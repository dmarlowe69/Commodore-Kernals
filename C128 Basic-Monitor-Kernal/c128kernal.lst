
; 64tass Turbo Assembler Macro V1.53.1515 listing file
; 64tass -L c128kernal.lst -o c128kernal.prg c128kernal.asm
; Tue Apr 24 18:44:21 2018

;Offset	;Hex		;Monitor	;Source

;******  Processing input file: c128kernal.asm

=0					KEYBOARD = 0
=$02					C_ULINE = $02  ; Underline On
=$0a					LF      = $0a  ; Line Feed
=$0d					CR      = $0d  ; Carriage Return
=$0f					BLINK   = $0f  ; Blinking On
=$11					DOWN    = $11  ; Cursor Down
=$12					REVERSE = $12  ; Reverse Printing
=$13					HOME    = $13  ; Cursor Home
=$14					DEL     = $14  ; Delete
=$1b					ESC     = $1b  ; Escape
=$1d					RIGHT   = $1d  ; Cursor Right
=$22					QUOTE   = $22  ; String Delimiter
=$27					APOSTR  = $27  ; Apostroph
=$91					UP      = $91  ; Cursor Up
=$ff					PICHAR  = $ff  ; BASIC Real_PI character
=$00					D8502   = $00  ; CPU 8502 register
=$01					R8502   = $01  ; CPU 8502 register
=$02					BANK    = $02  ; Bank configuration
=$03					PC_HI   = $03
=$04					PC_LO   = $04
=$05					S_REG   = $05
=$06					A_REG   = $06
=$07					X_REG   = $07
=$08					Y_REG   = $08
=$09					CHARAC  = $09
=$0a					ENDCHR  = $0a       ; scan quotes flag
=$0b					TRMPOS  = $0b       ; TAB column save
=$0c					B_VERCK = $0c       ; BASIC load/verify flag, 0 = load, 1 = verify
=$0d					B_COUNT = $0d       ; BASIC line crunch/array access/logic operators
=$0e					DIMFLG  = $0e       ; DIM flag
=$0f					VALTYP  = $0f       ; data type flag, $FF = string, $00 = numeric
=$10					INTFLG  = $10
=$11					GARBFL  = $11
=$12					SUBFLG  = $12
=$13					INPFLG  = $13
=$14					TANSGN  = $14       ; ATN sign/comparison evaluation flag
=$15					CHANNL  = $15
=$16					LINNUM  = $16       ; WORD: line number
=$18					TEMPPT  = $18       ; descriptor stack pointer, next free
=$19					LASTPT  = $19       ; current descriptor stack item pointer
=$1b					TEMPST  = $1b       ; (9 bytes): temporary descriptor stack
=$24					INDEXA  = $24       ; WORD: miscellaneous pointer
=$26					INDEXB  = $26       ; WORD: miscellaneous pointer
=$28					FAC3_M1 = $28
=$29					FAC3_M2 = $29
=$2a					FAC3_M3 = $2a
=$2b					FAC3_M4 = $2b
=$2d					TXTTAB  = $2d       ; WORD: Text Table
=$2f					VARTAB  = $2f       ; WORD: Variable Table
=$31					ARYTAB  = $31       ; WORD: Array Table
=$33					STREND  = $33       ; WORD: String End
=$35					FRETOP  = $35       ; WORD: Free Top of memory
=$37					FRESPC  = $37       ; WORD: Free Space
=$39					MEMSIZ  = $39       ; WORD: Memory Size
=$3b					CURLIN  = $3b       ; WORD: Current Line
=$3d					TXTPTR  = $3d       ; WORD: Text Pointer
=$3f					FNDPNT  = $3f       ; WORD: Find Pointer
=$41					DATLIN  = $41       ; WORD: Data Line
=$43					DATPTR  = $43       ; WORD: Data Pointer
=$45					INPPTR  = $45       ; WORD: Input Pointer
=$47					VARNAM  = $47       ; WORD: Variable Name
=$49					VARPNT  = $49       ; WORD: Variable Pointer
=$4b					FORPNT  = $4b       ; WORD: FOR Pointer
=$4d					VARTXT  = $4d       ; WORD: Variable Text Pointer
=$4f					OP_TMP  = $4f       ; Operator Temporary storage
=$50					GRBPNT  = $50       ; WORD: Garbage collection Pointer
=$52					DSCPNT  = $52       ; WORD: Descriptor Pointer
=$55					HELPER  = $55
=$56					JUMPER  = $56       ; 3 BYTES: JMP nnnn
=$58					OLDOV   = $58       ; Old Operator Value
=$59					FACTPA  = $59       ; 5 BYTES: Temporary Floating Point Accumulator A
=$5a					ARYPNT  = $5a       ; WORD: Array Pointer
=$5c					HIGHTR  = $5c       ; WORD:
=$5d					DESCA   = $5d       ; 3 bytes for temporary descriptor
=$5e					FACTPB   = $5e      ; 5 BYTES: Temporary Floating Point Accumulator B
=$5f					TMPVAR   = $5f      ; temporary variable
=$60					TENEXP   = $60      ; 10th's exponent
=$61					LOWTR    = $61      ; temporaray pointer
=$60					M_Aval = $60      ; 3 BYTES (address + bank) used in monitor
=$63					M_Bval = $63      ; 3 BYTES (address + bank) used in monitor
=$66					M_Cval = $66      ; 3 BYTES (address + bank) used in monitor
=$63					FAC1_EX  = $63      ; FAC1 exponent
=$64					FAC1_M1  = $64      ; FAC1 mantissa 1
=$65					FAC1_M2  = $65      ; FAC1 mantissa 2
=$66					FAC1_M3  = $66      ; FAC1 mantissa 3
=$67					FAC1_M4  = $67      ; FAC1 mantissa 4
=$68					FAC1_SI  = $68      ; FAC1 sign
=$69					DEGREE   = $69
=$6a					FAC2_EX  = $6a
=$6b					FAC2_M1  = $6b
=$6c					FAC2_M2  = $6c
=$6d					FAC2_M3  = $6d
=$6e					FAC2_M4  = $6e
=$6f					FAC2_SI  = $6f
=$70					STRPTR  = $70       ; string pointer & FAC variables
=$71					FROUND  = $71       ; FAC1 mantissa 5 = rounding byte
=$72					STRNG2  = $72       ; temp BASIC execute/array pointer low byte/index
=$74					AUTINC  = $74       ; WORD: auto increment value (0 = OFF)
=$76					MVDFLG  = $76       ; (graphics) memory reserved flag
=$77					TEMP_A  = $77       ; temporary byte value
=$78					KEYSIZ  = $78       ; string length and counter
=$79					SYNTMP  = $79       ; short term temporary value
=$7a					DS_LEN  = $7a       ; length  of DS$ (disk status)
=$7b					DS_ADR  = $7b       ; address of DS$ (disk status)
=$7d					TOS     = $7d       ; Top Of Basic Stack
=$7f					RUNMOD  = $7f       ; $80 = RUN [line], $40 = RUN <filename>, $00 = direct
=$80					DOSFLA  = $80       ; DOS flags A
=$81					DOSFLB  = $81       ; DOS flags B
=$82					OLDSTK  = $82       ; save stack pointer
=$83					COLSEL  = $83       ; color selected
=$84					MULCO1  = $84       ; multi color 1
=$85					MULCO2  = $85       ; multi color 2
=$86					FG_COL  = $86       ; foreground color
=$87					SCALE_X = $87       ; graphics scale X
=$89					SCALE_Y = $89       ; graphics scale Y
=$8b					STOPNB  = $8b       ; PAINT comparison byte
=$8c					GRAPNT  = $8c       ; Graphics Pointer
=$8e					VTEMPA  = $8e       ; Temporaray pointer
=$90					STATUS  = $90
=$91					STKEY   = $91       ; STOP key flag
=$92					SVXT    = $92       ; tape timer
=$93					K_VERCK = $93       ; verify flag and monitor variable
=$94					C3PO    = $94       ; serial buffer flag
=$95					BSOUR   = $95       ; serial output buffer
=$96					SYNO    = $96       ; tape sync
=$97					XSAV    = $97       ; save X register
=$98					LDTND   = $98       ; open file count
=$99					DFLTN   = $99       ; input device number
=$9a					DFLTO   = $9a       ; output device number
=$9b					PRTY    = $9b       ; tape parity byte
=$9c					DPSW    = $9c       ; tape dipole switch
=$9d					MSGFLG  = $9d       ; kernal message flag
=$9e					PTR_LO  = $9e       ; pointer 1
=$9f					PTR_HI  = $9f       ; pointer 2
=$a0					JIFFY_CLOCK = $a0   ; 3 bytes jiffy clock at 50Hz (PAL) or 60Hz (NTSC)
=$a3					R2D2    = $a3       ; serial bus
=$a4					BSOUR1  = $a4       ; serial output buffer
=$a5					CNTDN   = $a5       ; count down
=$a6					BUFPT   = $a6       ; tape buffer pointer
=$a7					RSI_In_Bit = $a7    ; RS232 Input bit
=$a8					RSI_Count  = $a8    ; RS232 Input bit counter
=$a9					RSI_Start  = $a9    ; RS232 Input start bit
=$aa					RSI_Data   = $aa    ; RS232 Input data byte
=$ab					RSI_Parity = $ab    ; RS232 Input parity
=$ac					SAL     = $ac       ; Start Address Low
=$ad					SAH     = $ad       ; Start Address High
=$ae					EAL     = $ae       ; End   Address Low
=$af					EAH     = $af       ; End   Address Hig
=$b0					CMP0    = $b0       ; tape timer
=$b1					CMP1    = $b1       ; tape timer
=$b2					TAPE1    = $b2      ; tape buffer pointer
=$b4					RS_Count = $b4      ; RS232 output character bit counter
=$b5					RS_Next  = $b5      ; RS232 next bit to transfer
=$b6					RS_Out   = $b6      ; current RS232 output byte
=$b7					FNLEN     = $b7     ; filename length
=$b8					LA        = $b8     ; Local     Address
=$b9					SA        = $b9     ; Secondary Address
=$ba					FA        = $ba     ; First     Address (unit)
=$bb					FNADR     = $bb     ; file name Address
=$bd					RS_Parity = $bd     ; RS232 Output Parity
=$be					FSBLK     = $be     ; tape block counter
=$bf					DRIVE     = $bf
=$c0					CAS1      = $c0     ; tape drive motor flag
=$c1					STAL    = $c1       ; start address low
=$c2					STAH    = $c2       ; start address high
=$c3					MEMUSS  = $c3       ; temporary pointer
=$c5					DATA    = $c5       ; tape data byte
=$c6					BA      = $c6       ; bank for load/save/verify
=$c7					FNBANK  = $c7       ; bank for filename
=$c8					RIBUF   = $c8       ; pointer to RS232 input  buffer
=$ca					ROBUF   = $ca       ; pointer to ES232 output buffer
=$cc					KEYTAB  = $cc       ; pointer to keyboard decode table
=$ce					IMPARM  = $ce       ; used by PRIMM (print immediate) subroutine
=$d0					NDX     = $d0       ; number of keys buffered
=$d1					KYNDX   = $d1       ; function key text counter
=$d2					KEYIDX  = $d2       ; function key text index
=$d3					SHFLAG  = $d3       ; flag for SHIFT, CONTROL, C=
=$d4					SFDX    = $d4       ; index of key pressed
=$d5					LSTX    = $d5       ; index of last key (for repeat)
=$d6					CRSW    = $d6       ; CRT switch 0 = keyboard input, all else screen
=$d7					MODE_80 = $d7       ; screen mode $00 = 40 col, $80 = 80 col
=$d8					GRAPHM  = $d8       ; graphics mode
=$d9					CHAREN  = $d9       ; character RAM/ROM flag
=$da					E_Beg   = $da       ; Screen Editor Start Address
=$dc					E_End   = $dc       ; Screen Editor End   Address
=$de					E_Col   = $de       ; Screen Editor Temporary Variable
=$df					E_Row   = $df       ; Screen Editor Temporary Variable
=$e0					PNT     = $e0       ; Pointer to current text row
=$e2					USER    = $e2       ; Pointer to text attribute
=$e4					Margin_Bottom = $e4 ; SCBOT  default = 24
=$e5					Margin_Top    = $e5 ; SCTOP  default =  0
=$e6					Margin_Left   = $e6 ; SCLF   default =  0
=$e7					Margin_Right  = $e7 ; SCRT   default = 39 or 79
=$e8					CurLst_Row    = $e8 ; LSXP   last cursor row (bit 7 = continuation row)
=$e9					CurLst_Col    = $e9 ; LSTP   last cursor column
=$ea					Cursor_End    = $ea ; INDX   Input end column (default = last non blank)
=$eb					Cursor_Row    = $eb ; TBLX   current cursor row
=$ec					Cursor_Col    = $ec ; PNTR   current cursor column
=$ed					LINES   = $ed       ; Screen lines
=$ee					COLUMNS = $ee       ; Screen columns
=$ef					DATAX   = $ef       ; Output character
=$f0					LSTCHR  = $f0       ; Last character
=$f1					E_Attribute   = $f1 ; Color/Attribute
=$f2					TCOLOR  = $f2       ; Color/Attribute for Insert
=$f3					E_Reverse     = $f3 ; Reverse flag
=$f4					QTSW    = $f4       ; Quote switch
=$f5					INSRT   = $f5       ; Insert mode
=$f6					INSFLG  = $f6       ; Automatic insert
=$f7					LOCKS   = $f7       ; Commodore/Shift lock
=$f8					Scroll_Locked = $f8 ; Scroll lock
=$f9					BEEPER  = $f9       ; Beeper mode
=$0100					STACK   = $0100     ; CPU runtime stack
=$0110					DOS_COUNT   = $0110 ; length of format string
=$0111					DOS_FNLEN_1 = $0111 ; length of 1st. filename
=$0112					DOS_DRIVE_1 = $0112 ; drive # 1 (0 for single drive units)
=$0113					DOS_FNLEN_2 = $0113 ; length of 2nd. filename
=$0114					DOS_DRIVE_2 = $0114 ; drive # 2 (0 for single drive units)
=$0115					DOS_FNADR_2 = $0115 ; address of 2nd. filename
=$0117					DOS_BEG     = $0117 ; start address for BSAVE, BLOAD
=$0119					DOS_END     = $0119 ; end   address for BSAVE
=$011b					DOS_LA      = $011b ; Logical   Address for file operations
=$011c					DOS_FA      = $011c ; First     Address (unit)
=$011d					DOS_SA      = $011d ; Secondary Address (0 = relocatble LOAD)
=$011e					DOS_RL      = $011e ; Record Length for REL files
=$011f					DOS_BANK    = $011f ; Bank for LOAD/SAVE
=$0120					DOS_ID      = $0120 ; ID (two characters) for HEADER
=$0122					DOS_UNIT    = $0122 ; 2nd. unit for unit to unit COPY
=$0123					BNR         = $0123 ; begin pointer
=$0124					ENR         = $0124 ; end   pointer
=$0125					DOLR        = $0125 ; dollar flag
=$0126					FLAG        = $0126 ; comma  flag
=$0127					SWE         = $0127 ; counter
=$0128					USGN        = $0128 ; exponent sign
=$0129					UEXP        = $0129 ; exponent pointer
=$012a					VN          = $012a ; digits before decimal point
=$012b					CHSN        = $012b ; adjust flag
=$012c					VF          = $012c ; chars  before decimal point
=$012d					NF          = $012d ; chars  after  decimal point
=$012e					POSP        = $012e ; +/- flag position
=$012f					FESP        = $012f ; exponent flag
=$0130					ETOF        = $0130 ; switch
=$0131					CFORM       = $0131 ; counter
=$0132					SNO         = $0132 ; sign number
=$0133					BLFD        = $0133 ; space star flag
=$0134					BEGFD       = $0134 ; begin pointer
=$0135					LFOR        = $0135 ; length of format string
=$0136					ENDFD       = $0136 ; end pointer
=$0200					BUF         = $0200 ; 161 bytes
=$02a2					  FETCH = $02a2
=$02af					  STASH = $02af
=$02be					  CMPARE = $02be
=$02cd					  JSRFAR = $02cd
=$02e3					  JMPFAR = $02e3
=$02fc					USRVEC  = $02fc     ; pointer to user defined machine code
=$0300					IERROR  = $0300     ; DEF_ERROR   BASIC error handler
=$0302					IMAIN   = $0302     ; DEF_MAIN    BASIC main loop
=$0304					ICRNCH  = $0304     ; DEF_CRUNCH  BASIC tokenizer
=$0306					IQPLOP  = $0306     ; DEF_QPLOP   BASIC statement lister
=$0308					IGONE   = $0308     ; DEF_GONE    BASIC interpret statement
=$030a					IEVAL   = $030a     ; DEF_EVAL    BASIC evaluate expressiom
=$030c					IESCLK  = $030c     ; DEF_ESCLK
=$030e					IESCPR  = $030e     ; DEF_ESCPR
=$0310					IESCEX  = $0310     ; DEF_ESCEX
=$0314					IIRQ    = $0314     ; IRQ_Normal
=$0316					IBRK    = $0316     ; Mon_Break
=$0318					INMI    = $0318     ; NMI_Normal
=$031a					IOPEN   = $031a     ; OPEN
=$031c					ICLOSE  = $031c     ; CLOSE
=$031e					ICHKIN  = $031e     ; CHKIN
=$0320					ICKOUT  = $0320     ; CKOUT
=$0322					ICLRCH  = $0322     ; CLRCH
=$0324					IBASIN  = $0324     ; BASIN
=$0326					IBSOUT  = $0326     ; BSOUT
=$0328					ISTOP   = $0328     ; STOP
=$032a					IGETIN  = $032a     ; GEIIN
=$032c					ICLALL  = $032c     ; CLALL
=$032e					EXMON   = $032e     ; Mon_Command
=$0330					ILOAD   = $0330     ; D_LOADSP
=$0332					ISAVE   = $0332     ; D_SAVE
=$0334					CTLVEC  = $0334     ; Edit_Use_Ctrl
=$0336					SHFVEC  = $0336     ; Edit_Print_Shifted
=$0338					ESCVEC  = $0338     ; Edit_Escape_Switch
=$033a					KEYVEC  = $033a     ; Edit_Use_Scancode
=$033c					KEYCHK  = $033c     ; Edit_Use_Function_Key
=$033e					DECODE  = $033e
=$034a					KEYD    = $034a     ; keyboard buffer 10 bytes
=$0354					TABMAP  = $0354     ; bitmap for 80 TAB positions (10 bytes)
=$035e					BITABL  = $035e     ; bitmap for line concatenation flag (4 bytes)
=$0362					LAT     = $0362     ; table of logical   addresses
=$036c					FAT     = $036c     ; table of first     addresses
=$0376					SAT     = $0376     ; table of secondary addresses
=$0380					  CHRGET = $0380
=$0386					  CHRGOT = $0386
=$0390					  ISNUM = $0390
=$039f					  Fetch_0 = $039f
=$03ab					  Fetch_1 = $03ab
=$03b7					  Get_INDEXA_1 = $03b7
=$03c0					  Get_INDEXB_0 = $03c0
=$03c9					  INDTXT = $03c9
=$03d2					NULL_DESC = $03d2   ; These 3 bytes must contain zeroes permanently
=$03d5					USER_BANK = $03d5   ; User defined bank configuration
=$03d6					TMPDES    = $03d6   ; space for two temporary address pointer
=$03da					STR_BANK  = $03da   ; bank for string to be parsed
=$03db					SAVSIZ    = $03db   ; string descriptor for sprite storage
=$03df					BITS      = $03df   ; FAC1 overflow
=$03e0					SPRTMP    = $03e0   ; temporary storage for TXTPTR
=$03e2					FG_BG     = $03e2   ; foreground background nibbles combined
=$03e3					FG_MC1    = $03e3   ; foreground multicolor 1
=$03f0					  RAM_DMA = $03f0
=$0400					VIC_TEXT      = $0400 ; bank 0 : 40 x 25 charcters ($400 - $7e7)
=$0400					VAR_START     = $0400 ; bank 1 : start of BASIC variable storage
=$0800					BASIC_STACK   = $0800 ; 512 byte stack for loops and GOSUB calls
=$0a00					RESET_VECTOR  = $0a00 ; used for cold start and monitor exit
=$0a02					DEJAVU        = $0a02 ; a value of $a5 indicates, that the routine had been run
=$0a03					PALNTS        = $0a03 ; $ff = PAL (50 hz),  $00 = NTSC (60 Hz)
=$0a04					INIT_STATUS   = $0a04 ; RESET and NMI status
=$0a05					MEM_BOT       = $0a05 ; bottom of banked RAM, default = $1c00
=$0a07					MEM_TOP       = $0a07 ; top    of banked RAM, default = $ff00
=$0a09					IRQTMP        = $0a09 ; save value of (IIRQ) here
=$0a0b					CASTON        = $0a0b ; timing value for tape operations
=$0a0c					KIKA26        = $0a0c ; temporary storage for tape operations
=$0a0d					STUPID        = $0a0d
=$0a0e					TIMOUT        = $0a0e
=$0a0f					RS_Enable     = $0a0f ; Enable RS232 interface
=$0a10					RS_Control    = $0a10 ; Control register
=$0a11					RS_Command    = $0a11 ; Command register
=$0a12					RS_Baudrate   = $0a12 ; Baudrate
=$0a14					RS_Status     = $0a14 ; Status
=$0a15					RS_Bits       = $0a15 ; Length of character
=$0a16					RS_Timer_Lo   = $0a16 ; Baudrate corrected for TIMER low
=$0a17					RS_Timer_Hi   = $0a17 ; Baudrate corrected for TIMER high
=$0a18					RS_IBP_End    = $0a18 ; Input  Buffer Pointer End
=$0a19					RS_IBP_Beg    = $0a19 ; Input  Buffer Pointer Begin
=$0a1a					RS_OBP_Beg    = $0a1a ; Output Buffer Pointer Begin
=$0a1b					RS_OBP_End    = $0a1b ; Output Buffer Pointer End
=$0a1c					Fast_IEC      = $0a1c ; Flag for fast IEC I/O
=$0a1d					JIFFY_COUNTDOWN         = $0a1d ; 3 byte jiffy clock
=$0a20					XMAX          = $0a20 ; max. length of keyboard queue (10)
=$0a21					PAUSE         = $0a21 ; Ctrl-S flag
=$0a22					RPTFLG        = $0a22 ; repeat flag: $80 = all, $40 = no, $00 = cursor
=$0a23					KOUNT         = $0a23 ; repeat speed delay (default = 4)
=$0a24					DELAY         = $0a24 ; initial repeat delay (default = 10)
=$0a25					LSTHF         = $0a25 ; Commodore-Shift dleay (default = 8)
=$0a26					BLNON         = $0a26 ; $40 = non blinking cursor
=$0a27					BLNSW         = $0a27 ; $00 = blinking on
=$0a28					BLNCT         = $0a28 ; blink count
=$0a29					GDBLN         = $0a29 ; save charcter under cursor
=$0a2a					GDCOL         = $0a2a ; save color    under cursor
=$0a2b					CURMOD        = $0a2b ; Cursor Mode
=$0a2c					VSH_TEXT      = $0a2c ; VIC text      page
=$0a2d					VSH_BITMAP    = $0a2d ; VIC bitmap    page
=$0a2e					VDC_RAM_PAGE  = $0a2e ; VDC text      page
=$0a2f					VDC_ATT_PAGE  = $0a2f ; VDC attribute page
=$0a30					LINTMP        = $0a30 ; temporary variable
=$0a31					VDC_ROW       = $0a31 ; temporary row
=$0a32					VDC_COL       = $0a32 ; temporary column
=$0a33					VDC_ATT       = $0a33 ; temporary attribute
=$0a34					VSH_SPLIT     = $0a34 ; VIC split shadow register
=$0a35					FN_SAVE_X     = $0a35 ; Save X register while accessing filename
=$0a36					PAL_ADJ       = $0a36 ; adjust jiffy clock running at 50 Hz
=$0a37					VSH_SPEED     = $0a37 ; VIC system speed
=$0a38					VSH_SPR_ENA   = $0a38 ; VIC sprites enabled
=$0a39					VSH_Ctrl_1    = $0a39 ; VIC control register 1
=$0a3a					SPRITES       = $0a3a ; sprite enable flag
=$0a3b					VIC_RAM_PAGE  = $0a3b ; start of VIC text RAM
=$0a3c					VDC_UPDATE_LO = $0a3c ; pointer to VDC RAM
=$0a3d					VDC_UPDATE_HI = $0a3d ; pointer to VDC RAM
=$0a40					ZP_SW_COL     = $0a40 ; swap area for alternate screen
=$0a60					SWPMAP        = $0a60 ; swap area for tab positions
=$0a80					M_Data        = $0a80  ; 32 bytes for hunt string
=$0aa0					M_Operand     = $0aa0  ; 10 bytes for operand
=$0aaa					M_Format      = $0aaa  ; bit pattern describing operand syntax
=$0aab					M_Op_Size     = $0aab  ; length of operand (0,1 or 2)
=$0aac					M_Mne         = $0aac  ; 3 bytes for assembler mnemonic
=$0aaf					M_Save_XR     = $0aaf  ; save X register
=$0ab1					M_Opcode      = $0ab1  ; opcode for assembler/disassembler
=$0ab2					M_Save_X      = $0ab2  ; save X register during banked RAM access
=$0ab3					M_Dir         = $0ab3  ; direction of memory block transfer
=$0ab4					M_Count       = $0ab4  ; unread bytes in input
=$0ab5					M_Number      = $0ab5  ; temporary variable
=$0ab6					M_Shift       = $0ab6  ; shifts for number conversion
=$0ab7					M_Temp        = $0ab7  ; temporary 20 bit value
=$0ac0					Module_Bank   = $0ac0  ; current bank for ROM module
=$0ac1					Module_Flags  = $0ac1  ; ROM module initialization flags
=$0ac5					DINFLAG       = $0ac5  ; ASCII/DIN mode and accent flag
=$0b00					T_Buffer      = $0b00  ; 256 bytes tape buffer
=$0c00					R_Rece_Buffer = $0c00  ; 256 bytes RS232 serial receive buffer
=$0d00					R_Send_Buffer = $0d00  ; 256 bytes RS232 serial send    buffer
=$1000					PKYBUF        = $1000  ;  10 bytes for programmable function keys
=$100a					PKYDEF        = $100a  ; 246 bytes for function key assignment
=$1100					DOSSTR        = $1100  ;  49 bytes for DOS command/open string
=$1131					XPOS          = $1131  ; position
=$1133					YPOS          = $1133
=$1135					XDEST         = $1135  ; destination
=$1137					YDEST         = $1137
=$1139					XABS          = $1139  ; absolute value
=$113b					YABS          = $113b
=$113d					XSGN          = $113d  ; sign
=$113f					YSGN          = $113f
=$1141					FCT           = $1141
=$1145					ERRVAL        = $1145
=$1147					LESSER        = $1147
=$1148					GREATR        = $1148
=$1149					ANGSGN        = $1149  ; quadrant
=$114a					SINVAL        = $114a  ;   sine value in 16 bit floating point
=$114c					COSVAL        = $114c  ; cosine value in 16 bit floating point
=$114e					ANGCNT        = $114e
=$1150					XCIRCL        = $1150
=$1152					YCIRCL        = $1152
=$1154					XRADIUS       = $1154
=$1156					YRADIUS       = $1156
=$1158					ROTANG        = $1158
=$115a					YDIST2        = $115a
=$115c					ANGBEG        = $115c
=$115e					ANGEND        = $115e
=$1160					XRCOS         = $1160
=$1162					YRSIN         = $1162
=$1164					XRSIN         = $1164
=$1166					YRCOS         = $1166
=$1168					CHRPAG        = $1168
=$1169					BITCNT        = $1169
=$116a					SCALEM        = $116a
=$116b					WIDTH         = $116b
=$116c					FILFLG        = $116c
=$116d					BITMSK        = $116d
=$116e					NUMCNT        = $116e
=$116f					TRCFLG        = $116f
=$1170					Ren_Line_Lo   = $1170
=$1171					Ren_Line_Hi   = $1171
=$1172					Ren_Step_Lo   = $1172
=$1173					Ren_Step_Hi   = $1173
=$1174					T3            = $1174  ; used in MOVSPR and DIRECTORY
=$1175					T4            = $1175
=$1176					T5            = $1176
=$1177					VTEMP3        = $1177  ; used in LAY_MUL_X
=$1178					VTEMP4        = $1178  ; used in Get_Coordinates
=$1179					Rel_Abs_Flag  = $1179  ; realtive or absolut plot mode
=$117a					ADRAY1        = $117a  ; pointer to FAC1_To_Int_AY
=$117c					ADRAY2        = $117c  ; pointer to Integer_To_Real
=$117e					SPRITE_DATA   = $117e
=$11d6					VSH           = $11d6    ; shadow of VIC = $d000
=4583					VSH_SS_COLL   = VSH + 17 ; sprite/sprite collision
=4585					VSH_LPX       = VSH + 19 ; light pen x
=4586					VSH_LPY       = VSH + 20 ; light pen y
=$11eb					CHARGEN_TEXT  = $11eb    ; character generator page for text     = $d8
=$11ec					CHARGEN_GRAF  = $11ec    ; character generator page for graphics = $d0
=$11ed					REC_SA        = $11ed    ; secondary address for RECORD command
=$1200					OLDLIN        = $1200    ; old line number
=$1202					OLDTXT        = $1202    ; old interpreter ointer
=$1204					PU_FILL       = $1204    ; default ' ' : print using fill character
=$1205					PU_COMMA      = $1205    ; default ',' : print using separator
=$1206					PU_DOT        = $1206    ; default '.' : print using decimal dot
=$1207					PU_MONEY      = $1207    ; default '$' : print using currency symbol
=$1208					ERRNUM        = $1208    ; error number ($ff = no error)
=$1209					ERRLIN        = $1209    ; linenumber of error
=$120b					TRAPNO        = $120b    ; linenumber for error trap ($ffxx = no trap)
=$120d					TMPTRP        = $120d    ; obsolete
=$120e					ERRTXT        = $120e    ; pointer to error position in BASIC source
=$1210					TEXT_TOP      = $1210    ; top of current   BASIC program text
=$1212					TEXT_MAX      = $1212    ; top of available BASIC program text
=$1214					TEXT_TMP      = $1214    ; temporary TEXT pointer
=$1216					TEXT_LIN      = $1216    ; temporary LINE number storage
=$1218					FUNC_USR      = $1218    ; JMP ($4c) and address for USR function
=$121b					RNDX          = $121b    ; last used random number as 5 byte float
=$1220					ARC_SEG       = $1220    ; plot intervall for plotting arcs or circles
=$1222					Snd_Tempo     = $1222    ; duration = 19.22 / Snd_Tempo [sec]
=$1223					Snd_Duration  = $1223    ; 16 bit duration for 3 voices
=$1229					Snd_Dur_Tmp   = $1229    ; 16 bit duration
=$122b					Snd_Octave    = $122b
=$122c					Snd_Sharp     = $122c
=$122d					Snd_Pitch     = $122d    ; 16 bit pitch
=$122f					VOICE = $122f
=$1230					WAVE0 = $1230
=$1233					DNOTE = $1233
=$1234					FLTSAV = $1234
=$1238					FLTFLG = $1238
=$1239					NIBBLE = $1239
=$123a					TONNUM = $123a
=$123b					TONVAL = $123b
=$123e					PARCNT = $123e
=$123f					ATKTAB = $123f
=$1249					SUSTAB = $1249
=$1253					WAVTAB = $1253
=$125d					PULSLO = $125d
=$1267					PULSHI = $1267
=$1271					FILTERS = $1271
=$1274					Old_Filter = $1274
=$1275					Old_Volume = $1275
=$1276					INT_TRIP_FLAG = $1276
=$1278					Light_Pen_Flag = $1278
=$1279					INT_ADR_LO = $1279
=$127c					INT_ADR_HI = $127c
=$127f					INT_VAL = $127f
=$1280					Collision_Type      = $1280
=$1281					Voice_Number        = $1281
=$1282					Sound_Duration_1_Lo = $1282
=$1283					Sound_Duration_2_Lo = $1283
=$1284					Sound_Duration_3_Lo = $1284
=$1285					Sound_Duration_1_Hi = $1285
=$1286					Sound_Duration_2_Hi = $1286
=$1287					Sound_Duration_3_Hi = $1287
=$1288					SOUND_MAX_LO        = $1288
=$128b					SOUND_MAX_HI        = $128b
=$128e					SOUND_MIN_LO        = $128e
=$1291					SOUND_MIN_HI        = $1291
=$1294					SOUND_DIR           = $1294
=$1297					SOUND_STEP_LO       = $1297
=$129a					SOUND_STEP_HI       = $129a
=$129d					SOUND_FREQ_LO       = $129d
=$12a0					SOUND_FREQ_HI       = $12a0
=$12a3					TEMP_TIME_LO        = $12a3
=$12a4					TEMP_TIME_HI        = $12a4
=$12a5					TEMP_MAX_LO         = $12a5
=$12a6					TEMP_MAX_HI         = $12a6
=$12a7					TEMP_MIN_LO         = $12a7
=$12a8					TEMP_MIN_HI         = $12a8
=$12a9					TEMP_DIRECTION      = $12a9
=$12aa					TEMP_STEP_LO        = $12aa
=$12ab					TEMP_STEP_HI        = $12ab
=$12ac					TEMP_FREQ_LO        = $12ac
=$12ad					TEMP_FREQ_HI        = $12ad
=$12ae					TEMP_PULSE_LO       = $12ae
=$12af					TEMP_PULSE_HI       = $12af
=$12b0					TEMP_WAVEFORM       = $12b0
=$12b1					POT_IEMP_1          = $12b1
=$12b2					POT_IEMP_2          = $12b2
=$12b3					Win_XL              = $12b3
=$12b4					Win_YL              = $12b4
=$12b5					Win_XH              = $12b5
=$12b6					Win_YH              = $12b6
=$12b7					SAVRAM              = $12b7
=$12fa					DEFMOD = $12fa
=$12fb					LINCNT = $12fb
=$12fc					SPRNUM = $12fc
=$12fd					IRQ_ACTIVE_FLAG = $12fd
=$1c00					RAMBOT = $1c00
=$1c01					PROGRAM_START = $1c01
=$1c00					COLOR_RAM = $1c00
=$2000					GRAFX_RAM = $2000
=$3e00					V3e00 = $3e00
=$d000					VIC = $d000
=$dc00					CIA1         = $DC00 ; base address
=$dc00					CIA1_KBD_COL = $DC00 ; CIA1 Peripheral data Register A : keyboard column
=$dc01					CIA1_KBD_ROW = $DC01 ; CIA1 Peripheral data Register B : keyboard row
=$dc02					CIA1_DDRA  = $DC02   ; CIA1 Data Direction  Register A
=$dc03					CIA1_DDRB  = $DC03   ; CIA1 Data Direction  Register B
=$dc04					CIA1_TALO  = $DC04   ; CIA1 Timer A Low  register
=$dc05					CIA1_TAHI  = $DC05   ; CIA1 Timer A High register
=$dc06					CIA1_TBLO  = $DC06   ; CIA1 Timer B Low  register
=$dc07					CIA1_TBHI  = $DC07   ; CIA1 Timer B High register
=$dc08					CIA1_TODT  = $DC08   ; CIA1 Time Of Day 1/10 seconds
=$dc09					CIA1_TODS  = $DC09   ; CIA1 Time Of Day seconds
=$dc0a					CIA1_TODM  = $DC0A   ; CIA1 Time Of Day minutes
=$dc0b					CIA1_TODH  = $DC0B   ; CIA1 Time Of Day hours
=$dc0c					CIA1_SDR   = $DC0C   ; CIA1 Serial Data Register
=$dc0d					CIA1_ICR   = $DC0D   ; CIA1 Interrupt Control Register
=$dc0e					CIA1_CRA   = $DC0E   ; CIA1 Control Register A
=$dc0f					CIA1_CRB   = $DC0F   ; CIA1 Control Register B
=$dd00					CIA2       = $DD00 ; base address
=$dd00					CIA2_PRA   = $DD00   ; CIA2 Peripheral data Register A
=$dd01					CIA2_PRB   = $DD01   ; CIA2 Peripheral data Register B
=$dd02					CIA2_DDRA  = $DD02   ; CIA2 Data Direction  Register A
=$dd03					CIA2_DDRB  = $DD03   ; CIA2 Data Direction  Register B
=$dd04					CIA2_TALO  = $DD04   ; CIA2 Timer A Low  register
=$dd05					CIA2_TAHI  = $DD05   ; CIA2 Timer A High register
=$dd06					CIA2_TBLO  = $DD06   ; CIA2 Timer B Low  register
=$dd07					CIA2_TBHI  = $DD07   ; CIA2 Timer B High register
=$dd08					CIA2_TODT  = $DD08   ; CIA2 Time Of Day 1/10 seconds
=$dd09					CIA2_TODS  = $DD09   ; CIA2 Time Of Day seconds
=$dd0a					CIA2_TODM  = $DD0A   ; CIA2 Time Of Day minutes
=$dd0b					CIA2_TODH  = $DD0B   ; CIA2 Time Of Day hours
=$dd0c					CIA2_SDR   = $DD0C   ; CIA2 Serial Data Register
=$dd0d					CIA2_ICR   = $DD0D   ; CIA2 Interrupt Control Register
=$dd0e					CIA2_CRA   = $DD0E   ; CIA2 Control Register A
=$dd0f					CIA2_CRB   = $DD0F   ; CIA2 Control Register B
=$7f					CTRL_COL = %01111111 ; $7f = col 7
=$fb					CTRL_ROW = %11111011 ; $fb = row 2
=$7f					STND_COL = %01111111 ; $7f = col 7
=$dc0d					VIA2_IER = CIA1_ICR    ; CIA1 Interrupt Control Register
=$dc07					VIA2_T2CH= $DC07
=$dc06					VIA2_T2CL= $DC06
=$dc04					VIA2_T1CL= $DC04
=$dc05					VIA2_T1CH= $DC05
=40					COLS          =  40
=25					ROWS          =  25
=2					COLINK        =   2
=80					COLMAX        =  80
=$d8					COLRAM_PAGE   = $D8
=14					Default_Color = 14   ; Light blue
=$d018					MEM_CONTROL   = $D018
=$dc07					IEC_TIM_H     = $DC07; CIA 1 TIH, timer high
=$dc0d					IEC_IFR       = CIA1_ICR    ; CIA 1 CRB, interrupt flag register
=$dd00					IEC_PCR       = $DD00; VIA 2 peripheral control register (PCR)
=$dd00					IEC_DRAN      = $DD00; CIA 2 DRA, IEC bus
=$dd01					RS2_DSR_CTS   = $DD01
=$dd0d					RS2_IRQ_REG   = CIA2_ICR
=$dd04					RS2_TIM_LOW   = $DD04
=$dd05					RS2_TIM_HIG   = $DD05
=$08					IEC_ATN_BIT   = $08
=$02					IEC_IFR_BIT   = $02
=$10					IEC_CLK_BIT   = %00010000; $10
=$20					IEC_DAT_BIT   = %00100000; $20
=$04					RS232_C_BIT   = %00000100; $04
=$d011					VIC_Ctrl_1  = $d011    ; VIC control register 1
=$d012					VIC_RASTER  = $d012
=$d013					VIC_LPX     = $d013
=$d014					VIC_LPY     = $d014
=$d015					VIC_SPR_ENA = $d015
=$d016					VIC_Ctrl_2  = $d016
=$d018					VIC_Memory  = $d018
=$d019					VIC_IRQ_REG = $d019
=$d01a					VIC_IRQ_ENA = $d01a
=$d01c					Vd01c = $d01c
=$d01e					VIC_SS_COLL = $d01e
=$d020					Vd020 = $d020
=$d021					VIC_BG_COL = $d021
=$d025					Vd025 = $d025
=$d026					Vd026 = $d026
=$d027					Vd027 = $d027
=$d02f					VIC_KBD = $d02f
=$d030					VIC_SPEED = $d030
=$d400					SID_Freq_1 = $d400
=$d402					SID_Pulse_1 = $d402
=$d404					SID_Control_1 = $d404
=$d405					SID_Attack_1 = $d405
=$d406					SID_Sustain_1 = $d406
=$d407					SID_Freq_2 = $d407
=$d409					SID_Pulse_2 = $d409
=$d40b					SID_Control_2 = $d40b
=$d40c					SID_Attack_2 = $d40c
=$d40d					SID_Sustain_2 = $d40d
=$d40e					SID_Freq_3 = $d40e
=$d410					SID_Pulse_3 = $d410
=$d412					SID_Control_3 = $d412
=$d413					SID_Attack_3 = $d413
=$d414					SID_Sustain_3 = $d414
=$d415					SID_Cutoff = $d415
=$d417					SID_Resonance = $d417
=$d418					SID_Volume = $d418
=$d419					SID_POT_X = $d419
=$d500					MMU_CONT = $d500
=$d501					MMU_PCRA = $d501
=$d505					MMU_MODE = $d505
=$d506					MMU_RAMC = $d506
=$d600					VDC_Register = $d600
=$d601					VDC_Data = $d601
=$d800					VIC_COLOR_RAM = $d800
=$df00					DMA_BASE   = $df00
=$df01					DMA_CMD    = $df01
=$df02					DMA_CBM_LO = $df02
=$df03					DMA_CBM_HI = $df03
=$df04					DMA_REU_LO = $df04
=$df05					DMA_REU_HI = $df05
=$df06					DMA_REU_BA = $df06
=$df07					DMA_CNT_LO = $df07
=$df08					DMA_CNT_HI = $df08
.4000					  B_Cold_Start
.4000	4c 23 40	jmp $4023	          JMP Cold_Start
.4003					  B_Warm_Start
.4003	4c 09 40	jmp $4009	          JMP Warm_Start
.4006					  B_BASIC_IRQ
.4006	4c 4d a8	jmp $a84d	          JMP BASIC_IRQ
.4009					  Warm_Start
.4009	20 cc ff	jsr $ffcc	          JSR K_CLRCH
.400c	20 7a 41	jsr $417a	          JSR Init_MMU
.400f	20 8d 41	jsr $418d	          JSR Stop_Sprites
.4012	20 12 41	jsr $4112	          JSR Init_SID
.4015	20 38 52	jsr $5238	          JSR Init_BASIC_Stack
.4018	a9 00		lda #$00	          LDA #0 ; keyboard channel
.401a	85 15		sta $15		          STA CHANNL
.401c	58		cli		Go_Ready  CLI
.401d	4c 37 4d	jmp $4d37	          JMP BASIC_Ready
>4020	00 ff ff			          .BYTE $00,$ff,$ff ; unused
.4023					  Cold_Start
.4023	20 7a 41	jsr $417a	          JSR Init_MMU
.4026	20 51 42	jsr $4251	          JSR Init_RAM_Vectors
.4029	20 45 40	jsr $4045	          JSR Init_BASIC
.402c	20 9b 41	jsr $419b	          JSR Show_Startup_Message
.402f	ad 04 0a	lda $0a04	          LDA INIT_STATUS
.4032	09 01		ora #$01	          ORA #1
.4034	8d 04 0a	sta $0a04	          STA INIT_STATUS
.4037	a2 03		ldx #$03	          LDX #<B_Warm_Start
.4039	8e 00 0a	stx $0a00	          STX RESET_VECTOR    ; switch from cold to warm start
.403c	a2 fb		ldx #$fb	          LDX #$fb
.403e	9a		txs		          TXS
.403f	20 56 ff	jsr $ff56	          JSR K_PHOENIX
.4042	4c 1c 40	jmp $401c	          JMP Go_Ready
.4045					  Init_BASIC
.4045	a9 4c		lda #$4c	          LDA #$4c ; JMP instruction
.4047	85 56		sta $56		          STA JUMPER
.4049	8d 18 12	sta $1218	          STA FUNC_USR
.404c	a9 28		lda #$28	          LDA #<Error_Illegal_Quantity
.404e	a0 7d		ldy #$7d	          LDY #>Error_Illegal_Quantity
.4050	8d 19 12	sta $1219	          STA FUNC_USR+1
.4053	8c 1a 12	sty $121a	          STY FUNC_USR+2
.4056	a9 9f		lda #$9f	          LDA #<FAC1_To_Int_AY
.4058	a0 84		ldy #$84	          LDY #>FAC1_To_Int_AY
.405a	8d 7a 11	sta $117a	          STA ADRAY1
.405d	8c 7b 11	sty $117b	          STY ADRAY1+1
.4060	a9 3c		lda #$3c	          LDA #<Integer_To_Real
.4062	a0 79		ldy #$79	          LDY #>Integer_To_Real
.4064	8d 7c 11	sta $117c	          STA ADRAY2
.4067	8c 7d 11	sty $117d	          STY ADRAY2+1
.406a	a2 55		ldx #$55	          LDX #$55 ; 'U'
.406c	bd 78 42	lda $4278,x	InBA_10   LDA ROM_CHRGET-1,X
.406f	9d 7f 03	sta $037f,x	          STA CHRGET-1,X
.4072	ca		dex		          DEX
.4073	d0 f7		bne $406c	          BNE InBA_10
.4075	8e df 03	stx $03df	          STX BITS
.4078	86 15		stx $15		          STX CHANNL
.407a	86 1a		stx $1a		          STX LASTPT+1
.407c	8e 6f 11	stx $116f	          STX TRCFLG
.407f	8e 00 1c	stx $1c00	          STX RAMBOT
.4082	86 76		stx $76		          STX MVDFLG
.4084	86 74		stx $74		          STX AUTINC
.4086	86 75		stx $75		          STX AUTINC+1
.4088	8e 6b 11	stx $116b	          STX WIDTH
.408b	8e 6a 11	stx $116a	          STX SCALEM
.408e	8e 6c 11	stx $116c	          STX FILFLG
.4091	8e 1b 12	stx $121b	          STX RNDX
.4094	8e 1c 01	stx $011c	          STX DOS_FA
.4097	8e 76 12	stx $1276	          STX INT_TRIP_FLAG
.409a	8e 77 12	stx $1277	          STX INT_TRIP_FLAG+1
.409d	8e 78 12	stx $1278	          STX Light_Pen_Flag
.40a0	8e 7f 12	stx $127f	          STX INT_VAL
.40a3	a0 58		ldy #$58	          LDY #$58 ; 'X'
.40a5	99 7e 11	sta $117e,y	InBA_20   STA SPRITE_DATA,Y
.40a8	88		dey		          DEY
.40a9	10 fa		bpl $40a5	          BPL InBA_20
.40ab	e8		inx		          INX
.40ac	8e fd 01	stx $01fd	          STX BUF-3
.40af	8e fc 01	stx $01fc	          STX BUF-4
.40b2	a2 0f		ldx #$0f	          LDX #15
.40b4	8e d5 03	stx $03d5	          STX USER_BANK
.40b7	a2 0d		ldx #$0d	          LDX #13
.40b9	86 86		stx $86		          STX FG_COL
.40bb	a2 01		ldx #$01	          LDX #1
.40bd	86 84		stx $84		          STX MULCO1
.40bf	a2 02		ldx #$02	          LDX #2
.40c1	86 85		stx $85		          STX MULCO2
.40c3	20 5c 6a	jsr $6a5c	          JSR setpcl
.40c6	a2 1b		ldx #$1b	          LDX #$1b
.40c8	86 18		stx $18		          STX TEMPPT
.40ca	a2 01		ldx #$01	          LDX #<PROGRAM_START
.40cc	a0 1c		ldy #$1c	          LDY #>PROGRAM_START
.40ce	86 2d		stx $2d		          STX TXTTAB
.40d0	84 2e		sty $2e		          STY TXTTAB+1
.40d2	a9 00		lda #$00	          LDA #<VAR_START
.40d4	a0 04		ldy #$04	          LDY #>VAR_START
.40d6	85 2f		sta $2f		          STA VARTAB
.40d8	84 30		sty $30		          STY VARTAB+1
.40da	a9 00		lda #$00	          LDA #<MMU_CR
.40dc	a0 ff		ldy #$ff	          LDY #>MMU_CR
.40de	8d 12 12	sta $1212	          STA TEXT_MAX
.40e1	8c 13 12	sty $1213	          STY TEXT_MAX+1
.40e4	a9 00		lda #$00	          LDA #<MMU_CR
.40e6	a0 ff		ldy #$ff	          LDY #>MMU_CR
.40e8	85 39		sta $39		          STA MEMSIZ
.40ea	84 3a		sty $3a		          STY MEMSIZ+1
.40ec	a2 3f		ldx #$3f	          LDX #$3f
.40ee	a0 07		ldy #$07	          LDY #7
.40f0	8a		txa		InBA_30   TXA
.40f1	99 f8 07	sta $07f8,y	          STA BASIC_STACK-8,Y
.40f4	ca		dex		          DEX
.40f5	88		dey		          DEY
.40f6	10 f8		bpl $40f0	          BPL InBA_30
.40f8	a9 00		lda #$00	          LDA #0
.40fa	a2 6c		ldx #$6c	          LDX #$6c
.40fc	9d 7e 11	sta $117e,x	InBA_40   STA SPRITE_DATA,X
.40ff	ca		dex		          DEX
.4100	10 fa		bpl $40fc	          BPL InBA_40
.4102	20 12 41	jsr $4112	          JSR Init_SID
.4105	a9 d0		lda #$d0	          LDA #$d0
.4107	8d ec 11	sta $11ec	          STA CHARGEN_GRAF
.410a	a9 d8		lda #$d8	          LDA #$d8
.410c	8d eb 11	sta $11eb	          STA CHARGEN_TEXT
.410f	4c d9 51	jmp $51d9	          JMP NEW_10
.4112					  Init_SID
.4112	a9 20		lda #$20	          LDA #<$0120         ; default duration
.4114	a0 01		ldy #$01	          LDY #>$0120
.4116	8d 29 12	sta $1229	          STA Snd_Dur_Tmp
.4119	8c 2a 12	sty $122a	          STY Snd_Dur_Tmp+1
.411c	a9 04		lda #$04	          LDA #4
.411e	8d 2b 12	sta $122b	          STA Snd_Octave
.4121	a9 10		lda #$10	          LDA #16
.4123	8d 22 12	sta $1222	          STA Snd_Tempo
.4126	a9 00		lda #$00	          LDA #0
.4128	8d 04 d4	sta $d404	          STA SID_Control_1
.412b	8d 0b d4	sta $d40b	          STA SID_Control_2
.412e	8d 12 d4	sta $d412	          STA SID_Control_3
.4131	8d fd 12	sta $12fd	          STA IRQ_ACTIVE_FLAG
.4134	a9 0f		lda #$0f	          LDA #15
.4136	8d 74 12	sta $1274	          STA Old_Filter
.4139	8d 75 12	sta $1275	          STA Old_Volume
.413c	8d 18 d4	sta $d418	          STA SID_Volume
.413f	a0 1d		ldy #$1d	          LDY #$1d
.4141	b9 11 70	lda $7011,y	ISID_10   LDA stkmus,Y
.4144	99 3f 12	sta $123f,y	          STA ATKTAB,Y
.4147	88		dey		          DEY
.4148	10 f7		bpl $4141	          BPL ISID_10
.414a	a2 09		ldx #$09	          LDX #9
.414c	bd 2f 70	lda $702f,x	ISID_20   LDA pwhmus,X
.414f	9d 67 12	sta $1267,x	          STA PULSHI,X
.4152	ca		dex		          DEX
.4153	10 f7		bpl $414c	          BPL ISID_20
.4155	8e 85 12	stx $1285	          STX Sound_Duration_1_Hi
.4158	8e 86 12	stx $1286	          STX Sound_Duration_2_Hi
.415b	8e 87 12	stx $1287	          STX Sound_Duration_3_Hi
.415e	8e 24 12	stx $1224	          STX Snd_Duration+1
.4161	8e 26 12	stx $1226	          STX Snd_Duration+3
.4164	8e 28 12	stx $1228	          STX Snd_Duration+5
.4167	a0 02		ldy #$02	          LDY #2
.4169	8c 2f 12	sty $122f	          STY VOICE
.416c	a2 00		ldx #$00	ISID_30   LDX #0
.416e	20 b2 6e	jsr $6eb2	          JSR Set_Envelope
.4171	ce 2f 12	dec $122f	          DEC VOICE
.4174	10 f6		bpl $416c	          BPL ISID_30
.4176	ee 2f 12	inc $122f	ISID_40   INC VOICE
.4179	60		rts		          RTS
.417a					  Init_MMU
.417a	20 45 a8	jsr $a845	          JSR Map_IO
.417d	a2 03		ldx #$03	          LDX #3
.417f	bd 89 41	lda $4189,x	IMMU_10   LDA MMU_Preconfiguration,X
.4182	9d 01 d5	sta $d501,x	          STA MMU_PCRA,X
.4185	ca		dex		          DEX
.4186	10 f7		bpl $417f	          BPL IMMU_10
.4188	60		rts		          RTS
.4189					  MMU_Preconfiguration
>4189	3f				          .BYTE $3f
>418a	7f				          .BYTE $7f
>418b	01				          .BYTE $01
>418c	41				          .BYTE $41
.418d					  Stop_Sprites
.418d	a9 00		lda #$00	          LDA #0
.418f	a0 07		ldy #$07	          LDY #7
.4191	be d9 6d	ldx $6dd9,y	StSp_10   LDX Sprite_Offset,Y
.4194	9d 7e 11	sta $117e,x	          STA SPRITE_DATA,X
.4197	88		dey		          DEY
.4198	10 f7		bpl $4191	          BPL StSp_10
.419a	60		rts		          RTS
.419b					  Show_Startup_Message
.419b	a0 00		ldy #$00	          LDY #0
.419d	b9 bb 41	lda $41bb,y	SSM_10    LDA Startup_Message,Y
.41a0	c9 40		cmp #$40	          CMP #'@'
.41a2	d0 0e		bne $41b2	          BNE SSM_30
.41a4	24 d7		bit $d7		          BIT MODE_80
.41a6	10 0d		bpl $41b5	          BPL SSM_40
.41a8	a2 13		ldx #$13	          LDX #$13
.41aa	a9 20		lda #$20	SSM_20    LDA #' '
.41ac	20 69 92	jsr $9269	          JSR B_BSOUT
.41af	ca		dex		          DEX
.41b0	d0 f8		bne $41aa	          BNE SSM_20
.41b2	20 69 92	jsr $9269	SSM_30    JSR B_BSOUT
.41b5	c8		iny		SSM_40    INY
.41b6	c0 96		cpy #$96	          CPY #$96
.41b8	d0 e3		bne $419d	          BNE SSM_10
.41ba	60		rts		          RTS
.41bb					  Startup_Message
>41bb	93 0d 40			           .BYTE $93,$0d,$40
>41be	20 43 4f 4d 4d 4f 44 4f		           .TEXT " COMMODORE BASIC V7.0"
>41c6	52 45 20 42 41 53 49 43 20 56 37 2e 30
>41d3	20 31 32 32 33 36 35 20		           .TEXT " 122365 BYTES FREE"
>41db	42 59 54 45 53 20 46 52 45 45
>41e5	0d 40				           .BYTE $0d,$40
>41e7	20 20 20 28 43 29 31 39		           .TEXT "   (C)1986 COMMODORE"
>41ef	38 36 20 43 4f 4d 4d 4f 44 4f 52 45
>41fb	20 45 4c 45 43 54 52 4f		           .TEXT " ELECTRONICS, LTD."
>4203	4e 49 43 53 2c 20 4c 54 44 2e
>420d	0d 40				           .BYTE $0d,$40
>420f	20 20 20 20 20 20 20 20		           .TEXT "         (C)1977"
>4217	20 28 43 29 31 39 37 37
>421f	20 4d 49 43 52 4f 53 4f		           .TEXT " MICROSOFT CORP."
>4227	46 54 20 43 4f 52 50 2e
>422f	0d 40				           .BYTE $0d,$40
>4231	20 20 20 20 20 20 20 20		           .TEXT "           ALL RIGHTS"
>4239	20 20 20 41 4c 4c 20 52 49 47 48 54 53
>4246	20 52 45 53 45 52 56 45		           .TEXT " RESERVED\r",0
>424e	44 0d 00
.4251					  Init_RAM_Vectors
.4251	a2 11		ldx #$11	          LDX #$11
.4253	bd 67 42	lda $4267,x	IRV_10    LDA ROM_BASIC_Vector_Table,X
.4256	9d 00 03	sta $0300,x	          STA IERROR,X
.4259	ca		dex		          DEX
.425a	10 f7		bpl $4253	          BPL IRV_10
.425c	a9 78		lda #$78	          LDA #<CALL_80       ; init USR vector
.425e	8d fc 02	sta $02fc	          STA USRVEC
.4261	a9 4c		lda #$4c	          LDA #>CALL_80
.4263	8d fd 02	sta $02fd	          STA USRVEC+1
.4266	60		rts		          RTS
.4267					  ROM_BASIC_Vector_Table
>4267	3f 4d				          .WORD DEF_ERROR     ; $0300 IERROR
>4269	c6 4d				          .WORD DEF_MAIN      ; $0302 IMAIN
>426b	0d 43				          .WORD DEF_CRUNCH    ; $0304 ICRNCH
>426d	51 51				          .WORD DEF_QPLOP     ; $0306 IQPLOP
>426f	a2 4a				          .WORD DEF_GONE      ; $0308 IGONE
>4271	da 78				          .WORD DEF_EVAL      ; $030a IEVAL
>4273	21 43				          .WORD DEF_ESCLK     ; $030c IESCLK
>4275	cd 51				          .WORD DEF_ESCPR     ; $030e IESCPR
>4277	a9 4b				          .WORD DEF_ESCEX     ; $0310 IESCEX
.4279					  ROM_CHRGET
.4279	e6 3d		inc $3d		          INC TXTPTR
.427b	d0 02		bne $427f	          BNE CHRG_10
.427d	e6 3e		inc $3e		          INC TXTPTR+1
.427f	8d 01 ff	sta $ff01	CHRG_10   STA MMU_LCRA
.4282	a0 00		ldy #$00	          LDY #0
.4284	b1 3d		lda ($3d),y	          LDA (TXTPTR),Y
.4286	8d 03 ff	sta $ff03	          STA MMU_LCRC
.4289	c9 3a		cmp #$3a	          CMP #':'
.428b	b0 0a		bcs $4297	          BCS CHRG_RET
.428d	c9 20		cmp #$20	          CMP #' '
.428f	f0 e8		beq $4279	          BEQ ROM_CHRGET
.4291	38		sec		          SEC
.4292	e9 30		sbc #$30	          SBC #$30 ; '0'
.4294	38		sec		          SEC
.4295	e9 d0		sbc #$d0	          SBC #$d0
.4297	60		rts		CHRG_RET  RTS
.4298					  ROM_Fetch_0
.4298	8d a6 03	sta $03a6	          STA Fetch_0+7       ; modify ZP address
.429b	8d 01 ff	sta $ff01	          STA MMU_LCRA
.429e	b1 00		lda ($00),y	          LDA (0),Y           ; <-- modified
.42a0	8d 03 ff	sta $ff03	          STA MMU_LCRC
.42a3	60		rts		          RTS
.42a4					  ROM_Fetch_1
.42a4	8d b2 03	sta $03b2	          STA Fetch_1+7       ; modify ZP address
.42a7	8d 02 ff	sta $ff02	          STA MMU_LCRB
.42aa	b1 00		lda ($00),y	          LDA (0),Y           ; <-- modified
.42ac	8d 04 ff	sta $ff04	          STA MMU_LCRD
.42af	60		rts		          RTS
.42b0					  ROM_Get_INDEXA_1
.42b0	8d 02 ff	sta $ff02	          STA MMU_LCRB
.42b3	b1 24		lda ($24),y	          LDA (INDEXA),Y
.42b5	8d 04 ff	sta $ff04	          STA MMU_LCRD
.42b8	60		rts		          RTS
.42b9					  ROM_Get_INDEXB_0
.42b9	8d 01 ff	sta $ff01	          STA MMU_LCRA
.42bc	b1 26		lda ($26),y	          LDA (INDEXB),Y
.42be	8d 03 ff	sta $ff03	          STA MMU_LCRC
.42c1	60		rts		          RTS
.42c2					  ROM_INDTXT
.42c2	8d 01 ff	sta $ff01	          STA MMU_LCRA
.42c5	b1 3d		lda ($3d),y	          LDA (TXTPTR),Y
.42c7	8d 03 ff	sta $ff03	          STA MMU_LCRC
.42ca	60		rts		          RTS
>42cb	00 00 00			          .BYTE $00,$00,$00
.42ce					  GRBPNT_from_Bank_1
.42ce	a9 50		lda #$50	          LDA #GRBPNT
.42d0	4c ab 03	jmp $03ab	          JMP Fetch_1
.42d3					  FNDPNT_from_Bank_1
.42d3	a9 3f		lda #$3f	          LDA #FNDPNT
.42d5	4c ab 03	jmp $03ab	          JMP Fetch_1
.42d8					  Get_DSCPNT_1
.42d8	a9 52		lda #$52	          LDA #DSCPNT
.42da	4c ab 03	jmp $03ab	          JMP Fetch_1
.42dd					  Get_HIGHTR_0
.42dd	a9 5c		lda #$5c	          LDA #HIGHTR
.42df	4c 9f 03	jmp $039f	          JMP Fetch_0
.42e2					  Get_HIGHTR_1
.42e2	a9 5c		lda #$5c	          LDA #HIGHTR
.42e4	4c ab 03	jmp $03ab	          JMP Fetch_1
.42e7					  Get_FAC1_M3_1
.42e7	a9 66		lda #$66	          LDA #FAC1_M3
.42e9	4c ab 03	jmp $03ab	          JMP Fetch_1
.42ec					  Get_LOWTR_0
.42ec	a9 61		lda #$61	          LDA #LOWTR
.42ee	4c 9f 03	jmp $039f	          JMP Fetch_0
.42f1					  Get_STRPTR_0
.42f1	a9 70		lda #$70	          LDA #STRPTR
.42f3	4c 9f 03	jmp $039f	          JMP Fetch_0
.42f6					  Get_STRPTR_1
.42f6	a9 70		lda #$70	          LDA #STRPTR
.42f8	4c ab 03	jmp $03ab	          JMP Fetch_1
.42fb					  GRBPNT_from_Bank_1_Copy
.42fb	a9 50		lda #$50	          LDA #GRBPNT
.42fd	4c ab 03	jmp $03ab	          JMP Fetch_1
.4300					  Get_LOWTR_1
.4300	a9 61		lda #$61	          LDA #LOWTR
.4302	4c ab 03	jmp $03ab	          JMP Fetch_1
.4305					  Get_INDEXA_0
.4305	a9 24		lda #$24	          LDA #INDEXA
.4307	4c 9f 03	jmp $039f	          JMP Fetch_0
.430a					  CRUNCH
.430a	6c 04 03	jmp ($0304)	          JMP (ICRNCH)
.430d					  DEF_CRUNCH
.430d	a5 3d		lda $3d		          LDA TXTPTR
.430f	48		pha		          PHA
.4310	a5 3e		lda $3e		          LDA TXTPTR+1
.4312	48		pha		          PHA
.4313	20 86 03	jsr $0386	CRUN_05   JSR CHRGOT
.4316	4c 1c 43	jmp $431c	          JMP CRUN_15
.4319	20 80 03	jsr $0380	CRUN_10   JSR CHRGET
.431c	90 fb		bcc $4319	CRUN_15   BCC CRUN_10
.431e	6c 0c 03	jmp ($030c)	          JMP (IESCLK)
.4321					  DEF_ESCLK
.4321	b0 03		bcs $4326	          BCS CRUN_25
.4323	4c b2 43	jmp $43b2	          JMP CRUN_85
.4326	c9 00		cmp #$00	CRUN_25   CMP #0
.4328	f0 77		beq $43a1	          BEQ CRUN_75
.432a	c9 3a		cmp #$3a	          CMP #$3a ; ':'
.432c	f0 eb		beq $4319	          BEQ CRUN_10
.432e	c9 3f		cmp #$3f	          CMP #$3f ; '?'
.4330	d0 04		bne $4336	          BNE CRUN_30
.4332	a9 99		lda #$99	          LDA #$99
.4334	d0 50		bne $4386	          BNE CRUN_65
.4336	c9 80		cmp #$80	CRUN_30   CMP #$80
.4338	90 0b		bcc $4345	          BCC CRUN_35
.433a	c9 ff		cmp #$ff	          CMP #$ff
.433c	f0 db		beq $4319	          BEQ CRUN_10
.433e	a0 01		ldy #$01	          LDY #1
.4340	20 cc 43	jsr $43cc	          JSR kloop
.4343	f0 ce		beq $4313	          BEQ CRUN_05
.4345	c9 22		cmp #$22	CRUN_35   CMP #$22 ; '"'
.4347	d0 0d		bne $4356	          BNE CRUN_45
.4349	20 80 03	jsr $0380	CRUN_40   JSR CHRGET
.434c	c9 00		cmp #$00	          CMP #0
.434e	f0 51		beq $43a1	          BEQ CRUN_75
.4350	c9 22		cmp #$22	          CMP #$22 ; '"'
.4352	f0 c5		beq $4319	          BEQ CRUN_10
.4354	d0 f3		bne $4349	          BNE CRUN_40
.4356	a9 46		lda #$46	CRUN_45   LDA #$46 ; 'F'
.4358	a0 09		ldy #$09	          LDY #9
.435a	20 e2 43	jsr $43e2	          JSR reser
.435d	90 06		bcc $4365	          BCC CRUN_50
.435f	a9 81		lda #$81	          LDA #$81
.4361	a2 00		ldx #$00	          LDX #0
.4363	f0 4b		beq $43b0	          BEQ CRUN_80
.4365	a9 46		lda #$46	CRUN_50   LDA #>BASIC_Keytab_D
.4367	a0 c9		ldy #$c9	          LDY #<BASIC_Keytab_D
.4369	20 e2 43	jsr $43e2	          JSR reser
.436c	90 06		bcc $4374	          BCC CRUN_55
.436e	a9 81		lda #$81	          LDA #$81
.4370	a2 ff		ldx #$ff	          LDX #$ff
.4372	d0 3c		bne $43b0	          BNE CRUN_80
.4374	a9 44		lda #$44	CRUN_55   LDA #$44 ; 'D'
.4376	a0 17		ldy #$17	          LDY #$17
.4378	20 e2 43	jsr $43e2	          JSR reser
.437b	90 9c		bcc $4319	          BCC CRUN_10
.437d	c0 00		cpy #$00	          CPY #0
.437f	f0 03		beq $4384	          BEQ CRUN_60
.4381	20 cc 43	jsr $43cc	          JSR kloop
.4384	a5 0d		lda $0d		CRUN_60   LDA B_COUNT
.4386	a0 00		ldy #$00	CRUN_65   LDY #0
.4388	91 3d		sta ($3d),y	          STA (TXTPTR),Y
.438a	c9 8f		cmp #$8f	          CMP #$8f
.438c	f0 0d		beq $439b	          BEQ CRUN_70
.438e	c9 83		cmp #$83	          CMP #$83
.4390	d0 87		bne $4319	          BNE CRUN_10
.4392	20 80 03	jsr $0380	          JSR CHRGET
.4395	20 8f 52	jsr $528f	          JSR Skip_Statement
.4398	4c 13 43	jmp $4313	          JMP CRUN_05
.439b	20 80 03	jsr $0380	CRUN_70   JSR CHRGET
.439e	20 9d 52	jsr $529d	          JSR BASIC_REM
.43a1	a6 3d		ldx $3d		CRUN_75   LDX TXTPTR
.43a3	68		pla		          PLA
.43a4	85 3e		sta $3e		          STA TXTPTR+1
.43a6	68		pla		          PLA
.43a7	85 3d		sta $3d		          STA TXTPTR
.43a9	38		sec		          SEC
.43aa	8a		txa		          TXA
.43ab	e5 3d		sbc $3d		          SBC TXTPTR
.43ad	a8		tay		          TAY
.43ae	c8		iny		          INY
.43af	60		rts		          RTS
.43b0					  CRUN_80
.43b0	65 0d		adc $0d		          ADC B_COUNT
.43b2	48		pha		CRUN_85   PHA
.43b3	88		dey		          DEY
.43b4	20 cc 43	jsr $43cc	          JSR kloop
.43b7	a9 fe		lda #$fe	          LDA #$fe
.43b9	e8		inx		          INX
.43ba	d0 02		bne $43be	          BNE CRUN_90
.43bc	a9 ce		lda #$ce	          LDA #$ce
.43be	a0 00		ldy #$00	CRUN_90   LDY #0
.43c0	91 3d		sta ($3d),y	          STA (TXTPTR),Y
.43c2	c8		iny		          INY
.43c3	68		pla		          PLA
.43c4	91 3d		sta ($3d),y	          STA (TXTPTR),Y
.43c6	20 80 03	jsr $0380	          JSR CHRGET
.43c9	4c 19 43	jmp $4319	          JMP CRUN_10
.43cc					  kloop
.43cc	18		clc		          CLC
.43cd	98		tya		          TYA
.43ce	65 3d		adc $3d		          ADC TXTPTR
.43d0	85 24		sta $24		          STA INDEXA
.43d2	a5 3e		lda $3e		          LDA TXTPTR+1
.43d4	69 00		adc #$00	          ADC #0
.43d6	85 25		sta $25		          STA INDEXA+1
.43d8	a0 ff		ldy #$ff	          LDY #$ff
.43da	c8		iny		kloop_10  INY
.43db	b1 24		lda ($24),y	          LDA (INDEXA),Y
.43dd	91 3d		sta ($3d),y	          STA (TXTPTR),Y
.43df	d0 f9		bne $43da	          BNE kloop_10
.43e1	60		rts		          RTS
.43e2					  reser
.43e2	85 25		sta $25		          STA INDEXA+1
.43e4	84 24		sty $24		          STY INDEXA
.43e6	a0 00		ldy #$00	          LDY #0
.43e8	84 0d		sty $0d		          STY B_COUNT
.43ea	88		dey		          DEY
.43eb	c8		iny		reser_10  INY
.43ec	b1 3d		lda ($3d),y	reser_20  LDA (TXTPTR),Y
.43ee	38		sec		          SEC
.43ef	f1 24		sbc ($24),y	          SBC (INDEXA),Y
.43f1	f0 f8		beq $43eb	          BEQ reser_10
.43f3	c9 80		cmp #$80	          CMP #$80
.43f5	f0 1b		beq $4412	          BEQ reser_60
.43f7	b1 24		lda ($24),y	reser_30  LDA (INDEXA),Y
.43f9	30 03		bmi $43fe	          BMI reser_40
.43fb	c8		iny		          INY
.43fc	d0 f9		bne $43f7	          BNE reser_30
.43fe	c8		iny		reser_40  INY
.43ff	e6 0d		inc $0d		          INC B_COUNT
.4401	18		clc		          CLC
.4402	98		tya		          TYA
.4403	65 24		adc $24		          ADC INDEXA
.4405	85 24		sta $24		          STA INDEXA
.4407	90 02		bcc $440b	          BCC reser_50
.4409	e6 25		inc $25		          INC INDEXA+1
.440b	18		clc		reser_50  CLC
.440c	a0 00		ldy #$00	          LDY #0
.440e	b1 24		lda ($24),y	          LDA (INDEXA),Y
.4410	d0 da		bne $43ec	          BNE reser_20
.4412	05 0d		ora $0d		reser_60  ORA B_COUNT
.4414	85 0d		sta $0d		          STA B_COUNT
.4416	60		rts		          RTS
.4417					  BASIC_Keytab_A
>4417	45 4e c4			          .SHIFT "END" ;^     ; $80
>441a	46 4f d2			          .SHIFT "FOR" ;^     ; $81
>441d	4e 45 58 d4			          .SHIFT "NEXT" ;^    ; $82
>4421	44 41 54 c1			          .SHIFT "DATA" ;^    ; $83
>4425	49 4e 50 55 54 a3		          .SHIFT "INPUT#" ;^  ; $84
>442b	49 4e 50 55 d4			          .SHIFT "INPUT" ;^   ; $85
>4430	44 49 cd			          .SHIFT "DIM" ;^     ; $86
>4433	52 45 41 c4			          .SHIFT "READ" ;^    ; $87
>4437	4c 45 d4			          .SHIFT "LET" ;^     ; $88
>443a	47 4f 54 cf			          .SHIFT "GOTO" ;^    ; $89
>443e	52 55 ce			          .SHIFT "RUN" ;^     ; $8a
>4441	49 c6				          .SHIFT "IF" ;^      ; $8b
>4443	52 45 53 54 4f 52 c5		          .SHIFT "RESTORE" ;^ ; $8c
>444a	47 4f 53 55 c2			          .SHIFT "GOSUB" ;^   ; $8d
>444f	52 45 54 55 52 ce		          .SHIFT "RETURN" ;^  ; $8e
>4455	52 45 cd			          .SHIFT "REM" ;^     ; $8f
>4458	53 54 4f d0			          .SHIFT "STOP" ;^    ; $90
>445c	4f ce				          .SHIFT "ON" ;^      ; $91
>445e	57 41 49 d4			          .SHIFT "WAIT" ;^    ; $92
>4462	4c 4f 41 c4			          .SHIFT "LOAD" ;^    ; $93
>4466	53 41 56 c5			          .SHIFT "SAVE" ;^    ; $94
>446a	56 45 52 49 46 d9		          .SHIFT "VERIFY" ;^  ; $95
>4470	44 45 c6			          .SHIFT "DEF" ;^     ; $96
>4473	50 4f 4b c5			          .SHIFT "POKE" ;^    ; $97
>4477	50 52 49 4e 54 a3		          .SHIFT "PRINT#" ;^  ; $98
>447d	50 52 49 4e d4			          .SHIFT "PRINT" ;^   ; $99
>4482	43 4f 4e d4			          .SHIFT "CONT" ;^    ; $9a
>4486	4c 49 53 d4			          .SHIFT "LIST" ;^    ; $9b
>448a	43 4c d2			          .SHIFT "CLR" ;^     ; $9c
>448d	43 4d c4			          .SHIFT "CMD" ;^     ; $9d
>4490	53 59 d3			          .SHIFT "SYS" ;^     ; $9e
>4493	4f 50 45 ce			          .SHIFT "OPEN" ;^    ; $9f
>4497	43 4c 4f 53 c5			          .SHIFT "CLOSE" ;^   ; $a0
>449c	47 45 d4			          .SHIFT "GET" ;^     ; $a1
>449f	4e 45 d7			          .SHIFT "NEW" ;^     ; $a2
>44a2	54 41 42 a8			          .SHIFT "TAB(" ;^    ; $a3
>44a6	54 cf				          .SHIFT "TO" ;^      ; $a4
>44a8	46 ce				          .SHIFT "FN" ;^      ; $a5
>44aa	53 50 43 a8			          .SHIFT "SPC(" ;^    ; $a6
>44ae	54 48 45 ce			          .SHIFT "THEN" ;^    ; $a7
>44b2	4e 4f d4			          .SHIFT "NOT" ;^     ; $a8
>44b5	53 54 45 d0			          .SHIFT "STEP" ;^    ; $a9
>44b9	ab				          .SHIFT "+" ;^       ; $aa
>44ba	ad				          .SHIFT "-" ;^       ; $ab
>44bb	aa				          .SHIFT "*" ;^       ; $ac
>44bc	af				          .SHIFT "/" ;^       ; $ad
>44bd	de				          .SHIFT "^" ;^       ; $ae
>44be	41 4e c4			          .SHIFT "AND" ;^     ; $af
>44c1	4f d2				          .SHIFT "OR" ;^      ; $b0
>44c3	be				          .SHIFT ">" ;^       ; $b1
>44c4	bd				          .SHIFT "=" ;^       ; $b2
>44c5	bc				          .SHIFT "<" ;^       ; $b3
>44c6	53 47 ce			          .SHIFT "SGN" ;^     ; $b4
>44c9	49 4e d4			          .SHIFT "INT" ;^     ; $b5
>44cc	41 42 d3			          .SHIFT "ABS" ;^     ; $b6
>44cf	55 53 d2			          .SHIFT "USR" ;^     ; $b7
>44d2	46 52 c5			          .SHIFT "FRE" ;^     ; $b8
>44d5	50 4f d3			          .SHIFT "POS" ;^     ; $b9
>44d8	53 51 d2			          .SHIFT "SQR" ;^     ; $ba
>44db	52 4e c4			          .SHIFT "RND" ;^     ; $bb
>44de	4c 4f c7			          .SHIFT "LOG" ;^     ; $bc
>44e1	45 58 d0			          .SHIFT "EXP" ;^     ; $bd
>44e4	43 4f d3			          .SHIFT "COS" ;^     ; $be
>44e7	53 49 ce			          .SHIFT "SIN" ;^     ; $bf
>44ea	54 41 ce			          .SHIFT "TAN" ;^     ; $c0
>44ed	41 54 ce			          .SHIFT "ATN" ;^     ; $c1
>44f0	50 45 45 cb			          .SHIFT "PEEK" ;^    ; $c2
>44f4	4c 45 ce			          .SHIFT "LEN" ;^     ; $c3
>44f7	53 54 52 a4			          .SHIFT "STR$" ;^    ; $c4
>44fb	56 41 cc			          .SHIFT "VAL" ;^     ; $c5
>44fe	41 53 c3			          .SHIFT "ASC" ;^     ; $c6
>4501	43 48 52 a4			          .SHIFT "CHR$" ;^    ; $c7
>4505	4c 45 46 54 a4			          .SHIFT "LEFT$" ;^   ; $c8
>450a	52 49 47 48 54 a4		          .SHIFT "RIGHT$" ;^  ; $c9
>4510	4d 49 44 a4			          .SHIFT "MID$" ;^    ; $ca
>4514	47 cf				          .SHIFT "GO" ;^      ; $cb
>4516	52 47 d2			          .SHIFT "RGR" ;^     ; $cc
>4519	52 43 4c d2			          .SHIFT "RCLR" ;^    ; $cd
>451d	80				          .BYTE $80
.451e					  BASIC_Keytab_B
>451e	4a 4f d9			          .SHIFT "JOY" ;^        ; $cf
>4521	52 44 4f d4			          .SHIFT "RDOT" ;^       ; $d0
>4525	44 45 c3			          .SHIFT "DEC" ;^        ; $d1
>4528	48 45 58 a4			          .SHIFT "HEX$" ;^       ; $d2
>452c	45 52 52 a4			          .SHIFT "ERR$" ;^       ; $d3
>4530	49 4e 53 54 d2			          .SHIFT "INSTR" ;^      ; $d4
>4535	45 4c 53 c5			          .SHIFT "ELSE" ;^       ; $d5
>4539	52 45 53 55 4d c5		          .SHIFT "RESUME" ;^     ; $d6
>453f	54 52 41 d0			          .SHIFT "TRAP" ;^       ; $d7
>4543	54 52 4f ce			          .SHIFT "TRON" ;^       ; $d8
>4547	54 52 4f 46 c6			          .SHIFT "TROFF" ;^      ; $d9
>454c	53 4f 55 4e c4			          .SHIFT "SOUND" ;^      ; $da
>4551	56 4f cc			          .SHIFT "VOL" ;^        ; $db
>4554	41 55 54 cf			          .SHIFT "AUTO" ;^       ; $dc
>4558	50 55 44 45 c6			          .SHIFT "PUDEF" ;^      ; $dd
>455d	47 52 41 50 48 49 c3		          .SHIFT "GRAPHIC" ;^    ; $de
>4564	50 41 49 4e d4			          .SHIFT "PAINT" ;^      ; $df
>4569	43 48 41 d2			          .SHIFT "CHAR" ;^       ; $e0
>456d	42 4f d8			          .SHIFT "BOX" ;^        ; $e1
>4570	43 49 52 43 4c c5		          .SHIFT "CIRCLE" ;^     ; $e2
>4576	47 53 48 41 50 c5		          .SHIFT "GSHAPE" ;^     ; $e3
>457c	53 53 48 41 50 c5		          .SHIFT "SSHAPE" ;^     ; $e4
>4582	44 52 41 d7			          .SHIFT "DRAW" ;^       ; $e5
>4586	4c 4f 43 41 54 c5		          .SHIFT "LOCATE" ;^     ; $e6
>458c	43 4f 4c 4f d2			          .SHIFT "COLOR" ;^      ; $e7
>4591	53 43 4e 43 4c d2		          .SHIFT "SCNCLR" ;^     ; $e8
>4597	53 43 41 4c c5			          .SHIFT "SCALE" ;^      ; $e9
>459c	48 45 4c d0			          .SHIFT "HELP" ;^       ; $ea
>45a0	44 cf				          .SHIFT "DO" ;^         ; $eb
>45a2	4c 4f 4f d0			          .SHIFT "LOOP" ;^       ; $ec
>45a6	45 58 49 d4			          .SHIFT "EXIT" ;^       ; $ed
>45aa	44 49 52 45 43 54 4f 52		          .SHIFT "DIRECTORY" ;^  ; $ee
>45b2	d9
>45b3	44 53 41 56 c5			          .SHIFT "DSAVE" ;^      ; $ef
>45b8	44 4c 4f 41 c4			          .SHIFT "DLOAD" ;^      ; $f0
>45bd	48 45 41 44 45 d2		          .SHIFT "HEADER" ;^     ; $f1
>45c3	53 43 52 41 54 43 c8		          .SHIFT "SCRATCH" ;^    ; $f2
>45ca	43 4f 4c 4c 45 43 d4		          .SHIFT "COLLECT" ;^    ; $f3
>45d1	43 4f 50 d9			          .SHIFT "COPY" ;^       ; $f4
>45d5	52 45 4e 41 4d c5		          .SHIFT "RENAME" ;^     ; $f5
>45db	42 41 43 4b 55 d0		          .SHIFT "BACKUP" ;^     ; $f6
>45e1	44 45 4c 45 54 c5		          .SHIFT "DELETE" ;^     ; $f7
>45e7	52 45 4e 55 4d 42 45 d2		          .SHIFT "RENUMBER" ;^   ; $f8
>45ef	4b 45 d9			          .SHIFT "KEY" ;^        ; $f9
>45f2	4d 4f 4e 49 54 4f d2		          .SHIFT "MONITOR" ;^    ; $fa
>45f9	55 53 49 4e c7			          .SHIFT "USING" ;^      ; $fb
>45fe	55 4e 54 49 cc			          .SHIFT "UNTIL" ;^      ; $fc
>4603	57 48 49 4c c5			          .SHIFT "WHILE" ;^      ; $fd
>4608	00				          .BYTE $00
.4609					  BASIC_Keytab_C
>4609	42 41 4e cb			          .SHIFT "BANK" ;^       ; $fe02
>460d	46 49 4c 54 45 d2		          .SHIFT "FILTER" ;^     ; $fe03
>4613	50 4c 41 d9			          .SHIFT "PLAY" ;^       ; $fe04
>4617	54 45 4d 50 cf			          .SHIFT "TEMPO" ;^      ; $fe05
>461c	4d 4f 56 53 50 d2		          .SHIFT "MOVSPR" ;^     ; $fe06
>4622	53 50 52 49 54 c5		          .SHIFT "SPRITE" ;^     ; $fe07
>4628	53 50 52 43 4f 4c 4f d2		          .SHIFT "SPRCOLOR" ;^   ; $fe08
>4630	52 52 45 c7			          .SHIFT "RREG" ;^       ; $fe09
>4634	45 4e 56 45 4c 4f 50 c5		          .SHIFT "ENVELOPE" ;^   ; $fe0a
>463c	53 4c 45 45 d0			          .SHIFT "SLEEP" ;^      ; $fe0b
>4641	43 41 54 41 4c 4f c7		          .SHIFT "CATALOG" ;^    ; $fe0c
>4648	44 4f 50 45 ce			          .SHIFT "DOPEN" ;^      ; $fe0d
>464d	41 50 50 45 4e c4		          .SHIFT "APPEND" ;^     ; $fe0e
>4653	44 43 4c 4f 53 c5		          .SHIFT "DCLOSE" ;^     ; $fe0f
>4659	42 53 41 56 c5			          .SHIFT "BSAVE" ;^      ; $fe10
>465e	42 4c 4f 41 c4			          .SHIFT "BLOAD" ;^      ; $fe11
>4663	52 45 43 4f 52 c4		          .SHIFT "RECORD" ;^     ; $fe12
>4669	43 4f 4e 43 41 d4		          .SHIFT "CONCAT" ;^     ; $fe13
>466f	44 56 45 52 49 46 d9		          .SHIFT "DVERIFY" ;^    ; $fe14
>4676	44 43 4c 45 41 d2		          .SHIFT "DCLEAR" ;^     ; $fe15
>467c	53 50 52 53 41 d6		          .SHIFT "SPRSAV" ;^     ; $fe16
>4682	43 4f 4c 4c 49 53 49 4f		          .SHIFT "COLLISION" ;^  ; $fe17
>468a	ce
>468b	42 45 47 49 ce			          .SHIFT "BEGIN" ;^      ; $fe18
>4690	42 45 4e c4			          .SHIFT "BEND" ;^       ; $fe19
>4694	57 49 4e 44 4f d7		          .SHIFT "WINDOW" ;^     ; $fe1a
>469a	42 4f 4f d4			          .SHIFT "BOOT" ;^       ; $fe1b
>469e	57 49 44 54 c8			          .SHIFT "WIDTH" ;^      ; $fe1c
>46a3	53 50 52 44 45 c6		          .SHIFT "SPRDEF" ;^     ; $fe1d
>46a9	51 55 49 d4			          .SHIFT "QUIT" ;^       ; $fe1e
>46ad	53 54 41 53 c8			          .SHIFT "STASH" ;^      ; $fe1f
>46b2	a0				          .SHIFT " " ;^          ; $fe20
>46b3	46 45 54 43 c8			          .SHIFT "FETCH" ;^      ; $fe21
>46b8	a0				          .SHIFT " " ;^          ; $fe22
>46b9	53 57 41 d0			          .SHIFT "SWAP" ;^       ; $fe23
>46bd	4f 46 c6			          .SHIFT "OFF" ;^        ; $fe24
>46c0	46 41 53 d4			          .SHIFT "FAST" ;^       ; $fe25
>46c4	53 4c 4f d7			          .SHIFT "SLOW" ;^       ; $fe26
>46c8	00				          .BYTE $00
.46c9					  BASIC_Keytab_D
>46c9	50 4f d4			          .SHIFT "POT" ;^      ; $ce02
>46cc	42 55 4d d0			          .SHIFT "BUMP" ;^     ; $ce03
>46d0	50 45 ce			          .SHIFT "PEN" ;^      ; $ce04
>46d3	52 53 50 50 4f d3		          .SHIFT "RSPPOS" ;^   ; $ce05
>46d9	52 53 50 52 49 54 c5		          .SHIFT "RSPRITE" ;^  ; $ce06
>46e0	52 53 50 43 4f 4c 4f d2		          .SHIFT "RSPCOLOR" ;^ ; $ce07
>46e8	58 4f d2			          .SHIFT "XOR" ;^      ; $ce08
>46eb	52 57 49 4e 44 4f d7		          .SHIFT "RWINDOW" ;^  ; $ce09
>46f2	50 4f 49 4e 54 45 d2		          .SHIFT "POINTER" ;^  ; $ce0a
>46f9	00 00 00			          .BYTE $00,$00,$00
.46fc					  BASIC_Action_A
>46fc	cc 4b				          .WORD BASIC_END     - 1; $80
>46fe	f8 5d				          .WORD BASIC_FOR     - 1; $81
>4700	f3 57				          .WORD BASIC_NEXT    - 1; $82
>4702	8e 52				          .WORD Skip_Statement- 1; $83 DATA
>4704	47 56				          .WORD BASIC_INPUT_D - 1; $84
>4706	61 56				          .WORD BASIC_INPUT   - 1; $85
>4708	7a 58				          .WORD BASIC_DIM     - 1; $86
>470a	a8 56				          .WORD BASIC_READ    - 1; $87
>470c	c5 53				          .WORD BASIC_LET     - 1; $88
>470e	da 59				          .WORD BASIC_GOTO    - 1; $89
>4710	9a 5a				          .WORD BASIC_RUN     - 1; $8a
>4712	c4 52				          .WORD BASIC_IF      - 1; $8b
>4714	c9 5a				          .WORD BASIC_RESTORE - 1; $8c
>4716	ce 59				          .WORD BASIC_GOSUB   - 1; $8d
>4718	61 52				          .WORD BASIC_RETURN  - 1; $8e
>471a	9c 52				          .WORD BASIC_REM     - 1; $8f
>471c	ca 4b				          .WORD BASIC_STOP    - 1; $90
>471e	a2 53				          .WORD BASIC_ON      - 1; $91
>4720	2c 6c				          .WORD BASIC_WAIT    - 1; $92
>4722	2b 91				          .WORD BASIC_LOAD    - 1; $93
>4724	11 91				          .WORD BASIC_SAVE    - 1; $94
>4726	28 91				          .WORD BASIC_VERIFY  - 1; $95
>4728	f9 84				          .WORD BASIC_DEF     - 1; $96
>472a	e4 80				          .WORD BASIC_POKE    - 1; $97
>472c	39 55				          .WORD BASIC_PRINT_D - 1; $98
>472e	59 55				          .WORD BASIC_PRINT   - 1; $99
>4730	5f 5a				          .WORD BASIC_CONT    - 1; $9a
>4732	e1 50				          .WORD BASIC_LIST    - 1; $9b
>4734	f7 51				          .WORD BASIC_CLR     - 1; $9c
>4736	3f 55				          .WORD BASIC_CMD     - 1; $9d
>4738	84 58				          .WORD BASIC_SYS     - 1; $9e
>473a	8c 91				          .WORD BASIC_OPEN    - 1; $9f
>473c	99 91				          .WORD BASIC_CLOSE   - 1; $a0
>473e	11 56				          .WORD BASIC_GET     - 1; $a1
>4740	d5 51				          .WORD BASIC_NEW     - 1; $a2
.4742					  BASIC_Action_B
>4742	90 53				          .WORD BASIC_ELSE     - 1; $d5
>4744	61 5f				          .WORD BASIC_RESUME   - 1; $d6
>4746	4c 5f				          .WORD BASIC_TRAP     - 1; $d7
>4748	b3 58				          .WORD BASIC_TRON     - 1; $d8
>474a	b6 58				          .WORD BASIC_TROFF    - 1; $d9
>474c	eb 71				          .WORD BASIC_SOUND    - 1; $da
>474e	c4 71				          .WORD BASIC_VOL      - 1; $db
>4750	74 59				          .WORD BASIC_AUTO     - 1; $dc
>4752	33 5f				          .WORD BASIC_PUDEF    - 1; $dd
>4754	59 6b				          .WORD BASIC_GRAPHIC  - 1; $de
>4756	a7 61				          .WORD BASIC_PAINT    - 1; $df
>4758	d6 67				          .WORD BASIC_CHAR     - 1; $e0
>475a	b6 62				          .WORD BASIC_BOX      - 1; $e1
>475c	8d 66				          .WORD BASIC_CIRCLE   - 1; $e2
>475e	8c 65				          .WORD BASIC_GSHAPE   - 1; $e3
>4760	2a 64				          .WORD BASIC_SSHAPE   - 1; $e4
>4762	96 67				          .WORD BASIC_DRAW     - 1; $e5
>4764	54 69				          .WORD BASIC_LOCATE   - 1; $e6
>4766	e1 69				          .WORD BASIC_COLOR    - 1; $e7
>4768	78 6a				          .WORD BASIC_SCNCLR   - 1; $e8
>476a	5f 69				          .WORD BASIC_SCALE    - 1; $e9
>476c	85 59				          .WORD BASIC_HELP     - 1; $ea
>476e	df 5f				          .WORD BASIC_DO       - 1; $eb
>4770	89 60				          .WORD BASIC_LOOP     - 1; $ec
>4772	38 60				          .WORD BASIC_EXIT     - 1; $ed
>4774	7d a0				          .WORD BASIC_DIRCAT   - 1; $ee
>4776	8b a1				          .WORD BASIC_DSAVE    - 1; $ef
>4778	a6 a1				          .WORD BASIC_DLOAD    - 1; $f0
>477a	66 a2				          .WORD BASIC_HEADER   - 1; $f1
>477c	a0 a2				          .WORD BASIC_SCRATCH  - 1; $f2
>477e	2e a3				          .WORD BASIC_COLLECT  - 1; $f3
>4780	45 a3				          .WORD BASIC_COPY     - 1; $f4
>4782	6d a3				          .WORD BASIC_RENAME   - 1; $f5
>4784	7b a3				          .WORD BASIC_BACKUP   - 1; $f6
>4786	86 5e				          .WORD BASIC_DELETE   - 1; $f7
>4788	f7 5a				          .WORD BASIC_RENUMBER - 1; $f8
>478a	09 61				          .WORD BASIC_KEY      - 1; $f9
>478c	ff af				          .WORD BASIC_MONITOR  - 1; $fa
.478e					  BASIC_Action_C
>478e	c8 6b				          .WORD BASIC_BANK      - 1; $fe02
>4790	45 70				          .WORD BASIC_FILTER    - 1; $fe03
>4792	e0 6d				          .WORD BASIC_PLAY      - 1; $fe04
>4794	d6 6f				          .WORD BASIC_TEMPO     - 1; $fe05
>4796	c5 6c				          .WORD BASIC_MOVSPR    - 1; $fe06
>4798	4e 6c				          .WORD BASIC_SPRITE    - 1; $fe07
>479a	8f 71				          .WORD BASIC_SPRCOLOR  - 1; $fe08
>479c	bc 58				          .WORD BASIC_RREG      - 1; $fe09
>479e	c0 70				          .WORD BASIC_ENVELOPE  - 1; $fe0a
>47a0	d6 6b				          .WORD BASIC_SLEEP     - 1; $fe0b
>47a2	7d a0				          .WORD BASIC_DIRCAT    - 1; $fe0c
>47a4	1c a1				          .WORD BASIC_DOPEN     - 1; $fe0d
>47a6	33 a1				          .WORD BASIC_APPEND    - 1; $fe0e
>47a8	6e a1				          .WORD BASIC_DCLOSE    - 1; $fe0f
>47aa	c7 a1				          .WORD BASIC_BSAVE     - 1; $fe10
>47ac	17 a2				          .WORD BASIC_BLOAD     - 1; $fe11
>47ae	d6 a2				          .WORD BASIC_RECORD    - 1; $fe12
>47b0	61 a3				          .WORD BASIC_CONCAT    - 1; $fe13
>47b2	a3 a1				          .WORD BASIC_DVERIFY   - 1; $fe14
>47b4	21 a3				          .WORD BASIC_DCLEAR    - 1; $fe15
>47b6	eb 76				          .WORD BASIC_SPRSAV    - 1; $fe16
>47b8	63 71				          .WORD BASIC_COLLISION - 1; $fe17
>47ba	6b 79				          .WORD SYNTAX_ERROR    - 1; $fe18
>47bc	8e 52				          .WORD Skip_Statement  - 1; $fe19 BEGIN
>47be	cb 72				          .WORD BASIC_WINDOW    - 1; $fe1a
>47c0	34 73				          .WORD BASIC_BOOT      - 1; $fe1b
>47c2	b5 71				          .WORD BASIC_WIDTH     - 1; $fe1c
>47c4	71 73				          .WORD BASIC_SPRDEF    - 1; $fe1d
>47c6	45 48				          .WORD Unimplemented   - 1; $fe1e
>47c8	1e aa				          .WORD BASIC_STASH     - 1; $fe1f
>47ca	00 00				          .WORD 1               - 1; $fe20
>47cc	23 aa				          .WORD BASIC_FETCH     - 1; $fe21
>47ce	00 00				          .WORD 1               - 1; $fe22
>47d0	28 aa				          .WORD BASIC_SWAP      - 1; $fe23
>47d2	45 48				          .WORD Unimplemented   - 1; $fe24
>47d4	b2 77				          .WORD BASIC_FAST      - 1; $fe25
>47d6	c3 77				          .WORD BASIC_SLOW      - 1; $fe26
.47d8					  BASIC_Function_A
>47d8	65 8c				          .WORD FUNC_SGN  ; $b4
>47da	fb 8c				          .WORD FUNC_INT  ; $b5
>47dc	84 8c				          .WORD FUNC_ABS  ; $b6
>47de	18 12				          .WORD FUNC_USR  ; $b7
>47e0	00 80				          .WORD FUNC_FRE  ; $b8
>47e2	d0 84				          .WORD FUNC_POS  ; $b9
>47e4	b7 8f				          .WORD FUNC_SQR  ; $ba
>47e6	34 84				          .WORD FUNC_RND  ; $bb
>47e8	ca 89				          .WORD FUNC_LOG  ; $bc
>47ea	33 90				          .WORD FUNC_EXP  ; $bd
>47ec	09 94				          .WORD FUNC_COS  ; $be
>47ee	10 94				          .WORD FUNC_SIN  ; $bf
>47f0	59 94				          .WORD FUNC_TAN  ; $c0
>47f2	b3 94				          .WORD FUNC_ATN  ; $c1
>47f4	c5 80				          .WORD FUNC_PEEK ; $c2
>47f6	68 86				          .WORD FUNC_LEN  ; $c3
>47f8	ae 85				          .WORD FUNC_STR  ; $c4
>47fa	4a 80				          .WORD FUNC_VAL  ; $c5
>47fc	77 86				          .WORD FUNC_ASC  ; $c6
>47fe	bf 85				          .WORD FUNC_CHR  ; $c7
>4800	d6 85				          .WORD FUNC_LEFT ; $c8
>4802	0a 86				          .WORD FUNC_RIGHT; $c9
>4804	1c 86				          .WORD FUNC_MID  ; $ca
.4806					  BASIC_Function_B
>4806	82 81				          .WORD FUNC_RGR ; $cc
>4808	9b 81				          .WORD FUNC_RCLR; $cd
>480a	00 00				          .WORD 0        ; $ce
>480c	03 82				          .WORD FUNC_JOY ; $cf
>480e	0c 9b				          .WORD FUNC_RDOT; $d0
>4810	76 80				          .WORD FUNC_DEC ; $d1
>4812	42 81				          .WORD FUNC_HEX ; $d2
>4814	f6 80				          .WORD FUNC_ERR ; $d3
.4816					  BASIC_Function_C
>4816	4d 82				          .WORD FUNC_POT      ; $ce02
>4818	7c 83				          .WORD FUNC_BUMP     ; $ce03
>481a	ae 82				          .WORD FUNC_PEN      ; $ce04
>481c	97 83				          .WORD FUNC_RSPPOS   ; $ce05
>481e	1e 83				          .WORD FUNC_RSPRITE  ; $ce06
>4820	61 83				          .WORD FUNC_RSPCOLOR ; $ce07
>4822	e1 83				          .WORD FUNC_XOR      ; $ce08
>4824	07 84				          .WORD FUNC_RWINDOW  ; $ce09
>4826	fa 82				          .WORD FUNC_POINTER  ; $ce0a
.4828					  BASIC_Operator
>4828	79 47 88			          .BYTE $79, <OP_PLUS-1    , >OP_PLUS-1
>482b	79 30 88			          .BYTE $79, <OP_MINUS-1   , >OP_MINUS-1
>482e	7b 26 8a			          .BYTE $7b, <OP_MULT-1    , >OP_MULT-1
>4831	7b 4b 8b			          .BYTE $7b, <OP_DIV-1     , >OP_DIV-1
>4834	7f c0 8f			          .BYTE $7f, <OP_POWER-1   , >OP_POWER-1
>4837	50 88 4c			          .BYTE $50, <OP_AND-1     , >OP_AND-1
>483a	46 85 4c			          .BYTE $46, <OP_OR-1      , >OP_OR-1
>483d	7d f9 8f			          .BYTE $7d, <OP_NEG-1     , >OP_NEG-1
>4840	5a 2f 79			          .BYTE $5a, <OP_NOT-1     , >OP_NOT-1
>4843	64 b5 4c			          .BYTE $64, <OP_COMPARE-1 , >OP_COMPARE-1
.4846					  Unimplemented
.4846	a2 28		ldx #$28	          LDX #$28
.4848	4c 3c 4d	jmp $4d3c	          JMP Print_Error_X
.484b					  Error_Messages
>484b	54 4f 4f 20 4d 41 4e 59		          .SHIFT "TOO MANY FILES" ;^        ; $01
>4853	20 46 49 4c 45 d3
>4859	46 49 4c 45 20 4f 50 45		          .SHIFT "FILE OPEN" ;^             ; $02
>4861	ce
>4862	46 49 4c 45 20 4e 4f 54		          .SHIFT "FILE NOT OPEN" ;^         ; $03
>486a	20 4f 50 45 ce
>486f	46 49 4c 45 20 4e 4f 54		          .SHIFT "FILE NOT FOUND" ;^        ; $04
>4877	20 46 4f 55 4e c4
>487d	44 45 56 49 43 45 20 4e		          .SHIFT "DEVICE NOT PRESENT" ;^    ; $05
>4885	4f 54 20 50 52 45 53 45 4e d4
>488f	4e 4f 54 20 49 4e 50 55		          .SHIFT "NOT INPUT FILE" ;^        ; $06
>4897	54 20 46 49 4c c5
>489d	4e 4f 54 20 4f 55 54 50		          .SHIFT "NOT OUTPUT FILE" ;^       ; $07
>48a5	55 54 20 46 49 4c c5
>48ac	4d 49 53 53 49 4e 47 20		          .SHIFT "MISSING FILE NAME" ;^     ; $08
>48b4	46 49 4c 45 20 4e 41 4d c5
>48bd	49 4c 4c 45 47 41 4c 20		          .SHIFT "ILLEGAL DEVICE NUMBER" ;^ ; $09
>48c5	44 45 56 49 43 45 20 4e 55 4d 42 45 d2
>48d2	4e 45 58 54 20 57 49 54		          .SHIFT "NEXT WITHOUT FOR" ;^      ; $0a
>48da	48 4f 55 54 20 46 4f d2
>48e2	53 59 4e 54 41 d8		          .SHIFT "SYNTAX" ;^                ; $0b
>48e8	52 45 54 55 52 4e 20 57		          .SHIFT "RETURN WITHOUT GOSUB" ;^  ; $0c
>48f0	49 54 48 4f 55 54 20 47 4f 53 55 c2
>48fc	4f 55 54 20 4f 46 20 44		          .SHIFT "OUT OF DATA" ;^           ; $0d
>4904	41 54 c1
>4907	49 4c 4c 45 47 41 4c 20		          .SHIFT "ILLEGAL QUANTITY" ;^      ; $0e
>490f	51 55 41 4e 54 49 54 d9
>4917	4f 56 45 52 46 4c 4f d7		          .SHIFT "OVERFLOW" ;^              ; $0f
>491f	4f 55 54 20 4f 46 20 4d		          .SHIFT "OUT OF MEMORY" ;^         ; $10
>4927	45 4d 4f 52 d9
>492c	55 4e 44 45 46 27 44 20		          .SHIFT "UNDEF'D STATEMENT" ;^     ; $11
>4934	53 54 41 54 45 4d 45 4e d4
>493d	42 41 44 20 53 55 42 53		          .SHIFT "BAD SUBSCRIPT" ;^         ; $12
>4945	43 52 49 50 d4
>494a	52 45 44 49 4d 27 44 20		          .SHIFT "REDIM'D ARRAY" ;^         ; $13
>4952	41 52 52 41 d9
>4957	44 49 56 49 53 49 4f 4e		          .SHIFT "DIVISION BY ZERO" ;^      ; $14
>495f	20 42 59 20 5a 45 52 cf
>4967	49 4c 4c 45 47 41 4c 20		          .SHIFT "ILLEGAL DIRECT" ;^        ; $15
>496f	44 49 52 45 43 d4
>4975	54 59 50 45 20 4d 49 53		          .SHIFT "TYPE MISMATCH" ;^         ; $16
>497d	4d 41 54 43 c8
>4982	53 54 52 49 4e 47 20 54		          .SHIFT "STRING TOO LONG" ;^       ; $17
>498a	4f 4f 20 4c 4f 4e c7
>4991	46 49 4c 45 20 44 41 54		          .SHIFT "FILE DATA" ;^             ; $18
>4999	c1
>499a	46 4f 52 4d 55 4c 41 20		          .SHIFT "FORMULA TOO COMPLEX" ;^   ; $19
>49a2	54 4f 4f 20 43 4f 4d 50 4c 45 d8
>49ad	43 41 4e 27 54 20 43 4f		          .SHIFT "CAN'T CONTINUE" ;^        ; $1a
>49b5	4e 54 49 4e 55 c5
>49bb	55 4e 44 45 46 27 44 20		          .SHIFT "UNDEF'D FUNCTION" ;^      ; $1b
>49c3	46 55 4e 43 54 49 4f ce
>49cb	56 45 52 49 46 d9		          .SHIFT "VERIFY" ;^                ; $1c
>49d1	4c 4f 41 c4			          .SHIFT "LOAD" ;^                  ; $1d
>49d5	42 52 45 41 4b			          .TEXT "BREAK"
>49da	00 a0				          .BYTE $00,$a0
.49dc					  Error_Message_B
>49dc	43 41 4e 27 54 20 52 45		          .SHIFT "CAN'T RESUME" ;^          ; $1f
>49e4	53 55 4d c5
>49e8	4c 4f 4f 50 20 4e 4f 54		          .SHIFT "LOOP NOT FOUND" ;^        ; $20
>49f0	20 46 4f 55 4e c4
>49f6	4c 4f 4f 50 20 57 49 54		          .SHIFT "LOOP WITHOUT DO" ;^       ; $21
>49fe	48 4f 55 54 20 44 cf
>4a05	44 49 52 45 43 54 20 4d		          .SHIFT "DIRECT MODE ONLY" ;^      ; $22
>4a0d	4f 44 45 20 4f 4e 4c d9
>4a15	4e 4f 20 47 52 41 50 48		          .SHIFT "NO GRAPHICS AREA" ;^      ; $23
>4a1d	49 43 53 20 41 52 45 c1
>4a25	42 41 44 20 44 49 53 cb		          .SHIFT "BAD DISK" ;^              ; $24
>4a2d	42 45 4e 44 20 4e 4f 54		          .SHIFT "BEND NOT FOUND" ;^        ; $25
>4a35	20 46 4f 55 4e c4
>4a3b	4c 49 4e 45 20 4e 55 4d		          .SHIFT "LINE NUMBER TOO LARGE" ;^ ; $26
>4a43	42 45 52 20 54 4f 4f 20 4c 41 52 47 c5
>4a50	55 4e 52 45 53 4f 4c 56		          .SHIFT "UNRESOLVED REFERENCE" ;^  ; $27
>4a58	45 44 20 52 45 46 45 52 45 4e 43 c5
>4a64	55 4e 49 4d 50 4c 45 4d		          .SHIFT "UNIMPLEMENTED COMMAND" ;^ ; $28
>4a6c	45 4e 54 45 44 20 43 4f 4d 4d 41 4e c4
>4a79	46 49 4c 45 20 52 45 41		          .SHIFT "FILE READ" ;^             ; $29
>4a81	c4
.4a82					  Set_Error_Index
.4a82	aa		tax		          TAX
.4a83	a0 00		ldy #$00	          LDY #0
.4a85	a9 4b		lda #$4b	          LDA #<Error_Messages
.4a87	85 26		sta $26		          STA INDEXB
.4a89	a9 48		lda #$48	          LDA #>Error_Messages
.4a8b	85 27		sta $27		          STA INDEXB+1
.4a8d	ca		dex		SEI_10    DEX
.4a8e	30 0e		bmi $4a9e	          BMI SEI_Ret
.4a90	b1 26		lda ($26),y	SEI_20    LDA (INDEXB),Y
.4a92	48		pha		          PHA
.4a93	e6 26		inc $26		          INC INDEXB
.4a95	d0 02		bne $4a99	          BNE SEI_30
.4a97	e6 27		inc $27		          INC INDEXB+1
.4a99	68		pla		SEI_30    PLA
.4a9a	10 f4		bpl $4a90	          BPL SEI_20
.4a9c	30 ef		bmi $4a8d	          BMI SEI_10
.4a9e	60		rts		SEI_Ret   RTS
.4a9f					  Interpret
.4a9f	6c 08 03	jmp ($0308)	          JMP (IGONE)
.4aa2					  DEF_GONE
.4aa2	24 7f		bit $7f		          BIT RUNMOD
.4aa4	10 4a		bpl $4af0	          BPL Inter_40
.4aa6	ad 7f 12	lda $127f	          LDA INT_VAL
.4aa9	30 45		bmi $4af0	          BMI Inter_40
.4aab	a2 02		ldx #$02	          LDX #2
.4aad	bd 76 12	lda $1276,x	Inter_20  LDA INT_TRIP_FLAG,X
.4ab0	f0 3b		beq $4aed	          BEQ Inter_30
.4ab2	a9 00		lda #$00	          LDA #0
.4ab4	9d 76 12	sta $1276,x	          STA INT_TRIP_FLAG,X
.4ab7	bd 79 12	lda $1279,x	          LDA INT_ADR_LO,X
.4aba	85 16		sta $16		          STA LINNUM
.4abc	bd 7c 12	lda $127c,x	          LDA INT_ADR_HI,X
.4abf	85 17		sta $17		          STA LINNUM+1
.4ac1	8a		txa		          TXA
.4ac2	48		pha		          PHA
.4ac3	a5 3d		lda $3d		          LDA TXTPTR
.4ac5	48		pha		          PHA
.4ac6	a5 3e		lda $3e		          LDA TXTPTR+1
.4ac8	48		pha		          PHA
.4ac9	ad 7f 12	lda $127f	          LDA INT_VAL
.4acc	09 80		ora #$80	          ORA #%10000000 ; $80
.4ace	8d 7f 12	sta $127f	          STA INT_VAL
.4ad1	20 80 03	jsr $0380	          JSR CHRGET
.4ad4	20 1d 5a	jsr $5a1d	          JSR Push_GOSUB
.4ad7	20 e2 59	jsr $59e2	          JSR GoTo
.4ada	20 f6 4a	jsr $4af6	          JSR Next_Statement
.4add	ad 7f 12	lda $127f	          LDA INT_VAL
.4ae0	29 7f		and #$7f	          AND #%01111111 ; $7f
.4ae2	8d 7f 12	sta $127f	          STA INT_VAL
.4ae5	68		pla		          PLA
.4ae6	85 3e		sta $3e		          STA TXTPTR+1
.4ae8	68		pla		          PLA
.4ae9	85 3d		sta $3d		          STA TXTPTR
.4aeb	68		pla		          PLA
.4aec	aa		tax		          TAX
.4aed	ca		dex		Inter_30  DEX
.4aee	10 bd		bpl $4aad	          BPL Inter_20
.4af0	20 80 03	jsr $0380	Inter_40  JSR CHRGET
.4af3	20 3f 4b	jsr $4b3f	Inter_50  JSR Execute
.4af6					  Next_Statement
.4af6	20 b5 4b	jsr $4bb5	          JSR Is_STOP_Key
.4af9	24 7f		bit $7f		          BIT RUNMOD
.4afb	10 06		bpl $4b03	          BPL NeSt_10
.4afd	20 34 4b	jsr $4b34	          JSR TXTPTR_TO_OLDTXT
.4b00	ba		tsx		          TSX
.4b01	86 82		stx $82		          STX OLDSTK
.4b03	a0 00		ldy #$00	NeSt_10   LDY #0
.4b05	20 c9 03	jsr $03c9	          JSR INDTXT
.4b08	f0 03		beq $4b0d	          BEQ NeSt_20
.4b0a	4c ae 4b	jmp $4bae	          JMP Exec_55
.4b0d	24 7f		bit $7f		NeSt_20   BIT RUNMOD
.4b0f	10 20		bpl $4b31	          BPL NeSt_40
.4b11	a0 02		ldy #$02	          LDY #2
.4b13	20 c9 03	jsr $03c9	          JSR INDTXT
.4b16	f0 19		beq $4b31	          BEQ NeSt_40
.4b18	c8		iny		          INY
.4b19	20 c9 03	jsr $03c9	          JSR INDTXT
.4b1c	85 3b		sta $3b		          STA CURLIN
.4b1e	c8		iny		          INY
.4b1f	20 c9 03	jsr $03c9	          JSR INDTXT
.4b22	85 3c		sta $3c		          STA CURLIN+1
.4b24	98		tya		          TYA
.4b25	18		clc		          CLC
.4b26	65 3d		adc $3d		          ADC TXTPTR
.4b28	85 3d		sta $3d		          STA TXTPTR
.4b2a	90 02		bcc $4b2e	          BCC NeSt_30
.4b2c	e6 3e		inc $3e		          INC TXTPTR+1
.4b2e	4c 9f 4a	jmp $4a9f	NeSt_30   JMP Interpret
.4b31	4c 37 4d	jmp $4d37	NeSt_40   JMP BASIC_Ready
.4b34					  TXTPTR_TO_OLDTXT
.4b34	a5 3d		lda $3d		          LDA TXTPTR
.4b36	a4 3e		ldy $3e		          LDY TXTPTR+1
.4b38	8d 02 12	sta $1202	          STA OLDTXT
.4b3b	8c 03 12	sty $1203	          STY OLDTXT+1
.4b3e	60		rts		TPOT_Ret  RTS
.4b3f					  Execute
.4b3f	f0 fd		beq $4b3e	          BEQ TPOT_Ret
.4b41	2c 6f 11	bit $116f	          BIT TRCFLG
.4b44	10 13		bpl $4b59	          BPL Exec_05
.4b46	24 7f		bit $7f		          BIT RUNMOD
.4b48	10 0f		bpl $4b59	          BPL Exec_05
.4b4a	48		pha		          PHA
.4b4b	a9 5b		lda #$5b	          LDA #'['            ; trace
.4b4d	20 0c 56	jsr $560c	          JSR Print_Char
.4b50	20 2e 8e	jsr $8e2e	          JSR Print_CURLIN
.4b53	a9 5d		lda #$5d	          LDA #']'
.4b55	20 0c 56	jsr $560c	          JSR Print_Char
.4b58	68		pla		          PLA
.4b59	c9 fe		cmp #$fe	Exec_05   CMP #$fe
.4b5b	f0 37		beq $4b94	          BEQ Exec_35
.4b5d	c9 cb		cmp #$cb	          CMP #$cb            ; GO
.4b5f	d0 03		bne $4b64	          BNE Exec_10
.4b61	4c 3d 5a	jmp $5a3d	          JMP BASIC_GO
.4b64	c9 ca		cmp #$ca	Exec_10   CMP #$ca            ; MID$
.4b66	f0 23		beq $4b8b	          BEQ Exec_25
.4b68	c9 fb		cmp #$fb	          CMP #$fb            ; USING
.4b6a	b0 3f		bcs $4bab	          BCS Exec_50
.4b6c	c9 a3		cmp #$a3	          CMP #$a3            ; TAB(
.4b6e	90 06		bcc $4b76	          BCC Exec_15
.4b70	c9 d5		cmp #$d5	          CMP #$d5            ; ELSE
.4b72	90 37		bcc $4bab	          BCC Exec_50
.4b74	e9 32		sbc #$32	          SBC #$32
.4b76	38		sec		Exec_15   SEC
.4b77	e9 80		sbc #$80	          SBC #$80
.4b79	b0 03		bcs $4b7e	          BCS Exec_20
.4b7b	4c c6 53	jmp $53c6	          JMP BASIC_LET
.4b7e	0a		asl a		Exec_20   ASL A
.4b7f	a8		tay		          TAY
.4b80	b9 fd 46	lda $46fd,y	          LDA BASIC_Action_A+1,Y
.4b83	48		pha		          PHA
.4b84	b9 fc 46	lda $46fc,y	          LDA BASIC_Action_A,Y
.4b87	48		pha		          PHA
.4b88	4c 80 03	jmp $0380	          JMP CHRGET
.4b8b	a9 59		lda #$59	Exec_25   LDA #>MID_ASSIGN-1
.4b8d	48		pha		          PHA
.4b8e	a9 00		lda #$00	          LDA #<MID_ASSIGN-1
.4b90	48		pha		          PHA
.4b91	4c 80 03	jmp $0380	Exec_30   JMP CHRGET
.4b94	20 80 03	jsr $0380	Exec_35   JSR CHRGET
.4b97	f0 12		beq $4bab	          BEQ Exec_50
.4b99	c9 02		cmp #$02	          CMP #2
.4b9b	90 08		bcc $4ba5	          BCC Exec_40
.4b9d	c9 27		cmp #$27	          CMP #$27 ; '''
.4b9f	b0 04		bcs $4ba5	          BCS Exec_40
.4ba1	69 47		adc #$47	          ADC #$47 ; 'G'
.4ba3	d0 d9		bne $4b7e	          BNE Exec_20
.4ba5	38		sec		Exec_40   SEC
.4ba6	6c 10 03	jmp ($0310)	          JMP (IESCEX)
.4ba9					  DEF_ESCEX
.4ba9	90 e6		bcc $4b91	          BCC Exec_30
.4bab	4c 6c 79	jmp $796c	Exec_50   JMP SYNTAX_ERROR
.4bae	c9 3a		cmp #$3a	Exec_55   CMP #':'
.4bb0	d0 f9		bne $4bab	          BNE Exec_50
.4bb2	4c 9f 4a	jmp $4a9f	          JMP Interpret
.4bb5					  Is_STOP_Key
.4bb5	20 93 92	jsr $9293	          JSR B_STOP
.4bb8	f0 01		beq $4bbb	          BEQ ISK_10
.4bba	60		rts		          RTS
.4bbb					  ISK_10
.4bbb	ac 0c 12	ldy $120c	          LDY TRAPNO+1
.4bbe	c8		iny		          INY
.4bbf	f0 0f		beq $4bd0	          BEQ END_20
.4bc1	20 93 92	jsr $9293	ISK_20    JSR B_STOP
.4bc4	f0 fb		beq $4bc1	          BEQ ISK_20
.4bc6	a2 1e		ldx #$1e	          LDX #$1e
.4bc8	4c 3c 4d	jmp $4d3c	          JMP Print_Error_X
.4bcb					  BASIC_STOP
.4bcb	b0 01		bcs $4bce	          BCS END_10
.4bcd					  BASIC_END
.4bcd	18		clc		          CLC ; $80
.4bce	d0 26		bne $4bf6	END_10    BNE END_Ret
.4bd0	24 7f		bit $7f		END_20    BIT RUNMOD
.4bd2	10 0d		bpl $4be1	          BPL END_30
.4bd4	20 34 4b	jsr $4b34	          JSR TXTPTR_TO_OLDTXT
.4bd7	a5 3b		lda $3b		          LDA CURLIN
.4bd9	a4 3c		ldy $3c		          LDY CURLIN+1
.4bdb	8d 00 12	sta $1200	          STA OLDLIN
.4bde	8c 01 12	sty $1201	          STY OLDLIN+1
.4be1	68		pla		END_30    PLA
.4be2	68		pla		          PLA
.4be3	90 0e		bcc $4bf3	          BCC END_40
.4be5	20 81 92	jsr $9281	          JSR B_PRIMM
>4be8	0d 0a 42 52 45 41 4b 00		          .TEXT "\r\nBREAK",0
.4bf0	4c af 4d	jmp $4daf	          JMP BAER_50
.4bf3	4c 37 4d	jmp $4d37	END_40    JMP BASIC_Ready
.4bf6	60		rts		END_Ret   RTS
.4bf7					  Call_Function
.4bf7	c9 ce		cmp #$ce	          CMP #$ce ; 2 byte token ?
.4bf9	f0 59		beq $4c54	          BEQ CALL_50
.4bfb	c9 d5		cmp #$d5	          CMP #$d5
.4bfd	b0 ac		bcs $4bab	          BCS Exec_50 ; illegal token
.4bff	c9 cb		cmp #$cb	          CMP #$cb
.4c01	90 02		bcc $4c05	          BCC CALL_10
.4c03	e9 01		sbc #$01	          SBC #1 ; skip $cb token
.4c05	48		pha		CALL_10   PHA
.4c06	aa		tax		          TAX
.4c07	20 80 03	jsr $0380	          JSR CHRGET
.4c0a	e0 d3		cpx #$d3	          CPX #$d3 ; ERR function
.4c0c	f0 08		beq $4c16	          BEQ CALL_20
.4c0e	e0 cb		cpx #$cb	          CPX #$cb ; function type B
.4c10	b0 29		bcs $4c3b	          BCS CALL_30
.4c12	e0 c8		cpx #$c8	          CPX #$c8
.4c14	90 25		bcc $4c3b	          BCC CALL_30
.4c16	20 59 79	jsr $7959	CALL_20   JSR Need_Left_Par
.4c19	20 ef 77	jsr $77ef	          JSR Eval_Expression
.4c1c	20 5c 79	jsr $795c	          JSR Need_Comma
.4c1f	20 dd 77	jsr $77dd	          JSR Need_String
.4c22	68		pla		          PLA
.4c23	c9 d3		cmp #$d3	          CMP #$d3
.4c25	f0 59		beq $4c80	          BEQ CALL_90
.4c27	aa		tax		          TAX
.4c28	a5 67		lda $67		          LDA FAC1_M4
.4c2a	48		pha		          PHA
.4c2b	a5 66		lda $66		          LDA FAC1_M3
.4c2d	48		pha		          PHA
.4c2e	8a		txa		          TXA
.4c2f	48		pha		          PHA
.4c30	20 f4 87	jsr $87f4	          JSR Get_Byte_Var
.4c33	68		pla		          PLA
.4c34	a8		tay		          TAY
.4c35	8a		txa		          TXA
.4c36	48		pha		          PHA
.4c37	98		tya		          TYA
.4c38	4c 3f 4c	jmp $4c3f	          JMP CALL_40
.4c3b	20 50 79	jsr $7950	CALL_30   JSR Get_Arg
.4c3e	68		pla		          PLA
.4c3f	38		sec		CALL_40   SEC
.4c40	e9 b4		sbc #$b4	          SBC #$b4
.4c42	0a		asl a		          ASL A
.4c43	a8		tay		          TAY
.4c44	b9 d9 47	lda $47d9,y	          LDA BASIC_Function_A+1,Y
.4c47	85 58		sta $58		          STA JUMPER+2
.4c49	b9 d8 47	lda $47d8,y	          LDA BASIC_Function_A,Y
.4c4c	85 57		sta $57		          STA JUMPER+1
.4c4e	20 56 00	jsr $0056	          JSR JUMPER
.4c51	4c da 77	jmp $77da	          JMP Assert_Numeric
.4c54	20 80 03	jsr $0380	CALL_50   JSR CHRGET
.4c57	f0 2a		beq $4c83	          BEQ CALL_99
.4c59	c9 0a		cmp #$0a	          CMP #10
.4c5b	f0 0b		beq $4c68	          BEQ CALL_60
.4c5d	48		pha		          PHA
.4c5e	20 80 03	jsr $0380	          JSR CHRGET
.4c61	20 59 79	jsr $7959	          JSR Need_Left_Par
.4c64	20 ef 77	jsr $77ef	          JSR Eval_Expression
.4c67	68		pla		          PLA
.4c68	c9 02		cmp #$02	CALL_60   CMP #2
.4c6a	90 08		bcc $4c74	          BCC CALL_70
.4c6c	c9 0b		cmp #$0b	          CMP #11
.4c6e	b0 04		bcs $4c74	          BCS CALL_70
.4c70	69 d1		adc #$d1	          ADC #$d1
.4c72	d0 cb		bne $4c3f	          BNE CALL_40
.4c74	38		sec		CALL_70   SEC
.4c75	20 7d 4c	jsr $4c7d	          JSR CALL_USR
.4c78					  CALL_80
.4c78	b0 09		bcs $4c83	          BCS CALL_99
.4c7a	4c da 77	jmp $77da	          JMP Assert_Numeric
.4c7d					  CALL_USR
.4c7d	6c fc 02	jmp ($02fc)	          JMP (USRVEC)        ; initialized to CALL_80
.4c80	4c c1 99	jmp $99c1	CALL_90   JMP FUNC_INSTR
.4c83	4c 6c 79	jmp $796c	CALL_99   JMP SYNTAX_ERROR
.4c86					  OP_OR
.4c86	a0 ff		ldy #$ff	          LDY #$ff
>4c88	2c				          .byte $2c ;BIT
.4c89					  OP_AND
.4c89	a0 00		ldy #$00	          LDY #0
.4c8b	84 0d		sty $0d		          STY B_COUNT
.4c8d	20 b4 84	jsr $84b4	          JSR Real_To_Integer
.4c90	a5 66		lda $66		          LDA FAC1_M3
.4c92	45 0d		eor $0d		          EOR B_COUNT
.4c94	85 09		sta $09		          STA CHARAC
.4c96	a5 67		lda $67		          LDA FAC1_M4
.4c98	45 0d		eor $0d		          EOR B_COUNT
.4c9a	85 0a		sta $0a		          STA ENDCHR
.4c9c	20 28 8c	jsr $8c28	          JSR FAC2_To_FAC1
.4c9f	20 b4 84	jsr $84b4	          JSR Real_To_Integer
.4ca2	a5 67		lda $67		          LDA FAC1_M4
.4ca4	45 0d		eor $0d		          EOR B_COUNT
.4ca6	25 0a		and $0a		          AND ENDCHR
.4ca8	45 0d		eor $0d		          EOR B_COUNT
.4caa	a8		tay		          TAY
.4cab	a5 66		lda $66		          LDA FAC1_M3
.4cad	45 0d		eor $0d		          EOR B_COUNT
.4caf	25 09		and $09		          AND CHARAC
.4cb1	45 0d		eor $0d		          EOR B_COUNT
.4cb3	4c 3c 79	jmp $793c	          JMP Integer_To_Real
.4cb6					  OP_COMPARE
.4cb6	20 de 77	jsr $77de	          JSR Check_Var_Type
.4cb9	b0 13		bcs $4cce	          BCS OPCO_10
.4cbb	a5 6f		lda $6f		          LDA FAC2_SI
.4cbd	09 7f		ora #$7f	          ORA #$7f
.4cbf	25 6b		and $6b		          AND FAC2_M1
.4cc1	85 6b		sta $6b		          STA FAC2_M1
.4cc3	a9 6a		lda #$6a	          LDA #<FAC2_EX
.4cc5	a0 00		ldy #$00	          LDY #>FAC2_EX
.4cc7	20 87 8c	jsr $8c87	          JSR Compare_AY_FAC1
.4cca	aa		tax		          TAX
.4ccb	4c 01 4d	jmp $4d01	          JMP OPCO_40
.4cce	a9 00		lda #$00	OPCO_10   LDA #0
.4cd0	85 0f		sta $0f		          STA VALTYP
.4cd2	c6 4f		dec $4f		          DEC OP_TMP
.4cd4	20 81 87	jsr $8781	          JSR Free_String_FAC1
.4cd7	85 63		sta $63		          STA FAC1_EX
.4cd9	86 64		stx $64		          STX FAC1_M1
.4cdb	84 65		sty $65		          STY FAC1_M2
.4cdd	a5 6d		lda $6d		          LDA FAC2_M3
.4cdf	a4 6e		ldy $6e		          LDY FAC2_M4
.4ce1	20 85 87	jsr $8785	          JSR Free_String_AY
.4ce4	86 6d		stx $6d		          STX FAC2_M3
.4ce6	84 6e		sty $6e		          STY FAC2_M4
.4ce8	aa		tax		          TAX
.4ce9	38		sec		          SEC
.4cea	e5 63		sbc $63		          SBC FAC1_EX
.4cec	f0 08		beq $4cf6	          BEQ OPCO_20
.4cee	a9 01		lda #$01	          LDA #1
.4cf0	90 04		bcc $4cf6	          BCC OPCO_20
.4cf2	a6 63		ldx $63		          LDX FAC1_EX
.4cf4	a9 ff		lda #$ff	          LDA #$ff
.4cf6	85 68		sta $68		OPCO_20   STA FAC1_SI
.4cf8	a0 ff		ldy #$ff	          LDY #$ff
.4cfa	e8		inx		          INX
.4cfb	c8		iny		OPCO_30   INY
.4cfc	ca		dex		          DEX
.4cfd	d0 07		bne $4d06	          BNE OPCO_50
.4cff	a6 68		ldx $68		          LDX FAC1_SI
.4d01	30 1b		bmi $4d1e	OPCO_40   BMI OPCO_60
.4d03	18		clc		          CLC
.4d04	90 18		bcc $4d1e	          BCC OPCO_60
.4d06	a9 6d		lda #$6d	OPCO_50   LDA #$6d
.4d08	20 ab 03	jsr $03ab	          JSR Fetch_1
.4d0b	48		pha		          PHA
.4d0c	a9 64		lda #$64	          LDA #$64
.4d0e	20 ab 03	jsr $03ab	          JSR Fetch_1
.4d11	85 79		sta $79		          STA SYNTMP
.4d13	68		pla		          PLA
.4d14	c5 79		cmp $79		          CMP SYNTMP
.4d16	f0 e3		beq $4cfb	          BEQ OPCO_30
.4d18	a2 ff		ldx #$ff	          LDX #$ff
.4d1a	b0 02		bcs $4d1e	          BCS OPCO_60
.4d1c	a2 01		ldx #$01	          LDX #1
.4d1e	e8		inx		OPCO_60   INX
.4d1f	8a		txa		          TXA
.4d20	2a		rol a		          ROL A
.4d21	25 14		and $14		          AND TANSGN
.4d23	f0 02		beq $4d27	          BEQ OPCO_70
.4d25	a9 ff		lda #$ff	          LDA #$ff
.4d27	4c 68 8c	jmp $8c68	OPCO_70   JMP A_To_FAC1
.4d2a					  Print_Ready
.4d2a	20 81 92	jsr $9281	          JSR B_PRIMM
>4d2d	0d 52 45 41 44 59 2e 0d		          .TEXT "\rREADY.\r",0
>4d35	00
.4d36	60		rts		          RTS
.4d37					  BASIC_Ready
.4d37	a2 80		ldx #$80	          LDX #$80
>4d39	2c				          .byte $2c ;BIT
.4d3a					  OOM_Error
.4d3a	a2 10		ldx #$10	          LDX #16
.4d3c					  Print_Error_X
.4d3c	6c 00 03	jmp ($0300)	          JMP (IERROR)        ; default: DEF_ERROR
.4d3f					  DEF_ERROR
.4d3f	8d 03 ff	sta $ff03	          STA MMU_LCRC        ; bank 0 and ROM and I/O
.4d42	8a		txa		          TXA                 ; error #
.4d43	30 72		bmi $4db7	          BMI BAER_60         ; -> no error
.4d45	8e 08 12	stx $1208	          STX ERRNUM          ; store error #
.4d48	24 7f		bit $7f		          BIT RUNMOD
.4d4a	10 30		bpl $4d7c	          BPL BAER_20         ; -> direct mode
.4d4c	a0 01		ldy #$01	          LDY #1
.4d4e	b9 3b 00	lda $003b,y	BAER_10   LDA CURLIN,Y        ; error line := current line
.4d51	99 09 12	sta $1209,y	          STA ERRLIN,Y
.4d54	b9 02 12	lda $1202,y	          LDA OLDTXT,Y        ; error position := current position
.4d57	99 0e 12	sta $120e,y	          STA ERRTXT,Y
.4d5a	88		dey		          DEY
.4d5b	10 f1		bpl $4d4e	          BPL BAER_10
.4d5d	ac 0c 12	ldy $120c	          LDY TRAPNO+1
.4d60	c8		iny		          INY
.4d61	f0 19		beq $4d7c	          BEQ BAER_20         ; -> no trap defined
.4d63	88		dey		          DEY                 ; Y = trap # high
.4d64	84 17		sty $17		          STY LINNUM+1
.4d66	8c 0d 12	sty $120d	          STY TMPTRP
.4d69	ac 0b 12	ldy $120b	          LDY TRAPNO
.4d6c	84 16		sty $16		          STY LINNUM          ; LINNUM := trap #
.4d6e	a2 ff		ldx #$ff	          LDX #$ff
.4d70	20 d1 7e	jsr $7ed1	          JSR Reset_Descriptor_Stack
.4d73	a6 82		ldx $82		          LDX OLDSTK
.4d75	9a		txs		          TXS                 ; reset stack pointer
.4d76	20 fb 59	jsr $59fb	          JSR GoTo_10         ; locate  trap code
.4d79	4c f6 4a	jmp $4af6	          JMP Next_Statement  ; execute trap code
.4d7c	ca		dex		BAER_20   DEX                 ; error # - 1
.4d7d	8a		txa		          TXA
.4d7e	20 82 4a	jsr $4a82	          JSR Set_Error_Index ; let INDEXB point to message
.4d81	20 6f 92	jsr $926f	          JSR B_CLRCH
.4d84	a9 00		lda #$00	          LDA #0
.4d86	85 15		sta $15		          STA CHANNL          ; default channel
.4d88	24 d7		bit $d7		          BIT MODE_80
.4d8a	30 02		bmi $4d8e	          BMI BAER_30
.4d8c	85 d8		sta $d8		          STA GRAPHM
.4d8e	20 98 55	jsr $5598	BAER_30   JSR Print_CR
.4d91	20 0a 56	jsr $560a	          JSR Print_Question_Mark
.4d94	a0 00		ldy #$00	          LDY #0
.4d96	b1 26		lda ($26),y	BAER_40   LDA (INDEXB),Y
.4d98	48		pha		          PHA
.4d99	29 7f		and #$7f	          AND #$7f
.4d9b	20 0c 56	jsr $560c	          JSR Print_Char      ; print error message
.4d9e	c8		iny		          INY
.4d9f	68		pla		          PLA
.4da0	10 f4		bpl $4d96	          BPL BAER_40
.4da2	20 38 52	jsr $5238	          JSR Init_BASIC_Stack
.4da5	20 81 92	jsr $9281	          JSR B_PRIMM
>4da8	20 45 52 52 4f 52 00		          .TEXT " ERROR",0    ; append "ERROR" to message
.4daf	a4 3c		ldy $3c		BAER_50   LDY CURLIN+1
.4db1	c8		iny		          INY
.4db2	f0 03		beq $4db7	          BEQ BAER_60
.4db4	20 26 8e	jsr $8e26	          JSR Print_IN_CURLIN ; print current line number
.4db7	20 2a 4d	jsr $4d2a	BAER_60   JSR Print_Ready     ; print prompt
.4dba	a9 80		lda #$80	          LDA #$80
.4dbc	20 90 ff	jsr $ff90	          JSR K_SETMSG
.4dbf	a9 00		lda #$00	          LDA #0
.4dc1	85 7f		sta $7f		          STA RUNMOD          ; return to direct mode
.4dc3	6c 02 03	jmp ($0302)	BAER_70   JMP (IMAIN)         ; default: DEF_MAIN
.4dc6					  DEF_MAIN
.4dc6	a2 ff		ldx #$ff	          LDX #$ff
.4dc8	86 3c		stx $3c		          STX CURLIN+1        ; invalidate CURLIN
.4dca	20 93 4f	jsr $4f93	          JSR Read_String
.4dcd	86 3d		stx $3d		MAIN_02   STX TXTPTR          ; (TXTPTR) := BUF-1
.4dcf	84 3e		sty $3e		          STY TXTPTR+1
.4dd1	20 80 03	jsr $0380	          JSR CHRGET          ; get 1st. char
.4dd4	aa		tax		          TAX
.4dd5	f0 ec		beq $4dc3	MAIN_04   BEQ BAER_70         ; no input: loop
.4dd7	90 09		bcc $4de2	          BCC MAIN_06         ; -> got number
.4dd9	20 0a 43	jsr $430a	          JSR CRUNCH          ; tokenize
.4ddc	20 86 03	jsr $0386	          JSR CHRGOT          ; get 1st. char
.4ddf	4c f3 4a	jmp $4af3	          JMP Inter_50        ; execute direct
.4de2	20 a0 50	jsr $50a0	MAIN_06   JSR Scan_Linenumber
.4de5	20 0a 43	jsr $430a	          JSR CRUNCH
.4de8	84 0d		sty $0d		          STY B_COUNT
.4dea	20 64 50	jsr $5064	          JSR Search_BASIC_Line
.4ded	90 7b		bcc $4e6a	          BCC MAIN_18         ; -> not found
.4def	a0 00		ldy #$00	          LDY #0
.4df1	20 ec 42	jsr $42ec	          JSR Get_LOWTR_0     ; link low of current line
.4df4	38		sec		          SEC
.4df5	e5 61		sbc $61		          SBC LOWTR           ; subtract current address
.4df7	38		sec		          SEC
.4df8	e9 04		sbc #$04	          SBC #4              ; subtract 4 for link & number
.4dfa	e5 0d		sbc $0d		          SBC B_COUNT         ; subtract new length
.4dfc	b0 1c		bcs $4e1a	          BCS MAIN_12         ; continue with high byte
.4dfe	49 ff		eor #$ff	          EOR #$ff
.4e00	69 01		adc #$01	          ADC #1
.4e02	ac 11 12	ldy $1211	          LDY TEXT_TOP+1      ; Y = old TEXT_TOP high
.4e05	6d 10 12	adc $1210	          ADC TEXT_TOP        ; A = new TEXT_TOP low
.4e08	90 01		bcc $4e0b	          BCC MAIN_08
.4e0a	c8		iny		          INY                 ; Y = new TEXT_TOP high
.4e0b	cc 13 12	cpy $1213	MAIN_08   CPY TEXT_MAX+1     ; test for Out Of Memory
.4e0e	90 0a		bcc $4e1a	          BCC MAIN_12
.4e10	d0 05		bne $4e17	          BNE MAIN_10
.4e12	cd 12 12	cmp $1212	          CMP TEXT_MAX
.4e15	90 03		bcc $4e1a	          BCC MAIN_12
.4e17	4c 3a 4d	jmp $4d3a	MAIN_10   JMP OOM_Error
.4e1a	a0 01		ldy #$01	MAIN_12   LDY #1
.4e1c	20 ec 42	jsr $42ec	          JSR Get_LOWTR_0     ; link high of current line
.4e1f	85 25		sta $25		          STA INDEXA+1
.4e21	ad 10 12	lda $1210	          LDA TEXT_TOP
.4e24	85 24		sta $24		          STA INDEXA          ; (INDEXA) = read pointer
.4e26	a5 62		lda $62		          LDA LOWTR+1
.4e28	85 27		sta $27		          STA INDEXB+1
.4e2a	88		dey		          DEY
.4e2b	20 ec 42	jsr $42ec	          JSR Get_LOWTR_0
.4e2e	18		clc		          CLC
.4e2f	e5 61		sbc $61		          SBC LOWTR
.4e31	49 ff		eor #$ff	          EOR #%11111111 ; $ff
.4e33	18		clc		          CLC
.4e34	6d 10 12	adc $1210	          ADC TEXT_TOP
.4e37	8d 10 12	sta $1210	          STA TEXT_TOP
.4e3a	85 26		sta $26		          STA INDEXB          ; (INDEXB) = write pointer
.4e3c	ad 11 12	lda $1211	          LDA TEXT_TOP+1
.4e3f	69 ff		adc #$ff	          ADC #$ff
.4e41	8d 11 12	sta $1211	          STA TEXT_TOP+1
.4e44	e5 62		sbc $62		          SBC LOWTR+1
.4e46	aa		tax		          TAX
.4e47	38		sec		          SEC
.4e48	a5 61		lda $61		          LDA LOWTR
.4e4a	ed 10 12	sbc $1210	          SBC TEXT_TOP
.4e4d	a8		tay		          TAY
.4e4e	b0 03		bcs $4e53	          BCS MAIN_14
.4e50	e8		inx		          INX                 ; X = number of blocks to move
.4e51	c6 27		dec $27		          DEC INDEXB+1
.4e53	18		clc		MAIN_14   CLC
.4e54	65 24		adc $24		          ADC INDEXA
.4e56	90 03		bcc $4e5b	          BCC MAIN_16
.4e58	c6 25		dec $25		          DEC INDEXA+1
.4e5a	18		clc		          CLC
.4e5b	20 05 43	jsr $4305	MAIN_16   JSR Get_INDEXA_0    ; delete current line
.4e5e	91 26		sta ($26),y	          STA (INDEXB),Y      ; by moving upper part of program down
.4e60	c8		iny		          INY
.4e61	d0 f8		bne $4e5b	          BNE MAIN_16
.4e63	e6 25		inc $25		          INC INDEXA+1
.4e65	e6 27		inc $27		          INC INDEXB+1
.4e67	ca		dex		          DEX
.4e68	d0 f1		bne $4e5b	          BNE MAIN_16
.4e6a	20 38 52	jsr $5238	MAIN_18   JSR Init_BASIC_Stack
.4e6d	20 4f 4f	jsr $4f4f	          JSR Relink
.4e70	a0 00		ldy #$00	          LDY #0
.4e72	b1 3d		lda ($3d),y	          LDA (TXTPTR),Y
.4e74	d0 03		bne $4e79	          BNE MAIN_20
.4e76	4c d5 4d	jmp $4dd5	          JMP MAIN_04         ; -> nothing to insert
.4e79	18		clc		MAIN_20   CLC
.4e7a	ad 10 12	lda $1210	          LDA TEXT_TOP
.4e7d	ac 11 12	ldy $1211	          LDY TEXT_TOP+1
.4e80	85 5c		sta $5c		          STA HIGHTR          ; (HIGHTR) = (TEXT_TOP)
.4e82	84 5d		sty $5d		          STY HIGHTR+1
.4e84	65 0d		adc $0d		          ADC B_COUNT         ; length of new line
.4e86	90 01		bcc $4e89	          BCC MAIN_22
.4e88	c8		iny		          INY
.4e89	18		clc		MAIN_22   CLC
.4e8a	69 04		adc #$04	          ADC #4              ; plus link & number
.4e8c	90 01		bcc $4e8f	          BCC MAIN_24
.4e8e	c8		iny		          INY
.4e8f	85 5a		sta $5a		MAIN_24   STA ARYPNT          ; (ARYPNT) = new TEXT_TOP
.4e91	84 5b		sty $5b		          STY ARYPNT+1
.4e93	cc 13 12	cpy $1213	          CPY TEXT_MAX+1     ; check for OOM
.4e96	90 0a		bcc $4ea2	          BCC MAIN_28
.4e98	d0 05		bne $4e9f	          BNE MAIN_26
.4e9a	cd 12 12	cmp $1212	          CMP TEXT_MAX
.4e9d	90 03		bcc $4ea2	          BCC MAIN_28
.4e9f	4c 3a 4d	jmp $4d3a	MAIN_26   JMP OOM_Error
.4ea2	8d 10 12	sta $1210	MAIN_28   STA TEXT_TOP        ; update TEXT_TOP
.4ea5	8c 11 12	sty $1211	          STY TEXT_TOP+1
.4ea8	38		sec		          SEC
.4ea9	a5 5c		lda $5c		          LDA HIGHTR
.4eab	e5 61		sbc $61		          SBC LOWTR
.4ead	85 24		sta $24		          STA INDEXA
.4eaf	a8		tay		          TAY
.4eb0	a5 5d		lda $5d		          LDA HIGHTR+1
.4eb2	e5 62		sbc $62		          SBC LOWTR+1
.4eb4	aa		tax		          TAX
.4eb5	e8		inx		          INX
.4eb6	98		tya		          TYA
.4eb7	f0 25		beq $4ede	          BEQ MAIN_36
.4eb9	a5 5c		lda $5c		          LDA HIGHTR
.4ebb	38		sec		          SEC
.4ebc	e5 24		sbc $24		          SBC INDEXA
.4ebe	85 5c		sta $5c		          STA HIGHTR
.4ec0	b0 03		bcs $4ec5	          BCS MAIN_30
.4ec2	c6 5d		dec $5d		          DEC HIGHTR+1
.4ec4	38		sec		          SEC
.4ec5	a5 5a		lda $5a		MAIN_30   LDA ARYPNT
.4ec7	e5 24		sbc $24		          SBC INDEXA
.4ec9	85 5a		sta $5a		          STA ARYPNT
.4ecb	b0 09		bcs $4ed6	          BCS MAIN_34
.4ecd	c6 5b		dec $5b		          DEC ARYPNT+1
.4ecf	90 05		bcc $4ed6	          BCC MAIN_34
.4ed1	20 dd 42	jsr $42dd	MAIN_32   JSR Get_HIGHTR_0
.4ed4	91 5a		sta ($5a),y	          STA (ARYPNT),Y
.4ed6	88		dey		MAIN_34   DEY
.4ed7	d0 f8		bne $4ed1	          BNE MAIN_32
.4ed9	20 dd 42	jsr $42dd	          JSR Get_HIGHTR_0
.4edc	91 5a		sta ($5a),y	          STA (ARYPNT),Y
.4ede	c6 5d		dec $5d		MAIN_36   DEC HIGHTR+1
.4ee0	c6 5b		dec $5b		          DEC ARYPNT+1
.4ee2	ca		dex		          DEX                 ; blocks to move
.4ee3	d0 f1		bne $4ed6	          BNE MAIN_34
.4ee5	a0 00		ldy #$00	          LDY #0
.4ee7	a9 01		lda #$01	          LDA #1
.4ee9	91 61		sta ($61),y	          STA (LOWTR),Y       ; Y=0: dummy link low
.4eeb	c8		iny		          INY
.4eec	91 61		sta ($61),y	          STA (LOWTR),Y       ; Y=1: dummy link high
.4eee	c8		iny		          INY
.4eef	a5 16		lda $16		          LDA LINNUM
.4ef1	91 61		sta ($61),y	          STA (LOWTR),Y       ; Y=2: line # low
.4ef3	a5 17		lda $17		          LDA LINNUM+1
.4ef5	c8		iny		          INY
.4ef6	91 61		sta ($61),y	          STA (LOWTR),Y       ; Y=3: line # high
.4ef8	18		clc		          CLC
.4ef9	a5 61		lda $61		          LDA LOWTR
.4efb	69 04		adc #$04	          ADC #4
.4efd	85 61		sta $61		          STA LOWTR
.4eff	90 02		bcc $4f03	          BCC MAIN_38
.4f01	e6 62		inc $62		          INC LOWTR+1         ; (LOWTR) += 4
.4f03	a4 0d		ldy $0d		MAIN_38   LDY B_COUNT         ; length of new line
.4f05	88		dey		          DEY
.4f06	b1 3d		lda ($3d),y	MAIN_40   LDA (TXTPTR),Y      ; from BUF
.4f08	91 61		sta ($61),y	          STA (LOWTR),Y       ; to program
.4f0a	88		dey		          DEY
.4f0b	c0 ff		cpy #$ff	          CPY #$ff
.4f0d	d0 f7		bne $4f06	          BNE MAIN_40
.4f0f	20 4f 4f	jsr $4f4f	          JSR Relink
.4f12	20 54 52	jsr $5254	          JSR Reset_TXTPTR
.4f15	a5 74		lda $74		          LDA AUTINC
.4f17	05 75		ora $75		          ORA AUTINC+1
.4f19	f0 31		beq $4f4c	          BEQ MAIN_46         ; -> no AUTO increment active
.4f1b	a5 16		lda $16		          LDA LINNUM
.4f1d	18		clc		          CLC
.4f1e	65 74		adc $74		          ADC AUTINC
.4f20	85 65		sta $65		          STA FAC1_M2
.4f22	a5 17		lda $17		          LDA LINNUM+1
.4f24	65 75		adc $75		          ADC AUTINC+1
.4f26	b0 24		bcs $4f4c	          BCS MAIN_46
.4f28	c9 fa		cmp #$fa	          CMP #$fa            ; check for overflow 64000
.4f2a	b0 20		bcs $4f4c	          BCS MAIN_46
.4f2c	85 64		sta $64		          STA FAC1_M1
.4f2e	a2 90		ldx #$90	          LDX #$90
.4f30	38		sec		          SEC
.4f31	20 75 8c	jsr $8c75	          JSR Word_To_FAC1
.4f34	20 42 8e	jsr $8e42	          JSR Format_FAC1     ; write new number to STACK
.4f37	a2 00		ldx #$00	          LDX #0
.4f39	bd 01 01	lda $0101,x	MAIN_42   LDA STACK+1,X       ; insert new number into keyboard buffer
.4f3c	f0 06		beq $4f44	          BEQ MAIN_44
.4f3e	9d 4a 03	sta $034a,x	          STA KEYD,X
.4f41	e8		inx		          INX
.4f42	d0 f5		bne $4f39	          BNE MAIN_42
.4f44	a9 1d		lda #$1d	MAIN_44   LDA #$1d            ; add cursor right
.4f46	9d 4a 03	sta $034a,x	          STA KEYD,X
.4f49	e8		inx		          INX
.4f4a	86 d0		stx $d0		          STX NDX             ; update length of keyboard buffer
.4f4c	4c c3 4d	jmp $4dc3	MAIN_46   JMP BAER_70
.4f4f					  Relink
.4f4f	a5 2d		lda $2d		          LDA TXTTAB
.4f51	a4 2e		ldy $2e		          LDY TXTTAB+1
.4f53	85 24		sta $24		          STA INDEXA
.4f55	84 25		sty $25		          STY INDEXA+1        ; (INDEXA) = start of program
.4f57	18		clc		          CLC
.4f58	a0 00		ldy #$00	Reli_10   LDY #0
.4f5a	20 05 43	jsr $4305	          JSR Get_INDEXA_0    ; old link low
.4f5d	d0 06		bne $4f65	          BNE Reli_20
.4f5f	c8		iny		          INY
.4f60	20 05 43	jsr $4305	          JSR Get_INDEXA_0    ; old link high
.4f63	f0 2d		beq $4f92	          BEQ Reli_Ret        ; finish for zero link
.4f65	a0 04		ldy #$04	Reli_20   LDY #4
.4f67	c8		iny		Reli_30   INY                 ; start with Y = 5
.4f68	20 05 43	jsr $4305	          JSR Get_INDEXA_0
.4f6b	d0 fa		bne $4f67	          BNE Reli_30         ; loop until end of line
.4f6d	c8		iny		          INY                 ; Y = length of line
.4f6e	98		tya		          TYA
.4f6f	65 24		adc $24		          ADC INDEXA
.4f71	aa		tax		          TAX                 ; X = new link low
.4f72	a0 00		ldy #$00	          LDY #0              ; Y = 0
.4f74	91 24		sta ($24),y	          STA (INDEXA),Y      ; update link low
.4f76	98		tya		          TYA                 ; A = 0
.4f77	65 25		adc $25		          ADC INDEXA+1        ; A = new link high
.4f79	c8		iny		          INY                 ; Y = 1
.4f7a	91 24		sta ($24),y	          STA (INDEXA),Y      ; update link high
.4f7c	86 24		stx $24		          STX INDEXA
.4f7e	85 25		sta $25		          STA INDEXA+1        ; (INDEXA) = next line
.4f80	90 d6		bcc $4f58	          BCC Reli_10         ; branch always
.4f82					  Set_TEXT_TOP
.4f82	18		clc		          CLC
.4f83	a5 24		lda $24		          LDA INDEXA
.4f85	a4 25		ldy $25		          LDY INDEXA+1
.4f87	69 02		adc #$02	          ADC #2
.4f89	90 01		bcc $4f8c	          BCC STT_10
.4f8b	c8		iny		          INY
.4f8c	8d 10 12	sta $1210	STT_10    STA TEXT_TOP
.4f8f	8c 11 12	sty $1211	          STY TEXT_TOP+1
.4f92	60		rts		Reli_Ret  RTS
.4f93					  Read_String
.4f93	a2 00		ldx #$00	          LDX #0
.4f95	20 e5 90	jsr $90e5	ReaS_10   JSR CHRIN
.4f98	c9 0d		cmp #$0d	          CMP #CR
.4f9a	d0 03		bne $4f9f	          BNE ReaS_20
.4f9c	4c 8b 55	jmp $558b	          JMP Terminate_BUF
.4f9f	9d 00 02	sta $0200,x	ReaS_20   STA BUF,X
.4fa2	e8		inx		          INX
.4fa3	e0 a1		cpx #$a1	          CPX #161            ; max. 2 lines at 80 characters each
.4fa5	90 ee		bcc $4f95	          BCC ReaS_10
.4fa7	4c ed a5	jmp $a5ed	          JMP String_Too_Long
.4faa					  Find_Token_On_Stack
.4faa	85 02		sta $02		          STA BANK            ; store search token
.4fac	20 47 50	jsr $5047	          JSR Init_FNDPNT     ; (FNDPNT) = (TOS) = $09ff
.4faf	a5 3f		lda $3f		FTOS_10   LDA FNDPNT
.4fb1	c9 ff		cmp #$ff	          CMP #<BASIC_STACK+$1ff
.4fb3	d0 06		bne $4fbb	          BNE FTOS_20
.4fb5	a5 40		lda $40		          LDA FNDPNT+1
.4fb7	c9 09		cmp #$09	          CMP #>BASIC_STACK+$1ff
.4fb9	f0 40		beq $4ffb	          BEQ FTOS_60         ; -> stack is empty
.4fbb	8d 03 ff	sta $ff03	FTOS_20   STA MMU_LCRC
.4fbe	a0 00		ldy #$00	          LDY #0
.4fc0	a5 02		lda $02		          LDA BANK            ; search token
.4fc2	c9 81		cmp #$81	          CMP #$81            ; FOR token
.4fc4	d0 1b		bne $4fe1	          BNE FTOS_40         ; -> not FOR token
.4fc6	d1 3f		cmp ($3f),y	          CMP (FNDPNT),Y      ; loop marker ?
.4fc8	d0 33		bne $4ffd	          BNE FTOS_Ret
.4fca	a0 02		ldy #$02	          LDY #2
.4fcc	a5 4c		lda $4c		          LDA FORPNT+1
.4fce	c9 ff		cmp #$ff	          CMP #$ff
.4fd0	f0 2b		beq $4ffd	          BEQ FTOS_Ret        ; -> invalid address of (FORPNT)
.4fd2	d1 3f		cmp ($3f),y	          CMP (FNDPNT),Y
.4fd4	d0 07		bne $4fdd	          BNE FTOS_30         ; -> index variables do not match
.4fd6	88		dey		          DEY
.4fd7	a5 4b		lda $4b		          LDA FORPNT
.4fd9	d1 3f		cmp ($3f),y	          CMP (FNDPNT),Y
.4fdb	f0 20		beq $4ffd	          BEQ FTOS_Ret        ; -> Found valid FOR structure
.4fdd	a2 12		ldx #$12	FTOS_30   LDX #$12            ; length of FOR structure
.4fdf	d0 0e		bne $4fef	          BNE FTOS_50         ; branch always
.4fe1	b1 3f		lda ($3f),y	FTOS_40   LDA (FNDPNT),Y
.4fe3	c5 02		cmp $02		          CMP BANK
.4fe5	f0 16		beq $4ffd	          BEQ FTOS_Ret        ; Found token on stack
.4fe7	a2 12		ldx #$12	          LDX #$12            ; length of FOR structure
.4fe9	c9 81		cmp #$81	          CMP #$81            ; looking for FOR ?
.4feb	f0 02		beq $4fef	          BEQ FTOS_50
.4fed	a2 05		ldx #$05	          LDX #5              ; length of other structures
.4fef	8a		txa		FTOS_50   TXA
.4ff0	18		clc		          CLC
.4ff1	65 3f		adc $3f		          ADC FNDPNT          ; move FNDPNT to next structure
.4ff3	85 3f		sta $3f		          STA FNDPNT
.4ff5	90 b8		bcc $4faf	          BCC FTOS_10
.4ff7	e6 40		inc $40		          INC FNDPNT+1
.4ff9	d0 b4		bne $4faf	          BNE FTOS_10         ; branch always
.4ffb	a0 01		ldy #$01	FTOS_60   LDY #1              ; Z=0 : not found
.4ffd	60		rts		FTOS_Ret  RTS                 ; Z=1 : found
.4ffe					  SUB_TOS
.4ffe	49 ff		eor #$ff	          EOR #$ff
.5000	38		sec		          SEC
.5001	65 7d		adc $7d		          ADC TOS
.5003	85 7d		sta $7d		          STA TOS
.5005	a4 7e		ldy $7e		          LDY TOS+1
.5007	b0 01		bcs $500a	          BCS SUTO_10
.5009	88		dey		          DEY
.500a	84 7e		sty $7e		SUTO_10   STY TOS+1
.500c	c0 08		cpy #$08	          CPY #8
.500e	90 34		bcc $5044	          BCC CMA_OOM
.5010	d0 04		bne $5016	          BNE SUTO_Ret
.5012	c5 7d		cmp $7d		          CMP TOS
.5014	90 2e		bcc $5044	          BCC CMA_OOM
.5016	60		rts		SUTO_Ret  RTS
.5017					  Check_Mem_Avail
.5017	c4 36		cpy $36		          CPY FRETOP+1
.5019	90 28		bcc $5043	          BCC CMA_40
.501b	d0 04		bne $5021	          BNE CMA_10
.501d	c5 35		cmp $35		          CMP FRETOP
.501f	90 22		bcc $5043	          BCC CMA_40
.5021	48		pha		CMA_10    PHA
.5022	a2 09		ldx #$09	          LDX #9              ; push $59 - $62
.5024	98		tya		          TYA
.5025	48		pha		CMA_20    PHA
.5026	b5 59		lda $59,x	          LDA FACTPA,X
.5028	ca		dex		          DEX
.5029	10 fa		bpl $5025	          BPL CMA_20
.502b	20 ea 92	jsr $92ea	          JSR Garbage_Collection
.502e	a2 f7		ldx #$f7	          LDX #$f7
.5030	68		pla		CMA_30    PLA
.5031	95 63		sta $63,x	          STA FAC1_EX,X       ; pull $59 - $62
.5033	e8		inx		          INX
.5034	30 fa		bmi $5030	          BMI CMA_30
.5036	68		pla		          PLA
.5037	a8		tay		          TAY
.5038	68		pla		          PLA
.5039	c4 36		cpy $36		          CPY FRETOP+1
.503b	90 06		bcc $5043	          BCC CMA_40
.503d	d0 05		bne $5044	          BNE CMA_OOM
.503f	c5 35		cmp $35		          CMP FRETOP
.5041	b0 01		bcs $5044	          BCS CMA_OOM
.5043	60		rts		CMA_40    RTS
.5044	4c 3a 4d	jmp $4d3a	CMA_OOM   JMP OOM_Error
.5047					  Init_FNDPNT
.5047	a5 7d		lda $7d		          LDA TOS
.5049	85 3f		sta $3f		          STA FNDPNT
.504b	a5 7e		lda $7e		          LDA TOS+1
.504d	85 40		sta $40		          STA FNDPNT+1
.504f	60		rts		          RTS
.5050					  Update_TOS
.5050	a5 3f		lda $3f		          LDA FNDPNT
.5052	85 7d		sta $7d		          STA TOS
.5054	a5 40		lda $40		          LDA FNDPNT+1
.5056	85 7e		sta $7e		          STA TOS+1
.5058	60		rts		          RTS
.5059					  Free_TOS
.5059	98		tya		          TYA
.505a	18		clc		          CLC
.505b	65 7d		adc $7d		          ADC TOS
.505d	85 7d		sta $7d		          STA TOS
.505f	90 02		bcc $5063	          BCC FreT_Ret
.5061	e6 7e		inc $7e		          INC TOS+1
.5063	60		rts		FreT_Ret  RTS
.5064					  Search_BASIC_Line
.5064	a5 2d		lda $2d		          LDA TXTTAB
.5066	a6 2e		ldx $2e		          LDX TXTTAB+1
.5068					  Find_LINNUM_AX
.5068	a0 01		ldy #$01	          LDY #1
.506a	85 61		sta $61		          STA LOWTR
.506c	86 62		stx $62		          STX LOWTR+1
.506e	20 ec 42	jsr $42ec	          JSR Get_LOWTR_0     ; link high
.5071	f0 2b		beq $509e	          BEQ SBL_30
.5073	c8		iny		          INY                 ; Y = 2
.5074	c8		iny		          INY                 ; Y = 3
.5075	20 ec 42	jsr $42ec	          JSR Get_LOWTR_0     ; # high
.5078	85 79		sta $79		          STA SYNTMP
.507a	a5 17		lda $17		          LDA LINNUM+1
.507c	c5 79		cmp $79		          CMP SYNTMP
.507e	90 1f		bcc $509f	          BCC SBL_Ret         ; beyond # -> not found
.5080	f0 03		beq $5085	          BEQ SBL_10          ; high bytes match: -> continue
.5082	88		dey		          DEY                 ; Y = 2
.5083	d0 0e		bne $5093	          BNE SBL_20          ; branch always
.5085	88		dey		SBL_10    DEY                 ; Y = 2
.5086	20 ec 42	jsr $42ec	          JSR Get_LOWTR_0     ; # low
.5089	85 79		sta $79		          STA SYNTMP
.508b	a5 16		lda $16		          LDA LINNUM
.508d	c5 79		cmp $79		          CMP SYNTMP
.508f	90 0e		bcc $509f	          BCC SBL_Ret         ; beyond # -> not found
.5091	f0 0c		beq $509f	          BEQ SBL_Ret         ; -> found
.5093	88		dey		SBL_20    DEY                 ; Y = 1
.5094	20 ec 42	jsr $42ec	          JSR Get_LOWTR_0     ; link high
.5097	aa		tax		          TAX
.5098	88		dey		          DEY                 ; Y = 0
.5099	20 ec 42	jsr $42ec	          JSR Get_LOWTR_0     ; link low
.509c	b0 ca		bcs $5068	          BCS Find_LINNUM_AX  ; brnach always
.509e	18		clc		SBL_30    CLC                 ; C=0 : not found
.509f	60		rts		SBL_Ret   RTS
.50a0					  Scan_Linenumber
.50a0	a2 00		ldx #$00	          LDX #0
.50a2	86 0a		stx $0a		          STX ENDCHR
.50a4	86 16		stx $16		          STX LINNUM
.50a6	86 17		stx $17		          STX LINNUM+1
.50a8	b0 37		bcs $50e1	ScLi_10   BCS ScLi_Ret
.50aa	e6 0a		inc $0a		          INC ENDCHR
.50ac	e9 2f		sbc #$2f	          SBC #$2f ; '/'
.50ae	85 09		sta $09		          STA CHARAC
.50b0	a5 17		lda $17		          LDA LINNUM+1
.50b2	85 24		sta $24		          STA INDEXA
.50b4	c9 19		cmp #$19	          CMP #$19
.50b6	90 03		bcc $50bb	          BCC ScLi_20
.50b8	4c 6c 79	jmp $796c	          JMP SYNTAX_ERROR
.50bb	a5 16		lda $16		ScLi_20   LDA LINNUM
.50bd	0a		asl a		          ASL A
.50be	26 24		rol $24		          ROL INDEXA
.50c0	0a		asl a		          ASL A
.50c1	26 24		rol $24		          ROL INDEXA
.50c3	65 16		adc $16		          ADC LINNUM
.50c5	85 16		sta $16		          STA LINNUM
.50c7	a5 24		lda $24		          LDA INDEXA
.50c9	65 17		adc $17		          ADC LINNUM+1
.50cb	85 17		sta $17		          STA LINNUM+1
.50cd	06 16		asl $16		          ASL LINNUM
.50cf	26 17		rol $17		          ROL LINNUM+1
.50d1	a5 16		lda $16		          LDA LINNUM
.50d3	65 09		adc $09		          ADC CHARAC
.50d5	85 16		sta $16		          STA LINNUM
.50d7	90 02		bcc $50db	          BCC ScLi_30
.50d9	e6 17		inc $17		          INC LINNUM+1
.50db	20 80 03	jsr $0380	ScLi_30   JSR CHRGET
.50de	4c a8 50	jmp $50a8	          JMP ScLi_10
.50e1	60		rts		ScLi_Ret  RTS
.50e2					  BASIC_LIST
.50e2	20 fb 5e	jsr $5efb	          JSR Get_Line_Range
.50e5	a0 01		ldy #$01	LIST_10   LDY #1              ; Y = 1
.50e7	20 ec 42	jsr $42ec	          JSR Get_LOWTR_0     ; link high
.50ea	d0 06		bne $50f2	          BNE LIST_20
.50ec	88		dey		          DEY                 ; Y = 0
.50ed	20 ec 42	jsr $42ec	          JSR Get_LOWTR_0     ; link low
.50f0	f0 2e		beq $5120	          BEQ LIST_50         ; zero link: -> finish
.50f2	20 b5 4b	jsr $4bb5	LIST_20   JSR Is_STOP_Key     ; check STOP key
.50f5	20 98 55	jsr $5598	          JSR Print_CR        ; start listing with newline
.50f8	a0 02		ldy #$02	          LDY #2              ; Y = 2
.50fa	20 ec 42	jsr $42ec	          JSR Get_LOWTR_0     ; line # low
.50fd	aa		tax		          TAX
.50fe	c8		iny		          INY                 ; Y = 3
.50ff	20 ec 42	jsr $42ec	          JSR Get_LOWTR_0     ; line # high
.5102	c5 17		cmp $17		          CMP LINNUM+1        ; compare with end value
.5104	d0 04		bne $510a	          BNE LIST_30
.5106	e4 16		cpx $16		          CPX LINNUM
.5108	f0 02		beq $510c	          BEQ LIST_40
.510a	b0 14		bcs $5120	LIST_30   BCS LIST_50         ; line # > end -> finish
.510c	20 23 51	jsr $5123	LIST_40   JSR List_Line
.510f	a0 00		ldy #$00	          LDY #0              ; Y = 0
.5111	20 ec 42	jsr $42ec	          JSR Get_LOWTR_0     ; link low
.5114	aa		tax		          TAX
.5115	c8		iny		          INY                 ; Y = 1
.5116	20 ec 42	jsr $42ec	          JSR Get_LOWTR_0     ; link high
.5119	86 61		stx $61		          STX LOWTR           ; set link to next line
.511b	85 62		sta $62		          STA LOWTR+1
.511d	4c e5 50	jmp $50e5	          JMP LIST_10         ; continue with next line
.5120	4c 98 55	jmp $5598	LIST_50   JMP Print_CR        ; LIST finished
.5123					  List_Line
.5123	a0 03		ldy #$03	          LDY #3
.5125	84 4b		sty $4b		          STY FORPNT
.5127	84 11		sty $11		          STY GARBFL
.5129	20 32 8e	jsr $8e32	          JSR Print_Integer_XA
.512c	a9 20		lda #$20	          LDA #' '
.512e	a4 4b		ldy $4b		LiLi_10   LDY FORPNT
.5130	29 7f		and #$7f	          AND #$7f
.5132	20 0c 56	jsr $560c	LiLi_15   JSR Print_Char
.5135	c9 22		cmp #$22	          CMP #QUOTE
.5137	d0 06		bne $513f	          BNE LiLi_20
.5139	a5 11		lda $11		          LDA GARBFL
.513b	49 ff		eor #$ff	          EOR #$ff
.513d	85 11		sta $11		          STA GARBFL
.513f	c8		iny		LiLi_20   INY
.5140	f0 de		beq $5120	          BEQ LIST_50
.5142	24 55		bit $55		          BIT HELPER
.5144	10 03		bpl $5149	          BPL LiLi_25
.5146	20 ac 59	jsr $59ac	          JSR At_Error_Position
.5149	20 ec 42	jsr $42ec	LiLi_25   JSR Get_LOWTR_0
.514c	f0 3d		beq $518b	          BEQ LiLi_60
.514e	6c 06 03	jmp ($0306)	          JMP (IQPLOP)
.5151					  DEF_QPLOP
.5151	10 df		bpl $5132	          BPL LiLi_15
.5153	c9 ff		cmp #$ff	          CMP #PICHAR
.5155	f0 db		beq $5132	          BEQ LiLi_15
.5157	24 11		bit $11		          BIT GARBFL
.5159	30 d7		bmi $5132	          BMI LiLi_15
.515b	c9 fe		cmp #$fe	          CMP #$fe            ; token group $fe..
.515d	f0 2d		beq $518c	          BEQ LiLi_65
.515f	c9 ce		cmp #$ce	          CMP #$ce            ; token group $ce..
.5161	f0 43		beq $51a6	          BEQ LiLi_70
.5163	aa		tax		          TAX
.5164	84 4b		sty $4b		          STY FORPNT
.5166	a9 44		lda #$44	          LDA #>BASIC_Keytab_A
.5168	a0 17		ldy #$17	          LDY #<BASIC_Keytab_A
.516a	85 25		sta $25		LiLi_30   STA INDEXA+1
.516c	84 24		sty $24		          STY INDEXA
.516e	a0 00		ldy #$00	          LDY #0
.5170	ca		dex		LiLi_35   DEX
.5171	10 0f		bpl $5182	          BPL LiLi_55
.5173	b1 24		lda ($24),y	LiLi_40   LDA (INDEXA),Y
.5175	48		pha		          PHA
.5176	e6 24		inc $24		          INC INDEXA
.5178	d0 02		bne $517c	          BNE LiLi_45
.517a	e6 25		inc $25		          INC INDEXA+1
.517c	68		pla		LiLi_45   PLA
.517d	10 f4		bpl $5173	          BPL LiLi_40
.517f	30 ef		bmi $5170	          BMI LiLi_35
.5181	c8		iny		LiLi_50   INY
.5182	b1 24		lda ($24),y	LiLi_55   LDA (INDEXA),Y
.5184	30 a8		bmi $512e	          BMI LiLi_10
.5186	20 0c 56	jsr $560c	          JSR Print_Char
.5189	d0 f6		bne $5181	          BNE LiLi_50
.518b	60		rts		LiLi_60   RTS
.518c	aa		tax		LiLi_65   TAX
.518d	c8		iny		          INY
.518e	20 ec 42	jsr $42ec	          JSR Get_LOWTR_0
.5191	f0 9f		beq $5132	          BEQ LiLi_15
.5193	84 4b		sty $4b		          STY FORPNT
.5195	c9 02		cmp #$02	          CMP #2
.5197	90 27		bcc $51c0	          BCC LiLi_75
.5199	c9 27		cmp #$27	          CMP #APOSTR
.519b	b0 23		bcs $51c0	          BCS LiLi_75
.519d	69 7e		adc #$7e	          ADC #$7e
.519f	aa		tax		          TAX
.51a0	a0 09		ldy #$09	          LDY #<BASIC_Keytab_C
.51a2	a9 46		lda #$46	          LDA #>BASIC_Keytab_C
.51a4	d0 c4		bne $516a	          BNE LiLi_30
.51a6	aa		tax		LiLi_70   TAX
.51a7	c8		iny		          INY
.51a8	20 ec 42	jsr $42ec	          JSR Get_LOWTR_0
.51ab	f0 85		beq $5132	          BEQ LiLi_15
.51ad	84 4b		sty $4b		          STY FORPNT
.51af	c9 02		cmp #$02	          CMP #2              ; from $ce02 (POT)
.51b1	90 0d		bcc $51c0	          BCC LiLi_75
.51b3	c9 0b		cmp #$0b	          CMP #11             ; to   $ce0a (POINTER)
.51b5	b0 09		bcs $51c0	          BCS LiLi_75
.51b7	69 7e		adc #$7e	          ADC #$7e
.51b9	aa		tax		          TAX
.51ba	a0 c9		ldy #$c9	          LDY #<BASIC_Keytab_D
.51bc	a9 46		lda #$46	          LDA #>BASIC_Keytab_D
.51be	d0 aa		bne $516a	          BNE LiLi_30
.51c0	e0 fe		cpx #$fe	LiLi_75   CPX #$fe
.51c2	d0 03		bne $51c7	          BNE LiLi_80
.51c4	a2 00		ldx #$00	          LDX #0
>51c6	2c				          .byte $2c ;BIT
.51c7	a2 ff		ldx #$ff	LiLi_80   LDX #$ff
.51c9	38		sec		          SEC
.51ca	6c 0e 03	jmp ($030e)	          JMP (IESCPR)
.51cd					  DEF_ESCPR
.51cd	b0 04		bcs $51d3	          BCS LiLi_85
.51cf	a0 00		ldy #$00	          LDY #0
.51d1	f0 af		beq $5182	          BEQ LiLi_55         ; branch always
.51d3	4c 32 51	jmp $5132	LiLi_85   JMP LiLi_15
.51d6					  BASIC_NEW
.51d6	f0 01		beq $51d9	          BEQ NEW_10
.51d8	60		rts		          RTS
.51d9					  NEW_10
.51d9	a9 00		lda #$00	          LDA #0
.51db	a8		tay		          TAY
.51dc	91 2d		sta ($2d),y	          STA (TXTTAB),Y      ; insert zero link
.51de	c8		iny		          INY
.51df	91 2d		sta ($2d),y	          STA (TXTTAB),Y
.51e1	8d 6f 11	sta $116f	          STA TRCFLG
.51e4	a5 2d		lda $2d		          LDA TXTTAB
.51e6	18		clc		          CLC
.51e7	69 02		adc #$02	          ADC #2
.51e9	8d 10 12	sta $1210	          STA TEXT_TOP        ; (TEXT_TOP) = (TXTTAB) + 2
.51ec	a5 2e		lda $2e		          LDA TXTTAB+1
.51ee	69 00		adc #$00	          ADC #0
.51f0	8d 11 12	sta $1211	          STA TEXT_TOP+1
.51f3					  Reset_BASIC_Execution
.51f3	20 54 52	jsr $5254	          JSR Reset_TXTPTR    ; (TXTPTR) = (TXTTAB) - 1
.51f6	a9 00		lda #$00	          LDA #0
.51f8					  BASIC_CLR
.51f8	d0 55		bne $524f	          BNE IBS_Ret
.51fa					  Clear_BASIC
.51fa	20 7b 92	jsr $927b	          JSR B_CLALL
.51fd	a0 00		ldy #$00	          LDY #0
.51ff	84 7a		sty $7a		          STY DS_LEN
.5201	88		dey		          DEY
.5202	8c 0c 12	sty $120c	          STY TRAPNO+1
.5205	8c 09 12	sty $1209	          STY ERRLIN
.5208	8c 0a 12	sty $120a	          STY ERRLIN+1
.520b	8c 08 12	sty $1208	          STY ERRNUM
.520e	a5 39		lda $39		          LDA MEMSIZ
.5210	a4 3a		ldy $3a		          LDY MEMSIZ+1
.5212	85 35		sta $35		          STA FRETOP
.5214	84 36		sty $36		          STY FRETOP+1
.5216	a9 ff		lda #$ff	          LDA #<BASIC_STACK+$1ff
.5218	a0 09		ldy #$09	          LDY #>BASIC_STACK+$1ff
.521a	85 7d		sta $7d		          STA TOS
.521c	84 7e		sty $7e		          STY TOS+1
.521e	a5 2f		lda $2f		          LDA VARTAB
.5220	a4 30		ldy $30		          LDY VARTAB+1
.5222	85 31		sta $31		          STA ARYTAB
.5224	84 32		sty $32		          STY ARYTAB+1
.5226	85 33		sta $33		          STA STREND
.5228	84 34		sty $34		          STY STREND+1
.522a	a2 03		ldx #$03	          LDX #3
.522c	bd 50 52	lda $5250,x	ClrB_10   LDA PUCHARS,X
.522f	9d 04 12	sta $1204,x	          STA PU_FILL,X
.5232	ca		dex		          DEX
.5233	10 f7		bpl $522c	          BPL ClrB_10
.5235	20 e1 5a	jsr $5ae1	ClrB_20   JSR Reset_DATPTR
.5238					  Init_BASIC_Stack
.5238	a2 1b		ldx #$1b	          LDX #$1b
.523a	86 18		stx $18		          STX TEMPPT
.523c	68		pla		          PLA
.523d	a8		tay		          TAY
.523e	68		pla		          PLA
.523f	a2 fa		ldx #$fa	          LDX #$fa            ; reset stackpointer
.5241	9a		txs		          TXS
.5242	48		pha		          PHA
.5243	98		tya		          TYA
.5244	48		pha		          PHA
.5245	a9 00		lda #$00	          LDA #0
.5247	8d 03 12	sta $1203	          STA OLDTXT+1
.524a	85 12		sta $12		          STA SUBFLG
.524c	8d df 03	sta $03df	          STA BITS
.524f	60		rts		IBS_Ret   RTS
.5250					  PUCHARS
>5250	20 2c 2e 24			          .TEXT " ,.$"        ; PU_FILL, PU_COMMA, PU_DOT, PU_MONEY
.5254					  Reset_TXTPTR
.5254	18		clc		          CLC
.5255	a5 2d		lda $2d		          LDA TXTTAB
.5257	69 ff		adc #$ff	          ADC #$ff
.5259	85 3d		sta $3d		          STA TXTPTR
.525b	a5 2e		lda $2e		          LDA TXTTAB+1
.525d	69 ff		adc #$ff	          ADC #$ff
.525f	85 3e		sta $3e		          STA TXTPTR+1
.5261	60		rts		          RTS
.5262					  BASIC_RETURN
.5262	68		pla		          PLA
.5263	68		pla		          PLA
.5264	a9 8d		lda #$8d	          LDA #$8d            ; RETURN token
.5266	20 aa 4f	jsr $4faa	          JSR Find_Token_On_Stack
.5269	f0 05		beq $5270	          BEQ RET_10
.526b	a2 0c		ldx #$0c	          LDX #12             ; RETURN WITHOUT GOSUB
.526d	4c 3c 4d	jmp $4d3c	          JMP Print_Error_X
.5270	20 50 50	jsr $5050	RET_10    JSR Update_TOS
.5273	a0 05		ldy #$05	          LDY #5
.5275	20 59 50	jsr $5059	          JSR Free_TOS
.5278	88		dey		          DEY
.5279	b1 3f		lda ($3f),y	          LDA (FNDPNT),Y
.527b	85 3e		sta $3e		          STA TXTPTR+1
.527d	88		dey		          DEY
.527e	b1 3f		lda ($3f),y	          LDA (FNDPNT),Y
.5280	85 3d		sta $3d		          STA TXTPTR
.5282	88		dey		          DEY
.5283	b1 3f		lda ($3f),y	          LDA (FNDPNT),Y
.5285	20 3b a8	jsr $a83b	          JSR To_Direct_Mode
.5288	b1 3f		lda ($3f),y	          LDA (FNDPNT),Y
.528a	85 3b		sta $3b		          STA CURLIN
.528c	4c 8f 52	jmp $528f	          JMP Skip_Statement     ; obsolete
.528f					  Skip_Statement
.528f	20 a2 52	jsr $52a2	          JSR Skip_To_EOS
.5292					  Add_Y_To_Execution_Pointer
.5292	98		tya		          TYA
.5293	18		clc		          CLC
.5294	65 3d		adc $3d		          ADC TXTPTR
.5296	85 3d		sta $3d		          STA TXTPTR
.5298	90 02		bcc $529c	          BCC AYEP_Ret
.529a	e6 3e		inc $3e		          INC TXTPTR+1
.529c	60		rts		AYEP_Ret  RTS
.529d					  BASIC_REM
.529d	20 a5 52	jsr $52a5	          JSR End_Of_Line
.52a0	f0 f0		beq $5292	          BEQ Add_Y_To_Execution_Pointer
.52a2					  Skip_To_EOS
.52a2	a2 3a		ldx #$3a	          LDX #':'
>52a4	2c				          .byte $2c ;BIT
.52a5					  End_Of_Line
.52a5	a2 00		ldx #$00	          LDX #0
.52a7	86 09		stx $09		          STX CHARAC
.52a9	a0 00		ldy #$00	          LDY #0
.52ab	84 0a		sty $0a		          STY ENDCHR
.52ad	a5 0a		lda $0a		EOL_10    LDA ENDCHR
.52af	a6 09		ldx $09		          LDX CHARAC
.52b1	85 09		sta $09		          STA CHARAC
.52b3	86 0a		stx $0a		          STX ENDCHR
.52b5	20 c9 03	jsr $03c9	EOL_20    JSR INDTXT
.52b8	f0 e2		beq $529c	          BEQ AYEP_Ret
.52ba	c5 0a		cmp $0a		          CMP ENDCHR
.52bc	f0 de		beq $529c	          BEQ AYEP_Ret
.52be	c8		iny		          INY
.52bf	c9 22		cmp #$22	          CMP #QUOTE
.52c1	d0 f2		bne $52b5	          BNE EOL_20
.52c3	f0 e8		beq $52ad	          BEQ EOL_10
.52c5					  BASIC_IF
.52c5	20 ef 77	jsr $77ef	          JSR Eval_Expression
.52c8	20 86 03	jsr $0386	          JSR CHRGOT
.52cb	c9 89		cmp #$89	          CMP #$89            ; GOTO token
.52cd	f0 05		beq $52d4	          BEQ IF_10
.52cf	a9 a7		lda #$a7	          LDA #$a7            ; THEN token
.52d1	20 5e 79	jsr $795e	          JSR Need_A
.52d4	a5 63		lda $63		IF_10     LDA FAC1_EX         ; IF clause != 0 (true) or 0 (false)
.52d6	d0 26		bne $52fe	          BNE IF_30
.52d8	20 86 03	jsr $0386	          JSR CHRGOT
.52db	c9 fe		cmp #$fe	          CMP #$fe            ; token group $fe..
.52dd	d0 0b		bne $52ea	          BNE IF_20
.52df	c8		iny		          INY
.52e0	20 c9 03	jsr $03c9	          JSR INDTXT
.52e3	c9 18		cmp #$18	          CMP #$18            ; BEGIN token
.52e5	d0 03		bne $52ea	          BNE IF_20
.52e7	20 20 53	jsr $5320	          JSR Skip_To_BEND
.52ea	20 8f 52	jsr $528f	IF_20     JSR Skip_Statement
.52ed	a0 00		ldy #$00	          LDY #0
.52ef	20 c9 03	jsr $03c9	          JSR INDTXT
.52f2	f0 a9		beq $529d	          BEQ BASIC_REM       ; skip rest of line
.52f4	20 80 03	jsr $0380	          JSR CHRGET
.52f7	c9 d5		cmp #$d5	          CMP #$d5            ; ELSE token
.52f9	d0 ef		bne $52ea	          BNE IF_20
.52fb	20 80 03	jsr $0380	          JSR CHRGET
.52fe	20 86 03	jsr $0386	IF_30     JSR CHRGOT
.5301	f0 17		beq $531a	          BEQ IF_50
.5303	b0 03		bcs $5308	          BCS IF_40
.5305	4c db 59	jmp $59db	          JMP BASIC_GOTO
.5308	c9 fe		cmp #$fe	IF_40     CMP #$fe            ; token group $fe..
.530a	d0 0e		bne $531a	          BNE IF_50
.530c	c8		iny		          INY
.530d	20 c9 03	jsr $03c9	          JSR INDTXT
.5310	c9 18		cmp #$18	          CMP #$18            ; BEGIN token
.5312	d0 06		bne $531a	          BNE IF_50
.5314	20 80 03	jsr $0380	          JSR CHRGET
.5317	20 80 03	jsr $0380	          JSR CHRGET
.531a	20 86 03	jsr $0386	IF_50     JSR CHRGOT
.531d	4c 3f 4b	jmp $4b3f	          JMP Execute
.5320					  Skip_To_BEND
.5320	20 80 03	jsr $0380	          JSR CHRGET
.5323	d0 27		bne $534c	          BNE BEND_30
.5325	c9 3a		cmp #$3a	BEND_10   CMP #':'
.5327	f0 f7		beq $5320	          BEQ Skip_To_BEND
.5329	24 7f		bit $7f		BEND_20   BIT RUNMOD
.532b	10 4a		bpl $5377	          BPL BEND_Err
.532d	a0 02		ldy #$02	          LDY #2
.532f	20 c9 03	jsr $03c9	          JSR INDTXT          ; link high
.5332	f0 43		beq $5377	          BEQ BEND_Err
.5334	c8		iny		          INY                 ; Y = 3
.5335	20 c9 03	jsr $03c9	          JSR INDTXT
.5338	85 3b		sta $3b		          STA CURLIN
.533a	c8		iny		          INY                 ; Y = 4
.533b	20 c9 03	jsr $03c9	          JSR INDTXT
.533e	85 3c		sta $3c		          STA CURLIN+1
.5340	98		tya		          TYA
.5341	18		clc		          CLC
.5342	65 3d		adc $3d		          ADC TXTPTR          ; next line
.5344	85 3d		sta $3d		          STA TXTPTR
.5346	90 d8		bcc $5320	          BCC Skip_To_BEND
.5348	e6 3e		inc $3e		          INC TXTPTR+1
.534a	d0 d4		bne $5320	          BNE Skip_To_BEND
.534c	c9 22		cmp #$22	BEND_30   CMP #QUOTE
.534e	d0 07		bne $5357	          BNE BEND_40
.5350	20 7c 53	jsr $537c	          JSR Skip_To_End_Of_String
.5353	f0 d0		beq $5325	          BEQ BEND_10
.5355	d0 c9		bne $5320	          BNE Skip_To_BEND
.5357	c9 8f		cmp #$8f	BEND_40   CMP #$8f            ; REM token
.5359	d0 06		bne $5361	          BNE BEND_50
.535b	20 9d 52	jsr $529d	          JSR BASIC_REM
.535e	4c 29 53	jmp $5329	          JMP BEND_20
.5361	c9 fe		cmp #$fe	BEND_50   CMP #$fe            ; $fe.. token ?
.5363	d0 bb		bne $5320	          BNE Skip_To_BEND
.5365	20 80 03	jsr $0380	          JSR CHRGET
.5368	c9 19		cmp #$19	          CMP #$19            ; $fe19 = BEND token
.536a	f0 0a		beq $5376	          BEQ BEND_60
.536c	c9 18		cmp #$18	          CMP #$18            ; $fe18 = BEGIN token
.536e	d0 b0		bne $5320	          BNE Skip_To_BEND
.5370	20 20 53	jsr $5320	          JSR Skip_To_BEND    ; nested BEGIN .. BEND
.5373	4c 20 53	jmp $5320	          JMP Skip_To_BEND
.5376	60		rts		BEND_60   RTS
.5377	a2 25		ldx #$25	BEND_Err  LDX #$25            ; BEND NOT FOUND
.5379	4c 3c 4d	jmp $4d3c	          JMP Print_Error_X
.537c					  Skip_To_End_Of_String
.537c	a0 00		ldy #$00	          LDY #0
.537e	e6 3d		inc $3d		SEOS_10   INC TXTPTR
.5380	d0 02		bne $5384	          BNE SEOS_20
.5382	e6 3e		inc $3e		          INC TXTPTR+1
.5384	20 c9 03	jsr $03c9	SEOS_20   JSR INDTXT
.5387	f0 07		beq $5390	          BEQ SEOS_Ret
.5389	c9 22		cmp #$22	          CMP #QUOTE
.538b	d0 f1		bne $537e	          BNE SEOS_10
.538d	4c 80 03	jmp $0380	          JMP CHRGET
.5390	60		rts		SEOS_Ret  RTS
.5391					  BASIC_ELSE
.5391	c9 fe		cmp #$fe	          CMP #$fe            ; $fe.. token ?
.5393	d0 0b		bne $53a0	          BNE ELSE_10
.5395	c8		iny		          INY
.5396	20 c9 03	jsr $03c9	          JSR INDTXT
.5399	c9 18		cmp #$18	          CMP #$18            ; BEGIN token
.539b	d0 03		bne $53a0	          BNE ELSE_10
.539d	20 20 53	jsr $5320	          JSR Skip_To_BEND
.53a0	4c 9d 52	jmp $529d	ELSE_10   JMP BASIC_REM
.53a3					  BASIC_ON
.53a3	20 f4 87	jsr $87f4	          JSR Get_Byte_Var
.53a6	48		pha		          PHA
.53a7	c9 8d		cmp #$8d	          CMP #$8d            ; GOSUB
.53a9	f0 07		beq $53b2	          BEQ ON_10
.53ab	c9 89		cmp #$89	          CMP #$89            ; GOTO
.53ad	f0 03		beq $53b2	          BEQ ON_10
.53af	4c 6c 79	jmp $796c	          JMP SYNTAX_ERROR
.53b2	c6 67		dec $67		ON_10     DEC FAC1_M4         ; ON value
.53b4	d0 04		bne $53ba	          BNE ON_20
.53b6	68		pla		          PLA
.53b7	4c 59 4b	jmp $4b59	          JMP Exec_05
.53ba	20 80 03	jsr $0380	ON_20     JSR CHRGET
.53bd	20 a0 50	jsr $50a0	          JSR Scan_Linenumber
.53c0	c9 2c		cmp #$2c	          CMP #','
.53c2	f0 ee		beq $53b2	          BEQ ON_10           ; next target
.53c4	68		pla		          PLA
.53c5	60		rts		          RTS
.53c6					  BASIC_LET
.53c6	20 af 7a	jsr $7aaf	          JSR Parse_Name
.53c9	85 4b		sta $4b		          STA FORPNT
.53cb	84 4c		sty $4c		          STY FORPNT+1
.53cd	a9 b2		lda #$b2	          LDA #$b2            ; '=' token
.53cf	20 5e 79	jsr $795e	          JSR Need_A
.53d2	a5 10		lda $10		          LDA INTFLG          ; save attributes
.53d4	48		pha		          PHA                 ; of variable
.53d5	a5 0f		lda $0f		          LDA VALTYP
.53d7	48		pha		          PHA
.53d8	20 ef 77	jsr $77ef	          JSR Eval_Expression ; FAC1 = value or pointer
.53db	68		pla		          PLA                 ; VALTYP
.53dc	2a		rol a		          ROL A               ; C=1 : string   C=0 : numeric
.53dd	20 de 77	jsr $77de	          JSR Check_Var_Type
.53e0	d0 22		bne $5404	          BNE LET_20          ; branch for string
.53e2	68		pla		          PLA                 ; INTFLG
.53e3					  Assign_Numeric_Variable
.53e3	10 15		bpl $53fa	          BPL LET_10          ; branch for real
.53e5	20 47 8c	jsr $8c47	          JSR Round_FAC1
.53e8	20 b4 84	jsr $84b4	          JSR Real_To_Integer
.53eb	a0 00		ldy #$00	          LDY #0
.53ed	a5 66		lda $66		          LDA FAC1_M3
.53ef	8d 04 ff	sta $ff04	          STA MMU_LCRD        ; write to RAM 1
.53f2	91 4b		sta ($4b),y	          STA (FORPNT),Y      ; integer high byte
.53f4	c8		iny		          INY
.53f5	a5 67		lda $67		          LDA FAC1_M4
.53f7	91 4b		sta ($4b),y	          STA (FORPNT),Y      ; integer low  byte
.53f9	60		rts		          RTS
.53fa	a6 4b		ldx $4b		LET_10    LDX FORPNT
.53fc	a4 4c		ldy $4c		          LDY FORPNT+1
.53fe	8d 04 ff	sta $ff04	          STA MMU_LCRD        ; select RAM1
.5401	4c 00 8c	jmp $8c00	          JMP FAC1_To_XY      ; (FORPNT) := FAC1
.5404	68		pla		LET_20    PLA                 ; INTFLG
.5405					  Assign_String_Variable
.5405	a4 4c		ldy $4c		          LDY FORPNT+1
.5407	c0 03		cpy #$03	          CPY #3              ; void string descriptor for TI$
.5409	d0 72		bne $547d	          BNE Assign_Normal_String
.540b	20 81 87	jsr $8781	          JSR Free_String_FAC1
.540e	c9 06		cmp #$06	          CMP #6              ; setting TI$ requires 6 digits
.5410	d0 3e		bne $5450	          BNE CLOCK_ERR
.5412	a0 00		ldy #$00	          LDY #0              ; FAC1 = 0.0
.5414	84 63		sty $63		          STY FAC1_EX
.5416	84 68		sty $68		          STY FAC1_SI
.5418	84 72		sty $72		CLOCK_10  STY STRNG2
.541a	20 48 54	jsr $5448	          JSR Add_TI_String_Digit_To_FAC1
.541d	20 17 8b	jsr $8b17	          JSR Multiply_FAC1_BY_10
.5420	e6 72		inc $72		          INC STRNG2
.5422	a4 72		ldy $72		          LDY STRNG2
.5424	20 48 54	jsr $5448	          JSR Add_TI_String_Digit_To_FAC1
.5427	20 38 8c	jsr $8c38	          JSR FAC1_Round_And_Copy_To_FAC2
.542a	aa		tax		          TAX
.542b	f0 05		beq $5432	          BEQ CLOCK_20
.542d	e8		inx		          INX
.542e	8a		txa		          TXA                 ; FAC2 *= 2
.542f	20 22 8b	jsr $8b22	          JSR Add_And_Double  ; FAC1  = (FAC1 + FAC2) * 2
.5432	a4 72		ldy $72		CLOCK_20  LDY STRNG2
.5434	c8		iny		          INY
.5435	c0 06		cpy #$06	          CPY #6
.5437	d0 df		bne $5418	          BNE CLOCK_10
.5439	20 17 8b	jsr $8b17	          JSR Multiply_FAC1_BY_10
.543c	20 c7 8c	jsr $8cc7	          JSR FAC1_INT
.543f	a6 66		ldx $66		          LDX FAC1_M3
.5441	a4 65		ldy $65		          LDY FAC1_M2
.5443	a5 67		lda $67		          LDA FAC1_M4
.5445	4c db ff	jmp $ffdb	          JMP K_SETTIM
.5448					  Add_TI_String_Digit_To_FAC1
.5448	20 b7 03	jsr $03b7	          JSR Get_INDEXA_1
.544b	20 90 03	jsr $0390	          JSR ISNUM
.544e	90 03		bcc $5453	          BCC ATSD_20
.5450	4c 28 7d	jmp $7d28	CLOCK_ERR JMP Error_Illegal_Quantity
.5453	e9 2f		sbc #$2f	ATSD_20   SBC #$2f            ; subtract "0" (C=0)
.5455	4c b0 8d	jmp $8db0	          JMP Add_A_To_FAC1
.5458	68		pla		ANS_10    PLA
.5459	c8		iny		          INY
.545a	c5 36		cmp $36		ANS_20    CMP FRETOP+1        ; address < FRETOP ?
.545c	90 18		bcc $5476	          BCC ANS_40
.545e	d0 08		bne $5468	          BNE ANS_30
.5460	88		dey		          DEY
.5461	20 e7 42	jsr $42e7	          JSR Get_FAC1_M3_1
.5464	c5 35		cmp $35		          CMP FRETOP
.5466	90 0e		bcc $5476	          BCC ANS_40
.5468	a4 67		ldy $67		ANS_30    LDY FAC1_M4
.546a	c4 30		cpy $30		          CPY VARTAB+1
.546c	90 08		bcc $5476	          BCC ANS_40
.546e	d0 24		bne $5494	          BNE Assing_String_From_Variable
.5470	a5 66		lda $66		          LDA FAC1_M3
.5472	c5 2f		cmp $2f		          CMP VARTAB
.5474	b0 1e		bcs $5494	          BCS Assing_String_From_Variable
.5476	a5 66		lda $66		ANS_40    LDA FAC1_M3         ; static string
.5478	a4 67		ldy $67		          LDY FAC1_M4
.547a	4c b2 54	jmp $54b2	          JMP ANS_50
.547d					  Assign_Normal_String
.547d	a0 02		ldy #$02	          LDY #2
.547f	20 e7 42	jsr $42e7	          JSR Get_FAC1_M3_1
.5482	c5 7c		cmp $7c		          CMP DS_ADR+1
.5484	d0 d4		bne $545a	          BNE ANS_20
.5486	48		pha		          PHA
.5487	88		dey		          DEY
.5488	20 e7 42	jsr $42e7	          JSR Get_FAC1_M3_1
.548b	c5 7b		cmp $7b		          CMP DS_ADR
.548d	d0 c9		bne $5458	          BNE ANS_10
.548f	a5 7a		lda $7a		          LDA DS_LEN
.5491	f0 c5		beq $5458	          BEQ ANS_10          ; -> DS$ undefined
.5493	68		pla		          PLA
.5494					  Assing_String_From_Variable
.5494	a0 00		ldy #$00	          LDY #0
.5496	20 e7 42	jsr $42e7	          JSR Get_FAC1_M3_1
.5499	20 88 86	jsr $8688	          JSR Allocate_String_FAC1
.549c	a5 52		lda $52		          LDA DSCPNT
.549e	a4 53		ldy $53		          LDY DSCPNT+1
.54a0	85 70		sta $70		          STA STRPTR
.54a2	84 71		sty $71		          STY STRPTR+1
.54a4	20 4e 87	jsr $874e	          JSR Store_String_STRPTR
.54a7	a5 70		lda $70		          LDA STRPTR
.54a9	a4 71		ldy $71		          LDY STRPTR+1
.54ab	20 e0 87	jsr $87e0	          JSR Pop_Descriptor_Stack
.54ae	a9 63		lda #$63	          LDA #<FAC1_EX
.54b0	a0 00		ldy #$00	          LDY #>FAC1_EX
.54b2	85 52		sta $52		ANS_50    STA DSCPNT
.54b4	84 53		sty $53		          STY DSCPNT+1
.54b6	85 24		sta $24		          STA INDEXA
.54b8	84 25		sty $25		          STY INDEXA+1
.54ba	20 e0 87	jsr $87e0	          JSR Pop_Descriptor_Stack
.54bd	20 f6 54	jsr $54f6	          JSR Back_Reference_Position
.54c0	90 0e		bcc $54d0	          BCC ANS_60
.54c2	a0 00		ldy #$00	          LDY #0
.54c4	a5 4b		lda $4b		          LDA FORPNT
.54c6	8d 04 ff	sta $ff04	          STA MMU_LCRD
.54c9	91 24		sta ($24),y	          STA (INDEXA),Y
.54cb	c8		iny		          INY
.54cc	a5 4c		lda $4c		          LDA FORPNT+1
.54ce	91 24		sta ($24),y	          STA (INDEXA),Y
.54d0	a5 4b		lda $4b		ANS_60    LDA FORPNT
.54d2	85 24		sta $24		          STA INDEXA
.54d4	a5 4c		lda $4c		          LDA FORPNT+1
.54d6	85 25		sta $25		          STA INDEXA+1
.54d8	20 f6 54	jsr $54f6	          JSR Back_Reference_Position
.54db	90 0c		bcc $54e9	          BCC ANS_70
.54dd	88		dey		          DEY
.54de	a9 ff		lda #$ff	          LDA #$ff
.54e0	8d 04 ff	sta $ff04	          STA MMU_LCRD
.54e3	91 24		sta ($24),y	          STA (INDEXA),Y
.54e5	88		dey		          DEY
.54e6	8a		txa		          TXA
.54e7	91 24		sta ($24),y	          STA (INDEXA),Y
.54e9	a0 02		ldy #$02	ANS_70    LDY #2
.54eb	a9 52		lda #$52	ANS_80    LDA #$52 ; 'R'
.54ed	20 ab 03	jsr $03ab	          JSR Fetch_1
.54f0	91 4b		sta ($4b),y	          STA (FORPNT),Y
.54f2	88		dey		          DEY
.54f3	10 f6		bpl $54eb	          BPL ANS_80
.54f5	60		rts		          RTS
.54f6					  Back_Reference_Position
.54f6	a0 00		ldy #$00	          LDY #0
.54f8	20 b7 03	jsr $03b7	          JSR Get_INDEXA_1        ; A = length
.54fb	48		pha		          PHA                 ; push length
.54fc	f0 39		beq $5537	          BEQ BRP_50
.54fe	c8		iny		          INY
.54ff	20 b7 03	jsr $03b7	          JSR Get_INDEXA_1
.5502	aa		tax		          TAX                 ; X = pointer low
.5503	c8		iny		          INY
.5504	20 b7 03	jsr $03b7	          JSR Get_INDEXA_1        ; A = pointer high
.5507	c5 3a		cmp $3a		          CMP MEMSIZ+1
.5509	90 06		bcc $5511	          BCC BRP_10
.550b	d0 2a		bne $5537	          BNE BRP_50
.550d	e4 39		cpx $39		          CPX MEMSIZ       ; return for addr >= MEMTOP
.550f	b0 26		bcs $5537	          BCS BRP_50
.5511	20 b7 03	jsr $03b7	BRP_10    JSR Get_INDEXA_1
.5514	c5 36		cmp $36		          CMP FRETOP+1
.5516	90 1f		bcc $5537	          BCC BRP_50
.5518	d0 04		bne $551e	          BNE BRP_20
.551a	e4 35		cpx $35		          CPX FRETOP          ; return for addr < FRETOP
.551c	90 19		bcc $5537	          BCC BRP_50
.551e	c5 7c		cmp $7c		BRP_20    CMP DS_ADR+1
.5520	d0 04		bne $5526	          BNE BRP_30
.5522	e4 7b		cpx $7b		          CPX DS_ADR
.5524	f0 11		beq $5537	          BEQ BRP_50          ; return for addr == DS$
.5526	86 24		stx $24		BRP_30    STX INDEXA
.5528	85 25		sta $25		          STA INDEXA+1        ; (INDEXA) = address of string
.552a	68		pla		          PLA
.552b	aa		tax		          TAX
.552c	18		clc		          CLC
.552d	65 24		adc $24		          ADC INDEXA
.552f	85 24		sta $24		          STA INDEXA
.5531	90 02		bcc $5535	          BCC BRP_40
.5533	e6 25		inc $25		          INC INDEXA+1        ; (SP24IX) = address + length
.5535	38		sec		BRP_40    SEC
.5536	60		rts		          RTS
.5537	68		pla		BRP_50    PLA
.5538	18		clc		          CLC
.5539	60		rts		          RTS
.553a					  BASIC_PRINT_D
.553a	20 40 55	jsr $5540	          JSR BASIC_CMD
.553d	4c 58 56	jmp $5658	          JMP Set_Default_Channels
.5540					  BASIC_CMD
.5540	20 f4 87	jsr $87f4	          JSR Get_Byte_Var
.5543	f0 05		beq $554a	          BEQ CMD_10
.5545	a9 2c		lda #$2c	          LDA #','
.5547	20 5e 79	jsr $795e	          JSR Need_A
.554a	08		php		CMD_10    PHP
.554b	86 15		stx $15		          STX CHANNL
.554d	20 eb 90	jsr $90eb	          JSR B_CKOUT
.5550	28		plp		          PLP
.5551	4c 5a 55	jmp $555a	          JMP BASIC_PRINT
.5554	20 e5 55	jsr $55e5	PRINT_10  JSR Print_String_From_Descriptor
.5557	20 86 03	jsr $0386	PRINT_20  JSR CHRGOT
.555a					  BASIC_PRINT
.555a	f0 3c		beq $5598	          BEQ Print_CR
.555c	c9 fb		cmp #$fb	          CMP #$fb            ; USING
.555e	d0 03		bne $5563	          BNE PRINT_30
.5560	4c 20 95	jmp $9520	          JMP PRINT_USING
.5563	f0 43		beq $55a8	PRINT_30  BEQ Print_Ret
.5565	c9 a3		cmp #$a3	          CMP #$a3            ; TAB(
.5567	f0 50		beq $55b9	          BEQ Tab_Spc
.5569	c9 a6		cmp #$a6	          CMP #$a6            ; SPC(
.556b	18		clc		          CLC
.556c	f0 4b		beq $55b9	          BEQ Tab_Spc
.556e	c9 2c		cmp #$2c	          CMP #','
.5570	f0 37		beq $55a9	          BEQ Comma_Tab
.5572	c9 3b		cmp #$3b	          CMP #';'
.5574	f0 5e		beq $55d4	          BEQ TaSp_40
.5576	20 ef 77	jsr $77ef	          JSR Eval_Expression
.5579	24 0f		bit $0f		          BIT VALTYP
.557b	30 d7		bmi $5554	          BMI PRINT_10
.557d	20 42 8e	jsr $8e42	          JSR Format_FAC1
.5580	20 9a 86	jsr $869a	          JSR Create_String_Descriptor
.5583	20 e5 55	jsr $55e5	          JSR Print_String_From_Descriptor
.5586	20 00 56	jsr $5600	          JSR Space_Or_Right
.5589	d0 cc		bne $5557	          BNE PRINT_20          ; always
.558b					  Terminate_BUF
.558b	a9 00		lda #$00	          LDA #0
.558d	9d 00 02	sta $0200,x	          STA BUF,X
.5590	a2 ff		ldx #$ff	          LDX #<BUF-1
.5592	a0 01		ldy #$01	          LDY #>BUF-1
.5594	a5 15		lda $15		          LDA CHANNL
.5596	d0 10		bne $55a8	          BNE Print_Ret
.5598					  Print_CR
.5598	a9 0d		lda #$0d	          LDA #CR
.559a	20 0c 56	jsr $560c	          JSR Print_Char
.559d	24 15		bit $15		          BIT CHANNL
.559f	10 05		bpl $55a6	          BPL Accu_EOR
.55a1	a9 0a		lda #$0a	          LDA #LF
.55a3	20 0c 56	jsr $560c	          JSR Print_Char
.55a6					  Accu_EOR
.55a6	49 ff		eor #$ff	          EOR #$ff
.55a8	60		rts		Print_Ret RTS
.55a9					  Comma_Tab
.55a9	38		sec		          SEC
.55aa	20 8d 92	jsr $928d	          JSR B_PLOT
.55ad	98		tya		          TYA
.55ae	38		sec		          SEC
.55af	e9 0a		sbc #$0a	CoTa_10   SBC #10
.55b1	b0 fc		bcs $55af	          BCS CoTa_10
.55b3	49 ff		eor #$ff	          EOR #$ff
.55b5	69 01		adc #$01	          ADC #1
.55b7	d0 16		bne $55cf	          BNE TaSp_10
.55b9					  Tab_Spc
.55b9	08		php		          PHP
.55ba	38		sec		          SEC
.55bb	20 8d 92	jsr $928d	          JSR B_PLOT
.55be	84 0b		sty $0b		          STY TRMPOS
.55c0	20 f1 87	jsr $87f1	          JSR Get_Next_Byte_Var
.55c3	c9 29		cmp #$29	          CMP #')'
.55c5	d0 13		bne $55da	          BNE TaSp_50
.55c7	28		plp		          PLP
.55c8	90 06		bcc $55d0	          BCC TaSp_20
.55ca	8a		txa		          TXA
.55cb	e5 0b		sbc $0b		          SBC TRMPOS
.55cd	90 05		bcc $55d4	          BCC TaSp_40
.55cf	aa		tax		TaSp_10   TAX
.55d0	e8		inx		TaSp_20   INX
.55d1	ca		dex		TaSp_30   DEX
.55d2	d0 09		bne $55dd	          BNE TaSp_60
.55d4	20 80 03	jsr $0380	TaSp_40   JSR CHRGET
.55d7	4c 63 55	jmp $5563	          JMP PRINT_30
.55da	4c 6c 79	jmp $796c	TaSp_50   JMP SYNTAX_ERROR
.55dd	20 00 56	jsr $5600	TaSp_60   JSR Space_Or_Right
.55e0	d0 ef		bne $55d1	          BNE TaSp_30
.55e2					  Print_String
.55e2	20 9a 86	jsr $869a	          JSR Create_String_Descriptor
.55e5					  Print_String_From_Descriptor
.55e5	20 81 87	jsr $8781	          JSR Free_String_FAC1
.55e8	aa		tax		          TAX
.55e9	a0 00		ldy #$00	          LDY #0
.55eb	e8		inx		          INX
.55ec	ca		dex		PSFD_10   DEX
.55ed	f0 b9		beq $55a8	          BEQ Print_Ret
.55ef	20 b7 03	jsr $03b7	          JSR Get_INDEXA_1
.55f2	20 0c 56	jsr $560c	          JSR Print_Char
.55f5	c8		iny		          INY
.55f6	c9 0d		cmp #$0d	          CMP #CR
.55f8	d0 f2		bne $55ec	          BNE PSFD_10
.55fa	20 a6 55	jsr $55a6	          JSR Accu_EOR
.55fd	4c ec 55	jmp $55ec	          JMP PSFD_10
.5600					  Space_Or_Right
.5600	a5 15		lda $15		          LDA CHANNL
.5602	f0 03		beq $5607	          BEQ SOR_10
.5604					  Print_Blank
.5604	a9 20		lda #$20	          LDA #' '
>5606	2c				          .byte $2c ;BIT
.5607	a9 1d		lda #$1d	SOR_10    LDA #RIGHT
>5609	2c				          .byte $2c ;BIT
.560a					  Print_Question_Mark
.560a	a9 3f		lda #$3f	          LDA #'?'
.560c					  Print_Char
.560c	20 df 90	jsr $90df	          JSR CHROUT
.560f	29 ff		and #$ff	          AND #$ff
.5611	60		rts		          RTS
.5612					  BASIC_GET
.5612	20 d9 84	jsr $84d9	          JSR Assert_Non_Direct
.5615	85 77		sta $77		          STA TEMP_A
.5617	c9 23		cmp #$23	          CMP #'#'
.5619	f0 0a		beq $5625	          BEQ GET_10
.561b	c9 f9		cmp #$f9	          CMP #$f9            ; KEY
.561d	d0 16		bne $5635	          BNE GET_20
.561f	20 80 03	jsr $0380	          JSR CHRGET
.5622	4c 35 56	jmp $5635	          JMP GET_20
.5625	20 80 03	jsr $0380	GET_10    JSR CHRGET
.5628	20 f4 87	jsr $87f4	          JSR Get_Byte_Var
.562b	a9 2c		lda #$2c	          LDA #','
.562d	20 5e 79	jsr $795e	          JSR Need_A
.5630	86 15		stx $15		          STX CHANNL
.5632	20 fd 90	jsr $90fd	          JSR B_CHKIN
.5635	a2 01		ldx #$01	GET_20    LDX #1
.5637	a0 02		ldy #$02	          LDY #2
.5639	a9 00		lda #$00	          LDA #0
.563b	8d 01 02	sta $0201	          STA BUF+1
.563e	a9 40		lda #$40	          LDA #$40
.5640	20 b2 56	jsr $56b2	          JSR Read_Get
.5643	a6 15		ldx $15		          LDX CHANNL
.5645	d0 13		bne $565a	          BNE SDC_10
.5647	60		rts		          RTS
.5648					  BASIC_INPUT_D
.5648	20 f4 87	jsr $87f4	          JSR Get_Byte_Var
.564b	a9 2c		lda #$2c	          LDA #','
.564d	20 5e 79	jsr $795e	          JSR Need_A
.5650	86 15		stx $15		          STX CHANNL
.5652	20 fd 90	jsr $90fd	          JSR B_CHKIN
.5655	20 71 56	jsr $5671	          JSR Input_String
.5658					  Set_Default_Channels
.5658	a5 15		lda $15		          LDA CHANNL
.565a	20 6f 92	jsr $926f	SDC_10    JSR B_CLRCH
.565d	a2 00		ldx #$00	          LDX #0
.565f	86 15		stx $15		          STX CHANNL
.5661	60		rts		          RTS
.5662					  BASIC_INPUT
.5662	c9 22		cmp #$22	          CMP #QUOTE
.5664	d0 0b		bne $5671	          BNE Input_String
.5666	20 13 79	jsr $7913	          JSR Create_Descriptor_From_TXTPTR
.5669	a9 3b		lda #$3b	          LDA #';'
.566b	20 5e 79	jsr $795e	          JSR Need_A
.566e	20 e5 55	jsr $55e5	          JSR Print_String_From_Descriptor
.5671					  Input_String
.5671	20 d9 84	jsr $84d9	          JSR Assert_Non_Direct
.5674	a9 2c		lda #$2c	          LDA #','
.5676	8d ff 01	sta $01ff	          STA BUF-1
.5679	20 9c 56	jsr $569c	InSt_10   JSR Prompt_And_Input
.567c	a5 15		lda $15		          LDA CHANNL
.567e	f0 0d		beq $568d	          BEQ InSt_20
.5680	20 51 92	jsr $9251	          JSR B_READST
.5683	29 02		and #$02	          AND #%00000010 ; $02
.5685	f0 06		beq $568d	          BEQ InSt_20
.5687	20 58 56	jsr $5658	          JSR Set_Default_Channels
.568a	4c 8f 52	jmp $528f	          JMP Skip_Statement
.568d	ad 00 02	lda $0200	InSt_20   LDA BUF
.5690	d0 1e		bne $56b0	          BNE READ_10
.5692	a5 15		lda $15		          LDA CHANNL
.5694	d0 e3		bne $5679	          BNE InSt_10
.5696	20 a2 52	jsr $52a2	          JSR Skip_To_EOS
.5699	4c 92 52	jmp $5292	          JMP Add_Y_To_Execution_Pointer
.569c					  Prompt_And_Input
.569c	a5 15		lda $15		          LDA CHANNL
.569e	d0 06		bne $56a6	          BNE PAT_10
.56a0	20 0a 56	jsr $560a	          JSR Print_Question_Mark
.56a3	20 04 56	jsr $5604	          JSR Print_Blank
.56a6	4c 93 4f	jmp $4f93	PAT_10    JMP Read_String
.56a9					  BASIC_READ
.56a9	a6 43		ldx $43		          LDX DATPTR
.56ab	a4 44		ldy $44		          LDY DATPTR+1
.56ad	a9 98		lda #$98	          LDA #$98
>56af	2c				          .byte $2c ;BIT
.56b0	a9 00		lda #$00	READ_10   LDA #0
.56b2					  Read_Get
.56b2	85 13		sta $13		          STA INPFLG
.56b4	86 45		stx $45		          STX INPPTR
.56b6	84 46		sty $46		          STY INPPTR+1
.56b8	20 af 7a	jsr $7aaf	READ_12   JSR Parse_Name
.56bb	85 4b		sta $4b		          STA FORPNT
.56bd	84 4c		sty $4c		          STY FORPNT+1
.56bf	a2 01		ldx #$01	          LDX #1
.56c1	b5 3d		lda $3d,x	READ_14   LDA TXTPTR,X
.56c3	95 4d		sta $4d,x	          STA VARTXT,X
.56c5	b5 45		lda $45,x	          LDA INPPTR,X
.56c7	95 3d		sta $3d,x	          STA TXTPTR,X
.56c9	ca		dex		          DEX
.56ca	10 f5		bpl $56c1	          BPL READ_14
.56cc	20 86 03	jsr $0386	          JSR CHRGOT
.56cf	d0 31		bne $5702	          BNE READ_30
.56d1	24 13		bit $13		          BIT INPFLG
.56d3	50 1a		bvc $56ef	          BVC READ_22         ; bit 6 set: GETIN
.56d5	a5 77		lda $77		          LDA TEMP_A
.56d7	c9 f9		cmp #$f9	          CMP #$f9
.56d9	d0 08		bne $56e3	          BNE READ_18
.56db	20 09 91	jsr $9109	READ_16   JSR B_GETIN
.56de	aa		tax		          TAX
.56df	f0 fa		beq $56db	          BEQ READ_16
.56e1	d0 03		bne $56e6	          BNE READ_20         ; always
.56e3	20 09 91	jsr $9109	READ_18   JSR B_GETIN
.56e6	8d 00 02	sta $0200	READ_20   STA BUF
.56e9	a2 ff		ldx #$ff	          LDX #<BUF-1
.56eb	a0 01		ldy #$01	          LDY #>BUF-1
.56ed	d0 0f		bne $56fe	          BNE READ_28         ; always
.56ef	10 03		bpl $56f4	READ_22   BPL READ_24         ; bit 7 set: READ
.56f1	4c ca 57	jmp $57ca	          JMP READ_DATA
.56f4	a5 15		lda $15		READ_24   LDA CHANNL
.56f6	d0 03		bne $56fb	          BNE READ_26
.56f8	20 0a 56	jsr $560a	          JSR Print_Question_Mark
.56fb	20 9c 56	jsr $569c	READ_26   JSR Prompt_And_Input
.56fe	86 3d		stx $3d		READ_28   STX TXTPTR
.5700	84 3e		sty $3e		          STY TXTPTR+1
.5702	20 80 03	jsr $0380	READ_30   JSR CHRGET
.5705	24 0f		bit $0f		          BIT VALTYP
.5707	10 31		bpl $573a	          BPL READ_38
.5709	24 13		bit $13		          BIT INPFLG
.570b	50 09		bvc $5716	          BVC READ_32
.570d	e8		inx		          INX
.570e	86 3d		stx $3d		          STX TXTPTR
.5710	a9 00		lda #$00	          LDA #0
.5712	85 09		sta $09		          STA CHARAC
.5714	f0 0c		beq $5722	          BEQ READ_34
.5716	85 09		sta $09		READ_32   STA CHARAC
.5718	c9 22		cmp #$22	          CMP #QUOTE
.571a	f0 07		beq $5723	          BEQ READ_35
.571c	a9 3a		lda #$3a	          LDA #':'
.571e	85 09		sta $09		          STA CHARAC
.5720	a9 2c		lda #$2c	          LDA #','
.5722	18		clc		READ_34   CLC
.5723	85 0a		sta $0a		READ_35   STA ENDCHR
.5725	a5 3d		lda $3d		          LDA TXTPTR
.5727	a4 3e		ldy $3e		          LDY TXTPTR+1
.5729	69 00		adc #$00	          ADC #0
.572b	90 01		bcc $572e	          BCC READ_36
.572d	c8		iny		          INY
.572e	20 a0 86	jsr $86a0	READ_36   JSR Create_String_Descriptor_AY
.5731	20 1f 79	jsr $791f	          JSR Restore_Execution_Pointer
.5734	20 05 54	jsr $5405	          JSR Assign_String_Variable
.5737	4c 44 57	jmp $5744	          JMP READ_40
.573a	a2 00		ldx #$00	READ_38   LDX #0
.573c	20 22 8d	jsr $8d22	          JSR Read_Real_To_FAC1
.573f	a5 10		lda $10		          LDA INTFLG
.5741	20 e3 53	jsr $53e3	          JSR Assign_Numeric_Variable
.5744	20 86 03	jsr $0386	READ_40   JSR CHRGOT
.5747	f0 3b		beq $5784	          BEQ READ_52
.5749	c9 2c		cmp #$2c	          CMP #','
.574b	f0 37		beq $5784	          BEQ READ_52
.574d	a5 13		lda $13		          LDA INPFLG
.574f	f0 0a		beq $575b	          BEQ READ_44
.5751	30 04		bmi $5757	          BMI READ_42
.5753	a6 15		ldx $15		          LDX CHANNL
.5755	d0 08		bne $575f	          BNE READ_46
.5757	a2 16		ldx #$16	READ_42   LDX #$16            ; TYPE MISMATCH
.5759	d0 06		bne $5761	          BNE READ_48
.575b	a5 15		lda $15		READ_44   LDA CHANNL
.575d	f0 05		beq $5764	          BEQ READ_50
.575f	a2 18		ldx #$18	READ_46   LDX #$18            ; FILE DATA
.5761	4c 3c 4d	jmp $4d3c	READ_48   JMP Print_Error_X
.5764	20 81 92	jsr $9281	READ_50   JSR B_PRIMM
>5767	3f 52 45 44 4f 20 46 52		          .TEXT "?REDO FROM START\r",0
>576f	4f 4d 20 53 54 41 52 54 0d 00
.5779	ad 02 12	lda $1202	          LDA OLDTXT
.577c	ac 03 12	ldy $1203	          LDY OLDTXT+1
.577f	85 3d		sta $3d		          STA TXTPTR
.5781	84 3e		sty $3e		          STY TXTPTR+1
.5783	60		rts		          RTS
.5784	a2 01		ldx #$01	READ_52   LDX #1
.5786	b5 3d		lda $3d,x	READ_54   LDA TXTPTR,X
.5788	95 45		sta $45,x	          STA INPPTR,X
.578a	b5 4d		lda $4d,x	          LDA VARTXT,X
.578c	95 3d		sta $3d,x	          STA TXTPTR,X
.578e	ca		dex		          DEX
.578f	10 f5		bpl $5786	          BPL READ_54
.5791	20 86 03	jsr $0386	          JSR CHRGOT
.5794	f0 06		beq $579c	          BEQ READ_56
.5796	20 5c 79	jsr $795c	          JSR Need_Comma
.5799	4c b8 56	jmp $56b8	          JMP READ_12
.579c	a5 45		lda $45		READ_56   LDA INPPTR
.579e	a4 46		ldy $46		          LDY INPPTR+1
.57a0	a6 13		ldx $13		          LDX INPFLG
.57a2	10 05		bpl $57a9	          BPL READ_58
.57a4	85 43		sta $43		          STA DATPTR
.57a6	84 44		sty $44		          STY DATPTR+1
.57a8	60		rts		          RTS
.57a9	a0 00		ldy #$00	READ_58   LDY #0
.57ab	a9 45		lda #$45	          LDA #INPPTR
.57ad	20 9f 03	jsr $039f	          JSR Fetch_0
.57b0	f0 17		beq $57c9	          BEQ READ_Ret
.57b2	a5 15		lda $15		          LDA CHANNL
.57b4	d0 13		bne $57c9	          BNE READ_Ret
.57b6	20 81 92	jsr $9281	          JSR B_PRIMM
>57b9	3f 45 58 54 52 41 20 49		          .TEXT "?EXTRA IGNORED\r",0
>57c1	47 4e 4f 52 45 44 0d 00
.57c9	60		rts		READ_Ret  RTS
.57ca					  READ_DATA
.57ca	20 a2 52	jsr $52a2	          JSR Skip_To_EOS
.57cd	c8		iny		          INY
.57ce	aa		tax		          TAX
.57cf	d0 15		bne $57e6	          BNE REDA_10
.57d1	a2 0d		ldx #$0d	          LDX #13
.57d3	c8		iny		          INY
.57d4	20 c9 03	jsr $03c9	          JSR INDTXT
.57d7	f0 40		beq $5819	          BEQ NEXT_40
.57d9	c8		iny		          INY
.57da	20 c9 03	jsr $03c9	          JSR INDTXT
.57dd	85 41		sta $41		          STA DATLIN
.57df	c8		iny		          INY
.57e0	20 c9 03	jsr $03c9	          JSR INDTXT
.57e3	c8		iny		          INY
.57e4	85 42		sta $42		          STA DATLIN+1
.57e6	20 92 52	jsr $5292	REDA_10   JSR Add_Y_To_Execution_Pointer
.57e9	20 86 03	jsr $0386	          JSR CHRGOT
.57ec	aa		tax		          TAX
.57ed	e0 83		cpx #$83	          CPX #$83            ; DATA token
.57ef	d0 d9		bne $57ca	          BNE READ_DATA
.57f1	4c 02 57	jmp $5702	          JMP READ_30
.57f4					  BASIC_NEXT
.57f4	d0 13		bne $5809	          BNE NEXT_20         ; branch if index after NEXT
.57f6	a0 ff		ldy #$ff	          LDY #$ff
.57f8	d0 14		bne $580e	          BNE NEXT_30         ; mark no index variable given
.57fa	a0 12		ldy #$12	NEXT_10   LDY #$12            ; size of FOR..NEXT structure
.57fc	20 59 50	jsr $5059	          JSR Free_TOS
.57ff	20 86 03	jsr $0386	          JSR CHRGOT
.5802	c9 2c		cmp #$2c	          CMP #','
.5804	d0 71		bne $5877	          BNE NEXT_Ret
.5806	20 80 03	jsr $0380	          JSR CHRGET
.5809	20 af 7a	jsr $7aaf	NEXT_20   JSR Parse_Name
.580c	85 4b		sta $4b		          STA FORPNT
.580e	84 4c		sty $4c		NEXT_30   STY FORPNT+1
.5810	a9 81		lda #$81	          LDA #$81            ; FOR marker
.5812	20 aa 4f	jsr $4faa	          JSR Find_Token_On_Stack
.5815	f0 05		beq $581c	          BEQ NEXT_50
.5817	a2 0a		ldx #$0a	          LDX #10             ; NEXT WITHOUT FOR
.5819	4c 3c 4d	jmp $4d3c	NEXT_40   JMP Print_Error_X
.581c	20 50 50	jsr $5050	NEXT_50   JSR Update_TOS
.581f	a5 3f		lda $3f		          LDA FNDPNT
.5821	18		clc		          CLC
.5822	69 03		adc #$03	          ADC #3
.5824	a4 40		ldy $40		          LDY FNDPNT+1
.5826	90 01		bcc $5829	          BCC NEXT_60
.5828	c8		iny		          INY
.5829	20 d4 8b	jsr $8bd4	NEXT_60   JSR Load_FAC1_AY    ; STEP value
.582c	a0 08		ldy #$08	          LDY #8
.582e	b1 3f		lda ($3f),y	          LDA (FNDPNT),Y      ; STEP sign
.5830	85 68		sta $68		          STA FAC1_SI
.5832	a0 01		ldy #$01	          LDY #1
.5834	b1 3f		lda ($3f),y	          LDA (FNDPNT),Y
.5836	48		pha		          PHA
.5837	aa		tax		          TAX
.5838	c8		iny		          INY
.5839	b1 3f		lda ($3f),y	          LDA (FNDPNT),Y
.583b	48		pha		          PHA
.583c	a8		tay		          TAY
.583d	8a		txa		          TXA
.583e	20 45 88	jsr $8845	          JSR Add_Var_AY_To_FAC1 ; FAC1 = index + STEP
.5841	68		pla		          PLA
.5842	a8		tay		          TAY
.5843	68		pla		          PLA
.5844	aa		tax		          TAX
.5845	8d 04 ff	sta $ff04	          STA MMU_LCRD
.5848	20 00 8c	jsr $8c00	          JSR FAC1_To_XY      ; store new index value
.584b	a5 3f		lda $3f		          LDA FNDPNT
.584d	18		clc		          CLC
.584e	69 09		adc #$09	          ADC #9
.5850	a4 40		ldy $40		          LDY FNDPNT+1        ; (A/Y) = address of TO value
.5852	90 01		bcc $5855	          BCC NEXT_70
.5854	c8		iny		          INY
.5855	8d 03 ff	sta $ff03	NEXT_70   STA MMU_LCRC
.5858	20 87 8c	jsr $8c87	          JSR Compare_AY_FAC1
.585b	a0 08		ldy #$08	          LDY #8
.585d	38		sec		          SEC
.585e	f1 3f		sbc ($3f),y	          SBC (FNDPNT),Y
.5860	f0 98		beq $57fa	          BEQ NEXT_10         ; -> exit FOR..NEXT loop
.5862	a0 11		ldy #$11	          LDY #$11
.5864	b1 3f		lda ($3f),y	          LDA (FNDPNT),Y      ; set TXTPTR and CURLIN to loop start
.5866	85 3d		sta $3d		          STA TXTPTR          ; and continue
.5868	88		dey		          DEY
.5869	b1 3f		lda ($3f),y	          LDA (FNDPNT),Y
.586b	85 3e		sta $3e		          STA TXTPTR+1
.586d	88		dey		          DEY
.586e	b1 3f		lda ($3f),y	          LDA (FNDPNT),Y
.5870	85 3c		sta $3c		          STA CURLIN+1
.5872	88		dey		          DEY
.5873	b1 3f		lda ($3f),y	          LDA (FNDPNT),Y
.5875	85 3b		sta $3b		          STA CURLIN
.5877	60		rts		NEXT_Ret  RTS
.5878	20 5c 79	jsr $795c	DIM_10    JSR Need_Comma
.587b					  BASIC_DIM
.587b	aa		tax		          TAX
.587c	20 b4 7a	jsr $7ab4	          JSR Get_Array_Address
.587f	20 86 03	jsr $0386	          JSR CHRGOT
.5882	d0 f4		bne $5878	          BNE DIM_10
.5884	60		rts		          RTS
.5885					  BASIC_SYS
.5885	20 12 88	jsr $8812	          JSR Get_Integer
.5888	a5 16		lda $16		          LDA LINNUM
.588a	85 04		sta $04		          STA PC_LO
.588c	a5 17		lda $17		          LDA LINNUM+1
.588e	85 03		sta $03		          STA PC_HI
.5890	ad d5 03	lda $03d5	          LDA USER_BANK
.5893	85 02		sta $02		          STA BANK
.5895	20 1e 9e	jsr $9e1e	          JSR Get_Byte_Or_Void
.5898	90 02		bcc $589c	          BCC SYS_10
.589a	86 06		stx $06		          STX A_REG
.589c	20 1e 9e	jsr $9e1e	SYS_10    JSR Get_Byte_Or_Void
.589f	90 02		bcc $58a3	          BCC SYS_20
.58a1	86 07		stx $07		          STX X_REG
.58a3	20 1e 9e	jsr $9e1e	SYS_20    JSR Get_Byte_Or_Void
.58a6	90 02		bcc $58aa	          BCC SYS_30
.58a8	86 08		stx $08		          STX Y_REG
.58aa	20 1e 9e	jsr $9e1e	SYS_30    JSR Get_Byte_Or_Void
.58ad	90 02		bcc $58b1	          BCC SYS_40
.58af	86 05		stx $05		          STX S_REG
.58b1	4c 6e ff	jmp $ff6e	SYS_40    JMP K_JSRFAR
.58b4					  BASIC_TRON
.58b4	a9 ff		lda #$ff	          LDA #$ff
>58b6	2c				          .BYTE $2C ;BIT
.58b7					  BASIC_TROFF
.58b7	a9 00		lda #$00	          LDA #0
.58b9	8d 6f 11	sta $116f	          STA TRCFLG
.58bc	60		rts		          RTS
.58bd					  BASIC_RREG
.58bd	a9 00		lda #$00	          LDA #0
.58bf	85 0d		sta $0d		          STA B_COUNT         ; count arguments
.58c1	20 86 03	jsr $0386	RREG_10   JSR CHRGOT
.58c4	f0 37		beq $58fd	          BEQ RREG_25
.58c6	c9 2c		cmp #$2c	          CMP #','
.58c8	f0 21		beq $58eb	          BEQ RREG_20         ; next argument
.58ca	20 af 7a	jsr $7aaf	          JSR Parse_Name
.58cd	85 4b		sta $4b		          STA FORPNT
.58cf	84 4c		sty $4c		          STY FORPNT+1        ; variable name
.58d1	a5 0f		lda $0f		          LDA VALTYP
.58d3	d0 29		bne $58fe	          BNE RREG_30         ; -> string variable not allowed
.58d5	a4 0d		ldy $0d		          LDY B_COUNT
.58d7	b9 06 00	lda $0006,y	          LDA A_REG,Y
.58da	c0 03		cpy #$03	          CPY #3
.58dc	d0 02		bne $58e0	          BNE RREG_15
.58de	a5 05		lda $05		          LDA S_REG
.58e0	a8		tay		RREG_15   TAY
.58e1	a9 00		lda #$00	          LDA #0
.58e3	20 3c 79	jsr $793c	          JSR Integer_To_Real
.58e6	a5 10		lda $10		          LDA INTFLG
.58e8	20 e3 53	jsr $53e3	          JSR Assign_Numeric_Variable
.58eb	e6 0d		inc $0d		RREG_20   INC B_COUNT
.58ed	a5 0d		lda $0d		          LDA B_COUNT
.58ef	c9 04		cmp #$04	          CMP #4
.58f1	b0 0a		bcs $58fd	          BCS RREG_25         ; loaded A,X,Y,S
.58f3	20 86 03	jsr $0386	          JSR CHRGOT
.58f6	f0 05		beq $58fd	          BEQ RREG_25
.58f8	20 80 03	jsr $0380	          JSR CHRGET
.58fb	d0 c4		bne $58c1	          BNE RREG_10
.58fd	60		rts		RREG_25   RTS
.58fe	4c e7 77	jmp $77e7	RREG_30   JMP TYPE_MISMATCH
.5901					  MID_ASSIGN
.5901	20 59 79	jsr $7959	          JSR Need_Left_Par
.5904	20 af 7a	jsr $7aaf	          JSR Parse_Name
.5907	85 4b		sta $4b		          STA FORPNT
.5909	84 4c		sty $4c		          STY FORPNT+1
.590b	20 dd 77	jsr $77dd	          JSR Need_String
.590e	20 09 88	jsr $8809	          JSR Comma_And_Byte
.5911	ca		dex		          DEX
.5912	86 78		stx $78		          STX KEYSIZ          ; start of substring
.5914	c9 29		cmp #$29	          CMP #')'
.5916	f0 04		beq $591c	          BEQ MIDA_10
.5918	20 09 88	jsr $8809	          JSR Comma_And_Byte
>591b	2c				          .BYTE $2C ;BIT
.591c	a2 ff		ldx #$ff	MIDA_10   LDX #$ff
.591e	86 77		stx $77		          STX TEMP_A          ; length of substring
.5920	20 56 79	jsr $7956	          JSR Need_Right_Par
.5923	a9 b2		lda #$b2	          LDA #$b2            ; '=' token
.5925	20 5e 79	jsr $795e	          JSR Need_A
.5928	20 ef 77	jsr $77ef	          JSR Eval_Expression
.592b	20 dd 77	jsr $77dd	          JSR Need_String
.592e	a0 02		ldy #$02	          LDY #2
.5930	a9 4b		lda #$4b	MIDA_20   LDA #FORPNT
.5932	20 ab 03	jsr $03ab	          JSR Fetch_1
.5935	99 5d 00	sta $005d,y	          STA HIGHTR+1,Y
.5938	20 e7 42	jsr $42e7	          JSR Get_FAC1_M3_1
.593b	99 60 00	sta $0060,y	          STA TENEXP,Y
.593e	88		dey		          DEY
.593f	10 ef		bpl $5930	          BPL MIDA_20
.5941	38		sec		          SEC
.5942	a5 61		lda $61		          LDA LOWTR
.5944	e5 78		sbc $78		          SBC KEYSIZ
.5946	85 61		sta $61		          STA LOWTR
.5948	b0 02		bcs $594c	          BCS MIDA_30
.594a	c6 62		dec $62		          DEC LOWTR+1         ; (LOWTR) = start of substring
.594c	a5 77		lda $77		MIDA_30   LDA TEMP_A
.594e	c5 60		cmp $60		          CMP TENEXP
.5950	90 02		bcc $5954	          BCC MIDA_40
.5952	a5 60		lda $60		          LDA TENEXP
.5954	aa		tax		MIDA_40   TAX
.5955	f0 18		beq $596f	          BEQ MIDA_70
.5957	18		clc		          CLC
.5958	65 78		adc $78		          ADC KEYSIZ
.595a	b0 16		bcs $5972	          BCS MIDA_Err
.595c	c5 5d		cmp $5d		          CMP HIGHTR+1
.595e	90 02		bcc $5962	          BCC MIDA_50
.5960	d0 10		bne $5972	          BNE MIDA_Err
.5962	a4 78		ldy $78		MIDA_50   LDY KEYSIZ
.5964	a9 61		lda #$61	MIDA_60   LDA #LOWTR          ; copy content into substring
.5966	20 ab 03	jsr $03ab	          JSR Fetch_1
.5969	91 5e		sta ($5e),y	          STA (FACTPB),Y
.596b	c8		iny		          INY
.596c	ca		dex		          DEX
.596d	d0 f5		bne $5964	          BNE MIDA_60
.596f	4c 81 87	jmp $8781	MIDA_70   JMP Free_String_FAC1
.5972	4c 28 7d	jmp $7d28	MIDA_Err  JMP Error_Illegal_Quantity
.5975					  BASIC_AUTO
.5975	20 f0 84	jsr $84f0	          JSR Assert_Direct_Mode
.5978	20 a0 50	jsr $50a0	          JSR Scan_Linenumber
.597b	a5 16		lda $16		          LDA LINNUM
.597d	85 74		sta $74		          STA AUTINC
.597f	a5 17		lda $17		          LDA LINNUM+1
.5981	85 75		sta $75		          STA AUTINC+1
.5983	4c 37 4d	jmp $4d37	          JMP BASIC_Ready
.5986					  BASIC_HELP
.5986	ae 08 12	ldx $1208	          LDX ERRNUM
.5989	e8		inx		          INX
.598a	f0 1d		beq $59a9	          BEQ HELP_10
.598c	ad 09 12	lda $1209	          LDA ERRLIN
.598f	ac 0a 12	ldy $120a	          LDY ERRLIN+1
.5992	85 16		sta $16		          STA LINNUM
.5994	84 17		sty $17		          STY LINNUM+1
.5996	20 64 50	jsr $5064	          JSR Search_BASIC_Line
.5999	90 0e		bcc $59a9	          BCC HELP_10
.599b	66 55		ror $55		          ROR HELPER
.599d	20 98 55	jsr $5598	          JSR Print_CR
.59a0	a6 16		ldx $16		          LDX LINNUM
.59a2	a5 17		lda $17		          LDA LINNUM+1
.59a4	20 23 51	jsr $5123	          JSR List_Line
.59a7	46 55		lsr $55		          LSR HELPER
.59a9	4c 98 55	jmp $5598	HELP_10   JMP Print_CR
.59ac					  At_Error_Position
.59ac	a6 62		ldx $62		          LDX LOWTR+1
.59ae	98		tya		          TYA
.59af	18		clc		          CLC
.59b0	65 61		adc $61		          ADC LOWTR
.59b2	90 01		bcc $59b5	          BCC AEP_10
.59b4	e8		inx		          INX
.59b5	ec 0f 12	cpx $120f	AEP_10    CPX ERRTXT+1
.59b8	d0 14		bne $59ce	          BNE AEP_Ret
.59ba	cd 0e 12	cmp $120e	          CMP ERRTXT
.59bd	90 0f		bcc $59ce	          BCC AEP_Ret
.59bf	f0 0d		beq $59ce	          BEQ AEP_Ret
.59c1	46 55		lsr $55		          LSR HELPER
.59c3	a9 12		lda #$12	          LDA #$12
.59c5	24 d7		bit $d7		          BIT MODE_80
.59c7	10 02		bpl $59cb	          BPL AEP_20
.59c9	a9 02		lda #$02	          LDA #2
.59cb	4c 0c 56	jmp $560c	AEP_20    JMP Print_Char
.59ce	60		rts		AEP_Ret   RTS
.59cf					  BASIC_GOSUB
.59cf	20 1d 5a	jsr $5a1d	          JSR Push_GOSUB
.59d2	20 86 03	jsr $0386	          JSR CHRGOT
.59d5	20 db 59	jsr $59db	          JSR BASIC_GOTO
.59d8	4c f6 4a	jmp $4af6	          JMP Next_Statement
.59db					  BASIC_GOTO
.59db	20 a0 50	jsr $50a0	          JSR Scan_Linenumber
.59de	a5 0a		lda $0a		          LDA ENDCHR          ; line # needed
.59e0	f0 38		beq $5a1a	          BEQ GoTo_Err        ; SYNTAX ERROR
.59e2					  GoTo
.59e2	20 a5 52	jsr $52a5	          JSR End_Of_Line
.59e5	38		sec		          SEC
.59e6	a5 3b		lda $3b		          LDA CURLIN
.59e8	e5 16		sbc $16		          SBC LINNUM
.59ea	a5 3c		lda $3c		          LDA CURLIN+1
.59ec	e5 17		sbc $17		          SBC LINNUM+1
.59ee	b0 0b		bcs $59fb	          BCS GoTo_10
.59f0	98		tya		          TYA
.59f1	38		sec		          SEC
.59f2	65 3d		adc $3d		          ADC TXTPTR
.59f4	a6 3e		ldx $3e		          LDX TXTPTR+1
.59f6	90 07		bcc $59ff	          BCC GoTo_20
.59f8	e8		inx		          INX
.59f9	b0 04		bcs $59ff	          BCS GoTo_20
.59fb					  GoTo_10
.59fb	a5 2d		lda $2d		          LDA TXTTAB
.59fd	a6 2e		ldx $2e		          LDX TXTTAB+1
.59ff	20 68 50	jsr $5068	GoTo_20   JSR Find_LINNUM_AX
.5a02	90 11		bcc $5a15	          BCC UNDEFINED_STATEMENT
.5a04	a5 61		lda $61		          LDA LOWTR
.5a06	e9 01		sbc #$01	          SBC #1
.5a08	85 3d		sta $3d		          STA TXTPTR
.5a0a	a5 62		lda $62		          LDA LOWTR+1
.5a0c	e9 00		sbc #$00	          SBC #0
.5a0e	85 3e		sta $3e		          STA TXTPTR+1
.5a10	24 7f		bit $7f		          BIT RUNMOD
.5a12	10 6d		bpl $5a81	          BPL Set_Run_Mode
.5a14	60		rts		          RTS
.5a15					  UNDEFINED_STATEMENT
.5a15	a2 11		ldx #$11	          LDX #$11            ; UNDEF'D STATEMENT
.5a17	4c 3c 4d	jmp $4d3c	          JMP Print_Error_X
.5a1a	4c 6c 79	jmp $796c	GoTo_Err  JMP SYNTAX_ERROR
.5a1d					  Push_GOSUB
.5a1d	a9 05		lda #$05	          LDA #5
.5a1f	20 fe 4f	jsr $4ffe	          JSR SUB_TOS
.5a22	a0 04		ldy #$04	          LDY #4
.5a24	a5 3e		lda $3e		          LDA TXTPTR+1
.5a26	91 7d		sta ($7d),y	          STA (TOS),Y
.5a28	88		dey		          DEY
.5a29	a5 3d		lda $3d		          LDA TXTPTR
.5a2b	91 7d		sta ($7d),y	          STA (TOS),Y
.5a2d	88		dey		          DEY
.5a2e	a5 3c		lda $3c		          LDA CURLIN+1
.5a30	91 7d		sta ($7d),y	          STA (TOS),Y
.5a32	88		dey		          DEY
.5a33	a5 3b		lda $3b		          LDA CURLIN
.5a35	91 7d		sta ($7d),y	          STA (TOS),Y
.5a37	88		dey		          DEY
.5a38	a9 8d		lda #$8d	          LDA #$8d            ; GOSUB token
.5a3a	91 7d		sta ($7d),y	          STA (TOS),Y
.5a3c	60		rts		          RTS
.5a3d					  BASIC_GO
.5a3d	20 80 03	jsr $0380	          JSR CHRGET
.5a40	c9 a4		cmp #$a4	          CMP #$a4            ; TO token
.5a42	d0 06		bne $5a4a	          BNE GO_10
.5a44	20 80 03	jsr $0380	          JSR CHRGET
.5a47	4c db 59	jmp $59db	          JMP BASIC_GOTO
.5a4a	20 f4 87	jsr $87f4	GO_10     JSR Get_Byte_Var
.5a4d	e0 40		cpx #$40	          CPX #64             ; GO64 ?
.5a4f	f0 03		beq $5a54	          BEQ GO_20
.5a51	4c 6c 79	jmp $796c	          JMP SYNTAX_ERROR
.5a54	20 e1 a7	jsr $a7e1	GO_20     JSR ARE_YOU_SURE
.5a57	d0 06		bne $5a5f	          BNE GO_Ret
.5a59	20 45 a8	jsr $a845	          JSR Map_IO
.5a5c	4c 4d ff	jmp $ff4d	          JMP K_C64
.5a5f	60		rts		GO_Ret    RTS
.5a60					  BASIC_CONT
.5a60	d0 38		bne $5a9a	          BNE SRM_Ret
.5a62	24 7f		bit $7f		          BIT RUNMOD
.5a64	30 34		bmi $5a9a	          BMI SRM_Ret
.5a66	a2 1a		ldx #$1a	          LDX #$1a            ; CAN'T CONTINUE
.5a68	ac 03 12	ldy $1203	          LDY OLDTXT+1
.5a6b	d0 03		bne $5a70	          BNE CONT_10
.5a6d	4c 3c 4d	jmp $4d3c	          JMP Print_Error_X
.5a70	ad 02 12	lda $1202	CONT_10   LDA OLDTXT
.5a73	85 3d		sta $3d		          STA TXTPTR
.5a75	84 3e		sty $3e		          STY TXTPTR+1
.5a77	ad 00 12	lda $1200	          LDA OLDLIN
.5a7a	ac 01 12	ldy $1201	          LDY OLDLIN+1
.5a7d	85 3b		sta $3b		          STA CURLIN
.5a7f	84 3c		sty $3c		          STY CURLIN+1
.5a81					  Set_Run_Mode
.5a81	a9 80		lda #$80	          LDA #$80
.5a83	85 7f		sta $7f		          STA RUNMOD
.5a85	0a		asl a		          ASL A               ; A = 0
.5a86	85 74		sta $74		          STA AUTINC          ; disable AUTO
.5a88	85 75		sta $75		          STA AUTINC+1
.5a8a	8d 7f 12	sta $127f	          STA INT_VAL
.5a8d	85 f6		sta $f6		          STA INSFLG
.5a8f	a2 02		ldx #$02	          LDX #2
.5a91	9d 76 12	sta $1276,x	SRM_10    STA INT_TRIP_FLAG,X
.5a94	ca		dex		          DEX
.5a95	10 fa		bpl $5a91	          BPL SRM_10
.5a97	4c 90 ff	jmp $ff90	          JMP K_SETMSG
.5a9a	60		rts		SRM_Ret   RTS
.5a9b					  BASIC_RUN
.5a9b	f0 18		beq $5ab5	          BEQ RUN_10          ; RUN
.5a9d	90 1c		bcc $5abb	          BCC RUN_20          ; RUN line
.5a9f	a9 40		lda #$40	          LDA #$40
.5aa1	85 7f		sta $7f		          STA RUNMOD
.5aa3	20 a7 a1	jsr $a1a7	          JSR BASIC_DLOAD     ; LOAD and RUN
.5aa6					  LINK_RUN
.5aa6	20 81 5a	jsr $5a81	          JSR Set_Run_Mode
.5aa9	20 f3 51	jsr $51f3	          JSR Reset_BASIC_Execution
.5aac	20 4f 4f	jsr $4f4f	          JSR Relink
.5aaf	20 98 55	jsr $5598	          JSR Print_CR
.5ab2	4c f6 4a	jmp $4af6	          JMP Next_Statement
.5ab5	20 81 5a	jsr $5a81	RUN_10    JSR Set_Run_Mode
.5ab8	4c f3 51	jmp $51f3	          JMP Reset_BASIC_Execution
.5abb	20 fa 51	jsr $51fa	RUN_20    JSR Clear_BASIC
.5abe	20 86 03	jsr $0386	          JSR CHRGOT
.5ac1	20 db 59	jsr $59db	          JSR BASIC_GOTO
.5ac4	20 81 5a	jsr $5a81	          JSR Set_Run_Mode
.5ac7	4c f6 4a	jmp $4af6	          JMP Next_Statement
.5aca					  BASIC_RESTORE
.5aca	f0 15		beq $5ae1	          BEQ Reset_DATPTR
.5acc	20 12 88	jsr $8812	          JSR Get_Integer
.5acf	84 16		sty $16		          STY LINNUM
.5ad1	85 17		sta $17		          STA LINNUM+1
.5ad3	20 64 50	jsr $5064	          JSR Search_BASIC_Line
.5ad6	b0 03		bcs $5adb	          BCS REST_10X
.5ad8	4c 15 5a	jmp $5a15	          JMP UNDEFINED_STATEMENT
.5adb	a5 61		lda $61		REST_10X  LDA LOWTR
.5add	a4 62		ldy $62		          LDY LOWTR+1
.5adf	b0 05		bcs $5ae6	          BCS ReDP_10
.5ae1					  Reset_DATPTR
.5ae1	38		sec		          SEC
.5ae2	a5 2d		lda $2d		          LDA TXTTAB
.5ae4	a4 2e		ldy $2e		          LDY TXTTAB+1
.5ae6	e9 01		sbc #$01	ReDP_10   SBC #1
.5ae8	b0 01		bcs $5aeb	          BCS ReDP_20
.5aea	88		dey		          DEY
.5aeb	85 43		sta $43		ReDP_20   STA DATPTR
.5aed	84 44		sty $44		          STY DATPTR+1
.5aef	60		rts		          RTS
.5af0					  Renumber_Token
>5af0	89				           .BYTE $89 ; GOTO
>5af1	8a				           .BYTE $8a ; RUN
>5af2	8d				           .BYTE $8d ; GOSUB
>5af3	a7				           .BYTE $a7 ; THEN
>5af4	8c				           .BYTE $8c ; RESTORE
>5af5	d6				           .BYTE $d6 ; RESUME
>5af6	d7				           .BYTE $d7 ; TRAP
>5af7	d5				           .BYTE $d5 ; ELSE
.5af8					  BASIC_RENUMBER
.5af8	20 f0 84	jsr $84f0	           JSR Assert_Direct_Mode
.5afb	a9 00		lda #$00	           LDA #>10           ; default start & increment = 10
.5afd	a2 0a		ldx #$0a	           LDX #<10
.5aff	8e 70 11	stx $1170	           STX Ren_Line_Lo
.5b02	8d 71 11	sta $1171	           STA Ren_Line_Hi
.5b05	8e 72 11	stx $1172	           STX Ren_Step_Lo
.5b08	8d 73 11	sta $1173	           STA Ren_Step_Hi
.5b0b	85 5c		sta $5c		           STA HIGHTR
.5b0d	85 5d		sta $5d		           STA HIGHTR+1
.5b0f	20 86 03	jsr $0386	           JSR CHRGOT
.5b12	f0 54		beq $5b68	           BEQ RENU_08        ; -> no arguments after RENUMBER
.5b14	20 a0 50	jsr $50a0	           JSR Scan_Linenumber
.5b17	a5 0a		lda $0a		           LDA ENDCHR
.5b19	f0 0a		beq $5b25	           BEQ RENU_02        ; -> only increment given
.5b1b	a5 16		lda $16		           LDA LINNUM
.5b1d	a6 17		ldx $17		           LDX LINNUM+1
.5b1f	8d 70 11	sta $1170	           STA Ren_Line_Lo    ; new start value
.5b22	8e 71 11	stx $1171	           STX Ren_Line_Hi
.5b25	20 06 9e	jsr $9e06	RENU_02    JSR Get_Comma_And_Integer
.5b28	90 0e		bcc $5b38	           BCC RENU_06
.5b2a	8c 72 11	sty $1172	           STY Ren_Step_Lo    ; increment value
.5b2d	8d 73 11	sta $1173	           STA Ren_Step_Hi
.5b30	0d 72 11	ora $1172	           ORA Ren_Step_Lo    ; test for zero
.5b33	d0 03		bne $5b38	           BNE RENU_06
.5b35	4c 28 7d	jmp $7d28	RENU_04    JMP Error_Illegal_Quantity ; zero increment
.5b38	20 06 9e	jsr $9e06	RENU_06    JSR Get_Comma_And_Integer
.5b3b	90 2b		bcc $5b68	           BCC RENU_08        ; -> no old start value given
.5b3d	84 5c		sty $5c		           STY HIGHTR
.5b3f	84 16		sty $16		           STY LINNUM
.5b41	85 5d		sta $5d		           STA HIGHTR+1
.5b43	85 17		sta $17		           STA LINNUM+1
.5b45	20 64 50	jsr $5064	           JSR Search_BASIC_Line
.5b48	a5 61		lda $61		           LDA LOWTR
.5b4a	a6 62		ldx $62		           LDX LOWTR+1
.5b4c	85 5a		sta $5a		           STA ARYPNT
.5b4e	86 5b		stx $5b		           STX ARYPNT+1
.5b50	ad 70 11	lda $1170	           LDA Ren_Line_Lo
.5b53	ae 71 11	ldx $1171	           LDX Ren_Line_Hi
.5b56	85 16		sta $16		           STA LINNUM
.5b58	86 17		stx $17		           STX LINNUM+1
.5b5a	20 64 50	jsr $5064	           JSR Search_BASIC_Line
.5b5d	38		sec		           SEC
.5b5e	a5 61		lda $61		           LDA LOWTR
.5b60	e5 5a		sbc $5a		           SBC ARYPNT
.5b62	a5 62		lda $62		           LDA LOWTR+1
.5b64	e5 5b		sbc $5b		           SBC ARYPNT+1
.5b66	90 cd		bcc $5b35	           BCC RENU_04
.5b68	20 68 5d	jsr $5d68	RENU_08    JSR Ren_Line_To_FAC          ; RENUMBER pass 1
.5b6b	20 9c 5d	jsr $5d9c	           JSR Next_Byte                ; check range of new line numbers
.5b6e	c8		iny		           INY
.5b6f	20 c9 03	jsr $03c9	           JSR INDTXT
.5b72	f0 3a		beq $5bae	           BEQ RENUMBER_PASS_2
.5b74	c8		iny		RENU_10    INY
.5b75	20 c9 03	jsr $03c9	           JSR INDTXT
.5b78	38		sec		           SEC
.5b79	e5 5c		sbc $5c		           SBC HIGHTR
.5b7b	c8		iny		           INY
.5b7c	20 c9 03	jsr $03c9	           JSR INDTXT
.5b7f	e5 5d		sbc $5d		           SBC HIGHTR+1
.5b81	b0 07		bcs $5b8a	           BCS RENU_12
.5b83	20 9d 5b	jsr $5b9d	           JSR Next_BASIC_Line
.5b86	d0 ec		bne $5b74	           BNE RENU_10
.5b88	f0 24		beq $5bae	           BEQ RENUMBER_PASS_2
.5b8a	20 9d 5b	jsr $5b9d	RENU_12    JSR Next_BASIC_Line
.5b8d	f0 1f		beq $5bae	           BEQ RENUMBER_PASS_2
.5b8f	20 89 5d	jsr $5d89	           JSR Add_Renumber_Step
.5b92	b0 04		bcs $5b98	           BCS RENU_14
.5b94	c9 f9		cmp #$f9	           CMP #$f9           ; line number < $f900 (63744)
.5b96	90 f2		bcc $5b8a	           BCC RENU_12
.5b98	a2 26		ldx #$26	RENU_14    LDX #$26           ; line number too large
.5b9a	4c 3c 4d	jmp $4d3c	           JMP Print_Error_X
.5b9d					  Next_BASIC_Line
.5b9d	a0 00		ldy #$00	           LDY #0
.5b9f	20 c9 03	jsr $03c9	           JSR INDTXT
.5ba2	aa		tax		           TAX
.5ba3	c8		iny		           INY
.5ba4	20 c9 03	jsr $03c9	           JSR INDTXT
.5ba7	f0 04		beq $5bad	           BEQ NBL_Ret
.5ba9	86 3d		stx $3d		           STX TXTPTR
.5bab	85 3e		sta $3e		           STA TXTPTR+1
.5bad	60		rts		NBL_Ret    RTS
.5bae					  RENUMBER_PASS_2
.5bae	a9 01		lda #$01	           LDA #1
.5bb0	85 77		sta $77		           STA TEMP_A         ; Flag for test run
.5bb2	ad 10 12	lda $1210	           LDA TEXT_TOP
.5bb5	ae 11 12	ldx $1211	           LDX TEXT_TOP+1
.5bb8	85 3f		sta $3f		           STA FNDPNT
.5bba	86 40		stx $40		           STX FNDPNT+1
.5bbc	20 fb 5b	jsr $5bfb	           JSR Replace_Targets
.5bbf	c6 77		dec $77		           DEC TEMP_A         ; Flag for run
.5bc1	20 fb 5b	jsr $5bfb	           JSR Replace_Targets
.5bc4	20 99 5d	jsr $5d99	RENU_20    JSR Get_Link_Hi
.5bc7	f0 2f		beq $5bf8	           BEQ RENU_26
.5bc9	20 9c 5d	jsr $5d9c	           JSR Next_Byte
.5bcc	85 16		sta $16		           STA LINNUM         ; line # lo
.5bce	c8		iny		           INY
.5bcf	20 c9 03	jsr $03c9	           JSR INDTXT         ; line # hi
.5bd2	38		sec		           SEC
.5bd3	e5 5d		sbc $5d		           SBC HIGHTR+1
.5bd5	90 19		bcc $5bf0	           BCC RENU_24        ; -> line # < old start
.5bd7	d0 06		bne $5bdf	           BNE RENU_22
.5bd9	a5 16		lda $16		           LDA LINNUM
.5bdb	e5 5c		sbc $5c		           SBC HIGHTR
.5bdd	90 11		bcc $5bf0	           BCC RENU_24        ; -> line # < old start
.5bdf	a5 64		lda $64		RENU_22    LDA FAC1_M1
.5be1	91 3d		sta ($3d),y	           STA (TXTPTR),Y     ; new line # hi
.5be3	88		dey		           DEY
.5be4	a5 65		lda $65		           LDA FAC1_M2
.5be6	91 3d		sta ($3d),y	           STA (TXTPTR),Y     ; new line # lo
.5be8	20 9c 5d	jsr $5d9c	           JSR Next_Byte
.5beb	20 80 5d	jsr $5d80	           JSR Next_Number
.5bee	f0 d4		beq $5bc4	           BEQ RENU_20
.5bf0	20 9c 5d	jsr $5d9c	RENU_24    JSR Next_Byte
.5bf3	20 83 5d	jsr $5d83	           JSR Skip_To_EOL
.5bf6	f0 cc		beq $5bc4	           BEQ RENU_20
.5bf8	4c e5 5e	jmp $5ee5	RENU_26    JMP Relink_Set_Top ; finished
.5bfb					  Replace_Targets
.5bfb	20 54 52	jsr $5254	           JSR Reset_TXTPTR
.5bfe	20 99 5d	jsr $5d99	RENU_30    JSR Get_Link_Hi
.5c01	d0 03		bne $5c06	           BNE RENU_32
.5c03	4c 68 5d	jmp $5d68	           JMP Ren_Line_To_FAC ; -> return
.5c06	20 9c 5d	jsr $5d9c	RENU_32    JSR Next_Byte
.5c09	85 4b		sta $4b		           STA FORPNT
.5c0b	20 9c 5d	jsr $5d9c	           JSR Next_Byte
.5c0e	85 4c		sta $4c		           STA FORPNT+1       ; (FORPNT) := old number
.5c10	20 9c 5d	jsr $5d9c	RENU_34    JSR Next_Byte
.5c13	c9 22		cmp #$22	RENU_36    CMP #QUOTE
.5c15	d0 0b		bne $5c22	           BNE RENU_40
.5c17	20 9c 5d	jsr $5d9c	RENU_38    JSR Next_Byte
.5c1a	f0 e2		beq $5bfe	           BEQ RENU_30
.5c1c	c9 22		cmp #$22	           CMP #QUOTE
.5c1e	d0 f7		bne $5c17	           BNE RENU_38
.5c20	f0 ee		beq $5c10	           BEQ RENU_34
.5c22	aa		tax		RENU_40    TAX
.5c23	f0 d9		beq $5bfe	           BEQ RENU_30        ; -> end of line
.5c25	10 e9		bpl $5c10	           BPL RENU_34        ; -> no token
.5c27	a2 08		ldx #$08	           LDX #8             ; # of tokens
.5c29	dd ef 5a	cmp $5aef,x	RENU_42    CMP Renumber_Token-1,X
.5c2c	f0 28		beq $5c56	           BEQ RENU_50
.5c2e	ca		dex		           DEX
.5c2f	d0 f8		bne $5c29	           BNE RENU_42
.5c31	c9 cb		cmp #$cb	           CMP #$cb           ; GO token
.5c33	d0 0b		bne $5c40	           BNE RENU_46
.5c35	20 80 03	jsr $0380	RENU_44    JSR CHRGET
.5c38	f0 c4		beq $5bfe	           BEQ RENU_30
.5c3a	c9 a4		cmp #$a4	           CMP #$a4           ; TO token
.5c3c	f0 18		beq $5c56	           BEQ RENU_50
.5c3e	d0 d0		bne $5c10	           BNE RENU_34
.5c40	c9 fe		cmp #$fe	RENU_46    CMP #$fe           ; start of 2-byte token
.5c42	d0 cc		bne $5c10	           BNE RENU_34
.5c44	20 80 03	jsr $0380	           JSR CHRGET
.5c47	f0 ec		beq $5c35	           BEQ RENU_44
.5c49	c9 17		cmp #$17	           CMP #$17           ; COLLISION token
.5c4b	d0 c3		bne $5c10	           BNE RENU_34
.5c4d	20 80 03	jsr $0380	RENU_48    JSR CHRGET
.5c50	f0 e3		beq $5c35	           BEQ RENU_44
.5c52	c9 2c		cmp #$2c	           CMP #','
.5c54	d0 f7		bne $5c4d	           BNE RENU_48
.5c56	a5 3d		lda $3d		RENU_50    LDA TXTPTR         ; found token with target
.5c58	8d 00 12	sta $1200	           STA OLDLIN
.5c5b	a5 3e		lda $3e		           LDA TXTPTR+1
.5c5d	8d 01 12	sta $1201	           STA OLDLIN+1
.5c60	20 80 03	jsr $0380	           JSR CHRGET
.5c63	b0 ae		bcs $5c13	           BCS RENU_36
.5c65	20 a0 50	jsr $50a0	           JSR Scan_Linenumber
.5c68	20 19 5d	jsr $5d19	           JSR Replace_Number
.5c6b	ad 00 12	lda $1200	           LDA OLDLIN
.5c6e	85 3d		sta $3d		           STA TXTPTR
.5c70	ad 01 12	lda $1201	           LDA OLDLIN+1
.5c73	85 3e		sta $3e		           STA TXTPTR+1
.5c75	20 80 03	jsr $0380	           JSR CHRGET
.5c78	a5 3d		lda $3d		           LDA TXTPTR
.5c7a	d0 02		bne $5c7e	           BNE RENU_52
.5c7c	c6 3e		dec $3e		           DEC TXTPTR+1
.5c7e	c6 3d		dec $3d		RENU_52    DEC TXTPTR
.5c80	a2 ff		ldx #$ff	           LDX #$ff
.5c82	a5 77		lda $77		           LDA TEMP_A         ; test run or active run ?
.5c84	f0 41		beq $5cc7	           BEQ RENU_60        ; -> do replacement
.5c86	20 8e 7e	jsr $7e8e	           JSR Test_OOM_CHRGOT
.5c89	c9 2c		cmp #$2c	RENU_54    CMP #','
.5c8b	f0 c9		beq $5c56	           BEQ RENU_50        ; -> multiple targets
.5c8d	d0 84		bne $5c13	           BNE RENU_36        ; -> look for next token
.5c8f					  Test_OOM_Bank_0
.5c8f	e8		inx		           INX                ; X = length of old number
.5c90	bd 01 01	lda $0101,x	           LDA STACK+1,X
.5c93	f0 1f		beq $5cb4	           BEQ OOM0_30
.5c95	20 80 03	jsr $0380	           JSR CHRGET
.5c98	90 f5		bcc $5c8f	           BCC Test_OOM_Bank_0
.5c9a	e6 3f		inc $3f		OOM0_10    INC FNDPNT
.5c9c	d0 02		bne $5ca0	           BNE OOM0_20
.5c9e	e6 40		inc $40		           INC FNDPNT+1
.5ca0	38		sec		OOM0_20    SEC
.5ca1	a5 3f		lda $3f		           LDA FNDPNT
.5ca3	ed 12 12	sbc $1212	           SBC TEXT_MAX
.5ca6	a5 40		lda $40		           LDA FNDPNT+1
.5ca8	ed 13 12	sbc $1213	           SBC TEXT_MAX+1
.5cab	b0 17		bcs $5cc4	           BCS OOM0_Err
.5cad	e8		inx		           INX
.5cae	bd 01 01	lda $0101,x	           LDA STACK+1,X
.5cb1	d0 e7		bne $5c9a	           BNE OOM0_10
.5cb3	60		rts		           RTS
.5cb4	20 80 03	jsr $0380	OOM0_30    JSR CHRGET
.5cb7	b0 0a		bcs $5cc3	           BCS OOM0_Ret
.5cb9	a5 3f		lda $3f		           LDA FNDPNT
.5cbb	d0 02		bne $5cbf	           BNE OOM0_40
.5cbd	c6 40		dec $40		           DEC FNDPNT+1
.5cbf	c6 3f		dec $3f		OOM0_40    DEC FNDPNT
.5cc1	90 f1		bcc $5cb4	           BCC OOM0_30
.5cc3	60		rts		OOM0_Ret   RTS
.5cc4	4c 3a 4d	jmp $4d3a	OOM0_Err   JMP OOM_Error
.5cc7					  RENU_60
.5cc7	e8		inx		           INX
.5cc8	bd 01 01	lda $0101,x	RENU_62    LDA STACK+1,X
.5ccb	f0 2c		beq $5cf9	           BEQ RENU_68
.5ccd	48		pha		           PHA
.5cce	20 9c 5d	jsr $5d9c	           JSR Next_Byte
.5cd1	c9 3a		cmp #$3a	           CMP #':'
.5cd3	b0 0c		bcs $5ce1	           BCS RENU_64
.5cd5	c9 20		cmp #$20	           CMP #' '
.5cd7	f0 08		beq $5ce1	           BEQ RENU_64
.5cd9	38		sec		           SEC
.5cda	e9 30		sbc #$30	           SBC #'0'
.5cdc	38		sec		           SEC
.5cdd	e9 d0		sbc #$d0	           SBC #$d0
.5cdf	90 10		bcc $5cf1	           BCC RENU_66        ; -> no digit
.5ce1	20 a7 5d	jsr $5da7	RENU_64    JSR Save_TXTPTR
.5ce4	e6 6d		inc $6d		           INC FAC2_M3
.5ce6	20 df 5d	jsr $5ddf	           JSR Move_Text_Down ; delete old number
.5ce9	ee 10 12	inc $1210	           INC TEXT_TOP
.5cec	d0 03		bne $5cf1	           BNE RENU_66
.5cee	ee 11 12	inc $1211	           INC TEXT_TOP+1
.5cf1	68		pla		RENU_66    PLA
.5cf2	a0 00		ldy #$00	           LDY #0
.5cf4	91 3d		sta ($3d),y	           STA (TXTPTR),Y
.5cf6	e8		inx		           INX
.5cf7	d0 cf		bne $5cc8	           BNE RENU_62
.5cf9	20 80 03	jsr $0380	RENU_68    JSR CHRGET
.5cfc	b0 8b		bcs $5c89	           BCS RENU_54
.5cfe	20 a7 5d	jsr $5da7	RENU_70    JSR Save_TXTPTR
.5d01	c6 6d		dec $6d		           DEC FAC2_M3
.5d03	20 c6 5d	jsr $5dc6	           JSR Move_Text_Up   ; insert new number
.5d06	ad 10 12	lda $1210	           LDA TEXT_TOP
.5d09	d0 03		bne $5d0e	           BNE RENU_72
.5d0b	ce 11 12	dec $1211	           DEC TEXT_TOP+1
.5d0e	ce 10 12	dec $1210	RENU_72    DEC TEXT_TOP
.5d11	20 86 03	jsr $0386	           JSR CHRGOT
.5d14	90 e8		bcc $5cfe	           BCC RENU_70
.5d16	4c 89 5c	jmp $5c89	           JMP RENU_54        ; replacement done
.5d19					  Replace_Number
.5d19	20 68 5d	jsr $5d68	           JSR Ren_Line_To_FAC
.5d1c	20 99 5d	jsr $5d99	RENU_80    JSR Get_Link_Hi
.5d1f	d0 0d		bne $5d2e	           BNE RENU_82
.5d21	a2 27		ldx #$27	           LDX #$27           ; unresolved reference
.5d23	a5 4b		lda $4b		           LDA FORPNT
.5d25	85 3b		sta $3b		           STA CURLIN
.5d27	a5 4c		lda $4c		           LDA FORPNT+1
.5d29	85 3c		sta $3c		           STA CURLIN+1
.5d2b	4c 3c 4d	jmp $4d3c	           JMP Print_Error_X
.5d2e	20 9c 5d	jsr $5d9c	RENU_82    JSR Next_Byte      ; line # lo
.5d31	85 5a		sta $5a		           STA ARYPNT
.5d33	c5 16		cmp $16		           CMP LINNUM
.5d35	d0 27		bne $5d5e	           BNE RENU_88
.5d37	20 9c 5d	jsr $5d9c	           JSR Next_Byte      ; line # hi
.5d3a	85 5b		sta $5b		           STA ARYPNT+1
.5d3c	c5 17		cmp $17		           CMP LINNUM+1
.5d3e	d0 23		bne $5d63	           BNE RENU_90
.5d40	38		sec		           SEC
.5d41	e5 5d		sbc $5d		           SBC HIGHTR+1
.5d43	90 08		bcc $5d4d	           BCC RENU_84
.5d45	d0 0e		bne $5d55	           BNE RENU_86
.5d47	a5 16		lda $16		           LDA LINNUM
.5d49	e5 5c		sbc $5c		           SBC HIGHTR
.5d4b	b0 08		bcs $5d55	           BCS RENU_86
.5d4d	a5 16		lda $16		RENU_84    LDA LINNUM
.5d4f	85 65		sta $65		           STA FAC1_M2
.5d51	a5 17		lda $17		           LDA LINNUM+1
.5d53	85 64		sta $64		           STA FAC1_M1
.5d55	a2 90		ldx #$90	RENU_86    LDX #$90
.5d57	38		sec		           SEC
.5d58	20 75 8c	jsr $8c75	           JSR Word_To_FAC1
.5d5b	4c 42 8e	jmp $8e42	           JMP Format_FAC1
.5d5e	20 9c 5d	jsr $5d9c	RENU_88    JSR Next_Byte
.5d61	85 5b		sta $5b		           STA ARYPNT+1
.5d63	20 75 5d	jsr $5d75	RENU_90    JSR Next_Line
.5d66	f0 b4		beq $5d1c	           BEQ RENU_80
.5d68					  Ren_Line_To_FAC
.5d68	ad 70 11	lda $1170	           LDA Ren_Line_Lo
.5d6b	85 65		sta $65		           STA FAC1_M2
.5d6d	ad 71 11	lda $1171	           LDA Ren_Line_Hi
.5d70	85 64		sta $64		           STA FAC1_M1
.5d72	4c 54 52	jmp $5254	           JMP Reset_TXTPTR
.5d75					  Next_Line
.5d75	a5 5a		lda $5a		           LDA ARYPNT
.5d77	38		sec		           SEC
.5d78	e5 5c		sbc $5c		           SBC HIGHTR
.5d7a	a5 5b		lda $5b		           LDA ARYPNT+1
.5d7c	e5 5d		sbc $5d		           SBC HIGHTR+1
.5d7e	90 03		bcc $5d83	           BCC Skip_To_EOL
.5d80					  Next_Number
.5d80	20 89 5d	jsr $5d89	           JSR Add_Renumber_Step
.5d83					  Skip_To_EOL
.5d83	20 9c 5d	jsr $5d9c	           JSR Next_Byte
.5d86	d0 fb		bne $5d83	           BNE Skip_To_EOL
.5d88	60		rts		           RTS
.5d89					  Add_Renumber_Step
.5d89	a5 65		lda $65		           LDA FAC1_M2
.5d8b	18		clc		           CLC
.5d8c	6d 72 11	adc $1172	           ADC Ren_Step_Lo
.5d8f	85 65		sta $65		           STA FAC1_M2
.5d91	a5 64		lda $64		           LDA FAC1_M1
.5d93	6d 73 11	adc $1173	           ADC Ren_Step_Hi
.5d96	85 64		sta $64		           STA FAC1_M1
.5d98	60		rts		           RTS
.5d99					  Get_Link_Hi
.5d99	20 9c 5d	jsr $5d9c	           JSR Next_Byte
.5d9c					  Next_Byte
.5d9c	a0 00		ldy #$00	           LDY #0
.5d9e	e6 3d		inc $3d		           INC TXTPTR
.5da0	d0 02		bne $5da4	           BNE NeBy_10
.5da2	e6 3e		inc $3e		           INC TXTPTR+1
.5da4	4c c9 03	jmp $03c9	NeBy_10    JMP INDTXT
.5da7					  Save_TXTPTR
.5da7	a5 3d		lda $3d		           LDA TXTPTR
.5da9	85 24		sta $24		           STA INDEXA
.5dab	a5 3e		lda $3e		           LDA TXTPTR+1
.5dad	85 25		sta $25		           STA INDEXA+1
.5daf	ad 10 12	lda $1210	           LDA TEXT_TOP
.5db2	85 26		sta $26		           STA INDEXB
.5db4	ad 11 12	lda $1211	           LDA TEXT_TOP+1
.5db7	85 27		sta $27		           STA INDEXB+1
.5db9	a0 00		ldy #$00	           LDY #0
.5dbb	84 0d		sty $0d		           STY B_COUNT
.5dbd	84 6d		sty $6d		           STY FAC2_M3
.5dbf	60		rts		           RTS
.5dc0					  Inc_INDEXB
.5dc0	e6 24		inc $24		           INC INDEXA
.5dc2	d0 02		bne $5dc6	           BNE Move_Text_Up
.5dc4	e6 25		inc $25		           INC INDEXA+1
.5dc6					  Move_Text_Up
.5dc6	a4 0d		ldy $0d		           LDY B_COUNT
.5dc8	c8		iny		           INY
.5dc9	20 05 43	jsr $4305	           JSR Get_INDEXA_0
.5dcc	a4 6d		ldy $6d		           LDY FAC2_M3
.5dce	c8		iny		           INY
.5dcf	91 24		sta ($24),y	           STA (INDEXA),Y
.5dd1	20 ee 5d	jsr $5dee	           JSR INDEXA_EQ_INDEXB
.5dd4	d0 ea		bne $5dc0	           BNE Inc_INDEXB
.5dd6	60		rts		           RTS
.5dd7					  Dec_INDEXB
.5dd7	a5 26		lda $26		           LDA INDEXB
.5dd9	d0 02		bne $5ddd	           BNE DEI2_10
.5ddb	c6 27		dec $27		           DEC INDEXB+1
.5ddd	c6 26		dec $26		DEI2_10    DEC INDEXB
.5ddf					  Move_Text_Down
.5ddf	a4 0d		ldy $0d		           LDY B_COUNT
.5de1	20 c0 03	jsr $03c0	           JSR Get_INDEXB_0
.5de4	a4 6d		ldy $6d		           LDY FAC2_M3
.5de6	91 26		sta ($26),y	           STA (INDEXB),Y
.5de8	20 ee 5d	jsr $5dee	           JSR INDEXA_EQ_INDEXB
.5deb	d0 ea		bne $5dd7	           BNE Dec_INDEXB
.5ded	60		rts		           RTS
.5dee					  INDEXA_EQ_INDEXB
.5dee	a5 24		lda $24		           LDA INDEXA
.5df0	c5 26		cmp $26		           CMP INDEXB
.5df2	d0 04		bne $5df8	           BNE CII2_Ret
.5df4	a5 25		lda $25		           LDA INDEXA+1
.5df6	c5 27		cmp $27		           CMP INDEXB+1
.5df8	60		rts		CII2_Ret   RTS
.5df9					  BASIC_FOR
.5df9	a9 80		lda #$80	          LDA #$80
.5dfb	85 12		sta $12		          STA SUBFLG          ; Inhibit integer index
.5dfd	20 c6 53	jsr $53c6	          JSR BASIC_LET       ; define index variable
.5e00	a9 81		lda #$81	          LDA #$81            ; FOR token
.5e02	20 aa 4f	jsr $4faa	          JSR Find_Token_On_Stack
.5e05	f0 08		beq $5e0f	          BEQ FOR_10          ; -> found
.5e07	a9 12		lda #$12	          LDA #$12            ; allocate 18 bytes for structure
.5e09	20 fe 4f	jsr $4ffe	          JSR SUB_TOS
.5e0c	20 47 50	jsr $5047	          JSR Init_FNDPNT
.5e0f	20 50 50	jsr $5050	FOR_10    JSR Update_TOS
.5e12	20 a2 52	jsr $52a2	          JSR Skip_To_EOS
.5e15	98		tya		          TYA
.5e16	a0 11		ldy #$11	          LDY #$11
.5e18	18		clc		          CLC
.5e19	65 3d		adc $3d		          ADC TXTPTR
.5e1b	91 7d		sta ($7d),y	          STA (TOS),Y         ; 11 : TXTPTR of loop body
.5e1d	a5 3e		lda $3e		          LDA TXTPTR+1
.5e1f	69 00		adc #$00	          ADC #0
.5e21	88		dey		          DEY
.5e22	91 7d		sta ($7d),y	          STA (TOS),Y         ; 10 : TXTPTR+1
.5e24	a5 3c		lda $3c		          LDA CURLIN+1
.5e26	88		dey		          DEY
.5e27	91 7d		sta ($7d),y	          STA (TOS),Y         ; 0f : CURLIN+1
.5e29	a5 3b		lda $3b		          LDA CURLIN
.5e2b	88		dey		          DEY
.5e2c	91 7d		sta ($7d),y	          STA (TOS),Y         ; 0e : CURLIN
.5e2e	a9 a4		lda #$a4	          LDA #$a4            ; TO token
.5e30	20 5e 79	jsr $795e	          JSR Need_A
.5e33	20 da 77	jsr $77da	          JSR Assert_Numeric
.5e36	20 d7 77	jsr $77d7	          JSR Eval_Numeric
.5e39	a5 68		lda $68		          LDA FAC1_SI
.5e3b	09 7f		ora #$7f	          ORA #$7f
.5e3d	25 64		and $64		          AND FAC1_M1         ; put sign bit into M1
.5e3f	85 64		sta $64		          STA FAC1_M1
.5e41	a2 04		ldx #$04	          LDX #4
.5e43	a0 0d		ldy #$0d	          LDY #13
.5e45	b5 63		lda $63,x	FOR_20    LDA FAC1_EX,X       ; 09-0d : store TO value
.5e47	91 7d		sta ($7d),y	          STA (TOS),Y
.5e49	ca		dex		          DEX                 ; non fatal bug
.5e4a	88		dey		          DEY                 ; X<0 should end the loop
.5e4b	10 f8		bpl $5e45	          BPL FOR_20
.5e4d	a9 9c		lda #$9c	          LDA #<Real_1        ; default STEP value = 1.0
.5e4f	a0 89		ldy #$89	          LDY #>Real_1
.5e51	20 d4 8b	jsr $8bd4	          JSR Load_FAC1_AY
.5e54	20 86 03	jsr $0386	          JSR CHRGOT
.5e57	c9 a9		cmp #$a9	          CMP #$a9            ; STEP token
.5e59	d0 06		bne $5e61	          BNE FOR_30
.5e5b	20 80 03	jsr $0380	          JSR CHRGET
.5e5e	20 d7 77	jsr $77d7	          JSR Eval_Numeric    ; get STEP value
.5e61	20 57 8c	jsr $8c57	FOR_30    JSR Test_FAC1_Sign
.5e64	48		pha		          PHA
.5e65	20 47 8c	jsr $8c47	          JSR Round_FAC1
.5e68	68		pla		          PLA
.5e69	a0 08		ldy #$08	          LDY #8
.5e6b	a2 05		ldx #$05	          LDX #5
.5e6d	91 7d		sta ($7d),y	FOR_40    STA (TOS),Y         ; 08    : store STEP sign
.5e6f	b5 62		lda $62,x	          LDA FAC1_EX-1,X     ; 03-07 : store STEP value
.5e71	88		dey		          DEY
.5e72	ca		dex		          DEX
.5e73	10 f8		bpl $5e6d	          BPL FOR_40
.5e75	a5 4c		lda $4c		          LDA FORPNT+1
.5e77	91 7d		sta ($7d),y	          STA (TOS),Y         ; 02 : FORPNT+1
.5e79	a5 4b		lda $4b		          LDA FORPNT
.5e7b	88		dey		          DEY
.5e7c	91 7d		sta ($7d),y	          STA (TOS),Y         ; 01 : FORPNT
.5e7e	a9 81		lda #$81	          LDA #$81
.5e80	88		dey		          DEY
.5e81	91 7d		sta ($7d),y	          STA (TOS),Y         ; 00 : FOR token marker
.5e83	60		rts		          RTS
.5e84	4c 6c 79	jmp $796c	FOR_Err   JMP SYNTAX_ERROR
.5e87					  BASIC_DELETE
.5e87	20 f0 84	jsr $84f0	          JSR Assert_Direct_Mode
.5e8a	20 86 03	jsr $0386	          JSR CHRGOT
.5e8d	f0 f5		beq $5e84	          BEQ FOR_Err
.5e8f	20 fb 5e	jsr $5efb	          JSR Get_Line_Range
.5e92	a5 61		lda $61		          LDA LOWTR
.5e94	a6 62		ldx $62		          LDX LOWTR+1
.5e96	85 26		sta $26		          STA INDEXB
.5e98	86 27		stx $27		          STX INDEXB+1
.5e9a	20 64 50	jsr $5064	          JSR Search_BASIC_Line
.5e9d	90 15		bcc $5eb4	          BCC DEL_20          ; -> not found
.5e9f	a0 01		ldy #$01	          LDY #1
.5ea1	20 ec 42	jsr $42ec	          JSR Get_LOWTR_0     ; link high
.5ea4	88		dey		          DEY
.5ea5	aa		tax		          TAX
.5ea6	d0 05		bne $5ead	          BNE DEL_10
.5ea8	20 ec 42	jsr $42ec	          JSR Get_LOWTR_0     ; link low
.5eab	f0 07		beq $5eb4	          BEQ DEL_20          ; -> end of program
.5ead	20 ec 42	jsr $42ec	DEL_10    JSR Get_LOWTR_0
.5eb0	85 61		sta $61		          STA LOWTR
.5eb2	86 62		stx $62		          STX LOWTR+1         ; (LOWTR) = next line
.5eb4	a5 26		lda $26		DEL_20    LDA INDEXB
.5eb6	38		sec		          SEC
.5eb7	e5 61		sbc $61		          SBC LOWTR
.5eb9	aa		tax		          TAX
.5eba	a5 27		lda $27		          LDA INDEXB+1
.5ebc	e5 62		sbc $62		          SBC LOWTR+1
.5ebe	a8		tay		          TAY
.5ebf	b0 24		bcs $5ee5	          BCS Relink_Set_Top  ; -> finished deleting
.5ec1	8a		txa		          TXA
.5ec2	18		clc		          CLC
.5ec3	6d 10 12	adc $1210	          ADC TEXT_TOP
.5ec6	8d 10 12	sta $1210	          STA TEXT_TOP
.5ec9	98		tya		          TYA
.5eca	6d 11 12	adc $1211	          ADC TEXT_TOP+1
.5ecd	8d 11 12	sta $1211	          STA TEXT_TOP+1
.5ed0	a0 00		ldy #$00	          LDY #0
.5ed2	20 ec 42	jsr $42ec	DEL_30    JSR Get_LOWTR_0     ; move upper part of program
.5ed5	91 26		sta ($26),y	          STA (INDEXB),Y      ; down, deleting current line
.5ed7	e6 61		inc $61		          INC LOWTR
.5ed9	d0 02		bne $5edd	          BNE DEL_40
.5edb	e6 62		inc $62		          INC LOWTR+1
.5edd	20 94 7e	jsr $7e94	DEL_40    JSR Inc_INDEXB_Cmp_TEXT_TOP
.5ee0	90 f0		bcc $5ed2	          BCC DEL_30
.5ee2	ea		nop		          NOP
.5ee3	ea		nop		          NOP
.5ee4	ea		nop		          NOP
.5ee5					  Relink_Set_Top
.5ee5	20 4f 4f	jsr $4f4f	          JSR Relink
.5ee8	a5 24		lda $24		          LDA INDEXA
.5eea	a6 25		ldx $25		          LDX INDEXA+1
.5eec	18		clc		          CLC
.5eed	69 02		adc #$02	          ADC #2
.5eef	8d 10 12	sta $1210	          STA TEXT_TOP
.5ef2	90 01		bcc $5ef5	          BCC ReST_10
.5ef4	e8		inx		          INX
.5ef5	8e 11 12	stx $1211	ReST_10   STX TEXT_TOP+1
.5ef8	60		rts		          RTS
>5ef9	00 00				          .FILL $5efb-* , $00 ;    2 bytes
.5efb					  Get_Line_Range
.5efb	f0 12		beq $5f0f	          BEQ GLR_10          ; -> no arguments
.5efd	90 10		bcc $5f0f	          BCC GLR_10          ; -> digit
.5eff	c9 ab		cmp #$ab	          CMP #$ab            ; leading '-' token
.5f01	d0 2e		bne $5f31	          BNE GLR_ERR         ; neither number nor minus
.5f03	a0 01		ldy #$01	          LDY #1
.5f05	20 c9 03	jsr $03c9	          JSR INDTXT          ; char after -
.5f08	f0 27		beq $5f31	          BEQ GLR_ERR         ; none:  -> error
.5f0a	c9 3a		cmp #$3a	          CMP #':'
.5f0c	f0 23		beq $5f31	          BEQ GLR_ERR         ; colon: -> error
.5f0e	38		sec		          SEC
.5f0f	20 a0 50	jsr $50a0	GLR_10    JSR Scan_Linenumber
.5f12	20 64 50	jsr $5064	          JSR Search_BASIC_Line
.5f15	20 86 03	jsr $0386	          JSR CHRGOT
.5f18	f0 0c		beq $5f26	          BEQ GLR_20          ; -> end of statement
.5f1a	c9 ab		cmp #$ab	          CMP #$ab            ; '-' token
.5f1c	d0 13		bne $5f31	          BNE GLR_ERR
.5f1e	20 80 03	jsr $0380	          JSR CHRGET
.5f21	20 a0 50	jsr $50a0	          JSR Scan_Linenumber
.5f24	d0 0b		bne $5f31	          BNE GLR_ERR
.5f26	a5 0a		lda $0a		GLR_20    LDA ENDCHR          ; # of digits
.5f28	d0 06		bne $5f30	          BNE GLR_Ret
.5f2a	a9 ff		lda #$ff	          LDA #$ff            ; endline default = $ffff
.5f2c	85 16		sta $16		          STA LINNUM
.5f2e	85 17		sta $17		          STA LINNUM+1
.5f30	60		rts		GLR_Ret   RTS
.5f31	4c 6c 79	jmp $796c	GLR_ERR   JMP SYNTAX_ERROR
.5f34					  BASIC_PUDEF
.5f34	20 7b 87	jsr $877b	          JSR Eval_String
.5f37	a8		tay		          TAY                 ; length of string
.5f38	88		dey		          DEY
.5f39	c0 04		cpy #$04	          CPY #4
.5f3b	90 03		bcc $5f40	          BCC PUDEF_10
.5f3d	4c 28 7d	jmp $7d28	          JMP Error_Illegal_Quantity ; PUDEF string too long
.5f40	20 b7 03	jsr $03b7	PUDEF_10  JSR Get_INDEXA_1
.5f43	8d 03 ff	sta $ff03	          STA MMU_LCRC
.5f46	99 04 12	sta $1204,y	          STA PU_FILL,Y        ; redefine PU characters
.5f49	88		dey		          DEY
.5f4a	10 f4		bpl $5f40	          BPL PUDEF_10
.5f4c	60		rts		          RTS
.5f4d					  BASIC_TRAP
.5f4d	20 d9 84	jsr $84d9	          JSR Assert_Non_Direct
.5f50	20 86 03	jsr $0386	          JSR CHRGOT
.5f53	f0 07		beq $5f5c	          BEQ TRAP_10         ; -> disable trapping
.5f55	20 12 88	jsr $8812	          JSR Get_Integer
.5f58	8c 0b 12	sty $120b	          STY TRAPNO
>5f5b	2c				          .BYTE $2C ;BIT
.5f5c	a9 ff		lda #$ff	TRAP_10   LDA #$ff
.5f5e	8d 0c 12	sta $120c	          STA TRAPNO+1
.5f61	60		rts		          RTS
.5f62					  BASIC_RESUME
.5f62	20 d9 84	jsr $84d9	          JSR Assert_Non_Direct
.5f65	ae 0a 12	ldx $120a	          LDX ERRLIN+1
.5f68	e8		inx		          INX
.5f69	f0 70		beq $5fdb	          BEQ CANT_RESUME     ; no error line defined
.5f6b	20 86 03	jsr $0386	          JSR CHRGOT
.5f6e	f0 47		beq $5fb7	          BEQ Resume_Execution
.5f70	90 3a		bcc $5fac	          BCC RESU_30
.5f72	c9 82		cmp #$82	          CMP #$82            ; NEXT token
.5f74	d0 62		bne $5fd8	          BNE RESU_Err
.5f76	20 b7 5f	jsr $5fb7	          JSR Resume_Execution
.5f79	a0 00		ldy #$00	          LDY #0
.5f7b	20 c9 03	jsr $03c9	          JSR INDTXT
.5f7e	d0 26		bne $5fa6	          BNE RESU_20
.5f80	c8		iny		          INY
.5f81	20 c9 03	jsr $03c9	          JSR INDTXT
.5f84	d0 09		bne $5f8f	          BNE RESU_10
.5f86	c8		iny		          INY
.5f87	20 c9 03	jsr $03c9	          JSR INDTXT
.5f8a	d0 03		bne $5f8f	          BNE RESU_10
.5f8c	4c 37 4d	jmp $4d37	          JMP BASIC_Ready
.5f8f	a0 03		ldy #$03	RESU_10   LDY #3
.5f91	20 c9 03	jsr $03c9	          JSR INDTXT
.5f94	85 3b		sta $3b		          STA CURLIN
.5f96	c8		iny		          INY
.5f97	20 c9 03	jsr $03c9	          JSR INDTXT
.5f9a	85 3c		sta $3c		          STA CURLIN+1
.5f9c	98		tya		          TYA
.5f9d	18		clc		          CLC
.5f9e	65 3d		adc $3d		          ADC TXTPTR
.5fa0	85 3d		sta $3d		          STA TXTPTR
.5fa2	90 02		bcc $5fa6	          BCC RESU_20
.5fa4	e6 3e		inc $3e		          INC TXTPTR+1
.5fa6	20 80 03	jsr $0380	RESU_20   JSR CHRGET
.5fa9	4c 8f 52	jmp $528f	          JMP Skip_Statement
.5fac	20 12 88	jsr $8812	RESU_30   JSR Get_Integer
.5faf	85 17		sta $17		          STA LINNUM+1
.5fb1	20 c6 5f	jsr $5fc6	          JSR Clear_Error_Flag
.5fb4	4c fb 59	jmp $59fb	          JMP GoTo_10
.5fb7					  Resume_Execution
.5fb7	a2 01		ldx #$01	          LDX #1
.5fb9	bd 09 12	lda $1209,x	ReEx_10   LDA ERRLIN,X
.5fbc	95 3b		sta $3b,x	          STA CURLIN,X
.5fbe	bd 0e 12	lda $120e,x	          LDA ERRTXT,X
.5fc1	95 3d		sta $3d,x	          STA TXTPTR,X
.5fc3	ca		dex		          DEX
.5fc4	10 f3		bpl $5fb9	          BPL ReEx_10
.5fc6					  Clear_Error_Flag
.5fc6	a2 ff		ldx #$ff	          LDX #$ff
.5fc8	8e 08 12	stx $1208	          STX ERRNUM
.5fcb	8e 09 12	stx $1209	          STX ERRLIN
.5fce	8e 0a 12	stx $120a	          STX ERRLIN+1
.5fd1	ae 0d 12	ldx $120d	          LDX TMPTRP
.5fd4	8e 0c 12	stx $120c	          STX TRAPNO+1
.5fd7	60		rts		          RTS
.5fd8	4c 6c 79	jmp $796c	RESU_Err  JMP SYNTAX_ERROR
.5fdb					  CANT_RESUME
.5fdb	a2 1f		ldx #$1f	      LDX #$1f
.5fdd	4c 3c 4d	jmp $4d3c	      JMP Print_Error_X
.5fe0					  BASIC_DO
.5fe0	a0 01		ldy #$01	          LDY #1
.5fe2	b9 3d 00	lda $003d,y	DO_10     LDA TXTPTR,Y        ; save position and line #
.5fe5	99 14 12	sta $1214,y	          STA TEXT_TMP,Y
.5fe8	b9 3b 00	lda $003b,y	          LDA CURLIN,Y
.5feb	99 16 12	sta $1216,y	          STA TEXT_LIN,Y
.5fee	88		dey		          DEY
.5fef	10 f1		bpl $5fe2	          BPL DO_10
.5ff1	20 86 03	jsr $0386	          JSR CHRGOT
.5ff4	f0 1c		beq $6012	          BEQ DO_40           ; -> unconditional DO
.5ff6	c9 fc		cmp #$fc	          CMP #$fc            ; UNTIL token
.5ff8	f0 11		beq $600b	          BEQ DO_30
.5ffa	c9 fd		cmp #$fd	          CMP #$fd            ; WHILE token
.5ffc	d0 43		bne $6041	          BNE Exit_Syn        ; SYNTAX ERROR
.5ffe	20 db 60	jsr $60db	          JSR Next_Expression
.6001	a5 63		lda $63		          LDA FAC1_EX
.6003	d0 0d		bne $6012	          BNE DO_40           ; -> WHILE(true)
.6005	20 86 03	jsr $0386	DO_20     JSR CHRGOT
.6008	4c 47 60	jmp $6047	          JMP EXIT_10         ; -> WHILE(false)
.600b	20 db 60	jsr $60db	DO_30     JSR Next_Expression
.600e	a5 63		lda $63		          LDA FAC1_EX
.6010	d0 f3		bne $6005	          BNE DO_20           ; -> UNTIL(true)
.6012	a9 05		lda #$05	DO_40     LDA #5
.6014	20 fe 4f	jsr $4ffe	          JSR SUB_TOS         ; allocate DO structure
.6017	8d 03 ff	sta $ff03	          STA MMU_LCRC
.601a	a0 04		ldy #$04	          LDY #4
.601c	ad 15 12	lda $1215	          LDA TEXT_TMP+1
.601f	91 7d		sta ($7d),y	          STA (TOS),Y         ; TXTPTR loop body
.6021	88		dey		          DEY
.6022	ad 14 12	lda $1214	          LDA TEXT_TMP
.6025	91 7d		sta ($7d),y	          STA (TOS),Y
.6027	88		dey		          DEY
.6028	ad 17 12	lda $1217	          LDA TEXT_LIN+1      ; LINE # loop body
.602b	91 7d		sta ($7d),y	          STA (TOS),Y
.602d	88		dey		          DEY
.602e	ad 16 12	lda $1216	          LDA TEXT_LIN
.6031	91 7d		sta ($7d),y	          STA (TOS),Y
.6033	88		dey		          DEY
.6034	a9 eb		lda #$eb	          LDA #$eb            ; DO token marker
.6036	91 7d		sta ($7d),y	          STA (TOS),Y
.6038	60		rts		          RTS
.6039					  BASIC_EXIT
.6039	20 9b 60	jsr $609b	          JSR Exit_DO
.603c	20 86 03	jsr $0386	          JSR CHRGOT
.603f	f0 06		beq $6047	          BEQ EXIT_10
.6041	4c 6c 79	jmp $796c	Exit_Syn  JMP SYNTAX_ERROR
.6044					  Exit_LOOP
.6044	20 80 03	jsr $0380	          JSR CHRGET
.6047	f0 17		beq $6060	EXIT_10   BEQ EXIT_30
.6049	c9 ec		cmp #$ec	          CMP #$ec            ; LOOP token
.604b	f0 3a		beq $6087	          BEQ EXIT_40
.604d	c9 22		cmp #$22	          CMP #QUOTE
.604f	f0 0a		beq $605b	          BEQ EXIT_20
.6051	c9 eb		cmp #$eb	          CMP #$eb            ; DO token
.6053	d0 ef		bne $6044	          BNE Exit_LOOP
.6055	20 44 60	jsr $6044	          JSR Exit_LOOP
.6058	4c 05 60	jmp $6005	          JMP DO_20
.605b	20 7c 53	jsr $537c	EXIT_20   JSR Skip_To_End_Of_String
.605e	d0 e4		bne $6044	          BNE Exit_LOOP
.6060	c9 3a		cmp #$3a	EXIT_30   CMP #':'
.6062	f0 e0		beq $6044	          BEQ Exit_LOOP
.6064	24 7f		bit $7f		          BIT RUNMOD
.6066	10 42		bpl $60aa	          BPL EXIT_50
.6068	a0 02		ldy #$02	          LDY #2
.606a	20 c9 03	jsr $03c9	          JSR INDTXT
.606d	f0 3b		beq $60aa	          BEQ EXIT_50
.606f	c8		iny		          INY
.6070	20 c9 03	jsr $03c9	          JSR INDTXT
.6073	85 3b		sta $3b		          STA CURLIN
.6075	c8		iny		          INY
.6076	20 c9 03	jsr $03c9	          JSR INDTXT
.6079	85 3c		sta $3c		          STA CURLIN+1
.607b	98		tya		          TYA
.607c	18		clc		          CLC
.607d	65 3d		adc $3d		          ADC TXTPTR
.607f	85 3d		sta $3d		          STA TXTPTR
.6081	90 c1		bcc $6044	          BCC Exit_LOOP
.6083	e6 3e		inc $3e		          INC TXTPTR+1
.6085	d0 bd		bne $6044	          BNE Exit_LOOP
.6087	4c 8f 52	jmp $528f	EXIT_40   JMP Skip_Statement
.608a					  BASIC_LOOP
.608a	f0 35		beq $60c1	          BEQ EXIT_80
.608c	c9 fd		cmp #$fd	          CMP #$fd
.608e	f0 2c		beq $60bc	          BEQ EXIT_70
.6090	c9 fc		cmp #$fc	          CMP #$fc
.6092	d0 ad		bne $6041	          BNE Exit_Syn
.6094	20 db 60	jsr $60db	          JSR Next_Expression
.6097	a5 63		lda $63		          LDA FAC1_EX
.6099	f0 26		beq $60c1	          BEQ EXIT_80
.609b					  Exit_DO
.609b	a9 eb		lda #$eb	          LDA #$eb            ; DO token
.609d	20 aa 4f	jsr $4faa	          JSR Find_Token_On_Stack
.60a0	d0 15		bne $60b7	          BNE EXIT_60
.60a2	20 50 50	jsr $5050	          JSR Update_TOS
.60a5	a0 05		ldy #$05	          LDY #5
.60a7	4c 59 50	jmp $5059	          JMP Free_TOS
.60aa	ad 16 12	lda $1216	EXIT_50   LDA TEXT_LIN
.60ad	ae 17 12	ldx $1217	          LDX TEXT_LIN+1
.60b0	85 3b		sta $3b		          STA CURLIN
.60b2	86 3c		stx $3c		          STX CURLIN+1
.60b4	a2 20		ldx #$20	          LDX #$20            ; LOOP NOT FOUND
>60b6	2c				          .BYTE $2C ;BIT
.60b7	a2 21		ldx #$21	EXIT_60   LDX #$21            ; LOOP WITHOUT DO
.60b9	4c 3c 4d	jmp $4d3c	          JMP Print_Error_X
.60bc	20 db 60	jsr $60db	EXIT_70   JSR Next_Expression
.60bf	f0 da		beq $609b	          BEQ Exit_DO
.60c1	20 9b 60	jsr $609b	EXIT_80   JSR Exit_DO
.60c4	88		dey		          DEY
.60c5	b1 3f		lda ($3f),y	          LDA (FNDPNT),Y
.60c7	85 3e		sta $3e		          STA TXTPTR+1
.60c9	88		dey		          DEY
.60ca	b1 3f		lda ($3f),y	          LDA (FNDPNT),Y
.60cc	85 3d		sta $3d		          STA TXTPTR
.60ce	88		dey		          DEY
.60cf	b1 3f		lda ($3f),y	          LDA (FNDPNT),Y
.60d1	20 3b a8	jsr $a83b	          JSR To_Direct_Mode
.60d4	b1 3f		lda ($3f),y	          LDA (FNDPNT),Y
.60d6	85 3b		sta $3b		          STA CURLIN
.60d8	4c e0 5f	jmp $5fe0	          JMP BASIC_DO
.60db					  Next_Expression
.60db	20 80 03	jsr $0380	          JSR CHRGET
.60de	4c ef 77	jmp $77ef	          JMP Eval_Expression
.60e1					  Assign_Key
.60e1	20 f4 87	jsr $87f4	          JSR Get_Byte_Var
.60e4	ca		dex		          DEX                 ; key # minus 1
.60e5	e0 08		cpx #$08	          CPX #8              ; 8 function keys
.60e7	90 03		bcc $60ec	          BCC AsKe_10
.60e9	4c 28 7d	jmp $7d28	          JMP Error_Illegal_Quantity
.60ec	86 77		stx $77		AsKe_10   STX TEMP_A
.60ee	20 5c 79	jsr $795c	          JSR Need_Comma
.60f1	20 7b 87	jsr $877b	          JSR Eval_String
.60f4	a8		tay		          TAY
.60f5	a9 01		lda #$01	          LDA #1
.60f7	85 26		sta $26		          STA INDEXB
.60f9	a9 24		lda #$24	          LDA #INDEXA
.60fb	a6 77		ldx $77		          LDX TEMP_A
.60fd	e8		inx		          INX                 ; X = key #
.60fe	20 45 a8	jsr $a845	          JSR Map_IO
.6101	20 65 ff	jsr $ff65	          JSR K_PFKEY
.6104	b0 01		bcs $6107	          BCS AsKe_OOM
.6106	60		rts		          RTS
.6107	4c 3a 4d	jmp $4d3a	AsKe_OOM  JMP OOM_Error
.610a					  BASIC_KEY
.610a	f0 15		beq $6121	          BEQ BKEY_10         ; -> list key strings
.610c	c9 91		cmp #$91	          CMP #$91            ; ON token
.610e	f0 0e		beq $611e	          BEQ BKEY_Err
.6110	c9 fe		cmp #$fe	          CMP #$fe
.6112	d0 cd		bne $60e1	          BNE Assign_Key
.6114	20 80 03	jsr $0380	          JSR CHRGET
.6117	c9 24		cmp #$24	          CMP #$24            ; $fe24 = OFF token
.6119	f0 03		beq $611e	          BEQ BKEY_Err
.611b	4c 6c 79	jmp $796c	          JMP SYNTAX_ERROR
.611e	4c 46 48	jmp $4846	BKEY_Err  JMP Unimplemented
.6121	a2 00		ldx #$00	BKEY_10   LDX #0
.6123	a0 00		ldy #$00	          LDY #0
.6125	e8		inx		BKEY_15   INX
.6126	bd ff 0f	lda $0fff,x	          LDA PKYBUF-1,X      ; length of key string
.6129	f0 53		beq $617e	          BEQ BKEY_60          ; -> zero = unset
.612b	85 78		sta $78		          STA KEYSIZ
.612d	86 77		stx $77		          STX TEMP_A          ; key #
.612f	a2 05		ldx #$05	          LDX #5
.6131	bd 2a a8	lda $a82a,x	BKEY_20   LDA KEYREV,X        ; print KEY N,
.6134	ca		dex		          DEX
.6135	d0 02		bne $6139	          BNE BKEY_25
.6137	05 77		ora $77		          ORA TEMP_A
.6139	20 69 92	jsr $9269	BKEY_25   JSR B_BSOUT
.613c	8a		txa		          TXA
.613d	10 f2		bpl $6131	          BPL BKEY_20
.613f	a2 07		ldx #$07	          LDX #7
.6141	b9 0a 10	lda $100a,y	BKEY_30   LDA PKYDEF,Y        ; next char
.6144	c8		iny		          INY
.6145	48		pha		          PHA
.6146	86 79		stx $79		          STX SYNTMP          ; save X
.6148	a2 04		ldx #$04	          LDX #4
.614a	dd a3 61	cmp $61a3,x	BKEY_35   CMP PFKEY_SPECIAL,X
.614d	f0 34		beq $6183	          BEQ BKEY_65         ; -> found special char
.614f	ca		dex		          DEX
.6150	d0 f8		bne $614a	          BNE BKEY_35
.6152	a6 79		ldx $79		          LDX SYNTMP          ; restore X
.6154	e0 08		cpx #$08	          CPX #8
.6156	90 07		bcc $615f	          BCC BKEY_40
.6158	d0 0a		bne $6164	          BNE BKEY_45
.615a	a9 2b		lda #$2b	          LDA #'+'
.615c	20 69 92	jsr $9269	          JSR B_BSOUT
.615f	a9 22		lda #$22	BKEY_40   LDA #QUOTE
.6161	20 69 92	jsr $9269	          JSR B_BSOUT
.6164	68		pla		BKEY_45   PLA
.6165	20 69 92	jsr $9269	          JSR B_BSOUT
.6168	a2 09		ldx #$09	          LDX #9
.616a	c6 78		dec $78		BKEY_50   DEC KEYSIZ
.616c	d0 d3		bne $6141	          BNE BKEY_30
.616e	e0 09		cpx #$09	          CPX #9
.6170	90 05		bcc $6177	          BCC BKEY_55
.6172	a9 22		lda #$22	          LDA #QUOTE
.6174	20 69 92	jsr $9269	          JSR B_BSOUT
.6177	a9 8d		lda #$8d	BKEY_55   LDA #$8d            ; SHIFT RETURN
.6179	20 69 92	jsr $9269	          JSR B_BSOUT
.617c	a6 77		ldx $77		          LDX TEMP_A
.617e	e0 08		cpx #$08	BKEY_60   CPX #8
.6180	d0 a3		bne $6125	          BNE BKEY_15         ; -> loop to next key
.6182	60		rts		          RTS
.6183	a6 79		ldx $79		BKEY_65   LDX SYNTMP          ; handle printing of special chars
.6185	bd 9a 61	lda $619a,x	BKEY_70   LDA REVCHR-3,X
.6188	20 69 92	jsr $9269	          JSR B_BSOUT
.618b	ca		dex		          DEX
.618c	e0 03		cpx #$03	          CPX #3
.618e	b0 f5		bcs $6185	          BCS BKEY_70
.6190	68		pla		          PLA
.6191	20 30 a8	jsr $a830	          JSR Print_Byte_A
.6194	a9 29		lda #$29	          LDA #')'
.6196	20 69 92	jsr $9269	          JSR B_BSOUT
.6199	a2 08		ldx #$08	          LDX #8
.619b	d0 cd		bne $616a	          BNE BKEY_50         ; always
>619d	28 24 52 48 43 2b		REVCHR    .TEXT "($RHC+"
.61a3					PFKEY_SPECIAL
>61a3	22 0d 8d 22 1b			          .BYTE $22,$0d,$8d,$22,$1b
.61a8					  BASIC_PAINT
.61a8	20 2f 9e	jsr $9e2f	          JSR Assert_Color_Source
.61ab	a2 04		ldx #$04	          LDX #4
.61ad	20 52 9e	jsr $9e52	          JSR Get_Graphics_XY
.61b0	20 f2 9d	jsr $9df2	          JSR XY_DEST_To_POS
.61b3	20 1c 9e	jsr $9e1c	          JSR Get_Byte_Or_Zero
.61b6	e0 02		cpx #$02	          CPX #2
.61b8	90 03		bcc $61bd	          BCC PAINT_10        ; allow 0 or 1
.61ba	4c 28 7d	jmp $7d28	          JMP Error_Illegal_Quantity
.61bd	8a		txa		PAINT_10  TXA
.61be	4a		lsr a		          LSR A
.61bf	6a		ror a		          ROR A
.61c0	85 8b		sta $8b		          STA STOPNB
.61c2	10 04		bpl $61c8	          BPL PAINT_15
.61c4	a5 83		lda $83		          LDA COLSEL
.61c6	f0 07		beq $61cf	          BEQ PAINT_20
.61c8	20 49 9c	jsr $9c49	PAINT_15  JSR Get_Pixel
.61cb	b0 02		bcs $61cf	          BCS PAINT_20
.61cd	d0 01		bne $61d0	          BNE PAINT_25
.61cf	60		rts		PAINT_20  RTS
.61d0	20 ea 92	jsr $92ea	PAINT_25  JSR Garbage_Collection
.61d3	8d 03 ff	sta $ff03	          STA MMU_LCRC
.61d6	a5 33		lda $33		          LDA STREND
.61d8	85 24		sta $24		          STA INDEXA
.61da	a5 34		lda $34		          LDA STREND+1
.61dc	85 25		sta $25		          STA INDEXA+1
.61de	38		sec		          SEC
.61df	a5 35		lda $35		          LDA FRETOP
.61e1	e9 03		sbc #$03	          SBC #3
.61e3	85 1b		sta $1b		          STA TEMPST
.61e5	a5 36		lda $36		          LDA FRETOP+1
.61e7	e9 00		sbc #$00	          SBC #0
.61e9	85 1c		sta $1c		          STA TEMPST+1
.61eb	a2 00		ldx #$00	PAINT_30  LDX #0
.61ed	86 63		stx $63		          STX FAC1_EX
.61ef	86 64		stx $64		          STX FAC1_M1
.61f1	ae 33 11	ldx $1133	PAINT_35  LDX YPOS
.61f4	d0 03		bne $61f9	          BNE PAINT_40
.61f6	ce 34 11	dec $1134	          DEC YPOS+1
.61f9	ce 33 11	dec $1133	PAINT_40  DEC YPOS
.61fc	20 49 9c	jsr $9c49	          JSR Get_Pixel
.61ff	b0 02		bcs $6203	          BCS PAINT_45
.6201	d0 ee		bne $61f1	          BNE PAINT_35
.6203	ee 33 11	inc $1133	PAINT_45  INC YPOS
.6206	d0 03		bne $620b	          BNE PAINT_50
.6208	ee 34 11	inc $1134	          INC YPOS+1
.620b	20 19 9c	jsr $9c19	PAINT_50  JSR Set_Pixel
.620e	ae 31 11	ldx $1131	          LDX XPOS
.6211	d0 03		bne $6216	          BNE PAINT_55
.6213	ce 32 11	dec $1132	          DEC XPOS+1
.6216	ce 31 11	dec $1131	PAINT_55  DEC XPOS
.6219	a5 63		lda $63		          LDA FAC1_EX
.621b	20 7c 62	jsr $627c	          JSR Test_Pixel
.621e	85 63		sta $63		          STA FAC1_EX
.6220	18		clc		          CLC
.6221	ad 31 11	lda $1131	          LDA XPOS
.6224	69 02		adc #$02	          ADC #2
.6226	8d 31 11	sta $1131	          STA XPOS
.6229	90 03		bcc $622e	          BCC PAINT_60
.622b	ee 32 11	inc $1132	          INC XPOS+1
.622e	a5 64		lda $64		PAINT_60  LDA FAC1_M1
.6230	20 7c 62	jsr $627c	          JSR Test_Pixel
.6233	85 64		sta $64		          STA FAC1_M1
.6235	ae 31 11	ldx $1131	          LDX XPOS
.6238	d0 03		bne $623d	          BNE PAINT_65
.623a	ce 32 11	dec $1132	          DEC XPOS+1
.623d	ce 31 11	dec $1131	PAINT_65  DEC XPOS
.6240	ee 33 11	inc $1133	          INC YPOS
.6243	d0 03		bne $6248	          BNE PAINT_70
.6245	ee 34 11	inc $1134	          INC YPOS+1
.6248	20 49 9c	jsr $9c49	PAINT_70  JSR Get_Pixel
.624b	b0 02		bcs $624f	          BCS PAINT_75
.624d	d0 bc		bne $620b	          BNE PAINT_50
.624f	a2 03		ldx #$03	PAINT_75  LDX #3
.6251	a0 00		ldy #$00	          LDY #0
.6253	a5 25		lda $25		          LDA INDEXA+1
.6255	c5 34		cmp $34		          CMP STREND+1
.6257	d0 06		bne $625f	          BNE PAINT_80
.6259	a5 24		lda $24		          LDA INDEXA
.625b	c5 33		cmp $33		          CMP STREND
.625d	f0 1a		beq $6279	          BEQ PAINT_90
.625f	a5 24		lda $24		PAINT_80  LDA INDEXA
.6261	d0 02		bne $6265	          BNE PAINT_85
.6263	c6 25		dec $25		          DEC INDEXA+1
.6265	c6 24		dec $24		PAINT_85  DEC INDEXA
.6267	20 b7 03	jsr $03b7	          JSR Get_INDEXA_1
.626a	8d 03 ff	sta $ff03	          STA MMU_LCRC
.626d	9d 31 11	sta $1131,x	          STA XPOS,X
.6270	ca		dex		          DEX
.6271	10 ec		bpl $625f	          BPL PAINT_80
.6273	20 b5 4b	jsr $4bb5	          JSR Is_STOP_Key
.6276	4c eb 61	jmp $61eb	          JMP PAINT_30
.6279	4c f2 9d	jmp $9df2	PAINT_90  JMP XY_DEST_To_POS
.627c					  Test_Pixel
.627c	48		pha		          PHA
.627d	20 49 9c	jsr $9c49	          JSR Get_Pixel
.6280	b0 18		bcs $629a	          BCS TePi_10
.6282	f0 16		beq $629a	          BEQ TePi_10
.6284	68		pla		          PLA
.6285	d0 16		bne $629d	          BNE TePi_20
.6287	aa		tax		          TAX
.6288	a8		tay		          TAY
.6289	a5 25		lda $25		          LDA INDEXA+1
.628b	c5 1c		cmp $1c		          CMP TEMPST+1
.628d	90 0f		bcc $629e	          BCC TePi_30
.628f	d0 06		bne $6297	          BNE TePi_OOM
.6291	a5 24		lda $24		          LDA INDEXA
.6293	c5 1b		cmp $1b		          CMP TEMPST
.6295	90 07		bcc $629e	          BCC TePi_30
.6297	4c 3a 4d	jmp $4d3a	TePi_OOM  JMP OOM_Error
.629a	68		pla		TePi_10   PLA
.629b	a9 00		lda #$00	          LDA #0
.629d	60		rts		TePi_20   RTS
.629e	bd 31 11	lda $1131,x	TePi_30   LDA XPOS,X
.62a1	8d 04 ff	sta $ff04	          STA MMU_LCRD
.62a4	91 24		sta ($24),y	          STA (INDEXA),Y
.62a6	8d 03 ff	sta $ff03	          STA MMU_LCRC
.62a9	e6 24		inc $24		          INC INDEXA
.62ab	d0 02		bne $62af	          BNE TePi_40
.62ad	e6 25		inc $25		          INC INDEXA+1
.62af	e8		inx		TePi_40   INX
.62b0	e0 04		cpx #$04	          CPX #4
.62b2	d0 ea		bne $629e	          BNE TePi_30
.62b4	a9 80		lda #$80	          LDA #$80
.62b6	60		rts		          RTS
.62b7					  BASIC_BOX
.62b7	20 2f 9e	jsr $9e2f	          JSR Assert_Color_Source
.62ba	a2 1f		ldx #$1f	          LDX #XCIRCL-XPOS    ; $1f = address of upper left corner
.62bc	20 6d 9e	jsr $9e6d	          JSR Get_Comma_And_Coordinates
.62bf	a2 2b		ldx #$2b	          LDX #ANGBEG-XPOS    ; $2b = address of lower right corner
.62c1	20 52 9e	jsr $9e52	          JSR Get_Graphics_XY
.62c4	20 06 9e	jsr $9e06	          JSR Get_Comma_And_Integer
.62c7	8c 54 11	sty $1154	          STY XRADIUS
.62ca	8d 55 11	sta $1155	          STA XRADIUS+1
.62cd	20 1c 9e	jsr $9e1c	          JSR Get_Byte_Or_Zero
.62d0	e0 02		cpx #$02	          CPX #2
.62d2	90 03		bcc $62d7	          BCC BOX_02
.62d4	4c 28 7d	jmp $7d28	          JMP Error_Illegal_Quantity
.62d7	8e 6c 11	stx $116c	BOX_02    STX FILFLG
.62da	8a		txa		          TXA
.62db	48		pha		          PHA
.62dc	20 89 63	jsr $6389	          JSR BOX_SUB
.62df	68		pla		          PLA
.62e0	d0 1c		bne $62fe	          BNE BOX_12
.62e2	f0 03		beq $62e7	          BEQ BOX_06
.62e4	20 0b 64	jsr $640b	BOX_04    JSR BOX_PAINT
.62e7	20 30 9b	jsr $9b30	BOX_06    JSR Draw_Line
.62ea	ad 4e 11	lda $114e	          LDA ANGCNT
.62ed	d0 f5		bne $62e4	          BNE BOX_04
.62ef	a2 04		ldx #$04	BOX_08    LDX #4
.62f1	bd 5b 11	lda $115b,x	BOX_10    LDA ANGBEG-1,X
.62f4	9d 30 11	sta $1130,x	          STA XPOS-1,X
.62f7	ca		dex		          DEX
.62f8	d0 f7		bne $62f1	          BNE BOX_10
.62fa	8e 6c 11	stx $116c	          STX FILFLG
.62fd	60		rts		          RTS
.62fe	a2 00		ldx #$00	BOX_12    LDX #0
.6300	ad 49 11	lda $1149	          LDA ANGSGN
.6303	4a		lsr a		          LSR A
.6304	90 02		bcc $6308	          BCC BOX_14
.6306	a2 02		ldx #$02	          LDX #2
.6308	bd 60 11	lda $1160,x	BOX_14    LDA XRCOS,X
.630b	8d 5a 11	sta $115a	          STA YDIST2
.630e	bd 61 11	lda $1161,x	          LDA XRCOS+1,X
.6311	8d 5b 11	sta $115b	          STA YDIST2+1
.6314	a9 00		lda #$00	          LDA #0
.6316	a2 03		ldx #$03	          LDX #3
.6318	9d 56 11	sta $1156,x	BOX_16    STA YRADIUS,X
.631b	ca		dex		          DEX
.631c	10 fa		bpl $6318	          BPL BOX_16
.631e	a2 07		ldx #$07	BOX_18    LDX #7
.6320	bd 31 11	lda $1131,x	BOX_20    LDA XPOS,X
.6323	48		pha		          PHA
.6324	ca		dex		          DEX
.6325	10 f9		bpl $6320	          BPL BOX_20
.6327	20 30 9b	jsr $9b30	          JSR Draw_Line
.632a	a2 00		ldx #$00	          LDX #0
.632c	68		pla		BOX_22    PLA
.632d	9d 31 11	sta $1131,x	          STA XPOS,X
.6330	e8		inx		          INX
.6331	e0 08		cpx #$08	          CPX #8
.6333	d0 f7		bne $632c	          BNE BOX_22
.6335	ad 5a 11	lda $115a	BOX_24    LDA YDIST2
.6338	d0 05		bne $633f	          BNE BOX_26
.633a	ce 5b 11	dec $115b	          DEC YDIST2+1
.633d	30 b0		bmi $62ef	          BMI BOX_08
.633f	ce 5a 11	dec $115a	BOX_26    DEC YDIST2
.6342	a2 25		ldx #$25	          LDX #$25 ; '%'
.6344	a0 1b		ldy #$1b	          LDY #$1b
.6346	ad 49 11	lda $1149	          LDA ANGSGN
.6349	4a		lsr a		          LSR A
.634a	90 02		bcc $634e	          BCC BOX_28
.634c	a0 19		ldy #$19	          LDY #$19
.634e	a9 00		lda #$00	BOX_28    LDA #0
.6350	4a		lsr a		BOX_30    LSR A
.6351	48		pha		          PHA
.6352	20 6d 9d	jsr $9d6d	          JSR LAY_Y_ADD_X
.6355	9d 31 11	sta $1131,x	          STA XPOS,X
.6358	98		tya		          TYA
.6359	9d 32 11	sta $1132,x	          STA XPOS+1,X
.635c	68		pla		          PLA
.635d	90 02		bcc $6361	          BCC BOX_32
.635f	09 a0		ora #$a0	          ORA #%10100000 ; $a0
.6361	e8		inx		BOX_32    INX
.6362	e8		inx		          INX
.6363	a0 19		ldy #$19	          LDY #$19
.6365	4e 49 11	lsr $1149	          LSR ANGSGN
.6368	90 02		bcc $636c	          BCC BOX_34
.636a	a0 1b		ldy #$1b	          LDY #$1b
.636c	2e 49 11	rol $1149	BOX_34    ROL ANGSGN
.636f	e0 27		cpx #$27	          CPX #$27 ; '''
.6371	f0 dd		beq $6350	          BEQ BOX_30
.6373	a2 06		ldx #$06	          LDX #6
.6375	0a		asl a		          ASL A
.6376	f0 bd		beq $6335	          BEQ BOX_24
.6378	90 08		bcc $6382	BOX_36    BCC BOX_38
.637a	fe 31 11	inc $1131,x	          INC XPOS,X
.637d	d0 03		bne $6382	          BNE BOX_38
.637f	fe 32 11	inc $1132,x	          INC XPOS+1,X
.6382	0a		asl a		BOX_38    ASL A
.6383	ca		dex		          DEX
.6384	ca		dex		          DEX
.6385	10 f1		bpl $6378	          BPL BOX_36
.6387	30 95		bmi $631e	          BMI BOX_18
.6389					  BOX_SUB
.6389	a0 23		ldy #$23	          LDY #XRADIUS-XPOS   ; $23
.638b	20 74 9a	jsr $9a74	          JSR Sin_Cos_Ang
.638e	a2 1f		ldx #$1f	          LDX #XCIRCL-XPOS    ; $1f
.6390	a0 2b		ldy #$2b	          LDY #ANGBEG-XPOS    ; $2b
.6392	98		tya		BOSU_10   TYA
.6393	48		pha		          PHA
.6394	20 99 9d	jsr $9d99	          JSR LAY_ABS_DIFF
.6397	9d 35 11	sta $1135,x	          STA XDEST,X
.639a	9d 39 11	sta $1139,x	          STA XABS,X
.639d	9d 41 11	sta $1141,x	          STA FCT,X
.63a0	98		tya		          TYA
.63a1	9d 36 11	sta $1136,x	          STA XDEST+1,X
.63a4	9d 3a 11	sta $113a,x	          STA XABS+1,X
.63a7	9d 42 11	sta $1142,x	          STA FCT+1,X
.63aa	68		pla		          PLA
.63ab	a8		tay		          TAY
.63ac	20 6d 9d	jsr $9d6d	          JSR LAY_Y_ADD_X
.63af	9d 31 11	sta $1131,x	          STA XPOS,X
.63b2	98		tya		          TYA
.63b3	9d 32 11	sta $1132,x	          STA XPOS+1,X
.63b6	a0 2d		ldy #$2d	          LDY #ANGEND-XPOS    ; $2d
.63b8	e8		inx		          INX
.63b9	e8		inx		          INX
.63ba	e0 21		cpx #$21	          CPX #YCIRCL-XPOS    ; $21
.63bc	f0 d4		beq $6392	          BEQ BOSU_10
.63be	a9 90		lda #$90	          LDA #$90
.63c0	20 f3 9a	jsr $9af3	          JSR ANG_DIST
.63c3	ad 49 11	lda $1149	          LDA ANGSGN
.63c6	29 03		and #$03	          AND #%00000011     ; $03
.63c8	8d 49 11	sta $1149	          STA ANGSGN
.63cb	aa		tax		          TAX
.63cc	bd ed 63	lda $63ed,x	          LDA BoxTab,X
.63cf	20 0b 64	jsr $640b	          JSR BOX_PAINT
.63d2	20 f2 9d	jsr $9df2	          JSR XY_DEST_To_POS
.63d5	ad 4e 11	lda $114e	          LDA ANGCNT
.63d8	20 0b 64	jsr $640b	          JSR BOX_PAINT
.63db	ae 49 11	ldx $1149	          LDX ANGSGN
.63de	bd ed 63	lda $63ed,x	          LDA BoxTab,X
.63e1	29 f0		and #$f0	          AND #%11110000     ; $f0
.63e3	8d 4f 11	sta $114f	          STA ANGCNT+1
.63e6	bd f1 63	lda $63f1,x	          LDA AngTab,X
.63e9	8d 4e 11	sta $114e	          STA ANGCNT
.63ec	60		rts		          RTS
>63ed	be e4 41 1b			BoxTab    .BYTE $be,$e4,$41,$1b
>63f1	41 1b be e4			AngTab    .BYTE $41,$1b,$be,$e4
>63f5	46 52 45 44 20 42 0d		          .TEXT "FRED B\r"    ; Fred Bowen
>63fc	54 45 52 52 59 20 52 0d		          .TEXT "TERRY R\r"   ; Terry Ryan
>6404	4d 49 4b 45 20 49 0d		          .TEXT "MIKE I\r"    ; Mike Isgur
.640b					  BOX_PAINT
.640b	20 67 67	jsr $6767	          JSR anglpt
.640e	a2 04		ldx #$04	          LDX #4
.6410	bd 32 11	lda $1132,x	BOPA_10   LDA XPOS+1,X
.6413	0a		asl a		          ASL A
.6414	7e 32 11	ror $1132,x	          ROR XPOS+1,X
.6417	7e 31 11	ror $1131,x	          ROR XPOS,X
.641a	90 08		bcc $6424	          BCC BOPA_20
.641c	fe 31 11	inc $1131,x	          INC XPOS,X
.641f	d0 03		bne $6424	          BNE BOPA_20
.6421	fe 32 11	inc $1132,x	          INC XPOS+1,X
.6424	e8		inx		BOPA_20   INX
.6425	e8		inx		          INX
.6426	e0 06		cpx #$06	          CPX #6
.6428	f0 e6		beq $6410	          BEQ BOPA_10
.642a	60		rts		          RTS
.642b					  BASIC_SSHAPE
.642b	20 74 a0	jsr $a074	          JSR Assert_Graphics_Mem
.642e	20 af 7a	jsr $7aaf	          JSR Parse_Name
.6431	8d 03 ff	sta $ff03	          STA MMU_LCRC
.6434	8d 5f 11	sta $115f	          STA ANGEND+1
.6437	8c 60 11	sty $1160	          STY XRCOS
.643a	24 0f		bit $0f		          BIT VALTYP
.643c	30 03		bmi $6441	          BMI SSHA_02
.643e	4c e7 77	jmp $77e7	          JMP TYPE_MISMATCH
.6441	a2 28		ldx #$28	SSHA_02   LDX #$28
.6443	20 6d 9e	jsr $9e6d	          JSR Get_Comma_And_Coordinates
.6446	a2 04		ldx #$04	          LDX #4
.6448	20 52 9e	jsr $9e52	          JSR Get_Graphics_XY
.644b	a2 2a		ldx #$2a	          LDX #$2a
.644d	a0 06		ldy #$06	          LDY #6
.644f	a9 02		lda #$02	          LDA #2
.6451	85 8e		sta $8e		          STA VTEMPA
.6453	20 99 9d	jsr $9d99	SSHA_04   JSR LAY_ABS_DIFF
.6456	aa		tax		          TAX
.6457	98		tya		          TYA
.6458	48		pha		          PHA
.6459	a4 8e		ldy $8e		          LDY VTEMPA
.645b	20 f9 9d	jsr $9df9	          JSR DEST_To_POS
.645e	90 0c		bcc $646c	          BCC SSHA_06
.6460	b9 59 11	lda $1159,y	          LDA ROTANG+1,Y
.6463	99 31 11	sta $1131,y	          STA XPOS,Y
.6466	b9 5a 11	lda $115a,y	          LDA YDIST2,Y
.6469	99 32 11	sta $1132,y	          STA XPOS+1,Y
.646c	8a		txa		SSHA_06   TXA
.646d	99 59 11	sta $1159,y	          STA ROTANG+1,Y
.6470	99 db 03	sta $03db,y	          STA SAVSIZ,Y
.6473	68		pla		          PLA
.6474	99 5a 11	sta $115a,y	          STA YDIST2,Y
.6477	99 dc 03	sta $03dc,y	          STA SAVSIZ+1,Y
.647a	a2 28		ldx #$28	          LDX #$28
.647c	a0 04		ldy #$04	          LDY #4
.647e	c6 8e		dec $8e		          DEC VTEMPA
.6480	c6 8e		dec $8e		          DEC VTEMPA
.6482	f0 cf		beq $6453	          BEQ SSHA_04
.6484	a0 ff		ldy #$ff	          LDY #$ff
.6486	8c 55 11	sty $1155	          STY XRADIUS+1
.6489	ad 31 11	lda $1131	          LDA XPOS
.648c	8d 5d 11	sta $115d	          STA ANGBEG+1
.648f	ad 32 11	lda $1132	          LDA XPOS+1
.6492	8d 5e 11	sta $115e	          STA ANGEND
.6495	98		tya		          TYA
.6496	20 90 86	jsr $8690	          JSR Allocate_String_A
.6499	8d 03 ff	sta $ff03	          STA MMU_LCRC
.649c	20 e3 9c	jsr $9ce3	SSHA_08   JSR getpos
.649f	b1 8c		lda ($8c),y	          LDA (GRAPNT),Y
.64a1	90 0e		bcc $64b1	          BCC SSHA_12
.64a3	ad 31 11	lda $1131	          LDA XPOS
.64a6	24 d8		bit $d8		          BIT GRAPHM
.64a8	10 02		bpl $64ac	          BPL SSHA_10
.64aa	38		sec		          SEC
.64ab	2a		rol a		          ROL A
.64ac	29 07		and #$07	SSHA_10   AND #%00000111 ; $07
.64ae	aa		tax		          TAX
.64af	a9 00		lda #$00	          LDA #0
.64b1	24 d8		bit $d8		SSHA_12   BIT GRAPHM
.64b3	10 01		bpl $64b6	          BPL SSHA_14
.64b5	ca		dex		          DEX
.64b6	8e 61 11	stx $1161	SSHA_14   STX XRCOS+1
.64b9	0a		asl a		SSHA_16   ASL A
.64ba	ca		dex		          DEX
.64bb	10 fc		bpl $64b9	          BPL SSHA_16
.64bd	6a		ror a		          ROR A
.64be	85 8e		sta $8e		          STA VTEMPA
.64c0	a9 08		lda #$08	          LDA #8
.64c2	24 d8		bit $d8		          BIT GRAPHM
.64c4	10 01		bpl $64c7	          BPL SSHA_18
.64c6	4a		lsr a		          LSR A
.64c7	18		clc		SSHA_18   CLC
.64c8	6d 31 11	adc $1131	          ADC XPOS
.64cb	8d 31 11	sta $1131	          STA XPOS
.64ce	90 03		bcc $64d3	          BCC SSHA_20
.64d0	ee 32 11	inc $1132	          INC XPOS+1
.64d3	20 e3 9c	jsr $9ce3	SSHA_20   JSR getpos
.64d6	a9 00		lda #$00	          LDA #0
.64d8	b0 02		bcs $64dc	          BCS SSHA_22
.64da	b1 8c		lda ($8c),y	          LDA (GRAPNT),Y
.64dc	85 8f		sta $8f		SSHA_22   STA VTEMPA+1
.64de	ae 61 11	ldx $1161	          LDX XRCOS+1
.64e1	4a		lsr a		SSHA_24   LSR A
.64e2	e8		inx		          INX
.64e3	e0 08		cpx #$08	          CPX #8
.64e5	d0 fa		bne $64e1	          BNE SSHA_24
.64e7	05 8e		ora $8e		          ORA VTEMPA
.64e9	ee 55 11	inc $1155	          INC XRADIUS+1
.64ec	ac 55 11	ldy $1155	          LDY XRADIUS+1
.64ef	c0 fc		cpy #$fc	          CPY #$fc
.64f1	90 03		bcc $64f6	          BCC SSHA_26
.64f3	4c ed a5	jmp $a5ed	          JMP String_Too_Long
.64f6	8d 04 ff	sta $ff04	SSHA_26      STA MMU_LCRD
.64f9	91 64		sta ($64),y	          STA (FAC1_M1),Y
.64fb	8d 03 ff	sta $ff03	          STA MMU_LCRC
.64fe	ae 61 11	ldx $1161	          LDX XRCOS+1
.6501	ad 59 11	lda $1159	          LDA ROTANG+1
.6504	38		sec		          SEC
.6505	24 d8		bit $d8		          BIT GRAPHM
.6507	10 03		bpl $650c	          BPL SSHA_28
.6509	e9 04		sbc #$04	          SBC #4
>650b	2c				          .BYTE $2C ;BIT
.650c	e9 08		sbc #$08	SSHA_28   SBC #8
.650e	8d 59 11	sta $1159	          STA ROTANG+1
.6511	a5 8f		lda $8f		          LDA VTEMPA+1
.6513	b0 a4		bcs $64b9	          BCS SSHA_16
.6515	ce 5a 11	dec $115a	          DEC YDIST2
.6518	10 9f		bpl $64b9	          BPL SSHA_16
.651a	ae 5b 11	ldx $115b	          LDX YDIST2+1
.651d	d0 48		bne $6567	          BNE SSHA_34
.651f	ce 5c 11	dec $115c	          DEC ANGBEG
.6522	10 43		bpl $6567	          BPL SSHA_34
.6524	24 d8		bit $d8		          BIT GRAPHM
.6526	10 06		bpl $652e	          BPL SSHA_30
.6528	0e db 03	asl $03db	          ASL SAVSIZ
.652b	2e dc 03	rol $03dc	          ROL SAVSIZ+1
.652e	a2 00		ldx #$00	SSHA_30   LDX #0
.6530	bd db 03	lda $03db,x	SSHA_32   LDA SAVSIZ,X
.6533	c8		iny		          INY
.6534	8d 04 ff	sta $ff04	          STA MMU_LCRD
.6537	91 64		sta ($64),y	          STA (FAC1_M1),Y
.6539	8d 03 ff	sta $ff03	          STA MMU_LCRC
.653c	e8		inx		          INX
.653d	e0 04		cpx #$04	          CPX #4
.653f	d0 ef		bne $6530	          BNE SSHA_32
.6541	c8		iny		          INY
.6542	8c db 03	sty $03db	          STY SAVSIZ
.6545	a5 64		lda $64		          LDA FAC1_M1
.6547	8d dc 03	sta $03dc	          STA SAVSIZ+1
.654a	a5 65		lda $65		          LDA FAC1_M2
.654c	8d dd 03	sta $03dd	          STA SAVSIZ+2
.654f	a9 db		lda #$db	          LDA #$db
.6551	85 66		sta $66		          STA FAC1_M3
.6553	a9 03		lda #$03	          LDA #3
.6555	85 67		sta $67		          STA FAC1_M4
.6557	ad 5f 11	lda $115f	          LDA ANGEND+1
.655a	85 4b		sta $4b		          STA FORPNT
.655c	ad 60 11	lda $1160	          LDA XRCOS
.655f	85 4c		sta $4c		          STA FORPNT+1
.6561	20 94 54	jsr $5494	          JSR Assing_String_From_Variable
.6564	4c f2 9d	jmp $9df2	          JMP XY_DEST_To_POS
.6567	ce 5b 11	dec $115b	SSHA_34   DEC YDIST2+1
.656a	ee 33 11	inc $1133	          INC YPOS
.656d	d0 03		bne $6572	          BNE SSHA_36
.656f	ee 34 11	inc $1134	          INC YPOS+1
.6572	ad 5d 11	lda $115d	SSHA_36   LDA ANGBEG+1
.6575	8d 31 11	sta $1131	          STA XPOS
.6578	ad 5e 11	lda $115e	          LDA ANGEND
.657b	8d 32 11	sta $1132	          STA XPOS+1
.657e	ad db 03	lda $03db	          LDA SAVSIZ
.6581	8d 59 11	sta $1159	          STA ROTANG+1
.6584	ad dc 03	lda $03dc	          LDA SAVSIZ+1
.6587	8d 5a 11	sta $115a	          STA YDIST2
.658a	4c 9c 64	jmp $649c	          JMP SSHA_08
.658d					  BASIC_GSHAPE
.658d	20 74 a0	jsr $a074	          JSR Assert_Graphics_Mem
.6590	20 7b 87	jsr $877b	          JSR Eval_String
.6593	8d 03 ff	sta $ff03	          STA MMU_LCRC
.6596	8d 53 11	sta $1153	          STA YCIRCL+1
.6599	86 26		stx $26		          STX INDEXB
.659b	84 27		sty $27		          STY INDEXB+1
.659d	a2 04		ldx #$04	          LDX #4
.659f	20 52 9e	jsr $9e52	          JSR Get_Graphics_XY
.65a2	20 1c 9e	jsr $9e1c	          JSR Get_Byte_Or_Zero
.65a5	e0 05		cpx #$05	          CPX #5
.65a7	90 03		bcc $65ac	          BCC GSHA_02
.65a9	4c 28 7d	jmp $7d28	          JMP Error_Illegal_Quantity
.65ac	8e 54 11	stx $1154	GSHA_02   STX XRADIUS
.65af	a2 03		ldx #$03	          LDX #3
.65b1	ac 53 11	ldy $1153	          LDY YCIRCL+1
.65b4	c0 05		cpy #$05	          CPY #5
.65b6	b0 01		bcs $65b9	          BCS GSHA_04
.65b8	60		rts		          RTS
.65b9	88		dey		GSHA_04   DEY
.65ba	a9 26		lda #$26	          LDA #$26 ; '&'
.65bc	20 ab 03	jsr $03ab	          JSR Fetch_1
.65bf	8d 03 ff	sta $ff03	          STA MMU_LCRC
.65c2	9d 59 11	sta $1159,x	          STA ROTANG+1,X
.65c5	ca		dex		          DEX
.65c6	10 f1		bpl $65b9	          BPL GSHA_04
.65c8	8e 55 11	stx $1155	          STX XRADIUS+1
.65cb	20 f2 9d	jsr $9df2	          JSR XY_DEST_To_POS
.65ce	ad 59 11	lda $1159	          LDA ROTANG+1
.65d1	8d 5d 11	sta $115d	          STA ANGBEG+1
.65d4	ad 5a 11	lda $115a	          LDA YDIST2
.65d7	8d 5e 11	sta $115e	          STA ANGEND
.65da	a9 08		lda #$08	GSHA_06   LDA #8
.65dc	8d 69 11	sta $1169	          STA BITCNT
.65df	ee 55 11	inc $1155	          INC XRADIUS+1
.65e2	ac 55 11	ldy $1155	          LDY XRADIUS+1
.65e5	a9 26		lda #$26	          LDA #$26 ; '&'
.65e7	20 ab 03	jsr $03ab	          JSR Fetch_1
.65ea	8d 03 ff	sta $ff03	          STA MMU_LCRC
.65ed	8d 57 11	sta $1157	          STA YRADIUS+1
.65f0	20 49 9c	jsr $9c49	GSHA_08   JSR Get_Pixel
.65f3	8d 56 11	sta $1156	          STA YRADIUS
.65f6	0e 57 11	asl $1157	          ASL YRADIUS+1
.65f9	2a		rol a		          ROL A
.65fa	ce 69 11	dec $1169	          DEC BITCNT
.65fd	24 d8		bit $d8		          BIT GRAPHM
.65ff	10 07		bpl $6608	          BPL GSHA_10
.6601	0e 57 11	asl $1157	          ASL YRADIUS+1
.6604	2a		rol a		          ROL A
.6605	ce 69 11	dec $1169	          DEC BITCNT
.6608	ae 54 11	ldx $1154	GSHA_10   LDX XRADIUS
.660b	e0 03		cpx #$03	          CPX #3
.660d	90 0c		bcc $661b	          BCC GSHA_14
.660f	f0 05		beq $6616	          BEQ GSHA_12
.6611	4d 56 11	eor $1156	          EOR YRADIUS
.6614	b0 11		bcs $6627	          BCS GSHA_18
.6616	2d 56 11	and $1156	GSHA_12   AND YRADIUS
.6619	b0 0c		bcs $6627	          BCS GSHA_18
.661b	e0 01		cpx #$01	GSHA_14   CPX #1
.661d	90 08		bcc $6627	          BCC GSHA_18
.661f	f0 04		beq $6625	          BEQ GSHA_16
.6621	0d 56 11	ora $1156	          ORA YRADIUS
>6624	2c				          .BYTE $2C ;BIT
.6625	49 ff		eor #$ff	GSHA_16   EOR #%11111111 ; $ff
.6627	29 03		and #$03	GSHA_18   AND #%00000011 ; $03
.6629	24 d8		bit $d8		          BIT GRAPHM
.662b	30 02		bmi $662f	          BMI GSHA_20
.662d	29 01		and #$01	          AND #%00000001 ; $01
.662f	85 83		sta $83		GSHA_20   STA COLSEL
.6631	20 19 9c	jsr $9c19	          JSR Set_Pixel
.6634	ee 31 11	inc $1131	          INC XPOS
.6637	d0 03		bne $663c	          BNE GSHA_22
.6639	ee 32 11	inc $1132	          INC XPOS+1
.663c	38		sec		GSHA_22   SEC
.663d	ad 5d 11	lda $115d	          LDA ANGBEG+1
.6640	24 d8		bit $d8		          BIT GRAPHM
.6642	10 03		bpl $6647	          BPL GSHA_24
.6644	e9 02		sbc #$02	          SBC #2
>6646	2c				          .BYTE $2C ;BIT
.6647	e9 01		sbc #$01	GSHA_24   SBC #1
.6649	8d 5d 11	sta $115d	          STA ANGBEG+1
.664c	ad 5e 11	lda $115e	          LDA ANGEND
.664f	e9 00		sbc #$00	          SBC #0
.6651	8d 5e 11	sta $115e	          STA ANGEND
.6654	b0 2d		bcs $6683	          BCS GSHA_30
.6656	a2 01		ldx #$01	          LDX #1
.6658	bd 59 11	lda $1159,x	GSHA_26   LDA ROTANG+1,X
.665b	9d 5d 11	sta $115d,x	          STA ANGBEG+1,X
.665e	bd 35 11	lda $1135,x	          LDA XDEST,X
.6661	9d 31 11	sta $1131,x	          STA XPOS,X
.6664	ca		dex		          DEX
.6665	10 f1		bpl $6658	          BPL GSHA_26
.6667	ee 33 11	inc $1133	          INC YPOS
.666a	d0 03		bne $666f	          BNE GSHA_28
.666c	ee 34 11	inc $1134	          INC YPOS+1
.666f	38		sec		GSHA_28   SEC
.6670	ad 5b 11	lda $115b	          LDA YDIST2+1
.6673	e9 01		sbc #$01	          SBC #1
.6675	8d 5b 11	sta $115b	          STA YDIST2+1
.6678	ad 5c 11	lda $115c	          LDA ANGBEG
.667b	e9 00		sbc #$00	          SBC #0
.667d	8d 5c 11	sta $115c	          STA ANGBEG
.6680	b0 09		bcs $668b	          BCS GSHA_32
.6682	60		rts		          RTS
.6683	ad 69 11	lda $1169	GSHA_30   LDA BITCNT
.6686	f0 03		beq $668b	          BEQ GSHA_32
.6688	4c f0 65	jmp $65f0	          JMP GSHA_08
.668b	4c da 65	jmp $65da	GSHA_32   JMP GSHA_06
.668e					  BASIC_CIRCLE
.668e	20 2f 9e	jsr $9e2f	          JSR Assert_Color_Source
.6691	a2 1f		ldx #$1f	          LDX #$1f
.6693	20 52 9e	jsr $9e52	          JSR Get_Graphics_XY
.6696	20 06 9e	jsr $9e06	          JSR Get_Comma_And_Integer
.6699	8c 54 11	sty $1154	          STY XRADIUS
.669c	8d 55 11	sta $1155	          STA XRADIUS+1
.669f	20 06 9e	jsr $9e06	          JSR Get_Comma_And_Integer
.66a2	8c 56 11	sty $1156	          STY YRADIUS
.66a5	b0 11		bcs $66b8	          BCS CIRC_10
.66a7	ad 54 11	lda $1154	          LDA XRADIUS
.66aa	8d 56 11	sta $1156	          STA YRADIUS
.66ad	ad 55 11	lda $1155	          LDA XRADIUS+1
.66b0	24 d8		bit $d8		          BIT GRAPHM
.66b2	10 04		bpl $66b8	          BPL CIRC_10
.66b4	0e 56 11	asl $1156	          ASL YRADIUS
.66b7	2a		rol a		          ROL A
.66b8	8d 57 11	sta $1157	CIRC_10   STA YRADIUS+1
.66bb	a2 23		ldx #$23	          LDX #$23 ; '#'
.66bd	20 4a 9d	jsr $9d4a	          JSR Scale_XY
.66c0	ea		nop		          NOP
.66c1	ea		nop		          NOP
.66c2	ea		nop		          NOP
.66c3	ea		nop		          NOP
.66c4	ea		nop		          NOP
.66c5	20 06 9e	jsr $9e06	          JSR Get_Comma_And_Integer
.66c8	8c 5c 11	sty $115c	          STY ANGBEG
.66cb	8d 5d 11	sta $115d	          STA ANGBEG+1
.66ce	20 06 9e	jsr $9e06	          JSR Get_Comma_And_Integer
.66d1	8c 5e 11	sty $115e	          STY ANGEND
.66d4	8d 5f 11	sta $115f	          STA ANGEND+1
.66d7	20 06 9e	jsr $9e06	          JSR Get_Comma_And_Integer
.66da	85 77		sta $77		          STA TEMP_A
.66dc	98		tya		          TYA
.66dd	a4 77		ldy $77		          LDY TEMP_A
.66df	20 77 9a	jsr $9a77	          JSR Sin_Cos_AY
.66e2	a2 2d		ldx #$2d	          LDX #$2d ; '-'
.66e4	a0 2b		ldy #$2b	          LDY #$2b ; '+'
.66e6	20 7c 9d	jsr $9d7c	          JSR LAY_Y_SUB_X
.66e9	90 0e		bcc $66f9	          BCC CIRC_20
.66eb	a9 68		lda #$68	          LDA #$68
.66ed	a0 01		ldy #$01	          LDY #1
.66ef	20 70 9d	jsr $9d70	          JSR LAY_ADD_X
.66f2	9d 31 11	sta $1131,x	          STA XPOS,X
.66f5	98		tya		          TYA
.66f6	9d 32 11	sta $1132,x	          STA XPOS+1,X
.66f9	a2 03		ldx #$03	CIRC_20   LDX #3
.66fb	bd 54 11	lda $1154,x	CIRC_30   LDA XRADIUS,X
.66fe	9d 58 11	sta $1158,x	          STA ROTANG,X
.6701	ca		dex		          DEX
.6702	10 f7		bpl $66fb	          BPL CIRC_30
.6704	a9 90		lda #$90	          LDA #$90
.6706	20 f3 9a	jsr $9af3	          JSR ANG_DIST
.6709	a2 07		ldx #$07	          LDX #7
.670b	bd 54 11	lda $1154,x	CIRC_40   LDA XRADIUS,X
.670e	9d 60 11	sta $1160,x	          STA XRCOS,X
.6711	ca		dex		          DEX
.6712	10 f7		bpl $670b	          BPL CIRC_40
.6714	20 50 67	jsr $6750	          JSR CIRC_SUB
.6717	20 f2 9d	jsr $9df2	          JSR XY_DEST_To_POS
.671a	a2 02		ldx #$02	          LDX #2
.671c	20 1e 9e	jsr $9e1e	          JSR Get_Byte_Or_Void
.671f	8a		txa		          TXA
.6720	d0 03		bne $6725	          BNE CIRC_50
.6722	4c 28 7d	jmp $7d28	          JMP Error_Illegal_Quantity
.6725	8e 20 12	stx $1220	CIRC_50   STX ARC_SEG
.6728	18		clc		          CLC
.6729	ad 20 12	lda $1220	CIRC_60   LDA ARC_SEG
.672c	6d 5c 11	adc $115c	          ADC ANGBEG
.672f	8d 5c 11	sta $115c	          STA ANGBEG
.6732	90 03		bcc $6737	          BCC CIRC_70
.6734	ee 5d 11	inc $115d	          INC ANGBEG+1
.6737	a2 2d		ldx #$2d	CIRC_70   LDX #$2d ; '-'
.6739	a0 2b		ldy #$2b	          LDY #$2b ; '+'
.673b	20 7c 9d	jsr $9d7c	          JSR LAY_Y_SUB_X
.673e	b0 08		bcs $6748	          BCS CIRC_80
.6740	20 50 67	jsr $6750	          JSR CIRC_SUB
.6743	20 30 9b	jsr $9b30	          JSR Draw_Line
.6746	90 e1		bcc $6729	          BCC CIRC_60
.6748	a0 2d		ldy #$2d	CIRC_80   LDY #$2d ; '-'
.674a	20 52 67	jsr $6752	          JSR CIRC_SUB_Y
.674d	4c 30 9b	jmp $9b30	          JMP Draw_Line
.6750					  CIRC_SUB
.6750	a0 2b		ldy #$2b	          LDY #ANGBEG-XPOS    ; $2b
.6752					  CIRC_SUB_Y
.6752	20 74 9a	jsr $9a74	          JSR Sin_Cos_Ang
.6755	a2 07		ldx #$07	          LDX #7
.6757	bd 60 11	lda $1160,x	CISU_10   LDA XRCOS,X
.675a	9d 54 11	sta $1154,x	          STA XRADIUS,X
.675d	ca		dex		          DEX
.675e	10 f7		bpl $6757	          BPL CISU_10
.6760	a9 50		lda #$50	          LDA #$50
.6762	20 f3 9a	jsr $9af3	          JSR ANG_DIST
.6765	a9 10		lda #$10	          LDA #16
.6767					  anglpt
.6767	8d 4e 11	sta $114e	          STA ANGCNT
.676a	a0 1f		ldy #$1f	          LDY #$1f
.676c	a2 23		ldx #$23	          LDX #$23 ; '#'
.676e	0e 4f 11	asl $114f	anglpt_1  ASL ANGCNT+1
.6771	2e 4e 11	rol $114e	          ROL ANGCNT
.6774	20 6b 9d	jsr $9d6b	          JSR LAY_SUB_ADD
.6777	e8		inx		          INX
.6778	e8		inx		          INX
.6779	0e 4f 11	asl $114f	          ASL ANGCNT+1
.677c	2e 4e 11	rol $114e	          ROL ANGCNT
.677f	20 67 9d	jsr $9d67	          JSR LAY_ADD_SUB
.6782	48		pha		          PHA
.6783	98		tya		          TYA
.6784	48		pha		          PHA
.6785	a0 21		ldy #$21	          LDY #$21 ; '!'
.6787	e8		inx		          INX
.6788	e8		inx		          INX
.6789	e0 27		cpx #$27	          CPX #$27 ; '''
.678b	f0 e1		beq $676e	          BEQ anglpt_1
.678d	a2 03		ldx #$03	          LDX #3
.678f	68		pla		anglpt_2  PLA
.6790	9d 35 11	sta $1135,x	          STA XDEST,X
.6793	ca		dex		          DEX
.6794	10 f9		bpl $678f	          BPL anglpt_2
.6796	60		rts		          RTS
.6797					  BASIC_DRAW
.6797	20 74 a0	jsr $a074	          JSR Assert_Graphics_Mem
.679a	a2 01		ldx #$01	          LDX #1              ; default = foreground color
.679c	86 83		stx $83		          STX COLSEL
.679e	20 86 03	jsr $0386	          JSR CHRGOT
.67a1	c9 a4		cmp #$a4	          CMP #$a4            ; TO token
.67a3	f0 0b		beq $67b0	          BEQ DRAW_10
.67a5	20 32 9e	jsr $9e32	          JSR Get_Color_Source
.67a8	20 86 03	jsr $0386	          JSR CHRGOT
.67ab	d0 03		bne $67b0	          BNE DRAW_10
.67ad	4c fb 9b	jmp $9bfb	          JMP Double_Pixel
.67b0	20 86 03	jsr $0386	DRAW_10   JSR CHRGOT
.67b3	c9 2c		cmp #$2c	          CMP #','
.67b5	f0 05		beq $67bc	          BEQ DRAW_20
.67b7	c9 a4		cmp #$a4	          CMP #$a4            ; TO token
.67b9	f0 01		beq $67bc	          BEQ DRAW_20
.67bb	60		rts		          RTS
.67bc	48		pha		DRAW_20   PHA
.67bd	20 80 03	jsr $0380	          JSR CHRGET
.67c0	a2 04		ldx #$04	          LDX #4
.67c2	20 70 9e	jsr $9e70	          JSR Get_Coordinates
.67c5	68		pla		          PLA
.67c6	10 06		bpl $67ce	          BPL DRAW_30
.67c8	20 30 9b	jsr $9b30	          JSR Draw_Line
.67cb	4c b0 67	jmp $67b0	          JMP DRAW_10
.67ce	20 f2 9d	jsr $9df2	DRAW_30   JSR XY_DEST_To_POS
.67d1	20 fb 9b	jsr $9bfb	          JSR Double_Pixel
.67d4	4c b0 67	jmp $67b0	          JMP DRAW_10
.67d7					  BASIC_CHAR
.67d7	20 32 9e	jsr $9e32	          JSR Get_Color_Source
.67da	a2 29		ldx #$29	          LDX #$29 ; ')'
.67dc	a0 1a		ldy #$1a	          LDY #$1a
.67de	a5 d8		lda $d8		          LDA GRAPHM
.67e0	d0 05		bne $67e7	          BNE CHAR_10
.67e2	20 ed ff	jsr $ffed	          JSR K_SCRORG
.67e5	e8		inx		          INX
.67e6	c8		iny		          INY
.67e7	8e 5e 11	stx $115e	CHAR_10   STX ANGEND
.67ea	8c 5f 11	sty $115f	          STY ANGEND+1
.67ed	20 09 88	jsr $8809	          JSR Comma_And_Byte
.67f0	ec 5e 11	cpx $115e	          CPX ANGEND
.67f3	b0 0b		bcs $6800	          BCS CHAR_15
.67f5	8e 5e 11	stx $115e	          STX ANGEND
.67f8	20 09 88	jsr $8809	          JSR Comma_And_Byte
.67fb	ec 5f 11	cpx $115f	          CPX ANGEND+1
.67fe	90 03		bcc $6803	          BCC CHAR_20
.6800	4c 28 7d	jmp $7d28	CHAR_15   JMP Error_Illegal_Quantity
.6803	8e 5f 11	stx $115f	CHAR_20   STX ANGEND+1
.6806	20 86 03	jsr $0386	          JSR CHRGOT
.6809	d0 04		bne $680f	          BNE CHAR_25
.680b	a9 00		lda #$00	          LDA #0
.680d	f0 06		beq $6815	          BEQ CHAR_30
.680f	20 5c 79	jsr $795c	CHAR_25   JSR Need_Comma
.6812	20 7b 87	jsr $877b	          JSR Eval_String
.6815	8d 03 ff	sta $ff03	CHAR_30   STA MMU_LCRC
.6818	8d 6e 11	sta $116e	          STA NUMCNT
.681b	98		tya		          TYA
.681c	48		pha		          PHA
.681d	8a		txa		          TXA
.681e	48		pha		          PHA
.681f	20 1c 9e	jsr $9e1c	          JSR Get_Byte_Or_Zero
.6822	8a		txa		          TXA
.6823	6a		ror a		          ROR A
.6824	6e 3d 11	ror $113d	          ROR XSGN
.6827	68		pla		          PLA
.6828	85 24		sta $24		          STA INDEXA
.682a	68		pla		          PLA
.682b	85 25		sta $25		          STA INDEXA+1
.682d	a5 d8		lda $d8		          LDA GRAPHM
.682f	d0 32		bne $6863	          BNE CHAR_50
.6831	ae 5f 11	ldx $115f	          LDX ANGEND+1
.6834	ac 5e 11	ldy $115e	          LDY ANGEND
.6837	18		clc		          CLC
.6838	20 82 7e	jsr $7e82	          JSR J_PLOT
.683b	a0 00		ldy #$00	          LDY #0
.683d	2c 3d 11	bit $113d	          BIT XSGN
.6840	10 05		bpl $6847	          BPL CHAR_35
.6842	a9 12		lda #$12	          LDA #$12
.6844	20 88 7e	jsr $7e88	          JSR J_PRINT
.6847	cc 6e 11	cpy $116e	CHAR_35   CPY NUMCNT
.684a	f0 0c		beq $6858	          BEQ CHAR_40
.684c	20 b7 03	jsr $03b7	          JSR Get_INDEXA_1
.684f	20 45 a8	jsr $a845	          JSR Map_IO
.6852	20 0c c0	jsr $c00c	          JSR E_PRINT
.6855	c8		iny		          INY
.6856	d0 ef		bne $6847	          BNE CHAR_35
.6858	2c 3d 11	bit $113d	CHAR_40   BIT XSGN
.685b	10 05		bpl $6862	          BPL CHAR_45
.685d	a9 92		lda #$92	          LDA #$92
.685f	20 88 7e	jsr $7e88	          JSR J_PRINT
.6862	60		rts		CHAR_45   RTS
.6863	20 74 a0	jsr $a074	CHAR_50   JSR Assert_Graphics_Mem
.6866	ad ec 11	lda $11ec	          LDA CHARGEN_GRAF
.6869	8d 68 11	sta $1168	          STA CHRPAG
.686c	a5 86		lda $86		          LDA FG_COL
.686e	aa		tax		          TAX
.686f	48		pha		          PHA
.6870	a5 83		lda $83		          LDA COLSEL
.6872	48		pha		          PHA
.6873	24 d8		bit $d8		          BIT GRAPHM
.6875	10 0e		bpl $6885	          BPL CHAR_55
.6877	68		pla		          PLA
.6878	f0 16		beq $6890	          BEQ CHAR_60
.687a	4a		lsr a		          LSR A
.687b	f0 13		beq $6890	          BEQ CHAR_60
.687d	a6 84		ldx $84		          LDX MULCO1
.687f	90 0f		bcc $6890	          BCC CHAR_60
.6881	a6 85		ldx $85		          LDX MULCO2
.6883	b0 0b		bcs $6890	          BCS CHAR_60
.6885	a6 86		ldx $86		CHAR_55   LDX FG_COL
.6887	68		pla		          PLA
.6888	d0 06		bne $6890	          BNE CHAR_60
.688a	20 45 a8	jsr $a845	          JSR Map_IO
.688d	ae 21 d0	ldx $d021	          LDX VIC_BG_COL
.6890	86 86		stx $86		CHAR_60   STX FG_COL
.6892	ae 5f 11	ldx $115f	          LDX ANGEND+1
.6895	a0 00		ldy #$00	          LDY #0
.6897	8c 60 11	sty $1160	          STY XRCOS
.689a	ac 60 11	ldy $1160	CHAR_65   LDY XRCOS
.689d	ee 60 11	inc $1160	          INC XRCOS
.68a0	20 b7 03	jsr $03b7	          JSR Get_INDEXA_1
.68a3	8d 03 ff	sta $ff03	          STA MMU_LCRC
.68a6	ce 6e 11	dec $116e	          DEC NUMCNT
.68a9	30 2c		bmi $68d7	          BMI CHAR_90
.68ab	c9 0e		cmp #$0e	          CMP #14
.68ad	d0 05		bne $68b4	          BNE CHAR_70
.68af	ad eb 11	lda $11eb	          LDA CHARGEN_TEXT
.68b2	d0 07		bne $68bb	          BNE CHAR_75
.68b4	c9 8e		cmp #$8e	CHAR_70   CMP #$8e
.68b6	d0 08		bne $68c0	          BNE CHAR_80
.68b8	ad ec 11	lda $11ec	          LDA CHARGEN_GRAF
.68bb	8d 68 11	sta $1168	CHAR_75   STA CHRPAG
.68be	d0 09		bne $68c9	          BNE CHAR_85
.68c0	ac 5e 11	ldy $115e	CHAR_80   LDY ANGEND
.68c3	20 db 68	jsr $68db	          JSR Display_Character
.68c6	ee 5e 11	inc $115e	          INC ANGEND
.68c9	c0 27		cpy #$27	CHAR_85   CPY #$27 ; '''
.68cb	90 cd		bcc $689a	          BCC CHAR_65
.68cd	a0 00		ldy #$00	          LDY #0
.68cf	8c 5e 11	sty $115e	          STY ANGEND
.68d2	e8		inx		          INX
.68d3	e0 18		cpx #$18	          CPX #$18
.68d5	90 c3		bcc $689a	          BCC CHAR_65
.68d7	68		pla		CHAR_90   PLA
.68d8	85 86		sta $86		          STA FG_COL
.68da	60		rts		          RTS
.68db					  Display_Character
.68db	48		pha		          PHA
.68dc	20 70 9c	jsr $9c70	          JSR Color_Character
.68df	98		tya		          TYA
.68e0	18		clc		          CLC
.68e1	7d 33 c0	adc $c033,x	          ADC E_40_Line_Lo,X
.68e4	85 8c		sta $8c		          STA GRAPNT
.68e6	bd 4c c0	lda $c04c,x	          LDA E_40_Line_Hi,X
.68e9	69 00		adc #$00	          ADC #0
.68eb	06 8c		asl $8c		          ASL GRAPNT
.68ed	2a		rol a		          ROL A
.68ee	06 8c		asl $8c		          ASL GRAPNT
.68f0	2a		rol a		          ROL A
.68f1	06 8c		asl $8c		          ASL GRAPNT
.68f3	2a		rol a		          ROL A
.68f4	85 8d		sta $8d		          STA GRAPNT+1
.68f6	8d 03 ff	sta $ff03	          STA MMU_LCRC
.68f9	a9 00		lda #$00	          LDA #0
.68fb	85 77		sta $77		          STA TEMP_A
.68fd	68		pla		          PLA
.68fe	48		pha		          PHA
.68ff	0a		asl a		          ASL A
.6900	26 77		rol $77		          ROL TEMP_A
.6902	0a		asl a		          ASL A
.6903	0a		asl a		          ASL A
.6904	26 77		rol $77		          ROL TEMP_A
.6906	85 26		sta $26		          STA INDEXB
.6908	a5 77		lda $77		          LDA TEMP_A
.690a	6d 68 11	adc $1168	          ADC CHRPAG
.690d	85 27		sta $27		          STA INDEXB+1
.690f	98		tya		          TYA
.6910	48		pha		          PHA
.6911	a0 07		ldy #$07	          LDY #7
.6913	ad 3d 11	lda $113d	DiCh_10   LDA XSGN
.6916	0a		asl a		          ASL A
.6917	b1 26		lda ($26),y	          LDA (INDEXB),Y
.6919	90 02		bcc $691d	          BCC DiCh_20
.691b	49 ff		eor #$ff	          EOR #%11111111 ; $ff
.691d	24 d8		bit $d8		DiCh_20   BIT GRAPHM
.691f	10 2b		bpl $694c	          BPL DiCh_70
.6921	29 aa		and #$aa	          AND #%10101010 ; $aa
.6923	85 77		sta $77		          STA TEMP_A
.6925	a5 83		lda $83		          LDA COLSEL
.6927	d0 0f		bne $6938	          BNE DiCh_40
.6929	a5 77		lda $77		          LDA TEMP_A
.692b	b0 07		bcs $6934	          BCS DiCh_30
.692d	4a		lsr a		          LSR A
.692e	45 77		eor $77		          EOR TEMP_A
.6930	49 aa		eor #$aa	          EOR #%10101010 ; $aa
.6932	d0 18		bne $694c	          BNE DiCh_70
.6934	09 55		ora #$55	DiCh_30   ORA #%01010101 ; $55 ; 'U'
.6936	d0 14		bne $694c	          BNE DiCh_70
.6938	c9 02		cmp #$02	DiCh_40   CMP #2
.693a	d0 04		bne $6940	          BNE DiCh_50
.693c	a5 77		lda $77		          LDA TEMP_A
.693e	b0 0c		bcs $694c	          BCS DiCh_70
.6940	90 07		bcc $6949	DiCh_50   BCC DiCh_60
.6942	a5 77		lda $77		          LDA TEMP_A
.6944	4a		lsr a		          LSR A
.6945	45 77		eor $77		          EOR TEMP_A
.6947	90 03		bcc $694c	          BCC DiCh_70
.6949	a5 77		lda $77		DiCh_60   LDA TEMP_A
.694b	4a		lsr a		          LSR A
.694c	91 8c		sta ($8c),y	DiCh_70   STA (GRAPNT),Y
.694e	88		dey		          DEY
.694f	10 c2		bpl $6913	          BPL DiCh_10
.6951	68		pla		          PLA
.6952	a8		tay		          TAY
.6953	68		pla		          PLA
.6954	60		rts		          RTS
.6955					  BASIC_LOCATE
.6955	20 74 a0	jsr $a074	          JSR Assert_Graphics_Mem
.6958	a2 04		ldx #$04	          LDX #4
.695a	20 70 9e	jsr $9e70	          JSR Get_Coordinates
.695d	4c f2 9d	jmp $9df2	          JMP XY_DEST_To_POS
.6960					  BASIC_SCALE
.6960	20 f4 87	jsr $87f4	          JSR Get_Byte_Var
.6963	e0 02		cpx #$02	          CPX #2
.6965	90 03		bcc $696a	          BCC SCAL_10
.6967	4c 28 7d	jmp $7d28	          JMP Error_Illegal_Quantity
.696a	8e 6a 11	stx $116a	SCAL_10   STX SCALEM
.696d	20 86 03	jsr $0386	          JSR CHRGOT
.6970	d0 14		bne $6986	          BNE SCAL_30
.6972	a2 00		ldx #$00	          LDX #0
.6974	a9 50		lda #$50	          LDA #$50 ; 'P'
.6976	a0 32		ldy #$32	          LDY #$32 ; '2'
.6978	24 d8		bit $d8		          BIT GRAPHM
.697a	10 01		bpl $697d	          BPL SCAL_20
.697c	4a		lsr a		          LSR A
.697d	86 87		stx $87		SCAL_20   STX SCALE_X
.697f	85 88		sta $88		          STA SCALE_X+1
.6981	86 89		stx $89		          STX SCALE_Y
.6983	84 8a		sty $8a		          STY SCALE_Y+1
.6985	60		rts		          RTS
.6986	20 c4 69	jsr $69c4	SCAL_30   JSR Get_Scale
.6989	a9 d8		lda #$d8	          LDA #<SC_320
.698b	a0 69		ldy #$69	          LDY #>SC_320
.698d	20 89 8a	jsr $8a89	          JSR Load_FAC2_From_AY_ROM
.6990	20 4c 8b	jsr $8b4c	          JSR OP_DIV
.6993	20 15 88	jsr $8815	          JSR FAC1_To_LINNUM
.6996	c9 00		cmp #$00	          CMP #0
.6998	d0 04		bne $699e	          BNE SCAL_40
.699a	c0 00		cpy #$00	          CPY #0
.699c	f0 37		beq $69d5	          BEQ GeSc_Err
.699e	48		pha		SCAL_40   PHA
.699f	98		tya		          TYA
.69a0	48		pha		          PHA
.69a1	20 c4 69	jsr $69c4	          JSR Get_Scale
.69a4	a9 dd		lda #$dd	          LDA #<SC_200
.69a6	a0 69		ldy #$69	          LDY #>SC_200
.69a8	20 89 8a	jsr $8a89	          JSR Load_FAC2_From_AY_ROM
.69ab	20 4c 8b	jsr $8b4c	          JSR OP_DIV
.69ae	20 15 88	jsr $8815	          JSR FAC1_To_LINNUM
.69b1	c9 00		cmp #$00	          CMP #0
.69b3	d0 04		bne $69b9	          BNE SCAL_50
.69b5	c0 00		cpy #$00	          CPY #0
.69b7	f0 1c		beq $69d5	          BEQ GeSc_Err
.69b9	84 89		sty $89		SCAL_50   STY SCALE_Y
.69bb	85 8a		sta $8a		          STA SCALE_Y+1
.69bd	68		pla		          PLA
.69be	85 87		sta $87		          STA SCALE_X
.69c0	68		pla		          PLA
.69c1	85 88		sta $88		          STA SCALE_X+1
.69c3	60		rts		          RTS
.69c4					  Get_Scale
.69c4	20 5c 79	jsr $795c	          JSR Need_Comma
.69c7	20 d7 77	jsr $77d7	          JSR Eval_Numeric
.69ca	a5 68		lda $68		          LDA FAC1_SI
.69cc	30 07		bmi $69d5	          BMI GeSc_Err
.69ce	a5 63		lda $63		          LDA FAC1_EX
.69d0	c9 90		cmp #$90	          CMP #$90
.69d2	b0 01		bcs $69d5	          BCS GeSc_Err
.69d4	60		rts		          RTS
.69d5	4c 28 7d	jmp $7d28	GeSc_Err  JMP Error_Illegal_Quantity
>69d8	99 1f ff 60 00			SC_320    .BYTE $99,$1f,$ff,$60,$00 ;.REAL $991fff6000 ; 20971200 = 320 * 65535
>69dd	98 47 ff 38 00			SC_200    .BYTE $98,$47,$ff,$38,$00 ;.REAL $9847ff3800 ; 13107000 = 200 * 65535
.69e2					  BASIC_COLOR
.69e2	20 f4 87	jsr $87f4	          JSR Get_Byte_Var
.69e5	e0 07		cpx #$07	          CPX #7
.69e7	b0 60		bcs $6a49	          BCS COLO_90
.69e9	86 77		stx $77		          STX TEMP_A
.69eb	20 09 88	jsr $8809	          JSR Comma_And_Byte
.69ee	ca		dex		          DEX
.69ef	e0 10		cpx #$10	          CPX #16
.69f1	b0 56		bcs $6a49	          BCS COLO_90
.69f3	20 45 a8	jsr $a845	          JSR Map_IO
.69f6	8a		txa		          TXA
.69f7	a6 77		ldx $77		          LDX TEMP_A
.69f9	e0 01		cpx #$01	          CPX #1
.69fb	f0 07		beq $6a04	          BEQ COLO_10
.69fd	b0 09		bcs $6a08	          BCS COLO_20
.69ff	8d 21 d0	sta $d021	          STA VIC_BG_COL
.6a02	d0 3f		bne $6a43	          BNE COLO_80
.6a04	85 86		sta $86		COLO_10   STA FG_COL
.6a06	f0 3b		beq $6a43	          BEQ COLO_80
.6a08	e0 03		cpx #$03	COLO_20   CPX #3
.6a0a	f0 06		beq $6a12	          BEQ COLO_30
.6a0c	b0 08		bcs $6a16	          BCS COLO_40
.6a0e	85 84		sta $84		          STA MULCO1
.6a10	d0 31		bne $6a43	          BNE COLO_80
.6a12	85 85		sta $85		COLO_30   STA MULCO2
.6a14	f0 2d		beq $6a43	          BEQ COLO_80
.6a16	e0 05		cpx #$05	COLO_40   CPX #5
.6a18	f0 07		beq $6a21	          BEQ COLO_50
.6a1a	b0 16		bcs $6a32	          BCS COLO_70
.6a1c	8d 20 d0	sta $d020	          STA Vd020
.6a1f	d0 22		bne $6a43	          BNE COLO_80
.6a21	24 d7		bit $d7		COLO_50   BIT MODE_80
.6a23	10 08		bpl $6a2d	          BPL COLO_60
.6a25	aa		tax		          TAX
.6a26	a5 f1		lda $f1		          LDA E_Attribute
.6a28	29 f0		and #$f0	          AND #%11110000 ; $f0
.6a2a	1d 4c 6a	ora $6a4c,x	          ORA VDC_Color,X
.6a2d	85 f1		sta $f1		COLO_60   STA E_Attribute
.6a2f	4c 43 6a	jmp $6a43	          JMP COLO_80
.6a32	aa		tax		COLO_70   TAX
.6a33	a9 1a		lda #$1a	          LDA #$1a
.6a35	8d 00 d6	sta $d600	          STA VDC_Register
.6a38	ad 01 d6	lda $d601	          LDA VDC_Data
.6a3b	29 f0		and #$f0	          AND #%11110000 ; $f0
.6a3d	1d 4c 6a	ora $6a4c,x	          ORA VDC_Color,X
.6a40	8d 01 d6	sta $d601	          STA VDC_Data
.6a43	20 5c 6a	jsr $6a5c	COLO_80   JSR setpcl
.6a46	4c 1e 9e	jmp $9e1e	          JMP Get_Byte_Or_Void
.6a49	4c 28 7d	jmp $7d28	COLO_90   JMP Error_Illegal_Quantity
>6a4c	00 0f 08 07 0b 04 02 0d		VDC_Color .BYTE $00,$0f,$08,$07,$0b,$04,$02,$0d
>6a54	0a 0c 09 06 01 05 03 0e		          .BYTE $0a,$0c,$09,$06,$01,$05,$03,$0e
.6a5c					  setpcl
.6a5c	a5 86		lda $86		          LDA FG_COL
.6a5e	0a		asl a		          ASL A
.6a5f	0a		asl a		          ASL A
.6a60	0a		asl a		          ASL A
.6a61	0a		asl a		          ASL A
.6a62	85 77		sta $77		          STA TEMP_A
.6a64	20 45 a8	jsr $a845	          JSR Map_IO
.6a67	ad 21 d0	lda $d021	          LDA VIC_BG_COL
.6a6a	29 0f		and #$0f	          AND #%00001111 ; $0f
.6a6c	05 77		ora $77		          ORA TEMP_A
.6a6e	8d e2 03	sta $03e2	          STA FG_BG
.6a71	a5 84		lda $84		          LDA MULCO1
.6a73	05 77		ora $77		          ORA TEMP_A
.6a75	8d e3 03	sta $03e3	          STA FG_MC1
.6a78	60		rts		          RTS
.6a79					  BASIC_SCNCLR
.6a79	d0 14		bne $6a8f	          BNE SCLR_20
.6a7b	20 8c 81	jsr $818c	          JSR Get_Graphics_Mode
.6a7e	c9 05		cmp #$05	          CMP #5
.6a80	90 09		bcc $6a8b	          BCC SCLR_10
.6a82	e9 05		sbc #$05	          SBC #5
.6a84	f0 58		beq $6ade	          BEQ Clear_80_Column_Screen
.6a86	48		pha		          PHA
.6a87	20 de 6a	jsr $6ade	          JSR Clear_80_Column_Screen
.6a8a	68		pla		          PLA
.6a8b	aa		tax		SCLR_10   TAX
.6a8c	4c 9b 6a	jmp $6a9b	          JMP SCLR_40
.6a8f	20 f4 87	jsr $87f4	SCLR_20   JSR Get_Byte_Var
.6a92	e0 05		cpx #$05	SCLR_30   CPX #5
.6a94	f0 48		beq $6ade	          BEQ Clear_80_Column_Screen
.6a96	90 03		bcc $6a9b	          BCC SCLR_40
.6a98	4c 28 7d	jmp $7d28	          JMP Error_Illegal_Quantity
.6a9b	8a		txa		SCLR_40   TXA
.6a9c	f0 54		beq $6af2	          BEQ Clear_40_Column_Screen
.6a9e	20 74 a0	jsr $a074	          JSR Assert_Graphics_Mem
.6aa1	8a		txa		          TXA
.6aa2	48		pha		          PHA
.6aa3	29 01		and #$01	          AND #%00000001 ; $01
.6aa5	d0 21		bne $6ac8	          BNE SCLR_60
.6aa7	20 f2 6a	jsr $6af2	          JSR Clear_40_Column_Screen
.6aaa	a5 d7		lda $d7		          LDA MODE_80
.6aac	48		pha		          PHA
.6aad	10 03		bpl $6ab2	          BPL SCLR_50
.6aaf	20 5f ff	jsr $ff5f	          JSR K_SWAPPER
.6ab2	ad 34 0a	lda $0a34	SCLR_50   LDA VSH_SPLIT
.6ab5	38		sec		          SEC
.6ab6	e9 30		sbc #$30	          SBC #$30 ; '0'
.6ab8	4a		lsr a		          LSR A
.6ab9	4a		lsr a		          LSR A
.6aba	4a		lsr a		          LSR A
.6abb	aa		tax		          TAX
.6abc	a0 00		ldy #$00	          LDY #0
.6abe	18		clc		          CLC
.6abf	20 8d 92	jsr $928d	          JSR B_PLOT
.6ac2	68		pla		          PLA
.6ac3	10 03		bpl $6ac8	          BPL SCLR_60
.6ac5	20 5f ff	jsr $ff5f	          JSR K_SWAPPER
.6ac8	68		pla		SCLR_60   PLA
.6ac9	29 02		and #$02	          AND #%00000010 ; $02
.6acb	f0 03		beq $6ad0	          BEQ SCLR_70
.6acd	20 17 6b	jsr $6b17	          JSR Clear_Color_RAM
.6ad0	20 30 6b	jsr $6b30	SCLR_70   JSR Clear_Graphics_RAM
.6ad3	a9 00		lda #$00	          LDA #0
.6ad5	a2 03		ldx #$03	          LDX #3
.6ad7	9d 31 11	sta $1131,x	SCLR_80   STA XPOS,X
.6ada	ca		dex		          DEX
.6adb	10 fa		bpl $6ad7	          BPL SCLR_80
.6add	60		rts		          RTS
.6ade					  Clear_80_Column_Screen
.6ade	a5 d7		lda $d7		          LDA MODE_80
.6ae0	48		pha		          PHA
.6ae1	30 03		bmi $6ae6	          BMI CLR80_10
.6ae3	20 5f ff	jsr $ff5f	          JSR K_SWAPPER
.6ae6	a9 93		lda #$93	CLR80_10  LDA #$93            ; clear window
.6ae8	20 69 92	jsr $9269	          JSR B_BSOUT
.6aeb	68		pla		          PLA
.6aec	30 03		bmi $6af1	          BMI CLR80_20
.6aee	20 5f ff	jsr $ff5f	          JSR K_SWAPPER
.6af1	60		rts		CLR80_20  RTS
.6af2					  Clear_40_Column_Screen
.6af2	a5 d7		lda $d7		          LDA MODE_80
.6af4	48		pha		          PHA
.6af5	10 03		bpl $6afa	          BPL CLR40_10
.6af7	20 5f ff	jsr $ff5f	          JSR K_SWAPPER
.6afa	a9 93		lda #$93	CLR40_10  LDA #$93
.6afc	20 69 92	jsr $9269	          JSR B_BSOUT
.6aff	68		pla		          PLA
.6b00	10 03		bpl $6b05	          BPL CLR40_20
.6b02	20 5f ff	jsr $ff5f	          JSR K_SWAPPER
.6b05	60		rts		CLR40_20  RTS
.6b06					  Fill_X_Pages
.6b06	84 8d		sty $8d		          STY GRAPNT+1
.6b08	a0 00		ldy #$00	          LDY #0
.6b0a	84 8c		sty $8c		          STY GRAPNT
.6b0c	91 8c		sta ($8c),y	FXP_10    STA (GRAPNT),Y
.6b0e	88		dey		          DEY
.6b0f	d0 fb		bne $6b0c	          BNE FXP_10
.6b11	e6 8d		inc $8d		          INC GRAPNT+1
.6b13	ca		dex		          DEX
.6b14	d0 f6		bne $6b0c	          BNE FXP_10
.6b16	60		rts		          RTS
.6b17					  Clear_Color_RAM
.6b17	20 45 a8	jsr $a845	          JSR Map_IO
.6b1a	78		sei		          SEI
.6b1b	a5 01		lda $01		          LDA R8502
.6b1d	48		pha		          PHA
.6b1e	29 fe		and #$fe	          AND #%11111110     ; $fe
.6b20	85 01		sta $01		          STA R8502           ; access color RAM
.6b22	a5 85		lda $85		          LDA MULCO2          ; fill color
.6b24	a0 d8		ldy #$d8	          LDY #>VIC_COLOR_RAM ; $d800
.6b26	a2 04		ldx #$04	          LDX #4              ; 4 pages
.6b28	20 06 6b	jsr $6b06	          JSR Fill_X_Pages
.6b2b	68		pla		          PLA
.6b2c	85 01		sta $01		          STA R8502
.6b2e	58		cli		          CLI
.6b2f	60		rts		          RTS
.6b30					  Clear_Graphics_RAM
.6b30	a9 00		lda #$00	          LDA #0              ; write zeroes
.6b32	a0 20		ldy #$20	          LDY #>GRAFX_RAM     ; fill $2000 - $3fff
.6b34	a2 20		ldx #$20	          LDX #$20            ; #$20 pages
.6b36	20 06 6b	jsr $6b06	          JSR Fill_X_Pages
.6b39	ad e2 03	lda $03e2	          LDA FG_BG           ; foreground / background
.6b3c	24 d8		bit $d8		          BIT GRAPHM
.6b3e	10 03		bpl $6b43	          BPL CGR_10
.6b40	ad e3 03	lda $03e3	          LDA FG_MC1          ; foreground mulricolor 1
.6b43	20 45 a8	jsr $a845	CGR_10    JSR Map_IO
.6b46	a0 1c		ldy #$1c	          LDY #>COLOR_RAM     ; fill $1c00 - $1fff
.6b48	a2 04		ldx #$04	          LDX #4              ; 4 pages
.6b4a	20 06 6b	jsr $6b06	          JSR Fill_X_Pages
.6b4d	a2 3f		ldx #$3f	          LDX #$3f            ; $0fc0 / $40
.6b4f	a0 07		ldy #$07	          LDY #7
.6b51	8a		txa		CGR_20    TXA
.6b52	99 f8 1f	sta $1ff8,y	          STA GRAFX_RAM-8,Y   ; init sprite pointer
.6b55	ca		dex		          DEX
.6b56	88		dey		          DEY
.6b57	10 f8		bpl $6b51	          BPL CGR_20
.6b59	60		rts		          RTS
.6b5a					  BASIC_GRAPHIC
.6b5a	c9 9c		cmp #$9c	          CMP #$9c
.6b5c	d0 0b		bne $6b69	          BNE GRAP_10
.6b5e	20 22 a0	jsr $a022	          JSR Free_Graphics_RAM
.6b61	20 80 03	jsr $0380	          JSR CHRGET
.6b64	a9 00		lda #$00	          LDA #0
.6b66	85 d8		sta $d8		          STA GRAPHM
.6b68	60		rts		          RTS
.6b69	20 f4 87	jsr $87f4	GRAP_10   JSR Get_Byte_Var
.6b6c	8a		txa		          TXA
.6b6d	48		pha		          PHA
.6b6e	e0 05		cpx #$05	          CPX #5
.6b70	f0 42		beq $6bb4	          BEQ GRAP_60
.6b72	b0 4d		bcs $6bc1	          BCS GRAP_70
.6b74	bd c4 6b	lda $6bc4,x	          LDA Graphic_Modes,X
.6b77	85 d8		sta $d8		          STA GRAPHM
.6b79	f0 07		beq $6b82	          BEQ GRAP_20
.6b7b	20 4f 9f	jsr $9f4f	          JSR Allocate_Graphics_RAM
.6b7e	24 d8		bit $d8		          BIT GRAPHM
.6b80	50 07		bvc $6b89	          BVC GRAP_40
.6b82	24 d7		bit $d7		GRAP_20   BIT MODE_80
.6b84	10 03		bpl $6b89	          BPL GRAP_40
.6b86	20 5f ff	jsr $ff5f	GRAP_30   JSR K_SWAPPER
.6b89	20 1c 9e	jsr $9e1c	GRAP_40   JSR Get_Byte_Or_Zero
.6b8c	e0 02		cpx #$02	          CPX #2
.6b8e	b0 31		bcs $6bc1	          BCS GRAP_70
.6b90	8a		txa		          TXA
.6b91	48		pha		          PHA
.6b92	a2 14		ldx #$14	          LDX #$14
.6b94	20 1e 9e	jsr $9e1e	          JSR Get_Byte_Or_Void
.6b97	e0 1a		cpx #$1a	          CPX #$1a
.6b99	b0 26		bcs $6bc1	          BCS GRAP_70
.6b9b	8a		txa		          TXA
.6b9c	0a		asl a		          ASL A
.6b9d	0a		asl a		          ASL A
.6b9e	0a		asl a		          ASL A
.6b9f	69 30		adc #$30	          ADC #$30 ; '0'
.6ba1	8d 34 0a	sta $0a34	          STA VSH_SPLIT
.6ba4	68		pla		          PLA
.6ba5	a8		tay		          TAY
.6ba6	68		pla		          PLA
.6ba7	aa		tax		          TAX
.6ba8	98		tya		          TYA
.6ba9	f0 03		beq $6bae	          BEQ GRAP_50
.6bab	20 92 6a	jsr $6a92	          JSR SCLR_30
.6bae	a9 00		lda #$00	GRAP_50   LDA #0
.6bb0	8d 6a 11	sta $116a	          STA SCALEM
.6bb3	60		rts		          RTS
.6bb4	24 d7		bit $d7		GRAP_60   BIT MODE_80
.6bb6	30 d1		bmi $6b89	          BMI GRAP_40
.6bb8	a5 d8		lda $d8		          LDA GRAPHM
.6bba	29 bf		and #$bf	          AND #%10111111 ; $bf
.6bbc	85 d8		sta $d8		          STA GRAPHM
.6bbe	4c 86 6b	jmp $6b86	          JMP GRAP_30
.6bc1	4c 28 7d	jmp $7d28	GRAP_70   JMP Error_Illegal_Quantity
.6bc4					  Graphic_Modes
>6bc4	00				          .BYTE $00           ; Text
>6bc5	20				          .BYTE $20           ; High Resolution
>6bc6	60				          .BYTE $60           ; High Resolution - Split
>6bc7	a0				          .BYTE $a0           ; Multicolor
>6bc8	e0				          .BYTE $e0           ; Multicolor - Split
.6bc9					  BASIC_BANK
.6bc9	20 f4 87	jsr $87f4	          JSR Get_Byte_Var
.6bcc	e0 10		cpx #$10	          CPX #16
.6bce	b0 04		bcs $6bd4	          BCS BANK_Err
.6bd0	8e d5 03	stx $03d5	          STX USER_BANK
.6bd3	60		rts		          RTS
.6bd4	4c 28 7d	jmp $7d28	BANK_Err  JMP Error_Illegal_Quantity
.6bd7					  BASIC_SLEEP
.6bd7	20 12 88	jsr $8812	          JSR Get_Integer
.6bda	a2 00		ldx #$00	          LDX #0
.6bdc	78		sei		          SEI
.6bdd	8c 1d 0a	sty $0a1d	          STY JIFFY_COUNTDOWN
.6be0	8d 1e 0a	sta $0a1e	          STA JIFFY_COUNTDOWN+1
.6be3	8e 1f 0a	stx $0a1f	          STX JIFFY_COUNTDOWN+2
.6be6	20 0c 6c	jsr $6c0c	          JSR ASL_TIMER
.6be9	20 16 6c	jsr $6c16	          JSR ADD_TIMER
.6bec	20 09 6c	jsr $6c09	          JSR TIMER_X4
.6bef	ac 1d 0a	ldy $0a1d	          LDY JIFFY_COUNTDOWN
.6bf2	ad 1e 0a	lda $0a1e	          LDA JIFFY_COUNTDOWN+1
.6bf5	ae 1f 0a	ldx $0a1f	          LDX JIFFY_COUNTDOWN+2
.6bf8	20 09 6c	jsr $6c09	          JSR TIMER_X4
.6bfb	20 16 6c	jsr $6c16	          JSR ADD_TIMER
.6bfe	58		cli		          CLI
.6bff	20 b5 4b	jsr $4bb5	SLEEP_10  JSR Is_STOP_Key
.6c02	ae 1f 0a	ldx $0a1f	          LDX JIFFY_COUNTDOWN+2
.6c05	e8		inx		          INX
.6c06	d0 f7		bne $6bff	          BNE SLEEP_10
.6c08	60		rts		          RTS
.6c09					  TIMER_X4
.6c09	20 0c 6c	jsr $6c0c	          JSR ASL_TIMER
.6c0c					  ASL_TIMER
.6c0c	0e 1d 0a	asl $0a1d	          ASL JIFFY_COUNTDOWN
.6c0f	2e 1e 0a	rol $0a1e	          ROL JIFFY_COUNTDOWN+1
.6c12	2e 1f 0a	rol $0a1f	          ROL JIFFY_COUNTDOWN+2
.6c15	60		rts		          RTS
.6c16					  ADD_TIMER
.6c16	48		pha		          PHA
.6c17	98		tya		          TYA
.6c18	6d 1d 0a	adc $0a1d	          ADC JIFFY_COUNTDOWN
.6c1b	8d 1d 0a	sta $0a1d	          STA JIFFY_COUNTDOWN
.6c1e	68		pla		          PLA
.6c1f	6d 1e 0a	adc $0a1e	          ADC JIFFY_COUNTDOWN+1
.6c22	8d 1e 0a	sta $0a1e	          STA JIFFY_COUNTDOWN+1
.6c25	8a		txa		          TXA
.6c26	6d 1f 0a	adc $0a1f	          ADC JIFFY_COUNTDOWN+2
.6c29	8d 1f 0a	sta $0a1f	          STA JIFFY_COUNTDOWN+2
.6c2c	60		rts		          RTS
.6c2d					  BASIC_WAIT
.6c2d	20 03 88	jsr $8803	          JSR LINNUM_Comma_Byte
.6c30	86 4b		stx $4b		          STX FORPNT
.6c32	a2 00		ldx #$00	          LDX #0
.6c34	20 86 03	jsr $0386	          JSR CHRGOT
.6c37	f0 03		beq $6c3c	          BEQ WAIT_10
.6c39	20 09 88	jsr $8809	          JSR Comma_And_Byte
.6c3c	86 4c		stx $4c		WAIT_10   STX FORPNT+1
.6c3e	a0 00		ldy #$00	WAIT_20   LDY #0
.6c40	ae d5 03	ldx $03d5	          LDX USER_BANK
.6c43	a9 16		lda #$16	          LDA #$16
.6c45	20 74 ff	jsr $ff74	          JSR K_INDFET
.6c48	45 4c		eor $4c		          EOR FORPNT+1
.6c4a	25 4b		and $4b		          AND FORPNT
.6c4c	f0 f0		beq $6c3e	          BEQ WAIT_20
.6c4e	60		rts		          RTS
.6c4f					  BASIC_SPRITE
.6c4f	20 bb 6c	jsr $6cbb	          JSR Get_Sprite_Number
.6c52	20 1e 9e	jsr $9e1e	          JSR Get_Byte_Or_Void
.6c55	90 05		bcc $6c5c	          BCC SPRI_10
.6c57	a0 15		ldy #$15	          LDY #$15
.6c59	20 9b 6c	jsr $6c9b	          JSR Switch_Sprite
.6c5c	20 1e 9e	jsr $9e1e	SPRI_10   JSR Get_Byte_Or_Void
.6c5f	90 0e		bcc $6c6f	          BCC SPRI_20
.6c61	ca		dex		          DEX
.6c62	e0 10		cpx #$10	          CPX #16
.6c64	b0 32		bcs $6c98	          BCS SPRI_Err
.6c66	8a		txa		          TXA
.6c67	a6 77		ldx $77		          LDX TEMP_A
.6c69	20 45 a8	jsr $a845	          JSR Map_IO
.6c6c	9d 27 d0	sta $d027,x	          STA Vd027,X
.6c6f	20 1e 9e	jsr $9e1e	SPRI_20   JSR Get_Byte_Or_Void
.6c72	90 05		bcc $6c79	          BCC SPRI_30
.6c74	a0 1b		ldy #$1b	          LDY #$1b
.6c76	20 9b 6c	jsr $6c9b	          JSR Switch_Sprite
.6c79	20 1e 9e	jsr $9e1e	SPRI_30   JSR Get_Byte_Or_Void
.6c7c	90 05		bcc $6c83	          BCC SPRI_40
.6c7e	a0 1d		ldy #$1d	          LDY #$1d
.6c80	20 9b 6c	jsr $6c9b	          JSR Switch_Sprite
.6c83	20 1e 9e	jsr $9e1e	SPRI_40   JSR Get_Byte_Or_Void
.6c86	90 05		bcc $6c8d	          BCC SPRI_50
.6c88	a0 17		ldy #$17	          LDY #$17
.6c8a	20 9b 6c	jsr $6c9b	          JSR Switch_Sprite
.6c8d	20 1e 9e	jsr $9e1e	SPRI_50   JSR Get_Byte_Or_Void
.6c90	90 05		bcc $6c97	          BCC SPRI_Ret
.6c92	a0 1c		ldy #$1c	          LDY #$1c
.6c94	20 9b 6c	jsr $6c9b	          JSR Switch_Sprite
.6c97	60		rts		SPRI_Ret  RTS
.6c98	4c 28 7d	jmp $7d28	SPRI_Err  JMP Error_Illegal_Quantity
.6c9b					  Switch_Sprite
.6c9b	8a		txa		          TXA
.6c9c	4a		lsr a		          LSR A               ; C=1 ON , C=0 OFF
.6c9d	d0 f9		bne $6c98	          BNE SPRI_Err
.6c9f	a6 77		ldx $77		          LDX TEMP_A
.6ca1	bd b3 6c	lda $6cb3,x	          LDA Bit_Mask,X
.6ca4	20 45 a8	jsr $a845	          JSR Map_IO
.6ca7	19 00 d0	ora $d000,y	          ORA VIC,Y
.6caa	b0 03		bcs $6caf	          BCS SwSp_10
.6cac	5d b3 6c	eor $6cb3,x	          EOR Bit_Mask,X
.6caf	99 00 d0	sta $d000,y	SwSp_10   STA VIC,Y
.6cb2	60		rts		          RTS
>6cb3	01 02 04 08 10 20 40 80		Bit_Mask  .BYTE $01,$02,$04,$08,$10,$20,$40,$80
.6cbb					  Get_Sprite_Number
.6cbb	20 f4 87	jsr $87f4	          JSR Get_Byte_Var
.6cbe	ca		dex		          DEX
.6cbf	e0 08		cpx #$08	          CPX #8
.6cc1	b0 d5		bcs $6c98	          BCS SPRI_Err
.6cc3	86 77		stx $77		          STX TEMP_A
.6cc5	60		rts		          RTS
.6cc6					  BASIC_MOVSPR
.6cc6	20 bb 6c	jsr $6cbb	          JSR Get_Sprite_Number
.6cc9	20 9e 6d	jsr $6d9e	          JSR Get_Sprite_Coordinates
.6ccc	2c 6e 11	bit $116e	          BIT NUMCNT
.6ccf	50 03		bvc $6cd4	          BVC MOVS_10
.6cd1	4c 6c 79	jmp $796c	          JMP SYNTAX_ERROR
.6cd4	8c 35 11	sty $1135	MOVS_10   STY XDEST
.6cd7	8c 37 11	sty $1137	          STY YDEST
.6cda	8d 36 11	sta $1136	          STA XDEST+1
.6cdd	8d 38 11	sta $1138	          STA YDEST+1
.6ce0	20 9e 6d	jsr $6d9e	          JSR Get_Sprite_Coordinates
.6ce3	2c 6e 11	bit $116e	          BIT NUMCNT
.6ce6	50 61		bvc $6d49	          BVC MOVS_40
.6ce8	30 3a		bmi $6d24	          BMI MOVS_30
.6cea	98		tya		          TYA
.6ceb	48		pha		          PHA
.6cec	a0 04		ldy #$04	          LDY #4
.6cee	20 74 9a	jsr $9a74	          JSR Sin_Cos_Ang
.6cf1	a6 77		ldx $77		          LDX TEMP_A
.6cf3	bc d9 6d	ldy $6dd9,x	          LDY Sprite_Offset,X
.6cf6	a9 00		lda #$00	          LDA #0
.6cf8	99 7e 11	sta $117e,y	          STA SPRITE_DATA,Y
.6cfb	c8		iny		          INY
.6cfc	a2 03		ldx #$03	          LDX #3
.6cfe	5e 4a 11	lsr $114a,x	MOVS_15   LSR SINVAL,X
.6d01	ca		dex		          DEX
.6d02	7e 4a 11	ror $114a,x	          ROR SINVAL,X
.6d05	ca		dex		          DEX
.6d06	10 f6		bpl $6cfe	          BPL MOVS_15
.6d08	e8		inx		MOVS_20   INX
.6d09	bd 49 11	lda $1149,x	          LDA ANGSGN,X
.6d0c	c8		iny		          INY
.6d0d	99 7e 11	sta $117e,y	          STA SPRITE_DATA,Y
.6d10	e0 04		cpx #$04	          CPX #4
.6d12	d0 f4		bne $6d08	          BNE MOVS_20
.6d14	a9 00		lda #$00	          LDA #0
.6d16	c8		iny		MOVS_25   INY
.6d17	99 7e 11	sta $117e,y	          STA SPRITE_DATA,Y
.6d1a	ca		dex		          DEX
.6d1b	d0 f9		bne $6d16	          BNE MOVS_25
.6d1d	68		pla		          PLA
.6d1e	29 0f		and #$0f	          AND #%00001111 ; $0f
.6d20	99 74 11	sta $1174,y	          STA T3,Y
.6d23	60		rts		          RTS
.6d24	20 39 81	jsr $8139	MOVS_30   JSR Swap_XY
.6d27	a8		tay		          TAY
.6d28	8a		txa		          TXA
.6d29	20 77 9a	jsr $9a77	          JSR Sin_Cos_AY
.6d2c	a2 04		ldx #$04	          LDX #4
.6d2e	20 4a 9d	jsr $9d4a	          JSR Scale_XY
.6d31	a2 04		ldx #$04	          LDX #4
.6d33	18		clc		          CLC
.6d34	20 ce 9a	jsr $9ace	MOVS_35   JSR LAY_SIN_X
.6d37	9d 31 11	sta $1131,x	          STA XPOS,X
.6d3a	98		tya		          TYA
.6d3b	9d 32 11	sta $1132,x	          STA XPOS+1,X
.6d3e	e8		inx		          INX
.6d3f	e8		inx		          INX
.6d40	e0 06		cpx #$06	          CPX #6
.6d42	f0 f0		beq $6d34	          BEQ MOVS_35
.6d44	6e 6e 11	ror $116e	          ROR NUMCNT
.6d47	30 0b		bmi $6d54	          BMI MOVS_45
.6d49	8c 37 11	sty $1137	MOVS_40   STY YDEST
.6d4c	8d 38 11	sta $1138	          STA YDEST+1
.6d4f	a2 04		ldx #$04	          LDX #4
.6d51	20 4a 9d	jsr $9d4a	          JSR Scale_XY
.6d54	a5 77		lda $77		MOVS_45   LDA TEMP_A
.6d56	aa		tax		          TAX
.6d57	0a		asl a		          ASL A
.6d58	a8		tay		          TAY
.6d59	ad 37 11	lda $1137	          LDA YDEST
.6d5c	0e 6e 11	asl $116e	          ASL NUMCNT
.6d5f	90 09		bcc $6d6a	          BCC MOVS_55
.6d61	18		clc		          CLC
.6d62	10 03		bpl $6d67	          BPL MOVS_50
.6d64	49 ff		eor #$ff	          EOR #%11111111 ; $ff
.6d66	38		sec		          SEC
.6d67	79 d7 11	adc $11d7,y	MOVS_50   ADC VSH+1,Y
.6d6a	78		sei		MOVS_55   SEI
.6d6b	99 d7 11	sta $11d7,y	          STA VSH+1,Y
.6d6e	ad 35 11	lda $1135	          LDA XDEST
.6d71	0e 6e 11	asl $116e	          ASL NUMCNT
.6d74	10 12		bpl $6d88	          BPL MOVS_65
.6d76	18		clc		          CLC
.6d77	79 d6 11	adc $11d6,y	          ADC VSH,Y
.6d7a	99 d6 11	sta $11d6,y	          STA VSH,Y
.6d7d	b0 03		bcs $6d82	          BCS MOVS_60
.6d7f	ee 36 11	inc $1136	          INC XDEST+1
.6d82	ad e6 11	lda $11e6	MOVS_60   LDA VSH+16
.6d85	4c 91 6d	jmp $6d91	          JMP MOVS_70
.6d88	99 d6 11	sta $11d6,y	MOVS_65   STA VSH,Y
.6d8b	ad e6 11	lda $11e6	          LDA VSH+16
.6d8e	1d b3 6c	ora $6cb3,x	          ORA Bit_Mask,X
.6d91	4e 36 11	lsr $1136	MOVS_70   LSR XDEST+1
.6d94	b0 03		bcs $6d99	          BCS MOVS_75
.6d96	5d b3 6c	eor $6cb3,x	          EOR Bit_Mask,X
.6d99	8d e6 11	sta $11e6	MOVS_75   STA VSH+16
.6d9c	58		cli		          CLI
.6d9d	60		rts		          RTS
.6d9e					  Get_Sprite_Coordinates
.6d9e	20 c6 6d	jsr $6dc6	          JSR Comma_Check
.6da1	6e 6e 11	ror $116e	          ROR NUMCNT
.6da4	10 0b		bpl $6db1	          BPL GSC_10
.6da6	c9 3b		cmp #$3b	          CMP #';'
.6da8	f0 13		beq $6dbd	          BEQ GSC_30
.6daa	c9 23		cmp #$23	          CMP #'#'
.6dac	f0 0e		beq $6dbc	          BEQ GSC_20
.6dae	4c 6c 79	jmp $796c	          JMP SYNTAX_ERROR
.6db1	20 86 03	jsr $0386	GSC_10    JSR CHRGOT
.6db4	c9 aa		cmp #$aa	          CMP #$aa            ; +
.6db6	f0 05		beq $6dbd	          BEQ GSC_30
.6db8	c9 ab		cmp #$ab	          CMP #$ab            ; -
.6dba	f0 01		beq $6dbd	          BEQ GSC_30
.6dbc	18		clc		GSC_20    CLC
.6dbd	6e 6e 11	ror $116e	GSC_30    ROR NUMCNT
.6dc0	20 d7 77	jsr $77d7	GSC_40    JSR Eval_Numeric    ; Call entry
.6dc3	4c 19 88	jmp $8819	          JMP F1TL_10
.6dc6					  Comma_Check
.6dc6	20 86 03	jsr $0386	          JSR CHRGOT
.6dc9	f0 0d		beq $6dd8	          BEQ CoCh_20
.6dcb	c9 2c		cmp #$2c	          CMP #','
.6dcd	18		clc		          CLC
.6dce	f0 01		beq $6dd1	          BEQ CoCh_10
.6dd0	38		sec		          SEC
.6dd1	08		php		CoCh_10   PHP
.6dd2	48		pha		          PHA
.6dd3	20 80 03	jsr $0380	          JSR CHRGET
.6dd6	68		pla		          PLA
.6dd7	28		plp		          PLP
.6dd8	60		rts		CoCh_20   RTS
.6dd9					  Sprite_Offset
>6dd9	00 0b 16 21 2c 37 42 4d		          .BYTE $00,$0b,$16,$21,$2c,$37,$42,$4d
.6de1					  BASIC_PLAY
.6de1	20 7b 87	jsr $877b	          JSR Eval_String
.6de4	8d 03 ff	sta $ff03	          STA MMU_LCRC
.6de7	85 77		sta $77		          STA TEMP_A
.6de9	20 ce 6f	jsr $6fce	          JSR Clear_Tone_Flags
.6dec	85 78		sta $78		          STA KEYSIZ
.6dee	a4 78		ldy $78		PLAY_10   LDY KEYSIZ
.6df0	c4 77		cpy $77		          CPY TEMP_A
.6df2	f0 0d		beq $6e01	          BEQ PLAY_Ret
.6df4	20 b7 03	jsr $03b7	          JSR Get_INDEXA_1
.6df7	8d 03 ff	sta $ff03	          STA MMU_LCRC
.6dfa	20 02 6e	jsr $6e02	          JSR Play_Note
.6dfd	e6 78		inc $78		          INC KEYSIZ
.6dff	d0 ed		bne $6dee	          BNE PLAY_10
.6e01	60		rts		PLAY_Ret  RTS
.6e02					  Play_Note
.6e02	c9 20		cmp #$20	          CMP #' '
.6e04	d0 01		bne $6e07	          BNE PlNo_10
.6e06	60		rts		          RTS
.6e07	c9 41		cmp #$41	PlNo_10   CMP #'A'
.6e09	90 07		bcc $6e12	          BCC PlNo_15
.6e0b	c9 48		cmp #$48	          CMP #'H'
.6e0d	b0 03		bcs $6e12	          BCS PlNo_15
.6e0f	4c 1e 6f	jmp $6f1e	          JMP Set_Note
.6e12	a2 04		ldx #$04	PlNo_15   LDX #4
.6e14	dd e7 6f	cmp $6fe7,x	PlNo_20   CMP notes,X
.6e17	d0 03		bne $6e1c	          BNE PlNo_25
.6e19	4c 07 6f	jmp $6f07	          JMP Set_Duration
.6e1c	ca		dex		PlNo_25   DEX
.6e1d	10 f5		bpl $6e14	          BPL PlNo_20
.6e1f	c9 52		cmp #$52	          CMP #'R'
.6e21	d0 03		bne $6e26	          BNE PlNo_30
.6e23	4c 78 6f	jmp $6f78	          JMP SeNo_75
.6e26	c9 2e		cmp #$2e	PlNo_30   CMP #'.'
.6e28	d0 03		bne $6e2d	          BNE PlNo_35
.6e2a	4c 03 6f	jmp $6f03	          JMP Store_DNOTE
.6e2d	a2 05		ldx #$05	PlNo_35   LDX #5
.6e2f	dd ec 6f	cmp $6fec,x	PlNo_40   CMP mutabl,X
.6e32	d0 03		bne $6e37	          BNE PlNo_45
.6e34	4c 52 6f	jmp $6f52	          JMP SeNo_40
.6e37	ca		dex		PlNo_45   DEX
.6e38	10 f5		bpl $6e2f	          BPL PlNo_40
.6e3a	c9 23		cmp #$23	          CMP #'#'
.6e3c	d0 03		bne $6e41	          BNE PlNo_50
.6e3e	4c 69 6f	jmp $6f69	          JMP Play_Sharp
.6e41	c9 24		cmp #$24	PlNo_50   CMP #'$'
.6e43	d0 03		bne $6e48	          BNE PlNo_55
.6e45	4c 6c 6f	jmp $6f6c	          JMP Play_Flatc
.6e48	38		sec		PlNo_55   SEC
.6e49	e9 30		sbc #$30	          SBC #'0'
.6e4b	c9 0a		cmp #$0a	          CMP #10
.6e4d	90 03		bcc $6e52	          BCC PlNo_60
.6e4f	4c fd 6e	jmp $6efd	          JMP Error_Exit
.6e52	0e 26 01	asl $0126	PlNo_60   ASL FLAG
.6e55	b0 46		bcs $6e9d	          BCS PlNo_85
.6e57	0e 26 01	asl $0126	          ASL FLAG
.6e5a	b0 4c		bcs $6ea8	          BCS PlNo_90
.6e5c	0e 26 01	asl $0126	          ASL FLAG
.6e5f	b0 50		bcs $6eb1	          BCS PlNo_95
.6e61	0e 26 01	asl $0126	          ASL FLAG
.6e64	90 77		bcc $6edd	          BCC Set_Volume
.6e66	c9 02		cmp #$02	          CMP #2
.6e68	90 03		bcc $6e6d	          BCC PlNo_65
.6e6a	4c fd 6e	jmp $6efd	          JMP Error_Exit
.6e6d	4a		lsr a		PlNo_65   LSR A
.6e6e	ac 2f 12	ldy $122f	          LDY VOICE
.6e71	be e4 6f	ldx $6fe4,y	          LDX times2,Y
.6e74	bd 24 12	lda $1224,x	PlNo_70   LDA Snd_Duration+1,X
.6e77	10 fb		bpl $6e74	          BPL PlNo_70
.6e79	b9 b3 6c	lda $6cb3,y	          LDA Bit_Mask,Y
.6e7c	0d 73 12	ora $1273	          ORA FILTERS+2
.6e7f	b0 03		bcs $6e84	          BCS PlNo_75
.6e81	59 b3 6c	eor $6cb3,y	          EOR Bit_Mask,Y
.6e84	8d 73 12	sta $1273	PlNo_75   STA FILTERS+2
.6e87	ad 74 12	lda $1274	          LDA Old_Filter
.6e8a	8d 75 12	sta $1275	          STA Old_Volume
.6e8d	a2 03		ldx #$03	          LDX #3
.6e8f	bd 71 12	lda $1271,x	PlNo_80   LDA FILTERS,X
.6e92	20 45 a8	jsr $a845	          JSR Map_IO
.6e95	9d 15 d4	sta $d415,x	          STA SID_Cutoff,X
.6e98	ca		dex		          DEX
.6e99	10 f4		bpl $6e8f	          BPL PlNo_80
.6e9b	30 5a		bmi $6ef7	          BMI Clear_FLAG
.6e9d	aa		tax		PlNo_85   TAX
.6e9e	ca		dex		          DEX
.6e9f	e0 03		cpx #$03	          CPX #3
.6ea1	b0 5a		bcs $6efd	          BCS Error_Exit
.6ea3	8e 2f 12	stx $122f	          STX VOICE
.6ea6	90 4f		bcc $6ef7	          BCC Clear_FLAG
.6ea8	c9 07		cmp #$07	PlNo_90   CMP #7
.6eaa	b0 51		bcs $6efd	          BCS Error_Exit
.6eac	8d 2b 12	sta $122b	          STA Snd_Octave
.6eaf	90 46		bcc $6ef7	          BCC Clear_FLAG
.6eb1	aa		tax		PlNo_95   TAX
.6eb2					  Set_Envelope
.6eb2	20 45 a8	jsr $a845	          JSR Map_IO
.6eb5	ac 2f 12	ldy $122f	          LDY VOICE
.6eb8	bd 53 12	lda $1253,x	          LDA WAVTAB,X
.6ebb	99 30 12	sta $1230,y	          STA WAVE0,Y
.6ebe	b9 39 70	lda $7039,y	          LDA offtab,Y
.6ec1	a8		tay		          TAY
.6ec2	bd 3f 12	lda $123f,x	          LDA ATKTAB,X
.6ec5	99 05 d4	sta $d405,y	          STA SID_Attack_1,Y
.6ec8	bd 49 12	lda $1249,x	          LDA SUSTAB,X
.6ecb	99 06 d4	sta $d406,y	          STA SID_Sustain_1,Y
.6ece	bd 5d 12	lda $125d,x	          LDA PULSLO,X
.6ed1	99 02 d4	sta $d402,y	          STA SID_Pulse_1,Y
.6ed4	bd 67 12	lda $1267,x	          LDA PULSHI,X
.6ed7	99 03 d4	sta $d403,y	          STA SID_Pulse_1+1,Y
.6eda	4c f7 6e	jmp $6ef7	          JMP Clear_FLAG
.6edd					  Set_Volume
.6edd	aa		tax		          TAX
.6ede	ad 74 12	lda $1274	          LDA Old_Filter
.6ee1	29 f0		and #$f0	          AND #%11110000 ; $f0
.6ee3	1d 3c 70	ora $703c,x	          ORA voltab,X
.6ee6	8d 74 12	sta $1274	          STA Old_Filter
.6ee9	ad 75 12	lda $1275	          LDA Old_Volume
.6eec	29 f0		and #$f0	          AND #%11110000 ; $f0
.6eee	1d 3c 70	ora $703c,x	          ORA voltab,X
.6ef1	20 45 a8	jsr $a845	          JSR Map_IO
.6ef4	8d 18 d4	sta $d418	          STA SID_Volume
.6ef7					  Clear_FLAG
.6ef7	a9 00		lda #$00	          LDA #0
.6ef9	8d 26 01	sta $0126	          STA FLAG
.6efc	60		rts		          RTS
.6efd					  Error_Exit
.6efd	20 f7 6e	jsr $6ef7	          JSR Clear_FLAG
.6f00	4c 28 7d	jmp $7d28	          JMP Error_Illegal_Quantity
.6f03					  Store_DNOTE
.6f03	8d 33 12	sta $1233	          STA DNOTE
.6f06	60		rts		          RTS
.6f07					  Set_Duration
.6f07	a0 80		ldy #$80	          LDY #<$0480
.6f09	8c 29 12	sty $1229	          STY Snd_Dur_Tmp
.6f0c	a0 04		ldy #$04	          LDY #>$0480
.6f0e	8c 2a 12	sty $122a	          STY Snd_Dur_Tmp+1
.6f11	ca		dex		SeDu_10   DEX
.6f12	30 09		bmi $6f1d	          BMI SeDu_Ret
.6f14	4e 2a 12	lsr $122a	          LSR Snd_Dur_Tmp+1
.6f17	6e 29 12	ror $1229	          ROR Snd_Dur_Tmp
.6f1a	4c 11 6f	jmp $6f11	          JMP SeDu_10
.6f1d	60		rts		SeDu_Ret  RTS
.6f1e					  Set_Note
.6f1e	38		sec		          SEC
.6f1f	e9 41		sbc #$41	          SBC #'A'
.6f21	aa		tax		          TAX
.6f22	bd f2 6f	lda $6ff2,x	          LDA scalen,X
.6f25	aa		tax		          TAX
.6f26	a9 06		lda #$06	          LDA #6
.6f28	38		sec		          SEC
.6f29	ed 2b 12	sbc $122b	          SBC Snd_Octave
.6f2c	a8		tay		          TAY
.6f2d	8a		txa		          TXA
.6f2e	18		clc		          CLC
.6f2f	6d 2c 12	adc $122c	          ADC Snd_Sharp
.6f32	10 03		bpl $6f37	          BPL SeNo_10
.6f34	a9 0b		lda #$0b	          LDA #11
.6f36	c8		iny		          INY
.6f37	c9 0c		cmp #$0c	SeNo_10   CMP #12
.6f39	90 03		bcc $6f3e	          BCC SeNo_20
.6f3b	a9 00		lda #$00	          LDA #0
.6f3d	88		dey		          DEY
.6f3e	aa		tax		SeNo_20   TAX
.6f3f	bd f9 6f	lda $6ff9,x	          LDA Pitch_NTSC_Low,X
.6f42	8d 2d 12	sta $122d	          STA Snd_Pitch
.6f45	20 a6 7e	jsr $7ea6	          JSR Get_Pitch       ; patch for NTSC / PAL pitch
.6f48	88		dey		SeNo_30   DEY
.6f49	30 27		bmi $6f72	          BMI SeNo_70
.6f4b	4a		lsr a		          LSR A
.6f4c	6e 2d 12	ror $122d	          ROR Snd_Pitch
.6f4f	4c 48 6f	jmp $6f48	          JMP SeNo_30
.6f52	c9 4d		cmp #$4d	SeNo_40   CMP #$4d ; 'M'
.6f54	f0 07		beq $6f5d	          BEQ SeNo_50
.6f56	bd 1c 9d	lda $9d1c,x	          LDA rbits,X
.6f59	8d 26 01	sta $0126	          STA FLAG
.6f5c	60		rts		          RTS
.6f5d	a0 05		ldy #$05	SeNo_50   LDY #5
.6f5f	b9 23 12	lda $1223,y	SeNo_60   LDA Snd_Duration,Y
.6f62	10 fb		bpl $6f5f	          BPL SeNo_60
.6f64	88		dey		          DEY
.6f65	88		dey		          DEY
.6f66	10 f7		bpl $6f5f	          BPL SeNo_60
.6f68	60		rts		          RTS
.6f69					  Play_Sharp
.6f69	a9 01		lda #$01	          LDA #1
>6f6b	2c				          .BYTE $2C ;BIT
.6f6c					  Play_Flatc
.6f6c	a9 ff		lda #$ff	          LDA #$ff
.6f6e	8d 2c 12	sta $122c	          STA Snd_Sharp
.6f71	60		rts		          RTS
.6f72	8d 2e 12	sta $122e	SeNo_70   STA Snd_Pitch+1
.6f75	a9 00		lda #$00	          LDA #0
>6f77	2c				          .BYTE $2C ;BIT
.6f78	a9 ff		lda #$ff	SeNo_75   LDA #$ff
.6f7a	48		pha		          PHA
.6f7b	ae 2f 12	ldx $122f	          LDX VOICE
.6f7e	bc e4 6f	ldy $6fe4,x	          LDY times2,X
.6f81	b9 24 12	lda $1224,y	SeNo_80   LDA Snd_Duration+1,Y
.6f84	10 fb		bpl $6f81	          BPL SeNo_80
.6f86	ad 29 12	lda $1229	          LDA Snd_Dur_Tmp
.6f89	99 23 12	sta $1223,y	          STA Snd_Duration,Y
.6f8c	ad 2a 12	lda $122a	          LDA Snd_Dur_Tmp+1
.6f8f	99 24 12	sta $1224,y	          STA Snd_Duration+1,Y
.6f92	ad 33 12	lda $1233	          LDA DNOTE
.6f95	f0 17		beq $6fae	          BEQ SeNo_85
.6f97	ad 2a 12	lda $122a	          LDA Snd_Dur_Tmp+1
.6f9a	4a		lsr a		          LSR A
.6f9b	48		pha		          PHA
.6f9c	ad 29 12	lda $1229	          LDA Snd_Dur_Tmp
.6f9f	6a		ror a		          ROR A
.6fa0	18		clc		          CLC
.6fa1	79 23 12	adc $1223,y	          ADC Snd_Duration,Y
.6fa4	99 23 12	sta $1223,y	          STA Snd_Duration,Y
.6fa7	68		pla		          PLA
.6fa8	79 24 12	adc $1224,y	          ADC Snd_Duration+1,Y
.6fab	99 24 12	sta $1224,y	          STA Snd_Duration+1,Y
.6fae	68		pla		SeNo_85   PLA
.6faf	30 1d		bmi $6fce	          BMI Clear_Tone_Flags
.6fb1	20 45 a8	jsr $a845	          JSR Map_IO
.6fb4	bc 39 70	ldy $7039,x	          LDY offtab,X
.6fb7	ad 2d 12	lda $122d	          LDA Snd_Pitch
.6fba	99 00 d4	sta $d400,y	          STA SID_Freq_1,Y
.6fbd	ad 2e 12	lda $122e	          LDA Snd_Pitch+1
.6fc0	99 01 d4	sta $d401,y	          STA SID_Freq_1+1,Y
.6fc3	a9 08		lda #$08	          LDA #8
.6fc5	99 04 d4	sta $d404,y	          STA SID_Control_1,Y
.6fc8	bd 30 12	lda $1230,x	          LDA WAVE0,X
.6fcb	99 04 d4	sta $d404,y	          STA SID_Control_1,Y
.6fce					  Clear_Tone_Flags
.6fce	a9 00		lda #$00	          LDA #0
.6fd0	8d 2c 12	sta $122c	          STA Snd_Sharp
.6fd3	8d 33 12	sta $1233	          STA DNOTE
.6fd6	60		rts		          RTS
.6fd7					  BASIC_TEMPO
.6fd7	20 f4 87	jsr $87f4	          JSR Get_Byte_Var
.6fda	8a		txa		          TXA
.6fdb	f0 04		beq $6fe1	          BEQ TEMPO_Err
.6fdd	8e 22 12	stx $1222	          STX Snd_Tempo
.6fe0	60		rts		          RTS
.6fe1	4c 28 7d	jmp $7d28	TEMPO_Err JMP Error_Illegal_Quantity
>6fe4	00 02 04			times2    .BYTE $00,$02,$04
>6fe7	57 48 51 49 53			notes     .TEXT "WHQIS"
>6fec	56 4f 54 58 55 4d		mutabl    .TEXT "VOTXUM"
>6ff2	09 0b 00 02 04 05 07		scalen    .BYTE $09,$0b,$00,$02,$04,$05,$07
.6ff9					Pitch_NTSC_Low
>6ff9	0f 0c 45 bf 7d 83 d6 79		          .BYTE $0f,$0c,$45,$bf,$7d,$83,$d6,$79
>7001	73 c7 7c 97			          .BYTE $73,$c7,$7c,$97
.7005					Pitch_NTSC_High
>7005	43 47 4b 4f 54 59 5e 64		          .BYTE $43,$47,$4b,$4f,$54,$59,$5e,$64
>700d	6a 70 77 7e			          .BYTE $6a,$70,$77,$7e
>7011	09 c0 00 05 94 09 09 09		stkmus    .BYTE $09,$c0,$00,$05,$94,$09,$09,$09
>7019	89 09				          .BYTE $89,$09
>701b	00 c0 f0 50 40 21 00 90		susmus    .BYTE $00,$c0,$f0,$50,$40,$21,$00,$90
>7023	41 00				          .BYTE $41,$00
>7025	41 21 11 81 11 21 41 41		wavmus    .BYTE $41,$21,$11,$81,$11,$21,$41,$41
>702d	41 11				          .BYTE $41,$11
>702f	06 00 00 00 00 00 02 08		pwhmus    .BYTE $06,$00,$00,$00,$00,$00,$02,$08
>7037	02 00				          .BYTE $02,$00
>7039	00 07 0e			offtab    .BYTE $00,$07,$0e
>703c	00 01 03 05 07 08 0a 0c		voltab    .BYTE $00,$01,$03,$05,$07,$08,$0a,$0c
>7044	0e 0f				          .BYTE $0e,$0f
.7046					  BASIC_FILTER
.7046	48		pha		          PHA
.7047	a0 03		ldy #$03	          LDY #3
.7049	b9 71 12	lda $1271,y	FILT_10   LDA FILTERS,Y
.704c	99 34 12	sta $1234,y	          STA FLTSAV,Y
.704f	88		dey		          DEY
.7050	10 f7		bpl $7049	          BPL FILT_10
.7052	68		pla		          PLA
.7053	c9 2c		cmp #$2c	          CMP #','
.7055	f0 19		beq $7070	          BEQ FILT_20
.7057	20 12 88	jsr $8812	          JSR Get_Integer
.705a	c9 08		cmp #$08	          CMP #8
.705c	b0 60		bcs $70be	          BCS FILT_Err
.705e	8c 34 12	sty $1234	          STY FLTSAV
.7061	8c 35 12	sty $1235	          STY FLTSAV+1
.7064	4a		lsr a		          LSR A
.7065	6e 35 12	ror $1235	          ROR FLTSAV+1
.7068	4a		lsr a		          LSR A
.7069	6e 35 12	ror $1235	          ROR FLTSAV+1
.706c	4a		lsr a		          LSR A
.706d	6e 35 12	ror $1235	          ROR FLTSAV+1
.7070	a9 10		lda #$10	FILT_20   LDA #16
.7072	8d 38 12	sta $1238	          STA FLTFLG
.7075	20 1e 9e	jsr $9e1e	FILT_30   JSR Get_Byte_Or_Void
.7078	90 17		bcc $7091	          BCC FILT_60
.707a	e0 01		cpx #$01	          CPX #1
.707c	90 05		bcc $7083	          BCC FILT_40
.707e	f0 03		beq $7083	          BEQ FILT_40
.7080	4c 28 7d	jmp $7d28	          JMP Error_Illegal_Quantity
.7083	ad 37 12	lda $1237	FILT_40   LDA FLTSAV+3
.7086	0d 38 12	ora $1238	          ORA FLTFLG
.7089	b0 03		bcs $708e	          BCS FILT_50
.708b	4d 38 12	eor $1238	          EOR FLTFLG
.708e	8d 37 12	sta $1237	FILT_50   STA FLTSAV+3
.7091	0e 38 12	asl $1238	FILT_60   ASL FLTFLG
.7094	10 df		bpl $7075	          BPL FILT_30
.7096	20 1e 9e	jsr $9e1e	          JSR Get_Byte_Or_Void
.7099	90 17		bcc $70b2	          BCC FILT_70
.709b	e0 10		cpx #$10	          CPX #16
.709d	b0 1f		bcs $70be	          BCS FILT_Err
.709f	8a		txa		          TXA
.70a0	0a		asl a		          ASL A
.70a1	0a		asl a		          ASL A
.70a2	0a		asl a		          ASL A
.70a3	0a		asl a		          ASL A
.70a4	8d 39 12	sta $1239	          STA NIBBLE
.70a7	ad 36 12	lda $1236	          LDA FLTSAV+2
.70aa	29 0f		and #$0f	          AND #%00001111 ; $0f
.70ac	0d 39 12	ora $1239	          ORA NIBBLE
.70af	8d 36 12	sta $1236	          STA FLTSAV+2
.70b2	a0 03		ldy #$03	FILT_70   LDY #3
.70b4	b9 34 12	lda $1234,y	FILT_80   LDA FLTSAV,Y
.70b7	99 71 12	sta $1271,y	          STA FILTERS,Y
.70ba	88		dey		          DEY
.70bb	10 f7		bpl $70b4	          BPL FILT_80
.70bd	60		rts		          RTS
.70be	4c 28 7d	jmp $7d28	FILT_Err  JMP Error_Illegal_Quantity
.70c1					  BASIC_ENVELOPE
.70c1	20 f4 87	jsr $87f4	          JSR Get_Byte_Var
.70c4	e0 0a		cpx #$0a	          CPX #10
.70c6	90 03		bcc $70cb	          BCC ENVE_20
.70c8	4c 28 7d	jmp $7d28	ENVE_10   JMP Error_Illegal_Quantity
.70cb	8e 3a 12	stx $123a	ENVE_20   STX TONNUM
.70ce	bd 3f 12	lda $123f,x	          LDA ATKTAB,X
.70d1	8d 3b 12	sta $123b	          STA TONVAL
.70d4	bd 49 12	lda $1249,x	          LDA SUSTAB,X
.70d7	8d 3c 12	sta $123c	          STA TONVAL+1
.70da	bd 53 12	lda $1253,x	          LDA WAVTAB,X
.70dd	8d 3d 12	sta $123d	          STA TONVAL+2
.70e0	a2 00		ldx #$00	          LDX #0
.70e2	8e 3e 12	stx $123e	ENVE_30   STX PARCNT
.70e5	20 1e 9e	jsr $9e1e	          JSR Get_Byte_Or_Void
.70e8	90 16		bcc $7100	          BCC ENVE_40
.70ea	8a		txa		          TXA
.70eb	0a		asl a		          ASL A
.70ec	0a		asl a		          ASL A
.70ed	0a		asl a		          ASL A
.70ee	0a		asl a		          ASL A
.70ef	8d 39 12	sta $1239	          STA NIBBLE
.70f2	ae 3e 12	ldx $123e	          LDX PARCNT
.70f5	bd 3b 12	lda $123b,x	          LDA TONVAL,X
.70f8	29 0f		and #$0f	          AND #%00001111 ; $0f
.70fa	0d 39 12	ora $1239	          ORA NIBBLE
.70fd	9d 3b 12	sta $123b,x	          STA TONVAL,X
.7100	20 1e 9e	jsr $9e1e	ENVE_40   JSR Get_Byte_Or_Void
.7103	90 14		bcc $7119	          BCC ENVE_50
.7105	8a		txa		          TXA
.7106	29 0f		and #$0f	          AND #%00001111 ; $0f
.7108	8d 39 12	sta $1239	          STA NIBBLE
.710b	ae 3e 12	ldx $123e	          LDX PARCNT
.710e	bd 3b 12	lda $123b,x	          LDA TONVAL,X
.7111	29 f0		and #$f0	          AND #%11110000 ; $f0
.7113	0d 39 12	ora $1239	          ORA NIBBLE
.7116	9d 3b 12	sta $123b,x	          STA TONVAL,X
.7119	ae 3e 12	ldx $123e	ENVE_50   LDX PARCNT
.711c	e8		inx		          INX
.711d	e0 01		cpx #$01	          CPX #1
.711f	f0 c1		beq $70e2	          BEQ ENVE_30
.7121	20 1e 9e	jsr $9e1e	          JSR Get_Byte_Or_Void
.7124	90 10		bcc $7136	          BCC ENVE_70
.7126	a9 15		lda #$15	          LDA #$15
.7128	e0 04		cpx #$04	          CPX #4
.712a	f0 07		beq $7133	          BEQ ENVE_60
.712c	b0 9a		bcs $70c8	          BCS ENVE_10
.712e	bd b7 6c	lda $6cb7,x	          LDA Bit_Mask+4,X
.7131	09 01		ora #$01	          ORA #%00000001 ; $01
.7133	8d 3d 12	sta $123d	ENVE_60   STA TONVAL+2
.7136	20 06 9e	jsr $9e06	ENVE_70   JSR Get_Comma_And_Integer
.7139	90 13		bcc $714e	          BCC ENVE_80
.713b	aa		tax		          TAX
.713c	ad 3d 12	lda $123d	          LDA TONVAL+2
.713f	29 40		and #$40	          AND #%01000000 ; $40 ; '@'
.7141	f0 0b		beq $714e	          BEQ ENVE_80
.7143	8a		txa		          TXA
.7144	ae 3a 12	ldx $123a	          LDX TONNUM
.7147	9d 67 12	sta $1267,x	          STA PULSHI,X
.714a	98		tya		          TYA
.714b	9d 5d 12	sta $125d,x	          STA PULSLO,X
.714e	ae 3a 12	ldx $123a	ENVE_80   LDX TONNUM
.7151	ad 3b 12	lda $123b	          LDA TONVAL
.7154	9d 3f 12	sta $123f,x	          STA ATKTAB,X
.7157	ad 3c 12	lda $123c	          LDA TONVAL+1
.715a	9d 49 12	sta $1249,x	          STA SUSTAB,X
.715d	ad 3d 12	lda $123d	          LDA TONVAL+2
.7160	9d 53 12	sta $1253,x	          STA WAVTAB,X
.7163	60		rts		          RTS
.7164					  BASIC_COLLISION
.7164	20 f4 87	jsr $87f4	          JSR Get_Byte_Var
.7167	ca		dex		          DEX
.7168	e0 03		cpx #$03	          CPX #3
.716a	b0 21		bcs $718d	          BCS COLL_Err
.716c	8e 80 12	stx $1280	          STX Collision_Type
.716f	20 06 9e	jsr $9e06	          JSR Get_Comma_And_Integer
.7172	08		php		          PHP
.7173	ae 80 12	ldx $1280	          LDX Collision_Type
.7176	9d 7c 12	sta $127c,x	          STA INT_ADR_HI,X
.7179	98		tya		          TYA
.717a	9d 79 12	sta $1279,x	          STA INT_ADR_LO,X
.717d	ad 7f 12	lda $127f	          LDA INT_VAL
.7180	1d b3 6c	ora $6cb3,x	          ORA Bit_Mask,X
.7183	28		plp		          PLP
.7184	b0 03		bcs $7189	          BCS COLL_10
.7186	5d b3 6c	eor $6cb3,x	          EOR Bit_Mask,X
.7189	8d 7f 12	sta $127f	COLL_10   STA INT_VAL
.718c	60		rts		          RTS
.718d	4c 28 7d	jmp $7d28	COLL_Err  JMP Error_Illegal_Quantity
.7190					  BASIC_SPRCOLOR
.7190	c9 2c		cmp #$2c	          CMP #$2c ; ','
.7192	f0 0e		beq $71a2	          BEQ SPRC_10
.7194	20 f4 87	jsr $87f4	          JSR Get_Byte_Var
.7197	ca		dex		          DEX
.7198	e0 10		cpx #$10	          CPX #16
.719a	b0 17		bcs $71b3	          BCS SPRC_Err
.719c	20 45 a8	jsr $a845	          JSR Map_IO
.719f	8e 25 d0	stx $d025	          STX Vd025
.71a2	20 1e 9e	jsr $9e1e	SPRC_10   JSR Get_Byte_Or_Void
.71a5	90 0b		bcc $71b2	          BCC SPRC_Ret
.71a7	ca		dex		          DEX
.71a8	e0 10		cpx #$10	          CPX #16
.71aa	b0 07		bcs $71b3	          BCS SPRC_Err
.71ac	20 45 a8	jsr $a845	          JSR Map_IO
.71af	8e 26 d0	stx $d026	          STX Vd026
.71b2	60		rts		SPRC_Ret  RTS
.71b3	4c 28 7d	jmp $7d28	SPRC_Err  JMP Error_Illegal_Quantity
.71b6					  BASIC_WIDTH
.71b6	20 f4 87	jsr $87f4	          JSR Get_Byte_Var
.71b9	ca		dex		          DEX
.71ba	e0 02		cpx #$02	          CPX #2
.71bc	b0 04		bcs $71c2	          BCS WIDT_Err
.71be	8e 6b 11	stx $116b	          STX WIDTH
.71c1	60		rts		          RTS
.71c2	4c 28 7d	jmp $7d28	WIDT_Err  JMP Error_Illegal_Quantity
.71c5					  BASIC_VOL
.71c5	20 f4 87	jsr $87f4	          JSR Get_Byte_Var
.71c8	e0 10		cpx #$10	          CPX #16
.71ca	b0 1d		bcs $71e9	          BCS VOL_Err
.71cc	86 77		stx $77		          STX TEMP_A
.71ce	ad 74 12	lda $1274	          LDA Old_Filter
.71d1	29 f0		and #$f0	          AND #%11110000 ; $f0
.71d3	05 77		ora $77		          ORA TEMP_A
.71d5	8d 74 12	sta $1274	          STA Old_Filter
.71d8	ad 75 12	lda $1275	          LDA Old_Volume
.71db	29 f0		and #$f0	          AND #%11110000 ; $f0
.71dd	05 77		ora $77		          ORA TEMP_A
.71df	8d 75 12	sta $1275	          STA Old_Volume
.71e2	20 45 a8	jsr $a845	          JSR Map_IO
.71e5	8d 18 d4	sta $d418	          STA SID_Volume
.71e8	60		rts		          RTS
.71e9	4c 28 7d	jmp $7d28	VOL_Err   JMP Error_Illegal_Quantity
.71ec					  BASIC_SOUND
.71ec	20 f4 87	jsr $87f4	          JSR Get_Byte_Var
.71ef	ca		dex		          DEX
.71f0	e0 03		cpx #$03	          CPX #3
.71f2	90 03		bcc $71f7	          BCC SOUND_10
.71f4	4c 28 7d	jmp $7d28	SOUND_Err JMP Error_Illegal_Quantity
.71f7	8e 81 12	stx $1281	SOUND_10  STX Voice_Number
.71fa	20 0f 88	jsr $880f	          JSR Comma_And_LINNUM
.71fd	8c a5 12	sty $12a5	          STY TEMP_MAX_LO
.7200	8d a6 12	sta $12a6	          STA TEMP_MAX_HI
.7203	8c ac 12	sty $12ac	          STY TEMP_FREQ_LO
.7206	8d ad 12	sta $12ad	          STA TEMP_FREQ_HI
.7209	20 0f 88	jsr $880f	          JSR Comma_And_LINNUM
.720c	c9 80		cmp #$80	          CMP #$80
.720e	b0 e4		bcs $71f4	          BCS SOUND_Err
.7210	8c a3 12	sty $12a3	          STY TEMP_TIME_LO
.7213	8d a4 12	sta $12a4	          STA TEMP_TIME_HI
.7216	20 1c 9e	jsr $9e1c	          JSR Get_Byte_Or_Zero
.7219	e0 03		cpx #$03	          CPX #3
.721b	b0 d7		bcs $71f4	SOUND_15  BCS SOUND_Err
.721d	8a		txa		          TXA
.721e	8d a9 12	sta $12a9	          STA TEMP_DIRECTION
.7221	29 01		and #$01	          AND #%00000001 ; $01
.7223	08		php		          PHP
.7224	20 06 9e	jsr $9e06	          JSR Get_Comma_And_Integer
.7227	8c a7 12	sty $12a7	          STY TEMP_MIN_LO
.722a	8d a8 12	sta $12a8	          STA TEMP_MIN_HI
.722d	20 06 9e	jsr $9e06	          JSR Get_Comma_And_Integer
.7230	28		plp		          PLP
.7231	f0 0d		beq $7240	          BEQ SOUND_20
.7233	48		pha		          PHA
.7234	98		tya		          TYA
.7235	49 ff		eor #$ff	          EOR #%11111111 ; $ff
.7237	18		clc		          CLC
.7238	69 01		adc #$01	          ADC #1
.723a	a8		tay		          TAY
.723b	68		pla		          PLA
.723c	49 ff		eor #$ff	          EOR #%11111111 ; $ff
.723e	69 00		adc #$00	          ADC #0
.7240	8d ab 12	sta $12ab	SOUND_20  STA TEMP_STEP_HI
.7243	98		tya		          TYA
.7244	8d aa 12	sta $12aa	          STA TEMP_STEP_LO
.7247	a2 02		ldx #$02	          LDX #2
.7249	20 1e 9e	jsr $9e1e	          JSR Get_Byte_Or_Void
.724c	e0 04		cpx #$04	          CPX #4
.724e	b0 cb		bcs $721b	          BCS SOUND_15
.7250	bd b7 6c	lda $6cb7,x	          LDA Bit_Mask+4,X
.7253	09 01		ora #$01	          ORA #%00000001 ; $01
.7255	8d b0 12	sta $12b0	          STA TEMP_WAVEFORM
.7258	20 06 9e	jsr $9e06	          JSR Get_Comma_And_Integer
.725b	b0 04		bcs $7261	          BCS SOUND_25
.725d	a9 08		lda #$08	          LDA #8
.725f	a0 00		ldy #$00	          LDY #0
.7261	c9 10		cmp #$10	SOUND_25  CMP #16
.7263	b0 8f		bcs $71f4	          BCS SOUND_Err
.7265	8c ae 12	sty $12ae	          STY TEMP_PULSE_LO
.7268	8d af 12	sta $12af	          STA TEMP_PULSE_HI
.726b	ad a3 12	lda $12a3	          LDA TEMP_TIME_LO
.726e	0d a4 12	ora $12a4	          ORA TEMP_TIME_HI
.7271	f0 46		beq $72b9	          BEQ SOUND_50
.7273	ae 81 12	ldx $1281	          LDX Voice_Number
.7276	8a		txa		          TXA
.7277	0a		asl a		          ASL A
.7278	a8		tay		          TAY
.7279	b9 24 12	lda $1224,y	SOUND_30  LDA Snd_Duration+1,Y
.727c	10 fb		bpl $7279	          BPL SOUND_30
.727e	bd 85 12	lda $1285,x	SOUND_35  LDA Sound_Duration_1_Hi,X
.7281	10 fb		bpl $727e	          BPL SOUND_35
.7283	a0 00		ldy #$00	          LDY #0
.7285	b9 a5 12	lda $12a5,y	SOUND_40  LDA TEMP_MAX_LO,Y
.7288	9d 88 12	sta $1288,x	          STA SOUND_MAX_LO,X
.728b	e8		inx		          INX
.728c	e8		inx		          INX
.728d	e8		inx		          INX
.728e	c8		iny		          INY
.728f	c0 09		cpy #$09	          CPY #9
.7291	d0 f2		bne $7285	          BNE SOUND_40
.7293	ae 81 12	ldx $1281	          LDX Voice_Number
.7296	bc 39 70	ldy $7039,x	          LDY offtab,X
.7299	20 45 a8	jsr $a845	          JSR Map_IO
.729c	a9 08		lda #$08	          LDA #8
.729e	99 04 d4	sta $d404,y	          STA SID_Control_1,Y
.72a1	a9 00		lda #$00	          LDA #0
.72a3	99 05 d4	sta $d405,y	          STA SID_Attack_1,Y
.72a6	a9 f0		lda #$f0	          LDA #$f0
.72a8	99 06 d4	sta $d406,y	          STA SID_Sustain_1,Y
.72ab	a2 00		ldx #$00	          LDX #0
.72ad	bd ac 12	lda $12ac,x	SOUND_45  LDA TEMP_FREQ_LO,X
.72b0	99 00 d4	sta $d400,y	          STA SID_Freq_1,Y
.72b3	c8		iny		          INY
.72b4	e8		inx		          INX
.72b5	e0 05		cpx #$05	          CPX #5
.72b7	d0 f4		bne $72ad	          BNE SOUND_45
.72b9	ae 81 12	ldx $1281	SOUND_50  LDX Voice_Number
.72bc	ac a3 12	ldy $12a3	          LDY TEMP_TIME_LO
.72bf	ad a4 12	lda $12a4	          LDA TEMP_TIME_HI
.72c2	78		sei		          SEI
.72c3	9d 85 12	sta $1285,x	          STA Sound_Duration_1_Hi,X
.72c6	98		tya		          TYA
.72c7	9d 82 12	sta $1282,x	          STA Sound_Duration_1_Lo,X
.72ca	58		cli		          CLI
.72cb	60		rts		          RTS
.72cc					  BASIC_WINDOW
.72cc	20 f4 87	jsr $87f4	          JSR Get_Byte_Var
.72cf	e0 28		cpx #$28	          CPX #40             ; limit for 40 column screen
.72d1	24 d7		bit $d7		          BIT MODE_80
.72d3	10 02		bpl $72d7	          BPL WIND_10
.72d5	e0 50		cpx #$50	          CPX #80             ; limit for 80 column screen
.72d7	b0 59		bcs $7332	WIND_10   BCS WIND_Err
.72d9	8e b3 12	stx $12b3	          STX Win_XL
.72dc	20 09 88	jsr $8809	          JSR Comma_And_Byte
.72df	e0 19		cpx #$19	          CPX #25             ; row limit
.72e1	b0 4f		bcs $7332	          BCS WIND_Err
.72e3	8e b4 12	stx $12b4	          STX Win_YL
.72e6	20 09 88	jsr $8809	          JSR Comma_And_Byte
.72e9	e0 28		cpx #$28	          CPX #40             ; limit for 40 column screen
.72eb	24 d7		bit $d7		          BIT MODE_80
.72ed	10 02		bpl $72f1	          BPL WIND_20
.72ef	e0 50		cpx #$50	          CPX #80             ; limit for 80 column screen
.72f1	b0 3f		bcs $7332	WIND_20   BCS WIND_Err
.72f3	8e b5 12	stx $12b5	          STX Win_XH
.72f6	ec b3 12	cpx $12b3	          CPX Win_XL
.72f9	90 37		bcc $7332	          BCC WIND_Err
.72fb	20 09 88	jsr $8809	          JSR Comma_And_Byte
.72fe	e0 19		cpx #$19	          CPX #25
.7300	b0 30		bcs $7332	          BCS WIND_Err
.7302	8e b6 12	stx $12b6	          STX Win_YH
.7305	ec b4 12	cpx $12b4	          CPX Win_YL
.7308	90 28		bcc $7332	          BCC WIND_Err
.730a	20 1c 9e	jsr $9e1c	          JSR Get_Byte_Or_Zero
.730d	e0 02		cpx #$02	          CPX #2
.730f	b0 21		bcs $7332	          BCS WIND_Err
.7311	8a		txa		          TXA
.7312	48		pha		          PHA
.7313	ae b3 12	ldx $12b3	          LDX Win_XL
.7316	ad b4 12	lda $12b4	          LDA Win_YL
.7319	18		clc		          CLC
.731a	20 2d c0	jsr $c02d	          JSR E_WINDOW
.731d	ae b5 12	ldx $12b5	          LDX Win_XH
.7320	ad b6 12	lda $12b6	          LDA Win_YH
.7323	38		sec		          SEC
.7324	20 2d c0	jsr $c02d	          JSR E_WINDOW
.7327	a2 13		ldx #$13	          LDX #$13            ; HOME
.7329	68		pla		          PLA
.732a	f0 02		beq $732e	          BEQ WIND_30
.732c	a2 93		ldx #$93	          LDX #$93            ; CLR
.732e	8a		txa		WIND_30   TXA
.732f	4c 69 92	jmp $9269	          JMP B_BSOUT
.7332	4c 28 7d	jmp $7d28	WIND_Err  JMP Error_Illegal_Quantity
.7335					  BASIC_BOOT
.7335	a9 e6		lda #$e6	          LDA #$e6
.7337	a2 fc		ldx #$fc	          LDX #$fc
.7339	20 c3 a3	jsr $a3c3	          JSR DOS_Parser_AX
.733c	a5 80		lda $80		          LDA DOSFLA
.733e	4a		lsr a		          LSR A
.733f	90 1d		bcc $735e	          BCC BABO_20
.7341	20 1f a2	jsr $a21f	          JSR BLOAD
.7344	b0 29		bcs $736f	          BCS BABO_Err
.7346	ae d5 03	ldx $03d5	          LDX USER_BANK
.7349	a5 81		lda $81		          LDA DOSFLB
.734b	4a		lsr a		          LSR A
.734c	90 03		bcc $7351	          BCC BABO_10
.734e	ae 1f 01	ldx $011f	          LDX DOS_BANK
.7351	86 02		stx $02		BABO_10   STX BANK
.7353	a5 ac		lda $ac		          LDA SAL
.7355	85 04		sta $04		          STA PC_LO
.7357	a5 ad		lda $ad		          LDA SAH
.7359	85 03		sta $03		          STA PC_HI
.735b	4c 6e ff	jmp $ff6e	          JMP K_JSRFAR
.735e	ad 12 01	lda $0112	BABO_20   LDA DOS_DRIVE_1
.7361	09 30		ora #$30	          ORA #'0'
.7363	ae 1c 01	ldx $011c	          LDX DOS_FA
.7366	20 45 a8	jsr $a845	          JSR Map_IO
.7369	20 53 ff	jsr $ff53	          JSR K_BOOT
.736c	b0 01		bcs $736f	          BCS BABO_Err
.736e	60		rts		          RTS
.736f	4c d0 90	jmp $90d0	BABO_Err  JMP Break_On_Error
.7372					  BASIC_SPRDEF
.7372	20 4f 9f	jsr $9f4f	          JSR Allocate_Graphics_RAM
.7375	20 45 a8	jsr $a845	          JSR Map_IO
.7378	a9 d0		lda #$d0	          LDA #$d0
.737a	8d 68 11	sta $1168	          STA CHRPAG          ; $d000 : character rom
.737d	a9 20		lda #$20	          LDA #$20
.737f	85 d8		sta $d8		          STA GRAPHM          ; $2000 : graphics screen
.7381	20 30 6b	jsr $6b30	          JSR Clear_Graphics_RAM
.7384	a0 80		ldy #$80	          LDY #$80
.7386	8c 3d 11	sty $113d	          STY XSGN
.7389	a0 18		ldy #$18	          LDY #24             ; display
.738b	a9 20		lda #$20	          LDA #' '
.738d	a2 00		ldx #$00	          LDX #0
.738f	20 db 68	jsr $68db	SPRD_05   JSR Display_Character
.7392	e8		inx		          INX
.7393	e0 15		cpx #$15	          CPX #21             ; display 21 blanks
.7395	90 f8		bcc $738f	          BCC SPRD_05
.7397	20 db 68	jsr $68db	SPRD_10   JSR Display_Character
.739a	88		dey		          DEY
.739b	10 fa		bpl $7397	          BPL SPRD_10
.739d	20 45 a8	jsr $a845	          JSR Map_IO
.73a0	a5 f1		lda $f1		          LDA E_Attribute
.73a2	48		pha		          PHA
.73a3	ad 21 d0	lda $d021	          LDA VIC_BG_COL
.73a6	85 f1		sta $f1		          STA E_Attribute
.73a8	a9 2b		lda #$2b	          LDA #'+'            ; sprite cursor
.73aa	a2 00		ldx #$00	          LDX #0
.73ac	8e 3d 11	stx $113d	          STX XSGN
.73af	a0 00		ldy #$00	SPRD_15   LDY #0
.73b1	20 db 68	jsr $68db	SPRD_20   JSR Display_Character
.73b4	c8		iny		          INY
.73b5	c0 18		cpy #$18	          CPY #24
.73b7	90 f8		bcc $73b1	          BCC SPRD_20
.73b9	e8		inx		          INX
.73ba	e0 15		cpx #$15	          CPX #21
.73bc	90 f1		bcc $73af	          BCC SPRD_15
.73be	68		pla		          PLA
.73bf	85 f1		sta $f1		          STA E_Attribute
.73c1	20 d4 76	jsr $76d4	          JSR Clear_Sprite
.73c4	a0 02		ldy #$02	SPRD_25   LDY #2
.73c6	a2 17		ldx #$17	          LDX #$17
.73c8	b9 6c 76	lda $766c,y	SPRD_30   LDA SPRITE_NO-2,Y
.73cb	f0 06		beq $73d3	          BEQ SPRD_35
.73cd	20 db 68	jsr $68db	          JSR Display_Character
.73d0	c8		iny		          INY
.73d1	d0 f5		bne $73c8	          BNE SPRD_30
.73d3	20 45 a8	jsr $a845	SPRD_35   JSR Map_IO
.73d6	20 e4 ff	jsr $ffe4	SPRD_40   JSR K_GETIN
.73d9	f0 fb		beq $73d6	          BEQ SPRD_40
.73db	c9 0d		cmp #$0d	          CMP #CR
.73dd	d0 08		bne $73e7	          BNE SPRD_45
.73df	20 30 6b	jsr $6b30	          JSR Clear_Graphics_RAM
.73e2	a9 00		lda #$00	          LDA #0
.73e4	85 d8		sta $d8		          STA GRAPHM
.73e6	60		rts		          RTS
.73e7	38		sec		SPRD_45   SEC
.73e8	e9 31		sbc #$31	          SBC #'1'
.73ea	8d fc 12	sta $12fc	          STA SPRNUM
.73ed	c9 08		cmp #$08	          CMP #8
.73ef	b0 e5		bcs $73d6	          BCS SPRD_40
.73f1	aa		tax		          TAX
.73f2	0a		asl a		          ASL A
.73f3	a8		tay		          TAY
.73f4	bd b3 6c	lda $6cb3,x	          LDA Bit_Mask,X
.73f7	8d 6d 11	sta $116d	          STA BITMSK
.73fa	2d 1c d0	and $d01c	          AND Vd01c
.73fd	f0 02		beq $7401	          BEQ SPRD_50
.73ff	a9 80		lda #$80	          LDA #$80
.7401	8d fa 12	sta $12fa	SPRD_50   STA DEFMOD
.7404	a9 08		lda #$08	          LDA #8
.7406	99 d6 11	sta $11d6,y	          STA VSH,Y
.7409	a9 4a		lda #$4a	          LDA #$4a ; 'J'
.740b	99 d7 11	sta $11d7,y	          STA VSH+1,Y
.740e	ad 6d 11	lda $116d	          LDA BITMSK
.7411	0d e6 11	ora $11e6	          ORA VSH+16
.7414	8d e6 11	sta $11e6	          STA VSH+16
.7417	ad 6d 11	lda $116d	          LDA BITMSK
.741a	8d 15 d0	sta $d015	          STA VIC_SPR_ENA
.741d	ae fc 12	ldx $12fc	          LDX SPRNUM
.7420	bc d9 6d	ldy $6dd9,x	          LDY Sprite_Offset,X
.7423	a9 00		lda #$00	          LDA #0
.7425	99 7e 11	sta $117e,y	          STA SPRITE_DATA,Y
.7428	8a		txa		          TXA
.7429	a0 11		ldy #$11	          LDY #$11
.742b	a2 17		ldx #$17	          LDX #$17
.742d	18		clc		          CLC
.742e	69 31		adc #$31	          ADC #'1'
.7430	20 db 68	jsr $68db	          JSR Display_Character
.7433	20 45 a8	jsr $a845	          JSR Map_IO
.7436	ad fc 12	lda $12fc	          LDA SPRNUM
.7439	4a		lsr a		          LSR A
.743a	6a		ror a		          ROR A
.743b	6a		ror a		          ROR A
.743c	85 4b		sta $4b		          STA FORPNT
.743e	a0 0e		ldy #$0e	          LDY #14
.7440	90 01		bcc $7443	          BCC SPRD_55
.7442	c8		iny		          INY
.7443	84 4c		sty $4c		SPRD_55   STY FORPNT+1
.7445	20 d1 75	jsr $75d1	          JSR Show_Sprite
.7448	a0 3f		ldy #$3f	          LDY #$3f
.744a	b1 4b		lda ($4b),y	SPRD_60   LDA (FORPNT),Y
.744c	99 b7 12	sta $12b7,y	          STA SAVRAM,Y
.744f	88		dey		          DEY
.7450	10 f8		bpl $744a	          BPL SPRD_60
.7452	a2 00		ldx #$00	SPRD_65   LDX #0
.7454	8e 5f 11	stx $115f	          STX ANGEND+1
.7457	8e 5e 11	stx $115e	          STX ANGEND
.745a	20 4a 76	jsr $764a	SPRD_70   JSR Show_Sprite_Cursor
.745d	20 e4 ff	jsr $ffe4	SPRD_75   JSR K_GETIN
.7460	f0 fb		beq $745d	          BEQ SPRD_75
.7462	48		pha		          PHA
.7463	20 4a 76	jsr $764a	          JSR Show_Sprite_Cursor
.7466	68		pla		          PLA
.7467	a2 10		ldx #$10	          LDX #16
.7469	dd b4 76	cmp $76b4,x	SPRD_80   CMP SPRITECOL-1,X
.746c	d0 0d		bne $747b	          BNE SPRD_85
.746e	ca		dex		          DEX
.746f	8a		txa		          TXA
.7470	ae fc 12	ldx $12fc	          LDX SPRNUM
.7473	9d 27 d0	sta $d027,x	          STA Vd027,X
.7476	20 d1 75	jsr $75d1	          JSR Show_Sprite
.7479	b0 df		bcs $745a	          BCS SPRD_70
.747b	ca		dex		SPRD_85   DEX
.747c	d0 eb		bne $7469	          BNE SPRD_80
.747e	a2 11		ldx #$11	          LDX #$11
.7480	dd 7f 76	cmp $767f,x	SPRD_90   CMP SPRITECMD,X
.7483	f0 05		beq $748a	          BEQ SPRD_95
.7485	ca		dex		          DEX
.7486	10 f8		bpl $7480	          BPL SPRD_90
.7488	30 d0		bmi $745a	          BMI SPRD_70
.748a	8a		txa		SPRD_95   TXA
.748b	a8		tay		          TAY
.748c	0a		asl a		          ASL A
.748d	aa		tax		          TAX
.748e	bd 91 76	lda $7691,x	          LDA Sprite_Jump_Table,X
.7491	48		pha		          PHA
.7492	bd 92 76	lda $7692,x	          LDA Sprite_Jump_Table+1,X
.7495	48		pha		          PHA
.7496	60		rts		          RTS
.7497					  SPR_Pixel
.7497	98		tya		          TYA
.7498	85 8f		sta $8f		          STA VTEMPA+1
.749a	20 10 76	jsr $7610	          JSR Load_Sprite_Color
.749d	48		pha		          PHA
.749e	ac 5e 11	ldy $115e	          LDY ANGEND
.74a1	ae 5f 11	ldx $115f	          LDX ANGEND+1
.74a4	20 c5 76	jsr $76c5	          JSR Set_Graphics_Pointer
.74a7	68		pla		          PLA
.74a8	20 3f 76	jsr $763f	          JSR Store_Graphic_Byte
.74ab	ac 5e 11	ldy $115e	          LDY ANGEND
.74ae	98		tya		          TYA
.74af	29 07		and #$07	          AND #%00000111 ; $07
.74b1	aa		tax		          TAX
.74b2	98		tya		          TYA
.74b3	4a		lsr a		          LSR A
.74b4	4a		lsr a		          LSR A
.74b5	4a		lsr a		          LSR A
.74b6	18		clc		          CLC
.74b7	6d 5f 11	adc $115f	          ADC ANGEND+1
.74ba	6d 5f 11	adc $115f	          ADC ANGEND+1
.74bd	6d 5f 11	adc $115f	          ADC ANGEND+1
.74c0	a8		tay		          TAY
.74c1	b1 4b		lda ($4b),y	          LDA (FORPNT),Y
.74c3	2c fa 12	bit $12fa	          BIT DEFMOD
.74c6	10 18		bpl $74e0	          BPL SPix_10
.74c8	85 8e		sta $8e		          STA VTEMPA
.74ca	bd 1c 9d	lda $9d1c,x	          LDA rbits,X
.74cd	1d 1d 9d	ora $9d1d,x	          ORA rbits+1,X
.74d0	48		pha		          PHA
.74d1	05 8e		ora $8e		          ORA VTEMPA
.74d3	85 8e		sta $8e		          STA VTEMPA
.74d5	68		pla		          PLA
.74d6	a6 8f		ldx $8f		          LDX VTEMPA+1
.74d8	3d 25 9f	and $9f25,x	          AND colval,X
.74db	45 8e		eor $8e		          EOR VTEMPA
.74dd	4c ea 74	jmp $74ea	          JMP SPix_12
.74e0	1d 1c 9d	ora $9d1c,x	SPix_10   ORA rbits,X
.74e3	06 8f		asl $8f		          ASL VTEMPA+1
.74e5	d0 03		bne $74ea	          BNE SPix_12
.74e7	5d 1c 9d	eor $9d1c,x	          EOR rbits,X
.74ea	91 4b		sta ($4b),y	SPix_12   STA (FORPNT),Y
.74ec	2c fa 12	bit $12fa	          BIT DEFMOD
.74ef	50 4e		bvc $753f	          BVC SPix_30
.74f1	4c 5a 74	jmp $745a	          JMP SPRD_70
.74f4	a0 3f		ldy #$3f	SPix_14   LDY #$3f
.74f6	b9 b7 12	lda $12b7,y	SPix_16   LDA SAVRAM,Y
.74f9	91 4b		sta ($4b),y	          STA (FORPNT),Y
.74fb	88		dey		          DEY
.74fc	10 f8		bpl $74f6	          BPL SPix_16
.74fe	a9 00		lda #$00	SPix_18   LDA #0
.7500	8d 15 d0	sta $d015	          STA VIC_SPR_ENA
.7503	4c c4 73	jmp $73c4	          JMP SPRD_25
.7506	ad fa 12	lda $12fa	SPix_20   LDA DEFMOD
.7509	49 80		eor #$80	          EOR #%10000000 ; $80
.750b	8d fa 12	sta $12fa	          STA DEFMOD
.750e	20 d1 75	jsr $75d1	          JSR Show_Sprite
.7511	ad 5e 11	lda $115e	          LDA ANGEND
.7514	29 fe		and #$fe	          AND #%11111110 ; $fe
.7516	8d 5e 11	sta $115e	          STA ANGEND
.7519	a0 1c		ldy #$1c	          LDY #$1c
>751b	2c				          .BYTE $2C ;BIT
.751c	a0 17		ldy #$17	SPix_22   LDY #$17
>751e	2c				          .BYTE $2C ;BIT
.751f	a0 1d		ldy #$1d	SPix_24   LDY #$1d
.7521	b9 00 d0	lda $d000,y	          LDA VIC,Y
.7524	ae fc 12	ldx $12fc	          LDX SPRNUM
.7527	5d b3 6c	eor $6cb3,x	          EOR Bit_Mask,X
.752a	99 00 d0	sta $d000,y	          STA VIC,Y
.752d	4c 5a 74	jmp $745a	          JMP SPRD_70
.7530	a0 3f		ldy #$3f	SPix_26   LDY #$3f
.7532	a9 00		lda #$00	          LDA #0
.7534	91 4b		sta ($4b),y	SPix_28   STA (FORPNT),Y
.7536	88		dey		          DEY
.7537	10 fb		bpl $7534	          BPL SPix_28
.7539	20 d4 76	jsr $76d4	          JSR Clear_Sprite
.753c	4c 52 74	jmp $7452	          JMP SPRD_65
.753f	a9 01		lda #$01	SPix_30   LDA #1
>7541	2c				          .BYTE $2C ;BIT
.7542	a9 ff		lda #$ff	SPix_32   LDA #$ff
.7544	2c fa 12	bit $12fa	          BIT DEFMOD
.7547	10 01		bpl $754a	          BPL SPix_34
.7549	0a		asl a		          ASL A
.754a	18		clc		SPix_34   CLC
.754b	6d 5e 11	adc $115e	          ADC ANGEND
.754e	30 09		bmi $7559	          BMI SPix_36
.7550	c9 18		cmp #$18	          CMP #$18
.7552	b0 2d		bcs $7581	          BCS SPix_48
.7554	8d 5e 11	sta $115e	          STA ANGEND
.7557	90 25		bcc $757e	          BCC SPix_46
.7559	a2 17		ldx #$17	SPix_36   LDX #$17
.755b	2c fa 12	bit $12fa	          BIT DEFMOD
.755e	10 01		bpl $7561	          BPL SPix_38
.7560	ca		dex		          DEX
.7561	8e 5e 11	stx $115e	SPix_38   STX ANGEND
.7564	a9 ff		lda #$ff	SPix_40   LDA #$ff
>7566	2c				          .BYTE $2C ;BIT
.7567	a9 01		lda #$01	SPix_42   LDA #1
.7569	18		clc		          CLC
.756a	6d 5f 11	adc $115f	          ADC ANGEND+1
.756d	c9 15		cmp #$15	          CMP #$15
.756f	b0 0d		bcs $757e	          BCS SPix_46
.7571	8d 5f 11	sta $115f	          STA ANGEND+1
.7574	90 08		bcc $757e	          BCC SPix_46
.7576	ad fa 12	lda $12fa	SPix_44   LDA DEFMOD
.7579	49 40		eor #$40	          EOR #%01000000 ; $40 ; '@'
.757b	8d fa 12	sta $12fa	          STA DEFMOD
.757e	4c 5a 74	jmp $745a	SPix_46   JMP SPRD_70
.7581	a9 00		lda #$00	SPix_48   LDA #0
.7583	8d 5e 11	sta $115e	          STA ANGEND
.7586	f0 df		beq $7567	          BEQ SPix_42
.7588	a0 02		ldy #$02	SPix_50   LDY #2
.758a	a2 18		ldx #$18	          LDX #$18
.758c	b9 61 76	lda $7661,y	SPix_52   LDA COPY_FROM-2,Y
.758f	f0 06		beq $7597	          BEQ SPix_54
.7591	20 db 68	jsr $68db	          JSR Display_Character
.7594	c8		iny		          INY
.7595	d0 f5		bne $758c	          BNE SPix_52
.7597	20 45 a8	jsr $a845	SPix_54   JSR Map_IO
.759a	20 e4 ff	jsr $ffe4	SPix_56   JSR K_GETIN
.759d	f0 fb		beq $759a	          BEQ SPix_56
.759f	c9 0d		cmp #$0d	          CMP #CR
.75a1	f0 1f		beq $75c2	          BEQ SPix_62
.75a3	38		sec		          SEC
.75a4	e9 31		sbc #$31	          SBC #$31 ; '1'
.75a6	c9 08		cmp #$08	          CMP #8
.75a8	b0 f0		bcs $759a	          BCS SPix_56
.75aa	4a		lsr a		          LSR A
.75ab	6a		ror a		          ROR A
.75ac	6a		ror a		          ROR A
.75ad	85 8e		sta $8e		          STA VTEMPA
.75af	a0 0e		ldy #$0e	          LDY #14
.75b1	90 01		bcc $75b4	          BCC SPix_58
.75b3	c8		iny		          INY
.75b4	84 8f		sty $8f		SPix_58   STY VTEMPA+1
.75b6	a0 3f		ldy #$3f	          LDY #$3f
.75b8	b1 8e		lda ($8e),y	SPix_60   LDA (VTEMPA),Y
.75ba	91 4b		sta ($4b),y	          STA (FORPNT),Y
.75bc	88		dey		          DEY
.75bd	10 f9		bpl $75b8	          BPL SPix_60
.75bf	20 d1 75	jsr $75d1	          JSR Show_Sprite
.75c2	a9 00		lda #$00	SPix_62   LDA #0
.75c4	a8		tay		          TAY
.75c5	99 00 3e	sta $3e00,y	SPix_64   STA V3e00,Y
.75c8	88		dey		          DEY
.75c9	d0 fa		bne $75c5	          BNE SPix_64
.75cb	4c 5a 74	jmp $745a	          JMP SPRD_70
>75ce	ff ff ff			          .BYTE $ff,$ff,$ff ; unused
.75d1					  Show_Sprite
.75d1	a2 00		ldx #$00	          LDX #0
.75d3	8e 60 11	stx $1160	          STX XRCOS
.75d6	8e fb 12	stx $12fb	ShSp_10   STX LINCNT
.75d9	20 c5 76	jsr $76c5	          JSR Set_Graphics_Pointer
.75dc	a0 00		ldy #$00	          LDY #0
.75de	a2 08		ldx #$08	ShSp_20   LDX #8
.75e0	8c 6e 11	sty $116e	          STY NUMCNT
.75e3	ac 60 11	ldy $1160	          LDY XRCOS
.75e6	b1 4b		lda ($4b),y	          LDA (FORPNT),Y
.75e8	ee 60 11	inc $1160	          INC XRCOS
.75eb	ac 6e 11	ldy $116e	          LDY NUMCNT
.75ee	0a		asl a		ShSp_30   ASL A
.75ef	2c fa 12	bit $12fa	          BIT DEFMOD
.75f2	10 02		bpl $75f6	          BPL ShSp_40
.75f4	2a		rol a		          ROL A
.75f5	ca		dex		          DEX
.75f6	48		pha		ShSp_40   PHA
.75f7	2a		rol a		          ROL A
.75f8	20 10 76	jsr $7610	          JSR Load_Sprite_Color
.75fb	20 3f 76	jsr $763f	          JSR Store_Graphic_Byte
.75fe	c8		iny		          INY
.75ff	68		pla		          PLA
.7600	ca		dex		          DEX
.7601	d0 eb		bne $75ee	          BNE ShSp_30
.7603	c0 18		cpy #$18	          CPY #$18
.7605	90 d7		bcc $75de	          BCC ShSp_20
.7607	ae fb 12	ldx $12fb	          LDX LINCNT
.760a	e8		inx		          INX
.760b	e0 15		cpx #$15	          CPX #$15
.760d	90 c7		bcc $75d6	          BCC ShSp_10
.760f	60		rts		          RTS
.7610					  Load_Sprite_Color
.7610	29 03		and #$03	          AND #3
.7612	4a		lsr a		          LSR A
.7613	6a		ror a		          ROR A
.7614	f0 0f		beq $7625	          BEQ LSC_10
.7616	2c fa 12	bit $12fa	          BIT DEFMOD
.7619	10 0f		bpl $762a	          BPL LSC_20
.761b	ad 25 d0	lda $d025	          LDA Vd025
.761e	90 14		bcc $7634	          BCC Expand_Color_Nibble
.7620	ad 26 d0	lda $d026	          LDA Vd026
.7623	b0 0f		bcs $7634	          BCS Expand_Color_Nibble
.7625	ad 21 d0	lda $d021	LSC_10    LDA VIC_BG_COL
.7628	90 0a		bcc $7634	          BCC Expand_Color_Nibble
.762a	86 8e		stx $8e		LSC_20    STX VTEMPA
.762c	ae fc 12	ldx $12fc	          LDX SPRNUM
.762f	bd 27 d0	lda $d027,x	          LDA Vd027,X
.7632	a6 8e		ldx $8e		          LDX VTEMPA
.7634					  Expand_Color_Nibble
.7634	29 0f		and #$0f	          AND #%00001111 ; $0f
.7636	85 8e		sta $8e		          STA VTEMPA
.7638	0a		asl a		          ASL A
.7639	0a		asl a		          ASL A
.763a	0a		asl a		          ASL A
.763b	0a		asl a		          ASL A
.763c	05 8e		ora $8e		          ORA VTEMPA
.763e	60		rts		          RTS
.763f					  Store_Graphic_Byte
.763f	91 8c		sta ($8c),y	          STA (GRAPNT),Y
.7641	2c fa 12	bit $12fa	          BIT DEFMOD
.7644	10 03		bpl $7649	          BPL SGB_10
.7646	c8		iny		          INY
.7647	91 8c		sta ($8c),y	          STA (GRAPNT),Y
.7649	60		rts		SGB_10    RTS
.764a					  Show_Sprite_Cursor
.764a	ae 5f 11	ldx $115f	          LDX ANGEND+1
.764d	20 c5 76	jsr $76c5	          JSR Set_Graphics_Pointer
.7650	ac 5e 11	ldy $115e	          LDY ANGEND
.7653	2c fa 12	bit $12fa	          BIT DEFMOD
.7656	10 03		bpl $765b	          BPL Toggle_Graphic_Bit7
.7658	20 5b 76	jsr $765b	          JSR Toggle_Graphic_Bit7
.765b					  Toggle_Graphic_Bit7
.765b	b1 8c		lda ($8c),y	          LDA (GRAPNT),Y
.765d	49 80		eor #$80	          EOR #%10000000 ; $80
.765f	91 8c		sta ($8c),y	          STA (GRAPNT),Y
.7661	c8		iny		          INY
.7662	60		rts		          RTS
>7663	43 4f 50 59 20 46 52 4f		COPY_FROM .TEXT "COPY FROM?",0
>766b	4d 3f 00
>766e	53 50 52 49 54 45 20 4e		SPRITE_NO .TEXT "SPRITE NUMBER?  ",0
>7676	55 4d 42 45 52 3f 20 20 00
>767f	31 32 33 34 03 8d 58 59		SPRITECMD .TEXT "1234",$03,$8d,"XYM",$9d
>7687	4d 9d
>7689	1d 91 11 93 13 41 0d 43		          .BYTE $1d,$91,$11,$93,$13,$41,$0d,$43
.7691					  Sprite_Jump_Table
>7691	74 96				          .BYTE >[SPR_Pixel -1],<[SPR_Pixel -1]
>7693	74 96				          .BYTE >[SPR_Pixel -1],<[SPR_Pixel -1]
>7695	74 96				          .BYTE >[SPR_Pixel -1],<[SPR_Pixel -1]
>7697	74 96				          .BYTE >[SPR_Pixel -1],<[SPR_Pixel -1]
>7699	74 f3				          .BYTE >[SPix_14   -1],<[SPix_14   -1]
>769b	74 fd				          .BYTE >[SPix_18   -1],<[SPix_18   -1]
>769d	75 1e				          .BYTE >[SPix_24   -1],<[SPix_24   -1]
>769f	75 1b				          .BYTE >[SPix_22   -1],<[SPix_22   -1]
>76a1	75 05				          .BYTE >[SPix_20   -1],<[SPix_20   -1]
>76a3	75 41				          .BYTE >[SPix_32   -1],<[SPix_32   -1]
>76a5	75 3e				          .BYTE >[SPix_30   -1],<[SPix_30   -1]
>76a7	75 63				          .BYTE >[SPix_40   -1],<[SPix_40   -1]
>76a9	75 66				          .BYTE >[SPix_42   -1],<[SPix_42   -1]
>76ab	75 2f				          .BYTE >[SPix_26   -1],<[SPix_26   -1]
>76ad	74 51				          .BYTE >[SPRD_65   -1],<[SPRD_65   -1]
>76af	75 75				          .BYTE >[SPix_44   -1],<[SPix_44   -1]
>76b1	75 80				          .BYTE >[SPix_48   -1],<[SPix_48   -1]
>76b3	75 87				          .BYTE >[SPix_50   -1],<[SPix_50   -1]
>76b5	90 05 1c 9f 9c 1e 1f 9e		SPRITECOL .BYTE $90,$05,$1c,$9f,$9c,$1e,$1f,$9e
>76bd	81 95 96 97 98 99 9a 9b		          .BYTE $81,$95,$96,$97,$98,$99,$9a,$9b
.76c5					  Set_Graphics_Pointer
.76c5	bd 33 c0	lda $c033,x	          LDA E_40_Line_Lo,X
.76c8	85 8c		sta $8c		          STA GRAPNT
.76ca	bd 4c c0	lda $c04c,x	          LDA E_40_Line_Hi,X
.76cd	29 03		and #$03	          AND #%00000011 ; $03
.76cf	09 1c		ora #$1c	          ORA #%00011100 ; $1c
.76d1	85 8d		sta $8d		          STA GRAPNT+1
.76d3	60		rts		          RTS
.76d4					  Clear_Sprite
.76d4	ad 21 d0	lda $d021	          LDA VIC_BG_COL
.76d7	20 34 76	jsr $7634	          JSR Expand_Color_Nibble
.76da	a2 14		ldx #$14	          LDX #20             ; start at row 20
.76dc	48		pha		ClSp_10   PHA
.76dd	20 c5 76	jsr $76c5	          JSR Set_Graphics_Pointer
.76e0	68		pla		          PLA
.76e1	a0 17		ldy #$17	          LDY #23             ; start at column 23
.76e3	91 8c		sta ($8c),y	ClSp_20   STA (GRAPNT),Y
.76e5	88		dey		          DEY                 ; next column
.76e6	10 fb		bpl $76e3	          BPL ClSp_20
.76e8	ca		dex		          DEX                 ; next row
.76e9	10 f1		bpl $76dc	          BPL ClSp_10
.76eb	60		rts		          RTS
.76ec					  BASIC_SPRSAV
.76ec	20 7c 77	jsr $777c	          JSR Get_Sprite_Address
.76ef	b0 2f		bcs $7720	          BCS SPRS_20
.76f1	85 4b		sta $4b		          STA FORPNT
.76f3	84 4c		sty $4c		          STY FORPNT+1
.76f5	a0 3e		ldy #$3e	          LDY #$3e            ; length of sprite data
.76f7	b1 4b		lda ($4b),y	SPRS_10   LDA (FORPNT),Y
.76f9	99 b7 12	sta $12b7,y	          STA SAVRAM,Y
.76fc	88		dey		          DEY
.76fd	10 f8		bpl $76f7	          BPL SPRS_10
.76ff	c8		iny		          INY                 ; Y = 0
.7700	8c f7 12	sty $12f7	          STY SAVRAM+$40      ; width  high
.7703	8c f9 12	sty $12f9	          STY SAVRAM+$42      ; height high
.7706	a9 17		lda #$17	          LDA #$17
.7708	8d f6 12	sta $12f6	          STA SAVRAM+$3f      ; width  low = 23
.770b	a9 14		lda #$14	          LDA #$14
.770d	8d f8 12	sta $12f8	          STA SAVRAM+$41      ; height low = 20
.7710	a2 b7		ldx #$b7	          LDX #<SAVRAM
.7712	a0 12		ldy #$12	          LDY #>SAVRAM
.7714	86 70		stx $70		          STX STRPTR
.7716	84 71		sty $71		          STY STRPTR+1
.7718	a9 43		lda #$43	          LDA #$43            ; sprite data + size
.771a	20 cc 86	jsr $86cc	          JSR Store_String_Bank_0
.771d	20 99 77	jsr $7799	          JSR LXAY_Descriptor
.7720	8e db 03	stx $03db	SPRS_20   STX SAVSIZ          ; string descriptor
.7723	8d dc 03	sta $03dc	          STA SAVSIZ+1
.7726	8c dd 03	sty $03dd	          STY SAVSIZ+2
.7729	20 5c 79	jsr $795c	          JSR Need_Comma
.772c	a5 3d		lda $3d		          LDA TXTPTR
.772e	8d e0 03	sta $03e0	          STA SPRTMP
.7731	a5 3e		lda $3e		          LDA TXTPTR+1
.7733	8d e1 03	sta $03e1	          STA SPRTMP+1
.7736	20 7c 77	jsr $777c	          JSR Get_Sprite_Address
.7739	b0 25		bcs $7760	          BCS SPRS_50
.773b	85 8c		sta $8c		          STA GRAPNT
.773d	84 8d		sty $8d		          STY GRAPNT+1
.773f	ad dc 03	lda $03dc	          LDA SAVSIZ+1
.7742	85 4b		sta $4b		          STA FORPNT
.7744	ad dd 03	lda $03dd	          LDA SAVSIZ+2
.7747	85 4c		sta $4c		          STA FORPNT+1
.7749	a0 00		ldy #$00	          LDY #0
.774b	cc db 03	cpy $03db	SPRS_30   CPY SAVSIZ
.774e	f0 0f		beq $775f	          BEQ SPRS_40
.7750	a9 4b		lda #$4b	          LDA #FORPNT
.7752	20 ab 03	jsr $03ab	          JSR Fetch_1
.7755	8d 03 ff	sta $ff03	          STA MMU_LCRC
.7758	91 8c		sta ($8c),y	          STA (GRAPNT),Y
.775a	c8		iny		          INY
.775b	c0 3f		cpy #$3f	          CPY #$3f
.775d	d0 ec		bne $774b	          BNE SPRS_30
.775f	60		rts		SPRS_40   RTS
.7760	ad e0 03	lda $03e0	SPRS_50   LDA SPRTMP
.7763	85 3d		sta $3d		          STA TXTPTR
.7765	ad e1 03	lda $03e1	          LDA SPRTMP+1
.7768	85 3e		sta $3e		          STA TXTPTR+1
.776a	20 af 7a	jsr $7aaf	          JSR Parse_Name
.776d	85 4b		sta $4b		          STA FORPNT
.776f	84 4c		sty $4c		          STY FORPNT+1
.7771	a9 db		lda #$db	          LDA #<SAVSIZ
.7773	85 66		sta $66		          STA FAC1_M3
.7775	a9 03		lda #$03	          LDA #>SAVSIZ
.7777	85 67		sta $67		          STA FAC1_M4
.7779	4c 05 54	jmp $5405	          JMP Assign_String_Variable
.777c					  Get_Sprite_Address
.777c	20 ef 77	jsr $77ef	          JSR Eval_Expression
.777f	24 0f		bit $0f		          BIT VALTYP
.7781	30 16		bmi $7799	          BMI LXAY_Descriptor
.7783	20 f7 87	jsr $87f7	          JSR Eval_Byte
.7786	ca		dex		          DEX
.7787	e0 08		cpx #$08	          CPX #8
.7789	b0 0b		bcs $7796	          BCS GSA_Err
.778b	8a		txa		          TXA
.778c	4a		lsr a		          LSR A
.778d	6a		ror a		          ROR A
.778e	6a		ror a		          ROR A
.778f	a0 0e		ldy #$0e	          LDY #14
.7791	90 01		bcc $7794	          BCC GSA_10
.7793	c8		iny		          INY
.7794	18		clc		GSA_10    CLC
.7795	60		rts		          RTS
.7796	4c 28 7d	jmp $7d28	GSA_Err   JMP Error_Illegal_Quantity
.7799					  LXAY_Descriptor
.7799	a5 66		lda $66		          LDA FAC1_M3
.779b	a4 67		ldy $67		          LDY FAC1_M4
.779d	20 e0 87	jsr $87e0	          JSR Pop_Descriptor_Stack
.77a0	a0 00		ldy #$00	          LDY #0
.77a2	20 e7 42	jsr $42e7	          JSR Get_FAC1_M3_1
.77a5	aa		tax		          TAX
.77a6	c8		iny		          INY
.77a7	20 e7 42	jsr $42e7	          JSR Get_FAC1_M3_1
.77aa	48		pha		          PHA
.77ab	c8		iny		          INY
.77ac	20 e7 42	jsr $42e7	          JSR Get_FAC1_M3_1
.77af	a8		tay		          TAY
.77b0	68		pla		          PLA
.77b1	38		sec		          SEC
.77b2	60		rts		          RTS
.77b3					  BASIC_FAST
.77b3	20 45 a8	jsr $a845	          JSR Map_IO
.77b6	ad 11 d0	lda $d011	          LDA VIC_Ctrl_1
.77b9	29 6f		and #$6f	          AND #%01101111     ; clear device enable bit 4
.77bb	8d 11 d0	sta $d011	          STA VIC_Ctrl_1
.77be	a9 01		lda #$01	          LDA #1
.77c0	8d 30 d0	sta $d030	          STA VIC_SPEED       ; set CPU speed to 2MHz
.77c3	60		rts		          RTS
.77c4					  BASIC_SLOW
.77c4	20 45 a8	jsr $a845	          JSR Map_IO
.77c7	a9 00		lda #$00	          LDA #0
.77c9	8d 30 d0	sta $d030	          STA VIC_SPEED       ; set CPU speed to 1MHz
.77cc	ad 11 d0	lda $d011	          LDA VIC_Ctrl_1
.77cf	29 7f		and #$7f	          AND #%01111111     ; clear RST8
.77d1	09 10		ora #$10	          ORA #%00010000     ; set device enable bit 4
.77d3	8d 11 d0	sta $d011	          STA VIC_Ctrl_1
.77d6	60		rts		          RTS
.77d7					  Eval_Numeric
.77d7	20 ef 77	jsr $77ef	          JSR Eval_Expression
.77da					  Assert_Numeric
.77da	18		clc		          CLC
.77db	90 01		bcc $77de	          BCC Check_Var_Type
.77dd					  Need_String
.77dd	38		sec		          SEC
.77de					  Check_Var_Type
.77de	24 0f		bit $0f		          BIT VALTYP          ; $FF = string   $00 = numeric
.77e0	30 03		bmi $77e5	          BMI CVT_10          ; branch on string type
.77e2	b0 03		bcs $77e7	          BCS TYPE_MISMATCH   ; string assert -> TYPE MISMATCH
.77e4	60		rts		CVT_Ret   RTS
.77e5	b0 fd		bcs $77e4	CVT_10    BCS CVT_Ret         ; looking for string, found string
.77e7					  TYPE_MISMATCH
.77e7	a2 16		ldx #$16	          LDX #$16            ; TYPE MISMATCH
>77e9	2c				          .BYTE $2C ;BIT                 ; skip word
.77ea	a2 19		ldx #$19	Err_FTC   LDX #$19            ; FORMULA TOO COMPLEX
.77ec	4c 3c 4d	jmp $4d3c	          JMP Print_Error_X
.77ef					  Eval_Expression
.77ef	a6 3d		ldx $3d		          LDX TXTPTR          ; TXTPTR--
.77f1	d0 02		bne $77f5	          BNE EvEx_05
.77f3	c6 3e		dec $3e		          DEC TXTPTR+1
.77f5	c6 3d		dec $3d		EvEx_05   DEC TXTPTR
.77f7	a2 00		ldx #$00	          LDX #0
>77f9	24				          .BYTE $24           ; skip next PHA
.77fa	48		pha		EvEx_10   PHA                 ; push ACCSYM (comparison op + type)
.77fb	8a		txa		          TXA
.77fc	48		pha		          PHA                 ; push X
.77fd	ba		tsx		          TSX
.77fe	e0 63		cpx #$63	          CPX #$63            ; remaining stack < $63
.7800	90 e8		bcc $77ea	          BCC Err_FTC
.7802	20 d7 78	jsr $78d7	          JSR Vectored_EVAL
.7805	a9 00		lda #$00	          LDA #0
.7807	85 4f		sta $4f		          STA OP_TMP
.7809	20 86 03	jsr $0386	EvEx_15   JSR CHRGOT
.780c	38		sec		EvEx_20   SEC
.780d	e9 b1		sbc #$b1	          SBC #$b1            ; > token ( start of comparison ops)
.780f	90 17		bcc $7828	          BCC EvEx_25
.7811	c9 03		cmp #$03	          CMP #3              ; ( 3 comparison operators > = < )
.7813	b0 13		bcs $7828	          BCS EvEx_25         ; -> function
.7815	c9 01		cmp #$01	          CMP #1              ; CMP #2
.7817	2a		rol a		          ROL A               ; ADC #1
.7818	49 01		eor #$01	          EOR #1              ; '>'  A = 1
.781a	45 4f		eor $4f		          EOR OP_TMP          ; '='  A = 2
.781c	c5 4f		cmp $4f		          CMP OP_TMP          ; '<'  A = 4
.781e	90 61		bcc $7881	          BCC SynErr1
.7820	85 4f		sta $4f		          STA OP_TMP
.7822	20 80 03	jsr $0380	          JSR CHRGET
.7825	4c 0c 78	jmp $780c	          JMP EvEx_20         ; loop (maybe <= or >= or <>)
.7828	a6 4f		ldx $4f		EvEx_25   LDX OP_TMP
.782a	d0 2c		bne $7858	          BNE EvEx_50
.782c	b0 7e		bcs $78ac	          BCS Pop_FAC2          ; function ( SGN INT ... MID$ )
.782e	69 07		adc #$07	          ADC #7
.7830	90 7a		bcc $78ac	          BCC Pop_FAC2          ; branch always
.7832	65 0f		adc $0f		          ADC VALTYP          ; C=1               0 1 2 3 4  5  6
.7834	d0 03		bne $7839	          BNE EvEx_30         ; binary operator ( + - * / ^ AND OR )
.7836	4c 0d 87	jmp $870d	          JMP Concatenate     ; '+' with strings
.7839	69 ff		adc #$ff	EvEx_30   ADC #$ff
.783b	85 24		sta $24		          STA INDEXA          ; op code (0-9 for '+' to '<')
.783d	0a		asl a		          ASL A               ; op code * 2
.783e	65 24		adc $24		          ADC INDEXA          ; op code * 3
.7840	a8		tay		          TAY                 ; Y = index
.7841	68		pla		EvEx_35   PLA                 ; precedence
.7842	d9 28 48	cmp $4828,y	          CMP BASIC_Operator,Y
.7845	b0 6a		bcs $78b1	          BCS PoFA_20         ; previous op has higher precedence
.7847	20 da 77	jsr $77da	          JSR Assert_Numeric
.784a	48		pha		EvEx_40   PHA                 ; save precedence
.784b	20 71 78	jsr $7871	EvEx_45   JSR Use_Operator
.784e	68		pla		          PLA                 ; restore precedence
.784f	a4 4d		ldy $4d		          LDY VARTXT          ; restore index
.7851	10 17		bpl $786a	          BPL EvEx_60
.7853	aa		tax		          TAX
.7854	f0 59		beq $78af	          BEQ PoFA_10
.7856	d0 62		bne $78ba	          BNE PoFA_40         ; always
.7858	46 0f		lsr $0f		EvEx_50   LSR VALTYP          ; clear type
.785a	8a		txa		          TXA                 ; comparison operator
.785b	2a		rol a		          ROL A               ; com op * 2
.785c	a6 3d		ldx $3d		          LDX TXTPTR          ; TXTPTR--
.785e	d0 02		bne $7862	          BNE EvEx_55
.7860	c6 3e		dec $3e		          DEC TXTPTR+1
.7862	c6 3d		dec $3d		EvEx_55   DEC TXTPTR
.7864	a0 1b		ldy #$1b	          LDY #$1b            ; index to Op_COMPARE
.7866	85 4f		sta $4f		          STA OP_TMP
.7868	d0 d7		bne $7841	          BNE EvEx_35
.786a	d9 28 48	cmp $4828,y	EvEx_60   CMP BASIC_Operator,Y
.786d	b0 4b		bcs $78ba	          BCS PoFA_40         ; higher or equal precedence
.786f	90 d9		bcc $784a	          BCC EvEx_40         ; lower precedence
.7871					  Use_Operator
.7871	b9 2a 48	lda $482a,y	          LDA BASIC_Operator+2,Y
.7874	48		pha		          PHA
.7875	b9 29 48	lda $4829,y	          LDA BASIC_Operator+1,Y
.7878	48		pha		          PHA
.7879	20 84 78	jsr $7884	          JSR Push_Operand
.787c	a5 4f		lda $4f		          LDA OP_TMP
.787e	4c fa 77	jmp $77fa	          JMP EvEx_10
.7881	4c 6c 79	jmp $796c	SynErr1   JMP SYNTAX_ERROR
.7884					  Push_Operand
.7884	a5 68		lda $68		          LDA FAC1_SI
.7886	be 28 48	ldx $4828,y	          LDX BASIC_Operator,Y
.7889	a8		tay		          TAY
.788a	18		clc		          CLC
.788b	68		pla		          PLA
.788c	69 01		adc #$01	          ADC #1
.788e	85 24		sta $24		          STA INDEXA          ; return address low
.7890	68		pla		          PLA
.7891	69 00		adc #$00	          ADC #0
.7893	85 25		sta $25		          STA INDEXA+1        ; return address high
.7895	98		tya		          TYA
.7896	48		pha		          PHA                 ; sign of operand
.7897	20 47 8c	jsr $8c47	          JSR Round_FAC1
.789a	a5 67		lda $67		          LDA FAC1_M4
.789c	48		pha		          PHA
.789d	a5 66		lda $66		          LDA FAC1_M3
.789f	48		pha		          PHA
.78a0	a5 65		lda $65		          LDA FAC1_M2
.78a2	48		pha		          PHA
.78a3	a5 64		lda $64		          LDA FAC1_M1
.78a5	48		pha		          PHA
.78a6	a5 63		lda $63		          LDA FAC1_EX
.78a8	48		pha		          PHA
.78a9	6c 24 00	jmp ($0024)	          JMP (INDEXA)        ; RTS
.78ac					  Pop_FAC2
.78ac	a0 ff		ldy #$ff	          LDY #$ff
.78ae	68		pla		          PLA
.78af	f0 23		beq $78d4	PoFA_10   BEQ PoFA_50
.78b1	c9 64		cmp #$64	PoFA_20   CMP #$64            ; precedence of Op_COMPARE
.78b3	f0 03		beq $78b8	          BEQ PoFA_30         ; strings may be comapred too
.78b5	20 da 77	jsr $77da	          JSR Assert_Numeric
.78b8	84 4d		sty $4d		PoFA_30   STY VARTXT
.78ba	68		pla		PoFA_40   PLA
.78bb	4a		lsr a		          LSR A               ; C = VALTYPE
.78bc	85 14		sta $14		          STA TANSGN          ; comparison operator
.78be	68		pla		          PLA
.78bf	85 6a		sta $6a		          STA FAC2_EX
.78c1	68		pla		          PLA
.78c2	85 6b		sta $6b		          STA FAC2_M1
.78c4	68		pla		          PLA
.78c5	85 6c		sta $6c		          STA FAC2_M2
.78c7	68		pla		          PLA
.78c8	85 6d		sta $6d		          STA FAC2_M3
.78ca	68		pla		          PLA
.78cb	85 6e		sta $6e		          STA FAC2_M4
.78cd	68		pla		          PLA
.78ce	85 6f		sta $6f		          STA FAC2_SI
.78d0	45 68		eor $68		          EOR FAC1_SI
.78d2	85 70		sta $70		          STA STRPTR
.78d4	a5 63		lda $63		PoFA_50   LDA FAC1_EX
.78d6	60		rts		          RTS
.78d7					  Vectored_EVAL
.78d7	6c 0a 03	jmp ($030a)	          JMP (IEVAL)
.78da					  DEF_EVAL
.78da	a9 00		lda #$00	          LDA #0
.78dc	85 0f		sta $0f		          STA VALTYP          ; default numeric
.78de	20 80 03	jsr $0380	Eva_10    JSR CHRGET
.78e1	b0 05		bcs $78e8	          BCS Eva_30          ; branch if not numeric
.78e3	a2 00		ldx #$00	Eva_20    LDX #0
.78e5	4c 22 8d	jmp $8d22	          JMP Read_Real_To_FAC1
.78e8	20 3c 7b	jsr $7b3c	Eva_30    JSR Is_Alpha
.78eb	90 03		bcc $78f0	          BCC Eva_40
.78ed	4c 78 79	jmp $7978	          JMP Get_Var
.78f0	c9 ff		cmp #$ff	Eva_40    CMP #$ff            ; PI token
.78f2	d0 0f		bne $7903	          BNE qdot
.78f4	a9 fe		lda #$fe	          LDA #<Real_PI
.78f6	a0 78		ldy #$78	          LDY #>Real_PI
.78f8	20 d4 8b	jsr $8bd4	          JSR Load_FAC1_AY
.78fb	4c 80 03	jmp $0380	          JMP CHRGET
>78fe	82 49 0f da a1			Real_PI   .BYTE $82,$49,$0f,$da,$a1 ;REAL $82490fdaa1;    3.14159265254
.7903					  qdot
.7903	c9 2e		cmp #$2e	          CMP #'.'
.7905	f0 dc		beq $78e3	          BEQ Eva_20
.7907	c9 ab		cmp #$ab	          CMP #$ab            ; -
.7909	f0 66		beq $7971	          BEQ Prep_Minus_Op
.790b	c9 aa		cmp #$aa	          CMP #$aa            ; +
.790d	f0 cf		beq $78de	          BEQ Eva_10
.790f	c9 22		cmp #$22	          CMP #QUOTE
.7911	d0 15		bne $7928	          BNE qdot_10
.7913					  Create_Descriptor_From_TXTPTR
.7913	a5 3d		lda $3d		          LDA TXTPTR
.7915	a4 3e		ldy $3e		          LDY TXTPTR+1
.7917	69 00		adc #$00	          ADC #0
.7919	90 01		bcc $791c	          BCC CDFT_10
.791b	c8		iny		          INY
.791c	20 9a 86	jsr $869a	CDFT_10   JSR Create_String_Descriptor
.791f					  Restore_Execution_Pointer
.791f	a6 72		ldx $72		          LDX STRNG2
.7921	a4 73		ldy $73		          LDY STRNG2+1
.7923	86 3d		stx $3d		          STX TXTPTR
.7925	84 3e		sty $3e		          STY TXTPTR+1
.7927	60		rts		          RTS
.7928	c9 a8		cmp #$a8	qdot_10   CMP #$a8            ; compare with token for NOT
.792a	d0 16		bne $7942	          BNE qdot_20         ; -> continue evaluation
.792c	a0 18		ldy #$18	          LDY #$18            ; offset to NOT function
.792e	d0 43		bne $7973	          BNE Prep_Operation  ; always
.7930					  OP_NOT
.7930	20 b4 84	jsr $84b4	          JSR Real_To_Integer
.7933	a5 67		lda $67		          LDA FAC1_M4
.7935	49 ff		eor #$ff	          EOR #$ff
.7937	a8		tay		          TAY
.7938	a5 66		lda $66		          LDA FAC1_M3
.793a	49 ff		eor #$ff	          EOR #$ff
.793c					  Integer_To_Real
.793c	20 e5 84	jsr $84e5	          JSR Integer_To_FAC1
.793f	4c 70 8c	jmp $8c70	          JMP AFACX
.7942	c9 a5		cmp #$a5	qdot_20   CMP #$a5            ; FN
.7944	d0 03		bne $7949	          BNE qdot_30
.7946	4c 3b 85	jmp $853b	          JMP Eval_FNX
.7949	c9 b4		cmp #$b4	qdot_30   CMP #$b4            ; SGN
.794b	90 03		bcc $7950	          BCC Get_Arg
.794d	4c f7 4b	jmp $4bf7	          JMP Call_Function
.7950					  Get_Arg
.7950	20 59 79	jsr $7959	          JSR Need_Left_Par
.7953	20 ef 77	jsr $77ef	          JSR Eval_Expression
.7956					  Need_Right_Par
.7956	a9 29		lda #$29	          LDA #')'
>7958	2c				          .byte $2c ;BIT
.7959					  Need_Left_Par
.7959	a9 28		lda #$28	          LDA #'('
>795b	2c				          .byte $2c ;BIT
.795c					  Need_Comma
.795c	a9 2c		lda #$2c	          LDA #','
.795e					  Need_A
.795e	a0 00		ldy #$00	          LDY #0
.7960	85 79		sta $79		          STA SYNTMP
.7962	20 c9 03	jsr $03c9	          JSR INDTXT
.7965	c5 79		cmp $79		          CMP SYNTMP
.7967	d0 03		bne $796c	          BNE SYNTAX_ERROR
.7969	4c 80 03	jmp $0380	          JMP CHRGET
.796c					  SYNTAX_ERROR
.796c	a2 0b		ldx #$0b	          LDX #11
.796e	4c 3c 4d	jmp $4d3c	          JMP Print_Error_X
.7971					  Prep_Minus_Op
.7971	a0 15		ldy #$15	          LDY #$15            ; set offset from base to > operator
.7973					  Prep_Operation
.7973	68		pla		          PLA                 ; dump return address low byte
.7974	68		pla		          PLA                 ; dump return address high byte
.7975	4c 4b 78	jmp $784b	          JMP EvEx_45         ; execute function then continue evaluation
.7978					  Get_Var
.7978	20 af 7a	jsr $7aaf	          JSR Parse_Name
.797b	85 66		sta $66		          STA FAC1_M3         ; save variable pointer
.797d	84 67		sty $67		          STY FAC1_M4
.797f	a6 47		ldx $47		          LDX VARNAM
.7981	a4 48		ldy $48		          LDY VARNAM+1
.7983	a5 0f		lda $0f		          LDA VALTYP          ; get data type flag, $FF = string, $00 = numeric
.7985	f0 63		beq $79ea	          BEQ Load_Value
.7987	a9 00		lda #$00	          LDA #0
.7989	85 71		sta $71		          STA STRPTR+1        ; clear FAC1 rounding byte
.798b	e0 54		cpx #$54	          CPX #'T'            ; TI$ ?
.798d	d0 25		bne $79b4	          BNE GeVa_10
.798f	c0 c9		cpy #$c9	          CPY #'I'+$80        ; TI$ ?
.7991	d0 20		bne $79b3	          BNE GeVa_Ret
.7993	a5 66		lda $66		          LDA FAC1_M3
.7995	c9 d2		cmp #$d2	          CMP #<NULL_DESC
.7997	d0 1a		bne $79b3	          BNE GeVa_Ret
.7999	a5 67		lda $67		          LDA FAC1_M4
.799b	c9 03		cmp #$03	          CMP #>NULL_DESC
.799d	d0 14		bne $79b3	          BNE GeVa_Ret
.799f	20 1a 7a	jsr $7a1a	          JSR Load_Jiffy_Clock
.79a2	84 60		sty $60		          STY TENEXP
.79a4	88		dey		          DEY
.79a5	84 72		sty $72		          STY STRNG2
.79a7	a0 06		ldy #$06	          LDY #6              ; HHMMSS = 6 digits
.79a9	84 5f		sty $5f		          STY TMPVAR
.79ab	a0 24		ldy #$24	          LDY #$24
.79ad	20 cd 8e	jsr $8ecd	          JSR Format_Clock_String
.79b0	4c b8 85	jmp $85b8	          JMP Create_Descriptor_for_FORMAT
.79b3	60		rts		GeVa_Ret  RTS
.79b4	e0 44		cpx #$44	GeVa_10   CPX #'D'            ; DS$ ?
.79b6	d0 fb		bne $79b3	          BNE GeVa_Ret
.79b8	c0 d3		cpy #$d3	          CPY #'S'+$80        ; DS$ ?
.79ba	d0 f7		bne $79b3	          BNE GeVa_Ret
.79bc	20 e3 79	jsr $79e3	          JSR Get_Disk_Status
.79bf	a0 ff		ldy #$ff	          LDY #$ff
.79c1	c8		iny		GeVa_20   INY
.79c2	a9 7b		lda #$7b	          LDA #DS_ADR
.79c4	20 ab 03	jsr $03ab	          JSR Fetch_1
.79c7	c9 00		cmp #$00	          CMP #0
.79c9	d0 f6		bne $79c1	          BNE GeVa_20
.79cb	98		tya		          TYA                 ; Y = length of DS$
.79cc	20 88 86	jsr $8688	          JSR Allocate_String_FAC1
.79cf	a8		tay		          TAY
.79d0	f0 0e		beq $79e0	          BEQ GeVa_40
.79d2	88		dey		GeVa_30   DEY
.79d3	a9 7b		lda #$7b	          LDA #DS_ADR
.79d5	20 ab 03	jsr $03ab	          JSR Fetch_1
.79d8	91 37		sta ($37),y	          STA (FRESPC),Y      ; store string in RAM
.79da	98		tya		          TYA
.79db	d0 f5		bne $79d2	          BNE GeVa_30
.79dd	20 71 87	jsr $8771	          JSR Adjust_FRESPC   ; obsolete (add 0 to FRESPC)
.79e0	4c e3 86	jmp $86e3	GeVa_40   JMP Push_String_Descriptor
.79e3					  Get_Disk_Status
.79e3	a5 7a		lda $7a		          LDA DS_LEN
.79e5	d0 40		bne $7a27	          BNE LJC_Ret
.79e7	4c 78 a7	jmp $a778	          JMP Update_DS
.79ea					  Load_Value
.79ea	24 10		bit $10		          BIT INTFLG          ; test data type flag, $80 = integer, $00 = float
.79ec	10 0f		bpl $79fd	          BPL LoVa_10
.79ee	a0 00		ldy #$00	          LDY #0
.79f0	20 e7 42	jsr $42e7	          JSR Get_FAC1_M3_1   ; get integer varlue low byte
.79f3	aa		tax		          TAX
.79f4	c8		iny		          INY
.79f5	20 e7 42	jsr $42e7	          JSR Get_FAC1_M3_1   ; get integer value high byte
.79f8	a8		tay		          TAY
.79f9	8a		txa		          TXA
.79fa	4c 3c 79	jmp $793c	          JMP Integer_To_Real
.79fd	a5 67		lda $67		LoVa_10   LDA FAC1_M4
.79ff	c9 03		cmp #$03	          CMP #>NULL_DESC
.7a01	d0 7e		bne $7a81	          BNE LoVa_60
.7a03	a5 66		lda $66		          LDA FAC1_M3
.7a05	c9 d2		cmp #$d2	          CMP #<NULL_DESC
.7a07	d0 78		bne $7a81	          BNE LoVa_60
.7a09	e0 54		cpx #$54	          CPX #'T'            ; TI ?
.7a0b	d0 1b		bne $7a28	          BNE LoVa_20
.7a0d	c0 49		cpy #$49	          CPY #'I'            ; TI ?
.7a0f	d0 70		bne $7a81	          BNE LoVa_60
.7a11	20 1a 7a	jsr $7a1a	          JSR Load_Jiffy_Clock
.7a14	98		tya		          TYA                 ; clear A
.7a15	a2 a0		ldx #$a0	          LDX #$a0            ; set exponent to 32 bit value
.7a17	4c 7b 8c	jmp $8c7b	          JMP IFACX     ; set exponent = X and normalise FAC1
.7a1a					  Load_Jiffy_Clock
.7a1a	20 de ff	jsr $ffde	          JSR K_RDTIM
.7a1d	86 66		stx $66		          STX FAC1_M3
.7a1f	84 65		sty $65		          STY FAC1_M2
.7a21	85 67		sta $67		          STA FAC1_M4
.7a23	a0 00		ldy #$00	          LDY #0
.7a25	84 64		sty $64		          STY FAC1_M1
.7a27	60		rts		LJC_Ret   RTS
.7a28	e0 53		cpx #$53	LoVa_20   CPX #'S'            ; ST ?
.7a2a	d0 0a		bne $7a36	          BNE LoVa_30
.7a2c	c0 54		cpy #$54	          CPY #'T'            ; ST ?
.7a2e	d0 51		bne $7a81	          BNE LoVa_60
.7a30	20 51 92	jsr $9251	          JSR B_READST
.7a33	4c 68 8c	jmp $8c68	          JMP A_To_FAC1
.7a36	e0 44		cpx #$44	LoVa_30   CPX #'D'            ; DS ?
.7a38	d0 26		bne $7a60	          BNE LoVa_40
.7a3a	c0 53		cpy #$53	          CPY #'S'            ; DS ?
.7a3c	d0 43		bne $7a81	          BNE LoVa_60
.7a3e	20 e3 79	jsr $79e3	          JSR Get_Disk_Status
.7a41	a0 00		ldy #$00	          LDY #0
.7a43	a9 7b		lda #$7b	          LDA #DS_ADR
.7a45	20 ab 03	jsr $03ab	          JSR Fetch_1         ; 1st. digit of status
.7a48	29 0f		and #$0f	          AND #$0f            ; ASCII -> binary
.7a4a	0a		asl a		          ASL A               ; multiply with 10
.7a4b	85 11		sta $11		          STA GARBFL
.7a4d	0a		asl a		          ASL A
.7a4e	0a		asl a		          ASL A
.7a4f	65 11		adc $11		          ADC GARBFL
.7a51	85 11		sta $11		          STA GARBFL
.7a53	c8		iny		          INY
.7a54	a9 7b		lda #$7b	          LDA #DS_ADR
.7a56	20 ab 03	jsr $03ab	          JSR Fetch_1         ; 2nd. digit of status
.7a59	29 0f		and #$0f	          AND #$0f            ; ASCII -> binary
.7a5b	65 11		adc $11		          ADC GARBFL          ; combine 1st. and 2nd. digit
.7a5d	4c 68 8c	jmp $8c68	          JMP A_To_FAC1
.7a60	e0 45		cpx #$45	LoVa_40   CPX #'E'            ; ER or EL ?
.7a62	d0 1d		bne $7a81	          BNE LoVa_60
.7a64	c0 52		cpy #$52	          CPY #'R'            ; ER ?
.7a66	f0 10		beq $7a78	          BEQ LoVa_50
.7a68	c0 4c		cpy #$4c	          CPY #'L'            ; EL ?
.7a6a	d0 15		bne $7a81	          BNE LoVa_60
.7a6c	8d 03 ff	sta $ff03	          STA MMU_LCRC
.7a6f	ad 0a 12	lda $120a	          LDA ERRLIN+1
.7a72	ac 09 12	ldy $1209	          LDY ERRLIN
.7a75	4c c9 84	jmp $84c9	          JMP AY_To_FAC1
.7a78	8d 03 ff	sta $ff03	LoVa_50   STA MMU_LCRC
.7a7b	ad 08 12	lda $1208	          LDA ERRNUM
.7a7e	4c 68 8c	jmp $8c68	          JMP A_To_FAC1
.7a81	a5 66		lda $66		LoVa_60   LDA FAC1_M3         ; A/Y = address of variable
.7a83	a4 67		ldy $67		          LDY FAC1_M4
.7a85	85 24		sta $24		LoVa_70   STA INDEXA
.7a87	84 25		sty $25		          STY INDEXA+1
.7a89	a0 00		ldy #$00	          LDY #0
.7a8b	20 b7 03	jsr $03b7	          JSR Get_INDEXA_1
.7a8e	85 63		sta $63		          STA FAC1_EX
.7a90	84 71		sty $71		          STY FROUND          ; FROUND = 0
.7a92	c8		iny		          INY
.7a93	20 b7 03	jsr $03b7	          JSR Get_INDEXA_1
.7a96	85 68		sta $68		          STA FAC1_SI
.7a98	09 80		ora #$80	          ORA #%10000000 ; $80
.7a9a	85 64		sta $64		          STA FAC1_M1
.7a9c	c8		iny		          INY
.7a9d	20 b7 03	jsr $03b7	          JSR Get_INDEXA_1
.7aa0	85 65		sta $65		          STA FAC1_M2
.7aa2	c8		iny		          INY
.7aa3	20 b7 03	jsr $03b7	          JSR Get_INDEXA_1
.7aa6	85 66		sta $66		          STA FAC1_M3
.7aa8	c8		iny		          INY
.7aa9	20 b7 03	jsr $03b7	          JSR Get_INDEXA_1
.7aac	85 67		sta $67		          STA FAC1_M4
.7aae	60		rts		          RTS
.7aaf					  Parse_Name
.7aaf	a2 00		ldx #$00	          LDX #0
.7ab1	20 86 03	jsr $0386	          JSR CHRGOT
.7ab4					  Get_Array_Address
.7ab4	86 0e		stx $0e		          STX DIMFLG
.7ab6					  Get_FN_Address
.7ab6	85 47		sta $47		          STA VARNAM
.7ab8	20 86 03	jsr $0386	          JSR CHRGOT
.7abb	20 3c 7b	jsr $7b3c	          JSR Is_Alpha
.7abe	b0 03		bcs $7ac3	          BCS GeAd_05
.7ac0	4c 6c 79	jmp $796c	GeAd_Err  JMP SYNTAX_ERROR
.7ac3	a2 00		ldx #$00	GeAd_05   LDX #0              ; set defaults
.7ac5	86 0f		stx $0f		          STX VALTYP          ; numeric
.7ac7	86 10		stx $10		          STX INTFLG          ; real
.7ac9	20 80 03	jsr $0380	          JSR CHRGET          ; 2nd. char of name
.7acc	90 05		bcc $7ad3	          BCC GeAd_10         ; -> branch if numeric
.7ace	20 3c 7b	jsr $7b3c	          JSR Is_Alpha
.7ad1	90 0b		bcc $7ade	          BCC GeAd_20         ; -> branch if not alpha
.7ad3	aa		tax		GeAd_10   TAX                 ; X = 2nd. char of name
.7ad4	20 80 03	jsr $0380	GeAd_15   JSR CHRGET          ; skip all alphanumeric characters
.7ad7	90 fb		bcc $7ad4	          BCC GeAd_15         ; after the 2nd. one
.7ad9	20 3c 7b	jsr $7b3c	          JSR Is_Alpha
.7adc	b0 f6		bcs $7ad4	          BCS GeAd_15
.7ade	c9 24		cmp #$24	GeAd_20   CMP #'$'            ; string ?
.7ae0	d0 06		bne $7ae8	          BNE GeAd_25
.7ae2	a9 ff		lda #$ff	          LDA #$ff            ; set string flag
.7ae4	85 0f		sta $0f		          STA VALTYP          ; $ff = string  $00 = numeric
.7ae6	d0 10		bne $7af8	          BNE GeAd_30
.7ae8	c9 25		cmp #$25	GeAd_25   CMP #'%'            ; integer ?
.7aea	d0 13		bne $7aff	          BNE GeAd_35
.7aec	a5 12		lda $12		          LDA SUBFLG          ; integer allowed ?
.7aee	d0 d0		bne $7ac0	          BNE GeAd_Err        ; -> not in this context
.7af0	a9 80		lda #$80	          LDA #$80
.7af2	85 10		sta $10		          STA INTFLG          ; integer flag
.7af4	05 47		ora $47		          ORA VARNAM
.7af6	85 47		sta $47		          STA VARNAM          ; mark variable as integer
.7af8	8a		txa		GeAd_30   TXA                 ; A = 2nd. char
.7af9	09 80		ora #$80	          ORA #$80            ; set string/integer bit
.7afb	aa		tax		          TAX                 ; X = 2nd. char OR $80
.7afc	20 80 03	jsr $0380	          JSR CHRGET          ; next char after '$' or '%'
.7aff	86 48		stx $48		GeAd_35   STX VARNAM+1        ; store 2nd. char of name
.7b01	38		sec		          SEC
.7b02	05 12		ora $12		          ORA SUBFLG          ; Or with FOR, FN flag
.7b04	e9 28		sbc #$28	          SBC #'('            ; array ?
.7b06	d0 03		bne $7b0b	          BNE GeAd_40         ; -> no
.7b08	4c ab 7c	jmp $7cab	          JMP Find_Array      ; read subscripts
.7b0b	a0 00		ldy #$00	GeAd_40   LDY #0
.7b0d	84 12		sty $12		          STY SUBFLG          ; clear integer disable flag
.7b0f	a5 2f		lda $2f		          LDA VARTAB
.7b11	a6 30		ldx $30		          LDX VARTAB+1        ; (A/X) = VARTAB
.7b13	86 62		stx $62		GeAd_45   STX LOWTR+1         ; find variable in (VARTAB..ARYTAB)
.7b15	85 61		sta $61		GeAd_50   STA LOWTR           ; LOWTR = (A/X)
.7b17	e4 32		cpx $32		          CPX ARYTAB+1
.7b19	d0 04		bne $7b1f	          BNE GeAd_55
.7b1b	c5 31		cmp $31		          CMP ARYTAB
.7b1d	f0 27		beq $7b46	          BEQ Create_Var      ; (A/X) == ARYTAB -> not found
.7b1f	20 00 43	jsr $4300	GeAd_55   JSR Get_LOWTR_1
.7b22	c5 47		cmp $47		          CMP VARNAM          ; compare 1st. char
.7b24	d0 0c		bne $7b32	          BNE GeAd_65
.7b26	c8		iny		          INY                 ; Y = 1
.7b27	20 00 43	jsr $4300	          JSR Get_LOWTR_1
.7b2a	c5 48		cmp $48		          CMP VARNAM+1        ; compare 2nd. char
.7b2c	d0 03		bne $7b31	          BNE GeAd_60
.7b2e	4c 57 7c	jmp $7c57	          JMP CrVa_90         ; -> found
.7b31	88		dey		GeAd_60   DEY                 ; Y = 0
.7b32	18		clc		GeAd_65   CLC
.7b33	a5 61		lda $61		          LDA LOWTR           ; LOWTR += 7
.7b35	69 07		adc #$07	          ADC #7
.7b37	90 dc		bcc $7b15	          BCC GeAd_50
.7b39	e8		inx		          INX
.7b3a	d0 d7		bne $7b13	          BNE GeAd_45         ; always
.7b3c					  Is_Alpha
.7b3c	c9 41		cmp #$41	          CMP #'A'
.7b3e	90 05		bcc $7b45	          BCC IsAl_Ret
.7b40	e9 5b		sbc #$5b	          SBC #'Z'+1
.7b42	38		sec		          SEC
.7b43	e9 a5		sbc #$a5	          SBC #$a5            ; restore original content
.7b45	60		rts		IsAl_Ret  RTS                 ; C=1 if (A..Z)
.7b46					  Create_Var
.7b46	ba		tsx		          TSX
.7b47	bd 02 01	lda $0102,x	          LDA STACK+2,X
.7b4a	c9 83		cmp #$83	          CMP #>FUNC_Call+2 ; $83 called from FUNC_POINTER ?
.7b4c	f0 04		beq $7b52	          BEQ CrVa_05
.7b4e	c9 79		cmp #$79	          CMP #>Get_Var+2   ; $79 called from Get_Var
.7b50	d0 2a		bne $7b7c	          BNE CrVa_35
.7b52	a9 d2		lda #$d2	CrVa_05   LDA #<NULL_DESC     ; load NULL descriptor
.7b54	a0 03		ldy #$03	          LDY #>NULL_DESC
.7b56	60		rts		          RTS
.7b57	c0 c9		cpy #$c9	CrVa_10   CPY #'I'+$80        ; TI$ = "hhmmss" sets jiffy clock
.7b59	f0 f7		beq $7b52	          BEQ CrVa_05         ; so don't create variable
.7b5b	c0 49		cpy #$49	          CPY #'I'            ; TI  (read only variable)
.7b5d	d0 31		bne $7b90	          BNE CrVa_40
.7b5f	f0 18		beq $7b79	          BEQ CrVa_30
.7b61	c0 d3		cpy #$d3	CrVa_15   CPY #'S'+$80        ; DS$ (read only variable)
.7b63	f0 14		beq $7b79	          BEQ CrVa_30
.7b65	c0 53		cpy #$53	          CPY #'S'            ; DS  (read only variable)
.7b67	d0 27		bne $7b90	          BNE CrVa_40
.7b69	f0 0e		beq $7b79	          BEQ CrVa_30
.7b6b	c0 54		cpy #$54	CrVa_20   CPY #'T'            ; ST  (read only variable)
.7b6d	d0 21		bne $7b90	          BNE CrVa_40
.7b6f	f0 08		beq $7b79	          BEQ CrVa_30
.7b71	c0 52		cpy #$52	CrVa_25   CPY #'R'           ;
.7b73	f0 04		beq $7b79	          BEQ CrVa_30
.7b75	c0 4c		cpy #$4c	          CPY #'L'
.7b77	d0 17		bne $7b90	          BNE CrVa_40
.7b79	4c 6c 79	jmp $796c	CrVa_30   JMP SYNTAX_ERROR
.7b7c	a5 47		lda $47		CrVa_35   LDA VARNAM
.7b7e	a4 48		ldy $48		          LDY VARNAM+1
.7b80	c9 54		cmp #$54	          CMP #'T'
.7b82	f0 d3		beq $7b57	          BEQ CrVa_10         ; -> check TI and TI$
.7b84	c9 53		cmp #$53	          CMP #'S'
.7b86	f0 e3		beq $7b6b	          BEQ CrVa_20         ; -> check ST
.7b88	c9 45		cmp #$45	          CMP #'E'
.7b8a	f0 e5		beq $7b71	          BEQ CrVa_25         ; -> check ER and EL
.7b8c	c9 44		cmp #$44	          CMP #'D'
.7b8e	f0 d1		beq $7b61	          BEQ CrVa_15         ; -> check DS and DS$
.7b90	a5 31		lda $31		CrVa_40   LDA ARYTAB
.7b92	a4 32		ldy $32		          LDY ARYTAB+1
.7b94	85 61		sta $61		          STA LOWTR
.7b96	84 62		sty $62		          STY LOWTR+1         ; LOWTR  = ARYTAB
.7b98	a5 33		lda $33		          LDA STREND
.7b9a	a4 34		ldy $34		          LDY STREND+1
.7b9c	85 5c		sta $5c		          STA HIGHTR
.7b9e	84 5d		sty $5d		          STY HIGHTR+1        ; HIGHTR = STREND
.7ba0	18		clc		          CLC
.7ba1	69 07		adc #$07	          ADC #7              ; 7 bytes for a new variable
.7ba3	90 01		bcc $7ba6	          BCC CrVa_45
.7ba5	c8		iny		          INY
.7ba6	85 5a		sta $5a		CrVa_45   STA ARYPNT
.7ba8	84 5b		sty $5b		          STY ARYPNT+1        ; ARYPNT = STREND + 7
.7baa	20 66 7c	jsr $7c66	          JSR Open_Up_Space   ; Move array space upwards
.7bad	a5 5a		lda $5a		          LDA ARYPNT
.7baf	a4 5b		ldy $5b		          LDY ARYPNT+1
.7bb1	c8		iny		          INY
.7bb2	85 31		sta $31		          STA ARYTAB          ; ARYTAB = ARYPNT + 256
.7bb4	84 32		sty $32		          STY ARYTAB+1
.7bb6	85 5a		sta $5a		          STA ARYPNT
.7bb8	84 5b		sty $5b		          STY ARYPNT+1
.7bba	a5 5a		lda $5a		CrVa_50   LDA ARYPNT
.7bbc	a6 5b		ldx $5b		          LDX ARYPNT+1
.7bbe	e4 34		cpx $34		CrVa_55   CPX STREND+1
.7bc0	d0 06		bne $7bc8	          BNE CrVa_60
.7bc2	c5 33		cmp $33		          CMP STREND
.7bc4	d0 02		bne $7bc8	          BNE CrVa_60         ; *** obsolete ***
.7bc6	f0 78		beq $7c40	          BEQ CrVa_80
.7bc8	85 24		sta $24		CrVa_60   STA INDEXA
.7bca	86 25		stx $25		          STX INDEXA+1
.7bcc	a0 00		ldy #$00	          LDY #0
.7bce	20 b7 03	jsr $03b7	          JSR Get_INDEXA_1
.7bd1	aa		tax		          TAX                 ; X = 1st. char
.7bd2	c8		iny		          INY                 ; Y = 1
.7bd3	20 b7 03	jsr $03b7	          JSR Get_INDEXA_1
.7bd6	08		php		          PHP                 ; push flags of 2nd. char
.7bd7	c8		iny		          INY                 ; Y = 2
.7bd8	20 b7 03	jsr $03b7	          JSR Get_INDEXA_1    ; A = array length low
.7bdb	65 5a		adc $5a		          ADC ARYPNT
.7bdd	85 5a		sta $5a		          STA ARYPNT
.7bdf	c8		iny		          INY                 ; Y = 3
.7be0	20 b7 03	jsr $03b7	          JSR Get_INDEXA_1    ; A = array length high
.7be3	65 5b		adc $5b		          ADC ARYPNT+1
.7be5	85 5b		sta $5b		          STA ARYPNT+1        ; ARYPNT += array length
.7be7	28		plp		          PLP                 ; flags of 2nd. char
.7be8	10 d0		bpl $7bba	          BPL CrVa_50         ; -> branch for real array
.7bea	8a		txa		          TXA                 ; flags for 1st. char
.7beb	30 cd		bmi $7bba	          BMI CrVa_50         ;-> branch for integer
.7bed	c8		iny		          INY                 ; Y = 4
.7bee	20 b7 03	jsr $03b7	          JSR Get_INDEXA_1    ; A = # of dimensions
.7bf1	a0 00		ldy #$00	          LDY #0
.7bf3	0a		asl a		          ASL A               ; dimensions * 2
.7bf4	69 05		adc #$05	          ADC #5              ; plus 5 bytes for header
.7bf6	65 24		adc $24		          ADC INDEXA
.7bf8	85 24		sta $24		          STA INDEXA
.7bfa	90 02		bcc $7bfe	          BCC CrVa_65
.7bfc	e6 25		inc $25		          INC INDEXA+1        ; INDEXA += header size
.7bfe	a6 25		ldx $25		CrVa_65   LDX INDEXA+1
.7c00	e4 5b		cpx $5b		          CPX ARYPNT+1        ; INDEXA == ARYPNT (end of array) ?
.7c02	d0 04		bne $7c08	          BNE CrVa_70
.7c04	c5 5a		cmp $5a		          CMP ARYPNT
.7c06	f0 b6		beq $7bbe	          BEQ CrVa_55         ; -> branch on end of array
.7c08	a0 00		ldy #$00	CrVa_70   LDY #0
.7c0a	20 b7 03	jsr $03b7	          JSR Get_INDEXA_1    ; length of string
.7c0d	f0 24		beq $7c33	          BEQ CrVa_75         ; -> next item
.7c0f	85 79		sta $79		          STA SYNTMP          ; save length
.7c11	c8		iny		          INY                 ; Y = 1
.7c12	20 b7 03	jsr $03b7	          JSR Get_INDEXA_1    ; address low
.7c15	18		clc		          CLC
.7c16	65 79		adc $79		          ADC SYNTMP          ; add length
.7c18	85 5c		sta $5c		          STA HIGHTR
.7c1a	c8		iny		          INY                 ; Y = 2
.7c1b	20 b7 03	jsr $03b7	          JSR Get_INDEXA_1    ; address high
.7c1e	69 00		adc #$00	          ADC #0
.7c20	85 5d		sta $5d		          STA HIGHTR+1        ; HIGHTR = back reference
.7c22	a0 00		ldy #$00	          LDY #0
.7c24	20 e2 42	jsr $42e2	          JSR Get_HIGHTR_1    ; back reference low
.7c27	69 07		adc #$07	          ADC #7              ; add 7
.7c29	91 5c		sta ($5c),y	          STA (HIGHTR),Y      ; store back
.7c2b	c8		iny		          INY                 ; Y = 1
.7c2c	20 e2 42	jsr $42e2	          JSR Get_HIGHTR_1    ; back reference high
.7c2f	69 00		adc #$00	          ADC #0              ; add carry
.7c31	91 5c		sta ($5c),y	          STA (HIGHTR),Y      ; store back
.7c33	a9 03		lda #$03	CrVa_75   LDA #3              ; position to next descriptor
.7c35	18		clc		          CLC
.7c36	65 24		adc $24		          ADC INDEXA
.7c38	85 24		sta $24		          STA INDEXA
.7c3a	90 c2		bcc $7bfe	          BCC CrVa_65
.7c3c	e6 25		inc $25		          INC INDEXA+1        ; INDEXA += 3 (next descriptor)
.7c3e	d0 be		bne $7bfe	          BNE CrVa_65         ; branch always
.7c40	a0 00		ldy #$00	CrVa_80   LDY #0
.7c42	a5 47		lda $47		          LDA VARNAM
.7c44	8d 04 ff	sta $ff04	          STA MMU_LCRD
.7c47	91 61		sta ($61),y	          STA (LOWTR),Y       ; byte 0: 1st. char
.7c49	c8		iny		          INY
.7c4a	a5 48		lda $48		          LDA VARNAM+1
.7c4c	91 61		sta ($61),y	          STA (LOWTR),Y       ; byte 1: 2nd. char
.7c4e	a9 00		lda #$00	          LDA #0
.7c50	c8		iny		CrVa_85   INY
.7c51	91 61		sta ($61),y	          STA (LOWTR),Y       ; byte 2-6: 0
.7c53	c0 06		cpy #$06	          CPY #6
.7c55	d0 f9		bne $7c50	          BNE CrVa_85
.7c57	a5 61		lda $61		CrVa_90   LDA LOWTR
.7c59	18		clc		          CLC
.7c5a	69 02		adc #$02	          ADC #2
.7c5c	a4 62		ldy $62		          LDY LOWTR+1
.7c5e	90 01		bcc $7c61	          BCC CrVa_95
.7c60	c8		iny		          INY
.7c61	85 49		sta $49		CrVa_95   STA VARPNT          ; VARPTR = value of variable
.7c63	84 4a		sty $4a		          STY VARPNT+1
.7c65	60		rts		          RTS
.7c66					  Open_Up_Space
.7c66	20 17 50	jsr $5017	          JSR Check_Mem_Avail ; may trigger a garbage collection
.7c69	85 33		sta $33		          STA STREND
.7c6b	84 34		sty $34		          STY STREND+1        ; save new top of variables
.7c6d	38		sec		          SEC
.7c6e	a5 5c		lda $5c		          LDA HIGHTR
.7c70	e5 61		sbc $61		          SBC LOWTR
.7c72	85 24		sta $24		          STA INDEXA
.7c74	a8		tay		          TAY
.7c75	a5 5d		lda $5d		          LDA HIGHTR+1
.7c77	e5 62		sbc $62		          SBC LOWTR+1
.7c79	aa		tax		          TAX                 ; Y/X = bytes to move
.7c7a	e8		inx		          INX                 ; pages + 1
.7c7b	98		tya		          TYA
.7c7c	f0 25		beq $7ca3	          BEQ OUS_40          ; -> no partial page
.7c7e	a5 5c		lda $5c		          LDA HIGHTR
.7c80	38		sec		          SEC
.7c81	e5 24		sbc $24		          SBC INDEXA
.7c83	85 5c		sta $5c		          STA HIGHTR
.7c85	b0 03		bcs $7c8a	          BCS OUS_10
.7c87	c6 5d		dec $5d		          DEC HIGHTR+1        ; HIGHTR = source pointer
.7c89	38		sec		          SEC
.7c8a	a5 5a		lda $5a		OUS_10    LDA ARYPNT
.7c8c	e5 24		sbc $24		          SBC INDEXA
.7c8e	85 5a		sta $5a		          STA ARYPNT
.7c90	b0 09		bcs $7c9b	          BCS OUS_30
.7c92	c6 5b		dec $5b		          DEC ARYPNT+1        ; ARYPNT = traget pointer
.7c94	90 05		bcc $7c9b	          BCC OUS_30
.7c96	20 e2 42	jsr $42e2	OUS_20    JSR Get_HIGHTR_1
.7c99	91 5a		sta ($5a),y	          STA (ARYPNT),Y
.7c9b	88		dey		OUS_30    DEY
.7c9c	d0 f8		bne $7c96	          BNE OUS_20
.7c9e	20 e2 42	jsr $42e2	          JSR Get_HIGHTR_1    ; transfer for Y = 0
.7ca1	91 5a		sta ($5a),y	          STA (ARYPNT),Y
.7ca3	c6 5d		dec $5d		OUS_40    DEC HIGHTR+1
.7ca5	c6 5b		dec $5b		          DEC ARYPNT+1
.7ca7	ca		dex		          DEX
.7ca8	d0 f1		bne $7c9b	          BNE OUS_30
.7caa	60		rts		          RTS
.7cab					  Find_Array
.7cab	a5 0e		lda $0e		          LDA DIMFLG
.7cad	05 10		ora $10		          ORA INTFLG
.7caf	48		pha		          PHA                 ; push INTFLG (bit 7) and DIMFLG (6-0)
.7cb0	a5 0f		lda $0f		          LDA VALTYP
.7cb2	48		pha		          PHA                 ; push VALTYP
.7cb3	a0 00		ldy #$00	          LDY #0
.7cb5	98		tya		FiAr_10   TYA                 ; start loop evaluating subscripts
.7cb6	48		pha		          PHA                 ; push Y
.7cb7	a5 48		lda $48		          LDA VARNAM+1
.7cb9	48		pha		          PHA
.7cba	a5 47		lda $47		          LDA VARNAM          ; push VARNAM
.7cbc	48		pha		          PHA
.7cbd	20 a7 84	jsr $84a7	          JSR Get_Positive_Integer
.7cc0	68		pla		          PLA
.7cc1	85 47		sta $47		          STA VARNAM
.7cc3	68		pla		          PLA
.7cc4	85 48		sta $48		          STA VARNAM+1        ; pull VARNAM
.7cc6	68		pla		          PLA
.7cc7	a8		tay		          TAY                 ; pull Y
.7cc8	ba		tsx		          TSX
.7cc9	bd 02 01	lda $0102,x	          LDA STACK+2,X
.7ccc	48		pha		          PHA                 ; push DIMFLG/INTFLG again
.7ccd	bd 01 01	lda $0101,x	          LDA STACK+1,X
.7cd0	48		pha		          PHA                 ; push VALTYP again
.7cd1	a5 66		lda $66		          LDA FAC1_M3
.7cd3	9d 02 01	sta $0102,x	          STA STACK+2,X
.7cd6	a5 67		lda $67		          LDA FAC1_M4         ; replace value above these flags
.7cd8	9d 01 01	sta $0101,x	          STA STACK+1,X       ; by the subscript pointer
.7cdb	c8		iny		          INY                 ; check next subscript index
.7cdc	84 0d		sty $0d		          STY B_COUNT         ; # of subscripts
.7cde	20 86 03	jsr $0386	          JSR CHRGOT
.7ce1	a4 0d		ldy $0d		          LDY B_COUNT
.7ce3	c9 2c		cmp #$2c	          CMP #','
.7ce5	f0 ce		beq $7cb5	          BEQ FiAr_10         ; -> more subscripts
.7ce7	20 56 79	jsr $7956	          JSR Need_Right_Par  ; else finish
.7cea	68		pla		          PLA
.7ceb	85 0f		sta $0f		          STA VALTYP
.7ced	68		pla		          PLA
.7cee	85 10		sta $10		          STA INTFLG
.7cf0	29 7f		and #$7f	          AND #$7f            ; extract DIMFLG
.7cf2	85 0e		sta $0e		          STA DIMFLG
.7cf4	a6 31		ldx $31		          LDX ARYTAB
.7cf6	a5 32		lda $32		          LDA ARYTAB+1
.7cf8	86 61		stx $61		FiAr_12   STX LOWTR           ; start search
.7cfa	85 62		sta $62		          STA LOWTR+1
.7cfc	c5 34		cmp $34		          CMP STREND+1
.7cfe	d0 04		bne $7d04	          BNE FiAr_14
.7d00	e4 33		cpx $33		          CPX STREND
.7d02	f0 42		beq $7d46	          BEQ FiAr_22           ; -> end of array space
.7d04	a0 00		ldy #$00	FiAr_14   LDY #0
.7d06	20 00 43	jsr $4300	          JSR Get_LOWTR_1
.7d09	c8		iny		          INY
.7d0a	c5 47		cmp $47		          CMP VARNAM
.7d0c	d0 07		bne $7d15	          BNE FiAr_16
.7d0e	20 00 43	jsr $4300	          JSR Get_LOWTR_1
.7d11	c5 48		cmp $48		          CMP VARNAM+1
.7d13	f0 18		beq $7d2d	          BEQ FiAr_20
.7d15	c8		iny		FiAr_16   INY
.7d16	20 00 43	jsr $4300	          JSR Get_LOWTR_1
.7d19	18		clc		          CLC
.7d1a	65 61		adc $61		          ADC LOWTR
.7d1c	aa		tax		          TAX
.7d1d	c8		iny		          INY
.7d1e	20 00 43	jsr $4300	          JSR Get_LOWTR_1
.7d21	65 62		adc $62		          ADC LOWTR+1
.7d23	90 d3		bcc $7cf8	          BCC FiAr_12         ; always
.7d25	a2 12		ldx #$12	FiAr_Bad  LDX #$12            ; BAD SUBSCRIPT
>7d27	2c				          .byte $2c ;BIT
.7d28					 Error_Illegal_Quantity
.7d28	a2 0e		ldx #$0e	          LDX #14
.7d2a	4c 3c 4d	jmp $4d3c	FiAr_Err  JMP Print_Error_X
.7d2d	a2 13		ldx #$13	FiAr_20   LDX #$13            ; REDIM'D ARRAY
.7d2f	a5 0e		lda $0e		          LDA DIMFLG
.7d31	d0 f7		bne $7d2a	          BNE FiAr_Err
.7d33	20 71 7e	jsr $7e71	          JSR Array_Pointer_To_First
.7d36	a0 04		ldy #$04	          LDY #4
.7d38	20 00 43	jsr $4300	          JSR Get_LOWTR_1     ; # of declared dimensions
.7d3b	85 79		sta $79		          STA SYNTMP
.7d3d	a5 0d		lda $0d		          LDA B_COUNT         ; *** replace with CMP B_COUNT
.7d3f	c5 79		cmp $79		          CMP SYNTMP          ;
.7d41	d0 e2		bne $7d25	          BNE FiAr_Bad
.7d43	4c d2 7d	jmp $7dd2	          JMP FiAr_38
.7d46	20 71 7e	jsr $7e71	FiAr_22   JSR Array_Pointer_To_First
.7d49	20 17 50	jsr $5017	          JSR Check_Mem_Avail
.7d4c	a0 00		ldy #$00	          LDY #0
.7d4e	84 73		sty $73		          STY STRNG2+1
.7d50	a2 05		ldx #$05	          LDX #5              ; # of bytes per element (default REAL)
.7d52	a5 47		lda $47		          LDA VARNAM
.7d54	8d 04 ff	sta $ff04	          STA MMU_LCRD        ; select RAM bank 1
.7d57	91 61		sta ($61),y	          STA (LOWTR),Y       ; store 1st. char
.7d59	10 01		bpl $7d5c	          BPL FiAr_24         ; branch if REAL or STRING
.7d5b	ca		dex		          DEX                 ; # of bytes = 4
.7d5c	c8		iny		FiAr_24   INY                 ; Y = 1
.7d5d	a5 48		lda $48		          LDA VARNAM+1
.7d5f	91 61		sta ($61),y	          STA (LOWTR),Y       ; store 2nd. char
.7d61	10 02		bpl $7d65	          BPL FiAr_26         ; branch if REAL
.7d63	ca		dex		          DEX
.7d64	ca		dex		          DEX                 ; # of bytes (2 INTEGER, 3 STRING)
.7d65	86 72		stx $72		FiAr_26   STX STRNG2          ; store size of elemnts
.7d67	a5 0d		lda $0d		          LDA B_COUNT         ; # of subscripts
.7d69	c8		iny		          INY
.7d6a	c8		iny		          INY
.7d6b	c8		iny		          INY                 ; Y = 4
.7d6c	91 61		sta ($61),y	          STA (LOWTR),Y       ; store # of dimensions
.7d6e	a2 0b		ldx #$0b	FiAr_28   LDX #11             ; default dimension (0..10)
.7d70	a9 00		lda #$00	          LDA #0
.7d72	24 0e		bit $0e		          BIT DIMFLG
.7d74	50 08		bvc $7d7e	          BVC FiAr_30         ; -> branch for default dimension
.7d76	68		pla		          PLA
.7d77	18		clc		          CLC
.7d78	69 01		adc #$01	          ADC #1              ; add 1 because indices start at 0
.7d7a	aa		tax		          TAX
.7d7b	68		pla		          PLA
.7d7c	69 00		adc #$00	          ADC #0              ; (X/A) = (subscript + 1)
.7d7e	c8		iny		FiAr_30   INY                 ; Y = 5,7,...
.7d7f	91 61		sta ($61),y	          STA (LOWTR),Y       ; store dimension high
.7d81	c8		iny		          INY                 ; Y = 6,8,...
.7d82	8a		txa		          TXA
.7d83	91 61		sta ($61),y	          STA (LOWTR),Y       ; store dimension low
.7d85	20 3e 7e	jsr $7e3e	          JSR Mult_16x16
.7d88	86 72		stx $72		          STX STRNG2          ; size low
.7d8a	85 73		sta $73		          STA STRNG2+1        ; size high
.7d8c	a4 24		ldy $24		          LDY INDEXA
.7d8e	c6 0d		dec $0d		          DEC B_COUNT         ; decrement dimension counter
.7d90	d0 dc		bne $7d6e	          BNE FiAr_28         ; loop for next dimension
.7d92	65 5b		adc $5b		          ADC ARYPNT+1
.7d94	b0 67		bcs $7dfd	          BCS FiAr_44         ; -> out of memory
.7d96	85 5b		sta $5b		          STA ARYPNT+1
.7d98	a8		tay		          TAY
.7d99	8a		txa		          TXA
.7d9a	65 5a		adc $5a		          ADC ARYPNT
.7d9c	90 03		bcc $7da1	          BCC FiAr_32
.7d9e	c8		iny		          INY
.7d9f	f0 5c		beq $7dfd	          BEQ FiAr_44         ; -> out of memory
.7da1	20 17 50	jsr $5017	FiAr_32   JSR Check_Mem_Avail
.7da4	85 33		sta $33		          STA STREND
.7da6	84 34		sty $34		          STY STREND+1        ; new top of array area
.7da8	a9 00		lda #$00	          LDA #0              ; clear array content
.7daa	e6 73		inc $73		          INC STRNG2+1        ; size high
.7dac	a4 72		ldy $72		          LDY STRNG2          ; Y = size low
.7dae	f0 05		beq $7db5	          BEQ FiAr_36
.7db0	88		dey		FiAr_34   DEY
.7db1	91 5a		sta ($5a),y	          STA (ARYPNT),Y      ; clear array
.7db3	d0 fb		bne $7db0	          BNE FiAr_34
.7db5	c6 5b		dec $5b		FiAr_36   DEC ARYPNT+1
.7db7	c6 73		dec $73		          DEC STRNG2+1
.7db9	d0 f5		bne $7db0	          BNE FiAr_34
.7dbb	e6 5b		inc $5b		          INC ARYPNT+1
.7dbd	38		sec		          SEC
.7dbe	a5 33		lda $33		          LDA STREND
.7dc0	e5 61		sbc $61		          SBC LOWTR
.7dc2	a0 02		ldy #$02	          LDY #2
.7dc4	91 61		sta ($61),y	          STA (LOWTR),Y       ; store array size low
.7dc6	a5 34		lda $34		          LDA STREND+1
.7dc8	c8		iny		          INY                 ; Y = 3
.7dc9	e5 62		sbc $62		          SBC LOWTR+1
.7dcb	91 61		sta ($61),y	          STA (LOWTR),Y       ; store array size high
.7dcd	a5 0e		lda $0e		          LDA DIMFLG
.7dcf	d0 6c		bne $7e3d	          BNE FiAr_Ret
.7dd1	c8		iny		          INY                 ; Y = 4
.7dd2	20 00 43	jsr $4300	FiAr_38   JSR Get_LOWTR_1
.7dd5	85 0d		sta $0d		          STA B_COUNT         ; # of dimensions
.7dd7	a9 00		lda #$00	          LDA #0
.7dd9	85 72		sta $72		          STA STRNG2
.7ddb	85 73		sta $73		FiAr_40   STA STRNG2+1
.7ddd	c8		iny		          INY                 ; Y = 5,7,...
.7dde	68		pla		          PLA
.7ddf	aa		tax		          TAX
.7de0	85 66		sta $66		          STA FAC1_M3
.7de2	20 00 43	jsr $4300	          JSR Get_LOWTR_1
.7de5	85 79		sta $79		          STA SYNTMP
.7de7	68		pla		          PLA
.7de8	85 67		sta $67		          STA FAC1_M4         ; FAC1M3/4 = subscript
.7dea	c5 79		cmp $79		          CMP SYNTMP          ; compare with dimension high
.7dec	90 12		bcc $7e00	          BCC FiAr_46         ; -> lower
.7dee	d0 0a		bne $7dfa	          BNE FiAr_42         ; greater -> out of range
.7df0	c8		iny		          INY                 ; Y = 6,8,...
.7df1	20 00 43	jsr $4300	          JSR Get_LOWTR_1
.7df4	85 79		sta $79		          STA SYNTMP
.7df6	e4 79		cpx $79		          CPX SYNTMP          ; compare with dimension low
.7df8	90 07		bcc $7e01	          BCC FiAr_48         ; -> lower
.7dfa	4c 25 7d	jmp $7d25	FiAr_42   JMP FiAr_Bad        ; BAD SUBSCRIPT
.7dfd	4c 3a 4d	jmp $4d3a	FiAr_44   JMP OOM_Error       ; OUT OF MEMORY
.7e00	c8		iny		FiAr_46   INY                 ; Y = 6,8,...
.7e01	a5 73		lda $73		FiAr_48   LDA STRNG2+1
.7e03	05 72		ora $72		          ORA STRNG2
.7e05	18		clc		          CLC
.7e06	f0 0a		beq $7e12	          BEQ FiAr_50         ; STRNG2 == 0 ?
.7e08	20 3e 7e	jsr $7e3e	          JSR Mult_16x16
.7e0b	8a		txa		          TXA
.7e0c	65 66		adc $66		          ADC FAC1_M3
.7e0e	aa		tax		          TAX
.7e0f	98		tya		          TYA
.7e10	a4 24		ldy $24		          LDY INDEXA
.7e12	65 67		adc $67		FiAr_50   ADC FAC1_M4
.7e14	86 72		stx $72		          STX STRNG2
.7e16	c6 0d		dec $0d		          DEC B_COUNT
.7e18	d0 c1		bne $7ddb	          BNE FiAr_40         ; next subscript
.7e1a	85 73		sta $73		          STA STRNG2+1
.7e1c	a2 05		ldx #$05	          LDX #5              ; standard item size (REAL)
.7e1e	a5 47		lda $47		          LDA VARNAM
.7e20	10 01		bpl $7e23	          BPL FiAr_52         ; -> REAL or STRING
.7e22	ca		dex		          DEX                 ; X = 4
.7e23	a5 48		lda $48		FiAr_52   LDA VARNAM+1
.7e25	10 02		bpl $7e29	          BPL FiAr_54         ; -> REAL
.7e27	ca		dex		          DEX
.7e28	ca		dex		          DEX                 ; X = 2
.7e29	86 2a		stx $2a		FiAr_54   STX FAC3_M3         ; item size (I=2, S=3, R=5)
.7e2b	a9 00		lda #$00	          LDA #0
.7e2d	20 49 7e	jsr $7e49	          JSR Mult_16x16_A    ; # of items * item size
.7e30	8a		txa		          TXA
.7e31	65 5a		adc $5a		          ADC ARYPNT
.7e33	85 49		sta $49		          STA VARPNT
.7e35	98		tya		          TYA
.7e36	65 5b		adc $5b		          ADC ARYPNT+1
.7e38	85 4a		sta $4a		          STA VARPNT+1        ; VARPTR = array element
.7e3a	a8		tay		          TAY
.7e3b	a5 49		lda $49		          LDA VARPNT          ; (A/Y) = VARPTR
.7e3d	60		rts		FiAr_Ret  RTS
.7e3e					  Mult_16x16
.7e3e	84 24		sty $24		          STY INDEXA
.7e40	20 00 43	jsr $4300	          JSR Get_LOWTR_1
.7e43	85 2a		sta $2a		          STA FAC3_M3
.7e45	88		dey		          DEY
.7e46	20 00 43	jsr $4300	          JSR Get_LOWTR_1
.7e49					  Mult_16x16_A
.7e49	85 2b		sta $2b		          STA FAC3_M4         ; FAC3M3/3 = Dimension
.7e4b	a9 10		lda #$10	          LDA #16
.7e4d	85 5f		sta $5f		          STA TMPVAR          ; 16 bit multiplication
.7e4f	a2 00		ldx #$00	          LDX #0
.7e51	a0 00		ldy #$00	          LDY #0
.7e53	8a		txa		Mu16_10   TXA                 ; (X/Y) = FAC3M3 * TMPPTD
.7e54	0a		asl a		          ASL A
.7e55	aa		tax		          TAX
.7e56	98		tya		          TYA
.7e57	2a		rol a		          ROL A
.7e58	a8		tay		          TAY
.7e59	b0 a2		bcs $7dfd	          BCS FiAr_44
.7e5b	06 72		asl $72		          ASL STRNG2
.7e5d	26 73		rol $73		          ROL STRNG2+1
.7e5f	90 0b		bcc $7e6c	          BCC Mu16_20
.7e61	18		clc		          CLC
.7e62	8a		txa		          TXA
.7e63	65 2a		adc $2a		          ADC FAC3_M3
.7e65	aa		tax		          TAX
.7e66	98		tya		          TYA
.7e67	65 2b		adc $2b		          ADC FAC3_M4
.7e69	a8		tay		          TAY
.7e6a	b0 91		bcs $7dfd	          BCS FiAr_44
.7e6c	c6 5f		dec $5f		Mu16_20   DEC TMPVAR          ; next bit
.7e6e	d0 e3		bne $7e53	          BNE Mu16_10
.7e70	60		rts		          RTS
.7e71					  Array_Pointer_To_First
.7e71	a5 0d		lda $0d		          LDA B_COUNT         ; # of dimensions
.7e73	0a		asl a		          ASL A               ; in bytes
.7e74	69 05		adc #$05	          ADC #5              ; plus header size
.7e76	65 61		adc $61		          ADC LOWTR           ; plus start of array
.7e78	a4 62		ldy $62		          LDY LOWTR+1
.7e7a	90 01		bcc $7e7d	          BCC APTF_10
.7e7c	c8		iny		          INY
.7e7d	85 5a		sta $5a		APTF_10   STA ARYPNT          ; pointer to first elemnt
.7e7f	84 5b		sty $5b		          STY ARYPNT+1
.7e81	60		rts		          RTS
.7e82					  J_PLOT
.7e82	20 45 a8	jsr $a845	          JSR Map_IO
.7e85	4c f0 ff	jmp $fff0	          JMP K_PLOT
.7e88					  J_PRINT
.7e88	20 45 a8	jsr $a845	          JSR Map_IO
.7e8b	4c 0c c0	jmp $c00c	          JMP E_PRINT
.7e8e					  Test_OOM_CHRGOT
.7e8e	20 8f 5c	jsr $5c8f	          JSR Test_OOM_Bank_0
.7e91	4c 86 03	jmp $0386	          JMP CHRGOT
.7e94					  Inc_INDEXB_Cmp_TEXT_TOP
.7e94	e6 26		inc $26		          INC INDEXB
.7e96	d0 02		bne $7e9a	          BNE IICTT_10
.7e98	e6 27		inc $27		          INC INDEXB+1
.7e9a	38		sec		IICTT_10  SEC
.7e9b	a5 26		lda $26		          LDA INDEXB
.7e9d	ed 10 12	sbc $1210	          SBC TEXT_TOP
.7ea0	a5 27		lda $27		          LDA INDEXB+1
.7ea2	ed 11 12	sbc $1211	          SBC TEXT_TOP+1
.7ea5	60		rts		          RTS
.7ea6					  Get_Pitch
.7ea6	2c 03 0a	bit $0a03	          BIT PALNTS          ; $ff = PAL , $00 = NTSC
.7ea9	30 04		bmi $7eaf	          BMI GePi_PAL        ; -> PAL
.7eab	bd 05 70	lda $7005,x	          LDA Pitch_NTSC_High,X
.7eae	60		rts		          RTS
.7eaf	bd b9 7e	lda $7eb9,x	GePi_PAL  LDA Pitch_PAL_Low,X
.7eb2	8d 2d 12	sta $122d	          STA Snd_Pitch
.7eb5	bd c5 7e	lda $7ec5,x	          LDA Pitch_PAL_High,X
.7eb8	60		rts		          RTS
.7eb9					  Pitch_PAL_Low
>7eb9	9c bf 22 c8 b4 eb 71 4c		          .BYTE $9c,$bf,$22,$c8,$b4,$eb,$71,$4c
>7ec1	7f 12 08 68			          .BYTE $7f,$12,$08,$68
.7ec5					  Pitch_PAL_High
>7ec5	45 49 4e 52 57 5c 62 68		          .BYTE $45,$49,$4e,$52,$57,$5c,$62,$68
>7ecd	6e 75 7c 83			          .BYTE $6e,$75,$7c,$83
.7ed1					  Reset_Descriptor_Stack
.7ed1	8e 0c 12	stx $120c	          STX TRAPNO+1
.7ed4	a2 1b		ldx #$1b	          LDX #$1b
.7ed6	86 18		stx $18		          STX TEMPPT
.7ed8	60		rts		          RTS
>7ed9	ff ff ff ff ff ff ff ff		          .FILL $7fc0-* ,$ff ; 231 bytes
>7ee1	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
;	...repeated 12 times (192 bytes)...
>7fb1	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
>7fc0	28 43 29 31 39 38 36 20		          .TEXT "(C)1986 COMMODORE ELECTRONICS"
>7fc8	43 4f 4d 4d 4f 44 4f 52 45 20 45 4c 45 43 54 52
>7fd8	4f 4e 49 43 53
>7fdd	2c 20 4c 54 44 2e 20 41		          .TEXT ", LTD. ALL RIGHTS RESERVED."
>7fe5	4c 4c 20 52 49 47 48 54 53 20 52 45 53 45 52 56
>7ff5	45 44 2e
>7ff8	ff ff ff ff			          .BYTE $ff,$ff,$ff,$ff
>7ffc	ef 8d 01 61			          .BYTE $ef,$8d,$01,$61
.8000					  FUNC_FRE
.8000	20 f7 87	jsr $87f7	          JSR Eval_Byte       ; allow FRE(0) or FRE(1)
.8003	e0 01		cpx #$01	          CPX #1
.8005	90 05		bcc $800c	          BCC FRE_10          ; -> FRE(0) bank 0
.8007	f0 31		beq $803a	          BEQ FRE_30          ; -> FRE(1) bank 1
.8009	4c 28 7d	jmp $7d28	          JMP Error_Illegal_Quantity
.800c	38		sec		FRE_10    SEC                 ; bank 0: MAX_MEM - TEXT_TOP
.800d	ad 12 12	lda $1212	          LDA TEXT_MAX
.8010	ed 10 12	sbc $1210	          SBC TEXT_TOP
.8013	a8		tay		          TAY                 ; Y = low
.8014	ad 13 12	lda $1213	          LDA TEXT_MAX+1
.8017	ed 11 12	sbc $1211	          SBC TEXT_TOP+1      ; A = high
.801a	b0 2b		bcs $8047	          BCS FRE_40          ; -> convert to REAL
.801c	a6 35		ldx $35		          LDX FRETOP          ; TEXT_TOP > MAX_MEM triggers EasterEgg
.801e	e8		inx		          INX
.801f	c8		iny		          INY
.8020	85 70		sta $70		          STA STRPTR
.8022	98		tya		          TYA
.8023	38		sec		          SEC
.8024	e9 05		sbc #$05	          SBC #5
.8026	85 71		sta $71		          STA FROUND
.8028	a5 71		lda $71		FRE_20    LDA FROUND
.802a	5d 37 ae	eor $ae37,x	          EOR EasterEgg-44,X
.802d	45 70		eor $70		          EOR STRPTR
.802f	f0 44		beq $8075	          BEQ VAL_Ret
.8031	20 d2 ff	jsr $ffd2	          JSR K_BSOUT         ; print easter egg message
.8034	e6 71		inc $71		          INC FROUND
.8036	e8		inx		          INX
.8037	d0 ef		bne $8028	          BNE FRE_20
.8039	60		rts		          RTS
.803a	20 ea 92	jsr $92ea	FRE_30    JSR Garbage_Collection
.803d	38		sec		          SEC                 ; bank 1: FRETOP - STREND
.803e	a5 35		lda $35		          LDA FRETOP
.8040	e5 33		sbc $33		          SBC STREND
.8042	a8		tay		          TAY
.8043	a5 36		lda $36		          LDA FRETOP+1
.8045	e5 34		sbc $34		          SBC STREND+1
.8047	4c c9 84	jmp $84c9	FRE_40    JMP AY_To_FAC1
.804a					  FUNC_VAL
.804a	20 6e 86	jsr $866e	          JSR Eval_String_Desc
.804d	d0 03		bne $8052	          BNE VAL_10
.804f	4c d6 88	jmp $88d6	          JMP Clear_FAC1      ; -> empty string
.8052	18		clc		VAL_10    CLC
.8053	65 24		adc $24		          ADC INDEXA
.8055	85 72		sta $72		          STA STRNG2
.8057	a5 25		lda $25		          LDA INDEXA+1
.8059	69 00		adc #$00	          ADC #0
.805b	85 73		sta $73		          STA STRNG2+1        ; STRNG2 = position after string
.805d	a0 00		ldy #$00	          LDY #0
.805f	a9 72		lda #$72	          LDA #STRNG2
.8061	20 ab 03	jsr $03ab	          JSR Fetch_1
.8064	48		pha		          PHA                 ; save string delimiter
.8065	98		tya		          TYA
.8066	91 72		sta ($72),y	          STA (STRNG2),Y      ; insert zero as delimiter
.8068	20 03 8e	jsr $8e03	          JSR CHRGOT_INDEXA
.806b	a2 01		ldx #$01	          LDX #1
.806d	20 22 8d	jsr $8d22	          JSR Read_Real_To_FAC1
.8070	68		pla		          PLA                 ; restore string delimiter
.8071	a0 00		ldy #$00	          LDY #0
.8073	91 72		sta ($72),y	          STA (STRNG2),Y      ; reinsert delimiter
.8075	60		rts		VAL_Ret   RTS
.8076					  FUNC_DEC
.8076	20 6e 86	jsr $866e	          JSR Eval_String_Desc
.8079	85 26		sta $26		          STA INDEXB          ; string length
.807b	a0 00		ldy #$00	          LDY #0
.807d	84 27		sty $27		          STY INDEXB+1        ; digit counter
.807f	84 72		sty $72		          STY STRNG2
.8081	84 73		sty $73		          STY STRNG2+1
.8083	c4 26		cpy $26		DEC_10    CPY INDEXB          ; at end of string ?
.8085	f0 34		beq $80bb	          BEQ DEC_40          ; -> finish
.8087	20 b7 03	jsr $03b7	          JSR Get_INDEXA_1    ; load next hex digit
.808a	c8		iny		          INY
.808b	c9 20		cmp #$20	          CMP #' '
.808d	f0 f4		beq $8083	          BEQ DEC_10          ; -> skip blanks
.808f	e6 27		inc $27		          INC INDEXB+1        ; increment digit counter
.8091	a6 27		ldx $27		          LDX INDEXB+1        ; X = counter
.8093	e0 05		cpx #$05	          CPX #5              ; max. 4 digits allowed
.8095	f0 2b		beq $80c2	          BEQ DEC_Err         ; -> too many digits
.8097	c9 30		cmp #$30	          CMP #'0'
.8099	90 27		bcc $80c2	          BCC DEC_Err
.809b	c9 3a		cmp #$3a	          CMP #'9'+1
.809d	90 0a		bcc $80a9	          BCC DEC_20          ; -> OK (0-9)
.809f	c9 41		cmp #$41	          CMP #'A'
.80a1	90 1f		bcc $80c2	          BCC DEC_Err
.80a3	c9 47		cmp #$47	          CMP #'F'+1
.80a5	b0 1b		bcs $80c2	          BCS DEC_Err
.80a7	e9 07		sbc #$07	          SBC #7              ; convert 'A'-'F' to  A-F
.80a9	e9 2f		sbc #$2f	DEC_20    SBC #'0'-1          ; C = 0
.80ab	0a		asl a		          ASL A
.80ac	0a		asl a		          ASL A
.80ad	0a		asl a		          ASL A
.80ae	0a		asl a		          ASL A               ; shift to high nibble
.80af	a2 04		ldx #$04	          LDX #4
.80b1	0a		asl a		DEC_30    ASL A               ; rotate into STRNG2
.80b2	26 72		rol $72		          ROL STRNG2
.80b4	26 73		rol $73		          ROL STRNG2+1
.80b6	ca		dex		          DEX
.80b7	d0 f8		bne $80b1	          BNE DEC_30
.80b9	f0 c8		beq $8083	          BEQ DEC_10          ; -> next digit
.80bb	a4 72		ldy $72		DEC_40    LDY STRNG2          ; convert value to REAL
.80bd	a5 73		lda $73		          LDA STRNG2+1
.80bf	4c c9 84	jmp $84c9	          JMP AY_To_FAC1
.80c2	4c 28 7d	jmp $7d28	DEC_Err   JMP Error_Illegal_Quantity
.80c5					  FUNC_PEEK
.80c5	a5 17		lda $17		          LDA LINNUM+1        ; save LINNUM
.80c7	48		pha		          PHA
.80c8	a5 16		lda $16		          LDA LINNUM
.80ca	48		pha		          PHA
.80cb	20 da 77	jsr $77da	          JSR Assert_Numeric
.80ce	20 15 88	jsr $8815	          JSR FAC1_To_LINNUM
.80d1	ae d5 03	ldx $03d5	          LDX USER_BANK
.80d4	a0 00		ldy #$00	          LDY #0
.80d6	a9 16		lda #$16	          LDA #LINNUM
.80d8	20 74 ff	jsr $ff74	          JSR K_INDFET
.80db	a8		tay		          TAY
.80dc	68		pla		          PLA
.80dd	85 16		sta $16		          STA LINNUM
.80df	68		pla		          PLA
.80e0	85 17		sta $17		          STA LINNUM+1        ; restore LINNUM
.80e2	4c d4 84	jmp $84d4	          JMP Y_To_Real
.80e5					 BASIC_POKE
.80e5	20 03 88	jsr $8803	          JSR LINNUM_Comma_Byte
.80e8	8a		txa		          TXA
.80e9	a0 00		ldy #$00	          LDY #0
.80eb	a2 16		ldx #$16	          LDX #LINNUM
.80ed	8e b9 02	stx $02b9	          STX STASH+10
.80f0	ae d5 03	ldx $03d5	          LDX USER_BANK
.80f3	4c 77 ff	jmp $ff77	          JMP K_INDSTA
.80f6					  FUNC_ERR
.80f6	20 f7 87	jsr $87f7	          JSR Eval_Byte
.80f9	ca		dex		          DEX
.80fa	8a		txa		          TXA
.80fb	c9 29		cmp #$29	          CMP #$29            ; error < $ 29 ?
.80fd	b0 37		bcs $8136	          BCS FERR_50         ; -> invalid arument
.80ff	20 82 4a	jsr $4a82	          JSR Set_Error_Index
.8102	a0 ff		ldy #$ff	          LDY #$ff
.8104	a2 00		ldx #$00	          LDX #0
.8106	e8		inx		FERR_10   INX
.8107	c8		iny		FERR_20   INY
.8108	b1 26		lda ($26),y	          LDA (INDEXB),Y
.810a	30 06		bmi $8112	          BMI FERR_30         ; -> last character
.810c	c9 20		cmp #$20	          CMP #' '
.810e	90 f7		bcc $8107	          BCC FERR_20         ; skip unprintable character
.8110	b0 f4		bcs $8106	          BCS FERR_10         ; -> always
.8112	8a		txa		FERR_30   TXA
.8113	20 90 86	jsr $8690	          JSR Allocate_String_A
.8116	a2 00		ldx #$00	          LDX #0
.8118	a0 ff		ldy #$ff	          LDY #$ff
.811a	8d 04 ff	sta $ff04	          STA MMU_LCRD
.811d	c8		iny		FERR_40   INY
.811e	b1 26		lda ($26),y	          LDA (INDEXB),Y
.8120	c9 20		cmp #$20	          CMP #' '
.8122	90 f9		bcc $811d	          BCC FERR_40
.8124	20 39 81	jsr $8139	          JSR Swap_XY
.8127	48		pha		          PHA
.8128	29 7f		and #$7f	          AND #$7f
.812a	91 64		sta ($64),y	          STA (FAC1_M1),Y
.812c	20 39 81	jsr $8139	          JSR Swap_XY
.812f	e8		inx		          INX
.8130	68		pla		          PLA
.8131	10 ea		bpl $811d	          BPL FERR_40
.8133	4c d1 85	jmp $85d1	          JMP Push_Descriptor
.8136	4c 28 7d	jmp $7d28	FERR_50   JMP Error_Illegal_Quantity
.8139					  Swap_XY
.8139	48		pha		          PHA
.813a	8a		txa		          TXA
.813b	48		pha		          PHA
.813c	98		tya		          TYA
.813d	aa		tax		          TAX
.813e	68		pla		          PLA
.813f	a8		tay		          TAY
.8140	68		pla		          PLA
.8141	60		rts		          RTS
.8142					  FUNC_HEX
.8142	20 da 77	jsr $77da	          JSR Assert_Numeric
.8145	a5 16		lda $16		          LDA LINNUM          ; save LINNUM
.8147	48		pha		          PHA
.8148	a5 17		lda $17		          LDA LINNUM+1
.814a	48		pha		          PHA
.814b	20 15 88	jsr $8815	          JSR FAC1_To_LINNUM
.814e	a9 04		lda #$04	          LDA #4              ; create string of length 4
.8150	20 90 86	jsr $8690	          JSR Allocate_String_A
.8153	a0 00		ldy #$00	          LDY #0
.8155	a5 17		lda $17		          LDA LINNUM+1
.8157	8d 04 ff	sta $ff04	          STA MMU_LCRD
.815a	20 6b 81	jsr $816b	          JSR Byte_To_Hex
.815d	a5 16		lda $16		          LDA LINNUM
.815f	20 6b 81	jsr $816b	          JSR Byte_To_Hex
.8162	68		pla		          PLA
.8163	85 17		sta $17		          STA LINNUM+1
.8165	68		pla		          PLA
.8166	85 16		sta $16		          STA LINNUM          ; restore LINNUM
.8168	4c d1 85	jmp $85d1	          JMP Push_Descriptor
.816b					  Byte_To_Hex
.816b	48		pha		          PHA
.816c	4a		lsr a		          LSR A
.816d	4a		lsr a		          LSR A
.816e	4a		lsr a		          LSR A
.816f	4a		lsr a		          LSR A
.8170	20 74 81	jsr $8174	          JSR Nibble_To_Hex
.8173	68		pla		          PLA
.8174					  Nibble_To_Hex
.8174	29 0f		and #$0f	          AND #%00001111 ; $0f
.8176	c9 0a		cmp #$0a	          CMP #10
.8178	90 02		bcc $817c	          BCC NTH_10
.817a	69 06		adc #$06	          ADC #6
.817c	69 30		adc #$30	NTH_10    ADC #'0'
.817e	91 64		sta ($64),y	          STA (FAC1_M1),Y
.8180	c8		iny		          INY
.8181	60		rts		          RTS
.8182					  FUNC_RGR
.8182	20 da 77	jsr $77da	          JSR Assert_Numeric
.8185	20 8c 81	jsr $818c	          JSR Get_Graphics_Mode
.8188	a8		tay		          TAY
.8189	4c d4 84	jmp $84d4	          JMP Y_To_Real
.818c					  Get_Graphics_Mode
.818c	a5 d8		lda $d8		          LDA GRAPHM
.818e	18		clc		          CLC
.818f	2a		rol a		          ROL A
.8190	2a		rol a		          ROL A
.8191	2a		rol a		          ROL A
.8192	69 00		adc #$00	          ADC #0
.8194	24 d7		bit $d7		          BIT MODE_80
.8196	10 02		bpl $819a	          BPL GGM_Ret
.8198	69 05		adc #$05	          ADC #5
.819a	60		rts		GGM_Ret   RTS
.819b					  FUNC_RCLR
.819b	20 f7 87	jsr $87f7	          JSR Eval_Byte
.819e	20 45 a8	jsr $a845	          JSR Map_IO
.81a1	ca		dex		          DEX
.81a2	30 15		bmi $81b9	          BMI RCLR_10
.81a4	ca		dex		          DEX
.81a5	30 1a		bmi $81c1	          BMI RCLR_20
.81a7	ca		dex		          DEX
.81a8	30 1c		bmi $81c6	          BMI RCLR_30
.81aa	ca		dex		          DEX
.81ab	30 1e		bmi $81cb	          BMI RCLR_40
.81ad	ca		dex		          DEX
.81ae	30 20		bmi $81d0	          BMI RCLR_50
.81b0	ca		dex		          DEX
.81b1	30 23		bmi $81d6	          BMI RCLR_60
.81b3	ca		dex		          DEX
.81b4	30 28		bmi $81de	          BMI RCLR_70
.81b6	4c 28 7d	jmp $7d28	          JMP Error_Illegal_Quantity
.81b9	ad 21 d0	lda $d021	RCLR_10   LDA VIC_BG_COL
.81bc	29 7f		and #$7f	          AND #%01111111 ; $7f
.81be	4c ec 81	jmp $81ec	          JMP RCLR_90
.81c1	a5 86		lda $86		RCLR_20   LDA FG_COL
.81c3	4c ec 81	jmp $81ec	          JMP RCLR_90
.81c6	a5 84		lda $84		RCLR_30   LDA MULCO1
.81c8	4c ec 81	jmp $81ec	          JMP RCLR_90
.81cb	a5 85		lda $85		RCLR_40   LDA MULCO2
.81cd	4c ec 81	jmp $81ec	          JMP RCLR_90
.81d0	ad 20 d0	lda $d020	RCLR_50   LDA Vd020
.81d3	4c ec 81	jmp $81ec	          JMP RCLR_90
.81d6	a5 f1		lda $f1		RCLR_60   LDA E_Attribute
.81d8	24 d7		bit $d7		          BIT MODE_80
.81da	10 10		bpl $81ec	          BPL RCLR_90
.81dc	30 08		bmi $81e6	          BMI RCLR_80
.81de	a9 1a		lda #$1a	RCLR_70   LDA #$1a
.81e0	8d 00 d6	sta $d600	          STA VDC_Register
.81e3	ad 01 d6	lda $d601	          LDA VDC_Data
.81e6	29 0f		and #$0f	RCLR_80   AND #%00001111 ; $0f
.81e8	aa		tax		          TAX
.81e9	bd f3 81	lda $81f3,x	          LDA unadju_8563,X
.81ec	29 0f		and #$0f	RCLR_90   AND #%00001111 ; $0f
.81ee	a8		tay		          TAY
.81ef	c8		iny		          INY
.81f0	4c d4 84	jmp $84d4	          JMP Y_To_Real
.81f3					  unadju_8563
>81f3	00 0c 06 0e 05 0d 0b 03		          .BYTE $00,$0c,$06,$0e,$05,$0d,$0b,$03
>81fb	02 0a 08 04 09 07 0f 01		          .BYTE $02,$0a,$08,$04,$09,$07,$0f,$01
.8203					  FUNC_JOY
.8203	20 f7 87	jsr $87f7	          JSR Eval_Byte
.8206	ca		dex		          DEX
.8207	e0 02		cpx #$02	          CPX #2
.8209	b0 34		bcs $823f	          BCS JOY_30
.820b	8a		txa		          TXA
.820c	49 01		eor #$01	          EOR #%00000001 ; $01
.820e	aa		tax		          TAX
.820f	08		php		          PHP
.8210	20 45 a8	jsr $a845	          JSR Map_IO
.8213	78		sei		          SEI
.8214	ad 00 dc	lda $dc00	          LDA CIA1
.8217	48		pha		          PHA
.8218	a0 ff		ldy #$ff	          LDY #$ff
.821a	8c 00 dc	sty $dc00	          STY CIA1
.821d	bd 00 dc	lda $dc00,x	JOY_10    LDA CIA1,X
.8220	dd 00 dc	cmp $dc00,x	          CMP CIA1,X
.8223	d0 f8		bne $821d	          BNE JOY_10
.8225	aa		tax		          TAX
.8226	68		pla		          PLA
.8227	8d 00 dc	sta $dc00	          STA CIA1
.822a	8a		txa		          TXA
.822b	28		plp		          PLP
.822c	29 0f		and #$0f	          AND #%00001111 ; $0f
.822e	a8		tay		          TAY
.822f	b9 3d 82	lda $823d,y	          LDA JOYTAB-5,Y
.8232	a8		tay		          TAY
.8233	8a		txa		          TXA
.8234	29 10		and #$10	          AND #%00010000 ; $10
.8236	d0 04		bne $823c	          BNE JOY_20
.8238	98		tya		          TYA
.8239	09 80		ora #$80	          ORA #%10000000 ; $80
.823b	a8		tay		          TAY
.823c	4c d4 84	jmp $84d4	JOY_20    JMP Y_To_Real
.823f	4c 28 7d	jmp $7d28	JOY_30    JMP Error_Illegal_Quantity
>8242	04 02 03 00 06 08 07 00		JOYTAB    .BYTE $04,$02,$03,$00,$06,$08,$07,$00
>824a	05 01 00			          .BYTE $05,$01,$00
.824d					  FUNC_POT
.824d	20 56 79	jsr $7956	          JSR Need_Right_Par
.8250	20 f7 87	jsr $87f7	          JSR Eval_Byte
.8253	ca		dex		          DEX
.8254	e0 04		cpx #$04	          CPX #4
.8256	b0 53		bcs $82ab	          BCS POT_Err
.8258	20 45 a8	jsr $a845	          JSR Map_IO
.825b	a0 00		ldy #$00	          LDY #0
.825d	8a		txa		          TXA
.825e	a2 40		ldx #$40	          LDX #$40
.8260	4a		lsr a		          LSR A
.8261	90 01		bcc $8264	          BCC POT_10
.8263	c8		iny		          INY
.8264	4a		lsr a		POT_10    LSR A
.8265	90 02		bcc $8269	          BCC POT_20
.8267	a2 80		ldx #$80	          LDX #$80
.8269	8e b1 12	stx $12b1	POT_20    STX POT_IEMP_1
.826c	08		php		          PHP
.826d	78		sei		          SEI
.826e	ad 00 dc	lda $dc00	          LDA CIA1
.8271	48		pha		          PHA
.8272	8e 00 dc	stx $dc00	          STX CIA1
.8275	a2 00		ldx #$00	          LDX #0
.8277	e8		inx		POT_30    INX                 ; wait 256 * 5 cycles = 1.28 msec
.8278	d0 fd		bne $8277	          BNE POT_30
.827a	b9 19 d4	lda $d419,y	POT_40    LDA SID_POT_X,Y
.827d	d9 19 d4	cmp $d419,y	          CMP SID_POT_X,Y
.8280	d0 f8		bne $827a	          BNE POT_40
.8282	8d b2 12	sta $12b2	          STA POT_IEMP_2
.8285	a2 00		ldx #$00	          LDX #0
.8287	2c b1 12	bit $12b1	          BIT POT_IEMP_1
.828a	30 01		bmi $828d	          BMI POT_50
.828c	e8		inx		          INX
.828d	a9 04		lda #$04	POT_50    LDA #4
.828f	88		dey		          DEY
.8290	30 01		bmi $8293	          BMI POT_60
.8292	0a		asl a		          ASL A
.8293	a0 ff		ldy #$ff	POT_60    LDY #$ff
.8295	8c 00 dc	sty $dc00	          STY CIA1
.8298	c8		iny		          INY
.8299	3d 00 dc	and $dc00,x	          AND CIA1,X
.829c	d0 01		bne $829f	          BNE POT_70
.829e	c8		iny		          INY
.829f	68		pla		POT_70    PLA
.82a0	8d 00 dc	sta $dc00	          STA CIA1
.82a3	98		tya		          TYA
.82a4	ac b2 12	ldy $12b2	          LDY POT_IEMP_2
.82a7	28		plp		          PLP
.82a8	4c c9 84	jmp $84c9	          JMP AY_To_FAC1
.82ab	4c 28 7d	jmp $7d28	POT_Err   JMP Error_Illegal_Quantity
.82ae					  FUNC_PEN
.82ae	20 56 79	jsr $7956	          JSR Need_Right_Par
.82b1	20 f7 87	jsr $87f7	          JSR Eval_Byte
.82b4	e0 05		cpx #$05	          CPX #5
.82b6	b0 f3		bcs $82ab	          BCS POT_Err
.82b8	e0 02		cpx #$02	          CPX #2
.82ba	b0 1a		bcs $82d6	          BCS PEN_20
.82bc	bc e9 11	ldy $11e9,x	          LDY VSH_LPX,X
.82bf	8c b1 12	sty $12b1	          STY POT_IEMP_1
.82c2	a9 00		lda #$00	          LDA #0
.82c4	9d e9 11	sta $11e9,x	          STA VSH_LPX,X
.82c7	e0 00		cpx #$00	          CPX #0
.82c9	d0 05		bne $82d0	          BNE PEN_10
.82cb	0e b1 12	asl $12b1	          ASL POT_IEMP_1
.82ce	69 00		adc #$00	          ADC #0
.82d0	ac b1 12	ldy $12b1	PEN_10    LDY POT_IEMP_1
.82d3	4c c9 84	jmp $84c9	          JMP AY_To_FAC1
.82d6	20 45 a8	jsr $a845	PEN_20    JSR Map_IO
.82d9	e0 04		cpx #$04	          CPX #4
.82db	f0 10		beq $82ed	          BEQ PEN_40
.82dd	a0 11		ldy #$11	          LDY #$11
.82df	e0 02		cpx #$02	          CPX #2
.82e1	f0 01		beq $82e4	          BEQ PEN_30
.82e3	88		dey		          DEY
.82e4	8c 00 d6	sty $d600	PEN_30    STY VDC_Register
.82e7	ac 01 d6	ldy $d601	          LDY VDC_Data
.82ea	4c d4 84	jmp $84d4	          JMP Y_To_Real
.82ed	ad 00 d6	lda $d600	PEN_40    LDA VDC_Register
.82f0	a0 00		ldy #$00	          LDY #0
.82f2	29 40		and #$40	          AND #%01000000 ; $40
.82f4	f0 01		beq $82f7	          BEQ PEN_50
.82f6	c8		iny		          INY
.82f7	4c d4 84	jmp $84d4	PEN_50    JMP Y_To_Real
.82fa					  FUNC_POINTER
.82fa	20 80 03	jsr $0380	          JSR CHRGET
.82fd	20 59 79	jsr $7959	          JSR Need_Left_Par
.8300	20 3c 7b	jsr $7b3c	          JSR Is_Alpha
.8303	90 16		bcc $831b	          BCC POIN_Err
.8305	20 af 7a	jsr $7aaf	FUNC_Call JSR Parse_Name      ; calling address used by Parse_Name
.8308	aa		tax		          TAX
.8309	98		tya		          TYA
.830a	48		pha		          PHA
.830b	20 56 79	jsr $7956	          JSR Need_Right_Par
.830e	8a		txa		          TXA
.830f	a8		tay		          TAY
.8310	68		pla		          PLA
.8311	c9 03		cmp #$03	          CMP #>NULL_DESC     ; address of NULL descriptor ?
.8313	d0 03		bne $8318	          BNE POIN_10
.8315	a9 00		lda #$00	          LDA #0
.8317	a8		tay		          TAY                 ; return NULL
.8318	4c c9 84	jmp $84c9	POIN_10   JMP AY_To_FAC1
.831b	4c 6c 79	jmp $796c	POIN_Err  JMP SYNTAX_ERROR
.831e					  FUNC_RSPRITE
.831e	20 f7 87	jsr $87f7	          JSR Eval_Byte
.8321	ca		dex		          DEX
.8322	e0 08		cpx #$08	          CPX #8
.8324	b0 32		bcs $8358	          BCS RSPR_Err
.8326	8a		txa		          TXA
.8327	48		pha		          PHA
.8328	20 5c 79	jsr $795c	          JSR Need_Comma
.832b	20 f4 87	jsr $87f4	          JSR Get_Byte_Var
.832e	20 56 79	jsr $7956	          JSR Need_Right_Par
.8331	e0 06		cpx #$06	          CPX #6
.8333	b0 23		bcs $8358	          BCS RSPR_Err
.8335	68		pla		          PLA
.8336	a8		tay		          TAY
.8337	20 45 a8	jsr $a845	          JSR Map_IO
.833a	b9 27 d0	lda $d027,y	          LDA Vd027,Y
.833d	29 0f		and #$0f	          AND #%00001111 ; $0f
.833f	18		clc		          CLC
.8340	69 01		adc #$01	          ADC #1
.8342	e0 01		cpx #$01	          CPX #1
.8344	f0 0e		beq $8354	          BEQ RSPR_10
.8346	bd 5b 83	lda $835b,x	          LDA RSPMOD,X
.8349	aa		tax		          TAX
.834a	b9 b3 6c	lda $6cb3,y	          LDA Bit_Mask,Y
.834d	3d 00 d0	and $d000,x	          AND VIC,X
.8350	f0 02		beq $8354	          BEQ RSPR_10
.8352	a9 01		lda #$01	          LDA #1
.8354	a8		tay		RSPR_10   TAY
.8355	4c d4 84	jmp $84d4	          JMP Y_To_Real
.8358	4c 28 7d	jmp $7d28	RSPR_Err  JMP Error_Illegal_Quantity
>835b	15 27 1b 1d 17 1c		RSPMOD    .BYTE $15,$27,$1b,$1d,$17,$1c
.8361					  FUNC_RSPCOLOR
.8361	20 56 79	jsr $7956	          JSR Need_Right_Par
.8364	20 f7 87	jsr $87f7	          JSR Eval_Byte
.8367	ca		dex		          DEX
.8368	e0 02		cpx #$02	          CPX #2
.836a	b0 0d		bcs $8379	          BCS RSPC_Err
.836c	20 45 a8	jsr $a845	          JSR Map_IO
.836f	bd 25 d0	lda $d025,x	          LDA Vd025,X
.8372	29 0f		and #$0f	          AND #%00001111 ; $0f
.8374	a8		tay		          TAY
.8375	c8		iny		          INY
.8376	4c d4 84	jmp $84d4	          JMP Y_To_Real
.8379	4c 28 7d	jmp $7d28	RSPC_Err  JMP Error_Illegal_Quantity
.837c					  FUNC_BUMP
.837c	20 56 79	jsr $7956	          JSR Need_Right_Par
.837f	20 f7 87	jsr $87f7	          JSR Eval_Byte
.8382	ca		dex		          DEX
.8383	e0 02		cpx #$02	          CPX #2
.8385	b0 0d		bcs $8394	          BCS BUMP_Err
.8387	78		sei		          SEI
.8388	bc e7 11	ldy $11e7,x	          LDY VSH_SS_COLL,X
.838b	a9 00		lda #$00	          LDA #0
.838d	9d e7 11	sta $11e7,x	          STA VSH_SS_COLL,X
.8390	58		cli		          CLI
.8391	4c d4 84	jmp $84d4	          JMP Y_To_Real
.8394	4c 28 7d	jmp $7d28	BUMP_Err  JMP Error_Illegal_Quantity
.8397					  FUNC_RSPPOS
.8397	20 f7 87	jsr $87f7	          JSR Eval_Byte
.839a	ca		dex		          DEX
.839b	e0 08		cpx #$08	          CPX #8
.839d	b0 3f		bcs $83de	          BCS RSPP_Err
.839f	8a		txa		          TXA
.83a0	48		pha		          PHA
.83a1	20 5c 79	jsr $795c	          JSR Need_Comma
.83a4	20 f4 87	jsr $87f4	          JSR Get_Byte_Var
.83a7	20 56 79	jsr $7956	          JSR Need_Right_Par
.83aa	e0 03		cpx #$03	          CPX #3
.83ac	b0 30		bcs $83de	          BCS RSPP_Err
.83ae	68		pla		          PLA
.83af	a8		tay		          TAY
.83b0	e0 02		cpx #$02	          CPX #2
.83b2	d0 09		bne $83bd	          BNE RSPP_10
.83b4	be d9 6d	ldx $6dd9,y	          LDX Sprite_Offset,Y
.83b7	bc 7e 11	ldy $117e,x	          LDY SPRITE_DATA,X
.83ba	4c d4 84	jmp $84d4	          JMP Y_To_Real
.83bd	78		sei		RSPP_10   SEI
.83be	b9 b3 6c	lda $6cb3,y	          LDA Bit_Mask,Y
.83c1	2d e6 11	and $11e6	          AND VSH+16
.83c4	f0 02		beq $83c8	          BEQ RSPP_20
.83c6	a9 01		lda #$01	          LDA #1
.83c8	48		pha		RSPP_20   PHA
.83c9	98		tya		          TYA
.83ca	0a		asl a		          ASL A
.83cb	a8		tay		          TAY
.83cc	8a		txa		          TXA
.83cd	4a		lsr a		          LSR A
.83ce	90 05		bcc $83d5	          BCC RSPP_30
.83d0	c8		iny		          INY
.83d1	68		pla		          PLA
.83d2	a9 00		lda #$00	          LDA #0
.83d4	48		pha		          PHA
.83d5	b9 d6 11	lda $11d6,y	RSPP_30   LDA VSH,Y
.83d8	58		cli		          CLI
.83d9	a8		tay		          TAY
.83da	68		pla		          PLA
.83db	4c c9 84	jmp $84c9	          JMP AY_To_FAC1
.83de	4c 28 7d	jmp $7d28	RSPP_Err  JMP Error_Illegal_Quantity
.83e1					  FUNC_XOR
.83e1	a5 16		lda $16		          LDA LINNUM          ; save LINNUM
.83e3	48		pha		          PHA
.83e4	a5 17		lda $17		          LDA LINNUM+1
.83e6	48		pha		          PHA
.83e7	20 da 77	jsr $77da	          JSR Assert_Numeric
.83ea	20 15 88	jsr $8815	          JSR FAC1_To_LINNUM
.83ed	48		pha		          PHA
.83ee	98		tya		          TYA
.83ef	48		pha		          PHA
.83f0	20 0f 88	jsr $880f	          JSR Comma_And_LINNUM
.83f3	20 56 79	jsr $7956	          JSR Need_Right_Par
.83f6	68		pla		          PLA
.83f7	45 16		eor $16		          EOR LINNUM
.83f9	a8		tay		          TAY
.83fa	68		pla		          PLA
.83fb	45 17		eor $17		          EOR LINNUM+1
.83fd	20 c9 84	jsr $84c9	          JSR AY_To_FAC1      ; store result
.8400	68		pla		          PLA
.8401	85 17		sta $17		          STA LINNUM+1
.8403	68		pla		          PLA
.8404	85 16		sta $16		          STA LINNUM          ; restore LINNUM
.8406	60		rts		          RTS
.8407					  FUNC_RWINDOW
.8407	20 56 79	jsr $7956	          JSR Need_Right_Par
.840a	20 f7 87	jsr $87f7	          JSR Eval_Byte
.840d	e0 02		cpx #$02	          CPX #2
.840f	f0 14		beq $8425	          BEQ RWIN_20
.8411	b0 1e		bcs $8431	          BCS RWIN_Err
.8413	e0 00		cpx #$00	          CPX #0
.8415	d0 07		bne $841e	          BNE RWIN_10
.8417	a5 e4		lda $e4		          LDA Margin_Bottom
.8419	38		sec		          SEC
.841a	e5 e5		sbc $e5		          SBC Margin_Top
.841c	b0 0f		bcs $842d	          BCS RWIN_30
.841e	a5 e7		lda $e7		RWIN_10   LDA Margin_Right
.8420	38		sec		          SEC
.8421	e5 e6		sbc $e6		          SBC Margin_Left
.8423	b0 08		bcs $842d	          BCS RWIN_30
.8425	a9 28		lda #$28	RWIN_20   LDA #40
.8427	24 d7		bit $d7		          BIT MODE_80
.8429	10 02		bpl $842d	          BPL RWIN_30
.842b	a9 50		lda #$50	          LDA #80
.842d	a8		tay		RWIN_30   TAY
.842e	4c d4 84	jmp $84d4	          JMP Y_To_Real
.8431	4c 28 7d	jmp $7d28	RWIN_Err  JMP Error_Illegal_Quantity
.8434					  FUNC_RND
.8434	20 57 8c	jsr $8c57	          JSR Test_FAC1_Sign
.8437	30 31		bmi $846a	RND_10    BMI RND_30
.8439	d0 1a		bne $8455	          BNE RND_20
.843b	20 45 a8	jsr $a845	          JSR Map_IO          ; RND(0)
.843e	ad 06 dc	lda $dc06	          LDA CIA1_TBLO
.8441	85 64		sta $64		          STA FAC1_M1
.8443	ad 07 dc	lda $dc07	          LDA CIA1_TBHI
.8446	85 66		sta $66		          STA FAC1_M3
.8448	ad 04 dc	lda $dc04	          LDA CIA1_TALO
.844b	85 65		sta $65		          STA FAC1_M2
.844d	ad 05 dc	lda $dc05	          LDA CIA1_TAHI
.8450	85 67		sta $67		          STA FAC1_M4
.8452	4c 7a 84	jmp $847a	          JMP RND_40
.8455	a9 1b		lda #$1b	RND_20    LDA #<RNDX          ; RND(+)
.8457	a0 12		ldy #$12	          LDY #>RNDX
.8459	20 d4 8b	jsr $8bd4	          JSR Load_FAC1_AY
.845c	a9 90		lda #$90	          LDA #<rmulc
.845e	a0 84		ldy #$84	          LDY #>rmulc
.8460	20 08 8a	jsr $8a08	          JSR Multiply_AY_To_FAC1
.8463	a9 95		lda #$95	          LDA #<raddc
.8465	a0 84		ldy #$84	          LDY #>raddc
.8467	20 12 8a	jsr $8a12	          JSR Add_AY_To_FAC1
.846a	a6 67		ldx $67		RND_30    LDX FAC1_M4         ; RND(-)
.846c	a5 64		lda $64		          LDA FAC1_M1
.846e	85 67		sta $67		          STA FAC1_M4
.8470	86 64		stx $64		          STX FAC1_M1
.8472	a6 65		ldx $65		          LDX FAC1_M2
.8474	a5 66		lda $66		          LDA FAC1_M3
.8476	85 65		sta $65		          STA FAC1_M2
.8478	86 66		stx $66		          STX FAC1_M3
.847a	a9 00		lda #$00	RND_40    LDA #0
.847c	85 68		sta $68		          STA FAC1_SI
.847e	a5 63		lda $63		          LDA FAC1_EX
.8480	85 71		sta $71		          STA FROUND
.8482	a9 80		lda #$80	          LDA #$80
.8484	85 63		sta $63		          STA FAC1_EX
.8486	20 b6 88	jsr $88b6	          JSR Normalise_FAC1
.8489	a2 1b		ldx #$1b	          LDX #<RNDX
.848b	a0 12		ldy #$12	          LDY #>RNDX
.848d	4c 00 8c	jmp $8c00	          JMP FAC1_To_XY
>8490	98 35 44 7a 00			rmulc     .BYTE $98,$35,$44,$7a,$00 ;.REAL $9835447a00 ; 11879546.00000000000
>8495	68 28 b1 46 00			raddc     .BYTE $68,$28,$b1,$46,$00 ;.REAL $6828b14600 ;        0.00000003928
>849a	90 80 00 00 00			n32768    .BYTE $90,$80,$00,$00,$00 ;.REAL $9080000000 ;   -32768.00000000000
.849f					  FAC1_To_Int_AY
.849f	20 b4 84	jsr $84b4	          JSR Real_To_Integer
.84a2	a5 66		lda $66		          LDA FAC1_M3
.84a4	a4 67		ldy $67		          LDY FAC1_M4
.84a6	60		rts		          RTS
.84a7					  Get_Positive_Integer
.84a7	20 80 03	jsr $0380	          JSR CHRGET
.84aa	20 ef 77	jsr $77ef	          JSR Eval_Expression
.84ad					  Eval_Positive_Integer
.84ad	20 da 77	jsr $77da	          JSR Assert_Numeric
.84b0	a5 68		lda $68		          LDA FAC1_SI
.84b2	30 0d		bmi $84c1	          BMI RIT_10
.84b4					  Real_To_Integer
.84b4	a5 63		lda $63		          LDA FAC1_EX
.84b6	c9 90		cmp #$90	          CMP #$90            ; check if -32767 >= value >= 32767
.84b8	90 0c		bcc $84c6	          BCC RIT_20
.84ba	a9 9a		lda #$9a	          LDA #<n32768        ; check if value == -32768
.84bc	a0 84		ldy #$84	          LDY #>n32768
.84be	20 87 8c	jsr $8c87	          JSR Compare_AY_FAC1
.84c1	f0 03		beq $84c6	RIT_10    BEQ RIT_20
.84c3	4c 28 7d	jmp $7d28	          JMP Error_Illegal_Quantity
.84c6	4c c7 8c	jmp $8cc7	RIT_20    JMP FAC1_INT
.84c9					  AY_To_FAC1
.84c9	20 e5 84	jsr $84e5	          JSR Integer_To_FAC1
.84cc	38		sec		          SEC                 ; AY = positive 16bit number
.84cd	4c 75 8c	jmp $8c75	          JMP Word_To_FAC1
.84d0					  FUNC_POS
.84d0	38		sec		          SEC
.84d1	20 8d 92	jsr $928d	          JSR B_PLOT
.84d4					  Y_To_Real
.84d4	a9 00		lda #$00	          LDA #0
.84d6	4c 3c 79	jmp $793c	          JMP Integer_To_Real
.84d9					  Assert_Non_Direct
.84d9	24 7f		bit $7f		          BIT RUNMOD
.84db	30 12		bmi $84ef	          BMI ITF_Ret
.84dd	a2 15		ldx #$15	          LDX #$15            ; ILLEGAL DIRECT
>84df	2c				          .BYTE $2C ;BIT
.84e0	a2 1b		ldx #$1b	UNDEF_Err LDX #$1b            ; UNDEF'D FUNCTION
.84e2	4c 3c 4d	jmp $4d3c	          JMP Print_Error_X
.84e5					  Integer_To_FAC1
.84e5	a2 00		ldx #$00	          LDX #0
.84e7	86 0f		stx $0f		          STX VALTYP          ; numeric result
.84e9	85 64		sta $64		          STA FAC1_M1         ; high
.84eb	84 65		sty $65		          STY FAC1_M2         ; low
.84ed	a2 90		ldx #$90	          LDX #$90            ; exponent
.84ef	60		rts		ITF_Ret   RTS
.84f0					  Assert_Direct_Mode
.84f0	24 7f		bit $7f		          BIT RUNMOD
.84f2	30 01		bmi $84f5	          BMI ADM_Err
.84f4	60		rts		          RTS
.84f5	a2 22		ldx #$22	ADM_Err   LDX #$22            ; direct mode only
.84f7	4c 3c 4d	jmp $4d3c	          JMP Print_Error_X
.84fa					  BASIC_DEF
.84fa	20 28 85	jsr $8528	          JSR Get_FN          ; read function name
.84fd	20 d9 84	jsr $84d9	          JSR Assert_Non_Direct
.8500	20 59 79	jsr $7959	          JSR Need_Left_Par
.8503	a9 80		lda #$80	          LDA #$80
.8505	85 12		sta $12		          STA SUBFLG          ; no integer function
.8507	20 af 7a	jsr $7aaf	          JSR Parse_Name
.850a	20 da 77	jsr $77da	          JSR Assert_Numeric  ; only numeric arguments
.850d	20 56 79	jsr $7956	          JSR Need_Right_Par
.8510	a9 b2		lda #$b2	          LDA #$b2            ; '=' token
.8512	20 5e 79	jsr $795e	          JSR Need_A
.8515	48		pha		          PHA
.8516	a5 4a		lda $4a		          LDA VARPNT+1
.8518	48		pha		          PHA
.8519	a5 49		lda $49		          LDA VARPNT          ; push function argument address
.851b	48		pha		          PHA
.851c	a5 3e		lda $3e		          LDA TXTPTR+1
.851e	48		pha		          PHA
.851f	a5 3d		lda $3d		          LDA TXTPTR          ; push function address
.8521	48		pha		          PHA
.8522	20 8f 52	jsr $528f	          JSR Skip_Statement
.8525	4c a0 85	jmp $85a0	          JMP FNX_30           ; pull and store attributes
.8528					  Get_FN
.8528	a9 a5		lda #$a5	          LDA #$a5            ; FN token
.852a	20 5e 79	jsr $795e	          JSR Need_A
.852d	09 80		ora #$80	          ORA #$80
.852f	85 12		sta $12		          STA SUBFLG          ; no integer function
.8531	20 b6 7a	jsr $7ab6	          JSR Get_FN_Address
.8534	85 50		sta $50		          STA GRBPNT
.8536	84 51		sty $51		          STY GRBPNT+1
.8538	4c da 77	jmp $77da	          JMP Assert_Numeric
.853b					  Eval_FNX
.853b	20 28 85	jsr $8528	          JSR Get_FN          ; address of function descriptor
.853e	a5 51		lda $51		          LDA GRBPNT+1        ; push function pointer
.8540	48		pha		          PHA
.8541	a5 50		lda $50		          LDA GRBPNT
.8543	48		pha		          PHA
.8544	20 50 79	jsr $7950	          JSR Get_Arg
.8547	20 da 77	jsr $77da	          JSR Assert_Numeric
.854a	68		pla		          PLA
.854b	85 50		sta $50		          STA GRBPNT
.854d	68		pla		          PLA
.854e	85 51		sta $51		          STA GRBPNT+1        ; restore function pointer
.8550	a0 02		ldy #$02	          LDY #2
.8552	20 ce 42	jsr $42ce	          JSR GRBPNT_from_Bank_1
.8555	85 49		sta $49		          STA VARPNT
.8557	aa		tax		          TAX
.8558	c8		iny		          INY                 ; Y = 3
.8559	20 ce 42	jsr $42ce	          JSR GRBPNT_from_Bank_1
.855c	f0 82		beq $84e0	          BEQ UNDEF_Err
.855e	85 4a		sta $4a		          STA VARPNT+1        ; VARPTR = address of argument variable
.8560	c8		iny		          INY                 ; Y = 4
.8561	a9 49		lda #$49	FNX_10    LDA #VARPNT
.8563	20 ab 03	jsr $03ab	          JSR Fetch_1
.8566	48		pha		          PHA                 ; push value of variable (5 bytes)
.8567	88		dey		          DEY
.8568	10 f7		bpl $8561	          BPL FNX_10
.856a	a4 4a		ldy $4a		          LDY VARPNT+1
.856c	8d 04 ff	sta $ff04	          STA MMU_LCRD
.856f	20 00 8c	jsr $8c00	          JSR FAC1_To_XY      ; (X/Y) = VARPTR - Y=0 on return
.8572	a5 3e		lda $3e		          LDA TXTPTR+1
.8574	48		pha		          PHA                 ; push TXTPTR
.8575	a5 3d		lda $3d		          LDA TXTPTR
.8577	48		pha		          PHA
.8578	20 ce 42	jsr $42ce	          JSR GRBPNT_from_Bank_1
.857b	85 3d		sta $3d		          STA TXTPTR
.857d	c8		iny		          INY
.857e	20 ce 42	jsr $42ce	          JSR GRBPNT_from_Bank_1
.8581	85 3e		sta $3e		          STA TXTPTR+1        ; TXTPTR = function body
.8583	a5 4a		lda $4a		          LDA VARPNT+1
.8585	48		pha		          PHA                 ; push VARPTR
.8586	a5 49		lda $49		          LDA VARPNT
.8588	48		pha		          PHA
.8589	20 d7 77	jsr $77d7	          JSR Eval_Numeric    ; execute function body
.858c	68		pla		          PLA
.858d	85 50		sta $50		          STA GRBPNT          ; GRBPNT = VARPNT
.858f	68		pla		          PLA
.8590	85 51		sta $51		          STA GRBPNT+1
.8592	20 86 03	jsr $0386	          JSR CHRGOT
.8595	f0 03		beq $859a	          BEQ FNX_20
.8597	4c 6c 79	jmp $796c	          JMP SYNTAX_ERROR    ; function did not end properly
.859a	68		pla		FNX_20    PLA
.859b	85 3d		sta $3d		          STA TXTPTR
.859d	68		pla		          PLA
.859e	85 3e		sta $3e		          STA TXTPTR+1        ; restore execution pointer
.85a0	a0 00		ldy #$00	FNX_30    LDY #0
.85a2	8d 04 ff	sta $ff04	          STA MMU_LCRD
.85a5	68		pla		FNX_40    PLA
.85a6	91 50		sta ($50),y	          STA (GRBPNT),Y      ; restore value of argument variable
.85a8	c8		iny		          INY
.85a9	c0 05		cpy #$05	          CPY #5
.85ab	d0 f8		bne $85a5	          BNE FNX_40
.85ad	60		rts		          RTS
.85ae					  FUNC_STR
.85ae	20 da 77	jsr $77da	          JSR Assert_Numeric
.85b1	a0 00		ldy #$00	          LDY #0
.85b3	20 44 8e	jsr $8e44	          JSR Format_FAC1_Y
.85b6	68		pla		          PLA
.85b7	68		pla		          PLA
.85b8					  Create_Descriptor_for_FORMAT
.85b8	a9 ff		lda #$ff	          LDA #<STACK-1
.85ba	a0 00		ldy #$00	          LDY #>STACK-1
.85bc	4c 9a 86	jmp $869a	          JMP Create_String_Descriptor
.85bf					  FUNC_CHR
.85bf	20 f7 87	jsr $87f7	          JSR Eval_Byte
.85c2	8a		txa		          TXA
.85c3	48		pha		          PHA
.85c4	a9 01		lda #$01	          LDA #1
.85c6	20 90 86	jsr $8690	          JSR Allocate_String_A
.85c9	68		pla		          PLA
.85ca	a0 00		ldy #$00	          LDY #0
.85cc	8d 04 ff	sta $ff04	          STA MMU_LCRD
.85cf	91 64		sta ($64),y	          STA (FAC1_M1),Y
.85d1					  Push_Descriptor
.85d1	68		pla		          PLA
.85d2	68		pla		          PLA
.85d3	4c e3 86	jmp $86e3	          JMP Push_String_Descriptor
.85d6					  FUNC_LEFT
.85d6	20 4d 86	jsr $864d	          JSR Pop_DSCPNT      ; get string address and 2nd. argument
.85d9	48		pha		          PHA
.85da	20 d8 42	jsr $42d8	          JSR Get_DSCPNT_1
.85dd	85 79		sta $79		          STA SYNTMP
.85df	68		pla		          PLA
.85e0	c5 79		cmp $79		          CMP SYNTMP          ; compare argument with length
.85e2	98		tya		          TYA                 ; A = 0
.85e3	90 05		bcc $85ea	LEFT_10   BCC LEFT_20         ; branch if arg < length
.85e5	20 d8 42	jsr $42d8	          JSR Get_DSCPNT_1    ; get total length
.85e8	aa		tax		          TAX                 ; string length
.85e9	98		tya		          TYA                 ; A = 0
.85ea	48		pha		LEFT_20   PHA                 ; push start index (0 for LEFT$)
.85eb	8a		txa		LEFT_30   TXA                 ; A  = new length
.85ec	48		pha		LEFT_40   PHA                 ; push new length
.85ed	20 90 86	jsr $8690	          JSR Allocate_String_A
.85f0	a5 52		lda $52		          LDA DSCPNT
.85f2	a4 53		ldy $53		          LDY DSCPNT+1
.85f4	20 85 87	jsr $8785	          JSR Free_String_AY  ; free string argument
.85f7	68		pla		          PLA
.85f8	a8		tay		          TAY                 ; Y = length
.85f9	68		pla		          PLA                 ; A = start index
.85fa	18		clc		          CLC
.85fb	65 24		adc $24		          ADC INDEXA
.85fd	85 24		sta $24		          STA INDEXA
.85ff	90 02		bcc $8603	          BCC LEFT_50
.8601	e6 25		inc $25		          INC INDEXA+1
.8603	98		tya		LEFT_50   TYA
.8604	20 63 87	jsr $8763	          JSR Store_String_INDEXA
.8607	4c e3 86	jmp $86e3	          JMP Push_String_Descriptor
.860a					  FUNC_RIGHT
.860a	20 4d 86	jsr $864d	          JSR Pop_DSCPNT      ; get string address and 2nd. argument
.860d	48		pha		          PHA
.860e	20 d8 42	jsr $42d8	          JSR Get_DSCPNT_1
.8611	85 79		sta $79		          STA SYNTMP
.8613	68		pla		          PLA
.8614	18		clc		          CLC
.8615	e5 79		sbc $79		          SBC SYNTMP          ; length - argument
.8617	49 ff		eor #$ff	          EOR #%11111111     ; negate
.8619	4c e3 85	jmp $85e3	          JMP LEFT_10
.861c					  FUNC_MID
.861c	a9 ff		lda #$ff	          LDA #255            ; default value for 3rd. argument
.861e	85 67		sta $67		          STA FAC1_M4
.8620	20 86 03	jsr $0386	          JSR CHRGOT
.8623	c9 29		cmp #$29	          CMP #')'
.8625	f0 06		beq $862d	          BEQ MID_10
.8627	20 5c 79	jsr $795c	          JSR Need_Comma
.862a	20 f4 87	jsr $87f4	          JSR Get_Byte_Var    ; 3rd. argument to FAC1M4
.862d	20 4d 86	jsr $864d	MID_10    JSR Pop_DSCPNT      ; get string address and 2nd. argument
.8630	f0 53		beq $8685	          BEQ ASC_Err         ; null string -> error
.8632	ca		dex		          DEX                 ; start index to offset
.8633	8a		txa		          TXA
.8634	48		pha		          PHA                 ; push offset
.8635	a2 00		ldx #$00	          LDX #0
.8637	48		pha		          PHA
.8638	20 d8 42	jsr $42d8	          JSR Get_DSCPNT_1
.863b	85 79		sta $79		          STA SYNTMP
.863d	68		pla		          PLA
.863e	18		clc		          CLC
.863f	e5 79		sbc $79		          SBC SYNTMP          ; offset - length
.8641	b0 a8		bcs $85eb	          BCS LEFT_30
.8643	49 ff		eor #$ff	          EOR #$ff            ; length - offset
.8645	c5 67		cmp $67		          CMP FAC1_M4
.8647	90 a3		bcc $85ec	          BCC LEFT_40         ; new length = rest of string
.8649	a5 67		lda $67		          LDA FAC1_M4         ; new length
.864b	b0 9f		bcs $85ec	          BCS LEFT_40         ; branch always
.864d					  Pop_DSCPNT
.864d	20 56 79	jsr $7956	          JSR Need_Right_Par
.8650	68		pla		          PLA
.8651	a8		tay		          TAY                 ; return address low
.8652	68		pla		          PLA
.8653	85 57		sta $57		          STA JUMPER+1        ; return address high
.8655	68		pla		          PLA
.8656	68		pla		          PLA
.8657	68		pla		          PLA
.8658	aa		tax		          TAX                 ; X = length
.8659	68		pla		          PLA
.865a	85 52		sta $52		          STA DSCPNT
.865c	68		pla		          PLA
.865d	85 53		sta $53		          STA DSCPNT+1        ; DSCPNT = string address
.865f	a5 57		lda $57		          LDA JUMPER+1
.8661	48		pha		          PHA                 ; return address high
.8662	98		tya		          TYA
.8663	48		pha		          PHA                 ; return address low
.8664	a0 00		ldy #$00	          LDY #0
.8666	8a		txa		          TXA                 ; A = length
.8667	60		rts		          RTS
.8668					  FUNC_LEN
.8668	20 6e 86	jsr $866e	          JSR Eval_String_Desc
.866b	4c d4 84	jmp $84d4	          JMP Y_To_Real
.866e					  Eval_String_Desc
.866e	20 7e 87	jsr $877e	          JSR Eval_And_Free_String
.8671	a2 00		ldx #$00	          LDX #0
.8673	86 0f		stx $0f		          STX VALTYP
.8675	a8		tay		          TAY
.8676	60		rts		          RTS
.8677					  FUNC_ASC
.8677	20 6e 86	jsr $866e	          JSR Eval_String_Desc
.867a	f0 06		beq $8682	          BEQ ASC_10
.867c	a0 00		ldy #$00	          LDY #0
.867e	20 b7 03	jsr $03b7	          JSR Get_INDEXA_1
.8681	a8		tay		          TAY
.8682	4c d4 84	jmp $84d4	ASC_10    JMP Y_To_Real
.8685	4c 28 7d	jmp $7d28	ASC_Err   JMP Error_Illegal_Quantity
.8688					  Allocate_String_FAC1
.8688	a6 66		ldx $66		          LDX FAC1_M3
.868a	a4 67		ldy $67		          LDY FAC1_M4
.868c	86 52		stx $52		          STX DSCPNT
.868e	84 53		sty $53		          STY DSCPNT+1
.8690					  Allocate_String_A
.8690	20 99 92	jsr $9299	          JSR Allocate_String_Space
.8693	86 64		stx $64		          STX FAC1_M1         ; addres low
.8695	84 65		sty $65		          STY FAC1_M2         ; address high
.8697	85 63		sta $63		          STA FAC1_EX         ; length
.8699	60		rts		          RTS
.869a					  Create_String_Descriptor
.869a	a2 22		ldx #$22	          LDX #QUOTE          ; set delimiter
.869c	86 09		stx $09		          STX CHARAC
.869e	86 0a		stx $0a		          STX ENDCHR
.86a0					  Create_String_Descriptor_AY
.86a0	85 70		sta $70		          STA STRPTR
.86a2	84 71		sty $71		          STY STRPTR+1        ; set STRPTR from (A/Y)
.86a4	85 64		sta $64		          STA FAC1_M1
.86a6	84 65		sty $65		          STY FAC1_M2         ; set FAC1M1/2 from (A/Y)
.86a8	a0 ff		ldy #$ff	          LDY #-1             ; pre increment loop
.86aa	c8		iny		CSD_10    INY
.86ab	20 f1 42	jsr $42f1	          JSR Get_STRPTR_0
.86ae	f0 0c		beq $86bc	          BEQ CSD_30          ; end of string
.86b0	c5 09		cmp $09		          CMP CHARAC          ; closing delimiter
.86b2	f0 04		beq $86b8	          BEQ CSD_20
.86b4	c5 0a		cmp $0a		          CMP ENDCHR
.86b6	d0 f2		bne $86aa	          BNE CSD_10          ; loop
.86b8	c9 22		cmp #$22	CSD_20    CMP #QUOTE
.86ba	f0 01		beq $86bd	          BEQ CSD_40
.86bc	18		clc		CSD_30    CLC
.86bd	84 63		sty $63		CSD_40    STY FAC1_EX         ; string length
.86bf	98		tya		          TYA
.86c0	65 70		adc $70		          ADC STRPTR
.86c2	85 72		sta $72		          STA STRNG2          ; STRNG2 = STRPTR + length
.86c4	a6 71		ldx $71		          LDX STRPTR+1
.86c6	90 01		bcc $86c9	          BCC CSD_50
.86c8	e8		inx		          INX
.86c9	86 73		stx $73		CSD_50    STX STRNG2+1
.86cb	98		tya		          TYA
.86cc					  Store_String_Bank_0
.86cc	20 88 86	jsr $8688	          JSR Allocate_String_FAC1
.86cf	a8		tay		          TAY
.86d0	f0 11		beq $86e3	          BEQ Push_String_Descriptor
.86d2	48		pha		          PHA
.86d3	88		dey		SSB0      DEY
.86d4	20 f1 42	jsr $42f1	          JSR Get_STRPTR_0
.86d7	8d 04 ff	sta $ff04	          STA MMU_LCRD
.86da	91 37		sta ($37),y	          STA (FRESPC),Y
.86dc	98		tya		          TYA
.86dd	d0 f4		bne $86d3	          BNE SSB0
.86df	68		pla		          PLA
.86e0	20 71 87	jsr $8771	          JSR Adjust_FRESPC
.86e3					  Push_String_Descriptor
.86e3	a6 18		ldx $18		          LDX TEMPPT          ; Descriptor stack pointer
.86e5	e0 24		cpx #$24	          CPX #TEMPPT+12      ; Descriptor stack limit
.86e7	d0 05		bne $86ee	          BNE PuSD_10
.86e9	a2 19		ldx #$19	          LDX #$19            ; FORMULA TOO COMPLEX
.86eb	4c 3c 4d	jmp $4d3c	          JMP Print_Error_X
.86ee	a5 63		lda $63		PuSD_10   LDA FAC1_EX
.86f0	95 00		sta $00,x	          STA 0,X
.86f2	a5 64		lda $64		          LDA FAC1_M1
.86f4	95 01		sta $01,x	          STA 1,X
.86f6	a5 65		lda $65		          LDA FAC1_M2
.86f8	95 02		sta $02,x	          STA 2,X
.86fa	a0 00		ldy #$00	          LDY #0
.86fc	86 66		stx $66		          STX FAC1_M3         ; mark stack position
.86fe	84 67		sty $67		          STY FAC1_M4
.8700	84 71		sty $71		          STY STRPTR+1
.8702	88		dey		          DEY                 ; Y = $ff
.8703	84 0f		sty $0f		          STY VALTYP          ; type = string
.8705	86 19		stx $19		          STX LASTPT          ; remember last used position
.8707	e8		inx		          INX                 ; increase descriptor stack pointer
.8708	e8		inx		          INX
.8709	e8		inx		          INX
.870a	86 18		stx $18		          STX TEMPPT
.870c	60		rts		          RTS
.870d					  Concatenate
.870d	a5 67		lda $67		          LDA FAC1_M4         ; push address of left operand
.870f	48		pha		          PHA
.8710	a5 66		lda $66		          LDA FAC1_M3
.8712	48		pha		          PHA
.8713	20 d7 78	jsr $78d7	          JSR Vectored_EVAL   ; evaluate right operand
.8716	20 dd 77	jsr $77dd	          JSR Need_String
.8719	68		pla		          PLA
.871a	85 70		sta $70		          STA STRPTR
.871c	68		pla		          PLA
.871d	85 71		sta $71		          STA STRPTR+1        ; pull address of left operand
.871f	a0 00		ldy #$00	          LDY #0
.8721	20 f6 42	jsr $42f6	          JSR Get_STRPTR_1
.8724	85 79		sta $79		          STA SYNTMP          ; length of left  string
.8726	20 e7 42	jsr $42e7	          JSR Get_FAC1_M3_1   ; length of right string
.8729	18		clc		          CLC
.872a	65 79		adc $79		          ADC SYNTMP          ; sum of lengths
.872c	90 03		bcc $8731	          BCC Conc_10
.872e	4c ed a5	jmp $a5ed	          JMP String_Too_Long
.8731	20 88 86	jsr $8688	Conc_10   JSR Allocate_String_FAC1
.8734	20 4e 87	jsr $874e	          JSR Store_String_STRPTR ; store left part
.8737	a5 52		lda $52		          LDA DSCPNT
.8739	a4 53		ldy $53		          LDY DSCPNT+1
.873b	20 85 87	jsr $8785	          JSR Free_String_AY
.873e	20 63 87	jsr $8763	          JSR Store_String_INDEXA ; store right part
.8741	a5 70		lda $70		          LDA STRPTR
.8743	a4 71		ldy $71		          LDY STRPTR+1
.8745	20 85 87	jsr $8785	          JSR Free_String_AY
.8748	20 e3 86	jsr $86e3	          JSR Push_String_Descriptor
.874b	4c 09 78	jmp $7809	          JMP EvEx_15
.874e					  Store_String_STRPTR
.874e	a0 00		ldy #$00	          LDY #0
.8750	20 f6 42	jsr $42f6	          JSR Get_STRPTR_1    ; A = length
.8753	48		pha		          PHA
.8754	c8		iny		          INY
.8755	20 f6 42	jsr $42f6	          JSR Get_STRPTR_1    ; X = address low
.8758	aa		tax		          TAX
.8759	c8		iny		          INY
.875a	20 f6 42	jsr $42f6	          JSR Get_STRPTR_1    ; Y = address high
.875d	a8		tay		          TAY
.875e	68		pla		          PLA
.875f	86 24		stx $24		          STX INDEXA
.8761	84 25		sty $25		          STY INDEXA+1
.8763					  Store_String_INDEXA
.8763	a8		tay		          TAY
.8764	f0 0b		beq $8771	          BEQ Adjust_FRESPC
.8766	48		pha		          PHA
.8767	88		dey		SSI_10    DEY
.8768	20 b7 03	jsr $03b7	          JSR Get_INDEXA_1
.876b	91 37		sta ($37),y	          STA (FRESPC),Y
.876d	98		tya		          TYA
.876e	d0 f7		bne $8767	          BNE SSI_10
.8770	68		pla		          PLA
.8771					  Adjust_FRESPC
.8771	18		clc		          CLC
.8772	65 37		adc $37		          ADC FRESPC
.8774	85 37		sta $37		          STA FRESPC
.8776	90 02		bcc $877a	          BCC AdFR_Ret
.8778	e6 38		inc $38		          INC FRESPC+1
.877a	60		rts		AdFR_Ret  RTS
.877b					  Eval_String
.877b	20 ef 77	jsr $77ef	          JSR Eval_Expression
.877e					  Eval_And_Free_String
.877e	20 dd 77	jsr $77dd	          JSR Need_String
.8781					  Free_String_FAC1
.8781	a5 66		lda $66		          LDA FAC1_M3
.8783	a4 67		ldy $67		          LDY FAC1_M4
.8785					  Free_String_AY
.8785	85 24		sta $24		          STA INDEXA
.8787	84 25		sty $25		          STY INDEXA+1        ; INDEXA = pointer to descriptor
.8789	20 e0 87	jsr $87e0	          JSR Pop_Descriptor_Stack
.878c	d0 3c		bne $87ca	          BNE FSAY_40         ; -> load if not temporary
.878e	20 f6 54	jsr $54f6	          JSR Back_Reference_Position
.8791	90 37		bcc $87ca	          BCC FSAY_40         ; -> branch if not a dynamic string
.8793	88		dey		          DEY
.8794	a9 ff		lda #$ff	          LDA #$ff
.8796	8d 04 ff	sta $ff04	          STA MMU_LCRD
.8799	91 24		sta ($24),y	          STA (INDEXA),Y      ; invalidate string (backref 1)
.879b	88		dey		          DEY                 ; Y = 0
.879c	8a		txa		          TXA
.879d	91 24		sta ($24),y	          STA (INDEXA),Y      ; store length (backref 0)
.879f	48		pha		          PHA
.87a0	49 ff		eor #$ff	          EOR #%11111111 ; $ff
.87a2	38		sec		          SEC
.87a3	65 24		adc $24		          ADC INDEXA
.87a5	a4 25		ldy $25		          LDY INDEXA+1
.87a7	b0 01		bcs $87aa	          BCS FSAY_10
.87a9	88		dey		          DEY
.87aa	85 24		sta $24		FSAY_10   STA INDEXA          ; INDEXA -= length
.87ac	84 25		sty $25		          STY INDEXA+1
.87ae	aa		tax		          TAX
.87af	68		pla		          PLA
.87b0	c4 36		cpy $36		          CPY FRETOP+1
.87b2	d0 3c		bne $87f0	          BNE PDS_Ret         ; return if INDEXA != FRETOP
.87b4	e4 35		cpx $35		          CPX FRETOP
.87b6	d0 38		bne $87f0	          BNE PDS_Ret
.87b8	48		pha		          PHA
.87b9	38		sec		          SEC
.87ba	65 35		adc $35		          ADC FRETOP
.87bc	85 35		sta $35		          STA FRETOP
.87be	90 02		bcc $87c2	          BCC FSAY_20
.87c0	e6 36		inc $36		          INC FRETOP+1
.87c2	e6 35		inc $35		FSAY_20   INC FRETOP          ; FRETOP += length + 2
.87c4	d0 02		bne $87c8	          BNE FSAY_30
.87c6	e6 36		inc $36		          INC FRETOP+1
.87c8	68		pla		FSAY_30   PLA
.87c9	60		rts		          RTS
.87ca	a0 00		ldy #$00	FSAY_40   LDY #0
.87cc	20 b7 03	jsr $03b7	          JSR Get_INDEXA_1
.87cf	48		pha		          PHA
.87d0	c8		iny		          INY
.87d1	20 b7 03	jsr $03b7	          JSR Get_INDEXA_1
.87d4	aa		tax		          TAX
.87d5	c8		iny		          INY
.87d6	20 b7 03	jsr $03b7	          JSR Get_INDEXA_1
.87d9	a8		tay		          TAY
.87da	86 24		stx $24		          STX INDEXA
.87dc	84 25		sty $25		          STY INDEXA+1
.87de	68		pla		          PLA
.87df	60		rts		          RTS
.87e0					  Pop_Descriptor_Stack
.87e0	c4 1a		cpy $1a		          CPY LASTPT+1
.87e2	d0 0c		bne $87f0	          BNE PDS_Ret
.87e4	c5 19		cmp $19		          CMP LASTPT
.87e6	d0 08		bne $87f0	          BNE PDS_Ret
.87e8	85 18		sta $18		          STA TEMPPT
.87ea	e9 03		sbc #$03	          SBC #3
.87ec	85 19		sta $19		          STA LASTPT
.87ee	a0 00		ldy #$00	          LDY #0
.87f0	60		rts		PDS_Ret   RTS
.87f1					  Get_Next_Byte_Var
.87f1	20 80 03	jsr $0380	          JSR CHRGET
.87f4					  Get_Byte_Var
.87f4	20 d7 77	jsr $77d7	          JSR Eval_Numeric
.87f7					  Eval_Byte
.87f7	20 ad 84	jsr $84ad	          JSR Eval_Positive_Integer
.87fa	a6 66		ldx $66		          LDX FAC1_M3
.87fc	d0 2d		bne $882b	          BNE FTLI_Err
.87fe	a6 67		ldx $67		          LDX FAC1_M4
.8800	4c 86 03	jmp $0386	          JMP CHRGOT
.8803					  LINNUM_Comma_Byte
.8803	20 d7 77	jsr $77d7	          JSR Eval_Numeric
.8806	20 15 88	jsr $8815	          JSR FAC1_To_LINNUM
.8809					  Comma_And_Byte
.8809	20 5c 79	jsr $795c	          JSR Need_Comma
.880c	4c f4 87	jmp $87f4	          JMP Get_Byte_Var
.880f					  Comma_And_LINNUM
.880f	20 5c 79	jsr $795c	          JSR Need_Comma
.8812					  Get_Integer
.8812	20 d7 77	jsr $77d7	          JSR Eval_Numeric
.8815					  FAC1_To_LINNUM
.8815	a5 68		lda $68		          LDA FAC1_SI
.8817	30 12		bmi $882b	          BMI FTLI_Err        ; only positive numbers
.8819	a5 63		lda $63		F1TL_10   LDA FAC1_EX
.881b	c9 91		cmp #$91	          CMP #$91
.881d	b0 0c		bcs $882b	          BCS FTLI_Err        ; -> greater 65536
.881f	20 c7 8c	jsr $8cc7	          JSR FAC1_INT
.8822	a5 66		lda $66		          LDA FAC1_M3
.8824	a4 67		ldy $67		          LDY FAC1_M4
.8826	84 16		sty $16		          STY LINNUM
.8828	85 17		sta $17		          STA LINNUM+1
.882a	60		rts		          RTS
.882b	4c 28 7d	jmp $7d28	FTLI_Err  JMP Error_Illegal_Quantity
.882e					  AY_Minus_FAC1
.882e	20 b4 8a	jsr $8ab4	          JSR Load_FAC2_From_AY_RAM
.8831					  OP_MINUS
.8831	a5 68		lda $68		          LDA FAC1_SI
.8833	49 ff		eor #$ff	          EOR #$ff
.8835	85 68		sta $68		          STA FAC1_SI
.8837	45 6f		eor $6f		          EOR FAC2_SI
.8839	85 70		sta $70		          STA STRPTR          ; pos = ADD, neg = SUB
.883b	a5 63		lda $63		          LDA FAC1_EX
.883d	4c 48 88	jmp $8848	          JMP OP_PLUS
.8840	20 79 89	jsr $8979	AFTF_00   JSR FACX_Bit_Shift
.8843	90 3d		bcc $8882	          BCC AFTF_40
.8845					  Add_Var_AY_To_FAC1
.8845	20 b4 8a	jsr $8ab4	          JSR Load_FAC2_From_AY_RAM
.8848					  OP_PLUS
.8848	d0 03		bne $884d	          BNE PLUS_10         ; -> branch if FAC1 is not 0
.884a	4c 28 8c	jmp $8c28	          JMP FAC2_To_FAC1    ; FAC1 = FAC2
.884d	a6 71		ldx $71		PLUS_10   LDX FROUND          ; rounding byte
.884f	86 58		stx $58		          STX OLDOV           ; copy it
.8851	a2 6a		ldx #$6a	          LDX #FAC2_EX        ; X points to FAC2
.8853	a5 6a		lda $6a		          LDA FAC2_EX
.8855					  AddSub_FAC2_To_FAC1
.8855	a8		tay		          TAY                 ; Y = exp 2
.8856	d0 01		bne $8859	          BNE AFTF_10
.8858	60		rts		          RTS                 ; return if FAC2 is zero
.8859	38		sec		AFTF_10   SEC
.885a	e5 63		sbc $63		          SBC FAC1_EX         ; A = exp 2 - exp 1
.885c	f0 24		beq $8882	          BEQ AFTF_40         ; -> exponents are equal
.885e	90 12		bcc $8872	          BCC AFTF_20         ; -> exp 2 < exp 1
.8860	84 63		sty $63		          STY FAC1_EX         ; exp 1 = exp 2
.8862	a4 6f		ldy $6f		          LDY FAC2_SI
.8864	84 68		sty $68		          STY FAC1_SI         ; sign 1 = sign 2
.8866	49 ff		eor #$ff	          EOR #$ff
.8868	69 00		adc #$00	          ADC #0              ; A = exp 1 - exp 2
.886a	a0 00		ldy #$00	          LDY #0
.886c	84 58		sty $58		          STY OLDOV           ; clear FAC2 rounding byte
.886e	a2 63		ldx #$63	          LDX #FAC1_EX        ; X points to FAC1
.8870	d0 04		bne $8876	          BNE AFTF_30         ; always
.8872	a0 00		ldy #$00	AFTF_20   LDY #0
.8874	84 71		sty $71		          STY FROUND          ; clear FAC1 rounding byte
.8876	c9 f9		cmp #$f9	AFTF_30   CMP #$f9
.8878	30 c6		bmi $8840	          BMI AFTF_00
.887a	a8		tay		          TAY
.887b	a5 71		lda $71		          LDA FROUND
.887d	56 01		lsr $01,x	          LSR 1,X
.887f	20 90 89	jsr $8990	          JSR Rotate_FACX
.8882	24 70		bit $70		AFTF_40   BIT STRPTR          ; add or subtract ?
.8884	10 57		bpl $88dd	          BPL AFTF_65           ; -> add mantissa of FAC2 to FAC1
.8886	a0 63		ldy #$63	          LDY #FAC1_EX
.8888	e0 6a		cpx #$6a	          CPX #FAC2_EX        ; if (X == FAC2) Y = FAC1
.888a	f0 02		beq $888e	          BEQ AFTF_50
.888c	a0 6a		ldy #$6a	          LDY #FAC2_EX        ; else           Y = FAC2
.888e	38		sec		AFTF_50   SEC
.888f	49 ff		eor #$ff	          EOR #$ff            ; negate rounding byte
.8891	65 58		adc $58		          ADC OLDOV
.8893	85 71		sta $71		          STA FROUND
.8895	b9 04 00	lda $0004,y	          LDA 4,Y
.8898	f5 04		sbc $04,x	          SBC 4,X
.889a	85 67		sta $67		          STA FAC1_M4
.889c	b9 03 00	lda $0003,y	          LDA 3,Y
.889f	f5 03		sbc $03,x	          SBC 3,X
.88a1	85 66		sta $66		          STA FAC1_M3
.88a3	b9 02 00	lda $0002,y	          LDA 2,Y
.88a6	f5 02		sbc $02,x	          SBC 2,X
.88a8	85 65		sta $65		          STA FAC1_M2
.88aa	b9 01 00	lda $0001,y	          LDA 1,Y
.88ad	f5 01		sbc $01,x	          SBC 1,X
.88af	85 64		sta $64		          STA FAC1_M1
.88b1	b0 03		bcs $88b6	AFTF_60   BCS Normalise_FAC1
.88b3	20 26 89	jsr $8926	          JSR Negate_FAC1
.88b6					  Normalise_FAC1
.88b6	a0 00		ldy #$00	          LDY #0              ; Y = 0
.88b8	98		tya		          TYA                 ; A = 0
.88b9	18		clc		          CLC
.88ba	a6 64		ldx $64		NF1_10    LDX FAC1_M1         ; MSB of mantissa
.88bc	d0 4a		bne $8908	          BNE AFTF_75         ; -> shift bitwise
.88be	a6 65		ldx $65		          LDX FAC1_M2         ; shift bytes
.88c0	86 64		stx $64		          STX FAC1_M1
.88c2	a6 66		ldx $66		          LDX FAC1_M3
.88c4	86 65		stx $65		          STX FAC1_M2
.88c6	a6 67		ldx $67		          LDX FAC1_M4
.88c8	86 66		stx $66		          STX FAC1_M3
.88ca	a6 71		ldx $71		          LDX FROUND
.88cc	86 67		stx $67		          STX FAC1_M4
.88ce	84 71		sty $71		          STY FROUND          ; FROUND = 0
.88d0	69 08		adc #$08	          ADC #8              ; A = shift count
.88d2	c9 20		cmp #$20	          CMP #32             ; maximum shift = 32 bit
.88d4	d0 e4		bne $88ba	          BNE NF1_10          ; loop
.88d6					  Clear_FAC1
.88d6	a9 00		lda #$00	          LDA #0
.88d8	85 63		sta $63		CF1_10    STA FAC1_EX
.88da	85 68		sta $68		CF1_20    STA FAC1_SI
.88dc	60		rts		          RTS
.88dd	65 58		adc $58		AFTF_65   ADC OLDOV           ; FAC2 rounding byte
.88df	85 71		sta $71		          STA FROUND
.88e1	a5 67		lda $67		          LDA FAC1_M4         ; add FAC2 mantissa to FAC1
.88e3	65 6e		adc $6e		          ADC FAC2_M4
.88e5	85 67		sta $67		          STA FAC1_M4
.88e7	a5 66		lda $66		          LDA FAC1_M3
.88e9	65 6d		adc $6d		          ADC FAC2_M3
.88eb	85 66		sta $66		          STA FAC1_M3
.88ed	a5 65		lda $65		          LDA FAC1_M2
.88ef	65 6c		adc $6c		          ADC FAC2_M2
.88f1	85 65		sta $65		          STA FAC1_M2
.88f3	a5 64		lda $64		          LDA FAC1_M1
.88f5	65 6b		adc $6b		          ADC FAC2_M1
.88f7	85 64		sta $64		          STA FAC1_M1
.88f9	4c 15 89	jmp $8915	          JMP AFTF_80
.88fc	69 01		adc #$01	AFTF_70   ADC #1
.88fe	06 71		asl $71		          ASL FROUND
.8900	26 67		rol $67		          ROL FAC1_M4
.8902	26 66		rol $66		          ROL FAC1_M3
.8904	26 65		rol $65		          ROL FAC1_M2
.8906	26 64		rol $64		          ROL FAC1_M1
.8908	10 f2		bpl $88fc	AFTF_75   BPL AFTF_70
.890a	38		sec		          SEC
.890b	e5 63		sbc $63		          SBC FAC1_EX
.890d	b0 c7		bcs $88d6	          BCS Clear_FAC1
.890f	49 ff		eor #$ff	          EOR #$ff
.8911	69 01		adc #$01	          ADC #1
.8913	85 63		sta $63		          STA FAC1_EX
.8915	90 0e		bcc $8925	AFTF_80   BCC AFTF_Ret
.8917	e6 63		inc $63		AFTF_85   INC FAC1_EX
.8919	f0 42		beq $895d	          BEQ Overflow_Error
.891b	66 64		ror $64		          ROR FAC1_M1
.891d	66 65		ror $65		          ROR FAC1_M2
.891f	66 66		ror $66		          ROR FAC1_M3
.8921	66 67		ror $67		          ROR FAC1_M4
.8923	66 71		ror $71		          ROR FROUND
.8925	60		rts		AFTF_Ret  RTS
.8926					  Negate_FAC1
.8926	a5 68		lda $68		          LDA FAC1_SI
.8928	49 ff		eor #$ff	          EOR #$ff
.892a	85 68		sta $68		          STA FAC1_SI
.892c					  Negate_FAC1_Mantissa
.892c	a5 64		lda $64		          LDA FAC1_M1
.892e	49 ff		eor #$ff	          EOR #$ff
.8930	85 64		sta $64		          STA FAC1_M1
.8932	a5 65		lda $65		          LDA FAC1_M2
.8934	49 ff		eor #$ff	          EOR #$ff
.8936	85 65		sta $65		          STA FAC1_M2
.8938	a5 66		lda $66		          LDA FAC1_M3
.893a	49 ff		eor #$ff	          EOR #$ff
.893c	85 66		sta $66		          STA FAC1_M3
.893e	a5 67		lda $67		          LDA FAC1_M4
.8940	49 ff		eor #$ff	          EOR #$ff
.8942	85 67		sta $67		          STA FAC1_M4
.8944	a5 71		lda $71		          LDA FROUND
.8946	49 ff		eor #$ff	          EOR #$ff
.8948	85 71		sta $71		          STA FROUND
.894a	e6 71		inc $71		          INC FROUND
.894c	d0 0e		bne $895c	          BNE IFM_Ret
.894e					  Inc_FAC1_Mantissa
.894e	e6 67		inc $67		          INC FAC1_M4
.8950	d0 0a		bne $895c	          BNE IFM_Ret
.8952	e6 66		inc $66		          INC FAC1_M3
.8954	d0 06		bne $895c	          BNE IFM_Ret
.8956	e6 65		inc $65		          INC FAC1_M2
.8958	d0 02		bne $895c	          BNE IFM_Ret
.895a	e6 64		inc $64		          INC FAC1_M1
.895c	60		rts		IFM_Ret   RTS
.895d					  Overflow_Error
.895d	a2 0f		ldx #$0f	          LDX #15
.895f	4c 3c 4d	jmp $4d3c	          JMP Print_Error_X
.8962					  FACX_Byte_Shift
.8962	a2 27		ldx #$27	          LDX #FAC3_M1-1
.8964	b4 04		ldy $04,x	FBS_10    LDY 4,X
.8966	84 71		sty $71		          STY FROUND
.8968	b4 03		ldy $03,x	          LDY 3,X
.896a	94 04		sty $04,x	          STY 4,X
.896c	b4 02		ldy $02,x	          LDY 2,X
.896e	94 03		sty $03,x	          STY 3,X
.8970	b4 01		ldy $01,x	          LDY 1,X
.8972	94 02		sty $02,x	          STY 2,X
.8974	ac df 03	ldy $03df	          LDY BITS
.8977	94 01		sty $01,x	          STY 1,X
.8979					  FACX_Bit_Shift
.8979	69 08		adc #$08	          ADC #8
.897b	30 e7		bmi $8964	          BMI FBS_10
.897d	f0 e5		beq $8964	          BEQ FBS_10
.897f	e9 08		sbc #$08	          SBC #8
.8981	a8		tay		          TAY
.8982	a5 71		lda $71		          LDA FROUND
.8984	b0 14		bcs $899a	          BCS FBS_40
.8986	16 01		asl $01,x	FBS_20    ASL 1,X
.8988	90 02		bcc $898c	          BCC FBS_30
.898a	f6 01		inc $01,x	          INC 1,X
.898c	76 01		ror $01,x	FBS_30    ROR 1,X
.898e	76 01		ror $01,x	          ROR 1,X
.8990					  Rotate_FACX
.8990	76 02		ror $02,x	          ROR 2,X
.8992	76 03		ror $03,x	          ROR 3,X
.8994	76 04		ror $04,x	          ROR 4,X
.8996	6a		ror a		          ROR A
.8997	c8		iny		          INY
.8998	d0 ec		bne $8986	          BNE FBS_20
.899a	18		clc		FBS_40    CLC
.899b	60		rts		          RTS
>899c	81 00 00 00 00			Real_1    .BYTE $81,$00,$00,$00,$00 ;.REAL $8100000000;    1.00000000000
>89a1	03				logcn2    .BYTE $03
>89a2	7f 5e 56 cb 79			          .BYTE $7f,$5e,$56,$cb,$79 ;.REAL $7f5e56cb79;    0.43425594189
>89a7	80 13 9b 0b 64			          .BYTE $80,$13,$9b,$0b,$64 ;.REAL $80139b0b64;    0.57658454124
>89ac	80 76 38 93 16			          .BYTE $80,$76,$38,$93,$16 ;.REAL $8076389316;    0.96180075919
>89b1	82 38 aa 3b 20			          .BYTE $82,$38,$aa,$3b,$20 ;.REAL $8238aa3b20;    2.88539007306
>89b6	80 35 04 f3 34			Sqrt2half .BYTE $80,$35,$04,$f3,$34 ;.REAL $803504f334;    0.70710678119
>89bb	81 35 04 f3 34			Sqrt2     .BYTE $81,$35,$04,$f3,$34 ;.REAL $813504f334;    1.41421356238
>89c0	80 80 00 00 00			Minus0_5  .BYTE $80,$80,$00,$00,$00 ;.REAL $8080000000;   -0.50000000000
>89c5	80 31 72 17 f8			Ln2       .BYTE $80,$31,$72,$17,$f8 ;.REAL $80317217f8;    0.69314718060
.89ca					  FUNC_LOG
.89ca	20 57 8c	jsr $8c57	          JSR Test_FAC1_Sign
.89cd	f0 02		beq $89d1	          BEQ LOG_10
.89cf	10 03		bpl $89d4	          BPL LOG_20
.89d1	4c 28 7d	jmp $7d28	LOG_10    JMP Error_Illegal_Quantity
.89d4	a5 63		lda $63		LOG_20    LDA FAC1_EX
.89d6	e9 7f		sbc #$7f	          SBC #$7f
.89d8	48		pha		          PHA
.89d9	a9 80		lda #$80	          LDA #$80
.89db	85 63		sta $63		          STA FAC1_EX
.89dd	a9 b6		lda #$b6	          LDA #<Sqrt2half
.89df	a0 89		ldy #$89	          LDY #>Sqrt2half
.89e1	20 12 8a	jsr $8a12	          JSR Add_AY_To_FAC1
.89e4	a9 bb		lda #$bb	          LDA #<Sqrt2
.89e6	a0 89		ldy #$89	          LDY #>Sqrt2
.89e8	20 1e 8a	jsr $8a1e	          JSR AY_Div_FAC1
.89eb	a9 9c		lda #$9c	          LDA #<Real_1
.89ed	a0 89		ldy #$89	          LDY #>Real_1
.89ef	20 18 8a	jsr $8a18	          JSR FAC1_Minus_AY
.89f2	a9 a1		lda #$a1	          LDA #<logcn2
.89f4	a0 89		ldy #$89	          LDY #>logcn2
.89f6	20 86 90	jsr $9086	          JSR Series_Evaluation
.89f9	a9 c0		lda #$c0	          LDA #<Minus0_5
.89fb	a0 89		ldy #$89	          LDY #>Minus0_5
.89fd	20 12 8a	jsr $8a12	          JSR Add_AY_To_FAC1
.8a00	68		pla		          PLA
.8a01	20 b0 8d	jsr $8db0	          JSR Add_A_To_FAC1
.8a04	a9 c5		lda #$c5	          LDA #<Ln2
.8a06	a0 89		ldy #$89	          LDY #>Ln2
.8a08					  Multiply_AY_To_FAC1
.8a08	20 89 8a	jsr $8a89	          JSR Load_FAC2_From_AY_ROM
.8a0b	4c 27 8a	jmp $8a27	          JMP OP_MULT
.8a0e					  Add_0_5_To_FAC1
.8a0e	a9 76		lda #$76	          LDA #<Real_0_5
.8a10	a0 8f		ldy #$8f	          LDY #>Real_0_5
.8a12					  Add_AY_To_FAC1
.8a12	20 89 8a	jsr $8a89	          JSR Load_FAC2_From_AY_ROM
.8a15	4c 48 88	jmp $8848	          JMP OP_PLUS
.8a18					  FAC1_Minus_AY
.8a18	20 89 8a	jsr $8a89	          JSR Load_FAC2_From_AY_ROM
.8a1b	4c 31 88	jmp $8831	          JMP OP_MINUS
.8a1e					  AY_Div_FAC1
.8a1e	20 89 8a	jsr $8a89	          JSR Load_FAC2_From_AY_ROM
.8a21	4c 4c 8b	jmp $8b4c	          JMP OP_DIV
.8a24					  AY_Mult_FAC1
.8a24	20 b4 8a	jsr $8ab4	          JSR Load_FAC2_From_AY_RAM
.8a27					  OP_MULT
.8a27	d0 03		bne $8a2c	          BNE MULT_10
.8a29	4c 88 8a	jmp $8a88	          JMP MULT_Ret
.8a2c	20 ec 8a	jsr $8aec	MULT_10   JSR Add_Exponents
.8a2f	a9 00		lda #$00	          LDA #0
.8a31	85 28		sta $28		          STA FAC3_M1
.8a33	85 29		sta $29		          STA FAC3_M2
.8a35	85 2a		sta $2a		          STA FAC3_M3
.8a37	85 2b		sta $2b		          STA FAC3_M4
.8a39	a5 71		lda $71		          LDA FROUND
.8a3b	20 5b 8a	jsr $8a5b	          JSR Mult_SubB
.8a3e	a5 67		lda $67		          LDA FAC1_M4
.8a40	20 55 8a	jsr $8a55	          JSR Mult_SubA
.8a43	a5 66		lda $66		          LDA FAC1_M3
.8a45	20 55 8a	jsr $8a55	          JSR Mult_SubA
.8a48	a5 65		lda $65		          LDA FAC1_M2
.8a4a	20 5b 8a	jsr $8a5b	          JSR Mult_SubB
.8a4d	a5 64		lda $64		          LDA FAC1_M1
.8a4f	20 5b 8a	jsr $8a5b	          JSR Mult_SubB
.8a52	4c c1 8b	jmp $8bc1	          JMP DIV_80
.8a55					  Mult_SubA
.8a55	d0 04		bne $8a5b	          BNE Mult_SubB       ; do bitwise multiply if A is not zero
.8a57	ea		nop		          NOP
.8a58	4c 62 89	jmp $8962	          JMP FACX_Byte_Shift ; else shift FAC3 right 8 bits
.8a5b					  Mult_SubB
.8a5b	4a		lsr a		          LSR A
.8a5c	09 80		ora #$80	          ORA #$80            ; make sure, that A remains not zero
.8a5e	a8		tay		MULT_20   TAY                 ; until 8 MoMe_60 are done
.8a5f	90 19		bcc $8a7a	          BCC MULT_30
.8a61	18		clc		          CLC
.8a62	a5 2b		lda $2b		          LDA FAC3_M4
.8a64	65 6e		adc $6e		          ADC FAC2_M4
.8a66	85 2b		sta $2b		          STA FAC3_M4
.8a68	a5 2a		lda $2a		          LDA FAC3_M3
.8a6a	65 6d		adc $6d		          ADC FAC2_M3
.8a6c	85 2a		sta $2a		          STA FAC3_M3
.8a6e	a5 29		lda $29		          LDA FAC3_M2
.8a70	65 6c		adc $6c		          ADC FAC2_M2
.8a72	85 29		sta $29		          STA FAC3_M2
.8a74	a5 28		lda $28		          LDA FAC3_M1
.8a76	65 6b		adc $6b		          ADC FAC2_M1
.8a78	85 28		sta $28		          STA FAC3_M1
.8a7a	66 28		ror $28		MULT_30   ROR FAC3_M1
.8a7c	66 29		ror $29		          ROR FAC3_M2
.8a7e	66 2a		ror $2a		          ROR FAC3_M3
.8a80	66 2b		ror $2b		          ROR FAC3_M4
.8a82	66 71		ror $71		          ROR FROUND
.8a84	98		tya		          TYA
.8a85	4a		lsr a		          LSR A
.8a86	d0 d6		bne $8a5e	          BNE MULT_20
.8a88	60		rts		MULT_Ret  RTS
.8a89					  Load_FAC2_From_AY_ROM
.8a89	85 24		sta $24		          STA INDEXA
.8a8b	84 25		sty $25		          STY INDEXA+1
.8a8d	a0 04		ldy #$04	          LDY #4
.8a8f	b1 24		lda ($24),y	          LDA (INDEXA),Y
.8a91	85 6e		sta $6e		          STA FAC2_M4
.8a93	88		dey		          DEY
.8a94	b1 24		lda ($24),y	          LDA (INDEXA),Y
.8a96	85 6d		sta $6d		          STA FAC2_M3
.8a98	88		dey		          DEY
.8a99	b1 24		lda ($24),y	          LDA (INDEXA),Y
.8a9b	85 6c		sta $6c		          STA FAC2_M2
.8a9d	88		dey		          DEY
.8a9e	b1 24		lda ($24),y	          LDA (INDEXA),Y      ; bit7 = sign
.8aa0	85 6f		sta $6f		          STA FAC2_SI         ; transfer sign to FAC2SI bit7
.8aa2	45 68		eor $68		          EOR FAC1_SI         ; EOR with sign of FAC1
.8aa4	85 70		sta $70		          STA STRPTR          ; flag sign comparison
.8aa6	a5 6f		lda $6f		          LDA FAC2_SI         ; load sign/byte 1 of mantissa
.8aa8	09 80		ora #$80	          ORA #$80            ; replace sign with 1 (normalize)
.8aaa	85 6b		sta $6b		          STA FAC2_M1         ; M1 is now in unpacked mode
.8aac	88		dey		          DEY                 ; Y = 0
.8aad	b1 24		lda ($24),y	          LDA (INDEXA),Y      ; exponent
.8aaf	85 6a		sta $6a		          STA FAC2_EX
.8ab1	a5 63		lda $63		          LDA FAC1_EX
.8ab3	60		rts		          RTS
.8ab4					  Load_FAC2_From_AY_RAM
.8ab4	85 24		sta $24		          STA INDEXA
.8ab6	84 25		sty $25		          STY INDEXA+1
.8ab8	ad 00 ff	lda $ff00	          LDA MMU_CR
.8abb	48		pha		          PHA                 ; save bank
.8abc	a0 04		ldy #$04	          LDY #4
.8abe	20 b7 03	jsr $03b7	          JSR Get_INDEXA_1
.8ac1	85 6e		sta $6e		          STA FAC2_M4
.8ac3	88		dey		          DEY
.8ac4	20 b7 03	jsr $03b7	          JSR Get_INDEXA_1
.8ac7	85 6d		sta $6d		          STA FAC2_M3
.8ac9	88		dey		          DEY
.8aca	20 b7 03	jsr $03b7	          JSR Get_INDEXA_1
.8acd	85 6c		sta $6c		          STA FAC2_M2
.8acf	88		dey		          DEY
.8ad0	20 b7 03	jsr $03b7	          JSR Get_INDEXA_1    ; bit7 = sign
.8ad3	85 6f		sta $6f		          STA FAC2_SI         ; transfer sign to FAC2SI bit7
.8ad5	45 68		eor $68		          EOR FAC1_SI         ; EOR with sign of FAC1
.8ad7	85 70		sta $70		          STA STRPTR          ; flag sign comparison
.8ad9	a5 6f		lda $6f		          LDA FAC2_SI         ; load sign/byte 1 of mantissa
.8adb	09 80		ora #$80	          ORA #$80            ; replace sign with 1 (normalize)
.8add	85 6b		sta $6b		          STA FAC2_M1         ; M1 is now in unpacked mode
.8adf	88		dey		          DEY                 ; Y = 0
.8ae0	20 b7 03	jsr $03b7	          JSR Get_INDEXA_1    ; exponent
.8ae3	85 6a		sta $6a		          STA FAC2_EX
.8ae5	68		pla		          PLA
.8ae6	8d 00 ff	sta $ff00	          STA MMU_CR          ; restore bank
.8ae9	a5 63		lda $63		          LDA FAC1_EX
.8aeb	60		rts		          RTS
.8aec					  Add_Exponents
.8aec	a5 6a		lda $6a		          LDA FAC2_EX
.8aee	f0 1f		beq $8b0f	ChFA_10   BEQ ChFA_50         ; -> set result = 0.0
.8af0	18		clc		          CLC
.8af1	65 63		adc $63		          ADC FAC1_EX         ; (exp 1 + exp 2)
.8af3	90 04		bcc $8af9	          BCC ChFA_20         ; -> no overflow
.8af5	30 1d		bmi $8b14	          BMI ChFA_Err        ; -> overflow
.8af7	18		clc		          CLC
>8af8	2c				          .BYTE $2C ;BIT
.8af9	10 14		bpl $8b0f	ChFA_20   BPL ChFA_50         ; -> underflow
.8afb	69 80		adc #$80	          ADC #$80            ; adjust bias
.8afd	85 63		sta $63		          STA FAC1_EX         ; exp 1 += exp 2
.8aff	d0 03		bne $8b04	          BNE ChFA_30
.8b01	4c da 88	jmp $88da	          JMP CF1_20
.8b04	a5 70		lda $70		ChFA_30   LDA STRPTR
.8b06	85 68		sta $68		          STA FAC1_SI
.8b08	60		rts		          RTS
.8b09	a5 68		lda $68		ChFA_40   LDA FAC1_SI         ; sign
.8b0b	49 ff		eor #$ff	          EOR #$ff            ; invert
.8b0d	30 05		bmi $8b14	          BMI ChFA_Err        ; -> error if sign was positive
.8b0f	68		pla		ChFA_50   PLA
.8b10	68		pla		          PLA
.8b11	4c d6 88	jmp $88d6	          JMP Clear_FAC1      ; FAC1 = 0.0
.8b14	4c 5d 89	jmp $895d	ChFA_Err  JMP Overflow_Error
.8b17					  Multiply_FAC1_BY_10
.8b17	20 38 8c	jsr $8c38	          JSR FAC1_Round_And_Copy_To_FAC2
.8b1a	aa		tax		          TAX
.8b1b	f0 10		beq $8b2d	          BEQ AAD_Ret
.8b1d	18		clc		          CLC
.8b1e	69 02		adc #$02	          ADC #2
.8b20	b0 f2		bcs $8b14	          BCS ChFA_Err
.8b22					  Add_And_Double
.8b22	a2 00		ldx #$00	          LDX #0
.8b24	86 70		stx $70		          STX STRPTR
.8b26	20 55 88	jsr $8855	          JSR AddSub_FAC2_To_FAC1
.8b29	e6 63		inc $63		          INC FAC1_EX
.8b2b	f0 e7		beq $8b14	          BEQ ChFA_Err
.8b2d	60		rts		AAD_Ret   RTS
>8b2e	84 20 00 00 00			Real_10   .BYTE $84,$20,$00,$00,$00 ;.REAL $8420000000;   10.00000000000
.8b33	a2 14		ldx #$14	DIV_ZERO  LDX #$14            ; DIVISION BY ZERO
.8b35	4c 3c 4d	jmp $4d3c	          JMP Print_Error_X
.8b38					  Divide_FAC1_By_10
.8b38	20 38 8c	jsr $8c38	          JSR FAC1_Round_And_Copy_To_FAC2
.8b3b	a9 2e		lda #$2e	          LDA #<Real_10
.8b3d	a0 8b		ldy #$8b	          LDY #>Real_10
.8b3f	a2 00		ldx #$00	          LDX #0
.8b41					  Divide_FAC2_By_AY
.8b41	86 70		stx $70		          STX STRPTR
.8b43	20 d4 8b	jsr $8bd4	          JSR Load_FAC1_AY
.8b46	4c 4c 8b	jmp $8b4c	          JMP OP_DIV
.8b49					  AY_Divided_By_FAC1
.8b49	20 b4 8a	jsr $8ab4	          JSR Load_FAC2_From_AY_RAM
.8b4c					  OP_DIV
.8b4c	f0 e5		beq $8b33	          BEQ DIV_ZERO        ; -> FAC1 was zero
.8b4e	20 47 8c	jsr $8c47	          JSR Round_FAC1
.8b51	a9 00		lda #$00	          LDA #0
.8b53	38		sec		          SEC
.8b54	e5 63		sbc $63		          SBC FAC1_EX
.8b56	85 63		sta $63		          STA FAC1_EX
.8b58	20 ec 8a	jsr $8aec	          JSR Add_Exponents
.8b5b	e6 63		inc $63		          INC FAC1_EX
.8b5d	f0 b5		beq $8b14	          BEQ ChFA_Err
.8b5f	a2 fc		ldx #$fc	          LDX #$fc             ; wrap around index
.8b61	a9 01		lda #$01	          LDA #1
.8b63	a4 6b		ldy $6b		DIV_10    LDY FAC2_M1
.8b65	c4 64		cpy $64		          CPY FAC1_M1
.8b67	d0 10		bne $8b79	          BNE DIV_20
.8b69	a4 6c		ldy $6c		          LDY FAC2_M2
.8b6b	c4 65		cpy $65		          CPY FAC1_M2
.8b6d	d0 0a		bne $8b79	          BNE DIV_20
.8b6f	a4 6d		ldy $6d		          LDY FAC2_M3
.8b71	c4 66		cpy $66		          CPY FAC1_M3
.8b73	d0 04		bne $8b79	          BNE DIV_20
.8b75	a4 6e		ldy $6e		          LDY FAC2_M4
.8b77	c4 67		cpy $67		          CPY FAC1_M4
.8b79	08		php		DIV_20    PHP
.8b7a	2a		rol a		          ROL A
.8b7b	90 09		bcc $8b86	          BCC DIV_30
.8b7d	e8		inx		          INX
.8b7e	95 2b		sta $2b,x	          STA FAC3_M4,X
.8b80	f0 32		beq $8bb4	          BEQ DIV_60
.8b82	10 34		bpl $8bb8	          BPL DIV_70
.8b84	a9 01		lda #$01	          LDA #1
.8b86	28		plp		DIV_30    PLP
.8b87	b0 0e		bcs $8b97	          BCS DIV_50
.8b89	06 6e		asl $6e		DIV_40    ASL FAC2_M4
.8b8b	26 6d		rol $6d		          ROL FAC2_M3
.8b8d	26 6c		rol $6c		          ROL FAC2_M2
.8b8f	26 6b		rol $6b		          ROL FAC2_M1
.8b91	b0 e6		bcs $8b79	          BCS DIV_20
.8b93	30 ce		bmi $8b63	          BMI DIV_10
.8b95	10 e2		bpl $8b79	          BPL DIV_20
.8b97	a8		tay		DIV_50    TAY
.8b98	a5 6e		lda $6e		          LDA FAC2_M4
.8b9a	e5 67		sbc $67		          SBC FAC1_M4
.8b9c	85 6e		sta $6e		          STA FAC2_M4
.8b9e	a5 6d		lda $6d		          LDA FAC2_M3
.8ba0	e5 66		sbc $66		          SBC FAC1_M3
.8ba2	85 6d		sta $6d		          STA FAC2_M3
.8ba4	a5 6c		lda $6c		          LDA FAC2_M2
.8ba6	e5 65		sbc $65		          SBC FAC1_M2
.8ba8	85 6c		sta $6c		          STA FAC2_M2
.8baa	a5 6b		lda $6b		          LDA FAC2_M1
.8bac	e5 64		sbc $64		          SBC FAC1_M1
.8bae	85 6b		sta $6b		          STA FAC2_M1
.8bb0	98		tya		          TYA
.8bb1	4c 89 8b	jmp $8b89	          JMP DIV_40
.8bb4	a9 40		lda #$40	DIV_60    LDA #$40 ; '@'
.8bb6	d0 ce		bne $8b86	          BNE DIV_30
.8bb8	0a		asl a		DIV_70    ASL A
.8bb9	0a		asl a		          ASL A
.8bba	0a		asl a		          ASL A
.8bbb	0a		asl a		          ASL A
.8bbc	0a		asl a		          ASL A
.8bbd	0a		asl a		          ASL A
.8bbe	85 71		sta $71		          STA FROUND
.8bc0	28		plp		          PLP
.8bc1	a5 28		lda $28		DIV_80    LDA FAC3_M1
.8bc3	85 64		sta $64		          STA FAC1_M1
.8bc5	a5 29		lda $29		          LDA FAC3_M2
.8bc7	85 65		sta $65		          STA FAC1_M2
.8bc9	a5 2a		lda $2a		          LDA FAC3_M3
.8bcb	85 66		sta $66		          STA FAC1_M3
.8bcd	a5 2b		lda $2b		          LDA FAC3_M4
.8bcf	85 67		sta $67		          STA FAC1_M4
.8bd1	4c b6 88	jmp $88b6	          JMP Normalise_FAC1
.8bd4					  Load_FAC1_AY
.8bd4	85 24		sta $24		          STA INDEXA
.8bd6	84 25		sty $25		          STY INDEXA+1
.8bd8	a0 04		ldy #$04	          LDY #4
.8bda	b1 24		lda ($24),y	          LDA (INDEXA),Y
.8bdc	85 67		sta $67		          STA FAC1_M4
.8bde	88		dey		          DEY
.8bdf	b1 24		lda ($24),y	          LDA (INDEXA),Y
.8be1	85 66		sta $66		          STA FAC1_M3
.8be3	88		dey		          DEY
.8be4	b1 24		lda ($24),y	          LDA (INDEXA),Y
.8be6	85 65		sta $65		          STA FAC1_M2
.8be8	88		dey		          DEY
.8be9	b1 24		lda ($24),y	          LDA (INDEXA),Y
.8beb	85 68		sta $68		          STA FAC1_SI
.8bed	09 80		ora #$80	          ORA #$80
.8bef	85 64		sta $64		          STA FAC1_M1
.8bf1	88		dey		          DEY                 ; Y = 0
.8bf2	b1 24		lda ($24),y	          LDA (INDEXA),Y
.8bf4	85 63		sta $63		          STA FAC1_EX
.8bf6	84 71		sty $71		          STY FROUND          ; FROUND = 0
.8bf8	60		rts		          RTS
.8bf9					  FAC1_To_FACTPB
.8bf9	a2 5e		ldx #$5e	          LDX #FACTPB
>8bfb	2c				          .BYTE $2C ;BIT
.8bfc					  FAC1_To_FACTPA
.8bfc	a2 59		ldx #$59	          LDX #FACTPA
.8bfe	a0 00		ldy #$00	          LDY #0
.8c00					  FAC1_To_XY
.8c00	20 47 8c	jsr $8c47	          JSR Round_FAC1
.8c03	86 24		stx $24		          STX INDEXA
.8c05	84 25		sty $25		          STY INDEXA+1
.8c07	a0 04		ldy #$04	          LDY #4
.8c09	a5 67		lda $67		          LDA FAC1_M4
.8c0b	91 24		sta ($24),y	          STA (INDEXA),Y
.8c0d	88		dey		          DEY
.8c0e	a5 66		lda $66		          LDA FAC1_M3
.8c10	91 24		sta ($24),y	          STA (INDEXA),Y
.8c12	88		dey		          DEY
.8c13	a5 65		lda $65		          LDA FAC1_M2
.8c15	91 24		sta ($24),y	          STA (INDEXA),Y
.8c17	88		dey		          DEY
.8c18	a5 68		lda $68		          LDA FAC1_SI
.8c1a	09 7f		ora #$7f	          ORA #$7f
.8c1c	25 64		and $64		          AND FAC1_M1
.8c1e	91 24		sta ($24),y	          STA (INDEXA),Y
.8c20	88		dey		          DEY
.8c21	a5 63		lda $63		          LDA FAC1_EX
.8c23	91 24		sta ($24),y	          STA (INDEXA),Y
.8c25	84 71		sty $71		          STY FROUND
.8c27	60		rts		          RTS
.8c28					  FAC2_To_FAC1
.8c28	a5 6f		lda $6f		          LDA FAC2_SI
.8c2a					  ASI_FAC2_To_FAC1
.8c2a	85 68		sta $68		          STA FAC1_SI
.8c2c	a2 05		ldx #$05	          LDX #5
.8c2e	b5 69		lda $69,x	F2F1_10   LDA FAC2_EX-1,X
.8c30	95 62		sta $62,x	          STA FAC1_EX-1,X
.8c32	ca		dex		          DEX
.8c33	d0 f9		bne $8c2e	          BNE F2F1_10
.8c35	86 71		stx $71		          STX FROUND
.8c37	60		rts		          RTS
.8c38					  FAC1_Round_And_Copy_To_FAC2
.8c38	20 47 8c	jsr $8c47	          JSR Round_FAC1
.8c3b					  FAC1_To_FAC2
.8c3b	a2 06		ldx #$06	          LDX #6
.8c3d	b5 62		lda $62,x	F1F2_10   LDA FAC1_EX-1,X
.8c3f	95 69		sta $69,x	          STA FAC2_EX-1,X
.8c41	ca		dex		          DEX
.8c42	d0 f9		bne $8c3d	          BNE F1F2_10
.8c44	86 71		stx $71		          STX FROUND
.8c46	60		rts		F1F2_Ret  RTS
.8c47					  Round_FAC1
.8c47	a5 63		lda $63		          LDA FAC1_EX
.8c49	f0 fb		beq $8c46	          BEQ F1F2_Ret
.8c4b	06 71		asl $71		          ASL FROUND
.8c4d	90 f7		bcc $8c46	          BCC F1F2_Ret
.8c4f					  Inc_FAC1
.8c4f	20 4e 89	jsr $894e	          JSR Inc_FAC1_Mantissa
.8c52	d0 f2		bne $8c46	          BNE F1F2_Ret
.8c54	4c 17 89	jmp $8917	          JMP AFTF_85
.8c57					  Test_FAC1_Sign
.8c57	a5 63		lda $63		          LDA FAC1_EX
.8c59	f0 09		beq $8c64	          BEQ TFS_Ret
.8c5b	a5 68		lda $68		TFS_10    LDA FAC1_SI
.8c5d	2a		rol a		TFS_20    ROL A
.8c5e	a9 ff		lda #$ff	          LDA #-1
.8c60	b0 02		bcs $8c64	          BCS TFS_Ret
.8c62	a9 01		lda #$01	          LDA #1
.8c64	60		rts		TFS_Ret   RTS
.8c65					  FUNC_SGN
.8c65	20 57 8c	jsr $8c57	          JSR Test_FAC1_Sign
.8c68					  A_To_FAC1
.8c68	85 64		sta $64		          STA FAC1_M1         ; value in M1
.8c6a	a9 00		lda #$00	          LDA #0
.8c6c	85 65		sta $65		          STA FAC1_M2         ; clear M2
.8c6e	a2 88		ldx #$88	          LDX #$88            ; exponent for integer in M1
.8c70	a5 64		lda $64		AFACX     LDA FAC1_M1
.8c72	49 ff		eor #$ff	          EOR #$ff            ; invert number
.8c74	2a		rol a		          ROL A               ; set carry for positive numbers
.8c75					  Word_To_FAC1
.8c75	a9 00		lda #$00	          LDA #0              ; clear lower half of mantissa
.8c77	85 67		sta $67		          STA FAC1_M4
.8c79	85 66		sta $66		          STA FAC1_M3
.8c7b	86 63		stx $63		IFACX     STX FAC1_EX         ; X to exponent
.8c7d	85 71		sta $71		          STA FROUND          ; clear rounding byte
.8c7f	85 68		sta $68		          STA FAC1_SI         ; clear sign (assume 16 bit unsigned word)
.8c81	4c b1 88	jmp $88b1	          JMP AFTF_60         ; -> normalize FAC1
.8c84					  FUNC_ABS
.8c84	46 68		lsr $68		          LSR FAC1_SI         ; clear FAC1 sign
.8c86	60		rts		          RTS
.8c87					  Compare_AY_FAC1
.8c87	85 26		sta $26		          STA INDEXB          ; INDEXB = 1st. = left  operand
.8c89	84 27		sty $27		          STY INDEXB+1        ; FAC1   = 2nd. = right operand
.8c8b	a0 00		ldy #$00	          LDY #0
.8c8d	b1 26		lda ($26),y	          LDA (INDEXB),Y      ; exp 1
.8c8f	c8		iny		          INY                 ; Y = 1
.8c90	aa		tax		          TAX                 ; X = exp 1
.8c91	f0 c4		beq $8c57	          BEQ Test_FAC1_Sign  ; -> left = 0 : get sign of right
.8c93	b1 26		lda ($26),y	          LDA (INDEXB),Y      ; M1
.8c95	45 68		eor $68		          EOR FAC1_SI         ; EOR both sign bits
.8c97	30 c2		bmi $8c5b	          BMI TFS_10          ; branch on different signs
.8c99	e4 63		cpx $63		          CPX FAC1_EX         ; compare exponents
.8c9b	d0 21		bne $8cbe	          BNE CAYF_10         ; branch if not equal
.8c9d	b1 26		lda ($26),y	          LDA (INDEXB),Y      ; M1
.8c9f	09 80		ora #$80	          ORA #$80            ; remove sign, set normalize bit
.8ca1	c5 64		cmp $64		          CMP FAC1_M1         ; compare M1's
.8ca3	d0 19		bne $8cbe	          BNE CAYF_10
.8ca5	c8		iny		          INY                 ; Y = 2
.8ca6	b1 26		lda ($26),y	          LDA (INDEXB),Y
.8ca8	c5 65		cmp $65		          CMP FAC1_M2         ; compare M2's
.8caa	d0 12		bne $8cbe	          BNE CAYF_10
.8cac	c8		iny		          INY                 ; Y = 3
.8cad	b1 26		lda ($26),y	          LDA (INDEXB),Y
.8caf	c5 66		cmp $66		          CMP FAC1_M3         ; compare M3's
.8cb1	d0 0b		bne $8cbe	          BNE CAYF_10
.8cb3	c8		iny		          INY                 ; Y = 4
.8cb4	a9 7f		lda #$7f	          LDA #$7f
.8cb6	c5 71		cmp $71		          CMP FROUND          ; clear carry for rounding bit set
.8cb8	b1 26		lda ($26),y	          LDA (INDEXB),Y
.8cba	e5 67		sbc $67		          SBC FAC1_M4         ; compare M4's with borrow
.8cbc	f0 2a		beq $8ce8	          BEQ FINT_20           ; numbers are equal
.8cbe	a5 68		lda $68		CAYF_10   LDA FAC1_SI
.8cc0	90 02		bcc $8cc4	          BCC CAYF_20
.8cc2	49 ff		eor #$ff	          EOR #$ff
.8cc4	4c 5d 8c	jmp $8c5d	CAYF_20   JMP TFS_20
.8cc7					  FAC1_INT
.8cc7	a5 63		lda $63		          LDA FAC1_EX
.8cc9	f0 4d		beq $8d18	          BEQ INT_0           ; clear all for zero exp
.8ccb	38		sec		          SEC
.8ccc	e9 a0		sbc #$a0	          SBC #$a0
.8cce	24 68		bit $68		          BIT FAC1_SI
.8cd0	10 0a		bpl $8cdc	          BPL FINT_10
.8cd2	aa		tax		          TAX                 ; save exp
.8cd3	a9 ff		lda #$ff	          LDA #$ff
.8cd5	8d df 03	sta $03df	          STA BITS
.8cd8	20 2c 89	jsr $892c	          JSR Negate_FAC1_Mantissa
.8cdb	8a		txa		          TXA                 ; restore exp
.8cdc	a2 63		ldx #$63	FINT_10   LDX #FAC1_EX
.8cde	c9 f9		cmp #$f9	          CMP #$f9
.8ce0	10 07		bpl $8ce9	          BPL FINT_30
.8ce2	20 79 89	jsr $8979	          JSR FACX_Bit_Shift
.8ce5	8c df 03	sty $03df	          STY BITS
.8ce8	60		rts		FINT_20   RTS
.8ce9	a8		tay		FINT_30   TAY
.8cea	a5 68		lda $68		          LDA FAC1_SI
.8cec	29 80		and #$80	          AND #%10000000     ; propagate sign
.8cee	46 64		lsr $64		          LSR FAC1_M1
.8cf0	05 64		ora $64		          ORA FAC1_M1
.8cf2	85 64		sta $64		          STA FAC1_M1
.8cf4	20 90 89	jsr $8990	          JSR Rotate_FACX
.8cf7	8c df 03	sty $03df	          STY BITS
.8cfa	60		rts		          RTS
.8cfb					  FUNC_INT
.8cfb	a5 63		lda $63		          LDA FAC1_EX
.8cfd	c9 a0		cmp #$a0	          CMP #$a0
.8cff	b0 20		bcs $8d21	          BCS INT_Ret         ; -> already integer
.8d01	20 68 aa	jsr $aa68	          JSR FAC1_Round_INT  ; -> convert to 32 bit integer
.8d04	84 71		sty $71		          STY FROUND          ; FROUND = 0
.8d06	a5 68		lda $68		          LDA FAC1_SI
.8d08	84 68		sty $68		          STY FAC1_SI         ; FAC1_SI = 0
.8d0a	49 80		eor #$80	          EOR #$80
.8d0c	2a		rol a		          ROL A
.8d0d	a9 a0		lda #$a0	          LDA #$a0            ; exp value for 32 bit integer
.8d0f	85 63		sta $63		          STA FAC1_EX
.8d11	a5 67		lda $67		          LDA FAC1_M4
.8d13	85 09		sta $09		          STA CHARAC
.8d15	4c b1 88	jmp $88b1	          JMP AFTF_60
.8d18	85 64		sta $64		INT_0     STA FAC1_M1         ; clear mantissa
.8d1a	85 65		sta $65		          STA FAC1_M2
.8d1c	85 66		sta $66		          STA FAC1_M3
.8d1e	85 67		sta $67		          STA FAC1_M4
.8d20	a8		tay		          TAY                 ; Y = 0 on exit
.8d21	60		rts		INT_Ret   RTS
.8d22					  Read_Real_To_FAC1
.8d22	8e da 03	stx $03da	          STX STR_BANK        ; bank for string to read
.8d25	a0 00		ldy #$00	          LDY #0
.8d27	a2 0a		ldx #$0a	          LDX #10
.8d29	94 5f		sty $5f,x	RRTF_10   STY TMPVAR,X        ; clear LOWTR, FAC1, etc.
.8d2b	ca		dex		          DEX
.8d2c	10 fb		bpl $8d29	          BPL RRTF_10
.8d2e	90 0f		bcc $8d3f	          BCC RRTF_16         ; -> numeric
.8d30	c9 2d		cmp #$2d	          CMP #'-'
.8d32	d0 04		bne $8d38	          BNE RRTF_12
.8d34	86 69		stx $69		          STX DEGREE          ; $ff = flag for - sign
.8d36	f0 04		beq $8d3c	          BEQ RRTF_14         ; branch always
.8d38	c9 2b		cmp #$2b	RRTF_12   CMP #'+'            ; skip + sign
.8d3a	d0 05		bne $8d41	          BNE RRTF_18
.8d3c	20 f5 8d	jsr $8df5	RRTF_14   JSR CHRGET_INDEXA   ; get next char
.8d3f	90 5b		bcc $8d9c	RRTF_16   BCC RRTF_42         ; -> numeric
.8d41	c9 2e		cmp #$2e	RRTF_18   CMP #'.'            ; decimal point ?
.8d43	f0 2e		beq $8d73	          BEQ RRTF_28         ; -> now the fractional part
.8d45	c9 45		cmp #$45	          CMP #'E'            ; exponent ?
.8d47	d0 30		bne $8d79	          BNE RRTF_30
.8d49	20 f5 8d	jsr $8df5	          JSR CHRGET_INDEXA   ; read character of exponent
.8d4c	90 17		bcc $8d65	          BCC RRTF_24         ; -> numeric
.8d4e	c9 ab		cmp #$ab	          CMP #$ab            ; '-' token
.8d50	f0 0e		beq $8d60	          BEQ RRTF_20
.8d52	c9 2d		cmp #$2d	          CMP #'-'
.8d54	f0 0a		beq $8d60	          BEQ RRTF_20
.8d56	c9 aa		cmp #$aa	          CMP #$aa            ; '+' token
.8d58	f0 08		beq $8d62	          BEQ RRTF_22
.8d5a	c9 2b		cmp #$2b	          CMP #'+'
.8d5c	f0 04		beq $8d62	          BEQ RRTF_22
.8d5e	d0 07		bne $8d67	          BNE RRTF_26         ; always
.8d60	66 62		ror $62		RRTF_20   ROR LOWTR+1         ; flag negative sign
.8d62	20 f5 8d	jsr $8df5	RRTF_22   JSR CHRGET_INDEXA   ; read character of exponent
.8d65	90 5c		bcc $8dc3	RRTF_24   BCC RRTF_50           ; -> numeric
.8d67	24 62		bit $62		RRTF_26   BIT LOWTR+1
.8d69	10 0e		bpl $8d79	          BPL RRTF_30         ; -> positive exponent
.8d6b	a9 00		lda #$00	          LDA #0
.8d6d	38		sec		          SEC
.8d6e	e5 60		sbc $60		          SBC TENEXP          ; -> negative exponent
.8d70	4c 7b 8d	jmp $8d7b	          JMP RRTF_32
.8d73	66 61		ror $61		RRTF_28   ROR LOWTR           ; bit 7 = flag for '.'
.8d75	24 61		bit $61		          BIT LOWTR
.8d77	50 c3		bvc $8d3c	          BVC RRTF_14         ; break if 2nd. dot read
.8d79	a5 60		lda $60		RRTF_30   LDA TENEXP          ; exponent read
.8d7b	38		sec		RRTF_32   SEC
.8d7c	e5 5f		sbc $5f		          SBC TMPVAR          ; minus # of digits after '.'
.8d7e	85 60		sta $60		          STA TENEXP          ; effective exponent
.8d80	f0 12		beq $8d94	          BEQ RRTF_38         ; -> zero exponent
.8d82	10 09		bpl $8d8d	          BPL RRTF_36         ; -> pos. exponent
.8d84	20 38 8b	jsr $8b38	RRTF_34   JSR Divide_FAC1_By_10 ; neg. exponent
.8d87	e6 60		inc $60		          INC TENEXP
.8d89	d0 f9		bne $8d84	          BNE RRTF_34
.8d8b	f0 07		beq $8d94	          BEQ RRTF_38
.8d8d	20 17 8b	jsr $8b17	RRTF_36   JSR Multiply_FAC1_BY_10 ; positive exponent
.8d90	c6 60		dec $60		          DEC TENEXP
.8d92	d0 f9		bne $8d8d	          BNE RRTF_36
.8d94	a5 69		lda $69		RRTF_38   LDA DEGREE          ; load sign
.8d96	30 01		bmi $8d99	          BMI RRTF_40         ; -> negate result
.8d98	60		rts		          RTS
.8d99	4c fa 8f	jmp $8ffa	RRTF_40   JMP OP_NEG
.8d9c	48		pha		RRTF_42   PHA
.8d9d	24 61		bit $61		          BIT LOWTR
.8d9f	10 02		bpl $8da3	          BPL RRTF_44
.8da1	e6 5f		inc $5f		          INC TMPVAR
.8da3	20 17 8b	jsr $8b17	RRTF_44   JSR Multiply_FAC1_BY_10
.8da6	68		pla		          PLA
.8da7	38		sec		          SEC
.8da8	e9 30		sbc #$30	          SBC #'0'
.8daa	20 b0 8d	jsr $8db0	          JSR Add_A_To_FAC1
.8dad	4c 3c 8d	jmp $8d3c	          JMP RRTF_14
.8db0					  Add_A_To_FAC1
.8db0	48		pha		          PHA
.8db1	20 38 8c	jsr $8c38	          JSR FAC1_Round_And_Copy_To_FAC2
.8db4	68		pla		          PLA
.8db5	20 68 8c	jsr $8c68	          JSR A_To_FAC1
.8db8	a5 6f		lda $6f		          LDA FAC2_SI
.8dba	45 68		eor $68		          EOR FAC1_SI
.8dbc	85 70		sta $70		          STA STRPTR
.8dbe	a6 63		ldx $63		          LDX FAC1_EX
.8dc0	4c 48 88	jmp $8848	          JMP OP_PLUS
.8dc3	a5 60		lda $60		RRTF_50   LDA TENEXP          ; exponent so far
.8dc5	c9 0a		cmp #$0a	          CMP #10             ; alreay two digits ?
.8dc7	90 09		bcc $8dd2	          BCC RRTF_52         ; -> OK if less than 10
.8dc9	a9 64		lda #$64	          LDA #100            ; exponent = 100
.8dcb	24 62		bit $62		          BIT LOWTR+1
.8dcd	30 21		bmi $8df0	          BMI RRTF_58         ; -> negative exponent
.8dcf	4c 5d 89	jmp $895d	          JMP Overflow_Error  ; max value = 37
.8dd2	0a		asl a		RRTF_52   ASL A               ; *  2
.8dd3	0a		asl a		          ASL A               ; *  4
.8dd4	18		clc		          CLC
.8dd5	65 60		adc $60		          ADC TENEXP          ; *  5
.8dd7	0a		asl a		          ASL A               ; * 10
.8dd8	18		clc		          CLC
.8dd9	a0 00		ldy #$00	          LDY #0
.8ddb	85 79		sta $79		          STA SYNTMP
.8ddd	ad da 03	lda $03da	          LDA STR_BANK
.8de0	d0 06		bne $8de8	          BNE RRTF_54
.8de2	20 c9 03	jsr $03c9	          JSR INDTXT
.8de5	4c eb 8d	jmp $8deb	          JMP RRTF_56
.8de8	20 b7 03	jsr $03b7	RRTF_54   JSR Get_INDEXA_1
.8deb	65 79		adc $79		RRTF_56   ADC SYNTMP
.8ded	38		sec		          SEC
.8dee	e9 30		sbc #$30	          SBC #'0'
.8df0	85 60		sta $60		RRTF_58   STA TENEXP          ; new value for exponent
.8df2	4c 62 8d	jmp $8d62	          JMP RRTF_22
.8df5					  CHRGET_INDEXA
.8df5	ad da 03	lda $03da	          LDA STR_BANK
.8df8	d0 03		bne $8dfd	          BNE CHXA_10
.8dfa	4c 80 03	jmp $0380	          JMP CHRGET          ; use default for bank 0
.8dfd	e6 24		inc $24		CHXA_10   INC INDEXA
.8dff	d0 02		bne $8e03	          BNE CHRGOT_INDEXA
.8e01	e6 25		inc $25		          INC INDEXA+1
.8e03					  CHRGOT_INDEXA
.8e03	a0 00		ldy #$00	          LDY #0
.8e05	20 b7 03	jsr $03b7	          JSR Get_INDEXA_1
.8e08	c9 3a		cmp #$3a	          CMP #':'
.8e0a	b0 0a		bcs $8e16	          BCS CHXA_Ret
.8e0c	c9 20		cmp #$20	          CMP #' '
.8e0e	f0 ed		beq $8dfd	          BEQ CHXA_10
.8e10	38		sec		          SEC
.8e11	e9 30		sbc #$30	          SBC #'0'
.8e13	38		sec		          SEC
.8e14	e9 d0		sbc #$d0	          SBC #$d0
.8e16	60		rts		CHXA_Ret  RTS
>8e17	9b 3e bc 1f fd			R9E9      .BYTE $9b,$3e,$bc,$1f,$fd   ;.REAL $9b3ebc1ffd; 99999999.90625000000
>8e1c	9e 6e 6b 27 fd			R9E10     .BYTE $9e,$6e,$6b,$27,$fd  ;.REAL $9e6e6b27fd; 999999999.25000000000
>8e21	9e 6e 6b 28 00			R1E10     .BYTE $9e,$6e,$6b,$28,$00 ;.REAL $9e6e6b2800; 1000000000.00000000000
.8e26					  Print_IN_CURLIN
.8e26	20 81 92	jsr $9281	          JSR B_PRIMM
>8e29	20 49 4e 20 00			          .TEXT " IN ",0
.8e2e					  Print_CURLIN
.8e2e	a5 3c		lda $3c		          LDA CURLIN+1
.8e30	a6 3b		ldx $3b		          LDX CURLIN
.8e32					  Print_Integer_XA
.8e32	85 64		sta $64		          STA FAC1_M1
.8e34	86 65		stx $65		          STX FAC1_M2
.8e36	a2 90		ldx #$90	          LDX #$90            ; exponent for 16 bit integer in M1/M2
.8e38	38		sec		          SEC
.8e39	20 75 8c	jsr $8c75	          JSR Word_To_FAC1
.8e3c	20 44 8e	jsr $8e44	          JSR Format_FAC1_Y
.8e3f	4c e2 55	jmp $55e2	          JMP Print_String
.8e42					  Format_FAC1
.8e42	a0 01		ldy #$01	          LDY #1              ; start of string storage
.8e44					  Format_FAC1_Y
.8e44	a9 20		lda #$20	          LDA #' '            ; default for positive number
.8e46	24 68		bit $68		          BIT FAC1_SI
.8e48	10 02		bpl $8e4c	          BPL FoFa_10
.8e4a	a9 2d		lda #$2d	          LDA #'-'            ; sign for negative number
.8e4c	99 ff 00	sta $00ff,y	FoFa_10   STA STACK-1,Y        ; store sign character
.8e4f	85 68		sta $68		          STA FAC1_SI         ; clear sign bit
.8e51	84 72		sty $72		          STY STRNG2          ; save Y
.8e53	c8		iny		          INY                 ; next string position
.8e54	a9 30		lda #$30	          LDA #'0'            ; default for value zero
.8e56	a6 63		ldx $63		          LDX FAC1_EX
.8e58	d0 03		bne $8e5d	          BNE FoFa_12
.8e5a	4c 69 8f	jmp $8f69	          JMP FoFa_60
.8e5d	a9 00		lda #$00	FoFa_12   LDA #0
.8e5f	e0 80		cpx #$80	          CPX #$80            ; exponent > 1.0 ?
.8e61	f0 02		beq $8e65	          BEQ FoFa_14
.8e63	b0 09		bcs $8e6e	          BCS FoFa_16         ; -> OK
.8e65	a9 21		lda #$21	FoFa_14   LDA #<R1E10
.8e67	a0 8e		ldy #$8e	          LDY #>R1E10
.8e69	20 08 8a	jsr $8a08	          JSR Multiply_AY_To_FAC1
.8e6c	a9 f7		lda #$f7	          LDA #-9
.8e6e	85 5f		sta $5f		FoFa_16   STA TMPVAR          ; current 10's exponent
.8e70	a9 1c		lda #$1c	FoFa_18   LDA #<R9E10
.8e72	a0 8e		ldy #$8e	          LDY #>R9E10
.8e74	20 87 8c	jsr $8c87	          JSR Compare_AY_FAC1
.8e77	f0 1e		beq $8e97	          BEQ FoFa_28
.8e79	10 12		bpl $8e8d	          BPL FoFa_24
.8e7b	a9 17		lda #$17	FoFa_20   LDA #<R9E9
.8e7d	a0 8e		ldy #$8e	          LDY #>R9E9
.8e7f	20 87 8c	jsr $8c87	          JSR Compare_AY_FAC1
.8e82	f0 02		beq $8e86	          BEQ FoFa_22
.8e84	10 0e		bpl $8e94	          BPL FoFa_26
.8e86	20 17 8b	jsr $8b17	FoFa_22   JSR Multiply_FAC1_BY_10
.8e89	c6 5f		dec $5f		          DEC TMPVAR
.8e8b	d0 ee		bne $8e7b	          BNE FoFa_20
.8e8d	20 38 8b	jsr $8b38	FoFa_24   JSR Divide_FAC1_By_10
.8e90	e6 5f		inc $5f		          INC TMPVAR          ; increment 10's exponent
.8e92	d0 dc		bne $8e70	          BNE FoFa_18
.8e94	20 0e 8a	jsr $8a0e	FoFa_26   JSR Add_0_5_To_FAC1 ; add 0.5 for rounding
.8e97	20 c7 8c	jsr $8cc7	FoFa_28   JSR FAC1_INT        ; convert to integer
.8e9a	a2 01		ldx #$01	          LDX #1
.8e9c	a5 5f		lda $5f		          LDA TMPVAR          ; current 10's exponent
.8e9e	18		clc		          CLC
.8e9f	69 0a		adc #$0a	          ADC #10             ; exp difference
.8ea1	30 09		bmi $8eac	          BMI FoFa_30         ; value < 1.0
.8ea3	c9 0b		cmp #$0b	          CMP #11
.8ea5	b0 06		bcs $8ead	          BCS FoFa_32
.8ea7	69 ff		adc #$ff	          ADC #$ff
.8ea9	aa		tax		          TAX                 ; X = exp + 9
.8eaa	a9 02		lda #$02	          LDA #2              ; fixed point
.8eac	38		sec		FoFa_30   SEC
.8ead	e9 02		sbc #$02	FoFa_32   SBC #2
.8eaf	85 60		sta $60		          STA TENEXP          ; exp print = 0 or exp+8
.8eb1	86 5f		stx $5f		          STX TMPVAR          ; digits before decimal point
.8eb3	8a		txa		          TXA
.8eb4	f0 02		beq $8eb8	          BEQ FoFa_34         ; -> if no digits before point
.8eb6	10 13		bpl $8ecb	          BPL FoFa_38
.8eb8	a4 72		ldy $72		FoFa_34   LDY STRNG2
.8eba	a9 2e		lda #$2e	          LDA # '.'
.8ebc	c8		iny		          INY
.8ebd	99 ff 00	sta $00ff,y	          STA STACK-1,Y        ; insert decimal point
.8ec0	8a		txa		          TXA
.8ec1	f0 06		beq $8ec9	          BEQ FoFa_36
.8ec3	a9 30		lda #$30	          LDA #'0'
.8ec5	c8		iny		          INY
.8ec6	99 ff 00	sta $00ff,y	          STA STACK-1,Y        ; insert '0'
.8ec9	84 72		sty $72		FoFa_36   STY STRNG2
.8ecb	a0 00		ldy #$00	FoFa_38   LDY #0
.8ecd					  Format_Clock_String
.8ecd	a2 80		ldx #$80	          LDX #$80
.8ecf	a5 67		lda $67		FoFa_40   LDA FAC1_M4
.8ed1	18		clc		          CLC
.8ed2	79 7e 8f	adc $8f7e,y	          ADC Dec_Print_Tab+3,Y
.8ed5	85 67		sta $67		          STA FAC1_M4
.8ed7	a5 66		lda $66		          LDA FAC1_M3
.8ed9	79 7d 8f	adc $8f7d,y	          ADC Dec_Print_Tab+2,Y
.8edc	85 66		sta $66		          STA FAC1_M3
.8ede	a5 65		lda $65		          LDA FAC1_M2
.8ee0	79 7c 8f	adc $8f7c,y	          ADC Dec_Print_Tab+1,Y
.8ee3	85 65		sta $65		          STA FAC1_M2
.8ee5	a5 64		lda $64		          LDA FAC1_M1
.8ee7	79 7b 8f	adc $8f7b,y	          ADC Dec_Print_Tab,Y
.8eea	85 64		sta $64		          STA FAC1_M1
.8eec	e8		inx		          INX
.8eed	b0 04		bcs $8ef3	          BCS FoFa_42
.8eef	10 de		bpl $8ecf	          BPL FoFa_40
.8ef1	30 02		bmi $8ef5	          BMI FoFa_44
.8ef3	30 da		bmi $8ecf	FoFa_42   BMI FoFa_40
.8ef5	8a		txa		FoFa_44   TXA
.8ef6	90 04		bcc $8efc	          BCC FoFa_46
.8ef8	49 ff		eor #$ff	          EOR #$ff
.8efa	69 0a		adc #$0a	          ADC #10
.8efc	69 2f		adc #$2f	FoFa_46   ADC #'0'-1
.8efe	c8		iny		          INY
.8eff	c8		iny		          INY
.8f00	c8		iny		          INY
.8f01	c8		iny		          INY                 ; Y += 4
.8f02	84 49		sty $49		          STY VARPNT          ; save index to Dec_Print_Tab
.8f04	a4 72		ldy $72		          LDY STRNG2          ; get index to string
.8f06	c8		iny		          INY
.8f07	aa		tax		          TAX
.8f08	29 7f		and #$7f	          AND #$7f
.8f0a	99 ff 00	sta $00ff,y	          STA STACK-1,Y        ; store digit
.8f0d	c6 5f		dec $5f		          DEC TMPVAR          ; # of digits
.8f0f	d0 06		bne $8f17	          BNE FoFa_48         ; -> if not zero
.8f11	a9 2e		lda #$2e	          LDA #'.'
.8f13	c8		iny		          INY
.8f14	99 ff 00	sta $00ff,y	          STA STACK-1,Y        ; store decimal point
.8f17	84 72		sty $72		FoFa_48   STY STRNG2          ; save string index
.8f19	a4 49		ldy $49		          LDY VARPNT          ; get table index
.8f1b	8a		txa		          TXA
.8f1c	49 ff		eor #$ff	          EOR #$ff
.8f1e	29 80		and #$80	          AND #$80
.8f20	aa		tax		          TAX
.8f21	c0 24		cpy #$24	          CPY #$24            ; end of decimal table ?
.8f23	f0 04		beq $8f29	          BEQ FoFa_50
.8f25	c0 3c		cpy #$3c	          CPY #$3c            ; end of jiffy table ?
.8f27	d0 a6		bne $8ecf	          BNE FoFa_40
.8f29	a4 72		ldy $72		FoFa_50   LDY STRNG2
.8f2b	b9 ff 00	lda $00ff,y	FoFa_52   LDA STACK-1,Y
.8f2e	88		dey		          DEY
.8f2f	c9 30		cmp #$30	          CMP #'0'
.8f31	f0 f8		beq $8f2b	          BEQ FoFa_52
.8f33	c9 2e		cmp #$2e	          CMP #'.'
.8f35	f0 01		beq $8f38	          BEQ FoFa_54
.8f37	c8		iny		          INY
.8f38	a9 2b		lda #$2b	FoFa_54   LDA #'+'            ; default sign for exponent
.8f3a	a6 60		ldx $60		          LDX TENEXP
.8f3c	f0 2e		beq $8f6c	          BEQ FoFa_62
.8f3e	10 08		bpl $8f48	          BPL FoFa_56
.8f40	a9 00		lda #$00	          LDA #0
.8f42	38		sec		          SEC
.8f43	e5 60		sbc $60		          SBC TENEXP
.8f45	aa		tax		          TAX
.8f46	a9 2d		lda #$2d	          LDA #'-'            ; negative sign for exponent
.8f48	99 01 01	sta $0101,y	FoFa_56   STA STACK+1,Y
.8f4b	a9 45		lda #$45	          LDA #'E'
.8f4d	99 00 01	sta $0100,y	          STA STACK,Y
.8f50	8a		txa		          TXA
.8f51	a2 2f		ldx #$2f	          LDX #'0'-1
.8f53	38		sec		          SEC
.8f54	e8		inx		FoFa_58   INX
.8f55	e9 0a		sbc #$0a	          SBC #10
.8f57	b0 fb		bcs $8f54	          BCS FoFa_58
.8f59	69 3a		adc #$3a	          ADC #'9'+1
.8f5b	99 03 01	sta $0103,y	          STA STACK+3,Y
.8f5e	8a		txa		          TXA
.8f5f	99 02 01	sta $0102,y	          STA STACK+2,Y
.8f62	a9 00		lda #$00	          LDA #0
.8f64	99 04 01	sta $0104,y	          STA STACK+4,Y
.8f67	f0 08		beq $8f71	          BEQ FoFa_64         ; always
.8f69	99 ff 00	sta $00ff,y	FoFa_60   STA STACK-1,Y
.8f6c	a9 00		lda #$00	FoFa_62   LDA #0
.8f6e	99 00 01	sta $0100,y	          STA STACK,Y
.8f71	a9 00		lda #$00	FoFa_64   LDA #0
.8f73	a0 01		ldy #$01	          LDY #1
.8f75	60		rts		          RTS
>8f76	80 00 00 00 00			Real_0_5  .BYTE $80,$00,$00,$00,$00 ;.REAL $8000000000;    0.5
.8f7b					  Dec_Print_Tab
>8f7b	fa 0a 1f 00			          .BYTE $fa,$0a,$1f,$00 ; -100000000
>8f7f	00 98 96 80			          .BYTE $00,$98,$96,$80 ;   10000000
>8f83	ff f0 bd c0			          .BYTE $ff,$f0,$bd,$c0 ;   -1000000
>8f87	00 01 86 a0			          .BYTE $00,$01,$86,$a0 ;     100000
>8f8b	ff ff d8 f0			          .BYTE $ff,$ff,$d8,$f0 ;     -10000
>8f8f	00 00 03 e8			          .BYTE $00,$00,$03,$e8 ;       1000
>8f93	ff ff ff 9c			          .BYTE $ff,$ff,$ff,$9c ;       -100
>8f97	00 00 00 0a			          .BYTE $00,$00,$00,$0a ;         10
>8f9b	ff ff ff ff			          .BYTE $ff,$ff,$ff,$ff ;         -1
.8f9f					 Clock_Print_Tab
>8f9f	ff df 0a 80			          .BYTE $ff,$df,$0a,$80 ;   -2160000
>8fa3	00 03 4b c0			          .BYTE $00,$03,$4b,$c0 ;     216000
>8fa7	ff ff 73 60			          .BYTE $ff,$ff,$73,$60 ;     -36000
>8fab	00 00 0e 10			          .BYTE $00,$00,$0e,$10 ;       3600
>8faf	ff ff fd a8			          .BYTE $ff,$ff,$fd,$a8 ;       -600
>8fb3	00 00 00 3c			          .BYTE $00,$00,$00,$3c ;         60
.8fb7					  FUNC_SQR
.8fb7	20 38 8c	jsr $8c38	          JSR FAC1_Round_And_Copy_To_FAC2
.8fba	a9 76		lda #$76	          LDA #<Real_0_5
.8fbc	a0 8f		ldy #$8f	          LDY #>Real_0_5
.8fbe	20 d4 8b	jsr $8bd4	POT_XY    JSR Load_FAC1_AY
.8fc1					  OP_POWER
.8fc1	f0 70		beq $9033	          BEQ FUNC_EXP        ; -> FAC1 == 0
.8fc3	a5 6a		lda $6a		          LDA FAC2_EX
.8fc5	d0 03		bne $8fca	          BNE POW_10
.8fc7	4c d8 88	jmp $88d8	          JMP CF1_10
.8fca	a2 50		ldx #$50	POW_10    LDX #<GRBPNT
.8fcc	a0 00		ldy #$00	          LDY #>GRBPNT
.8fce	20 00 8c	jsr $8c00	          JSR FAC1_To_XY
.8fd1	a5 6f		lda $6f		          LDA FAC2_SI
.8fd3	10 0f		bpl $8fe4	          BPL POW_20
.8fd5	20 fb 8c	jsr $8cfb	          JSR FUNC_INT
.8fd8	a9 50		lda #$50	          LDA #<GRBPNT
.8fda	a0 00		ldy #$00	          LDY #>GRBPNT
.8fdc	20 87 8c	jsr $8c87	          JSR Compare_AY_FAC1
.8fdf	d0 03		bne $8fe4	          BNE POW_20
.8fe1	98		tya		          TYA
.8fe2	a4 09		ldy $09		          LDY CHARAC
.8fe4	20 2a 8c	jsr $8c2a	POW_20    JSR ASI_FAC2_To_FAC1
.8fe7	98		tya		          TYA
.8fe8	48		pha		          PHA
.8fe9	20 ca 89	jsr $89ca	          JSR FUNC_LOG
.8fec	a9 50		lda #$50	          LDA #<GRBPNT
.8fee	a0 00		ldy #$00	          LDY #>GRBPNT
.8ff0	20 24 8a	jsr $8a24	          JSR AY_Mult_FAC1
.8ff3	20 33 90	jsr $9033	          JSR FUNC_EXP
.8ff6	68		pla		          PLA
.8ff7	4a		lsr a		          LSR A
.8ff8	90 0a		bcc $9004	          BCC NEG_Ret
.8ffa					  OP_NEG
.8ffa	a5 63		lda $63		          LDA FAC1_EX
.8ffc	f0 06		beq $9004	          BEQ NEG_Ret
.8ffe	a5 68		lda $68		          LDA FAC1_SI
.9000	49 ff		eor #$ff	          EOR #$ff
.9002	85 68		sta $68		          STA FAC1_SI
.9004	60		rts		NEG_Ret   RTS
.9005					  Rev_Log_2
>9005	81 38 aa 3b 29			          .BYTE $81,$38,$aa,$3b,$29 ;REAL $8138aa3b29;    1.44269504072
>900a	07				expcon    .BYTE $07
>900b	71 34 58 3e 56			          .BYTE $71,$34,$58,$3e,$56 ;REAL $7134583e56;    0.00002149876
>9010	74 16 7e b3 1b			          .BYTE $74,$16,$7e,$b3,$1b ;REAL $74167eb31b;    0.00014352314
>9015	77 2f ee e3 85			          .BYTE $77,$2f,$ee,$e3,$85 ;REAL $772feee385;    0.00134226348
>901a	7a 1d 84 1c 2a			          .BYTE $7a,$1d,$84,$1c,$2a ;REAL $7a1d841c2a;    0.00961401701
>901f	7c 63 59 58 0a			          .BYTE $7c,$63,$59,$58,$0a ;REAL $7c6359580a;    0.05550512686
>9024	7e 75 fd e7 c6			          .BYTE $7e,$75,$fd,$e7,$c6 ;REAL $7e75fde7c6;    0.24022638460
>9029	80 31 72 18 10			          .BYTE $80,$31,$72,$18,$10 ;REAL $8031721810;    0.69314718619
>902e	81 00 00 00 00			          .BYTE $81,$00,$00,$00,$00 ;REAL $8100000000;    1.00000000000
.9033					  FUNC_EXP
.9033	a9 05		lda #$05	          LDA #<Rev_Log_2
.9035	a0 90		ldy #$90	          LDY #>Rev_Log_2
.9037	20 08 8a	jsr $8a08	          JSR Multiply_AY_To_FAC1
.903a	a5 71		lda $71		          LDA FROUND
.903c	69 50		adc #$50	          ADC #$50            ; round exponential
.903e	90 03		bcc $9043	          BCC EXP_10
.9040	20 4f 8c	jsr $8c4f	          JSR Inc_FAC1
.9043	85 58		sta $58		EXP_10    STA OLDOV
.9045	20 3b 8c	jsr $8c3b	          JSR FAC1_To_FAC2
.9048	a5 63		lda $63		          LDA FAC1_EX
.904a	c9 88		cmp #$88	          CMP #$88
.904c	90 03		bcc $9051	          BCC EXP_30          ; -> value < 128
.904e	20 09 8b	jsr $8b09	EXP_20    JSR ChFA_40         ; FAC1 = 0.0 for tiny values
.9051	20 fb 8c	jsr $8cfb	EXP_30    JSR FUNC_INT        ; convert to integer
.9054	a5 09		lda $09		          LDA CHARAC
.9056	18		clc		          CLC
.9057	69 81		adc #$81	          ADC #$81
.9059	f0 f3		beq $904e	          BEQ EXP_20
.905b	38		sec		          SEC
.905c	e9 01		sbc #$01	          SBC #1
.905e	48		pha		          PHA
.905f	a2 05		ldx #$05	          LDX #5
.9061	b5 6a		lda $6a,x	EXP_40    LDA FAC2_EX,X       ; FAC1 <-> FAC2
.9063	b4 63		ldy $63,x	          LDY FAC1_EX,X
.9065	95 63		sta $63,x	          STA FAC1_EX,X
.9067	94 6a		sty $6a,x	          STY FAC2_EX,X
.9069	ca		dex		          DEX
.906a	10 f5		bpl $9061	          BPL EXP_40
.906c	a5 58		lda $58		          LDA OLDOV
.906e	85 71		sta $71		          STA FROUND
.9070	20 31 88	jsr $8831	          JSR OP_MINUS
.9073	20 fa 8f	jsr $8ffa	          JSR OP_NEG
.9076	a9 0a		lda #$0a	          LDA #<expcon
.9078	a0 90		ldy #$90	          LDY #>expcon
.907a	20 9c 90	jsr $909c	          JSR Eval_Series_AY
.907d	a9 00		lda #$00	          LDA #0
.907f	85 70		sta $70		          STA STRPTR
.9081	68		pla		          PLA
.9082	20 ee 8a	jsr $8aee	          JSR ChFA_10         ; do not JMP! (may return with PLA PLA)
.9085	60		rts		          RTS
.9086					  Series_Evaluation
.9086	85 72		sta $72		          STA STRNG2
.9088	84 73		sty $73		          STY STRNG2+1
.908a	20 fc 8b	jsr $8bfc	          JSR FAC1_To_FACTPA
.908d	a9 59		lda #$59	          LDA #FACTPA
.908f	20 24 8a	jsr $8a24	          JSR AY_Mult_FAC1
.9092	20 a0 90	jsr $90a0	          JSR Eval_Series
.9095	a9 59		lda #$59	          LDA #<FACTPA
.9097	a0 00		ldy #$00	          LDY #>FACTPA
.9099	4c 24 8a	jmp $8a24	          JMP AY_Mult_FAC1
.909c					  Eval_Series_AY
.909c	85 72		sta $72		          STA STRNG2
.909e	84 73		sty $73		          STY STRNG2+1
.90a0					  Eval_Series
.90a0	20 f9 8b	jsr $8bf9	          JSR FAC1_To_FACTPB
.90a3	b1 72		lda ($72),y	          LDA (STRNG2),Y
.90a5	85 69		sta $69		          STA DEGREE
.90a7	a4 72		ldy $72		          LDY STRNG2
.90a9	c8		iny		          INY
.90aa	98		tya		          TYA
.90ab	d0 02		bne $90af	          BNE EvSe_10
.90ad	e6 73		inc $73		          INC STRNG2+1
.90af	85 72		sta $72		EvSe_10   STA STRNG2
.90b1	a4 73		ldy $73		          LDY STRNG2+1
.90b3	20 08 8a	jsr $8a08	EvSe_20   JSR Multiply_AY_To_FAC1
.90b6	a5 72		lda $72		          LDA STRNG2
.90b8	a4 73		ldy $73		          LDY STRNG2+1
.90ba	18		clc		          CLC
.90bb	69 05		adc #$05	          ADC #5              ; advance polynomial pointer
.90bd	90 01		bcc $90c0	          BCC EvSe_30
.90bf	c8		iny		          INY
.90c0	85 72		sta $72		EvSe_30   STA STRNG2
.90c2	84 73		sty $73		          STY STRNG2+1
.90c4	20 12 8a	jsr $8a12	          JSR Add_AY_To_FAC1
.90c7	a9 5e		lda #$5e	          LDA #<FACTPB
.90c9	a0 00		ldy #$00	          LDY #>FACTPB
.90cb	c6 69		dec $69		          DEC DEGREE
.90cd	d0 e4		bne $90b3	          BNE EvSe_20
.90cf	60		rts		          RTS
.90d0					  Break_On_Error
.90d0	aa		tax		          TAX
.90d1	d0 02		bne $90d5	          BNE BOE_Err
.90d3	a2 1e		ldx #$1e	Break_Err LDX #$1e            ; BREAK
.90d5	4c 3c 4d	jmp $4d3c	BOE_Err   JMP Print_Error_X
.90d8					  B_OPEN
.90d8	20 45 a8	jsr $a845	          JSR Map_IO
.90db	20 c0 ff	jsr $ffc0	          JSR K_OPEN
.90de	60		rts		          RTS
.90df					  CHROUT
.90df	20 69 92	jsr $9269	          JSR B_BSOUT
.90e2	b0 ec		bcs $90d0	          BCS Break_On_Error
.90e4	60		rts		          RTS
.90e5					  CHRIN
.90e5	20 63 92	jsr $9263	          JSR B_BASIN
.90e8	b0 e6		bcs $90d0	          BCS Break_On_Error
.90ea	60		rts		          RTS
.90eb					  B_CKOUT
.90eb	48		pha		          PHA
.90ec	20 45 a8	jsr $a845	          JSR Map_IO
.90ef	20 c9 ff	jsr $ffc9	          JSR K_CKOUT
.90f2	20 43 92	jsr $9243	          JSR Invalidate_Disk_Status
.90f5	aa		tax		          TAX
.90f6	68		pla		          PLA
.90f7	90 03		bcc $90fc	          BCC BCOUT_Ret
.90f9	8a		txa		          TXA
.90fa	b0 d4		bcs $90d0	          BCS Break_On_Error
.90fc	60		rts		BCOUT_Ret RTS
.90fd					  B_CHKIN
.90fd	20 45 a8	jsr $a845	          JSR Map_IO
.9100	20 c6 ff	jsr $ffc6	          JSR K_CHKIN
.9103	20 43 92	jsr $9243	          JSR Invalidate_Disk_Status
.9106	b0 c8		bcs $90d0	          BCS Break_On_Error
.9108	60		rts		          RTS
.9109					  B_GETIN
.9109	20 45 a8	jsr $a845	          JSR Map_IO
.910c	20 e4 ff	jsr $ffe4	          JSR K_GETIN
.910f	b0 c2		bcs $90d3	          BCS Break_Err
.9111	60		rts		          RTS
.9112					  BASIC_SAVE
.9112	20 ae 91	jsr $91ae	          JSR Load_Save_Parameter
.9115	ae 10 12	ldx $1210	SAVE_10   LDX TEXT_TOP
.9118	ac 11 12	ldy $1211	          LDY TEXT_TOP+1
.911b	a9 2d		lda #$2d	          LDA #TXTTAB         ; address of start address
.911d	20 45 a8	jsr $a845	SAVE_20   JSR Map_IO
.9120	20 d8 ff	jsr $ffd8	          JSR K_SAVESP
.9123	20 43 92	jsr $9243	          JSR Invalidate_Disk_Status
.9126	b0 a8		bcs $90d0	          BCS Break_On_Error
.9128	60		rts		          RTS
.9129					  BASIC_VERIFY
.9129	a9 01		lda #$01	          LDA #1
>912b	2c				          .byte $2c ;BIT
.912c					  BASIC_LOAD
.912c	a9 00		lda #$00	          LDA #0              ; 0 = LOAD mode
.912e	85 0c		sta $0c		          STA B_VERCK         ; set LOAD or VERIFY flag
.9130	20 ae 91	jsr $91ae	          JSR Load_Save_Parameter
.9133					  LOAD_Parameter_Set
.9133	20 45 a8	jsr $a845	          JSR Map_IO
.9136	a5 0c		lda $0c		          LDA B_VERCK         ; LOAD (0) or VERIFY (1)
.9138	a6 2d		ldx $2d		          LDX TXTTAB
.913a	a4 2e		ldy $2e		          LDY TXTTAB+1
.913c	20 d5 ff	jsr $ffd5	          JSR K_LOADSP        ; Kernel load routine
.913f	08		php		          PHP                 ; push status
.9140	20 43 92	jsr $9243	          JSR Invalidate_Disk_Status
.9143	28		plp		          PLP                 ; pull status
.9144	b0 65		bcs $91ab	          BCS CLOSE_Err           ; -> load error
.9146	a5 0c		lda $0c		          LDA B_VERCK
.9148	f0 16		beq $9160	          BEQ LPS_10          ; -> LOAD
.914a	a2 1c		ldx #$1c	          LDX #$1c            ; VERIFY
.914c	20 51 92	jsr $9251	          JSR B_READST
.914f	29 10		and #$10	          AND #%00010000     ; and VERIFY bit
.9151	d0 16		bne $9169	          BNE LPS_20          ; -> verify error
.9153	24 7f		bit $7f		          BIT RUNMOD
.9155	30 08		bmi $915f	          BMI LPS_Ret         ; -> running
.9157	20 81 92	jsr $9281	          JSR B_PRIMM         ; stopped
>915a	0d 4f 4b 0d 00			          .TEXT "\rOK\r",0
.915f	60		rts		LPS_Ret   RTS
.9160	20 51 92	jsr $9251	LPS_10    JSR B_READST
.9163	29 bf		and #$bf	          AND #%10111111     ; test all but EOI (but 6)
.9165	f0 05		beq $916c	          BEQ LPS_30
.9167	a2 1d		ldx #$1d	LPS_Err   LDX #$1d            ; LOAD
.9169	4c 3c 4d	jmp $4d3c	LPS_20    JMP Print_Error_X
.916c	8e 10 12	stx $1210	LPS_30    STX TEXT_TOP        ; store load end address
.916f	8c 11 12	sty $1211	          STY TEXT_TOP+1
.9172	24 7f		bit $7f		          BIT RUNMOD
.9174	30 0e		bmi $9184	          BMI LPS_40          ; -> RUN [line]
.9176	70 e7		bvs $915f	          BVS LPS_Ret         ; -> RUN <filename>
.9178	20 2a 4d	jsr $4d2a	          JSR Print_Ready
.917b	20 4f 4f	jsr $4f4f	          JSR Relink
.917e	20 f3 51	jsr $51f3	          JSR Reset_BASIC_Execution
.9181	4c c3 4d	jmp $4dc3	          JMP BAER_70
.9184	20 54 52	jsr $5254	LPS_40    JSR Reset_TXTPTR
.9187	20 4f 4f	jsr $4f4f	          JSR Relink
.918a	4c 35 52	jmp $5235	          JMP ClrB_20
.918d					  BASIC_OPEN
.918d	20 f6 91	jsr $91f6	          JSR Get_Open_Close_Parameter
.9190	18		clc		          CLC
.9191	20 d8 90	jsr $90d8	          JSR B_OPEN
.9194	20 43 92	jsr $9243	          JSR Invalidate_Disk_Status
.9197	b0 12		bcs $91ab	          BCS CLOSE_Err
.9199	60		rts		          RTS
.919a					  BASIC_CLOSE
.919a	20 f6 91	jsr $91f6	          JSR Get_Open_Close_Parameter
.919d	20 45 a8	jsr $a845	          JSR Map_IO
.91a0	a5 4b		lda $4b		          LDA FORPNT
.91a2	18		clc		          CLC
.91a3	20 75 92	jsr $9275	          JSR B_CLOSE
.91a6	20 43 92	jsr $9243	          JSR Invalidate_Disk_Status
.91a9	90 b4		bcc $915f	          BCC LPS_Ret
.91ab	4c d0 90	jmp $90d0	CLOSE_Err JMP Break_On_Error
.91ae					  Load_Save_Parameter
.91ae	a9 00		lda #$00	          LDA #0
.91b0	20 5d 92	jsr $925d	          JSR B_SETNAM        ; clear filename
.91b3	a2 01		ldx #$01	          LDX #1              ; default unit = 1 tape
.91b5	a0 00		ldy #$00	          LDY #0              ; default SA = 0
.91b7	20 57 92	jsr $9257	          JSR B_SETLFS        ; LA=0, FA=1, SA=0
.91ba	20 87 92	jsr $9287	          JSR B_SETBNK        ; bank = 0
.91bd	20 e3 91	jsr $91e3	          JSR CHRGOT_Or_BREAK ; more parameter ?
.91c0	20 39 92	jsr $9239	          JSR Get_Filename    ; read and store filename
.91c3	20 e3 91	jsr $91e3	          JSR CHRGOT_Or_BREAK ; more parameter ?
.91c6	20 dd 91	jsr $91dd	          JSR Comma_Byte      ; read unit
.91c9	a0 00		ldy #$00	          LDY #0              ; Y = 0
.91cb	86 4b		stx $4b		          STX FORPNT          ; store unit
.91cd	20 57 92	jsr $9257	          JSR B_SETLFS        ; FA=X, SA=0
.91d0	20 e3 91	jsr $91e3	          JSR CHRGOT_Or_BREAK ; more parameter ?
.91d3	20 dd 91	jsr $91dd	          JSR Comma_Byte      ; read EOT parameter
.91d6	8a		txa		          TXA                 ; A = EOT
.91d7	a8		tay		          TAY                 ; Y = EOT
.91d8	a6 4b		ldx $4b		          LDX FORPNT          ; X = FA
.91da	4c 57 92	jmp $9257	          JMP B_SETLFS        ; LA=A, FA=X, SA=Y
.91dd					  Comma_Byte
.91dd	20 eb 91	jsr $91eb	          JSR Need_Comma_And_Byte
.91e0	4c f4 87	jmp $87f4	          JMP Get_Byte_Var
.91e3					  CHRGOT_Or_BREAK
.91e3	20 86 03	jsr $0386	          JSR CHRGOT
.91e6	d0 02		bne $91ea	          BNE COB_Ret
.91e8	68		pla		          PLA
.91e9	68		pla		          PLA
.91ea	60		rts		COB_Ret   RTS
.91eb					  Need_Comma_And_Byte
.91eb	20 5c 79	jsr $795c	          JSR Need_Comma
.91ee					  Need_Byte
.91ee	20 86 03	jsr $0386	          JSR CHRGOT
.91f1	d0 f7		bne $91ea	          BNE COB_Ret
.91f3	4c 6c 79	jmp $796c	          JMP SYNTAX_ERROR
.91f6					  Get_Open_Close_Parameter
.91f6	a9 00		lda #$00	          LDA #0
.91f8	a2 01		ldx #$01	          LDX #1
.91fa	20 87 92	jsr $9287	          JSR B_SETBNK        ; bank = 0
.91fd	20 5d 92	jsr $925d	          JSR B_SETNAM        ; clear filename
.9200	20 ee 91	jsr $91ee	          JSR Need_Byte       ; assert more
.9203	20 f4 87	jsr $87f4	          JSR Get_Byte_Var    ; get logical address
.9206	86 4b		stx $4b		          STX FORPNT          ; save it
.9208	8a		txa		          TXA                 ; A = LA
.9209	a2 01		ldx #$01	          LDX #1              ; X = FA = 1
.920b	a0 00		ldy #$00	          LDY #0              ; Y = SA = 0
.920d	20 57 92	jsr $9257	          JSR B_SETLFS        ; set defaults
.9210	20 e3 91	jsr $91e3	          JSR CHRGOT_Or_BREAK ; more ?
.9213	20 dd 91	jsr $91dd	          JSR Comma_Byte      ; get unit
.9216	86 4c		stx $4c		          STX FORPNT+1        ; save it
.9218	a0 00		ldy #$00	          LDY #0              ; Y = SA = 0
.921a	a5 4b		lda $4b		          LDA FORPNT          ; A = LA
.921c	e0 03		cpx #$03	          CPX #3              ; unit < 3 ?
.921e	90 01		bcc $9221	          BCC GOCP_10         ; -> OK
.9220	88		dey		          DEY                 ; SA = 255
.9221	20 57 92	jsr $9257	GOCP_10   JSR B_SETLFS        ; set parameter
.9224	20 e3 91	jsr $91e3	          JSR CHRGOT_Or_BREAK ; more ?
.9227	20 dd 91	jsr $91dd	          JSR Comma_Byte      ; get SA
.922a	8a		txa		          TXA                 ; A = SA
.922b	a8		tay		          TAY                 ; Y = SA
.922c	a6 4c		ldx $4c		          LDX FORPNT+1        ; X = FA
.922e	a5 4b		lda $4b		          LDA FORPNT          ; A = LA
.9230	20 57 92	jsr $9257	          JSR B_SETLFS        ; set parameter
.9233	20 e3 91	jsr $91e3	          JSR CHRGOT_Or_BREAK ; more ?
.9236	20 eb 91	jsr $91eb	          JSR Need_Comma_And_Byte
.9239					  Get_Filename
.9239	20 7b 87	jsr $877b	          JSR Eval_String     ; read filename
.923c	a6 24		ldx $24		          LDX INDEXA          ; fn address low
.923e	a4 25		ldy $25		          LDY INDEXA+1        ; fn address high
.9240	4c 5d 92	jmp $925d	          JMP B_SETNAM        ; declare filename
.9243					  Invalidate_Disk_Status
.9243	08		php		          PHP
.9244	48		pha		          PHA
.9245	a5 ba		lda $ba		          LDA FA
.9247	c9 04		cmp #$04	          CMP #4
.9249	90 03		bcc $924e	          BCC IDS_10
.924b	20 0d a8	jsr $a80d	          JSR Free_DOS_Status_String
.924e	68		pla		IDS_10    PLA
.924f	28		plp		          PLP
.9250	60		rts		          RTS
.9251					  B_READST
.9251	20 45 a8	jsr $a845	          JSR Map_IO          ; not needed
.9254	4c b7 ff	jmp $ffb7	          JMP K_READST
.9257					  B_SETLFS
.9257	20 45 a8	jsr $a845	          JSR Map_IO          ; not needed
.925a	4c ba ff	jmp $ffba	          JMP K_SETLFS
.925d					  B_SETNAM
.925d	20 45 a8	jsr $a845	          JSR Map_IO          ; not needed
.9260	4c bd ff	jmp $ffbd	          JMP K_SETNAM
.9263					  B_BASIN
.9263	20 45 a8	jsr $a845	          JSR Map_IO
.9266	4c cf ff	jmp $ffcf	          JMP K_BASIN
.9269					  B_BSOUT
.9269	20 45 a8	jsr $a845	          JSR Map_IO
.926c	4c d2 ff	jmp $ffd2	          JMP K_BSOUT
.926f					  B_CLRCH
.926f	20 45 a8	jsr $a845	          JSR Map_IO
.9272	4c cc ff	jmp $ffcc	          JMP K_CLRCH
.9275					  B_CLOSE
.9275	20 45 a8	jsr $a845	          JSR Map_IO
.9278	4c c3 ff	jmp $ffc3	          JMP K_CLOSE
.927b					  B_CLALL
.927b	20 45 a8	jsr $a845	          JSR Map_IO
.927e	4c e7 ff	jmp $ffe7	          JMP K_CLALL
.9281					  B_PRIMM
.9281	20 45 a8	jsr $a845	          JSR Map_IO
.9284	4c 7d ff	jmp $ff7d	          JMP K_PRIMM
.9287					  B_SETBNK
.9287	20 45 a8	jsr $a845	          JSR Map_IO
.928a	4c 68 ff	jmp $ff68	          JMP K_SETBNK
.928d					  B_PLOT
.928d	8d 03 ff	sta $ff03	          STA MMU_LCRC
.9290	4c f0 ff	jmp $fff0	          JMP K_PLOT
.9293					  B_STOP
.9293	20 45 a8	jsr $a845	          JSR Map_IO
.9296	4c e1 ff	jmp $ffe1	          JMP K_STOP
.9299					  Allocate_String_Space
.9299	46 11		lsr $11		          LSR GARBFL          ; clear bit 7 of GARBFL
.929b	aa		tax		ASS_10    TAX                 ; string length
.929c	f0 3b		beq $92d9	          BEQ ASS_50          ; 0 -> nothing to do
.929e	48		pha		          PHA                 ; save length
.929f	a5 35		lda $35		          LDA FRETOP
.92a1	38		sec		          SEC
.92a2	e9 02		sbc #$02	          SBC #2              ; subtract 2 for back reference
.92a4	a4 36		ldy $36		          LDY FRETOP+1
.92a6	b0 01		bcs $92a9	          BCS ASS_20
.92a8	88		dey		          DEY
.92a9	85 24		sta $24		ASS_20    STA INDEXA          ; INDEXA = FRETOP - 2
.92ab	84 25		sty $25		          STY INDEXA+1
.92ad	8a		txa		          TXA
.92ae	49 ff		eor #$ff	          EOR #%11111111     ; negate
.92b0	38		sec		          SEC
.92b1	65 24		adc $24		          ADC INDEXA          ; subtract length
.92b3	b0 01		bcs $92b6	          BCS ASS_30
.92b5	88		dey		          DEY
.92b6	c4 34		cpy $34		ASS_30    CPY STREND+1        ; A/Y = FRETOP - length - 2
.92b8	90 20		bcc $92da	          BCC ASS_60          ; A/Y < STREND -> garbage collection
.92ba	d0 04		bne $92c0	          BNE ASS_40
.92bc	c5 33		cmp $33		          CMP STREND
.92be	90 1a		bcc $92da	          BCC ASS_60          ; A/Y < STREND -> garbage collection
.92c0	85 37		sta $37		ASS_40    STA FRESPC
.92c2	84 38		sty $38		          STY FRESPC+1        ; FRESPC = FRETOP - length - 2
.92c4	a0 01		ldy #$01	          LDY #1
.92c6	a9 ff		lda #$ff	          LDA #$ff
.92c8	8d 04 ff	sta $ff04	          STA MMU_LCRD
.92cb	91 24		sta ($24),y	          STA (INDEXA),Y      ; mark as unassigned
.92cd	88		dey		          DEY                 ; Y = 0
.92ce	68		pla		          PLA                 ; length
.92cf	91 24		sta ($24),y	          STA (INDEXA),Y      ; store length
.92d1	a6 37		ldx $37		          LDX FRESPC
.92d3	a4 38		ldy $38		          LDY FRESPC+1
.92d5	86 35		stx $35		          STX FRETOP
.92d7	84 36		sty $36		          STY FRETOP+1        ; FRETOP = FRESPC
.92d9	60		rts		ASS_50    RTS
.92da	a5 11		lda $11		ASS_60    LDA GARBFL
.92dc	30 09		bmi $92e7	          BMI ASS_Err         ; 2nd. attempt -> OOM
.92de	20 ea 92	jsr $92ea	          JSR Garbage_Collection
.92e1	38		sec		          SEC
.92e2	66 11		ror $11		          ROR GARBFL          ; set flag: collection was done
.92e4	68		pla		          PLA                 ; pull length
.92e5	d0 b4		bne $929b	          BNE ASS_10          ; branch always
.92e7	4c 3a 4d	jmp $4d3a	ASS_Err   JMP OOM_Error
.92ea					  Garbage_Collection
.92ea	a6 18		ldx $18		          LDX TEMPPT          ; descriptor stack pointer
.92ec	e0 1b		cpx #$1b	GaCo_10   CPX #TEMPST         ; start of stack ?
.92ee	f0 13		beq $9303	          BEQ GaCo_15         ; -> empty stack
.92f0	20 f0 93	jsr $93f0	          JSR Trailer_Address
.92f3	f0 f7		beq $92ec	          BEQ GaCo_10         ; zero length -> loop
.92f5	8a		txa		          TXA                 ; A = stack pointer
.92f6	a0 00		ldy #$00	          LDY #0
.92f8	8d 04 ff	sta $ff04	          STA MMU_LCRD
.92fb	91 5e		sta ($5e),y	          STA (FACTPB),Y      ; back reference low
.92fd	98		tya		          TYA
.92fe	c8		iny		          INY                 ; Y = 1
.92ff	91 5e		sta ($5e),y	          STA (FACTPB),Y      ; back reference high
.9301	d0 e9		bne $92ec	          BNE GaCo_10         ; always
.9303	a0 00		ldy #$00	GaCo_15   LDY #0
.9305	84 5a		sty $5a		          STY ARYPNT          ; ARYPNT = 0
.9307	a6 39		ldx $39		          LDX MEMSIZ
.9309	a4 3a		ldy $3a		          LDY MEMSIZ+1
.930b	86 61		stx $61		          STX LOWTR           ; LOWTR  = MEMSIZ
.930d	86 50		stx $50		          STX GRBPNT          ; GRBPNT = MEMSIZ
.930f	86 37		stx $37		          STX FRESPC          ; FRESPC = MEMSIZ
.9311	84 62		sty $62		          STY LOWTR+1
.9313	84 51		sty $51		          STY GRBPNT+1
.9315	84 38		sty $38		          STY FRESPC+1
.9317	8a		txa		          TXA
.9318	20 83 93	jsr $9383	GaCo_20   JSR Invalid_String  ; breaks out after reaching FRETOP
.931b	d0 0c		bne $9329	          BNE GaCo_30         ; -> string is valid
.931d	88		dey		GaCo_25   DEY
.931e	20 fb 42	jsr $42fb	          JSR GRBPNT_from_Bank_1_Copy ; A = length
.9321	20 d2 93	jsr $93d2	          JSR GRBPNT_Minus_A          ; GRBPNT -= length
.9324	38		sec		          SEC
.9325	66 5a		ror $5a		          ROR ARYPNT          ; set flag
.9327	d0 ef		bne $9318	          BNE GaCo_20         ; always
.9329	24 5a		bit $5a		GaCo_30   BIT ARYPNT
.932b	10 42		bpl $936f	          BPL GaCo_50         ; -> no gap so far
.932d	a2 00		ldx #$00	          LDX #0
.932f	86 5a		stx $5a		          STX ARYPNT          ; reset flag
.9331	a9 02		lda #$02	          LDA #2              ; obsolete
.9333	a0 01		ldy #$01	GaCo_35   LDY #1
.9335	20 fb 42	jsr $42fb	          JSR GRBPNT_from_Bank_1_Copy
.9338	91 61		sta ($61),y	          STA (LOWTR),Y
.933a	88		dey		          DEY                 ; Y = 0
.933b	20 fb 42	jsr $42fb	          JSR GRBPNT_from_Bank_1_Copy
.933e	91 61		sta ($61),y	          STA (LOWTR),Y       ; LOWTR = string address
.9340	20 b7 03	jsr $03b7	          JSR Get_INDEXA_1    ; A = length
.9343	aa		tax		          TAX                 ; X = length
.9344	20 e1 93	jsr $93e1	          JSR LOWTR_Minus_A
.9347	85 37		sta $37		          STA FRESPC
.9349	84 38		sty $38		          STY FRESPC+1        ; update FRESPC
.934b	8a		txa		          TXA                 ; A = length
.934c	20 d2 93	jsr $93d2	          JSR GRBPNT_Minus_A  ; GRBPNT -= length
.934f	8a		txa		          TXA
.9350	a8		tay		          TAY
.9351	88		dey		GaCo_40   DEY
.9352	20 fb 42	jsr $42fb	          JSR GRBPNT_from_Bank_1_Copy
.9355	91 61		sta ($61),y	          STA (LOWTR),Y
.9357	ca		dex		          DEX                 ; decrement string length
.9358	d0 f7		bne $9351	          BNE GaCo_40
.935a	a0 02		ldy #$02	          LDY #2
.935c	b9 60 00	lda $0060,y	GaCo_45   LDA TENEXP,Y
.935f	91 24		sta ($24),y	          STA (INDEXA),Y
.9361	88		dey		          DEY
.9362	d0 f8		bne $935c	          BNE GaCo_45
.9364	a5 50		lda $50		          LDA GRBPNT
.9366	a4 51		ldy $51		          LDY GRBPNT+1
.9368	20 83 93	jsr $9383	          JSR Invalid_String
.936b	f0 b0		beq $931d	          BEQ GaCo_25
.936d	d0 c4		bne $9333	          BNE GaCo_35
.936f	a0 00		ldy #$00	GaCo_50   LDY #0
.9371	20 b7 03	jsr $03b7	          JSR Get_INDEXA_1
.9374	aa		tax		          TAX
.9375	20 e1 93	jsr $93e1	          JSR LOWTR_Minus_A
.9378	85 37		sta $37		          STA FRESPC
.937a	84 38		sty $38		          STY FRESPC+1        ; FRESPC = last found valid string
.937c	8a		txa		          TXA
.937d	20 d2 93	jsr $93d2	          JSR GRBPNT_Minus_A
.9380	4c 18 93	jmp $9318	          JMP GaCo_20
.9383					  Invalid_String
.9383	c4 36		cpy $36		          CPY FRETOP+1
.9385	90 2a		bcc $93b1	          BCC InvS_40         ; -> not in string RAM
.9387	d0 06		bne $938f	          BNE InvS_10
.9389	c5 35		cmp $35		          CMP FRETOP
.938b	f0 24		beq $93b1	          BEQ InvS_40         ; -> not in string RAM
.938d	90 22		bcc $93b1	          BCC InvS_40         ; -> not in string RAM
.938f	24 5a		bit $5a		InvS_10   BIT ARYPNT
.9391	30 05		bmi $9398	          BMI InvS_20
.9393	a9 02		lda #$02	          LDA #2
.9395	20 e1 93	jsr $93e1	          JSR LOWTR_Minus_A
.9398	a9 02		lda #$02	InvS_20   LDA #2
.939a	20 d2 93	jsr $93d2	          JSR GRBPNT_Minus_A
.939d	a0 01		ldy #$01	          LDY #1
.939f	20 fb 42	jsr $42fb	          JSR GRBPNT_from_Bank_1_Copy
.93a2	c9 ff		cmp #$ff	          CMP #$ff
.93a4	d0 01		bne $93a7	          BNE InvS_30
.93a6	60		rts		          RTS                 ; return with Z=1
.93a7	20 fb 42	jsr $42fb	InvS_30   JSR GRBPNT_from_Bank_1_Copy
.93aa	99 24 00	sta $0024,y	          STA INDEXA,Y
.93ad	88		dey		          DEY
.93ae	10 f7		bpl $93a7	          BPL InvS_30
.93b0	60		rts		          RTS                 ; return with Z=0
.93b1	a6 18		ldx $18		InvS_40   LDX TEMPPT
.93b3	e0 1b		cpx #$1b	InvS_50   CPX #TEMPST
.93b5	f0 10		beq $93c7	          BEQ InvS_60
.93b7	20 f0 93	jsr $93f0	          JSR Trailer_Address
.93ba	f0 f7		beq $93b3	          BEQ InvS_50
.93bc	a0 00		ldy #$00	          LDY #0
.93be	91 5e		sta ($5e),y	          STA (FACTPB),Y      ; store length
.93c0	c8		iny		          INY                 ; Y = 1
.93c1	a9 ff		lda #$ff	          LDA #$ff
.93c3	91 5e		sta ($5e),y	          STA (FACTPB),Y      ; mark as invalid
.93c5	d0 ec		bne $93b3	          BNE InvS_50         ; always
.93c7	68		pla		InvS_60   PLA
.93c8	68		pla		          PLA                 ; remove return address
.93c9	a5 37		lda $37		          LDA FRESPC
.93cb	a4 38		ldy $38		          LDY FRESPC+1
.93cd	85 35		sta $35		          STA FRETOP          ; FRETOP = FRESPC
.93cf	84 36		sty $36		          STY FRETOP+1
.93d1	60		rts		          RTS
.93d2					  GRBPNT_Minus_A
.93d2	49 ff		eor #$ff	          EOR #$ff            ; negate
.93d4	38		sec		          SEC
.93d5	65 50		adc $50		          ADC GRBPNT
.93d7	a4 51		ldy $51		          LDY GRBPNT+1
.93d9	b0 01		bcs $93dc	          BCS GMA_10
.93db	88		dey		          DEY
.93dc	85 50		sta $50		GMA_10    STA GRBPNT
.93de	84 51		sty $51		          STY GRBPNT+1
.93e0	60		rts		          RTS
.93e1					  LOWTR_Minus_A
.93e1	49 ff		eor #$ff	          EOR #$ff            ; negate
.93e3	38		sec		          SEC
.93e4	65 61		adc $61		          ADC LOWTR
.93e6	a4 62		ldy $62		          LDY LOWTR+1
.93e8	b0 01		bcs $93eb	          BCS LMA_10
.93ea	88		dey		          DEY
.93eb	85 61		sta $61		LMA_10    STA LOWTR
.93ed	84 62		sty $62		          STY LOWTR+1
.93ef	60		rts		          RTS
.93f0					  Trailer_Address
.93f0	ca		dex		          DEX
.93f1	b5 00		lda $00,x	          LDA 0,X             ; string address high
.93f3	85 5f		sta $5f		          STA FACTPB+1
.93f5	ca		dex		          DEX
.93f6	b5 00		lda $00,x	          LDA 0,X             ; string address low
.93f8	85 5e		sta $5e		          STA FACTPB
.93fa	ca		dex		          DEX
.93fb	b5 00		lda $00,x	          LDA 0,X             ; string length
.93fd	48		pha		          PHA                 ; push length
.93fe	18		clc		          CLC
.93ff	65 5e		adc $5e		          ADC FACTPB
.9401	85 5e		sta $5e		          STA FACTPB
.9403	90 02		bcc $9407	          BCC TrAd_10
.9405	e6 5f		inc $5f		          INC FACTPB+1        ; FACTPB = string address + length
.9407	68		pla		TrAd_10   PLA                 ; pull length (set flags)
.9408	60		rts		          RTS
.9409					  FUNC_COS
.9409	a9 85		lda #$85	          LDA #<PI_Half
.940b	a0 94		ldy #$94	          LDY #>PI_Half
.940d	20 12 8a	jsr $8a12	          JSR Add_AY_To_FAC1
.9410					  FUNC_SIN
.9410	20 38 8c	jsr $8c38	          JSR FAC1_Round_And_Copy_To_FAC2
.9413	a9 8a		lda #$8a	          LDA #<Two_PI
.9415	a0 94		ldy #$94	          LDY #>Two_PI
.9417	a6 6f		ldx $6f		          LDX FAC2_SI
.9419	20 41 8b	jsr $8b41	          JSR Divide_FAC2_By_AY ; arg / (2 Pi)
.941c	20 38 8c	jsr $8c38	          JSR FAC1_Round_And_Copy_To_FAC2
.941f	20 fb 8c	jsr $8cfb	          JSR FUNC_INT
.9422	a9 00		lda #$00	          LDA #0
.9424	85 70		sta $70		          STA STRPTR
.9426	20 31 88	jsr $8831	          JSR OP_MINUS
.9429	a9 8f		lda #$8f	          LDA #<Real_0_25
.942b	a0 94		ldy #$94	          LDY #>Real_0_25
.942d	20 18 8a	jsr $8a18	          JSR FAC1_Minus_AY
.9430	a5 68		lda $68		          LDA FAC1_SI
.9432	48		pha		          PHA
.9433	10 0d		bpl $9442	          BPL SIN_10
.9435	20 0e 8a	jsr $8a0e	          JSR Add_0_5_To_FAC1
.9438	a5 68		lda $68		          LDA FAC1_SI
.943a	30 09		bmi $9445	          BMI SIN_20
.943c	a5 14		lda $14		          LDA TANSGN
.943e	49 ff		eor #$ff	          EOR #$ff
.9440	85 14		sta $14		          STA TANSGN
.9442	20 fa 8f	jsr $8ffa	SIN_10    JSR OP_NEG
.9445	a9 8f		lda #$8f	SIN_20    LDA #<Real_0_25
.9447	a0 94		ldy #$94	          LDY #>Real_0_25
.9449	20 12 8a	jsr $8a12	          JSR Add_AY_To_FAC1
.944c	68		pla		          PLA
.944d	10 03		bpl $9452	          BPL SIN_30
.944f	20 fa 8f	jsr $8ffa	          JSR OP_NEG
.9452	a9 94		lda #$94	SIN_30    LDA #<VAR_SIN
.9454	a0 94		ldy #$94	          LDY #>VAR_SIN
.9456	4c 86 90	jmp $9086	          JMP Series_Evaluation
.9459					  FUNC_TAN
.9459	20 fc 8b	jsr $8bfc	          JSR FAC1_To_FACTPA
.945c	a9 00		lda #$00	          LDA #0
.945e	85 14		sta $14		          STA TANSGN
.9460	20 10 94	jsr $9410	          JSR FUNC_SIN
.9463	a2 50		ldx #$50	          LDX #<GRBPNT
.9465	a0 00		ldy #$00	          LDY #>GRBPNT
.9467	20 00 8c	jsr $8c00	          JSR FAC1_To_XY
.946a	a9 59		lda #$59	          LDA #<FACTPA
.946c	a0 00		ldy #$00	          LDY #>FACTPA
.946e	20 d4 8b	jsr $8bd4	          JSR Load_FAC1_AY
.9471	a9 00		lda #$00	          LDA #0
.9473	85 68		sta $68		          STA FAC1_SI
.9475	a5 14		lda $14		          LDA TANSGN
.9477	20 81 94	jsr $9481	          JSR TAN_10
.947a	a9 50		lda #$50	          LDA #<GRBPNT
.947c	a0 00		ldy #$00	          LDY #>GRBPNT
.947e	4c 49 8b	jmp $8b49	          JMP AY_Divided_By_FAC1
.9481					  TAN_10
.9481	48		pha		          PHA
.9482	4c 42 94	jmp $9442	          JMP SIN_10
>9485	81 49 0f da a2			PI_Half   .BYTE $81,$49,$0f,$da,$a2 ;.REAL $81490fdaa2;    1.57079632673
>948a	83 49 0f da a2			Two_PI    .BYTE $83,$49,$0f,$da,$a2 ;.REAL $83490fdaa2;    6.28318530694
>948f	7f 00 00 00 00			Real_0_25 .BYTE $7f,$00,$00,$00,$00 ;.REAL $7f00000000;    0.25000000000
>9494	05				VAR_SIN   .BYTE $05
>9495	84 e6 1a 2d 1b			          .BYTE $84,$e6,$1a,$2d,$1b ;.REAL $84e61a2d1b;  -14.38139067218
>949a	86 28 07 fb f8			          .BYTE $86,$28,$07,$fb,$f8 ;.REAL $862807fbf8;   42.00779712200
>949f	87 99 68 89 01			          .BYTE $87,$99,$68,$89,$01 ;.REAL $8799688901;  -76.70417025685
>94a4	87 23 35 df e1			          .BYTE $87,$23,$35,$df,$e1 ;.REAL $872335dfe1;   81.60522368550
>94a9	86 a5 5d e7 28			          .BYTE $86,$a5,$5d,$e7,$28 ;.REAL $86a55de728;  -41.34170210361
>94ae	83 49 0f da a2			          .BYTE $83,$49,$0f,$da,$a2 ;.REAL $83490fdaa2;    6.28318530694
.94b3					  FUNC_ATN
.94b3	a5 68		lda $68		          LDA FAC1_SI
.94b5	48		pha		          PHA
.94b6	10 03		bpl $94bb	          BPL ATN_10
.94b8	20 fa 8f	jsr $8ffa	          JSR OP_NEG
.94bb	a5 63		lda $63		ATN_10    LDA FAC1_EX
.94bd	48		pha		          PHA
.94be	c9 81		cmp #$81	          CMP #$81
.94c0	90 07		bcc $94c9	          BCC ATN_20
.94c2	a9 9c		lda #$9c	          LDA #<Real_1
.94c4	a0 89		ldy #$89	          LDY #>Real_1
.94c6	20 1e 8a	jsr $8a1e	          JSR AY_Div_FAC1
.94c9	a9 e3		lda #$e3	ATN_20    LDA #<VAR_ATN
.94cb	a0 94		ldy #$94	          LDY #>VAR_ATN
.94cd	20 86 90	jsr $9086	          JSR Series_Evaluation
.94d0	68		pla		          PLA
.94d1	c9 81		cmp #$81	          CMP #$81
.94d3	90 07		bcc $94dc	          BCC ATN_30
.94d5	a9 85		lda #$85	          LDA #<PI_Half
.94d7	a0 94		ldy #$94	          LDY #>PI_Half
.94d9	20 18 8a	jsr $8a18	          JSR FAC1_Minus_AY
.94dc	68		pla		ATN_30    PLA
.94dd	10 03		bpl $94e2	          BPL ATN_Ret
.94df	4c fa 8f	jmp $8ffa	          JMP OP_NEG
.94e2	60		rts		ATN_Ret   RTS
.94e3					  VAR_ATN
>94e3	0b				          .BYTE $0b
>94e4	76 b3 83 bd d3			          .BYTE $76,$b3,$83,$bd,$d3 ;.REAL $76b383bdd3;   -0.00068479391
>94e9	79 1e f4 a6 f5			          .BYTE $79,$1e,$f4,$a6,$f5 ;.REAL $791ef4a6f5;    0.00485094216
>94ee	7b 83 fc b0 10			          .BYTE $7b,$83,$fc,$b0,$10 ;.REAL $7b83fcb010;   -0.01611170184
>94f3	7c 0c 1f 67 ca			          .BYTE $7c,$0c,$1f,$67,$ca ;.REAL $7c0c1f67ca;    0.03420963805
>94f8	7c de 53 cb c1			          .BYTE $7c,$de,$53,$cb,$c1 ;.REAL $7cde53cbc1;   -0.05427913276
>94fd	7d 14 64 70 4c			          .BYTE $7d,$14,$64,$70,$4c ;.REAL $7d1464704c;    0.07245719654
>9502	7d b7 ea 51 7a			          .BYTE $7d,$b7,$ea,$51,$7a ;.REAL $7db7ea517a;   -0.08980239538
>9507	7d 63 30 88 7e			          .BYTE $7d,$63,$30,$88,$7e ;.REAL $7d6330887e;    0.11093241343
>950c	7e 92 44 99 3a			          .BYTE $7e,$92,$44,$99,$3a ;.REAL $7e9244993a;   -0.14283980767
>9511	7e 4c cc 91 c7			          .BYTE $7e,$4c,$cc,$91,$c7 ;.REAL $7e4ccc91c7;    0.19999912049
>9516	7f aa aa aa 13			          .BYTE $7f,$aa,$aa,$aa,$13 ;.REAL $7faaaaaa13;   -0.33333331568
>951b	81 00 00 00 00			          .BYTE $81,$00,$00,$00,$00 ;.REAL $8100000000;    1.00000000000
.9520					  PRINT_USING
.9520	a2 ff		ldx #$ff	          LDX #$ff
.9522	8e 36 01	stx $0136	          STX ENDFD
.9525	20 80 03	jsr $0380	          JSR CHRGET
.9528	20 ef 77	jsr $77ef	          JSR Eval_Expression
.952b	20 dd 77	jsr $77dd	          JSR Need_String     ; get using string
.952e	a5 66		lda $66		          LDA FAC1_M3
.9530	48		pha		          PHA
.9531	a5 67		lda $67		          LDA FAC1_M4
.9533	48		pha		          PHA                 ; push using string address
.9534	a0 02		ldy #$02	          LDY #2
.9536	20 e7 42	jsr $42e7	PRUS_10   JSR Get_FAC1_M3_1
.9539	88		dey		          DEY
.953a	99 3f 00	sta $003f,y	          STA FNDPNT,Y        ; FNDPNT = using descriptor
.953d	d0 f7		bne $9536	          BNE PRUS_10
.953f	20 e7 42	jsr $42e7	          JSR Get_FAC1_M3_1
.9542	8d 35 01	sta $0135	          STA LFOR            ; length of using string
.9545	a8		tay		          TAY
.9546	f0 0b		beq $9553	          BEQ PRUS_20         ; -> error:  empty using string
.9548	88		dey		PRUS_15   DEY
.9549	20 d3 42	jsr $42d3	          JSR FNDPNT_from_Bank_1
.954c	c9 23		cmp #$23	          CMP #'#'            ; digit
.954e	f0 06		beq $9556	          BEQ PRUS_25
.9550	98		tya		          TYA
.9551	d0 f5		bne $9548	          BNE PRUS_15
.9553	4c 6c 79	jmp $796c	PRUS_20   JMP SYNTAX_ERROR
.9556	a9 3b		lda #$3b	PRUS_25   LDA #';'
.9558	20 5e 79	jsr $795e	PRUS_30   JSR Need_A
.955b	84 77		sty $77		          STY TEMP_A
.955d	8c 23 01	sty $0123	          STY BNR
.9560	20 ef 77	jsr $77ef	          JSR Eval_Expression
.9563	24 0f		bit $0f		          BIT VALTYP
.9565	10 39		bpl $95a0	          BPL PRUS_65
.9567	20 9f 97	jsr $979f	          JSR Init_Using
.956a	20 f2 98	jsr $98f2	          JSR Analyse_Using
.956d	ae 2b 01	ldx $012b	          LDX CHSN
.9570	f0 15		beq $9587	          BEQ PRUS_40
.9572	a2 00		ldx #$00	          LDX #0
.9574	38		sec		          SEC
.9575	ad 31 01	lda $0131	          LDA CFORM
.9578	e5 78		sbc $78		          SBC KEYSIZ
.957a	90 0b		bcc $9587	          BCC PRUS_40
.957c	a2 3d		ldx #$3d	          LDX #'='
.957e	ec 2b 01	cpx $012b	          CPX CHSN
.9581	d0 03		bne $9586	          BNE PRUS_35
.9583	4a		lsr a		          LSR A
.9584	69 00		adc #$00	          ADC #0
.9586	aa		tax		PRUS_35   TAX
.9587	a0 00		ldy #$00	PRUS_40   LDY #0
.9589	8a		txa		PRUS_45   TXA
.958a	f0 05		beq $9591	          BEQ PRUS_55
.958c	ca		dex		          DEX
.958d	a9 20		lda #$20	PRUS_50   LDA #' '
.958f	d0 08		bne $9599	          BNE PRUS_60         ; always
.9591	c4 78		cpy $78		PRUS_55   CPY KEYSIZ
.9593	b0 f8		bcs $958d	          BCS PRUS_50
.9595	20 b7 03	jsr $03b7	          JSR Get_INDEXA_1
.9598	c8		iny		          INY
.9599	20 eb 98	jsr $98eb	PRUS_60   JSR Chrout_Using
.959c	d0 eb		bne $9589	          BNE PRUS_45
.959e	f0 27		beq $95c7	          BEQ PRUS_85
.95a0	20 42 8e	jsr $8e42	PRUS_65   JSR Format_FAC1
.95a3	a0 ff		ldy #$ff	          LDY #$ff
.95a5	c8		iny		PRUS_70   INY
.95a6	b9 00 01	lda $0100,y	          LDA STACK,Y
.95a9	d0 fa		bne $95a5	          BNE PRUS_70
.95ab	98		tya		          TYA
.95ac	20 90 86	jsr $8690	          JSR Allocate_String_A
.95af	a0 00		ldy #$00	          LDY #0
.95b1	8d 04 ff	sta $ff04	          STA MMU_LCRD
.95b4	b9 00 01	lda $0100,y	PRUS_75   LDA STACK,Y
.95b7	f0 05		beq $95be	          BEQ PRUS_80
.95b9	91 64		sta ($64),y	          STA (FAC1_M1),Y
.95bb	c8		iny		          INY
.95bc	d0 f6		bne $95b4	          BNE PRUS_75
.95be	20 e3 86	jsr $86e3	PRUS_80   JSR Push_String_Descriptor
.95c1	20 9f 97	jsr $979f	          JSR Init_Using
.95c4	20 e7 95	jsr $95e7	          JSR Print_Formatted
.95c7	20 86 03	jsr $0386	PRUS_85   JSR CHRGOT
.95ca	c9 2c		cmp #$2c	          CMP #','
.95cc	f0 8a		beq $9558	          BEQ PRUS_30
.95ce	38		sec		          SEC
.95cf	66 77		ror $77		          ROR TEMP_A
.95d1	20 f2 98	jsr $98f2	          JSR Analyse_Using
.95d4	68		pla		          PLA
.95d5	a8		tay		          TAY
.95d6	68		pla		          PLA
.95d7	20 85 87	jsr $8785	          JSR Free_String_AY
.95da	20 86 03	jsr $0386	          JSR CHRGOT
.95dd	c9 3b		cmp #$3b	          CMP #';'
.95df	f0 03		beq $95e4	          BEQ PRUS_90
.95e1	4c 98 55	jmp $5598	          JMP Print_CR
.95e4	4c 80 03	jmp $0380	PRUS_90   JMP CHRGET
.95e7					  Print_Formatted
.95e7	8d 03 ff	sta $ff03	          STA MMU_LCRC        ; bank = 14
.95ea	ad 04 12	lda $1204	          LDA PU_FILL
.95ed	8d 33 01	sta $0133	          STA BLFD
.95f0	a9 ff		lda #$ff	          LDA #$ff
.95f2	8d 32 01	sta $0132	PrFo_10   STA SNO             ; handle negative sign
.95f5	4c fa 95	jmp $95fa	          JMP PrFo_20
.95f8	86 80		stx $80		PrFo_15   STX DOSFLA          ; clear bit 7: decimal point present
.95fa	c4 78		cpy $78		PrFo_20   CPY KEYSIZ
.95fc	f0 33		beq $9631	          BEQ PrFo_35
.95fe	b9 00 01	lda $0100,y	          LDA STACK,Y         ; load next character
.9601	c8		iny		          INY                 ; increment index
.9602	c9 20		cmp #$20	          CMP #' '            ; blank ?
.9604	f0 f4		beq $95fa	          BEQ PrFo_20         ; -> skip
.9606	c9 2d		cmp #$2d	          CMP #'-'            ; minus sign ?
.9608	f0 e8		beq $95f2	          BEQ PrFo_10         ; -> store it in SNO
.960a	c9 2e		cmp #$2e	          CMP #'.'            ; decimal point ?
.960c	f0 ea		beq $95f8	          BEQ PrFo_15         ; store X in DOSFLA
.960e	c9 45		cmp #$45	          CMP #'E'            ; exponent ?
.9610	f0 11		beq $9623	          BEQ PrFo_25         ; -> look for exponent sign
.9612	9d 00 01	sta $0100,x	          STA STACK,X         ; copy to result
.9615	8e 24 01	stx $0124	          STX ENR             ; save X index
.9618	e8		inx		          INX                 ; increment write position
.9619	24 80		bit $80		          BIT DOSFLA
.961b	10 dd		bpl $95fa	          BPL PrFo_20         ; ->loop
.961d	ee 2a 01	inc $012a	          INC VN
.9620	4c fa 95	jmp $95fa	          JMP PrFo_20
.9623	b9 00 01	lda $0100,y	PrFo_25   LDA STACK,Y         ; load char after 'E'
.9626	c9 2d		cmp #$2d	          CMP #'-'            ; negative exponent ?
.9628	d0 03		bne $962d	          BNE PrFo_30         ; -> no
.962a	6e 28 01	ror $0128	          ROR USGN            ; set bit 7 in flag USGN
.962d	c8		iny		PrFo_30   INY                 ; position after exponent sign
.962e	8c 29 01	sty $0129	          STY UEXP            ; store index to exponent value
.9631	a5 80		lda $80		PrFo_35   LDA DOSFLA          ; decimal point there ?
.9633	10 02		bpl $9637	          BPL PrFo_40         ; -> yes
.9635	86 80		stx $80		          STX DOSFLA          ; add decimal point to end of number
.9637	20 f2 98	jsr $98f2	PrFo_40   JSR Analyse_Using
.963a	ad 2c 01	lda $012c	          LDA VF
.963d	c9 ff		cmp #$ff	          CMP #$ff
.963f	f0 29		beq $966a	          BEQ PrFo_50
.9641	ad 2f 01	lda $012f	          LDA FESP
.9644	f0 3f		beq $9685	          BEQ PrFo_70
.9646	ad 29 01	lda $0129	          LDA UEXP
.9649	d0 12		bne $965d	          BNE PrFo_45
.964b	ae 24 01	ldx $0124	          LDX ENR
.964e	20 74 97	jsr $9774	          JSR Print_Using_Exp
.9651	de 02 01	dec $0102,x	          DEC STACK+2,X
.9654	e8		inx		          INX
.9655	8e 29 01	stx $0129	          STX UEXP
.9658	20 fb 97	jsr $97fb	          JSR Check_Zeroes
.965b	f0 25		beq $9682	          BEQ PrFo_65
.965d	ac 2e 01	ldy $012e	PrFo_45   LDY POSP
.9660	d0 17		bne $9679	          BNE PrFo_60
.9662	ac 32 01	ldy $0132	          LDY SNO
.9665	30 12		bmi $9679	          BMI PrFo_60
.9667	ad 2c 01	lda $012c	          LDA VF
.966a	f0 6a		beq $96d6	PrFo_50   BEQ PrFo_82
.966c	ce 2c 01	dec $012c	          DEC VF
.966f	d0 05		bne $9676	          BNE PrFo_55
.9671	ad 2d 01	lda $012d	          LDA NF
.9674	f0 60		beq $96d6	          BEQ PrFo_82
.9676	ee 27 01	inc $0127	PrFo_55   INC SWE
.9679	20 ee 96	jsr $96ee	PrFo_60   JSR Shift_Point
.967c	20 b9 97	jsr $97b9	          JSR Using_Round
.967f	20 ee 96	jsr $96ee	          JSR Shift_Point
.9682	4c 1c 98	jmp $981c	PrFo_65   JMP Output_Formatted
.9685	ac 29 01	ldy $0129	PrFo_70   LDY UEXP
.9688	f0 16		beq $96a0	          BEQ PrFo_74
.968a	85 78		sta $78		          STA KEYSIZ
.968c	38		sec		          SEC
.968d	6e 30 01	ror $0130	          ROR ETOF
.9690	a4 80		ldy $80		          LDY DOSFLA
.9692	ad 28 01	lda $0128	          LDA USGN
.9695	10 06		bpl $969d	          BPL PrFo_72
.9697	20 27 97	jsr $9727	          JSR ShPo_45
.969a	4c a9 96	jmp $96a9	          JMP PrFo_76
.969d	20 08 97	jsr $9708	PrFo_72   JSR ShPo_20
.96a0	a4 80		ldy $80		PrFo_74   LDY DOSFLA
.96a2	f0 05		beq $96a9	          BEQ PrFo_76
.96a4	20 ff 97	jsr $97ff	          JSR Leading_Zero
.96a7	f0 06		beq $96af	          BEQ PrFo_78
.96a9	20 b9 97	jsr $97b9	PrFo_76   JSR Using_Round
.96ac	4c b2 96	jmp $96b2	          JMP PrFo_80
.96af	ce 2a 01	dec $012a	PrFo_78   DEC VN
.96b2	38		sec		PrFo_80   SEC
.96b3	ad 2c 01	lda $012c	          LDA VF
.96b6	ed 2a 01	sbc $012a	          SBC VN
.96b9	90 1b		bcc $96d6	          BCC PrFo_82
.96bb	8d 27 01	sta $0127	          STA SWE
.96be	ac 2e 01	ldy $012e	          LDY POSP
.96c1	d0 1b		bne $96de	          BNE PrFo_86
.96c3	ac 32 01	ldy $0132	          LDY SNO
.96c6	30 16		bmi $96de	          BMI PrFo_86
.96c8	a8		tay		          TAY
.96c9	f0 0b		beq $96d6	          BEQ PrFo_82
.96cb	88		dey		          DEY
.96cc	d0 13		bne $96e1	          BNE PrFo_88
.96ce	ad 2d 01	lda $012d	          LDA NF
.96d1	0d 2a 01	ora $012a	          ORA VN
.96d4	d0 ac		bne $9682	          BNE PrFo_65
.96d6	a9 2a		lda #$2a	PrFo_82   LDA #'*'
.96d8	20 eb 98	jsr $98eb	PrFo_84   JSR Chrout_Using
.96db	d0 fb		bne $96d8	          BNE PrFo_84
.96dd	60		rts		          RTS
.96de	a8		tay		PrFo_86   TAY
.96df	f0 a1		beq $9682	          BEQ PrFo_65
.96e1	ad 2a 01	lda $012a	PrFo_88   LDA VN
.96e4	d0 9c		bne $9682	          BNE PrFo_65
.96e6	ce 27 01	dec $0127	          DEC SWE
.96e9	e6 77		inc $77		          INC TEMP_A
.96eb	4c 82 96	jmp $9682	          JMP PrFo_65
.96ee					  Shift_Point
.96ee	38		sec		          SEC
.96ef	ad 2c 01	lda $012c	          LDA VF              ; chars before point
.96f2	ed 2a 01	sbc $012a	          SBC VN              ; minus digits before point
.96f5	f0 39		beq $9730	          BEQ ShPo_Ret
.96f7	a4 80		ldy $80		          LDY DOSFLA          ; point position
.96f9	90 16		bcc $9711	          BCC ShPo_25         ; -> more digits than chars
.96fb	85 78		sta $78		          STA KEYSIZ          ; chars - digits
.96fd	cc 24 01	cpy $0124	ShPo_10   CPY ENR             ; at end ?
.9700	f0 02		beq $9704	          BEQ ShPo_15         ; -> yes
.9702	b0 01		bcs $9705	          BCS ShPo_17           ; -> Y is beyond
.9704	c8		iny		ShPo_15   INY                 ; Y = after point
.9705	ee 2a 01	inc $012a	ShPo_17   INC VN              ; inc digits before point
.9708					  ShPo_20
.9708	20 3d 97	jsr $973d	          JSR Adjust_PU_Exp   ; Format exponent
.970b	c6 78		dec $78		          DEC KEYSIZ
.970d	d0 ee		bne $96fd	          BNE ShPo_10         ; loop
.970f	f0 1d		beq $972e	          BEQ ShPo_50         ; -> finish
.9711	49 ff		eor #$ff	ShPo_25   EOR #$ff
.9713	69 01		adc #$01	          ADC #1
.9715	85 78		sta $78		          STA KEYSIZ          ; KEYSIZ = -A
.9717	cc 23 01	cpy $0123	ShPo_30   CPY BNR             ; Y = at begin ?
.971a	f0 07		beq $9723	          BEQ ShPo_35         ; ->
.971c	88		dey		          DEY                 ; go backwards
.971d	ce 2a 01	dec $012a	          DEC VN              ; decrement chars after point
.9720	4c 25 97	jmp $9725	          JMP ShPo_40
.9723	e6 77		inc $77		ShPo_35   INC TEMP_A
.9725	a9 80		lda #$80	ShPo_40   LDA #$80
.9727					  ShPo_45
.9727	20 3f 97	jsr $973f	          JSR Adjust_PU_Exp_A
.972a	c6 78		dec $78		          DEC KEYSIZ
.972c	d0 e9		bne $9717	          BNE ShPo_30
.972e	84 80		sty $80		ShPo_50   STY DOSFLA
.9730	60		rts		ShPo_Ret  RTS
.9731					  Toggle_0_9
.9731	d0 39		bne $976c	          BNE APE_30
.9733	49 09		eor #$09	          EOR #9              ; '0' -> '9' or '9' -> '0'
.9735	9d 00 01	sta $0100,x	          STA STACK,X
.9738	ca		dex		          DEX
.9739	ec 29 01	cpx $0129	          CPX UEXP
.973c	60		rts		          RTS
.973d					  Adjust_PU_Exp
.973d	a9 00		lda #$00	          LDA #0
.973f					  Adjust_PU_Exp_A
.973f	ae 29 01	ldx $0129	          LDX UEXP
.9742	e8		inx		          INX
.9743	2c 30 01	bit $0130	          BIT ETOF
.9746	30 10		bmi $9758	          BMI APE_20
.9748	4d 28 01	eor $0128	          EOR USGN
.974b	f0 0b		beq $9758	          BEQ APE_20
.974d	20 82 97	jsr $9782	APE_10    JSR Inc_Digit_X
.9750	20 31 97	jsr $9731	          JSR Toggle_0_9
.9753	b0 f8		bcs $974d	          BCS APE_10
.9755	4c 5d 89	jmp $895d	          JMP Overflow_Error
.9758	bd 00 01	lda $0100,x	APE_20    LDA STACK,X
.975b	de 00 01	dec $0100,x	          DEC STACK,X
.975e	c9 30		cmp #$30	          CMP #'0'
.9760	20 31 97	jsr $9731	          JSR Toggle_0_9
.9763	b0 f3		bcs $9758	          BCS APE_20
.9765	2c 30 01	bit $0130	          BIT ETOF
.9768	10 05		bpl $976f	          BPL APE_40
.976a	84 80		sty $80		          STY DOSFLA
.976c	68		pla		APE_30    PLA
.976d	68		pla		          PLA
.976e	60		rts		          RTS
.976f	ad 28 01	lda $0128	APE_40    LDA USGN
.9772	49 80		eor #$80	          EOR #$80
.9774					  Print_Using_Exp
.9774	8d 28 01	sta $0128	          STA USGN
.9777	a9 30		lda #$30	          LDA #'0'
.9779	9d 01 01	sta $0101,x	          STA STACK+1,X
.977c	a9 31		lda #$31	          LDA #'1'
.977e	9d 02 01	sta $0102,x	          STA STACK+2,X
.9781	60		rts		          RTS
.9782					  Inc_Digit_X
.9782	bd 00 01	lda $0100,x	          LDA STACK,X
.9785	fe 00 01	inc $0100,x	          INC STACK,X
.9788	c9 39		cmp #$39	          CMP #'9'
.978a	60		rts		          RTS
.978b					  Inc_Using_Y
.978b	18		clc		          CLC
.978c	c8		iny		          INY
.978d	f0 05		beq $9794	          BEQ IUY_10
.978f	cc 35 01	cpy $0135	          CPY LFOR
.9792	90 04		bcc $9798	          BCC IUY_20
.9794	a4 77		ldy $77		IUY_10    LDY TEMP_A
.9796	d0 d4		bne $976c	          BNE APE_30
.9798	20 d3 42	jsr $42d3	IUY_20    JSR FNDPNT_from_Bank_1
.979b	ee 31 01	inc $0131	          INC CFORM
.979e	60		rts		          RTS
.979f					  Init_Using
.979f	20 81 87	jsr $8781	          JSR Free_String_FAC1
.97a2	85 78		sta $78		          STA KEYSIZ
.97a4	a2 0a		ldx #$0a	          LDX #10
.97a6	a9 00		lda #$00	          LDA #0
.97a8	9d 27 01	sta $0127,x	InUs_10   STA SWE,X
.97ab	ca		dex		          DEX
.97ac	10 fa		bpl $97a8	          BPL InUs_10
.97ae	8e 26 01	stx $0126	          STX FLAG            ; = $ff
.97b1	86 80		stx $80		          STX DOSFLA          ; = $ff
.97b3	8e 25 01	stx $0125	          STX DOLR            ; = $ff
.97b6	aa		tax		          TAX
.97b7	a8		tay		          TAY
.97b8	60		rts		          RTS
.97b9					  Using_Round
.97b9	18		clc		          CLC
.97ba	a5 80		lda $80		          LDA DOSFLA
.97bc	6d 2d 01	adc $012d	          ADC NF
.97bf	b0 39		bcs $97fa	          BCS UsRo_Ret
.97c1	38		sec		          SEC
.97c2	e5 77		sbc $77		          SBC TEMP_A
.97c4	90 34		bcc $97fa	          BCC UsRo_Ret
.97c6	cd 24 01	cmp $0124	          CMP ENR
.97c9	f0 02		beq $97cd	          BEQ UsRo_10
.97cb	b0 2d		bcs $97fa	          BCS UsRo_Ret
.97cd	cd 23 01	cmp $0123	UsRo_10   CMP BNR
.97d0	90 28		bcc $97fa	          BCC UsRo_Ret
.97d2	aa		tax		          TAX
.97d3	bd 00 01	lda $0100,x	          LDA STACK,X         ; char after last printable
.97d6	c9 35		cmp #$35	          CMP #'5'            ; less 5 ?
.97d8	90 20		bcc $97fa	          BCC UsRo_Ret        ; -> cut off
.97da	ec 23 01	cpx $0123	UsRo_20   CPX BNR             ; at begin ?
.97dd	f0 0a		beq $97e9	          BEQ UsRo_30         ; -> store 1
.97df	ca		dex		          DEX                 ; X = last printable position
.97e0	20 82 97	jsr $9782	          JSR Inc_Digit_X     ; round up
.97e3	8e 24 01	stx $0124	          STX ENR
.97e6	f0 f2		beq $97da	          BEQ UsRo_20
.97e8	60		rts		          RTS
.97e9	a9 31		lda #$31	UsRo_30   LDA #'1'            ; 0.5 - 0.9 -> round to 1
.97eb	9d 00 01	sta $0100,x	          STA STACK,X
.97ee	e8		inx		          INX
.97ef	86 80		stx $80		          STX DOSFLA
.97f1	c6 77		dec $77		          DEC TEMP_A
.97f3	10 05		bpl $97fa	          BPL UsRo_Ret
.97f5	e6 77		inc $77		          INC TEMP_A
.97f7	ee 2a 01	inc $012a	          INC VN
.97fa	60		rts		UsRo_Ret  RTS
.97fb					  Check_Zeroes
.97fb	a4 80		ldy $80		          LDY DOSFLA          ; write position at start ?
.97fd	f0 17		beq $9816	          BEQ UsZe_20           ; -> remove leading zeroes
.97ff					  Leading_Zero
.97ff	ac 23 01	ldy $0123	          LDY BNR             ; Y = begin
.9802					  Using_Zero
.9802	b9 00 01	lda $0100,y	          LDA STACK,Y
.9805	c9 30		cmp #$30	          CMP #'0'
.9807	60		rts		          RTS
.9808	e6 80		inc $80		UsZe_10   INC DOSFLA
.980a	20 3d 97	jsr $973d	          JSR Adjust_PU_Exp
.980d	ee 23 01	inc $0123	          INC BNR
.9810	cc 24 01	cpy $0124	          CPY ENR
.9813	f0 e5		beq $97fa	          BEQ UsRo_Ret
.9815	c8		iny		          INY
.9816	20 02 98	jsr $9802	UsZe_20   JSR Using_Zero
.9819	f0 ed		beq $9808	          BEQ UsZe_10
.981b	60		rts		          RTS
.981c					  Output_Formatted
.981c	ad 25 01	lda $0125	          LDA DOLR            ; dollar flag ?
.981f	30 02		bmi $9823	          BMI OuFo_10         ; -> no $
.9821	e6 77		inc $77		          INC TEMP_A
.9823	ae 23 01	ldx $0123	OuFo_10   LDX BNR             ; X = begin index number string
.9826	ca		dex		          DEX
.9827	ac 34 01	ldy $0134	          LDY BEGFD           ; Y = begin index format string
.982a	20 d3 42	jsr $42d3	OuFo_12   JSR FNDPNT_from_Bank_1
.982d	c8		iny		          INY                 ; advance index to number string
.982e	c9 2c		cmp #$2c	          CMP #','
.9830	d0 14		bne $9846	          BNE OuFo_16         ; -> not a comma
.9832	2c 26 01	bit $0126	          BIT FLAG            ; comma flag ?
.9835	30 09		bmi $9840	          BMI OuFo_14         ; -> don't print commas
.9837	8d 03 ff	sta $ff03	          STA MMU_LCRC
.983a	ad 05 12	lda $1205	          LDA PU_COMMA          ; load comma separator symbol
.983d	4c ab 98	jmp $98ab	          JMP OuFo_38         ; -> print it
.9840	ad 33 01	lda $0133	OuFo_14   LDA BLFD            ; load fill character
.9843	4c ab 98	jmp $98ab	          JMP OuFo_38         ; -> print it
.9846	c9 2e		cmp #$2e	OuFo_16   CMP #'.'
.9848	d0 09		bne $9853	          BNE OuFo_18         ; -> no dot
.984a	8d 03 ff	sta $ff03	          STA MMU_LCRC
.984d	ad 06 12	lda $1206	          LDA PU_DOT
.9850	4c ab 98	jmp $98ab	          JMP OuFo_38         ; -> print dot
.9853	c9 2b		cmp #$2b	OuFo_18   CMP #'+'
.9855	f0 3b		beq $9892	          BEQ OuFo_28         ; -> print + or -
.9857	c9 2d		cmp #$2d	          CMP #'-'
.9859	f0 32		beq $988d	          BEQ OuFo_26         ; -> print blank or -
.985b	c9 5e		cmp #$5e	          CMP #'^'
.985d	d0 69		bne $98c8	          BNE OuFo_44
.985f	a9 45		lda #$45	          LDA #'E'            ; -> print start of exponent
.9861	20 eb 98	jsr $98eb	          JSR Chrout_Using
.9864	ac 29 01	ldy $0129	          LDY UEXP
.9867	20 02 98	jsr $9802	          JSR Using_Zero
.986a	d0 06		bne $9872	          BNE OuFo_20
.986c	c8		iny		          INY
.986d	20 02 98	jsr $9802	          JSR Using_Zero
.9870	f0 07		beq $9879	          BEQ OuFo_22
.9872	a9 2d		lda #$2d	OuFo_20   LDA #'-'
.9874	2c 28 01	bit $0128	          BIT USGN
.9877	30 02		bmi $987b	          BMI OuFo_24
.9879	a9 2b		lda #$2b	OuFo_22   LDA #'+'
.987b	20 eb 98	jsr $98eb	OuFo_24   JSR Chrout_Using    ; print sign of exponent
.987e	ae 29 01	ldx $0129	          LDX UEXP
.9881	bd 00 01	lda $0100,x	          LDA STACK,X
.9884	20 eb 98	jsr $98eb	          JSR Chrout_Using
.9887	ac 36 01	ldy $0136	          LDY ENDFD
.988a	4c a1 98	jmp $98a1	          JMP OuFo_32
.988d	ad 32 01	lda $0132	OuFo_26   LDA SNO
.9890	30 ae		bmi $9840	          BMI OuFo_14
.9892	ad 32 01	lda $0132	OuFo_28   LDA SNO
.9895	4c ab 98	jmp $98ab	          JMP OuFo_38         ; -> print sign
.9898	a5 77		lda $77		OuFo_30   LDA TEMP_A
.989a	d0 18		bne $98b4	          BNE OuFo_42
.989c	ec 24 01	cpx $0124	          CPX ENR
.989f	f0 05		beq $98a6	          BEQ OuFo_34
.98a1	e8		inx		OuFo_32   INX
.98a2	bd 00 01	lda $0100,x	          LDA STACK,X
>98a5	2c				          .BYTE $2C ;BIT
.98a6	a9 30		lda #$30	OuFo_34   LDA #'0'
.98a8	4e 26 01	lsr $0126	OuFo_36   LSR FLAG
.98ab	20 eb 98	jsr $98eb	OuFo_38   JSR Chrout_Using
.98ae	f0 03		beq $98b3	          BEQ OuFo_40
.98b0	4c 2a 98	jmp $982a	          JMP OuFo_12
.98b3	60		rts		OuFo_40   RTS
.98b4	c6 77		dec $77		OuFo_42   DEC TEMP_A
.98b6	ad 25 01	lda $0125	          LDA DOLR
.98b9	30 eb		bmi $98a6	          BMI OuFo_34
.98bb	20 6e aa	jsr $aa6e	          JSR Output_Comma
.98be	ea		nop		          NOP
.98bf	8d 03 ff	sta $ff03	          STA MMU_LCRC
.98c2	ad 07 12	lda $1207	          LDA PU_MONEY          ; currency symbol
.98c5	4c a8 98	jmp $98a8	          JMP OuFo_36
.98c8	ad 27 01	lda $0127	OuFo_44   LDA SWE
.98cb	f0 cb		beq $9898	          BEQ OuFo_30
.98cd	ce 27 01	dec $0127	          DEC SWE
.98d0	f0 03		beq $98d5	OuFo_46   BEQ OuFo_48
.98d2	4c 40 98	jmp $9840	          JMP OuFo_14
.98d5	ad 2e 01	lda $012e	OuFo_48   LDA POSP
.98d8	30 f6		bmi $98d0	          BMI OuFo_46
.98da	20 d3 42	jsr $42d3	OuFo_50   JSR FNDPNT_from_Bank_1
.98dd	c9 2c		cmp #$2c	          CMP #','
.98df	d0 ac		bne $988d	          BNE OuFo_26
.98e1	ad 33 01	lda $0133	          LDA BLFD
.98e4	20 eb 98	jsr $98eb	          JSR Chrout_Using
.98e7	c8		iny		          INY
.98e8	4c da 98	jmp $98da	          JMP OuFo_50
.98eb					  Chrout_Using
.98eb	20 0c 56	jsr $560c	          JSR Print_Char
.98ee	ce 31 01	dec $0131	          DEC CFORM
.98f1	60		rts		          RTS
.98f2					  Analyse_Using
.98f2	ac 36 01	ldy $0136	          LDY ENDFD
.98f5	20 8b 97	jsr $978b	AnUs_10   JSR Inc_Using_Y
.98f8	20 a7 99	jsr $99a7	          JSR Is_Format_Control_Char
.98fb	d0 14		bne $9911	          BNE AnUs_25
.98fd	8c 34 01	sty $0134	          STY BEGFD           ; index to start of format
.9900	90 1a		bcc $991c	          BCC AnUs_35         ; -> char is '#'
.9902	aa		tax		          TAX                 ; save char
.9903	20 8b 97	jsr $978b	AnUs_15   JSR Inc_Using_Y
.9906	b0 05		bcs $990d	          BCS AnUs_20         ; -> end of format
.9908	20 af 99	jsr $99af	          JSR Is_Dot_Align
.990b	f0 0a		beq $9917	          BEQ AnUs_30
.990d	ac 34 01	ldy $0134	AnUs_20   LDY BEGFD
.9910	8a		txa		          TXA                 ; restore char
.9911	20 0c 56	jsr $560c	AnUs_25   JSR Print_Char      ; print char from format string
.9914	4c f5 98	jmp $98f5	          JMP AnUs_10         ; -> loop
.9917	b0 ea		bcs $9903	AnUs_30   BCS AnUs_15
.9919	ac 34 01	ldy $0134	          LDY BEGFD
.991c	a6 77		ldx $77		AnUs_35   LDX TEMP_A
.991e	d0 7a		bne $999a	          BNE IFS_20
.9920	8e 31 01	stx $0131	          STX CFORM
.9923	88		dey		          DEY
.9924	ce 31 01	dec $0131	AnUs_40   DEC CFORM
.9927	20 8b 97	jsr $978b	AnUs_45   JSR Inc_Using_Y
.992a	b0 74		bcs $99a0	          BCS IFS_40
.992c	c9 2c		cmp #$2c	          CMP #','
.992e	f0 f7		beq $9927	          BEQ AnUs_45
.9930	20 7e 99	jsr $997e	          JSR Is_Format_Sign
.9933	90 ef		bcc $9924	          BCC AnUs_40
.9935	c9 2e		cmp #$2e	          CMP #'.'
.9937	d0 08		bne $9941	          BNE AnUs_55
.9939	e8		inx		          INX
.993a	e0 02		cpx #$02	          CPX #2
.993c	90 e9		bcc $9927	          BCC AnUs_45
.993e	4c 6c 79	jmp $796c	AnUs_50   JMP SYNTAX_ERROR
.9941	20 b3 99	jsr $99b3	AnUs_55   JSR Is_Align
.9944	d0 0b		bne $9951	          BNE AnUs_65
.9946	90 03		bcc $994b	          BCC AnUs_60
.9948	8d 2b 01	sta $012b	          STA CHSN
.994b	fe 2c 01	inc $012c,x	AnUs_60   INC VF,X
.994e	4c 27 99	jmp $9927	          JMP AnUs_45
.9951	c9 24		cmp #$24	AnUs_65   CMP #'$'
.9953	d0 0f		bne $9964	          BNE AnUs_70
.9955	2c 25 01	bit $0125	          BIT DOLR
.9958	10 f1		bpl $994b	          BPL AnUs_60
.995a	18		clc		          CLC
.995b	6e 25 01	ror $0125	          ROR DOLR
.995e	ce 2c 01	dec $012c	          DEC VF
.9961	4c 4b 99	jmp $994b	          JMP AnUs_60
.9964	c9 5e		cmp #$5e	AnUs_70   CMP #'^'
.9966	d0 16		bne $997e	          BNE Is_Format_Sign
.9968	a2 02		ldx #$02	          LDX #2
.996a	20 8b 97	jsr $978b	AnUs_75   JSR Inc_Using_Y
.996d	b0 cf		bcs $993e	          BCS AnUs_50
.996f	c9 5e		cmp #$5e	          CMP #'^'
.9971	d0 cb		bne $993e	          BNE AnUs_50
.9973	ca		dex		          DEX
.9974	10 f4		bpl $996a	          BPL AnUs_75
.9976	ee 2f 01	inc $012f	          INC FESP
.9979	20 8b 97	jsr $978b	          JSR Inc_Using_Y
.997c	b0 22		bcs $99a0	          BCS IFS_40
.997e					  Is_Format_Sign
.997e	c9 2b		cmp #$2b	          CMP #'+'
.9980	d0 19		bne $999b	          BNE IFS_30
.9982	ad 32 01	lda $0132	          LDA SNO
.9985	10 05		bpl $998c	          BPL IFS_10
.9987	a9 2b		lda #$2b	          LDA #'+'
.9989	8d 32 01	sta $0132	          STA SNO
.998c	ad 2e 01	lda $012e	IFS_10    LDA POSP
.998f	d0 ad		bne $993e	          BNE AnUs_50
.9991	6e 2e 01	ror $012e	          ROR POSP
.9994	8c 36 01	sty $0136	          STY ENDFD
.9997	ee 31 01	inc $0131	          INC CFORM
.999a	60		rts		IFS_20    RTS
.999b	c9 2d		cmp #$2d	IFS_30    CMP #'-'
.999d	f0 ed		beq $998c	          BEQ IFS_10
.999f	38		sec		          SEC
.99a0	8c 36 01	sty $0136	IFS_40    STY ENDFD
.99a3	ce 36 01	dec $0136	          DEC ENDFD
.99a6	60		rts		          RTS
.99a7					  Is_Format_Control_Char
.99a7	c9 2b		cmp #$2b	          CMP #'+'
.99a9	f0 15		beq $99c0	          BEQ Alig_Ret
.99ab	c9 2d		cmp #$2d	          CMP #'-'
.99ad	f0 11		beq $99c0	          BEQ Alig_Ret
.99af					  Is_Dot_Align
.99af	c9 2e		cmp #$2e	          CMP #'.'
.99b1	f0 0d		beq $99c0	          BEQ Alig_Ret
.99b3					  Is_Align
.99b3	c9 3d		cmp #$3d	          CMP #'='            ; align left
.99b5	f0 09		beq $99c0	          BEQ Alig_Ret
.99b7	c9 3e		cmp #$3e	          CMP #'>'            ; align right
.99b9	f0 05		beq $99c0	          BEQ Alig_Ret
.99bb	c9 23		cmp #$23	          CMP #'#'            ; digit
.99bd	d0 01		bne $99c0	          BNE Alig_Ret
.99bf	18		clc		          CLC
.99c0	60		rts		Alig_Ret  RTS
.99c1					  FUNC_INSTR
.99c1	a5 66		lda $66		          LDA FAC1_M3
.99c3	8d d6 03	sta $03d6	          STA TMPDES
.99c6	a5 67		lda $67		          LDA FAC1_M4
.99c8	8d d7 03	sta $03d7	          STA TMPDES+1        ; TMPDES = address of descriptor
.99cb	20 ef 77	jsr $77ef	          JSR Eval_Expression
.99ce	20 dd 77	jsr $77dd	          JSR Need_String
.99d1	a5 66		lda $66		          LDA FAC1_M3
.99d3	8d d8 03	sta $03d8	          STA TMPDES+2
.99d6	a5 67		lda $67		          LDA FAC1_M4
.99d8	8d d9 03	sta $03d9	          STA TMPDES+3        ; TMPDES+2 = address of search descriptor
.99db	a2 01		ldx #$01	          LDX #1
.99dd	86 67		stx $67		          STX FAC1_M4         ; default start index
.99df	20 86 03	jsr $0386	          JSR CHRGOT
.99e2	c9 29		cmp #$29	          CMP #')'
.99e4	f0 03		beq $99e9	          BEQ FUIN_10         ; -> end of arguments
.99e6	20 09 88	jsr $8809	          JSR Comma_And_Byte
.99e9	20 56 79	jsr $7956	FUIN_10   JSR Need_Right_Par
.99ec	a6 67		ldx $67		          LDX FAC1_M4         ; start index (1-255)
.99ee	d0 03		bne $99f3	          BNE FUIN_20         ; must not be zero
.99f0	4c 28 7d	jmp $7d28	          JMP Error_Illegal_Quantity
.99f3	ca		dex		FUIN_20   DEX
.99f4	86 63		stx $63		          STX FAC1_EX         ; start index (0-254)
.99f6	a2 03		ldx #$03	          LDX #3
.99f8	bd d6 03	lda $03d6,x	FUIN_30   LDA TMPDES,X        ; copy string addresses
.99fb	95 59		sta $59,x	          STA FACTPA,X        ; FACTPA = TMPDES
.99fd	ca		dex		          DEX
.99fe	10 f8		bpl $99f8	          BPL FUIN_30
.9a00	a0 02		ldy #$02	          LDY #2
.9a02	a9 59		lda #$59	FUIN_40   LDA #FACTPA
.9a04	20 ab 03	jsr $03ab	          JSR Fetch_1         ; next byte descriptor
.9a07	99 5d 00	sta $005d,y	          STA DESCA,Y         ; 3 bytes
.9a0a	a9 5b		lda #$5b	          LDA #FACTPA+2
.9a0c	20 ab 03	jsr $03ab	          JSR Fetch_1         ; next byte of search descriptor
.9a0f	99 60 00	sta $0060,y	          STA TENEXP,Y        ; 3 bytes
.9a12	88		dey		          DEY
.9a13	10 ed		bpl $9a02	          BPL FUIN_40
.9a15	a5 60		lda $60		          LDA TENEXP          ; length of search string
.9a17	f0 3b		beq $9a54	          BEQ FUIN_90         ; -> empty search string: not found
.9a19	a9 00		lda #$00	FUIN_50   LDA #0              ; reset search index
.9a1b	85 64		sta $64		          STA FAC1_M1
.9a1d	18		clc		          CLC
.9a1e	a5 60		lda $60		          LDA TENEXP          ; A = length of search string
.9a20	65 63		adc $63		          ADC FAC1_EX         ; A += start index
.9a22	b0 30		bcs $9a54	          BCS FUIN_90         ; -> index overflow
.9a24	c5 5d		cmp $5d		          CMP DESCA           ; compare with length of string
.9a26	90 02		bcc $9a2a	          BCC FUIN_60         ; -> continue
.9a28	d0 2a		bne $9a54	          BNE FUIN_90         ; -> beyond end of string
.9a2a	a4 64		ldy $64		FUIN_60   LDY FAC1_M1         ; search index
.9a2c	c4 60		cpy $60		          CPY TENEXP          ; compare with search length
.9a2e	f0 1f		beq $9a4f	          BEQ FUIN_80         ; -> found!
.9a30	98		tya		          TYA
.9a31	18		clc		          CLC
.9a32	65 63		adc $63		          ADC FAC1_EX         ; position = search index + search start
.9a34	a8		tay		          TAY
.9a35	a9 5e		lda #$5e	          LDA #DESCA+1        ; load next char string
.9a37	20 ab 03	jsr $03ab	          JSR Fetch_1
.9a3a	85 79		sta $79		          STA SYNTMP          ; save it
.9a3c	a4 64		ldy $64		          LDY FAC1_M1
.9a3e	a9 61		lda #$61	          LDA #TENEXP+1       ; load next char of search string
.9a40	20 ab 03	jsr $03ab	          JSR Fetch_1
.9a43	c5 79		cmp $79		          CMP SYNTMP          ; compare string char with search char
.9a45	f0 04		beq $9a4b	          BEQ FUIN_70         ; -> continue if equal
.9a47	e6 63		inc $63		          INC FAC1_EX         ; increment search index
.9a49	d0 ce		bne $9a19	          BNE FUIN_50         ; always
.9a4b	e6 64		inc $64		FUIN_70   INC FAC1_M1         ; increment search index
.9a4d	d0 db		bne $9a2a	          BNE FUIN_60         ; branch always
.9a4f	e6 63		inc $63		FUIN_80   INC FAC1_EX         ; add 1 for range correction
.9a51	a5 63		lda $63		          LDA FAC1_EX         ; load it as result
>9a53	2c				          .BYTE $2C ;BIT
.9a54	a9 00		lda #$00	FUIN_90   LDA #0
.9a56	8d 03 ff	sta $ff03	          STA MMU_LCRC
.9a59	48		pha		          PHA                 ; push result
.9a5a	ad d8 03	lda $03d8	          LDA TMPDES+2
.9a5d	ac d9 03	ldy $03d9	          LDY TMPDES+3
.9a60	20 85 87	jsr $8785	          JSR Free_String_AY  ; free search pattern
.9a63	8d 03 ff	sta $ff03	          STA MMU_LCRC
.9a66	ad d6 03	lda $03d6	          LDA TMPDES
.9a69	ac d7 03	ldy $03d7	          LDY TMPDES+1
.9a6c	20 85 87	jsr $8785	          JSR Free_String_AY  ; free string
.9a6f	68		pla		          PLA                 ; pop result
.9a70	a8		tay		          TAY
.9a71	4c d4 84	jmp $84d4	          JMP Y_To_Real
.9a74					  Sin_Cos_Ang
.9a74	20 8f 9d	jsr $9d8f	          JSR LAY_XPOS_Y      ; A/Y = XPOS,Y
.9a77					  Sin_Cos_AY
.9a77	a2 00		ldx #$00	          LDX #0
.9a79	e8		inx		SCAY_10   INX                 ; X = 1 + (A/Y) / 90
.9a7a	38		sec		          SEC
.9a7b	e9 5a		sbc #$5a	          SBC #90
.9a7d	b0 fa		bcs $9a79	          BCS SCAY_10
.9a7f	88		dey		          DEY
.9a80	10 f7		bpl $9a79	          BPL SCAY_10
.9a82	8e 49 11	stx $1149	          STX ANGSGN          ; 1 + (A/Y) / 90
.9a85	48		pha		          PHA                 ; push A
.9a86	69 5a		adc #$5a	          ADC #90
.9a88	20 94 9a	jsr $9a94	          JSR SCAY_20         ; COS(val)
.9a8b	68		pla		          PLA                 ; pull A
.9a8c	18		clc		          CLC
.9a8d	49 ff		eor #$ff	          EOR #$ff
.9a8f	69 01		adc #$01	          ADC #1              ; negate A
.9a91	ce 49 11	dec $1149	          DEC ANGSGN          ; quadrant = (A/Y) / 90
.9a94					  SCAY_20
.9a94	a2 ff		ldx #$ff	          LDX #$ff            ; start loop with X=0
.9a96	e8		inx		SCAY_30   INX
.9a97	38		sec		          SEC
.9a98	e9 0a		sbc #$0a	          SBC #10
.9a9a	b0 fa		bcs $9a96	          BCS SCAY_30
.9a9c	69 0a		adc #$0a	          ADC #10
.9a9e	85 8e		sta $8e		          STA VTEMPA          ; A = angle % 10
.9aa0	8a		txa		          TXA                 ; X = angle / 10
.9aa1	0a		asl a		          ASL A               ; X *= 2
.9aa2	aa		tax		          TAX
.9aa3	bd 2a 9f	lda $9f2a,x	          LDA angval+1,X
.9aa6	bc 29 9f	ldy $9f29,x	          LDY angval,X        ; A/Y = SIN(X)  X unit = [10 deg]
.9aa9	18		clc		SCAY_40   CLC
.9aaa	c6 8e		dec $8e		          DEC VTEMPA
.9aac	30 0c		bmi $9aba	          BMI SCAY_50
.9aae	7d 3e 9f	adc $9f3e,x	          ADC incval+1,X      ; linear interpolation
.9ab1	48		pha		          PHA
.9ab2	98		tya		          TYA
.9ab3	7d 3d 9f	adc $9f3d,x	          ADC incval,X
.9ab6	a8		tay		          TAY
.9ab7	68		pla		          PLA
.9ab8	90 ef		bcc $9aa9	          BCC SCAY_40         ; always
.9aba	48		pha		SCAY_50   PHA
.9abb	a2 00		ldx #$00	          LDX #0
.9abd	ad 49 11	lda $1149	          LDA ANGSGN          ; quadrant
.9ac0	4a		lsr a		          LSR A
.9ac1	b0 02		bcs $9ac5	          BCS SCAY_60         ; -> odd quadrant
.9ac3	a2 02		ldx #$02	          LDX #2
.9ac5	68		pla		SCAY_60   PLA
.9ac6	9d 4a 11	sta $114a,x	          STA SINVAL,X        ; result low
.9ac9	98		tya		          TYA
.9aca	9d 4b 11	sta $114b,x	          STA SINVAL+1,X      ; result high
.9acd	60		rts		          RTS
.9ace					  LAY_SIN_X
.9ace	a0 19		ldy #$19	          LDY #SINVAL-XPOS    ; $19
.9ad0	90 02		bcc $9ad4	          BCC LSIN_10
.9ad2	a0 1b		ldy #$1b	          LDY #COSVAL-XPOS    ; $1b
.9ad4	ad 49 11	lda $1149	LSIN_10   LDA ANGSGN          ; quadrant
.9ad7	69 02		adc #$02	          ADC #2
.9ad9	4a		lsr a		          LSR A
.9ada	4a		lsr a		          LSR A
.9adb	08		php		          PHP
.9adc	20 8f 9d	jsr $9d8f	          JSR LAY_XPOS_Y      ; load SIN or COS to AY/
.9adf	c0 ff		cpy #$ff	          CPY #$ff
.9ae1	90 07		bcc $9aea	          BCC LSIN_20
.9ae3	8a		txa		          TXA
.9ae4	a8		tay		          TAY
.9ae5	20 8f 9d	jsr $9d8f	          JSR LAY_XPOS_Y      ; load angle to A/Y
.9ae8	b0 03		bcs $9aed	          BCS LSIN_30         ; always
.9aea	20 ae 9d	jsr $9dae	LSIN_20   JSR LAY_MUL_X       ; scale
.9aed	28		plp		LSIN_30   PLP
.9aee	b0 1b		bcs $9b0b	          BCS ANDI_Ret
.9af0	4c 9e 9d	jmp $9d9e	          JMP LABS_10
.9af3					  ANG_DIST
.9af3	8d 4e 11	sta $114e	          STA ANGCNT
.9af6	a2 23		ldx #$23	          LDX #XRADIUS-XPOS   ; $23
.9af8	0e 4e 11	asl $114e	ANDI_10   ASL ANGCNT
.9afb	20 ce 9a	jsr $9ace	          JSR LAY_SIN_X
.9afe	9d 31 11	sta $1131,x	          STA XPOS,X
.9b01	98		tya		          TYA
.9b02	9d 32 11	sta $1132,x	          STA XPOS+1,X
.9b05	e8		inx		          INX
.9b06	e8		inx		          INX
.9b07	e0 2b		cpx #$2b	          CPX #ANGBEG-XPOS    ; $2b
.9b09	90 ed		bcc $9af8	          BCC ANDI_10
.9b0b	60		rts		ANDI_Ret  RTS
.9b0c					  FUNC_RDOT
.9b0c	20 f7 87	jsr $87f7	          JSR Eval_Byte
.9b0f	e0 02		cpx #$02	          CPX #2
.9b11	90 10		bcc $9b23	          BCC RDOT_30
.9b13	f0 03		beq $9b18	          BEQ RDOT_10
.9b15	4c 28 7d	jmp $7d28	          JMP Error_Illegal_Quantity
.9b18	20 49 9c	jsr $9c49	RDOT_10   JSR Get_Pixel
.9b1b	a8		tay		          TAY
.9b1c	90 02		bcc $9b20	          BCC RDOT_20
.9b1e	a0 00		ldy #$00	          LDY #0
.9b20	4c d4 84	jmp $84d4	RDOT_20   JMP Y_To_Real
.9b23	8a		txa		RDOT_30   TXA
.9b24	0a		asl a		          ASL A
.9b25	aa		tax		          TAX
.9b26	bd 31 11	lda $1131,x	          LDA XPOS,X
.9b29	a8		tay		          TAY
.9b2a	bd 32 11	lda $1132,x	          LDA XPOS+1,X
.9b2d	4c 3c 79	jmp $793c	          JMP Integer_To_Real
.9b30					  Draw_Line
.9b30	a2 02		ldx #$02	          LDX #2
.9b32	a0 06		ldy #$06	          LDY #6
.9b34	a9 00		lda #$00	DrLi_10   LDA #0
.9b36	9d 3d 11	sta $113d,x	          STA XSGN,X
.9b39	9d 3e 11	sta $113e,x	          STA XSGN+1,X
.9b3c	20 99 9d	jsr $9d99	          JSR LAY_ABS_DIFF
.9b3f	10 08		bpl $9b49	          BPL DrLi_20
.9b41	de 3d 11	dec $113d,x	          DEC XSGN,X
.9b44	de 3e 11	dec $113e,x	          DEC XSGN+1,X
.9b47	d0 0b		bne $9b54	          BNE DrLi_40
.9b49	c9 00		cmp #$00	DrLi_20   CMP #0
.9b4b	d0 04		bne $9b51	          BNE DrLi_30
.9b4d	c0 00		cpy #$00	          CPY #0
.9b4f	f0 03		beq $9b54	          BEQ DrLi_40
.9b51	fe 3d 11	inc $113d,x	DrLi_30   INC XSGN,X
.9b54	9d 39 11	sta $1139,x	DrLi_40   STA XABS,X
.9b57	0a		asl a		          ASL A
.9b58	9d 41 11	sta $1141,x	          STA FCT,X
.9b5b	98		tya		          TYA
.9b5c	9d 3a 11	sta $113a,x	          STA XABS+1,X
.9b5f	2a		rol a		          ROL A
.9b60	9d 42 11	sta $1142,x	          STA FCT+1,X
.9b63	ca		dex		          DEX
.9b64	ca		dex		          DEX
.9b65	a0 04		ldy #$04	          LDY #4
.9b67	e0 00		cpx #$00	          CPX #0
.9b69	f0 c9		beq $9b34	          BEQ DrLi_10
.9b6b	a2 0a		ldx #$0a	          LDX #10
.9b6d	a0 08		ldy #$08	          LDY #8
.9b6f	20 7c 9d	jsr $9d7c	          JSR LAY_Y_SUB_X
.9b72	a9 00		lda #$00	          LDA #0
.9b74	2a		rol a		          ROL A
.9b75	2a		rol a		          ROL A
.9b76	8d 47 11	sta $1147	          STA LESSER
.9b79	49 02		eor #$02	          EOR #%00000010 ; $02
.9b7b	8d 48 11	sta $1148	          STA GREATR
.9b7e	18		clc		          CLC
.9b7f	a9 10		lda #$10	          LDA #16
.9b81	6d 47 11	adc $1147	          ADC LESSER
.9b84	a8		tay		          TAY
.9b85	48		pha		          PHA
.9b86	49 02		eor #$02	          EOR #%00000010 ; $02
.9b88	aa		tax		          TAX
.9b89	20 7c 9d	jsr $9d7c	          JSR LAY_Y_SUB_X
.9b8c	9d 31 11	sta $1131,x	          STA XPOS,X
.9b8f	98		tya		          TYA
.9b90	9d 32 11	sta $1132,x	          STA XPOS+1,X
.9b93	68		pla		          PLA
.9b94	a8		tay		          TAY
.9b95	18		clc		          CLC
.9b96	a9 08		lda #$08	          LDA #8
.9b98	6d 48 11	adc $1148	          ADC GREATR
.9b9b	aa		tax		          TAX
.9b9c	20 7c 9d	jsr $9d7c	          JSR LAY_Y_SUB_X
.9b9f	8d 45 11	sta $1145	          STA ERRVAL
.9ba2	8c 46 11	sty $1146	          STY ERRVAL+1
.9ba5	20 fb 9b	jsr $9bfb	DrLi_50   JSR Double_Pixel
.9ba8	ac 48 11	ldy $1148	          LDY GREATR
.9bab	38		sec		          SEC
.9bac	b9 39 11	lda $1139,y	          LDA XABS,Y
.9baf	e9 01		sbc #$01	          SBC #1
.9bb1	99 39 11	sta $1139,y	          STA XABS,Y
.9bb4	b0 0b		bcs $9bc1	          BCS DrLi_60
.9bb6	b9 3a 11	lda $113a,y	          LDA XABS+1,Y
.9bb9	e9 00		sbc #$00	          SBC #0
.9bbb	99 3a 11	sta $113a,y	          STA XABS+1,Y
.9bbe	b0 01		bcs $9bc1	          BCS DrLi_60
.9bc0	60		rts		          RTS
.9bc1	ae 47 11	ldx $1147	DrLi_60   LDX LESSER
.9bc4	ad 46 11	lda $1146	          LDA ERRVAL+1
.9bc7	30 06		bmi $9bcf	          BMI DrLi_70
.9bc9	20 ea 9b	jsr $9bea	          JSR Add_Increment
.9bcc	ae 48 11	ldx $1148	          LDX GREATR
.9bcf	18		clc		DrLi_70   CLC
.9bd0	ad 45 11	lda $1145	          LDA ERRVAL
.9bd3	7d 41 11	adc $1141,x	          ADC FCT,X
.9bd6	8d 45 11	sta $1145	          STA ERRVAL
.9bd9	ad 46 11	lda $1146	          LDA ERRVAL+1
.9bdc	7d 42 11	adc $1142,x	          ADC FCT+1,X
.9bdf	8d 46 11	sta $1146	          STA ERRVAL+1
.9be2	ae 48 11	ldx $1148	          LDX GREATR
.9be5	20 ea 9b	jsr $9bea	          JSR Add_Increment
.9be8	f0 bb		beq $9ba5	          BEQ DrLi_50
.9bea					  Add_Increment
.9bea	a0 02		ldy #$02	          LDY #2
.9bec	18		clc		          CLC
.9bed	bd 31 11	lda $1131,x	AdIn_10   LDA XPOS,X
.9bf0	7d 3d 11	adc $113d,x	          ADC XSGN,X
.9bf3	9d 31 11	sta $1131,x	          STA XPOS,X
.9bf6	e8		inx		          INX
.9bf7	88		dey		          DEY
.9bf8	d0 f3		bne $9bed	          BNE AdIn_10
.9bfa	60		rts		          RTS
.9bfb					  Double_Pixel
.9bfb	ad 6c 11	lda $116c	          LDA FILFLG
.9bfe	0d 6b 11	ora $116b	          ORA WIDTH
.9c01	f0 16		beq $9c19	          BEQ Set_Pixel
.9c03	ee 31 11	inc $1131	          INC XPOS            ; ++XPOS
.9c06	d0 03		bne $9c0b	          BNE DoPi_10
.9c08	ee 32 11	inc $1132	          INC XPOS+1
.9c0b	20 19 9c	jsr $9c19	DoPi_10   JSR Set_Pixel       ; set neighbour pixel
.9c0e	ae 31 11	ldx $1131	          LDX XPOS
.9c11	d0 03		bne $9c16	          BNE DoPi_20
.9c13	ce 32 11	dec $1132	          DEC XPOS+1          ; --XPOS
.9c16	ce 31 11	dec $1131	DoPi_20   DEC XPOS
.9c19					  Set_Pixel
.9c19	20 24 9d	jsr $9d24	          JSR LXY_ROW_COL
.9c1c	b0 24		bcs $9c42	          BCS SePi_30
.9c1e	20 70 9c	jsr $9c70	          JSR Color_Character
.9c21	20 e8 9c	jsr $9ce8	          JSR getpos_10
.9c24	8d 6d 11	sta $116d	          STA BITMSK
.9c27	b1 8c		lda ($8c),y	          LDA (GRAPNT),Y
.9c29	0d 6d 11	ora $116d	          ORA BITMSK
.9c2c	24 d8		bit $d8		          BIT GRAPHM
.9c2e	10 13		bpl $9c43	          BPL SePi_40
.9c30	48		pha		          PHA
.9c31	a6 83		ldx $83		          LDX COLSEL
.9c33	ad 6d 11	lda $116d	          LDA BITMSK
.9c36	3d 25 9f	and $9f25,x	          AND colval,X
.9c39	8d 6d 11	sta $116d	          STA BITMSK
.9c3c	68		pla		          PLA
.9c3d	4d 6d 11	eor $116d	SePi_10   EOR BITMSK
.9c40	91 8c		sta ($8c),y	SePi_20   STA (GRAPNT),Y
.9c42	60		rts		SePi_30   RTS
.9c43	a6 83		ldx $83		SePi_40   LDX COLSEL
.9c45	d0 f9		bne $9c40	          BNE SePi_20
.9c47	f0 f4		beq $9c3d	          BEQ SePi_10
.9c49					  Get_Pixel
.9c49	20 e3 9c	jsr $9ce3	          JSR getpos
.9c4c	b0 21		bcs $9c6f	          BCS GePi_Ret
.9c4e	8d 6d 11	sta $116d	          STA BITMSK
.9c51	b1 8c		lda ($8c),y	          LDA (GRAPNT),Y
.9c53	2d 6d 11	and $116d	          AND BITMSK
.9c56	2a		rol a		GePi_10   ROL A
.9c57	ca		dex		          DEX
.9c58	10 fc		bpl $9c56	          BPL GePi_10
.9c5a	2a		rol a		          ROL A
.9c5b	24 8b		bit $8b		          BIT STOPNB
.9c5d	30 06		bmi $9c65	          BMI GePi_20
.9c5f	29 03		and #$03	          AND #%00000011 ; $03
.9c61	c5 83		cmp $83		          CMP COLSEL
.9c63	18		clc		          CLC
.9c64	60		rts		          RTS
.9c65	18		clc		GePi_20   CLC
.9c66	29 03		and #$03	          AND #%00000011 ; $03
.9c68	f0 03		beq $9c6d	          BEQ GePi_30
.9c6a	a2 00		ldx #$00	          LDX #0
.9c6c	60		rts		          RTS
.9c6d	a2 ff		ldx #$ff	GePi_30   LDX #$ff
.9c6f	60		rts		GePi_Ret  RTS
.9c70					  Color_Character
.9c70	bd 33 c0	lda $c033,x	          LDA E_40_Line_Lo,X ; same values for color RAM
.9c73	85 8c		sta $8c		          STA GRAPNT
.9c75	bd ca 9c	lda $9cca,x	          LDA ColRAM_Line_Hi,X
.9c78	85 8d		sta $8d		          STA GRAPNT+1
.9c7a	a5 83		lda $83		          LDA COLSEL
.9c7c	d0 08		bne $9c86	          BNE CCha_10
.9c7e	ad e2 03	lda $03e2	          LDA FG_BG
.9c81	24 d8		bit $d8		          BIT GRAPHM
.9c83	10 08		bpl $9c8d	          BPL CCha_20
.9c85	60		rts		          RTS
.9c86	c9 02		cmp #$02	CCha_10   CMP #2
.9c88	d0 10		bne $9c9a	          BNE CCha_30
.9c8a	ad e3 03	lda $03e3	          LDA FG_MC1
.9c8d	29 0f		and #$0f	CCha_20   AND #%00001111 ; $0f
.9c8f	85 77		sta $77		          STA TEMP_A
.9c91	b1 8c		lda ($8c),y	          LDA (GRAPNT),Y
.9c93	29 f0		and #$f0	          AND #%11110000 ; $f0
.9c95	05 77		ora $77		          ORA TEMP_A
.9c97	91 8c		sta ($8c),y	          STA (GRAPNT),Y
.9c99	60		rts		          RTS
.9c9a	b0 10		bcs $9cac	CCha_30   BCS CCha_40
.9c9c	ad e2 03	lda $03e2	          LDA FG_BG
.9c9f	29 f0		and #$f0	          AND #%11110000 ; $f0
.9ca1	85 77		sta $77		          STA TEMP_A
.9ca3	b1 8c		lda ($8c),y	          LDA (GRAPNT),Y
.9ca5	29 0f		and #$0f	          AND #%00001111 ; $0f
.9ca7	05 77		ora $77		          ORA TEMP_A
.9ca9	91 8c		sta ($8c),y	          STA (GRAPNT),Y
.9cab	60		rts		          RTS
.9cac	a5 8d		lda $8d		CCha_40   LDA GRAPNT+1
.9cae	29 03		and #$03	          AND #%00000011 ; $03
.9cb0	09 d8		ora #$d8	          ORA #%11011000 ; $d8
.9cb2	85 8d		sta $8d		          STA GRAPNT+1
.9cb4	a9 00		lda #$00	          LDA #0
.9cb6	8d 00 ff	sta $ff00	          STA MMU_CR
.9cb9	78		sei		          SEI
.9cba	a5 01		lda $01		          LDA R8502
.9cbc	48		pha		          PHA
.9cbd	29 fe		and #$fe	          AND #%11111110 ; $fe
.9cbf	85 01		sta $01		          STA R8502
.9cc1	a5 85		lda $85		          LDA MULCO2
.9cc3	91 8c		sta ($8c),y	          STA (GRAPNT),Y
.9cc5	68		pla		          PLA
.9cc6	85 01		sta $01		          STA R8502
.9cc8	58		cli		          CLI
.9cc9	60		rts		          RTS
.9cca					  ColRAM_Line_Hi
>9cca	1c 1c 1c 1c 1c			          .BYTE $1c,$1c,$1c,$1c,$1c ; line  0 -  4
>9ccf	1c 1c 1d 1d 1d			          .BYTE $1c,$1c,$1d,$1d,$1d ; line  5 -  9
>9cd4	1d 1d 1d 1e 1e			          .BYTE $1d,$1d,$1d,$1e,$1e ; line 10 - 14
>9cd9	1e 1e 1e 1e 1e			          .BYTE $1e,$1e,$1e,$1e,$1e ; line 15 - 19
>9cde	1f 1f 1f 1f 1f			          .BYTE $1f,$1f,$1f,$1f,$1f ; line 20 - 24
.9ce3					  getpos
.9ce3	20 24 9d	jsr $9d24	          JSR LXY_ROW_COL
.9ce6	b0 33		bcs $9d1b	          BCS getpos_30
.9ce8					  getpos_10
.9ce8	98		tya		          TYA
.9ce9	18		clc		          CLC
.9cea	7d 33 c0	adc $c033,x	          ADC E_40_Line_Lo,X
.9ced	85 8c		sta $8c		          STA GRAPNT
.9cef	bd 4c c0	lda $c04c,x	          LDA E_40_Line_Hi,X
.9cf2	69 00		adc #$00	          ADC #0
.9cf4	06 8c		asl $8c		          ASL GRAPNT
.9cf6	2a		rol a		          ROL A
.9cf7	06 8c		asl $8c		          ASL GRAPNT
.9cf9	2a		rol a		          ROL A
.9cfa	06 8c		asl $8c		          ASL GRAPNT
.9cfc	2a		rol a		          ROL A
.9cfd	85 8d		sta $8d		          STA GRAPNT+1
.9cff	ad 33 11	lda $1133	          LDA YPOS
.9d02	29 07		and #$07	          AND #%00000111 ; $07
.9d04	a8		tay		          TAY
.9d05	ad 31 11	lda $1131	          LDA XPOS
.9d08	24 d8		bit $d8		          BIT GRAPHM
.9d0a	08		php		          PHP
.9d0b	10 01		bpl $9d0e	          BPL getpos_20
.9d0d	0a		asl a		          ASL A
.9d0e	29 07		and #$07	getpos_20 AND #%00000111 ; $07
.9d10	aa		tax		          TAX
.9d11	bd 1c 9d	lda $9d1c,x	          LDA rbits,X
.9d14	28		plp		          PLP
.9d15	10 04		bpl $9d1b	          BPL getpos_30
.9d17	e8		inx		          INX
.9d18	1d 1c 9d	ora $9d1c,x	          ORA rbits,X
.9d1b	60		rts		getpos_30 RTS
>9d1c	80 40 20 10 08 04 02 01		rbits     .BYTE $80,$40,$20,$10,$08,$04,$02,$01
.9d24					  LXY_ROW_COL
.9d24	ad 32 11	lda $1132	          LDA XPOS+1
.9d27	4a		lsr a		          LSR A
.9d28	d0 1e		bne $9d48	          BNE LXYRC_20
.9d2a	ad 31 11	lda $1131	          LDA XPOS
.9d2d	6a		ror a		          ROR A
.9d2e	4a		lsr a		          LSR A
.9d2f	24 d8		bit $d8		          BIT GRAPHM
.9d31	30 01		bmi $9d34	          BMI LXYRC_10
.9d33	4a		lsr a		          LSR A
.9d34	a8		tay		LXYRC_10  TAY
.9d35	c0 28		cpy #$28	          CPY #40             ; max columns
.9d37	b0 0f		bcs $9d48	          BCS LXYRC_20
.9d39	ad 34 11	lda $1134	          LDA YPOS+1
.9d3c	d0 0a		bne $9d48	          BNE LXYRC_20
.9d3e	ad 33 11	lda $1133	          LDA YPOS
.9d41	4a		lsr a		          LSR A
.9d42	4a		lsr a		          LSR A
.9d43	4a		lsr a		          LSR A
.9d44	aa		tax		          TAX
.9d45	c9 19		cmp #$19	          CMP #25             ; max rows
.9d47	60		rts		          RTS
.9d48	38		sec		LXYRC_20  SEC
.9d49	60		rts		          RTS
.9d4a					  Scale_XY
.9d4a	ad 6a 11	lda $116a	          LDA SCALEM
.9d4d	f0 17		beq $9d66	          BEQ ScXY_Ret
.9d4f	a5 87		lda $87		          LDA SCALE_X
.9d51	a4 88		ldy $88		          LDY SCALE_X+1
.9d53	20 5a 9d	jsr $9d5a	          JSR ScXY_10
.9d56	a5 89		lda $89		          LDA SCALE_Y
.9d58	a4 8a		ldy $8a		          LDY SCALE_Y+1
.9d5a					  ScXY_10
.9d5a	20 ae 9d	jsr $9dae	          JSR LAY_MUL_X
.9d5d	9d 31 11	sta $1131,x	          STA XPOS,X
.9d60	98		tya		          TYA
.9d61	e8		inx		          INX
.9d62	9d 31 11	sta $1131,x	          STA XPOS,X
.9d65	e8		inx		          INX
.9d66	60		rts		ScXY_Ret  RTS
.9d67					  LAY_ADD_SUB
.9d67	90 07		bcc $9d70	          BCC LAY_ADD_X
.9d69	b0 14		bcs $9d7f	          BCS LYSX_10
.9d6b					  LAY_SUB_ADD
.9d6b	b0 0f		bcs $9d7c	          BCS LAY_Y_SUB_X
.9d6d					  LAY_Y_ADD_X
.9d6d	20 8f 9d	jsr $9d8f	          JSR LAY_XPOS_Y
.9d70					  LAY_ADD_X
.9d70	18		clc		          CLC
.9d71	7d 31 11	adc $1131,x	          ADC XPOS,X
.9d74	48		pha		          PHA
.9d75	98		tya		          TYA
.9d76	7d 32 11	adc $1132,x	          ADC XPOS+1,X
.9d79	a8		tay		          TAY
.9d7a	68		pla		          PLA
.9d7b	60		rts		          RTS
.9d7c					  LAY_Y_SUB_X
.9d7c	20 8f 9d	jsr $9d8f	          JSR LAY_XPOS_Y
.9d7f	38		sec		LYSX_10   SEC
.9d80	fd 31 11	sbc $1131,x	          SBC XPOS,X
.9d83	85 59		sta $59		          STA FACTPA
.9d85	98		tya		          TYA
.9d86	fd 32 11	sbc $1132,x	          SBC XPOS+1,X
.9d89	a8		tay		          TAY
.9d8a	08		php		          PHP
.9d8b	a5 59		lda $59		          LDA FACTPA
.9d8d	28		plp		          PLP
.9d8e	60		rts		          RTS
.9d8f					  LAY_XPOS_Y
.9d8f	b9 31 11	lda $1131,y	          LDA XPOS,Y
.9d92	48		pha		          PHA
.9d93	b9 32 11	lda $1132,y	          LDA XPOS+1,Y
.9d96	a8		tay		          TAY
.9d97	68		pla		          PLA
.9d98	60		rts		          RTS
.9d99					  LAY_ABS_DIFF
.9d99	20 7c 9d	jsr $9d7c	          JSR LAY_Y_SUB_X
.9d9c					  LAY_ABS
.9d9c	10 0f		bpl $9dad	          BPL LABS_Ret
.9d9e	08		php		LABS_10   PHP
.9d9f	18		clc		          CLC
.9da0	49 ff		eor #$ff	          EOR #$ff
.9da2	69 01		adc #$01	          ADC #1
.9da4	48		pha		          PHA
.9da5	98		tya		          TYA
.9da6	49 ff		eor #$ff	          EOR #$ff
.9da8	69 00		adc #$00	          ADC #0
.9daa	a8		tay		          TAY
.9dab	68		pla		          PLA
.9dac	28		plp		          PLP
.9dad	60		rts		LABS_Ret  RTS
.9dae					  LAY_MUL_X
.9dae	84 8e		sty $8e		          STY VTEMPA
.9db0	85 8f		sta $8f		          STA VTEMPA+1
.9db2	bd 31 11	lda $1131,x	          LDA XPOS,X
.9db5	bc 32 11	ldy $1132,x	          LDY XPOS+1,X
.9db8	08		php		          PHP
.9db9	20 9c 9d	jsr $9d9c	          JSR LAY_ABS
.9dbc	9d 31 11	sta $1131,x	          STA XPOS,X
.9dbf	98		tya		          TYA
.9dc0	9d 32 11	sta $1132,x	          STA XPOS+1,X
.9dc3	a9 00		lda #$00	          LDA #0
.9dc5	8d 77 11	sta $1177	          STA VTEMP3
.9dc8	a0 10		ldy #$10	          LDY #16
.9dca	46 8e		lsr $8e		LAYMX_10  LSR VTEMPA
.9dcc	66 8f		ror $8f		          ROR VTEMPA+1
.9dce	90 0f		bcc $9ddf	          BCC LAYMX_20
.9dd0	18		clc		          CLC
.9dd1	7d 31 11	adc $1131,x	          ADC XPOS,X
.9dd4	48		pha		          PHA
.9dd5	ad 77 11	lda $1177	          LDA VTEMP3
.9dd8	7d 32 11	adc $1132,x	          ADC XPOS+1,X
.9ddb	8d 77 11	sta $1177	          STA VTEMP3
.9dde	68		pla		          PLA
.9ddf	4e 77 11	lsr $1177	LAYMX_20  LSR VTEMP3
.9de2	6a		ror a		          ROR A
.9de3	88		dey		          DEY
.9de4	d0 e4		bne $9dca	          BNE LAYMX_10
.9de6	69 00		adc #$00	          ADC #0
.9de8	ac 77 11	ldy $1177	          LDY VTEMP3
.9deb	90 01		bcc $9dee	          BCC LAYMX_30
.9ded	c8		iny		          INY
.9dee	28		plp		LAYMX_30  PLP
.9def	4c 9c 9d	jmp $9d9c	          JMP LAY_ABS
.9df2					  XY_DEST_To_POS
.9df2	a0 00		ldy #$00	          LDY #0
.9df4	20 f9 9d	jsr $9df9	          JSR DEST_To_POS
.9df7	a0 02		ldy #$02	          LDY #2
.9df9					  DEST_To_POS
.9df9	b9 35 11	lda $1135,y	          LDA XDEST,Y
.9dfc	99 31 11	sta $1131,y	          STA XPOS,Y
.9dff	b9 36 11	lda $1136,y	          LDA XDEST+1,Y
.9e02	99 32 11	sta $1132,y	          STA XPOS+1,Y
.9e05	60		rts		          RTS
.9e06					  Get_Comma_And_Integer
.9e06	20 86 03	jsr $0386	          JSR CHRGOT
.9e09	f0 0c		beq $9e17	          BEQ GCAI_10
.9e0b	20 5c 79	jsr $795c	          JSR Need_Comma
.9e0e	c9 2c		cmp #$2c	          CMP #','
.9e10	f0 05		beq $9e17	          BEQ GCAI_10
.9e12	20 12 88	jsr $8812	          JSR Get_Integer
.9e15	38		sec		          SEC
.9e16	60		rts		          RTS
.9e17	a9 00		lda #$00	GCAI_10   LDA #0
.9e19	a8		tay		          TAY
.9e1a	18		clc		GCAI_CRet CLC
.9e1b	60		rts		          RTS
.9e1c					  Get_Byte_Or_Zero
.9e1c	a2 00		ldx #$00	          LDX #0
.9e1e					  Get_Byte_Or_Void
.9e1e	20 86 03	jsr $0386	          JSR CHRGOT
.9e21	f0 f7		beq $9e1a	          BEQ GCAI_CRet
.9e23	20 5c 79	jsr $795c	          JSR Need_Comma
.9e26	c9 2c		cmp #$2c	          CMP #','
.9e28	f0 f0		beq $9e1a	          BEQ GCAI_CRet
.9e2a	20 f4 87	jsr $87f4	          JSR Get_Byte_Var
.9e2d	38		sec		          SEC
.9e2e	60		rts		          RTS
.9e2f					  Assert_Color_Source
.9e2f	20 74 a0	jsr $a074	          JSR Assert_Graphics_Mem
.9e32					  Get_Color_Source
.9e32	a2 01		ldx #$01	          LDX #1              ; default color = foreground
.9e34	20 86 03	jsr $0386	          JSR CHRGOT
.9e37	f0 13		beq $9e4c	          BEQ GCS_10
.9e39	c9 2c		cmp #$2c	          CMP #','
.9e3b	f0 0f		beq $9e4c	          BEQ GCS_10
.9e3d	20 f4 87	jsr $87f4	          JSR Get_Byte_Var
.9e40	e0 04		cpx #$04	          CPX #4
.9e42	b0 0b		bcs $9e4f	          BCS GCS_Err
.9e44	e0 02		cpx #$02	          CPX #2
.9e46	24 d8		bit $d8		          BIT GRAPHM
.9e48	30 02		bmi $9e4c	          BMI GCS_10
.9e4a	b0 03		bcs $9e4f	          BCS GCS_Err
.9e4c	86 83		stx $83		GCS_10    STX COLSEL
.9e4e	60		rts		          RTS
.9e4f	4c 28 7d	jmp $7d28	GCS_Err   JMP Error_Illegal_Quantity
.9e52					  Get_Graphics_XY
.9e52	20 86 03	jsr $0386	          JSR CHRGOT
.9e55	f0 07		beq $9e5e	          BEQ GGXY_10
.9e57	20 5c 79	jsr $795c	          JSR Need_Comma
.9e5a	c9 2c		cmp #$2c	          CMP #','
.9e5c	d0 12		bne $9e70	          BNE Get_Coordinates
.9e5e	a0 00		ldy #$00	GGXY_10   LDY #0
.9e60	b9 31 11	lda $1131,y	GGXY_20   LDA XPOS,Y
.9e63	9d 31 11	sta $1131,x	          STA XPOS,X
.9e66	e8		inx		          INX
.9e67	c8		iny		          INY
.9e68	c0 04		cpy #$04	          CPY #4
.9e6a	d0 f4		bne $9e60	          BNE GGXY_20
.9e6c	60		rts		          RTS
.9e6d					  Get_Comma_And_Coordinates
.9e6d	20 5c 79	jsr $795c	          JSR Need_Comma
.9e70					  Get_Coordinates
.9e70	8e 78 11	stx $1178	          STX VTEMP4
.9e73	20 08 9f	jsr $9f08	          JSR Get_Coordinate_Value
.9e76	20 86 03	jsr $0386	          JSR CHRGOT
.9e79	c9 2c		cmp #$2c	          CMP #','
.9e7b	f0 56		beq $9ed3	          BEQ GeCo_40
.9e7d	c9 3b		cmp #$3b	          CMP #';'
.9e7f	f0 03		beq $9e84	          BEQ GeCo_10
.9e81	4c 6c 79	jmp $796c	          JMP SYNTAX_ERROR
.9e84	20 80 03	jsr $0380	GeCo_10   JSR CHRGET
.9e87	20 12 88	jsr $8812	          JSR Get_Integer
.9e8a	85 77		sta $77		          STA TEMP_A
.9e8c	98		tya		          TYA
.9e8d	a4 77		ldy $77		          LDY TEMP_A
.9e8f	20 77 9a	jsr $9a77	          JSR Sin_Cos_AY
.9e92	ae 78 11	ldx $1178	          LDX VTEMP4
.9e95	bd 31 11	lda $1131,x	          LDA XPOS,X
.9e98	9d 33 11	sta $1133,x	          STA YPOS,X
.9e9b	bd 32 11	lda $1132,x	          LDA XPOS+1,X
.9e9e	9d 34 11	sta $1134,x	          STA YPOS+1,X
.9ea1	20 4a 9d	jsr $9d4a	          JSR Scale_XY
.9ea4	a9 0e		lda #$0e	          LDA #14
.9ea6	8d 79 11	sta $1179	          STA Rel_Abs_Flag
.9ea9	18		clc		          CLC
.9eaa	ae 78 11	ldx $1178	          LDX VTEMP4
.9ead	20 ce 9a	jsr $9ace	GeCo_20   JSR LAY_SIN_X
.9eb0	9d 31 11	sta $1131,x	          STA XPOS,X
.9eb3	98		tya		          TYA
.9eb4	9d 32 11	sta $1132,x	          STA XPOS+1,X
.9eb7	a0 00		ldy #$00	          LDY #0
.9eb9	4e 79 11	lsr $1179	          LSR Rel_Abs_Flag
.9ebc	90 02		bcc $9ec0	          BCC GeCo_30
.9ebe	a0 02		ldy #$02	          LDY #2
.9ec0	20 6b 9d	jsr $9d6b	GeCo_30   JSR LAY_SUB_ADD
.9ec3	9d 31 11	sta $1131,x	          STA XPOS,X
.9ec6	98		tya		          TYA
.9ec7	9d 32 11	sta $1132,x	          STA XPOS+1,X
.9eca	e8		inx		          INX
.9ecb	e8		inx		          INX
.9ecc	4e 79 11	lsr $1179	          LSR Rel_Abs_Flag
.9ecf	d0 dc		bne $9ead	          BNE GeCo_20
.9ed1	18		clc		          CLC
.9ed2	60		rts		          RTS
.9ed3	20 80 03	jsr $0380	GeCo_40   JSR CHRGET
.9ed6	ee 78 11	inc $1178	          INC VTEMP4
.9ed9	ee 78 11	inc $1178	          INC VTEMP4
.9edc	20 08 9f	jsr $9f08	          JSR Get_Coordinate_Value
.9edf	ae 78 11	ldx $1178	          LDX VTEMP4
.9ee2	ca		dex		          DEX
.9ee3	ca		dex		          DEX
.9ee4	20 4a 9d	jsr $9d4a	          JSR Scale_XY
.9ee7	a0 02		ldy #$02	          LDY #2
.9ee9	ae 78 11	ldx $1178	          LDX VTEMP4
.9eec	e8		inx		          INX
.9eed	e8		inx		          INX
.9eee	ca		dex		GeCo_50   DEX
.9eef	ca		dex		          DEX
.9ef0	4e 79 11	lsr $1179	          LSR Rel_Abs_Flag
.9ef3	90 0a		bcc $9eff	          BCC GeCo_60
.9ef5	20 6d 9d	jsr $9d6d	          JSR LAY_Y_ADD_X
.9ef8	9d 31 11	sta $1131,x	          STA XPOS,X
.9efb	98		tya		          TYA
.9efc	9d 32 11	sta $1132,x	          STA XPOS+1,X
.9eff	a0 00		ldy #$00	GeCo_60   LDY #0
.9f01	ec 78 11	cpx $1178	          CPX VTEMP4
.9f04	f0 e8		beq $9eee	          BEQ GeCo_50
.9f06	18		clc		          CLC
.9f07	60		rts		          RTS
.9f08					  Get_Coordinate_Value
.9f08	20 86 03	jsr $0386	          JSR CHRGOT
.9f0b	c9 aa		cmp #$aa	          CMP #$aa            ; + token
.9f0d	f0 05		beq $9f14	          BEQ GCV_10
.9f0f	c9 ab		cmp #$ab	          CMP #$ab            ; - token
.9f11	f0 01		beq $9f14	          BEQ GCV_10
.9f13	18		clc		          CLC
.9f14	2e 79 11	rol $1179	GCV_10    ROL Rel_Abs_Flag    ; set bit 7 if + or -
.9f17	20 c0 6d	jsr $6dc0	          JSR GSC_40          ; evaluate numeric
.9f1a	ae 78 11	ldx $1178	          LDX VTEMP4          ; storage pointer
.9f1d	9d 32 11	sta $1132,x	          STA XPOS+1,X        ; value high
.9f20	98		tya		          TYA
.9f21	9d 31 11	sta $1131,x	          STA XPOS,X          ; value low
.9f24	60		rts		          RTS
>9f25	ff aa 55 00			colval    .BYTE $ff,$aa,$55,$00
>9f29	00 00				angval    .WORD $0000 ; 0000 [00]  0.000
>9f2b	2c 71				          .WORD $712c ; 2c71 [10]  0.174
>9f2d	57 8d				          .WORD $8d57 ; 578d [20]  0.342
>9f2f	80 00				          .WORD $0080 ; 8000 [30]  0.500
>9f31	a4 8f				          .WORD $8fa4 ; a48f [40]  0.643
>9f33	c4 19				          .WORD $19c4 ; c419 [50]  0.766
>9f35	dd b2				          .WORD $b2dd ; ddb2 [60]  0.866
>9f37	f0 90				          .WORD $90f0 ; f090 [70]  0.940
>9f39	fc 1c				          .WORD $1cfc ; fc1c [80]  0.985
>9f3b	ff ff				          .WORD $ffff ; ffff [90]  1.000
>9f3d	04 72				incval    .WORD $7204 ;  472
>9f3f	04 50				          .WORD $5004 ;  450
>9f41	04 0b				          .WORD $0b04 ;  40b
>9f43	03 a8				          .WORD $a803 ;  3a8
>9f45	03 28				          .WORD $2803 ;  328
>9f47	02 90				          .WORD $9002 ;  290
>9f49	01 e3				          .WORD $e301 ;  1e3
>9f4b	01 28				          .WORD $2801 ;  128
>9f4d	00 63				          .WORD $6300 ;   63
.9f4f					  Allocate_Graphics_RAM
.9f4f	a5 76		lda $76		          LDA MVDFLG          ; graphics RAM reseved ?
.9f51	f0 01		beq $9f54	          BEQ AGR_10          ; -> no
.9f53	60		rts		          RTS                 ; nothing to do
.9f54	ad 11 12	lda $1211	AGR_10    LDA TEXT_TOP+1
.9f57	18		clc		          CLC
.9f58	69 24		adc #$24	          ADC #$24            ; 9 Kbyte free ?
.9f5a	b0 0e		bcs $9f6a	          BCS AGR_15
.9f5c	85 62		sta $62		          STA LOWTR+1         ; new value for TEXT_TOP+1
.9f5e	cd 13 12	cmp $1213	          CMP TEXT_MAX+1      ; compare with maximum ($ff)
.9f61	90 0a		bcc $9f6d	          BCC AGR_20          ; -> OK below
.9f63	d0 05		bne $9f6a	          BNE AGR_15          ; -> OOM
.9f65	cc 12 12	cpy $1212	          CPY TEXT_MAX        ; *** ERROR *** Y is undefined
.9f68	90 03		bcc $9f6d	          BCC AGR_20
.9f6a	4c 3a 4d	jmp $4d3a	AGR_15    JMP OOM_Error       ; Out Of Memory
.9f6d	c6 76		dec $76		AGR_20    DEC MVDFLG          ; MVDFLG = $ff
.9f6f	ad 10 12	lda $1210	          LDA TEXT_TOP
.9f72	85 24		sta $24		          STA INDEXA
.9f74	a5 62		lda $62		          LDA LOWTR+1
.9f76	85 25		sta $25		          STA INDEXA+1        ; INDEXA = TEXT_TOP + $2400
.9f78	ae 10 12	ldx $1210	          LDX TEXT_TOP
.9f7b	86 26		stx $26		          STX INDEXB
.9f7d	ad 11 12	lda $1211	          LDA TEXT_TOP+1
.9f80	85 27		sta $27		          STA INDEXB+1        ; INDEXB = TEXT_TOP
.9f82	38		sec		          SEC
.9f83	e9 1c		sbc #$1c	          SBC #$1c
.9f85	a8		tay		          TAY
.9f86	8a		txa		          TXA
.9f87	49 ff		eor #$ff	          EOR #$ff
.9f89	85 50		sta $50		          STA GRBPNT
.9f8b	98		tya		          TYA
.9f8c	49 ff		eor #$ff	          EOR #$ff
.9f8e	85 51		sta $51		          STA GRBPNT+1        ; GRBPNT = $1c00 - TEXT_TOP
.9f90	a0 00		ldy #$00	          LDY #0
.9f92	e6 50		inc $50		AGR_25    INC GRBPNT          ; ++GRBPNT (bytes to move)
.9f94	d0 04		bne $9f9a	          BNE AGR_30
.9f96	e6 51		inc $51		          INC GRBPNT+1
.9f98	f0 18		beq $9fb2	          BEQ AGR_45          ; -> exit loop
.9f9a	a5 24		lda $24		AGR_30    LDA INDEXA          ; --INDEXA (target pointer)
.9f9c	d0 02		bne $9fa0	          BNE AGR_35
.9f9e	c6 25		dec $25		          DEC INDEXA+1
.9fa0	c6 24		dec $24		AGR_35    DEC INDEXA
.9fa2	a5 26		lda $26		          LDA INDEXB          ; --INDEXB (source pointer)
.9fa4	d0 02		bne $9fa8	          BNE AGR_40
.9fa6	c6 27		dec $27		          DEC INDEXB+1
.9fa8	c6 26		dec $26		AGR_40    DEC INDEXB
.9faa	20 c0 03	jsr $03c0	          JSR Get_INDEXB_0    ; load  source
.9fad	91 24		sta ($24),y	          STA (INDEXA),Y      ; store target
.9faf	4c 92 9f	jmp $9f92	          JMP AGR_25          ; -> loop
.9fb2	18		clc		AGR_45    CLC
.9fb3	ad 11 12	lda $1211	          LDA TEXT_TOP+1      ; obsolete, is set below after Relink
.9fb6	69 24		adc #$24	          ADC #$24
.9fb8	8d 11 12	sta $1211	          STA TEXT_TOP+1      ; TEXT_TOP += $2400
.9fbb	a5 2e		lda $2e		          LDA TXTTAB+1
.9fbd	69 24		adc #$24	          ADC #$24
.9fbf	85 2e		sta $2e		          STA TXTTAB+1        ; TXTTAB   += $2400
.9fc1	a5 44		lda $44		          LDA DATPTR+1
.9fc3	69 24		adc #$24	          ADC #$24
.9fc5	85 44		sta $44		          STA DATPTR+1        ; DATPTR   += $2400
.9fc7	20 4f 4f	jsr $4f4f	AGR_50    JSR Relink
.9fca	20 82 4f	jsr $4f82	          JSR Set_TEXT_TOP
.9fcd	24 7f		bit $7f		          BIT RUNMOD
.9fcf	10 2d		bpl $9ffe	          BPL AGR_65
.9fd1	a2 24		ldx #$24	          LDX #$24            ; add $2400
.9fd3	24 76		bit $76		          BIT MVDFLG
.9fd5	30 02		bmi $9fd9	          BMI AGR_55
.9fd7	a2 dc		ldx #$dc	          LDX #$dc            ; subtract $2400
.9fd9	8a		txa		AGR_55    TXA
.9fda	18		clc		          CLC
.9fdb	65 3e		adc $3e		          ADC TXTPTR+1
.9fdd	85 3e		sta $3e		          STA TXTPTR+1        ; adjust TXTPTR
.9fdf	8a		txa		          TXA
.9fe0	18		clc		          CLC
.9fe1	6d 03 12	adc $1203	          ADC OLDTXT+1
.9fe4	8d 03 12	sta $1203	          STA OLDTXT+1        ; adjust OLDTXT
.9fe7	8a		txa		          TXA
.9fe8	18		clc		          CLC
.9fe9	6d 0f 12	adc $120f	          ADC ERRTXT+1
.9fec	8d 0f 12	sta $120f	          STA ERRTXT+1        ; adjust ERRTXT
.9fef	20 47 50	jsr $5047	          JSR Init_FNDPNT
.9ff2	a5 3f		lda $3f		AGR_60    LDA FNDPNT
.9ff4	c9 ff		cmp #$ff	          CMP #$ff
.9ff6	d0 07		bne $9fff	          BNE AGR_70
.9ff8	a5 40		lda $40		          LDA FNDPNT+1
.9ffa	c9 09		cmp #$09	          CMP #9
.9ffc	d0 01		bne $9fff	          BNE AGR_70
.9ffe	60		rts		AGR_65    RTS
.9fff	a0 00		ldy #$00	AGR_70    LDY #0              ; adjust structures on stack
.a001	b1 3f		lda ($3f),y	          LDA (FNDPNT),Y
.a003	c9 81		cmp #$81	          CMP #$81
.a005	d0 09		bne $a010	          BNE AGR_75
.a007	a0 10		ldy #$10	          LDY #16
.a009	20 62 a0	jsr $a062	          JSR Shift_Stack_Value
.a00c	a9 12		lda #$12	          LDA #$12
.a00e	d0 07		bne $a017	          BNE AGR_80
.a010	a0 04		ldy #$04	AGR_75    LDY #4
.a012	20 62 a0	jsr $a062	          JSR Shift_Stack_Value
.a015	a9 05		lda #$05	          LDA #5
.a017	18		clc		AGR_80    CLC
.a018	65 3f		adc $3f		          ADC FNDPNT
.a01a	85 3f		sta $3f		          STA FNDPNT
.a01c	90 d4		bcc $9ff2	          BCC AGR_60
.a01e	e6 40		inc $40		          INC FNDPNT+1
.a020	d0 d0		bne $9ff2	          BNE AGR_60
.a022					  Free_Graphics_RAM
.a022	a5 76		lda $76		          LDA MVDFLG          ; Graphics RAM allocated ?
.a024	d0 01		bne $a027	          BNE FGR_10          ; -> yes : unallocate
.a026	60		rts		          RTS
.a027	a0 00		ldy #$00	FGR_10    LDY #0
.a029	84 76		sty $76		          STY MVDFLG
.a02b	84 24		sty $24		          STY INDEXA
.a02d	84 26		sty $26		          STY INDEXB
.a02f	a9 1c		lda #$1c	          LDA #$1c
.a031	85 25		sta $25		          STA INDEXA+1        ; INDEXA = $1c00
.a033	a9 40		lda #$40	          LDA #$40 ; '@'
.a035	85 27		sta $27		          STA INDEXB+1        ; INDEXB = $4000
.a037	20 c0 03	jsr $03c0	FGR_20    JSR Get_INDEXB_0    ; Load  source
.a03a	91 24		sta ($24),y	          STA (INDEXA),Y      ; Store target
.a03c	c8		iny		          INY
.a03d	d0 f8		bne $a037	          BNE FGR_20
.a03f	e6 25		inc $25		          INC INDEXA+1        ; next page target
.a041	e6 27		inc $27		          INC INDEXB+1        ; next page source
.a043	ad 11 12	lda $1211	          LDA TEXT_TOP+1
.a046	c5 27		cmp $27		          CMP INDEXB+1
.a048	b0 ed		bcs $a037	          BCS FGR_20          ; loop until TEXT_TOP
.a04a	38		sec		          SEC
.a04b	a5 2e		lda $2e		          LDA TXTTAB+1
.a04d	e9 24		sbc #$24	          SBC #$24
.a04f	85 2e		sta $2e		          STA TXTTAB+1        ; TXTTAB -= $2400
.a051	ad 11 12	lda $1211	          LDA TEXT_TOP+1
.a054	e9 24		sbc #$24	          SBC #$24
.a056	8d 11 12	sta $1211	          STA TEXT_TOP+1      ; TEXT_TOP -= $2400
.a059	a5 44		lda $44		          LDA DATPTR+1
.a05b	e9 24		sbc #$24	          SBC #$24
.a05d	85 44		sta $44		          STA DATPTR+1        ; DATPTR -= $2400
.a05f	4c c7 9f	jmp $9fc7	          JMP AGR_50
.a062					  Shift_Stack_Value
.a062	b1 3f		lda ($3f),y	          LDA (FNDPNT),Y
.a064	24 76		bit $76		          BIT MVDFLG
.a066	d0 06		bne $a06e	          BNE SSV_10
.a068	38		sec		          SEC
.a069	e9 24		sbc #$24	          SBC #$24
.a06b	91 3f		sta ($3f),y	          STA (FNDPNT),Y
.a06d	60		rts		          RTS
.a06e	18		clc		SSV_10    CLC
.a06f	69 24		adc #$24	          ADC #$24
.a071	91 3f		sta ($3f),y	          STA (FNDPNT),Y
.a073	60		rts		          RTS
.a074					  Assert_Graphics_Mem
.a074	a5 76		lda $76		          LDA MVDFLG
.a076	f0 01		beq $a079	          BEQ NGA_Err
.a078	60		rts		          RTS
.a079	a2 23		ldx #$23	NGA_Err   LDX #$23            ; NO GRAPHICS AREA
.a07b	4c 3c 4d	jmp $4d3c	          JMP Print_Error_X
.a07e					  BASIC_DIRCAT
.a07e	20 bf a3	jsr $a3bf	          JSR DOS_Parser
.a081	a5 80		lda $80		          LDA DOSFLA
.a083	29 e6		and #$e6	          AND #%11100110     ; $e6: @,W,TD,LA,TFN
.a085	f0 03		beq $a08a	          BEQ DIR_10
.a087	4c 6c 79	jmp $796c	          JMP SYNTAX_ERROR
.a08a	a0 01		ldy #$01	DIR_10    LDY #1              ; start of command string
.a08c	a2 01		ldx #$01	          LDX #1              ; length of command string '$'
.a08e	a5 80		lda $80		          LDA DOSFLA
.a090	29 11		and #$11	          AND #%00010001     ; $11: drive, filename
.a092	f0 06		beq $a09a	          BEQ DIR_20          ; -> no drive or pattern
.a094	4a		lsr a		          LSR A               ; fn flag -> carry
.a095	90 02		bcc $a099	          BCC DIR_15          ; -> no pattern
.a097	e8		inx		          INX
.a098	e8		inx		          INX                 ; "$0:"
.a099	e8		inx		DIR_15    INX                 ; "$0:pattern"
.a09a	8a		txa		DIR_20    TXA                 ; length of command string
.a09b	20 67 a6	jsr $a667	          JSR Build_DOS_Command
.a09e	a9 00		lda #$00	          LDA #0
.a0a0	aa		tax		          TAX
.a0a1	20 87 92	jsr $9287	          JSR B_SETBNK        ; bank 0
.a0a4	a0 60		ldy #$60	          LDY #$60            ; SA
.a0a6	ae 1c 01	ldx $011c	          LDX DOS_FA          ; FA
.a0a9	a9 00		lda #$00	          LDA #0              ; LA
.a0ab	20 57 92	jsr $9257	          JSR B_SETLFS
.a0ae	38		sec		          SEC
.a0af	20 d8 90	jsr $90d8	          JSR B_OPEN          ; OPEN LA,FA,SA,"$0:pattern"
.a0b2	90 09		bcc $a0bd	          BCC DIR_25          ; -> OK
.a0b4	48		pha		          PHA                 ; push error #
.a0b5	20 14 a1	jsr $a114	          JSR DIR_55          ; close channel 0
.a0b8	68		pla		          PLA                 ; pull error #
.a0b9	aa		tax		          TAX                 ; X  = error #
.a0ba	4c 3c 4d	jmp $4d3c	          JMP Print_Error_X   ; error exit
.a0bd	a2 00		ldx #$00	DIR_25    LDX #0              ; select channel 0
.a0bf	20 45 a8	jsr $a845	          JSR Map_IO
.a0c2	20 c6 ff	jsr $ffc6	          JSR K_CHKIN
.a0c5	a0 03		ldy #$03	          LDY #3              ; read load address, link & number
.a0c7	8c 74 11	sty $1174	DIR_30    STY T3              ; words to read
.a0ca	20 63 92	jsr $9263	DIR_35    JSR B_BASIN
.a0cd	8d 75 11	sta $1175	          STA T4              ; word low
.a0d0	20 51 92	jsr $9251	          JSR B_READST        ; check status
.a0d3	d0 3f		bne $a114	          BNE DIR_55
.a0d5	20 63 92	jsr $9263	          JSR B_BASIN
.a0d8	8d 76 11	sta $1176	          STA T5              ; word high
.a0db	20 51 92	jsr $9251	          JSR B_READST        ; check status
.a0de	d0 34		bne $a114	          BNE DIR_55
.a0e0	ce 74 11	dec $1174	          DEC T3              ; word count
.a0e3	d0 e5		bne $a0ca	          BNE DIR_35          ; -> ignore this word and loop
.a0e5	ae 75 11	ldx $1175	          LDX T4              ; blocks low
.a0e8	ad 76 11	lda $1176	          LDA T5              ; blocks high
.a0eb	20 32 8e	jsr $8e32	          JSR Print_Integer_XA; print blocks
.a0ee	a9 20		lda #$20	          LDA #' '            ; print blank
.a0f0	20 69 92	jsr $9269	          JSR B_BSOUT
.a0f3	20 63 92	jsr $9263	DIR_40    JSR B_BASIN         ; next char of directory
.a0f6	48		pha		          PHA                 ; push received byte
.a0f7	20 51 92	jsr $9251	          JSR B_READST        ; status OK ?
.a0fa	d0 17		bne $a113	          BNE DIR_50          ; no -> finish
.a0fc	68		pla		          PLA                 ; restore received byte
.a0fd	f0 06		beq $a105	          BEQ DIR_45          ; -> end of line
.a0ff	20 69 92	jsr $9269	          JSR B_BSOUT         ; print char
.a102	4c f3 a0	jmp $a0f3	          JMP DIR_40          ; loop
.a105	a9 0d		lda #$0d	DIR_45    LDA #13             ; print return
.a107	20 69 92	jsr $9269	          JSR B_BSOUT
.a10a	20 93 92	jsr $9293	          JSR B_STOP          ; check STOP key
.a10d	f0 05		beq $a114	          BEQ DIR_55          ; -> exit on STOP
.a10f	a0 02		ldy #$02	          LDY #2              ; Y = words to read (link & number)
.a111	d0 b4		bne $a0c7	          BNE DIR_30          ; branch always
.a113	68		pla		DIR_50    PLA
.a114	20 6f 92	jsr $926f	DIR_55    JSR B_CLRCH         ; clear channel
.a117	a9 00		lda #$00	          LDA #0
.a119	18		clc		          CLC
.a11a	4c 75 92	jmp $9275	          JMP B_CLOSE         ; close directory file
.a11d					  BASIC_DOPEN
.a11d	a9 22		lda #$22	          LDA #%00100010     ; inhibit second drive and filename
.a11f	20 c1 a3	jsr $a3c1	          JSR DOS_Parser_A
.a122	20 6f a7	jsr $a76f	          JSR Require_LA_Filename
.a125	20 57 a1	jsr $a157	          JSR Find_Free_SA
.a128	a0 05		ldy #$05	          LDY #Pat_DOPEN - Pat_DCLEAR - 1 ; start of command
.a12a	a2 04		ldx #$04	          LDX #4              ; length of OPEN command
.a12c	24 80		bit $80		          BIT DOSFLA          ; test DOS flags
.a12e	50 13		bvc $a143	          BVC APPE_10         ; -> No WRITE or REL flag
.a130	a2 08		ldx #$08	          LDX #8              ; length of OPEN command
.a132	d0 0f		bne $a143	          BNE APPE_10         ; always
.a134					  BASIC_APPEND
.a134	a9 e2		lda #$e2	          LDA #%11100010     ; accept LA,Drive,Unit,File
.a136	20 c1 a3	jsr $a3c1	          JSR DOS_Parser_A
.a139	20 6f a7	jsr $a76f	          JSR Require_LA_Filename
.a13c	20 57 a1	jsr $a157	          JSR Find_Free_SA
.a13f	a0 16		ldy #$16	          LDY #Pat_APPEND - Pat_DCLEAR - 1
.a141	a2 05		ldx #$05	          LDX #$05 ;#?Pat_APPEND
.a143	8a		txa		APPE_10   TXA
.a144	20 67 a6	jsr $a667	          JSR Build_DOS_Command
.a147	20 6f 92	jsr $926f	          JSR B_CLRCH
.a14a	a9 00		lda #$00	          LDA #0
.a14c	aa		tax		          TAX
.a14d	20 87 92	jsr $9287	          JSR B_SETBNK
.a150	20 d8 90	jsr $90d8	          JSR B_OPEN
.a153	ea		nop		          NOP
.a154	4c b2 a3	jmp $a3b2	          JMP PDC_20
.a157					  Find_Free_SA
.a157	a0 61		ldy #$61	          LDY #$61            ; try SA from $62 to $6e
.a159	c8		iny		FFSA_10   INY                 ; address 2 - 14
.a15a	c0 6f		cpy #$6f	          CPY #$6f
.a15c	f0 0c		beq $a16a	          BEQ FFSA_Err
.a15e	20 45 a8	jsr $a845	          JSR Map_IO
.a161	20 5c ff	jsr $ff5c	          JSR K_LKUPSA        ; look up SA
.a164	90 f3		bcc $a159	          BCC FFSA_10         ; -> already in use
.a166	8c 1d 01	sty $011d	          STY DOS_SA          ; use this one
.a169	60		rts		          RTS
.a16a	a2 01		ldx #$01	FFSA_Err  LDX #1              ; TOO MANY FILES
.a16c	4c 3c 4d	jmp $4d3c	          JMP Print_Error_X
.a16f					  BASIC_DCLOSE
.a16f	a9 f3		lda #$f3	          LDA #%11110011     ; allow only LA and Unit
.a171	20 c1 a3	jsr $a3c1	          JSR DOS_Parser_A
.a174	20 0d a8	jsr $a80d	          JSR Free_DOS_Status_String
.a177	a5 80		lda $80		          LDA DOSFLA
.a179	29 04		and #$04	          AND #%00000100     ; test LA bit
.a17b	f0 06		beq $a183	          BEQ B_CLOALL          ; -> no LA: close all
.a17d	ad 1b 01	lda $011b	          LDA DOS_LA
.a180	4c 75 92	jmp $9275	          JMP B_CLOSE
.a183					  B_CLOALL
.a183	ad 1c 01	lda $011c	          LDA DOS_FA
.a186	20 45 a8	jsr $a845	          JSR Map_IO
.a189	4c 4a ff	jmp $ff4a	          JMP K_CLOALL
.a18c					  BASIC_DSAVE
.a18c	a9 66		lda #$66	          LDA #$66
.a18e	20 c1 a3	jsr $a3c1	          JSR DOS_Parser_A
.a191	20 50 a7	jsr $a750	          JSR Assert_Filename
.a194	a0 05		ldy #$05	          LDY #Pat_DOPEN - Pat_DCLEAR  - 1
.a196	a9 04		lda #$04	          LDA #4              ; command length
.a198	20 67 a6	jsr $a667	          JSR Build_DOS_Command
.a19b	a9 00		lda #$00	          LDA #0
.a19d	aa		tax		          TAX
.a19e	20 87 92	jsr $9287	          JSR B_SETBNK        ; bank 0 is default
.a1a1	4c 15 91	jmp $9115	          JMP SAVE_10
.a1a4					  BASIC_DVERIFY
.a1a4	a9 01		lda #$01	          LDA #1              ; set verify flag
>a1a6	2c				          .BYTE $2C ;BIT                 ; skip next statement
.a1a7					  BASIC_DLOAD
.a1a7	a9 00		lda #$00	          LDA #0
.a1a9	85 0c		sta $0c		          STA B_VERCK
.a1ab	a9 e6		lda #$e6	          LDA #$e6
.a1ad	20 c1 a3	jsr $a3c1	          JSR DOS_Parser_A
.a1b0	20 50 a7	jsr $a750	          JSR Assert_Filename
.a1b3	a9 00		lda #$00	          LDA #0
.a1b5	8d 1d 01	sta $011d	          STA DOS_SA
.a1b8	a0 05		ldy #$05	          LDY #Pat_DOPEN - Pat_DCLEAR  - 1
.a1ba	a9 04		lda #$04	          LDA #4              ; command length
.a1bc	20 67 a6	jsr $a667	          JSR Build_DOS_Command
.a1bf	a9 00		lda #$00	          LDA #0              ; bank for loading
.a1c1	aa		tax		          TAX                 ; bank for filename
.a1c2	20 87 92	jsr $9287	          JSR B_SETBNK
.a1c5	4c 33 91	jmp $9133	          JMP LOAD_Parameter_Set
.a1c8					  BASIC_BSAVE
.a1c8	a9 66		lda #$66	          LDA #$66
.a1ca	a2 f8		ldx #$f8	          LDX #$f8
.a1cc	20 c3 a3	jsr $a3c3	          JSR DOS_Parser_AX
.a1cf	20 50 a7	jsr $a750	          JSR Assert_Filename
.a1d2	a5 81		lda $81		          LDA DOSFLB
.a1d4	29 06		and #$06	          AND #6
.a1d6	c9 06		cmp #$06	          CMP #6
.a1d8	f0 03		beq $a1dd	          BEQ BSAV_10         ; -> all parameter set
.a1da	4c 6c 79	jmp $796c	          JMP SYNTAX_ERROR
.a1dd	ad 1a 01	lda $011a	BSAV_10   LDA DOS_END+1
.a1e0	cd 18 01	cmp $0118	          CMP DOS_BEG+1
.a1e3	90 30		bcc $a215	          BCC BSAV_Err
.a1e5	d0 0a		bne $a1f1	          BNE BSAV_20
.a1e7	ad 19 01	lda $0119	          LDA DOS_END
.a1ea	cd 17 01	cmp $0117	          CMP DOS_BEG
.a1ed	90 26		bcc $a215	          BCC BSAV_Err
.a1ef	f0 24		beq $a215	          BEQ BSAV_Err
.a1f1	a0 05		ldy #$05	BSAV_20   LDY #5
.a1f3	a9 04		lda #$04	          LDA #4
.a1f5	20 67 a6	jsr $a667	          JSR Build_DOS_Command
.a1f8	ad 1f 01	lda $011f	          LDA DOS_BANK
.a1fb	a2 00		ldx #$00	          LDX #0
.a1fd	20 87 92	jsr $9287	          JSR B_SETBNK
.a200	ae 17 01	ldx $0117	          LDX DOS_BEG
.a203	ac 18 01	ldy $0118	          LDY DOS_BEG+1
.a206	a9 5a		lda #$5a	          LDA #ARYPNT         ; address of save address
.a208	86 5a		stx $5a		          STX ARYPNT
.a20a	84 5b		sty $5b		          STY ARYPNT+1
.a20c	ae 19 01	ldx $0119	          LDX DOS_END
.a20f	ac 1a 01	ldy $011a	          LDY DOS_END+1
.a212	4c 1d 91	jmp $911d	          JMP SAVE_20
.a215	4c 28 7d	jmp $7d28	BSAV_Err  JMP Error_Illegal_Quantity
>a218					          .FILL $a218-* ,0
.a218					  BASIC_BLOAD
.a218	a9 e6		lda #$e6	          LDA #$e6            ; DOS flags
.a21a	a2 fc		ldx #$fc	          LDX #$fc            ; DOS flags
.a21c	20 c3 a3	jsr $a3c3	          JSR DOS_Parser_AX
.a21f					  BLOAD
.a21f	20 50 a7	jsr $a750	          JSR Assert_Filename
.a222	ae 17 01	ldx $0117	          LDX DOS_BEG
.a225	ac 18 01	ldy $0118	          LDY DOS_BEG+1
.a228	a9 00		lda #$00	          LDA #0
.a22a	e0 ff		cpx #$ff	          CPX #$ff
.a22c	d0 06		bne $a234	          BNE BLOAD_10
.a22e	c0 ff		cpy #$ff	          CPY #$ff
.a230	d0 02		bne $a234	          BNE BLOAD_10
.a232	a9 ff		lda #$ff	          LDA #$ff
.a234	8d 1d 01	sta $011d	BLOAD_10  STA DOS_SA
.a237	a0 05		ldy #$05	          LDY #Pat_DOPEN - Pat_DCLEAR  - 1
.a239	a9 04		lda #$04	          LDA #4              ; command length
.a23b	20 67 a6	jsr $a667	          JSR Build_DOS_Command
.a23e	ad 1f 01	lda $011f	          LDA DOS_BANK        ; bank for loading
.a241	a2 00		ldx #$00	          LDX #0              ; bank for filename
.a243	20 87 92	jsr $9287	          JSR B_SETBNK
.a246	a9 00		lda #$00	          LDA #0
.a248	ae 17 01	ldx $0117	          LDX DOS_BEG
.a24b	ac 18 01	ldy $0118	          LDY DOS_BEG+1
.a24e	20 d5 ff	jsr $ffd5	          JSR K_LOADSP
.a251	08		php		          PHP
.a252	20 43 92	jsr $9243	          JSR Invalidate_Disk_Status
.a255	28		plp		          PLP
.a256	90 03		bcc $a25b	          BCC BLOAD_20
.a258	4c d0 90	jmp $90d0	          JMP Break_On_Error
.a25b	20 51 92	jsr $9251	BLOAD_20  JSR B_READST
.a25e	29 bf		and #$bf	          AND #%10111111 ; $bf
.a260	f0 03		beq $a265	          BEQ BLOAD_30
.a262	4c 67 91	jmp $9167	          JMP LPS_Err
.a265	18		clc		BLOAD_30  CLC
.a266	60		rts		          RTS
.a267					  BASIC_HEADER
.a267	20 bf a3	jsr $a3bf	          JSR DOS_Parser
.a26a	20 49 a7	jsr $a749	          JSR Need_Name
.a26d	29 01		and #$01	          AND #1
.a26f	c9 01		cmp #$01	          CMP #1
.a271	d0 61		bne $a2d4	          BNE SCRA_40
.a273	20 7b 92	jsr $927b	          JSR B_CLALL
.a276	20 e1 a7	jsr $a7e1	          JSR ARE_YOU_SURE
.a279	d0 25		bne $a2a0	          BNE HEAD_Ret
.a27b	a0 1b		ldy #$1b	          LDY #Pat_HEADER - Pat_DCLEAR - 1 ;$a643 - $a627 -1 = $1b
.a27d	a9 04		lda #$04	          LDA #$04 ;#?Pat_HEADER - 2 ; no ID ;$a643 - 2
.a27f	ae 20 01	ldx $0120	          LDX DOS_ID
.a282	f0 02		beq $a286	          BEQ HEAD_10
.a284	a9 06		lda #$06	          LDA #$06 ;#?Pat_HEADER ;$a627 ? = high byte lower nibble $address &0f00 >> 8
.a286	20 97 a3	jsr $a397	HEAD_10   JSR Put_DOS_Command
.a289	20 78 a7	jsr $a778	          JSR Update_DS
.a28c	24 7f		bit $7f		          BIT RUNMOD
.a28e	30 10		bmi $a2a0	          BMI HEAD_Ret
.a290	a0 00		ldy #$00	          LDY #0
.a292	a9 7b		lda #$7b	          LDA #DS_ADR
.a294	20 ab 03	jsr $03ab	          JSR Fetch_1
.a297	c9 32		cmp #$32	          CMP #'2'
.a299	90 05		bcc $a2a0	          BCC HEAD_Ret
.a29b	a2 24		ldx #$24	          LDX #$24            ; BAD DISK
.a29d	4c 3c 4d	jmp $4d3c	          JMP Print_Error_X
.a2a0	60		rts		HEAD_Ret  RTS
.a2a1					  BASIC_SCRATCH
.a2a1	20 bf a3	jsr $a3bf	          JSR DOS_Parser
.a2a4	20 49 a7	jsr $a749	          JSR Need_Name
.a2a7	20 e1 a7	jsr $a7e1	          JSR ARE_YOU_SURE
.a2aa	d0 27		bne $a2d3	          BNE SCRA_30
.a2ac	a0 37		ldy #$37	          LDY #Pat_SCRATCH - Pat_DCLEAR - 1
.a2ae	a9 04		lda #$04	          LDA #$04 ;#?Pat_SCRATCH
.a2b0	20 97 a3	jsr $a397	          JSR Put_DOS_Command
.a2b3	20 78 a7	jsr $a778	          JSR Update_DS
.a2b6	24 7f		bit $7f		          BIT RUNMOD
.a2b8	30 19		bmi $a2d3	          BMI SCRA_30
.a2ba	a9 0d		lda #$0d	          LDA #13
.a2bc	20 69 92	jsr $9269	          JSR B_BSOUT
.a2bf	a0 00		ldy #$00	          LDY #0
.a2c1	a9 7b		lda #$7b	SCRA_10   LDA #DS_ADR         ; print disk status
.a2c3	20 ab 03	jsr $03ab	          JSR Fetch_1
.a2c6	f0 06		beq $a2ce	          BEQ SCRA_20
.a2c8	20 69 92	jsr $9269	          JSR B_BSOUT
.a2cb	c8		iny		          INY
.a2cc	d0 f3		bne $a2c1	          BNE SCRA_10
.a2ce	a9 0d		lda #$0d	SCRA_20   LDA #13
.a2d0	20 df 90	jsr $90df	          JSR CHROUT
.a2d3	60		rts		SCRA_30   RTS
.a2d4	4c 6c 79	jmp $796c	SCRA_40   JMP SYNTAX_ERROR
.a2d7					  BASIC_RECORD
.a2d7	a9 23		lda #$23	          LDA #'#'
.a2d9	20 5e 79	jsr $795e	          JSR Need_A
.a2dc	20 f4 87	jsr $87f4	          JSR Get_Byte_Var
.a2df	e0 00		cpx #$00	          CPX #0
.a2e1	f0 37		beq $a31a	          BEQ REC1_Err        ; LA # must be > 0
.a2e3	8e 1b 01	stx $011b	          STX DOS_LA
.a2e6	20 0f 88	jsr $880f	          JSR Comma_And_LINNUM; get record #
.a2e9	a2 01		ldx #$01	          LDX #1              ; default  position in record
.a2eb	20 1e 9e	jsr $9e1e	          JSR Get_Byte_Or_Void; optional position in record
.a2ee	e0 00		cpx #$00	          CPX #0
.a2f0	f0 28		beq $a31a	          BEQ REC1_Err        ; position must be > 0
.a2f2	e0 ff		cpx #$ff	          CPX #$ff
.a2f4	f0 24		beq $a31a	          BEQ REC1_Err        ; position must be < 255
.a2f6	8e 1e 01	stx $011e	          STX DOS_RL          ; position
.a2f9	ad 1b 01	lda $011b	          LDA DOS_LA
.a2fc	20 45 a8	jsr $a845	          JSR Map_IO
.a2ff	20 59 ff	jsr $ff59	          JSR K_LKUPLA        ; lookup FA,SA
.a302	b0 19		bcs $a31d	          BCS REC4_Err
.a304	8c ed 11	sty $11ed	          STY REC_SA
.a307	8e 1c 01	stx $011c	          STX DOS_FA
.a30a	a9 00		lda #$00	          LDA #0              ; setup command channel
.a30c	8d 1b 01	sta $011b	          STA DOS_LA
.a30f	a9 6f		lda #$6f	          LDA #$6f
.a311	8d 1d 01	sta $011d	          STA DOS_SA
.a314	a0 3b		ldy #$3b	          LDY #Pat_RECORD - Pat_DCLEAR - 1
.a316	a9 04		lda #$04	          LDA #$04 ;#?Pat_RECORD
.a318	d0 7d		bne $a397	          BNE Put_DOS_Command
.a31a	4c 28 7d	jmp $7d28	REC1_Err  JMP Error_Illegal_Quantity
.a31d	a2 04		ldx #$04	REC4_Err  LDX #4              ; FILE NOT FOUND
.a31f	4c 3c 4d	jmp $4d3c	          JMP Print_Error_X
.a322					  BASIC_DCLEAR
.a322	20 bf a3	jsr $a3bf	          JSR DOS_Parser
.a325	a0 ff		ldy #$ff	          LDY #$ff
.a327	a9 02		lda #$02	          LDA #2
.a329	20 97 a3	jsr $a397	          JSR Put_DOS_Command
.a32c	4c 83 a1	jmp $a183	          JMP B_CLOALL
.a32f					  BASIC_COLLECT
.a32f	20 bf a3	jsr $a3bf	          JSR DOS_Parser
.a332	20 5b a7	jsr $a75b	          JSR Unit_And_Drive_Only
.a335	20 7b 92	jsr $927b	          JSR B_CLALL
.a338	a0 21		ldy #$21	          LDY #Pat_COLLECT - Pat_DCLEAR - 1
.a33a	a2 01		ldx #$01	          LDX #1              ; collect with no drive
.a33c	a5 80		lda $80		          LDA DOSFLA
.a33e	29 10		and #$10	          AND #%00010000     ; drive ?
.a340	f0 01		beq $a343	          BEQ COLLE_10        ; -> no
.a342	e8		inx		          INX                 ; collect with drive
.a343	8a		txa		COLLE_10  TXA
.a344	d0 51		bne $a397	          BNE Put_DOS_Command ; always
.a346					  BASIC_COPY
.a346	20 bf a3	jsr $a3bf	          JSR DOS_Parser
.a349	29 30		and #$30	          AND #%00110000   ; source & target drive
.a34b	c9 30		cmp #$30	          CMP #%00110000
.a34d	d0 06		bne $a355	          BNE COPY_10
.a34f	a5 80		lda $80		          LDA DOSFLA        ; source and target drive set
.a351	29 c7		and #$c7	          AND #%11000111   ; @ W LA FN1 FN2
.a353	f0 07		beq $a35c	          BEQ COPY_20       ; -> copy *
.a355	a5 80		lda $80		COPY_10   LDA DOSFLA
.a357	20 60 a7	jsr $a760	          JSR Deny_AT_W_LA
.a35a	a5 80		lda $80		          LDA DOSFLA        ; obsolete
.a35c	a0 27		ldy #$27	COPY_20   LDY #Pat_COPY - Pat_DCLEAR - 1
.a35e	a9 08		lda #$08	          LDA #$08 ;#?Pat_COPY    ; command length
.a360	d0 35		bne $a397	          BNE Put_DOS_Command
.a362					  BASIC_CONCAT
.a362	20 bf a3	jsr $a3bf	          JSR DOS_Parser
.a365	20 60 a7	jsr $a760	          JSR Deny_AT_W_LA
.a368	a0 0d		ldy #$0d	          LDY #Pat_CONCAT - Pat_DCLEAR - 1
.a36a	a9 0c		lda #$0c	          LDA #12             ; overlap with APPEND
.a36c	d0 29		bne $a397	          BNE Put_DOS_Command
.a36e					  BASIC_RENAME
.a36e	a9 e4		lda #$e4	          LDA #$e4
.a370	20 c1 a3	jsr $a3c1	          JSR DOS_Parser_A
.a373	20 66 a7	jsr $a766	          JSR Require_Two_Filenames
.a376	a0 2f		ldy #$2f	          LDY #Pat_RENAME - Pat_DCLEAR  - 1
.a378	a9 08		lda #$08	          LDA #$08 ;#?Pat_RENAME
.a37a	d0 1b		bne $a397	          BNE Put_DOS_Command
.a37c					  BASIC_BACKUP
.a37c	a9 c7		lda #$c7	          LDA #$c7
.a37e	20 c1 a3	jsr $a3c1	          JSR DOS_Parser_A
.a381	29 30		and #$30	          AND #%00110000     ; source & target drive
.a383	c9 30		cmp #$30	          CMP #%00110000
.a385	f0 03		beq $a38a	          BEQ BACK_10
.a387	4c 6c 79	jmp $796c	          JMP SYNTAX_ERROR
.a38a	20 e1 a7	jsr $a7e1	BACK_10   JSR ARE_YOU_SURE
.a38d	f0 01		beq $a390	          BEQ BACK_20
.a38f	60		rts		          RTS
.a390	20 83 a1	jsr $a183	BACK_20   JSR B_CLOALL
.a393	a0 23		ldy #$23	          LDY #$23 ; '#'
.a395	a9 04		lda #$04	          LDA #4
.a397					  Put_DOS_Command
.a397	20 67 a6	jsr $a667	          JSR Build_DOS_Command
.a39a	20 6f 92	jsr $926f	PDC_10    JSR B_CLRCH
.a39d	a9 00		lda #$00	          LDA #0
.a39f	aa		tax		          TAX
.a3a0	20 87 92	jsr $9287	          JSR B_SETBNK
.a3a3	38		sec		          SEC
.a3a4	20 d8 90	jsr $90d8	          JSR B_OPEN
.a3a7	08		php		          PHP
.a3a8	48		pha		          PHA
.a3a9	ad 1b 01	lda $011b	          LDA DOS_LA
.a3ac	38		sec		          SEC
.a3ad	20 75 92	jsr $9275	          JSR B_CLOSE
.a3b0	68		pla		          PLA
.a3b1	28		plp		          PLP
.a3b2	b0 01		bcs $a3b5	PDC_20    BCS PDC_Err
.a3b4	60		rts		          RTS
.a3b5	4c d0 90	jmp $90d0	PDC_Err   JMP Break_On_Error
>a3b8	ff				dostbl     .BYTE $ff
>a3b9	ff				           .BYTE $ff
>a3ba	ff				           .BYTE $ff
>a3bb	ff				           .BYTE $ff
>a3bc	00				           .BYTE $00          ; default LA
>a3bd	08				           .BYTE $08          ; default FA
>a3be	6f				           .BYTE $6f          ; default SA
.a3bf					  DOS_Parser
.a3bf	a9 00		lda #$00	           LDA #0             ; disabled flags
.a3c1					  DOS_Parser_A
.a3c1	a2 ff		ldx #$ff	           LDX #$ff           ; enabled flags
.a3c3					  DOS_Parser_AX
.a3c3	48		pha		           PHA
.a3c4	8a		txa		           TXA
.a3c5	48		pha		           PHA
.a3c6	a9 00		lda #$00	           LDA #0
.a3c8	85 80		sta $80		           STA DOSFLA
.a3ca	85 81		sta $81		           STA DOSFLB
.a3cc	a2 22		ldx #$22	           LDX #$22
.a3ce	9d 00 01	sta $0100,x	DOSP_10    STA STACK,X        ; clear $0101 to $0122
.a3d1	ca		dex		           DEX
.a3d2	d0 fa		bne $a3ce	           BNE DOSP_10
.a3d4	a2 06		ldx #$06	           LDX #6
.a3d6	bd b8 a3	lda $a3b8,x	DOSP_12    LDA dostbl,X
.a3d9	9d 17 01	sta $0117,x	           STA DOS_BEG,X  ; set default values
.a3dc	ca		dex		           DEX
.a3dd	10 f7		bpl $a3d6	           BPL DOSP_12
.a3df	ae d5 03	ldx $03d5	           LDX USER_BANK
.a3e2	8e 1f 01	stx $011f	           STX DOS_BANK       ; set bank
.a3e5	20 86 03	jsr $0386	           JSR CHRGOT
.a3e8	d0 0e		bne $a3f8	DOSP_13    BNE DOSP_16
.a3ea	68		pla		DOSP_14    PLA                ; exit sequence
.a3eb	25 81		and $81		           AND DOSFLB         ; check forbidden parameter
.a3ed	d0 6b		bne $a45a	           BNE DOSP_Syn
.a3ef	68		pla		           PLA
.a3f0	20 1d a6	jsr $a61d	           JSR Assert_DOSFLA  ; check required parameter
.a3f3	a5 80		lda $80		           LDA DOSFLA
.a3f5	a6 81		ldx $81		           LDX DOSFLB
.a3f7	60		rts		           RTS
.a3f8	c9 23		cmp #$23	DOSP_16    CMP #'#'           ; logical address ?
.a3fa	f0 4b		beq $a447	           BEQ DOSP_32
.a3fc	c9 57		cmp #$57	           CMP #'W'           ; write mode ?
.a3fe	f0 5d		beq $a45d	           BEQ DOSP_36
.a400	c9 4c		cmp #$4c	           CMP #'L'           ; relative file ?
.a402	f0 59		beq $a45d	           BEQ DOSP_36
.a404	c9 52		cmp #$52	           CMP #'R'           ; read mode ?
.a406	f0 29		beq $a431	           BEQ DOSP_22
.a408	c9 44		cmp #$44	           CMP #'D'           ; Drive ?
.a40a	f0 73		beq $a47f	           BEQ DOSP_42
.a40c	c9 91		cmp #$91	           CMP #$91           ; ON token
.a40e	f0 27		beq $a437	           BEQ DOSP_24
.a410	c9 42		cmp #$42	           CMP #'B'           ; Bank
.a412	f0 2e		beq $a442	           BEQ DOSP_30
.a414	c9 55		cmp #$55	           CMP #'U'           ; Unit ?
.a416	f0 25		beq $a43d	           BEQ DOSP_28
.a418	c9 50		cmp #$50	           CMP #'P'           ; Position ?
.a41a	d0 03		bne $a41f	           BNE DOSP_18
.a41c	4c b4 a4	jmp $a4b4	           JMP DOSP_50
.a41f	c9 49		cmp #$49	DOSP_18    CMP #'I'           ; ID parameter on HEADER ?
.a421	f0 75		beq $a498	           BEQ DOSP_48
.a423	c9 22		cmp #$22	           CMP #QUOTE
.a425	f0 07		beq $a42e	           BEQ DOSP_20        ; -> start reading filename 1
.a427	c9 28		cmp #$28	           CMP #'('
.a429	f0 03		beq $a42e	           BEQ DOSP_20
.a42b	4c 6c 79	jmp $796c	           JMP SYNTAX_ERROR
.a42e	4c dc a4	jmp $a4dc	DOSP_20    JMP DOSP_56
.a431	20 80 03	jsr $0380	DOSP_22    JSR CHRGET
.a434	4c fb a4	jmp $a4fb	           JMP DOSP_62
.a437	20 82 a5	jsr $a582	DOSP_24    JSR Get_Bank_Or_Unit
.a43a	4c f7 a4	jmp $a4f7	DOSP_26    JMP DOSP_60
.a43d	20 8d a5	jsr $a58d	DOSP_28    JSR Get_Unit
.a440	d0 f8		bne $a43a	           BNE DOSP_26        ; branch always
.a442	20 9e a5	jsr $a59e	DOSP_30    JSR Get_Bank
.a445	f0 f3		beq $a43a	           BEQ DOSP_26
.a447	a9 04		lda #$04	DOSP_32    LDA #4             ; bit 2 = LA set
.a449	20 1d a6	jsr $a61d	           JSR Assert_DOSFLA  ; inhibit multiple settings
.a44c	20 f2 a5	jsr $a5f2	           JSR Get_DOS_Parameter_Byte
.a44f	e0 00		cpx #$00	           CPX #0
.a451	f0 42		beq $a495	           BEQ DOSP_Ill       ; ILLEGAL QUANTITY
.a453	8e 1b 01	stx $011b	           STX DOS_LA         ; set LA
.a456	a9 04		lda #$04	           LDA #4             ; flag for LA defined
.a458	d0 e0		bne $a43a	           BNE DOSP_26        ; branch always
.a45a	4c 6c 79	jmp $796c	DOSP_Syn   JMP SYNTAX_ERROR
.a45d	aa		tax		DOSP_36    TAX
.a45e	a9 40		lda #$40	           LDA #$40           ; bit 6 = WRITE flag
.a460	20 1d a6	jsr $a61d	           JSR Assert_DOSFLA
.a463	e0 57		cpx #$57	           CPX #'W'
.a465	d0 06		bne $a46d	           BNE DOSP_38        ; continue with L parameter
.a467	20 80 03	jsr $0380	           JSR CHRGET
.a46a	4c 7b a4	jmp $a47b	           JMP DOSP_40
.a46d	20 f2 a5	jsr $a5f2	DOSP_38    JSR Get_DOS_Parameter_Byte
.a470	e0 00		cpx #$00	           CPX #0
.a472	f0 21		beq $a495	           BEQ DOSP_Ill       ; record length must be > 0
.a474	e0 ff		cpx #$ff	           CPX #$ff
.a476	f0 1d		beq $a495	           BEQ DOSP_Ill       ; record length must be < 255
.a478	8e 1e 01	stx $011e	           STX DOS_RL         ; set record length
.a47b	a9 40		lda #$40	DOSP_40    LDA #$40           ; WRITE or REL flag
.a47d	d0 14		bne $a493	           BNE DOSP_44        ; branch always
.a47f	a9 10		lda #$10	DOSP_42    LDA #16            ; bit 4 = DRIVE 1 set
.a481	20 1d a6	jsr $a61d	           JSR Assert_DOSFLA
.a484	20 f2 a5	jsr $a5f2	           JSR Get_DOS_Parameter_Byte
.a487	e0 02		cpx #$02	           CPX #2             ; DRIVE must be 0 or 1 only
.a489	b0 0a		bcs $a495	           BCS DOSP_Ill
.a48b	8e 12 01	stx $0112	           STX DOS_DRIVE_1    ; source drive
.a48e	8e 14 01	stx $0114	           STX DOS_DRIVE_2    ; target drive
.a491	a9 10		lda #$10	           LDA #16            ; DRIVE flag
.a493	d0 62		bne $a4f7	DOSP_44    BNE DOSP_60        ; branch always
.a495	4c 28 7d	jmp $7d28	DOSP_Ill   JMP Error_Illegal_Quantity
.a498	ad 22 01	lda $0122	DOSP_48    LDA DOS_UNIT
.a49b	d0 bd		bne $a45a	           BNE DOSP_Syn
.a49d	20 80 03	jsr $0380	           JSR CHRGET
.a4a0	8d 20 01	sta $0120	           STA DOS_ID
.a4a3	20 80 03	jsr $0380	           JSR CHRGET
.a4a6	8d 21 01	sta $0121	           STA DOS_ID+1
.a4a9	a9 ff		lda #$ff	           LDA #$ff
.a4ab	8d 22 01	sta $0122	           STA DOS_UNIT
.a4ae	20 80 03	jsr $0380	           JSR CHRGET
.a4b1	4c fb a4	jmp $a4fb	           JMP DOSP_62
.a4b4	a9 02		lda #$02	DOSP_50    LDA #2             ; bit 1 = binary load start
.a4b6	20 22 a6	jsr $a622	           JSR Assert_DOSFLB
.a4b9	20 05 a6	jsr $a605	           JSR Get_DOS_Parameter_Word
.a4bc	8c 17 01	sty $0117	           STY DOS_BEG
.a4bf	8d 18 01	sta $0118	           STA DOS_BEG+1
.a4c2	a9 02		lda #$02	           LDA #2
.a4c4	05 81		ora $81		DOSP_52    ORA DOSFLB
.a4c6	85 81		sta $81		           STA DOSFLB
.a4c8	d0 31		bne $a4fb	           BNE DOSP_62
.a4ca	a9 04		lda #$04	DOSP_54    LDA #4             ; bit 2 = binary load end
.a4cc	20 22 a6	jsr $a622	           JSR Assert_DOSFLB
.a4cf	20 05 a6	jsr $a605	           JSR Get_DOS_Parameter_Word
.a4d2	8c 19 01	sty $0119	           STY DOS_END
.a4d5	8d 1a 01	sta $011a	           STA DOS_END+1
.a4d8	a9 04		lda #$04	           LDA #4
.a4da	d0 e8		bne $a4c4	           BNE DOSP_52        ; branch always
.a4dc	a9 01		lda #$01	DOSP_56    LDA #1             ; read 1st. filename
.a4de	20 b9 a5	jsr $a5b9	           JSR Get_DOS_Filename
.a4e1	8d 11 01	sta $0111	           STA DOS_FNLEN_1
.a4e4	a0 00		ldy #$00	           LDY #0
.a4e6	20 b7 03	jsr $03b7	DOSP_58    JSR Get_INDEXA_1   ; copy filename to DOS buffer
.a4e9	8d 03 ff	sta $ff03	           STA MMU_LCRC
.a4ec	99 b7 12	sta $12b7,y	           STA SAVRAM,Y
.a4ef	c8		iny		           INY
.a4f0	cc 11 01	cpy $0111	           CPY DOS_FNLEN_1
.a4f3	90 f1		bcc $a4e6	           BCC DOSP_58
.a4f5	a9 01		lda #$01	           LDA #1             ; set flag: filename 1
.a4f7	05 80		ora $80		DOSP_60    ORA DOSFLA
.a4f9	85 80		sta $80		           STA DOSFLA
.a4fb	20 86 03	jsr $0386	DOSP_62    JSR CHRGOT         ; next char
.a4fe	d0 19		bne $a519	           BNE DOSP_72
.a500	4c ea a3	jmp $a3ea	DOSP_64    JMP DOSP_14        ; -> check & exit
.a503	c9 91		cmp #$91	DOSP_66    CMP #$91           ; ON token
.a505	d0 03		bne $a50a	           BNE DOSP_68
.a507	4c 37 a4	jmp $a437	           JMP DOSP_24        ; Get bank or unit
.a50a	c9 a4		cmp #$a4	DOSP_68    CMP #$a4           ; TO token
.a50c	f0 02		beq $a510	           BEQ DOSP_70        ; <- obsolete
.a50e	d0 6d		bne $a57d	           BNE DOSP_88          ; branch always
.a510	20 80 03	jsr $0380	DOSP_70    JSR CHRGET
.a513	c9 50		cmp #$50	           CMP #'P'
.a515	d0 0f		bne $a526	           BNE DOSP_76
.a517	f0 b1		beq $a4ca	           BEQ DOSP_54        ; -> load start/end address
.a519	c9 2c		cmp #$2c	DOSP_72    CMP #','
.a51b	d0 e6		bne $a503	           BNE DOSP_66
.a51d	20 80 03	jsr $0380	           JSR CHRGET
.a520	4c f8 a3	jmp $a3f8	           JMP DOSP_16
.a523	20 80 03	jsr $0380	DOSP_74    JSR CHRGET
.a526	c9 44		cmp #$44	DOSP_76    CMP #'D'           ; idestination drive
.a528	f0 10		beq $a53a	           BEQ DOSP_78
.a52a	c9 91		cmp #$91	           CMP #$91           ; ON token
.a52c	f0 1f		beq $a54d	           BEQ DOSP_80
.a52e	c9 55		cmp #$55	           CMP #'U'           ; destination unit
.a530	f0 21		beq $a553	           BEQ DOSP_82
.a532	c9 22		cmp #$22	           CMP #QUOTE
.a534	f0 22		beq $a558	           BEQ DOSP_84
.a536	c9 28		cmp #$28	           CMP #'('
.a538	f0 1e		beq $a558	           BEQ DOSP_84
.a53a	a9 20		lda #$20	DOSP_78    LDA #$20           ; drive 2 flag
.a53c	20 1d a6	jsr $a61d	           JSR Assert_DOSFLA
.a53f	20 f2 a5	jsr $a5f2	           JSR Get_DOS_Parameter_Byte
.a542	e0 02		cpx #$02	           CPX #2
.a544	b0 39		bcs $a57f	           BCS DOSP_90
.a546	8e 14 01	stx $0114	           STX DOS_DRIVE_2
.a549	a9 20		lda #$20	           LDA #$20           ; drive 2 flag
.a54b	d0 1b		bne $a568	           BNE DOSP_86        ; branch always
.a54d	20 82 a5	jsr $a582	DOSP_80    JSR Get_Bank_Or_Unit
.a550	4c 68 a5	jmp $a568	           JMP DOSP_86
.a553	20 8d a5	jsr $a58d	DOSP_82    JSR Get_Unit
.a556	d0 10		bne $a568	           BNE DOSP_86
.a558	a9 02		lda #$02	DOSP_84    LDA #2             ; read 2nd. filename
.a55a	20 b9 a5	jsr $a5b9	           JSR Get_DOS_Filename
.a55d	8d 13 01	sta $0113	           STA DOS_FNLEN_2
.a560	8e 15 01	stx $0115	           STX DOS_FNADR_2
.a563	8c 16 01	sty $0116	           STY DOS_FNADR_2+1
.a566	a9 02		lda #$02	           LDA #2             ; flag 2nd. filename
.a568	05 80		ora $80		DOSP_86    ORA DOSFLA
.a56a	85 80		sta $80		           STA DOSFLA
.a56c	20 86 03	jsr $0386	           JSR CHRGOT
.a56f	f0 8f		beq $a500	           BEQ DOSP_64
.a571	c9 2c		cmp #$2c	           CMP #','
.a573	f0 ae		beq $a523	           BEQ DOSP_74
.a575	c9 91		cmp #$91	           CMP #$91           ; ON token
.a577	f0 d4		beq $a54d	           BEQ DOSP_80
.a579	c9 55		cmp #$55	           CMP #'U'
.a57b	f0 d6		beq $a553	           BEQ DOSP_82
.a57d	d0 37		bne $a5b6	DOSP_88    BNE GeBa_Err          ; SYNTAX ERROR
.a57f	4c 28 7d	jmp $7d28	DOSP_90    JMP Error_Illegal_Quantity
.a582					  Get_Bank_Or_Unit
.a582	20 80 03	jsr $0380	           JSR CHRGET
.a585					  Bank_Or_Unit
.a585	c9 42		cmp #$42	           CMP #'B'
.a587	f0 15		beq $a59e	           BEQ Get_Bank
.a589	c9 55		cmp #$55	           CMP #'U'
.a58b	d0 29		bne $a5b6	           BNE GeBa_Err
.a58d					  Get_Unit
.a58d	20 f2 a5	jsr $a5f2	           JSR Get_DOS_Parameter_Byte
.a590	e0 1f		cpx #$1f	           CPX #$1f
.a592	b0 56		bcs $a5ea	           BCS GDF_30
.a594	e0 04		cpx #$04	           CPX #4
.a596	90 52		bcc $a5ea	           BCC GDF_30
.a598	8e 1c 01	stx $011c	           STX DOS_FA
.a59b	a9 08		lda #$08	           LDA #8
.a59d	60		rts		           RTS
.a59e					  Get_Bank
.a59e	a9 01		lda #$01	           LDA #1
.a5a0	20 22 a6	jsr $a622	           JSR Assert_DOSFLB
.a5a3	20 f2 a5	jsr $a5f2	           JSR Get_DOS_Parameter_Byte
.a5a6	e0 10		cpx #$10	           CPX #16
.a5a8	b0 d5		bcs $a57f	           BCS DOSP_90
.a5aa	8e 1f 01	stx $011f	           STX DOS_BANK
.a5ad	a9 01		lda #$01	           LDA #1
.a5af	05 81		ora $81		           ORA DOSFLB
.a5b1	85 81		sta $81		           STA DOSFLB
.a5b3	a9 00		lda #$00	           LDA #0
.a5b5	60		rts		           RTS
.a5b6	4c 6c 79	jmp $796c	GeBa_Err   JMP SYNTAX_ERROR
.a5b9					  Get_DOS_Filename
.a5b9	20 1d a6	jsr $a61d	           JSR Assert_DOSFLA  ; filename set already ?
.a5bc	20 7b 87	jsr $877b	           JSR Eval_String
.a5bf	aa		tax		           TAX
.a5c0	f0 25		beq $a5e7	           BEQ GDF_20
.a5c2	a0 00		ldy #$00	           LDY #0
.a5c4	20 b7 03	jsr $03b7	           JSR Get_INDEXA_1
.a5c7	c9 40		cmp #$40	           CMP #'@'           ; replace symbol
.a5c9	d0 12		bne $a5dd	           BNE GDF_10
.a5cb	a9 80		lda #$80	           LDA #$80
.a5cd	20 1d a6	jsr $a61d	           JSR Assert_DOSFLA  ; check replace flag
.a5d0	a5 80		lda $80		           LDA DOSFLA
.a5d2	09 80		ora #$80	           ORA #%10000000    ; set replace flag
.a5d4	85 80		sta $80		           STA DOSFLA
.a5d6	ca		dex		           DEX
.a5d7	e6 24		inc $24		           INC INDEXA         ; skip repplace char
.a5d9	d0 02		bne $a5dd	           BNE GDF_10
.a5db	e6 25		inc $25		           INC INDEXA+1
.a5dd	8a		txa		GDF_10     TXA
.a5de	c9 11		cmp #$11	           CMP #$11
.a5e0	b0 0b		bcs $a5ed	           BCS String_Too_Long
.a5e2	a6 24		ldx $24		           LDX INDEXA
.a5e4	a4 25		ldy $25		           LDY INDEXA+1
.a5e6	60		rts		           RTS
.a5e7	a2 08		ldx #$08	GDF_20     LDX #8             ; MISSING FILE NAME
>a5e9	2c				           .BYTE $2C ;BIT
.a5ea	a2 09		ldx #$09	GDF_30     LDX #9             ; ILLEGAL DEVICE NUMBER
>a5ec	2c				           .BYTE $2C ;BIT
.a5ed					  String_Too_Long
.a5ed	a2 17		ldx #$17	           LDX #$17
.a5ef	4c 3c 4d	jmp $4d3c	           JMP Print_Error_X
.a5f2					  Get_DOS_Parameter_Byte
.a5f2	20 80 03	jsr $0380	           JSR CHRGET
.a5f5	f0 bf		beq $a5b6	           BEQ GeBa_Err
.a5f7	90 09		bcc $a602	           BCC GDPB_10
.a5f9	20 59 79	jsr $7959	           JSR Need_Left_Par
.a5fc	20 f4 87	jsr $87f4	           JSR Get_Byte_Var
.a5ff	4c 56 79	jmp $7956	           JMP Need_Right_Par
.a602	4c f4 87	jmp $87f4	GDPB_10    JMP Get_Byte_Var
.a605					  Get_DOS_Parameter_Word
.a605	20 80 03	jsr $0380	           JSR CHRGET
.a608	f0 ac		beq $a5b6	           BEQ GeBa_Err
.a60a	90 0e		bcc $a61a	           BCC GDPW_10
.a60c	20 59 79	jsr $7959	           JSR Need_Left_Par
.a60f	20 12 88	jsr $8812	           JSR Get_Integer
.a612	20 56 79	jsr $7956	           JSR Need_Right_Par
.a615	a4 16		ldy $16		           LDY LINNUM
.a617	a5 17		lda $17		           LDA LINNUM+1
.a619	60		rts		           RTS
.a61a	4c 12 88	jmp $8812	GDPW_10    JMP Get_Integer
.a61d					  Assert_DOSFLA
.a61d	25 80		and $80		           AND DOSFLA
.a61f	d0 95		bne $a5b6	           BNE GeBa_Err
.a621	60		rts		           RTS
.a622					  Assert_DOSFLB
.a622	25 81		and $81		           AND DOSFLB
.a624	d0 90		bne $a5b6	           BNE GeBa_Err
.a626	60		rts		           RTS
.a627					  Pat_DCLEAR
>a627	49 d1				          .BYTE 'I',$d1       ; INITIALIZE drive
.a629					  Pat_DIRECTORY
>a629	24 d1 3a f1			          .BYTE '$',$d1,':',$f1 ; $ drive : filename
.a62d					  Pat_DOPEN
>a62d	f0 d1 3a f1 2c e1 2c e0		          .BYTE $f0,$d1,':',$f1,',',$e1,',',$e0
.a635					  Pat_CONCAT
>a635	43 d2 3a f2 3d d2 3a f2		          .BYTE 'C',$d2,':',$f2,'=',$d2,':',$f2,','
>a63d	2c
.a63e					  Pat_APPEND
>a63e	d1 3a f1 2c 41			          .TEXT $d1,':',$f1,",A"
.a643					  Pat_HEADER
>a643	4e d1 3a f1 2c d0		          .BYTE 'N',$d1,':',$f1,',',$d0
.a649					  Pat_COLLECT
>a649	56 d1				          .BYTE 'V',$d1
.a64b					  Pat_BACKUP
>a64b	44 d2 3d d1			          .BYTE 'D',$d2,'=',$d1
.a64f					  Pat_COPY
>a64f	43 d2 3a f2 3d d1 3a f1		          .BYTE 'C',$d2,':',$f2,'=',$d1,':',$f1
.a657					  Pat_RENAME
>a657	52 d1 3a f2 3d d1 3a f1		          .BYTE 'R',$d1,':',$f2,'=',$d1,':',$f1
.a65f					  Pat_SCRATCH
>a65f	53 d1 3a f1			          .BYTE 'S',$d1,':',$f1
.a663					  Pat_RECORD
>a663	50 c2 e2 e0			          .BYTE 'P',$c2,$e2,$e0
.a667					  Build_DOS_Command
.a667	8d 10 01	sta $0110	          STA DOS_COUNT       ; length of format string
.a66a	98		tya		          TYA                 ; index to start of format string
.a66b	48		pha		          PHA                 ; save index
.a66c	20 0d a8	jsr $a80d	          JSR Free_DOS_Status_String
.a66f	a2 00		ldx #$00	          LDX #0
.a671	68		pla		BDC_10    PLA                 ; restore format index
.a672	ce 10 01	dec $0110	          DEC DOS_COUNT       ; remaining format bytes
.a675	30 48		bmi $a6bf	          BMI BDC_22          ; -> done
.a677	a8		tay		          TAY
.a678	c8		iny		          INY                 ; increment index
.a679	98		tya		          TYA
.a67a	48		pha		          PHA                 ; save index
.a67b	b9 27 a6	lda $a627,y	          LDA Pat_DCLEAR,Y    ; next byte
.a67e	10 37		bpl $a6b7	          BPL BDC_18          ; -> store as is
.a680	c9 c2		cmp #$c2	          CMP #$c2            ; SA secondary address
.a682	f0 52		beq $a6d6	          BEQ BDC_24
.a684	c9 d0		cmp #$d0	          CMP #$d0            ; ID (formatting)
.a686	f0 5d		beq $a6e5	          BEQ BDC_30
.a688	c9 e2		cmp #$e2	          CMP #$e2            ; word (record number)
.a68a	f0 77		beq $a703	          BEQ BDC_36
.a68c	c9 e1		cmp #$e1	          CMP #$e1            ; L or S
.a68e	f0 61		beq $a6f1	          BEQ BDC_32
.a690	c9 f0		cmp #$f0	          CMP #$f0            ; @
.a692	f0 47		beq $a6db	          BEQ BDC_26
.a694	c9 f1		cmp #$f1	          CMP #$f1            ; filename 1
.a696	f0 75		beq $a70d	          BEQ BDC_38
.a698	c9 f2		cmp #$f2	          CMP #$f2            ; filename 2
.a69a	f0 21		beq $a6bd	          BEQ BDC_20
.a69c	c9 e0		cmp #$e0	          CMP #$e0            ; record length or 'W'
.a69e	d0 05		bne $a6a5	          BNE BDC_12
.a6a0	ad 1e 01	lda $011e	          LDA DOS_RL
.a6a3	d0 12		bne $a6b7	          BNE BDC_18
.a6a5	c9 d1		cmp #$d1	BDC_12    CMP #$d1            ; drive 1
.a6a7	d0 05		bne $a6ae	          BNE BDC_14
.a6a9	ad 12 01	lda $0112	          LDA DOS_DRIVE_1
.a6ac	10 07		bpl $a6b5	          BPL BDC_16
.a6ae	c9 d2		cmp #$d2	BDC_14    CMP #$d2            ; drive 2
.a6b0	d0 bf		bne $a671	          BNE BDC_10
.a6b2	ad 14 01	lda $0114	          LDA DOS_DRIVE_2
.a6b5	09 30		ora #$30	BDC_16    ORA #'0'            ; bin to ASCII
.a6b7	9d 00 11	sta $1100,x	BDC_18    STA DOSSTR,X
.a6ba	e8		inx		          INX
.a6bb	d0 b4		bne $a671	          BNE BDC_10          ; always
.a6bd	f0 64		beq $a723	BDC_20    BEQ BDC_42          ; always
.a6bf	8a		txa		BDC_22    TXA
.a6c0	48		pha		          PHA
.a6c1	a2 00		ldx #$00	          LDX #<DOSSTR
.a6c3	a0 11		ldy #$11	          LDY #>DOSSTR
.a6c5	20 5d 92	jsr $925d	          JSR B_SETNAM
.a6c8	ad 1b 01	lda $011b	          LDA DOS_LA
.a6cb	ae 1c 01	ldx $011c	          LDX DOS_FA
.a6ce	ac 1d 01	ldy $011d	          LDY DOS_SA
.a6d1	20 57 92	jsr $9257	          JSR B_SETLFS
.a6d4	68		pla		          PLA
.a6d5	60		rts		          RTS
.a6d6	ad ed 11	lda $11ed	BDC_24    LDA REC_SA          ; insert SA
.a6d9	d0 dc		bne $a6b7	          BNE BDC_18
.a6db	24 80		bit $80		BDC_26    BIT DOSFLA          ; insert
.a6dd	30 02		bmi $a6e1	          BMI BDC_28
.a6df	10 90		bpl $a671	          BPL BDC_10
.a6e1	a9 40		lda #$40	BDC_28    LDA #$40 ; '@'      ; insert @
.a6e3	d0 d2		bne $a6b7	          BNE BDC_18
.a6e5	ad 20 01	lda $0120	BDC_30    LDA DOS_ID          ; insert ID
.a6e8	9d 00 11	sta $1100,x	          STA DOSSTR,X
.a6eb	e8		inx		          INX
.a6ec	ad 21 01	lda $0121	          LDA DOS_ID+1
.a6ef	d0 c6		bne $a6b7	          BNE BDC_18
.a6f1	ad 1e 01	lda $011e	BDC_32    LDA DOS_RL          ; insert 'L'
.a6f4	f0 04		beq $a6fa	          BEQ BDC_34
.a6f6	a9 4c		lda #$4c	          LDA #'L'
.a6f8	d0 bd		bne $a6b7	          BNE BDC_18
.a6fa	a9 53		lda #$53	BDC_34    LDA #'S'            ; insert "S,W"
.a6fc	8d 1e 01	sta $011e	          STA DOS_RL
.a6ff	a9 57		lda #$57	          LDA #'W'
.a701	d0 b4		bne $a6b7	          BNE BDC_18
.a703	a5 16		lda $16		BDC_36    LDA LINNUM          ; insert binary word
.a705	9d 00 11	sta $1100,x	          STA DOSSTR,X
.a708	a5 17		lda $17		          LDA LINNUM+1
.a70a	e8		inx		          INX
.a70b	d0 aa		bne $a6b7	          BNE BDC_18
.a70d	ac 11 01	ldy $0111	BDC_38    LDY DOS_FNLEN_1     ; insert filename 1
.a710	f0 33		beq $a745	          BEQ BDC_46
.a712	a0 00		ldy #$00	          LDY #0
.a714	b9 b7 12	lda $12b7,y	BDC_40    LDA SAVRAM,Y
.a717	9d 00 11	sta $1100,x	          STA DOSSTR,X
.a71a	e8		inx		          INX
.a71b	c8		iny		          INY
.a71c	cc 11 01	cpy $0111	          CPY DOS_FNLEN_1
.a71f	d0 f3		bne $a714	          BNE BDC_40
.a721	f0 23		beq $a746	          BEQ BDC_48
.a723	ad 15 01	lda $0115	BDC_42    LDA DOS_FNADR_2     ; insert filename 2
.a726	85 24		sta $24		          STA INDEXA
.a728	ad 16 01	lda $0116	          LDA DOS_FNADR_2+1
.a72b	85 25		sta $25		          STA INDEXA+1
.a72d	ac 13 01	ldy $0113	          LDY DOS_FNLEN_2
.a730	f0 13		beq $a745	          BEQ BDC_46
.a732	a0 00		ldy #$00	          LDY #0
.a734	20 b7 03	jsr $03b7	BDC_44    JSR Get_INDEXA_1
.a737	8d 03 ff	sta $ff03	          STA MMU_LCRC
.a73a	9d 00 11	sta $1100,x	          STA DOSSTR,X
.a73d	e8		inx		          INX
.a73e	c8		iny		          INY
.a73f	cc 13 01	cpy $0113	          CPY DOS_FNLEN_2
.a742	d0 f0		bne $a734	          BNE BDC_44
>a744	24				          .BYTE $24
.a745	ca		dex		BDC_46    DEX
.a746	4c 71 a6	jmp $a671	BDC_48    JMP BDC_10
.a749					  Need_Name
.a749	29 e6		and #$e6	          AND #%11100110 ; $e6
.a74b	f0 03		beq $a750	          BEQ Assert_Filename
.a74d	4c 6c 79	jmp $796c	NeNa_Err  JMP SYNTAX_ERROR
.a750					  Assert_Filename
.a750	a5 80		lda $80		          LDA DOSFLA
.a752	29 01		and #$01	          AND #1
.a754	c9 01		cmp #$01	          CMP #1
.a756	d0 f5		bne $a74d	          BNE NeNa_Err
.a758	a5 80		lda $80		          LDA DOSFLA
.a75a	60		rts		          RTS
.a75b					  Unit_And_Drive_Only
.a75b	29 e7		and #$e7	          AND #%11100111 ; $e7
.a75d	d0 ee		bne $a74d	          BNE NeNa_Err
.a75f	60		rts		          RTS
.a760					  Deny_AT_W_LA
.a760	29 c4		and #$c4	          AND #%11000100 ; $c4
.a762	d0 e9		bne $a74d	          BNE NeNa_Err
.a764	a5 80		lda $80		          LDA DOSFLA
.a766					  Require_Two_Filenames
.a766	29 03		and #$03	          AND #3
.a768	c9 03		cmp #$03	          CMP #3
.a76a	d0 e1		bne $a74d	          BNE NeNa_Err
.a76c	a5 80		lda $80		          LDA DOSFLA
.a76e	60		rts		          RTS
.a76f					  Require_LA_Filename
.a76f	29 05		and #$05	          AND #5
.a771	c9 05		cmp #$05	          CMP #5
.a773	d0 d8		bne $a74d	          BNE NeNa_Err
.a775	a5 80		lda $80		          LDA DOSFLA
.a777	60		rts		          RTS
.a778					  Update_DS
.a778	a5 7a		lda $7a		          LDA DS_LEN          ; Allocated ?
.a77a	d0 19		bne $a795	          BNE UpDS_10         ; -> yes
.a77c	a9 28		lda #$28	          LDA #40             ; fixed length
.a77e	85 7a		sta $7a		          STA DS_LEN
.a780	20 99 92	jsr $9299	          JSR Allocate_String_Space
.a783	86 7b		stx $7b		          STX DS_ADR
.a785	84 7c		sty $7c		          STY DS_ADR+1
.a787	a0 28		ldy #$28	          LDY #40             ; fixed length
.a789	8d 04 ff	sta $ff04	          STA MMU_LCRD
.a78c	a9 7a		lda #$7a	          LDA #<DS_LEN        ; address of descriptor low
.a78e	91 7b		sta ($7b),y	          STA (DS_ADR),Y      ; back reference low
.a790	c8		iny		          INY
.a791	a9 00		lda #$00	          LDA #>DS_LEN        ; address of descriptor high
.a793	91 7b		sta ($7b),y	          STA (DS_ADR),Y      ; back reference high
.a795	ae 1c 01	ldx $011c	UpDS_10   LDX DOS_FA          ; unit
.a798	d0 05		bne $a79f	          BNE UpDS_20         ; use defined unit
.a79a	a2 08		ldx #$08	          LDX #8              ; set default
.a79c	8e 1c 01	stx $011c	          STX DOS_FA          ; FA
.a79f	a9 00		lda #$00	UpDS_20   LDA #0              ; LA
.a7a1	a0 6f		ldy #$6f	          LDY #$6f            ; SA (command channel 15)
.a7a3	20 57 92	jsr $9257	          JSR B_SETLFS
.a7a6	a9 00		lda #$00	          LDA #0
.a7a8	20 5d 92	jsr $925d	          JSR B_SETNAM        ; no name
.a7ab	20 d8 90	jsr $90d8	          JSR B_OPEN          ; open command channel
.a7ae	a2 00		ldx #$00	          LDX #0
.a7b0	20 c6 ff	jsr $ffc6	          JSR K_CHKIN         ; select for input
.a7b3	b0 20		bcs $a7d5	          BCS UpDS_50
.a7b5	a0 ff		ldy #$ff	          LDY #$ff            ; pre increment loop
.a7b7	c8		iny		UpDS_30   INY
.a7b8	20 63 92	jsr $9263	          JSR B_BASIN         ; read from command channel
.a7bb	8d 04 ff	sta $ff04	          STA MMU_LCRD
.a7be	c9 0d		cmp #$0d	          CMP #CR             ; stop reading at CR
.a7c0	f0 06		beq $a7c8	          BEQ UpDS_40
.a7c2	91 7b		sta ($7b),y	          STA (DS_ADR),Y      ; store message
.a7c4	c0 28		cpy #$28	          CPY #40             ; maximum length
.a7c6	90 ef		bcc $a7b7	          BCC UpDS_30         ; loop
.a7c8					  UpDS_40
.a7c8	a9 00		lda #$00	          LDA #0              ; use zero instead of CR
.a7ca	91 7b		sta ($7b),y	          STA (DS_ADR),Y      ; insert string limiter
.a7cc	20 6f 92	jsr $926f	          JSR B_CLRCH         ; reset input channel
.a7cf	a9 00		lda #$00	          LDA #0
.a7d1	38		sec		          SEC
.a7d2	4c 75 92	jmp $9275	          JMP B_CLOSE         ; close channel and return
.a7d5	48		pha		UpDS_50   PHA                 ; push error code
.a7d6	20 c8 a7	jsr $a7c8	          JSR UpDS_40         ; close channel
.a7d9	20 0d a8	jsr $a80d	          JSR Free_DOS_Status_String
.a7dc	68		pla		          PLA                 ; pull error code
.a7dd	aa		tax		          TAX
.a7de	4c 3c 4d	jmp $4d3c	          JMP Print_Error_X   ; print error and exit
.a7e1					  ARE_YOU_SURE
.a7e1	24 7f		bit $7f		          BIT RUNMOD
.a7e3	30 25		bmi $a80a	          BMI AYS_30          ; reply positive while running
.a7e5	20 81 92	jsr $9281	          JSR B_PRIMM
>a7e8	41 52 45 20 59 4f 55 20		          .TEXT "ARE YOU SURE?",0
>a7f0	53 55 52 45 3f 00
.a7f6	20 6f 92	jsr $926f	          JSR B_CLRCH
.a7f9	20 63 92	jsr $9263	          JSR B_BASIN
.a7fc	48		pha		          PHA                 ; push first read char
.a7fd	c9 0d		cmp #$0d	AYS_10    CMP #CR
.a7ff	f0 05		beq $a806	          BEQ AYS_20
.a801	20 63 92	jsr $9263	          JSR B_BASIN
.a804	d0 f7		bne $a7fd	          BNE AYS_10          ; loop until CR
.a806	68		pla		AYS_20    PLA                 ; pull first char
.a807	c9 59		cmp #$59	          CMP #'Y'            ; was it 'Y' ?
.a809	60		rts		          RTS
.a80a	a9 00		lda #$00	AYS_30    LDA #0
.a80c	60		rts		          RTS
.a80d					  Free_DOS_Status_String
.a80d	98		tya		          TYA                 ; save Y
.a80e	48		pha		          PHA
.a80f	a5 7a		lda $7a		          LDA DS_LEN
.a811	f0 0d		beq $a820	          BEQ EDS_10          ; -> DS$ not allocated
.a813	a0 28		ldy #$28	          LDY #40             ; fixed length
.a815	98		tya		          TYA
.a816	8d 04 ff	sta $ff04	          STA MMU_LCRD
.a819	91 7b		sta ($7b),y	          STA (DS_ADR),Y      ; back reference low
.a81b	c8		iny		          INY
.a81c	a9 ff		lda #$ff	          LDA #$ff
.a81e	91 7b		sta ($7b),y	          STA (DS_ADR),Y      ; back reference high
.a820	a9 00		lda #$00	EDS_10    LDA #0
.a822	8d 03 ff	sta $ff03	          STA MMU_LCRC
.a825	85 7a		sta $7a		          STA DS_LEN          ; mark as free
.a827	68		pla		          PLA
.a828	a8		tay		          TAY                 ; restore Y
.a829	60		rts		EDS_Ret   RTS
.a82a					  KEYREV
>a82a	2c 30 20 59 45 4b		          .TEXT ",0 YEK"
.a830					  Print_Byte_A
.a830	aa		tax		          TAX                 ; X = low byte
.a831	98		tya		          TYA
.a832	48		pha		          PHA                 ; save Y
.a833	a9 00		lda #$00	          LDA #0              ; A = high byte
.a835	20 32 8e	jsr $8e32	          JSR Print_Integer_XA
.a838	68		pla		          PLA
.a839	a8		tay		          TAY                 ; restore Y
.a83a	60		rts		          RTS
.a83b					  To_Direct_Mode
.a83b	85 3c		sta $3c		          STA CURLIN+1        ; store current line high
.a83d	88		dey		          DEY                 ; decrement stack index
.a83e	aa		tax		          TAX                 ; X = current line high
.a83f	e8		inx		          INX                 ; ++X
.a840	d0 02		bne $a844	          BNE TDM_Ret         ; -> branch if CURLIN+1 was not $ff
.a842	86 7f		stx $7f		          STX RUNMOD          ; RUNMOD = 0 -> direct mode
.a844	60		rts		TDM_Ret   RTS
.a845					  Map_IO
.a845	48		pha		          PHA
.a846	a9 00		lda #$00	          LDA #0
.a848	8d 00 ff	sta $ff00	          STA MMU_CR          ; Map in I/O and ROM
.a84b	68		pla		          PLA
.a84c	60		rts		          RTS
.a84d					  BASIC_IRQ
.a84d	ad fd 12	lda $12fd	          LDA IRQ_ACTIVE_FLAG ; already executing IRQ ?
.a850	f0 01		beq $a853	          BEQ BIRQ_10         ; -> no  : continue
.a852	60		rts		          RTS                 ; -> yes : return
.a853	ee fd 12	inc $12fd	BIRQ_10   INC IRQ_ACTIVE_FLAG ; flag IRQ as active
.a856	a2 10		ldx #$10	          LDX #16
.a858	bd d6 11	lda $11d6,x	BIRQ_12   LDA VSH,X
.a85b	9d 00 d0	sta $d000,x	          STA VIC,X
.a85e	ca		dex		          DEX
.a85f	10 f7		bpl $a858	          BPL BIRQ_12
.a861	a0 07		ldy #$07	          LDY #7              ; sprite index
.a863	ad 15 d0	lda $d015	BIRQ_14   LDA VIC_SPR_ENA
.a866	39 b3 6c	and $6cb3,y	          AND Bit_Mask,Y
.a869	f0 38		beq $a8a3	          BEQ BIRQ_20         ; -> sprite disabled
.a86b	be d9 6d	ldx $6dd9,y	          LDX Sprite_Offset,Y ; X = index to sprite parameter
.a86e	bd 7e 11	lda $117e,x	          LDA SPRITE_DATA,X   ; A = speed
.a871	f0 30		beq $a8a3	          BEQ BIRQ_20         ; -> sprite doesn't move
.a873	9d 7f 11	sta $117f,x	          STA SPRITE_DATA+1,X ; set movement increment
.a876	98		tya		BIRQ_16   TYA                 ; sprite index
.a877	0a		asl a		          ASL A               ; * 2
.a878	a8		tay		          TAY
.a879	bd 80 11	lda $1180,x	          LDA SPRITE_DATA+2,X ; quadrant
.a87c	38		sec		          SEC
.a87d	e9 01		sbc #$01	          SBC #1              ; quadrant - 1
.a87f	e8		inx		          INX
.a880	e8		inx		          INX                 ; sprite y position
.a881	c8		iny		          INY
.a882	20 f4 a9	jsr $a9f4	          JSR Move_Sprite     ; update y position
.a885	ca		dex		          DEX
.a886	ca		dex		          DEX                 ; sprite x position
.a887	88		dey		          DEY
.a888	bd 80 11	lda $1180,x	          LDA SPRITE_DATA+2,X
.a88b	20 f4 a9	jsr $a9f4	          JSR Move_Sprite     ; update x position
.a88e	08		php		          PHP
.a88f	98		tya		          TYA
.a890	4a		lsr a		          LSR A
.a891	a8		tay		          TAY                 ; sprite index
.a892	28		plp		          PLP
.a893	90 09		bcc $a89e	          BCC BIRQ_18
.a895	ad e6 11	lda $11e6	          LDA VSH+16     ; MSB sprite postion
.a898	59 b3 6c	eor $6cb3,y	          EOR Bit_Mask,Y
.a89b	8d e6 11	sta $11e6	          STA VSH+16     ; MSB sprite postion
.a89e	de 7f 11	dec $117f,x	BIRQ_18   DEC SPRITE_DATA+1,X
.a8a1	d0 d3		bne $a876	          BNE BIRQ_16
.a8a3	88		dey		BIRQ_20   DEY
.a8a4	10 bd		bpl $a863	          BPL BIRQ_14          ; -> loop next sprite
.a8a6	ad 19 d0	lda $d019	          LDA VIC_IRQ_REG     ; load IRQ mask
.a8a9	8d 19 d0	sta $d019	          STA VIC_IRQ_REG     ; reset all IRQ's
.a8ac	29 0e		and #$0e	          AND #%00001110     ; light-pen, sprite collision
.a8ae	f0 44		beq $a8f4	          BEQ BIRQ_30         ; -> no collision
.a8b0	4a		lsr a		          LSR A               ; shift out raster IRQ
.a8b1	a0 01		ldy #$01	          LDY #1              ; Y=1 sprite/background, Y=0 sprite/sprite
.a8b3	4a		lsr a		BIRQ_22   LSR A               ; C = collision
.a8b4	90 20		bcc $a8d6	          BCC BIRQ_28         ; -> none
.a8b6	48		pha		          PHA                 ; save IRQ flags1
.a8b7	b9 1e d0	lda $d01e,y	          LDA VIC_SS_COLL,Y
.a8ba	19 e7 11	ora $11e7,y	          ORA VSH_SS_COLL,Y
.a8bd	99 e7 11	sta $11e7,y	          STA VSH_SS_COLL,Y   ; update collision shadow register
.a8c0	a9 00		lda #$00	          LDA #0
.a8c2	99 1e d0	sta $d01e,y	          STA VIC_SS_COLL,Y   ; clear collision register
.a8c5	ad 7f 12	lda $127f	          LDA INT_VAL         ; flag for collision treatment
.a8c8	c0 00		cpy #$00	          CPY #0
.a8ca	f0 01		beq $a8cd	          BEQ BIRQ_24         ; -> Y=0 : sprite/sprite coll
.a8cc	4a		lsr a		          LSR A
.a8cd	4a		lsr a		BIRQ_24   LSR A
.a8ce	90 05		bcc $a8d5	          BCC BIRQ_26
.a8d0	a9 ff		lda #$ff	          LDA #$ff
.a8d2	99 76 12	sta $1276,y	          STA INT_TRIP_FLAG,Y
.a8d5	68		pla		BIRQ_26   PLA
.a8d6	88		dey		BIRQ_28   DEY                 ; Y=1 sprite/background, Y=0 sprite/sprite
.a8d7	10 da		bpl $a8b3	          BPL BIRQ_22
.a8d9	4a		lsr a		          LSR A               ; C = light pen flag
.a8da	90 18		bcc $a8f4	          BCC BIRQ_30         ; -> none
.a8dc	ad 13 d0	lda $d013	          LDA VIC_LPX         ; copy positions from VIC to shadow
.a8df	8d e9 11	sta $11e9	          STA VSH_LPX
.a8e2	ad 14 d0	lda $d014	          LDA VIC_LPY
.a8e5	8d ea 11	sta $11ea	          STA VSH_LPY
.a8e8	ad 7f 12	lda $127f	          LDA INT_VAL
.a8eb	29 04		and #$04	          AND #%00000100     ; $04
.a8ed	f0 05		beq $a8f4	          BEQ BIRQ_30         ; -> no light pen IRQ
.a8ef	a9 ff		lda #$ff	          LDA #$ff
.a8f1	8d 78 12	sta $1278	          STA Light_Pen_Flag  ; set flag
.a8f4	a2 00		ldx #$00	BIRQ_30   LDX #0              ; X=0,2,4 : voice = 1,2,3
.a8f6	bd 24 12	lda $1224,x	BIRQ_32   LDA Snd_Duration+1,X      ; duration high
.a8f9	30 27		bmi $a922	          BMI BIRQ_34         ; -> inactive
.a8fb	bd 23 12	lda $1223,x	          LDA Snd_Duration,X        ; duration low
.a8fe	38		sec		          SEC                 ; duration -= Snd_Tempo
.a8ff	ed 22 12	sbc $1222	          SBC Snd_Tempo
.a902	9d 23 12	sta $1223,x	          STA Snd_Duration,X
.a905	b0 1b		bcs $a922	          BCS BIRQ_34
.a907	bd 24 12	lda $1224,x	          LDA Snd_Duration+1,X
.a90a	e9 00		sbc #$00	          SBC #0
.a90c	9d 24 12	sta $1224,x	          STA Snd_Duration+1,X
.a90f	b0 11		bcs $a922	          BCS BIRQ_34         ; -> greater 0 : continue
.a911	8a		txa		          TXA
.a912	4a		lsr a		          LSR A
.a913	a8		tay		          TAY                 ; voice #
.a914	b9 30 12	lda $1230,y	          LDA WAVE0,Y         ; envelope
.a917	29 fe		and #$fe	          AND #%11111110     ; $fe
.a919	48		pha		          PHA
.a91a	b9 39 70	lda $7039,y	          LDA offtab,Y        ; SID offset
.a91d	a8		tay		          TAY
.a91e	68		pla		          PLA
.a91f	99 04 d4	sta $d404,y	          STA SID_Control_1,Y ; set new envelope
.a922	e8		inx		BIRQ_34   INX
.a923	e8		inx		          INX                 ; next voice
.a924	e0 06		cpx #$06	          CPX #6
.a926	d0 ce		bne $a8f6	          BNE BIRQ_32         ; -> loop next voice
.a928	a0 02		ldy #$02	          LDY #2              ; loop for voices 2,1,0
.a92a	b9 85 12	lda $1285,y	BIRQ_36   LDA Sound_Duration_1_Hi,Y
.a92d	10 06		bpl $a935	          BPL BIRQ_40         ; -> voice is active
.a92f	88		dey		BIRQ_38   DEY
.a930	10 f8		bpl $a92a	          BPL BIRQ_36
.a932	4c f0 a9	jmp $a9f0	          JMP Exit_BASIC_IRQ
.a935	18		clc		BIRQ_40   CLC
.a936	b9 9d 12	lda $129d,y	          LDA SOUND_FREQ_LO,Y
.a939	79 97 12	adc $1297,y	          ADC SOUND_STEP_LO,Y
.a93c	99 9d 12	sta $129d,y	          STA SOUND_FREQ_LO,Y
.a93f	b9 a0 12	lda $12a0,y	          LDA SOUND_FREQ_HI,Y
.a942	79 9a 12	adc $129a,y	          ADC SOUND_STEP_HI,Y
.a945	99 a0 12	sta $12a0,y	          STA SOUND_FREQ_HI,Y
.a948	b9 94 12	lda $1294,y	          LDA SOUND_DIR,Y
.a94b	aa		tax		          TAX
.a94c	29 01		and #$01	          AND #1
.a94e	f0 2e		beq $a97e	          BEQ BIRQ_46
.a950	90 0f		bcc $a961	          BCC BIRQ_42
.a952	38		sec		          SEC
.a953	b9 9d 12	lda $129d,y	          LDA SOUND_FREQ_LO,Y
.a956	f9 8e 12	sbc $128e,y	          SBC SOUND_MIN_LO,Y
.a959	b9 a0 12	lda $12a0,y	          LDA SOUND_FREQ_HI,Y
.a95c	f9 91 12	sbc $1291,y	          SBC SOUND_MIN_HI,Y
.a95f	b0 4d		bcs $a9ae	          BCS BIRQ_54
.a961	e0 02		cpx #$02	BIRQ_42   CPX #2
.a963	90 0a		bcc $a96f	          BCC BIRQ_44
.a965	20 da a9	jsr $a9da	          JSR Negate_Sound_Step
.a968	a9 02		lda #$02	          LDA #2
.a96a	99 94 12	sta $1294,y	          STA SOUND_DIR,Y
.a96d	d0 33		bne $a9a2	          BNE BIRQ_50
.a96f	b9 88 12	lda $1288,y	BIRQ_44   LDA SOUND_MAX_LO,Y
.a972	99 9d 12	sta $129d,y	          STA SOUND_FREQ_LO,Y
.a975	b9 8b 12	lda $128b,y	          LDA SOUND_MAX_HI,Y
.a978	99 a0 12	sta $12a0,y	          STA SOUND_FREQ_HI,Y
.a97b	4c ae a9	jmp $a9ae	          JMP BIRQ_54
.a97e	b0 14		bcs $a994	BIRQ_46   BCS BIRQ_48
.a980	b9 a0 12	lda $12a0,y	          LDA SOUND_FREQ_HI,Y
.a983	d9 8b 12	cmp $128b,y	          CMP SOUND_MAX_HI,Y
.a986	90 26		bcc $a9ae	          BCC BIRQ_54
.a988	d0 0a		bne $a994	          BNE BIRQ_48
.a98a	b9 9d 12	lda $129d,y	          LDA SOUND_FREQ_LO,Y
.a98d	d9 88 12	cmp $1288,y	          CMP SOUND_MAX_LO,Y
.a990	90 1c		bcc $a9ae	          BCC BIRQ_54
.a992	f0 1a		beq $a9ae	          BEQ BIRQ_54
.a994	e0 02		cpx #$02	BIRQ_48   CPX #2
.a996	90 0a		bcc $a9a2	          BCC BIRQ_50
.a998	20 da a9	jsr $a9da	          JSR Negate_Sound_Step
.a99b	a9 03		lda #$03	          LDA #3
.a99d	99 94 12	sta $1294,y	          STA SOUND_DIR,Y
.a9a0	d0 cd		bne $a96f	          BNE BIRQ_44
.a9a2	b9 8e 12	lda $128e,y	BIRQ_50   LDA SOUND_MIN_LO,Y
.a9a5	99 9d 12	sta $129d,y	          STA SOUND_FREQ_LO,Y
.a9a8	b9 91 12	lda $1291,y	          LDA SOUND_MIN_HI,Y
.a9ab	99 a0 12	sta $12a0,y	          STA SOUND_FREQ_HI,Y
.a9ae	be 39 70	ldx $7039,y	BIRQ_54   LDX offtab,Y
.a9b1	b9 9d 12	lda $129d,y	          LDA SOUND_FREQ_LO,Y
.a9b4	9d 00 d4	sta $d400,x	          STA SID_Freq_1,X
.a9b7	b9 a0 12	lda $12a0,y	          LDA SOUND_FREQ_HI,Y
.a9ba	9d 01 d4	sta $d401,x	          STA SID_Freq_1+1,X
.a9bd	98		tya		          TYA
.a9be	aa		tax		          TAX
.a9bf	bd 82 12	lda $1282,x	          LDA Sound_Duration_1_Lo,X
.a9c2	d0 03		bne $a9c7	          BNE BIRQ_56
.a9c4	de 85 12	dec $1285,x	          DEC Sound_Duration_1_Hi,X
.a9c7	de 82 12	dec $1282,x	BIRQ_56   DEC Sound_Duration_1_Lo,X
.a9ca	bd 85 12	lda $1285,x	          LDA Sound_Duration_1_Hi,X
.a9cd	10 08		bpl $a9d7	          BPL BIRQ_58
.a9cf	a9 08		lda #$08	          LDA #8
.a9d1	be 39 70	ldx $7039,y	          LDX offtab,Y
.a9d4	9d 04 d4	sta $d404,x	          STA SID_Control_1,X
.a9d7	4c 2f a9	jmp $a92f	BIRQ_58   JMP BIRQ_38
.a9da					  Negate_Sound_Step
.a9da	b9 97 12	lda $1297,y	          LDA SOUND_STEP_LO,Y
.a9dd	49 ff		eor #$ff	          EOR #$ff
.a9df	18		clc		          CLC
.a9e0	69 01		adc #$01	          ADC #1
.a9e2	99 97 12	sta $1297,y	          STA SOUND_STEP_LO,Y
.a9e5	b9 9a 12	lda $129a,y	          LDA SOUND_STEP_HI,Y
.a9e8	49 ff		eor #$ff	          EOR #$ff
.a9ea	69 00		adc #$00	          ADC #0
.a9ec	99 9a 12	sta $129a,y	          STA SOUND_STEP_HI,Y
.a9ef	60		rts		          RTS
.a9f0					  Exit_BASIC_IRQ
.a9f0	ce fd 12	dec $12fd	          DEC IRQ_ACTIVE_FLAG
.a9f3	60		rts		          RTS
.a9f4					  Move_Sprite
.a9f4	48		pha		          PHA                 ; save quadrant
.a9f5	18		clc		          CLC
.a9f6	bd 81 11	lda $1181,x	          LDA SPRITE_DATA+3,X ; movement
.a9f9	7d 85 11	adc $1185,x	          ADC SPRITE_DATA+7,X ; old position
.a9fc	9d 85 11	sta $1185,x	          STA SPRITE_DATA+7,X ; new position
.a9ff	bd 82 11	lda $1182,x	          LDA SPRITE_DATA+4,X
.aa02	7d 86 11	adc $1186,x	          ADC SPRITE_DATA+8,X
.aa05	9d 86 11	sta $1186,x	          STA SPRITE_DATA+8,X
.aa08	68		pla		          PLA                 ; restore quadrant
.aa09	90 13		bcc $aa1e	          BCC MoSp_Ret
.aa0b	4a		lsr a		          LSR A
.aa0c	4a		lsr a		          LSR A               ; C = bit2
.aa0d	b9 d6 11	lda $11d6,y	          LDA VSH,Y
.aa10	b0 05		bcs $aa17	          BCS MoSp_10
.aa12	69 01		adc #$01	          ADC #1
.aa14	4c 1b aa	jmp $aa1b	          JMP MoSp_20
.aa17	e9 01		sbc #$01	MoSp_10   SBC #1
.aa19	c9 ff		cmp #$ff	          CMP #$ff
.aa1b	99 d6 11	sta $11d6,y	MoSp_20   STA VSH,Y
.aa1e	60		rts		MoSp_Ret  RTS
.aa1f					  BASIC_STASH
.aa1f	a9 84		lda #$84	          LDA #$84            ; STASH marker
.aa21	4c 2b aa	jmp $aa2b	          JMP SWAP_10
.aa24					  BASIC_FETCH
.aa24	a9 85		lda #$85	          LDA #$85            ; FETCH marker
.aa26	4c 2b aa	jmp $aa2b	          JMP SWAP_10
.aa29					  BASIC_SWAP
.aa29	a9 86		lda #$86	          LDA #$86            ; SWAP marker
.aa2b	48		pha		SWAP_10   PHA                 ; save marker
.aa2c	20 12 88	jsr $8812	          JSR Get_Integer     ; get byte count
.aa2f	20 45 a8	jsr $a845	          JSR Map_IO
.aa32	8c 07 df	sty $df07	          STY DMA_CNT_LO
.aa35	8d 08 df	sta $df08	          STA DMA_CNT_HI
.aa38	20 0f 88	jsr $880f	          JSR Comma_And_LINNUM ; get internal address
.aa3b	20 45 a8	jsr $a845	          JSR Map_IO
.aa3e	8c 02 df	sty $df02	          STY DMA_CBM_LO
.aa41	8d 03 df	sta $df03	          STA DMA_CBM_HI
.aa44	20 0f 88	jsr $880f	          JSR Comma_And_LINNUM ; get external address
.aa47	20 45 a8	jsr $a845	          JSR Map_IO
.aa4a	8c 04 df	sty $df04	          STY DMA_REU_LO
.aa4d	8d 05 df	sta $df05	          STA DMA_REU_HI
.aa50	20 09 88	jsr $8809	          JSR Comma_And_Byte   ; get external bank
.aa53	e0 10		cpx #$10	          CPX #16              ; limit to 1 Mbyte
.aa55	b0 0e		bcs $aa65	          BCS SWAP_Err
.aa57	20 45 a8	jsr $a845	          JSR Map_IO
.aa5a	8e 06 df	stx $df06	          STX DMA_REU_BA
.aa5d	68		pla		          PLA                  ; restore marker
.aa5e	a8		tay		          TAY                  ; Y = marker
.aa5f	ae d5 03	ldx $03d5	          LDX USER_BANK        ; user bank
.aa62	4c 50 ff	jmp $ff50	          JMP K_DMA            ; do it
.aa65	4c 28 7d	jmp $7d28	SWAP_Err  JMP Error_Illegal_Quantity
.aa68					  FAC1_Round_INT
.aa68	20 47 8c	jsr $8c47	          JSR Round_FAC1
.aa6b	4c c7 8c	jmp $8cc7	          JMP FAC1_INT
.aa6e					  Output_Comma
.aa6e	20 d3 42	jsr $42d3	          JSR FNDPNT_from_Bank_1
.aa71	c9 2c		cmp #$2c	          CMP #','
.aa73	d0 07		bne $aa7c	          BNE OuCo_10
.aa75	ad 33 01	lda $0133	          LDA BLFD            ; fill character
.aa78	20 eb 98	jsr $98eb	          JSR Chrout_Using
.aa7b	c8		iny		          INY
.aa7c	38		sec		OuCo_10   SEC
.aa7d	6e 25 01	ror $0125	          ROR DOLR            ; flag dollar used
.aa80	60		rts		          RTS
>aa81	ff ff ff ff ff ff ff ff		          .FILL $ae63-* , $ff
>aa89	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
;	...repeated 60 times (960 bytes)...
>ae59	ff ff ff ff ff ff ff ff ff ff
.ae63					  EasterEgg
>ae63	7b e9 77 6a 5f 5e 5d be		          .BYTE $7b,$e9,$77,$6a,$5f,$5e,$5d,$be
>ae6b	21 3d 24 37 3f 22 55 20		          .BYTE $21,$3d,$24,$37,$3f,$22,$55,$20
>ae73	24 4a 30 27 3a 4e 2f 35		          .BYTE $24,$4a,$30,$27,$3a,$4e,$2f,$35
>ae7b	4d 4c 4f 40 47 46 68 69		          .BYTE $4d,$4c,$4f,$40,$47,$46,$68,$69
>ae83	88 15 1f 0c 08 1f 0f 19		          .BYTE $88,$15,$1f,$0c,$08,$1f,$0f,$19
>ae8b	69 5f 71 96 05 13 11 74		          .BYTE $69,$5f,$71,$96,$05,$13,$11,$74
>ae93	89 05 1e 0d 01 43 6d 98		          .BYTE $89,$05,$1e,$0d,$01,$43,$6d,$98
>ae9b	06 10 13 19 67 94 1c 05		          .BYTE $06,$10,$13,$19,$67,$94,$1c,$05
>aea3	75 37 19 ee 70 70 1d f9		          .BYTE $75,$37,$19,$ee,$70,$70,$1d,$f9
>aeab	61 66 66 79 79 73 38 39		          .BYTE $61,$66,$66,$79,$79,$73,$38,$39
>aeb3	e3 6f 7b 6c 78 6f 7f 69		          .BYTE $e3,$6f,$7b,$6c,$78,$6f,$7f,$69
>aebb	19 2f 01 e2 6e 6a 05 ec		          .BYTE $19,$2f,$01,$e2,$6e,$6a,$05,$ec
>aec3	5e 48 5d 15 3f da 5c 4a		          .BYTE $5e,$48,$5d,$15,$3f,$da,$5c,$4a
>aecb	56 32 d9 51 4e 58 5c 51		          .BYTE $56,$32,$d9,$51,$4e,$58,$5c,$51
>aed3	06 2a cf 5a 4e 40 46 2c		          .BYTE $06,$2a,$cf,$5a,$4e,$40,$46,$2c
>aedb	d3 43 4d 41 4e 47 08 09		          .BYTE $d3,$43,$4d,$41,$4e,$47,$08,$09
>aee3	e9 36 b0 b6 b4 de bc ae		          .BYTE $e9,$36,$b0,$b6,$b4,$de,$bc,$ae
>aeeb	be a1 dd b4 b8 b8 d2 a0		          .BYTE $be,$a1,$dd,$b4,$b8,$b8,$d2,$a0
>aef3	cb a7 a8 a3 aa ce b9 a4		          .BYTE $cb,$a7,$a8,$a3,$aa,$ce,$b9,$a4
>aefb	a6 af cf ed e7			          .BYTE $a6,$af,$cf,$ed,$e7
>af00					          .FILL $af00-* ,0
.af00					  BASIC_Jump_Table
.af00	4c b4 84	jmp $84b4	          JMP Real_To_Integer
.af03	4c 3c 79	jmp $793c	          JMP Integer_To_Real
.af06	4c 42 8e	jmp $8e42	          JMP Format_FAC1
.af09	4c 52 80	jmp $8052	          JMP VAL_10
.af0c	4c 15 88	jmp $8815	          JMP FAC1_To_LINNUM
.af0f	4c 75 8c	jmp $8c75	          JMP Word_To_FAC1
.af12	4c 2e 88	jmp $882e	          JMP AY_Minus_FAC1
.af15	4c 31 88	jmp $8831	          JMP OP_MINUS
.af18	4c 45 88	jmp $8845	          JMP Add_Var_AY_To_FAC1
.af1b	4c 48 88	jmp $8848	          JMP OP_PLUS
.af1e	4c 24 8a	jmp $8a24	          JMP AY_Mult_FAC1
.af21	4c 27 8a	jmp $8a27	          JMP OP_MULT
.af24	4c 49 8b	jmp $8b49	          JMP AY_Divided_By_FAC1
.af27	4c 4c 8b	jmp $8b4c	          JMP OP_DIV
.af2a	4c ca 89	jmp $89ca	          JMP FUNC_LOG
.af2d	4c fb 8c	jmp $8cfb	          JMP FUNC_INT
.af30	4c b7 8f	jmp $8fb7	          JMP FUNC_SQR
.af33	4c fa 8f	jmp $8ffa	          JMP OP_NEG
.af36	4c be 8f	jmp $8fbe	          JMP POT_XY
.af39	4c c1 8f	jmp $8fc1	          JMP OP_POWER
.af3c	4c 33 90	jmp $9033	          JMP FUNC_EXP
.af3f	4c 09 94	jmp $9409	          JMP FUNC_COS
.af42	4c 10 94	jmp $9410	          JMP FUNC_SIN
.af45	4c 59 94	jmp $9459	          JMP FUNC_TAN
.af48	4c b3 94	jmp $94b3	          JMP FUNC_ATN
.af4b	4c 47 8c	jmp $8c47	          JMP Round_FAC1
.af4e	4c 84 8c	jmp $8c84	          JMP FUNC_ABS
.af51	4c 57 8c	jmp $8c57	          JMP Test_FAC1_Sign
.af54	4c 87 8c	jmp $8c87	          JMP Compare_AY_FAC1
.af57	4c 37 84	jmp $8437	          JMP RND_10
.af5a	4c b4 8a	jmp $8ab4	          JMP Load_FAC2_From_AY_RAM
.af5d	4c 89 8a	jmp $8a89	          JMP Load_FAC2_From_AY_ROM
.af60	4c 85 7a	jmp $7a85	          JMP LoVa_70
.af63	4c d4 8b	jmp $8bd4	          JMP Load_FAC1_AY
.af66	4c 00 8c	jmp $8c00	          JMP FAC1_To_XY
.af69	4c 28 8c	jmp $8c28	          JMP FAC2_To_FAC1
.af6c	4c 38 8c	jmp $8c38	          JMP FAC1_Round_And_Copy_To_FAC2
.af6f	4c 28 48	jmp $4828	          JMP BASIC_Operator
.af72	4c 30 9b	jmp $9b30	          JMP Draw_Line
.af75	4c fb 9b	jmp $9bfb	          JMP Double_Pixel
.af78	4c 50 67	jmp $6750	          JMP CIRC_SUB
.af7b	4c 9b 5a	jmp $5a9b	          JMP BASIC_RUN
.af7e	4c f3 51	jmp $51f3	          JMP Reset_BASIC_Execution
.af81	4c f8 51	jmp $51f8	          JMP BASIC_CLR
.af84	4c d6 51	jmp $51d6	          JMP BASIC_NEW
.af87	4c 4f 4f	jmp $4f4f	          JMP Relink
.af8a	4c 0a 43	jmp $430a	          JMP CRUNCH
.af8d	4c 64 50	jmp $5064	          JMP Search_BASIC_Line
.af90	4c f6 4a	jmp $4af6	          JMP Next_Statement
.af93	4c d7 78	jmp $78d7	          JMP Vectored_EVAL
.af96	4c ef 77	jmp $77ef	          JMP Eval_Expression
.af99	4c a6 5a	jmp $5aa6	          JMP LINK_RUN
.af9c	4c 81 5a	jmp $5a81	          JMP Set_Run_Mode
.af9f	4c a0 50	jmp $50a0	          JMP Scan_Linenumber
.afa2	4c ea 92	jmp $92ea	          JMP Garbage_Collection
.afa5	4c cd 4d	jmp $4dcd	          JMP MAIN_02
>afa8	ff ff ff ff ff ff ff ff		          .FILL $b000-* ,$ff ;   88 bytes
>afb0	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
;	...repeated 3 times (48 bytes)...
>aff0	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
.b000					  BASIC_MONITOR
.b000	4c 21 b0	jmp $b021	          JMP Mon_Entry_By_Call
.b003					  Mon_Break
.b003	4c 09 b0	jmp $b009	          JMP Mon_Entry_By_Break
.b006					  Mon_Command
.b006	4c b2 b0	jmp $b0b2	          JMP Mon_Command_Switch
.b009					  Mon_Entry_By_Break
.b009	20 7d ff	jsr $ff7d	          JSR K_PRIMM
>b00c	0d 42 52 45 41 4b 07 00		          .TEXT "\rBREAK",7,0
.b014	68		pla		          PLA                 ; bank of interrupted program
.b015	85 02		sta $02		          STA BANK
.b017	a2 05		ldx #$05	          LDX #5
.b019	68		pla		MEBB_10   PLA
.b01a	95 03		sta $03,x	          STA PC_HI,X         ; save CPU registers and flags
.b01c	ca		dex		          DEX
.b01d	10 fa		bpl $b019	          BPL MEBB_10
.b01f	30 25		bmi $b046	          BMI Mon_Start       ; always
.b021					  Mon_Entry_By_Call
.b021	a9 00		lda #$00	          LDA #0
.b023	8d 00 ff	sta $ff00	          STA MMU_CR          ; system bank
.b026	85 06		sta $06		          STA A_REG           ; clear register saves
.b028	85 07		sta $07		          STA X_REG
.b02a	85 08		sta $08		          STA Y_REG
.b02c	85 05		sta $05		          STA S_REG
.b02e	a9 00		lda #$00	          LDA #<BASIC_MONITOR ; default for PC save
.b030	a0 b0		ldy #$b0	          LDY #>BASIC_MONITOR
.b032	85 04		sta $04		          STA PC_LO
.b034	84 03		sty $03		          STY PC_HI
.b036	a9 0f		lda #$0f	          LDA #15
.b038	85 02		sta $02		          STA BANK            ; bank configuration for monitor
.b03a	20 7d ff	jsr $ff7d	          JSR K_PRIMM
>b03d	0d 4d 4f 4e 49 54 4f 52		          .TEXT "\rMONITOR",0
>b045	00
.b046					  Mon_Start
.b046	d8		cld		          CLD                 ; clear decimal mode
.b047	ba		tsx		          TSX
.b048	86 09		stx $09		          STX CHARAC          ; save stack pointer
.b04a	a9 c0		lda #$c0	          LDA #$c0            ; activate kernal and I/O messages
.b04c	20 90 ff	jsr $ff90	          JSR K_SETMSG        ; set message flag
.b04f	58		cli		          CLI                 ; enable interrupts
.b050					  Mon_Print_Header
.b050	20 7d ff	jsr $ff7d	          JSR K_PRIMM         ; print register header
>b053	0d 20 20 20 20 50 43 20		          .TEXT "\r    PC  SR AC XR YR SP\r; "
>b05b	20 53 52 20 41 43 20 58 52 20 59 52 20 53 50 0d
>b06b	3b 20
>b06d	1b 51 00			          .BYTE $1b,$51,$00
.b070	a5 02		lda $02		          LDA BANK
.b072	20 d2 b8	jsr $b8d2	          JSR Mon_Bin_To_Hex
.b075	8a		txa		          TXA                 ; hex value of lower nibble
.b076	20 d2 ff	jsr $ffd2	          JSR K_BSOUT         ; prinz bank as single hex
.b079	a5 03		lda $03		          LDA PC_HI
.b07b	20 c2 b8	jsr $b8c2	          JSR Mon_Hex
.b07e	a0 02		ldy #$02	          LDY #2
.b080	b9 02 00	lda $0002,y	MPH_10    LDA BANK,Y          ; print all register values
.b083	20 a5 b8	jsr $b8a5	          JSR Mon_Hex_Blank
.b086	c8		iny		          INY
.b087	c0 08		cpy #$08	          CPY #8
.b089	90 f5		bcc $b080	          BCC MPH_10
.b08b					  Mon_Main
.b08b	20 b4 b8	jsr $b8b4	          JSR Mon_CR
.b08e	a2 00		ldx #$00	          LDX #0
.b090	86 7a		stx $7a		          STX DS_LEN
.b092	20 cf ff	jsr $ffcf	MoMa_10   JSR K_BASIN
.b095	9d 00 02	sta $0200,x	          STA BUF,X
.b098	e8		inx		          INX
.b099	e0 a1		cpx #$a1	          CPX #161            ; max. buffer size
.b09b	b0 1f		bcs $b0bc	          BCS Mon_Error
.b09d	c9 0d		cmp #$0d	          CMP #CR             ; end of input
.b09f	d0 f1		bne $b092	          BNE MoMa_10
.b0a1	a9 00		lda #$00	          LDA #0
.b0a3	9d ff 01	sta $01ff,x	          STA BUF-1,X         ; zero terminate buffer
.b0a6	20 e9 b8	jsr $b8e9	MoMa_20   JSR Mon_Get_Char
.b0a9	f0 e0		beq $b08b	          BEQ Mon_Main
.b0ab	c9 20		cmp #$20	          CMP #' '
.b0ad	f0 f7		beq $b0a6	          BEQ MoMa_20
.b0af	6c 2e 03	jmp ($032e)	          JMP (EXMON)         ; JMP Mon_Command -> Switch
.b0b2					  Mon_Command_Switch
.b0b2	a2 15		ldx #$15	          LDX #21             ; # of commands
.b0b4	dd e6 b0	cmp $b0e6,x	MoCS_10   CMP cmdchr,X
.b0b7	f0 0c		beq $b0c5	          BEQ MoMa_30
.b0b9	ca		dex		          DEX
.b0ba	10 f8		bpl $b0b4	          BPL MoCS_10
.b0bc					  Mon_Error
.b0bc	20 7d ff	jsr $ff7d	          JSR K_PRIMM
>b0bf	1d 3f 00			          .BYTE $1d,$3f,$00   ; cursor right, ?, 0
.b0c2	4c 8b b0	jmp $b08b	          JMP Mon_Main
.b0c5					  MoMa_30
.b0c5	e0 13		cpx #$13	          CPX #19
.b0c7	b0 12		bcs $b0db	          BCS MoMa_40         ; -> Load, Save or Verify
.b0c9	e0 0f		cpx #$0f	          CPX #15
.b0cb	b0 13		bcs $b0e0	          BCS MoMa_50         ; -> numeric conversion
.b0cd	8a		txa		          TXA
.b0ce	0a		asl a		          ASL A
.b0cf	aa		tax		          TAX
.b0d0	bd fd b0	lda $b0fd,x	          LDA cmdtbl+1,X
.b0d3	48		pha		          PHA
.b0d4	bd fc b0	lda $b0fc,x	          LDA cmdtbl,X
.b0d7	48		pha		          PHA
.b0d8	4c a7 b7	jmp $b7a7	          JMP Mon_Got_Aval    ; parse arguments, then execute function
.b0db	85 93		sta $93		MoMa_40   STA K_VERCK         ; store 'L', or 'S' or 'V'
.b0dd	4c 37 b3	jmp $b337	          JMP Mon_Load_Save   ; load, save or verify
.b0e0	4c b1 b9	jmp $b9b1	MoMa_50   JMP Mon_Convert
.b0e3					  Mon_Exit
.b0e3	6c 00 0a	jmp ($0a00)	          JMP (RESET_VECTOR)
>b0e6	41 43 44 46 47 48 4a 4d		cmdchr    .TEXT "ACDFGHJMRTX@.>;"
>b0ee	52 54 58 40 2e 3e 3b
>b0f5	24 2b 26 25			cmdnum    .TEXT "$+&%"
>b0f9	4c 53 56			          .TEXT "LSV"
>b0fc	05 b4				cmdtbl    .WORD Mon_Assemble     - 1  ; A
>b0fe	30 b2				          .WORD Mon_Compare -      1  ; C
>b100	98 b5				          .WORD Mon_Disassemble  - 1  ; D
>b102	da b3				          .WORD Mon_Fill         - 1  ; F
>b104	d5 b1				          .WORD Mon_Go           - 1  ; G
>b106	cd b2				          .WORD Mon_Hunt         - 1  ; H
>b108	de b1				          .WORD Mon_Gosub        - 1  ; J
>b10a	51 b1				          .WORD Mon_Memory       - 1  ; M
>b10c	4f b0				          .WORD Mon_Print_Header - 1  ; R
>b10e	33 b2				          .WORD Mon_Transfer     - 1  ; T
>b110	e2 b0				          .WORD Mon_Exit         - 1  ; X
>b112	8f ba				          .WORD Mon_Disk         - 1  ; @
>b114	05 b4				          .WORD Mon_Assemble     - 1  ; .
>b116	aa b1				          .WORD Mon_Set_Memory   - 1  ; >
>b118	93 b1				          .WORD Mon_Set_Register - 1  ; ;
.b11a					  Mon_Fetch
.b11a	8e b2 0a	stx $0ab2	          STX M_Save_X
.b11d	a6 68		ldx $68		          LDX M_Cval+2
.b11f	a9 66		lda #$66	          LDA #M_Cval
.b121	78		sei		          SEI
.b122	20 74 ff	jsr $ff74	          JSR K_INDFET
.b125	58		cli		          CLI
.b126	ae b2 0a	ldx $0ab2	          LDX M_Save_X
.b129	60		rts		          RTS
.b12a					  Mon_Stash
.b12a	8e b2 0a	stx $0ab2	          STX M_Save_X
.b12d	a2 66		ldx #$66	          LDX #M_Cval
.b12f	8e b9 02	stx $02b9	          STX STASH+10
.b132	a6 68		ldx $68		          LDX M_Cval+2
.b134	78		sei		          SEI
.b135	20 77 ff	jsr $ff77	          JSR K_INDSTA
.b138	58		cli		          CLI
.b139	ae b2 0a	ldx $0ab2	          LDX M_Save_X
.b13c	60		rts		          RTS
.b13d					  Mon_Compa
.b13d	8e b2 0a	stx $0ab2	          STX M_Save_X
.b140	a2 66		ldx #$66	          LDX #M_Cval
.b142	8e c8 02	stx $02c8	          STX CMPARE+10
.b145	a6 68		ldx $68		          LDX M_Cval+2
.b147	78		sei		          SEI
.b148	20 7a ff	jsr $ff7a	          JSR K_INDCMP
.b14b	58		cli		          CLI
.b14c	08		php		          PHP
.b14d	ae b2 0a	ldx $0ab2	          LDX M_Save_X
.b150	28		plp		          PLP
.b151	60		rts		          RTS
.b152					  Mon_Memory
.b152	b0 08		bcs $b15c	          BCS MoMe_10         ; -> no end address
.b154	20 01 b9	jsr $b901	          JSR Mon_Aval_To_Cval
.b157	20 a7 b7	jsr $b7a7	          JSR Mon_Got_Aval
.b15a	90 06		bcc $b162	          BCC MoMe_20
.b15c	a9 0b		lda #$0b	MoMe_10   LDA #11             ; display 12 lines
.b15e	85 60		sta $60		          STA M_Aval
.b160	d0 15		bne $b177	          BNE MoMe_40
.b162	20 0e b9	jsr $b90e	MoMe_20   JSR Mon_Aval_Minus_Cval
.b165	90 2a		bcc $b191	          BCC MoMe_Err
.b167	a2 03		ldx #$03	          LDX #3              ; X = 3
.b169	24 d7		bit $d7		          BIT MODE_80
.b16b	10 01		bpl $b16e	          BPL MoMe_30         ; -> 40 column screen
.b16d	e8		inx		          INX                 ; X = 4
.b16e	46 62		lsr $62		MoMe_30   LSR M_Aval+2      ; Aval /= (bytes per line)
.b170	66 61		ror $61		          ROR M_Aval+1
.b172	66 60		ror $60		          ROR M_Aval
.b174	ca		dex		          DEX
.b175	d0 f7		bne $b16e	          BNE MoMe_30
.b177	20 e1 ff	jsr $ffe1	MoMe_40   JSR K_STOP          ; test for STOP key
.b17a	f0 12		beq $b18e	          BEQ MoMe_60         ; -> STOP
.b17c	20 e8 b1	jsr $b1e8	          JSR Mon_Dump_Row
.b17f	a9 08		lda #$08	          LDA #8              ; display  8 bytes on 40 column screen
.b181	24 d7		bit $d7		          BIT MODE_80
.b183	10 01		bpl $b186	          BPL MoMe_50
.b185	0a		asl a		          ASL A               ; display 16 bytes on 80 column screen
.b186	20 52 b9	jsr $b952	MoMe_50   JSR Mon_Add_Cval
.b189	20 22 b9	jsr $b922	          JSR Mon_Dec_Aval
.b18c	b0 e9		bcs $b177	          BCS MoMe_40
.b18e	4c 8b b0	jmp $b08b	MoMe_60   JMP Mon_Main
.b191	4c bc b0	jmp $b0bc	MoMe_Err  JMP Mon_Error
.b194					  Mon_Set_Register
.b194	20 74 b9	jsr $b974	          JSR Mon_Aval_To_PCB          ; set PC
.b197	a0 00		ldy #$00	          LDY #0
.b199	20 a7 b7	jsr $b7a7	MoSr_10   JSR Mon_Got_Aval
.b19c	b0 0a		bcs $b1a8	          BCS MoSr_20
.b19e	a5 60		lda $60		          LDA M_Aval
.b1a0	99 05 00	sta $0005,y	          STA S_REG,Y         ; SR AC XR YR SP
.b1a3	c8		iny		          INY
.b1a4	c0 05		cpy #$05	          CPY #5
.b1a6	90 f1		bcc $b199	          BCC MoSr_10
.b1a8	4c 8b b0	jmp $b08b	MoSr_20   JMP Mon_Main
.b1ab					  Mon_Set_Memory
.b1ab	b0 1c		bcs $b1c9	          BCS MoSM_30
.b1ad	20 01 b9	jsr $b901	          JSR Mon_Aval_To_Cval
.b1b0	a0 00		ldy #$00	          LDY #0
.b1b2	20 a7 b7	jsr $b7a7	MoSM_10   JSR Mon_Got_Aval
.b1b5	b0 12		bcs $b1c9	          BCS MoSM_30
.b1b7	a5 60		lda $60		          LDA M_Aval
.b1b9	20 2a b1	jsr $b12a	          JSR Mon_Stash
.b1bc	c8		iny		          INY
.b1bd	24 d7		bit $d7		          BIT MODE_80
.b1bf	10 04		bpl $b1c5	          BPL MoSM_20         ; -> 40 columns
.b1c1	c0 10		cpy #$10	          CPY #16
.b1c3	90 ed		bcc $b1b2	          BCC MoSM_10
.b1c5	c0 08		cpy #$08	MoSM_20   CPY #8
.b1c7	90 e9		bcc $b1b2	          BCC MoSM_10
.b1c9	20 7d ff	jsr $ff7d	MoSM_30   JSR K_PRIMM
>b1cc	1b 4f 91 00			          .BYTE ESC,'O',$91,0 ; clear attributes
.b1d0	20 e8 b1	jsr $b1e8	          JSR Mon_Dump_Row
.b1d3	4c 8b b0	jmp $b08b	          JMP Mon_Main
.b1d6					  Mon_Go
.b1d6	20 74 b9	jsr $b974	          JSR Mon_Aval_To_PCB
.b1d9	a6 09		ldx $09		          LDX CHARAC
.b1db	9a		txs		          TXS
.b1dc	4c 71 ff	jmp $ff71	          JMP K_JMPFAR
.b1df					  Mon_Gosub
.b1df	20 74 b9	jsr $b974	          JSR Mon_Aval_To_PCB
.b1e2	20 6e ff	jsr $ff6e	          JSR K_JSRFAR
.b1e5	4c 8b b0	jmp $b08b	          JMP Mon_Main
.b1e8					  Mon_Dump_Row
.b1e8	20 b4 b8	jsr $b8b4	          JSR Mon_CR
.b1eb	a9 3e		lda #$3e	          LDA #'>'
.b1ed	20 d2 ff	jsr $ffd2	          JSR K_BSOUT
.b1f0	20 92 b8	jsr $b892	          JSR Mon_Hex_Cval        ; address
.b1f3	a0 00		ldy #$00	          LDY #0
.b1f5	f0 03		beq $b1fa	          BEQ MoDR_20         ; always
.b1f7	20 a8 b8	jsr $b8a8	MoDR_10   JSR Mon_Blank
.b1fa	20 1a b1	jsr $b11a	MoDR_20   JSR Mon_Fetch
.b1fd	20 c2 b8	jsr $b8c2	          JSR Mon_Hex          ; memory byte
.b200	c8		iny		          INY
.b201	c0 08		cpy #$08	          CPY #8              ; 40 columns
.b203	24 d7		bit $d7		          BIT MODE_80
.b205	10 02		bpl $b209	          BPL MoDR_30         ; -> 40 column screen
.b207	c0 10		cpy #$10	          CPY #16             ; 80 columns
.b209	90 ec		bcc $b1f7	MoDR_30   BCC MoDR_10         ; -> loop
.b20b	20 7d ff	jsr $ff7d	          JSR K_PRIMM
>b20e	3a 12 00			          .BYTE ':',$12,0     ; separator to text dump
.b211	a0 00		ldy #$00	          LDY #0              ; fall through to text dump
.b213	20 1a b1	jsr $b11a	MoDR_40   JSR Mon_Fetch
.b216	48		pha		          PHA
.b217	29 7f		and #$7f	          AND #$7f            ; remove reverse bit
.b219	c9 20		cmp #$20	          CMP #' '            ; printable ?
.b21b	68		pla		          PLA
.b21c	b0 02		bcs $b220	          BCS MoDR_50
.b21e	a9 2e		lda #$2e	          LDA #'.'            ; use dot for unprintable chars
.b220	20 d2 ff	jsr $ffd2	MoDR_50   JSR K_BSOUT
.b223	c8		iny		          INY
.b224	24 d7		bit $d7		          BIT MODE_80
.b226	10 04		bpl $b22c	          BPL MoDR_60
.b228	c0 10		cpy #$10	          CPY #16             ; 80 columns
.b22a	90 e7		bcc $b213	          BCC MoDR_40
.b22c	c0 08		cpy #$08	MoDR_60   CPY #8              ; 40 columns
.b22e	90 e3		bcc $b213	          BCC MoDR_40
.b230	60		rts		          RTS
.b231					  Mon_Compare
.b231	a9 00		lda #$00	          LDA #0
>b233	2c				          .byte $2c ;BIT
.b234					  Mon_Transfer
.b234	a9 80		lda #$80	          LDA #$80
.b236	85 93		sta $93		          STA K_VERCK         ; $80 = Transfer, $00 = Compare
.b238	a9 00		lda #$00	          LDA #0
.b23a	8d b3 0a	sta $0ab3	          STA M_Dir
.b23d	20 83 b9	jsr $b983	          JSR Mon_Range       ; Cval, TEMPS (Bval = range)
.b240	b0 05		bcs $b247	          BCS MoTr_10
.b242	20 a7 b7	jsr $b7a7	          JSR Mon_Got_Aval    ; Aval = target address
.b245	90 03		bcc $b24a	          BCC MoTr_15
.b247	4c bc b0	jmp $b0bc	MoTr_10   JMP Mon_Error
.b24a	24 93		bit $93		MoTr_15   BIT K_VERCK
.b24c	10 2c		bpl $b27a	          BPL MoTr_25         ; -> Compare is indepent of direction
.b24e	38		sec		          SEC
.b24f	a5 66		lda $66		          LDA M_Cval
.b251	e5 60		sbc $60		          SBC M_Aval
.b253	a5 67		lda $67		          LDA M_Cval+1
.b255	e5 61		sbc $61		          SBC M_Aval+1      ; source (Cval) >= target (Aval) ?
.b257	b0 21		bcs $b27a	          BCS MoTr_25         ; -> yes, do a forward copy
.b259	a5 63		lda $63		          LDA M_Bval        ; otherwise we need a backward copy
.b25b	65 60		adc $60		          ADC M_Aval
.b25d	85 60		sta $60		          STA M_Aval
.b25f	a5 64		lda $64		          LDA M_Bval+1
.b261	65 61		adc $61		          ADC M_Aval+1
.b263	85 61		sta $61		          STA M_Aval+1
.b265	a5 65		lda $65		          LDA M_Bval+2
.b267	65 62		adc $62		          ADC M_Aval+2
.b269	85 62		sta $62		          STA M_Aval+2
.b26b	a2 02		ldx #$02	          LDX #2
.b26d	bd b7 0a	lda $0ab7,x	MoTr_20   LDA M_Temp,X         ; Cval = TEMPS
.b270	95 66		sta $66,x	          STA M_Cval,X
.b272	ca		dex		          DEX
.b273	10 f8		bpl $b26d	          BPL MoTr_20
.b275	a9 80		lda #$80	          LDA #$80
.b277	8d b3 0a	sta $0ab3	          STA M_Dir       ; do a backward transfer
.b27a	20 b4 b8	jsr $b8b4	MoTr_25   JSR Mon_CR
.b27d	a0 00		ldy #$00	          LDY #0
.b27f	20 e1 ff	jsr $ffe1	MoTr_30   JSR K_STOP
.b282	f0 47		beq $b2cb	          BEQ MoTr_65
.b284	20 1a b1	jsr $b11a	          JSR Mon_Fetch       ; load byte (Cval)
.b287	a2 60		ldx #$60	          LDX #M_Aval
.b289	8e b9 02	stx $02b9	          STX STASH+10
.b28c	8e c8 02	stx $02c8	          STX CMPARE+10
.b28f	a6 62		ldx $62		MoTr_35   LDX M_Aval+2      ; bank config
.b291	78		sei		          SEI
.b292	24 93		bit $93		          BIT K_VERCK
.b294	10 03		bpl $b299	          BPL MoTr_40         ; -> compare
.b296	20 77 ff	jsr $ff77	          JSR K_INDSTA        ; transfer
.b299	a6 62		ldx $62		MoTr_40   LDX M_Aval+2      ; bank config
.b29b	20 7a ff	jsr $ff7a	          JSR K_INDCMP        ; compare
.b29e	58		cli		          CLI
.b29f	f0 09		beq $b2aa	          BEQ MoTr_45         ; -> equal
.b2a1	20 92 b8	jsr $b892	          JSR Mon_Hex_Cval
.b2a4	20 a8 b8	jsr $b8a8	          JSR Mon_Blank
.b2a7	20 a8 b8	jsr $b8a8	          JSR Mon_Blank
.b2aa	2c b3 0a	bit $0ab3	MoTr_45   BIT M_Dir
.b2ad	30 0b		bmi $b2ba	          BMI MoTr_50         ; -> backward: count down
.b2af	e6 60		inc $60		          INC M_Aval        ; count up
.b2b1	d0 10		bne $b2c3	          BNE MoTr_55
.b2b3	e6 61		inc $61		          INC M_Aval+1
.b2b5	d0 0c		bne $b2c3	          BNE MoTr_55
.b2b7	4c bc b0	jmp $b0bc	          JMP Mon_Error
.b2ba	20 22 b9	jsr $b922	MoTr_50   JSR Mon_Dec_Aval
.b2bd	20 60 b9	jsr $b960	          JSR Mon_Dec_Cval
.b2c0	4c c6 b2	jmp $b2c6	          JMP MoTr_60
.b2c3	20 50 b9	jsr $b950	MoTr_55   JSR Mon_Inc_Cval
.b2c6	20 3c b9	jsr $b93c	MoTr_60   JSR Mon_Dec_Bval
.b2c9	b0 b4		bcs $b27f	          BCS MoTr_30         ; loop
.b2cb	4c 8b b0	jmp $b08b	MoTr_65   JMP Mon_Main
.b2ce					  Mon_Hunt
.b2ce	20 83 b9	jsr $b983	          JSR Mon_Range
.b2d1	b0 61		bcs $b334	          BCS MoHu_Err
.b2d3	a0 00		ldy #$00	          LDY #0
.b2d5	20 e9 b8	jsr $b8e9	          JSR Mon_Get_Char
.b2d8	c9 27		cmp #$27	          CMP #APOSTR
.b2da	d0 16		bne $b2f2	          BNE MoHu_20         ; -> read numeric value
.b2dc	20 e9 b8	jsr $b8e9	          JSR Mon_Get_Char    ; read search string
.b2df	c9 00		cmp #$00	          CMP #0
.b2e1	f0 51		beq $b334	          BEQ MoHu_Err
.b2e3	99 80 0a	sta $0a80,y	MoHu_10   STA M_Data,Y
.b2e6	c8		iny		          INY
.b2e7	20 e9 b8	jsr $b8e9	          JSR Mon_Get_Char
.b2ea	f0 1b		beq $b307	          BEQ MoHu_40
.b2ec	c0 20		cpy #$20	          CPY #32             ; maximum length of search pattern
.b2ee	d0 f3		bne $b2e3	          BNE MoHu_10
.b2f0	f0 15		beq $b307	          BEQ MoHu_40         ; always
.b2f2	8c 00 01	sty $0100	MoHu_20   STY STACK
.b2f5	20 a5 b7	jsr $b7a5	          JSR Mon_Get_Aval    ; get numeric value
.b2f8	a5 60		lda $60		MoHu_30   LDA M_Aval
.b2fa	99 80 0a	sta $0a80,y	          STA M_Data,Y
.b2fd	c8		iny		          INY
.b2fe	20 a7 b7	jsr $b7a7	          JSR Mon_Got_Aval
.b301	b0 04		bcs $b307	          BCS MoHu_40         ; -> end of arguments
.b303	c0 20		cpy #$20	          CPY #32             ; maximum length of search pattern
.b305	d0 f1		bne $b2f8	          BNE MoHu_30
.b307	84 93		sty $93		MoHu_40   STY K_VERCK         ; length of hunt string
.b309	20 b4 b8	jsr $b8b4	          JSR Mon_CR
.b30c	a0 00		ldy #$00	MoHu_50   LDY #0              ; start comparison
.b30e	20 1a b1	jsr $b11a	MoHu_60   JSR Mon_Fetch
.b311	d9 80 0a	cmp $0a80,y	          CMP M_Data,Y
.b314	d0 0e		bne $b324	          BNE MoHu_70         ; -> no match
.b316	c8		iny		          INY
.b317	c4 93		cpy $93		          CPY K_VERCK
.b319	d0 f3		bne $b30e	          BNE MoHu_60         ; -> more to compare
.b31b	20 92 b8	jsr $b892	          JSR Mon_Hex_Cval        ; print matching address
.b31e	20 a8 b8	jsr $b8a8	          JSR Mon_Blank
.b321	20 a8 b8	jsr $b8a8	          JSR Mon_Blank
.b324	20 e1 ff	jsr $ffe1	MoHu_70   JSR K_STOP          ; check for stop key
.b327	f0 08		beq $b331	          BEQ MoHu_80         ; -> user stop
.b329	20 50 b9	jsr $b950	          JSR Mon_Inc_Cval    ; increment comparison address
.b32c	20 3c b9	jsr $b93c	          JSR Mon_Dec_Bval    ; decrement comparison counter
.b32f	b0 db		bcs $b30c	          BCS MoHu_50         ; -> loop
.b331	4c 8b b0	jmp $b08b	MoHu_80   JMP Mon_Main
.b334	4c bc b0	jmp $b0bc	MoHu_Err  JMP Mon_Error
.b337					  Mon_Load_Save
.b337	a0 01		ldy #$01	          LDY #1              ; Y = 1
.b339	84 ba		sty $ba		          STY FA              ; default device = 1 (tape)
.b33b	84 b9		sty $b9		          STY SA              ; default secondary address = 1
.b33d	88		dey		          DEY                 ; Y = 0
.b33e	84 c6		sty $c6		          STY BA              ; default bank = 0
.b340	84 b7		sty $b7		          STY FNLEN           ; no filename
.b342	84 c7		sty $c7		          STY FNBANK          ; default filename bank = 0
.b344	84 90		sty $90		          STY STATUS          ; Clear STATUS
.b346	a9 0a		lda #$0a	          LDA #>M_Data          ; put filename into M_Data
.b348	85 bc		sta $bc		          STA FNADR+1
.b34a	a9 80		lda #$80	          LDA #<M_Data
.b34c	85 bb		sta $bb		          STA FNADR
.b34e	20 e9 b8	jsr $b8e9	MLS_10    JSR Mon_Get_Char
.b351	f0 58		beq $b3ab	          BEQ MLS_60          ; -> finished
.b353	c9 20		cmp #$20	          CMP #' '
.b355	f0 f7		beq $b34e	          BEQ MLS_10          ; -> skip blanks
.b357	c9 22		cmp #$22	          CMP #QUOTE
.b359	d0 15		bne $b370	          BNE MLS_30          ; -> error: no quote
.b35b	a6 7a		ldx $7a		          LDX DS_LEN          ; X = buffer pointer
.b35d	bd 00 02	lda $0200,x	MLS_20    LDA BUF,X
.b360	f0 49		beq $b3ab	          BEQ MLS_60          ; -> end of buffer
.b362	e8		inx		          INX
.b363	c9 22		cmp #$22	          CMP #QUOTE
.b365	f0 0c		beq $b373	          BEQ MLS_40          ; -> end of string
.b367	91 bb		sta ($bb),y	          STA (FNADR),Y       ; store filename character
.b369	e6 b7		inc $b7		          INC FNLEN           ; update length
.b36b	c8		iny		          INY                 ; increase length
.b36c	c0 11		cpy #$11	          CPY #17             ; length < 17 ?
.b36e	90 ed		bcc $b35d	          BCC MLS_20          ; -> OK loop
.b370	4c bc b0	jmp $b0bc	MLS_30    JMP Mon_Error
.b373	86 7a		stx $7a		MLS_40    STX DS_LEN          ; save buffer pointer
.b375	20 e9 b8	jsr $b8e9	          JSR Mon_Get_Char    ; more parameter ?
.b378	f0 31		beq $b3ab	          BEQ MLS_60          ; -> no
.b37a	20 a7 b7	jsr $b7a7	          JSR Mon_Got_Aval    ; read numeric value
.b37d	b0 2c		bcs $b3ab	          BCS MLS_60          ; -> none
.b37f	a5 60		lda $60		          LDA M_Aval
.b381	85 ba		sta $ba		          STA FA              ; store value as device address
.b383	20 a7 b7	jsr $b7a7	          JSR Mon_Got_Aval    ; read next value
.b386	b0 23		bcs $b3ab	          BCS MLS_60          ; -> none
.b388	20 01 b9	jsr $b901	          JSR Mon_Aval_To_Cval    ; Cval = start address and bank
.b38b	85 c6		sta $c6		          STA BA              ; store bank from Aval+2
.b38d	20 a7 b7	jsr $b7a7	          JSR Mon_Got_Aval    ; read next value
.b390	b0 3f		bcs $b3d1	          BCS MLS_80          ; -> none
.b392	20 b4 b8	jsr $b8b4	          JSR Mon_CR
.b395	a6 60		ldx $60		          LDX M_Aval          ; (X/Y) = end address
.b397	a4 61		ldy $61		          LDY M_Aval+1
.b399	a5 93		lda $93		          LDA K_VERCK         ; 'L', 'S' or 'V'
.b39b	c9 53		cmp #$53	          CMP #'S'            ; SAVE ?
.b39d	d0 d1		bne $b370	          BNE MLS_30          ; -> error: end address only with SAVE
.b39f	a9 00		lda #$00	          LDA #0
.b3a1	85 b9		sta $b9		          STA SA
.b3a3	a9 66		lda #$66	          LDA #M_Cval         ; address of start address
.b3a5	20 d8 ff	jsr $ffd8	          JSR K_SAVESP        ; perform SAVE
.b3a8	4c 8b b0	jmp $b08b	MLS_50    JMP Mon_Main
.b3ab	a5 93		lda $93		MLS_60    LDA K_VERCK         ; mode
.b3ad	c9 56		cmp #$56	          CMP #'V'            ; VERIFY ?
.b3af	f0 06		beq $b3b7	          BEQ MLS_70
.b3b1	c9 4c		cmp #$4c	          CMP #'L'            ; LOAD ?
.b3b3	d0 bb		bne $b370	          BNE MLS_30          ; -> error: neither VERIFY nor LOAD
.b3b5	a9 00		lda #$00	          LDA #0              ; 0 = LOAD
.b3b7	20 d5 ff	jsr $ffd5	MLS_70    JSR K_LOADSP        ; perform LOAD or VERIFY
.b3ba	a5 90		lda $90		          LDA STATUS
.b3bc	29 10		and #$10	          AND #%00010000     ; $10 check verify error flag
.b3be	f0 e8		beq $b3a8	          BEQ MLS_50          ; -> OK
.b3c0	a5 93		lda $93		          LDA K_VERCK
.b3c2	f0 ac		beq $b370	          BEQ MLS_30          ; was loading -> OK
.b3c4	20 7d ff	jsr $ff7d	          JSR K_PRIMM         ; start verify error message
>b3c7	20 45 52 52 4f 52 00		          .TEXT " ERROR",0
.b3ce	4c 8b b0	jmp $b08b	          JMP Mon_Main
.b3d1	a6 66		ldx $66		MLS_80    LDX M_Cval
.b3d3	a4 67		ldy $67		          LDY M_Cval+1
.b3d5	a9 00		lda #$00	          LDA #0
.b3d7	85 b9		sta $b9		          STA SA
.b3d9	f0 d0		beq $b3ab	          BEQ MLS_60
.b3db					  Mon_Fill
.b3db	20 83 b9	jsr $b983	          JSR Mon_Range       ; get fill range
.b3de	b0 23		bcs $b403	          BCS MoFi_Err        ; -> error
.b3e0	a5 68		lda $68		          LDA M_Cval+2
.b3e2	cd b9 0a	cmp $0ab9	          CMP M_Temp+2        ; compare bank in range
.b3e5	d0 1c		bne $b403	          BNE MoFi_Err
.b3e7	20 a7 b7	jsr $b7a7	          JSR Mon_Got_Aval    ; iAval = fill byte
.b3ea	b0 17		bcs $b403	          BCS MoFi_Err
.b3ec	a0 00		ldy #$00	          LDY #0
.b3ee	a5 60		lda $60		MoFi_10   LDA M_Aval          ; fill byte
.b3f0	20 2a b1	jsr $b12a	          JSR Mon_Stash       ; store it
.b3f3	20 e1 ff	jsr $ffe1	          JSR K_STOP
.b3f6	f0 08		beq $b400	          BEQ MoFi_20
.b3f8	20 50 b9	jsr $b950	          JSR Mon_Inc_Cval    ; increment fill address
.b3fb	20 3c b9	jsr $b93c	          JSR Mon_Dec_Bval    ; decrement fill count
.b3fe	b0 ee		bcs $b3ee	          BCS MoFi_10         ; -> loop
.b400	4c 8b b0	jmp $b08b	MoFi_20   JMP Mon_Main
.b403	4c bc b0	jmp $b0bc	MoFi_Err  JMP Mon_Error
.b406					  Mon_Assemble
.b406	b0 3a		bcs $b442	          BCS MoAs_20         ; -> error: missing PC address
.b408	20 01 b9	jsr $b901	          JSR Mon_Aval_To_Cval    ; Cval := PC
.b40b	a2 00		ldx #$00	MoAs_10   LDX #0
.b40d	8e a1 0a	stx $0aa1	          STX M_Operand+1
.b410	8e b4 0a	stx $0ab4	          STX M_Count
.b413	20 e9 b8	jsr $b8e9	MoAs_12   JSR Mon_Get_Char
.b416	d0 07		bne $b41f	          BNE MoAs_14         ; -> continue
.b418	e0 00		cpx #$00	          CPX #0
.b41a	d0 03		bne $b41f	          BNE MoAs_14
.b41c	4c 8b b0	jmp $b08b	          JMP Mon_Main        ; -> no input after address
.b41f	c9 20		cmp #$20	MoAs_14   CMP #' '
.b421	f0 e8		beq $b40b	          BEQ MoAs_10         ; -> skip blank
.b423	9d ac 0a	sta $0aac,x	          STA M_Mne,X         ; store mnemonic character
.b426	e8		inx		          INX
.b427	e0 03		cpx #$03	          CPX #3              ; length of a mnemonic
.b429	d0 e8		bne $b413	          BNE MoAs_12         ; -> loop for more
.b42b	ca		dex		MoAs_16   DEX                 ; x = mnemonix index
.b42c	30 17		bmi $b445	          BMI MoAs_22         ; -> loop finished
.b42e	bd ac 0a	lda $0aac,x	          LDA M_Mne,X         ; A = mnemonic charcater
.b431	38		sec		          SEC
.b432	e9 3f		sbc #$3f	          SBC #$3f            ; convert to 5-bit value
.b434	a0 05		ldy #$05	          LDY #5
.b436	4a		lsr a		MoAs_18   LSR A               ; rotate 5-bit value into (M_Operand)
.b437	6e a1 0a	ror $0aa1	          ROR M_Operand+1
.b43a	6e a0 0a	ror $0aa0	          ROR M_Operand
.b43d	88		dey		          DEY
.b43e	d0 f6		bne $b436	          BNE MoAs_18         ; -> loop bits of 5-bit character
.b440	f0 e9		beq $b42b	          BEQ MoAs_16         ; -> loop mnemonic charcters
.b442	4c bc b0	jmp $b0bc	MoAs_20   JMP Mon_Error       ; -> error exit
.b445	a2 02		ldx #$02	MoAs_22   LDX #2              ; store operand after compressed mnemonic
.b447	ad b4 0a	lda $0ab4	MoAs_24   LDA M_Count         ; unread bytes in buffer
.b44a	d0 30		bne $b47c	          BNE MoAs_34         ; -> more to read
.b44c	20 ce b7	jsr $b7ce	          JSR Mon_Eval        ; evaluate operand
.b44f	f0 29		beq $b47a	          BEQ MoAs_32         ; -> no characters evaluated
.b451	b0 ef		bcs $b442	          BCS MoAs_20         ; -> error during evaluation
.b453	a9 24		lda #$24	          LDA #'$'
.b455	9d a0 0a	sta $0aa0,x	          STA M_Operand,X     ; start operand with '$'
.b458	e8		inx		          INX
.b459	a5 62		lda $62		          LDA M_Aval+2        ; check bank byte of operand
.b45b	d0 e5		bne $b442	          BNE MoAs_20         ; -> error: not allowed
.b45d	a0 04		ldy #$04	          LDY #4              ; default length of address
.b45f	ad b6 0a	lda $0ab6	          LDA M_Shift         ; base (16,10,8,2)
.b462	c9 08		cmp #$08	          CMP #8
.b464	90 05		bcc $b46b	          BCC MoAs_26         ; -> base = 2
.b466	cc b4 0a	cpy $0ab4	          CPY M_Count
.b469	f0 06		beq $b471	          BEQ MoAs_28         ; -> no fillup necessary
.b46b	a5 61		lda $61		MoAs_26   LDA M_Aval+1        ; high byte
.b46d	d0 02		bne $b471	          BNE MoAs_28         ; -> not zero
.b46f	a0 02		ldy #$02	          LDY #2              ; insert '00' for high byte
.b471	a9 30		lda #$30	MoAs_28   LDA #'0'            ; insert leading zero
.b473	9d a0 0a	sta $0aa0,x	MoAs_30   STA M_Operand,X
.b476	e8		inx		          INX
.b477	88		dey		          DEY
.b478	d0 f9		bne $b473	          BNE MoAs_30         ; loop for leading 0
.b47a	c6 7a		dec $7a		MoAs_32   DEC DS_LEN
.b47c	20 e9 b8	jsr $b8e9	MoAs_34   JSR Mon_Get_Char
.b47f	f0 0e		beq $b48f	          BEQ MoAs_36         ; -> end of operand
.b481	c9 20		cmp #$20	          CMP #' '
.b483	f0 c2		beq $b447	          BEQ MoAs_24         ; skip blank
.b485	9d a0 0a	sta $0aa0,x	          STA M_Operand,X          ; store operand byte
.b488	e8		inx		          INX
.b489	e0 0a		cpx #$0a	          CPX #10             ; maximum operand length
.b48b	90 ba		bcc $b447	          BCC MoAs_24         ; loop
.b48d	b0 b3		bcs $b442	          BCS MoAs_20         ; -> error: operand too long
.b48f	86 63		stx $63		MoAs_36   STX M_Bval          ; save X
.b491	a2 00		ldx #$00	          LDX #0
.b493	8e b1 0a	stx $0ab1	          STX M_Opcode
.b496	a2 00		ldx #$00	MoAs_38   LDX #0              ; loop body for next opcode
.b498	86 9f		stx $9f		          STX PTR_HI            ; reset operand index
.b49a	ad b1 0a	lda $0ab1	          LDA M_Opcode
.b49d	20 59 b6	jsr $b659	          JSR Mon_Analyze_Opcode
.b4a0	ae aa 0a	ldx $0aaa	          LDX M_Format
.b4a3	86 64		stx $64		          STX M_Bval+1        ; save operand format
.b4a5	aa		tax		          TAX
.b4a6	bd 61 b7	lda $b761,x	          LDA Mon_Mne_Right,X     ; compressed left  half of mnemonic
.b4a9	20 7f b5	jsr $b57f	          JSR Mon_Match_Operand
.b4ac	bd 21 b7	lda $b721,x	          LDA Mon_Mne_Left,X      ; compressed right half of mnemonic
.b4af	20 7f b5	jsr $b57f	          JSR Mon_Match_Operand   ;  6  5  4  3  2  1
.b4b2	a2 06		ldx #$06	          LDX #6              ;  $  (  #  ,  )  ,
.b4b4	e0 03		cpx #$03	MoAs_40   CPX #3              ; ",X" mode
.b4b6	d0 14		bne $b4cc	          BNE MoAs_44
.b4b8	ac ab 0a	ldy $0aab	          LDY M_Op_Size
.b4bb	f0 0f		beq $b4cc	          BEQ MoAs_44         ; -> no operand
.b4bd	ad aa 0a	lda $0aaa	MoAs_42   LDA M_Format
.b4c0	c9 e8		cmp #$e8	          CMP #$e8            ; 11101 << 3 (2 byte instructions)
.b4c2	a9 30		lda #$30	          LDA #'0'            ; high byte
.b4c4	b0 1e		bcs $b4e4	          BCS MoAs_48         ; -> not a ZP mode
.b4c6	20 7c b5	jsr $b57c	          JSR Mon_Match_Double    ; match "00"
.b4c9	88		dey		          DEY
.b4ca	d0 f1		bne $b4bd	          BNE MoAs_42
.b4cc	0e aa 0a	asl $0aaa	MoAs_44   ASL M_Format        ; next address mode bit
.b4cf	90 0e		bcc $b4df	          BCC MoAs_46         ; -> not set
.b4d1	bd 14 b7	lda $b714,x	          LDA Mon_Char1-1,X
.b4d4	20 7f b5	jsr $b57f	          JSR Mon_Match_Operand   ; match 1st. character
.b4d7	bd 1a b7	lda $b71a,x	          LDA Mon_Char2-1,X
.b4da	f0 03		beq $b4df	          BEQ MoAs_46
.b4dc	20 7f b5	jsr $b57f	          JSR Mon_Match_Operand   ; match 2nd. character
.b4df	ca		dex		MoAs_46   DEX
.b4e0	d0 d2		bne $b4b4	          BNE MoAs_40         ; -> loop next M_Format bit
.b4e2	f0 06		beq $b4ea	          BEQ MoAs_50         ; -> always
.b4e4	20 7c b5	jsr $b57c	MoAs_48   JSR Mon_Match_Double    ; match "00"
.b4e7	20 7c b5	jsr $b57c	          JSR Mon_Match_Double    ; match "00"
.b4ea	a5 63		lda $63		MoAs_50   LDA M_Bval
.b4ec	c5 9f		cmp $9f		          CMP PTR_HI            ; operand index
.b4ee	f0 03		beq $b4f3	          BEQ MoAs_52
.b4f0	4c 8b b5	jmp $b58b	          JMP MaOp_10
.b4f3	ac ab 0a	ldy $0aab	MoAs_52   LDY M_Op_Size
.b4f6	f0 32		beq $b52a	          BEQ MoAs_62         ; -> implicit mode
.b4f8	a5 64		lda $64		          LDA M_Bval+1        ; copy of M_Format
.b4fa	c9 9d		cmp #$9d	          CMP #$9d            ; relative (branches)
.b4fc	d0 23		bne $b521	          BNE MoAs_58         ; -> no
.b4fe	a5 60		lda $60		          LDA M_Aval          ; handle branch instruction
.b500	e5 66		sbc $66		          SBC M_Cval
.b502	aa		tax		          TAX                 ; X = low byte of distance
.b503	a5 61		lda $61		          LDA M_Aval+1
.b505	e5 67		sbc $67		          SBC M_Cval+1
.b507	90 08		bcc $b511	          BCC MoAs_54
.b509	d0 6e		bne $b579	          BNE MoAs_Err        ; error: branch out of range
.b50b	e0 82		cpx #$82	          CPX #$82
.b50d	b0 6a		bcs $b579	          BCS MoAs_Err        ; error: branch out of range
.b50f	90 08		bcc $b519	          BCC MoAs_56         ; always
.b511	a8		tay		MoAs_54   TAY
.b512	c8		iny		          INY
.b513	d0 64		bne $b579	          BNE MoAs_Err
.b515	e0 82		cpx #$82	          CPX #$82
.b517	90 60		bcc $b579	          BCC MoAs_Err
.b519	ca		dex		MoAs_56   DEX                 ; adjust distance by subtracting 2
.b51a	ca		dex		          DEX
.b51b	8a		txa		          TXA
.b51c	ac ab 0a	ldy $0aab	          LDY M_Op_Size
.b51f	d0 03		bne $b524	          BNE MoAs_60         ; -> implicit mode
.b521	b9 5f 00	lda $005f,y	MoAs_58   LDA FACTPB+1,Y      ; store operand bytes
.b524	20 2a b1	jsr $b12a	MoAs_60   JSR Mon_Stash
.b527	88		dey		          DEY
.b528	d0 f7		bne $b521	          BNE MoAs_58
.b52a	ad b1 0a	lda $0ab1	MoAs_62   LDA M_Opcode
.b52d	20 2a b1	jsr $b12a	          JSR Mon_Stash       ; store opcode
.b530	20 ad b8	jsr $b8ad	          JSR Mon_BOL         ; Beginnig Of Line
.b533	20 7d ff	jsr $ff7d	          JSR K_PRIMM
>b536	41 20 1b 51 00			          .TEXT "A ",ESC,"Q",0
.b53b	20 dc b5	jsr $b5dc	          JSR Mon_Print_Code  ; print disassembled instruction
.b53e	ee ab 0a	inc $0aab	          INC M_Op_Size
.b541	ad ab 0a	lda $0aab	          LDA M_Op_Size
.b544	20 52 b9	jsr $b952	          JSR Mon_Add_Cval
.b547	a9 41		lda #$41	          LDA #'A'            ; A bxxxx " into keyboard buffer
.b549	8d 4a 03	sta $034a	          STA KEYD
.b54c	a9 20		lda #$20	          LDA #' '
.b54e	8d 4b 03	sta $034b	          STA KEYD+1
.b551	8d 51 03	sta $0351	          STA KEYD+7
.b554	a5 68		lda $68		          LDA M_Cval+2
.b556	20 d2 b8	jsr $b8d2	          JSR Mon_Bin_To_Hex
.b559	8e 4c 03	stx $034c	          STX KEYD+2          ; bank
.b55c	a5 67		lda $67		          LDA M_Cval+1
.b55e	20 d2 b8	jsr $b8d2	          JSR Mon_Bin_To_Hex
.b561	8d 4d 03	sta $034d	          STA KEYD+3          ; high byte
.b564	8e 4e 03	stx $034e	          STX KEYD+4
.b567	a5 66		lda $66		          LDA M_Cval
.b569	20 d2 b8	jsr $b8d2	          JSR Mon_Bin_To_Hex
.b56c	8d 4f 03	sta $034f	          STA KEYD+5          ; low byte
.b56f	8e 50 03	stx $0350	          STX KEYD+6
.b572	a9 08		lda #$08	          LDA #8              ; force length of keyboard buffer
.b574	85 d0		sta $d0		          STA NDX
.b576	4c 8b b0	jmp $b08b	          JMP Mon_Main
.b579	4c bc b0	jmp $b0bc	MoAs_Err  JMP Mon_Error
.b57c					  Mon_Match_Double
.b57c	20 7f b5	jsr $b57f	          JSR Mon_Match_Operand
.b57f					  Mon_Match_Operand
.b57f	8e af 0a	stx $0aaf	          STX M_Save_XR       ; save X
.b582	a6 9f		ldx $9f		          LDX PTR_HI            ; operand index
.b584	dd a0 0a	cmp $0aa0,x	          CMP M_Operand,X          ; compare A with operand byte
.b587	f0 0a		beq $b593	          BEQ MaOp_20         ; -> match
.b589	68		pla		          PLA
.b58a	68		pla		          PLA                 ; remove return address
.b58b	ee b1 0a	inc $0ab1	MaOp_10   INC M_Opcode          ; next opcode
.b58e	f0 e9		beq $b579	          BEQ MoAs_Err        ; -> error: no matching code found
.b590	4c 96 b4	jmp $b496	          JMP MoAs_38         ; -> try next opcode
.b593	e6 9f		inc $9f		MaOp_20   INC PTR_HI            ; increase operand index
.b595	ae af 0a	ldx $0aaf	          LDX M_Save_XR       ; restore X
.b598	60		rts		          RTS
.b599					  Mon_Disassemble
.b599	b0 08		bcs $b5a3	          BCS MoDi_10         ; -> no range: disassemble 20 lines
.b59b	20 01 b9	jsr $b901	          JSR Mon_Aval_To_Cval    ; Cval := start of disassembly
.b59e	20 a7 b7	jsr $b7a7	          JSR Mon_Got_Aval    ; Aval := end   of disassembly
.b5a1	90 06		bcc $b5a9	          BCC MoDi_12
.b5a3	a9 14		lda #$14	MoDi_10   LDA #20
.b5a5	85 60		sta $60		          STA M_Aval
.b5a7	d0 05		bne $b5ae	          BNE MoDi_14         ; always
.b5a9	20 0e b9	jsr $b90e	MoDi_12   JSR Mon_Aval_Minus_Cval ; Aval := range
.b5ac	90 23		bcc $b5d1	          BCC MoDi_Err
.b5ae	20 7d ff	jsr $ff7d	MoDi_14   JSR K_PRIMM
>b5b1	0d 1b 51 00			          .BYTE CR,ESC,"Q",0  ; CR, delete to end of line
.b5b5	20 e1 ff	jsr $ffe1	          JSR K_STOP
.b5b8	f0 14		beq $b5ce	          BEQ MoDi_End
.b5ba	20 d4 b5	jsr $b5d4	          JSR Mon_Dis_Code    ; Disassembler instruction
.b5bd	ee ab 0a	inc $0aab	          INC M_Op_Size      ; add opcode to operand length
.b5c0	ad ab 0a	lda $0aab	          LDA M_Op_Size      ; total length of instruction
.b5c3	20 52 b9	jsr $b952	          JSR Mon_Add_Cval    ; advance Cval
.b5c6	ad ab 0a	lda $0aab	          LDA M_Op_Size
.b5c9	20 24 b9	jsr $b924	          JSR Mon_Sub_Aval    ; subtract length from range
.b5cc	b0 e0		bcs $b5ae	          BCS MoDi_14         ; -> loop
.b5ce	4c 8b b0	jmp $b08b	MoDi_End  JMP Mon_Main
.b5d1	4c bc b0	jmp $b0bc	MoDi_Err  JMP Mon_Error
.b5d4					  Mon_Dis_Code
.b5d4	a9 2e		lda #$2e	          LDA #'.'
.b5d6	20 d2 ff	jsr $ffd2	          JSR K_BSOUT
.b5d9	20 a8 b8	jsr $b8a8	          JSR Mon_Blank
.b5dc					  Mon_Print_Code
.b5dc	20 92 b8	jsr $b892	          JSR Mon_Hex_Cval        ; format address
.b5df	20 a8 b8	jsr $b8a8	          JSR Mon_Blank
.b5e2	a0 00		ldy #$00	          LDY #0
.b5e4	20 1a b1	jsr $b11a	          JSR Mon_Fetch
.b5e7	20 59 b6	jsr $b659	          JSR Mon_Analyze_Opcode
.b5ea	48		pha		          PHA                 ; push opcode
.b5eb	ae ab 0a	ldx $0aab	          LDX M_Op_Size      ; operand length
.b5ee	e8		inx		          INX                 ; plus opcode
.b5ef	ca		dex		MoPC_10   DEX
.b5f0	10 0a		bpl $b5fc	          BPL MoPC_15         ; -> opcode present
.b5f2	20 7d ff	jsr $ff7d	          JSR K_PRIMM
>b5f5	20 20 20 00			          .TEXT "   ",0       ; no opcode, print blanks
.b5f9	4c 02 b6	jmp $b602	          JMP MoPC_20
.b5fc	20 1a b1	jsr $b11a	MoPC_15   JSR Mon_Fetch       ; get instruction byte
.b5ff	20 a5 b8	jsr $b8a5	          JSR Mon_Hex_Blank   ; print it
.b602	c8		iny		MoPC_20   INY
.b603	c0 03		cpy #$03	          CPY #3              ; up to three bytes
.b605	90 e8		bcc $b5ef	          BCC MoPC_10         ; -> loop
.b607	68		pla		          PLA                 ; pull opcode
.b608	a2 03		ldx #$03	          LDX #3              ; print 3 character
.b60a	20 a1 b6	jsr $b6a1	          JSR Mon_Mnemonic
.b60d	a2 06		ldx #$06	          LDX #6              ; process 6 format bits
.b60f	e0 03		cpx #$03	MoPC_25   CPX #3              ; ,X mode
.b611	d0 17		bne $b62a	          BNE MoPC_35
.b613	ac ab 0a	ldy $0aab	          LDY M_Op_Size      ; operand length
.b616	f0 12		beq $b62a	          BEQ MoPC_35         ; -> no operand
.b618	ad aa 0a	lda $0aaa	MoPC_30   LDA M_Format
.b61b	c9 e8		cmp #$e8	          CMP #$e8            ; 11101 << 3 (2 byte instructions)
.b61d	08		php		          PHP
.b61e	20 1a b1	jsr $b11a	          JSR Mon_Fetch       ; get operand byte
.b621	28		plp		          PLP
.b622	b0 1d		bcs $b641	          BCS MoPC_50         ; -> not a ZP mode
.b624	20 c2 b8	jsr $b8c2	          JSR Mon_Hex
.b627	88		dey		          DEY
.b628	d0 ee		bne $b618	          BNE MoPC_30
.b62a	0e aa 0a	asl $0aaa	MoPC_35   ASL M_Format
.b62d	90 0e		bcc $b63d	          BCC MoPC_40
.b62f	bd 14 b7	lda $b714,x	          LDA Mon_Char1-1,X   ; 1st. char of address mode
.b632	20 d2 ff	jsr $ffd2	          JSR K_BSOUT
.b635	bd 1a b7	lda $b71a,x	          LDA Mon_Char2-1,X   ; 2nd. char of address mode
.b638	f0 03		beq $b63d	          BEQ MoPC_40
.b63a	20 d2 ff	jsr $ffd2	          JSR K_BSOUT
.b63d	ca		dex		MoPC_40   DEX
.b63e	d0 cf		bne $b60f	          BNE MoPC_25         ; loop operand format
.b640	60		rts		          RTS
.b641	20 4d b6	jsr $b64d	MoPC_50   JSR MoPC_60
.b644	18		clc		          CLC
.b645	69 01		adc #$01	          ADC #1
.b647	d0 01		bne $b64a	          BNE MoPC_55
.b649	e8		inx		          INX
.b64a	4c 9f b8	jmp $b89f	MoPC_55   JMP Mon_Hex_Word    ; print word operand
.b64d	a6 67		ldx $67		MoPC_60   LDX M_Cval+1      ; add signed (A) to Cval
.b64f	a8		tay		          TAY
.b650	10 01		bpl $b653	          BPL MoPC_65
.b652	ca		dex		          DEX
.b653	65 66		adc $66		MoPC_65   ADC M_Cval
.b655	90 01		bcc $b658	          BCC MoPC_Ret
.b657	e8		inx		          INX
.b658	60		rts		MoPC_Ret  RTS
.b659					  Mon_Analyze_Opcode
.b659	a8		tay		          TAY                 ; save opcode
.b65a	4a		lsr a		          LSR A               ; bit 0 -> carry
.b65b	90 0b		bcc $b668	          BCC AnOp_10
.b65d	4a		lsr a		          LSR A               ; bit 1 -> carry
.b65e	b0 17		bcs $b677	          BCS AnOp_30         ; 11 -> no valid opcode
.b660	c9 22		cmp #$22	          CMP #$22            ; invalid opcode $89 ?
.b662	f0 13		beq $b677	          BEQ AnOp_30
.b664	29 07		and #$07	          AND #7              ; mask addressing mode bbb
.b666	09 80		ora #$80	          ORA #$80            ; set bit 7
.b668	4a		lsr a		AnOp_10   LSR A               ; A,X = aaa bbb (cc = x0)
.b669	aa		tax		          TAX                 ; A,X = aaa bb  (cc = 10)
.b66a	bd c3 b6	lda $b6c3,x	          LDA Mon_Mode,X      ; get addressing mode index
.b66d	b0 04		bcs $b673	          BCS AnOp_20         ; branch on cc = 10
.b66f	4a		lsr a		          LSR A               ; move nibble for cc = 00
.b670	4a		lsr a		          LSR A
.b671	4a		lsr a		          LSR A
.b672	4a		lsr a		          LSR A
.b673	29 0f		and #$0f	AnOp_20   AND #15             ; mask addressing mode index
.b675	d0 04		bne $b67b	          BNE AnOp_40         ; branch for valid mode
.b677	a0 80		ldy #$80	AnOp_30   LDY #$80            ; set invalid opcode
.b679	a9 00		lda #$00	          LDA #0
.b67b	aa		tax		AnOp_40   TAX                 ; X = addressing mode index
.b67c	bd 07 b7	lda $b707,x	          LDA Mon_Address,X   ; A = addressing mode format
.b67f	8d aa 0a	sta $0aaa	          STA M_Format        ; format
.b682	29 03		and #$03	          AND #3
.b684	8d ab 0a	sta $0aab	          STA M_Op_Size
.b687	98		tya		          TYA                 ; restore opcode
.b688	29 8f		and #$8f	          AND #$8f            ; mask
.b68a	aa		tax		          TAX
.b68b	98		tya		          TYA                 ; restore opcode
.b68c	a0 03		ldy #$03	          LDY #3
.b68e	e0 8a		cpx #$8a	          CPX #$8a            ; TXS,TAX,TSX,DEX,NOP
.b690	f0 0b		beq $b69d	          BEQ AnOp_70
.b692	4a		lsr a		AnOp_50   LSR A
.b693	90 08		bcc $b69d	          BCC AnOp_70
.b695	4a		lsr a		          LSR A
.b696	4a		lsr a		AnOp_60   LSR A
.b697	09 20		ora #$20	          ORA #$20
.b699	88		dey		          DEY
.b69a	d0 fa		bne $b696	          BNE AnOp_60
.b69c	c8		iny		          INY
.b69d	88		dey		AnOp_70   DEY
.b69e	d0 f2		bne $b692	          BNE AnOp_50
.b6a0	60		rts		          RTS
.b6a1					  Mon_Mnemonic
.b6a1	a8		tay		          TAY
.b6a2	b9 21 b7	lda $b721,y	          LDA Mon_Mne_Left,Y
.b6a5	85 63		sta $63		          STA M_Bval
.b6a7	b9 61 b7	lda $b761,y	          LDA Mon_Mne_Right,Y
.b6aa	85 64		sta $64		          STA M_Bval+1
.b6ac	a9 00		lda #$00	MoMn_10   LDA #0
.b6ae	a0 05		ldy #$05	          LDY #5              ; 5 bit encoding
.b6b0	06 64		asl $64		MoMn_20   ASL M_Bval+1
.b6b2	26 63		rol $63		          ROL M_Bval
.b6b4	2a		rol a		          ROL A
.b6b5	88		dey		          DEY
.b6b6	d0 f8		bne $b6b0	          BNE MoMn_20
.b6b8	69 3f		adc #$3f	          ADC #$3f            ; add offset
.b6ba	20 d2 ff	jsr $ffd2	          JSR K_BSOUT
.b6bd	ca		dex		          DEX
.b6be	d0 ec		bne $b6ac	          BNE MoMn_10
.b6c0	4c a8 b8	jmp $b8a8	          JMP Mon_Blank
.b6c3					  Mon_Mode
>b6c3	40				          .BYTE $40           ; $4 BRK        $0 ---
>b6c4	02				          .BYTE $02           ; $0 ---        $2 ASL zz
>b6c5	45				          .BYTE $45           ; $4 PHP        $5 ASL A
>b6c6	03				          .BYTE $03           ; $0 ---        $3 ASL nnnn
>b6c7	d0				          .BYTE $d0           ; $d BPL oo     $0 ---
>b6c8	08				          .BYTE $08           ; $0 ---        $8 ASL zz,X
>b6c9	40				          .BYTE $40           ; $4 CLC        $0 ---
>b6ca	09				          .BYTE $09           ; $0 ---        $9 ASL nnnn,X
>b6cb	30				          .BYTE $30           ; $3 JSR nnnn   $0 --
>b6cc	22				          .BYTE $22           ; $2 BIT zz     $2 ROL zz
>b6cd	45				          .BYTE $45           ; $4 PLP        $5 ROL A
>b6ce	33				          .BYTE $33           ; $3 BIT nnnn   $3 ROL nnnn
>b6cf	d0				          .BYTE $d0           ; $d BMI oo     $0 ---
>b6d0	08				          .BYTE $08           ; $0 ---        $8 ROL zz,X
>b6d1	40				          .BYTE $40           ; $4 SEC        $0 ---
>b6d2	09				          .BYTE $09           ; $0 ---        $9 ROL nnnn,X
>b6d3	40				          .BYTE $40           ; $4 RTI        $0 ---
>b6d4	02				          .BYTE $02           ; $0 ---        $2 LSR zz
>b6d5	45				          .BYTE $45           ; $4 PHA        $5 LSR A
>b6d6	33				          .BYTE $33           ; $3 JMP nnnn   $3 LSR nnnn
>b6d7	d0				          .BYTE $d0           ; $d BVC oo     $0 ---
>b6d8	08				          .BYTE $08           ; $0 ---        $8 LSR zz,X
>b6d9	40				          .BYTE $40           ; $4 CLI        $0 ---
>b6da	09				          .BYTE $09           ; $0 ---        $9 LSR nnnn,X
>b6db	40				          .BYTE $40           ; $4 RTS        $0 ---
>b6dc	02				          .BYTE $02           ; $0 ---        $2 ROR zz
>b6dd	45				          .BYTE $45           ; $4 PLA        $5 ROR A
>b6de	b3				          .BYTE $b3           ; $b JMP (nnnn) $3 ROR nnnn
>b6df	d0				          .BYTE $d0           ; $d BVS oo     $0 ---
>b6e0	08				          .BYTE $08           ; $0 ---        $8 ROR zz,X
>b6e1	40				          .BYTE $40           ; $4 SEI        $0 ---
>b6e2	09				          .BYTE $09           ; $0 ---        $9 ROR nnnn,X
>b6e3	00				          .BYTE $00           ; $0 ---        $0 ---
>b6e4	22				          .BYTE $22           ; $2 STY zz     $2 STX zz
>b6e5	44				          .BYTE $44           ; $4 DEY        $4 TXA
>b6e6	33				          .BYTE $33           ; $3 STY nnnn   $3 STX nnnn
>b6e7	d0				          .BYTE $d0           ; $d BCC oo     $0 ---
>b6e8	8c				          .BYTE $8c           ; $8 STY zz,X   $c STX zz,Y
>b6e9	44				          .BYTE $44           ; $4 TYA        $4 TXS
>b6ea	00				          .BYTE $00           ; $0 ---        $0 ---
>b6eb	11				          .BYTE $11           ; $1 LDY #      $1 LDX #
>b6ec	22				          .BYTE $22           ; $2 LDY zz     $2 LDX zz
>b6ed	44				          .BYTE $44           ; $4 TAY        $4 TAX
>b6ee	33				          .BYTE $33           ; $3 LDY nnnn   $3 LDX nnnn
>b6ef	d0				          .BYTE $d0           ; $d BCS oo     $0 ---
>b6f0	8c				          .BYTE $8c           ; $8 LDY zz,X   $c LDX zz,Y
>b6f1	44				          .BYTE $44           ; $4 CLV        $4 TSX
>b6f2	9a				          .BYTE $9a           ; $9 LDY nnnn,X $a LDX nnnn,Y
>b6f3	10				          .BYTE $10           ; $1 CPY #      $0 ---
>b6f4	22				          .BYTE $22           ; $2 CPY zz     $2 DEC zz
>b6f5	44				          .BYTE $44           ; $4 INY        $4 DEX
>b6f6	33				          .BYTE $33           ; $3 CPY nnnn   $3 DEC nnnn
>b6f7	d0				          .BYTE $d0           ; $d BNE oo     $0 ---
>b6f8	08				          .BYTE $08           ; $0 ---        $8 DEC zz,X
>b6f9	40				          .BYTE $40           ; $4 CLD        $0 ---
>b6fa	09				          .BYTE $09           ; $0 ---        $9 DEC nnnn,X
>b6fb	10				          .BYTE $10           ; $1 CPX #      $0 ---
>b6fc	22				          .BYTE $22           ; $2 CPX zz     $2 INC zz
>b6fd	44				          .BYTE $44           ; $4 INX        $4 NOP
>b6fe	33				          .BYTE $33           ; $3 CPX nnnn   $3 INC nnnn
>b6ff	d0				          .BYTE $d0           ; $d BEQ oo     $0 ---
>b700	08				          .BYTE $08           ; $0 ---        $8 INC zz,X
>b701	40				          .BYTE $40           ; $4 SED        $0 ---
>b702	09				          .BYTE $09           ; $0 ---        $9 INC nnnn,X
>b703	62				          .BYTE $62           ; $6 (zz,X)     $2 zz
>b704	13				          .BYTE $13           ; $1 #          $3 nnnn
>b705	78				          .BYTE $78           ; $7 (zz),Y     $8 zz,X
>b706	a9				          .BYTE $a9           ; $a nnnn,Y     $9 nnnn,X
.b707					  Mon_Address
>b707	00				           .BYTE %00000000  ; 0         implicit
>b708	21				           .BYTE %00100001  ; 1  $#     immediate
>b709	81				           .BYTE %10000001  ; 2  $zz    zeropage
>b70a	82				           .BYTE %10000010  ; 3  $nnnn  absolute
>b70b	00				           .BYTE %00000000  ; 4         implicit
>b70c	00				           .BYTE %00000000  ; 5         implicit
>b70d	59				           .BYTE %01011001  ; 6 ($zz,X) indexed indirect
>b70e	4d				           .BYTE %01001101  ; 7 ($zz),Y indirect indexed
>b70f	91				           .BYTE %10010001  ; 8 $zz,X   zeropage,X
>b710	92				           .BYTE %10010010  ; 9 $nnnn,X absolute,X
>b711	86				           .BYTE %10000110  ; a $nnnn,Y absolute,Y
>b712	4a				           .BYTE %01001010  ; b ($nnnn) indirect
>b713	85				           .BYTE %10000101  ; c $zz,Y   zeropage,Y
>b714	9d				           .BYTE %10011101  ; d $nnnn   relative
>b715	2c 29 2c 23 28 24		Mon_Char1  .TEXT ",", ")", ",", "#", "(", "$"
>b71b	59 00 58 24 24 00		Mon_Char2  .TEXT "Y",  0 , "X", "$", "$",  0
.b721					  Mon_Mne_Left
>b721	1c 8a 1c 23 5d 8b 1b a1		          .BYTE $1C,$8A,$1C,$23,$5D,$8B,$1B,$A1
>b729	9d 8a 1d 23 9d 8b 1d a1		          .BYTE $9D,$8A,$1D,$23,$9D,$8B,$1D,$A1
>b731	00 29 19 ae 69 a8 19 23		          .BYTE $00,$29,$19,$AE,$69,$A8,$19,$23
>b739	24 53 1b 23 24 53 19 a1		          .BYTE $24,$53,$1B,$23,$24,$53,$19,$A1
>b741	00 1a 5b 5b a5 69 24 24		          .BYTE $00,$1A,$5B,$5B,$A5,$69,$24,$24
>b749	ae ae a8 ad 29 00 7c 00		          .BYTE $AE,$AE,$A8,$AD,$29,$00,$7C,$00
>b751	15 9c 6d 9c a5 69 29 53		          .BYTE $15,$9C,$6D,$9C,$A5,$69,$29,$53
>b759	84 13 34 11 a5 69 23 a0		          .BYTE $84,$13,$34,$11,$A5,$69,$23,$A0
.b761					  Mon_Mne_Right
>b761	d8 62 5a 48 26 62 94 88		          .BYTE $D8,$62,$5A,$48,$26,$62,$94,$88
>b769	54 44 c8 54 68 44 e8 94		          .BYTE $54,$44,$C8,$54,$68,$44,$E8,$94
>b771	00 b4 08 84 74 b4 28 6e		          .BYTE $00,$B4,$08,$84,$74,$B4,$28,$6E
>b779	74 f4 cc 4a 72 f2 a4 8a		          .BYTE $74,$F4,$CC,$4A,$72,$F2,$A4,$8A
>b781	00 aa a2 a2 74 74 74 72		          .BYTE $00,$AA,$A2,$A2,$74,$74,$74,$72
>b789	44 68 b2 32 b2 00 22 00		          .BYTE $44,$68,$B2,$32,$B2,$00,$22,$00
>b791	1a 1a 26 26 72 72 88 c8		          .BYTE $1A,$1A,$26,$26,$72,$72,$88,$C8
>b799	c4 ca 26 48 44 44 a2 c8		          .BYTE $C4,$CA,$26,$48,$44,$44,$A2,$C8
>b7a1	0d 20 20 20			          .BYTE $0D,$20,$20,$20
.b7a5					  Mon_Get_Aval
.b7a5	c6 7a		dec $7a		          DEC DS_LEN
.b7a7					  Mon_Got_Aval
.b7a7	20 ce b7	jsr $b7ce	          JSR Mon_Eval
.b7aa	b0 16		bcs $b7c2	          BCS MoGA_20
.b7ac	20 e7 b8	jsr $b8e7	          JSR Mon_Got_Char
.b7af	d0 09		bne $b7ba	          BNE MoGA_10         ; -> not at end
.b7b1	c6 7a		dec $7a		          DEC DS_LEN          ; buffer index
.b7b3	ad b4 0a	lda $0ab4	          LDA M_Count         ; bytes read
.b7b6	d0 11		bne $b7c9	          BNE MoGA_40         ; -> return with carry clear (OK)
.b7b8	f0 0d		beq $b7c7	          BEQ MoGA_30         ; -> return with carry set
.b7ba	c9 20		cmp #$20	MoGA_10   CMP #' '
.b7bc	f0 0b		beq $b7c9	          BEQ MoGA_40         ; delimiter blank
.b7be	c9 2c		cmp #$2c	          CMP #','
.b7c0	f0 07		beq $b7c9	          BEQ MoGA_40         ; delimiter comma
.b7c2	68		pla		MoGA_20   PLA
.b7c3	68		pla		          PLA                 ; remove return address
.b7c4	4c bc b0	jmp $b0bc	          JMP Mon_Error
.b7c7	38		sec		MoGA_30   SEC
>b7c8	24				          .BYTE $24           ; skip CLC
.b7c9	18		clc		MoGA_40   CLC
.b7ca	ad b4 0a	lda $0ab4	          LDA M_Count
.b7cd	60		rts		          RTS
.b7ce					  Mon_Eval
.b7ce	a9 00		lda #$00	          LDA #0              ; clear result
.b7d0	85 60		sta $60		          STA M_Aval
.b7d2	85 61		sta $61		          STA M_Aval+1
.b7d4	85 62		sta $62		          STA M_Aval+2
.b7d6	8d b4 0a	sta $0ab4	          STA M_Count         ; # of chars
.b7d9	8a		txa		          TXA                 ; save X
.b7da	48		pha		          PHA
.b7db	98		tya		          TYA                 ; save Y
.b7dc	48		pha		          PHA
.b7dd	20 e9 b8	jsr $b8e9	MoEv_10   JSR Mon_Get_Char
.b7e0	d0 03		bne $b7e5	          BNE MoEv_15
.b7e2	4c 7e b8	jmp $b87e	          JMP MoEv_65         ; -> finish
.b7e5	c9 20		cmp #$20	MoEv_15   CMP #' '
.b7e7	f0 f4		beq $b7dd	          BEQ MoEv_10         ; -> skip blanks
.b7e9	a2 03		ldx #$03	          LDX #3
.b7eb	dd f5 b0	cmp $b0f5,x	MoEv_20   CMP cmdnum,X        ; $ + & %
.b7ee	f0 06		beq $b7f6	          BEQ MoEv_25
.b7f0	ca		dex		          DEX
.b7f1	10 f8		bpl $b7eb	          BPL MoEv_20
.b7f3	e8		inx		          INX
.b7f4	c6 7a		dec $7a		          DEC DS_LEN          ; buffer index
.b7f6	bc 8a b8	ldy $b88a,x	MoEv_25   LDY Mon_Base,X      ; 16 ($), 10 (+), 8 (&), 2 (%)
.b7f9	bd 8e b8	lda $b88e,x	          LDA Mon_Shift,X     ;  4       3      3      1
.b7fc	8d b6 0a	sta $0ab6	          STA M_Shift
.b7ff	20 e9 b8	jsr $b8e9	MoEv_30   JSR Mon_Get_Char
.b802	f0 7a		beq $b87e	          BEQ MoEv_65
.b804	38		sec		          SEC
.b805	e9 30		sbc #$30	          SBC #'0'
.b807	90 75		bcc $b87e	          BCC MoEv_65         ; -> below '0' not alphanumeric
.b809	c9 0a		cmp #$0a	          CMP #10
.b80b	90 06		bcc $b813	          BCC MoEv_35         ; -> inside (0 - 9)
.b80d	e9 07		sbc #$07	          SBC #7
.b80f	c9 10		cmp #$10	          CMP #16             ; hex ?
.b811	b0 6b		bcs $b87e	          BCS MoEv_65         ; -> invalid
.b813	8d b5 0a	sta $0ab5	MoEv_35   STA M_Number          ; store digit
.b816	cc b5 0a	cpy $0ab5	          CPY M_Number          ; compare with base
.b819	90 61		bcc $b87c	          BCC MoEv_60         ; -> out of range
.b81b	f0 5f		beq $b87c	          BEQ MoEv_60         ; -> out of range
.b81d	ee b4 0a	inc $0ab4	          INC M_Count         ; # of chars
.b820	c0 0a		cpy #$0a	          CPY #10             ; base 10 ?
.b822	d0 0a		bne $b82e	          BNE MoEv_45         ; -> no
.b824	a2 02		ldx #$02	          LDX #2
.b826	b5 60		lda $60,x	MoEv_40   LDA M_Aval,X      ; TEMPS = TENEXP
.b828	9d b7 0a	sta $0ab7,x	          STA M_Temp,X
.b82b	ca		dex		          DEX
.b82c	10 f8		bpl $b826	          BPL MoEv_40
.b82e	ae b6 0a	ldx $0ab6	MoEv_45   LDX M_Shift           ; shifts for base 16, 8 or 2
.b831	06 60		asl $60		MoEv_50   ASL M_Aval
.b833	26 61		rol $61		          ROL M_Aval+1
.b835	26 62		rol $62		          ROL M_Aval+2
.b837	b0 43		bcs $b87c	          BCS MoEv_60
.b839	ca		dex		          DEX
.b83a	d0 f5		bne $b831	          BNE MoEv_50
.b83c	c0 0a		cpy #$0a	          CPY #10             ; base 10 ?
.b83e	d0 22		bne $b862	          BNE MoEv_55         ; -> no
.b840	0e b7 0a	asl $0ab7	          ASL M_Temp           ; M_Aval = TENEXP << 3 + TENEXP + TENEXP
.b843	2e b8 0a	rol $0ab8	          ROL M_Temp+1
.b846	2e b9 0a	rol $0ab9	          ROL M_Temp+2
.b849	b0 31		bcs $b87c	          BCS MoEv_60
.b84b	ad b7 0a	lda $0ab7	          LDA M_Temp
.b84e	65 60		adc $60		          ADC M_Aval
.b850	85 60		sta $60		          STA M_Aval
.b852	ad b8 0a	lda $0ab8	          LDA M_Temp+1
.b855	65 61		adc $61		          ADC M_Aval+1
.b857	85 61		sta $61		          STA M_Aval+1
.b859	ad b9 0a	lda $0ab9	          LDA M_Temp+2
.b85c	65 62		adc $62		          ADC M_Aval+2
.b85e	85 62		sta $62		          STA M_Aval+2
.b860	b0 1a		bcs $b87c	          BCS MoEv_60         ; -> overflow
.b862	18		clc		MoEv_55   CLC
.b863	ad b5 0a	lda $0ab5	          LDA M_Number
.b866	65 60		adc $60		          ADC M_Aval
.b868	85 60		sta $60		          STA M_Aval
.b86a	8a		txa		          TXA
.b86b	65 61		adc $61		          ADC M_Aval+1
.b86d	85 61		sta $61		          STA M_Aval+1
.b86f	8a		txa		          TXA
.b870	65 62		adc $62		          ADC M_Aval+2
.b872	85 62		sta $62		          STA M_Aval+2
.b874	b0 06		bcs $b87c	          BCS MoEv_60         ; -> overflow
.b876	29 f0		and #$f0	          AND #%11110000     ; check bank value
.b878	d0 02		bne $b87c	          BNE MoEv_60         ; -> overflow
.b87a	f0 83		beq $b7ff	          BEQ MoEv_30         ; -> OK
.b87c	38		sec		MoEv_60   SEC
>b87d	24				          .BYTE $24
.b87e	18		clc		MoEv_65   CLC
.b87f	8c b6 0a	sty $0ab6	          STY M_Shift
.b882	68		pla		          PLA
.b883	a8		tay		          TAY                 ; restore Y
.b884	68		pla		          PLA
.b885	aa		tax		          TAX                 ; restore X
.b886	ad b4 0a	lda $0ab4	          LDA M_Count         ; # of chars
.b889	60		rts		          RTS
>b88a	10 0a 08 02			Mon_Base  .BYTE 16,10, 8, 2   ; supported bases for input
>b88e	04 03 03 01			Mon_Shift .BYTE  4, 3, 3, 1   ; shifts for digit multiplying
.b892					  Mon_Hex_Cval
.b892	a5 68		lda $68		          LDA M_Cval+2
.b894	20 d2 b8	jsr $b8d2	          JSR Mon_Bin_To_Hex
.b897	8a		txa		          TXA
.b898	20 d2 ff	jsr $ffd2	          JSR K_BSOUT
.b89b	a5 66		lda $66		          LDA M_Cval
.b89d	a6 67		ldx $67		          LDX M_Cval+1
.b89f					  Mon_Hex_Word
.b89f	48		pha		          PHA
.b8a0	8a		txa		          TXA
.b8a1	20 c2 b8	jsr $b8c2	          JSR Mon_Hex
.b8a4	68		pla		          PLA
.b8a5					  Mon_Hex_Blank
.b8a5	20 c2 b8	jsr $b8c2	          JSR Mon_Hex
.b8a8					  Mon_Blank
.b8a8	a9 20		lda #$20	          LDA #' '
.b8aa	4c d2 ff	jmp $ffd2	          JMP K_BSOUT
.b8ad					  Mon_BOL
.b8ad	20 7d ff	jsr $ff7d	          JSR K_PRIMM
>b8b0	0d 91 00			          .BYTE CR,UP,0
.b8b3	60		rts		          RTS
.b8b4					  Mon_CR
.b8b4	a9 0d		lda #$0d	          LDA #CR
.b8b6	4c d2 ff	jmp $ffd2	          JMP K_BSOUT
.b8b9					  Mon_Blank_Line
.b8b9	20 7d ff	jsr $ff7d	          JSR K_PRIMM
>b8bc	0d 1b 51 20 00			          .TEXT CR,ESC,"Q ",0
.b8c1	60		rts		          RTS
.b8c2					  Mon_Hex
.b8c2	8e af 0a	stx $0aaf	          STX M_Save_XR
.b8c5	20 d2 b8	jsr $b8d2	          JSR Mon_Bin_To_Hex
.b8c8	20 d2 ff	jsr $ffd2	          JSR K_BSOUT
.b8cb	8a		txa		          TXA
.b8cc	ae af 0a	ldx $0aaf	          LDX M_Save_XR
.b8cf	4c d2 ff	jmp $ffd2	          JMP K_BSOUT
.b8d2					  Mon_Bin_To_Hex
.b8d2	48		pha		          PHA
.b8d3	20 dc b8	jsr $b8dc	          JSR Mon_Nib_Hex
.b8d6	aa		tax		          TAX
.b8d7	68		pla		          PLA
.b8d8	4a		lsr a		          LSR A
.b8d9	4a		lsr a		          LSR A
.b8da	4a		lsr a		          LSR A
.b8db	4a		lsr a		          LSR A
.b8dc					  Mon_Nib_Hex
.b8dc	29 0f		and #$0f	          AND #15
.b8de	c9 0a		cmp #$0a	          CMP #10
.b8e0	90 02		bcc $b8e4	          BCC MoNH_10
.b8e2	69 06		adc #$06	          ADC #6
.b8e4	69 30		adc #$30	MoNH_10   ADC #'0'
.b8e6	60		rts		          RTS
.b8e7					  Mon_Got_Char
.b8e7	c6 7a		dec $7a		          DEC DS_LEN
.b8e9					  Mon_Get_Char
.b8e9	8e af 0a	stx $0aaf	          STX M_Save_XR       ; save X
.b8ec	a6 7a		ldx $7a		          LDX DS_LEN          ; buffer index
.b8ee	bd 00 02	lda $0200,x	          LDA BUF,X
.b8f1	f0 06		beq $b8f9	          BEQ MGNC_10         ; zero -> exit
.b8f3	c9 3a		cmp #$3a	          CMP #':'
.b8f5	f0 02		beq $b8f9	          BEQ MGNC_10         ; set Z flag for ':'
.b8f7	c9 3f		cmp #$3f	          CMP #'?'            ; set Z flag for '?'
.b8f9	08		php		MGNC_10   PHP                 ; push flags
.b8fa	e6 7a		inc $7a		          INC DS_LEN          ; buffer index
.b8fc	ae af 0a	ldx $0aaf	          LDX M_Save_XR       ; restore X
.b8ff	28		plp		          PLP                 ; pull flags
.b900	60		rts		          RTS
.b901					  Mon_Aval_To_Cval
.b901	a5 60		lda $60		          LDA M_Aval
.b903	85 66		sta $66		          STA M_Cval
.b905	a5 61		lda $61		          LDA M_Aval+1
.b907	85 67		sta $67		          STA M_Cval+1
.b909	a5 62		lda $62		          LDA M_Aval+2
.b90b	85 68		sta $68		          STA M_Cval+2
.b90d	60		rts		          RTS
.b90e					  Mon_Aval_Minus_Cval
.b90e	38		sec		          SEC
.b90f	a5 60		lda $60		          LDA M_Aval
.b911	e5 66		sbc $66		          SBC M_Cval
.b913	85 60		sta $60		          STA M_Aval
.b915	a5 61		lda $61		          LDA M_Aval+1
.b917	e5 67		sbc $67		          SBC M_Cval+1
.b919	85 61		sta $61		          STA M_Aval+1
.b91b	a5 62		lda $62		          LDA M_Aval+2
.b91d	e5 68		sbc $68		          SBC M_Cval+2
.b91f	85 62		sta $62		          STA M_Aval+2
.b921	60		rts		          RTS
.b922					  Mon_Dec_Aval
.b922	a9 01		lda #$01	          LDA #1
.b924					  Mon_Sub_Aval
.b924	8d af 0a	sta $0aaf	          STA M_Save_XR
.b927	38		sec		          SEC
.b928	a5 60		lda $60		          LDA M_Aval
.b92a	ed af 0a	sbc $0aaf	          SBC M_Save_XR
.b92d	85 60		sta $60		          STA M_Aval
.b92f	a5 61		lda $61		          LDA M_Aval+1
.b931	e9 00		sbc #$00	          SBC #0
.b933	85 61		sta $61		          STA M_Aval+1
.b935	a5 62		lda $62		          LDA M_Aval+2
.b937	e9 00		sbc #$00	          SBC #0
.b939	85 62		sta $62		          STA M_Aval+2
.b93b	60		rts		          RTS
.b93c					  Mon_Dec_Bval
.b93c	38		sec		          SEC
.b93d	a5 63		lda $63		          LDA M_Bval
.b93f	e9 01		sbc #$01	          SBC #1
.b941	85 63		sta $63		          STA M_Bval
.b943	a5 64		lda $64		          LDA M_Bval+1
.b945	e9 00		sbc #$00	          SBC #0
.b947	85 64		sta $64		          STA M_Bval+1
.b949	a5 65		lda $65		          LDA M_Bval+2
.b94b	e9 00		sbc #$00	          SBC #0
.b94d	85 65		sta $65		          STA M_Bval+2
.b94f	60		rts		          RTS
.b950					  Mon_Inc_Cval
.b950	a9 01		lda #$01	          LDA #1
.b952					  Mon_Add_Cval
.b952	18		clc		          CLC
.b953	65 66		adc $66		          ADC M_Cval
.b955	85 66		sta $66		          STA M_Cval
.b957	90 06		bcc $b95f	          BCC MoAC_Ret
.b959	e6 67		inc $67		          INC M_Cval+1
.b95b	d0 02		bne $b95f	          BNE MoAC_Ret
.b95d	e6 68		inc $68		          INC M_Cval+2
.b95f	60		rts		MoAC_Ret  RTS
.b960					  Mon_Dec_Cval
.b960	38		sec		          SEC
.b961	a5 66		lda $66		          LDA M_Cval
.b963	e9 01		sbc #$01	          SBC #1
.b965	85 66		sta $66		          STA M_Cval
.b967	a5 67		lda $67		          LDA M_Cval+1
.b969	e9 00		sbc #$00	          SBC #0
.b96b	85 67		sta $67		          STA M_Cval+1
.b96d	a5 68		lda $68		          LDA M_Cval+2
.b96f	e9 00		sbc #$00	          SBC #0
.b971	85 68		sta $68		          STA M_Cval+2
.b973	60		rts		          RTS
.b974					  Mon_Aval_To_PCB
.b974	b0 0c		bcs $b982	          BCS MPCB_Ret
.b976	a5 60		lda $60		          LDA M_Aval
.b978	a4 61		ldy $61		          LDY M_Aval+1
.b97a	a6 62		ldx $62		          LDX M_Aval+2
.b97c	85 04		sta $04		          STA PC_LO
.b97e	84 03		sty $03		          STY PC_HI
.b980	86 02		stx $02		          STX BANK
.b982	60		rts		MPCB_Ret  RTS
.b983					  Mon_Range
.b983	b0 2a		bcs $b9af	          BCS MoRa_Err
.b985	20 01 b9	jsr $b901	          JSR Mon_Aval_To_Cval ; Cval  = 1st. address
.b988	20 a7 b7	jsr $b7a7	          JSR Mon_Got_Aval     ; Aval  = 2nd. address
.b98b	b0 22		bcs $b9af	          BCS MoRa_Err
.b98d	a5 60		lda $60		          LDA M_Aval           ; M_Temp = 2nd. address
.b98f	8d b7 0a	sta $0ab7	          STA M_Temp
.b992	a5 61		lda $61		          LDA M_Aval+1
.b994	8d b8 0a	sta $0ab8	          STA M_Temp+1
.b997	a5 62		lda $62		          LDA M_Aval+2
.b999	8d b9 0a	sta $0ab9	          STA M_Temp+2
.b99c	20 0e b9	jsr $b90e	          JSR Mon_Aval_Minus_Cval ; Aval = range
.b99f	a5 60		lda $60		          LDA M_Aval              ; Bval = range
.b9a1	85 63		sta $63		          STA M_Bval
.b9a3	a5 61		lda $61		          LDA M_Aval+1
.b9a5	85 64		sta $64		          STA M_Bval+1
.b9a7	a5 62		lda $62		          LDA M_Aval+2
.b9a9	85 65		sta $65		          STA M_Bval+2
.b9ab	90 02		bcc $b9af	          BCC MoRa_Err
.b9ad	18		clc		          CLC
>b9ae	24				          .BYTE $24
.b9af	38		sec		MoRa_Err  SEC
.b9b0	60		rts		          RTS
.b9b1					  Mon_Convert
.b9b1	20 a5 b7	jsr $b7a5	          JSR Mon_Get_Aval    ; read value
.b9b4	20 b9 b8	jsr $b8b9	          JSR Mon_Blank_Line
.b9b7	a9 24		lda #$24	          LDA #'$'            ; hex number
.b9b9	20 d2 ff	jsr $ffd2	          JSR K_BSOUT
.b9bc	a5 62		lda $62		          LDA M_Aval+2
.b9be	f0 07		beq $b9c7	          BEQ MoCo_10         ; bank value ?
.b9c0	20 d2 b8	jsr $b8d2	          JSR Mon_Bin_To_Hex
.b9c3	8a		txa		          TXA
.b9c4	20 d2 ff	jsr $ffd2	          JSR K_BSOUT
.b9c7	a5 60		lda $60		MoCo_10   LDA M_Aval
.b9c9	a6 61		ldx $61		          LDX M_Aval+1
.b9cb	20 9f b8	jsr $b89f	          JSR Mon_Hex_Word
.b9ce	20 b9 b8	jsr $b8b9	          JSR Mon_Blank_Line
.b9d1	a9 2b		lda #$2b	          LDA # '+'           ; decimal number
.b9d3	20 d2 ff	jsr $ffd2	          JSR K_BSOUT
.b9d6	20 07 ba	jsr $ba07	          JSR Mon_Bin_BCD
.b9d9	a9 00		lda #$00	          LDA #0              ; suppress leading zeroes
.b9db	a2 08		ldx #$08	          LDX #8              ; # of digits
.b9dd	a0 03		ldy #$03	          LDY #3              ; bits per digit - 1
.b9df	20 5d ba	jsr $ba5d	          JSR Mon_Print_Number
.b9e2	20 b9 b8	jsr $b8b9	          JSR Mon_Blank_Line
.b9e5	a9 26		lda #$26	          LDA #'&'            ; octal number
.b9e7	20 d2 ff	jsr $ffd2	          JSR K_BSOUT
.b9ea	a9 00		lda #$00	          LDA #0              ; suppress leading zeroes
.b9ec	a2 08		ldx #$08	          LDX #8              ; # of digits
.b9ee	a0 02		ldy #$02	          LDY #2              ; bits per digit - 1
.b9f0	20 47 ba	jsr $ba47	          JSR Mon_Print_Aval
.b9f3	20 b9 b8	jsr $b8b9	          JSR Mon_Blank_Line
.b9f6	a9 25		lda #$25	          LDA #'%'            ; dual number
.b9f8	20 d2 ff	jsr $ffd2	          JSR K_BSOUT
.b9fb	a9 00		lda #$00	          LDA #0              ; suppress leading zeroes
.b9fd	a2 18		ldx #$18	          LDX #24             ; # of digits
.b9ff	a0 00		ldy #$00	          LDY #0              ; bits per digit - 1
.ba01	20 47 ba	jsr $ba47	          JSR Mon_Print_Aval
.ba04	4c 8b b0	jmp $b08b	          JMP Mon_Main
.ba07					  Mon_Bin_BCD
.ba07	20 01 b9	jsr $b901	          JSR Mon_Aval_To_Cval
.ba0a	a9 00		lda #$00	          LDA #0
.ba0c	a2 07		ldx #$07	          LDX #7
.ba0e	9d a0 0a	sta $0aa0,x	MoBD_10   STA M_Operand,X
.ba11	ca		dex		          DEX
.ba12	10 fa		bpl $ba0e	          BPL MoBD_10
.ba14	ee a7 0a	inc $0aa7	          INC M_Operand+7
.ba17	a0 17		ldy #$17	          LDY #23             ; 24 bits for 3 bytes
.ba19	08		php		          PHP
.ba1a	78		sei		          SEI                 ; disable interrupt
.ba1b	f8		sed		          SED                 ; set decimal mode
.ba1c	46 68		lsr $68		MoBD_20   LSR M_Cval+2
.ba1e	66 67		ror $67		          ROR M_Cval+1
.ba20	66 66		ror $66		          ROR M_Cval
.ba22	90 0f		bcc $ba33	          BCC MoBD_40         ; -> skip adding
.ba24	18		clc		          CLC
.ba25	a2 03		ldx #$03	          LDX #3
.ba27	bd a4 0a	lda $0aa4,x	MoBD_30   LDA M_Operand+4,X
.ba2a	7d a0 0a	adc $0aa0,x	          ADC M_Operand,X
.ba2d	9d a0 0a	sta $0aa0,x	          STA M_Operand,X
.ba30	ca		dex		          DEX
.ba31	10 f4		bpl $ba27	          BPL MoBD_30
.ba33	18		clc		MoBD_40   CLC
.ba34	a2 03		ldx #$03	          LDX #3
.ba36	bd a4 0a	lda $0aa4,x	MoBD_50   LDA M_Operand+4,X
.ba39	7d a4 0a	adc $0aa4,x	          ADC M_Operand+4,X
.ba3c	9d a4 0a	sta $0aa4,x	          STA M_Operand+4,X
.ba3f	ca		dex		          DEX
.ba40	10 f4		bpl $ba36	          BPL MoBD_50         ; double M_Operand+4
.ba42	88		dey		          DEY
.ba43	10 d7		bpl $ba1c	          BPL MoBD_20         ; loop for next bit
.ba45	28		plp		          PLP                 ; clear decimal and IRQ mode
.ba46	60		rts		          RTS
.ba47					  Mon_Print_Aval
.ba47	48		pha		          PHA
.ba48	a5 60		lda $60		          LDA M_Aval
.ba4a	8d a2 0a	sta $0aa2	          STA M_Operand+2
.ba4d	a5 61		lda $61		          LDA M_Aval+1
.ba4f	8d a1 0a	sta $0aa1	          STA M_Operand+1
.ba52	a5 62		lda $62		          LDA M_Aval+2
.ba54	8d a0 0a	sta $0aa0	          STA M_Operand
.ba57	a9 00		lda #$00	          LDA #0
.ba59	8d a3 0a	sta $0aa3	          STA M_Operand+3
.ba5c	68		pla		          PLA
.ba5d					  Mon_Print_Number
.ba5d	8d b4 0a	sta $0ab4	          STA M_Count       ; suppress leading zeroes ?
.ba60	8c b6 0a	sty $0ab6	          STY M_Shift
.ba63	ac b6 0a	ldy $0ab6	MoPN_10   LDY M_Shift
.ba66	a9 00		lda #$00	          LDA #0
.ba68	0e a3 0a	asl $0aa3	MoPN_20   ASL M_Operand+3
.ba6b	2e a2 0a	rol $0aa2	          ROL M_Operand+2
.ba6e	2e a1 0a	rol $0aa1	          ROL M_Operand+1
.ba71	2e a0 0a	rol $0aa0	          ROL M_Operand
.ba74	2a		rol a		          ROL A
.ba75	88		dey		          DEY                 ; rotate SHIFT bytes into A
.ba76	10 f0		bpl $ba68	          BPL MoPN_20
.ba78	a8		tay		          TAY
.ba79	d0 09		bne $ba84	          BNE MoPN_30         ; -> print digit if not 0
.ba7b	e0 01		cpx #$01	          CPX #1
.ba7d	f0 05		beq $ba84	          BEQ MoPN_30         ; -> print digit if last
.ba7f	ac b4 0a	ldy $0ab4	          LDY M_Count
.ba82	f0 08		beq $ba8c	          BEQ MoPN_40         ; -> skip leading zeroes
.ba84	ee b4 0a	inc $0ab4	MoPN_30   INC M_Count       ; -> switch off zero suppression
.ba87	09 30		ora #$30	          ORA #'0'            ; convert digit to ASCII
.ba89	20 d2 ff	jsr $ffd2	          JSR K_BSOUT         ; print it
.ba8c	ca		dex		MoPN_40   DEX                 ; # of digits
.ba8d	d0 d4		bne $ba63	          BNE MoPN_10
.ba8f	60		rts		          RTS
.ba90					  Mon_Disk
.ba90	d0 03		bne $ba95	          BNE MonD_10
.ba92	a2 08		ldx #$08	          LDX #8              ; default device
>ba94	2c				          .byte $2c ;BIT
.ba95	a6 60		ldx $60		MonD_10   LDX M_Aval
.ba97	e0 04		cpx #$04	          CPX #4
.ba99	90 65		bcc $bb00	          BCC MonD_Err        ; -> error: device <  4
.ba9b	e0 1f		cpx #$1f	          CPX #31
.ba9d	b0 61		bcs $bb00	          BCS MonD_Err        ; -> error: device > 31
.ba9f	86 60		stx $60		          STX M_Aval
.baa1	a9 00		lda #$00	          LDA #0
.baa3	85 62		sta $62		          STA M_Aval+2
.baa5	85 b7		sta $b7		          STA FNLEN
.baa7	aa		tax		          TAX
.baa8	20 68 ff	jsr $ff68	          JSR K_SETBNK        ; bank 0
.baab	20 e9 b8	jsr $b8e9	          JSR Mon_Get_Char
.baae	c6 7a		dec $7a		          DEC DS_LEN
.bab0	c9 24		cmp #$24	          CMP #'$'            ; loading directory ?
.bab2	f0 4f		beq $bb03	          BEQ Mon_Dir         ; -> yes
.bab4	a9 00		lda #$00	          LDA #0              ; LA
.bab6	a6 60		ldx $60		          LDX M_Aval        ; FA
.bab8	a0 0f		ldy #$0f	          LDY #15             ; SA
.baba	20 ba ff	jsr $ffba	          JSR K_SETLFS
.babd	20 c0 ff	jsr $ffc0	          JSR K_OPEN          ; OPEN 0,FA,15
.bac0	b0 32		bcs $baf4	          BCS MonD_50         ; -> error
.bac2	a2 00		ldx #$00	          LDX #0
.bac4	20 c9 ff	jsr $ffc9	          JSR K_CKOUT         ; select output channel
.bac7	b0 2b		bcs $baf4	          BCS MonD_50         ; -> error
.bac9	a6 7a		ldx $7a		MonD_20   LDX DS_LEN          ; buffer pointer
.bacb	e6 7a		inc $7a		          INC DS_LEN
.bacd	bd 00 02	lda $0200,x	          LDA BUF,X           ; load command character
.bad0	f0 05		beq $bad7	          BEQ MonD_30         ; -> finish
.bad2	20 d2 ff	jsr $ffd2	          JSR K_BSOUT         ; send to device
.bad5	90 f2		bcc $bac9	          BCC MonD_20         ; -> loop
.bad7	20 cc ff	jsr $ffcc	MonD_30   JSR K_CLRCH         ; command has been sent
.bada	20 b4 b8	jsr $b8b4	          JSR Mon_CR
.badd	a2 00		ldx #$00	          LDX #0
.badf	20 c6 ff	jsr $ffc6	          JSR K_CHKIN         ; select input channel
.bae2	b0 10		bcs $baf4	          BCS MonD_50         ; -> error
.bae4	20 cf ff	jsr $ffcf	MonD_40   JSR K_BASIN
.bae7	20 d2 ff	jsr $ffd2	          JSR K_BSOUT         ; get char and print
.baea	c9 0d		cmp #$0d	          CMP #CR             ; until CR
.baec	f0 06		beq $baf4	          BEQ MonD_50
.baee	a5 90		lda $90		          LDA STATUS
.baf0	29 bf		and #$bf	          AND #%10111111     ; check EOI flag
.baf2	f0 f0		beq $bae4	          BEQ MonD_40         ; loop
.baf4	20 cc ff	jsr $ffcc	MonD_50   JSR K_CLRCH         ; clear channel
.baf7	a9 00		lda #$00	          LDA #0
.baf9	38		sec		          SEC
.bafa	20 c3 ff	jsr $ffc3	          JSR K_CLOSE         ; close command channel
.bafd	4c 8b b0	jmp $b08b	          JMP Mon_Main
.bb00	4c bc b0	jmp $b0bc	MonD_Err  JMP Mon_Error
.bb03					  Mon_Dir
.bb03	a0 ff		ldy #$ff	          LDY #$ff
.bb05	a6 7a		ldx $7a		          LDX DS_LEN          ; buffer pointer
.bb07	ca		dex		          DEX
.bb08	c8		iny		MDir_10   INY                 ; count length of pattern
.bb09	e8		inx		          INX
.bb0a	bd 00 02	lda $0200,x	          LDA BUF,X           ; pattern character
.bb0d	d0 f9		bne $bb08	          BNE MDir_10         ; loop if not at end
.bb0f	98		tya		          TYA                 ; A = length
.bb10	a6 7a		ldx $7a		          LDX DS_LEN          ; start of pattern low
.bb12	a0 02		ldy #$02	          LDY #>BUF           ; start of pattern high
.bb14	20 bd ff	jsr $ffbd	          JSR K_SETNAM
.bb17	a9 00		lda #$00	          LDA #0
.bb19	a6 60		ldx $60		          LDX M_Aval
.bb1b	a0 60		ldy #$60	          LDY #$60
.bb1d	20 ba ff	jsr $ffba	          JSR K_SETLFS        ; OPEN 0,FA,$60 (LOAD)
.bb20	20 c0 ff	jsr $ffc0	          JSR K_OPEN
.bb23	b0 cf		bcs $baf4	          BCS MonD_50         ; -> error
.bb25	a2 00		ldx #$00	          LDX #0
.bb27	20 c6 ff	jsr $ffc6	          JSR K_CHKIN
.bb2a	20 b4 b8	jsr $b8b4	          JSR Mon_CR
.bb2d	a0 03		ldy #$03	          LDY #3              ; load adr, link, blocks
.bb2f	84 63		sty $63		MDir_20   STY M_Bval
.bb31	20 cf ff	jsr $ffcf	MDir_30   JSR K_BASIN
.bb34	85 60		sta $60		          STA M_Aval        ; low byte
.bb36	a5 90		lda $90		          LDA STATUS
.bb38	d0 ba		bne $baf4	          BNE MonD_50         ; -> finish
.bb3a	20 cf ff	jsr $ffcf	          JSR K_BASIN
.bb3d	85 61		sta $61		          STA M_Aval+1      ; high byte
.bb3f	a5 90		lda $90		          LDA STATUS
.bb41	d0 b1		bne $baf4	          BNE MonD_50         ; -> finish
.bb43	c6 63		dec $63		          DEC M_Bval
.bb45	d0 ea		bne $bb31	          BNE MDir_30         ; loop read word
.bb47	20 07 ba	jsr $ba07	          JSR Mon_Bin_BCD
.bb4a	a9 00		lda #$00	          LDA #0
.bb4c	a2 08		ldx #$08	          LDX #8
.bb4e	a0 03		ldy #$03	          LDY #3
.bb50	20 5d ba	jsr $ba5d	          JSR Mon_Print_Number ; blocks
.bb53	a9 20		lda #$20	          LDA #' '
.bb55	20 d2 ff	jsr $ffd2	          JSR K_BSOUT
.bb58	20 cf ff	jsr $ffcf	MDir_40   JSR K_BASIN         ; print header / dir entry / free blcoks
.bb5b	f0 09		beq $bb66	          BEQ MDir_50
.bb5d	a6 90		ldx $90		          LDX STATUS
.bb5f	d0 93		bne $baf4	          BNE MonD_50
.bb61	20 d2 ff	jsr $ffd2	          JSR K_BSOUT
.bb64	90 f2		bcc $bb58	          BCC MDir_40
.bb66	20 b4 b8	jsr $b8b4	MDir_50   JSR Mon_CR
.bb69	20 e1 ff	jsr $ffe1	          JSR K_STOP
.bb6c	f0 86		beq $baf4	          BEQ MonD_50
.bb6e	a0 02		ldy #$02	          LDY #2              ; link, blocks
.bb70	d0 bd		bne $bb2f	          BNE MDir_20
>bb72	ff ff ff ff ff ff ff ff		          .FILL $bfc0-* ,$ff ; 1102 bytes
>bb7a	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
;	...repeated 67 times (1072 bytes)...
>bfba	ff ff ff ff ff ff
>bfc0	28 43 29 31 39 38 36 20		          .TEXT "(C)1986 COMMODORE ELECTRONICS"
>bfc8	43 4f 4d 4d 4f 44 4f 52 45 20 45 4c 45 43 54 52
>bfd8	4f 4e 49 43 53
>bfdd	2c 20 4c 54 44 2e 20 41		          .TEXT ", LTD. ALL RIGHTS RESERVED."
>bfe5	4c 4c 20 52 49 47 48 54 53 20 52 45 53 45 52 56
>bff5	45 44 2e
>bff8	ff ff ff ff c8 cd		          .BYTE $ff,$ff,$ff,$ff,$c8,$cd
>bffe	01 c5				          .WORD $c501 ; 15103
.c000	4c 7b c0	jmp $c07b	E_CINT    JMP Edit_Initialize
.c003	4c 34 cc	jmp $cc34	E_DISPLAY JMP Edit_Display
.c006	4c 34 c2	jmp $c234	E_GETKEY  JMP Edit_Get_Key
.c009	4c 9b c2	jmp $c29b	E_GETSCR  JMP Edit_Get_Screen
.c00c	4c 2d c7	jmp $c72d	E_PRINT   JMP Edit_Print
.c00f	4c 5b cc	jmp $cc5b	E_SCRORG  JMP Edit_Get_Window
.c012	4c 87 fc	jmp $fc87	E_KEY     JMP K_Scan_Keyboard
.c015	4c 51 c6	jmp $c651	E_REPEAT  JMP Edit_Repeat
.c018	4c 6a cc	jmp $cc6a	E_PLOT    JMP Edit_Plot
.c01b	4c 57 cd	jmp $cd57	E_CURSOR  JMP Edit_Cursor
.c01e	4c c1 c9	jmp $c9c1	E_ESCAPE  JMP Edit_Escape_Switch
.c021	4c a2 cc	jmp $cca2	E_PFKEY   JMP Edit_Set_FKey
.c024	4c 94 c1	jmp $c194	E_RASTER  JMP Edit_Raster
.c027	4c 0c ce	jmp $ce0c	E_DLCHR   JMP Edit_Load_Chargen
.c02a	4c 2e cd	jmp $cd2e	E_SWAPPER JMP Edit_Screen_Swapper
.c02d	4c 1b ca	jmp $ca1b	E_WINDOW  JMP Edit_Window_Corner
>c030	ff ff ff			          .BYTE $ff,$ff,$ff
.c033					  E_40_Line_Lo
>c033	00				          .BYTE <[VIC_TEXT +  0 * 40]
>c034	28				          .BYTE <[VIC_TEXT +  1 * 40]
>c035	50				          .BYTE <[VIC_TEXT +  2 * 40]
>c036	78				          .BYTE <[VIC_TEXT +  3 * 40]
>c037	a0				          .BYTE <[VIC_TEXT +  4 * 40]
>c038	c8				          .BYTE <[VIC_TEXT +  5 * 40]
>c039	f0				          .BYTE <[VIC_TEXT +  6 * 40]
>c03a	18				          .BYTE <[VIC_TEXT +  7 * 40]
>c03b	40				          .BYTE <[VIC_TEXT +  8 * 40]
>c03c	68				          .BYTE <[VIC_TEXT +  9 * 40]
>c03d	90				          .BYTE <[VIC_TEXT + 10 * 40]
>c03e	b8				          .BYTE <[VIC_TEXT + 11 * 40]
>c03f	e0				          .BYTE <[VIC_TEXT + 12 * 40]
>c040	08				          .BYTE <[VIC_TEXT + 13 * 40]
>c041	30				          .BYTE <[VIC_TEXT + 14 * 40]
>c042	58				          .BYTE <[VIC_TEXT + 15 * 40]
>c043	80				          .BYTE <[VIC_TEXT + 16 * 40]
>c044	a8				          .BYTE <[VIC_TEXT + 17 * 40]
>c045	d0				          .BYTE <[VIC_TEXT + 18 * 40]
>c046	f8				          .BYTE <[VIC_TEXT + 19 * 40]
>c047	20				          .BYTE <[VIC_TEXT + 20 * 40]
>c048	48				          .BYTE <[VIC_TEXT + 21 * 40]
>c049	70				          .BYTE <[VIC_TEXT + 22 * 40]
>c04a	98				          .BYTE <[VIC_TEXT + 23 * 40]
>c04b	c0				          .BYTE <[VIC_TEXT + 24 * 40]
.c04c					  E_40_Line_Hi
>c04c	04				          .BYTE >[VIC_TEXT +  0 * 40]
>c04d	04				          .BYTE >[VIC_TEXT +  1 * 40]
>c04e	04				          .BYTE >[VIC_TEXT +  2 * 40]
>c04f	04				          .BYTE >[VIC_TEXT +  3 * 40]
>c050	04				          .BYTE >[VIC_TEXT +  4 * 40]
>c051	04				          .BYTE >[VIC_TEXT +  5 * 40]
>c052	04				          .BYTE >[VIC_TEXT +  6 * 40]
>c053	05				          .BYTE >[VIC_TEXT +  7 * 40]
>c054	05				          .BYTE >[VIC_TEXT +  8 * 40]
>c055	05				          .BYTE >[VIC_TEXT +  9 * 40]
>c056	05				          .BYTE >[VIC_TEXT + 10 * 40]
>c057	05				          .BYTE >[VIC_TEXT + 11 * 40]
>c058	05				          .BYTE >[VIC_TEXT + 12 * 40]
>c059	06				          .BYTE >[VIC_TEXT + 13 * 40]
>c05a	06				          .BYTE >[VIC_TEXT + 14 * 40]
>c05b	06				          .BYTE >[VIC_TEXT + 15 * 40]
>c05c	06				          .BYTE >[VIC_TEXT + 16 * 40]
>c05d	06				          .BYTE >[VIC_TEXT + 17 * 40]
>c05e	06				          .BYTE >[VIC_TEXT + 18 * 40]
>c05f	06				          .BYTE >[VIC_TEXT + 19 * 40]
>c060	07				          .BYTE >[VIC_TEXT + 20 * 40]
>c061	07				          .BYTE >[VIC_TEXT + 21 * 40]
>c062	07				          .BYTE >[VIC_TEXT + 22 * 40]
>c063	07				          .BYTE >[VIC_TEXT + 23 * 40]
>c064	07				          .BYTE >[VIC_TEXT + 24 * 40]
.c065					  Edit_Vectors
>c065	b9 c7				          .WORD Edit_Use_Ctrl
>c067	05 c8				          .WORD Edit_Print_Shifted
>c069	c1 c9				          .WORD Edit_Escape_Switch
>c06b	e1 c5				          .WORD Edit_Use_Scancode
>c06d	ad c6				          .WORD Edit_Use_Function_Key
.c06f					  ASCII_Key_Tables
>c06f	80 fa				          .WORD Keytab_Normal
>c071	d9 fa				          .WORD Keytab_Shifted
>c073	32 fb				          .WORD Keytab_CBM
>c075	8b fb				          .WORD Keytab_Control
>c077	80 fa				          .WORD Keytab_Normal
>c079	e4 fb				          .WORD Keytab_Capslock
.c07b					  Edit_Initialize
.c07b	a9 03		lda #$03	          LDA #3              ; set Video Address VA14 and VA15
.c07d	0d 00 dd	ora $dd00	          ORA CIA2_PRA
.c080	8d 00 dd	sta $dd00	          STA CIA2_PRA        ; store it
.c083	a9 fb		lda #$fb	          LDA #%11111011     ; $fb
.c085	25 01		and $01		          AND R8502           ; switch $D000 to character ROM
.c087	09 02		ora #$02	          ORA #%00000010     ; $02
.c089	85 01		sta $01		          STA R8502           ; switch $E000-$FFF to ROM
.c08b	20 cc ff	jsr $ffcc	          JSR K_CLRCH         ; reset I/O channels
.c08e	a9 00		lda #$00	          LDA #0
.c090	20 80 fc	jsr $fc80	          JSR Edit_Patch_DIN  ; Zero DINFLG and SID_Volume
.c093	85 d8		sta $d8		          STA GRAPHM
.c095	85 d7		sta $d7		          STA MODE_80
.c097	85 d0		sta $d0		          STA NDX
.c099	85 d1		sta $d1		          STA KYNDX
.c09b	85 d6		sta $d6		          STA CRSW
.c09d	8d 21 0a	sta $0a21	          STA PAUSE
.c0a0	8d 26 0a	sta $0a26	          STA BLNON
.c0a3	85 d9		sta $d9		          STA CHAREN
.c0a5	8d 2e 0a	sta $0a2e	          STA VDC_RAM_PAGE    ; VDC base address = $0000
.c0a8	a9 14		lda #$14	          LDA #$14
.c0aa	8d 2c 0a	sta $0a2c	          STA VSH_TEXT        ; VIC text
.c0ad	a9 78		lda #$78	          LDA #$78
.c0af	8d 2d 0a	sta $0a2d	          STA VSH_BITMAP      ; VIC bitmap
.c0b2	a9 08		lda #$08	          LDA #8
.c0b4	8d 2f 0a	sta $0a2f	          STA VDC_ATT_PAGE    ; VDC attribute RAM = $0800
.c0b7	ad 4c c0	lda $c04c	          LDA E_40_Line_Hi
.c0ba	8d 3b 0a	sta $0a3b	          STA VIC_RAM_PAGE    ; VIC text RAM
.c0bd	a9 0a		lda #$0a	          LDA #10
.c0bf	8d 20 0a	sta $0a20	          STA XMAX            ; max lenth of keyboad queue
.c0c2	8d 28 0a	sta $0a28	          STA BLNCT           ;
.c0c5	8d 27 0a	sta $0a27	          STA BLNSW           ; Not zero: blinking off
.c0c8	8d 24 0a	sta $0a24	          STA DELAY
.c0cb	a9 04		lda #$04	          LDA #4
.c0cd	8d 23 0a	sta $0a23	          STA KOUNT
.c0d0	20 83 c9	jsr $c983	          JSR Set_Default_Tabstops
.c0d3	8d 22 0a	sta $0a22	          STA RPTFLG          ; $80 = all keys repeat
.c0d6	0d 05 d5	ora $d505	          ORA MMU_MODE
.c0d9	8d 05 d5	sta $d505	          STA MMU_MODE
.c0dc	a9 60		lda #$60	          LDA #$60
.c0de	8d 2b 0a	sta $0a2b	          STA CURMOD          ; normal blinking
.c0e1	a9 d0		lda #$d0	          LDA #$d0
.c0e3	8d 34 0a	sta $0a34	          STA VSH_SPLIT
.c0e6	a2 1a		ldx #$1a	          LDX #$1a
.c0e8	bd 74 ce	lda $ce74,x	CINT_10   LDA ZP_40_COL,X     ; store default ZP values
.c0eb	95 e0		sta $e0,x	          STA PNT,X           ; for 40 column screen in zero page
.c0ed	bd 8e ce	lda $ce8e,x	          LDA ZP_80_COL,X     ; store default ZP values
.c0f0	9d 40 0a	sta $0a40,x	          STA ZP_SW_COL,X     ; for 80 column screen in swap area
.c0f3	ca		dex		          DEX
.c0f4	10 f2		bpl $c0e8	          BPL CINT_10
.c0f6	a2 09		ldx #$09	          LDX #9
.c0f8	bd 65 c0	lda $c065,x	CINT_20   LDA Edit_Vectors,X
.c0fb	9d 34 03	sta $0334,x	          STA CTLVEC,X
.c0fe	ca		dex		          DEX
.c0ff	10 f7		bpl $c0f8	          BPL CINT_20
.c101	2c 04 0a	bit $0a04	          BIT INIT_STATUS
.c104	70 1e		bvs $c124	          BVS CINT_40
.c106	20 81 fe	jsr $fe81	          JSR DIN_or_ASCII
.c109	a9 00		lda #$00	          LDA #0
.c10b	8d 3f 03	sta $033f	          STA DECODE+1
.c10e	20 87 fc	jsr $fc87	          JSR K_Scan_Keyboard
.c111	a2 4c		ldx #$4c	          LDX #$4c
.c113	bd a8 ce	lda $cea8,x	CINT_30   LDA Edit_Default_FK,X
.c116	9d 00 10	sta $1000,x	          STA PKYBUF,X
.c119	ca		dex		          DEX
.c11a	10 f7		bpl $c113	          BPL CINT_30
.c11c	a9 40		lda #$40	          LDA #$40 ; '@'
.c11e	0d 04 0a	ora $0a04	          ORA INIT_STATUS
.c121	8d 04 0a	sta $0a04	          STA INIT_STATUS
.c124	20 2e cd	jsr $cd2e	CINT_40   JSR Edit_Screen_Swapper
.c127	20 83 c9	jsr $c983	          JSR Set_Default_Tabstops
.c12a	20 24 ca	jsr $ca24	          JSR Set_Fullscreen
.c12d	20 42 c1	jsr $c142	          JSR Clear_Window
.c130	20 2e cd	jsr $cd2e	          JSR Edit_Screen_Swapper
.c133	20 24 ca	jsr $ca24	          JSR Set_Fullscreen
.c136	20 42 c1	jsr $c142	          JSR Clear_Window
.c139	2c 05 d5	bit $d505	          BIT MMU_MODE
.c13c	30 03		bmi $c141	          BMI CINT_Ret
.c13e	20 2e cd	jsr $cd2e	          JSR Edit_Screen_Swapper
.c141	60		rts		CINT_Ret  RTS
.c142					  Clear_Window
.c142	20 50 c1	jsr $c150	          JSR Cursor_To_Window_Home
.c145	20 5e c1	jsr $c15e	ClWi_10   JSR Set_Screen_Pointer_X
.c148	20 a5 c4	jsr $c4a5	          JSR Clear_Window_Row_X
.c14b	e4 e4		cpx $e4		          CPX Margin_Bottom
.c14d	e8		inx		          INX
.c14e	90 f5		bcc $c145	          BCC ClWi_10
.c150					  Cursor_To_Window_Home
.c150	a6 e5		ldx $e5		          LDX Margin_Top
.c152	86 eb		stx $eb		          STX Cursor_Row
.c154	86 e8		stx $e8		          STX CurLst_Row
.c156					  Cursor_To_Left_Margin
.c156	a4 e6		ldy $e6		          LDY Margin_Left
.c158	84 ec		sty $ec		          STY Cursor_Col
.c15a	84 e9		sty $e9		          STY CurLst_Col
.c15c					  Set_Screen_Pointer
.c15c	a6 eb		ldx $eb		          LDX Cursor_Row
.c15e					  Set_Screen_Pointer_X
.c15e	bd 33 c0	lda $c033,x	          LDA E_40_Line_Lo,X
.c161	24 d7		bit $d7		          BIT MODE_80
.c163	10 01		bpl $c166	          BPL SSPX_10         ; -> 40 columns
.c165	0a		asl a		          ASL A
.c166	85 e0		sta $e0		SSPX_10   STA PNT             ; address low
.c168	bd 4c c0	lda $c04c,x	          LDA E_40_Line_Hi,X
.c16b	29 03		and #$03	          AND #%00000011     ; use lowest bits
.c16d	24 d7		bit $d7		          BIT MODE_80
.c16f	10 06		bpl $c177	          BPL SSPX_20         ; -> 40 columns
.c171	2a		rol a		          ROL A               ; double value + carry, clear carry
.c172	0d 2e 0a	ora $0a2e	          ORA VDC_RAM_PAGE    ; 80 column address high
.c175	90 03		bcc $c17a	          BCC SSPX_30         ; always
.c177	0d 3b 0a	ora $0a3b	SSPX_20   ORA VIC_RAM_PAGE    ; 40 column address high
.c17a	85 e1		sta $e1		SSPX_30   STA PNT+1           ; PNT = pointer to start of row X
.c17c					  Set_Attribute_Pointer
.c17c	a5 e0		lda $e0		          LDA PNT
.c17e	85 e2		sta $e2		          STA USER
.c180	a5 e1		lda $e1		          LDA PNT+1
.c182	24 d7		bit $d7		          BIT MODE_80
.c184	10 07		bpl $c18d	          BPL SAP_10          ; -> 40 columns
.c186	29 07		and #$07	          AND #%00000111     ; $07
.c188	0d 2f 0a	ora $0a2f	          ORA VDC_ATT_PAGE
.c18b	d0 04		bne $c191	          BNE SAP_20          ; always
.c18d	29 03		and #$03	SAP_10    AND #%00000011     ; $03
.c18f	09 d8		ora #$d8	          ORA #%11011000     ; $d8
.c191	85 e3		sta $e3		SAP_20    STA USER+1
.c193	60		rts		          RTS
.c194					  Edit_Raster
.c194	38		sec		          SEC
.c195	ad 19 d0	lda $d019	          LDA VIC_IRQ_REG
.c198	29 01		and #$01	          AND #%00000001     ; raster interrupt ?
.c19a	f0 07		beq $c1a3	          BEQ RAST_10         ; -> no
.c19c	8d 19 d0	sta $d019	          STA VIC_IRQ_REG     ; reset raster interrupt
.c19f	a5 d8		lda $d8		          LDA GRAPHM          ; load graphics mode
.c1a1	c9 ff		cmp #$ff	          CMP #$ff            ; text/graphic/split ?
.c1a3	f0 6f		beq $c214	RAST_10   BEQ RAST_80         ;
.c1a5	2c 11 d0	bit $d011	          BIT VIC_Ctrl_1
.c1a8	30 04		bmi $c1ae	          BMI RAST_20         ; -> branch on RST8 set
.c1aa	29 40		and #$40	          AND #%01000000     ; test split screen
.c1ac	d0 31		bne $c1df	          BNE RAST_50         ; -> branch on split screen
.c1ae	38		sec		RAST_20   SEC
.c1af	a5 d8		lda $d8		          LDA GRAPHM
.c1b1	f0 2c		beq $c1df	          BEQ RAST_50
.c1b3	24 d8		bit $d8		          BIT GRAPHM
.c1b5	50 06		bvc $c1bd	          BVC RAST_30         ; -> no split screen
.c1b7	ad 34 0a	lda $0a34	          LDA VSH_SPLIT       ; VIC split shadow register
.c1ba	8d 12 d0	sta $d012	          STA VIC_RASTER
.c1bd	a5 01		lda $01		RAST_30   LDA R8502
.c1bf	29 fd		and #$fd	          AND #%11111101     ; $E000-$EFFF : RAM
.c1c1	09 04		ora #$04	          ORA #%00000100     ; $D000-$Dfff : I/O
.c1c3	48		pha		          PHA                 ; save mask
.c1c4	ad 2d 0a	lda $0a2d	          LDA VSH_BITMAP      ; save bitmap pointer
.c1c7	48		pha		          PHA
.c1c8	ad 11 d0	lda $d011	          LDA VIC_Ctrl_1
.c1cb	29 7f		and #$7f	          AND #%01111111     ; reset bit8 of raster register
.c1cd	09 20		ora #$20	          ORA #%00100000     ; enable bitmap mode
.c1cf	a8		tay		          TAY                 ; save mask in Y
.c1d0	ad 16 d0	lda $d016	          LDA VIC_Ctrl_2
.c1d3	24 d8		bit $d8		          BIT GRAPHM
.c1d5	30 03		bmi $c1da	          BMI RAST_40         ; -> multi color mode
.c1d7	29 ef		and #$ef	          AND #%11101111     ; Disable multi color mode
>c1d9	2c				          .byte $2c ;BIT                 ; skip next statement
.c1da	09 10		ora #$10	RAST_40   ORA #%00010000     ; Enable multi color mode
.c1dc	aa		tax		          TAX                 ; save mask in X
.c1dd	d0 28		bne $c207	          BNE RAST_70         ; branch always
.c1df	a9 ff		lda #$ff	RAST_50   LDA #$ff
.c1e1	8d 12 d0	sta $d012	          STA VIC_RASTER
.c1e4	a5 01		lda $01		          LDA R8502
.c1e6	09 02		ora #$02	          ORA #%00000010     ; $E000-$FFFF : Kernal  ROM
.c1e8	29 fb		and #$fb	          AND #%11111011     ; $D000-$DFFF : Chargen ROM
.c1ea	05 d9		ora $d9		          ORA CHAREN
.c1ec	48		pha		          PHA                 ; save mask
.c1ed	ad 2c 0a	lda $0a2c	          LDA VSH_TEXT
.c1f0	48		pha		          PHA
.c1f1	ad 11 d0	lda $d011	          LDA VIC_Ctrl_1
.c1f4	29 5f		and #$5f	          AND #%01011111     ; switch off bitmap mode
.c1f6	a8		tay		          TAY                 ; save mask in Y
.c1f7	ad 16 d0	lda $d016	          LDA VIC_Ctrl_2
.c1fa	29 ef		and #$ef	          AND #%11101111     ; switch off multi color mode
.c1fc	aa		tax		          TAX                 ; save mask in X
.c1fd	b0 08		bcs $c207	          BCS RAST_70
.c1ff	a2 07		ldx #$07	          LDX #7              ; wait 0.03 ms
.c201	ca		dex		RAST_60   DEX
.c202	d0 fd		bne $c201	          BNE RAST_60
.c204	ea		nop		          NOP
.c205	ea		nop		          NOP
.c206	aa		tax		          TAX
.c207	68		pla		RAST_70   PLA
.c208	8d 18 d0	sta $d018	          STA VIC_Memory
.c20b	68		pla		          PLA
.c20c	85 01		sta $01		          STA R8502
.c20e	8c 11 d0	sty $d011	          STY VIC_Ctrl_1
.c211	8e 16 d0	stx $d016	          STX VIC_Ctrl_2
.c214	b0 13		bcs $c229	RAST_80   BCS RAST_90
.c216	ad 30 d0	lda $d030	          LDA VIC_SPEED
.c219	29 01		and #$01	          AND #%00000001     ; mask CUP speed
.c21b	f0 0c		beq $c229	          BEQ RAST_90         ; -> branch on 1 MHz
.c21d	a5 d8		lda $d8		          LDA GRAPHM
.c21f	29 40		and #$40	          AND #%01000000     ; test split screen
.c221	f0 06		beq $c229	          BEQ RAST_90         ; -> branch if not
.c223	ad 11 d0	lda $d011	          LDA VIC_Ctrl_1
.c226	10 01		bpl $c229	          BPL RAST_90         ; -> RST8 clear
.c228	38		sec		          SEC
.c229	58		cli		RAST_90   CLI                 ; enable interrupts
.c22a	90 07		bcc $c233	          BCC RAST_Ret        ; -> skip key and cursor routines
.c22c	20 87 fc	jsr $fc87	          JSR K_Scan_Keyboard             ; scan keyboard
.c22f	20 e7 c6	jsr $c6e7	          JSR Blink_Cursor    ; blink cursor
.c232	38		sec		          SEC
.c233	60		rts		RAST_Ret  RTS
.c234					  Edit_Get_Key
.c234	a6 d1		ldx $d1		          LDX KYNDX           ; chars in function key buffer
.c236	f0 0c		beq $c244	          BEQ GETK_10         ; -> none
.c238	a4 d2		ldy $d2		          LDY KEYIDX          ; get text index
.c23a	b9 0a 10	lda $100a,y	          LDA PKYDEF,Y        ; get next char
.c23d	c6 d1		dec $d1		          DEC KYNDX           ; decrement remaining chars
.c23f	e6 d2		inc $d2		          INC KEYIDX          ; increment index
.c241	58		cli		          CLI                 ; enable interrupts
.c242	18		clc		          CLC                 ; C=0 got new char
.c243	60		rts		          RTS                 ; and return
.c244	ac 4a 03	ldy $034a	GETK_10   LDY KEYD            ; load next char into Y
.c247	bd 4b 03	lda $034b,x	GETK_20   LDA KEYD+1,X        ; scroll keyboard buffer
.c24a	9d 4a 03	sta $034a,x	          STA KEYD,X
.c24d	e8		inx		          INX
.c24e	e4 d0		cpx $d0		          CPX NDX
.c250	d0 f5		bne $c247	          BNE GETK_20         ; loop
.c252	c6 d0		dec $d0		          DEC NDX             ; decrement chars in buffer
.c254	98		tya		          TYA                 ; A = char to return
.c255	58		cli		          CLI                 ; enable interrupts
.c256	18		clc		          CLC                 ; C=0 got new char
.c257	60		rts		          RTS                 ; and return
.c258	20 2d c7	jsr $c72d	GETK_30   JSR Edit_Print           ; display char
.c25b	20 6f cd	jsr $cd6f	GETK_40   JSR Edit_Cursor_On
.c25e	a5 d0		lda $d0		GETK_50   LDA NDX             ; chars in buffer
.c260	05 d1		ora $d1		          ORA KYNDX           ; chars from function key
.c262	f0 fa		beq $c25e	          BEQ GETK_50         ; -> waitloop if none
.c264	20 9f cd	jsr $cd9f	          JSR Edit_Cursor_Off
.c267	20 34 c2	jsr $c234	          JSR Edit_Get_Key    ; get next char
.c26a	c9 0d		cmp #$0d	          CMP #CR
.c26c	d0 ea		bne $c258	          BNE GETK_30         ; -> loop if not CR
.c26e	85 d6		sta $d6		          STA CRSW            ; not zero: screen input
.c270	a9 00		lda #$00	          LDA #0
.c272	85 f4		sta $f4		          STA QTSW            ; clear quote switch
.c274	20 c3 cb	jsr $cbc3	          JSR Edit_Cursor_Last
.c277	8e 30 0a	stx $0a30	          STX LINTMP
.c27a	20 b5 cb	jsr $cbb5	          JSR Start_Of_Line
.c27d	a4 e6		ldy $e6		          LDY Margin_Left
.c27f	a5 e8		lda $e8		          LDA CurLst_Row
.c281	30 13		bmi $c296	          BMI GETK_80         ; -> coupled row
.c283	c5 eb		cmp $eb		          CMP Cursor_Row
.c285	90 0f		bcc $c296	          BCC GETK_80         ; -> input row != cursor row
.c287	a4 e9		ldy $e9		          LDY CurLst_Col
.c289	cd 30 0a	cmp $0a30	          CMP LINTMP          ; input column == last input column ?
.c28c	d0 04		bne $c292	          BNE GETK_60         ; -> no
.c28e	c4 ea		cpy $ea		          CPY Cursor_End
.c290	f0 02		beq $c294	          BEQ GETK_70         ; -> yes
.c292	b0 11		bcs $c2a5	GETK_60   BCS GETS_10
.c294	85 eb		sta $eb		GETK_70   STA Cursor_Row
.c296	84 ec		sty $ec		GETK_80   STY Cursor_Col
.c298	4c bc c2	jmp $c2bc	          JMP GETS_25
.c29b					  Edit_Get_Screen
.c29b	98		tya		          TYA
.c29c	48		pha		          PHA                 ; save Y
.c29d	8a		txa		          TXA
.c29e	48		pha		          PHA                 ; save X
.c29f	a5 d6		lda $d6		          LDA CRSW            ; Cursor Wait ?
.c2a1	f0 b8		beq $c25b	          BEQ GETK_40         ; -> get key
.c2a3	10 17		bpl $c2bc	          BPL GETS_25         ; -> get char from screen RAM
.c2a5	a9 00		lda #$00	GETS_10   LDA #0
.c2a7	85 d6		sta $d6		          STA CRSW
.c2a9	a9 0d		lda #$0d	          LDA #CR
.c2ab	a2 03		ldx #$03	          LDX #3
.c2ad	e4 99		cpx $99		          CPX DFLTN
.c2af	f0 04		beq $c2b5	          BEQ GETS_15         ; -> input from screen
.c2b1	e4 9a		cpx $9a		          CPX DFLTO
.c2b3	f0 03		beq $c2b8	          BEQ GETS_20         ; -> output to screen
.c2b5	20 2d c7	jsr $c72d	GETS_15   JSR Edit_Print
.c2b8	a9 0d		lda #$0d	GETS_20   LDA #CR
.c2ba	d0 39		bne $c2f5	          BNE GETS_55         ; -> exit with CR
.c2bc	20 5c c1	jsr $c15c	GETS_25   JSR Set_Screen_Pointer
.c2bf	20 58 cb	jsr $cb58	          JSR Edit_Get_Char
.c2c2	85 ef		sta $ef		          STA DATAX           ; display code
.c2c4	29 3f		and #$3f	          AND #%00111111
.c2c6	06 ef		asl $ef		          ASL DATAX
.c2c8	24 ef		bit $ef		          BIT DATAX
.c2ca	10 02		bpl $c2ce	          BPL GETS_30
.c2cc	09 80		ora #$80	          ORA #%10000000
.c2ce	90 04		bcc $c2d4	GETS_30   BCC GETS_35
.c2d0	a6 f4		ldx $f4		          LDX QTSW
.c2d2	d0 04		bne $c2d8	          BNE GETS_40
.c2d4	70 02		bvs $c2d8	GETS_35   BVS GETS_40
.c2d6	09 40		ora #$40	          ORA #%01000000
.c2d8	20 ff c2	jsr $c2ff	GETS_40   JSR Edit_Toggle_Quote
.c2db	a4 eb		ldy $eb		          LDY Cursor_Row
.c2dd	cc 30 0a	cpy $0a30	          CPY LINTMP
.c2e0	90 0a		bcc $c2ec	          BCC GETS_45
.c2e2	a4 ec		ldy $ec		          LDY Cursor_Col
.c2e4	c4 ea		cpy $ea		          CPY Cursor_End
.c2e6	90 04		bcc $c2ec	          BCC GETS_45
.c2e8	66 d6		ror $d6		          ROR CRSW            ; set bit 7 of CRSW
.c2ea	30 03		bmi $c2ef	          BMI GETS_50         ; always
.c2ec	20 ed cb	jsr $cbed	GETS_45   JSR Edit_Cursor_Right
.c2ef	c9 de		cmp #$de	GETS_50   CMP #$de            ; Pi in display code
.c2f1	d0 02		bne $c2f5	          BNE GETS_55
.c2f3	a9 ff		lda #$ff	          LDA #$ff            ; Pi PETSCII
.c2f5	85 ef		sta $ef		GETS_55   STA DATAX
.c2f7	68		pla		          PLA
.c2f8	aa		tax		          TAX
.c2f9	68		pla		          PLA
.c2fa	a8		tay		          TAY
.c2fb	a5 ef		lda $ef		          LDA DATAX
.c2fd	18		clc		          CLC
.c2fe	60		rts		          RTS
.c2ff					  Edit_Toggle_Quote
.c2ff	c9 22		cmp #$22	          CMP #QUOTE
.c301	d0 08		bne $c30b	          BNE EdTQ_Ret
.c303	a5 f4		lda $f4		          LDA QTSW
.c305	49 01		eor #$01	          EOR #1
.c307	85 f4		sta $f4		          STA QTSW
.c309	a9 22		lda #$22	          LDA #QUOTE
.c30b	60		rts		EdTQ_Ret  RTS
.c30c					  Edit_Print_Exit
.c30c	a5 ef		lda $ef		          LDA DATAX           ; printed character
.c30e	85 f0		sta $f0		          STA LSTCHR          ; remember it
.c310	20 57 cd	jsr $cd57	          JSR Edit_Cursor          ; update cursor
.c313	a5 f5		lda $f5		          LDA INSRT           ; outstanding inserts ?
.c315	f0 02		beq $c319	          BEQ EdPE_10         ; -> no
.c317	46 f4		lsr $f4		          LSR QTSW            ; clear quote mode
.c319	68		pla		EdPE_10   PLA
.c31a	a8		tay		          TAY                 ; pull Y
.c31b	68		pla		          PLA
.c31c	aa		tax		          TAX                 ; pull X
.c31d	68		pla		          PLA                 ; pull A
.c31e	18		clc		          CLC                 ; status OK
.c31f	60		rts		          RTS
.c320					  Print_To_Screen
.c320	09 40		ora #$40	          ORA #$40
.c322	a6 f3		ldx $f3		PTS_10    LDX E_Reverse
.c324	f0 02		beq $c328	          BEQ PTS_30
.c326	09 80		ora #$80	PTS_20    ORA #$80            ; set reverse bit
.c328	a6 f5		ldx $f5		PTS_30    LDX INSRT           ; insert mode ?
.c32a	f0 02		beq $c32e	          BEQ PTS_40
.c32c	c6 f5		dec $f5		          DEC INSRT           ; # of inserts pending
.c32e	24 f6		bit $f6		PTS_40    BIT INSFLG
.c330	10 09		bpl $c33b	          BPL PTS_50
.c332	48		pha		          PHA
.c333	20 e3 c8	jsr $c8e3	          JSR Edit_Shift_Text
.c336	a2 00		ldx #$00	          LDX #0
.c338	86 f5		stx $f5		          STX INSRT           ; clear insert mode
.c33a	68		pla		          PLA
.c33b	20 2f cc	jsr $cc2f	PTS_50    JSR Edit_Put_Char_Att
.c33e					  Edit_Cursor_Next
.c33e	c4 e7		cpy $e7		          CPY Margin_Right
.c340	90 0a		bcc $c34c	          BCC EdAC_10
.c342	a6 eb		ldx $eb		          LDX Cursor_Row
.c344	e4 e4		cpx $e4		          CPX Margin_Bottom
.c346	90 04		bcc $c34c	          BCC EdAC_10
.c348	24 f8		bit $f8		          BIT Scroll_Locked
.c34a	30 16		bmi $c362	          BMI EdAC_Ret        ; -> scroll locked
.c34c	20 5c c1	jsr $c15c	EdAC_10   JSR Set_Screen_Pointer
.c34f	20 ed cb	jsr $cbed	          JSR Edit_Cursor_Right
.c352	90 0e		bcc $c362	          BCC EdAC_Ret        ; -> OK
.c354	20 74 cb	jsr $cb74	          JSR Is_Coupled_Row
.c357	b0 08		bcs $c361	          BCS EdAC_20
.c359	38		sec		          SEC
.c35a	24 f8		bit $f8		          BIT Scroll_Locked
.c35c	70 04		bvs $c362	          BVS EdAC_Ret
.c35e	20 7c c3	jsr $c37c	          JSR Edit_Scroll_Down
.c361	18		clc		EdAC_20   CLC
.c362	60		rts		EdAC_Ret  RTS
.c363					  Edit_Cursor_Down
.c363	a6 eb		ldx $eb		          LDX Cursor_Row
.c365	e4 e4		cpx $e4		          CPX Margin_Bottom
.c367	90 0e		bcc $c377	          BCC EdCD_20         ; -> not at last row
.c369	24 f8		bit $f8		          BIT Scroll_Locked
.c36b	10 06		bpl $c373	          BPL EdCD_10         ; -> scroll window
.c36d	a5 e5		lda $e5		          LDA Margin_Top
.c36f	85 eb		sta $eb		          STA Cursor_Row      ; set cursor to upper margin
.c371	b0 06		bcs $c379	          BCS EdCD_30         ; branch always
.c373	20 a6 c3	jsr $c3a6	EdCD_10   JSR Edit_Scroll_Up
.c376	18		clc		          CLC
.c377	e6 eb		inc $eb		EdCD_20   INC Cursor_Row
.c379	4c 5c c1	jmp $c15c	EdCD_30   JMP Set_Screen_Pointer
.c37c					  Edit_Scroll_Down
.c37c	a6 e8		ldx $e8		          LDX CurLst_Row
.c37e	30 06		bmi $c386	          BMI EdSD_10         ; -> cont row
.c380	e4 eb		cpx $eb		          CPX Cursor_Row
.c382	90 02		bcc $c386	          BCC EdSD_10
.c384	e6 e8		inc $e8		          INC CurLst_Row
.c386	a6 e4		ldx $e4		EdSD_10   LDX Margin_Bottom
.c388	20 5e c1	jsr $c15e	EdSD_20   JSR Set_Screen_Pointer_X
.c38b	a4 e6		ldy $e6		          LDY Margin_Left     ; copy row from left to right margin
.c38d	e4 eb		cpx $eb		          CPX Cursor_Row
.c38f	f0 0f		beq $c3a0	          BEQ EdSD_30         ; -> finish at cursor row
.c391	ca		dex		          DEX
.c392	20 76 cb	jsr $cb76	          JSR Is_Coupled_Row_X
.c395	e8		inx		          INX
.c396	20 83 cb	jsr $cb83	          JSR Toggle_Cont_Flag_X
.c399	ca		dex		          DEX
.c39a	20 0d c4	jsr $c40d	          JSR Scroll_Row      ; X = source row
.c39d	4c 88 c3	jmp $c388	          JMP EdSD_20
.c3a0	20 a5 c4	jsr $c4a5	EdSD_30   JSR Clear_Window_Row_X
.c3a3	4c 93 cb	jmp $cb93	          JMP Set_Cont_Flag
.c3a6					  Edit_Scroll_Up
.c3a6	a6 e5		ldx $e5		          LDX Margin_Top
.c3a8	e8		inx		ScUp_10   INX
.c3a9	20 76 cb	jsr $cb76	          JSR Is_Coupled_Row_X
.c3ac	90 0a		bcc $c3b8	          BCC ScUp_20         ; -> single row
.c3ae	e4 e4		cpx $e4		          CPX Margin_Bottom
.c3b0	90 f6		bcc $c3a8	          BCC ScUp_10
.c3b2	a6 e5		ldx $e5		          LDX Margin_Top
.c3b4	e8		inx		          INX
.c3b5	20 85 cb	jsr $cb85	          JSR Clear_Cont_Flag
.c3b8	c6 eb		dec $eb		ScUp_20   DEC Cursor_Row
.c3ba	24 e8		bit $e8		          BIT CurLst_Row
.c3bc	30 02		bmi $c3c0	          BMI ScUp_30         ; -> continuation row
.c3be	c6 e8		dec $e8		          DEC CurLst_Row
.c3c0	a6 e5		ldx $e5		ScUp_30   LDX Margin_Top
.c3c2	e4 df		cpx $df		          CPX E_Row
.c3c4	b0 02		bcs $c3c8	          BCS ScUp_40
.c3c6	c6 df		dec $df		          DEC E_Row
.c3c8	20 dc c3	jsr $c3dc	ScUp_40   JSR Scroll_Window
.c3cb	a6 e5		ldx $e5		          LDX Margin_Top
.c3cd	20 76 cb	jsr $cb76	          JSR Is_Coupled_Row_X
.c3d0	08		php		          PHP
.c3d1	20 85 cb	jsr $cb85	          JSR Clear_Cont_Flag
.c3d4	28		plp		          PLP
.c3d5	90 04		bcc $c3db	          BCC ScUp_Ret
.c3d7	24 f8		bit $f8		          BIT Scroll_Locked
.c3d9	30 cb		bmi $c3a6	          BMI Edit_Scroll_Up
.c3db	60		rts		ScUp_Ret  RTS
.c3dc					  Scroll_Window
.c3dc	20 5e c1	jsr $c15e	          JSR Set_Screen_Pointer_X
.c3df	a4 e6		ldy $e6		          LDY Margin_Left
.c3e1	e4 e4		cpx $e4		          CPX Margin_Bottom
.c3e3	b0 0f		bcs $c3f4	          BCS ScWi_10
.c3e5	e8		inx		          INX
.c3e6	20 76 cb	jsr $cb76	          JSR Is_Coupled_Row_X
.c3e9	ca		dex		          DEX
.c3ea	20 83 cb	jsr $cb83	          JSR Toggle_Cont_Flag_X
.c3ed	e8		inx		          INX
.c3ee	20 0d c4	jsr $c40d	          JSR Scroll_Row
.c3f1	4c dc c3	jmp $c3dc	          JMP Scroll_Window
.c3f4	20 a5 c4	jsr $c4a5	ScWi_10   JSR Clear_Window_Row_X
.c3f7	a9 7f		lda #$7f	          LDA #$7f            ; test col 7
.c3f9	8d 00 dc	sta $dc00	          STA CIA1_KBD_COL
.c3fc	ad 01 dc	lda $dc01	          LDA CIA1_KBD_ROW
.c3ff	c9 df		cmp #$df	          CMP #%11011111    ; Commodore key ?
.c401	d0 09		bne $c40c	          BNE ScWi_Ret
.c403	a0 00		ldy #$00	          LDY #0
.c405	ea		nop		ScWi_20   NOP
.c406	ca		dex		          DEX
.c407	d0 fc		bne $c405	          BNE ScWi_20
.c409	88		dey		          DEY
.c40a	d0 f9		bne $c405	          BNE ScWi_20
.c40c	60		rts		ScWi_Ret  RTS
.c40d					  Scroll_Row
.c40d	24 d7		bit $d7		          BIT MODE_80
.c40f	30 25		bmi $c436	          BMI ScRo_20         ; -> 80 column screen
.c411	bd 33 c0	lda $c033,x	          LDA E_40_Line_Lo,X
.c414	85 dc		sta $dc		          STA E_End           ; character low
.c416	85 da		sta $da		          STA E_Beg           ; colour    low
.c418	bd 4c c0	lda $c04c,x	          LDA E_40_Line_Hi,X
.c41b	29 03		and #$03	          AND #%00000011
.c41d	0d 3b 0a	ora $0a3b	          ORA VIC_RAM_PAGE
.c420	85 db		sta $db		          STA E_Beg+1         ; character high
.c422	29 03		and #$03	          AND #%00000011     ; $03
.c424	09 d8		ora #$d8	          ORA #%11011000     ; $d8
.c426	85 dd		sta $dd		          STA E_End+1         ; colour    high
.c428	b1 da		lda ($da),y	ScRo_10   LDA (E_Beg),Y
.c42a	91 e0		sta ($e0),y	          STA (PNT),Y         ; copy character
.c42c	b1 dc		lda ($dc),y	          LDA (E_End),Y
.c42e	91 e2		sta ($e2),y	          STA (USER),Y        ; copy colour
.c430	c4 e7		cpy $e7		          CPY Margin_Right
.c432	c8		iny		          INY
.c433	90 f3		bcc $c428	          BCC ScRo_10
.c435	60		rts		          RTS
.c436	8e 31 0a	stx $0a31	ScRo_20   STX VDC_ROW      ; save row
.c439	8c 32 0a	sty $0a32	          STY VDC_COL      ; save col
.c43c	a2 18		ldx #$18	          LDX #$18            ; VDC reg $18
.c43e	20 da cd	jsr $cdda	          JSR VDC_Read_Register_X
.c441	09 80		ora #$80	          ORA #%10000000     ; $80
.c443	20 cc cd	jsr $cdcc	          JSR VDC_Write_Register_X
.c446	20 e6 cd	jsr $cde6	          JSR VDC_Set_Char_Address
.c449	ae 31 0a	ldx $0a31	          LDX VDC_ROW
.c44c	bd 33 c0	lda $c033,x	          LDA E_40_Line_Lo,X
.c44f	0a		asl a		          ASL A
.c450	85 da		sta $da		          STA E_Beg
.c452	bd 4c c0	lda $c04c,x	          LDA E_40_Line_Hi,X
.c455	29 03		and #$03	          AND #%00000011 ; $03
.c457	2a		rol a		          ROL A
.c458	0d 2e 0a	ora $0a2e	          ORA VDC_RAM_PAGE
.c45b	85 db		sta $db		          STA E_Beg+1
.c45d	a2 20		ldx #$20	          LDX #$20            ; VDC reg $20
.c45f	18		clc		          CLC
.c460	98		tya		          TYA
.c461	65 da		adc $da		          ADC E_Beg
.c463	85 da		sta $da		          STA E_Beg
.c465	a9 00		lda #$00	          LDA #0
.c467	65 db		adc $db		          ADC E_Beg+1
.c469	85 db		sta $db		          STA E_Beg+1
.c46b	20 cc cd	jsr $cdcc	          JSR VDC_Write_Register_X
.c46e	e8		inx		          INX
.c46f	a5 da		lda $da		          LDA E_Beg
.c471	20 cc cd	jsr $cdcc	          JSR VDC_Write_Register_X
.c474	38		sec		          SEC
.c475	a6 e7		ldx $e7		          LDX Margin_Right
.c477	e8		inx		          INX
.c478	8a		txa		          TXA
.c479	ed 32 0a	sbc $0a32	          SBC VDC_COL
.c47c	8d 32 0a	sta $0a32	          STA VDC_COL
.c47f	a2 1e		ldx #$1e	          LDX #$1e
.c481	20 cc cd	jsr $cdcc	          JSR VDC_Write_Register_X
.c484	a2 20		ldx #$20	          LDX #$20
.c486	a5 db		lda $db		          LDA E_Beg+1
.c488	29 07		and #$07	          AND #%00000111 ; $07
.c48a	0d 2f 0a	ora $0a2f	          ORA VDC_ATT_PAGE
.c48d	20 cc cd	jsr $cdcc	          JSR VDC_Write_Register_X
.c490	e8		inx		          INX
.c491	a5 da		lda $da		          LDA E_Beg
.c493	20 cc cd	jsr $cdcc	          JSR VDC_Write_Register_X
.c496	20 f9 cd	jsr $cdf9	          JSR VDC_Set_Attr_Address
.c499	ad 32 0a	lda $0a32	          LDA VDC_COL
.c49c	a2 1e		ldx #$1e	          LDX #$1e
.c49e	20 cc cd	jsr $cdcc	          JSR VDC_Write_Register_X
.c4a1	ae 31 0a	ldx $0a31	          LDX VDC_ROW
.c4a4	60		rts		          RTS
.c4a5					  Clear_Window_Row_X
.c4a5	a4 e6		ldy $e6		          LDY Margin_Left            ; start at left margin
.c4a7	20 85 cb	jsr $cb85	          JSR Clear_Cont_Flag ; make this line single
.c4aa					  Clear_Row_To_EOR
.c4aa	20 5e c1	jsr $c15e	          JSR Set_Screen_Pointer_X
.c4ad	24 d7		bit $d7		          BIT MODE_80
.c4af	30 0f		bmi $c4c0	          BMI CRTE_20         ; -> 80 columns
.c4b1	88		dey		          DEY                 ; pre increment loop
.c4b2	c8		iny		CRTE_10   INY
.c4b3	a9 20		lda #$20	          LDA #' '
.c4b5	91 e0		sta ($e0),y	          STA (PNT),Y         ; store blank
.c4b7	a5 f1		lda $f1		          LDA E_Attribute
.c4b9	91 e2		sta ($e2),y	          STA (USER),Y        ; store color
.c4bb	c4 e7		cpy $e7		          CPY Margin_Right
.c4bd	d0 f3		bne $c4b2	          BNE CRTE_10         ; -> loop
.c4bf	60		rts		          RTS
.c4c0	8e 31 0a	stx $0a31	CRTE_20   STX VDC_ROW
.c4c3	8c 32 0a	sty $0a32	          STY VDC_COL
.c4c6	a2 18		ldx #$18	          LDX #$18            ; COPY / vertical scrolling
.c4c8	20 da cd	jsr $cdda	          JSR VDC_Read_Register_X
.c4cb	29 7f		and #$7f	          AND #%01111111     ; Clear COPY bit
.c4cd	20 cc cd	jsr $cdcc	          JSR VDC_Write_Register_X
.c4d0	a2 12		ldx #$12	          LDX #$12            ; Update address high
.c4d2	18		clc		          CLC
.c4d3	98		tya		          TYA                 ; column
.c4d4	65 e0		adc $e0		          ADC PNT             ; + row address low
.c4d6	48		pha		          PHA                 ; push
.c4d7	8d 3c 0a	sta $0a3c	          STA VDC_UPDATE_LO
.c4da	a9 00		lda #$00	          LDA #0
.c4dc	65 e1		adc $e1		          ADC PNT+1
.c4de	8d 3d 0a	sta $0a3d	          STA VDC_UPDATE_HI   ; VDC_UPDATE = PNT + Y
.c4e1	20 cc cd	jsr $cdcc	          JSR VDC_Write_Register_X
.c4e4	e8		inx		          INX
.c4e5	68		pla		          PLA
.c4e6	20 cc cd	jsr $cdcc	          JSR VDC_Write_Register_X
.c4e9	a9 20		lda #$20	          LDA #' '
.c4eb	20 ca cd	jsr $cdca	          JSR VDC_Write_Data
.c4ee	38		sec		          SEC
.c4ef	a5 e7		lda $e7		          LDA Margin_Right
.c4f1	ed 32 0a	sbc $0a32	          SBC VDC_COL         ; minus column
.c4f4	48		pha		          PHA
.c4f5	f0 14		beq $c50b	          BEQ CRTE_30         ; -> at right margin
.c4f7	aa		tax		          TAX                 ; bytes to write
.c4f8	38		sec		          SEC
.c4f9	6d 3c 0a	adc $0a3c	          ADC VDC_UPDATE_LO
.c4fc	8d 3c 0a	sta $0a3c	          STA VDC_UPDATE_LO
.c4ff	a9 00		lda #$00	          LDA #0
.c501	6d 3d 0a	adc $0a3d	          ADC VDC_UPDATE_HI
.c504	8d 3d 0a	sta $0a3d	          STA VDC_UPDATE_HI   ; VDC_UPDATE = address of right margin
.c507	8a		txa		          TXA                 ; count
.c508	20 3e c5	jsr $c53e	          JSR VDC_Fill_Char_A ; fill row with blanks
.c50b	a2 12		ldx #$12	CRTE_30   LDX #$12            ; Update address high
.c50d	18		clc		          CLC
.c50e	98		tya		          TYA
.c50f	65 e2		adc $e2		          ADC USER
.c511	48		pha		          PHA
.c512	a9 00		lda #$00	          LDA #0
.c514	65 e3		adc $e3		          ADC USER+1          ; write attribute address
.c516	20 cc cd	jsr $cdcc	          JSR VDC_Write_Register_X
.c519	e8		inx		          INX
.c51a	68		pla		          PLA
.c51b	20 cc cd	jsr $cdcc	          JSR VDC_Write_Register_X
.c51e	ad 3d 0a	lda $0a3d	          LDA VDC_UPDATE_HI
.c521	29 07		and #$07	          AND #%00000111 ; $07
.c523	0d 2f 0a	ora $0a2f	          ORA VDC_ATT_PAGE
.c526	8d 3d 0a	sta $0a3d	          STA VDC_UPDATE_HI
.c529	a5 f1		lda $f1		          LDA E_Attribute
.c52b	29 8f		and #$8f	          AND #%10001111 ; $8f
.c52d	20 ca cd	jsr $cdca	          JSR VDC_Write_Data  ; write attribute
.c530	68		pla		          PLA
.c531	f0 03		beq $c536	          BEQ CRTE_40
.c533	20 3e c5	jsr $c53e	          JSR VDC_Fill_Char_A ; fill row with attribute
.c536	ae 31 0a	ldx $0a31	CRTE_40   LDX VDC_ROW      ; restore X
.c539	a4 e7		ldy $e7		          LDY Margin_Right    ; restore Y
.c53b	60		rts		          RTS
.c53c	a9 01		lda #$01	VFCA_00   LDA #1
.c53e					  VDC_Fill_Char_A
.c53e	a2 1e		ldx #$1e	          LDX #$1e            ; word count
.c540	20 cc cd	jsr $cdcc	          JSR VDC_Write_Register_X
.c543	2c 00 d6	bit $d600	VFCA_10   BIT VDC_Register
.c546	10 fb		bpl $c543	          BPL VFCA_10
.c548	a2 12		ldx #$12	          LDX #$12            ; update high
.c54a	20 da cd	jsr $cdda	          JSR VDC_Read_Register_X
.c54d	cd 3d 0a	cmp $0a3d	          CMP VDC_UPDATE_HI
.c550	90 ea		bcc $c53c	          BCC VFCA_00
.c552	a2 13		ldx #$13	          LDX #$13            ; update low
.c554	20 da cd	jsr $cdda	          JSR VDC_Read_Register_X
.c557	cd 3c 0a	cmp $0a3c	          CMP VDC_UPDATE_LO
.c55a	90 e0		bcc $c53c	          BCC VFCA_00
.c55c	60		rts		          RTS
.c55d					  Scan_Keyboard
.c55d	a5 01		lda $01		          LDA R8502
.c55f	29 40		and #$40	          AND #%01000000     ; extract bit 6 : ASCII/DIN
.c561	49 40		eor #$40	          EOR #%01000000     ; toggle  bit 6
.c563	4a		lsr a		          LSR A
.c564	4a		lsr a		          LSR A               ; bit 4 : 1 = DIN, 0 = ASCII
.c565	85 d3		sta $d3		          STA SHFLAG          ; store in shift flag
.c567	a0 58		ldy #$58	          LDY #88             ; scan 88 keys (8 x 11 matrix)
.c569	84 d4		sty $d4		          STY SFDX            ; key index
.c56b	a9 00		lda #$00	          LDA #0
.c56d	8d 00 dc	sta $dc00	          STA CIA1_KBD_COL    ; enable all columns
.c570	8d 2f d0	sta $d02f	          STA VIC_KBD         ; enable VIC keyboard
.c573	ae 01 dc	ldx $dc01	          LDX CIA1_KBD_ROW    ; get keypress row
.c576	e0 ff		cpx #$ff	          CPX #$ff            ; any keys down ?
.c578	d0 03		bne $c57d	          BNE SKBD_10         ; -> handle keypress
.c57a	4c 97 c6	jmp $c697	          JMP REPE_25           ; -> exit scan routine
.c57d	a8		tay		SKBD_10   TAY                 ; Y = 0
.c57e	ad 3e 03	lda $033e	          LDA DECODE          ; (KEYTAB) := (DECODE)
.c581	85 cc		sta $cc		          STA KEYTAB
.c583	ad 3f 03	lda $033f	          LDA DECODE+1
.c586	85 cd		sta $cd		          STA KEYTAB+1
.c588	a9 ff		lda #$ff	          LDA #$ff
.c58a	8d 2f d0	sta $d02f	          STA VIC_KBD
.c58d	2a		rol a		          ROL A               ; A = 1111 1110
.c58e	24 d3		bit $d3		SKBD_15   BIT SHFLAG          ; flag for Shift/Ctrl/CBM
.c590	30 05		bmi $c597	          BMI SKBD_20         ; -> scan VIC port (col 8/9/A)
.c592	8d 00 dc	sta $dc00	          STA CIA1_KBD_COL    ; use CIA column
.c595	10 03		bpl $c59a	          BPL SKBD_25         ; always
.c597	8d 2f d0	sta $d02f	SKBD_20   STA VIC_KBD         ; use VIC column
.c59a	a2 08		ldx #$08	SKBD_25   LDX #8              ; scan 8 rows per column
.c59c	48		pha		          PHA
.c59d	ad 01 dc	lda $dc01	SKBD_30   LDA CIA1_KBD_ROW    ; unclutter
.c5a0	cd 01 dc	cmp $dc01	          CMP CIA1_KBD_ROW
.c5a3	d0 f8		bne $c59d	          BNE SKBD_30
.c5a5	4a		lsr a		SKBD_35   LSR A               ; test row bit
.c5a6	b0 17		bcs $c5bf	          BCS SKBD_50         ; -> key not pressed
.c5a8	48		pha		          PHA                 ; push row value
.c5a9	b1 cc		lda ($cc),y	          LDA (KEYTAB),Y
.c5ab	c9 08		cmp #$08	          CMP #8              ; ALT key
.c5ad	f0 08		beq $c5b7	          BEQ SKBD_40
.c5af	c9 05		cmp #$05	          CMP #5
.c5b1	b0 09		bcs $c5bc	          BCS SKBD_45         ; -> no special keys
.c5b3	c9 03		cmp #$03	          CMP #3
.c5b5	f0 05		beq $c5bc	          BEQ SKBD_45         ; -> no special keys
.c5b7	05 d3		ora $d3		SKBD_40   ORA SHFLAG          ; set flags for modifier keys
.c5b9	85 d3		sta $d3		          STA SHFLAG
>c5bb	2c				          .byte $2c ;BIT                 ; skip next instruction
.c5bc	84 d4		sty $d4		SKBD_45   STY SFDX            ; key index
.c5be	68		pla		          PLA                 ; restore row value
.c5bf	c8		iny		SKBD_50   INY
.c5c0	ca		dex		          DEX
.c5c1	d0 e2		bne $c5a5	          BNE SKBD_35         ; -> loop row bits
.c5c3	c0 59		cpy #$59	          CPY #89
.c5c5	b0 10		bcs $c5d7	          BCS SKBD_55         ; -> finished
.c5c7	68		pla		          PLA
.c5c8	38		sec		          SEC
.c5c9	2a		rol a		          ROL A
.c5ca	b0 c2		bcs $c58e	          BCS SKBD_15         ; -> handle next key
.c5cc	8d 00 dc	sta $dc00	          STA CIA1_KBD_COL    ; select next column
.c5cf	26 d3		rol $d3		          ROL SHFLAG
.c5d1	38		sec		          SEC
.c5d2	66 d3		ror $d3		          ROR SHFLAG
.c5d4	2a		rol a		          ROL A
.c5d5	d0 b7		bne $c58e	          BNE SKBD_15
.c5d7	06 d3		asl $d3		SKBD_55   ASL SHFLAG
.c5d9	46 d3		lsr $d3		          LSR SHFLAG
.c5db	68		pla		          PLA
.c5dc	a5 d4		lda $d4		          LDA SFDX
.c5de	6c 3a 03	jmp ($033a)	          JMP (KEYVEC)        ; default: next statement
.c5e1					  Edit_Use_Scancode
.c5e1	c9 57		cmp #$57	          CMP #$57            ; NO SCROLL key
.c5e3	d0 13		bne $c5f8	          BNE SKBD_65
.c5e5	24 f7		bit $f7		          BIT LOCKS           ; halted by Ctrl-S ?
.c5e7	70 5a		bvs $c643	          BVS SKBD_Ret        ; -> yes: no action
.c5e9	ad 25 0a	lda $0a25	          LDA LSTHF           ; CBM-Shift delay ?
.c5ec	d0 55		bne $c643	          BNE SKBD_Ret
.c5ee	a9 0d		lda #$0d	          LDA #13             ; index for Ctrl-S
.c5f0	4d 21 0a	eor $0a21	          EOR PAUSE
.c5f3	8d 21 0a	sta $0a21	          STA PAUSE
.c5f6	50 30		bvc $c628	          BVC SKBD_75         ; always
.c5f8	a5 d3		lda $d3		SKBD_65   LDA SHFLAG
.c5fa	f0 55		beq $c651	          BEQ Edit_Repeat
.c5fc	c9 10		cmp #$10	          CMP #16             ; CAPS-LOCK/DIN ?
.c5fe	f0 44		beq $c644	          BEQ SKBD_85         ; -> no
.c600	c9 08		cmp #$08	          CMP #8              ; ALT ?
.c602	f0 42		beq $c646	          BEQ SKBD_90         ; -> no
.c604	29 07		and #$07	          AND #7
.c606	c9 03		cmp #$03	          CMP #3              ; CBM or Shift ?
.c608	d0 25		bne $c62f	          BNE SKBD_80         ; -> yes
.c60a	a5 f7		lda $f7		          LDA LOCKS
.c60c	30 43		bmi $c651	          BMI Edit_Repeat     ; -> Shiftr-CBM disabled
.c60e	ad 25 0a	lda $0a25	          LDA LSTHF           ; CBM-Shift delay ?
.c611	d0 3e		bne $c651	          BNE Edit_Repeat     ; -> decode key
.c613	24 d7		bit $d7		          BIT MODE_80
.c615	10 09		bpl $c620	          BPL SKBD_70         ; -> 40 column screen
.c617	a5 f1		lda $f1		          LDA E_Attribute
.c619	49 80		eor #$80	          EOR #$80
.c61b	85 f1		sta $f1		          STA E_Attribute
.c61d	4c 28 c6	jmp $c628	          JMP SKBD_75
.c620	ad 2c 0a	lda $0a2c	SKBD_70   LDA VSH_TEXT
.c623	49 02		eor #$02	          EOR #2
.c625	8d 2c 0a	sta $0a2c	          STA VSH_TEXT
.c628	a9 08		lda #$08	SKBD_75   LDA #8
.c62a	8d 25 0a	sta $0a25	          STA LSTHF           ; set timer
.c62d	d0 22		bne $c651	          BNE Edit_Repeat          ; always
.c62f	0a		asl a		SKBD_80   ASL A
.c630	c9 08		cmp #$08	          CMP #8
.c632	90 12		bcc $c646	          BCC SKBD_90         ; -> no Ctrl
.c634	a9 06		lda #$06	          LDA #6              ; select Keytab_Control
.c636	a6 d4		ldx $d4		          LDX SFDX
.c638	e0 0d		cpx #$0d	          CPX #13             ; key 'S' ?
.c63a	d0 0a		bne $c646	          BNE SKBD_90         ; -> no
.c63c	24 f7		bit $f7		          BIT LOCKS
.c63e	70 06		bvs $c646	          BVS SKBD_90
.c640	8e 21 0a	stx $0a21	          STX PAUSE           ; flag pause Ctrl-S
.c643	60		rts		SKBD_Ret  RTS
.c644	a9 0a		lda #$0a	SKBD_85   LDA #10             ; select Keytab_Capslock
.c646	aa		tax		SKBD_90   TAX
.c647	bd 3e 03	lda $033e,x	          LDA DECODE,X        ; set KEYRAB pointer
.c64a	85 cc		sta $cc		          STA KEYTAB
.c64c	bd 3f 03	lda $033f,x	          LDA DECODE+1,X
.c64f	85 cd		sta $cd		          STA KEYTAB+1
.c651					  Edit_Repeat
.c651	a4 d4		ldy $d4		          LDY SFDX            ; key index
.c653	b1 cc		lda ($cc),y	          LDA (KEYTAB),Y      ; key value
.c655	aa		tax		          TAX
.c656	c4 d5		cpy $d5		          CPY LSTX            ; equal to last used index ?
.c658	f0 07		beq $c661	          BEQ REPE_10         ; -> check repeat condition
.c65a	a0 10		ldy #$10	          LDY #16
.c65c	8c 24 0a	sty $0a24	          STY DELAY           ; set initial delay
.c65f	d0 36		bne $c697	          BNE REPE_25         ; always
.c661	29 7f		and #$7f	REPE_10   AND #$7f
.c663	2c 22 0a	bit $0a22	          BIT RPTFLG
.c666	30 16		bmi $c67e	          BMI REPE_15         ; -> $80 = all keys repeat
.c668	70 5a		bvs $c6c4	          BVS UFK_20          ; -> $40 = no  keys repeat
.c66a	c9 7f		cmp #$7f	          CMP #$7f            ; NO SCROLL ($ff)
.c66c	f0 29		beq $c697	          BEQ REPE_25         ; -> repeat not
.c66e	c9 14		cmp #$14	          CMP #$14            ; DELETE / INSERT
.c670	f0 0c		beq $c67e	          BEQ REPE_15         ; -> repeat
.c672	c9 20		cmp #$20	          CMP #' '            ; BLANK
.c674	f0 08		beq $c67e	          BEQ REPE_15         ; -> repeat
.c676	c9 1d		cmp #$1d	          CMP #RIGHT          ; cursor left / right
.c678	f0 04		beq $c67e	          BEQ REPE_15         ; -> repeat
.c67a	c9 11		cmp #$11	          CMP #DOWN           ; cursor down / up
.c67c	d0 46		bne $c6c4	          BNE UFK_20          ; -> repeat not
.c67e	ac 24 0a	ldy $0a24	REPE_15   LDY DELAY
.c681	f0 05		beq $c688	          BEQ REPE_20         ; delay OK -> continue
.c683	ce 24 0a	dec $0a24	          DEC DELAY
.c686	d0 3c		bne $c6c4	          BNE UFK_20          ; -> don't repeat while delaying
.c688	ce 23 0a	dec $0a23	REPE_20   DEC KOUNT
.c68b	d0 37		bne $c6c4	          BNE UFK_20          ; -> don't repeat too fast
.c68d	a0 04		ldy #$04	          LDY #4
.c68f	8c 23 0a	sty $0a23	          STY KOUNT           ; set new speed counter
.c692	a4 d0		ldy $d0		          LDY NDX             ; keys in buffer
.c694	88		dey		          DEY
.c695	10 2d		bpl $c6c4	          BPL UFK_20          ; -> don't repeat if buffer is not empty
.c697	4e 25 0a	lsr $0a25	REPE_25   LSR LSTHF
.c69a	a4 d4		ldy $d4		          LDY SFDX
.c69c	84 d5		sty $d5		          STY LSTX            ; last index = current index
.c69e	e0 ff		cpx #$ff	          CPX #$ff            ; NO SCROLL key ?
.c6a0	f0 22		beq $c6c4	          BEQ UFK_20          ; -> finish
.c6a2	a9 00		lda #$00	          LDA #0
.c6a4	8d 21 0a	sta $0a21	          STA PAUSE           ; clear Ctrl-S, scroll lock
.c6a7	8a		txa		          TXA
.c6a8	a6 d3		ldx $d3		          LDX SHFLAG
.c6aa	4c c6 fc	jmp $fcc6	          JMP Check_DIN
.c6ad					  Edit_Use_Function_Key
.c6ad	a2 09		ldx #$09	          LDX #9
.c6af	dd dd c6	cmp $c6dd,x	UFK_10    CMP FKey_Code,X
.c6b2	f0 16		beq $c6ca	          BEQ UFK_30
.c6b4	ca		dex		          DEX
.c6b5	10 f8		bpl $c6af	          BPL UFK_10
.c6b7	a6 d0		ldx $d0		          LDX NDX
.c6b9	ec 20 0a	cpx $0a20	          CPX XMAX
.c6bc	b0 06		bcs $c6c4	          BCS UFK_20
.c6be	9d 4a 03	sta $034a,x	          STA KEYD,X
.c6c1	e8		inx		          INX
.c6c2	86 d0		stx $d0		          STX NDX
.c6c4	a9 7f		lda #$7f	UFK_20    LDA #$7f
.c6c6	8d 00 dc	sta $dc00	          STA CIA1_KBD_COL
.c6c9	60		rts		          RTS
.c6ca	4c 00 cf	jmp $cf00	UFK_30    JMP UFK_40
.c6cd	85 d1		sta $d1		          STA KYNDX           ; unused. replaced by patch
.c6cf	a9 00		lda #$00	          LDA #0              ; startimg at UFK_40 ($cf00)
.c6d1	ca		dex		REPE_50   DEX                 ; *
.c6d2	30 06		bmi $c6da	          BMI REPE_55         ; *
.c6d4	18		clc		          CLC                 ; *
.c6d5	7d 00 10	adc $1000,x	          ADC PKYBUF,X        ; *
.c6d8	90 f7		bcc $c6d1	          BCC REPE_50         ; *
.c6da	85 d2		sta $d2		REPE_55   STA KEYIDX          ; *
.c6dc	60		rts		          RTS                 ; *
.c6dd					  FKey_Code
>c6dd	85				          .BYTE $85           ; f1   graphic
>c6de	89				          .BYTE $89           ; f2   dload"
>c6df	86				          .BYTe $86           ; f3   directory
>c6e0	8a				          .BYTE $8a           ; f4   scnclr
>c6e1	87				          .BYTE $87           ; f5   dsave"
>c6e2	8b				          .BYTE $8b           ; f6   run
>c6e3	88				          .BYTE $88           ; f7   list
>c6e4	8c				          .BYTE $8c           ; f8   monitor
>c6e5	83				          .BYTE $83           ; RUN
>c6e6	84				          .BYTE $84           ; HELP
.c6e7					  Blink_Cursor
.c6e7	24 d7		bit $d7		          BIT MODE_80
.c6e9	30 41		bmi $c72c	          BMI BlCu_Ret        ; -> 80 column screen
.c6eb	ad 27 0a	lda $0a27	          LDA BLNSW
.c6ee	d0 3c		bne $c72c	          BNE BlCu_Ret        ; -> blinking off
.c6f0	ce 28 0a	dec $0a28	          DEC BLNCT           ; blink counter
.c6f3	d0 37		bne $c72c	          BNE BlCu_Ret        ; -> no change yet
.c6f5	ad 26 0a	lda $0a26	          LDA BLNON
.c6f8	29 c0		and #$c0	          AND #$c0            ; blinking on, steady cursor
.c6fa	c9 c0		cmp #$c0	          CMP #$c0
.c6fc	f0 2e		beq $c72c	          BEQ BlCu_Ret        ; -> nothing to do
.c6fe	a9 14		lda #$14	          LDA #20
.c700	8d 28 0a	sta $0a28	          STA BLNCT           ; restart blink timer
.c703	a4 ec		ldy $ec		          LDY Cursor_Col
.c705	ae 2a 0a	ldx $0a2a	          LDX GDCOL
.c708	b1 e0		lda ($e0),y	          LDA (PNT),Y         ; character under cursor
.c70a	2c 26 0a	bit $0a26	          BIT BLNON
.c70d	30 10		bmi $c71f	          BMI BlCu_10         ; -> visible cursor phase
.c70f	8d 29 0a	sta $0a29	          STA GDBLN           ; save chracter under cursor
.c712	20 7c c1	jsr $c17c	          JSR Set_Attribute_Pointer
.c715	b1 e2		lda ($e2),y	          LDA (USER),Y        ; color under cursor
.c717	8d 2a 0a	sta $0a2a	          STA GDCOL           ; save color under cursor
.c71a	a6 f1		ldx $f1		          LDX E_Attribute
.c71c	ad 29 0a	lda $0a29	          LDA GDBLN
.c71f	49 80		eor #$80	BlCu_10   EOR #$80            ; toggle color
.c721	20 40 cc	jsr $cc40	          JSR Edit_Display_AX
.c724	ad 26 0a	lda $0a26	          LDA BLNON
.c727	49 80		eor #$80	          EOR #$80            ; toggle cursor blink phase
.c729	8d 26 0a	sta $0a26	          STA BLNON
.c72c	60		rts		BlCu_Ret  RTS
.c72d					  Edit_Print
.c72d	85 ef		sta $ef		          STA DATAX           ; save character to print
.c72f	48		pha		          PHA                 ; push A
.c730	8a		txa		          TXA
.c731	48		pha		          PHA                 ; push X
.c732	98		tya		          TYA
.c733	48		pha		          PHA                 ; push Y
.c734	ad 21 0a	lda $0a21	EdPr_10   LDA PAUSE
.c737	d0 fb		bne $c734	          BNE EdPr_10
.c739	85 d6		sta $d6		          STA CRSW            ; 0 = keyboard input
.c73b	a9 c3		lda #$c3	          LDA #>Edit_Print_Exit-1
.c73d	48		pha		          PHA
.c73e	a9 0b		lda #$0b	          LDA #<Edit_Print_Exit-1
.c740	48		pha		          PHA
.c741	a4 ec		ldy $ec		          LDY Cursor_Col
.c743	a5 ef		lda $ef		          LDA DATAX
.c745	c9 0d		cmp #$0d	          CMP #CR
.c747	f0 26		beq $c76f	          BEQ EdPr_50         ; -> new line
.c749	c9 8d		cmp #$8d	          CMP #$8d            ; shift CR
.c74b	f0 22		beq $c76f	          BEQ EdPr_50         ; -> new line
.c74d	a6 f0		ldx $f0		          LDX LSTCHR
.c74f	e0 1b		cpx #$1b	          CPX #ESC
.c751	d0 03		bne $c756	          BNE EdPr_20
.c753	4c be c9	jmp $c9be	          JMP Edit_Escape_Jump           ; ESC command
.c756	aa		tax		EdPr_20   TAX
.c757	10 03		bpl $c75c	          BPL EdPr_30
.c759	4c 02 c8	jmp $c802	          JMP Edit_Jump_Shifted
.c75c	c9 20		cmp #$20	EdPr_30   CMP #' '
.c75e	90 56		bcc $c7b6	          BCC Edit_Jump_Ctrl           ; control character
.c760	c9 60		cmp #$60	          CMP #$60
.c762	90 03		bcc $c767	          BCC EdPr_40         ; normal character
.c764	29 df		and #$df	          AND #%11011111
>c766	2c				          .byte $2c ;BIT
.c767	29 3f		and #$3f	EdPr_40   AND #%00111111
.c769	20 ff c2	jsr $c2ff	          JSR Edit_Toggle_Quote
.c76c	4c 22 c3	jmp $c322	          JMP PTS_10          ; print to screen
.c76f	20 c3 cb	jsr $cbc3	EdPr_50   JSR Edit_Cursor_Last
.c772	e8		inx		          INX
.c773	20 85 cb	jsr $cb85	          JSR Clear_Cont_Flag
.c776	a4 e6		ldy $e6		          LDY Margin_Left
.c778	84 ec		sty $ec		          STY Cursor_Col
.c77a	20 63 c3	jsr $c363	          JSR Edit_Cursor_Down
.c77d					  Edit_Attributes_Off
.c77d	a5 f1		lda $f1		          LDA E_Attribute
.c77f	29 cf		and #$cf	          AND #%11001111 ; $cf
.c781	85 f1		sta $f1		          STA E_Attribute
.c783	a9 00		lda #$00	          LDA #0
.c785	85 f5		sta $f5		          STA INSRT
.c787	85 f3		sta $f3		          STA E_Reverse
.c789	85 f4		sta $f4		          STA QTSW
.c78b	60		rts		          RTS
.c78c					  Ctrl_Code
>c78c	02				          .BYTE $02           ; Ctrl B
>c78d	07				          .BYTE $07           ; Ctrl G
>c78e	09				          .BYTE $09           ; TAB
>c78f	0a				          .BYTE $0a           ; Ctrl J
>c790	0b				          .BYTE $0b           ; Ctrl K
>c791	0c				          .BYTE $0c           ; Ctrl L
>c792	0e				          .BYTE $0e           ; Ctrl N
>c793	0f				          .BYTE $0f           ; Ctrl O
>c794	11				          .BYTE $11           ; Ctrl Q
>c795	12				          .BYTE $12           ; Ctrl R
>c796	13				          .BYTE $13           ; HOME
>c797	14				          .BYTE $14           ; DEL
>c798	18				          .BYTE $18           ; Ctrl X
>c799	1d				          .BYTE $1d           ; Cursor Right
.c79a					  Ctrl_Action
>c79a	c6 c8				          .WORD Edit_Underline_On      - 1 ; Ctrl B Bold
>c79c	8d c9				          .WORD Ctrl_G_Bell            - 1
>c79e	4e c9				          .WORD Ctrl_I_Tab             - 1
>c7a0	b0 c9				          .WORD Ctrl_J_Linefeed        - 1
>c7a2	a5 c8				          .WORD Ctrl_K_Unlock_Charset  - 1
>c7a4	ab c8				          .WORD Ctrl_L_Lock_Charset    - 1
>c7a6	7f c8				          .WORD Edit_Charset_Text      - 1 ; Ctrl N Normal
>c7a8	d4 c8				          .WORD Edit_Blink_On          - 1 ; Ctrl O
>c7aa	59 c8				          .WORD Ctrl_Q_Down            - 1
>c7ac	c1 c8				          .WORD Edit_Reverse_On        - 1 ; Ctrl R Reverse
>c7ae	b2 c8				          .WORD Edit_Home              - 1
>c7b0	1a c9				          .WORD Edit_Delete            - 1
>c7b2	60 c9				          .WORD Edit_Toggle_Tab        - 1
>c7b4	53 c8				          .WORD Edit_Right             - 1
.c7b6					  Edit_Jump_Ctrl
.c7b6	6c 34 03	jmp ($0334)	          JMP (CTLVEC)        ; default: next statement
.c7b9					  Edit_Use_Ctrl
.c7b9	c9 1b		cmp #$1b	          CMP #ESC            ; Escape ?
.c7bb	f0 38		beq $c7f5	          BEQ ICtr_80         ; -> no action
.c7bd	a6 f5		ldx $f5		          LDX INSRT
.c7bf	d0 08		bne $c7c9	          BNE ICtr_10         ; -> outstanding inserts
.c7c1	c9 14		cmp #$14	          CMP #DEL
.c7c3	f0 0b		beq $c7d0	          BEQ ICtr_20         ; -> Delete
.c7c5	a6 f4		ldx $f4		          LDX QTSW
.c7c7	f0 07		beq $c7d0	          BEQ ICtr_20         ; -> not in quotes
.c7c9	a2 00		ldx #$00	ICtr_10   LDX #0
.c7cb	86 ef		stx $ef		          STX DATAX           ; ignore character
.c7cd	4c 26 c3	jmp $c326	          JMP PTS_20
.c7d0	a2 0d		ldx #$0d	ICtr_20   LDX #13
.c7d2	dd 8c c7	cmp $c78c,x	ICtr_30   CMP Ctrl_Code,X
.c7d5	f0 1f		beq $c7f6	          BEQ ICtr_90         ; -> found code
.c7d7	ca		dex		          DEX
.c7d8	10 f8		bpl $c7d2	          BPL ICtr_30
.c7da	a2 0f		ldx #$0f	ICtr_40   LDX #15
.c7dc	dd 4c ce	cmp $ce4c,x	ICtr_50   CMP VIC_Color_Codes,X        ; search color codes
.c7df	f0 04		beq $c7e5	          BEQ ICtr_60
.c7e1	ca		dex		          DEX
.c7e2	10 f8		bpl $c7dc	          BPL ICtr_50
.c7e4	60		rts		          RTS
.c7e5	24 d7		bit $d7		ICtr_60   BIT MODE_80
.c7e7	30 03		bmi $c7ec	          BMI ICtr_70
.c7e9	86 f1		stx $f1		          STX E_Attribute
.c7eb	60		rts		          RTS
.c7ec	a5 f1		lda $f1		ICtr_70   LDA E_Attribute
.c7ee	29 f0		and #$f0	          AND #%11110000 ; $f0
.c7f0	1d 5c ce	ora $ce5c,x	          ORA VDC_Color_Codes,X
.c7f3	85 f1		sta $f1		          STA E_Attribute
.c7f5	60		rts		ICtr_80   RTS
.c7f6	8a		txa		ICtr_90   TXA
.c7f7	0a		asl a		          ASL A
.c7f8	aa		tax		          TAX                 ; push address
.c7f9	bd 9b c7	lda $c79b,x	          LDA Ctrl_Action+1,X
.c7fc	48		pha		          PHA
.c7fd	bd 9a c7	lda $c79a,x	          LDA Ctrl_Action,X
.c800	48		pha		          PHA
.c801	60		rts		          RTS                 ; jump via RTS
.c802					  Edit_Jump_Shifted
.c802	6c 36 03	jmp ($0336)	          JMP (SHFVEC)        ; default: next statement
.c805					  Edit_Print_Shifted
.c805	29 7f		and #$7f	          AND #$7f            ; remove PETSCII shift bit
.c807	c9 20		cmp #$20	          CMP #' '
.c809	90 09		bcc $c814	          BCC PrSh_20         ; -> control codes
.c80b	c9 7f		cmp #$7f	          CMP #$7f
.c80d	d0 02		bne $c811	          BNE PrSh_10
.c80f	a9 5e		lda #$5e	          LDA #'^'            ; replace code $ff with $5e
.c811	4c 20 c3	jmp $c320	PrSh_10   JMP Print_To_Screen
.c814	a6 f4		ldx $f4		PrSh_20   LDX QTSW
.c816	f0 05		beq $c81d	          BEQ PrSh_40         ; -> not in quotemode
.c818	09 40		ora #$40	PrSh_30   ORA #%01000000     ; convert to display code
.c81a	4c 26 c3	jmp $c326	          JMP PTS_20
.c81d	c9 14		cmp #$14	PrSh_40   CMP #DEL            ; INSERT ? (Shift DEL)
.c81f	d0 03		bne $c824	          BNE PrSh_50
.c821	4c e3 c8	jmp $c8e3	          JMP Edit_Shift_Text
.c824	a6 f5		ldx $f5		PrSh_50   LDX INSRT
.c826	d0 f0		bne $c818	          BNE PrSh_30         ; -> already in insert mode
.c828	c9 11		cmp #$11	          CMP #DOWN           ; Cursor UP ?
.c82a	f0 3b		beq $c867	          BEQ Edit_Up
.c82c	c9 1d		cmp #$1d	          CMP #RIGHT          ; Cursor LEFT ?
.c82e	f0 45		beq $c875	          BEQ Edit_Left
.c830	c9 0e		cmp #$0e	          CMP #14             ; graphics charset ? ($8e)
.c832	f0 5e		beq $c892	          BEQ EdCT_20
.c834	c9 12		cmp #$12	          CMP #REVERSE        ; Reverse off ? ($92)
.c836	d0 03		bne $c83b	          BNE PrSh_60
.c838	4c bf c8	jmp $c8bf	          JMP Edit_Reverse_Off
.c83b	c9 02		cmp #$02	PrSh_60   CMP #C_ULINE        ; Underline off ? ($82)
.c83d	d0 03		bne $c842	          BNE PrSh_70
.c83f	4c ce c8	jmp $c8ce	          JMP Edit_Underline_Off
.c842	c9 0f		cmp #$0f	PrSh_70   CMP #15             ; Blinking off ? ($8f)
.c844	d0 03		bne $c849	          BNE PrSh_80
.c846	4c dc c8	jmp $c8dc	          JMP Edit_Blink_Off
.c849	c9 13		cmp #$13	PrSh_80   CMP #HOME           ; CLEAR ? ($93)
.c84b	d0 03		bne $c850	          BNE PrSh_90
.c84d	4c 42 c1	jmp $c142	          JMP Clear_Window
.c850	09 80		ora #$80	PrSh_90   ORA #$80            ; restore shift bit
.c852	d0 86		bne $c7da	          BNE ICtr_40         ; always
.c854					  Edit_Right
.c854	20 ed cb	jsr $cbed	          JSR Edit_Cursor_Right
.c857	b0 04		bcs $c85d	          BCS Edit_Down
.c859	60		rts		          RTS
.c85a					  Ctrl_Q_Down
.c85a	20 63 c3	jsr $c363	          JSR Edit_Cursor_Down
.c85d					  Edit_Down
.c85d	20 74 cb	jsr $cb74	          JSR Is_Coupled_Row
.c860	b0 03		bcs $c865	          BCS EdDo_10
.c862	38		sec		          SEC
.c863	66 e8		ror $e8		          ROR CurLst_Row      ; flag coupled row
.c865	18		clc		EdDo_10   CLC
.c866	60		rts		EdDo_Ret  RTS
.c867					  Edit_Up
.c867	a6 e5		ldx $e5		          LDX Margin_Top
.c869	e4 eb		cpx $eb		          CPX Cursor_Row
.c86b	b0 f9		bcs $c866	          BCS EdDo_Ret
.c86d	20 5d c8	jsr $c85d	EdUp_10   JSR Edit_Down
.c870	c6 eb		dec $eb		          DEC Cursor_Row
.c872	4c 5c c1	jmp $c15c	          JMP Set_Screen_Pointer
.c875					  Edit_Left
.c875	20 00 cc	jsr $cc00	          JSR Edit_Cursor_Left
.c878	b0 ec		bcs $c866	          BCS EdDo_Ret
.c87a	d0 e9		bne $c865	          BNE EdDo_10
.c87c	e6 eb		inc $eb		          INC Cursor_Row
.c87e	d0 ed		bne $c86d	          BNE EdUp_10         ; always
.c880					  Edit_Charset_Text
.c880	24 d7		bit $d7		          BIT MODE_80
.c882	30 07		bmi $c88b	          BMI EdCT_10
.c884	ad 2c 0a	lda $0a2c	          LDA VSH_TEXT
.c887	09 02		ora #$02	          ORA #%00000010 ; $02
.c889	d0 10		bne $c89b	          BNE EdCT_30         ; always
.c88b	a5 f1		lda $f1		EdCT_10   LDA E_Attribute
.c88d	09 80		ora #$80	          ORA #%10000000 ; $80
.c88f	85 f1		sta $f1		          STA E_Attribute
.c891	60		rts		          RTS
.c892	24 d7		bit $d7		EdCT_20   BIT MODE_80
.c894	30 09		bmi $c89f	          BMI EdCT_40
.c896	ad 2c 0a	lda $0a2c	          LDA VSH_TEXT
.c899	29 fd		and #$fd	          AND #%11111101 ; $fd
.c89b	8d 2c 0a	sta $0a2c	EdCT_30   STA VSH_TEXT
.c89e	60		rts		          RTS
.c89f	a5 f1		lda $f1		EdCT_40   LDA E_Attribute
.c8a1	29 7f		and #$7f	          AND #%01111111 ; $7f
.c8a3	85 f1		sta $f1		          STA E_Attribute
.c8a5	60		rts		          RTS
.c8a6					  Ctrl_K_Unlock_Charset
.c8a6	a9 80		lda #$80	          LDA #$80
.c8a8	05 f7		ora $f7		          ORA LOCKS
.c8aa	30 04		bmi $c8b0	          BMI LUCS_10
.c8ac					  Ctrl_L_Lock_Charset
.c8ac	a9 7f		lda #$7f	          LDA #$7f
.c8ae	25 f7		and $f7		          AND LOCKS
.c8b0	85 f7		sta $f7		LUCS_10   STA LOCKS
.c8b2	60		rts		          RTS
.c8b3					  Edit_Home
.c8b3	a5 f0		lda $f0		          LDA LSTCHR
.c8b5	c9 13		cmp #$13	          CMP #HOME
.c8b7	d0 03		bne $c8bc	          BNE EdHo_10
.c8b9	20 24 ca	jsr $ca24	          JSR Set_Fullscreen  ; 2 x HOME sets fullsize window
.c8bc	4c 50 c1	jmp $c150	EdHo_10   JMP Cursor_To_Window_Home
.c8bf					  Edit_Reverse_Off
.c8bf	a9 00		lda #$00	          LDA #0
>c8c1	2c				          .byte $2c ;BIT
.c8c2					  Edit_Reverse_On
.c8c2	a9 80		lda #$80	          LDA #$80
.c8c4	85 f3		sta $f3		          STA E_Reverse
.c8c6	60		rts		          RTS
.c8c7					  Edit_Underline_On
.c8c7	a5 f1		lda $f1		          LDA E_Attribute
.c8c9	09 20		ora #$20	          ORA #%00100000
.c8cb	85 f1		sta $f1		          STA E_Attribute
.c8cd	60		rts		          RTS
.c8ce					  Edit_Underline_Off
.c8ce	a5 f1		lda $f1		          LDA E_Attribute
.c8d0	29 df		and #$df	          AND #%11011111 ; $df
.c8d2	85 f1		sta $f1		          STA E_Attribute
.c8d4	60		rts		          RTS
.c8d5					  Edit_Blink_On
.c8d5	a5 f1		lda $f1		          LDA E_Attribute
.c8d7	09 10		ora #$10	          ORA #%00010000
.c8d9	85 f1		sta $f1		          STA E_Attribute
.c8db	60		rts		          RTS
.c8dc					  Edit_Blink_Off
.c8dc	a5 f1		lda $f1		          LDA E_Attribute
.c8de	29 ef		and #$ef	          AND #%11101111 ; $ef
.c8e0	85 f1		sta $f1		          STA E_Attribute
.c8e2	60		rts		          RTS
.c8e3					  Edit_Shift_Text
.c8e3	20 1e cc	jsr $cc1e	          JSR Edit_Save_Row_Col
.c8e6	20 c3 cb	jsr $cbc3	          JSR Edit_Cursor_Last
.c8e9	e4 df		cpx $df		          CPX E_Row           ; at last row ?
.c8eb	d0 02		bne $c8ef	          BNE EdST_10         ; -> no
.c8ed	c4 de		cpy $de		          CPY E_Col
.c8ef	90 21		bcc $c912	EdST_10   BCC EdST_30
.c8f1	20 3e c3	jsr $c33e	          JSR Edit_Cursor_Next
.c8f4	b0 22		bcs $c918	          BCS EdST_40
.c8f6	20 00 cc	jsr $cc00	EdST_20   JSR Edit_Cursor_Left
.c8f9	20 58 cb	jsr $cb58	          JSR Edit_Get_Char
.c8fc	20 ed cb	jsr $cbed	          JSR Edit_Cursor_Right
.c8ff	20 32 cc	jsr $cc32	          JSR Edit_Put_Char
.c902	20 00 cc	jsr $cc00	          JSR Edit_Cursor_Left
.c905	a6 eb		ldx $eb		          LDX Cursor_Row
.c907	e4 df		cpx $df		          CPX E_Row
.c909	d0 eb		bne $c8f6	          BNE EdST_20
.c90b	c4 de		cpy $de		          CPY E_Col
.c90d	d0 e7		bne $c8f6	          BNE EdST_20
.c90f	20 27 cc	jsr $cc27	          JSR Edit_Put_Blank
.c912	e6 f5		inc $f5		EdST_30   INC INSRT
.c914	d0 02		bne $c918	          BNE EdST_40
.c916	c6 f5		dec $f5		          DEC INSRT
.c918	4c 32 c9	jmp $c932	EdST_40   JMP EdDe_20
.c91b					  Edit_Delete
.c91b	20 75 c8	jsr $c875	          JSR Edit_Left
.c91e	20 1e cc	jsr $cc1e	          JSR Edit_Save_Row_Col ; destination position
.c921	b0 0f		bcs $c932	          BCS EdDe_20           ; -> nothing to delete
.c923	c4 e7		cpy $e7		EdDe_10   CPY Margin_Right      ; at end of previous row ?
.c925	90 16		bcc $c93d	          BCC EdDe_30           ; -> no
.c927	a6 eb		ldx $eb		          LDX Cursor_Row
.c929	e8		inx		          INX
.c92a	20 76 cb	jsr $cb76	          JSR Is_Coupled_Row_X
.c92d	b0 0e		bcs $c93d	          BCS EdDe_30           ; -> yes
.c92f	20 27 cc	jsr $cc27	          JSR Edit_Put_Blank
.c932	a5 de		lda $de		EdDe_20   LDA E_Col
.c934	85 ec		sta $ec		          STA Cursor_Col
.c936	a5 df		lda $df		          LDA E_Row
.c938	85 eb		sta $eb		          STA Cursor_Row
.c93a	4c 5c c1	jmp $c15c	          JMP Set_Screen_Pointer
.c93d	20 ed cb	jsr $cbed	EdDe_30   JSR Edit_Cursor_Right
.c940	20 58 cb	jsr $cb58	          JSR Edit_Get_Char
.c943	20 00 cc	jsr $cc00	          JSR Edit_Cursor_Left
.c946	20 32 cc	jsr $cc32	          JSR Edit_Put_Char
.c949	20 ed cb	jsr $cbed	          JSR Edit_Cursor_Right
.c94c	4c 23 c9	jmp $c923	          JMP EdDe_10
.c94f					  Ctrl_I_Tab
.c94f	a4 ec		ldy $ec		          LDY Cursor_Col
.c951	c8		iny		ETab_10   INY
.c952	c4 e7		cpy $e7		          CPY Margin_Right
.c954	b0 06		bcs $c95c	          BCS ETab_20
.c956	20 6c c9	jsr $c96c	          JSR Jc96c
.c959	f0 f6		beq $c951	          BEQ ETab_10
>c95b	2c				          .byte $2c ;BIT
.c95c	a4 e7		ldy $e7		ETab_20   LDY Margin_Right
.c95e	84 ec		sty $ec		          STY Cursor_Col
.c960	60		rts		          RTS
.c961					  Edit_Toggle_Tab
.c961	a4 ec		ldy $ec		          LDY Cursor_Col
.c963	20 6c c9	jsr $c96c	          JSR Jc96c
.c966	45 da		eor $da		          EOR E_Beg
.c968	9d 54 03	sta $0354,x	          STA TABMAP,X
.c96b	60		rts		          RTS
.c96c					  Jc96c
.c96c	98		tya		          TYA
.c96d	29 07		and #$07	          AND #%00000111 ; $07
.c96f	aa		tax		          TAX
.c970	bd 6c ce	lda $ce6c,x	          LDA Edit_Bit_Mask,X
.c973	85 da		sta $da		          STA E_Beg
.c975	98		tya		          TYA
.c976	4a		lsr a		          LSR A
.c977	4a		lsr a		          LSR A
.c978	4a		lsr a		          LSR A
.c979	aa		tax		          TAX
.c97a	bd 54 03	lda $0354,x	          LDA TABMAP,X
.c97d	24 da		bit $da		          BIT E_Beg
.c97f	60		rts		          RTS
.c980					  Clear_All_Tabstops
.c980	a9 00		lda #$00	          LDA #0
>c982	2c				          .byte $2c ;BIT
.c983					  Set_Default_Tabstops
.c983	a9 80		lda #$80	          LDA #$80           ; set tab on every 8th. column
.c985	a2 09		ldx #$09	          LDX #9             ; use 10 bytes for 80 columns
.c987	9d 54 03	sta $0354,x	STAB_10   STA TABMAP,X
.c98a	ca		dex		          DEX
.c98b	10 fa		bpl $c987	          BPL STAB_10
.c98d	60		rts		STAB_Ret  RTS
.c98e					  Ctrl_G_Bell
.c98e	24 f9		bit $f9		          BIT BEEPER
.c990	30 fb		bmi $c98d	          BMI STAB_Ret
.c992	a9 15		lda #$15	          LDA #$15
.c994	8d 18 d4	sta $d418	          STA SID_Volume
.c997	a0 09		ldy #$09	          LDY #<CHARAC
.c999	a2 00		ldx #$00	          LDX #>CHARAC
.c99b	8c 05 d4	sty $d405	          STY SID_Attack_1
.c99e	8e 06 d4	stx $d406	          STX SID_Sustain_1
.c9a1	a9 30		lda #$30	          LDA #$30
.c9a3	8d 01 d4	sta $d401	          STA SID_Freq_1+1
.c9a6	a9 20		lda #$20	          LDA #$20
.c9a8	8d 04 d4	sta $d404	          STA SID_Control_1
.c9ab	a9 21		lda #$21	          LDA #$21
.c9ad	8d 04 d4	sta $d404	          STA SID_Control_1
.c9b0	60		rts		          RTS
.c9b1					  Ctrl_J_Linefeed
.c9b1	a5 ec		lda $ec		          LDA Cursor_Col
.c9b3	48		pha		          PHA
.c9b4	20 c3 cb	jsr $cbc3	          JSR Edit_Cursor_Last
.c9b7	20 63 c3	jsr $c363	          JSR Edit_Cursor_Down
.c9ba	68		pla		          PLA
.c9bb	85 ec		sta $ec		          STA Cursor_Col
.c9bd	60		rts		          RTS
.c9be					  Edit_Escape_Jump
.c9be	6c 38 03	jmp ($0338)	          JMP (ESCVEC)        ; default: next instruction
.c9c1					  Edit_Escape_Switch
.c9c1	c9 1b		cmp #$1b	          CMP #ESC
.c9c3	d0 05		bne $c9ca	          BNE EdES_10
.c9c5	46 ef		lsr $ef		          LSR DATAX           ; DATAX = CR (ESC >> 1)
.c9c7	4c 7d c7	jmp $c77d	          JMP Edit_Attributes_Off
.c9ca	29 7f		and #$7f	EdES_10   AND #$7f
.c9cc	38		sec		          SEC
.c9cd	e9 40		sbc #$40	          SBC #'@'            ; from ESC @
.c9cf	c9 1b		cmp #$1b	          CMP #$1b            ; to   ESC Z
.c9d1	b0 0a		bcs $c9dd	          BCS EdES_Ret        ; -> out of range
.c9d3	0a		asl a		          ASL A
.c9d4	aa		tax		          TAX
.c9d5	bd df c9	lda $c9df,x	          LDA Edit_Escape_Case+1,X
.c9d8	48		pha		          PHA
.c9d9	bd de c9	lda $c9de,x	          LDA Edit_Escape_Case,X
.c9dc	48		pha		          PHA
.c9dd	60		rts		EdES_Ret  RTS
.c9de					  Edit_Escape_Case
>c9de	9e ca				          .WORD Edit_Erase_EOS       - 1 ; ESC @
>c9e0	ec ca				          .WORD Edit_Auto_Insert_On  - 1 ; ESC A Auto
>c9e2	15 ca				          .WORD Edit_Set_Window_LR   - 1 ; ESC B Bottom
>c9e4	e9 ca				          .WORD Edit_Auto_Insert_Off - 1 ; ESC C
>c9e6	51 ca				          .WORD Edit_Delete_Line     - 1 ; ESC D Delete
>c9e8	0a cb				          .WORD Edit_Steady_Cursor   - 1 ; ESC E
>c9ea	20 cb				          .WORD Edit_Blinking_Cursor - 1 ; ESC F Flickering
>c9ec	36 cb				          .WORD Edit_Enable_Bell     - 1 ; ESC G
>c9ee	39 cb				          .WORD Edit_Disable_Bell    - 1 ; ESC H
>c9f0	3c ca				          .WORD Edit_Insert_Line     - 1 ; ESC I Insert
>c9f2	b0 cb				          .WORD Edit_Cursor_BOL      - 1 ; ESC J
>c9f4	51 cb				          .WORD Edit_Cursor_EOL      - 1 ; ESC K
>c9f6	e1 ca				          .WORD Edit_Scroll_Unlock   - 1 ; ESC L
>c9f8	e4 ca				          .WORD Edit_Scroll_Lock     - 1 ; ESC M
>c9fa	47 cb				          .WORD Edit_Inverse_Off     - 1 ; ESC N
>c9fc	7c c7				          .WORD Edit_Attributes_Off  - 1 ; ESC O Off
>c9fe	8a ca				          .WORD Edit_Erase_BOL       - 1 ; ESC P
>ca00	75 ca				          .WORD Edit_Erase_EOL       - 1 ; ESC Q
>ca02	3e cb				          .WORD Edit_Inverse_On      - 1 ; ESC R Reverse
>ca04	f1 ca				          .WORD Edit_Cursor_Block    - 1 ; ESC S Steady
>ca06	13 ca				          .WORD Edit_Window_UL       - 1 ; ESC T Top
>ca08	fd ca				          .WORD Edit_Cursor_Line     - 1 ; ESC U Underline
>ca0a	bb ca				          .WORD Edit_Scroll_Line_Up  - 1 ; ESC V
>ca0c	c9 ca				          .WORD Edit_Scroll_Line_Dn  - 1 ; ESC W
>ca0e	2b cd				          .WORD Edit_Toggle_Screen   - 1 ; ESC X eXchange
>ca10	82 c9				          .WORD Set_Default_Tabstops - 1 ; ESC Y Yank
>ca12	7f c9				          .WORD Clear_All_Tabstops   - 1 ; ESC Z Zero
.ca14					  Edit_Window_UL
.ca14	18		clc		          CLC
>ca15	24				          .BYTE $24
.ca16					  Edit_Set_Window_LR
.ca16	38		sec		          SEC
.ca17	a6 ec		ldx $ec		          LDX Cursor_Col
.ca19	a5 eb		lda $eb		          LDA Cursor_Row
.ca1b					  Edit_Window_Corner
.ca1b	90 11		bcc $ca2e	          BCC SeFu_10
.ca1d					  Set_Lower_Right_Corner
.ca1d	85 e4		sta $e4		          STA Margin_Bottom
.ca1f	86 e7		stx $e7		          STX Margin_Right
.ca21	4c 32 ca	jmp $ca32	          JMP SeFu_20         ; clear concatenation flags
.ca24					  Set_Fullscreen
.ca24	a5 ed		lda $ed		          LDA LINES
.ca26	a6 ee		ldx $ee		          LDX COLUMNS
.ca28	20 1d ca	jsr $ca1d	          JSR Set_Lower_Right_Corner
.ca2b	a9 00		lda #$00	          LDA #0              ; home position top  margin
.ca2d	aa		tax		          TAX                 ; home position left margin
.ca2e	85 e5		sta $e5		SeFu_10   STA Margin_Top
.ca30	86 e6		stx $e6		          STX Margin_Left
.ca32	a9 00		lda #$00	SeFu_20   LDA #0              ; clear concatenation flags
.ca34	a2 04		ldx #$04	          LDX #4              ; 4 bytes for 25 rows
.ca36	9d 5d 03	sta $035d,x	SeFu_30   STA BITABL-1,X
.ca39	ca		dex		          DEX
.ca3a	d0 fa		bne $ca36	          BNE SeFu_30
.ca3c	60		rts		          RTS
.ca3d					  Edit_Insert_Line
.ca3d	20 7c c3	jsr $c37c	          JSR Edit_Scroll_Down
.ca40	20 56 c1	jsr $c156	          JSR Cursor_To_Left_Margin
.ca43	e8		inx		          INX
.ca44	20 76 cb	jsr $cb76	          JSR Is_Coupled_Row_X
.ca47	08		php		          PHP
.ca48	20 81 cb	jsr $cb81	          JSR Toggle_Cont_Flag
.ca4b	28		plp		          PLP
.ca4c	b0 03		bcs $ca51	          BCS EdIL_Ret
.ca4e	38		sec		          SEC
.ca4f	66 e8		ror $e8		          ROR CurLst_Row
.ca51	60		rts		EdIL_Ret  RTS
.ca52					  Edit_Delete_Line
.ca52	20 b5 cb	jsr $cbb5	          JSR Start_Of_Line
.ca55	a5 e5		lda $e5		          LDA Margin_Top
.ca57	48		pha		          PHA
.ca58	a5 eb		lda $eb		          LDA Cursor_Row
.ca5a	85 e5		sta $e5		          STA Margin_Top
.ca5c	a5 f8		lda $f8		          LDA Scroll_Locked
.ca5e	48		pha		          PHA
.ca5f	a9 80		lda #$80	          LDA #$80
.ca61	85 f8		sta $f8		          STA Scroll_Locked
.ca63	20 b8 c3	jsr $c3b8	          JSR ScUp_20
.ca66	68		pla		          PLA
.ca67	85 f8		sta $f8		          STA Scroll_Locked
.ca69	a5 e5		lda $e5		          LDA Margin_Top
.ca6b	85 eb		sta $eb		          STA Cursor_Row
.ca6d	68		pla		          PLA
.ca6e	85 e5		sta $e5		          STA Margin_Top
.ca70	38		sec		          SEC
.ca71	66 e8		ror $e8		          ROR CurLst_Row
.ca73	4c 56 c1	jmp $c156	          JMP Cursor_To_Left_Margin
.ca76					  Edit_Erase_EOL
.ca76	20 1e cc	jsr $cc1e	          JSR Edit_Save_Row_Col
.ca79	20 aa c4	jsr $c4aa	EdEE_10   JSR Clear_Row_To_EOR
.ca7c	e6 eb		inc $eb		          INC Cursor_Row
.ca7e	20 5c c1	jsr $c15c	          JSR Set_Screen_Pointer
.ca81	a4 e6		ldy $e6		          LDY Margin_Left
.ca83	20 74 cb	jsr $cb74	          JSR Is_Coupled_Row
.ca86	b0 f1		bcs $ca79	          BCS EdEE_10
.ca88	4c 32 c9	jmp $c932	EdEE_20   JMP EdDe_20
.ca8b					  Edit_Erase_BOL
.ca8b	20 1e cc	jsr $cc1e	          JSR Edit_Save_Row_Col
.ca8e	20 27 cc	jsr $cc27	EdEB_10   JSR Edit_Put_Blank
.ca91	c4 e6		cpy $e6		          CPY Margin_Left
.ca93	d0 05		bne $ca9a	          BNE EdEB_20
.ca95	20 74 cb	jsr $cb74	          JSR Is_Coupled_Row
.ca98	90 ee		bcc $ca88	          BCC EdEE_20
.ca9a	20 00 cc	jsr $cc00	EdEB_20   JSR Edit_Cursor_Left
.ca9d	90 ef		bcc $ca8e	          BCC EdEB_10
.ca9f					  Edit_Erase_EOS
.ca9f	20 1e cc	jsr $cc1e	          JSR Edit_Save_Row_Col
.caa2	20 aa c4	jsr $c4aa	EdEr_10   JSR Clear_Row_To_EOR
.caa5	e6 eb		inc $eb		          INC Cursor_Row
.caa7	20 5c c1	jsr $c15c	          JSR Set_Screen_Pointer
.caaa	a4 e6		ldy $e6		          LDY Margin_Left
.caac	20 74 cb	jsr $cb74	          JSR Is_Coupled_Row
.caaf	b0 f1		bcs $caa2	          BCS EdEr_10
.cab1	a5 eb		lda $eb		          LDA Cursor_Row
.cab3	c5 e4		cmp $e4		          CMP Margin_Bottom
.cab5	90 eb		bcc $caa2	          BCC EdEr_10
.cab7	f0 e9		beq $caa2	          BEQ EdEr_10
.cab9	4c 32 c9	jmp $c932	          JMP EdDe_20
.cabc					  Edit_Scroll_Line_Up
.cabc	20 1e cc	jsr $cc1e	          JSR Edit_Save_Row_Col
.cabf	8a		txa		          TXA
.cac0	48		pha		          PHA
.cac1	20 a6 c3	jsr $c3a6	          JSR Edit_Scroll_Up
.cac4	68		pla		          PLA
.cac5	85 df		sta $df		          STA E_Row
.cac7	4c 32 c9	jmp $c932	          JMP EdDe_20
.caca					  Edit_Scroll_Line_Dn
.caca	20 1e cc	jsr $cc1e	          JSR Edit_Save_Row_Col
.cacd	20 74 cb	jsr $cb74	          JSR Is_Coupled_Row
.cad0	b0 03		bcs $cad5	          BCS ESLD_10
.cad2	38		sec		          SEC
.cad3	66 e8		ror $e8		          ROR CurLst_Row
.cad5	a5 e5		lda $e5		ESLD_10   LDA Margin_Top
.cad7	85 eb		sta $eb		          STA Cursor_Row
.cad9	20 7c c3	jsr $c37c	          JSR Edit_Scroll_Down
.cadc	20 85 cb	jsr $cb85	          JSR Clear_Cont_Flag
.cadf	4c 32 c9	jmp $c932	          JMP EdDe_20
.cae2					  Edit_Scroll_Unlock
.cae2	a9 00		lda #$00	          LDA #0
>cae4	2c				          .byte $2c ;BIT
.cae5					  Edit_Scroll_Lock
.cae5	a9 80		lda #$80	          LDA #$80
.cae7	85 f8		sta $f8		          STA Scroll_Locked
.cae9	60		rts		          RTS
.caea					  Edit_Auto_Insert_Off
.caea	a9 00		lda #$00	          LDA #0
>caec	2c				          .byte $2c ;BIT
.caed					  Edit_Auto_Insert_On
.caed	a9 ff		lda #$ff	          LDA #$ff
.caef	85 f6		sta $f6		          STA INSFLG
.caf1	60		rts		          RTS
.caf2					  Edit_Cursor_Block
.caf2	24 d7		bit $d7		          BIT MODE_80
.caf4	10 40		bpl $cb36	          BPL EdBC_Ret
.caf6	ad 2b 0a	lda $0a2b	          LDA CURMOD
.caf9	29 e0		and #$e0	          AND #%11100000 ; $e0
.cafb	4c 14 cb	jmp $cb14	          JMP EdSC_10
.cafe					  Edit_Cursor_Line
.cafe	24 d7		bit $d7		          BIT MODE_80
.cb00	10 34		bpl $cb36	          BPL EdBC_Ret
.cb02	ad 2b 0a	lda $0a2b	          LDA CURMOD
.cb05	29 e0		and #$e0	          AND #%11100000 ; $e0
.cb07	09 07		ora #$07	          ORA #%00000111 ; $07
.cb09	d0 09		bne $cb14	          BNE EdSC_10
.cb0b					  Edit_Steady_Cursor
.cb0b	24 d7		bit $d7		          BIT MODE_80
.cb0d	10 0b		bpl $cb1a	          BPL EdSC_20
.cb0f	ad 2b 0a	lda $0a2b	          LDA CURMOD
.cb12	29 1f		and #$1f	          AND #%00011111 ; $1f
.cb14	8d 2b 0a	sta $0a2b	EdSC_10   STA CURMOD
.cb17	4c 91 cd	jmp $cd91	          JMP ECON_10
.cb1a	ad 26 0a	lda $0a26	EdSC_20   LDA BLNON
.cb1d	09 40		ora #$40	          ORA #%01000000 ; $40
.cb1f	d0 12		bne $cb33	          BNE EdBC_20
.cb21					  Edit_Blinking_Cursor
.cb21	24 d7		bit $d7		          BIT MODE_80
.cb23	10 09		bpl $cb2e	          BPL EdBC_10
.cb25	ad 2b 0a	lda $0a2b	          LDA CURMOD
.cb28	29 1f		and #$1f	          AND #%00011111 ; $1f
.cb2a	09 60		ora #$60	          ORA #%01100000 ; $60
.cb2c	d0 e6		bne $cb14	          BNE EdSC_10
.cb2e	ad 26 0a	lda $0a26	EdBC_10   LDA BLNON
.cb31	29 bf		and #$bf	          AND #%10111111 ; $bf
.cb33	8d 26 0a	sta $0a26	EdBC_20   STA BLNON
.cb36	60		rts		EdBC_Ret  RTS
.cb37					  Edit_Enable_Bell
.cb37	a9 00		lda #$00	          LDA #0
>cb39	2c				          .byte $2c ;BIT
.cb3a					  Edit_Disable_Bell
.cb3a	a9 80		lda #$80	          LDA #$80
.cb3c	85 f9		sta $f9		          STA BEEPER
.cb3e	60		rts		          RTS
.cb3f					  Edit_Inverse_On
.cb3f	a2 18		ldx #$18	          LDX #$18
.cb41	20 da cd	jsr $cdda	          JSR VDC_Read_Register_X
.cb44	09 40		ora #$40	          ORA #%01000000
.cb46	d0 07		bne $cb4f	          BNE EdIO_10
.cb48					  Edit_Inverse_Off
.cb48	a2 18		ldx #$18	          LDX #$18
.cb4a	20 da cd	jsr $cdda	          JSR VDC_Read_Register_X
.cb4d	29 bf		and #$bf	          AND #%10111111 ; $bf
.cb4f	4c cc cd	jmp $cdcc	EdIO_10   JMP VDC_Write_Register_X
.cb52					  Edit_Cursor_EOL
.cb52	20 c3 cb	jsr $cbc3	          JSR Edit_Cursor_Last
.cb55	4c 3e c3	jmp $c33e	          JMP Edit_Cursor_Next
.cb58					  Edit_Get_Char
.cb58	a4 ec		ldy $ec		          LDY Cursor_Col      ; cursor column
.cb5a	24 d7		bit $d7		          BIT MODE_80         ; screen mode
.cb5c	30 07		bmi $cb65	          BMI EGSC_10         ; -> 80 column screen
.cb5e	b1 e2		lda ($e2),y	          LDA (USER),Y
.cb60	85 f2		sta $f2		          STA TCOLOR          ; TCOLOR = attribute
.cb62	b1 e0		lda ($e0),y	          LDA (PNT),Y         ; A      = character
.cb64	60		rts		          RTS
.cb65	20 f9 cd	jsr $cdf9	EGSC_10   JSR VDC_Set_Attr_Address
.cb68	20 d8 cd	jsr $cdd8	          JSR VDC_Read_RAM
.cb6b	85 f2		sta $f2		          STA TCOLOR          ; TCOLOR = attribute
.cb6d	20 e6 cd	jsr $cde6	          JSR VDC_Set_Char_Address
.cb70	20 d8 cd	jsr $cdd8	          JSR VDC_Read_RAM    ; A      = character
.cb73	60		rts		          RTS
.cb74					  Is_Coupled_Row
.cb74	a6 eb		ldx $eb		          LDX Cursor_Row            ; X = row
.cb76					  Is_Coupled_Row_X
.cb76	20 9f cb	jsr $cb9f	          JSR Cont_Flag_Bit_Pos
.cb79	3d 5e 03	and $035e,x	          AND BITABL,X
.cb7c	c9 01		cmp #$01	          CMP #1
.cb7e	4c 90 cb	jmp $cb90	          JMP CCF_20
.cb81					  Toggle_Cont_Flag
.cb81	a6 eb		ldx $eb		          LDX Cursor_Row
.cb83					  Toggle_Cont_Flag_X
.cb83	b0 0e		bcs $cb93	          BCS Set_Cont_Flag
.cb85					  Clear_Cont_Flag
.cb85	20 9f cb	jsr $cb9f	          JSR Cont_Flag_Bit_Pos
.cb88	49 ff		eor #$ff	          EOR #$ff
.cb8a	3d 5e 03	and $035e,x	          AND BITABL,X
.cb8d	9d 5e 03	sta $035e,x	CCF_10    STA BITABL,X
.cb90	a6 da		ldx $da		CCF_20    LDX E_Beg
.cb92	60		rts		          RTS
.cb93					  Set_Cont_Flag
.cb93	24 f8		bit $f8		          BIT Scroll_Locked
.cb95	70 df		bvs $cb76	          BVS Is_Coupled_Row_X ; -> no coupled rows in scroll lock mode
.cb97	20 9f cb	jsr $cb9f	          JSR Cont_Flag_Bit_Pos
.cb9a	1d 5e 03	ora $035e,x	          ORA BITABL,X
.cb9d	d0 ee		bne $cb8d	          BNE CCF_10
.cb9f					  Cont_Flag_Bit_Pos
.cb9f	86 da		stx $da		          STX E_Beg          ; save row
.cba1	8a		txa		          TXA
.cba2	29 07		and #$07	          AND #7              ; row mod 8
.cba4	aa		tax		          TAX                 ; X = bit number
.cba5	bd 6c ce	lda $ce6c,x	          LDA Edit_Bit_Mask,X ; A = bit mask
.cba8	48		pha		          PHA                 ; push bit mask
.cba9	a5 da		lda $da		          LDA E_Beg          ; A = roq
.cbab	4a		lsr a		          LSR A               ; / 2
.cbac	4a		lsr a		          LSR A               ; / 4
.cbad	4a		lsr a		          LSR A               ; / 8
.cbae	aa		tax		          TAX                 ; X = byte index
.cbaf	68		pla		          PLA                 ; A = bit  index
.cbb0	60		rts		          RTS
.cbb1					  Edit_Cursor_BOL
.cbb1	a4 e6		ldy $e6		          LDY Margin_Left
.cbb3	84 ec		sty $ec		          STY Cursor_Col
.cbb5					  Start_Of_Line
.cbb5	20 74 cb	jsr $cb74	          JSR Is_Coupled_Row
.cbb8	90 06		bcc $cbc0	          BCC SOL_10
.cbba	c6 eb		dec $eb		          DEC Cursor_Row
.cbbc	10 f7		bpl $cbb5	          BPL Start_Of_Line
.cbbe	e6 eb		inc $eb		          INC Cursor_Row
.cbc0	4c 5c c1	jmp $c15c	SOL_10    JMP Set_Screen_Pointer
.cbc3					  Edit_Cursor_Last
.cbc3	e6 eb		inc $eb		          INC Cursor_Row
.cbc5	20 74 cb	jsr $cb74	          JSR Is_Coupled_Row
.cbc8	b0 f9		bcs $cbc3	          BCS Edit_Cursor_Last
.cbca	c6 eb		dec $eb		          DEC Cursor_Row
.cbcc	20 5c c1	jsr $c15c	          JSR Set_Screen_Pointer
.cbcf	a4 e7		ldy $e7		          LDY Margin_Right
.cbd1	84 ec		sty $ec		          STY Cursor_Col      ; PNTR = right margin
.cbd3	20 58 cb	jsr $cb58	EELR_10   JSR Edit_Get_Char
.cbd6	a6 eb		ldx $eb		          LDX Cursor_Row
.cbd8	c9 20		cmp #$20	          CMP #' '
.cbda	d0 0e		bne $cbea	          BNE EELR_30
.cbdc	c4 e6		cpy $e6		          CPY Margin_Left
.cbde	d0 05		bne $cbe5	          BNE EELR_20
.cbe0	20 74 cb	jsr $cb74	          JSR Is_Coupled_Row
.cbe3	90 05		bcc $cbea	          BCC EELR_30
.cbe5	20 00 cc	jsr $cc00	EELR_20   JSR Edit_Cursor_Left
.cbe8	90 e9		bcc $cbd3	          BCC EELR_10         ; -> cursor did move
.cbea	84 ea		sty $ea		EELR_30   STY Cursor_End      ; position of last non blank
.cbec	60		rts		          RTS
.cbed					  Edit_Cursor_Right
.cbed	48		pha		          PHA
.cbee	a4 ec		ldy $ec		          LDY Cursor_Col
.cbf0	c4 e7		cpy $e7		          CPY Margin_Right
.cbf2	90 07		bcc $cbfb	          BCC EdCR_10
.cbf4	20 63 c3	jsr $c363	          JSR Edit_Cursor_Down
.cbf7	a4 e6		ldy $e6		          LDY Margin_Left
.cbf9	88		dey		          DEY
.cbfa	38		sec		          SEC
.cbfb	c8		iny		EdCR_10   INY
.cbfc	84 ec		sty $ec		          STY Cursor_Col
.cbfe	68		pla		          PLA
.cbff	60		rts		          RTS
.cc00					  Edit_Cursor_Left
.cc00	a4 ec		ldy $ec		          LDY Cursor_Col            ; Y = cursor column
.cc02	88		dey		          DEY                 ; --Y
.cc03	30 04		bmi $cc09	          BMI EdCL_10         ; -> off screen
.cc05	c4 e6		cpy $e6		          CPY Margin_Left            ; compare with left margin
.cc07	b0 0f		bcs $cc18	          BCS EdCL_20         ; -> OK
.cc09	a4 e5		ldy $e5		EdCL_10   LDY Margin_Top           ; Y = upper margin
.cc0b	c4 eb		cpy $eb		          CPY Cursor_Row            ; compare with row
.cc0d	b0 0e		bcs $cc1d	          BCS EdCL_Ret        ; -> cursor is at home position
.cc0f	c6 eb		dec $eb		          DEC Cursor_Row            ; up one row
.cc11	48		pha		          PHA                 ; save A
.cc12	20 5c c1	jsr $c15c	          JSR Set_Screen_Pointer
.cc15	68		pla		          PLA                 ; restore A
.cc16	a4 e7		ldy $e7		          LDY Margin_Right
.cc18	84 ec		sty $ec		EdCL_20   STY Cursor_Col            ; cursor column = wight margin
.cc1a	c4 e7		cpy $e7		          CPY Margin_Right
.cc1c	18		clc		          CLC                 ; success
.cc1d	60		rts		EdCL_Ret  RTS
.cc1e					  Edit_Save_Row_Col
.cc1e	a4 ec		ldy $ec		          LDY Cursor_Col
.cc20	84 de		sty $de		          STY E_Col
.cc22	a6 eb		ldx $eb		          LDX Cursor_Row
.cc24	86 df		stx $df		          STX E_Row
.cc26	60		rts		          RTS
.cc27					  Edit_Put_Blank
.cc27	a5 f1		lda $f1		          LDA E_Attribute
.cc29	29 8f		and #$8f	          AND #%10001111 ; $8f
.cc2b	aa		tax		          TAX
.cc2c	a9 20		lda #$20	          LDA #' '
>cc2e	2c				          .byte $2c ;
.cc2f					  Edit_Put_Char_Att
.cc2f	a6 f1		ldx $f1		          LDX E_Attribute
>cc31	2c				          .byte $2c ;                 ; skip next statement
.cc32					  Edit_Put_Char
.cc32	a6 f2		ldx $f2		          LDX TCOLOR
.cc34					  Edit_Display
.cc34	a8		tay		          TAY
.cc35	a9 02		lda #$02	          LDA #2
.cc37	8d 28 0a	sta $0a28	          STA BLNCT
.cc3a	20 7c c1	jsr $c17c	          JSR Set_Attribute_Pointer
.cc3d	98		tya		          TYA
.cc3e	a4 ec		ldy $ec		          LDY Cursor_Col
.cc40					  Edit_Display_AX
.cc40	24 d7		bit $d7		          BIT MODE_80
.cc42	30 06		bmi $cc4a	          BMI CTSR_80
.cc44	91 e0		sta ($e0),y	          STA (PNT),Y
.cc46	8a		txa		          TXA
.cc47	91 e2		sta ($e2),y	          STA (USER),Y
.cc49	60		rts		          RTS
.cc4a	48		pha		CTSR_80   PHA
.cc4b	8a		txa		          TXA
.cc4c	48		pha		          PHA
.cc4d	20 f9 cd	jsr $cdf9	          JSR VDC_Set_Attr_Address
.cc50	68		pla		          PLA
.cc51	20 ca cd	jsr $cdca	          JSR VDC_Write_Data
.cc54	20 e6 cd	jsr $cde6	          JSR VDC_Set_Char_Address
.cc57	68		pla		          PLA
.cc58	4c ca cd	jmp $cdca	          JMP VDC_Write_Data
.cc5b					  Edit_Get_Window
.cc5b	38		sec		          SEC
.cc5c	a5 e4		lda $e4		          LDA Margin_Bottom
.cc5e	e5 e5		sbc $e5		          SBC Margin_Top
.cc60	a8		tay		          TAY
.cc61	38		sec		          SEC
.cc62	a5 e7		lda $e7		          LDA Margin_Right
.cc64	e5 e6		sbc $e6		          SBC Margin_Left
.cc66	aa		tax		          TAX
.cc67	a5 ee		lda $ee		          LDA COLUMNS
.cc69	60		rts		          RTS
.cc6a					  Edit_Plot
.cc6a	b0 29		bcs $cc95	          BCS EdPl_50         ; -> get position
.cc6c	8a		txa		          TXA
.cc6d	65 e5		adc $e5		          ADC Margin_Top
.cc6f	b0 14		bcs $cc85	          BCS EdPl_30
.cc71	c5 e4		cmp $e4		          CMP Margin_Bottom
.cc73	f0 02		beq $cc77	          BEQ EdPl_10
.cc75	b0 0e		bcs $cc85	          BCS EdPl_30
.cc77	48		pha		EdPl_10   PHA
.cc78	18		clc		          CLC
.cc79	98		tya		          TYA
.cc7a	65 e6		adc $e6		          ADC Margin_Left
.cc7c	b0 06		bcs $cc84	          BCS EdPl_20
.cc7e	c5 e7		cmp $e7		          CMP Margin_Right
.cc80	f0 04		beq $cc86	          BEQ EdPl_40
.cc82	90 02		bcc $cc86	          BCC EdPl_40
.cc84	68		pla		EdPl_20   PLA
.cc85	60		rts		EdPl_30   RTS
.cc86	85 ec		sta $ec		EdPl_40   STA Cursor_Col
.cc88	85 e9		sta $e9		          STA CurLst_Col
.cc8a	68		pla		          PLA
.cc8b	85 eb		sta $eb		          STA Cursor_Row
.cc8d	85 e8		sta $e8		          STA CurLst_Row
.cc8f	20 5c c1	jsr $c15c	          JSR Set_Screen_Pointer
.cc92	20 57 cd	jsr $cd57	          JSR Edit_Cursor
.cc95	a5 eb		lda $eb		EdPl_50   LDA Cursor_Row
.cc97	e5 e5		sbc $e5		          SBC Margin_Top
.cc99	aa		tax		          TAX
.cc9a	38		sec		          SEC
.cc9b	a5 ec		lda $ec		          LDA Cursor_Col
.cc9d	e5 e6		sbc $e6		          SBC Margin_Left
.cc9f	a8		tay		          TAY
.cca0	18		clc		          CLC
.cca1	60		rts		          RTS
.cca2					  Edit_Set_FKey
.cca2	ca		dex		          DEX                 ; key index (0-7)
.cca3	86 dc		stx $dc		          STX E_End
.cca5	84 da		sty $da		          STY E_Beg           ; text lnegth
.cca7	8d aa 02	sta $02aa	          STA FETCH+8         ; #INDEXA ($24)
.ccaa	a8		tay		          TAY
.ccab	b6 02		ldx $02,y	          LDX BANK,Y          ; LDX #1 (INDEX)B  ($26) = ($02,$24)
.ccad	20 6b ff	jsr $ff6b	          JSR K_GETCFG        ; LDA #$7f (Bank_Config_Table,X)
.ccb0	85 de		sta $de		          STA E_Col           ; save bank
.ccb2	a2 0a		ldx #$0a	          LDX #10             ; find position after all 10 text entries
.ccb4	20 20 cd	jsr $cd20	          JSR Edit_FText_Index
.ccb7	85 db		sta $db		          STA E_Beg+1         ; total length so far
.ccb9	a6 dc		ldx $dc		          LDX E_End           ; key index
.ccbb	e8		inx		          INX                 ; + 1
.ccbc	20 20 cd	jsr $cd20	          JSR Edit_FText_Index
.ccbf	85 dd		sta $dd		          STA E_End+1         ; length after current key
.ccc1	a6 dc		ldx $dc		          LDX E_End           ; key index
.ccc3	a5 da		lda $da		          LDA E_Beg           ; new text length
.ccc5	38		sec		          SEC
.ccc6	fd 00 10	sbc $1000,x	          SBC PKYBUF,X        ; old text length
.ccc9	f0 2b		beq $ccf6	          BEQ ESFK_40         ; -> just replace
.cccb	90 16		bcc $cce3	          BCC ESFK_20         ; new < old -> shift down
.cccd	18		clc		          CLC                 ; new > old
.ccce	65 db		adc $db		          ADC E_Beg+1         ; A = (new-old) + total length
.ccd0	b0 4d		bcs $cd1f	          BCS ESFK_Ret        ; -> overlow
.ccd2	aa		tax		          TAX                 ; X = new total length
.ccd3	a4 db		ldy $db		          LDY E_Beg+1         ; Y = old total length
.ccd5	c4 dd		cpy $dd		ESFK_10   CPY E_End+1         ; Y = length after current key ?
.ccd7	f0 1d		beq $ccf6	          BEQ ESFK_40         ; -> move finished
.ccd9	88		dey		          DEY
.ccda	ca		dex		          DEX
.ccdb	b9 0a 10	lda $100a,y	          LDA PKYDEF,Y        ; shift up
.ccde	9d 0a 10	sta $100a,x	          STA PKYDEF,X
.cce1	b0 f2		bcs $ccd5	          BCS ESFK_10         ; always
.cce3	65 dd		adc $dd		ESFK_20   ADC E_End+1
.cce5	aa		tax		          TAX
.cce6	a4 dd		ldy $dd		          LDY E_End+1
.cce8	c4 db		cpy $db		ESFK_30   CPY E_Beg+1
.ccea	b0 0a		bcs $ccf6	          BCS ESFK_40
.ccec	b9 0a 10	lda $100a,y	          LDA PKYDEF,Y        ; shift down
.ccef	9d 0a 10	sta $100a,x	          STA PKYDEF,X
.ccf2	c8		iny		          INY
.ccf3	e8		inx		          INX
.ccf4	90 f2		bcc $cce8	          BCC ESFK_30         ; always
.ccf6	a6 dc		ldx $dc		ESFK_40   LDX E_End           ; key index
.ccf8	20 20 cd	jsr $cd20	          JSR Edit_FText_Index
.ccfb	aa		tax		          TAX                 ; text index
.ccfc	a4 dc		ldy $dc		          LDY E_End           ; Y = key index
.ccfe	a5 da		lda $da		          LDA E_Beg           ; A = new text length
.cd00	99 00 10	sta $1000,y	          STA PKYBUF,Y        ; store text length in table
.cd03	a0 00		ldy #$00	          LDY #0              ; store new text from (INDEXA)
.cd05	c6 da		dec $da		ESFK_50   DEC E_Beg           ; decrement text length
.cd07	30 15		bmi $cd1e	          BMI ESFK_60         ; -> finish
.cd09	86 df		stx $df		          STX E_Row           ; save X
.cd0b	a6 de		ldx $de		          LDX E_Col           ; X = bank
.cd0d	ad aa 02	lda $02aa	          LDA FETCH+8         ; #INDEXA
.cd10	78		sei		          SEI
.cd11	20 a2 02	jsr $02a2	          JSR FETCH           ; replace with Get_INDEXA_1 !!!
.cd14	58		cli		          CLI
.cd15	a6 df		ldx $df		          LDX E_Row           ; restore X
.cd17	9d 0a 10	sta $100a,x	          STA PKYDEF,X
.cd1a	e8		inx		          INX                 ; increment store index
.cd1b	c8		iny		          INY                 ; increment load  index
.cd1c	d0 e7		bne $cd05	          BNE ESFK_50         ; always
.cd1e	18		clc		ESFK_60   CLC                 ; C=0 OK
.cd1f	60		rts		ESFK_Ret  RTS
.cd20					  Edit_FText_Index
.cd20	a9 00		lda #$00	          LDA #0
.cd22	18		clc		          CLC
.cd23	ca		dex		EGFI_10   DEX
.cd24	30 05		bmi $cd2b	          BMI EGFI_Ret
.cd26	7d 00 10	adc $1000,x	          ADC PKYBUF,X
.cd29	90 f8		bcc $cd23	          BCC EGFI_10
.cd2b	60		rts		EGFI_Ret  RTS
.cd2c					  Edit_Toggle_Screen
.cd2c	85 f0		sta $f0		          STA LSTCHR
.cd2e					  Edit_Screen_Swapper
.cd2e	a2 1a		ldx #$1a	          LDX #$1a
.cd30	bc 40 0a	ldy $0a40,x	EdSS_10   LDY ZP_SW_COL,X
.cd33	b5 e0		lda $e0,x	          LDA PNT,X
.cd35	9d 40 0a	sta $0a40,x	          STA ZP_SW_COL,X
.cd38	98		tya		          TYA
.cd39	95 e0		sta $e0,x	          STA PNT,X
.cd3b	ca		dex		          DEX
.cd3c	10 f2		bpl $cd30	          BPL EdSS_10
.cd3e	a2 0d		ldx #$0d	          LDX #13             ; 10 for TABMAP and 4 for BITABL
.cd40	bc 60 0a	ldy $0a60,x	EdSS_20   LDY SWPMAP,X
.cd43	bd 54 03	lda $0354,x	          LDA TABMAP,X
.cd46	9d 60 0a	sta $0a60,x	          STA SWPMAP,X
.cd49	98		tya		          TYA
.cd4a	9d 54 03	sta $0354,x	          STA TABMAP,X
.cd4d	ca		dex		          DEX
.cd4e	10 f0		bpl $cd40	          BPL EdSS_20
.cd50	a5 d7		lda $d7		          LDA MODE_80
.cd52	49 80		eor #$80	          EOR #%10000000 ; $80
.cd54	85 d7		sta $d7		          STA MODE_80
.cd56	60		rts		EdSS_Ret  RTS
.cd57					  Edit_Cursor
.cd57	24 d7		bit $d7		          BIT MODE_80
.cd59	10 fb		bpl $cd56	          BPL EdSS_Ret
.cd5b	a2 0e		ldx #$0e	          LDX #14
.cd5d	18		clc		          CLC
.cd5e	a5 e0		lda $e0		          LDA PNT
.cd60	65 ec		adc $ec		          ADC Cursor_Col
.cd62	48		pha		          PHA
.cd63	a5 e1		lda $e1		          LDA PNT+1
.cd65	69 00		adc #$00	          ADC #0
.cd67	20 cc cd	jsr $cdcc	          JSR VDC_Write_Register_X
.cd6a	e8		inx		          INX
.cd6b	68		pla		          PLA
.cd6c	4c cc cd	jmp $cdcc	          JMP VDC_Write_Register_X
.cd6f					  Edit_Cursor_On
.cd6f	24 d7		bit $d7		          BIT MODE_80         ; 80 or 40 column screen ?
.cd71	10 26		bpl $cd99	          BPL ECON_20         ; -> 40 col
.cd73	20 7c c1	jsr $c17c	          JSR Set_Attribute_Pointer
.cd76	a4 ec		ldy $ec		          LDY Cursor_Col
.cd78	20 f9 cd	jsr $cdf9	          JSR VDC_Set_Attr_Address
.cd7b	20 d8 cd	jsr $cdd8	          JSR VDC_Read_RAM
.cd7e	8d 33 0a	sta $0a33	          STA VDC_ATT          ; save char under cursor
.cd81	29 f0		and #$f0	          AND #%11110000     ; invert char
.cd83	85 db		sta $db		          STA E_Beg+1
.cd85	20 f9 cd	jsr $cdf9	          JSR VDC_Set_Attr_Address
.cd88	a5 f1		lda $f1		          LDA E_Attribute
.cd8a	29 0f		and #$0f	          AND #%00001111     ; invert color
.cd8c	05 db		ora $db		          ORA E_Beg+1
.cd8e	20 ca cd	jsr $cdca	          JSR VDC_Write_Data
.cd91	a2 0a		ldx #$0a	ECON_10   LDX #10
.cd93	ad 2b 0a	lda $0a2b	          LDA CURMOD
.cd96	4c cc cd	jmp $cdcc	          JMP VDC_Write_Register_X
.cd99	a9 00		lda #$00	ECON_20   LDA #0
.cd9b	8d 27 0a	sta $0a27	          STA BLNSW           ; 0 = blinking on
.cd9e	60		rts		          RTS
.cd9f					  Edit_Cursor_Off
.cd9f	24 d7		bit $d7		          BIT MODE_80         ; 80 or 40 column screen ?
.cda1	10 10		bpl $cdb3	          BPL ECOF_10         ; -> 40 col
.cda3	20 f9 cd	jsr $cdf9	          JSR VDC_Set_Attr_Address
.cda6	ad 33 0a	lda $0a33	          LDA VDC_ATT         ; attribute under cursor
.cda9	20 ca cd	jsr $cdca	          JSR VDC_Write_Data  ; prepare to write
.cdac	a2 0a		ldx #$0a	          LDX #10
.cdae	a9 20		lda #$20	          LDA #' '
.cdb0	4c cc cd	jmp $cdcc	          JMP VDC_Write_Register_X
.cdb3	8d 27 0a	sta $0a27	ECOF_10   STA BLNSW           ; BLNSW != 0 : switch blinking off
.cdb6	ad 26 0a	lda $0a26	          LDA BLNON           ; cursor blink on ?
.cdb9	10 0e		bpl $cdc9	          BPL ECOF_Ret        ; -> no, nothing to do
.cdbb	29 40		and #$40	          AND #%01000000
.cdbd	8d 26 0a	sta $0a26	          STA BLNON
.cdc0	ad 29 0a	lda $0a29	          LDA GDBLN
.cdc3	ae 2a 0a	ldx $0a2a	          LDX GDCOL           ; cursor blink mode
.cdc6	20 34 cc	jsr $cc34	          JSR Edit_Display
.cdc9	60		rts		ECOF_Ret  RTS
.cdca					  VDC_Write_Data
.cdca	a2 1f		ldx #$1f	          LDX #$1f
.cdcc					  VDC_Write_Register_X
.cdcc	8e 00 d6	stx $d600	          STX VDC_Register
.cdcf	2c 00 d6	bit $d600	VWRX_10   BIT VDC_Register
.cdd2	10 fb		bpl $cdcf	          BPL VWRX_10
.cdd4	8d 01 d6	sta $d601	          STA VDC_Data
.cdd7	60		rts		          RTS
.cdd8					  VDC_Read_RAM
.cdd8	a2 1f		ldx #$1f	          LDX #$1f
.cdda					  VDC_Read_Register_X
.cdda	8e 00 d6	stx $d600	          STX VDC_Register
.cddd	2c 00 d6	bit $d600	VRRX_10   BIT VDC_Register
.cde0	10 fb		bpl $cddd	          BPL VRRX_10
.cde2	ad 01 d6	lda $d601	          LDA VDC_Data
.cde5	60		rts		          RTS
.cde6					  VDC_Set_Char_Address
.cde6	a2 12		ldx #$12	          LDX #$12
.cde8	18		clc		          CLC
.cde9	98		tya		          TYA
.cdea	65 e0		adc $e0		          ADC PNT
.cdec	48		pha		          PHA
.cded	a9 00		lda #$00	          LDA #0
.cdef	65 e1		adc $e1		          ADC PNT+1
.cdf1	20 cc cd	jsr $cdcc	          JSR VDC_Write_Register_X
.cdf4	68		pla		          PLA
.cdf5	e8		inx		          INX
.cdf6	4c cc cd	jmp $cdcc	          JMP VDC_Write_Register_X
.cdf9					  VDC_Set_Attr_Address
.cdf9	a2 12		ldx #$12	          LDX #18             ; VDC register 18
.cdfb	18		clc		          CLC
.cdfc	98		tya		          TYA
.cdfd	65 e2		adc $e2		          ADC USER            ; USER + Y
.cdff	48		pha		          PHA
.ce00	a9 00		lda #$00	          LDA #0
.ce02	65 e3		adc $e3		          ADC USER+1
.ce04	20 cc cd	jsr $cdcc	          JSR VDC_Write_Register_X
.ce07	68		pla		          PLA
.ce08	e8		inx		          INX
.ce09	4c cc cd	jmp $cdcc	          JMP VDC_Write_Register_X
.ce0c					  Edit_Load_Chargen
.ce0c	a9 00		lda #$00	          LDA #<VIC
.ce0e	a0 d0		ldy #$d0	          LDY #>VIC
.ce10	85 da		sta $da		          STA E_Beg
.ce12	84 db		sty $db		          STY E_Beg+1
.ce14	a2 12		ldx #$12	          LDX #$12
.ce16	a9 20		lda #$20	          LDA #$20            ; Write chargen to $2000
.ce18	20 cc cd	jsr $cdcc	          JSR VDC_Write_Register_X
.ce1b	e8		inx		          INX
.ce1c	a9 00		lda #$00	          LDA #0
.ce1e	20 cc cd	jsr $cdcc	          JSR VDC_Write_Register_X
.ce21	a0 00		ldy #$00	          LDY #0
.ce23	a2 0e		ldx #$0e	EdLC_10   LDX #$0e            ; bank
.ce25	a9 da		lda #$da	          LDA #E_Beg
.ce27	20 74 ff	jsr $ff74	          JSR K_INDFET
.ce2a	20 ca cd	jsr $cdca	          JSR VDC_Write_Data
.ce2d	c8		iny		          INY
.ce2e	c0 08		cpy #$08	          CPY #8              ; 8 bytes per character
.ce30	90 f1		bcc $ce23	          BCC EdLC_10
.ce32	a9 00		lda #$00	          LDA #0
.ce34	20 ca cd	jsr $cdca	EdLC_20   JSR VDC_Write_Data
.ce37	88		dey		          DEY
.ce38	d0 fa		bne $ce34	          BNE EdLC_20
.ce3a	18		clc		          CLC
.ce3b	a5 da		lda $da		          LDA E_Beg
.ce3d	69 08		adc #$08	          ADC #8              ; position to next character
.ce3f	85 da		sta $da		          STA E_Beg
.ce41	90 e0		bcc $ce23	          BCC EdLC_10
.ce43	e6 db		inc $db		          INC E_Beg+1
.ce45	a5 db		lda $db		          LDA E_Beg+1
.ce47	c9 e0		cmp #$e0	          CMP #$e0            ; end of chargen ROM at $dfff
.ce49	90 d8		bcc $ce23	          BCC EdLC_10
.ce4b	60		rts		          RTS
.ce4c					  VIC_Color_Codes
>ce4c	90				          .BYTE $90           ; black
>ce4d	05				          .BYTE $05           ; white
>ce4e	1c				          .BYTE $1c           ; red
>ce4f	9f				          .BYTE $9f           ; green
>ce50	9c				          .BYTE $9c           ; violet
>ce51	1e				          .BYTE $1e           ; dark green
>ce52	1f				          .BYTE $1f           ; blue
>ce53	9e				          .BYTE $9e           ; yellow
>ce54	81				          .BYTE $81           ; light brown
>ce55	95				          .BYTE $95           ; brown
>ce56	96				          .BYTE $96           ; rose
>ce57	97				          .BYTE $97           ; dark grey
>ce58	98				          .BYTE $98           ; grey
>ce59	99				          .BYTE $99           ; light green
>ce5a	9a				          .BYTE $9a           ; light blue
>ce5b	9b				          .BYTe $9b           ; light grey
.ce5c					  VDC_Color_Codes
>ce5c	00				          .BYTE $00           ; black
>ce5d	0f				          .BYTE $0f           ; white
>ce5e	08				          .BYTE $08           ; red
>ce5f	07				          .BYTE $07           ; green
>ce60	0b				          .BYTE $0b           ; violet
>ce61	04				          .BYTE $04           ; dark green
>ce62	02				          .BYTE $02           ; blue
>ce63	0d				          .BYTE $0d           ; yellow
>ce64	0a				          .BYTE $0a           ; light brown
>ce65	0c				          .BYTE $0c           ; brown
>ce66	09				          .BYTE $09           ; rose
>ce67	06				          .BYTE $06           ; dark grey
>ce68	01				          .BYTE $01           ; grey
>ce69	05				          .BYTE $05           ; light green
>ce6a	03				          .BYTE $03           ; light blue
>ce6b	0e				          .BYTe $0e           ; light grey
.ce6c					  Edit_Bit_Mask
>ce6c	80 40 20 10 08 04 02 01		          .BYTE $80,$40,$20,$10,$08,$04,$02,$01
.ce74					  ZP_40_COL
>ce74	00 04				          .WORD VIC_TEXT      ; $e0  PNT
>ce76	00 d8				          .WORD VIC_COLOR_RAM ; $e2  USER
>ce78	18				          .BYTE 24            ; $e4  Margin_Bottom
>ce79	00				          .BYTE  0            ; $e5  Margin_Top
>ce7a	00				          .BYTE  0            ; $e6  Margin_Left
>ce7b	27				          .BYTE 39            ; $e7  Margin_Right
>ce7c	00				          .BYTE  0            ; $e8  CurLst_Row
>ce7d	00				          .BYTE  0            ; $e9  CurLst_Col
>ce7e	00				          .BYTE  0            ; $ea  Cursor_End
>ce7f	00				          .BYTE  0            ; $eb  Cursor_Row
>ce80	00				          .BYTE  0            ; $ec  Cursor_Col
>ce81	18				          .BYTE 24            ; $ed  LINES
>ce82	27				          .BYTE 39            ; $ee  COLUMNS
>ce83	00				          .BYTE  0            ; $ef  DATAX
>ce84	00				          .BYTE  0            ; $f0  LSTCHR
>ce85	0d				          .BYTE 13            ; $f1  E_Attribute
>ce86	0d				          .BYTE 13            ; $f2  TCOLOR
>ce87	00				          .BYTE  0            ; $f3  E_Reverse
>ce88	00				          .BYTE  0            ; $f4  QTSW
>ce89	00				          .BYTE  0            ; $f5  INSRT
>ce8a	00				          .BYTE  0            ; $f6  INSFLG
>ce8b	00				          .BYTE  0            ; $f7  LOCKS
>ce8c	00				          .BYTE  0            ; $f8  Scroll_Locked
>ce8d	00				          .BYTE  0            ; $f9  BEEPER
.ce8e					  ZP_80_COL
>ce8e	00 00				          .WORD $0000         ; $e0  PNT
>ce90	00 08				          .WORD $0800         ; $e2  USER
>ce92	18				          .BYTE 24            ; $e4  Margin_Bottom
>ce93	00				          .BYTE  0            ; $e5  Margin_Top
>ce94	00				          .BYTE  0            ; $e6  Margin_Left
>ce95	4f				          .BYTE 79            ; $e7  Margin_Right
>ce96	00				          .BYTE  0            ; $e8  CurLst_Row
>ce97	00				          .BYTE  0            ; $e9  CurLst_Col
>ce98	00				          .BYTE  0            ; $ea  Cursor_End
>ce99	00				          .BYTE  0            ; $eb  Cursor_Row
>ce9a	00				          .BYTE  0            ; $ec  Cursor_Col
>ce9b	18				          .BYTE 24            ; $ed  LINES
>ce9c	4f				          .BYTE 79            ; $ee  COLUMNS
>ce9d	00				          .BYTE  0            ; $ef  DATAX
>ce9e	00				          .BYTE  0            ; $f0  LSTCHR
>ce9f	07				          .BYTE  7            ; $f1  E_Attribute
>cea0	07				          .BYTE  7            ; $f2  TCOLOR
>cea1	00				          .BYTE  0            ; $f3  E_Reverse
>cea2	00				          .BYTE  0            ; $f4  QTSW
>cea3	00				          .BYTE  0            ; $f5  INSRT
>cea4	00				          .BYTE  0            ; $f6  INSFLG
>cea5	00				          .BYTE  0            ; $f7  LOCKS
>cea6	00				          .BYTE  0            ; $f8  Scroll_Locked
>cea7	00				          .BYTE  0            ; $f9  BEEPER
.cea8					  Edit_Default_FK
>cea8	07 06 0a 07 06 04 05 08		          .BYTE $07,$06,$0a,$07,$06,$04,$05,$08,$09,$05
>ceb0	09 05
>ceb2	47 52 41 50 48 49 43		          .TEXT "GRAPHIC"     ; f1
>ceb9	44 4c 4f 41 44 22		          .TEXT 'DLOAD"'     ; f2
>cebf	44 49 52 45 43 54 4f 52		          .TEXT "DIRECTORY\r" ; f3
>cec7	59 0d
>cec9	53 43 4e 43 4c 52 0d		          .TEXT "SCNCLR\r"    ; f4
>ced0	44 53 41 56 45 22		          .TEXT 'DSAVE"'     ; f5
>ced6	52 55 4e 0d			          .TEXT "RUN\r"       ; f6
>ceda	4c 49 53 54 0d			          .TEXT "LIST\r"      ; f7
>cedf	4d 4f 4e 49 54 4f 52 0d		          .TEXT "MONITOR\r"   ; f8
>cee7	44 cc 22 2a 0d 52 55 4e		          .TEXT "D",$cc,QUOTE,"*\rRUN\r" ; DLOAD"* and RUN
>ceef	0d
>cef0	48 45 4c 50 0d			          .TEXT "HELP\r"
>cef5	ff ff ff ff ff ff ff ff		          .FILL $cf00-* ,$ff ;   11 bytes
>cefd	ff ff ff
.cf00					  UFK_40
.cf00	a5 d1		lda $d1		          LDA KYNDX
.cf02	d0 12		bne $cf16	          BNE UFK_70
.cf04	bd 00 10	lda $1000,x	          LDA PKYBUF,X
.cf07	85 d1		sta $d1		          STA KYNDX
.cf09	a9 00		lda #$00	          LDA #0
.cf0b	18		clc		          CLC
.cf0c	ca		dex		UFK_50    DEX
.cf0d	30 05		bmi $cf14	          BMI UFK_60
.cf0f	7d 00 10	adc $1000,x	          ADC PKYBUF,X
.cf12	90 f8		bcc $cf0c	          BCC UFK_50
.cf14	85 d2		sta $d2		UFK_60    STA KEYIDX
.cf16	4c c4 c6	jmp $c6c4	UFK_70    JMP UFK_20
>cf19	ff ff ff ff ff ff ff ff		          .FILL $cf80-* ,$ff ;  103 bytes
>cf21	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
;	...repeated 4 times (64 bytes)...
>cf71	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
.cf80					  DMA
.cf80	ad 06 d5	lda $d506	          LDA MMU_RAMC
.cf83	48		pha		          PHA                 ; save RAM configuration
.cf84	5d f0 f7	eor $f7f0,x	          EOR Bank_Config_Table,X
.cf87	29 3f		and #$3f	          AND #%00111111
.cf89	5d f0 f7	eor $f7f0,x	          EOR Bank_Config_Table,X
.cf8c	8d 06 d5	sta $d506	          STA MMU_RAMC
.cf8f	bd f0 f7	lda $f7f0,x	          LDA Bank_Config_Table,X
.cf92	aa		tax		          TAX
.cf93	08		php		          PHP
.cf94	78		sei		          SEI
.cf95	20 f0 03	jsr $03f0	          JSR RAM_DMA
.cf98	28		plp		          PLP
.cf99	68		pla		          PLA                 ; restore RAM configuration
.cf9a	8d 06 d5	sta $d506	          STA MMU_RAMC
.cf9d	60		rts		          RTS
>cf9e	ff ff ff ff ff ff ff ff		          .FILL $cfc0-* ,$ff ;   34 bytes
>cfa6	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
>cfb6	ff ff ff ff ff ff ff ff ff ff
>cfc0	28 43 29 31 39 38 36 20		          .TEXT "(C)1986 COMMODORE"
>cfc8	43 4f 4d 4d 4f 44 4f 52 45
>cfd1	20 45 4c 45 43 54 52 4f		          .TEXT " ELECTRONICS, LTD."
>cfd9	4e 49 43 53 2c 20 4c 54 44 2e
>cfe3	20 41 4c 4c 20 52 49 47		          .TEXT " ALL RIGHTS RESERVED."
>cfeb	48 54 53 20 52 45 53 45 52 56 45 44 2e
>cff8	ff 00 f3 91 3b ea 01 4c		          .BYTE $ff,$00,$f3,$91,$3b,$ea,$01,$4c
>d000	ff ff ff ff ff ff ff ff		          .FILL $e000-* ,$ff
>d008	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
;	...repeated 254 times (4064 bytes)...
>dff8	ff ff ff ff ff ff ff ff
.e000					  System_Reset
.e000	a2 ff		ldx #$ff	          LDX #$ff
.e002	78		sei		          SEI
.e003	9a		txs		          TXS
.e004	d8		cld		          CLD
.e005	a9 00		lda #$00	          LDA #0
.e007	8d 00 ff	sta $ff00	          STA MMU_CR
.e00a	a2 0a		ldx #$0a	          LDX #10
.e00c	bd 4b e0	lda $e04b,x	SyRe_10   LDA MMU_Reset_Table,X
.e00f	9d 00 d5	sta $d500,x	          STA MMU_CONT,X
.e012	ca		dex		          DEX
.e013	10 f7		bpl $e00c	          BPL SyRe_10
.e015	8d 04 0a	sta $0a04	          STA INIT_STATUS
.e018	20 cd e0	jsr $e0cd	          JSR Init_Bank_Switching
.e01b	20 f0 e1	jsr $e1f0	          JSR Check_CBM
.e01e	20 42 e2	jsr $e242	          JSR Test_Cartridge
.e021	20 09 e1	jsr $e109	          JSR IOINIT
.e024	20 3d f6	jsr $f63d	          JSR Check_STOP_Key
.e027	48		pha		          PHA
.e028	30 07		bmi $e031	          BMI SyRe_20
.e02a	a9 a5		lda #$a5	          LDA #$a5
.e02c	cd 02 0a	cmp $0a02	          CMP DEJAVU
.e02f	f0 03		beq $e034	          BEQ SyRe_30
.e031	20 93 e0	jsr $e093	SyRe_20   JSR RAMTAS
.e034	20 56 e0	jsr $e056	SyRe_30   JSR RESTOR
.e037	20 00 c0	jsr $c000	          JSR E_CINT
.e03a	68		pla		          PLA
.e03b	58		cli		          CLI
.e03c	30 03		bmi $e041	          BMI SyRe_40
.e03e	4c 00 b0	jmp $b000	          JMP BASIC_MONITOR
.e041	c9 df		cmp #$df	SyRe_40   CMP #$df
.e043	f0 03		beq $e048	          BEQ SyRe_50
.e045	6c 00 0a	jmp ($0a00)	          JMP (RESET_VECTOR)
.e048	4c 4b e2	jmp $e24b	SyRe_50   JMP C64
.e04b					  MMU_Reset_Table
>e04b	00				          .BYTE $00 ; RAM 0 - BASIC - Kernal - I/O
>e04c	00				          .BYTE $00 ; Config A
>e04d	00				          .BYTE $00 ; Config B
>e04e	00				          .BYTE $00 ; Config C
>e04f	00				          .BYTE $00 ; Config D
>e050	bf				          .BYTE $bf ; Mode      80 Col - C128 - 8502
>e051	04				          .BYTE $04 ; RAM       Bank 0 - lower common 1K
>e052	00 00				          .WORD $0000 ;     0 ; Zero  Page
>e054	01 00				          .WORD $0001 ;     1 ; Stack Page
.e056					  RESTOR
.e056	a2 73		ldx #$73	          LDX #<vectss
.e058	a0 e0		ldy #$e0	          LDY #>vectss
.e05a	18		clc		          CLC
.e05b					  VECTOR
.e05b	86 c3		stx $c3		          STX MEMUSS
.e05d	84 c4		sty $c4		          STY MEMUSS+1
.e05f	a0 1f		ldy #$1f	          LDY #$1f
.e061	b9 14 03	lda $0314,y	VECT_10   LDA IIRQ,Y
.e064	b0 02		bcs $e068	          BCS VECT_20
.e066	b1 c3		lda ($c3),y	          LDA (MEMUSS),Y
.e068	99 14 03	sta $0314,y	VECT_20   STA IIRQ,Y
.e06b	90 02		bcc $e06f	          BCC VECT_30
.e06d	91 c3		sta ($c3),y	          STA (MEMUSS),Y
.e06f	88		dey		VECT_30   DEY
.e070	10 ef		bpl $e061	          BPL VECT_10
.e072	60		rts		          RTS
.e073					  vectss
>e073	65 fa				          .WORD IRQ_Normal    ; $0314 IIRQ
>e075	03 b0				          .WORD Mon_Break     ; $0316 IBRK
>e077	40 fa				          .WORD NMI_Normal    ; $0318 INMI
>e079	bd ef				          .WORD OPEN          ; $031a IOPEN
>e07b	88 f1				          .WORD CLOSE         ; $031c ICLOSE
>e07d	06 f1				          .WORD CHKIN         ; $031e ICHKIN
>e07f	4c f1				          .WORD CKOUT         ; $0320 ICKOUT
>e081	26 f2				          .WORD CLRCH         ; $0322 ICLRCH
>e083	06 ef				          .WORD BASIN         ; $0324 IBASIN
>e085	79 ef				          .WORD BSOUT         ; $0326 IBSOUT
>e087	6e f6				          .WORD STOP          ; $0328 ISTOP
>e089	eb ee				          .WORD GETIN         ; $032a KEYVEC
>e08b	22 f2				          .WORD CLALL         ; $032c ICLALL
>e08d	06 b0				          .WORD Mon_Command   ; $032e EXMON
>e08f	6c f2				          .WORD D_LOADSP      ; $0330 ILOAD
>e091	4e f5				          .WORD D_SAVE        ; $0332 ISAVE
.e093					  RAMTAS
.e093	a9 00		lda #$00	          LDA #0
.e095	a8		tay		          TAY
.e096	99 02 00	sta $0002,y	RAMT_10   STA BANK,Y          ; clear $02 - $ff
.e099	c8		iny		          INY
.e09a	d0 fa		bne $e096	          BNE RAMT_10
.e09c	a0 0b		ldy #$0b	          LDY #>T_Buffer
.e09e	84 b3		sty $b3		          STY TAPE1+1         ; (TAPE1) = T_Buffer
.e0a0	85 b2		sta $b2		          STA TAPE1
.e0a2	a0 0c		ldy #$0c	          LDY #>R_Rece_Buffer
.e0a4	84 c9		sty $c9		          STY RIBUF+1         ; (RIBUF) = R_Rece_Buffer
.e0a6	85 c8		sta $c8		          STA RIBUF
.e0a8	a0 0d		ldy #$0d	          LDY #>R_Send_Buffer
.e0aa	84 cb		sty $cb		          STY ROBUF+1         ; (ROBUF) = R_Send_Buffer
.e0ac	85 ca		sta $ca		          STA ROBUF
.e0ae	18		clc		          CLC
.e0af	a0 ff		ldy #$ff	          LDY #>$ff00
.e0b1	a2 00		ldx #$00	          LDX #<$ff00
.e0b3	20 6b f7	jsr $f76b	          JSR SET_MEM_TOP     ; (MEM_TOP) = $ff00
.e0b6	a0 1c		ldy #$1c	          LDY #>RAMBOT
.e0b8	a2 00		ldx #$00	          LDX #<RAMBOT
.e0ba	20 7a f7	jsr $f77a	          JSR SET_MEM_BOT     ; (MEM_BOT) = $1c00
.e0bd	a0 40		ldy #$40	          LDY #>B_Cold_Start
.e0bf	a2 00		ldx #$00	          LDX #<B_Cold_Start
.e0c1	8c 01 0a	sty $0a01	          STY RESET_VECTOR+1
.e0c4	8e 00 0a	stx $0a00	          STX RESET_VECTOR
.e0c7	a9 a5		lda #$a5	          LDA #$a5
.e0c9	8d 02 0a	sta $0a02	          STA DEJAVU          ; set flag RAMTAS executed
.e0cc	60		rts		          RTS
.e0cd					  Init_Bank_Switching
.e0cd	a0 03		ldy #$03	          LDY #3
.e0cf	b9 05 e1	lda $e105,y	InBS_10   LDA insttb,Y
.e0d2	8d 00 ff	sta $ff00	          STA MMU_CR
.e0d5	a2 3f		ldx #$3f	          LDX #$3f
.e0d7	bd 05 ff	lda $ff05,x	InBS_20   LDA NMI,X
.e0da	9d 05 ff	sta $ff05,x	          STA NMI,X
.e0dd	ca		dex		          DEX
.e0de	10 f7		bpl $e0d7	          BPL InBS_20
.e0e0	a2 05		ldx #$05	          LDX #5
.e0e2	bd fa ff	lda $fffa,x	InBS_30   LDA V_NMI,X
.e0e5	9d fa ff	sta $fffa,x	          STA V_NMI,X
.e0e8	ca		dex		          DEX
.e0e9	10 f7		bpl $e0e2	          BPL InBS_30
.e0eb	88		dey		          DEY
.e0ec	10 e1		bpl $e0cf	          BPL InBS_10
.e0ee	a2 59		ldx #$59	          LDX #$59
.e0f0	bd 00 f8	lda $f800,x	InBS_40   LDA ROM_FETCH,X
.e0f3	9d a2 02	sta $02a2,x	          STA FETCH,X
.e0f6	ca		dex		          DEX
.e0f7	10 f7		bpl $e0f0	          BPL InBS_40
.e0f9	a2 0c		ldx #$0c	          LDX #12
.e0fb	bd 5a f8	lda $f85a,x	InBS_50   LDA ROM_DMA,X
.e0fe	9d f0 03	sta $03f0,x	          STA RAM_DMA,X
.e101	ca		dex		          DEX
.e102	10 f7		bpl $e0fb	          BPL InBS_50
.e104	60		rts		          RTS
.e105					  insttb
>e105	00				          .BYTE $00           ; RAM bank 0
>e106	40				          .BYTE $40           ; RAM bank 1
>e107	80				          .BYTE $80           ; RAM bank 2 (not installed)
>e108	c0				          .BYTE $c0           ; RAM bank 3 (not installed)
.e109					  IOINIT
.e109	a9 7f		lda #$7f	          LDA #$7f
.e10b	8d 0d dc	sta $dc0d	          STA CIA1_ICR
.e10e	8d 0d dd	sta $dd0d	          STA CIA2_ICR
.e111	8d 00 dc	sta $dc00	          STA CIA1_KBD_COL
.e114	a9 08		lda #$08	          LDA #8
.e116	8d 0e dc	sta $dc0e	          STA CIA1_CRA
.e119	8d 0e dd	sta $dd0e	          STA CIA2_CRA
.e11c	8d 0f dc	sta $dc0f	          STA CIA1_CRB
.e11f	8d 0f dd	sta $dd0f	          STA CIA2_CRB
.e122	a2 00		ldx #$00	          LDX #0
.e124	8e 03 dc	stx $dc03	          STX CIA1_DDRB
.e127	8e 03 dd	stx $dd03	          STX CIA2_DDRB
.e12a	ca		dex		          DEX
.e12b	8e 02 dc	stx $dc02	          STX CIA1_DDRA
.e12e	a9 07		lda #$07	          LDA #7
.e130	8d 00 dd	sta $dd00	          STA CIA2_PRA
.e133	a9 3f		lda #$3f	          LDA #$3f
.e135	8d 02 dd	sta $dd02	          STA CIA2_DDRA
.e138	a9 e3		lda #$e3	          LDA #$e3
.e13a	85 01		sta $01		          STA R8502
.e13c	a9 2f		lda #$2f	          LDA #$2f
.e13e	85 00		sta $00		          STA D8502
.e140	a2 ff		ldx #$ff	          LDX #$ff
.e142	ad 11 d0	lda $d011	IOIN_10   LDA VIC_Ctrl_1
.e145	10 fb		bpl $e142	          BPL IOIN_10
.e147	a9 08		lda #$08	IOIN_20   LDA #8
.e149	cd 12 d0	cmp $d012	          CMP VIC_RASTER
.e14c	90 06		bcc $e154	          BCC IOIN_30         ; -> PAL: PALNTS = $ff
.e14e	ad 11 d0	lda $d011	          LDA VIC_Ctrl_1
.e151	30 f4		bmi $e147	          BMI IOIN_20
.e153	e8		inx		          INX                 ;   NTSC: PALNTS = $00
.e154	8e 03 0a	stx $0a03	IOIN_30   STX PALNTS
.e157	a9 00		lda #$00	          LDA #0
.e159	20 55 fc	jsr $fc55	          JSR Init_RS232
.e15c	8d 39 0a	sta $0a39	          STA VSH_Ctrl_1
.e15f	8d 0a 0a	sta $0a0a	          STA IRQTMP+1
.e162	8d 3a 0a	sta $0a3a	          STA SPRITES
.e165	8d 36 0a	sta $0a36	          STA PAL_ADJ
.e168	85 99		sta $99		          STA DFLTN
.e16a	a9 03		lda #$03	          LDA #3
.e16c	85 9a		sta $9a		          STA DFLTO
.e16e	a2 30		ldx #$30	          LDX #$30
.e170	bd c7 e2	lda $e2c7,x	IOIN_40   LDA VIC_Init_Values,X
.e173	9d 00 d0	sta $d000,x	          STA VIC,X
.e176	ca		dex		          DEX
.e177	10 f7		bpl $e170	          BPL IOIN_40
.e179	a2 00		ldx #$00	          LDX #0
.e17b	20 dc e1	jsr $e1dc	          JSR VDC_Program_X
.e17e	ad 00 d6	lda $d600	          LDA VDC_Register
.e181	29 07		and #$07	          AND #%00000111 ; $07
.e183	f0 05		beq $e18a	          BEQ IOIN_50
.e185	a2 3b		ldx #$3b	          LDX #VDC_Init_NTSC-VDC_Init_Values ; $3b
.e187	20 dc e1	jsr $e1dc	          JSR VDC_Program_X
.e18a	2c 03 0a	bit $0a03	IOIN_50   BIT PALNTS
.e18d	10 05		bpl $e194	          BPL IOIN_60
.e18f	a2 3e		ldx #$3e	          LDX #VDC_Init_PAL-VDC_Init_Values ; $3e
.e191	20 67 fc	jsr $fc67	          JSR VDC_Program_Mod
.e194	ad 04 0a	lda $0a04	IOIN_60   LDA INIT_STATUS
.e197	30 15		bmi $e1ae	          BMI IOIN_80
.e199	20 27 c0	jsr $c027	          JSR E_DLCHR
.e19c	a9 80		lda #$80	          LDA #$80
.e19e	0d 04 0a	ora $0a04	          ORA INIT_STATUS
.e1a1	8d 04 0a	sta $0a04	          STA INIT_STATUS
.e1a4	a2 ff		ldx #$ff	          LDX #$ff
.e1a6	a0 ff		ldy #$ff	          LDY #$ff
.e1a8	88		dey		IOIN_70   DEY
.e1a9	d0 fd		bne $e1a8	          BNE IOIN_70
.e1ab	ca		dex		          DEX
.e1ac	d0 fa		bne $e1a8	          BNE IOIN_70
.e1ae	a9 00		lda #$00	IOIN_80   LDA #0
.e1b0	a2 18		ldx #$18	          LDX #$18
.e1b2	9d 00 d4	sta $d400,x	IOIN_90   STA SID_Freq_1,X
.e1b5	ca		dex		          DEX
.e1b6	10 fa		bpl $e1b2	          BPL IOIN_90
.e1b8					  Test_Fast_IEC
.e1b8	a2 01		ldx #$01	          LDX #1              ; X = 1
.e1ba	8e 1a d0	stx $d01a	          STX VIC_IRQ_ENA     ; enable raster interrupt only
.e1bd	ca		dex		          DEX                 ; X = 0
.e1be	8e 1c 0a	stx $0a1c	          STX Fast_IEC        ; default: not a fast device
.e1c1	8e 0f 0a	stx $0a0f	          STX RS_Enable       ; disable RS232 interface
.e1c4	ca		dex		          DEX                 ; X = $ff
.e1c5	8e 06 dc	stx $dc06	          STX CIA1_TBLO
.e1c8	8e 07 dc	stx $dc07	          STX CIA1_TBHI       ; $ffff = 65 msec
.e1cb	a2 11		ldx #$11	          LDX #%00010001     ; ONE STOP
.e1cd	8e 0f dc	stx $dc0f	          STX CIA1_CRB
.e1d0	20 c3 e5	jsr $e5c3	          JSR IEC_Fast_Input
.e1d3	20 d6 e5	jsr $e5d6	          JSR IEC_Fast_Output
.e1d6	20 c3 e5	jsr $e5c3	          JSR IEC_Fast_Input
.e1d9	4c 4e e5	jmp $e54e	          JMP IEC_Clock_Low
.e1dc					  VDC_Program_X
.e1dc	bc f8 e2	ldy $e2f8,x	          LDY VDC_Init_Values,X
.e1df	30 0d		bmi $e1ee	          BMI VPX_10
.e1e1	e8		inx		          INX
.e1e2	bd f8 e2	lda $e2f8,x	          LDA VDC_Init_Values,X
.e1e5	e8		inx		          INX
.e1e6	8c 00 d6	sty $d600	          STY VDC_Register
.e1e9	8d 01 d6	sta $d601	          STA VDC_Data
.e1ec	10 ee		bpl $e1dc	          BPL VDC_Program_X
.e1ee	e8		inx		VPX_10    INX
.e1ef	60		rts		          RTS
.e1f0					  Check_CBM
.e1f0	a2 f5		ldx #$f5	          LDX #<$fff5
.e1f2	a0 ff		ldy #$ff	          LDY #>$fff5
.e1f4	86 c3		stx $c3		          STX MEMUSS
.e1f6	84 c4		sty $c4		          STY MEMUSS+1
.e1f8	a9 c3		lda #$c3	          LDA #MEMUSS
.e1fa	8d aa 02	sta $02aa	          STA FETCH+8
.e1fd	a0 02		ldy #$02	          LDY #2
.e1ff	a2 7f		ldx #$7f	CCBM_10   LDX #$7f            ; RAM bank 1
.e201	20 a2 02	jsr $02a2	          JSR FETCH
.e204	d9 c4 e2	cmp $e2c4,y	          CMP ROM_CBM,Y
.e207	d0 1b		bne $e224	          BNE SYSTEM
.e209	88		dey		          DEY
.e20a	10 f3		bpl $e1ff	          BPL CCBM_10
.e20c	a2 f8		ldx #$f8	          LDX #<V_SYSTEM
.e20e	a0 ff		ldy #$ff	          LDY #>V_SYSTEM
.e210	86 c3		stx $c3		          STX MEMUSS
.e212	84 c4		sty $c4		          STY MEMUSS+1
.e214	a0 01		ldy #$01	          LDY #1
.e216	a2 7f		ldx #$7f	CCBM_20   LDX #$7f
.e218	20 a2 02	jsr $02a2	          JSR FETCH
.e21b	99 02 00	sta $0002,y	          STA BANK,Y
.e21e	88		dey		          DEY
.e21f	10 f5		bpl $e216	          BPL CCBM_20
.e221	6c 02 00	jmp ($0002)	          JMP (BANK)
.e224					  SYSTEM
.e224	a9 40		lda #$40	          LDA #$40 ; '@'
.e226	8d 00 ff	sta $ff00	          STA MMU_CR
.e229	a9 24		lda #$24	          LDA #<SYSTEM
.e22b	a0 e2		ldy #$e2	          LDY #>SYSTEM
.e22d	8d f8 ff	sta $fff8	          STA V_SYSTEM
.e230	8c f9 ff	sty $fff9	          STY V_SYSTEM+1
.e233	a2 03		ldx #$03	          LDX #3
.e235	bd c3 e2	lda $e2c3,x	SYST_10   LDA ROM_CBM-1,X
.e238	9d f4 ff	sta $fff4,x	          STA V_LOCK-2,X
.e23b	ca		dex		          DEX
.e23c	d0 f7		bne $e235	          BNE SYST_10
.e23e	8e 00 ff	stx $ff00	          STX MMU_CR
.e241	60		rts		          RTS
.e242					  Test_Cartridge
.e242	ad 05 d5	lda $d505	          LDA MMU_MODE
.e245	29 30		and #$30	          AND #%00110000 ; $30
.e247	c9 30		cmp #$30	          CMP #%00110000 ; $30
.e249	f0 20		beq $e26b	          BEQ TeCa_10         ; -> no C64 modules
.e24b					  C64
.e24b	a9 e3		lda #$e3	          LDA #$e3
.e24d	85 01		sta $01		          STA R8502
.e24f	a9 2f		lda #$2f	          LDA #$2f
.e251	85 00		sta $00		          STA D8502
.e253	a2 08		ldx #$08	          LDX #8
.e255	bd 62 e2	lda $e262,x	C64_10    LDA ROM_GO64-1,X    ; copy reset code to RAM
.e258	95 01		sta $01,x	          STA BANK-1,X
.e25a	ca		dex		          DEX
.e25b	d0 f8		bne $e255	          BNE C64_10
.e25d	8e 30 d0	stx $d030	          STX VIC_SPEED       ; set to 1 MHz
.e260	4c 02 00	jmp $0002	          JMP BANK            ; jump to reset in C64 mode
.e263					  ROM_GO64
.e263	a9 f7		lda #$f7	          LDA #$f7
.e265	8d 05 d5	sta $d505	          STA MMU_MODE
.e268	6c fc ff	jmp ($fffc)	          JMP (V_RESET)
.e26b	a2 03		ldx #$03	TeCa_10   LDX #3              ; 4 banks
.e26d	8e c0 0a	stx $0ac0	          STX Module_Bank
.e270	a9 00		lda #$00	          LDA #0
.e272	9d c1 0a	sta $0ac1,x	TeCa_20   STA Module_Flags,X  ; clear module flags
.e275	ca		dex		          DEX
.e276	10 fa		bpl $e272	          BPL TeCa_20         ; loop
.e278	85 9e		sta $9e		          STA PTR_LO          ; ROM address low
.e27a	a0 09		ldy #$09	TeCa_30   LDY #9
.e27c	ae c0 0a	ldx $0ac0	          LDX Module_Bank     ; module bank counter 3 -> 0
.e27f	bd bc e2	lda $e2bc,x	          LDA ROM_PAGES,X
.e282	85 9f		sta $9f		          STA PTR_HI          ; ROM address high
.e284	bd c0 e2	lda $e2c0,x	          LDA ROM_BANK,X
.e287	85 02		sta $02		          STA BANK            ; ROM bank
.e289	a6 02		ldx $02		TeCa_40   LDX BANK
.e28b	a9 9e		lda #$9e	          LDA #PTR_LO
.e28d	20 d0 f7	jsr $f7d0	          JSR INDFET          ; LDA ROM,9 and ROM,8 and ROM,7
.e290	d9 bd e2	cmp $e2bd,y	          CMP ROM_CBM-7,Y     ; check for "CBM" string
.e293	d0 21		bne $e2b6	          BNE TeCa_50         ; -> no valid string
.e295	88		dey		          DEY
.e296	c0 07		cpy #$07	          CPY #7              ; last index
.e298	b0 ef		bcs $e289	          BCS TeCa_40         ; loop
.e29a	a6 02		ldx $02		          LDX BANK
.e29c	a9 9e		lda #$9e	          LDA #PTR_LO
.e29e	20 d0 f7	jsr $f7d0	          JSR INDFET          ; LDA ROM,6 (flags)
.e2a1	ae c0 0a	ldx $0ac0	          LDX Module_Bank
.e2a4	9d c1 0a	sta $0ac1,x	          STA Module_Flags,X  ; store ROM flags
.e2a7	c9 01		cmp #$01	          CMP #1              ; init code present ?
.e2a9	d0 0b		bne $e2b6	          BNE TeCa_50         ; -> no
.e2ab	a5 9e		lda $9e		          LDA PTR_LO
.e2ad	a4 9f		ldy $9f		          LDY PTR_HI
.e2af	85 04		sta $04		          STA PC_LO           ; PC := ROM address
.e2b1	84 03		sty $03		          STY PC_HI
.e2b3	20 cd 02	jsr $02cd	          JSR JSRFAR          ; call ROM initialization code
.e2b6	ce c0 0a	dec $0ac0	TeCa_50   DEC Module_Bank     ; next ROM module
.e2b9	10 bf		bpl $e27a	          BPL TeCa_30
.e2bb	60		rts		          RTS
.e2bc					  ROM_PAGES
>e2bc	c0				          .BYTE >$c000
>e2bd	80				          .BYTE >$8000
>e2be	c0				          .BYTE >$c000
>e2bf	80				          .BYTE >$8000
.e2c0					  ROM_BANK
>e2c0	04				          .BYTE $04
>e2c1	04				          .BYTE $04
>e2c2	08				          .BYTE $08
>e2c3	08				          .BYTE $08
.e2c4					  ROM_CBM
>e2c4	43 42 4d			          .TEXT "CBM"         ; expansion ROM marker
.e2c7					  VIC_Init_Values
>e2c7	00				          .BYTE $00           ; D000 X coordinate sprite 0
>e2c8	00				          .BYTE $00           ; D001 Y coordinate sprite 0
>e2c9	00				          .BYTE $00           ; D002 X coordinate sprite 1
>e2ca	00				          .BYTE $00           ; D003 Y coordinate sprite 1
>e2cb	00				          .BYTE $00           ; D004 X coordinate sprite 2
>e2cc	00				          .BYTE $00           ; D005 Y coordinate sprite 2
>e2cd	00				          .BYTE $00           ; D006 X coordinate sprite 3
>e2ce	00				          .BYTE $00           ; D007 Y coordinate sprite 3
>e2cf	00				          .BYTE $00           ; D008 X coordinate sprite 4
>e2d0	00				          .BYTE $00           ; D009 Y coordinate sprite 4
>e2d1	00				          .BYTE $00           ; D00A X coordinate sprite 5
>e2d2	00				          .BYTE $00           ; D00B Y coordinate sprite 5
>e2d3	00				          .BYTE $00           ; D00C X coordinate sprite 6
>e2d4	00				          .BYTE $00           ; D00D Y coordinate sprite 6
>e2d5	00				          .BYTE $00           ; D00E X coordinate sprite 7
>e2d6	00				          .BYTE $00           ; D00F Y coordinate sprite 7
>e2d7	00				          .BYTE $00           ; D010 MSBs of X coordinates
>e2d8	1b				          .BYTE $1b           ; D011 Control register 1
>e2d9	ff				          .BYTE $ff           ; D012 VIC_RASTER counter
>e2da	00				          .BYTE $00           ; D013 Light pen X
>e2db	00				          .BYTE $00           ; D014 Light pen Y
>e2dc	00				          .BYTE $00           ; D015 Sprite enabled
>e2dd	08				          .BYTE $08           ; D016 Control register 2
>e2de	00				          .BYTE $00           ; D017 Sprite Y expansion
>e2df	14				          .BYTE $14           ; D018 Memory control
>e2e0	ff				          .BYTE $ff           ; D019 Interrupt register
>e2e1	01				          .BYTE $01           ; D01A Interrupt enabled
>e2e2	00				          .BYTE $00           ; D01B Sprite priority
>e2e3	00				          .BYTE $00           ; D01C Sprite multicolor
>e2e4	00				          .BYTE $00           ; D01D Sprite X expansion
>e2e5	00				          .BYTE $00           ; D01E Sprite sprite collision
>e2e6	00				          .BYTE $00           ; D01F Sprite data   collision
>e2e7	0d				          .BYTE $0d           ; D020 Border color
>e2e8	0b				          .BYTE $0b           ; D021 Background  color 0
>e2e9	01				          .BYTE $01           ; D022 Background  color 1
>e2ea	02				          .BYTE $02           ; D023 Background  color 2
>e2eb	03				          .BYTE $03           ; D024 Background  color 3
>e2ec	01				          .BYTE $01           ; D025 Sprite multicolor 0
>e2ed	02				          .BYTE $02           ; D026 Sprite multicolor 1
>e2ee	00				          .BYTE $00           ; D027 Sprite color 0
>e2ef	01				          .BYTE $01           ; D028 Sprite color 1
>e2f0	02				          .BYTE $02           ; D029 Sprite color 2
>e2f1	03				          .BYTE $03           ; D02A Sprite color 3
>e2f2	04				          .BYTE $04           ; D02B Sprite color 4
>e2f3	05				          .BYTE $05           ; D02C Sprite color 5
>e2f4	06				          .BYTE $06           ; D02D Sprite color 6
>e2f5	07				          .BYTE $07           ; D02E Sprite color 7
>e2f6	ff				          .BYTE $ff           ; D02F Keyboard control
>e2f7	fc				          .BYTE $fc           ; D030 Fast (2 MHz) or Slow (1 MHz)
.e2f8					  VDC_Init_Values
>e2f8	00 7e				          .BYTE $00,$7e       ; 00 total   columns (126)
>e2fa	01 50				          .BYTE $01,$50       ; 01 visible columns ( 80)
>e2fc	02 66				          .BYTE $02,$66       ; 02 horizonatl sync
>e2fe	03 49				          .BYTE $03,$49       ; 03 VSYNC / HSYNC
>e300	04 20				          .BYTE $04,$20       ; 04 total rows (32)
>e302	05 00				          .BYTE $05,$00       ; 05 rows adjust
>e304	06 19				          .BYTE $06,$19       ; 06 visible rows (25)
>e306	07 1d				          .BYTE $07,$1d       ; 07 VSYNC position
>e308	08 00				          .BYTE $08,$00       ; 08 Interlace
>e30a	09 07				          .BYTE $09,$07       ; 09 scanlines - 1 per character
>e30c	0a 20				          .BYTE $0a,$20       ; 0A cursor mode / start
>e30e	0b 07				          .BYTE $0b,$07       ; 0B cursor end
>e310	0c 00				          .BYTE $0c,$00       ; 0C character RAM start high
>e312	0d 00				          .BYTE $0d,$00       ; 0D character RAM start low
>e314	0e 00				          .BYTE $0e,$00       ; 0E cursor position high
>e316	0f 00				          .BYTE $0f,$00       ; 0F cursor position low
>e318	14 08				          .BYTE $14,$08       ; 14 attribute RAM start high
>e31a	15 00				          .BYTE $15,$00       ; 15 attribute RAM start low
>e31c	17 08				          .BYTE $17,$08       ; 17 scanlines - 1 per character
>e31e	18 20				          .BYTE $18,$20       ; 18 block copy / blink frequency
>e320	19 40				          .BYTE $19,$40       ; 19 text / graphics mode
>e322	1a f0				          .BYTE $1a,$f0       ; 1A foreground / background color
>e324	1b 00				          .BYTE $1b,$00       ; 1B row step value
>e326	1c 20				          .BYTE $1c,$20       ; 1C character generator page
>e328	1d 07				          .BYTE $1d,$07       ; 1D underline count
>e32a	22 7d				          .BYTE $22,$7d       ; 22 left margin
>e32c	23 64				          .BYTE $23,$64       ; 23 right margin
>e32e	24 05				          .BYTE $24,$05       ; 24 refresh cycles
>e330	16 78				          .BYTE $16,$78       ; 16 character width
>e332	ff				          .BYTE $ff           ; end of table marker
.e333					VDC_Init_NTSC
>e333	19 47				          .BYTE $19,$47       ; 19 text / graphics mode
>e335	ff				          .BYTE $ff           ; end of table marker
.e336					VDC_Init_PAL
>e336	04 26				          .BYTE $04,$26       ; 04 total rows (38)
>e338	07 20				          .BYTE $07,$20       ; 07 VSYNC position
>e33a	ff				          .BYTE $ff           ; end of table marker
.e33b					  TALK
.e33b	09 40		ora #$40	          ORA #%01000000     ; $40 set TALK bit
>e33d	2c				          .byte $2c ;                 ; skip next instruction
.e33e					  LISTN
.e33e	09 20		ora #$20	          ORA #%00100000     ; $20 set LISTEN bit
.e340	20 ec e7	jsr $e7ec	          JSR RS232_Stop
.e343					  Talk_Listen
.e343	48		pha		          PHA                 ; push primary address
.e344	24 94		bit $94		          BIT C3PO            ; test IEC buffer flag
.e346	10 0a		bpl $e352	          BPL TaLi_10         ; -> buffer empty
.e348	38		sec		          SEC
.e349	66 a3		ror $a3		          ROR R2D2            ; set
.e34b	20 8c e3	jsr $e38c	          JSR IEC_Send_Byte
.e34e	46 94		lsr $94		          LSR C3PO
.e350	46 a3		lsr $a3		          LSR R2D2
.e352	68		pla		TaLi_10   PLA                 ; pull primary address
.e353	85 95		sta $95		          STA BSOUR
.e355	20 73 e5	jsr $e573	          JSR Disable_IRQ_and_Sprites
.e358	20 57 e5	jsr $e557	          JSR IEC_Data_Out_High
.e35b	ad 00 dd	lda $dd00	          LDA CIA2_PRA
.e35e	29 08		and #$08	          AND #%00001000     ; $08
.e360	d0 12		bne $e374	          BNE TaLi_30
.e362	20 d6 e5	jsr $e5d6	          JSR IEC_Fast_Output
.e365	a9 ff		lda #$ff	          LDA #$ff
.e367	8d 0c dc	sta $dc0c	          STA CIA1_SDR        ; send $ff
.e36a	20 bc e5	jsr $e5bc	          JSR IEC_Wait_Ready
.e36d	8a		txa		          TXA
.e36e	a2 14		ldx #$14	          LDX #$14
.e370	ca		dex		TaLi_20   DEX
.e371	d0 fd		bne $e370	          BNE TaLi_20
.e373	aa		tax		          TAX
.e374	ad 00 dd	lda $dd00	TaLi_30   LDA CIA2_PRA
.e377	09 08		ora #$08	          ORA #%00001000 ; $08
.e379	8d 00 dd	sta $dd00	          STA CIA2_PRA
.e37c					  IEC_Send_With_ATN
.e37c	20 73 e5	jsr $e573	          JSR Disable_IRQ_and_Sprites
.e37f	20 4e e5	jsr $e54e	          JSR IEC_Clock_Low
.e382	20 57 e5	jsr $e557	          JSR IEC_Data_Out_High
.e385	8a		txa		          TXA
.e386	a2 b8		ldx #$b8	          LDX #$b8            ; wait 1 millisecond
.e388	ca		dex		ISWA_10   DEX
.e389	d0 fd		bne $e388	          BNE ISWA_10
.e38b	aa		tax		          TAX
.e38c					  IEC_Send_Byte
.e38c	20 73 e5	jsr $e573	          JSR Disable_IRQ_and_Sprites
.e38f	20 57 e5	jsr $e557	          JSR IEC_Data_Out_High
.e392	20 69 e5	jsr $e569	          JSR IEC_Clock_Data_In
.e395	90 03		bcc $e39a	          BCC ISB_10          ; -> DATA IN high
.e397	4c 28 e4	jmp $e428	          JMP ISB_75          ; -> device not present
.e39a	2c 0d dc	bit $dc0d	ISB_10    BIT CIA1_ICR        ; reset IRQ flag
.e39d	20 45 e5	jsr $e545	          JSR IEC_Clock_High
.e3a0	24 a3		bit $a3		          BIT R2D2
.e3a2	10 0a		bpl $e3ae	          BPL ISB_25
.e3a4	20 69 e5	jsr $e569	ISB_15    JSR IEC_Clock_Data_In
.e3a7	90 fb		bcc $e3a4	          BCC ISB_15          ; wait for DATA IN low
.e3a9	20 69 e5	jsr $e569	ISB_20    JSR IEC_Clock_Data_In
.e3ac	b0 fb		bcs $e3a9	          BCS ISB_20          ; wait for DATA IN high
.e3ae	ad 00 dd	lda $dd00	ISB_25    LDA CIA2_PRA
.e3b1	cd 00 dd	cmp $dd00	          CMP CIA2_PRA
.e3b4	d0 f8		bne $e3ae	          BNE ISB_25          ; -> debounce
.e3b6	48		pha		          PHA                 ; push
.e3b7	ad 0d dc	lda $dc0d	          LDA CIA1_ICR
.e3ba	29 08		and #$08	          AND #%00001000     ; $08 test IRQ IEC port
.e3bc	f0 05		beq $e3c3	          BEQ ISB_30          ; -> slow IEC device
.e3be	a9 c0		lda #$c0	          LDA #$c0            ; fast IEC and burst mode enabled
.e3c0	8d 1c 0a	sta $0a1c	          STA Fast_IEC        ; fast IEC device
.e3c3	68		pla		ISB_30    PLA
.e3c4	10 e8		bpl $e3ae	          BPL ISB_25          ; -> DATA IN high
.e3c6	09 10		ora #$10	          ORA #%00010000     ; $10 DATA OUT low
.e3c8	8d 00 dd	sta $dd00	          STA CIA2_PRA
.e3cb	29 08		and #$08	          AND #%00001000     ; $08 ATN out
.e3cd	d0 13		bne $e3e2	          BNE ISB_35          ; -> ATN low
.e3cf	2c 1c 0a	bit $0a1c	          BIT Fast_IEC
.e3d2	10 0e		bpl $e3e2	          BPL ISB_35          ; -> slow IEC
.e3d4	20 d6 e5	jsr $e5d6	          JSR IEC_Fast_Output
.e3d7	a5 95		lda $95		          LDA BSOUR
.e3d9	8d 0c dc	sta $dc0c	          STA CIA1_SDR        ; store data in register
.e3dc	20 bc e5	jsr $e5bc	          JSR IEC_Wait_Ready  ; wait until sent
.e3df	4c 12 e4	jmp $e412	          JMP ISB_55          ; -> finish
.e3e2	a9 08		lda #$08	ISB_35    LDA #8              ; send 8 bits
.e3e4	85 a5		sta $a5		          STA CNTDN
.e3e6	ad 00 dd	lda $dd00	ISB_40    LDA CIA2_PRA
.e3e9	cd 00 dd	cmp $dd00	          CMP CIA2_PRA
.e3ec	d0 f8		bne $e3e6	          BNE ISB_40            ; -> debounce
.e3ee	0a		asl a		          ASL A                 ; DATA IN -> carry
.e3ef	90 34		bcc $e425	          BCC ISB_70            ; -> error: timeout
.e3f1	66 95		ror $95		          ROR BSOUR             ; next data bit -> carry
.e3f3	b0 05		bcs $e3fa	          BCS ISB_45
.e3f5	20 60 e5	jsr $e560	          JSR IEC_Data_Out_Low  ;    send '0' bit
.e3f8	d0 03		bne $e3fd	          BNE ISB_50            ; always
.e3fa	20 57 e5	jsr $e557	ISB_45    JSR IEC_Data_Out_High ; -> send '1' bit
.e3fd	20 45 e5	jsr $e545	ISB_50    JSR IEC_Clock_High
.e400	ea		nop		          NOP                   ; wait 8 cycles
.e401	ea		nop		          NOP
.e402	ea		nop		          NOP
.e403	ea		nop		          NOP
.e404	ad 00 dd	lda $dd00	          LDA CIA2_PRA
.e407	29 df		and #$df	          AND #%11011111       ; $df DATA  OUT high
.e409	09 10		ora #$10	          ORA #%00010000       ; $10 CLOCK OUT low
.e40b	8d 00 dd	sta $dd00	          STA CIA2_PRA
.e40e	c6 a5		dec $a5		          DEC CNTDN             ; next bit
.e410	d0 d4		bne $e3e6	          BNE ISB_40            ; loop
.e412	8a		txa		ISB_55    TXA
.e413	48		pha		          PHA                 ; save X
.e414	a2 22		ldx #$22	          LDX #$22            ; timeout counter
.e416	20 69 e5	jsr $e569	ISB_60    JSR IEC_Clock_Data_In
.e419	b0 05		bcs $e420	          BCS ISB_65          ; -> wait for DATA IN
.e41b	68		pla		          PLA
.e41c	aa		tax		          TAX                 ; restore X
.e41d	4c 9f e5	jmp $e59f	          JMP Enable_IRQ_and_Sprites ; exit
.e420	ca		dex		ISB_65    DEX
.e421	d0 f3		bne $e416	          BNE ISB_60
.e423	68		pla		          PLA
.e424	aa		tax		          TAX                 ; restore X
.e425	a9 03		lda #$03	ISB_70    LDA #3              ; timeout
>e427	2c				          .byte $2c ;BIT
.e428	a9 80		lda #$80	ISB_75    LDA #$80            ; device not present
.e42a					  IEC_Error
.e42a	48		pha		          PHA
.e42b	ad 1c 0a	lda $0a1c	          LDA Fast_IEC
.e42e	29 7f		and #$7f	          AND #%01111111     ; $7f clear fast IEC flag
.e430	8d 1c 0a	sta $0a1c	          STA Fast_IEC
.e433	68		pla		          PLA
.e434	20 57 f7	jsr $f757	          JSR SETST
.e437	20 9f e5	jsr $e59f	          JSR Enable_IRQ_and_Sprites
.e43a	18		clc		          CLC
.e43b	4c 35 e5	jmp $e535	          JMP UNLSN_10
.e43e					  ACPTR
.e43e	20 73 e5	jsr $e573	          JSR Disable_IRQ_and_Sprites
.e441	a9 00		lda #$00	          LDA #0
.e443	85 a5		sta $a5		          STA CNTDN           ; retry counter
.e445	2c 0d dc	bit $dc0d	          BIT CIA1_ICR        ; reset IRQ's
.e448	8a		txa		          TXA
.e449	48		pha		          PHA                 ; save X
.e44a	20 45 e5	jsr $e545	          JSR IEC_Clock_High
.e44d	20 69 e5	jsr $e569	ACPTR_10  JSR IEC_Clock_Data_In
.e450	10 fb		bpl $e44d	          BPL ACPTR_10        ; wait for CLOCK IN high
.e452	a2 0d		ldx #$0d	ACPTR_15  LDX #13             ; wait max. 0.25 msec
.e454	ad 00 dd	lda $dd00	          LDA CIA2_PRA
.e457	29 df		and #$df	          AND #%11011111     ; $df DATA OUT high
.e459	8d 00 dd	sta $dd00	          STA CIA2_PRA
.e45c	ad 00 dd	lda $dd00	ACPTR_20  LDA CIA2_PRA
.e45f	cd 00 dd	cmp $dd00	          CMP CIA2_PRA
.e462	d0 f8		bne $e45c	          BNE ACPTR_20        ; -> debounce
.e464	0a		asl a		          ASL A               ; CLOCK IN -> bit 7
.e465	10 1d		bpl $e484	          BPL ACPTR_30        ; -> OK
.e467	ca		dex		          DEX
.e468	d0 f2		bne $e45c	          BNE ACPTR_20        ; -> wait for CLOCK_IN
.e46a	a5 a5		lda $a5		          LDA CNTDN
.e46c	d0 0f		bne $e47d	          BNE ACPTR_25        ; -> retry failed again
.e46e	20 60 e5	jsr $e560	          JSR IEC_Data_Out_Low
.e471	20 45 e5	jsr $e545	          JSR IEC_Clock_High
.e474	a9 40		lda #$40	          LDA #$40            ; EOF
.e476	20 57 f7	jsr $f757	          JSR SETST           ; set EOF flag
.e479	e6 a5		inc $a5		          INC CNTDN           ; set retry flag
.e47b	d0 d5		bne $e452	          BNE ACPTR_15        ; always
.e47d	68		pla		ACPTR_25  PLA                 ; read failed
.e47e	aa		tax		          TAX                 ; restore X
.e47f	a9 02		lda #$02	          LDA #2              ; timeout reading
.e481	4c 2a e4	jmp $e42a	          JMP IEC_Error
.e484	a2 08		ldx #$08	ACPTR_30  LDX #8 ; 8 bits to read
.e486	ad 0d dc	lda $dc0d	ACPTR_35  LDA CIA1_ICR
.e489	29 08		and #$08	          AND #%00001000     ; $08 fast IEC ?
.e48b	d0 28		bne $e4b5	          BNE ACPTR_60        ; -> fast IEC device
.e48d	ad 00 dd	lda $dd00	ACPTR_40  LDA CIA2_PRA
.e490	cd 00 dd	cmp $dd00	          CMP CIA2_PRA
.e493	d0 f8		bne $e48d	          BNE ACPTR_40        ; -> debounce
.e495	0a		asl a		          ASL A               ; CLOCK IN -> bit 7
.e496	10 ee		bpl $e486	          BPL ACPTR_35        ; -> OK
.e498	66 a4		ror $a4		ACPTR_45  ROR BSOUR1          ; store bit in BSOUR1
.e49a	ad 00 dd	lda $dd00	ACPTR_50  LDA CIA2_PRA
.e49d	cd 00 dd	cmp $dd00	          CMP CIA2_PRA
.e4a0	d0 f8		bne $e49a	          BNE ACPTR_50        ; -> debounce
.e4a2	0a		asl a		          ASL A               ; CLOCK IN -> bit 7
.e4a3	30 f5		bmi $e49a	          BMI ACPTR_50        ; -> wait for CLOCK IN high
.e4a5	ca		dex		          DEX
.e4a6	f0 17		beq $e4bf	          BEQ ACPTR_65        ; -> all 8 bits read
.e4a8	ad 00 dd	lda $dd00	ACPTR_55  LDA CIA2_PRA
.e4ab	cd 00 dd	cmp $dd00	          CMP CIA2_PRA
.e4ae	d0 f8		bne $e4a8	          BNE ACPTR_55        ; -> debounce
.e4b0	0a		asl a		          ASL A               ; CLOCK IN -> bit 7
.e4b1	10 f5		bpl $e4a8	          BPL ACPTR_55        ; -> wait for CLOCK IN low
.e4b3	30 e3		bmi $e498	          BMI ACPTR_45        ; always
.e4b5	ad 0c dc	lda $dc0c	ACPTR_60  LDA CIA1_SDR        ; data register
.e4b8	85 a4		sta $a4		          STA BSOUR1          ; received byte
.e4ba	a9 c0		lda #$c0	          LDA #$c0            ; fast serial and burst mode enabled
.e4bc	8d 1c 0a	sta $0a1c	          STA Fast_IEC        ; store flags
.e4bf	68		pla		ACPTR_65  PLA
.e4c0	aa		tax		          TAX                 ; restore X
.e4c1	20 60 e5	jsr $e560	          JSR IEC_Data_Out_Low
.e4c4	24 90		bit $90		          BIT STATUS
.e4c6	50 03		bvc $e4cb	          BVC ACPTR_70        ; -> branch on EOI = 0
.e4c8	20 38 e5	jsr $e538	          JSR IEC_CLOCK_DATA_OUT_High
.e4cb	20 9f e5	jsr $e59f	ACPTR_70  JSR Enable_IRQ_and_Sprites
.e4ce	a5 a4		lda $a4		          LDA BSOUR1          ; return result in A
.e4d0	18		clc		          CLC                 ; clear carry -> OK
.e4d1	60		rts		          RTS
.e4d2					  SECND
.e4d2	85 95		sta $95		          STA BSOUR
.e4d4	20 7c e3	jsr $e37c	          JSR IEC_Send_With_ATN
.e4d7					  IEC_ATN_OUT_High
.e4d7	ad 00 dd	lda $dd00	          LDA CIA2_PRA
.e4da	29 f7		and #$f7	          AND #%11110111     ; $f7 ATN OUT high
.e4dc	8d 00 dd	sta $dd00	          STA CIA2_PRA
.e4df	60		rts		          RTS
.e4e0					  TKSA
.e4e0	85 95		sta $95		          STA BSOUR
.e4e2	20 7c e3	jsr $e37c	          JSR IEC_Send_With_ATN
.e4e5	24 90		bit $90		          BIT STATUS
.e4e7	30 4c		bmi $e535	          BMI UNLSN_10           ; branch on device not present
.e4e9					  IEC_ATN_High_Exit
.e4e9	20 73 e5	jsr $e573	          JSR Disable_IRQ_and_Sprites
.e4ec	20 60 e5	jsr $e560	          JSR IEC_Data_Out_Low
.e4ef	20 d7 e4	jsr $e4d7	          JSR IEC_ATN_OUT_High
.e4f2	20 45 e5	jsr $e545	          JSR IEC_Clock_High
.e4f5	ad 00 dd	lda $dd00	IAHE_10   LDA CIA2_PRA
.e4f8	cd 00 dd	cmp $dd00	          CMP CIA2_PRA
.e4fb	d0 f8		bne $e4f5	          BNE IAHE_10
.e4fd	0a		asl a		          ASL A
.e4fe	30 f5		bmi $e4f5	          BMI IAHE_10
.e500	4c 9f e5	jmp $e59f	          JMP Enable_IRQ_and_Sprites
.e503					  CIOUT
.e503	24 94		bit $94		          BIT C3PO            ; data in buffer ?
.e505	30 05		bmi $e50c	          BMI CIOUT_10        ; -> yes
.e507	38		sec		          SEC
.e508	66 94		ror $94		          ROR C3PO            ; set flag: data in buffer
.e50a	d0 05		bne $e511	          BNE CIOUT_20        ; always
.e50c	48		pha		CIOUT_10  PHA                 ; save new data byte
.e50d	20 8c e3	jsr $e38c	          JSR IEC_Send_Byte   ; send buffered byte
.e510	68		pla		          PLA                 ; restore new data byte
.e511	85 95		sta $95		CIOUT_20  STA BSOUR           ; store in buffer
.e513	18		clc		          CLC                 ; OK
.e514	60		rts		          RTS
.e515					  UNTLK
.e515	20 73 e5	jsr $e573	          JSR Disable_IRQ_and_Sprites
.e518	20 4e e5	jsr $e54e	          JSR IEC_Clock_Low
.e51b	ad 00 dd	lda $dd00	          LDA CIA2_PRA
.e51e	09 08		ora #$08	          ORA #%00001000     ; $08
.e520	8d 00 dd	sta $dd00	          STA CIA2_PRA
.e523	a9 5f		lda #$5f	          LDA #$5f            ; UNTALK value
>e525	2c				          .byte $2c ;BIT
.e526					  UNLSN
.e526	a9 3f		lda #$3f	          LDA #$3f            ; UNLISTEN value
.e528	48		pha		          PHA
.e529	ad 1c 0a	lda $0a1c	          LDA Fast_IEC
.e52c	29 7f		and #$7f	          AND #%01111111     ; $7f clear fast IEC flag
.e52e	8d 1c 0a	sta $0a1c	          STA Fast_IEC
.e531	68		pla		          PLA
.e532	20 43 e3	jsr $e343	          JSR Talk_Listen
.e535	20 d7 e4	jsr $e4d7	UNLSN_10  JSR IEC_ATN_OUT_High
.e538					  IEC_CLOCK_DATA_OUT_High
.e538	8a		txa		          TXA
.e539	a2 0a		ldx #$0a	          LDX #10
.e53b	ca		dex		ICDO_10   DEX
.e53c	d0 fd		bne $e53b	          BNE ICDO_10
.e53e	aa		tax		          TAX
.e53f	20 45 e5	jsr $e545	          JSR IEC_Clock_High
.e542	4c 57 e5	jmp $e557	          JMP IEC_Data_Out_High
.e545					  IEC_Clock_High
.e545	ad 00 dd	lda $dd00	          LDA CIA2_PRA
.e548	29 ef		and #$ef	          AND #%11101111 ; $ef
.e54a	8d 00 dd	sta $dd00	          STA CIA2_PRA
.e54d	60		rts		          RTS
.e54e					  IEC_Clock_Low
.e54e	ad 00 dd	lda $dd00	          LDA CIA2_PRA
.e551	09 10		ora #$10	          ORA #%00010000 ; $10
.e553	8d 00 dd	sta $dd00	          STA CIA2_PRA
.e556	60		rts		          RTS
.e557					  IEC_Data_Out_High
.e557	ad 00 dd	lda $dd00	          LDA CIA2_PRA
.e55a	29 df		and #$df	          AND #%11011111 ; $df
.e55c	8d 00 dd	sta $dd00	          STA CIA2_PRA
.e55f	60		rts		          RTS
.e560					  IEC_Data_Out_Low
.e560	ad 00 dd	lda $dd00	          LDA CIA2_PRA
.e563	09 20		ora #$20	          ORA #%00100000 ; $20
.e565	8d 00 dd	sta $dd00	          STA CIA2_PRA
.e568	60		rts		          RTS
.e569					  IEC_Clock_Data_In
.e569	ad 00 dd	lda $dd00	          LDA CIA2_PRA
.e56c	cd 00 dd	cmp $dd00	          CMP CIA2_PRA
.e56f	d0 f8		bne $e569	          BNE IEC_Clock_Data_In
.e571	0a		asl a		          ASL A
.e572	60		rts		          RTS
.e573					  Disable_IRQ_and_Sprites
.e573	78		sei		          SEI
.e574					  Disable_Sprites
.e574	2c 3a 0a	bit $0a3a	          BIT SPRITES
.e577	30 25		bmi $e59e	          BMI DiSp_Ret
.e579	2c 37 0a	bit $0a37	          BIT VSH_SPEED
.e57c	30 20		bmi $e59e	          BMI DiSp_Ret
.e57e	ad 30 d0	lda $d030	          LDA VIC_SPEED
.e581	8d 37 0a	sta $0a37	          STA VSH_SPEED
.e584	ad 15 d0	lda $d015	          LDA VIC_SPR_ENA
.e587	8d 38 0a	sta $0a38	          STA VSH_SPR_ENA
.e58a	a9 00		lda #$00	          LDA #0
.e58c	8d 15 d0	sta $d015	          STA VIC_SPR_ENA
.e58f	8d 30 d0	sta $d030	          STA VIC_SPEED
.e592	ad 38 0a	lda $0a38	          LDA VSH_SPR_ENA
.e595	f0 07		beq $e59e	          BEQ DiSp_Ret
.e597	8a		txa		          TXA
.e598	a2 00		ldx #$00	          LDX #0
.e59a	ca		dex		DiSp_10   DEX ; wait loop
.e59b	d0 fd		bne $e59a	          BNE DiSp_10
.e59d	aa		tax		          TAX
.e59e	60		rts		DiSp_Ret  RTS
.e59f					  Enable_IRQ_and_Sprites
.e59f	2c 3a 0a	bit $0a3a	          BIT SPRITES
.e5a2	30 16		bmi $e5ba	          BMI EnSp_10
.e5a4	2c 37 0a	bit $0a37	          BIT VSH_SPEED
.e5a7	10 11		bpl $e5ba	          BPL EnSp_10
.e5a9	ad 38 0a	lda $0a38	          LDA VSH_SPR_ENA
.e5ac	8d 15 d0	sta $d015	          STA VIC_SPR_ENA
.e5af	ad 37 0a	lda $0a37	          LDA VSH_SPEED
.e5b2	8d 30 d0	sta $d030	          STA VIC_SPEED
.e5b5	a9 00		lda #$00	          LDA #0
.e5b7	8d 37 0a	sta $0a37	          STA VSH_SPEED
.e5ba	58		cli		EnSp_10   CLI
.e5bb	60		rts		          RTS
.e5bc					  IEC_Wait_Ready
.e5bc	ad 0d dc	lda $dc0d	          LDA CIA1_ICR
.e5bf	29 08		and #$08	          AND #%00001000 ; $08
.e5c1	f0 f9		beq $e5bc	          BEQ IEC_Wait_Ready
.e5c3					  IEC_Fast_Input
.e5c3	ad 0e dc	lda $dc0e	          LDA CIA1_CRA
.e5c6	29 80		and #$80	          AND #%10000000 ; $80 save TOD flag
.e5c8	09 08		ora #$08	          ORA #%00001000 ; $08 set ONE SHOT flag
.e5ca	8d 0e dc	sta $dc0e	          STA CIA1_CRA
.e5cd	ad 05 d5	lda $d505	          LDA MMU_MODE
.e5d0	29 f7		and #$f7	          AND #%11110111 ; $f7 fast serial direction input
.e5d2	8d 05 d5	sta $d505	          STA MMU_MODE
.e5d5	60		rts		          RTS
.e5d6					  IEC_Fast_Output
.e5d6	ad 05 d5	lda $d505	          LDA MMU_MODE
.e5d9	09 08		ora #$08	          ORA #%00001000     ; $08 Fast IEC direction output
.e5db	8d 05 d5	sta $d505	          STA MMU_MODE
.e5de	a9 7f		lda #$7f	          LDA #$7f
.e5e0	8d 0d dc	sta $dc0d	          STA CIA1_ICR        ; disable IRQ's
.e5e3	a9 00		lda #$00	          LDA #0
.e5e5	8d 05 dc	sta $dc05	          STA CIA1_TAHI
.e5e8	a9 04		lda #$04	          LDA #4
.e5ea	8d 04 dc	sta $dc04	          STA CIA1_TALO       ; set timer A to 4 (PHI2)
.e5ed	ad 0e dc	lda $dc0e	          LDA CIA1_CRA
.e5f0	29 80		and #$80	          AND #%10000000     ; $80
.e5f2	09 55		ora #$55	          ORA #%01010101     ; $55
.e5f4	8d 0e dc	sta $dc0e	          STA CIA1_CRA
.e5f7	2c 0d dc	bit $dc0d	          BIT CIA1_ICR        ; reset IRQ flags
.e5fa	60		rts		          RTS
.e5fb					  SPINIO
.e5fb	90 c6		bcc $e5c3	          BCC IEC_Fast_Input
.e5fd	b0 d7		bcs $e5d6	          BCS IEC_Fast_Output
.e5ff					  RS_NMI_Send
.e5ff	a5 b4		lda $b4		          LDA RS_Count        ; # of data bits to send
.e601	f0 47		beq $e64a	          BEQ RS_Send_Next_Byte
.e603	30 3f		bmi $e644	          BMI RNS_90          ; -> send STOP bit
.e605	46 b6		lsr $b6		          LSR RS_Out          ; next bit to carry
.e607	a2 00		ldx #$00	          LDX #0              ; $00 for bit 0
.e609	90 01		bcc $e60c	          BCC RNS_10
.e60b	ca		dex		          DEX                 ; $ff for bit 1
.e60c	8a		txa		RNS_10    TXA
.e60d	45 bd		eor $bd		          EOR RS_Parity       ; update parity
.e60f	85 bd		sta $bd		          STA RS_Parity       ; store  parity
.e611	c6 b4		dec $b4		          DEC RS_Count
.e613	f0 06		beq $e61b	          BEQ RNS_30          ; -> parity check
.e615	8a		txa		RNS_20    TXA
.e616	29 04		and #$04	          AND #%00000100     ; $04 bit 2 = transfer position
.e618	85 b5		sta $b5		          STA RS_Next
.e61a	60		rts		          RTS
.e61b	a9 20		lda #$20	RNS_30    LDA #%00100000     ; $20 ODD parity
.e61d	2c 11 0a	bit $0a11	          BIT RS_Command
.e620	f0 14		beq $e636	          BEQ RNS_60          ; -> NO parity
.e622	30 1c		bmi $e640	          BMI RNS_80          ; -> MARK or SPACE parity
.e624	70 14		bvs $e63a	          BVS RNS_70          ; -> EVEN parity
.e626	a5 bd		lda $bd		          LDA RS_Parity
.e628	d0 01		bne $e62b	          BNE RNS_50
.e62a	ca		dex		RNS_40    DEX
.e62b	c6 b4		dec $b4		RNS_50    DEC RS_Count
.e62d	ad 10 0a	lda $0a10	          LDA RS_Control
.e630	10 e3		bpl $e615	          BPL RNS_20
.e632	c6 b4		dec $b4		          DEC RS_Count
.e634	d0 df		bne $e615	          BNE RNS_20
.e636	e6 b4		inc $b4		RNS_60    INC RS_Count
.e638	d0 f0		bne $e62a	          BNE RNS_40          ; always
.e63a	a5 bd		lda $bd		RNS_70    LDA RS_Parity       ; EVEN parity
.e63c	f0 ed		beq $e62b	          BEQ RNS_50          ; -> is EVEN  -> send 0
.e63e	d0 ea		bne $e62a	          BNE RNS_40          ; -> is ODD   -> send 1
.e640	70 e9		bvs $e62b	RNS_80    BVS RNS_50          ; -> is MARK  -> send 1
.e642	50 e6		bvc $e62a	          BVC RNS_40          ; -> is SPACE -> send 0
.e644	e6 b4		inc $b4		RNS_90    INC RS_Count        ; RS_Count = 0
.e646	a2 ff		ldx #$ff	          LDX #$ff            ; -> send 1 STOP bit
.e648	d0 cb		bne $e615	          BNE RNS_20          ; always
.e64a					  RS_Send_Next_Byte
.e64a	ad 11 0a	lda $0a11	          LDA RS_Command
.e64d	4a		lsr a		          LSR A
.e64e	90 07		bcc $e657	          BCC RSNB_10         ; -> 3-wire communication
.e650	2c 01 dd	bit $dd01	          BIT CIA2_PRB
.e653	10 1d		bpl $e672	          BPL RSNB_20         ; -> error: missing DSR
.e655	50 1e		bvc $e675	          BVC RSNB_30         ; -> error: missing CTS
.e657	a9 00		lda #$00	RSNB_10   LDA #0
.e659	85 bd		sta $bd		          STA RS_Parity
.e65b	85 b5		sta $b5		          STA RS_Next
.e65d	ae 15 0a	ldx $0a15	          LDX RS_Bits
.e660	86 b4		stx $b4		          STX RS_Count        ; initialize bit counter
.e662	ac 1a 0a	ldy $0a1a	          LDY RS_OBP_Beg
.e665	cc 1b 0a	cpy $0a1b	          CPY RS_OBP_End      ; compare buffer pointer
.e668	f0 13		beq $e67d	          BEQ RSNB_40         ; -> buffer is empty
.e66a	b1 ca		lda ($ca),y	          LDA (ROBUF),Y       ; fetch next byte from buffer
.e66c	85 b6		sta $b6		          STA RS_Out          ; store it into transmitter buffer
.e66e	ee 1a 0a	inc $0a1a	          INC RS_OBP_Beg      ; update buffer pointer
.e671	60		rts		          RTS
.e672	a9 40		lda #$40	RSNB_20   LDA #$40            ; missing DSR
>e674	2c				          .byte $2c ;BIT
.e675	a9 10		lda #$10	RSNB_30   LDA #16             ; missing CTS
.e677	0d 14 0a	ora $0a14	          ORA RS_Status
.e67a	8d 14 0a	sta $0a14	          STA RS_Status       ; set error bit
.e67d	a9 01		lda #$01	RSNB_40   LDA #1              ; start TIMER A
.e67f					  Set_CIA2_Interrupt
.e67f	8d 0d dd	sta $dd0d	          STA CIA2_ICR
.e682	4d 0f 0a	eor $0a0f	          EOR RS_Enable
.e685	09 80		ora #$80	          ORA #%10000000 ; $80
.e687	8d 0f 0a	sta $0a0f	          STA RS_Enable
.e68a	8d 0d dd	sta $dd0d	          STA CIA2_ICR
.e68d	60		rts		          RTS
.e68e					  RS_Set_Databits
.e68e	a2 09		ldx #$09	          LDX #9              ; databits + 1
.e690	a9 20		lda #$20	          LDA #%00100000     ; check bit 5
.e692	2c 10 0a	bit $0a10	          BIT RS_Control
.e695	f0 01		beq $e698	          BEQ RSSD_10
.e697	ca		dex		          DEX                 ; X = 8
.e698	50 02		bvc $e69c	RSSD_10   BVC RSSD_Ret
.e69a	ca		dex		          DEX
.e69b	ca		dex		          DEX
.e69c	60		rts		RSSD_Ret  RTS
.e69d					  RS_NMI_Receive
.e69d	a6 a9		ldx $a9		          LDX RSI_Start
.e69f	d0 33		bne $e6d4	          BNE RSNR_30         ; -> get start bit
.e6a1	c6 a8		dec $a8		          DEC RSI_Count
.e6a3	f0 3a		beq $e6df	          BEQ RSNR_35         ; -> byte complete
.e6a5	30 0d		bmi $e6b4	          BMI RSNR_20         ; -> get stop bit
.e6a7	a5 a7		lda $a7		          LDA RSI_In_Bit
.e6a9	45 ab		eor $ab		          EOR RSI_Parity
.e6ab	85 ab		sta $ab		          STA RSI_Parity      ; update parity
.e6ad	46 a7		lsr $a7		          LSR RSI_In_Bit
.e6af	66 aa		ror $aa		          ROR RSI_Data        ; rotate into data byte
.e6b1	60		rts		RSNR_10   RTS
.e6b2	c6 a8		dec $a8		RSNR_15   DEC RSI_Count
.e6b4	a5 a7		lda $a7		RSNR_20   LDA RSI_In_Bit      ; stop bit
.e6b6	f0 6b		beq $e723	          BEQ RSNR_70         ; -> BREAK or error
.e6b8	ad 10 0a	lda $0a10	          LDA RS_Control
.e6bb	0a		asl a		          ASL A               ; C=1 -> 2 stop bits
.e6bc	a9 01		lda #$01	          LDA #1              ; # of stop bits
.e6be	65 a8		adc $a8		          ADC RSI_Count
.e6c0	d0 ef		bne $e6b1	          BNE RSNR_10         ; -> return
.e6c2	a9 90		lda #$90	RSNR_25   LDA #$90            ; IRQ enable & RS232
.e6c4	8d 0d dd	sta $dd0d	          STA CIA2_ICR
.e6c7	0d 0f 0a	ora $0a0f	          ORA RS_Enable
.e6ca	8d 0f 0a	sta $0a0f	          STA RS_Enable
.e6cd	85 a9		sta $a9		          STA RSI_Start
.e6cf	a9 02		lda #$02	          LDA #2
.e6d1	4c 7f e6	jmp $e67f	          JMP Set_CIA2_Interrupt
.e6d4	a5 a7		lda $a7		RSNR_30   LDA RSI_In_Bit
.e6d6	d0 ea		bne $e6c2	          BNE RSNR_25         ; -> no start bit: reinitialize
.e6d8	85 a9		sta $a9		          STA RSI_Start
.e6da	a9 01		lda #$01	          LDA #1
.e6dc	85 ab		sta $ab		          STA RSI_Parity
.e6de	60		rts		          RTS
.e6df	ac 18 0a	ldy $0a18	RSNR_35   LDY RS_IBP_End
.e6e2	c8		iny		          INY
.e6e3	cc 19 0a	cpy $0a19	          CPY RS_IBP_Beg      ; compare buffer pointers
.e6e6	f0 2a		beq $e712	          BEQ RSNR_55         ; -> error: input buffer overflow
.e6e8	8c 18 0a	sty $0a18	          STY RS_IBP_End
.e6eb	88		dey		          DEY
.e6ec	a5 aa		lda $aa		          LDA RSI_Data        ; received byte
.e6ee	ae 15 0a	ldx $0a15	          LDX RS_Bits
.e6f1	e0 09		cpx #$09	RSNR_40   CPX #9
.e6f3	f0 04		beq $e6f9	          BEQ RSNR_45         ; -> byte in correct position
.e6f5	4a		lsr a		          LSR A               ; bitlengths < 8 need more shifts
.e6f6	e8		inx		          INX
.e6f7	d0 f8		bne $e6f1	          BNE RSNR_40
.e6f9	91 c8		sta ($c8),y	RSNR_45   STA (RIBUF),Y       ; store received byte in buffer
.e6fb	a9 20		lda #$20	          LDA #$20
.e6fd	2c 11 0a	bit $0a11	          BIT RS_Command      ; test parity
.e700	f0 b0		beq $e6b2	          BEQ RSNR_15         ; -> NO parity
.e702	30 ad		bmi $e6b1	          BMI RSNR_10         ; -> fixed parity: ignore
.e704	a5 a7		lda $a7		          LDA RSI_In_Bit
.e706	45 ab		eor $ab		          EOR RSI_Parity
.e708	f0 03		beq $e70d	          BEQ RSNR_50         ; -> check ODD parity
.e70a	70 a5		bvs $e6b1	          BVS RSNR_10         ; -> EVEN parity -> OK
>e70c	2c				          .byte $2c ;BIT
.e70d	50 a2		bvc $e6b1	RSNR_50   BVC RSNR_10         ; -> ODD parity -> OK
.e70f	a9 01		lda #$01	          LDA #1              ; error: parity
>e711	2c				          .byte $2c ;BIT
.e712	a9 04		lda #$04	RSNR_55   LDA #4              ; error: input buffer overflow
>e714	2c				          .byte $2c ;BIT
.e715	a9 80		lda #$80	RSNR_60   LDA #$80            ; error: BREAK
>e717	2c				          .byte $2c ;BIT
.e718	a9 02		lda #$02	RSNR_65   LDA #2              ; error: frame
.e71a	0d 14 0a	ora $0a14	          ORA RS_Status
.e71d	8d 14 0a	sta $0a14	          STA RS_Status
.e720	4c c2 e6	jmp $e6c2	          JMP RSNR_25
.e723	a5 aa		lda $aa		RSNR_70   LDA RSI_Data        ; BREAK or frame error
.e725	d0 f1		bne $e718	          BNE RSNR_65
.e727	f0 ec		beq $e715	          BEQ RSNR_60
.e729					  RS_CKOUT
.e729	85 9a		sta $9a		          STA DFLTO           ; output channel = 2
.e72b	ad 11 0a	lda $0a11	          LDA RS_Command
.e72e	4a		lsr a		          LSR A
.e72f	90 29		bcc $e75a	          BCC RSDM_10         ; -> 3-wire handshake
.e731	a9 02		lda #$02	          LDA #2
.e733	2c 01 dd	bit $dd01	          BIT CIA2_PRB
.e736	10 1d		bpl $e755	          BPL RS_DSR_Missing
.e738	d0 20		bne $e75a	          BNE RSDM_10         ; always
.e73a	ad 0f 0a	lda $0a0f	RSCO_10   LDA RS_Enable
.e73d	29 02		and #$02	          AND #%00000010     ; $02 TIMER B
.e73f	d0 f9		bne $e73a	          BNE RSCO_10
.e741	2c 01 dd	bit $dd01	RSCO_20   BIT CIA2_PRB
.e744	70 fb		bvs $e741	          BVS RSCO_20
.e746	ad 01 dd	lda $dd01	          LDA CIA2_PRB
.e749	09 02		ora #$02	          ORA #%00000010 ; $02
.e74b	8d 01 dd	sta $dd01	          STA CIA2_PRB
.e74e	2c 01 dd	bit $dd01	RSCO_30   BIT CIA2_PRB
.e751	70 07		bvs $e75a	          BVS RSDM_10
.e753	30 f9		bmi $e74e	          BMI RSCO_30
.e755					  RS_DSR_Missing
.e755	a9 40		lda #$40	          LDA #$40
.e757	8d 14 0a	sta $0a14	          STA RS_Status
.e75a	18		clc		RSDM_10   CLC
.e75b	60		rts		          RTS
.e75c	20 70 e7	jsr $e770	RSW_00    JSR RS_Start_Baud
.e75f					  RS_Write
.e75f	ac 1b 0a	ldy $0a1b	          LDY RS_OBP_End
.e762	c8		iny		          INY
.e763	cc 1a 0a	cpy $0a1a	          CPY RS_OBP_Beg      ; compare buffer pointer
.e766	f0 f4		beq $e75c	          BEQ RSW_00          ; -> buffer full: wait
.e768	8c 1b 0a	sty $0a1b	          STY RS_OBP_End
.e76b	88		dey		          DEY
.e76c	a5 9e		lda $9e		          LDA PTR_LO
.e76e	91 ca		sta ($ca),y	          STA (ROBUF),Y       ; store byte into send buffer
.e770					  RS_Start_Baud
.e770	ad 0f 0a	lda $0a0f	          LDA RS_Enable
.e773	4a		lsr a		          LSR A
.e774	b0 1e		bcs $e794	          BCS RSSB_Ret        ; RS 232 output is active
.e776	a9 10		lda #$10	          LDA #16
.e778	8d 0e dd	sta $dd0e	          STA CIA2_CRA        ;
.e77b	ad 16 0a	lda $0a16	          LDA RS_Timer_Lo
.e77e	8d 04 dd	sta $dd04	          STA CIA2_TALO
.e781	ad 17 0a	lda $0a17	          LDA RS_Timer_Hi
.e784	8d 05 dd	sta $dd05	          STA CIA2_TAHI
.e787	a9 81		lda #$81	          LDA #$81
.e789	20 7f e6	jsr $e67f	          JSR Set_CIA2_Interrupt
.e78c	20 4a e6	jsr $e64a	          JSR RS_Send_Next_Byte
.e78f	a9 11		lda #$11	          LDA #$11            ; clear RS232 received & TIMER A
.e791	8d 0e dd	sta $dd0e	          STA CIA2_CRA
.e794	60		rts		RSSB_Ret  RTS
.e795					  RS_CHKIN
.e795	85 99		sta $99		          STA DFLTN           ; default input channel = 2
.e797	ad 11 0a	lda $0a11	          LDA RS_Command
.e79a	4a		lsr a		          LSR A
.e79b	90 28		bcc $e7c5	          BCC RSCI_40         ; -> 3-wire handshake
.e79d	29 08		and #$08	          AND #%00001000     ; $08
.e79f	f0 24		beq $e7c5	          BEQ RSCI_40         ; -> full duplex
.e7a1	a9 02		lda #$02	          LDA #2
.e7a3	2c 01 dd	bit $dd01	          BIT CIA2_PRB
.e7a6	10 ad		bpl $e755	          BPL RS_DSR_Missing
.e7a8	f0 22		beq $e7cc	          BEQ RSCI_50         ; RTS missing
.e7aa	ad 0f 0a	lda $0a0f	RSCI_10   LDA RS_Enable
.e7ad	4a		lsr a		          LSR A
.e7ae	b0 fa		bcs $e7aa	          BCS RSCI_10         ; wait send completion
.e7b0	ad 01 dd	lda $dd01	          LDA CIA2_PRB
.e7b3	29 fd		and #$fd	          AND #%11111101     ; $fd RTS request to send
.e7b5	8d 01 dd	sta $dd01	          STA CIA2_PRB
.e7b8	ad 01 dd	lda $dd01	RSCI_20   LDA CIA2_PRB
.e7bb	29 04		and #$04	          AND #%00000100     ; $04
.e7bd	f0 f9		beq $e7b8	          BEQ RSCI_20
.e7bf	a9 90		lda #$90	RSCI_30   LDA #$90
.e7c1	18		clc		          CLC
.e7c2	4c 7f e6	jmp $e67f	          JMP Set_CIA2_Interrupt
.e7c5	ad 0f 0a	lda $0a0f	RSCI_40   LDA RS_Enable
.e7c8	29 12		and #$12	          AND #%00010010 ; $12
.e7ca	f0 f3		beq $e7bf	          BEQ RSCI_30
.e7cc	18		clc		RSCI_50   CLC
.e7cd	60		rts		          RTS
.e7ce					  RS_Read
.e7ce	ad 14 0a	lda $0a14	          LDA RS_Status
.e7d1	ac 19 0a	ldy $0a19	          LDY RS_IBP_Beg
.e7d4	cc 18 0a	cpy $0a18	          CPY RS_IBP_End
.e7d7	f0 0b		beq $e7e4	          BEQ RSR_10          ; -> buffer empty
.e7d9	29 f7		and #$f7	          AND #%11110111 ; $f7
.e7db	8d 14 0a	sta $0a14	          STA RS_Status
.e7de	b1 c8		lda ($c8),y	          LDA (RIBUF),Y       ; load byte from buffer
.e7e0	ee 19 0a	inc $0a19	          INC RS_IBP_Beg
.e7e3	60		rts		          RTS
.e7e4	09 08		ora #$08	RSR_10    ORA #%00001000 ; $08
.e7e6	8d 14 0a	sta $0a14	          STA RS_Status
.e7e9	a9 00		lda #$00	          LDA #0
.e7eb	60		rts		          RTS
.e7ec					  RS232_Stop
.e7ec	48		pha		          PHA
.e7ed	ad 0f 0a	lda $0a0f	          LDA RS_Enable
.e7f0	f0 11		beq $e803	          BEQ RSS_20
.e7f2	ad 0f 0a	lda $0a0f	RSS_10    LDA RS_Enable
.e7f5	29 03		and #$03	          AND #%00000011 ; $03
.e7f7	d0 f9		bne $e7f2	          BNE RSS_10
.e7f9	a9 10		lda #$10	          LDA #16
.e7fb	8d 0d dd	sta $dd0d	          STA CIA2_ICR
.e7fe	a9 00		lda #$00	          LDA #0
.e800	8d 0f 0a	sta $0a0f	          STA RS_Enable
.e803	68		pla		RSS_20    PLA
.e804	60		rts		          RTS
.e805					  RS_NMI_Main
.e805	98		tya		          TYA                 ; A = CIA2_ICR
.e806	2d 0f 0a	and $0a0f	          AND RS_Enable
.e809	aa		tax		          TAX
.e80a	29 01		and #$01	          AND #%00000001
.e80c	f0 28		beq $e836	          BEQ RSNM_30         ; -> IRQ TIMER B
.e80e	ad 00 dd	lda $dd00	          LDA CIA2_PRA
.e811	29 fb		and #$fb	          AND #%11111011     ; $fb
.e813	05 b5		ora $b5		          ORA RS_Next         ; next bit to send at pos 2
.e815	8d 00 dd	sta $dd00	          STA CIA2_PRA        ; sed next bit
.e818	ad 0f 0a	lda $0a0f	          LDA RS_Enable
.e81b	8d 0d dd	sta $dd0d	          STA CIA2_ICR
.e81e	8a		txa		          TXA
.e81f	29 12		and #$12	          AND #%00010010     ; RS232 input & TIMER B
.e821	f0 0d		beq $e830	          BEQ RSNM_20
.e823	29 02		and #$02	          AND #%00000010     ; TIMER B
.e825	f0 06		beq $e82d	          BEQ RSNM_10         ; -> no TIMER B IRQ
.e827	20 78 e8	jsr $e878	          JSR RS_NMI_Get_Bit
.e82a	4c 30 e8	jmp $e830	          JMP RSNM_20
.e82d	20 a9 e8	jsr $e8a9	RSNM_10   JSR RS_NMI_Put_Bit
.e830	20 ff e5	jsr $e5ff	RSNM_20   JSR RS_NMI_Send
.e833	4c 49 e8	jmp $e849	          JMP RSNM_50
.e836	8a		txa		RSNM_30   TXA
.e837	29 02		and #$02	          AND #%00000010 ; $02
.e839	f0 06		beq $e841	          BEQ RSNM_40
.e83b	20 78 e8	jsr $e878	          JSR RS_NMI_Get_Bit
.e83e	4c 49 e8	jmp $e849	          JMP RSNM_50
.e841	8a		txa		RSNM_40   TXA
.e842	29 10		and #$10	          AND #%00010000 ; $10
.e844	f0 03		beq $e849	          BEQ RSNM_50
.e846	20 a9 e8	jsr $e8a9	          JSR RS_NMI_Put_Bit
.e849	ad 0f 0a	lda $0a0f	RSNM_50   LDA RS_Enable
.e84c	8d 0d dd	sta $dd0d	          STA CIA2_ICR
.e84f	60		rts		          RTS
.e850					  RS_Baud_NTSC
>e850	c1 27				          .WORD $27c1 ; 10177    50   Baud  1.027.700
>e852	3e 1a				          .WORD $1a3e ;  6718    75   Baud  1.022.700
>e854	c5 11				          .WORD $11c5 ;  4549   110   Baud  1.022.780
>e856	74 0e				          .WORD $0e74 ;  3700   134.5 Baud  1.022.200
>e858	ed 0c				          .WORD $0ced ;  3309   150   Baud  1.022.700
>e85a	45 06				          .WORD $0645 ;  1605   300   Baud  1.023.000
>e85c	f0 02				          .WORD $02f0 ;   752   600   Baud  1.022.400
>e85e	46 01				          .WORD $0146 ;   326  1200   Baud  1.022.400
>e860	b8 00				          .WORD $00b8 ;   184  1800   Baud  1.022.400
>e862	71 00				          .WORD $0071 ;   113  2400   Baud  1.022.400
.e864					  RS_Baud_PAL
>e864	19 26				          .WORD $2619 ;  9753    50   Baud
>e866	44 19				          .WORD $1944 ;  6468    75   Baud
>e868	1a 11				          .WORD $111a ;  4378   110   Baud
>e86a	e8 0d				          .WORD $0de8 ;  3560   134.5 Baud
>e86c	70 0c				          .WORD $0c70 ;  3184   150   Baud
>e86e	06 06				          .WORD $0606 ;  1542   300   Baud
>e870	d1 02				          .WORD $02d1 ;   721   600   Baud
>e872	37 01				          .WORD $0137 ;   311  1200   Baud
>e874	ae 00				          .WORD $00ae ;   174  1800   Baud
>e876	69 00				          .WORD $0069 ;   105  2400   Baud
.e878					  RS_NMI_Get_Bit
.e878	ad 01 dd	lda $dd01	          LDA CIA2_PRB
.e87b	29 01		and #$01	          AND #1
.e87d	85 a7		sta $a7		          STA RSI_In_Bit      ; received data bit
.e87f	ad 06 dd	lda $dd06	          LDA CIA2_TBLO       ; reprogram TIMER B latch
.e882	e9 28		sbc #$28	          SBC #40             ; B = B - 40 + baudtime
.e884	6d 16 0a	adc $0a16	          ADC RS_Timer_Lo
.e887	8d 06 dd	sta $dd06	          STA CIA2_TBLO
.e88a	ad 07 dd	lda $dd07	          LDA CIA2_TBHI
.e88d	6d 17 0a	adc $0a17	          ADC RS_Timer_Hi
.e890	8d 07 dd	sta $dd07	          STA CIA2_TBHI
.e893	a9 11		lda #$11	          LDA #$11
.e895	8d 0f dd	sta $dd0f	          STA CIA2_CRB        ; start TIMER B from latch
.e898	ad 0f 0a	lda $0a0f	          LDA RS_Enable
.e89b	8d 0d dd	sta $dd0d	          STA CIA2_ICR        ; enable TIMER interrupt
.e89e	a9 ff		lda #$ff	          LDA #$ff
.e8a0	8d 06 dd	sta $dd06	          STA CIA2_TBLO       ; set TIMER B latch to maximum
.e8a3	8d 07 dd	sta $dd07	          STA CIA2_TBHI
.e8a6	4c 9d e6	jmp $e69d	          JMP RS_NMI_Receive
.e8a9					  RS_NMI_Put_Bit
.e8a9	ad 12 0a	lda $0a12	          LDA RS_Baudrate     ; set baudrate
.e8ac	8d 06 dd	sta $dd06	          STA CIA2_TBLO
.e8af	ad 13 0a	lda $0a13	          LDA RS_Baudrate+1
.e8b2	8d 07 dd	sta $dd07	          STA CIA2_TBHI
.e8b5	a9 11		lda #$11	          LDA #$11
.e8b7	8d 0f dd	sta $dd0f	          STA CIA2_CRB        ; start TIMER B from latch
.e8ba	a9 12		lda #$12	          LDA #$12
.e8bc	4d 0f 0a	eor $0a0f	          EOR RS_Enable
.e8bf	8d 0f 0a	sta $0a0f	          STA RS_Enable
.e8c2	a9 ff		lda #$ff	          LDA #$ff
.e8c4	8d 06 dd	sta $dd06	          STA CIA2_TBLO       ; set TIMER B latch to maximum
.e8c7	8d 07 dd	sta $dd07	          STA CIA2_TBHI
.e8ca	ae 15 0a	ldx $0a15	          LDX RS_Bits
.e8cd	86 a8		stx $a8		          STX RSI_Count
.e8cf	60		rts		          RTS
.e8d0					  TAPE_Find_Header
.e8d0	a5 93		lda $93		          LDA K_VERCK         ; get load/verify flag
.e8d2	48		pha		          PHA                 ; save load/verify flag
.e8d3	20 f2 e9	jsr $e9f2	          JSR TAPE_Read_Block
.e8d6	68		pla		          PLA                 ; restore load/verify flag
.e8d7	85 93		sta $93		          STA K_VERCK         ; save load/verify flag
.e8d9	b0 3d		bcs $e918	          BCS TAFH_Ret        ; exit on error
.e8db	a0 00		ldy #$00	          LDY #0
.e8dd	b1 b2		lda ($b2),y	          LDA (TAPE1),Y       ; read first byte from tape buffer
.e8df	c9 05		cmp #$05	          CMP #5              ; EOT (5) = End Of Tape
.e8e1	f0 34		beq $e917	          BEQ TAFH_60         ; exit if end of the tape
.e8e3	c9 01		cmp #$01	          CMP #1              ; header of a relocatable BASIC program ?
.e8e5	f0 08		beq $e8ef	          BEQ TAFH_10         ; branch if program file header
.e8e7	c9 03		cmp #$03	          CMP #3              ; header of a non relocatable program
.e8e9	f0 04		beq $e8ef	          BEQ TAFH_10         ; branch if program file header
.e8eb	c9 04		cmp #$04	          CMP #4              ; header sequential data file
.e8ed	d0 e1		bne $e8d0	          BNE TAPE_Find_Header; continue search
.e8ef	aa		tax		TAFH_10   TAX                 ; X = header type
.e8f0	24 9d		bit $9d		          BIT MSGFLG          ; get message mode flag
.e8f2	10 22		bpl $e916	          BPL TAFH_50         ; exit if control messages off
.e8f4	a0 63		ldy #$63	          LDY #Msg_Found      ; $63 FOUND
.e8f6	20 22 f7	jsr $f722	          JSR System_Message
.e8f9	a0 05		ldy #$05	          LDY #5              ; index to tape filename
.e8fb	b1 b2		lda ($b2),y	TAFH_20   LDA (TAPE1),Y       ; get filename char
.e8fd	20 d2 ff	jsr $ffd2	          JSR K_BSOUT         ; print it
.e900	c8		iny		          INY
.e901	c0 15		cpy #$15	          CPY #21             ; length = 16 from Y=5 to 20
.e903	d0 f6		bne $e8fb	          BNE TAFH_20         ; loop
.e905	a5 a1		lda $a1		          LDA JIFFY_CLOCK+1   ; load medium byte of jiffy clock
.e907	69 02		adc #$02	          ADC #2              ; add 2 (2 * 256 / 60 sec = 8.5 sec)
.e909	a4 91		ldy $91		TAFH_30   LDY STKEY           ; STOP key flag
.e90b	c8		iny		          INY
.e90c	d0 04		bne $e912	          BNE TAFH_40         ; -> STKEY was not $ff : key pressed
.e90e	c5 a1		cmp $a1		          CMP JIFFY_CLOCK+1   ; waittime of 8.5 seconds reached ?
.e910	d0 f7		bne $e909	          BNE TAFH_30         ; -> stay in STOP key wait loop
.e912	c0 f0		cpy #$f0	TAFH_40   CPY #$f0            ; SPACE key ?
.e914	f0 ba		beq $e8d0	          BEQ TAPE_Find_Header; -> skip this file and continue
.e916	18		clc		TAFH_50   CLC                 ; set OK flag
.e917	88		dey		TAFH_60   DEY                 ; compensate INY: Y = STKEY or $ff
.e918	60		rts		TAFH_Ret  RTS                 ; return
.e919					  TAPE_Write_Program_Header
.e919	85 9e		sta $9e		          STA PTR_LO          ; save header type
.e91b	20 80 e9	jsr $e980	          JSR TAPE_XY_Check
.e91e	90 5f		bcc $e97f	          BCC TWPH_Ret        ; don't write to ZP or stack
.e920	a5 c2		lda $c2		          LDA STAH            ; push I/O start address
.e922	48		pha		          PHA
.e923	a5 c1		lda $c1		          LDA STAL
.e925	48		pha		          PHA
.e926	a5 af		lda $af		          LDA EAH             ; push tape end address
.e928	48		pha		          PHA
.e929	a5 ae		lda $ae		          LDA EAL
.e92b	48		pha		          PHA
.e92c	a0 bf		ldy #$bf	          LDY #$bf            ; 191 = index to header end
.e92e	a9 20		lda #$20	          LDA #' '
.e930	91 b2		sta ($b2),y	TWPH_10   STA (TAPE1),Y       ; blank buffer
.e932	88		dey		          DEY
.e933	d0 fb		bne $e930	          BNE TWPH_10
.e935	a5 9e		lda $9e		          LDA PTR_LO          ; header type
.e937	91 b2		sta ($b2),y	          STA (TAPE1),Y       ; write to header 0
.e939	c8		iny		          INY
.e93a	a5 c1		lda $c1		          LDA STAL            ; start address low
.e93c	91 b2		sta ($b2),y	          STA (TAPE1),Y       ; write to header 1
.e93e	c8		iny		          INY
.e93f	a5 c2		lda $c2		          LDA STAH            ; start address high
.e941	91 b2		sta ($b2),y	          STA (TAPE1),Y       ; write to header 2
.e943	c8		iny		          INY
.e944	a5 ae		lda $ae		          LDA EAL             ; end address low
.e946	91 b2		sta ($b2),y	          STA (TAPE1),Y       ; write to header 3
.e948	c8		iny		          INY
.e949	a5 af		lda $af		          LDA EAH             ; end address high
.e94b	91 b2		sta ($b2),y	          STA (TAPE1),Y       ; write to header 4
.e94d	c8		iny		          INY
.e94e	84 9f		sty $9f		          STY PTR_HI          ; save index
.e950	a0 00		ldy #$00	          LDY #0
.e952	84 9e		sty $9e		          STY PTR_LO          ; clear name index
.e954	a4 9e		ldy $9e		TWPH_20   LDY PTR_LO          ; filename index
.e956	c4 b7		cpy $b7		          CPY FNLEN           ; compare with file name length
.e958	f0 0d		beq $e967	          BEQ TWPH_30         ; exit loop if all done
.e95a	20 ae f7	jsr $f7ae	          JSR Get_Filename_Char
.e95d	a4 9f		ldy $9f		          LDY PTR_HI          ; get buffer index
.e95f	91 b2		sta ($b2),y	          STA (TAPE1),Y       ; save file name byte to buffer
.e961	e6 9e		inc $9e		          INC PTR_LO          ; increment file name index
.e963	e6 9f		inc $9f		          INC PTR_HI          ; increment tape buffer index
.e965	d0 ed		bne $e954	          BNE TWPH_20         ; loop, branch always
.e967	20 87 e9	jsr $e987	TWPH_30   JSR TAPE_SAL_EAL
.e96a	a9 69		lda #$69	          LDA #$69            ; set write lead cycle count
.e96c	85 ab		sta $ab		          STA RSI_Parity      ; save write lead cycle count
.e96e	20 1c ea	jsr $ea1c	          JSR TAPE_Write
.e971	a8		tay		          TAY
.e972	68		pla		          PLA
.e973	85 ae		sta $ae		          STA EAL             ; restore load end address
.e975	68		pla		          PLA
.e976	85 af		sta $af		          STA EAH
.e978	68		pla		          PLA
.e979	85 c1		sta $c1		          STA STAL            ; restore load start address
.e97b	68		pla		          PLA
.e97c	85 c2		sta $c2		          STA STAH
.e97e	98		tya		          TYA
.e97f	60		rts		TWPH_Ret  RTS
.e980					  TAPE_XY_Check
.e980	a6 b2		ldx $b2		          LDX TAPE1
.e982	a4 b3		ldy $b3		          LDY TAPE1+1
.e984	c0 02		cpy #$02	          CPY #2
.e986	60		rts		          RTS
.e987					  TAPE_SAL_EAL
.e987	20 80 e9	jsr $e980	          JSR TAPE_XY_Check
.e98a	8a		txa		          TXA
.e98b	85 c1		sta $c1		          STA STAL            ; SAL = TAPE1
.e98d	18		clc		          CLC
.e98e	69 c0		adc #$c0	          ADC #$c0
.e990	85 ae		sta $ae		          STA EAL             ; EAL = TAPE1 + 192
.e992	98		tya		          TYA
.e993	85 c2		sta $c2		          STA STAH
.e995	69 00		adc #$00	          ADC #0
.e997	85 af		sta $af		          STA EAH
.e999	60		rts		          RTS
.e99a					  TAPE_Find_File
.e99a	20 d0 e8	jsr $e8d0	          JSR TAPE_Find_Header
.e99d	b0 1e		bcs $e9bd	          BCS TAFF_Ret        ; -> end of tape: not found
.e99f	a0 05		ldy #$05	          LDY #5              ; start of filename
.e9a1	84 9f		sty $9f		          STY PTR_HI          ; buffered filename index
.e9a3	a0 00		ldy #$00	          LDY #0
.e9a5	84 9e		sty $9e		          STY PTR_LO          ; fined filename index
.e9a7	c4 b7		cpy $b7		TAFF_10   CPY FNLEN
.e9a9	f0 11		beq $e9bc	          BEQ TAFF_20         ; -> OK found
.e9ab	20 ae f7	jsr $f7ae	          JSR Get_Filename_Char
.e9ae	a4 9f		ldy $9f		          LDY PTR_HI
.e9b0	d1 b2		cmp ($b2),y	          CMP (TAPE1),Y
.e9b2	d0 e6		bne $e99a	          BNE TAPE_Find_File  ; -> skip this file, try next one
.e9b4	e6 9e		inc $9e		          INC PTR_LO
.e9b6	e6 9f		inc $9f		          INC PTR_HI
.e9b8	a4 9e		ldy $9e		          LDY PTR_LO
.e9ba	d0 eb		bne $e9a7	          BNE TAFF_10         ; always
.e9bc	18		clc		TAFF_20   CLC                 ; success
.e9bd	60		rts		TAFF_Ret  RTS
.e9be					  TAPE_Advance_BUFPT
.e9be	20 80 e9	jsr $e980	          JSR TAPE_XY_Check
.e9c1	e6 a6		inc $a6		          INC BUFPT
.e9c3	a4 a6		ldy $a6		          LDY BUFPT
.e9c5	c0 c0		cpy #$c0	          CPY #$c0
.e9c7	60		rts		          RTS
.e9c8					  TAPE_Wait_for_Play
.e9c8	20 df e9	jsr $e9df	          JSR TAPE_Play_Key
.e9cb	f0 1a		beq $e9e7	          BEQ TAPK_10
.e9cd	a0 1b		ldy #$1b	          LDY #Msg_Play
.e9cf	20 22 f7	jsr $f722	TWFP_10   JSR System_Message
.e9d2	20 8f ea	jsr $ea8f	TWFP_20   JSR TAPE_Stop_Key
.e9d5	20 df e9	jsr $e9df	          JSR TAPE_Play_Key
.e9d8	d0 f8		bne $e9d2	          BNE TWFP_20
.e9da	a0 6a		ldy #$6a	          LDY #Msg_OK
.e9dc	4c 22 f7	jmp $f722	          JMP System_Message
.e9df					  TAPE_Play_Key
.e9df	a9 10		lda #$10	          LDA #16
.e9e1	24 01		bit $01		          BIT R8502
.e9e3	d0 02		bne $e9e7	          BNE TAPK_10
.e9e5	24 01		bit $01		          BIT R8502
.e9e7	18		clc		TAPK_10   CLC
.e9e8	60		rts		          RTS
.e9e9					  TAPE_Wait_For_Record
.e9e9	20 df e9	jsr $e9df	          JSR TAPE_Play_Key
.e9ec	f0 f9		beq $e9e7	          BEQ TAPK_10
.e9ee	a0 2e		ldy #$2e	          LDY #Msg_Record
.e9f0	d0 dd		bne $e9cf	          BNE TWFP_10
.e9f2					  TAPE_Read_Block
.e9f2	a9 00		lda #$00	          LDA #0
.e9f4	85 90		sta $90		          STA STATUS
.e9f6	85 93		sta $93		          STA K_VERCK
.e9f8	20 87 e9	jsr $e987	          JSR TAPE_SAL_EAL
.e9fb					  TAPE_Read
.e9fb	20 c8 e9	jsr $e9c8	          JSR TAPE_Wait_for_Play
.e9fe	b0 1f		bcs $ea1f	          BCS TAWB_10
.ea00	78		sei		          SEI
.ea01	a9 00		lda #$00	          LDA #0
.ea03	85 aa		sta $aa		          STA RSI_Data
.ea05	85 b4		sta $b4		          STA RS_Count
.ea07	85 b0		sta $b0		          STA CMP0
.ea09	85 9e		sta $9e		          STA PTR_LO
.ea0b	85 9f		sta $9f		          STA PTR_HI
.ea0d	85 9c		sta $9c		          STA DPSW
.ea0f	a9 90		lda #$90	          LDA #$90            ; STA CIA1_IC
.ea11	a2 0e		ldx #$0e	          LDX #14             ; Install TAPE_IRQ_Read as IRQ routine
.ea13	d0 11		bne $ea26	          BNE TAPE_Setup_IRQ  ; always
.ea15					  TAPE_Write_Buffer
.ea15	20 87 e9	jsr $e987	          JSR TAPE_SAL_EAL
.ea18					  TAPE_Write_Program
.ea18	a9 14		lda #$14	          LDA #$14
.ea1a	85 ab		sta $ab		          STA RSI_Parity
.ea1c					  TAPE_Write
.ea1c	20 e9 e9	jsr $e9e9	          JSR TAPE_Wait_For_Record
.ea1f	b0 7a		bcs $ea9b	TAWB_10   BCS TASK_10
.ea21	78		sei		          SEI
.ea22	a9 82		lda #$82	          LDA #$82
.ea24	a2 08		ldx #$08	          LDX #8              ; Install TAPE_IRQ_Leader as IRQ routine
.ea26					  TAPE_Setup_IRQ
.ea26	a0 00		ldy #$00	          LDY #0
.ea28	8c 1a d0	sty $d01a	          STY VIC_IRQ_ENA
.ea2b	88		dey		          DEY
.ea2c	8c 19 d0	sty $d019	          STY VIC_IRQ_REG
.ea2f	8d 0d dc	sta $dc0d	          STA CIA1_ICR
.ea32	ad 0e dc	lda $dc0e	          LDA CIA1_CRA
.ea35	09 19		ora #$19	          ORA #%00011001 ; $19
.ea37	8d 0f dc	sta $dc0f	          STA CIA1_CRB
.ea3a	29 91		and #$91	          AND #%10010001 ; $91
.ea3c	8d 0b 0a	sta $0a0b	          STA CASTON
.ea3f	20 ec e7	jsr $e7ec	          JSR RS232_Stop
.ea42	ad 11 d0	lda $d011	          LDA VIC_Ctrl_1
.ea45	a8		tay		          TAY
.ea46	29 10		and #$10	          AND #%00010000 ; $10
.ea48	8d 39 0a	sta $0a39	          STA VSH_Ctrl_1
.ea4b	98		tya		          TYA
.ea4c	29 6f		and #$6f	          AND #%01101111 ; $6f
.ea4e	8d 11 d0	sta $d011	          STA VIC_Ctrl_1
.ea51	20 74 e5	jsr $e574	          JSR Disable_Sprites
.ea54	ad 14 03	lda $0314	          LDA IIRQ            ; save old IRQ vector
.ea57	8d 09 0a	sta $0a09	          STA IRQTMP
.ea5a	ad 15 03	lda $0315	          LDA IIRQ+1
.ea5d	8d 0a 0a	sta $0a0a	          STA IRQTMP+1
.ea60	20 9b ee	jsr $ee9b	          JSR TAPE_Switch_IRQ
.ea63	a9 02		lda #$02	          LDA #2
.ea65	85 be		sta $be		          STA FSBLK
.ea67	20 5a ed	jsr $ed5a	          JSR TAPE_Init_Byte
.ea6a	a5 01		lda $01		          LDA R8502
.ea6c	29 1f		and #$1f	          AND #%00011111 ; $1f
.ea6e	85 01		sta $01		          STA R8502
.ea70	85 c0		sta $c0		          STA CAS1
.ea72	a2 ff		ldx #$ff	          LDX #$ff            ; wait 0.3 sec for tape start
.ea74	a0 ff		ldy #$ff	TASI_10   LDY #$ff
.ea76	88		dey		TASI_20   DEY
.ea77	d0 fd		bne $ea76	          BNE TASI_20
.ea79	ca		dex		          DEX
.ea7a	d0 f8		bne $ea74	          BNE TASI_10
.ea7c	58		cli		          CLI
.ea7d	ad 0a 0a	lda $0a0a	TASI_30   LDA IRQTMP+1
.ea80	cd 15 03	cmp $0315	          CMP IIRQ+1
.ea83	18		clc		          CLC
.ea84	f0 15		beq $ea9b	          BEQ TASK_10
.ea86	20 8f ea	jsr $ea8f	          JSR TAPE_Stop_Key
.ea89	20 3d f6	jsr $f63d	          JSR Check_STOP_Key
.ea8c	4c 7d ea	jmp $ea7d	          JMP TASI_30         ; wait until tape I/O finished
.ea8f					  TAPE_Stop_Key
.ea8f	20 e1 ff	jsr $ffe1	          JSR K_STOP
.ea92	18		clc		          CLC
.ea93	d0 0b		bne $eaa0	          BNE TASK_Ret
.ea95	20 57 ee	jsr $ee57	          JSR TAPE_Stop_IO
.ea98	38		sec		          SEC
.ea99	68		pla		          PLA                 ; remove return address
.ea9a	68		pla		          PLA
.ea9b	a9 00		lda #$00	TASK_10   LDA #0
.ea9d	8d 0a 0a	sta $0a0a	          STA IRQTMP+1        ; flag STOP
.eaa0	60		rts		TASK_Ret  RTS
.eaa1					  TAPE_Set_Timer
.eaa1	86 b1		stx $b1		          STX CMP1
.eaa3	a5 b0		lda $b0		          LDA CMP0
.eaa5	0a		asl a		          ASL A
.eaa6	0a		asl a		          ASL A
.eaa7	18		clc		          CLC
.eaa8	65 b0		adc $b0		          ADC CMP0
.eaaa	18		clc		          CLC
.eaab	65 b1		adc $b1		          ADC CMP1
.eaad	85 b1		sta $b1		          STA CMP1
.eaaf	a9 00		lda #$00	          LDA #0
.eab1	24 b0		bit $b0		          BIT CMP0
.eab3	30 01		bmi $eab6	          BMI TASS_10
.eab5	2a		rol a		          ROL A
.eab6	06 b1		asl $b1		TASS_10   ASL CMP1
.eab8	2a		rol a		          ROL A
.eab9	06 b1		asl $b1		          ASL CMP1
.eabb	2a		rol a		          ROL A
.eabc	aa		tax		          TAX
.eabd	ad 06 dc	lda $dc06	TASS_20   LDA CIA1_TBLO
.eac0	c9 16		cmp #$16	          CMP #$16
.eac2	90 f9		bcc $eabd	          BCC TASS_20
.eac4	65 b1		adc $b1		          ADC CMP1
.eac6	8d 04 dc	sta $dc04	          STA CIA1_TALO
.eac9	8a		txa		          TXA
.eaca	6d 07 dc	adc $dc07	          ADC CIA1_TBHI
.eacd	8d 05 dc	sta $dc05	          STA CIA1_TAHI
.ead0	ad 0b 0a	lda $0a0b	          LDA CASTON
.ead3	8d 0e dc	sta $dc0e	          STA CIA1_CRA
.ead6	8d 0d 0a	sta $0a0d	          STA STUPID
.ead9	ad 0d dc	lda $dc0d	          LDA CIA1_ICR
.eadc	29 10		and #$10	          AND #%00010000 ; $10
.eade	f0 09		beq $eae9	          BEQ TASS_30
.eae0	a9 ea		lda #$ea	          LDA #$ea
.eae2	48		pha		          PHA
.eae3	a9 e9		lda #$e9	          LDA #$e9
.eae5	48		pha		          PHA
.eae6	4c c8 ee	jmp $eec8	          JMP TAPE_Sim_IRQ
.eae9	58		cli		TASS_30   CLI
.eaea	60		rts		          RTS
.eaeb					  TAPE_IRQ_Read
.eaeb	ae 07 dc	ldx $dc07	          LDX CIA1_TBHI
.eaee	a0 ff		ldy #$ff	          LDY #$ff
.eaf0	98		tya		          TYA
.eaf1	ed 06 dc	sbc $dc06	          SBC CIA1_TBLO
.eaf4	ec 07 dc	cpx $dc07	          CPX CIA1_TBHI
.eaf7	d0 f2		bne $eaeb	          BNE TAPE_IRQ_Read
.eaf9	86 b1		stx $b1		          STX CMP1
.eafb	aa		tax		          TAX
.eafc	8c 06 dc	sty $dc06	          STY CIA1_TBLO
.eaff	8c 07 dc	sty $dc07	          STY CIA1_TBHI
.eb02	a9 19		lda #$19	          LDA #$19
.eb04	8d 0f dc	sta $dc0f	          STA CIA1_CRB
.eb07	ad 0d dc	lda $dc0d	          LDA CIA1_ICR
.eb0a	8d 0c 0a	sta $0a0c	          STA KIKA26
.eb0d	98		tya		          TYA
.eb0e	e5 b1		sbc $b1		          SBC CMP1
.eb10	86 b1		stx $b1		          STX CMP1
.eb12	4a		lsr a		          LSR A
.eb13	66 b1		ror $b1		          ROR CMP1
.eb15	4a		lsr a		          LSR A
.eb16	66 b1		ror $b1		          ROR CMP1
.eb18	a5 b0		lda $b0		          LDA CMP0
.eb1a	18		clc		          CLC
.eb1b	69 3c		adc #$3c	          ADC #$3c
.eb1d	c5 b1		cmp $b1		          CMP CMP1
.eb1f	b0 4a		bcs $eb6b	          BCS TIR_22
.eb21	a6 9c		ldx $9c		          LDX DPSW
.eb23	f0 03		beq $eb28	          BEQ TIR_10
.eb25	4c 1f ec	jmp $ec1f	          JMP TIR_50
.eb28	a6 a3		ldx $a3		TIR_10    LDX R2D2
.eb2a	30 1b		bmi $eb47	          BMI TIR_12
.eb2c	a2 00		ldx #$00	          LDX #0
.eb2e	69 30		adc #$30	          ADC #$30
.eb30	65 b0		adc $b0		          ADC CMP0
.eb32	c5 b1		cmp $b1		          CMP CMP1
.eb34	b0 1c		bcs $eb52	          BCS TIR_16
.eb36	e8		inx		          INX
.eb37	69 26		adc #$26	          ADC #$26
.eb39	65 b0		adc $b0		          ADC CMP0
.eb3b	c5 b1		cmp $b1		          CMP CMP1
.eb3d	b0 17		bcs $eb56	          BCS TIR_18
.eb3f	69 2c		adc #$2c	          ADC #$2c
.eb41	65 b0		adc $b0		          ADC CMP0
.eb43	c5 b1		cmp $b1		          CMP CMP1
.eb45	90 03		bcc $eb4a	          BCC TIR_14
.eb47	4c cf eb	jmp $ebcf	TIR_12    JMP TIR_38
.eb4a	a5 b4		lda $b4		TIR_14    LDA RS_Count
.eb4c	f0 1d		beq $eb6b	          BEQ TIR_22
.eb4e	85 a8		sta $a8		          STA RSI_Count
.eb50	d0 19		bne $eb6b	          BNE TIR_22
.eb52	e6 a9		inc $a9		TIR_16    INC RSI_Start
.eb54	b0 02		bcs $eb58	          BCS TIR_20
.eb56	c6 a9		dec $a9		TIR_18    DEC RSI_Start
.eb58	38		sec		TIR_20    SEC
.eb59	e9 13		sbc #$13	          SBC #$13
.eb5b	e5 b1		sbc $b1		          SBC CMP1
.eb5d	65 92		adc $92		          ADC SVXT
.eb5f	85 92		sta $92		          STA SVXT
.eb61	a5 a4		lda $a4		          LDA BSOUR1
.eb63	49 01		eor #$01	          EOR #%00000001 ; $01
.eb65	85 a4		sta $a4		          STA BSOUR1
.eb67	f0 2b		beq $eb94	          BEQ TIR_30
.eb69	86 c5		stx $c5		          STX DATA
.eb6b	a5 b4		lda $b4		TIR_22    LDA RS_Count
.eb6d	f0 22		beq $eb91	          BEQ TIR_28
.eb6f	ad 0c 0a	lda $0a0c	          LDA KIKA26
.eb72	29 01		and #$01	          AND #%00000001 ; $01
.eb74	d0 05		bne $eb7b	          BNE TIR_24
.eb76	ad 0d 0a	lda $0a0d	          LDA STUPID
.eb79	d0 16		bne $eb91	          BNE TIR_28
.eb7b	a9 00		lda #$00	TIR_24    LDA #0
.eb7d	85 a4		sta $a4		          STA BSOUR1
.eb7f	8d 0d 0a	sta $0a0d	          STA STUPID
.eb82	a5 a3		lda $a3		          LDA R2D2
.eb84	10 30		bpl $ebb6	          BPL TIR_36
.eb86	30 bf		bmi $eb47	          BMI TIR_12
.eb88	a2 a6		ldx #$a6	TIR_26    LDX #$a6
.eb8a	20 a1 ea	jsr $eaa1	          JSR TAPE_Set_Timer
.eb8d	a5 9b		lda $9b		          LDA PRTY
.eb8f	d0 b9		bne $eb4a	          BNE TIR_14
.eb91	4c 33 ff	jmp $ff33	TIR_28    JMP IRQ_Exit
.eb94	a5 92		lda $92		TIR_30    LDA SVXT
.eb96	f0 07		beq $eb9f	          BEQ TIR_34
.eb98	30 03		bmi $eb9d	          BMI TIR_32
.eb9a	c6 b0		dec $b0		          DEC CMP0
>eb9c	2c				          .byte $2c ;BIT
.eb9d	e6 b0		inc $b0		TIR_32    INC CMP0
.eb9f	a9 00		lda #$00	TIR_34    LDA #0
.eba1	85 92		sta $92		          STA SVXT
.eba3	e4 c5		cpx $c5		          CPX DATA
.eba5	d0 0f		bne $ebb6	          BNE TIR_36
.eba7	8a		txa		          TXA
.eba8	d0 a0		bne $eb4a	          BNE TIR_14
.ebaa	a5 a9		lda $a9		          LDA RSI_Start
.ebac	30 bd		bmi $eb6b	          BMI TIR_22
.ebae	c9 10		cmp #$10	          CMP #16
.ebb0	90 b9		bcc $eb6b	          BCC TIR_22
.ebb2	85 96		sta $96		          STA SYNO
.ebb4	b0 b5		bcs $eb6b	          BCS TIR_22
.ebb6	8a		txa		TIR_36    TXA
.ebb7	45 9b		eor $9b		          EOR PRTY
.ebb9	85 9b		sta $9b		          STA PRTY
.ebbb	a5 b4		lda $b4		          LDA RS_Count
.ebbd	f0 d2		beq $eb91	          BEQ TIR_28
.ebbf	c6 a3		dec $a3		          DEC R2D2
.ebc1	30 c5		bmi $eb88	          BMI TIR_26
.ebc3	46 c5		lsr $c5		          LSR DATA
.ebc5	66 bf		ror $bf		          ROR DRIVE
.ebc7	a2 da		ldx #$da	          LDX #$da
.ebc9	20 a1 ea	jsr $eaa1	          JSR TAPE_Set_Timer
.ebcc	4c 33 ff	jmp $ff33	          JMP IRQ_Exit
.ebcf	a5 96		lda $96		TIR_38    LDA SYNO
.ebd1	f0 04		beq $ebd7	          BEQ TIR_40
.ebd3	a5 b4		lda $b4		          LDA RS_Count
.ebd5	f0 07		beq $ebde	          BEQ TIR_42
.ebd7	a5 a3		lda $a3		TIR_40    LDA R2D2
.ebd9	30 03		bmi $ebde	          BMI TIR_42
.ebdb	4c 56 eb	jmp $eb56	          JMP TIR_18
.ebde	46 b1		lsr $b1		TIR_42    LSR CMP1
.ebe0	a9 93		lda #$93	          LDA #$93
.ebe2	38		sec		          SEC
.ebe3	e5 b1		sbc $b1		          SBC CMP1
.ebe5	65 b0		adc $b0		          ADC CMP0
.ebe7	0a		asl a		          ASL A
.ebe8	aa		tax		          TAX
.ebe9	20 a1 ea	jsr $eaa1	          JSR TAPE_Set_Timer
.ebec	e6 9c		inc $9c		          INC DPSW
.ebee	a5 b4		lda $b4		          LDA RS_Count
.ebf0	d0 11		bne $ec03	          BNE TIR_44
.ebf2	a5 96		lda $96		          LDA SYNO
.ebf4	f0 26		beq $ec1c	          BEQ TIR_48
.ebf6	85 a8		sta $a8		          STA RSI_Count
.ebf8	a9 00		lda #$00	          LDA #0
.ebfa	85 96		sta $96		          STA SYNO
.ebfc	a9 81		lda #$81	          LDA #$81
.ebfe	8d 0d dc	sta $dc0d	          STA CIA1_ICR
.ec01	85 b4		sta $b4		          STA RS_Count
.ec03	a5 96		lda $96		TIR_44    LDA SYNO
.ec05	85 b5		sta $b5		          STA RS_Next
.ec07	f0 09		beq $ec12	          BEQ TIR_46
.ec09	a9 00		lda #$00	          LDA #0
.ec0b	85 b4		sta $b4		          STA RS_Count
.ec0d	a9 01		lda #$01	          LDA #1
.ec0f	8d 0d dc	sta $dc0d	          STA CIA1_ICR
.ec12	a5 bf		lda $bf		TIR_46    LDA DRIVE
.ec14	85 bd		sta $bd		          STA RS_Parity
.ec16	a5 a8		lda $a8		          LDA RSI_Count
.ec18	05 a9		ora $a9		          ORA RSI_Start
.ec1a	85 b6		sta $b6		          STA RS_Out
.ec1c	4c 33 ff	jmp $ff33	TIR_48    JMP IRQ_Exit
.ec1f	20 5a ed	jsr $ed5a	TIR_50    JSR TAPE_Init_Byte
.ec22	85 9c		sta $9c		          STA DPSW
.ec24	a2 da		ldx #$da	          LDX #$da
.ec26	20 a1 ea	jsr $eaa1	          JSR TAPE_Set_Timer
.ec29	a5 be		lda $be		          LDA FSBLK
.ec2b	f0 02		beq $ec2f	          BEQ TIR_52
.ec2d	85 a7		sta $a7		          STA RSI_In_Bit
.ec2f	a9 0f		lda #$0f	TIR_52    LDA #15
.ec31	24 aa		bit $aa		          BIT RSI_Data
.ec33	10 17		bpl $ec4c	          BPL TIR_58
.ec35	a5 b5		lda $b5		          LDA RS_Next
.ec37	d0 0c		bne $ec45	          BNE TIR_54
.ec39	a6 be		ldx $be		          LDX FSBLK
.ec3b	ca		dex		          DEX
.ec3c	d0 0b		bne $ec49	          BNE TIR_56
.ec3e	a9 08		lda #$08	          LDA #8
.ec40	20 57 f7	jsr $f757	          JSR SETST
.ec43	d0 04		bne $ec49	          BNE TIR_56
.ec45	a9 00		lda #$00	TIR_54    LDA #0
.ec47	85 aa		sta $aa		          STA RSI_Data
.ec49	4c 33 ff	jmp $ff33	TIR_56    JMP IRQ_Exit
.ec4c	70 31		bvs $ec7f	TIR_58    BVS TIR_66
.ec4e	d0 18		bne $ec68	          BNE TIR_62
.ec50	a5 b5		lda $b5		          LDA RS_Next
.ec52	d0 f5		bne $ec49	          BNE TIR_56
.ec54	a5 b6		lda $b6		          LDA RS_Out
.ec56	d0 f1		bne $ec49	          BNE TIR_56
.ec58	a5 a7		lda $a7		          LDA RSI_In_Bit
.ec5a	4a		lsr a		          LSR A
.ec5b	a5 bd		lda $bd		          LDA RS_Parity
.ec5d	30 03		bmi $ec62	          BMI TIR_60
.ec5f	90 18		bcc $ec79	          BCC TIR_64
.ec61	18		clc		          CLC
.ec62	b0 15		bcs $ec79	TIR_60    BCS TIR_64
.ec64	29 0f		and #$0f	          AND #%00001111 ; $0f
.ec66	85 aa		sta $aa		          STA RSI_Data
.ec68	c6 aa		dec $aa		TIR_62    DEC RSI_Data
.ec6a	d0 dd		bne $ec49	          BNE TIR_56
.ec6c	a9 40		lda #$40	          LDA #$40 ; '@'
.ec6e	85 aa		sta $aa		          STA RSI_Data
.ec70	20 51 ed	jsr $ed51	          JSR STAL_To_SAL
.ec73	a9 00		lda #$00	          LDA #0
.ec75	85 ab		sta $ab		          STA RSI_Parity
.ec77	f0 d0		beq $ec49	          BEQ TIR_56
.ec79	a9 80		lda #$80	TIR_64    LDA #$80
.ec7b	85 aa		sta $aa		          STA RSI_Data
.ec7d	d0 ca		bne $ec49	          BNE TIR_56
.ec7f	a5 b5		lda $b5		TIR_66    LDA RS_Next
.ec81	f0 0a		beq $ec8d	          BEQ TIR_68
.ec83	a9 04		lda #$04	          LDA #4
.ec85	20 57 f7	jsr $f757	          JSR SETST
.ec88	a9 00		lda #$00	          LDA #0
.ec8a	4c 0c ed	jmp $ed0c	          JMP TIR_86
.ec8d	20 b7 ee	jsr $eeb7	TIR_68    JSR Check_IO_End
.ec90	90 03		bcc $ec95	          BCC TIR_70
.ec92	4c 0a ed	jmp $ed0a	          JMP TIR_84
.ec95	a6 a7		ldx $a7		TIR_70    LDX RSI_In_Bit
.ec97	ca		dex		          DEX
.ec98	f0 2e		beq $ecc8	          BEQ TIR_74
.ec9a	a5 93		lda $93		          LDA K_VERCK
.ec9c	f0 0d		beq $ecab	          BEQ TIR_72
.ec9e	a0 00		ldy #$00	          LDY #0
.eca0	20 cc f7	jsr $f7cc	          JSR LDA_IND_SAL
.eca3	c5 bd		cmp $bd		          CMP RS_Parity
.eca5	f0 04		beq $ecab	          BEQ TIR_72
.eca7	a9 01		lda #$01	          LDA #1
.eca9	85 b6		sta $b6		          STA RS_Out
.ecab	a5 b6		lda $b6		TIR_72    LDA RS_Out
.ecad	f0 4c		beq $ecfb	          BEQ TIR_80
.ecaf	a2 3d		ldx #$3d	          LDX #$3d ; '='
.ecb1	e4 9e		cpx $9e		          CPX PTR_LO
.ecb3	90 3f		bcc $ecf4	          BCC TIR_78
.ecb5	a6 9e		ldx $9e		          LDX PTR_LO
.ecb7	a5 ad		lda $ad		          LDA SAH
.ecb9	9d 01 01	sta $0101,x	          STA STACK+1,X
.ecbc	a5 ac		lda $ac		          LDA SAL
.ecbe	9d 00 01	sta $0100,x	          STA STACK,X
.ecc1	e8		inx		          INX
.ecc2	e8		inx		          INX
.ecc3	86 9e		stx $9e		          STX PTR_LO
.ecc5	4c fb ec	jmp $ecfb	          JMP TIR_80
.ecc8	a6 9f		ldx $9f		TIR_74    LDX PTR_HI
.ecca	e4 9e		cpx $9e		          CPX PTR_LO
.eccc	f0 37		beq $ed05	          BEQ TIR_82
.ecce	a5 ac		lda $ac		          LDA SAL
.ecd0	dd 00 01	cmp $0100,x	          CMP STACK,X
.ecd3	d0 30		bne $ed05	          BNE TIR_82
.ecd5	a5 ad		lda $ad		          LDA SAH
.ecd7	dd 01 01	cmp $0101,x	          CMP STACK+1,X
.ecda	d0 29		bne $ed05	          BNE TIR_82
.ecdc	e6 9f		inc $9f		          INC PTR_HI
.ecde	e6 9f		inc $9f		          INC PTR_HI
.ece0	a5 93		lda $93		          LDA K_VERCK
.ece2	f0 0c		beq $ecf0	          BEQ TIR_76
.ece4	a0 00		ldy #$00	          LDY #0
.ece6	20 cc f7	jsr $f7cc	          JSR LDA_IND_SAL
.ece9	c5 bd		cmp $bd		          CMP RS_Parity
.eceb	f0 18		beq $ed05	          BEQ TIR_82
.eced	c8		iny		          INY
.ecee	84 b6		sty $b6		          STY RS_Out
.ecf0	a5 b6		lda $b6		TIR_76    LDA RS_Out
.ecf2	f0 07		beq $ecfb	          BEQ TIR_80
.ecf4	a9 10		lda #$10	TIR_78    LDA #16
.ecf6	20 57 f7	jsr $f757	          JSR SETST
.ecf9	d0 0a		bne $ed05	          BNE TIR_82
.ecfb	a5 93		lda $93		TIR_80    LDA K_VERCK
.ecfd	d0 06		bne $ed05	          BNE TIR_82
.ecff	a8		tay		          TAY
.ed00	a5 bd		lda $bd		          LDA RS_Parity
.ed02	20 bc f7	jsr $f7bc	          JSR STA_IND_SAL
.ed05	20 c1 ee	jsr $eec1	TIR_82    JSR Inc_SAL_Word
.ed08	d0 44		bne $ed4e	          BNE TIR_94
.ed0a	a9 80		lda #$80	TIR_84    LDA #$80
.ed0c	85 aa		sta $aa		TIR_86    STA RSI_Data
.ed0e	78		sei		          SEI
.ed0f	a2 01		ldx #$01	          LDX #1
.ed11	8e 0d dc	stx $dc0d	          STX CIA1_ICR
.ed14	ae 0d dc	ldx $dc0d	          LDX CIA1_ICR
.ed17	a6 be		ldx $be		          LDX FSBLK
.ed19	ca		dex		          DEX
.ed1a	30 02		bmi $ed1e	          BMI TIR_88
.ed1c	86 be		stx $be		          STX FSBLK
.ed1e	c6 a7		dec $a7		TIR_88    DEC RSI_In_Bit
.ed20	f0 08		beq $ed2a	          BEQ TIR_90
.ed22	a5 9e		lda $9e		          LDA PTR_LO
.ed24	d0 28		bne $ed4e	          BNE TIR_94
.ed26	85 be		sta $be		          STA FSBLK
.ed28	f0 24		beq $ed4e	          BEQ TIR_94
.ed2a	20 57 ee	jsr $ee57	TIR_90    JSR TAPE_Stop_IO
.ed2d	20 51 ed	jsr $ed51	          JSR STAL_To_SAL
.ed30	a0 00		ldy #$00	          LDY #0
.ed32	84 ab		sty $ab		          STY RSI_Parity
.ed34	20 cc f7	jsr $f7cc	TIR_92    JSR LDA_IND_SAL
.ed37	45 ab		eor $ab		          EOR RSI_Parity
.ed39	85 ab		sta $ab		          STA RSI_Parity
.ed3b	20 c1 ee	jsr $eec1	          JSR Inc_SAL_Word
.ed3e	20 b7 ee	jsr $eeb7	          JSR Check_IO_End
.ed41	90 f1		bcc $ed34	          BCC TIR_92
.ed43	a5 ab		lda $ab		          LDA RSI_Parity
.ed45	45 bd		eor $bd		          EOR RS_Parity
.ed47	f0 05		beq $ed4e	          BEQ TIR_94
.ed49	a9 20		lda #$20	          LDA #$20 ; ' '
.ed4b	20 57 f7	jsr $f757	          JSR SETST
.ed4e	4c 33 ff	jmp $ff33	TIR_94    JMP IRQ_Exit
.ed51					  STAL_To_SAL
.ed51	a5 c2		lda $c2		          LDA STAH
.ed53	85 ad		sta $ad		          STA SAH
.ed55	a5 c1		lda $c1		          LDA STAL
.ed57	85 ac		sta $ac		          STA SAL
.ed59	60		rts		          RTS
.ed5a					  TAPE_Init_Byte
.ed5a	a9 08		lda #$08	          LDA #8
.ed5c	85 a3		sta $a3		          STA R2D2
.ed5e	a9 00		lda #$00	          LDA #0
.ed60	85 a4		sta $a4		          STA BSOUR1
.ed62	85 a8		sta $a8		          STA RSI_Count
.ed64	85 9b		sta $9b		          STA PRTY
.ed66	85 a9		sta $a9		          STA RSI_Start
.ed68	60		rts		          RTS
.ed69					  TAPE_Write_Bit
.ed69	a5 bd		lda $bd		          LDA RS_Parity
.ed6b	4a		lsr a		          LSR A
.ed6c	a9 60		lda #$60	          LDA #$60
.ed6e	90 02		bcc $ed72	          BCC TAPE_Write_A
.ed70					  TAPE_Write_1
.ed70	a9 b0		lda #$b0	          LDA #$b0
.ed72					  TAPE_Write_A
.ed72	a2 00		ldx #$00	          LDX #0
.ed74					  TAPE_Write_AX
.ed74	8d 06 dc	sta $dc06	          STA CIA1_TBLO
.ed77	8e 07 dc	stx $dc07	          STX CIA1_TBHI
.ed7a	ad 0d dc	lda $dc0d	          LDA CIA1_ICR
.ed7d	a9 19		lda #$19	          LDA #$19
.ed7f	8d 0f dc	sta $dc0f	          STA CIA1_CRB
.ed82	a5 01		lda $01		          LDA R8502
.ed84	49 08		eor #$08	          EOR #%00001000 ; $08
.ed86	85 01		sta $01		          STA R8502
.ed88	29 08		and #$08	          AND #%00001000 ; $08
.ed8a	60		rts		          RTS
.ed8b	38		sec		TAIW_00   SEC
.ed8c	66 b6		ror $b6		          ROR RS_Out
.ed8e	30 3c		bmi $edcc	          BMI TAIW_20
.ed90					  TAPE_IRQ_Write
.ed90	a5 a8		lda $a8		          LDA RSI_Count
.ed92	d0 12		bne $eda6	          BNE TAIW_10
.ed94	a9 10		lda #$10	          LDA #16
.ed96	a2 01		ldx #$01	          LDX #1
.ed98	20 74 ed	jsr $ed74	          JSR TAPE_Write_AX
.ed9b	d0 2f		bne $edcc	          BNE TAIW_20
.ed9d	e6 a8		inc $a8		          INC RSI_Count
.ed9f	a5 b6		lda $b6		          LDA RS_Out
.eda1	10 29		bpl $edcc	          BPL TAIW_20
.eda3	4c 1b ee	jmp $ee1b	          JMP TAIW_60
.eda6	a5 a9		lda $a9		TAIW_10   LDA RSI_Start
.eda8	d0 09		bne $edb3	          BNE TAIW_15
.edaa	20 70 ed	jsr $ed70	          JSR TAPE_Write_1
.edad	d0 1d		bne $edcc	          BNE TAIW_20
.edaf	e6 a9		inc $a9		          INC RSI_Start
.edb1	d0 19		bne $edcc	          BNE TAIW_20
.edb3	20 69 ed	jsr $ed69	TAIW_15   JSR TAPE_Write_Bit
.edb6	d0 14		bne $edcc	          BNE TAIW_20
.edb8	a5 a4		lda $a4		          LDA BSOUR1
.edba	49 01		eor #$01	          EOR #1
.edbc	85 a4		sta $a4		          STA BSOUR1
.edbe	f0 0f		beq $edcf	          BEQ TAIW_25
.edc0	a5 bd		lda $bd		          LDA RS_Parity
.edc2	49 01		eor #$01	          EOR #1
.edc4	85 bd		sta $bd		          STA RS_Parity
.edc6	29 01		and #$01	          AND #1
.edc8	45 9b		eor $9b		          EOR PRTY
.edca	85 9b		sta $9b		          STA PRTY
.edcc	4c 33 ff	jmp $ff33	TAIW_20   JMP IRQ_Exit
.edcf	46 bd		lsr $bd		TAIW_25   LSR RS_Parity
.edd1	c6 a3		dec $a3		          DEC R2D2
.edd3	a5 a3		lda $a3		          LDA R2D2
.edd5	f0 3b		beq $ee12	          BEQ TAIW_50
.edd7	10 f3		bpl $edcc	          BPL TAIW_20
.edd9	20 5a ed	jsr $ed5a	TAIW_30   JSR TAPE_Init_Byte
.eddc	58		cli		          CLI
.eddd	a5 a5		lda $a5		          LDA CNTDN
.eddf	f0 12		beq $edf3	          BEQ TAIW_40
.ede1	a2 00		ldx #$00	          LDX #0
.ede3	86 c5		stx $c5		          STX DATA
.ede5	c6 a5		dec $a5		          DEC CNTDN
.ede7	a6 be		ldx $be		          LDX FSBLK
.ede9	e0 02		cpx #$02	          CPX #2
.edeb	d0 02		bne $edef	          BNE TAIW_35
.eded	09 80		ora #$80	          ORA #$80
.edef	85 bd		sta $bd		TAIW_35   STA RS_Parity
.edf1	d0 d9		bne $edcc	          BNE TAIW_20
.edf3	20 b7 ee	jsr $eeb7	TAIW_40   JSR Check_IO_End
.edf6	90 0a		bcc $ee02	          BCC TAIW_45
.edf8	d0 91		bne $ed8b	          BNE TAIW_00
.edfa	e6 ad		inc $ad		          INC SAH
.edfc	a5 c5		lda $c5		          LDA DATA
.edfe	85 bd		sta $bd		          STA RS_Parity
.ee00	b0 ca		bcs $edcc	          BCS TAIW_20
.ee02	a0 00		ldy #$00	TAIW_45   LDY #0
.ee04	20 cc f7	jsr $f7cc	          JSR LDA_IND_SAL
.ee07	85 bd		sta $bd		          STA RS_Parity
.ee09	45 c5		eor $c5		          EOR DATA
.ee0b	85 c5		sta $c5		          STA DATA
.ee0d	20 c1 ee	jsr $eec1	          JSR Inc_SAL_Word
.ee10	d0 ba		bne $edcc	          BNE TAIW_20
.ee12	a5 9b		lda $9b		TAIW_50   LDA PRTY
.ee14	49 01		eor #$01	          EOR #1
.ee16	85 bd		sta $bd		          STA RS_Parity
.ee18	4c 33 ff	jmp $ff33	TAIW_55   JMP IRQ_Exit
.ee1b	c6 be		dec $be		TAIW_60   DEC FSBLK
.ee1d	d0 03		bne $ee22	          BNE TAIW_65
.ee1f	20 b0 ee	jsr $eeb0	          JSR TAPE_Stop_Motor
.ee22	a9 50		lda #$50	TAIW_65   LDA #$50
.ee24	85 a7		sta $a7		          STA RSI_In_Bit
.ee26	a2 08		ldx #$08	          LDX #8              ; switch IRQ to TAPE_IRQ_Leader
.ee28	78		sei		          SEI
.ee29	20 9b ee	jsr $ee9b	          JSR TAPE_Switch_IRQ
.ee2c	d0 ea		bne $ee18	          BNE TAIW_55         ; always
.ee2e					  TAPE_IRQ_Leader
.ee2e	a9 78		lda #$78	          LDA #$78            ; set time constant low byte for bit = leader
.ee30	20 72 ed	jsr $ed72	          JSR TAPE_Write_A
.ee33	d0 e3		bne $ee18	          BNE TAIW_55         ; if tape bit high restore registers and exit IRQ
.ee35	c6 a7		dec $a7		          DEC RSI_In_Bit      ; decrement cycle count
.ee37	d0 df		bne $ee18	          BNE TAIW_55         ; if not all done restore registers and exit IRQ
.ee39	20 5a ed	jsr $ed5a	          JSR TAPE_Init_Byte
.ee3c	c6 ab		dec $ab		          DEC RSI_Parity      ; decrement cassette leader count
.ee3e	10 d8		bpl $ee18	          BPL TAIW_55         ; -> exit IRQ
.ee40	a2 0a		ldx #$0a	          LDX #10             ; switch IRQ to TAPE_IRQ_Write
.ee42	20 9b ee	jsr $ee9b	          JSR TAPE_Switch_IRQ
.ee45	58		cli		          CLI                 ; enable interrupts
.ee46	e6 ab		inc $ab		          INC RSI_Parity      ; clear cassette leader counter, was -1
.ee48	a5 be		lda $be		          LDA FSBLK           ; get cassette block count
.ee4a	f0 49		beq $ee95	          BEQ TSIO_30         ; if all done restore everything and exit IRQ
.ee4c	20 51 ed	jsr $ed51	          JSR STAL_To_SAL
.ee4f	a2 09		ldx #$09	          LDX #9              ; set 9 synchronisation bytes
.ee51	86 a5		stx $a5		          STX CNTDN           ; save cassette synchronization byte count
.ee53	86 b6		stx $b6		          STX RS_Out
.ee55	d0 82		bne $edd9	          BNE TAIW_30         ; go do next tape byte, branch always
.ee57					  TAPE_Stop_IO
.ee57	08		php		          PHP                 ; save status
.ee58	78		sei		          SEI                 ; disable interrupts
.ee59	ad 11 d0	lda $d011	          LDA VIC_Ctrl_1
.ee5c	0d 39 0a	ora $0a39	          ORA VSH_Ctrl_1
.ee5f	29 7f		and #$7f	          AND #%01111111     ; disable all interrupts
.ee61	8d 11 d0	sta $d011	          STA VIC_Ctrl_1
.ee64	2c 3a 0a	bit $0a3a	          BIT SPRITES
.ee67	30 16		bmi $ee7f	          BMI TSIO_10         ; -> don't change sprite enable flag
.ee69	2c 37 0a	bit $0a37	          BIT VSH_SPEED
.ee6c	10 11		bpl $ee7f	          BPL TSIO_10         ; -> sprites are on alreay
.ee6e	ad 38 0a	lda $0a38	          LDA VSH_SPR_ENA
.ee71	8d 15 d0	sta $d015	          STA VIC_SPR_ENA     ; restore sprite enable flag
.ee74	ad 37 0a	lda $0a37	          LDA VSH_SPEED
.ee77	8d 30 d0	sta $d030	          STA VIC_SPEED       ; restore speed
.ee7a	a9 00		lda #$00	          LDA #0
.ee7c	8d 37 0a	sta $0a37	          STA VSH_SPEED       ; clear shadow register
.ee7f	20 b0 ee	jsr $eeb0	TSIO_10   JSR TAPE_Stop_Motor
.ee82	20 b8 e1	jsr $e1b8	          JSR Test_Fast_IEC   ; reset IEC attributes
.ee85	ad 0a 0a	lda $0a0a	          LDA IRQTMP+1        ; restore IRQ vector
.ee88	f0 09		beq $ee93	          BEQ TSIO_20
.ee8a	8d 15 03	sta $0315	          STA IIRQ+1
.ee8d	ad 09 0a	lda $0a09	          LDA IRQTMP
.ee90	8d 14 03	sta $0314	          STA IIRQ
.ee93	28		plp		TSIO_20   PLP                 ; restore status
.ee94	60		rts		          RTS
.ee95	20 57 ee	jsr $ee57	TSIO_30   JSR TAPE_Stop_IO
.ee98	4c 33 ff	jmp $ff33	          JMP IRQ_Exit
.ee9b					  TAPE_Switch_IRQ
.ee9b	bd a0 ee	lda $eea0,x	          LDA TAPE_IRQ_Table-8,X  ; get tape IRQ vector low byte
.ee9e	8d 14 03	sta $0314	          STA IIRQ                ; set IRQ vector low byte
.eea1	bd a1 ee	lda $eea1,x	          LDA TAPE_IRQ_Table-7,X  ; get tape IRQ vector high byte
.eea4	8d 15 03	sta $0315	          STA IIRQ+1              ; set IRQ vector high byte
.eea7	60		rts		          RTS
.eea8					  TAPE_IRQ_Table
>eea8	2e ee				          .WORD TAPE_IRQ_Leader   ; write tape leader
>eeaa	90 ed				          .WORD TAPE_IRQ_Write    ; write data byte
>eeac	65 fa				          .WORD IRQ_Normal        ; default IRQ
>eeae	eb ea				          .WORD TAPE_IRQ_Read     ; read data byte
.eeb0					  TAPE_Stop_Motor
.eeb0	a5 01		lda $01		          LDA R8502
.eeb2	09 20		ora #$20	          ORA #%00100000     ;  cassette motor off
.eeb4	85 01		sta $01		          STA R8502
.eeb6	60		rts		          RTS
.eeb7					  Check_IO_End
.eeb7	38		sec		          SEC
.eeb8	a5 ac		lda $ac		          LDA SAL             ; get buffer address low byte
.eeba	e5 ae		sbc $ae		          SBC EAL             ; subtract buffer end low byte
.eebc	a5 ad		lda $ad		          LDA SAH             ; get buffer address high byte
.eebe	e5 af		sbc $af		          SBC EAH             ; subtract buffer end high byte
.eec0	60		rts		          RTS                 ; C=1 if SAL/H >= EAL/H
.eec1					  Inc_SAL_Word
.eec1	e6 ac		inc $ac		          INC SAL
.eec3	d0 02		bne $eec7	          BNE ISW_Ret
.eec5	e6 ad		inc $ad		          INC SAH
.eec7	60		rts		ISW_Ret   RTS
.eec8					  TAPE_Sim_IRQ
.eec8	08		php		          PHP
.eec9	68		pla		          PLA
.eeca	29 ef		and #$ef	          AND #%11101111     ; $ef set IRQ/BRK bit to IRQ
.eecc	48		pha		          PHA
.eecd	4c 17 ff	jmp $ff17	          JMP IRQ
.eed0					  TAPE_Switch_Sense
.eed0	a5 01		lda $01		          LDA R8502
.eed2	29 10		and #$10	          AND #%00010000     ; $10
.eed4	f0 0a		beq $eee0	          BEQ TSS_10          ; -> key pressed
.eed6	a0 00		ldy #$00	          LDY #0
.eed8	84 c0		sty $c0		          STY CAS1            ; motor flag = 0
.eeda	a5 01		lda $01		          LDA R8502
.eedc	09 20		ora #$20	          ORA #%00100000     ; $20 bit5 = 1 : motor off
.eede	d0 08		bne $eee8	          BNE TSS_20          ; always
.eee0	a5 c0		lda $c0		TSS_10    LDA CAS1            ; test motor flag
.eee2	d0 06		bne $eeea	          BNE TSS_Ret         ; -> motor is already on
.eee4	a5 01		lda $01		          LDA R8502
.eee6	29 df		and #$df	          AND #%11011111     ; $df bit5 = 0 : motor on
.eee8	85 01		sta $01		TSS_20    STA R8502           ; motor on or off
.eeea	60		rts		TSS_Ret   RTS
.eeeb					  GETIN
.eeeb	a5 99		lda $99		          LDA DFLTN           ; get input channel
.eeed	d0 0a		bne $eef9	          BNE GETIN_10        ; -> not keyboard
.eeef	a5 d0		lda $d0		          LDA NDX             ; keys in buffer
.eef1	05 d1		ora $d1		          ORA KYNDX           ; keys in function key buffer
.eef3	f0 0f		beq $ef04	          BEQ GETIN_30        ; -> no keys
.eef5	78		sei		          SEI
.eef6	4c 06 c0	jmp $c006	          JMP E_GETKEY        ; fetch byte from buffer or function key
.eef9	c9 02		cmp #$02	GETIN_10  CMP #2              ; input channel = RS232 ?
.eefb	d0 18		bne $ef15	          BNE BASIN_20           ; -> no
.eefd	84 97		sty $97		GETIN_20  STY XSAV            ; save Y
.eeff	20 ce e7	jsr $e7ce	          JSR RS_Read         ; fetch byte from RS232 input buffer
.ef02	a4 97		ldy $97		          LDY XSAV            ; restore Y
.ef04	18		clc		GETIN_30  CLC                 ; operation OK
.ef05	60		rts		          RTS
.ef06					  BASIN
.ef06	a5 99		lda $99		          LDA DFLTN           ; current input channel
.ef08	d0 0b		bne $ef15	          BNE BASIN_20        ; -> is not keyvoard
.ef0a	a5 ec		lda $ec		          LDA Cursor_Col
.ef0c	85 e9		sta $e9		          STA CurLst_Col      ; last cursor column
.ef0e	a5 eb		lda $eb		          LDA Cursor_Row
.ef10	85 e8		sta $e8		          STA CurLst_Row      ; last cursor row
.ef12	4c 09 c0	jmp $c009	BASIN_10  JMP E_GETSCR        ; get character from screen at cursor position
.ef15	c9 03		cmp #$03	BASIN_20  CMP #3              ; input channel = screen ?
.ef17	d0 09		bne $ef22	          BNE BASIN_30        ; -> no
.ef19	20 40 fc	jsr $fc40	          JSR Set_CRSW        ; patch: set CRSW and save Cursor_Row
.ef1c	a5 e7		lda $e7		          LDA Margin_Right
.ef1e	85 ea		sta $ea		          STA Cursor_End      ; define end of line
.ef20	b0 f0		bcs $ef12	          BCS BASIN_10        ; branch always (CMP #3)
.ef22	b0 38		bcs $ef5c	BASIN_30  BCS IEC_BASIN           ; -> channel > 3 : IEC device
.ef24	c9 02		cmp #$02	          CMP #2              ; RS232 interface ?
.ef26	f0 3f		beq $ef67	          BEQ RS232_BASIN           ; -> read from RS232 input buffer
.ef28	86 97		stx $97		          STX XSAV            ; save X
.ef2a	20 48 ef	jsr $ef48	          JSR TAPE_BASIN      ; get character from TAPE buffer
.ef2d	b0 16		bcs $ef45	          BCS BASIN_60        ; -> return on error
.ef2f	48		pha		          PHA                 ; push char
.ef30	20 48 ef	jsr $ef48	          JSR TAPE_BASIN      ; get next character from buffer
.ef33	b0 0d		bcs $ef42	          BCS BASIN_50        ; -> return on error
.ef35	d0 05		bne $ef3c	          BNE BASIN_40        ; -> unget character
.ef37	a9 40		lda #$40	          LDA #$40            ; set bit6 = EOF
.ef39	20 57 f7	jsr $f757	          JSR SETST           ; mark EOF status
.ef3c	c6 a6		dec $a6		BASIN_40  DEC BUFPT           ; unget character
.ef3e	a6 97		ldx $97		          LDX XSAV            ; restore X
.ef40	68		pla		          PLA                 ; restore read character
.ef41	60		rts		          RTS                 ; return
.ef42	aa		tax		BASIN_50  TAX                 ; X = read character
.ef43	68		pla		          PLA                 ; clean stack
.ef44	8a		txa		          TXA                 ; A = read character
.ef45	a6 97		ldx $97		BASIN_60  LDX XSAV            ; restore X
.ef47	60		rts		          RTS                 ; return
.ef48					  TAPE_BASIN
.ef48	20 be e9	jsr $e9be	          JSR TAPE_Advance_BUFPT
.ef4b	d0 0b		bne $ef58	          BNE TABA_10         ; -> not at end : get character
.ef4d	20 f2 e9	jsr $e9f2	          JSR TAPE_Read_Block ; read next block into buffer
.ef50	b0 09		bcs $ef5b	          BCS TABA_Ret        ; -> exit on error
.ef52	a9 00		lda #$00	          LDA #0
.ef54	85 a6		sta $a6		          STA BUFPT           ; reset buffer pointer
.ef56	f0 f0		beq $ef48	          BEQ TAPE_BASIN      ; -> branch always
.ef58	b1 b2		lda ($b2),y	TABA_10   LDA (TAPE1),Y       ; get character from TAPE buffer
.ef5a	18		clc		          CLC                 ; OK flag
.ef5b	60		rts		TABA_Ret  RTS                 ; return
.ef5c					  IEC_BASIN
.ef5c	a5 90		lda $90		          LDA STATUS          ; check I/O status
.ef5e	d0 03		bne $ef63	          BNE IEBA_10         ; -> cannot read
.ef60	4c 3e e4	jmp $e43e	          JMP ACPTR           ; -> read from IEC device
.ef63	a9 0d		lda #$0d	IEBA_10   LDA #CR             ; return CR if not able to read
.ef65	18		clc		IEBA_20   CLC                 ; OK flag
.ef66	60		rts		IEBA_Ret  RTS
.ef67					  RS232_BASIN
.ef67	20 fd ee	jsr $eefd	          JSR GETIN_20        ; get character from RS232 buffer
.ef6a	b0 f9		bcs $ef65	          BCS IEBA_20         ; exit on error
.ef6c	c9 00		cmp #$00	          CMP #0
.ef6e	d0 f6		bne $ef66	          BNE IEBA_Ret        ; -> not NULL
.ef70	ad 14 0a	lda $0a14	          LDA RS_Status
.ef73	29 60		and #$60	          AND #%01100000     ; $60 check DSR signal (bit 6)
.ef75	d0 ec		bne $ef63	          BNE IEBA_10         ; -> no DSR : load CR and exit
.ef77	f0 ee		beq $ef67	          BEQ RS232_BASIN     ; -> DSR signal : try again
.ef79					  BSOUT
.ef79	48		pha		          PHA                 ; save character
.ef7a	a5 9a		lda $9a		          LDA DFLTO
.ef7c	c9 03		cmp #$03	          CMP #3
.ef7e	d0 04		bne $ef84	          BNE BSOUT_10
.ef80	68		pla		          PLA                 ; restore character
.ef81	4c 0c c0	jmp $c00c	          JMP E_PRINT         ; print to screen (3)
.ef84	90 04		bcc $ef8a	BSOUT_10  BCC BSOUT_20        ; -> to tape (1) or RS232 (2)
.ef86	68		pla		          PLA
.ef87	4c 03 e5	jmp $e503	          JMP CIOUT           ; output to IEC device (> 3)
.ef8a	4a		lsr a		BSOUT_20  LSR A               ; C=1 for tape, C=0 for RS232
.ef8b	68		pla		          PLA                 ; restore output byte
.ef8c					  TAPE_RS232_BSOUT
.ef8c	85 9e		sta $9e		          STA PTR_LO          ; save character
.ef8e	8a		txa		          TXA
.ef8f	48		pha		          PHA                 ; save X
.ef90	98		tya		          TYA
.ef91	48		pha		          PHA                 ; save Y
.ef92	90 23		bcc $efb7	          BCC BSOUT_70        ; -> RS232 output
.ef94	20 be e9	jsr $e9be	          JSR TAPE_Advance_BUFPT
.ef97	d0 0e		bne $efa7	          BNE BSOUT_30        ; if not iat end store byte and exit
.ef99	20 15 ea	jsr $ea15	          JSR TAPE_Write_Buffer
.ef9c	b0 0e		bcs $efac	          BCS BSOUT_50        ; -> error
.ef9e	a9 02		lda #$02	          LDA #2              ; set data block type
.efa0	a0 00		ldy #$00	          LDY #0
.efa2	91 b2		sta ($b2),y	          STA (TAPE1),Y       ; save type to buffer
.efa4	c8		iny		          INY
.efa5	84 a6		sty $a6		          STY BUFPT           ; save tape buffer index
.efa7	a5 9e		lda $9e		BSOUT_30  LDA PTR_LO          ; restore character
.efa9	91 b2		sta ($b2),y	          STA (TAPE1),Y       ; store to buffer
.efab	18		clc		BSOUT_40  CLC                 ; flag no error
.efac	68		pla		BSOUT_50  PLA
.efad	a8		tay		          TAY                 ; pull Y
.efae	68		pla		          PLA
.efaf	aa		tax		          TAX                 ; pull X
.efb0	a5 9e		lda $9e		          LDA PTR_LO          ; restore output character
.efb2	90 02		bcc $efb6	          BCC BSOUT_60        ; -> exit if OK
.efb4	a9 00		lda #$00	          LDA #0              ; A=0 for error return
.efb6	60		rts		BSOUT_60  RTS
.efb7	20 5f e7	jsr $e75f	BSOUT_70  JSR RS_Write        ; write character to RS232 buffer
.efba	4c ab ef	jmp $efab	          JMP BSOUT_40        ; -> exit
.efbd					  OPEN
.efbd	a6 b8		ldx $b8		          LDX LA              ; logical address
.efbf	20 02 f2	jsr $f202	          JSR Lookup_X          ; look up entry in file tables
.efc2	f0 2f		beq $eff3	          BEQ OPEN_30         ; -> error: already open
.efc4	a6 98		ldx $98		          LDX LDTND           ; # of open files
.efc6	e0 0a		cpx #$0a	          CPX #10             ; compare with upper limit 10
.efc8	b0 26		bcs $eff0	          BCS OPEN_20         ; -> error: too many open files
.efca	e6 98		inc $98		          INC LDTND           ; increment # of open files
.efcc	a5 b8		lda $b8		          LDA LA              ; logical address
.efce	9d 62 03	sta $0362,x	          STA LAT,X           ; table of LA's
.efd1	a5 b9		lda $b9		          LDA SA              ; secondary address
.efd3	09 60		ora #$60	          ORA #%01100000     ; OR with $60
.efd5	85 b9		sta $b9		          STA SA              ; store it
.efd7	9d 76 03	sta $0376,x	          STA SAT,X           ; table of SA's
.efda	a5 ba		lda $ba		          LDA FA              ; first address (device/unit)
.efdc	9d 6c 03	sta $036c,x	          STA FAT,X           ; table of FA's
.efdf	f0 0d		beq $efee	          BEQ OPEN_10         ; -> open keyboard: no further action
.efe1	c9 02		cmp #$02	          CMP #2              ; RS232 device ?
.efe3	f0 5b		beq $f040	          BEQ RS_OPEN         ; -> open RS232 channel
.efe5	90 0f		bcc $eff6	          BCC TAPE_OPEN       ; -> device = 1 (tape)
.efe7	c9 03		cmp #$03	          CMP #3              ; screen device ?
.efe9	f0 03		beq $efee	          BEQ OPEN_10         ; -> open screen: no further action
.efeb	20 cb f0	jsr $f0cb	          JSR IEC_OPEN        ; device >= 4: open IEC device
.efee	18		clc		OPEN_10   CLC                 ; flag: OK
.efef	60		rts		          RTS                 ; return
.eff0	4c 7c f6	jmp $f67c	OPEN_20   JMP Too_Many_Files           ; error
.eff3	4c 7f f6	jmp $f67f	OPEN_30   JMP File_Open_Err           ; error
.eff6					  TAPE_OPEN
.eff6	20 80 e9	jsr $e980	          JSR TAPE_XY_Check
.eff9	b0 03		bcs $effe	          BCS TAOP_10
.effb	4c 94 f6	jmp $f694	          JMP Illegal_Device_Number           ; -> illeagl device number
.effe	a5 b9		lda $b9		TAOP_10   LDA SA
.f000	29 0f		and #$0f	          AND #%00001111     ; $0f
.f002	d0 1f		bne $f023	          BNE TAOP_40         ; -> open for write
.f004	20 c8 e9	jsr $e9c8	          JSR TAPE_Wait_for_Play
.f007	b0 36		bcs $f03f	          BCS TAOP_Ret        ; -> error
.f009	20 0f f5	jsr $f50f	          JSR Searching       ; display SEARCHING
.f00c	a5 b7		lda $b7		          LDA FNLEN           ; filename length
.f00e	f0 0a		beq $f01a	          BEQ TAOP_30         ; -> not specified: find any file
.f010	20 9a e9	jsr $e99a	          JSR TAPE_Find_File  ; look for named file
.f013	90 18		bcc $f02d	          BCC TAOP_50         ; -> found
.f015	f0 28		beq $f03f	          BEQ TAOP_Ret        ; -> forced STOP
.f017	4c 85 f6	jmp $f685	TAOP_20   JMP File_Not_Found
.f01a	20 d0 e8	jsr $e8d0	TAOP_30   JSR TAPE_Find_Header
.f01d	90 0e		bcc $f02d	          BCC TAOP_50         ; -> found
.f01f	f0 1e		beq $f03f	          BEQ TAOP_Ret        ; -> forced STOP
.f021	b0 f4		bcs $f017	          BCS TAOP_20         ; always
.f023	20 e9 e9	jsr $e9e9	TAOP_40   JSR TAPE_Wait_For_Record
.f026	b0 17		bcs $f03f	          BCS TAOP_Ret        ; -> error
.f028	a9 04		lda #$04	          LDA #4              ; -> header type: 1st. block of data
.f02a	20 19 e9	jsr $e919	          JSR TAPE_Write_Program_Header
.f02d	a9 bf		lda #$bf	TAOP_50   LDA #$bf            ; 191 = last buffer index
.f02f	a4 b9		ldy $b9		          LDY SA
.f031	c0 60		cpy #$60	          CPY #$60            ; SA = 60 ?
.f033	f0 07		beq $f03c	          BEQ TAOP_60         ; -> PRG file
.f035	a0 00		ldy #$00	          LDY #0              ; 1st. buffer index
.f037	a9 02		lda #$02	          LDA #2              ; type 2: data block
.f039	91 b2		sta ($b2),y	          STA (TAPE1),Y       ; store header info
.f03b	98		tya		          TYA                 ; A = index
.f03c	85 a6		sta $a6		TAOP_60   STA BUFPT           ; save buffer index
.f03e	18		clc		          CLC                 ; flag OK
.f03f	60		rts		TAOP_Ret  RTS                 ; return
.f040					  RS_OPEN
.f040	20 b0 f0	jsr $f0b0	          JSR RS_Init_CIA
.f043	8c 14 0a	sty $0a14	          STY RS_Status       ; Y = 0
.f046	c4 b7		cpy $b7		RSOP_10   CPY FNLEN
.f048	f0 0b		beq $f055	          BEQ RSOP_20
.f04a	20 ae f7	jsr $f7ae	          JSR Get_Filename_Char
.f04d	99 10 0a	sta $0a10,y	          STA RS_Control,Y    ; get RS232 parameter
.f050	c8		iny		          INY
.f051	c0 04		cpy #$04	          CPY #4
.f053	d0 f1		bne $f046	          BNE RSOP_10
.f055	20 8e e6	jsr $e68e	RSOP_20   JSR RS_Set_Databits
.f058	8e 15 0a	stx $0a15	          STX RS_Bits
.f05b	ad 10 0a	lda $0a10	          LDA RS_Control
.f05e	29 0f		and #$0f	          AND #%00001111     ; $0f
.f060	f0 1c		beq $f07e	          BEQ RSOP_50         ; -> user baudrate
.f062	0a		asl a		          ASL A
.f063	aa		tax		          TAX                 ; index to baudrate table
.f064	ad 03 0a	lda $0a03	          LDA PALNTS          ; check PAL or NTSC
.f067	d0 09		bne $f072	          BNE RSOP_30         ; -> use PAL  values
.f069	bc 4f e8	ldy $e84f,x	          LDY RS_Baud_NTSC-1,X
.f06c	bd 4e e8	lda $e84e,x	          LDA RS_Baud_NTSC-2,X
.f06f	4c 78 f0	jmp $f078	          JMP RSOP_40
.f072	bc 63 e8	ldy $e863,x	RSOP_30   LDY RS_Baud_PAL-1,X
.f075	bd 62 e8	lda $e862,x	          LDA RS_Baud_PAL-2,X
.f078	8c 13 0a	sty $0a13	RSOP_40   STY RS_Baudrate+1
.f07b	8d 12 0a	sta $0a12	          STA RS_Baudrate
.f07e	ad 12 0a	lda $0a12	RSOP_50   LDA RS_Baudrate     ; X/Y = baudrate * 2
.f081	0a		asl a		          ASL A
.f082	aa		tax		          TAX
.f083	ad 13 0a	lda $0a13	          LDA RS_Baudrate+1
.f086	2a		rol a		          ROL A
.f087	a8		tay		          TAY
.f088	8a		txa		          TXA
.f089	69 c8		adc #$c8	          ADC #$c8            ; add 200
.f08b	8d 16 0a	sta $0a16	          STA RS_Timer_Lo
.f08e	98		tya		          TYA
.f08f	69 00		adc #$00	          ADC #0
.f091	8d 17 0a	sta $0a17	          STA RS_Timer_Hi     ; timer = baudrate * 2 + 200
.f094	ad 11 0a	lda $0a11	          LDA RS_Command
.f097	4a		lsr a		          LSR A
.f098	90 09		bcc $f0a3	          BCC RSOP_60         ; -> 3 wire handshake
.f09a	ad 01 dd	lda $dd01	          LDA CIA2_PRB
.f09d	30 04		bmi $f0a3	          BMI RSOP_60         ; -> DSR set
.f09f	20 55 e7	jsr $e755	          JSR RS_DSR_Missing
.f0a2	18		clc		          CLC
.f0a3	ad 18 0a	lda $0a18	RSOP_60   LDA RS_IBP_End      ; sync buffer pointer (buffer empty)
.f0a6	8d 19 0a	sta $0a19	          STA RS_IBP_Beg
.f0a9	ad 1b 0a	lda $0a1b	          LDA RS_OBP_End
.f0ac	8d 1a 0a	sta $0a1a	          STA RS_OBP_Beg
.f0af	60		rts		          RTS
.f0b0					  RS_Init_CIA
.f0b0	a9 7f		lda #$7f	          LDA #$7f            ; enable interrupts
.f0b2	8d 0d dd	sta $dd0d	          STA CIA2_ICR
.f0b5	a9 06		lda #$06	          LDA #6              ; set DTR & RTS to output
.f0b7	8d 03 dd	sta $dd03	          STA CIA2_DDRB
.f0ba	8d 01 dd	sta $dd01	          STA CIA2_PRB
.f0bd	a9 04		lda #$04	          LDA #4              ; set DTR & RTS to high
.f0bf	0d 00 dd	ora $dd00	          ORA CIA2_PRA
.f0c2	8d 00 dd	sta $dd00	          STA CIA2_PRA
.f0c5	a0 00		ldy #$00	          LDY #0              ; disable all RS interrupts
.f0c7	8c 0f 0a	sty $0a0f	          STY RS_Enable
.f0ca	60		rts		          RTS
.f0cb					  IEC_OPEN
.f0cb	a5 b9		lda $b9		          LDA SA
.f0cd	30 04		bmi $f0d3	          BMI IEOP_10         ; -> no SA set
.f0cf	a4 b7		ldy $b7		          LDY FNLEN
.f0d1	d0 02		bne $f0d5	          BNE IEOP_20         ; -> filename given
.f0d3	18		clc		IEOP_10   CLC                 ; clear carry for OK
.f0d4	60		rts		          RTS
.f0d5	a9 00		lda #$00	IEOP_20   LDA #0
.f0d7	85 90		sta $90		          STA STATUS          ; clear status bits
.f0d9	a5 ba		lda $ba		          LDA FA
.f0db	20 3e e3	jsr $e33e	          JSR LISTN           ; IEC listen
.f0de	24 90		bit $90		          BIT STATUS
.f0e0	30 0b		bmi $f0ed	          BMI IEOP_30         ; -> device not present
.f0e2	a5 b9		lda $b9		          LDA SA
.f0e4	09 f0		ora #$f0	          ORA #%11110000     ; $f0
.f0e6	20 d2 e4	jsr $e4d2	          JSR SECND           ; send SA
.f0e9	a5 90		lda $90		          LDA STATUS
.f0eb	10 05		bpl $f0f2	          BPL IEOP_40         ; -> OK
.f0ed	68		pla		IEOP_30   PLA                 ; remove return address
.f0ee	68		pla		          PLA                 ; jump to error routine
.f0ef	4c 88 f6	jmp $f688	          JMP Device_Not_Present
.f0f2					IEOP_40
.f0f2	a5 b7		lda $b7		          LDA FNLEN           ; redundant: was already
.f0f4	f0 0d		beq $f103	          BEQ IEOP_60         ; checked at entry
.f0f6	a0 00		ldy #$00	          LDY #0
.f0f8	20 ae f7	jsr $f7ae	IEOP_50   JSR Get_Filename_Char
.f0fb	20 03 e5	jsr $e503	          JSR CIOUT           ; send filename
.f0fe	c8		iny		          INY
.f0ff	c4 b7		cpy $b7		          CPY FNLEN
.f101	d0 f5		bne $f0f8	          BNE IEOP_50         ; loop
.f103	4c b0 f5	jmp $f5b0	IEOP_60   JMP IEC_Unlisten           ; UNLSN CLC and RTS
>f106					          .FILL $f106-* ,0
.f106					  CHKIN
.f106	20 02 f2	jsr $f202	          JSR Lookup_X
.f109	d0 3e		bne $f149	          BNE CHKERR_4        ; -> FILE NOT OPEN
.f10b	20 12 f2	jsr $f212	          JSR Get_LASAFA
.f10e	f0 13		beq $f123	          BEQ CHKIN_10        ; -> input from keyboard
.f110	c9 03		cmp #$03	          CMP #3
.f112	f0 0f		beq $f123	          BEQ CHKIN_10        ; -> input from screen
.f114	b0 11		bcs $f127	          BCS CHKIN_20        ; -> input from IEC
.f116	c9 02		cmp #$02	          CMP #2
.f118	d0 03		bne $f11d	          BNE IEC_CHKIN       ; -> input from IEC
.f11a	4c 95 e7	jmp $e795	          JMP RS_CHKIN        ; -> input from RS232
.f11d					  IEC_CHKIN
.f11d	a6 b9		ldx $b9		          LDX SA
.f11f	e0 60		cpx #$60	          CPX #$60            ; SA for LOAD ?
.f121	d0 20		bne $f143	          BNE CHKERR_2
.f123	85 99		sta $99		CHKIN_10  STA DFLTN           ; set unit for input
.f125	18		clc		          CLC                 ; flag OK
.f126	60		rts		          RTS
.f127	aa		tax		CHKIN_20  TAX                 ; device / unit
.f128	20 3b e3	jsr $e33b	          JSR TALK
.f12b	24 90		bit $90		          BIT STATUS
.f12d	30 11		bmi $f140	          BMI CHKERR_1
.f12f	a5 b9		lda $b9		          LDA SA
.f131	10 05		bpl $f138	          BPL CHKIN_30
.f133	20 e9 e4	jsr $e4e9	          JSR IEC_ATN_High_Exit
.f136	10 03		bpl $f13b	          BPL CHKIN_40
.f138	20 e0 e4	jsr $e4e0	CHKIN_30  JSR TKSA
.f13b	8a		txa		CHKIN_40  TXA
.f13c	24 90		bit $90		          BIT STATUS
.f13e	10 e3		bpl $f123	          BPL CHKIN_10
.f140	4c 88 f6	jmp $f688	CHKERR_1  JMP Device_Not_Present
.f143	4c 8b f6	jmp $f68b	CHKERR_2  JMP Not_Input_File
.f146	4c 8e f6	jmp $f68e	CHKERR_3  JMP Not_Output_File
.f149	4c 82 f6	jmp $f682	CHKERR_4  JMP File_Not_Open
.f14c					  CKOUT
.f14c	20 02 f2	jsr $f202	          JSR Lookup_X
.f14f	d0 f8		bne $f149	          BNE CHKERR_4        ; -> FILE NOT OPEN
.f151	20 12 f2	jsr $f212	          JSR Get_LASAFA
.f154	f0 f0		beq $f146	          BEQ CHKERR_3        ; -> cannot output to keyboard
.f156	c9 03		cmp #$03	          CMP #3
.f158	f0 0f		beq $f169	          BEQ CKOUT_20        ; -> output to screen
.f15a	b0 11		bcs $f16d	          BCS IEC_CKOUT
.f15c	c9 02		cmp #$02	          CMP #2
.f15e	d0 03		bne $f163	          BNE CKOUT_10
.f160	4c 29 e7	jmp $e729	          JMP RS_CKOUT        ; -> output to RS232
.f163	a6 b9		ldx $b9		CKOUT_10  LDX SA
.f165	e0 60		cpx #$60	          CPX #$60            ; -> SA for LOAD ?
.f167	f0 dd		beq $f146	          BEQ CHKERR_3        ; -> cannot use LOAD SA for output
.f169	85 9a		sta $9a		CKOUT_20  STA DFLTO           ; -> select output device
.f16b	18		clc		CKOUT_30  CLC                 ; -> flag OK
.f16c	60		rts		          RTS
.f16d					  IEC_CKOUT
.f16d	aa		tax		          TAX                 ; X = unit
.f16e	20 3e e3	jsr $e33e	          JSR LISTN           ; LISTEN
.f171	24 90		bit $90		          BIT STATUS
.f173	30 cb		bmi $f140	          BMI CHKERR_1        ; -> device not present
.f175	a5 b9		lda $b9		          LDA SA
.f177	10 05		bpl $f17e	          BPL CKOUT_40
.f179	20 d7 e4	jsr $e4d7	          JSR IEC_ATN_OUT_High
.f17c	d0 03		bne $f181	          BNE CKOUT_50
.f17e	20 d2 e4	jsr $e4d2	CKOUT_40  JSR SECND
.f181	8a		txa		CKOUT_50  TXA
.f182	24 90		bit $90		          BIT STATUS
.f184	10 e3		bpl $f169	          BPL CKOUT_20        ; -> OK
.f186	30 b8		bmi $f140	          BMI CHKERR_1        ; always
.f188					  CLOSE
.f188	66 92		ror $92		          ROR SVXT
.f18a	20 07 f2	jsr $f207	          JSR Lookup_A
.f18d	d0 dc		bne $f16b	          BNE CKOUT_30        ; -> not found: return
.f18f	20 12 f2	jsr $f212	          JSR Get_LASAFA
.f192	8a		txa		          TXA
.f193	48		pha		          PHA                 ; push table index
.f194	a5 ba		lda $ba		          LDA FA
.f196	f0 4c		beq $f1e4	          BEQ CLOSE_50        ; -> close keyboard channel
.f198	c9 03		cmp #$03	          CMP #3
.f19a	f0 48		beq $f1e4	          BEQ CLOSE_50        ; -> close screen channel
.f19c	b0 31		bcs $f1cf	          BCS CLOSE_30        ; -> close IEC device
.f19e	c9 02		cmp #$02	          CMP #2
.f1a0	d0 07		bne $f1a9	          BNE CLOSE_10        ; -> close TAPE channel
.f1a2	68		pla		          PLA
.f1a3	20 e5 f1	jsr $f1e5	          JSR Remove_Filehandle
.f1a6	4c b0 f0	jmp $f0b0	          JMP RS_Init_CIA
.f1a9	a5 b9		lda $b9		CLOSE_10  LDA SA
.f1ab	29 0f		and #$0f	          AND #$0f
.f1ad	f0 35		beq $f1e4	          BEQ CLOSE_50        ; -> close input file
.f1af	20 80 e9	jsr $e980	          JSR TAPE_XY_Check
.f1b2	a9 00		lda #$00	          LDA #0
.f1b4	38		sec		          SEC
.f1b5	20 8c ef	jsr $ef8c	          JSR TAPE_RS232_BSOUT
.f1b8	20 15 ea	jsr $ea15	          JSR TAPE_Write_Buffer
.f1bb	90 04		bcc $f1c1	          BCC CLOSE_20
.f1bd	68		pla		          PLA
.f1be	a9 00		lda #$00	          LDA #0
.f1c0	60		rts		          RTS
.f1c1	a5 b9		lda $b9		CLOSE_20  LDA SA
.f1c3	c9 62		cmp #$62	          CMP #$62
.f1c5	d0 1d		bne $f1e4	          BNE CLOSE_50
.f1c7	a9 05		lda #$05	          LDA #5              ; write EOT marker
.f1c9	20 19 e9	jsr $e919	          JSR TAPE_Write_Program_Header
.f1cc	4c e4 f1	jmp $f1e4	          JMP CLOSE_50
.f1cf	24 92		bit $92		CLOSE_30  BIT SVXT
.f1d1	10 0e		bpl $f1e1	          BPL CLOSE_40
.f1d3	a5 ba		lda $ba		          LDA FA
.f1d5	c9 08		cmp #$08	          CMP #8
.f1d7	90 08		bcc $f1e1	          BCC CLOSE_40        ; -> not a disc device
.f1d9	a5 b9		lda $b9		          LDA SA
.f1db	29 0f		and #$0f	          AND #%00001111 ; $0f
.f1dd	c9 0f		cmp #$0f	          CMP #15
.f1df	f0 03		beq $f1e4	          BEQ CLOSE_50        ; command channel
.f1e1	20 9e f5	jsr $f59e	CLOSE_40  JSR IEC_Close
.f1e4	68		pla		CLOSE_50  PLA
.f1e5					  Remove_Filehandle
.f1e5	aa		tax		          TAX
.f1e6	c6 98		dec $98		          DEC LDTND
.f1e8	e4 98		cpx $98		          CPX LDTND
.f1ea	f0 14		beq $f200	          BEQ ReFi_10
.f1ec	a4 98		ldy $98		          LDY LDTND
.f1ee	b9 62 03	lda $0362,y	          LDA LAT,Y
.f1f1	9d 62 03	sta $0362,x	          STA LAT,X
.f1f4	b9 6c 03	lda $036c,y	          LDA FAT,Y
.f1f7	9d 6c 03	sta $036c,x	          STA FAT,X
.f1fa	b9 76 03	lda $0376,y	          LDA SAT,Y
.f1fd	9d 76 03	sta $0376,x	          STA SAT,X
.f200	18		clc		ReFi_10   CLC
.f201	60		rts		          RTS
.f202					  Lookup_X
.f202	a9 00		lda #$00	          LDA #0
.f204	85 90		sta $90		          STA STATUS
.f206	8a		txa		          TXA
.f207					  Lookup_A
.f207	a6 98		ldx $98		          LDX LDTND
.f209	ca		dex		LoUp_10   DEX
.f20a	30 05		bmi $f211	          BMI LoUp_Ret
.f20c	dd 62 03	cmp $0362,x	          CMP LAT,X
.f20f	d0 f8		bne $f209	          BNE LoUp_10
.f211	60		rts		LoUp_Ret  RTS
.f212					  Get_LASAFA
.f212	bd 62 03	lda $0362,x	          LDA LAT,X
.f215	85 b8		sta $b8		          STA LA
.f217	bd 76 03	lda $0376,x	          LDA SAT,X
.f21a	85 b9		sta $b9		          STA SA
.f21c	bd 6c 03	lda $036c,x	          LDA FAT,X
.f21f	85 ba		sta $ba		          STA FA
.f221	60		rts		          RTS
.f222					  CLALL
.f222	a9 00		lda #$00	          LDA #0
.f224	85 98		sta $98		          STA LDTND           ; clear file open table
.f226					  CLRCH
.f226	a2 03		ldx #$03	          LDX #3
.f228	e4 9a		cpx $9a		          CPX DFLTO
.f22a	b0 03		bcs $f22f	          BCS CLRCH_10
.f22c	20 26 e5	jsr $e526	          JSR UNLSN           ; UNLISTEN if IEC device
.f22f	e4 99		cpx $99		CLRCH_10  CPX DFLTN
.f231	b0 03		bcs $f236	          BCS CLRCH_20
.f233	20 15 e5	jsr $e515	          JSR UNTLK           ; UNTALK if IEC device
.f236	86 9a		stx $9a		CLRCH_20  STX DFLTO
.f238	a9 00		lda #$00	          LDA #0
.f23a	85 99		sta $99		          STA DFLTN
.f23c	60		rts		          RTS
.f23d					  CLOALL
.f23d	85 ba		sta $ba		          STA FA              ; closing device
.f23f	c5 9a		cmp $9a		          CMP DFLTO           ; active output device ?
.f241	d0 05		bne $f248	          BNE CLOA_10         ; -> no
.f243	a9 03		lda #$03	          LDA #3
.f245	85 9a		sta $9a		          STA DFLTO           ; reset active output
>f247	2c				          .byte $2c ;BIT
.f248	c5 99		cmp $99		CLOA_10   CMP DFLTN           ; active input device ?
.f24a	d0 04		bne $f250	          BNE CLOA_20         ; -> no
.f24c	a9 00		lda #$00	          LDA #0
.f24e	85 99		sta $99		          STA DFLTN           ; reset active input
.f250	a5 ba		lda $ba		CLOA_20   LDA FA
.f252	a6 98		ldx $98		          LDX LDTND           ; # of open channels
.f254	ca		dex		CLOA_30   DEX
.f255	30 0d		bmi $f264	          BMI CLOA_Ret        ; -> done
.f257	dd 6c 03	cmp $036c,x	          CMP FAT,X           ; device to close ?
.f25a	d0 f8		bne $f254	          BNE CLOA_30         ; -> no
.f25c	bd 62 03	lda $0362,x	          LDA LAT,X
.f25f	20 c3 ff	jsr $ffc3	          JSR K_CLOSE         ; -> close this channel
.f262	90 ec		bcc $f250	          BCC CLOA_20         ; loop if OK
.f264	60		rts		CLOA_Ret  RTS
.f265					  LOAD_AXY
.f265	86 c3		stx $c3		          STX MEMUSS
.f267	84 c4		sty $c4		          STY MEMUSS+1
.f269					  LOADSP_MEM
.f269	6c 30 03	jmp ($0330)	          JMP (ILOAD)         ; default -> D_LOADSP
.f26c					  D_LOADSP
.f26c	85 93		sta $93		          STA K_VERCK         ; verify flag
.f26e	a9 00		lda #$00	          LDA #0
.f270	85 90		sta $90		          STA STATUS          ; clear status
.f272	a5 ba		lda $ba		          LDA FA
.f274	c9 04		cmp #$04	          CMP #4
.f276	b0 03		bcs $f27b	          BCS LOAD_10         ; -> IEC  load
.f278	4c 26 f3	jmp $f326	          JMP TAPE_LOAD       ; -> TAPE load
.f27b	ad 1c 0a	lda $0a1c	LOAD_10   LDA Fast_IEC
.f27e	29 be		and #$be	          AND #%10111110     ; $be clear burst mode bit 6
.f280	8d 1c 0a	sta $0a1c	          STA Fast_IEC        ; should be $bf ?
.f283	a6 b9		ldx $b9		          LDX SA
.f285	86 9e		stx $9e		          STX PTR_LO          ; save SA
.f287	a4 b7		ldy $b7		          LDY FNLEN
.f289	d0 03		bne $f28e	          BNE LOAD_20         ; -> filename given
.f28b	4c 1a f3	jmp $f31a	          JMP Err_Missing_File_Name
.f28e	84 9f		sty $9f		LOAD_20   STY PTR_HI          ; save FNLEN
.f290	20 0f f5	jsr $f50f	          JSR Searching
.f293	20 a1 f3	jsr $f3a1	          JSR BURST_LOAD      ; try burst load
.f296	b0 03		bcs $f29b	          BCS LOAD_30         ; -> continue with slow load
.f298	4c 9b f3	jmp $f39b	          JMP LOAD_Done       ; -> finish
.f29b	a4 9f		ldy $9f		LOAD_30   LDY PTR_HI          ; saved   FNLEN
.f29d	84 b7		sty $b7		          STY FNLEN           ; restore FNLEN
.f29f	a9 60		lda #$60	          LDA #$60            ; special value for LOAD protocol
.f2a1	85 b9		sta $b9		          STA SA
.f2a3	20 cb f0	jsr $f0cb	          JSR IEC_OPEN        ; open file for LOAD
.f2a6	a5 ba		lda $ba		          LDA FA
.f2a8	20 3b e3	jsr $e33b	          JSR TALK            ; talk
.f2ab	a5 b9		lda $b9		          LDA SA
.f2ad	20 e0 e4	jsr $e4e0	          JSR TKSA            ; talk secondary
.f2b0	20 3e e4	jsr $e43e	          JSR ACPTR           ; Load address low
.f2b3	85 ae		sta $ae		          STA EAL
.f2b5	20 3e e4	jsr $e43e	          JSR ACPTR           ; Load address high
.f2b8	85 af		sta $af		          STA EAH
.f2ba	a5 90		lda $90		          LDA STATUS
.f2bc	4a		lsr a		          LSR A
.f2bd	4a		lsr a		          LSR A               ; C = bit 6 EOI
.f2be	b0 57		bcs $f317	          BCS Err_File_Not_Found
.f2c0	a5 9e		lda $9e		          LDA PTR_LO          ; saved SA
.f2c2	d0 08		bne $f2cc	          BNE LOAD_40         ; -> use load address from file
.f2c4	a5 c3		lda $c3		          LDA MEMUSS
.f2c6	85 ae		sta $ae		          STA EAL             ; overwrite load address
.f2c8	a5 c4		lda $c4		          LDA MEMUSS+1
.f2ca	85 af		sta $af		          STA EAH
.f2cc	20 4a fc	jsr $fc4a	LOAD_40   JSR EA_to_SA        ; copy EA to SA
.f2cf	a9 fd		lda #$fd	LOAD_50   LDA #$fd
.f2d1	25 90		and $90		          AND STATUS          ; clear bit 1 (time out read)
.f2d3	85 90		sta $90		          STA STATUS
.f2d5	20 e1 ff	jsr $ffe1	          JSR K_STOP          ; STOP key pressed ?
.f2d8	f0 49		beq $f323	          BEQ Stop_Load       ; -> close file and stop loading
.f2da	20 3e e4	jsr $e43e	          JSR ACPTR           ; read next byte
.f2dd	aa		tax		          TAX                 ; save it in X
.f2de	a5 90		lda $90		          LDA STATUS
.f2e0	4a		lsr a		          LSR A
.f2e1	4a		lsr a		          LSR A
.f2e2	b0 eb		bcs $f2cf	          BCS LOAD_50         ; -> time out: try again
.f2e4	8a		txa		          TXA                 ; A = read byte
.f2e5	a4 93		ldy $93		          LDY K_VERCK         ; verify flag
.f2e7	f0 12		beq $f2fb	          BEQ LOAD_60         ; -> loading
.f2e9	85 bd		sta $bd		          STA RS_Parity       ; store read byte
.f2eb	a0 00		ldy #$00	          LDY #0
.f2ed	20 c9 f7	jsr $f7c9	          JSR LDA_IND_EAL
.f2f0	c5 bd		cmp $bd		          CMP RS_Parity       ; verify
.f2f2	f0 0a		beq $f2fe	          BEQ LOAD_70         ; -> OK
.f2f4	a9 10		lda #$10	          LDA #16             ; bit 4: set verify error
.f2f6	20 57 f7	jsr $f757	          JSR SETST
.f2f9	d0 03		bne $f2fe	          BNE LOAD_70         ; always
.f2fb	20 bf f7	jsr $f7bf	LOAD_60   JSR STA_IND_EAL     ; store read byte
.f2fe	e6 ae		inc $ae		LOAD_70   INC EAL             ; increment load address
.f300	d0 08		bne $f30a	          BNE LOAD_80
.f302	e6 af		inc $af		          INC EAH
.f304	a5 af		lda $af		          LDA EAH             ; check for memory overflow $ff00
.f306	c9 ff		cmp #$ff	          CMP #$ff
.f308	f0 16		beq $f320	          BEQ Err_Break_IO
.f30a	24 90		bit $90		LOAD_80   BIT STATUS          ; check bit 6 EOI
.f30c	50 c1		bvc $f2cf	          BVC LOAD_50         ; -> loop
.f30e	20 15 e5	jsr $e515	          JSR UNTLK           ; start exit procedure
.f311	20 9e f5	jsr $f59e	          JSR IEC_Close
.f314	4c 9b f3	jmp $f39b	          JMP LOAD_Done
.f317					Err_File_Not_Found
.f317	4c 85 f6	jmp $f685	          JMP File_Not_Found
.f31a					Err_Missing_File_Name
.f31a	4c 91 f6	jmp $f691	          JMP Missing_File_Name
.f31d					Err_Illegal_Device_Number
.f31d	4c 94 f6	jmp $f694	          JMP Illegal_Device_Number
.f320					Err_Break_IO
.f320	4c 97 f6	jmp $f697	          JMP Break_IO
.f323	4c b5 f5	jmp $f5b5	Stop_Load JMP Err_IEC_Close
.f326					  TAPE_LOAD
.f326	c9 01		cmp #$01	          CMP #1              ; check device = 1
.f328	d0 f3		bne $f31d	          BNE Err_Illegal_Device_Number
.f32a	20 80 e9	jsr $e980	          JSR TAPE_XY_Check
.f32d	90 ee		bcc $f31d	          BCC Err_Illegal_Device_Number
.f32f	20 c8 e9	jsr $e9c8	          JSR TAPE_Wait_for_Play
.f332	b0 6c		bcs $f3a0	          BCS LOAD_Ret        ; time out
.f334	20 0f f5	jsr $f50f	          JSR Searching
.f337	a5 b7		lda $b7		TALO_10   LDA FNLEN
.f339	f0 09		beq $f344	          BEQ TALO_20         ; -> load next file
.f33b	20 9a e9	jsr $e99a	          JSR TAPE_Find_File
.f33e	90 0b		bcc $f34b	          BCC TALO_30         ; -> found
.f340	f0 5e		beq $f3a0	          BEQ LOAD_Ret        ; -> STOP key
.f342	b0 d3		bcs $f317	          BCS Err_File_Not_Found
.f344	20 d0 e8	jsr $e8d0	TALO_20   JSR TAPE_Find_Header
.f347	f0 57		beq $f3a0	          BEQ LOAD_Ret        ; -> STOP key
.f349	b0 cc		bcs $f317	          BCS Err_File_Not_Found
.f34b	38		sec		TALO_30   SEC
.f34c	a5 90		lda $90		          LDA STATUS
.f34e	29 10		and #$10	          AND #%00010000     ; $10 bit 4: verify error
.f350	d0 4e		bne $f3a0	          BNE LOAD_Ret
.f352	e0 01		cpx #$01	          CPX #1              ; 1 = BASIC program
.f354	f0 11		beq $f367	          BEQ TALO_50         ; -> load BASIC program
.f356	e0 03		cpx #$03	          CPX #3              ; 3 = binary program
.f358	d0 dd		bne $f337	          BNE TALO_10         ; not a program -> search again
.f35a	a0 01		ldy #$01	TALO_40   LDY #1
.f35c	b1 b2		lda ($b2),y	          LDA (TAPE1),Y       ; byte 1: load address low
.f35e	85 c3		sta $c3		          STA MEMUSS
.f360	c8		iny		          INY
.f361	b1 b2		lda ($b2),y	          LDA (TAPE1),Y       ; byte 2: load address high
.f363	85 c4		sta $c4		          STA MEMUSS+1
.f365	b0 04		bcs $f36b	          BCS TALO_60
.f367	a5 b9		lda $b9		TALO_50   LDA SA
.f369	d0 ef		bne $f35a	          BNE TALO_40         ; SA != 0 -> absolute load
.f36b	a0 03		ldy #$03	TALO_60   LDY #3
.f36d	b1 b2		lda ($b2),y	          LDA (TAPE1),Y       ; byte 3: end address low
.f36f	a0 01		ldy #$01	          LDY #1
.f371	f1 b2		sbc ($b2),y	          SBC (TAPE1),Y
.f373	aa		tax		          TAX
.f374	a0 04		ldy #$04	          LDY #4
.f376	b1 b2		lda ($b2),y	          LDA (TAPE1),Y       ; byte 4: end address high
.f378	a0 02		ldy #$02	          LDY #2
.f37a	f1 b2		sbc ($b2),y	          SBC (TAPE1),Y
.f37c	a8		tay		          TAY                 ; X/Y = file length
.f37d	18		clc		          CLC
.f37e	8a		txa		          TXA
.f37f	65 c3		adc $c3		          ADC MEMUSS          ; check if file fits into memory
.f381	85 ae		sta $ae		          STA EAL
.f383	98		tya		          TYA
.f384	65 c4		adc $c4		          ADC MEMUSS+1
.f386	85 af		sta $af		          STA EAH
.f388	c9 ff		cmp #$ff	          CMP #$ff
.f38a	f0 94		beq $f320	          BEQ Err_Break_IO
.f38c	a5 c3		lda $c3		          LDA MEMUSS          ; set start address
.f38e	85 c1		sta $c1		          STA STAL
.f390	a5 c4		lda $c4		          LDA MEMUSS+1
.f392	85 c2		sta $c2		          STA STAH
.f394	20 33 f5	jsr $f533	          JSR Loading_Verifying
.f397	20 fb e9	jsr $e9fb	          JSR TAPE_Read       ; start tape load
>f39a	24				          .BYTE $24
.f39b	18		clc		LOAD_Done CLC
.f39c	a6 ae		ldx $ae		          LDX EAL
.f39e	a4 af		ldy $af		          LDY EAH
.f3a0	60		rts		LOAD_Ret  RTS
.f3a1					  BURST_LOAD
.f3a1	a0 00		ldy #$00	          LDY #0
.f3a3	20 ae f7	jsr $f7ae	          JSR Get_Filename_Char
.f3a6	c9 24		cmp #$24	          CMP #'$'            ; directory load ?
.f3a8	f0 f6		beq $f3a0	          BEQ LOAD_Ret        ; -> return for slow load C=1
.f3aa	a6 ba		ldx $ba		          LDX FA
.f3ac	a0 0f		ldy #$0f	          LDY #15
.f3ae	a9 00		lda #$00	          LDA #0
.f3b0	20 38 f7	jsr $f738	          JSR SETLFS          ; OPEN 0,U,15
.f3b3	85 b7		sta $b7		          STA FNLEN           ; no filename
.f3b5	20 c0 ff	jsr $ffc0	          JSR K_OPEN          ; open command channel
.f3b8	a6 b8		ldx $b8		          LDX LA
.f3ba	20 c9 ff	jsr $ffc9	          JSR K_CKOUT         ; select command channel
.f3bd	90 08		bcc $f3c7	          BCC BULO_10         ; -> OK
.f3bf	20 8c f4	jsr $f48c	          JSR BULO_Close   ; C=1: error
.f3c2	68		pla		          PLA                 ; remove return address
.f3c3	68		pla		          PLA
.f3c4	4c 88 f6	jmp $f688	          JMP Device_Not_Present
.f3c7	a0 03		ldy #$03	BULO_10   LDY #3              ; send "U0" $1f
.f3c9	b9 0b f5	lda $f50b,y	BULO_15   LDA Burst_Load_Command-1,Y
.f3cc	20 d2 ff	jsr $ffd2	          JSR K_BSOUT
.f3cf	88		dey		          DEY
.f3d0	d0 f7		bne $f3c9	          BNE BULO_15
.f3d2	20 ae f7	jsr $f7ae	BULO_20   JSR Get_Filename_Char
.f3d5	20 d2 ff	jsr $ffd2	          JSR K_BSOUT         ; send filename
.f3d8	c8		iny		          INY
.f3d9	c4 9f		cpy $9f		          CPY PTR_HI          ; FNLEN
.f3db	d0 f5		bne $f3d2	          BNE BULO_20
.f3dd	20 cc ff	jsr $ffcc	          JSR K_CLRCH
.f3e0	2c 1c 0a	bit $0a1c	          BIT Fast_IEC        ; burst mode enabled ?
.f3e3	70 05		bvs $f3ea	          BVS BULO_25         ; -> yes
.f3e5	20 8c f4	jsr $f48c	          JSR BULO_Close
.f3e8	38		sec		          SEC                 ; Set error flag
.f3e9	60		rts		          RTS
.f3ea	a5 9f		lda $9f		BULO_25   LDA PTR_HI
.f3ec	85 b7		sta $b7		          STA FNLEN           ; restore Filename length
.f3ee	78		sei		          SEI
.f3ef	20 45 e5	jsr $e545	          JSR IEC_Clock_High
.f3f2	20 c3 e5	jsr $e5c3	          JSR IEC_Fast_Input
.f3f5	2c 0d dc	bit $dc0d	          BIT CIA1_ICR
.f3f8	20 03 f5	jsr $f503	          JSR Toggle_CLOCK_OUT
.f3fb	20 ba f4	jsr $f4ba	          JSR Read_Burst_Byte   ; burst status byte
.f3fe	c9 02		cmp #$02	          CMP #2              ; 2 = file not found
.f400	d0 08		bne $f40a	          BNE BULO_30         ; -> file found
.f402	20 8c f4	jsr $f48c	          JSR BULO_Close
.f405	68		pla		          PLA
.f406	68		pla		          PLA
.f407	4c 85 f6	jmp $f685	          JMP File_Not_Found
.f40a	48		pha		BULO_30   PHA                 ; Push transfer status
.f40b	c9 1f		cmp #$1f	          CMP #$1f            ; burst status = EOI ?
.f40d	d0 0b		bne $f41a	          BNE BULO_35
.f40f	20 03 f5	jsr $f503	          JSR Toggle_CLOCK_OUT
.f412	20 ba f4	jsr $f4ba	          JSR Read_Burst_Byte   ; bytes following status byte
.f415	85 a5		sta $a5		          STA CNTDN
.f417	4c 21 f4	jmp $f421	          JMP BULO_40
.f41a	c9 02		cmp #$02	BULO_35   CMP #2              ; burst status OK ? ( < 2 )
.f41c	90 03		bcc $f421	          BCC BULO_40         ; -> OK
.f41e	68		pla		          PLA
.f41f	b0 77		bcs $f498	          BCS BULO_Err           ; -> always
.f421	20 33 f5	jsr $f533	BULO_40   JSR Loading_Verifying
.f424	20 03 f5	jsr $f503	          JSR Toggle_CLOCK_OUT
.f427	20 ba f4	jsr $f4ba	          JSR Read_Burst_Byte
.f42a	85 ae		sta $ae		          STA EAL             ; Load address low
.f42c	20 03 f5	jsr $f503	          JSR Toggle_CLOCK_OUT
.f42f	20 ba f4	jsr $f4ba	          JSR Read_Burst_Byte
.f432	85 af		sta $af		          STA EAH             ; Load address high
.f434	a6 9e		ldx $9e		          LDX PTR_LO          ; SA
.f436	d0 08		bne $f440	          BNE BULO_45         ; -> SA != 0 -> use address from file
.f438	a5 c3		lda $c3		          LDA MEMUSS          ; Overwrite load address
.f43a	a6 c4		ldx $c4		          LDX MEMUSS+1
.f43c	85 ae		sta $ae		          STA EAL
.f43e	86 af		stx $af		          STX EAH
.f440	a5 ae		lda $ae		BULO_45   LDA EAL
.f442	a6 af		ldx $af		          LDX EAH
.f444	85 ac		sta $ac		          STA SAL
.f446	86 ad		stx $ad		          STX SAH
.f448	68		pla		          PLA                 ; Pull burst status
.f449	c9 1f		cmp #$1f	          CMP #$1f            ; burst status = EOI ?
.f44b	f0 32		beq $f47f	          BEQ BULO_65         ; ->
.f44d	20 03 f5	jsr $f503	          JSR Toggle_CLOCK_OUT
.f450	a9 fc		lda #$fc	          LDA #$fc            ; Length of 1st. data block = 252
.f452	85 a5		sta $a5		          STA CNTDN
.f454	20 3d f6	jsr $f63d	BULO_50   JSR Check_STOP_Key
.f457	20 e1 ff	jsr $ffe1	          JSR K_STOP
.f45a	f0 4a		beq $f4a6	          BEQ BULO_Stop
.f45c	20 c5 f4	jsr $f4c5	          JSR Read_Burst_Block  ; read block in burst mode
.f45f	b0 51		bcs $f4b2	          BCS BULO_Break
.f461	20 ba f4	jsr $f4ba	          JSR Read_Burst_Byte   ; read burst status
.f464	c9 02		cmp #$02	          CMP #2
.f466	90 06		bcc $f46e	          BCC BULO_55         ; -> OK
.f468	c9 1f		cmp #$1f	          CMP #$1f            ; EOI ?
.f46a	f0 0b		beq $f477	          BEQ BULO_60         ; -> finish
.f46c	d0 2a		bne $f498	          BNE BULO_Err           ; -> error
.f46e	20 03 f5	jsr $f503	BULO_55   JSR Toggle_CLOCK_OUT
.f471	a9 fe		lda #$fe	          LDA #$fe            ; Next data block = 254 bytes
.f473	85 a5		sta $a5		          STA CNTDN
.f475	d0 dd		bne $f454	          BNE BULO_50         ; loop always
.f477	20 03 f5	jsr $f503	BULO_60   JSR Toggle_CLOCK_OUT
.f47a	20 ba f4	jsr $f4ba	          JSR Read_Burst_Byte
.f47d	85 a5		sta $a5		          STA CNTDN           ; Length of last data block
.f47f	20 03 f5	jsr $f503	BULO_65   JSR Toggle_CLOCK_OUT
.f482	20 c5 f4	jsr $f4c5	          JSR Read_Burst_Block
.f485	b0 2b		bcs $f4b2	          BCS BULO_Break
.f487	a9 40		lda #$40	          LDA #$40            ; bit 6 = EOI
.f489	20 57 f7	jsr $f757	          JSR SETST
.f48c					  BULO_Close
.f48c	20 45 e5	jsr $e545	          JSR IEC_Clock_High
.f48f	58		cli		          CLI
.f490	a5 b8		lda $b8		          LDA LA
.f492	38		sec		          SEC
.f493	20 c3 ff	jsr $ffc3	          JSR K_CLOSE
.f496	18		clc		          CLC
.f497	60		rts		          RTS
.f498					  BULO_Err
.f498	a9 02		lda #$02	          LDA #2              ; bit 1 = TIME OUT READ
.f49a	20 57 f7	jsr $f757	          JSR SETST
.f49d	20 8c f4	jsr $f48c	          JSR BULO_Close
.f4a0	68		pla		          PLA                 ; remove BURST_LOAD return address
.f4a1	68		pla		          PLA
.f4a2	a9 29		lda #$29	          LDA #$29            ; FILE READ ERROR
.f4a4	38		sec		          SEC                 ; error flag
.f4a5	60		rts		          RTS                 ; return from LOADSP
.f4a6					  BULO_Stop
.f4a6	20 8c f4	jsr $f48c	          JSR BULO_Close
.f4a9	a9 00		lda #$00	          LDA #0
.f4ab	85 b9		sta $b9		          STA SA
.f4ad	68		pla		          PLA
.f4ae	68		pla		          PLA
.f4af	4c b5 f5	jmp $f5b5	          JMP Err_IEC_Close
.f4b2					  BULO_Break
.f4b2	20 8c f4	jsr $f48c	          JSR BULO_Close
.f4b5	68		pla		          PLA
.f4b6	68		pla		          PLA
.f4b7	4c 97 f6	jmp $f697	          JMP Break_IO
.f4ba					  Read_Burst_Byte
.f4ba	a9 08		lda #$08	          LDA #8              ; bit 3 = ISDR
.f4bc	2c 0d dc	bit $dc0d	RBB_10    BIT CIA1_ICR
.f4bf	f0 fb		beq $f4bc	          BEQ RBB_10          ; wait for interrupt ISDR
.f4c1	ad 0c dc	lda $dc0c	          LDA CIA1_SDR        ; A = data byte
.f4c4	60		rts		          RTS
.f4c5					  Read_Burst_Block
.f4c5	a9 08		lda #$08	          LDA #8              ; bit 3 = ISDR
.f4c7	2c 0d dc	bit $dc0d	RBBl_10   BIT CIA1_ICR
.f4ca	f0 fb		beq $f4c7	          BEQ RBBl_10         ; wait for interrupt ISDR
.f4cc	ac 0c dc	ldy $dc0c	          LDY CIA1_SDR        ; Y = data byte
.f4cf	ad 00 dd	lda $dd00	          LDA CIA2_PRA
.f4d2	49 10		eor #$10	          EOR #%00010000     ; $10 toggle CLOCK OUT
.f4d4	8d 00 dd	sta $dd00	          STA CIA2_PRA
.f4d7	98		tya		          TYA                 ; A = data byte
.f4d8	a4 93		ldy $93		          LDY K_VERCK         ; LOAD (0) or VERIFY (1) ?
.f4da	f0 12		beq $f4ee	          BEQ RBBl_20         ; -> LOAD
.f4dc	85 bd		sta $bd		          STA RS_Parity       ; store read byte
.f4de	a0 00		ldy #$00	          LDY #0
.f4e0	20 c9 f7	jsr $f7c9	          JSR LDA_IND_EAL     ; load memory byte
.f4e3	c5 bd		cmp $bd		          CMP RS_Parity       ; verify
.f4e5	f0 0a		beq $f4f1	          BEQ RBBl_30         ; -> OK
.f4e7	a9 10		lda #$10	          LDA #16             ; Veriyfy error
.f4e9	20 57 f7	jsr $f757	          JSR SETST
.f4ec	d0 03		bne $f4f1	          BNE RBBl_30         ; always
.f4ee	20 bf f7	jsr $f7bf	RBBl_20   JSR STA_IND_EAL     ; store read byte
.f4f1	e6 ae		inc $ae		RBBl_30   INC EAL             ; increment load address
.f4f3	d0 08		bne $f4fd	          BNE RBBl_40
.f4f5	e6 af		inc $af		          INC EAH
.f4f7	a5 af		lda $af		          LDA EAH
.f4f9	c9 ff		cmp #$ff	          CMP #$ff            ; Do not load to page $ff
.f4fb	f0 05		beq $f502	          BEQ RBBl_Ret        ; -> exit with C=1 (error)
.f4fd	c6 a5		dec $a5		RBBl_40   DEC CNTDN           ; decrement burst count down
.f4ff	d0 c4		bne $f4c5	          BNE Read_Burst_Block
.f501	18		clc		          CLC
.f502	60		rts		RBBl_Ret  RTS
.f503					  Toggle_CLOCK_OUT
.f503	ad 00 dd	lda $dd00	          LDA CIA2_PRA
.f506	49 10		eor #$10	          EOR #%00010000
.f508	8d 00 dd	sta $dd00	          STA CIA2_PRA
.f50b	60		rts		          RTS
.f50c					  Burst_Load_Command
>f50c	1f				          .BYTE $1f           ; "U0" + CHR$(31)
>f50d	30 55				          .TEXT "0U"          ; used reverse
.f50f					  Searching
.f50f	a5 9d		lda $9d		          LDA MSGFLG
.f511	10 1f		bpl $f532	          BPL OuFi_Ret
.f513	a0 0c		ldy #$0c	          LDY #Msg_Searching
.f515	20 22 f7	jsr $f722	          JSR System_Message
.f518	a5 b7		lda $b7		          LDA FNLEN
.f51a	f0 16		beq $f532	          BEQ OuFi_Ret
.f51c	a0 17		ldy #$17	          LDY #Msg_For
.f51e	20 22 f7	jsr $f722	          JSR System_Message
.f521					  Ouput_Filename
.f521	a4 b7		ldy $b7		          LDY FNLEN
.f523	f0 0d		beq $f532	          BEQ OuFi_Ret
.f525	a0 00		ldy #$00	          LDY #0
.f527	20 ae f7	jsr $f7ae	OuFi_10   JSR Get_Filename_Char
.f52a	20 d2 ff	jsr $ffd2	          JSR K_BSOUT
.f52d	c8		iny		          INY
.f52e	c4 b7		cpy $b7		          CPY FNLEN
.f530	d0 f5		bne $f527	          BNE OuFi_10
.f532	60		rts		OuFi_Ret  RTS
.f533					  Loading_Verifying
.f533	a0 49		ldy #$49	          LDY #Msg_Loading
.f535	a5 93		lda $93		          LDA K_VERCK
.f537	f0 02		beq $f53b	          BEQ LoVe_10
.f539	a0 59		ldy #$59	          LDY #Msg_Verifying
.f53b	4c 1e f7	jmp $f71e	LoVe_10   JMP System_Message_Cond
.f53e					  SAVESP
.f53e	86 ae		stx $ae		          STX EAL
.f540	84 af		sty $af		          STY EAH
.f542	aa		tax		          TAX
.f543	b5 00		lda $00,x	          LDA 0,X
.f545	85 c1		sta $c1		          STA STAL
.f547	b5 01		lda $01,x	          LDA 1,X
.f549	85 c2		sta $c2		          STA STAH
.f54b	6c 32 03	jmp ($0332)	          JMP (ISAVE)         ; default = D_SAVE
.f54e					  D_SAVE
.f54e	a5 ba		lda $ba		          LDA FA
.f550	c9 01		cmp #$01	          CMP #1
.f552	f0 74		beq $f5c8	          BEQ TAPE_SAVE       ; save to tape
.f554	c9 04		cmp #$04	          CMP #4
.f556	b0 09		bcs $f561	          BCS DSAV_30         ; save to IEC
.f558	4c 94 f6	jmp $f694	DSAV_10   JMP Illegal_Device_Number
.f55b	4c 91 f6	jmp $f691	DSAV_20   JMP Missing_File_Name
.f55e	4c 85 f6	jmp $f685	          JMP File_Not_Found
.f561	a4 b7		ldy $b7		DSAV_30   LDY FNLEN
.f563	f0 f6		beq $f55b	          BEQ DSAV_20
.f565	a9 61		lda #$61	          LDA #$61            ; SA for saving
.f567	85 b9		sta $b9		          STA SA
.f569	20 cb f0	jsr $f0cb	          JSR IEC_OPEN
.f56c	20 bc f5	jsr $f5bc	          JSR Saving          ; print saving filename
.f56f	a5 ba		lda $ba		          LDA FA
.f571	20 3e e3	jsr $e33e	          JSR LISTN
.f574	a5 b9		lda $b9		          LDA SA
.f576	20 d2 e4	jsr $e4d2	          JSR SECND
.f579	a0 00		ldy #$00	          LDY #0
.f57b	20 51 ed	jsr $ed51	          JSR STAL_To_SAL
.f57e	20 03 e5	jsr $e503	          JSR CIOUT           ; write start address low
.f581	a5 ad		lda $ad		          LDA SAH
.f583	20 03 e5	jsr $e503	          JSR CIOUT           ; write start address high
.f586	20 b7 ee	jsr $eeb7	DSAV_40   JSR Check_IO_End
.f589	b0 10		bcs $f59b	          BCS DSAV_50         ; -> finish
.f58b	20 cc f7	jsr $f7cc	          JSR LDA_IND_SAL     ; load data byte from memory
.f58e	20 03 e5	jsr $e503	          JSR CIOUT           ; write data byte
.f591	20 e1 ff	jsr $ffe1	          JSR K_STOP          ; check STOP key
.f594	f0 1f		beq $f5b5	          BEQ Err_IEC_Close
.f596	20 c1 ee	jsr $eec1	          JSR Inc_SAL_Word    ; increment address SAL/SAH
.f599	d0 eb		bne $f586	          BNE DSAV_40         ; loop always
.f59b	20 26 e5	jsr $e526	DSAV_50   JSR UNLSN
.f59e					  IEC_Close
.f59e	24 b9		bit $b9		          BIT SA
.f5a0	30 11		bmi $f5b3	          BMI IEC_Ret
.f5a2	a5 ba		lda $ba		          LDA FA
.f5a4	20 3e e3	jsr $e33e	          JSR LISTN
.f5a7	a5 b9		lda $b9		          LDA SA
.f5a9	29 ef		and #$ef	          AND #%11101111     ; $ef
.f5ab	09 e0		ora #$e0	          ORA #%11100000     ; $e0
.f5ad	20 d2 e4	jsr $e4d2	          JSR SECND
.f5b0					  IEC_Unlisten
.f5b0	20 26 e5	jsr $e526	          JSR UNLSN
.f5b3	18		clc		IEC_Ret   CLC
.f5b4	60		rts		          RTS
.f5b5					  Err_IEC_Close
.f5b5	20 9e f5	jsr $f59e	          JSR IEC_Close
.f5b8	a9 00		lda #$00	          LDA #0
.f5ba	38		sec		          SEC
.f5bb	60		rts		          RTS
.f5bc					  Saving
.f5bc	a5 9d		lda $9d		          LDA MSGFLG
.f5be	10 37		bpl $f5f7	          BPL TASA_Ret
.f5c0	a0 51		ldy #$51	          LDY #Msg_Saving
.f5c2	20 22 f7	jsr $f722	          JSR System_Message
.f5c5	4c 21 f5	jmp $f521	          JMP Ouput_Filename
.f5c8					  TAPE_SAVE
.f5c8	20 80 e9	jsr $e980	          JSR TAPE_XY_Check   ; setup buffer
.f5cb	90 8b		bcc $f558	          BCC DSAV_10         ; -> error
.f5cd	20 e9 e9	jsr $e9e9	          JSR TAPE_Wait_For_Record
.f5d0	b0 25		bcs $f5f7	          BCS TASA_Ret        ; -> timed out
.f5d2	20 bc f5	jsr $f5bc	          JSR Saving
.f5d5	a2 03		ldx #$03	          LDX #3              ; header type for binary
.f5d7	a5 b9		lda $b9		          LDA SA
.f5d9	29 01		and #$01	          AND #1
.f5db	d0 02		bne $f5df	          BNE TASA_10
.f5dd	a2 01		ldx #$01	          LDX #1              ; header type for BASIC program
.f5df	8a		txa		TASA_10   TXA
.f5e0	20 19 e9	jsr $e919	          JSR TAPE_Write_Program_Header
.f5e3	b0 12		bcs $f5f7	          BCS TASA_Ret        ; -> error
.f5e5	20 18 ea	jsr $ea18	          JSR TAPE_Write_Program
.f5e8	b0 0d		bcs $f5f7	          BCS TASA_Ret        ; -> error
.f5ea	a5 b9		lda $b9		          LDA SA
.f5ec	29 02		and #$02	          AND #2
.f5ee	f0 06		beq $f5f6	          BEQ TASA_20
.f5f0	a9 05		lda #$05	          LDA #5
.f5f2	20 19 e9	jsr $e919	          JSR TAPE_Write_Program_Header
>f5f5	24				          .BYTE $24           ; skip next byte
.f5f6	18		clc		TASA_20   CLC
.f5f7	60		rts		TASA_Ret  RTS
.f5f8					  UDTIM
.f5f8	e6 a2		inc $a2		          INC JIFFY_CLOCK+2   ; increment 24 bit jiffy clock
.f5fa	d0 06		bne $f602	          BNE UDTIM_10
.f5fc	e6 a1		inc $a1		          INC JIFFY_CLOCK+1
.f5fe	d0 02		bne $f602	          BNE UDTIM_10
.f600	e6 a0		inc $a0		          INC JIFFY_CLOCK
.f602	38		sec		UDTIM_10  SEC                 ; timer - $4f1a01 (24 * 60 * 60 * 60 + 1)
.f603	a5 a2		lda $a2		          LDA JIFFY_CLOCK+2
.f605	e9 01		sbc #$01	          SBC #1
.f607	a5 a1		lda $a1		          LDA JIFFY_CLOCK+1
.f609	e9 1a		sbc #$1a	          SBC #$1a
.f60b	a5 a0		lda $a0		          LDA JIFFY_CLOCK
.f60d	e9 4f		sbc #$4f	          SBC #$4f
.f60f	90 08		bcc $f619	          BCC UDTIM_20        ; -> no overflow (24 hours)
.f611	a2 00		ldx #$00	          LDX #0              ; reset timer
.f613	86 a0		stx $a0		          STX JIFFY_CLOCK
.f615	86 a1		stx $a1		          STX JIFFY_CLOCK+1
.f617	86 a2		stx $a2		          STX JIFFY_CLOCK+2
.f619	ad 1d 0a	lda $0a1d	UDTIM_20  LDA JIFFY_COUNTDOWN
.f61c	d0 0b		bne $f629	          BNE UDTIM_40
.f61e	ad 1e 0a	lda $0a1e	          LDA JIFFY_COUNTDOWN+1
.f621	d0 03		bne $f626	          BNE UDTIM_30
.f623	ce 1f 0a	dec $0a1f	          DEC JIFFY_COUNTDOWN+2
.f626	ce 1e 0a	dec $0a1e	UDTIM_30  DEC JIFFY_COUNTDOWN+1
.f629	ce 1d 0a	dec $0a1d	UDTIM_40  DEC JIFFY_COUNTDOWN
.f62c	2c 03 0a	bit $0a03	          BIT PALNTS          ; check PAL NTSC flag
.f62f	10 0c		bpl $f63d	          BPL Check_STOP_Key  ; -> NTSC
.f631	ce 36 0a	dec $0a36	          DEC PAL_ADJ
.f634	10 07		bpl $f63d	          BPL Check_STOP_Key  ; -> no PAL adjustment this time
.f636	a9 05		lda #$05	          LDA #5
.f638	8d 36 0a	sta $0a36	          STA PAL_ADJ         ; reset PAL adjustment counter
.f63b	d0 bb		bne $f5f8	          BNE UDTIM           ; -> run once more for PAL adjustment
.f63d					  Check_STOP_Key
.f63d	ad 01 dc	lda $dc01	          LDA CIA1_KBD_ROW
.f640	cd 01 dc	cmp $dc01	          CMP CIA1_KBD_ROW
.f643	d0 f8		bne $f63d	          BNE Check_STOP_Key
.f645	aa		tax		          TAX
.f646	30 13		bmi $f65b	          BMI Bf65b
.f648	a2 bd		ldx #$bd	          LDX #$bd
.f64a	8e 00 dc	stx $dc00	          STX CIA1_KBD_COL
.f64d	ae 01 dc	ldx $dc01	Bf64d     LDX CIA1_KBD_ROW
.f650	ec 01 dc	cpx $dc01	          CPX CIA1_KBD_ROW
.f653	d0 f8		bne $f64d	          BNE Bf64d
.f655	8d 00 dc	sta $dc00	          STA CIA1_KBD_COL
.f658	e8		inx		          INX
.f659	d0 02		bne $f65d	          BNE Bf65d
.f65b	85 91		sta $91		Bf65b     STA STKEY
.f65d	60		rts		Bf65d     RTS
.f65e					  RDTIM
.f65e	78		sei		          SEI
.f65f	a5 a2		lda $a2		          LDA JIFFY_CLOCK+2
.f661	a6 a1		ldx $a1		          LDX JIFFY_CLOCK+1
.f663	a4 a0		ldy $a0		          LDY JIFFY_CLOCK
.f665					  SETTIM
.f665	78		sei		          SEI
.f666	85 a2		sta $a2		          STA JIFFY_CLOCK+2
.f668	86 a1		stx $a1		          STX JIFFY_CLOCK+1
.f66a	84 a0		sty $a0		          STY JIFFY_CLOCK
.f66c	58		cli		          CLI
.f66d	60		rts		          RTS
.f66e					  STOP
.f66e	a5 91		lda $91		          LDA STKEY
.f670	c9 7f		cmp #$7f	          CMP #$7f
.f672	d0 07		bne $f67b	          BNE STOP_Ret
.f674	08		php		          PHP
.f675	20 cc ff	jsr $ffcc	          JSR K_CLRCH         ; clear channels
.f678	85 d0		sta $d0		          STA NDX             ; empty keyboard buffer
.f67a	28		plp		          PLP
.f67b	60		rts		STOP_Ret  RTS
.f67c					  Too_Many_Files
.f67c	a9 01		lda #$01	          LDA #1
>f67e	2c				          .byte $2c ;BIT
.f67f					  File_Open_Err
.f67f	a9 02		lda #$02	          LDA #2
>f681	2c				          .byte $2c ;BIT
.f682					  File_Not_Open
.f682	a9 03		lda #$03	          LDA #3
>f684	2c				          .byte $2c ;BIT
.f685					  File_Not_Found
.f685	a9 04		lda #$04	          LDA #4
>f687	2c				          .byte $2c ;BIT
.f688					  Device_Not_Present
.f688	a9 05		lda #$05	          LDA #5
>f68a	2c				          .byte $2c ;BIT
.f68b					  Not_Input_File
.f68b	a9 06		lda #$06	          LDA #6
>f68d	2c				          .byte $2c ;BIT
.f68e					  Not_Output_File
.f68e	a9 07		lda #$07	          LDA #7
>f690	2c				          .byte $2c ;BIT
.f691					  Missing_File_Name
.f691	a9 08		lda #$08	          LDA #8
>f693	2c				          .byte $2c ;BIT
.f694					  Illegal_Device_Number
.f694	a9 09		lda #$09	          LDA #9
>f696	2c				          .byte $2c ;BIT
.f697					  Break_IO
.f697	a9 10		lda #$10	          LDA #16
.f699	48		pha		          PHA
.f69a	20 cc ff	jsr $ffcc	          JSR K_CLRCH
.f69d	a0 00		ldy #$00	          LDY #Msg_Error
.f69f	24 9d		bit $9d		          BIT MSGFLG
.f6a1	50 0a		bvc $f6ad	          BVC Break_Ret
.f6a3	20 22 f7	jsr $f722	          JSR System_Message
.f6a6	68		pla		          PLA
.f6a7	48		pha		          PHA
.f6a8	09 30		ora #$30	          ORA #'0'            ; convert error # to ASCII
.f6aa	20 d2 ff	jsr $ffd2	          JSR K_BSOUT
.f6ad	68		pla		Break_Ret PLA
.f6ae	38		sec		          SEC
.f6af	60		rts		          RTS
.f6b0					  Message_Table
=0					  Msg_Error     = * - Message_Table
>f6b0	0d 49 2f 4f 20 45 52 52		          .SHIFT "\rI/O ERROR #" ;^
>f6b8	4f 52 20 a3
=12					  Msg_Searching = * - Message_Table
>f6bc	0d 53 45 41 52 43 48 49		          .SHIFT "\rSEARCHING " ;^
>f6c4	4e 47 a0
=23					  Msg_For       = * - Message_Table
>f6c7	46 4f 52 a0			          .SHIFT "FOR " ;^
=27					  Msg_Play      = * - Message_Table
>f6cb	0d 50 52 45 53 53 20 50		          .SHIFT "\rPRESS PLAY ON TAPE" ;^
>f6d3	4c 41 59 20 4f 4e 20 54 41 50 c5
=46					  Msg_Record    = * - Message_Table
>f6de	50 52 45 53 53 20 52 45		          .SHIFT "PRESS RECORD & PLAY ON TAPE" ;^
>f6e6	43 4f 52 44 20 26 20 50 4c 41 59 20 4f 4e 20 54
>f6f6	41 50 c5
=73					  Msg_Loading   = * - Message_Table
>f6f9	0d 4c 4f 41 44 49 4e c7		          .SHIFT "\rLOADING" ;^
=81					  Msg_Saving    = * - Message_Table
>f701	0d 53 41 56 49 4e 47 a0		          .SHIFT "\rSAVING " ;^
=89					  Msg_Verifying = * - Message_Table
>f709	0d 56 45 52 49 46 59 49		          .SHIFT "\rVERIFYING" ;^
>f711	4e c7
=99					  Msg_Found     = * - Message_Table
>f713	0d 46 4f 55 4e 44 a0		          .SHIFT "\rFOUND " ;^
=106					  Msg_OK        = * - Message_Table
>f71a	0d 4f 4b 8d			          .SHIFT "\rOK\r" ;^
.f71e					  System_Message_Cond
.f71e	24 9d		bit $9d		          BIT MSGFLG
.f720	10 0d		bpl $f72f	          BPL SyMe_10
.f722					  System_Message
.f722	b9 b0 f6	lda $f6b0,y	          LDA Message_Table,Y
.f725	08		php		          PHP
.f726	29 7f		and #$7f	          AND #%01111111 ; $7f
.f728	20 d2 ff	jsr $ffd2	          JSR K_BSOUT
.f72b	c8		iny		          INY
.f72c	28		plp		          PLP
.f72d	10 f3		bpl $f722	          BPL System_Message
.f72f	18		clc		SyMe_10   CLC
.f730	60		rts		          RTS
.f731					  SETNAM
.f731	85 b7		sta $b7		          STA FNLEN
.f733	86 bb		stx $bb		          STX FNADR
.f735	84 bc		sty $bc		          STY FNADR+1
.f737	60		rts		          RTS
.f738					  SETLFS
.f738	85 b8		sta $b8		          STA LA
.f73a	86 ba		stx $ba		          STX FA
.f73c	84 b9		sty $b9		          STY SA
.f73e	60		rts		          RTS
.f73f					  SETBNK
.f73f	85 c6		sta $c6		          STA BA
.f741	86 c7		stx $c7		          STX FNBANK
.f743	60		rts		          RTS
.f744					  READST
.f744	a5 ba		lda $ba		          LDA FA
.f746	c9 02		cmp #$02	          CMP #2              ; RS232 active ?
.f748	d0 0b		bne $f755	          BNE REAST_10        ; -> no, read common status
.f74a	ad 14 0a	lda $0a14	          LDA RS_Status
.f74d	48		pha		          PHA
.f74e	a9 00		lda #$00	          LDA #0
.f750	8d 14 0a	sta $0a14	          STA RS_Status       ; clear RS232 status after reading
.f753	68		pla		          PLA
.f754	60		rts		          RTS
.f755	a5 90		lda $90		REAST_10  LDA STATUS
.f757					  SETST
.f757	05 90		ora $90		          ORA STATUS
.f759	85 90		sta $90		          STA STATUS
.f75b	60		rts		          RTS
.f75c					  SETMSG
.f75c	85 9d		sta $9d		          STA MSGFLG
.f75e	60		rts		          RTS
.f75f					  SETTMO
.f75f	8d 0e 0a	sta $0a0e	          STA TIMOUT
.f762	60		rts		          RTS
.f763					  MEMTOP
.f763	90 06		bcc $f76b	          BCC SET_MEM_TOP
.f765	ae 07 0a	ldx $0a07	          LDX MEM_TOP
.f768	ac 08 0a	ldy $0a08	          LDY MEM_TOP+1
.f76b					  SET_MEM_TOP
.f76b	8e 07 0a	stx $0a07	          STX MEM_TOP
.f76e	8c 08 0a	sty $0a08	          STY MEM_TOP+1
.f771	60		rts		          RTS
.f772					  MEMBOT
.f772	90 06		bcc $f77a	          BCC SET_MEM_BOT
.f774	ae 05 0a	ldx $0a05	          LDX MEM_BOT
.f777	ac 06 0a	ldy $0a06	          LDY MEM_BOT+1
.f77a					  SET_MEM_BOT
.f77a	8e 05 0a	stx $0a05	          STX MEM_BOT
.f77d	8c 06 0a	sty $0a06	          STY MEM_BOT+1
.f780	60		rts		          RTS
.f781					  IOBASE
.f781	a2 00		ldx #$00	          LDX #<VIC
.f783	a0 d0		ldy #$d0	          LDY #>VIC
.f785	60		rts		          RTS
.f786					  LKUPSA
.f786	98		tya		          TYA                 ; A = address
.f787	a6 98		ldx $98		          LDX LDTND           ; X = # of open files
.f789	ca		dex		LKSA_10   DEX
.f78a	30 0f		bmi $f79b	          BMI LKSA_30         ; -> not found
.f78c	dd 76 03	cmp $0376,x	          CMP SAT,X
.f78f	d0 f8		bne $f789	          BNE LKSA_10
.f791	20 12 f2	jsr $f212	LKSA_20   JSR Get_LASAFA
.f794	aa		tax		          TAX                 ; X = FA
.f795	a5 b8		lda $b8		          LDA LA
.f797	a4 b9		ldy $b9		          LDY SA
.f799	18		clc		          CLC                 ; C=0 : found
.f79a	60		rts		          RTS
.f79b	38		sec		LKSA_30   SEC                 ; C=1 : not found
.f79c	60		rts		          RTS
.f79d					  LKUPLA
.f79d	aa		tax		          TAX
.f79e	20 02 f2	jsr $f202	          JSR Lookup_X
.f7a1	f0 ee		beq $f791	          BEQ LKSA_20         ; -> found
.f7a3	d0 f6		bne $f79b	          BNE LKSA_30         ; -> not found
.f7a5	bd f0 f7	lda $f7f0,x	          LDA Bank_Config_Table,X
.f7a8	29 fe		and #$fe	          AND #%11111110 ; $fe
.f7aa	aa		tax		          TAX
.f7ab	4c f0 03	jmp $03f0	          JMP RAM_DMA
.f7ae					  Get_Filename_Char
.f7ae	8e 35 0a	stx $0a35	          STX FN_SAVE_X
.f7b1	a6 c7		ldx $c7		          LDX FNBANK
.f7b3	a9 bb		lda #$bb	          LDA #FNADR
.f7b5	20 d0 f7	jsr $f7d0	          JSR INDFET
.f7b8	ae 35 0a	ldx $0a35	          LDX FN_SAVE_X
.f7bb	60		rts		          RTS
.f7bc					  STA_IND_SAL
.f7bc	a2 ac		ldx #$ac	          LDX #SAL
>f7be	2c				          .byte $2c ;BIT
.f7bf					  STA_IND_EAL
.f7bf	a2 ae		ldx #$ae	          LDX #EAL
.f7c1	8e b9 02	stx $02b9	          STX STASH+10
.f7c4	a6 c6		ldx $c6		          LDX BA
.f7c6	4c da f7	jmp $f7da	          JMP INDSTA
.f7c9					  LDA_IND_EAL
.f7c9	a9 ae		lda #$ae	          LDA #EAL
>f7cb	2c				          .byte $2c ;BIT
.f7cc					  LDA_IND_SAL
.f7cc	a9 ac		lda #$ac	          LDA #SAL
.f7ce	a6 c6		ldx $c6		          LDX BA
.f7d0					  INDFET
.f7d0	8d aa 02	sta $02aa	          STA FETCH+8
.f7d3	bd f0 f7	lda $f7f0,x	          LDA Bank_Config_Table,X
.f7d6	aa		tax		          TAX
.f7d7	4c a2 02	jmp $02a2	          JMP FETCH
.f7da					  INDSTA
.f7da	48		pha		          PHA
.f7db	bd f0 f7	lda $f7f0,x	          LDA Bank_Config_Table,X
.f7de	aa		tax		          TAX
.f7df	68		pla		          PLA
.f7e0	4c af 02	jmp $02af	          JMP STASH
.f7e3					  INDCMP
.f7e3	48		pha		          PHA
.f7e4	bd f0 f7	lda $f7f0,x	          LDA Bank_Config_Table,X
.f7e7	aa		tax		          TAX
.f7e8	68		pla		          PLA
.f7e9	4c be 02	jmp $02be	          JMP CMPARE
.f7ec					  GETCFG
.f7ec	bd f0 f7	lda $f7f0,x	          LDA Bank_Config_Table,X
.f7ef	60		rts		          RTS
.f7f0					  Bank_Config_Table
>f7f0	3f				          .BYTE %00111111    ; $3f RAM 0
>f7f1	7f				          .BYTE %01111111    ; $7f RAM 1
>f7f2	bf				          .BYTE %10111111    ; $bf RAM 2
>f7f3	ff				          .BYTE %11111111    ; $ff RAM 3
>f7f4	16				          .BYTE %00010110    ; $16 internal ROM, RAM 0, I/O
>f7f5	56				          .BYTE %01010110    ; $56 internal ROM, RAM 1, I/O
>f7f6	96				          .BYTE %10010110    ; $96 internal ROM, RAM 2, I/O
>f7f7	d6				          .BYTE %11010110    ; $d6 internal ROM, RAM 3, I/O
>f7f8	2a				          .BYTE %00101010    ; $2a external ROM, RAM 0, I/O
>f7f9	6a				          .BYTE %01101010    ; $2a external ROM, RAM 1, I/O
>f7fa	aa				          .BYTE %10101010    ; $2a external ROM, RAM 2, I/O
>f7fb	ea				          .BYTE %11101010    ; $2a external ROM, RAM 3, I/O
>f7fc	06				          .BYTE %00000110    ; $06 kernal, int.  ROM, RAM 0, I/O
>f7fd	0a				          .BYTE %00001010    ; $0a kernal, ext.  ROM, RAM 0, I/O
>f7fe	01				          .BYTE %00000001    ; $01 kernal, BASIC ROM, RAM 0, CHAR
>f7ff	00				          .BYTE %00000000    ; $00 kernal, BASIC ROM, RAM 0, I/O
.f800					  ROM_FETCH
.f800	ad 00 ff	lda $ff00	          LDA MMU_CR
.f803	8e 00 ff	stx $ff00	          STX MMU_CR
.f806	aa		tax		          TAX
.f807	b1 ff		lda ($ff),y	          LDA ($ff),Y         ; dummy address
.f809	8e 00 ff	stx $ff00	          STX MMU_CR
.f80c	60		rts		          RTS
.f80d					  ROM_STASH
.f80d	48		pha		          PHA
.f80e	ad 00 ff	lda $ff00	          LDA MMU_CR
.f811	8e 00 ff	stx $ff00	          STX MMU_CR
.f814	aa		tax		          TAX
.f815	68		pla		          PLA
.f816	91 ff		sta ($ff),y	          STA ($ff),Y         ; dummy address
.f818	8e 00 ff	stx $ff00	          STX MMU_CR
.f81b	60		rts		          RTS
.f81c					  ROM_CMPARE
.f81c	48		pha		          PHA
.f81d	ad 00 ff	lda $ff00	          LDA MMU_CR
.f820	8e 00 ff	stx $ff00	          STX MMU_CR
.f823	aa		tax		          TAX
.f824	68		pla		          PLA
.f825	d1 ff		cmp ($ff),y	          CMP ($ff),Y         ; dummy address
.f827	8e 00 ff	stx $ff00	          STX MMU_CR
.f82a	60		rts		          RTS
.f82b					  ROM_JSRFAR
.f82b	20 e3 02	jsr $02e3	          JSR JMPFAR
.f82e	85 06		sta $06		          STA A_REG
.f830	86 07		stx $07		          STX X_REG
.f832	84 08		sty $08		          STY Y_REG
.f834	08		php		          PHP
.f835	68		pla		          PLA
.f836	85 05		sta $05		          STA S_REG
.f838	ba		tsx		          TSX
.f839	86 09		stx $09		          STX CHARAC
.f83b	a9 00		lda #$00	          LDA #0
.f83d	8d 00 ff	sta $ff00	          STA MMU_CR
.f840	60		rts		          RTS
.f841					  ROM_JMPFAR
.f841	a2 00		ldx #$00	          LDX #0
.f843	b5 03		lda $03,x	JMPF_10   LDA PC_HI,X
.f845	48		pha		          PHA
.f846	e8		inx		          INX
.f847	e0 03		cpx #$03	          CPX #3
.f849	90 f8		bcc $f843	          BCC JMPF_10
.f84b	a6 02		ldx $02		          LDX BANK
.f84d	20 6b ff	jsr $ff6b	          JSR K_GETCFG
.f850	8d 00 ff	sta $ff00	          STA MMU_CR
.f853	a5 06		lda $06		          LDA A_REG
.f855	a6 07		ldx $07		          LDX X_REG
.f857	a4 08		ldy $08		          LDY Y_REG
.f859	40		rti		          RTI
.f85a					  ROM_DMA
.f85a	ae 00 ff	ldx $ff00	          LDX MMU_CR
.f85d	8c 01 df	sty $df01	          STY DMA_CMD
.f860	8d 00 ff	sta $ff00	          STA MMU_CR
.f863	8e 00 ff	stx $ff00	          STX MMU_CR
.f866	60		rts		          RTS
.f867					  PHOENIX
.f867	78		sei		          SEI
.f868	a2 03		ldx #$03	          LDX #3
.f86a	8e c0 0a	stx $0ac0	          STX Module_Bank
.f86d	ae c0 0a	ldx $0ac0	PHOE_10   LDX Module_Bank
.f870	bd c1 0a	lda $0ac1,x	          LDA Module_Flags,X
.f873	f0 11		beq $f886	          BEQ PHOE_20
.f875	a0 00		ldy #$00	          LDY #0
.f877	bd bc e2	lda $e2bc,x	          LDA ROM_PAGES,X
.f87a	85 03		sta $03		          STA PC_HI
.f87c	84 04		sty $04		          STY PC_LO
.f87e	bd c0 e2	lda $e2c0,x	          LDA ROM_BANK,X
.f881	85 02		sta $02		          STA BANK
.f883	20 cd 02	jsr $02cd	          JSR JSRFAR
.f886	ce c0 0a	dec $0ac0	PHOE_20   DEC Module_Bank
.f889	10 e2		bpl $f86d	          BPL PHOE_10
.f88b	58		cli		          CLI
.f88c	a2 08		ldx #$08	          LDX #8              ; default unit
.f88e	a9 30		lda #$30	          LDA #'0'            ; default drive
.f890					  BOOT
.f890	85 bf		sta $bf		          STA DRIVE           ; ASCII, typically '0'
.f892	86 ba		stx $ba		          STX FA              ; default 8
.f894	8a		txa		          TXA                 ; X = unit / device
.f895	20 3d f2	jsr $f23d	          JSR CLOALL          ; close all channels of boot device
.f898	a2 00		ldx #$00	          LDX #0
.f89a	86 9f		stx $9f		          STX PTR_HI
.f89c	86 c2		stx $c2		          STX STAH            ; sector = 0
.f89e	e8		inx		          INX
.f89f	86 c1		stx $c1		          STX STAL            ; track  = 1
.f8a1	c8		iny		BOOT_10   INY                 ; delay loop for 0.3 sec
.f8a2	d0 fd		bne $f8a1	          BNE BOOT_10
.f8a4	e8		inx		          INX
.f8a5	d0 fa		bne $f8a1	          BNE BOOT_10
.f8a7	a2 0c		ldx #$0c	          LDX #12            ; copy block read command to stack bottom
.f8a9	bd 08 fa	lda $fa08,x	BOOT_15   LDA BootComm,X
.f8ac	9d 00 01	sta $0100,x	          STA STACK,X
.f8af	ca		dex		          DEX
.f8b0	10 f7		bpl $f8a9	          BPL BOOT_15
.f8b2	a5 bf		lda $bf		          LDA DRIVE
.f8b4	8d 06 01	sta $0106	          STA STACK+6         ; insert drive #
.f8b7	a9 00		lda #$00	          LDA #0
.f8b9	a2 0f		ldx #$0f	          LDX #15             ; kernal, BASIC ROM, RAM 0, I/O
.f8bb	20 3f f7	jsr $f73f	          JSR SETBNK          ; boot to MMU config 15
.f8be	a9 01		lda #$01	          LDA #1
.f8c0	a2 15		ldx #$15	          LDX #<InitDrive
.f8c2	a0 fa		ldy #$fa	          LDY #>InitDrive
.f8c4	20 31 f7	jsr $f731	          JSR SETNAM          ; prepare initialization command "I"
.f8c7	a9 00		lda #$00	          LDA #0
.f8c9	a0 0f		ldy #$0f	          LDY #15
.f8cb	a6 ba		ldx $ba		          LDX FA
.f8cd	20 38 f7	jsr $f738	          JSR SETLFS          ; specify commandchannel
.f8d0	20 c0 ff	jsr $ffc0	          JSR K_OPEN          ; send "I" on command channel
.f8d3	b0 16		bcs $f8eb	          BCS BOOT_20         ; -> branch on error
.f8d5	a9 01		lda #$01	          LDA #1
.f8d7	a2 16		ldx #$16	          LDX #<Hash
.f8d9	a0 fa		ldy #$fa	          LDY #>Hash
.f8db	20 31 f7	jsr $f731	          JSR SETNAM          ; prepare open buffer command "#"
.f8de	a9 0d		lda #$0d	          LDA #13
.f8e0	a8		tay		          TAY
.f8e1	a6 ba		ldx $ba		          LDX FA
.f8e3	20 38 f7	jsr $f738	          JSR SETLFS          ; prepare open parameter 13,unit,13
.f8e6	20 c0 ff	jsr $ffc0	          JSR K_OPEN          ; open channel to floppy buffer
.f8e9	90 03		bcc $f8ee	          BCC BOOT_25         ; -> branch if OK
.f8eb	4c 8b f9	jmp $f98b	BOOT_20   JMP BOOT_Exit
.f8ee	a9 00		lda #$00	BOOT_25   LDA #<T_Buffer
.f8f0	a0 0b		ldy #$0b	          LDY #>T_Buffer
.f8f2	85 ac		sta $ac		          STA SAL
.f8f4	84 ad		sty $ad		          STY SAH             ; SAL/SAH = tape buffer
.f8f6	20 d5 f9	jsr $f9d5	          JSR IEC_Read_Block  ; read boot sector to T_Buffer
.f8f9	a2 00		ldx #$00	          LDX #0
.f8fb	bd 00 0b	lda $0b00,x	BOOT_30   LDA T_Buffer,X      ; look for "CBM" in first 3 bytes
.f8fe	dd c4 e2	cmp $e2c4,x	          CMP ROM_CBM,X
.f901	d0 e8		bne $f8eb	          BNE BOOT_20         ; -> no "CBM" signature: exit
.f903	e8		inx		          INX
.f904	e0 03		cpx #$03	          CPX #3
.f906	90 f3		bcc $f8fb	          BCC BOOT_30         ; loop
.f908	20 17 fa	jsr $fa17	          JSR PRIMM           ; OK, print "BOOTING "
>f90b	0d 42 4f 4f 54 49 4e 47		          .TEXT "\rBOOTING ",0
>f913	20 00
.f915	bd 00 0b	lda $0b00,x	BOOT_35   LDA T_Buffer,X      ; copy start and end address
.f918	95 a9		sta $a9,x	          STA SAL-3,X         ; X (3..6) -> SAL,SAH,EAL,EAH
.f91a	e8		inx		          INX
.f91b	e0 07		cpx #$07	          CPX #7
.f91d	90 f6		bcc $f915	          BCC BOOT_35
.f91f	bd 00 0b	lda $0b00,x	BOOT_40   LDA T_Buffer,X      ; print boot sector message
.f922	f0 06		beq $f92a	          BEQ BOOT_45         ; starting at byte 7
.f924	20 d2 ff	jsr $ffd2	          JSR K_BSOUT
.f927	e8		inx		          INX
.f928	d0 f5		bne $f91f	          BNE BOOT_40
.f92a	86 9e		stx $9e		BOOT_45   STX PTR_LO          ; save index to buffer
.f92c	20 17 fa	jsr $fa17	          JSR PRIMM
>f92f	2e 2e 2e 0d 00			          .TEXT "...\r",0
.f934	a5 ae		lda $ae		          LDA EAL
.f936	85 c6		sta $c6		          STA BA
.f938	a5 af		lda $af		BOOT_50   LDA EAH
.f93a	f0 09		beq $f945	          BEQ BOOT_55         ; -> must not boot to ZP
.f93c	c6 af		dec $af		          DEC EAH
.f93e	20 b3 f9	jsr $f9b3	          JSR Read_Next_Block
.f941	e6 ad		inc $ad		          INC SAH             ; load address += 256
.f943	d0 f3		bne $f938	          BNE BOOT_50         ; loop
.f945	20 8b f9	jsr $f98b	BOOT_55   JSR BOOT_Exit       ; close channels
.f948	a6 9e		ldx $9e		          LDX PTR_LO          ; X = buffer index
>f94a	2c				          .byte $2c ;BIT                 ; skip next statement
.f94b	e6 9f		inc $9f		BOOT_60   INC PTR_HI          ; count skipped bytes
.f94d	e8		inx		          INX
.f94e	bd 00 0b	lda $0b00,x	          LDA T_Buffer,X
.f951	d0 f8		bne $f94b	          BNE BOOT_60         ; skip buffer content until zero
.f953	e8		inx		          INX
.f954	86 04		stx $04		          STX PC_LO           ; save end index
.f956	a6 9e		ldx $9e		          LDX PTR_LO          ; X = start index
.f958	a9 3a		lda #$3a	          LDA #':'
.f95a	9d 00 0b	sta $0b00,x	          STA T_Buffer,X      ; store ':'
.f95d	ca		dex		          DEX
.f95e	a5 bf		lda $bf		          LDA DRIVE
.f960	9d 00 0b	sta $0b00,x	          STA T_Buffer,X      ; precede command with drive and ':'
.f963	86 9e		stx $9e		          STX PTR_LO          ; update start index
.f965	a6 9f		ldx $9f		          LDX PTR_HI          ; filename length
.f967	f0 15		beq $f97e	          BEQ BOOT_65         ; -> nothing to load
.f969	e8		inx		          INX
.f96a	e8		inx		          INX
.f96b	8a		txa		          TXA                 ; length plus 2 (drive and :)
.f96c	a6 9e		ldx $9e		          LDX PTR_LO
.f96e	a0 0b		ldy #$0b	          LDY #11
.f970	20 31 f7	jsr $f731	          JSR SETNAM          ; prepare filename
.f973	a9 00		lda #$00	          LDA #0
.f975	aa		tax		          TAX
.f976	20 3f f7	jsr $f73f	          JSR SETBNK
.f979	a9 00		lda #$00	          LDA #0
.f97b	20 69 f2	jsr $f269	          JSR LOADSP_MEM      ; load file
.f97e	a9 0b		lda #$0b	BOOT_65   LDA #>T_Buffer
.f980	85 03		sta $03		          STA PC_HI
.f982	a9 0f		lda #$0f	          LDA #15
.f984	85 02		sta $02		          STA BANK
.f986	20 cd 02	jsr $02cd	          JSR JSRFAR          ; call boot sector address
.f989	18		clc		          CLC
.f98a	60		rts		          RTS
.f98b					  BOOT_Exit
.f98b	08		php		          PHP                 ; save status
.f98c	48		pha		          PHA                 ; save A
.f98d	20 cc ff	jsr $ffcc	          JSR K_CLRCH
.f990	a9 0d		lda #$0d	          LDA #13
.f992	18		clc		          CLC
.f993	20 c3 ff	jsr $ffc3	          JSR K_CLOSE         ; close floppy buffer channel
.f996	a2 00		ldx #$00	          LDX #0
.f998	20 c9 ff	jsr $ffc9	          JSR K_CKOUT         ; command channel
.f99b	b0 0a		bcs $f9a7	          BCS BOEx_10
.f99d	a9 55		lda #$55	          LDA #'U'
.f99f	20 d2 ff	jsr $ffd2	          JSR K_BSOUT
.f9a2	a9 49		lda #$49	          LDA #'I'
.f9a4	20 d2 ff	jsr $ffd2	          JSR K_BSOUT         ; send "UI" (reset floppy drive)
.f9a7	20 cc ff	jsr $ffcc	BOEx_10   JSR K_CLRCH
.f9aa	a9 00		lda #$00	          LDA #0
.f9ac	38		sec		          SEC
.f9ad	20 c3 ff	jsr $ffc3	          JSR K_CLOSE         ; close command channel
.f9b0	68		pla		          PLA
.f9b1	28		plp		          PLP
.f9b2	60		rts		          RTS
.f9b3					  Read_Next_Block
.f9b3	a6 c2		ldx $c2		          LDX STAH            ; sector
.f9b5	e8		inx		          INX                 ; next sector
.f9b6	e0 15		cpx #$15	          CPX #21             ; sector range:  0-20
.f9b8	90 04		bcc $f9be	          BCC NeBl_10
.f9ba	a2 00		ldx #$00	          LDX #0              ; set sector to tero
.f9bc	e6 c1		inc $c1		          INC STAL            ; increment track
.f9be	86 c2		stx $c2		NeBl_10   STX STAH            ; update sector
.f9c0	8a		txa		          TXA
.f9c1	20 fb f9	jsr $f9fb	          JSR Format_Byte     ; format sector
.f9c4	8d 00 01	sta $0100	          STA STACK
.f9c7	8e 01 01	stx $0101	          STX STACK+1         ; update sector in command string
.f9ca	a5 c1		lda $c1		          LDA STAL
.f9cc	20 fb f9	jsr $f9fb	          JSR Format_Byte     ; format track
.f9cf	8d 03 01	sta $0103	          STA STACK+3
.f9d2	8e 04 01	stx $0104	          STX STACK+4         ; update track in command string
.f9d5					  IEC_Read_Block
.f9d5	a2 00		ldx #$00	          LDX #0
.f9d7	20 c9 ff	jsr $ffc9	          JSR K_CKOUT         ; command channel
.f9da	a2 0c		ldx #$0c	          LDX #12
.f9dc	bd 00 01	lda $0100,x	ReBl_10   LDA STACK,X         ; send U1 block read command
.f9df	20 d2 ff	jsr $ffd2	          JSR K_BSOUT
.f9e2	ca		dex		          DEX
.f9e3	10 f7		bpl $f9dc	          BPL ReBl_10
.f9e5	20 cc ff	jsr $ffcc	          JSR K_CLRCH
.f9e8	a2 0d		ldx #$0d	          LDX #13
.f9ea	20 c6 ff	jsr $ffc6	          JSR K_CHKIN         ; floppy buffer channel
.f9ed	a0 00		ldy #$00	          LDY #0
.f9ef	20 cf ff	jsr $ffcf	ReBl_20   JSR K_BASIN         ; read from floppy buffer
.f9f2	20 bc f7	jsr $f7bc	          JSR STA_IND_SAL     ; store to memory
.f9f5	c8		iny		          INY
.f9f6	d0 f7		bne $f9ef	          BNE ReBl_20         ; loop until 256 bytes are read
.f9f8	4c cc ff	jmp $ffcc	          JMP K_CLRCH
.f9fb					  Format_Byte
.f9fb	a2 30		ldx #$30	          LDX #'0'
.f9fd	38		sec		          SEC
.f9fe	e9 0a		sbc #$0a	FoBy_10   SBC #10
.fa00	90 03		bcc $fa05	          BCC FoBy_20
.fa02	e8		inx		          INX
.fa03	b0 f9		bcs $f9fe	          BCS FoBy_10
.fa05	69 3a		adc #$3a	FoBy_20   ADC #'0'+10
.fa07	60		rts		          RTS
>fa08	30 30 20 31 30 20 30 20		BootComm  .TEXT "00 10 0 31:1U" ; U1:13 0 01 00 (1st. sector)
>fa10	33 31 3a 31 55
>fa15	49				InitDrive .TEXT "I"
>fa16	23				Hash      .TEXT "#"
.fa17					  PRIMM
.fa17	48		pha		          PHA
.fa18	8a		txa		          TXA
.fa19	48		pha		          PHA
.fa1a	98		tya		          TYA
.fa1b	48		pha		          PHA
.fa1c	a0 00		ldy #$00	          LDY #0
.fa1e	ba		tsx		PRIMM_10  TSX
.fa1f	fe 04 01	inc $0104,x	          INC STACK+4,X       ; return address low
.fa22	d0 03		bne $fa27	          BNE PRIMM_20
.fa24	fe 05 01	inc $0105,x	          INC STACK+5,X       ; return address high
.fa27	bd 04 01	lda $0104,x	PRIMM_20  LDA STACK+4,X
.fa2a	85 ce		sta $ce		          STA IMPARM
.fa2c	bd 05 01	lda $0105,x	          LDA STACK+5,X
.fa2f	85 cf		sta $cf		          STA IMPARM+1
.fa31	b1 ce		lda ($ce),y	          LDA (IMPARM),Y
.fa33	f0 05		beq $fa3a	          BEQ PRIMM_30
.fa35	20 d2 ff	jsr $ffd2	          JSR K_BSOUT
.fa38	90 e4		bcc $fa1e	          BCC PRIMM_10
.fa3a	68		pla		PRIMM_30  PLA
.fa3b	a8		tay		          TAY
.fa3c	68		pla		          PLA
.fa3d	aa		tax		          TAX
.fa3e	68		pla		          PLA
.fa3f	60		rts		          RTS                 ; 41 bytes
.fa40					  NMI_Normal
.fa40	d8		cld		          CLD                 ; clear decimal flag
.fa41	a9 7f		lda #$7f	          LDA #$7f
.fa43	8d 0d dd	sta $dd0d	          STA CIA2_ICR
.fa46	ac 0d dd	ldy $dd0d	          LDY CIA2_ICR
.fa49	30 14		bmi $fa5f	          BMI NMI_10          ; -> RS232 interrupt
.fa4b	20 3d f6	jsr $f63d	          JSR Check_STOP_Key
.fa4e	20 e1 ff	jsr $ffe1	          JSR K_STOP
.fa51	d0 0c		bne $fa5f	          BNE NMI_10          ; -> no STOP key pressed
.fa53	20 56 e0	jsr $e056	          JSR RESTOR          ; STOP RESTORE action
.fa56	20 09 e1	jsr $e109	          JSR IOINIT
.fa59	20 00 c0	jsr $c000	          JSR E_CINT
.fa5c	6c 00 0a	jmp ($0a00)	          JMP (RESET_VECTOR)
.fa5f	20 05 e8	jsr $e805	NMI_10    JSR RS_NMI_Main
.fa62	4c 33 ff	jmp $ff33	          JMP IRQ_Exit
.fa65					  IRQ_Normal
.fa65	d8		cld		          CLD                 ; clear decimal flag
.fa66	20 24 c0	jsr $c024	          JSR E_RASTER        ; check for raster interrupt
.fa69	90 12		bcc $fa7d	          BCC IRQN_10         ;
.fa6b	20 f8 f5	jsr $f5f8	          JSR UDTIM           ; update clock
.fa6e	20 d0 ee	jsr $eed0	          JSR TAPE_Switch_Sense
.fa71	ad 0d dc	lda $dc0d	          LDA CIA1_ICR        ; clear IRQ flags
.fa74	ad 04 0a	lda $0a04	          LDA INIT_STATUS
.fa77	4a		lsr a		          LSR A
.fa78	90 03		bcc $fa7d	          BCC IRQN_10
.fa7a	20 06 40	jsr $4006	          JSR B_BASIC_IRQ     ; perform BASIC tasks
.fa7d	4c 33 ff	jmp $ff33	IRQN_10   JMP IRQ_Exit
.fa80					  Keytab_Normal
>fa80	14 0d 1d 88			          .BYTE $14,$0d,$1d,$88 ; 00  DEL  CR   Down F7
>fa84	85 86 87 11			          .BYTE $85,$86,$87,$11 ; 04  F1   F3   F5   Right
>fa88	33 57 41 34			          .BYTE '3','W','A','4' ; 08  3    W    A    4
>fa8c	5a 53 45 01			          .BYTE 'Z','S','E',$01 ; 0C  Z    S    E    LShift
>fa90	35 52 44 36			          .BYTE '5','R','D','6' ; 10  5    R    D    6
>fa94	43 46 54 58			          .BYTE 'C','F','T','X' ; 14  C    F    T    X
>fa98	37 59 47 38			          .BYTE '7','Y','G','8' ; 18  7    Y    G    8
>fa9c	42 48 55 56			          .BYTE 'B','H','U','V' ; 1C  B    H    U    V
>faa0	39 49 4a 30			          .BYTE '9','I','J','0' ; 20  9    I    J    0
>faa4	4d 4b 4f 4e			          .BYTE 'M','K','O','N' ; 24  M    K    O    N
>faa8	2b 50 4c 2d			          .BYTE '+','P','L','-' ; 28  +    P    L    -
>faac	2e 3a 40 2c			          .BYTE '.',':','@',',' ; 2C  .    :    @    ,
>fab0	5c 2a 3b 13			          .BYTE $5c,'*',';',$13 ; 30  pnd  *    ;    HOME
>fab4	01 3d 5e 2f			          .BYTE $01,'=','^','/' ; 34  RShi =    ^    /
>fab8	31 5f 04 32			          .BYTE '1','_',$04,'2' ; 38  1    _    Ctrl 2
>fabc	20 02 51 03			          .BYTE ' ',$02,'Q',$03 ; 3C  SPC       Q    STOP
>fac0	84 38 35 09			          .BYTE $84,'8','5',$09 ; 40  HELP K8   K5   TAB
>fac4	32 34 37 31			          .BYTE '2','4','7','1' ; 44  K2   K4   K7   K1
>fac8	1b 2b 2d 0a			          .BYTE $1b,'+','-',$0a ; 48  ESC  K+   K-   LF
>facc	0d 36 39 33			          .BYTE $0d,'6','9','3' ; 4C  Entr K6   K9   K3
>fad0	08 30 2e 91			          .BYTE $08,'0','.',$91 ; 50  ALT  K0   K.   Up
>fad4	11 9d 1d ff			          .BYTE $11,$9d,$1d,$ff ; 54  Down Left Righ NOSCRL
>fad8	ff				          .BYTE $ff             ; 58
.fad9					  Keytab_Shifted
>fad9	94 8d 9d 8c			          .BYTE $94,$8d,$9d,$8c ; 00  INST ShCR Up   F8
>fadd	89 8a 8b 91			          .BYTE $89,$8a,$8b,$91 ; 04  F2   F4   F6   Left
>fae1	23 d7 c1 24			          .BYTE '#',$d7,$c1,'$' ; 08  #    W    A    $
>fae5	da d3 c5 01			          .BYTE $da,$d3,$c5,$01 ; 0C  Z    S    E    LShift
>fae9	25 d2 c4 26			          .BYTE '%',$d2,$c4,'&' ; 10  %    R    D    &
>faed	c3 c6 d4 d8			          .BYTE $c3,$c6,$d4,$d8 ; 14  C    F    T    X
>faf1	27 d9 c7 28			          .BYTE $27,$d9,$c7,'(' ; 18  Apo  Y    G    (
>faf5	c2 c8 d5 d6			          .BYTE $c2,$c8,$d5,$d6 ; 1C  B    H    U    V
>faf9	29 c9 ca 30			          .BYTE ')',$c9,$ca,'0' ; 20  )    I    J    0
>fafd	cd cb cf ce			          .BYTE $cd,$cb,$cf,$ce ; 24  M    K    O    N
>fb01	db d0 cc dd			          .BYTE $db,$d0,$cc,$dd ; 28  +    P    L    -
>fb05	3e 5b ba 3c			          .BYTE '>','[',$ba,'<' ; 2C  >    [    @    <
>fb09	a9 c0 5d 93			          .BYTE $a9,$c0,']',$93 ; 30  pnd  *    ]    CLR
>fb0d	01 3d de 3f			          .BYTE $01,'=',$de,'?' ; 34  RShi =    ^    ?
>fb11	21 5f 04 22			          .BYTE '!','_',$04,$22 ; 38  !    _    Ctrl Quote
>fb15	a0 02 d1 83			          .BYTE $a0,$02,$d1,$83 ; 3C  SPC       Q    RUN
>fb19	84 38 35 18			          .BYTE $84,'8','5',$18 ; 40  HELP K8   K5   TAB
>fb1d	32 34 37 31			          .BYTE '2','4','7','1' ; 44  K2   K4   K7   K1
>fb21	1b 2b 2d 0a			          .BYTE $1b,'+','-',$0a ; 48  ESC  K+   K-   LF
>fb25	8d 36 39 33			          .BYTE $8d,'6','9','3' ; 4C  Entr K6   K9   K3
>fb29	08 30 2e 91			          .BYTE $08,'0','.',$91 ; 50  ALT  K0   K.   Up
>fb2d	11 9d 1d ff			          .BYTE $11,$9d,$1d,$ff ; 54  Righ Left Down NOSCRL
>fb31	ff				          .BYTE $ff             ; 58
.fb32					  Keytab_CBM
>fb32	94 8d 9d 8c			          .BYTE $94,$8d,$9d,$8c ; 00  INST ShCR Up   F8
>fb36	89 8a 8b 91			          .BYTE $89,$8a,$8b,$91 ; 04  F2   F4   F6   Left
>fb3a	96 b3 b0 97			          .BYTE $96,$b3,$b0,$97 ; 08  #    W    A    $
>fb3e	ad ae b1 01			          .BYTE $ad,$ae,$b1,$01 ; 0C  Z    S    E    LShift
>fb42	98 b2 ac 99			          .BYTE $98,$b2,$ac,$99 ; 10  %    R    D    &
>fb46	bc bb a3 bd			          .BYTE $bc,$bb,$a3,$bd ; 14  C    F    T    X
>fb4a	9a b7 a5 9b			          .BYTE $9a,$b7,$a5,$9b ; 18  Apo  Y    G    (
>fb4e	bf b4 b8 be			          .BYTE $bf,$b4,$b8,$be ; 1C  B    H    U    V
>fb52	29 a2 b5 30			          .BYTE $29,$a2,$b5,$30 ; 20  )    I    J    0
>fb56	a7 a1 b9 aa			          .BYTE $a7,$a1,$b9,$aa ; 24  M    K    O    N
>fb5a	a6 af b6 dc			          .BYTE $a6,$af,$b6,$dc ; 28  +    P    L    -
>fb5e	3e 5b a4 3c			          .BYTE '>','[',$a4,'<' ; 2C  >    [    @    <
>fb62	a8 df 5d 93			          .BYTE $a8,$df,$5d,$93 ; 30  pnd  *    ]    CLR
>fb66	01 3d de 3f			          .BYTE $01,'=',$de,'?' ; 34  RShi =    ^    ?
>fb6a	81 5f 04 95			          .BYTE $81,$5f,$04,$95 ; 38  !    _    Ctrl Quote
>fb6e	a0 02 ab 03			          .BYTE $a0,$02,$ab,$03 ; 3C  SPC       Q    STOP
>fb72	84 38 35 18			          .BYTE $84,'8','5',$18 ; 40  HELP K8   K5   TAB
>fb76	32 34 37 31			          .BYTE '2','4','7','1' ; 44  K2   K4   K7   K1
>fb7a	1b 2b 2d 0a			          .BYTE $1b,'+','-',$0a ; 48  ESC  K+   K-   LF
>fb7e	8d 36 39 33			          .BYTE $8d,'6','9','3' ; 4C  Entr K6   K9   K3
>fb82	08 30 2e 91			          .BYTE $08,'0','.',$91 ; 50  ALT  K0   K.   Up
>fb86	11 9d 1d ff			          .BYTE $11,$9d,$1d,$ff ; 54  Righ Left Down NOSCRL
>fb8a	ff				          .BYTE $ff             ; 58
.fb8b					  Keytab_Control
>fb8b	ff ff ff ff			          .BYTE $ff,$ff,$ff,$ff ; 00  INST ShCR Up   F8
>fb8f	ff ff ff ff			          .BYTE $ff,$ff,$ff,$ff ; 04  F2   F4   F6   Left
>fb93	1c 17 01 9f			          .BYTE $1c,$17,$01,$9f ; 08  #    W    A    $
>fb97	1a 13 05 ff			          .BYTE $1a,$13,$05,$ff ; 0C  Z    S    E    LShift
>fb9b	9c 12 04 1e			          .BYTE $9c,$12,$04,$1e ; 10  %    R    D    &
>fb9f	03 06 14 18			          .BYTE $03,$06,$14,$18 ; 14  C    F    T    X
>fba3	1f 19 07 9e			          .BYTE $1f,$19,$07,$9e ; 18  Apo  Y    G    (
>fba7	02 08 15 16			          .BYTE $02,$08,$15,$16 ; 1C  B    H    U    V
>fbab	12 09 0a 92			          .BYTE $12,$09,$0a,$92 ; 20  )    I    J    0
>fbaf	0d 0b 0f 0e			          .BYTE $0d,$0b,$0f,$0e ; 24  M    K    O    N
>fbb3	ff 10 0c ff			          .BYTE $ff,$10,$0c,$ff ; 28  +    P    L    -
>fbb7	ff 1b 00 ff			          .BYTE $ff,$1b,$00,$ff ; 2C  >    [    @    <
>fbbb	1c ff 1d ff			          .BYTE $1c,$ff,$1d,$ff ; 30  pnd  *    ]    CLR
>fbbf	ff 1f 1e ff			          .BYTE $ff,$1f,$1e,$ff ; 34  RShi =    ^    ?
>fbc3	90 06 ff 05			          .BYTE $90,$06,$ff,$05 ; 38  !    _    Ctrl Quote
>fbc7	ff ff 11 ff			          .BYTE $ff,$ff,$11,$ff ; 3C  SPC       Q    STOP
>fbcb	84 38 35 18			          .BYTE $84,$38,$35,$18 ; 40  HELP K8   K5   TAB
>fbcf	32 34 37 31			          .BYTE $32,$34,$37,$31 ; 44  K2   K4   K7   K1
>fbd3	1b 2b 2d 0a			          .BYTE $1b,$2b,$2d,$0a ; 48  ESC  K+   K-   LF
>fbd7	8d 36 39 33			          .BYTE $8d,$36,$39,$33 ; 4C  Entr K6   K9   K3
>fbdb	08 30 2e 91			          .BYTE $08,$30,$2e,$91 ; 50  ALT  K0   K.   Up
>fbdf	11 9d 1d ff			          .BYTE $11,$9d,$1d,$ff ; 54  Righ Left Down NOSCRL
>fbe3	ff				          .BYTE $ff             ; 58
.fbe4					  Keytab_Capslock
>fbe4	14 0d 1d 88			          .BYTE $14,$0d,$1d,$88 ; 00  INST ShCR Up   F8
>fbe8	85 86 87 11			          .BYTE $85,$86,$87,$11 ; 04  F2   F4   F6   Left
>fbec	33 d7 c1 34			          .BYTE $33,$d7,$c1,$34 ; 08  #    W    A    $
>fbf0	da d3 c5 01			          .BYTE $da,$d3,$c5,$01 ; 0C  Z    S    E    LShift
>fbf4	35 d2 c4 36			          .BYTE $35,$d2,$c4,$36 ; 10  %    R    D    &
>fbf8	c3 c6 d4 d8			          .BYTE $c3,$c6,$d4,$d8 ; 14  C    F    T    X
>fbfc	37 d9 c7 38			          .BYTE $37,$d9,$c7,$38 ; 18  Apo  Y    G    (
>fc00	c2 c8 d5 d6			          .BYTE $c2,$c8,$d5,$d6 ; 1C  B    H    U    V
>fc04	39 c9 ca 30			          .BYTE $39,$c9,$ca,$30 ; 20  )    I    J    0
>fc08	cd cb cf ce			          .BYTE $cd,$cb,$cf,$ce ; 24  M    K    O    N
>fc0c	2b d0 cc 2d			          .BYTE $2b,$d0,$cc,$2d ; 28  +    P    L    -
>fc10	2e 3a 40 2c			          .BYTE $2e,$3a,$40,$2c ; 2C  >    [    @    <
>fc14	5c 2a 3b 13			          .BYTE $5c,$2a,$3b,$13 ; 30  pnd  *    ]    CLR
>fc18	01 3d 5e 2f			          .BYTE $01,$3d,$5e,$2f ; 34  RShi =    ^    ?
>fc1c	31 5f 04 32			          .BYTE $31,$5f,$04,$32 ; 38  !    _    Ctrl Quote
>fc20	20 02 d1 03			          .BYTE $20,$02,$d1,$03 ; 3C  SPC       Q    STOP
>fc24	84 38 35 09			          .BYTE $84,$38,$35,$09 ; 40  HELP K8   K5   TAB
>fc28	32 34 37 31			          .BYTE $32,$34,$37,$31 ; 44  K2   K4   K7   K1
>fc2c	1b 2b 2d 0a			          .BYTE $1b,$2b,$2d,$0a ; 48  ESC  K+   K-   LF
>fc30	0d 36 39 33			          .BYTE $0d,$36,$39,$33 ; 4C  Entr K6   K9   K3
>fc34	08 30 2e 91			          .BYTE $08,$30,$2e,$91 ; 50  ALT  K0   K.   Up
>fc38	11 9d 1d ff			          .BYTE $11,$9d,$1d,$ff ; 54  Righ Left Down NOSCRL
>fc3c	ff ff ff ff			          .BYTE $ff,$ff,$ff,$ff ; 58
.fc40					  Set_CRSW
.fc40	05 d6		ora $d6		          ORA CRSW
.fc42	85 d6		sta $d6		          STA CRSW
.fc44	a5 eb		lda $eb		          LDA Cursor_Row
.fc46	8d 30 0a	sta $0a30	          STA LINTMP
.fc49	60		rts		          RTS
.fc4a					  EA_to_SA
.fc4a	a5 ae		lda $ae		          LDA EAL
.fc4c	a4 af		ldy $af		          LDY EAH
.fc4e	85 ac		sta $ac		          STA SAL
.fc50	84 ad		sty $ad		          STY SAH
.fc52	4c 33 f5	jmp $f533	          JMP Loading_Verifying
.fc55					  Init_RS232
.fc55	8d 37 0a	sta $0a37	          STA VSH_SPEED
.fc58	8d 11 0a	sta $0a11	          STA RS_Command
.fc5b	8d 12 0a	sta $0a12	          STA RS_Baudrate
.fc5e	8d 13 0a	sta $0a13	          STA RS_Baudrate+1
.fc61	a2 06		ldx #$06	          LDX #6
.fc63	8e 10 0a	stx $0a10	          STX RS_Control
.fc66	60		rts		          RTS
.fc67					  VDC_Program_Mod
.fc67	a0 00		ldy #$00	          LDY #0
.fc69	a9 7f		lda #$7f	          LDA #$7f
.fc6b	8c 00 d6	sty $d600	          STY VDC_Register
.fc6e	8d 01 d6	sta $d601	          STA VDC_Data
.fc71	4c dc e1	jmp $e1dc	          JMP VDC_Program_X
>fc74	ff ff ff ff ff ff ff ff		          .BYTE $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff
>fc7c	ff ff ff ff
.fc80					  Edit_Patch_DIN
.fc80	8d c5 0a	sta $0ac5	          STA DINFLAG
.fc83	8d 18 d4	sta $d418	          STA SID_Volume
.fc86	60		rts		          RTS
.fc87					  K_Scan_Keyboard
.fc87	2c c5 0a	bit $0ac5	          BIT DINFLAG
.fc8a	30 37		bmi $fcc3	          BMI KEY_40          ; -> ASCII keyboard
.fc8c	a5 d3		lda $d3		          LDA SHFLAG
.fc8e	29 10		and #$10	          AND #%00010000     ; $10
.fc90	f0 0d		beq $fc9f	          BEQ KEY_10          ; -> No CAPS lock
.fc92	ad 3f 03	lda $033f	          LDA DECODE+1
.fc95	c9 fd		cmp #$fd	          CMP #>DIN_Normal
.fc97	f0 2a		beq $fcc3	          BEQ KEY_40
.fc99	a9 34		lda #$34	          LDA #<DIN_Key_Tables
.fc9b	a0 fe		ldy #$fe	          LDY #>DIN_Key_Tables
.fc9d	d0 0b		bne $fcaa	          BNE KEY_20          ; always
.fc9f	ad 3f 03	lda $033f	KEY_10    LDA DECODE+1
.fca2	c9 fa		cmp #$fa	          CMP #>Keytab_Normal
.fca4	f0 1d		beq $fcc3	          BEQ KEY_40
.fca6	a9 6f		lda #$6f	          LDA #<ASCII_Key_Tables
.fca8	a0 c0		ldy #$c0	          LDY #>ASCII_Key_Tables
.fcaa	85 cc		sta $cc		KEY_20    STA KEYTAB
.fcac	84 cd		sty $cd		          STY KEYTAB+1
.fcae	a0 0b		ldy #$0b	          LDY #11
.fcb0	b1 cc		lda ($cc),y	KEY_30    LDA (KEYTAB),Y      ; update table vectors
.fcb2	99 3e 03	sta $033e,y	          STA DECODE,Y
.fcb5	88		dey		          DEY
.fcb6	10 f8		bpl $fcb0	          BPL KEY_30
.fcb8	c8		iny		          INY
.fcb9	8c c5 0a	sty $0ac5	          STY DINFLAG         ; DINFLAG = 0
.fcbc	08		php		          PHP
.fcbd	78		sei		          SEI
.fcbe	20 0c ce	jsr $ce0c	          JSR Edit_Load_Chargen
.fcc1	28		plp		          PLP
.fcc2	60		rts		          RTS
.fcc3	4c 5d c5	jmp $c55d	KEY_40    JMP Scan_Keyboard
.fcc6					  Check_DIN
.fcc6	ae 3f 03	ldx $033f	          LDX DECODE+1
.fcc9	e0 fd		cpx #$fd	          CPX #>DIN_Normal
.fccb	d0 55		bne $fd22	          BNE CDIN_90         ; -> US keyboard mode
.fccd	ae c5 0a	ldx $0ac5	          LDX DINFLAG
.fcd0	30 50		bmi $fd22	          BMI CDIN_90         ; -> already in DIN mode
.fcd2	f0 1d		beq $fcf1	          BEQ CDIN_30         ; -> last key was not an accented key
.fcd4	bc 45 fe	ldy $fe45,x	          LDY Accent_Index,X  ; Y = # of diacritics to check
.fcd7	ca		dex		          DEX                 ; X = 0,1,2 for accent key
.fcd8	88		dey		CDIN_10   DEY                 ; Y = 2,6,11
.fcd9	48		pha		          PHA                 ; push A
.fcda	98		tya		          TYA                 ; A = 2,6,11
.fcdb	dd 45 fe	cmp $fe45,x	          CMP Accent_Index,X  ; compare with prevoius index
.fcde	68		pla		          PLA                 ; pull A
.fcdf	90 08		bcc $fce9	          BCC CDIN_20         ; -> exit comparison loop
.fce1	d9 4a fe	cmp $fe4a,y	          CMP Accent_Vocals-1,Y ; compare with allowed chars
.fce4	d0 f2		bne $fcd8	          BNE CDIN_10         ; -> no match: loop
.fce6	b9 65 fe	lda $fe65,y	          LDA Accent_Codes-1,Y      ; load diacritic character
.fce9	48		pha		CDIN_20   PHA
.fcea	29 7f		and #$7f	          AND #%01111111     ; $7f
.fcec	c9 20		cmp #$20	          CMP #' '            ; blank ?
.fcee	68		pla		          PLA
.fcef	90 23		bcc $fd14	          BCC CDIN_60         ; -> not printable
.fcf1	a2 05		ldx #$05	CDIN_30   LDX #5              ; check for accents and circumflex
.fcf3	dd 3f fe	cmp $fe3f,x	CDIN_40   CMP Accent_Key-1,X
.fcf6	f0 03		beq $fcfb	          BEQ CDIN_50         ; found accent acute, grave or circumflec
.fcf8	ca		dex		          DEX
.fcf9	d0 f8		bne $fcf3	          BNE CDIN_40
.fcfb	8e c5 0a	stx $0ac5	CDIN_50   STX DINFLAG         ; store accent index or zero
.fcfe	e0 00		cpx #$00	          CPX #0
.fd00	f0 20		beq $fd22	          BEQ CDIN_90         ; -> no accent key
.fd02	a8		tay		          TAY                 ; Y = key
.fd03	24 f6		bit $f6		          BIT INSFLG          ; insert flag ?
.fd05	30 0d		bmi $fd14	          BMI CDIN_60         ; -> branch on auto insert
.fd07	24 d7		bit $d7		          BIT MODE_80
.fd09	10 0a		bpl $fd15	          BPL CDIN_70         ; -> branch on 40 column mode
.fd0b	a2 0a		ldx #$0a	          LDX #10
.fd0d	20 da cd	jsr $cdda	          JSR VDC_Read_Register_X
.fd10	29 40		and #$40	          AND #%01000000     ; $40
.fd12	d0 06		bne $fd1a	          BNE CDIN_80         ; -> cursor is blinking
.fd14	60		rts		CDIN_60   RTS
.fd15	ad 27 0a	lda $0a27	CDIN_70   LDA BLNSW
.fd18	d0 fa		bne $fd14	          BNE CDIN_60
.fd1a	98		tya		CDIN_80   TYA
.fd1b	09 40		ora #$40	          ORA #%01000000     ; $40
.fd1d	29 7f		and #$7f	          AND #%01111111     ; $7f
.fd1f	4c 2f cc	jmp $cc2f	          JMP Edit_Put_Char_Att
.fd22	a6 d3		ldx $d3		CDIN_90   LDX SHFLAG
.fd24	a4 d5		ldy $d5		          LDY LSTX
.fd26	6c 3c 03	jmp ($033c)	          JMP (KEYCHK)        ; -> Edit_Use_Function_Key
.fd29					  DIN_Normal
>fd29	14 0d 1d 88			          .BYTE $14,$0d,$1d,$88 ; 00  DEL  CR   Down F7
>fd2d	85 86 87 11			          .BYTE $85,$86,$87,$11 ; 04  F1   F3   F5   Right
>fd31	33 57 41 34			          .BYTE '3','W','A','4' ; 08  3    W    A    4
>fd35	59 53 45 01			          .BYTE 'Y','S','E',$01 ; 0C [Y]   S    E    LShift
>fd39	35 52 44 36			          .BYTE '5','R','D','6' ; 10  5    R    D    6
>fd3d	43 46 54 58			          .BYTE 'C','F','T','X' ; 14  C    F    T    X
>fd41	37 5a 47 38			          .BYTE '7','Z','G','8' ; 18  7   [Z]   G    8
>fd45	42 48 55 56			          .BYTE 'B','H','U','V' ; 1C  B    H    U    V
>fd49	39 49 4a 30			          .BYTE '9','I','J','0' ; 20  9    I    J    0
>fd4d	4d 4b 4f 4e			          .BYTE 'M','K','O','N' ; 24  M    K    O    N
>fd51	be 50 4c af			          .BYTE $be,'P','L',$af ; 28 [sz]  P    L   [Acc]
>fd55	2e bc bd 2c			          .BYTE '.',$bc,$bd,',' ; 2C  .   [oe] [ue]  ,
>fd59	5b 2b bb 13			          .BYTE '[','+',$bb,$13 ; 30  [    +   [ae]  HOME
>fd5d	01 23 5d 2d			          .BYTE $01,'#',']','-' ; 34  RShi[#]   ]   [-]
>fd61	31 3c 04 32			          .BYTE '1','<',$04,'2' ; 38  1   [<]   Ctrl 2
>fd65	20 02 51 03			          .BYTE ' ',$02,'Q',$03 ; 3C  SPC       Q    STOP
>fd69	84 38 35 09			          .BYTE $84,'8','5',$09 ; 40  HELP K8   K5   TAB
>fd6d	32 34 37 31			          .BYTE '2','4','7','1' ; 44  K2   K4   K7   K1
>fd71	1b 2b 2d 0a			          .BYTE $1b,'+','-',$0a ; 48  ESC  K+   K-   LF
>fd75	0d 36 39 33			          .BYTE $0d,'6','9','3' ; 4C  Entr K6   K9   K3
>fd79	08 30 2e 91			          .BYTE $08,'0','.',$91 ; 50  ALT  K0   K.   Up
>fd7d	11 9d 1d ff			          .BYTE $11,$9d,$1d,$ff ; 54  Down Left Righ NOSCRL
>fd81	ff				          .BYTE $ff             ; 58
.fd82					  DIN_Shift
>fd82	94 8d 9d 8c			          .BYTE $94,$8d,$9d,$8c ; 00  INST ShCR Up   F8
>fd86	89 8a 8b 91			          .BYTE $89,$8a,$8b,$91 ; 04  F2   F4   F6   Left
>fd8a	40 d7 c1 24			          .BYTE $40,$d7,$c1,$24 ; 08  #    W    A    $
>fd8e	d9 d3 c5 01			          .BYTE $d9,$d3,$c5,$01 ; 0C [Y]   S    E    LShift
>fd92	25 d2 c4 26			          .BYTE $25,$d2,$c4,$26 ; 10  %    R    D    &
>fd96	c3 c6 d4 d8			          .BYTE $c3,$c6,$d4,$d8 ; 14  C    F    T    X
>fd9a	2f da c7 28			          .BYTE $2f,$da,$c7,$28 ; 18  Apo [Z]   G    (
>fd9e	c2 c8 d5 d6			          .BYTE $c2,$c8,$d5,$d6 ; 1C  B    H    U    V
>fda2	29 c9 ca 3d			          .BYTE $29,$c9,$ca,$3d ; 20  )    I    J    0
>fda6	cd cb cf ce			          .BYTE $cd,$cb,$cf,$ce ; 24  M    K    O    N
>fdaa	3f d0 cc c0			          .BYTE '?',$d0,$cc,$c0 ; 28 [?]   P    L   [Acc]
>fdae	3a dc dd 3b			          .BYTE ':',$dc,$dd,';' ; 2C [:]  [OE] [UE] [;]
>fdb2	5e 2a db 93			          .BYTE $5e,$2a,$db,$93 ; 30  pnd  *   [AE]  CLR
>fdb6	01 27 5c 5f			          .BYTE $01,$27,$5c,'_' ; 34  RShi[']   Pnd [_]
>fdba	21 3e 04 22			          .BYTE '!','>',$04,$22 ; 38  !   [>]   Ctrl Quote
>fdbe	a0 02 d1 83			          .BYTE $a0,$02,$d1,$83 ; 3C  SPC       Q    RUN
>fdc2	84 38 35 18			          .BYTE $84,$38,$35,$18 ; 40  HELP K8   K5   TAB
>fdc6	32 34 37 31			          .BYTE '2','4','7','1' ; 44  K2   K4   K7   K1
>fdca	1b 2b 2d 0a			          .BYTE $1b,'+','-',$0a ; 48  ESC  K+   K-   LF
>fdce	8d 36 39 33			          .BYTE $8d,'6','9','3' ; 4C  Entr K6   K9   K3
>fdd2	08 30 2e 91			          .BYTE $08,'0','.',$91 ; 50  ALT  K0   K.   Up
>fdd6	11 9d 1d ff			          .BYTE $11,$9d,$1d,$ff ; 54  Righ Left Down NOSCRL
>fdda	ff				          .BYTE $ff             ; 58
.fddb					  DIN_CBM
>fddb	94 8d 9d 8c			          .BYTE $94,$8d,$9d,$8c ; 00  INST ShCR Up   F8
>fddf	89 8a 8b 91			          .BYTE $89,$8a,$8b,$91 ; 04  F2   F4   F6   Left
>fde3	96 a7 a8 97			          .BYTE $96,$a7,$a8,$97 ; 08  #   [W]  [A]   $
>fde7	a2 aa a3 01			          .BYTE $a2,$aa,$a3,$01 ; 0C [Z]  [S]  [E]   LShift
>fdeb	98 a9 c4 99			          .BYTE $98,$a9,$c4,$99 ; 10  %   [R]  [D]   &
>fdef	c5 d3 ce a4			          .BYTE $c5,$d3,$ce,$a4 ; 14 [C]  [F]  [T]  [X]
>fdf3	9a c2 df 9b			          .BYTE $9a,$c2,$df,$9b ; 18  Apo [Y]  [G]   (
>fdf7	a1 c9 d6 d7			          .BYTE $a1,$c9,$d6,$d7 ; 1C [B]  [H]  [U]  [V]
>fdfb	d1 c3 d5 c1			          .BYTE $d1,$c3,$d5,$c1 ; 20 [)]  [I]  [J]  [0]
>fdff	cb da d8 cd			          .BYTE $cb,$da,$d8,$cd ; 24 [M]  [K]  [O]  [N]
>fe03	ab d9 c8 bf			          .BYTE $ab,$d9,$c8,$bf ; 28 [+]  [P]  [L]  [-]
>fe07	ba ca b0 ac			          .BYTE $ba,$ca,$b0,$ac ; 2C  >    [    @    <
>fe0b	ad a6 db 93			          .BYTE $ad,$a6,$db,$93 ; 30  pnd  *    ]    CLR
>fe0f	01 dd de b9			          .BYTE $01,$dd,$de,$b9 ; 34  RShi =    ^    ?
>fe13	81 b1 04 95			          .BYTE $81,$b1,$04,$95 ; 38  !    _    Ctrl Quote
>fe17	a0 02 a5 03			          .BYTE $a0,$02,$a5,$03 ; 3C  SPC       Q    STOP
>fe1b	84 38 35 18			          .BYTE $84,$38,$35,$18 ; 40  HELP K8   K5   TAB
>fe1f	32 34 37 31			          .BYTE $32,$34,$37,$31 ; 44  K2   K4   K7   K1
>fe23	1b 2b 2d 0a			          .BYTE $1b,$2b,$2d,$0a ; 48  ESC  K+   K-   LF
>fe27	8d 36 39 33			          .BYTE $8d,$36,$39,$33 ; 4C  Entr K6   K9   K3
>fe2b	08 30 2e 91			          .BYTE $08,$30,$2e,$91 ; 50  ALT  K0   K.   Up
>fe2f	11 9d 1d ff			          .BYTE $11,$9d,$1d,$ff ; 54  Righ Left Down NOSCRL
>fe33	ff				          .BYTE $ff             ; 58
.fe34					  DIN_Key_Tables
>fe34	29 fd				          .WORD DIN_Normal
>fe36	82 fd				          .WORD DIN_Shift
>fe38	db fd				          .WORD DIN_CBM
>fe3a	8b fb				          .WORD Keytab_Control
>fe3c	29 fd				          .WORD DIN_Normal
>fe3e	29 fd				          .WORD DIN_Normal
.fe40					  Accent_Key
>fe40	af				          .BYTE $af           ; accent acute       A
>fe41	c0				          .BYTE $c0           ; accent grave       A E U
>fe42	bf				          .BYTE $bf           ; accent circumflex  A E I O U
>fe43	00 00				          .FILL 2 ,0
.fe45					  Accent_Index
>fe45	01				          .BYTE  1            ; index to acute      table
>fe46	03				          .BYTE  3            ; index to grave      table
>fe47	07				          .BYTE  7            ; index to circumflex table
>fe48	0c				          .BYTE 12
>fe49	0c				          .BYTE 12
>fe4a	0c				          .BYTE 12
.fe4b					  Accent_Vocals
>fe4b	45 c0				          .BYTE 'E'    ,$c0   ; vocals with acute
>fe4d	41 45 55 af			          .TEXT "AEU"  ,$af   ; vocals with grave
>fe51	41 45 49 4f 55			          .TEXT "AEIOU"       ; vocals with circumflex
>fe56	ff ff ff ff ff ff ff ff		          .FILL 16 ,$ff
>fe5e	ff ff ff ff ff ff ff ff
.fe66					  Accent_Codes
>fe66	ac				          .BYTE $ac           ; e acute
>fe67	bf				          .BYTE $bf
>fe68	b2				          .BYTE $b2           ; a grave
>fe69	ae				          .BYTE $ae           ; e grave
>fe6a	b3				          .BYTE $b3           ; u grave
>fe6b	bf				          .BYTE $bf
>fe6c	b4				          .BYTE $b4           ; a circumflex
>fe6d	b5				          .BYTE $b5           ; e circumflex
>fe6e	b6				          .BYTE $b6           ; i circumflex
>fe6f	b7				          .BYTE $b7           ; o circumflex
>fe70	b8				          .BYTE $b8           ; u circumflex
>fe71	ff ff ff ff ff ff ff ff		          .FILL 16 ,$ff
>fe79	ff ff ff ff ff ff ff ff
.fe81					  DIN_or_ASCII
.fe81	a5 01		lda $01		          LDA R8502
.fe83	29 40		and #$40	          AND #%01000000     ; $40 extract bit 6
.fe85	49 40		eor #$40	          EOR #%01000000     ; $40 flip    bit 6
.fe87	4a		lsr a		          LSR A
.fe88	4a		lsr a		          LSR A               ; shift DIN bit to bit 4
.fe89	85 d3		sta $d3		          STA SHFLAG          ; store flag
.fe8b	60		rts		          RTS
>fe8c	ff ff ff ff ff ff ff ff		          .FILL $ff00-* ,$ff ;  116 bytes
>fe94	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
;	...repeated 5 times (80 bytes)...
>fef4	ff ff ff ff ff ff ff ff ff ff ff ff
>ff00	ff				MMU_CR    .BYTE $ff
>ff01	ff				MMU_LCRA  .BYTE $ff
>ff02	ff				MMU_LCRB  .BYTE $ff
>ff03	ff				MMU_LCRC  .BYTE $ff
>ff04	ff				MMU_LCRD  .BYTE $ff
.ff05					  NMI
.ff05	78		sei		          SEI
.ff06	48		pha		          PHA
.ff07	8a		txa		          TXA
.ff08	48		pha		          PHA
.ff09	98		tya		          TYA
.ff0a	48		pha		          PHA
.ff0b	ad 00 ff	lda $ff00	          LDA MMU_CR
.ff0e	48		pha		          PHA
.ff0f	a9 00		lda #$00	          LDA #0
.ff11	8d 00 ff	sta $ff00	          STA MMU_CR
.ff14	6c 18 03	jmp ($0318)	          JMP (INMI)
.ff17					  IRQ
.ff17	48		pha		          PHA                 ; push A
.ff18	8a		txa		          TXA
.ff19	48		pha		          PHA                 ; push X
.ff1a	98		tya		          TYA
.ff1b	48		pha		          PHA                 ; push Y
.ff1c	ad 00 ff	lda $ff00	          LDA MMU_CR
.ff1f	48		pha		          PHA                 ; push bank
.ff20	a9 00		lda #$00	          LDA #0
.ff22	8d 00 ff	sta $ff00	          STA MMU_CR          ; switch to system bank
.ff25	ba		tsx		          TSX
.ff26	bd 05 01	lda $0105,x	          LDA STACK+5,X       ; get IRQ flags
.ff29	29 10		and #$10	          AND #%00010000     ; test BRK flag
.ff2b	f0 03		beq $ff30	          BEQ IRQ_10          ; -> no BRK : jump to normal IRQ
.ff2d	6c 16 03	jmp ($0316)	          JMP (IBRK)
.ff30	6c 14 03	jmp ($0314)	IRQ_10    JMP (IIRQ)
.ff33	68		pla		IRQ_Exit  PLA                 ; pull bank
.ff34	8d 00 ff	sta $ff00	          STA MMU_CR
.ff37	68		pla		          PLA                 ; pull Y
.ff38	a8		tay		          TAY
.ff39	68		pla		          PLA                 ; pull X
.ff3a	aa		tax		          TAX
.ff3b	68		pla		          PLA                 ; pull A
.ff3c	40		rti		          RTI
.ff3d					  RESET
.ff3d	a9 00		lda #$00	          LDA #0
.ff3f	8d 00 ff	sta $ff00	          STA MMU_CR
.ff42	4c 00 e0	jmp $e000	          JMP System_Reset
>ff45	ff ff				          .WORD $ffff ;     1
.ff47	4c fb e5	jmp $e5fb	K_SPINIO  JMP SPINIO
.ff4a	4c 3d f2	jmp $f23d	K_CLOALL  JMP CLOALL
.ff4d	4c 4b e2	jmp $e24b	K_C64     JMP C64
.ff50	4c 80 cf	jmp $cf80	K_DMA     JMP DMA
.ff53	4c 90 f8	jmp $f890	K_BOOT    JMP BOOT
.ff56	4c 67 f8	jmp $f867	K_PHOENIX JMP PHOENIX
.ff59	4c 9d f7	jmp $f79d	K_LKUPLA  JMP LKUPLA
.ff5c	4c 86 f7	jmp $f786	K_LKUPSA  JMP LKUPSA
.ff5f	4c 2a c0	jmp $c02a	K_SWAPPER JMP E_SWAPPER
.ff62	4c 27 c0	jmp $c027	K_DLCHR   JMP E_DLCHR
.ff65	4c 21 c0	jmp $c021	K_PFKEY   JMP E_PFKEY
.ff68	4c 3f f7	jmp $f73f	K_SETBNK  JMP SETBNK
.ff6b	4c ec f7	jmp $f7ec	K_GETCFG  JMP GETCFG
.ff6e	4c cd 02	jmp $02cd	K_JSRFAR  JMP JSRFAR
.ff71	4c e3 02	jmp $02e3	K_JMPFAR  JMP JMPFAR
.ff74	4c d0 f7	jmp $f7d0	K_INDFET  JMP INDFET
.ff77	4c da f7	jmp $f7da	K_INDSTA  JMP INDSTA
.ff7a	4c e3 f7	jmp $f7e3	K_INDCMP  JMP INDCMP
.ff7d	4c 17 fa	jmp $fa17	K_PRIMM   JMP PRIMM
>ff80	01				K_VERSION .BYTE $01
.ff81	4c 00 c0	jmp $c000	K_CINT    JMP E_CINT
.ff84	4c 09 e1	jmp $e109	K_IOINIT  JMP IOINIT
.ff87	4c 93 e0	jmp $e093	K_RAMTAS  JMP RAMTAS
.ff8a	4c 56 e0	jmp $e056	K_RESTOR  JMP RESTOR
.ff8d	4c 5b e0	jmp $e05b	K_VECTOR  JMP VECTOR
.ff90	4c 5c f7	jmp $f75c	K_SETMSG  JMP SETMSG
.ff93	4c d2 e4	jmp $e4d2	K_SECND   JMP SECND
.ff96	4c e0 e4	jmp $e4e0	K_TKSA    JMP TKSA
.ff99	4c 63 f7	jmp $f763	K_MEMTOP  JMP MEMTOP
.ff9c	4c 72 f7	jmp $f772	K_MEMBOT  JMP MEMBOT
.ff9f	4c 12 c0	jmp $c012	K_KEY     JMP E_KEY
.ffa2	4c 5f f7	jmp $f75f	K_SETTMO  JMP SETTMO
.ffa5	4c 3e e4	jmp $e43e	K_ACPTR   JMP ACPTR
.ffa8	4c 03 e5	jmp $e503	K_CIOUT   JMP CIOUT
.ffab	4c 15 e5	jmp $e515	K_UNTLK   JMP UNTLK
.ffae	4c 26 e5	jmp $e526	K_UNLSN   JMP UNLSN
.ffb1	4c 3e e3	jmp $e33e	K_LISTN   JMP LISTN
.ffb4	4c 3b e3	jmp $e33b	K_TALK    JMP TALK
.ffb7	4c 44 f7	jmp $f744	K_READST  JMP READST
.ffba	4c 38 f7	jmp $f738	K_SETLFS  JMP SETLFS
.ffbd	4c 31 f7	jmp $f731	K_SETNAM  JMP SETNAM
.ffc0	6c 1a 03	jmp ($031a)	K_OPEN    JMP (IOPEN)
.ffc3	6c 1c 03	jmp ($031c)	K_CLOSE   JMP (ICLOSE)
.ffc6	6c 1e 03	jmp ($031e)	K_CHKIN   JMP (ICHKIN)
.ffc9	6c 20 03	jmp ($0320)	K_CKOUT   JMP (ICKOUT)
.ffcc	6c 22 03	jmp ($0322)	K_CLRCH   JMP (ICLRCH)
.ffcf	6c 24 03	jmp ($0324)	K_BASIN   JMP (IBASIN)
.ffd2	6c 26 03	jmp ($0326)	K_BSOUT   JMP (IBSOUT)
.ffd5	4c 65 f2	jmp $f265	K_LOADSP  JMP LOAD_AXY
.ffd8	4c 3e f5	jmp $f53e	K_SAVESP  JMP SAVESP
.ffdb	4c 65 f6	jmp $f665	K_SETTIM  JMP SETTIM
.ffde	4c 5e f6	jmp $f65e	K_RDTIM   JMP RDTIM
.ffe1	6c 28 03	jmp ($0328)	K_STOP    JMP (ISTOP)
.ffe4	6c 2a 03	jmp ($032a)	K_GETIN   JMP (IGETIN)
.ffe7	6c 2c 03	jmp ($032c)	K_CLALL   JMP (ICLALL)
.ffea	4c f8 f5	jmp $f5f8	K_UDTIM   JMP UDTIM
.ffed	4c 0f c0	jmp $c00f	K_SCRORG  JMP E_SCRORG
.fff0	4c 18 c0	jmp $c018	K_PLOT    JMP E_PLOT
.fff3	4c 81 f7	jmp $f781	K_IOBASE  JMP IOBASE
>fff6	ff ff				V_LOCK    .WORD $ffff ;     1
>fff8	24 e2				V_SYSTEM  .WORD SYSTEM
>fffa	05 ff				V_NMI     .WORD NMI
>fffc	3d ff				V_RESET   .WORD RESET
>fffe	17 ff				V_IRQ     .WORD IRQ

;******  End of listing
