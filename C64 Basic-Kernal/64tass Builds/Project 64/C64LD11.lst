
; 64tass Turbo Assembler Macro V1.53.1515 listing file
; 64tass -L C64LD11.lst -o C64LD11.prg C64LD11.asm
; Fri Jan 26 19:08:44 2018

;Offset	;Hex		;Monitor	;Source

;******  Processing input file: C64LD11.asm

=$00					LAB_00	= $00			; 6510 I/O port data direction register
=$01					LAB_01	= $01			; 6510 I/O port data register
=$03					LAB_03	= $03			; float to fixed vector low byte
=$04					LAB_04	= $04			; float to fixed vector high byte
=$05					LAB_05	= $05			; fixed to float vector low byte
=$06					LAB_06	= $06			; fixed to float vector high byte
=$07					LAB_07	= $07			; search character
=$08					LAB_08	= $08			; scan quotes flag
=$09					LAB_09	= $09			; TAB column save
=$0a					LAB_0A	= $0A			; load/verify flag, 0 = load, 1 = verify
=$0b					LAB_0B	= $0B			; temporary byte, line crunch/array access/logic operators
=$0c					LAB_0C	= $0C			; DIM flag
=$0d					LAB_0D	= $0D			; data type flag, $FF = string, $00 = numeric
=$0e					LAB_0E	= $0E			; data type flag, $80 = integer, $00 = floating point
=$0f					LAB_0F	= $0F			; garbage collected/open quote/DATA flag
=$10					LAB_10	= $10			; subscript/FNx flag
=$11					LAB_11	= $11			; input mode flag, $00 = INPUT, $40 = GET, $98 = READ
=$12					LAB_12	= $12			; ATN sign/comparison evaluation flag
=$13					LAB_13	= $13			; current I/O channel
=$14					LAB_14	= $14			; temporary integer low byte
=$15					LAB_15	= $15			; temporary integer high byte
=$16					LAB_16	= $16			; descriptor stack pointer, next free
=$17					LAB_17	= $17			; current descriptor stack item pointer low byte
=$18					LAB_18	= $18			; current descriptor stack item pointer high byte
=$19					LAB_19	= $19			; to $21, descriptor stack
=$22					LAB_22	= $22			; misc temp byte
=$23					LAB_23	= $23			; misc temp byte
=$24					LAB_24	= $24			; misc temp byte
=$25					LAB_25	= $25			; misc temp byte
=$26					LAB_26	= $26			; temp mantissa 1
=$27					LAB_27	= $27			; temp mantissa 2
=$28					LAB_28	= $28			; temp mantissa 3
=$29					LAB_29	= $29			; temp mantissa 4
=$2b					LAB_2B	= $2B			; start of memory low byte
=$2c					LAB_2C	= $2C			; start of memory high byte
=$2d					LAB_2D	= $2D			; start of variables low byte
=$2e					LAB_2E	= $2E			; start of variables high byte
=$2f					LAB_2F	= $2F			; end of variables low byte
=$30					LAB_30	= $30			; end of variables high byte
=$31					LAB_31	= $31			; end of arrays low byte
=$32					LAB_32	= $32			; end of arrays high byte
=$33					LAB_33	= $33			; bottom of string space low byte
=$34					LAB_34	= $34			; bottom of string space high byte
=$35					LAB_35	= $35			; string utility ptr low byte
=$36					LAB_36	= $36			; string utility ptr high byte
=$37					LAB_37	= $37			; end of memory low byte
=$38					LAB_38	= $38			; end of memory high byte
=$39					LAB_39	= $39			; current line number low byte
=$3a					LAB_3A	= $3A			; current line number high byte
=$3b					LAB_3B	= $3B			; break line number low byte
=$3c					LAB_3C	= $3C			; break line number high byte
=$3d					LAB_3D	= $3D			; continue pointer low byte
=$3e					LAB_3E	= $3E			; continue pointer high byte
=$3f					LAB_3F	= $3F			; current DATA line number low byte
=$40					LAB_40	= $40			; current DATA line number high byte
=$41					LAB_41	= $41			; DATA pointer low byte
=$42					LAB_42	= $42			; DATA pointer high byte
=$43					LAB_43	= $43			; READ pointer low byte
=$44					LAB_44	= $44			; READ pointer high byte
=$45					LAB_45	= $45			; current variable name first byte
=$46					LAB_46	= $46			; current variable name second byte
=$47					LAB_47	= $47			; current variable address low byte
=$48					LAB_48	= $48			; current variable address high byte
=$49					LAB_49	= $49			; FOR/NEXT variable pointer low byte
=$4a					LAB_4A	= $4A			; FOR/NEXT variable pointer high byte
=$4b					LAB_4B	= $4B			; BASIC execute pointer temporary low byte/precedence flag
=$4c					LAB_4C	= $4C			; BASIC execute pointer temporary high byte
=$4d					LAB_4D	= $4D			; comparrison evaluation flag
=$4e					LAB_4E	= $4E			; FAC temp store/function/variable/garbage pointer low byte
=$4f					LAB_4F	= $4F			; FAC temp store/function/variable/garbage pointer high byte
=$50					LAB_50	= $50			; FAC temp store/descriptor pointer low byte
=$51					LAB_51	= $51			; FAC temp store/descriptor pointer high byte
=$53					LAB_53	= $53			; garbage collection step size
=$54					LAB_54	= $54			; JMP opcode for functions
=$55					LAB_55	= $55			; functions jump vector low byte
=$56					LAB_56	= $56			; functions jump vector high byte
=$57					LAB_57	= $57			; FAC temp store
=$58					LAB_58	= $58			; FAC temp store
=$59					LAB_59	= $59			; FAC temp store
=$5a					LAB_5A	= $5A			; FAC temp store
=$5b					LAB_5B	= $5B			; block end high byte
=$5c					LAB_5C	= $5C			; FAC temp store
=$5d					LAB_5D	= $5D			; FAC temp store
=$5e					LAB_5E	= $5E			; FAC temp store
=$5f					LAB_5F	= $5F			; FAC temp store
=$60					LAB_60	= $60			; block start high byte
=$61					LAB_61	= $61			; FAC1 exponent
=$62					LAB_62	= $62			; FAC1 mantissa 1
=$63					LAB_63	= $63			; FAC1 mantissa 2
=$64					LAB_64	= $64			; FAC1 mantissa 3
=$65					LAB_65	= $65			; FAC1 mantissa 4
=$66					LAB_66	= $66			; FAC1 sign
=$67					LAB_67	= $67			; constant count/-ve flag
=$68					LAB_68	= $68			; FAC1 overflow
=$69					LAB_69	= $69			; FAC2 exponent
=$6a					LAB_6A	= $6A			; FAC2 mantissa 1
=$6b					LAB_6B	= $6B			; FAC2 mantissa 2
=$6c					LAB_6C	= $6C			; FAC2 mantissa 3
=$6d					LAB_6D	= $6D			; FAC2 mantissa 4
=$6e					LAB_6E	= $6E			; FAC2 sign
=$6f					LAB_6F	= $6F			; FAC sign comparrison
=$70					LAB_70	= $70			; FAC1 rounding
=$71					LAB_71	= $71			; temp BASIC execute/array pointer low byte/index
=$72					LAB_72	= $72			; temp BASIC execute/array pointer high byte
=$73					LAB_0073	= $73			; increment and scan memory, BASIC byte get
=$79					LAB_0079	= $79			; scan memory, BASIC byte get
=$7a					LAB_7A	= $7A			; BASIC execute pointer low byte
=$7b					LAB_7B	= $7B			; BASIC execute pointer high byte
=$80					LAB_80	= $80			; numeric test entry
=$8b					LAB_8B	= $8B			; RND() seed, five bytes
=$90					LAB_90	= $90			; serial status byte
=$91					LAB_91	= $91			; stop key column
=$92					LAB_92	= $92			; timing constant for tape read
=$93					LAB_93	= $93			; load/verify flag, load = $00, verify = $01
=$94					LAB_94	= $94			; serial output: deferred character flag
=$95					LAB_95	= $95			; serial output: deferred character
=$96					LAB_96	= $96			; cassette block synchronization number
=$97					LAB_97	= $97			; X register save
=$98					LAB_98	= $98			; open file count
=$99					LAB_99	= $99			; input device number
=$9a					LAB_9A	= $9A			; output device number
=$9b					LAB_9B	= $9B			; tape character parity
=$9c					LAB_9C	= $9C			; tape byte received flag
=$9d					LAB_9D	= $9D			; message mode flag,
=$9e					LAB_9E	= $9E			; tape Pass 1 error log/character buffer
=$9f					LAB_9F	= $9F			; tape Pass 1 error log/character index
=$a0					LAB_A0	= $A0			; jiffy clock high byte
=$a1					LAB_A1	= $A1			; jiffy clock mid byte
=$a2					LAB_A2	= $A2			; jiffy clock low byte
=$a3					LAB_A3	= $A3			; EOI flag byte/tape bit count
=$a4					LAB_A4	= $A4			; tape bit cycle phase
=$a5					LAB_A5	= $A5			; cassette synchronization byte count/serial bus bit count
=$a6					LAB_A6	= $A6			; tape buffer index
=$a7					LAB_A7	= $A7			; receiver input bit temp storage
=$a8					LAB_A8	= $A8			; receiver bit count in
=$a9					LAB_A9	= $A9			; receiver start bit check flag, $90 = no start bit
=$aa					LAB_AA	= $AA			; receiver byte buffer/assembly location
=$ab					LAB_AB	= $AB			; receiver parity bit storage
=$ac					LAB_AC	= $AC			; tape buffer start pointer low byte
=$ad					LAB_AD	= $AD			; tape buffer start pointer high byte
=$ae					LAB_AE	= $AE			; tape buffer end pointer low byte
=$af					LAB_AF	= $AF			; tape buffer end pointer high byte
=$b0					LAB_B0	= $B0			; tape timing constant min byte
=$b1					LAB_B1	= $B1			; tape timing constant max byte
=$b2					LAB_B2	= $B2			; tape buffer start pointer low byte
=$b3					LAB_B3	= $B3			; tape buffer start pointer high byte
=$b4					LAB_B4	= $B4			; transmitter bit count out
=$b5					LAB_B5	= $B5			; transmitter next bit to be sent
=$b6					LAB_B6	= $B6			; transmitter byte buffer/disassembly location
=$b7					LAB_B7	= $B7			; file name length
=$b8					LAB_B8	= $B8			; logical file
=$b9					LAB_B9	= $B9			; secondary address
=$ba					LAB_BA	= $BA			; current device number
=$bb					LAB_BB	= $BB			; file name pointer low byte
=$bc					LAB_BC	= $BC			; file name pointer high byte
=$bd					LAB_BD	= $BD			; tape write byte/RS232 parity byte
=$be					LAB_BE	= $BE			; tape copies count
=$bf					LAB_BF	= $BF			; tape parity count
=$c0					LAB_C0	= $C0			; tape motor interlock
=$c1					LAB_C1	= $C1			; I/O start addresses low byte
=$c2					LAB_C2	= $C2			; I/O start addresses high byte
=$c3					LAB_C3	= $C3			; kernal setup pointer low byte
=$c4					LAB_C4	= $C4			; kernal setup pointer high byte
=$c5					LAB_C5	= $C5			; current key pressed
=$c6					LAB_C6	= $C6			; keyboard buffer length/index
=$c7					LAB_C7	= $C7			; reverse flag $12 = reverse, $00 = normal
=$c8					LAB_C8	= $C8			; input [EOL] pointer
=$c9					LAB_C9	= $C9			; input cursor row
=$ca					LAB_CA	= $CA			; input cursor column
=$cb					LAB_CB	= $CB			; which key
=$cc					LAB_CC	= $CC			; cursor enable, $00 = flash cursor
=$cd					LAB_CD	= $CD			; cursor timing countdown
=$ce					LAB_CE	= $CE			; character under cursor
=$cf					LAB_CF	= $CF			; cursor blink phase
=$d0					LAB_D0	= $D0			; input from keyboard or screen, $xx = input is available
=$d1					LAB_D1	= $D1			; current screen line pointer low byte
=$d2					LAB_D2	= $D2			; current screen line pointer high byte
=$d3					LAB_D3	= $D3			; cursor column
=$d4					LAB_D4	= $D4			; cursor quote flag
=$d5					LAB_D5	= $D5			; current screen line length
=$d6					LAB_D6	= $D6			; cursor row
=$d7					LAB_D7	= $D7			; checksum byte/temporary last character
=$d8					LAB_D8	= $D8			; insert count
=$d9					LAB_D9	= $D9			; to LAB_D9 + $18 inclusive, screen line link table
=$f3					LAB_F3	= $F3			; colour RAM pointer low byte
=$f4					LAB_F4	= $F4			; colour RAM pointer high byte
=$f5					LAB_F5	= $F5			; keyboard pointer low byte
=$f6					LAB_F6	= $F6			; keyboard pointer high byte
=$f7					LAB_F7	= $F7			; RS232 Rx pointer low byte
=$f8					LAB_F8	= $F8			; RS232 Rx pointer high byte
=$f9					LAB_F9	= $F9			; RS232 Tx pointer low byte
=$fa					LAB_FA	= $FA			; RS232 Tx pointer high byte
=$ff					LAB_FF	= $FF			; string conversion address
=$0100					LAB_0100	= $0100		;.
=$0101					LAB_0101	= $0101		;.
=$0102					LAB_0102	= $0102		;.
=$0103					LAB_0103	= $0103		;.
=$0104					LAB_0104	= $0104		;.
=$0109					LAB_0109	= $0109		;.
=$010f					LAB_010F	= $010F		;.
=$0110					LAB_0110	= $0110		;.
=$0111					LAB_0111	= $0111		;.
=$0112					LAB_0112	= $0112		;.
=$01fc					LAB_01FC	= $01FC		; start of crunched line
=$01fd					LAB_01FD	= $01FD		;.
=$01fe					LAB_01FE	= $01FE		;.
=$01ff					LAB_01FF	= $01FF		; input buffer - 1
=$0200					LAB_0200	= $0200		; input buffer. for some routines the byte before the input
=$0201					LAB_0201	= $0201		; address for GET byte
=$0259					LAB_0259	= $0259		; .. to LAB_0262 logical file table
=$0263					LAB_0263	= $0263		; .. to LAB_026C device number table
=$026d					LAB_026D	= $026D		; .. to LAB_0276 secondary address table
=$0277					LAB_0277	= $0277		; .. to LAB_0280 keyboard buffer
=$0281					LAB_0281	= $0281		; OS start of memory low byte
=$0282					LAB_0282	= $0282		; OS start of memory high byte
=$0283					LAB_0283	= $0283		; OS top of memory low byte
=$0284					LAB_0284	= $0284		; OS top of memory high byte
=$0285					LAB_0285	= $0285		; serial bus timeout flag
=$0286					LAB_0286	= $0286		; current colour code
=$0287					LAB_0287	= $0287		; colour under cursor
=$0288					LAB_0288	= $0288		; screen memory page
=$0289					LAB_0289	= $0289		; maximum keyboard buffer size
=$028a					LAB_028A	= $028A		; key repeat. $80 = repeat all, $40 = repeat none,
=$028b					LAB_028B	= $028B		; repeat speed counter
=$028c					LAB_028C	= $028C		; repeat delay counter
=$028d					LAB_028D	= $028D		; keyboard shift/control flag
=$028e					LAB_028E	= $028E		; SHIFT/CTRL/C= keypress last pattern
=$028f					LAB_028F	= $028F		; keyboard decode logic pointer low byte
=$0290					LAB_0290	= $0290		; keyboard decode logic pointer high byte
=$0291					LAB_0291	= $0291		; shift mode switch, $00 = enabled, $80 = locked
=$0292					LAB_0292	= $0292		; screen scrolling flag, $00 = enabled
=$0293					LAB_0293	= $0293		; pseudo 6551 control register. the first character of
=$0294					LAB_0294	= $0294		; pseudo 6551 command register. the second character of
=$0295					LAB_0295	= $0295		; nonstandard bit timing low byte. the third character
=$0296					LAB_0296	= $0296		; nonstandard bit timing high byte. the fourth character
=$0297					LAB_0297	= $0297		; RS-232 status register
=$0298					LAB_0298	= $0298		; number of bits to be sent/received
=$0299					LAB_0299	= $0299		; bit time low byte
=$029a					LAB_029A	= $029A		; bit time high byte
=$029b					LAB_029B	= $029B		; index to Rx buffer end
=$029c					LAB_029C	= $029C		; index to Rx buffer start
=$029d					LAB_029D	= $029D		; index to Tx buffer start
=$029e					LAB_029E	= $029E		; index to Tx buffer end
=$029f					LAB_029F	= $029F		; saved IRQ low byte
=$02a0					LAB_02A0	= $02A0		; saved IRQ high byte
=$02a1					LAB_02A1	= $02A1		; RS-232 interrupt enable byte
=$02a2					LAB_02A2	= $02A2		; VIA 1 CRB shadow copy
=$02a3					LAB_02A3	= $02A3		; VIA 1 ICR shadow copy
=$02a4					LAB_02A4	= $02A4		; VIA 1 CRA shadow copy
=$02a5					LAB_02A5	= $02A5		; temp Index to the next line for scrolling
=$02a6					LAB_02A6	= $02A6		; PAL/NTSC flag
=$0300					LAB_0300	= $0300		; vector to the print BASIC error message routine
=$0302					LAB_0302	= $0302		; Vector to the main BASIC program Loop
=$0304					LAB_0304	= $0304		; Vector to the the ASCII text to keywords routine
=$0306					LAB_0306	= $0306		; Vector to the list BASIC program as ASCII routine
=$0308					LAB_0308	= $0308		; Vector to the execute next BASIC command routine
=$030a					LAB_030A	= $030A		; Vector to the get value from BASIC line routine
=$030c					LAB_030C	= $030C		; A for SYS command
=$030d					LAB_030D	= $030D		; X for SYS command
=$030e					LAB_030E	= $030E		; Y for SYS command
=$030f					LAB_030F	= $030F		; P for SYS command
=$0310					LAB_0310	= $0310		; JMP instruction for user function
=$0311					LAB_0311	= $0311		; user function vector low byte
=$0312					LAB_0312	= $0312		; user function vector high byte
=$0314					LAB_0314	= $0314		; IRQ vector low byte
=$0315					LAB_0315	= $0315		; IRQ vector high byte
=$0316					LAB_0316	= $0316		; BRK vector
=$0318					LAB_0318	= $0318		; NMI vector
=$031a					LAB_031A	= $031A		; kernal vector - open a logical file
=$031c					LAB_031C	= $031C		; kernal vector - close a specified logical file
=$031e					LAB_031E	= $031E		; kernal vector - open channel for input
=$0320					LAB_0320	= $0320		; kernal vector - open channel for output
=$0322					LAB_0322	= $0322		; kernal vector - close input and output channels
=$0324					LAB_0324	= $0324		; kernal vector - input character from channel
=$0326					LAB_0326	= $0326		; kernal vector - output character to channel
=$0328					LAB_0328	= $0328		; kernal vector - scan stop key
=$032a					LAB_032A	= $032A		; kernal vector - get character from keyboard queue
=$032c					LAB_032C	= $032C		; kernal vector - close all channels and files
=$0330					LAB_0330	= $0330		; kernal vector - load
=$0332					LAB_0332	= $0332		; kernal vector - save
=$033c					LAB_033C	= $033C		; cassette buffer
=$8000					LAB_8000	= $8000		; autostart ROM initial entry vector
=$8002					LAB_8002	= $8002		; autostart ROM break entry
=$8004					LAB_8004	= $8004		; autostart ROM identifier string start
=$d000					LAB_D000	= $D000		; vic ii chip base address
=$d011					LAB_D011	= $D011		; vertical fine scroll and control
=$d012					LAB_D012	= $D012		; raster compare register
=$d016					LAB_D016	= $D016		; horizontal fine scroll and control
=$d018					LAB_D018	= $D018		; memory control
=$d019					LAB_D019	= $D019		; vic interrupt flag register
=$d418					LAB_D418	= $D418		; volume and filter select
=$d800					LAB_D800	= $D800		; 1K colour RAM base address
=$dc00					LAB_DC00	= $DC00		; VIA 1 DRA, keyboard column drive
=$dc01					LAB_DC01	= $DC01		; VIA 1 DRB, keyboard row port
=$dc02					LAB_DC02	= $DC02		; VIA 1 DDRA, keyboard column
=$dc03					LAB_DC03	= $DC03		; VIA 1 DDRB, keyboard row
=$dc04					LAB_DC04	= $DC04		; VIA 1 timer A low byte
=$dc05					LAB_DC05	= $DC05		; VIA 1 timer A high byte
=$dc06					LAB_DC06	= $DC06		; VIA 1 timer B low byte
=$dc07					LAB_DC07	= $DC07		; VIA 1 timer B high byte
=$dc0d					LAB_DC0D	= $DC0D		; VIA 1 ICR
=$dc0e					LAB_DC0E	= $DC0E		; VIA 1 CRA
=$dc0f					LAB_DC0F	= $DC0F		; VIA 1 CRB
=$dd00					LAB_DD00	= $DD00		; VIA 2 DRA, serial port and video address
=$dd01					LAB_DD01	= $DD01		; VIA 2 DRB, RS232 port
=$dd02					LAB_DD02	= $DD02		; VIA 2 DDRA, serial port and video address
=$dd03					LAB_DD03	= $DD03		; VIA 2 DDRB, RS232 port
=$dd04					LAB_DD04	= $DD04		; VIA 2 timer A low byte
=$dd05					LAB_DD05	= $DD05		; VIA 2 timer A high byte
=$dd06					LAB_DD06	= $DD06		; VIA 2 timer B low byte
=$dd07					LAB_DD07	= $DD07		; VIA 2 timer B high byte
=$dd0d					LAB_DD0D	= $DD0D		; VIA 2 ICR
=$dd0e					LAB_DD0E	= $DD0E		; VIA 2 CRA
=$dd0f					LAB_DD0F	= $DD0F		; VIA 2 CRB
=$81					TK_FOR	= $81			; FOR token
=$83					TK_DATA	= $83			; DATA token
=$89					TK_GOTO	= $89			; GOTO token
=$8d					TK_GOSUB	= $8D			; GOSUB token
=$8f					TK_REM	= $8F			; REM token
=$99					TK_PRINT	= $99			; PRINT token
=$a3					TK_TAB	= $A3			; TAB( token
=$a4					TK_TO		= $A4			; TO token
=$a5					TK_FN		= $A5			; FN token
=$a6					TK_SPC	= $A6			; SPC( token
=$a7					TK_THEN	= $A7			; THEN token
=$a8					TK_NOT	= $A8			; NOT token
=$a9					TK_STEP	= $A9			; STEP token
=$aa					TK_PLUS	= $AA			; + token
=$ab					TK_MINUS	= $AB			; - token
=$b1					TK_GT		= $B1			; > token
=$b2					TK_EQUAL	= $B2			; = token
=$b4					TK_SGN	= $B4			; SGN token
=$cb					TK_GO		= $CB			; GO token
=$ff					TK_PI		= $FF			; PI token
.a000					LAB_A000
>a000	94 e3					.word	LAB_E394		; BASIC cold start entry point
.a002					LAB_A002
>a002	7b e3					.word	LAB_E37B		; BASIC warm start entry point
>a004	43 42 4d 42 41 53 49 43			.text	"CBMBASIC"		; ROM name, unreferenced
.a00c					LAB_A00C
>a00c	30 a8					.word	LAB_A831-1		; perform END		$80
>a00e	41 a7					.word	LAB_A742-1		; perform FOR		$81
>a010	1d ad					.word	LAB_AD1E-1		; perform NEXT		$82
>a012	f7 a8					.word	LAB_A8F8-1		; perform DATA		$83
>a014	a4 ab					.word	LAB_ABA5-1		; perform INPUT#		$84
>a016	be ab					.word	LAB_ABBF-1		; perform INPUT		$85
>a018	80 b0					.word	LAB_B081-1		; perform DIM		$86
>a01a	05 ac					.word	LAB_AC06-1		; perform READ		$87
>a01c	a4 a9					.word	LAB_A9A5-1		; perform LET		$88
>a01e	9f a8					.word	LAB_A8A0-1		; perform GOTO		$89
>a020	70 a8					.word	LAB_A871-1		; perform RUN		$8A
>a022	27 a9					.word	LAB_A928-1		; perform IF		$8B
>a024	1c a8					.word	LAB_A81D-1		; perform RESTORE		$8C
>a026	82 a8					.word	LAB_A883-1		; perform GOSUB		$8D
>a028	d1 a8					.word	LAB_A8D2-1		; perform RETURN		$8E
>a02a	3a a9					.word	LAB_A93B-1		; perform REM		$8F
>a02c	2e a8					.word	LAB_A82F-1		; perform STOP		$90
>a02e	4a a9					.word	LAB_A94B-1		; perform ON		$91
>a030	2c b8					.word	LAB_B82D-1		; perform WAIT		$92
>a032	67 e1					.word	LAB_E168-1		; perform LOAD		$93
>a034	55 e1					.word	LAB_E156-1		; perform SAVE		$94
>a036	64 e1					.word	LAB_E165-1		; perform VERIFY		$95
>a038	b2 b3					.word	LAB_B3B3-1		; perform DEF		$96
>a03a	23 b8					.word	LAB_B824-1		; perform POKE		$97
>a03c	7f aa					.word	LAB_AA80-1		; perform PRINT#		$98
>a03e	9f aa					.word	LAB_AAA0-1		; perform PRINT		$99
>a040	56 a8					.word	LAB_A857-1		; perform CONT		$9A
>a042	9b a6					.word	LAB_A69C-1		; perform LIST		$9B
>a044	5d a6					.word	LAB_A65E-1		; perform CLR		$9C
>a046	85 aa					.word	LAB_AA86-1		; perform CMD		$9D
>a048	29 e1					.word	LAB_E12A-1		; perform SYS		$9E
>a04a	bd e1					.word	LAB_E1BE-1		; perform OPEN		$9F
>a04c	c6 e1					.word	LAB_E1C7-1		; perform CLOSE		$A0
>a04e	7a ab					.word	LAB_AB7B-1		; perform GET		$A1
>a050	41 a6					.word	LAB_A642-1		; perform NEW		$A2
.a052					LAB_A052
>a052	39 bc					.word	LAB_BC39		; perform SGN()		$B4
>a054	cc bc					.word	LAB_BCCC		; perform INT()		$B5
>a056	58 bc					.word	LAB_BC58		; perform ABS()		$B6
>a058	10 03					.word	LAB_0310		; perform USR()		$B7
>a05a	7d b3					.word	LAB_B37D		; perform FRE()		$B8
>a05c	9e b3					.word	LAB_B39E		; perform POS()		$B9
>a05e	71 bf					.word	LAB_BF71		; perform SQR()		$BA
>a060	97 e0					.word	LAB_E097		; perform RND()		$BB
>a062	ea b9					.word	LAB_B9EA		; perform LOG()		$BC
>a064	ed bf					.word	LAB_BFED		; perform EXP()		$BD
>a066	64 e2					.word	LAB_E264		; perform COS()		$BE
>a068	6b e2					.word	LAB_E26B		; perform SIN()		$BF
>a06a	b4 e2					.word	LAB_E2B4		; perform TAN()		$C0
>a06c	0e e3					.word	LAB_E30E		; perform ATN()		$C1
>a06e	0d b8					.word	LAB_B80D		; perform PEEK()		$C2
>a070	7c b7					.word	LAB_B77C		; perform LEN()		$C3
>a072	65 b4					.word	LAB_B465		; perform STR$()		$C4
>a074	ad b7					.word	LAB_B7AD		; perform VAL()		$C5
>a076	8b b7					.word	LAB_B78B		; perform ASC()		$C6
>a078	ec b6					.word	LAB_B6EC		; perform CHR$()		$C7
>a07a	00 b7					.word	LAB_B700		; perform LEFT$()		$C8
>a07c	2c b7					.word	LAB_B72C		; perform RIGHT$()	$C9
>a07e	37 b7					.word	LAB_B737		; perform MID$()		$CA
.a080					LAB_A080
>a080	79					.byte	$79
>a081	69 b8					.word	LAB_B86A-1		; +
>a083	79					.byte	$79
>a084	52 b8					.word	LAB_B853-1		; -
>a086	7b					.byte	$7B
>a087	2a ba					.word	LAB_BA2B-1		; *
>a089	7b					.byte	$7B
>a08a	11 bb					.word	LAB_BB12-1		; /
>a08c	7f					.byte	$7F
>a08d	7a bf					.word	LAB_BF7B-1		; ^
>a08f	50					.byte	$50
>a090	e8 af					.word	LAB_AFE9-1		; AND
>a092	46					.byte	$46
>a093	e5 af					.word	LAB_AFE6-1		; OR
>a095	7d					.byte	$7D
>a096	b3 bf					.word	LAB_BFB4-1		; >
>a098	5a					.byte	$5A
>a099	d3 ae					.word	LAB_AED4-1		; =
.a09b					LAB_A09B
>a09b	64					.byte	$64
>a09c	15 b0					.word	LAB_B016-1		; <
.a09e					LAB_A09E
>a09e	45 4e c4				.text	"EN",'D'+$80	; END		$80		128
>a0a1	46 4f d2				.text	"FO",'R'+$80	; FOR		$81		129
>a0a4	4e 45 58 d4				.text	"NEX",'T'+$80	; NEXT	$82		130
>a0a8	44 41 54 c1				.text	"DAT",'A'+$80	; DATA	$83		131
>a0ac	49 4e 50 55 54 a3			.text	"INPUT",'#'+$80	; INPUT#	$84		132
>a0b2	49 4e 50 55 d4				.text	"INPU",'T'+$80	; INPUT	$85		133
>a0b7	44 49 cd				.text	"DI",'M'+$80	; DIM		$86		134
>a0ba	52 45 41 c4				.text	"REA",'D'+$80	; READ	$87		135
>a0be	4c 45 d4				.text	"LE",'T'+$80	; LET		$88		136
>a0c1	47 4f 54 cf				.text	"GOT",'O'+$80	; GOTO	$89		137
>a0c5	52 55 ce				.text	"RU",'N'+$80	; RUN		$8A		138
>a0c8	49 c6					.text	"I",'F'+$80		; IF		$8B		139
>a0ca	52 45 53 54 4f 52 c5			.text	"RESTOR",'E'+$80	; RESTORE	$8C		140
>a0d1	47 4f 53 55 c2				.text	"GOSU",'B'+$80	; GOSUB	$8D		141
>a0d6	52 45 54 55 52 ce			.text	"RETUR",'N'+$80	; RETURN	$8E		142
>a0dc	52 45 cd				.text	"RE",'M'+$80	; REM		$8F		143
>a0df	53 54 4f d0				.text	"STO",'P'+$80	; STOP	$90		144
>a0e3	4f ce					.text	"O",'N'+$80		; ON		$91		145
>a0e5	57 41 49 d4				.text	"WAI",'T'+$80	; WAIT	$92		146
>a0e9	4c 4f 41 c4				.text	"LOA",'D'+$80	; LOAD	$93		147
>a0ed	53 41 56 c5				.text	"SAV",'E'+$80	; SAVE	$94		148
>a0f1	56 45 52 49 46 d9			.text	"VERIF",'Y'+$80	; VERIFY	$95		149
>a0f7	44 45 c6				.text	"DE",'F'+$80	; DEF		$96		150
>a0fa	50 4f 4b c5				.text	"POK",'E'+$80	; POKE	$97		151
>a0fe	50 52 49 4e 54 a3			.text	"PRINT",'#'+$80	; PRINT#	$98		152
>a104	50 52 49 4e d4				.text	"PRIN",'T'+$80	; PRINT	$99		153
>a109	43 4f 4e d4				.text	"CON",'T'+$80	; CONT	$9A		154
>a10d	4c 49 53 d4				.text	"LIS",'T'+$80	; LIST	$9B		155
>a111	43 4c d2				.text	"CL",'R'+$80	; CLR		$9C		156
>a114	43 4d c4				.text	"CM",'D'+$80	; CMD		$9D		157
>a117	53 59 d3				.text	"SY",'S'+$80	; SYS		$9E		158
>a11a	4f 50 45 ce				.text	"OPE",'N'+$80	; OPEN	$9F		159
>a11e	43 4c 4f 53 c5				.text	"CLOS",'E'+$80	; CLOSE	$A0		160
>a123	47 45 d4				.text	"GE",'T'+$80	; GET		$A1		161
>a126	4e 45 d7				.text	"NE",'W'+$80	; NEW		$A2		162
>a129	54 41 42 a8				.text	"TAB",'('+$80	; TAB(	$A3		163
>a12d	54 cf					.text	"T",'O'+$80		; TO		$A4		164
>a12f	46 ce					.text	"F",'N'+$80		; FN		$A5		165
>a131	53 50 43 a8				.text	"SPC",'('+$80	; SPC(	$A6		166
>a135	54 48 45 ce				.text	"THE",'N'+$80	; THEN	$A7		167
>a139	4e 4f d4				.text	"NO",'T'+$80	; NOT		$A8		168
>a13c	53 54 45 d0				.text	"STE",'P'+$80	; STEP	$A9		169
>a140	ab					.byte	'+'+$80		; +		$AA		170
>a141	ad					.byte	'-'+$80		; -		$AB		171
>a142	aa					.byte	'*'+$80		; *		$AC		172
>a143	af					.byte	'/'+$80		; /		$AD		173
>a144	de					.byte	'^'+$80		; ^		$AE		174
>a145	41 4e c4				.text	"AN",'D'+$80	; AND		$AF		175
>a148	4f d2					.text	"O",'R'+$80		; OR		$B0		176
>a14a	be					.byte	'>'+$80		; >		$B1		177
>a14b	bd					.byte	'='+$80		; =		$B2		178
>a14c	bc					.byte	'<'+$80		; <		$B3		179
>a14d	53 47 ce				.text	"SG",'N'+$80	; SGN		$B4		180
>a150	49 4e d4				.text	"IN",'T'+$80	; INT		$B5		181
>a153	41 42 d3				.text	"AB",'S'+$80	; ABS		$B6		182
>a156	55 53 d2				.text	"US",'R'+$80	; USR		$B7		183
>a159	46 52 c5				.text	"FR",'E'+$80	; FRE		$B8		184
>a15c	50 4f d3				.text	"PO",'S'+$80	; POS		$B9		185
>a15f	53 51 d2				.text	"SQ",'R'+$80	; SQR		$BA		186
>a162	52 4e c4				.text	"RN",'D'+$80	; RND		$BB		187
>a165	4c 4f c7				.text	"LO",'G'+$80	; LOG		$BC		188
>a168	45 58 d0				.text	"EX",'P'+$80	; EXP		$BD		189
>a16b	43 4f d3				.text	"CO",'S'+$80	; COS		$BE		190
>a16e	53 49 ce				.text	"SI",'N'+$80	; SIN		$BF		191
>a171	54 41 ce				.text	"TA",'N'+$80	; TAN		$C0		192
>a174	41 54 ce				.text	"AT",'N'+$80	; ATN		$C1		193
>a177	50 45 45 cb				.text	"PEE",'K'+$80	; PEEK	$C2		194
>a17b	4c 45 ce				.text	"LE",'N'+$80	; LEN		$C3		195
>a17e	53 54 52 a4				.text	"STR",'$'+$80	; STR$	$C4		196
>a182	56 41 cc				.text	"VA",'L'+$80	; VAL		$C5		197
>a185	41 53 c3				.text	"AS",'C'+$80	; ASC		$C6		198
>a188	43 48 52 a4				.text	"CHR",'$'+$80	; CHR$	$C7		199
>a18c	4c 45 46 54 a4				.text	"LEFT",'$'+$80	; LEFT$	$C8		200
>a191	52 49 47 48 54 a4			.text	"RIGHT",'$'+$80	; RIGHT$	$C9		201
>a197	4d 49 44 a4				.text	"MID",'$'+$80	; MID$	$CA		202
>a19b	47 cf					.text	"G",'O'+$80		; GO		$CB		203
>a19d	00					.byte	$00			; end marker
.a19e					LAB_A19E
>a19e	54 4f 4f 20 4d 41 4e 59			.text	"TOO MANY FILE",'S'+$80
>a1a6	20 46 49 4c 45 d3
.a1ac					LAB_A1AC
>a1ac	46 49 4c 45 20 4f 50 45			.text	"FILE OPE",'N'+$80
>a1b4	ce
.a1b5					LAB_A1B5
>a1b5	46 49 4c 45 20 4e 4f 54			.text	"FILE NOT OPE",'N'+$80
>a1bd	20 4f 50 45 ce
.a1c2					LAB_A1C2
>a1c2	46 49 4c 45 20 4e 4f 54			.text	"FILE NOT FOUN",'D'+$80
>a1ca	20 46 4f 55 4e c4
.a1d0					LAB_A1D0
>a1d0	44 45 56 49 43 45 20 4e			.text	"DEVICE NOT PRESEN",'T'+$80
>a1d8	4f 54 20 50 52 45 53 45 4e d4
.a1e2					LAB_A1E2
>a1e2	4e 4f 54 20 49 4e 50 55			.text	"NOT INPUT FIL",'E'+$80
>a1ea	54 20 46 49 4c c5
.a1f0					LAB_A1F0
>a1f0	4e 4f 54 20 4f 55 54 50			.text	"NOT OUTPUT FIL",'E'+$80
>a1f8	55 54 20 46 49 4c c5
.a1ff					LAB_A1FF
>a1ff	4d 49 53 53 49 4e 47 20			.text	"MISSING FILE NAM",'E'+$80
>a207	46 49 4c 45 20 4e 41 4d c5
.a210					LAB_A210
>a210	49 4c 4c 45 47 41 4c 20			.text	"ILLEGAL DEVICE NUMBE",'R'+$80
>a218	44 45 56 49 43 45 20 4e 55 4d 42 45 d2
.a225					LAB_A225
>a225	4e 45 58 54 20 57 49 54			.text	"NEXT WITHOUT FO",'R'+$80
>a22d	48 4f 55 54 20 46 4f d2
.a235					LAB_A235
>a235	53 59 4e 54 41 d8			.text	"SYNTA",'X'+$80
.a23b					LAB_A23B
>a23b	52 45 54 55 52 4e 20 57			.text	"RETURN WITHOUT GOSU",'B'+$80
>a243	49 54 48 4f 55 54 20 47 4f 53 55 c2
.a24f					LAB_A24F
>a24f	4f 55 54 20 4f 46 20 44			.text	"OUT OF DAT",'A'+$80
>a257	41 54 c1
.a25a					LAB_A25A
>a25a	49 4c 4c 45 47 41 4c 20			.text	"ILLEGAL QUANTIT",'Y'+$80
>a262	51 55 41 4e 54 49 54 d9
.a26a					LAB_A26A
>a26a	4f 56 45 52 46 4c 4f d7			.text	"OVERFLO",'W'+$80
.a272					LAB_A272
>a272	4f 55 54 20 4f 46 20 4d			.text	"OUT OF MEMOR",'Y'+$80
>a27a	45 4d 4f 52 d9
.a27f					LAB_A27F
>a27f	55 4e 44 45 46 27 44 20			.text	"UNDEF'D STATEMEN",'T'+$80
>a287	53 54 41 54 45 4d 45 4e d4
.a290					LAB_A290
>a290	42 41 44 20 53 55 42 53			.text	"BAD SUBSCRIP",'T'+$80
>a298	43 52 49 50 d4
.a29d					LAB_A29D
>a29d	52 45 44 49 4d 27 44 20			.text	"REDIM'D ARRA",'Y'+$80
>a2a5	41 52 52 41 d9
.a2aa					LAB_A2AA
>a2aa	44 49 56 49 53 49 4f 4e			.text	"DIVISION BY ZER",'O'+$80
>a2b2	20 42 59 20 5a 45 52 cf
.a2ba					LAB_A2BA
>a2ba	49 4c 4c 45 47 41 4c 20			.text	"ILLEGAL DIREC",'T'+$80
>a2c2	44 49 52 45 43 d4
.a2c8					LAB_A2C8
>a2c8	54 59 50 45 20 4d 49 53			.text	"TYPE MISMATC",'H'+$80
>a2d0	4d 41 54 43 c8
.a2d5					LAB_A2D5
>a2d5	53 54 52 49 4e 47 20 54			.text	"STRING TOO LON",'G'+$80
>a2dd	4f 4f 20 4c 4f 4e c7
.a2e4					LAB_A2E4
>a2e4	46 49 4c 45 20 44 41 54			.text	"FILE DAT",'A'+$80
>a2ec	c1
.a2ed					LAB_A2ED
>a2ed	46 4f 52 4d 55 4c 41 20			.text	"FORMULA TOO COMPLE",'X'+$80
>a2f5	54 4f 4f 20 43 4f 4d 50 4c 45 d8
.a300					LAB_A300
>a300	43 41 4e 27 54 20 43 4f			.text	"CAN'T CONTINU",'E'+$80
>a308	4e 54 49 4e 55 c5
.a30e					LAB_A30E
>a30e	55 4e 44 45 46 27 44 20			.text	"UNDEF'D FUNCTIO",'N'+$80
>a316	46 55 4e 43 54 49 4f ce
.a31e					LAB_A31E
>a31e	56 45 52 49 46 d9			.text	"VERIF",'Y'+$80
.a324					LAB_A324
>a324	4c 4f 41 c4				.text	"LOA",'D'+$80
.a328					LAB_A328
>a328	9e a1					.word	LAB_A19E		; $01	TOO MANY FILES
>a32a	ac a1					.word	LAB_A1AC		; $02	FILE OPEN
>a32c	b5 a1					.word	LAB_A1B5		; $03	FILE NOT OPEN
>a32e	c2 a1					.word	LAB_A1C2		; $04	FILE NOT FOUND
>a330	d0 a1					.word	LAB_A1D0		; $05	DEVICE NOT PRESENT
>a332	e2 a1					.word	LAB_A1E2		; $06	NOT INPUT FILE
>a334	f0 a1					.word	LAB_A1F0		; $07	NOT OUTPUT FILE
>a336	ff a1					.word	LAB_A1FF		; $08	MISSING FILE NAME
>a338	10 a2					.word	LAB_A210		; $09	ILLEGAL DEVICE NUMBER
>a33a	25 a2					.word	LAB_A225		; $0A	NEXT WITHOUT FOR
>a33c	35 a2					.word	LAB_A235		; $0B	SYNTAX
>a33e	3b a2					.word	LAB_A23B		; $0C	RETURN WITHOUT GOSUB
>a340	4f a2					.word	LAB_A24F		; $0D	OUT OF DATA
>a342	5a a2					.word	LAB_A25A		; $0E	ILLEGAL QUANTITY
>a344	6a a2					.word	LAB_A26A		; $0F	OVERFLOW
>a346	72 a2					.word	LAB_A272		; $10	OUT OF MEMORY
>a348	7f a2					.word	LAB_A27F		; $11	UNDEF'D STATEMENT
>a34a	90 a2					.word	LAB_A290		; $12	BAD SUBSCRIPT
>a34c	9d a2					.word	LAB_A29D		; $13	REDIM'D ARRAY
>a34e	aa a2					.word	LAB_A2AA		; $14	DIVISION BY ZERO
>a350	ba a2					.word	LAB_A2BA		; $15	ILLEGAL DIRECT
>a352	c8 a2					.word	LAB_A2C8		; $16	TYPE MISMATCH
>a354	d5 a2					.word	LAB_A2D5		; $17	STRING TOO LONG
>a356	e4 a2					.word	LAB_A2E4		; $18	FILE DATA
>a358	ed a2					.word	LAB_A2ED		; $19	FORMULA TOO COMPLEX
>a35a	00 a3					.word	LAB_A300		; $1A	CAN'T CONTINUE
>a35c	0e a3					.word	LAB_A30E		; $1B	UNDEF'D FUNCTION
>a35e	1e a3					.word	LAB_A31E		; $1C	VERIFY
>a360	24 a3					.word	LAB_A324		; $1D	LOAD
>a362	83 a3					.word	LAB_A383		; $1E	BREAK
.a364					LAB_A364
>a364	0d 4f 4b 0d 00				.text	$0D,"OK",$0D,$00
.a369					LAB_A369
>a369	20 20 45 52 52 4f 52 00			.text	"  ERROR",$00
.a371					LAB_A371
>a371	20 49 4e 20 00				.text	" IN ",$00
.a376					LAB_A376
>a376	0d 0a 52 45 41 44 59 2e			.text	$0D,$0A,"READY.",$0D,$0A,$00
>a37e	0d 0a 00
.a381					LAB_A381
>a381	0d 0a					.byte	$0D,$0A
.a383					LAB_A383
>a383	42 52 45 41 4b 00			.text	"BREAK",$00
>a389	a0					.byte	$A0			; unused
.a38a					LAB_A38A
.a38a	ba		tsx			TSX				; copy stack pointer
.a38b	e8		inx			INX				; +1 pass return address
.a38c	e8		inx			INX				; +2 pass return address
.a38d	e8		inx			INX				; +3 pass calling routine return address
.a38e	e8		inx			INX				; +4 pass calling routine return address
.a38f					LAB_A38F
.a38f	bd 01 01	lda $0101,x		LDA	LAB_0100+1,X	; get the token byte from the stack
.a392	c9 81		cmp #$81		CMP	#TK_FOR		; is it the FOR token
.a394	d0 21		bne $a3b7		BNE	LAB_A3B7		; if not FOR token just exit
.a396	a5 4a		lda $4a			LDA	LAB_4A		; get FOR/NEXT variable pointer high byte
.a398	d0 0a		bne $a3a4		BNE	LAB_A3A4		; branch if not null
.a39a	bd 02 01	lda $0102,x		LDA	LAB_0100+2,X	; get FOR variable pointer low byte
.a39d	85 49		sta $49			STA	LAB_49		; save FOR/NEXT variable pointer low byte
.a39f	bd 03 01	lda $0103,x		LDA	LAB_0100+3,X	; get FOR variable pointer high byte
.a3a2	85 4a		sta $4a			STA	LAB_4A		; save FOR/NEXT variable pointer high byte
.a3a4					LAB_A3A4
.a3a4	dd 03 01	cmp $0103,x		CMP	LAB_0100+3,X	; compare variable pointer with stacked variable pointer
.a3a7	d0 07		bne $a3b0		BNE	LAB_A3B0		; branch if no match
.a3a9	a5 49		lda $49			LDA	LAB_49		; get FOR/NEXT variable pointer low byte
.a3ab	dd 02 01	cmp $0102,x		CMP	LAB_0100+2,X	; compare variable pointer with stacked variable pointer
.a3ae	f0 07		beq $a3b7		BEQ	LAB_A3B7		; exit if match found
.a3b0					LAB_A3B0
.a3b0	8a		txa			TXA				; copy index
.a3b1	18		clc			CLC				; clear carry for add
.a3b2	69 12		adc #$12		ADC	#$12			; add FOR stack use size
.a3b4	aa		tax			TAX				; copy back to index
.a3b5	d0 d8		bne $a38f		BNE	LAB_A38F		; loop if not at start of stack
.a3b7					LAB_A3B7
.a3b7	60		rts			RTS
.a3b8					LAB_A3B8
.a3b8	20 08 a4	jsr $a408		JSR	LAB_A408		; check available memory, do out of memory error if no room
.a3bb	85 31		sta $31			STA	LAB_31		; set end of arrays low byte
.a3bd	84 32		sty $32			STY	LAB_32		; set end of arrays high byte
.a3bf					LAB_A3BF
.a3bf	38		sec			SEC				; set carry for subtract
.a3c0	a5 5a		lda $5a			LDA	LAB_5A		; get block end low byte
.a3c2	e5 5f		sbc $5f			SBC	LAB_5F		; subtract block start low byte
.a3c4	85 22		sta $22			STA	LAB_22		; save MOD(block length/$100) byte
.a3c6	a8		tay			TAY				; copy MOD(block length/$100) byte to Y
.a3c7	a5 5b		lda $5b			LDA	LAB_5B		; get block end high byte
.a3c9	e5 60		sbc $60			SBC	LAB_60		; subtract block start high byte
.a3cb	aa		tax			TAX				; copy block length high byte to X
.a3cc	e8		inx			INX				; +1 to allow for count=0 exit
.a3cd	98		tya			TYA				; copy block length low byte to A
.a3ce	f0 23		beq $a3f3		BEQ	LAB_A3F3		; branch if length low byte=0
.a3d0	a5 5a		lda $5a			LDA	LAB_5A		; get block end low byte
.a3d2	38		sec			SEC				; set carry for subtract
.a3d3	e5 22		sbc $22			SBC	LAB_22		; subtract MOD(block length/$100) byte
.a3d5	85 5a		sta $5a			STA	LAB_5A		; save corrected old block end low byte
.a3d7	b0 03		bcs $a3dc		BCS	LAB_A3DC		; branch if no underflow
.a3d9	c6 5b		dec $5b			DEC	LAB_5B		; else decrement block end high byte
.a3db	38		sec			SEC				; set carry for subtract
.a3dc					LAB_A3DC
.a3dc	a5 58		lda $58			LDA	LAB_58		; get destination end low byte
.a3de	e5 22		sbc $22			SBC	LAB_22		; subtract MOD(block length/$100) byte
.a3e0	85 58		sta $58			STA	LAB_58		; save modified new block end low byte
.a3e2	b0 08		bcs $a3ec		BCS	LAB_A3EC		; branch if no underflow
.a3e4	c6 59		dec $59			DEC	LAB_59		; else decrement block end high byte
.a3e6	90 04		bcc $a3ec		BCC	LAB_A3EC		; branch always
.a3e8					LAB_A3E8
.a3e8	b1 5a		lda ($5a),y		LDA	(LAB_5A),Y		; get byte from source
.a3ea	91 58		sta ($58),y		STA	(LAB_58),Y		; copy byte to destination
.a3ec					LAB_A3EC
.a3ec	88		dey			DEY				; decrement index
.a3ed	d0 f9		bne $a3e8		BNE	LAB_A3E8		; loop until Y=0
.a3ef	b1 5a		lda ($5a),y		LDA	(LAB_5A),Y		; get byte from source
.a3f1	91 58		sta ($58),y		STA	(LAB_58),Y		; save byte to destination
.a3f3					LAB_A3F3
.a3f3	c6 5b		dec $5b			DEC	LAB_5B		; decrement source pointer high byte
.a3f5	c6 59		dec $59			DEC	LAB_59		; decrement destination pointer high byte
.a3f7	ca		dex			DEX				; decrement block count
.a3f8	d0 f2		bne $a3ec		BNE	LAB_A3EC		; loop until count = $0
.a3fa	60		rts			RTS
.a3fb					LAB_A3FB
.a3fb	0a		asl a			ASL				; *2
.a3fc	69 3e		adc #$3e		ADC	#$3E			; need at least $3E bytes free
.a3fe	b0 35		bcs $a435		BCS	LAB_A435		; if overflow go do out of memory error then warm start
.a400	85 22		sta $22			STA	LAB_22		; save result in temp byte
.a402	ba		tsx			TSX				; copy stack
.a403	e4 22		cpx $22			CPX	LAB_22		; compare new limit with stack
.a405	90 2e		bcc $a435		BCC	LAB_A435		; if stack < limit do out of memory error then warm start
.a407	60		rts			RTS
.a408					LAB_A408
.a408	c4 34		cpy $34			CPY	LAB_34		; compare with bottom of string space high byte
.a40a	90 28		bcc $a434		BCC	LAB_A434		; if less then exit (is ok)
.a40c	d0 04		bne $a412		BNE	LAB_A412		; skip next test if greater (tested <)
.a40e	c5 33		cmp $33			CMP	LAB_33		; compare with bottom of string space low byte
.a410	90 22		bcc $a434		BCC	LAB_A434		; if less then exit (is ok)
.a412					LAB_A412
.a412	48		pha			PHA				; push address low byte
.a413	a2 09		ldx #$09		LDX	#$09			; set index to save LAB_57 to LAB_60 inclusive
.a415	98		tya			TYA				; copy address high byte (to push on stack)
.a416					LAB_A416
.a416	48		pha			PHA				; push byte
.a417	b5 57		lda $57,x		LDA	LAB_57,X		; get byte from LAB_57 to LAB_60
.a419	ca		dex			DEX				; decrement index
.a41a	10 fa		bpl $a416		BPL	LAB_A416		; loop until all done
.a41c	20 26 b5	jsr $b526		JSR	LAB_B526		; do garbage collection routine
.a41f	a2 f7		ldx #$f7		LDX	#$F7			; set index to restore bytes
.a421					LAB_A421
.a421	68		pla			PLA				; pop byte
.a422	95 61		sta $61,x		STA	LAB_60+1,X		; save byte to LAB_57 to LAB_60
.a424	e8		inx			INX				; increment index
.a425	30 fa		bmi $a421		BMI	LAB_A421		; loop while -ve
.a427	68		pla			PLA				; pop address high byte
.a428	a8		tay			TAY				; copy back to Y
.a429	68		pla			PLA				; pop address low byte
.a42a	c4 34		cpy $34			CPY	LAB_34		; compare with bottom of string space high byte
.a42c	90 06		bcc $a434		BCC	LAB_A434		; if less then exit (is ok)
.a42e	d0 05		bne $a435		BNE	LAB_A435		; if greater do out of memory error then warm start
.a430	c5 33		cmp $33			CMP	LAB_33		; compare with bottom of string space low byte
.a432	b0 01		bcs $a435		BCS	LAB_A435		; if >= do out of memory error then warm start
.a434					LAB_A434
.a434	60		rts			RTS
.a435					LAB_A435
.a435	a2 10		ldx #$10		LDX	#$10			; error code $10, out of memory error
.a437					LAB_A437
.a437	6c 00 03	jmp ($0300)		JMP	(LAB_0300)		; do error message
.a43a					LAB_A43A
.a43a	8a		txa			TXA				; copy error number
.a43b	0a		asl a			ASL				; *2
.a43c	aa		tax			TAX				; copy to index
.a43d	bd 26 a3	lda $a326,x		LDA	LAB_A328-2,X	; get error message pointer low byte
.a440	85 22		sta $22			STA	LAB_22		; save it
.a442	bd 27 a3	lda $a327,x		LDA	LAB_A328-1,X	; get error message pointer high byte
.a445	85 23		sta $23			STA	LAB_23		; save it
.a447	20 cc ff	jsr $ffcc		JSR	LAB_FFCC		; close input and output channels
.a44a	a9 00		lda #$00		LDA	#$00			; clear A
.a44c	85 13		sta $13			STA	LAB_13		; clear current I/O channel, flag default
.a44e	20 d7 aa	jsr $aad7		JSR	LAB_AAD7		; print CR/LF
.a451	20 45 ab	jsr $ab45		JSR	LAB_AB45		; print "?"
.a454	a0 00		ldy #$00		LDY	#$00			; clear index
.a456					LAB_A456
.a456	b1 22		lda ($22),y		LDA	(LAB_22),Y		; get byte from message
.a458	48		pha			PHA				; save status
.a459	29 7f		and #$7f		AND	#$7F			; mask 0xxx xxxx, clear b7
.a45b	20 47 ab	jsr $ab47		JSR	LAB_AB47		; output character
.a45e	c8		iny			INY				; increment index
.a45f	68		pla			PLA				; restore status
.a460	10 f4		bpl $a456		BPL	LAB_A456		; loop if character was not end marker
.a462	20 7a a6	jsr $a67a		JSR	LAB_A67A		; flush BASIC stack and clear continue pointer
.a465	a9 69		lda #$69		LDA	#<LAB_A369		; set " ERROR" pointer low byte
.a467	a0 a3		ldy #$a3		LDY	#>LAB_A369		; set " ERROR" pointer high byte
.a469					LAB_A469
.a469	20 1e ab	jsr $ab1e		JSR	LAB_AB1E		; print null terminated string
.a46c	a4 3a		ldy $3a			LDY	LAB_3A		; get current line number high byte
.a46e	c8		iny			INY				; increment it
.a46f	f0 03		beq $a474		BEQ	LAB_A474		; branch if was in immediate mode
.a471	20 c2 bd	jsr $bdc2		JSR	LAB_BDC2		; do " IN " line number message
.a474					LAB_A474
.a474	a9 76		lda #$76		LDA	#<LAB_A376		; set "READY." pointer low byte
.a476	a0 a3		ldy #$a3		LDY	#>LAB_A376		; set "READY." pointer high byte
.a478	20 1e ab	jsr $ab1e		JSR	LAB_AB1E		; print null terminated string
.a47b	a9 80		lda #$80		LDA	#$80			; set for control messages only
.a47d	20 90 ff	jsr $ff90		JSR	LAB_FF90		; control kernal messages
.a480					LAB_A480
.a480	6c 02 03	jmp ($0302)		JMP	(LAB_0302)		; do BASIC warm start
.a483					LAB_A483
.a483	20 60 a5	jsr $a560		JSR	LAB_A560		; call for BASIC input
.a486	86 7a		stx $7a			STX	LAB_7A		; save BASIC execute pointer low byte
.a488	84 7b		sty $7b			STY	LAB_7B		; save BASIC execute pointer high byte
.a48a	20 73 00	jsr $0073		JSR	LAB_0073		; increment and scan memory
.a48d	aa		tax			TAX				; copy byte to set flags
.a48e	f0 f0		beq $a480		BEQ	LAB_A480		; loop if no input
.a490	a2 ff		ldx #$ff		LDX	#$FF			; current line high byte to -1, indicates immediate mode
.a492	86 3a		stx $3a			STX	LAB_3A		; set current line number high byte
.a494	90 06		bcc $a49c		BCC	LAB_A49C		; if numeric character go handle new BASIC line
.a496	20 79 a5	jsr $a579		JSR	LAB_A579		; crunch keywords into BASIC tokens
.a499	4c e1 a7	jmp $a7e1		JMP	LAB_A7E1		; go scan and interpret code
.a49c					LAB_A49C
.a49c	20 6b a9	jsr $a96b		JSR	LAB_A96B		; get fixed-point number into temporary integer
.a49f	20 79 a5	jsr $a579		JSR	LAB_A579		; crunch keywords into BASIC tokens
.a4a2	84 0b		sty $0b			STY	LAB_0B		; save index pointer to end of crunched line
.a4a4	20 13 a6	jsr $a613		JSR	LAB_A613		; search BASIC for temporary integer line number
.a4a7	90 44		bcc $a4ed		BCC	LAB_A4ED		; if not found skip the line delete
.a4a9	a0 01		ldy #$01		LDY	#$01			; set index to next line pointer high byte
.a4ab	b1 5f		lda ($5f),y		LDA	(LAB_5F),Y		; get next line pointer high byte
.a4ad	85 23		sta $23			STA	LAB_23		; save it
.a4af	a5 2d		lda $2d			LDA	LAB_2D		; get start of variables low byte
.a4b1	85 22		sta $22			STA	LAB_22		; save it
.a4b3	a5 60		lda $60			LDA	LAB_60		; get found line pointer high byte
.a4b5	85 25		sta $25			STA	LAB_25		; save it
.a4b7	a5 5f		lda $5f			LDA	LAB_5F		; get found line pointer low byte
.a4b9	88		dey			DEY				; decrement index
.a4ba	f1 5f		sbc ($5f),y		SBC	(LAB_5F),Y		; subtract next line pointer low byte
.a4bc	18		clc			CLC				; clear carry for add
.a4bd	65 2d		adc $2d			ADC	LAB_2D		; add start of variables low byte
.a4bf	85 2d		sta $2d			STA	LAB_2D		; set start of variables low byte
.a4c1	85 24		sta $24			STA	LAB_24		; save destination pointer low byte
.a4c3	a5 2e		lda $2e			LDA	LAB_2E		; get start of variables high byte
.a4c5	69 ff		adc #$ff		ADC	#$FF			; -1 + carry
.a4c7	85 2e		sta $2e			STA	LAB_2E		; set start of variables high byte
.a4c9	e5 60		sbc $60			SBC	LAB_60		; subtract found line pointer high byte
.a4cb	aa		tax			TAX				; copy to block count
.a4cc	38		sec			SEC				; set carry for subtract
.a4cd	a5 5f		lda $5f			LDA	LAB_5F		; get found line pointer low byte
.a4cf	e5 2d		sbc $2d			SBC	LAB_2D		; subtract start of variables low byte
.a4d1	a8		tay			TAY				; copy to bytes in first block count
.a4d2	b0 03		bcs $a4d7		BCS	LAB_A4D7		; branch if no underflow
.a4d4	e8		inx			INX				; increment block count, correct for = 0 loop exit
.a4d5	c6 25		dec $25			DEC	LAB_25		; decrement destination high byte
.a4d7					LAB_A4D7
.a4d7	18		clc			CLC				; clear carry for add
.a4d8	65 22		adc $22			ADC	LAB_22		; add source pointer low byte
.a4da	90 03		bcc $a4df		BCC	LAB_A4DF		; branch if no overflow
.a4dc	c6 23		dec $23			DEC	LAB_23		; else decrement source pointer high byte
.a4de	18		clc			CLC				; clear carry
.a4df					LAB_A4DF
.a4df	b1 22		lda ($22),y		LDA	(LAB_22),Y		; get byte from source
.a4e1	91 24		sta ($24),y		STA	(LAB_24),Y		; copy to destination
.a4e3	c8		iny			INY				; increment index
.a4e4	d0 f9		bne $a4df		BNE	LAB_A4DF		; while <> 0 do this block
.a4e6	e6 23		inc $23			INC	LAB_23		; increment source pointer high byte
.a4e8	e6 25		inc $25			INC	LAB_25		; increment destination pointer high byte
.a4ea	ca		dex			DEX				; decrement block count
.a4eb	d0 f2		bne $a4df		BNE	LAB_A4DF		; loop until all done
.a4ed					LAB_A4ED
.a4ed	20 59 a6	jsr $a659		JSR	LAB_A659		; reset execution to start, clear variables, flush stack
.a4f0	20 33 a5	jsr $a533		JSR	LAB_A533		; rebuild BASIC line chaining
.a4f3	ad 00 02	lda $0200		LDA	LAB_0200		; get first byte from buffer
.a4f6	f0 88		beq $a480		BEQ	LAB_A480		; if no line go do BASIC warm start
.a4f8	18		clc			CLC				; clear carry for add
.a4f9	a5 2d		lda $2d			LDA	LAB_2D		; get start of variables low byte
.a4fb	85 5a		sta $5a			STA	LAB_5A		; save as source end pointer low byte
.a4fd	65 0b		adc $0b			ADC	LAB_0B		; add index pointer to end of crunched line
.a4ff	85 58		sta $58			STA	LAB_58		; save as destination end pointer low byte
.a501	a4 2e		ldy $2e			LDY	LAB_2E		; get start of variables high byte
.a503	84 5b		sty $5b			STY	LAB_5B		; save as source end pointer high byte
.a505	90 01		bcc $a508		BCC	LAB_A508		; branch if no carry to high byte
.a507	c8		iny			INY				; else increment high byte
.a508					LAB_A508
.a508	84 59		sty $59			STY	LAB_59		; save as destination end pointer high byte
.a50a	20 b8 a3	jsr $a3b8		JSR	LAB_A3B8		; open up space in memory
.a50d	a5 14		lda $14			LDA	LAB_14		; get line number low byte
.a50f	a4 15		ldy $15			LDY	LAB_15		; get line number high byte
.a511	8d fe 01	sta $01fe		STA	LAB_01FE		; save line number low byte before crunched line
.a514	8c ff 01	sty $01ff		STY	LAB_01FF		; save line number high byte before crunched line
.a517	a5 31		lda $31			LDA	LAB_31		; get end of arrays low byte
.a519	a4 32		ldy $32			LDY	LAB_32		; get end of arrays high byte
.a51b	85 2d		sta $2d			STA	LAB_2D		; set start of variables low byte
.a51d	84 2e		sty $2e			STY	LAB_2E		; set start of variables high byte
.a51f	a4 0b		ldy $0b			LDY	LAB_0B		; get index to end of crunched line
.a521	88		dey			DEY				; -1
.a522					LAB_A522
.a522	b9 fc 01	lda $01fc,y		LDA	LAB_01FC,Y		; get byte from crunched line
.a525	91 5f		sta ($5f),y		STA	(LAB_5F),Y		; save byte to memory
.a527	88		dey			DEY				; decrement index
.a528	10 f8		bpl $a522		BPL	LAB_A522		; loop while more to do
.a52a					LAB_A52A
.a52a	20 59 a6	jsr $a659		JSR	LAB_A659		; reset execution to start, clear variables and flush stack
.a52d	20 33 a5	jsr $a533		JSR	LAB_A533		; rebuild BASIC line chaining
.a530	4c 80 a4	jmp $a480		JMP	LAB_A480		; go do BASIC warm start
.a533					LAB_A533
.a533	a5 2b		lda $2b			LDA	LAB_2B		; get start of memory low byte
.a535	a4 2c		ldy $2c			LDY	LAB_2C		; get start of memory high byte
.a537	85 22		sta $22			STA	LAB_22		; set line start pointer low byte
.a539	84 23		sty $23			STY	LAB_23		; set line start pointer high byte
.a53b	18		clc			CLC				; clear carry for add
.a53c					LAB_A53C
.a53c	a0 01		ldy #$01		LDY	#$01			; set index to pointer to next line high byte
.a53e	b1 22		lda ($22),y		LDA	(LAB_22),Y		; get pointer to next line high byte
.a540	f0 1d		beq $a55f		BEQ	LAB_A55F		; exit if null, [EOT]
.a542	a0 04		ldy #$04		LDY	#$04			; point to first code byte of line
.a544					LAB_A544
.a544	c8		iny			INY				; next code byte
.a545	b1 22		lda ($22),y		LDA	(LAB_22),Y		; get byte
.a547	d0 fb		bne $a544		BNE	LAB_A544		; loop if not [EOL]
.a549	c8		iny			INY				; point to byte past [EOL], start of next line
.a54a	98		tya			TYA				; copy it
.a54b	65 22		adc $22			ADC	LAB_22		; add line start pointer low byte
.a54d	aa		tax			TAX				; copy to X
.a54e	a0 00		ldy #$00		LDY	#$00			; clear index, point to this line's next line pointer
.a550	91 22		sta ($22),y		STA	(LAB_22),Y		; set next line pointer low byte
.a552	a5 23		lda $23			LDA	LAB_23		; get line start pointer high byte
.a554	69 00		adc #$00		ADC	#$00			; add any overflow
.a556	c8		iny			INY				; increment index to high byte
.a557	91 22		sta ($22),y		STA	(LAB_22),Y		; set next line pointer high byte
.a559	86 22		stx $22			STX	LAB_22		; set line start pointer low byte
.a55b	85 23		sta $23			STA	LAB_23		; set line start pointer high byte
.a55d	90 dd		bcc $a53c		BCC	LAB_A53C		; go do next line, branch always
.a55f					LAB_A55F
.a55f	60		rts			RTS
.a560					LAB_A560
.a560	a2 00		ldx #$00		LDX	#$00			; set channel $00, keyboard
.a562					LAB_A562
.a562	20 12 e1	jsr $e112		JSR	LAB_E112		; input character from channel with error check
.a565	c9 0d		cmp #$0d		CMP	#$0D			; compare with [CR]
.a567	f0 0d		beq $a576		BEQ	LAB_A576		; if [CR] set XY to LAB_200 - 1, print [CR] and exit
.a569	9d 00 02	sta $0200,x		STA	LAB_0200,X		; save character to buffer
.a56c	e8		inx			INX				; increment buffer index
.a56d	e0 59		cpx #$59		CPX	#$59			; compare with max+1
.a56f	90 f1		bcc $a562		BCC	LAB_A562		; branch if < max+1
.a571	a2 17		ldx #$17		LDX	#$17			; error $17, string too long error
.a573	4c 37 a4	jmp $a437		JMP	LAB_A437		; do error #X then warm start
.a576					LAB_A576
.a576	4c ca aa	jmp $aaca		JMP	LAB_AACA		; set XY to LAB_200 - 1 and print [CR]
.a579					LAB_A579
.a579	6c 04 03	jmp ($0304)		JMP	(LAB_0304)		; do crunch BASIC tokens
.a57c					LAB_A57C
.a57c	a6 7a		ldx $7a			LDX	LAB_7A		; get BASIC execute pointer low byte
.a57e	a0 04		ldy #$04		LDY	#$04			; set save index
.a580	84 0f		sty $0f			STY	LAB_0F		; clear open quote/DATA flag
.a582					LAB_A582
.a582	bd 00 02	lda $0200,x		LDA	LAB_0200,X		; get a byte from the input buffer
.a585	10 07		bpl $a58e		BPL	LAB_A58E		; if b7 clear go do crunching
.a587	c9 ff		cmp #$ff		CMP	#TK_PI		; compare with the token for PI, this toke is input
.a589	f0 3e		beq $a5c9		BEQ	LAB_A5C9		; if PI save byte then continue crunching
.a58b	e8		inx			INX				; increment read index
.a58c	d0 f4		bne $a582		BNE	LAB_A582		; loop if more to do, branch always
.a58e					LAB_A58E
.a58e	c9 20		cmp #$20		CMP	#' '			; compare with [SPACE]
.a590	f0 37		beq $a5c9		BEQ	LAB_A5C9		; if [SPACE] save byte then continue crunching
.a592	85 08		sta $08			STA	LAB_08		; save buffer byte as search character
.a594	c9 22		cmp #$22		CMP	#$22			; compare with quote character
.a596	f0 56		beq $a5ee		BEQ	LAB_A5EE		; if quote go copy quoted string
.a598	24 0f		bit $0f			BIT	LAB_0F		; get open quote/DATA token flag
.a59a	70 2d		bvs $a5c9		BVS	LAB_A5C9		; branch if b6 of Oquote set, was DATA
.a59c	c9 3f		cmp #$3f		CMP	#'?'			; compare with "?" character
.a59e	d0 04		bne $a5a4		BNE	LAB_A5A4		; if not "?" continue crunching
.a5a0	a9 99		lda #$99		LDA	#TK_PRINT		; else the keyword token is $99, PRINT
.a5a2	d0 25		bne $a5c9		BNE	LAB_A5C9		; go save byte then continue crunching, branch always
.a5a4					LAB_A5A4
.a5a4	c9 30		cmp #$30		CMP	#'0'			; compare with "0"
.a5a6	90 04		bcc $a5ac		BCC	LAB_A5AC		; branch if <, continue crunching
.a5a8	c9 3c		cmp #$3c		CMP	#'<'			; compare with "<"
.a5aa	90 1d		bcc $a5c9		BCC	LAB_A5C9		; if <, 0123456789:; go save byte then continue crunching
.a5ac					LAB_A5AC
.a5ac	84 71		sty $71			STY	LAB_71		; copy save index
.a5ae	a0 00		ldy #$00		LDY	#$00			; clear table pointer
.a5b0	84 0b		sty $0b			STY	LAB_0B		; clear word index
.a5b2	88		dey			DEY				; adjust for pre increment loop
.a5b3	86 7a		stx $7a			STX	LAB_7A		; save BASIC execute pointer low byte, buffer index
.a5b5	ca		dex			DEX				; adjust for pre increment loop
.a5b6					LAB_A5B6
.a5b6	c8		iny			INY				; next table byte
.a5b7	e8		inx			INX				; next buffer byte
.a5b8					LAB_A5B8
.a5b8	bd 00 02	lda $0200,x		LDA	LAB_0200,X		; get byte from input buffer
.a5bb	38		sec			SEC				; set carry for subtract
.a5bc	f9 9e a0	sbc $a09e,y		SBC	LAB_A09E,Y		; subtract table byte
.a5bf	f0 f5		beq $a5b6		BEQ	LAB_A5B6		; go compare next if match
.a5c1	c9 80		cmp #$80		CMP	#$80			; was it end marker match ?
.a5c3	d0 30		bne $a5f5		BNE	LAB_A5F5		; branch if not, not found keyword
.a5c5	05 0b		ora $0b			ORA	LAB_0B		; OR with word index, +$80 in A makes token
.a5c7					LAB_A5C7
.a5c7	a4 71		ldy $71			LDY	LAB_71		; restore save index
.a5c9					LAB_A5C9
.a5c9	e8		inx			INX				; increment buffer read index
.a5ca	c8		iny			INY				; increment save index
.a5cb	99 fb 01	sta $01fb,y		STA	LAB_0200-5,Y	; save byte to output
.a5ce	b9 fb 01	lda $01fb,y		LDA	LAB_0200-5,Y	; get byte from output, set flags
.a5d1	f0 36		beq $a609		BEQ	LAB_A609		; branch if was null [EOL]
.a5d3	38		sec			SEC				; set carry for subtract
.a5d4	e9 3a		sbc #$3a		SBC	#':'			; subtract ":"
.a5d6	f0 04		beq $a5dc		BEQ	LAB_A5DC		; branch if it was (is now $00)
.a5d8	c9 49		cmp #$49		CMP	#TK_DATA-':'	; compare with the token for DATA-':'
.a5da	d0 02		bne $a5de		BNE	LAB_A5DE		; if not DATA go try REM
.a5dc					LAB_A5DC
.a5dc	85 0f		sta $0f			STA	LAB_0F		; save the token-$3A
.a5de					LAB_A5DE
.a5de	38		sec			SEC				; set carry for subtract
.a5df	e9 55		sbc #$55		SBC	#TK_REM-':'		; subtract the token for REM-':'
.a5e1	d0 9f		bne $a582		BNE	LAB_A582		; if wasn't REM crunch next bit of line
.a5e3	85 08		sta $08			STA	LAB_08		; else was REM so set search for [EOL]
.a5e5					LAB_A5E5
.a5e5	bd 00 02	lda $0200,x		LDA	LAB_0200,X		; get byte from input buffer
.a5e8	f0 df		beq $a5c9		BEQ	LAB_A5C9		; if null [EOL] save byte then continue crunching
.a5ea	c5 08		cmp $08			CMP	LAB_08		; compare with stored character
.a5ec	f0 db		beq $a5c9		BEQ	LAB_A5C9		; if match save byte then continue crunching
.a5ee					LAB_A5EE
.a5ee	c8		iny			INY				; increment save index
.a5ef	99 fb 01	sta $01fb,y		STA	LAB_0200-5,Y	; save byte to output
.a5f2	e8		inx			INX				; increment buffer index
.a5f3	d0 f0		bne $a5e5		BNE	LAB_A5E5		; loop while <> 0, should never reach 0
.a5f5					LAB_A5F5
.a5f5	a6 7a		ldx $7a			LDX	LAB_7A		; restore BASIC execute pointer low byte
.a5f7	e6 0b		inc $0b			INC	LAB_0B		; increment word index (next word)
.a5f9					LAB_A5F9
.a5f9	c8		iny			INY				; increment table index
.a5fa	b9 9d a0	lda $a09d,y		LDA	LAB_A09E-1,Y	; get table byte
.a5fd	10 fa		bpl $a5f9		BPL	LAB_A5F9		; loop if not end of word yet
.a5ff	b9 9e a0	lda $a09e,y		LDA	LAB_A09E,Y		; get byte from keyword table
.a602	d0 b4		bne $a5b8		BNE	LAB_A5B8		; go test next word if not zero byte, end of table
.a604	bd 00 02	lda $0200,x		LDA	LAB_0200,X		; restore byte from input buffer
.a607	10 be		bpl $a5c7		BPL	LAB_A5C7		; branch always, all unmatched bytes in the buffer are
.a609					LAB_A609
.a609	99 fd 01	sta $01fd,y		STA	LAB_01FD,Y		; save [EOL]
.a60c	c6 7b		dec $7b			DEC	LAB_7B		; decrement BASIC execute pointer high byte
.a60e	a9 ff		lda #$ff		LDA	#$FF			; point to start of buffer-1
.a610	85 7a		sta $7a			STA	LAB_7A		; set BASIC execute pointer low byte
.a612	60		rts			RTS
.a613					LAB_A613
.a613	a5 2b		lda $2b			LDA	LAB_2B		; get start of memory low byte
.a615	a6 2c		ldx $2c			LDX	LAB_2C		; get start of memory high byte
.a617					LAB_A617
.a617	a0 01		ldy #$01		LDY	#$01			; set index to next line pointer high byte
.a619	85 5f		sta $5f			STA	LAB_5F		; save low byte as current
.a61b	86 60		stx $60			STX	LAB_60		; save high byte as current
.a61d	b1 5f		lda ($5f),y		LDA	(LAB_5F),Y		; get next line pointer high byte from address
.a61f	f0 1f		beq $a640		BEQ	LAB_A640		; pointer was zero so done, exit
.a621	c8		iny			INY				; increment index ...
.a622	c8		iny			INY				; ... to line # high byte
.a623	a5 15		lda $15			LDA	LAB_15		; get temporary integer high byte
.a625	d1 5f		cmp ($5f),y		CMP	(LAB_5F),Y		; compare with line # high byte
.a627	90 18		bcc $a641		BCC	LAB_A641		; exit if temp < this line, target line passed
.a629	f0 03		beq $a62e		BEQ	LAB_A62E		; go check low byte if =
.a62b	88		dey			DEY				; else decrement index
.a62c	d0 09		bne $a637		BNE	LAB_A637		; branch always
.a62e					LAB_A62E
.a62e	a5 14		lda $14			LDA	LAB_14		; get temporary integer low byte
.a630	88		dey			DEY				; decrement index to line # low byte
.a631	d1 5f		cmp ($5f),y		CMP	(LAB_5F),Y		; compare with line # low byte
.a633	90 0c		bcc $a641		BCC	LAB_A641		; exit if temp < this line, target line passed
.a635	f0 0a		beq $a641		BEQ	LAB_A641		; exit if temp = (found line#)
.a637					LAB_A637
.a637	88		dey			DEY				; decrement index to next line pointer high byte
.a638	b1 5f		lda ($5f),y		LDA	(LAB_5F),Y		; get next line pointer high byte
.a63a	aa		tax			TAX				; copy to X
.a63b	88		dey			DEY				; decrement index to next line pointer low byte
.a63c	b1 5f		lda ($5f),y		LDA	(LAB_5F),Y		; get next line pointer low byte
.a63e	b0 d7		bcs $a617		BCS	LAB_A617		; go search for line # in temporary integer
.a640					LAB_A640
.a640	18		clc			CLC				; clear found flag
.a641					LAB_A641
.a641	60		rts			RTS
.a642					LAB_A642
.a642	d0 fd		bne $a641		BNE	LAB_A641		; exit if following byte to allow syntax error
.a644					LAB_A644
.a644	a9 00		lda #$00		LDA	#$00			; clear A
.a646	a8		tay			TAY				; clear index
.a647	91 2b		sta ($2b),y		STA	(LAB_2B),Y		; clear pointer to next line low byte
.a649	c8		iny			INY				; increment index
.a64a	91 2b		sta ($2b),y		STA	(LAB_2B),Y		; clear pointer to next line high byte, erase program
.a64c	a5 2b		lda $2b			LDA	LAB_2B		; get start of memory low byte
.a64e	18		clc			CLC				; clear carry for add
.a64f	69 02		adc #$02		ADC	#$02			; add null program length
.a651	85 2d		sta $2d			STA	LAB_2D		; set start of variables low byte
.a653	a5 2c		lda $2c			LDA	LAB_2C		; get start of memory high byte
.a655	69 00		adc #$00		ADC	#$00			; add carry
.a657	85 2e		sta $2e			STA	LAB_2E		; set start of variables high byte
.a659					LAB_A659
.a659	20 8e a6	jsr $a68e		JSR	LAB_A68E		; set BASIC execute pointer to start of memory - 1
.a65c	a9 00		lda #$00		LDA	#$00			; set Zb for CLR entry
.a65e					LAB_A65E
.a65e	d0 2d		bne $a68d		BNE	LAB_A68D		; exit if following byte to allow syntax error
.a660					LAB_A660
.a660	20 e7 ff	jsr $ffe7		JSR	LAB_FFE7		; close all channels and files
.a663					LAB_A663
.a663	a5 37		lda $37			LDA	LAB_37		; get end of memory low byte
.a665	a4 38		ldy $38			LDY	LAB_38		; get end of memory high byte
.a667	85 33		sta $33			STA	LAB_33		; set bottom of string space low byte, clear strings
.a669	84 34		sty $34			STY	LAB_34		; set bottom of string space high byte
.a66b	a5 2d		lda $2d			LDA	LAB_2D		; get start of variables low byte
.a66d	a4 2e		ldy $2e			LDY	LAB_2E		; get start of variables high byte
.a66f	85 2f		sta $2f			STA	LAB_2F		; set end of variables low byte, clear variables
.a671	84 30		sty $30			STY	LAB_30		; set end of variables high byte
.a673	85 31		sta $31			STA	LAB_31		; set end of arrays low byte, clear arrays
.a675	84 32		sty $32			STY	LAB_32		; set end of arrays high byte
.a677					LAB_A677
.a677	20 1d a8	jsr $a81d		JSR	LAB_A81D		; perform RESTORE
.a67a					LAB_A67A
.a67a	a2 19		ldx #$19		LDX	#LAB_19		; get the descriptor stack start
.a67c	86 16		stx $16			STX	LAB_16		; set the descriptor stack pointer
.a67e	68		pla			PLA				; pull the return address low byte
.a67f	a8		tay			TAY				; copy it
.a680	68		pla			PLA				; pull the return address high byte
.a681	a2 fa		ldx #$fa		LDX	#$FA			; set the cleared stack pointer
.a683	9a		txs			TXS				; set the stack
.a684	48		pha			PHA				; push the return address high byte
.a685	98		tya			TYA				; restore the return address low byte
.a686	48		pha			PHA				; push the return address low byte
.a687	a9 00		lda #$00		LDA	#$00			; clear A
.a689	85 3e		sta $3e			STA	LAB_3E		; clear the continue pointer high byte
.a68b	85 10		sta $10			STA	LAB_10		; clear the subscript/FNX flag
.a68d					LAB_A68D
.a68d	60		rts			RTS
.a68e					LAB_A68E
.a68e	18		clc			CLC				; clear carry for add
.a68f	a5 2b		lda $2b			LDA	LAB_2B		; get start of memory low byte
.a691	69 ff		adc #$ff		ADC	#$FF			; add -1 low byte
.a693	85 7a		sta $7a			STA	LAB_7A		; set BASIC execute pointer low byte
.a695	a5 2c		lda $2c			LDA	LAB_2C		; get start of memory high byte
.a697	69 ff		adc #$ff		ADC	#$FF			; add -1 high byte
.a699	85 7b		sta $7b			STA	LAB_7B		; save BASIC execute pointer high byte
.a69b	60		rts			RTS
.a69c					LAB_A69C
.a69c	90 06		bcc $a6a4		BCC	LAB_A6A4		; branch if next character not token (LIST n...)
.a69e	f0 04		beq $a6a4		BEQ	LAB_A6A4		; branch if next character [NULL] (LIST)
.a6a0	c9 ab		cmp #$ab		CMP	#TK_MINUS		; compare with token for -
.a6a2	d0 e9		bne $a68d		BNE	LAB_A68D		; exit if not - (LIST -m)
.a6a4					LAB_A6A4
.a6a4	20 6b a9	jsr $a96b		JSR	LAB_A96B		; get fixed-point number into temporary integer
.a6a7	20 13 a6	jsr $a613		JSR	LAB_A613		; search BASIC for temporary integer line number
.a6aa	20 79 00	jsr $0079		JSR	LAB_0079		; scan memory
.a6ad	f0 0c		beq $a6bb		BEQ	LAB_A6BB		; branch if no more chrs
.a6af	c9 ab		cmp #$ab		CMP	#TK_MINUS		; compare with token for -
.a6b1	d0 8e		bne $a641		BNE	LAB_A641		; return if not "-" (will be SN error)
.a6b3	20 73 00	jsr $0073		JSR	LAB_0073		; increment and scan memory
.a6b6	20 6b a9	jsr $a96b		JSR	LAB_A96B		; get fixed-point number into temporary integer
.a6b9	d0 86		bne $a641		BNE	LAB_A641		; exit if not ok
.a6bb					LAB_A6BB
.a6bb	68		pla			PLA				; dump return address low byte, exit via warm start
.a6bc	68		pla			PLA				; dump return address high byte
.a6bd	a5 14		lda $14			LDA	LAB_14		; get temporary integer low byte
.a6bf	05 15		ora $15			ORA	LAB_15		; OR temporary integer high byte
.a6c1	d0 06		bne $a6c9		BNE	LAB_A6C9		; branch if start set
.a6c3	a9 ff		lda #$ff		LDA	#$FF			; set for -1
.a6c5	85 14		sta $14			STA	LAB_14		; set temporary integer low byte
.a6c7	85 15		sta $15			STA	LAB_15		; set temporary integer high byte
.a6c9					LAB_A6C9
.a6c9	a0 01		ldy #$01		LDY	#$01			; set index for line
.a6cb	84 0f		sty $0f			STY	LAB_0F		; clear open quote flag
.a6cd	b1 5f		lda ($5f),y		LDA	(LAB_5F),Y		; get next line pointer high byte
.a6cf	f0 43		beq $a714		BEQ	LAB_A714		; if null all done so exit
.a6d1	20 2c a8	jsr $a82c		JSR	LAB_A82C		; do CRTL-C check vector
.a6d4	20 d7 aa	jsr $aad7		JSR	LAB_AAD7		; print CR/LF
.a6d7	c8		iny			INY				; increment index for line
.a6d8	b1 5f		lda ($5f),y		LDA	(LAB_5F),Y		; get line number low byte
.a6da	aa		tax			TAX				; copy to X
.a6db	c8		iny			INY				; increment index
.a6dc	b1 5f		lda ($5f),y		LDA	(LAB_5F),Y		; get line number high byte
.a6de	c5 15		cmp $15			CMP	LAB_15		; compare with temporary integer high byte
.a6e0	d0 04		bne $a6e6		BNE	LAB_A6E6		; branch if no high byte match
.a6e2	e4 14		cpx $14			CPX	LAB_14		; compare with temporary integer low byte
.a6e4	f0 02		beq $a6e8		BEQ	LAB_A6E8		; branch if = last line to do, < will pass next branch
.a6e6					LAB_A6E6
.a6e6	b0 2c		bcs $a714		BCS	LAB_A714		; if greater all done so exit
.a6e8					LAB_A6E8
.a6e8	84 49		sty $49			STY	LAB_49		; save index for line
.a6ea	20 cd bd	jsr $bdcd		JSR	LAB_BDCD		; print XA as unsigned integer
.a6ed	a9 20		lda #$20		LDA	#' '			; space is the next character
.a6ef					LAB_A6EF
.a6ef	a4 49		ldy $49			LDY	LAB_49		; get index for line
.a6f1	29 7f		and #$7f		AND	#$7F			; mask top out bit of character
.a6f3					LAB_A6F3
.a6f3	20 47 ab	jsr $ab47		JSR	LAB_AB47		; go print the character
.a6f6	c9 22		cmp #$22		CMP	#$22			; was it " character
.a6f8	d0 06		bne $a700		BNE	LAB_A700		; if not skip the quote handle
.a6fa	a5 0f		lda $0f			LDA	LAB_0F		; get open quote flag
.a6fc	49 ff		eor #$ff		EOR	#$FF			; toggle it
.a6fe	85 0f		sta $0f			STA	LAB_0F		; save it back
.a700					LAB_A700
.a700	c8		iny			INY				; increment index
.a701	f0 11		beq $a714		BEQ	LAB_A714		; line too long so just bail out and do a warm start
.a703	b1 5f		lda ($5f),y		LDA	(LAB_5F),Y		; get next byte
.a705	d0 10		bne $a717		BNE	LAB_A717		; if not [EOL] (go print character)
.a707	a8		tay			TAY				; else clear index
.a708	b1 5f		lda ($5f),y		LDA	(LAB_5F),Y		; get next line pointer low byte
.a70a	aa		tax			TAX				; copy to X
.a70b	c8		iny			INY				; increment index
.a70c	b1 5f		lda ($5f),y		LDA	(LAB_5F),Y		; get next line pointer high byte
.a70e	86 5f		stx $5f			STX	LAB_5F		; set pointer to line low byte
.a710	85 60		sta $60			STA	LAB_60		; set pointer to line high byte
.a712	d0 b5		bne $a6c9		BNE	LAB_A6C9		; go do next line if not [EOT]
.a714					LAB_A714
.a714	4c 86 e3	jmp $e386		JMP	LAB_E386		; do warm start
.a717					LAB_A717
.a717	6c 06 03	jmp ($0306)		JMP	(LAB_0306)		; do uncrunch BASIC tokens
.a71a					LAB_A71A
.a71a	10 d7		bpl $a6f3		BPL	LAB_A6F3		; just go print it if not token byte
.a71c	c9 ff		cmp #$ff		CMP	#TK_PI		; compare with the token for PI. in this case the token
.a71e	f0 d3		beq $a6f3		BEQ	LAB_A6F3		; just print it if so
.a720	24 0f		bit $0f			BIT	LAB_0F		; test the open quote flag
.a722	30 cf		bmi $a6f3		BMI	LAB_A6F3		; just go print character if open quote set
.a724	38		sec			SEC				; else set carry for subtract
.a725	e9 7f		sbc #$7f		SBC	#$7F			; reduce token range to 1 to whatever
.a727	aa		tax			TAX				; copy token # to X
.a728	84 49		sty $49			STY	LAB_49		; save index for line
.a72a	a0 ff		ldy #$ff		LDY	#$FF			; start from -1, adjust for pre increment
.a72c					LAB_A72C
.a72c	ca		dex			DEX				; decrement token #
.a72d	f0 08		beq $a737		BEQ	LAB_A737		; if now found go do printing
.a72f					LAB_A72F
.a72f	c8		iny			INY				; else increment index
.a730	b9 9e a0	lda $a09e,y		LDA	LAB_A09E,Y		; get byte from keyword table
.a733	10 fa		bpl $a72f		BPL	LAB_A72F		; loop until keyword end marker
.a735	30 f5		bmi $a72c		BMI	LAB_A72C		; go test if this is required keyword, branch always
.a737					LAB_A737
.a737	c8		iny			INY				; increment keyword table index
.a738	b9 9e a0	lda $a09e,y		LDA	LAB_A09E,Y		; get byte from table
.a73b	30 b2		bmi $a6ef		BMI	LAB_A6EF		; go restore index, mask byte and print if
.a73d	20 47 ab	jsr $ab47		JSR	LAB_AB47		; else go print the character
.a740	d0 f5		bne $a737		BNE	LAB_A737		; go get next character, branch always
.a742					LAB_A742
.a742	a9 80		lda #$80		LDA	#$80			; set FNX
.a744	85 10		sta $10			STA	LAB_10		; set subscript/FNX flag
.a746	20 a5 a9	jsr $a9a5		JSR	LAB_A9A5		; perform LET
.a749	20 8a a3	jsr $a38a		JSR	LAB_A38A		; search the stack for FOR or GOSUB activity
.a74c	d0 05		bne $a753		BNE	LAB_A753		; branch if FOR, this variable, not found
.a74e	8a		txa			TXA				; copy index
.a74f	69 0f		adc #$0f		ADC	#$0F			; add FOR structure size-2
.a751	aa		tax			TAX				; copy to index
.a752	9a		txs			TXS				; set stack (dump FOR structure (-2 bytes))
.a753					LAB_A753
.a753	68		pla			PLA				; pull return address
.a754	68		pla			PLA				; pull return address
.a755	a9 09		lda #$09		LDA	#$09			; we need 18d bytes !
.a757	20 fb a3	jsr $a3fb		JSR	LAB_A3FB		; check room on stack for 2*A bytes
.a75a	20 06 a9	jsr $a906		JSR	LAB_A906		; scan for next BASIC statement ([:] or [EOL])
.a75d	18		clc			CLC				; clear carry for add
.a75e	98		tya			TYA				; copy index to A
.a75f	65 7a		adc $7a			ADC	LAB_7A		; add BASIC execute pointer low byte
.a761	48		pha			PHA				; push onto stack
.a762	a5 7b		lda $7b			LDA	LAB_7B		; get BASIC execute pointer high byte
.a764	69 00		adc #$00		ADC	#$00			; add carry
.a766	48		pha			PHA				; push onto stack
.a767	a5 3a		lda $3a			LDA	LAB_3A		; get current line number high byte
.a769	48		pha			PHA				; push onto stack
.a76a	a5 39		lda $39			LDA	LAB_39		; get current line number low byte
.a76c	48		pha			PHA				; push onto stack
.a76d	a9 a4		lda #$a4		LDA	#TK_TO		; set "TO" token
.a76f	20 ff ae	jsr $aeff		JSR	LAB_AEFF		; scan for CHR$(A), else do syntax error then warm start
.a772	20 8d ad	jsr $ad8d		JSR	LAB_AD8D		; check if source is numeric, else do type mismatch
.a775	20 8a ad	jsr $ad8a		JSR	LAB_AD8A		; evaluate expression and check is numeric, else do
.a778	a5 66		lda $66			LDA	LAB_66		; get FAC1 sign (b7)
.a77a	09 7f		ora #$7f		ORA	#$7F			; set all non sign bits
.a77c	25 62		and $62			AND	LAB_62		; and FAC1 mantissa 1
.a77e	85 62		sta $62			STA	LAB_62		; save FAC1 mantissa 1
.a780	a9 8b		lda #$8b		LDA	#<LAB_A78B		; set return address low byte
.a782	a0 a7		ldy #$a7		LDY	#>LAB_A78B		; set return address high byte
.a784	85 22		sta $22			STA	LAB_22		; save return address low byte
.a786	84 23		sty $23			STY	LAB_23		; save return address high byte
.a788	4c 43 ae	jmp $ae43		JMP	LAB_AE43		; round FAC1 and put on stack, returns to next instruction
.a78b					LAB_A78B
.a78b	a9 bc		lda #$bc		LDA	#<LAB_B9BC		; set 1 pointer low address, default step size
.a78d	a0 b9		ldy #$b9		LDY	#>LAB_B9BC		; set 1 pointer high address
.a78f	20 a2 bb	jsr $bba2		JSR	LAB_BBA2		; unpack memory (AY) into FAC1
.a792	20 79 00	jsr $0079		JSR	LAB_0079		; scan memory
.a795	c9 a9		cmp #$a9		CMP	#TK_STEP		; compare with STEP token
.a797	d0 06		bne $a79f		BNE	LAB_A79F		; if not "STEP" continue
.a799	20 73 00	jsr $0073		JSR	LAB_0073		; increment and scan memory
.a79c	20 8a ad	jsr $ad8a		JSR	LAB_AD8A		; evaluate expression and check is numeric, else do
.a79f					LAB_A79F
.a79f	20 2b bc	jsr $bc2b		JSR	LAB_BC2B		; get FAC1 sign, return A = $FF -ve, A = $01 +ve
.a7a2	20 38 ae	jsr $ae38		JSR	LAB_AE38		; push sign, round FAC1 and put on stack
.a7a5	a5 4a		lda $4a			LDA	LAB_4A		; get FOR/NEXT variable pointer high byte
.a7a7	48		pha			PHA				; push on stack
.a7a8	a5 49		lda $49			LDA	LAB_49		; get FOR/NEXT variable pointer low byte
.a7aa	48		pha			PHA				; push on stack
.a7ab	a9 81		lda #$81		LDA	#TK_FOR		; get FOR token
.a7ad	48		pha			PHA				; push on stack
.a7ae					LAB_A7AE
.a7ae	20 2c a8	jsr $a82c		JSR	LAB_A82C		; do CRTL-C check vector
.a7b1	a5 7a		lda $7a			LDA	LAB_7A		; get the BASIC execute pointer low byte
.a7b3	a4 7b		ldy $7b			LDY	LAB_7B		; get the BASIC execute pointer high byte
.a7b5	c0 02		cpy #$02		CPY	#$02			; compare the high byte with $02xx
.a7b7	ea		nop			NOP				; unused byte							##
.a7b8	f0 04		beq $a7be		BEQ	LAB_A7BE		; if immediate mode skip the continue pointer save
.a7ba	85 3d		sta $3d			STA	LAB_3D		; save the continue pointer low byte
.a7bc	84 3e		sty $3e			STY	LAB_3E		; save the continue pointer high byte
.a7be					LAB_A7BE
.a7be	a0 00		ldy #$00		LDY	#$00			; clear the index
.a7c0	b1 7a		lda ($7a),y		LDA	(LAB_7A),Y		; get a BASIC byte
.a7c2	d0 43		bne $a807		BNE	LAB_A807		; if not [EOL] go test for ":"
.a7c4	a0 02		ldy #$02		LDY	#$02			; else set the index
.a7c6	b1 7a		lda ($7a),y		LDA	(LAB_7A),Y		; get next line pointer high byte
.a7c8	18		clc			CLC				; clear carry for no "BREAK" message
.a7c9	d0 03		bne $a7ce		BNE	LAB_A7CE		; branch if not end of program
.a7cb	4c 4b a8	jmp $a84b		JMP	LAB_A84B		; else go to immediate mode,was immediate or [EOT] marker
.a7ce					LAB_A7CE
.a7ce	c8		iny			INY				; increment index
.a7cf	b1 7a		lda ($7a),y		LDA	(LAB_7A),Y		; get line number low byte
.a7d1	85 39		sta $39			STA	LAB_39		; save current line number low byte
.a7d3	c8		iny			INY				; increment index
.a7d4	b1 7a		lda ($7a),y		LDA	(LAB_7A),Y		; get line # high byte
.a7d6	85 3a		sta $3a			STA	LAB_3A		; save current line number high byte
.a7d8	98		tya			TYA				; A now = 4
.a7d9	65 7a		adc $7a			ADC	LAB_7A		; add BASIC execute pointer low byte, now points to code
.a7db	85 7a		sta $7a			STA	LAB_7A		; save BASIC execute pointer low byte
.a7dd	90 02		bcc $a7e1		BCC	LAB_A7E1		; branch if no overflow
.a7df	e6 7b		inc $7b			INC	LAB_7B		; else increment BASIC execute pointer high byte
.a7e1					LAB_A7E1
.a7e1	6c 08 03	jmp ($0308)		JMP	(LAB_0308)		; do start new BASIC code
.a7e4					LAB_A7E4
.a7e4	20 73 00	jsr $0073		JSR	LAB_0073		; increment and scan memory
.a7e7	20 ed a7	jsr $a7ed		JSR	LAB_A7ED		; go interpret BASIC code from BASIC execute pointer
.a7ea	4c ae a7	jmp $a7ae		JMP	LAB_A7AE		; loop
.a7ed					LAB_A7ED
.a7ed	f0 3c		beq $a82b		BEQ	LAB_A82B		; if the first byte is null just exit
.a7ef					LAB_A7EF
.a7ef	e9 80		sbc #$80		SBC	#$80			; normalise the token
.a7f1	90 11		bcc $a804		BCC	LAB_A804		; if wasn't token go do LET
.a7f3	c9 23		cmp #$23		CMP	#TK_TAB-$80		; compare with token for TAB(-$80
.a7f5	b0 17		bcs $a80e		BCS	LAB_A80E		; branch if >= TAB(
.a7f7	0a		asl a			ASL				; *2 bytes per vector
.a7f8	a8		tay			TAY				; copy to index
.a7f9	b9 0d a0	lda $a00d,y		LDA	LAB_A00C+1,Y	; get vector high byte
.a7fc	48		pha			PHA				; push on stack
.a7fd	b9 0c a0	lda $a00c,y		LDA	LAB_A00C,Y		; get vector low byte
.a800	48		pha			PHA				; push on stack
.a801	4c 73 00	jmp $0073		JMP	LAB_0073		; increment and scan memory and return. the return in
.a804					LAB_A804
.a804	4c a5 a9	jmp $a9a5		JMP	LAB_A9A5		; perform LET
.a807					LAB_A807
.a807	c9 3a		cmp #$3a		CMP	#':'			; comapre with ":"
.a809	f0 d6		beq $a7e1		BEQ	LAB_A7E1		; if ":" go execute new code
.a80b					LAB_A80B
.a80b	4c 08 af	jmp $af08		JMP	LAB_AF08		; do syntax error then warm start
.a80e					LAB_A80E
.a80e	c9 4b		cmp #$4b		CMP	#TK_GO-$80		; compare with the token for GO
.a810	d0 f9		bne $a80b		BNE	LAB_A80B		; if not "GO" do syntax error then warm start
.a812	20 73 00	jsr $0073		JSR	LAB_0073		; increment and scan memory
.a815	a9 a4		lda #$a4		LDA	#TK_TO		; set "TO" token
.a817	20 ff ae	jsr $aeff		JSR	LAB_AEFF		; scan for CHR$(A), else do syntax error then warm start
.a81a	4c a0 a8	jmp $a8a0		JMP	LAB_A8A0		; perform GOTO
.a81d					LAB_A81D
.a81d	38		sec			SEC				; set carry for subtract
.a81e	a5 2b		lda $2b			LDA	LAB_2B		; get start of memory low byte
.a820	e9 01		sbc #$01		SBC	#$01			; -1
.a822	a4 2c		ldy $2c			LDY	LAB_2C		; get start of memory high byte
.a824	b0 01		bcs $a827		BCS	LAB_A827		; branch if no rollunder
.a826	88		dey			DEY				; else decrement high byte
.a827					LAB_A827
.a827	85 41		sta $41			STA	LAB_41		; set DATA pointer low byte
.a829	84 42		sty $42			STY	LAB_42		; set DATA pointer high byte
.a82b					LAB_A82B
.a82b	60		rts			RTS
.a82c					LAB_A82C
.a82c	20 e1 ff	jsr $ffe1		JSR	LAB_FFE1		; scan stop key
.a82f					LAB_A82F
.a82f	b0 01		bcs $a832		BCS	LAB_A832		; if carry set do BREAK instead of just END
.a831					LAB_A831
.a831	18		clc			CLC				; clear carry
.a832					LAB_A832
.a832	d0 3c		bne $a870		BNE	LAB_A870		; return if wasn't CTRL-C
.a834	a5 7a		lda $7a			LDA	LAB_7A		; get BASIC execute pointer low byte
.a836	a4 7b		ldy $7b			LDY	LAB_7B		; get BASIC execute pointer high byte
.a838	a6 3a		ldx $3a			LDX	LAB_3A		; get current line number high byte
.a83a	e8		inx			INX				; increment it
.a83b	f0 0c		beq $a849		BEQ	LAB_A849		; branch if was immediate mode
.a83d	85 3d		sta $3d			STA	LAB_3D		; save continue pointer low byte
.a83f	84 3e		sty $3e			STY	LAB_3E		; save continue pointer high byte
.a841	a5 39		lda $39			LDA	LAB_39		; get current line number low byte
.a843	a4 3a		ldy $3a			LDY	LAB_3A		; get current line number high byte
.a845	85 3b		sta $3b			STA	LAB_3B		; save break line number low byte
.a847	84 3c		sty $3c			STY	LAB_3C		; save break line number high byte
.a849					LAB_A849
.a849	68		pla			PLA				; dump return address low byte
.a84a	68		pla			PLA				; dump return address high byte
.a84b					LAB_A84B
.a84b	a9 81		lda #$81		LDA	#<LAB_A381		; set [CR][LF]"BREAK" pointer low byte
.a84d	a0 a3		ldy #$a3		LDY	#>LAB_A381		; set [CR][LF]"BREAK" pointer high byte
.a84f	90 03		bcc $a854		BCC	LAB_A854		; if was program end skip the print string
.a851	4c 69 a4	jmp $a469		JMP	LAB_A469		; print string and do warm start
.a854					LAB_A854
.a854	4c 86 e3	jmp $e386		JMP	LAB_E386		; do warm start
.a857					LAB_A857
.a857	d0 17		bne $a870		BNE	LAB_A870		; exit if following byte to allow syntax error
.a859	a2 1a		ldx #$1a		LDX	#$1A			; error code $1A, can't continue error
.a85b	a4 3e		ldy $3e			LDY	LAB_3E		; get continue pointer high byte
.a85d	d0 03		bne $a862		BNE	LAB_A862		; go do continue if we can
.a85f	4c 37 a4	jmp $a437		JMP	LAB_A437		; else do error #X then warm start
.a862					LAB_A862
.a862	a5 3d		lda $3d			LDA	LAB_3D		; get continue pointer low byte
.a864	85 7a		sta $7a			STA	LAB_7A		; save BASIC execute pointer low byte
.a866	84 7b		sty $7b			STY	LAB_7B		; save BASIC execute pointer high byte
.a868	a5 3b		lda $3b			LDA	LAB_3B		; get break line low byte
.a86a	a4 3c		ldy $3c			LDY	LAB_3C		; get break line high byte
.a86c	85 39		sta $39			STA	LAB_39		; set current line number low byte
.a86e	84 3a		sty $3a			STY	LAB_3A		; set current line number high byte
.a870					LAB_A870
.a870	60		rts			RTS
.a871					LAB_A871
.a871	08		php			PHP				; save status
.a872	a9 00		lda #$00		LDA	#$00			; no control or kernal messages
.a874	20 90 ff	jsr $ff90		JSR	LAB_FF90		; control kernal messages
.a877	28		plp			PLP				; restore status
.a878	d0 03		bne $a87d		BNE	LAB_A87D		; branch if RUN n
.a87a	4c 59 a6	jmp $a659		JMP	LAB_A659		; reset execution to start, clear variables, flush stack
.a87d					LAB_A87D
.a87d	20 60 a6	jsr $a660		JSR	LAB_A660		; go do "CLEAR"
.a880	4c 97 a8	jmp $a897		JMP	LAB_A897		; get n and do GOTO n
.a883					LAB_A883
.a883	a9 03		lda #$03		LDA	#$03			; need 6 bytes for GOSUB
.a885	20 fb a3	jsr $a3fb		JSR	LAB_A3FB		; check room on stack for 2*A bytes
.a888	a5 7b		lda $7b			LDA	LAB_7B		; get BASIC execute pointer high byte
.a88a	48		pha			PHA				; save it
.a88b	a5 7a		lda $7a			LDA	LAB_7A		; get BASIC execute pointer low byte
.a88d	48		pha			PHA				; save it
.a88e	a5 3a		lda $3a			LDA	LAB_3A		; get current line number high byte
.a890	48		pha			PHA				; save it
.a891	a5 39		lda $39			LDA	LAB_39		; get current line number low byte
.a893	48		pha			PHA				; save it
.a894	a9 8d		lda #$8d		LDA	#TK_GOSUB		; token for GOSUB
.a896	48		pha			PHA				; save it
.a897					LAB_A897
.a897	20 79 00	jsr $0079		JSR	LAB_0079		; scan memory
.a89a	20 a0 a8	jsr $a8a0		JSR	LAB_A8A0		; perform GOTO
.a89d	4c ae a7	jmp $a7ae		JMP	LAB_A7AE		; go do interpreter inner loop
.a8a0					LAB_A8A0
.a8a0	20 6b a9	jsr $a96b		JSR	LAB_A96B		; get fixed-point number into temporary integer
.a8a3	20 09 a9	jsr $a909		JSR	LAB_A909		; scan for next BASIC line
.a8a6	38		sec			SEC				; set carry for subtract
.a8a7	a5 39		lda $39			LDA	LAB_39		; get current line number low byte
.a8a9	e5 14		sbc $14			SBC	LAB_14		; subtract temporary integer low byte
.a8ab	a5 3a		lda $3a			LDA	LAB_3A		; get current line number high byte
.a8ad	e5 15		sbc $15			SBC	LAB_15		; subtract temporary integer high byte
.a8af	b0 0b		bcs $a8bc		BCS	LAB_A8BC		; if current line number >= temporary integer, go search
.a8b1	98		tya			TYA				; else copy line index to A
.a8b2	38		sec			SEC				; set carry (+1)
.a8b3	65 7a		adc $7a			ADC	LAB_7A		; add BASIC execute pointer low byte
.a8b5	a6 7b		ldx $7b			LDX	LAB_7B		; get BASIC execute pointer high byte
.a8b7	90 07		bcc $a8c0		BCC	LAB_A8C0		; branch if no overflow to high byte
.a8b9	e8		inx			INX				; increment high byte
.a8ba	b0 04		bcs $a8c0		BCS	LAB_A8C0		; branch always (can never be carry)
.a8bc					LAB_A8BC
.a8bc	a5 2b		lda $2b			LDA	LAB_2B		; get start of memory low byte
.a8be	a6 2c		ldx $2c			LDX	LAB_2C		; get start of memory high byte
.a8c0					LAB_A8C0
.a8c0	20 17 a6	jsr $a617		JSR	LAB_A617		; search Basic for temp integer line number from AX
.a8c3	90 1e		bcc $a8e3		BCC	LAB_A8E3		; if carry clear go do unsdefined statement error
.a8c5	a5 5f		lda $5f			LDA	LAB_5F		; get pointer low byte
.a8c7	e9 01		sbc #$01		SBC	#$01			; -1
.a8c9	85 7a		sta $7a			STA	LAB_7A		; save BASIC execute pointer low byte
.a8cb	a5 60		lda $60			LDA	LAB_60		; get pointer high byte
.a8cd	e9 00		sbc #$00		SBC	#$00			; subtract carry
.a8cf	85 7b		sta $7b			STA	LAB_7B		; save BASIC execute pointer high byte
.a8d1					LAB_A8D1
.a8d1	60		rts			RTS
.a8d2					LAB_A8D2
.a8d2	d0 fd		bne $a8d1		BNE	LAB_A8D1		; exit if following token to allow syntax error
.a8d4	a9 ff		lda #$ff		LDA	#$FF			; set byte so no match possible
.a8d6	85 4a		sta $4a			STA	LAB_4A		; save FOR/NEXT variable pointer high byte
.a8d8	20 8a a3	jsr $a38a		JSR	LAB_A38A		; search the stack for FOR or GOSUB activity,
.a8db	9a		txs			TXS				; correct the stack
.a8dc	c9 8d		cmp #$8d		CMP	#TK_GOSUB		; compare with GOSUB token
.a8de	f0 0b		beq $a8eb		BEQ	LAB_A8EB		; if matching GOSUB go continue RETURN
.a8e0	a2 0c		ldx #$0c		LDX	#$0C			; else error code $04, return without gosub error
>a8e2	2c					.byte	$2C			; makes next line BIT LAB_11A2
.a8e3					LAB_A8E3
.a8e3	a2 11		ldx #$11		LDX	#$11			; error code $11, undefined statement error
.a8e5	4c 37 a4	jmp $a437		JMP	LAB_A437		; do error #X then warm start
.a8e8					LAB_A8E8
.a8e8	4c 08 af	jmp $af08		JMP	LAB_AF08		; do syntax error then warm start
.a8eb					LAB_A8EB
.a8eb	68		pla			PLA				; dump token byte
.a8ec	68		pla			PLA				; pull return line low byte
.a8ed	85 39		sta $39			STA	LAB_39		; save current line number low byte
.a8ef	68		pla			PLA				; pull return line high byte
.a8f0	85 3a		sta $3a			STA	LAB_3A		; save current line number high byte
.a8f2	68		pla			PLA				; pull return address low byte
.a8f3	85 7a		sta $7a			STA	LAB_7A		; save BASIC execute pointer low byte
.a8f5	68		pla			PLA				; pull return address high byte
.a8f6	85 7b		sta $7b			STA	LAB_7B		; save BASIC execute pointer high byte
.a8f8					LAB_A8F8
.a8f8	20 06 a9	jsr $a906		JSR	LAB_A906		; scan for next BASIC statement ([:] or [EOL])
.a8fb					LAB_A8FB
.a8fb	98		tya			TYA				; copy index to A
.a8fc	18		clc			CLC				; clear carry for add
.a8fd	65 7a		adc $7a			ADC	LAB_7A		; add BASIC execute pointer low byte
.a8ff	85 7a		sta $7a			STA	LAB_7A		; save BASIC execute pointer low byte
.a901	90 02		bcc $a905		BCC	LAB_A905		; skip increment if no carry
.a903	e6 7b		inc $7b			INC	LAB_7B		; else increment BASIC execute pointer high byte
.a905					LAB_A905
.a905	60		rts			RTS
.a906					LAB_A906
.a906	a2 3a		ldx #$3a		LDX	#':'			; set look for character = ":"
>a908	2c					.byte	$2C			; makes next line BIT LAB_00A2
.a909					LAB_A909
.a909	a2 00		ldx #$00		LDX	#$00			; set alternate search character = [EOL]
.a90b	86 07		stx $07			STX	LAB_07		; store alternate search character
.a90d	a0 00		ldy #$00		LDY	#$00			; set search character = [EOL]
.a90f	84 08		sty $08			STY	LAB_08		; save the search character
.a911					LAB_A911
.a911	a5 08		lda $08			LDA	LAB_08		; get search character
.a913	a6 07		ldx $07			LDX	LAB_07		; get alternate search character
.a915	85 07		sta $07			STA	LAB_07		; make search character = alternate search character
.a917	86 08		stx $08			STX	LAB_08		; make alternate search character = search character
.a919					LAB_A919
.a919	b1 7a		lda ($7a),y		LDA	(LAB_7A),Y		; get BASIC byte
.a91b	f0 e8		beq $a905		BEQ	LAB_A905		; exit if null [EOL]
.a91d	c5 08		cmp $08			CMP	LAB_08		; compare with search character
.a91f	f0 e4		beq $a905		BEQ	LAB_A905		; exit if found
.a921	c8		iny			INY				; else increment index
.a922	c9 22		cmp #$22		CMP	#$22			; compare current character with open quote
.a924	d0 f3		bne $a919		BNE	LAB_A919		; if found go swap search character for alternate search
.a926	f0 e9		beq $a911		BEQ	LAB_A911		; loop for next character, branch always
.a928					LAB_A928
.a928	20 9e ad	jsr $ad9e		JSR	LAB_AD9E		; evaluate expression
.a92b	20 79 00	jsr $0079		JSR	LAB_0079		; scan memory
.a92e	c9 89		cmp #$89		CMP	#TK_GOTO		; compare with "GOTO" token
.a930	f0 05		beq $a937		BEQ	LAB_A937		; if it was  the token for GOTO go do IF ... GOTO
.a932	a9 a7		lda #$a7		LDA	#TK_THEN		; set "THEN" token
.a934	20 ff ae	jsr $aeff		JSR	LAB_AEFF		; scan for CHR$(A), else do syntax error then warm start
.a937					LAB_A937
.a937	a5 61		lda $61			LDA	LAB_61		; get FAC1 exponent
.a939	d0 05		bne $a940		BNE	LAB_A940		; if result was non zero continue execution
.a93b					LAB_A93B
.a93b	20 09 a9	jsr $a909		JSR	LAB_A909		; scan for next BASIC line
.a93e	f0 bb		beq $a8fb		BEQ	LAB_A8FB		; add Y to the BASIC execute pointer and return, branch
.a940					LAB_A940
.a940	20 79 00	jsr $0079		JSR	LAB_0079		; scan memory
.a943	b0 03		bcs $a948		BCS	LAB_A948		; branch if not numeric character, is variable or keyword
.a945	4c a0 a8	jmp $a8a0		JMP	LAB_A8A0		; else perform GOTO n
.a948					LAB_A948
.a948	4c ed a7	jmp $a7ed		JMP	LAB_A7ED		; interpret BASIC code from BASIC execute pointer
.a94b					LAB_A94B
.a94b	20 9e b7	jsr $b79e		JSR	LAB_B79E		; get byte parameter
.a94e	48		pha			PHA				; push next character
.a94f	c9 8d		cmp #$8d		CMP	#TK_GOSUB		; compare with GOSUB token
.a951	f0 04		beq $a957		BEQ	LAB_A957		; if GOSUB go see if it should be executed
.a953					LAB_A953
.a953	c9 89		cmp #$89		CMP	#TK_GOTO		; compare with GOTO token
.a955	d0 91		bne $a8e8		BNE	LAB_A8E8		; if not GOTO do syntax error then warm start
.a957					LAB_A957
.a957	c6 65		dec $65			DEC	LAB_65		; decrement the byte value
.a959	d0 04		bne $a95f		BNE	LAB_A95F		; if not zero go see if another line number exists
.a95b	68		pla			PLA				; pull keyword token
.a95c	4c ef a7	jmp $a7ef		JMP	LAB_A7EF		; go execute it
.a95f					LAB_A95F
.a95f	20 73 00	jsr $0073		JSR	LAB_0073		; increment and scan memory
.a962	20 6b a9	jsr $a96b		JSR	LAB_A96B		; get fixed-point number into temporary integer
.a965	c9 2c		cmp #$2c		CMP	#','			; compare next character with ","
.a967	f0 ee		beq $a957		BEQ	LAB_A957		; loop if ","
.a969	68		pla			PLA				; else pull keyword token, ran out of options
.a96a					LAB_A96A
.a96a	60		rts			RTS
.a96b					LAB_A96B
.a96b	a2 00		ldx #$00		LDX	#$00			; clear X
.a96d	86 14		stx $14			STX	LAB_14		; clear temporary integer low byte
.a96f	86 15		stx $15			STX	LAB_15		; clear temporary integer high byte
.a971					LAB_A971
.a971	b0 f7		bcs $a96a		BCS	LAB_A96A		; return if carry set, end of scan, character was not 0-9
.a973	e9 2f		sbc #$2f		SBC	#'0'-1		; subtract $30, $2F+carry, from byte
.a975	85 07		sta $07			STA	LAB_07		; store #
.a977	a5 15		lda $15			LDA	LAB_15		; get temporary integer high byte
.a979	85 22		sta $22			STA	LAB_22		; save it for now
.a97b	c9 19		cmp #$19		CMP	#$19			; compare with $19
.a97d	b0 d4		bcs $a953		BCS	LAB_A953		; branch if >= this makes the maximum line number 63999
.a97f	a5 14		lda $14			LDA	LAB_14		; get temporary integer low byte
.a981	0a		asl a			ASL				; *2 low byte
.a982	26 22		rol $22			ROL	LAB_22		; *2 high byte
.a984	0a		asl a			ASL				; *2 low byte
.a985	26 22		rol $22			ROL	LAB_22		; *2 high byte (*4)
.a987	65 14		adc $14			ADC	LAB_14		; + low byte (*5)
.a989	85 14		sta $14			STA	LAB_14		; save it
.a98b	a5 22		lda $22			LDA	LAB_22		; get high byte temp
.a98d	65 15		adc $15			ADC	LAB_15		; + high byte (*5)
.a98f	85 15		sta $15			STA	LAB_15		; save it
.a991	06 14		asl $14			ASL	LAB_14		; *2 low byte (*10d)
.a993	26 15		rol $15			ROL	LAB_15		; *2 high byte (*10d)
.a995	a5 14		lda $14			LDA	LAB_14		; get low byte
.a997	65 07		adc $07			ADC	LAB_07		; add #
.a999	85 14		sta $14			STA	LAB_14		; save low byte
.a99b	90 02		bcc $a99f		BCC	LAB_A99F		; branch if no overflow to high byte
.a99d	e6 15		inc $15			INC	LAB_15		; else increment high byte
.a99f					LAB_A99F
.a99f	20 73 00	jsr $0073		JSR	LAB_0073		; increment and scan memory
.a9a2	4c 71 a9	jmp $a971		JMP	LAB_A971		; loop for next character
.a9a5					LAB_A9A5
.a9a5	20 8b b0	jsr $b08b		JSR	LAB_B08B		; get variable address
.a9a8	85 49		sta $49			STA	LAB_49		; save variable address low byte
.a9aa	84 4a		sty $4a			STY	LAB_4A		; save variable address high byte
.a9ac	a9 b2		lda #$b2		LDA	#TK_EQUAL		; $B2 is "=" token
.a9ae	20 ff ae	jsr $aeff		JSR	LAB_AEFF		; scan for CHR$(A), else do syntax error then warm start
.a9b1	a5 0e		lda $0e			LDA	LAB_0E		; get data type flag, $80 = integer, $00 = float
.a9b3	48		pha			PHA				; push data type flag
.a9b4	a5 0d		lda $0d			LDA	LAB_0D		; get data type flag, $FF = string, $00 = numeric
.a9b6	48		pha			PHA				; push data type flag
.a9b7	20 9e ad	jsr $ad9e		JSR	LAB_AD9E		; evaluate expression
.a9ba	68		pla			PLA				; pop data type flag
.a9bb	2a		rol a			ROL				; string bit into carry
.a9bc	20 90 ad	jsr $ad90		JSR	LAB_AD90		; do type match check
.a9bf	d0 18		bne $a9d9		BNE	LAB_A9D9		; branch if string
.a9c1	68		pla			PLA				; pop integer/float data type flag
.a9c2					LAB_A9C2
.a9c2	10 12		bpl $a9d6		BPL	LAB_A9D6		; branch if float
.a9c4	20 1b bc	jsr $bc1b		JSR	LAB_BC1B		; round FAC1
.a9c7	20 bf b1	jsr $b1bf		JSR	LAB_B1BF		; evaluate integer expression, no sign check
.a9ca	a0 00		ldy #$00		LDY	#$00			; clear index
.a9cc	a5 64		lda $64			LDA	LAB_64		; get FAC1 mantissa 3
.a9ce	91 49		sta ($49),y		STA	(LAB_49),Y		; save as integer variable low byte
.a9d0	c8		iny			INY				; increment index
.a9d1	a5 65		lda $65			LDA	LAB_65		; get FAC1 mantissa 4
.a9d3	91 49		sta ($49),y		STA	(LAB_49),Y		; save as integer variable high byte
.a9d5	60		rts			RTS
.a9d6					LAB_A9D6
.a9d6	4c d0 bb	jmp $bbd0		JMP	LAB_BBD0		; pack FAC1 into variable pointer and return
.a9d9					LAB_A9D9
.a9d9	68		pla			PLA				; dump integer/float data type flag
.a9da					LAB_A9DA
.a9da	a4 4a		ldy $4a			LDY	LAB_4A		; get variable pointer high byte
.a9dc	c0 bf		cpy #$bf		CPY	#>LAB_BF13		; was it TI$ pointer
.a9de	d0 4c		bne $aa2c		BNE	LAB_AA2C		; branch if not
.a9e0	20 a6 b6	jsr $b6a6		JSR	LAB_B6A6		; pop string off descriptor stack, or from top of string
.a9e3	c9 06		cmp #$06		CMP	#$06			; compare length with 6
.a9e5	d0 3d		bne $aa24		BNE	LAB_AA24		; if length not 6 do illegal quantity error then warm start
.a9e7	a0 00		ldy #$00		LDY	#$00			; clear index
.a9e9	84 61		sty $61			STY	LAB_61		; clear FAC1 exponent
.a9eb	84 66		sty $66			STY	LAB_66		; clear FAC1 sign (b7)
.a9ed					LAB_A9ED
.a9ed	84 71		sty $71			STY	LAB_71		; save index
.a9ef	20 1d aa	jsr $aa1d		JSR	LAB_AA1D		; check and evaluate numeric digit
.a9f2	20 e2 ba	jsr $bae2		JSR	LAB_BAE2		; multiply FAC1 by 10
.a9f5	e6 71		inc $71			INC	LAB_71		; increment index
.a9f7	a4 71		ldy $71			LDY	LAB_71		; restore index
.a9f9	20 1d aa	jsr $aa1d		JSR	LAB_AA1D		; check and evaluate numeric digit
.a9fc	20 0c bc	jsr $bc0c		JSR	LAB_BC0C		; round and copy FAC1 to FAC2
.a9ff	aa		tax			TAX				; copy FAC1 exponent
.aa00	f0 05		beq $aa07		BEQ	LAB_AA07		; branch if FAC1 zero
.aa02	e8		inx			INX				; increment index, * 2
.aa03	8a		txa			TXA				; copy back to A
.aa04	20 ed ba	jsr $baed		JSR	LAB_BAED		; FAC1 = (FAC1 + (FAC2 * 2)) * 2 = FAC1 * 6
.aa07					LAB_AA07
.aa07	a4 71		ldy $71			LDY	LAB_71		; get index
.aa09	c8		iny			INY				; increment index
.aa0a	c0 06		cpy #$06		CPY	#$06			; compare index with 6
.aa0c	d0 df		bne $a9ed		BNE	LAB_A9ED		; loop if not 6
.aa0e	20 e2 ba	jsr $bae2		JSR	LAB_BAE2		; multiply FAC1 by 10
.aa11	20 9b bc	jsr $bc9b		JSR	LAB_BC9B		; convert FAC1 floating to fixed
.aa14	a6 64		ldx $64			LDX	LAB_64		; get FAC1 mantissa 3
.aa16	a4 63		ldy $63			LDY	LAB_63		; get FAC1 mantissa 2
.aa18	a5 65		lda $65			LDA	LAB_65		; get FAC1 mantissa 4
.aa1a	4c db ff	jmp $ffdb		JMP	LAB_FFDB		; set real time clock and return
.aa1d					LAB_AA1D
.aa1d	b1 22		lda ($22),y		LDA	(LAB_22),Y		; get byte from string
.aa1f	20 80 00	jsr $0080		JSR	LAB_80		; clear Cb if numeric. this call should be to LAB_84
.aa22	90 03		bcc $aa27		BCC	LAB_AA27		; branch if numeric
.aa24					LAB_AA24
.aa24	4c 48 b2	jmp $b248		JMP	LAB_B248		; do illegal quantity error then warm start
.aa27					LAB_AA27
.aa27	e9 2f		sbc #$2f		SBC	#'0'-1		; subtract $2F + carry to convert ASCII to binary
.aa29	4c 7e bd	jmp $bd7e		JMP	LAB_BD7E		; evaluate new ASCII digit and return
.aa2c					LAB_AA2C
.aa2c	a0 02		ldy #$02		LDY	#$02			; index to string pointer high byte
.aa2e	b1 64		lda ($64),y		LDA	(LAB_64),Y		; get string pointer high byte
.aa30	c5 34		cmp $34			CMP	LAB_34		; compare with bottom of string space high byte
.aa32	90 17		bcc $aa4b		BCC	LAB_AA4B		; branch if string pointer high byte is less than bottom
.aa34	d0 07		bne $aa3d		BNE	LAB_AA3D		; branch if string pointer high byte is greater than
.aa36	88		dey			DEY				; decrement index to string pointer low byte
.aa37	b1 64		lda ($64),y		LDA	(LAB_64),Y		; get string pointer low byte
.aa39	c5 33		cmp $33			CMP	LAB_33		; compare with bottom of string space low byte
.aa3b	90 0e		bcc $aa4b		BCC	LAB_AA4B		; branch if string pointer low byte is less than bottom
.aa3d					LAB_AA3D
.aa3d	a4 65		ldy $65			LDY	LAB_65		; get descriptor pointer high byte
.aa3f	c4 2e		cpy $2e			CPY	LAB_2E		; compare with start of variables high byte
.aa41	90 08		bcc $aa4b		BCC	LAB_AA4B		; branch if less, is on string stack
.aa43	d0 0d		bne $aa52		BNE	LAB_AA52		; if greater make space and copy string
.aa45	a5 64		lda $64			LDA	LAB_64		; get descriptor pointer low byte
.aa47	c5 2d		cmp $2d			CMP	LAB_2D		; compare with start of variables low byte
.aa49	b0 07		bcs $aa52		BCS	LAB_AA52		; if greater or equal make space and copy string
.aa4b					LAB_AA4B
.aa4b	a5 64		lda $64			LDA	LAB_64		; get descriptor pointer low byte
.aa4d	a4 65		ldy $65			LDY	LAB_65		; get descriptor pointer high byte
.aa4f	4c 68 aa	jmp $aa68		JMP	LAB_AA68		; go copy descriptor to variable
.aa52					LAB_AA52
.aa52	a0 00		ldy #$00		LDY	#$00			; clear index
.aa54	b1 64		lda ($64),y		LDA	(LAB_64),Y		; get string length
.aa56	20 75 b4	jsr $b475		JSR	LAB_B475		; copy descriptor pointer and make string space A bytes long
.aa59	a5 50		lda $50			LDA	LAB_50		; copy old descriptor pointer low byte
.aa5b	a4 51		ldy $51			LDY	LAB_51		; copy old descriptor pointer high byte
.aa5d	85 6f		sta $6f			STA	LAB_6F		; save old descriptor pointer low byte
.aa5f	84 70		sty $70			STY	LAB_70		; save old descriptor pointer high byte
.aa61	20 7a b6	jsr $b67a		JSR	LAB_B67A		; copy string from descriptor to utility pointer
.aa64	a9 61		lda #$61		LDA	#<LAB_61		; get descriptor pointer low byte
.aa66	a0 00		ldy #$00		LDY	#>LAB_61		; get descriptor pointer high byte
.aa68					LAB_AA68
.aa68	85 50		sta $50			STA	LAB_50		; save descriptor pointer low byte
.aa6a	84 51		sty $51			STY	LAB_51		; save descriptor pointer high byte
.aa6c	20 db b6	jsr $b6db		JSR	LAB_B6DB		; clean descriptor stack, YA = pointer
.aa6f	a0 00		ldy #$00		LDY	#$00			; clear index
.aa71	b1 50		lda ($50),y		LDA	(LAB_50),Y		; get string length from new descriptor
.aa73	91 49		sta ($49),y		STA	(LAB_49),Y		; copy string length to variable
.aa75	c8		iny			INY				; increment index
.aa76	b1 50		lda ($50),y		LDA	(LAB_50),Y		; get string pointer low byte from new descriptor
.aa78	91 49		sta ($49),y		STA	(LAB_49),Y		; copy string pointer low byte to variable
.aa7a	c8		iny			INY				; increment index
.aa7b	b1 50		lda ($50),y		LDA	(LAB_50),Y		; get string pointer high byte from new descriptor
.aa7d	91 49		sta ($49),y		STA	(LAB_49),Y		; copy string pointer high byte to variable
.aa7f	60		rts			RTS
.aa80					LAB_AA80
.aa80	20 86 aa	jsr $aa86		JSR	LAB_AA86		; perform CMD
.aa83	4c b5 ab	jmp $abb5		JMP	LAB_ABB5		; close input and output channels and return
.aa86					LAB_AA86
.aa86	20 9e b7	jsr $b79e		JSR	LAB_B79E		; get byte parameter
.aa89	f0 05		beq $aa90		BEQ	LAB_AA90		; branch if following byte is ":" or [EOT]
.aa8b	a9 2c		lda #$2c		LDA	#','			; set ","
.aa8d	20 ff ae	jsr $aeff		JSR	LAB_AEFF		; scan for CHR$(A), else do syntax error then warm start
.aa90					LAB_AA90
.aa90	08		php			PHP				; save status
.aa91	86 13		stx $13			STX	LAB_13		; set current I/O channel
.aa93	20 18 e1	jsr $e118		JSR	LAB_E118		; open channel for output with error check
.aa96	28		plp			PLP				; restore status
.aa97	4c a0 aa	jmp $aaa0		JMP	LAB_AAA0		; perform PRINT
.aa9a					LAB_AA9A
.aa9a	20 21 ab	jsr $ab21		JSR	LAB_AB21		; print string from utility pointer
.aa9d					LAB_AA9D
.aa9d	20 79 00	jsr $0079		JSR	LAB_0079		; scan memory
.aaa0					LAB_AAA0
.aaa0	f0 35		beq $aad7		BEQ	LAB_AAD7		; if nothing following just print CR/LF
.aaa2					LAB_AAA2
.aaa2	f0 43		beq $aae7		BEQ	LAB_AAE7		; exit if nothing following, end of PRINT branch
.aaa4	c9 a3		cmp #$a3		CMP	#TK_TAB		; compare with token for TAB(
.aaa6	f0 50		beq $aaf8		BEQ	LAB_AAF8		; if TAB( go handle it
.aaa8	c9 a6		cmp #$a6		CMP	#TK_SPC		; compare with token for SPC(
.aaaa	18		clc			CLC				; flag SPC(
.aaab	f0 4b		beq $aaf8		BEQ	LAB_AAF8		; if SPC( go handle it
.aaad	c9 2c		cmp #$2c		CMP	#','			; compare with ","
.aaaf	f0 37		beq $aae8		BEQ	LAB_AAE8		; if "," go skip to the next TAB position
.aab1	c9 3b		cmp #$3b		CMP	#';'			; compare with ";"
.aab3	f0 5e		beq $ab13		BEQ	LAB_AB13		; if ";" go continue the print loop
.aab5	20 9e ad	jsr $ad9e		JSR	LAB_AD9E		; evaluate expression
.aab8	24 0d		bit $0d			BIT	LAB_0D		; test data type flag, $FF = string, $00 = numeric
.aaba	30 de		bmi $aa9a		BMI	LAB_AA9A		; if string go print string, scan memory and continue PRINT
.aabc	20 dd bd	jsr $bddd		JSR	LAB_BDDD		; convert FAC1 to ASCII string result in (AY)
.aabf	20 87 b4	jsr $b487		JSR	LAB_B487		; print " terminated string to utility pointer
.aac2	20 21 ab	jsr $ab21		JSR	LAB_AB21		; print string from utility pointer
.aac5	20 3b ab	jsr $ab3b		JSR	LAB_AB3B		; print [SPACE] or [CURSOR RIGHT]
.aac8	d0 d3		bne $aa9d		BNE	LAB_AA9D		; go scan memory and continue PRINT, branch always
.aaca					LAB_AACA
.aaca	a9 00		lda #$00		LDA	#$00			; clear A
.aacc	9d 00 02	sta $0200,x		STA	LAB_0200,X		; clear first byte of input buffer
.aacf	a2 ff		ldx #$ff		LDX	#<LAB_01FF		; LAB_0200 - 1 low byte
.aad1	a0 01		ldy #$01		LDY	#>LAB_01FF		; LAB_0200 - 1 high byte
.aad3	a5 13		lda $13			LDA	LAB_13		; get current I/O channel
.aad5	d0 10		bne $aae7		BNE	LAB_AAE7		; exit if not default channel
.aad7					LAB_AAD7
.aad7	a9 0d		lda #$0d		LDA	#$0D			; set [CR]
.aad9	20 47 ab	jsr $ab47		JSR	LAB_AB47		; print the character
.aadc	24 13		bit $13			BIT	LAB_13		; test current I/O channel
.aade	10 05		bpl $aae5		BPL	LAB_AAE5		; if ?? toggle A, EOR #$FF and return
.aae0	a9 0a		lda #$0a		LDA	#$0A			; set [LF]
.aae2	20 47 ab	jsr $ab47		JSR	LAB_AB47		; print the character
.aae5					LAB_AAE5
.aae5	49 ff		eor #$ff		EOR	#$FF			; invert A
.aae7					LAB_AAE7
.aae7	60		rts			RTS
.aae8					LAB_AAE8
.aae8	38		sec			SEC				; set Cb for read cursor position
.aae9	20 f0 ff	jsr $fff0		JSR	LAB_FFF0		; read/set X,Y cursor position
.aaec	98		tya			TYA				; copy cursor Y
.aaed	38		sec			SEC				; set carry for subtract
.aaee					LAB_AAEE
.aaee	e9 0a		sbc #$0a		SBC	#$0A			; subtract one TAB length
.aaf0	b0 fc		bcs $aaee		BCS	LAB_AAEE		; loop if result was +ve
.aaf2	49 ff		eor #$ff		EOR	#$FF			; complement it
.aaf4	69 01		adc #$01		ADC	#$01			; +1, twos complement
.aaf6	d0 16		bne $ab0e		BNE	LAB_AB0E		; always print A spaces, result is never $00
.aaf8					LAB_AAF8
.aaf8	08		php			PHP				; save TAB( or SPC( status
.aaf9	38		sec			SEC				; set Cb for read cursor position
.aafa	20 f0 ff	jsr $fff0		JSR	LAB_FFF0		; read/set X,Y cursor position
.aafd	84 09		sty $09			STY	LAB_09		; save current cursor position
.aaff	20 9b b7	jsr $b79b		JSR	LAB_B79B		; scan and get byte parameter
.ab02	c9 29		cmp #$29		CMP	#')'			; compare with ")"
.ab04	d0 59		bne $ab5f		BNE	LAB_AB5F		; if not ")" do syntax error
.ab06	28		plp			PLP				; restore TAB( or SPC( status
.ab07	90 06		bcc $ab0f		BCC	LAB_AB0F		; branch if was SPC(
.ab09	8a		txa			TXA				; copy TAB() byte to A
.ab0a	e5 09		sbc $09			SBC	LAB_09		; subtract current cursor position
.ab0c	90 05		bcc $ab13		BCC	LAB_AB13		; go loop for next if already past requited position
.ab0e					LAB_AB0E
.ab0e	aa		tax			TAX				; copy [SPACE] count to X
.ab0f					LAB_AB0F
.ab0f	e8		inx			INX				; increment count
.ab10					LAB_AB10
.ab10	ca		dex			DEX				; decrement count
.ab11	d0 06		bne $ab19		BNE	LAB_AB19		; branch if count was not zero
.ab13					LAB_AB13
.ab13	20 73 00	jsr $0073		JSR	LAB_0073		; increment and scan memory
.ab16	4c a2 aa	jmp $aaa2		JMP	LAB_AAA2		; continue print loop
.ab19					LAB_AB19
.ab19	20 3b ab	jsr $ab3b		JSR	LAB_AB3B		; print [SPACE] or [CURSOR RIGHT]
.ab1c	d0 f2		bne $ab10		BNE	LAB_AB10		; loop, branch always
.ab1e					LAB_AB1E
.ab1e	20 87 b4	jsr $b487		JSR	LAB_B487		; print " terminated string to utility pointer
.ab21					LAB_AB21
.ab21	20 a6 b6	jsr $b6a6		JSR	LAB_B6A6		; pop string off descriptor stack, or from top of string
.ab24	aa		tax			TAX				; copy length
.ab25	a0 00		ldy #$00		LDY	#$00			; clear index
.ab27	e8		inx			INX				; increment length, for pre decrement loop
.ab28					LAB_AB28
.ab28	ca		dex			DEX				; decrement length
.ab29	f0 bc		beq $aae7		BEQ	LAB_AAE7		; exit if done
.ab2b	b1 22		lda ($22),y		LDA	(LAB_22),Y		; get byte from string
.ab2d	20 47 ab	jsr $ab47		JSR	LAB_AB47		; print the character
.ab30	c8		iny			INY				; increment index
.ab31	c9 0d		cmp #$0d		CMP	#$0D			; compare byte with [CR]
.ab33	d0 f3		bne $ab28		BNE	LAB_AB28		; loop if not [CR]
.ab35	20 e5 aa	jsr $aae5		JSR	LAB_AAE5		; toggle A, EOR #$FF. what is the point of this ??
.ab38	4c 28 ab	jmp $ab28		JMP	LAB_AB28		; loop
.ab3b					LAB_AB3B
.ab3b	a5 13		lda $13			LDA	LAB_13		; get current I/O channel
.ab3d	f0 03		beq $ab42		BEQ	LAB_AB42		; if default channel go output [CURSOR RIGHT]
.ab3f	a9 20		lda #$20		LDA	#' '			; else output [SPACE]
>ab41	2c					.byte	$2C			; makes next line BIT LAB_1DA9
.ab42					LAB_AB42
.ab42	a9 1d		lda #$1d		LDA	#$1D			; set [CURSOR RIGHT]
>ab44	2c					.byte	$2C			; makes next line BIT LAB_3FA9
.ab45					LAB_AB45
.ab45	a9 3f		lda #$3f		LDA	#'?'			; set "?"
.ab47					LAB_AB47
.ab47	20 0c e1	jsr $e10c		JSR	LAB_E10C		; output character to channel with error check
.ab4a	29 ff		and #$ff		AND	#$FF			; set the flags on A
.ab4c	60		rts			RTS
.ab4d					LAB_AB4D
.ab4d	a5 11		lda $11			LDA	LAB_11		; get INPUT mode flag, $00 = INPUT, $40 = GET, $98 = READ
.ab4f	f0 11		beq $ab62		BEQ	LAB_AB62		; branch if INPUT
.ab51	30 04		bmi $ab57		BMI	LAB_AB57		; branch if READ
.ab53	a0 ff		ldy #$ff		LDY	#$FF			; set current line high byte to -1, indicate immediate mode
.ab55	d0 04		bne $ab5b		BNE	LAB_AB5B		; branch always
.ab57					LAB_AB57
.ab57	a5 3f		lda $3f			LDA	LAB_3F		; get current DATA line number low byte
.ab59	a4 40		ldy $40			LDY	LAB_40		; get current DATA line number high byte
.ab5b					LAB_AB5B
.ab5b	85 39		sta $39			STA	LAB_39		; set current line number low byte
.ab5d	84 3a		sty $3a			STY	LAB_3A		; set current line number high byte
.ab5f					LAB_AB5F
.ab5f	4c 08 af	jmp $af08		JMP	LAB_AF08		; do syntax error then warm start
.ab62					LAB_AB62
.ab62	a5 13		lda $13			LDA	LAB_13		; get current I/O channel
.ab64	f0 05		beq $ab6b		BEQ	LAB_AB6B		; branch if default channel
.ab66	a2 18		ldx #$18		LDX	#$18			; else error $18, file data error
.ab68	4c 37 a4	jmp $a437		JMP	LAB_A437		; do error #X then warm start
.ab6b					LAB_AB6B
.ab6b	a9 0c		lda #$0c		LDA	#<LAB_AD0C		; set "?REDO FROM START" pointer low byte
.ab6d	a0 ad		ldy #$ad		LDY	#>LAB_AD0C		; set "?REDO FROM START" pointer high byte
.ab6f	20 1e ab	jsr $ab1e		JSR	LAB_AB1E		; print null terminated string
.ab72	a5 3d		lda $3d			LDA	LAB_3D		; get continue pointer low byte
.ab74	a4 3e		ldy $3e			LDY	LAB_3E		; get continue pointer high byte
.ab76	85 7a		sta $7a			STA	LAB_7A		; save BASIC execute pointer low byte
.ab78	84 7b		sty $7b			STY	LAB_7B		; save BASIC execute pointer high byte
.ab7a	60		rts			RTS
.ab7b					LAB_AB7B
.ab7b	20 a6 b3	jsr $b3a6		JSR	LAB_B3A6		; check not Direct, back here if ok
.ab7e	c9 23		cmp #$23		CMP	#'#'			; compare with "#"
.ab80	d0 10		bne $ab92		BNE	LAB_AB92		; branch if not GET#
.ab82	20 73 00	jsr $0073		JSR	LAB_0073		; increment and scan memory
.ab85	20 9e b7	jsr $b79e		JSR	LAB_B79E		; get byte parameter
.ab88	a9 2c		lda #$2c		LDA	#','			; set ","
.ab8a	20 ff ae	jsr $aeff		JSR	LAB_AEFF		; scan for CHR$(A), else do syntax error then warm start
.ab8d	86 13		stx $13			STX	LAB_13		; set current I/O channel
.ab8f	20 1e e1	jsr $e11e		JSR	LAB_E11E		; open channel for input with error check
.ab92					LAB_AB92
.ab92	a2 01		ldx #$01		LDX	#<LAB_0201		; set pointer low byte
.ab94	a0 02		ldy #$02		LDY	#>LAB_0201		; set pointer high byte
.ab96	a9 00		lda #$00		LDA	#$00			; clear A
.ab98	8d 01 02	sta $0201		STA	LAB_0201		; ensure null terminator
.ab9b	a9 40		lda #$40		LDA	#$40			; input mode = GET
.ab9d	20 0f ac	jsr $ac0f		JSR	LAB_AC0F		; perform the GET part of READ
.aba0	a6 13		ldx $13			LDX	LAB_13		; get current I/O channel
.aba2	d0 13		bne $abb7		BNE	LAB_ABB7		; if not default channel go do channel close and return
.aba4	60		rts			RTS
.aba5					LAB_ABA5
.aba5	20 9e b7	jsr $b79e		JSR	LAB_B79E		; get byte parameter
.aba8	a9 2c		lda #$2c		LDA	#','			; set ","
.abaa	20 ff ae	jsr $aeff		JSR	LAB_AEFF		; scan for CHR$(A), else do syntax error then warm start
.abad	86 13		stx $13			STX	LAB_13		; set current I/O channel
.abaf	20 1e e1	jsr $e11e		JSR	LAB_E11E		; open channel for input with error check
.abb2	20 ce ab	jsr $abce		JSR	LAB_ABCE		; perform INPUT with no prompt string
.abb5					LAB_ABB5
.abb5	a5 13		lda $13			LDA	LAB_13		; get current I/O channel
.abb7					LAB_ABB7
.abb7	20 cc ff	jsr $ffcc		JSR	LAB_FFCC		; close input and output channels
.abba	a2 00		ldx #$00		LDX	#$00			; clear X
.abbc	86 13		stx $13			STX	LAB_13		; clear current I/O channel, flag default
.abbe	60		rts			RTS
.abbf					LAB_ABBF
.abbf	c9 22		cmp #$22		CMP	#$22			; compare next byte with open quote
.abc1	d0 0b		bne $abce		BNE	LAB_ABCE		; if no prompt string just do INPUT
.abc3	20 bd ae	jsr $aebd		JSR	LAB_AEBD		; print "..." string
.abc6	a9 3b		lda #$3b		LDA	#';'			; load A with ";"
.abc8	20 ff ae	jsr $aeff		JSR	LAB_AEFF		; scan for CHR$(A), else do syntax error then warm start
.abcb	20 21 ab	jsr $ab21		JSR	LAB_AB21		; print string from utility pointer
.abce					LAB_ABCE
.abce	20 a6 b3	jsr $b3a6		JSR	LAB_B3A6		; check not Direct, back here if ok
.abd1	a9 2c		lda #$2c		LDA	#','			; set ","
.abd3	8d ff 01	sta $01ff		STA	LAB_01FF		; save to start of buffer - 1
.abd6					LAB_ABD6
.abd6	20 f9 ab	jsr $abf9		JSR	LAB_ABF9		; print "? " and get BASIC input
.abd9	a5 13		lda $13			LDA	LAB_13		; get current I/O channel
.abdb	f0 0d		beq $abea		BEQ	LAB_ABEA		; branch if default I/O channel
.abdd	20 b7 ff	jsr $ffb7		JSR	LAB_FFB7		; read I/O status word
.abe0	29 02		and #$02		AND	#$02			; mask no DSR/timeout
.abe2	f0 06		beq $abea		BEQ	LAB_ABEA		; branch if not error
.abe4	20 b5 ab	jsr $abb5		JSR	LAB_ABB5		; close input and output channels
.abe7	4c f8 a8	jmp $a8f8		JMP	LAB_A8F8		; perform DATA
.abea					LAB_ABEA
.abea	ad 00 02	lda $0200		LDA	LAB_0200		; get first byte in input buffer
.abed	d0 1e		bne $ac0d		BNE	LAB_AC0D		; branch if not null
.abef	a5 13		lda $13			LDA	LAB_13		; get current I/O channel
.abf1	d0 e3		bne $abd6		BNE	LAB_ABD6		; if not default channel go get BASIC input
.abf3	20 06 a9	jsr $a906		JSR	LAB_A906		; scan for next BASIC statement ([:] or [EOL])
.abf6	4c fb a8	jmp $a8fb		JMP	LAB_A8FB		; add Y to the BASIC execute pointer and return
.abf9					LAB_ABF9
.abf9	a5 13		lda $13			LDA	LAB_13		; get current I/O channel
.abfb	d0 06		bne $ac03		BNE	LAB_AC03		; skip "?" prompt if not default channel
.abfd	20 45 ab	jsr $ab45		JSR	LAB_AB45		; print "?"
.ac00	20 3b ab	jsr $ab3b		JSR	LAB_AB3B		; print [SPACE] or [CURSOR RIGHT]
.ac03					LAB_AC03
.ac03	4c 60 a5	jmp $a560		JMP	LAB_A560		; call for BASIC input and return
.ac06					LAB_AC06
.ac06	a6 41		ldx $41			LDX	LAB_41		; get DATA pointer low byte
.ac08	a4 42		ldy $42			LDY	LAB_42		; get DATA pointer high byte
.ac0a	a9 98		lda #$98		LDA	#$98			; set input mode = READ
>ac0c	2c					.byte	$2C			; makes next line BIT LAB_00A9
.ac0d					LAB_AC0D
.ac0d	a9 00		lda #$00		LDA	#$00			; set input mode = INPUT
.ac0f					LAB_AC0F
.ac0f	85 11		sta $11			STA	LAB_11		; set input mode flag, $00 = INPUT, $40 = GET, $98 = READ
.ac11	86 43		stx $43			STX	LAB_43		; save READ pointer low byte
.ac13	84 44		sty $44			STY	LAB_44		; save READ pointer high byte
.ac15					LAB_AC15
.ac15	20 8b b0	jsr $b08b		JSR	LAB_B08B		; get variable address
.ac18	85 49		sta $49			STA	LAB_49		; save address low byte
.ac1a	84 4a		sty $4a			STY	LAB_4A		; save address high byte
.ac1c	a5 7a		lda $7a			LDA	LAB_7A		; get BASIC execute pointer low byte
.ac1e	a4 7b		ldy $7b			LDY	LAB_7B		; get BASIC execute pointer high byte
.ac20	85 4b		sta $4b			STA	LAB_4B		; save BASIC execute pointer low byte
.ac22	84 4c		sty $4c			STY	LAB_4C		; save BASIC execute pointer high byte
.ac24	a6 43		ldx $43			LDX	LAB_43		; get READ pointer low byte
.ac26	a4 44		ldy $44			LDY	LAB_44		; get READ pointer high byte
.ac28	86 7a		stx $7a			STX	LAB_7A		; save as BASIC execute pointer low byte
.ac2a	84 7b		sty $7b			STY	LAB_7B		; save as BASIC execute pointer high byte
.ac2c	20 79 00	jsr $0079		JSR	LAB_0079		; scan memory
.ac2f	d0 20		bne $ac51		BNE	LAB_AC51		; branch if not null
.ac31	24 11		bit $11			BIT	LAB_11		; test input mode flag, $00 = INPUT, $40 = GET, $98 = READ
.ac33	50 0c		bvc $ac41		BVC	LAB_AC41		; branch if not GET
.ac35	20 24 e1	jsr $e124		JSR	LAB_E124		; get character from input device with error check
.ac38	8d 00 02	sta $0200		STA	LAB_0200		; save to buffer
.ac3b	a2 ff		ldx #$ff		LDX	#<LAB_01FF		; set pointer low byte
.ac3d	a0 01		ldy #$01		LDY	#>LAB_01FF		; set pointer high byte
.ac3f	d0 0c		bne $ac4d		BNE	LAB_AC4D		; go interpret single character
.ac41					LAB_AC41
.ac41	30 75		bmi $acb8		BMI	LAB_ACB8		; branch if READ
.ac43	a5 13		lda $13			LDA	LAB_13		; get current I/O channel
.ac45	d0 03		bne $ac4a		BNE	LAB_AC4A		; skip "?" prompt if not default channel
.ac47	20 45 ab	jsr $ab45		JSR	LAB_AB45		; print "?"
.ac4a					LAB_AC4A
.ac4a	20 f9 ab	jsr $abf9		JSR	LAB_ABF9		; print "? " and get BASIC input
.ac4d					LAB_AC4D
.ac4d	86 7a		stx $7a			STX	LAB_7A		; save BASIC execute pointer low byte
.ac4f	84 7b		sty $7b			STY	LAB_7B		; save BASIC execute pointer high byte
.ac51					LAB_AC51
.ac51	20 73 00	jsr $0073		JSR	LAB_0073		; increment and scan memory, execute pointer now points to
.ac54	24 0d		bit $0d			BIT	LAB_0D		; test data type flag, $FF = string, $00 = numeric
.ac56	10 31		bpl $ac89		BPL	LAB_AC89		; branch if numeric
.ac58	24 11		bit $11			BIT	LAB_11		; test INPUT mode flag, $00 = INPUT, $40 = GET, $98 = READ
.ac5a	50 09		bvc $ac65		BVC	LAB_AC65		; branch if not GET
.ac5c	e8		inx			INX				; clear X ??
.ac5d	86 7a		stx $7a			STX	LAB_7A		; save BASIC execute pointer low byte
.ac5f	a9 00		lda #$00		LDA	#$00			; clear A
.ac61	85 07		sta $07			STA	LAB_07		; clear search character
.ac63	f0 0c		beq $ac71		BEQ	LAB_AC71		; branch always
.ac65					LAB_AC65
.ac65	85 07		sta $07			STA	LAB_07		; save search character
.ac67	c9 22		cmp #$22		CMP	#$22			; compare with "
.ac69	f0 07		beq $ac72		BEQ	LAB_AC72		; branch if quote
.ac6b	a9 3a		lda #$3a		LDA	#':'			; set ":"
.ac6d	85 07		sta $07			STA	LAB_07		; set search character
.ac6f	a9 2c		lda #$2c		LDA	#','			; set ","
.ac71					LAB_AC71
.ac71	18		clc			CLC				; clear carry for add
.ac72					LAB_AC72
.ac72	85 08		sta $08			STA	LAB_08		; set scan quotes flag
.ac74	a5 7a		lda $7a			LDA	LAB_7A		; get BASIC execute pointer low byte
.ac76	a4 7b		ldy $7b			LDY	LAB_7B		; get BASIC execute pointer high byte
.ac78	69 00		adc #$00		ADC	#$00			; add to pointer low byte. this add increments the pointer
.ac7a	90 01		bcc $ac7d		BCC	LAB_AC7D		; branch if no rollover
.ac7c	c8		iny			INY				; else increment pointer high byte
.ac7d					LAB_AC7D
.ac7d	20 8d b4	jsr $b48d		JSR	LAB_B48D		; print string to utility pointer
.ac80	20 e2 b7	jsr $b7e2		JSR	LAB_B7E2		; restore BASIC execute pointer from temp
.ac83	20 da a9	jsr $a9da		JSR	LAB_A9DA		; perform string LET
.ac86	4c 91 ac	jmp $ac91		JMP	LAB_AC91		; continue processing command
.ac89					LAB_AC89
.ac89	20 f3 bc	jsr $bcf3		JSR	LAB_BCF3		; get FAC1 from string
.ac8c	a5 0e		lda $0e			LDA	LAB_0E		; get data type flag, $80 = integer, $00 = float
.ac8e	20 c2 a9	jsr $a9c2		JSR	LAB_A9C2		; assign value to numeric variable
.ac91					LAB_AC91
.ac91	20 79 00	jsr $0079		JSR	LAB_0079		; scan memory
.ac94	f0 07		beq $ac9d		BEQ	LAB_AC9D		; branch if ":" or [EOL]
.ac96	c9 2c		cmp #$2c		CMP	#','			; comparte with ","
.ac98	f0 03		beq $ac9d		BEQ	LAB_AC9D		; branch if ","
.ac9a	4c 4d ab	jmp $ab4d		JMP	LAB_AB4D		; else go do bad input routine
.ac9d					LAB_AC9D
.ac9d	a5 7a		lda $7a			LDA	LAB_7A		; get BASIC execute pointer low byte
.ac9f	a4 7b		ldy $7b			LDY	LAB_7B		; get BASIC execute pointer high byte
.aca1	85 43		sta $43			STA	LAB_43		; save READ pointer low byte
.aca3	84 44		sty $44			STY	LAB_44		; save READ pointer high byte
.aca5	a5 4b		lda $4b			LDA	LAB_4B		; get saved BASIC execute pointer low byte
.aca7	a4 4c		ldy $4c			LDY	LAB_4C		; get saved BASIC execute pointer high byte
.aca9	85 7a		sta $7a			STA	LAB_7A		; restore BASIC execute pointer low byte
.acab	84 7b		sty $7b			STY	LAB_7B		; restore BASIC execute pointer high byte
.acad	20 79 00	jsr $0079		JSR	LAB_0079		; scan memory
.acb0	f0 2d		beq $acdf		BEQ	LAB_ACDF		; branch if ":" or [EOL]
.acb2	20 fd ae	jsr $aefd		JSR	LAB_AEFD		; scan for ",", else do syntax error then warm start
.acb5	4c 15 ac	jmp $ac15		JMP	LAB_AC15		; go READ or INPUT next variable from list
.acb8					LAB_ACB8
.acb8	20 06 a9	jsr $a906		JSR	LAB_A906		; scan for next BASIC statement ([:] or [EOL])
.acbb	c8		iny			INY				; increment index to next byte
.acbc	aa		tax			TAX				; copy byte to X
.acbd	d0 12		bne $acd1		BNE	LAB_ACD1		; branch if ":"
.acbf	a2 0d		ldx #$0d		LDX	#$0D			; else set error $0D, out of data error
.acc1	c8		iny			INY				; increment index to next line pointer high byte
.acc2	b1 7a		lda ($7a),y		LDA	(LAB_7A),Y		; get next line pointer high byte
.acc4	f0 6c		beq $ad32		BEQ	LAB_AD32		; branch if program end, eventually does error X
.acc6	c8		iny			INY				; increment index
.acc7	b1 7a		lda ($7a),y		LDA	(LAB_7A),Y		; get next line # low byte
.acc9	85 3f		sta $3f			STA	LAB_3F		; save current DATA line low byte
.accb	c8		iny			INY				; increment index
.accc	b1 7a		lda ($7a),y		LDA	(LAB_7A),Y		; get next line # high byte
.acce	c8		iny			INY				; increment index
.accf	85 40		sta $40			STA	LAB_40		; save current DATA line high byte
.acd1					LAB_ACD1
.acd1	20 fb a8	jsr $a8fb		JSR	LAB_A8FB		; add Y to the BASIC execute pointer
.acd4	20 79 00	jsr $0079		JSR	LAB_0079		; scan memory
.acd7	aa		tax			TAX				; copy the byte
.acd8	e0 83		cpx #$83		CPX	#TK_DATA		; compare it with token for DATA
.acda	d0 dc		bne $acb8		BNE	LAB_ACB8		; loop if not DATA
.acdc	4c 51 ac	jmp $ac51		JMP	LAB_AC51		; continue evaluating READ
.acdf					LAB_ACDF
.acdf	a5 43		lda $43			LDA	LAB_43		; get READ pointer low byte
.ace1	a4 44		ldy $44			LDY	LAB_44		; get READ pointer high byte
.ace3	a6 11		ldx $11			LDX	LAB_11		; get INPUT mode flag, $00 = INPUT, $40 = GET, $98 = READ
.ace5	10 03		bpl $acea		BPL	LAB_ACEA		; branch if INPUT or GET
.ace7	4c 27 a8	jmp $a827		JMP	LAB_A827		; else set data pointer and exit
.acea					LAB_ACEA
.acea	a0 00		ldy #$00		LDY	#$00			; clear index
.acec	b1 43		lda ($43),y		LDA	(LAB_43),Y		; get READ byte
.acee	f0 0b		beq $acfb		BEQ	LAB_ACFB		; exit if [EOL]
.acf0	a5 13		lda $13			LDA	LAB_13		; get current I/O channel
.acf2	d0 07		bne $acfb		BNE	LAB_ACFB		; exit if not default channel
.acf4	a9 fc		lda #$fc		LDA	#<LAB_ACFC		; set "?EXTRA IGNORED" pointer low byte
.acf6	a0 ac		ldy #$ac		LDY	#>LAB_ACFC		; set "?EXTRA IGNORED" pointer high byte
.acf8	4c 1e ab	jmp $ab1e		JMP	LAB_AB1E		; print null terminated string
.acfb					LAB_ACFB
.acfb	60		rts			RTS
.acfc					LAB_ACFC
>acfc	3f 45 58 54 52 41 20 49			.text	"?EXTRA IGNORED",$0D,$00
>ad04	47 4e 4f 52 45 44 0d 00
.ad0c					LAB_AD0C
>ad0c	3f 52 45 44 4f 20 46 52			.text	"?REDO FROM START",$0D,$00
>ad14	4f 4d 20 53 54 41 52 54 0d 00
.ad1e					LAB_AD1E
.ad1e	d0 04		bne $ad24		BNE	LAB_AD24		; branch if NEXT variable
.ad20	a0 00		ldy #$00		LDY	#$00			; else clear Y
.ad22	f0 03		beq $ad27		BEQ	LAB_AD27		; branch always
.ad24					LAB_AD24
.ad24	20 8b b0	jsr $b08b		JSR	LAB_B08B		; get variable address
.ad27					LAB_AD27
.ad27	85 49		sta $49			STA	LAB_49		; save FOR/NEXT variable pointer low byte
.ad29	84 4a		sty $4a			STY	LAB_4A		; save FOR/NEXT variable pointer high byte
.ad2b	20 8a a3	jsr $a38a		JSR	LAB_A38A		; search the stack for FOR or GOSUB activity
.ad2e	f0 05		beq $ad35		BEQ	LAB_AD35		; branch if FOR, this variable, found
.ad30	a2 0a		ldx #$0a		LDX	#$0A			; else set error $0A, next without for error
.ad32					LAB_AD32
.ad32	4c 37 a4	jmp $a437		JMP	LAB_A437		; do error #X then warm start
.ad35					LAB_AD35
.ad35	9a		txs			TXS				; update stack pointer
.ad36	8a		txa			TXA				; copy stack pointer
.ad37	18		clc			CLC				; clear carry for add
.ad38	69 04		adc #$04		ADC	#$04			; point to STEP value
.ad3a	48		pha			PHA				; save it
.ad3b	69 06		adc #$06		ADC	#$06			; point to TO value
.ad3d	85 24		sta $24			STA	LAB_24		; save pointer to TO variable for compare
.ad3f	68		pla			PLA				; restore pointer to STEP value
.ad40	a0 01		ldy #$01		LDY	#$01			; point to stack page
.ad42	20 a2 bb	jsr $bba2		JSR	LAB_BBA2		; unpack memory (AY) into FAC1
.ad45	ba		tsx			TSX				; get stack pointer back
.ad46	bd 09 01	lda $0109,x		LDA	LAB_0100+9,X	; get step sign
.ad49	85 66		sta $66			STA	LAB_66		; save FAC1 sign (b7)
.ad4b	a5 49		lda $49			LDA	LAB_49		; get FOR/NEXT variable pointer low byte
.ad4d	a4 4a		ldy $4a			LDY	LAB_4A		; get FOR/NEXT variable pointer high byte
.ad4f	20 67 b8	jsr $b867		JSR	LAB_B867		; add FOR variable to FAC1
.ad52	20 d0 bb	jsr $bbd0		JSR	LAB_BBD0		; pack FAC1 into FOR variable
.ad55	a0 01		ldy #$01		LDY	#$01			; point to stack page
.ad57	20 5d bc	jsr $bc5d		JSR	LAB_BC5D		; compare FAC1 with TO value
.ad5a	ba		tsx			TSX				; get stack pointer back
.ad5b	38		sec			SEC				; set carry for subtract
.ad5c	fd 09 01	sbc $0109,x		SBC	LAB_0100+9,X	; subtract step sign
.ad5f	f0 17		beq $ad78		BEQ	LAB_AD78		; branch if =, loop complete
.ad61	bd 0f 01	lda $010f,x		LDA	LAB_0100+$0F,X	; get FOR line low byte
.ad64	85 39		sta $39			STA	LAB_39		; save current line number low byte
.ad66	bd 10 01	lda $0110,x		LDA	LAB_0110,X		; get FOR line high byte
.ad69	85 3a		sta $3a			STA	LAB_3A		; save current line number high byte
.ad6b	bd 12 01	lda $0112,x		LDA	LAB_0112,X		; get BASIC execute pointer low byte
.ad6e	85 7a		sta $7a			STA	LAB_7A		; save BASIC execute pointer low byte
.ad70	bd 11 01	lda $0111,x		LDA	LAB_0111,X		; get BASIC execute pointer high byte
.ad73	85 7b		sta $7b			STA	LAB_7B		; save BASIC execute pointer high byte
.ad75					LAB_AD75
.ad75	4c ae a7	jmp $a7ae		JMP	LAB_A7AE		; go do interpreter inner loop
.ad78					LAB_AD78
.ad78	8a		txa			TXA				; stack copy to A
.ad79	69 11		adc #$11		ADC	#$11			; add $12, $11 + carry, to dump FOR structure
.ad7b	aa		tax			TAX				; copy back to index
.ad7c	9a		txs			TXS				; copy to stack pointer
.ad7d	20 79 00	jsr $0079		JSR	LAB_0079		; scan memory
.ad80	c9 2c		cmp #$2c		CMP	#','			; compare with ","
.ad82	d0 f1		bne $ad75		BNE	LAB_AD75		; if not "," go do interpreter inner loop
.ad84	20 73 00	jsr $0073		JSR	LAB_0073		; increment and scan memory
.ad87	20 24 ad	jsr $ad24		JSR	LAB_AD24		; do NEXT variable
.ad8a					LAB_AD8A
.ad8a	20 9e ad	jsr $ad9e		JSR	LAB_AD9E		; evaluate expression
.ad8d					LAB_AD8D
.ad8d	18		clc			CLC
>ad8e	24					.byte	$24			; makes next line BIT LAB_38
.ad8f					LAB_AD8F
.ad8f	38		sec			SEC				; destination is string
.ad90					LAB_AD90
.ad90	24 0d		bit $0d			BIT	LAB_0D		; test data type flag, $FF = string, $00 = numeric
.ad92	30 03		bmi $ad97		BMI	LAB_AD97		; branch if string
.ad94	b0 03		bcs $ad99		BCS	LAB_AD99		; if destiantion is numeric do type missmatch error
.ad96					LAB_AD96
.ad96	60		rts			RTS
.ad97					LAB_AD97
.ad97	b0 fd		bcs $ad96		BCS	LAB_AD96		; exit if destination is string
.ad99					LAB_AD99
.ad99	a2 16		ldx #$16		LDX	#$16			; error code $16, type missmatch error
.ad9b	4c 37 a4	jmp $a437		JMP	LAB_A437		; do error #X then warm start
.ad9e					LAB_AD9E
.ad9e	a6 7a		ldx $7a			LDX	LAB_7A		; get BASIC execute pointer low byte
.ada0	d0 02		bne $ada4		BNE	LAB_ADA4		; skip next if not zero
.ada2	c6 7b		dec $7b			DEC	LAB_7B		; else decrement BASIC execute pointer high byte
.ada4					LAB_ADA4
.ada4	c6 7a		dec $7a			DEC	LAB_7A		; decrement BASIC execute pointer low byte
.ada6	a2 00		ldx #$00		LDX	#$00			; set null precedence, flag done
>ada8	24					.byte	$24			; makes next line BIT LAB_48
.ada9					LAB_ADA9
.ada9	48		pha			PHA				; push compare evaluation byte if branch to here
.adaa	8a		txa			TXA				; copy precedence byte
.adab	48		pha			PHA				; push precedence byte
.adac	a9 01		lda #$01		LDA	#$01			; 2 bytes
.adae	20 fb a3	jsr $a3fb		JSR	LAB_A3FB		; check room on stack for A*2 bytes
.adb1	20 83 ae	jsr $ae83		JSR	LAB_AE83		; get value from line
.adb4	a9 00		lda #$00		LDA	#$00			; clear A
.adb6	85 4d		sta $4d			STA	LAB_4D		; clear comparrison evaluation flag
.adb8					LAB_ADB8
.adb8	20 79 00	jsr $0079		JSR	LAB_0079		; scan memory
.adbb					LAB_ADBB
.adbb	38		sec			SEC				; set carry for subtract
.adbc	e9 b1		sbc #$b1		SBC	#TK_GT		; subtract the token for ">"
.adbe	90 17		bcc $add7		BCC	LAB_ADD7		; branch if < ">"
.adc0	c9 03		cmp #$03		CMP	#$03			; compare with ">" to +3
.adc2	b0 13		bcs $add7		BCS	LAB_ADD7		; branch if >= 3
.adc4	c9 01		cmp #$01		CMP	#$01			; compare with token for =
.adc6	2a		rol a			ROL				; *2, b0 = carry (=1 if token was = or <)
.adc7	49 01		eor #$01		EOR	#$01			; toggle b0
.adc9	45 4d		eor $4d			EOR	LAB_4D		; EOR with comparrison evaluation flag
.adcb	c5 4d		cmp $4d			CMP	LAB_4D		; compare with comparrison evaluation flag
.adcd	90 61		bcc $ae30		BCC	LAB_AE30		; if < saved flag do syntax error then warm start
.adcf	85 4d		sta $4d			STA	LAB_4D		; save new comparrison evaluation flag
.add1	20 73 00	jsr $0073		JSR	LAB_0073		; increment and scan memory
.add4	4c bb ad	jmp $adbb		JMP	LAB_ADBB		; go do next character
.add7					LAB_ADD7
.add7	a6 4d		ldx $4d			LDX	LAB_4D		; get comparrison evaluation flag
.add9	d0 2c		bne $ae07		BNE	LAB_AE07		; branch if compare function
.addb	b0 7b		bcs $ae58		BCS	LAB_AE58		; go do functions
.addd	69 07		adc #$07		ADC	#$07			; add # of operators (+, -, *, /, ^, AND or OR)
.addf	90 77		bcc $ae58		BCC	LAB_AE58		; branch if < + operator
.ade1	65 0d		adc $0d			ADC	LAB_0D		; add data type flag, $FF = string, $00 = numeric
.ade3	d0 03		bne $ade8		BNE	LAB_ADE8		; branch if not string or not + token
.ade5	4c 3d b6	jmp $b63d		JMP	LAB_B63D		; add strings, string 1 is in the descriptor, string 2
.ade8					LAB_ADE8
.ade8	69 ff		adc #$ff		ADC	#$FF			; -1 (corrects for carry add)
.adea	85 22		sta $22			STA	LAB_22		; save it
.adec	0a		asl a			ASL				; *2
.aded	65 22		adc $22			ADC	LAB_22		; *3
.adef	a8		tay			TAY				; copy to index
.adf0					LAB_ADF0
.adf0	68		pla			PLA				; pull previous precedence
.adf1	d9 80 a0	cmp $a080,y		CMP	LAB_A080,Y		; compare with precedence byte
.adf4	b0 67		bcs $ae5d		BCS	LAB_AE5D		; branch if A >=
.adf6	20 8d ad	jsr $ad8d		JSR	LAB_AD8D		; check if source is numeric, else do type mismatch
.adf9					LAB_ADF9
.adf9	48		pha			PHA				; save precedence
.adfa					LAB_ADFA
.adfa	20 20 ae	jsr $ae20		JSR	LAB_AE20		; get vector, execute function then continue evaluation
.adfd	68		pla			PLA				; restore precedence
.adfe	a4 4b		ldy $4b			LDY	LAB_4B		; get precedence stacked flag
.ae00	10 17		bpl $ae19		BPL	LAB_AE19		; branch if stacked values
.ae02	aa		tax			TAX				; copy precedence, set flags
.ae03	f0 56		beq $ae5b		BEQ	LAB_AE5B		; exit if done
.ae05	d0 5f		bne $ae66		BNE	LAB_AE66		; else pop FAC2 and return, branch always
.ae07					LAB_AE07
.ae07	46 0d		lsr $0d			LSR	LAB_0D		; clear data type flag, $FF = string, $00 = numeric
.ae09	8a		txa			TXA				; copy compare function flag
.ae0a	2a		rol a			ROL				; <<1, shift data type flag into b0, 1 = string, 0 = num
.ae0b	a6 7a		ldx $7a			LDX	LAB_7A		; get BASIC execute pointer low byte
.ae0d	d0 02		bne $ae11		BNE	LAB_AE11		; branch if no underflow
.ae0f	c6 7b		dec $7b			DEC	LAB_7B		; else decrement BASIC execute pointer high byte
.ae11					LAB_AE11
.ae11	c6 7a		dec $7a			DEC	LAB_7A		; decrement BASIC execute pointer low byte
.ae13	a0 1b		ldy #$1b		LDY	#LAB_A09B-LAB_A080
.ae15	85 4d		sta $4d			STA	LAB_4D		; save new comparrison evaluation flag
.ae17	d0 d7		bne $adf0		BNE	LAB_ADF0		; branch always
.ae19					LAB_AE19
.ae19	d9 80 a0	cmp $a080,y		CMP	LAB_A080,Y		; compare with stacked function precedence
.ae1c	b0 48		bcs $ae66		BCS	LAB_AE66		; if A >=, pop FAC2 and return
.ae1e	90 d9		bcc $adf9		BCC	LAB_ADF9		; else go stack this one and continue, branch always
.ae20					LAB_AE20
.ae20	b9 82 a0	lda $a082,y		LDA	LAB_A080+2,Y	; get function vector high byte
.ae23	48		pha			PHA				; onto stack
.ae24	b9 81 a0	lda $a081,y		LDA	LAB_A080+1,Y	; get function vector low byte
.ae27	48		pha			PHA				; onto stack
.ae28	20 33 ae	jsr $ae33		JSR	LAB_AE33		; function will return here, then the next RTS will call
.ae2b	a5 4d		lda $4d			LDA	LAB_4D		; get comparrison evaluation flag
.ae2d	4c a9 ad	jmp $ada9		JMP	LAB_ADA9		; continue evaluating expression
.ae30					LAB_AE30
.ae30	4c 08 af	jmp $af08		JMP	LAB_AF08		; do syntax error then warm start
.ae33					LAB_AE33
.ae33	a5 66		lda $66			LDA	LAB_66		; get FAC1 sign (b7)
.ae35	be 80 a0	ldx $a080,y		LDX	LAB_A080,Y		; get precedence byte
.ae38					LAB_AE38
.ae38	a8		tay			TAY				; copy sign
.ae39	68		pla			PLA				; get return address low byte
.ae3a	85 22		sta $22			STA	LAB_22		; save it
.ae3c	e6 22		inc $22			INC	LAB_22		; increment it as return-1 is pushed
.ae3e	68		pla			PLA				; get return address high byte
.ae3f	85 23		sta $23			STA	LAB_23		; save it
.ae41	98		tya			TYA				; restore sign
.ae42	48		pha			PHA				; push sign
.ae43					LAB_AE43
.ae43	20 1b bc	jsr $bc1b		JSR	LAB_BC1B		; round FAC1
.ae46	a5 65		lda $65			LDA	LAB_65		; get FAC1 mantissa 4
.ae48	48		pha			PHA				; save it
.ae49	a5 64		lda $64			LDA	LAB_64		; get FAC1 mantissa 3
.ae4b	48		pha			PHA				; save it
.ae4c	a5 63		lda $63			LDA	LAB_63		; get FAC1 mantissa 2
.ae4e	48		pha			PHA				; save it
.ae4f	a5 62		lda $62			LDA	LAB_62		; get FAC1 mantissa 1
.ae51	48		pha			PHA				; save it
.ae52	a5 61		lda $61			LDA	LAB_61		; get FAC1 exponent
.ae54	48		pha			PHA				; save it
.ae55	6c 22 00	jmp ($0022)		JMP	(LAB_22)		; return, sort of
.ae58					LAB_AE58
.ae58	a0 ff		ldy #$ff		LDY	#$FF			; flag function
.ae5a	68		pla			PLA				; pull precedence byte
.ae5b					LAB_AE5B
.ae5b	f0 23		beq $ae80		BEQ	LAB_AE80		; exit if done
.ae5d					LAB_AE5D
.ae5d	c9 64		cmp #$64		CMP	#$64			; compare previous precedence with $64
.ae5f	f0 03		beq $ae64		BEQ	LAB_AE64		; branch if was $64 (< function)
.ae61	20 8d ad	jsr $ad8d		JSR	LAB_AD8D		; check if source is numeric, else do type mismatch
.ae64					LAB_AE64
.ae64	84 4b		sty $4b			STY	LAB_4B		; save precedence stacked flag
.ae66					LAB_AE66
.ae66	68		pla			PLA				; pop byte
.ae67	4a		lsr a			LSR				; shift out comparison evaluation lowest bit
.ae68	85 12		sta $12			STA	LAB_12		; save the comparison evaluation flag
.ae6a	68		pla			PLA				; pop exponent
.ae6b	85 69		sta $69			STA	LAB_69		; save FAC2 exponent
.ae6d	68		pla			PLA				; pop mantissa 1
.ae6e	85 6a		sta $6a			STA	LAB_6A		; save FAC2 mantissa 1
.ae70	68		pla			PLA				; pop mantissa 2
.ae71	85 6b		sta $6b			STA	LAB_6B		; save FAC2 mantissa 2
.ae73	68		pla			PLA				; pop mantissa 3
.ae74	85 6c		sta $6c			STA	LAB_6C		; save FAC2 mantissa 3
.ae76	68		pla			PLA				; pop mantissa 4
.ae77	85 6d		sta $6d			STA	LAB_6D		; save FAC2 mantissa 4
.ae79	68		pla			PLA				; pop sign
.ae7a	85 6e		sta $6e			STA	LAB_6E		; save FAC2 sign (b7)
.ae7c	45 66		eor $66			EOR	LAB_66		; EOR FAC1 sign (b7)
.ae7e	85 6f		sta $6f			STA	LAB_6F		; save sign compare (FAC1 EOR FAC2)
.ae80					LAB_AE80
.ae80	a5 61		lda $61			LDA	LAB_61		; get FAC1 exponent
.ae82	60		rts			RTS
.ae83					LAB_AE83
.ae83	6c 0a 03	jmp ($030a)		JMP	(LAB_030A)		; get arithmetic element
.ae86					LAB_AE86
.ae86	a9 00		lda #$00		LDA	#$00			; clear byte
.ae88	85 0d		sta $0d			STA	LAB_0D		; clear data type flag, $FF = string, $00 = numeric
.ae8a					LAB_AE8A
.ae8a	20 73 00	jsr $0073		JSR	LAB_0073		; increment and scan memory
.ae8d	b0 03		bcs $ae92		BCS	LAB_AE92		; branch if not numeric character
.ae8f					LAB_AE8F
.ae8f	4c f3 bc	jmp $bcf3		JMP	LAB_BCF3		; get FAC1 from string and return
.ae92					LAB_AE92
.ae92	20 13 b1	jsr $b113		JSR	LAB_B113		; check byte, return Cb = 0 if<"A" or >"Z"
.ae95	90 03		bcc $ae9a		BCC	LAB_AE9A		; branch if not variable name
.ae97	4c 28 af	jmp $af28		JMP	LAB_AF28		; variable name set-up and return
.ae9a					LAB_AE9A
.ae9a	c9 ff		cmp #$ff		CMP	#TK_PI		; compare with token for PI
.ae9c	d0 0f		bne $aead		BNE	LAB_AEAD		; branch if not PI
.ae9e	a9 a8		lda #$a8		LDA	#<LAB_AEA8		; get PI pointer low byte
.aea0	a0 ae		ldy #$ae		LDY	#>LAB_AEA8		; get PI pointer high byte
.aea2	20 a2 bb	jsr $bba2		JSR	LAB_BBA2		; unpack memory (AY) into FAC1
.aea5	4c 73 00	jmp $0073		JMP	LAB_0073		; increment and scan memory and return
.aea8					LAB_AEA8
>aea8	82 49 0f da a1				.byte	$82,$49,$0F,$DA,$A1
.aead					LAB_AEAD
.aead	c9 2e		cmp #$2e		CMP	#'.'			; compare with "."
.aeaf	f0 de		beq $ae8f		BEQ	LAB_AE8F		; if so get FAC1 from string and return, e.g. was .123
.aeb1	c9 ab		cmp #$ab		CMP	#TK_MINUS		; compare with token for -
.aeb3	f0 58		beq $af0d		BEQ	LAB_AF0D		; branch if - token, do set-up for functions
.aeb5	c9 aa		cmp #$aa		CMP	#TK_PLUS		; compare with token for +
.aeb7	f0 d1		beq $ae8a		BEQ	LAB_AE8A		; branch if + token, +1 = 1 so ignore leading +
.aeb9	c9 22		cmp #$22		CMP	#$22			; compare with "
.aebb	d0 0f		bne $aecc		BNE	LAB_AECC		; branch if not open quote
.aebd					LAB_AEBD
.aebd	a5 7a		lda $7a			LDA	LAB_7A		; get BASIC execute pointer low byte
.aebf	a4 7b		ldy $7b			LDY	LAB_7B		; get BASIC execute pointer high byte
.aec1	69 00		adc #$00		ADC	#$00			; add carry to low byte
.aec3	90 01		bcc $aec6		BCC	LAB_AEC6		; branch if no overflow
.aec5	c8		iny			INY				; increment high byte
.aec6					LAB_AEC6
.aec6	20 87 b4	jsr $b487		JSR	LAB_B487		; print " terminated string to utility pointer
.aec9	4c e2 b7	jmp $b7e2		JMP	LAB_B7E2		; restore BASIC execute pointer from temp and return
.aecc					LAB_AECC
.aecc	c9 a8		cmp #$a8		CMP	#TK_NOT		; compare with token for NOT
.aece	d0 13		bne $aee3		BNE	LAB_AEE3		; branch if not token for NOT
.aed0	a0 18		ldy #$18		LDY	#$18			; offset to NOT function
.aed2	d0 3b		bne $af0f		BNE	LAB_AF0F		; do set-up for function then execute, branch always
.aed4					LAB_AED4
.aed4	20 bf b1	jsr $b1bf		JSR	LAB_B1BF		; evaluate integer expression, no sign check
.aed7	a5 65		lda $65			LDA	LAB_65		; get FAC1 mantissa 4
.aed9	49 ff		eor #$ff		EOR	#$FF			; invert it
.aedb	a8		tay			TAY				; copy it
.aedc	a5 64		lda $64			LDA	LAB_64		; get FAC1 mantissa 3
.aede	49 ff		eor #$ff		EOR	#$FF			; invert it
.aee0	4c 91 b3	jmp $b391		JMP	LAB_B391		; convert fixed integer AY to float FAC1 and return
.aee3					LAB_AEE3
.aee3	c9 a5		cmp #$a5		CMP	#TK_FN		; compare with token for FN
.aee5	d0 03		bne $aeea		BNE	LAB_AEEA		; branch if not token for FN
.aee7	4c f4 b3	jmp $b3f4		JMP	LAB_B3F4		; else go evaluate FNx
.aeea					LAB_AEEA
.aeea	c9 b4		cmp #$b4		CMP	#TK_SGN		; compare with token for SGN
.aeec	90 03		bcc $aef1		BCC	LAB_AEF1		; if less than SGN token evaluate expression in parentheses
.aeee	4c a7 af	jmp $afa7		JMP	LAB_AFA7		; go set up function references, branch always
.aef1					LAB_AEF1
.aef1	20 fa ae	jsr $aefa		JSR	LAB_AEFA		; scan for "(", else do syntax error then warm start
.aef4	20 9e ad	jsr $ad9e		JSR	LAB_AD9E		; evaluate expression
.aef7					LAB_AEF7
.aef7	a9 29		lda #$29		LDA	#')'			; load A with ")"
>aef9	2c					.byte	$2C			; makes next line BIT LAB_28A9
.aefa					LAB_AEFA
.aefa	a9 28		lda #$28		LDA	#'('			; load A with "("
>aefc	2c					.byte	$2C			; makes next line BIT LAB_2CA9
.aefd					LAB_AEFD
.aefd	a9 2c		lda #$2c		LDA	#','			; load A with ","
.aeff					LAB_AEFF
.aeff	a0 00		ldy #$00		LDY	#$00			; clear index
.af01	d1 7a		cmp ($7a),y		CMP	(LAB_7A),Y		; compare with BASIC byte
.af03	d0 03		bne $af08		BNE	LAB_AF08		; if not expected byte do syntax error then warm start
.af05	4c 73 00	jmp $0073		JMP	LAB_0073		; else increment and scan memory and return
.af08					LAB_AF08
.af08	a2 0b		ldx #$0b		LDX	#$0B			; error code $0B, syntax error
.af0a	4c 37 a4	jmp $a437		JMP	LAB_A437		; do error #X then warm start
.af0d					LAB_AF0D
.af0d	a0 15		ldy #$15		LDY	#$15			; set offset from base to > operator
.af0f					LAB_AF0F
.af0f	68		pla			PLA				; dump return address low byte
.af10	68		pla			PLA				; dump return address high byte
.af11	4c fa ad	jmp $adfa		JMP	LAB_ADFA		; execute function then continue evaluation
.af14					LAB_AF14
.af14	38		sec			SEC				; set carry for subtract
.af15	a5 64		lda $64			LDA	LAB_64		; get variable address low byte
.af17	e9 00		sbc #$00		SBC	#<LAB_A000		; subtract LAB_A000 low byte
.af19	a5 65		lda $65			LDA	LAB_65		; get variable address high byte
.af1b	e9 a0		sbc #$a0		SBC	#>LAB_A000		; subtract LAB_A000 high byte
.af1d	90 08		bcc $af27		BCC	LAB_AF27		; exit if address < LAB_A000
.af1f	a9 a2		lda #$a2		LDA	#<LAB_E3A2		; get end of BASIC marker low byte
.af21	e5 64		sbc $64			SBC	LAB_64		; subtract variable address low byte
.af23	a9 e3		lda #$e3		LDA	#>LAB_E3A2		; get end of BASIC marker high byte
.af25	e5 65		sbc $65			SBC	LAB_65		; subtract variable address high byte
.af27					LAB_AF27
.af27	60		rts			RTS
.af28					LAB_AF28
.af28	20 8b b0	jsr $b08b		JSR	LAB_B08B		; get variable address
.af2b	85 64		sta $64			STA	LAB_64		; save variable pointer low byte
.af2d	84 65		sty $65			STY	LAB_65		; save variable pointer high byte
.af2f	a6 45		ldx $45			LDX	LAB_45		; get current variable name first character
.af31	a4 46		ldy $46			LDY	LAB_46		; get current variable name second character
.af33	a5 0d		lda $0d			LDA	LAB_0D		; get data type flag, $FF = string, $00 = numeric
.af35	f0 26		beq $af5d		BEQ	LAB_AF5D		; branch if numeric
.af37	a9 00		lda #$00		LDA	#$00			; else clear A
.af39	85 70		sta $70			STA	LAB_70		; clear FAC1 rounding byte
.af3b	20 14 af	jsr $af14		JSR	LAB_AF14		; check address range
.af3e	90 1c		bcc $af5c		BCC	LAB_AF5C		; exit if not in BASIC ROM
.af40	e0 54		cpx #$54		CPX	#'T'			; compare variable name first character with "T"
.af42	d0 18		bne $af5c		BNE	LAB_AF5C		; exit if not "T"
.af44	c0 c9		cpy #$c9		CPY	#'I'+$80		; compare variable name second character with "I$"
.af46	d0 14		bne $af5c		BNE	LAB_AF5C		; exit if not "I$"
.af48	20 84 af	jsr $af84		JSR	LAB_AF84		; read real time clock into FAC1 mantissa, 0HML
.af4b	84 5e		sty $5e			STY	LAB_5E		; clear exponent count adjust
.af4d	88		dey			DEY				; Y = $FF
.af4e	84 71		sty $71			STY	LAB_71		; set output string index, -1 to allow for pre increment
.af50	a0 06		ldy #$06		LDY	#$06			; HH:MM:SS is six digits
.af52	84 5d		sty $5d			STY	LAB_5D		; set number of characters before the decimal point
.af54	a0 24		ldy #$24		LDY	#LAB_BF3A-LAB_BF16
.af56	20 68 be	jsr $be68		JSR	LAB_BE68		; convert jiffy count to string
.af59	4c 6f b4	jmp $b46f		JMP	LAB_B46F		; exit via STR$() code tail
.af5c					LAB_AF5C
.af5c	60		rts			RTS
.af5d					LAB_AF5D
.af5d	24 0e		bit $0e			BIT	LAB_0E		; test data type flag, $80 = integer, $00 = float
.af5f	10 0d		bpl $af6e		BPL	LAB_AF6E		; branch if float
.af61	a0 00		ldy #$00		LDY	#$00			; clear index
.af63	b1 64		lda ($64),y		LDA	(LAB_64),Y		; get integer variable low byte
.af65	aa		tax			TAX				; copy to X
.af66	c8		iny			INY				; increment index
.af67	b1 64		lda ($64),y		LDA	(LAB_64),Y		; get integer variable high byte
.af69	a8		tay			TAY				; copy to Y
.af6a	8a		txa			TXA				; copy loa byte to A
.af6b	4c 91 b3	jmp $b391		JMP	LAB_B391		; convert fixed integer AY to float FAC1 and return
.af6e					LAB_AF6E
.af6e	20 14 af	jsr $af14		JSR	LAB_AF14		; check address range
.af71	90 2d		bcc $afa0		BCC	LAB_AFA0		; if not in BASIC ROM get pointer and unpack into FAC1
.af73	e0 54		cpx #$54		CPX	#'T'			; compare variable name first character with "T"
.af75	d0 1b		bne $af92		BNE	LAB_AF92		; branch if not "T"
.af77	c0 49		cpy #$49		CPY	#'I'			; compare variable name second character with "I"
.af79	d0 25		bne $afa0		BNE	LAB_AFA0		; branch if not "I"
.af7b	20 84 af	jsr $af84		JSR	LAB_AF84		; read real time clock into FAC1 mantissa, 0HML
.af7e	98		tya			TYA				; clear A
.af7f	a2 a0		ldx #$a0		LDX	#$A0			; set exponent to 32 bit value
.af81	4c 4f bc	jmp $bc4f		JMP	LAB_BC4F		; set exponent = X and normalise FAC1
.af84					LAB_AF84
.af84	20 de ff	jsr $ffde		JSR	LAB_FFDE		; read real time clock
.af87	86 64		stx $64			STX	LAB_64		; save jiffy clock mid byte as  FAC1 mantissa 3
.af89	84 63		sty $63			STY	LAB_63		; save jiffy clock high byte as  FAC1 mantissa 2
.af8b	85 65		sta $65			STA	LAB_65		; save jiffy clock low byte as  FAC1 mantissa 4
.af8d	a0 00		ldy #$00		LDY	#$00			; clear Y
.af8f	84 62		sty $62			STY	LAB_62		; clear FAC1 mantissa 1
.af91	60		rts			RTS
.af92					LAB_AF92
.af92	e0 53		cpx #$53		CPX	#'S'			; compare variable name first character with "S"
.af94	d0 0a		bne $afa0		BNE	LAB_AFA0		; if not "S" go do normal floating variable
.af96	c0 54		cpy #$54		CPY	#'T'			; compare variable name second character with "
.af98	d0 06		bne $afa0		BNE	LAB_AFA0		; if not "T" go do normal floating variable
.af9a	20 b7 ff	jsr $ffb7		JSR	LAB_FFB7		; read I/O status word
.af9d	4c 3c bc	jmp $bc3c		JMP	LAB_BC3C		; save A as integer byte and return
.afa0					LAB_AFA0
.afa0	a5 64		lda $64			LDA	LAB_64		; get variable pointer low byte
.afa2	a4 65		ldy $65			LDY	LAB_65		; get variable pointer high byte
.afa4	4c a2 bb	jmp $bba2		JMP	LAB_BBA2		; unpack memory (AY) into FAC1
.afa7					LAB_AFA7
.afa7	0a		asl a			ASL				; *2 (2 bytes per function address)
.afa8	48		pha			PHA				; save function offset
.afa9	aa		tax			TAX				; copy function offset
.afaa	20 73 00	jsr $0073		JSR	LAB_0073		; increment and scan memory
.afad	e0 8f		cpx #$8f		CPX	#$8F			; compare function offset to CHR$ token offset+1
.afaf	90 20		bcc $afd1		BCC	LAB_AFD1		; branch if < LEFT$ (can not be =)
.afb1	20 fa ae	jsr $aefa		JSR	LAB_AEFA		; scan for "(", else do syntax error then warm start
.afb4	20 9e ad	jsr $ad9e		JSR	LAB_AD9E		; evaluate, should be string, expression
.afb7	20 fd ae	jsr $aefd		JSR	LAB_AEFD		; scan for ",", else do syntax error then warm start
.afba	20 8f ad	jsr $ad8f		JSR	LAB_AD8F		; check if source is string, else do type mismatch
.afbd	68		pla			PLA				; restore function offset
.afbe	aa		tax			TAX				; copy it
.afbf	a5 65		lda $65			LDA	LAB_65		; get descriptor pointer high byte
.afc1	48		pha			PHA				; push string pointer high byte
.afc2	a5 64		lda $64			LDA	LAB_64		; get descriptor pointer low byte
.afc4	48		pha			PHA				; push string pointer low byte
.afc5	8a		txa			TXA				; restore function offset
.afc6	48		pha			PHA				; save function offset
.afc7	20 9e b7	jsr $b79e		JSR	LAB_B79E		; get byte parameter
.afca	68		pla			PLA				; restore function offset
.afcb	a8		tay			TAY				; copy function offset
.afcc	8a		txa			TXA				; copy byte parameter to A
.afcd	48		pha			PHA				; push byte parameter
.afce	4c d6 af	jmp $afd6		JMP	LAB_AFD6		; go call function
.afd1					LAB_AFD1
.afd1	20 f1 ae	jsr $aef1		JSR	LAB_AEF1		; evaluate expression within parentheses
.afd4	68		pla			PLA				; restore function offset
.afd5	a8		tay			TAY				; copy to index
.afd6					LAB_AFD6
.afd6	b9 ea 9f	lda $9fea,y		LDA	LAB_A052-$68,Y	; get function jump vector low byte
.afd9	85 55		sta $55			STA	LAB_55		; save functions jump vector low byte
.afdb	b9 eb 9f	lda $9feb,y		LDA	LAB_A052-$67,Y	; get function jump vector high byte
.afde	85 56		sta $56			STA	LAB_56		; save functions jump vector high byte
.afe0	20 54 00	jsr $0054		JSR	LAB_54		; do function call
.afe3	4c 8d ad	jmp $ad8d		JMP	LAB_AD8D		; check if source is numeric and RTS, else do type mismatch
.afe6					LAB_AFE6
.afe6	a0 ff		ldy #$ff		LDY	#$FF			; set Y for OR
>afe8	2c					.byte	$2C			; makes next line BIT LAB_00A0
.afe9					LAB_AFE9
.afe9	a0 00		ldy #$00		LDY	#$00			; clear Y for AND
.afeb	84 0b		sty $0b			STY	LAB_0B		; set AND/OR invert value
.afed	20 bf b1	jsr $b1bf		JSR	LAB_B1BF		; evaluate integer expression, no sign check
.aff0	a5 64		lda $64			LDA	LAB_64		; get FAC1 mantissa 3
.aff2	45 0b		eor $0b			EOR	LAB_0B		; EOR low byte
.aff4	85 07		sta $07			STA	LAB_07		; save it
.aff6	a5 65		lda $65			LDA	LAB_65		; get FAC1 mantissa 4
.aff8	45 0b		eor $0b			EOR	LAB_0B		; EOR high byte
.affa	85 08		sta $08			STA	LAB_08		; save it
.affc	20 fc bb	jsr $bbfc		JSR	LAB_BBFC		; copy FAC2 to FAC1, get 2nd value in expression
.afff	20 bf b1	jsr $b1bf		JSR	LAB_B1BF		; evaluate integer expression, no sign check
.b002	a5 65		lda $65			LDA	LAB_65		; get FAC1 mantissa 4
.b004	45 0b		eor $0b			EOR	LAB_0B		; EOR high byte
.b006	25 08		and $08			AND	LAB_08		; AND with expression 1 high byte
.b008	45 0b		eor $0b			EOR	LAB_0B		; EOR result high byte
.b00a	a8		tay			TAY				; save in Y
.b00b	a5 64		lda $64			LDA	LAB_64		; get FAC1 mantissa 3
.b00d	45 0b		eor $0b			EOR	LAB_0B		; EOR low byte
.b00f	25 07		and $07			AND	LAB_07		; AND with expression 1 low byte
.b011	45 0b		eor $0b			EOR	LAB_0B		; EOR result low byte
.b013	4c 91 b3	jmp $b391		JMP	LAB_B391		; convert fixed integer AY to float FAC1 and return
.b016					LAB_B016
.b016	20 90 ad	jsr $ad90		JSR	LAB_AD90		; type match check, set C for string
.b019	b0 13		bcs $b02e		BCS	LAB_B02E		; branch if string
.b01b	a5 6e		lda $6e			LDA	LAB_6E		; get FAC2 sign (b7)
.b01d	09 7f		ora #$7f		ORA	#$7F			; set all non sign bits
.b01f	25 6a		and $6a			AND	LAB_6A		; and FAC2 mantissa 1 (AND in sign bit)
.b021	85 6a		sta $6a			STA	LAB_6A		; save FAC2 mantissa 1
.b023	a9 69		lda #$69		LDA	#<LAB_69		; set pointer low byte to FAC2
.b025	a0 00		ldy #$00		LDY	#>LAB_69		; set pointer high byte to FAC2
.b027	20 5b bc	jsr $bc5b		JSR	LAB_BC5B		; compare FAC1 with (AY)
.b02a	aa		tax			TAX				; copy the result
.b02b	4c 61 b0	jmp $b061		JMP	LAB_B061		; go evaluate result
.b02e					LAB_B02E
.b02e	a9 00		lda #$00		LDA	#$00			; clear byte
.b030	85 0d		sta $0d			STA	LAB_0D		; clear data type flag, $FF = string, $00 = numeric
.b032	c6 4d		dec $4d			DEC	LAB_4D		; clear < bit in comparrison evaluation flag
.b034	20 a6 b6	jsr $b6a6		JSR	LAB_B6A6		; pop string off descriptor stack, or from top of string
.b037	85 61		sta $61			STA	LAB_61		; save length
.b039	86 62		stx $62			STX	LAB_62		; save string pointer low byte
.b03b	84 63		sty $63			STY	LAB_63		; save string pointer high byte
.b03d	a5 6c		lda $6c			LDA	LAB_6C		; get descriptor pointer low byte
.b03f	a4 6d		ldy $6d			LDY	LAB_6D		; get descriptor pointer high byte
.b041	20 aa b6	jsr $b6aa		JSR	LAB_B6AA		; pop (YA) descriptor off stack or from top of string space
.b044	86 6c		stx $6c			STX	LAB_6C		; save string pointer low byte
.b046	84 6d		sty $6d			STY	LAB_6D		; save string pointer high byte
.b048	aa		tax			TAX				; copy length
.b049	38		sec			SEC				; set carry for subtract
.b04a	e5 61		sbc $61			SBC	LAB_61		; subtract string 1 length
.b04c	f0 08		beq $b056		BEQ	LAB_B056		; branch if str 1 length = string 2 length
.b04e	a9 01		lda #$01		LDA	#$01			; set str 1 length > string 2 length
.b050	90 04		bcc $b056		BCC	LAB_B056		; branch if so
.b052	a6 61		ldx $61			LDX	LAB_61		; get string 1 length
.b054	a9 ff		lda #$ff		LDA	#$FF			; set str 1 length < string 2 length
.b056					LAB_B056
.b056	85 66		sta $66			STA	LAB_66		; save length compare
.b058	a0 ff		ldy #$ff		LDY	#$FF			; set index
.b05a	e8		inx			INX				; adjust for loop
.b05b					LAB_B05B
.b05b	c8		iny			INY				; increment index
.b05c	ca		dex			DEX				; decrement count
.b05d	d0 07		bne $b066		BNE	LAB_B066		; branch if still bytes to do
.b05f	a6 66		ldx $66			LDX	LAB_66		; get length compare back
.b061					LAB_B061
.b061	30 0f		bmi $b072		BMI	LAB_B072		; branch if str 1 < str 2
.b063	18		clc			CLC				; flag str 1 <= str 2
.b064	90 0c		bcc $b072		BCC	LAB_B072		; go evaluate result
.b066					LAB_B066
.b066	b1 6c		lda ($6c),y		LDA	(LAB_6C),Y		; get string 2 byte
.b068	d1 62		cmp ($62),y		CMP	(LAB_62),Y		; compare with string 1 byte
.b06a	f0 ef		beq $b05b		BEQ	LAB_B05B		; loop if bytes =
.b06c	a2 ff		ldx #$ff		LDX	#$FF			; set str 1 < string 2
.b06e	b0 02		bcs $b072		BCS	LAB_B072		; branch if so
.b070	a2 01		ldx #$01		LDX	#$01			; set str 1 > string 2
.b072					LAB_B072
.b072	e8		inx			INX				; x = 0, 1 or 2
.b073	8a		txa			TXA				; copy to A
.b074	2a		rol a			ROL				; * 2 (1, 2 or 4)
.b075	25 12		and $12			AND	LAB_12		; AND with the comparison evaluation flag
.b077	f0 02		beq $b07b		BEQ	LAB_B07B		; branch if 0 (compare is false)
.b079	a9 ff		lda #$ff		LDA	#$FF			; else set result true
.b07b					LAB_B07B
.b07b	4c 3c bc	jmp $bc3c		JMP	LAB_BC3C		; save A as integer byte and return
.b07e					LAB_B07E
.b07e	20 fd ae	jsr $aefd		JSR	LAB_AEFD		; scan for ",", else do syntax error then warm start
.b081					LAB_B081
.b081	aa		tax			TAX				; copy "DIM" flag to X
.b082	20 90 b0	jsr $b090		JSR	LAB_B090		; search for variable
.b085	20 79 00	jsr $0079		JSR	LAB_0079		; scan memory
.b088	d0 f4		bne $b07e		BNE	LAB_B07E		; scan for "," and loop if not null
.b08a	60		rts			RTS
.b08b					LAB_B08B
.b08b	a2 00		ldx #$00		LDX	#$00			; set DIM flag = $00
.b08d	20 79 00	jsr $0079		JSR	LAB_0079		; scan memory, 1st character
.b090					LAB_B090
.b090	86 0c		stx $0c			STX	LAB_0C		; save DIM flag
.b092					LAB_B092
.b092	85 45		sta $45			STA	LAB_45		; save 1st character
.b094	20 79 00	jsr $0079		JSR	LAB_0079		; scan memory
.b097	20 13 b1	jsr $b113		JSR	LAB_B113		; check byte, return Cb = 0 if<"A" or >"Z"
.b09a	b0 03		bcs $b09f		BCS	LAB_B09F		; branch if ok
.b09c					LAB_B09C
.b09c	4c 08 af	jmp $af08		JMP	LAB_AF08		; else syntax error then warm start
.b09f					LAB_B09F
.b09f	a2 00		ldx #$00		LDX	#$00			; clear 2nd character temp
.b0a1	86 0d		stx $0d			STX	LAB_0D		; clear data type flag, $FF = string, $00 = numeric
.b0a3	86 0e		stx $0e			STX	LAB_0E		; clear data type flag, $80 = integer, $00 = float
.b0a5	20 73 00	jsr $0073		JSR	LAB_0073		; increment and scan memory, 2nd character
.b0a8	90 05		bcc $b0af		BCC	LAB_B0AF		; if character = "0"-"9" (ok) go save 2nd character
.b0aa	20 13 b1	jsr $b113		JSR	LAB_B113		; check byte, return Cb = 0 if<"A" or >"Z"
.b0ad	90 0b		bcc $b0ba		BCC	LAB_B0BA		; branch if <"A" or >"Z" (go check if string)
.b0af					LAB_B0AF
.b0af	aa		tax			TAX				; copy 2nd character
.b0b0					LAB_B0B0
.b0b0	20 73 00	jsr $0073		JSR	LAB_0073		; increment and scan memory, 3rd character
.b0b3	90 fb		bcc $b0b0		BCC	LAB_B0B0		; loop if character = "0"-"9" (ignore)
.b0b5	20 13 b1	jsr $b113		JSR	LAB_B113		; check byte, return Cb = 0 if<"A" or >"Z"
.b0b8	b0 f6		bcs $b0b0		BCS	LAB_B0B0		; loop if character = "A"-"Z" (ignore)
.b0ba					LAB_B0BA
.b0ba	c9 24		cmp #$24		CMP	#'$'			; compare with "$"
.b0bc	d0 06		bne $b0c4		BNE	LAB_B0C4		; branch if not string
.b0be	a9 ff		lda #$ff		LDA	#$FF			; set data type = string
.b0c0	85 0d		sta $0d			STA	LAB_0D		; set data type flag, $FF = string, $00 = numeric
.b0c2	d0 10		bne $b0d4		BNE	LAB_B0D4		; branch always
.b0c4					LAB_B0C4
.b0c4	c9 25		cmp #$25		CMP	#'%'			; compare with "%"
.b0c6	d0 13		bne $b0db		BNE	LAB_B0DB		; branch if not integer
.b0c8	a5 10		lda $10			LDA	LAB_10		; get subscript/FNX flag
.b0ca	d0 d0		bne $b09c		BNE	LAB_B09C		; if ?? do syntax error then warm start
.b0cc	a9 80		lda #$80		LDA	#$80			; set integer type
.b0ce	85 0e		sta $0e			STA	LAB_0E		; set data type = integer
.b0d0	05 45		ora $45			ORA	LAB_45		; OR current variable name first byte
.b0d2	85 45		sta $45			STA	LAB_45		; save current variable name first byte
.b0d4					LAB_B0D4
.b0d4	8a		txa			TXA				; get 2nd character back
.b0d5	09 80		ora #$80		ORA	#$80			; set top bit, indicate string or integer variable
.b0d7	aa		tax			TAX				; copy back to 2nd character temp
.b0d8	20 73 00	jsr $0073		JSR	LAB_0073		; increment and scan memory
.b0db					LAB_B0DB
.b0db	86 46		stx $46			STX	LAB_46		; save 2nd character
.b0dd	38		sec			SEC				; set carry for subtract
.b0de	05 10		ora $10			ORA	LAB_10		; or with subscript/FNX flag - or FN name
.b0e0	e9 28		sbc #$28		SBC	#'('			; subtract "("
.b0e2	d0 03		bne $b0e7		BNE	LAB_B0E7		; branch if not "("
.b0e4	4c d1 b1	jmp $b1d1		JMP	LAB_B1D1		; go find, or make, array
.b0e7					LAB_B0E7
.b0e7	a0 00		ldy #$00		LDY	#$00			; clear A
.b0e9	84 10		sty $10			STY	LAB_10		; clear subscript/FNX flag
.b0eb	a5 2d		lda $2d			LDA	LAB_2D		; get start of variables low byte
.b0ed	a6 2e		ldx $2e			LDX	LAB_2E		; get start of variables high byte
.b0ef					LAB_B0EF
.b0ef	86 60		stx $60			STX	LAB_60		; save search address high byte
.b0f1					LAB_B0F1
.b0f1	85 5f		sta $5f			STA	LAB_5F		; save search address low byte
.b0f3	e4 30		cpx $30			CPX	LAB_30		; compare with end of variables high byte
.b0f5	d0 04		bne $b0fb		BNE	LAB_B0FB		; skip next compare if <>
.b0f7	c5 2f		cmp $2f			CMP	LAB_2F		; compare low address with end of variables low byte
.b0f9	f0 22		beq $b11d		BEQ	LAB_B11D		; if not found go make new variable
.b0fb					LAB_B0FB
.b0fb	a5 45		lda $45			LDA	LAB_45		; get 1st character of variable to find
.b0fd	d1 5f		cmp ($5f),y		CMP	(LAB_5F),Y		; compare with variable name 1st character
.b0ff	d0 08		bne $b109		BNE	LAB_B109		; branch if no match
.b101	a5 46		lda $46			LDA	LAB_46		; get 2nd character of variable to find
.b103	c8		iny			INY				; index to point to variable name 2nd character
.b104	d1 5f		cmp ($5f),y		CMP	(LAB_5F),Y		; compare with variable name 2nd character
.b106	f0 7d		beq $b185		BEQ	LAB_B185		; branch if match (found variable)
.b108	88		dey			DEY				; else decrement index (now = $00)
.b109					LAB_B109
.b109	18		clc			CLC				; clear carry for add
.b10a	a5 5f		lda $5f			LDA	LAB_5F		; get search address low byte
.b10c	69 07		adc #$07		ADC	#$07			; +7, offset to next variable name
.b10e	90 e1		bcc $b0f1		BCC	LAB_B0F1		; loop if no overflow to high byte
.b110	e8		inx			INX				; else increment high byte
.b111	d0 dc		bne $b0ef		BNE	LAB_B0EF		; loop always, RAM doesn't extend to $FFFF
.b113					LAB_B113
.b113	c9 41		cmp #$41		CMP	#$41			; compare with "A"
.b115	90 05		bcc $b11c		BCC	LAB_B11C		; exit if less
.b117	e9 5b		sbc #$5b		SBC	#$5B			; subtract "Z"+1
.b119	38		sec			SEC				; set carry
.b11a	e9 a5		sbc #$a5		SBC	#$A5			; subtract $A5 (restore byte)
.b11c					LAB_B11C
.b11c	60		rts			RTS
.b11d					LAB_B11D
.b11d	68		pla			PLA				; pop return address low byte
.b11e	48		pha			PHA				; push return address low byte
=44842					LAB_AF28p2	= LAB_AF28+2
.b11f	c9 2a		cmp #$2a		CMP	#<LAB_AF28p2	; compare with expected calling routine return low byte
.b121	d0 05		bne $b128		BNE	LAB_B128		; if not get variable go create new variable
.b123					LAB_B123
.b123	a9 13		lda #$13		LDA	#<LAB_BF13		; set result pointer low byte
.b125	a0 bf		ldy #$bf		LDY	#>LAB_BF13		; set result pointer high byte
.b127	60		rts			RTS
.b128					LAB_B128
.b128	a5 45		lda $45			LDA	LAB_45		; get variable name first character
.b12a	a4 46		ldy $46			LDY	LAB_46		; get variable name second character
.b12c	c9 54		cmp #$54		CMP	#'T'			; compare first character with "T"
.b12e	d0 0b		bne $b13b		BNE	LAB_B13B		; branch if not "T"
.b130	c0 c9		cpy #$c9		CPY	#'I'+$80		; compare second character with "I$"
.b132	f0 ef		beq $b123		BEQ	LAB_B123		; if "I$" return null value
.b134	c0 49		cpy #$49		CPY	#'I'			; compare second character with "I"
.b136	d0 03		bne $b13b		BNE	LAB_B13B		; branch if not "I"
.b138					LAB_B138
.b138	4c 08 af	jmp $af08		JMP	LAB_AF08		; do syntax error then warm start
.b13b					LAB_B13B
.b13b	c9 53		cmp #$53		CMP	#'S'			; compare first character with "S"
.b13d	d0 04		bne $b143		BNE	LAB_B143		; branch if not "S"
.b13f	c0 54		cpy #$54		CPY	#'T'			; compare second character with "T"
.b141	f0 f5		beq $b138		BEQ	LAB_B138		; if name is "ST" do syntax error
.b143					LAB_B143
.b143	a5 2f		lda $2f			LDA	LAB_2F		; get end of variables low byte
.b145	a4 30		ldy $30			LDY	LAB_30		; get end of variables high byte
.b147	85 5f		sta $5f			STA	LAB_5F		; save old block start low byte
.b149	84 60		sty $60			STY	LAB_60		; save old block start high byte
.b14b	a5 31		lda $31			LDA	LAB_31		; get end of arrays low byte
.b14d	a4 32		ldy $32			LDY	LAB_32		; get end of arrays high byte
.b14f	85 5a		sta $5a			STA	LAB_5A		; save old block end low byte
.b151	84 5b		sty $5b			STY	LAB_5B		; save old block end high byte
.b153	18		clc			CLC				; clear carry for add
.b154	69 07		adc #$07		ADC	#$07			; +7, space for one variable
.b156	90 01		bcc $b159		BCC	LAB_B159		; branch if no overflow to high byte
.b158	c8		iny			INY				; else increment high byte
.b159					LAB_B159
.b159	85 58		sta $58			STA	LAB_58		; set new block end low byte
.b15b	84 59		sty $59			STY	LAB_59		; set new block end high byte
.b15d	20 b8 a3	jsr $a3b8		JSR	LAB_A3B8		; open up space in memory
.b160	a5 58		lda $58			LDA	LAB_58		; get new start low byte
.b162	a4 59		ldy $59			LDY	LAB_59		; get new start high byte (-$100)
.b164	c8		iny			INY				; correct high byte
.b165	85 2f		sta $2f			STA	LAB_2F		; set end of variables low byte
.b167	84 30		sty $30			STY	LAB_30		; set end of variables high byte
.b169	a0 00		ldy #$00		LDY	#$00			; clear index
.b16b	a5 45		lda $45			LDA	LAB_45		; get variable name 1st character
.b16d	91 5f		sta ($5f),y		STA	(LAB_5F),Y		; save variable name 1st character
.b16f	c8		iny			INY				; increment index
.b170	a5 46		lda $46			LDA	LAB_46		; get variable name 2nd character
.b172	91 5f		sta ($5f),y		STA	(LAB_5F),Y		; save variable name 2nd character
.b174	a9 00		lda #$00		LDA	#$00			; clear A
.b176	c8		iny			INY				; increment index
.b177	91 5f		sta ($5f),y		STA	(LAB_5F),Y		; initialise variable byte
.b179	c8		iny			INY				; increment index
.b17a	91 5f		sta ($5f),y		STA	(LAB_5F),Y		; initialise variable byte
.b17c	c8		iny			INY				; increment index
.b17d	91 5f		sta ($5f),y		STA	(LAB_5F),Y		; initialise variable byte
.b17f	c8		iny			INY				; increment index
.b180	91 5f		sta ($5f),y		STA	(LAB_5F),Y		; initialise variable byte
.b182	c8		iny			INY				; increment index
.b183	91 5f		sta ($5f),y		STA	(LAB_5F),Y		; initialise variable byte
.b185					LAB_B185
.b185	a5 5f		lda $5f			LDA	LAB_5F		; get variable address low byte
.b187	18		clc			CLC				; clear carry for add
.b188	69 02		adc #$02		ADC	#$02			; +2, offset past variable name bytes
.b18a	a4 60		ldy $60			LDY	LAB_60		; get variable address high byte
.b18c	90 01		bcc $b18f		BCC	LAB_B18F		; branch if no overflow from add
.b18e	c8		iny			INY				; else increment high byte
.b18f					LAB_B18F
.b18f	85 47		sta $47			STA	LAB_47		; save current variable pointer low byte
.b191	84 48		sty $48			STY	LAB_48		; save current variable pointer high byte
.b193	60		rts			RTS
.b194					LAB_B194
.b194	a5 0b		lda $0b			LDA	LAB_0B		; get # of dimensions (1, 2 or 3)
.b196	0a		asl a			ASL				; *2 (also clears the carry !)
.b197	69 05		adc #$05		ADC	#$05			; +5 (result is 7, 9 or 11 here)
.b199	65 5f		adc $5f			ADC	LAB_5F		; add array start pointer low byte
.b19b	a4 60		ldy $60			LDY	LAB_60		; get array pointer high byte
.b19d	90 01		bcc $b1a0		BCC	LAB_B1A0		; branch if no overflow
.b19f	c8		iny			INY				; else increment high byte
.b1a0					LAB_B1A0
.b1a0	85 58		sta $58			STA	LAB_58		; save array data pointer low byte
.b1a2	84 59		sty $59			STY	LAB_59		; save array data pointer high byte
.b1a4	60		rts			RTS
.b1a5					LAB_B1A5
>b1a5	90 80 00 00 00				.byte	$90,$80,$00,$00,$00	; -32768
.b1aa					LAB_B1AA
.b1aa	20 bf b1	jsr $b1bf		JSR	LAB_B1BF		; evaluate integer expression, no sign check
.b1ad	a5 64		lda $64			LDA	LAB_64		; get result low byte
.b1af	a4 65		ldy $65			LDY	LAB_65		; get result high byte
.b1b1	60		rts			RTS
.b1b2					LAB_B1B2
.b1b2	20 73 00	jsr $0073		JSR	LAB_0073		; increment and scan memory
.b1b5	20 9e ad	jsr $ad9e		JSR	LAB_AD9E		; evaluate expression
.b1b8					LAB_B1B8
.b1b8	20 8d ad	jsr $ad8d		JSR	LAB_AD8D		; check if source is numeric, else do type mismatch
.b1bb	a5 66		lda $66			LDA	LAB_66		; get FAC1 sign (b7)
.b1bd	30 0d		bmi $b1cc		BMI	LAB_B1CC		; do illegal quantity error if -ve
.b1bf					LAB_B1BF
.b1bf	a5 61		lda $61			LDA	LAB_61		; get FAC1 exponent
.b1c1	c9 90		cmp #$90		CMP	#$90			; compare with exponent = 2^16 (n>2^15)
.b1c3	90 09		bcc $b1ce		BCC	LAB_B1CE		; if n<2^16 go convert FAC1 floating to fixed and return
.b1c5	a9 a5		lda #$a5		LDA	#<LAB_B1A5		; set pointer low byte to -32768
.b1c7	a0 b1		ldy #$b1		LDY	#>LAB_B1A5		; set pointer high byte to -32768
.b1c9	20 5b bc	jsr $bc5b		JSR	LAB_BC5B		; compare FAC1 with (AY)
.b1cc					LAB_B1CC
.b1cc	d0 7a		bne $b248		BNE	LAB_B248		; if <> do illegal quantity error then warm start
.b1ce					LAB_B1CE
.b1ce	4c 9b bc	jmp $bc9b		JMP	LAB_BC9B		; convert FAC1 floating to fixed and return
.b1d1					LAB_B1D1
.b1d1	a5 0c		lda $0c			LDA	LAB_0C		; get DIM flag
.b1d3	05 0e		ora $0e			ORA	LAB_0E		; OR with data type flag
.b1d5	48		pha			PHA				; push it
.b1d6	a5 0d		lda $0d			LDA	LAB_0D		; get data type flag, $FF = string, $00 = numeric
.b1d8	48		pha			PHA				; push it
.b1d9	a0 00		ldy #$00		LDY	#$00			; clear dimensions count
.b1db					LAB_B1DB
.b1db	98		tya			TYA				; copy dimensions count
.b1dc	48		pha			PHA				; save it
.b1dd	a5 46		lda $46			LDA	LAB_46		; get array name 2nd byte
.b1df	48		pha			PHA				; save it
.b1e0	a5 45		lda $45			LDA	LAB_45		; get array name 1st byte
.b1e2	48		pha			PHA				; save it
.b1e3	20 b2 b1	jsr $b1b2		JSR	LAB_B1B2		; evaluate integer expression
.b1e6	68		pla			PLA				; pull array name 1st byte
.b1e7	85 45		sta $45			STA	LAB_45		; restore array name 1st byte
.b1e9	68		pla			PLA				; pull array name 2nd byte
.b1ea	85 46		sta $46			STA	LAB_46		; restore array name 2nd byte
.b1ec	68		pla			PLA				; pull dimensions count
.b1ed	a8		tay			TAY				; restore it
.b1ee	ba		tsx			TSX				; copy stack pointer
.b1ef	bd 02 01	lda $0102,x		LDA	LAB_0100+2,X	; get DIM flag
.b1f2	48		pha			PHA				; push it
.b1f3	bd 01 01	lda $0101,x		LDA	LAB_0100+1,X	; get data type flag
.b1f6	48		pha			PHA				; push it
.b1f7	a5 64		lda $64			LDA	LAB_64		; get this dimension size high byte
.b1f9	9d 02 01	sta $0102,x		STA	LAB_0100+2,X	; stack before flag bytes
.b1fc	a5 65		lda $65			LDA	LAB_65		; get this dimension size low byte
.b1fe	9d 01 01	sta $0101,x		STA	LAB_0100+1,X	; stack before flag bytes
.b201	c8		iny			INY				; increment dimensions count
.b202	20 79 00	jsr $0079		JSR	LAB_0079		; scan memory
.b205	c9 2c		cmp #$2c		CMP	#','			; compare with ","
.b207	f0 d2		beq $b1db		BEQ	LAB_B1DB		; if found go do next dimension
.b209	84 0b		sty $0b			STY	LAB_0B		; store dimensions count
.b20b	20 f7 ae	jsr $aef7		JSR	LAB_AEF7		; scan for ")", else do syntax error then warm start
.b20e	68		pla			PLA				; pull data type flag
.b20f	85 0d		sta $0d			STA	LAB_0D		; restore data type flag, $FF = string, $00 = numeric
.b211	68		pla			PLA				; pull data type flag
.b212	85 0e		sta $0e			STA	LAB_0E		; restore data type flag, $80 = integer, $00 = float
.b214	29 7f		and #$7f		AND	#$7F			; mask dim flag
.b216	85 0c		sta $0c			STA	LAB_0C		; restore DIM flag
.b218	a6 2f		ldx $2f			LDX	LAB_2F		; set end of variables low byte
.b21a	a5 30		lda $30			LDA	LAB_30		; set end of variables high byte
.b21c					LAB_B21C
.b21c	86 5f		stx $5f			STX	LAB_5F		; save as array start pointer low byte
.b21e	85 60		sta $60			STA	LAB_60		; save as array start pointer high byte
.b220	c5 32		cmp $32			CMP	LAB_32		; compare with end of arrays high byte
.b222	d0 04		bne $b228		BNE	LAB_B228		; branch if not reached array memory end
.b224	e4 31		cpx $31			CPX	LAB_31		; else compare with end of arrays low byte
.b226	f0 39		beq $b261		BEQ	LAB_B261		; go build array if not found
.b228					LAB_B228
.b228	a0 00		ldy #$00		LDY	#$00			; clear index
.b22a	b1 5f		lda ($5f),y		LDA	(LAB_5F),Y		; get array name first byte
.b22c	c8		iny			INY				; increment index to second name byte
.b22d	c5 45		cmp $45			CMP	LAB_45		; compare with this array name first byte
.b22f	d0 06		bne $b237		BNE	LAB_B237		; branch if no match
.b231	a5 46		lda $46			LDA	LAB_46		; else get this array name second byte
.b233	d1 5f		cmp ($5f),y		CMP	(LAB_5F),Y		; compare with array name second byte
.b235	f0 16		beq $b24d		BEQ	LAB_B24D		; array found so branch
.b237					LAB_B237
.b237	c8		iny			INY				; increment index
.b238	b1 5f		lda ($5f),y		LDA	(LAB_5F),Y		; get array size low byte
.b23a	18		clc			CLC				; clear carry for add
.b23b	65 5f		adc $5f			ADC	LAB_5F		; add array start pointer low byte
.b23d	aa		tax			TAX				; copy low byte to X
.b23e	c8		iny			INY				; increment index
.b23f	b1 5f		lda ($5f),y		LDA	(LAB_5F),Y		; get array size high byte
.b241	65 60		adc $60			ADC	LAB_60		; add array memory pointer high byte
.b243	90 d7		bcc $b21c		BCC	LAB_B21C		; if no overflow go check next array
.b245					LAB_B245
.b245	a2 12		ldx #$12		LDX	#$12			; error $12, bad subscript error
>b247	2c					.byte	$2C			; makes next line BIT LAB_0EA2
.b248					LAB_B248
.b248	a2 0e		ldx #$0e		LDX	#$0E			; error $0E, illegal quantity error
.b24a					LAB_B24A
.b24a	4c 37 a4	jmp $a437		JMP	LAB_A437		; do error #X then warm start
.b24d					LAB_B24D
.b24d	a2 13		ldx #$13		LDX	#$13			; set error $13, double dimension error
.b24f	a5 0c		lda $0c			LDA	LAB_0C		; get DIM flag
.b251	d0 f7		bne $b24a		BNE	LAB_B24A		; if we are trying to dimension it do error #X then warm
.b253	20 94 b1	jsr $b194		JSR	LAB_B194		; set-up array pointer to first element in array
.b256	a5 0b		lda $0b			LDA	LAB_0B		; get dimensions count
.b258	a0 04		ldy #$04		LDY	#$04			; set index to array's # of dimensions
.b25a	d1 5f		cmp ($5f),y		CMP	(LAB_5F),Y		; compare with no of dimensions
.b25c	d0 e7		bne $b245		BNE	LAB_B245		; if wrong do bad subscript error
.b25e	4c ea b2	jmp $b2ea		JMP	LAB_B2EA		; found array so go get element
.b261					LAB_B261
.b261	20 94 b1	jsr $b194		JSR	LAB_B194		; set-up array pointer to first element in array
.b264	20 08 a4	jsr $a408		JSR	LAB_A408		; check available memory, do out of memory error if no room
.b267	a0 00		ldy #$00		LDY	#$00			; clear Y
.b269	84 72		sty $72			STY	LAB_72		; clear array data size high byte
.b26b	a2 05		ldx #$05		LDX	#$05			; set default element size
.b26d	a5 45		lda $45			LDA	LAB_45		; get variable name 1st byte
.b26f	91 5f		sta ($5f),y		STA	(LAB_5F),Y		; save array name 1st byte
.b271	10 01		bpl $b274		BPL	LAB_B274		; branch if not string or floating point array
.b273	ca		dex			DEX				; decrement element size, $04
.b274					LAB_B274
.b274	c8		iny			INY				; increment index
.b275	a5 46		lda $46			LDA	LAB_46		; get variable name 2nd byte
.b277	91 5f		sta ($5f),y		STA	(LAB_5F),Y		; save array name 2nd byte
.b279	10 02		bpl $b27d		BPL	LAB_B27D		; branch if not integer or string
.b27b	ca		dex			DEX				; decrement element size, $03
.b27c	ca		dex			DEX				; decrement element size, $02
.b27d					LAB_B27D
.b27d	86 71		stx $71			STX	LAB_71		; save element size
.b27f	a5 0b		lda $0b			LDA	LAB_0B		; get dimensions count
.b281	c8		iny			INY				; increment index ..
.b282	c8		iny			INY				; .. to array  ..
.b283	c8		iny			INY				; .. dimension count
.b284	91 5f		sta ($5f),y		STA	(LAB_5F),Y		; save array dimension count
.b286					LAB_B286
.b286	a2 0b		ldx #$0b		LDX	#$0B			; set default dimension size low byte
.b288	a9 00		lda #$00		LDA	#$00			; set default dimension size high byte
.b28a	24 0c		bit $0c			BIT	LAB_0C		; test DIM flag
.b28c	50 08		bvc $b296		BVC	LAB_B296		; branch if default to be used
.b28e	68		pla			PLA				; pull dimension size low byte
.b28f	18		clc			CLC				; clear carry for add
.b290	69 01		adc #$01		ADC	#$01			; add 1, allow for zeroeth element
.b292	aa		tax			TAX				; copy low byte to X
.b293	68		pla			PLA				; pull dimension size high byte
.b294	69 00		adc #$00		ADC	#$00			; add carry to high byte
.b296					LAB_B296
.b296	c8		iny			INY				; incement index to dimension size high byte
.b297	91 5f		sta ($5f),y		STA	(LAB_5F),Y		; save dimension size high byte
.b299	c8		iny			INY				; incement index to dimension size low byte
.b29a	8a		txa			TXA				; copy dimension size low byte
.b29b	91 5f		sta ($5f),y		STA	(LAB_5F),Y		; save dimension size low byte
.b29d	20 4c b3	jsr $b34c		JSR	LAB_B34C		; compute array size
.b2a0	86 71		stx $71			STX	LAB_71		; save result low byte
.b2a2	85 72		sta $72			STA	LAB_72		; save result high byte
.b2a4	a4 22		ldy $22			LDY	LAB_22		; restore index
.b2a6	c6 0b		dec $0b			DEC	LAB_0B		; decrement dimensions count
.b2a8	d0 dc		bne $b286		BNE	LAB_B286		; loop if not all done
.b2aa	65 59		adc $59			ADC	LAB_59		; add array data pointer high byte
.b2ac	b0 5d		bcs $b30b		BCS	LAB_B30B		; if overflow do out of memory error then warm start
.b2ae	85 59		sta $59			STA	LAB_59		; save array data pointer high byte
.b2b0	a8		tay			TAY				; copy array data pointer high byte
.b2b1	8a		txa			TXA				; copy array size low byte
.b2b2	65 58		adc $58			ADC	LAB_58		; add array data pointer low byte
.b2b4	90 03		bcc $b2b9		BCC	LAB_B2B9		; branch if no rollover
.b2b6	c8		iny			INY				; else increment next array pointer high byte
.b2b7	f0 52		beq $b30b		BEQ	LAB_B30B		; if rolled over do out of memory error then warm start
.b2b9					LAB_B2B9
.b2b9	20 08 a4	jsr $a408		JSR	LAB_A408		; check available memory, do out of memory error if no room
.b2bc	85 31		sta $31			STA	LAB_31		; set end of arrays low byte
.b2be	84 32		sty $32			STY	LAB_32		; set end of arrays high byte
.b2c0	a9 00		lda #$00		LDA	#$00			; clear A for array clear
.b2c2	e6 72		inc $72			INC	LAB_72		; increment array size high byte, now block count
.b2c4	a4 71		ldy $71			LDY	LAB_71		; get array size low byte, now index to block
.b2c6	f0 05		beq $b2cd		BEQ	LAB_B2CD		; branch if $00
.b2c8					LAB_B2C8
.b2c8	88		dey			DEY				; decrement index, do 0 to n-1
.b2c9	91 58		sta ($58),y		STA	(LAB_58),Y		; clear array element byte
.b2cb	d0 fb		bne $b2c8		BNE	LAB_B2C8		; loop until this block done
.b2cd					LAB_B2CD
.b2cd	c6 59		dec $59			DEC	LAB_59		; decrement array pointer high byte
.b2cf	c6 72		dec $72			DEC	LAB_72		; decrement block count high byte
.b2d1	d0 f5		bne $b2c8		BNE	LAB_B2C8		; loop until all blocks done
.b2d3	e6 59		inc $59			INC	LAB_59		; correct for last loop
.b2d5	38		sec			SEC				; set carry for subtract
.b2d6	a5 31		lda $31			LDA	LAB_31		; get end of arrays low byte
.b2d8	e5 5f		sbc $5f			SBC	LAB_5F		; subtract array start low byte
.b2da	a0 02		ldy #$02		LDY	#$02			; index to array size low byte
.b2dc	91 5f		sta ($5f),y		STA	(LAB_5F),Y		; save array size low byte
.b2de	a5 32		lda $32			LDA	LAB_32		; get end of arrays high byte
.b2e0	c8		iny			INY				; index to array size high byte
.b2e1	e5 60		sbc $60			SBC	LAB_60		; subtract array start high byte
.b2e3	91 5f		sta ($5f),y		STA	(LAB_5F),Y		; save array size high byte
.b2e5	a5 0c		lda $0c			LDA	LAB_0C		; get default DIM flag
.b2e7	d0 62		bne $b34b		BNE	LAB_B34B		; exit if this was a DIM command
.b2e9	c8		iny			INY				; set index to # of dimensions, the dimension indeces
.b2ea					LAB_B2EA
.b2ea	b1 5f		lda ($5f),y		LDA	(LAB_5F),Y		; get array's dimension count
.b2ec	85 0b		sta $0b			STA	LAB_0B		; save it
.b2ee	a9 00		lda #$00		LDA	#$00			; clear byte
.b2f0	85 71		sta $71			STA	LAB_71		; clear array data pointer low byte
.b2f2					LAB_B2F2
.b2f2	85 72		sta $72			STA	LAB_72		; save array data pointer high byte
.b2f4	c8		iny			INY				; increment index, point to array bound high byte
.b2f5	68		pla			PLA				; pull array index low byte
.b2f6	aa		tax			TAX				; copy to X
.b2f7	85 64		sta $64			STA	LAB_64		; save index low byte to FAC1 mantissa 3
.b2f9	68		pla			PLA				; pull array index high byte
.b2fa	85 65		sta $65			STA	LAB_65		; save index high byte to FAC1 mantissa 4
.b2fc	d1 5f		cmp ($5f),y		CMP	(LAB_5F),Y		; compare with array bound high byte
.b2fe	90 0e		bcc $b30e		BCC	LAB_B30E		; branch if within bounds
.b300	d0 06		bne $b308		BNE	LAB_B308		; if outside bounds do bad subscript error
.b302	c8		iny			INY				; index to array bound low byte
.b303	8a		txa			TXA				; get array index low byte
.b304	d1 5f		cmp ($5f),y		CMP	(LAB_5F),Y		; compare with array bound low byte
.b306	90 07		bcc $b30f		BCC	LAB_B30F		; branch if within bounds
.b308					LAB_B308
.b308	4c 45 b2	jmp $b245		JMP	LAB_B245		; do bad subscript error
.b30b					LAB_B30B
.b30b	4c 35 a4	jmp $a435		JMP	LAB_A435		; do out of memory error then warm start
.b30e					LAB_B30E
.b30e	c8		iny			INY				; index to array bound low byte
.b30f					LAB_B30F
.b30f	a5 72		lda $72			LDA	LAB_72		; get array data pointer high byte
.b311	05 71		ora $71			ORA	LAB_71		; OR with array data pointer low byte
.b313	18		clc			CLC				; clear carry for either add, carry always clear here ??
.b314	f0 0a		beq $b320		BEQ	LAB_B320		; branch if array data pointer = null, skip multiply
.b316	20 4c b3	jsr $b34c		JSR	LAB_B34C		; compute array size
.b319	8a		txa			TXA				; get result low byte
.b31a	65 64		adc $64			ADC	LAB_64		; add index low byte from FAC1 mantissa 3
.b31c	aa		tax			TAX				; save result low byte
.b31d	98		tya			TYA				; get result high byte
.b31e	a4 22		ldy $22			LDY	LAB_22		; restore index
.b320					LAB_B320
.b320	65 65		adc $65			ADC	LAB_65		; add index high byte from FAC1 mantissa 4
.b322	86 71		stx $71			STX	LAB_71		; save array data pointer low byte
.b324	c6 0b		dec $0b			DEC	LAB_0B		; decrement dimensions count
.b326	d0 ca		bne $b2f2		BNE	LAB_B2F2		; loop if dimensions still to do
.b328	85 72		sta $72			STA	LAB_72		; save array data pointer high byte
.b32a	a2 05		ldx #$05		LDX	#$05			; set default element size
.b32c	a5 45		lda $45			LDA	LAB_45		; get variable name 1st byte
.b32e	10 01		bpl $b331		BPL	LAB_B331		; branch if not string or floating point array
.b330	ca		dex			DEX				; decrement element size, $04
.b331					LAB_B331
.b331	a5 46		lda $46			LDA	LAB_46		; get variable name 2nd byte
.b333	10 02		bpl $b337		BPL	LAB_B337		; branch if not integer or string
.b335	ca		dex			DEX				; decrement element size, $03
.b336	ca		dex			DEX				; decrement element size, $02
.b337					LAB_B337
.b337	86 28		stx $28			STX	LAB_28		; save dimension size low byte
.b339	a9 00		lda #$00		LDA	#$00			; clear dimension size high byte
.b33b	20 55 b3	jsr $b355		JSR	LAB_B355		; compute array size
.b33e	8a		txa			TXA				; copy array size low byte
.b33f	65 58		adc $58			ADC	LAB_58		; add array data start pointer low byte
.b341	85 47		sta $47			STA	LAB_47		; save as current variable pointer low byte
.b343	98		tya			TYA				; copy array size high byte
.b344	65 59		adc $59			ADC	LAB_59		; add array data start pointer high byte
.b346	85 48		sta $48			STA	LAB_48		; save as current variable pointer high byte
.b348	a8		tay			TAY				; copy high byte to Y
.b349	a5 47		lda $47			LDA	LAB_47		; get current variable pointer low byte
.b34b					LAB_B34B
.b34b	60		rts			RTS
.b34c					LAB_B34C
.b34c	84 22		sty $22			STY	LAB_22		; save index
.b34e	b1 5f		lda ($5f),y		LDA	(LAB_5F),Y		; get dimension size low byte
.b350	85 28		sta $28			STA	LAB_28		; save dimension size low byte
.b352	88		dey			DEY				; decrement index
.b353	b1 5f		lda ($5f),y		LDA	(LAB_5F),Y		; get dimension size high byte
.b355					LAB_B355
.b355	85 29		sta $29			STA	LAB_29		; save dimension size high byte
.b357	a9 10		lda #$10		LDA	#$10			; count = $10 (16 bit multiply)
.b359	85 5d		sta $5d			STA	LAB_5D		; save bit count
.b35b	a2 00		ldx #$00		LDX	#$00			; clear result low byte
.b35d	a0 00		ldy #$00		LDY	#$00			; clear result high byte
.b35f					LAB_B35F
.b35f	8a		txa			TXA				; get result low byte
.b360	0a		asl a			ASL				; *2
.b361	aa		tax			TAX				; save result low byte
.b362	98		tya			TYA				; get result high byte
.b363	2a		rol a			ROL				; *2
.b364	a8		tay			TAY				; save result high byte
.b365	b0 a4		bcs $b30b		BCS	LAB_B30B		; if overflow go do "Out of memory" error
.b367	06 71		asl $71			ASL	LAB_71		; shift element size low byte
.b369	26 72		rol $72			ROL	LAB_72		; shift element size high byte
.b36b	90 0b		bcc $b378		BCC	LAB_B378		; skip add if no carry
.b36d	18		clc			CLC				; else clear carry for add
.b36e	8a		txa			TXA				; get result low byte
.b36f	65 28		adc $28			ADC	LAB_28		; add dimension size low byte
.b371	aa		tax			TAX				; save result low byte
.b372	98		tya			TYA				; get result high byte
.b373	65 29		adc $29			ADC	LAB_29		; add dimension size high byte
.b375	a8		tay			TAY				; save result high byte
.b376	b0 93		bcs $b30b		BCS	LAB_B30B		; if overflow go do "Out of memory" error
.b378					LAB_B378
.b378	c6 5d		dec $5d			DEC	LAB_5D		; decrement bit count
.b37a	d0 e3		bne $b35f		BNE	LAB_B35F		; loop until all done
.b37c	60		rts			RTS
.b37d					LAB_B37D
.b37d	a5 0d		lda $0d			LDA	LAB_0D		; get data type flag, $FF = string, $00 = numeric
.b37f	f0 03		beq $b384		BEQ	LAB_B384		; branch if numeric
.b381	20 a6 b6	jsr $b6a6		JSR	LAB_B6A6		; pop string off descriptor stack, or from top of string
.b384					LAB_B384
.b384	20 26 b5	jsr $b526		JSR	LAB_B526		; go do garbage collection
.b387	38		sec			SEC				; set carry for subtract
.b388	a5 33		lda $33			LDA	LAB_33		; get bottom of string space low byte
.b38a	e5 31		sbc $31			SBC	LAB_31		; subtract end of arrays low byte
.b38c	a8		tay			TAY				; copy result to Y
.b38d	a5 34		lda $34			LDA	LAB_34		; get bottom of string space high byte
.b38f	e5 32		sbc $32			SBC	LAB_32		; subtract end of arrays high byte
.b391					LAB_B391
.b391	a2 00		ldx #$00		LDX	#$00			; set type = numeric
.b393	86 0d		stx $0d			STX	LAB_0D		; clear data type flag, $FF = string, $00 = numeric
.b395	85 62		sta $62			STA	LAB_62		; save FAC1 mantissa 1
.b397	84 63		sty $63			STY	LAB_63		; save FAC1 mantissa 2
.b399	a2 90		ldx #$90		LDX	#$90			; set exponent=2^16 (integer)
.b39b	4c 44 bc	jmp $bc44		JMP	LAB_BC44		; set exp = X, clear FAC1 3 and 4, normalise and return
.b39e					LAB_B39E
.b39e	38		sec			SEC				; set Cb for read cursor position
.b39f	20 f0 ff	jsr $fff0		JSR	LAB_FFF0		; read/set X,Y cursor position
.b3a2					LAB_B3A2
.b3a2	a9 00		lda #$00		LDA	#$00			; clear high byte
.b3a4	f0 eb		beq $b391		BEQ	LAB_B391		; convert fixed integer AY to float FAC1, branch always
.b3a6					LAB_B3A6
.b3a6	a6 3a		ldx $3a			LDX	LAB_3A		; get current line number high byte
.b3a8	e8		inx			INX				; increment it
.b3a9	d0 a0		bne $b34b		BNE	LAB_B34B		; return if not direct mode
.b3ab	a2 15		ldx #$15		LDX	#$15			; error $15, illegal direct error
>b3ad	2c					.byte	$2C			; makes next line BIT LAB_1BA2
.b3ae					LAB_B3AE
.b3ae	a2 1b		ldx #$1b		LDX	#$1B			; error $1B, undefined function error
.b3b0	4c 37 a4	jmp $a437		JMP	LAB_A437		; do error #X then warm start
.b3b3					LAB_B3B3
.b3b3	20 e1 b3	jsr $b3e1		JSR	LAB_B3E1		; check FNx syntax
.b3b6	20 a6 b3	jsr $b3a6		JSR	LAB_B3A6		; check not direct, back here if ok
.b3b9	20 fa ae	jsr $aefa		JSR	LAB_AEFA		; scan for "(", else do syntax error then warm start
.b3bc	a9 80		lda #$80		LDA	#$80			; set flag for FNx
.b3be	85 10		sta $10			STA	LAB_10		; save subscript/FNx flag
.b3c0	20 8b b0	jsr $b08b		JSR	LAB_B08B		; get variable address
.b3c3	20 8d ad	jsr $ad8d		JSR	LAB_AD8D		; check if source is numeric, else do type mismatch
.b3c6	20 f7 ae	jsr $aef7		JSR	LAB_AEF7		; scan for ")", else do syntax error then warm start
.b3c9	a9 b2		lda #$b2		LDA	#TK_EQUAL		; get = token
.b3cb	20 ff ae	jsr $aeff		JSR	LAB_AEFF		; scan for CHR$(A), else do syntax error then warm start
.b3ce	48		pha			PHA				; push next character
.b3cf	a5 48		lda $48			LDA	LAB_48		; get current variable pointer high byte
.b3d1	48		pha			PHA				; push it
.b3d2	a5 47		lda $47			LDA	LAB_47		; get current variable pointer low byte
.b3d4	48		pha			PHA				; push it
.b3d5	a5 7b		lda $7b			LDA	LAB_7B		; get BASIC execute pointer high byte
.b3d7	48		pha			PHA				; push it
.b3d8	a5 7a		lda $7a			LDA	LAB_7A		; get BASIC execute pointer low byte
.b3da	48		pha			PHA				; push it
.b3db	20 f8 a8	jsr $a8f8		JSR	LAB_A8F8		; perform DATA
.b3de	4c 4f b4	jmp $b44f		JMP	LAB_B44F		; put execute pointer and variable pointer into function
.b3e1					LAB_B3E1
.b3e1	a9 a5		lda #$a5		LDA	#TK_FN		; set FN token
.b3e3	20 ff ae	jsr $aeff		JSR	LAB_AEFF		; scan for CHR$(A), else do syntax error then warm start
.b3e6	09 80		ora #$80		ORA	#$80			; set FN flag bit
.b3e8	85 10		sta $10			STA	LAB_10		; save FN name
.b3ea	20 92 b0	jsr $b092		JSR	LAB_B092		; search for FN variable
.b3ed	85 4e		sta $4e			STA	LAB_4E		; save function pointer low byte
.b3ef	84 4f		sty $4f			STY	LAB_4F		; save function pointer high byte
.b3f1	4c 8d ad	jmp $ad8d		JMP	LAB_AD8D		; check if source is numeric and return, else do type
.b3f4					LAB_B3F4
.b3f4	20 e1 b3	jsr $b3e1		JSR	LAB_B3E1		; check FNx syntax
.b3f7	a5 4f		lda $4f			LDA	LAB_4F		; get function pointer high byte
.b3f9	48		pha			PHA				; push it
.b3fa	a5 4e		lda $4e			LDA	LAB_4E		; get function pointer low byte
.b3fc	48		pha			PHA				; push it
.b3fd	20 f1 ae	jsr $aef1		JSR	LAB_AEF1		; evaluate expression within parentheses
.b400	20 8d ad	jsr $ad8d		JSR	LAB_AD8D		; check if source is numeric, else do type mismatch
.b403	68		pla			PLA				; pop function pointer low byte
.b404	85 4e		sta $4e			STA	LAB_4E		; restore it
.b406	68		pla			PLA				; pop function pointer high byte
.b407	85 4f		sta $4f			STA	LAB_4F		; restore it
.b409	a0 02		ldy #$02		LDY	#$02			; index to variable pointer high byte
.b40b	b1 4e		lda ($4e),y		LDA	(LAB_4E),Y		; get variable address low byte
.b40d	85 47		sta $47			STA	LAB_47		; save current variable pointer low byte
.b40f	aa		tax			TAX				; copy address low byte
.b410	c8		iny			INY				; index to variable address high byte
.b411	b1 4e		lda ($4e),y		LDA	(LAB_4E),Y		; get variable pointer high byte
.b413	f0 99		beq $b3ae		BEQ	LAB_B3AE		; branch if high byte zero
.b415	85 48		sta $48			STA	LAB_48		; save current variable pointer high byte
.b417	c8		iny			INY				; index to mantissa 3
.b418					LAB_B418
.b418	b1 47		lda ($47),y		LDA	(LAB_47),Y		; get byte from variable
.b41a	48		pha			PHA				; stack it
.b41b	88		dey			DEY				; decrement index
.b41c	10 fa		bpl $b418		BPL	LAB_B418		; loop until variable stacked
.b41e	a4 48		ldy $48			LDY	LAB_48		; get current variable pointer high byte
.b420	20 d4 bb	jsr $bbd4		JSR	LAB_BBD4		; pack FAC1 into (XY)
.b423	a5 7b		lda $7b			LDA	LAB_7B		; get BASIC execute pointer high byte
.b425	48		pha			PHA				; push it
.b426	a5 7a		lda $7a			LDA	LAB_7A		; get BASIC execute pointer low byte
.b428	48		pha			PHA				; push it
.b429	b1 4e		lda ($4e),y		LDA	(LAB_4E),Y		; get function execute pointer low byte
.b42b	85 7a		sta $7a			STA	LAB_7A		; save BASIC execute pointer low byte
.b42d	c8		iny			INY				; index to high byte
.b42e	b1 4e		lda ($4e),y		LDA	(LAB_4E),Y		; get function execute pointer high byte
.b430	85 7b		sta $7b			STA	LAB_7B		; save BASIC execute pointer high byte
.b432	a5 48		lda $48			LDA	LAB_48		; get current variable pointer high byte
.b434	48		pha			PHA				; push it
.b435	a5 47		lda $47			LDA	LAB_47		; get current variable pointer low byte
.b437	48		pha			PHA				; push it
.b438	20 8a ad	jsr $ad8a		JSR	LAB_AD8A		; evaluate expression and check is numeric, else do
.b43b	68		pla			PLA				; pull variable address low byte
.b43c	85 4e		sta $4e			STA	LAB_4E		; save variable address low byte
.b43e	68		pla			PLA				; pull variable address high byte
.b43f	85 4f		sta $4f			STA	LAB_4F		; save variable address high byte
.b441	20 79 00	jsr $0079		JSR	LAB_0079		; scan memory
.b444	f0 03		beq $b449		BEQ	LAB_B449		; branch if null (should be [EOL] marker)
.b446	4c 08 af	jmp $af08		JMP	LAB_AF08		; else syntax error then warm start
.b449					LAB_B449
.b449	68		pla			PLA				; pull BASIC execute pointer low byte
.b44a	85 7a		sta $7a			STA	LAB_7A		; save BASIC execute pointer low byte
.b44c	68		pla			PLA				; pull BASIC execute pointer high byte
.b44d	85 7b		sta $7b			STA	LAB_7B		; save BASIC execute pointer high byte
.b44f					LAB_B44F
.b44f	a0 00		ldy #$00		LDY	#$00			; clear index
.b451	68		pla			PLA				; pull BASIC execute pointer low byte
.b452	91 4e		sta ($4e),y		STA	(LAB_4E),Y		; save to function
.b454	68		pla			PLA				; pull BASIC execute pointer high byte
.b455	c8		iny			INY				; increment index
.b456	91 4e		sta ($4e),y		STA	(LAB_4E),Y		; save to function
.b458	68		pla			PLA				; pull current variable address low byte
.b459	c8		iny			INY				; increment index
.b45a	91 4e		sta ($4e),y		STA	(LAB_4E),Y		; save to function
.b45c	68		pla			PLA				; pull current variable address high byte
.b45d	c8		iny			INY				; increment index
.b45e	91 4e		sta ($4e),y		STA	(LAB_4E),Y		; save to function
.b460	68		pla			PLA				; pull ??
.b461	c8		iny			INY				; increment index
.b462	91 4e		sta ($4e),y		STA	(LAB_4E),Y		; save to function
.b464	60		rts			RTS
.b465					LAB_B465
.b465	20 8d ad	jsr $ad8d		JSR	LAB_AD8D		; check if source is numeric, else do type mismatch
.b468	a0 00		ldy #$00		LDY	#$00			; set string index
.b46a	20 df bd	jsr $bddf		JSR	LAB_BDDF		; convert FAC1 to string
.b46d	68		pla			PLA				; dump return address (skip type check)
.b46e	68		pla			PLA				; dump return address (skip type check)
.b46f					LAB_B46F
.b46f	a9 ff		lda #$ff		LDA	#<LAB_FF		; set result string low pointer
.b471	a0 00		ldy #$00		LDY	#>LAB_FF		; set result string high pointer
.b473	f0 12		beq $b487		BEQ	LAB_B487		; print null terminated string to utility pointer
.b475					LAB_B475
.b475	a6 64		ldx $64			LDX	LAB_64		; get descriptor pointer low byte
.b477	a4 65		ldy $65			LDY	LAB_65		; get descriptor pointer high byte
.b479	86 50		stx $50			STX	LAB_50		; save descriptor pointer low byte
.b47b	84 51		sty $51			STY	LAB_51		; save descriptor pointer high byte
.b47d					LAB_B47D
.b47d	20 f4 b4	jsr $b4f4		JSR	LAB_B4F4		; make space in string memory for string A long
.b480	86 62		stx $62			STX	LAB_62		; save string pointer low byte
.b482	84 63		sty $63			STY	LAB_63		; save string pointer high byte
.b484	85 61		sta $61			STA	LAB_61		; save length
.b486	60		rts			RTS
.b487					LAB_B487
.b487	a2 22		ldx #$22		LDX	#$22			; set terminator to "
.b489	86 07		stx $07			STX	LAB_07		; set search character, terminator 1
.b48b	86 08		stx $08			STX	LAB_08		; set terminator 2
.b48d					LAB_B48D
.b48d	85 6f		sta $6f			STA	LAB_6F		; store string start low byte
.b48f	84 70		sty $70			STY	LAB_70		; store string start high byte
.b491	85 62		sta $62			STA	LAB_62		; save string pointer low byte
.b493	84 63		sty $63			STY	LAB_63		; save string pointer high byte
.b495	a0 ff		ldy #$ff		LDY	#$FF			; set length to -1
.b497					LAB_B497
.b497	c8		iny			INY				; increment length
.b498	b1 6f		lda ($6f),y		LDA	(LAB_6F),Y		; get byte from string
.b49a	f0 0c		beq $b4a8		BEQ	LAB_B4A8		; exit loop if null byte [EOS]
.b49c	c5 07		cmp $07			CMP	LAB_07		; compare with search character, terminator 1
.b49e	f0 04		beq $b4a4		BEQ	LAB_B4A4		; branch if terminator
.b4a0	c5 08		cmp $08			CMP	LAB_08		; compare with terminator 2
.b4a2	d0 f3		bne $b497		BNE	LAB_B497		; loop if not terminator 2
.b4a4					LAB_B4A4
.b4a4	c9 22		cmp #$22		CMP	#$22			; compare with "
.b4a6	f0 01		beq $b4a9		BEQ	LAB_B4A9		; branch if " (carry set if = !)
.b4a8					LAB_B4A8
.b4a8	18		clc			CLC				; clear carry for add (only if [EOL] terminated string)
.b4a9					LAB_B4A9
.b4a9	84 61		sty $61			STY	LAB_61		; save length in FAC1 exponent
.b4ab	98		tya			TYA				; copy length to A
.b4ac	65 6f		adc $6f			ADC	LAB_6F		; add string start low byte
.b4ae	85 71		sta $71			STA	LAB_71		; save string end low byte
.b4b0	a6 70		ldx $70			LDX	LAB_70		; get string start high byte
.b4b2	90 01		bcc $b4b5		BCC	LAB_B4B5		; branch if no low byte overflow
.b4b4	e8		inx			INX				; else increment high byte
.b4b5					LAB_B4B5
.b4b5	86 72		stx $72			STX	LAB_72		; save string end high byte
.b4b7	a5 70		lda $70			LDA	LAB_70		; get string start high byte
.b4b9	f0 04		beq $b4bf		BEQ	LAB_B4BF		; branch if in utility area
.b4bb	c9 02		cmp #$02		CMP	#$02			; compare with input buffer memory high byte
.b4bd	d0 0b		bne $b4ca		BNE	LAB_B4CA		; branch if not in input buffer memory
.b4bf					LAB_B4BF
.b4bf	98		tya			TYA				; copy length to A
.b4c0	20 75 b4	jsr $b475		JSR	LAB_B475		; copy descriptor pointer and make string space A bytes long
.b4c3	a6 6f		ldx $6f			LDX	LAB_6F		; get string start low byte
.b4c5	a4 70		ldy $70			LDY	LAB_70		; get string start high byte
.b4c7	20 88 b6	jsr $b688		JSR	LAB_B688		; store string A bytes long from XY to utility pointer
.b4ca					LAB_B4CA
.b4ca	a6 16		ldx $16			LDX	LAB_16		; get the descriptor stack pointer
.b4cc	e0 22		cpx #$22		CPX	#LAB_19+9		; compare it with the maximum + 1
.b4ce	d0 05		bne $b4d5		BNE	LAB_B4D5		; if there is space on the string stack continue
.b4d0	a2 19		ldx #$19		LDX	#$19			; error $19, string too complex error
.b4d2					LAB_B4D2
.b4d2	4c 37 a4	jmp $a437		JMP	LAB_A437		; do error #X then warm start
.b4d5					LAB_B4D5
.b4d5	a5 61		lda $61			LDA	LAB_61		; get the string length
.b4d7	95 00		sta $00,x		STA	LAB_00,X		; put it on the string stack
.b4d9	a5 62		lda $62			LDA	LAB_62		; get the string pointer low byte
.b4db	95 01		sta $01,x		STA	LAB_00+1,X		; put it on the string stack
.b4dd	a5 63		lda $63			LDA	LAB_63		; get the string pointer high byte
.b4df	95 02		sta $02,x		STA	LAB_00+2,X		; put it on the string stack
.b4e1	a0 00		ldy #$00		LDY	#$00			; clear Y
.b4e3	86 64		stx $64			STX	LAB_64		; save the string descriptor pointer low byte
.b4e5	84 65		sty $65			STY	LAB_65		; save the string descriptor pointer high byte, always $00
.b4e7	84 70		sty $70			STY	LAB_70		; clear FAC1 rounding byte
.b4e9	88		dey			DEY				; Y = $FF
.b4ea	84 0d		sty $0d			STY	LAB_0D		; save the data type flag, $FF = string
.b4ec	86 17		stx $17			STX	LAB_17		; save the current descriptor stack item pointer low byte
.b4ee	e8		inx			INX				; update the stack pointer
.b4ef	e8		inx			INX				; update the stack pointer
.b4f0	e8		inx			INX				; update the stack pointer
.b4f1	86 16		stx $16			STX	LAB_16		; save the new descriptor stack pointer
.b4f3	60		rts			RTS
.b4f4					LAB_B4F4
.b4f4	46 0f		lsr $0f			LSR	LAB_0F		; clear garbage collected flag (b7)
.b4f6					LAB_B4F6
.b4f6	48		pha			PHA				; save string length
.b4f7	49 ff		eor #$ff		EOR	#$FF			; complement it
.b4f9	38		sec			SEC				; set carry for subtract, two's complement add
.b4fa	65 33		adc $33			ADC	LAB_33		; add bottom of string space low byte, subtract length
.b4fc	a4 34		ldy $34			LDY	LAB_34		; get bottom of string space high byte
.b4fe	b0 01		bcs $b501		BCS	LAB_B501		; skip decrement if no underflow
.b500	88		dey			DEY				; decrement bottom of string space high byte
.b501					LAB_B501
.b501	c4 32		cpy $32			CPY	LAB_32		; compare with end of arrays high byte
.b503	90 11		bcc $b516		BCC	LAB_B516		; do out of memory error if less
.b505	d0 04		bne $b50b		BNE	LAB_B50B		; if not = skip next test
.b507	c5 31		cmp $31			CMP	LAB_31		; compare with end of arrays low byte
.b509	90 0b		bcc $b516		BCC	LAB_B516		; do out of memory error if less
.b50b					LAB_B50B
.b50b	85 33		sta $33			STA	LAB_33		; save bottom of string space low byte
.b50d	84 34		sty $34			STY	LAB_34		; save bottom of string space high byte
.b50f	85 35		sta $35			STA	LAB_35		; save string utility ptr low byte
.b511	84 36		sty $36			STY	LAB_36		; save string utility ptr high byte
.b513	aa		tax			TAX				; copy low byte to X
.b514	68		pla			PLA				; get string length back
.b515	60		rts			RTS
.b516					LAB_B516
.b516	a2 10		ldx #$10		LDX	#$10			; error code $10, out of memory error
.b518	a5 0f		lda $0f			LDA	LAB_0F		; get garbage collected flag
.b51a	30 b6		bmi $b4d2		BMI	LAB_B4D2		; if set then do error code X
.b51c	20 26 b5	jsr $b526		JSR	LAB_B526		; else go do garbage collection
.b51f	a9 80		lda #$80		LDA	#$80			; flag for garbage collected
.b521	85 0f		sta $0f			STA	LAB_0F		; set garbage collected flag
.b523	68		pla			PLA				; pull length
.b524	d0 d0		bne $b4f6		BNE	LAB_B4F6		; go try again (loop always, length should never be = $00)
.b526					LAB_B526
.b526	a6 37		ldx $37			LDX	LAB_37		; get end of memory low byte
.b528	a5 38		lda $38			LDA	LAB_38		; get end of memory high byte
.b52a					LAB_B52A
.b52a	86 33		stx $33			STX	LAB_33		; set bottom of string space low byte
.b52c	85 34		sta $34			STA	LAB_34		; set bottom of string space high byte
.b52e	a0 00		ldy #$00		LDY	#$00			; clear index
.b530	84 4f		sty $4f			STY	LAB_4F		; clear working pointer high byte
.b532	84 4e		sty $4e			STY	LAB_4E		; clear working pointer low byte
.b534	a5 31		lda $31			LDA	LAB_31		; get end of arrays low byte
.b536	a6 32		ldx $32			LDX	LAB_32		; get end of arrays high byte
.b538	85 5f		sta $5f			STA	LAB_5F		; save as highest uncollected string pointer low byte
.b53a	86 60		stx $60			STX	LAB_60		; save as highest uncollected string pointer high byte
.b53c	a9 19		lda #$19		LDA	#LAB_19		; set descriptor stack pointer
.b53e	a2 00		ldx #$00		LDX	#$00			; clear X
.b540	85 22		sta $22			STA	LAB_22		; save descriptor stack pointer low byte
.b542	86 23		stx $23			STX	LAB_23		; save descriptor stack pointer high byte ($00)
.b544					LAB_B544
.b544	c5 16		cmp $16			CMP	LAB_16		; compare with descriptor stack pointer
.b546	f0 05		beq $b54d		BEQ	LAB_B54D		; branch if =
.b548	20 c7 b5	jsr $b5c7		JSR	LAB_B5C7		; check string salvageability
.b54b	f0 f7		beq $b544		BEQ	LAB_B544		; loop always
.b54d					LAB_B54D
.b54d	a9 07		lda #$07		LDA	#$07			; set step size = $07, collecting variables
.b54f	85 53		sta $53			STA	LAB_53		; save garbage collection step size
.b551	a5 2d		lda $2d			LDA	LAB_2D		; get start of variables low byte
.b553	a6 2e		ldx $2e			LDX	LAB_2E		; get start of variables high byte
.b555	85 22		sta $22			STA	LAB_22		; save as pointer low byte
.b557	86 23		stx $23			STX	LAB_23		; save as pointer high byte
.b559					LAB_B559
.b559	e4 30		cpx $30			CPX	LAB_30		; compare end of variables high byte,
.b55b	d0 04		bne $b561		BNE	LAB_B561		; branch if no high byte match
.b55d	c5 2f		cmp $2f			CMP	LAB_2F		; else compare end of variables low byte,
.b55f	f0 05		beq $b566		BEQ	LAB_B566		; branch if = variable memory end
.b561					LAB_B561
.b561	20 bd b5	jsr $b5bd		JSR	LAB_B5BD		; check variable salvageability
.b564	f0 f3		beq $b559		BEQ	LAB_B559		; loop always
.b566					LAB_B566
.b566	85 58		sta $58			STA	LAB_58		; save start of arrays low byte as working pointer
.b568	86 59		stx $59			STX	LAB_59		; save start of arrays high byte as working pointer
.b56a	a9 03		lda #$03		LDA	#$03			; set step size, collecting descriptors
.b56c	85 53		sta $53			STA	LAB_53		; save step size
.b56e					LAB_B56E
.b56e	a5 58		lda $58			LDA	LAB_58		; get pointer low byte
.b570	a6 59		ldx $59			LDX	LAB_59		; get pointer high byte
.b572					LAB_B572
.b572	e4 32		cpx $32			CPX	LAB_32		; compare with end of arrays high byte
.b574	d0 07		bne $b57d		BNE	LAB_B57D		; branch if not at end
.b576	c5 31		cmp $31			CMP	LAB_31		; else compare with end of arrays low byte
.b578	d0 03		bne $b57d		BNE	LAB_B57D		; branch if not at end
.b57a	4c 06 b6	jmp $b606		JMP	LAB_B606		; collect string, tidy up and exit if at end ??
.b57d					LAB_B57D
.b57d	85 22		sta $22			STA	LAB_22		; save pointer low byte
.b57f	86 23		stx $23			STX	LAB_23		; save pointer high byte
.b581	a0 00		ldy #$00		LDY	#$00			; set index
.b583	b1 22		lda ($22),y		LDA	(LAB_22),Y		; get array name first byte
.b585	aa		tax			TAX				; copy it
.b586	c8		iny			INY				; increment index
.b587	b1 22		lda ($22),y		LDA	(LAB_22),Y		; get array name second byte
.b589	08		php			PHP				; push the flags
.b58a	c8		iny			INY				; increment index
.b58b	b1 22		lda ($22),y		LDA	(LAB_22),Y		; get array size low byte
.b58d	65 58		adc $58			ADC	LAB_58		; add start of this array low byte
.b58f	85 58		sta $58			STA	LAB_58		; save start of next array low byte
.b591	c8		iny			INY				; increment index
.b592	b1 22		lda ($22),y		LDA	(LAB_22),Y		; get array size high byte
.b594	65 59		adc $59			ADC	LAB_59		; add start of this array high byte
.b596	85 59		sta $59			STA	LAB_59		; save start of next array high byte
.b598	28		plp			PLP				; restore the flags
.b599	10 d3		bpl $b56e		BPL	LAB_B56E		; skip if not string array
.b59b	8a		txa			TXA				; get name first byte back
.b59c	30 d0		bmi $b56e		BMI	LAB_B56E		; skip if not string array
.b59e	c8		iny			INY				; increment index
.b59f	b1 22		lda ($22),y		LDA	(LAB_22),Y		; get # of dimensions
.b5a1	a0 00		ldy #$00		LDY	#$00			; clear index
.b5a3	0a		asl a			ASL				; *2
.b5a4	69 05		adc #$05		ADC	#$05			; +5 (array header size)
.b5a6	65 22		adc $22			ADC	LAB_22		; add pointer low byte
.b5a8	85 22		sta $22			STA	LAB_22		; save pointer low byte
.b5aa	90 02		bcc $b5ae		BCC	LAB_B5AE		; branch if no rollover
.b5ac	e6 23		inc $23			INC	LAB_23		; else increment pointer hgih byte
.b5ae					LAB_B5AE
.b5ae	a6 23		ldx $23			LDX	LAB_23		; get pointer high byte
.b5b0					LAB_B5B0
.b5b0	e4 59		cpx $59			CPX	LAB_59		; compare pointer high byte with end of this array high byte
.b5b2	d0 04		bne $b5b8		BNE	LAB_B5B8		; branch if not there yet
.b5b4	c5 58		cmp $58			CMP	LAB_58		; compare pointer low byte with end of this array low byte
.b5b6	f0 ba		beq $b572		BEQ	LAB_B572		; if at end of this array go check next array
.b5b8					LAB_B5B8
.b5b8	20 c7 b5	jsr $b5c7		JSR	LAB_B5C7		; check string salvageability
.b5bb	f0 f3		beq $b5b0		BEQ	LAB_B5B0		; loop
.b5bd					LAB_B5BD
.b5bd	b1 22		lda ($22),y		LDA	(LAB_22),Y		; get variable name first byte
.b5bf	30 35		bmi $b5f6		BMI	LAB_B5F6		; add step and exit if not string
.b5c1	c8		iny			INY				; increment index
.b5c2	b1 22		lda ($22),y		LDA	(LAB_22),Y		; get variable name second byte
.b5c4	10 30		bpl $b5f6		BPL	LAB_B5F6		; add step and exit if not string
.b5c6	c8		iny			INY				; increment index
.b5c7					LAB_B5C7
.b5c7	b1 22		lda ($22),y		LDA	(LAB_22),Y		; get string length
.b5c9	f0 2b		beq $b5f6		BEQ	LAB_B5F6		; add step and exit if null string
.b5cb	c8		iny			INY				; increment index
.b5cc	b1 22		lda ($22),y		LDA	(LAB_22),Y		; get string pointer low byte
.b5ce	aa		tax			TAX				; copy to X
.b5cf	c8		iny			INY				; increment index
.b5d0	b1 22		lda ($22),y		LDA	(LAB_22),Y		; get string pointer high byte
.b5d2	c5 34		cmp $34			CMP	LAB_34		; compare string pointer high byte with bottom of string
.b5d4	90 06		bcc $b5dc		BCC	LAB_B5DC		; if bottom of string space greater go test against highest
.b5d6	d0 1e		bne $b5f6		BNE	LAB_B5F6		; if bottom of string space less string has been collected
.b5d8	e4 33		cpx $33			CPX	LAB_33		; compare string pointer low byte with bottom of string
.b5da	b0 1a		bcs $b5f6		BCS	LAB_B5F6		; if bottom of string space less string has been collected
.b5dc					LAB_B5DC
.b5dc	c5 60		cmp $60			CMP	LAB_60		; compare string pointer high byte with highest uncollected
.b5de	90 16		bcc $b5f6		BCC	LAB_B5F6		; if highest uncollected string is greater then go update
.b5e0	d0 04		bne $b5e6		BNE	LAB_B5E6		; if highest uncollected string is less then go set this
.b5e2	e4 5f		cpx $5f			CPX	LAB_5F		; compare string pointer low byte with highest uncollected
.b5e4	90 10		bcc $b5f6		BCC	LAB_B5F6		; if highest uncollected string is greater then go update
.b5e6					LAB_B5E6
.b5e6	86 5f		stx $5f			STX	LAB_5F		; save string pointer low byte as highest uncollected string
.b5e8	85 60		sta $60			STA	LAB_60		; save string pointer high byte as highest uncollected
.b5ea	a5 22		lda $22			LDA	LAB_22		; get descriptor pointer low byte
.b5ec	a6 23		ldx $23			LDX	LAB_23		; get descriptor pointer high byte
.b5ee	85 4e		sta $4e			STA	LAB_4E		; save working pointer high byte
.b5f0	86 4f		stx $4f			STX	LAB_4F		; save working pointer low byte
.b5f2	a5 53		lda $53			LDA	LAB_53		; get step size
.b5f4	85 55		sta $55			STA	LAB_55		; copy step size
.b5f6					LAB_B5F6
.b5f6	a5 53		lda $53			LDA	LAB_53		; get step size
.b5f8	18		clc			CLC				; clear carry for add
.b5f9	65 22		adc $22			ADC	LAB_22		; add pointer low byte
.b5fb	85 22		sta $22			STA	LAB_22		; save pointer low byte
.b5fd	90 02		bcc $b601		BCC	LAB_B601		; branch if no rollover
.b5ff	e6 23		inc $23			INC	LAB_23		; else increment pointer high byte
.b601					LAB_B601
.b601	a6 23		ldx $23			LDX	LAB_23		; get pointer high byte
.b603	a0 00		ldy #$00		LDY	#$00			; flag not moved
.b605	60		rts			RTS
.b606					LAB_B606
.b606	a5 4f		lda $4f			LDA	LAB_4F		; get working pointer low byte
.b608	05 4e		ora $4e			ORA	LAB_4E		; OR working pointer high byte
.b60a	f0 f5		beq $b601		BEQ	LAB_B601		; exit if nothing to collect
.b60c	a5 55		lda $55			LDA	LAB_55		; get copied step size
.b60e	29 04		and #$04		AND	#$04			; mask step size, $04 for variables, $00 for array or stack
.b610	4a		lsr a			LSR				; >> 1
.b611	a8		tay			TAY				; copy to index
.b612	85 55		sta $55			STA	LAB_55		; save offset to descriptor start
.b614	b1 4e		lda ($4e),y		LDA	(LAB_4E),Y		; get string length low byte
.b616	65 5f		adc $5f			ADC	LAB_5F		; add string start low byte
.b618	85 5a		sta $5a			STA	LAB_5A		; set block end low byte
.b61a	a5 60		lda $60			LDA	LAB_60		; get string start high byte
.b61c	69 00		adc #$00		ADC	#$00			; add carry
.b61e	85 5b		sta $5b			STA	LAB_5B		; set block end high byte
.b620	a5 33		lda $33			LDA	LAB_33		; get bottom of string space low byte
.b622	a6 34		ldx $34			LDX	LAB_34		; get bottom of string space high byte
.b624	85 58		sta $58			STA	LAB_58		; save destination end low byte
.b626	86 59		stx $59			STX	LAB_59		; save destination end high byte
.b628	20 bf a3	jsr $a3bf		JSR	LAB_A3BF		; open up space in memory, don't set array end. this
.b62b	a4 55		ldy $55			LDY	LAB_55		; restore offset to descriptor start
.b62d	c8		iny			INY				; increment index to string pointer low byte
.b62e	a5 58		lda $58			LDA	LAB_58		; get new string pointer low byte
.b630	91 4e		sta ($4e),y		STA	(LAB_4E),Y		; save new string pointer low byte
.b632	aa		tax			TAX				; copy string pointer low byte
.b633	e6 59		inc $59			INC	LAB_59		; increment new string pointer high byte
.b635	a5 59		lda $59			LDA	LAB_59		; get new string pointer high byte
.b637	c8		iny			INY				; increment index to string pointer high byte
.b638	91 4e		sta ($4e),y		STA	(LAB_4E),Y		; save new string pointer high byte
.b63a	4c 2a b5	jmp $b52a		JMP	LAB_B52A		; re-run routine from last ending, XA holds new bottom
.b63d					LAB_B63D
.b63d	a5 65		lda $65			LDA	LAB_65		; get descriptor pointer high byte
.b63f	48		pha			PHA				; put on stack
.b640	a5 64		lda $64			LDA	LAB_64		; get descriptor pointer low byte
.b642	48		pha			PHA				; put on stack
.b643	20 83 ae	jsr $ae83		JSR	LAB_AE83		; get value from line
.b646	20 8f ad	jsr $ad8f		JSR	LAB_AD8F		; check if source is string, else do type mismatch
.b649	68		pla			PLA				; get descriptor pointer low byte back
.b64a	85 6f		sta $6f			STA	LAB_6F		; set pointer low byte
.b64c	68		pla			PLA				; get descriptor pointer high byte back
.b64d	85 70		sta $70			STA	LAB_70		; set pointer high byte
.b64f	a0 00		ldy #$00		LDY	#$00			; clear index
.b651	b1 6f		lda ($6f),y		LDA	(LAB_6F),Y		; get length of first string from descriptor
.b653	18		clc			CLC				; clear carry for add
.b654	71 64		adc ($64),y		ADC	(LAB_64),Y		; add length of second string
.b656	90 05		bcc $b65d		BCC	LAB_B65D		; branch if no overflow
.b658	a2 17		ldx #$17		LDX	#$17			; else error $17, string too long error
.b65a	4c 37 a4	jmp $a437		JMP	LAB_A437		; do error #X then warm start
.b65d					LAB_B65D
.b65d	20 75 b4	jsr $b475		JSR	LAB_B475		; copy descriptor pointer and make string space A bytes long
.b660	20 7a b6	jsr $b67a		JSR	LAB_B67A		; copy string from descriptor to utility pointer
.b663	a5 50		lda $50			LDA	LAB_50		; get descriptor pointer low byte
.b665	a4 51		ldy $51			LDY	LAB_51		; get descriptor pointer high byte
.b667	20 aa b6	jsr $b6aa		JSR	LAB_B6AA		; pop (YA) descriptor off stack or from top of string space
.b66a	20 8c b6	jsr $b68c		JSR	LAB_B68C		; store string from pointer to utility pointer
.b66d	a5 6f		lda $6f			LDA	LAB_6F		; get descriptor pointer low byte
.b66f	a4 70		ldy $70			LDY	LAB_70		; get descriptor pointer high byte
.b671	20 aa b6	jsr $b6aa		JSR	LAB_B6AA		; pop (YA) descriptor off stack or from top of string space
.b674	20 ca b4	jsr $b4ca		JSR	LAB_B4CA		; check space on descriptor stack then put string address
.b677	4c b8 ad	jmp $adb8		JMP	LAB_ADB8		; continue evaluation
.b67a					LAB_B67A
.b67a	a0 00		ldy #$00		LDY	#$00			; clear index
.b67c	b1 6f		lda ($6f),y		LDA	(LAB_6F),Y		; get string length
.b67e	48		pha			PHA				; save it
.b67f	c8		iny			INY				; increment index
.b680	b1 6f		lda ($6f),y		LDA	(LAB_6F),Y		; get string pointer low byte
.b682	aa		tax			TAX				; copy to X
.b683	c8		iny			INY				; increment index
.b684	b1 6f		lda ($6f),y		LDA	(LAB_6F),Y		; get string pointer high byte
.b686	a8		tay			TAY				; copy to Y
.b687	68		pla			PLA				; get length back
.b688					LAB_B688
.b688	86 22		stx $22			STX	LAB_22		; save string pointer low byte
.b68a	84 23		sty $23			STY	LAB_23		; save string pointer high byte
.b68c					LAB_B68C
.b68c	a8		tay			TAY				; copy length as index
.b68d	f0 0a		beq $b699		BEQ	LAB_B699		; branch if null string
.b68f	48		pha			PHA				; save length
.b690					LAB_B690
.b690	88		dey			DEY				; decrement length/index
.b691	b1 22		lda ($22),y		LDA	(LAB_22),Y		; get byte from string
.b693	91 35		sta ($35),y		STA	(LAB_35),Y		; save byte to destination
.b695	98		tya			TYA				; copy length/index
.b696	d0 f8		bne $b690		BNE	LAB_B690		; loop if not all done yet
.b698	68		pla			PLA				; restore length
.b699					LAB_B699
.b699	18		clc			CLC				; clear carry for add
.b69a	65 35		adc $35			ADC	LAB_35		; add string utility ptr low byte
.b69c	85 35		sta $35			STA	LAB_35		; save string utility ptr low byte
.b69e	90 02		bcc $b6a2		BCC	LAB_B6A2		; branch if no rollover
.b6a0	e6 36		inc $36			INC	LAB_36		; increment string utility ptr high byte
.b6a2					LAB_B6A2
.b6a2	60		rts			RTS
.b6a3					LAB_B6A3
.b6a3	20 8f ad	jsr $ad8f		JSR	LAB_AD8F		; check if source is string, else do type mismatch
.b6a6					LAB_B6A6
.b6a6	a5 64		lda $64			LDA	LAB_64		; get descriptor pointer low byte
.b6a8	a4 65		ldy $65			LDY	LAB_65		; get descriptor pointer high byte
.b6aa					LAB_B6AA
.b6aa	85 22		sta $22			STA	LAB_22		; save string pointer low byte
.b6ac	84 23		sty $23			STY	LAB_23		; save string pointer high byte
.b6ae	20 db b6	jsr $b6db		JSR	LAB_B6DB		; clean descriptor stack, YA = pointer
.b6b1	08		php			PHP				; save status flags
.b6b2	a0 00		ldy #$00		LDY	#$00			; clear index
.b6b4	b1 22		lda ($22),y		LDA	(LAB_22),Y		; get length from string descriptor
.b6b6	48		pha			PHA				; put on stack
.b6b7	c8		iny			INY				; increment index
.b6b8	b1 22		lda ($22),y		LDA	(LAB_22),Y		; get string pointer low byte from descriptor
.b6ba	aa		tax			TAX				; copy to X
.b6bb	c8		iny			INY				; increment index
.b6bc	b1 22		lda ($22),y		LDA	(LAB_22),Y		; get string pointer high byte from descriptor
.b6be	a8		tay			TAY				; copy to Y
.b6bf	68		pla			PLA				; get string length back
.b6c0	28		plp			PLP				; restore status
.b6c1	d0 13		bne $b6d6		BNE	LAB_B6D6		; branch if pointer <> last_sl,last_sh
.b6c3	c4 34		cpy $34			CPY	LAB_34		; compare with bottom of string space high byte
.b6c5	d0 0f		bne $b6d6		BNE	LAB_B6D6		; branch if <>
.b6c7	e4 33		cpx $33			CPX	LAB_33		; else compare with bottom of string space low byte
.b6c9	d0 0b		bne $b6d6		BNE	LAB_B6D6		; branch if <>
.b6cb	48		pha			PHA				; save string length
.b6cc	18		clc			CLC				; clear carry for add
.b6cd	65 33		adc $33			ADC	LAB_33		; add bottom of string space low byte
.b6cf	85 33		sta $33			STA	LAB_33		; set bottom of string space low byte
.b6d1	90 02		bcc $b6d5		BCC	LAB_B6D5		; skip increment if no overflow
.b6d3	e6 34		inc $34			INC	LAB_34		; increment bottom of string space high byte
.b6d5					LAB_B6D5
.b6d5	68		pla			PLA				; restore string length
.b6d6					LAB_B6D6
.b6d6	86 22		stx $22			STX	LAB_22		; save string pointer low byte
.b6d8	84 23		sty $23			STY	LAB_23		; save string pointer high byte
.b6da	60		rts			RTS
.b6db					LAB_B6DB
.b6db	c4 18		cpy $18			CPY	LAB_18		; compare high byte with current descriptor stack item
.b6dd	d0 0c		bne $b6eb		BNE	LAB_B6EB		; exit if <>
.b6df	c5 17		cmp $17			CMP	LAB_17		; compare low byte with current descriptor stack item
.b6e1	d0 08		bne $b6eb		BNE	LAB_B6EB		; exit if <>
.b6e3	85 16		sta $16			STA	LAB_16		; set descriptor stack pointer
.b6e5	e9 03		sbc #$03		SBC	#$03			; update last string pointer low byte
.b6e7	85 17		sta $17			STA	LAB_17		; save current descriptor stack item pointer low byte
.b6e9	a0 00		ldy #$00		LDY	#$00			; clear high byte
.b6eb					LAB_B6EB
.b6eb	60		rts			RTS
.b6ec					LAB_B6EC
.b6ec	20 a1 b7	jsr $b7a1		JSR	LAB_B7A1		; evaluate byte expression, result in X
.b6ef	8a		txa			TXA				; copy to A
.b6f0	48		pha			PHA				; save character
.b6f1	a9 01		lda #$01		LDA	#$01			; string is single byte
.b6f3	20 7d b4	jsr $b47d		JSR	LAB_B47D		; make string space A bytes long
.b6f6	68		pla			PLA				; get character back
.b6f7	a0 00		ldy #$00		LDY	#$00			; clear index
.b6f9	91 62		sta ($62),y		STA	(LAB_62),Y		; save byte in string - byte IS string!
.b6fb	68		pla			PLA				; dump return address (skip type check)
.b6fc	68		pla			PLA				; dump return address (skip type check)
.b6fd	4c ca b4	jmp $b4ca		JMP	LAB_B4CA		; check space on descriptor stack then put string address
.b700					LAB_B700
.b700	20 61 b7	jsr $b761		JSR	LAB_B761		; pull string data and byte parameter from stack
.b703	d1 50		cmp ($50),y		CMP	(LAB_50),Y		; compare byte parameter with string length
.b705	98		tya			TYA				; clear A
.b706					LAB_B706
.b706	90 04		bcc $b70c		BCC	LAB_B70C		; branch if string length > byte parameter
.b708	b1 50		lda ($50),y		LDA	(LAB_50),Y		; else make parameter = length
.b70a	aa		tax			TAX				; copy to byte parameter copy
.b70b	98		tya			TYA				; clear string start offset
.b70c					LAB_B70C
.b70c	48		pha			PHA				; save string start offset
.b70d					LAB_B70D
.b70d	8a		txa			TXA				; copy byte parameter (or string length if <)
.b70e					LAB_B70E
.b70e	48		pha			PHA				; save string length
.b70f	20 7d b4	jsr $b47d		JSR	LAB_B47D		; make string space A bytes long
.b712	a5 50		lda $50			LDA	LAB_50		; get descriptor pointer low byte
.b714	a4 51		ldy $51			LDY	LAB_51		; get descriptor pointer high byte
.b716	20 aa b6	jsr $b6aa		JSR	LAB_B6AA		; pop (YA) descriptor off stack or from top of string space
.b719	68		pla			PLA				; get string length back
.b71a	a8		tay			TAY				; copy length to Y
.b71b	68		pla			PLA				; get string start offset back
.b71c	18		clc			CLC				; clear carry for add
.b71d	65 22		adc $22			ADC	LAB_22		; add start offset to string start pointer low byte
.b71f	85 22		sta $22			STA	LAB_22		; save string start pointer low byte
.b721	90 02		bcc $b725		BCC	LAB_B725		; branch if no overflow
.b723	e6 23		inc $23			INC	LAB_23		; else increment string start pointer high byte
.b725					LAB_B725
.b725	98		tya			TYA				; copy length to A
.b726	20 8c b6	jsr $b68c		JSR	LAB_B68C		; store string from pointer to utility pointer
.b729	4c ca b4	jmp $b4ca		JMP	LAB_B4CA		; check space on descriptor stack then put string address
.b72c					LAB_B72C
.b72c	20 61 b7	jsr $b761		JSR	LAB_B761		; pull string data and byte parameter from stack
.b72f	18		clc			CLC				; clear carry for add-1
.b730	f1 50		sbc ($50),y		SBC	(LAB_50),Y		; subtract string length
.b732	49 ff		eor #$ff		EOR	#$FF			; invert it (A=LEN(expression$)-l)
.b734	4c 06 b7	jmp $b706		JMP	LAB_B706		; go do rest of LEFT$()
.b737					LAB_B737
.b737	a9 ff		lda #$ff		LDA	#$FF			; set default length = 255
.b739	85 65		sta $65			STA	LAB_65		; save default length
.b73b	20 79 00	jsr $0079		JSR	LAB_0079		; scan memory
.b73e	c9 29		cmp #$29		CMP	#')'			; compare with ")"
.b740	f0 06		beq $b748		BEQ	LAB_B748		; branch if = ")" (skip second byte get)
.b742	20 fd ae	jsr $aefd		JSR	LAB_AEFD		; scan for ",", else do syntax error then warm start
.b745	20 9e b7	jsr $b79e		JSR	LAB_B79E		; get byte parameter
.b748					LAB_B748
.b748	20 61 b7	jsr $b761		JSR	LAB_B761		; pull string data and byte parameter from stack
.b74b	f0 4b		beq $b798		BEQ	LAB_B798		; if null do illegal quantity error then warm start
.b74d	ca		dex			DEX				; decrement start index
.b74e	8a		txa			TXA				; copy to A
.b74f	48		pha			PHA				; save string start offset
.b750	18		clc			CLC				; clear carry for sub-1
.b751	a2 00		ldx #$00		LDX	#$00			; clear output string length
.b753	f1 50		sbc ($50),y		SBC	(LAB_50),Y		; subtract string length
.b755	b0 b6		bcs $b70d		BCS	LAB_B70D		; if start>string length go do null string
.b757	49 ff		eor #$ff		EOR	#$FF			; complement -length
.b759	c5 65		cmp $65			CMP	LAB_65		; compare byte parameter
.b75b	90 b1		bcc $b70e		BCC	LAB_B70E		; if length>remaining string go do RIGHT$
.b75d	a5 65		lda $65			LDA	LAB_65		; get length byte
.b75f	b0 ad		bcs $b70e		BCS	LAB_B70E		; go do string copy, branch always
.b761					LAB_B761
.b761	20 f7 ae	jsr $aef7		JSR	LAB_AEF7		; scan for ")", else do syntax error then warm start
.b764	68		pla			PLA				; pull return address low byte
.b765	a8		tay			TAY				; save return address low byte
.b766	68		pla			PLA				; pull return address high byte
.b767	85 55		sta $55			STA	LAB_55		; save return address high byte
.b769	68		pla			PLA				; dump call to function vector low byte
.b76a	68		pla			PLA				; dump call to function vector high byte
.b76b	68		pla			PLA				; pull byte parameter
.b76c	aa		tax			TAX				; copy byte parameter to X
.b76d	68		pla			PLA				; pull string pointer low byte
.b76e	85 50		sta $50			STA	LAB_50		; save it
.b770	68		pla			PLA				; pull string pointer high byte
.b771	85 51		sta $51			STA	LAB_51		; save it
.b773	a5 55		lda $55			LDA	LAB_55		; get return address high byte
.b775	48		pha			PHA				; back on stack
.b776	98		tya			TYA				; get return address low byte
.b777	48		pha			PHA				; back on stack
.b778	a0 00		ldy #$00		LDY	#$00			; clear index
.b77a	8a		txa			TXA				; copy byte parameter
.b77b	60		rts			RTS
.b77c					LAB_B77C
.b77c	20 82 b7	jsr $b782		JSR	LAB_B782		; evaluate string, get length in A (and Y)
.b77f	4c a2 b3	jmp $b3a2		JMP	LAB_B3A2		; convert Y to byte in FAC1 and return
.b782					LAB_B782
.b782	20 a3 b6	jsr $b6a3		JSR	LAB_B6A3		; evaluate string
.b785	a2 00		ldx #$00		LDX	#$00			; set data type = numeric
.b787	86 0d		stx $0d			STX	LAB_0D		; clear data type flag, $FF = string, $00 = numeric
.b789	a8		tay			TAY				; copy length to Y
.b78a	60		rts			RTS
.b78b					LAB_B78B
.b78b	20 82 b7	jsr $b782		JSR	LAB_B782		; evaluate string, get length in A (and Y)
.b78e	f0 08		beq $b798		BEQ	LAB_B798		; if null do illegal quantity error then warm start
.b790	a0 00		ldy #$00		LDY	#$00			; set index to first character
.b792	b1 22		lda ($22),y		LDA	(LAB_22),Y		; get byte
.b794	a8		tay			TAY				; copy to Y
.b795	4c a2 b3	jmp $b3a2		JMP	LAB_B3A2		; convert Y to byte in FAC1 and return
.b798					LAB_B798
.b798	4c 48 b2	jmp $b248		JMP	LAB_B248		; do illegal quantity error then warm start
.b79b					LAB_B79B
.b79b	20 73 00	jsr $0073		JSR	LAB_0073		; increment and scan memory
.b79e					LAB_B79E
.b79e	20 8a ad	jsr $ad8a		JSR	LAB_AD8A		; evaluate expression and check is numeric, else do
.b7a1					LAB_B7A1
.b7a1	20 b8 b1	jsr $b1b8		JSR	LAB_B1B8		; evaluate integer expression, sign check
.b7a4	a6 64		ldx $64			LDX	LAB_64		; get FAC1 mantissa 3
.b7a6	d0 f0		bne $b798		BNE	LAB_B798		; if not null do illegal quantity error then warm start
.b7a8	a6 65		ldx $65			LDX	LAB_65		; get FAC1 mantissa 4
.b7aa	4c 79 00	jmp $0079		JMP	LAB_0079		; scan memory and return
.b7ad					LAB_B7AD
.b7ad	20 82 b7	jsr $b782		JSR	LAB_B782		; evaluate string, get length in A (and Y)
.b7b0	d0 03		bne $b7b5		BNE	LAB_B7B5		; branch if not null string
.b7b2	4c f7 b8	jmp $b8f7		JMP	LAB_B8F7		; clear FAC1 exponent and sign and return
.b7b5					LAB_B7B5
.b7b5	a6 7a		ldx $7a			LDX	LAB_7A		; get BASIC execute pointer low byte
.b7b7	a4 7b		ldy $7b			LDY	LAB_7B		; get BASIC execute pointer high byte
.b7b9	86 71		stx $71			STX	LAB_71		; save BASIC execute pointer low byte
.b7bb	84 72		sty $72			STY	LAB_72		; save BASIC execute pointer high byte
.b7bd	a6 22		ldx $22			LDX	LAB_22		; get string pointer low byte
.b7bf	86 7a		stx $7a			STX	LAB_7A		; save BASIC execute pointer low byte
.b7c1	18		clc			CLC				; clear carry for add
.b7c2	65 22		adc $22			ADC	LAB_22		; add string length
.b7c4	85 24		sta $24			STA	LAB_24		; save string end low byte
.b7c6	a6 23		ldx $23			LDX	LAB_23		; get string pointer high byte
.b7c8	86 7b		stx $7b			STX	LAB_7B		; save BASIC execute pointer high byte
.b7ca	90 01		bcc $b7cd		BCC	LAB_B7CD		; branch if no high byte increment
.b7cc	e8		inx			INX				; increment string end high byte
.b7cd					LAB_B7CD
.b7cd	86 25		stx $25			STX	LAB_25		; save string end high byte
.b7cf	a0 00		ldy #$00		LDY	#$00			; set index to $00
.b7d1	b1 24		lda ($24),y		LDA	(LAB_24),Y		; get string end byte
.b7d3	48		pha			PHA				; push it
.b7d4	98		tya			TYA				; clear A
.b7d5	91 24		sta ($24),y		STA	(LAB_24),Y		; terminate string with $00
.b7d7	20 79 00	jsr $0079		JSR	LAB_0079		; scan memory
.b7da	20 f3 bc	jsr $bcf3		JSR	LAB_BCF3		; get FAC1 from string
.b7dd	68		pla			PLA				; restore string end byte
.b7de	a0 00		ldy #$00		LDY	#$00			; clear index
.b7e0	91 24		sta ($24),y		STA	(LAB_24),Y		; put string end byte back
.b7e2					LAB_B7E2
.b7e2	a6 71		ldx $71			LDX	LAB_71		; get BASIC execute pointer low byte back
.b7e4	a4 72		ldy $72			LDY	LAB_72		; get BASIC execute pointer high byte back
.b7e6	86 7a		stx $7a			STX	LAB_7A		; save BASIC execute pointer low byte
.b7e8	84 7b		sty $7b			STY	LAB_7B		; save BASIC execute pointer high byte
.b7ea	60		rts			RTS
.b7eb					LAB_B7EB
.b7eb	20 8a ad	jsr $ad8a		JSR	LAB_AD8A		; evaluate expression and check is numeric, else do
.b7ee	20 f7 b7	jsr $b7f7		JSR	LAB_B7F7		; convert FAC_1 to integer in temporary integer
.b7f1					LAB_B7F1
.b7f1	20 fd ae	jsr $aefd		JSR	LAB_AEFD		; scan for ",", else do syntax error then warm start
.b7f4	4c 9e b7	jmp $b79e		JMP	LAB_B79E		; get byte parameter and return
.b7f7					LAB_B7F7
.b7f7	a5 66		lda $66			LDA	LAB_66		; get FAC1 sign
.b7f9	30 9d		bmi $b798		BMI	LAB_B798		; if -ve do illegal quantity error then warm start
.b7fb	a5 61		lda $61			LDA	LAB_61		; get FAC1 exponent
.b7fd	c9 91		cmp #$91		CMP	#$91			; compare with exponent = 2^16
.b7ff	b0 97		bcs $b798		BCS	LAB_B798		; if >= do illegal quantity error then warm start
.b801	20 9b bc	jsr $bc9b		JSR	LAB_BC9B		; convert FAC1 floating to fixed
.b804	a5 64		lda $64			LDA	LAB_64		; get FAC1 mantissa 3
.b806	a4 65		ldy $65			LDY	LAB_65		; get FAC1 mantissa 4
.b808	84 14		sty $14			STY	LAB_14		; save temporary integer low byte
.b80a	85 15		sta $15			STA	LAB_15		; save temporary integer high byte
.b80c	60		rts			RTS
.b80d					LAB_B80D
.b80d	a5 15		lda $15			LDA	LAB_15		; get line number high byte
.b80f	48		pha			PHA				; save line number high byte
.b810	a5 14		lda $14			LDA	LAB_14		; get line number low byte
.b812	48		pha			PHA				; save line number low byte
.b813	20 f7 b7	jsr $b7f7		JSR	LAB_B7F7		; convert FAC_1 to integer in temporary integer
.b816	a0 00		ldy #$00		LDY	#$00			; clear index
.b818	b1 14		lda ($14),y		LDA	(LAB_14),Y		; read byte
.b81a	a8		tay			TAY				; copy byte to A
.b81b	68		pla			PLA				; pull byte
.b81c	85 14		sta $14			STA	LAB_14		; restore line number low byte
.b81e	68		pla			PLA				; pull byte
.b81f	85 15		sta $15			STA	LAB_15		; restore line number high byte
.b821	4c a2 b3	jmp $b3a2		JMP	LAB_B3A2		; convert Y to byte in FAC_1 and return
.b824					LAB_B824
.b824	20 eb b7	jsr $b7eb		JSR	LAB_B7EB		; get parameters for POKE/WAIT
.b827	8a		txa			TXA				; copy byte to A
.b828	a0 00		ldy #$00		LDY	#$00			; clear index
.b82a	91 14		sta ($14),y		STA	(LAB_14),Y		; write byte
.b82c	60		rts			RTS
.b82d					LAB_B82D
.b82d	20 eb b7	jsr $b7eb		JSR	LAB_B7EB		; get parameters for POKE/WAIT
.b830	86 49		stx $49			STX	LAB_49		; save byte
.b832	a2 00		ldx #$00		LDX	#$00			; clear mask
.b834	20 79 00	jsr $0079		JSR	LAB_0079		; scan memory
.b837	f0 03		beq $b83c		BEQ	LAB_B83C		; skip if no third argument
.b839	20 f1 b7	jsr $b7f1		JSR	LAB_B7F1		; scan for "," and get byte, else syntax error then
.b83c					LAB_B83C
.b83c	86 4a		stx $4a			STX	LAB_4A		; save EOR argument
.b83e	a0 00		ldy #$00		LDY	#$00			; clear index
.b840					LAB_B840
.b840	b1 14		lda ($14),y		LDA	(LAB_14),Y		; get byte via temporary integer	(address)
.b842	45 4a		eor $4a			EOR	LAB_4A		; EOR with second argument		(mask)
.b844	25 49		and $49			AND	LAB_49		; AND with first argument		(byte)
.b846	f0 f8		beq $b840		BEQ	LAB_B840		; loop if result is zero
.b848					LAB_B848
.b848	60		rts			RTS
.b849					LAB_B849
.b849	a9 11		lda #$11		LDA	#<LAB_BF11		; set 0.5 pointer low byte
.b84b	a0 bf		ldy #$bf		LDY	#>LAB_BF11		; set 0.5 pointer high byte
.b84d	4c 67 b8	jmp $b867		JMP	LAB_B867		; add (AY) to FAC1
.b850					LAB_B850
.b850	20 8c ba	jsr $ba8c		JSR	LAB_BA8C		; unpack memory (AY) into FAC2
.b853					LAB_B853
.b853	a5 66		lda $66			LDA	LAB_66		; get FAC1 sign (b7)
.b855	49 ff		eor #$ff		EOR	#$FF			; complement it
.b857	85 66		sta $66			STA	LAB_66		; save FAC1 sign (b7)
.b859	45 6e		eor $6e			EOR	LAB_6E		; EOR with FAC2 sign (b7)
.b85b	85 6f		sta $6f			STA	LAB_6F		; save sign compare (FAC1 EOR FAC2)
.b85d	a5 61		lda $61			LDA	LAB_61		; get FAC1 exponent
.b85f	4c 6a b8	jmp $b86a		JMP	LAB_B86A		; add FAC2 to FAC1 and return
.b862					LAB_B862
.b862	20 99 b9	jsr $b999		JSR	LAB_B999		; shift FACX A times right (>8 shifts)
.b865	90 3c		bcc $b8a3		BCC	LAB_B8A3		;.go subtract mantissas
.b867					LAB_B867
.b867	20 8c ba	jsr $ba8c		JSR	LAB_BA8C		; unpack memory (AY) into FAC2
.b86a					LAB_B86A
.b86a	d0 03		bne $b86f		BNE	LAB_B86F		; branch if FAC1 is not zero
.b86c	4c fc bb	jmp $bbfc		JMP	LAB_BBFC		; FAC1 was zero so copy FAC2 to FAC1 and return
.b86f					LAB_B86F
.b86f	a6 70		ldx $70			LDX	LAB_70		; get FAC1 rounding byte
.b871	86 56		stx $56			STX	LAB_56		; save as FAC2 rounding byte
.b873	a2 69		ldx #$69		LDX	#LAB_69		; set index to FAC2 exponent address
.b875	a5 69		lda $69			LDA	LAB_69		; get FAC2 exponent
.b877					LAB_B877
.b877	a8		tay			TAY				; copy exponent
.b878	f0 ce		beq $b848		BEQ	LAB_B848		; exit if zero
.b87a	38		sec			SEC				; set carry for subtract
.b87b	e5 61		sbc $61			SBC	LAB_61		; subtract FAC1 exponent
.b87d	f0 24		beq $b8a3		BEQ	LAB_B8A3		; if equal go add mantissas
.b87f	90 12		bcc $b893		BCC	LAB_B893		; if FAC2 < FAC1 then go shift FAC2 right
.b881	84 61		sty $61			STY	LAB_61		; save FAC1 exponent
.b883	a4 6e		ldy $6e			LDY	LAB_6E		; get FAC2 sign (b7)
.b885	84 66		sty $66			STY	LAB_66		; save FAC1 sign (b7)
.b887	49 ff		eor #$ff		EOR	#$FF			; complement A
.b889	69 00		adc #$00		ADC	#$00			; +1, twos complement, carry is set
.b88b	a0 00		ldy #$00		LDY	#$00			; clear Y
.b88d	84 56		sty $56			STY	LAB_56		; clear FAC2 rounding byte
.b88f	a2 61		ldx #$61		LDX	#LAB_61		; set index to FAC1 exponent address
.b891	d0 04		bne $b897		BNE	LAB_B897		; branch always
.b893					LAB_B893
.b893	a0 00		ldy #$00		LDY	#$00			; clear Y
.b895	84 70		sty $70			STY	LAB_70		; clear FAC1 rounding byte
.b897					LAB_B897
.b897	c9 f9		cmp #$f9		CMP	#$F9			; compare exponent diff with $F9
.b899	30 c7		bmi $b862		BMI	LAB_B862		; branch if range $79-$F8
.b89b	a8		tay			TAY				; copy exponent difference to Y
.b89c	a5 70		lda $70			LDA	LAB_70		; get FAC1 rounding byte
.b89e	56 01		lsr $01,x		LSR	LAB_00+1,X		; shift FAC? mantissa 1
.b8a0	20 b0 b9	jsr $b9b0		JSR	LAB_B9B0		; shift FACX Y times right
.b8a3					LAB_B8A3
.b8a3	24 6f		bit $6f			BIT	LAB_6F		; test sign compare (FAC1 EOR FAC2)
.b8a5	10 57		bpl $b8fe		BPL	LAB_B8FE		; if = add FAC2 mantissa to FAC1 mantissa and return
.b8a7	a0 61		ldy #$61		LDY	#LAB_61		; set the Y index to FAC1 exponent address
.b8a9	e0 69		cpx #$69		CPX	#LAB_69		; compare X to FAC2 exponent address
.b8ab	f0 02		beq $b8af		BEQ	LAB_B8AF		; if = continue, Y = FAC1, X = FAC2
.b8ad	a0 69		ldy #$69		LDY	#LAB_69		; else set the Y index to FAC2 exponent address
.b8af					LAB_B8AF
.b8af	38		sec			SEC				; set carry for subtract
.b8b0	49 ff		eor #$ff		EOR	#$FF			; ones complement A
.b8b2	65 56		adc $56			ADC	LAB_56		; add FAC2 rounding byte
.b8b4	85 70		sta $70			STA	LAB_70		; save FAC1 rounding byte
.b8b6	b9 04 00	lda $0004,y		LDA	LAB_00+4,Y		; get FACY mantissa 4
.b8b9	f5 04		sbc $04,x		SBC	LAB_00+4,X		; subtract FACX mantissa 4
.b8bb	85 65		sta $65			STA	LAB_65		; save FAC1 mantissa 4
.b8bd	b9 03 00	lda $0003,y		LDA	LAB_00+3,Y		; get FACY mantissa 3
.b8c0	f5 03		sbc $03,x		SBC	LAB_00+3,X		; subtract FACX mantissa 3
.b8c2	85 64		sta $64			STA	LAB_64		; save FAC1 mantissa 3
.b8c4	b9 02 00	lda $0002,y		LDA	LAB_00+2,Y		; get FACY mantissa 2
.b8c7	f5 02		sbc $02,x		SBC	LAB_00+2,X		; subtract FACX mantissa 2
.b8c9	85 63		sta $63			STA	LAB_63		; save FAC1 mantissa 2
.b8cb	b9 01 00	lda $0001,y		LDA	LAB_00+1,Y		; get FACY mantissa 1
.b8ce	f5 01		sbc $01,x		SBC	LAB_00+1,X		; subtract FACX mantissa 1
.b8d0	85 62		sta $62			STA	LAB_62		; save FAC1 mantissa 1
.b8d2					LAB_B8D2
.b8d2	b0 03		bcs $b8d7		BCS	LAB_B8D7		; branch if number is +ve
.b8d4	20 47 b9	jsr $b947		JSR	LAB_B947		; negate FAC1
.b8d7					LAB_B8D7
.b8d7	a0 00		ldy #$00		LDY	#$00			; clear Y
.b8d9	98		tya			TYA				; clear A
.b8da	18		clc			CLC				; clear carry for add
.b8db					LAB_B8DB
.b8db	a6 62		ldx $62			LDX	LAB_62		; get FAC1 mantissa 1
.b8dd	d0 4a		bne $b929		BNE	LAB_B929		; if not zero normalise FAC1
.b8df	a6 63		ldx $63			LDX	LAB_63		; get FAC1 mantissa 2
.b8e1	86 62		stx $62			STX	LAB_62		; save FAC1 mantissa 1
.b8e3	a6 64		ldx $64			LDX	LAB_64		; get FAC1 mantissa 3
.b8e5	86 63		stx $63			STX	LAB_63		; save FAC1 mantissa 2
.b8e7	a6 65		ldx $65			LDX	LAB_65		; get FAC1 mantissa 4
.b8e9	86 64		stx $64			STX	LAB_64		; save FAC1 mantissa 3
.b8eb	a6 70		ldx $70			LDX	LAB_70		; get FAC1 rounding byte
.b8ed	86 65		stx $65			STX	LAB_65		; save FAC1 mantissa 4
.b8ef	84 70		sty $70			STY	LAB_70		; clear FAC1 rounding byte
.b8f1	69 08		adc #$08		ADC	#$08			; add x to exponent offset
.b8f3	c9 20		cmp #$20		CMP	#$20			; compare with $20, max offset, all bits would be = 0
.b8f5	d0 e4		bne $b8db		BNE	LAB_B8DB		; loop if not max
.b8f7					LAB_B8F7
.b8f7	a9 00		lda #$00		LDA	#$00			; clear A
.b8f9					LAB_B8F9
.b8f9	85 61		sta $61			STA	LAB_61		; set FAC1 exponent
.b8fb					LAB_B8FB
.b8fb	85 66		sta $66			STA	LAB_66		; save FAC1 sign (b7)
.b8fd	60		rts			RTS
.b8fe					LAB_B8FE
.b8fe	65 56		adc $56			ADC	LAB_56		; add FAC2 rounding byte
.b900	85 70		sta $70			STA	LAB_70		; save FAC1 rounding byte
.b902	a5 65		lda $65			LDA	LAB_65		; get FAC1 mantissa 4
.b904	65 6d		adc $6d			ADC	LAB_6D		; add FAC2 mantissa 4
.b906	85 65		sta $65			STA	LAB_65		; save FAC1 mantissa 4
.b908	a5 64		lda $64			LDA	LAB_64		; get FAC1 mantissa 3
.b90a	65 6c		adc $6c			ADC	LAB_6C		; add FAC2 mantissa 3
.b90c	85 64		sta $64			STA	LAB_64		; save FAC1 mantissa 3
.b90e	a5 63		lda $63			LDA	LAB_63		; get FAC1 mantissa 2
.b910	65 6b		adc $6b			ADC	LAB_6B		; add FAC2 mantissa 2
.b912	85 63		sta $63			STA	LAB_63		; save FAC1 mantissa 2
.b914	a5 62		lda $62			LDA	LAB_62		; get FAC1 mantissa 1
.b916	65 6a		adc $6a			ADC	LAB_6A		; add FAC2 mantissa 1
.b918	85 62		sta $62			STA	LAB_62		; save FAC1 mantissa 1
.b91a	4c 36 b9	jmp $b936		JMP	LAB_B936		; test and normalise FAC1 for C=0/1
.b91d					LAB_B91D
.b91d	69 01		adc #$01		ADC	#$01			; add 1 to exponent offset
.b91f	06 70		asl $70			ASL	LAB_70		; shift FAC1 rounding byte
.b921	26 65		rol $65			ROL	LAB_65		; shift FAC1 mantissa 4
.b923	26 64		rol $64			ROL	LAB_64		; shift FAC1 mantissa 3
.b925	26 63		rol $63			ROL	LAB_63		; shift FAC1 mantissa 2
.b927	26 62		rol $62			ROL	LAB_62		; shift FAC1 mantissa 1
.b929					LAB_B929
.b929	10 f2		bpl $b91d		BPL	LAB_B91D		; loop if not normalised
.b92b	38		sec			SEC				; set carry for subtract
.b92c	e5 61		sbc $61			SBC	LAB_61		; subtract FAC1 exponent
.b92e	b0 c7		bcs $b8f7		BCS	LAB_B8F7		; branch if underflow (set result = $0)
.b930	49 ff		eor #$ff		EOR	#$FF			; complement exponent
.b932	69 01		adc #$01		ADC	#$01			; +1 (twos complement)
.b934	85 61		sta $61			STA	LAB_61		; save FAC1 exponent
.b936					LAB_B936
.b936	90 0e		bcc $b946		BCC	LAB_B946		; exit if no overflow
.b938					LAB_B938
.b938	e6 61		inc $61			INC	LAB_61		; increment FAC1 exponent
.b93a	f0 42		beq $b97e		BEQ	LAB_B97E		; if zero do overflow error then warm start
.b93c	66 62		ror $62			ROR	LAB_62		; shift FAC1 mantissa 1
.b93e	66 63		ror $63			ROR	LAB_63		; shift FAC1 mantissa 2
.b940	66 64		ror $64			ROR	LAB_64		; shift FAC1 mantissa 3
.b942	66 65		ror $65			ROR	LAB_65		; shift FAC1 mantissa 4
.b944	66 70		ror $70			ROR	LAB_70		; shift FAC1 rounding byte
.b946					LAB_B946
.b946	60		rts			RTS
.b947					LAB_B947
.b947	a5 66		lda $66			LDA	LAB_66		; get FAC1 sign (b7)
.b949	49 ff		eor #$ff		EOR	#$FF			; complement it
.b94b	85 66		sta $66			STA	LAB_66		; save FAC1 sign (b7)
.b94d					LAB_B94D
.b94d	a5 62		lda $62			LDA	LAB_62		; get FAC1 mantissa 1
.b94f	49 ff		eor #$ff		EOR	#$FF			; complement it
.b951	85 62		sta $62			STA	LAB_62		; save FAC1 mantissa 1
.b953	a5 63		lda $63			LDA	LAB_63		; get FAC1 mantissa 2
.b955	49 ff		eor #$ff		EOR	#$FF			; complement it
.b957	85 63		sta $63			STA	LAB_63		; save FAC1 mantissa 2
.b959	a5 64		lda $64			LDA	LAB_64		; get FAC1 mantissa 3
.b95b	49 ff		eor #$ff		EOR	#$FF			; complement it
.b95d	85 64		sta $64			STA	LAB_64		; save FAC1 mantissa 3
.b95f	a5 65		lda $65			LDA	LAB_65		; get FAC1 mantissa 4
.b961	49 ff		eor #$ff		EOR	#$FF			; complement it
.b963	85 65		sta $65			STA	LAB_65		; save FAC1 mantissa 4
.b965	a5 70		lda $70			LDA	LAB_70		; get FAC1 rounding byte
.b967	49 ff		eor #$ff		EOR	#$FF			; complement it
.b969	85 70		sta $70			STA	LAB_70		; save FAC1 rounding byte
.b96b	e6 70		inc $70			INC	LAB_70		; increment FAC1 rounding byte
.b96d	d0 0e		bne $b97d		BNE	LAB_B97D		; exit if no overflow
.b96f					LAB_B96F
.b96f	e6 65		inc $65			INC	LAB_65		; increment FAC1 mantissa 4
.b971	d0 0a		bne $b97d		BNE	LAB_B97D		; finished if no rollover
.b973	e6 64		inc $64			INC	LAB_64		; increment FAC1 mantissa 3
.b975	d0 06		bne $b97d		BNE	LAB_B97D		; finished if no rollover
.b977	e6 63		inc $63			INC	LAB_63		; increment FAC1 mantissa 2
.b979	d0 02		bne $b97d		BNE	LAB_B97D		; finished if no rollover
.b97b	e6 62		inc $62			INC	LAB_62		; increment FAC1 mantissa 1
.b97d					LAB_B97D
.b97d	60		rts			RTS
.b97e					LAB_B97E
.b97e	a2 0f		ldx #$0f		LDX	#$0F			; error $0F, overflow error
.b980	4c 37 a4	jmp $a437		JMP	LAB_A437		; do error #X then warm start
.b983					LAB_B983
.b983	a2 25		ldx #$25		LDX	#LAB_26-1		; set the offset to FACtemp
.b985					LAB_B985
.b985	b4 04		ldy $04,x		LDY	LAB_00+4,X		; get FACX mantissa 4
.b987	84 70		sty $70			STY	LAB_70		; save as FAC1 rounding byte
.b989	b4 03		ldy $03,x		LDY	LAB_00+3,X		; get FACX mantissa 3
.b98b	94 04		sty $04,x		STY	LAB_00+4,X		; save FACX mantissa 4
.b98d	b4 02		ldy $02,x		LDY	LAB_00+2,X		; get FACX mantissa 2
.b98f	94 03		sty $03,x		STY	LAB_00+3,X		; save FACX mantissa 3
.b991	b4 01		ldy $01,x		LDY	LAB_00+1,X		; get FACX mantissa 1
.b993	94 02		sty $02,x		STY	LAB_00+2,X		; save FACX mantissa 2
.b995	a4 68		ldy $68			LDY	LAB_68		; get FAC1 overflow byte
.b997	94 01		sty $01,x		STY	LAB_00+1,X		; save FACX mantissa 1
.b999					LAB_B999
.b999	69 08		adc #$08		ADC	#$08			; add 8 to shift count
.b99b	30 e8		bmi $b985		BMI	LAB_B985		; go do 8 shift if still -ve
.b99d	f0 e6		beq $b985		BEQ	LAB_B985		; go do 8 shift if zero
.b99f	e9 08		sbc #$08		SBC	#$08			; else subtract 8 again
.b9a1	a8		tay			TAY				; save count to Y
.b9a2	a5 70		lda $70			LDA	LAB_70		; get FAC1 rounding byte
.b9a4	b0 14		bcs $b9ba		BCS	LAB_B9BA		;.
.b9a6					LAB_B9A6
.b9a6	16 01		asl $01,x		ASL	LAB_00+1,X		; shift FACX mantissa 1
.b9a8	90 02		bcc $b9ac		BCC	LAB_B9AC		; branch if +ve
.b9aa	f6 01		inc $01,x		INC	LAB_00+1,X		; this sets b7 eventually
.b9ac					LAB_B9AC
.b9ac	76 01		ror $01,x		ROR	LAB_00+1,X		; shift FACX mantissa 1 (correct for ASL)
.b9ae	76 01		ror $01,x		ROR	LAB_00+1,X		; shift FACX mantissa 1 (put carry in b7)
.b9b0					LAB_B9B0
.b9b0	76 02		ror $02,x		ROR	LAB_00+2,X		; shift FACX mantissa 2
.b9b2	76 03		ror $03,x		ROR	LAB_00+3,X		; shift FACX mantissa 3
.b9b4	76 04		ror $04,x		ROR	LAB_00+4,X		; shift FACX mantissa 4
.b9b6	6a		ror a			ROR				; shift FACX rounding byte
.b9b7	c8		iny			INY				; increment exponent diff
.b9b8	d0 ec		bne $b9a6		BNE	LAB_B9A6		; branch if range adjust not complete
.b9ba					LAB_B9BA
.b9ba	18		clc			CLC				; just clear it
.b9bb	60		rts			RTS
.b9bc					LAB_B9BC
>b9bc	81 00 00 00 00				.byte	$81,$00,$00,$00,$00	; 1
.b9c1					LAB_B9C1
>b9c1	03					.byte	$03				; series counter
>b9c2	7f 5e 56 cb 79				.byte	$7F,$5E,$56,$CB,$79
>b9c7	80 13 9b 0b 64				.byte	$80,$13,$9B,$0B,$64
>b9cc	80 76 38 93 16				.byte	$80,$76,$38,$93,$16
>b9d1	82 38 aa 3b 20				.byte	$82,$38,$AA,$3B,$20
.b9d6					LAB_B9D6
>b9d6	80 35 04 f3 34				.byte	$80,$35,$04,$F3,$34	; 0.70711	1/root 2
.b9db					LAB_B9DB
>b9db	81 35 04 f3 34				.byte	$81,$35,$04,$F3,$34	; 1.41421	root 2
.b9e0					LAB_B9E0
>b9e0	80 80 00 00 00				.byte	$80,$80,$00,$00,$00	; -0.5	1/2
.b9e5					LAB_B9E5
>b9e5	80 31 72 17 f8				.byte	$80,$31,$72,$17,$F8	; 0.69315	LOG(2)
.b9ea					LAB_B9EA
.b9ea	20 2b bc	jsr $bc2b		JSR	LAB_BC2B		; test sign and zero
.b9ed	f0 02		beq $b9f1		BEQ	LAB_B9F1		; if zero do illegal quantity error then warm start
.b9ef	10 03		bpl $b9f4		BPL	LAB_B9F4		; skip error if +ve
.b9f1					LAB_B9F1
.b9f1	4c 48 b2	jmp $b248		JMP	LAB_B248		; do illegal quantity error then warm start
.b9f4					LAB_B9F4
.b9f4	a5 61		lda $61			LDA	LAB_61		; get FAC1 exponent
.b9f6	e9 7f		sbc #$7f		SBC	#$7F			; normalise it
.b9f8	48		pha			PHA				; save it
.b9f9	a9 80		lda #$80		LDA	#$80			; set exponent to zero
.b9fb	85 61		sta $61			STA	LAB_61		; save FAC1 exponent
.b9fd	a9 d6		lda #$d6		LDA	#<LAB_B9D6		; pointer to 1/root 2 low byte
.b9ff	a0 b9		ldy #$b9		LDY	#>LAB_B9D6		; pointer to 1/root 2 high byte
.ba01	20 67 b8	jsr $b867		JSR	LAB_B867		; add (AY) to FAC1 (1/root2)
.ba04	a9 db		lda #$db		LDA	#<LAB_B9DB		; pointer to root 2 low byte
.ba06	a0 b9		ldy #$b9		LDY	#>LAB_B9DB		; pointer to root 2 high byte
.ba08	20 0f bb	jsr $bb0f		JSR	LAB_BB0F		; convert AY and do (AY)/FAC1 (root2/(x+(1/root2)))
.ba0b	a9 bc		lda #$bc		LDA	#<LAB_B9BC		; pointer to 1 low byte
.ba0d	a0 b9		ldy #$b9		LDY	#>LAB_B9BC		; pointer to 1 high byte
.ba0f	20 50 b8	jsr $b850		JSR	LAB_B850		; subtract FAC1 ((root2/(x+(1/root2)))-1) from (AY)
.ba12	a9 c1		lda #$c1		LDA	#<LAB_B9C1		; pointer to series for LOG(n) low byte
.ba14	a0 b9		ldy #$b9		LDY	#>LAB_B9C1		; pointer to series for LOG(n) high byte
.ba16	20 43 e0	jsr $e043		JSR	LAB_E043		; ^2 then series evaluation
.ba19	a9 e0		lda #$e0		LDA	#<LAB_B9E0		; pointer to -0.5 low byte
.ba1b	a0 b9		ldy #$b9		LDY	#>LAB_B9E0		; pointer to -0.5 high byte
.ba1d	20 67 b8	jsr $b867		JSR	LAB_B867		; add (AY) to FAC1
.ba20	68		pla			PLA				; restore FAC1 exponent
.ba21	20 7e bd	jsr $bd7e		JSR	LAB_BD7E		; evaluate new ASCII digit
.ba24	a9 e5		lda #$e5		LDA	#<LAB_B9E5		; pointer to LOG(2) low byte
.ba26	a0 b9		ldy #$b9		LDY	#>LAB_B9E5		; pointer to LOG(2) high byte
.ba28					LAB_BA28
.ba28	20 8c ba	jsr $ba8c		JSR	LAB_BA8C		; unpack memory (AY) into FAC2
.ba2b					LAB_BA2B
.ba2b	d0 03		bne $ba30		BNE	LAB_BA30		; multiply FAC1 by FAC2 ??
.ba2d	4c 8b ba	jmp $ba8b		JMP	LAB_BA8B		; exit if zero
.ba30					LAB_BA30
.ba30	20 b7 ba	jsr $bab7		JSR	LAB_BAB7		; test and adjust accumulators
.ba33	a9 00		lda #$00		LDA	#$00			; clear A
.ba35	85 26		sta $26			STA	LAB_26		; clear temp mantissa 1
.ba37	85 27		sta $27			STA	LAB_27		; clear temp mantissa 2
.ba39	85 28		sta $28			STA	LAB_28		; clear temp mantissa 3
.ba3b	85 29		sta $29			STA	LAB_29		; clear temp mantissa 4
.ba3d	a5 70		lda $70			LDA	LAB_70		; get FAC1 rounding byte
.ba3f	20 59 ba	jsr $ba59		JSR	LAB_BA59		; go do shift/add FAC2
.ba42	a5 65		lda $65			LDA	LAB_65		; get FAC1 mantissa 4
.ba44	20 59 ba	jsr $ba59		JSR	LAB_BA59		; go do shift/add FAC2
.ba47	a5 64		lda $64			LDA	LAB_64		; get FAC1 mantissa 3
.ba49	20 59 ba	jsr $ba59		JSR	LAB_BA59		; go do shift/add FAC2
.ba4c	a5 63		lda $63			LDA	LAB_63		; get FAC1 mantissa 2
.ba4e	20 59 ba	jsr $ba59		JSR	LAB_BA59		; go do shift/add FAC2
.ba51	a5 62		lda $62			LDA	LAB_62		; get FAC1 mantissa 1
.ba53	20 5e ba	jsr $ba5e		JSR	LAB_BA5E		; go do shift/add FAC2
.ba56	4c 8f bb	jmp $bb8f		JMP	LAB_BB8F		; copy temp to FAC1, normalise and return
.ba59					LAB_BA59
.ba59	d0 03		bne $ba5e		BNE	LAB_BA5E		; branch if byte <> zero
.ba5b	4c 83 b9	jmp $b983		JMP	LAB_B983		; shift FCAtemp << A+8 times
.ba5e					LAB_BA5E
.ba5e	4a		lsr a			LSR				; shift byte
.ba5f	09 80		ora #$80		ORA	#$80			; set top bit (mark for 8 times)
.ba61					LAB_BA61
.ba61	a8		tay			TAY				; copy result
.ba62	90 19		bcc $ba7d		BCC	LAB_BA7D		; skip next if bit was zero
.ba64	18		clc			CLC				; clear carry for add
.ba65	a5 29		lda $29			LDA	LAB_29		; get temp mantissa 4
.ba67	65 6d		adc $6d			ADC	LAB_6D		; add FAC2 mantissa 4
.ba69	85 29		sta $29			STA	LAB_29		; save temp mantissa 4
.ba6b	a5 28		lda $28			LDA	LAB_28		; get temp mantissa 3
.ba6d	65 6c		adc $6c			ADC	LAB_6C		; add FAC2 mantissa 3
.ba6f	85 28		sta $28			STA	LAB_28		; save temp mantissa 3
.ba71	a5 27		lda $27			LDA	LAB_27		; get temp mantissa 2
.ba73	65 6b		adc $6b			ADC	LAB_6B		; add FAC2 mantissa 2
.ba75	85 27		sta $27			STA	LAB_27		; save temp mantissa 2
.ba77	a5 26		lda $26			LDA	LAB_26		; get temp mantissa 1
.ba79	65 6a		adc $6a			ADC	LAB_6A		; add FAC2 mantissa 1
.ba7b	85 26		sta $26			STA	LAB_26		; save temp mantissa 1
.ba7d					LAB_BA7D
.ba7d	66 26		ror $26			ROR	LAB_26		; shift temp mantissa 1
.ba7f	66 27		ror $27			ROR	LAB_27		; shift temp mantissa 2
.ba81	66 28		ror $28			ROR	LAB_28		; shift temp mantissa 3
.ba83	66 29		ror $29			ROR	LAB_29		; shift temp mantissa 4
.ba85	66 70		ror $70			ROR	LAB_70		; shift temp rounding byte
.ba87	98		tya			TYA				; get byte back
.ba88	4a		lsr a			LSR				; shift byte
.ba89	d0 d6		bne $ba61		BNE	LAB_BA61		; loop if all bits not done
.ba8b					LAB_BA8B
.ba8b	60		rts			RTS
.ba8c					LAB_BA8C
.ba8c	85 22		sta $22			STA	LAB_22		; save pointer low byte
.ba8e	84 23		sty $23			STY	LAB_23		; save pointer high byte
.ba90	a0 04		ldy #$04		LDY	#$04			; 5 bytes to get (0-4)
.ba92	b1 22		lda ($22),y		LDA	(LAB_22),Y		; get mantissa 4
.ba94	85 6d		sta $6d			STA	LAB_6D		; save FAC2 mantissa 4
.ba96	88		dey			DEY				; decrement index
.ba97	b1 22		lda ($22),y		LDA	(LAB_22),Y		; get mantissa 3
.ba99	85 6c		sta $6c			STA	LAB_6C		; save FAC2 mantissa 3
.ba9b	88		dey			DEY				; decrement index
.ba9c	b1 22		lda ($22),y		LDA	(LAB_22),Y		; get mantissa 2
.ba9e	85 6b		sta $6b			STA	LAB_6B		; save FAC2 mantissa 2
.baa0	88		dey			DEY				; decrement index
.baa1	b1 22		lda ($22),y		LDA	(LAB_22),Y		; get mantissa 1 + sign
.baa3	85 6e		sta $6e			STA	LAB_6E		; save FAC2 sign (b7)
.baa5	45 66		eor $66			EOR	LAB_66		; EOR with FAC1 sign (b7)
.baa7	85 6f		sta $6f			STA	LAB_6F		; save sign compare (FAC1 EOR FAC2)
.baa9	a5 6e		lda $6e			LDA	LAB_6E		; recover FAC2 sign (b7)
.baab	09 80		ora #$80		ORA	#$80			; set 1xxx xxx (set normal bit)
.baad	85 6a		sta $6a			STA	LAB_6A		; save FAC2 mantissa 1
.baaf	88		dey			DEY				; decrement index
.bab0	b1 22		lda ($22),y		LDA	(LAB_22),Y		; get exponent byte
.bab2	85 69		sta $69			STA	LAB_69		; save FAC2 exponent
.bab4	a5 61		lda $61			LDA	LAB_61		; get FAC1 exponent
.bab6	60		rts			RTS
.bab7					LAB_BAB7
.bab7	a5 69		lda $69			LDA	LAB_69		; get FAC2 exponent
.bab9					LAB_BAB9
.bab9	f0 1f		beq $bada		BEQ	LAB_BADA		; branch if FAC2 = $00 (handle underflow)
.babb	18		clc			CLC				; clear carry for add
.babc	65 61		adc $61			ADC	LAB_61		; add FAC1 exponent
.babe	90 04		bcc $bac4		BCC	LAB_BAC4		; branch if sum of exponents < $0100
.bac0	30 1d		bmi $badf		BMI	LAB_BADF		; do overflow error
.bac2	18		clc			CLC				; clear carry for the add
>bac3	2c					.byte	$2C			; makes next line BIT LAB_1410
.bac4					LAB_BAC4
.bac4	10 14		bpl $bada		BPL	LAB_BADA		; if +ve go handle underflow
.bac6	69 80		adc #$80		ADC	#$80			; adjust exponent
.bac8	85 61		sta $61			STA	LAB_61		; save FAC1 exponent
.baca	d0 03		bne $bacf		BNE	LAB_BACF		; branch if not zero
.bacc	4c fb b8	jmp $b8fb		JMP	LAB_B8FB		; save FAC1 sign and return
.bacf					LAB_BACF
.bacf	a5 6f		lda $6f			LDA	LAB_6F		; get sign compare (FAC1 EOR FAC2)
.bad1	85 66		sta $66			STA	LAB_66		; save FAC1 sign (b7)
.bad3	60		rts			RTS
.bad4					LAB_BAD4
.bad4	a5 66		lda $66			LDA	LAB_66		; get FAC1 sign (b7)
.bad6	49 ff		eor #$ff		EOR	#$FF			; complement it
.bad8	30 05		bmi $badf		BMI	LAB_BADF		; do overflow error
.bada					LAB_BADA
.bada	68		pla			PLA				; pop return address low byte
.badb	68		pla			PLA				; pop return address high byte
.badc	4c f7 b8	jmp $b8f7		JMP	LAB_B8F7		; clear FAC1 exponent and sign and return
.badf					LAB_BADF
.badf	4c 7e b9	jmp $b97e		JMP	LAB_B97E		; do overflow error then warm start
.bae2					LAB_BAE2
.bae2	20 0c bc	jsr $bc0c		JSR	LAB_BC0C		; round and copy FAC1 to FAC2
.bae5	aa		tax			TAX				; copy exponent (set the flags)
.bae6	f0 10		beq $baf8		BEQ	LAB_BAF8		; exit if zero
.bae8	18		clc			CLC				; clear carry for add
.bae9	69 02		adc #$02		ADC	#$02			; add two to exponent (*4)
.baeb	b0 f2		bcs $badf		BCS	LAB_BADF		; do overflow error if > $FF
.baed					LAB_BAED
.baed	a2 00		ldx #$00		LDX	#$00			; clear byte
.baef	86 6f		stx $6f			STX	LAB_6F		; clear sign compare (FAC1 EOR FAC2)
.baf1	20 77 b8	jsr $b877		JSR	LAB_B877		; add FAC2 to FAC1 (*5)
.baf4	e6 61		inc $61			INC	LAB_61		; increment FAC1 exponent (*10)
.baf6	f0 e7		beq $badf		BEQ	LAB_BADF		; if exponent now zero go do overflow error
.baf8					LAB_BAF8
.baf8	60		rts			RTS
.baf9					LAB_BAF9
>baf9	84 20 00 00 00				.byte	$84,$20,$00,$00,$00	; 10
.bafe					LAB_BAFE
.bafe	20 0c bc	jsr $bc0c		JSR	LAB_BC0C		; round and copy FAC1 to FAC2
.bb01	a9 f9		lda #$f9		LDA	#<LAB_BAF9		; set 10 pointer low byte
.bb03	a0 ba		ldy #$ba		LDY	#>LAB_BAF9		; set 10 pointer high byte
.bb05	a2 00		ldx #$00		LDX	#$00			; clear sign
.bb07					LAB_BB07
.bb07	86 6f		stx $6f			STX	LAB_6F		; save sign compare (FAC1 EOR FAC2)
.bb09	20 a2 bb	jsr $bba2		JSR	LAB_BBA2		; unpack memory (AY) into FAC1
.bb0c	4c 12 bb	jmp $bb12		JMP	LAB_BB12		; do FAC2/FAC1
.bb0f					LAB_BB0F
.bb0f	20 8c ba	jsr $ba8c		JSR	LAB_BA8C		; unpack memory (AY) into FAC2
.bb12					LAB_BB12
.bb12	f0 76		beq $bb8a		BEQ	LAB_BB8A		; if zero go do /0 error
.bb14	20 1b bc	jsr $bc1b		JSR	LAB_BC1B		; round FAC1
.bb17	a9 00		lda #$00		LDA	#$00			; clear A
.bb19	38		sec			SEC				; set carry for subtract
.bb1a	e5 61		sbc $61			SBC	LAB_61		; subtract FAC1 exponent (2s complement)
.bb1c	85 61		sta $61			STA	LAB_61		; save FAC1 exponent
.bb1e	20 b7 ba	jsr $bab7		JSR	LAB_BAB7		; test and adjust accumulators
.bb21	e6 61		inc $61			INC	LAB_61		; increment FAC1 exponent
.bb23	f0 ba		beq $badf		BEQ	LAB_BADF		; if zero do overflow error
.bb25	a2 fc		ldx #$fc		LDX	#$FC			; set index to FAC temp
.bb27	a9 01		lda #$01		LDA	#$01			;.set byte
.bb29					LAB_BB29
.bb29	a4 6a		ldy $6a			LDY	LAB_6A		; get FAC2 mantissa 1
.bb2b	c4 62		cpy $62			CPY	LAB_62		; compare FAC1 mantissa 1
.bb2d	d0 10		bne $bb3f		BNE	LAB_BB3F		; branch if <>
.bb2f	a4 6b		ldy $6b			LDY	LAB_6B		; get FAC2 mantissa 2
.bb31	c4 63		cpy $63			CPY	LAB_63		; compare FAC1 mantissa 2
.bb33	d0 0a		bne $bb3f		BNE	LAB_BB3F		; branch if <>
.bb35	a4 6c		ldy $6c			LDY	LAB_6C		; get FAC2 mantissa 3
.bb37	c4 64		cpy $64			CPY	LAB_64		; compare FAC1 mantissa 3
.bb39	d0 04		bne $bb3f		BNE	LAB_BB3F		; branch if <>
.bb3b	a4 6d		ldy $6d			LDY	LAB_6D		; get FAC2 mantissa 4
.bb3d	c4 65		cpy $65			CPY	LAB_65		; compare FAC1 mantissa 4
.bb3f					LAB_BB3F
.bb3f	08		php			PHP				; save FAC2-FAC1 compare status
.bb40	2a		rol a			ROL				;.shift byte
.bb41	90 09		bcc $bb4c		BCC	LAB_BB4C		; skip next if no carry
.bb43	e8		inx			INX				; increment index to FAC temp
.bb44	95 29		sta $29,x		STA	LAB_29,X		;.
.bb46	f0 32		beq $bb7a		BEQ	LAB_BB7A		;.
.bb48	10 34		bpl $bb7e		BPL	LAB_BB7E		;.
.bb4a	a9 01		lda #$01		LDA	#$01			;.
.bb4c					LAB_BB4C
.bb4c	28		plp			PLP				; restore FAC2-FAC1 compare status
.bb4d	b0 0e		bcs $bb5d		BCS	LAB_BB5D		; if FAC2 >= FAC1 then do subtract
.bb4f					LAB_BB4F
.bb4f	06 6d		asl $6d			ASL	LAB_6D		; shift FAC2 mantissa 4
.bb51	26 6c		rol $6c			ROL	LAB_6C		; shift FAC2 mantissa 3
.bb53	26 6b		rol $6b			ROL	LAB_6B		; shift FAC2 mantissa 2
.bb55	26 6a		rol $6a			ROL	LAB_6A		; shift FAC2 mantissa 1
.bb57	b0 e6		bcs $bb3f		BCS	LAB_BB3F		; loop with no compare
.bb59	30 ce		bmi $bb29		BMI	LAB_BB29		; loop with compare
.bb5b	10 e2		bpl $bb3f		BPL	LAB_BB3F		; loop with no compare, branch always
.bb5d					LAB_BB5D
.bb5d	a8		tay			TAY				; save FAC2-FAC1 compare status
.bb5e	a5 6d		lda $6d			LDA	LAB_6D		; get FAC2 mantissa 4
.bb60	e5 65		sbc $65			SBC	LAB_65		; subtract FAC1 mantissa 4
.bb62	85 6d		sta $6d			STA	LAB_6D		; save FAC2 mantissa 4
.bb64	a5 6c		lda $6c			LDA	LAB_6C		; get FAC2 mantissa 3
.bb66	e5 64		sbc $64			SBC	LAB_64		; subtract FAC1 mantissa 3
.bb68	85 6c		sta $6c			STA	LAB_6C		; save FAC2 mantissa 3
.bb6a	a5 6b		lda $6b			LDA	LAB_6B		; get FAC2 mantissa 2
.bb6c	e5 63		sbc $63			SBC	LAB_63		; subtract FAC1 mantissa 2
.bb6e	85 6b		sta $6b			STA	LAB_6B		; save FAC2 mantissa 2
.bb70	a5 6a		lda $6a			LDA	LAB_6A		; get FAC2 mantissa 1
.bb72	e5 62		sbc $62			SBC	LAB_62		; subtract FAC1 mantissa 1
.bb74	85 6a		sta $6a			STA	LAB_6A		; save FAC2 mantissa 1
.bb76	98		tya			TYA				; restore FAC2-FAC1 compare status
.bb77	4c 4f bb	jmp $bb4f		JMP	LAB_BB4F		;.
.bb7a					LAB_BB7A
.bb7a	a9 40		lda #$40		LDA	#$40			;.
.bb7c	d0 ce		bne $bb4c		BNE	LAB_BB4C		; branch always
.bb7e					LAB_BB7E
.bb7e	0a		asl a			ASL				;.
.bb7f	0a		asl a			ASL				;.
.bb80	0a		asl a			ASL				;.
.bb81	0a		asl a			ASL				;.
.bb82	0a		asl a			ASL				;.
.bb83	0a		asl a			ASL				;.
.bb84	85 70		sta $70			STA	LAB_70		; save FAC1 rounding byte
.bb86	28		plp			PLP				; dump FAC2-FAC1 compare status
.bb87	4c 8f bb	jmp $bb8f		JMP	LAB_BB8F		; copy temp to FAC1, normalise and return
.bb8a					LAB_BB8A
.bb8a	a2 14		ldx #$14		LDX	#$14			; error $14, divide by zero error
.bb8c	4c 37 a4	jmp $a437		JMP	LAB_A437		; do error #X then warm start
.bb8f					LAB_BB8F
.bb8f	a5 26		lda $26			LDA	LAB_26		; get temp mantissa 1
.bb91	85 62		sta $62			STA	LAB_62		; save FAC1 mantissa 1
.bb93	a5 27		lda $27			LDA	LAB_27		; get temp mantissa 2
.bb95	85 63		sta $63			STA	LAB_63		; save FAC1 mantissa 2
.bb97	a5 28		lda $28			LDA	LAB_28		; get temp mantissa 3
.bb99	85 64		sta $64			STA	LAB_64		; save FAC1 mantissa 3
.bb9b	a5 29		lda $29			LDA	LAB_29		; get temp mantissa 4
.bb9d	85 65		sta $65			STA	LAB_65		; save FAC1 mantissa 4
.bb9f	4c d7 b8	jmp $b8d7		JMP	LAB_B8D7		; normalise FAC1 and return
.bba2					LAB_BBA2
.bba2	85 22		sta $22			STA	LAB_22		; save pointer low byte
.bba4	84 23		sty $23			STY	LAB_23		; save pointer high byte
.bba6	a0 04		ldy #$04		LDY	#$04			; 5 bytes to do
.bba8	b1 22		lda ($22),y		LDA	(LAB_22),Y		; get fifth byte
.bbaa	85 65		sta $65			STA	LAB_65		; save FAC1 mantissa 4
.bbac	88		dey			DEY				; decrement index
.bbad	b1 22		lda ($22),y		LDA	(LAB_22),Y		; get fourth byte
.bbaf	85 64		sta $64			STA	LAB_64		; save FAC1 mantissa 3
.bbb1	88		dey			DEY				; decrement index
.bbb2	b1 22		lda ($22),y		LDA	(LAB_22),Y		; get third byte
.bbb4	85 63		sta $63			STA	LAB_63		; save FAC1 mantissa 2
.bbb6	88		dey			DEY				; decrement index
.bbb7	b1 22		lda ($22),y		LDA	(LAB_22),Y		; get second byte
.bbb9	85 66		sta $66			STA	LAB_66		; save FAC1 sign (b7)
.bbbb	09 80		ora #$80		ORA	#$80			; set 1xxx xxxx (add normal bit)
.bbbd	85 62		sta $62			STA	LAB_62		; save FAC1 mantissa 1
.bbbf	88		dey			DEY				; decrement index
.bbc0	b1 22		lda ($22),y		LDA	(LAB_22),Y		; get first byte (exponent)
.bbc2	85 61		sta $61			STA	LAB_61		; save FAC1 exponent
.bbc4	84 70		sty $70			STY	LAB_70		; clear FAC1 rounding byte
.bbc6	60		rts			RTS
.bbc7					LAB_BBC7
.bbc7	a2 5c		ldx #$5c		LDX	#<LAB_5C		; set pointer low byte
>bbc9	2c					.byte	$2C			; makes next line BIT LAB_57A2
.bbca					LAB_BBCA
.bbca	a2 57		ldx #$57		LDX	#<LAB_57		; set pointer low byte
.bbcc	a0 00		ldy #$00		LDY	#>LAB_57		; set pointer high byte
.bbce	f0 04		beq $bbd4		BEQ	LAB_BBD4		; pack FAC1 into (XY) and return, branch always
.bbd0					LAB_BBD0
.bbd0	a6 49		ldx $49			LDX	LAB_49		; get destination pointer low byte
.bbd2	a4 4a		ldy $4a			LDY	LAB_4A		; get destination pointer high byte
.bbd4					LAB_BBD4
.bbd4	20 1b bc	jsr $bc1b		JSR	LAB_BC1B		; round FAC1
.bbd7	86 22		stx $22			STX	LAB_22		; save pointer low byte
.bbd9	84 23		sty $23			STY	LAB_23		; save pointer high byte
.bbdb	a0 04		ldy #$04		LDY	#$04			; set index
.bbdd	a5 65		lda $65			LDA	LAB_65		; get FAC1 mantissa 4
.bbdf	91 22		sta ($22),y		STA	(LAB_22),Y		; store in destination
.bbe1	88		dey			DEY				; decrement index
.bbe2	a5 64		lda $64			LDA	LAB_64		; get FAC1 mantissa 3
.bbe4	91 22		sta ($22),y		STA	(LAB_22),Y		; store in destination
.bbe6	88		dey			DEY				; decrement index
.bbe7	a5 63		lda $63			LDA	LAB_63		; get FAC1 mantissa 2
.bbe9	91 22		sta ($22),y		STA	(LAB_22),Y		; store in destination
.bbeb	88		dey			DEY				; decrement index
.bbec	a5 66		lda $66			LDA	LAB_66		; get FAC1 sign (b7)
.bbee	09 7f		ora #$7f		ORA	#$7F			; set bits x111 1111
.bbf0	25 62		and $62			AND	LAB_62		; AND in FAC1 mantissa 1
.bbf2	91 22		sta ($22),y		STA	(LAB_22),Y		; store in destination
.bbf4	88		dey			DEY				; decrement index
.bbf5	a5 61		lda $61			LDA	LAB_61		; get FAC1 exponent
.bbf7	91 22		sta ($22),y		STA	(LAB_22),Y		; store in destination
.bbf9	84 70		sty $70			STY	LAB_70		; clear FAC1 rounding byte
.bbfb	60		rts			RTS
.bbfc					LAB_BBFC
.bbfc	a5 6e		lda $6e			LDA	LAB_6E		; get FAC2 sign (b7)
.bbfe					LAB_BBFE
.bbfe	85 66		sta $66			STA	LAB_66		; save FAC1 sign (b7)
.bc00	a2 05		ldx #$05		LDX	#$05			; 5 bytes to copy
.bc02					LAB_BC02
.bc02	b5 68		lda $68,x		LDA	LAB_68,X		; get byte from FAC2,X
.bc04	95 60		sta $60,x		STA	LAB_60,X		; save byte at FAC1,X
.bc06	ca		dex			DEX				; decrement count
.bc07	d0 f9		bne $bc02		BNE	LAB_BC02		; loop if not all done
.bc09	86 70		stx $70			STX	LAB_70		; clear FAC1 rounding byte
.bc0b	60		rts			RTS
.bc0c					LAB_BC0C
.bc0c	20 1b bc	jsr $bc1b		JSR	LAB_BC1B		; round FAC1
.bc0f					LAB_BC0F
.bc0f	a2 06		ldx #$06		LDX	#$06			; 6 bytes to copy
.bc11					LAB_BC11
.bc11	b5 60		lda $60,x		LDA	LAB_60,X		; get byte from FAC1,X
.bc13	95 68		sta $68,x		STA	LAB_68,X		; save byte at FAC2,X
.bc15	ca		dex			DEX				; decrement count
.bc16	d0 f9		bne $bc11		BNE	LAB_BC11		; loop if not all done
.bc18	86 70		stx $70			STX	LAB_70		; clear FAC1 rounding byte
.bc1a					LAB_BC1A
.bc1a	60		rts			RTS
.bc1b					LAB_BC1B
.bc1b	a5 61		lda $61			LDA	LAB_61		; get FAC1 exponent
.bc1d	f0 fb		beq $bc1a		BEQ	LAB_BC1A		; exit if zero
.bc1f	06 70		asl $70			ASL	LAB_70		; shift FAC1 rounding byte
.bc21	90 f7		bcc $bc1a		BCC	LAB_BC1A		; exit if no overflow
.bc23					LAB_BC23
.bc23	20 6f b9	jsr $b96f		JSR	LAB_B96F		; increment FAC1 mantissa
.bc26	d0 f2		bne $bc1a		BNE	LAB_BC1A		; branch if no overflow
.bc28	4c 38 b9	jmp $b938		JMP	LAB_B938		; nornalise FAC1 for C=1 and return
.bc2b					LAB_BC2B
.bc2b	a5 61		lda $61			LDA	LAB_61		; get FAC1 exponent
.bc2d	f0 09		beq $bc38		BEQ	LAB_BC38		; exit if zero (allready correct SGN(0)=0)
.bc2f					LAB_BC2F
.bc2f	a5 66		lda $66			LDA	LAB_66		; else get FAC1 sign (b7)
.bc31					LAB_BC31
.bc31	2a		rol a			ROL				; move sign bit to carry
.bc32	a9 ff		lda #$ff		LDA	#$FF			; set byte for -ve result
.bc34	b0 02		bcs $bc38		BCS	LAB_BC38		; return if sign was set (-ve)
.bc36	a9 01		lda #$01		LDA	#$01			; else set byte for +ve result
.bc38					LAB_BC38
.bc38	60		rts			RTS
.bc39					LAB_BC39
.bc39	20 2b bc	jsr $bc2b		JSR	LAB_BC2B		; get FAC1 sign, return A = $FF -ve, A = $01 +ve
.bc3c					LAB_BC3C
.bc3c	85 62		sta $62			STA	LAB_62		; save FAC1 mantissa 1
.bc3e	a9 00		lda #$00		LDA	#$00			; clear A
.bc40	85 63		sta $63			STA	LAB_63		; clear FAC1 mantissa 2
.bc42	a2 88		ldx #$88		LDX	#$88			; set exponent
.bc44					LAB_BC44
.bc44	a5 62		lda $62			LDA	LAB_62		; get FAC1 mantissa 1
.bc46	49 ff		eor #$ff		EOR	#$FF			; complement it
.bc48	2a		rol a			ROL				; sign bit into carry
.bc49					LAB_BC49
.bc49	a9 00		lda #$00		LDA	#$00			; clear A
.bc4b	85 65		sta $65			STA	LAB_65		; clear FAC1 mantissa 4
.bc4d	85 64		sta $64			STA	LAB_64		; clear FAC1 mantissa 3
.bc4f					LAB_BC4F
.bc4f	86 61		stx $61			STX	LAB_61		; set FAC1 exponent
.bc51	85 70		sta $70			STA	LAB_70		; clear FAC1 rounding byte
.bc53	85 66		sta $66			STA	LAB_66		; clear FAC1 sign (b7)
.bc55	4c d2 b8	jmp $b8d2		JMP	LAB_B8D2		; do ABS and normalise FAC1
.bc58					LAB_BC58
.bc58	46 66		lsr $66			LSR	LAB_66		; clear FAC1 sign, put zero in b7
.bc5a	60		rts			RTS
.bc5b					LAB_BC5B
.bc5b	85 24		sta $24			STA	LAB_24		; save pointer low byte
.bc5d					LAB_BC5D
.bc5d	84 25		sty $25			STY	LAB_25		; save pointer high byte
.bc5f	a0 00		ldy #$00		LDY	#$00			; clear index
.bc61	b1 24		lda ($24),y		LDA	(LAB_24),Y		; get exponent
.bc63	c8		iny			INY				; increment index
.bc64	aa		tax			TAX				; copy (AY) exponent to X
.bc65	f0 c4		beq $bc2b		BEQ	LAB_BC2B		; branch if (AY) exponent=0 and get FAC1 sign
.bc67	b1 24		lda ($24),y		LDA	(LAB_24),Y		; get (AY) mantissa 1, with sign
.bc69	45 66		eor $66			EOR	LAB_66		; EOR FAC1 sign (b7)
.bc6b	30 c2		bmi $bc2f		BMI	LAB_BC2F		; if signs <> do return A = $FF, Cb = 1/-ve
.bc6d	e4 61		cpx $61			CPX	LAB_61		; compare (AY) exponent with FAC1 exponent
.bc6f	d0 21		bne $bc92		BNE	LAB_BC92		; branch if different
.bc71	b1 24		lda ($24),y		LDA	(LAB_24),Y		; get (AY) mantissa 1, with sign
.bc73	09 80		ora #$80		ORA	#$80			; normalise top bit
.bc75	c5 62		cmp $62			CMP	LAB_62		; compare with FAC1 mantissa 1
.bc77	d0 19		bne $bc92		BNE	LAB_BC92		; branch if different
.bc79	c8		iny			INY				; increment index
.bc7a	b1 24		lda ($24),y		LDA	(LAB_24),Y		; get mantissa 2
.bc7c	c5 63		cmp $63			CMP	LAB_63		; compare with FAC1 mantissa 2
.bc7e	d0 12		bne $bc92		BNE	LAB_BC92		; branch if different
.bc80	c8		iny			INY				; increment index
.bc81	b1 24		lda ($24),y		LDA	(LAB_24),Y		; get mantissa 3
.bc83	c5 64		cmp $64			CMP	LAB_64		; compare with FAC1 mantissa 3
.bc85	d0 0b		bne $bc92		BNE	LAB_BC92		; branch if different
.bc87	c8		iny			INY				; increment index
.bc88	a9 7f		lda #$7f		LDA	#$7F			; set for 1/2 value rounding byte
.bc8a	c5 70		cmp $70			CMP	LAB_70		; compare with FAC1 rounding byte (set carry)
.bc8c	b1 24		lda ($24),y		LDA	(LAB_24),Y		; get mantissa 4
.bc8e	e5 65		sbc $65			SBC	LAB_65		; subtract FAC1 mantissa 4
.bc90	f0 28		beq $bcba		BEQ	LAB_BCBA		; exit if mantissa 4 equal
.bc92					LAB_BC92
.bc92	a5 66		lda $66			LDA	LAB_66		; get FAC1 sign (b7)
.bc94	90 02		bcc $bc98		BCC	LAB_BC98		; branch if FAC1 > (AY)
.bc96	49 ff		eor #$ff		EOR	#$FF			; else toggle FAC1 sign
.bc98					LAB_BC98
.bc98	4c 31 bc	jmp $bc31		JMP	LAB_BC31		; return A = $FF, Cb = 1/-ve A = $01, Cb = 0/+ve
.bc9b					LAB_BC9B
.bc9b	a5 61		lda $61			LDA	LAB_61		; get FAC1 exponent
.bc9d	f0 4a		beq $bce9		BEQ	LAB_BCE9		; if zero go clear FAC1 and return
.bc9f	38		sec			SEC				; set carry for subtract
.bca0	e9 a0		sbc #$a0		SBC	#$A0			; subtract maximum integer range exponent
.bca2	24 66		bit $66			BIT	LAB_66		; test FAC1 sign (b7)
.bca4	10 09		bpl $bcaf		BPL	LAB_BCAF		; branch if FAC1 +ve
.bca6	aa		tax			TAX				; copy subtracted exponent
.bca7	a9 ff		lda #$ff		LDA	#$FF			; overflow for -ve number
.bca9	85 68		sta $68			STA	LAB_68		; set FAC1 overflow byte
.bcab	20 4d b9	jsr $b94d		JSR	LAB_B94D		; twos complement FAC1 mantissa
.bcae	8a		txa			TXA				; restore subtracted exponent
.bcaf					LAB_BCAF
.bcaf	a2 61		ldx #$61		LDX	#$61			; set index to FAC1
.bcb1	c9 f9		cmp #$f9		CMP	#$F9			; compare exponent result
.bcb3	10 06		bpl $bcbb		BPL	LAB_BCBB		; if < 8 shifts shift FAC1 A times right and return
.bcb5	20 99 b9	jsr $b999		JSR	LAB_B999		; shift FAC1 A times right (> 8 shifts)
.bcb8	84 68		sty $68			STY	LAB_68		; clear FAC1 overflow byte
.bcba					LAB_BCBA
.bcba	60		rts			RTS
.bcbb					LAB_BCBB
.bcbb	a8		tay			TAY				; copy shift count
.bcbc	a5 66		lda $66			LDA	LAB_66		; get FAC1 sign (b7)
.bcbe	29 80		and #$80		AND	#$80			; mask sign bit only (x000 0000)
.bcc0	46 62		lsr $62			LSR	LAB_62		; shift FAC1 mantissa 1
.bcc2	05 62		ora $62			ORA	LAB_62		; OR sign in b7 FAC1 mantissa 1
.bcc4	85 62		sta $62			STA	LAB_62		; save FAC1 mantissa 1
.bcc6	20 b0 b9	jsr $b9b0		JSR	LAB_B9B0		; shift FAC1 Y times right
.bcc9	84 68		sty $68			STY	LAB_68		; clear FAC1 overflow byte
.bccb	60		rts			RTS
.bccc					LAB_BCCC
.bccc	a5 61		lda $61			LDA	LAB_61		; get FAC1 exponent
.bcce	c9 a0		cmp #$a0		CMP	#$A0			; compare with max int
.bcd0	b0 20		bcs $bcf2		BCS	LAB_BCF2		; exit if >= (allready int, too big for fractional part!)
.bcd2	20 9b bc	jsr $bc9b		JSR	LAB_BC9B		; convert FAC1 floating to fixed
.bcd5	84 70		sty $70			STY	LAB_70		; save FAC1 rounding byte
.bcd7	a5 66		lda $66			LDA	LAB_66		; get FAC1 sign (b7)
.bcd9	84 66		sty $66			STY	LAB_66		; save FAC1 sign (b7)
.bcdb	49 80		eor #$80		EOR	#$80			; toggle FAC1 sign
.bcdd	2a		rol a			ROL				; shift into carry
.bcde	a9 a0		lda #$a0		LDA	#$A0			; set new exponent
.bce0	85 61		sta $61			STA	LAB_61		; save FAC1 exponent
.bce2	a5 65		lda $65			LDA	LAB_65		; get FAC1 mantissa 4
.bce4	85 07		sta $07			STA	LAB_07		; save FAC1 mantissa 4 for power function
.bce6	4c d2 b8	jmp $b8d2		JMP	LAB_B8D2		; do ABS and normalise FAC1
.bce9					LAB_BCE9
.bce9	85 62		sta $62			STA	LAB_62		; clear FAC1 mantissa 1
.bceb	85 63		sta $63			STA	LAB_63		; clear FAC1 mantissa 2
.bced	85 64		sta $64			STA	LAB_64		; clear FAC1 mantissa 3
.bcef	85 65		sta $65			STA	LAB_65		; clear FAC1 mantissa 4
.bcf1	a8		tay			TAY				; clear Y
.bcf2					LAB_BCF2
.bcf2	60		rts			RTS
.bcf3					LAB_BCF3
.bcf3	a0 00		ldy #$00		LDY	#$00			; clear Y
.bcf5	a2 0a		ldx #$0a		LDX	#$0A			; set index
.bcf7					LAB_BCF7
.bcf7	94 5d		sty $5d,x		STY	LAB_5D,X		; clear byte
.bcf9	ca		dex			DEX				; decrement index
.bcfa	10 fb		bpl $bcf7		BPL	LAB_BCF7		; loop until numexp to negnum (and FAC1) = $00
.bcfc	90 0f		bcc $bd0d		BCC	LAB_BD0D		; branch if first character is numeric
.bcfe	c9 2d		cmp #$2d		CMP	#'-'			; else compare with "-"
.bd00	d0 04		bne $bd06		BNE	LAB_BD06		; branch if not "-"
.bd02	86 67		stx $67			STX	LAB_67		; set flag for -ve n (negnum = $FF)
.bd04	f0 04		beq $bd0a		BEQ	LAB_BD0A		; branch always
.bd06					LAB_BD06
.bd06	c9 2b		cmp #$2b		CMP	#'+'			; else compare with "+"
.bd08	d0 05		bne $bd0f		BNE	LAB_BD0F		; branch if not "+"
.bd0a					LAB_BD0A
.bd0a	20 73 00	jsr $0073		JSR	LAB_0073		; increment and scan memory
.bd0d					LAB_BD0D
.bd0d	90 5b		bcc $bd6a		BCC	LAB_BD6A		; branch if numeric character
.bd0f					LAB_BD0F
.bd0f	c9 2e		cmp #$2e		CMP	#'.'			; else compare with "."
.bd11	f0 2e		beq $bd41		BEQ	LAB_BD41		; branch if "."
.bd13	c9 45		cmp #$45		CMP	#'E'			; else compare with "E"
.bd15	d0 30		bne $bd47		BNE	LAB_BD47		; branch if not "E"
.bd17	20 73 00	jsr $0073		JSR	LAB_0073		; increment and scan memory
.bd1a	90 17		bcc $bd33		BCC	LAB_BD33		; branch if numeric character
.bd1c	c9 ab		cmp #$ab		CMP	#TK_MINUS		; else compare with token for -
.bd1e	f0 0e		beq $bd2e		BEQ	LAB_BD2E		; branch if token for -
.bd20	c9 2d		cmp #$2d		CMP	#'-'			; else compare with "-"
.bd22	f0 0a		beq $bd2e		BEQ	LAB_BD2E		; branch if "-"
.bd24	c9 aa		cmp #$aa		CMP	#TK_PLUS		; else compare with token for +
.bd26	f0 08		beq $bd30		BEQ	LAB_BD30		; branch if token for +
.bd28	c9 2b		cmp #$2b		CMP	#'+'			; else compare with "+"
.bd2a	f0 04		beq $bd30		BEQ	LAB_BD30		; branch if "+"
.bd2c	d0 07		bne $bd35		BNE	LAB_BD35		; branch always
.bd2e					LAB_BD2E
.bd2e	66 60		ror $60			ROR	LAB_60		; set exponent -ve flag (C, which=1, into b7)
.bd30					LAB_BD30
.bd30	20 73 00	jsr $0073		JSR	LAB_0073		; increment and scan memory
.bd33					LAB_BD33
.bd33	90 5c		bcc $bd91		BCC	LAB_BD91		; branch if numeric character
.bd35					LAB_BD35
.bd35	24 60		bit $60			BIT	LAB_60		; test exponent -ve flag
.bd37	10 0e		bpl $bd47		BPL	LAB_BD47		; if +ve go evaluate exponent
.bd39	a9 00		lda #$00		LDA	#$00			; clear result
.bd3b	38		sec			SEC				; set carry for subtract
.bd3c	e5 5e		sbc $5e			SBC	LAB_5E		; subtract exponent byte
.bd3e	4c 49 bd	jmp $bd49		JMP	LAB_BD49		; go evaluate exponent
.bd41					LAB_BD41
.bd41	66 5f		ror $5f			ROR	LAB_5F		; set decimal point flag
.bd43	24 5f		bit $5f			BIT	LAB_5F		; test decimal point flag
.bd45	50 c3		bvc $bd0a		BVC	LAB_BD0A		; branch if only one decimal point so far
.bd47					LAB_BD47
.bd47	a5 5e		lda $5e			LDA	LAB_5E		; get exponent count byte
.bd49					LAB_BD49
.bd49	38		sec			SEC				; set carry for subtract
.bd4a	e5 5d		sbc $5d			SBC	LAB_5D		; subtract numerator exponent
.bd4c	85 5e		sta $5e			STA	LAB_5E		; save exponent count byte
.bd4e	f0 12		beq $bd62		BEQ	LAB_BD62		; branch if no adjustment
.bd50	10 09		bpl $bd5b		BPL	LAB_BD5B		; else if +ve go do FAC1*10^expcnt
.bd52					LAB_BD52
.bd52	20 fe ba	jsr $bafe		JSR	LAB_BAFE		; divide FAC1 by 10
.bd55	e6 5e		inc $5e			INC	LAB_5E		; increment exponent count byte
.bd57	d0 f9		bne $bd52		BNE	LAB_BD52		; loop until all done
.bd59	f0 07		beq $bd62		BEQ	LAB_BD62		; branch always
.bd5b					LAB_BD5B
.bd5b	20 e2 ba	jsr $bae2		JSR	LAB_BAE2		; multiply FAC1 by 10
.bd5e	c6 5e		dec $5e			DEC	LAB_5E		; decrement exponent count byte
.bd60	d0 f9		bne $bd5b		BNE	LAB_BD5B		; loop until all done
.bd62					LAB_BD62
.bd62	a5 67		lda $67			LDA	LAB_67		; get -ve flag
.bd64	30 01		bmi $bd67		BMI	LAB_BD67		; if -ve do - FAC1 and return
.bd66	60		rts			RTS
.bd67					LAB_BD67
.bd67	4c b4 bf	jmp $bfb4		JMP	LAB_BFB4		; do - FAC1
.bd6a					LAB_BD6A
.bd6a	48		pha			PHA				; save character
.bd6b	24 5f		bit $5f			BIT	LAB_5F		; test decimal point flag
.bd6d	10 02		bpl $bd71		BPL	LAB_BD71		; skip exponent increment if not set
.bd6f	e6 5d		inc $5d			INC	LAB_5D		; else increment number exponent
.bd71					LAB_BD71
.bd71	20 e2 ba	jsr $bae2		JSR	LAB_BAE2		; multiply FAC1 by 10
.bd74	68		pla			PLA				; restore character
.bd75	38		sec			SEC				; set carry for subtract
.bd76	e9 30		sbc #$30		SBC	#'0'			; convert to binary
.bd78	20 7e bd	jsr $bd7e		JSR	LAB_BD7E		; evaluate new ASCII digit
.bd7b	4c 0a bd	jmp $bd0a		JMP	LAB_BD0A		; go do next character
.bd7e					LAB_BD7E
.bd7e	48		pha			PHA				; save digit
.bd7f	20 0c bc	jsr $bc0c		JSR	LAB_BC0C		; round and copy FAC1 to FAC2
.bd82	68		pla			PLA				; restore digit
.bd83	20 3c bc	jsr $bc3c		JSR	LAB_BC3C		; save A as integer byte
.bd86	a5 6e		lda $6e			LDA	LAB_6E		; get FAC2 sign (b7)
.bd88	45 66		eor $66			EOR	LAB_66		; toggle with FAC1 sign (b7)
.bd8a	85 6f		sta $6f			STA	LAB_6F		; save sign compare (FAC1 EOR FAC2)
.bd8c	a6 61		ldx $61			LDX	LAB_61		; get FAC1 exponent
.bd8e	4c 6a b8	jmp $b86a		JMP	LAB_B86A		; add FAC2 to FAC1 and return
.bd91					LAB_BD91
.bd91	a5 5e		lda $5e			LDA	LAB_5E		; get exponent count byte
.bd93	c9 0a		cmp #$0a		CMP	#$0A			; compare with 10 decimal
.bd95	90 09		bcc $bda0		BCC	LAB_BDA0		; branch if less
.bd97	a9 64		lda #$64		LDA	#$64			; make all -ve exponents = -100 decimal (causes underflow)
.bd99	24 60		bit $60			BIT	LAB_60		; test exponent -ve flag
.bd9b	30 11		bmi $bdae		BMI	LAB_BDAE		; branch if -ve
.bd9d	4c 7e b9	jmp $b97e		JMP	LAB_B97E		; else do overflow error then warm start
.bda0					LAB_BDA0
.bda0	0a		asl a			ASL				; *2
.bda1	0a		asl a			ASL				; *4
.bda2	18		clc			CLC				; clear carry for add
.bda3	65 5e		adc $5e			ADC	LAB_5E		; *5
.bda5	0a		asl a			ASL				; *10
.bda6	18		clc			CLC				; clear carry for add
.bda7	a0 00		ldy #$00		LDY	#$00			; set index
.bda9	71 7a		adc ($7a),y		ADC	(LAB_7A),Y		; add character (will be $30 too much!)
.bdab	38		sec			SEC				; set carry for subtract
.bdac	e9 30		sbc #$30		SBC	#'0'			; convert character to binary
.bdae					LAB_BDAE
.bdae	85 5e		sta $5e			STA	LAB_5E		; save exponent count byte
.bdb0	4c 30 bd	jmp $bd30		JMP	LAB_BD30		; go get next character
.bdb3					LAB_BDB3
>bdb3	9b 3e bc 1f fd				.byte	$9B,$3E,$BC,$1F,$FD
.bdb8					LAB_BDB8
>bdb8	9e 6e 6b 27 fd				.byte	$9E,$6E,$6B,$27,$FD
.bdbd					LAB_BDBD
>bdbd	9e 6e 6b 28 00				.byte	$9E,$6E,$6B,$28,$00
.bdc2					LAB_BDC2
.bdc2	a9 71		lda #$71		LDA	#<LAB_A371		; set " IN " pointer low byte
.bdc4	a0 a3		ldy #$a3		LDY	#>LAB_A371		; set " IN " pointer high byte
.bdc6	20 da bd	jsr $bdda		JSR	LAB_BDDA		; print null terminated string
.bdc9	a5 3a		lda $3a			LDA	LAB_3A		; get the current line number high byte
.bdcb	a6 39		ldx $39			LDX	LAB_39		; get the current line number low byte
.bdcd					LAB_BDCD
.bdcd	85 62		sta $62			STA	LAB_62		; save high byte as FAC1 mantissa1
.bdcf	86 63		stx $63			STX	LAB_63		; save low byte as FAC1 mantissa2
.bdd1	a2 90		ldx #$90		LDX	#$90			; set exponent to 16d bits
.bdd3	38		sec			SEC				; set integer is +ve flag
.bdd4	20 49 bc	jsr $bc49		JSR	LAB_BC49		; set exponent = X, clear mantissa 4 and 3 and normalise
.bdd7	20 df bd	jsr $bddf		JSR	LAB_BDDF		; convert FAC1 to string
.bdda					LAB_BDDA
.bdda	4c 1e ab	jmp $ab1e		JMP	LAB_AB1E		; print null terminated string
.bddd					LAB_BDDD
.bddd	a0 01		ldy #$01		LDY	#$01			; set index = 1
.bddf					LAB_BDDF
.bddf	a9 20		lda #$20		LDA	#' '			; character = " " (assume +ve)
.bde1	24 66		bit $66			BIT	LAB_66		; test FAC1 sign (b7)
.bde3	10 02		bpl $bde7		BPL	LAB_BDE7		; branch if +ve
.bde5	a9 2d		lda #$2d		LDA	#'-'			; else character = "-"
.bde7					LAB_BDE7
.bde7	99 ff 00	sta $00ff,y		STA	LAB_FF,Y		; save leading character (" " or "-")
.bdea	85 66		sta $66			STA	LAB_66		; save FAC1 sign (b7)
.bdec	84 71		sty $71			STY	LAB_71		; save index
.bdee	c8		iny			INY				; increment index
.bdef	a9 30		lda #$30		LDA	#'0'			; set character = "0"
.bdf1	a6 61		ldx $61			LDX	LAB_61		; get FAC1 exponent
.bdf3	d0 03		bne $bdf8		BNE	LAB_BDF8		; branch if FAC1<>0
.bdf5	4c 04 bf	jmp $bf04		JMP	LAB_BF04		; save last character, [EOT] and exit
.bdf8					LAB_BDF8
.bdf8	a9 00		lda #$00		LDA	#$00			; clear (number exponent count)
.bdfa	e0 80		cpx #$80		CPX	#$80			; compare FAC1 exponent with $80 (<1.00000)
.bdfc					LAB_BDFC
.bdfc	f0 02		beq $be00		BEQ	LAB_BE00		; branch if 0.5 <= FAC1 < 1.0
.bdfe	b0 09		bcs $be09		BCS	LAB_BE09		; branch if FAC1=>1
.be00					LAB_BE00
.be00	a9 bd		lda #$bd		LDA	#<LAB_BDBD		; set 1000000000 pointer low byte
.be02	a0 bd		ldy #$bd		LDY	#>LAB_BDBD		; set 1000000000 pointer high byte
.be04	20 28 ba	jsr $ba28		JSR	LAB_BA28		; do convert AY, FCA1*(AY)
.be07	a9 f7		lda #$f7		LDA	#$F7			; set number exponent count
.be09					LAB_BE09
.be09	85 5d		sta $5d			STA	LAB_5D		; save number exponent count
.be0b					LAB_BE0B
.be0b	a9 b8		lda #$b8		LDA	#<LAB_BDB8		; set 999999999.25 pointer low byte (max before sci note)
.be0d	a0 bd		ldy #$bd		LDY	#>LAB_BDB8		; set 999999999.25 pointer high byte
.be0f	20 5b bc	jsr $bc5b		JSR	LAB_BC5B		; compare FAC1 with (AY)
.be12	f0 1e		beq $be32		BEQ	LAB_BE32		; exit if FAC1 = (AY)
.be14	10 12		bpl $be28		BPL	LAB_BE28		; go do /10 if FAC1 > (AY)
.be16					LAB_BE16
.be16	a9 b3		lda #$b3		LDA	#<LAB_BDB3		; set 99999999.90625 pointer low byte
.be18	a0 bd		ldy #$bd		LDY	#>LAB_BDB3		; set 99999999.90625 pointer high byte
.be1a	20 5b bc	jsr $bc5b		JSR	LAB_BC5B		; compare FAC1 with (AY)
.be1d	f0 02		beq $be21		BEQ	LAB_BE21		; branch if FAC1 = (AY) (allow decimal places)
.be1f	10 0e		bpl $be2f		BPL	LAB_BE2F		; branch if FAC1 > (AY) (no decimal places)
.be21					LAB_BE21
.be21	20 e2 ba	jsr $bae2		JSR	LAB_BAE2		; multiply FAC1 by 10
.be24	c6 5d		dec $5d			DEC	LAB_5D		; decrement number exponent count
.be26	d0 ee		bne $be16		BNE	LAB_BE16		; go test again, branch always
.be28					LAB_BE28
.be28	20 fe ba	jsr $bafe		JSR	LAB_BAFE		; divide FAC1 by 10
.be2b	e6 5d		inc $5d			INC	LAB_5D		; increment number exponent count
.be2d	d0 dc		bne $be0b		BNE	LAB_BE0B		; go test again, branch always
.be2f					LAB_BE2F
.be2f	20 49 b8	jsr $b849		JSR	LAB_B849		; add 0.5 to FAC1 (round FAC1)
.be32					LAB_BE32
.be32	20 9b bc	jsr $bc9b		JSR	LAB_BC9B		; convert FAC1 floating to fixed
.be35	a2 01		ldx #$01		LDX	#$01			; set default digits before dp = 1
.be37	a5 5d		lda $5d			LDA	LAB_5D		; get number exponent count
.be39	18		clc			CLC				; clear carry for add
.be3a	69 0a		adc #$0a		ADC	#$0A			; up to 9 digits before point
.be3c	30 09		bmi $be47		BMI	LAB_BE47		; if -ve then 1 digit before dp
.be3e	c9 0b		cmp #$0b		CMP	#$0B			; A>=$0B if n>=1E9
.be40	b0 06		bcs $be48		BCS	LAB_BE48		; branch if >= $0B
.be42	69 ff		adc #$ff		ADC	#$FF			; take 1 from digit count
.be44	aa		tax			TAX				; copy to X
.be45	a9 02		lda #$02		LDA	#$02			;.set exponent adjust
.be47					LAB_BE47
.be47	38		sec			SEC				; set carry for subtract
.be48					LAB_BE48
.be48	e9 02		sbc #$02		SBC	#$02			; -2
.be4a	85 5e		sta $5e			STA	LAB_5E		;.save exponent adjust
.be4c	86 5d		stx $5d			STX	LAB_5D		; save digits before dp count
.be4e	8a		txa			TXA				; copy to A
.be4f	f0 02		beq $be53		BEQ	LAB_BE53		; branch if no digits before dp
.be51	10 13		bpl $be66		BPL	LAB_BE66		; branch if digits before dp
.be53					LAB_BE53
.be53	a4 71		ldy $71			LDY	LAB_71		; get output string index
.be55	a9 2e		lda #$2e		LDA	#'.'			; character "."
.be57	c8		iny			INY				; increment index
.be58	99 ff 00	sta $00ff,y		STA	LAB_FF,Y		; save to output string
.be5b	8a		txa			TXA				;.
.be5c	f0 06		beq $be64		BEQ	LAB_BE64		;.
.be5e	a9 30		lda #$30		LDA	#'0'			; character "0"
.be60	c8		iny			INY				; increment index
.be61	99 ff 00	sta $00ff,y		STA	LAB_FF,Y		; save to output string
.be64					LAB_BE64
.be64	84 71		sty $71			STY	LAB_71		; save output string index
.be66					LAB_BE66
.be66	a0 00		ldy #$00		LDY	#$00			; clear index (point to 100,000)
.be68					LAB_BE68
.be68	a2 80		ldx #$80		LDX	#$80			;.
.be6a					LAB_BE6A
.be6a	a5 65		lda $65			LDA	LAB_65		; get FAC1 mantissa 4
.be6c	18		clc			CLC				; clear carry for add
.be6d	79 19 bf	adc $bf19,y		ADC	LAB_BF16+3,Y	; add byte 4, least significant
.be70	85 65		sta $65			STA	LAB_65		; save FAC1 mantissa4
.be72	a5 64		lda $64			LDA	LAB_64		; get FAC1 mantissa 3
.be74	79 18 bf	adc $bf18,y		ADC	LAB_BF16+2,Y	; add byte 3
.be77	85 64		sta $64			STA	LAB_64		; save FAC1 mantissa3
.be79	a5 63		lda $63			LDA	LAB_63		; get FAC1 mantissa 2
.be7b	79 17 bf	adc $bf17,y		ADC	LAB_BF16+1,Y	; add byte 2
.be7e	85 63		sta $63			STA	LAB_63		; save FAC1 mantissa2
.be80	a5 62		lda $62			LDA	LAB_62		; get FAC1 mantissa 1
.be82	79 16 bf	adc $bf16,y		ADC	LAB_BF16+0,Y	; add byte 1, most significant
.be85	85 62		sta $62			STA	LAB_62		; save FAC1 mantissa1
.be87	e8		inx			INX				; increment the digit, set the sign on the test sense bit
.be88	b0 04		bcs $be8e		BCS	LAB_BE8E		; if the carry is set go test if the result was positive
.be8a	10 de		bpl $be6a		BPL	LAB_BE6A		; not -ve so try again
.be8c	30 02		bmi $be90		BMI	LAB_BE90		; else done so return the digit
.be8e					LAB_BE8E
.be8e	30 da		bmi $be6a		BMI	LAB_BE6A		; not +ve so try again
.be90					LAB_BE90
.be90	8a		txa			TXA				; copy the digit
.be91	90 04		bcc $be97		BCC	LAB_BE97		; if Cb=0 just use it
.be93	49 ff		eor #$ff		EOR	#$FF			; else make the 2's complement ..
.be95	69 0a		adc #$0a		ADC	#$0A			; .. and subtract it from 10
.be97					LAB_BE97
.be97	69 2f		adc #$2f		ADC	#'0'-1		; add "0"-1 to result
.be99	c8		iny			INY				; increment ..
.be9a	c8		iny			INY				; .. index to..
.be9b	c8		iny			INY				; .. next less ..
.be9c	c8		iny			INY				; .. power of ten
.be9d	84 47		sty $47			STY	LAB_47		; save current variable pointer low byte
.be9f	a4 71		ldy $71			LDY	LAB_71		; get output string index
.bea1	c8		iny			INY				; increment output string index
.bea2	aa		tax			TAX				; copy character to X
.bea3	29 7f		and #$7f		AND	#$7F			; mask out top bit
.bea5	99 ff 00	sta $00ff,y		STA	LAB_FF,Y		; save to output string
.bea8	c6 5d		dec $5d			DEC	LAB_5D		; decrement # of characters before the dp
.beaa	d0 06		bne $beb2		BNE	LAB_BEB2		; branch if still characters to do
.beac	a9 2e		lda #$2e		LDA	#'.'			; character "."
.beae	c8		iny			INY				; increment output string index
.beaf	99 ff 00	sta $00ff,y		STA	LAB_0100-1,Y	; save to output string
.beb2					LAB_BEB2
.beb2	84 71		sty $71			STY	LAB_71		; save output string index
.beb4	a4 47		ldy $47			LDY	LAB_47		; get current variable pointer low byte
.beb6	8a		txa			TXA				; get character back
.beb7	49 ff		eor #$ff		EOR	#$FF			; toggle the test sense bit
.beb9	29 80		and #$80		AND	#$80			; clear the digit
.bebb	aa		tax			TAX				; copy it to the new digit
.bebc	c0 24		cpy #$24		CPY	#LAB_BF3A-LAB_BF16
.bebe	f0 04		beq $bec4		BEQ	LAB_BEC4		; if at the max exit the digit loop
.bec0	c0 3c		cpy #$3c		CPY	#LAB_BF52-LAB_BF16
.bec2	d0 a6		bne $be6a		BNE	LAB_BE6A		; loop if not at the max
.bec4					LAB_BEC4
.bec4	a4 71		ldy $71			LDY	LAB_71		; restore the output string index
.bec6					LAB_BEC6
.bec6	b9 ff 00	lda $00ff,y		LDA	LAB_0100-1,Y	; get character from output string
.bec9	88		dey			DEY				; decrement output string index
.beca	c9 30		cmp #$30		CMP	#'0'			; compare with "0"
.becc	f0 f8		beq $bec6		BEQ	LAB_BEC6		; loop until non "0" character found
.bece	c9 2e		cmp #$2e		CMP	#'.'			; compare with "."
.bed0	f0 01		beq $bed3		BEQ	LAB_BED3		; branch if was dp
.bed2	c8		iny			INY				; increment output string index
.bed3					LAB_BED3
.bed3	a9 2b		lda #$2b		LDA	#'+'			; character "+"
.bed5	a6 5e		ldx $5e			LDX	LAB_5E		; get exponent count
.bed7	f0 2e		beq $bf07		BEQ	LAB_BF07		; if zero go set null terminator and exit
.bed9	10 08		bpl $bee3		BPL	LAB_BEE3		; branch if exponent count +ve
.bedb	a9 00		lda #$00		LDA	#$00			; clear A
.bedd	38		sec			SEC				; set carry for subtract
.bede	e5 5e		sbc $5e			SBC	LAB_5E		; subtract exponent count adjust (convert -ve to +ve)
.bee0	aa		tax			TAX				; copy exponent count to X
.bee1	a9 2d		lda #$2d		LDA	#'-'			; character "-"
.bee3					LAB_BEE3
.bee3	99 01 01	sta $0101,y		STA	LAB_0100+1,Y	; save to output string
.bee6	a9 45		lda #$45		LDA	#'E'			; character "E"
.bee8	99 00 01	sta $0100,y		STA	LAB_0100,Y		; save exponent sign to output string
.beeb	8a		txa			TXA				; get exponent count back
.beec	a2 2f		ldx #$2f		LDX	#'0'-1		; one less than "0" character
.beee	38		sec			SEC				; set carry for subtract
.beef					LAB_BEEF
.beef	e8		inx			INX				; increment 10's character
.bef0	e9 0a		sbc #$0a		SBC	#$0A			;.subtract 10 from exponent count
.bef2	b0 fb		bcs $beef		BCS	LAB_BEEF		; loop while still >= 0
.bef4	69 3a		adc #$3a		ADC	#':'			; add character ":" ($30+$0A, result is 10 less that value)
.bef6	99 03 01	sta $0103,y		STA	LAB_0100+3,Y	; save to output string
.bef9	8a		txa			TXA				; copy 10's character
.befa	99 02 01	sta $0102,y		STA	LAB_0100+2,Y	; save to output string
.befd	a9 00		lda #$00		LDA	#$00			; set null terminator
.beff	99 04 01	sta $0104,y		STA	LAB_0100+4,Y	; save to output string
.bf02	f0 08		beq $bf0c		BEQ	LAB_BF0C		; go set string pointer (AY) and exit, branch always
.bf04					LAB_BF04
.bf04	99 ff 00	sta $00ff,y		STA	LAB_0100-1,Y	; save last character to output string
.bf07					LAB_BF07
.bf07	a9 00		lda #$00		LDA	#$00			; set null terminator
.bf09	99 00 01	sta $0100,y		STA	LAB_0100,Y		; save after last character
.bf0c					LAB_BF0C
.bf0c	a9 00		lda #$00		LDA	#<LAB_0100		; set result string pointer low byte
.bf0e	a0 01		ldy #$01		LDY	#>LAB_0100		; set result string pointer high byte
.bf10	60		rts			RTS
.bf11					LAB_BF11
>bf11	80 00					.byte	$80,$00		; 0.5, first two bytes
.bf13					LAB_BF13
>bf13	00 00 00				.byte	$00,$00,$00		; null return for undefined variables
.bf16					LAB_BF16
>bf16	fa 0a 1f 00				.byte	$FA,$0A,$1F,$00	; -100000000
>bf1a	00 98 96 80				.byte	$00,$98,$96,$80	;  +10000000
>bf1e	ff f0 bd c0				.byte	$FF,$F0,$BD,$C0	;   -1000000
>bf22	00 01 86 a0				.byte	$00,$01,$86,$A0	;    +100000
>bf26	ff ff d8 f0				.byte	$FF,$FF,$D8,$F0	;     -10000
>bf2a	00 00 03 e8				.byte	$00,$00,$03,$E8	;      +1000
>bf2e	ff ff ff 9c				.byte	$FF,$FF,$FF,$9C	;       -100
>bf32	00 00 00 0a				.byte	$00,$00,$00,$0A	;        +10
>bf36	ff ff ff ff				.byte	$FF,$FF,$FF,$FF	;         -1
.bf3a					LAB_BF3A
>bf3a	ff df 0a 80				.byte	$FF,$DF,$0A,$80	; -2160000	10s hours
>bf3e	00 03 4b c0				.byte	$00,$03,$4B,$C0	;  +216000	    hours
>bf42	ff ff 73 60				.byte	$FF,$FF,$73,$60	;   -36000	10s mins
>bf46	00 00 0e 10				.byte	$00,$00,$0E,$10	;    +3600	    mins
>bf4a	ff ff fd a8				.byte	$FF,$FF,$FD,$A8	;     -600	10s secs
>bf4e	00 00 00 3c				.byte	$00,$00,$00,$3C	;      +60	    secs
.bf52					LAB_BF52
>bf52	ec					.byte	$EC			; checksum byte
>bf53	aa aa aa aa aa aa aa aa			.byte	$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA
>bf5b	aa aa aa aa aa aa aa
>bf62	aa aa aa aa aa aa aa aa			.byte	$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA
>bf6a	aa aa aa aa aa aa aa
.bf71					LAB_BF71
.bf71	20 0c bc	jsr $bc0c		JSR	LAB_BC0C		; round and copy FAC1 to FAC2
.bf74	a9 11		lda #$11		LDA	#<LAB_BF11		; set 0.5 pointer low address
.bf76	a0 bf		ldy #$bf		LDY	#>LAB_BF11		; set 0.5 pointer high address
.bf78	20 a2 bb	jsr $bba2		JSR	LAB_BBA2		; unpack memory (AY) into FAC1
.bf7b					LAB_BF7B
.bf7b	f0 70		beq $bfed		BEQ	LAB_BFED		; perform EXP()
.bf7d	a5 69		lda $69			LDA	LAB_69		; get FAC2 exponent
.bf7f	d0 03		bne $bf84		BNE	LAB_BF84		; branch if FAC2<>0
.bf81	4c f9 b8	jmp $b8f9		JMP	LAB_B8F9		; clear FAC1 exponent and sign and return
.bf84					LAB_BF84
.bf84	a2 4e		ldx #$4e		LDX	#<LAB_4E		; set destination pointer low byte
.bf86	a0 00		ldy #$00		LDY	#>LAB_4E		; set destination pointer high byte
.bf88	20 d4 bb	jsr $bbd4		JSR	LAB_BBD4		; pack FAC1 into (XY)
.bf8b	a5 6e		lda $6e			LDA	LAB_6E		; get FAC2 sign (b7)
.bf8d	10 0f		bpl $bf9e		BPL	LAB_BF9E		; branch if FAC2>0
.bf8f	20 cc bc	jsr $bccc		JSR	LAB_BCCC		; perform INT()
.bf92	a9 4e		lda #$4e		LDA	#<LAB_4E		; set source pointer low byte
.bf94	a0 00		ldy #$00		LDY	#>LAB_4E		; set source pointer high byte
.bf96	20 5b bc	jsr $bc5b		JSR	LAB_BC5B		; compare FAC1 with (AY)
.bf99	d0 03		bne $bf9e		BNE	LAB_BF9E		; branch if FAC1 <> (AY) to allow Function Call error
.bf9b	98		tya			TYA				; clear sign b7
.bf9c	a4 07		ldy $07			LDY	LAB_07		; get FAC1 mantissa 4 from INT() function as sign in
.bf9e					LAB_BF9E
.bf9e	20 fe bb	jsr $bbfe		JSR	LAB_BBFE		; save FAC1 sign and copy ABS(FAC2) to FAC1
.bfa1	98		tya			TYA				; copy sign back ..
.bfa2	48		pha			PHA				; .. and save it
.bfa3	20 ea b9	jsr $b9ea		JSR	LAB_B9EA		; perform LOG()
.bfa6	a9 4e		lda #$4e		LDA	#<LAB_4E		; set pointer low byte
.bfa8	a0 00		ldy #$00		LDY	#>LAB_4E		; set pointer high byte
.bfaa	20 28 ba	jsr $ba28		JSR	LAB_BA28		; do convert AY, FCA1*(AY)
.bfad	20 ed bf	jsr $bfed		JSR	LAB_BFED		; perform EXP()
.bfb0	68		pla			PLA				; pull sign from stack
.bfb1	4a		lsr a			LSR				; b0 is to be tested
.bfb2	90 0a		bcc $bfbe		BCC	LAB_BFBE		; if no bit then exit
.bfb4					LAB_BFB4
.bfb4	a5 61		lda $61			LDA	LAB_61		; get FAC1 exponent
.bfb6	f0 06		beq $bfbe		BEQ	LAB_BFBE		; exit if FAC1_e = $00
.bfb8	a5 66		lda $66			LDA	LAB_66		; get FAC1 sign (b7)
.bfba	49 ff		eor #$ff		EOR	#$FF			; complement it
.bfbc	85 66		sta $66			STA	LAB_66		; save FAC1 sign (b7)
.bfbe					LAB_BFBE
.bfbe	60		rts			RTS
.bfbf					LAB_BFBF
>bfbf	81 38 aa 3b 29				.byte	$81,$38,$AA,$3B,$29	; 1.443
.bfc4					LAB_BFC4
>bfc4	07					.byte	$07				; series count
>bfc5	71 34 58 3e 56				.byte	$71,$34,$58,$3E,$56	; 2.14987637E-5
>bfca	74 16 7e b3 1b				.byte	$74,$16,$7E,$B3,$1B	; 1.43523140E-4
>bfcf	77 2f ee e3 85				.byte	$77,$2F,$EE,$E3,$85	; 1.34226348E-3
>bfd4	7a 1d 84 1c 2a				.byte	$7A,$1D,$84,$1C,$2A	; 9.61401701E-3
>bfd9	7c 63 59 58 0a				.byte	$7C,$63,$59,$58,$0A	; 5.55051269E-2
>bfde	7e 75 fd e7 c6				.byte	$7E,$75,$FD,$E7,$C6	; 2.40226385E-1
>bfe3	80 31 72 18 10				.byte	$80,$31,$72,$18,$10	; 6.93147186E-1
>bfe8	81 00 00 00 00				.byte	$81,$00,$00,$00,$00	; 1.00000000
.bfed					LAB_BFED
.bfed	a9 bf		lda #$bf		LDA	#<LAB_BFBF		; set 1.443 pointer low byte
.bfef	a0 bf		ldy #$bf		LDY	#>LAB_BFBF		; set 1.443 pointer high byte
.bff1	20 28 ba	jsr $ba28		JSR	LAB_BA28		; do convert AY, FCA1*(AY)
.bff4	a5 70		lda $70			LDA	LAB_70		; get FAC1 rounding byte
.bff6	69 50		adc #$50		ADC	#$50			; +$50/$100
.bff8	90 03		bcc $bffd		BCC	LAB_BFFD		; skip rounding if no carry
.bffa	20 23 bc	jsr $bc23		JSR	LAB_BC23		; round FAC1 (no check)
.bffd					LAB_BFFD
.bffd	4c 00 e0	jmp $e000		JMP	LAB_E000		; continue EXP()
.e000					LAB_E000
.e000	85 56		sta $56			STA	LAB_56		; save FAC2 rounding byte
.e002	20 0f bc	jsr $bc0f		JSR	LAB_BC0F		; copy FAC1 to FAC2
.e005	a5 61		lda $61			LDA	LAB_61		; get FAC1 exponent
.e007	c9 88		cmp #$88		CMP	#$88			; compare with EXP limit (256d)
.e009	90 03		bcc $e00e		BCC	LAB_E00E		; branch if less
.e00b					LAB_E00B
.e00b	20 d4 ba	jsr $bad4		JSR	LAB_BAD4		; handle overflow and underflow
.e00e					LAB_E00E
.e00e	20 cc bc	jsr $bccc		JSR	LAB_BCCC		; perform INT()
.e011	a5 07		lda $07			LDA	LAB_07		; get mantissa 4 from INT()
.e013	18		clc			CLC				; clear carry for add
.e014	69 81		adc #$81		ADC	#$81			; normalise +1
.e016	f0 f3		beq $e00b		BEQ	LAB_E00B		; if $00 result has overflowed so go handle it
.e018	38		sec			SEC				; set carry for subtract
.e019	e9 01		sbc #$01		SBC	#$01			; exponent now correct
.e01b	48		pha			PHA				; save FAC2 exponent
.e01c	a2 05		ldx #$05		LDX	#$05			; 4 bytes to do
.e01e					LAB_E01E
.e01e	b5 69		lda $69,x		LDA	LAB_69,X		; get FAC2,X
.e020	b4 61		ldy $61,x		LDY	LAB_61,X		; get FAC1,X
.e022	95 61		sta $61,x		STA	LAB_61,X		; save FAC1,X
.e024	94 69		sty $69,x		STY	LAB_69,X		; save FAC2,X
.e026	ca		dex			DEX				; decrement count/index
.e027	10 f5		bpl $e01e		BPL	LAB_E01E		; loop if not all done
.e029	a5 56		lda $56			LDA	LAB_56		; get FAC2 rounding byte
.e02b	85 70		sta $70			STA	LAB_70		; save as FAC1 rounding byte
.e02d	20 53 b8	jsr $b853		JSR	LAB_B853		; perform subtraction, FAC2 from FAC1
.e030	20 b4 bf	jsr $bfb4		JSR	LAB_BFB4		; do - FAC1
.e033	a9 c4		lda #$c4		LDA	#<LAB_BFC4		; set counter pointer low byte
.e035	a0 bf		ldy #$bf		LDY	#>LAB_BFC4		; set counter pointer high byte
.e037	20 59 e0	jsr $e059		JSR	LAB_E059		; go do series evaluation
.e03a	a9 00		lda #$00		LDA	#$00			; clear A
.e03c	85 6f		sta $6f			STA	LAB_6F		; clear sign compare (FAC1 EOR FAC2)
.e03e	68		pla			PLA				;.get saved FAC2 exponent
.e03f	20 b9 ba	jsr $bab9		JSR	LAB_BAB9		; test and adjust accumulators
.e042	60		rts			RTS
.e043					LAB_E043
.e043	85 71		sta $71			STA	LAB_71		; save count pointer low byte
.e045	84 72		sty $72			STY	LAB_72		; save count pointer high byte
.e047	20 ca bb	jsr $bbca		JSR	LAB_BBCA		; pack FAC1 into LAB_57
.e04a	a9 57		lda #$57		LDA	#<LAB_57		; set pointer low byte (Y already $00)
.e04c	20 28 ba	jsr $ba28		JSR	LAB_BA28		; do convert AY, FCA1*(AY)
.e04f	20 5d e0	jsr $e05d		JSR	LAB_E05D		; go do series evaluation
.e052	a9 57		lda #$57		LDA	#<LAB_57		; pointer to original # low byte
.e054	a0 00		ldy #$00		LDY	#>LAB_57		; pointer to original # high byte
.e056	4c 28 ba	jmp $ba28		JMP	LAB_BA28		; do convert AY, FCA1*(AY)
.e059					LAB_E059
.e059	85 71		sta $71			STA	LAB_71		; save count pointer low byte
.e05b	84 72		sty $72			STY	LAB_72		; save count pointer high byte
.e05d					LAB_E05D
.e05d	20 c7 bb	jsr $bbc7		JSR	LAB_BBC7		; pack FAC1 into LAB_5C
.e060	b1 71		lda ($71),y		LDA	(LAB_71),Y		; get constants count
.e062	85 67		sta $67			STA	LAB_67		; save constants count
.e064	a4 71		ldy $71			LDY	LAB_71		; get count pointer low byte
.e066	c8		iny			INY				; increment it (now constants pointer)
.e067	98		tya			TYA				; copy it
.e068	d0 02		bne $e06c		BNE	LAB_E06C		; skip next if no overflow
.e06a	e6 72		inc $72			INC	LAB_72		; else increment high byte
.e06c					LAB_E06C
.e06c	85 71		sta $71			STA	LAB_71		; save low byte
.e06e	a4 72		ldy $72			LDY	LAB_72		; get high byte
.e070					LAB_E070
.e070	20 28 ba	jsr $ba28		JSR	LAB_BA28		; do convert AY, FCA1*(AY)
.e073	a5 71		lda $71			LDA	LAB_71		; get constants pointer low byte
.e075	a4 72		ldy $72			LDY	LAB_72		; get constants pointer high byte
.e077	18		clc			CLC				; clear carry for add
.e078	69 05		adc #$05		ADC	#$05			; +5 to low pointer (5 bytes per constant)
.e07a	90 01		bcc $e07d		BCC	LAB_E07D		; skip next if no overflow
.e07c	c8		iny			INY				; increment high byte
.e07d					LAB_E07D
.e07d	85 71		sta $71			STA	LAB_71		; save pointer low byte
.e07f	84 72		sty $72			STY	LAB_72		; save pointer high byte
.e081	20 67 b8	jsr $b867		JSR	LAB_B867		; add (AY) to FAC1
.e084	a9 5c		lda #$5c		LDA	#<LAB_5C		; set pointer low byte to partial
.e086	a0 00		ldy #$00		LDY	#>LAB_5C		; set pointer high byte to partial
.e088	c6 67		dec $67			DEC	LAB_67		; decrement constants count
.e08a	d0 e4		bne $e070		BNE	LAB_E070		; loop until all done
.e08c	60		rts			RTS
.e08d					LAB_E08D
>e08d	98 35 44 7a 00				.byte	$98,$35,$44,$7A,$00
.e092					LAB_E092
>e092	68 28 b1 46 00				.byte	$68,$28,$B1,$46,$00
.e097					LAB_E097
.e097	20 2b bc	jsr $bc2b		JSR	LAB_BC2B		; get FAC1 sign
.e09a	30 37		bmi $e0d3		BMI	LAB_E0D3		; if n<0 copy byte swapped FAC1 into RND() seed
.e09c	d0 20		bne $e0be		BNE	LAB_E0BE		; if n>0 get next number in RND() sequence
.e09e	20 f3 ff	jsr $fff3		JSR	LAB_FFF3		; return base address of I/O devices
.e0a1	86 22		stx $22			STX	LAB_22		; save pointer low byte
.e0a3	84 23		sty $23			STY	LAB_23		; save pointer high byte
.e0a5	a0 04		ldy #$04		LDY	#$04			; set index to T1 low byte
.e0a7	b1 22		lda ($22),y		LDA	(LAB_22),Y		; get T1 low byte
.e0a9	85 62		sta $62			STA	LAB_62		; save FAC1 mantissa 1
.e0ab	c8		iny			INY				; increment index
.e0ac	b1 22		lda ($22),y		LDA	(LAB_22),Y		; get T1 high byte
.e0ae	85 64		sta $64			STA	LAB_64		; save FAC1 mantissa 3
.e0b0	a0 08		ldy #$08		LDY	#$08			; set index to T2 low byte
.e0b2	b1 22		lda ($22),y		LDA	(LAB_22),Y		; get T2 low byte
.e0b4	85 63		sta $63			STA	LAB_63		; save FAC1 mantissa 2
.e0b6	c8		iny			INY				; increment index
.e0b7	b1 22		lda ($22),y		LDA	(LAB_22),Y		; get T2 high byte
.e0b9	85 65		sta $65			STA	LAB_65		; save FAC1 mantissa 4
.e0bb	4c e3 e0	jmp $e0e3		JMP	LAB_E0E3		; set exponent and exit
.e0be					LAB_E0BE
.e0be	a9 8b		lda #$8b		LDA	#<LAB_8B		; set seed pointer low address
.e0c0	a0 00		ldy #$00		LDY	#>LAB_8B		; set seed pointer high address
.e0c2	20 a2 bb	jsr $bba2		JSR	LAB_BBA2		; unpack memory (AY) into FAC1
.e0c5	a9 8d		lda #$8d		LDA	#<LAB_E08D		; set 11879546 pointer low byte
.e0c7	a0 e0		ldy #$e0		LDY	#>LAB_E08D		; set 11879546 pointer high byte
.e0c9	20 28 ba	jsr $ba28		JSR	LAB_BA28		; do convert AY, FCA1*(AY)
.e0cc	a9 92		lda #$92		LDA	#<LAB_E092		; set 3.927677739E-8 pointer low byte
.e0ce	a0 e0		ldy #$e0		LDY	#>LAB_E092		; set 3.927677739E-8 pointer high byte
.e0d0	20 67 b8	jsr $b867		JSR	LAB_B867		; add (AY) to FAC1
.e0d3					LAB_E0D3
.e0d3	a6 65		ldx $65			LDX	LAB_65		; get FAC1 mantissa 4
.e0d5	a5 62		lda $62			LDA	LAB_62		; get FAC1 mantissa 1
.e0d7	85 65		sta $65			STA	LAB_65		; save FAC1 mantissa 4
.e0d9	86 62		stx $62			STX	LAB_62		; save FAC1 mantissa 1
.e0db	a6 63		ldx $63			LDX	LAB_63		; get FAC1 mantissa 2
.e0dd	a5 64		lda $64			LDA	LAB_64		; get FAC1 mantissa 3
.e0df	85 63		sta $63			STA	LAB_63		; save FAC1 mantissa 2
.e0e1	86 64		stx $64			STX	LAB_64		; save FAC1 mantissa 3
.e0e3					LAB_E0E3
.e0e3	a9 00		lda #$00		LDA	#$00			; clear byte
.e0e5	85 66		sta $66			STA	LAB_66		; clear FAC1 sign (always +ve)
.e0e7	a5 61		lda $61			LDA	LAB_61		; get FAC1 exponent
.e0e9	85 70		sta $70			STA	LAB_70		; save FAC1 rounding byte
.e0eb	a9 80		lda #$80		LDA	#$80			; set exponent = $80
.e0ed	85 61		sta $61			STA	LAB_61		; save FAC1 exponent
.e0ef	20 d7 b8	jsr $b8d7		JSR	LAB_B8D7		; normalise FAC1
.e0f2	a2 8b		ldx #$8b		LDX	#<LAB_8B		; set seed pointer low address
.e0f4	a0 00		ldy #$00		LDY	#>LAB_8B		; set seed pointer high address
.e0f6					LAB_E0F6
.e0f6	4c d4 bb	jmp $bbd4		JMP	LAB_BBD4		; pack FAC1 into (XY)
.e0f9					LAB_E0F9
.e0f9	c9 f0		cmp #$f0		CMP	#$F0			; compare error with $F0
.e0fb	d0 07		bne $e104		BNE	LAB_E104		; branch if not $F0
.e0fd	84 38		sty $38			STY	LAB_38		; set end of memory high byte
.e0ff	86 37		stx $37			STX	LAB_37		; set end of memory low byte
.e101	4c 63 a6	jmp $a663		JMP	LAB_A663		; clear from start to end and return
.e104					LAB_E104
.e104	aa		tax			TAX				; copy error #
.e105	d0 02		bne $e109		BNE	LAB_E109		; branch if not $00
.e107	a2 1e		ldx #$1e		LDX	#$1E			; else error $1E, break error
.e109					LAB_E109
.e109	4c 37 a4	jmp $a437		JMP	LAB_A437		; do error #X then warm start
.e10c					LAB_E10C
.e10c	20 d2 ff	jsr $ffd2		JSR	LAB_FFD2		; output character to channel
.e10f	b0 e8		bcs $e0f9		BCS	LAB_E0F9		; if error go handle BASIC I/O error
.e111	60		rts			RTS
.e112					LAB_E112
.e112	20 cf ff	jsr $ffcf		JSR	LAB_FFCF		; input character from channel
.e115	b0 e2		bcs $e0f9		BCS	LAB_E0F9		; if error go handle BASIC I/O error
.e117	60		rts			RTS
.e118					LAB_E118
.e118	20 ad e4	jsr $e4ad		JSR	LAB_E4AD		; open channel for output
.e11b	b0 dc		bcs $e0f9		BCS	LAB_E0F9		; if error go handle BASIC I/O error
.e11d	60		rts			RTS
.e11e					LAB_E11E
.e11e	20 c6 ff	jsr $ffc6		JSR	LAB_FFC6		; open channel for input
.e121	b0 d6		bcs $e0f9		BCS	LAB_E0F9		; if error go handle BASIC I/O error
.e123	60		rts			RTS
.e124					LAB_E124
.e124	20 e4 ff	jsr $ffe4		JSR	LAB_FFE4		; get character from input device
.e127	b0 d0		bcs $e0f9		BCS	LAB_E0F9		; if error go handle BASIC I/O error
.e129	60		rts			RTS
.e12a					LAB_E12A
.e12a	20 8a ad	jsr $ad8a		JSR	LAB_AD8A		; evaluate expression and check is numeric, else do
.e12d	20 f7 b7	jsr $b7f7		JSR	LAB_B7F7		; convert FAC_1 to integer in temporary integer
.e130	a9 e1		lda #$e1		LDA	#>LAB_E146		; get return address high byte
.e132	48		pha			PHA				; push as return address
.e133	a9 46		lda #$46		LDA	#<LAB_E146		; get return address low byte
.e135	48		pha			PHA				; push as return address
.e136	ad 0f 03	lda $030f		LDA	LAB_030F		; get saved status register
.e139	48		pha			PHA				; put on stack
.e13a	ad 0c 03	lda $030c		LDA	LAB_030C		; get saved A
.e13d	ae 0d 03	ldx $030d		LDX	LAB_030D		; get saved X
.e140	ac 0e 03	ldy $030e		LDY	LAB_030E		; get saved Y
.e143	28		plp			PLP				; pull processor status
.e144	6c 14 00	jmp ($0014)		JMP	(LAB_14)		; call SYS address
=57670					LAB_E146	= *-1
.e147	08		php			PHP				; save status
.e148	8d 0c 03	sta $030c		STA	LAB_030C		; save returned A
.e14b	8e 0d 03	stx $030d		STX	LAB_030D		; save returned X
.e14e	8c 0e 03	sty $030e		STY	LAB_030E		; save returned Y
.e151	68		pla			PLA				; restore saved status
.e152	8d 0f 03	sta $030f		STA	LAB_030F		; save status
.e155	60		rts			RTS
.e156					LAB_E156
.e156	20 d4 e1	jsr $e1d4		JSR	LAB_E1D4		; get parameters for LOAD/SAVE
.e159	a6 2d		ldx $2d			LDX	LAB_2D		; get start of variables low byte
.e15b	a4 2e		ldy $2e			LDY	LAB_2E		; get start of variables high byte
.e15d	a9 2b		lda #$2b		LDA	#LAB_2B		; index to start of program memory
.e15f	20 d8 ff	jsr $ffd8		JSR	LAB_FFD8		; save RAM to device, A = index to start address, XY = end
.e162	b0 95		bcs $e0f9		BCS	LAB_E0F9		; if error go handle BASIC I/O error
.e164	60		rts			RTS
.e165					LAB_E165
.e165	a9 01		lda #$01		LDA	#$01			; flag verify
>e167	2c					.byte	$2C			; makes next line BIT LAB_00A9
.e168					LAB_E168
.e168	a9 00		lda #$00		LDA	#$00			; flag load
.e16a	85 0a		sta $0a			STA	LAB_0A		; set load/verify flag
.e16c	20 d4 e1	jsr $e1d4		JSR	LAB_E1D4		; get parameters for LOAD/SAVE
.e16f	a5 0a		lda $0a			LDA	LAB_0A		; get load/verify flag
.e171	a6 2b		ldx $2b			LDX	LAB_2B		; get start of memory low byte
.e173	a4 2c		ldy $2c			LDY	LAB_2C		; get start of memory high byte
.e175	20 d5 ff	jsr $ffd5		JSR	LAB_FFD5		; load RAM from a device
.e178	b0 57		bcs $e1d1		BCS	LAB_E1D1		; if error go handle BASIC I/O error
.e17a	a5 0a		lda $0a			LDA	LAB_0A		; get load/verify flag
.e17c	f0 17		beq $e195		BEQ	LAB_E195		; branch if load
.e17e	a2 1c		ldx #$1c		LDX	#$1C			; error $1C, verify error
.e180	20 b7 ff	jsr $ffb7		JSR	LAB_FFB7		; read I/O status word
.e183	29 10		and #$10		AND	#$10			; mask for tape read error
.e185	d0 17		bne $e19e		BNE	LAB_E19E		; branch if no read error
.e187	a5 7a		lda $7a			LDA	LAB_7A		; get the BASIC execute pointer low byte
.e189	c9 02		cmp #$02		CMP	#$02			;.
.e18b	f0 07		beq $e194		BEQ	LAB_E194		; if ?? skip "OK" prompt
.e18d	a9 64		lda #$64		LDA	#<LAB_A364		; set "OK" pointer low byte
.e18f	a0 a3		ldy #$a3		LDY	#>LAB_A364		; set "OK" pointer high byte
.e191	4c 1e ab	jmp $ab1e		JMP	LAB_AB1E		; print null terminated string
.e194					LAB_E194
.e194	60		rts			RTS
.e195					LAB_E195
.e195	20 b7 ff	jsr $ffb7		JSR	LAB_FFB7		; read I/O status word
.e198	29 bf		and #$bf		AND	#$BF			; mask x0xx xxxx, clear read error
.e19a	f0 05		beq $e1a1		BEQ	LAB_E1A1		; branch if no errors
.e19c	a2 1d		ldx #$1d		LDX	#$1D			; error $1D, load error
.e19e					LAB_E19E
.e19e	4c 37 a4	jmp $a437		JMP	LAB_A437		; do error #X then warm start
.e1a1					LAB_E1A1
.e1a1	a5 7b		lda $7b			LDA	LAB_7B		; get BASIC execute pointer high byte
.e1a3	c9 02		cmp #$02		CMP	#$02			; compare with $02xx
.e1a5	d0 0e		bne $e1b5		BNE	LAB_E1B5		; branch if not immediate mode
.e1a7	86 2d		stx $2d			STX	LAB_2D		; set start of variables low byte
.e1a9	84 2e		sty $2e			STY	LAB_2E		; set start of variables high byte
.e1ab	a9 76		lda #$76		LDA	#<LAB_A376		; set "READY." pointer low byte
.e1ad	a0 a3		ldy #$a3		LDY	#>LAB_A376		; set "READY." pointer high byte
.e1af	20 1e ab	jsr $ab1e		JSR	LAB_AB1E		; print null terminated string
.e1b2	4c 2a a5	jmp $a52a		JMP	LAB_A52A		; reset execution, clear variables, flush stack,
.e1b5					LAB_E1B5
.e1b5	20 8e a6	jsr $a68e		JSR	LAB_A68E		; set BASIC execute pointer to start of memory - 1
.e1b8	20 33 a5	jsr $a533		JSR	LAB_A533		; rebuild BASIC line chaining
.e1bb	4c 77 a6	jmp $a677		JMP	LAB_A677		; rebuild BASIC line chaining, do RESTORE and return
.e1be					LAB_E1BE
.e1be	20 19 e2	jsr $e219		JSR	LAB_E219		; get parameters for OPEN/CLOSE
.e1c1	20 c0 ff	jsr $ffc0		JSR	LAB_FFC0		; open a logical file
.e1c4	b0 0b		bcs $e1d1		BCS	LAB_E1D1		; branch if error
.e1c6	60		rts			RTS
.e1c7					LAB_E1C7
.e1c7	20 19 e2	jsr $e219		JSR	LAB_E219		; get parameters for OPEN/CLOSE
.e1ca	a5 49		lda $49			LDA	LAB_49		; get logical file number
.e1cc	20 c3 ff	jsr $ffc3		JSR	LAB_FFC3		; close a specified logical file
.e1cf	90 c3		bcc $e194		BCC	LAB_E194		; exit if no error
.e1d1					LAB_E1D1
.e1d1	4c f9 e0	jmp $e0f9		JMP	LAB_E0F9		; go handle BASIC I/O error
.e1d4					LAB_E1D4
.e1d4	a9 00		lda #$00		LDA	#$00			; clear file name length
.e1d6	20 bd ff	jsr $ffbd		JSR	LAB_FFBD		; clear the filename
.e1d9	a2 01		ldx #$01		LDX	#$01			; set default device number, cassette
.e1db	a0 00		ldy #$00		LDY	#$00			; set default command
.e1dd	20 ba ff	jsr $ffba		JSR	LAB_FFBA		; set logical, first and second addresses
.e1e0	20 06 e2	jsr $e206		JSR	LAB_E206		; exit function if [EOT] or ":"
.e1e3	20 57 e2	jsr $e257		JSR	LAB_E257		; set filename
.e1e6	20 06 e2	jsr $e206		JSR	LAB_E206		; exit function if [EOT] or ":"
.e1e9	20 00 e2	jsr $e200		JSR	LAB_E200		; scan and get byte, else do syntax error then warm start
.e1ec	a0 00		ldy #$00		LDY	#$00			; clear command
.e1ee	86 49		stx $49			STX	LAB_49		; save device number
.e1f0	20 ba ff	jsr $ffba		JSR	LAB_FFBA		; set logical, first and second addresses
.e1f3	20 06 e2	jsr $e206		JSR	LAB_E206		; exit function if [EOT] or ":"
.e1f6	20 00 e2	jsr $e200		JSR	LAB_E200		; scan and get byte, else do syntax error then warm start
.e1f9	8a		txa			TXA				; copy command to A
.e1fa	a8		tay			TAY				; copy command to Y
.e1fb	a6 49		ldx $49			LDX	LAB_49		; get device number back
.e1fd	4c ba ff	jmp $ffba		JMP	LAB_FFBA		; set logical, first and second addresses and return
.e200					LAB_E200
.e200	20 0e e2	jsr $e20e		JSR	LAB_E20E		; scan for ",byte", else do syntax error then warm start
.e203	4c 9e b7	jmp $b79e		JMP	LAB_B79E		; get byte parameter and return
.e206					LAB_E206
.e206	20 79 00	jsr $0079		JSR	LAB_0079		; scan memory
.e209	d0 02		bne $e20d		BNE	LAB_E20D		; branch if not [EOL] or ":"
.e20b	68		pla			PLA				; dump return address low byte
.e20c	68		pla			PLA				; dump return address high byte
.e20d					LAB_E20D
.e20d	60		rts			RTS
.e20e					LAB_E20E
.e20e	20 fd ae	jsr $aefd		JSR	LAB_AEFD		; scan for ",", else do syntax error then warm start
.e211					LAB_E211
.e211	20 79 00	jsr $0079		JSR	LAB_0079		; scan memory
.e214	d0 f7		bne $e20d		BNE	LAB_E20D		; exit if following byte
.e216	4c 08 af	jmp $af08		JMP	LAB_AF08		; else do syntax error then warm start
.e219					LAB_E219
.e219	a9 00		lda #$00		LDA	#$00			; clear the filename length
.e21b	20 bd ff	jsr $ffbd		JSR	LAB_FFBD		; clear the filename
.e21e	20 11 e2	jsr $e211		JSR	LAB_E211		; scan for valid byte, else do syntax error then warm start
.e221	20 9e b7	jsr $b79e		JSR	LAB_B79E		; get byte parameter, logical file number
.e224	86 49		stx $49			STX	LAB_49		; save logical file number
.e226	8a		txa			TXA				; copy logical file number to A
.e227	a2 01		ldx #$01		LDX	#$01			; set default device number, cassette
.e229	a0 00		ldy #$00		LDY	#$00			; set default command
.e22b	20 ba ff	jsr $ffba		JSR	LAB_FFBA		; set logical, first and second addresses
.e22e	20 06 e2	jsr $e206		JSR	LAB_E206		; exit function if [EOT] or ":"
.e231	20 00 e2	jsr $e200		JSR	LAB_E200		; scan and get byte, else do syntax error then warm start
.e234	86 4a		stx $4a			STX	LAB_4A		; save device number
.e236	a0 00		ldy #$00		LDY	#$00			; clear command
.e238	a5 49		lda $49			LDA	LAB_49		; get logical file number
.e23a	e0 03		cpx #$03		CPX	#$03			; compare device number with screen
.e23c	90 01		bcc $e23f		BCC	LAB_E23F		; branch if less than screen
.e23e	88		dey			DEY				; else decrement command
.e23f					LAB_E23F
.e23f	20 ba ff	jsr $ffba		JSR	LAB_FFBA		; set logical, first and second addresses
.e242	20 06 e2	jsr $e206		JSR	LAB_E206		; exit function if [EOT] or ":"
.e245	20 00 e2	jsr $e200		JSR	LAB_E200		; scan and get byte, else do syntax error then warm start
.e248	8a		txa			TXA				; copy command to A
.e249	a8		tay			TAY				; copy command to Y
.e24a	a6 4a		ldx $4a			LDX	LAB_4A		; get device number
.e24c	a5 49		lda $49			LDA	LAB_49		; get logical file number
.e24e	20 ba ff	jsr $ffba		JSR	LAB_FFBA		; set logical, first and second addresses
.e251	20 06 e2	jsr $e206		JSR	LAB_E206		; exit function if [EOT] or ":"
.e254	20 0e e2	jsr $e20e		JSR	LAB_E20E		; scan for ",byte", else do syntax error then warm start
.e257					LAB_E257
.e257	20 9e ad	jsr $ad9e		JSR	LAB_AD9E		; evaluate expression
.e25a	20 a3 b6	jsr $b6a3		JSR	LAB_B6A3		; evaluate string
.e25d	a6 22		ldx $22			LDX	LAB_22		; get string pointer low byte
.e25f	a4 23		ldy $23			LDY	LAB_23		; get string pointer high byte
.e261	4c bd ff	jmp $ffbd		JMP	LAB_FFBD		; set the filename and return
.e264					LAB_E264
.e264	a9 e0		lda #$e0		LDA	#<LAB_E2E0		; set pi/2 pointer low byte
.e266	a0 e2		ldy #$e2		LDY	#>LAB_E2E0		; set pi/2 pointer high byte
.e268	20 67 b8	jsr $b867		JSR	LAB_B867		; add (AY) to FAC1
.e26b					LAB_E26B
.e26b	20 0c bc	jsr $bc0c		JSR	LAB_BC0C		; round and copy FAC1 to FAC2
.e26e	a9 e5		lda #$e5		LDA	#<LAB_E2E5		; set 2*pi pointer low byte
.e270	a0 e2		ldy #$e2		LDY	#>LAB_E2E5		; set 2*pi pointer high byte
.e272	a6 6e		ldx $6e			LDX	LAB_6E		; get FAC2 sign (b7)
.e274	20 07 bb	jsr $bb07		JSR	LAB_BB07		; divide by (AY) (X=sign)
.e277	20 0c bc	jsr $bc0c		JSR	LAB_BC0C		; round and copy FAC1 to FAC2
.e27a	20 cc bc	jsr $bccc		JSR	LAB_BCCC		; perform INT()
.e27d	a9 00		lda #$00		LDA	#$00			; clear byte
.e27f	85 6f		sta $6f			STA	LAB_6F		; clear sign compare (FAC1 EOR FAC2)
.e281	20 53 b8	jsr $b853		JSR	LAB_B853		; perform subtraction, FAC2 from FAC1
.e284	a9 ea		lda #$ea		LDA	#<LAB_E2EA		; set 0.25 pointer low byte
.e286	a0 e2		ldy #$e2		LDY	#>LAB_E2EA		; set 0.25 pointer high byte
.e288	20 50 b8	jsr $b850		JSR	LAB_B850		; perform subtraction, FAC1 from (AY)
.e28b	a5 66		lda $66			LDA	LAB_66		; get FAC1 sign (b7)
.e28d	48		pha			PHA				; save FAC1 sign
.e28e	10 0d		bpl $e29d		BPL	LAB_E29D		; branch if +ve
.e290	20 49 b8	jsr $b849		JSR	LAB_B849		; add 0.5 to FAC1 (round FAC1)
.e293	a5 66		lda $66			LDA	LAB_66		; get FAC1 sign (b7)
.e295	30 09		bmi $e2a0		BMI	LAB_E2A0		; branch if -ve
.e297	a5 12		lda $12			LDA	LAB_12		; get the comparison evaluation flag
.e299	49 ff		eor #$ff		EOR	#$FF			; toggle flag
.e29b	85 12		sta $12			STA	LAB_12		; save the comparison evaluation flag
.e29d					LAB_E29D
.e29d	20 b4 bf	jsr $bfb4		JSR	LAB_BFB4		; do - FAC1
.e2a0					LAB_E2A0
.e2a0	a9 ea		lda #$ea		LDA	#<LAB_E2EA		; set 0.25 pointer low byte
.e2a2	a0 e2		ldy #$e2		LDY	#>LAB_E2EA		; set 0.25 pointer high byte
.e2a4	20 67 b8	jsr $b867		JSR	LAB_B867		; add (AY) to FAC1
.e2a7	68		pla			PLA				; restore FAC1 sign
.e2a8	10 03		bpl $e2ad		BPL	LAB_E2AD		; branch if was +ve
.e2aa	20 b4 bf	jsr $bfb4		JSR	LAB_BFB4		; do - FAC1
.e2ad					LAB_E2AD
.e2ad	a9 ef		lda #$ef		LDA	#<LAB_E2EF		; set pointer low byte to counter
.e2af	a0 e2		ldy #$e2		LDY	#>LAB_E2EF		; set pointer high byte to counter
.e2b1	4c 43 e0	jmp $e043		JMP	LAB_E043		; ^2 then series evaluation and return
.e2b4					LAB_E2B4
.e2b4	20 ca bb	jsr $bbca		JSR	LAB_BBCA		; pack FAC1 into LAB_57
.e2b7	a9 00		lda #$00		LDA	#$00			; clear A
.e2b9	85 12		sta $12			STA	LAB_12		; clear the comparison evaluation flag
.e2bb	20 6b e2	jsr $e26b		JSR	LAB_E26B		; perform SIN()
.e2be	a2 4e		ldx #$4e		LDX	#<LAB_4E		; set sin(n) pointer low byte
.e2c0	a0 00		ldy #$00		LDY	#>LAB_4E		; set sin(n) pointer high byte
.e2c2	20 f6 e0	jsr $e0f6		JSR	LAB_E0F6		; pack FAC1 into (XY)
.e2c5	a9 57		lda #$57		LDA	#<LAB_57		; set n pointer low byte
.e2c7	a0 00		ldy #$00		LDY	#>LAB_57		; set n pointer high byte
.e2c9	20 a2 bb	jsr $bba2		JSR	LAB_BBA2		; unpack memory (AY) into FAC1
.e2cc	a9 00		lda #$00		LDA	#$00			; clear byte
.e2ce	85 66		sta $66			STA	LAB_66		; clear FAC1 sign (b7)
.e2d0	a5 12		lda $12			LDA	LAB_12		; get the comparison evaluation flag
.e2d2	20 dc e2	jsr $e2dc		JSR	LAB_E2DC		; save flag and go do series evaluation
.e2d5	a9 4e		lda #$4e		LDA	#<LAB_4E		; set sin(n) pointer low byte
.e2d7	a0 00		ldy #$00		LDY	#>LAB_4E		; set sin(n) pointer high byte
.e2d9	4c 0f bb	jmp $bb0f		JMP	LAB_BB0F		; convert AY and do (AY)/FAC1
.e2dc					LAB_E2DC
.e2dc	48		pha			PHA				; save comparison flag
.e2dd	4c 9d e2	jmp $e29d		JMP	LAB_E29D		; add 0.25, ^2 then series evaluation
.e2e0					LAB_E2E0
>e2e0	81 49 0f da a2				.byte	$81,$49,$0F,$DA,$A2	; 1.570796371, pi/2, as floating number
.e2e5					LAB_E2E5
>e2e5	83 49 0f da a2				.byte	$83,$49,$0F,$DA,$A2	; 6.28319, 2*pi, as floating number
.e2ea					LAB_E2EA
>e2ea	7f 00 00 00 00				.byte	$7F,$00,$00,$00,$00	; 0.25
.e2ef					LAB_E2EF
>e2ef	05					.byte	$05				; series counter
>e2f0	84 e6 1a 2d 1b				.byte	$84,$E6,$1A,$2D,$1B	; -14.3813907
>e2f5	86 28 07 fb f8				.byte	$86,$28,$07,$FB,$F8	;  42.0077971
>e2fa	87 99 68 89 01				.byte	$87,$99,$68,$89,$01	; -76.7041703
>e2ff	87 23 35 df e1				.byte	$87,$23,$35,$DF,$E1	;  81.6052237
>e304	86 a5 5d e7 28				.byte	$86,$A5,$5D,$E7,$28	; -41.3417021
>e309	83 49 0f da a2				.byte	$83,$49,$0F,$DA,$A2	;  6.28318531
.e30e					LAB_E30E
.e30e	a5 66		lda $66			LDA	LAB_66		; get FAC1 sign (b7)
.e310	48		pha			PHA				; save sign
.e311	10 03		bpl $e316		BPL	LAB_E316		; branch if +ve
.e313	20 b4 bf	jsr $bfb4		JSR	LAB_BFB4		; else do - FAC1
.e316					LAB_E316
.e316	a5 61		lda $61			LDA	LAB_61		; get FAC1 exponent
.e318	48		pha			PHA				; push exponent
.e319	c9 81		cmp #$81		CMP	#$81			; compare with 1
.e31b	90 07		bcc $e324		BCC	LAB_E324		; branch if FAC1 < 1
.e31d	a9 bc		lda #$bc		LDA	#<LAB_B9BC		; pointer to 1 low byte
.e31f	a0 b9		ldy #$b9		LDY	#>LAB_B9BC		; pointer to 1 high byte
.e321	20 0f bb	jsr $bb0f		JSR	LAB_BB0F		; convert AY and do (AY)/FAC1
.e324					LAB_E324
.e324	a9 3e		lda #$3e		LDA	#<LAB_E33E		; pointer to series low byte
.e326	a0 e3		ldy #$e3		LDY	#>LAB_E33E		; pointer to series high byte
.e328	20 43 e0	jsr $e043		JSR	LAB_E043		; ^2 then series evaluation
.e32b	68		pla			PLA				; restore old FAC1 exponent
.e32c	c9 81		cmp #$81		CMP	#$81			; compare with 1
.e32e	90 07		bcc $e337		BCC	LAB_E337		; branch if FAC1 < 1
.e330	a9 e0		lda #$e0		LDA	#<LAB_E2E0		; pointer to (pi/2) low byte
.e332	a0 e2		ldy #$e2		LDY	#>LAB_E2E0		; pointer to (pi/2) low byte
.e334	20 50 b8	jsr $b850		JSR	LAB_B850		; perform subtraction, FAC1 from (AY)
.e337					LAB_E337
.e337	68		pla			PLA				; restore FAC1 sign
.e338	10 03		bpl $e33d		BPL	LAB_E33D		; exit if was +ve
.e33a	4c b4 bf	jmp $bfb4		JMP	LAB_BFB4		; else do - FAC1 and return
.e33d					LAB_E33D
.e33d	60		rts			RTS
.e33e					LAB_E33E
>e33e	0b					.byte	$0B				; series counter
>e33f	76 b3 83 bd d3				.byte	$76,$B3,$83,$BD,$D3	;-6.84793912e-04
>e344	79 1e f4 a6 f5				.byte	$79,$1E,$F4,$A6,$F5	; 4.85094216e-03
>e349	7b 83 fc b0 10				.byte	$7B,$83,$FC,$B0,$10	;-0.0161117015
>e34e	7c 0c 1f 67 ca				.byte	$7C,$0C,$1F,$67,$CA	; 0.034209638
>e353	7c de 53 cb c1				.byte	$7C,$DE,$53,$CB,$C1	;-0.054279133
>e358	7d 14 64 70 4c				.byte	$7D,$14,$64,$70,$4C	; 0.0724571965
>e35d	7d b7 ea 51 7a				.byte	$7D,$B7,$EA,$51,$7A	;-0.0898019185
>e362	7d 63 30 88 7e				.byte	$7D,$63,$30,$88,$7E	; 0.110932413
>e367	7e 92 44 99 3a				.byte	$7E,$92,$44,$99,$3A	;-0.142839808
>e36c	7e 4c cc 91 c7				.byte	$7E,$4C,$CC,$91,$C7	; 0.19999912
>e371	7f aa aa aa 13				.byte	$7F,$AA,$AA,$AA,$13	;-0.333333316
>e376	81 00 00 00 00				.byte	$81,$00,$00,$00,$00	; 1.000000000
.e37b					LAB_E37B
.e37b	20 cc ff	jsr $ffcc		JSR	LAB_FFCC		; close input and output channels
.e37e	a9 00		lda #$00		LDA	#$00			; clear A
.e380	85 13		sta $13			STA	LAB_13		; set current I/O channel, flag default
.e382	20 7a a6	jsr $a67a		JSR	LAB_A67A		; flush BASIC stack and clear continue pointer
.e385	58		cli			CLI				; enable the interrupts
.e386					LAB_E386
.e386	a2 80		ldx #$80		LDX	#$80			; set -ve error, just do warm start
.e388	6c 00 03	jmp ($0300)		JMP	(LAB_0300)		; go handle error message, normally LAB_E38B
.e38b					LAB_E38B
.e38b	8a		txa			TXA				; copy the error number
.e38c	30 03		bmi $e391		BMI	LAB_E391		; if -ve go do warm start
.e38e	4c 3a a4	jmp $a43a		JMP	LAB_A43A		; else do error #X then warm start
.e391					LAB_E391
.e391	4c 74 a4	jmp $a474		JMP	LAB_A474		; do warm start
.e394					LAB_E394
.e394	20 53 e4	jsr $e453		JSR	LAB_E453		; initialise the BASIC vector table
.e397	20 bf e3	jsr $e3bf		JSR	LAB_E3BF		; initialise the BASIC RAM locations
.e39a	20 22 e4	jsr $e422		JSR	LAB_E422		; print the start up message and initialise the memory
.e39d	a2 fb		ldx #$fb		LDX	#$FB			; value for start stack
.e39f	9a		txs			TXS				; set stack pointer
.e3a0	d0 e4		bne $e386		BNE	LAB_E386		; do "READY." warm start, branch always
.e3a2					LAB_E3A2
.e3a2	e6 7a		inc $7a			INC	LAB_7A		; increment BASIC execute pointer low byte
.e3a4	d0 02		bne $e3a8		BNE	LAB_E3A8		; branch if no carry
.e3a6	e6 7b		inc $7b			INC	LAB_7B		; increment BASIC execute pointer high byte
.e3a8					LAB_E3A8
.e3a8	ad 60 ea	lda $ea60		LDA	$EA60			; get byte to scan, address set by call routine
.e3ab	c9 3a		cmp #$3a		CMP	#':'			; compare with ":"
.e3ad	b0 0a		bcs $e3b9		BCS	LAB_E3B9		; exit if>=
.e3af	c9 20		cmp #$20		CMP	#' '			; compare with " "
.e3b1	f0 ef		beq $e3a2		BEQ	LAB_E3A2		; if " " go do next
.e3b3	38		sec			SEC				; set carry for SBC
.e3b4	e9 30		sbc #$30		SBC	#'0'			; subtract "0"
.e3b6	38		sec			SEC				; set carry for SBC
.e3b7	e9 d0		sbc #$d0		SBC	#$D0			; subtract -"0"
.e3b9					LAB_E3B9
.e3b9	60		rts			RTS
>e3ba	80 4f c7 52 58				.byte	$80,$4F,$C7,$52,$58
.e3bf					LAB_E3BF
.e3bf	a9 4c		lda #$4c		LDA	#$4C			; opcode for JMP
.e3c1	85 54		sta $54			STA	LAB_54		; save for functions vector jump
.e3c3	8d 10 03	sta $0310		STA	LAB_0310		; save for USR() vector jump
.e3c6	a9 48		lda #$48		LDA	#<LAB_B248		; set USR() vector low byte
.e3c8	a0 b2		ldy #$b2		LDY	#>LAB_B248		; set USR() vector high byte
.e3ca	8d 11 03	sta $0311		STA	LAB_0311		; save USR() vector low byte
.e3cd	8c 12 03	sty $0312		STY	LAB_0312		; save USR() vector high byte
.e3d0	a9 91		lda #$91		LDA	#<LAB_B391		; set fixed to float vector low byte
.e3d2	a0 b3		ldy #$b3		LDY	#>LAB_B391		; set fixed to float vector high byte
.e3d4	85 05		sta $05			STA	LAB_05		; save fixed to float vector low byte
.e3d6	84 06		sty $06			STY	LAB_06		; save fixed to float vector high byte
.e3d8	a9 aa		lda #$aa		LDA	#<LAB_B1AA		; set float to fixed vector low byte
.e3da	a0 b1		ldy #$b1		LDY	#>LAB_B1AA		; set float to fixed vector high byte
.e3dc	85 03		sta $03			STA	LAB_03		; save float to fixed vector low byte
.e3de	84 04		sty $04			STY	LAB_04		; save float to fixed vector high byte
.e3e0	a2 1c		ldx #$1c		LDX	#$1C			; set the byte count
.e3e2					LAB_E3E2
.e3e2	bd a2 e3	lda $e3a2,x		LDA	LAB_E3A2,X		; get a byte from the table
.e3e5	95 73		sta $73,x		STA	LAB_0073,X		; save the byte in page zero
.e3e7	ca		dex			DEX				; decrement the count
.e3e8	10 f8		bpl $e3e2		BPL	LAB_E3E2		; loop if not all done
.e3ea	a9 03		lda #$03		LDA	#$03			; set the step size, collecting descriptors
.e3ec	85 53		sta $53			STA	LAB_53		; save the garbage collection step size
.e3ee	a9 00		lda #$00		LDA	#$00			; clear A
.e3f0	85 68		sta $68			STA	LAB_68		; clear FAC1 overflow byte
.e3f2	85 13		sta $13			STA	LAB_13		; clear the current I/O channel, flag default
.e3f4	85 18		sta $18			STA	LAB_18		; clear the current descriptor stack item pointer high byte
.e3f6	a2 01		ldx #$01		LDX	#$01			; set X
.e3f8	8e fd 01	stx $01fd		STX	LAB_01FD		; set the chain link pointer low byte
.e3fb	8e fc 01	stx $01fc		STX	LAB_01FC		; set the chain link pointer high byte
.e3fe	a2 19		ldx #$19		LDX	#LAB_19		; initial the value for descriptor stack
.e400	86 16		stx $16			STX	LAB_16		; set descriptor stack pointer
.e402	38		sec			SEC				; set Cb = 1 to read the bottom of memory
.e403	20 9c ff	jsr $ff9c		JSR	LAB_FF9C		; read/set the bottom of memory
.e406	86 2b		stx $2b			STX	LAB_2B		; save the start of memory low byte
.e408	84 2c		sty $2c			STY	LAB_2C		; save the start of memory high byte
.e40a	38		sec			SEC				; set Cb = 1 to read the top of memory
.e40b	20 99 ff	jsr $ff99		JSR	LAB_FF99		; read/set the top of memory
.e40e	86 37		stx $37			STX	LAB_37		; save the end of memory low byte
.e410	84 38		sty $38			STY	LAB_38		; save the end of memory high byte
.e412	86 33		stx $33			STX	LAB_33		; set the bottom of string space low byte
.e414	84 34		sty $34			STY	LAB_34		; set the bottom of string space high byte
.e416	a0 00		ldy #$00		LDY	#$00			; clear the index
.e418	98		tya			TYA				; clear the A
.e419	91 2b		sta ($2b),y		STA	(LAB_2B),Y		; clear the the first byte of memory
.e41b	e6 2b		inc $2b			INC	LAB_2B		; increment the start of memory low byte
.e41d	d0 02		bne $e421		BNE	LAB_E421		; if no rollover skip the high byte increment
.e41f	e6 2c		inc $2c			INC	LAB_2C		; increment start of memory high byte
.e421					LAB_E421
.e421	60		rts			RTS
.e422					LAB_E422
.e422	a5 2b		lda $2b			LDA	LAB_2B		; get the start of memory low byte
.e424	a4 2c		ldy $2c			LDY	LAB_2C		; get the start of memory high byte
.e426	20 08 a4	jsr $a408		JSR	LAB_A408		; check available memory, do out of memory error if no room
.e429	a9 73		lda #$73		LDA	#<LAB_E473		; set "**** COMMODORE 64 BASIC V2 ****" pointer low byte
.e42b	a0 e4		ldy #$e4		LDY	#>LAB_E473		; set "**** COMMODORE 64 BASIC V2 ****" pointer high byte
.e42d	20 1e ab	jsr $ab1e		JSR	LAB_AB1E		; print a null terminated string
.e430	a5 37		lda $37			LDA	LAB_37		; get the end of memory low byte
.e432	38		sec			SEC				; set carry for subtract
.e433	e5 2b		sbc $2b			SBC	LAB_2B		; subtract the start of memory low byte
.e435	aa		tax			TAX				; copy the result to X
.e436	a5 38		lda $38			LDA	LAB_38		; get the end of memory high byte
.e438	e5 2c		sbc $2c			SBC	LAB_2C		; subtract the start of memory high byte
.e43a	20 cd bd	jsr $bdcd		JSR	LAB_BDCD		; print XA as unsigned integer
.e43d	a9 60		lda #$60		LDA	#<LAB_E460		; set " BYTES FREE" pointer low byte
.e43f	a0 e4		ldy #$e4		LDY	#>LAB_E460		; set " BYTES FREE" pointer high byte
.e441	20 1e ab	jsr $ab1e		JSR	LAB_AB1E		; print a null terminated string
.e444	4c 44 a6	jmp $a644		JMP	LAB_A644		; do NEW, CLEAR, RESTORE and return
.e447					LAB_E447
>e447	8b e3					.word	LAB_E38B		; error message				LAB_0300
>e449	83 a4					.word	LAB_A483		; BASIC warm start			LAB_0302
>e44b	7c a5					.word	LAB_A57C		; crunch BASIC tokens			LAB_0304
>e44d	1a a7					.word	LAB_A71A		; uncrunch BASIC tokens			LAB_0306
>e44f	e4 a7					.word	LAB_A7E4		; start new BASIC code			LAB_0308
>e451	86 ae					.word	LAB_AE86		; get arithmetic element		LAB_030A
.e453					LAB_E453
.e453	a2 0b		ldx #$0b		LDX	#$0B			; set byte count
.e455					LAB_E455
.e455	bd 47 e4	lda $e447,x		LDA	LAB_E447,X		; get byte from table
.e458	9d 00 03	sta $0300,x		STA	LAB_0300,X		; save byte to RAM
.e45b	ca		dex			DEX				; decrement index
.e45c	10 f7		bpl $e455		BPL	LAB_E455		; loop if more to do
.e45e	60		rts			RTS
>e45f	00					.byte	$00			; unused byte ??
.e460					LAB_E460
>e460	20 42 41 53 49 43 20 42			.text	" BASIC BYTES FREE",$0D,$00
>e468	59 54 45 53 20 46 52 45 45 0d 00
.e473					LAB_E473
>e473	93 0d					.byte	$93,$0D
>e475	20 20 20 20 2a 2a 2a 2a			.text	"    **** COMMODORE 64 BASIC V2 ****",$0D
>e47d	20 43 4f 4d 4d 4f 44 4f 52 45 20 36 34 20 42 41
>e48d	53 49 43 20 56 32 20 2a 2a 2a 2a 0d
>e499	0d					.byte	$0D
>e49a	20 36 34 4b 20 52 41 4d			.text	" 64K RAM SYSTEM  ",$00
>e4a2	20 53 59 53 54 45 4d 20 20 00
>e4ac	81					.byte	$81			; unused byte ??
.e4ad					LAB_E4AD
.e4ad	48		pha			PHA				; save the flag byte
.e4ae	20 c9 ff	jsr $ffc9		JSR	LAB_FFC9		; open channel for output
.e4b1	aa		tax			TAX				; copy the returned flag byte
.e4b2	68		pla			PLA				; restore the alling flag byte
.e4b3	90 01		bcc $e4b6		BCC	LAB_E4B6		; if there is no error skip copying the error flag
.e4b5	8a		txa			TXA				; else copy the error flag
.e4b6					LAB_E4B6
.e4b6	60		rts			RTS
>e4b7	aa aa aa aa				.byte	$AA,$AA,$AA,$AA	; unused
>e4bb	aa aa aa aa				.byte	$AA,$AA,$AA,$AA	; unused
>e4bf	aa aa aa aa				.byte	$AA,$AA,$AA,$AA	; unused
>e4c3	aa aa aa aa				.byte	$AA,$AA,$AA,$AA	; unused
>e4c7	aa aa aa aa				.byte	$AA,$AA,$AA,$AA	; unused
>e4cb	aa aa aa aa				.byte	$AA,$AA,$AA,$AA	; unused
>e4cf	aa aa aa aa				.byte	$AA,$AA,$AA,$AA	; unused
.e4d3					LAB_E4D3
.e4d3	85 a9		sta $a9			STA	LAB_A9		; save the start bit check flag, set start bit received
.e4d5	a9 01		lda #$01		LDA	#$01			; set the initial parity state
.e4d7	85 ab		sta $ab			STA	LAB_AB		; save the receiver parity bit
.e4d9	60		rts			RTS
.e4da					LAB_E4DA
.e4da	ad 86 02	lda $0286		LDA	LAB_0286		; get the current colour code
.e4dd	91 f3		sta ($f3),y		STA	(LAB_F3),Y		; save it to the colour RAM
.e4df	60		rts			RTS
.e4e0					LAB_E4E0
.e4e0	69 02		adc #$02		ADC	#$02			; set the number of jiffies to wait
.e4e2					LAB_E4E2
.e4e2	a4 91		ldy $91			LDY	LAB_91		; read the stop key column
.e4e4	c8		iny			INY				; test for $FF, no keys pressed
.e4e5	d0 04		bne $e4eb		BNE	LAB_E4EB		; if any keys were pressed just exit
.e4e7	c5 a1		cmp $a1			CMP	LAB_A1		; compare the wait time with the jiffy clock mid byte
.e4e9	d0 f7		bne $e4e2		BNE	LAB_E4E2		; if not there yet go wait some more
.e4eb					LAB_E4EB
.e4eb	60		rts			RTS
.e4ec					LAB_E4EC
>e4ec	19 26					.word	$2619			;   50   baud	985300
>e4ee	44 19					.word	$1944			;   75   baud	985200
>e4f0	1a 11					.word	$111A			;  110   baud	985160
>e4f2	e8 0d					.word	$0DE8			;  134.5 baud	984540
>e4f4	70 0c					.word	$0C70			;  150   baud	985200
>e4f6	06 06					.word	$0606			;  300   baud	985200
>e4f8	d1 02					.word	$02D1			;  600   baud	985200
>e4fa	37 01					.word	$0137			; 1200   baud	986400
>e4fc	ae 00					.word	$00AE			; 1800   baud	986400
>e4fe	69 00					.word	$0069			; 2400   baud	984000
.e500					LAB_E500
.e500	a2 00		ldx #$00		LDX	#<LAB_DC00		; get the I/O base address low byte
.e502	a0 dc		ldy #$dc		LDY	#>LAB_DC00		; get the I/O base address high byte
.e504	60		rts			RTS
.e505					LAB_E505
.e505	a2 28		ldx #$28		LDX	#$28			; get the x size
.e507	a0 19		ldy #$19		LDY	#$19			; get the y size
.e509	60		rts			RTS
.e50a					LAB_E50A
.e50a	b0 07		bcs $e513		BCS	LAB_E513		; if read cursor go do read
.e50c	86 d6		stx $d6			STX	LAB_D6		; save the cursor row
.e50e	84 d3		sty $d3			STY	LAB_D3		; save the cursor column
.e510	20 6c e5	jsr $e56c		JSR	LAB_E56C		; set the screen pointers for the cursor row, column
.e513					LAB_E513
.e513	a6 d6		ldx $d6			LDX	LAB_D6		; get the cursor row
.e515	a4 d3		ldy $d3			LDY	LAB_D3		; get the cursor column
.e517	60		rts			RTS
.e518					LAB_E518
.e518	20 a0 e5	jsr $e5a0		JSR	LAB_E5A0		; initialise the vic chip
.e51b	a9 00		lda #$00		LDA	#$00			; clear A
.e51d	8d 91 02	sta $0291		STA	LAB_0291		; clear the shift mode switch
.e520	85 cf		sta $cf			STA	LAB_CF		; clear the cursor blink phase
.e522	a9 48		lda #$48		LDA	#<LAB_EB48		; get the keyboard decode logic pointer low byte
.e524	8d 8f 02	sta $028f		STA	LAB_028F		; save the keyboard decode logic pointer low byte
.e527	a9 eb		lda #$eb		LDA	#>LAB_EB48		; get the keyboard decode logic pointer high byte
.e529	8d 90 02	sta $0290		STA	LAB_0290		; save the keyboard decode logic pointer high byte
.e52c	a9 0a		lda #$0a		LDA	#$0A			; set the maximum size of the keyboard buffer
.e52e	8d 89 02	sta $0289		STA	LAB_0289		; save the maximum size of the keyboard buffer
.e531	8d 8c 02	sta $028c		STA	LAB_028C		; save the repeat delay counter
.e534	a9 0e		lda #$0e		LDA	#$0E			; set light blue
.e536	8d 86 02	sta $0286		STA	LAB_0286		; save the current colour code
.e539	a9 04		lda #$04		LDA	#$04			; speed 4
.e53b	8d 8b 02	sta $028b		STA	LAB_028B		; save the repeat speed counter
.e53e	a9 0c		lda #$0c		LDA	#$0C			; set the cursor flash timing
.e540	85 cd		sta $cd			STA	LAB_CD		; save the cursor timing countdown
.e542	85 cc		sta $cc			STA	LAB_CC		; save the cursor enable, $00 = flash cursor
.e544					LAB_E544
.e544	ad 88 02	lda $0288		LDA	LAB_0288		; get the screen memory page
.e547	09 80		ora #$80		ORA	#$80			; set the high bit, flag every line is a logical line start
.e549	a8		tay			TAY				; copy to Y
.e54a	a9 00		lda #$00		LDA	#$00			; clear the line start low byte
.e54c	aa		tax			TAX				; clear the index
.e54d					LAB_E54D
.e54d	94 d9		sty $d9,x		STY	LAB_D9,X		; save the start of line X pointer high byte
.e54f	18		clc			CLC				; clear carry for add
.e550	69 28		adc #$28		ADC	#$28			; add the line length to the low byte
.e552	90 01		bcc $e555		BCC	LAB_E555		; if no rollover skip the high byte increment
.e554	c8		iny			INY				; else increment the high byte
.e555					LAB_E555
.e555	e8		inx			INX				; increment the line index
.e556	e0 1a		cpx #$1a		CPX	#$1A			; compare it with the number of lines + 1
.e558	d0 f3		bne $e54d		BNE	LAB_E54D		; loop if not all done
.e55a	a9 ff		lda #$ff		LDA	#$FF			; set the end of table marker
.e55c	95 d9		sta $d9,x		STA	LAB_D9,X		; mark the end of the table
.e55e	a2 18		ldx #$18		LDX	#$18			; set the line count, 25 lines to do, 0 to 24
.e560					LAB_E560
.e560	20 ff e9	jsr $e9ff		JSR	LAB_E9FF		; clear screen line X
.e563	ca		dex			DEX				; decrement the count
.e564	10 fa		bpl $e560		BPL	LAB_E560		; loop if more to do
.e566					LAB_E566
.e566	a0 00		ldy #$00		LDY	#$00			; clear Y
.e568	84 d3		sty $d3			STY	LAB_D3		; clear the cursor column
.e56a	84 d6		sty $d6			STY	LAB_D6		; clear the cursor row
.e56c					LAB_E56C
.e56c	a6 d6		ldx $d6			LDX	LAB_D6		; get the cursor row
.e56e	a5 d3		lda $d3			LDA	LAB_D3		; get the cursor column
.e570					LAB_E570
.e570	b4 d9		ldy $d9,x		LDY	LAB_D9,X		; get start of line X pointer high byte
.e572	30 08		bmi $e57c		BMI	LAB_E57C		; if it is the logical line start continue
.e574	18		clc			CLC				; else clear carry for add
.e575	69 28		adc #$28		ADC	#$28			; add one line length
.e577	85 d3		sta $d3			STA	LAB_D3		; save the cursor column
.e579	ca		dex			DEX				; decrement the cursor row
.e57a	10 f4		bpl $e570		BPL	LAB_E570		; loop, branch always
.e57c					LAB_E57C
.e57c	20 f0 e9	jsr $e9f0		JSR	LAB_E9F0		; fetch a screen address
.e57f	a9 27		lda #$27		LDA	#$27			; set the line length
.e581	e8		inx			INX				; increment the cursor row
.e582					LAB_E582
.e582	b4 d9		ldy $d9,x		LDY	LAB_D9,X		; get the start of line X pointer high byte
.e584	30 06		bmi $e58c		BMI	LAB_E58C		; if logical line start exit
.e586	18		clc			CLC				; else clear carry for add
.e587	69 28		adc #$28		ADC	#$28			; add one line length to the current line length
.e589	e8		inx			INX				; increment the cursor row
.e58a	10 f6		bpl $e582		BPL	LAB_E582		; loop, branch always
.e58c					LAB_E58C
.e58c	85 d5		sta $d5			STA	LAB_D5		; save current screen line length
.e58e	4c 24 ea	jmp $ea24		JMP	LAB_EA24		; calculate the pointer to colour RAM and return
.e591					LAB_E591
.e591	e4 c9		cpx $c9			CPX	LAB_C9		; compare it with the input cursor row
.e593	f0 03		beq $e598		BEQ	LAB_E598		; if there just exit
.e595	4c ed e6	jmp $e6ed		JMP	LAB_E6ED		; else go ??
.e598					LAB_E598
.e598	60		rts			RTS
.e599	ea		nop			NOP				; huh
.e59a	20 a0 e5	jsr $e5a0		JSR	LAB_E5A0		; initialise the vic chip
.e59d	4c 66 e5	jmp $e566		JMP	LAB_E566		; home the cursor and return
.e5a0					LAB_E5A0
.e5a0	a9 03		lda #$03		LDA	#$03			; set the screen as the output device
.e5a2	85 9a		sta $9a			STA	LAB_9A		; save the output device number
.e5a4	a9 00		lda #$00		LDA	#$00			; set the keyboard as the input device
.e5a6	85 99		sta $99			STA	LAB_99		; save the input device number
.e5a8	a2 2f		ldx #$2f		LDX	#$2F			; set the count/index
.e5aa					LAB_E5AA
.e5aa	bd b8 ec	lda $ecb8,x		LDA	LAB_ECB9-1,X	; get a vic ii chip initialisation value
.e5ad	9d ff cf	sta $cfff,x		STA	LAB_D000-1,X	; save it to the vic ii chip
.e5b0	ca		dex			DEX				; decrement the count/index
.e5b1	d0 f7		bne $e5aa		BNE	LAB_E5AA		; loop if more to do
.e5b3	60		rts			RTS
.e5b4					LAB_E5B4
.e5b4	ac 77 02	ldy $0277		LDY	LAB_0277		; get the current character from the buffer
.e5b7	a2 00		ldx #$00		LDX	#$00			; clear the index
.e5b9					LAB_E5B9
.e5b9	bd 78 02	lda $0278,x		LDA	LAB_0277+1,X	; get the next character,X from the buffer
.e5bc	9d 77 02	sta $0277,x		STA	LAB_0277,X		; save it as the current character,X in the buffer
.e5bf	e8		inx			INX				; increment the index
.e5c0	e4 c6		cpx $c6			CPX	LAB_C6		; compare it with the keyboard buffer index
.e5c2	d0 f5		bne $e5b9		BNE	LAB_E5B9		; loop if more to do
.e5c4	c6 c6		dec $c6			DEC	LAB_C6		; decrement keyboard buffer index
.e5c6	98		tya			TYA				; copy the key to A
.e5c7	58		cli			CLI				; enable the interrupts
.e5c8	18		clc			CLC				; flag got byte
.e5c9	60		rts			RTS
.e5ca					LAB_E5CA
.e5ca	20 16 e7	jsr $e716		JSR	LAB_E716		; output character
.e5cd					LAB_E5CD
.e5cd	a5 c6		lda $c6			LDA	LAB_C6		; get the keyboard buffer index
.e5cf	85 cc		sta $cc			STA	LAB_CC		; cursor enable, $00 = flash cursor, $xx = no flash
.e5d1	8d 92 02	sta $0292		STA	LAB_0292		; screen scrolling flag, $00 = scroll, $xx = no scroll
.e5d4	f0 f7		beq $e5cd		BEQ	LAB_E5CD		; loop if the buffer is empty
.e5d6	78		sei			SEI				; disable the interrupts
.e5d7	a5 cf		lda $cf			LDA	LAB_CF		; get the cursor blink phase
.e5d9	f0 0c		beq $e5e7		BEQ	LAB_E5E7		; if cursor phase skip the overwrite
.e5db	a5 ce		lda $ce			LDA	LAB_CE		; get the character under the cursor
.e5dd	ae 87 02	ldx $0287		LDX	LAB_0287		; get the colour under the cursor
.e5e0	a0 00		ldy #$00		LDY	#$00			; clear Y
.e5e2	84 cf		sty $cf			STY	LAB_CF		; clear the cursor blink phase
.e5e4	20 13 ea	jsr $ea13		JSR	LAB_EA13		; print character A and colour X
.e5e7					LAB_E5E7
.e5e7	20 b4 e5	jsr $e5b4		JSR	LAB_E5B4		; input from the keyboard buffer
.e5ea	c9 83		cmp #$83		CMP	#$83			; compare with [SHIFT][RUN]
.e5ec	d0 10		bne $e5fe		BNE	LAB_E5FE		; if not [SHIFT][RUN] skip the buffer fill
.e5ee	a2 09		ldx #$09		LDX	#$09			; set the byte count
.e5f0	78		sei			SEI				; disable the interrupts
.e5f1	86 c6		stx $c6			STX	LAB_C6		; set the keyboard buffer index
.e5f3					LAB_E5F3
.e5f3	bd e6 ec	lda $ece6,x		LDA	LAB_ECE7-1,X	; get byte from the auto load/run table
.e5f6	9d 76 02	sta $0276,x		STA	LAB_0277-1,X	; save it to the keyboard buffer
.e5f9	ca		dex			DEX				; decrement the count/index
.e5fa	d0 f7		bne $e5f3		BNE	LAB_E5F3		; loop while more to do
.e5fc	f0 cf		beq $e5cd		BEQ	LAB_E5CD		; loop for the next key, branch always
.e5fe					LAB_E5FE
.e5fe	c9 0d		cmp #$0d		CMP	#$0D			; compare the key with [CR]
.e600	d0 c8		bne $e5ca		BNE	LAB_E5CA		; if not [CR] print the character and get the next key
.e602	a4 d5		ldy $d5			LDY	LAB_D5		; get the current screen line length
.e604	84 d0		sty $d0			STY	LAB_D0		; input from keyboard or screen, $xx = screen,
.e606					LAB_E606
.e606	b1 d1		lda ($d1),y		LDA	(LAB_D1),Y		; get the character from the current screen line
.e608	c9 20		cmp #$20		CMP	#' '			; compare it with [SPACE]
.e60a	d0 03		bne $e60f		BNE	LAB_E60F		; if not [SPACE] continue
.e60c	88		dey			DEY				; else eliminate the space, decrement end of input line
.e60d	d0 f7		bne $e606		BNE	LAB_E606		; loop, branch always
.e60f					LAB_E60F
.e60f	c8		iny			INY				; increment past the last non space character on line
.e610	84 c8		sty $c8			STY	LAB_C8		; save the input [EOL] pointer
.e612	a0 00		ldy #$00		LDY	#$00			; clear A
.e614	8c 92 02	sty $0292		STY	LAB_0292		; clear the screen scrolling flag, $00 = scroll
.e617	84 d3		sty $d3			STY	LAB_D3		; clear the cursor column
.e619	84 d4		sty $d4			STY	LAB_D4		; clear the cursor quote flag, $xx = quote, $00 = no quote
.e61b	a5 c9		lda $c9			LDA	LAB_C9		; get the input cursor row
.e61d	30 1b		bmi $e63a		BMI	LAB_E63A		;.
.e61f	a6 d6		ldx $d6			LDX	LAB_D6		; get the cursor row
.e621	20 91 e5	jsr $e591		JSR	LAB_E591		; find and set the pointers for the start of logical line
.e624	e4 c9		cpx $c9			CPX	LAB_C9		; compare with input cursor row
.e626	d0 12		bne $e63a		BNE	LAB_E63A		;.
.e628	a5 ca		lda $ca			LDA	LAB_CA		; get the input cursor column
.e62a	85 d3		sta $d3			STA	LAB_D3		; save the cursor column
.e62c	c5 c8		cmp $c8			CMP	LAB_C8		; compare the cursor column with input [EOL] pointer
.e62e	90 0a		bcc $e63a		BCC	LAB_E63A		; if less, cursor is in line, go ??
.e630	b0 2b		bcs $e65d		BCS	LAB_E65D		; else the cursor is beyond the line end, branch always
.e632					LAB_E632
.e632	98		tya			TYA				; copy Y
.e633	48		pha			PHA				; save Y
.e634	8a		txa			TXA				; copy X
.e635	48		pha			PHA				; save X
.e636	a5 d0		lda $d0			LDA	LAB_D0		; input from keyboard or screen, $xx = screen,
.e638	f0 93		beq $e5cd		BEQ	LAB_E5CD		; if keyboard go wait for key
.e63a					LAB_E63A
.e63a	a4 d3		ldy $d3			LDY	LAB_D3		; get the cursor column
.e63c	b1 d1		lda ($d1),y		LDA	(LAB_D1),Y		; get character from the current screen line
.e63e	85 d7		sta $d7			STA	LAB_D7		; save temporary last character
.e640	29 3f		and #$3f		AND	#$3F			; mask key bits
.e642	06 d7		asl $d7			ASL	LAB_D7		; << temporary last character
.e644	24 d7		bit $d7			BIT	LAB_D7		; test it
.e646	10 02		bpl $e64a		BPL	LAB_E64A		; branch if not [NO KEY]
.e648	09 80		ora #$80		ORA	#$80			;.
.e64a					LAB_E64A
.e64a	90 04		bcc $e650		BCC	LAB_E650		;.
.e64c	a6 d4		ldx $d4			LDX	LAB_D4		; get the cursor quote flag, $xx = quote, $00 = no quote
.e64e	d0 04		bne $e654		BNE	LAB_E654		; if in quote mode go ??
.e650					LAB_E650
.e650	70 02		bvs $e654		BVS	LAB_E654		;.
.e652	09 40		ora #$40		ORA	#$40			;.
.e654					LAB_E654
.e654	e6 d3		inc $d3			INC	LAB_D3		; increment the cursor column
.e656	20 84 e6	jsr $e684		JSR	LAB_E684		; if open quote toggle the cursor quote flag
.e659	c4 c8		cpy $c8			CPY	LAB_C8		; compare ?? with input [EOL] pointer
.e65b	d0 17		bne $e674		BNE	LAB_E674		; if not at line end go ??
.e65d					LAB_E65D
.e65d	a9 00		lda #$00		LDA	#$00			; clear A
.e65f	85 d0		sta $d0			STA	LAB_D0		; clear input from keyboard or screen, $xx = screen,
.e661	a9 0d		lda #$0d		LDA	#$0D			; set character [CR]
.e663	a6 99		ldx $99			LDX	LAB_99		; get the input device number
.e665	e0 03		cpx #$03		CPX	#$03			; compare the input device with the screen
.e667	f0 06		beq $e66f		BEQ	LAB_E66F		; if screen go ??
.e669	a6 9a		ldx $9a			LDX	LAB_9A		; get the output device number
.e66b	e0 03		cpx #$03		CPX	#$03			; compare the output device with the screen
.e66d	f0 03		beq $e672		BEQ	LAB_E672		; if screen go ??
.e66f					LAB_E66F
.e66f	20 16 e7	jsr $e716		JSR	LAB_E716		; output the character
.e672					LAB_E672
.e672	a9 0d		lda #$0d		LDA	#$0D			; set character [CR]
.e674					LAB_E674
.e674	85 d7		sta $d7			STA	LAB_D7		; save character
.e676	68		pla			PLA				; pull X
.e677	aa		tax			TAX				; restore X
.e678	68		pla			PLA				; pull Y
.e679	a8		tay			TAY				; restore Y
.e67a	a5 d7		lda $d7			LDA	LAB_D7		; restore character
.e67c	c9 de		cmp #$de		CMP	#$DE			;.
.e67e	d0 02		bne $e682		BNE	LAB_E682		;.
.e680	a9 ff		lda #$ff		LDA	#$FF			;.
.e682					LAB_E682
.e682	18		clc			CLC				; flag ok
.e683	60		rts			RTS
.e684					LAB_E684
.e684	c9 22		cmp #$22		CMP	#$22			; comapre byte with "
.e686	d0 08		bne $e690		BNE	LAB_E690		; exit if not "
.e688	a5 d4		lda $d4			LDA	LAB_D4		; get cursor quote flag, $xx = quote, $00 = no quote
.e68a	49 01		eor #$01		EOR	#$01			; toggle it
.e68c	85 d4		sta $d4			STA	LAB_D4		; save cursor quote flag
.e68e	a9 22		lda #$22		LDA	#$22			; restore the "
.e690					LAB_E690
.e690	60		rts			RTS
.e691					LAB_E691
.e691	09 40		ora #$40		ORA	#$40			; change to uppercase/graphic
.e693					LAB_E693
.e693	a6 c7		ldx $c7			LDX	LAB_C7		; get the reverse flag
.e695	f0 02		beq $e699		BEQ	LAB_E699		; branch if not reverse
.e697					LAB_E697
.e697	09 80		ora #$80		ORA	#$80			; reverse character
.e699					LAB_E699
.e699	a6 d8		ldx $d8			LDX	LAB_D8		; get the insert count
.e69b	f0 02		beq $e69f		BEQ	LAB_E69F		; branch if none
.e69d	c6 d8		dec $d8			DEC	LAB_D8		; else decrement the insert count
.e69f					LAB_E69F
.e69f	ae 86 02	ldx $0286		LDX	LAB_0286		; get the current colour code
.e6a2	20 13 ea	jsr $ea13		JSR	LAB_EA13		; print character A and colour X
.e6a5	20 b6 e6	jsr $e6b6		JSR	LAB_E6B6		; advance the cursor
.e6a8					LAB_E6A8
.e6a8	68		pla			PLA				; pull Y
.e6a9	a8		tay			TAY				; restore Y
.e6aa	a5 d8		lda $d8			LDA	LAB_D8		; get the insert count
.e6ac	f0 02		beq $e6b0		BEQ	LAB_E6B0		; skip quote flag clear if inserts to do
.e6ae	46 d4		lsr $d4			LSR	LAB_D4		; clear cursor quote flag, $xx = quote, $00 = no quote
.e6b0					LAB_E6B0
.e6b0	68		pla			PLA				; pull X
.e6b1	aa		tax			TAX				; restore X
.e6b2	68		pla			PLA				; restore A
.e6b3	18		clc			CLC				;.
.e6b4	58		cli			CLI				; enable the interrupts
.e6b5	60		rts			RTS
.e6b6					LAB_E6B6
.e6b6	20 b3 e8	jsr $e8b3		JSR	LAB_E8B3		; test for line increment
.e6b9	e6 d3		inc $d3			INC	LAB_D3		; increment the cursor column
.e6bb	a5 d5		lda $d5			LDA	LAB_D5		; get current screen line length
.e6bd	c5 d3		cmp $d3			CMP	LAB_D3		; compare ?? with the cursor column
.e6bf	b0 3f		bcs $e700		BCS	LAB_E700		; exit if line length >= cursor column
.e6c1	c9 4f		cmp #$4f		CMP	#$4F			; compare with max length
.e6c3	f0 32		beq $e6f7		BEQ	LAB_E6F7		; if at max clear column, back cursor up and do newline
.e6c5	ad 92 02	lda $0292		LDA	LAB_0292		; get the autoscroll flag
.e6c8	f0 03		beq $e6cd		BEQ	LAB_E6CD		; branch if autoscroll on
.e6ca	4c 67 e9	jmp $e967		JMP	LAB_E967		;.else open space on screen
.e6cd					LAB_E6CD
.e6cd	a6 d6		ldx $d6			LDX	LAB_D6		; get the cursor row
.e6cf	e0 19		cpx #$19		CPX	#$19			; compare with max + 1
.e6d1	90 07		bcc $e6da		BCC	LAB_E6DA		; if less than max + 1 go add this row to the current
.e6d3	20 ea e8	jsr $e8ea		JSR	LAB_E8EA		; else scroll the screen
.e6d6	c6 d6		dec $d6			DEC	LAB_D6		; decrement the cursor row
.e6d8	a6 d6		ldx $d6			LDX	LAB_D6		; get the cursor row
.e6da					LAB_E6DA
.e6da	16 d9		asl $d9,x		ASL	LAB_D9,X		; shift start of line X pointer high byte
.e6dc	56 d9		lsr $d9,x		LSR	LAB_D9,X		; shift start of line X pointer high byte back,
.e6de	e8		inx			INX				; increment screen row
.e6df	b5 d9		lda $d9,x		LDA	LAB_D9,X		; get start of line X pointer high byte
.e6e1	09 80		ora #$80		ORA	#$80			; mark as start of logical line
.e6e3	95 d9		sta $d9,x		STA	LAB_D9,X		; set start of line X pointer high byte
.e6e5	ca		dex			DEX				; restore screen row
.e6e6	a5 d5		lda $d5			LDA	LAB_D5		; get current screen line length
.e6e8	18		clc			CLC				; clear carry for add
.e6e9	69 28		adc #$28		ADC	#$28			; add one line length
.e6eb	85 d5		sta $d5			STA	LAB_D5		; save current screen line length
.e6ed					LAB_E6ED
.e6ed	b5 d9		lda $d9,x		LDA	LAB_D9,X		; get start of line X pointer high byte
.e6ef	30 03		bmi $e6f4		BMI	LAB_E6F4		; exit loop if start of logical line
.e6f1	ca		dex			DEX				; else back up one line
.e6f2	d0 f9		bne $e6ed		BNE	LAB_E6ED		; loop if not on first line
.e6f4					LAB_E6F4
.e6f4	4c f0 e9	jmp $e9f0		JMP	LAB_E9F0		; fetch a screen address
.e6f7					LAB_E6F7
.e6f7	c6 d6		dec $d6			DEC	LAB_D6		; decrement the cursor row
.e6f9	20 7c e8	jsr $e87c		JSR	LAB_E87C		; do newline
.e6fc	a9 00		lda #$00		LDA	#$00			; clear A
.e6fe	85 d3		sta $d3			STA	LAB_D3		; clear the cursor column
.e700					LAB_E700
.e700	60		rts			RTS
.e701					LAB_E701
.e701	a6 d6		ldx $d6			LDX	LAB_D6		; get the cursor row
.e703	d0 06		bne $e70b		BNE	LAB_E70B		; branch if not top row
.e705	86 d3		stx $d3			STX	LAB_D3		; clear cursor column
.e707	68		pla			PLA				; dump return address low byte
.e708	68		pla			PLA				; dump return address high byte
.e709	d0 9d		bne $e6a8		BNE	LAB_E6A8		; restore registers, set quote flag and exit, branch always
.e70b					LAB_E70B
.e70b	ca		dex			DEX				; decrement the cursor row
.e70c	86 d6		stx $d6			STX	LAB_D6		; save the cursor row
.e70e	20 6c e5	jsr $e56c		JSR	LAB_E56C		; set the screen pointers for cursor row, column
.e711	a4 d5		ldy $d5			LDY	LAB_D5		; get current screen line length
.e713	84 d3		sty $d3			STY	LAB_D3		; save the cursor column
.e715	60		rts			RTS
.e716					LAB_E716
.e716	48		pha			PHA				; save character
.e717	85 d7		sta $d7			STA	LAB_D7		; save temporary last character
.e719	8a		txa			TXA				; copy X
.e71a	48		pha			PHA				; save X
.e71b	98		tya			TYA				; copy Y
.e71c	48		pha			PHA				; save Y
.e71d	a9 00		lda #$00		LDA	#$00			; clear A
.e71f	85 d0		sta $d0			STA	LAB_D0		; clear input from keyboard or screen, $xx = screen,
.e721	a4 d3		ldy $d3			LDY	LAB_D3		; get cursor column
.e723	a5 d7		lda $d7			LDA	LAB_D7		; restore last character
.e725	10 03		bpl $e72a		BPL	LAB_E72A		; branch if unshifted
.e727	4c d4 e7	jmp $e7d4		JMP	LAB_E7D4		; do shifted characters and return
.e72a					LAB_E72A
.e72a	c9 0d		cmp #$0d		CMP	#$0D			; compare with [CR]
.e72c	d0 03		bne $e731		BNE	LAB_E731		; branch if not [CR]
.e72e	4c 91 e8	jmp $e891		JMP	LAB_E891		; else output [CR] and return
.e731					LAB_E731
.e731	c9 20		cmp #$20		CMP	#' '			; compare with [SPACE]
.e733	90 10		bcc $e745		BCC	LAB_E745		; branch if < [SPACE]
.e735	c9 60		cmp #$60		CMP	#$60			;.
.e737	90 04		bcc $e73d		BCC	LAB_E73D		; branch if $20 to $5F
.e739	29 df		and #$df		AND	#$DF			;.
.e73b	d0 02		bne $e73f		BNE	LAB_E73F		;.
.e73d					LAB_E73D
.e73d	29 3f		and #$3f		AND	#$3F			;.
.e73f					LAB_E73F
.e73f	20 84 e6	jsr $e684		JSR	LAB_E684		; if open quote toggle cursor direct/programmed flag
.e742	4c 93 e6	jmp $e693		JMP	LAB_E693		;.
.e745					LAB_E745
.e745	a6 d8		ldx $d8			LDX	LAB_D8		; get the insert count
.e747	f0 03		beq $e74c		BEQ	LAB_E74C		; if no characters to insert continue
.e749	4c 97 e6	jmp $e697		JMP	LAB_E697		; insert reversed character
.e74c					LAB_E74C
.e74c	c9 14		cmp #$14		CMP	#$14			; compare the character with [INSERT]/[DELETE]
.e74e	d0 2e		bne $e77e		BNE	LAB_E77E		; if not [INSERT]/[DELETE] go ??
.e750	98		tya			TYA				;.
.e751	d0 06		bne $e759		BNE	LAB_E759		;.
.e753	20 01 e7	jsr $e701		JSR	LAB_E701		; back onto the previous line if possible
.e756	4c 73 e7	jmp $e773		JMP	LAB_E773		;.
.e759					LAB_E759
.e759	20 a1 e8	jsr $e8a1		JSR	LAB_E8A1		; test for line decrement
.e75c	88		dey			DEY				; decrement index to previous character
.e75d	84 d3		sty $d3			STY	LAB_D3		; save the cursor column
.e75f	20 24 ea	jsr $ea24		JSR	LAB_EA24		; calculate the pointer to colour RAM
.e762					LAB_E762
.e762	c8		iny			INY				; increment index to next character
.e763	b1 d1		lda ($d1),y		LDA	(LAB_D1),Y		; get character from current screen line
.e765	88		dey			DEY				; decrement index to previous character
.e766	91 d1		sta ($d1),y		STA	(LAB_D1),Y		; save character to current screen line
.e768	c8		iny			INY				; increment index to next character
.e769	b1 f3		lda ($f3),y		LDA	(LAB_F3),Y		; get colour RAM byte
.e76b	88		dey			DEY				; decrement index to previous character
.e76c	91 f3		sta ($f3),y		STA	(LAB_F3),Y		; save colour RAM byte
.e76e	c8		iny			INY				; increment index to next character
.e76f	c4 d5		cpy $d5			CPY	LAB_D5		; compare with current screen line length
.e771	d0 ef		bne $e762		BNE	LAB_E762		; loop if not there yet
.e773					LAB_E773
.e773	a9 20		lda #$20		LDA	#' '			; set [SPACE]
.e775	91 d1		sta ($d1),y		STA	(LAB_D1),Y		; clear last character on current screen line
.e777	ad 86 02	lda $0286		LDA	LAB_0286		; get the current colour code
.e77a	91 f3		sta ($f3),y		STA	(LAB_F3),Y		; save to colour RAM
.e77c	10 4d		bpl $e7cb		BPL	LAB_E7CB		; branch always
.e77e					LAB_E77E
.e77e	a6 d4		ldx $d4			LDX	LAB_D4		; get cursor quote flag, $xx = quote, $00 = no quote
.e780	f0 03		beq $e785		BEQ	LAB_E785		; branch if not quote mode
.e782	4c 97 e6	jmp $e697		JMP	LAB_E697		; insert reversed character
.e785					LAB_E785
.e785	c9 12		cmp #$12		CMP	#$12			; compare with [RVS ON]
.e787	d0 02		bne $e78b		BNE	LAB_E78B		; if not [RVS ON] skip setting the reverse flag
.e789	85 c7		sta $c7			STA	LAB_C7		; else set the reverse flag
.e78b					LAB_E78B
.e78b	c9 13		cmp #$13		CMP	#$13			; compare with [CLR HOME]
.e78d	d0 03		bne $e792		BNE	LAB_E792		; if not [CLR HOME] continue
.e78f	20 66 e5	jsr $e566		JSR	LAB_E566		; home the cursor
.e792					LAB_E792
.e792	c9 1d		cmp #$1d		CMP	#$1D			; compare with [CURSOR RIGHT]
.e794	d0 17		bne $e7ad		BNE	LAB_E7AD		; if not [CURSOR RIGHT] go ??
.e796	c8		iny			INY				; increment the cursor column
.e797	20 b3 e8	jsr $e8b3		JSR	LAB_E8B3		; test for line increment
.e79a	84 d3		sty $d3			STY	LAB_D3		; save the cursor column
.e79c	88		dey			DEY				; decrement the cursor column
.e79d	c4 d5		cpy $d5			CPY	LAB_D5		; compare cursor column with current screen line length
.e79f	90 09		bcc $e7aa		BCC	LAB_E7AA		; exit if less
.e7a1	c6 d6		dec $d6			DEC	LAB_D6		; decrement the cursor row
.e7a3	20 7c e8	jsr $e87c		JSR	LAB_E87C		; do newline
.e7a6	a0 00		ldy #$00		LDY	#$00			; clear cursor column
.e7a8					LAB_E7A8
.e7a8	84 d3		sty $d3			STY	LAB_D3		; save the cursor column
.e7aa					LAB_E7AA
.e7aa	4c a8 e6	jmp $e6a8		JMP	LAB_E6A8		; restore the registers, set the quote flag and exit
.e7ad					LAB_E7AD
.e7ad	c9 11		cmp #$11		CMP	#$11			; compare with [CURSOR DOWN]
.e7af	d0 1d		bne $e7ce		BNE	LAB_E7CE		; if not [CURSOR DOWN] go ??
.e7b1	18		clc			CLC				; clear carry for add
.e7b2	98		tya			TYA				; copy the cursor column
.e7b3	69 28		adc #$28		ADC	#$28			; add one line
.e7b5	a8		tay			TAY				; copy back to Y
.e7b6	e6 d6		inc $d6			INC	LAB_D6		; increment the cursor row
.e7b8	c5 d5		cmp $d5			CMP	LAB_D5		; compare cursor column with current screen line length
.e7ba	90 ec		bcc $e7a8		BCC	LAB_E7A8		; if less go save cursor column and exit
.e7bc	f0 ea		beq $e7a8		BEQ	LAB_E7A8		; if equal go save cursor column and exit
.e7be	c6 d6		dec $d6			DEC	LAB_D6		; decrement the cursor row
.e7c0					LAB_E7C0
.e7c0	e9 28		sbc #$28		SBC	#$28			; subtract one line
.e7c2	90 04		bcc $e7c8		BCC	LAB_E7C8		; if on previous line exit the loop
.e7c4	85 d3		sta $d3			STA	LAB_D3		; else save the cursor column
.e7c6	d0 f8		bne $e7c0		BNE	LAB_E7C0		; loop if not at the start of the line
.e7c8					LAB_E7C8
.e7c8	20 7c e8	jsr $e87c		JSR	LAB_E87C		; do newline
.e7cb					LAB_E7CB
.e7cb	4c a8 e6	jmp $e6a8		JMP	LAB_E6A8		; restore the registers, set the quote flag and exit
.e7ce					LAB_E7CE
.e7ce	20 cb e8	jsr $e8cb		JSR	LAB_E8CB		; set the colour code
.e7d1	4c 44 ec	jmp $ec44		JMP	LAB_EC44		; go check for special character codes
.e7d4					LAB_E7D4
.e7d4	29 7f		and #$7f		AND	#$7F			; mask 0xxx xxxx, clear b7
.e7d6	c9 7f		cmp #$7f		CMP	#$7F			; was it $FF before the mask
.e7d8	d0 02		bne $e7dc		BNE	LAB_E7DC		; branch if not
.e7da	a9 5e		lda #$5e		LDA	#$5E			; else make it $5E
.e7dc					LAB_E7DC
.e7dc	c9 20		cmp #$20		CMP	#' '			; compare the character with [SPACE]
.e7de	90 03		bcc $e7e3		BCC	LAB_E7E3		; if < [SPACE] go ??
.e7e0	4c 91 e6	jmp $e691		JMP	LAB_E691		; insert uppercase/graphic character and return
.e7e3					LAB_E7E3
.e7e3	c9 0d		cmp #$0d		CMP	#$0D			; compare with [CR]
.e7e5	d0 03		bne $e7ea		BNE	LAB_E7EA		; if not [CR] continue
.e7e7	4c 91 e8	jmp $e891		JMP	LAB_E891		; else output [CR] and return
.e7ea					LAB_E7EA
.e7ea	a6 d4		ldx $d4			LDX	LAB_D4		; get the cursor quote flag, $xx = quote, $00 = no quote
.e7ec	d0 3f		bne $e82d		BNE	LAB_E82D		; branch if quote mode
.e7ee	c9 14		cmp #$14		CMP	#$14			; compare with [INSERT DELETE]
.e7f0	d0 37		bne $e829		BNE	LAB_E829		; if not [INSERT DELETE] go ??
.e7f2	a4 d5		ldy $d5			LDY	LAB_D5		; get current screen line length
.e7f4	b1 d1		lda ($d1),y		LDA	(LAB_D1),Y		; get character from current screen line
.e7f6	c9 20		cmp #$20		CMP	#' '			; compare the character with [SPACE]
.e7f8	d0 04		bne $e7fe		BNE	LAB_E7FE		; if not [SPACE] continue
.e7fa	c4 d3		cpy $d3			CPY	LAB_D3		; compare the current column with the cursor column
.e7fc	d0 07		bne $e805		BNE	LAB_E805		; if not cursor column go open up space on line
.e7fe					LAB_E7FE
.e7fe	c0 4f		cpy #$4f		CPY	#$4F			; compare current column with max line length
.e800	f0 24		beq $e826		BEQ	LAB_E826		; if at line end just exit
.e802	20 65 e9	jsr $e965		JSR	LAB_E965		; else open up a space on the screen
.e805					LAB_E805
.e805	a4 d5		ldy $d5			LDY	LAB_D5		; get current screen line length
.e807	20 24 ea	jsr $ea24		JSR	LAB_EA24		; calculate the pointer to colour RAM
.e80a					LAB_E80A
.e80a	88		dey			DEY				; decrement the index to previous character
.e80b	b1 d1		lda ($d1),y		LDA	(LAB_D1),Y		; get the character from the current screen line
.e80d	c8		iny			INY				; increment the index to next character
.e80e	91 d1		sta ($d1),y		STA	(LAB_D1),Y		; save the character to the current screen line
.e810	88		dey			DEY				; decrement the index to previous character
.e811	b1 f3		lda ($f3),y		LDA	(LAB_F3),Y		; get the current screen line colour RAM byte
.e813	c8		iny			INY				; increment the index to next character
.e814	91 f3		sta ($f3),y		STA	(LAB_F3),Y		; save the current screen line colour RAM byte
.e816	88		dey			DEY				; decrement the index to the previous character
.e817	c4 d3		cpy $d3			CPY	LAB_D3		; compare the index with the cursor column
.e819	d0 ef		bne $e80a		BNE	LAB_E80A		; loop if not there yet
.e81b	a9 20		lda #$20		LDA	#' '			; set [SPACE]
.e81d	91 d1		sta ($d1),y		STA	(LAB_D1),Y		; clear character at cursor position on current screen line
.e81f	ad 86 02	lda $0286		LDA	LAB_0286		; get current colour code
.e822	91 f3		sta ($f3),y		STA	(LAB_F3),Y		; save to cursor position on current screen line colour RAM
.e824	e6 d8		inc $d8			INC	LAB_D8		; increment insert count
.e826					LAB_E826
.e826	4c a8 e6	jmp $e6a8		JMP	LAB_E6A8		; restore the registers, set the quote flag and exit
.e829					LAB_E829
.e829	a6 d8		ldx $d8			LDX	LAB_D8		; get the insert count
.e82b	f0 05		beq $e832		BEQ	LAB_E832		; branch if no insert space
.e82d					LAB_E82D
.e82d	09 40		ora #$40		ORA	#$40			; change to uppercase/graphic
.e82f	4c 97 e6	jmp $e697		JMP	LAB_E697		; insert reversed character
.e832					LAB_E832
.e832	c9 11		cmp #$11		CMP	#$11			; compare with [CURSOR UP]
.e834	d0 16		bne $e84c		BNE	LAB_E84C		; branch if not [CURSOR UP]
.e836	a6 d6		ldx $d6			LDX	LAB_D6		; get the cursor row
.e838	f0 37		beq $e871		BEQ	LAB_E871		; if on the top line go restore the registers, set the
.e83a	c6 d6		dec $d6			DEC	LAB_D6		; decrement the cursor row
.e83c	a5 d3		lda $d3			LDA	LAB_D3		; get the cursor column
.e83e	38		sec			SEC				; set carry for subtract
.e83f	e9 28		sbc #$28		SBC	#$28			; subtract one line length
.e841	90 04		bcc $e847		BCC	LAB_E847		; branch if stepped back to previous line
.e843	85 d3		sta $d3			STA	LAB_D3		; else save the cursor column ..
.e845	10 2a		bpl $e871		BPL	LAB_E871		; .. and exit, branch always
.e847					LAB_E847
.e847	20 6c e5	jsr $e56c		JSR	LAB_E56C		; set the screen pointers for cursor row, column ..
.e84a	d0 25		bne $e871		BNE	LAB_E871		; .. and exit, branch always
.e84c					LAB_E84C
.e84c	c9 12		cmp #$12		CMP	#$12			; compare with [RVS OFF]
.e84e	d0 04		bne $e854		BNE	LAB_E854		; if not [RVS OFF] continue
.e850	a9 00		lda #$00		LDA	#$00			; else clear A
.e852	85 c7		sta $c7			STA	LAB_C7		; clear the reverse flag
.e854					LAB_E854
.e854	c9 1d		cmp #$1d		CMP	#$1D			; compare with [CURSOR LEFT]
.e856	d0 12		bne $e86a		BNE	LAB_E86A		; if not [CURSOR LEFT] go ??
.e858	98		tya			TYA				; copy the cursor column
.e859	f0 09		beq $e864		BEQ	LAB_E864		; if at start of line go back onto the previous line
.e85b	20 a1 e8	jsr $e8a1		JSR	LAB_E8A1		; test for line decrement
.e85e	88		dey			DEY				; decrement the cursor column
.e85f	84 d3		sty $d3			STY	LAB_D3		; save the cursor column
.e861	4c a8 e6	jmp $e6a8		JMP	LAB_E6A8		; restore the registers, set the quote flag and exit
.e864					LAB_E864
.e864	20 01 e7	jsr $e701		JSR	LAB_E701		; back onto the previous line if possible
.e867	4c a8 e6	jmp $e6a8		JMP	LAB_E6A8		; restore the registers, set the quote flag and exit
.e86a					LAB_E86A
.e86a	c9 13		cmp #$13		CMP	#$13			; compare with [CLR]
.e86c	d0 06		bne $e874		BNE	LAB_E874		; if not [CLR] continue
.e86e	20 44 e5	jsr $e544		JSR	LAB_E544		; clear the screen
.e871					LAB_E871
.e871	4c a8 e6	jmp $e6a8		JMP	LAB_E6A8		; restore the registers, set the quote flag and exit
.e874					LAB_E874
.e874	09 80		ora #$80		ORA	#$80			; restore b7, colour can only be black, cyan, magenta
.e876	20 cb e8	jsr $e8cb		JSR	LAB_E8CB		; set the colour code
.e879	4c 4f ec	jmp $ec4f		JMP	LAB_EC4F		; go check for special character codes except fro switch
.e87c					LAB_E87C
.e87c	46 c9		lsr $c9			LSR	LAB_C9		; shift >> input cursor row
.e87e	a6 d6		ldx $d6			LDX	LAB_D6		; get the cursor row
.e880					LAB_E880
.e880	e8		inx			INX				; increment the row
.e881	e0 19		cpx #$19		CPX	#$19			; compare it with last row + 1
.e883	d0 03		bne $e888		BNE	LAB_E888		; if not last row + 1 skip the screen scroll
.e885	20 ea e8	jsr $e8ea		JSR	LAB_E8EA		; else scroll the screen
.e888					LAB_E888
.e888	b5 d9		lda $d9,x		LDA	LAB_D9,X		; get start of line X pointer high byte
.e88a	10 f4		bpl $e880		BPL	LAB_E880		; loop if not start of logical line
.e88c	86 d6		stx $d6			STX	LAB_D6		; save the cursor row
.e88e	4c 6c e5	jmp $e56c		JMP	LAB_E56C		; set the screen pointers for cursor row, column and return
.e891					LAB_E891
.e891	a2 00		ldx #$00		LDX	#$00			; clear X
.e893	86 d8		stx $d8			STX	LAB_D8		; clear the insert count
.e895	86 c7		stx $c7			STX	LAB_C7		; clear the reverse flag
.e897	86 d4		stx $d4			STX	LAB_D4		; clear the cursor quote flag, $xx = quote, $00 = no quote
.e899	86 d3		stx $d3			STX	LAB_D3		; save the cursor column
.e89b	20 7c e8	jsr $e87c		JSR	LAB_E87C		; do newline
.e89e	4c a8 e6	jmp $e6a8		JMP	LAB_E6A8		; restore the registers, set the quote flag and exit
.e8a1					LAB_E8A1
.e8a1	a2 02		ldx #$02		LDX	#$02			; set the count
.e8a3	a9 00		lda #$00		LDA	#$00			; set the column
.e8a5					LAB_E8A5
.e8a5	c5 d3		cmp $d3			CMP	LAB_D3		; compare the column with the cursor column
.e8a7	f0 07		beq $e8b0		BEQ	LAB_E8B0		; if at the start of the line go decrement the cursor row
.e8a9	18		clc			CLC				; else clear carry for add
.e8aa	69 28		adc #$28		ADC	#$28			; increment to next line
.e8ac	ca		dex			DEX				; decrement loop count
.e8ad	d0 f6		bne $e8a5		BNE	LAB_E8A5		; loop if more to test
.e8af	60		rts			RTS
.e8b0					LAB_E8B0
.e8b0	c6 d6		dec $d6			DEC	LAB_D6		; else decrement the cursor row
.e8b2	60		rts			RTS
.e8b3					LAB_E8B3
.e8b3	a2 02		ldx #$02		LDX	#$02			; set the count
.e8b5	a9 27		lda #$27		LDA	#$27			; set the column
.e8b7					LAB_E8B7
.e8b7	c5 d3		cmp $d3			CMP	LAB_D3		; compare the column with the cursor column
.e8b9	f0 07		beq $e8c2		BEQ	LAB_E8C2		; if at end of line test and possibly increment cursor row
.e8bb	18		clc			CLC				; else clear carry for add
.e8bc	69 28		adc #$28		ADC	#$28			; increment to the next line
.e8be	ca		dex			DEX				; decrement the loop count
.e8bf	d0 f6		bne $e8b7		BNE	LAB_E8B7		; loop if more to test
.e8c1	60		rts			RTS
.e8c2					LAB_E8C2
.e8c2	a6 d6		ldx $d6			LDX	LAB_D6		; get the cursor row
.e8c4	e0 19		cpx #$19		CPX	#$19			; compare it with the end of the screen
.e8c6	f0 02		beq $e8ca		BEQ	LAB_E8CA		; if at the end of screen just exit
.e8c8	e6 d6		inc $d6			INC	LAB_D6		; else increment the cursor row
.e8ca					LAB_E8CA
.e8ca	60		rts			RTS
.e8cb					LAB_E8CB
.e8cb	a2 0f		ldx #$0f		LDX	#LAB_E8E9-LAB_E8DA
.e8cd					LAB_E8CD
.e8cd	dd da e8	cmp $e8da,x		CMP	LAB_E8DA,X		; compare the character with a table code
.e8d0	f0 04		beq $e8d6		BEQ	LAB_E8D6		; if a match go save the colour and exit
.e8d2	ca		dex			DEX				; else decrement the index
.e8d3	10 f8		bpl $e8cd		BPL	LAB_E8CD		; loop if more to do
.e8d5	60		rts			RTS
.e8d6					LAB_E8D6
.e8d6	8e 86 02	stx $0286		STX	LAB_0286		; save the current colour code
.e8d9	60		rts			RTS
.e8da					LAB_E8DA
>e8da	90					.byte	$90			;  144	black
>e8db	05					.byte	$05			;    5	white
>e8dc	1c					.byte	$1C			;   28	red
>e8dd	9f					.byte	$9F			;  159	cyan
>e8de	9c					.byte	$9C			;  156	purple
>e8df	1e					.byte	$1E			;   30	green
>e8e0	1f					.byte	$1F			;   31	Blue
>e8e1	9e					.byte	$9E			;  158	yellow
>e8e2	81					.byte	$81			;  129	orange
>e8e3	95					.byte	$95			;  149	brown
>e8e4	96					.byte	$96			;  150	light red
>e8e5	97					.byte	$97			;  151	dark grey
>e8e6	98					.byte	$98			;  152	medium grey
>e8e7	99					.byte	$99			;  153	light green
>e8e8	9a					.byte	$9A			;  154	light blue
.e8e9					LAB_E8E9
>e8e9	9b					.byte	$9B			;  155	light grey
.e8ea					LAB_E8EA
.e8ea	a5 ac		lda $ac			LDA	LAB_AC		; copy the tape buffer start pointer
.e8ec	48		pha			PHA				; save it
.e8ed	a5 ad		lda $ad			LDA	LAB_AD		; copy the tape buffer start pointer
.e8ef	48		pha			PHA				; save it
.e8f0	a5 ae		lda $ae			LDA	LAB_AE		; copy the tape buffer end pointer
.e8f2	48		pha			PHA				; save it
.e8f3	a5 af		lda $af			LDA	LAB_AF		; copy the tape buffer end pointer
.e8f5	48		pha			PHA				; save it
.e8f6					LAB_E8F6
.e8f6	a2 ff		ldx #$ff		LDX	#$FF			; set to -1 for pre increment loop
.e8f8	c6 d6		dec $d6			DEC	LAB_D6		; decrement the cursor row
.e8fa	c6 c9		dec $c9			DEC	LAB_C9		; decrement the input cursor row
.e8fc	ce a5 02	dec $02a5		DEC	LAB_02A5		; decrement the screen row marker
.e8ff					LAB_E8FF
.e8ff	e8		inx			INX				; increment the line number
.e900	20 f0 e9	jsr $e9f0		JSR	LAB_E9F0		; fetch a screen address, set the start of line X
.e903	e0 18		cpx #$18		CPX	#$18			; compare with last line
.e905	b0 0c		bcs $e913		BCS	LAB_E913		; branch if >= $16
.e907	bd f1 ec	lda $ecf1,x		LDA	LAB_ECF0+1,X	; get the start of the next line pointer low byte
.e90a	85 ac		sta $ac			STA	LAB_AC		; save the next line pointer low byte
.e90c	b5 da		lda $da,x		LDA	LAB_D9+1,X		; get the start of the next line pointer high byte
.e90e	20 c8 e9	jsr $e9c8		JSR	LAB_E9C8		; shift the screen line up
.e911	30 ec		bmi $e8ff		BMI	LAB_E8FF		; loop, branch always
.e913					LAB_E913
.e913	20 ff e9	jsr $e9ff		JSR	LAB_E9FF		; clear screen line X
.e916	a2 00		ldx #$00		LDX	#$00			; clear index
.e918					LAB_E918
.e918	b5 d9		lda $d9,x		LDA	LAB_D9,X		; get the start of line X pointer high byte
.e91a	29 7f		and #$7f		AND	#$7F			; clear the line X start of logical line bit
.e91c	b4 da		ldy $da,x		LDY	LAB_D9+1,X		; get the start of the next line pointer high byte
.e91e	10 02		bpl $e922		BPL	LAB_E922		; if next line is not a start of line skip the start set
.e920	09 80		ora #$80		ORA	#$80			; set line X start of logical line bit
.e922					LAB_E922
.e922	95 d9		sta $d9,x		STA	LAB_D9,X		; set start of line X pointer high byte
.e924	e8		inx			INX				; increment line number
.e925	e0 18		cpx #$18		CPX	#$18			; compare with last line
.e927	d0 ef		bne $e918		BNE	LAB_E918		; loop if not last line
.e929	a5 f1		lda $f1			LDA	LAB_D9+$18		; get start of last line pointer high byte
.e92b	09 80		ora #$80		ORA	#$80			; mark as start of logical line
.e92d	85 f1		sta $f1			STA	LAB_D9+$18		; set start of last line pointer high byte
.e92f	a5 d9		lda $d9			LDA	LAB_D9		; get start of first line pointer high byte
.e931	10 c3		bpl $e8f6		BPL	LAB_E8F6		; if not start of logical line loop back and
.e933	e6 d6		inc $d6			INC	LAB_D6		; increment the cursor row
.e935	ee a5 02	inc $02a5		INC	LAB_02A5		; increment screen row marker
.e938	a9 7f		lda #$7f		LDA	#$7F			; set keyboard column c7
.e93a	8d 00 dc	sta $dc00		STA	LAB_DC00		; save VIA 1 DRA, keyboard column drive
.e93d	ad 01 dc	lda $dc01		LDA	LAB_DC01		; read VIA 1 DRB, keyboard row port
.e940	c9 fb		cmp #$fb		CMP	#$FB			; compare with row r2 active, [CTL]
.e942	08		php			PHP				; save status
.e943	a9 7f		lda #$7f		LDA	#$7F			; set keyboard column c7
.e945	8d 00 dc	sta $dc00		STA	LAB_DC00		; save VIA 1 DRA, keyboard column drive
.e948	28		plp			PLP				; restore status
.e949	d0 0b		bne $e956		BNE	LAB_E956		; skip delay if ??
.e94b	a0 00		ldy #$00		LDY	#$00			; clear delay outer loop count, do this 256 times
.e94d					LAB_E94D
.e94d	ea		nop			NOP				; waste cycles
.e94e	ca		dex			DEX				; decrement inner loop count
.e94f	d0 fc		bne $e94d		BNE	LAB_E94D		; loop if not all done
.e951	88		dey			DEY				; decrement outer loop count
.e952	d0 f9		bne $e94d		BNE	LAB_E94D		; loop if not all done
.e954	84 c6		sty $c6			STY	LAB_C6		; clear the keyboard buffer index
.e956					LAB_E956
.e956	a6 d6		ldx $d6			LDX	LAB_D6		; get the cursor row
.e958					LAB_E958
.e958	68		pla			PLA				; pull tape buffer end pointer
.e959	85 af		sta $af			STA	LAB_AF		; restore it
.e95b	68		pla			PLA				; pull tape buffer end pointer
.e95c	85 ae		sta $ae			STA	LAB_AE		; restore it
.e95e	68		pla			PLA				; pull tape buffer pointer
.e95f	85 ad		sta $ad			STA	LAB_AD		; restore it
.e961	68		pla			PLA				; pull tape buffer pointer
.e962	85 ac		sta $ac			STA	LAB_AC		; restore it
.e964	60		rts			RTS
.e965					LAB_E965
.e965	a6 d6		ldx $d6			LDX	LAB_D6		; get the cursor row
.e967					LAB_E967
.e967	e8		inx			INX				; increment the row
.e968	b5 d9		lda $d9,x		LDA	LAB_D9,X		; get the start of line X pointer high byte
.e96a	10 fb		bpl $e967		BPL	LAB_E967		; loop if not start of logical line
.e96c	8e a5 02	stx $02a5		STX	LAB_02A5		; save the screen row marker
.e96f	e0 18		cpx #$18		CPX	#$18			; compare it with the last line
.e971	f0 0e		beq $e981		BEQ	LAB_E981		; if = last line go ??
.e973	90 0c		bcc $e981		BCC	LAB_E981		; if < last line go ??
.e975	20 ea e8	jsr $e8ea		JSR	LAB_E8EA		; scroll the screen
.e978	ae a5 02	ldx $02a5		LDX	LAB_02A5		; get the screen row marker
.e97b	ca		dex			DEX				; decrement the screen row marker
.e97c	c6 d6		dec $d6			DEC	LAB_D6		; decrement the cursor row
.e97e	4c da e6	jmp $e6da		JMP	LAB_E6DA		; add this row to the current logical line and return
.e981					LAB_E981
.e981	a5 ac		lda $ac			LDA	LAB_AC		; copy tape buffer pointer
.e983	48		pha			PHA				; save it
.e984	a5 ad		lda $ad			LDA	LAB_AD		; copy tape buffer pointer
.e986	48		pha			PHA				; save it
.e987	a5 ae		lda $ae			LDA	LAB_AE		; copy tape buffer end pointer
.e989	48		pha			PHA				; save it
.e98a	a5 af		lda $af			LDA	LAB_AF		; copy tape buffer end pointer
.e98c	48		pha			PHA				; save it
.e98d	a2 19		ldx #$19		LDX	#$19			; set to end line + 1 for predecrement loop
.e98f					LAB_E98F
.e98f	ca		dex			DEX				; decrement the line number
.e990	20 f0 e9	jsr $e9f0		JSR	LAB_E9F0		; fetch a screen address
.e993	ec a5 02	cpx $02a5		CPX	LAB_02A5		; compare it with the screen row marker
.e996	90 0e		bcc $e9a6		BCC	LAB_E9A6		; if < screen row marker go ??
.e998	f0 0c		beq $e9a6		BEQ	LAB_E9A6		; if = screen row marker go ??
.e99a	bd ef ec	lda $ecef,x		LDA	LAB_ECF0-1,X	; else get the start of the previous line low byte from the
.e99d	85 ac		sta $ac			STA	LAB_AC		; save previous line pointer low byte
.e99f	b5 d8		lda $d8,x		LDA	LAB_D9-1,X		; get the start of the previous line pointer high byte
.e9a1	20 c8 e9	jsr $e9c8		JSR	LAB_E9C8		; shift the screen line down
.e9a4	30 e9		bmi $e98f		BMI	LAB_E98F		; loop, branch always
.e9a6					LAB_E9A6
.e9a6	20 ff e9	jsr $e9ff		JSR	LAB_E9FF		; clear screen line X
.e9a9	a2 17		ldx #$17		LDX	#$17			;.
.e9ab					LAB_E9AB
.e9ab	ec a5 02	cpx $02a5		CPX	LAB_02A5		; compare it with the screen row marker
.e9ae	90 0f		bcc $e9bf		BCC	LAB_E9BF		;.
.e9b0	b5 da		lda $da,x		LDA	LAB_D9+1,X		;.
.e9b2	29 7f		and #$7f		AND	#$7F			;.
.e9b4	b4 d9		ldy $d9,x		LDY	LAB_D9,X		; get start of line X pointer high byte
.e9b6	10 02		bpl $e9ba		BPL	LAB_E9BA		;.
.e9b8	09 80		ora #$80		ORA	#$80			;.
.e9ba					LAB_E9BA
.e9ba	95 da		sta $da,x		STA	LAB_D9+1,X		;.
.e9bc	ca		dex			DEX				;.
.e9bd	d0 ec		bne $e9ab		BNE	LAB_E9AB		;.
.e9bf					LAB_E9BF
.e9bf	ae a5 02	ldx $02a5		LDX	LAB_02A5		; get the screen row marker
.e9c2	20 da e6	jsr $e6da		JSR	LAB_E6DA		; add this row to the current logical line
.e9c5	4c 58 e9	jmp $e958		JMP	LAB_E958		; restore the tape buffer pointers and exit
.e9c8					LAB_E9C8
.e9c8	29 03		and #$03		AND	#$03			; mask 0000 00xx, line memory page
.e9ca	0d 88 02	ora $0288		ORA	LAB_0288		; OR with screen memory page
.e9cd	85 ad		sta $ad			STA	LAB_AD		; save next/previous line pointer high byte
.e9cf	20 e0 e9	jsr $e9e0		JSR	LAB_E9E0		; calculate pointers to screen lines colour RAM
.e9d2	a0 27		ldy #$27		LDY	#$27			; set the column count
.e9d4					LAB_E9D4
.e9d4	b1 ac		lda ($ac),y		LDA	(LAB_AC),Y		; get character from next/previous screen line
.e9d6	91 d1		sta ($d1),y		STA	(LAB_D1),Y		; save character to current screen line
.e9d8	b1 ae		lda ($ae),y		LDA	(LAB_AE),Y		; get colour from next/previous screen line colour RAM
.e9da	91 f3		sta ($f3),y		STA	(LAB_F3),Y		; save colour to current screen line colour RAM
.e9dc	88		dey			DEY				; decrement column index/count
.e9dd	10 f5		bpl $e9d4		BPL	LAB_E9D4		; loop if more to do
.e9df	60		rts			RTS
.e9e0					LAB_E9E0
.e9e0	20 24 ea	jsr $ea24		JSR	LAB_EA24		; calculate the pointer to the current screen line colour
.e9e3	a5 ac		lda $ac			LDA	LAB_AC		; get the next screen line pointer low byte
.e9e5	85 ae		sta $ae			STA	LAB_AE		; save the next screen line colour RAM pointer low byte
.e9e7	a5 ad		lda $ad			LDA	LAB_AD		; get the next screen line pointer high byte
.e9e9	29 03		and #$03		AND	#$03			; mask 0000 00xx, line memory page
.e9eb	09 d8		ora #$d8		ORA	#>LAB_D800		; set  1101 01xx, colour memory page
.e9ed	85 af		sta $af			STA	LAB_AF		; save the next screen line colour RAM pointer high byte
.e9ef	60		rts			RTS
.e9f0					LAB_E9F0
.e9f0	bd f0 ec	lda $ecf0,x		LDA	LAB_ECF0,X		; get the start of line low byte from the ROM table
.e9f3	85 d1		sta $d1			STA	LAB_D1		; set the current screen line pointer low byte
.e9f5	b5 d9		lda $d9,x		LDA	LAB_D9,X		; get the start of line high byte from the RAM table
.e9f7	29 03		and #$03		AND	#$03			; mask 0000 00xx, line memory page
.e9f9	0d 88 02	ora $0288		ORA	LAB_0288		; OR with the screen memory page
.e9fc	85 d2		sta $d2			STA	LAB_D2		; save the current screen line pointer high byte
.e9fe	60		rts			RTS
.e9ff					LAB_E9FF
.e9ff	a0 27		ldy #$27		LDY	#$27			; set number of columns to clear
.ea01	20 f0 e9	jsr $e9f0		JSR	LAB_E9F0		; fetch a screen address
.ea04	20 24 ea	jsr $ea24		JSR	LAB_EA24		; calculate the pointer to colour RAM
.ea07					LAB_EA07
.ea07	20 da e4	jsr $e4da		JSR	LAB_E4DA		; save the current colour to the colour RAM
.ea0a	a9 20		lda #$20		LDA	#' '			; set [SPACE]
.ea0c	91 d1		sta ($d1),y		STA	(LAB_D1),Y		; clear character in current screen line
.ea0e	88		dey			DEY				; decrement index
.ea0f	10 f6		bpl $ea07		BPL	LAB_EA07		; loop if more to do
.ea11	60		rts			RTS
.ea12	ea		nop			NOP				; unused
.ea13					LAB_EA13
.ea13	a8		tay			TAY				; copy the character
.ea14	a9 02		lda #$02		LDA	#$02			; set the count to $02, usually $14 ??
.ea16	85 cd		sta $cd			STA	LAB_CD		; save the cursor countdown
.ea18	20 24 ea	jsr $ea24		JSR	LAB_EA24		; calculate the pointer to colour RAM
.ea1b	98		tya			TYA				; get the character back
.ea1c					LAB_EA1C
.ea1c	a4 d3		ldy $d3			LDY	LAB_D3		; get the cursor column
.ea1e	91 d1		sta ($d1),y		STA	(LAB_D1),Y		; save the character from current screen line
.ea20	8a		txa			TXA				; copy the colour to A
.ea21	91 f3		sta ($f3),y		STA	(LAB_F3),Y		; save to colour RAM
.ea23	60		rts			RTS
.ea24					LAB_EA24
.ea24	a5 d1		lda $d1			LDA	LAB_D1		; get current screen line pointer low byte
.ea26	85 f3		sta $f3			STA	LAB_F3		; save pointer to colour RAM low byte
.ea28	a5 d2		lda $d2			LDA	LAB_D2		; get current screen line pointer high byte
.ea2a	29 03		and #$03		AND	#$03			; mask 0000 00xx, line memory page
.ea2c	09 d8		ora #$d8		ORA	#>LAB_D800		; set  1101 01xx, colour memory page
.ea2e	85 f4		sta $f4			STA	LAB_F4		; save pointer to colour RAM high byte
.ea30	60		rts			RTS
.ea31					LAB_EA31
.ea31	20 ea ff	jsr $ffea		JSR	LAB_FFEA		; increment the real time clock
.ea34	a5 cc		lda $cc			LDA	LAB_CC		; get the cursor enable, $00 = flash cursor
.ea36	d0 29		bne $ea61		BNE	LAB_EA61		; if flash not enabled skip the flash
.ea38	c6 cd		dec $cd			DEC	LAB_CD		; decrement the cursor timing countdown
.ea3a	d0 25		bne $ea61		BNE	LAB_EA61		; if not counted out skip the flash
.ea3c	a9 14		lda #$14		LDA	#$14			; set the flash count
.ea3e	85 cd		sta $cd			STA	LAB_CD		; save the cursor timing countdown
.ea40	a4 d3		ldy $d3			LDY	LAB_D3		; get the cursor column
.ea42	46 cf		lsr $cf			LSR	LAB_CF		; shift b0 cursor blink phase into carry
.ea44	ae 87 02	ldx $0287		LDX	LAB_0287		; get the colour under the cursor
.ea47	b1 d1		lda ($d1),y		LDA	(LAB_D1),Y		; get the character from current screen line
.ea49	b0 11		bcs $ea5c		BCS	LAB_EA5C		; branch if cursor phase b0 was 1
.ea4b	e6 cf		inc $cf			INC	LAB_CF		; set the cursor blink phase to 1
.ea4d	85 ce		sta $ce			STA	LAB_CE		; save the character under the cursor
.ea4f	20 24 ea	jsr $ea24		JSR	LAB_EA24		; calculate the pointer to colour RAM
.ea52	b1 f3		lda ($f3),y		LDA	(LAB_F3),Y		; get the colour RAM byte
.ea54	8d 87 02	sta $0287		STA	LAB_0287		; save the colour under the cursor
.ea57	ae 86 02	ldx $0286		LDX	LAB_0286		; get the current colour code
.ea5a	a5 ce		lda $ce			LDA	LAB_CE		; get the character under the cursor
.ea5c					LAB_EA5C
.ea5c	49 80		eor #$80		EOR	#$80			; toggle b7 of character under cursor
.ea5e	20 1c ea	jsr $ea1c		JSR	LAB_EA1C		; save the character and colour to the screen @ the cursor
.ea61					LAB_EA61
.ea61	a5 01		lda $01			LDA	LAB_01		; read the 6510 I/O port
.ea63	29 10		and #$10		AND	#$10			; mask 000x 0000, the cassette switch sense
.ea65	f0 0a		beq $ea71		BEQ	LAB_EA71		; if the cassette sense is low skip the motor stop
.ea67	a0 00		ldy #$00		LDY	#$00			; clear Y
.ea69	84 c0		sty $c0			STY	LAB_C0		; clear the tape motor interlock
.ea6b	a5 01		lda $01			LDA	LAB_01		; read the 6510 I/O port
.ea6d	09 20		ora #$20		ORA	#$20			; mask xxxx xx1x, turn off the motor
.ea6f	d0 08		bne $ea79		BNE	LAB_EA79		; go save the port value, branch always
.ea71					LAB_EA71
.ea71	a5 c0		lda $c0			LDA	LAB_C0		; get the tape motor interlock
.ea73	d0 06		bne $ea7b		BNE	LAB_EA7B		; if the cassette interlock <> 0 don't turn on motor
.ea75	a5 01		lda $01			LDA	LAB_01		; read the 6510 I/O port
.ea77	29 1f		and #$1f		AND	#$1F			; mask xxxx xx0x, turn on the motor
.ea79					LAB_EA79
.ea79	85 01		sta $01			STA	LAB_01		; save the 6510 I/O port
.ea7b					LAB_EA7B
.ea7b	20 87 ea	jsr $ea87		JSR	LAB_EA87		; scan the keyboard
.ea7e	ad 0d dc	lda $dc0d		LDA	LAB_DC0D		; read VIA 1 ICR, clear the timer interrupt flag
.ea81	68		pla			PLA				; pull Y
.ea82	a8		tay			TAY				; restore Y
.ea83	68		pla			PLA				; pull X
.ea84	aa		tax			TAX				; restore X
.ea85	68		pla			PLA				; restore A
.ea86	40		rti			RTI
.ea87					LAB_EA87
.ea87	a9 00		lda #$00		LDA	#$00			; clear A
.ea89	8d 8d 02	sta $028d		STA	LAB_028D		; clear the keyboard shift/control/c= flag
.ea8c	a0 40		ldy #$40		LDY	#$40			; set no key
.ea8e	84 cb		sty $cb			STY	LAB_CB		; save which key
.ea90	8d 00 dc	sta $dc00		STA	LAB_DC00		; clear VIA 1 DRA, keyboard column drive
.ea93	ae 01 dc	ldx $dc01		LDX	LAB_DC01		; read VIA 1 DRB, keyboard row port
.ea96	e0 ff		cpx #$ff		CPX	#$FF			; compare with all bits set
.ea98	f0 61		beq $eafb		BEQ	LAB_EAFB		; if no key pressed clear current key and exit (does
.ea9a	a8		tay			TAY				; clear the key count
.ea9b	a9 81		lda #$81		LDA	#<LAB_EB81		; get the decode table low byte
.ea9d	85 f5		sta $f5			STA	LAB_F5		; save the keyboard pointer low byte
.ea9f	a9 eb		lda #$eb		LDA	#>LAB_EB81		; get the decode table high byte
.eaa1	85 f6		sta $f6			STA	LAB_F6		; save the keyboard pointer high byte
.eaa3	a9 fe		lda #$fe		LDA	#$FE			; set column 0 low
.eaa5	8d 00 dc	sta $dc00		STA	LAB_DC00		; save VIA 1 DRA, keyboard column drive
.eaa8					LAB_EAA8
.eaa8	a2 08		ldx #$08		LDX	#$08			; set the row count
.eaaa	48		pha			PHA				; save the column
.eaab					LAB_EAAB
.eaab	ad 01 dc	lda $dc01		LDA	LAB_DC01		; read VIA 1 DRB, keyboard row port
.eaae	cd 01 dc	cmp $dc01		CMP	LAB_DC01		; compare it with itself
.eab1	d0 f8		bne $eaab		BNE	LAB_EAAB		; loop if changing
.eab3					LAB_EAB3
.eab3	4a		lsr a			LSR				; shift row to Cb
.eab4	b0 16		bcs $eacc		BCS	LAB_EACC		; if no key closed on this row go do next row
.eab6	48		pha			PHA				; save row
.eab7	b1 f5		lda ($f5),y		LDA	(LAB_F5),Y		; get character from decode table
.eab9	c9 05		cmp #$05		CMP	#$05			; compare with $05, there is no $05 key but the control
.eabb	b0 0c		bcs $eac9		BCS	LAB_EAC9		; if not shift/control/c=/stop go save key count
.eabd	c9 03		cmp #$03		CMP	#$03			; compare with $03, stop
.eabf	f0 08		beq $eac9		BEQ	LAB_EAC9		; if stop go save key count and continue
.eac1	0d 8d 02	ora $028d		ORA	LAB_028D		; OR it with the keyboard shift/control/c= flag
.eac4	8d 8d 02	sta $028d		STA	LAB_028D		; save the keyboard shift/control/c= flag
.eac7	10 02		bpl $eacb		BPL	LAB_EACB		; skip save key, branch always
.eac9					LAB_EAC9
.eac9	84 cb		sty $cb			STY	LAB_CB		; save key count
.eacb					LAB_EACB
.eacb	68		pla			PLA				; restore row
.eacc					LAB_EACC
.eacc	c8		iny			INY				; increment key count
.eacd	c0 41		cpy #$41		CPY	#$41			; compare with max+1
.eacf	b0 0b		bcs $eadc		BCS	LAB_EADC		; exit loop if >= max+1
.ead1	ca		dex			DEX				; decrement row count
.ead2	d0 df		bne $eab3		BNE	LAB_EAB3		; loop if more rows to do
.ead4	38		sec			SEC				; set carry for keyboard column shift
.ead5	68		pla			PLA				; restore the column
.ead6	2a		rol a			ROL				; shift the keyboard column
.ead7	8d 00 dc	sta $dc00		STA	LAB_DC00		; save VIA 1 DRA, keyboard column drive
.eada	d0 cc		bne $eaa8		BNE	LAB_EAA8		; loop for next column, branch always
.eadc					LAB_EADC
.eadc	68		pla			PLA				; dump the saved column
.eadd	6c 8f 02	jmp ($028f)		JMP	(LAB_028F)		; evaluate the SHIFT/CTRL/C= keys, LAB_EBDC
.eae0					LAB_EAE0
.eae0	a4 cb		ldy $cb			LDY	LAB_CB		; get saved key count
.eae2	b1 f5		lda ($f5),y		LDA	(LAB_F5),Y		; get character from decode table
.eae4	aa		tax			TAX				; copy character to X
.eae5	c4 c5		cpy $c5			CPY	LAB_C5		; compare key count with last key count
.eae7	f0 07		beq $eaf0		BEQ	LAB_EAF0		; if this key = current key, key held, go test repeat
.eae9	a0 10		ldy #$10		LDY	#$10			; set the repeat delay count
.eaeb	8c 8c 02	sty $028c		STY	LAB_028C		; save the repeat delay count
.eaee	d0 36		bne $eb26		BNE	LAB_EB26		; go save key to buffer and exit, branch always
.eaf0					LAB_EAF0
.eaf0	29 7f		and #$7f		AND	#$7F			; clear b7
.eaf2	2c 8a 02	bit $028a		BIT	LAB_028A		; test key repeat
.eaf5	30 16		bmi $eb0d		BMI	LAB_EB0D		; if repeat all go ??
.eaf7	70 49		bvs $eb42		BVS	LAB_EB42		; if repeat none go ??
.eaf9	c9 7f		cmp #$7f		CMP	#$7F			; compare with end marker
.eafb					LAB_EAFB
.eafb	f0 29		beq $eb26		BEQ	LAB_EB26		; if $00/end marker go save key to buffer and exit
.eafd	c9 14		cmp #$14		CMP	#$14			; compare with [INSERT]/[DELETE]
.eaff	f0 0c		beq $eb0d		BEQ	LAB_EB0D		; if [INSERT]/[DELETE] go test for repeat
.eb01	c9 20		cmp #$20		CMP	#' '			; compare with [SPACE]
.eb03	f0 08		beq $eb0d		BEQ	LAB_EB0D		; if [SPACE] go test for repeat
.eb05	c9 1d		cmp #$1d		CMP	#$1D			; compare with [CURSOR RIGHT]
.eb07	f0 04		beq $eb0d		BEQ	LAB_EB0D		; if [CURSOR RIGHT] go test for repeat
.eb09	c9 11		cmp #$11		CMP	#$11			; compare with [CURSOR DOWN]
.eb0b	d0 35		bne $eb42		BNE	LAB_EB42		; if not [CURSOR DOWN] just exit
.eb0d					LAB_EB0D
.eb0d	ac 8c 02	ldy $028c		LDY	LAB_028C		; get the repeat delay counter
.eb10	f0 05		beq $eb17		BEQ	LAB_EB17		; if delay expired go ??
.eb12	ce 8c 02	dec $028c		DEC	LAB_028C		; else decrement repeat delay counter
.eb15	d0 2b		bne $eb42		BNE	LAB_EB42		; if delay not expired go ??
.eb17					LAB_EB17
.eb17	ce 8b 02	dec $028b		DEC	LAB_028B		; decrement the repeat speed counter
.eb1a	d0 26		bne $eb42		BNE	LAB_EB42		; branch if repeat speed count not expired
.eb1c	a0 04		ldy #$04		LDY	#$04			; set for 4/60ths of a second
.eb1e	8c 8b 02	sty $028b		STY	LAB_028B		; save the repeat speed counter
.eb21	a4 c6		ldy $c6			LDY	LAB_C6		; get the keyboard buffer index
.eb23	88		dey			DEY				; decrement it
.eb24	10 1c		bpl $eb42		BPL	LAB_EB42		; if the buffer isn't empty just exit
.eb26					LAB_EB26
.eb26	a4 cb		ldy $cb			LDY	LAB_CB		; get the key count
.eb28	84 c5		sty $c5			STY	LAB_C5		; save it as the current key count
.eb2a	ac 8d 02	ldy $028d		LDY	LAB_028D		; get the keyboard shift/control/c= flag
.eb2d	8c 8e 02	sty $028e		STY	LAB_028E		; save it as last keyboard shift pattern
.eb30	e0 ff		cpx #$ff		CPX	#$FF			; compare the character with the table end marker or no key
.eb32	f0 0e		beq $eb42		BEQ	LAB_EB42		; if it was the table end marker or no key just exit
.eb34	8a		txa			TXA				; copy the character to A
.eb35	a6 c6		ldx $c6			LDX	LAB_C6		; get the keyboard buffer index
.eb37	ec 89 02	cpx $0289		CPX	LAB_0289		; compare it with the keyboard buffer size
.eb3a	b0 06		bcs $eb42		BCS	LAB_EB42		; if the buffer is full just exit
.eb3c	9d 77 02	sta $0277,x		STA	LAB_0277,X		; save the character to the keyboard buffer
.eb3f	e8		inx			INX				; increment the index
.eb40	86 c6		stx $c6			STX	LAB_C6		; save the keyboard buffer index
.eb42					LAB_EB42
.eb42	a9 7f		lda #$7f		LDA	#$7F			; enable column 7 for the stop key
.eb44	8d 00 dc	sta $dc00		STA	LAB_DC00		; save VIA 1 DRA, keyboard column drive
.eb47	60		rts			RTS
.eb48					LAB_EB48
.eb48	ad 8d 02	lda $028d		LDA	LAB_028D		; get the keyboard shift/control/c= flag
.eb4b	c9 03		cmp #$03		CMP	#$03			; compare with [SHIFT][C=]
.eb4d	d0 15		bne $eb64		BNE	LAB_EB64		; if not [SHIFT][C=] go ??
.eb4f	cd 8e 02	cmp $028e		CMP	LAB_028E		; compare with last
.eb52	f0 ee		beq $eb42		BEQ	LAB_EB42		; exit if still the same
.eb54	ad 91 02	lda $0291		LDA	LAB_0291		; get the shift mode switch $00 = enabled, $80 = locked
.eb57	30 1d		bmi $eb76		BMI	LAB_EB76		; if locked continue keyboard decode
.eb59	ad 18 d0	lda $d018		LDA	LAB_D018		; get the start of character memory address
.eb5c	49 02		eor #$02		EOR	#$02			; toggle address b1
.eb5e	8d 18 d0	sta $d018		STA	LAB_D018		; save the start of character memory address
.eb61	4c 76 eb	jmp $eb76		JMP	LAB_EB76		; continue the keyboard decode
.eb64					LAB_EB64
.eb64	0a		asl a			ASL				; << 1
.eb65	c9 08		cmp #$08		CMP	#$08			; compare with [CTRL]
.eb67	90 02		bcc $eb6b		BCC	LAB_EB6B		; if [CTRL] is not pressed skip the index change
.eb69	a9 06		lda #$06		LDA	#$06			; else [CTRL] was pressed so make the index = $06
.eb6b					LAB_EB6B
.eb6b	aa		tax			TAX				; copy the index to X
.eb6c	bd 79 eb	lda $eb79,x		LDA	LAB_EB79,X		; get the decode table pointer low byte
.eb6f	85 f5		sta $f5			STA	LAB_F5		; save the decode table pointer low byte
.eb71	bd 7a eb	lda $eb7a,x		LDA	LAB_EB79+1,X	; get the decode table pointer high byte
.eb74	85 f6		sta $f6			STA	LAB_F6		; save the decode table pointer high byte
.eb76					LAB_EB76
.eb76	4c e0 ea	jmp $eae0		JMP	LAB_EAE0		; continue the keyboard decode
.eb79					LAB_EB79
>eb79	81 eb					.word	LAB_EB81		; standard
>eb7b	c2 eb					.word	LAB_EBC2		; shift
>eb7d	03 ec					.word	LAB_EC03		; commodore
>eb7f	78 ec					.word	LAB_EC78		; control
.eb81					LAB_EB81
>eb81	14 0d 1d 88 85 86 87 11			.byte	$14,$0D,$1D,$88,$85,$86,$87,$11
>eb89	33 57 41 34 5a 53 45 01			.byte	$33,$57,$41,$34,$5A,$53,$45,$01
>eb91	35 52 44 36 43 46 54 58			.byte	$35,$52,$44,$36,$43,$46,$54,$58
>eb99	37 59 47 38 42 48 55 56			.byte	$37,$59,$47,$38,$42,$48,$55,$56
>eba1	39 49 4a 30 4d 4b 4f 4e			.byte	$39,$49,$4A,$30,$4D,$4B,$4F,$4E
>eba9	2b 50 4c 2d 2e 3a 40 2c			.byte	$2B,$50,$4C,$2D,$2E,$3A,$40,$2C
>ebb1	5c 2a 3b 13 01 3d 5e 2f			.byte	$5C,$2A,$3B,$13,$01,$3D,$5E,$2F
>ebb9	31 5f 04 32 20 02 51 03			.byte	$31,$5F,$04,$32,$20,$02,$51,$03
>ebc1	ff					.byte	$FF
.ebc2					LAB_EBC2
>ebc2	94 8d 9d 8c 89 8a 8b 91			.byte	$94,$8D,$9D,$8C,$89,$8A,$8B,$91
>ebca	23 d7 c1 24 da d3 c5 01			.byte	$23,$D7,$C1,$24,$DA,$D3,$C5,$01
>ebd2	25 d2 c4 26 c3 c6 d4 d8			.byte	$25,$D2,$C4,$26,$C3,$C6,$D4,$D8
>ebda	27 d9 c7 28 c2 c8 d5 d6			.byte	$27,$D9,$C7,$28,$C2,$C8,$D5,$D6
>ebe2	29 c9 ca 30 cd cb cf ce			.byte	$29,$C9,$CA,$30,$CD,$CB,$CF,$CE
>ebea	db d0 cc dd 3e 5b ba 3c			.byte	$DB,$D0,$CC,$DD,$3E,$5B,$BA,$3C
>ebf2	a9 c0 5d 93 01 3d de 3f			.byte	$A9,$C0,$5D,$93,$01,$3D,$DE,$3F
>ebfa	21 5f 04 22 a0 02 d1 83			.byte	$21,$5F,$04,$22,$A0,$02,$D1,$83
>ec02	ff					.byte	$FF
.ec03					LAB_EC03
>ec03	94 8d 9d 8c 89 8a 8b 91			.byte	$94,$8D,$9D,$8C,$89,$8A,$8B,$91
>ec0b	96 b3 b0 97 ad ae b1 01			.byte	$96,$B3,$B0,$97,$AD,$AE,$B1,$01
>ec13	98 b2 ac 99 bc bb a3 bd			.byte	$98,$B2,$AC,$99,$BC,$BB,$A3,$BD
>ec1b	9a b7 a5 9b bf b4 b8 be			.byte	$9A,$B7,$A5,$9B,$BF,$B4,$B8,$BE
>ec23	29 a2 b5 30 a7 a1 b9 aa			.byte	$29,$A2,$B5,$30,$A7,$A1,$B9,$AA
>ec2b	a6 af b6 dc 3e 5b a4 3c			.byte	$A6,$AF,$B6,$DC,$3E,$5B,$A4,$3C
>ec33	a8 df 5d 93 01 3d de 3f			.byte	$A8,$DF,$5D,$93,$01,$3D,$DE,$3F
>ec3b	81 5f 04 95 a0 02 ab 83			.byte	$81,$5F,$04,$95,$A0,$02,$AB,$83
>ec43	ff					.byte	$FF
.ec44					LAB_EC44
.ec44	c9 0e		cmp #$0e		CMP	#$0E			; compare with [SWITCH TO LOWER CASE]
.ec46	d0 07		bne $ec4f		BNE	LAB_EC4F		; if not [SWITCH TO LOWER CASE] skip the switch
.ec48	ad 18 d0	lda $d018		LDA	LAB_D018		; get the start of character memory address
.ec4b	09 02		ora #$02		ORA	#$02			; mask xxxx xx1x, set lower case characters
.ec4d	d0 09		bne $ec58		BNE	LAB_EC58		; go save the new value, branch always
.ec4f					LAB_EC4F
.ec4f	c9 8e		cmp #$8e		CMP	#$8E			; compare with [SWITCH TO UPPER CASE]
.ec51	d0 0b		bne $ec5e		BNE	LAB_EC5E		; if not [SWITCH TO UPPER CASE] go do the [SHIFT]+[C=] key
.ec53	ad 18 d0	lda $d018		LDA	LAB_D018		; get the start of character memory address
.ec56	29 fd		and #$fd		AND	#$FD			; mask xxxx xx0x, set upper case characters
.ec58					LAB_EC58
.ec58	8d 18 d0	sta $d018		STA	LAB_D018		; save the start of character memory address
.ec5b					LAB_EC5B
.ec5b	4c a8 e6	jmp $e6a8		JMP	LAB_E6A8		; restore the registers, set the quote flag and exit
.ec5e					LAB_EC5E
.ec5e	c9 08		cmp #$08		CMP	#$08			; compare with disable [SHIFT][C=]
.ec60	d0 07		bne $ec69		BNE	LAB_EC69		; if not disable [SHIFT][C=] skip the set
.ec62	a9 80		lda #$80		LDA	#$80			; set to lock shift mode switch
.ec64	0d 91 02	ora $0291		ORA	LAB_0291		; OR it with the shift mode switch
.ec67	30 09		bmi $ec72		BMI	LAB_EC72		; go save the value, branch always
.ec69					LAB_EC69
.ec69	c9 09		cmp #$09		CMP	#$09			; compare with enable [SHIFT][C=]
.ec6b	d0 ee		bne $ec5b		BNE	LAB_EC5B		; exit if not enable [SHIFT][C=]
.ec6d	a9 7f		lda #$7f		LDA	#$7F			; set to unlock shift mode switch
.ec6f	2d 91 02	and $0291		AND	LAB_0291		; AND it with the shift mode switch
.ec72					LAB_EC72
.ec72	8d 91 02	sta $0291		STA	LAB_0291		; save the shift mode switch $00 = enabled, $80 = locked
.ec75	4c a8 e6	jmp $e6a8		JMP	LAB_E6A8		; restore the registers, set the quote flag and exit
.ec78					LAB_EC78
>ec78	ff ff ff ff ff ff ff ff			.byte	$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
>ec80	1c 17 01 9f 1a 13 05 ff			.byte	$1C,$17,$01,$9F,$1A,$13,$05,$FF
>ec88	9c 12 04 1e 03 06 14 18			.byte	$9C,$12,$04,$1E,$03,$06,$14,$18
>ec90	1f 19 07 9e 02 08 15 16			.byte	$1F,$19,$07,$9E,$02,$08,$15,$16
>ec98	12 09 0a 92 0d 0b 0f 0e			.byte	$12,$09,$0A,$92,$0D,$0B,$0F,$0E
>eca0	ff 10 0c ff ff 1b 00 ff			.byte	$FF,$10,$0C,$FF,$FF,$1B,$00,$FF
>eca8	1c ff 1d ff ff 1f 1e ff			.byte	$1C,$FF,$1D,$FF,$FF,$1F,$1E,$FF
>ecb0	90 06 ff 05 ff ff 11 ff			.byte	$90,$06,$FF,$05,$FF,$FF,$11,$FF
>ecb8	ff					.byte	$FF
.ecb9					LAB_ECB9
>ecb9	00 00					.byte	$00,$00		; sprite 0 x,y
>ecbb	00 00					.byte	$00,$00		; sprite 1 x,y
>ecbd	00 00					.byte	$00,$00		; sprite 2 x,y
>ecbf	00 00					.byte	$00,$00		; sprite 3 x,y
>ecc1	00 00					.byte	$00,$00		; sprite 4 x,y
>ecc3	00 00					.byte	$00,$00		; sprite 5 x,y
>ecc5	00 00					.byte	$00,$00		; sprite 6 x,y
>ecc7	00 00					.byte	$00,$00		; sprite 7 x,y
>ecc9	00					.byte	$00			; sprites 0 to 7 x bit 8
>ecca	9b					.byte	$9B			; enable screen, enable 25 rows
>eccb	37					.byte	$37			; raster compare
>eccc	00					.byte	$00			; light pen x
>eccd	00					.byte	$00			; light pen y
>ecce	00					.byte	$00			; sprite 0 to 7 enable
>eccf	08					.byte	$08			; enable 40 column display
>ecd0	00					.byte	$00			; sprite 0 to 7 y expand
>ecd1	14					.byte	$14			; memory control
>ecd2	0f					.byte	$0F			; clear all interrupts
>ecd3	00					.byte	$00			; all vic IRQs disabeld
>ecd4	00					.byte	$00			; sprite 0 to 7 foreground priority
>ecd5	00					.byte	$00			; sprite 0 to 7 multicolour
>ecd6	00					.byte	$00			; sprite 0 to 7 x expand
>ecd7	00					.byte	$00			; sprite 0 to 7 sprite collision
>ecd8	00					.byte	$00			; sprite 0 to 7 foreground collision
>ecd9	0e					.byte	$0E			; border colour
>ecda	06					.byte	$06			; background colour 0
>ecdb	01					.byte	$01			; background colour 1
>ecdc	02					.byte	$02			; background colour 2
>ecdd	03					.byte	$03			; background colour 3
>ecde	04					.byte	$04			; sprite multicolour 0
>ecdf	00					.byte	$00			; sprite multicolour 1
>ece0	01					.byte	$01			; sprite 0 colour
>ece1	02					.byte	$02			; sprite 1 colour
>ece2	03					.byte	$03			; sprite 2 colour
>ece3	04					.byte	$04			; sprite 3 colour
>ece4	05					.byte	$05			; sprite 4 colour
>ece5	06					.byte	$06			; sprite 5 colour
>ece6	07					.byte	$07			; sprite 6 colour
.ece7					LAB_ECE7
>ece7	4c 4f 41 44 0d 52 55 4e			.text	"LOAD",$0D,"RUN",$0D
>ecef	0d
.ecf0					LAB_ECF0
>ecf0	00 28 50 78 a0				.byte	$00,$28,$50,$78,$A0
>ecf5	c8 f0 18 40 68				.byte	$C8,$F0,$18,$40,$68
>ecfa	90 b8 e0 08 30				.byte	$90,$B8,$E0,$08,$30
>ecff	58 80 a8 d0 f8				.byte	$58,$80,$A8,$D0,$F8
>ed04	20 48 70 98 c0				.byte	$20,$48,$70,$98,$C0
.ed09					LAB_ED09
.ed09	09 40		ora #$40		ORA	#$40			; OR with the TALK command
>ed0b	2c					.byte	$2C			; makes next line BIT LAB_xxxx
.ed0c					LAB_ED0C
.ed0c	09 20		ora #$20		ORA	#$20			; OR with the LISTEN command
.ed0e	20 a4 f0	jsr $f0a4		JSR	LAB_F0A4		; check RS232 bus idle
.ed11					LAB_ED11
.ed11	48		pha			PHA				; save device address
.ed12	24 94		bit $94			BIT	LAB_94		; test deferred character flag
.ed14	10 0a		bpl $ed20		BPL	LAB_ED20		; if no defered character continue
.ed16	38		sec			SEC				; else flag EOI
.ed17	66 a3		ror $a3			ROR	LAB_A3		; rotate into EOI flag byte
.ed19	20 40 ed	jsr $ed40		JSR	LAB_ED40		; Tx byte on serial bus
.ed1c	46 94		lsr $94			LSR	LAB_94		; clear deferred character flag
.ed1e	46 a3		lsr $a3			LSR	LAB_A3		; clear EOI flag
.ed20					LAB_ED20
.ed20	68		pla			PLA				; restore the device address
.ed21	85 95		sta $95			STA	LAB_95		; save as serial defered character
.ed23	78		sei			SEI				; disable the interrupts
.ed24	20 97 ee	jsr $ee97		JSR	LAB_EE97		; set the serial data out high
.ed27	c9 3f		cmp #$3f		CMP	#$3F			; compare read byte with $3F
.ed29	d0 03		bne $ed2e		BNE	LAB_ED2E		; branch if not $3F, this branch will always be taken as
.ed2b	20 85 ee	jsr $ee85		JSR	LAB_EE85		; set the serial clock out high
.ed2e					LAB_ED2E
.ed2e	ad 00 dd	lda $dd00		LDA	LAB_DD00		; read VIA 2 DRA, serial port and video address
.ed31	09 08		ora #$08		ORA	#$08			; mask xxxx 1xxx, set serial ATN low
.ed33	8d 00 dd	sta $dd00		STA	LAB_DD00		; save VIA 2 DRA, serial port and video address
.ed36					LAB_ED36
.ed36	78		sei			SEI				; disable the interrupts
.ed37	20 8e ee	jsr $ee8e		JSR	LAB_EE8E		; set the serial clock out low
.ed3a	20 97 ee	jsr $ee97		JSR	LAB_EE97		; set the serial data out high
.ed3d	20 b3 ee	jsr $eeb3		JSR	LAB_EEB3		; 1ms delay
.ed40					LAB_ED40
.ed40	78		sei			SEI				; disable the interrupts
.ed41	20 97 ee	jsr $ee97		JSR	LAB_EE97		; set the serial data out high
.ed44	20 a9 ee	jsr $eea9		JSR	LAB_EEA9		; get the serial data status in Cb
.ed47	b0 64		bcs $edad		BCS	LAB_EDAD		; if the serial data is high go do 'device not present'
.ed49	20 85 ee	jsr $ee85		JSR	LAB_EE85		; set the serial clock out high
.ed4c	24 a3		bit $a3			BIT	LAB_A3		; test the EOI flag
.ed4e	10 0a		bpl $ed5a		BPL	LAB_ED5A		; if not EOI go ??
.ed50					LAB_ED50
.ed50	20 a9 ee	jsr $eea9		JSR	LAB_EEA9		; get the serial data status in Cb
.ed53	90 fb		bcc $ed50		BCC	LAB_ED50		; loop if the data is low
.ed55					LAB_ED55
.ed55	20 a9 ee	jsr $eea9		JSR	LAB_EEA9		; get the serial data status in Cb
.ed58	b0 fb		bcs $ed55		BCS	LAB_ED55		; loop if the data is high
.ed5a					LAB_ED5A
.ed5a	20 a9 ee	jsr $eea9		JSR	LAB_EEA9		; get the serial data status in Cb
.ed5d	90 fb		bcc $ed5a		BCC	LAB_ED5A		; loop if the data is low
.ed5f	20 8e ee	jsr $ee8e		JSR	LAB_EE8E		; set the serial clock out low
.ed62	a9 08		lda #$08		LDA	#$08			; eight bits to do
.ed64	85 a5		sta $a5			STA	LAB_A5		; set serial bus bit count
.ed66					LAB_ED66
.ed66	ad 00 dd	lda $dd00		LDA	LAB_DD00		; read VIA 2 DRA, serial port and video address
.ed69	cd 00 dd	cmp $dd00		CMP	LAB_DD00		; compare it with itself
.ed6c	d0 f8		bne $ed66		BNE	LAB_ED66		; if changed go try again
.ed6e	0a		asl a			ASL				; shift the serial data into Cb
.ed6f	90 3f		bcc $edb0		BCC	LAB_EDB0		; if the serial data is low go do serial bus timeout
.ed71	66 95		ror $95			ROR	LAB_95		; rotate the transmit byte
.ed73	b0 05		bcs $ed7a		BCS	LAB_ED7A		; if the bit = 1 go set the serial data out high
.ed75	20 a0 ee	jsr $eea0		JSR	LAB_EEA0		; else set the serial data out low
.ed78	d0 03		bne $ed7d		BNE	LAB_ED7D		; continue, branch always
.ed7a					LAB_ED7A
.ed7a	20 97 ee	jsr $ee97		JSR	LAB_EE97		; set the serial data out high
.ed7d					LAB_ED7D
.ed7d	20 85 ee	jsr $ee85		JSR	LAB_EE85		; set the serial clock out high
.ed80	ea		nop			NOP				; waste ..
.ed81	ea		nop			NOP				; .. a ..
.ed82	ea		nop			NOP				; .. cycle ..
.ed83	ea		nop			NOP				; .. or two
.ed84	ad 00 dd	lda $dd00		LDA	LAB_DD00		; read VIA 2 DRA, serial port and video address
.ed87	29 df		and #$df		AND	#$DF			; mask xx0x xxxx, set the serial data out high
.ed89	09 10		ora #$10		ORA	#$10			; mask xxx1 xxxx, set the serial clock out low
.ed8b	8d 00 dd	sta $dd00		STA	LAB_DD00		; save VIA 2 DRA, serial port and video address
.ed8e	c6 a5		dec $a5			DEC	LAB_A5		; decrement the serial bus bit count
.ed90	d0 d4		bne $ed66		BNE	LAB_ED66		; loop if not all done
.ed92	a9 04		lda #$04		LDA	#$04			; wait for up to about 1ms
.ed94	8d 07 dc	sta $dc07		STA	LAB_DC07		; save VIA 1 timer B high byte
.ed97	a9 19		lda #$19		LDA	#$19			; load timer B, timer B single shot, start timer B
.ed99	8d 0f dc	sta $dc0f		STA	LAB_DC0F		; save VIA 1 CRB
.ed9c	ad 0d dc	lda $dc0d		LDA	LAB_DC0D		; read VIA 1 ICR
.ed9f					LAB_ED9F
.ed9f	ad 0d dc	lda $dc0d		LDA	LAB_DC0D		; read VIA 1 ICR
.eda2	29 02		and #$02		AND	#$02			; mask 0000 00x0, timer A interrupt
.eda4	d0 0a		bne $edb0		BNE	LAB_EDB0		; if timer A interrupt go do serial bus timeout
.eda6	20 a9 ee	jsr $eea9		JSR	LAB_EEA9		; get the serial data status in Cb
.eda9	b0 f4		bcs $ed9f		BCS	LAB_ED9F		; if the serial data is high go wait some more
.edab	58		cli			CLI				; enable the interrupts
.edac	60		rts			RTS
.edad					LAB_EDAD
.edad	a9 80		lda #$80		LDA	#$80			; error $80, device not present
>edaf	2c					.byte	$2C			; makes next line BIT LAB_xxxx
.edb0					LAB_EDB0
.edb0	a9 03		lda #$03		LDA	#$03			; error $03, read timeout, write timeout
.edb2					LAB_EDB2
.edb2	20 1c fe	jsr $fe1c		JSR	LAB_FE1C		; OR into the serial status byte
.edb5	58		cli			CLI				; enable the interrupts
.edb6	18		clc			CLC				; clear for branch
.edb7	90 4a		bcc $ee03		BCC	LAB_EE03		; ATN high, delay, clock high then data high, branch always
.edb9					LAB_EDB9
.edb9	85 95		sta $95			STA	LAB_95		; save the defered Tx byte
.edbb	20 36 ed	jsr $ed36		JSR	LAB_ED36		; set the serial clk/data, wait and Tx the byte
.edbe					LAB_EDBE
.edbe	ad 00 dd	lda $dd00		LDA	LAB_DD00		; read VIA 2 DRA, serial port and video address
.edc1	29 f7		and #$f7		AND	#$F7			; mask xxxx 0xxx, set serial ATN high
.edc3	8d 00 dd	sta $dd00		STA	LAB_DD00		; save VIA 2 DRA, serial port and video address
.edc6	60		rts			RTS
.edc7					LAB_EDC7
.edc7	85 95		sta $95			STA	LAB_95		; save the defered Tx byte
.edc9	20 36 ed	jsr $ed36		JSR	LAB_ED36		; set the serial clk/data, wait and Tx the byte
.edcc					LAB_EDCC
.edcc	78		sei			SEI				; disable the interrupts
.edcd	20 a0 ee	jsr $eea0		JSR	LAB_EEA0		; set the serial data out low
.edd0	20 be ed	jsr $edbe		JSR	LAB_EDBE		; set serial ATN high
.edd3	20 85 ee	jsr $ee85		JSR	LAB_EE85		; set the serial clock out high
.edd6					LAB_EDD6
.edd6	20 a9 ee	jsr $eea9		JSR	LAB_EEA9		; get the serial data status in Cb
.edd9	30 fb		bmi $edd6		BMI	LAB_EDD6		; loop if the clock is high
.eddb	58		cli			CLI				; enable the interrupts
.eddc	60		rts			RTS
.eddd					LAB_EDDD
.eddd	24 94		bit $94			BIT	LAB_94		; test the deferred character flag
.eddf	30 05		bmi $ede6		BMI	LAB_EDE6		; if there is a defered character go send it
.ede1	38		sec			SEC				; set carry
.ede2	66 94		ror $94			ROR	LAB_94		; shift into the deferred character flag
.ede4	d0 05		bne $edeb		BNE	LAB_EDEB		; save the byte and exit, branch always
.ede6					LAB_EDE6
.ede6	48		pha			PHA				; save the byte
.ede7	20 40 ed	jsr $ed40		JSR	LAB_ED40		; Tx byte on serial bus
.edea	68		pla			PLA				; restore the byte
.edeb					LAB_EDEB
.edeb	85 95		sta $95			STA	LAB_95		; save the defered Tx byte
.eded	18		clc			CLC				; flag ok
.edee	60		rts			RTS
.edef					LAB_EDEF
.edef	78		sei			SEI				; disable the interrupts
.edf0	20 8e ee	jsr $ee8e		JSR	LAB_EE8E		; set the serial clock out low
.edf3	ad 00 dd	lda $dd00		LDA	LAB_DD00		; read VIA 2 DRA, serial port and video address
.edf6	09 08		ora #$08		ORA	#$08			; mask xxxx 1xxx, set the serial ATN low
.edf8	8d 00 dd	sta $dd00		STA	LAB_DD00		; save VIA 2 DRA, serial port and video address
.edfb	a9 5f		lda #$5f		LDA	#$5F			; set the UNTALK command
>edfd	2c					.byte	$2C			; makes next line BIT LAB_xxxx
.edfe					LAB_EDFE
.edfe	a9 3f		lda #$3f		LDA	#$3F			; set the UNLISTEN command
.ee00	20 11 ed	jsr $ed11		JSR	LAB_ED11		; send a control character
.ee03					LAB_EE03
.ee03	20 be ed	jsr $edbe		JSR	LAB_EDBE		; set serial ATN high
.ee06					LAB_EE06
.ee06	8a		txa			TXA				; save the device number
.ee07	a2 0a		ldx #$0a		LDX	#$0A			; short delay
.ee09					LAB_EE09
.ee09	ca		dex			DEX				; decrement the count
.ee0a	d0 fd		bne $ee09		BNE	LAB_EE09		; loop if not all done
.ee0c	aa		tax			TAX				; restore the device number
.ee0d	20 85 ee	jsr $ee85		JSR	LAB_EE85		; set the serial clock out high
.ee10	4c 97 ee	jmp $ee97		JMP	LAB_EE97		; set the serial data out high and return
.ee13					LAB_EE13
.ee13	78		sei			SEI				; disable the interrupts
.ee14	a9 00		lda #$00		LDA	#$00			; set 0 bits to do, will flag EOI on timeour
.ee16	85 a5		sta $a5			STA	LAB_A5		; save the serial bus bit count
.ee18	20 85 ee	jsr $ee85		JSR	LAB_EE85		; set the serial clock out high
.ee1b					LAB_EE1B
.ee1b	20 a9 ee	jsr $eea9		JSR	LAB_EEA9		; get the serial data status in Cb
.ee1e	10 fb		bpl $ee1b		BPL	LAB_EE1B		; loop if the serial clock is low
.ee20					LAB_EE20
.ee20	a9 01		lda #$01		LDA	#$01			; set the timeout count high byte
.ee22	8d 07 dc	sta $dc07		STA	LAB_DC07		; save VIA 1 timer B high byte
.ee25	a9 19		lda #$19		LDA	#$19			; load timer B, timer B single shot, start timer B
.ee27	8d 0f dc	sta $dc0f		STA	LAB_DC0F		; save VIA 1 CRB
.ee2a	20 97 ee	jsr $ee97		JSR	LAB_EE97		; set the serial data out high
.ee2d	ad 0d dc	lda $dc0d		LDA	LAB_DC0D		; read VIA 1 ICR
.ee30					LAB_EE30
.ee30	ad 0d dc	lda $dc0d		LDA	LAB_DC0D		; read VIA 1 ICR
.ee33	29 02		and #$02		AND	#$02			; mask 0000 00x0, timer A interrupt
.ee35	d0 07		bne $ee3e		BNE	LAB_EE3E		; if timer A interrupt go ??
.ee37	20 a9 ee	jsr $eea9		JSR	LAB_EEA9		; get the serial data status in Cb
.ee3a	30 f4		bmi $ee30		BMI	LAB_EE30		; loop if the serial clock is low
.ee3c	10 18		bpl $ee56		BPL	LAB_EE56		; else go set 8 bits to do, branch always
.ee3e					LAB_EE3E
.ee3e	a5 a5		lda $a5			LDA	LAB_A5		; get the serial bus bit count
.ee40	f0 05		beq $ee47		BEQ	LAB_EE47		; if not already EOI then go flag EOI
.ee42	a9 02		lda #$02		LDA	#$02			; else error $02, read timeour
.ee44	4c b2 ed	jmp $edb2		JMP	LAB_EDB2		; set the serial status and exit
.ee47					LAB_EE47
.ee47	20 a0 ee	jsr $eea0		JSR	LAB_EEA0		; set the serial data out low
.ee4a	20 85 ee	jsr $ee85		JSR	LAB_EE85		; set the serial clock out high
.ee4d	a9 40		lda #$40		LDA	#$40			; set EOI
.ee4f	20 1c fe	jsr $fe1c		JSR	LAB_FE1C		; OR into the serial status byte
.ee52	e6 a5		inc $a5			INC	LAB_A5		; increment the serial bus bit count, do error on the next
.ee54	d0 ca		bne $ee20		BNE	LAB_EE20		; go try again, branch always
.ee56					LAB_EE56
.ee56	a9 08		lda #$08		LDA	#$08			; set 8 bits to do
.ee58	85 a5		sta $a5			STA	LAB_A5		; save the serial bus bit count
.ee5a					LAB_EE5A
.ee5a	ad 00 dd	lda $dd00		LDA	LAB_DD00		; read VIA 2 DRA, serial port and video address
.ee5d	cd 00 dd	cmp $dd00		CMP	LAB_DD00		; compare it with itself
.ee60	d0 f8		bne $ee5a		BNE	LAB_EE5A		; if changing go try again
.ee62	0a		asl a			ASL				; shift the serial data into the carry
.ee63	10 f5		bpl $ee5a		BPL	LAB_EE5A		; loop while the serial clock is low
.ee65	66 a4		ror $a4			ROR	LAB_A4		; shift the data bit into the receive byte
.ee67					LAB_EE67
.ee67	ad 00 dd	lda $dd00		LDA	LAB_DD00		; read VIA 2 DRA, serial port and video address
.ee6a	cd 00 dd	cmp $dd00		CMP	LAB_DD00		; compare it with itself
.ee6d	d0 f8		bne $ee67		BNE	LAB_EE67		; if changing go try again
.ee6f	0a		asl a			ASL				; shift the serial data into the carry
.ee70	30 f5		bmi $ee67		BMI	LAB_EE67		; loop while the serial clock is high
.ee72	c6 a5		dec $a5			DEC	LAB_A5		; decrement the serial bus bit count
.ee74	d0 e4		bne $ee5a		BNE	LAB_EE5A		; loop if not all done
.ee76	20 a0 ee	jsr $eea0		JSR	LAB_EEA0		; set the serial data out low
.ee79	24 90		bit $90			BIT	LAB_90		; test the serial status byte
.ee7b	50 03		bvc $ee80		BVC	LAB_EE80		; if EOI not set skip the bus end sequence
.ee7d	20 06 ee	jsr $ee06		JSR	LAB_EE06		; 1ms delay, clock high then data high
.ee80					LAB_EE80
.ee80	a5 a4		lda $a4			LDA	LAB_A4		; get the receive byte
.ee82	58		cli			CLI				; enable the interrupts
.ee83	18		clc			CLC				; flag ok
.ee84	60		rts			RTS
.ee85					LAB_EE85
.ee85	ad 00 dd	lda $dd00		LDA	LAB_DD00		; read VIA 2 DRA, serial port and video address
.ee88	29 ef		and #$ef		AND	#$EF			; mask xxx0 xxxx, set serial clock out high
.ee8a	8d 00 dd	sta $dd00		STA	LAB_DD00		; save VIA 2 DRA, serial port and video address
.ee8d	60		rts			RTS
.ee8e					LAB_EE8E
.ee8e	ad 00 dd	lda $dd00		LDA	LAB_DD00		; read VIA 2 DRA, serial port and video address
.ee91	09 10		ora #$10		ORA	#$10			; mask xxx1 xxxx, set serial clock out low
.ee93	8d 00 dd	sta $dd00		STA	LAB_DD00		; save VIA 2 DRA, serial port and video address
.ee96	60		rts			RTS
.ee97					LAB_EE97
.ee97	ad 00 dd	lda $dd00		LDA	LAB_DD00		; read VIA 2 DRA, serial port and video address
.ee9a	29 df		and #$df		AND	#$DF			; mask xx0x xxxx, set serial data out high
.ee9c	8d 00 dd	sta $dd00		STA	LAB_DD00		; save VIA 2 DRA, serial port and video address
.ee9f	60		rts			RTS
.eea0					LAB_EEA0
.eea0	ad 00 dd	lda $dd00		LDA	LAB_DD00		; read VIA 2 DRA, serial port and video address
.eea3	09 20		ora #$20		ORA	#$20			; mask xx1x xxxx, set serial data out low
.eea5	8d 00 dd	sta $dd00		STA	LAB_DD00		; save VIA 2 DRA, serial port and video address
.eea8	60		rts			RTS
.eea9					LAB_EEA9
.eea9	ad 00 dd	lda $dd00		LDA	LAB_DD00		; read VIA 2 DRA, serial port and video address
.eeac	cd 00 dd	cmp $dd00		CMP	LAB_DD00		; compare it with itself
.eeaf	d0 f8		bne $eea9		BNE	LAB_EEA9		; if changing got try again
.eeb1	0a		asl a			ASL				; shift the serial data into Cb
.eeb2	60		rts			RTS
.eeb3					LAB_EEB3
.eeb3	8a		txa			TXA				; save X
.eeb4	a2 b8		ldx #$b8		LDX	#$B8			; set the loop count
.eeb6					LAB_EEB6
.eeb6	ca		dex			DEX				; decrement the loop count
.eeb7	d0 fd		bne $eeb6		BNE	LAB_EEB6		; loop if more to do
.eeb9	aa		tax			TAX				; restore X
.eeba	60		rts			RTS
.eebb					LAB_EEBB
.eebb	a5 b4		lda $b4			LDA	LAB_B4		; get RS232 bit count
.eebd	f0 47		beq $ef06		BEQ	LAB_EF06		; if zero go setup next RS232 Tx byte and return
.eebf	30 3f		bmi $ef00		BMI	LAB_EF00		; if -ve go do stop bit(s)
.eec1	46 b6		lsr $b6			LSR	LAB_B6		; shift RS232 output byte buffer
.eec3	a2 00		ldx #$00		LDX	#$00			; set $00 for bit = 0
.eec5	90 01		bcc $eec8		BCC	LAB_EEC8		; branch if bit was 0
.eec7	ca		dex			DEX				; set $FF for bit = 1
.eec8					LAB_EEC8
.eec8	8a		txa			TXA				; copy bit to A
.eec9	45 bd		eor $bd			EOR	LAB_BD		; EOR with RS232 parity byte
.eecb	85 bd		sta $bd			STA	LAB_BD		; save RS232 parity byte
.eecd	c6 b4		dec $b4			DEC	LAB_B4		; decrement RS232 bit count
.eecf	f0 06		beq $eed7		BEQ	LAB_EED7		; if RS232 bit count now zero go do parity bit
.eed1					LAB_EED1
.eed1	8a		txa			TXA				; copy bit to A
.eed2	29 04		and #$04		AND	#$04			; mask 0000 0x00, RS232 Tx DATA bit
.eed4	85 b5		sta $b5			STA	LAB_B5		; save the next RS232 data bit to send
.eed6	60		rts			RTS
.eed7					LAB_EED7
.eed7	a9 20		lda #$20		LDA	#$20			; mask 00x0 0000, parity enable bit
.eed9	2c 94 02	bit $0294		BIT	LAB_0294		; test the pseudo 6551 command register
.eedc	f0 14		beq $eef2		BEQ	LAB_EEF2		; if parity disabled go ??
.eede	30 1c		bmi $eefc		BMI	LAB_EEFC		; if fixed mark or space parity go ??
.eee0	70 14		bvs $eef6		BVS	LAB_EEF6		; if even parity go ??
.eee2	a5 bd		lda $bd			LDA	LAB_BD		; get RS232 parity byte
.eee4	d0 01		bne $eee7		BNE	LAB_EEE7		; if parity not zero leave parity bit = 0
.eee6					LAB_EEE6
.eee6	ca		dex			DEX				; make parity bit = 1
.eee7					LAB_EEE7
.eee7	c6 b4		dec $b4			DEC	LAB_B4		; decrement RS232 bit count, 1 stop bit
.eee9	ad 93 02	lda $0293		LDA	LAB_0293		; get pseudo 6551 control register
.eeec	10 e3		bpl $eed1		BPL	LAB_EED1		; if 1 stop bit save parity bit and exit
.eeee	c6 b4		dec $b4			DEC	LAB_B4		; decrement RS232 bit count, 2 stop bits
.eef0	d0 df		bne $eed1		BNE	LAB_EED1		; save bit and exit, branch always
.eef2					LAB_EEF2
.eef2	e6 b4		inc $b4			INC	LAB_B4		; increment RS232 bit count, = -1 stop bit
.eef4	d0 f0		bne $eee6		BNE	LAB_EEE6		; set stop bit = 1 and exit
.eef6					LAB_EEF6
.eef6	a5 bd		lda $bd			LDA	LAB_BD		; get RS232 parity byte
.eef8	f0 ed		beq $eee7		BEQ	LAB_EEE7		; if parity zero leave parity bit = 0
.eefa	d0 ea		bne $eee6		BNE	LAB_EEE6		; else make parity bit = 1, branch always
.eefc					LAB_EEFC
.eefc	70 e9		bvs $eee7		BVS	LAB_EEE7		; if fixed space parity leave parity bit = 0
.eefe	50 e6		bvc $eee6		BVC	LAB_EEE6		; else fixed mark parity make parity bit = 1, branch always
.ef00					LAB_EF00
.ef00	e6 b4		inc $b4			INC	LAB_B4		; decrement RS232 bit count
.ef02	a2 ff		ldx #$ff		LDX	#$FF			; set stop bit = 1
.ef04	d0 cb		bne $eed1		BNE	LAB_EED1		; save stop bit and exit, branch always
.ef06					LAB_EF06
.ef06	ad 94 02	lda $0294		LDA	LAB_0294		; read the 6551 pseudo command register
.ef09	4a		lsr a			LSR				; handshake bit inot Cb
.ef0a	90 07		bcc $ef13		BCC	LAB_EF13		; if 3 line interface go ??
.ef0c	2c 01 dd	bit $dd01		BIT	LAB_DD01		; test VIA 2 DRB, RS232 port
.ef0f	10 1d		bpl $ef2e		BPL	LAB_EF2E		; if DSR = 0 set DSR signal not present and exit
.ef11	50 1e		bvc $ef31		BVC	LAB_EF31		; if CTS = 0 set CTS signal not present and exit
.ef13					LAB_EF13
.ef13	a9 00		lda #$00		LDA	#$00			; clear A
.ef15	85 bd		sta $bd			STA	LAB_BD		; clear the RS232 parity byte
.ef17	85 b5		sta $b5			STA	LAB_B5		; clear the RS232 next bit to send
.ef19	ae 98 02	ldx $0298		LDX	LAB_0298		; get the number of bits to be sent/received
.ef1c	86 b4		stx $b4			STX	LAB_B4		; set the RS232 bit count
.ef1e	ac 9d 02	ldy $029d		LDY	LAB_029D		; get the index to the Tx buffer start
.ef21	cc 9e 02	cpy $029e		CPY	LAB_029E		; compare it with the index to the Tx buffer end
.ef24	f0 13		beq $ef39		BEQ	LAB_EF39		; if all done go disable T?? interrupt and return
.ef26	b1 f9		lda ($f9),y		LDA	(LAB_F9),Y		; else get a byte from the buffer
.ef28	85 b6		sta $b6			STA	LAB_B6		; save it to the RS232 output byte buffer
.ef2a	ee 9d 02	inc $029d		INC	LAB_029D		; increment the index to the Tx buffer start
.ef2d	60		rts			RTS
.ef2e					LAB_EF2E
.ef2e	a9 40		lda #$40		LDA	#$40			; set DSR signal not present
>ef30	2c					.byte	$2C			; makes next line BIT LAB_xxxx
.ef31					LAB_EF31
.ef31	a9 10		lda #$10		LDA	#$10			; set CTS signal not present
.ef33	0d 97 02	ora $0297		ORA	LAB_0297		; OR it with the RS232 status register
.ef36	8d 97 02	sta $0297		STA	LAB_0297		; save the RS232 status register
.ef39					LAB_EF39
.ef39	a9 01		lda #$01		LDA	#$01			; disable timer A interrupt
.ef3b					LAB_EF3B
.ef3b	8d 0d dd	sta $dd0d		STA	LAB_DD0D		; save VIA 2 ICR
.ef3e	4d a1 02	eor $02a1		EOR	LAB_02A1		; EOR with the RS-232 interrupt enable byte
.ef41	09 80		ora #$80		ORA	#$80			; set the interrupts enable bit
.ef43	8d a1 02	sta $02a1		STA	LAB_02A1		; save the RS-232 interrupt enable byte
.ef46	8d 0d dd	sta $dd0d		STA	LAB_DD0D		; save VIA 2 ICR
.ef49	60		rts			RTS
.ef4a					LAB_EF4A
.ef4a	a2 09		ldx #$09		LDX	#$09			; set bit count to 9, 8 data + 1 stop bit
.ef4c	a9 20		lda #$20		LDA	#$20			; mask for 8/7 data bits
.ef4e	2c 93 02	bit $0293		BIT	LAB_0293		; test pseudo 6551 control register
.ef51	f0 01		beq $ef54		BEQ	LAB_EF54		; branch if 8 bits
.ef53	ca		dex			DEX				; else decrement count for 7 data bits
.ef54					LAB_EF54
.ef54	50 02		bvc $ef58		BVC	LAB_EF58		; branch if 7 bits
.ef56	ca		dex			DEX				; else decrement count ..
.ef57	ca		dex			DEX				; .. for 5 data bits
.ef58					LAB_EF58
.ef58	60		rts			RTS
.ef59					LAB_EF59
.ef59	a6 a9		ldx $a9			LDX	LAB_A9		; get start bit check flag
.ef5b	d0 33		bne $ef90		BNE	LAB_EF90		; if no start bit received go ??
.ef5d	c6 a8		dec $a8			DEC	LAB_A8		; decrement receiver bit count in
.ef5f	f0 36		beq $ef97		BEQ	LAB_EF97		; if the byte is complete go add it to the buffer
.ef61	30 0d		bmi $ef70		BMI	LAB_EF70		;.
.ef63	a5 a7		lda $a7			LDA	LAB_A7		; get the RS232 received data bit
.ef65	45 ab		eor $ab			EOR	LAB_AB		; EOR with the receiver parity bit
.ef67	85 ab		sta $ab			STA	LAB_AB		; save the receiver parity bit
.ef69	46 a7		lsr $a7			LSR	LAB_A7		; shift the RS232 received data bit
.ef6b	66 aa		ror $aa			ROR	LAB_AA		;.
.ef6d					LAB_EF6D
.ef6d	60		rts			RTS
.ef6e					LAB_EF6E
.ef6e	c6 a8		dec $a8			DEC	LAB_A8		; decrement receiver bit count in
.ef70					LAB_EF70
.ef70	a5 a7		lda $a7			LDA	LAB_A7		; get the RS232 received data bit
.ef72	f0 67		beq $efdb		BEQ	LAB_EFDB		;.
.ef74	ad 93 02	lda $0293		LDA	LAB_0293		; get pseudo 6551 control register
.ef77	0a		asl a			ASL				; shift the stop bit flag to Cb
.ef78	a9 01		lda #$01		LDA	#$01			; + 1
.ef7a	65 a8		adc $a8			ADC	LAB_A8		; add receiver bit count in
.ef7c	d0 ef		bne $ef6d		BNE	LAB_EF6D		; exit, branch always
.ef7e					LAB_EF7E
.ef7e	a9 90		lda #$90		LDA	#$90			; enable FLAG interrupt
.ef80	8d 0d dd	sta $dd0d		STA	LAB_DD0D		; save VIA 2 ICR
.ef83	0d a1 02	ora $02a1		ORA	LAB_02A1		; OR with the RS-232 interrupt enable byte
.ef86	8d a1 02	sta $02a1		STA	LAB_02A1		; save the RS-232 interrupt enable byte
.ef89	85 a9		sta $a9			STA	LAB_A9		; set start bit check flag, set no start bit received
.ef8b	a9 02		lda #$02		LDA	#$02			; disable timer B interrupt
.ef8d	4c 3b ef	jmp $ef3b		JMP	LAB_EF3B		; set VIA 2 ICR from A and return
.ef90					LAB_EF90
.ef90	a5 a7		lda $a7			LDA	LAB_A7		; get the RS232 received data bit
.ef92	d0 ea		bne $ef7e		BNE	LAB_EF7E		; if ?? go setup to receive an RS232 bit and return
.ef94	4c d3 e4	jmp $e4d3		JMP	LAB_E4D3		; flag the RS232 start bit and set the parity
.ef97					LAB_EF97
.ef97	ac 9b 02	ldy $029b		LDY	LAB_029B		; get index to Rx buffer end
.ef9a	c8		iny			INY				; increment index
.ef9b	cc 9c 02	cpy $029c		CPY	LAB_029C		; compare with index to Rx buffer start
.ef9e	f0 2a		beq $efca		BEQ	LAB_EFCA		; if buffer full go do Rx overrun error
.efa0	8c 9b 02	sty $029b		STY	LAB_029B		; save index to Rx buffer end
.efa3	88		dey			DEY				; decrement index
.efa4	a5 aa		lda $aa			LDA	LAB_AA		; get assembled byte
.efa6	ae 98 02	ldx $0298		LDX	LAB_0298		; get bit count
.efa9					LAB_EFA9
.efa9	e0 09		cpx #$09		CPX	#$09			; compare with byte + stop
.efab	f0 04		beq $efb1		BEQ	LAB_EFB1		; branch if all nine bits received
.efad	4a		lsr a			LSR				; else shift byte
.efae	e8		inx			INX				; increment bit count
.efaf	d0 f8		bne $efa9		BNE	LAB_EFA9		; loop, branch always
.efb1					LAB_EFB1
.efb1	91 f7		sta ($f7),y		STA	(LAB_F7),Y		; save received byte to Rx buffer
.efb3	a9 20		lda #$20		LDA	#$20			; mask 00x0 0000, parity enable bit
.efb5	2c 94 02	bit $0294		BIT	LAB_0294		; test the pseudo 6551 command register
.efb8	f0 b4		beq $ef6e		BEQ	LAB_EF6E		; branch if parity disabled
.efba	30 b1		bmi $ef6d		BMI	LAB_EF6D		; branch if mark or space parity
.efbc	a5 a7		lda $a7			LDA	LAB_A7		; get the RS232 received data bit
.efbe	45 ab		eor $ab			EOR	LAB_AB		; EOR with the receiver parity bit
.efc0	f0 03		beq $efc5		BEQ	LAB_EFC5		;.
.efc2	70 a9		bvs $ef6d		BVS	LAB_EF6D		; if ?? just exit
>efc4	2c					.byte	$2C			; makes next line BIT LAB_xxxx
.efc5					LAB_EFC5
.efc5	50 a6		bvc $ef6d		BVC	$EF6D			; if ?? just exit
.efc7	a9 01		lda #$01		LDA	#$01			; set Rx parity error
>efc9	2c					.byte	$2C			; makes next line BIT LAB_xxxx
.efca					LAB_EFCA
.efca	a9 04		lda #$04		LDA	#$04			; set Rx overrun error
>efcc	2c					.byte	$2C			; makes next line BIT LAB_80A9
.efcd					LAB_EFCD
.efcd	a9 80		lda #$80		LDA	#$80			; set Rx break error
>efcf	2c					.byte	$2C			; makes next line BIT LAB_02A9
.efd0					LAB_EFD0
.efd0	a9 02		lda #$02		LDA	#$02			; set Rx frame error
.efd2	0d 97 02	ora $0297		ORA	LAB_0297		; OR it with the RS232 status byte
.efd5	8d 97 02	sta $0297		STA	LAB_0297		; save the RS232 status byte
.efd8	4c 7e ef	jmp $ef7e		JMP	LAB_EF7E		; setup to receive an RS232 bit and return
.efdb					LAB_EFDB
.efdb	a5 aa		lda $aa			LDA	LAB_AA		;.
.efdd	d0 f1		bne $efd0		BNE	LAB_EFD0		; if ?? do frame error
.efdf	f0 ec		beq $efcd		BEQ	LAB_EFCD		; else do break error, branch always
.efe1					LAB_EFE1
.efe1	85 9a		sta $9a			STA	LAB_9A		; save the output device number
.efe3	ad 94 02	lda $0294		LDA	LAB_0294		; read the pseudo 6551 command register
.efe6	4a		lsr a			LSR				; shift handshake bit to carry
.efe7	90 29		bcc $f012		BCC	LAB_F012		; if 3 line interface go ??
.efe9	a9 02		lda #$02		LDA	#$02			; mask 0000 00x0, RTS out
.efeb	2c 01 dd	bit $dd01		BIT	LAB_DD01		; test VIA 2 DRB, RS232 port
.efee	10 1d		bpl $f00d		BPL	LAB_F00D		; if DSR = 0 set DSR not present and exit
.eff0	d0 20		bne $f012		BNE	LAB_F012		; if RTS = 1 just exit
.eff2					LAB_EFF2
.eff2	ad a1 02	lda $02a1		LDA	LAB_02A1		; get the RS-232 interrupt enable byte
.eff5	29 02		and #$02		AND	#$02			; mask 0000 00x0, timer B interrupt
.eff7	d0 f9		bne $eff2		BNE	LAB_EFF2		; loop while the timer B interrupt is enebled
.eff9					LAB_EFF9
.eff9	2c 01 dd	bit $dd01		BIT	LAB_DD01		; test VIA 2 DRB, RS232 port
.effc	70 fb		bvs $eff9		BVS	LAB_EFF9		; loop while CTS high
.effe	ad 01 dd	lda $dd01		LDA	LAB_DD01		; read VIA 2 DRB, RS232 port
.f001	09 02		ora #$02		ORA	#$02			; mask xxxx xx1x, set RTS high
.f003	8d 01 dd	sta $dd01		STA	LAB_DD01		; save VIA 2 DRB, RS232 port
.f006					LAB_F006
.f006	2c 01 dd	bit $dd01		BIT	LAB_DD01		; test VIA 2 DRB, RS232 port
.f009	70 07		bvs $f012		BVS	LAB_F012		; exit if CTS high
.f00b	30 f9		bmi $f006		BMI	LAB_F006		; loop while DSR high
.f00d					LAB_F00D
.f00d	a9 40		lda #$40		LDA	#$40			; set DSR signal not present
.f00f	8d 97 02	sta $0297		STA	LAB_0297		; save the RS232 status register
.f012					LAB_F012
.f012	18		clc			CLC				; flag ok
.f013	60		rts			RTS
.f014					LAB_F014
.f014	20 28 f0	jsr $f028		JSR	LAB_F028		; setup for RS232 transmit
.f017					LAB_F017
.f017	ac 9e 02	ldy $029e		LDY	LAB_029E		; get index to Tx buffer end
.f01a	c8		iny			INY				; + 1
.f01b	cc 9d 02	cpy $029d		CPY	LAB_029D		; compare with index to Tx buffer start
.f01e	f0 f4		beq $f014		BEQ	LAB_F014		; loop while buffer full
.f020	8c 9e 02	sty $029e		STY	LAB_029E		; set index to Tx buffer end
.f023	88		dey			DEY				; index to available buffer byte
.f024	a5 9e		lda $9e			LDA	LAB_9E		; read the RS232 character buffer
.f026	91 f9		sta ($f9),y		STA	(LAB_F9),Y		; save the byte to the buffer
.f028					LAB_F028
.f028	ad a1 02	lda $02a1		LDA	LAB_02A1		; get the RS-232 interrupt enable byte
.f02b	4a		lsr a			LSR				; shift the enable bit to Cb
.f02c	b0 1e		bcs $f04c		BCS	LAB_F04C		; if interrupts are enabled just exit
.f02e	a9 10		lda #$10		LDA	#$10			; start timer A
.f030	8d 0e dd	sta $dd0e		STA	LAB_DD0E		; save VIA 2 CRA
.f033	ad 99 02	lda $0299		LDA	LAB_0299		; get the baud rate bit time low byte
.f036	8d 04 dd	sta $dd04		STA	LAB_DD04		; save VIA 2 timer A low byte
.f039	ad 9a 02	lda $029a		LDA	LAB_029A		; get the baud rate bit time high byte
.f03c	8d 05 dd	sta $dd05		STA	LAB_DD05		; save VIA 2 timer A high byte
.f03f	a9 81		lda #$81		LDA	#$81			; enable timer A interrupt
.f041	20 3b ef	jsr $ef3b		JSR	LAB_EF3B		; set VIA 2 ICR from A
.f044	20 06 ef	jsr $ef06		JSR	LAB_EF06		; setup next RS232 Tx byte
.f047	a9 11		lda #$11		LDA	#$11			; load timer A, start timer A
.f049	8d 0e dd	sta $dd0e		STA	LAB_DD0E		; save VIA 2 CRA
.f04c					LAB_F04C
.f04c	60		rts			RTS
.f04d					LAB_F04D
.f04d	85 99		sta $99			STA	LAB_99		; save the input device number
.f04f	ad 94 02	lda $0294		LDA	LAB_0294		; get pseudo 6551 command register
.f052	4a		lsr a			LSR				; shift the handshake bit to Cb
.f053	90 28		bcc $f07d		BCC	LAB_F07D		; if 3 line interface go ??
.f055	29 08		and #$08		AND	#$08			; mask the duplex bit, pseudo 6551 command is >> 1
.f057	f0 24		beq $f07d		BEQ	LAB_F07D		; if full duplex go ??
.f059	a9 02		lda #$02		LDA	#$02			; mask 0000 00x0, RTS out
.f05b	2c 01 dd	bit $dd01		BIT	LAB_DD01		; test VIA 2 DRB, RS232 port
.f05e	10 ad		bpl $f00d		BPL	LAB_F00D		; if DSR = 0 set no DSR and exit
.f060	f0 22		beq $f084		BEQ	LAB_F084		; if RTS = 0 just exit
.f062					LAB_F062
.f062	ad a1 02	lda $02a1		LDA	LAB_02A1		; get the RS-232 interrupt enable byte
.f065	4a		lsr a			LSR				; shift the timer A interrupt enable bit to Cb
.f066	b0 fa		bcs $f062		BCS	LAB_F062		; loop while the timer A interrupt is enabled
.f068	ad 01 dd	lda $dd01		LDA	LAB_DD01		; read VIA 2 DRB, RS232 port
.f06b	29 fd		and #$fd		AND	#$FD			; mask xxxx xx0x, clear RTS out
.f06d	8d 01 dd	sta $dd01		STA	LAB_DD01		; save VIA 2 DRB, RS232 port
.f070					LAB_F070
.f070	ad 01 dd	lda $dd01		LDA	LAB_DD01		; read VIA 2 DRB, RS232 port
.f073	29 04		and #$04		AND	#$04			; mask xxxx x1xx, DTR in
.f075	f0 f9		beq $f070		BEQ	LAB_F070		; loop while DTR low
.f077					LAB_F077
.f077	a9 90		lda #$90		LDA	#$90			; enable the FLAG interrupt
.f079	18		clc			CLC				; flag ok
.f07a	4c 3b ef	jmp $ef3b		JMP	LAB_EF3B		; set VIA 2 ICR from A and return
.f07d					LAB_F07D
.f07d	ad a1 02	lda $02a1		LDA	LAB_02A1		; get the RS-232 interrupt enable byte
.f080	29 12		and #$12		AND	#$12			; mask 000x 00x0
.f082	f0 f3		beq $f077		BEQ	LAB_F077		; if FLAG or timer B bits set go enable the FLAG inetrrupt
.f084					LAB_F084
.f084	18		clc			CLC				; flag ok
.f085	60		rts			RTS
.f086					LAB_F086
.f086	ad 97 02	lda $0297		LDA	LAB_0297		; get the RS232 status register
.f089	ac 9c 02	ldy $029c		LDY	LAB_029C		; get index to Rx buffer start
.f08c	cc 9b 02	cpy $029b		CPY	LAB_029B		; compare with index to Rx buffer end
.f08f	f0 0b		beq $f09c		BEQ	LAB_F09C		; return null if buffer empty
.f091	29 f7		and #$f7		AND	#$F7			; clear the Rx buffer empty bit
.f093	8d 97 02	sta $0297		STA	LAB_0297		; save the RS232 status register
.f096	b1 f7		lda ($f7),y		LDA	(LAB_F7),Y		; get byte from Rx buffer
.f098	ee 9c 02	inc $029c		INC	LAB_029C		; increment index to Rx buffer start
.f09b	60		rts			RTS
.f09c					LAB_F09C
.f09c	09 08		ora #$08		ORA	#$08			; set the Rx buffer empty bit
.f09e	8d 97 02	sta $0297		STA	LAB_0297		; save the RS232 status register
.f0a1	a9 00		lda #$00		LDA	#$00			; return null
.f0a3	60		rts			RTS
.f0a4					LAB_F0A4
.f0a4	48		pha			PHA				; save A
.f0a5	ad a1 02	lda $02a1		LDA	LAB_02A1		; get the RS-232 interrupt enable byte
.f0a8	f0 11		beq $f0bb		BEQ	LAB_F0BB		; if no interrupts enabled just exit
.f0aa					LAB_F0AA
.f0aa	ad a1 02	lda $02a1		LDA	LAB_02A1		; get the RS-232 interrupt enable byte
.f0ad	29 03		and #$03		AND	#$03			; mask 0000 00xx, the error bits
.f0af	d0 f9		bne $f0aa		BNE	LAB_F0AA		; if there are errors loop
.f0b1	a9 10		lda #$10		LDA	#$10			; disable FLAG interrupt
.f0b3	8d 0d dd	sta $dd0d		STA	LAB_DD0D		; save VIA 2 ICR
.f0b6	a9 00		lda #$00		LDA	#$00			; clear A
.f0b8	8d a1 02	sta $02a1		STA	LAB_02A1		; clear the RS-232 interrupt enable byte
.f0bb					LAB_F0BB
.f0bb	68		pla			PLA				; restore A
.f0bc	60		rts			RTS
.f0bd					LAB_F0BD
>f0bd	0d 49 2f 4f 20 45 52 52			.text	$0D,"I/O ERROR ",'#'+$80
>f0c5	4f 52 20 a3
.f0c9					LAB_F0C9
>f0c9	0d 53 45 41 52 43 48 49			.text	$0D,"SEARCHING",' '+$80
>f0d1	4e 47 a0
.f0d4					LAB_F0D4
>f0d4	46 4f 52 a0				.text	"FOR",' '+$80
.f0d8					LAB_F0D8
>f0d8	0d 50 52 45 53 53 20 50			.text	$0D,"PRESS PLAY ON TAP",'E'+$80
>f0e0	4c 41 59 20 4f 4e 20 54 41 50 c5
.f0eb					LAB_F0EB
>f0eb	50 52 45 53 53 20 52 45			.text	"PRESS RECORD & PLAY ON TAP",'E'+$80
>f0f3	43 4f 52 44 20 26 20 50 4c 41 59 20 4f 4e 20 54
>f103	41 50 c5
.f106					LAB_F106
>f106	0d 4c 4f 41 44 49 4e c7			.text	$0D,"LOADIN",'G'+$80
.f10e					LAB_F10E
>f10e	0d 53 41 56 49 4e 47 a0			.text	$0D,"SAVING",' '+$80
.f116					LAB_F116
>f116	0d 56 45 52 49 46 59 49			.text	$0D,"VERIFYIN",'G'+$80
>f11e	4e c7
.f120					LAB_F120
>f120	0d 46 4f 55 4e 44 a0			.text	$0D,"FOUND",' '+$80
.f127					LAB_F127
>f127	0d 4f 4b 8d				.text	$0D,"OK",$0D+$80
.f12b					LAB_F12B
.f12b	24 9d		bit $9d			BIT	LAB_9D		; test message mode flag
.f12d	10 0d		bpl $f13c		BPL	LAB_F13C		; exit if control messages off
.f12f					LAB_F12F
.f12f	b9 bd f0	lda $f0bd,y		LDA	LAB_F0BD,Y		; get byte from message table
.f132	08		php			PHP				; save status
.f133	29 7f		and #$7f		AND	#$7F			; clear b7
.f135	20 d2 ff	jsr $ffd2		JSR	LAB_FFD2		; output character to channel
.f138	c8		iny			INY				; increment index
.f139	28		plp			PLP				; restore status
.f13a	10 f3		bpl $f12f		BPL	LAB_F12F		; loop if not end of message
.f13c					LAB_F13C
.f13c	18		clc			CLC				;.
.f13d	60		rts			RTS
.f13e					LAB_F13E
.f13e	a5 99		lda $99			LDA	LAB_99		; get the input device number
.f140	d0 08		bne $f14a		BNE	LAB_F14A		; if not the keyboard go handle other devices
.f142	a5 c6		lda $c6			LDA	LAB_C6		; get the keyboard buffer index
.f144	f0 0f		beq $f155		BEQ	LAB_F155		; if the buffer is empty go flag no byte and return
.f146	78		sei			SEI				; disable the interrupts
.f147	4c b4 e5	jmp $e5b4		JMP	LAB_E5B4		; get input from the keyboard buffer and return
.f14a					LAB_F14A
.f14a	c9 02		cmp #$02		CMP	#$02			; compare the device with the RS232 device
.f14c	d0 18		bne $f166		BNE	LAB_F166		; if not the RS232 device go ??
.f14e					LAB_F14E
.f14e	84 97		sty $97			STY	LAB_97		; save Y
.f150	20 86 f0	jsr $f086		JSR	LAB_F086		; get a byte from RS232 buffer
.f153	a4 97		ldy $97			LDY	LAB_97		; restore Y
.f155					LAB_F155
.f155	18		clc			CLC				; flag no error
.f156	60		rts			RTS
.f157					LAB_F157
.f157	a5 99		lda $99			LDA	LAB_99		; get the input device number
.f159	d0 0b		bne $f166		BNE	LAB_F166		; if not the keyboard continue
.f15b	a5 d3		lda $d3			LDA	LAB_D3		; get the cursor column
.f15d	85 ca		sta $ca			STA	LAB_CA		; set the input cursor column
.f15f	a5 d6		lda $d6			LDA	LAB_D6		; get the cursor row
.f161	85 c9		sta $c9			STA	LAB_C9		; set the input cursor row
.f163	4c 32 e6	jmp $e632		JMP	LAB_E632		; input from screen or keyboard
.f166					LAB_F166
.f166	c9 03		cmp #$03		CMP	#$03			; compare device number with screen
.f168	d0 09		bne $f173		BNE	LAB_F173		; if not screen continue
.f16a	85 d0		sta $d0			STA	LAB_D0		; input from keyboard or screen, $xx = screen,
.f16c	a5 d5		lda $d5			LDA	LAB_D5		; get current screen line length
.f16e	85 c8		sta $c8			STA	LAB_C8		; save input [EOL] pointer
.f170	4c 32 e6	jmp $e632		JMP	LAB_E632		; input from screen or keyboard
.f173					LAB_F173
.f173	b0 38		bcs $f1ad		BCS	LAB_F1AD		; if input device > screen go do IEC devices
.f175	c9 02		cmp #$02		CMP	#$02			; compare the device with the RS232 device
.f177	f0 3f		beq $f1b8		BEQ	LAB_F1B8		; if RS232 device go get a byte from the RS232 device
.f179	86 97		stx $97			STX	LAB_97		; save X
.f17b	20 99 f1	jsr $f199		JSR	LAB_F199		; get a byte from tape
.f17e	b0 16		bcs $f196		BCS	LAB_F196		; if error just exit
.f180	48		pha			PHA				; save the byte
.f181	20 99 f1	jsr $f199		JSR	LAB_F199		; get the next byte from tape
.f184	b0 0d		bcs $f193		BCS	LAB_F193		; if error just exit
.f186	d0 05		bne $f18d		BNE	LAB_F18D		; if end reached ??
.f188	a9 40		lda #$40		LDA	#$40			; set EOI
.f18a	20 1c fe	jsr $fe1c		JSR	LAB_FE1C		; OR into the serial status byte
.f18d					LAB_F18D
.f18d	c6 a6		dec $a6			DEC	LAB_A6		; decrement tape buffer index
.f18f	a6 97		ldx $97			LDX	LAB_97		; restore X
.f191	68		pla			PLA				; restore the saved byte
.f192	60		rts			RTS
.f193					LAB_F193
.f193	aa		tax			TAX				; copy the error byte
.f194	68		pla			PLA				; dump the saved byte
.f195	8a		txa			TXA				; restore error byte
.f196					LAB_F196
.f196	a6 97		ldx $97			LDX	LAB_97		; restore X
.f198	60		rts			RTS
.f199					LAB_F199
.f199	20 0d f8	jsr $f80d		JSR	LAB_F80D		; bump tape pointer
.f19c	d0 0b		bne $f1a9		BNE	LAB_F1A9		; if not end get next byte and exit
.f19e	20 41 f8	jsr $f841		JSR	LAB_F841		; initiate tape read
.f1a1	b0 11		bcs $f1b4		BCS	LAB_F1B4		; exit if error flagged
.f1a3	a9 00		lda #$00		LDA	#$00			; clear A
.f1a5	85 a6		sta $a6			STA	LAB_A6		; clear tape buffer index
.f1a7	f0 f0		beq $f199		BEQ	LAB_F199		; loop, branch always
.f1a9					LAB_F1A9
.f1a9	b1 b2		lda ($b2),y		LDA	(LAB_B2),Y		; get next byte from buffer
.f1ab	18		clc			CLC				; flag no error
.f1ac	60		rts			RTS
.f1ad					LAB_F1AD
.f1ad	a5 90		lda $90			LDA	LAB_90		; get the serial status byte
.f1af	f0 04		beq $f1b5		BEQ	LAB_F1B5		; if no errors flagged go input byte and return
.f1b1					LAB_F1B1
.f1b1	a9 0d		lda #$0d		LDA	#$0D			; else return [EOL]
.f1b3					LAB_F1B3
.f1b3	18		clc			CLC				; flag no error
.f1b4					LAB_F1B4
.f1b4	60		rts			RTS
.f1b5					LAB_F1B5
.f1b5	4c 13 ee	jmp $ee13		JMP	LAB_EE13		; input byte from serial bus and return
.f1b8					LAB_F1B8
.f1b8	20 4e f1	jsr $f14e		JSR	LAB_F14E		; get byte from RS232 device
.f1bb	b0 f7		bcs $f1b4		BCS	LAB_F1B4		; branch if error, this doesn't get taken as the last
.f1bd	c9 00		cmp #$00		CMP	#$00			; compare with null
.f1bf	d0 f2		bne $f1b3		BNE	LAB_F1B3		; exit if not null
.f1c1	ad 97 02	lda $0297		LDA	LAB_0297		; get the RS232 status register
.f1c4	29 60		and #$60		AND	#$60			; mask 0xx0 0000, DSR detected and ??
.f1c6	d0 e9		bne $f1b1		BNE	LAB_F1B1		; if ?? return null
.f1c8	f0 ee		beq $f1b8		BEQ	LAB_F1B8		; else loop, branch always
.f1ca					LAB_F1CA
.f1ca	48		pha			PHA				; save the character to output
.f1cb	a5 9a		lda $9a			LDA	LAB_9A		; get the output device number
.f1cd	c9 03		cmp #$03		CMP	#$03			; compare the output device with the screen
.f1cf	d0 04		bne $f1d5		BNE	LAB_F1D5		; if not the screen go ??
.f1d1	68		pla			PLA				; else restore the output character
.f1d2	4c 16 e7	jmp $e716		JMP	LAB_E716		; go output the character to the screen
.f1d5					LAB_F1D5
.f1d5	90 04		bcc $f1db		BCC	LAB_F1DB		; if < screen go ??
.f1d7	68		pla			PLA				; else restore the output character
.f1d8	4c dd ed	jmp $eddd		JMP	LAB_EDDD		; go output the character to the serial bus
.f1db					LAB_F1DB
.f1db	4a		lsr a			LSR				; shift b0 of the device into Cb
.f1dc	68		pla			PLA				; restore the output character
.f1dd					LAB_F1DD
.f1dd	85 9e		sta $9e			STA	LAB_9E		; save the character to the character buffer
.f1df	8a		txa			TXA				; copy X
.f1e0	48		pha			PHA				; save X
.f1e1	98		tya			TYA				; copy Y
.f1e2	48		pha			PHA				; save Y
.f1e3	90 23		bcc $f208		BCC	LAB_F208		; if Cb is clear it must be the RS232 device
.f1e5	20 0d f8	jsr $f80d		JSR	LAB_F80D		; bump the tape pointer
.f1e8	d0 0e		bne $f1f8		BNE	LAB_F1F8		; if not end save next byte and exit
.f1ea	20 64 f8	jsr $f864		JSR	LAB_F864		; initiate tape write
.f1ed	b0 0e		bcs $f1fd		BCS	LAB_F1FD		; exit if error
.f1ef	a9 02		lda #$02		LDA	#$02			; set data block type ??
.f1f1	a0 00		ldy #$00		LDY	#$00			; clear index
.f1f3	91 b2		sta ($b2),y		STA	(LAB_B2),Y		; save type to buffer ??
.f1f5	c8		iny			INY				; increment index
.f1f6	84 a6		sty $a6			STY	LAB_A6		; save tape buffer index
.f1f8					LAB_F1F8
.f1f8	a5 9e		lda $9e			LDA	LAB_9E		; restore character from character buffer
.f1fa	91 b2		sta ($b2),y		STA	(LAB_B2),Y		; save to buffer
.f1fc					LAB_F1FC
.f1fc	18		clc			CLC				; flag no error
.f1fd					LAB_F1FD
.f1fd	68		pla			PLA				; pull Y
.f1fe	a8		tay			TAY				; restore Y
.f1ff	68		pla			PLA				; pull X
.f200	aa		tax			TAX				; restore X
.f201	a5 9e		lda $9e			LDA	LAB_9E		; get the character from the character buffer
.f203	90 02		bcc $f207		BCC	LAB_F207		; exit if no error
.f205	a9 00		lda #$00		LDA	#$00			; else clear A
.f207					LAB_F207
.f207	60		rts			RTS
.f208					LAB_F208
.f208	20 17 f0	jsr $f017		JSR	LAB_F017		; send byte to the RS232 buffer, no setup
.f20b	4c fc f1	jmp $f1fc		JMP	LAB_F1FC		; do no error exit
.f20e					LAB_F20E
.f20e	20 0f f3	jsr $f30f		JSR	LAB_F30F		; find a file
.f211	f0 03		beq $f216		BEQ	LAB_F216		; if the file is open continue
.f213	4c 01 f7	jmp $f701		JMP	LAB_F701		; else do 'file not open' error and return
.f216					LAB_F216
.f216	20 1f f3	jsr $f31f		JSR	LAB_F31F		; set file details from table,X
.f219	a5 ba		lda $ba			LDA	LAB_BA		; get the device number
.f21b	f0 16		beq $f233		BEQ	LAB_F233		; if the device was the keyboard save the device #, flag
.f21d	c9 03		cmp #$03		CMP	#$03			; compare the device number with the screen
.f21f	f0 12		beq $f233		BEQ	LAB_F233		; if the device was the screen save the device #, flag ok
.f221	b0 14		bcs $f237		BCS	LAB_F237		; if the device was a serial bus device go ??
.f223	c9 02		cmp #$02		CMP	#$02			; else compare the device with the RS232 device
.f225	d0 03		bne $f22a		BNE	LAB_F22A		; if not the RS232 device continue
.f227	4c 4d f0	jmp $f04d		JMP	LAB_F04D		; else go get input from the RS232 buffer and return
.f22a					LAB_F22A
.f22a	a6 b9		ldx $b9			LDX	LAB_B9		; get the secondary address
.f22c	e0 60		cpx #$60		CPX	#$60			;.
.f22e	f0 03		beq $f233		BEQ	LAB_F233		;.
.f230	4c 0a f7	jmp $f70a		JMP	LAB_F70A		; go do 'not input file' error and return
.f233					LAB_F233
.f233	85 99		sta $99			STA	LAB_99		; save the input device number
.f235	18		clc			CLC				; flag ok
.f236	60		rts			RTS
.f237					LAB_F237
.f237	aa		tax			TAX				; copy device number to X
.f238	20 09 ed	jsr $ed09		JSR	LAB_ED09		; command serial bus device to TALK
.f23b	a5 b9		lda $b9			LDA	LAB_B9		; get the secondary address
.f23d	10 06		bpl $f245		BPL	LAB_F245		;.
.f23f	20 cc ed	jsr $edcc		JSR	LAB_EDCC		; wait for the serial bus end after send
.f242	4c 48 f2	jmp $f248		JMP	LAB_F248		;.
.f245					LAB_F245
.f245	20 c7 ed	jsr $edc7		JSR	LAB_EDC7		; send secondary address after TALK
.f248					LAB_F248
.f248	8a		txa			TXA				; copy device back to A
.f249	24 90		bit $90			BIT	LAB_90		; test the serial status byte
.f24b	10 e6		bpl $f233		BPL	LAB_F233		; if device present save device number and exit
.f24d	4c 07 f7	jmp $f707		JMP	LAB_F707		; do 'device not present' error and return
.f250					LAB_F250
.f250	20 0f f3	jsr $f30f		JSR	LAB_F30F		; find a file
.f253	f0 03		beq $f258		BEQ	LAB_F258		; if file found continue
.f255	4c 01 f7	jmp $f701		JMP	LAB_F701		; else do 'file not open' error and return
.f258					LAB_F258
.f258	20 1f f3	jsr $f31f		JSR	LAB_F31F		; set file details from table,X
.f25b	a5 ba		lda $ba			LDA	LAB_BA		; get the device number
.f25d	d0 03		bne $f262		BNE	LAB_F262		; if the device is not the keyboard go ??
.f25f					LAB_F25F
.f25f	4c 0d f7	jmp $f70d		JMP	LAB_F70D		; go do 'not output file' error and return
.f262					LAB_F262
.f262	c9 03		cmp #$03		CMP	#$03			; compare the device with the screen
.f264	f0 0f		beq $f275		BEQ	LAB_F275		; if the device is the screen go save output the output
.f266	b0 11		bcs $f279		BCS	LAB_F279		; if > screen then go handle a serial bus device
.f268	c9 02		cmp #$02		CMP	#$02			; compare the device with the RS232 device
.f26a	d0 03		bne $f26f		BNE	LAB_F26F		; if not the RS232 device then it must be the tape device
.f26c	4c e1 ef	jmp $efe1		JMP	LAB_EFE1		; else go open RS232 channel for output
.f26f					LAB_F26F
.f26f	a6 b9		ldx $b9			LDX	LAB_B9		; get the secondary address
.f271	e0 60		cpx #$60		CPX	#$60			;.
.f273	f0 ea		beq $f25f		BEQ	LAB_F25F		; if ?? do not output file error and return
.f275					LAB_F275
.f275	85 9a		sta $9a			STA	LAB_9A		; save the output device number
.f277	18		clc			CLC				; flag ok
.f278	60		rts			RTS
.f279					LAB_F279
.f279	aa		tax			TAX				; copy the device number
.f27a	20 0c ed	jsr $ed0c		JSR	LAB_ED0C		; command devices on the serial bus to LISTEN
.f27d	a5 b9		lda $b9			LDA	LAB_B9		; get the secondary address
.f27f	10 05		bpl $f286		BPL	LAB_F286		; if address to send go ??
.f281	20 be ed	jsr $edbe		JSR	LAB_EDBE		; else set serial ATN high
.f284	d0 03		bne $f289		BNE	LAB_F289		; go ??, branch always
.f286					LAB_F286
.f286	20 b9 ed	jsr $edb9		JSR	LAB_EDB9		; send secondary address after LISTEN
.f289					LAB_F289
.f289	8a		txa			TXA				; copy device number back to A
.f28a	24 90		bit $90			BIT	LAB_90		; test the serial status byte
.f28c	10 e7		bpl $f275		BPL	LAB_F275		; if the device is present go save the output device number
.f28e	4c 07 f7	jmp $f707		JMP	LAB_F707		; else do 'device not present error' and return
.f291					LAB_F291
.f291	20 14 f3	jsr $f314		JSR	LAB_F314		; find file A
.f294	f0 02		beq $f298		BEQ	LAB_F298		; if file found go close it
.f296	18		clc			CLC				; else the file was closed so just flag ok
.f297	60		rts			RTS
.f298					LAB_F298
.f298	20 1f f3	jsr $f31f		JSR	LAB_F31F		; set file details from table,X
.f29b	8a		txa			TXA				; copy file index to A
.f29c	48		pha			PHA				; save file index
.f29d	a5 ba		lda $ba			LDA	LAB_BA		; get the device number
.f29f	f0 50		beq $f2f1		BEQ	LAB_F2F1		; if it is the keyboard go restore the index and close the
.f2a1	c9 03		cmp #$03		CMP	#$03			; compare the device number with the screen
.f2a3	f0 4c		beq $f2f1		BEQ	LAB_F2F1		; if it is the screen go restore the index and close the
.f2a5	b0 47		bcs $f2ee		BCS	LAB_F2EE		; if > screen go do serial bus device close
.f2a7	c9 02		cmp #$02		CMP	#$02			; compare the device with the RS232 device
.f2a9	d0 1d		bne $f2c8		BNE	LAB_F2C8		; if not the RS232 device go ??
.f2ab	68		pla			PLA				; restore file index
.f2ac	20 f2 f2	jsr $f2f2		JSR	LAB_F2F2		; close file index X
.f2af	20 83 f4	jsr $f483		JSR	LAB_F483		; initialise RS232 output
.f2b2	20 27 fe	jsr $fe27		JSR	LAB_FE27		; read the top of memory
.f2b5	a5 f8		lda $f8			LDA	LAB_F8		; get the RS232 input buffer pointer high byte
.f2b7	f0 01		beq $f2ba		BEQ	LAB_F2BA		; if no RS232 input buffer go ??
.f2b9	c8		iny			INY				; else reclaim RS232 input buffer memory
.f2ba					LAB_F2BA
.f2ba	a5 fa		lda $fa			LDA	LAB_FA		; get the RS232 output buffer pointer high byte
.f2bc	f0 01		beq $f2bf		BEQ	LAB_F2BF		; if no RS232 output buffer skip the reclaim
.f2be	c8		iny			INY				; else reclaim the RS232 output buffer memory
.f2bf					LAB_F2BF
.f2bf	a9 00		lda #$00		LDA	#$00			; clear A
.f2c1	85 f8		sta $f8			STA	LAB_F8		; clear the RS232 input buffer pointer high byte
.f2c3	85 fa		sta $fa			STA	LAB_FA		; clear the RS232 output buffer pointer high byte
.f2c5	4c 7d f4	jmp $f47d		JMP	LAB_F47D		; go set the top of memory to F0xx
.f2c8					LAB_F2C8
.f2c8	a5 b9		lda $b9			LDA	LAB_B9		; get the secondary address
.f2ca	29 0f		and #$0f		AND	#$0F			; mask the device #
.f2cc	f0 23		beq $f2f1		BEQ	LAB_F2F1		; if ?? restore index and close file
.f2ce	20 d0 f7	jsr $f7d0		JSR	LAB_F7D0		; get tape buffer start pointer in XY
.f2d1	a9 00		lda #$00		LDA	#$00			; character $00
.f2d3	38		sec			SEC				; flag the tape device
.f2d4	20 dd f1	jsr $f1dd		JSR	LAB_F1DD		; output the character to the cassette or RS232 device
.f2d7	20 64 f8	jsr $f864		JSR	LAB_F864		; initiate tape write
.f2da	90 04		bcc $f2e0		BCC	LAB_F2E0		;.
.f2dc	68		pla			PLA				;.
.f2dd	a9 00		lda #$00		LDA	#$00			;.
.f2df	60		rts			RTS
.f2e0					LAB_F2E0
.f2e0	a5 b9		lda $b9			LDA	LAB_B9		; get the secondary address
.f2e2	c9 62		cmp #$62		CMP	#$62			;.
.f2e4	d0 0b		bne $f2f1		BNE	LAB_F2F1		; if not ?? restore index and close file
.f2e6	a9 05		lda #$05		LDA	#$05			; set logical end of the tape
.f2e8	20 6a f7	jsr $f76a		JSR	LAB_F76A		; write tape header
.f2eb	4c f1 f2	jmp $f2f1		JMP	LAB_F2F1		; restore index and close file
.f2ee					LAB_F2EE
.f2ee	20 42 f6	jsr $f642		JSR	LAB_F642		; close serial bus device
.f2f1					LAB_F2F1
.f2f1	68		pla			PLA				; restore file index
.f2f2					LAB_F2F2
.f2f2	aa		tax			TAX				; copy index to file to close
.f2f3	c6 98		dec $98			DEC	LAB_98		; decrement the open file count
.f2f5	e4 98		cpx $98			CPX	LAB_98		; compare the index with the open file count
.f2f7	f0 14		beq $f30d		BEQ	LAB_F30D		; exit if equal, last entry was closing file
.f2f9	a4 98		ldy $98			LDY	LAB_98		; get the open file count as index
.f2fb	b9 59 02	lda $0259,y		LDA	LAB_0259,Y		; get last+1 logical file number from logical file table
.f2fe	9d 59 02	sta $0259,x		STA	LAB_0259,X		; save logical file number over closed file
.f301	b9 63 02	lda $0263,y		LDA	LAB_0263,Y		; get last+1 device number from device number table
.f304	9d 63 02	sta $0263,x		STA	LAB_0263,X		; save device number over closed file
.f307	b9 6d 02	lda $026d,y		LDA	LAB_026D,Y		; get last+1 secondary address from secondary address table
.f30a	9d 6d 02	sta $026d,x		STA	LAB_026D,X		; save secondary address over closed file
.f30d					LAB_F30D
.f30d	18		clc			CLC				; flag ok
.f30e	60		rts			RTS
.f30f					LAB_F30F
.f30f	a9 00		lda #$00		LDA	#$00			; clear A
.f311	85 90		sta $90			STA	LAB_90		; clear the serial status byte
.f313	8a		txa			TXA				; copy the logical file number to A
.f314					LAB_F314
.f314	a6 98		ldx $98			LDX	LAB_98		; get the open file count
.f316					LAB_F316
.f316	ca		dex			DEX				; decrememnt the count to give the index
.f317	30 15		bmi $f32e		BMI	LAB_F32E		; if no files just exit
.f319	dd 59 02	cmp $0259,x		CMP	LAB_0259,X		; compare the logical file number with the table logical
.f31c	d0 f8		bne $f316		BNE	LAB_F316		; if no match go try again
.f31e	60		rts			RTS
.f31f					LAB_F31F
.f31f	bd 59 02	lda $0259,x		LDA	LAB_0259,X		; get logical file from logical file table
.f322	85 b8		sta $b8			STA	LAB_B8		; save the logical file
.f324	bd 63 02	lda $0263,x		LDA	LAB_0263,X		; get device number from device number table
.f327	85 ba		sta $ba			STA	LAB_BA		; save the device number
.f329	bd 6d 02	lda $026d,x		LDA	LAB_026D,X		; get secondary address from secondary address table
.f32c	85 b9		sta $b9			STA	LAB_B9		; save the secondary address
.f32e					LAB_F32E
.f32e	60		rts			RTS
.f32f					LAB_F32F
.f32f	a9 00		lda #$00		LDA	#$00			; clear A
.f331	85 98		sta $98			STA	LAB_98		; clear the open file count
.f333					LAB_F333
.f333	a2 03		ldx #$03		LDX	#$03			; set the screen device
.f335	e4 9a		cpx $9a			CPX	LAB_9A		; compare the screen with the output device number
.f337	b0 03		bcs $f33c		BCS	LAB_F33C		; if <= screen skip the serial bus unlisten
.f339	20 fe ed	jsr $edfe		JSR	LAB_EDFE		; else command the serial bus to UNLISTEN
.f33c					LAB_F33C
.f33c	e4 99		cpx $99			CPX	LAB_99		; compare the screen with the input device number
.f33e	b0 03		bcs $f343		BCS	LAB_F343		; if <= screen skip the serial bus untalk
.f340	20 ef ed	jsr $edef		JSR	LAB_EDEF		; else command the serial bus to UNTALK
.f343					LAB_F343
.f343	86 9a		stx $9a			STX	LAB_9A		; save the screen as the output device number
.f345	a9 00		lda #$00		LDA	#$00			; set the keyboard as the input device
.f347	85 99		sta $99			STA	LAB_99		; save the input device number
.f349	60		rts			RTS
.f34a					LAB_F34A
.f34a	a6 b8		ldx $b8			LDX	LAB_B8		; get the logical file
.f34c	d0 03		bne $f351		BNE	LAB_F351		; if there is a file continue
.f34e	4c 0a f7	jmp $f70a		JMP	LAB_F70A		; else do 'not input file error' and return
.f351					LAB_F351
.f351	20 0f f3	jsr $f30f		JSR	LAB_F30F		; find a file
.f354	d0 03		bne $f359		BNE	LAB_F359		; if file not found continue
.f356	4c fe f6	jmp $f6fe		JMP	LAB_F6FE		; else do 'file already open' error and return
.f359					LAB_F359
.f359	a6 98		ldx $98			LDX	LAB_98		; get the open file count
.f35b	e0 0a		cpx #$0a		CPX	#$0A			; compare it with the maximum + 1
.f35d	90 03		bcc $f362		BCC	LAB_F362		; if less than maximum + 1 go open the file
.f35f	4c fb f6	jmp $f6fb		JMP	LAB_F6FB		; else do 'too many files error' and return
.f362					LAB_F362
.f362	e6 98		inc $98			INC	LAB_98		; increment the open file count
.f364	a5 b8		lda $b8			LDA	LAB_B8		; get the logical file
.f366	9d 59 02	sta $0259,x		STA	LAB_0259,X		; save it to the logical file table
.f369	a5 b9		lda $b9			LDA	LAB_B9		; get the secondary address
.f36b	09 60		ora #$60		ORA	#$60			; OR with the OPEN CHANNEL command
.f36d	85 b9		sta $b9			STA	LAB_B9		; save the secondary address
.f36f	9d 6d 02	sta $026d,x		STA	LAB_026D,X		; save it to the secondary address table
.f372	a5 ba		lda $ba			LDA	LAB_BA		; get the device number
.f374	9d 63 02	sta $0263,x		STA	LAB_0263,X		; save it to the device number table
.f377	f0 5a		beq $f3d3		BEQ	LAB_F3D3		; if it is the keyboard go do the ok exit
.f379	c9 03		cmp #$03		CMP	#$03			; compare the device number with the screen
.f37b	f0 56		beq $f3d3		BEQ	LAB_F3D3		; if it is the screen go do the ok exit
.f37d	90 05		bcc $f384		BCC	LAB_F384		; if tape or RS232 device go ??
.f37f	20 d5 f3	jsr $f3d5		JSR	LAB_F3D5		; send the secondary address and filename
.f382	90 4f		bcc $f3d3		BCC	LAB_F3D3		; go do ok exit, branch always
.f384					LAB_F384
.f384	c9 02		cmp #$02		CMP	#$02			;.
.f386	d0 03		bne $f38b		BNE	LAB_F38B		;.
.f388	4c 09 f4	jmp $f409		JMP	LAB_F409		; go open RS232 device and return
.f38b					LAB_F38B
.f38b	20 d0 f7	jsr $f7d0		JSR	LAB_F7D0		; get tape buffer start pointer in XY
.f38e	b0 03		bcs $f393		BCS	LAB_F393		; if >= $0200 go ??
.f390	4c 13 f7	jmp $f713		JMP	LAB_F713		; else do 'illegal device number' and return
.f393					LAB_F393
.f393	a5 b9		lda $b9			LDA	LAB_B9		; get the secondary address
.f395	29 0f		and #$0f		AND	#$0F			;.
.f397	d0 1f		bne $f3b8		BNE	LAB_F3B8		;.
.f399	20 17 f8	jsr $f817		JSR	LAB_F817		; wait for PLAY
.f39c	b0 36		bcs $f3d4		BCS	LAB_F3D4		; exit if STOP was pressed
.f39e	20 af f5	jsr $f5af		JSR	LAB_F5AF		; print "Searching..."
.f3a1	a5 b7		lda $b7			LDA	LAB_B7		; get file name length
.f3a3	f0 0a		beq $f3af		BEQ	LAB_F3AF		; if null file name just go find header
.f3a5	20 ea f7	jsr $f7ea		JSR	LAB_F7EA		; find specific tape header
.f3a8	90 18		bcc $f3c2		BCC	LAB_F3C2		; branch if no error
.f3aa	f0 28		beq $f3d4		BEQ	LAB_F3D4		; exit if ??
.f3ac					LAB_F3AC
.f3ac	4c 04 f7	jmp $f704		JMP	LAB_F704		; do file not found error and return
.f3af					LAB_F3AF
.f3af	20 2c f7	jsr $f72c		JSR	LAB_F72C		; find tape header, exit with header in buffer
.f3b2	f0 20		beq $f3d4		BEQ	LAB_F3D4		; exit if end of tape found
.f3b4	90 0c		bcc $f3c2		BCC	LAB_F3C2		;.
.f3b6	b0 f4		bcs $f3ac		BCS	LAB_F3AC		;.
.f3b8					LAB_F3B8
.f3b8	20 38 f8	jsr $f838		JSR	LAB_F838		; wait for PLAY/RECORD
.f3bb	b0 17		bcs $f3d4		BCS	LAB_F3D4		; exit if STOP was pressed
.f3bd	a9 04		lda #$04		LDA	#$04			; set data file header
.f3bf	20 6a f7	jsr $f76a		JSR	LAB_F76A		; write tape header
.f3c2					LAB_F3C2
.f3c2	a9 bf		lda #$bf		LDA	#$BF			;.
.f3c4	a4 b9		ldy $b9			LDY	LAB_B9		; get the secondary address
.f3c6	c0 60		cpy #$60		CPY	#$60			;.
.f3c8	f0 07		beq $f3d1		BEQ	LAB_F3D1		;.
.f3ca	a0 00		ldy #$00		LDY	#$00			; clear index
.f3cc	a9 02		lda #$02		LDA	#$02			;.
.f3ce	91 b2		sta ($b2),y		STA	(LAB_B2),Y		;.save to tape buffer
.f3d0	98		tya			TYA				;.clear A
.f3d1					LAB_F3D1
.f3d1	85 a6		sta $a6			STA	LAB_A6		;.save tape buffer index
.f3d3					LAB_F3D3
.f3d3	18		clc			CLC				; flag ok
.f3d4					LAB_F3D4
.f3d4	60		rts			RTS
.f3d5					LAB_F3D5
.f3d5	a5 b9		lda $b9			LDA	LAB_B9		; get the secondary address
.f3d7	30 fa		bmi $f3d3		BMI	LAB_F3D3		; ok exit if -ve
.f3d9	a4 b7		ldy $b7			LDY	LAB_B7		; get file name length
.f3db	f0 f6		beq $f3d3		BEQ	LAB_F3D3		; ok exit if null
.f3dd	a9 00		lda #$00		LDA	#$00			; clear A
.f3df	85 90		sta $90			STA	LAB_90		; clear the serial status byte
.f3e1	a5 ba		lda $ba			LDA	LAB_BA		; get the device number
.f3e3	20 0c ed	jsr $ed0c		JSR	LAB_ED0C		; command devices on the serial bus to LISTEN
.f3e6	a5 b9		lda $b9			LDA	LAB_B9		; get the secondary address
.f3e8	09 f0		ora #$f0		ORA	#$F0			; OR with the OPEN command
.f3ea	20 b9 ed	jsr $edb9		JSR	LAB_EDB9		; send secondary address after LISTEN
.f3ed	a5 90		lda $90			LDA	LAB_90		; get the serial status byte
.f3ef	10 05		bpl $f3f6		BPL	LAB_F3F6		; if device present skip the 'device not present' error
.f3f1	68		pla			PLA				; else dump calling address low byte
.f3f2	68		pla			PLA				; dump calling address high byte
.f3f3	4c 07 f7	jmp $f707		JMP	LAB_F707		; do 'device not present' error and return
.f3f6					LAB_F3F6
.f3f6	a5 b7		lda $b7			LDA	LAB_B7		; get file name length
.f3f8	f0 0c		beq $f406		BEQ	LAB_F406		; branch if null name
.f3fa	a0 00		ldy #$00		LDY	#$00			; clear index
.f3fc					LAB_F3FC
.f3fc	b1 bb		lda ($bb),y		LDA	(LAB_BB),Y		; get file name byte
.f3fe	20 dd ed	jsr $eddd		JSR	LAB_EDDD		; output byte to serial bus
.f401	c8		iny			INY				; increment index
.f402	c4 b7		cpy $b7			CPY	LAB_B7		; compare with file name length
.f404	d0 f6		bne $f3fc		BNE	LAB_F3FC		; loop if not all done
.f406					LAB_F406
.f406	4c 54 f6	jmp $f654		JMP	LAB_F654		; command serial bus to UNLISTEN and return
.f409					LAB_F409
.f409	20 83 f4	jsr $f483		JSR	LAB_F483		; initialise RS232 output
.f40c	8c 97 02	sty $0297		STY	LAB_0297		; save the RS232 status register
.f40f					LAB_F40F
.f40f	c4 b7		cpy $b7			CPY	LAB_B7		; compare with file name length
.f411	f0 0a		beq $f41d		BEQ	LAB_F41D		; exit loop if done
.f413	b1 bb		lda ($bb),y		LDA	(LAB_BB),Y		; get file name byte
.f415	99 93 02	sta $0293,y		STA	LAB_0293,Y		; copy to 6551 register set
.f418	c8		iny			INY				; increment index
.f419	c0 04		cpy #$04		CPY	#$04			; compare with $04
.f41b	d0 f2		bne $f40f		BNE	LAB_F40F		; loop if not to 4 yet
.f41d					LAB_F41D
.f41d	20 4a ef	jsr $ef4a		JSR	LAB_EF4A		; compute bit count
.f420	8e 98 02	stx $0298		STX	LAB_0298		; save bit count
.f423	ad 93 02	lda $0293		LDA	LAB_0293		; get pseudo 6551 control register
.f426	29 0f		and #$0f		AND	#$0F			; mask 0000 xxxx, baud rate
.f428	f0 1c		beq $f446		BEQ	LAB_F446		; if zero skip the baud rate setup
.f42a	0a		asl a			ASL				; * 2 bytes per entry
.f42b	aa		tax			TAX				; copy to the index
.f42c	ad a6 02	lda $02a6		LDA	LAB_02A6		; get the PAL/NTSC flag
.f42f	d0 09		bne $f43a		BNE	LAB_F43A		; if PAL go set PAL timing
.f431	bc c1 fe	ldy $fec1,x		LDY	LAB_FEC2-1,X	; get the NTSC baud rate value high byte
.f434	bd c0 fe	lda $fec0,x		LDA	LAB_FEC2-2,X	; get the NTSC baud rate value low byte
.f437	4c 40 f4	jmp $f440		JMP	LAB_F440		; go save the baud rate values
.f43a					LAB_F43A
.f43a	bc eb e4	ldy $e4eb,x		LDY	LAB_E4EC-1,X	; get the PAL baud rate value high byte
.f43d	bd ea e4	lda $e4ea,x		LDA	LAB_E4EC-2,X	; get the PAL baud rate value low byte
.f440					LAB_F440
.f440	8c 96 02	sty $0296		STY	LAB_0296		; save the nonstandard bit timing high byte
.f443	8d 95 02	sta $0295		STA	LAB_0295		; save the nonstandard bit timing low byte
.f446					LAB_F446
.f446	ad 95 02	lda $0295		LDA	LAB_0295		; get the nonstandard bit timing low byte
.f449	0a		asl a			ASL				; * 2
.f44a	20 2e ff	jsr $ff2e		JSR	LAB_FF2E		;.
.f44d	ad 94 02	lda $0294		LDA	LAB_0294		; read the pseudo 6551 command register
.f450	4a		lsr a			LSR				; shift the X line/3 line bit into Cb
.f451	90 09		bcc $f45c		BCC	LAB_F45C		; if 3 line skip the DRS test
.f453	ad 01 dd	lda $dd01		LDA	LAB_DD01		; read VIA 2 DRB, RS232 port
.f456	0a		asl a			ASL				; shift DSR in into Cb
.f457	b0 03		bcs $f45c		BCS	LAB_F45C		; if DSR present skip the error set
.f459	20 0d f0	jsr $f00d		JSR	LAB_F00D		; set no DSR
.f45c					LAB_F45C
.f45c	ad 9b 02	lda $029b		LDA	LAB_029B		; get index to Rx buffer end
.f45f	8d 9c 02	sta $029c		STA	LAB_029C		; set index to Rx buffer start, clear Rx buffer
.f462	ad 9e 02	lda $029e		LDA	LAB_029E		; get index to Tx buffer end
.f465	8d 9d 02	sta $029d		STA	LAB_029D		; set index to Tx buffer start, clear Tx buffer
.f468	20 27 fe	jsr $fe27		JSR	LAB_FE27		; read the top of memory
.f46b	a5 f8		lda $f8			LDA	LAB_F8		; get the RS232 input buffer pointer high byte
.f46d	d0 05		bne $f474		BNE	LAB_F474		; if buffer already set skip the save
.f46f	88		dey			DEY				; decrement top of memory high byte, 256 byte buffer
.f470	84 f8		sty $f8			STY	LAB_F8		; save the RS232 input buffer pointer high byte
.f472	86 f7		stx $f7			STX	LAB_F7		; save the RS232 input buffer pointer low byte
.f474					LAB_F474
.f474	a5 fa		lda $fa			LDA	LAB_FA		; get the RS232 output buffer pointer high byte
.f476	d0 05		bne $f47d		BNE	LAB_F47D		; if ?? go set the top of memory to F0xx
.f478	88		dey			DEY				;.
.f479	84 fa		sty $fa			STY	LAB_FA		; save the RS232 output buffer pointer high byte
.f47b	86 f9		stx $f9			STX	LAB_F9		; save the RS232 output buffer pointer low byte
.f47d					LAB_F47D
.f47d	38		sec			SEC				; read the top of memory
.f47e	a9 f0		lda #$f0		LDA	#$F0			; set $F000
.f480	4c 2d fe	jmp $fe2d		JMP	LAB_FE2D		; set the top of memory and return
.f483					LAB_F483
.f483	a9 7f		lda #$7f		LDA	#$7F			; disable all interrupts
.f485	8d 0d dd	sta $dd0d		STA	LAB_DD0D		; save VIA 2 ICR
.f488	a9 06		lda #$06		LDA	#$06			; set RS232 DTR output, RS232 RTS output
.f48a	8d 03 dd	sta $dd03		STA	LAB_DD03		; save VIA 2 DDRB, RS232 port
.f48d	8d 01 dd	sta $dd01		STA	LAB_DD01		; save VIA 2 DRB, RS232 port
.f490	a9 04		lda #$04		LDA	#$04			; mask xxxx x1xx, set RS232 Tx DATA high
.f492	0d 00 dd	ora $dd00		ORA	LAB_DD00		; OR it with VIA 2 DRA, serial port and video address
.f495	8d 00 dd	sta $dd00		STA	LAB_DD00		; save VIA 2 DRA, serial port and video address
.f498	a0 00		ldy #$00		LDY	#$00			; clear Y
.f49a	8c a1 02	sty $02a1		STY	LAB_02A1		; clear the RS-232 interrupt enable byte
.f49d	60		rts			RTS
.f49e					LAB_F49E
.f49e	86 c3		stx $c3			STX	LAB_C3		; set kernal setup pointer low byte
.f4a0	84 c4		sty $c4			STY	LAB_C4		; set kernal setup pointer high byte
.f4a2	6c 30 03	jmp ($0330)		JMP	(LAB_0330)		; do LOAD vector, usually points to LAB_F4A5
.f4a5					LAB_F4A5
.f4a5	85 93		sta $93			STA	LAB_93		; save load/verify flag
.f4a7	a9 00		lda #$00		LDA	#$00			; clear A
.f4a9	85 90		sta $90			STA	LAB_90		; clear the serial status byte
.f4ab	a5 ba		lda $ba			LDA	LAB_BA		; get the device number
.f4ad	d0 03		bne $f4b2		BNE	LAB_F4B2		; if not the keyboard continue
.f4af					LAB_F4AF
.f4af	4c 13 f7	jmp $f713		JMP	LAB_F713		; else do 'illegal device number' and return
.f4b2					LAB_F4B2
.f4b2	c9 03		cmp #$03		CMP	#$03			;.
.f4b4	f0 f9		beq $f4af		BEQ	LAB_F4AF		;.
.f4b6	90 7b		bcc $f533		BCC	LAB_F533		;.
.f4b8	a4 b7		ldy $b7			LDY	LAB_B7		; get file name length
.f4ba	d0 03		bne $f4bf		BNE	LAB_F4BF		; if not null name go ??
.f4bc	4c 10 f7	jmp $f710		JMP	LAB_F710		; else do 'missing file name' error and return
.f4bf					LAB_F4BF
.f4bf	a6 b9		ldx $b9			LDX	LAB_B9		; get the secondary address
.f4c1	20 af f5	jsr $f5af		JSR	LAB_F5AF		; print "Searching..."
.f4c4	a9 60		lda #$60		LDA	#$60			;.
.f4c6	85 b9		sta $b9			STA	LAB_B9		; save the secondary address
.f4c8	20 d5 f3	jsr $f3d5		JSR	LAB_F3D5		; send secondary address and filename
.f4cb	a5 ba		lda $ba			LDA	LAB_BA		; get the device number
.f4cd	20 09 ed	jsr $ed09		JSR	LAB_ED09		; command serial bus device to TALK
.f4d0	a5 b9		lda $b9			LDA	LAB_B9		; get the secondary address
.f4d2	20 c7 ed	jsr $edc7		JSR	LAB_EDC7		; send secondary address after TALK
.f4d5	20 13 ee	jsr $ee13		JSR	LAB_EE13		; input byte from serial bus
.f4d8	85 ae		sta $ae			STA	LAB_AE		; save program start address low byte
.f4da	a5 90		lda $90			LDA	LAB_90		; get the serial status byte
.f4dc	4a		lsr a			LSR				; shift time out read ..
.f4dd	4a		lsr a			LSR				; .. into carry bit
.f4de	b0 50		bcs $f530		BCS	LAB_F530		; if timed out go do file not found error and return
.f4e0	20 13 ee	jsr $ee13		JSR	LAB_EE13		; input byte from serial bus
.f4e3	85 af		sta $af			STA	LAB_AF		; save program start address high byte
.f4e5	8a		txa			TXA				; copy secondary address
.f4e6	d0 08		bne $f4f0		BNE	LAB_F4F0		; load location not set in LOAD call, so continue with the
.f4e8	a5 c3		lda $c3			LDA	LAB_C3		; get the load address low byte
.f4ea	85 ae		sta $ae			STA	LAB_AE		; save the program start address low byte
.f4ec	a5 c4		lda $c4			LDA	LAB_C4		; get the load address high byte
.f4ee	85 af		sta $af			STA	LAB_AF		; save the program start address high byte
.f4f0					LAB_F4F0
.f4f0	20 d2 f5	jsr $f5d2		JSR	LAB_F5D2		;.
.f4f3					LAB_F4F3
.f4f3	a9 fd		lda #$fd		LDA	#$FD			; mask xxxx xx0x, clear time out read bit
.f4f5	25 90		and $90			AND	LAB_90		; mask the serial status byte
.f4f7	85 90		sta $90			STA	LAB_90		; set the serial status byte
.f4f9	20 e1 ff	jsr $ffe1		JSR	LAB_FFE1		; scan stop key, return Zb = 1 = [STOP]
.f4fc	d0 03		bne $f501		BNE	LAB_F501		; if not [STOP] go ??
.f4fe	4c 33 f6	jmp $f633		JMP	LAB_F633		; else close the serial bus device and flag stop
.f501					LAB_F501
.f501	20 13 ee	jsr $ee13		JSR	LAB_EE13		; input byte from serial bus
.f504	aa		tax			TAX				; copy byte
.f505	a5 90		lda $90			LDA	LAB_90		; get the serial status byte
.f507	4a		lsr a			LSR				; shift time out read ..
.f508	4a		lsr a			LSR				; .. into carry bit
.f509	b0 e8		bcs $f4f3		BCS	LAB_F4F3		; if timed out go try again
.f50b	8a		txa			TXA				; copy received byte back
.f50c	a4 93		ldy $93			LDY	LAB_93		; get load/verify flag
.f50e	f0 0c		beq $f51c		BEQ	LAB_F51C		; if load go load
.f510	a0 00		ldy #$00		LDY	#$00			; clear index
.f512	d1 ae		cmp ($ae),y		CMP	(LAB_AE),Y		; compare byte with previously loaded byte
.f514	f0 08		beq $f51e		BEQ	LAB_F51E		; if match go ??
.f516	a9 10		lda #$10		LDA	#$10			; flag read error
.f518	20 1c fe	jsr $fe1c		JSR	LAB_FE1C		; OR into the serial status byte
>f51b	2c					.byte	$2C			; makes next line BIT LAB_AE91
.f51c					LAB_F51C
.f51c	91 ae		sta ($ae),y		STA	(LAB_AE),Y		; save byte to memory
.f51e					LAB_F51E
.f51e	e6 ae		inc $ae			INC	LAB_AE		; increment save pointer low byte
.f520	d0 02		bne $f524		BNE	LAB_F524		; if no rollover go ??
.f522	e6 af		inc $af			INC	LAB_AF		; else increment save pointer high byte
.f524					LAB_F524
.f524	24 90		bit $90			BIT	LAB_90		; test the serial status byte
.f526	50 cb		bvc $f4f3		BVC	LAB_F4F3		; loop if not end of file
.f528	20 ef ed	jsr $edef		JSR	LAB_EDEF		; command serial bus to UNTALK
.f52b	20 42 f6	jsr $f642		JSR	LAB_F642		; close serial bus device
.f52e	90 79		bcc $f5a9		BCC	LAB_F5A9		; if ?? go flag ok and exit
.f530					LAB_F530
.f530	4c 04 f7	jmp $f704		JMP	LAB_F704		; do file not found error and return
.f533					LAB_F533
.f533	4a		lsr a			LSR
.f534	b0 03		bcs $f539		BCS	LAB_F539
.f536	4c 13 f7	jmp $f713		JMP	LAB_F713		; else do 'illegal device number' and return
.f539					LAB_F539
.f539	20 d0 f7	jsr $f7d0		JSR	LAB_F7D0		; get tape buffer start pointer in XY
.f53c	b0 03		bcs $f541		BCS	LAB_F541		; if ??
.f53e	4c 13 f7	jmp $f713		JMP	LAB_F713		; else do 'illegal device number' and return
.f541					LAB_F541
.f541	20 17 f8	jsr $f817		JSR	LAB_F817		; wait for PLAY
.f544	b0 68		bcs $f5ae		BCS	LAB_F5AE		; exit if STOP was pressed
.f546	20 af f5	jsr $f5af		JSR	LAB_F5AF		; print "Searching..."
.f549					LAB_F549
.f549	a5 b7		lda $b7			LDA	LAB_B7		; get file name length
.f54b	f0 09		beq $f556		BEQ	LAB_F556		;.
.f54d	20 ea f7	jsr $f7ea		JSR	LAB_F7EA		; find specific tape header
.f550	90 0b		bcc $f55d		BCC	LAB_F55D		; if no error continue
.f552	f0 5a		beq $f5ae		BEQ	LAB_F5AE		; exit if ??
.f554	b0 da		bcs $f530		BCS	LAB_F530		;., branch always
.f556					LAB_F556
.f556	20 2c f7	jsr $f72c		JSR	LAB_F72C		; find tape header, exit with header in buffer
.f559	f0 53		beq $f5ae		BEQ	LAB_F5AE		; exit if ??
.f55b	b0 d3		bcs $f530		BCS	LAB_F530		;.
.f55d					LAB_F55D
.f55d	a5 90		lda $90			LDA	LAB_90		; get the serial status byte
.f55f	29 10		and #$10		AND	#$10			; mask 000x 0000, read error
.f561	38		sec			SEC				; flag fail
.f562	d0 4a		bne $f5ae		BNE	LAB_F5AE		; if read error just exit
.f564	e0 01		cpx #$01		CPX	#$01			;.
.f566	f0 11		beq $f579		BEQ	LAB_F579		;.
.f568	e0 03		cpx #$03		CPX	#$03			;.
.f56a	d0 dd		bne $f549		BNE	LAB_F549		;.
.f56c					LAB_F56C
.f56c	a0 01		ldy #$01		LDY	#$01			;.
.f56e	b1 b2		lda ($b2),y		LDA	(LAB_B2),Y		;.
.f570	85 c3		sta $c3			STA	LAB_C3		;.
.f572	c8		iny			INY				;.
.f573	b1 b2		lda ($b2),y		LDA	(LAB_B2),Y		;.
.f575	85 c4		sta $c4			STA	LAB_C4		;.
.f577	b0 04		bcs $f57d		BCS	LAB_F57D		;.
.f579					LAB_F579
.f579	a5 b9		lda $b9			LDA	LAB_B9		; get the secondary address
.f57b	d0 ef		bne $f56c		BNE	LAB_F56C		;.
.f57d					LAB_F57D
.f57d	a0 03		ldy #$03		LDY	#$03			;.
.f57f	b1 b2		lda ($b2),y		LDA	(LAB_B2),Y		;.
.f581	a0 01		ldy #$01		LDY	#$01			;.
.f583	f1 b2		sbc ($b2),y		SBC	(LAB_B2),Y		;.
.f585	aa		tax			TAX				;.
.f586	a0 04		ldy #$04		LDY	#$04			;.
.f588	b1 b2		lda ($b2),y		LDA	(LAB_B2),Y		;.
.f58a	a0 02		ldy #$02		LDY	#$02			;.
.f58c	f1 b2		sbc ($b2),y		SBC	(LAB_B2),Y		;.
.f58e	a8		tay			TAY				;.
.f58f	18		clc			CLC				;.
.f590	8a		txa			TXA				;.
.f591	65 c3		adc $c3			ADC	LAB_C3		;.
.f593	85 ae		sta $ae			STA	LAB_AE		;.
.f595	98		tya			TYA				;.
.f596	65 c4		adc $c4			ADC	LAB_C4		;.
.f598	85 af		sta $af			STA	LAB_AF		;.
.f59a	a5 c3		lda $c3			LDA	LAB_C3		;.
.f59c	85 c1		sta $c1			STA	LAB_C1		; set I/O start addresses low byte
.f59e	a5 c4		lda $c4			LDA	LAB_C4		;.
.f5a0	85 c2		sta $c2			STA	LAB_C2		; set I/O start addresses high byte
.f5a2	20 d2 f5	jsr $f5d2		JSR	LAB_F5D2		; display "LOADING" or "VERIFYING"
.f5a5	20 4a f8	jsr $f84a		JSR	LAB_F84A		; do the tape read
>f5a8	24					.byte	$24			; makes next line BIT LAB_xx, keep the error flag in Cb
.f5a9					LAB_F5A9
.f5a9	18		clc			CLC				; flag ok
.f5aa	a6 ae		ldx $ae			LDX	LAB_AE		; get the LOAD end pointer low byte
.f5ac	a4 af		ldy $af			LDY	LAB_AF		; get the LOAD end pointer high byte
.f5ae					LAB_F5AE
.f5ae	60		rts			RTS
.f5af					LAB_F5AF
.f5af	a5 9d		lda $9d			LDA	LAB_9D		; get message mode flag
.f5b1	10 1e		bpl $f5d1		BPL	LAB_F5D1		; exit if control messages off
.f5b3	a0 0c		ldy #$0c		LDY	#LAB_F0C9-LAB_F0BD
.f5b5	20 2f f1	jsr $f12f		JSR	LAB_F12F		; display kernel I/O message
.f5b8	a5 b7		lda $b7			LDA	LAB_B7		; get file name length
.f5ba	f0 15		beq $f5d1		BEQ	LAB_F5D1		; exit if null name
.f5bc	a0 17		ldy #$17		LDY	#LAB_F0D4-LAB_F0BD
.f5be	20 2f f1	jsr $f12f		JSR	LAB_F12F		; display kernel I/O message
.f5c1					LAB_F5C1
.f5c1	a4 b7		ldy $b7			LDY	LAB_B7		; get file name length
.f5c3	f0 0c		beq $f5d1		BEQ	LAB_F5D1		; exit if null file name
.f5c5	a0 00		ldy #$00		LDY	#$00			; clear index
.f5c7					LAB_F5C7
.f5c7	b1 bb		lda ($bb),y		LDA	(LAB_BB),Y		; get file name byte
.f5c9	20 d2 ff	jsr $ffd2		JSR	LAB_FFD2		; output character to channel
.f5cc	c8		iny			INY				; increment index
.f5cd	c4 b7		cpy $b7			CPY	LAB_B7		; compare with file name length
.f5cf	d0 f6		bne $f5c7		BNE	LAB_F5C7		; loop if more to do
.f5d1					LAB_F5D1
.f5d1	60		rts			RTS
.f5d2					LAB_F5D2
.f5d2	a0 49		ldy #$49		LDY	#LAB_F106-LAB_F0BD
.f5d4	a5 93		lda $93			LDA	LAB_93		; get load/verify flag
.f5d6	f0 02		beq $f5da		BEQ	LAB_F5DA		; branch if load
.f5d8	a0 59		ldy #$59		LDY	#LAB_F116-LAB_F0BD
.f5da					LAB_F5DA
.f5da	4c 2b f1	jmp $f12b		JMP	LAB_F12B		; display kernel I/O message if in direct mode and return
.f5dd					LAB_F5DD
.f5dd	86 ae		stx $ae			STX	LAB_AE		; save end address low byte
.f5df	84 af		sty $af			STY	LAB_AF		; save end address high byte
.f5e1	aa		tax			TAX				; copy index to start pointer
.f5e2	b5 00		lda $00,x		LDA	LAB_00+0,X		; get start address low byte
.f5e4	85 c1		sta $c1			STA	LAB_C1		; set I/O start addresses low byte
.f5e6	b5 01		lda $01,x		LDA	LAB_00+1,X		; get start address high byte
.f5e8	85 c2		sta $c2			STA	LAB_C2		; set I/O start addresses high byte
.f5ea	6c 32 03	jmp ($0332)		JMP	(LAB_0332)		; go save, usually points to LAB_F685
.f5ed					LAB_F5ED
.f5ed	a5 ba		lda $ba			LDA	LAB_BA		; get the device number
.f5ef	d0 03		bne $f5f4		BNE	LAB_F5F4		; if not keyboard go ??
.f5f1					LAB_F5F1
.f5f1	4c 13 f7	jmp $f713		JMP	LAB_F713		; else do 'illegal device number' and return
.f5f4					LAB_F5F4
.f5f4	c9 03		cmp #$03		CMP	#$03			; compare device number with screen
.f5f6	f0 f9		beq $f5f1		BEQ	LAB_F5F1		; if screen do illegal device number and return
.f5f8	90 5f		bcc $f659		BCC	LAB_F659		; branch if < screen
.f5fa	a9 61		lda #$61		LDA	#$61			; set secondary address to $01
.f5fc	85 b9		sta $b9			STA	LAB_B9		; save the secondary address
.f5fe	a4 b7		ldy $b7			LDY	LAB_B7		; get the file name length
.f600	d0 03		bne $f605		BNE	LAB_F605		; if filename not null continue
.f602	4c 10 f7	jmp $f710		JMP	LAB_F710		; else do 'missing file name' error and return
.f605					LAB_F605
.f605	20 d5 f3	jsr $f3d5		JSR	LAB_F3D5		; send secondary address and filename
.f608	20 8f f6	jsr $f68f		JSR	LAB_F68F		; print saving <file name>
.f60b	a5 ba		lda $ba			LDA	LAB_BA		; get the device number
.f60d	20 0c ed	jsr $ed0c		JSR	LAB_ED0C		; command devices on the serial bus to LISTEN
.f610	a5 b9		lda $b9			LDA	LAB_B9		; get the secondary address
.f612	20 b9 ed	jsr $edb9		JSR	LAB_EDB9		; send secondary address after LISTEN
.f615	a0 00		ldy #$00		LDY	#$00			; clear index
.f617	20 8e fb	jsr $fb8e		JSR	LAB_FB8E		; copy I/O start address to buffer address
.f61a	a5 ac		lda $ac			LDA	LAB_AC		; get buffer address low byte
.f61c	20 dd ed	jsr $eddd		JSR	LAB_EDDD		; output byte to serial bus
.f61f	a5 ad		lda $ad			LDA	LAB_AD		; get buffer address high byte
.f621	20 dd ed	jsr $eddd		JSR	LAB_EDDD		; output byte to serial bus
.f624					LAB_F624
.f624	20 d1 fc	jsr $fcd1		JSR	LAB_FCD1		; check read/write pointer, return Cb = 1 if pointer >= end
.f627	b0 16		bcs $f63f		BCS	LAB_F63F		; go do UNLISTEN if at end
.f629	b1 ac		lda ($ac),y		LDA	(LAB_AC),Y		; get byte from buffer
.f62b	20 dd ed	jsr $eddd		JSR	LAB_EDDD		; output byte to serial bus
.f62e	20 e1 ff	jsr $ffe1		JSR	LAB_FFE1		; scan stop key
.f631	d0 07		bne $f63a		BNE	LAB_F63A		; if stop not pressed go increment pointer and loop for next
.f633					LAB_F633
.f633	20 42 f6	jsr $f642		JSR	LAB_F642		; close serial bus device
.f636	a9 00		lda #$00		LDA	#$00			;.
.f638	38		sec			SEC				; flag stop
.f639	60		rts			RTS
.f63a					LAB_F63A
.f63a	20 db fc	jsr $fcdb		JSR	LAB_FCDB		; increment read/write pointer
.f63d	d0 e5		bne $f624		BNE	LAB_F624		; loop, branch always
.f63f					LAB_F63F
.f63f	20 fe ed	jsr $edfe		JSR	LAB_EDFE		; command serial bus to UNLISTEN
.f642					LAB_F642
.f642	24 b9		bit $b9			BIT	LAB_B9		; test the secondary address
.f644	30 11		bmi $f657		BMI	LAB_F657		; if already closed just exit
.f646	a5 ba		lda $ba			LDA	LAB_BA		; get the device number
.f648	20 0c ed	jsr $ed0c		JSR	LAB_ED0C		; command devices on the serial bus to LISTEN
.f64b	a5 b9		lda $b9			LDA	LAB_B9		; get the secondary address
.f64d	29 ef		and #$ef		AND	#$EF			; mask the channel number
.f64f	09 e0		ora #$e0		ORA	#$E0			; OR with the CLOSE command
.f651	20 b9 ed	jsr $edb9		JSR	LAB_EDB9		; send secondary address after LISTEN
.f654					LAB_F654
.f654	20 fe ed	jsr $edfe		JSR	LAB_EDFE		; command serial bus to UNLISTEN
.f657					LAB_F657
.f657	18		clc			CLC				; flag ok
.f658	60		rts			RTS
.f659					LAB_F659
.f659	4a		lsr a			LSR				;.
.f65a	b0 03		bcs $f65f		BCS	LAB_F65F		; if not RS232 device ??
.f65c	4c 13 f7	jmp $f713		JMP	LAB_F713		; else do 'illegal device number' and return
.f65f					LAB_F65F
.f65f	20 d0 f7	jsr $f7d0		JSR	LAB_F7D0		; get tape buffer start pointer in XY
.f662	90 8d		bcc $f5f1		BCC	LAB_F5F1		; if < $0200 do illegal device number and return
.f664	20 38 f8	jsr $f838		JSR	LAB_F838		; wait for PLAY/RECORD
.f667	b0 25		bcs $f68e		BCS	LAB_F68E		; exit if STOP was pressed
.f669	20 8f f6	jsr $f68f		JSR	LAB_F68F		; print saving <file name>
.f66c	a2 03		ldx #$03		LDX	#$03			; set header for a non relocatable program file
.f66e	a5 b9		lda $b9			LDA	LAB_B9		; get the secondary address
.f670	29 01		and #$01		AND	#$01			; mask non relocatable bit
.f672	d0 02		bne $f676		BNE	LAB_F676		; if non relocatable program go ??
.f674	a2 01		ldx #$01		LDX	#$01			; else set header for a relocatable program file
.f676					LAB_F676
.f676	8a		txa			TXA				; copy header type to A
.f677	20 6a f7	jsr $f76a		JSR	LAB_F76A		; write tape header
.f67a	b0 12		bcs $f68e		BCS	LAB_F68E		; exit if error
.f67c	20 67 f8	jsr $f867		JSR	LAB_F867		; do tape write, 20 cycle count
.f67f	b0 0d		bcs $f68e		BCS	LAB_F68E		; exit if error
.f681	a5 b9		lda $b9			LDA	LAB_B9		; get the secondary address
.f683	29 02		and #$02		AND	#$02			; mask end of tape flag
.f685	f0 06		beq $f68d		BEQ	LAB_F68D		; if not end of tape go ??
.f687	a9 05		lda #$05		LDA	#$05			; else set logical end of the tape
.f689	20 6a f7	jsr $f76a		JSR	LAB_F76A		; write tape header
>f68c	24					.byte	$24			; makes next line BIT LAB_18 so Cb is not changed
.f68d					LAB_F68D
.f68d	18		clc			CLC				; flag ok
.f68e					LAB_F68E
.f68e	60		rts			RTS
.f68f					LAB_F68F
.f68f	a5 9d		lda $9d			LDA	LAB_9D		; get message mode flag
.f691	10 fb		bpl $f68e		BPL	LAB_F68E		; exit if control messages off
.f693	a0 51		ldy #$51		LDY	#LAB_F10E-LAB_F0BD
.f695	20 2f f1	jsr $f12f		JSR	LAB_F12F		; display kernel I/O message
.f698	4c c1 f5	jmp $f5c1		JMP	LAB_F5C1		; print file name and return
.f69b					LAB_F69B
.f69b	a2 00		ldx #$00		LDX	#$00			; clear X
.f69d	e6 a2		inc $a2			INC	LAB_A2		; increment the jiffy clock low byte
.f69f	d0 06		bne $f6a7		BNE	LAB_F6A7		; if no rollover ??
.f6a1	e6 a1		inc $a1			INC	LAB_A1		; increment the jiffy clock mid byte
.f6a3	d0 02		bne $f6a7		BNE	LAB_F6A7		; branch if no rollover
.f6a5	e6 a0		inc $a0			INC	LAB_A0		; increment the jiffy clock high byte
.f6a7					LAB_F6A7
.f6a7	38		sec			SEC				; set carry for subtract
.f6a8	a5 a2		lda $a2			LDA	LAB_A2		; get the jiffy clock low byte
.f6aa	e9 01		sbc #$01		SBC	#$01			; subtract $4F1A01 low byte
.f6ac	a5 a1		lda $a1			LDA	LAB_A1		; get the jiffy clock mid byte
.f6ae	e9 1a		sbc #$1a		SBC	#$1A			; subtract $4F1A01 mid byte
.f6b0	a5 a0		lda $a0			LDA	LAB_A0		; get the jiffy clock high byte
.f6b2	e9 4f		sbc #$4f		SBC	#$4F			; subtract $4F1A01 high byte
.f6b4	90 06		bcc $f6bc		BCC	LAB_F6BC		; if less than $4F1A01 jiffies skip the clock reset
.f6b6	86 a0		stx $a0			STX	LAB_A0		; clear the jiffy clock high byte
.f6b8	86 a1		stx $a1			STX	LAB_A1		; clear the jiffy clock mid byte
.f6ba	86 a2		stx $a2			STX	LAB_A2		; clear the jiffy clock low byte
.f6bc					LAB_F6BC
.f6bc	ad 01 dc	lda $dc01		LDA	LAB_DC01		; read VIA 1 DRB, keyboard row port
.f6bf	cd 01 dc	cmp $dc01		CMP	LAB_DC01		; compare it with itself
.f6c2	d0 f8		bne $f6bc		BNE	LAB_F6BC		; loop if changing
.f6c4	aa		tax			TAX				;.
.f6c5	30 13		bmi $f6da		BMI	LAB_F6DA		;.
.f6c7	a2 bd		ldx #$bd		LDX	#$BD			; set c6
.f6c9	8e 00 dc	stx $dc00		STX	LAB_DC00		; save VIA 1 DRA, keyboard column drive
.f6cc					LAB_F6CC
.f6cc	ae 01 dc	ldx $dc01		LDX	LAB_DC01		; read VIA 1 DRB, keyboard row port
.f6cf	ec 01 dc	cpx $dc01		CPX	LAB_DC01		; compare it with itself
.f6d2	d0 f8		bne $f6cc		BNE	LAB_F6CC		; loop if changing
.f6d4	8d 00 dc	sta $dc00		STA	LAB_DC00		; save VIA 1 DRA, keyboard column drive
.f6d7	e8		inx			INX				;.
.f6d8	d0 02		bne $f6dc		BNE	LAB_F6DC		;.
.f6da					LAB_F6DA
.f6da	85 91		sta $91			STA	LAB_91		; save the stop key column
.f6dc					LAB_F6DC
.f6dc	60		rts			RTS
.f6dd					LAB_F6DD
.f6dd	78		sei			SEI				; disable the interrupts
.f6de	a5 a2		lda $a2			LDA	LAB_A2		; get the jiffy clock low byte
.f6e0	a6 a1		ldx $a1			LDX	LAB_A1		; get the jiffy clock mid byte
.f6e2	a4 a0		ldy $a0			LDY	LAB_A0		; get the jiffy clock high byte
.f6e4					LAB_F6E4
.f6e4	78		sei			SEI				; disable the interrupts
.f6e5	85 a2		sta $a2			STA	LAB_A2		; save the jiffy clock low byte
.f6e7	86 a1		stx $a1			STX	LAB_A1		; save the jiffy clock mid byte
.f6e9	84 a0		sty $a0			STY	LAB_A0		; save the jiffy clock high byte
.f6eb	58		cli			CLI				; enable the interrupts
.f6ec	60		rts			RTS
.f6ed					LAB_F6ED
.f6ed	a5 91		lda $91			LDA	LAB_91		; read the stop key column
.f6ef	c9 7f		cmp #$7f		CMP	#$7F			; compare with [STP] down
.f6f1	d0 07		bne $f6fa		BNE	LAB_F6FA		; if not [STP] or not just [STP] exit
.f6f3	08		php			PHP				; save status
.f6f4	20 cc ff	jsr $ffcc		JSR	LAB_FFCC		; close input and output channels
.f6f7	85 c6		sta $c6			STA	LAB_C6		; save the keyboard buffer index
.f6f9	28		plp			PLP				; restore status
.f6fa					LAB_F6FA
.f6fa	60		rts			RTS
.f6fb					LAB_F6FB
.f6fb	a9 01		lda #$01		LDA	#$01			; 'too many files' error
>f6fd	2c					.byte	$2C			; makes next line BIT LAB_xxxx
.f6fe					LAB_F6FE
.f6fe	a9 02		lda #$02		LDA	#$02			; 'file already open' error
>f700	2c					.byte	$2C			; makes next line BIT LAB_xxxx
.f701					LAB_F701
.f701	a9 03		lda #$03		LDA	#$03			; 'file not open' error
>f703	2c					.byte	$2C			; makes next line BIT LAB_xxxx
.f704					LAB_F704
.f704	a9 04		lda #$04		LDA	#$04			; 'file not found' error
>f706	2c					.byte	$2C			; makes next line BIT LAB_xxxx
.f707					LAB_F707
.f707	a9 05		lda #$05		LDA	#$05			; 'device not present' error
>f709	2c					.byte	$2C			; makes next line BIT LAB_xxxx
.f70a					LAB_F70A
.f70a	a9 06		lda #$06		LDA	#$06			; 'not input file' error
>f70c	2c					.byte	$2C			; makes next line BIT LAB_xxxx
.f70d					LAB_F70D
.f70d	a9 07		lda #$07		LDA	#$07			; 'not output file' error
>f70f	2c					.byte	$2C			; makes next line BIT LAB_xxxx
.f710					LAB_F710
.f710	a9 08		lda #$08		LDA	#$08			; 'missing file name' error
>f712	2c					.byte	$2C			; makes next line BIT LAB_xxxx
.f713					LAB_F713
.f713	a9 09		lda #$09		LDA	#$09			; do 'illegal device number'
.f715	48		pha			PHA				; save the error #
.f716	20 cc ff	jsr $ffcc		JSR	LAB_FFCC		; close input and output channels
.f719	a0 00		ldy #$00		LDY	#LAB_F0BD-LAB_F0BD
.f71b	24 9d		bit $9d			BIT	LAB_9D		; test message mode flag
.f71d	50 0a		bvc $f729		BVC	LAB_F729		; exit if kernal messages off
.f71f	20 2f f1	jsr $f12f		JSR	LAB_F12F		; display kernel I/O message
.f722	68		pla			PLA				; restore error #
.f723	48		pha			PHA				; copy error #
.f724	09 30		ora #$30		ORA	#'0'			; convert to ASCII
.f726	20 d2 ff	jsr $ffd2		JSR	LAB_FFD2		; output character to channel
.f729					LAB_F729
.f729	68		pla			PLA				; pull error number
.f72a	38		sec			SEC				; flag error
.f72b	60		rts			RTS
.f72c					LAB_F72C
.f72c	a5 93		lda $93			LDA	LAB_93		; get load/verify flag
.f72e	48		pha			PHA				; save load/verify flag
.f72f	20 41 f8	jsr $f841		JSR	LAB_F841		; initiate tape read
.f732	68		pla			PLA				; restore load/verify flag
.f733	85 93		sta $93			STA	LAB_93		; save load/verify flag
.f735	b0 32		bcs $f769		BCS	LAB_F769		; exit if error
.f737	a0 00		ldy #$00		LDY	#$00			; clear the index
.f739	b1 b2		lda ($b2),y		LDA	(LAB_B2),Y		; read first byte from tape buffer
.f73b	c9 05		cmp #$05		CMP	#$05			; compare with logical end of the tape
.f73d	f0 2a		beq $f769		BEQ	LAB_F769		; if end of the tape exit
.f73f	c9 01		cmp #$01		CMP	#$01			; compare with header for a relocatable program file
.f741	f0 08		beq $f74b		BEQ	LAB_F74B		; if program file header go ??
.f743	c9 03		cmp #$03		CMP	#$03			; compare with header for a non relocatable program file
.f745	f0 04		beq $f74b		BEQ	LAB_F74B		; if program file header go  ??
.f747	c9 04		cmp #$04		CMP	#$04			; compare with data file header
.f749	d0 e1		bne $f72c		BNE	LAB_F72C		; if data file loop to find the tape header
.f74b					LAB_F74B
.f74b	aa		tax			TAX				; copy header type
.f74c	24 9d		bit $9d			BIT	LAB_9D		; get message mode flag
.f74e	10 17		bpl $f767		BPL	LAB_F767		; exit if control messages off
.f750	a0 63		ldy #$63		LDY	#LAB_F120-LAB_F0BD
.f752	20 2f f1	jsr $f12f		JSR	LAB_F12F		; display kernel I/O message
.f755	a0 05		ldy #$05		LDY	#$05			; index to the tape filename
.f757					LAB_F757
.f757	b1 b2		lda ($b2),y		LDA	(LAB_B2),Y		; get byte from tape buffer
.f759	20 d2 ff	jsr $ffd2		JSR	LAB_FFD2		; output character to channel
.f75c	c8		iny			INY				; increment the index
.f75d	c0 15		cpy #$15		CPY	#$15			; compare it with end+1
.f75f	d0 f6		bne $f757		BNE	LAB_F757		; loop if more to do
.f761	a5 a1		lda $a1			LDA	LAB_A1		; get the jiffy clock mid byte
.f763	20 e0 e4	jsr $e4e0		JSR	LAB_E4E0		; wait ~8.5 seconds for any key from the STOP key column
.f766	ea		nop			NOP				; waste cycles
.f767					LAB_F767
.f767	18		clc			CLC				; flag no error
.f768	88		dey			DEY				; decrement the index
.f769					LAB_F769
.f769	60		rts			RTS
.f76a					LAB_F76A
.f76a	85 9e		sta $9e			STA	LAB_9E		; save header type
.f76c	20 d0 f7	jsr $f7d0		JSR	LAB_F7D0		; get tape buffer start pointer in XY
.f76f	90 5e		bcc $f7cf		BCC	LAB_F7CF		; if < $0200 just exit ??
.f771	a5 c2		lda $c2			LDA	LAB_C2		; get I/O start address high byte
.f773	48		pha			PHA				; save it
.f774	a5 c1		lda $c1			LDA	LAB_C1		; get I/O start address low byte
.f776	48		pha			PHA				; save it
.f777	a5 af		lda $af			LDA	LAB_AF		; get tape end address high byte
.f779	48		pha			PHA				; save it
.f77a	a5 ae		lda $ae			LDA	LAB_AE		; get tape end address low byte
.f77c	48		pha			PHA				; save it
.f77d	a0 bf		ldy #$bf		LDY	#$BF			; index to header end
.f77f	a9 20		lda #$20		LDA	#' '			; clear byte, [SPACE]
.f781					LAB_F781
.f781	91 b2		sta ($b2),y		STA	(LAB_B2),Y		; clear header byte
.f783	88		dey			DEY				; decrement index
.f784	d0 fb		bne $f781		BNE	LAB_F781		; loop if more to do
.f786	a5 9e		lda $9e			LDA	LAB_9E		; get the header type back
.f788	91 b2		sta ($b2),y		STA	(LAB_B2),Y		; write it to header
.f78a	c8		iny			INY				; increment the index
.f78b	a5 c1		lda $c1			LDA	LAB_C1		; get the I/O start address low byte
.f78d	91 b2		sta ($b2),y		STA	(LAB_B2),Y		; write it to header
.f78f	c8		iny			INY				; increment the index
.f790	a5 c2		lda $c2			LDA	LAB_C2		; get the I/O start address high byte
.f792	91 b2		sta ($b2),y		STA	(LAB_B2),Y		; write it to header
.f794	c8		iny			INY				; increment the index
.f795	a5 ae		lda $ae			LDA	LAB_AE		; get the tape end address low byte
.f797	91 b2		sta ($b2),y		STA	(LAB_B2),Y		; write it to header
.f799	c8		iny			INY				; increment the index
.f79a	a5 af		lda $af			LDA	LAB_AF		; get the tape end address high byte
.f79c	91 b2		sta ($b2),y		STA	(LAB_B2),Y		; write it to header
.f79e	c8		iny			INY				; increment the index
.f79f	84 9f		sty $9f			STY	LAB_9F		; save the index
.f7a1	a0 00		ldy #$00		LDY	#$00			; clear Y
.f7a3	84 9e		sty $9e			STY	LAB_9E		; clear the name index
.f7a5					LAB_F7A5
.f7a5	a4 9e		ldy $9e			LDY	LAB_9E		; get name index
.f7a7	c4 b7		cpy $b7			CPY	LAB_B7		; compare with file name length
.f7a9	f0 0c		beq $f7b7		BEQ	LAB_F7B7		; if all done exit the loop
.f7ab	b1 bb		lda ($bb),y		LDA	(LAB_BB),Y		; get file name byte
.f7ad	a4 9f		ldy $9f			LDY	LAB_9F		; get buffer index
.f7af	91 b2		sta ($b2),y		STA	(LAB_B2),Y		; save file name byte to buffer
.f7b1	e6 9e		inc $9e			INC	LAB_9E		; increment file name index
.f7b3	e6 9f		inc $9f			INC	LAB_9F		; increment tape buffer index
.f7b5	d0 ee		bne $f7a5		BNE	LAB_F7A5		; loop, branch always
.f7b7					LAB_F7B7
.f7b7	20 d7 f7	jsr $f7d7		JSR	LAB_F7D7		; set tape buffer start and end pointers
.f7ba	a9 69		lda #$69		LDA	#$69			; set write lead cycle count
.f7bc	85 ab		sta $ab			STA	LAB_AB		; save write lead cycle count
.f7be	20 6b f8	jsr $f86b		JSR	LAB_F86B		; do tape write, no cycle count set
.f7c1	a8		tay			TAY				;.
.f7c2	68		pla			PLA				; pull tape end address low byte
.f7c3	85 ae		sta $ae			STA	LAB_AE		; restore it
.f7c5	68		pla			PLA				; pull tape end address high byte
.f7c6	85 af		sta $af			STA	LAB_AF		; restore it
.f7c8	68		pla			PLA				; pull I/O start addresses low byte
.f7c9	85 c1		sta $c1			STA	LAB_C1		; restore it
.f7cb	68		pla			PLA				; pull I/O start addresses high byte
.f7cc	85 c2		sta $c2			STA	LAB_C2		; restore it
.f7ce	98		tya			TYA				;.
.f7cf					LAB_F7CF
.f7cf	60		rts			RTS
.f7d0					LAB_F7D0
.f7d0	a6 b2		ldx $b2			LDX	LAB_B2		; get tape buffer start pointer low byte
.f7d2	a4 b3		ldy $b3			LDY	LAB_B3		; get tape buffer start pointer high byte
.f7d4	c0 02		cpy #$02		CPY	#$02			; compare high byte with $02xx
.f7d6	60		rts			RTS
.f7d7					LAB_F7D7
.f7d7	20 d0 f7	jsr $f7d0		JSR	LAB_F7D0		; get tape buffer start pointer in XY
.f7da	8a		txa			TXA				; copy tape buffer start pointer low byte
.f7db	85 c1		sta $c1			STA	LAB_C1		; save as I/O address pointer low byte
.f7dd	18		clc			CLC				; clear carry for add
.f7de	69 c0		adc #$c0		ADC	#$C0			; add buffer length low byte
.f7e0	85 ae		sta $ae			STA	LAB_AE		; save tape buffer end pointer low byte
.f7e2	98		tya			TYA				; copy tape buffer start pointer high byte
.f7e3	85 c2		sta $c2			STA	LAB_C2		; save as I/O address pointer high byte
.f7e5	69 00		adc #$00		ADC	#$00			; add buffer length high byte
.f7e7	85 af		sta $af			STA	LAB_AF		; save tape buffer end pointer high byte
.f7e9	60		rts			RTS
.f7ea					LAB_F7EA
.f7ea	20 2c f7	jsr $f72c		JSR	LAB_F72C		; find tape header, exit with header in buffer
.f7ed	b0 1d		bcs $f80c		BCS	LAB_F80C		; just exit if error
.f7ef	a0 05		ldy #$05		LDY	#$05			; index to name
.f7f1	84 9f		sty $9f			STY	LAB_9F		; save as tape buffer index
.f7f3	a0 00		ldy #$00		LDY	#$00			; clear Y
.f7f5	84 9e		sty $9e			STY	LAB_9E		; save as name buffer index
.f7f7					LAB_F7F7
.f7f7	c4 b7		cpy $b7			CPY	LAB_B7		; compare with file name length
.f7f9	f0 10		beq $f80b		BEQ	LAB_F80B		; ok exit if match
.f7fb	b1 bb		lda ($bb),y		LDA	(LAB_BB),Y		; get file name byte
.f7fd	a4 9f		ldy $9f			LDY	LAB_9F		; get index to tape buffer
.f7ff	d1 b2		cmp ($b2),y		CMP	(LAB_B2),Y		; compare with tape header name byte
.f801	d0 e7		bne $f7ea		BNE	LAB_F7EA		; if no match go get next header
.f803	e6 9e		inc $9e			INC	LAB_9E		; else increment name buffer index
.f805	e6 9f		inc $9f			INC	LAB_9F		; increment tape buffer index
.f807	a4 9e		ldy $9e			LDY	LAB_9E		; get name buffer index
.f809	d0 ec		bne $f7f7		BNE	LAB_F7F7		; loop, branch always
.f80b					LAB_F80B
.f80b	18		clc			CLC				; flag ok
.f80c					LAB_F80C
.f80c	60		rts			RTS
.f80d					LAB_F80D
.f80d	20 d0 f7	jsr $f7d0		JSR	LAB_F7D0		; get tape buffer start pointer in XY
.f810	e6 a6		inc $a6			INC	LAB_A6		; increment tape buffer index
.f812	a4 a6		ldy $a6			LDY	LAB_A6		; get tape buffer index
.f814	c0 c0		cpy #$c0		CPY	#$C0			; compare with buffer length
.f816	60		rts			RTS
.f817					LAB_F817
.f817	20 2e f8	jsr $f82e		JSR	LAB_F82E		; return cassette sense in Zb
.f81a	f0 1a		beq $f836		BEQ	LAB_F836		; if switch closed just exit
.f81c	a0 1b		ldy #$1b		LDY	#LAB_F0D8-LAB_F0BD
.f81e					LAB_F81E
.f81e	20 2f f1	jsr $f12f		JSR	LAB_F12F		; display kernel I/O message
.f821					LAB_F821
.f821	20 d0 f8	jsr $f8d0		JSR	LAB_F8D0		; scan stop key and flag abort if pressed
.f824	20 2e f8	jsr $f82e		JSR	LAB_F82E		; return cassette sense in Zb
.f827	d0 f8		bne $f821		BNE	LAB_F821		; loop if the cassette switch is open
.f829	a0 6a		ldy #$6a		LDY	#LAB_F127-LAB_F0BD
.f82b	4c 2f f1	jmp $f12f		JMP	LAB_F12F		; display kernel I/O message and return
.f82e					LAB_F82E
.f82e	a9 10		lda #$10		LDA	#$10			; set the mask for the cassette switch
.f830	24 01		bit $01			BIT	LAB_01		; test the 6510 I/O port
.f832	d0 02		bne $f836		BNE	LAB_F836		; branch if cassette sense high
.f834	24 01		bit $01			BIT	LAB_01		; test the 6510 I/O port
.f836					LAB_F836
.f836	18		clc			CLC				;.
.f837	60		rts			RTS
.f838					LAB_F838
.f838	20 2e f8	jsr $f82e		JSR	LAB_F82E		; return the cassette sense in Zb
.f83b	f0 f9		beq $f836		BEQ	LAB_F836		; exit if switch closed
.f83d	a0 2e		ldy #$2e		LDY	#LAB_F0EB-LAB_F0BD
.f83f	d0 dd		bne $f81e		BNE	LAB_F81E		; display message and wait for switch, branch always
.f841					LAB_F841
.f841	a9 00		lda #$00		LDA	#$00			; clear A
.f843	85 90		sta $90			STA	LAB_90		; clear serial status byte
.f845	85 93		sta $93			STA	LAB_93		; clear the load/verify flag
.f847	20 d7 f7	jsr $f7d7		JSR	LAB_F7D7		; set the tape buffer start and end pointers
.f84a					LAB_F84A
.f84a	20 17 f8	jsr $f817		JSR	LAB_F817		; wait for PLAY
.f84d	b0 1f		bcs $f86e		BCS	LAB_F86E		; exit if STOP was pressed, uses a further BCS at the
.f84f	78		sei			SEI				; disable interrupts
.f850	a9 00		lda #$00		LDA	#$00			; clear A
.f852	85 aa		sta $aa			STA	LAB_AA		;.
.f854	85 b4		sta $b4			STA	LAB_B4		;.
.f856	85 b0		sta $b0			STA	LAB_B0		; clear tape timing constant min byte
.f858	85 9e		sta $9e			STA	LAB_9E		; clear tape pass 1 error log/char buffer
.f85a	85 9f		sta $9f			STA	LAB_9F		; clear tape pass 2 error log corrected
.f85c	85 9c		sta $9c			STA	LAB_9C		; clear byte received flag
.f85e	a9 90		lda #$90		LDA	#$90			; enable CA1 interrupt ??
.f860	a2 0e		ldx #$0e		LDX	#$0E			; set index for tape read vector
.f862	d0 11		bne $f875		BNE	LAB_F875		; go do tape read/write, branch always
.f864					LAB_F864
.f864	20 d7 f7	jsr $f7d7		JSR	LAB_F7D7		; set tape buffer start and end pointers
.f867					LAB_F867
.f867	a9 14		lda #$14		LDA	#$14			; set write lead cycle count
.f869	85 ab		sta $ab			STA	LAB_AB		; save write lead cycle count
.f86b					LAB_F86B
.f86b	20 38 f8	jsr $f838		JSR	LAB_F838		; wait for PLAY/RECORD
.f86e					LAB_F86E
.f86e	b0 6c		bcs $f8dc		BCS	LAB_F8DC		; if STOPped clear save IRQ address and exit
.f870	78		sei			SEI				; disable interrupts
.f871	a9 82		lda #$82		LDA	#$82			; enable ?? interrupt
.f873	a2 08		ldx #$08		LDX	#$08			; set index for tape write tape leader vector
.f875					LAB_F875
.f875	a0 7f		ldy #$7f		LDY	#$7F			; disable all interrupts
.f877	8c 0d dc	sty $dc0d		STY	LAB_DC0D		; save VIA 1 ICR, disable all interrupts
.f87a	8d 0d dc	sta $dc0d		STA	LAB_DC0D		; save VIA 1 ICR, enable interrupts according to A
.f87d	ad 0e dc	lda $dc0e		LDA	LAB_DC0E		; read VIA 1 CRA
.f880	09 19		ora #$19		ORA	#$19			; load timer B, timer B single shot, start timer B
.f882	8d 0f dc	sta $dc0f		STA	LAB_DC0F		; save VIA 1 CRB
.f885	29 91		and #$91		AND	#$91			; mask x00x 000x, TOD clock, load timer A, start timer A
.f887	8d a2 02	sta $02a2		STA	LAB_02A2		; save VIA 1 CRB shadow copy
.f88a	20 a4 f0	jsr $f0a4		JSR	LAB_F0A4		;.
.f88d	ad 11 d0	lda $d011		LDA	LAB_D011		; read the vertical fine scroll and control register
.f890	29 ef		and #$ef		AND	#$EF			; mask xxx0 xxxx, blank the screen
.f892	8d 11 d0	sta $d011		STA	LAB_D011		; save the vertical fine scroll and control register
.f895	ad 14 03	lda $0314		LDA	LAB_0314		; get IRQ vector low byte
.f898	8d 9f 02	sta $029f		STA	LAB_029F		; save IRQ vector low byte
.f89b	ad 15 03	lda $0315		LDA	LAB_0315		; get IRQ vector high byte
.f89e	8d a0 02	sta $02a0		STA	LAB_02A0		; save IRQ vector high byte
.f8a1	20 bd fc	jsr $fcbd		JSR	LAB_FCBD		; set the tape vector
.f8a4	a9 02		lda #$02		LDA	#$02			; set copies count. the first copy is the load copy, the
.f8a6	85 be		sta $be			STA	LAB_BE		; save copies count
.f8a8	20 97 fb	jsr $fb97		JSR	LAB_FB97		; new tape byte setup
.f8ab	a5 01		lda $01			LDA	LAB_01		; read the 6510 I/O port
.f8ad	29 1f		and #$1f		AND	#$1F			; mask 000x xxxx, cassette motor on ??
.f8af	85 01		sta $01			STA	LAB_01		; save the 6510 I/O port
.f8b1	85 c0		sta $c0			STA	LAB_C0		; set the tape motor interlock
.f8b3	a2 ff		ldx #$ff		LDX	#$FF			; outer loop count
.f8b5					LAB_F8B5
.f8b5	a0 ff		ldy #$ff		LDY	#$FF			; inner loop count
.f8b7					LAB_F8B7
.f8b7	88		dey			DEY				; decrement inner loop count
.f8b8	d0 fd		bne $f8b7		BNE	LAB_F8B7		; loop if more to do
.f8ba	ca		dex			DEX				; decrement outer loop count
.f8bb	d0 f8		bne $f8b5		BNE	LAB_F8B5		; loop if more to do
.f8bd	58		cli			CLI				; enable tape interrupts
.f8be					LAB_F8BE
.f8be	ad a0 02	lda $02a0		LDA	LAB_02A0		; get saved IRQ high byte
.f8c1	cd 15 03	cmp $0315		CMP	LAB_0315		; compare with the current IRQ high byte
.f8c4	18		clc			CLC				; flag ok
.f8c5	f0 15		beq $f8dc		BEQ	LAB_F8DC		; if tape write done go clear saved IRQ address and exit
.f8c7	20 d0 f8	jsr $f8d0		JSR	LAB_F8D0		; scan stop key and flag abort if pressed
.f8ca	20 bc f6	jsr $f6bc		JSR	LAB_F6BC		; increment real time clock
.f8cd	4c be f8	jmp $f8be		JMP	LAB_F8BE		; loop
.f8d0					LAB_F8D0
.f8d0	20 e1 ff	jsr $ffe1		JSR	LAB_FFE1		; scan stop key
.f8d3	18		clc			CLC				; flag no stop
.f8d4	d0 0b		bne $f8e1		BNE	LAB_F8E1		; exit if no stop
.f8d6	20 93 fc	jsr $fc93		JSR	LAB_FC93		; restore everything for STOP
.f8d9	38		sec			SEC				; flag stopped
.f8da	68		pla			PLA				; dump return address low byte
.f8db	68		pla			PLA				; dump return address high byte
.f8dc					LAB_F8DC
.f8dc	a9 00		lda #$00		LDA	#$00			; clear A
.f8de	8d a0 02	sta $02a0		STA	LAB_02A0		; clear saved IRQ address high byte
.f8e1					LAB_F8E1
.f8e1	60		rts			RTS
.f8e2					LAB_F8E2
.f8e2	86 b1		stx $b1			STX	LAB_B1		; save tape timing constant max byte
.f8e4	a5 b0		lda $b0			LDA	LAB_B0		; get tape timing constant min byte
.f8e6	0a		asl a			ASL				; *2
.f8e7	0a		asl a			ASL				; *4
.f8e8	18		clc			CLC				; clear carry for add
.f8e9	65 b0		adc $b0			ADC	LAB_B0		; add tape timing constant min byte *5
.f8eb	18		clc			CLC				; clear carry for add
.f8ec	65 b1		adc $b1			ADC	LAB_B1		; add tape timing constant max byte
.f8ee	85 b1		sta $b1			STA	LAB_B1		; save tape timing constant max byte
.f8f0	a9 00		lda #$00		LDA	#$00			;.
.f8f2	24 b0		bit $b0			BIT	LAB_B0		; test tape timing constant min byte
.f8f4	30 01		bmi $f8f7		BMI	LAB_F8F7		; branch if b7 set
.f8f6	2a		rol a			ROL				; else shift carry into ??
.f8f7					LAB_F8F7
.f8f7	06 b1		asl $b1			ASL	LAB_B1		; shift tape timing constant max byte
.f8f9	2a		rol a			ROL				;.
.f8fa	06 b1		asl $b1			ASL	LAB_B1		; shift tape timing constant max byte
.f8fc	2a		rol a			ROL				;.
.f8fd	aa		tax			TAX				;.
.f8fe					LAB_F8FE
.f8fe	ad 06 dc	lda $dc06		LDA	LAB_DC06		; get VIA 1 timer B low byte
.f901	c9 16		cmp #$16		CMP	#$16			;.compare with ??
.f903	90 f9		bcc $f8fe		BCC	LAB_F8FE		; loop if less
.f905	65 b1		adc $b1			ADC	LAB_B1		; add tape timing constant max byte
.f907	8d 04 dc	sta $dc04		STA	LAB_DC04		; save VIA 1 timer A low byte
.f90a	8a		txa			TXA				;.
.f90b	6d 07 dc	adc $dc07		ADC	LAB_DC07		; add VIA 1 timer B high byte
.f90e	8d 05 dc	sta $dc05		STA	LAB_DC05		; save VIA 1 timer A high byte
.f911	ad a2 02	lda $02a2		LDA	LAB_02A2		; read VIA 1 CRB shadow copy
.f914	8d 0e dc	sta $dc0e		STA	LAB_DC0E		; save VIA 1 CRA
.f917	8d a4 02	sta $02a4		STA	LAB_02A4		; save VIA 1 CRA shadow copy
.f91a	ad 0d dc	lda $dc0d		LDA	LAB_DC0D		; read VIA 1 ICR
.f91d	29 10		and #$10		AND	#$10			; mask 000x 0000, FLAG interrupt
.f91f	f0 09		beq $f92a		BEQ	LAB_F92A		; if no FLAG interrupt just exit
.f921	a9 f9		lda #$f9		LDA	#>LAB_F92A		; set the return address high byte
.f923	48		pha			PHA				; push the return address high byte
.f924	a9 2a		lda #$2a		LDA	#<LAB_F92A		; set the return address low byte
.f926	48		pha			PHA				; push the return address low byte
.f927	4c 43 ff	jmp $ff43		JMP	LAB_FF43		; save the status and do the IRQ routine
.f92a					LAB_F92A
.f92a	58		cli			CLI				; enable interrupts
.f92b	60		rts			RTS
.f92c					LAB_F92C
.f92c	ae 07 dc	ldx $dc07		LDX	LAB_DC07		; read VIA 1 timer B high byte
.f92f	a0 ff		ldy #$ff		LDY	#$FF			;.set $FF
.f931	98		tya			TYA				;.A = $FF
.f932	ed 06 dc	sbc $dc06		SBC	LAB_DC06		; subtract VIA 1 timer B low byte
.f935	ec 07 dc	cpx $dc07		CPX	LAB_DC07		; compare it with VIA 1 timer B high byte
.f938	d0 f2		bne $f92c		BNE	LAB_F92C		; if timer low byte rolled over loop
.f93a	86 b1		stx $b1			STX	LAB_B1		; save tape timing constant max byte
.f93c	aa		tax			TAX				;.copy $FF - T2C_l
.f93d	8c 06 dc	sty $dc06		STY	LAB_DC06		; save VIA 1 timer B low byte
.f940	8c 07 dc	sty $dc07		STY	LAB_DC07		; save VIA 1 timer B high byte
.f943	a9 19		lda #$19		LDA	#$19			; load timer B, timer B single shot, start timer B
.f945	8d 0f dc	sta $dc0f		STA	LAB_DC0F		; save VIA 1 CRB
.f948	ad 0d dc	lda $dc0d		LDA	LAB_DC0D		; read VIA 1 ICR
.f94b	8d a3 02	sta $02a3		STA	LAB_02A3		; save VIA 1 ICR shadow copy
.f94e	98		tya			TYA				; y = $FF
.f94f	e5 b1		sbc $b1			SBC	LAB_B1		; subtract tape timing constant max byte
.f951	86 b1		stx $b1			STX	LAB_B1		; save tape timing constant max byte
.f953	4a		lsr a			LSR				;.A = $FF - T2C_h >> 1
.f954	66 b1		ror $b1			ROR	LAB_B1		; shift tape timing constant max byte
.f956	4a		lsr a			LSR				;.A = $FF - T2C_h >> 1
.f957	66 b1		ror $b1			ROR	LAB_B1		; shift tape timing constant max byte
.f959	a5 b0		lda $b0			LDA	LAB_B0		; get tape timing constant min byte
.f95b	18		clc			CLC				; clear carry for add
.f95c	69 3c		adc #$3c		ADC	#$3C			;.
.f95e	c5 b1		cmp $b1			CMP	LAB_B1		; compare with tape timing constant max byte
.f960	b0 4a		bcs $f9ac		BCS	LAB_F9AC		;.branch if min + $3C >= ($FFFF - T2C) >> 2
.f962	a6 9c		ldx $9c			LDX	LAB_9C		;.get byte received flag
.f964	f0 03		beq $f969		BEQ	LAB_F969		;. if not byte received ??
.f966	4c 60 fa	jmp $fa60		JMP	LAB_FA60		;.store the tape character
.f969					LAB_F969
.f969	a6 a3		ldx $a3			LDX	LAB_A3		;.get EOI flag byte
.f96b	30 1b		bmi $f988		BMI	LAB_F988		;.
.f96d	a2 00		ldx #$00		LDX	#$00			;.
.f96f	69 30		adc #$30		ADC	#$30			;.
.f971	65 b0		adc $b0			ADC	LAB_B0		; add tape timing constant min byte
.f973	c5 b1		cmp $b1			CMP	LAB_B1		; compare with tape timing constant max byte
.f975	b0 1c		bcs $f993		BCS	LAB_F993		;.
.f977	e8		inx			INX				;.
.f978	69 26		adc #$26		ADC	#$26			;.
.f97a	65 b0		adc $b0			ADC	LAB_B0		; add tape timing constant min byte
.f97c	c5 b1		cmp $b1			CMP	LAB_B1		; compare with tape timing constant max byte
.f97e	b0 17		bcs $f997		BCS	LAB_F997		;.
.f980	69 2c		adc #$2c		ADC	#$2C			;.
.f982	65 b0		adc $b0			ADC	LAB_B0		; add tape timing constant min byte
.f984	c5 b1		cmp $b1			CMP	LAB_B1		; compare with tape timing constant max byte
.f986	90 03		bcc $f98b		BCC	LAB_F98B		;.
.f988					LAB_F988
.f988	4c 10 fa	jmp $fa10		JMP	LAB_FA10		;.
.f98b					LAB_F98B
.f98b	a5 b4		lda $b4			LDA	LAB_B4		; get the bit count
.f98d	f0 1d		beq $f9ac		BEQ	LAB_F9AC		; if all done go ??
.f98f	85 a8		sta $a8			STA	LAB_A8		; save receiver bit count in
.f991	d0 19		bne $f9ac		BNE	LAB_F9AC		; branch always
.f993					LAB_F993
.f993	e6 a9		inc $a9			INC	LAB_A9		; increment ?? start bit check flag
.f995	b0 02		bcs $f999		BCS	LAB_F999		;.
.f997					LAB_F997
.f997	c6 a9		dec $a9			DEC	LAB_A9		; decrement ?? start bit check flag
.f999					LAB_F999
.f999	38		sec			SEC				;.
.f99a	e9 13		sbc #$13		SBC	#$13			;.
.f99c	e5 b1		sbc $b1			SBC	LAB_B1		; subtract tape timing constant max byte
.f99e	65 92		adc $92			ADC	LAB_92		; add timing constant for tape
.f9a0	85 92		sta $92			STA	LAB_92		; save timing constant for tape
.f9a2	a5 a4		lda $a4			LDA	LAB_A4		;.get tape bit cycle phase
.f9a4	49 01		eor #$01		EOR	#$01			;.
.f9a6	85 a4		sta $a4			STA	LAB_A4		;.save tape bit cycle phase
.f9a8	f0 2b		beq $f9d5		BEQ	LAB_F9D5		;.
.f9aa	86 d7		stx $d7			STX	LAB_D7		;.
.f9ac					LAB_F9AC
.f9ac	a5 b4		lda $b4			LDA	LAB_B4		; get the bit count
.f9ae	f0 22		beq $f9d2		BEQ	LAB_F9D2		; if all done go ??
.f9b0	ad a3 02	lda $02a3		LDA	LAB_02A3		; read VIA 1 ICR shadow copy
.f9b3	29 01		and #$01		AND	#$01			; mask 0000 000x, timer A interrupt enabled
.f9b5	d0 05		bne $f9bc		BNE	LAB_F9BC		; if timer A is enabled go ??
.f9b7	ad a4 02	lda $02a4		LDA	LAB_02A4		; read VIA 1 CRA shadow copy
.f9ba	d0 16		bne $f9d2		BNE	LAB_F9D2		; if ?? just exit
.f9bc					LAB_F9BC
.f9bc	a9 00		lda #$00		LDA	#$00			; clear A
.f9be	85 a4		sta $a4			STA	LAB_A4		; clear the tape bit cycle phase
.f9c0	8d a4 02	sta $02a4		STA	LAB_02A4		; save VIA 1 CRA shadow copy
.f9c3	a5 a3		lda $a3			LDA	LAB_A3		;.get EOI flag byte
.f9c5	10 30		bpl $f9f7		BPL	LAB_F9F7		;.
.f9c7	30 bf		bmi $f988		BMI	LAB_F988		;.
.f9c9					LAB_F9C9
.f9c9	a2 a6		ldx #$a6		LDX	#$A6			; set timimg max byte
.f9cb	20 e2 f8	jsr $f8e2		JSR	LAB_F8E2		; set timing
.f9ce	a5 9b		lda $9b			LDA	LAB_9B		;.
.f9d0	d0 b9		bne $f98b		BNE	LAB_F98B		;.
.f9d2					LAB_F9D2
.f9d2	4c bc fe	jmp $febc		JMP	LAB_FEBC		; restore registers and exit interrupt
.f9d5					LAB_F9D5
.f9d5	a5 92		lda $92			LDA	LAB_92		; get timing constant for tape
.f9d7	f0 07		beq $f9e0		BEQ	LAB_F9E0		;.
.f9d9	30 03		bmi $f9de		BMI	LAB_F9DE		;.
.f9db	c6 b0		dec $b0			DEC	LAB_B0		; decrement tape timing constant min byte
>f9dd	2c					.byte	$2C			; makes next line BIT LAB_B0E6
.f9de					LAB_F9DE
.f9de	e6 b0		inc $b0			INC	LAB_B0		; increment tape timing constant min byte
.f9e0					LAB_F9E0
.f9e0	a9 00		lda #$00		LDA	#$00			;.
.f9e2	85 92		sta $92			STA	LAB_92		; clear timing constant for tape
.f9e4	e4 d7		cpx $d7			CPX	LAB_D7		;.
.f9e6	d0 0f		bne $f9f7		BNE	LAB_F9F7		;.
.f9e8	8a		txa			TXA				;.
.f9e9	d0 a0		bne $f98b		BNE	LAB_F98B		;.
.f9eb	a5 a9		lda $a9			LDA	LAB_A9		; get start bit check flag
.f9ed	30 bd		bmi $f9ac		BMI	LAB_F9AC		;.
.f9ef	c9 10		cmp #$10		CMP	#$10			;.
.f9f1	90 b9		bcc $f9ac		BCC	LAB_F9AC		;.
.f9f3	85 96		sta $96			STA	LAB_96		;.save cassette block synchronization number
.f9f5	b0 b5		bcs $f9ac		BCS	LAB_F9AC		;.
.f9f7					LAB_F9F7
.f9f7	8a		txa			TXA				;.
.f9f8	45 9b		eor $9b			EOR	LAB_9B		;.
.f9fa	85 9b		sta $9b			STA	LAB_9B		;.
.f9fc	a5 b4		lda $b4			LDA	LAB_B4		;.
.f9fe	f0 d2		beq $f9d2		BEQ	LAB_F9D2		;.
.fa00	c6 a3		dec $a3			DEC	LAB_A3		;.decrement EOI flag byte
.fa02	30 c5		bmi $f9c9		BMI	LAB_F9C9		;.
.fa04	46 d7		lsr $d7			LSR	LAB_D7		;.
.fa06	66 bf		ror $bf			ROR	LAB_BF		;.parity count
.fa08	a2 da		ldx #$da		LDX	#$DA			; set timimg max byte
.fa0a	20 e2 f8	jsr $f8e2		JSR	LAB_F8E2		; set timing
.fa0d	4c bc fe	jmp $febc		JMP	LAB_FEBC		; restore registers and exit interrupt
.fa10					LAB_FA10
.fa10	a5 96		lda $96			LDA	LAB_96		;.get cassette block synchronization number
.fa12	f0 04		beq $fa18		BEQ	LAB_FA18		;.
.fa14	a5 b4		lda $b4			LDA	LAB_B4		;.
.fa16	f0 07		beq $fa1f		BEQ	LAB_FA1F		;.
.fa18					LAB_FA18
.fa18	a5 a3		lda $a3			LDA	LAB_A3		;.get EOI flag byte
.fa1a	30 03		bmi $fa1f		BMI	LAB_FA1F		;.
.fa1c	4c 97 f9	jmp $f997		JMP	LAB_F997		;.
.fa1f					LAB_FA1F
.fa1f	46 b1		lsr $b1			LSR	LAB_B1		; shift tape timing constant max byte
.fa21	a9 93		lda #$93		LDA	#$93			;.
.fa23	38		sec			SEC				;.
.fa24	e5 b1		sbc $b1			SBC	LAB_B1		; subtract tape timing constant max byte
.fa26	65 b0		adc $b0			ADC	LAB_B0		; add tape timing constant min byte
.fa28	0a		asl a			ASL				;.
.fa29	aa		tax			TAX				; copy timimg high byte
.fa2a	20 e2 f8	jsr $f8e2		JSR	LAB_F8E2		; set timing
.fa2d	e6 9c		inc $9c			INC	LAB_9C		;.
.fa2f	a5 b4		lda $b4			LDA	LAB_B4		;.
.fa31	d0 11		bne $fa44		BNE	LAB_FA44		;.
.fa33	a5 96		lda $96			LDA	LAB_96		;.get cassette block synchronization number
.fa35	f0 26		beq $fa5d		BEQ	LAB_FA5D		;.
.fa37	85 a8		sta $a8			STA	LAB_A8		; save receiver bit count in
.fa39	a9 00		lda #$00		LDA	#$00			; clear A
.fa3b	85 96		sta $96			STA	LAB_96		;.clear cassette block synchronization number
.fa3d	a9 81		lda #$81		LDA	#$81			; enable timer A interrupt
.fa3f	8d 0d dc	sta $dc0d		STA	LAB_DC0D		; save VIA 1 ICR
.fa42	85 b4		sta $b4			STA	LAB_B4		;.
.fa44					LAB_FA44
.fa44	a5 96		lda $96			LDA	LAB_96		;.get cassette block synchronization number
.fa46	85 b5		sta $b5			STA	LAB_B5		;.
.fa48	f0 09		beq $fa53		BEQ	LAB_FA53		;.
.fa4a	a9 00		lda #$00		LDA	#$00			;.
.fa4c	85 b4		sta $b4			STA	LAB_B4		;.
.fa4e	a9 01		lda #$01		LDA	#$01			; disable timer A interrupt
.fa50	8d 0d dc	sta $dc0d		STA	LAB_DC0D		; save VIA 1 ICR
.fa53					LAB_FA53
.fa53	a5 bf		lda $bf			LDA	LAB_BF		;.parity count
.fa55	85 bd		sta $bd			STA	LAB_BD		;.save RS232 parity byte
.fa57	a5 a8		lda $a8			LDA	LAB_A8		; get receiver bit count in
.fa59	05 a9		ora $a9			ORA	LAB_A9		; OR with start bit check flag
.fa5b	85 b6		sta $b6			STA	LAB_B6		;.
.fa5d					LAB_FA5D
.fa5d	4c bc fe	jmp $febc		JMP	LAB_FEBC		; restore registers and exit interrupt
.fa60					LAB_FA60
.fa60	20 97 fb	jsr $fb97		JSR	LAB_FB97		; new tape byte setup
.fa63	85 9c		sta $9c			STA	LAB_9C		; clear byte received flag
.fa65	a2 da		ldx #$da		LDX	#$DA			; set timimg max byte
.fa67	20 e2 f8	jsr $f8e2		JSR	LAB_F8E2		; set timing
.fa6a	a5 be		lda $be			LDA	LAB_BE		;.get copies count
.fa6c	f0 02		beq $fa70		BEQ	LAB_FA70		;.
.fa6e	85 a7		sta $a7			STA	LAB_A7		; save receiver input bit temporary storage
.fa70					LAB_FA70
.fa70	a9 0f		lda #$0f		LDA	#$0F			;.
.fa72	24 aa		bit $aa			BIT	LAB_AA		;.
.fa74	10 17		bpl $fa8d		BPL	LAB_FA8D		;.
.fa76	a5 b5		lda $b5			LDA	LAB_B5		;.
.fa78	d0 0c		bne $fa86		BNE	LAB_FA86		;.
.fa7a	a6 be		ldx $be			LDX	LAB_BE		;.get copies count
.fa7c	ca		dex			DEX				;.
.fa7d	d0 0b		bne $fa8a		BNE	LAB_FA8A		; if ?? restore registers and exit interrupt
.fa7f	a9 08		lda #$08		LDA	#$08			; set short block
.fa81	20 1c fe	jsr $fe1c		JSR	LAB_FE1C		; OR into serial status byte
.fa84	d0 04		bne $fa8a		BNE	LAB_FA8A		; restore registers and exit interrupt, branch always
.fa86					LAB_FA86
.fa86	a9 00		lda #$00		LDA	#$00			;.
.fa88	85 aa		sta $aa			STA	LAB_AA		;.
.fa8a					LAB_FA8A
.fa8a	4c bc fe	jmp $febc		JMP	LAB_FEBC		; restore registers and exit interrupt
.fa8d					LAB_FA8D
.fa8d	70 31		bvs $fac0		BVS	LAB_FAC0		;.
.fa8f	d0 18		bne $faa9		BNE	LAB_FAA9		;.
.fa91	a5 b5		lda $b5			LDA	LAB_B5		;.
.fa93	d0 f5		bne $fa8a		BNE	LAB_FA8A		;.
.fa95	a5 b6		lda $b6			LDA	LAB_B6		;.
.fa97	d0 f1		bne $fa8a		BNE	LAB_FA8A		;.
.fa99	a5 a7		lda $a7			LDA	LAB_A7		; get receiver input bit temporary storage
.fa9b	4a		lsr a			LSR				;.
.fa9c	a5 bd		lda $bd			LDA	LAB_BD		;.get RS232 parity byte
.fa9e	30 03		bmi $faa3		BMI	LAB_FAA3		;.
.faa0	90 18		bcc $faba		BCC	LAB_FABA		;.
.faa2	18		clc			CLC				;.
.faa3					LAB_FAA3
.faa3	b0 15		bcs $faba		BCS	LAB_FABA		;.
.faa5	29 0f		and #$0f		AND	#$0F			;.
.faa7	85 aa		sta $aa			STA	LAB_AA		;.
.faa9					LAB_FAA9
.faa9	c6 aa		dec $aa			DEC	LAB_AA		;.
.faab	d0 dd		bne $fa8a		BNE	LAB_FA8A		;.
.faad	a9 40		lda #$40		LDA	#$40			;.
.faaf	85 aa		sta $aa			STA	LAB_AA		;.
.fab1	20 8e fb	jsr $fb8e		JSR	LAB_FB8E		; copy I/O start address to buffer address
.fab4	a9 00		lda #$00		LDA	#$00			;.
.fab6	85 ab		sta $ab			STA	LAB_AB		;.
.fab8	f0 d0		beq $fa8a		BEQ	LAB_FA8A		;.
.faba					LAB_FABA
.faba	a9 80		lda #$80		LDA	#$80			;.
.fabc	85 aa		sta $aa			STA	LAB_AA		;.
.fabe	d0 ca		bne $fa8a		BNE	LAB_FA8A		; restore registers and exit interrupt, branch always
.fac0					LAB_FAC0
.fac0	a5 b5		lda $b5			LDA	LAB_B5		;.
.fac2	f0 0a		beq $face		BEQ	LAB_FACE		;.
.fac4	a9 04		lda #$04		LDA	#$04			;.
.fac6	20 1c fe	jsr $fe1c		JSR	LAB_FE1C		; OR into serial status byte
.fac9	a9 00		lda #$00		LDA	#$00			;.
.facb	4c 4a fb	jmp $fb4a		JMP	LAB_FB4A		;.
.face					LAB_FACE
.face	20 d1 fc	jsr $fcd1		JSR	LAB_FCD1		; check read/write pointer, return Cb = 1 if pointer >= end
.fad1	90 03		bcc $fad6		BCC	LAB_FAD6		;.
.fad3	4c 48 fb	jmp $fb48		JMP	LAB_FB48		;.
.fad6					LAB_FAD6
.fad6	a6 a7		ldx $a7			LDX	LAB_A7		; get receiver input bit temporary storage
.fad8	ca		dex			DEX				;.
.fad9	f0 2d		beq $fb08		BEQ	LAB_FB08		;.
.fadb	a5 93		lda $93			LDA	LAB_93		; get load/verify flag
.fadd	f0 0c		beq $faeb		BEQ	LAB_FAEB		; if load go ??
.fadf	a0 00		ldy #$00		LDY	#$00			; clear index
.fae1	a5 bd		lda $bd			LDA	LAB_BD		;.get RS232 parity byte
.fae3	d1 ac		cmp ($ac),y		CMP	(LAB_AC),Y		;.
.fae5	f0 04		beq $faeb		BEQ	LAB_FAEB		;.
.fae7	a9 01		lda #$01		LDA	#$01			;.
.fae9	85 b6		sta $b6			STA	LAB_B6		;.
.faeb					LAB_FAEB
.faeb	a5 b6		lda $b6			LDA	LAB_B6		;.
.faed	f0 4b		beq $fb3a		BEQ	LAB_FB3A		;.
.faef	a2 3d		ldx #$3d		LDX	#$3D			;.
.faf1	e4 9e		cpx $9e			CPX	LAB_9E		;.
.faf3	90 3e		bcc $fb33		BCC	LAB_FB33		;.
.faf5	a6 9e		ldx $9e			LDX	LAB_9E		;.
.faf7	a5 ad		lda $ad			LDA	LAB_AD		;.
.faf9	9d 01 01	sta $0101,x		STA	LAB_0100+1,X	;.
.fafc	a5 ac		lda $ac			LDA	LAB_AC		;.
.fafe	9d 00 01	sta $0100,x		STA	LAB_0100,X		;.
.fb01	e8		inx			INX				;.
.fb02	e8		inx			INX				;.
.fb03	86 9e		stx $9e			STX	LAB_9E		;.
.fb05	4c 3a fb	jmp $fb3a		JMP	LAB_FB3A		;.
.fb08					LAB_FB08
.fb08	a6 9f		ldx $9f			LDX	LAB_9F		;.
.fb0a	e4 9e		cpx $9e			CPX	LAB_9E		;.
.fb0c	f0 35		beq $fb43		BEQ	LAB_FB43		;.
.fb0e	a5 ac		lda $ac			LDA	LAB_AC		;.
.fb10	dd 00 01	cmp $0100,x		CMP	LAB_0100,X		;.
.fb13	d0 2e		bne $fb43		BNE	LAB_FB43		;.
.fb15	a5 ad		lda $ad			LDA	LAB_AD		;.
.fb17	dd 01 01	cmp $0101,x		CMP	LAB_0100+1,X	;.
.fb1a	d0 27		bne $fb43		BNE	LAB_FB43		;.
.fb1c	e6 9f		inc $9f			INC	LAB_9F		;.
.fb1e	e6 9f		inc $9f			INC	LAB_9F		;.
.fb20	a5 93		lda $93			LDA	LAB_93		; get load/verify flag
.fb22	f0 0b		beq $fb2f		BEQ	LAB_FB2F		; if load ??
.fb24	a5 bd		lda $bd			LDA	LAB_BD		;.get RS232 parity byte
.fb26	a0 00		ldy #$00		LDY	#$00			;.
.fb28	d1 ac		cmp ($ac),y		CMP	(LAB_AC),Y		;.
.fb2a	f0 17		beq $fb43		BEQ	LAB_FB43		;.
.fb2c	c8		iny			INY				;.
.fb2d	84 b6		sty $b6			STY	LAB_B6		;.
.fb2f					LAB_FB2F
.fb2f	a5 b6		lda $b6			LDA	LAB_B6		;.
.fb31	f0 07		beq $fb3a		BEQ	LAB_FB3A		;.
.fb33					LAB_FB33
.fb33	a9 10		lda #$10		LDA	#$10			;.
.fb35	20 1c fe	jsr $fe1c		JSR	LAB_FE1C		; OR into serial status byte
.fb38	d0 09		bne $fb43		BNE	LAB_FB43		;.
.fb3a					LAB_FB3A
.fb3a	a5 93		lda $93			LDA	LAB_93		; get load/verify flag
.fb3c	d0 05		bne $fb43		BNE	LAB_FB43		; if verify go ??
.fb3e	a8		tay			TAY				;.
.fb3f	a5 bd		lda $bd			LDA	LAB_BD		;.get RS232 parity byte
.fb41	91 ac		sta ($ac),y		STA	(LAB_AC),Y		;.
.fb43					LAB_FB43
.fb43	20 db fc	jsr $fcdb		JSR	LAB_FCDB		; increment read/write pointer
.fb46	d0 43		bne $fb8b		BNE	LAB_FB8B		; restore registers and exit interrupt, branch always
.fb48					LAB_FB48
.fb48	a9 80		lda #$80		LDA	#$80			;.
.fb4a					LAB_FB4A
.fb4a	85 aa		sta $aa			STA	LAB_AA		;.
.fb4c	78		sei			SEI				;.
.fb4d	a2 01		ldx #$01		LDX	#$01			; disable timer A interrupt
.fb4f	8e 0d dc	stx $dc0d		STX	LAB_DC0D		; save VIA 1 ICR
.fb52	ae 0d dc	ldx $dc0d		LDX	LAB_DC0D		; read VIA 1 ICR
.fb55	a6 be		ldx $be			LDX	LAB_BE		;.get copies count
.fb57	ca		dex			DEX				;.
.fb58	30 02		bmi $fb5c		BMI	LAB_FB5C		;.
.fb5a	86 be		stx $be			STX	LAB_BE		;.save copies count
.fb5c					LAB_FB5C
.fb5c	c6 a7		dec $a7			DEC	LAB_A7		; decrement receiver input bit temporary storage
.fb5e	f0 08		beq $fb68		BEQ	LAB_FB68		;.
.fb60	a5 9e		lda $9e			LDA	LAB_9E		;.
.fb62	d0 27		bne $fb8b		BNE	LAB_FB8B		; if ?? restore registers and exit interrupt
.fb64	85 be		sta $be			STA	LAB_BE		;.save copies count
.fb66	f0 23		beq $fb8b		BEQ	LAB_FB8B		; restore registers and exit interrupt, branch always
.fb68					LAB_FB68
.fb68	20 93 fc	jsr $fc93		JSR	LAB_FC93		; restore everything for STOP
.fb6b	20 8e fb	jsr $fb8e		JSR	LAB_FB8E		; copy I/O start address to buffer address
.fb6e	a0 00		ldy #$00		LDY	#$00			; clear index
.fb70	84 ab		sty $ab			STY	LAB_AB		; clear checksum
.fb72					LAB_FB72
.fb72	b1 ac		lda ($ac),y		LDA	(LAB_AC),Y		; get byte from buffer
.fb74	45 ab		eor $ab			EOR	LAB_AB		; XOR with checksum
.fb76	85 ab		sta $ab			STA	LAB_AB		; save new checksum
.fb78	20 db fc	jsr $fcdb		JSR	LAB_FCDB		; increment read/write pointer
.fb7b	20 d1 fc	jsr $fcd1		JSR	LAB_FCD1		; check read/write pointer, return Cb = 1 if pointer >= end
.fb7e	90 f2		bcc $fb72		BCC	LAB_FB72		; loop if not at end
.fb80	a5 ab		lda $ab			LDA	LAB_AB		; get computed checksum
.fb82	45 bd		eor $bd			EOR	LAB_BD		; compare with stored checksum ??
.fb84	f0 05		beq $fb8b		BEQ	LAB_FB8B		; if checksum ok restore registers and exit interrupt
.fb86	a9 20		lda #$20		LDA	#$20			; else set checksum error
.fb88	20 1c fe	jsr $fe1c		JSR	LAB_FE1C		; OR into the serial status byte
.fb8b					LAB_FB8B
.fb8b	4c bc fe	jmp $febc		JMP	LAB_FEBC		; restore registers and exit interrupt
.fb8e					LAB_FB8E
.fb8e	a5 c2		lda $c2			LDA	LAB_C2		; get I/O start address high byte
.fb90	85 ad		sta $ad			STA	LAB_AD		; set buffer address high byte
.fb92	a5 c1		lda $c1			LDA	LAB_C1		; get I/O start address low byte
.fb94	85 ac		sta $ac			STA	LAB_AC		; set buffer address low byte
.fb96	60		rts			RTS
.fb97					LAB_FB97
.fb97	a9 08		lda #$08		LDA	#$08			; eight bits to do
.fb99	85 a3		sta $a3			STA	LAB_A3		; set bit count
.fb9b	a9 00		lda #$00		LDA	#$00			; clear A
.fb9d	85 a4		sta $a4			STA	LAB_A4		; clear tape bit cycle phase
.fb9f	85 a8		sta $a8			STA	LAB_A8		; clear start bit first cycle done flag
.fba1	85 9b		sta $9b			STA	LAB_9B		; clear byte parity
.fba3	85 a9		sta $a9			STA	LAB_A9		; clear start bit check flag, set no start bit yet
.fba5	60		rts			RTS
.fba6					LAB_FBA6
.fba6	a5 bd		lda $bd			LDA	LAB_BD		; get tape write byte
.fba8	4a		lsr a			LSR				; shift lsb into Cb
.fba9	a9 60		lda #$60		LDA	#$60			; set time constant low byte for bit = 0
.fbab	90 02		bcc $fbaf		BCC	LAB_FBAF		; branch if bit was 0
.fbad					LAB_FBAD
.fbad	a9 b0		lda #$b0		LDA	#$B0			; set time constant low byte for bit = 1
.fbaf					LAB_FBAF
.fbaf	a2 00		ldx #$00		LDX	#$00			; set time constant high byte
.fbb1					LAB_FBB1
.fbb1	8d 06 dc	sta $dc06		STA	LAB_DC06		; save VIA 1 timer B low byte
.fbb4	8e 07 dc	stx $dc07		STX	LAB_DC07		; save VIA 1 timer B high byte
.fbb7	ad 0d dc	lda $dc0d		LDA	LAB_DC0D		; read VIA 1 ICR
.fbba	a9 19		lda #$19		LDA	#$19			; load timer B, timer B single shot, start timer B
.fbbc	8d 0f dc	sta $dc0f		STA	LAB_DC0F		; save VIA 1 CRB
.fbbf	a5 01		lda $01			LDA	LAB_01		; read the 6510 I/O port
.fbc1	49 08		eor #$08		EOR	#$08			; toggle tape out bit
.fbc3	85 01		sta $01			STA	LAB_01		; save the 6510 I/O port
.fbc5	29 08		and #$08		AND	#$08			; mask tape out bit
.fbc7	60		rts			RTS
.fbc8					LAB_FBC8
.fbc8	38		sec			SEC				; set carry flag
.fbc9	66 b6		ror $b6			ROR	LAB_B6		; set buffer address high byte negative, flag all sync,
.fbcb	30 3c		bmi $fc09		BMI	LAB_FC09		; restore registers and exit interrupt, branch always
.fbcd					LAB_FBCD
.fbcd	a5 a8		lda $a8			LDA	LAB_A8		; get start bit first cycle done flag
.fbcf	d0 12		bne $fbe3		BNE	LAB_FBE3		; if first cycle done go do rest of byte
.fbd1	a9 10		lda #$10		LDA	#$10			; set first start cycle time constant low byte
.fbd3	a2 01		ldx #$01		LDX	#$01			; set first start cycle time constant high byte
.fbd5	20 b1 fb	jsr $fbb1		JSR	LAB_FBB1		; write time constant and toggle tape
.fbd8	d0 2f		bne $fc09		BNE	LAB_FC09		; if first half cycle go restore registers and exit
.fbda	e6 a8		inc $a8			INC	LAB_A8		; set start bit first start cycle done flag
.fbdc	a5 b6		lda $b6			LDA	LAB_B6		; get buffer address high byte
.fbde	10 29		bpl $fc09		BPL	LAB_FC09		; if block not complete go restore registers and exit
.fbe0	4c 57 fc	jmp $fc57		JMP	LAB_FC57		; else do tape routine, block complete exit
.fbe3					LAB_FBE3
.fbe3	a5 a9		lda $a9			LDA	LAB_A9		; get start bit check flag
.fbe5	d0 09		bne $fbf0		BNE	LAB_FBF0		; if the start bit is complete go send the byte bits
.fbe7	20 ad fb	jsr $fbad		JSR	LAB_FBAD		; set time constant for bit = 1 and toggle tape
.fbea	d0 1d		bne $fc09		BNE	LAB_FC09		; if first half cycle go restore registers and exit
.fbec	e6 a9		inc $a9			INC	LAB_A9		; set start bit check flag
.fbee	d0 19		bne $fc09		BNE	LAB_FC09		; restore registers and exit interrupt, branch always
.fbf0					LAB_FBF0
.fbf0	20 a6 fb	jsr $fba6		JSR	LAB_FBA6		; send lsb from tape write byte to tape
.fbf3	d0 14		bne $fc09		BNE	LAB_FC09		; if first half cycle go restore registers and exit
.fbf5	a5 a4		lda $a4			LDA	LAB_A4		; get tape bit cycle phase
.fbf7	49 01		eor #$01		EOR	#$01			; toggle b0
.fbf9	85 a4		sta $a4			STA	LAB_A4		; save tape bit cycle phase
.fbfb	f0 0f		beq $fc0c		BEQ	LAB_FC0C		; if bit cycle phase complete go setup for next bit
.fbfd	a5 bd		lda $bd			LDA	LAB_BD		; get tape write byte
.fbff	49 01		eor #$01		EOR	#$01			; invert bit being sent
.fc01	85 bd		sta $bd			STA	LAB_BD		; save tape write byte
.fc03	29 01		and #$01		AND	#$01			; mask b0
.fc05	45 9b		eor $9b			EOR	LAB_9B		; EOR with tape write byte parity bit
.fc07	85 9b		sta $9b			STA	LAB_9B		; save tape write byte parity bit
.fc09					LAB_FC09
.fc09	4c bc fe	jmp $febc		JMP	LAB_FEBC		; restore registers and exit interrupt
.fc0c					LAB_FC0C
.fc0c	46 bd		lsr $bd			LSR	LAB_BD		; shift bit out of tape write byte
.fc0e	c6 a3		dec $a3			DEC	LAB_A3		; decrement tape write bit count
.fc10	a5 a3		lda $a3			LDA	LAB_A3		; get tape write bit count
.fc12	f0 3a		beq $fc4e		BEQ	LAB_FC4E		; if all the data bits have been written go setup for
.fc14	10 f3		bpl $fc09		BPL	LAB_FC09		; if all the data bits are not yet sent just restore the
.fc16					LAB_FC16
.fc16	20 97 fb	jsr $fb97		JSR	LAB_FB97		; new tape byte setup
.fc19	58		cli			CLI				; enable the interrupts
.fc1a	a5 a5		lda $a5			LDA	LAB_A5		; get cassette synchronization character count
.fc1c	f0 12		beq $fc30		BEQ	LAB_FC30		; if synchronisation characters done go do block data
.fc1e	a2 00		ldx #$00		LDX	#$00			; clear X
.fc20	86 d7		stx $d7			STX	LAB_D7		; clear checksum byte
.fc22	c6 a5		dec $a5			DEC	LAB_A5		; decrement cassette synchronization byte count
.fc24	a6 be		ldx $be			LDX	LAB_BE		; get cassette copies count
.fc26	e0 02		cpx #$02		CPX	#$02			; compare with load block indicator
.fc28	d0 02		bne $fc2c		BNE	LAB_FC2C		; branch if not the load block
.fc2a	09 80		ora #$80		ORA	#$80			; this is the load block so make the synchronisation count
.fc2c					LAB_FC2C
.fc2c	85 bd		sta $bd			STA	LAB_BD		; save the synchronisation byte as the tape write byte
.fc2e	d0 d9		bne $fc09		BNE	LAB_FC09		; restore registers and exit interrupt, branch always
.fc30					LAB_FC30
.fc30	20 d1 fc	jsr $fcd1		JSR	LAB_FCD1		; check read/write pointer, return Cb = 1 if pointer >= end
.fc33	90 0a		bcc $fc3f		BCC	LAB_FC3F		; if not all done yet go get the byte to send
.fc35	d0 91		bne $fbc8		BNE	LAB_FBC8		; if pointer > end go flag block done and exit interrupt
.fc37	e6 ad		inc $ad			INC	LAB_AD		; increment buffer pointer high byte, this means the block
.fc39	a5 d7		lda $d7			LDA	LAB_D7		; get checksum byte
.fc3b	85 bd		sta $bd			STA	LAB_BD		; save checksum as tape write byte
.fc3d	b0 ca		bcs $fc09		BCS	LAB_FC09		; restore registers and exit interrupt, branch always
.fc3f					LAB_FC3F
.fc3f	a0 00		ldy #$00		LDY	#$00			; clear index
.fc41	b1 ac		lda ($ac),y		LDA	(LAB_AC),Y		; get byte from buffer
.fc43	85 bd		sta $bd			STA	LAB_BD		; save as tape write byte
.fc45	45 d7		eor $d7			EOR	LAB_D7		; XOR with checksum byte
.fc47	85 d7		sta $d7			STA	LAB_D7		; save new checksum byte
.fc49	20 db fc	jsr $fcdb		JSR	LAB_FCDB		; increment read/write pointer
.fc4c	d0 bb		bne $fc09		BNE	LAB_FC09		; restore registers and exit interrupt, branch always
.fc4e					LAB_FC4E
.fc4e	a5 9b		lda $9b			LDA	LAB_9B		; get parity bit
.fc50	49 01		eor #$01		EOR	#$01			; toggle it
.fc52	85 bd		sta $bd			STA	LAB_BD		; save as tape write byte
.fc54					LAB_FC54
.fc54	4c bc fe	jmp $febc		JMP	LAB_FEBC		; restore registers and exit interrupt
.fc57					LAB_FC57
.fc57	c6 be		dec $be			DEC	LAB_BE		; decrement copies remaining to read/write
.fc59	d0 03		bne $fc5e		BNE	LAB_FC5E		; branch if more to do
.fc5b	20 ca fc	jsr $fcca		JSR	LAB_FCCA		; stop the cassette motor
.fc5e					LAB_FC5E
.fc5e	a9 50		lda #$50		LDA	#$50			; set tape write leader count
.fc60	85 a7		sta $a7			STA	LAB_A7		; save tape write leader count
.fc62	a2 08		ldx #$08		LDX	#$08			; set index for write tape leader vector
.fc64	78		sei			SEI				; disable the interrupts
.fc65	20 bd fc	jsr $fcbd		JSR	LAB_FCBD		; set the tape vector
.fc68	d0 ea		bne $fc54		BNE	LAB_FC54		; restore registers and exit interrupt, branch always
.fc6a					LAB_FC6A
.fc6a	a9 78		lda #$78		LDA	#$78			; set time constant low byte for bit = leader
.fc6c	20 af fb	jsr $fbaf		JSR	LAB_FBAF		; write time constant and toggle tape
.fc6f	d0 e3		bne $fc54		BNE	LAB_FC54		; if tape bit high restore registers and exit interrupt
.fc71	c6 a7		dec $a7			DEC	LAB_A7		; decrement cycle count
.fc73	d0 df		bne $fc54		BNE	LAB_FC54		; if not all done restore registers and exit interrupt
.fc75	20 97 fb	jsr $fb97		JSR	LAB_FB97		; new tape byte setup
.fc78	c6 ab		dec $ab			DEC	LAB_AB		; decrement cassette leader count
.fc7a	10 d8		bpl $fc54		BPL	LAB_FC54		; if not all done restore registers and exit interrupt
.fc7c	a2 0a		ldx #$0a		LDX	#$0A			; set index for tape write vector
.fc7e	20 bd fc	jsr $fcbd		JSR	LAB_FCBD		; set the tape vector
.fc81	58		cli			CLI				; enable the interrupts
.fc82	e6 ab		inc $ab			INC	LAB_AB		; clear cassette leader counter, was $FF
.fc84	a5 be		lda $be			LDA	LAB_BE		; get cassette block count
.fc86	f0 30		beq $fcb8		BEQ	LAB_FCB8		; if all done restore everything for STOP and exit the
.fc88	20 8e fb	jsr $fb8e		JSR	LAB_FB8E		; copy I/O start address to buffer address
.fc8b	a2 09		ldx #$09		LDX	#$09			; set nine synchronisation bytes
.fc8d	86 a5		stx $a5			STX	LAB_A5		; save cassette synchronization byte count
.fc8f	86 b6		stx $b6			STX	LAB_B6		;.
.fc91	d0 83		bne $fc16		BNE	LAB_FC16		; go do the next tape byte, branch always
.fc93					LAB_FC93
.fc93	08		php			PHP				; save status
.fc94	78		sei			SEI				; disable the interrupts
.fc95	ad 11 d0	lda $d011		LDA	LAB_D011		; read the vertical fine scroll and control register
.fc98	09 10		ora #$10		ORA	#$10			; mask xxx1 xxxx, unblank the screen
.fc9a	8d 11 d0	sta $d011		STA	LAB_D011		; save the vertical fine scroll and control register
.fc9d	20 ca fc	jsr $fcca		JSR	LAB_FCCA		; stop the cassette motor
.fca0	a9 7f		lda #$7f		LDA	#$7F			; disable all interrupts
.fca2	8d 0d dc	sta $dc0d		STA	LAB_DC0D		; save VIA 1 ICR
.fca5	20 dd fd	jsr $fddd		JSR	LAB_FDDD		;.
.fca8	ad a0 02	lda $02a0		LDA	LAB_02A0		; get saved IRQ vector high byte
.fcab	f0 09		beq $fcb6		BEQ	LAB_FCB6		; branch if null
.fcad	8d 15 03	sta $0315		STA	LAB_0315		; restore IRQ vector high byte
.fcb0	ad 9f 02	lda $029f		LDA	LAB_029F		; get saved IRQ vector low byte
.fcb3	8d 14 03	sta $0314		STA	LAB_0314		; restore IRQ vector low byte
.fcb6					LAB_FCB6
.fcb6	28		plp			PLP				; restore status
.fcb7	60		rts			RTS
.fcb8					LAB_FCB8
.fcb8	20 93 fc	jsr $fc93		JSR	LAB_FC93		; restore everything for STOP
.fcbb	f0 97		beq $fc54		BEQ	LAB_FC54		; restore registers and exit interrupt, branch always
.fcbd					LAB_FCBD
.fcbd	bd 93 fd	lda $fd93,x		LDA	LAB_FD9B-8,X	; get tape IRQ vector low byte
.fcc0	8d 14 03	sta $0314		STA	LAB_0314		; set IRQ vector low byte
.fcc3	bd 94 fd	lda $fd94,x		LDA	LAB_FD9B-7,X	; get tape IRQ vector high byte
.fcc6	8d 15 03	sta $0315		STA	LAB_0315		; set IRQ vector high byte
.fcc9	60		rts			RTS
.fcca					LAB_FCCA
.fcca	a5 01		lda $01			LDA	LAB_01		; read the 6510 I/O port
.fccc	09 20		ora #$20		ORA	#$20			; mask xxxx xx1x, turn the cassette motor off
.fcce	85 01		sta $01			STA	LAB_01		; save the 6510 I/O port
.fcd0	60		rts			RTS
.fcd1					LAB_FCD1
.fcd1	38		sec			SEC				; set carry for subtract
.fcd2	a5 ac		lda $ac			LDA	LAB_AC		; get buffer address low byte
.fcd4	e5 ae		sbc $ae			SBC	LAB_AE		; subtract buffer end low byte
.fcd6	a5 ad		lda $ad			LDA	LAB_AD		; get buffer address high byte
.fcd8	e5 af		sbc $af			SBC	LAB_AF		; subtract buffer end high byte
.fcda	60		rts			RTS
.fcdb					LAB_FCDB
.fcdb	e6 ac		inc $ac			INC	LAB_AC		; increment buffer address low byte
.fcdd	d0 02		bne $fce1		BNE	LAB_FCE1		; branch if no overflow
.fcdf	e6 ad		inc $ad			INC	LAB_AD		; increment buffer address low byte
.fce1					LAB_FCE1
.fce1	60		rts			RTS
.fce2					LAB_FCE2
.fce2	a2 ff		ldx #$ff		LDX	#$FF			; set X for stack
.fce4	78		sei			SEI				; disable the interrupts
.fce5	9a		txs			TXS				; clear stack
.fce6	d8		cld			CLD				; clear decimal mode
.fce7	20 02 fd	jsr $fd02		JSR	LAB_FD02		; scan for autostart ROM at $8000
.fcea	d0 03		bne $fcef		BNE	LAB_FCEF		; if not there continue startup
.fcec	6c 00 80	jmp ($8000)		JMP	(LAB_8000)		; else call ROM start code
.fcef					LAB_FCEF
.fcef	8e 16 d0	stx $d016		STX	LAB_D016		; read the horizontal fine scroll and control register
.fcf2	20 a3 fd	jsr $fda3		JSR	LAB_FDA3		; initialise SID, CIA and IRQ
.fcf5	20 50 fd	jsr $fd50		JSR	LAB_FD50		; RAM test and find RAM end
.fcf8	20 15 fd	jsr $fd15		JSR	LAB_FD15		; restore default I/O vectors
.fcfb	20 5b ff	jsr $ff5b		JSR	LAB_FF5B		; initialise VIC and screen editor
.fcfe	58		cli			CLI				; enable the interrupts
.fcff	6c 00 a0	jmp ($a000)		JMP	(LAB_A000)		; execute BASIC
.fd02					LAB_FD02
.fd02	a2 05		ldx #$05		LDX	#$05			; five characters to test
.fd04					LAB_FD04
.fd04	bd 0f fd	lda $fd0f,x		LDA	LAB_FD10-1,X	; get test character
.fd07	dd 03 80	cmp $8003,x		CMP	LAB_8004-1,X	; compare wiith byte in ROM space
.fd0a	d0 03		bne $fd0f		BNE	LAB_FD0F		; exit if no match
.fd0c	ca		dex			DEX				; decrement index
.fd0d	d0 f5		bne $fd04		BNE	LAB_FD04		; loop if not all done
.fd0f					LAB_FD0F
.fd0f	60		rts			RTS
.fd10					LAB_FD10
>fd10	c3 c2 cd 38 30				.byte	$C3,$C2,$CD,$38,$30
.fd15					LAB_FD15
.fd15	a2 30		ldx #$30		LDX	#<LAB_FD30		; pointer to vector table low byte
.fd17	a0 fd		ldy #$fd		LDY	#>LAB_FD30		; pointer to vector table high byte
.fd19	18		clc			CLC				; flag set vectors
.fd1a					LAB_FD1A
.fd1a	86 c3		stx $c3			STX	LAB_C3		; save pointer low byte
.fd1c	84 c4		sty $c4			STY	LAB_C4		; save pointer high byte
.fd1e	a0 1f		ldy #$1f		LDY	#$1F			; set byte count
.fd20					LAB_FD20
.fd20	b9 14 03	lda $0314,y		LDA	LAB_0314,Y		; read vector byte from vectors
.fd23	b0 02		bcs $fd27		BCS	LAB_FD27		; branch if read vectors
.fd25	b1 c3		lda ($c3),y		LDA	(LAB_C3),Y		; read vector byte from (XY)
.fd27					LAB_FD27
.fd27	91 c3		sta ($c3),y		STA	(LAB_C3),Y		; save byte to (XY)
.fd29	99 14 03	sta $0314,y		STA	LAB_0314,Y		; save byte to vector
.fd2c	88		dey			DEY				; decrement index
.fd2d	10 f1		bpl $fd20		BPL	LAB_FD20		; loop if more to do
.fd2f	60		rts			RTS
.fd30					LAB_FD30
>fd30	31 ea					.word	LAB_EA31		; LAB_0314	IRQ vector
>fd32	66 fe					.word	LAB_FE66		; LAB_0316	BRK vector
>fd34	47 fe					.word	LAB_FE47		; LAB_0318	NMI vector
>fd36	4a f3					.word	LAB_F34A		; LAB_031A	open a logical file
>fd38	91 f2					.word	LAB_F291		; LAB_031C	close a specified logical file
>fd3a	0e f2					.word	LAB_F20E		; LAB_031E	open channel for input
>fd3c	50 f2					.word	LAB_F250		; LAB_0320	open channel for output
>fd3e	33 f3					.word	LAB_F333		; LAB_0322	close input and output channels
>fd40	57 f1					.word	LAB_F157		; LAB_0324	input character from channel
>fd42	ca f1					.word	LAB_F1CA		; LAB_0326	output character to channel
>fd44	ed f6					.word	LAB_F6ED		; LAB_0328	scan stop key
>fd46	3e f1					.word	LAB_F13E		; LAB_032A	get character from the input device
>fd48	2f f3					.word	LAB_F32F		; LAB_032C	close all channels and files
>fd4a	66 fe					.word	LAB_FE66		; LAB_032E	user function
>fd4c	a5 f4					.word	LAB_F4A5		; LAB_0330	load
>fd4e	ed f5					.word	LAB_F5ED		; LAB_0332	save
.fd50					LAB_FD50
.fd50	a9 00		lda #$00		LDA	#$00			; clear A
.fd52	a8		tay			TAY				; clear index
.fd53					LAB_FD53
.fd53	99 02 00	sta $0002,y		STA	LAB_00+2,Y		; clear page 0, don't do $0000 or $0001
.fd56	99 00 02	sta $0200,y		STA	LAB_0200,Y		; clear page 2
.fd59	99 00 03	sta $0300,y		STA	LAB_0300,Y		; clear page 3
.fd5c	c8		iny			INY				; increment index
.fd5d	d0 f4		bne $fd53		BNE	LAB_FD53		; loop if more to do
.fd5f	a2 3c		ldx #$3c		LDX	#<LAB_033C		; set cassette buffer pointer low byte
.fd61	a0 03		ldy #$03		LDY	#>LAB_033C		; set cassette buffer pointer high byte
.fd63	86 b2		stx $b2			STX	LAB_B2		; save tape buffer start pointer low byte
.fd65	84 b3		sty $b3			STY	LAB_B3		; save tape buffer start pointer high byte
.fd67	a8		tay			TAY				; clear Y
.fd68	a9 03		lda #$03		LDA	#$03			; set RAM test pointer high byte
.fd6a	85 c2		sta $c2			STA	LAB_C2		; save RAM test pointer high byte
.fd6c					LAB_FD6C
.fd6c	e6 c2		inc $c2			INC	LAB_C2		; increment RAM test pointer high byte
.fd6e					LAB_FD6E
.fd6e	b1 c1		lda ($c1),y		LDA	(LAB_C1),Y		;.
.fd70	aa		tax			TAX				;.
.fd71	a9 55		lda #$55		LDA	#$55			;.
.fd73	91 c1		sta ($c1),y		STA	(LAB_C1),Y		;.
.fd75	d1 c1		cmp ($c1),y		CMP	(LAB_C1),Y		;.
.fd77	d0 0f		bne $fd88		BNE	LAB_FD88		;.
.fd79	2a		rol a			ROL				;.
.fd7a	91 c1		sta ($c1),y		STA	(LAB_C1),Y		;.
.fd7c	d1 c1		cmp ($c1),y		CMP	(LAB_C1),Y		;.
.fd7e	d0 08		bne $fd88		BNE	LAB_FD88		;.
.fd80	8a		txa			TXA				;.
.fd81	91 c1		sta ($c1),y		STA	(LAB_C1),Y		;.
.fd83	c8		iny			INY				;.
.fd84	d0 e8		bne $fd6e		BNE	LAB_FD6E		;.
.fd86	f0 e4		beq $fd6c		BEQ	LAB_FD6C		;.
.fd88					LAB_FD88
.fd88	98		tya			TYA				;.
.fd89	aa		tax			TAX				;.
.fd8a	a4 c2		ldy $c2			LDY	LAB_C2		;.
.fd8c	18		clc			CLC				;.
.fd8d	20 2d fe	jsr $fe2d		JSR	LAB_FE2D		; set the top of memory
.fd90	a9 08		lda #$08		LDA	#$08			;.
.fd92	8d 82 02	sta $0282		STA	LAB_0282		; save the OS start of memory high byte
.fd95	a9 04		lda #$04		LDA	#$04			;.
.fd97	8d 88 02	sta $0288		STA	LAB_0288		; save the screen memory page
.fd9a	60		rts			RTS
.fd9b					LAB_FD9B
>fd9b	6a fc					.word	LAB_FC6A		; $08	write tape leader IRQ routine
>fd9d	cd fb					.word	LAB_FBCD		; $0A	tape write IRQ routine
>fd9f	31 ea					.word	LAB_EA31		; $0C	normal IRQ vector
>fda1	2c f9					.word	LAB_F92C		; $0E	read tape bits IRQ routine
.fda3					LAB_FDA3
.fda3	a9 7f		lda #$7f		LDA	#$7F			; disable all interrupts
.fda5	8d 0d dc	sta $dc0d		STA	LAB_DC0D		; save VIA 1 ICR
.fda8	8d 0d dd	sta $dd0d		STA	LAB_DD0D		; save VIA 2 ICR
.fdab	8d 00 dc	sta $dc00		STA	LAB_DC00		; save VIA 1 DRA, keyboard column drive
.fdae	a9 08		lda #$08		LDA	#$08			; set timer single shot
.fdb0	8d 0e dc	sta $dc0e		STA	LAB_DC0E		; save VIA 1 CRA
.fdb3	8d 0e dd	sta $dd0e		STA	LAB_DD0E		; save VIA 2 CRA
.fdb6	8d 0f dc	sta $dc0f		STA	LAB_DC0F		; save VIA 1 CRB
.fdb9	8d 0f dd	sta $dd0f		STA	LAB_DD0F		; save VIA 2 CRB
.fdbc	a2 00		ldx #$00		LDX	#$00			; set all inputs
.fdbe	8e 03 dc	stx $dc03		STX	LAB_DC03		; save VIA 1 DDRB, keyboard row
.fdc1	8e 03 dd	stx $dd03		STX	LAB_DD03		; save VIA 2 DDRB, RS232 port
.fdc4	8e 18 d4	stx $d418		STX	LAB_D418		; clear the volume and filter select register
.fdc7	ca		dex			DEX				; set X = $FF
.fdc8	8e 02 dc	stx $dc02		STX	LAB_DC02		; save VIA 1 DDRA, keyboard column
.fdcb	a9 07		lda #$07		LDA	#$07			; DATA out high, CLK out high, ATN out high, RE232 Tx DATA
.fdcd	8d 00 dd	sta $dd00		STA	LAB_DD00		; save VIA 2 DRA, serial port and video address
.fdd0	a9 3f		lda #$3f		LDA	#$3F			; set serial DATA input, serial CLK input
.fdd2	8d 02 dd	sta $dd02		STA	LAB_DD02		; save VIA 2 DDRA, serial port and video address
.fdd5	a9 e7		lda #$e7		LDA	#$E7			; set 1110 0111, motor off, enable I/O, enable KERNAL,
.fdd7	85 01		sta $01			STA	LAB_01		; save the 6510 I/O port
.fdd9	a9 2f		lda #$2f		LDA	#$2F			; set 0010 1111, 0 = input, 1 = output
.fddb	85 00		sta $00			STA	LAB_00		; save the 6510 I/O port direction register
.fddd					LAB_FDDD
.fddd	ad a6 02	lda $02a6		LDA	LAB_02A6		; get the PAL/NTSC flag
.fde0	f0 0a		beq $fdec		BEQ	LAB_FDEC		; if NTSC go set NTSC timing
.fde2	a9 25		lda #$25		LDA	#$25			;.
.fde4	8d 04 dc	sta $dc04		STA	LAB_DC04		; save VIA 1 timer A low byte
.fde7	a9 40		lda #$40		LDA	#$40			;.
.fde9	4c f3 fd	jmp $fdf3		JMP	LAB_FDF3		;.
.fdec					LAB_FDEC
.fdec	a9 95		lda #$95		LDA	#$95			;.
.fdee	8d 04 dc	sta $dc04		STA	LAB_DC04		; save VIA 1 timer A low byte
.fdf1	a9 42		lda #$42		LDA	#$42			;.
.fdf3					LAB_FDF3
.fdf3	8d 05 dc	sta $dc05		STA	LAB_DC05		; save VIA 1 timer A high byte
.fdf6	4c 6e ff	jmp $ff6e		JMP	LAB_FF6E		;.
.fdf9					LAB_FDF9
.fdf9	85 b7		sta $b7			STA	LAB_B7		; set file name length
.fdfb	86 bb		stx $bb			STX	LAB_BB		; set file name pointer low byte
.fdfd	84 bc		sty $bc			STY	LAB_BC		; set file name pointer high byte
.fdff	60		rts			RTS
.fe00					LAB_FE00
.fe00	85 b8		sta $b8			STA	LAB_B8		; save the logical file
.fe02	86 ba		stx $ba			STX	LAB_BA		; save the device number
.fe04	84 b9		sty $b9			STY	LAB_B9		; save the secondary address
.fe06	60		rts			RTS
.fe07					LAB_FE07
.fe07	a5 ba		lda $ba			LDA	LAB_BA		; get the device number
.fe09	c9 02		cmp #$02		CMP	#$02			; compare device with RS232 device
.fe0b	d0 0d		bne $fe1a		BNE	LAB_FE1A		; if not RS232 device go ??
.fe0d	ad 97 02	lda $0297		LDA	LAB_0297		; get the RS232 status register
.fe10	48		pha			PHA				; save the RS232 status value
.fe11	a9 00		lda #$00		LDA	#$00			; clear A
.fe13	8d 97 02	sta $0297		STA	LAB_0297		; clear the RS232 status register
.fe16	68		pla			PLA				; restore the RS232 status value
.fe17	60		rts			RTS
.fe18					LAB_FE18
.fe18	85 9d		sta $9d			STA	LAB_9D		; set message mode flag
.fe1a					LAB_FE1A
.fe1a	a5 90		lda $90			LDA	LAB_90		; read the serial status byte
.fe1c					LAB_FE1C
.fe1c	05 90		ora $90			ORA	LAB_90		; OR with the serial status byte
.fe1e	85 90		sta $90			STA	LAB_90		; save the serial status byte
.fe20	60		rts			RTS
.fe21					LAB_FE21
.fe21	8d 85 02	sta $0285		STA	LAB_0285		; save serial bus timeout flag
.fe24	60		rts			RTS
.fe25					LAB_FE25
.fe25	90 06		bcc $fe2d		BCC	LAB_FE2D		; if Cb clear go set the top of memory
.fe27					LAB_FE27
.fe27	ae 83 02	ldx $0283		LDX	LAB_0283		; get memory top low byte
.fe2a	ac 84 02	ldy $0284		LDY	LAB_0284		; get memory top high byte
.fe2d					LAB_FE2D
.fe2d	8e 83 02	stx $0283		STX	LAB_0283		; set memory top low byte
.fe30	8c 84 02	sty $0284		STY	LAB_0284		; set memory top high byte
.fe33	60		rts			RTS
.fe34					LAB_FE34
.fe34	90 06		bcc $fe3c		BCC	LAB_FE3C		; if Cb clear go set the bottom of memory
.fe36	ae 81 02	ldx $0281		LDX	LAB_0281		; get the OS start of memory low byte
.fe39	ac 82 02	ldy $0282		LDY	LAB_0282		; get the OS start of memory high byte
.fe3c					LAB_FE3C
.fe3c	8e 81 02	stx $0281		STX	LAB_0281		; save the OS start of memory low byte
.fe3f	8c 82 02	sty $0282		STY	LAB_0282		; save the OS start of memory high byte
.fe42	60		rts			RTS
.fe43					LAB_FE43
.fe43	78		sei			SEI				; disable the interrupts
.fe44	6c 18 03	jmp ($0318)		JMP	(LAB_0318)		; do NMI vector
.fe47					LAB_FE47
.fe47	48		pha			PHA				; save A
.fe48	8a		txa			TXA				; copy X
.fe49	48		pha			PHA				; save X
.fe4a	98		tya			TYA				; copy Y
.fe4b	48		pha			PHA				; save Y
.fe4c	a9 7f		lda #$7f		LDA	#$7F			; disable all interrupts
.fe4e	8d 0d dd	sta $dd0d		STA	LAB_DD0D		; save VIA 2 ICR
.fe51	ac 0d dd	ldy $dd0d		LDY	LAB_DD0D		; save VIA 2 ICR
.fe54	30 1c		bmi $fe72		BMI	LAB_FE72		;.
.fe56	20 02 fd	jsr $fd02		JSR	LAB_FD02		; scan for autostart ROM at $8000
.fe59	d0 03		bne $fe5e		BNE	LAB_FE5E		; branch if no autostart ROM
.fe5b	6c 02 80	jmp ($8002)		JMP	(LAB_8002)		; else do autostart ROM break entry
.fe5e					LAB_FE5E
.fe5e	20 bc f6	jsr $f6bc		JSR	LAB_F6BC		; increment real time clock
.fe61	20 e1 ff	jsr $ffe1		JSR	LAB_FFE1		; scan stop key
.fe64	d0 0c		bne $fe72		BNE	LAB_FE72		; if not [STOP] restore registers and exit interrupt
.fe66					LAB_FE66
.fe66	20 15 fd	jsr $fd15		JSR	LAB_FD15		; restore default I/O vectors
.fe69	20 a3 fd	jsr $fda3		JSR	LAB_FDA3		; initialise SID, CIA and IRQ
.fe6c	20 18 e5	jsr $e518		JSR	LAB_E518		; initialise the screen and keyboard
.fe6f	6c 02 a0	jmp ($a002)		JMP	(LAB_A002)		; do BASIC break entry
.fe72					LAB_FE72
.fe72	98		tya			TYA				;.
.fe73	2d a1 02	and $02a1		AND	LAB_02A1		; AND with the RS-232 interrupt enable byte
.fe76	aa		tax			TAX				;.
.fe77	29 01		and #$01		AND	#$01			;.
.fe79	f0 28		beq $fea3		BEQ	LAB_FEA3		;.
.fe7b	ad 00 dd	lda $dd00		LDA	LAB_DD00		; read VIA 2 DRA, serial port and video address
.fe7e	29 fb		and #$fb		AND	#$FB			; mask xxxx x0xx, clear RS232 Tx DATA
.fe80	05 b5		ora $b5			ORA	LAB_B5		; OR in the RS232 transmit data bit
.fe82	8d 00 dd	sta $dd00		STA	LAB_DD00		; save VIA 2 DRA, serial port and video address
.fe85	ad a1 02	lda $02a1		LDA	LAB_02A1		; get the RS-232 interrupt enable byte
.fe88	8d 0d dd	sta $dd0d		STA	LAB_DD0D		; save VIA 2 ICR
.fe8b	8a		txa			TXA				;.
.fe8c	29 12		and #$12		AND	#$12			;.
.fe8e	f0 0d		beq $fe9d		BEQ	LAB_FE9D		;.
.fe90	29 02		and #$02		AND	#$02			;.
.fe92	f0 06		beq $fe9a		BEQ	LAB_FE9A		;.
.fe94	20 d6 fe	jsr $fed6		JSR	LAB_FED6		;.
.fe97	4c 9d fe	jmp $fe9d		JMP	LAB_FE9D		;.
.fe9a					LAB_FE9A
.fe9a	20 07 ff	jsr $ff07		JSR	LAB_FF07		;.
.fe9d					LAB_FE9D
.fe9d	20 bb ee	jsr $eebb		JSR	LAB_EEBB		;.
.fea0	4c b6 fe	jmp $feb6		JMP	LAB_FEB6		;.
.fea3					LAB_FEA3
.fea3	8a		txa			TXA				; get active interrupts back
.fea4	29 02		and #$02		AND	#$02			; mask ?? interrupt
.fea6	f0 06		beq $feae		BEQ	LAB_FEAE		; branch if not ?? interrupt
.fea8	20 d6 fe	jsr $fed6		JSR	LAB_FED6		;.
.feab	4c b6 fe	jmp $feb6		JMP	LAB_FEB6		;.
.feae					LAB_FEAE
.feae	8a		txa			TXA				; get active interrupts back
.feaf	29 10		and #$10		AND	#$10			; mask CB1 interrupt, Rx data bit transition
.feb1	f0 03		beq $feb6		BEQ	LAB_FEB6		; if no bit restore registers and exit interrupt
.feb3	20 07 ff	jsr $ff07		JSR	LAB_FF07		;.
.feb6					LAB_FEB6
.feb6	ad a1 02	lda $02a1		LDA	LAB_02A1		; get the RS-232 interrupt enable byte
.feb9	8d 0d dd	sta $dd0d		STA	LAB_DD0D		; save VIA 2 ICR
.febc					LAB_FEBC
.febc	68		pla			PLA				; pull Y
.febd	a8		tay			TAY				; restore Y
.febe	68		pla			PLA				; pull X
.febf	aa		tax			TAX				; restore X
.fec0	68		pla			PLA				; restore A
.fec1	40		rti			RTI
.fec2					LAB_FEC2
>fec2	c1 27					.word	$27C1			;   50   baud	1027700
>fec4	3e 1a					.word	$1A3E			;   75   baud	1022700
>fec6	c5 11					.word	$11C5			;  110   baud	1022780
>fec8	74 0e					.word	$0E74			;  134.5 baud	1022200
>feca	ed 0c					.word	$0CED			;  150   baud	1022700
>fecc	45 06					.word	$0645			;  300   baud	1023000
>fece	f0 02					.word	$02F0			;  600   baud	1022400
>fed0	46 01					.word	$0146			; 1200   baud	1022400
>fed2	b8 00					.word	$00B8			; 1800   baud	1022400
>fed4	71 00					.word	$0071			; 2400   baud	1022400
.fed6					LAB_FED6
.fed6	ad 01 dd	lda $dd01		LDA	LAB_DD01		; read VIA 2 DRB, RS232 port
.fed9	29 01		and #$01		AND	#$01			; mask 0000 000x, RS232 Rx DATA
.fedb	85 a7		sta $a7			STA	LAB_A7		; save the RS232 received data bit
.fedd	ad 06 dd	lda $dd06		LDA	LAB_DD06		; get VIA 2 timer B low byte
.fee0	e9 1c		sbc #$1c		SBC	#$1C			;.
.fee2	6d 99 02	adc $0299		ADC	LAB_0299		;.
.fee5	8d 06 dd	sta $dd06		STA	LAB_DD06		; save VIA 2 timer B low byte
.fee8	ad 07 dd	lda $dd07		LDA	LAB_DD07		; get VIA 2 timer B high byte
.feeb	6d 9a 02	adc $029a		ADC	LAB_029A		;.
.feee	8d 07 dd	sta $dd07		STA	LAB_DD07		; save VIA 2 timer B high byte
.fef1	a9 11		lda #$11		LDA	#$11			; set timer B single shot, start timer B
.fef3	8d 0f dd	sta $dd0f		STA	LAB_DD0F		; save VIA 2 CRB
.fef6	ad a1 02	lda $02a1		LDA	LAB_02A1		; get the RS-232 interrupt enable byte
.fef9	8d 0d dd	sta $dd0d		STA	LAB_DD0D		; save VIA 2 ICR
.fefc	a9 ff		lda #$ff		LDA	#$FF			;.
.fefe	8d 06 dd	sta $dd06		STA	LAB_DD06		; save VIA 2 timer B low byte
.ff01	8d 07 dd	sta $dd07		STA	LAB_DD07		; save VIA 2 timer B high byte
.ff04	4c 59 ef	jmp $ef59		JMP	LAB_EF59		;.
.ff07					LAB_FF07
.ff07	ad 95 02	lda $0295		LDA	LAB_0295		; nonstandard bit timing low byte
.ff0a	8d 06 dd	sta $dd06		STA	LAB_DD06		; save VIA 2 timer B low byte
.ff0d	ad 96 02	lda $0296		LDA	LAB_0296		; nonstandard bit timing high byte
.ff10	8d 07 dd	sta $dd07		STA	LAB_DD07		; save VIA 2 timer B high byte
.ff13	a9 11		lda #$11		LDA	#$11			; set timer B single shot, start timer B
.ff15	8d 0f dd	sta $dd0f		STA	LAB_DD0F		; save VIA 2 CRB
.ff18	a9 12		lda #$12		LDA	#$12			;.
.ff1a	4d a1 02	eor $02a1		EOR	LAB_02A1		; EOR with the RS-232 interrupt enable byte
.ff1d	8d a1 02	sta $02a1		STA	LAB_02A1		; save the RS-232 interrupt enable byte
.ff20	a9 ff		lda #$ff		LDA	#$FF			;.
.ff22	8d 06 dd	sta $dd06		STA	LAB_DD06		; save VIA 2 timer B low byte
.ff25	8d 07 dd	sta $dd07		STA	LAB_DD07		; save VIA 2 timer B high byte
.ff28	ae 98 02	ldx $0298		LDX	LAB_0298		;.
.ff2b	86 a8		stx $a8			STX	LAB_A8		;.
.ff2d	60		rts			RTS
.ff2e					LAB_FF2E
.ff2e	aa		tax			TAX				;.
.ff2f	ad 96 02	lda $0296		LDA	LAB_0296		; nonstandard bit timing high byte
.ff32	2a		rol a			ROL				;.
.ff33	a8		tay			TAY				;.
.ff34	8a		txa			TXA				;.
.ff35	69 c8		adc #$c8		ADC	#$C8			;.
.ff37	8d 99 02	sta $0299		STA	LAB_0299		;.
.ff3a	98		tya			TYA				;.
.ff3b	69 00		adc #$00		ADC	#$00			; add any carry
.ff3d	8d 9a 02	sta $029a		STA	LAB_029A		;.
.ff40	60		rts			RTS
.ff41	ea		nop			NOP				; waste cycles
.ff42	ea		nop			NOP				; waste cycles
.ff43					LAB_FF43
.ff43	08		php			PHP				; save the processor status
.ff44	68		pla			PLA				; pull the processor status
.ff45	29 ef		and #$ef		AND	#$EF			; mask xxx0 xxxx, clear the break bit
.ff47	48		pha			PHA				; save the modified processor status
.ff48					LAB_FF48
.ff48	48		pha			PHA				; save A
.ff49	8a		txa			TXA				; copy X
.ff4a	48		pha			PHA				; save X
.ff4b	98		tya			TYA				; copy Y
.ff4c	48		pha			PHA				; save Y
.ff4d	ba		tsx			TSX				; copy stack pointer
.ff4e	bd 04 01	lda $0104,x		LDA	LAB_0100+4,X	; get stacked status register
.ff51	29 10		and #$10		AND	#$10			; mask BRK flag
.ff53	f0 03		beq $ff58		BEQ	LAB_FF58		; branch if not BRK
.ff55	6c 16 03	jmp ($0316)		JMP	(LAB_0316)		; else do BRK vector (iBRK)
.ff58					LAB_FF58
.ff58	6c 14 03	jmp ($0314)		JMP	(LAB_0314)		; do IRQ vector (iIRQ)
.ff5b					LAB_FF5B
.ff5b	20 18 e5	jsr $e518		JSR	LAB_E518		; initialise the screen and keyboard
.ff5e					LAB_FF5E
.ff5e	ad 12 d0	lda $d012		LDA	LAB_D012		; read the raster compare register
.ff61	d0 fb		bne $ff5e		BNE	LAB_FF5E		; loop if not raster line $00
.ff63	ad 19 d0	lda $d019		LDA	LAB_D019		; read the vic interrupt flag register
.ff66	29 01		and #$01		AND	#$01			; mask the raster compare flag
.ff68	8d a6 02	sta $02a6		STA	LAB_02A6		; save the PAL/NTSC flag
.ff6b	4c dd fd	jmp $fddd		JMP	LAB_FDDD		;.
.ff6e					LAB_FF6E
.ff6e	a9 81		lda #$81		LDA	#$81			; enable timer A interrupt
.ff70	8d 0d dc	sta $dc0d		STA	LAB_DC0D		; save VIA 1 ICR
.ff73	ad 0e dc	lda $dc0e		LDA	LAB_DC0E		; read VIA 1 CRA
.ff76	29 80		and #$80		AND	#$80			; mask x000 0000, TOD clock
.ff78	09 11		ora #$11		ORA	#$11			; mask xxx1 xxx1, load timer A, start timer A
.ff7a	8d 0e dc	sta $dc0e		STA	LAB_DC0E		; save VIA 1 CRA
.ff7d	4c 8e ee	jmp $ee8e		JMP	LAB_EE8E		; set the serial clock out low and return
>ff80	03					.byte	$03			;.
.ff81	4c 5b ff	jmp $ff5b		JMP	LAB_FF5B		; initialise VIC and screen editor
.ff84	4c a3 fd	jmp $fda3		JMP	LAB_FDA3		; initialise SID, CIA and IRQ
.ff87	4c 50 fd	jmp $fd50		JMP	LAB_FD50		; RAM test and find RAM end
.ff8a	4c 15 fd	jmp $fd15		JMP	LAB_FD15		; restore default I/O vectors
.ff8d	4c 1a fd	jmp $fd1a		JMP	LAB_FD1A		; read/set vectored I/O
.ff90					LAB_FF90
.ff90	4c 18 fe	jmp $fe18		JMP	LAB_FE18		; control kernal messages
.ff93	4c b9 ed	jmp $edb9		JMP	LAB_EDB9		; send secondary address after LISTEN
.ff96	4c c7 ed	jmp $edc7		JMP	LAB_EDC7		; send secondary address after TALK
.ff99					LAB_FF99
.ff99	4c 25 fe	jmp $fe25		JMP	LAB_FE25		; read/set the top of memory
.ff9c					LAB_FF9C
.ff9c	4c 34 fe	jmp $fe34		JMP	LAB_FE34		; read/set the bottom of memory
.ff9f	4c 87 ea	jmp $ea87		JMP	LAB_EA87		; scan keyboard
.ffa2	4c 21 fe	jmp $fe21		JMP	LAB_FE21		; set timeout on serial bus
.ffa5	4c 13 ee	jmp $ee13		JMP	LAB_EE13		; input byte from serial bus
.ffa8	4c dd ed	jmp $eddd		JMP	LAB_EDDD		; output byte to serial bus
.ffab	4c ef ed	jmp $edef		JMP	LAB_EDEF		; command serial bus to UNTALK
.ffae	4c fe ed	jmp $edfe		JMP	LAB_EDFE		; command serial bus to UNLISTEN
.ffb1	4c 0c ed	jmp $ed0c		JMP	LAB_ED0C		; command devices on the serial bus to LISTEN
.ffb4	4c 09 ed	jmp $ed09		JMP	LAB_ED09		; command serial bus device to TALK
.ffb7					LAB_FFB7
.ffb7	4c 07 fe	jmp $fe07		JMP	LAB_FE07		; read I/O status word
.ffba					LAB_FFBA
.ffba	4c 00 fe	jmp $fe00		JMP	LAB_FE00		; set logical, first and second addresses
.ffbd					LAB_FFBD
.ffbd	4c f9 fd	jmp $fdf9		JMP	LAB_FDF9		; set the filename
.ffc0					LAB_FFC0
.ffc0	6c 1a 03	jmp ($031a)		JMP	(LAB_031A)		; do open a logical file
.ffc3					LAB_FFC3
.ffc3	6c 1c 03	jmp ($031c)		JMP	(LAB_031C)		; do close a specified logical file
.ffc6					LAB_FFC6
.ffc6	6c 1e 03	jmp ($031e)		JMP	(LAB_031E)		; do open channel for input
.ffc9					LAB_FFC9
.ffc9	6c 20 03	jmp ($0320)		JMP	(LAB_0320)		; do open channel for output
.ffcc					LAB_FFCC
.ffcc	6c 22 03	jmp ($0322)		JMP	(LAB_0322)		; do close input and output channels
.ffcf					LAB_FFCF
.ffcf	6c 24 03	jmp ($0324)		JMP	(LAB_0324)		; do input character from channel
.ffd2					LAB_FFD2
.ffd2	6c 26 03	jmp ($0326)		JMP	(LAB_0326)		; do output character to channel
.ffd5					LAB_FFD5
.ffd5	4c 9e f4	jmp $f49e		JMP	LAB_F49E		; load RAM from a device
.ffd8					LAB_FFD8
.ffd8	4c dd f5	jmp $f5dd		JMP	LAB_F5DD		; save RAM to device
.ffdb					LAB_FFDB
.ffdb	4c e4 f6	jmp $f6e4		JMP	LAB_F6E4		; set real time clock
.ffde					LAB_FFDE
.ffde	4c dd f6	jmp $f6dd		JMP	LAB_F6DD		; read real time clock
.ffe1					LAB_FFE1
.ffe1	6c 28 03	jmp ($0328)		JMP	(LAB_0328)		; do scan stop key
.ffe4					LAB_FFE4
.ffe4	6c 2a 03	jmp ($032a)		JMP	(LAB_032A)		; do get character from input device
.ffe7					LAB_FFE7
.ffe7	6c 2c 03	jmp ($032c)		JMP	(LAB_032C)		; do close all channels and files
.ffea					LAB_FFEA
.ffea	4c 9b f6	jmp $f69b		JMP	LAB_F69B		; increment real time clock
.ffed	4c 05 e5	jmp $e505		JMP	LAB_E505		; return X,Y organization of screen
.fff0					LAB_FFF0
.fff0	4c 0a e5	jmp $e50a		JMP	LAB_E50A		; read/set X,Y cursor position
.fff3					LAB_FFF3
.fff3	4c 00 e5	jmp $e500		JMP	LAB_E500		; return the base address of the I/O devices
>fff6	52 52 42 59				.text	"RRBY"
>fffa	43 fe					.word	LAB_FE43		; NMI vector
>fffc	e2 fc					.word	LAB_FCE2		; RESET vector
>fffe	48 ff					.word	LAB_FF48		; IRQ vector

;******  End of listing
