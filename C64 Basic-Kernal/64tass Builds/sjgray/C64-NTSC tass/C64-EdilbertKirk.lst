
; 64tass Turbo Assembler Macro V1.53.1515 listing file
; 64tass -L C64-EdilbertKirk.lst -o C64-EdilbertKirk.prg C64-EdilbertKirk.asm
; Wed Feb 07 18:19:33 2018

;Offset	;Hex		;Monitor	;Source

;******  Processing input file: C64-EdilbertKirk.asm

=1					C64 = 1        ; set to 1 for assembling the C64 ROM images
=0					VIC = 1 - C64  ;     or 0 for assembling the VIC ROM images
=0					JIFFY = 0      ; set to 1 for JIFFY DOS
=0					PAL   = 0      ; set to 0 for NTSC
=$d000					VIC_BASE      = $D000
=$d011					VIC_CONTROL_1 = $D011
=$d012					VIC_RASTER    = $D012
=$d015					VIC_SPR_ENA   = $D015
=$d016					VIC_CONTROL_2 = $D016
=$2f					VIC_REGS = $2F
=$dc00					CIA1_PRA   = $DC00   ; CIA1 Peripheral data Register A
=$dc01					CIA1_PRB   = $DC01   ; CIA1 Peripheral data Register B
=$dc02					CIA1_DDRA  = $DC02   ; CIA1 Data Direction  Register A
=$dc03					CIA1_DDRB  = $DC03   ; CIA1 Data Direction  Register B
=$dc04					CIA1_TALO  = $DC04   ; CIA1 Timer A Low  register
=$dc05					CIA1_TAHI  = $DC05   ; CIA1 Timer A High register
=$dc06					CIA1_TBLO  = $DC06   ; CIA1 Timer B Low  register
=$dc07					CIA1_TBHI  = $DC07   ; CIA1 Timer B High register
=$dc08					CIA1_TODT  = $DC08   ; CIA1 Time Of Day 1/10 seconds
=$dc09					CIA1_TODS  = $DC09   ; CIA1 Time Of Day seconds
=$dc0a					CIA1_TODM  = $DC0A   ; CIA1 Time Of Day minutes
=$dc0b					CIA1_TODH  = $DC0B   ; CIA1 Time Of Day hours
=$dc0c					CIA1_SDR   = $DC0C   ; CIA1 Serial Data Register
=$dc0d					CIA1_ICR   = $DC0D   ; CIA1 Interrupt Control Register
=$dc0e					CIA1_CRA   = $DC0E   ; CIA1 Control Register A
=$dc0f					CIA1_CRB   = $DC0F   ; CIA1 Control Register B
=$dd00					CIA2_PRA   = $DD00   ; CIA2 Peripheral data Register A
=$dd01					CIA2_PRB   = $DD01   ; CIA2 Peripheral data Register B
=$dd02					CIA2_DDRA  = $DD02   ; CIA2 Data Direction  Register A
=$dd03					CIA2_DDRB  = $DD03   ; CIA2 Data Direction  Register B
=$dd04					CIA2_TALO  = $DD04   ; CIA2 Timer A Low  register
=$dd05					CIA2_TAHI  = $DD05   ; CIA2 Timer A High register
=$dd06					CIA2_TBLO  = $DD06   ; CIA2 Timer B Low  register
=$dd07					CIA2_TBHI  = $DD07   ; CIA2 Timer B High register
=$dd08					CIA2_TODT  = $DD08   ; CIA2 Time Of Day 1/10 seconds
=$dd09					CIA2_TODS  = $DD09   ; CIA2 Time Of Day seconds
=$dd0a					CIA2_TODM  = $DD0A   ; CIA2 Time Of Day minutes
=$dd0b					CIA2_TODH  = $DD0B   ; CIA2 Time Of Day hours
=$dd0c					CIA2_SDR   = $DD0C   ; CIA2 Serial Data Register
=$dd0d					CIA2_ICR   = $DD0D   ; CIA2 Interrupt Control Register
=$dd0e					CIA2_CRA   = $DD0E   ; CIA2 Control Register A
=$dd0f					CIA2_CRB   = $DD0F   ; CIA2 Control Register B
=$dc00					KEYB_COL   = CIA1_PRA
=$dc01					KEYB_ROW   = CIA1_PRB
=$dc01					KEYB_ROWN  = CIA1_PRB
=$7f					CTRL_COL = %01111111 ; $7f = col 7
=$fb					CTRL_ROW = %11111011 ; $fb = row 2
=$7f					STND_COL = %01111111 ; $7f = col 7
=0					D6510       =     0
=1					R6510       =     1
=$dc0d					VIA2_IER = CIA1_ICR    ; CIA1 Interrupt Control Register
=$dc07					VIA2_T2CH= $DC07
=$dc06					VIA2_T2CL= $DC06
=$dc04					VIA2_T1CL= $DC04
=$dc05					VIA2_T1CH= $DC05
=40					COLS          =  40
=25					ROWS          =  25
=2					COLINK        =   2
=80					COLMAX        =  80
=$d8					COLRAM_PAGE   = $D8
=14					Default_Color = 14   ; Light blue
=$d018					MEM_CONTROL   = $D018
=$dc07					IEC_TIM_H     = $DC07; CIA 1 TIH, timer high
=$dc0d					IEC_IFR       = CIA1_ICR    ; CIA 1 CRB, interrupt flag register
=$dd00					IEC_PCR       = $DD00; VIA 2 peripheral control register (PCR)
=$dd00					IEC_DRAN      = $DD00; CIA 2 DRA, IEC bus
=$dd01					RS2_DSR_CTS   = $DD01
=$dd0d					RS2_IRQ_REG   = CIA2_ICR
=$dd04					RS2_TIM_LOW   = $DD04
=$dd05					RS2_TIM_HIG   = $DD05
=$08					IEC_ATN_BIT   = $08
=$02					IEC_IFR_BIT   = $02
=$10					IEC_CLK_BIT   = %00010000; $10
=$20					IEC_DAT_BIT   = %00100000; $20
=$04					RS232_C_BIT   = %00000100; $04
=$0400					BASIC_SCREEN    = $0400
=$0800					BASIC_RAM_START = $0800
=$8000					OPTION_ROM      = $8000
=$a000					BASIC_ROM       = $A000
=$0d					CR    = $0D ; Carriage Return
=$0a					LF    = $0A ; Line Feed
=$22					QUOTE = $22 ; Quote
=$3b					SEMIC = $3B ; Semicolon
=$03					ADRAY1 = $03         ; float to fixed vector (Float_To_Integer)
=$05					ADRAY2 = $05         ; fixed to float vector (Integer_To_Float)
=$07					CHARAC = $07         ; search character
=$08					ENDCHR = $08         ; scan quotes flag
=$09					TRMPOS = $09         ; TAB column save
=$0a					VERCK  = $0A         ; load/verify flag, 0 = load, 1 = verify
=$0b					COUNT  = $0B         ; line crunch/array access/logic operators
=$0c					DIMFLG = $0C         ; DIM flag
=$0d					VALTYP = $0D         ; data type flag, $FF = string, $00 = numeric
=$0e					INTFLG = $0E         ; data type flag, $80 = integer, $00 = floating pt.
=$0f					GARBFL = $0F         ; garbage collected/open quote/DATA flag
=$10					SUBFLG = $10         ; subscript/FNx flag
=$11					INPFLG = $11         ; input mode, $00 = INPUT, $40 = GET, $98 = READ
=$12					TANSGN = $12         ; ATN sign/comparison evaluation flag
=$13					IOPMPT = $13         ; current I/O channel
=$14					LINNUM = $14         ; temporary integer
=$16					TEMPPT = $16         ; descriptor stack pointer, next free
=$17					LASTPT = $17         ; current descriptor stack item pointer
=$19					TEMPST = $19         ; to $21, descriptor stack
=$22					INDEXA = $22         ; misc temp word
=$24					INDEXB = $24         ; misc temp word
=$25					FAC3   = $25         ; auxiliary Floating Point Accumulator
=$2b					TXTTAB = $2B         ; start of memory
=$2d					VARTAB = $2D         ; start of variables
=$2f					ARYTAB = $2F         ; end of variables
=$31					STREND = $31         ; end of arrays
=$33					FRESPC = $33         ; bottom of string space
=$35					UTLSTP = $35         ; string utility ptr
=$37					MEMSIZ = $37         ; end of memory
=$39					CURLIN = $39         ; current line number
=$3b					OLDLIN = $3B         ; break line number
=$3d					OLDTXT = $3D         ; continue pointer
=$3f					DATLIN = $3F         ; current DATA line number
=$41					DATPTR = $41         ; DATA pointer
=$43					INPPTR = $43         ; READ pointer
=$45					VARNAM = $45         ; current variable name
=$47					VARPNT = $47         ; current variable address
=$49					FORPNT = $49         ; FOR/NEXT variable pointer
=$4b					YSAVE  = $4B         ; BASIC execute pointer temporary/precedence flag
=$4d					ACCSYM = $4D         ; comparrison evaluation flag
=$4e					FUNCPT = $4E         ; FAC temp store/function/variable/garbage pointer
=$50					DESCPT = $50         ; FAC temp store/descriptor pointer
=$53					GARBSS = $53         ; garbage collection step size
=$54					JUMPER = $54         ; JMP opcode for functions
=$55					FUNJMP = $55         ; functions jump vector
=$56					FAC2M5 = $56         ; FAC2 mantissa 5 = rounding byte
=$57					FACTPA = $57         ; FAC temp store ($57 - $5B)
=$58					TMPPTA = $58         ; temp pointer A
=$5a					TMPPTB = $5A         ; temp pointer B
=$5c					FACTPB = $5C         ; FAC temp store ($5C - $60)
=$5d					TMPVA1 = $5D         ; temp variable (counter)
=$5e					TMPVA2 = $5E         ; temp variable (counter)
=$5f					TMPPTC = $5F         ; temp pointer C
=$61					FAC1EX = $61         ; FAC1 exponent
=$62					FAC1M1 = $62         ; FAC1 mantissa 1
=$63					FAC1M2 = $63         ; FAC1 mantissa 2
=$64					FAC1M3 = $64         ; FAC1 mantissa 3
=$65					FAC1M4 = $65         ; FAC1 mantissa 4
=$66					FAC1SI = $66         ; FAC1 sign
=$67					SGNFLG = $67         ; constant count/negative flag
=$68					FAC1OV = $68         ; FAC1 overflow
=$69					FAC2EX = $69         ; FAC2 exponent
=$6a					FAC2M1 = $6A         ; FAC2 mantissa 1
=$6b					FAC2M2 = $6B         ; FAC2 mantissa 2
=$6c					FAC2M3 = $6C         ; FAC2 mantissa 3
=$6d					FAC2M4 = $6D         ; FAC2 mantissa 4
=$6e					FAC2SI = $6E         ; FAC2 sign
=$6f					STRPTR = $6F         ; string pointer & FAC variables
=$70					FAC1M5 = $70         ; FAC1 mantissa 5 = rounding byte
=$71					TMPPTD = $71         ; temp BASIC execute/array pointer low byte/index
=$73					CHRGET = $73         ; next program byte, BASIC byte get
=$79					CHRGOT = $79         ; scan memory, BASIC byte get
=$7a					TXTPTR = $7A         ; BASIC execute pointer
=$80					ISNUM  = $80         ; numeric test entry
=$8b					RNDX   = $8B         ; RND() seed, five bytes
=$90					STATUS = $90         ; serial status byte
=$91					STKEY  = $91         ; keyboard row, bx = 0 = key down
=$92					SVXT   = $92         ; timing constant for tape read
=$93					VERCKK = $93         ; load/verify flag, load = $00, verify = $01
=$94					C3PO   = $94         ; serial output: deferred character flag
=$95					BSOUR  = $95         ; serial output: deferred character
=$96					SYNO   = $96         ; cassette block synchronization number
=$97					TEMPX  = $97         ; register save
=$98					LDTND  = $98         ; open file count
=$99					DFLTN  = $99         ; input device number
=$9a					DFLTO  = $9A         ; output device number
=$9b					PRTY   = $9B         ; tape character parity
=$9c					DPSW   = $9C         ; byte received flag
=$9d					MSGFLG = $9D         ; message mode flag,
=$9e					PTR1   = $9E         ; index to cassette file name/header ID
=$9f					PTR2   = $9F         ; tape Pass 2 error log corrected
=$a0					JIFFYH = $A0         ; jiffy clock high byte
=$a1					JIFFYM = $A1         ; jiffy clock mid byte
=$a2					JIFFYL = $A2         ; jiffy clock low byte
=$a3					TSFCNT = $A3         ; EOI flag byte/tape bit count or Jiffy device flag
=$a4					TBTCNT = $A4         ; tape bit cycle phase
=$a5					CNTDN  = $A5         ; tape synch byte count/serial bus bit count
=$a6					BUFPNT = $A6         ; tape buffer index
=$a7					INBIT  = $A7         ; receiver input bit temp storage
=$a8					BITCI  = $A8         ; receiver bit count in
=$a9					RINONE = $A9         ; receiver start bit check flag, $90 = no start bit
=$aa					RIDATA = $AA         ; receiver byte buffer/assembly location
=$ab					RIPRTY = $AB         ; receiver parity bit storage
=$ac					SAL    = $AC         ; tape buffer start pointer; scroll screen
=$ae					EAL    = $AE         ; tape buffer end   pointer; scroll screen
=$b0					CMPO   = $B0         ; tape timing constant (word)
=$b2					TAPE1  = $B2         ; tape buffer start pointer
=$b4					BITTS  = $B4         ; transmitter bit count out
=$b5					NXTBIT = $B5         ; transmitter next bit to be sent
=$b6					RODATA = $B6         ; transmitter byte buffer/disassembly location
=$b7					FNLEN  = $B7         ; file name length
=$b8					LA     = $B8         ; logical file
=$b9					SA     = $B9         ; secondary address
=$ba					FA     = $BA         ; current device number
=$bb					FNADR  = $BB         ; file name pointer
=$bd					ROPRTY = $BD         ; tape write byte/RS232 parity byte
=$be					FSBLK  = $BE         ; tape copies count
=$bf					MYCH   = $BF         ; parity count ??
=$c0					CAS1   = $C0         ; tape motor interlock
=$c1					STAL   = $C1         ; I/O start addresses
=$c3					MEMUSS = $C3         ; kernal setup pointer
=$c5					LSTX   = $C5         ; current key pressed
=$c6					NDX    = $C6         ; keyboard buffer length/index
=$c7					RVS    = $C7         ; reverse flag $12 = reverse, $00 = normal
=$c8					INDX   = $C8         ; input [EOL] pointer
=$c9					ICRROW = $C9         ; input cursor row
=$ca					ICRCOL = $CA         ; input cursor column
=$cb					SFDX   = $CB         ; which key
=$cc					BLNSW  = $CC         ; cursor enable, $00 = flash cursor
=$cd					BLNCT  = $CD         ; cursor timing countdown
=$ce					GDBLN  = $CE         ; character under cursor
=$cf					BLNON  = $CF         ; cursor blink phase
=$d0					INSRC  = $D0         ; input from keyboard or screen
=$d1					LINPTR = $D1         ; current screen line pointer
=$d3					CSRIDX = $D3         ; cursor column
=$d4					CSRMOD = $D4         ; cursor quote flag
=$d5					LINLEN = $D5         ; current screen line length
=$d6					TBLX   = $D6         ; cursor row
=$d7					LASTKY = $D7         ; checksum byte/temporary last character
=$d8					INSRTO = $D8         ; insert count
=$d9					SLLTBL = $D9         ; to SLLTBL + $18 inclusive, screen line link table
=$f3					USER   = $F3         ; colour RAM pointer
=$f5					KBDPTR = $F5         ; keyboard pointer
=$f7					RXPTR  = $F7         ; RS232 Rx pointer
=$f9					TXPTR  = $F9         ; RS232 Tx pointer
=$ff					BASSTO = $FF         ; FAC1 to string output base
=$0100					STACK  = $0100       ; bottom of the stack page
=$0200					BUF    = $0200       ;   input buffer. for some routines the byte before
=$0259					FILTBL = $0259       ;   .. to $0262 logical file table
=$0263					DEVTBL = $0263       ;   .. to $026C device number table
=$026d					SECATB = $026D       ;   .. to $0276 secondary address table
=$0277					KBUFFR = $0277       ;   .. to $0280 keyboard buffer
=$0281					OSSTAR = $0281       ;   OS start of memory low byte
=$0283					OSTOP  = $0283       ;   OS top of memory low byte
=$0285					STIMOT = $0285       ;   serial bus timeout flag
=$0286					COLOR  = $0286       ;   current colour code
=$0287					CSRCLR = $0287       ;   colour under cursor
=$0288					SCNMPG = $0288       ;   screen memory page
=$0289					KBMAXL = $0289       ;   maximum keyboard buffer size
=$028a					KEYRPT = $028A       ;   key repeat. $80 = repeat all, $40 = repeat none,
=$028b					KRPTSP = $028B       ;   repeat speed counter
=$028c					KRPTDL = $028C       ;   repeat delay counter
=$028d					SHFLAG   = $028D     ; keyboard shift/control flag
=$028e					LSTSHF   = $028E     ; SHIFT/CTRL/C= keypress last pattern
=$028f					KEYLOG   = $028F     ; keyboard decode logic pointer
=$0291					MODE     = $0291     ; shift mode switch, $00 = enabled, $80 = locked
=$0292					AUTODN   = $0292     ; screen scrolling flag, $00 = enabled
=$0293					M51CTR   = $0293     ; pseudo 6551 control register. the first character of
=$0294					M51CDR   = $0294     ; pseudo 6551 command register. the second character of
=$0295					M51AJB   = $0295     ; Nonstandard Bit Timing. the third and fourth character
=$0297					RSSTAT   = $0297     ; RS-232 status register
=$0298					BITNUM   = $0298     ; number of bits to be sent/received
=$0299					BAUDOF   = $0299     ; time of one bit cell
=$029b					RIDBE    = $029B     ; index to Rx buffer end
=$029c					RIDBS    = $029C     ; index to Rx buffer start
=$029d					RODBS    = $029D     ; index to Tx buffer start
=$029e					RODBE    = $029E     ; index to Tx buffer end
=$029f					IRQTMP   = $029F     ; saved IRQ
=$02a1					ENABL    = $02A1
=$02a2					TODSNS   = $02A2
=$02a3					TRDTMP   = $02A3
=$02a4					TD1IRQ   = $02A4
=$02a5					SCROWM   = $02A5     ; screen row marker
=$02a6					TVSFLG   = $02A6     ; PAL / NTSC flag
=$0300					IERROR   = $0300     ; vector to the print BASIC error message routine
=$0302					IMAIN    = $0302     ; Vector to the main BASIC program Loop
=$0304					ICRNCH   = $0304     ; Vector to the the ASCII text to keywords routine
=$0306					IQPLOP   = $0306     ; Vector to the list BASIC program as ASCII routine
=$0308					IGONE    = $0308     ; Vector to the execute next BASIC command routine
=$030a					IEVAL    = $030A     ; Vector to the get value from BASIC line routine
=$030c					SAREG    = $030C     ; A for SYS command
=$030d					SXREG    = $030D     ; X for SYS command
=$030e					SYREG    = $030E     ; Y for SYS command
=$030f					SPREG    = $030F     ; P for SYS command
=$0310					Basic_USR= $0310     ; USR() JMP instruction ($4C)
=$0311					USRVEC   = $0311     ; USR() vector
=$0314					CINV     = $0314     ; IRQ vector
=$0316					CBINV    = $0316     ; BRK vector
=$0318					NMINV    = $0318     ; NMI vector
=$031a					IOPEN    = $031A     ; kernal vector - open a logical file
=$031c					ICLOSE   = $031C     ; kernal vector - close a logical file
=$031e					ICHKIN   = $031E     ; kernal vector - open channel for input
=$0320					ICKOUT   = $0320     ; kernal vector - open channel for output
=$0322					ICLRCH   = $0322     ; kernal vector - close input and output channels
=$0324					IBASIN   = $0324     ; kernal vector - input character from channel
=$0326					IBSOUT   = $0326     ; kernal vector - output character to channel
=$0328					ISTOP    = $0328     ; kernal vector - check if stop key is pressed
=$032a					IGETIN   = $032A     ; kernal vector - get character from keyboard queue
=$032c					ICLALL   = $032C     ; kernal vector - close all channels and files
=$032e					USRCMD   = $032E     ; kernal vector - user IRQ
=$0330					ILOAD    = $0330     ; kernal vector - load
=$0332					ISAVE    = $0332     ; kernal vector - save
=$033c					TBUFFR   = $033C     ; to $03FB - cassette buffer
=$dc00					   IO_Base_Address = $DC00
=$80					TK_END     = $80   ; END token
=$81					TK_FOR     = $81   ; FOR token
=$82					TK_NEXT    = $82   ; NEXT token
=$83					TK_DATA    = $83   ; DATA token
=$84					TK_INFL    = $84   ; INPUT# token
=$85					TK_INPUT   = $85   ; INPUT token
=$86					TK_DIM     = $86   ; DIM token
=$87					TK_READ    = $87   ; READ token
=$88					TK_LET     = $88   ; LET token
=$89					TK_GOTO    = $89   ; GOTO token
=$8a					TK_RUN     = $8A   ; RUN token
=$8b					TK_IF      = $8B   ; IF token
=$8c					TK_RESTORE = $8C   ; RESTORE token
=$8d					TK_GOSUB   = $8D   ; GOSUB token
=$8e					TK_RETURN  = $8E   ; RETURN token
=$8f					TK_REM     = $8F   ; REM token
=$90					TK_STOP    = $90   ; STOP token
=$91					TK_ON      = $91   ; ON token
=$92					TK_WAIT    = $92   ; WAIT token
=$93					TK_LOAD    = $93   ; LOAD token
=$94					TK_SAVE    = $94   ; SAVE token
=$95					TK_VERIFY  = $95   ; VERIFY token
=$96					TK_DEF     = $96   ; DEF token
=$97					TK_POKE    = $97   ; POKE token
=$98					TK_PRINFL  = $98   ; PRINT# token
=$99					TK_PRINT   = $99   ; PRINT token
=$9a					TK_CONT    = $9A   ; CONT token
=$9b					TK_LIST    = $9B   ; LIST token
=$9c					TK_CLR     = $9C   ; CLR token
=$9d					TK_CMD     = $9D   ; CMD token
=$9e					TK_SYS     = $9E   ; SYS token
=$9f					TK_OPEN    = $9F   ; OPEN token
=$a0					TK_CLOSE   = $A0   ; CLOSE token
=$a1					TK_GET     = $A1   ; GET token
=$a2					TK_NEW     = $A2   ; NEW token
=$a3					TK_TAB     = $A3   ; TAB( token
=$a4					TK_TO      = $A4   ; TO token
=$a5					TK_FN      = $A5   ; FN token
=$a6					TK_SPC     = $A6   ; SPC( token
=$a7					TK_THEN    = $A7   ; THEN token
=$a8					TK_NOT     = $A8   ; NOT token
=$a9					TK_STEP    = $A9   ; STEP token
=$aa					TK_PLUS    = $AA   ; + token
=$ab					TK_MINUS   = $AB   ; - token
=$ac					TK_MUL     = $AC   ; * token
=$ad					TK_DIV     = $AD   ; / token
=$ae					TK_POWER   = $AE   ; ^ token
=$af					TK_AND     = $AF   ; AND token
=$b0					TK_OR      = $B0   ; OR token
=$b1					TK_GT      = $B1   ; > token
=$b2					TK_EQUAL   = $B2   ; = token
=$b3					TK_LT      = $B3   ; < token
=$b4					TK_SGN     = $B4   ; SGN token
=$b5					TK_INT     = $B5   ; INT token
=$b6					TK_ABS     = $B6   ; ABS token
=$b7					TK_USR     = $B7   ; USR token
=$b8					TK_FRE     = $B8   ; FRE token
=$b9					TK_POS     = $B9   ; POS token
=$ba					TK_SQR     = $BA   ; SQR token
=$bb					TK_RND     = $BB   ; RND token
=$bc					TK_LOG     = $BC   ; LOG token
=$bd					TK_EXP     = $BD   ; EXP token
=$be					TK_COS     = $BE   ; COS token
=$bf					TK_SIN     = $BF   ; SIN token
=$c0					TK_TAN     = $C0   ; TAN token
=$c1					TK_ATN     = $C1   ; ATN token
=$c2					TK_PEEK    = $C2   ; PEEK token
=$c3					TK_LEN     = $C3   ; LEN token
=$c4					TK_STRS    = $C4   ; STR$ token
=$c5					TK_VAL     = $C5   ; VAL token
=$c6					TK_ASC     = $C6   ; ASC token
=$c7					TK_CHRS    = $C7   ; CHR$ token
=$c8					TK_LEFTS   = $C8   ; LEFT$ token
=$c9					TK_RIGHTS  = $C9   ; RIGHT$ token
=$ca					TK_MIDS    = $CA   ; MID$ token
=$cb					TK_GO      = $CB   ; GO token
=$ff					TK_PI      = $FF   ; PI token
>a000	94 e3				          .word   Basic_Cold_Start
>a002	7b e3				BASIC_BRK .word   Basic_Warm_Start
>a004	43 42 4d 42 41 53 49 43		BASIC_ID  .TEXT   "CBMBASIC"
.a00c					  Basic_Statement_Table
>a00c	30 a8				   .word Basic_END      -1; $80
>a00e	41 a7				   .word Basic_FOR      -1; $81
>a010	1d ad				   .word Basic_NEXT     -1; $82
>a012	f7 a8				   .word Basic_DATA     -1; $83
>a014	a4 ab				   .word Basic_INPUTN   -1; $84
>a016	be ab				   .word Basic_INPUT    -1; $85
>a018	80 b0				   .word Basic_DIM      -1; $86
>a01a	05 ac				   .word Basic_READ     -1; $87
>a01c	a4 a9				   .word Basic_LET      -1; $88
>a01e	9f a8				   .word Basic_GOTO     -1; $89
>a020	70 a8				   .word Basic_RUN      -1; $8A
>a022	27 a9				   .word Basic_IF       -1; $8B
>a024	1c a8				   .word Basic_RESTORE  -1; $8C
>a026	82 a8				   .word Basic_GOSUB    -1; $8D
>a028	d1 a8				   .word Basic_RETURN   -1; $8E
>a02a	3a a9				   .word Basic_REM      -1; $8F
>a02c	2e a8				   .word Basic_STOP     -1; $90
>a02e	4a a9				   .word Basic_ON       -1; $91
>a030	2c b8				   .word Basic_WAIT     -1; $92
>a032	67 e1				   .word Basic_LOAD     -1; $93
>a034	55 e1				   .word Basic_SAVE     -1; $94
>a036	64 e1				   .word Basic_VERIFY   -1; $95
>a038	b2 b3				   .word Basic_DEF      -1; $96
>a03a	23 b8				   .word Basic_POKE     -1; $97
>a03c	7f aa				   .word Basic_PRINTN   -1; $98
>a03e	9f aa				   .word Basic_PRINT    -1; $99
>a040	56 a8				   .word Basic_CONT     -1; $9A
>a042	9b a6				   .word Basic_LIST     -1; $9B
>a044	5d a6				   .word Basic_CLR      -1; $9C
>a046	85 aa				   .word Basic_CMD      -1; $9D
>a048	29 e1				   .word Basic_SYS      -1; $9E
>a04a	bd e1				   .word Basic_OPEN     -1; $9F
>a04c	c6 e1				   .word Basic_CLOSE    -1; $A0
>a04e	7a ab				   .word Basic_GET      -1; $A1
>a050	41 a6				   .word Basic_NEW      -1; $A2
.a052					  Basic_Function_Table
>a052	39 bc				   .word Basic_SGN   ; $B4
>a054	cc bc				   .word Basic_INT   ; $B5
>a056	58 bc				   .word Basic_ABS   ; $B6
>a058	10 03				   .word Basic_USR   ; $B7
>a05a	7d b3				   .word Basic_FRE   ; $B8
>a05c	9e b3				   .word Basic_POS   ; $B9
>a05e	71 bf				   .word Basic_SQR   ; $BA
>a060	97 e0				   .word Basic_RND   ; $BB
>a062	ea b9				   .word Basic_LOG   ; $BC
>a064	ed bf				   .word Basic_EXP   ; $BD
>a066	64 e2				   .word Basic_COS   ; $BE
>a068	6b e2				   .word Basic_SIN   ; $BF
>a06a	b4 e2				   .word Basic_TAN   ; $C0
>a06c	0e e3				   .word Basic_ATN   ; $C1
>a06e	0d b8				   .word Basic_PEEK  ; $C2
>a070	7c b7				   .word Basic_LEN   ; $C3
>a072	65 b4				   .word Basic_STR   ; $C4
>a074	ad b7				   .word Basic_VAL   ; $C5
>a076	8b b7				   .word Basic_ASC   ; $C6
>a078	ec b6				   .word Basic_CHR   ; $C7
>a07a	00 b7				   .word Basic_LEFT  ; $C8
>a07c	2c b7				   .word Basic_RIGHT ; $C9
>a07e	37 b7				   .word Basic_MID   ; $CA
.a080					  Basic_Operator_Table
>a080	79 69 b8			   .byte $79,<Basic_PLUS-1     ,>Basic_PLUS-1     ; $AA
>a083	79 52 b8			   .byte $79,<Basic_MINUS-1    ,>Basic_MINUS-1    ; $AB
>a086	7b 2a ba			   .byte $7B,<Basic_MULTIPLY-1 ,>Basic_MULTIPLY-1 ; $AC
>a089	7b 11 bb			   .byte $7B,<Basic_DIVIDE-1   ,>Basic_DIVIDE-1   ; $AD
>a08c	7f 7a bf			   .byte $7F,<Basic_POWER-1    ,>Basic_POWER-1    ; $AE
>a08f	50 e8 af			   .byte $50,<Basic_AND-1      ,>Basic_AND-1      ; $AF
>a092	46 e5 af			   .byte $46,<Basic_OR-1       ,>Basic_OR-1       ; $B0
>a095	7d b3 bf			   .byte $7D,<Basic_GREATER-1  ,>Basic_GREATER-1  ; $B1
>a098	5a d3 ae			   .byte $5A,<Basic_EQUAL-1    ,>Basic_EQUAL-1    ; $B2
>a09b	64 15 b0			   .byte $64,<Basic_LESS-1     ,>Basic_LESS-1     ; $B3
.a09e					  Basic_Keyword_Table
>a09e	45 4e c4			   .SHIFT   "END" ;^    ; END
>a0a1	46 4f d2			   .SHIFT   "FOR" ;^    ; FOR
>a0a4	4e 45 58 d4			   .SHIFT   "NEXT" ;^   ; NEXT
>a0a8	44 41 54 c1			   .SHIFT   "DATA" ;^   ; DATA
>a0ac	49 4e 50 55 54 a3		   .SHIFT   "INPUT#" ;^ ; INPUT#
>a0b2	49 4e 50 55 d4			   .SHIFT   "INPUT" ;^  ; INPUT
>a0b7	44 49 cd			   .SHIFT   "DIM" ;^    ; DIM
>a0ba	52 45 41 c4			   .SHIFT   "READ" ;^   ; READ
>a0be	4c 45 d4			   .SHIFT   "LET" ;^    ; LET
>a0c1	47 4f 54 cf			   .SHIFT   "GOTO" ;^   ; GOTO
>a0c5	52 55 ce			   .SHIFT   "RUN" ;^    ; RUN
>a0c8	49 c6				   .SHIFT   "IF" ;^     ; IF
>a0ca	52 45 53 54 4f 52 c5		   .SHIFT   "RESTORE" ;^; RESTORE
>a0d1	47 4f 53 55 c2			   .SHIFT   "GOSUB" ;^  ; GOSUB
>a0d6	52 45 54 55 52 ce		   .SHIFT   "RETURN" ;^ ; RETURN
>a0dc	52 45 cd			   .SHIFT   "REM" ;^    ; REM
>a0df	53 54 4f d0			   .SHIFT   "STOP" ;^   ; STOP
>a0e3	4f ce				   .SHIFT   "ON" ;^     ; ON
>a0e5	57 41 49 d4			   .SHIFT   "WAIT" ;^   ; WAIT
>a0e9	4c 4f 41 c4			   .SHIFT   "LOAD" ;^   ; LOAD
>a0ed	53 41 56 c5			   .SHIFT   "SAVE" ;^   ; SAVE
>a0f1	56 45 52 49 46 d9		   .SHIFT   "VERIFY" ;^ ; VERIFY
>a0f7	44 45 c6			   .SHIFT   "DEF" ;^    ; DEF
>a0fa	50 4f 4b c5			   .SHIFT   "POKE" ;^   ; POKE
>a0fe	50 52 49 4e 54 a3		   .SHIFT   "PRINT#" ;^ ; PRINT#
>a104	50 52 49 4e d4			   .SHIFT   "PRINT" ;^  ; PRINT
>a109	43 4f 4e d4			   .SHIFT   "CONT" ;^   ; CONT
>a10d	4c 49 53 d4			   .SHIFT   "LIST" ;^   ; LIST
>a111	43 4c d2			   .SHIFT   "CLR" ;^    ; CLR
>a114	43 4d c4			   .SHIFT   "CMD" ;^    ; CMD
>a117	53 59 d3			   .SHIFT   "SYS" ;^    ; SYS
>a11a	4f 50 45 ce			   .SHIFT   "OPEN" ;^   ; OPEN
>a11e	43 4c 4f 53 c5			   .SHIFT   "CLOSE" ;^  ; CLOSE
>a123	47 45 d4			   .SHIFT   "GET" ;^    ; GET
>a126	4e 45 d7			   .SHIFT   "NEW" ;^    ; NEW
>a129	54 41 42 a8			   .SHIFT   "TAB(" ;^   ; TAB(
>a12d	54 cf				   .SHIFT   "TO" ;^     ; TO
>a12f	46 ce				   .SHIFT   "FN" ;^     ; FN
>a131	53 50 43 a8			   .SHIFT   "SPC(" ;^   ; SPC(
>a135	54 48 45 ce			   .SHIFT   "THEN" ;^   ; THEN
>a139	4e 4f d4			   .SHIFT   "NOT" ;^    ; NOT
>a13c	53 54 45 d0			   .SHIFT   "STEP" ;^   ; STEP
>a140	ab				   .SHIFT   "+" ;^      ; +
>a141	ad				   .SHIFT   "-" ;^      ; -
>a142	aa				   .SHIFT   "*" ;^      ; *
>a143	af				   .SHIFT   "/" ;^      ; /
>a144	de				   .SHIFT   "^" ;^      ; ^
>a145	41 4e c4			   .SHIFT   "AND" ;^    ; AND
>a148	4f d2				   .SHIFT   "OR" ;^     ; OR
>a14a	be				   .SHIFT   ">" ;^      ; >
>a14b	bd				   .SHIFT   "=" ;^      ; =
>a14c	bc				   .SHIFT   "<" ;^      ; <
>a14d	53 47 ce			   .SHIFT   "SGN" ;^    ; SGN
>a150	49 4e d4			   .SHIFT   "INT" ;^    ; INT
>a153	41 42 d3			   .SHIFT   "ABS" ;^    ; ABS
>a156	55 53 d2			   .SHIFT   "USR" ;^    ; USR
>a159	46 52 c5			   .SHIFT   "FRE" ;^    ; FRE
>a15c	50 4f d3			   .SHIFT   "POS" ;^    ; POS
>a15f	53 51 d2			   .SHIFT   "SQR" ;^    ; SQR
>a162	52 4e c4			   .SHIFT   "RND" ;^    ; RND
>a165	4c 4f c7			   .SHIFT   "LOG" ;^    ; LOG
>a168	45 58 d0			   .SHIFT   "EXP" ;^    ; EXP
>a16b	43 4f d3			   .SHIFT   "COS" ;^    ; COS
>a16e	53 49 ce			   .SHIFT   "SIN" ;^    ; SIN
>a171	54 41 ce			   .SHIFT   "TAN" ;^    ; TAN
>a174	41 54 ce			   .SHIFT   "ATN" ;^    ; ATN
>a177	50 45 45 cb			   .SHIFT   "PEEK" ;^   ; PEEK
>a17b	4c 45 ce			   .SHIFT   "LEN" ;^    ; LEN
>a17e	53 54 52 a4			   .SHIFT   "STR$" ;^   ; STR$
>a182	56 41 cc			   .SHIFT   "VAL" ;^    ; VAL
>a185	41 53 c3			   .SHIFT   "ASC" ;^    ; ASC
>a188	43 48 52 a4			   .SHIFT   "CHR$" ;^   ; CHR$
>a18c	4c 45 46 54 a4			   .SHIFT   "LEFT$" ;^  ; LEFT$
>a191	52 49 47 48 54 a4		   .SHIFT   "RIGHT$" ;^ ; RIGHT$
>a197	4d 49 44 a4			   .SHIFT   "MID$" ;^   ; MID$
>a19b	47 cf				   .SHIFT   "GO" ;^     ; GO so that GO TO, as well as GOTO, will work
>a19d	00				   .BYTE   $00       ; end marker
>a19e	54 4f 4f 20 4d 41 4e 59		ERR_01 .SHIFT   "TOO MANY FILES" ;^
>a1a6	20 46 49 4c 45 d3
>a1ac	46 49 4c 45 20 4f 50 45		ERR_02 .SHIFT   "FILE OPEN" ;^
>a1b4	ce
>a1b5	46 49 4c 45 20 4e 4f 54		ERR_03 .SHIFT   "FILE NOT OPEN" ;^
>a1bd	20 4f 50 45 ce
>a1c2	46 49 4c 45 20 4e 4f 54		ERR_04 .SHIFT   "FILE NOT FOUND" ;^
>a1ca	20 46 4f 55 4e c4
>a1d0	44 45 56 49 43 45 20 4e		ERR_05 .SHIFT   "DEVICE NOT PRESENT" ;^
>a1d8	4f 54 20 50 52 45 53 45 4e d4
>a1e2	4e 4f 54 20 49 4e 50 55		ERR_06 .SHIFT   "NOT INPUT FILE" ;^
>a1ea	54 20 46 49 4c c5
>a1f0	4e 4f 54 20 4f 55 54 50		ERR_07 .SHIFT   "NOT OUTPUT FILE" ;^
>a1f8	55 54 20 46 49 4c c5
>a1ff	4d 49 53 53 49 4e 47 20		ERR_08 .SHIFT   "MISSING FILE NAME" ;^
>a207	46 49 4c 45 20 4e 41 4d c5
>a210	49 4c 4c 45 47 41 4c 20		ERR_09 .SHIFT   "ILLEGAL DEVICE NUMBER" ;^
>a218	44 45 56 49 43 45 20 4e 55 4d 42 45 d2
>a225	4e 45 58 54 20 57 49 54		ERR_0A .SHIFT   "NEXT WITHOUT FOR" ;^
>a22d	48 4f 55 54 20 46 4f d2
>a235	53 59 4e 54 41 d8		ERR_0B .SHIFT   "SYNTAX" ;^
>a23b	52 45 54 55 52 4e 20 57		ERR_0C .SHIFT   "RETURN WITHOUT GOSUB" ;^
>a243	49 54 48 4f 55 54 20 47 4f 53 55 c2
>a24f	4f 55 54 20 4f 46 20 44		ERR_0D .SHIFT   "OUT OF DATA" ;^
>a257	41 54 c1
>a25a	49 4c 4c 45 47 41 4c 20		ERR_0E .SHIFT   "ILLEGAL QUANTITY" ;^
>a262	51 55 41 4e 54 49 54 d9
>a26a	4f 56 45 52 46 4c 4f d7		ERR_0F .SHIFT   "OVERFLOW" ;^
>a272	4f 55 54 20 4f 46 20 4d		ERR_10 .SHIFT   "OUT OF MEMORY" ;^
>a27a	45 4d 4f 52 d9
>a27f	55 4e 44 45 46 27 44 20		ERR_11 .SHIFT   "UNDEF'D STATEMENT" ;^
>a287	53 54 41 54 45 4d 45 4e d4
>a290	42 41 44 20 53 55 42 53		ERR_12 .SHIFT   "BAD SUBSCRIPT" ;^
>a298	43 52 49 50 d4
>a29d	52 45 44 49 4d 27 44 20		ERR_13 .SHIFT   "REDIM'D ARRAY" ;^
>a2a5	41 52 52 41 d9
>a2aa	44 49 56 49 53 49 4f 4e		ERR_14 .SHIFT   "DIVISION BY ZERO" ;^
>a2b2	20 42 59 20 5a 45 52 cf
>a2ba	49 4c 4c 45 47 41 4c 20		ERR_15 .SHIFT   "ILLEGAL DIRECT" ;^
>a2c2	44 49 52 45 43 d4
>a2c8	54 59 50 45 20 4d 49 53		ERR_16 .SHIFT   "TYPE MISMATCH" ;^
>a2d0	4d 41 54 43 c8
>a2d5	53 54 52 49 4e 47 20 54		ERR_17 .SHIFT   "STRING TOO LONG" ;^
>a2dd	4f 4f 20 4c 4f 4e c7
>a2e4	46 49 4c 45 20 44 41 54		ERR_18 .SHIFT   "FILE DATA" ;^
>a2ec	c1
>a2ed	46 4f 52 4d 55 4c 41 20		ERR_19 .SHIFT   "FORMULA TOO COMPLEX" ;^
>a2f5	54 4f 4f 20 43 4f 4d 50 4c 45 d8
>a300	43 41 4e 27 54 20 43 4f		ERR_1A .SHIFT   "CAN'T CONTINUE" ;^
>a308	4e 54 49 4e 55 c5
>a30e	55 4e 44 45 46 27 44 20		ERR_1B .SHIFT   "UNDEF'D FUNCTION" ;^
>a316	46 55 4e 43 54 49 4f ce
>a31e	56 45 52 49 46 d9		ERR_1C .SHIFT   "VERIFY" ;^
>a324	4c 4f 41 c4			ERR_1D .SHIFT   "LOAD" ;^
.a328					Basic_Msg_Tab
>a328	9e a1				   .word   ERR_01  ; TOO MANY FILES
>a32a	ac a1				   .word   ERR_02  ; FILE OPEN
>a32c	b5 a1				   .word   ERR_03  ; FILE NOT OPEN
>a32e	c2 a1				   .word   ERR_04  ; FILE NOT FOUND
>a330	d0 a1				   .word   ERR_05  ; DEVICE NOT PRESENT
>a332	e2 a1				   .word   ERR_06  ; NOT INPUT FILE
>a334	f0 a1				   .word   ERR_07  ; NOT OUTPUT FILE
>a336	ff a1				   .word   ERR_08  ; MISSING FILE NAME
>a338	10 a2				   .word   ERR_09  ; ILLEGAL DEVICE NUMBER
>a33a	25 a2				   .word   ERR_0A  ; NEXT WITHOUT FOR
>a33c	35 a2				   .word   ERR_0B  ; SYNTAX
>a33e	3b a2				   .word   ERR_0C  ; RETURN WITHOUT GOSUB
>a340	4f a2				   .word   ERR_0D  ; OUT OF DATA
>a342	5a a2				   .word   ERR_0E  ; ILLEGAL QUANTITY
>a344	6a a2				   .word   ERR_0F  ; OVERFLOW
>a346	72 a2				   .word   ERR_10  ; OUT OF MEMORY
>a348	7f a2				   .word   ERR_11  ; UNDEF'D STATEMENT
>a34a	90 a2				   .word   ERR_12  ; BAD SUBSCRIPT
>a34c	9d a2				   .word   ERR_13  ; REDIM'D ARRAY
>a34e	aa a2				   .word   ERR_14  ; DIVISION BY ZERO
>a350	ba a2				   .word   ERR_15  ; ILLEGAL DIRECT
>a352	c8 a2				   .word   ERR_16  ; TYPE MISMATCH
>a354	d5 a2				   .word   ERR_17  ; STRING TOO LONG
>a356	e4 a2				   .word   ERR_18  ; FILE DATA
>a358	ed a2				   .word   ERR_19  ; FORMULA TOO COMPLEX
>a35a	00 a3				   .word   ERR_1A  ; CAN'T CONTINUE
>a35c	0e a3				   .word   ERR_1B  ; UNDEF'D FUNCTION
>a35e	1e a3				   .word   ERR_1C  ; VERIFY
>a360	24 a3				   .word   ERR_1D  ; LOAD
>a362	83 a3				   .word   Msg_Break
>a364	0d 4f 4b 0d 00			Msg_OK    .TEXT   "\rOK\r",0
>a369	20 20 45 52 52 4f 52 00		Msg_Err   .TEXT   "  ERROR",0
>a371	20 49 4e 20 00			Msg_IN    .TEXT   " IN ",0
>a376	0d 0a 52 45 41 44 59 2e		Msg_Ready .TEXT   "\r\nREADY.\r\n",0
>a37e	0d 0a 00
>a381	0d 0a				Msg_CrLf  .TEXT   "\r\n"
>a383	42 52 45 41 4b 00		Msg_Break .TEXT   "BREAK",0
>a389	a0				   .byte $A0 ; unused
.a38a					  Find_Active_FOR
.a38a	ba		tsx		   TSX               ; copy stack pointer
.a38b	e8		inx		   INX               ; +1 pass return address
.a38c	e8		inx		   INX               ; +2 pass return address
.a38d	e8		inx		   INX               ; +3 pass calling routine return address
.a38e	e8		inx		   INX               ; +4 pass calling routine return address
.a38f					FAF_Loop
.a38f	bd 01 01	lda $0101,x	   LDA STACK+1,X     ; get token byte from stack
.a392	c9 81		cmp #$81	   CMP #TK_FOR       ; is it FOR token
.a394	d0 21		bne $a3b7	   BNE FAF_Ret       ; exit if not FOR token
.a396	a5 4a		lda $4a		   LDA FORPNT+1      ; get FOR/NEXT variable pointer high byte
.a398	d0 0a		bne $a3a4	   BNE FAF_10        ; branch if defined
.a39a	bd 02 01	lda $0102,x	   LDA STACK+2,X     ; get FOR variable pointer low byte
.a39d	85 49		sta $49		   STA FORPNT        ; save FOR/NEXT variable pointer low byte
.a39f	bd 03 01	lda $0103,x	   LDA STACK+3,X     ; get FOR variable pointer high byte
.a3a2	85 4a		sta $4a		   STA FORPNT+1      ; save FOR/NEXT variable pointer high byte
.a3a4					FAF_10
.a3a4	dd 03 01	cmp $0103,x	   CMP STACK+3,X     ; compare variable pointer with stacked variable pointer
.a3a7	d0 07		bne $a3b0	   BNE FAF_20        ; branch if no match
.a3a9	a5 49		lda $49		   LDA FORPNT        ; get FOR/NEXT variable pointer low byte
.a3ab	dd 02 01	cmp $0102,x	   CMP STACK+2,X     ; compare variable pointer with stacked variable pointer
.a3ae	f0 07		beq $a3b7	   BEQ FAF_Ret       ; exit if match found
.a3b0					FAF_20
.a3b0	8a		txa		   TXA               ; copy index
.a3b1	18		clc		   CLC
.a3b2	69 12		adc #$12	   ADC #18           ; add FOR stack use size
.a3b4	aa		tax		   TAX               ; copy back to index
.a3b5	d0 d8		bne $a38f	   BNE FAF_Loop
.a3b7					FAF_Ret
.a3b7	60		rts		   RTS
.a3b8					  Open_Up_Space
.a3b8	20 08 a4	jsr $a408	   JSR Check_Mem_Avail
.a3bb	85 31		sta $31		   STA STREND
.a3bd	84 32		sty $32		   STY STREND+1
.a3bf					  Move_Block
.a3bf	38		sec		   SEC
.a3c0	a5 5a		lda $5a		   LDA TMPPTB        ; get block end low byte
.a3c2	e5 5f		sbc $5f		   SBC TMPPTC        ; subtract block start low byte
.a3c4	85 22		sta $22		   STA INDEXA        ; save MOD(block length/$100) byte
.a3c6	a8		tay		   TAY               ; copy MOD(block length/$100) byte to Y
.a3c7	a5 5b		lda $5b		   LDA TMPPTB+1      ; get block end high byte
.a3c9	e5 60		sbc $60		   SBC TMPPTC+1      ; subtract block start high byte
.a3cb	aa		tax		   TAX               ; copy block length high byte to X
.a3cc	e8		inx		   INX               ; +1 to allow for count=0 exit
.a3cd	98		tya		   TYA               ; copy block length low byte to A
.a3ce	f0 23		beq $a3f3	   BEQ MoBl_20       ; branch if length low byte=0
.a3d0	a5 5a		lda $5a		   LDA TMPPTB        ; get block end low byte
.a3d2	38		sec		   SEC
.a3d3	e5 22		sbc $22		   SBC INDEXA        ; subtract MOD(block length/$100) byte
.a3d5	85 5a		sta $5a		   STA TMPPTB        ; save corrected old block end low byte
.a3d7	b0 03		bcs $a3dc	   BCS MoBl_10       ; if no underflow skip the high byte decrement
.a3d9	c6 5b		dec $5b		   DEC TMPPTB+1      ; else decrement block end high byte
.a3db	38		sec		   SEC
.a3dc					MoBl_10
.a3dc	a5 58		lda $58		   LDA TMPPTA        ; get destination end low byte
.a3de	e5 22		sbc $22		   SBC INDEXA        ; subtract MOD(block length/$100) byte
.a3e0	85 58		sta $58		   STA TMPPTA        ; save modified new block end low byte
.a3e2	b0 08		bcs $a3ec	   BCS MoBl_Loop_X   ; if no underflow skip the high byte decrement
.a3e4	c6 59		dec $59		   DEC TMPPTA+1      ; else decrement block end high byte
.a3e6	90 04		bcc $a3ec	   BCC MoBl_Loop_X   ; branch always
.a3e8					MoBl_Loop_Y
.a3e8	b1 5a		lda ($5a),y	   LDA (TMPPTB),Y    ; get byte from source
.a3ea	91 58		sta ($58),y	   STA (TMPPTA),Y    ; copy byte to destination
.a3ec					MoBl_Loop_X
.a3ec	88		dey		   DEY
.a3ed	d0 f9		bne $a3e8	   BNE MoBl_Loop_Y
.a3ef	b1 5a		lda ($5a),y	   LDA (TMPPTB),Y    ; get byte from source
.a3f1	91 58		sta ($58),y	   STA (TMPPTA),Y    ; save byte to destination
.a3f3					MoBl_20
.a3f3	c6 5b		dec $5b		   DEC TMPPTB+1      ; decrement source pointer high byte
.a3f5	c6 59		dec $59		   DEC TMPPTA+1      ; decrement destination pointer high byte
.a3f7	ca		dex		   DEX               ; decrement block count
.a3f8	d0 f2		bne $a3ec	   BNE MoBl_Loop_X   ; loop until count = $0
.a3fa	60		rts		   RTS
.a3fb					  Check_Stack_Avail
.a3fb	0a		asl a		   ASL A
.a3fc	69 3e		adc #$3e	   ADC #$3E          ; need at least $3E bytes free
.a3fe	b0 35		bcs $a435	   BCS Error_Out_Of_Memory
.a400	85 22		sta $22		   STA INDEXA        ; save result in temp byte
.a402	ba		tsx		   TSX               ; copy stack
.a403	e4 22		cpx $22		   CPX INDEXA        ; compare new limit with stack
.a405	90 2e		bcc $a435	   BCC Error_Out_Of_Memory
.a407	60		rts		   RTS
.a408					  Check_Mem_Avail
.a408	c4 34		cpy $34		   CPY FRESPC+1      ; compare with bottom of string space high byte
.a40a	90 28		bcc $a434	   BCC CMA_Ret       ; if less then OK
.a40c	d0 04		bne $a412	   BNE CMA_10        ; skip next test if greater (tested <)
.a40e	c5 33		cmp $33		   CMP FRESPC        ; compare with bottom of string space low byte
.a410	90 22		bcc $a434	   BCC CMA_Ret       ; if less then OK
.a412					CMA_10
.a412	48		pha		   PHA               ; push address low byte
.a413	a2 09		ldx #$09	   LDX #9            ; set index to save 10 bytes (FACTPA & FACTPB)
.a415	98		tya		   TYA               ; copy address high byte (to push on stack)
.a416					CMA_Loop_X
.a416	48		pha		   PHA               ; push byte
.a417	b5 57		lda $57,x	   LDA FACTPA,X      ; get byte from FACTPA to TMPPTC+1
.a419	ca		dex		   DEX
.a41a	10 fa		bpl $a416	   BPL CMA_Loop_X
.a41c	20 26 b5	jsr $b526	   JSR Garbage_Collection
.a41f	a2 f7		ldx #$f7	   LDX #$F7          ; use zero page wrap around
.a421					CMA_Loop_2
.a421	68		pla		   PLA               ; pop byte
.a422	95 61		sta $61,x	   STA FAC1EX,X      ; save byte from FACTPA to FAC1
.a424	e8		inx		   INX               ; increment index
.a425	30 fa		bmi $a421	   BMI CMA_Loop_2
.a427	68		pla		   PLA               ; pop address high byte
.a428	a8		tay		   TAY               ; copy back to Y
.a429	68		pla		   PLA               ; pop address low byte
.a42a	c4 34		cpy $34		   CPY FRESPC+1      ; compare with bottom of string space high byte
.a42c	90 06		bcc $a434	   BCC CMA_Ret       ; if less then OK
.a42e	d0 05		bne $a435	   BNE Error_Out_Of_Memory
.a430	c5 33		cmp $33		   CMP FRESPC
.a432	b0 01		bcs $a435	   BCS Error_Out_Of_Memory
.a434					CMA_Ret
.a434	60		rts		   RTS
.a435					  Error_Out_Of_Memory
.a435	a2 10		ldx #$10	   LDX #$10          ; error code $10, out of memory error
.a437					  Basic_Error
.a437	6c 00 03	jmp ($0300)	   JMP (IERROR)      ; normally next statement
.a43a					  Default_Error
.a43a	8a		txa		   TXA               ; copy error number
.a43b	0a		asl a		   ASL A             ; *2
.a43c	aa		tax		   TAX               ; copy to index
.a43d	bd 26 a3	lda $a326,x	   LDA Basic_Msg_Tab-2,X  ; get error message pointer low byte
.a440	85 22		sta $22		   STA INDEXA        ; save it
.a442	bd 27 a3	lda $a327,x	   LDA Basic_Msg_Tab-1,X  ; get error message pointer high byte
.a445	85 23		sta $23		   STA INDEXA+1      ; save it
.a447	20 cc ff	jsr $ffcc	   JSR CLRCHN        ; Clear I/O channels
.a44a	a9 00		lda #$00	   LDA #0
.a44c	85 13		sta $13		   STA IOPMPT        ; clear current I/O channel, flag default
.a44e	20 d7 aa	jsr $aad7	   JSR Print_CR
.a451	20 45 ab	jsr $ab45	   JSR Print_Question_Mark
.a454	a0 00		ldy #$00	   LDY #0
.a456					DeEr_Loop
.a456	b1 22		lda ($22),y	   LDA (INDEXA),Y    ; get byte from message
.a458	48		pha		   PHA               ; save status
.a459	29 7f		and #$7f	   AND #$7F          ; mask 0xxx xxxx, clear b7
.a45b	20 47 ab	jsr $ab47	   JSR Print_Char
.a45e	c8		iny		   INY
.a45f	68		pla		   PLA               ; restore status
.a460	10 f4		bpl $a456	   BPL DeEr_Loop
.a462	20 7a a6	jsr $a67a	   JSR Flush_BASIC_Stack
.a465	a9 69		lda #$69	   LDA #<Msg_Err ;#<addr
.a467	a0 a3		ldy #$a3	   LDY #>Msg_Err ;#>addr
.a469					  Display_Msg_Then_Ready
.a469	20 1e ab	jsr $ab1e	   JSR Print_String
.a46c	a4 3a		ldy $3a		   LDY CURLIN+1      ; get current line number high byte
.a46e	c8		iny		   INY               ; increment it
.a46f	f0 03		beq $a474	   BEQ Basic_Ready   ; CURLIN+1 was $FF = direct mode
.a471	20 c2 bd	jsr $bdc2	   JSR Print_IN
.a474					  Basic_Ready
.a474	a9 76		lda #$76	   LDA #<Msg_Ready
.a476	a0 a3		ldy #$a3	   LDY #>Msg_Ready
.a478	20 1e ab	jsr $ab1e	   JSR Print_String
.a47b	a9 80		lda #$80	   LDA #$80          ; set for control messages only
.a47d	20 90 ff	jsr $ff90	   JSR SETMSG        ; control kernal messages
.a480					  Vectored_Warmstart
.a480	6c 02 03	jmp ($0302)	   JMP (IMAIN)       ; normally next statement
.a483					  Default_Warmstart
.a483	20 60 a5	jsr $a560	   JSR Read_String
.a486	86 7a		stx $7a		   STX TXTPTR
.a488	84 7b		sty $7b		   STY TXTPTR+1
.a48a	20 73 00	jsr $0073	   JSR CHRGET
.a48d	aa		tax		   TAX               ; copy byte to set flags
.a48e	f0 f0		beq $a480	   BEQ Vectored_Warmstart ; loop if no input
.a490	a2 ff		ldx #$ff	   LDX #-1           ; indicates direct mode
.a492	86 3a		stx $3a		   STX CURLIN+1
.a494	90 06		bcc $a49c	   BCC New_Basic_Line
.a496					Direct_Call
.a496	20 79 a5	jsr $a579	   JSR Tokenize_Line
.a499	4c e1 a7	jmp $a7e1	   JMP Start_Program
.a49c					  New_Basic_Line
.a49c	20 6b a9	jsr $a96b	   JSR Scan_Linenumber
.a49f	20 79 a5	jsr $a579	   JSR Tokenize_Line
.a4a2	84 0b		sty $0b		   STY COUNT         ; save index pointer to end of crunched line
.a4a4	20 13 a6	jsr $a613	   JSR Find_BASIC_Line
.a4a7	90 44		bcc $a4ed	   BCC NBL_20        ; if not found skip the line delete
.a4a9	a0 01		ldy #$01	   LDY #1            ; set index to next line pointer high byte
.a4ab	b1 5f		lda ($5f),y	   LDA (TMPPTC),Y    ; get next line pointer high byte
.a4ad	85 23		sta $23		   STA INDEXA+1      ; save it
.a4af	a5 2d		lda $2d		   LDA VARTAB        ; get start of variables low byte
.a4b1	85 22		sta $22		   STA INDEXA        ; save it
.a4b3	a5 60		lda $60		   LDA TMPPTC+1      ; get found line pointer high byte
.a4b5	85 25		sta $25		   STA INDEXB+1      ; save it
.a4b7	a5 5f		lda $5f		   LDA TMPPTC        ; get found line pointer low byte
.a4b9	88		dey		   DEY               ; decrement index
.a4ba	f1 5f		sbc ($5f),y	   SBC (TMPPTC),Y    ; subtract next line pointer low byte
.a4bc	18		clc		   CLC
.a4bd	65 2d		adc $2d		   ADC VARTAB        ; add start of variables low byte
.a4bf	85 2d		sta $2d		   STA VARTAB        ; set start of variables low byte
.a4c1	85 24		sta $24		   STA INDEXB        ; save destination pointer low byte
.a4c3	a5 2e		lda $2e		   LDA VARTAB+1      ; get start of variables high byte
.a4c5	69 ff		adc #$ff	   ADC #$FF          ; -1 + carry
.a4c7	85 2e		sta $2e		   STA VARTAB+1      ; set start of variables high byte
.a4c9	e5 60		sbc $60		   SBC TMPPTC+1      ; subtract found line pointer high byte
.a4cb	aa		tax		   TAX               ; copy to block count
.a4cc	38		sec		   SEC
.a4cd	a5 5f		lda $5f		   LDA TMPPTC        ; get found line pointer low byte
.a4cf	e5 2d		sbc $2d		   SBC VARTAB        ; subtract start of variables low byte
.a4d1	a8		tay		   TAY               ; copy to bytes in first block count
.a4d2	b0 03		bcs $a4d7	   BCS NBL_10        ; if no underflow skip the high byte decrement
.a4d4	e8		inx		   INX               ; increment block count, correct for = 0 loop exit
.a4d5	c6 25		dec $25		   DEC INDEXB+1      ; decrement destination high byte
.a4d7					NBL_10
.a4d7	18		clc		   CLC
.a4d8	65 22		adc $22		   ADC INDEXA        ; add source pointer low byte
.a4da	90 03		bcc $a4df	   BCC NBL_Loop      ; if no underflow skip the high byte decrement
.a4dc	c6 23		dec $23		   DEC INDEXA+1      ; else decrement source pointer high byte
.a4de	18		clc		   CLC
.a4df					NBL_Loop
.a4df	b1 22		lda ($22),y	   LDA (INDEXA),Y    ; get byte from source
.a4e1	91 24		sta ($24),y	   STA (INDEXB),Y    ; copy to destination
.a4e3	c8		iny		   INY
.a4e4	d0 f9		bne $a4df	   BNE NBL_Loop      ; while <> 0 do this block
.a4e6	e6 23		inc $23		   INC INDEXA+1      ; increment source pointer high byte
.a4e8	e6 25		inc $25		   INC INDEXB+1      ; increment destination pointer high byte
.a4ea	ca		dex		   DEX               ; decrement block count
.a4eb	d0 f2		bne $a4df	   BNE NBL_Loop      ; loop until all done
.a4ed					NBL_20
.a4ed	20 59 a6	jsr $a659	   JSR Reset_BASIC_Execution
.a4f0	20 33 a5	jsr $a533	   JSR Rechain
.a4f3	ad 00 02	lda $0200	   LDA BUF           ; get first byte from buffer
.a4f6	f0 88		beq $a480	   BEQ Vectored_Warmstart
.a4f8	18		clc		   CLC               ; insert line into memory
.a4f9	a5 2d		lda $2d		   LDA VARTAB        ; get start of variables low byte
.a4fb	85 5a		sta $5a		   STA TMPPTB        ; save as source end pointer low byte
.a4fd	65 0b		adc $0b		   ADC COUNT         ; add index pointer to end of crunched line
.a4ff	85 58		sta $58		   STA TMPPTA        ; save as destination end pointer low byte
.a501	a4 2e		ldy $2e		   LDY VARTAB+1      ; get start of variables high byte
.a503	84 5b		sty $5b		   STY TMPPTB+1      ; save as source end pointer high byte
.a505	90 01		bcc $a508	   BCC NBL_30      ; if no carry skip the high byte increment
.a507	c8		iny		   INY               ; else increment the high byte
.a508					NBL_30
.a508	84 59		sty $59		   STY TMPPTA+1      ; save as destination end pointer high byte
.a50a	20 b8 a3	jsr $a3b8	   JSR Open_Up_Space
.a50d	a5 14		lda $14		   LDA LINNUM
.a50f	a4 15		ldy $15		   LDY LINNUM+1
.a511	8d fe 01	sta $01fe	   STA BUF-2         ; save line number low byte before crunched line
.a514	8c ff 01	sty $01ff	   STY BUF-1         ; save line number high byte before crunched line
.a517	a5 31		lda $31		   LDA STREND
.a519	a4 32		ldy $32		   LDY STREND+1
.a51b	85 2d		sta $2d		   STA VARTAB
.a51d	84 2e		sty $2e		   STY VARTAB+1
.a51f	a4 0b		ldy $0b		   LDY COUNT         ; get index to end of crunched line
.a521	88		dey		   DEY               ; -1
.a522					NBL_Copy
.a522	b9 fc 01	lda $01fc,y	   LDA BUF-4,Y       ; get byte from crunched line
.a525	91 5f		sta ($5f),y	   STA (TMPPTC),Y    ; save byte to memory
.a527	88		dey		   DEY               ; decrement index
.a528	10 f8		bpl $a522	   BPL NBL_Copy      ; loop while more to do
.a52a					  Reset_And_Rechain
.a52a	20 59 a6	jsr $a659	   JSR Reset_BASIC_Execution
.a52d	20 33 a5	jsr $a533	   JSR Rechain
.a530	4c 80 a4	jmp $a480	   JMP Vectored_Warmstart
.a533					  Rechain
.a533	a5 2b		lda $2b		   LDA TXTTAB
.a535	a4 2c		ldy $2c		   LDY TXTTAB+1
.a537	85 22		sta $22		   STA INDEXA
.a539	84 23		sty $23		   STY INDEXA+1
.a53b	18		clc		   CLC
.a53c					Rech_Loop
.a53c	a0 01		ldy #$01	   LDY #1            ; set index to pointer to next line high byte
.a53e	b1 22		lda ($22),y	   LDA (INDEXA),Y    ; get pointer to next line high byte
.a540	f0 1d		beq $a55f	   BEQ Rech_Ret      ; exit if null, [EOT]
.a542	a0 04		ldy #$04	   LDY #4            ; point to first code byte of line
.a544					Rech_Loop_2
.a544	c8		iny		   INY               ; next code byte
.a545	b1 22		lda ($22),y	   LDA (INDEXA),Y    ; get byte
.a547	d0 fb		bne $a544	   BNE Rech_Loop_2   ; loop if not [EOL]
.a549	c8		iny		   INY               ; point to byte past [EOL], start of next line
.a54a	98		tya		   TYA               ; copy it
.a54b	65 22		adc $22		   ADC INDEXA        ; add line start pointer low byte
.a54d	aa		tax		   TAX               ; copy to X
.a54e	a0 00		ldy #$00	   LDY #0            ; point to this line's next line pointer
.a550	91 22		sta ($22),y	   STA (INDEXA),Y    ; set next line pointer low byte
.a552	a5 23		lda $23		   LDA INDEXA+1      ; get line start pointer high byte
.a554	69 00		adc #$00	   ADC #$00          ; add any overflow
.a556	c8		iny		   INY
.a557	91 22		sta ($22),y	   STA (INDEXA),Y    ; set next line pointer high byte
.a559	86 22		stx $22		   STX INDEXA        ; set line start pointer low byte
.a55b	85 23		sta $23		   STA INDEXA+1      ; set line start pointer high byte
.a55d	90 dd		bcc $a53c	   BCC Rech_Loop     ; branch always
.a55f					Rech_Ret
.a55f	60		rts		   RTS
.a560					  Read_String
.a560	a2 00		ldx #$00	   LDX #0            ; set channel 0, keyboard
.a562					ReSt_Loop
.a562	20 12 e1	jsr $e112	   JSR Read_Char
.a565	c9 0d		cmp #$0d	   CMP #CR
.a567	f0 0d		beq $a576	   BEQ ReSt_Finish
.a569	9d 00 02	sta $0200,x	   STA BUF,X
.a56c	e8		inx		   INX
.a56d	e0 59		cpx #$59	   CPX #$59          ; compare with max+1
.a56f	90 f1		bcc $a562	   BCC ReSt_Loop
.a571	a2 17		ldx #$17	   LDX #$17          ; error $17, string too long error
.a573	4c 37 a4	jmp $a437	   JMP Basic_Error
.a576					ReSt_Finish
.a576	4c ca aa	jmp $aaca	   JMP Terminate_BUF      ; set XY to BUF - 1 and print [CR]
.a579					  Tokenize_Line
.a579	6c 04 03	jmp ($0304)	   JMP (ICRNCH)      ; normally next statement
.a57c					  Default_Tokenize
.a57c	a6 7a		ldx $7a		   LDX TXTPTR        ; get BASIC execute pointer low byte
.a57e	a0 04		ldy #$04	   LDY #4
.a580	84 0f		sty $0f		   STY GARBFL        ; clear open quote/DATA flag
.a582					Toke_Loop
.a582	bd 00 02	lda $0200,x	   LDA BUF,X
.a585	10 07		bpl $a58e	   BPL Toke_05       ; plain text
.a587	c9 ff		cmp #$ff	   CMP #TK_PI
.a589	f0 3e		beq $a5c9	   BEQ Toke_35       ; if PI save & continue
.a58b	e8		inx		   INX               ; next char
.a58c	d0 f4		bne $a582	   BNE Toke_Loop     ; branch always
.a58e					Toke_05
.a58e	c9 20		cmp #$20	   CMP #' '
.a590	f0 37		beq $a5c9	   BEQ Toke_35       ; if [SPACE] save & continue
.a592	85 08		sta $08		   STA ENDCHR        ; save buffer byte as search character
.a594	c9 22		cmp #$22	   CMP #QUOTE
.a596	f0 56		beq $a5ee	   BEQ Toke_55       ; if quote go copy quoted string
.a598	24 0f		bit $0f		   BIT GARBFL        ; get open quote/DATA token flag
.a59a	70 2d		bvs $a5c9	   BVS Toke_35       ; branch if b6 of Oquote set, was DATA
.a59c	c9 3f		cmp #$3f	   CMP #'?'          ; compare with '?' character
.a59e	d0 04		bne $a5a4	   BNE Toke_10       ; if not "?" continue crunching
.a5a0	a9 99		lda #$99	   LDA #TK_PRINT     ; replace '?' by the token for PRINT
.a5a2	d0 25		bne $a5c9	   BNE Toke_35       ; branch always
.a5a4					Toke_10
.a5a4	c9 30		cmp #$30	   CMP #'0'          ; compare with "0"
.a5a6	90 04		bcc $a5ac	   BCC Toke_15       ; if < "0" continue crunching
.a5a8	c9 3c		cmp #$3c	   CMP #'<'          ; compare with "<"
.a5aa	90 1d		bcc $a5c9	   BCC Toke_35       ; if <, 0123456789:; save & continue
.a5ac					Toke_15
.a5ac	84 71		sty $71		   STY TMPPTD        ; copy save index
.a5ae	a0 00		ldy #$00	   LDY #0            ; clear table pointer
.a5b0	84 0b		sty $0b		   STY COUNT         ; clear word index
.a5b2	88		dey		   DEY               ; Y = $FF
.a5b3	86 7a		stx $7a		   STX TXTPTR        ; save BASIC execute pointer low byte, buffer index
.a5b5	ca		dex		   DEX               ; adjust for pre increment loop
.a5b6					Toke_20
.a5b6	c8		iny		   INY               ; next table byte
.a5b7	e8		inx		   INX               ; next buffer byte
.a5b8					Toke_25
.a5b8	bd 00 02	lda $0200,x	   LDA BUF,X         ; get byte from input buffer
.a5bb	38		sec		   SEC
.a5bc	f9 9e a0	sbc $a09e,y	   SBC Basic_Keyword_Table,Y
.a5bf	f0 f5		beq $a5b6	   BEQ Toke_20       ; match so far
.a5c1	c9 80		cmp #$80	   CMP #$80          ; was it end marker match ?
.a5c3	d0 30		bne $a5f5	   BNE Toke_60       ; if not go try the next keyword
.a5c5	05 0b		ora $0b		   ORA COUNT         ; OR with word index, +$80 in A makes token
.a5c7					Toke_30
.a5c7	a4 71		ldy $71		   LDY TMPPTD        ; restore save index
.a5c9					Toke_35
.a5c9	e8		inx		   INX               ; increment buffer read index
.a5ca	c8		iny		   INY               ; increment save index
.a5cb	99 fb 01	sta $01fb,y	   STA BUF-5,Y       ; save byte to output
.a5ce	b9 fb 01	lda $01fb,y	   LDA BUF-5,Y       ; get byte from output, set flags
.a5d1	f0 36		beq $a609	   BEQ Toke_70       ; branch if was null [EOL]
.a5d3	38		sec		   SEC
.a5d4	e9 3a		sbc #$3a	   SBC #':'          ; subtract ":"
.a5d6	f0 04		beq $a5dc	   BEQ Toke_40       ; branch if it was (A is now 0)
.a5d8	c9 49		cmp #$49	   CMP #TK_DATA-':'  ; compare with the token for DATA-':'
.a5da	d0 02		bne $a5de	   BNE Toke_45       ; if not DATA go try REM
.a5dc					Toke_40
.a5dc	85 0f		sta $0f		   STA GARBFL        ; save token-':'
.a5de					Toke_45
.a5de	38		sec		   SEC
.a5df	e9 55		sbc #$55	   SBC #TK_REM-':'   ; subtract the token for REM-':'
.a5e1	d0 9f		bne $a582	   BNE Toke_Loop     ; if wasn't REM go crunch next bit of line
.a5e3					Toke_REM
.a5e3	85 08		sta $08		   STA ENDCHR        ; else was REM so set search for [EOL]
.a5e5					Toke_50
.a5e5	bd 00 02	lda $0200,x	   LDA BUF,X         ; get byte from input buffer
.a5e8	f0 df		beq $a5c9	   BEQ Toke_35       ; if null [EOL] save byte then continue crunching
.a5ea	c5 08		cmp $08		   CMP ENDCHR        ; compare with stored character
.a5ec	f0 db		beq $a5c9	   BEQ Toke_35       ; if match save byte then continue crunching
.a5ee					Toke_55
.a5ee	c8		iny		   INY               ; increment save index
.a5ef	99 fb 01	sta $01fb,y	   STA BUF-5,Y       ; save byte to output
.a5f2	e8		inx		   INX               ; increment buffer index
.a5f3	d0 f0		bne $a5e5	   BNE Toke_50       ; branch always
.a5f5					Toke_60
.a5f5	a6 7a		ldx $7a		   LDX TXTPTR        ; restore BASIC execute pointer low byte
.a5f7	e6 0b		inc $0b		   INC COUNT         ; increment word index (next word)
.a5f9					Toke_65
.a5f9	c8		iny		   INY               ; increment table index
.a5fa	b9 9d a0	lda $a09d,y	   LDA Basic_Keyword_Table-1,Y; get table byte
.a5fd	10 fa		bpl $a5f9	   BPL Toke_65       ; loop if not end of word yet
.a5ff	b9 9e a0	lda $a09e,y	   LDA Basic_Keyword_Table,Y  ; get byte from keyword table
.a602	d0 b4		bne $a5b8	   BNE Toke_25       ; go test next word if not zero byte, end of table
.a604	bd 00 02	lda $0200,x	   LDA BUF,X         ; restore byte from input buffer
.a607	10 be		bpl $a5c7	   BPL Toke_30       ; branch always, all unmatched bytes in the buffer are
.a609					Toke_70
.a609	99 fd 01	sta $01fd,y	   STA BUF-3,Y       ; save [EOL]
.a60c	c6 7b		dec $7b		   DEC TXTPTR+1      ; decrement BASIC execute pointer high byte
.a60e	a9 ff		lda #$ff	   LDA #$FF          ; point to start of buffer-1
.a610	85 7a		sta $7a		   STA TXTPTR        ; set BASIC execute pointer low byte
.a612	60		rts		   RTS
.a613					  Find_BASIC_Line
.a613	a5 2b		lda $2b		   LDA TXTTAB
.a615	a6 2c		ldx $2c		   LDX TXTTAB+1
.a617					  Find_BASIC_Line_AX
.a617	a0 01		ldy #$01	   LDY #1            ; set Y to next line link high byte
.a619	85 5f		sta $5f		   STA TMPPTC
.a61b	86 60		stx $60		   STX TMPPTC+1
.a61d	b1 5f		lda ($5f),y	   LDA (TMPPTC),Y    ; get line link high byte
.a61f	f0 1f		beq $a640	   BEQ FiBL_Not_Found; 0 = end of program
.a621	c8		iny		   INY               ; Y = 2
.a622	c8		iny		   INY               ; Y = 3
.a623	a5 15		lda $15		   LDA LINNUM+1      ; target line # high byte
.a625	d1 5f		cmp ($5f),y	   CMP (TMPPTC),Y    ; compare with line # high byte
.a627	90 18		bcc $a641	   BCC FiBL_Ret      ; beyond target line
.a629	f0 03		beq $a62e	   BEQ FiBL_Check    ; go check low byte if =
.a62b	88		dey		   DEY               ; Y = 2
.a62c	d0 09		bne $a637	   BNE FiBL_Cont     ; branch always
.a62e					FiBL_Check
.a62e	a5 14		lda $14		   LDA LINNUM        ; get target line # low byte
.a630	88		dey		   DEY               ; Y = 2
.a631	d1 5f		cmp ($5f),y	   CMP (TMPPTC),Y    ; compare with line # low byte
.a633	90 0c		bcc $a641	   BCC FiBL_Ret      ; beyond target line
.a635	f0 0a		beq $a641	   BEQ FiBL_Ret      ; target line found: exit
.a637					FiBL_Cont
.a637	88		dey		   DEY               ; Y = 1
.a638	b1 5f		lda ($5f),y	   LDA (TMPPTC),Y    ; get next line link high byte
.a63a	aa		tax		   TAX               ; copy to X
.a63b	88		dey		   DEY               ; Y = 0
.a63c	b1 5f		lda ($5f),y	   LDA (TMPPTC),Y    ; get next line link low byte
.a63e	b0 d7		bcs $a617	   BCS Find_BASIC_Line_AX ; branch always
.a640					FiBL_Not_Found
.a640	18		clc		   CLC               ; clear found flag
.a641					FiBL_Ret
.a641	60		rts		   RTS
.a642					  Basic_NEW
.a642	d0 fd		bne $a641	   BNE FiBL_Ret      ; exit if following byte to allow syntax error
.a644					  Perform_NEW
.a644	a9 00		lda #$00	   LDA #0
.a646	a8		tay		   TAY               ; clear index
.a647	91 2b		sta ($2b),y	   STA (TXTTAB),Y    ; clear pointer to next line low byte
.a649	c8		iny		   INY
.a64a	91 2b		sta ($2b),y	   STA (TXTTAB),Y    ; clear pointer to next line high byte, erase program
.a64c	a5 2b		lda $2b		   LDA TXTTAB        ; get start of memory low byte
.a64e	18		clc		   CLC
.a64f	69 02		adc #$02	   ADC #2            ; add null program length
.a651	85 2d		sta $2d		   STA VARTAB        ; set start of variables low byte
.a653	a5 2c		lda $2c		   LDA TXTTAB+1      ; get start of memory high byte
.a655	69 00		adc #$00	   ADC #0            ; add carry
.a657	85 2e		sta $2e		   STA VARTAB+1      ; set start of variables high byte
.a659					  Reset_BASIC_Execution
.a659	20 8e a6	jsr $a68e	   JSR Reset_BASIC_Exec_Pointer
.a65c	a9 00		lda #$00	   LDA #$00          ; set Zb for CLR entry
.a65e					  Basic_CLR
.a65e	d0 2d		bne $a68d	   BNE Flush_Ret      ; exit if following byte to allow syntax error
.a660					  Clear_Variable_Space
.a660	20 e7 ff	jsr $ffe7	   JSR CLALL         ; close all channels and files
.a663					  Reset_Variable_Pointer
.a663	a5 37		lda $37		   LDA MEMSIZ
.a665	a4 38		ldy $38		   LDY MEMSIZ+1
.a667	85 33		sta $33		   STA FRESPC
.a669	84 34		sty $34		   STY FRESPC+1
.a66b	a5 2d		lda $2d		   LDA VARTAB
.a66d	a4 2e		ldy $2e		   LDY VARTAB+1
.a66f	85 2f		sta $2f		   STA ARYTAB
.a671	84 30		sty $30		   STY ARYTAB+1
.a673	85 31		sta $31		   STA STREND
.a675	84 32		sty $32		   STY STREND+1
.a677					  Restore_And_Flush_Stack
.a677	20 1d a8	jsr $a81d	   JSR Basic_RESTORE ; perform RESTORE
.a67a					  Flush_BASIC_Stack
.a67a	a2 19		ldx #$19	   LDX #TEMPST       ; get descriptor stack start
.a67c	86 16		stx $16		   STX TEMPPT        ; set descriptor stack pointer
.a67e	68		pla		   PLA               ; pull return address low byte
.a67f	a8		tay		   TAY               ; copy it
.a680	68		pla		   PLA               ; pull return address high byte
.a681	a2 fa		ldx #$fa	   LDX #$FA          ; set cleared stack pointer
.a683	9a		txs		   TXS               ; set stack
.a684	48		pha		   PHA               ; push return address high byte
.a685	98		tya		   TYA               ; restore return address low byte
.a686	48		pha		   PHA               ; push return address low byte
.a687	a9 00		lda #$00	   LDA #0
.a689	85 3e		sta $3e		   STA OLDTXT+1      ; clear continue pointer high byte
.a68b	85 10		sta $10		   STA SUBFLG        ; clear subscript/FNX flag
.a68d					Flush_Ret
.a68d	60		rts		   RTS
.a68e					  Reset_BASIC_Exec_Pointer
.a68e	18		clc		   CLC
.a68f	a5 2b		lda $2b		   LDA TXTTAB        ; get start of memory low byte
.a691	69 ff		adc #$ff	   ADC #$FF          ; add -1 low byte
.a693	85 7a		sta $7a		   STA TXTPTR        ; set BASIC execute pointer low byte
.a695	a5 2c		lda $2c		   LDA TXTTAB+1      ; get start of memory high byte
.a697	69 ff		adc #$ff	   ADC #$FF          ; add -1 high byte
.a699	85 7b		sta $7b		   STA TXTPTR+1      ; save BASIC execute pointer high byte
.a69b	60		rts		   RTS
.a69c					  Basic_LIST
.a69c	90 06		bcc $a6a4	   BCC LIST_05       ; branch if next character not token (LIST n...)
.a69e	f0 04		beq $a6a4	   BEQ LIST_05       ; branch if next character [NULL] (LIST)
.a6a0	c9 ab		cmp #$ab	   CMP #TK_MINUS     ; the only token allowed here (LIST -m)
.a6a2	d0 e9		bne $a68d	   BNE Flush_Ret
.a6a4					LIST_05
.a6a4	20 6b a9	jsr $a96b	   JSR Scan_Linenumber
.a6a7	20 13 a6	jsr $a613	   JSR Find_BASIC_Line
.a6aa	20 79 00	jsr $0079	   JSR CHRGOT
.a6ad	f0 0c		beq $a6bb	   BEQ LIST_10       ; branch if no more chrs
.a6af	c9 ab		cmp #$ab	   CMP #TK_MINUS     ; compare with "-"
.a6b1	d0 8e		bne $a641	   BNE FiBL_Ret      ; return if not "-" (will be SN error)
.a6b3	20 73 00	jsr $0073	   JSR CHRGET        ; LIST [n]-m
.a6b6	20 6b a9	jsr $a96b	   JSR Scan_Linenumber
.a6b9	d0 86		bne $a641	   BNE FiBL_Ret      ; exit if not ok
.a6bb					LIST_10
.a6bb	68		pla		   PLA               ; dump return address low byte, exit via warm start
.a6bc	68		pla		   PLA               ; dump return address high byte
.a6bd	a5 14		lda $14		   LDA LINNUM        ; get temporary integer low byte
.a6bf	05 15		ora $15		   ORA LINNUM+1      ; OR temporary integer high byte
.a6c1	d0 06		bne $a6c9	   BNE LIST_15       ; branch if start set
.a6c3					LIST_12
.a6c3	a9 ff		lda #$ff	   LDA #$FF          ; set last line to $FFFF if not specified
.a6c5	85 14		sta $14		   STA LINNUM
.a6c7	85 15		sta $15		   STA LINNUM+1
.a6c9					LIST_15
.a6c9	a0 01		ldy #$01	   LDY #1
.a6cb	84 0f		sty $0f		   STY GARBFL        ; clear open quote flag
.a6cd	b1 5f		lda ($5f),y	   LDA (TMPPTC),Y    ; get next line pointer high byte
.a6cf	f0 43		beq $a714	   BEQ LIST_45       ; if null all done so exit
.a6d1	20 2c a8	jsr $a82c	   JSR Check_STOP
.a6d4					LIST_17
.a6d4	20 d7 aa	jsr $aad7	   JSR Print_CR
.a6d7	c8		iny		   INY
.a6d8	b1 5f		lda ($5f),y	   LDA (TMPPTC),Y    ; get line number low byte
.a6da	aa		tax		   TAX
.a6db	c8		iny		   INY
.a6dc	b1 5f		lda ($5f),y	   LDA (TMPPTC),Y    ; get line number high byte
.a6de	c5 15		cmp $15		   CMP LINNUM+1      ; compare with temporary integer high byte
.a6e0	d0 04		bne $a6e6	   BNE LIST_20       ; branch if no high byte match
.a6e2	e4 14		cpx $14		   CPX LINNUM        ; compare with temporary integer low byte
.a6e4	f0 02		beq $a6e8	   BEQ LIST_25       ; branch if = last line to do, < will pass next branch
.a6e6					LIST_20
.a6e6	b0 2c		bcs $a714	   BCS LIST_45       ; if greater all done so exit
.a6e8					LIST_25
.a6e8	84 49		sty $49		   STY FORPNT        ; save index for line
.a6ea	20 cd bd	jsr $bdcd	   JSR Print_Integer_XA
.a6ed	a9 20		lda #$20	   LDA #' '          ; print [SPACE] after line #
.a6ef					LIST_30
.a6ef	a4 49		ldy $49		   LDY FORPNT        ; get index for line
.a6f1	29 7f		and #$7f	   AND #$7F          ; mask top out bit of character
.a6f3					LIST_35
.a6f3	20 47 ab	jsr $ab47	   JSR Print_Char
.a6f6	c9 22		cmp #$22	   CMP #QUOTE
.a6f8	d0 06		bne $a700	   BNE LIST_40       ; if not skip the quote handle
.a6fa	a5 0f		lda $0f		   LDA GARBFL        ; get open quote flag
.a6fc	49 ff		eor #$ff	   EOR #$FF          ; toggle it
.a6fe	85 0f		sta $0f		   STA GARBFL        ; save it back
.a700					LIST_40
.a700	c8		iny		   INY
.a701	f0 11		beq $a714	   BEQ LIST_45       ; line too long so just bail out and do a warm start
.a703	b1 5f		lda ($5f),y	   LDA (TMPPTC),Y    ; get next byte
.a705	d0 10		bne $a717	   BNE Vectored_Detokenize      ; if not [EOL] (go print character)
.a707	a8		tay		   TAY               ; else clear index
.a708	b1 5f		lda ($5f),y	   LDA (TMPPTC),Y    ; get next line pointer low byte
.a70a	aa		tax		   TAX               ; copy to X
.a70b	c8		iny		   INY
.a70c	b1 5f		lda ($5f),y	   LDA (TMPPTC),Y    ; get next line pointer high byte
.a70e	86 5f		stx $5f		   STX TMPPTC        ; set pointer to line low byte
.a710	85 60		sta $60		   STA TMPPTC+1      ; set pointer to line high byte
.a712	d0 b5		bne $a6c9	   BNE LIST_15       ; go do next line if not [EOT]
.a714					LIST_45
.a714	4c 86 e3	jmp $e386	   JMP Vectored_Basic_Ready
.a717					  Vectored_Detokenize
.a717	6c 06 03	jmp ($0306)	   JMP (IQPLOP)      ; normally next statement
.a71a					  Default_Detokenize
.a71a	10 d7		bpl $a6f3	   BPL LIST_35       ; print it if not token byte
.a71c	c9 ff		cmp #$ff	   CMP #TK_PI        ; compare with the token for PI
.a71e	f0 d3		beq $a6f3	   BEQ LIST_35       ; just print it if so
.a720	24 0f		bit $0f		   BIT GARBFL        ; test the open quote flag
.a722	30 cf		bmi $a6f3	   BMI LIST_35       ; just go print character if open quote set
.a724	38		sec		   SEC               ; else set carry for subtract
.a725	e9 7f		sbc #$7f	   SBC #$7F          ; convert token to inex
.a727	aa		tax		   TAX               ; copy token # to X
.a728	84 49		sty $49		   STY FORPNT        ; save Y
.a72a	a0 ff		ldy #$ff	   LDY #$FF          ; start from -1, adjust for pre increment
.a72c					DeTo_10
.a72c	ca		dex		   DEX               ; decrement token #
.a72d	f0 08		beq $a737	   BEQ DeTo_30       ; if not found go do printing
.a72f					DeTo_20
.a72f	c8		iny		   INY
.a730	b9 9e a0	lda $a09e,y	   LDA Basic_Keyword_Table,Y
.a733	10 fa		bpl $a72f	   BPL DeTo_20      ; loop until keyword end marker
.a735	30 f5		bmi $a72c	   BMI DeTo_10      ; branch always
.a737					DeTo_30
.a737	c8		iny		   INY
.a738	b9 9e a0	lda $a09e,y	   LDA Basic_Keyword_Table,Y
.a73b	30 b2		bmi $a6ef	   BMI LIST_30       ; go restore index, mask byte and print
.a73d	20 47 ab	jsr $ab47	   JSR Print_Char
.a740	d0 f5		bne $a737	   BNE DeTo_30       ; go get next character, branch always
.a742					  Basic_FOR
.a742	a9 80		lda #$80	   LDA #$80
.a744	85 10		sta $10		   STA SUBFLG        ; set FNX flag
.a746	20 a5 a9	jsr $a9a5	   JSR Basic_LET
.a749	20 8a a3	jsr $a38a	   JSR Find_Active_FOR
.a74c	d0 05		bne $a753	   BNE BaFO_10       ; branch if this FOR variable was not found
.a74e	8a		txa		   TXA               ; dump the old one
.a74f	69 0f		adc #$0f	   ADC #15           ; add FOR structure size-2
.a751	aa		tax		   TAX               ; copy to index
.a752	9a		txs		   TXS               ; set stack (dump FOR structure (-2 bytes))
.a753					BaFO_10
.a753	68		pla		   PLA               ; pull return address
.a754	68		pla		   PLA               ; pull return address
.a755	a9 09		lda #$09	   LDA #$09          ; we need 18d bytes !
.a757	20 fb a3	jsr $a3fb	   JSR Check_Stack_Avail
.a75a	20 06 a9	jsr $a906	   JSR Next_Statement
.a75d	18		clc		   CLC
.a75e	98		tya		   TYA               ; copy index to A
.a75f	65 7a		adc $7a		   ADC TXTPTR        ; add BASIC execute pointer low byte
.a761	48		pha		   PHA               ; push onto stack
.a762	a5 7b		lda $7b		   LDA TXTPTR+1      ; get BASIC execute pointer high byte
.a764	69 00		adc #$00	   ADC #$00          ; add carry
.a766	48		pha		   PHA               ; push onto stack
.a767	a5 3a		lda $3a		   LDA CURLIN+1
.a769	48		pha		   PHA
.a76a	a5 39		lda $39		   LDA CURLIN
.a76c	48		pha		   PHA
.a76d	a9 a4		lda #$a4	   LDA #TK_TO        ; set "TO" token
.a76f	20 ff ae	jsr $aeff	   JSR Need_A
.a772	20 8d ad	jsr $ad8d	   JSR Is_Numeric
.a775	20 8a ad	jsr $ad8a	   JSR Eval_Numeric
.a778	a5 66		lda $66		   LDA FAC1SI        ; get FAC1 sign (b7)
.a77a	09 7f		ora #$7f	   ORA #$7F          ; set all non sign bits
.a77c	25 62		and $62		   AND FAC1M1        ; and FAC1 mantissa 1
.a77e	85 62		sta $62		   STA FAC1M1        ; save FAC1 mantissa 1
.a780	a9 8b		lda #$8b	   LDA #<BaFO_20 ;#<addr
.a782	a0 a7		ldy #$a7	   LDY #>BaFO_20 ;#>addr
.a784	85 22		sta $22		   STA INDEXA
.a786	84 23		sty $23		   STY INDEXA+1
.a788	4c 43 ae	jmp $ae43	   JMP Round_And_Push_FAC1
.a78b					BaFO_20
.a78b	a9 bc		lda #$bc	   LDA #<REAL_1 ;#<addr
.a78d	a0 b9		ldy #$b9	   LDY #>REAL_1 ;#>addr
.a78f	20 a2 bb	jsr $bba2	   JSR Load_FAC1_AY
.a792	20 79 00	jsr $0079	   JSR CHRGOT
.a795	c9 a9		cmp #$a9	   CMP #TK_STEP
.a797	d0 06		bne $a79f	   BNE BaFO_30
.a799	20 73 00	jsr $0073	   JSR CHRGET
.a79c	20 8a ad	jsr $ad8a	   JSR Eval_Numeric  ; Get STEP value
.a79f					BaFO_30
.a79f	20 2b bc	jsr $bc2b	   JSR Get_FAC1_Sign
.a7a2	20 38 ae	jsr $ae38	   JSR Push_FAC1
.a7a5	a5 4a		lda $4a		   LDA FORPNT+1
.a7a7	48		pha		   PHA
.a7a8	a5 49		lda $49		   LDA FORPNT
.a7aa	48		pha		   PHA
.a7ab	a9 81		lda #$81	   LDA #TK_FOR       ; push FOR token
.a7ad	48		pha		   PHA
.a7ae					  Interpreter_Loop
.a7ae	20 2c a8	jsr $a82c	   JSR Check_STOP
.a7b1	a5 7a		lda $7a		   LDA TXTPTR
.a7b3	a4 7b		ldy $7b		   LDY TXTPTR+1
.a7b5	c0 02		cpy #$02	   CPY #>BUF         ; direct mode ?
.a7b7	ea		nop		   NOP               ; unused byte
.a7b8	f0 04		beq $a7be	   BEQ InLo_10       ; in direct mode skip the continue pointer save
.a7ba	85 3d		sta $3d		   STA OLDTXT
.a7bc	84 3e		sty $3e		   STY OLDTXT+1
.a7be					InLo_10
.a7be	a0 00		ldy #$00	   LDY #0
.a7c0	b1 7a		lda ($7a),y	   LDA (TXTPTR),Y    ; get BASIC byte
.a7c2	d0 43		bne $a807	   BNE Inte_20      ; if not [EOL] go test for ":"
.a7c4	a0 02		ldy #$02	   LDY #2
.a7c6	b1 7a		lda ($7a),y	   LDA (TXTPTR),Y    ; get next line pointer high byte
.a7c8	18		clc		   CLC
.a7c9	d0 03		bne $a7ce	   BNE InLo_20       ; branch if not end of program
.a7cb	4c 4b a8	jmp $a84b	   JMP End_Of_Exec
.a7ce					InLo_20
.a7ce	c8		iny		   INY
.a7cf	b1 7a		lda ($7a),y	   LDA (TXTPTR),Y    ; get line number low byte
.a7d1	85 39		sta $39		   STA CURLIN        ; save current line number low byte
.a7d3	c8		iny		   INY
.a7d4	b1 7a		lda ($7a),y	   LDA (TXTPTR),Y    ; get line # high byte
.a7d6	85 3a		sta $3a		   STA CURLIN+1      ; save current line number high byte
.a7d8	98		tya		   TYA               ; A now = 4
.a7d9	65 7a		adc $7a		   ADC TXTPTR        ; add BASIC execute pointer low byte, now points to code
.a7db	85 7a		sta $7a		   STA TXTPTR        ; save BASIC execute pointer low byte
.a7dd	90 02		bcc $a7e1	   BCC Start_Program      ; if no overflow skip the high byte increment
.a7df	e6 7b		inc $7b		   INC TXTPTR+1      ; else increment BASIC execute pointer high byte
.a7e1					  Start_Program
.a7e1	6c 08 03	jmp ($0308)	   JMP (IGONE)       ; normally following code
.a7e4					  Default_Start
.a7e4	20 73 00	jsr $0073	   JSR CHRGET
.a7e7	20 ed a7	jsr $a7ed	   JSR Interpret
.a7ea	4c ae a7	jmp $a7ae	   JMP Interpreter_Loop
.a7ed					  Interpret
.a7ed	f0 3c		beq $a82b	   BEQ BaRE_Ret      ; if the first byte is null just exit
.a7ef					  Interpret_10
.a7ef	e9 80		sbc #$80	   SBC #$80          ; normalise the token
.a7f1	90 11		bcc $a804	   BCC Inte_10       ; if wasn't token go do LET
.a7f3	c9 23		cmp #$23	   CMP #TK_TAB-$80   ; compare with token for TAB(-$80
.a7f5	b0 17		bcs $a80e	   BCS Inte_40       ; branch if >= TAB(
.a7f7	0a		asl a		   ASL A             ; *2 bytes per vector
.a7f8	a8		tay		   TAY               ; copy to index
.a7f9	b9 0d a0	lda $a00d,y	   LDA Basic_Statement_Table+1,Y; get vector high byte
.a7fc	48		pha		   PHA               ; push on stack
.a7fd	b9 0c a0	lda $a00c,y	   LDA Basic_Statement_Table,Y  ; get vector low byte
.a800	48		pha		   PHA               ; push on stack
.a801	4c 73 00	jmp $0073	   JMP CHRGET        ; the return from CHRGET calls the command code
.a804					Inte_10
.a804	4c a5 a9	jmp $a9a5	   JMP Basic_LET     ; perform LET
.a807					Inte_20
.a807	c9 3a		cmp #$3a	   CMP #':'          ; comapre with ":"
.a809	f0 d6		beq $a7e1	   BEQ Start_Program ; if ":" go execute new code
.a80b					Inte_30
.a80b	4c 08 af	jmp $af08	   JMP Syntax_Error
.a80e					Inte_40
.a80e	c9 4b		cmp #$4b	   CMP #TK_GO-$80    ; compare with token for GO
.a810	d0 f9		bne $a80b	   BNE Inte_30       ; if not "GO" do syntax error then warm start
.a812	20 73 00	jsr $0073	   JSR CHRGET
.a815	a9 a4		lda #$a4	   LDA #TK_TO        ; set "TO" token
.a817	20 ff ae	jsr $aeff	   JSR Need_A
.a81a	4c a0 a8	jmp $a8a0	   JMP Basic_GOTO    ; perform GOTO
.a81d					  Basic_RESTORE
.a81d	38		sec		   SEC
.a81e	a5 2b		lda $2b		   LDA TXTTAB        ; get start of memory low byte
.a820	e9 01		sbc #$01	   SBC #$01          ; -1
.a822	a4 2c		ldy $2c		   LDY TXTTAB+1      ; get start of memory high byte
.a824	b0 01		bcs $a827	   BCS Store_DATPTR
.a826	88		dey		   DEY               ; else decrement high byte
.a827					Store_DATPTR
.a827	85 41		sta $41		   STA DATPTR
.a829	84 42		sty $42		   STY DATPTR+1
.a82b					BaRE_Ret
.a82b	60		rts		   RTS
.a82c					  Check_STOP
.a82c	20 e1 ff	jsr $ffe1	   JSR STOP          ; Check if stop key is pressed
.a82f					  Basic_STOP
.a82f	b0 01		bcs $a832	   BCS BaEN_10       ; if carry set do BREAK instead of just END
.a831					  Basic_END
.a831	18		clc		   CLC
.a832					BaEN_10
.a832	d0 3c		bne $a870	   BNE BaCO_Ret      ; return if wasn't CTRL-C
.a834	a5 7a		lda $7a		   LDA TXTPTR
.a836	a4 7b		ldy $7b		   LDY TXTPTR+1
.a838	a6 3a		ldx $3a		   LDX CURLIN+1      ; get current line number high byte
.a83a	e8		inx		   INX               ; increment it
.a83b	f0 0c		beq $a849	   BEQ BaEN_20       ; branch if was direct mode
.a83d	85 3d		sta $3d		   STA OLDTXT
.a83f	84 3e		sty $3e		   STY OLDTXT+1
.a841	a5 39		lda $39		   LDA CURLIN
.a843	a4 3a		ldy $3a		   LDY CURLIN+1
.a845	85 3b		sta $3b		   STA OLDLIN
.a847	84 3c		sty $3c		   STY OLDLIN+1
.a849					BaEN_20
.a849	68		pla		   PLA               ; dump return address low byte
.a84a	68		pla		   PLA               ; dump return address high byte
.a84b					  End_Of_Exec
.a84b	a9 81		lda #$81	   LDA #<Msg_CrLf ;#<addr
.a84d	a0 a3		ldy #$a3	   LDY #>Msg_CrLf ;#>addr
.a84f	90 03		bcc $a854	   BCC BaEN_30       ; branch if it was program end
.a851	4c 69 a4	jmp $a469	   JMP Display_Msg_Then_Ready
.a854					BaEN_30
.a854	4c 86 e3	jmp $e386	   JMP Vectored_Basic_Ready
.a857					  Basic_CONT
.a857	d0 17		bne $a870	   BNE BaCO_Ret      ; exit if following byte to allow syntax error
.a859	a2 1a		ldx #$1a	   LDX #$1A          ; error code $1A, can't continue error
.a85b	a4 3e		ldy $3e		   LDY OLDTXT+1      ; get continue pointer high byte
.a85d	d0 03		bne $a862	   BNE BaCO_10       ; go do continue if we can
.a85f	4c 37 a4	jmp $a437	   JMP Basic_Error
.a862					BaCO_10
.a862	a5 3d		lda $3d		   LDA OLDTXT        ; get continue pointer low byte
.a864	85 7a		sta $7a		   STA TXTPTR
.a866	84 7b		sty $7b		   STY TXTPTR+1
.a868	a5 3b		lda $3b		   LDA OLDLIN
.a86a	a4 3c		ldy $3c		   LDY OLDLIN+1
.a86c	85 39		sta $39		   STA CURLIN
.a86e	84 3a		sty $3a		   STY CURLIN+1
.a870					BaCO_Ret
.a870	60		rts		   RTS
.a871					  Basic_RUN
.a871	08		php		   PHP
.a872	a9 00		lda #$00	   LDA #0            ; no control or kernal messages
.a874	20 90 ff	jsr $ff90	   JSR SETMSG
.a877	28		plp		   PLP
.a878	d0 03		bne $a87d	   BNE BaRU_10       ; branch if RUN n
.a87a	4c 59 a6	jmp $a659	   JMP Reset_BASIC_Execution
.a87d					BaRU_10
.a87d	20 60 a6	jsr $a660	   JSR Clear_Variable_Space
.a880	4c 97 a8	jmp $a897	   JMP Goto_Line
.a883					  Basic_GOSUB
.a883	a9 03		lda #$03	   LDA #3            ; need 6 bytes for GOSUB
.a885	20 fb a3	jsr $a3fb	   JSR Check_Stack_Avail
.a888	a5 7b		lda $7b		   LDA TXTPTR+1
.a88a	48		pha		   PHA
.a88b	a5 7a		lda $7a		   LDA TXTPTR
.a88d	48		pha		   PHA
.a88e	a5 3a		lda $3a		   LDA CURLIN+1
.a890	48		pha		   PHA
.a891	a5 39		lda $39		   LDA CURLIN
.a893	48		pha		   PHA
.a894	a9 8d		lda #$8d	   LDA #TK_GOSUB     ; token for GOSUB
.a896	48		pha		   PHA               ; save it
.a897					  Goto_Line
.a897	20 79 00	jsr $0079	   JSR CHRGOT
.a89a	20 a0 a8	jsr $a8a0	   JSR Basic_GOTO
.a89d	4c ae a7	jmp $a7ae	   JMP Interpreter_Loop
.a8a0					  Basic_GOTO
.a8a0	20 6b a9	jsr $a96b	   JSR Scan_Linenumber
.a8a3	20 09 a9	jsr $a909	   JSR Next_Line
.a8a6	38		sec		   SEC
.a8a7	a5 39		lda $39		   LDA CURLIN        ; get current line number low byte
.a8a9	e5 14		sbc $14		   SBC LINNUM        ; subtract temporary integer low byte
.a8ab	a5 3a		lda $3a		   LDA CURLIN+1      ; get current line number high byte
.a8ad	e5 15		sbc $15		   SBC LINNUM+1      ; subtract temporary integer high byte
.a8af	b0 0b		bcs $a8bc	   BCS BaGO_10       ; if current line # >= temporary search from start
.a8b1	98		tya		   TYA               ; else copy line index to A
.a8b2	38		sec		   SEC               ; set carry (+1)
.a8b3	65 7a		adc $7a		   ADC TXTPTR        ; add BASIC execute pointer low byte
.a8b5	a6 7b		ldx $7b		   LDX TXTPTR+1      ; get BASIC execute pointer high byte
.a8b7	90 07		bcc $a8c0	   BCC BaGO_20       ; if no overflow skip the high byte increment
.a8b9	e8		inx		   INX               ; increment high byte
.a8ba	b0 04		bcs $a8c0	   BCS BaGO_20       ; go find the line, branch always
.a8bc					BaGO_10
.a8bc	a5 2b		lda $2b		   LDA TXTTAB
.a8be	a6 2c		ldx $2c		   LDX TXTTAB+1
.a8c0					BaGO_20
.a8c0	20 17 a6	jsr $a617	   JSR Find_BASIC_Line_AX
.a8c3	90 1e		bcc $a8e3	   BCC Undefined_Statement
.a8c5	a5 5f		lda $5f		   LDA TMPPTC        ; get pointer low byte
.a8c7	e9 01		sbc #$01	   SBC #1            ; -1
.a8c9	85 7a		sta $7a		   STA TXTPTR        ; save BASIC execute pointer low byte
.a8cb	a5 60		lda $60		   LDA TMPPTC+1      ; get pointer high byte
.a8cd	e9 00		sbc #$00	   SBC #0            ; subtract carry
.a8cf	85 7b		sta $7b		   STA TXTPTR+1      ; save BASIC execute pointer high byte
.a8d1					BaGO_Ret
.a8d1	60		rts		   RTS
.a8d2					  Basic_RETURN
.a8d2	d0 fd		bne $a8d1	   BNE BaGO_Ret      ; exit if following token to allow syntax error
.a8d4	a9 ff		lda #$ff	   LDA #$FF          ; set byte so no match possible
.a8d6	85 4a		sta $4a		   STA FORPNT+1      ; save FOR/NEXT variable pointer high byte
.a8d8	20 8a a3	jsr $a38a	   JSR Find_Active_FOR
.a8db	9a		txs		   TXS               ; correct the stack
.a8dc	c9 8d		cmp #$8d	   CMP #TK_GOSUB     ; compare with GOSUB token
.a8de	f0 0b		beq $a8eb	   BEQ BaRE_20       ; if matching GOSUB go continue RETURN
.a8e0	a2 0c		ldx #$0c	   LDX #$0C          ; else error code $04, return without gosub error
>a8e2	2c				   .byte $2C         ; skip next statement
.a8e3					  Undefined_Statement
.a8e3	a2 11		ldx #$11	   LDX #$11          ; error code $11, undefined statement error
.a8e5	4c 37 a4	jmp $a437	   JMP Basic_Error
.a8e8					BaRE_10
.a8e8	4c 08 af	jmp $af08	   JMP Syntax_Error
.a8eb					BaRE_20
.a8eb	68		pla		   PLA               ; dump token byte
.a8ec	68		pla		   PLA
.a8ed	85 39		sta $39		   STA CURLIN
.a8ef	68		pla		   PLA
.a8f0	85 3a		sta $3a		   STA CURLIN+1
.a8f2	68		pla		   PLA
.a8f3	85 7a		sta $7a		   STA TXTPTR
.a8f5	68		pla		   PLA
.a8f6	85 7b		sta $7b		   STA TXTPTR+1
.a8f8					  Basic_DATA
.a8f8	20 06 a9	jsr $a906	   JSR Next_Statement
.a8fb					  Add_Y_To_Execution_Pointer
.a8fb	98		tya		   TYA               ; copy index to A
.a8fc					Add_To_TXTPTR
.a8fc	18		clc		   CLC
.a8fd	65 7a		adc $7a		   ADC TXTPTR        ; add BASIC execute pointer low byte
.a8ff	85 7a		sta $7a		   STA TXTPTR        ; save BASIC execute pointer low byte
.a901	90 02		bcc $a905	   BCC AYTE_Ret      ; skip increment if no carry
.a903	e6 7b		inc $7b		   INC TXTPTR+1      ; else increment BASIC execute pointer high byte
.a905					AYTE_Ret
.a905	60		rts		   RTS
.a906					  Next_Statement
.a906	a2 3a		ldx #$3a	   LDX #':'          ; look for colon
>a908	2c				   .byte   $2C       ; skip "LDX #0" command
.a909					  Next_Line
.a909	a2 00		ldx #$00	   LDX #0            ; look for 0 [EOL]
.a90b	86 07		stx $07		   STX CHARAC        ; store alternate search character
.a90d	a0 00		ldy #$00	   LDY #0            ; set search character = [EOL]
.a90f	84 08		sty $08		   STY ENDCHR        ; save the search character
.a911					NeLi_10
.a911	a5 08		lda $08		   LDA ENDCHR        ; get search character
.a913	a6 07		ldx $07		   LDX CHARAC        ; get alternate search character
.a915	85 07		sta $07		   STA CHARAC        ; make search character = alternate search character
.a917					NeLi_15
.a917	86 08		stx $08		   STX ENDCHR        ; make alternate search character = search character
.a919					NeLi_20
.a919	b1 7a		lda ($7a),y	   LDA (TXTPTR),Y    ; get BASIC byte
.a91b	f0 e8		beq $a905	   BEQ AYTE_Ret      ; exit if null [EOL]
.a91d	c5 08		cmp $08		   CMP ENDCHR        ; compare with search character
.a91f	f0 e4		beq $a905	   BEQ AYTE_Ret      ; exit if found
.a921	c8		iny		   INY               ; else increment index
.a922	c9 22		cmp #$22	   CMP #QUOTE
.a924	d0 f3		bne $a919	   BNE NeLi_20       ; if found go swap search character for alternate search
.a926	f0 e9		beq $a911	   BEQ NeLi_10       ; loop for next character, branch always
.a928					  Basic_IF
.a928	20 9e ad	jsr $ad9e	   JSR Eval_Expression
.a92b	20 79 00	jsr $0079	   JSR CHRGOT
.a92e	c9 89		cmp #$89	   CMP #TK_GOTO
.a930	f0 05		beq $a937	   BEQ BaIF_10       ; do IF ... GOTO
.a932	a9 a7		lda #$a7	   LDA #TK_THEN
.a934	20 ff ae	jsr $aeff	   JSR Need_A
.a937					BaIF_10
.a937	a5 61		lda $61		   LDA FAC1EX        ; get FAC1 exponent
.a939	d0 05		bne $a940	   BNE BaIF_20      ; if result was non zero continue execution
.a93b					  Basic_REM
.a93b	20 09 a9	jsr $a909	   JSR Next_Line
.a93e	f0 bb		beq $a8fb	   BEQ Add_Y_To_Execution_Pointer ; branch always
.a940					BaIF_20
.a940	20 79 00	jsr $0079	   JSR CHRGOT
.a943	b0 03		bcs $a948	   BCS BaIF_30      ; if not numeric character, is variable or keyword
.a945	4c a0 a8	jmp $a8a0	   JMP Basic_GOTO    ; else perform GOTO n
.a948					BaIF_30
.a948	4c ed a7	jmp $a7ed	   JMP Interpret
.a94b					  Basic_ON
.a94b	20 9e b7	jsr $b79e	   JSR Get_Byte_Value
.a94e	48		pha		   PHA               ; push next character
.a94f	c9 8d		cmp #$8d	   CMP #TK_GOSUB     ; compare with GOSUB token
.a951	f0 04		beq $a957	   BEQ BaON_20       ; if GOSUB go see if it should be executed
.a953					BaON_10
.a953	c9 89		cmp #$89	   CMP #TK_GOTO      ; compare with GOTO token
.a955	d0 91		bne $a8e8	   BNE BaRE_10       ; if not GOTO do syntax error then warm start
.a957					BaON_20
.a957	c6 65		dec $65		   DEC FAC1M4        ; decrement the byte value
.a959	d0 04		bne $a95f	   BNE BaON_30       ; if not zero go see if another line number exists
.a95b	68		pla		   PLA               ; pull keyword token
.a95c	4c ef a7	jmp $a7ef	   JMP Interpret_10
.a95f					BaON_30
.a95f	20 73 00	jsr $0073	   JSR CHRGET
.a962	20 6b a9	jsr $a96b	   JSR Scan_Linenumber
.a965	c9 2c		cmp #$2c	   CMP #','          ; compare next character with ","
.a967	f0 ee		beq $a957	   BEQ BaON_20       ; loop if ","
.a969	68		pla		   PLA               ; else pull keyword token, ran out of options
.a96a					BaON_Ret
.a96a	60		rts		   RTS
.a96b					  Scan_Linenumber
.a96b	a2 00		ldx #$00	   LDX #0
.a96d	86 14		stx $14		   STX LINNUM
.a96f	86 15		stx $15		   STX LINNUM+1
.a971					ScLi_Loop
.a971	b0 f7		bcs $a96a	   BCS BaON_Ret      ; return if carry set, end of scan, character was not 0-9
.a973	e9 2f		sbc #$2f	   SBC #$2F          ; subtract $30, $2F+carry, from byte
.a975	85 07		sta $07		   STA CHARAC        ; store # OPT: TAX
.a977	a5 15		lda $15		   LDA LINNUM+1      ; get temporary integer high byte
.a979	85 22		sta $22		   STA INDEXA        ; save it for now
.a97b	c9 19		cmp #$19	   CMP #$19          ; compare with $19
.a97d	b0 d4		bcs $a953	   BCS BaON_10       ; branch if >= this makes the maximum line number 63999
.a97f	a5 14		lda $14		   LDA LINNUM        ; get temporary integer low byte
.a981	0a		asl a		   ASL A             ; *2 low byte
.a982	26 22		rol $22		   ROL INDEXA        ; *2 high byte
.a984	0a		asl a		   ASL A             ; *2 low byte
.a985	26 22		rol $22		   ROL INDEXA        ; *2 high byte (*4)
.a987	65 14		adc $14		   ADC LINNUM        ; + low byte (*5)
.a989	85 14		sta $14		   STA LINNUM        ; save it
.a98b	a5 22		lda $22		   LDA INDEXA        ; get high byte temp
.a98d	65 15		adc $15		   ADC LINNUM+1      ; + high byte (*5)
.a98f	85 15		sta $15		   STA LINNUM+1      ; save it
.a991	06 14		asl $14		   ASL LINNUM        ; *2 low byte (*10d)
.a993	26 15		rol $15		   ROL LINNUM+1      ; *2 high byte (*10d)
.a995	a5 14		lda $14		   LDA LINNUM        ; get low byte OPT: TXA
.a997	65 07		adc $07		   ADC CHARAC        ; add #        OPT: ADC LINNUM
.a999	85 14		sta $14		   STA LINNUM        ; save low byte
.a99b	90 02		bcc $a99f	   BCC ScLi_10       ; if no overflow skip high byte increment
.a99d	e6 15		inc $15		   INC LINNUM+1      ; else increment high byte
.a99f					ScLi_10
.a99f	20 73 00	jsr $0073	   JSR CHRGET
.a9a2	4c 71 a9	jmp $a971	   JMP ScLi_Loop      ; OPT: BCC ScLi_Loop : RTS
.a9a5					  Basic_LET
.a9a5	20 8b b0	jsr $b08b	   JSR Get_Scalar_Address
.a9a8	85 49		sta $49		   STA FORPNT
.a9aa	84 4a		sty $4a		   STY FORPNT+1
.a9ac	a9 b2		lda #$b2	   LDA #TK_EQUAL
.a9ae	20 ff ae	jsr $aeff	   JSR Need_A        ; '=' is needed
.a9b1	a5 0e		lda $0e		   LDA INTFLG        ; get data type flag, $80 = integer, $00 = float
.a9b3	48		pha		   PHA               ; push data type flag
.a9b4	a5 0d		lda $0d		   LDA VALTYP        ; get data type flag, $FF = string, $00 = numeric
.a9b6	48		pha		   PHA               ; push data type flag
.a9b7	20 9e ad	jsr $ad9e	   JSR Eval_Expression
.a9ba	68		pla		   PLA               ; pop data type flag
.a9bb	2a		rol a		   ROL A             ; string bit into carry
.a9bc	20 90 ad	jsr $ad90	   JSR Check_Var_Type
.a9bf	d0 18		bne $a9d9	   BNE LET_20        ; if string go assign a string value
.a9c1	68		pla		   PLA               ; pop integer/float data type flag
.a9c2					  Assign_Numeric_variable
.a9c2	10 12		bpl $a9d6	   BPL LET_10        ; if float go assign a floating value
.a9c4	20 1b bc	jsr $bc1b	   JSR Round_FAC1_Checked
.a9c7	20 bf b1	jsr $b1bf	   JSR Eval_Integer
.a9ca	a0 00		ldy #$00	   LDY #0
.a9cc	a5 64		lda $64		   LDA FAC1M3        ; get FAC1 mantissa 3
.a9ce	91 49		sta ($49),y	   STA (FORPNT),Y    ; save as integer variable low byte
.a9d0	c8		iny		   INY
.a9d1	a5 65		lda $65		   LDA FAC1M4        ; get FAC1 mantissa 4
.a9d3	91 49		sta ($49),y	   STA (FORPNT),Y    ; save as integer variable high byte
.a9d5	60		rts		   RTS
.a9d6					LET_10
.a9d6	4c d0 bb	jmp $bbd0	   JMP Assign_FAC1_To_FOR_Index
.a9d9					LET_20
.a9d9	68		pla		   PLA               ; dump integer/float data type flag
.a9da					  Assign_String_Variable
.a9da	a4 4a		ldy $4a		   LDY FORPNT+1      ; get variable pointer high byte
.a9dc	c0 bf		cpy #$bf	   CPY #>NULL_Descriptor ; TI$
.a9de	d0 4c		bne $aa2c	   BNE Assign_String
.a9e0	20 a6 b6	jsr $b6a6	   JSR Get_String_Descriptor
.a9e3	c9 06		cmp #$06	   CMP #6            ; TI$ = "hhmmss"
.a9e5	d0 3d		bne $aa24	   BNE Jump_Illegal_Quantity
.a9e7	a0 00		ldy #$00	   LDY #0
.a9e9	84 61		sty $61		   STY FAC1EX        ; clear FAC1 exponent
.a9eb	84 66		sty $66		   STY FAC1SI        ; clear FAC1 sign (b7)
.a9ed					LET_30
.a9ed	84 71		sty $71		   STY TMPPTD        ; save index
.a9ef	20 1d aa	jsr $aa1d	   JSR Eval_Digit    ; check and evaluate numeric digit
.a9f2	20 e2 ba	jsr $bae2	   JSR Multiply_FAC1_BY_10
.a9f5	e6 71		inc $71		   INC TMPPTD        ; increment index
.a9f7	a4 71		ldy $71		   LDY TMPPTD        ; restore index
.a9f9	20 1d aa	jsr $aa1d	   JSR Eval_Digit    ; check and evaluate numeric digit
.a9fc	20 0c bc	jsr $bc0c	   JSR FAC1_Round_And_Copy_To_FAC2
.a9ff	aa		tax		   TAX               ; copy FAC1 exponent
.aa00	f0 05		beq $aa07	   BEQ LET_40        ; branch if FAC1 zero
.aa02	e8		inx		   INX               ; increment index, * 2
.aa03	8a		txa		   TXA               ; copy back to A
.aa04	20 ed ba	jsr $baed	   JSR Multiply_FAC1_By_4
.aa07					LET_40
.aa07	a4 71		ldy $71		   LDY TMPPTD        ; get index
.aa09	c8		iny		   INY
.aa0a	c0 06		cpy #$06	   CPY #6            ; max. 6 digits "hhmmss"
.aa0c	d0 df		bne $a9ed	   BNE LET_30
.aa0e	20 e2 ba	jsr $bae2	   JSR Multiply_FAC1_BY_10
.aa11	20 9b bc	jsr $bc9b	   JSR FAC1_To_Integer
.aa14	a6 64		ldx $64		   LDX FAC1M3        ; get FAC1 mantissa 3
.aa16	a4 63		ldy $63		   LDY FAC1M2        ; get FAC1 mantissa 2
.aa18	a5 65		lda $65		   LDA FAC1M4        ; get FAC1 mantissa 4
.aa1a	4c db ff	jmp $ffdb	   JMP SETTIM        ; Set the system clock
.aa1d					  Eval_Digit
.aa1d	b1 22		lda ($22),y	   LDA (INDEXA),Y    ; get byte from string
.aa1f	20 80 00	jsr $0080	   JSR ISNUM
.aa22	90 03		bcc $aa27	   BCC EvDi_10       ; branch if numeric
.aa24					Jump_Illegal_Quantity
.aa24	4c 48 b2	jmp $b248	   JMP Illegal_Quantity
.aa27					EvDi_10
.aa27	e9 2f		sbc #$2f	   SBC #$2F          ; subtract $2F + carry = '0'
.aa29	4c 7e bd	jmp $bd7e	   JMP Add_A_To_FAC1
.aa2c					  Assign_String
.aa2c	a0 02		ldy #$02	   LDY #2            ; index to string pointer high byte
.aa2e	b1 64		lda ($64),y	   LDA (FAC1M3),Y    ; get string pointer high byte
.aa30	c5 34		cmp $34		   CMP FRESPC+1      ; compare with bottom of string space high byte
.aa32	90 17		bcc $aa4b	   BCC AsSt_20       ; branch if string pointer < bottom of string space
.aa34	d0 07		bne $aa3d	   BNE AsSt_10       ; branch if string pointer > bottom of string space
.aa36	88		dey		   DEY               ; Y = 1
.aa37	b1 64		lda ($64),y	   LDA (FAC1M3),Y    ; get string pointer low byte
.aa39	c5 33		cmp $33		   CMP FRESPC        ; compare with bottom of string space low byte
.aa3b	90 0e		bcc $aa4b	   BCC AsSt_20       ; branch if string pointer < bottom of string space
.aa3d					AsSt_10
.aa3d	a4 65		ldy $65		   LDY FAC1M4        ; get descriptor pointer high byte
.aa3f	c4 2e		cpy $2e		   CPY VARTAB+1      ; compare with start of variables high byte
.aa41	90 08		bcc $aa4b	   BCC AsSt_20       ; branch if less, is on string stack
.aa43	d0 0d		bne $aa52	   BNE AsSt_30       ; if greater make space and copy string
.aa45	a5 64		lda $64		   LDA FAC1M3        ; get descriptor pointer low byte
.aa47	c5 2d		cmp $2d		   CMP VARTAB        ; compare with start of variables low byte
.aa49	b0 07		bcs $aa52	   BCS AsSt_30       ; if greater or equal make space and copy string
.aa4b					AsSt_20
.aa4b	a5 64		lda $64		   LDA FAC1M3        ; get descriptor pointer low byte
.aa4d	a4 65		ldy $65		   LDY FAC1M4        ; get descriptor pointer high byte
.aa4f	4c 68 aa	jmp $aa68	   JMP AsSt_40       ; go copy descriptor to variable
.aa52					AsSt_30
.aa52	a0 00		ldy #$00	   LDY #0
.aa54	b1 64		lda ($64),y	   LDA (FAC1M3),Y    ; get string length
.aa56	20 75 b4	jsr $b475	   JSR Allocate_String_FAC1
.aa59	a5 50		lda $50		   LDA DESCPT
.aa5b	a4 51		ldy $51		   LDY DESCPT+1
.aa5d	85 6f		sta $6f		   STA STRPTR
.aa5f	84 70		sty $70		   STY STRPTR+1
.aa61	20 7a b6	jsr $b67a	   JSR Store_String_STRPTR
.aa64	a9 61		lda #$61	   LDA #<FAC1EX ;#<addr
.aa66	a0 00		ldy #$00	   LDY #>FAC1EX ;#>addr
.aa68					AsSt_40
.aa68	85 50		sta $50		   STA DESCPT
.aa6a	84 51		sty $51		   STY DESCPT+1
.aa6c	20 db b6	jsr $b6db	   JSR Pop_Descriptor_Stack
.aa6f	a0 00		ldy #$00	   LDY #0
.aa71	b1 50		lda ($50),y	   LDA (DESCPT),Y    ; get string length from new descriptor
.aa73	91 49		sta ($49),y	   STA (FORPNT),Y    ; copy string length to variable
.aa75	c8		iny		   INY
.aa76	b1 50		lda ($50),y	   LDA (DESCPT),Y    ; get string pointer low byte from new descriptor
.aa78	91 49		sta ($49),y	   STA (FORPNT),Y    ; copy string pointer low byte to variable
.aa7a	c8		iny		   INY
.aa7b	b1 50		lda ($50),y	   LDA (DESCPT),Y    ; get string pointer high byte from new descriptor
.aa7d	91 49		sta ($49),y	   STA (FORPNT),Y    ; copy string pointer high byte to variable
.aa7f	60		rts		   RTS
.aa80					  Basic_PRINTN
.aa80	20 86 aa	jsr $aa86	   JSR Basic_CMD
.aa83	4c b5 ab	jmp $abb5	   JMP Set_Default_Channels
.aa86					  Basic_CMD
.aa86	20 9e b7	jsr $b79e	   JSR Get_Byte_Value
.aa89	f0 05		beq $aa90	   BEQ BCMD_10       ; branch if following byte is ":" or [EOT]
.aa8b	a9 2c		lda #$2c	   LDA #','
.aa8d	20 ff ae	jsr $aeff	   JSR Need_A
.aa90					BCMD_10
.aa90	08		php		   PHP               ; save status
.aa91	86 13		stx $13		   STX IOPMPT        ; set current I/O channel
.aa93	20 18 e1	jsr $e118	   JSR Select_Output_Channel
.aa96	28		plp		   PLP               ; restore status
.aa97	4c a0 aa	jmp $aaa0	   JMP Basic_PRINT   ; perform PRINT
.aa9a					BaPR_00
.aa9a	20 21 ab	jsr $ab21	   JSR Print_String_From_Descriptor
.aa9d					BaPR_05
.aa9d	20 79 00	jsr $0079	   JSR CHRGOT
.aaa0					  Basic_PRINT
.aaa0	f0 35		beq $aad7	   BEQ Print_CR
.aaa2					BaPR_10
.aaa2	f0 43		beq $aae7	   BEQ Invert_Ret      ; if nothing following exit, end of PRINT branch
.aaa4	c9 a3		cmp #$a3	   CMP #TK_TAB       ; compare with token for TAB(
.aaa6	f0 50		beq $aaf8	   BEQ TAB_20      ; if TAB( go handle it
.aaa8	c9 a6		cmp #$a6	   CMP #TK_SPC       ; compare with token for SPC(
.aaaa	18		clc		   CLC               ; flag SPC(
.aaab	f0 4b		beq $aaf8	   BEQ TAB_20      ; if SPC( go handle it
.aaad	c9 2c		cmp #$2c	   CMP #','
.aaaf	f0 37		beq $aae8	   BEQ TAB_Jump
.aab1	c9 3b		cmp #$3b	   CMP #SEMIC
.aab3	f0 5e		beq $ab13	   BEQ TAB_60      ; if ";" go continue the print loop
.aab5	20 9e ad	jsr $ad9e	   JSR Eval_Expression
.aab8	24 0d		bit $0d		   BIT VALTYP        ; test data type flag, $FF = string, $00 = numeric
.aaba	30 de		bmi $aa9a	   BMI BaPR_00      ; if string go print string, scan memory and continue PRINT
.aabc	20 dd bd	jsr $bddd	   JSR Format_FAC1
.aabf	20 87 b4	jsr $b487	   JSR Create_String_Descriptor
.aac2	20 21 ab	jsr $ab21	   JSR Print_String_From_Descriptor
.aac5	20 3b ab	jsr $ab3b	   JSR Cursor_Right_Or_Space
.aac8	d0 d3		bne $aa9d	   BNE BaPR_05      ; go scan memory and continue PRINT, branch always
.aaca					  Terminate_BUF
.aaca	a9 00		lda #$00	   LDA #0
.aacc	9d 00 02	sta $0200,x	   STA BUF,X         ; terminate string with 0 byte
.aacf	a2 ff		ldx #$ff	   LDX #<BUF-1
.aad1	a0 01		ldy #$01	   LDY #>BUF-1
.aad3	a5 13		lda $13		   LDA IOPMPT        ; get current I/O channel
.aad5	d0 10		bne $aae7	   BNE Invert_Ret      ; exit if not default channel
.aad7					  Print_CR
.aad7	a9 0d		lda #$0d	   LDA #CR
.aad9	20 47 ab	jsr $ab47	   JSR Print_Char
.aadc	24 13		bit $13		   BIT IOPMPT        ; test current I/O channel
.aade	10 05		bpl $aae5	   BPL Invert_A      ; needless, because this is always true
.aae0	a9 0a		lda #$0a	   LDA #LF
.aae2	20 47 ab	jsr $ab47	   JSR Print_Char
.aae5					  Invert_A
.aae5	49 ff		eor #$ff	   EOR #$FF          ; invert A
.aae7					Invert_Ret
.aae7	60		rts		   RTS
.aae8					  TAB_Jump
.aae8	38		sec		   SEC               ; set Cb for read cursor position
.aae9	20 f0 ff	jsr $fff0	   JSR PLOT          ; Read cursor location
.aaec	98		tya		   TYA               ; copy cursor Y
.aaed	38		sec		   SEC
.aaee					TAB_10
.aaee	e9 0a		sbc #$0a	   SBC #10           ; subtract one TAB length
.aaf0	b0 fc		bcs $aaee	   BCS TAB_10
.aaf2	49 ff		eor #$ff	   EOR #$FF          ; complement it
.aaf4	69 01		adc #$01	   ADC #1
.aaf6	d0 16		bne $ab0e	   BNE TAB_30        ; print A spaces, branch always
.aaf8					TAB_20
.aaf8	08		php		   PHP               ; save TAB( or SPC( status
.aaf9	38		sec		   SEC               ; set Cb for read cursor position
.aafa	20 f0 ff	jsr $fff0	   JSR PLOT          ; Read or set cursor location
.aafd	84 09		sty $09		   STY TRMPOS        ; save current cursor position
.aaff	20 9b b7	jsr $b79b	   JSR Get_Next_Byte_Value
.ab02	c9 29		cmp #$29	   CMP #$29          ; compare with ")"
.ab04	d0 59		bne $ab5f	   BNE BaIn_30       ; if not ")" do syntax error
.ab06	28		plp		   PLP               ; restore TAB( or SPC( status
.ab07	90 06		bcc $ab0f	   BCC TAB_40        ; branch if was SPC(
.ab09	8a		txa		   TXA               ; copy TAB() byte to A
.ab0a	e5 09		sbc $09		   SBC TRMPOS        ; subtract current cursor position
.ab0c	90 05		bcc $ab13	   BCC TAB_60        ; go loop for next if already past requited position
.ab0e					TAB_30
.ab0e	aa		tax		   TAX               ; copy [SPACE] count to X
.ab0f					TAB_40
.ab0f	e8		inx		   INX               ; increment count
.ab10					TAB_50
.ab10	ca		dex		   DEX               ; decrement count
.ab11	d0 06		bne $ab19	   BNE TAB_70        ; branch if count was not zero
.ab13					TAB_60
.ab13	20 73 00	jsr $0073	   JSR CHRGET
.ab16	4c a2 aa	jmp $aaa2	   JMP BaPR_10       ; continue print loop
.ab19					TAB_70
.ab19	20 3b ab	jsr $ab3b	   JSR Cursor_Right_Or_Space
.ab1c	d0 f2		bne $ab10	   BNE TAB_50        ; loop, branch always
.ab1e					  Print_String
.ab1e	20 87 b4	jsr $b487	   JSR Create_String_Descriptor
.ab21					  Print_String_From_Descriptor
.ab21	20 a6 b6	jsr $b6a6	   JSR Get_String_Descriptor
.ab24	aa		tax		   TAX               ; copy length
.ab25	a0 00		ldy #$00	   LDY #0
.ab27	e8		inx		   INX               ; increment length, for pre decrement loop
.ab28					PSFD_Loop
.ab28	ca		dex		   DEX               ; decrement length
.ab29	f0 bc		beq $aae7	   BEQ Invert_Ret    ; exit if done
.ab2b	b1 22		lda ($22),y	   LDA (INDEXA),Y    ; get byte from string
.ab2d	20 47 ab	jsr $ab47	   JSR Print_Char
.ab30	c8		iny		   INY
.ab31	c9 0d		cmp #$0d	   CMP #$0D          ; compare byte with [CR]
.ab33	d0 f3		bne $ab28	   BNE PSFD_Loop
.ab35	20 e5 aa	jsr $aae5	   JSR Invert_A      ; nonsense
.ab38	4c 28 ab	jmp $ab28	   JMP PSFD_Loop
.ab3b					  Cursor_Right_Or_Space
.ab3b	a5 13		lda $13		   LDA IOPMPT        ; get current I/O channel
.ab3d	f0 03		beq $ab42	   BEQ CROS_10       ; if default channel load [CURSOR RIGHT]
.ab3f	a9 20		lda #$20	   LDA #' '          ; else load [SPACE]
>ab41	2c				   .byte $2C         ; skip until Print_Char
.ab42					CROS_10
.ab42	a9 1d		lda #$1d	   LDA #$1D          ; load [CURSOR RIGHT]
>ab44	2c				   .byte $2C         ; skip until Print_Char
.ab45					  Print_Question_Mark
.ab45	a9 3f		lda #$3f	   LDA #'?'
.ab47					  Print_Char
.ab47	20 0c e1	jsr $e10c	   JSR CHROUT_Checked
.ab4a	29 ff		and #$ff	   AND #$FF          ; set flags
.ab4c	60		rts		   RTS
.ab4d					  Bad_Input
.ab4d	a5 11		lda $11		   LDA INPFLG        ; get INPUT mode flag, $00 = INPUT, $40 = GET, $98 = READ
.ab4f	f0 11		beq $ab62	   BEQ BaIn_40       ; branch if INPUT
.ab51	30 04		bmi $ab57	   BMI BaIn_10       ; branch if READ
.ab53	a0 ff		ldy #$ff	   LDY #$FF          ; set current line high byte to -1, indicate immediate mode
.ab55	d0 04		bne $ab5b	   BNE BaIn_20       ; branch always
.ab57					BaIn_10
.ab57	a5 3f		lda $3f		   LDA DATLIN
.ab59	a4 40		ldy $40		   LDY DATLIN+1
.ab5b					BaIn_20
.ab5b	85 39		sta $39		   STA CURLIN
.ab5d	84 3a		sty $3a		   STY CURLIN+1
.ab5f					BaIn_30
.ab5f	4c 08 af	jmp $af08	   JMP Syntax_Error
.ab62					BaIn_40
.ab62	a5 13		lda $13		   LDA IOPMPT        ; get current I/O channel
.ab64	f0 05		beq $ab6b	   BEQ BaIn_50       ; if default channel go do "?REDO FROM START" message
.ab66	a2 18		ldx #$18	   LDX #$18          ; else error $18, file data error
.ab68	4c 37 a4	jmp $a437	   JMP Basic_Error
.ab6b					BaIn_50
.ab6b	a9 0c		lda #$0c	   LDA #<Msg_Redo_From_Start
.ab6d	a0 ad		ldy #$ad	   LDY #>Msg_Redo_From_Start
.ab6f	20 1e ab	jsr $ab1e	   JSR Print_String
.ab72	a5 3d		lda $3d		   LDA OLDTXT
.ab74	a4 3e		ldy $3e		   LDY OLDTXT+1
.ab76	85 7a		sta $7a		   STA TXTPTR
.ab78	84 7b		sty $7b		   STY TXTPTR+1
.ab7a	60		rts		   RTS
.ab7b					  Basic_GET
.ab7b	20 a6 b3	jsr $b3a6	   JSR Assert_Non_Direct
.ab7e	c9 23		cmp #$23	   CMP #'#'          ; compare with "#"
.ab80	d0 10		bne $ab92	   BNE BaGE_10       ; branch if not GET#
.ab82	20 73 00	jsr $0073	   JSR CHRGET
.ab85	20 9e b7	jsr $b79e	   JSR Get_Byte_Value
.ab88	a9 2c		lda #$2c	   LDA #','
.ab8a	20 ff ae	jsr $aeff	   JSR Need_A
.ab8d	86 13		stx $13		   STX IOPMPT        ; set current I/O channel
.ab8f	20 1e e1	jsr $e11e	   JSR CHKIN_Checked
.ab92					BaGE_10
.ab92	a2 01		ldx #$01	   LDX #<BUF+1     ; set BUF+1 pointer low byte
.ab94	a0 02		ldy #$02	   LDY #>BUF+1     ; set BUF+1 pointer high byte
.ab96	a9 00		lda #$00	   LDA #0
.ab98	8d 01 02	sta $0201	   STA BUF+1         ; ensure null terminator
.ab9b	a9 40		lda #$40	   LDA #$40          ; input mode = GET
.ab9d	20 0f ac	jsr $ac0f	   JSR Read_Get
.aba0	a6 13		ldx $13		   LDX IOPMPT        ; get current I/O channel
.aba2	d0 13		bne $abb7	   BNE BaIN_101       ; if not default channel go do channel close and return
.aba4	60		rts		   RTS
.aba5					  Basic_INPUTN
.aba5	20 9e b7	jsr $b79e	   JSR Get_Byte_Value
.aba8	a9 2c		lda #$2c	   LDA #','
.abaa	20 ff ae	jsr $aeff	   JSR Need_A
.abad	86 13		stx $13		   STX IOPMPT        ; set current I/O channel
.abaf	20 1e e1	jsr $e11e	   JSR CHKIN_Checked
.abb2	20 ce ab	jsr $abce	   JSR Input_String
.abb5					  Set_Default_Channels
.abb5	a5 13		lda $13		   LDA IOPMPT        ; get current I/O channel
.abb7					BaIN_101
.abb7	20 cc ff	jsr $ffcc	   JSR CLRCHN        ; Clear I/O channels
.abba	a2 00		ldx #$00	   LDX #0
.abbc	86 13		stx $13		   STX IOPMPT        ; clear current I/O channel
.abbe	60		rts		   RTS
.abbf					  Basic_INPUT
.abbf	c9 22		cmp #$22	   CMP #QUOTE
.abc1	d0 0b		bne $abce	   BNE Input_String
.abc3	20 bd ae	jsr $aebd	   JSR Make_String_Descriptor_From_Code
.abc6	a9 3b		lda #$3b	   LDA #SEMIC
.abc8	20 ff ae	jsr $aeff	   JSR Need_A
.abcb	20 21 ab	jsr $ab21	   JSR Print_String_From_Descriptor
.abce					  Input_String
.abce	20 a6 b3	jsr $b3a6	   JSR Assert_Non_Direct
.abd1	a9 2c		lda #$2c	   LDA #','
.abd3	8d ff 01	sta $01ff	   STA BUF-1         ; save to start of buffer - 1
.abd6					BaIN_201
.abd6	20 f9 ab	jsr $abf9	   JSR Prompt_And_Input
.abd9	a5 13		lda $13		   LDA IOPMPT        ; get current I/O channel
.abdb	f0 0d		beq $abea	   BEQ BaIN_301       ; branch if default I/O channel
.abdd	20 b7 ff	jsr $ffb7	   JSR READST        ; read I/O status word
.abe0	29 02		and #$02	   AND #$02          ; mask no DSR/timeout
.abe2	f0 06		beq $abea	   BEQ BaIN_301       ; branch if not error
.abe4	20 b5 ab	jsr $abb5	   JSR Set_Default_Channels
.abe7	4c f8 a8	jmp $a8f8	   JMP Basic_DATA    ; perform DATA
.abea					BaIN_301
.abea	ad 00 02	lda $0200	   LDA BUF           ; get first byte in input buffer
.abed	d0 1e		bne $ac0d	   BNE BaIN_501
.abef	a5 13		lda $13		   LDA IOPMPT        ; get current I/O channel
.abf1	d0 e3		bne $abd6	   BNE BaIN_201       ; if not default channel go get BASIC input
.abf3	20 06 a9	jsr $a906	   JSR Next_Statement
.abf6	4c fb a8	jmp $a8fb	   JMP Add_Y_To_Execution_Pointer
.abf9					  Prompt_And_Input
.abf9	a5 13		lda $13		   LDA IOPMPT        ; get current I/O channel
.abfb	d0 06		bne $ac03	   BNE BaIN_401       ; skip "?" prompt if not default channel
.abfd	20 45 ab	jsr $ab45	   JSR Print_Question_Mark
.ac00	20 3b ab	jsr $ab3b	   JSR Cursor_Right_Or_Space
.ac03					BaIN_401
.ac03	4c 60 a5	jmp $a560	   JMP Read_String
.ac06					  Basic_READ
.ac06	a6 41		ldx $41		   LDX DATPTR
.ac08	a4 42		ldy $42		   LDY DATPTR+1
.ac0a	a9 98		lda #$98	   LDA #$98          ; set input mode = READ
>ac0c	2c				   .byte   $2C       ; skip next statement
.ac0d					BaIN_501
.ac0d	a9 00		lda #$00	   LDA #$00          ; set input mode = INPUT
.ac0f					  Read_Get
.ac0f	85 11		sta $11		   STA INPFLG        ; $00 = INPUT, $40 = GET, $98 = READ
.ac11	86 43		stx $43		   STX INPPTR
.ac13	84 44		sty $44		   STY INPPTR+1
.ac15					READ_Loop_Var
.ac15	20 8b b0	jsr $b08b	   JSR Get_Scalar_Address
.ac18	85 49		sta $49		   STA FORPNT
.ac1a	84 4a		sty $4a		   STY FORPNT+1
.ac1c	a5 7a		lda $7a		   LDA TXTPTR
.ac1e	a4 7b		ldy $7b		   LDY TXTPTR+1
.ac20	85 4b		sta $4b		   STA YSAVE
.ac22	84 4c		sty $4c		   STY YSAVE+1
.ac24	a6 43		ldx $43		   LDX INPPTR
.ac26	a4 44		ldy $44		   LDY INPPTR+1
.ac28	86 7a		stx $7a		   STX TXTPTR
.ac2a	84 7b		sty $7b		   STY TXTPTR+1
.ac2c	20 79 00	jsr $0079	   JSR CHRGOT
.ac2f	d0 20		bne $ac51	   BNE READ_20       ; branch if not null
.ac31	24 11		bit $11		   BIT INPFLG        ; $00 = INPUT, $40 = GET, $98 = READ
.ac33	50 0c		bvc $ac41	   BVC READ_05       ; branch if not GET
.ac35	20 24 e1	jsr $e124	   JSR GETIN_Checked
.ac38	8d 00 02	sta $0200	   STA BUF           ; save to buffer
.ac3b	a2 ff		ldx #$ff	   LDX #<BUF-1     ; set BUF-1 pointer low byte
.ac3d	a0 01		ldy #$01	   LDY #>BUF-1     ; set BUF-1 pointer high byte
.ac3f	d0 0c		bne $ac4d	   BNE READ_15       ; branch always
.ac41					READ_05
.ac41	30 75		bmi $acb8	   BMI READ_60      ; branch if READ else it's do INPUT
.ac43	a5 13		lda $13		   LDA IOPMPT        ; get current I/O channel
.ac45	d0 03		bne $ac4a	   BNE READ_10       ; skip "?" prompt if not default channel
.ac47	20 45 ab	jsr $ab45	   JSR Print_Question_Mark
.ac4a					READ_10
.ac4a	20 f9 ab	jsr $abf9	   JSR Prompt_And_Input
.ac4d					READ_15
.ac4d	86 7a		stx $7a		   STX TXTPTR
.ac4f	84 7b		sty $7b		   STY TXTPTR+1
.ac51					READ_20
.ac51	20 73 00	jsr $0073	   JSR CHRGET        ; execute pointer now points to start of next data
.ac54	24 0d		bit $0d		   BIT VALTYP        ; test data type flag, $FF = string, $00 = numeric
.ac56	10 31		bpl $ac89	   BPL READ_45      ; branch if numeric
.ac58	24 11		bit $11		   BIT INPFLG        ; $00 = INPUT, $40 = GET, $98 = READ
.ac5a	50 09		bvc $ac65	   BVC READ_25       ; branch if not GET
.ac5c	e8		inx		   INX               ; GET string
.ac5d	86 7a		stx $7a		   STX TXTPTR        ; save BASIC execute pointer low byte
.ac5f	a9 00		lda #$00	   LDA #0
.ac61	85 07		sta $07		   STA CHARAC        ; clear search character
.ac63	f0 0c		beq $ac71	   BEQ READ_30       ; branch always
.ac65					READ_25
.ac65	85 07		sta $07		   STA CHARAC        ; save search character
.ac67	c9 22		cmp #$22	   CMP #QUOTE
.ac69	f0 07		beq $ac72	   BEQ READ_35       ; if quote only search for "..." string
.ac6b	a9 3a		lda #$3a	   LDA #':'          ; set ":"
.ac6d	85 07		sta $07		   STA CHARAC        ; set search character
.ac6f	a9 2c		lda #$2c	   LDA #','
.ac71					READ_30
.ac71	18		clc		   CLC
.ac72					READ_35
.ac72	85 08		sta $08		   STA ENDCHR        ; set scan quotes flag
.ac74	a5 7a		lda $7a		   LDA TXTPTR
.ac76	a4 7b		ldy $7b		   LDY TXTPTR+1
.ac78	69 00		adc #$00	   ADC #0            ; INPUT and READ increment by carry
.ac7a	90 01		bcc $ac7d	   BCC READ_40       ; if no carry skip the high byte increment
.ac7c	c8		iny		   INY               ; else increment pointer high byte
.ac7d					READ_40
.ac7d	20 8d b4	jsr $b48d	   JSR Create_String_Descriptor_AY
.ac80	20 e2 b7	jsr $b7e2	   JSR Restore_Execution_Pointer
.ac83	20 da a9	jsr $a9da	   JSR Assign_String_Variable
.ac86	4c 91 ac	jmp $ac91	   JMP READ_50       ; continue processing command
.ac89					READ_45
.ac89	20 f3 bc	jsr $bcf3	   JSR Load_FAC1_From_String
.ac8c	a5 0e		lda $0e		   LDA INTFLG        ; get data type flag, $80 = integer, $00 = float
.ac8e	20 c2 a9	jsr $a9c2	   JSR Assign_Numeric_variable
.ac91					READ_50
.ac91	20 79 00	jsr $0079	   JSR CHRGOT
.ac94	f0 07		beq $ac9d	   BEQ READ_55       ; if ":" or [EOL] go handle the string end
.ac96	c9 2c		cmp #$2c	   CMP #','          ; comparte with ","
.ac98	f0 03		beq $ac9d	   BEQ READ_55       ; if "," go handle the string end
.ac9a	4c 4d ab	jmp $ab4d	   JMP Bad_Input
.ac9d					READ_55
.ac9d	a5 7a		lda $7a		   LDA TXTPTR
.ac9f	a4 7b		ldy $7b		   LDY TXTPTR+1
.aca1	85 43		sta $43		   STA INPPTR
.aca3	84 44		sty $44		   STY INPPTR+1
.aca5	a5 4b		lda $4b		   LDA YSAVE
.aca7	a4 4c		ldy $4c		   LDY YSAVE+1
.aca9	85 7a		sta $7a		   STA TXTPTR
.acab	84 7b		sty $7b		   STY TXTPTR+1
.acad	20 79 00	jsr $0079	   JSR CHRGOT
.acb0	f0 2d		beq $acdf	   BEQ READ_70       ; branch if ":" or [EOL]
.acb2	20 fd ae	jsr $aefd	   JSR Need_Comma
.acb5	4c 15 ac	jmp $ac15	   JMP READ_Loop_Var
.acb8					READ_60
.acb8	20 06 a9	jsr $a906	   JSR Next_Statement
.acbb	c8		iny		   INY
.acbc	aa		tax		   TAX               ; copy byte to X
.acbd	d0 12		bne $acd1	   BNE READ_65       ; if ":" go look for the next DATA
.acbf	a2 0d		ldx #$0d	   LDX #$0D          ; else set error $0D, out of data error
.acc1	c8		iny		   INY
.acc2	b1 7a		lda ($7a),y	   LDA (TXTPTR),Y    ; get next line pointer high byte
.acc4	f0 6c		beq $ad32	   BEQ NEXT_20      ; if program end go do error, eventually does error X
.acc6	c8		iny		   INY
.acc7	b1 7a		lda ($7a),y	   LDA (TXTPTR),Y    ; get next line # low byte
.acc9	85 3f		sta $3f		   STA DATLIN        ; save current DATA line low byte
.accb	c8		iny		   INY
.accc	b1 7a		lda ($7a),y	   LDA (TXTPTR),Y    ; get next line # high byte
.acce	c8		iny		   INY
.accf	85 40		sta $40		   STA DATLIN+1      ; save current DATA line high byte
.acd1					READ_65
.acd1	20 fb a8	jsr $a8fb	   JSR Add_Y_To_Execution_Pointer
.acd4	20 79 00	jsr $0079	   JSR CHRGOT
.acd7	aa		tax		   TAX               ; copy byte
.acd8	e0 83		cpx #$83	   CPX #TK_DATA      ; compare with token for DATA
.acda	d0 dc		bne $acb8	   BNE READ_60       ; loop if not DATA
.acdc	4c 51 ac	jmp $ac51	   JMP READ_20       ; continue evaluating READ
.acdf					READ_70
.acdf	a5 43		lda $43		   LDA INPPTR        ; get READ pointer low byte
.ace1	a4 44		ldy $44		   LDY INPPTR+1      ; get READ pointer high byte
.ace3	a6 11		ldx $11		   LDX INPFLG        ; get INPUT mode flag, $00 = INPUT, $40 = GET, $98 = READ
.ace5	10 03		bpl $acea	   BPL READ_75       ; if INPUT or GET go exit or ignore extra input
.ace7	4c 27 a8	jmp $a827	   JMP Store_DATPTR
.acea					READ_75
.acea	a0 00		ldy #$00	   LDY #0
.acec	b1 43		lda ($43),y	   LDA (INPPTR),Y    ; get READ byte
.acee	f0 0b		beq $acfb	   BEQ READ_Ret      ; exit if [EOL]
.acf0	a5 13		lda $13		   LDA IOPMPT        ; get current I/O channel
.acf2	d0 07		bne $acfb	   BNE READ_Ret      ; exit if not default channel
.acf4	a9 fc		lda #$fc	   LDA #<Msg_Extra_Ignored ;#<addr
.acf6	a0 ac		ldy #$ac	   LDY #>Msg_Extra_Ignored ;#>addr
.acf8	4c 1e ab	jmp $ab1e	   JMP Print_String
.acfb					READ_Ret
.acfb	60		rts		   RTS
>acfc	3f 45 58 54 52 41 20 49		Msg_Extra_Ignored   .TEXT "?EXTRA IGNORED\r",0
>ad04	47 4e 4f 52 45 44 0d 00
>ad0c	3f 52 45 44 4f 20 46 52		Msg_Redo_From_Start .TEXT "?REDO FROM START\r",0
>ad14	4f 4d 20 53 54 41 52 54 0d 00
.ad1e					  Basic_NEXT
.ad1e	d0 04		bne $ad24	   BNE Find_NEXT_Variable
.ad20	a0 00		ldy #$00	   LDY #0
.ad22	f0 03		beq $ad27	   BEQ NEXT_10      ; use any variable, branch always
.ad24					  Find_NEXT_Variable
.ad24	20 8b b0	jsr $b08b	   JSR Get_Scalar_Address
.ad27					NEXT_10
.ad27	85 49		sta $49		   STA FORPNT
.ad29	84 4a		sty $4a		   STY FORPNT+1
.ad2b	20 8a a3	jsr $a38a	   JSR Find_Active_FOR
.ad2e	f0 05		beq $ad35	   BEQ NEXT_30       ; if FOR found continue
.ad30	a2 0a		ldx #$0a	   LDX #$0A          ; else set error $0A, next without for error
.ad32					NEXT_20
.ad32	4c 37 a4	jmp $a437	   JMP Basic_Error
.ad35					NEXT_30
.ad35	9a		txs		   TXS               ; update stack pointer
.ad36	8a		txa		   TXA               ; copy stack pointer
.ad37	18		clc		   CLC
.ad38	69 04		adc #$04	   ADC #$04          ; point to STEP value
.ad3a	48		pha		   PHA               ; save it
.ad3b	69 06		adc #$06	   ADC #$06          ; point to TO value
.ad3d	85 24		sta $24		   STA INDEXB        ; save pointer to TO variable for compare
.ad3f	68		pla		   PLA               ; restore pointer to STEP value
.ad40	a0 01		ldy #$01	   LDY #$01          ; point to stack page
.ad42	20 a2 bb	jsr $bba2	   JSR Load_FAC1_AY
.ad45	ba		tsx		   TSX               ; get stack pointer back
.ad46	bd 09 01	lda $0109,x	   LDA STACK+9,X     ; get step sign
.ad49	85 66		sta $66		   STA FAC1SI        ; save FAC1 sign (b7)
.ad4b	a5 49		lda $49		   LDA FORPNT        ; get FOR/NEXT variable pointer low byte
.ad4d	a4 4a		ldy $4a		   LDY FORPNT+1      ; get FOR/NEXT variable pointer high byte
.ad4f	20 67 b8	jsr $b867	   JSR Add_Var_AY_To_FAC1
.ad52	20 d0 bb	jsr $bbd0	   JSR Assign_FAC1_To_FOR_Index
.ad55	a0 01		ldy #$01	   LDY #$01          ; point to stack page
.ad57	20 5d bc	jsr $bc5d	   JSR Compare_FAC1_INDEXB_Y ; compare FAC1 with TO value
.ad5a	ba		tsx		   TSX               ; get stack pointer back
.ad5b	38		sec		   SEC
.ad5c	fd 09 01	sbc $0109,x	   SBC STACK+9,X     ; subtract step sign
.ad5f	f0 17		beq $ad78	   BEQ NEXT_50       ; if = loop complete, go unstack the FOR
.ad61	bd 0f 01	lda $010f,x	   LDA STACK+$0F,X   ; get FOR line low byte
.ad64	85 39		sta $39		   STA CURLIN        ; save current line number low byte
.ad66	bd 10 01	lda $0110,x	   LDA STACK+$10,X   ; get FOR line high byte
.ad69	85 3a		sta $3a		   STA CURLIN+1      ; save current line number high byte
.ad6b	bd 12 01	lda $0112,x	   LDA STACK+$12,X   ; get BASIC execute pointer low byte
.ad6e	85 7a		sta $7a		   STA TXTPTR        ; save BASIC execute pointer low byte
.ad70	bd 11 01	lda $0111,x	   LDA STACK+$11,X   ; get BASIC execute pointer high byte
.ad73	85 7b		sta $7b		   STA TXTPTR+1      ; save BASIC execute pointer high byte
.ad75					NEXT_40
.ad75	4c ae a7	jmp $a7ae	   JMP Interpreter_Loop
.ad78					NEXT_50
.ad78	8a		txa		   TXA               ; stack copy to A
.ad79	69 11		adc #$11	   ADC #$11          ; add $12, $11 + carry, to dump FOR structure
.ad7b	aa		tax		   TAX               ; copy back to index
.ad7c	9a		txs		   TXS               ; copy to stack pointer
.ad7d	20 79 00	jsr $0079	   JSR CHRGOT
.ad80	c9 2c		cmp #$2c	   CMP #','
.ad82	d0 f1		bne $ad75	   BNE NEXT_40       ; if not "," go do interpreter inner loop
.ad84	20 73 00	jsr $0073	   JSR CHRGET
.ad87	20 24 ad	jsr $ad24	   JSR Find_NEXT_Variable
.ad8a					  Eval_Numeric
.ad8a	20 9e ad	jsr $ad9e	   JSR Eval_Expression
.ad8d					  Is_Numeric
.ad8d	18		clc		   CLC
>ad8e	24				   .byte   $24       ; skip next byte
.ad8f					  Assert_String_Type
.ad8f	38		sec		   SEC               ; string required
.ad90					  Check_Var_Type
.ad90	24 0d		bit $0d		   BIT VALTYP        ; test data type flag, $FF = string, $00 = numeric
.ad92	30 03		bmi $ad97	   BMI CVT_20        ; branch to string check
.ad94	b0 03		bcs $ad99	   BCS Type_Missmatch
.ad96					CVT_10
.ad96	60		rts		   RTS
.ad97					CVT_20
.ad97	b0 fd		bcs $ad96	   BCS CVT_10        ; exit if string is required
.ad99					Type_Missmatch
.ad99	a2 16		ldx #$16	   LDX #$16          ; error code $16, type missmatch error
.ad9b	4c 37 a4	jmp $a437	   JMP Basic_Error
.ad9e					  Eval_Expression
.ad9e	a6 7a		ldx $7a		   LDX TXTPTR        ; get BASIC execute pointer low byte
.ada0	d0 02		bne $ada4	   BNE EvEx_05       ; skip next if not zero
.ada2	c6 7b		dec $7b		   DEC TXTPTR+1      ; else decrement BASIC execute pointer high byte
.ada4					EvEx_05
.ada4	c6 7a		dec $7a		   DEC TXTPTR        ; decrement BASIC execute pointer low byte
.ada6	a2 00		ldx #$00	   LDX #$00          ; set null precedence, flag done
>ada8	24				   .byte   $24       ; makes next line BIT VARPNT+1
.ada9					EvEx_10
.ada9	48		pha		   PHA               ; push compare evaluation byte if branch to here
.adaa	8a		txa		   TXA               ; copy precedence byte
.adab	48		pha		   PHA               ; push precedence byte
.adac	a9 01		lda #$01	   LDA #$01          ; 2 bytes
.adae	20 fb a3	jsr $a3fb	   JSR Check_Stack_Avail
.adb1	20 83 ae	jsr $ae83	   JSR Evaluate
.adb4	a9 00		lda #$00	   LDA #0
.adb6	85 4d		sta $4d		   STA ACCSYM        ; clear comparrison evaluation flag
.adb8					EvEx_15
.adb8	20 79 00	jsr $0079	   JSR CHRGOT
.adbb					EvEx_20
.adbb	38		sec		   SEC
.adbc	e9 b1		sbc #$b1	   SBC #TK_GT        ; subtract token for ">"
.adbe	90 17		bcc $add7	   BCC EvEx_25       ; if < ">" skip comparrison test check
.adc0	c9 03		cmp #$03	   CMP #$03          ; compare with ">" to +3
.adc2	b0 13		bcs $add7	   BCS EvEx_25       ; if >= 3 skip comparrison test check
.adc4	c9 01		cmp #$01	   CMP #$01          ; compare with token for =
.adc6	2a		rol a		   ROL A             ; *2, b0 = carry (=1 if token was = or <)
.adc7	49 01		eor #$01	   EOR #$01          ; toggle b0
.adc9	45 4d		eor $4d		   EOR ACCSYM        ; EOR with comparrison evaluation flag
.adcb	c5 4d		cmp $4d		   CMP ACCSYM        ; compare with comparrison evaluation flag
.adcd	90 61		bcc $ae30	   BCC Jump_Syntax_Error      ; if < saved flag do syntax error then warm start
.adcf	85 4d		sta $4d		   STA ACCSYM        ; save new comparrison evaluation flag
.add1	20 73 00	jsr $0073	   JSR CHRGET
.add4	4c bb ad	jmp $adbb	   JMP EvEx_20       ; go do next character
.add7					EvEx_25
.add7	a6 4d		ldx $4d		   LDX ACCSYM        ; get comparrison evaluation flag
.add9	d0 2c		bne $ae07	   BNE EvEx_50       ; if compare function flagged go evaluate right hand side
.addb	b0 7b		bcs $ae58	   BCS Right_Operand      ; apply operator
.addd	69 07		adc #$07	   ADC #$07          ; add # of operators (+, -, *, /, ^, AND or OR)
.addf	90 77		bcc $ae58	   BCC Right_Operand      ; if < + operator go do the function
.ade1	65 0d		adc $0d		   ADC VALTYP        ; add data type flag, $FF = string, $00 = numeric
.ade3	d0 03		bne $ade8	   BNE EvEx_30       ; if not string or not + token skip concatenate
.ade5	4c 3d b6	jmp $b63d	   JMP Concatenate   ; add strings, string 1 is in the descriptor, string 2
.ade8					EvEx_30
.ade8	69 ff		adc #$ff	   ADC #$FF          ; -1 (corrects for carry add)
.adea	85 22		sta $22		   STA INDEXA        ; save it
.adec	0a		asl a		   ASL A             ; *2
.aded	65 22		adc $22		   ADC INDEXA        ; *3
.adef	a8		tay		   TAY               ; copy to index
.adf0					EvEx_35
.adf0	68		pla		   PLA               ; pull previous precedence
.adf1	d9 80 a0	cmp $a080,y	   CMP Basic_Operator_Table,Y  ; compare with precedence byte
.adf4	b0 67		bcs $ae5d	   BCS RiOp_20      ; if A >= go do the function
.adf6	20 8d ad	jsr $ad8d	   JSR Is_Numeric
.adf9					EvEx_40
.adf9	48		pha		   PHA               ; save precedence
.adfa					EvEx_45
.adfa	20 20 ae	jsr $ae20	   JSR Call_Operator_Function
.adfd	68		pla		   PLA               ; restore precedence
.adfe	a4 4b		ldy $4b		   LDY YSAVE         ; get precedence stacked flag
.ae00	10 17		bpl $ae19	   BPL EvEx_60       ; if stacked values go check the precedence
.ae02	aa		tax		   TAX               ; copy precedence, set flags
.ae03	f0 56		beq $ae5b	   BEQ RiOp_10      ; exit if done
.ae05	d0 5f		bne $ae66	   BNE RiOp_40      ; else pop FAC2 and return, branch always
.ae07					EvEx_50
.ae07	46 0d		lsr $0d		   LSR VALTYP        ; clear data type flag, $FF = string, $00 = numeric
.ae09	8a		txa		   TXA               ; copy compare function flag
.ae0a	2a		rol a		   ROL A             ; <<1, shift data type flag into b0, 1 = string, 0 = num
.ae0b	a6 7a		ldx $7a		   LDX TXTPTR        ; get BASIC execute pointer low byte
.ae0d	d0 02		bne $ae11	   BNE EvEx_55       ; if no underflow skip the high byte decrement
.ae0f	c6 7b		dec $7b		   DEC TXTPTR+1      ; else decrement BASIC execute pointer high byte
.ae11					EvEx_55
.ae11	c6 7a		dec $7a		   DEC TXTPTR        ; decrement BASIC execute pointer low byte
.ae13	a0 1b		ldy #$1b	   LDY #$1B          ; set offset to = operator precedence entry
.ae15	85 4d		sta $4d		   STA ACCSYM        ; save new comparrison evaluation flag
.ae17	d0 d7		bne $adf0	   BNE EvEx_35       ; branch always
.ae19					EvEx_60
.ae19	d9 80 a0	cmp $a080,y	   CMP Basic_Operator_Table,Y  ; compare with stacked function precedence
.ae1c	b0 48		bcs $ae66	   BCS RiOp_40      ; if A >=, pop FAC2 and return
.ae1e	90 d9		bcc $adf9	   BCC EvEx_40       ; else go stack this one and continue, branch always
.ae20					  Call_Operator_Function
.ae20	b9 82 a0	lda $a082,y	   LDA Basic_Operator_Table+2,Y
.ae23	48		pha		   PHA
.ae24	b9 81 a0	lda $a081,y	   LDA Basic_Operator_Table+1,Y
.ae27	48		pha		   PHA
.ae28	20 33 ae	jsr $ae33	   JSR Apply_Operator
.ae2b	a5 4d		lda $4d		   LDA ACCSYM        ; get comparrison evaluation flag
.ae2d	4c a9 ad	jmp $ada9	   JMP EvEx_10       ; continue evaluating expression
.ae30					Jump_Syntax_Error
.ae30	4c 08 af	jmp $af08	   JMP Syntax_Error
.ae33					  Apply_Operator
.ae33	a5 66		lda $66		   LDA FAC1SI        ; get FAC1 sign (b7)
.ae35	be 80 a0	ldx $a080,y	   LDX Basic_Operator_Table,Y  ; get precedence byte
.ae38					  Push_FAC1
.ae38	a8		tay		   TAY               ; copy sign
.ae39	68		pla		   PLA               ; get return address low byte
.ae3a	85 22		sta $22		   STA INDEXA        ; save it
.ae3c	e6 22		inc $22		   INC INDEXA        ; increment it as return-1 is pushed
.ae3e	68		pla		   PLA               ; get return address high byte
.ae3f	85 23		sta $23		   STA INDEXA+1      ; save it
.ae41	98		tya		   TYA               ; restore sign
.ae42	48		pha		   PHA               ; push sign
.ae43					  Round_And_Push_FAC1
.ae43	20 1b bc	jsr $bc1b	   JSR Round_FAC1_Checked
.ae46	a5 65		lda $65		   LDA FAC1M3+1
.ae48	48		pha		   PHA
.ae49	a5 64		lda $64		   LDA FAC1M3
.ae4b	48		pha		   PHA
.ae4c	a5 63		lda $63		   LDA FAC1M1+1
.ae4e	48		pha		   PHA
.ae4f	a5 62		lda $62		   LDA FAC1M1
.ae51	48		pha		   PHA
.ae52	a5 61		lda $61		   LDA FAC1EX        ; get FAC1 exponent
.ae54	48		pha		   PHA               ; push it
.ae55	6c 22 00	jmp ($0022)	   JMP (INDEXA)      ; return, sort of
.ae58					  Right_Operand
.ae58	a0 ff		ldy #$ff	   LDY #$FF          ; flag function
.ae5a	68		pla		   PLA               ; pull precedence byte
.ae5b					RiOp_10
.ae5b	f0 23		beq $ae80	   BEQ RiOp_50       ; exit if done
.ae5d					RiOp_20
.ae5d	c9 64		cmp #$64	   CMP #$64          ; compare previous precedence with $64
.ae5f	f0 03		beq $ae64	   BEQ RiOp_30       ; if was $64 (< function) skip the type check
.ae61	20 8d ad	jsr $ad8d	   JSR Is_Numeric
.ae64					RiOp_30
.ae64	84 4b		sty $4b		   STY YSAVE         ; save precedence stacked flag
.ae66					RiOp_40
.ae66	68		pla		   PLA               ; pop byte
.ae67	4a		lsr a		   LSR A             ; shift out comparison evaluation lowest bit
.ae68	85 12		sta $12		   STA TANSGN        ; save the comparison evaluation flag
.ae6a	68		pla		   PLA               ; pop exponent
.ae6b	85 69		sta $69		   STA FAC2EX        ; save FAC2 exponent
.ae6d	68		pla		   PLA
.ae6e	85 6a		sta $6a		   STA FAC2M1
.ae70	68		pla		   PLA
.ae71	85 6b		sta $6b		   STA FAC2M1+1
.ae73	68		pla		   PLA
.ae74	85 6c		sta $6c		   STA FAC2M3
.ae76	68		pla		   PLA
.ae77	85 6d		sta $6d		   STA FAC2M3+1
.ae79	68		pla		   PLA               ; pop sign
.ae7a	85 6e		sta $6e		   STA FAC2SI        ; save FAC2 sign (b7)
.ae7c	45 66		eor $66		   EOR FAC1SI        ; EOR FAC1 sign (b7)
.ae7e	85 6f		sta $6f		   STA STRPTR        ; save sign compare (FAC1 EOR FAC2)
.ae80					RiOp_50
.ae80	a5 61		lda $61		   LDA FAC1EX        ; get FAC1 exponent
.ae82	60		rts		   RTS
.ae83					  Evaluate
.ae83	6c 0a 03	jmp ($030a)	   JMP (IEVAL)       ; normally Default_EVAL
.ae86					  Default_EVAL
.ae86	a9 00		lda #$00	   LDA #0
.ae88	85 0d		sta $0d		   STA VALTYP        ; clear data type flag, $FF = string, $00 = numeric
.ae8a					EVA_10
.ae8a	20 73 00	jsr $0073	   JSR CHRGET
.ae8d	b0 03		bcs $ae92	   BCS EVA_30        ; if not numeric character continue
.ae8f					EVA_20
.ae8f	4c f3 bc	jmp $bcf3	   JMP Load_FAC1_From_String
.ae92					EVA_30
.ae92	20 13 b1	jsr $b113	   JSR Is_Alpha
.ae95	90 03		bcc $ae9a	   BCC EVA_40
.ae97	4c 28 af	jmp $af28	   JMP Get_Var       ; variable name set-up and return
.ae9a					EVA_40
.ae9a	c9 ff		cmp #$ff	   CMP #TK_PI
.ae9c	d0 0f		bne $aead	   BNE EVA_50        ; if not PI continue
.ae9e	a9 a8		lda #$a8	   LDA #<Float_PI ;#<addr
.aea0	a0 ae		ldy #$ae	   LDY #>Float_PI ;#>addr
.aea2	20 a2 bb	jsr $bba2	   JSR Load_FAC1_AY
.aea5	4c 73 00	jmp $0073	   JMP CHRGET
>aea8	82 49 0f da a1			Float_PI .byte $82,$49,$0F,$DA,$A1 ;.real 3.141592653
.aead					EVA_50
.aead	c9 2e		cmp #$2e	   CMP #'.'
.aeaf	f0 de		beq $ae8f	   BEQ EVA_20        ; if so get FAC1 from string and return, e.g. was .123
.aeb1	c9 ab		cmp #$ab	   CMP #TK_MINUS
.aeb3	f0 58		beq $af0d	   BEQ Prep_Minus_Operation
.aeb5	c9 aa		cmp #$aa	   CMP #TK_PLUS
.aeb7	f0 d1		beq $ae8a	   BEQ EVA_10        ; if + token ignore the leading +, +1 = 1
.aeb9	c9 22		cmp #$22	   CMP #QUOTE
.aebb	d0 0f		bne $aecc	   BNE EVA_70        ; if not open quote continue
.aebd					  Make_String_Descriptor_From_Code
.aebd	a5 7a		lda $7a		   LDA TXTPTR
.aebf	a4 7b		ldy $7b		   LDY TXTPTR+1
.aec1	69 00		adc #$00	   ADC #0            ; add carry to low byte
.aec3	90 01		bcc $aec6	   BCC EVA_60        ; branch if no overflow
.aec5	c8		iny		   INY               ; increment high byte
.aec6					EVA_60
.aec6	20 87 b4	jsr $b487	   JSR Create_String_Descriptor
.aec9	4c e2 b7	jmp $b7e2	   JMP Restore_Execution_Pointer
.aecc					EVA_70
.aecc	c9 a8		cmp #$a8	   CMP #TK_NOT       ; compare with token for NOT
.aece	d0 13		bne $aee3	   BNE EVA_80        ; if not token for NOT continue
.aed0	a0 18		ldy #$18	   LDY #$18          ; offset to NOT function
.aed2	d0 3b		bne $af0f	   BNE Prep_Operation      ; do set-up for function then execute, branch always
.aed4					  Basic_EQUAL
.aed4	20 bf b1	jsr $b1bf	   JSR Eval_Integer
.aed7	a5 65		lda $65		   LDA FAC1M4        ; get FAC1 mantissa 4
.aed9	49 ff		eor #$ff	   EOR #$FF          ; invert it
.aedb	a8		tay		   TAY               ; copy it
.aedc	a5 64		lda $64		   LDA FAC1M3        ; get FAC1 mantissa 3
.aede	49 ff		eor #$ff	   EOR #$FF          ; invert it
.aee0	4c 91 b3	jmp $b391	   JMP Integer_To_Float
.aee3					EVA_80
.aee3	c9 a5		cmp #$a5	   CMP #TK_FN        ; compare with token for FN
.aee5	d0 03		bne $aeea	   BNE EVA_90        ; if not token for FN continue
.aee7	4c f4 b3	jmp $b3f4	   JMP Eval_FNX      ; else go evaluate FNx
.aeea					EVA_90
.aeea	c9 b4		cmp #$b4	   CMP #TK_SGN       ; compare with token for SGN
.aeec	90 03		bcc $aef1	   BCC Eval_In_Parenthesis
.aeee	4c a7 af	jmp $afa7	   JMP Function_Call
.aef1					  Eval_In_Parenthesis
.aef1	20 fa ae	jsr $aefa	   JSR Need_Left_Parenthesis
.aef4	20 9e ad	jsr $ad9e	   JSR Eval_Expression
.aef7					  Need_Right_Parenthesis
.aef7	a9 29		lda #$29	   LDA #')'
>aef9	2c				   .byte   $2C       ; skip until Need_A
.aefa					  Need_Left_Parenthesis
.aefa	a9 28		lda #$28	   LDA #'('
>aefc	2c				   .byte   $2C       ; skip until Need_A
.aefd					  Need_Comma
.aefd	a9 2c		lda #$2c	   LDA #','
.aeff					  Need_A
.aeff	a0 00		ldy #$00	   LDY #0
.af01	d1 7a		cmp ($7a),y	   CMP (TXTPTR),Y    ; compare with BASIC byte
.af03	d0 03		bne $af08	   BNE Syntax_Error
.af05	4c 73 00	jmp $0073	   JMP CHRGET        ; else next program byte and return
.af08					  Syntax_Error
.af08	a2 0b		ldx #$0b	   LDX #$0B          ; error code $0B, syntax error
.af0a	4c 37 a4	jmp $a437	   JMP Basic_Error
.af0d					  Prep_Minus_Operation
.af0d	a0 15		ldy #$15	   LDY #$15          ; set offset from base to > operator
.af0f					Prep_Operation
.af0f	68		pla		   PLA               ; dump return address low byte
.af10	68		pla		   PLA               ; dump return address high byte
.af11	4c fa ad	jmp $adfa	   JMP EvEx_45      ; execute function then continue evaluation
.af14					  Is_Inside_BASIC_ROM
.af14	38		sec		   SEC
.af15	a5 64		lda $64		   LDA FAC1M3        ; get variable address low byte
.af17	e9 00		sbc #$00	   SBC #<BASIC_ROM   ; subtract BASIC_ROM low byte
.af19	a5 65		lda $65		   LDA FAC1M4        ; get variable address high byte
.af1b	e9 a0		sbc #$a0	   SBC #>BASIC_ROM   ; subtract BASIC_ROM high byte
.af1d	90 08		bcc $af27	   BCC IIBR_Ret      ; exit if address < BASIC_ROM
.af1f	a9 a2		lda #$a2	   LDA #<CHRGET_ROM  ; get end of BASIC marker low byte
.af21	e5 64		sbc $64		   SBC FAC1M3        ; subtract variable address low byte
.af23	a9 e3		lda #$e3	   LDA #>CHRGET_ROM  ; get end of BASIC marker high byte
.af25	e5 65		sbc $65		   SBC FAC1M4        ; subtract variable address high byte
.af27					IIBR_Ret
.af27	60		rts		   RTS
.af28					  Get_Var
.af28	20 8b b0	jsr $b08b	   JSR Get_Scalar_Address
.af2b	85 64		sta $64		   STA FAC1M3
.af2d	84 65		sty $65		   STY FAC1M3+1
.af2f	a6 45		ldx $45		   LDX VARNAM
.af31	a4 46		ldy $46		   LDY VARNAM+1
.af33	a5 0d		lda $0d		   LDA VALTYP        ; get data type flag, $FF = string, $00 = numeric
.af35	f0 26		beq $af5d	   BEQ Load_Value    ; if numeric go handle a numeric variable
.af37	a9 00		lda #$00	   LDA #0
.af39	85 70		sta $70		   STA FAC1M5        ; clear FAC1 rounding byte
.af3b	20 14 af	jsr $af14	   JSR Is_Inside_BASIC_ROM
.af3e	90 1c		bcc $af5c	   BCC GeVa_Ret      ; exit if not in BASIC ROM
.af40	e0 54		cpx #$54	   CPX #'T'          ; compare variable name first character with "T"
.af42	d0 18		bne $af5c	   BNE GeVa_Ret      ; exit if not "T"
.af44	c0 c9		cpy #$c9	   CPY #'I'+$80      ; compare variable name second character with "I$"
.af46	d0 14		bne $af5c	   BNE GeVa_Ret      ; exit if not "I$"
.af48	20 84 af	jsr $af84	   JSR Load_Jiffyclock
.af4b	84 5e		sty $5e		   STY TMPVA2        ; clear exponent count adjust
.af4d	88		dey		   DEY               ; Y = $FF
.af4e	84 71		sty $71		   STY TMPPTD        ; set output string index, -1 to allow for pre increment
.af50	a0 06		ldy #$06	   LDY #6            ; HH:MM:SS is six digits
.af52	84 5d		sty $5d		   STY TMPVA1        ; set number of characters before the decimal point
.af54	a0 24		ldy #$24	   LDY #Jiffy_Conversion_Table-Decimal_Conversion_Table
.af56	20 68 be	jsr $be68	   JSR Format_Jiffyclock
.af59	4c 6f b4	jmp $b46f	   JMP BaST_10      ; exit via STR$() code tail
.af5c					GeVa_Ret
.af5c	60		rts		   RTS
.af5d					  Load_Value
.af5d	24 0e		bit $0e		   BIT INTFLG        ; test data type flag, $80 = integer, $00 = float
.af5f	10 0d		bpl $af6e	   BPL Load_Float    ; if float go handle float
.af61	a0 00		ldy #$00	   LDY #0
.af63	b1 64		lda ($64),y	   LDA (FAC1M3),Y    ; get integer variable low byte
.af65	aa		tax		   TAX               ; copy to X
.af66	c8		iny		   INY
.af67	b1 64		lda ($64),y	   LDA (FAC1M3),Y    ; get integer variable high byte
.af69	a8		tay		   TAY               ; copy to Y
.af6a	8a		txa		   TXA               ; copy loa byte to A
.af6b	4c 91 b3	jmp $b391	   JMP Integer_To_Float
.af6e					  Load_Float
.af6e	20 14 af	jsr $af14	   JSR Is_Inside_BASIC_ROM
.af71	90 2d		bcc $afa0	   BCC Load_Float_Var ; if not get pointer and unpack into FAC1
.af73	e0 54		cpx #$54	   CPX #'T'
.af75	d0 1b		bne $af92	   BNE Check_ST_Var
.af77	c0 49		cpy #$49	   CPY #'I'          ; is it "TI" ?
.af79	d0 25		bne $afa0	   BNE Load_Float_Var
.af7b	20 84 af	jsr $af84	   JSR Load_Jiffyclock
.af7e	98		tya		   TYA               ; clear A
.af7f	a2 a0		ldx #$a0	   LDX #$A0          ; set exponent to 32 bit value
.af81	4c 4f bc	jmp $bc4f	   JMP CITF_10       ; set exponent = X and normalise FAC1
.af84					  Load_Jiffyclock
.af84	20 de ff	jsr $ffde	   JSR RDTIM         ; Read system clock
.af87	86 64		stx $64		   STX FAC1M3        ; save jiffy clock mid byte as  FAC1 mantissa 3
.af89	84 63		sty $63		   STY FAC1M2        ; save jiffy clock high byte as  FAC1 mantissa 2
.af8b	85 65		sta $65		   STA FAC1M4        ; save jiffy clock low byte as  FAC1 mantissa 4
.af8d	a0 00		ldy #$00	   LDY #$00          ; clear Y
.af8f	84 62		sty $62		   STY FAC1M1        ; clear FAC1 mantissa 1
.af91	60		rts		   RTS
.af92					  Check_ST_Var
.af92	e0 53		cpx #$53	   CPX #'S'
.af94	d0 0a		bne $afa0	   BNE Load_Float_Var
.af96	c0 54		cpy #$54	   CPY #'T'          ; is it "ST" ?
.af98	d0 06		bne $afa0	   BNE Load_Float_Var
.af9a	20 b7 ff	jsr $ffb7	   JSR READST
.af9d	4c 3c bc	jmp $bc3c	   JMP A_To_FAC1
.afa0					  Load_Float_Var
.afa0	a5 64		lda $64		   LDA FAC1M3
.afa2	a4 65		ldy $65		   LDY FAC1M3+1
.afa4	4c a2 bb	jmp $bba2	   JMP Load_FAC1_AY
.afa7					  Function_Call
.afa7	0a		asl a		   ASL A             ; offset = 2 * (token  - $80) : bit 7 shifted out
.afa8	48		pha		   PHA               ; save function offset
.afa9	aa		tax		   TAX               ; copy function offset
.afaa	20 73 00	jsr $0073	   JSR CHRGET
.afad	e0 8f		cpx #$8f	   CPX #$8F ;#((TK_CHRS - $80) * 2) + 1 ; chr$ index + 1
.afaf	90 20		bcc $afd1	   BCC FuCa_10       ; branch if not left$, right$, mid$
.afb1	20 fa ae	jsr $aefa	   JSR Need_Left_Parenthesis
.afb4	20 9e ad	jsr $ad9e	   JSR Eval_Expression
.afb7	20 fd ae	jsr $aefd	   JSR Need_Comma
.afba	20 8f ad	jsr $ad8f	   JSR Assert_String_Type
.afbd	68		pla		   PLA               ; restore function offset
.afbe	aa		tax		   TAX               ; copy it
.afbf	a5 65		lda $65		   LDA FAC1M3+1
.afc1	48		pha		   PHA
.afc2	a5 64		lda $64		   LDA FAC1M3
.afc4	48		pha		   PHA
.afc5	8a		txa		   TXA               ; restore function offset
.afc6	48		pha		   PHA               ; save function offset
.afc7	20 9e b7	jsr $b79e	   JSR Get_Byte_Value
.afca	68		pla		   PLA               ; restore function offset
.afcb	a8		tay		   TAY               ; copy function offset
.afcc	8a		txa		   TXA               ; copy byte parameter to A
.afcd	48		pha		   PHA               ; push byte parameter
.afce	4c d6 af	jmp $afd6	   JMP FuCa_20       ; go call function
.afd1					FuCa_10
.afd1	20 f1 ae	jsr $aef1	   JSR Eval_In_Parenthesis
.afd4	68		pla		   PLA               ; restore function offset
.afd5	a8		tay		   TAY               ; copy to index
.afd6					FuCa_20
.afd6	b9 ea 9f	lda $9fea,y	   LDA $9FEA,y ;Basic_Function_Table-2*(TK_SGN-$80),Y    ; .. -$68
.afd9	85 55		sta $55		   STA FUNJMP
.afdb	b9 eb 9f	lda $9feb,y	   LDA $9FEB,y ;Basic_Function_Table-2*(TK_SGN-$80)+1,Y  ; .. -$67
.afde	85 56		sta $56		   STA FUNJMP+1
.afe0	20 54 00	jsr $0054	   JSR JUMPER
.afe3	4c 8d ad	jmp $ad8d	   JMP Is_Numeric
.afe6					  Basic_OR
.afe6	a0 ff		ldy #$ff	   LDY #$FF          ; set Y for OR
>afe8	2c				   .byte   $2C       ; skip next statement
.afe9					  Basic_AND
.afe9	a0 00		ldy #$00	   LDY #$00          ; clear Y for AND
.afeb	84 0b		sty $0b		   STY COUNT         ; set AND/OR invert value
.afed	20 bf b1	jsr $b1bf	   JSR Eval_Integer
.aff0	a5 64		lda $64		   LDA FAC1M3        ; get FAC1 mantissa 3
.aff2	45 0b		eor $0b		   EOR COUNT         ; EOR low byte
.aff4	85 07		sta $07		   STA CHARAC        ; save it
.aff6	a5 65		lda $65		   LDA FAC1M4        ; get FAC1 mantissa 4
.aff8	45 0b		eor $0b		   EOR COUNT         ; EOR high byte
.affa	85 08		sta $08		   STA ENDCHR        ; save it
.affc	20 fc bb	jsr $bbfc	   JSR FAC2_To_FAC1
.afff	20 bf b1	jsr $b1bf	   JSR Eval_Integer
.b002	a5 65		lda $65		   LDA FAC1M4        ; get FAC1 mantissa 4
.b004	45 0b		eor $0b		   EOR COUNT         ; EOR high byte
.b006	25 08		and $08		   AND ENDCHR        ; AND with expression 1 high byte
.b008	45 0b		eor $0b		   EOR COUNT         ; EOR result high byte
.b00a	a8		tay		   TAY               ; save in Y
.b00b	a5 64		lda $64		   LDA FAC1M3        ; get FAC1 mantissa 3
.b00d	45 0b		eor $0b		   EOR COUNT         ; EOR low byte
.b00f	25 07		and $07		   AND CHARAC        ; AND with expression 1 low byte
.b011	45 0b		eor $0b		   EOR COUNT         ; EOR result low byte
.b013	4c 91 b3	jmp $b391	   JMP Integer_To_Float
.b016					  Basic_LESS
.b016	20 90 ad	jsr $ad90	   JSR Check_Var_Type
.b019	b0 13		bcs $b02e	   BCS BaLE_10       ; if string go do string compare
.b01b	a5 6e		lda $6e		   LDA FAC2SI        ; get FAC2 sign (b7)
.b01d	09 7f		ora #$7f	   ORA #$7F          ; set all non sign bits
.b01f	25 6a		and $6a		   AND FAC2M1        ; and FAC2 mantissa 1 (AND in sign bit)
.b021	85 6a		sta $6a		   STA FAC2M1        ; save FAC2 mantissa 1
.b023	a9 69		lda #$69	   LDA #<FAC2EX ;#<addr
.b025	a0 00		ldy #$00	   LDY #>FAC2EX ;#>addr
.b027	20 5b bc	jsr $bc5b	   JSR Compare_FAC1_AY
.b02a	aa		tax		   TAX               ; copy the result
.b02b	4c 61 b0	jmp $b061	   JMP BaLE_40       ; go evaluate result
.b02e					BaLE_10
.b02e	a9 00		lda #$00	   LDA #0
.b030	85 0d		sta $0d		   STA VALTYP        ; clear data type flag, $FF = string, $00 = numeric
.b032	c6 4d		dec $4d		   DEC ACCSYM        ; clear < bit in comparrison evaluation flag
.b034	20 a6 b6	jsr $b6a6	   JSR Get_String_Descriptor
.b037	85 61		sta $61		   STA FAC1EX        ; save length
.b039	86 62		stx $62		   STX FAC1M1        ; save string pointer low byte
.b03b	84 63		sty $63		   STY FAC1M2        ; save string pointer high byte
.b03d	a5 6c		lda $6c		   LDA FAC2M3        ; get descriptor pointer low byte
.b03f	a4 6d		ldy $6d		   LDY FAC2M4        ; get descriptor pointer high byte
.b041	20 aa b6	jsr $b6aa	   JSR Get_String_Descriptor_AY
.b044	86 6c		stx $6c		   STX FAC2M3        ; save string pointer low byte
.b046	84 6d		sty $6d		   STY FAC2M4        ; save string pointer high byte
.b048	aa		tax		   TAX               ; copy length
.b049	38		sec		   SEC
.b04a	e5 61		sbc $61		   SBC FAC1EX        ; subtract string 1 length
.b04c	f0 08		beq $b056	   BEQ BaLE_20       ; if str 1 length = string 2 length go compare the strings
.b04e	a9 01		lda #$01	   LDA #1            ; set str 1 length > string 2 length
.b050	90 04		bcc $b056	   BCC BaLE_20       ; if so return + 1 if otherwise equal
.b052	a6 61		ldx $61		   LDX FAC1EX        ; get string 1 length
.b054	a9 ff		lda #$ff	   LDA #$FF          ; set str 1 length < string 2 length
.b056					BaLE_20
.b056	85 66		sta $66		   STA FAC1SI        ; save length compare
.b058	a0 ff		ldy #$ff	   LDY #$FF          ; set index
.b05a	e8		inx		   INX               ; adjust for loop
.b05b					BaLE_30
.b05b	c8		iny		   INY
.b05c	ca		dex		   DEX               ; decrement count
.b05d	d0 07		bne $b066	   BNE BaLE_50       ; if still bytes to do go compare them
.b05f	a6 66		ldx $66		   LDX FAC1SI        ; get length compare back
.b061					BaLE_40
.b061	30 0f		bmi $b072	   BMI BaLE_60       ; branch if str 1 < str 2
.b063	18		clc		   CLC               ; flag str 1 <= str 2
.b064	90 0c		bcc $b072	   BCC BaLE_60       ; go evaluate result, branch always
.b066					BaLE_50
.b066	b1 6c		lda ($6c),y	   LDA (FAC2M3),Y    ; get string 2 byte
.b068	d1 62		cmp ($62),y	   CMP (FAC1M1),Y    ; compare with string 1 byte
.b06a	f0 ef		beq $b05b	   BEQ BaLE_30       ; loop if bytes =
.b06c	a2 ff		ldx #$ff	   LDX #$FF          ; set str 1 < string 2
.b06e	b0 02		bcs $b072	   BCS BaLE_60       ; branch if so
.b070	a2 01		ldx #$01	   LDX #$01          ; set str 1 > string 2
.b072					BaLE_60
.b072	e8		inx		   INX               ; x = 0, 1 or 2
.b073	8a		txa		   TXA               ; copy to A
.b074	2a		rol a		   ROL A             ; * 2 (1, 2 or 4)
.b075	25 12		and $12		   AND TANSGN        ; AND with the comparison evaluation flag
.b077	f0 02		beq $b07b	   BEQ BaLE_70       ; branch if 0 (compare is false)
.b079	a9 ff		lda #$ff	   LDA #$FF          ; else set result true
.b07b					BaLE_70
.b07b	4c 3c bc	jmp $bc3c	   JMP A_To_FAC1
.b07e					DIM_00
.b07e	20 fd ae	jsr $aefd	   JSR Need_Comma
.b081					  Basic_DIM
.b081	aa		tax		   TAX               ; copy "DIM" flag to X
.b082	20 90 b0	jsr $b090	   JSR Get_Array_Address
.b085	20 79 00	jsr $0079	   JSR CHRGOT
.b088	d0 f4		bne $b07e	   BNE DIM_00      ; scan for "," and loop if not null
.b08a	60		rts		   RTS
.b08b					  Get_Scalar_Address
.b08b	a2 00		ldx #$00	   LDX #$00          ; set DIM flag = $00
.b08d	20 79 00	jsr $0079	   JSR CHRGOT        ; 1st. character
.b090					  Get_Array_Address
.b090	86 0c		stx $0c		   STX DIMFLG        ; save DIM flag
.b092					  Get_FN_Address
.b092	85 45		sta $45		   STA VARNAM        ; save 1st character
.b094	20 79 00	jsr $0079	   JSR CHRGOT
.b097	20 13 b1	jsr $b113	   JSR Is_Alpha
.b09a	b0 03		bcs $b09f	   BCS Get_Address      ; if ok continue
.b09c					Var_Syntax_Error
.b09c	4c 08 af	jmp $af08	   JMP Syntax_Error
.b09f					  Get_Address
.b09f	a2 00		ldx #$00	   LDX #0            ; clear 2nd character temp
.b0a1	86 0d		stx $0d		   STX VALTYP        ; clear data type flag, $FF = string, $00 = numeric
.b0a3	86 0e		stx $0e		   STX INTFLG        ; clear data type flag, $80 = integer, $00 = float
.b0a5	20 73 00	jsr $0073	   JSR CHRGET        ; 2nd character
.b0a8	90 05		bcc $b0af	   BCC GAdd_05       ; if character = "0"-"9" (ok) go save 2nd character
.b0aa	20 13 b1	jsr $b113	   JSR Is_Alpha
.b0ad	90 0b		bcc $b0ba	   BCC GAdd_15       ; if <"A" or >"Z" go check if string
.b0af					GAdd_05
.b0af	aa		tax		   TAX               ; copy 2nd character
.b0b0					GAdd_10
.b0b0	20 73 00	jsr $0073	   JSR CHRGET        ; 3rd character
.b0b3	90 fb		bcc $b0b0	   BCC GAdd_10       ; loop if character = "0"-"9" (ignore)
.b0b5	20 13 b1	jsr $b113	   JSR Is_Alpha
.b0b8	b0 f6		bcs $b0b0	   BCS GAdd_10       ; loop if character = "A"-"Z" (ignore)
.b0ba					GAdd_15
.b0ba	c9 24		cmp #$24	   CMP #'$'
.b0bc	d0 06		bne $b0c4	   BNE GAdd_20       ; if not string go check integer
.b0be	a9 ff		lda #$ff	   LDA #$FF          ; set data type = string
.b0c0	85 0d		sta $0d		   STA VALTYP        ; set data type flag, $FF = string, $00 = numeric
.b0c2	d0 10		bne $b0d4	   BNE GAdd_25       ; branch always
.b0c4					GAdd_20
.b0c4	c9 25		cmp #$25	   CMP #'%'
.b0c6	d0 13		bne $b0db	   BNE GAdd_30       ; if not integer go check for an array
.b0c8	a5 10		lda $10		   LDA SUBFLG        ; get subscript/FNX flag
.b0ca	d0 d0		bne $b09c	   BNE Var_Syntax_Error      ; if ?? do syntax error then warm start
.b0cc	a9 80		lda #$80	   LDA #$80          ; set integer type
.b0ce	85 0e		sta $0e		   STA INTFLG        ; set data type = integer
.b0d0	05 45		ora $45		   ORA VARNAM        ; OR current variable name first byte
.b0d2	85 45		sta $45		   STA VARNAM        ; save current variable name first byte
.b0d4					GAdd_25
.b0d4	8a		txa		   TXA               ; get 2nd character back
.b0d5	09 80		ora #$80	   ORA #$80          ; set top bit, indicate string or integer variable
.b0d7	aa		tax		   TAX               ; copy back to 2nd character temp
.b0d8	20 73 00	jsr $0073	   JSR CHRGET
.b0db					GAdd_30
.b0db	86 46		stx $46		   STX VARNAM+1      ; save 2nd character
.b0dd	38		sec		   SEC
.b0de	05 10		ora $10		   ORA SUBFLG        ; or with subscript/FNX flag - or FN name
.b0e0	e9 28		sbc #$28	   SBC #'('
.b0e2	d0 03		bne $b0e7	   BNE GAdd_35       ; if not "(" go find a plain numeric variable
.b0e4	4c d1 b1	jmp $b1d1	   JMP Find_Array
.b0e7					GAdd_35
.b0e7	a0 00		ldy #$00	   LDY #0
.b0e9	84 10		sty $10		   STY SUBFLG        ; clear subscript/FNX flag
.b0eb	a5 2d		lda $2d		   LDA VARTAB
.b0ed	a6 2e		ldx $2e		   LDX VARTAB+1
.b0ef					GAdd_40
.b0ef	86 60		stx $60		   STX TMPPTC+1      ; save search address high byte
.b0f1					GAdd_45
.b0f1	85 5f		sta $5f		   STA TMPPTC        ; save search address low byte
.b0f3	e4 30		cpx $30		   CPX ARYTAB+1      ; compare with end of variables high byte
.b0f5	d0 04		bne $b0fb	   BNE GAdd_50       ; skip next compare if <>
.b0f7	c5 2f		cmp $2f		   CMP ARYTAB        ; compare low address with end of variables low byte
.b0f9	f0 22		beq $b11d	   BEQ Create_Var      ; if not found go make new variable
.b0fb					GAdd_50
.b0fb	a5 45		lda $45		   LDA VARNAM        ; get 1st character of variable to find
.b0fd	d1 5f		cmp ($5f),y	   CMP (TMPPTC),Y    ; compare with variable name 1st character
.b0ff	d0 08		bne $b109	   BNE GAdd_55       ; if no match go try the next variable
.b101	a5 46		lda $46		   LDA VARNAM+1      ; get 2nd character of variable to find
.b103	c8		iny		   INY               ; index to point to variable name 2nd character
.b104	d1 5f		cmp ($5f),y	   CMP (TMPPTC),Y    ; compare with variable name 2nd character
.b106	f0 7d		beq $b185	   BEQ CrVa_70      ; if match go return the variable
.b108	88		dey		   DEY               ; else decrement index (now = $00)
.b109					GAdd_55
.b109	18		clc		   CLC
.b10a	a5 5f		lda $5f		   LDA TMPPTC        ; get search address low byte
.b10c	69 07		adc #$07	   ADC #7            ; +7, offset to next variable name
.b10e	90 e1		bcc $b0f1	   BCC GAdd_45       ; loop if no overflow to high byte
.b110	e8		inx		   INX               ; else increment high byte
.b111	d0 dc		bne $b0ef	   BNE GAdd_40       ; loop always, RAM doesn't extend to $FFFF
.b113					  Is_Alpha
.b113	c9 41		cmp #$41	   CMP #'A'
.b115	90 05		bcc $b11c	   BCC IA_RET
.b117	e9 5b		sbc #$5b	   SBC #$5B          ; subtract "Z"+1
.b119	38		sec		   SEC
.b11a	e9 a5		sbc #$a5	   SBC #$A5          ; subtract $A5 (restore byte)
.b11c					IA_RET
.b11c	60		rts		   RTS
.b11d					  Create_Var
.b11d	68		pla		   PLA               ; pop return address low byte
.b11e	48		pha		   PHA               ; push return address low byte
.b11f	c9 2a		cmp #$2a	   CMP #<Get_Var+2 ; compare with expected calling routine return low byte
.b121	d0 05		bne $b128	   BNE CrVa_20       ; if not get variable go create new variable
.b123					CrVa_10
.b123	a9 13		lda #$13	   LDA #<NULL_Descriptor ;#<addr
.b125	a0 bf		ldy #$bf	   LDY #>NULL_Descriptor ;#>addr
.b127	60		rts		   RTS
.b128					CrVa_20
.b128	a5 45		lda $45		   LDA VARNAM
.b12a	a4 46		ldy $46		   LDY VARNAM+1
.b12c	c9 54		cmp #$54	   CMP #'T'
.b12e	d0 0b		bne $b13b	   BNE CrVa_40
.b130	c0 c9		cpy #$c9	   CPY #'I'+$80      ; is it TI$ ?
.b132	f0 ef		beq $b123	   BEQ CrVa_10
.b134	c0 49		cpy #$49	   CPY #'I'
.b136	d0 03		bne $b13b	   BNE CrVa_40       ; is it TI ?
.b138					CrVa_30
.b138	4c 08 af	jmp $af08	   JMP Syntax_Error
.b13b					CrVa_40
.b13b	c9 53		cmp #$53	   CMP #'S'          ; compare first character with "S"
.b13d	d0 04		bne $b143	   BNE CrVa_50      ; if not "S" continue
.b13f	c0 54		cpy #$54	   CPY #'T'          ; compare second character with "T"
.b141	f0 f5		beq $b138	   BEQ CrVa_30       ; if name is "ST" do syntax error
.b143					CrVa_50
.b143	a5 2f		lda $2f		   LDA ARYTAB
.b145	a4 30		ldy $30		   LDY ARYTAB+1
.b147	85 5f		sta $5f		   STA TMPPTC
.b149	84 60		sty $60		   STY TMPPTC+1
.b14b	a5 31		lda $31		   LDA STREND
.b14d	a4 32		ldy $32		   LDY STREND+1
.b14f	85 5a		sta $5a		   STA TMPPTB
.b151	84 5b		sty $5b		   STY TMPPTB+1
.b153	18		clc		   CLC
.b154	69 07		adc #$07	   ADC #7            ; +7, space for one variable
.b156	90 01		bcc $b159	   BCC CrVa_60       ; if no overflow skip the high byte increment
.b158	c8		iny		   INY               ; else increment high byte
.b159					CrVa_60
.b159	85 58		sta $58		   STA TMPPTA
.b15b	84 59		sty $59		   STY TMPPTA+1
.b15d	20 b8 a3	jsr $a3b8	   JSR Open_Up_Space
.b160	a5 58		lda $58		   LDA TMPPTA
.b162	a4 59		ldy $59		   LDY TMPPTA+1
.b164	c8		iny		   INY               ; correct high byte
.b165	85 2f		sta $2f		   STA ARYTAB
.b167	84 30		sty $30		   STY ARYTAB+1
.b169	a0 00		ldy #$00	   LDY #0
.b16b	a5 45		lda $45		   LDA VARNAM        ; get variable name 1st character
.b16d	91 5f		sta ($5f),y	   STA (TMPPTC),Y    ; save variable name 1st character
.b16f	c8		iny		   INY
.b170	a5 46		lda $46		   LDA VARNAM+1      ; get variable name 2nd character
.b172	91 5f		sta ($5f),y	   STA (TMPPTC),Y    ; save variable name 2nd character
.b174	a9 00		lda #$00	   LDA #0
.b176	c8		iny		   INY
.b177	91 5f		sta ($5f),y	   STA (TMPPTC),Y    ; initialise variable byte
.b179	c8		iny		   INY
.b17a	91 5f		sta ($5f),y	   STA (TMPPTC),Y    ; initialise variable byte
.b17c	c8		iny		   INY
.b17d	91 5f		sta ($5f),y	   STA (TMPPTC),Y    ; initialise variable byte
.b17f	c8		iny		   INY
.b180	91 5f		sta ($5f),y	   STA (TMPPTC),Y    ; initialise variable byte
.b182	c8		iny		   INY
.b183	91 5f		sta ($5f),y	   STA (TMPPTC),Y    ; initialise variable byte
.b185					CrVa_70
.b185	a5 5f		lda $5f		   LDA TMPPTC        ; get variable address low byte
.b187	18		clc		   CLC
.b188	69 02		adc #$02	   ADC #$02          ; +2, offset past variable name bytes
.b18a	a4 60		ldy $60		   LDY TMPPTC+1      ; get variable address high byte
.b18c	90 01		bcc $b18f	   BCC CrVa_80       ; if no overflow skip the high byte increment
.b18e	c8		iny		   INY               ; else increment high byte
.b18f					CrVa_80
.b18f	85 47		sta $47		   STA VARPNT
.b191	84 48		sty $48		   STY VARPNT+1
.b193	60		rts		   RTS
.b194					  Array_Pointer_To_First
.b194	a5 0b		lda $0b		   LDA COUNT         ; get # of dimensions (1, 2 or 3)
.b196	0a		asl a		   ASL A             ; *2 (also clears the carry !)
.b197	69 05		adc #$05	   ADC #$05          ; +5 (result is 7, 9 or 11 here)
.b199	65 5f		adc $5f		   ADC TMPPTC        ; add array start pointer low byte
.b19b	a4 60		ldy $60		   LDY TMPPTC+1      ; get array pointer high byte
.b19d	90 01		bcc $b1a0	   BCC APTF_10       ; if no overflow skip the high byte increment
.b19f	c8		iny		   INY               ; else increment high byte
.b1a0					APTF_10
.b1a0	85 58		sta $58		   STA TMPPTA
.b1a2	84 59		sty $59		   STY TMPPTA+1
.b1a4	60		rts		   RTS
>b1a5	90 80 00 00 00			Float_M32768 .byte $90,$80,$00,$00,$00 ;.real -32768
.b1aa					  Float_To_Integer
.b1aa	20 bf b1	jsr $b1bf	   JSR Eval_Integer
.b1ad	a5 64		lda $64		   LDA FAC1M3        ; get result low byte
.b1af	a4 65		ldy $65		   LDY FAC1M4        ; get result high byte
.b1b1	60		rts		   RTS
.b1b2					  Eval_Positive_Integer
.b1b2	20 73 00	jsr $0073	   JSR CHRGET
.b1b5	20 9e ad	jsr $ad9e	   JSR Eval_Expression
.b1b8					  Eval_Positive_Integer_Check
.b1b8	20 8d ad	jsr $ad8d	   JSR Is_Numeric
.b1bb	a5 66		lda $66		   LDA FAC1SI        ; get FAC1 sign (b7)
.b1bd	30 0d		bmi $b1cc	   BMI EvIn_10       ; do illegal quantity error negative
.b1bf					  Eval_Integer
.b1bf	a5 61		lda $61		   LDA FAC1EX        ; get FAC1 exponent
.b1c1	c9 90		cmp #$90	   CMP #$90          ; compare with exponent = 2^16 (n>2^15)
.b1c3	90 09		bcc $b1ce	   BCC EvIn_20       ; if n<2^16 go convert FAC1 floating to fixed and return
.b1c5	a9 a5		lda #$a5	   LDA #<Float_M32768 ;#<addr
.b1c7	a0 b1		ldy #$b1	   LDY #>Float_M32768 ;#>addr
.b1c9	20 5b bc	jsr $bc5b	   JSR Compare_FAC1_AY
.b1cc					EvIn_10
.b1cc	d0 7a		bne $b248	   BNE Illegal_Quantity
.b1ce					EvIn_20
.b1ce	4c 9b bc	jmp $bc9b	   JMP FAC1_To_Integer
.b1d1					  Find_Array
.b1d1	a5 0c		lda $0c		   LDA DIMFLG        ; get DIM flag
.b1d3	05 0e		ora $0e		   ORA INTFLG        ; OR with data type flag
.b1d5	48		pha		   PHA               ; push it
.b1d6	a5 0d		lda $0d		   LDA VALTYP        ; get data type flag, $FF = string, $00 = numeric
.b1d8	48		pha		   PHA               ; push it
.b1d9	a0 00		ldy #$00	   LDY #0            ; clear dimensions count
.b1db					FiAr_05
.b1db	98		tya		   TYA               ; copy dimensions count
.b1dc	48		pha		   PHA               ; save it
.b1dd	a5 46		lda $46		   LDA VARNAM+1
.b1df	48		pha		   PHA
.b1e0	a5 45		lda $45		   LDA VARNAM
.b1e2	48		pha		   PHA
.b1e3	20 b2 b1	jsr $b1b2	   JSR Eval_Positive_Integer
.b1e6	68		pla		   PLA
.b1e7	85 45		sta $45		   STA VARNAM
.b1e9	68		pla		   PLA
.b1ea	85 46		sta $46		   STA VARNAM+1
.b1ec	68		pla		   PLA               ; pull dimensions count
.b1ed	a8		tay		   TAY               ; restore it
.b1ee	ba		tsx		   TSX               ; copy stack pointer
.b1ef	bd 02 01	lda $0102,x	   LDA STACK+2,X     ; get DIM flag
.b1f2	48		pha		   PHA               ; push it
.b1f3	bd 01 01	lda $0101,x	   LDA STACK+1,X     ; get data type flag
.b1f6	48		pha		   PHA               ; push it
.b1f7	a5 64		lda $64		   LDA FAC1M3        ; get this dimension size high byte
.b1f9	9d 02 01	sta $0102,x	   STA STACK+2,X     ; stack before flag bytes
.b1fc	a5 65		lda $65		   LDA FAC1M4        ; get this dimension size low byte
.b1fe	9d 01 01	sta $0101,x	   STA STACK+1,X     ; stack before flag bytes
.b201	c8		iny		   INY               ; increment dimensions count
.b202	20 79 00	jsr $0079	   JSR CHRGOT
.b205	c9 2c		cmp #$2c	   CMP #','
.b207	f0 d2		beq $b1db	   BEQ FiAr_05       ; if found go do next dimension
.b209	84 0b		sty $0b		   STY COUNT         ; store dimensions count
.b20b	20 f7 ae	jsr $aef7	   JSR Need_Right_Parenthesis
.b20e	68		pla		   PLA               ; pull data type flag
.b20f	85 0d		sta $0d		   STA VALTYP        ; restore data type flag, $FF = string, $00 = numeric
.b211	68		pla		   PLA               ; pull data type flag
.b212	85 0e		sta $0e		   STA INTFLG        ; restore data type flag, $80 = integer, $00 = float
.b214	29 7f		and #$7f	   AND #$7F          ; mask dim flag
.b216	85 0c		sta $0c		   STA DIMFLG        ; restore DIM flag
.b218	a6 2f		ldx $2f		   LDX ARYTAB        ; set end of variables low byte
.b21a	a5 30		lda $30		   LDA ARYTAB+1      ; set end of variables high byte
.b21c					FiAr_10
.b21c	86 5f		stx $5f		   STX TMPPTC        ; save as array start pointer low byte
.b21e	85 60		sta $60		   STA TMPPTC+1      ; save as array start pointer high byte
.b220	c5 32		cmp $32		   CMP STREND+1      ; compare with end of arrays high byte
.b222	d0 04		bne $b228	   BNE FiAr_15       ; if not reached array memory end continue searching
.b224	e4 31		cpx $31		   CPX STREND        ; else compare with end of arrays low byte
.b226	f0 39		beq $b261	   BEQ FiAr_30       ; go build array if not found
.b228					FiAr_15
.b228	a0 00		ldy #$00	   LDY #0
.b22a	b1 5f		lda ($5f),y	   LDA (TMPPTC),Y    ; get array name first byte
.b22c	c8		iny		   INY
.b22d	c5 45		cmp $45		   CMP VARNAM        ; compare with this array name first byte
.b22f	d0 06		bne $b237	   BNE FiAr_20       ; if no match go try the next array
.b231	a5 46		lda $46		   LDA VARNAM+1      ; else get this array name second byte
.b233	d1 5f		cmp ($5f),y	   CMP (TMPPTC),Y    ; compare with array name second byte
.b235	f0 16		beq $b24d	   BEQ FiAr_25       ; array found so branch
.b237					FiAr_20
.b237	c8		iny		   INY
.b238	b1 5f		lda ($5f),y	   LDA (TMPPTC),Y    ; get array size low byte
.b23a	18		clc		   CLC
.b23b	65 5f		adc $5f		   ADC TMPPTC        ; add array start pointer low byte
.b23d	aa		tax		   TAX               ; copy low byte to X
.b23e	c8		iny		   INY
.b23f	b1 5f		lda ($5f),y	   LDA (TMPPTC),Y    ; get array size high byte
.b241	65 60		adc $60		   ADC TMPPTC+1      ; add array memory pointer high byte
.b243	90 d7		bcc $b21c	   BCC FiAr_10      ; if no overflow go check next array
.b245					  Bad_Subscript
.b245	a2 12		ldx #$12	   LDX #$12          ; error $12, bad subscript error
>b247	2c				   .byte   $2C       ; skip next statement
.b248					  Illegal_Quantity
.b248	a2 0e		ldx #$0e	   LDX #$0E          ; error $0E, illegal quantity error
.b24a					Jump_Basic_Error
.b24a	4c 37 a4	jmp $a437	   JMP Basic_Error
.b24d					FiAr_25
.b24d	a2 13		ldx #$13	   LDX #$13          ; set error $13, double dimension error
.b24f	a5 0c		lda $0c		   LDA DIMFLG        ; get DIM flag
.b251	d0 f7		bne $b24a	   BNE Jump_Basic_Error
.b253	20 94 b1	jsr $b194	   JSR Array_Pointer_To_First
.b256	a5 0b		lda $0b		   LDA COUNT         ; get dimensions count
.b258	a0 04		ldy #$04	   LDY #4            ; set index to array's # of dimensions
.b25a	d1 5f		cmp ($5f),y	   CMP (TMPPTC),Y    ; compare with no of dimensions
.b25c	d0 e7		bne $b245	   BNE Bad_Subscript ; if wrong do bad subscript error
.b25e	4c ea b2	jmp $b2ea	   JMP Find_Array_Element
.b261					FiAr_30
.b261	20 94 b1	jsr $b194	   JSR Array_Pointer_To_First
.b264	20 08 a4	jsr $a408	   JSR Check_Mem_Avail
.b267	a0 00		ldy #$00	   LDY #0
.b269	84 72		sty $72		   STY TMPPTD+1      ; clear array data size high byte
.b26b	a2 05		ldx #$05	   LDX #5            ; set default element size
.b26d	a5 45		lda $45		   LDA VARNAM        ; get variable name 1st byte
.b26f	91 5f		sta ($5f),y	   STA (TMPPTC),Y    ; save array name 1st byte
.b271	10 01		bpl $b274	   BPL FiAr_35       ; branch if not string or floating point array
.b273	ca		dex		   DEX               ; decrement element size, $04
.b274					FiAr_35
.b274	c8		iny		   INY
.b275	a5 46		lda $46		   LDA VARNAM+1      ; get variable name 2nd byte
.b277	91 5f		sta ($5f),y	   STA (TMPPTC),Y    ; save array name 2nd byte
.b279	10 02		bpl $b27d	   BPL FiAr_40       ; branch if not integer or string
.b27b	ca		dex		   DEX               ; decrement element size, $03
.b27c	ca		dex		   DEX               ; decrement element size, $02
.b27d					FiAr_40
.b27d	86 71		stx $71		   STX TMPPTD        ; save element size
.b27f	a5 0b		lda $0b		   LDA COUNT         ; get dimensions count
.b281	c8		iny		   INY
.b282	c8		iny		   INY               ; .. to array  ..
.b283	c8		iny		   INY               ; .. dimension count
.b284	91 5f		sta ($5f),y	   STA (TMPPTC),Y    ; save array dimension count
.b286					FiAr_45
.b286	a2 0b		ldx #$0b	   LDX #11           ; set default dimension size low byte (0:10)
.b288	a9 00		lda #$00	   LDA #0            ; set default dimension size high byte
.b28a	24 0c		bit $0c		   BIT DIMFLG        ; test DIM flag
.b28c	50 08		bvc $b296	   BVC FiAr_50       ; if default to be used don't pull a dimension
.b28e	68		pla		   PLA               ; pull dimension size low byte
.b28f	18		clc		   CLC
.b290	69 01		adc #$01	   ADC #1            ; add 1, allow for zeroeth element
.b292	aa		tax		   TAX               ; copy low byte to X
.b293	68		pla		   PLA               ; pull dimension size high byte
.b294	69 00		adc #$00	   ADC #0            ; add carry to high byte
.b296					FiAr_50
.b296	c8		iny		   INY               ; incement index to dimension size high byte
.b297	91 5f		sta ($5f),y	   STA (TMPPTC),Y    ; save dimension size high byte
.b299	c8		iny		   INY               ; incement index to dimension size low byte
.b29a	8a		txa		   TXA               ; copy dimension size low byte
.b29b	91 5f		sta ($5f),y	   STA (TMPPTC),Y    ; save dimension size low byte
.b29d	20 4c b3	jsr $b34c	   JSR Compute_Array_Size
.b2a0	86 71		stx $71		   STX TMPPTD        ; save result low byte
.b2a2	85 72		sta $72		   STA TMPPTD+1      ; save result high byte
.b2a4	a4 22		ldy $22		   LDY INDEXA        ; restore index
.b2a6	c6 0b		dec $0b		   DEC COUNT         ; decrement dimensions count
.b2a8	d0 dc		bne $b286	   BNE FiAr_45       ; loop if not all done
.b2aa	65 59		adc $59		   ADC TMPPTA+1      ; add array data pointer high byte
.b2ac	b0 5d		bcs $b30b	   BCS FiAE_30       ; if overflow do out of memory error then warm start
.b2ae	85 59		sta $59		   STA TMPPTA+1      ; save array data pointer high byte
.b2b0	a8		tay		   TAY               ; copy array data pointer high byte
.b2b1	8a		txa		   TXA               ; copy array size low byte
.b2b2	65 58		adc $58		   ADC TMPPTA        ; add array data pointer low byte
.b2b4	90 03		bcc $b2b9	   BCC FiAr_55       ; if no rollover skip the high byte increment
.b2b6	c8		iny		   INY               ; else increment next array pointer high byte
.b2b7	f0 52		beq $b30b	   BEQ FiAE_30       ; if rolled over do out of memory error then warm start
.b2b9					FiAr_55
.b2b9	20 08 a4	jsr $a408	   JSR Check_Mem_Avail
.b2bc	85 31		sta $31		   STA STREND
.b2be	84 32		sty $32		   STY STREND+1
.b2c0	a9 00		lda #$00	   LDA #0            ; for array clear
.b2c2	e6 72		inc $72		   INC TMPPTD+1      ; increment array size high byte, now block count
.b2c4	a4 71		ldy $71		   LDY TMPPTD        ; get array size low byte, now index to block
.b2c6	f0 05		beq $b2cd	   BEQ FiAr_65       ; if $00 go do the high byte decrement
.b2c8					FiAr_60
.b2c8	88		dey		   DEY               ; decrement index, do 0 to n-1
.b2c9	91 58		sta ($58),y	   STA (TMPPTA),Y    ; clear array element byte
.b2cb	d0 fb		bne $b2c8	   BNE FiAr_60       ; loop until this block done
.b2cd					FiAr_65
.b2cd	c6 59		dec $59		   DEC TMPPTA+1      ; decrement array pointer high byte
.b2cf	c6 72		dec $72		   DEC TMPPTD+1      ; decrement block count high byte
.b2d1	d0 f5		bne $b2c8	   BNE FiAr_60       ; loop until all blocks done
.b2d3	e6 59		inc $59		   INC TMPPTA+1      ; correct for last loop
.b2d5	38		sec		   SEC
.b2d6	a5 31		lda $31		   LDA STREND        ; get end of arrays low byte
.b2d8	e5 5f		sbc $5f		   SBC TMPPTC        ; subtract array start low byte
.b2da	a0 02		ldy #$02	   LDY #$02          ; index to array size low byte
.b2dc	91 5f		sta ($5f),y	   STA (TMPPTC),Y    ; save array size low byte
.b2de	a5 32		lda $32		   LDA STREND+1      ; get end of arrays high byte
.b2e0	c8		iny		   INY               ; index to array size high byte
.b2e1	e5 60		sbc $60		   SBC TMPPTC+1      ; subtract array start high byte
.b2e3	91 5f		sta ($5f),y	   STA (TMPPTC),Y    ; save array size high byte
.b2e5	a5 0c		lda $0c		   LDA DIMFLG        ; get default DIM flag
.b2e7	d0 62		bne $b34b	   BNE FiAE_Ret      ; exit if this was a DIM command
.b2e9	c8		iny		   INY               ; set index to # of dimensions, the dimension indeces
.b2ea					  Find_Array_Element
.b2ea	b1 5f		lda ($5f),y	   LDA (TMPPTC),Y    ; get array's dimension count
.b2ec	85 0b		sta $0b		   STA COUNT         ; save it
.b2ee	a9 00		lda #$00	   LDA #0
.b2f0	85 71		sta $71		   STA TMPPTD        ; clear array data pointer low byte
.b2f2					FiAE_10
.b2f2	85 72		sta $72		   STA TMPPTD+1      ; save array data pointer high byte
.b2f4	c8		iny		   INY
.b2f5	68		pla		   PLA               ; pull array index low byte
.b2f6	aa		tax		   TAX               ; copy to X
.b2f7	85 64		sta $64		   STA FAC1M3        ; save index low byte to FAC1 mantissa 3
.b2f9	68		pla		   PLA               ; pull array index high byte
.b2fa	85 65		sta $65		   STA FAC1M4        ; save index high byte to FAC1 mantissa 4
.b2fc	d1 5f		cmp ($5f),y	   CMP (TMPPTC),Y    ; compare with array bound high byte
.b2fe	90 0e		bcc $b30e	   BCC FiAE_40       ; if within bounds continue
.b300	d0 06		bne $b308	   BNE FiAE_20       ; if outside bounds do bad subscript error
.b302	c8		iny		   INY               ; index to array bound low byte
.b303	8a		txa		   TXA               ; get array index low byte
.b304	d1 5f		cmp ($5f),y	   CMP (TMPPTC),Y    ; compare with array bound low byte
.b306	90 07		bcc $b30f	   BCC FiAE_50       ; if within bounds continue
.b308					FiAE_20
.b308	4c 45 b2	jmp $b245	   JMP Bad_Subscript
.b30b					FiAE_30
.b30b	4c 35 a4	jmp $a435	   JMP Error_Out_Of_Memory
.b30e					FiAE_40
.b30e	c8		iny		   INY               ; index to array bound low byte
.b30f					FiAE_50
.b30f	a5 72		lda $72		   LDA TMPPTD+1      ; get array data pointer high byte
.b311	05 71		ora $71		   ORA TMPPTD        ; OR with array data pointer low byte
.b313	18		clc		   CLC
.b314	f0 0a		beq $b320	   BEQ FiAE_60       ; if array data pointer = null skip the multiply
.b316	20 4c b3	jsr $b34c	   JSR Compute_Array_Size
.b319	8a		txa		   TXA               ; get result low byte
.b31a	65 64		adc $64		   ADC FAC1M3        ; add index low byte from FAC1 mantissa 3
.b31c	aa		tax		   TAX               ; save result low byte
.b31d	98		tya		   TYA               ; get result high byte
.b31e	a4 22		ldy $22		   LDY INDEXA        ; restore index
.b320					FiAE_60
.b320	65 65		adc $65		   ADC FAC1M4        ; add index high byte from FAC1 mantissa 4
.b322	86 71		stx $71		   STX TMPPTD        ; save array data pointer low byte
.b324	c6 0b		dec $0b		   DEC COUNT         ; decrement dimensions count
.b326	d0 ca		bne $b2f2	   BNE FiAE_10       ; loop if dimensions still to do
.b328	85 72		sta $72		   STA TMPPTD+1      ; save array data pointer high byte
.b32a	a2 05		ldx #$05	   LDX #$05          ; set default element size
.b32c	a5 45		lda $45		   LDA VARNAM        ; get variable name 1st byte
.b32e	10 01		bpl $b331	   BPL FiAE_70       ; branch if not string or floating point array
.b330	ca		dex		   DEX               ; decrement element size, $04
.b331					FiAE_70
.b331	a5 46		lda $46		   LDA VARNAM+1      ; get variable name 2nd byte
.b333	10 02		bpl $b337	   BPL FiAE_80       ; branch if not integer or string
.b335	ca		dex		   DEX               ; decrement element size, $03
.b336	ca		dex		   DEX               ; decrement element size, $02
.b337					FiAE_80
.b337	86 28		stx $28		   STX FAC3+3       ; save dimension size low byte
.b339	a9 00		lda #$00	   LDA #$00          ; clear dimension size high byte
.b33b	20 55 b3	jsr $b355	   JSR Compute_Array_Size_A
.b33e	8a		txa		   TXA               ; copy array size low byte
.b33f	65 58		adc $58		   ADC TMPPTA        ; add array data start pointer low byte
.b341	85 47		sta $47		   STA VARPNT        ; save as current variable pointer low byte
.b343	98		tya		   TYA               ; copy array size high byte
.b344	65 59		adc $59		   ADC TMPPTA+1      ; add array data start pointer high byte
.b346	85 48		sta $48		   STA VARPNT+1      ; save as current variable pointer high byte
.b348	a8		tay		   TAY               ; copy high byte to Y
.b349	a5 47		lda $47		   LDA VARPNT        ; get current variable pointer low byte
.b34b					FiAE_Ret
.b34b	60		rts		   RTS
.b34c					  Compute_Array_Size
.b34c	84 22		sty $22		   STY INDEXA        ; save index
.b34e	b1 5f		lda ($5f),y	   LDA (TMPPTC),Y    ; get dimension size low byte
.b350	85 28		sta $28		   STA FAC3+3       ; save dimension size low byte
.b352	88		dey		   DEY               ; decrement index
.b353	b1 5f		lda ($5f),y	   LDA (TMPPTC),Y    ; get dimension size high byte
.b355					  Compute_Array_Size_A
.b355	85 29		sta $29		   STA FAC3+4       ; save dimension size high byte
.b357	a9 10		lda #$10	   LDA #$10          ; count = $10 (16 bit multiply)
.b359	85 5d		sta $5d		   STA TMPVA1        ; save bit count
.b35b	a2 00		ldx #$00	   LDX #$00          ; clear result low byte
.b35d	a0 00		ldy #$00	   LDY #$00          ; clear result high byte
.b35f					CAS_10
.b35f	8a		txa		   TXA               ; get result low byte
.b360	0a		asl a		   ASL A             ; *2
.b361	aa		tax		   TAX               ; save result low byte
.b362	98		tya		   TYA               ; get result high byte
.b363	2a		rol a		   ROL A             ; *2
.b364	a8		tay		   TAY               ; save result high byte
.b365	b0 a4		bcs $b30b	   BCS FiAE_30       ; if overflow go do "Out of memory" error
.b367	06 71		asl $71		   ASL TMPPTD        ; shift element size low byte
.b369	26 72		rol $72		   ROL TMPPTD+1      ; shift element size high byte
.b36b	90 0b		bcc $b378	   BCC CAS_20        ; skip add if no carry
.b36d	18		clc		   CLC               ; else clear carry for add
.b36e	8a		txa		   TXA               ; get result low byte
.b36f	65 28		adc $28		   ADC FAC3+3       ; add dimension size low byte
.b371	aa		tax		   TAX               ; save result low byte
.b372	98		tya		   TYA               ; get result high byte
.b373	65 29		adc $29		   ADC FAC3+4       ; add dimension size high byte
.b375	a8		tay		   TAY               ; save result high byte
.b376	b0 93		bcs $b30b	   BCS FiAE_30       ; if overflow go do "Out of memory" error
.b378					CAS_20
.b378	c6 5d		dec $5d		   DEC TMPVA1        ; decrement bit count
.b37a	d0 e3		bne $b35f	   BNE CAS_10        ; loop until all done
.b37c	60		rts		   RTS
.b37d					  Basic_FRE
.b37d	a5 0d		lda $0d		   LDA VALTYP        ; get data type flag, $FF = string, $00 = numeric
.b37f	f0 03		beq $b384	   BEQ FRE_10        ; if numeric don't pop the string
.b381	20 a6 b6	jsr $b6a6	   JSR Get_String_Descriptor
.b384					FRE_10
.b384	20 26 b5	jsr $b526	   JSR Garbage_Collection
.b387	38		sec		   SEC
.b388	a5 33		lda $33		   LDA FRESPC        ; get bottom of string space low byte
.b38a	e5 31		sbc $31		   SBC STREND        ; subtract end of arrays low byte
.b38c	a8		tay		   TAY               ; copy result to Y
.b38d	a5 34		lda $34		   LDA FRESPC+1      ; get bottom of string space high byte
.b38f	e5 32		sbc $32		   SBC STREND+1      ; subtract end of arrays high byte
.b391					  Integer_To_Float
.b391	a2 00		ldx #$00	   LDX #$00          ; set type = numeric
.b393	86 0d		stx $0d		   STX VALTYP        ; clear data type flag, $FF = string, $00 = numeric
.b395	85 62		sta $62		   STA FAC1M1        ; save FAC1 mantissa 1
.b397	84 63		sty $63		   STY FAC1M2        ; save FAC1 mantissa 2
.b399	a2 90		ldx #$90	   LDX #$90          ; set exponent=2^16 (integer)
.b39b	4c 44 bc	jmp $bc44	   JMP Int_To_Float_Exp_X      ; set exp = X, clear FAC1 3 and 4, normalise and return
.b39e					  Basic_POS
.b39e	38		sec		   SEC               ; set Cb for read cursor position
.b39f	20 f0 ff	jsr $fff0	   JSR PLOT          ; Read or set cursor location
.b3a2					  Y_To_Float
.b3a2	a9 00		lda #$00	   LDA #0            ; clear high byte
.b3a4	f0 eb		beq $b391	   BEQ Integer_To_Float
.b3a6					  Assert_Non_Direct
.b3a6	a6 3a		ldx $3a		   LDX CURLIN+1      ; get current line number high byte
.b3a8	e8		inx		   INX               ; increment it
.b3a9	d0 a0		bne $b34b	   BNE FiAE_Ret      ; return if not direct mode
.b3ab	a2 15		ldx #$15	   LDX #$15          ; error $15, illegal direct error
>b3ad	2c				   .byte   $2C       ; skip next statement
.b3ae					  Undefined_Function
.b3ae	a2 1b		ldx #$1b	   LDX #$1B          ; error $1B, undefined function error
.b3b0	4c 37 a4	jmp $a437	   JMP Basic_Error
.b3b3					  Basic_DEF
.b3b3	20 e1 b3	jsr $b3e1	   JSR Get_FN
.b3b6	20 a6 b3	jsr $b3a6	   JSR Assert_Non_Direct
.b3b9	20 fa ae	jsr $aefa	   JSR Need_Left_Parenthesis
.b3bc	a9 80		lda #$80	   LDA #$80          ; set flag for FNx
.b3be	85 10		sta $10		   STA SUBFLG        ; save subscript/FNx flag
.b3c0	20 8b b0	jsr $b08b	   JSR Get_Scalar_Address
.b3c3	20 8d ad	jsr $ad8d	   JSR Is_Numeric
.b3c6	20 f7 ae	jsr $aef7	   JSR Need_Right_Parenthesis
.b3c9	a9 b2		lda #$b2	   LDA #TK_EQUAL     ; get = token
.b3cb	20 ff ae	jsr $aeff	   JSR Need_A
.b3ce	48		pha		   PHA               ; push next character
.b3cf	a5 48		lda $48		   LDA VARPNT+1
.b3d1	48		pha		   PHA
.b3d2	a5 47		lda $47		   LDA VARPNT
.b3d4	48		pha		   PHA
.b3d5	a5 7b		lda $7b		   LDA TXTPTR+1
.b3d7	48		pha		   PHA
.b3d8	a5 7a		lda $7a		   LDA TXTPTR
.b3da	48		pha		   PHA
.b3db	20 f8 a8	jsr $a8f8	   JSR Basic_DATA    ; perform DATA
.b3de	4c 4f b4	jmp $b44f	   JMP EvFN_30      ; put execute pointer and variable pointer into function
.b3e1					  Get_FN
.b3e1	a9 a5		lda #$a5	   LDA #TK_FN        ; set FN token
.b3e3	20 ff ae	jsr $aeff	   JSR Need_A
.b3e6	09 80		ora #$80	   ORA #$80          ; set FN flag bit
.b3e8	85 10		sta $10		   STA SUBFLG        ; save FN name
.b3ea	20 92 b0	jsr $b092	   JSR Get_FN_Address
.b3ed	85 4e		sta $4e		   STA FUNCPT
.b3ef	84 4f		sty $4f		   STY FUNCPT+1
.b3f1	4c 8d ad	jmp $ad8d	   JMP Is_Numeric
.b3f4					  Eval_FNX
.b3f4	20 e1 b3	jsr $b3e1	   JSR Get_FN
.b3f7	a5 4f		lda $4f		   LDA FUNCPT+1
.b3f9	48		pha		   PHA
.b3fa	a5 4e		lda $4e		   LDA FUNCPT
.b3fc	48		pha		   PHA
.b3fd	20 f1 ae	jsr $aef1	   JSR Eval_In_Parenthesis
.b400	20 8d ad	jsr $ad8d	   JSR Is_Numeric
.b403	68		pla		   PLA
.b404	85 4e		sta $4e		   STA FUNCPT
.b406	68		pla		   PLA
.b407	85 4f		sta $4f		   STA FUNCPT+1
.b409	a0 02		ldy #$02	   LDY #$02          ; index to variable pointer high byte
.b40b	b1 4e		lda ($4e),y	   LDA (FUNCPT),Y    ; get variable address low byte
.b40d	85 47		sta $47		   STA VARPNT        ; save current variable pointer low byte
.b40f	aa		tax		   TAX               ; copy address low byte
.b410	c8		iny		   INY               ; index to variable address high byte
.b411	b1 4e		lda ($4e),y	   LDA (FUNCPT),Y    ; get variable pointer high byte
.b413	f0 99		beq $b3ae	   BEQ Undefined_Function      ; if high byte zero go do undefined function error
.b415	85 48		sta $48		   STA VARPNT+1      ; save current variable pointer high byte
.b417	c8		iny		   INY               ; index to mantissa 3
.b418					EvFN_10
.b418	b1 47		lda ($47),y	   LDA (VARPNT),Y    ; get byte from variable
.b41a	48		pha		   PHA               ; stack it
.b41b	88		dey		   DEY               ; decrement index
.b41c	10 fa		bpl $b418	   BPL EvFN_10      ; loop until variable stacked
.b41e	a4 48		ldy $48		   LDY VARPNT+1      ; get current variable pointer high byte
.b420	20 d4 bb	jsr $bbd4	   JSR Assign_FAC1_To_Var
.b423	a5 7b		lda $7b		   LDA TXTPTR+1
.b425	48		pha		   PHA
.b426	a5 7a		lda $7a		   LDA TXTPTR
.b428	48		pha		   PHA
.b429	b1 4e		lda ($4e),y	   LDA (FUNCPT),Y    ; get function execute pointer low byte
.b42b	85 7a		sta $7a		   STA TXTPTR        ; save BASIC execute pointer low byte
.b42d	c8		iny		   INY               ; index to high byte
.b42e	b1 4e		lda ($4e),y	   LDA (FUNCPT),Y    ; get function execute pointer high byte
.b430	85 7b		sta $7b		   STA TXTPTR+1      ; save BASIC execute pointer high byte
.b432	a5 48		lda $48		   LDA VARPNT+1
.b434	48		pha		   PHA
.b435	a5 47		lda $47		   LDA VARPNT
.b437	48		pha		   PHA
.b438	20 8a ad	jsr $ad8a	   JSR Eval_Numeric
.b43b	68		pla		   PLA
.b43c	85 4e		sta $4e		   STA FUNCPT
.b43e	68		pla		   PLA
.b43f	85 4f		sta $4f		   STA FUNCPT+1
.b441	20 79 00	jsr $0079	   JSR CHRGOT
.b444	f0 03		beq $b449	   BEQ EvFN_20      ; if null (should be [EOL] marker) continue
.b446	4c 08 af	jmp $af08	   JMP Syntax_Error
.b449					EvFN_20
.b449	68		pla		   PLA
.b44a	85 7a		sta $7a		   STA TXTPTR
.b44c	68		pla		   PLA
.b44d	85 7b		sta $7b		   STA TXTPTR+1
.b44f					EvFN_30
.b44f	a0 00		ldy #$00	   LDY #0
.b451	68		pla		   PLA               ; pull BASIC execute pointer low byte
.b452	91 4e		sta ($4e),y	   STA (FUNCPT),Y    ; save to function
.b454	68		pla		   PLA               ; pull BASIC execute pointer high byte
.b455	c8		iny		   INY
.b456	91 4e		sta ($4e),y	   STA (FUNCPT),Y    ; save to function
.b458	68		pla		   PLA               ; pull current variable address low byte
.b459	c8		iny		   INY
.b45a	91 4e		sta ($4e),y	   STA (FUNCPT),Y    ; save to function
.b45c	68		pla		   PLA               ; pull current variable address high byte
.b45d	c8		iny		   INY
.b45e	91 4e		sta ($4e),y	   STA (FUNCPT),Y    ; save to function
.b460	68		pla		   PLA               ; pull ??
.b461	c8		iny		   INY
.b462	91 4e		sta ($4e),y	   STA (FUNCPT),Y    ; save to function
.b464	60		rts		   RTS
.b465					  Basic_STR
.b465	20 8d ad	jsr $ad8d	   JSR Is_Numeric
.b468	a0 00		ldy #$00	   LDY #0
.b46a	20 df bd	jsr $bddf	   JSR Format_FAC1_Y
.b46d	68		pla		   PLA               ; dump return address (skip type check)
.b46e	68		pla		   PLA               ; dump return address (skip type check)
.b46f					BaST_10
.b46f	a9 ff		lda #$ff	   LDA #<BASSTO ;#<addr
.b471	a0 00		ldy #$00	   LDY #>BASSTO ;#>addr
.b473	f0 12		beq $b487	   BEQ Create_String_Descriptor
.b475					  Allocate_String_FAC1
.b475	a6 64		ldx $64		   LDX FAC1M3
.b477	a4 65		ldy $65		   LDY FAC1M3+1
.b479	86 50		stx $50		   STX DESCPT
.b47b	84 51		sty $51		   STY DESCPT+1
.b47d					  Allocate_String_A
.b47d	20 f4 b4	jsr $b4f4	   JSR Allocate_String_Space
.b480	86 62		stx $62		   STX FAC1M1        ; save string pointer low byte
.b482	84 63		sty $63		   STY FAC1M2        ; save string pointer high byte
.b484	85 61		sta $61		   STA FAC1EX        ; save length
.b486	60		rts		   RTS
.b487					  Create_String_Descriptor
.b487	a2 22		ldx #$22	   LDX #QUOTE
.b489	86 07		stx $07		   STX CHARAC        ; set terminator 1
.b48b	86 08		stx $08		   STX ENDCHR        ; set terminator 2
.b48d					  Create_String_Descriptor_AY
.b48d	85 6f		sta $6f		   STA STRPTR
.b48f	84 70		sty $70		   STY STRPTR+1
.b491	85 62		sta $62		   STA FAC1M1
.b493	84 63		sty $63		   STY FAC1M1+1
.b495	a0 ff		ldy #$ff	   LDY #$FF          ; set length to -1
.b497					CSD_10
.b497	c8		iny		   INY               ; increment length
.b498	b1 6f		lda ($6f),y	   LDA (STRPTR),Y    ; get byte from string
.b49a	f0 0c		beq $b4a8	   BEQ CSD_30        ; exit loop if null byte [EOS]
.b49c	c5 07		cmp $07		   CMP CHARAC        ; compare with search character, terminator 1
.b49e	f0 04		beq $b4a4	   BEQ CSD_20        ; branch if terminator
.b4a0	c5 08		cmp $08		   CMP ENDCHR        ; compare with terminator 2
.b4a2	d0 f3		bne $b497	   BNE CSD_10        ; loop if not terminator 2
.b4a4					CSD_20
.b4a4	c9 22		cmp #$22	   CMP #QUOTE
.b4a6	f0 01		beq $b4a9	   BEQ CSD_40        ; branch if " (carry set if = !)
.b4a8					CSD_30
.b4a8	18		clc		   CLC
.b4a9					CSD_40
.b4a9	84 61		sty $61		   STY FAC1EX        ; save length in FAC1 exponent
.b4ab	98		tya		   TYA               ; copy length to A
.b4ac	65 6f		adc $6f		   ADC STRPTR        ; add string start low byte
.b4ae	85 71		sta $71		   STA TMPPTD        ; save string end low byte
.b4b0	a6 70		ldx $70		   LDX STRPTR+1      ; get string start high byte
.b4b2	90 01		bcc $b4b5	   BCC CSD_50        ; if no low byte overflow skip the high byte increment
.b4b4	e8		inx		   INX               ; else increment high byte
.b4b5					CSD_50
.b4b5	86 72		stx $72		   STX TMPPTD+1      ; save string end high byte
.b4b7	a5 70		lda $70		   LDA STRPTR+1      ; get string start high byte
.b4b9	f0 04		beq $b4bf	   BEQ CSD_60        ; branch if in utility area
.b4bb	c9 02		cmp #$02	   CMP #$02          ; compare with input buffer memory high byte
.b4bd	d0 0b		bne $b4ca	   BNE Push_String_Descriptor
.b4bf					CSD_60
.b4bf	98		tya		   TYA               ; copy length to A
.b4c0	20 75 b4	jsr $b475	   JSR Allocate_String_FAC1
.b4c3	a6 6f		ldx $6f		   LDX STRPTR
.b4c5	a4 70		ldy $70		   LDY STRPTR+1
.b4c7					Store_And_Push_String
.b4c7	20 88 b6	jsr $b688	   JSR Store_String_XY
.b4ca					   Push_String_Descriptor
.b4ca	a6 16		ldx $16		   LDX TEMPPT        ; get descriptor stack pointer
.b4cc	e0 22		cpx #$22	   CPX #QUOTE
.b4ce	d0 05		bne $b4d5	   BNE PSD_20        ; branch if space on string stack
.b4d0	a2 19		ldx #$19	   LDX #$19          ; error $19, string too complex error
.b4d2					PSD_10
.b4d2	4c 37 a4	jmp $a437	   JMP Basic_Error
.b4d5					PSD_20
.b4d5	a5 61		lda $61		   LDA FAC1EX        ; get string length
.b4d7	95 00		sta $00,x	   STA 0,X           ; put on string stack
.b4d9	a5 62		lda $62		   LDA FAC1M1        ; get string pointer low byte
.b4db	95 01		sta $01,x	   STA 1,X           ; put on string stack
.b4dd	a5 63		lda $63		   LDA FAC1M2        ; get string pointer high byte
.b4df	95 02		sta $02,x	   STA 2,X           ; put on string stack
.b4e1	a0 00		ldy #$00	   LDY #0            ; clear Y
.b4e3	86 64		stx $64		   STX FAC1M3
.b4e5	84 65		sty $65		   STY FAC1M3+1
.b4e7	84 70		sty $70		   STY FAC1M5        ; clear FAC1 rounding byte
.b4e9	88		dey		   DEY               ; Y = $FF
.b4ea	84 0d		sty $0d		   STY VALTYP        ; save data type flag, $FF = string
.b4ec	86 17		stx $17		   STX LASTPT        ; save current descriptor stack item pointer low byte
.b4ee	e8		inx		   INX               ; update stack pointer
.b4ef	e8		inx		   INX               ; update stack pointer
.b4f0	e8		inx		   INX               ; update stack pointer
.b4f1	86 16		stx $16		   STX TEMPPT        ; set new descriptor stack pointer
.b4f3	60		rts		   RTS
.b4f4					  Allocate_String_Space
.b4f4	46 0f		lsr $0f		   LSR GARBFL        ; clear garbage collected flag (b7)
.b4f6					ASS_10
.b4f6	48		pha		   PHA               ; save string length
.b4f7	49 ff		eor #$ff	   EOR #$FF          ; complement it
.b4f9	38		sec		   SEC               ; set carry for subtract, two's complement add
.b4fa	65 33		adc $33		   ADC FRESPC        ; add bottom of string space low byte, subtract length
.b4fc	a4 34		ldy $34		   LDY FRESPC+1      ; get bottom of string space high byte
.b4fe	b0 01		bcs $b501	   BCS ASS_20        ; skip decrement if no underflow
.b500	88		dey		   DEY               ; decrement bottom of string space high byte
.b501					ASS_20
.b501	c4 32		cpy $32		   CPY STREND+1      ; compare with end of arrays high byte
.b503	90 11		bcc $b516	   BCC ASS_40        ; do out of memory error if less
.b505	d0 04		bne $b50b	   BNE ASS_30        ; if not = skip next test
.b507	c5 31		cmp $31		   CMP STREND        ; compare with end of arrays low byte
.b509	90 0b		bcc $b516	   BCC ASS_40        ; do out of memory error if less
.b50b					ASS_30
.b50b	85 33		sta $33		   STA FRESPC
.b50d	84 34		sty $34		   STY FRESPC+1
.b50f	85 35		sta $35		   STA UTLSTP
.b511	84 36		sty $36		   STY UTLSTP+1
.b513	aa		tax		   TAX               ; copy low byte to X
.b514	68		pla		   PLA               ; get string length back
.b515	60		rts		   RTS
.b516					ASS_40
.b516	a2 10		ldx #$10	   LDX #$10          ; error code $10, out of memory error
.b518	a5 0f		lda $0f		   LDA GARBFL        ; get garbage collected flag
.b51a	30 b6		bmi $b4d2	   BMI PSD_10        ; if set then do error code X
.b51c	20 26 b5	jsr $b526	   JSR Garbage_Collection
.b51f	a9 80		lda #$80	   LDA #$80          ; flag for garbage collected
.b521	85 0f		sta $0f		   STA GARBFL        ; set garbage collected flag
.b523	68		pla		   PLA               ; pull length
.b524	d0 d0		bne $b4f6	   BNE ASS_10        ; go try again (loop always, length should never be = $00)
.b526					  Garbage_Collection
.b526	a6 37		ldx $37		   LDX MEMSIZ        ; get end of memory low byte
.b528	a5 38		lda $38		   LDA MEMSIZ+1      ; get end of memory high byte
.b52a					GaCo_Iter
.b52a	86 33		stx $33		   STX FRESPC        ; set bottom of string space low byte
.b52c	85 34		sta $34		   STA FRESPC+1      ; set bottom of string space high byte
.b52e	a0 00		ldy #$00	   LDY #0
.b530	84 4f		sty $4f		   STY FUNCPT+1      ; clear working pointer high byte
.b532	84 4e		sty $4e		   STY FUNCPT        ; clear working pointer low byte
.b534	a5 31		lda $31		   LDA STREND
.b536	a6 32		ldx $32		   LDX STREND+1
.b538	85 5f		sta $5f		   STA TMPPTC
.b53a	86 60		stx $60		   STX TMPPTC+1
.b53c	a9 19		lda #$19	   LDA #TEMPST       ; set descriptor stack pointer
.b53e	a2 00		ldx #$00	   LDX #0            ; check first descriptors on string stack
.b540	85 22		sta $22		   STA INDEXA
.b542	86 23		stx $23		   STX INDEXA+1
.b544					GaCo_Loop_1
.b544	c5 16		cmp $16		   CMP TEMPPT        ; compare with descriptor stack pointer
.b546	f0 05		beq $b54d	   BEQ GaCo_10       ; branch if descripor on stack
.b548	20 c7 b5	jsr $b5c7	   JSR Check_String  ;
.b54b	f0 f7		beq $b544	   BEQ GaCo_Loop_1   ; loop always (Check_String returns with LDY #0)
.b54d					GaCo_10
.b54d	a9 07		lda #$07	   LDA #7            ; set step size = 7, collecting variables
.b54f	85 53		sta $53		   STA GARBSS        ; save garbage collection step size
.b551	a5 2d		lda $2d		   LDA VARTAB
.b553	a6 2e		ldx $2e		   LDX VARTAB+1
.b555	85 22		sta $22		   STA INDEXA
.b557	86 23		stx $23		   STX INDEXA+1
.b559					GaCo_20
.b559	e4 30		cpx $30		   CPX ARYTAB+1      ; compare end of variables high byte,
.b55b	d0 04		bne $b561	   BNE GaCo_30       ; branch if no high byte match
.b55d	c5 2f		cmp $2f		   CMP ARYTAB        ; else compare end of variables low byte,
.b55f	f0 05		beq $b566	   BEQ GaCo_40       ; branch if = variable memory end
.b561					GaCo_30
.b561	20 bd b5	jsr $b5bd	   JSR Check_Variable
.b564	f0 f3		beq $b559	   BEQ GaCo_20       ; loop always
.b566					GaCo_40
.b566	85 58		sta $58		   STA TMPPTA
.b568	86 59		stx $59		   STX TMPPTA+1
.b56a	a9 03		lda #$03	   LDA #3            ; set step size, collecting descriptors
.b56c	85 53		sta $53		   STA GARBSS        ; save step size
.b56e					GaCo_50
.b56e	a5 58		lda $58		   LDA TMPPTA
.b570	a6 59		ldx $59		   LDX TMPPTA+1
.b572					GaCo_60
.b572	e4 32		cpx $32		   CPX STREND+1      ; compare with end of arrays high byte
.b574	d0 07		bne $b57d	   BNE GaCo_70       ; branch if not at end
.b576	c5 31		cmp $31		   CMP STREND        ; else compare with end of arrays low byte
.b578	d0 03		bne $b57d	   BNE GaCo_70       ; branch if not at end
.b57a	4c 06 b6	jmp $b606	   JMP Collect_String
.b57d					GaCo_70
.b57d	85 22		sta $22		   STA INDEXA
.b57f	86 23		stx $23		   STX INDEXA+1
.b581	a0 00		ldy #$00	   LDY #0
.b583	b1 22		lda ($22),y	   LDA (INDEXA),Y    ; get array name first byte
.b585	aa		tax		   TAX               ; copy it
.b586	c8		iny		   INY
.b587	b1 22		lda ($22),y	   LDA (INDEXA),Y    ; get array name second byte
.b589	08		php		   PHP               ; push the flags
.b58a	c8		iny		   INY
.b58b	b1 22		lda ($22),y	   LDA (INDEXA),Y    ; get array size low byte
.b58d	65 58		adc $58		   ADC TMPPTA        ; add start of this array low byte
.b58f	85 58		sta $58		   STA TMPPTA        ; save start of next array low byte
.b591	c8		iny		   INY
.b592	b1 22		lda ($22),y	   LDA (INDEXA),Y    ; get array size high byte
.b594	65 59		adc $59		   ADC TMPPTA+1      ; add start of this array high byte
.b596	85 59		sta $59		   STA TMPPTA+1      ; save start of next array high byte
.b598	28		plp		   PLP               ; restore the flags
.b599	10 d3		bpl $b56e	   BPL GaCo_50       ; skip if not string array
.b59b	8a		txa		   TXA               ; get name first byte back
.b59c	30 d0		bmi $b56e	   BMI GaCo_50       ; skip if not string array
.b59e	c8		iny		   INY
.b59f	b1 22		lda ($22),y	   LDA (INDEXA),Y    ; get # of dimensions
.b5a1	a0 00		ldy #$00	   LDY #0
.b5a3	0a		asl a		   ASL A             ; *2
.b5a4	69 05		adc #$05	   ADC #5            ; +5 (array header size)
.b5a6	65 22		adc $22		   ADC INDEXA        ; add pointer low byte
.b5a8	85 22		sta $22		   STA INDEXA        ; save pointer low byte
.b5aa	90 02		bcc $b5ae	   BCC GaCo_80       ; if no rollover skip the high byte increment
.b5ac	e6 23		inc $23		   INC INDEXA+1      ; else increment pointer hgih byte
.b5ae					GaCo_80
.b5ae	a6 23		ldx $23		   LDX INDEXA+1      ; get pointer high byte
.b5b0					GaCo_90
.b5b0	e4 59		cpx $59		   CPX TMPPTA+1      ; compare pointer high byte with end of this array high byte
.b5b2	d0 04		bne $b5b8	   BNE GaCo_95       ; branch if not there yet
.b5b4	c5 58		cmp $58		   CMP TMPPTA        ; compare pointer low byte with end of this array low byte
.b5b6	f0 ba		beq $b572	   BEQ GaCo_60       ; if at end of this array go check next array
.b5b8					GaCo_95
.b5b8	20 c7 b5	jsr $b5c7	   JSR Check_String
.b5bb	f0 f3		beq $b5b0	   BEQ GaCo_90      ; loop
.b5bd					  Check_Variable
.b5bd	b1 22		lda ($22),y	   LDA (INDEXA),Y    ; get variable name first byte
.b5bf	30 35		bmi $b5f6	   BMI ChSt_30       ; add step and exit if not string
.b5c1	c8		iny		   INY
.b5c2	b1 22		lda ($22),y	   LDA (INDEXA),Y    ; get variable name second byte
.b5c4	10 30		bpl $b5f6	   BPL ChSt_30       ; add step and exit if not string
.b5c6	c8		iny		   INY
.b5c7					  Check_String
.b5c7	b1 22		lda ($22),y	   LDA (INDEXA),Y    ; get string length
.b5c9	f0 2b		beq $b5f6	   BEQ ChSt_30       ; add step and exit if null string
.b5cb	c8		iny		   INY
.b5cc	b1 22		lda ($22),y	   LDA (INDEXA),Y    ; get string pointer low byte
.b5ce	aa		tax		   TAX               ; copy to X
.b5cf	c8		iny		   INY
.b5d0	b1 22		lda ($22),y	   LDA (INDEXA),Y    ; get string pointer high byte
.b5d2	c5 34		cmp $34		   CMP FRESPC+1      ; compare string pointer high byte with bottom of string
.b5d4	90 06		bcc $b5dc	   BCC ChSt_10       ; if less go test against highest
.b5d6	d0 1e		bne $b5f6	   BNE ChSt_30       ; bottom of string space less string has been collected
.b5d8	e4 33		cpx $33		   CPX FRESPC        ; compare string pointer low byte with bottom of string
.b5da	b0 1a		bcs $b5f6	   BCS ChSt_30       ; if bottom of string space less string has been collected
.b5dc					ChSt_10
.b5dc	c5 60		cmp $60		   CMP TMPPTC+1      ; compare string pointer high byte with highest uncollected
.b5de	90 16		bcc $b5f6	   BCC ChSt_30       ; if highest uncollected string is greater then go update
.b5e0	d0 04		bne $b5e6	   BNE ChSt_20       ; if highest uncollected string is less then go set this
.b5e2	e4 5f		cpx $5f		   CPX TMPPTC        ; compare string pointer low byte with highest uncollected
.b5e4	90 10		bcc $b5f6	   BCC ChSt_30       ; if highest uncollected string is greater then go update
.b5e6					ChSt_20
.b5e6	86 5f		stx $5f		   STX TMPPTC        ; save string pointer low byte as highest uncollected string
.b5e8	85 60		sta $60		   STA TMPPTC+1      ; save string pointer high byte as highest uncollected
.b5ea	a5 22		lda $22		   LDA INDEXA
.b5ec	a6 23		ldx $23		   LDX INDEXA+1
.b5ee	85 4e		sta $4e		   STA FUNCPT
.b5f0	86 4f		stx $4f		   STX FUNCPT+1
.b5f2	a5 53		lda $53		   LDA GARBSS        ; get step size
.b5f4	85 55		sta $55		   STA FUNJMP        ; copy step size
.b5f6					ChSt_30
.b5f6	a5 53		lda $53		   LDA GARBSS        ; get step size (7 or 3)
.b5f8	18		clc		   CLC
.b5f9	65 22		adc $22		   ADC INDEXA        ; add pointer low byte
.b5fb	85 22		sta $22		   STA INDEXA        ; save pointer low byte
.b5fd	90 02		bcc $b601	   BCC ChSt_40       ; if no rollover skip the high byte increment
.b5ff	e6 23		inc $23		   INC INDEXA+1      ; else increment pointer high byte
.b601					ChSt_40
.b601	a6 23		ldx $23		   LDX INDEXA+1      ; get pointer high byte
.b603	a0 00		ldy #$00	   LDY #0
.b605	60		rts		   RTS
.b606					  Collect_String
.b606	a5 4f		lda $4f		   LDA FUNCPT+1      ; get working pointer low byte
.b608	05 4e		ora $4e		   ORA FUNCPT        ; OR working pointer high byte
.b60a	f0 f5		beq $b601	   BEQ ChSt_40       ; exit if nothing to collect
.b60c	a5 55		lda $55		   LDA FUNJMP        ; get copied step size
.b60e	29 04		and #$04	   AND #4            ; mask step size, 4 for variables, 0 for array or stack
.b610	4a		lsr a		   LSR A             ; 2 for variables, 0 for descriptors
.b611	a8		tay		   TAY               ; copy to index
.b612	85 55		sta $55		   STA FUNJMP        ; save offset to descriptor start
.b614	b1 4e		lda ($4e),y	   LDA (FUNCPT),Y    ; get string length
.b616	65 5f		adc $5f		   ADC TMPPTC        ; add string start low byte
.b618	85 5a		sta $5a		   STA TMPPTB        ; set block end low byte
.b61a	a5 60		lda $60		   LDA TMPPTC+1      ; get string start high byte
.b61c	69 00		adc #$00	   ADC #0            ; add carry
.b61e	85 5b		sta $5b		   STA TMPPTB+1      ; set block end high byte
.b620	a5 33		lda $33		   LDA FRESPC
.b622	a6 34		ldx $34		   LDX FRESPC+1
.b624	85 58		sta $58		   STA TMPPTA
.b626	86 59		stx $59		   STX TMPPTA+1
.b628	20 bf a3	jsr $a3bf	   JSR Move_Block
.b62b	a4 55		ldy $55		   LDY FUNJMP        ; restore offset to descriptor start
.b62d	c8		iny		   INY
.b62e	a5 58		lda $58		   LDA TMPPTA        ; get new string pointer low byte
.b630	91 4e		sta ($4e),y	   STA (FUNCPT),Y    ; save new string pointer low byte
.b632	aa		tax		   TAX               ; copy string pointer low byte
.b633	e6 59		inc $59		   INC TMPPTA+1      ; increment new string pointer high byte
.b635	a5 59		lda $59		   LDA TMPPTA+1      ; get new string pointer high byte
.b637	c8		iny		   INY
.b638	91 4e		sta ($4e),y	   STA (FUNCPT),Y    ; save new string pointer high byte
.b63a	4c 2a b5	jmp $b52a	   JMP GaCo_Iter     ; XA holds new bottom of string memory pointer
.b63d					  Concatenate
.b63d	a5 65		lda $65		   LDA FAC1M3+1
.b63f	48		pha		   PHA
.b640	a5 64		lda $64		   LDA FAC1M3
.b642	48		pha		   PHA
.b643	20 83 ae	jsr $ae83	   JSR Evaluate
.b646	20 8f ad	jsr $ad8f	   JSR Assert_String_Type
.b649	68		pla		   PLA
.b64a	85 6f		sta $6f		   STA STRPTR
.b64c	68		pla		   PLA
.b64d	85 70		sta $70		   STA STRPTR+1
.b64f	a0 00		ldy #$00	   LDY #0
.b651	b1 6f		lda ($6f),y	   LDA (STRPTR),Y    ; get length of first string from descriptor
.b653	18		clc		   CLC
.b654	71 64		adc ($64),y	   ADC (FAC1M3),Y    ; add length of second string
.b656	90 05		bcc $b65d	   BCC Conc_10       ; if no overflow continue
.b658	a2 17		ldx #$17	   LDX #$17          ; else error $17, string too long error
.b65a	4c 37 a4	jmp $a437	   JMP Basic_Error
.b65d					Conc_10
.b65d	20 75 b4	jsr $b475	   JSR Allocate_String_FAC1
.b660	20 7a b6	jsr $b67a	   JSR Store_String_STRPTR
.b663	a5 50		lda $50		   LDA DESCPT
.b665	a4 51		ldy $51		   LDY DESCPT+1
.b667	20 aa b6	jsr $b6aa	   JSR Get_String_Descriptor_AY
.b66a	20 8c b6	jsr $b68c	   JSR Store_String_INDEXA
.b66d	a5 6f		lda $6f		   LDA STRPTR
.b66f	a4 70		ldy $70		   LDY STRPTR+1
.b671	20 aa b6	jsr $b6aa	   JSR Get_String_Descriptor_AY
.b674	20 ca b4	jsr $b4ca	   JSR Push_String_Descriptor
.b677	4c b8 ad	jmp $adb8	   JMP EvEx_15      ; continue evaluation
.b67a					  Store_String_STRPTR
.b67a	a0 00		ldy #$00	   LDY #0
.b67c	b1 6f		lda ($6f),y	   LDA (STRPTR),Y    ; get string length
.b67e	48		pha		   PHA               ; save it
.b67f	c8		iny		   INY
.b680	b1 6f		lda ($6f),y	   LDA (STRPTR),Y    ; get string pointer low byte
.b682	aa		tax		   TAX               ; copy to X
.b683	c8		iny		   INY
.b684	b1 6f		lda ($6f),y	   LDA (STRPTR),Y    ; get string pointer high byte
.b686	a8		tay		   TAY               ; copy to Y
.b687	68		pla		   PLA               ; get length back
.b688					  Store_String_XY
.b688	86 22		stx $22		   STX INDEXA
.b68a	84 23		sty $23		   STY INDEXA+1
.b68c					  Store_String_INDEXA
.b68c	a8		tay		   TAY               ; copy length as index
.b68d	f0 0a		beq $b699	   BEQ SSIN_20       ; branch if null string
.b68f	48		pha		   PHA               ; save length
.b690					SSIN_10
.b690	88		dey		   DEY               ; decrement length/index
.b691	b1 22		lda ($22),y	   LDA (INDEXA),Y    ; get byte from string
.b693	91 35		sta ($35),y	   STA (UTLSTP),Y    ; save byte to destination
.b695	98		tya		   TYA               ; y = 0 ?
.b696	d0 f8		bne $b690	   BNE SSIN_10       ; loop if not all done yet
.b698	68		pla		   PLA               ; restore length
.b699					SSIN_20
.b699	18		clc		   CLC
.b69a	65 35		adc $35		   ADC UTLSTP        ; add string utility ptr low byte
.b69c	85 35		sta $35		   STA UTLSTP        ; save string utility ptr low byte
.b69e	90 02		bcc $b6a2	   BCC SSIN_30       ; if no rollover skip the high byte increment
.b6a0	e6 36		inc $36		   INC UTLSTP+1      ; increment string utility ptr high byte
.b6a2					SSIN_30
.b6a2	60		rts		   RTS
.b6a3					  Eval_String
.b6a3	20 8f ad	jsr $ad8f	   JSR Assert_String_Type
.b6a6					  Get_String_Descriptor
.b6a6	a5 64		lda $64		   LDA FAC1M3
.b6a8	a4 65		ldy $65		   LDY FAC1M3+1
.b6aa					  Get_String_Descriptor_AY
.b6aa	85 22		sta $22		   STA INDEXA
.b6ac	84 23		sty $23		   STY INDEXA+1
.b6ae	20 db b6	jsr $b6db	   JSR Pop_Descriptor_Stack
.b6b1	08		php		   PHP               ; save status flags
.b6b2	a0 00		ldy #$00	   LDY #0
.b6b4	b1 22		lda ($22),y	   LDA (INDEXA),Y    ; get length from string descriptor
.b6b6	48		pha		   PHA
.b6b7	c8		iny		   INY
.b6b8	b1 22		lda ($22),y	   LDA (INDEXA),Y    ; get string pointer low byte from descriptor
.b6ba	aa		tax		   TAX
.b6bb	c8		iny		   INY
.b6bc	b1 22		lda ($22),y	   LDA (INDEXA),Y    ; get string pointer high byte from descriptor
.b6be	a8		tay		   TAY
.b6bf	68		pla		   PLA               ; get string length back
.b6c0	28		plp		   PLP               ; restore status
.b6c1	d0 13		bne $b6d6	   BNE GSD_20        ; branch if pointer not popped
.b6c3	c4 34		cpy $34		   CPY FRESPC+1      ; compare with bottom of string space high byte
.b6c5	d0 0f		bne $b6d6	   BNE GSD_20        ; branch if <>
.b6c7	e4 33		cpx $33		   CPX FRESPC        ; else compare with bottom of string space low byte
.b6c9	d0 0b		bne $b6d6	   BNE GSD_20        ; branch if <>
.b6cb	48		pha		   PHA               ; push string length
.b6cc	18		clc		   CLC               ; string address is identical to FRESPC,
.b6cd	65 33		adc $33		   ADC FRESPC        ; so we can free that memory easyli.
.b6cf	85 33		sta $33		   STA FRESPC
.b6d1	90 02		bcc $b6d5	   BCC GSD_10
.b6d3	e6 34		inc $34		   INC FRESPC+1
.b6d5					GSD_10
.b6d5	68		pla		   PLA               ; pull string length
.b6d6					GSD_20
.b6d6	86 22		stx $22		   STX INDEXA
.b6d8	84 23		sty $23		   STY INDEXA+1
.b6da	60		rts		   RTS
.b6db					  Pop_Descriptor_Stack
.b6db	c4 18		cpy $18		   CPY LASTPT+1      ; compare high byte with current descriptor stack item
.b6dd	d0 0c		bne $b6eb	   BNE PDS_Ret
.b6df	c5 17		cmp $17		   CMP LASTPT        ; compare low byte with current descriptor stack item
.b6e1	d0 08		bne $b6eb	   BNE PDS_Ret
.b6e3	85 16		sta $16		   STA TEMPPT        ; set descriptor stack pointer
.b6e5	e9 03		sbc #$03	   SBC #3            ; update last string pointer low byte
.b6e7	85 17		sta $17		   STA LASTPT        ; save current descriptor stack item pointer low byte
.b6e9	a0 00		ldy #$00	   LDY #0            ; set Z flag : descriptor popped
.b6eb					PDS_Ret
.b6eb	60		rts		   RTS
.b6ec					  Basic_CHR
.b6ec	20 a1 b7	jsr $b7a1	   JSR Eval_Byte
.b6ef	8a		txa		   TXA               ; copy to A
.b6f0	48		pha		   PHA               ; save character
.b6f1	a9 01		lda #$01	   LDA #$01          ; string is single byte
.b6f3	20 7d b4	jsr $b47d	   JSR Allocate_String_A
.b6f6	68		pla		   PLA               ; get character back
.b6f7	a0 00		ldy #$00	   LDY #0
.b6f9	91 62		sta ($62),y	   STA (FAC1M1),Y    ; save byte in string - byte IS string!
.b6fb	68		pla		   PLA               ; dump return address (skip type check)
.b6fc	68		pla		   PLA               ; dump return address (skip type check)
.b6fd	4c ca b4	jmp $b4ca	   JMP Push_String_Descriptor
.b700					  Basic_LEFT
.b700	20 61 b7	jsr $b761	   JSR Pop_String_Descriptor_And_Byte
.b703	d1 50		cmp ($50),y	   CMP (DESCPT),Y    ; compare byte parameter with string length
.b705	98		tya		   TYA               ; clear A
.b706					LEFT_10
.b706	90 04		bcc $b70c	   BCC LEFT_20       ; branch if string length > byte parameter
.b708	b1 50		lda ($50),y	   LDA (DESCPT),Y    ; else make parameter = length
.b70a	aa		tax		   TAX               ; copy to byte parameter copy
.b70b	98		tya		   TYA               ; clear string start offset
.b70c					LEFT_20
.b70c	48		pha		   PHA               ; save string start offset
.b70d					LEFT_30
.b70d	8a		txa		   TXA               ; copy byte parameter (or string length if <)
.b70e					LEFT_40
.b70e	48		pha		   PHA               ; save string length
.b70f	20 7d b4	jsr $b47d	   JSR Allocate_String_A
.b712	a5 50		lda $50		   LDA DESCPT
.b714	a4 51		ldy $51		   LDY DESCPT+1
.b716	20 aa b6	jsr $b6aa	   JSR Get_String_Descriptor_AY
.b719	68		pla		   PLA               ; get string length back
.b71a	a8		tay		   TAY               ; copy length to Y
.b71b	68		pla		   PLA               ; get string start offset back
.b71c	18		clc		   CLC
.b71d	65 22		adc $22		   ADC INDEXA        ; add start offset to string start pointer low byte
.b71f	85 22		sta $22		   STA INDEXA        ; save string start pointer low byte
.b721	90 02		bcc $b725	   BCC LEFT_50       ; if no overflow skip the high byte increment
.b723	e6 23		inc $23		   INC INDEXA+1      ; else increment string start pointer high byte
.b725					LEFT_50
.b725	98		tya		   TYA               ; copy length to A
.b726	20 8c b6	jsr $b68c	   JSR Store_String_INDEXA
.b729	4c ca b4	jmp $b4ca	   JMP Push_String_Descriptor
.b72c					  Basic_RIGHT
.b72c	20 61 b7	jsr $b761	   JSR Pop_String_Descriptor_And_Byte
.b72f	18		clc		   CLC
.b730	f1 50		sbc ($50),y	   SBC (DESCPT),Y    ; subtract string length
.b732	49 ff		eor #$ff	   EOR #$FF          ; invert it (A=LEN(expression$)-l)
.b734	4c 06 b7	jmp $b706	   JMP LEFT_10      ; go do rest of LEFT$()
.b737					  Basic_MID
.b737	a9 ff		lda #$ff	   LDA #$FF          ; set default length = 255
.b739	85 65		sta $65		   STA FAC1M4        ; save default length
.b73b	20 79 00	jsr $0079	   JSR CHRGOT
.b73e	c9 29		cmp #$29	   CMP #')'
.b740	f0 06		beq $b748	   BEQ MID_10        ; no 2nd. byte
.b742	20 fd ae	jsr $aefd	   JSR Need_Comma
.b745	20 9e b7	jsr $b79e	   JSR Get_Byte_Value
.b748					MID_10
.b748	20 61 b7	jsr $b761	   JSR Pop_String_Descriptor_And_Byte
.b74b	f0 4b		beq $b798	   BEQ Jump_To_Illegal_Quantity
.b74d	ca		dex		   DEX               ; decrement start index
.b74e	8a		txa		   TXA               ; copy to A
.b74f	48		pha		   PHA               ; save string start offset
.b750	18		clc		   CLC
.b751	a2 00		ldx #$00	   LDX #0            ; clear output string length
.b753	f1 50		sbc ($50),y	   SBC (DESCPT),Y    ; start - string length
.b755	b0 b6		bcs $b70d	   BCS LEFT_30       ; if start > string length go do null string
.b757	49 ff		eor #$ff	   EOR #$FF          ; complement -length
.b759	c5 65		cmp $65		   CMP FAC1M4        ; compare with length
.b75b	90 b1		bcc $b70e	   BCC LEFT_40       ; if length > remaining string go do RIGHT$
.b75d	a5 65		lda $65		   LDA FAC1M4        ; get length byte
.b75f	b0 ad		bcs $b70e	   BCS LEFT_40       ; go do string copy, branch always
.b761					  Pop_String_Descriptor_And_Byte
.b761	20 f7 ae	jsr $aef7	   JSR Need_Right_Parenthesis
.b764	68		pla		   PLA
.b765	a8		tay		   TAY               ; save return address low byte
.b766	68		pla		   PLA
.b767	85 55		sta $55		   STA FUNJMP        ; save return address high byte
.b769	68		pla		   PLA               ; dump call to function vector low byte
.b76a	68		pla		   PLA               ; dump call to function vector high byte
.b76b	68		pla		   PLA               ; pull byte parameter
.b76c	aa		tax		   TAX               ; copy byte parameter to X
.b76d	68		pla		   PLA
.b76e	85 50		sta $50		   STA DESCPT
.b770	68		pla		   PLA
.b771	85 51		sta $51		   STA DESCPT+1
.b773	a5 55		lda $55		   LDA FUNJMP        ; get return address high byte
.b775	48		pha		   PHA               ; back on stack
.b776	98		tya		   TYA               ; get return address low byte
.b777	48		pha		   PHA               ; back on stack
.b778	a0 00		ldy #$00	   LDY #0
.b77a	8a		txa		   TXA               ; copy byte parameter
.b77b	60		rts		   RTS
.b77c					  Basic_LEN
.b77c	20 82 b7	jsr $b782	   JSR Eval_String_And_Len
.b77f	4c a2 b3	jmp $b3a2	   JMP Y_To_Float      ; convert Y to byte in FAC1 and return
.b782					  Eval_String_And_Len
.b782	20 a3 b6	jsr $b6a3	   JSR Eval_String
.b785	a2 00		ldx #$00	   LDX #$00          ; set data type = numeric
.b787	86 0d		stx $0d		   STX VALTYP        ; clear data type flag, $FF = string, $00 = numeric
.b789	a8		tay		   TAY               ; copy length to Y
.b78a	60		rts		   RTS
.b78b					  Basic_ASC
.b78b	20 82 b7	jsr $b782	   JSR Eval_String_And_Len
.b78e	f0 08		beq $b798	   BEQ Jump_To_Illegal_Quantity
.b790	a0 00		ldy #$00	   LDY #0
.b792	b1 22		lda ($22),y	   LDA (INDEXA),Y    ; get 1st. byte
.b794	a8		tay		   TAY               ; copy to Y
.b795	4c a2 b3	jmp $b3a2	   JMP Y_To_Float
.b798					  Jump_To_Illegal_Quantity
.b798	4c 48 b2	jmp $b248	   JMP Illegal_Quantity
.b79b					  Get_Next_Byte_Value
.b79b	20 73 00	jsr $0073	   JSR CHRGET
.b79e					  Get_Byte_Value
.b79e	20 8a ad	jsr $ad8a	   JSR Eval_Numeric
.b7a1					  Eval_Byte
.b7a1	20 b8 b1	jsr $b1b8	   JSR Eval_Positive_Integer_Check
.b7a4	a6 64		ldx $64		   LDX FAC1M3        ; high byte must be 0
.b7a6	d0 f0		bne $b798	   BNE Jump_To_Illegal_Quantity
.b7a8	a6 65		ldx $65		   LDX FAC1M4
.b7aa	4c 79 00	jmp $0079	   JMP CHRGOT
.b7ad					  Basic_VAL
.b7ad	20 82 b7	jsr $b782	   JSR Eval_String_And_Len
.b7b0	d0 03		bne $b7b5	   BNE VAL_10        ; if not a null string go evaluate it
.b7b2	4c f7 b8	jmp $b8f7	   JMP Clear_FAC1_Exp_And_Sign
.b7b5					VAL_10
.b7b5	a6 7a		ldx $7a		   LDX TXTPTR
.b7b7	a4 7b		ldy $7b		   LDY TXTPTR+1
.b7b9	86 71		stx $71		   STX TMPPTD
.b7bb	84 72		sty $72		   STY TMPPTD+1
.b7bd	a6 22		ldx $22		   LDX INDEXA        ; get string pointer low byte
.b7bf	86 7a		stx $7a		   STX TXTPTR        ; save BASIC execute pointer low byte
.b7c1	18		clc		   CLC
.b7c2	65 22		adc $22		   ADC INDEXA        ; add string length
.b7c4	85 24		sta $24		   STA INDEXB        ; save string end low byte
.b7c6	a6 23		ldx $23		   LDX INDEXA+1      ; get string pointer high byte
.b7c8	86 7b		stx $7b		   STX TXTPTR+1      ; save BASIC execute pointer high byte
.b7ca	90 01		bcc $b7cd	   BCC VAL_20        ; if no rollover skip the high byte increment
.b7cc	e8		inx		   INX               ; increment string end high byte
.b7cd					VAL_20
.b7cd	86 25		stx $25		   STX INDEXB+1      ; save string end high byte
.b7cf	a0 00		ldy #$00	   LDY #0
.b7d1	b1 24		lda ($24),y	   LDA (INDEXB),Y    ; get string end byte
.b7d3	48		pha		   PHA               ; push it
.b7d4	98		tya		   TYA               ; clear A
.b7d5	91 24		sta ($24),y	   STA (INDEXB),Y    ; terminate string with 0
.b7d7	20 79 00	jsr $0079	   JSR CHRGOT
.b7da	20 f3 bc	jsr $bcf3	   JSR Load_FAC1_From_String
.b7dd	68		pla		   PLA               ; restore string end byte
.b7de	a0 00		ldy #$00	   LDY #0
.b7e0	91 24		sta ($24),y	   STA (INDEXB),Y    ; put string end byte back
.b7e2					  Restore_Execution_Pointer
.b7e2	a6 71		ldx $71		   LDX TMPPTD
.b7e4	a4 72		ldy $72		   LDY TMPPTD+1
.b7e6	86 7a		stx $7a		   STX TXTPTR
.b7e8	84 7b		sty $7b		   STY TXTPTR+1
.b7ea	60		rts		   RTS
.b7eb					  Get_Word_And_Byte
.b7eb	20 8a ad	jsr $ad8a	   JSR Eval_Numeric
.b7ee	20 f7 b7	jsr $b7f7	   JSR FAC1_To_LINNUM
.b7f1					  Need_Comma_Get_Byte
.b7f1	20 fd ae	jsr $aefd	   JSR Need_Comma
.b7f4	4c 9e b7	jmp $b79e	   JMP Get_Byte_Value
.b7f7					  FAC1_To_LINNUM
.b7f7	a5 66		lda $66		   LDA FAC1SI        ; get FAC1 sign
.b7f9	30 9d		bmi $b798	   BMI Jump_To_Illegal_Quantity
.b7fb	a5 61		lda $61		   LDA FAC1EX        ; get FAC1 exponent
.b7fd	c9 91		cmp #$91	   CMP #$91          ; compare with exponent = 2^16
.b7ff	b0 97		bcs $b798	   BCS Jump_To_Illegal_Quantity
.b801	20 9b bc	jsr $bc9b	   JSR FAC1_To_Integer
.b804	a5 64		lda $64		   LDA FAC1M3        ; get FAC1 mantissa 3
.b806	a4 65		ldy $65		   LDY FAC1M4        ; get FAC1 mantissa 4
.b808	84 14		sty $14		   STY LINNUM        ; save temporary integer low byte
.b80a	85 15		sta $15		   STA LINNUM+1      ; save temporary integer high byte
.b80c	60		rts		   RTS
.b80d					  Basic_PEEK
.b80d	a5 15		lda $15		   LDA LINNUM+1
.b80f	48		pha		   PHA
.b810	a5 14		lda $14		   LDA LINNUM
.b812	48		pha		   PHA
.b813	20 f7 b7	jsr $b7f7	   JSR FAC1_To_LINNUM
.b816	a0 00		ldy #$00	   LDY #0
.b818	b1 14		lda ($14),y	   LDA (LINNUM),Y    ; read byte
.b81a	a8		tay		   TAY               ; copy byte to Y
.b81b	68		pla		   PLA
.b81c	85 14		sta $14		   STA LINNUM
.b81e	68		pla		   PLA
.b81f	85 15		sta $15		   STA LINNUM+1
.b821	4c a2 b3	jmp $b3a2	   JMP Y_To_Float
.b824					  Basic_POKE
.b824	20 eb b7	jsr $b7eb	   JSR Get_Word_And_Byte
.b827	8a		txa		   TXA               ; copy byte to A
.b828	a0 00		ldy #$00	   LDY #0
.b82a	91 14		sta ($14),y	   STA (LINNUM),Y    ; write byte
.b82c	60		rts		   RTS
.b82d					  Basic_WAIT
.b82d	20 eb b7	jsr $b7eb	   JSR Get_Word_And_Byte
.b830	86 49		stx $49		   STX FORPNT        ; save byte
.b832	a2 00		ldx #$00	   LDX #0            ; clear mask
.b834	20 79 00	jsr $0079	   JSR CHRGOT
.b837	f0 03		beq $b83c	   BEQ WAIT_10      ; skip if no third argument
.b839	20 f1 b7	jsr $b7f1	   JSR Need_Comma_Get_Byte
.b83c					WAIT_10
.b83c	86 4a		stx $4a		   STX FORPNT+1      ; save EOR argument
.b83e	a0 00		ldy #$00	   LDY #0
.b840					WAIT_20
.b840	b1 14		lda ($14),y	   LDA (LINNUM),Y    ; get byte via temporary integer (address)
.b842	45 4a		eor $4a		   EOR FORPNT+1      ; EOR with second argument       (mask)
.b844	25 49		and $49		   AND FORPNT        ; AND with first argument        (byte)
.b846	f0 f8		beq $b840	   BEQ WAIT_20       ; loop if result is zero
.b848					WAIT_Ret
.b848	60		rts		   RTS
.b849					  Add_0_5_To_FAC1
.b849	a9 11		lda #$11	   LDA #<Float_0_5 ;#<addr
.b84b	a0 bf		ldy #$bf	   LDY #>Float_0_5 ;#>addr
.b84d	4c 67 b8	jmp $b867	   JMP Add_Var_AY_To_FAC1
.b850					  AY_Minus_FAC1
.b850	20 8c ba	jsr $ba8c	   JSR Load_FAC2_From_AY
.b853					  Basic_MINUS
.b853	a5 66		lda $66		   LDA FAC1SI        ; get FAC1 sign (b7)
.b855	49 ff		eor #$ff	   EOR #$FF          ; complement it
.b857	85 66		sta $66		   STA FAC1SI        ; save FAC1 sign (b7)
.b859	45 6e		eor $6e		   EOR FAC2SI        ; EOR with FAC2 sign (b7)
.b85b	85 6f		sta $6f		   STA STRPTR        ; save sign compare (FAC1 EOR FAC2)
.b85d	a5 61		lda $61		   LDA FAC1EX        ; get FAC1 exponent
.b85f	4c 6a b8	jmp $b86a	   JMP Basic_PLUS    ; add FAC2 to FAC1 and return
.b862					PLUS_00
.b862	20 99 b9	jsr $b999	   JSR Shift_FACX_A
.b865	90 3c		bcc $b8a3	   BCC PLUS_20      ; go subtract the mantissas, branch always
.b867					  Add_Var_AY_To_FAC1
.b867	20 8c ba	jsr $ba8c	   JSR Load_FAC2_From_AY
.b86a					  Basic_PLUS
.b86a	d0 03		bne $b86f	   BNE PLUS_05      ; if FAC1 is not zero continue
.b86c	4c fc bb	jmp $bbfc	   JMP FAC2_To_FAC1
.b86f					PLUS_05
.b86f	a6 70		ldx $70		   LDX FAC1M5        ; get FAC1 rounding byte
.b871	86 56		stx $56		   STX FAC2M5        ; put FAC2 rounding byte
.b873	a2 69		ldx #$69	   LDX #FAC2EX       ; set index to FAC2
.b875	a5 69		lda $69		   LDA FAC2EX        ; get FAC2 exponent
.b877					  Add_FAC2_To_FAC1
.b877	a8		tay		   TAY               ; copy exponent
.b878	f0 ce		beq $b848	   BEQ WAIT_Ret      ; exit if FAC2 is zero
.b87a	38		sec		   SEC
.b87b	e5 61		sbc $61		   SBC FAC1EX        ; FAC2 exponent - FAC1 exponent
.b87d	f0 24		beq $b8a3	   BEQ PLUS_20       ; if equal go add mantissas
.b87f	90 12		bcc $b893	   BCC PLUS_10       ; if FAC2 < FAC1 then shift FAC2 right
.b881	84 61		sty $61		   STY FAC1EX        ; else                shift FAC1 right
.b883	a4 6e		ldy $6e		   LDY FAC2SI        ; get FAC2 sign (b7)
.b885	84 66		sty $66		   STY FAC1SI        ; put FAC1 sign (b7)
.b887	49 ff		eor #$ff	   EOR #$FF          ; complement A
.b889	69 00		adc #$00	   ADC #$00          ; +1, twos complement, carry is set
.b88b	a0 00		ldy #$00	   LDY #0
.b88d	84 56		sty $56		   STY FAC2M5        ; clear FAC2 rounding byte
.b88f	a2 61		ldx #$61	   LDX #FAC1EX       ; set index to FAC1
.b891	d0 04		bne $b897	   BNE PLUS_15       ; branch always
.b893					PLUS_10
.b893	a0 00		ldy #$00	   LDY #0
.b895	84 70		sty $70		   STY FAC1M5        ; clear FAC1 rounding byte
.b897					PLUS_15
.b897	c9 f9		cmp #$f9	   CMP #$F9          ; compare exponent diff with $F9
.b899	30 c7		bmi $b862	   BMI PLUS_00       ; branch if range $79-$F8
.b89b	a8		tay		   TAY               ; copy exponent difference to Y
.b89c	a5 70		lda $70		   LDA FAC1M5        ; get FAC1 rounding byte
.b89e	56 01		lsr $01,x	   LSR 1,X           ; shift FAC mantissa 1
.b8a0	20 b0 b9	jsr $b9b0	   JSR Shift_FACX_Right_Y
.b8a3					PLUS_20
.b8a3	24 6f		bit $6f		   BIT STRPTR        ; test sign compare (FAC1 EOR FAC2)
.b8a5	10 57		bpl $b8fe	   BPL PLUS_50      ; if = add FAC2 mantissa to FAC1 mantissa and return
.b8a7	a0 61		ldy #$61	   LDY #FAC1EX       ; set index to FAC1 exponent address
.b8a9	e0 69		cpx #$69	   CPX #FAC2EX       ; compare X to FAC2 exponent address
.b8ab	f0 02		beq $b8af	   BEQ PLUS_25       ; branch if equal
.b8ad	a0 69		ldy #$69	   LDY #FAC2EX       ; else set index to FAC2 exponent address
.b8af					PLUS_25
.b8af	38		sec		   SEC               ; compute FACY - FACX
.b8b0	49 ff		eor #$ff	   EOR #$FF          ; ones complement A
.b8b2	65 56		adc $56		   ADC FAC2M5        ; add FAC2 rounding byte
.b8b4	85 70		sta $70		   STA FAC1M5        ; put FAC1 rounding byte
.b8b6	b9 04 00	lda $0004,y	   LDA 4,Y
.b8b9	f5 04		sbc $04,x	   SBC 4,X
.b8bb	85 65		sta $65		   STA FAC1M4
.b8bd	b9 03 00	lda $0003,y	   LDA 3,Y
.b8c0	f5 03		sbc $03,x	   SBC 3,X
.b8c2	85 64		sta $64		   STA FAC1M3
.b8c4	b9 02 00	lda $0002,y	   LDA 2,Y
.b8c7	f5 02		sbc $02,x	   SBC 2,X
.b8c9	85 63		sta $63		   STA FAC1M2
.b8cb	b9 01 00	lda $0001,y	   LDA 1,Y
.b8ce	f5 01		sbc $01,x	   SBC 1,X
.b8d0	85 62		sta $62		   STA FAC1M1
.b8d2					PLUS_30
.b8d2	b0 03		bcs $b8d7	   BCS Normalise_FAC1
.b8d4	20 47 b9	jsr $b947	   JSR Negate_FAC1
.b8d7					  Normalise_FAC1
.b8d7	a0 00		ldy #$00	   LDY #0
.b8d9	98		tya		   TYA
.b8da	18		clc		   CLC
.b8db					PLUS_35
.b8db	a6 62		ldx $62		   LDX FAC1M1        ; get FAC1 mantissa 1
.b8dd	d0 4a		bne $b929	   BNE PLUS_60      ; if not zero normalise FAC1
.b8df	a6 63		ldx $63		   LDX FAC1M2        ; get FAC1 mantissa 2
.b8e1	86 62		stx $62		   STX FAC1M1        ; save FAC1 mantissa 1
.b8e3	a6 64		ldx $64		   LDX FAC1M3        ; get FAC1 mantissa 3
.b8e5	86 63		stx $63		   STX FAC1M2        ; save FAC1 mantissa 2
.b8e7	a6 65		ldx $65		   LDX FAC1M4        ; get FAC1 mantissa 4
.b8e9	86 64		stx $64		   STX FAC1M3        ; save FAC1 mantissa 3
.b8eb	a6 70		ldx $70		   LDX FAC1M5        ; get FAC1 rounding byte
.b8ed	86 65		stx $65		   STX FAC1M4        ; save FAC1 mantissa 4
.b8ef	84 70		sty $70		   STY FAC1M5        ; clear FAC1 rounding byte
.b8f1	69 08		adc #$08	   ADC #8            ; add x to exponent offset
.b8f3	c9 20		cmp #$20	   CMP #$20          ; compare with $20, max offset, all bits would be = 0
.b8f5	d0 e4		bne $b8db	   BNE PLUS_35       ; loop if not max
.b8f7					  Clear_FAC1_Exp_And_Sign
.b8f7	a9 00		lda #$00	   LDA #0
.b8f9					PLUS_40
.b8f9	85 61		sta $61		   STA FAC1EX        ; set FAC1 exponent
.b8fb					PLUS_45
.b8fb	85 66		sta $66		   STA FAC1SI        ; save FAC1 sign (b7)
.b8fd	60		rts		   RTS
.b8fe					PLUS_50
.b8fe	65 56		adc $56		   ADC FAC2M5
.b900	85 70		sta $70		   STA FAC1M5
.b902	a5 65		lda $65		   LDA FAC1M4
.b904	65 6d		adc $6d		   ADC FAC2M4
.b906	85 65		sta $65		   STA FAC1M4
.b908	a5 64		lda $64		   LDA FAC1M3
.b90a	65 6c		adc $6c		   ADC FAC2M3
.b90c	85 64		sta $64		   STA FAC1M3
.b90e	a5 63		lda $63		   LDA FAC1M2
.b910	65 6b		adc $6b		   ADC FAC2M2
.b912	85 63		sta $63		   STA FAC1M2
.b914	a5 62		lda $62		   LDA FAC1M1
.b916	65 6a		adc $6a		   ADC FAC2M1
.b918	85 62		sta $62		   STA FAC1M1
.b91a	4c 36 b9	jmp $b936	   JMP Test_And_Normalize_FAC1
.b91d					PLUS_55
.b91d	69 01		adc #$01	   ADC #1
.b91f	06 70		asl $70		   ASL FAC1M5
.b921	26 65		rol $65		   ROL FAC1M4
.b923	26 64		rol $64		   ROL FAC1M3
.b925	26 63		rol $63		   ROL FAC1M2
.b927	26 62		rol $62		   ROL FAC1M1
.b929					PLUS_60
.b929	10 f2		bpl $b91d	   BPL PLUS_55      ; loop if not normalised
.b92b	38		sec		   SEC
.b92c	e5 61		sbc $61		   SBC FAC1EX        ; subtract FAC1 exponent
.b92e	b0 c7		bcs $b8f7	   BCS Clear_FAC1_Exp_And_Sign ; branch if underflow (set result = $0)
.b930	49 ff		eor #$ff	   EOR #$FF          ; complement exponent
.b932	69 01		adc #$01	   ADC #$01          ; +1 (twos complement)
.b934	85 61		sta $61		   STA FAC1EX        ; save FAC1 exponent
.b936					  Test_And_Normalize_FAC1
.b936	90 0e		bcc $b946	   BCC TANF_Ret      ; exit if no overflow
.b938					TANF_10
.b938	e6 61		inc $61		   INC FAC1EX        ; increment FAC1 exponent
.b93a	f0 42		beq $b97e	   BEQ Overflow_Error
.b93c	66 62		ror $62		   ROR FAC1M1        ; shift FAC1 mantissa 1
.b93e	66 63		ror $63		   ROR FAC1M2        ; shift FAC1 mantissa 2
.b940	66 64		ror $64		   ROR FAC1M3        ; shift FAC1 mantissa 3
.b942	66 65		ror $65		   ROR FAC1M4        ; shift FAC1 mantissa 4
.b944	66 70		ror $70		   ROR FAC1M5        ; shift FAC1 rounding byte
.b946					TANF_Ret
.b946	60		rts		   RTS
.b947					  Negate_FAC1
.b947	a5 66		lda $66		   LDA FAC1SI        ; get FAC1 sign (b7)
.b949	49 ff		eor #$ff	   EOR #$FF          ; complement it
.b94b	85 66		sta $66		   STA FAC1SI        ; save FAC1 sign (b7)
.b94d					  Negate_FAC1_Mantissa
.b94d	a5 62		lda $62		   LDA FAC1M1
.b94f	49 ff		eor #$ff	   EOR #$FF
.b951	85 62		sta $62		   STA FAC1M1
.b953	a5 63		lda $63		   LDA FAC1M2
.b955	49 ff		eor #$ff	   EOR #$FF
.b957	85 63		sta $63		   STA FAC1M2
.b959	a5 64		lda $64		   LDA FAC1M3
.b95b	49 ff		eor #$ff	   EOR #$FF
.b95d	85 64		sta $64		   STA FAC1M3
.b95f	a5 65		lda $65		   LDA FAC1M4
.b961	49 ff		eor #$ff	   EOR #$FF
.b963	85 65		sta $65		   STA FAC1M4
.b965	a5 70		lda $70		   LDA FAC1M5
.b967	49 ff		eor #$ff	   EOR #$FF
.b969	85 70		sta $70		   STA FAC1M5
.b96b	e6 70		inc $70		   INC FAC1M5
.b96d	d0 0e		bne $b97d	   BNE IFM_Ret
.b96f					  Inc_FAC1_Mantissa
.b96f	e6 65		inc $65		   INC FAC1M4
.b971	d0 0a		bne $b97d	   BNE IFM_Ret
.b973	e6 64		inc $64		   INC FAC1M3
.b975	d0 06		bne $b97d	   BNE IFM_Ret
.b977	e6 63		inc $63		   INC FAC1M2
.b979	d0 02		bne $b97d	   BNE IFM_Ret
.b97b	e6 62		inc $62		   INC FAC1M1
.b97d					IFM_Ret
.b97d	60		rts		   RTS
.b97e					  Overflow_Error
.b97e	a2 0f		ldx #$0f	   LDX #$0F          ; error $0F, overflow error
.b980	4c 37 a4	jmp $a437	   JMP Basic_Error
.b983					  Shift_FAC3
.b983	a2 25		ldx #$25	   LDX #FAC3         ; apply shift routines on FAC3
.b985					  Shift_FACX
.b985	b4 04		ldy $04,x	   LDY 4,X
.b987	84 70		sty $70		   STY FAC1M5      ; mantissa 4 -> rounding byte
.b989	b4 03		ldy $03,x	   LDY 3,X
.b98b	94 04		sty $04,x	   STY 4,X           ; mantissa 3 -> 4
.b98d	b4 02		ldy $02,x	   LDY 2,X
.b98f	94 03		sty $03,x	   STY 3,X           ; mantissa 2 -> 3
.b991	b4 01		ldy $01,x	   LDY 1,X
.b993	94 02		sty $02,x	   STY 2,X           ; mantissa 1 -> 2
.b995	a4 68		ldy $68		   LDY FAC1OV
.b997	94 01		sty $01,x	   STY 1,X           ; overflow -> mantissa 1
.b999					  Shift_FACX_A
.b999	69 08		adc #$08	   ADC #8            ; add 8 to shift count
.b99b	30 e8		bmi $b985	   BMI Shift_FACX    ; if still negative shift byte wise
.b99d	f0 e6		beq $b985	   BEQ Shift_FACX    ; 8 shifts to do
.b99f	e9 08		sbc #$08	   SBC #8            ; reverse the addition
.b9a1	a8		tay		   TAY               ; save shift count to Y
.b9a2	a5 70		lda $70		   LDA FAC1M5      ; get FAC1 rounding byte
.b9a4	b0 14		bcs $b9ba	   BCS ShFA_30
.b9a6					ShFA_10
.b9a6	16 01		asl $01,x	   ASL 1,X           ; shift sign to carry, bit0 set to 0
.b9a8	90 02		bcc $b9ac	   BCC ShFA_20       ; branch if positive
.b9aa	f6 01		inc $01,x	   INC 1,X           ; bit0 set to 1
.b9ac					ShFA_20
.b9ac	76 01		ror $01,x	   ROR 1,X           ; shift FACX mantissa 1 with sign extension
.b9ae	76 01		ror $01,x	   ROR 1,X           ; shift FACX mantissa 1 with sign extension
.b9b0					  Shift_FACX_Right_Y
.b9b0	76 02		ror $02,x	   ROR 2,X           ; shift FACX mantissa 2
.b9b2	76 03		ror $03,x	   ROR 3,X           ; shift FACX mantissa 3
.b9b4	76 04		ror $04,x	   ROR 4,X           ; shift FACX mantissa 4
.b9b6	6a		ror a		   ROR A             ; shift FACX rounding byte
.b9b7	c8		iny		   INY               ; increment exponent diff
.b9b8	d0 ec		bne $b9a6	   BNE ShFA_10       ; branch if range adjust not complete
.b9ba					ShFA_30
.b9ba	18		clc		   CLC               ; just clear it
.b9bb	60		rts		   RTS
>b9bc	81 00 00 00 00			REAL_1 .byte $81,$00,$00,$00,$00 ;.real 1
.b9c1					VLOG_A
>b9c1	03				   .byte   $03            ; series counter
>b9c2	7f 5e 56 cb 79			   .byte $7F,$5E,$56,$CB,$79 ;.real   0.4342559419
>b9c7	80 13 9b 0b 64			   .byte $80,$13,$9B,$0B,$64 ;.real   0.5765845413
>b9cc	80 76 38 93 16			   .byte $80,$76,$38,$93,$16 ;.real   0.9618007592
>b9d1	82 38 aa 3b 20			   .byte $82,$38,$AA,$3B,$20 ;.real   2.8853900731
>b9d6	80 35 04 f3 34			HALF_SQRT_2 .byte $80,$35,$04,$F3,$34 ;.real   0.7071067812  ; 0.5 * sqrt(2.0)
>b9db	81 35 04 f3 34			SQRT_2      .byte $81,$35,$04,$F3,$34 ;.real   1.4142135624  ; sqrt(2.0)
>b9e0	80 80 00 00 00			MINUS_0_5   .byte $80,$80,$00,$00,$00 ;.real  -0.5
>b9e5	80 31 72 17 f8			LN_2        .byte $80,$31,$72,$17,$F8 ;.real   0.6931471807  ; ln(2.0)
.b9ea					  Basic_LOG
.b9ea	20 2b bc	jsr $bc2b	   JSR Get_FAC1_Sign
.b9ed	f0 02		beq $b9f1	   BEQ LOG_10        ; if zero do illegal quantity
.b9ef	10 03		bpl $b9f4	   BPL LOG_20        ; skip error if positive
.b9f1					LOG_10
.b9f1	4c 48 b2	jmp $b248	   JMP Illegal_Quantity      ; do illegal quantity error then warm start
.b9f4					LOG_20
.b9f4	a5 61		lda $61		   LDA FAC1EX        ; get FAC1 exponent
.b9f6	e9 7f		sbc #$7f	   SBC #$7F          ; normalise it
.b9f8	48		pha		   PHA               ; save it
.b9f9	a9 80		lda #$80	   LDA #$80          ; set exponent to zero
.b9fb	85 61		sta $61		   STA FAC1EX        ; save FAC1 exponent
.b9fd	a9 d6		lda #$d6	   LDA #<HALF_SQRT_2 ;#<addr
.b9ff	a0 b9		ldy #$b9	   LDY #>HALF_SQRT_2 ;#>addr
.ba01	20 67 b8	jsr $b867	   JSR Add_Var_AY_To_FAC1
.ba04	a9 db		lda #$db	   LDA #<SQRT_2 ;#<addr
.ba06	a0 b9		ldy #$b9	   LDY #>SQRT_2 ;#>addr
.ba08	20 0f bb	jsr $bb0f	   JSR AY_Divided_By_FAC1
.ba0b	a9 bc		lda #$bc	   LDA #<REAL_1 ;#<addr
.ba0d	a0 b9		ldy #$b9	   LDY #>REAL_1 ;#>addr
.ba0f	20 50 b8	jsr $b850	   JSR AY_Minus_FAC1
.ba12	a9 c1		lda #$c1	   LDA #<VLOG_A ;#<addr
.ba14	a0 b9		ldy #$b9	   LDY #>VLOG_A ;#>addr
.ba16	20 43 e0	jsr $e043	   JSR Square_And_Series_Eval
.ba19	a9 e0		lda #$e0	   LDA #<MINUS_0_5 ;#<addr
.ba1b	a0 b9		ldy #$b9	   LDY #>MINUS_0_5 ;#>addr
.ba1d	20 67 b8	jsr $b867	   JSR Add_Var_AY_To_FAC1
.ba20	68		pla		   PLA               ; restore FAC1 exponent
.ba21	20 7e bd	jsr $bd7e	   JSR Add_A_To_FAC1
.ba24	a9 e5		lda #$e5	   LDA #<LN_2 ;#<addr
.ba26	a0 b9		ldy #$b9	   LDY #>LN_2 ;#>addr
.ba28					  Multiply_FAC1_With_AY
.ba28	20 8c ba	jsr $ba8c	   JSR Load_FAC2_From_AY
.ba2b					  Basic_MULTIPLY
.ba2b	d0 03		bne $ba30	   BNE MULT_10       ; multiply FAC1 by FAC2 ??
.ba2d	4c 8b ba	jmp $ba8b	   JMP Mult_Sub_Ret  ; exit if zero
.ba30					MULT_10
.ba30	20 b7 ba	jsr $bab7	   JSR Check_FACs
.ba33	a9 00		lda #$00	   LDA #0
.ba35	85 26		sta $26		   STA FAC3+1
.ba37	85 27		sta $27		   STA FAC3+2
.ba39	85 28		sta $28		   STA FAC3+3
.ba3b	85 29		sta $29		   STA FAC3+4
.ba3d	a5 70		lda $70		   LDA FAC1M5
.ba3f	20 59 ba	jsr $ba59	   JSR Mult_SubA
.ba42	a5 65		lda $65		   LDA FAC1M4
.ba44	20 59 ba	jsr $ba59	   JSR Mult_SubA
.ba47	a5 64		lda $64		   LDA FAC1M3
.ba49	20 59 ba	jsr $ba59	   JSR Mult_SubA
.ba4c	a5 63		lda $63		   LDA FAC1M2
.ba4e	20 59 ba	jsr $ba59	   JSR Mult_SubA
.ba51	a5 62		lda $62		   LDA FAC1M1
.ba53	20 5e ba	jsr $ba5e	   JSR Mult_SubB
.ba56	4c 8f bb	jmp $bb8f	   JMP FAC3_To_FAC1
.ba59					  Mult_SubA
.ba59	d0 03		bne $ba5e	   BNE Mult_SubB
.ba5b	4c 83 b9	jmp $b983	   JMP Shift_FAC3
.ba5e					  Mult_SubB
.ba5e	4a		lsr a		   LSR A             ; shift byte
.ba5f	09 80		ora #$80	   ORA #$80          ; set top bit (mark for 8 times)
.ba61					MULT_20
.ba61	a8		tay		   TAY               ; copy result
.ba62	90 19		bcc $ba7d	   BCC MULT_30       ; skip next if bit was zero
.ba64	18		clc		   CLC
.ba65	a5 29		lda $29		   LDA FAC3+4
.ba67	65 6d		adc $6d		   ADC FAC2M4
.ba69	85 29		sta $29		   STA FAC3+4
.ba6b	a5 28		lda $28		   LDA FAC3+3
.ba6d	65 6c		adc $6c		   ADC FAC2M3
.ba6f	85 28		sta $28		   STA FAC3+3
.ba71	a5 27		lda $27		   LDA FAC3+2
.ba73	65 6b		adc $6b		   ADC FAC2M2
.ba75	85 27		sta $27		   STA FAC3+2
.ba77	a5 26		lda $26		   LDA FAC3+1
.ba79	65 6a		adc $6a		   ADC FAC2M1
.ba7b	85 26		sta $26		   STA FAC3+1
.ba7d					MULT_30
.ba7d	66 26		ror $26		   ROR FAC3+1
.ba7f	66 27		ror $27		   ROR FAC3+2
.ba81	66 28		ror $28		   ROR FAC3+3
.ba83	66 29		ror $29		   ROR FAC3+4
.ba85	66 70		ror $70		   ROR FAC1M5
.ba87	98		tya		   TYA               ; get byte back
.ba88	4a		lsr a		   LSR A             ; shift byte
.ba89	d0 d6		bne $ba61	   BNE MULT_20       ; loop if all bits not done
.ba8b					Mult_Sub_Ret
.ba8b	60		rts		   RTS
.ba8c					  Load_FAC2_From_AY
.ba8c	85 22		sta $22		   STA INDEXA
.ba8e	84 23		sty $23		   STY INDEXA+1
.ba90	a0 04		ldy #$04	   LDY #4            ; 5 bytes to get (0-4)
.ba92	b1 22		lda ($22),y	   LDA (INDEXA),Y    ; get mantissa 4
.ba94	85 6d		sta $6d		   STA FAC2M4        ; save FAC2 mantissa 4
.ba96	88		dey		   DEY               ; decrement index
.ba97	b1 22		lda ($22),y	   LDA (INDEXA),Y    ; get mantissa 3
.ba99	85 6c		sta $6c		   STA FAC2M3        ; save FAC2 mantissa 3
.ba9b	88		dey		   DEY               ; decrement index
.ba9c	b1 22		lda ($22),y	   LDA (INDEXA),Y    ; get mantissa 2
.ba9e	85 6b		sta $6b		   STA FAC2M2        ; save FAC2 mantissa 2
.baa0	88		dey		   DEY               ; decrement index
.baa1	b1 22		lda ($22),y	   LDA (INDEXA),Y    ; get mantissa 1 + sign
.baa3	85 6e		sta $6e		   STA FAC2SI        ; save FAC2 sign (b7)
.baa5	45 66		eor $66		   EOR FAC1SI        ; EOR with FAC1 sign (b7)
.baa7	85 6f		sta $6f		   STA STRPTR        ; save sign compare (FAC1 EOR FAC2)
.baa9	a5 6e		lda $6e		   LDA FAC2SI        ; recover FAC2 sign (b7)
.baab	09 80		ora #$80	   ORA #$80          ; set 1xxx xxx (set normal bit)
.baad	85 6a		sta $6a		   STA FAC2M1        ; save FAC2 mantissa 1
.baaf	88		dey		   DEY               ; decrement index
.bab0	b1 22		lda ($22),y	   LDA (INDEXA),Y    ; get exponent byte
.bab2	85 69		sta $69		   STA FAC2EX        ; save FAC2 exponent
.bab4	a5 61		lda $61		   LDA FAC1EX        ; get FAC1 exponent
.bab6	60		rts		   RTS
.bab7					  Check_FACs
.bab7	a5 69		lda $69		   LDA FAC2EX        ; get FAC2 exponent
.bab9					  Check_FACs_A
.bab9	f0 1f		beq $bada	   BEQ ChFA_30       ; branch if FAC2 = $00 (handle underflow)
.babb	18		clc		   CLC
.babc	65 61		adc $61		   ADC FAC1EX        ; add FAC1 exponent
.babe	90 04		bcc $bac4	   BCC ChFA_10       ; branch if sum of exponents < $0100
.bac0	30 1d		bmi $badf	   BMI ChFA_40       ; do overflow error
.bac2	18		clc		   CLC
>bac3	2c				   .byte   $2C       ; skip next statement
.bac4					ChFA_10
.bac4	10 14		bpl $bada	   BPL ChFA_30       ; if positive go handle underflow
.bac6	69 80		adc #$80	   ADC #$80          ; adjust exponent
.bac8	85 61		sta $61		   STA FAC1EX        ; save FAC1 exponent
.baca	d0 03		bne $bacf	   BNE ChFA_20       ; branch if not zero
.bacc	4c fb b8	jmp $b8fb	   JMP PLUS_45       ; save FAC1 sign and return
.bacf					ChFA_20
.bacf	a5 6f		lda $6f		   LDA STRPTR        ; get sign compare (FAC1 EOR FAC2)
.bad1	85 66		sta $66		   STA FAC1SI        ; save FAC1 sign (b7)
.bad3	60		rts		   RTS
.bad4					  Check_Overflow
.bad4	a5 66		lda $66		   LDA FAC1SI        ; get FAC1 sign (b7)
.bad6	49 ff		eor #$ff	   EOR #$FF          ; complement it
.bad8	30 05		bmi $badf	   BMI ChFA_40       ; do overflow error
.bada					ChFA_30
.bada	68		pla		   PLA               ; pop return address low byte
.badb	68		pla		   PLA               ; pop return address high byte
.badc	4c f7 b8	jmp $b8f7	   JMP Clear_FAC1_Exp_And_Sign
.badf					ChFA_40
.badf	4c 7e b9	jmp $b97e	   JMP Overflow_Error
.bae2					  Multiply_FAC1_BY_10
.bae2	20 0c bc	jsr $bc0c	   JSR FAC1_Round_And_Copy_To_FAC2
.bae5	aa		tax		   TAX               ; copy exponent (set the flags)
.bae6	f0 10		beq $baf8	   BEQ Mu10_Ret      ; exit if zero
.bae8	18		clc		   CLC
.bae9	69 02		adc #$02	   ADC #$02          ; add two to exponent (*4)
.baeb	b0 f2		bcs $badf	   BCS ChFA_40       ; do overflow error if > $FF
.baed					  Multiply_FAC1_By_4
.baed	a2 00		ldx #$00	   LDX #0
.baef	86 6f		stx $6f		   STX STRPTR        ; clear sign compare (FAC1 EOR FAC2)
.baf1	20 77 b8	jsr $b877	   JSR Add_FAC2_To_FAC1
.baf4	e6 61		inc $61		   INC FAC1EX        ; increment FAC1 exponent (*2)
.baf6	f0 e7		beq $badf	   BEQ ChFA_40       ; if exponent now zero go do overflow error
.baf8					Mu10_Ret
.baf8	60		rts		   RTS
>baf9	84 20 00 00 00			Float_10 .byte $84,$20,$00,$00,$00 ;.real 10
.bafe					  Divide_FAC1_By_10
.bafe	20 0c bc	jsr $bc0c	   JSR FAC1_Round_And_Copy_To_FAC2
.bb01	a9 f9		lda #$f9	   LDA #<Float_10 ;#<addr
.bb03	a0 ba		ldy #$ba	   LDY #>Float_10 ;#>addr
.bb05	a2 00		ldx #$00	   LDX #0            ; clear sign
.bb07					  Divide_FAC2_By_AY
.bb07	86 6f		stx $6f		   STX STRPTR        ; save sign compare (FAC1 EOR FAC2)
.bb09	20 a2 bb	jsr $bba2	   JSR Load_FAC1_AY
.bb0c	4c 12 bb	jmp $bb12	   JMP Basic_DIVIDE  ; do FAC2/FAC1
.bb0f					  AY_Divided_By_FAC1
.bb0f	20 8c ba	jsr $ba8c	   JSR Load_FAC2_From_AY
.bb12					  Basic_DIVIDE
.bb12	f0 76		beq $bb8a	   BEQ Divide_By_Zero; if zero go do /0 error
.bb14	20 1b bc	jsr $bc1b	   JSR Round_FAC1_Checked
.bb17	a9 00		lda #$00	   LDA #0
.bb19	38		sec		   SEC
.bb1a	e5 61		sbc $61		   SBC FAC1EX        ; subtract FAC1 exponent (2s complement)
.bb1c	85 61		sta $61		   STA FAC1EX        ; save FAC1 exponent
.bb1e	20 b7 ba	jsr $bab7	   JSR Check_FACs
.bb21	e6 61		inc $61		   INC FAC1EX        ; increment FAC1 exponent
.bb23	f0 ba		beq $badf	   BEQ ChFA_40       ; if zero do overflow error
.bb25	a2 fc		ldx #$fc	   LDX #$FC          ; set index to FAC temp
.bb27	a9 01		lda #$01	   LDA #$01          ; set byte
.bb29					DIVI_10
.bb29	a4 6a		ldy $6a		   LDY FAC2M1        ; compare mantissa
.bb2b	c4 62		cpy $62		   CPY FAC1M1
.bb2d	d0 10		bne $bb3f	   BNE DIVI_20
.bb2f	a4 6b		ldy $6b		   LDY FAC2M2
.bb31	c4 63		cpy $63		   CPY FAC1M2
.bb33	d0 0a		bne $bb3f	   BNE DIVI_20
.bb35	a4 6c		ldy $6c		   LDY FAC2M3
.bb37	c4 64		cpy $64		   CPY FAC1M3
.bb39	d0 04		bne $bb3f	   BNE DIVI_20
.bb3b	a4 6d		ldy $6d		   LDY FAC2M4
.bb3d	c4 65		cpy $65		   CPY FAC1M4
.bb3f					DIVI_20
.bb3f	08		php		   PHP               ; save the FAC2-FAC1 compare status
.bb40	2a		rol a		   ROL A             ; shift byte
.bb41	90 09		bcc $bb4c	   BCC DIVI_30       ; skip next if no carry
.bb43	e8		inx		   INX               ; increment index to FAC temp
.bb44	95 29		sta $29,x	   STA FAC3+4,X
.bb46	f0 32		beq $bb7a	   BEQ DIVI_60
.bb48	10 34		bpl $bb7e	   BPL DIVI_70
.bb4a	a9 01		lda #$01	   LDA #1
.bb4c					DIVI_30
.bb4c	28		plp		   PLP               ; restore FAC2-FAC1 compare status
.bb4d	b0 0e		bcs $bb5d	   BCS DIVI_50       ; if FAC2 >= FAC1 then do subtract
.bb4f					DIVI_40
.bb4f	06 6d		asl $6d		   ASL FAC2M4        ; shift FAC2 mantissa 4
.bb51	26 6c		rol $6c		   ROL FAC2M3        ; shift FAC2 mantissa 3
.bb53	26 6b		rol $6b		   ROL FAC2M2        ; shift FAC2 mantissa 2
.bb55	26 6a		rol $6a		   ROL FAC2M1        ; shift FAC2 mantissa 1
.bb57	b0 e6		bcs $bb3f	   BCS DIVI_20       ; loop with no compare
.bb59	30 ce		bmi $bb29	   BMI DIVI_10       ; loop with compare
.bb5b	10 e2		bpl $bb3f	   BPL DIVI_20       ; loop always with no compare
.bb5d					DIVI_50
.bb5d	a8		tay		   TAY               ; save FAC2-FAC1 compare status
.bb5e	a5 6d		lda $6d		   LDA FAC2M4        ; FAC2 = FAC2 - FAC1
.bb60	e5 65		sbc $65		   SBC FAC1M4
.bb62	85 6d		sta $6d		   STA FAC2M4
.bb64	a5 6c		lda $6c		   LDA FAC2M3
.bb66	e5 64		sbc $64		   SBC FAC1M3
.bb68	85 6c		sta $6c		   STA FAC2M3
.bb6a	a5 6b		lda $6b		   LDA FAC2M2
.bb6c	e5 63		sbc $63		   SBC FAC1M2
.bb6e	85 6b		sta $6b		   STA FAC2M2
.bb70	a5 6a		lda $6a		   LDA FAC2M1
.bb72	e5 62		sbc $62		   SBC FAC1M1
.bb74	85 6a		sta $6a		   STA FAC2M1
.bb76	98		tya		   TYA               ; restore FAC2-FAC1 compare status
.bb77	4c 4f bb	jmp $bb4f	   JMP DIVI_40       ; go shift FAC2
.bb7a					DIVI_60
.bb7a	a9 40		lda #$40	   LDA #$40
.bb7c	d0 ce		bne $bb4c	   BNE DIVI_30
.bb7e					DIVI_70
.bb7e	0a		asl a		   ASL A
.bb7f	0a		asl a		   ASL A
.bb80	0a		asl a		   ASL A
.bb81	0a		asl a		   ASL A
.bb82	0a		asl a		   ASL A
.bb83	0a		asl a		   ASL A
.bb84	85 70		sta $70		   STA FAC1M5        ; save FAC1 rounding byte
.bb86	28		plp		   PLP               ; dump FAC2-FAC1 compare status
.bb87	4c 8f bb	jmp $bb8f	   JMP FAC3_To_FAC1
.bb8a					  Divide_By_Zero
.bb8a	a2 14		ldx #$14	   LDX #$14          ; error $14, divide by zero error
.bb8c	4c 37 a4	jmp $a437	   JMP Basic_Error
.bb8f					  FAC3_To_FAC1
.bb8f	a5 26		lda $26		   LDA FAC3+1
.bb91	85 62		sta $62		   STA FAC1M1
.bb93	a5 27		lda $27		   LDA FAC3+2
.bb95	85 63		sta $63		   STA FAC1M2
.bb97	a5 28		lda $28		   LDA FAC3+3
.bb99	85 64		sta $64		   STA FAC1M3
.bb9b	a5 29		lda $29		   LDA FAC3+4
.bb9d	85 65		sta $65		   STA FAC1M4
.bb9f	4c d7 b8	jmp $b8d7	   JMP Normalise_FAC1
.bba2					  Load_FAC1_AY
.bba2	85 22		sta $22		   STA INDEXA
.bba4	84 23		sty $23		   STY INDEXA+1
.bba6	a0 04		ldy #$04	   LDY #$04          ; 5 bytes to do
.bba8	b1 22		lda ($22),y	   LDA (INDEXA),Y    ; get fifth byte
.bbaa	85 65		sta $65		   STA FAC1M4        ; save FAC1 mantissa 4
.bbac	88		dey		   DEY               ; decrement index
.bbad	b1 22		lda ($22),y	   LDA (INDEXA),Y    ; get fourth byte
.bbaf	85 64		sta $64		   STA FAC1M3        ; save FAC1 mantissa 3
.bbb1	88		dey		   DEY               ; decrement index
.bbb2	b1 22		lda ($22),y	   LDA (INDEXA),Y    ; get third byte
.bbb4	85 63		sta $63		   STA FAC1M2        ; save FAC1 mantissa 2
.bbb6	88		dey		   DEY               ; decrement index
.bbb7	b1 22		lda ($22),y	   LDA (INDEXA),Y    ; get second byte
.bbb9	85 66		sta $66		   STA FAC1SI        ; save FAC1 sign (b7)
.bbbb	09 80		ora #$80	   ORA #$80          ; set 1xxx xxxx (add normal bit)
.bbbd	85 62		sta $62		   STA FAC1M1        ; save FAC1 mantissa 1
.bbbf	88		dey		   DEY               ; decrement index
.bbc0	b1 22		lda ($22),y	   LDA (INDEXA),Y    ; get first byte (exponent)
.bbc2	85 61		sta $61		   STA FAC1EX        ; save FAC1 exponent
.bbc4	84 70		sty $70		   STY FAC1M5        ; clear FAC1 rounding byte
.bbc6	60		rts		   RTS
.bbc7					  FAC1_To_FACTPB
.bbc7	a2 5c		ldx #$5c	   LDX #<FACTPB      ; set pointer low byte
>bbc9	2c				   .byte   $2C       ; skip next statement
.bbca					  FAC1_To_FACTPA
.bbca	a2 57		ldx #$57	   LDX #<FACTPA      ; set pointer low byte
.bbcc	a0 00		ldy #$00	   LDY #>FACTPA      ; set pointer high byte
.bbce	f0 04		beq $bbd4	   BEQ Assign_FAC1_To_Var
.bbd0					  Assign_FAC1_To_FOR_Index
.bbd0	a6 49		ldx $49		   LDX FORPNT
.bbd2	a4 4a		ldy $4a		   LDY FORPNT+1
.bbd4					  Assign_FAC1_To_Var
.bbd4	20 1b bc	jsr $bc1b	   JSR Round_FAC1_Checked
.bbd7	86 22		stx $22		   STX INDEXA
.bbd9	84 23		sty $23		   STY INDEXA+1
.bbdb	a0 04		ldy #$04	   LDY #$04          ; set index
.bbdd	a5 65		lda $65		   LDA FAC1M4        ; get FAC1 mantissa 4
.bbdf	91 22		sta ($22),y	   STA (INDEXA),Y    ; store in destination
.bbe1	88		dey		   DEY               ; decrement index
.bbe2	a5 64		lda $64		   LDA FAC1M3        ; get FAC1 mantissa 3
.bbe4	91 22		sta ($22),y	   STA (INDEXA),Y    ; store in destination
.bbe6	88		dey		   DEY               ; decrement index
.bbe7	a5 63		lda $63		   LDA FAC1M2        ; get FAC1 mantissa 2
.bbe9	91 22		sta ($22),y	   STA (INDEXA),Y    ; store in destination
.bbeb	88		dey		   DEY               ; decrement index
.bbec	a5 66		lda $66		   LDA FAC1SI        ; get FAC1 sign (b7)
.bbee	09 7f		ora #$7f	   ORA #$7F          ; set bits x111 1111
.bbf0	25 62		and $62		   AND FAC1M1        ; AND in FAC1 mantissa 1
.bbf2	91 22		sta ($22),y	   STA (INDEXA),Y    ; store in destination
.bbf4	88		dey		   DEY               ; decrement index
.bbf5	a5 61		lda $61		   LDA FAC1EX        ; get FAC1 exponent
.bbf7	91 22		sta ($22),y	   STA (INDEXA),Y    ; store in destination
.bbf9	84 70		sty $70		   STY FAC1M5        ; clear FAC1 rounding byte
.bbfb	60		rts		   RTS
.bbfc					  FAC2_To_FAC1
.bbfc	a5 6e		lda $6e		   LDA FAC2SI        ; get FAC2 sign (b7)
.bbfe					  Copy_ABS_FAC2_To_FAC1
.bbfe	85 66		sta $66		   STA FAC1SI        ; save FAC1 sign (b7)
.bc00	a2 05		ldx #$05	   LDX #5            ; 5 bytes to copy
.bc02					F2F1_Loop
.bc02	b5 68		lda $68,x	   LDA FAC2EX-1,X
.bc04	95 60		sta $60,x	   STA FAC1EX-1,X
.bc06	ca		dex		   DEX
.bc07	d0 f9		bne $bc02	   BNE F2F1_Loop
.bc09	86 70		stx $70		   STX FAC1M5        ; clear FAC1 rounding byte
.bc0b	60		rts		   RTS
.bc0c					  FAC1_Round_And_Copy_To_FAC2
.bc0c	20 1b bc	jsr $bc1b	   JSR Round_FAC1_Checked
.bc0f					  FAC1_To_FAC2
.bc0f	a2 06		ldx #$06	   LDX #6
.bc11					F1F2_Loop
.bc11	b5 60		lda $60,x	   LDA FAC1EX-1,X
.bc13	95 68		sta $68,x	   STA FAC2EX-1,X
.bc15	ca		dex		   DEX
.bc16	d0 f9		bne $bc11	   BNE F1F2_Loop
.bc18	86 70		stx $70		   STX FAC1M5        ; clear FAC1 rounding byte
.bc1a					F1F2_Ret
.bc1a	60		rts		   RTS
.bc1b					  Round_FAC1_Checked
.bc1b	a5 61		lda $61		   LDA FAC1EX        ; get FAC1 exponent
.bc1d	f0 fb		beq $bc1a	   BEQ F1F2_Ret      ; exit if zero
.bc1f	06 70		asl $70		   ASL FAC1M5        ; shift FAC1 rounding byte
.bc21	90 f7		bcc $bc1a	   BCC F1F2_Ret      ; exit if no overflow
.bc23					  Round_FAC1
.bc23	20 6f b9	jsr $b96f	   JSR Inc_FAC1_Mantissa
.bc26	d0 f2		bne $bc1a	   BNE F1F2_Ret      ; branch if no overflow
.bc28	4c 38 b9	jmp $b938	   JMP TANF_10       ; normalise FAC1 for C=1 and return
.bc2b					  Get_FAC1_Sign
.bc2b	a5 61		lda $61		   LDA FAC1EX        ; get FAC1 exponent
.bc2d	f0 09		beq $bc38	   BEQ GFS_Ret       ; exit if zero
.bc2f					GFS_10
.bc2f	a5 66		lda $66		   LDA FAC1SI        ; else get FAC1 sign (b7)
.bc31					GFS_20
.bc31	2a		rol a		   ROL A             ; move sign bit to carry
.bc32	a9 ff		lda #$ff	   LDA #$FF          ; set byte for negative result
.bc34	b0 02		bcs $bc38	   BCS GFS_Ret       ; return if sign was set (negative)
.bc36	a9 01		lda #$01	   LDA #1            ; else set byte for positive result
.bc38					GFS_Ret
.bc38	60		rts		   RTS
.bc39					  Basic_SGN
.bc39	20 2b bc	jsr $bc2b	   JSR Get_FAC1_Sign
.bc3c					  A_To_FAC1
.bc3c	85 62		sta $62		   STA FAC1M1        ; save FAC1 mantissa 1
.bc3e	a9 00		lda #$00	   LDA #0
.bc40	85 63		sta $63		   STA FAC1M2        ; clear FAC1 mantissa 2
.bc42	a2 88		ldx #$88	   LDX #$88          ; set exponent
.bc44					  Int_To_Float_Exp_X
.bc44	a5 62		lda $62		   LDA FAC1M1        ; get FAC1 mantissa 1
.bc46	49 ff		eor #$ff	   EOR #$FF          ; complement it
.bc48	2a		rol a		   ROL A             ; sign bit into carry
.bc49					  Convert_Integer_To_Float
.bc49	a9 00		lda #$00	   LDA #0
.bc4b	85 65		sta $65		   STA FAC1M4        ; clear FAC1 mantissa 4
.bc4d	85 64		sta $64		   STA FAC1M3        ; clear FAC1 mantissa 3
.bc4f					CITF_10
.bc4f	86 61		stx $61		   STX FAC1EX        ; set FAC1 exponent
.bc51	85 70		sta $70		   STA FAC1M5        ; clear FAC1 rounding byte
.bc53	85 66		sta $66		   STA FAC1SI        ; clear FAC1 sign (b7)
.bc55	4c d2 b8	jmp $b8d2	   JMP PLUS_30       ; do ABS and normalise FAC1
.bc58					  Basic_ABS
.bc58	46 66		lsr $66		   LSR FAC1SI        ; clear FAC1 sign, put zero in b7
.bc5a	60		rts		   RTS
.bc5b					  Compare_FAC1_AY
.bc5b	85 24		sta $24		   STA INDEXB        ; save pointer low byte
.bc5d					  Compare_FAC1_INDEXB_Y
.bc5d	84 25		sty $25		   STY INDEXB+1      ; save pointer high byte
.bc5f	a0 00		ldy #$00	   LDY #0
.bc61	b1 24		lda ($24),y	   LDA (INDEXB),Y    ; get exponent
.bc63	c8		iny		   INY
.bc64	aa		tax		   TAX               ; copy (AY) exponent to X
.bc65	f0 c4		beq $bc2b	   BEQ Get_FAC1_Sign
.bc67	b1 24		lda ($24),y	   LDA (INDEXB),Y    ; get (AY) mantissa 1, with sign
.bc69	45 66		eor $66		   EOR FAC1SI        ; EOR FAC1 sign (b7)
.bc6b	30 c2		bmi $bc2f	   BMI GFS_10        ; if signs <> do return A = $FF, Cb = 1/negative
.bc6d	e4 61		cpx $61		   CPX FAC1EX        ; compare (AY) exponent with FAC1 exponent
.bc6f	d0 21		bne $bc92	   BNE CPFA_10       ; branch if different
.bc71	b1 24		lda ($24),y	   LDA (INDEXB),Y    ; get (AY) mantissa 1, with sign
.bc73	09 80		ora #$80	   ORA #$80          ; normalise top bit
.bc75	c5 62		cmp $62		   CMP FAC1M1        ; compare with FAC1 mantissa 1
.bc77	d0 19		bne $bc92	   BNE CPFA_10       ; branch if different
.bc79	c8		iny		   INY
.bc7a	b1 24		lda ($24),y	   LDA (INDEXB),Y    ; get mantissa 2
.bc7c	c5 63		cmp $63		   CMP FAC1M2        ; compare with FAC1 mantissa 2
.bc7e	d0 12		bne $bc92	   BNE CPFA_10       ; branch if different
.bc80	c8		iny		   INY
.bc81	b1 24		lda ($24),y	   LDA (INDEXB),Y    ; get mantissa 3
.bc83	c5 64		cmp $64		   CMP FAC1M3        ; compare with FAC1 mantissa 3
.bc85	d0 0b		bne $bc92	   BNE CPFA_10       ; branch if different
.bc87	c8		iny		   INY
.bc88	a9 7f		lda #$7f	   LDA #$7F          ; set for 1/2 value rounding byte
.bc8a	c5 70		cmp $70		   CMP FAC1M5        ; compare with FAC1 rounding byte (set carry)
.bc8c	b1 24		lda ($24),y	   LDA (INDEXB),Y    ; get mantissa 4
.bc8e	e5 65		sbc $65		   SBC FAC1M4        ; subtract FAC1 mantissa 4
.bc90	f0 28		beq $bcba	   BEQ FATI_20       ; exit if mantissa 4 equal
.bc92					CPFA_10
.bc92	a5 66		lda $66		   LDA FAC1SI        ; get FAC1 sign (b7)
.bc94	90 02		bcc $bc98	   BCC CPFA_20       ; branch if FAC1 > (AY)
.bc96	49 ff		eor #$ff	   EOR #$FF          ; else toggle FAC1 sign
.bc98					CPFA_20
.bc98	4c 31 bc	jmp $bc31	   JMP GFS_20        ; return A = $FF, Cb = 1/negative A = $01, Cb = 0/positive
.bc9b					  FAC1_To_Integer
.bc9b	a5 61		lda $61		   LDA FAC1EX
.bc9d	f0 4a		beq $bce9	   BEQ Clear_FAC1
.bc9f	38		sec		   SEC
.bca0	e9 a0		sbc #$a0	   SBC #$A0          ; subtract maximum integer range exponent
.bca2	24 66		bit $66		   BIT FAC1SI        ; test FAC1 sign (b7)
.bca4	10 09		bpl $bcaf	   BPL FATI_10       ; branch if FAC1 positive
.bca6	aa		tax		   TAX               ; copy subtracted exponent
.bca7	a9 ff		lda #$ff	   LDA #$FF          ; overflow for negative number
.bca9	85 68		sta $68		   STA FAC1OV        ; set FAC1 overflow byte
.bcab	20 4d b9	jsr $b94d	   JSR Negate_FAC1_Mantissa
.bcae	8a		txa		   TXA               ; restore subtracted exponent
.bcaf					FATI_10
.bcaf	a2 61		ldx #$61	   LDX #FAC1EX
.bcb1	c9 f9		cmp #$f9	   CMP #$F9          ; compare exponent result
.bcb3	10 06		bpl $bcbb	   BPL FATI_30       ; less than 8 shifts
.bcb5	20 99 b9	jsr $b999	   JSR Shift_FACX_A
.bcb8	84 68		sty $68		   STY FAC1OV        ; clear FAC1 overflow byte
.bcba					FATI_20
.bcba	60		rts		   RTS
.bcbb					FATI_30
.bcbb	a8		tay		   TAY               ; copy shift count
.bcbc	a5 66		lda $66		   LDA FAC1SI        ; get FAC1 sign (b7)
.bcbe	29 80		and #$80	   AND #$80          ; mask sign bit only (x000 0000)
.bcc0	46 62		lsr $62		   LSR FAC1M1        ; shift FAC1 mantissa 1
.bcc2	05 62		ora $62		   ORA FAC1M1        ; OR sign in b7 FAC1 mantissa 1
.bcc4	85 62		sta $62		   STA FAC1M1        ; save FAC1 mantissa 1
.bcc6	20 b0 b9	jsr $b9b0	   JSR Shift_FACX_Right_Y
.bcc9	84 68		sty $68		   STY FAC1OV        ; clear FAC1 overflow byte
.bccb	60		rts		   RTS
.bccc					  Basic_INT
.bccc	a5 61		lda $61		   LDA FAC1EX        ; get FAC1 exponent
.bcce	c9 a0		cmp #$a0	   CMP #$A0          ; compare with max int
.bcd0	b0 20		bcs $bcf2	   BCS ClF1_Ret      ; exit if >= (allready int, too big for fractional part!)
.bcd2	20 9b bc	jsr $bc9b	   JSR FAC1_To_Integer
.bcd5	84 70		sty $70		   STY FAC1M5        ; save FAC1 rounding byte
.bcd7	a5 66		lda $66		   LDA FAC1SI        ; get FAC1 sign (b7)
.bcd9	84 66		sty $66		   STY FAC1SI        ; save FAC1 sign (b7)
.bcdb	49 80		eor #$80	   EOR #$80          ; toggle FAC1 sign
.bcdd	2a		rol a		   ROL A             ; shift into carry
.bcde	a9 a0		lda #$a0	   LDA #$A0          ; set new exponent
.bce0	85 61		sta $61		   STA FAC1EX        ; save FAC1 exponent
.bce2	a5 65		lda $65		   LDA FAC1M4        ; get FAC1 mantissa 4
.bce4	85 07		sta $07		   STA CHARAC        ; save FAC1 mantissa 4 for power function
.bce6	4c d2 b8	jmp $b8d2	   JMP PLUS_30      ; do ABS and normalise FAC1
.bce9					  Clear_FAC1
.bce9	85 62		sta $62		   STA FAC1M1
.bceb	85 63		sta $63		   STA FAC1M2
.bced	85 64		sta $64		   STA FAC1M3
.bcef	85 65		sta $65		   STA FAC1M4
.bcf1	a8		tay		   TAY
.bcf2					ClF1_Ret
.bcf2	60		rts		   RTS
.bcf3					  Load_FAC1_From_String
.bcf3	a0 00		ldy #$00	   LDY #0
.bcf5	a2 0a		ldx #$0a	   LDX #10
.bcf7					LFFS_05
.bcf7	94 5d		sty $5d,x	   STY TMPVA1,X      ; clear 10 bytes TMPVA1 & FAC1 ($5D - $66)
.bcf9	ca		dex		   DEX
.bcfa	10 fb		bpl $bcf7	   BPL LFFS_05
.bcfc	90 0f		bcc $bd0d	   BCC LFFS_20       ; branch if first character is numeric
.bcfe	c9 2d		cmp #$2d	   CMP #'-'          ; else compare with "-"
.bd00	d0 04		bne $bd06	   BNE LFFS_10       ; branch if not "-"
.bd02	86 67		stx $67		   STX SGNFLG        ; set flag for negative n (X = $FF)
.bd04	f0 04		beq $bd0a	   BEQ LFFS_15       ; branch always
.bd06					LFFS_10
.bd06	c9 2b		cmp #$2b	   CMP #'+'          ; else compare with "+"
.bd08	d0 05		bne $bd0f	   BNE LFFS_25       ; branch if not "+"
.bd0a					LFFS_15
.bd0a	20 73 00	jsr $0073	   JSR CHRGET        ; next char
.bd0d					LFFS_20
.bd0d	90 5b		bcc $bd6a	   BCC LFFS_75       ; branch if numeric character
.bd0f					LFFS_25
.bd0f	c9 2e		cmp #$2e	   CMP #'.'
.bd11	f0 2e		beq $bd41	   BEQ LFFS_40
.bd13	c9 45		cmp #$45	   CMP #'E'
.bd15	d0 30		bne $bd47	   BNE LFFS_45
.bd17	20 73 00	jsr $0073	   JSR CHRGET        ; read exponent
.bd1a	90 17		bcc $bd33	   BCC LFFS_37       ; branch if numeric character
.bd1c	c9 ab		cmp #$ab	   CMP #TK_MINUS
.bd1e	f0 0e		beq $bd2e	   BEQ LFFS_30
.bd20	c9 2d		cmp #$2d	   CMP #'-'
.bd22	f0 0a		beq $bd2e	   BEQ LFFS_30
.bd24	c9 aa		cmp #$aa	   CMP #TK_PLUS
.bd26	f0 08		beq $bd30	   BEQ LFFS_35
.bd28	c9 2b		cmp #$2b	   CMP #'+'
.bd2a	f0 04		beq $bd30	   BEQ LFFS_35
.bd2c	d0 07		bne $bd35	   BNE LFFS_38       ; branch always
.bd2e					LFFS_30
.bd2e	66 60		ror $60		   ROR TMPPTC+1      ; set exponent negative flag (ror carry into sign)
.bd30					LFFS_35
.bd30	20 73 00	jsr $0073	   JSR CHRGET        ; next char of exponent
.bd33					LFFS_37
.bd33	90 5c		bcc $bd91	   BCC LFFS_85       ; branch if numeric character
.bd35					LFFS_38
.bd35	24 60		bit $60		   BIT TMPPTC+1      ; test exponent negative flag
.bd37	10 0e		bpl $bd47	   BPL LFFS_45       ; if positive go evaluate exponent
.bd39	a9 00		lda #$00	   LDA #0
.bd3b	38		sec		   SEC
.bd3c	e5 5e		sbc $5e		   SBC TMPVA2        ; negate exponent
.bd3e	4c 49 bd	jmp $bd49	   JMP LFFS_50       ; go evaluate exponent
.bd41					LFFS_40
.bd41	66 5f		ror $5f		   ROR TMPPTC        ; set decimal point flag
.bd43	24 5f		bit $5f		   BIT TMPPTC        ; test decimal point flag
.bd45	50 c3		bvc $bd0a	   BVC LFFS_15       ; branch if only one decimal point so far
.bd47					LFFS_45
.bd47	a5 5e		lda $5e		   LDA TMPVA2        ; get exponent count byte
.bd49					LFFS_50
.bd49	38		sec		   SEC
.bd4a	e5 5d		sbc $5d		   SBC TMPVA1        ; subtract numerator exponent
.bd4c	85 5e		sta $5e		   STA TMPVA2        ; save exponent count byte
.bd4e	f0 12		beq $bd62	   BEQ LFFS_65       ; branch if no adjustment
.bd50	10 09		bpl $bd5b	   BPL LFFS_60       ; else if positive go do FAC1*10^expcnt
.bd52					LFFS_55
.bd52	20 fe ba	jsr $bafe	   JSR Divide_FAC1_By_10
.bd55	e6 5e		inc $5e		   INC TMPVA2        ; increment exponent count byte
.bd57	d0 f9		bne $bd52	   BNE LFFS_55       ; loop until all done
.bd59	f0 07		beq $bd62	   BEQ LFFS_65       ; branch always
.bd5b					LFFS_60
.bd5b	20 e2 ba	jsr $bae2	   JSR Multiply_FAC1_BY_10
.bd5e	c6 5e		dec $5e		   DEC TMPVA2        ; decrement exponent count byte
.bd60	d0 f9		bne $bd5b	   BNE LFFS_60       ; loop until all done
.bd62					LFFS_65
.bd62	a5 67		lda $67		   LDA SGNFLG        ; get negative flag
.bd64	30 01		bmi $bd67	   BMI LFFS_70       ; if negative do - FAC1 and return
.bd66	60		rts		   RTS
.bd67					LFFS_70
.bd67	4c b4 bf	jmp $bfb4	   JMP Basic_GREATER ; do - FAC1
.bd6a					LFFS_75
.bd6a	48		pha		   PHA               ; save character
.bd6b	24 5f		bit $5f		   BIT TMPPTC        ; test decimal point flag
.bd6d	10 02		bpl $bd71	   BPL LFFS_80       ; skip exponent increment if not set
.bd6f	e6 5d		inc $5d		   INC TMPVA1        ; else increment number exponent
.bd71					LFFS_80
.bd71	20 e2 ba	jsr $bae2	   JSR Multiply_FAC1_BY_10
.bd74	68		pla		   PLA               ; restore character
.bd75	38		sec		   SEC
.bd76	e9 30		sbc #$30	   SBC #'0'          ; convert to binary
.bd78	20 7e bd	jsr $bd7e	   JSR Add_A_To_FAC1
.bd7b	4c 0a bd	jmp $bd0a	   JMP LFFS_15      ; go do next character
.bd7e					  Add_A_To_FAC1
.bd7e	48		pha		   PHA               ; save digit
.bd7f	20 0c bc	jsr $bc0c	   JSR FAC1_Round_And_Copy_To_FAC2
.bd82	68		pla		   PLA               ; restore digit
.bd83	20 3c bc	jsr $bc3c	   JSR A_To_FAC1
.bd86	a5 6e		lda $6e		   LDA FAC2SI        ; get FAC2 sign (b7)
.bd88	45 66		eor $66		   EOR FAC1SI        ; toggle with FAC1 sign (b7)
.bd8a	85 6f		sta $6f		   STA STRPTR        ; save sign compare (FAC1 EOR FAC2)
.bd8c	a6 61		ldx $61		   LDX FAC1EX        ; get FAC1 exponent
.bd8e	4c 6a b8	jmp $b86a	   JMP Basic_PLUS    ; add FAC2 to FAC1 and return
.bd91					LFFS_85
.bd91	a5 5e		lda $5e		   LDA TMPVA2        ; get exponent count byte
.bd93	c9 0a		cmp #$0a	   CMP #10           ; compare with 10 decimal
.bd95	90 09		bcc $bda0	   BCC LFFS_90       ; branch if less
.bd97	a9 64		lda #$64	   LDA #$64          ; make all negative exponents = -100 decimal (causes underflow)
.bd99	24 60		bit $60		   BIT TMPPTC+1      ; test exponent negative flag
.bd9b	30 11		bmi $bdae	   BMI LFFS_95       ; branch if negative
.bd9d	4c 7e b9	jmp $b97e	   JMP Overflow_Error
.bda0					LFFS_90
.bda0	0a		asl a		   ASL A             ; *2
.bda1	0a		asl a		   ASL A             ; *4
.bda2	18		clc		   CLC
.bda3	65 5e		adc $5e		   ADC TMPVA2        ; *5
.bda5	0a		asl a		   ASL A             ; *10
.bda6	18		clc		   CLC
.bda7	a0 00		ldy #$00	   LDY #0
.bda9	71 7a		adc ($7a),y	   ADC (TXTPTR),Y    ; add character (will be $30 too much!)
.bdab	38		sec		   SEC
.bdac	e9 30		sbc #$30	   SBC #'0'          ; convert character to binary
.bdae					LFFS_95
.bdae	85 5e		sta $5e		   STA TMPVA2        ; save exponent count byte
.bdb0	4c 30 bd	jmp $bd30	   JMP LFFS_35       ; go get next character
>bdb3	9b 3e bc 1f fd			MAXREAL_A .byte $9B,$3E,$BC,$1F,$FD ;.real   99999999.90625
>bdb8	9e 6e 6b 27 fd			MAXREAL_B .byte $9E,$6E,$6B,$27,$FD ;.real  999999999.25
>bdbd	9e 6e 6b 28 00			MAXREAL_C .byte $9E,$6E,$6B,$28,$00 ;.real 1000000000
.bdc2					  Print_IN
.bdc2	a9 71		lda #$71	   LDA #<Msg_IN ;#<addr
.bdc4	a0 a3		ldy #$a3	   LDY #>Msg_IN ;#>addr
.bdc6	20 da bd	jsr $bdda	   JSR To_Print_String
.bdc9	a5 3a		lda $3a		   LDA CURLIN+1      ; get the current line number high byte
.bdcb	a6 39		ldx $39		   LDX CURLIN        ; get the current line number low byte
.bdcd					  Print_Integer_XA
.bdcd	85 62		sta $62		   STA FAC1M1        ; save high byte as FAC1 mantissa1
.bdcf	86 63		stx $63		   STX FAC1M2        ; save low byte as FAC1 mantissa2
.bdd1	a2 90		ldx #$90	   LDX #$90          ; set exponent to 16d bits
.bdd3	38		sec		   SEC               ; set integer is positive flag
.bdd4	20 49 bc	jsr $bc49	   JSR Convert_Integer_To_Float
.bdd7	20 df bd	jsr $bddf	   JSR Format_FAC1_Y
.bdda					To_Print_String
.bdda	4c 1e ab	jmp $ab1e	   JMP Print_String
.bddd					  Format_FAC1
.bddd	a0 01		ldy #$01	   LDY #1
.bddf					  Format_FAC1_Y
.bddf	a9 20		lda #$20	   LDA #' '          ; character = " " (assume positive)
.bde1	24 66		bit $66		   BIT FAC1SI        ; test FAC1 sign (b7)
.bde3	10 02		bpl $bde7	   BPL FoFA_02       ; if positive skip the - sign set
.bde5	a9 2d		lda #$2d	   LDA #'-'          ; else character = "-"
.bde7					FoFA_02
.bde7	99 ff 00	sta $00ff,y	   STA BASSTO,Y      ; save leading character (" " or "-")
.bdea	85 66		sta $66		   STA FAC1SI        ; save FAC1 sign (b7)
.bdec	84 71		sty $71		   STY TMPPTD        ; save the index
.bdee	c8		iny		   INY
.bdef	a9 30		lda #$30	   LDA #'0'          ; set character = "0"
.bdf1	a6 61		ldx $61		   LDX FAC1EX        ; get FAC1 exponent
.bdf3	d0 03		bne $bdf8	   BNE FoFA_04       ; if FAC1 not zero format it
.bdf5	4c 04 bf	jmp $bf04	   JMP FoFA_52       ; just 0
.bdf8					FoFA_04
.bdf8	a9 00		lda #$00	   LDA #$00          ; clear (number exponent count)
.bdfa	e0 80		cpx #$80	   CPX #$80          ; compare FAC1 exponent with $80 (<1.00000)
.bdfc	f0 02		beq $be00	   BEQ FoFA_06       ; branch if 0.5 <= FAC1 < 1.0
.bdfe	b0 09		bcs $be09	   BCS FoFA_08       ; branch if FAC1=>1
.be00					FoFA_06
.be00	a9 bd		lda #$bd	   LDA #<MAXREAL_C ;#<addr
.be02	a0 bd		ldy #$bd	   LDY #>MAXREAL_C ;#>addr
.be04	20 28 ba	jsr $ba28	   JSR Multiply_FAC1_With_AY
.be07	a9 f7		lda #$f7	   LDA #$F7          ; set number exponent count
.be09					FoFA_08
.be09	85 5d		sta $5d		   STA TMPVA1        ; save number exponent count
.be0b					FoFA_10
.be0b	a9 b8		lda #$b8	   LDA #<MAXREAL_B ;#<addr
.be0d	a0 bd		ldy #$bd	   LDY #>MAXREAL_B ;#>addr
.be0f	20 5b bc	jsr $bc5b	   JSR Compare_FAC1_AY
.be12	f0 1e		beq $be32	   BEQ FoFA_20       ; exit if FAC1 = (AY)
.be14	10 12		bpl $be28	   BPL FoFA_16       ; go do /10 if FAC1 > (AY)
.be16					FoFA_12
.be16	a9 b3		lda #$b3	   LDA #<MAXREAL_A ;#<addr
.be18	a0 bd		ldy #$bd	   LDY #>MAXREAL_A ;#>addr
.be1a	20 5b bc	jsr $bc5b	   JSR Compare_FAC1_AY
.be1d	f0 02		beq $be21	   BEQ FoFA_14       ; branch if FAC1 = (AY) (allow decimal places)
.be1f	10 0e		bpl $be2f	   BPL FoFA_18       ; branch if FAC1 > (AY) (no decimal places)
.be21					FoFA_14
.be21	20 e2 ba	jsr $bae2	   JSR Multiply_FAC1_BY_10
.be24	c6 5d		dec $5d		   DEC TMPVA1        ; decrement number exponent count
.be26	d0 ee		bne $be16	   BNE FoFA_12       ; go test again, branch always
.be28					FoFA_16
.be28	20 fe ba	jsr $bafe	   JSR Divide_FAC1_By_10
.be2b	e6 5d		inc $5d		   INC TMPVA1        ; increment number exponent count
.be2d	d0 dc		bne $be0b	   BNE FoFA_10       ; go test again, branch always
.be2f					FoFA_18
.be2f	20 49 b8	jsr $b849	   JSR Add_0_5_To_FAC1
.be32					FoFA_20
.be32	20 9b bc	jsr $bc9b	   JSR FAC1_To_Integer
.be35	a2 01		ldx #$01	   LDX #$01          ; set default digits before dp = 1
.be37	a5 5d		lda $5d		   LDA TMPVA1        ; get number exponent count
.be39	18		clc		   CLC
.be3a	69 0a		adc #$0a	   ADC #$0A          ; up to 9 digits before point
.be3c	30 09		bmi $be47	   BMI FoFA_22       ; if negative then 1 digit before dp
.be3e	c9 0b		cmp #$0b	   CMP #$0B          ; A>=$0B if n>=1E9
.be40	b0 06		bcs $be48	   BCS FoFA_24       ; branch if >= $0B
.be42	69 ff		adc #$ff	   ADC #$FF          ; take 1 from digit count
.be44	aa		tax		   TAX               ; copy to X
.be45	a9 02		lda #$02	   LDA #$02          ; set the exponent adjust
.be47					FoFA_22
.be47	38		sec		   SEC
.be48					FoFA_24
.be48	e9 02		sbc #$02	   SBC #$02          ; -2
.be4a	85 5e		sta $5e		   STA TMPVA2        ; save the exponent adjust
.be4c	86 5d		stx $5d		   STX TMPVA1        ; save digits before dp count
.be4e	8a		txa		   TXA               ; copy digits before dp count to A
.be4f	f0 02		beq $be53	   BEQ FoFA_26       ; if no digits before the dp go do the "."
.be51	10 13		bpl $be66	   BPL FoFA_30       ; if there are digits before the dp go do them
.be53					FoFA_26
.be53	a4 71		ldy $71		   LDY TMPPTD        ; get the output string index
.be55	a9 2e		lda #$2e	   LDA #'.'          ; character "."
.be57	c8		iny		   INY               ; increment the index
.be58	99 ff 00	sta $00ff,y	   STA STACK-1,Y     ; save the "." to the output string
.be5b	8a		txa		   TXA               ; copy digits before dp count to A
.be5c	f0 06		beq $be64	   BEQ FoFA_28       ; if no digits before the dp skip the "0"
.be5e	a9 30		lda #$30	   LDA #'0'          ; character "0"
.be60	c8		iny		   INY
.be61	99 ff 00	sta $00ff,y	   STA STACK-1,Y     ; save the "0" to the output string
.be64					FoFA_28
.be64	84 71		sty $71		   STY TMPPTD        ; save the output string index
.be66					FoFA_30
.be66	a0 00		ldy #$00	   LDY #0            ; clear the powers of 10 index (point to -100,000,000)
.be68					  Format_Jiffyclock
.be68	a2 80		ldx #$80	   LDX #$80          ; clear the digit, set the test sense
.be6a					FoFA_32
.be6a	a5 65		lda $65		   LDA FAC1M4        ; get FAC1 mantissa 4
.be6c	18		clc		   CLC
.be6d	79 19 bf	adc $bf19,y	   ADC Decimal_Conversion_Table+3,Y
.be70	85 65		sta $65		   STA FAC1M4        ; save FAC1 mantissa4
.be72	a5 64		lda $64		   LDA FAC1M3        ; get FAC1 mantissa 3
.be74	79 18 bf	adc $bf18,y	   ADC Decimal_Conversion_Table+2,Y
.be77	85 64		sta $64		   STA FAC1M3        ; save FAC1 mantissa3
.be79	a5 63		lda $63		   LDA FAC1M2        ; get FAC1 mantissa 2
.be7b	79 17 bf	adc $bf17,y	   ADC Decimal_Conversion_Table+1,Y
.be7e	85 63		sta $63		   STA FAC1M2        ; save FAC1 mantissa2
.be80	a5 62		lda $62		   LDA FAC1M1        ; get FAC1 mantissa 1
.be82	79 16 bf	adc $bf16,y	   ADC Decimal_Conversion_Table+0,Y
.be85	85 62		sta $62		   STA FAC1M1        ; save FAC1 mantissa1
.be87	e8		inx		   INX               ; increment the digit, set the sign on the test sense bit
.be88	b0 04		bcs $be8e	   BCS FoFA_34       ; if the carry is set go test if the result was positive
.be8a	10 de		bpl $be6a	   BPL FoFA_32       ; not negative so try again
.be8c	30 02		bmi $be90	   BMI FoFA_36       ; else done so return the digit
.be8e					FoFA_34
.be8e	30 da		bmi $be6a	   BMI FoFA_32       ; not positive so try again
.be90					FoFA_36
.be90	8a		txa		   TXA               ; copy the digit
.be91	90 04		bcc $be97	   BCC FoFA_38       ; if Cb=0 just use it
.be93	49 ff		eor #$ff	   EOR #$FF          ; else make the 2's complement ..
.be95	69 0a		adc #$0a	   ADC #$0A          ; .. and subtract it from 10
.be97					FoFA_38
.be97	69 2f		adc #$2f	   ADC #'0'-1        ; add "0"-1 to result
.be99	c8		iny		   INY               ; increment ..
.be9a	c8		iny		   INY               ; .. index to..
.be9b	c8		iny		   INY               ; .. next less ..
.be9c	c8		iny		   INY               ; .. power of ten
.be9d	84 47		sty $47		   STY VARPNT        ; save the powers of ten table index
.be9f	a4 71		ldy $71		   LDY TMPPTD        ; get output string index
.bea1	c8		iny		   INY               ; increment output string index
.bea2	aa		tax		   TAX               ; copy character to X
.bea3	29 7f		and #$7f	   AND #$7F          ; mask out top bit
.bea5	99 ff 00	sta $00ff,y	   STA STACK-1,Y     ; save to output string
.bea8	c6 5d		dec $5d		   DEC TMPVA1        ; decrement # of characters before the dp
.beaa	d0 06		bne $beb2	   BNE FoFA_40       ; if still characters to do skip the decimal point
.beac	a9 2e		lda #$2e	   LDA #'.'          ; character "."
.beae	c8		iny		   INY               ; increment output string index
.beaf	99 ff 00	sta $00ff,y	   STA STACK-1,Y     ; save to output string
.beb2					FoFA_40
.beb2	84 71		sty $71		   STY TMPPTD        ; save the output string index
.beb4	a4 47		ldy $47		   LDY VARPNT        ; get the powers of ten table index
.beb6	8a		txa		   TXA               ; get the character back
.beb7	49 ff		eor #$ff	   EOR #$FF          ; toggle the test sense bit
.beb9	29 80		and #$80	   AND #$80          ; clear the digit
.bebb	aa		tax		   TAX               ; copy it to the new digit
.bebc	c0 24		cpy #$24	   CPY #Jiffy_Conversion_Table-Decimal_Conversion_Table
.bebe	f0 04		beq $bec4	   BEQ FoFA_42       ; if at the max exit the digit loop
.bec0	c0 3c		cpy #$3c	   CPY #End_Of_Conversion-Decimal_Conversion_Table
.bec2	d0 a6		bne $be6a	   BNE FoFA_32       ; loop if not at the max
.bec4					FoFA_42
.bec4	a4 71		ldy $71		   LDY TMPPTD        ; restore the output string index
.bec6					FoFA_44
.bec6	b9 ff 00	lda $00ff,y	   LDA STACK-1,Y     ; get character from output string
.bec9	88		dey		   DEY               ; decrement output string index
.beca	c9 30		cmp #$30	   CMP #'0'          ; compare with "0"
.becc	f0 f8		beq $bec6	   BEQ FoFA_44       ; loop until non "0" character found
.bece	c9 2e		cmp #$2e	   CMP #'.'          ; compare with "."
.bed0	f0 01		beq $bed3	   BEQ FoFA_46       ; branch if was dp
.bed2	c8		iny		   INY               ; increment output string index
.bed3					FoFA_46
.bed3	a9 2b		lda #$2b	   LDA #'+'          ; character "+"
.bed5	a6 5e		ldx $5e		   LDX TMPVA2        ; get exponent count
.bed7	f0 2e		beq $bf07	   BEQ FoFA_54       ; if zero go set null terminator and exit
.bed9	10 08		bpl $bee3	   BPL FoFA_48       ; branch if exponent count positive
.bedb	a9 00		lda #$00	   LDA #0
.bedd	38		sec		   SEC
.bede	e5 5e		sbc $5e		   SBC TMPVA2        ; subtract exponent count adjust (convert negative to positive)
.bee0	aa		tax		   TAX               ; copy exponent count to X
.bee1	a9 2d		lda #$2d	   LDA #'-'          ; character "-"
.bee3					FoFA_48
.bee3	99 01 01	sta $0101,y	   STA STACK+1,Y     ; save to output string
.bee6	a9 45		lda #$45	   LDA #'E'          ; character "E"
.bee8	99 00 01	sta $0100,y	   STA STACK,Y       ; save exponent sign to output string
.beeb	8a		txa		   TXA               ; get exponent count back
.beec	a2 2f		ldx #$2f	   LDX #$2F          ; one less than "0" character
.beee	38		sec		   SEC
.beef					FoFA_50
.beef	e8		inx		   INX               ; increment 10's character
.bef0	e9 0a		sbc #$0a	   SBC #$0A          ; subtract 10 from exponent count
.bef2	b0 fb		bcs $beef	   BCS FoFA_50       ; loop while still >= 0
.bef4	69 3a		adc #$3a	   ADC #':'          ; add character ":" ($30+$0A, result is 10 less that value)
.bef6	99 03 01	sta $0103,y	   STA STACK+3,Y     ; save to output string
.bef9	8a		txa		   TXA               ; copy 10's character
.befa	99 02 01	sta $0102,y	   STA STACK+2,Y     ; save to output string
.befd	a9 00		lda #$00	   LDA #$00          ; set null terminator
.beff	99 04 01	sta $0104,y	   STA STACK+4,Y     ; save to output string
.bf02	f0 08		beq $bf0c	   BEQ FoFA_56       ; go set string pointer (AY) and exit, branch always
.bf04					FoFA_52
.bf04	99 ff 00	sta $00ff,y	   STA STACK-1,Y     ; save last character to output string
.bf07					FoFA_54
.bf07	a9 00		lda #$00	   LDA #$00          ; set null terminator
.bf09	99 00 01	sta $0100,y	   STA STACK,Y       ; save after last character
.bf0c					FoFA_56
.bf0c	a9 00		lda #$00	   LDA #<STACK ;#<addr
.bf0e	a0 01		ldy #$01	   LDY #>STACK ;#>addr
.bf10	60		rts		   RTS
>bf11	80 00				Float_0_5       .byte $80,$00 ; 0.5 (including next 3 bytes)
>bf13	00 00 00			NULL_Descriptor .byte 0,0,0 ; null descriptor for undefined variables
.bf16					  Decimal_Conversion_Table
>bf16	fa 0a 1f 00			   .byte $FA,$0A,$1F,$00 ;.quad -100000000
>bf1a	00 98 96 80			   .byte $00,$98,$96,$80 ;.quad  +10000000
>bf1e	ff f0 bd c0			   .byte $FF,$F0,$BD,$C0 ;.quad   -1000000
>bf22	00 01 86 a0			   .byte $00,$01,$86,$A0 ;.quad    +100000
>bf26	ff ff d8 f0			   .byte $FF,$FF,$D8,$F0 ;.quad     -10000
>bf2a	00 00 03 e8			   .byte $00,$00,$03,$E8 ;.quad      +1000
>bf2e	ff ff ff 9c			   .byte $FF,$FF,$FF,$9C ;.quad       -100
>bf32	00 00 00 0a			   .byte $00,$00,$00,$0A ;.quad        +10
>bf36	ff ff ff ff			   .byte $FF,$FF,$FF,$FF ;.quad         -1
.bf3a					  Jiffy_Conversion_Table
>bf3a	ff df 0a 80			   .byte $FF,$DF,$0A,$80 ;.quad -2160000 ; 10s hours
>bf3e	00 03 4b c0			   .byte $00,$03,$4B,$C0 ;.quad  +216000 ;     hours
>bf42	ff ff 73 60			   .byte $FF,$FF,$73,$60 ;.quad   -36000 ; 10s mins
>bf46	00 00 0e 10			   .byte $00,$00,$0E,$10 ;.quad    +3600 ;     mins
>bf4a	ff ff fd a8			   .byte $FF,$FF,$FD,$A8 ;.quad     -600 ; 10s secs
>bf4e	00 00 00 3c			   .byte $00,$00,$00,$3C ;.quad      +60 ;     secs
.bf52					End_Of_Conversion
>bf52	ec				   .byte $EC
>bf53	aa aa aa aa aa aa aa aa		   .fill 30 ,$AA
>bf5b	aa aa aa aa aa aa aa aa aa aa aa aa aa aa aa aa
>bf6b	aa aa aa aa aa aa
.bf71					  Basic_SQR
.bf71	20 0c bc	jsr $bc0c	   JSR FAC1_Round_And_Copy_To_FAC2
.bf74	a9 11		lda #$11	   LDA #<Float_0_5 ;#<addr
.bf76	a0 bf		ldy #$bf	   LDY #>Float_0_5 ;#>addr
.bf78	20 a2 bb	jsr $bba2	   JSR Load_FAC1_AY
.bf7b					  Basic_POWER
.bf7b	f0 70		beq $bfed	   BEQ Basic_EXP     ; perform EXP()
.bf7d	a5 69		lda $69		   LDA FAC2EX        ; get FAC2 exponent
.bf7f	d0 03		bne $bf84	   BNE POW_10        ; branch if FAC2<>0
.bf81	4c f9 b8	jmp $b8f9	   JMP PLUS_40       ; clear FAC1 exponent and sign and return
.bf84					POW_10
.bf84	a2 4e		ldx #$4e	   LDX #<FUNCPT      ; set destination pointer low byte
.bf86	a0 00		ldy #$00	   LDY #>FUNCPT      ; set destination pointer high byte
.bf88	20 d4 bb	jsr $bbd4	   JSR Assign_FAC1_To_Var
.bf8b	a5 6e		lda $6e		   LDA FAC2SI        ; get FAC2 sign (b7)
.bf8d	10 0f		bpl $bf9e	   BPL POW_20        ; branch if FAC2>0
.bf8f	20 cc bc	jsr $bccc	   JSR Basic_INT     ; perform INT()
.bf92	a9 4e		lda #$4e	   LDA #<FUNCPT ;#<addr
.bf94	a0 00		ldy #$00	   LDY #>FUNCPT ;#>addr
.bf96	20 5b bc	jsr $bc5b	   JSR Compare_FAC1_AY
.bf99	d0 03		bne $bf9e	   BNE POW_20        ; branch if FAC1 <> (AY) to allow Function Call error
.bf9b	98		tya		   TYA               ; clear sign b7
.bf9c	a4 07		ldy $07		   LDY CHARAC        ; get FAC1 mantissa 4 from INT() function as sign in
.bf9e					POW_20
.bf9e	20 fe bb	jsr $bbfe	   JSR Copy_ABS_FAC2_To_FAC1
.bfa1	98		tya		   TYA               ; copy sign back ..
.bfa2	48		pha		   PHA               ; .. and save it
.bfa3	20 ea b9	jsr $b9ea	   JSR Basic_LOG     ; perform LOG()
.bfa6	a9 4e		lda #$4e	   LDA #<FUNCPT ;#<addr
.bfa8	a0 00		ldy #$00	   LDY #>FUNCPT ;#>addr
.bfaa	20 28 ba	jsr $ba28	   JSR Multiply_FAC1_With_AY
.bfad	20 ed bf	jsr $bfed	   JSR Basic_EXP     ; perform EXP()
.bfb0	68		pla		   PLA               ; pull sign from stack
.bfb1	4a		lsr a		   LSR A             ; b0 is to be tested
.bfb2	90 0a		bcc $bfbe	   BCC GREA_Ret      ; if no bit then exit
.bfb4					  Basic_GREATER
.bfb4	a5 61		lda $61		   LDA FAC1EX        ; get FAC1 exponent
.bfb6	f0 06		beq $bfbe	   BEQ GREA_Ret      ; exit if FAC1_e = $00
.bfb8	a5 66		lda $66		   LDA FAC1SI        ; get FAC1 sign (b7)
.bfba	49 ff		eor #$ff	   EOR #$FF          ; complement it
.bfbc	85 66		sta $66		   STA FAC1SI        ; save FAC1 sign (b7)
.bfbe					GREA_Ret
.bfbe	60		rts		   RTS
>bfbf	81 38 aa 3b 29			REV_LOG_2 .byte $81,$38,$AA,$3B,$29 ;.real 1.4426950408
.bfc4					VAR_EXP
>bfc4	07				   .byte   7         ; series count
>bfc5	71 34 58 3e 56			   .byte $71,$34,$58,$3E,$56 ;.real  2.1498763705E-5
>bfca	74 16 7e b3 1b			   .byte $74,$16,$7E,$B3,$1B ;.real  1.4352314041E-4
>bfcf	77 2f ee e3 85			   .byte $77,$2F,$EE,$E3,$85 ;.real  1.3422634825E-3
>bfd4	7a 1d 84 1c 2a			   .byte $7A,$1D,$84,$1C,$2A ;.real  9.6140170140E-3
>bfd9	7c 63 59 58 0a			   .byte $7C,$63,$59,$58,$0A ;.real  5.5505126870E-2
>bfde	7e 75 fd e7 c6			   .byte $7E,$75,$FD,$E7,$C6 ;.real  2.4022638465E-1
>bfe3	80 31 72 18 10			   .byte $80,$31,$72,$18,$10 ;.real  6.9314718640E-1
>bfe8	81 00 00 00 00			   .byte $81,$00,$00,$00,$00 ;.real  1.0
.bfed					  Basic_EXP
.bfed	a9 bf		lda #$bf	   LDA #<REV_LOG_2 ;#<addr
.bfef	a0 bf		ldy #$bf	   LDY #>REV_LOG_2 ;#>addr
.bff1	20 28 ba	jsr $ba28	   JSR Multiply_FAC1_With_AY
.bff4	a5 70		lda $70		   LDA FAC1M5        ; get FAC1 rounding byte
.bff6	69 50		adc #$50	   ADC #$50          ; +$50/$100
.bff8	90 03		bcc $bffd	   BCC EXP_10        ; skip rounding if no carry
.bffa	20 23 bc	jsr $bc23	   JSR Round_FAC1
.bffd					EXP_10
.bffd	4c 00 e0	jmp $e000	   JMP C64_Kernal_ROM
.e000					C64_Kernal_ROM
.e000	85 56		sta $56		   STA FAC2M5        ; save FAC2 rounding byte
.e002	20 0f bc	jsr $bc0f	   JSR FAC1_To_FAC2
.e005	a5 61		lda $61		   LDA FAC1EX        ; get FAC1 exponent
.e007	c9 88		cmp #$88	   CMP #$88          ; compare with EXP limit (256d)
.e009	90 03		bcc $e00e	   BCC EXP_30        ; branch if less
.e00b					EXP_20
.e00b	20 d4 ba	jsr $bad4	   JSR Check_Overflow
.e00e					EXP_30
.e00e	20 cc bc	jsr $bccc	   JSR Basic_INT     ; perform INT()
.e011	a5 07		lda $07		   LDA CHARAC        ; get mantissa 4 from INT()
.e013	18		clc		   CLC
.e014	69 81		adc #$81	   ADC #$81          ; normalise +1
.e016	f0 f3		beq $e00b	   BEQ EXP_20        ; if $00 result has overflowed so go handle it
.e018	38		sec		   SEC
.e019	e9 01		sbc #$01	   SBC #$01          ; exponent now correct
.e01b	48		pha		   PHA               ; save FAC2 exponent
.e01c	a2 05		ldx #$05	   LDX #$05          ; 4 bytes to do
.e01e					EXP_40
.e01e	b5 69		lda $69,x	   LDA FAC2EX,X      ; get FAC2,X
.e020	b4 61		ldy $61,x	   LDY FAC1EX,X      ; get FAC1,X
.e022	95 61		sta $61,x	   STA FAC1EX,X      ; save FAC1,X
.e024	94 69		sty $69,x	   STY FAC2EX,X      ; save FAC2,X
.e026	ca		dex		   DEX               ; decrement count/index
.e027	10 f5		bpl $e01e	   BPL EXP_40        ; loop if not all done
.e029	a5 56		lda $56		   LDA FAC2M5        ; get FAC2 rounding byte
.e02b	85 70		sta $70		   STA FAC1M5        ; save as FAC1 rounding byte
.e02d	20 53 b8	jsr $b853	   JSR Basic_MINUS   ; perform subtraction, FAC2 from FAC1
.e030	20 b4 bf	jsr $bfb4	   JSR Basic_GREATER ; do - FAC1
.e033	a9 c4		lda #$c4	   LDA #<VAR_EXP ;#<addr
.e035	a0 bf		ldy #$bf	   LDY #>VAR_EXP ;#>addr
.e037	20 59 e0	jsr $e059	   JSR Eval_Series_AY
.e03a	a9 00		lda #$00	   LDA #0
.e03c	85 6f		sta $6f		   STA STRPTR        ; clear sign compare (FAC1 EOR FAC2)
.e03e	68		pla		   PLA               ; pull the saved FAC2 exponent
.e03f	20 b9 ba	jsr $bab9	   JSR Check_FACs_A
.e042	60		rts		   RTS
.e043					  Square_And_Series_Eval
.e043	85 71		sta $71		   STA TMPPTD
.e045	84 72		sty $72		   STY TMPPTD+1
.e047	20 ca bb	jsr $bbca	   JSR FAC1_To_FACTPA
.e04a	a9 57		lda #$57	   LDA #<FACTPA      ; set pointer low byte (Y already $00)
.e04c	20 28 ba	jsr $ba28	   JSR Multiply_FAC1_With_AY
.e04f	20 5d e0	jsr $e05d	   JSR Eval_Series
.e052	a9 57		lda #$57	   LDA #<FACTPA ;#<addr
.e054	a0 00		ldy #$00	   LDY #>FACTPA ;#>addr
.e056	4c 28 ba	jmp $ba28	   JMP Multiply_FAC1_With_AY
.e059					  Eval_Series_AY
.e059	85 71		sta $71		   STA TMPPTD
.e05b	84 72		sty $72		   STY TMPPTD+1
.e05d					  Eval_Series
.e05d	20 c7 bb	jsr $bbc7	   JSR FAC1_To_FACTPB
.e060	b1 71		lda ($71),y	   LDA (TMPPTD),Y    ; get constants count
.e062	85 67		sta $67		   STA SGNFLG        ; save constants count
.e064	a4 71		ldy $71		   LDY TMPPTD        ; get count pointer low byte
.e066	c8		iny		   INY               ; increment it (now constants pointer)
.e067	98		tya		   TYA               ; copy it
.e068	d0 02		bne $e06c	   BNE EvSe_10       ; skip next if no overflow
.e06a	e6 72		inc $72		   INC TMPPTD+1      ; else increment high byte
.e06c					EvSe_10
.e06c	85 71		sta $71		   STA TMPPTD        ; save low byte
.e06e	a4 72		ldy $72		   LDY TMPPTD+1      ; get high byte
.e070					EvSe_20
.e070	20 28 ba	jsr $ba28	   JSR Multiply_FAC1_With_AY
.e073	a5 71		lda $71		   LDA TMPPTD
.e075	a4 72		ldy $72		   LDY TMPPTD+1
.e077	18		clc		   CLC
.e078	69 05		adc #$05	   ADC #$05          ; +5 to low pointer (5 bytes per constant)
.e07a	90 01		bcc $e07d	   BCC EvSe_30       ; skip next if no overflow
.e07c	c8		iny		   INY               ; increment high byte
.e07d					EvSe_30
.e07d	85 71		sta $71		   STA TMPPTD
.e07f	84 72		sty $72		   STY TMPPTD+1
.e081	20 67 b8	jsr $b867	   JSR Add_Var_AY_To_FAC1
.e084	a9 5c		lda #$5c	   LDA #<FACTPB ;#<addr
.e086	a0 00		ldy #$00	   LDY #>FACTPB ;#>addr
.e088	c6 67		dec $67		   DEC SGNFLG        ; decrement constants count
.e08a	d0 e4		bne $e070	   BNE EvSe_20       ; loop until all done
.e08c	60		rts		   RTS
>e08d	98 35 44 7a 00			RND_VA .byte $98,$35,$44,$7A,$00 ;.real 11879546
>e092	68 28 b1 46 00			RND_VB .byte $68,$28,$B1,$46,$00 ;.real 3.927677739E-8
.e097					  Basic_RND
.e097	20 2b bc	jsr $bc2b	   JSR Get_FAC1_Sign
.e09a	30 37		bmi $e0d3	   BMI RND_20        ; if      n<0 copy byte swapped FAC1 into RND() seed
.e09c	d0 20		bne $e0be	   BNE RND_10        ; else if n>0 get next number in RND() sequence
.e09e	20 f3 ff	jsr $fff3	   JSR IOBASE        ; else    n=0 so get the RND() from VIA 1 timers
.e0a1	86 22		stx $22		   STX INDEXA
.e0a3	84 23		sty $23		   STY INDEXA+1
.e0a5	a0 04		ldy #$04	   LDY #$04          ; set index to T1 low byte
.e0a7	b1 22		lda ($22),y	   LDA (INDEXA),Y    ; get T1 low byte
.e0a9	85 62		sta $62		   STA FAC1M1        ; save FAC1 mantissa 1
.e0ab	c8		iny		   INY
.e0ac	b1 22		lda ($22),y	   LDA (INDEXA),Y    ; get T1 high byte
.e0ae	85 64		sta $64		   STA FAC1M3        ; save FAC1 mantissa 3
.e0b0	a0 08		ldy #$08	   LDY #$08          ; set index to T2 low byte
.e0b2	b1 22		lda ($22),y	   LDA (INDEXA),Y    ; get T2 low byte
.e0b4	85 63		sta $63		   STA FAC1M2        ; save FAC1 mantissa 2
.e0b6	c8		iny		   INY
.e0b7	b1 22		lda ($22),y	   LDA (INDEXA),Y    ; get T2 high byte
.e0b9	85 65		sta $65		   STA FAC1M4        ; save FAC1 mantissa 4
.e0bb	4c e3 e0	jmp $e0e3	   JMP RND_30        ; set exponent and exit
.e0be					RND_10
.e0be	a9 8b		lda #$8b	   LDA #<RNDX ;#<addr
.e0c0	a0 00		ldy #$00	   LDY #>RNDX ;#>addr
.e0c2	20 a2 bb	jsr $bba2	   JSR Load_FAC1_AY
.e0c5	a9 8d		lda #$8d	   LDA #<RND_VA ;#<addr
.e0c7	a0 e0		ldy #$e0	   LDY #>RND_VA ;#>addr
.e0c9	20 28 ba	jsr $ba28	   JSR Multiply_FAC1_With_AY
.e0cc	a9 92		lda #$92	   LDA #<RND_VB ;#<addr
.e0ce	a0 e0		ldy #$e0	   LDY #>RND_VB ;#>addr
.e0d0	20 67 b8	jsr $b867	   JSR Add_Var_AY_To_FAC1
.e0d3					RND_20
.e0d3	a6 65		ldx $65		   LDX FAC1M4        ; get FAC1 mantissa 4
.e0d5	a5 62		lda $62		   LDA FAC1M1        ; get FAC1 mantissa 1
.e0d7	85 65		sta $65		   STA FAC1M4        ; save FAC1 mantissa 4
.e0d9	86 62		stx $62		   STX FAC1M1        ; save FAC1 mantissa 1
.e0db	a6 63		ldx $63		   LDX FAC1M2        ; get FAC1 mantissa 2
.e0dd	a5 64		lda $64		   LDA FAC1M3        ; get FAC1 mantissa 3
.e0df	85 63		sta $63		   STA FAC1M2        ; save FAC1 mantissa 2
.e0e1	86 64		stx $64		   STX FAC1M3        ; save FAC1 mantissa 3
.e0e3					RND_30
.e0e3	a9 00		lda #$00	   LDA #0
.e0e5	85 66		sta $66		   STA FAC1SI        ; clear FAC1 sign (always positive)
.e0e7	a5 61		lda $61		   LDA FAC1EX        ; get FAC1 exponent
.e0e9	85 70		sta $70		   STA FAC1M5        ; save FAC1 rounding byte
.e0eb	a9 80		lda #$80	   LDA #$80          ; set exponent = $80
.e0ed	85 61		sta $61		   STA FAC1EX        ; save FAC1 exponent
.e0ef	20 d7 b8	jsr $b8d7	   JSR Normalise_FAC1
.e0f2	a2 8b		ldx #$8b	   LDX #<RNDX        ; set seed pointer low address
.e0f4	a0 00		ldy #$00	   LDY #>RNDX        ; set seed pointer high address
.e0f6					  Go_Assign_FAC1_To_Var
.e0f6	4c d4 bb	jmp $bbd4	   JMP Assign_FAC1_To_Var
.e0f9					  Error_Handler
.e0f9	c9 f0		cmp #$f0	   CMP #$F0          ; compare error with $F0
.e0fb	d0 07		bne $e104	   BNE ErHa_10       ; branch if not $F0
.e0fd	84 38		sty $38		   STY MEMSIZ+1      ; set end of memory high byte
.e0ff	86 37		stx $37		   STX MEMSIZ        ; set end of memory low byte
.e101	4c 63 a6	jmp $a663	   JMP Reset_Variable_Pointer
.e104					ErHa_10
.e104	aa		tax		   TAX               ; copy error #
.e105	d0 02		bne $e109	   BNE ErHa_20       ; branch if not $00
.e107	a2 1e		ldx #$1e	   LDX #$1E          ; else error $1E, break error
.e109					ErHa_20
.e109	4c 37 a4	jmp $a437	   JMP Basic_Error
.e10c					  CHROUT_Checked
.e10c	20 d2 ff	jsr $ffd2	   JSR CHROUT        ; Output a character
.e10f	b0 e8		bcs $e0f9	   BCS Error_Handler
.e111	60		rts		   RTS
.e112					  Read_Char
.e112	20 cf ff	jsr $ffcf	   JSR CHRIN
.e115	b0 e2		bcs $e0f9	   BCS Error_Handler
.e117	60		rts		   RTS
.e118					  Select_Output_Channel
.e118	20 ad e4	jsr $e4ad	   JSR CHKOUT_Checked
.e11b	b0 dc		bcs $e0f9	   BCS Error_Handler
.e11d	60		rts		   RTS
.e11e					  CHKIN_Checked
.e11e	20 c6 ff	jsr $ffc6	   JSR CHKIN         ; open channel for input
.e121	b0 d6		bcs $e0f9	   BCS Error_Handler
.e123	60		rts		   RTS
.e124					  GETIN_Checked
.e124	20 e4 ff	jsr $ffe4	   JSR GETIN         ; get character from input device
.e127	b0 d0		bcs $e0f9	   BCS Error_Handler
.e129	60		rts		   RTS
.e12a					  Basic_SYS
.e12a	20 8a ad	jsr $ad8a	   JSR Eval_Numeric
.e12d	20 f7 b7	jsr $b7f7	   JSR FAC1_To_LINNUM
.e130	a9 e1		lda #$e1	   LDA #>SYS_Ret-1   ; get return address high byte
.e132	48		pha		   PHA               ; push as return address
.e133	a9 46		lda #$46	   LDA #<SYS_Ret-1   ; get return address low byte
.e135	48		pha		   PHA               ; push as return address
.e136	ad 0f 03	lda $030f	   LDA SPREG         ; get saved status register
.e139	48		pha		   PHA               ; put on stack
.e13a	ad 0c 03	lda $030c	   LDA SAREG         ; get saved A
.e13d	ae 0d 03	ldx $030d	   LDX SXREG         ; get saved X
.e140	ac 0e 03	ldy $030e	   LDY SYREG         ; get saved Y
.e143	28		plp		   PLP               ; pull processor status
.e144	6c 14 00	jmp ($0014)	   JMP (LINNUM)      ; call SYS address
.e147					  SYS_Ret
.e147	08		php		   PHP               ; save status
.e148	8d 0c 03	sta $030c	   STA SAREG         ; save returned A
.e14b	8e 0d 03	stx $030d	   STX SXREG         ; save returned X
.e14e	8c 0e 03	sty $030e	   STY SYREG         ; save returned Y
.e151	68		pla		   PLA               ; restore saved status
.e152	8d 0f 03	sta $030f	   STA SPREG         ; save status
.e155	60		rts		   RTS
.e156					  Basic_SAVE
.e156	20 d4 e1	jsr $e1d4	   JSR Get_Load_Save_Params
.e159					Jiffy_SAVE
.e159	a6 2d		ldx $2d		   LDX VARTAB
.e15b	a4 2e		ldy $2e		   LDY VARTAB+1
.e15d	a9 2b		lda #$2b	   LDA #TXTTAB       ; index to start of program memory
.e15f	20 d8 ff	jsr $ffd8	   JSR SAVE          ; save RAM to device, A = index to start address, XY = end
.e162	b0 95		bcs $e0f9	   BCS Error_Handler
.e164	60		rts		   RTS
.e165					  Basic_VERIFY
.e165	a9 01		lda #$01	   LDA #1            ; flag verify
>e167	2c				   .byte   $2C       ; skip next statement
.e168					  Basic_LOAD
.e168	a9 00		lda #$00	   LDA #0            ; flag load
.e16a	85 0a		sta $0a		   STA VERCK         ; set load/verify flag
.e16c	20 d4 e1	jsr $e1d4	   JSR Get_Load_Save_Params
.e16f	a5 0a		lda $0a		   LDA VERCK         ; get load/verify flag
.e171	a6 2b		ldx $2b		   LDX TXTTAB
.e173	a4 2c		ldy $2c		   LDY TXTTAB+1
.e175	20 d5 ff	jsr $ffd5	   JSR LOAD          ; load RAM from a device
.e178	b0 57		bcs $e1d1	   BCS Jump_Error_Handler
.e17a	a5 0a		lda $0a		   LDA VERCK         ; get load/verify flag
.e17c	f0 17		beq $e195	   BEQ LOAD_30       ; branch if load
.e17e					LOAD_05
.e17e	a2 1c		ldx #$1c	   LDX #$1C          ; error $1C, verify error
.e180	20 b7 ff	jsr $ffb7	   JSR READST        ; read I/O status word
.e183	29 10		and #$10	   AND #$10          ; mask for tape read error
.e185	d0 17		bne $e19e	   BNE LOAD_40       ; branch if read error
.e187					LOAD_10
.e187	a5 7a		lda $7a		   LDA TXTPTR        ; get BASIC execute pointer low byte
.e189	c9 02		cmp #$02	   CMP #2            ; BUG! should be LDA TXTPTR+1:CMP #>BUF:BNE LOAD20
.e18b	f0 07		beq $e194	   BEQ LOAD_20
.e18d	a9 64		lda #$64	   LDA #<Msg_OK ;#<addr
.e18f	a0 a3		ldy #$a3	   LDY #>Msg_OK ;#>addr
.e191	4c 1e ab	jmp $ab1e	   JMP Print_String
.e194					LOAD_20
.e194	60		rts		   RTS
.e195					LOAD_30
.e195	20 b7 ff	jsr $ffb7	   JSR READST        ; read I/O status word
.e198	29 bf		and #$bf	   AND #$BF          ; mask x0xx xxxx, clear read error
.e19a	f0 05		beq $e1a1	   BEQ LOAD_50       ; branch if no errors
.e19c	a2 1d		ldx #$1d	   LDX #$1D          ; error $1D, load error
.e19e					LOAD_40
.e19e	4c 37 a4	jmp $a437	   JMP Basic_Error
.e1a1					LOAD_50
.e1a1	a5 7b		lda $7b		   LDA TXTPTR+1      ; get BASIC execute pointer high byte
.e1a3	c9 02		cmp #$02	   CMP #>BUF
.e1a5	d0 0e		bne $e1b5	   BNE LOAD_60       ; branch if not direct mode
.e1a7					LOAD_55
.e1a7	86 2d		stx $2d		   STX VARTAB
.e1a9	84 2e		sty $2e		   STY VARTAB+1
.e1ab	a9 76		lda #$76	   LDA #<Msg_Ready
.e1ad	a0 a3		ldy #$a3	   LDY #>Msg_Ready
.e1af	20 1e ab	jsr $ab1e	   JSR Print_String
.e1b2	4c 2a a5	jmp $a52a	   JMP Reset_And_Rechain
.e1b5					LOAD_60
.e1b5	20 8e a6	jsr $a68e	   JSR Reset_BASIC_Exec_Pointer
.e1b8	20 33 a5	jsr $a533	   JSR Rechain
.e1bb	4c 77 a6	jmp $a677	   JMP Restore_And_Flush_Stack      ; do RESTORE, clear stack and return
.e1be					  Basic_OPEN
.e1be	20 19 e2	jsr $e219	   JSR Get_Open_Close_Params
.e1c1	20 c0 ff	jsr $ffc0	   JSR OPEN          ; open a logical file
.e1c4	b0 0b		bcs $e1d1	   BCS Jump_Error_Handler      ; branch if error
.e1c6	60		rts		   RTS
.e1c7					  Basic_CLOSE
.e1c7	20 19 e2	jsr $e219	   JSR Get_Open_Close_Params
.e1ca	a5 49		lda $49		   LDA FORPNT        ; get logical file number
.e1cc	20 c3 ff	jsr $ffc3	   JSR CLOSE         ; close a specified logical file
.e1cf	90 c3		bcc $e194	   BCC LOAD_20      ; exit if no error
.e1d1					Jump_Error_Handler
.e1d1	4c f9 e0	jmp $e0f9	   JMP Error_Handler
.e1d4					  Get_Load_Save_Params
.e1d4	a9 00		lda #$00	   LDA #$00          ; clear file name length
.e1d6	20 bd ff	jsr $ffbd	   JSR SETNAM        ; clear filename
.e1d9	a2 01		ldx #$01	   LDX #$01          ; set default device number, cassette
.e1db	a0 00		ldy #$00	   LDY #$00          ; set default command
.e1dd	20 ba ff	jsr $ffba	   JSR SETLFS        ; set logical, first and second addresses
.e1e0	20 06 e2	jsr $e206	   JSR Exit_On_EOS
.e1e3	20 57 e2	jsr $e257	   JSR Set_Filename
.e1e6	20 06 e2	jsr $e206	   JSR Exit_On_EOS
.e1e9	20 00 e2	jsr $e200	   JSR Get_Byte_Param
.e1ec	a0 00		ldy #$00	   LDY #$00          ; clear command
.e1ee	86 49		stx $49		   STX FORPNT        ; save device number
.e1f0	20 ba ff	jsr $ffba	   JSR SETLFS        ; set logical, first and second addresses
.e1f3	20 06 e2	jsr $e206	   JSR Exit_On_EOS
.e1f6	20 00 e2	jsr $e200	   JSR Get_Byte_Param
.e1f9	8a		txa		   TXA               ; copy command to A
.e1fa	a8		tay		   TAY               ; copy command to Y
.e1fb	a6 49		ldx $49		   LDX FORPNT        ; get device number back
.e1fd	4c ba ff	jmp $ffba	   JMP SETLFS        ; set logical, first and second addresses and return
.e200					  Get_Byte_Param
.e200	20 0e e2	jsr $e20e	   JSR Read_Comma_And_Byte
.e203	4c 9e b7	jmp $b79e	   JMP Get_Byte_Value
.e206					  Exit_On_EOS
.e206	20 79 00	jsr $0079	   JSR CHRGOT
.e209	d0 02		bne $e20d	   BNE EOE_Ret       ; branch if not [EOL] or ":"
.e20b	68		pla		   PLA               ; dump return address low byte
.e20c	68		pla		   PLA               ; dump return address high byte
.e20d					EOE_Ret
.e20d	60		rts		   RTS
.e20e					  Read_Comma_And_Byte
.e20e	20 fd ae	jsr $aefd	   JSR Need_Comma
.e211					  Need_Byte
.e211	20 79 00	jsr $0079	   JSR CHRGOT
.e214	d0 f7		bne $e20d	   BNE EOE_Ret      ; exit if following byte
.e216	4c 08 af	jmp $af08	   JMP Syntax_Error
.e219					  Get_Open_Close_Params
.e219	a9 00		lda #$00	   LDA #$00          ; clear file name length
.e21b	20 bd ff	jsr $ffbd	   JSR SETNAM        ; clear filename
.e21e	20 11 e2	jsr $e211	   JSR Need_Byte
.e221	20 9e b7	jsr $b79e	   JSR Get_Byte_Value
.e224	86 49		stx $49		   STX FORPNT        ; save logical file number
.e226	8a		txa		   TXA               ; copy logical file number to A
.e227	a2 01		ldx #$01	   LDX #$01          ; set default device number, cassette
.e229					GOCP_05
.e229	a0 00		ldy #$00	   LDY #$00          ; set default command
.e22b	20 ba ff	jsr $ffba	   JSR SETLFS        ; set logical, first and second addresses
.e22e	20 06 e2	jsr $e206	   JSR Exit_On_EOS
.e231	20 00 e2	jsr $e200	   JSR Get_Byte_Param
.e234	86 4a		stx $4a		   STX FORPNT+1      ; save device number
.e236	a0 00		ldy #$00	   LDY #$00          ; clear command
.e238	a5 49		lda $49		   LDA FORPNT        ; get logical file number
.e23a	e0 03		cpx #$03	   CPX #$03          ; compare device number with screen
.e23c	90 01		bcc $e23f	   BCC GOCP_10       ; branch if less than screen
.e23e	88		dey		   DEY               ; else decrement command
.e23f					GOCP_10
.e23f	20 ba ff	jsr $ffba	   JSR SETLFS        ; set logical, first and second addresses
.e242	20 06 e2	jsr $e206	   JSR Exit_On_EOS
.e245	20 00 e2	jsr $e200	   JSR Get_Byte_Param
.e248	8a		txa		   TXA               ; copy command to A
.e249	a8		tay		   TAY               ; copy command to Y
.e24a	a6 4a		ldx $4a		   LDX FORPNT+1      ; get device number
.e24c	a5 49		lda $49		   LDA FORPNT        ; get logical file number
.e24e	20 ba ff	jsr $ffba	   JSR SETLFS        ; set logical, first and second addresses
.e251	20 06 e2	jsr $e206	   JSR Exit_On_EOS
.e254	20 0e e2	jsr $e20e	   JSR Read_Comma_And_Byte
.e257					  Set_Filename
.e257	20 9e ad	jsr $ad9e	   JSR Eval_Expression
.e25a					Set_Filename_From_String
.e25a	20 a3 b6	jsr $b6a3	   JSR Eval_String
.e25d	a6 22		ldx $22		   LDX INDEXA        ; get string pointer low byte
.e25f	a4 23		ldy $23		   LDY INDEXA+1      ; get string pointer high byte
.e261	4c bd ff	jmp $ffbd	   JMP SETNAM        ; set filename and return
.e264					  Basic_COS
.e264	a9 e0		lda #$e0	   LDA #<PI_Half ;#<addr
.e266	a0 e2		ldy #$e2	   LDY #>PI_Half ;#>addr
.e268	20 67 b8	jsr $b867	   JSR Add_Var_AY_To_FAC1
.e26b					  Basic_SIN
.e26b	20 0c bc	jsr $bc0c	   JSR FAC1_Round_And_Copy_To_FAC2
.e26e	a9 e5		lda #$e5	   LDA #<Two_PI ;#<addr
.e270	a0 e2		ldy #$e2	   LDY #>Two_PI ;#>addr
.e272	a6 6e		ldx $6e		   LDX FAC2SI        ; get FAC2 sign (b7)
.e274	20 07 bb	jsr $bb07	   JSR Divide_FAC2_By_AY
.e277	20 0c bc	jsr $bc0c	   JSR FAC1_Round_And_Copy_To_FAC2
.e27a	20 cc bc	jsr $bccc	   JSR Basic_INT
.e27d	a9 00		lda #$00	   LDA #0
.e27f	85 6f		sta $6f		   STA STRPTR        ; clear sign compare (FAC1 EOR FAC2)
.e281	20 53 b8	jsr $b853	   JSR Basic_MINUS   ; perform subtraction, FAC2 from FAC1
.e284	a9 ea		lda #$ea	   LDA #<Float_0_25 ;#<addr
.e286	a0 e2		ldy #$e2	   LDY #>Float_0_25 ;#>addr
.e288	20 50 b8	jsr $b850	   JSR AY_Minus_FAC1
.e28b	a5 66		lda $66		   LDA FAC1SI        ; get FAC1 sign (b7)
.e28d	48		pha		   PHA               ; save FAC1 sign
.e28e	10 0d		bpl $e29d	   BPL SIN_10        ; branch if positive
.e290	20 49 b8	jsr $b849	   JSR Add_0_5_To_FAC1
.e293	a5 66		lda $66		   LDA FAC1SI        ; get FAC1 sign (b7)
.e295	30 09		bmi $e2a0	   BMI SIN_20        ; branch if negative
.e297	a5 12		lda $12		   LDA TANSGN        ; get the comparison evaluation flag
.e299	49 ff		eor #$ff	   EOR #$FF          ; toggle flag
.e29b	85 12		sta $12		   STA TANSGN        ; save the comparison evaluation flag
.e29d					SIN_10
.e29d	20 b4 bf	jsr $bfb4	   JSR Basic_GREATER ; do - FAC1
.e2a0					SIN_20
.e2a0	a9 ea		lda #$ea	   LDA #<Float_0_25 ;#<addr
.e2a2	a0 e2		ldy #$e2	   LDY #>Float_0_25 ;#>addr
.e2a4	20 67 b8	jsr $b867	   JSR Add_Var_AY_To_FAC1
.e2a7	68		pla		   PLA               ; restore FAC1 sign
.e2a8	10 03		bpl $e2ad	   BPL SIN_30        ; branch if was positive
.e2aa	20 b4 bf	jsr $bfb4	   JSR Basic_GREATER ; do - FAC1
.e2ad					SIN_30
.e2ad	a9 ef		lda #$ef	   LDA #<VAR_SIN ;#<addr
.e2af	a0 e2		ldy #$e2	   LDY #>VAR_SIN ;#>addr
.e2b1	4c 43 e0	jmp $e043	   JMP Square_And_Series_Eval
.e2b4					  Basic_TAN
.e2b4	20 ca bb	jsr $bbca	   JSR FAC1_To_FACTPA
.e2b7	a9 00		lda #$00	   LDA #0
.e2b9	85 12		sta $12		   STA TANSGN        ; clear the comparison evaluation flag
.e2bb	20 6b e2	jsr $e26b	   JSR Basic_SIN     ; perform SIN()
.e2be	a2 4e		ldx #$4e	   LDX #<FUNCPT      ; set sin(n) pointer low byte
.e2c0	a0 00		ldy #$00	   LDY #>FUNCPT      ; set sin(n) pointer high byte
.e2c2	20 f6 e0	jsr $e0f6	   JSR Go_Assign_FAC1_To_Var
.e2c5	a9 57		lda #$57	   LDA #<FACTPA ;#<addr
.e2c7	a0 00		ldy #$00	   LDY #>FACTPA ;#>addr
.e2c9	20 a2 bb	jsr $bba2	   JSR Load_FAC1_AY
.e2cc	a9 00		lda #$00	   LDA #0
.e2ce	85 66		sta $66		   STA FAC1SI        ; clear FAC1 sign (b7)
.e2d0	a5 12		lda $12		   LDA TANSGN        ; get the comparison evaluation flag
.e2d2	20 dc e2	jsr $e2dc	   JSR TAN_10
.e2d5	a9 4e		lda #$4e	   LDA #<FUNCPT ;#<addr
.e2d7	a0 00		ldy #$00	   LDY #>FUNCPT ;#>addr
.e2d9	4c 0f bb	jmp $bb0f	   JMP AY_Divided_By_FAC1
.e2dc					  TAN_10
.e2dc	48		pha		   PHA               ; save comparison flag
.e2dd	4c 9d e2	jmp $e29d	   JMP SIN_10      ; add 0.25, ^2 then series evaluation
>e2e0	81 49 0f da a2			PI_Half    .byte $81,$49,$0F,$DA,$A2 ;.real 1.5707963271
>e2e5	83 49 0f da a2			Two_PI     .byte $83,$49,$0F,$DA,$A2 ;.real 6.283185307
>e2ea	7f 00 00 00 00			Float_0_25 .byte $7F,$00,$00,$00,$00 ;.real 0.25
.e2ef					VAR_SIN
>e2ef	05				   .byte   $05       ; series counter
>e2f0	84 e6 1a 2d 1b			   .byte $84,$E6,$1A,$2D,$1B ;.real -14.381390673
>e2f5	86 28 07 fb f8			   .byte $86,$28,$07,$FB,$F8 ;.real  42.00779713
>e2fa	87 99 68 89 01			   .byte $87,$99,$68,$89,$01 ;.real -76.70417028
>e2ff	87 23 35 df e1			   .byte $87,$23,$35,$DF,$E1 ;.real  81.60522370
>e304	86 a5 5d e7 28			   .byte $86,$A5,$5D,$E7,$28 ;.real -41.34170211
>e309	83 49 0f da a2			   .byte $83,$49,$0F,$DA,$A2 ;.real   6.283185308
.e30e					  Basic_ATN
.e30e	a5 66		lda $66		   LDA FAC1SI        ; get FAC1 sign (b7)
.e310	48		pha		   PHA               ; save sign
.e311	10 03		bpl $e316	   BPL ATN_10        ; branch if positive
.e313	20 b4 bf	jsr $bfb4	   JSR Basic_GREATER ; else do - FAC1
.e316					ATN_10
.e316	a5 61		lda $61		   LDA FAC1EX        ; get FAC1 exponent
.e318	48		pha		   PHA               ; push exponent
.e319	c9 81		cmp #$81	   CMP #$81          ; compare with 1
.e31b	90 07		bcc $e324	   BCC ATN_20        ; branch if FAC1 < 1
.e31d	a9 bc		lda #$bc	   LDA #<REAL_1 ;#<addr
.e31f	a0 b9		ldy #$b9	   LDY #>REAL_1 ;#>addr
.e321	20 0f bb	jsr $bb0f	   JSR AY_Divided_By_FAC1
.e324					ATN_20
.e324	a9 3e		lda #$3e	   LDA #<VAR_ATN ;#<addr
.e326	a0 e3		ldy #$e3	   LDY #>VAR_ATN ;#>addr
.e328	20 43 e0	jsr $e043	   JSR Square_And_Series_Eval
.e32b	68		pla		   PLA               ; restore old FAC1 exponent
.e32c	c9 81		cmp #$81	   CMP #$81          ; compare with 1
.e32e	90 07		bcc $e337	   BCC ATN_30        ; branch if FAC1 < 1
.e330	a9 e0		lda #$e0	   LDA #<PI_Half ;#<addr
.e332	a0 e2		ldy #$e2	   LDY #>PI_Half ;#>addr
.e334	20 50 b8	jsr $b850	   JSR AY_Minus_FAC1
.e337					ATN_30
.e337	68		pla		   PLA               ; restore FAC1 sign
.e338	10 03		bpl $e33d	   BPL ATN_Ret       ; exit if was positive
.e33a	4c b4 bf	jmp $bfb4	   JMP Basic_GREATER ; else do - FAC1 and return
.e33d					ATN_Ret
.e33d	60		rts		   RTS
.e33e					VAR_ATN
>e33e	0b				   .byte 11        ; series counter
>e33f	76 b3 83 bd d3			   .byte $76,$B3,$83,$BD,$D3 ;.real -6.8479391200E-4
>e344	79 1e f4 a6 f5			   .byte $79,$1E,$F4,$A6,$F5 ;.real  4.8509421570E-3
>e349	7b 83 fc b0 10			   .byte $7B,$83,$FC,$B0,$10 ;.real -1.6111701850E-2
>e34e	7c 0c 1f 67 ca			   .byte $7C,$0C,$1F,$67,$CA ;.real  3.4209638050E-2
>e353	7c de 53 cb c1			   .byte $7C,$DE,$53,$CB,$C1 ;.real -5.4279132770E-2
>e358	7d 14 64 70 4c			   .byte $7D,$14,$64,$70,$4C ;.real  7.2457196550E-2
>e35d	7d b7 ea 51 7a			   .byte $7D,$B7,$EA,$51,$7A ;.real -8.9802395400E-2
>e362	7d 63 30 88 7e			   .byte $7D,$63,$30,$88,$7E ;.real  1.1093241345E-1
>e367	7e 92 44 99 3a			   .byte $7E,$92,$44,$99,$3A ;.real -0.1428398077
>e36c	7e 4c cc 91 c7			   .byte $7E,$4C,$CC,$91,$C7 ;.real  0.1999991205
>e371	7f aa aa aa 13			   .byte $7F,$AA,$AA,$AA,$13 ;.real -0.3333333157
>e376	81 00 00 00 00			   .byte $81,$00,$00,$00,$00 ;.real  1.0
.e37b					Basic_Warm_Start
.e37b	20 cc ff	jsr $ffcc	   JSR CLRCHN        ; Clear I/O channels
.e37e	a9 00		lda #$00	   LDA #0
.e380	85 13		sta $13		   STA IOPMPT        ; set current I/O channel, flag default
.e382	20 7a a6	jsr $a67a	   JSR Flush_BASIC_Stack
.e385	58		cli		   CLI               ; enable interrupts
.e386					Vectored_Basic_Ready
.e386	a2 80		ldx #$80	   LDX #$80
.e388	6c 00 03	jmp ($0300)	   JMP (IERROR)      ; normally next statement
.e38b					Back_To_Prompt
.e38b	8a		txa		   TXA
.e38c	30 03		bmi $e391	   BMI Jump_READY
.e38e	4c 3a a4	jmp $a43a	   JMP Default_Error      ; print error message
.e391					Jump_READY
.e391	4c 74 a4	jmp $a474	   JMP Basic_Ready
.e394					Basic_Cold_Start
.e394	20 53 e4	jsr $e453	   JSR Init_BASIC_Jump_Vectors
.e397	20 bf e3	jsr $e3bf	   JSR Init_BASIC_RAM_Vectors
.e39a	20 22 e4	jsr $e422	   JSR Print_Startup_Message
.e39d	a2 fb		ldx #$fb	   LDX #$FB          ; value for start stack
.e39f	9a		txs		   TXS               ; set stack pointer
.e3a0	d0 e4		bne $e386	   BNE Vectored_Basic_Ready        ; branch always
.e3a2					  CHRGET_ROM
.e3a2	e6 7a		inc $7a		   INC TXTPTR        ; increment BASIC execute pointer low byte
.e3a4	d0 02		bne $e3a8	   BNE CHRO_10       ; branch if no carry
.e3a6	e6 7b		inc $7b		   INC TXTPTR+1      ; increment BASIC execute pointer high byte
.e3a8					CHRO_10
.e3a8	ad 60 ea	lda $ea60	   LDA $EA60         ; get byte to scan, address set by call routine
.e3ab	c9 3a		cmp #$3a	   CMP #':'          ; compare with ":"
.e3ad	b0 0a		bcs $e3b9	   BCS CHRO_Ret      ; exit if>=
.e3af	c9 20		cmp #$20	   CMP #' '          ; compare with " "
.e3b1	f0 ef		beq $e3a2	   BEQ CHRGET_ROM    ; if " " go do next
.e3b3	38		sec		   SEC               ; set carry for SBC
.e3b4	e9 30		sbc #$30	   SBC #'0'          ; subtract "0"
.e3b6	38		sec		   SEC               ; set carry for SBC
.e3b7	e9 d0		sbc #$d0	   SBC #$D0          ; subtract -"0"
.e3b9					CHRO_Ret
.e3b9	60		rts		   RTS
>e3ba	80 4f c7 52 58			   .byte   $80,$4F,$C7,$52,$58 ; 0.811635157
.e3bf					  Init_BASIC_RAM_Vectors
.e3bf	a9 4c		lda #$4c	   LDA #$4C          ; opcode for JMP
.e3c1	85 54		sta $54		   STA JUMPER        ; save for functions vector jump
.e3c3	8d 10 03	sta $0310	   STA Basic_USR
.e3c6	a9 48		lda #$48	   LDA #<Illegal_Quantity ;#<addr
.e3c8	a0 b2		ldy #$b2	   LDY #>Illegal_Quantity ;#>addr
.e3ca	8d 11 03	sta $0311	   STA USRVEC
.e3cd	8c 12 03	sty $0312	   STY USRVEC+1
.e3d0	a9 91		lda #$91	   LDA #<Integer_To_Float ;#<addr
.e3d2	a0 b3		ldy #$b3	   LDY #>Integer_To_Float ;#>addr
.e3d4	85 05		sta $05		   STA ADRAY2
.e3d6	84 06		sty $06		   STY ADRAY2+1
.e3d8	a9 aa		lda #$aa	   LDA #<Float_To_Integer ;#<addr
.e3da	a0 b1		ldy #$b1	   LDY #>Float_To_Integer ;#>addr
.e3dc	85 03		sta $03		   STA ADRAY1
.e3de	84 04		sty $04		   STY ADRAY1+1
.e3e0	a2 1c		ldx #$1c	   LDX #$1C          ; set byte count
.e3e2					IBRV_10
.e3e2	bd a2 e3	lda $e3a2,x	   LDA CHRGET_ROM,X  ; get byte from table
.e3e5	95 73		sta $73,x	   STA CHRGET,X      ; save byte in page zero
.e3e7	ca		dex		   DEX               ; decrement count
.e3e8	10 f8		bpl $e3e2	   BPL IBRV_10       ; loop if not all done
.e3ea	a9 03		lda #$03	   LDA #$03          ; set step size, collecting descriptors
.e3ec	85 53		sta $53		   STA GARBSS        ; save garbage collection step size
.e3ee	a9 00		lda #$00	   LDA #0
.e3f0	85 68		sta $68		   STA FAC1OV        ; clear FAC1 overflow byte
.e3f2	85 13		sta $13		   STA IOPMPT        ; clear current I/O channel, flag default
.e3f4	85 18		sta $18		   STA LASTPT+1      ; clear current descriptor stack item pointer high byte
.e3f6	a2 01		ldx #$01	   LDX #$01          ; set X
.e3f8	8e fd 01	stx $01fd	   STX BUF-3         ; set chain link pointer low byte
.e3fb	8e fc 01	stx $01fc	   STX BUF-4         ; set chain link pointer high byte
.e3fe	a2 19		ldx #$19	   LDX #TEMPST       ; initial value for descriptor stack
.e400	86 16		stx $16		   STX TEMPPT        ; set descriptor stack pointer
.e402	38		sec		   SEC               ; set Cb = 1 to read the bottom of memory
.e403	20 9c ff	jsr $ff9c	   JSR MEMBOT        ; read/set the bottom of memory
.e406	86 2b		stx $2b		   STX TXTTAB
.e408	84 2c		sty $2c		   STY TXTTAB+1
.e40a	38		sec		   SEC               ; set Cb = 1 to read the top of memory
.e40b	20 99 ff	jsr $ff99	   JSR MEMTOP        ; read/set the top of memory
.e40e	86 37		stx $37		   STX MEMSIZ
.e410	84 38		sty $38		   STY MEMSIZ+1
.e412	86 33		stx $33		   STX FRESPC
.e414	84 34		sty $34		   STY FRESPC+1
.e416	a0 00		ldy #$00	   LDY #0
.e418	98		tya		   TYA               ; clear A
.e419	91 2b		sta ($2b),y	   STA (TXTTAB),Y    ; clear first byte of memory
.e41b	e6 2b		inc $2b		   INC TXTTAB        ; increment start of memory low byte
.e41d	d0 02		bne $e421	   BNE IBRV_Ret      ; branch if no rollover
.e41f	e6 2c		inc $2c		   INC TXTTAB+1      ; increment start of memory high byte
.e421					IBRV_Ret
.e421	60		rts		   RTS
.e422					  Print_Startup_Message
.e422	a5 2b		lda $2b		   LDA TXTTAB
.e424	a4 2c		ldy $2c		   LDY TXTTAB+1
.e426	20 08 a4	jsr $a408	   JSR Check_Mem_Avail
.e429	a9 73		lda #$73	   LDA #<Start_Message
.e42b	a0 e4		ldy #$e4	   LDY #>Start_Message
.e42d	20 1e ab	jsr $ab1e	   JSR Print_String
.e430	a5 37		lda $37		   LDA MEMSIZ        ; get end of memory low byte
.e432	38		sec		   SEC
.e433	e5 2b		sbc $2b		   SBC TXTTAB        ; subtract start of memory low byte
.e435	aa		tax		   TAX               ; copy result to X
.e436	a5 38		lda $38		   LDA MEMSIZ+1      ; get end of memory high byte
.e438	e5 2c		sbc $2c		   SBC TXTTAB+1      ; subtract start of memory high byte
.e43a	20 cd bd	jsr $bdcd	   JSR Print_Integer_XA
.e43d	a9 60		lda #$60	   LDA #<Bytes_Free_Message
.e43f	a0 e4		ldy #$e4	   LDY #>Bytes_Free_Message
.e441	20 1e ab	jsr $ab1e	   JSR Print_String
.e444	4c 44 a6	jmp $a644	   JMP Perform_NEW
.e447					Basic_Vectors
>e447	8b e3				   .word   Back_To_Prompt     ; error message            IERROR
>e449	83 a4				   .word   Default_Warmstart  ; BASIC warm start         IMAIN
>e44b	7c a5				   .word   Default_Tokenize   ; crunch BASIC tokens      ICRNCH
>e44d	1a a7				   .word   Default_Detokenize ; uncrunch BASIC tokens    IQPLOP
>e44f	e4 a7				   .word   Default_Start      ; start new BASIC code     IGONE
>e451	86 ae				   .word   Default_EVAL       ; get arithmetic element   IEVAL
.e453					  Init_BASIC_Jump_Vectors
.e453	a2 0b		ldx #$0b	   LDX #$0B          ; set byte count
.e455					IBJV_10
.e455	bd 47 e4	lda $e447,x	   LDA Basic_Vectors,X
.e458	9d 00 03	sta $0300,x	   STA IERROR,X      ; save byte to RAM
.e45b	ca		dex		   DEX               ; decrement index
.e45c	10 f7		bpl $e455	   BPL IBJV_10       ; loop if more to do
.e45e	60		rts		   RTS
>e45f	00				   .BYTE 0
.e460					Bytes_Free_Message
>e460	20 42 41 53 49 43 20 42		   .TEXT " BASIC BYTES FREE\r",0
>e468	59 54 45 53 20 46 52 45 45 0d 00
.e473					Start_Message
>e473	93				   .BYTE $93
>e474	0d 20 20 20 20 2a 2a 2a		   .TEXT "\r    **** COMMODORE 64 BASIC V2 ****\r"
>e47c	2a 20 43 4f 4d 4d 4f 44 4f 52 45 20 36 34 20 42
>e48c	41 53 49 43 20 56 32 20 2a 2a 2a 2a 0d
>e499	0d 20 36 34 4b 20 52 41		   .TEXT "\r 64K RAM SYSTEM  ",0
>e4a1	4d 20 53 59 53 54 45 4d 20 20 00
>e4ac	81				   .BYTE $81
.e4ad					  CHKOUT_Checked
.e4ad	48		pha		   PHA
.e4ae	20 c9 ff	jsr $ffc9	   JSR CHKOUT
.e4b1	aa		tax		   TAX
.e4b2	68		pla		   PLA
.e4b3	90 01		bcc $e4b6	   BCC CHCh_Ret
.e4b5	8a		txa		   TXA
.e4b6					CHCh_Ret
.e4b6	60		rts		   RTS
>e4b7	aa aa aa aa aa aa aa aa		   .fill 28 ,$aa
>e4bf	aa aa aa aa aa aa aa aa aa aa aa aa aa aa aa aa
>e4cf	aa aa aa aa
.e4d3					Je4d3
.e4d3	85 a9		sta $a9		   STA RINONE
.e4d5	a9 01		lda #$01	   LDA #1
.e4d7	85 ab		sta $ab		   STA RIPRTY
.e4d9	60		rts		   RTS
.e4da					STA_COLOR
.e4da	ad 86 02	lda $0286	   LDA COLOR
.e4dd	91 f3		sta ($f3),y	   STA (USER),Y
.e4df	60		rts		   RTS
.e4e0					  Delay_2JiffyM
.e4e0	69 02		adc #$02	   ADC #2
.e4e2					Be4e2
.e4e2	a4 91		ldy $91		   LDY STKEY
.e4e4	c8		iny		   INY
.e4e5	d0 04		bne $e4eb	   BNE Be4eb
.e4e7	c5 a1		cmp $a1		   CMP JIFFYM
.e4e9	d0 f7		bne $e4e2	   BNE Be4e2
.e4eb					Be4eb
.e4eb	60		rts		   RTS
.e4ec					  BaudNTSC
>e4ec	19 26				   .WORD $2619       ;       9753
>e4ee	44 19				   .WORD $1944       ;       6468
>e4f0	1a 11				   .WORD $111a       ;       4378
>e4f2	e8 0d				   .WORD $0de8       ;       3560
>e4f4	70 0c				   .WORD $0c70       ;       3184
>e4f6	06 06				   .WORD $0606       ;       1542
>e4f8	d1 02				   .WORD $02d1       ;        721
>e4fa	37 01				   .WORD $0137       ;        311
>e4fc	ae 00				   .WORD $00ae       ;        174
>e4fe	69 00				   .WORD $0069       ;        105
.e500					  Kernal_IOBASE
.e500	a2 00		ldx #$00	   LDX #<IO_Base_Address
.e502	a0 dc		ldy #$dc	   LDY #>IO_Base_Address
.e504	60		rts		   RTS
.e505					  Kernal_SCREEN
.e505	a2 28		ldx #$28	   LDX #COLS
.e507	a0 19		ldy #$19	   LDY #ROWS
.e509	60		rts		   RTS
.e50a					  Kernal_PLOT
.e50a	b0 07		bcs $e513	   BCS PLOT_10       ; if read cursor skip the set cursor
.e50c					PLOT_05
.e50c	86 d6		stx $d6		   STX TBLX          ; save cursor row
.e50e	84 d3		sty $d3		   STY CSRIDX        ; save cursor column
.e510	20 6c e5	jsr $e56c	   JSR Adjust_Line   ; set screen pointers for cursor row, column
.e513					PLOT_10
.e513	a6 d6		ldx $d6		   LDX TBLX          ; get cursor row
.e515	a4 d3		ldy $d3		   LDY CSRIDX        ; get cursor column
.e517	60		rts		   RTS
.e518					  Initialise_Hardware
.e518	20 a0 e5	jsr $e5a0	   JSR Set_Default_Devices
.e51b					InHa_10
.e51b	a9 00		lda #$00	   LDA #0
.e51d	8d 91 02	sta $0291	   STA MODE          ; clear shift mode switch
.e520	85 cf		sta $cf		   STA BLNON         ; clear cursor blink phase
.e522	a9 48		lda #$48	   LDA #<Keyboard_Decoder
.e524	8d 8f 02	sta $028f	   STA KEYLOG
.e527	a9 eb		lda #$eb	   LDA #>Keyboard_Decoder
.e529	8d 90 02	sta $0290	   STA KEYLOG+1
.e52c	a9 0a		lda #$0a	   LDA #$0A          ; 10d
.e52e	8d 89 02	sta $0289	   STA KBMAXL        ; set maximum size of keyboard buffer
.e531	8d 8c 02	sta $028c	   STA KRPTDL        ; set repeat delay counter
.e534	a9 0e		lda #$0e	   LDA #Default_Color
.e536	8d 86 02	sta $0286	   STA COLOR         ; set current colour code
.e539	a9 04		lda #$04	   LDA #$04          ; speed 4
.e53b	8d 8b 02	sta $028b	   STA KRPTSP        ; set repeat speed counter
.e53e	a9 0c		lda #$0c	   LDA #$0C          ; cursor flash timing
.e540	85 cd		sta $cd		   STA BLNCT         ; set cursor timing countdown
.e542	85 cc		sta $cc		   STA BLNSW         ; set cursor enable, $00 = flash cursor
.e544					  Clear_Screen
.e544	ad 88 02	lda $0288	   LDA SCNMPG        ; get screen memory page
.e547	09 80		ora #$80	   ORA #$80          ; set high bit, flag every line is logical line start
.e549	a8		tay		   TAY               ; copy to Y
.e54a	a9 00		lda #$00	   LDA #$00          ; clear line start low byte
.e54c	aa		tax		   TAX               ; clear index
.e54d					ClSc_10
.e54d	94 d9		sty $d9,x	   STY SLLTBL,X      ; save start of line X pointer high byte
.e54f	18		clc		   CLC
.e550	69 28		adc #$28	   ADC #COLS         ; add line length to low byte
.e552	90 01		bcc $e555	   BCC ClSc_20       ; if no rollover skip the high byte increment
.e554	c8		iny		   INY               ; else increment high byte
.e555					ClSc_20
.e555	e8		inx		   INX               ; increment line index
.e556	e0 1a		cpx #$1a	   CPX #ROWS+1       ; compare with number of lines + 1
.e558	d0 f3		bne $e54d	   BNE ClSc_10       ; loop if not all done
.e55a	a9 ff		lda #$ff	   LDA #$FF          ; end of table marker ??
.e55c	95 d9		sta $d9,x	   STA SLLTBL,X      ; mark end of table
.e55e	a2 18		ldx #$18	   LDX #ROWS-1       ; set line count
.e560					ClSc_30
.e560	20 ff e9	jsr $e9ff	   JSR Clear_Screen_Row_X
.e563	ca		dex		   DEX               ; decrement count
.e564	10 fa		bpl $e560	   BPL ClSc_30       ; loop if more to do
.e566					  Do_Home
.e566	a0 00		ldy #$00	   LDY #0
.e568	84 d3		sty $d3		   STY CSRIDX        ; clear cursor column
.e56a	84 d6		sty $d6		   STY TBLX          ; clear cursor row
.e56c					Adjust_Line
.e56c	a6 d6		ldx $d6		   LDX TBLX          ; get cursor row
.e56e	a5 d3		lda $d3		   LDA CSRIDX        ; get cursor column
.e570					Home_10
.e570	b4 d9		ldy $d9,x	   LDY SLLTBL,X      ; get start of line X pointer high byte
.e572	30 08		bmi $e57c	   BMI Home_20       ; continue if logical line start
.e574	18		clc		   CLC               ; else clear carry for add
.e575	69 28		adc #$28	   ADC #COLS         ; add one line length
.e577	85 d3		sta $d3		   STA CSRIDX        ; save cursor column
.e579	ca		dex		   DEX               ; decrement cursor row
.e57a	10 f4		bpl $e570	   BPL Home_10       ; loop, branch always
.e57c					Home_20
.e57c	20 f0 e9	jsr $e9f0	   JSR Start_Of_Line
.e57f	a9 27		lda #$27	   LDA #COLS-1       ; set line length
.e581	e8		inx		   INX               ; increment cursor row
.e582					Home_30
.e582	b4 d9		ldy $d9,x	   LDY SLLTBL,X      ; get start of line X pointer high byte
.e584	30 06		bmi $e58c	   BMI Home_40       ; exit if logical line start
.e586	18		clc		   CLC               ; else clear carry for add
.e587	69 28		adc #$28	   ADC #COLS         ; add one line length to current line length
.e589	e8		inx		   INX               ; increment cursor row
.e58a	10 f6		bpl $e582	   BPL Home_30       ; loop, branch always
.e58c					Home_40
.e58c	85 d5		sta $d5		   STA LINLEN        ; save current screen line length
.e58e	4c 24 ea	jmp $ea24	   JMP Set_COLRAM_Pointer
.e591					Home_50
.e591	e4 c9		cpx $c9		   CPX ICRROW
.e593	f0 03		beq $e598	   BEQ Home_Ret
.e595	4c ed e6	jmp $e6ed	   JMP Set_Pointer_To_Start_Of_Logical_Row_X
.e598					Home_Ret
.e598	60		rts		   RTS
.e599	ea		nop		   NOP
.e59a	20 a0 e5	jsr $e5a0	   JSR Set_Default_Devices
.e59d	4c 66 e5	jmp $e566	   JMP Do_Home
.e5a0					  Set_Default_Devices
.e5a0	a9 03		lda #$03	   LDA #3            ; set screen
.e5a2	85 9a		sta $9a		   STA DFLTO         ; set output device number
.e5a4	a9 00		lda #$00	   LDA #0            ; set keyboard
.e5a6	85 99		sta $99		   STA DFLTN         ; set input device number
.e5a8					  Init_VIC_Chip
.e5a8	a2 2f		ldx #$2f	   LDX #VIC_REGS
.e5aa					IVC_Loop
.e5aa	bd b8 ec	lda $ecb8,x	   LDA VIC_INIT-1,X  ; get byte from setup table
.e5ad	9d ff cf	sta $cfff,x	   STA VIC_BASE-1,X  ; save byte to Vic chip
.e5b0	ca		dex		   DEX               ; decrement count/index
.e5b1	d0 f7		bne $e5aa	   BNE IVC_Loop      ; loop if more to do
.e5b3	60		rts		   RTS
.e5b4					  Get_Char_From_Keyboard_Buffer
.e5b4	ac 77 02	ldy $0277	   LDY KBUFFR        ; get current character from buffer
.e5b7	a2 00		ldx #$00	   LDX #0
.e5b9					GCFK_Loop
.e5b9	bd 78 02	lda $0278,x	   LDA KBUFFR+1,X    ; get next character,X from buffer
.e5bc	9d 77 02	sta $0277,x	   STA KBUFFR,X      ; save as current character,X in buffer
.e5bf	e8		inx		   INX               ; increment index
.e5c0	e4 c6		cpx $c6		   CPX NDX           ; compare with keyboard buffer index
.e5c2	d0 f5		bne $e5b9	   BNE GCFK_Loop     ; loop if more to do
.e5c4	c6 c6		dec $c6		   DEC NDX           ; decrement keyboard buffer index
.e5c6	98		tya		   TYA               ; copy key to A
.e5c7	58		cli		   CLI               ; enable interrupts
.e5c8	18		clc		   CLC               ; flag got byte
.e5c9	60		rts		   RTS
.e5ca					  Display_And_Get_Key
.e5ca	20 16 e7	jsr $e716	   JSR Screen_CHROUT ; output character
.e5cd					  Get_Key
.e5cd	a5 c6		lda $c6		   LDA NDX           ; get keyboard buffer index
.e5cf	85 cc		sta $cc		   STA BLNSW         ; cursor enable, $00 = flash cursor, $xx = no flash
.e5d1	8d 92 02	sta $0292	   STA AUTODN        ; screen scrolling flag, $00 = scroll, $xx = no scroll
.e5d4	f0 f7		beq $e5cd	   BEQ Get_Key       ; loop if buffer empty
.e5d6	78		sei		   SEI               ; disable interrupts
.e5d7	a5 cf		lda $cf		   LDA BLNON         ; get cursor blink phase
.e5d9	f0 0c		beq $e5e7	   BEQ GETK_10       ; branch if cursor phase
.e5db	a5 ce		lda $ce		   LDA GDBLN         ; get character under cursor
.e5dd	ae 87 02	ldx $0287	   LDX CSRCLR        ; get colour under cursor
.e5e0	a0 00		ldy #$00	   LDY #$00          ; clear Y
.e5e2	84 cf		sty $cf		   STY BLNON         ; clear cursor blink phase
.e5e4	20 13 ea	jsr $ea13	   JSR Display_Char_A_And_Color_X
.e5e7					GETK_10
.e5e7	20 b4 e5	jsr $e5b4	   JSR Get_Char_From_Keyboard_Buffer
.e5ea	c9 83		cmp #$83	   CMP #$83          ; compare with [SHIFT][RUN]
.e5ec	d0 10		bne $e5fe	   BNE GETK_30       ; branch if not [SHIFT][RUN]
.e5ee	a2 09		ldx #$09	   LDX #9            ; set byte count
.e5f0	78		sei		   SEI               ; disable interrupts
.e5f1	86 c6		stx $c6		   STX NDX           ; set keyboard buffer index
.e5f3					GETK_20
.e5f3	bd e6 ec	lda $ece6,x	   LDA RUNKEY-1,X    ; get byte from auto load/run table
.e5f6	9d 76 02	sta $0276,x	   STA KBUFFR-1,X    ; save to keyboard buffer
.e5f9	ca		dex		   DEX               ; decrement count/index
.e5fa	d0 f7		bne $e5f3	   BNE GETK_20       ; loop while more to do
.e5fc	f0 cf		beq $e5cd	   BEQ Get_Key       ; loop for next key, branch always
.e5fe					GETK_30
.e5fe	c9 0d		cmp #$0d	   CMP #CR
.e600	d0 c8		bne $e5ca	   BNE Display_And_Get_Key
.e602	a4 d5		ldy $d5		   LDY LINLEN        ; get current screen line length
.e604	84 d0		sty $d0		   STY INSRC         ; input from keyboard or screen, $xx = screen,
.e606					GETK_40
.e606	b1 d1		lda ($d1),y	   LDA (LINPTR),Y    ; get character from current screen line
.e608	c9 20		cmp #$20	   CMP #' '          ; compare with [SPACE]
.e60a	d0 03		bne $e60f	   BNE GETK_50       ; branch if not [SPACE]
.e60c	88		dey		   DEY               ; else eliminate the space, decrement end of input line
.e60d	d0 f7		bne $e606	   BNE GETK_40       ; loop, branch always
.e60f					GETK_50
.e60f	c8		iny		   INY               ; increment past last non space character on line
.e610	84 c8		sty $c8		   STY INDX          ; save input [EOL] pointer
.e612	a0 00		ldy #$00	   LDY #0
.e614	8c 92 02	sty $0292	   STY AUTODN        ; clear screen scrolling flag, $00 = scroll, $xx = no scroll
.e617	84 d3		sty $d3		   STY CSRIDX        ; clear cursor column
.e619	84 d4		sty $d4		   STY CSRMOD        ; clear cursor quote flag, $xx = quote, $00 = no quote
.e61b	a5 c9		lda $c9		   LDA ICRROW        ; get input cursor row
.e61d	30 1b		bmi $e63a	   BMI Get_Screen
.e61f	a6 d6		ldx $d6		   LDX TBLX          ; get cursor row
.e621	20 91 e5	jsr $e591	   JSR Home_50
.e624	e4 c9		cpx $c9		   CPX ICRROW        ; compare with input cursor row
.e626	d0 12		bne $e63a	   BNE Get_Screen
.e628	a5 ca		lda $ca		   LDA ICRCOL        ; get input cursor column
.e62a	85 d3		sta $d3		   STA CSRIDX        ; save cursor column
.e62c	c5 c8		cmp $c8		   CMP INDX          ; compare with input [EOL] pointer
.e62e	90 0a		bcc $e63a	   BCC Get_Screen    ; branch if less, cursor is in line
.e630	b0 2b		bcs $e65d	   BCS GetS_20      ; else cursor is beyond the line end, branch always
.e632					  CHRIN_Keyboard_Or_Screen
.e632	98		tya		   TYA               ; copy Y
.e633	48		pha		   PHA               ; save Y
.e634	8a		txa		   TXA               ; copy X
.e635	48		pha		   PHA               ; save X
.e636	a5 d0		lda $d0		   LDA INSRC         ; input from keyboard or screen, $xx = screen,
.e638	f0 93		beq $e5cd	   BEQ Get_Key       ; if keyboard go wait for key
.e63a					  Get_Screen
.e63a	a4 d3		ldy $d3		   LDY CSRIDX        ; get cursor column
.e63c	b1 d1		lda ($d1),y	   LDA (LINPTR),Y    ; get character from the current screen line
.e63e	85 d7		sta $d7		   STA LASTKY        ; save temporary last character
.e640	29 3f		and #$3f	   AND #$3F          ; mask key bits
.e642	06 d7		asl $d7		   ASL LASTKY        ; << temporary last character
.e644	24 d7		bit $d7		   BIT LASTKY        ; test it
.e646	10 02		bpl $e64a	   BPL GetS_05       ; branch if not [NO KEY]
.e648	09 80		ora #$80	   ORA #$80
.e64a					GetS_05
.e64a	90 04		bcc $e650	   BCC GetS_10
.e64c	a6 d4		ldx $d4		   LDX CSRMOD        ; get cursor quote flag, $xx = quote, $00 = no quote
.e64e	d0 04		bne $e654	   BNE GetS_15       ; branch if in quote mode
.e650					GetS_10
.e650	70 02		bvs $e654	   BVS GetS_15
.e652	09 40		ora #$40	   ORA #$40
.e654					GetS_15
.e654	e6 d3		inc $d3		   INC CSRIDX        ; increment cursor column
.e656	20 84 e6	jsr $e684	   JSR If_Quote_Toggle_Flag
.e659	c4 c8		cpy $c8		   CPY INDX          ; compare with input [EOL] pointer
.e65b	d0 17		bne $e674	   BNE GetS_35       ; branch if not at line end
.e65d					GetS_20
.e65d	a9 00		lda #$00	   LDA #$00
.e65f	85 d0		sta $d0		   STA INSRC         ; clear input from keyboard or screen, $xx = screen,
.e661	a9 0d		lda #$0d	   LDA #$0D          ; set character [CR]
.e663	a6 99		ldx $99		   LDX DFLTN         ; get input device number
.e665	e0 03		cpx #$03	   CPX #$03          ; compare with screen
.e667	f0 06		beq $e66f	   BEQ GetS_25       ; branch if screen
.e669	a6 9a		ldx $9a		   LDX DFLTO         ; get output device number
.e66b	e0 03		cpx #$03	   CPX #$03          ; compare with screen
.e66d	f0 03		beq $e672	   BEQ GetS_30       ; branch if screen
.e66f					GetS_25
.e66f	20 16 e7	jsr $e716	   JSR Screen_CHROUT ; output character
.e672					GetS_30
.e672	a9 0d		lda #$0d	   LDA #$0D          ; set character [CR]
.e674					GetS_35
.e674	85 d7		sta $d7		   STA LASTKY        ; save character
.e676	68		pla		   PLA               ; pull X
.e677	aa		tax		   TAX               ; restore X
.e678	68		pla		   PLA               ; pull Y
.e679	a8		tay		   TAY               ; restore Y
.e67a	a5 d7		lda $d7		   LDA LASTKY        ; restore character
.e67c	c9 de		cmp #$de	   CMP #$DE
.e67e	d0 02		bne $e682	   BNE GetS_40
.e680	a9 ff		lda #$ff	   LDA #$FF
.e682					GetS_40
.e682	18		clc		   CLC
.e683	60		rts		   RTS
.e684					  If_Quote_Toggle_Flag
.e684	c9 22		cmp #$22	   CMP #QUOTE
.e686	d0 08		bne $e690	   BNE IQTF_Ret      ; exit if not "
.e688	a5 d4		lda $d4		   LDA CSRMOD        ; get cursor quote flag, $xx = quote, $00 = no quote
.e68a	49 01		eor #$01	   EOR #1            ; toggle it
.e68c	85 d4		sta $d4		   STA CSRMOD        ; save cursor quote flag
.e68e	a9 22		lda #$22	   LDA #QUOTE
.e690					IQTF_Ret
.e690	60		rts		   RTS
.e691					  Insert_Char
.e691	09 40		ora #$40	   ORA #$40          ; change to uppercase/graphic
.e693					InsC_10
.e693	a6 c7		ldx $c7		   LDX RVS           ; get reverse flag
.e695	f0 02		beq $e699	   BEQ InsC_30       ; branch if not reverse
.e697					InsC_20
.e697	09 80		ora #$80	   ORA #$80          ; reverse character
.e699					InsC_30
.e699	a6 d8		ldx $d8		   LDX INSRTO        ; get insert count
.e69b	f0 02		beq $e69f	   BEQ InsC_40       ; branch if none
.e69d	c6 d8		dec $d8		   DEC INSRTO        ; else decrement insert count
.e69f					InsC_40
.e69f	ae 86 02	ldx $0286	   LDX COLOR         ; get current colour code
.e6a2	20 13 ea	jsr $ea13	   JSR Display_Char_A_And_Color_X
.e6a5	20 b6 e6	jsr $e6b6	   JSR Advance_Cursor
.e6a8					InsC_50
.e6a8	68		pla		   PLA               ; pull Y
.e6a9	a8		tay		   TAY               ; restore Y
.e6aa	a5 d8		lda $d8		   LDA INSRTO        ; get insert count
.e6ac	f0 02		beq $e6b0	   BEQ InsC_60       ; skip quote flag clear if inserts to do
.e6ae	46 d4		lsr $d4		   LSR CSRMOD        ; clear cursor quote flag, $xx = quote, $00 = no quote
.e6b0					InsC_60
.e6b0	68		pla		   PLA               ; pull X
.e6b1	aa		tax		   TAX               ; restore X
.e6b2	68		pla		   PLA               ; restore A
.e6b3	18		clc		   CLC
.e6b4	58		cli		   CLI               ; enable interrupts
.e6b5	60		rts		   RTS
.e6b6					  Advance_Cursor
.e6b6	20 b3 e8	jsr $e8b3	   JSR Test_Line_Inc
.e6b9	e6 d3		inc $d3		   INC CSRIDX        ; increment cursor column
.e6bb	a5 d5		lda $d5		   LDA LINLEN        ; get current screen line length
.e6bd	c5 d3		cmp $d3		   CMP CSRIDX        ; compare with cursor column
.e6bf	b0 3f		bcs $e700	   BCS SPTS_Ret      ; exit if line length >= cursor column
.e6c1	c9 4f		cmp #$4f	   CMP #COLMAX-1     ; compare with max length
.e6c3	f0 32		beq $e6f7	   BEQ SPTS_20       ; if at max clear column, back cursor up and do newline
.e6c5	ad 92 02	lda $0292	   LDA AUTODN        ; get autoscroll flag
.e6c8	f0 03		beq $e6cd	   BEQ AdCu_10       ; branch if autoscroll on
.e6ca	4c 67 e9	jmp $e967	   JMP InsL_10      ; else open space on screen
.e6cd					AdCu_10
.e6cd	a6 d6		ldx $d6		   LDX TBLX          ; get cursor row
.e6cf	e0 19		cpx #$19	   CPX #ROWS         ; compare with max + 1
.e6d1	90 07		bcc $e6da	   BCC Expand_Logical_Line
.e6d3	20 ea e8	jsr $e8ea	   JSR Scroll_Screen
.e6d6	c6 d6		dec $d6		   DEC TBLX          ; decrement cursor row
.e6d8	a6 d6		ldx $d6		   LDX TBLX          ; get cursor row
.e6da					  Expand_Logical_Line
.e6da	16 d9		asl $d9,x	   ASL SLLTBL,X      ; shift start of line X pointer high byte
.e6dc	56 d9		lsr $d9,x	   LSR SLLTBL,X      ; clears bit 7
.e6de	e8		inx		   INX               ; increment screen row
.e6df	b5 d9		lda $d9,x	   LDA SLLTBL,X      ; get start of line X pointer high byte
.e6e1	09 80		ora #$80	   ORA #$80          ; mark as start of logical line
.e6e3	95 d9		sta $d9,x	   STA SLLTBL,X      ; set start of line X pointer high byte
.e6e5	ca		dex		   DEX               ; restore screen row
.e6e6	a5 d5		lda $d5		   LDA LINLEN        ; get current screen line length
.e6e8	18		clc		   CLC
.e6e9					ELL_20
.e6e9	69 28		adc #$28	   ADC #COLS         ; add one line length
.e6eb	85 d5		sta $d5		   STA LINLEN        ; save current screen line length
.e6ed					  Set_Pointer_To_Start_Of_Logical_Row_X
.e6ed	b5 d9		lda $d9,x	   LDA SLLTBL,X      ; get start of line X pointer high byte
.e6ef	30 03		bmi $e6f4	   BMI SPTS_10       ; exit loop if start of logical line
.e6f1	ca		dex		   DEX               ; else back up one line
.e6f2	d0 f9		bne $e6ed	   BNE Set_Pointer_To_Start_Of_Logical_Row_X
.e6f4					SPTS_10
.e6f4	4c f0 e9	jmp $e9f0	   JMP Start_Of_Line
.e6f7					SPTS_20
.e6f7	c6 d6		dec $d6		   DEC TBLX          ; decrement cursor row. if the cursor was incremented past
.e6f9	20 7c e8	jsr $e87c	   JSR Do_Newline
.e6fc	a9 00		lda #$00	   LDA #0
.e6fe	85 d3		sta $d3		   STA CSRIDX        ; clear cursor column
.e700					SPTS_Ret
.e700	60		rts		   RTS
.e701					  Previous_Line
.e701	a6 d6		ldx $d6		   LDX TBLX          ; get cursor row
.e703	d0 06		bne $e70b	   BNE PreL_10       ; branch if not top row
.e705	86 d3		stx $d3		   STX CSRIDX        ; clear cursor column
.e707	68		pla		   PLA               ; dump return address low byte
.e708	68		pla		   PLA               ; dump return address high byte
.e709	d0 9d		bne $e6a8	   BNE InsC_50       ; restore registers, set quote flag and exit, branch always
.e70b					PreL_10
.e70b	ca		dex		   DEX               ; decrement cursor row
.e70c	86 d6		stx $d6		   STX TBLX          ; save cursor row
.e70e	20 6c e5	jsr $e56c	   JSR Adjust_Line   ; set screen pointers for cursor row, column
.e711	a4 d5		ldy $d5		   LDY LINLEN        ; get current screen line length
.e713	84 d3		sty $d3		   STY CSRIDX        ; save as cursor column
.e715	60		rts		   RTS
.e716					  Screen_CHROUT
.e716	48		pha		   PHA               ; save character
.e717	85 d7		sta $d7		   STA LASTKY        ; save temporary last character
.e719	8a		txa		   TXA               ; copy X
.e71a	48		pha		   PHA               ; save X
.e71b	98		tya		   TYA               ; copy Y
.e71c	48		pha		   PHA               ; save Y
.e71d	a9 00		lda #$00	   LDA #0
.e71f	85 d0		sta $d0		   STA INSRC         ; clear input from keyboard or screen, $xx = screen,
.e721	a4 d3		ldy $d3		   LDY CSRIDX        ; get cursor column
.e723	a5 d7		lda $d7		   LDA LASTKY        ; restore last character
.e725	10 03		bpl $e72a	   BPL ScrO_02       ; branch if unshifted
.e727	4c d4 e7	jmp $e7d4	   JMP ScrO_42       ; do shifted characters and return
.e72a					ScrO_02
.e72a	c9 0d		cmp #$0d	   CMP #$0D          ; compare with [CR]
.e72c	d0 03		bne $e731	   BNE ScrO_04       ; branch if not [CR]
.e72e	4c 91 e8	jmp $e891	   JMP Screen_Return
.e731					ScrO_04
.e731	c9 20		cmp #$20	   CMP #' '          ; compare with [SPACE]
.e733	90 10		bcc $e745	   BCC ScrO_10       ; branch if < [SPACE]
.e735	c9 60		cmp #$60	   CMP #$60
.e737	90 04		bcc $e73d	   BCC ScrO_06       ; branch if $20 to $5F
.e739	29 df		and #$df	   AND #$DF
.e73b	d0 02		bne $e73f	   BNE ScrO_08
.e73d					ScrO_06
.e73d	29 3f		and #$3f	   AND #$3F
.e73f					ScrO_08
.e73f	20 84 e6	jsr $e684	   JSR If_Quote_Toggle_Flag
.e742	4c 93 e6	jmp $e693	   JMP InsC_10
.e745					ScrO_10
.e745	a6 d8		ldx $d8		   LDX INSRTO        ; get insert count
.e747	f0 03		beq $e74c	   BEQ ScrO_12       ; branch if no characters to insert
.e749	4c 97 e6	jmp $e697	   JMP InsC_20       ; insert reversed character
.e74c					ScrO_12
.e74c	c9 14		cmp #$14	   CMP #$14          ; compare with [INSERT]/[DELETE]
.e74e	d0 2e		bne $e77e	   BNE ScrO_20       ; branch if not [INSERT]/[DELETE]
.e750	98		tya		   TYA
.e751	d0 06		bne $e759	   BNE ScrO_14
.e753	20 01 e7	jsr $e701	   JSR Previous_Line
.e756	4c 73 e7	jmp $e773	   JMP ScrO_18
.e759					ScrO_14
.e759	20 a1 e8	jsr $e8a1	   JSR Test_Line_Dec
.e75c	88		dey		   DEY               ; decrement index to previous character
.e75d	84 d3		sty $d3		   STY CSRIDX        ; save cursor column
.e75f	20 24 ea	jsr $ea24	   JSR Set_COLRAM_Pointer
.e762					ScrO_16
.e762	c8		iny		   INY
.e763	b1 d1		lda ($d1),y	   LDA (LINPTR),Y    ; get character from current screen line
.e765	88		dey		   DEY               ; decrement index to previous character
.e766	91 d1		sta ($d1),y	   STA (LINPTR),Y    ; save character to current screen line
.e768	c8		iny		   INY
.e769	b1 f3		lda ($f3),y	   LDA (USER),Y      ; get colour RAM byte
.e76b	88		dey		   DEY               ; decrement index to previous character
.e76c	91 f3		sta ($f3),y	   STA (USER),Y      ; save colour RAM byte
.e76e	c8		iny		   INY
.e76f	c4 d5		cpy $d5		   CPY LINLEN        ; compare with current screen line length
.e771	d0 ef		bne $e762	   BNE ScrO_16       ; loop if not there yet
.e773					ScrO_18
.e773	a9 20		lda #$20	   LDA #' '          ; set [SPACE]
.e775	91 d1		sta ($d1),y	   STA (LINPTR),Y    ; clear last character on current screen line
.e777	ad 86 02	lda $0286	   LDA COLOR         ; get current colour code
.e77a	91 f3		sta ($f3),y	   STA (USER),Y      ; save to colour RAM
.e77c	10 4d		bpl $e7cb	   BPL ScrO_38       ; branch always
.e77e					ScrO_20
.e77e	a6 d4		ldx $d4		   LDX CSRMOD        ; get cursor quote flag, $xx = quote, $00 = no quote
.e780	f0 03		beq $e785	   BEQ ScrO_22       ; branch if not quote mode
.e782	4c 97 e6	jmp $e697	   JMP InsC_20       ; insert reversed character
.e785					ScrO_22
.e785	c9 12		cmp #$12	   CMP #$12          ; compare with [RVS ON]
.e787	d0 02		bne $e78b	   BNE ScrO_24       ; branch if not [RVS ON]
.e789	85 c7		sta $c7		   STA RVS           ; set reverse flag
.e78b					ScrO_24
.e78b	c9 13		cmp #$13	   CMP #$13          ; compare with [CLR HOME]
.e78d	d0 03		bne $e792	   BNE ScrO_26       ; branch if not [CLR HOME]
.e78f	20 66 e5	jsr $e566	   JSR Do_Home
.e792					ScrO_26
.e792	c9 1d		cmp #$1d	   CMP #$1D          ; compare with [CURSOR RIGHT]
.e794	d0 17		bne $e7ad	   BNE ScrO_32       ; branch if not [CURSOR RIGHT]
.e796	c8		iny		   INY               ; increment cursor column
.e797	20 b3 e8	jsr $e8b3	   JSR Test_Line_Inc
.e79a	84 d3		sty $d3		   STY CSRIDX        ; save cursor column
.e79c	88		dey		   DEY               ; decrement cursor column
.e79d	c4 d5		cpy $d5		   CPY LINLEN        ; compare cursor column with current screen line length
.e79f	90 09		bcc $e7aa	   BCC ScrO_30       ; exit if less
.e7a1	c6 d6		dec $d6		   DEC TBLX          ; decrement cursor row
.e7a3	20 7c e8	jsr $e87c	   JSR Do_Newline
.e7a6	a0 00		ldy #$00	   LDY #$00          ; clear cursor column
.e7a8					ScrO_28
.e7a8	84 d3		sty $d3		   STY CSRIDX        ; save cursor column
.e7aa					ScrO_30
.e7aa	4c a8 e6	jmp $e6a8	   JMP InsC_50       ; restore registers, set quote flag and exit
.e7ad					ScrO_32
.e7ad	c9 11		cmp #$11	   CMP #$11          ; compare with [CURSOR DOWN]
.e7af	d0 1d		bne $e7ce	   BNE ScrO_40       ; branch if not [CURSOR DOWN]
.e7b1	18		clc		   CLC
.e7b2	98		tya		   TYA               ; copy cursor column
.e7b3	69 28		adc #$28	   ADC #COLS         ; add one line
.e7b5	a8		tay		   TAY               ; copy back to A
.e7b6	e6 d6		inc $d6		   INC TBLX          ; increment cursor row
.e7b8	c5 d5		cmp $d5		   CMP LINLEN        ; compare cursor column with current screen line length
.e7ba	90 ec		bcc $e7a8	   BCC ScrO_28       ; save cursor column and exit if less
.e7bc	f0 ea		beq $e7a8	   BEQ ScrO_28       ; save cursor column and exit if equal
.e7be	c6 d6		dec $d6		   DEC TBLX          ; decrement cursor row
.e7c0					ScrO_34
.e7c0	e9 28		sbc #$28	   SBC #COLS         ; subtract one line
.e7c2	90 04		bcc $e7c8	   BCC ScrO_36       ; exit loop if on previous line
.e7c4	85 d3		sta $d3		   STA CSRIDX        ; else save cursor column
.e7c6	d0 f8		bne $e7c0	   BNE ScrO_34       ; loop if not at start of line
.e7c8					ScrO_36
.e7c8	20 7c e8	jsr $e87c	   JSR Do_Newline
.e7cb					ScrO_38
.e7cb	4c a8 e6	jmp $e6a8	   JMP InsC_50       ; restore registers, set quote flag and exit
.e7ce					ScrO_40
.e7ce	20 cb e8	jsr $e8cb	   JSR Set_Color
.e7d1	4c 44 ec	jmp $ec44	   JMP Switch_Text_Graphics
.e7d4					ScrO_42
.e7d4	29 7f		and #$7f	   AND #$7F          ; mask 0xxx xxxx, clear b7
.e7d6	c9 7f		cmp #$7f	   CMP #$7F          ; was it $FF before the mask
.e7d8	d0 02		bne $e7dc	   BNE ScrO_44       ; branch if not
.e7da	a9 5e		lda #$5e	   LDA #$5E          ; else make it $5E
.e7dc					ScrO_44
.e7dc	c9 20		cmp #$20	   CMP #' '          ; compare with [SPACE]
.e7de	90 03		bcc $e7e3	   BCC ScrO_46       ; branch if < [SPACE]
.e7e0	4c 91 e6	jmp $e691	   JMP Insert_Char
.e7e3					ScrO_46
.e7e3	c9 0d		cmp #$0d	   CMP #$0D          ; compare with [CR]
.e7e5	d0 03		bne $e7ea	   BNE ScrO_48       ; branch if not [CR]
.e7e7	4c 91 e8	jmp $e891	   JMP Screen_Return      ; else output [CR] and return
.e7ea					ScrO_48
.e7ea	a6 d4		ldx $d4		   LDX CSRMOD        ; get cursor quote flag, $xx = quote, $00 = no quote
.e7ec	d0 3f		bne $e82d	   BNE ScrO_60       ; branch if quote mode
.e7ee	c9 14		cmp #$14	   CMP #$14          ; compare with [INSERT DELETE]
.e7f0	d0 37		bne $e829	   BNE ScrO_58       ; branch if not [INSERT DELETE]
.e7f2	a4 d5		ldy $d5		   LDY LINLEN        ; get current screen line length
.e7f4	b1 d1		lda ($d1),y	   LDA (LINPTR),Y    ; get character from current screen line
.e7f6	c9 20		cmp #$20	   CMP #' '          ; compare with [SPACE]
.e7f8	d0 04		bne $e7fe	   BNE ScrO_50       ; branch if not [SPACE]
.e7fa	c4 d3		cpy $d3		   CPY CSRIDX        ; compare current column with cursor column
.e7fc	d0 07		bne $e805	   BNE ScrO_52       ; if not cursor column go open up space on line
.e7fe					ScrO_50
.e7fe	c0 4f		cpy #$4f	   CPY #COLMAX-1     ; compare current column with max line length
.e800	f0 24		beq $e826	   BEQ ScrO_56       ; exit if at line end
.e802	20 65 e9	jsr $e965	   JSR Insert_Line
.e805					ScrO_52
.e805	a4 d5		ldy $d5		   LDY LINLEN        ; get current screen line length
.e807	20 24 ea	jsr $ea24	   JSR Set_COLRAM_Pointer
.e80a					ScrO_54
.e80a	88		dey		   DEY               ; decrement index to previous character
.e80b	b1 d1		lda ($d1),y	   LDA (LINPTR),Y    ; get character from current screen line
.e80d	c8		iny		   INY
.e80e	91 d1		sta ($d1),y	   STA (LINPTR),Y    ; save character to current screen line
.e810	88		dey		   DEY               ; decrement index to previous character
.e811	b1 f3		lda ($f3),y	   LDA (USER),Y      ; get current screen line colour RAM byte
.e813	c8		iny		   INY
.e814	91 f3		sta ($f3),y	   STA (USER),Y      ; save current screen line colour RAM byte
.e816	88		dey		   DEY               ; decrement index to previous character
.e817	c4 d3		cpy $d3		   CPY CSRIDX        ; compare with cursor column
.e819	d0 ef		bne $e80a	   BNE ScrO_54       ; loop if not there yet
.e81b	a9 20		lda #$20	   LDA #' '          ; set [SPACE]
.e81d	91 d1		sta ($d1),y	   STA (LINPTR),Y    ; clear character at cursor position on current screen line
.e81f	ad 86 02	lda $0286	   LDA COLOR         ; get current colour code
.e822	91 f3		sta ($f3),y	   STA (USER),Y      ; save to cursor position on current screen line colour RAM
.e824	e6 d8		inc $d8		   INC INSRTO        ; increment insert count
.e826					ScrO_56
.e826	4c a8 e6	jmp $e6a8	   JMP InsC_50       ; restore registers, set quote flag and exit
.e829					ScrO_58
.e829	a6 d8		ldx $d8		   LDX INSRTO        ; get insert count
.e82b	f0 05		beq $e832	   BEQ ScrO_62       ; branch if no insert space
.e82d					ScrO_60
.e82d	09 40		ora #$40	   ORA #$40          ; change to uppercase/graphic
.e82f	4c 97 e6	jmp $e697	   JMP InsC_20       ; insert reversed character
.e832					ScrO_62
.e832	c9 11		cmp #$11	   CMP #$11          ; compare with [CURSOR UP]
.e834	d0 16		bne $e84c	   BNE ScrO_66       ; branch if not [CURSOR UP]
.e836	a6 d6		ldx $d6		   LDX TBLX          ; get cursor row
.e838	f0 37		beq $e871	   BEQ ScrO_74       ; branch if on top line
.e83a	c6 d6		dec $d6		   DEC TBLX          ; decrement cursor row
.e83c	a5 d3		lda $d3		   LDA CSRIDX        ; get cursor column
.e83e	38		sec		   SEC
.e83f	e9 28		sbc #$28	   SBC #COLS         ; subtract one line length
.e841	90 04		bcc $e847	   BCC ScrO_64       ; branch if stepped back to previous line
.e843	85 d3		sta $d3		   STA CSRIDX        ; else save cursor column ..
.e845	10 2a		bpl $e871	   BPL ScrO_74       ; .. and exit, branch always
.e847					ScrO_64
.e847	20 6c e5	jsr $e56c	   JSR Adjust_Line   ; set screen pointers for cursor row, column ..
.e84a	d0 25		bne $e871	   BNE ScrO_74       ; .. and exit, branch always
.e84c					ScrO_66
.e84c	c9 12		cmp #$12	   CMP #$12          ; compare with [RVS OFF]
.e84e	d0 04		bne $e854	   BNE ScrO_68       ; branch if not [RVS OFF]
.e850	a9 00		lda #$00	   LDA #0
.e852	85 c7		sta $c7		   STA RVS           ; clear reverse flag
.e854					ScrO_68
.e854	c9 1d		cmp #$1d	   CMP #$1D          ; compare with [CURSOR LEFT]
.e856	d0 12		bne $e86a	   BNE ScrO_72       ; branch if not [CURSOR LEFT]
.e858	98		tya		   TYA               ; copy cursor column
.e859	f0 09		beq $e864	   BEQ ScrO_70       ; branch if at start of line
.e85b	20 a1 e8	jsr $e8a1	   JSR Test_Line_Dec
.e85e	88		dey		   DEY               ; decrement cursor column
.e85f	84 d3		sty $d3		   STY CSRIDX        ; save cursor column
.e861	4c a8 e6	jmp $e6a8	   JMP InsC_50       ; restore registers, set quote flag and exit
.e864					ScrO_70
.e864	20 01 e7	jsr $e701	   JSR Previous_Line
.e867	4c a8 e6	jmp $e6a8	   JMP InsC_50       ; restore registers, set quote flag and exit
.e86a					ScrO_72
.e86a	c9 13		cmp #$13	   CMP #$13          ; compare with [CLR]
.e86c	d0 06		bne $e874	   BNE ScrO_76       ; branch if not [CLR]
.e86e	20 44 e5	jsr $e544	   JSR Clear_Screen
.e871					ScrO_74
.e871	4c a8 e6	jmp $e6a8	   JMP InsC_50       ; restore registers, set quote flag and exit
.e874					ScrO_76
.e874	09 80		ora #$80	   ORA #$80          ; restore b7, colour can only be black, cyan, magenta
.e876	20 cb e8	jsr $e8cb	   JSR Set_Color
.e879	4c 4f ec	jmp $ec4f	   JMP STG_10
.e87c					  Do_Newline
.e87c	46 c9		lsr $c9		   LSR ICRROW        ; shift >> input cursor row
.e87e	a6 d6		ldx $d6		   LDX TBLX          ; get cursor row
.e880					NewL_10
.e880	e8		inx		   INX               ; increment row
.e881	e0 19		cpx #$19	   CPX #ROWS         ; compare with last row + 1
.e883	d0 03		bne $e888	   BNE NewL_20       ; branch if not last row + 1
.e885	20 ea e8	jsr $e8ea	   JSR Scroll_Screen
.e888					NewL_20
.e888	b5 d9		lda $d9,x	   LDA SLLTBL,X      ; get start of line X pointer high byte
.e88a	10 f4		bpl $e880	   BPL NewL_10       ; loop if not start of logical line
.e88c	86 d6		stx $d6		   STX TBLX          ; else save cursor row
.e88e	4c 6c e5	jmp $e56c	   JMP Adjust_Line   ; set screen pointers for cursor row, column and return
.e891					  Screen_Return
.e891	a2 00		ldx #$00	   LDX #0
.e893	86 d8		stx $d8		   STX INSRTO        ; clear insert count
.e895	86 c7		stx $c7		   STX RVS           ; clear reverse flag
.e897	86 d4		stx $d4		   STX CSRMOD        ; clear cursor quote flag, $xx = quote, $00 = no quote
.e899	86 d3		stx $d3		   STX CSRIDX        ; clear cursor column
.e89b	20 7c e8	jsr $e87c	   JSR Do_Newline
.e89e	4c a8 e6	jmp $e6a8	   JMP InsC_50      ; restore registers, set quote flag and exit
.e8a1					  Test_Line_Dec
.e8a1	a2 02		ldx #$02	   LDX #COLINK       ; set count
.e8a3	a9 00		lda #$00	   LDA #$00          ; set column
.e8a5					TLD_10
.e8a5	c5 d3		cmp $d3		   CMP CSRIDX        ; compare with cursor column
.e8a7	f0 07		beq $e8b0	   BEQ TLD_20        ; branch if at start of line
.e8a9	18		clc		   CLC               ; else clear carry for add
.e8aa	69 28		adc #$28	   ADC #COLS         ; increment to next line
.e8ac	ca		dex		   DEX               ; decrement loop count
.e8ad	d0 f6		bne $e8a5	   BNE TLD_10        ; loop if more to test
.e8af	60		rts		   RTS
.e8b0					TLD_20
.e8b0	c6 d6		dec $d6		   DEC TBLX          ; else decrement cursor row
.e8b2	60		rts		   RTS
.e8b3					  Test_Line_Inc
.e8b3	a2 02		ldx #$02	   LDX #COLINK       ; set count
.e8b5	a9 27		lda #$27	   LDA #COLS-1       ; set column
.e8b7					TLI_10
.e8b7	c5 d3		cmp $d3		   CMP CSRIDX        ; compare with cursor column
.e8b9	f0 07		beq $e8c2	   BEQ TLI_20        ; if at end of line test and possibly increment cursor row
.e8bb	18		clc		   CLC               ; else clear carry for add
.e8bc	69 28		adc #$28	   ADC #COLS         ; increment to next line
.e8be	ca		dex		   DEX               ; decrement loop count
.e8bf	d0 f6		bne $e8b7	   BNE TLI_10        ; loop if more to test
.e8c1	60		rts		   RTS
.e8c2					TLI_20
.e8c2	a6 d6		ldx $d6		   LDX TBLX          ; get cursor row
.e8c4	e0 19		cpx #$19	   CPX #ROWS
.e8c6	f0 02		beq $e8ca	   BEQ TLI_30        ; exit if end of screen
.e8c8	e6 d6		inc $d6		   INC TBLX          ; else increment cursor row
.e8ca					TLI_30
.e8ca	60		rts		   RTS
.e8cb					  Set_Color
.e8cb	a2 0f		ldx #$0f	   LDX #Color_Codes_End-Color_Codes-1
.e8cd					SeCo_Loop
.e8cd	dd da e8	cmp $e8da,x	   CMP Color_Codes,X ; compare the character with the table code
.e8d0	f0 04		beq $e8d6	   BEQ SeCo_10       ; if a match go save the colour and exit
.e8d2	ca		dex		   DEX               ; else decrement the index
.e8d3	10 f8		bpl $e8cd	   BPL SeCo_Loop     ; loop if more to do
.e8d5	60		rts		   RTS
.e8d6					SeCo_10
.e8d6	8e 86 02	stx $0286	   STX COLOR         ; set current colour code
.e8d9	60		rts		   RTS
.e8da					Color_Codes
>e8da	90				   .byte $90         ; black
>e8db	05				   .byte $05         ; white
>e8dc	1c				   .byte $1C         ; red
>e8dd	9f				   .byte $9F         ; cyan
>e8de	9c				   .byte $9C         ; magenta
>e8df	1e				   .byte $1E         ; green
>e8e0	1f				   .byte $1F         ; blue
>e8e1	9e				   .byte $9E         ; yellow
>e8e2	81				   .byte $81         ; orange
>e8e3	95				   .byte $95         ; brown
>e8e4	96				   .byte $96         ; light red
>e8e5	97				   .byte $97         ; grey 1
>e8e6	98				   .byte $98         ; grey 2
>e8e7	99				   .byte $99         ; light green
>e8e8	9a				   .byte $9a         ; light blue
>e8e9	9b				   .byte $9b         ; grey 3
.e8ea					Color_Codes_End
.e8ea					  Scroll_Screen
.e8ea	a5 ac		lda $ac		   LDA SAL           ; save SAL & EAL
.e8ec	48		pha		   PHA
.e8ed	a5 ad		lda $ad		   LDA SAL+1
.e8ef	48		pha		   PHA
.e8f0	a5 ae		lda $ae		   LDA EAL
.e8f2	48		pha		   PHA
.e8f3	a5 af		lda $af		   LDA EAL+1
.e8f5	48		pha		   PHA
.e8f6					ScSc_05
.e8f6	a2 ff		ldx #$ff	   LDX #-1           ; set for pre increment loop
.e8f8	c6 d6		dec $d6		   DEC TBLX          ; decrement cursor row
.e8fa	c6 c9		dec $c9		   DEC ICRROW        ; decrement input cursor row
.e8fc	ce a5 02	dec $02a5	   DEC SCROWM        ; decrement screen row marker
.e8ff					ScSc_10
.e8ff	e8		inx		   INX               ; increment line number
.e900	20 f0 e9	jsr $e9f0	   JSR Start_Of_Line
.e903	e0 18		cpx #$18	   CPX #ROWS-1       ; compare with last line
.e905	b0 0c		bcs $e913	   BCS ScSc_15       ; branch if on last line
.e907	bd f1 ec	lda $ecf1,x	   LDA Line_Adress_Low+1,X
.e90a	85 ac		sta $ac		   STA SAL           ; save next line pointer low byte
.e90c	b5 da		lda $da,x	   LDA SLLTBL+1,X    ; get start of next line pointer high byte
.e90e	20 c8 e9	jsr $e9c8	   JSR Shift_Row
.e911	30 ec		bmi $e8ff	   BMI ScSc_10       ; loop, branch always
.e913					ScSc_15
.e913	20 ff e9	jsr $e9ff	   JSR Clear_Screen_Row_X
.e916	a2 00		ldx #$00	   LDX #0
.e918					ScSc_20
.e918	b5 d9		lda $d9,x	   LDA SLLTBL,X      ; get start of line X pointer high byte
.e91a	29 7f		and #$7f	   AND #$7F          ; clear line X start of logical line bit
.e91c	b4 da		ldy $da,x	   LDY SLLTBL+1,X    ; get start of next line pointer high byte
.e91e	10 02		bpl $e922	   BPL ScSc_25       ; branch if next line not start of line
.e920	09 80		ora #$80	   ORA #$80          ; set line X start of logical line bit
.e922					ScSc_25
.e922	95 d9		sta $d9,x	   STA SLLTBL,X      ; set start of line X pointer high byte
.e924	e8		inx		   INX               ; increment line number
.e925	e0 18		cpx #$18	   CPX #ROWS-1       ; compare with last line
.e927	d0 ef		bne $e918	   BNE ScSc_20       ; loop if not last line
.e929	a5 f1		lda $f1		   LDA SLLTBL+ROWS-1 ; get start of last line pointer high byte
.e92b	09 80		ora #$80	   ORA #$80          ; mark as start of logical line
.e92d	85 f1		sta $f1		   STA SLLTBL+ROWS-1 ; set start of last line pointer high byte
.e92f	a5 d9		lda $d9		   LDA SLLTBL        ; get start of first line pointer high byte
.e931	10 c3		bpl $e8f6	   BPL ScSc_05       ; if not start of logical line loop back and
.e933	e6 d6		inc $d6		   INC TBLX          ; increment cursor row
.e935	ee a5 02	inc $02a5	   INC SCROWM        ; increment screen row marker
.e938					ScSc_27
.e938	a9 7f		lda #$7f	   LDA #CTRL_COL     ; set keyboard column for [CTRL] key
.e93a	8d 00 dc	sta $dc00	   STA KEYB_COL      ; set VIA/CIA keyboard column
.e93d	ad 01 dc	lda $dc01	   LDA KEYB_ROW      ; get VIA/CIA keyboard row
.e940	c9 fb		cmp #$fb	   CMP #CTRL_ROW     ; compare with row of [CTRL] key
.e942	08		php		   PHP               ; save status
.e943	a9 7f		lda #$7f	   LDA #STND_COL     ; set standard keyboard col
.e945	8d 00 dc	sta $dc00	   STA KEYB_COL      ; set VIA/CIA keyboard column
.e948	28		plp		   PLP               ; restore status
.e949	d0 0b		bne $e956	   BNE ScSc_40       ; skip if no [CTRL] key down
.e94b	a0 00		ldy #$00	   LDY #0            ; delay scrolling if [CTRL] key down
.e94d					ScSc_30
.e94d	ea		nop		   NOP               ; waste cycles
.e94e	ca		dex		   DEX               ; decrement inner loop count
.e94f	d0 fc		bne $e94d	   BNE ScSc_30       ; loop if not all done
.e951	88		dey		   DEY               ; decrement outer loop count
.e952	d0 f9		bne $e94d	   BNE ScSc_30       ; loop if not all done
.e954	84 c6		sty $c6		   STY NDX           ; clear keyboard buffer index
.e956					ScSc_40
.e956	a6 d6		ldx $d6		   LDX TBLX          ; get cursor row
.e958					ScSc_45
.e958	68		pla		   PLA               ; restore EAL & SAL
.e959	85 af		sta $af		   STA EAL+1
.e95b	68		pla		   PLA
.e95c	85 ae		sta $ae		   STA EAL
.e95e	68		pla		   PLA
.e95f	85 ad		sta $ad		   STA SAL+1
.e961	68		pla		   PLA
.e962	85 ac		sta $ac		   STA SAL
.e964	60		rts		   RTS
.e965					  Insert_Line
.e965	a6 d6		ldx $d6		   LDX TBLX          ; get cursor row
.e967					InsL_10
.e967	e8		inx		   INX               ; increment row
.e968	b5 d9		lda $d9,x	   LDA SLLTBL,X      ; get start of line X pointer high byte
.e96a	10 fb		bpl $e967	   BPL InsL_10       ; branch if not start of logical line
.e96c	8e a5 02	stx $02a5	   STX SCROWM        ; set screen row marker
.e96f	e0 18		cpx #$18	   CPX #ROWS-1       ; compare with last line
.e971	f0 0e		beq $e981	   BEQ InsL_20       ; branch if = last line
.e973	90 0c		bcc $e981	   BCC InsL_20       ; branch if < last line
.e975	20 ea e8	jsr $e8ea	   JSR Scroll_Screen
.e978	ae a5 02	ldx $02a5	   LDX SCROWM        ; get screen row marker
.e97b	ca		dex		   DEX               ; decrement screen row marker
.e97c	c6 d6		dec $d6		   DEC TBLX          ; decrement cursor row
.e97e	4c da e6	jmp $e6da	   JMP Expand_Logical_Line
.e981					InsL_20
.e981	a5 ac		lda $ac		   LDA SAL           ; copy tape buffer pointer
.e983	48		pha		   PHA               ; save it
.e984	a5 ad		lda $ad		   LDA SAL+1         ; copy tape buffer pointer
.e986	48		pha		   PHA               ; save it
.e987	a5 ae		lda $ae		   LDA EAL           ; copy tape buffer end pointer
.e989	48		pha		   PHA               ; save it
.e98a	a5 af		lda $af		   LDA EAL+1         ; copy tape buffer end pointer
.e98c	48		pha		   PHA               ; save it
.e98d	a2 19		ldx #$19	   LDX #ROWS         ; set to end line + 1 for predecrement loop
.e98f					InsL_30
.e98f	ca		dex		   DEX               ; decrement line number
.e990	20 f0 e9	jsr $e9f0	   JSR Start_Of_Line
.e993	ec a5 02	cpx $02a5	   CPX SCROWM        ; compare with screen row marker
.e996	90 0e		bcc $e9a6	   BCC InsL_40       ; branch if < screen row marker
.e998	f0 0c		beq $e9a6	   BEQ InsL_40       ; branch if = screen row marker
.e99a	bd ef ec	lda $ecef,x	   LDA Line_Adress_Low-1,X  ; else get start of previous line low byte from ROM table
.e99d	85 ac		sta $ac		   STA SAL           ; save previous line pointer low byte
.e99f	b5 d8		lda $d8,x	   LDA SLLTBL-1,X    ; get start of previous line pointer high byte
.e9a1	20 c8 e9	jsr $e9c8	   JSR Shift_Row
.e9a4	30 e9		bmi $e98f	   BMI InsL_30       ; loop, branch always
.e9a6					InsL_40
.e9a6	20 ff e9	jsr $e9ff	   JSR Clear_Screen_Row_X
.e9a9	a2 17		ldx #$17	   LDX #ROWS-2
.e9ab					InsL_50
.e9ab	ec a5 02	cpx $02a5	   CPX SCROWM        ;.compare with screen row marker
.e9ae	90 0f		bcc $e9bf	   BCC InsL_70
.e9b0	b5 da		lda $da,x	   LDA SLLTBL+1,X
.e9b2	29 7f		and #$7f	   AND #$7F
.e9b4	b4 d9		ldy $d9,x	   LDY SLLTBL,X
.e9b6	10 02		bpl $e9ba	   BPL InsL_60
.e9b8	09 80		ora #$80	   ORA #$80
.e9ba					InsL_60
.e9ba	95 da		sta $da,x	   STA SLLTBL+1,X
.e9bc	ca		dex		   DEX
.e9bd	d0 ec		bne $e9ab	   BNE InsL_50
.e9bf					InsL_70
.e9bf	ae a5 02	ldx $02a5	   LDX SCROWM        ;.get screen row marker
.e9c2	20 da e6	jsr $e6da	   JSR Expand_Logical_Line
.e9c5	4c 58 e9	jmp $e958	   JMP ScSc_45
.e9c8					  Shift_Row
.e9c8	29 03		and #$03	   AND #$03          ; mask 0000 00xx, line memory page
.e9ca	0d 88 02	ora $0288	   ORA SCNMPG        ; OR with screen memory page
.e9cd	85 ad		sta $ad		   STA SAL+1         ; save next/previous line pointer high byte
.e9cf	20 e0 e9	jsr $e9e0	   JSR Update_Color_RAM_Pointer
.e9d2					ShRo_10
.e9d2	a0 27		ldy #$27	   LDY #COLS-1       ; set column count
.e9d4					ShRo_20
.e9d4	b1 ac		lda ($ac),y	   LDA (SAL),Y       ; get character from next/previous screen line
.e9d6	91 d1		sta ($d1),y	   STA (LINPTR),Y    ; save character to current screen line
.e9d8	b1 ae		lda ($ae),y	   LDA (EAL),Y       ; get colour from next/previous screen line colour RAM
.e9da	91 f3		sta ($f3),y	   STA (USER),Y      ; save colour to current screen line colour RAM
.e9dc	88		dey		   DEY               ; decrement column index/count
.e9dd	10 f5		bpl $e9d4	   BPL ShRo_20
.e9df	60		rts		   RTS
.e9e0					  Update_Color_RAM_Pointer
.e9e0	20 24 ea	jsr $ea24	   JSR Set_COLRAM_Pointer
.e9e3	a5 ac		lda $ac		   LDA SAL
.e9e5	85 ae		sta $ae		   STA EAL
.e9e7	a5 ad		lda $ad		   LDA SAL+1
.e9e9	29 03		and #$03	   AND #$03
.e9eb	09 d8		ora #$d8	   ORA #$D8          ; C64 color RAM = $D800
.e9ed	85 af		sta $af		   STA EAL+1
.e9ef	60		rts		   RTS
.e9f0					  Start_Of_Line
.e9f0	bd f0 ec	lda $ecf0,x	   LDA Line_Adress_Low,X
.e9f3	85 d1		sta $d1		   STA LINPTR        ; set current screen line pointer low byte
.e9f5	b5 d9		lda $d9,x	   LDA SLLTBL,X      ; get start of line high byte from RAM table
.e9f7	29 03		and #$03	   AND #$03          ; mask 0000 00xx, line memory page
.e9f9	0d 88 02	ora $0288	   ORA SCNMPG        ; OR with screen memory page
.e9fc	85 d2		sta $d2		   STA LINPTR+1      ; set current screen line pointer high byte
.e9fe	60		rts		   RTS
.e9ff					  Clear_Screen_Row_X
.e9ff	a0 27		ldy #$27	   LDY #COLS-1       ; set number of columns to clear
.ea01	20 f0 e9	jsr $e9f0	   JSR Start_Of_Line
.ea04	20 24 ea	jsr $ea24	   JSR Set_COLRAM_Pointer
.ea07					CSRX_Loop
.ea07	20 da e4	jsr $e4da	   JSR STA_COLOR
.ea0a	a9 20		lda #$20	   LDA #' '          ; set [SPACE]
.ea0c	91 d1		sta ($d1),y	   STA (LINPTR),Y    ; clear character in current screen line
.ea0e	88		dey		   DEY
.ea0f	10 f6		bpl $ea07	   BPL CSRX_Loop
.ea11	60		rts		   RTS
.ea12	ea		nop		   NOP
.ea13					  Display_Char_A_And_Color_X
.ea13	a8		tay		   TAY               ; copy character
.ea14	a9 02		lda #$02	   LDA #$02          ; set count to $02, usually $14 ??
.ea16	85 cd		sta $cd		   STA BLNCT         ; set cursor countdown
.ea18	20 24 ea	jsr $ea24	   JSR Set_COLRAM_Pointer
.ea1b	98		tya		   TYA               ; get character back
.ea1c					  Display_Char_And_Color
.ea1c	a4 d3		ldy $d3		   LDY CSRIDX        ; get cursor column
.ea1e	91 d1		sta ($d1),y	   STA (LINPTR),Y    ; save character from current screen line
.ea20	8a		txa		   TXA               ; copy colour to A
.ea21	91 f3		sta ($f3),y	   STA (USER),Y      ; save to colour RAM
.ea23	60		rts		   RTS
.ea24					  Set_COLRAM_Pointer
.ea24	a5 d1		lda $d1		   LDA LINPTR        ; get current screen line pointer low byte
.ea26	85 f3		sta $f3		   STA USER          ; save pointer to colour RAM low byte
.ea28	a5 d2		lda $d2		   LDA LINPTR+1      ; get current screen line pointer high byte
.ea2a	29 03		and #$03	   AND #$03          ; mask 0000 00xx, line memory page
.ea2c	09 d8		ora #$d8	   ORA #COLRAM_PAGE  ; set  1001 01xx, colour memory page
.ea2e	85 f4		sta $f4		   STA USER+1        ; save pointer to colour RAM high byte
.ea30	60		rts		   RTS
.ea31					  Default_IRQ
.ea31	20 ea ff	jsr $ffea	   JSR UDTIM         ; Update the system clock
.ea34	a5 cc		lda $cc		   LDA BLNSW         ; get cursor enable
.ea36	d0 29		bne $ea61	   BNE DIRQ_20       ; branch if not flash cursor
.ea38	c6 cd		dec $cd		   DEC BLNCT         ; else decrement cursor timing countdown
.ea3a	d0 25		bne $ea61	   BNE DIRQ_20       ; branch if not done
.ea3c	a9 14		lda #$14	   LDA #$14          ; set count
.ea3e	85 cd		sta $cd		   STA BLNCT         ; save cursor timing countdown
.ea40	a4 d3		ldy $d3		   LDY CSRIDX        ; get cursor column
.ea42	46 cf		lsr $cf		   LSR BLNON         ; shift b0 cursor blink phase into carry
.ea44	ae 87 02	ldx $0287	   LDX CSRCLR        ; get colour under cursor
.ea47	b1 d1		lda ($d1),y	   LDA (LINPTR),Y    ; get character from current screen line
.ea49	b0 11		bcs $ea5c	   BCS DIRQ_10       ; branch if cursor phase b0 was 1
.ea4b	e6 cf		inc $cf		   INC BLNON         ; set cursor blink phase to 1
.ea4d	85 ce		sta $ce		   STA GDBLN         ; save character under cursor
.ea4f	20 24 ea	jsr $ea24	   JSR Set_COLRAM_Pointer
.ea52	b1 f3		lda ($f3),y	   LDA (USER),Y      ; get colour RAM byte
.ea54	8d 87 02	sta $0287	   STA CSRCLR        ; save colour under cursor
.ea57	ae 86 02	ldx $0286	   LDX COLOR         ; get current colour code
.ea5a	a5 ce		lda $ce		   LDA GDBLN         ; get character under cursor
.ea5c					DIRQ_10
.ea5c	49 80		eor #$80	   EOR #$80          ; toggle b7 of character under cursor
.ea5e	20 1c ea	jsr $ea1c	   JSR Display_Char_And_Color
.ea61					DIRQ_20
.ea61	a5 01		lda $01		   LDA R6510
.ea63	29 10		and #$10	   AND #$10          ; mask cassette switch sense
.ea65	f0 0a		beq $ea71	   BEQ DIRQ_30      ; branch if cassette sense low
.ea67	a0 00		ldy #$00	   LDY #0
.ea69	84 c0		sty $c0		   STY CAS1          ; clear the tape motor interlock
.ea6b	a5 01		lda $01		   LDA R6510
.ea6d	09 20		ora #$20	   ORA #$20          ; set CA2 high, turn off motor
.ea6f	d0 08		bne $ea79	   BNE DIRQ_40      ; branch always
.ea71					DIRQ_30
.ea71	a5 c0		lda $c0		   LDA CAS1          ; get tape motor interlock
.ea73	d0 06		bne $ea7b	   BNE DIRQ_50      ; if cassette interlock <> 0 don't turn on motor
.ea75	a5 01		lda $01		   LDA $01           ; R6510
.ea77	29 1f		and #$1f	   AND #$1F          ; turn on motor
.ea79					DIRQ_40
.ea79	85 01		sta $01		   STA R6510
.ea7b					DIRQ_50
.ea7b	20 87 ea	jsr $ea87	   JSR Kernal_SCNKEY ; scan keyboard
.ea7e	ad 0d dc	lda $dc0d	   LDA CIA1_ICR      ; CIA1 Interrupt Control Register
.ea81	68		pla		   PLA
.ea82	a8		tay		   TAY
.ea83	68		pla		   PLA
.ea84	aa		tax		   TAX
.ea85	68		pla		   PLA
.ea86	40		rti		   RTI
.ea87					  Kernal_SCNKEY
.ea87	a9 00		lda #$00	   LDA #0
.ea89	8d 8d 02	sta $028d	   STA SHFLAG        ; clear keyboard shift/control/c= flag
.ea8c	a0 40		ldy #$40	   LDY #$40          ; set no key
.ea8e	84 cb		sty $cb		   STY SFDX          ; save which key
.ea90	8d 00 dc	sta $dc00	   STA KEYB_COL      ; clear keyboard column
.ea93	ae 01 dc	ldx $dc01	   LDX KEYB_ROW      ; get keyboard row
.ea96	e0 ff		cpx #$ff	   CPX #$FF          ; compare with all bits set
.ea98	f0 61		beq $eafb	   BEQ KeSc_50       ; if no key pressed clear current key and exit
.ea9a	a8		tay		   TAY               ; clear key count
.ea9b	a9 81		lda #$81	   LDA #<KBD_NORMAL  ; get decode table low byte
.ea9d	85 f5		sta $f5		   STA KBDPTR        ; set keyboard pointer low byte
.ea9f	a9 eb		lda #$eb	   LDA #>KBD_NORMAL  ; get decode table high byte
.eaa1	85 f6		sta $f6		   STA KBDPTR+1      ; set keyboard pointer high byte
.eaa3	a9 fe		lda #$fe	   LDA #$FE
.eaa5	8d 00 dc	sta $dc00	   STA KEYB_COL      ; select keyboard col 0
.eaa8					KeSc_05
.eaa8	a2 08		ldx #$08	   LDX #8            ; set row count
.eaaa	48		pha		   PHA
.eaab					KeSc_10
.eaab	ad 01 dc	lda $dc01	   LDA KEYB_ROW      ; get VIA/CIA keyboard row
.eaae	cd 01 dc	cmp $dc01	   CMP KEYB_ROW      ; compare with itself
.eab1	d0 f8		bne $eaab	   BNE KeSc_10       ; loop if changing
.eab3					KeSc_15
.eab3	4a		lsr a		   LSR A             ; shift row to Cb
.eab4	b0 16		bcs $eacc	   BCS KeSc_30       ; if no key closed on this row go do next row
.eab6	48		pha		   PHA               ; save row
.eab7	b1 f5		lda ($f5),y	   LDA (KBDPTR),Y    ; get character from decode table
.eab9	c9 05		cmp #$05	   CMP #$05          ; compare with $05, there is no $05 key but the control
.eabb	b0 0c		bcs $eac9	   BCS KeSc_20       ; if not shift/control/c=/stop go save key count
.eabd	c9 03		cmp #$03	   CMP #$03          ; compare with $03, stop
.eabf	f0 08		beq $eac9	   BEQ KeSc_20       ; if stop go save key count and continue
.eac1	0d 8d 02	ora $028d	   ORA SHFLAG        ; OR keyboard shift/control/c= flag
.eac4	8d 8d 02	sta $028d	   STA SHFLAG        ; save keyboard shift/control/c= flag
.eac7	10 02		bpl $eacb	   BPL KeSc_25       ; skip save key, branch always
.eac9					KeSc_20
.eac9	84 cb		sty $cb		   STY SFDX          ; save key count
.eacb					KeSc_25
.eacb	68		pla		   PLA               ; restore row
.eacc					KeSc_30
.eacc	c8		iny		   INY               ; increment key count
.eacd	c0 41		cpy #$41	   CPY #$41          ; compare with max+1
.eacf	b0 0b		bcs $eadc	   BCS KeSc_35       ; exit loop if >= max+1
.ead1	ca		dex		   DEX               ; decrement row count
.ead2	d0 df		bne $eab3	   BNE KeSc_15       ; loop if more rows to do
.ead4	38		sec		   SEC               ; set carry for keyboard column shift
.ead5	68		pla		   PLA
.ead6	2a		rol a		   ROL A
.ead7	8d 00 dc	sta $dc00	   STA KEYB_COL
.eada	d0 cc		bne $eaa8	   BNE KeSc_05      ; loop for next column, branch always
.eadc					KeSc_35
.eadc	68		pla		   PLA
.eadd	6c 8f 02	jmp ($028f)	   JMP (KEYLOG)      ; normally Keyboard_Decoder
.eae0					KeSc_40
.eae0	a4 cb		ldy $cb		   LDY SFDX          ; get saved key count
.eae2	b1 f5		lda ($f5),y	   LDA (KBDPTR),Y    ; get character from decode table
.eae4	aa		tax		   TAX               ; copy character to X
.eae5	c4 c5		cpy $c5		   CPY LSTX          ; compare key count with last key count
.eae7	f0 07		beq $eaf0	   BEQ KeSc_45       ; if this key = current key, key held, go test repeat
.eae9	a0 10		ldy #$10	   LDY #$10          ; set repeat delay count
.eaeb	8c 8c 02	sty $028c	   STY KRPTDL        ; save repeat delay count
.eaee	d0 36		bne $eb26	   BNE KeSc_65       ; go save key to buffer and exit, branch always
.eaf0					KeSc_45
.eaf0	29 7f		and #$7f	   AND #$7F          ; clear b7
.eaf2	2c 8a 02	bit $028a	   BIT KEYRPT        ; test key repeat
.eaf5	30 16		bmi $eb0d	   BMI KeSc_55       ; branch if repeat all
.eaf7	70 49		bvs $eb42	   BVS KeSc_70       ; branch if repeat none
.eaf9	c9 7f		cmp #$7f	   CMP #$7F          ; compare with end marker
.eafb					KeSc_50
.eafb	f0 29		beq $eb26	   BEQ KeSc_65       ; if $00/end marker go save key to buffer and exit
.eafd	c9 14		cmp #$14	   CMP #$14          ; compare with [INSERT]/[DELETE]
.eaff	f0 0c		beq $eb0d	   BEQ KeSc_55       ; if [INSERT]/[DELETE] go test for repeat
.eb01	c9 20		cmp #$20	   CMP #' '          ; compare with [SPACE]
.eb03	f0 08		beq $eb0d	   BEQ KeSc_55       ; if [SPACE] go test for repeat
.eb05	c9 1d		cmp #$1d	   CMP #$1D          ; compare with [CURSOR RIGHT]
.eb07	f0 04		beq $eb0d	   BEQ KeSc_55       ; if [CURSOR RIGHT] go test for repeat
.eb09	c9 11		cmp #$11	   CMP #$11          ; compare with [CURSOR DOWN]
.eb0b	d0 35		bne $eb42	   BNE KeSc_70       ; if not [CURSOR DOWN] just exit
.eb0d					KeSc_55
.eb0d	ac 8c 02	ldy $028c	   LDY KRPTDL        ; get repeat delay counter
.eb10	f0 05		beq $eb17	   BEQ KeSc_60       ; branch if delay expired
.eb12	ce 8c 02	dec $028c	   DEC KRPTDL        ; else decrement repeat delay counter
.eb15	d0 2b		bne $eb42	   BNE KeSc_70       ; branch if delay not expired
.eb17					KeSc_60
.eb17	ce 8b 02	dec $028b	   DEC KRPTSP        ; decrement repeat speed counter
.eb1a	d0 26		bne $eb42	   BNE KeSc_70       ; branch if repeat speed count not expired
.eb1c	a0 04		ldy #$04	   LDY #$04          ; set for 4/60ths of a second
.eb1e	8c 8b 02	sty $028b	   STY KRPTSP        ; set repeat speed counter
.eb21	a4 c6		ldy $c6		   LDY NDX           ; get keyboard buffer index
.eb23	88		dey		   DEY               ; decrement it
.eb24	10 1c		bpl $eb42	   BPL KeSc_70       ; if the buffer isn't empty just exit
.eb26					KeSc_65
.eb26	a4 cb		ldy $cb		   LDY SFDX          ; get the key count
.eb28	84 c5		sty $c5		   STY LSTX          ; save as the current key count
.eb2a	ac 8d 02	ldy $028d	   LDY SHFLAG        ; get keyboard shift/control/c= flag
.eb2d	8c 8e 02	sty $028e	   STY LSTSHF        ; save as last keyboard shift pattern
.eb30	e0 ff		cpx #$ff	   CPX #$FF          ; compare character with table end marker or no key
.eb32	f0 0e		beq $eb42	   BEQ KeSc_70       ; if table end marker or no key just exit
.eb34	8a		txa		   TXA               ; copy character to A
.eb35	a6 c6		ldx $c6		   LDX NDX           ; get keyboard buffer index
.eb37	ec 89 02	cpx $0289	   CPX KBMAXL        ; compare with keyboard buffer size
.eb3a	b0 06		bcs $eb42	   BCS KeSc_70       ; if buffer full just exit
.eb3c	9d 77 02	sta $0277,x	   STA KBUFFR,X      ; save character to keyboard buffer
.eb3f	e8		inx		   INX               ; increment index
.eb40	86 c6		stx $c6		   STX NDX           ; save keyboard buffer index
.eb42					KeSc_70
.eb42	a9 7f		lda #$7f	   LDA #STND_COL     ; col 3 on VIC / col 7 on C64
.eb44	8d 00 dc	sta $dc00	   STA KEYB_COL      ; set VIA/CIA keyboard column
.eb47	60		rts		   RTS
.eb48					  Keyboard_Decoder
.eb48	ad 8d 02	lda $028d	   LDA SHFLAG        ; get keyboard shift/control/c= flag
.eb4b	c9 03		cmp #$03	   CMP #$03          ; compare with [SHIFT][C=]
.eb4d	d0 15		bne $eb64	   BNE KeDe_10       ; branch if not
.eb4f	cd 8e 02	cmp $028e	   CMP LSTSHF        ; compare with last
.eb52	f0 ee		beq $eb42	   BEQ KeSc_70       ; exit if still the same
.eb54	ad 91 02	lda $0291	   LDA MODE          ; get shift mode switch $00 = enabled, $80 = locked
.eb57	30 1d		bmi $eb76	   BMI KeDe_30       ; if locked continue keyboard decode
.eb59	ad 18 d0	lda $d018	   LDA MEM_CONTROL   ; get start of character memory, ROM
.eb5c	49 02		eor #$02	   EOR #$02          ; toggle $8000,$8800
.eb5e	8d 18 d0	sta $d018	   STA MEM_CONTROL   ; set start of character memory, ROM
.eb61	4c 76 eb	jmp $eb76	   JMP KeDe_30       ; continue keyboard decode
.eb64					KeDe_10
.eb64	0a		asl a		   ASL A             ; convert flag to index
.eb65	c9 08		cmp #$08	   CMP #8            ; compare with [CTRL]
.eb67	90 02		bcc $eb6b	   BCC KeDe_20       ; branch if not [CTRL] pressed
.eb69	a9 06		lda #$06	   LDA #6            ; [CTRL] : table 3 : index 6
.eb6b					KeDe_20
.eb6b	aa		tax		   TAX               ; copy index to X
.eb6c	bd 79 eb	lda $eb79,x	   LDA KBD_Decode_Pointer,X
.eb6f	85 f5		sta $f5		   STA KBDPTR
.eb71	bd 7a eb	lda $eb7a,x	   LDA KBD_Decode_Pointer+1,X
.eb74	85 f6		sta $f6		   STA KBDPTR+1
.eb76					KeDe_30
.eb76	4c e0 ea	jmp $eae0	   JMP KeSc_40       ; continue keyboard decode
.eb79					  KBD_Decode_Pointer
>eb79	81 eb				   .word   KBD_NORMAL  ; 0   normal
>eb7b	c2 eb				   .word   KBD_SHIFTED ; 1   shifted
>eb7d	03 ec				   .word   KBD_CBMKEY  ; 2   commodore
>eb7f	78 ec				   .word   KBD_CONTROL ; 3   control
.eb81					KBD_NORMAL
>eb81	14 0d 1d 88 85 86 87 11		   .BYTE $14,$0d,$1d,$88,$85,$86,$87,$11
>eb89	33 57 41 34 5a 53 45 01		   .BYTE $33,$57,$41,$34,$5a,$53,$45,$01
>eb91	35 52 44 36 43 46 54 58		   .BYTE $35,$52,$44,$36,$43,$46,$54,$58
>eb99	37 59 47 38 42 48 55 56		   .BYTE $37,$59,$47,$38,$42,$48,$55,$56
>eba1	39 49 4a 30 4d 4b 4f 4e		   .BYTE $39,$49,$4a,$30,$4d,$4b,$4f,$4e
>eba9	2b 50 4c 2d 2e 3a 40 2c		   .BYTE $2b,$50,$4c,$2d,$2e,$3a,$40,$2c
>ebb1	5c 2a 3b 13 01 3d 5e 2f		   .BYTE $5c,$2a,$3b,$13,$01,$3d,$5e,$2f
>ebb9	31 5f 04 32 20 02 51 03		   .BYTE $31,$5f,$04,$32,$20,$02,$51,$03
>ebc1	ff				   .BYTE $ff
.ebc2					KBD_SHIFTED
>ebc2	94 8d 9d 8c 89 8a 8b 91		   .BYTE $94,$8d,$9d,$8c,$89,$8a,$8b,$91
>ebca	23 d7 c1 24 da d3 c5 01		   .BYTE $23,$d7,$c1,$24,$da,$d3,$c5,$01
>ebd2	25 d2 c4 26 c3 c6 d4 d8		   .BYTE $25,$d2,$c4,$26,$c3,$c6,$d4,$d8
>ebda	27 d9 c7 28 c2 c8 d5 d6		   .BYTE $27,$d9,$c7,$28,$c2,$c8,$d5,$d6
>ebe2	29 c9 ca 30 cd cb cf ce		   .BYTE $29,$c9,$ca,$30,$cd,$cb,$cf,$ce
>ebea	db d0 cc dd 3e 5b ba 3c		   .BYTE $db,$d0,$cc,$dd,$3e,$5b,$ba,$3c
>ebf2	a9 c0 5d 93 01 3d de 3f		   .BYTE $a9,$c0,$5d,$93,$01,$3d,$de,$3f
>ebfa	21 5f 04 22 a0 02 d1 83		   .BYTE $21,$5f,$04,$22,$a0,$02,$d1,$83
>ec02	ff				   .BYTE $ff
.ec03					KBD_CBMKEY
>ec03	94 8d 9d 8c 89 8a 8b 91		   .BYTE $94,$8d,$9d,$8c,$89,$8a,$8b,$91
>ec0b	96 b3 b0 97 ad ae b1 01		   .BYTE $96,$b3,$b0,$97,$ad,$ae,$b1,$01
>ec13	98 b2 ac 99 bc bb a3 bd		   .BYTE $98,$b2,$ac,$99,$bc,$bb,$a3,$bd
>ec1b	9a b7 a5 9b bf b4 b8 be		   .BYTE $9a,$b7,$a5,$9b,$bf,$b4,$b8,$be
>ec23	29 a2 b5 30 a7 a1 b9 aa		   .BYTE $29,$a2,$b5,$30,$a7,$a1,$b9,$aa
>ec2b	a6 af b6 dc 3e 5b a4 3c		   .BYTE $a6,$af,$b6,$dc,$3e,$5b,$a4,$3c
>ec33	a8 df 5d 93 01 3d de 3f		   .BYTE $a8,$df,$5d,$93,$01,$3d,$de,$3f
>ec3b	81 5f 04 95 a0 02 ab 83		   .BYTE $81,$5f,$04,$95,$a0,$02,$ab,$83
>ec43	ff				   .BYTE $ff
.ec44					  Switch_Text_Graphics
.ec44	c9 0e		cmp #$0e	   CMP #$0E          ; compare with [SWITCH TO LOWER CASE]
.ec46	d0 07		bne $ec4f	   BNE STG_10        ; branch if not [SWITCH TO LOWER CASE]
.ec48	ad 18 d0	lda $d018	   LDA MEM_CONTROL
.ec4b	09 02		ora #$02	   ORA #2
.ec4d	d0 09		bne $ec58	   BNE STG_20
.ec4f					STG_10
.ec4f	c9 8e		cmp #$8e	   CMP #$8E          ; compare with [SWITCH TO UPPER CASE]
.ec51	d0 0b		bne $ec5e	   BNE STG_40        ; branch if not [SWITCH TO UPPER CASE]
.ec53	ad 18 d0	lda $d018	   LDA MEM_CONTROL
.ec56	29 fd		and #$fd	   AND #$FD
.ec58					STG_20
.ec58	8d 18 d0	sta $d018	   STA MEM_CONTROL   ; save start of character memory, ROM
.ec5b					STG_30
.ec5b	4c a8 e6	jmp $e6a8	   JMP InsC_50       ; restore registers, set quote flag and exit
.ec5e					STG_40
.ec5e	c9 08		cmp #$08	   CMP #$08          ; compare with disable [SHIFT][C=]
.ec60	d0 07		bne $ec69	   BNE STG_50        ; branch if not disable [SHIFT][C=]
.ec62	a9 80		lda #$80	   LDA #$80          ; set to lock shift mode switch
.ec64	0d 91 02	ora $0291	   ORA MODE          ; OR with shift mode switch, $00 = enabled, $80 = locked
.ec67	30 09		bmi $ec72	   BMI STG_60
.ec69					STG_50
.ec69	c9 09		cmp #$09	   CMP #$09          ; compare with enable [SHIFT][C=]
.ec6b	d0 ee		bne $ec5b	   BNE STG_30        ; exit if not enable [SHIFT][C=]    ##### start ####
.ec6d	a9 7f		lda #$7f	   LDA #$7F          ; set to unlock shift mode switch
.ec6f	2d 91 02	and $0291	   AND MODE          ; AND with shift mode switch, $00 = enabled, $80 = locked
.ec72					STG_60
.ec72	8d 91 02	sta $0291	   STA MODE          ; save shift mode switch
.ec75	4c a8 e6	jmp $e6a8	   JMP InsC_50
.ec78					KBD_CONTROL
>ec78	ff ff ff ff ff ff ff ff		  .BYTE $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff
>ec80	1c 17 01 9f 1a 13 05 ff		  .BYTE $1c,$17,$01,$9f,$1a,$13,$05,$ff
>ec88	9c 12 04 1e 03 06 14 18		  .BYTE $9c,$12,$04,$1e,$03,$06,$14,$18
>ec90	1f 19 07 9e 02 08 15 16		  .BYTE $1f,$19,$07,$9e,$02,$08,$15,$16
>ec98	12 09 0a 92 0d 0b 0f 0e		  .BYTE $12,$09,$0a,$92,$0d,$0b,$0f,$0e
>eca0	ff 10 0c ff ff 1b 00 ff		  .BYTE $ff,$10,$0c,$ff,$ff,$1b,$00,$ff
>eca8	1c ff 1d ff ff 1f 1e ff		  .BYTE $1c,$ff,$1d,$ff,$ff,$1f,$1e,$ff
>ecb0	90 06 ff 05 ff ff 11 ff		  .BYTE $90,$06,$ff,$05,$ff,$ff,$11,$ff
>ecb8	ff				  .BYTE $ff
.ecb9					VIC_INIT
>ecb9	00 00 00 00 00 00 00 00		   .BYTE $00,$00,$00,$00,$00,$00,$00,$00
>ecc1	00 00 00 00 00 00 00 00		   .BYTE $00,$00,$00,$00,$00,$00,$00,$00
>ecc9	00 9b 37 00 00 00 08 00		   .BYTE $00,$9b,$37,$00,$00,$00,$08,$00
>ecd1	14 0f 00 00 00 00 00 00		   .BYTE $14,$0f,$00,$00,$00,$00,$00,$00
>ecd9	0e 06 01 02 03 04 00 01		   .BYTE $0e,$06,$01,$02,$03,$04,$00,$01
>ece1	02 03 04 05 06 07		   .BYTE $02,$03,$04,$05,$06,$07
>ece7	4c 4f 41 44 0d 52 55 4e		RUNKEY .TEXT "LOAD",$0D,"RUN",$0D
>ecef	0d
.ecf0					  Line_Adress_Low
>ecf0	00 28 50 78 a0 c8 f0 18		   .byte $00,$28,$50,$78,$a0,$c8,$f0,$18
>ecf8	40 68 90 b8 e0 08 30 58		   .byte $40,$68,$90,$b8,$e0,$08,$30,$58
>ed00	80 a8 d0 f8 20 48 70 98		   .byte $80,$a8,$d0,$f8,$20,$48,$70,$98
>ed08	c0				   .byte $c0
.ed09					  Kernal_TALK
.ed09	09 40		ora #$40	   ORA #$40          ; OR with the TALK command
>ed0b	2c				   .byte   $2C       ; skip next 2 bytes
.ed0c					  Kernal_LISTEN
.ed0c	09 20		ora #$20	   ORA #$20          ; OR with the LISTEN command
.ed0e	20 a4 f0	jsr $f0a4	   JSR RS232_Stop
.ed11					  IEC_Send_Control_Byte
.ed11	48		pha		   PHA               ; save device address
.ed12	24 94		bit $94		   BIT C3PO          ; test deferred character flag
.ed14	10 0a		bpl $ed20	   BPL ISCB_10       ; branch if no defered character
.ed16	38		sec		   SEC               ; flag EOI
.ed17	66 a3		ror $a3		   ROR TSFCNT        ; rotate into EOI flag byte
.ed19	20 40 ed	jsr $ed40	   JSR IEC_Send_Byte
.ed1c	46 94		lsr $94		   LSR C3PO          ; clear deferred character flag
.ed1e	46 a3		lsr $a3		   LSR TSFCNT        ; clear EOI flag
.ed20					ISCB_10
.ed20	68		pla		   PLA               ; device address OR'ed with command
.ed21	85 95		sta $95		   STA BSOUR         ; save as serial defered character
.ed23	78		sei		   SEI
.ed24	20 97 ee	jsr $ee97	   JSR CLR_IEC_DAT   ; set IEC data out high (0)
.ed27	c9 3f		cmp #$3f	   CMP #$3F          ; compare read byte with $3F
.ed29	d0 03		bne $ed2e	   BNE ISCB_20       ; branch if not $3F, this branch will always be taken
.ed2b	20 85 ee	jsr $ee85	   JSR CLR_IEC_CLK   ; set IEC clock out high (0)
.ed2e					ISCB_20
.ed2e	ad 00 dd	lda $dd00	   LDA IEC_DRAN      ; get VIA 1 DRA, no handshake
.ed31	09 08		ora #$08	   ORA #IEC_ATN_BIT  ; set IEC ATN low (1)
.ed33	8d 00 dd	sta $dd00	   STA IEC_DRAN      ; set VIA 1 DRA, no handshake
.ed36					  IEC_Delay_And_Send_Byte
.ed36	78		sei		   SEI
.ed37	20 8e ee	jsr $ee8e	   JSR SET_IEC_CLK   ; set IEC clock out low
.ed3a	20 97 ee	jsr $ee97	   JSR CLR_IEC_DAT   ; set IEC data  out high
.ed3d	20 b3 ee	jsr $eeb3	   JSR WAIT_1MS      ; 1ms delay
.ed40					  IEC_Send_Byte
.ed40	78		sei		   SEI               ; disable interrupts
.ed41	20 97 ee	jsr $ee97	   JSR CLR_IEC_DAT   ; set serial data out high
.ed44	20 a9 ee	jsr $eea9	   JSR GET_IEC_CLK   ; get serial clock status
.ed47	b0 64		bcs $edad	   BCS Device_Not_Present
.ed49	20 85 ee	jsr $ee85	   JSR CLR_IEC_CLK   ; set serial clock high
.ed4c	24 a3		bit $a3		   BIT TSFCNT        ; test EOI flag
.ed4e	10 0a		bpl $ed5a	   BPL ISCB_50       ; branch if not EOI
.ed50					ISCB_30
.ed50	20 a9 ee	jsr $eea9	   JSR GET_IEC_CLK   ; get serial clock status
.ed53	90 fb		bcc $ed50	   BCC ISCB_30       ; loop if data low
.ed55					ISCB_40
.ed55	20 a9 ee	jsr $eea9	   JSR GET_IEC_CLK   ; get serial clock status
.ed58	b0 fb		bcs $ed55	   BCS ISCB_40       ; loop if data high
.ed5a					ISCB_50
.ed5a	20 a9 ee	jsr $eea9	   JSR GET_IEC_CLK   ; get serial clock status
.ed5d	90 fb		bcc $ed5a	   BCC ISCB_50       ; loop if data low
.ed5f	20 8e ee	jsr $ee8e	   JSR SET_IEC_CLK   ; set serial clock low
.ed62	a9 08		lda #$08	   LDA #$08          ; eight bits to do
.ed64	85 a5		sta $a5		   STA CNTDN         ; set serial bus bit count
.ed66					ISCB_60
.ed66	ad 00 dd	lda $dd00	   LDA IEC_DRAN      ; get VIA 1 DRA, no handshake
.ed69	cd 00 dd	cmp $dd00	   CMP IEC_DRAN      ; compare with self
.ed6c	d0 f8		bne $ed66	   BNE ISCB_60       ; loop if changing
.ed6e	0a		asl a		   ASL A             ; serial clock to carry
.ed6f	90 3f		bcc $edb0	   BCC IEC_Timeout
.ed71	66 95		ror $95		   ROR BSOUR         ; rotate transmit byte
.ed73	b0 05		bcs $ed7a	   BCS ISCB_70       ; branch if bit = 1
.ed75	20 a0 ee	jsr $eea0	   JSR SET_IEC_DAT   ; else set serial data out low
.ed78	d0 03		bne $ed7d	   BNE ISCB_80       ; branch always
.ed7a					ISCB_70
.ed7a	20 97 ee	jsr $ee97	   JSR CLR_IEC_DAT   ; set serial data out high
.ed7d					ISCB_80
.ed7d	20 85 ee	jsr $ee85	   JSR CLR_IEC_CLK   ; set serial clock high
.ed80	ea		nop		   NOP
.ed81	ea		nop		   NOP
.ed82	ea		nop		   NOP
.ed83	ea		nop		   NOP
.ed84	ad 00 dd	lda $dd00	   LDA IEC_PCR       ; get VIA/CIA PCR
.ed87	29 df		and #$df	   AND #$DF          ; set CB2 low, serial data out high
.ed89	09 10		ora #$10	   ORA #IEC_CLK_BIT  ; set CA2 high, serial clock out low
.ed8b	8d 00 dd	sta $dd00	   STA IEC_PCR
.ed8e	c6 a5		dec $a5		   DEC CNTDN         ; decrement serial bus bit count
.ed90	d0 d4		bne $ed66	   BNE ISCB_60       ; loop if not all done
.ed92	a9 04		lda #$04	   LDA #4            ; wait for up to about 1ms
.ed94	8d 07 dc	sta $dc07	   STA IEC_TIM_H     ; set VIA/CIA timer high
.ed97					ISCB_90
.ed97	a9 19		lda #$19	   LDA #$19
.ed99	8d 0f dc	sta $dc0f	   STA CIA1_CRB      ; CIA1 Control Register B
.ed9c	ad 0d dc	lda $dc0d	   LDA CIA1_ICR      ; CIA1 Interrupt Control Register
.ed9f					ISCB_95
.ed9f	ad 0d dc	lda $dc0d	   LDA CIA1_ICR      ; CIA1 Interrupt Control Register
.eda2	29 02		and #$02	   AND #2
.eda4	d0 0a		bne $edb0	   BNE IEC_Timeout
.eda6	20 a9 ee	jsr $eea9	   JSR GET_IEC_CLK   ; get serial clock status
.eda9	b0 f4		bcs $ed9f	   BCS ISCB_95
.edab	58		cli		   CLI
.edac	60		rts		   RTS
.edad					  Device_Not_Present
.edad	a9 80		lda #$80	   LDA #$80          ; error $80, device not present
>edaf	2c				   .byte   $2C       ; skip next statement
.edb0					  IEC_Timeout
.edb0	a9 03		lda #$03	   LDA #$03          ; error $03, write timeout
.edb2					  Set_IEC_Status
.edb2	20 1c fe	jsr $fe1c	   JSR Ora_Status
.edb5	58		cli		   CLI               ; enable interrupts
.edb6	18		clc		   CLC               ; clear for branch
.edb7	90 4a		bcc $ee03	   BCC KeUN_10      ; ATN high, delay, clock high then data high, branch always
.edb9					  Kernal_SECOND
.edb9	85 95		sta $95		   STA BSOUR         ; save defered byte
.edbb	20 36 ed	jsr $ed36	   JSR IEC_Delay_And_Send_Byte
.edbe					  IEC_ATN_High
.edbe	ad 00 dd	lda $dd00	   LDA IEC_DRAN      ; get VIA 1 DRA, no handshake
.edc1	29 f7		and #$f7	   AND #$F7          ; set serial ATN high
.edc3	8d 00 dd	sta $dd00	   STA IEC_DRAN      ; set VIA 1 DRA, no handshake
.edc6	60		rts		   RTS
.edc7					  Kernal_TKSA
.edc7	85 95		sta $95		   STA BSOUR         ; save the secondary address byte to transmit
.edc9	20 36 ed	jsr $ed36	   JSR IEC_Delay_And_Send_Byte
.edcc					  IEC_Finish_Send
.edcc	78		sei		   SEI               ; disable interrupts
.edcd	20 a0 ee	jsr $eea0	   JSR SET_IEC_DAT   ; set serial data out low
.edd0	20 be ed	jsr $edbe	   JSR IEC_ATN_High  ; set serial ATN high
.edd3	20 85 ee	jsr $ee85	   JSR CLR_IEC_CLK   ; set serial clock high
.edd6					IFS_10
.edd6	20 a9 ee	jsr $eea9	   JSR GET_IEC_CLK   ; get serial clock status
.edd9	30 fb		bmi $edd6	   BMI IFS_10        ; branch if clock high
.eddb	58		cli		   CLI               ; enable interrupts
.eddc	60		rts		   RTS
.eddd					  Kernal_CIOUT
.eddd	24 94		bit $94		   BIT C3PO          ; test deferred character flag
.eddf	30 05		bmi $ede6	   BMI KeCI_10       ; branch if defered character
.ede1	38		sec		   SEC               ; set carry
.ede2	66 94		ror $94		   ROR C3PO          ; shift into deferred character flag
.ede4	d0 05		bne $edeb	   BNE KeCI_20       ; save byte and exit, branch always
.ede6					KeCI_10
.ede6	48		pha		   PHA               ; save byte
.ede7	20 40 ed	jsr $ed40	   JSR IEC_Send_Byte
.edea	68		pla		   PLA               ; restore byte
.edeb					KeCI_20
.edeb	85 95		sta $95		   STA BSOUR         ; save defered byte
.eded	18		clc		   CLC               ; flag ok
.edee	60		rts		   RTS
.edef					  Kernal_UNTLK
.edef	78		sei		   SEI
.edf0	20 8e ee	jsr $ee8e	   JSR SET_IEC_CLK
.edf3	ad 00 dd	lda $dd00	   LDA IEC_DRAN      ; get VIA 1 DRA, no handshake
.edf6	09 08		ora #$08	   ORA #IEC_ATN_BIT  ; set serial ATN low
.edf8	8d 00 dd	sta $dd00	   STA IEC_DRAN      ; set VIA 1 DRA, no handshake
.edfb	a9 5f		lda #$5f	   LDA #$5F          ; set the UNTALK command
>edfd	2c				   .byte   $2C       ; skip next two bytes
.edfe					  Kernal_UNLSN
.edfe	a9 3f		lda #$3f	   LDA #$3F          ; set the UNLISTEN command
.ee00	20 11 ed	jsr $ed11	   JSR IEC_Send_Control_Byte
.ee03					KeUN_10
.ee03	20 be ed	jsr $edbe	   JSR IEC_ATN_High  ; set serial ATN high
.ee06					  IEC_Delay_CLK_High_DATA_High
.ee06	8a		txa		   TXA               ; save device number
.ee07	a2 0a		ldx #$0a	   LDX #10           ; short delay
.ee09					IDel_10
.ee09	ca		dex		   DEX               ; decrement count
.ee0a	d0 fd		bne $ee09	   BNE IDel_10       ; loop if not all done
.ee0c	aa		tax		   TAX               ; restore device number
.ee0d	20 85 ee	jsr $ee85	   JSR CLR_IEC_CLK   ; set serial clock high
.ee10	4c 97 ee	jmp $ee97	   JMP CLR_IEC_DAT   ; set serial data out high and return
.ee13					  Kernal_ACPTR
.ee13	78		sei		   SEI               ; disable interrupts
.ee14	a9 00		lda #$00	   LDA #0
.ee16					KeAC_03
.ee16	85 a5		sta $a5		   STA CNTDN         ; clear serial bus bit count
.ee18	20 85 ee	jsr $ee85	   JSR CLR_IEC_CLK   ; set serial clock high
.ee1b					KeAC_05
.ee1b	20 a9 ee	jsr $eea9	   JSR GET_IEC_CLK   ; get serial clock status
.ee1e	10 fb		bpl $ee1b	   BPL KeAC_05       ; loop while clock low
.ee20					KeAC_10
.ee20	a9 01		lda #$01	   LDA #$01          ; set timeout count high byte
.ee22	8d 07 dc	sta $dc07	   STA IEC_TIM_H
.ee25					KeAC_15
.ee25	a9 19		lda #$19	   LDA #$19
.ee27	8d 0f dc	sta $dc0f	   STA CIA1_CRB      ; CIA1 Control Register B
.ee2a	20 97 ee	jsr $ee97	   JSR CLR_IEC_DAT   ; set serial data out high
.ee2d	ad 0d dc	lda $dc0d	   LDA CIA1_ICR      ; CIA1 Interrupt Control Register
.ee30					KeAC_20
.ee30	ad 0d dc	lda $dc0d	   LDA IEC_IFR       ; get VIA 2 IFR
.ee33	29 02		and #$02	   AND #IEC_IFR_BIT  ; mask T2 interrupt
.ee35	d0 07		bne $ee3e	   BNE KeAC_25       ; branch if T2 interrupt
.ee37	20 a9 ee	jsr $eea9	   JSR GET_IEC_CLK   ; get serial clock status
.ee3a	30 f4		bmi $ee30	   BMI KeAC_20       ; loop if clock high
.ee3c	10 18		bpl $ee56	   BPL KeAC_35       ; else go se 8 bits to do, branch always
.ee3e					KeAC_25
.ee3e	a5 a5		lda $a5		   LDA CNTDN         ; get serial bus bit count
.ee40	f0 05		beq $ee47	   BEQ KeAC_30       ; if not already EOI then go flag EOI
.ee42	a9 02		lda #$02	   LDA #$02          ; error $02, read timeour
.ee44	4c b2 ed	jmp $edb2	   JMP Set_IEC_Status
.ee47					KeAC_30
.ee47	20 a0 ee	jsr $eea0	   JSR SET_IEC_DAT    ; set serial data out low
.ee4a	20 85 ee	jsr $ee85	   JSR CLR_IEC_CLK
.ee4d	a9 40		lda #$40	   LDA #$40          ; set EOI
.ee4f	20 1c fe	jsr $fe1c	   JSR Ora_Status
.ee52	e6 a5		inc $a5		   INC CNTDN         ; increment serial bus bit count, do error on next timeout
.ee54	d0 ca		bne $ee20	   BNE KeAC_10       ; go try again
.ee56					KeAC_35
.ee56	a9 08		lda #$08	   LDA #$08          ; 8 bits to do
.ee58	85 a5		sta $a5		   STA CNTDN         ; set serial bus bit count
.ee5a					KeAC_40
.ee5a	ad 00 dd	lda $dd00	   LDA IEC_DRAN      ; get VIA 1 DRA, no handshake
.ee5d	cd 00 dd	cmp $dd00	   CMP IEC_DRAN      ; compare with self
.ee60	d0 f8		bne $ee5a	   BNE KeAC_40       ; loop if changing
.ee62	0a		asl a		   ASL A             ; serial clock into carry
.ee63	10 f5		bpl $ee5a	   BPL KeAC_40       ; loop while serial clock low
.ee65	66 a4		ror $a4		   ROR TBTCNT        ; shift data bit into receive byte
.ee67					KeAC_45
.ee67	ad 00 dd	lda $dd00	   LDA IEC_DRAN      ; get VIA 1 DRA, no handshake
.ee6a	cd 00 dd	cmp $dd00	   CMP IEC_DRAN      ; compare with self
.ee6d	d0 f8		bne $ee67	   BNE KeAC_45       ; loop if changing
.ee6f	0a		asl a		   ASL A             ; serial clock into carry
.ee70	30 f5		bmi $ee67	   BMI KeAC_45       ; loop while serial clock high
.ee72	c6 a5		dec $a5		   DEC CNTDN         ; decrement serial bus bit count
.ee74	d0 e4		bne $ee5a	   BNE KeAC_40       ; loop if not all done
.ee76	20 a0 ee	jsr $eea0	   JSR SET_IEC_DAT   ; set serial data out low
.ee79	24 90		bit $90		   BIT STATUS        ; get serial status byte
.ee7b	50 03		bvc $ee80	   BVC KeAC_50       ; branch if no error
.ee7d	20 06 ee	jsr $ee06	   JSR IEC_Delay_CLK_High_DATA_High
.ee80					KeAC_50
.ee80	a5 a4		lda $a4		   LDA TBTCNT        ; get receive byte
.ee82	58		cli		   CLI               ; enable interrupts
.ee83	18		clc		   CLC
.ee84	60		rts		   RTS
.ee85					  CLR_IEC_CLK
.ee85	ad 00 dd	lda $dd00	   LDA IEC_PCR
.ee88	29 ef		and #$ef	   AND #~IEC_CLK_BIT
.ee8a	8d 00 dd	sta $dd00	   STA IEC_PCR
.ee8d	60		rts		   RTS
.ee8e					  SET_IEC_CLK
.ee8e	ad 00 dd	lda $dd00	   LDA IEC_PCR
.ee91	09 10		ora #$10	   ORA #IEC_CLK_BIT
.ee93	8d 00 dd	sta $dd00	   STA IEC_PCR
.ee96	60		rts		   RTS
.ee97					  CLR_IEC_DAT
.ee97	ad 00 dd	lda $dd00	   LDA IEC_PCR
.ee9a	29 df		and #$df	   AND #~IEC_DAT_BIT
.ee9c	8d 00 dd	sta $dd00	   STA IEC_PCR
.ee9f	60		rts		   RTS
.eea0					  SET_IEC_DAT
.eea0	ad 00 dd	lda $dd00	   LDA IEC_PCR
.eea3	09 20		ora #$20	   ORA #IEC_DAT_BIT
.eea5	8d 00 dd	sta $dd00	   STA IEC_PCR
.eea8	60		rts		   RTS
.eea9					  GET_IEC_CLK
.eea9	ad 00 dd	lda $dd00	   LDA IEC_PCR
.eeac	cd 00 dd	cmp $dd00	   CMP IEC_PCR
.eeaf	d0 f8		bne $eea9	   BNE GET_IEC_CLK
.eeb1	0a		asl a		   ASL A             ; C = data   bit 7 = clock
.eeb2	60		rts		   RTS
.eeb3					  WAIT_1MS
.eeb3	8a		txa		   TXA
.eeb4	a2 b8		ldx #$b8	   LDX #$B8
.eeb6					W1MS_10
.eeb6	ca		dex		   DEX
.eeb7	d0 fd		bne $eeb6	   BNE W1MS_10
.eeb9	aa		tax		   TAX
.eeba	60		rts		   RTS
.eebb					  RS232_NMI_Transmit
.eebb	a5 b4		lda $b4		   LDA BITTS         ; get RS232 bit count
.eebd	f0 47		beq $ef06	   BEQ RS232_Setup_Next_Byte_To_Send
.eebf	30 3f		bmi $ef00	   BMI RTra_40       ; if negative go do stop bit(s)
.eec1	46 b6		lsr $b6		   LSR RODATA        ; shift RS232 output byte buffer
.eec3	a2 00		ldx #$00	   LDX #$00          ; set $00 for bit = 0
.eec5	90 01		bcc $eec8	   BCC RTra_05       ; branch if bit was 0
.eec7	ca		dex		   DEX               ; set $FF for bit = 1
.eec8					RTra_05
.eec8	8a		txa		   TXA               ; copy bit to A
.eec9	45 bd		eor $bd		   EOR ROPRTY        ; EOR with RS232 parity byte
.eecb	85 bd		sta $bd		   STA ROPRTY        ; save RS232 parity byte
.eecd	c6 b4		dec $b4		   DEC BITTS         ; decrement RS232 bit count
.eecf	f0 06		beq $eed7	   BEQ RTra_15       ; if RS232 bit count now zero go do parity bit
.eed1					RTra_10
.eed1	8a		txa		   TXA               ; copy bit to A
.eed2	29 04		and #$04	   AND #RS232_C_BIT  ; mask for CB2 control bit
.eed4	85 b5		sta $b5		   STA NXTBIT        ; save RS232 next bit to send
.eed6	60		rts		   RTS
.eed7					RTra_15
.eed7	a9 20		lda #$20	   LDA #$20          ; mask 00x0 0000, parity enable bit
.eed9	2c 94 02	bit $0294	   BIT M51CDR        ; test pseudo 6551 command register
.eedc	f0 14		beq $eef2	   BEQ RTra_30       ; branch if parity disabled
.eede	30 1c		bmi $eefc	   BMI RTra_35       ; branch if fixed mark or space parity
.eee0	70 14		bvs $eef6	   BVS RTra_32       ; branch if even parity
.eee2	a5 bd		lda $bd		   LDA ROPRTY        ; get RS232 parity byte
.eee4	d0 01		bne $eee7	   BNE RTra_25       ; if parity not zero leave parity bit = 0
.eee6					RTra_20
.eee6	ca		dex		   DEX               ; make parity bit = 1
.eee7					RTra_25
.eee7	c6 b4		dec $b4		   DEC BITTS         ; decrement RS232 bit count, 1 stop bit
.eee9	ad 93 02	lda $0293	   LDA M51CTR        ; get pseudo 6551 control register
.eeec	10 e3		bpl $eed1	   BPL RTra_10       ; if 1 stop bit save parity bit and exit
.eeee	c6 b4		dec $b4		   DEC BITTS         ; decrement RS232 bit count, 2 stop bits
.eef0	d0 df		bne $eed1	   BNE RTra_10       ; save bit and exit, branch always
.eef2					RTra_30
.eef2	e6 b4		inc $b4		   INC BITTS         ; increment RS232 bit count, = -1 stop bit
.eef4	d0 f0		bne $eee6	   BNE RTra_20       ; set stop bit = 1 and exit
.eef6					RTra_32
.eef6	a5 bd		lda $bd		   LDA ROPRTY        ; get RS232 parity byte
.eef8	f0 ed		beq $eee7	   BEQ RTra_25       ; if parity zero leave parity bit = 0
.eefa	d0 ea		bne $eee6	   BNE RTra_20       ; else make parity bit = 1, branch always
.eefc					RTra_35
.eefc	70 e9		bvs $eee7	   BVS RTra_25       ; if fixed space parity leave parity bit = 0
.eefe	50 e6		bvc $eee6	   BVC RTra_20       ; else fixed mark parity make parity bit = 1, branch always
.ef00					RTra_40
.ef00	e6 b4		inc $b4		   INC BITTS         ; decrement RS232 bit count
.ef02	a2 ff		ldx #$ff	   LDX #$FF          ; set stop bit = 1
.ef04	d0 cb		bne $eed1	   BNE RTra_10       ; save stop bit and exit, branch always
.ef06					  RS232_Setup_Next_Byte_To_Send
.ef06	ad 94 02	lda $0294	   LDA M51CDR        ; get 6551 pseudo command register
.ef09	4a		lsr a		   LSR A             ; handshake bit inot Cb
.ef0a	90 07		bcc $ef13	   BCC RSNB_10       ; branch if 3 line interface
.ef0c	2c 01 dd	bit $dd01	   BIT RS2_DSR_CTS
.ef0f	10 1d		bpl $ef2e	   BPL RS232_No_DSR_Signal
.ef11	50 1e		bvc $ef31	   BVC RNDS_10      ; if CTS = 0 set CTS signal not present and exit
.ef13					RSNB_10
.ef13	a9 00		lda #$00	   LDA #0
.ef15	85 bd		sta $bd		   STA ROPRTY        ; clear RS232 parity byte
.ef17	85 b5		sta $b5		   STA NXTBIT        ; clear RS232 next bit to send
.ef19	ae 98 02	ldx $0298	   LDX BITNUM        ; get number of bits to be sent/received
.ef1c	86 b4		stx $b4		   STX BITTS         ; set RS232 bit count
.ef1e	ac 9d 02	ldy $029d	   LDY RODBS         ; get index to Tx buffer start
.ef21	cc 9e 02	cpy $029e	   CPY RODBE         ; compare with index to Tx buffer end
.ef24	f0 13		beq $ef39	   BEQ RNDS_20      ; if all done go disable T1 interrupt and return
.ef26	b1 f9		lda ($f9),y	   LDA (TXPTR),Y     ; else get byte from buffer
.ef28	85 b6		sta $b6		   STA RODATA        ; save to RS232 output byte buffer
.ef2a	ee 9d 02	inc $029d	   INC RODBS         ; increment index to Tx buffer start
.ef2d	60		rts		   RTS
.ef2e					  RS232_No_DSR_Signal
.ef2e	a9 40		lda #$40	   LDA #$40          ; set DSR signal not present
>ef30	2c				   .byte   $2C
.ef31					RNDS_10
.ef31	a9 10		lda #$10	   LDA #$10          ; set CTS signal not present
.ef33	0d 97 02	ora $0297	   ORA RSSTAT        ; OR with RS232 status register
.ef36	8d 97 02	sta $0297	   STA RSSTAT        ; save RS232 status register
.ef39					RNDS_20
.ef39	a9 01		lda #$01	   LDA #1
.ef3b					RNDS_30
.ef3b	8d 0d dd	sta $dd0d	   STA CIA2_ICR
.ef3e	4d a1 02	eor $02a1	   EOR ENABL
.ef41	09 80		ora #$80	   ORA #$80
.ef43	8d a1 02	sta $02a1	   STA ENABL
.ef46	8d 0d dd	sta $dd0d	   STA CIA2_ICR
.ef49	60		rts		   RTS
.ef4a					  RS232_Set_Data_Bits
.ef4a	a2 09		ldx #$09	   LDX #$09          ; set bit count to 9, 8 data + 1 stop bit
.ef4c	a9 20		lda #$20	   LDA #$20          ; mask for 8/7 data bits
.ef4e	2c 93 02	bit $0293	   BIT M51CTR        ; test pseudo 6551 control register
.ef51	f0 01		beq $ef54	   BEQ RSDB_10       ; branch if 8 bits
.ef53	ca		dex		   DEX               ; else decrement count for 7 data bits
.ef54					RSDB_10
.ef54	50 02		bvc $ef58	   BVC RSDB_20       ; branch if 7 bits
.ef56	ca		dex		   DEX               ; else decrement count ..
.ef57	ca		dex		   DEX               ; .. for 5 data bits
.ef58					RSDB_20
.ef58	60		rts		   RTS
.ef59					  RS232_NMI_Receive
.ef59	a6 a9		ldx $a9		   LDX RINONE        ; get start bit check flag
.ef5b	d0 33		bne $ef90	   BNE RRec_25       ; branch if no start bit received
.ef5d	c6 a8		dec $a8		   DEC BITCI         ; decrement receiver bit count in
.ef5f	f0 36		beq $ef97	   BEQ RRec_30
.ef61	30 0d		bmi $ef70	   BMI RRec_15
.ef63	a5 a7		lda $a7		   LDA INBIT
.ef65	45 ab		eor $ab		   EOR RIPRTY
.ef67	85 ab		sta $ab		   STA RIPRTY
.ef69	46 a7		lsr $a7		   LSR INBIT         ; shift receiver input bit temporary storage
.ef6b	66 aa		ror $aa		   ROR RIDATA
.ef6d					RRec_05
.ef6d	60		rts		   RTS
.ef6e					RRec_10
.ef6e	c6 a8		dec $a8		   DEC BITCI         ; decrement receiver bit count in
.ef70					RRec_15
.ef70	a5 a7		lda $a7		   LDA INBIT         ; get receiver input bit temporary storage
.ef72	f0 67		beq $efdb	   BEQ RRec_65
.ef74	ad 93 02	lda $0293	   LDA M51CTR        ; get pseudo 6551 control register
.ef77	0a		asl a		   ASL A
.ef78	a9 01		lda #$01	   LDA #$01
.ef7a	65 a8		adc $a8		   ADC BITCI         ; add receiver bit count in
.ef7c	d0 ef		bne $ef6d	   BNE RRec_05
.ef7e					RRec_20
.ef7e	a9 90		lda #$90	   LDA #$90          ; enable CB1 interrupt
.ef80	8d 0d dd	sta $dd0d	   STA RS2_IRQ_REG   ; set VIA 1 IER
.ef83	0d a1 02	ora $02a1	   ORA ENABL
.ef86	8d a1 02	sta $02a1	   STA ENABL
.ef89	85 a9		sta $a9		   STA RINONE
.ef8b	a9 02		lda #$02	   LDA #2
.ef8d	4c 3b ef	jmp $ef3b	   JMP RNDS_30
.ef90					RRec_25
.ef90	a5 a7		lda $a7		   LDA INBIT         ; get receiver input bit temporary storage
.ef92	d0 ea		bne $ef7e	   BNE RRec_20
.ef94	4c d3 e4	jmp $e4d3	   JMP Je4d3
.ef97					RRec_30
.ef97	ac 9b 02	ldy $029b	   LDY RIDBE         ; get index to Rx buffer end
.ef9a	c8		iny		   INY
.ef9b	cc 9c 02	cpy $029c	   CPY RIDBS         ; compare with index to Rx buffer start
.ef9e	f0 2a		beq $efca	   BEQ RRec_50       ; if buffer full go do Rx overrun error
.efa0	8c 9b 02	sty $029b	   STY RIDBE         ; save index to Rx buffer end
.efa3	88		dey		   DEY               ; decrement index
.efa4	a5 aa		lda $aa		   LDA RIDATA        ; get assembled byte
.efa6	ae 98 02	ldx $0298	   LDX BITNUM        ; get bit count
.efa9					RRec_35
.efa9	e0 09		cpx #$09	   CPX #$09          ; compare with byte + stop
.efab	f0 04		beq $efb1	   BEQ RRec_40       ; branch if all nine bits received
.efad	4a		lsr a		   LSR A             ; else shift byte
.efae	e8		inx		   INX               ; increment bit count
.efaf	d0 f8		bne $efa9	   BNE RRec_35       ; loop, branch always
.efb1					RRec_40
.efb1	91 f7		sta ($f7),y	   STA (RXPTR),Y     ; save received byte to Rx buffer
.efb3	a9 20		lda #$20	   LDA #$20          ; mask 00x0 0000, parity enable bit
.efb5	2c 94 02	bit $0294	   BIT M51CDR        ; test pseudo 6551 command register
.efb8	f0 b4		beq $ef6e	   BEQ RRec_10       ; branch if parity disabled
.efba	30 b1		bmi $ef6d	   BMI RRec_05       ; branch if mark or space parity
.efbc	a5 a7		lda $a7		   LDA INBIT         ; get receiver input bit temporary storage
.efbe	45 ab		eor $ab		   EOR RIPRTY
.efc0	f0 03		beq $efc5	   BEQ RRec_45
.efc2	70 a9		bvs $ef6d	   BVS RRec_05
>efc4	2c				   .byte   $2C
.efc5					RRec_45
.efc5	50 a6		bvc $ef6d	   BVC RRec_05
.efc7	a9 01		lda #$01	   LDA #$01          ; set Rx parity error
>efc9	2c				   .byte   $2C
.efca					RRec_50
.efca	a9 04		lda #$04	   LDA #$04          ; set Rx overrun error
>efcc	2c				   .byte   $2C
.efcd					RRec_55
.efcd	a9 80		lda #$80	   LDA #$80          ; Rx break error
>efcf	2c				   .byte   $2C
.efd0					RRec_60
.efd0	a9 02		lda #$02	   LDA #$02          ; Rx frame error
.efd2	0d 97 02	ora $0297	   ORA RSSTAT        ; OR with RS232 status byte
.efd5	8d 97 02	sta $0297	   STA RSSTAT        ; save RS232 status byte
.efd8	4c 7e ef	jmp $ef7e	   JMP RRec_20
.efdb					RRec_65
.efdb	a5 aa		lda $aa		   LDA RIDATA
.efdd	d0 f1		bne $efd0	   BNE RRec_60      ; if ?? do frame error
.efdf	f0 ec		beq $efcd	   BEQ RRec_55      ; else do break error, branch always
.efe1					RRec_70
.efe1					  RS232_CHKOUT
.efe1	85 9a		sta $9a		   STA DFLTO         ; save output device number
.efe3	ad 94 02	lda $0294	   LDA M51CDR        ; get pseudo 6551 command register
.efe6	4a		lsr a		   LSR A             ; shift handshake bit to carry
.efe7	90 29		bcc $f012	   BCC RSSN_10       ; branch if 3 line interface
.efe9	a9 02		lda #$02	   LDA #$02          ; mask for RTS out
.efeb	2c 01 dd	bit $dd01	   BIT RS2_DSR_CTS   ; test VIA 1 DRB
.efee	10 1d		bpl $f00d	   BPL RS232_Set_Status_No_Signal
.eff0	d0 20		bne $f012	   BNE RSSN_10       ; if RTS = 1 just exit
.eff2					RCHO_10
.eff2	ad a1 02	lda $02a1	   LDA ENABL
.eff5	29 02		and #$02	   AND #2
.eff7	d0 f9		bne $eff2	   BNE RCHO_10       ; loop while either enabled
.eff9					RCHO_20
.eff9	2c 01 dd	bit $dd01	   BIT RS2_DSR_CTS   ; test VIA 1 DRB
.effc	70 fb		bvs $eff9	   BVS RCHO_20       ; loop while CTS high
.effe	ad 01 dd	lda $dd01	   LDA RS2_DSR_CTS   ; get VIA 1 DRB
.f001	09 02		ora #$02	   ORA #$02          ; set RTS high
.f003	8d 01 dd	sta $dd01	   STA RS2_DSR_CTS   ; save VIA 1 DRB
.f006					RCHO_30
.f006	2c 01 dd	bit $dd01	   BIT RS2_DSR_CTS   ; test VIA 1 DRB
.f009	70 07		bvs $f012	   BVS RSSN_10       ; exit if CTS high
.f00b	30 f9		bmi $f006	   BMI RCHO_30       ; loop while DSR high
.f00d					  RS232_Set_Status_No_Signal
.f00d	a9 40		lda #$40	   LDA #$40
.f00f	8d 97 02	sta $0297	   STA RSSTAT
.f012					RSSN_10
.f012	18		clc		   CLC               ; flag ok
.f013	60		rts		   RTS
.f014					  RS232_Put_Byte_To_Buffer
.f014	20 28 f0	jsr $f028	   JSR RPBB_20
.f017					RPBB_10
.f017	ac 9e 02	ldy $029e	   LDY RODBE         ; get index to Tx buffer end
.f01a	c8		iny		   INY               ; + 1
.f01b	cc 9d 02	cpy $029d	   CPY RODBS         ; compare with index to Tx buffer start
.f01e	f0 f4		beq $f014	   BEQ RS232_Put_Byte_To_Buffer
.f020	8c 9e 02	sty $029e	   STY RODBE         ; set index to Tx buffer end
.f023	88		dey		   DEY               ; index to available buffer byte
.f024	a5 9e		lda $9e		   LDA PTR1
.f026	91 f9		sta ($f9),y	   STA (TXPTR),Y     ; save byte to buffer
.f028					RPBB_20
.f028	ad a1 02	lda $02a1	   LDA ENABL
.f02b	4a		lsr a		   LSR A
.f02c	b0 1e		bcs $f04c	   BCS RPBB_40
.f02e	a9 10		lda #$10	   LDA #$10
.f030	8d 0e dd	sta $dd0e	   STA CIA2_CRA
.f033					RPBB_30
.f033	ad 99 02	lda $0299	   LDA BAUDOF        ; get baud rate bit time low byte
.f036	8d 04 dd	sta $dd04	   STA RS2_TIM_LOW   ; set VIA 1 T1C_l
.f039	ad 9a 02	lda $029a	   LDA BAUDOF+1      ; get baud rate bit time high byte
.f03c	8d 05 dd	sta $dd05	   STA RS2_TIM_HIG   ; set VIA 1 T1C_h
.f03f	a9 81		lda #$81	   LDA #$81
.f041	20 3b ef	jsr $ef3b	   JSR RNDS_30
.f044	20 06 ef	jsr $ef06	   JSR RS232_Setup_Next_Byte_To_Send
.f047	a9 11		lda #$11	   LDA #$11
.f049	8d 0e dd	sta $dd0e	   STA CIA2_CRA
.f04c					RPBB_40
.f04c	60		rts		   RTS
.f04d					  RS232_CHKIN
.f04d	85 99		sta $99		   STA DFLTN         ; save input device number
.f04f	ad 94 02	lda $0294	   LDA M51CDR        ; get pseudo 6551 command register
.f052	4a		lsr a		   LSR A
.f053	90 28		bcc $f07d	   BCC RCHI_40       ; branch if 3 line interface
.f055	29 08		and #$08	   AND #$08          ; mask duplex bit, pseudo 6551 command is >> 1
.f057	f0 24		beq $f07d	   BEQ RCHI_40       ; branch if full duplex
.f059	a9 02		lda #$02	   LDA #2
.f05b	2c 01 dd	bit $dd01	   BIT RS2_DSR_CTS   ; test VIA 1 DRB
.f05e	10 ad		bpl $f00d	   BPL RS232_Set_Status_No_Signal
.f060	f0 22		beq $f084	   BEQ RCHI_50
.f062					RCHI_10
.f062	ad a1 02	lda $02a1	   LDA ENABL
.f065	4a		lsr a		   LSR A
.f066	b0 fa		bcs $f062	   BCS RCHI_10
.f068	ad 01 dd	lda $dd01	   LDA RS2_DSR_CTS   ; get VIA 1 DRB
.f06b	29 fd		and #$fd	   AND #$FD          ; mask xxxx xx0x, clear RTS out
.f06d	8d 01 dd	sta $dd01	   STA RS2_DSR_CTS   ; save VIA 1 DRB
.f070					RCHI_20
.f070	ad 01 dd	lda $dd01	   LDA RS2_DSR_CTS   ; get VIA 1 DRB
.f073	29 04		and #$04	   AND #$04          ; mask xxxx x1xx, DTR
.f075	f0 f9		beq $f070	   BEQ RCHI_20       ; loop while DTR low
.f077					RCHI_30
.f077	a9 90		lda #$90	   LDA #$90          ; enable CB1 interrupt
.f079	18		clc		   CLC
.f07a	4c 3b ef	jmp $ef3b	   JMP RNDS_30
.f07d					RCHI_40
.f07d	ad a1 02	lda $02a1	   LDA ENABL
.f080	29 12		and #$12	   AND #$12
.f082	f0 f3		beq $f077	   BEQ RCHI_30
.f084					RCHI_50
.f084	18		clc		   CLC
.f085	60		rts		   RTS
.f086					  RS232_Get_Byte_From_Buffer
.f086	ad 97 02	lda $0297	   LDA RSSTAT
.f089	ac 9c 02	ldy $029c	   LDY RIDBS         ; get index to Rx buffer start
.f08c	cc 9b 02	cpy $029b	   CPY RIDBE         ; compare with index to Rx buffer end
.f08f	f0 0b		beq $f09c	   BEQ RGBB_10       ; return null if buffer empty
.f091	29 f7		and #$f7	   AND #$F7
.f093	8d 97 02	sta $0297	   STA RSSTAT
.f096	b1 f7		lda ($f7),y	   LDA (RXPTR),Y     ; get byte from Rx buffer
.f098	ee 9c 02	inc $029c	   INC RIDBS         ; increment index to Rx buffer start
.f09b	60		rts		   RTS
.f09c					RGBB_10
.f09c	09 08		ora #$08	   ORA #8
.f09e	8d 97 02	sta $0297	   STA RSSTAT
.f0a1	a9 00		lda #$00	   LDA #$00          ; return null
.f0a3	60		rts		   RTS
.f0a4					  RS232_Stop
.f0a4	48		pha		   PHA
.f0a5	ad a1 02	lda $02a1	   LDA ENABL
.f0a8	f0 11		beq $f0bb	   BEQ RSTP_30
.f0aa					RSTP_10
.f0aa	ad a1 02	lda $02a1	   LDA ENABL
.f0ad	29 03		and #$03	   AND #3
.f0af	d0 f9		bne $f0aa	   BNE RSTP_10
.f0b1	a9 10		lda #$10	   LDA #$10          ; disable CB1 interrupt
.f0b3	8d 0d dd	sta $dd0d	   STA RS2_IRQ_REG   ; set VIA 1 IER
.f0b6	a9 00		lda #$00	   LDA #0
.f0b8	8d a1 02	sta $02a1	   STA ENABL
.f0bb					RSTP_30
.f0bb	68		pla		   PLA
.f0bc	60		rts		   RTS
>f0bd	0d 49 2f 4f 20 45 52 52		Msg_Start     .SHIFT "\rI/O ERROR #" ;^
>f0c5	4f 52 20 a3
>f0c9	0d 53 45 41 52 43 48 49		Msg_Searching .SHIFT "\rSEARCHING "  ;^
>f0d1	4e 47 a0
>f0d4	46 4f 52 a0			Msg_FOR       .SHIFT "FOR "          ;^
>f0d8	0d 50 52 45 53 53 20 50		Msg_Play      .SHIFT "\rPRESS PLAY ON TAPE"        ;^
>f0e0	4c 41 59 20 4f 4e 20 54 41 50 c5
>f0eb	50 52 45 53 53 20 52 45		Msg_Record    .SHIFT "PRESS RECORD & PLAY ON TAPE" ;^
>f0f3	43 4f 52 44 20 26 20 50 4c 41 59 20 4f 4e 20 54
>f103	41 50 c5
>f106	0d 4c 4f 41 44 49 4e c7		Msg_Loading   .SHIFT "\rLOADING"     ;^
>f10e	0d 53 41 56 49 4e 47 a0		Msg_Saving    .SHIFT "\rSAVING "     ;^
>f116	0d 56 45 52 49 46 59 49		Msg_Verifying .SHIFT "\rVERIFYING"   ;^
>f11e	4e c7
>f120	0d 46 4f 55 4e 44 a0		Msg_Found     .SHIFT "\rFOUND "      ;^
>f127	0d 4f 4b 8d			Msg_okIO      .SHIFT "\rOK\r"        ;^
.f12b					  Display_Direct_Msg
.f12b	24 9d		bit $9d		   BIT MSGFLG        ; test message mode flag
.f12d	10 0d		bpl $f13c	   BPL DDM_10        ; exit if control messages off
.f12f					  Display_Kernal_IO_Message
.f12f	b9 bd f0	lda $f0bd,y	   LDA Msg_Start,Y    ; get byte from message table
.f132	08		php		   PHP               ; save status
.f133	29 7f		and #$7f	   AND #$7F          ; clear b7
.f135	20 d2 ff	jsr $ffd2	   JSR CHROUT        ; Output a character
.f138	c8		iny		   INY
.f139	28		plp		   PLP               ; restore status
.f13a	10 f3		bpl $f12f	   BPL Display_Kernal_IO_Message
.f13c					DDM_10
.f13c	18		clc		   CLC
.f13d	60		rts		   RTS
.f13e					  Kernal_GETIN
.f13e	a5 99		lda $99		   LDA DFLTN         ; get input device number
.f140	d0 08		bne $f14a	   BNE KeGE_10       ; branch if not keyboard
.f142	a5 c6		lda $c6		   LDA NDX           ; get keyboard buffer length
.f144	f0 0f		beq $f155	   BEQ KeGE_20
.f146	78		sei		   SEI               ; disable inter/rupts
.f147	4c b4 e5	jmp $e5b4	   JMP Get_Char_From_Keyboard_Buffer
.f14a					KeGE_10
.f14a	c9 02		cmp #$02	   CMP #$02          ; compare device with RS232 device
.f14c	d0 18		bne $f166	   BNE CHRI_05      ; branch if not RS232 device
.f14e					  RS232_Get_Byte
.f14e	84 97		sty $97		   STY TEMPX         ; save Y
.f150	20 86 f0	jsr $f086	   JSR RS232_Get_Byte_From_Buffer
.f153	a4 97		ldy $97		   LDY TEMPX         ; restore Y
.f155					KeGE_20
.f155	18		clc		   CLC               ; flag no error
.f156	60		rts		   RTS
.f157					  Kernal_CHRIN
.f157	a5 99		lda $99		   LDA DFLTN         ; get input device number
.f159	d0 0b		bne $f166	   BNE CHRI_05       ; if it's not the keyboard continue
.f15b	a5 d3		lda $d3		   LDA CSRIDX        ; get cursor column
.f15d	85 ca		sta $ca		   STA ICRCOL        ; set input cursor column
.f15f	a5 d6		lda $d6		   LDA TBLX          ; get cursor row
.f161	85 c9		sta $c9		   STA ICRROW        ; set input cursor row
.f163	4c 32 e6	jmp $e632	   JMP CHRIN_Keyboard_Or_Screen
.f166					CHRI_05
.f166	c9 03		cmp #$03	   CMP #$03          ; compare device number with screen
.f168	d0 09		bne $f173	   BNE CHRI_10       ; if it's not the screen continue
.f16a					CHRI_07
.f16a	85 d0		sta $d0		   STA INSRC         ; input from keyboard or screen, $xx = screen,
.f16c	a5 d5		lda $d5		   LDA LINLEN        ; get current screen line length
.f16e	85 c8		sta $c8		   STA INDX          ; save input [EOL] pointer
.f170	4c 32 e6	jmp $e632	   JMP CHRIN_Keyboard_Or_Screen
.f173					CHRI_10
.f173	b0 38		bcs $f1ad	   BCS IEC_Get_Byte
.f175	c9 02		cmp #$02	   CMP #$02          ; compare device with RS232 device
.f177	f0 3f		beq $f1b8	   BEQ RS232_Read_Byte
.f179	86 97		stx $97		   STX TEMPX         ; save X
.f17b	20 99 f1	jsr $f199	   JSR TAPE_Get_Byte
.f17e	b0 16		bcs $f196	   BCS CHRI_25       ; exit if error
.f180	48		pha		   PHA               ; save byte
.f181	20 99 f1	jsr $f199	   JSR TAPE_Get_Byte
.f184	b0 0d		bcs $f193	   BCS CHRI_20       ; exit if error
.f186	d0 05		bne $f18d	   BNE CHRI_15       ; branch if end reached
.f188	a9 40		lda #$40	   LDA #$40          ; set [EOF] bit
.f18a	20 1c fe	jsr $fe1c	   JSR Ora_Status
.f18d					CHRI_15
.f18d	c6 a6		dec $a6		   DEC BUFPNT        ; decrement tape buffer index
.f18f	a6 97		ldx $97		   LDX TEMPX         ; restore X
.f191	68		pla		   PLA               ; restore saved byte
.f192	60		rts		   RTS
.f193					CHRI_20
.f193	aa		tax		   TAX               ; copy error byte ??
.f194	68		pla		   PLA               ; dump saved byte
.f195	8a		txa		   TXA               ; restore error byte ??
.f196					CHRI_25
.f196	a6 97		ldx $97		   LDX TEMPX         ; restore X
.f198	60		rts		   RTS
.f199					  TAPE_Get_Byte
.f199	20 0d f8	jsr $f80d	   JSR TAPE_Advance_Buffer_Pointer
.f19c	d0 0b		bne $f1a9	   BNE TGB_05        ; if not end get next byte and exit
.f19e	20 41 f8	jsr $f841	   JSR TAPE_Init_Read
.f1a1	b0 11		bcs $f1b4	   BCS IGB_30      ; exit if error flagged
.f1a3	a9 00		lda #$00	   LDA #0
.f1a5	85 a6		sta $a6		   STA BUFPNT        ; clear tape buffer index
.f1a7	f0 f0		beq $f199	   BEQ TAPE_Get_Byte ; branch always
.f1a9					TGB_05
.f1a9	b1 b2		lda ($b2),y	   LDA (TAPE1),Y     ; get next byte from buffer
.f1ab	18		clc		   CLC               ; flag no error
.f1ac	60		rts		   RTS
.f1ad					  IEC_Get_Byte
.f1ad	a5 90		lda $90		   LDA STATUS        ; get serial status byte
.f1af	f0 04		beq $f1b5	   BEQ IGB_40        ; if no errors flagged go input byte and return
.f1b1					IGB_10
.f1b1	a9 0d		lda #$0d	   LDA #$0D          ; else return [EOL]
.f1b3					IGB_20
.f1b3	18		clc		   CLC               ; flag no error
.f1b4					IGB_30
.f1b4	60		rts		   RTS
.f1b5					IGB_40
.f1b5	4c 13 ee	jmp $ee13	   JMP Kernal_ACPTR
.f1b8					  RS232_Read_Byte
.f1b8	20 4e f1	jsr $f14e	   JSR RS232_Get_Byte
.f1bb	b0 f7		bcs $f1b4	   BCS IGB_30
.f1bd	c9 00		cmp #$00	   CMP #$00          ; compare with null
.f1bf	d0 f2		bne $f1b3	   BNE IGB_20
.f1c1	ad 97 02	lda $0297	   LDA RSSTAT
.f1c4	29 60		and #$60	   AND #$60
.f1c6	d0 e9		bne $f1b1	   BNE IGB_10
.f1c8	f0 ee		beq $f1b8	   BEQ RS232_Read_Byte      ; loop if null
.f1ca					  Kernal_CHROUT
.f1ca	48		pha		   PHA               ; save the character to send
.f1cb	a5 9a		lda $9a		   LDA DFLTO         ; get output device number
.f1cd	c9 03		cmp #$03	   CMP #$03          ; compare device number with screen
.f1cf	d0 04		bne $f1d5	   BNE KeCO_10       ; if output device not screen continue
.f1d1	68		pla		   PLA               ; restore character to send
.f1d2	4c 16 e7	jmp $e716	   JMP Screen_CHROUT ; output character and return
.f1d5					KeCO_10
.f1d5	90 04		bcc $f1db	   BCC KeCO_20       ; if output device < screen continue
.f1d7	68		pla		   PLA               ; restore character to send
.f1d8	4c dd ed	jmp $eddd	   JMP Kernal_CIOUT  ; output a byte to the serial bus and return
.f1db					KeCO_20
.f1db	4a		lsr a		   LSR A
.f1dc	68		pla		   PLA               ; restore the character to send
.f1dd					  TAPE_Send_Byte
.f1dd	85 9e		sta $9e		   STA PTR1          ; save character to character buffer
.f1df	8a		txa		   TXA               ; copy X
.f1e0	48		pha		   PHA               ; save X
.f1e1	98		tya		   TYA               ; copy Y
.f1e2	48		pha		   PHA               ; save Y
.f1e3	90 23		bcc $f208	   BCC RS232_Send_Byte
.f1e5	20 0d f8	jsr $f80d	   JSR TAPE_Advance_Buffer_Pointer
.f1e8	d0 0e		bne $f1f8	   BNE TASB_10       ; if not end save next byte and exit
.f1ea	20 64 f8	jsr $f864	   JSR Init_Tape_Write
.f1ed	b0 0e		bcs $f1fd	   BCS TASB_30       ; exit if error
.f1ef	a9 02		lda #$02	   LDA #$02          ; set data block type ??
.f1f1	a0 00		ldy #$00	   LDY #0
.f1f3	91 b2		sta ($b2),y	   STA (TAPE1),Y     ; save type to buffer ??
.f1f5	c8		iny		   INY
.f1f6	84 a6		sty $a6		   STY BUFPNT        ; save tape buffer index
.f1f8					TASB_10
.f1f8	a5 9e		lda $9e		   LDA PTR1          ; restore character from character buffer
.f1fa	91 b2		sta ($b2),y	   STA (TAPE1),Y     ; save to buffer
.f1fc					TASB_20
.f1fc	18		clc		   CLC               ; flag no error
.f1fd					TASB_30
.f1fd	68		pla		   PLA               ; pull Y
.f1fe	a8		tay		   TAY               ; restore Y
.f1ff	68		pla		   PLA               ; pull X
.f200	aa		tax		   TAX               ; restore X
.f201	a5 9e		lda $9e		   LDA PTR1
.f203	90 02		bcc $f207	   BCC TASB_40       ; exit if no error
.f205	a9 00		lda #$00	   LDA #$00          ; else clear A
.f207					TASB_40
.f207	60		rts		   RTS
.f208					  RS232_Send_Byte
.f208	20 17 f0	jsr $f017	   JSR RPBB_10
.f20b	4c fc f1	jmp $f1fc	   JMP TASB_20
.f20e					  Kernal_ICHKIN
.f20e	20 0f f3	jsr $f30f	   JSR Find_File_X
.f211	f0 03		beq $f216	   BEQ KICH_10       ; branch if file opened
.f213	4c 01 f7	jmp $f701	   JMP File_Not_Open
.f216					KICH_10
.f216	20 1f f3	jsr $f31f	   JSR Get_LFS
.f219	a5 ba		lda $ba		   LDA FA            ; get device number
.f21b	f0 16		beq $f233	   BEQ KICH_30       ; if device was keyboard save device #, flag ok and exit
.f21d	c9 03		cmp #$03	   CMP #$03          ; compare device number with screen
.f21f	f0 12		beq $f233	   BEQ KICH_30       ; if device was screen save device #, flag ok and exit
.f221	b0 14		bcs $f237	   BCS KICH_40       ; branch if serial bus device
.f223	c9 02		cmp #$02	   CMP #$02          ; compare device with RS232 device
.f225	d0 03		bne $f22a	   BNE KICH_20       ; branch if not RS 232 device
.f227	4c 4d f0	jmp $f04d	   JMP RS232_CHKIN
.f22a					KICH_20
.f22a	a6 b9		ldx $b9		   LDX SA            ; get secondary address
.f22c	e0 60		cpx #$60	   CPX #$60
.f22e	f0 03		beq $f233	   BEQ KICH_30
.f230	4c 0a f7	jmp $f70a	   JMP Not_Input_File
.f233					KICH_30
.f233	85 99		sta $99		   STA DFLTN         ; save input device number
.f235	18		clc		   CLC               ; flag ok
.f236	60		rts		   RTS
.f237					KICH_40
.f237	aa		tax		   TAX               ; copy device number to X
.f238	20 09 ed	jsr $ed09	   JSR Kernal_TALK   ; command a serial bus device to TALK
.f23b	a5 b9		lda $b9		   LDA SA            ; get secondary address
.f23d	10 06		bpl $f245	   BPL KICH_50
.f23f	20 cc ed	jsr $edcc	   JSR IEC_Finish_Send
.f242	4c 48 f2	jmp $f248	   JMP KICH_60
.f245					KICH_50
.f245	20 c7 ed	jsr $edc7	   JSR Kernal_TKSA   ; send secondary address after TALK
.f248					KICH_60
.f248	8a		txa		   TXA               ; copy device back to A
.f249	24 90		bit $90		   BIT STATUS        ; test serial status byte
.f24b	10 e6		bpl $f233	   BPL KICH_30       ; if device present save device number and exit
.f24d	4c 07 f7	jmp $f707	   JMP Dev_Not_Present      ; do device not present error and return
.f250					  Kernal_CHKOUT
.f250	20 0f f3	jsr $f30f	   JSR Find_File_X
.f253	f0 03		beq $f258	   BEQ KCHO_10       ; branch if file found
.f255	4c 01 f7	jmp $f701	   JMP File_Not_Open
.f258					KCHO_10
.f258	20 1f f3	jsr $f31f	   JSR Get_LFS
.f25b	a5 ba		lda $ba		   LDA FA            ; get device number
.f25d	d0 03		bne $f262	   BNE KCHO_30       ; branch if device is not keyboard
.f25f					KCHO_20
.f25f	4c 0d f7	jmp $f70d	   JMP Not_Output_File
.f262					KCHO_30
.f262	c9 03		cmp #$03	   CMP #$03          ; compare device number with screen
.f264	f0 0f		beq $f275	   BEQ KCHO_50       ; if screen save output device number and exit
.f266	b0 11		bcs $f279	   BCS KCHO_60       ; branch if > screen, serial bus device
.f268	c9 02		cmp #$02	   CMP #$02          ; compare device with RS232 device
.f26a	d0 03		bne $f26f	   BNE KCHO_40       ; branch if not RS232 device, must be tape
.f26c	4c e1 ef	jmp $efe1	   JMP RS232_CHKOUT
.f26f					KCHO_40
.f26f	a6 b9		ldx $b9		   LDX SA            ; get secondary address
.f271	e0 60		cpx #$60	   CPX #$60
.f273	f0 ea		beq $f25f	   BEQ KCHO_20       ; if ?? do not output file error and return
.f275					KCHO_50
.f275	85 9a		sta $9a		   STA DFLTO         ; save output device number
.f277	18		clc		   CLC               ; flag ok
.f278	60		rts		   RTS
.f279					KCHO_60
.f279	aa		tax		   TAX               ; copy device number
.f27a	20 0c ed	jsr $ed0c	   JSR Kernal_LISTEN ; command devices on the serial bus to LISTEN
.f27d	a5 b9		lda $b9		   LDA SA            ; get secondary address
.f27f	10 05		bpl $f286	   BPL KCHO_70       ; branch if address to send
.f281	20 be ed	jsr $edbe	   JSR IEC_ATN_High
.f284	d0 03		bne $f289	   BNE KCHO_80       ; branch always
.f286					KCHO_70
.f286	20 b9 ed	jsr $edb9	   JSR Kernal_SECOND ; send secondary address after LISTEN
.f289					KCHO_80
.f289	8a		txa		   TXA               ; copy device number back to A
.f28a	24 90		bit $90		   BIT STATUS        ; test serial status byte
.f28c	10 e7		bpl $f275	   BPL KCHO_50       ; if device present save output device number and exit
.f28e	4c 07 f7	jmp $f707	   JMP Dev_Not_Present      ; else do device not present error and return
.f291					  Kernal_CLOSE
.f291	20 14 f3	jsr $f314	   JSR Find_File_A
.f294	f0 02		beq $f298	   BEQ KeCL_10       ; if the file is found go close it
.f296	18		clc		   CLC               ; else the file was closed so just flag ok
.f297	60		rts		   RTS
.f298					KeCL_10
.f298	20 1f f3	jsr $f31f	   JSR Get_LFS
.f29b	8a		txa		   TXA               ; copy file index to A
.f29c	48		pha		   PHA               ; save file index
.f29d	a5 ba		lda $ba		   LDA FA            ; get device number
.f29f	f0 50		beq $f2f1	   BEQ KeCL_80       ; if $00, keyboard, restore index and close file
.f2a1	c9 03		cmp #$03	   CMP #3            ; compare device number with screen
.f2a3	f0 4c		beq $f2f1	   BEQ KeCL_80       ; if screen restore index and close file
.f2a5	b0 47		bcs $f2ee	   BCS KeCL_70       ; if > screen go do serial bus device close
.f2a7	c9 02		cmp #$02	   CMP #2            ; compare device with RS232 device
.f2a9	d0 1d		bne $f2c8	   BNE KeCL_40       ; branch if not RS232 device
.f2ab	68		pla		   PLA               ; restore file index
.f2ac	20 f2 f2	jsr $f2f2	   JSR Close_File
.f2af	20 83 f4	jsr $f483	   JSR ROPN_50
.f2b2	20 27 fe	jsr $fe27	   JSR Read_Memtop
.f2b5	a5 f8		lda $f8		   LDA RXPTR+1       ; get RS232 input buffer pointer high byte
.f2b7	f0 01		beq $f2ba	   BEQ KeCL_20       ; branch if no RS232 input buffer
.f2b9	c8		iny		   INY               ; else reclaim RS232 input buffer memory
.f2ba					KeCL_20
.f2ba	a5 fa		lda $fa		   LDA TXPTR+1       ; get RS232 output buffer pointer high byte
.f2bc	f0 01		beq $f2bf	   BEQ KeCL_30       ; branch if no RS232 output buffer
.f2be	c8		iny		   INY               ; else reclaim RS232 output buffer memory
.f2bf					KeCL_30
.f2bf	a9 00		lda #$00	   LDA #0
.f2c1	85 f8		sta $f8		   STA RXPTR+1       ; clear RS232 input buffer pointer high byte
.f2c3	85 fa		sta $fa		   STA TXPTR+1       ; clear RS232 output buffer pointer high byte
.f2c5	4c 7d f4	jmp $f47d	   JMP ROPN_45       ; go set top of memory and exit
.f2c8					KeCL_40
.f2c8	a5 b9		lda $b9		   LDA SA            ; get secondary address
.f2ca	29 0f		and #$0f	   AND #$0F
.f2cc	f0 23		beq $f2f1	   BEQ KeCL_80
.f2ce	20 d0 f7	jsr $f7d0	   JSR TAPE_Get_Buffer_Address
.f2d1	a9 00		lda #$00	   LDA #0
.f2d3	38		sec		   SEC
.f2d4	20 dd f1	jsr $f1dd	   JSR TAPE_Send_Byte
.f2d7	20 64 f8	jsr $f864	   JSR Init_Tape_Write
.f2da	90 04		bcc $f2e0	   BCC KeCL_60
.f2dc	68		pla		   PLA
.f2dd	a9 00		lda #$00	   LDA #0
.f2df	60		rts		   RTS
.f2e0					KeCL_60
.f2e0	a5 b9		lda $b9		   LDA SA            ; get secondary address
.f2e2	c9 62		cmp #$62	   CMP #$62
.f2e4	d0 0b		bne $f2f1	   BNE KeCL_80
.f2e6	a9 05		lda #$05	   LDA #$05          ; set logical end of the tape
.f2e8	20 6a f7	jsr $f76a	   JSR TAPE_Write_Header
.f2eb	4c f1 f2	jmp $f2f1	   JMP KeCL_80       ; restore index and close file
.f2ee					KeCL_70
.f2ee	20 42 f6	jsr $f642	   JSR IEC_Close
.f2f1					KeCL_80
.f2f1	68		pla		   PLA               ; restore file index
.f2f2					  Close_File
.f2f2	aa		tax		   TAX               ; copy index to file to close
.f2f3					ClFi_05
.f2f3	c6 98		dec $98		   DEC LDTND         ; decrement open file count
.f2f5	e4 98		cpx $98		   CPX LDTND         ; compare index with open file count
.f2f7	f0 14		beq $f30d	   BEQ ClFi_10       ; exit if equal, last entry was closing file
.f2f9	a4 98		ldy $98		   LDY LDTND         ; get open file count as index
.f2fb	b9 59 02	lda $0259,y	   LDA FILTBL,Y      ; get last+1 logical file number from logical file table
.f2fe	9d 59 02	sta $0259,x	   STA FILTBL,X      ; save logical file number over closed file
.f301	b9 63 02	lda $0263,y	   LDA DEVTBL,Y      ; get last+1 device number from device number table
.f304	9d 63 02	sta $0263,x	   STA DEVTBL,X      ; save device number over closed file
.f307	b9 6d 02	lda $026d,y	   LDA SECATB,Y      ; get last+1 secondary address from secondary address table
.f30a	9d 6d 02	sta $026d,x	   STA SECATB,X      ; save secondary address over closed file
.f30d					ClFi_10
.f30d	18		clc		   CLC
.f30e					ClFi_Ret
.f30e	60		rts		   RTS
.f30f					  Find_File_X
.f30f	a9 00		lda #$00	   LDA #0
.f311	85 90		sta $90		   STA STATUS        ; clear serial status byte
.f313	8a		txa		   TXA               ; copy logical file number to A
.f314					  Find_File_A
.f314	a6 98		ldx $98		   LDX LDTND         ; get open file count
.f316					FiFi_10
.f316	ca		dex		   DEX               ; decrememnt count to give index
.f317	30 15		bmi $f32e	   BMI GLFS_Ret      ; exit if no files
.f319	dd 59 02	cmp $0259,x	   CMP FILTBL,X      ; compare logical file number with table logical file number
.f31c	d0 f8		bne $f316	   BNE FiFi_10       ; loop if no match
.f31e	60		rts		   RTS
.f31f					  Get_LFS
.f31f	bd 59 02	lda $0259,x	   LDA FILTBL,X      ; get logical file from logical file table
.f322	85 b8		sta $b8		   STA LA            ; set logical file
.f324	bd 63 02	lda $0263,x	   LDA DEVTBL,X      ; get device number from device number table
.f327	85 ba		sta $ba		   STA FA            ; set device number
.f329	bd 6d 02	lda $026d,x	   LDA SECATB,X      ; get secondary address from secondary address table
.f32c	85 b9		sta $b9		   STA SA            ; set secondary address
.f32e					GLFS_Ret
.f32e	60		rts		   RTS
.f32f					  Kernal_CLALL
.f32f	a9 00		lda #$00	   LDA #0
.f331	85 98		sta $98		   STA LDTND         ; clear open file count
.f333					  Kernal_CLRCHN
.f333	a2 03		ldx #$03	   LDX #$03          ; set X to screen
.f335	e4 9a		cpx $9a		   CPX DFLTO         ; compare output device number with screen
.f337	b0 03		bcs $f33c	   BCS KeCC_10       ; branch if >= screen
.f339	20 fe ed	jsr $edfe	   JSR Kernal_UNLSN  ; command the serial bus to UNLISTEN
.f33c					KeCC_10
.f33c	e4 99		cpx $99		   CPX DFLTN         ; compare input device number with screen
.f33e	b0 03		bcs $f343	   BCS KeCC_20       ; branch if >= screen
.f340	20 ef ed	jsr $edef	   JSR Kernal_UNTLK  ; command the serial bus to UNTALK
.f343					KeCC_20
.f343	86 9a		stx $9a		   STX DFLTO         ; set output device number to screen
.f345	a9 00		lda #$00	   LDA #$00          ; set for keyboard
.f347	85 99		sta $99		   STA DFLTN         ; set input device number to keyboard
.f349	60		rts		   RTS
.f34a					  Kernal_OPEN
.f34a	a6 b8		ldx $b8		   LDX LA            ; get logical file number
.f34c	d0 03		bne $f351	   BNE OPEN_05       ; branch if there is a file
.f34e	4c 0a f7	jmp $f70a	   JMP Not_Input_File      ; else do not input file error and return
.f351					OPEN_05
.f351	20 0f f3	jsr $f30f	   JSR Find_File_X
.f354	d0 03		bne $f359	   BNE OPEN_10       ; branch if file not found
.f356	4c fe f6	jmp $f6fe	   JMP File_Already_Open      ; else do file already open error and return
.f359					OPEN_10
.f359	a6 98		ldx $98		   LDX LDTND         ; get open file count
.f35b	e0 0a		cpx #$0a	   CPX #$0A          ; compare with max
.f35d	90 03		bcc $f362	   BCC OPEN_15       ; branch if less
.f35f	4c fb f6	jmp $f6fb	   JMP Too_Many_Files      ; else do too many files error and return
.f362					OPEN_15
.f362	e6 98		inc $98		   INC LDTND         ; increment open file count
.f364	a5 b8		lda $b8		   LDA LA            ; get logical file number
.f366	9d 59 02	sta $0259,x	   STA FILTBL,X      ; save to logical file table
.f369	a5 b9		lda $b9		   LDA SA            ; get secondary address
.f36b	09 60		ora #$60	   ORA #$60          ; OR with the OPEN CHANNEL command
.f36d	85 b9		sta $b9		   STA SA            ; set secondary address
.f36f	9d 6d 02	sta $026d,x	   STA SECATB,X      ; save to secondary address table
.f372	a5 ba		lda $ba		   LDA FA            ; get device number
.f374	9d 63 02	sta $0263,x	   STA DEVTBL,X      ; save to device number table
.f377	f0 5a		beq $f3d3	   BEQ OPEN_60       ; do ok exit if keyboard
.f379	c9 03		cmp #$03	   CMP #$03          ; compare device number with screen
.f37b	f0 56		beq $f3d3	   BEQ OPEN_60       ; do ok exit if screen
.f37d	90 05		bcc $f384	   BCC OPEN_20       ; branch if < screen, tape or RS232
.f37f	20 d5 f3	jsr $f3d5	   JSR IEC_Send_SA_And_Filename
.f382	90 4f		bcc $f3d3	   BCC OPEN_60       ; do ok exit
.f384					OPEN_20
.f384	c9 02		cmp #$02	   CMP #2            ; RS232 ?
.f386	d0 03		bne $f38b	   BNE OPEN_25
.f388	4c 09 f4	jmp $f409	   JMP RS232_Open
.f38b					OPEN_25
.f38b	20 d0 f7	jsr $f7d0	   JSR TAPE_Get_Buffer_Address
.f38e	b0 03		bcs $f393	   BCS OPEN_30       ; branch if >= $0200
.f390	4c 13 f7	jmp $f713	   JMP Illegal_Jiffy_Device
.f393					OPEN_30
.f393	a5 b9		lda $b9		   LDA SA            ; get secondary address
.f395	29 0f		and #$0f	   AND #$0F
.f397	d0 1f		bne $f3b8	   BNE OPEN_45
.f399	20 17 f8	jsr $f817	   JSR Wait_For_Play
.f39c	b0 36		bcs $f3d4	   BCS OPEN_Ret      ; exit if STOP was pressed
.f39e	20 af f5	jsr $f5af	   JSR Print_Searching
.f3a1	a5 b7		lda $b7		   LDA FNLEN         ; get file name length
.f3a3	f0 0a		beq $f3af	   BEQ OPEN_40       ; if null file name just go find header
.f3a5	20 ea f7	jsr $f7ea	   JSR TAPE_Find_Fileheader
.f3a8	90 18		bcc $f3c2	   BCC OPEN_50       ; branch if no error
.f3aa	f0 28		beq $f3d4	   BEQ OPEN_Ret      ; exit if ??
.f3ac					OPEN_35
.f3ac	4c 04 f7	jmp $f704	   JMP File_Not_Found      ; do file not found error and return
.f3af					OPEN_40
.f3af	20 2c f7	jsr $f72c	   JSR TAPE_Find_Any_Header
.f3b2	f0 20		beq $f3d4	   BEQ OPEN_Ret      ; exit if end of tape found
.f3b4	90 0c		bcc $f3c2	   BCC OPEN_50
.f3b6	b0 f4		bcs $f3ac	   BCS OPEN_35
.f3b8					OPEN_45
.f3b8	20 38 f8	jsr $f838	   JSR TAPE_Wait_For_Record
.f3bb	b0 17		bcs $f3d4	   BCS OPEN_Ret      ; exit if STOP was pressed
.f3bd	a9 04		lda #$04	   LDA #$04          ; set data file header
.f3bf	20 6a f7	jsr $f76a	   JSR TAPE_Write_Header
.f3c2					OPEN_50
.f3c2	a9 bf		lda #$bf	   LDA #$BF
.f3c4	a4 b9		ldy $b9		   LDY SA            ; get secondary address
.f3c6	c0 60		cpy #$60	   CPY #$60
.f3c8	f0 07		beq $f3d1	   BEQ OPEN_55
.f3ca	a0 00		ldy #$00	   LDY #0
.f3cc	a9 02		lda #$02	   LDA #$02
.f3ce	91 b2		sta ($b2),y	   STA (TAPE1),Y     ; save to tape buffer
.f3d0	98		tya		   TYA               ; clear A
.f3d1					OPEN_55
.f3d1	85 a6		sta $a6		   STA BUFPNT        ; save tape buffer index
.f3d3					OPEN_60
.f3d3	18		clc		   CLC               ; flag ok
.f3d4					OPEN_Ret
.f3d4	60		rts		   RTS
.f3d5					  IEC_Send_SA_And_Filename
.f3d5	a5 b9		lda $b9		   LDA SA            ; get secondary address
.f3d7	30 fa		bmi $f3d3	   BMI OPEN_60       ; ok exit if negative
.f3d9	a4 b7		ldy $b7		   LDY FNLEN         ; get file name length
.f3db	f0 f6		beq $f3d3	   BEQ OPEN_60       ; ok exit if null
.f3dd	a9 00		lda #$00	   LDA #0
.f3df	85 90		sta $90		   STA STATUS
.f3e1	a5 ba		lda $ba		   LDA FA            ; get device number
.f3e3	20 0c ed	jsr $ed0c	   JSR Kernal_LISTEN ; command devices on the serial bus to LISTEN
.f3e6	a5 b9		lda $b9		   LDA SA            ; get the secondary address
.f3e8	09 f0		ora #$f0	   ORA #$F0          ; OR with the OPEN command
.f3ea	20 b9 ed	jsr $edb9	   JSR Kernal_SECOND ; send secondary address after LISTEN
.f3ed	a5 90		lda $90		   LDA STATUS        ; get serial status byte
.f3ef	10 05		bpl $f3f6	   BPL ISSF_10       ; branch if device present
.f3f1					Pop_Dev_Not_Present
.f3f1	68		pla		   PLA               ; else dump calling address low byte
.f3f2	68		pla		   PLA               ; dump calling address high byte
.f3f3					Jmp_Dev_Not_Present
.f3f3	4c 07 f7	jmp $f707	   JMP Dev_Not_Present      ; do device not present error and return
.f3f6					ISSF_10
.f3f6	a5 b7		lda $b7		   LDA FNLEN         ; get file name length
.f3f8	f0 0c		beq $f406	   BEQ ISSF_30       ; branch if null name
.f3fa	a0 00		ldy #$00	   LDY #0
.f3fc					ISSF_20
.f3fc	b1 bb		lda ($bb),y	   LDA (FNADR ),Y    ; get file name byte
.f3fe	20 dd ed	jsr $eddd	   JSR Kernal_CIOUT  ; output a byte to the serial bus
.f401	c8		iny		   INY
.f402	c4 b7		cpy $b7		   CPY FNLEN         ; compare with file name length
.f404	d0 f6		bne $f3fc	   BNE ISSF_20       ; loop if not all done
.f406					ISSF_30
.f406	4c 54 f6	jmp $f654	   JMP IClo_10
.f409					  RS232_Open
.f409	20 83 f4	jsr $f483	   JSR ROPN_50
.f40c	8c 97 02	sty $0297	   STY RSSTAT        ; clear RS232 status byte
.f40f					ROPN_05
.f40f	c4 b7		cpy $b7		   CPY FNLEN         ; compare with file name length
.f411	f0 0a		beq $f41d	   BEQ ROPN_10       ; exit loop if done
.f413	b1 bb		lda ($bb),y	   LDA (FNADR ),Y    ; get file name byte
.f415	99 93 02	sta $0293,y	   STA M51CTR  ,Y    ; copy to 6551 register set
.f418	c8		iny		   INY
.f419	c0 04		cpy #$04	   CPY #$04          ; compare with $04
.f41b	d0 f2		bne $f40f	   BNE ROPN_05       ; loop if not to 4 yet
.f41d					ROPN_10
.f41d	20 4a ef	jsr $ef4a	   JSR RS232_Set_Data_Bits
.f420	8e 98 02	stx $0298	   STX BITNUM        ; save bit count
.f423	ad 93 02	lda $0293	   LDA M51CTR        ; get pseudo 6551 control register
.f426	29 0f		and #$0f	   AND #$0F          ; mask 0000 xxxx, baud rate
.f428	f0 1c		beq $f446	   BEQ ROPN_30
.f42a					ROPN_15
.f42a	0a		asl a		   ASL A             ; * 2
.f42b	aa		tax		   TAX               ; copy to index
.f42c	ad a6 02	lda $02a6	   LDA TVSFLG        ; TV flag
.f42f	d0 09		bne $f43a	   BNE ROPN_20       ; 0 = PAL
.f431	bc c1 fe	ldy $fec1,x	   LDY Baudrate-1,X
.f434	bd c0 fe	lda $fec0,x	   LDA Baudrate-2,X
.f437	4c 40 f4	jmp $f440	   JMP ROPN_25
.f43a					ROPN_20
.f43a	bc eb e4	ldy $e4eb,x	   LDY BaudNTSC-1,X
.f43d	bd ea e4	lda $e4ea,x	   LDA BaudNTSC-2,X
.f440					ROPN_25
.f440	8c 96 02	sty $0296	   STY M51AJB+1
.f443	8d 95 02	sta $0295	   STA M51AJB
.f446					ROPN_30
.f446	ad 95 02	lda $0295	   LDA M51AJB
.f449	0a		asl a		   ASL A
.f44a	20 2e ff	jsr $ff2e	   JSR Set_Baud_Rate
.f44d	ad 94 02	lda $0294	   LDA M51CDR        ; get pseudo 6551 command register
.f450	4a		lsr a		   LSR A             ; shift b0 into Cb
.f451	90 09		bcc $f45c	   BCC ROPN_35       ; branch if 3 line interface
.f453	ad 01 dd	lda $dd01	   LDA  CIA2_PRB
.f456	0a		asl a		   ASL A             ; shift DSR into Cb
.f457	b0 03		bcs $f45c	   BCS ROPN_35       ; branch if DSR = 1
.f459	20 0d f0	jsr $f00d	   JSR RS232_Set_Status_No_Signal
.f45c					ROPN_35
.f45c	ad 9b 02	lda $029b	   LDA RIDBE         ; get index to Rx buffer end
.f45f	8d 9c 02	sta $029c	   STA RIDBS         ; set index to Rx buffer start, clear Rx buffer
.f462	ad 9e 02	lda $029e	   LDA RODBE         ; get index to Tx buffer end
.f465	8d 9d 02	sta $029d	   STA RODBS         ; set index to Tx buffer start, clear Tx buffer
.f468	20 27 fe	jsr $fe27	   JSR Read_Memtop
.f46b	a5 f8		lda $f8		   LDA RXPTR+1       ; get Rx buffer pointer high byte
.f46d	d0 05		bne $f474	   BNE ROPN_40       ; branch if buffer already set
.f46f	88		dey		   DEY               ; decrement top of memory high byte, 256 byte buffer
.f470	84 f8		sty $f8		   STY RXPTR+1       ; set Rx buffer pointer high byte
.f472	86 f7		stx $f7		   STX RXPTR         ; set Rx buffer pointer low byte
.f474					ROPN_40
.f474	a5 fa		lda $fa		   LDA TXPTR+1       ; get Tx buffer pointer high byte
.f476	d0 05		bne $f47d	   BNE ROPN_45       ; branch if buffer already set
.f478	88		dey		   DEY               ; decrement Rx buffer pointer high byte, 256 byte buffer
.f479	84 fa		sty $fa		   STY TXPTR+1       ; set Tx buffer pointer high byte
.f47b	86 f9		stx $f9		   STX TXPTR         ; set Tx buffer pointer low byte
.f47d					ROPN_45
.f47d	38		sec		   SEC
.f47e	a9 f0		lda #$f0	   LDA #$F0
.f480	4c 2d fe	jmp $fe2d	   JMP Set_memtop
.f483					ROPN_50
.f483	a9 7f		lda #$7f	   LDA #$7F
.f485	8d 0d dd	sta $dd0d	   STA CIA2_ICR
.f488	a9 06		lda #$06	   LDA #6
.f48a	8d 03 dd	sta $dd03	   STA CIA2_DDRB
.f48d	8d 01 dd	sta $dd01	   STA CIA2_PRB
.f490	a9 04		lda #$04	   LDA #4
.f492	0d 00 dd	ora $dd00	   ORA CIA2_PRA
.f495	8d 00 dd	sta $dd00	   STA CIA2_PRA
.f498	a0 00		ldy #$00	   LDY #0
.f49a	8c a1 02	sty $02a1	   STY ENABL
.f49d	60		rts		   RTS
.f49e					  Kernal_LOAD
.f49e	86 c3		stx $c3		   STX MEMUSS
.f4a0	84 c4		sty $c4		   STY MEMUSS+1
.f4a2	6c 30 03	jmp ($0330)	   JMP (ILOAD)       ; do LOAD vector, usually points to Default_LOAD
.f4a5					  Default_LOAD
.f4a5	85 93		sta $93		   STA VERCKK        ; save load/verify flag
.f4a7	a9 00		lda #$00	   LDA #0
.f4a9	85 90		sta $90		   STA STATUS        ; clear serial status byte
.f4ab	a5 ba		lda $ba		   LDA FA            ; get device number
.f4ad	d0 03		bne $f4b2	   BNE DLOA_10       ; branch if not keyboard
.f4af					DLOA_05
.f4af	4c 13 f7	jmp $f713	   JMP Illegal_Jiffy_Device
.f4b2					DLOA_10
.f4b2	c9 03		cmp #$03	   CMP #$03          ; compare device number with screen
.f4b4	f0 f9		beq $f4af	   BEQ DLOA_05       ; if screen go do illegal device number and return
.f4b6	90 7b		bcc $f533	   BCC DLOA_55       ; branch if less than screen
.f4b8	a4 b7		ldy $b7		   LDY FNLEN         ; get file name length
.f4ba	d0 03		bne $f4bf	   BNE DLOA_15       ; branch if not null name
.f4bc	4c 10 f7	jmp $f710	   JMP Missing_File_Name
.f4bf					DLOA_15
.f4bf	a6 b9		ldx $b9		   LDX SA
.f4c1	20 af f5	jsr $f5af	   JSR Print_Searching
.f4c4	a9 60		lda #$60	   LDA #$60
.f4c6	85 b9		sta $b9		   STA SA            ; save the secondary address
.f4c8	20 d5 f3	jsr $f3d5	   JSR IEC_Send_SA_And_Filename
.f4cb	a5 ba		lda $ba		   LDA FA            ; get device number
.f4cd	20 09 ed	jsr $ed09	   JSR Kernal_TALK   ; command a serial bus device to TALK
.f4d0	a5 b9		lda $b9		   LDA SA            ; get secondary address
.f4d2	20 c7 ed	jsr $edc7	   JSR Kernal_TKSA   ; send secondary address after TALK
.f4d5	20 13 ee	jsr $ee13	   JSR Kernal_ACPTR  ; input a byte from the serial bus
.f4d8	85 ae		sta $ae		   STA EAL           ; save program start address low byte
.f4da	a5 90		lda $90		   LDA STATUS        ; get serial status byte
.f4dc	4a		lsr a		   LSR A             ; shift time out read ..
.f4dd	4a		lsr a		   LSR A             ; .. into carry bit
.f4de	b0 50		bcs $f530	   BCS DLOA_50       ; if timed out go do file not found error and return
.f4e0	20 13 ee	jsr $ee13	   JSR Kernal_ACPTR  ; input a byte from the serial bus
.f4e3	85 af		sta $af		   STA EAL+1         ; save program start address high byte
.f4e5	8a		txa		   TXA
.f4e6	d0 08		bne $f4f0	   BNE DLOA_20
.f4e8	a5 c3		lda $c3		   LDA MEMUSS
.f4ea	85 ae		sta $ae		   STA EAL
.f4ec	a5 c4		lda $c4		   LDA MEMUSS+1
.f4ee	85 af		sta $af		   STA EAL+1
.f4f0					DLOA_20
.f4f0	20 d2 f5	jsr $f5d2	   JSR Display_LOADING_Or_VERIFYING
.f4f3					DLOA_25
.f4f3	a9 fd		lda #$fd	   LDA #$FD          ; mask xxxx xx0x, clear time out read bit
.f4f5	25 90		and $90		   AND STATUS        ; mask serial status byte
.f4f7	85 90		sta $90		   STA STATUS        ; set serial status byte
.f4f9	20 e1 ff	jsr $ffe1	   JSR STOP          ; Check if stop key is pressed
.f4fc	d0 03		bne $f501	   BNE DLOA_30       ; branch if not [STOP]
.f4fe	4c 33 f6	jmp $f633	   JMP SAVE_50       ; else close the serial bus device and flag stop
.f501					DLOA_30
.f501	20 13 ee	jsr $ee13	   JSR Kernal_ACPTR  ; input a byte from the serial bus
.f504	aa		tax		   TAX               ; copy byte
.f505	a5 90		lda $90		   LDA STATUS        ; get serial status byte
.f507	4a		lsr a		   LSR A             ; shift time out read ..
.f508	4a		lsr a		   LSR A             ; .. into carry bit
.f509	b0 e8		bcs $f4f3	   BCS DLOA_25       ; if timed out go ??
.f50b	8a		txa		   TXA               ; copy received byte back
.f50c	a4 93		ldy $93		   LDY VERCKK        ; get load/verify flag
.f50e	f0 0c		beq $f51c	   BEQ DLOA_35       ; branch if load
.f510	a0 00		ldy #$00	   LDY #0
.f512	d1 ae		cmp ($ae),y	   CMP (EAL),Y       ; compare byte with previously loaded byte
.f514	f0 08		beq $f51e	   BEQ DLOA_40       ; branch if match
.f516	a9 10		lda #$10	   LDA #$10          ; flag read error
.f518	20 1c fe	jsr $fe1c	   JSR Ora_Status
>f51b	2c				   .byte   $2C
.f51c					DLOA_35
.f51c	91 ae		sta ($ae),y	   STA (EAL),Y       ; save byte to memory
.f51e					DLOA_40
.f51e	e6 ae		inc $ae		   INC EAL           ; increment save pointer low byte
.f520	d0 02		bne $f524	   BNE DLOA_45       ; if no rollover skip the high byte increment
.f522	e6 af		inc $af		   INC EAL+1         ; else increment save pointer high byte
.f524					DLOA_45
.f524	24 90		bit $90		   BIT STATUS        ; test serial status byte
.f526	50 cb		bvc $f4f3	   BVC DLOA_25       ; loop if not end of file
.f528					DLOA_47
.f528	20 ef ed	jsr $edef	   JSR Kernal_UNTLK  ; command the serial bus to UNTALK
.f52b	20 42 f6	jsr $f642	   JSR IEC_Close
.f52e	90 79		bcc $f5a9	   BCC DLOA_94       ; if OK exit
.f530					DLOA_50
.f530	4c 04 f7	jmp $f704	   JMP File_Not_Found
.f533					DLOA_55
.f533	4a		lsr a		   LSR A
.f534	b0 03		bcs $f539	   BCS DLOA_60
.f536	4c 13 f7	jmp $f713	   JMP Illegal_Jiffy_Device
.f539					DLOA_60
.f539	20 d0 f7	jsr $f7d0	   JSR TAPE_Get_Buffer_Address
.f53c	b0 03		bcs $f541	   BCS DLOA_65       ; branch if >= $0200
.f53e	4c 13 f7	jmp $f713	   JMP Illegal_Jiffy_Device
.f541					DLOA_65
.f541	20 17 f8	jsr $f817	   JSR Wait_For_Play
.f544	b0 68		bcs $f5ae	   BCS DLOA_Ret      ; exit if STOP was pressed
.f546	20 af f5	jsr $f5af	   JSR Print_Searching
.f549					DLOA_70
.f549	a5 b7		lda $b7		   LDA FNLEN         ; get file name length
.f54b	f0 09		beq $f556	   BEQ DLOA_75
.f54d	20 ea f7	jsr $f7ea	   JSR TAPE_Find_Fileheader
.f550	90 0b		bcc $f55d	   BCC DLOA_80       ; if no error continue
.f552	f0 5a		beq $f5ae	   BEQ DLOA_Ret      ; exit if ??
.f554	b0 da		bcs $f530	   BCS DLOA_50       ; branch always
.f556					DLOA_75
.f556	20 2c f7	jsr $f72c	   JSR TAPE_Find_Any_Header
.f559	f0 53		beq $f5ae	   BEQ DLOA_Ret      ; exit if ??
.f55b	b0 d3		bcs $f530	   BCS DLOA_50
.f55d					DLOA_80
.f55d	a5 90		lda $90		   LDA STATUS        ; get serial status byte
.f55f	29 10		and #$10	   AND #$10          ; mask 000x 0000, read error
.f561	38		sec		   SEC               ; flag fail
.f562	d0 4a		bne $f5ae	   BNE DLOA_Ret      ; if read error just exit
.f564	e0 01		cpx #$01	   CPX #$01
.f566	f0 11		beq $f579	   BEQ DLOA_90
.f568	e0 03		cpx #$03	   CPX #$03
.f56a	d0 dd		bne $f549	   BNE DLOA_70
.f56c					DLOA_85
.f56c	a0 01		ldy #$01	   LDY #$01
.f56e	b1 b2		lda ($b2),y	   LDA (TAPE1),Y
.f570	85 c3		sta $c3		   STA MEMUSS
.f572	c8		iny		   INY
.f573	b1 b2		lda ($b2),y	   LDA (TAPE1),Y
.f575	85 c4		sta $c4		   STA MEMUSS+1
.f577	b0 04		bcs $f57d	   BCS DLOA_92
.f579					DLOA_90
.f579	a5 b9		lda $b9		   LDA SA
.f57b	d0 ef		bne $f56c	   BNE DLOA_85
.f57d					DLOA_92
.f57d	a0 03		ldy #$03	   LDY #$03
.f57f	b1 b2		lda ($b2),y	   LDA (TAPE1),Y
.f581	a0 01		ldy #$01	   LDY #$01
.f583	f1 b2		sbc ($b2),y	   SBC (TAPE1),Y
.f585	aa		tax		   TAX
.f586	a0 04		ldy #$04	   LDY #$04
.f588	b1 b2		lda ($b2),y	   LDA (TAPE1),Y
.f58a	a0 02		ldy #$02	   LDY #$02
.f58c	f1 b2		sbc ($b2),y	   SBC (TAPE1),Y
.f58e	a8		tay		   TAY
.f58f	18		clc		   CLC
.f590	8a		txa		   TXA
.f591	65 c3		adc $c3		   ADC MEMUSS
.f593	85 ae		sta $ae		   STA EAL
.f595	98		tya		   TYA
.f596	65 c4		adc $c4		   ADC MEMUSS+1
.f598	85 af		sta $af		   STA EAL+1
.f59a	a5 c3		lda $c3		   LDA MEMUSS
.f59c	85 c1		sta $c1		   STA STAL
.f59e	a5 c4		lda $c4		   LDA MEMUSS+1
.f5a0	85 c2		sta $c2		   STA STAL+1
.f5a2	20 d2 f5	jsr $f5d2	   JSR Display_LOADING_Or_VERIFYING
.f5a5	20 4a f8	jsr $f84a	   JSR TAPE_Read
>f5a8	24				   .byte   $24       ; skip CLC statement
.f5a9					DLOA_94
.f5a9	18		clc		   CLC               ; flag ok
.f5aa					DLOA_95
.f5aa	a6 ae		ldx $ae		   LDX EAL           ; get the LOAD end pointer low byte
.f5ac	a4 af		ldy $af		   LDY EAL+1         ; get the LOAD end pointer high byte
.f5ae					DLOA_Ret
.f5ae	60		rts		   RTS
.f5af					  Print_Searching
.f5af	a5 9d		lda $9d		   LDA MSGFLG
.f5b1	10 1e		bpl $f5d1	   BPL PrSe_Ret
.f5b3	a0 0c		ldy #$0c	   LDY #Msg_Searching-Msg_Start
.f5b5	20 2f f1	jsr $f12f	   JSR Display_Kernal_IO_Message
.f5b8	a5 b7		lda $b7		   LDA FNLEN
.f5ba	f0 15		beq $f5d1	   BEQ PrSe_Ret
.f5bc	a0 17		ldy #$17	   LDY #Msg_FOR-Msg_Start
.f5be	20 2f f1	jsr $f12f	   JSR Display_Kernal_IO_Message
.f5c1					PrSe_10
.f5c1	a4 b7		ldy $b7		   LDY FNLEN
.f5c3	f0 0c		beq $f5d1	   BEQ PrSe_Ret
.f5c5	a0 00		ldy #$00	   LDY #0
.f5c7					PrSe_20
.f5c7	b1 bb		lda ($bb),y	   LDA (FNADR ),Y
.f5c9	20 d2 ff	jsr $ffd2	   JSR CHROUT
.f5cc	c8		iny		   INY
.f5cd	c4 b7		cpy $b7		   CPY FNLEN
.f5cf	d0 f6		bne $f5c7	   BNE PrSe_20
.f5d1					PrSe_Ret
.f5d1	60		rts		   RTS
.f5d2					  Display_LOADING_Or_VERIFYING
.f5d2	a0 49		ldy #$49	   LDY #Msg_Loading-Msg_Start
.f5d4	a5 93		lda $93		   LDA VERCKK        ; get load/verify flag
.f5d6	f0 02		beq $f5da	   BEQ DLV_10        ; branch if load
.f5d8	a0 59		ldy #$59	   LDY #Msg_Verifying-Msg_Start
.f5da					DLV_10
.f5da	4c 2b f1	jmp $f12b	   JMP Display_Direct_Msg
.f5dd					  Kernal_SAVE
.f5dd	86 ae		stx $ae		   STX EAL           ; save end address low byte
.f5df	84 af		sty $af		   STY EAL+1         ; save end address high byte
.f5e1	aa		tax		   TAX               ; copy index to start pointer
.f5e2	b5 00		lda $00,x	   LDA 0,X           ; get start address low byte
.f5e4	85 c1		sta $c1		   STA STAL          ; set I/O start addresses low byte
.f5e6	b5 01		lda $01,x	   LDA 1,X           ; get start address high byte
.f5e8	85 c2		sta $c2		   STA STAL+1        ; set I/O start addresses high byte
.f5ea	6c 32 03	jmp ($0332)	   JMP (ISAVE)       ; go save, usually points to Default_SAVE
.f5ed					  Default_SAVE
.f5ed	a5 ba		lda $ba		   LDA FA            ; get device number
.f5ef	d0 03		bne $f5f4	   BNE SAVE_20       ; branch if not keyboard
.f5f1					SAVE_10
.f5f1	4c 13 f7	jmp $f713	   JMP Illegal_Jiffy_Device
.f5f4					SAVE_20
.f5f4	c9 03		cmp #$03	   CMP #$03          ; compare device number with screen
.f5f6	f0 f9		beq $f5f1	   BEQ SAVE_10       ; if screen do illegal device number and return
.f5f8	90 5f		bcc $f659	   BCC IClo_30      ; branch if < screen
.f5fa	a9 61		lda #$61	   LDA #$61          ; set secondary address to $01
.f5fc	85 b9		sta $b9		   STA SA            ; save secondary address
.f5fe	a4 b7		ldy $b7		   LDY FNLEN         ; get file name length
.f600	d0 03		bne $f605	   BNE SAVE_30       ; branch if filename not null
.f602					Jmp_Missing_Filename
.f602	4c 10 f7	jmp $f710	   JMP Missing_File_Name      ; else do missing file name error and return
.f605					SAVE_30
.f605	20 d5 f3	jsr $f3d5	   JSR IEC_Send_SA_And_Filename
.f608	20 8f f6	jsr $f68f	   JSR Display_SAVING_Filename
.f60b	a5 ba		lda $ba		   LDA FA            ; get device number
.f60d	20 0c ed	jsr $ed0c	   JSR Kernal_LISTEN ; command devices on the serial bus to LISTEN
.f610	a5 b9		lda $b9		   LDA SA            ; get secondary address
.f612	20 b9 ed	jsr $edb9	   JSR Kernal_SECOND ; send secondary address after LISTEN
.f615	a0 00		ldy #$00	   LDY #0
.f617	20 8e fb	jsr $fb8e	   JSR Set_IO_Start
.f61a	a5 ac		lda $ac		   LDA SAL           ; get buffer address low byte
.f61c	20 dd ed	jsr $eddd	   JSR Kernal_CIOUT  ; output a byte to the serial bus
.f61f	a5 ad		lda $ad		   LDA SAL+1         ; get buffer address high byte
.f621	20 dd ed	jsr $eddd	   JSR Kernal_CIOUT  ; output a byte to the serial bus
.f624					SAVE_40
.f624	20 d1 fc	jsr $fcd1	   JSR Check_IO_End
.f627	b0 16		bcs $f63f	   BCS SAVE_70       ; go do UNLISTEN if at end
.f629	b1 ac		lda ($ac),y	   LDA (SAL),Y       ; get byte from buffer
.f62b	20 dd ed	jsr $eddd	   JSR Kernal_CIOUT  ; output a byte to the serial bus
.f62e	20 e1 ff	jsr $ffe1	   JSR STOP          ; Check if stop key is pressed
.f631	d0 07		bne $f63a	   BNE SAVE_60       ; if stop not pressed go increment pointer and loop for next
.f633					SAVE_50
.f633	20 42 f6	jsr $f642	   JSR IEC_Close
.f636	a9 00		lda #$00	   LDA #0
.f638	38		sec		   SEC               ; flag stop
.f639	60		rts		   RTS
.f63a					SAVE_60
.f63a	20 db fc	jsr $fcdb	   JSR Inc_SAL_Word
.f63d	d0 e5		bne $f624	   BNE SAVE_40       ; loop, branch always
.f63f					SAVE_70
.f63f	20 fe ed	jsr $edfe	   JSR Kernal_UNLSN  ; command the serial bus to UNLISTEN
.f642					  IEC_Close
.f642	24 b9		bit $b9		   BIT SA            ; test the secondary address
.f644	30 11		bmi $f657	   BMI IClo_20       ; if already closed just exit
.f646	a5 ba		lda $ba		   LDA FA            ; get the device number
.f648	20 0c ed	jsr $ed0c	   JSR Kernal_LISTEN ; command devices on the serial bus to LISTEN
.f64b	a5 b9		lda $b9		   LDA SA            ; get secondary address
.f64d	29 ef		and #$ef	   AND #$EF          ; mask the channel number
.f64f	09 e0		ora #$e0	   ORA #$E0          ; OR with the CLOSE command
.f651	20 b9 ed	jsr $edb9	   JSR Kernal_SECOND ; send secondary address after LISTEN
.f654					IClo_10
.f654	20 fe ed	jsr $edfe	   JSR Kernal_UNLSN  ; command the serial bus to UNLISTEN
.f657					IClo_20
.f657	18		clc		   CLC               ; flag ok
.f658	60		rts		   RTS
.f659					IClo_30
.f659	4a		lsr a		   LSR A
.f65a	b0 03		bcs $f65f	   BCS IClo_40
.f65c	4c 13 f7	jmp $f713	   JMP Illegal_Jiffy_Device
.f65f					IClo_40
.f65f	20 d0 f7	jsr $f7d0	   JSR TAPE_Get_Buffer_Address
.f662	90 8d		bcc $f5f1	   BCC SAVE_10
.f664	20 38 f8	jsr $f838	   JSR TAPE_Wait_For_Record
.f667	b0 25		bcs $f68e	   BCS IClo_Ret      ; exit if STOP was pressed
.f669	20 8f f6	jsr $f68f	   JSR Display_SAVING_Filename
.f66c	a2 03		ldx #$03	   LDX #$03          ; set header for a non relocatable program file
.f66e	a5 b9		lda $b9		   LDA SA            ; get secondary address
.f670	29 01		and #$01	   AND #$01          ; mask non relocatable bit
.f672	d0 02		bne $f676	   BNE IClo_50       ; branch if non relocatable program
.f674	a2 01		ldx #$01	   LDX #$01          ; else set header for a relocatable program file
.f676					IClo_50
.f676	8a		txa		   TXA               ; copy header type to A
.f677	20 6a f7	jsr $f76a	   JSR TAPE_Write_Header
.f67a	b0 12		bcs $f68e	   BCS IClo_Ret      ; exit if error
.f67c	20 67 f8	jsr $f867	   JSR TAPE_Write_With_Lead
.f67f	b0 0d		bcs $f68e	   BCS IClo_Ret      ; exit if error
.f681	a5 b9		lda $b9		   LDA SA            ; get secondary address
.f683	29 02		and #$02	   AND #$02          ; mask end of tape flag
.f685	f0 06		beq $f68d	   BEQ IClo_60       ; branch if not end of tape
.f687	a9 05		lda #$05	   LDA #$05          ; else set logical end of the tape
.f689	20 6a f7	jsr $f76a	   JSR TAPE_Write_Header
>f68c	24				   .byte   $24       ; skip next command
.f68d					IClo_60
.f68d	18		clc		   CLC               ; flag ok
.f68e					IClo_Ret
.f68e	60		rts		   RTS
.f68f					  Display_SAVING_Filename
.f68f	a5 9d		lda $9d		   LDA MSGFLG        ; get message mode flag
.f691	10 fb		bpl $f68e	   BPL IClo_Ret      ; exit if control messages off
.f693	a0 51		ldy #$51	   LDY #Msg_Saving-Msg_Start
.f695	20 2f f1	jsr $f12f	   JSR Display_Kernal_IO_Message
.f698	4c c1 f5	jmp $f5c1	   JMP PrSe_10      ; print file name and return
.f69b					  Kernal_UDTIM
.f69b	a2 00		ldx #$00	   LDX #$00          ; clear X
.f69d	e6 a2		inc $a2		   INC JIFFYL        ; increment jiffy low byte
.f69f	d0 06		bne $f6a7	   BNE UDTI_10       ; if no rollover skip the mid byte increment
.f6a1	e6 a1		inc $a1		   INC JIFFYM        ; increment jiffy mid byte
.f6a3	d0 02		bne $f6a7	   BNE UDTI_10       ; if no rollover skip the high byte increment
.f6a5	e6 a0		inc $a0		   INC JIFFYH        ; increment jiffy high byte
.f6a7					UDTI_10
.f6a7	38		sec		   SEC
.f6a8	a5 a2		lda $a2		   LDA JIFFYL        ; get jiffy clock low byte
.f6aa	e9 01		sbc #$01	   SBC #$01          ; subtract $4F1A01 low byte
.f6ac	a5 a1		lda $a1		   LDA JIFFYM        ; get jiffy clock mid byte
.f6ae	e9 1a		sbc #$1a	   SBC #$1A          ; subtract $4F1A01 mid byte
.f6b0	a5 a0		lda $a0		   LDA JIFFYH        ; get jiffy clock high byte
.f6b2	e9 4f		sbc #$4f	   SBC #$4F          ; subtract $4F1A01 high byte
.f6b4	90 06		bcc $f6bc	   BCC Look_For_Special_Keys
.f6b6	86 a0		stx $a0		   STX JIFFYH        ; clear jiffies high byte
.f6b8	86 a1		stx $a1		   STX JIFFYM        ; clear jiffies mid byte
.f6ba	86 a2		stx $a2		   STX JIFFYL        ; clear jiffies low byte
.f6bc					  Look_For_Special_Keys
.f6bc	ad 01 dc	lda $dc01	   LDA KEYB_ROWN     ; get VIA 2 DRA, keyboard row, no handshake
.f6bf	cd 01 dc	cmp $dc01	   CMP KEYB_ROWN     ; compare with self
.f6c2	d0 f8		bne $f6bc	   BNE Look_For_Special_Keys
.f6c4	aa		tax		   TAX
.f6c5	30 13		bmi $f6da	   BMI LFSK_20
.f6c7	a2 bd		ldx #$bd	   LDX #$bd
.f6c9	8e 00 dc	stx $dc00	   STX KEYB_COL
.f6cc					LFSK_10
.f6cc	ae 01 dc	ldx $dc01	   LDX KEYB_ROW
.f6cf	ec 01 dc	cpx $dc01	   CPX KEYB_ROW
.f6d2	d0 f8		bne $f6cc	   BNE LFSK_10
.f6d4	8d 00 dc	sta $dc00	   STA KEYB_COL
.f6d7	e8		inx		   INX
.f6d8	d0 02		bne $f6dc	   BNE LFSK_Ret
.f6da					LFSK_20
.f6da	85 91		sta $91		   STA STKEY         ; save VIA 2 DRA, keyboard row
.f6dc					LFSK_Ret
.f6dc	60		rts		   RTS
.f6dd					  Kernal_RDTIM
.f6dd	78		sei		   SEI               ; disable interrupts
.f6de	a5 a2		lda $a2		   LDA JIFFYL        ; get jiffy clock low byte
.f6e0	a6 a1		ldx $a1		   LDX JIFFYM        ; get jiffy clock mid byte
.f6e2	a4 a0		ldy $a0		   LDY JIFFYH        ; get jiffy clock high byte
.f6e4					  Kernal_SETTIM
.f6e4	78		sei		   SEI               ; disable interrupts
.f6e5	85 a2		sta $a2		   STA JIFFYL        ; save jiffy clock low byte
.f6e7	86 a1		stx $a1		   STX JIFFYM        ; save jiffy clock mid byte
.f6e9	84 a0		sty $a0		   STY JIFFYH        ; save jiffy clock high byte
.f6eb	58		cli		   CLI               ; enable interrupts
.f6ec	60		rts		   RTS
.f6ed					  Kernal_STOP
.f6ed	a5 91		lda $91		   LDA STKEY         ; get keyboard row
.f6ef	c9 7f		cmp #$7f	   CMP #$7f
.f6f1	d0 07		bne $f6fa	   BNE STOP_Ret      ; branch if not just r0
.f6f3	08		php		   PHP               ; save status
.f6f4	20 cc ff	jsr $ffcc	   JSR CLRCHN        ; Clear I/O channels
.f6f7	85 c6		sta $c6		   STA NDX           ; save keyboard buffer length
.f6f9	28		plp		   PLP               ; restore status
.f6fa					STOP_Ret
.f6fa	60		rts		   RTS
.f6fb					Too_Many_Files
.f6fb	a9 01		lda #$01	   LDA #$01
>f6fd	2c				   .byte   $2C
.f6fe					File_Already_Open
.f6fe	a9 02		lda #$02	   LDA #$02
>f700	2c				   .byte   $2C
.f701					File_Not_Open
.f701	a9 03		lda #$03	   LDA #$03
>f703	2c				   .byte   $2C
.f704					File_Not_Found
.f704	a9 04		lda #$04	   LDA #$04
>f706	2c				   .byte   $2C
.f707					Dev_Not_Present
.f707	a9 05		lda #$05	   LDA #$05
>f709	2c				   .byte   $2C
.f70a					Not_Input_File
.f70a	a9 06		lda #$06	   LDA #$06
>f70c	2c				   .byte   $2C
.f70d					Not_Output_File
.f70d	a9 07		lda #$07	   LDA #$07
>f70f	2c				   .byte   $2C
.f710					Missing_File_Name
.f710	a9 08		lda #$08	   LDA #$08
>f712	2c				   .byte   $2C
.f713					Illegal_Jiffy_Device
.f713	a9 09		lda #$09	   LDA #$09          ; illegal device number
.f715	48		pha		   PHA               ; save error #
.f716	20 cc ff	jsr $ffcc	   JSR CLRCHN        ; Clear I/O channels
.f719	a0 00		ldy #$00	   LDY #0            ; index to "I/O ERROR #"
.f71b	24 9d		bit $9d		   BIT MSGFLG        ; test message mode flag
.f71d	50 0a		bvc $f729	   BVC DIOR_10       ; exit if kernal messages off
.f71f	20 2f f1	jsr $f12f	   JSR Display_Kernal_IO_Message
.f722	68		pla		   PLA               ; restore error #
.f723	48		pha		   PHA               ; copy error #
.f724	09 30		ora #$30	   ORA #'0'          ; convert to ASCII
.f726	20 d2 ff	jsr $ffd2	   JSR CHROUT        ; Output a character
.f729					DIOR_10
.f729	68		pla		   PLA               ; pull error number
.f72a	38		sec		   SEC               ; flag error
.f72b					Jiffy_RTS
.f72b	60		rts		   RTS
.f72c					  TAPE_Find_Any_Header
.f72c	a5 93		lda $93		   LDA VERCKK        ; get load/verify flag
.f72e	48		pha		   PHA               ; save load/verify flag
.f72f	20 41 f8	jsr $f841	   JSR TAPE_Init_Read
.f732	68		pla		   PLA               ; restore load/verify flag
.f733	85 93		sta $93		   STA VERCKK        ; save load/verify flag
.f735	b0 32		bcs $f769	   BCS TFAH_Ret      ; exit if error
.f737	a0 00		ldy #$00	   LDY #0
.f739	b1 b2		lda ($b2),y	   LDA (TAPE1),Y     ; read first byte from tape buffer
.f73b	c9 05		cmp #$05	   CMP #$05          ; compare with logical end of the tape
.f73d	f0 2a		beq $f769	   BEQ TFAH_Ret      ; exit if end of the tape
.f73f	c9 01		cmp #$01	   CMP #$01          ; compare with header for a relocatable program file
.f741	f0 08		beq $f74b	   BEQ TFAH_10      ; branch if program file header
.f743	c9 03		cmp #$03	   CMP #$03          ; compare with header for a non relocatable program file
.f745	f0 04		beq $f74b	   BEQ TFAH_10      ; branch if program file header
.f747	c9 04		cmp #$04	   CMP #$04          ; compare with data file header
.f749	d0 e1		bne $f72c	   BNE TAPE_Find_Any_Header
.f74b					TFAH_10
.f74b	aa		tax		   TAX               ; copy header type
.f74c	24 9d		bit $9d		   BIT MSGFLG        ; get message mode flag
.f74e	10 17		bpl $f767	   BPL TFAH_30      ; exit if control messages off
.f750	a0 63		ldy #$63	   LDY #Msg_Found-Msg_Start
.f752	20 2f f1	jsr $f12f	   JSR Display_Kernal_IO_Message
.f755	a0 05		ldy #$05	   LDY #$05          ; index to tape filename
.f757					TFAH_20
.f757	b1 b2		lda ($b2),y	   LDA (TAPE1),Y     ; get byte from tape buffer
.f759	20 d2 ff	jsr $ffd2	   JSR CHROUT        ; Output a character
.f75c	c8		iny		   INY
.f75d	c0 15		cpy #$15	   CPY #$15          ; compare with end+1
.f75f	d0 f6		bne $f757	   BNE TFAH_20      ; loop if more to do
.f761	a5 a1		lda $a1		   LDA JIFFYM
.f763	20 e0 e4	jsr $e4e0	   JSR Delay_2JiffyM
.f766	ea		nop		   NOP
.f767					TFAH_30
.f767	18		clc		   CLC               ; flag no error
.f768	88		dey		   DEY               ; decrement index
.f769					TFAH_Ret
.f769	60		rts		   RTS
.f76a					  TAPE_Write_Header
.f76a	85 9e		sta $9e		   STA PTR1          ; save header type
.f76c	20 d0 f7	jsr $f7d0	   JSR TAPE_Get_Buffer_Address
.f76f	90 5e		bcc $f7cf	   BCC TWH_Ret       ; exit if < $0200
.f771	a5 c2		lda $c2		   LDA STAL+1
.f773	48		pha		   PHA
.f774	a5 c1		lda $c1		   LDA STAL
.f776	48		pha		   PHA
.f777	a5 af		lda $af		   LDA EAL+1
.f779	48		pha		   PHA
.f77a	a5 ae		lda $ae		   LDA EAL
.f77c	48		pha		   PHA
.f77d	a0 bf		ldy #$bf	   LDY #$BF          ; index to header end
.f77f	a9 20		lda #$20	   LDA #' '          ; clear byte, [SPACE]
.f781					TWH_10
.f781	91 b2		sta ($b2),y	   STA (TAPE1),Y     ; clear header byte
.f783	88		dey		   DEY               ; decrement index
.f784	d0 fb		bne $f781	   BNE TWH_10        ; loop if more to do
.f786	a5 9e		lda $9e		   LDA PTR1          ; get header type back
.f788	91 b2		sta ($b2),y	   STA (TAPE1),Y     ; write to header
.f78a	c8		iny		   INY
.f78b	a5 c1		lda $c1		   LDA STAL          ; get I/O start address low byte
.f78d	91 b2		sta ($b2),y	   STA (TAPE1),Y     ; write to header
.f78f	c8		iny		   INY
.f790	a5 c2		lda $c2		   LDA STAL+1        ; get I/O start address high byte
.f792	91 b2		sta ($b2),y	   STA (TAPE1),Y     ; write to header
.f794	c8		iny		   INY
.f795	a5 ae		lda $ae		   LDA EAL           ; get tape end address low byte
.f797	91 b2		sta ($b2),y	   STA (TAPE1),Y     ; write to header
.f799	c8		iny		   INY
.f79a	a5 af		lda $af		   LDA EAL+1         ; get tape end address high byte
.f79c	91 b2		sta ($b2),y	   STA (TAPE1),Y     ; write to header
.f79e	c8		iny		   INY
.f79f	84 9f		sty $9f		   STY PTR2          ; save index
.f7a1	a0 00		ldy #$00	   LDY #$00          ; clear Y
.f7a3	84 9e		sty $9e		   STY PTR1          ; clear name index
.f7a5					TWH_20
.f7a5	a4 9e		ldy $9e		   LDY PTR1          ; get name index
.f7a7	c4 b7		cpy $b7		   CPY FNLEN         ; compare with file name length
.f7a9	f0 0c		beq $f7b7	   BEQ TWH_30        ; exit loop if all done
.f7ab	b1 bb		lda ($bb),y	   LDA (FNADR ),Y    ; get file name byte
.f7ad	a4 9f		ldy $9f		   LDY PTR2          ; get buffer index
.f7af	91 b2		sta ($b2),y	   STA (TAPE1),Y     ; save file name byte to buffer
.f7b1	e6 9e		inc $9e		   INC PTR1          ; increment file name index
.f7b3	e6 9f		inc $9f		   INC PTR2          ; increment tape buffer index
.f7b5	d0 ee		bne $f7a5	   BNE TWH_20        ; loop, branch always
.f7b7					TWH_30
.f7b7	20 d7 f7	jsr $f7d7	   JSR TAPE_Set_Buffer_Pointer
.f7ba	a9 69		lda #$69	   LDA #$69          ; set write lead cycle count
.f7bc	85 ab		sta $ab		   STA RIPRTY        ; save write lead cycle count
.f7be	20 6b f8	jsr $f86b	   JSR TAPE_Write
.f7c1	a8		tay		   TAY
.f7c2	68		pla		   PLA
.f7c3	85 ae		sta $ae		   STA EAL
.f7c5	68		pla		   PLA
.f7c6	85 af		sta $af		   STA EAL+1
.f7c8	68		pla		   PLA
.f7c9	85 c1		sta $c1		   STA STAL
.f7cb	68		pla		   PLA
.f7cc	85 c2		sta $c2		   STA STAL+1
.f7ce	98		tya		   TYA
.f7cf					TWH_Ret
.f7cf	60		rts		   RTS
.f7d0					  TAPE_Get_Buffer_Address
.f7d0	a6 b2		ldx $b2		   LDX TAPE1
.f7d2	a4 b3		ldy $b3		   LDY TAPE1+1
.f7d4	c0 02		cpy #$02	   CPY #2            ; compare high byte with $02xx
.f7d6	60		rts		   RTS
.f7d7					  TAPE_Set_Buffer_Pointer
.f7d7	20 d0 f7	jsr $f7d0	   JSR TAPE_Get_Buffer_Address
.f7da	8a		txa		   TXA               ; copy tape buffer start pointer low byte
.f7db	85 c1		sta $c1		   STA STAL          ; save as I/O address pointer low byte
.f7dd	18		clc		   CLC
.f7de	69 c0		adc #$c0	   ADC #$C0          ; add buffer length low byte
.f7e0	85 ae		sta $ae		   STA EAL           ; save tape buffer end pointer low byte
.f7e2	98		tya		   TYA               ; copy tape buffer start pointer high byte
.f7e3	85 c2		sta $c2		   STA STAL+1        ; save as I/O address pointer high byte
.f7e5	69 00		adc #$00	   ADC #$00          ; add buffer length high byte
.f7e7	85 af		sta $af		   STA EAL+1         ; save tape buffer end pointer high byte
.f7e9	60		rts		   RTS
.f7ea					  TAPE_Find_Fileheader
.f7ea	20 2c f7	jsr $f72c	   JSR TAPE_Find_Any_Header
.f7ed	b0 1d		bcs $f80c	   BCS TFF_Ret       ; just exit if error
.f7ef	a0 05		ldy #$05	   LDY #$05          ; index to name
.f7f1	84 9f		sty $9f		   STY PTR2          ; save as tape buffer index
.f7f3	a0 00		ldy #$00	   LDY #$00          ; clear Y
.f7f5	84 9e		sty $9e		   STY PTR1          ; save as name buffer index
.f7f7					TFF_10
.f7f7	c4 b7		cpy $b7		   CPY FNLEN         ; compare with file name length
.f7f9	f0 10		beq $f80b	   BEQ TFF_20        ; ok exit if match
.f7fb	b1 bb		lda ($bb),y	   LDA (FNADR ),Y    ; get file name byte
.f7fd	a4 9f		ldy $9f		   LDY PTR2          ; get index to tape buffer
.f7ff	d1 b2		cmp ($b2),y	   CMP (TAPE1),Y     ; compare with tape header name byte
.f801	d0 e7		bne $f7ea	   BNE TAPE_Find_Fileheader
.f803	e6 9e		inc $9e		   INC PTR1          ; else increment name buffer index
.f805	e6 9f		inc $9f		   INC PTR2          ; increment tape buffer index
.f807	a4 9e		ldy $9e		   LDY PTR1          ; get name buffer index
.f809	d0 ec		bne $f7f7	   BNE TFF_10        ; loop, branch always
.f80b					TFF_20
.f80b	18		clc		   CLC               ; flag ok
.f80c					TFF_Ret
.f80c	60		rts		   RTS
.f80d					  TAPE_Advance_Buffer_Pointer
.f80d	20 d0 f7	jsr $f7d0	   JSR TAPE_Get_Buffer_Address
.f810	e6 a6		inc $a6		   INC BUFPNT        ; increment tape buffer index
.f812	a4 a6		ldy $a6		   LDY BUFPNT        ; get tape buffer index
.f814	c0 c0		cpy #$c0	   CPY #$C0          ; compare with buffer length
.f816	60		rts		   RTS
.f817					  Wait_For_Play
.f817	20 2e f8	jsr $f82e	   JSR TAPE_Sense
.f81a	f0 1a		beq $f836	   BEQ TASe_10      ; exit if switch closed
.f81c	a0 1b		ldy #$1b	   LDY #Msg_Play-Msg_Start
.f81e					WFP_10
.f81e	20 2f f1	jsr $f12f	   JSR Display_Kernal_IO_Message
.f821					WFP_20
.f821	20 d0 f8	jsr $f8d0	   JSR TAPE_Abort_On_STOP
.f824	20 2e f8	jsr $f82e	   JSR TAPE_Sense
.f827	d0 f8		bne $f821	   BNE WFP_20        ; loop if cassette switch open
.f829	a0 6a		ldy #$6a	   LDY #Msg_okIO-Msg_Start
.f82b	4c 2f f1	jmp $f12f	   JMP Display_Kernal_IO_Message
.f82e					  TAPE_Sense
.f82e	a9 10		lda #$10	   LDA #$10
.f830	24 01		bit $01		   BIT R6510
.f832	d0 02		bne $f836	   BNE TASe_10
.f834	24 01		bit $01		   BIT R6510
.f836					TASe_10
.f836	18		clc		   CLC
.f837	60		rts		   RTS
.f838					  TAPE_Wait_For_Record
.f838	20 2e f8	jsr $f82e	   JSR TAPE_Sense
.f83b	f0 f9		beq $f836	   BEQ TASe_10       ; exit if switch closed
.f83d	a0 2e		ldy #$2e	   LDY #Msg_Record-Msg_Start
.f83f	d0 dd		bne $f81e	   BNE WFP_10        ; display message and wait for switch, branch always
.f841					  TAPE_Init_Read
.f841	a9 00		lda #$00	   LDA #0
.f843	85 90		sta $90		   STA STATUS        ; clear serial status byte
.f845	85 93		sta $93		   STA VERCKK        ; clear the load/verify flag
.f847	20 d7 f7	jsr $f7d7	   JSR TAPE_Set_Buffer_Pointer
.f84a					  TAPE_Read
.f84a	20 17 f8	jsr $f817	   JSR Wait_For_Play
.f84d	b0 1f		bcs $f86e	   BCS TAWR_10      ; exit if STOP was pressed, uses further BCS at target
.f84f	78		sei		   SEI               ; disable interrupts
.f850	a9 00		lda #$00	   LDA #0
.f852	85 aa		sta $aa		   STA RIDATA        ;.
.f854	85 b4		sta $b4		   STA BITTS         ;.
.f856	85 b0		sta $b0		   STA CMPO          ; clear tape timing constant min byte
.f858	85 9e		sta $9e		   STA PTR1          ; clear tape pass 1 error log/char buffer
.f85a	85 9f		sta $9f		   STA PTR2          ; clear tape pass 2 error log corrected
.f85c	85 9c		sta $9c		   STA DPSW          ; clear byte received flag
.f85e	a9 90		lda #$90	   LDA #$90
.f860	a2 0e		ldx #$0e	   LDX #$0E          ; set index for tape read vector
.f862	d0 11		bne $f875	   BNE TAWR_20      ; go do tape read/write, branch always
.f864					  Init_Tape_Write
.f864	20 d7 f7	jsr $f7d7	   JSR TAPE_Set_Buffer_Pointer
.f867					  TAPE_Write_With_Lead
.f867	a9 14		lda #$14	   LDA #20           ; set write lead cycle count
.f869	85 ab		sta $ab		   STA RIPRTY        ; save write lead cycle count
.f86b					  TAPE_Write
.f86b	20 38 f8	jsr $f838	   JSR TAPE_Wait_For_Record
.f86e					TAWR_10
.f86e	b0 6c		bcs $f8dc	   BCS Clear_Saved_IRQ_Address
.f870	78		sei		   SEI               ; disable interrupts
.f871	a9 82		lda #$82	   LDA #$82
.f873	a2 08		ldx #$08	   LDX #$08          ; set index for tape write tape leader vector
.f875					TAWR_20
.f875	a0 7f		ldy #$7f	   LDY #$7F          ; disable all interrupts
.f877	8c 0d dc	sty $dc0d	   STY VIA2_IER      ; set VIA 2 IER, disable interrupts
.f87a	8d 0d dc	sta $dc0d	   STA VIA2_IER      ; set VIA 2 IER, enable interrupts according to A
.f87d	ad 0e dc	lda $dc0e	   LDA CIA1_CRA
.f880	09 19		ora #$19	   ORA #$19
.f882	8d 0f dc	sta $dc0f	   STA CIA1_CRB      ; CIA1 Control Register B
.f885	29 91		and #$91	   AND #$91
.f887	8d a2 02	sta $02a2	   STA TODSNS
.f88a	20 a4 f0	jsr $f0a4	   JSR RS232_Stop
.f88d	ad 11 d0	lda $d011	   LDA VIC_CONTROL_1
.f890	29 ef		and #$ef	   AND #$EF          ; clear bit 8 of raster value
.f892	8d 11 d0	sta $d011	   STA VIC_CONTROL_1
.f895	ad 14 03	lda $0314	   LDA CINV          ; get IRQ vector low byte
.f898	8d 9f 02	sta $029f	   STA IRQTMP        ; save IRQ vector low byte
.f89b	ad 15 03	lda $0315	   LDA CINV+1        ; get IRQ vector high byte
.f89e	8d a0 02	sta $02a0	   STA IRQTMP+1      ; save IRQ vector high byte
.f8a1	20 bd fc	jsr $fcbd	   JSR TAPE_Set_IRQ_Vector
.f8a4	a9 02		lda #$02	   LDA #$02          ; set copies count. the first copy is the load copy, the
.f8a6	85 be		sta $be		   STA FSBLK         ; save copies count
.f8a8	20 97 fb	jsr $fb97	   JSR TAPE_New_Byte_Setup
.f8ab	a5 01		lda $01		   LDA R6510
.f8ad	29 1f		and #$1f	   AND #$1f
.f8af	85 01		sta $01		   STA R6510
.f8b1	85 c0		sta $c0		   STA CAS1          ; set tape motor interlock
.f8b3	a2 ff		ldx #$ff	   LDX #$FF          ; outer loop count
.f8b5					TAWR_30
.f8b5	a0 ff		ldy #$ff	   LDY #$FF          ; inner loop count
.f8b7					TAWR_40
.f8b7	88		dey		   DEY               ; decrement inner loop count
.f8b8	d0 fd		bne $f8b7	   BNE TAWR_40      ; loop if more to do
.f8ba	ca		dex		   DEX               ; decrement outer loop count
.f8bb	d0 f8		bne $f8b5	   BNE TAWR_30      ; loop if more to do
.f8bd	58		cli		   CLI               ; enable tape interrupts
.f8be					TAWR_50
.f8be	ad a0 02	lda $02a0	   LDA IRQTMP+1      ; get saved IRQ high byte
.f8c1	cd 15 03	cmp $0315	   CMP CINV+1        ; compare with the current IRQ high byte
.f8c4	18		clc		   CLC               ; flag ok
.f8c5	f0 15		beq $f8dc	   BEQ Clear_Saved_IRQ_Address
.f8c7	20 d0 f8	jsr $f8d0	   JSR TAPE_Abort_On_STOP
.f8ca	20 bc f6	jsr $f6bc	   JSR Look_For_Special_Keys
.f8cd	4c be f8	jmp $f8be	   JMP TAWR_50      ; loop
.f8d0					  TAPE_Abort_On_STOP
.f8d0	20 e1 ff	jsr $ffe1	   JSR STOP          ; Check if stop key is pressed
.f8d3	18		clc		   CLC               ; flag no stop
.f8d4	d0 0b		bne $f8e1	   BNE CSIA_Ret      ; exit if no stop
.f8d6	20 93 fc	jsr $fc93	   JSR Restoring_After_STOP
.f8d9	38		sec		   SEC               ; flag stopped
.f8da	68		pla		   PLA               ; dump return address low byte
.f8db	68		pla		   PLA               ; dump return address high byte
.f8dc					  Clear_Saved_IRQ_Address
.f8dc	a9 00		lda #$00	   LDA #0
.f8de	8d a0 02	sta $02a0	   STA IRQTMP+1      ; clear saved IRQ address high byte
.f8e1					CSIA_Ret
.f8e1	60		rts		   RTS
.f8e2					  TAPE_Set_Timer
.f8e2	86 b1		stx $b1		   STX CMPO+1        ; save tape timing constant max byte
.f8e4	a5 b0		lda $b0		   LDA CMPO          ; get tape timing constant min byte
.f8e6	0a		asl a		   ASL A             ; *2
.f8e7	0a		asl a		   ASL A             ; *4
.f8e8	18		clc		   CLC
.f8e9	65 b0		adc $b0		   ADC CMPO          ; add tape timing constant min byte *5
.f8eb	18		clc		   CLC
.f8ec	65 b1		adc $b1		   ADC CMPO+1        ; add tape timing constant max byte
.f8ee	85 b1		sta $b1		   STA CMPO+1        ; save tape timing constant max byte
.f8f0	a9 00		lda #$00	   LDA #$00          ;.
.f8f2	24 b0		bit $b0		   BIT CMPO          ; test tape timing constant min byte
.f8f4	30 01		bmi $f8f7	   BMI TST_10        ; branch if b7 set
.f8f6	2a		rol a		   ROL A             ; else shift carry into ??
.f8f7					TST_10
.f8f7	06 b1		asl $b1		   ASL CMPO+1        ; shift tape timing constant max byte
.f8f9	2a		rol a		   ROL A
.f8fa	06 b1		asl $b1		   ASL CMPO+1        ; shift tape timing constant max byte
.f8fc	2a		rol a		   ROL A
.f8fd	aa		tax		   TAX
.f8fe					TST_20
.f8fe	ad 06 dc	lda $dc06	   LDA VIA2_T2CL     ; get VIA 2 T2C_l
.f901	c9 16		cmp #$16	   CMP #$16
.f903	90 f9		bcc $f8fe	   BCC TST_20        ; loop if less
.f905	65 b1		adc $b1		   ADC CMPO+1        ; add tape timing constant max byte
.f907	8d 04 dc	sta $dc04	   STA VIA2_T1CL     ; set VIA 2 T1C_l
.f90a	8a		txa		   TXA
.f90b	6d 07 dc	adc $dc07	   ADC VIA2_T2CH     ; add VIA 2 T2C_h
.f90e	8d 05 dc	sta $dc05	   STA VIA2_T1CH     ; set VIA 2 T1C_h
.f911	ad a2 02	lda $02a2	   LDA TODSNS
.f914	8d 0e dc	sta $dc0e	   STA CIA1_CRA
.f917	8d a4 02	sta $02a4	   STA TD1IRQ
.f91a	ad 0d dc	lda $dc0d	   LDA CIA1_ICR      ; CIA1 Interrupt Control Register
.f91d	29 10		and #$10	   AND #$10
.f91f	f0 09		beq $f92a	   BEQ TST_30
.f921	a9 f9		lda #$f9	   LDA #>TST_30
.f923	48		pha		   PHA
.f924	a9 2a		lda #$2a	   LDA #<TST_30
.f926	48		pha		   PHA
.f927	4c 43 ff	jmp $ff43	   JMP Clear_BREAK_Flag
.f92a					TST_30
.f92a	58		cli		   CLI
.f92b	60		rts		   RTS
.f92c					  TAPE_Read_IRQ
.f92c	ae 07 dc	ldx $dc07	   LDX VIA2_T2CH     ; get VIA 2 T2C_h
.f92f	a0 ff		ldy #$ff	   LDY #$FF
.f931	98		tya		   TYA
.f932	ed 06 dc	sbc $dc06	   SBC VIA2_T2CL     ; subtract VIA 2 T2C_l
.f935	ec 07 dc	cpx $dc07	   CPX VIA2_T2CH     ; compare VIA 2 T2C_h with previous
.f938	d0 f2		bne $f92c	   BNE TAPE_Read_IRQ ; loop if timer low byte rolled over
.f93a	86 b1		stx $b1		   STX CMPO+1        ; save tape timing constant max byte
.f93c	aa		tax		   TAX               ; copy $FF - T2C_l
.f93d	8c 06 dc	sty $dc06	   STY VIA2_T2CL     ; set VIA 2 T2C_l to $FF
.f940	8c 07 dc	sty $dc07	   STY VIA2_T2CH     ; set VIA 2 T2C_h to $FF
.f943	a9 19		lda #$19	   LDA #$19
.f945	8d 0f dc	sta $dc0f	   STA CIA1_CRB      ; CIA1 Control Register B
.f948	ad 0d dc	lda $dc0d	   LDA CIA1_ICR      ; CIA1 Interrupt Control Register
.f94b	8d a3 02	sta $02a3	   STA TRDTMP
.f94e	98		tya		   TYA
.f94f	e5 b1		sbc $b1		   SBC CMPO+1        ; subtract tape timing constant max byte
.f951	86 b1		stx $b1		   STX CMPO+1        ; save tape timing constant max byte
.f953	4a		lsr a		   LSR A             ; A = $FF - T2C_h >> 1
.f954	66 b1		ror $b1		   ROR CMPO+1        ; shift tape timing constant max byte
.f956	4a		lsr a		   LSR A             ; A = $FF - T2C_h >> 1
.f957	66 b1		ror $b1		   ROR CMPO+1        ; shift tape timing constant max byte
.f959	a5 b0		lda $b0		   LDA CMPO          ; get tape timing constant min byte
.f95b	18		clc		   CLC
.f95c	69 3c		adc #$3c	   ADC #$3C
.f95e	c5 b1		cmp $b1		   CMP CMPO+1        ; compare with tape timing constant max byte
.f960	b0 4a		bcs $f9ac	   BCS TARI_14       ; branch if min + $3C >= ($FFFF - T2C) >> 2
.f962	a6 9c		ldx $9c		   LDX DPSW          ; get byte received flag
.f964	f0 03		beq $f969	   BEQ TARI_02       ; branch if not byte received
.f966	4c 60 fa	jmp $fa60	   JMP TAPE_Store_Char      ; store tape character
.f969					TARI_02
.f969	a6 a3		ldx $a3		   LDX TSFCNT        ; get EOI flag byte
.f96b	30 1b		bmi $f988	   BMI TARI_04
.f96d	a2 00		ldx #$00	   LDX #$00
.f96f	69 30		adc #$30	   ADC #$30
.f971	65 b0		adc $b0		   ADC CMPO          ; add tape timing constant min byte
.f973	c5 b1		cmp $b1		   CMP CMPO+1        ; compare with tape timing constant max byte
.f975	b0 1c		bcs $f993	   BCS TARI_08
.f977	e8		inx		   INX
.f978	69 26		adc #$26	   ADC #$26
.f97a	65 b0		adc $b0		   ADC CMPO          ; add tape timing constant min byte
.f97c	c5 b1		cmp $b1		   CMP CMPO+1        ; compare with tape timing constant max byte
.f97e	b0 17		bcs $f997	   BCS TARI_10
.f980	69 2c		adc #$2c	   ADC #$2C
.f982	65 b0		adc $b0		   ADC CMPO          ; add tape timing constant min byte
.f984	c5 b1		cmp $b1		   CMP CMPO+1        ; compare with tape timing constant max byte
.f986	90 03		bcc $f98b	   BCC TARI_06
.f988					TARI_04
.f988	4c 10 fa	jmp $fa10	   JMP TARI_30
.f98b					TARI_06
.f98b	a5 b4		lda $b4		   LDA BITTS         ; get bit count
.f98d	f0 1d		beq $f9ac	   BEQ TARI_14       ; branch if zero
.f98f	85 a8		sta $a8		   STA BITCI         ; save receiver bit count in
.f991	d0 19		bne $f9ac	   BNE TARI_14       ; branch always
.f993					TARI_08
.f993	e6 a9		inc $a9		   INC RINONE        ; increment ?? start bit check flag
.f995	b0 02		bcs $f999	   BCS TARI_12
.f997					TARI_10
.f997	c6 a9		dec $a9		   DEC RINONE        ; decrement ?? start bit check flag
.f999					TARI_12
.f999	38		sec		   SEC
.f99a	e9 13		sbc #$13	   SBC #$13
.f99c	e5 b1		sbc $b1		   SBC CMPO+1        ; subtract tape timing constant max byte
.f99e	65 92		adc $92		   ADC SVXT          ; add timing constant for tape
.f9a0	85 92		sta $92		   STA SVXT          ; save timing constant for tape
.f9a2	a5 a4		lda $a4		   LDA TBTCNT        ; get tape bit cycle phase
.f9a4	49 01		eor #$01	   EOR #$01
.f9a6	85 a4		sta $a4		   STA TBTCNT        ; save tape bit cycle phase
.f9a8	f0 2b		beq $f9d5	   BEQ TARI_22
.f9aa	86 d7		stx $d7		   STX LASTKY
.f9ac					TARI_14
.f9ac	a5 b4		lda $b4		   LDA BITTS         ; get bit count
.f9ae	f0 22		beq $f9d2	   BEQ TARI_20       ; exit if zero
.f9b0	ad a3 02	lda $02a3	   LDA TRDTMP
.f9b3	29 01		and #$01	   AND #1
.f9b5	d0 05		bne $f9bc	   BNE TARI_16
.f9b7	ad a4 02	lda $02a4	   LDA TD1IRQ
.f9ba	d0 16		bne $f9d2	   BNE TARI_20
.f9bc					TARI_16
.f9bc	a9 00		lda #$00	   LDA #$00
.f9be	85 a4		sta $a4		   STA TBTCNT        ; clear tape bit cycle phase
.f9c0	8d a4 02	sta $02a4	   STA TD1IRQ
.f9c3	a5 a3		lda $a3		   LDA TSFCNT        ;.get EOI flag byte
.f9c5	10 30		bpl $f9f7	   BPL TARI_28
.f9c7	30 bf		bmi $f988	   BMI TARI_04
.f9c9					TARI_18
.f9c9	a2 a6		ldx #$a6	   LDX #$A6          ; set timimg max byte
.f9cb	20 e2 f8	jsr $f8e2	   JSR TAPE_Set_Timer
.f9ce	a5 9b		lda $9b		   LDA PRTY
.f9d0	d0 b9		bne $f98b	   BNE TARI_06
.f9d2					TARI_20
.f9d2	4c bc fe	jmp $febc	   JMP Exit_IRQ      ; restore registers and exit interrupt
.f9d5					TARI_22
.f9d5	a5 92		lda $92		   LDA SVXT          ; get timing constant for tape
.f9d7	f0 07		beq $f9e0	   BEQ TARI_26
.f9d9	30 03		bmi $f9de	   BMI TARI_24
.f9db	c6 b0		dec $b0		   DEC CMPO          ; decrement tape timing constant min byte
>f9dd	2c				   .byte   $2C
.f9de					TARI_24
.f9de	e6 b0		inc $b0		   INC CMPO          ; increment tape timing constant min byte
.f9e0					TARI_26
.f9e0	a9 00		lda #$00	   LDA #0
.f9e2	85 92		sta $92		   STA SVXT          ; clear timing constant for tape
.f9e4	e4 d7		cpx $d7		   CPX LASTKY
.f9e6	d0 0f		bne $f9f7	   BNE TARI_28
.f9e8	8a		txa		   TXA
.f9e9	d0 a0		bne $f98b	   BNE TARI_06
.f9eb	a5 a9		lda $a9		   LDA RINONE        ; get start bit check flag
.f9ed	30 bd		bmi $f9ac	   BMI TARI_14
.f9ef	c9 10		cmp #$10	   CMP #$10
.f9f1	90 b9		bcc $f9ac	   BCC TARI_14
.f9f3	85 96		sta $96		   STA SYNO          ; save cassette block synchronization number
.f9f5	b0 b5		bcs $f9ac	   BCS TARI_14
.f9f7					TARI_28
.f9f7	8a		txa		   TXA
.f9f8	45 9b		eor $9b		   EOR PRTY
.f9fa	85 9b		sta $9b		   STA PRTY
.f9fc	a5 b4		lda $b4		   LDA BITTS
.f9fe	f0 d2		beq $f9d2	   BEQ TARI_20
.fa00	c6 a3		dec $a3		   DEC TSFCNT        ; decrement EOI flag byte
.fa02	30 c5		bmi $f9c9	   BMI TARI_18
.fa04	46 d7		lsr $d7		   LSR LASTKY
.fa06	66 bf		ror $bf		   ROR MYCH          ; parity count
.fa08	a2 da		ldx #$da	   LDX #$DA          ; set timimg max byte
.fa0a	20 e2 f8	jsr $f8e2	   JSR TAPE_Set_Timer
.fa0d	4c bc fe	jmp $febc	   JMP Exit_IRQ      ; restore registers and exit interrupt
.fa10					TARI_30
.fa10	a5 96		lda $96		   LDA SYNO          ; get cassette block synchronization number
.fa12	f0 04		beq $fa18	   BEQ TARI_32
.fa14	a5 b4		lda $b4		   LDA BITTS
.fa16	f0 07		beq $fa1f	   BEQ TARI_34
.fa18					TARI_32
.fa18	a5 a3		lda $a3		   LDA TSFCNT        ; get EOI flag byte
.fa1a	30 03		bmi $fa1f	   BMI TARI_34
.fa1c	4c 97 f9	jmp $f997	   JMP TARI_10
.fa1f					TARI_34
.fa1f	46 b1		lsr $b1		   LSR CMPO+1        ; shift tape timing constant max byte
.fa21	a9 93		lda #$93	   LDA #$93
.fa23	38		sec		   SEC
.fa24	e5 b1		sbc $b1		   SBC CMPO+1        ; subtract tape timing constant max byte
.fa26	65 b0		adc $b0		   ADC CMPO          ; add tape timing constant min byte
.fa28	0a		asl a		   ASL A
.fa29	aa		tax		   TAX               ; copy timimg high byte
.fa2a	20 e2 f8	jsr $f8e2	   JSR TAPE_Set_Timer      ; set timing
.fa2d	e6 9c		inc $9c		   INC DPSW
.fa2f	a5 b4		lda $b4		   LDA BITTS
.fa31	d0 11		bne $fa44	   BNE TARI_36
.fa33	a5 96		lda $96		   LDA SYNO          ; get cassette block synchronization number
.fa35	f0 26		beq $fa5d	   BEQ TARI_40
.fa37	85 a8		sta $a8		   STA BITCI         ; save receiver bit count in
.fa39	a9 00		lda #$00	   LDA #$00
.fa3b	85 96		sta $96		   STA SYNO          ; clear cassette block synchronization number
.fa3d	a9 81		lda #$81	   LDA #$81
.fa3f	8d 0d dc	sta $dc0d	   STA VIA2_IER      ; set VIA 2 IER
.fa42	85 b4		sta $b4		   STA BITTS
.fa44					TARI_36
.fa44	a5 96		lda $96		   LDA SYNO          ; get cassette block synchronization number
.fa46	85 b5		sta $b5		   STA NXTBIT
.fa48	f0 09		beq $fa53	   BEQ TARI_38
.fa4a	a9 00		lda #$00	   LDA #$00
.fa4c	85 b4		sta $b4		   STA BITTS
.fa4e	a9 01		lda #$01	   LDA #1
.fa50	8d 0d dc	sta $dc0d	   STA VIA2_IER      ; set VIA 2 IER
.fa53					TARI_38
.fa53	a5 bf		lda $bf		   LDA MYCH          ; parity count
.fa55	85 bd		sta $bd		   STA ROPRTY        ; save RS232 parity byte
.fa57	a5 a8		lda $a8		   LDA BITCI         ; get receiver bit count in
.fa59	05 a9		ora $a9		   ORA RINONE        ; OR with start bit check flag
.fa5b	85 b6		sta $b6		   STA RODATA
.fa5d					TARI_40
.fa5d	4c bc fe	jmp $febc	   JMP Exit_IRQ      ; restore registers and exit interrupt
.fa60					  TAPE_Store_Char
.fa60	20 97 fb	jsr $fb97	   JSR TAPE_New_Byte_Setup
.fa63	85 9c		sta $9c		   STA DPSW          ; clear byte received flag
.fa65	a2 da		ldx #$da	   LDX #$DA          ; set timimg max byte
.fa67	20 e2 f8	jsr $f8e2	   JSR TAPE_Set_Timer
.fa6a	a5 be		lda $be		   LDA FSBLK         ; get copies count
.fa6c	f0 02		beq $fa70	   BEQ TASC_10
.fa6e	85 a7		sta $a7		   STA INBIT         ; save receiver input bit temporary storage
.fa70					TASC_10
.fa70	a9 0f		lda #$0f	   LDA #$0F
.fa72	24 aa		bit $aa		   BIT RIDATA
.fa74	10 17		bpl $fa8d	   BPL TASC_40
.fa76	a5 b5		lda $b5		   LDA NXTBIT
.fa78	d0 0c		bne $fa86	   BNE TASC_20
.fa7a	a6 be		ldx $be		   LDX FSBLK         ; get copies count
.fa7c	ca		dex		   DEX
.fa7d	d0 0b		bne $fa8a	   BNE TASC_30       ; if ?? restore registers and exit interrupt
.fa7f	a9 08		lda #$08	   LDA #$08          ; set short block
.fa81	20 1c fe	jsr $fe1c	   JSR Ora_Status
.fa84	d0 04		bne $fa8a	   BNE TASC_30       ; restore registers and exit interrupt, branch always
.fa86					TASC_20
.fa86	a9 00		lda #$00	   LDA #$00
.fa88	85 aa		sta $aa		   STA RIDATA
.fa8a					TASC_30
.fa8a	4c bc fe	jmp $febc	   JMP Exit_IRQ      ; restore registers and exit interrupt
.fa8d					TASC_40
.fa8d	70 31		bvs $fac0	   BVS TASC_64
.fa8f	d0 18		bne $faa9	   BNE TASC_60
.fa91	a5 b5		lda $b5		   LDA NXTBIT
.fa93	d0 f5		bne $fa8a	   BNE TASC_30
.fa95	a5 b6		lda $b6		   LDA RODATA
.fa97	d0 f1		bne $fa8a	   BNE TASC_30
.fa99	a5 a7		lda $a7		   LDA INBIT         ; get receiver input bit temporary storage
.fa9b	4a		lsr a		   LSR A
.fa9c	a5 bd		lda $bd		   LDA ROPRTY        ; get RS232 parity byte
.fa9e	30 03		bmi $faa3	   BMI TASC_50
.faa0	90 18		bcc $faba	   BCC TASC_62
.faa2	18		clc		   CLC
.faa3					TASC_50
.faa3	b0 15		bcs $faba	   BCS TASC_62
.faa5	29 0f		and #$0f	   AND #$0F
.faa7	85 aa		sta $aa		   STA RIDATA
.faa9					TASC_60
.faa9	c6 aa		dec $aa		   DEC RIDATA
.faab	d0 dd		bne $fa8a	   BNE TASC_30
.faad	a9 40		lda #$40	   LDA #$40
.faaf	85 aa		sta $aa		   STA RIDATA
.fab1	20 8e fb	jsr $fb8e	   JSR Set_IO_Start
.fab4	a9 00		lda #$00	   LDA #0
.fab6	85 ab		sta $ab		   STA RIPRTY
.fab8	f0 d0		beq $fa8a	   BEQ TASC_30      ; branch always
.faba					TASC_62
.faba	a9 80		lda #$80	   LDA #$80
.fabc	85 aa		sta $aa		   STA RIDATA
.fabe	d0 ca		bne $fa8a	   BNE TASC_30      ; restore registers and exit interrupt, branch always
.fac0					TASC_64
.fac0	a5 b5		lda $b5		   LDA NXTBIT
.fac2	f0 0a		beq $face	   BEQ TASC_66
.fac4					TASC_65
.fac4	a9 04		lda #$04	   LDA #$04
.fac6	20 1c fe	jsr $fe1c	   JSR Ora_Status
.fac9	a9 00		lda #$00	   LDA #$00
.facb	4c 4a fb	jmp $fb4a	   JMP TASC_84
.face					TASC_66
.face	20 d1 fc	jsr $fcd1	   JSR Check_IO_End
.fad1	90 03		bcc $fad6	   BCC TASC_68
.fad3	4c 48 fb	jmp $fb48	   JMP TASC_82
.fad6					TASC_68
.fad6	a6 a7		ldx $a7		   LDX INBIT         ; get receiver input bit temporary storage
.fad8	ca		dex		   DEX
.fad9	f0 2d		beq $fb08	   BEQ TASC_72
.fadb	a5 93		lda $93		   LDA VERCKK
.fadd	f0 0c		beq $faeb	   BEQ TASC_70
.fadf	a0 00		ldy #$00	   LDY #0
.fae1	a5 bd		lda $bd		   LDA ROPRTY
.fae3	d1 ac		cmp ($ac),y	   CMP (SAL),Y
.fae5	f0 04		beq $faeb	   BEQ TASC_70
.fae7	a9 01		lda #$01	   LDA #$01
.fae9	85 b6		sta $b6		   STA RODATA
.faeb					TASC_70
.faeb	a5 b6		lda $b6		   LDA RODATA
.faed	f0 4b		beq $fb3a	   BEQ TASC_78
.faef	a2 3d		ldx #$3d	   LDX #$3D
.faf1	e4 9e		cpx $9e		   CPX PTR1
.faf3	90 3e		bcc $fb33	   BCC TASC_76
.faf5	a6 9e		ldx $9e		   LDX PTR1
.faf7	a5 ad		lda $ad		   LDA SAL+1
.faf9	9d 01 01	sta $0101,x	   STA STACK+1,X
.fafc	a5 ac		lda $ac		   LDA SAL
.fafe	9d 00 01	sta $0100,x	   STA STACK,X
.fb01	e8		inx		   INX
.fb02	e8		inx		   INX
.fb03	86 9e		stx $9e		   STX PTR1
.fb05	4c 3a fb	jmp $fb3a	   JMP TASC_78
.fb08					TASC_72
.fb08	a6 9f		ldx $9f		   LDX PTR2
.fb0a	e4 9e		cpx $9e		   CPX PTR1
.fb0c	f0 35		beq $fb43	   BEQ TASC_80
.fb0e	a5 ac		lda $ac		   LDA SAL
.fb10	dd 00 01	cmp $0100,x	   CMP STACK,X
.fb13	d0 2e		bne $fb43	   BNE TASC_80
.fb15	a5 ad		lda $ad		   LDA SAL+1
.fb17	dd 01 01	cmp $0101,x	   CMP STACK+1,X
.fb1a	d0 27		bne $fb43	   BNE TASC_80
.fb1c	e6 9f		inc $9f		   INC PTR2
.fb1e	e6 9f		inc $9f		   INC PTR2
.fb20	a5 93		lda $93		   LDA VERCKK        ; get load/verify flag
.fb22	f0 0b		beq $fb2f	   BEQ TASC_74      ; branch if load
.fb24	a5 bd		lda $bd		   LDA ROPRTY        ; get RS232 parity byte
.fb26	a0 00		ldy #$00	   LDY #$00
.fb28	d1 ac		cmp ($ac),y	   CMP (SAL),Y
.fb2a	f0 17		beq $fb43	   BEQ TASC_80
.fb2c	c8		iny		   INY
.fb2d	84 b6		sty $b6		   STY RODATA
.fb2f					TASC_74
.fb2f	a5 b6		lda $b6		   LDA RODATA
.fb31	f0 07		beq $fb3a	   BEQ TASC_78
.fb33					TASC_76
.fb33	a9 10		lda #$10	   LDA #$10
.fb35	20 1c fe	jsr $fe1c	   JSR Ora_Status
.fb38	d0 09		bne $fb43	   BNE TASC_80
.fb3a					TASC_78
.fb3a	a5 93		lda $93		   LDA VERCKK        ; get load/verify flag
.fb3c	d0 05		bne $fb43	   BNE TASC_80       ; branch if verify
.fb3e	a8		tay		   TAY
.fb3f	a5 bd		lda $bd		   LDA ROPRTY        ; get RS232 parity byte
.fb41	91 ac		sta ($ac),y	   STA (SAL),Y
.fb43					TASC_80
.fb43	20 db fc	jsr $fcdb	   JSR Inc_SAL_Word
.fb46	d0 43		bne $fb8b	   BNE TASC_92      ; restore registers and exit interrupt, branch always
.fb48					TASC_82
.fb48	a9 80		lda #$80	   LDA #$80
.fb4a					TASC_84
.fb4a	85 aa		sta $aa		   STA RIDATA
.fb4c	78		sei		   SEI
.fb4d	a2 01		ldx #$01	   LDX #1
.fb4f	8e 0d dc	stx $dc0d	   STX CIA1_ICR      ; CIA1 Interrupt Control Register
.fb52	ae 0d dc	ldx $dc0d	   LDX CIA1_ICR      ; CIA1 Interrupt Control Register
.fb55	a6 be		ldx $be		   LDX FSBLK         ; get copies count
.fb57	ca		dex		   DEX
.fb58	30 02		bmi $fb5c	   BMI TASC_86
.fb5a	86 be		stx $be		   STX FSBLK         ; save copies count
.fb5c					TASC_86
.fb5c	c6 a7		dec $a7		   DEC INBIT         ; decrement receiver input bit temporary storage
.fb5e	f0 08		beq $fb68	   BEQ TASC_88
.fb60	a5 9e		lda $9e		   LDA PTR1
.fb62	d0 27		bne $fb8b	   BNE TASC_92       ; if ?? restore registers and exit interrupt
.fb64	85 be		sta $be		   STA FSBLK         ; save copies count
.fb66	f0 23		beq $fb8b	   BEQ TASC_92       ; restore registers and exit interrupt, branch always
.fb68					TASC_88
.fb68	20 93 fc	jsr $fc93	   JSR Restoring_After_STOP
.fb6b	20 8e fb	jsr $fb8e	   JSR Set_IO_Start
.fb6e	a0 00		ldy #$00	   LDY #0
.fb70	84 ab		sty $ab		   STY RIPRTY        ; clear checksum
.fb72					TASC_90
.fb72	b1 ac		lda ($ac),y	   LDA (SAL),Y       ; get byte from buffer
.fb74	45 ab		eor $ab		   EOR RIPRTY        ; XOR with checksum
.fb76	85 ab		sta $ab		   STA RIPRTY        ; save new checksum
.fb78	20 db fc	jsr $fcdb	   JSR Inc_SAL_Word
.fb7b	20 d1 fc	jsr $fcd1	   JSR Check_IO_End
.fb7e	90 f2		bcc $fb72	   BCC TASC_90       ; loop if not at end
.fb80	a5 ab		lda $ab		   LDA RIPRTY        ; get computed checksum
.fb82	45 bd		eor $bd		   EOR ROPRTY        ; compare with stored checksum ??
.fb84	f0 05		beq $fb8b	   BEQ TASC_92       ; if checksum ok restore registers and exit interrupt
.fb86	a9 20		lda #$20	   LDA #$20          ; else set checksum error
.fb88	20 1c fe	jsr $fe1c	   JSR Ora_Status
.fb8b					TASC_92
.fb8b	4c bc fe	jmp $febc	   JMP Exit_IRQ      ; restore registers and exit interrupt
.fb8e					Set_IO_Start
.fb8e	a5 c2		lda $c2		   LDA STAL+1        ; get I/O start address high byte
.fb90	85 ad		sta $ad		   STA SAL+1         ; set buffer address high byte
.fb92	a5 c1		lda $c1		   LDA STAL          ; get I/O start address low byte
.fb94	85 ac		sta $ac		   STA SAL           ; set buffer address low byte
.fb96	60		rts		   RTS
.fb97					  TAPE_New_Byte_Setup
.fb97	a9 08		lda #$08	   LDA #$08          ; eight bits to do
.fb99	85 a3		sta $a3		   STA TSFCNT        ; set bit count
.fb9b	a9 00		lda #$00	   LDA #0
.fb9d	85 a4		sta $a4		   STA TBTCNT        ; clear tape bit cycle phase
.fb9f	85 a8		sta $a8		   STA BITCI         ; clear start bit first cycle done flag
.fba1	85 9b		sta $9b		   STA PRTY          ; clear byte parity
.fba3	85 a9		sta $a9		   STA RINONE        ; clear start bit check flag, set no start bit yet
.fba5	60		rts		   RTS
.fba6					  TAPE_Write_Bit
.fba6	a5 bd		lda $bd		   LDA ROPRTY        ; get tape write byte
.fba8	4a		lsr a		   LSR A             ; shift lsb into Cb
.fba9	a9 60		lda #$60	   LDA #$60          ; set time constant low byte for bit = 0
.fbab	90 02		bcc $fbaf	   BCC TAPE_Write_Timer
.fbad					  TAPE_Timer_Bit_Is_1
.fbad	a9 b0		lda #$b0	   LDA #$B0          ; set time constant low byte for bit = 1
.fbaf					  TAPE_Write_Timer
.fbaf	a2 00		ldx #$00	   LDX #$00          ; set time constant high byte
.fbb1					  TAPE_Start_Timer
.fbb1	8d 06 dc	sta $dc06	   STA VIA2_T2CL     ; set VIA 2 T2C_l
.fbb4	8e 07 dc	stx $dc07	   STX VIA2_T2CH     ; set VIA 2 T2C_h
.fbb7	ad 0d dc	lda $dc0d	   LDA CIA1_ICR    ; CIA1 Interrupt Control Register
.fbba	a9 19		lda #$19	   LDA #$19
.fbbc	8d 0f dc	sta $dc0f	   STA CIA1_CRB    ; CIA1 Control Register B
.fbbf	a5 01		lda $01		   LDA R6510
.fbc1	49 08		eor #$08	   EOR #$08          ; toggle tape out bit
.fbc3	85 01		sta $01		    STA R6510
.fbc5	29 08		and #$08	   AND #$08          ; mask tape out bit
.fbc7	60		rts		   RTS
.fbc8					TAST_10
.fbc8	38		sec		   SEC               ; set carry flag
.fbc9	66 b6		ror $b6		   ROR RODATA
.fbcb	30 3c		bmi $fc09	   BMI TAWI_15      ; restore registers and exit interrupt, branch always
.fbcd					  TAPE_Write_IRQ
.fbcd	a5 a8		lda $a8		   LDA BITCI         ; get start bit first cycle done flag
.fbcf	d0 12		bne $fbe3	   BNE TAWI_05       ; if first cycle done go do rest of byte
.fbd1	a9 10		lda #$10	   LDA #$10          ; set first start cycle time constant low byte
.fbd3	a2 01		ldx #$01	   LDX #$01          ; set first start cycle time constant high byte
.fbd5	20 b1 fb	jsr $fbb1	   JSR TAPE_Start_Timer
.fbd8	d0 2f		bne $fc09	   BNE TAWI_15      ; if first half cycle go restore registers and exit
.fbda	e6 a8		inc $a8		   INC BITCI         ; set start bit first start cycle done flag
.fbdc	a5 b6		lda $b6		   LDA RODATA
.fbde	10 29		bpl $fc09	   BPL TAWI_15      ; if block not complete go restore registers and exit
.fbe0	4c 57 fc	jmp $fc57	   JMP TAWI_55      ; else do tape routine, block complete exit
.fbe3					TAWI_05
.fbe3	a5 a9		lda $a9		   LDA RINONE        ; get start bit check flag
.fbe5	d0 09		bne $fbf0	   BNE TAWI_10       ; if the start bit is complete go send the byte bits
.fbe7	20 ad fb	jsr $fbad	   JSR TAPE_Timer_Bit_Is_1
.fbea	d0 1d		bne $fc09	   BNE TAWI_15       ; if first half cycle go restore registers and exit
.fbec	e6 a9		inc $a9		   INC RINONE        ; set start bit check flag
.fbee	d0 19		bne $fc09	   BNE TAWI_15       ; restore registers and exit interrupt, branch always
.fbf0					TAWI_10
.fbf0	20 a6 fb	jsr $fba6	   JSR TAPE_Write_Bit
.fbf3	d0 14		bne $fc09	   BNE TAWI_15       ; if first half cycle go restore registers and exit
.fbf5	a5 a4		lda $a4		   LDA TBTCNT        ; get tape bit cycle phase
.fbf7	49 01		eor #$01	   EOR #$01          ; toggle b0
.fbf9	85 a4		sta $a4		   STA TBTCNT        ; save tape bit cycle phase
.fbfb	f0 0f		beq $fc0c	   BEQ TAWI_20       ; if bit cycle phase complete go setup for next bit
.fbfd	a5 bd		lda $bd		   LDA ROPRTY        ; get tape write byte
.fbff	49 01		eor #$01	   EOR #$01          ; invert bit being sent
.fc01	85 bd		sta $bd		   STA ROPRTY        ; save tape write byte
.fc03	29 01		and #$01	   AND #$01          ; mask b0
.fc05	45 9b		eor $9b		   EOR PRTY          ; EOR with tape write byte parity bit
.fc07	85 9b		sta $9b		   STA PRTY          ; save tape write byte parity bit
.fc09					TAWI_15
.fc09	4c bc fe	jmp $febc	   JMP Exit_IRQ      ; restore registers and exit interrupt
.fc0c					TAWI_20
.fc0c	46 bd		lsr $bd		   LSR ROPRTY        ; shift bit out of tape write byte
.fc0e	c6 a3		dec $a3		   DEC TSFCNT        ; decrement tape write bit count
.fc10	a5 a3		lda $a3		   LDA TSFCNT        ; get tape write bit count
.fc12	f0 3a		beq $fc4e	   BEQ TAWI_45       ; if all the data bits have been written go setup for
.fc14	10 f3		bpl $fc09	   BPL TAWI_15       ; if all the data bits are not yet sent just restore the
.fc16					TAWI_25
.fc16	20 97 fb	jsr $fb97	   JSR TAPE_New_Byte_Setup
.fc19	58		cli		   CLI               ; enable interrupts
.fc1a	a5 a5		lda $a5		   LDA CNTDN         ; get cassette synchronization character count
.fc1c	f0 12		beq $fc30	   BEQ TAWI_35       ; if synchronisation characters done go do block data
.fc1e	a2 00		ldx #$00	   LDX #$00          ; clear X
.fc20	86 d7		stx $d7		   STX LASTKY        ; clear checksum byte
.fc22	c6 a5		dec $a5		   DEC CNTDN         ; decrement cassette synchronization byte count
.fc24	a6 be		ldx $be		   LDX FSBLK         ; get cassette copies count
.fc26	e0 02		cpx #$02	   CPX #$02          ; compare with load block indicator
.fc28	d0 02		bne $fc2c	   BNE TAWI_30       ; branch if not the load block
.fc2a	09 80		ora #$80	   ORA #$80          ; this is the load block so make the synchronisation count
.fc2c					TAWI_30
.fc2c	85 bd		sta $bd		   STA ROPRTY        ; save the synchronisation byte as the tape write byte
.fc2e	d0 d9		bne $fc09	   BNE TAWI_15       ; restore registers and exit interrupt, branch always
.fc30					TAWI_35
.fc30	20 d1 fc	jsr $fcd1	   JSR Check_IO_End
.fc33	90 0a		bcc $fc3f	   BCC TAWI_40       ; if not all done yet go get the byte to send
.fc35	d0 91		bne $fbc8	   BNE TAST_10       ; if pointer > end go flag block done and exit interrupt
.fc37	e6 ad		inc $ad		   INC SAL+1         ; increment buffer pointer high byte, this means the block
.fc39	a5 d7		lda $d7		   LDA LASTKY        ; get checksum byte
.fc3b	85 bd		sta $bd		   STA ROPRTY        ; save checksum as tape write byte
.fc3d	b0 ca		bcs $fc09	   BCS TAWI_15       ; restore registers and exit interrupt, branch always
.fc3f					TAWI_40
.fc3f	a0 00		ldy #$00	   LDY #0
.fc41	b1 ac		lda ($ac),y	   LDA (SAL),Y       ; get byte from buffer
.fc43	85 bd		sta $bd		   STA ROPRTY        ; save as tape write byte
.fc45	45 d7		eor $d7		   EOR LASTKY        ; XOR with checksum byte
.fc47	85 d7		sta $d7		   STA LASTKY        ; save new checksum byte
.fc49	20 db fc	jsr $fcdb	   JSR Inc_SAL_Word
.fc4c	d0 bb		bne $fc09	   BNE TAWI_15       ; restore registers and exit interrupt, branch always
.fc4e					TAWI_45
.fc4e	a5 9b		lda $9b		   LDA PRTY          ; get parity bit
.fc50	49 01		eor #$01	   EOR #$01          ; toggle it
.fc52	85 bd		sta $bd		   STA ROPRTY        ; save as tape write byte
.fc54					TAWI_50
.fc54	4c bc fe	jmp $febc	   JMP Exit_IRQ      ; restore registers and exit interrupt
.fc57					TAWI_55
.fc57	c6 be		dec $be		   DEC FSBLK         ; decrement copies remaining to read/write
.fc59	d0 03		bne $fc5e	   BNE TAWI_60       ; branch if more to do
.fc5b	20 ca fc	jsr $fcca	   JSR TAPE_Stop_Motor
.fc5e					TAWI_60
.fc5e	a9 50		lda #$50	   LDA #$50          ; set tape write leader count
.fc60	85 a7		sta $a7		   STA INBIT         ; save tape write leader count
.fc62	a2 08		ldx #$08	   LDX #$08          ; set index for write tape leader vector
.fc64	78		sei		   SEI               ; disable interrupts
.fc65	20 bd fc	jsr $fcbd	   JSR TAPE_Set_IRQ_Vector
.fc68	d0 ea		bne $fc54	   BNE TAWI_50       ; restore registers and exit interrupt, branch always
.fc6a					TAPE_Write_Leader
.fc6a	a9 78		lda #$78	   LDA #$78          ; set time constant low byte for bit = leader
.fc6c	20 af fb	jsr $fbaf	   JSR TAPE_Write_Timer
.fc6f	d0 e3		bne $fc54	   BNE TAWI_50       ; if tape bit high restore registers and exit interrupt
.fc71	c6 a7		dec $a7		   DEC INBIT         ; decrement cycle count
.fc73	d0 df		bne $fc54	   BNE TAWI_50       ; if not all done restore registers and exit interrupt
.fc75	20 97 fb	jsr $fb97	   JSR TAPE_New_Byte_Setup
.fc78	c6 ab		dec $ab		   DEC RIPRTY        ; decrement cassette leader count
.fc7a	10 d8		bpl $fc54	   BPL TAWI_50       ; if not all done restore registers and exit interrupt
.fc7c	a2 0a		ldx #$0a	   LDX #$0A          ; set index for tape write vector
.fc7e	20 bd fc	jsr $fcbd	   JSR TAPE_Set_IRQ_Vector
.fc81	58		cli		   CLI               ; enable interrupts
.fc82	e6 ab		inc $ab		   INC RIPRTY        ; clear cassette leader counter, was $FF
.fc84	a5 be		lda $be		   LDA FSBLK         ; get cassette block count
.fc86	f0 30		beq $fcb8	   BEQ Reset_TAPE_IRQ      ; if all done restore everything for STOP and exit interrupt
.fc88	20 8e fb	jsr $fb8e	   JSR Set_IO_Start
.fc8b	a2 09		ldx #$09	   LDX #$09          ; set nine synchronisation bytes
.fc8d	86 a5		stx $a5		   STX CNTDN         ; save cassette synchronization byte count
.fc8f	86 b6		stx $b6		   STX RODATA
.fc91	d0 83		bne $fc16	   BNE TAWI_25      ; go do next tape byte, branch always
.fc93					  Restoring_After_STOP
.fc93	08		php		   PHP               ; save status
.fc94	78		sei		   SEI               ; disable interrupts
.fc95	ad 11 d0	lda $d011	   LDA VIC_CONTROL_1
.fc98	09 10		ora #$10	   ORA #$10          ; set DEN bit
.fc9a	8d 11 d0	sta $d011	   STA VIC_CONTROL_1
.fc9d	20 ca fc	jsr $fcca	   JSR TAPE_Stop_Motor
.fca0	a9 7f		lda #$7f	   LDA #$7F          ; disable all interrupts
.fca2	8d 0d dc	sta $dc0d	   STA CIA1_ICR      ; CIA1 Interrupt Control Register
.fca5	20 dd fd	jsr $fddd	   JSR Program_Timer_A
.fca8	ad a0 02	lda $02a0	   LDA IRQTMP+1      ; get saved IRQ vector high byte
.fcab	f0 09		beq $fcb6	   BEQ RAS_10        ; branch if null
.fcad	8d 15 03	sta $0315	   STA CINV+1        ; restore IRQ vector high byte
.fcb0	ad 9f 02	lda $029f	   LDA IRQTMP        ; get saved IRQ vector low byte
.fcb3	8d 14 03	sta $0314	   STA CINV          ; restore IRQ vector low byte
.fcb6					RAS_10
.fcb6	28		plp		   PLP               ; restore status
.fcb7	60		rts		   RTS
.fcb8					  Reset_TAPE_IRQ
.fcb8	20 93 fc	jsr $fc93	   JSR Restoring_After_STOP
.fcbb	f0 97		beq $fc54	   BEQ TAWI_50      ; restore registers and exit interrupt, branch always
.fcbd					  TAPE_Set_IRQ_Vector
.fcbd	bd 93 fd	lda $fd93,x	   LDA TAPE_IRQ_Vectors-8,X  ; get tape IRQ vector low byte
.fcc0	8d 14 03	sta $0314	   STA CINV          ; set IRQ vector low byte
.fcc3	bd 94 fd	lda $fd94,x	   LDA TAPE_IRQ_Vectors-7,X  ; get tape IRQ vector high byte
.fcc6	8d 15 03	sta $0315	   STA CINV+1        ; set IRQ vector high byte
.fcc9	60		rts		   RTS
.fcca					  TAPE_Stop_Motor
.fcca	a5 01		lda $01		   LDA R6510
.fccc	09 20		ora #$20	   ORA #$20
.fcce	85 01		sta $01		   STA R6510
.fcd0	60		rts		   RTS
.fcd1					  Check_IO_End
.fcd1	38		sec		   SEC
.fcd2	a5 ac		lda $ac		   LDA SAL           ; get buffer address low byte
.fcd4	e5 ae		sbc $ae		   SBC EAL           ; subtract buffer end low byte
.fcd6	a5 ad		lda $ad		   LDA SAL+1         ; get buffer address high byte
.fcd8	e5 af		sbc $af		   SBC EAL+1         ; subtract buffer end high byte
.fcda	60		rts		   RTS
.fcdb					  Inc_SAL_Word
.fcdb	e6 ac		inc $ac		   INC SAL
.fcdd	d0 02		bne $fce1	   BNE ISW_Ret
.fcdf	e6 ad		inc $ad		   INC SAL+1
.fce1					ISW_Ret
.fce1	60		rts		   RTS
.fce2					  Entry_RESET
.fce2	a2 ff		ldx #$ff	   LDX #$FF          ; set X for stack
.fce4	78		sei		   SEI               ; disable interrupts
.fce5	9a		txs		   TXS               ; clear stack
.fce6	d8		cld		   CLD               ; clear decimal mode
.fce7	20 02 fd	jsr $fd02	   JSR Scan_Autostart_Signature
.fcea	d0 03		bne $fcef	   BNE HARE_10       ; if not there continue Vic startup
.fcec	6c 00 80	jmp ($8000)	   JMP (OPTION_ROM)
.fcef					HARE_10
.fcef	8e 16 d0	stx $d016	   STX VIC_CONTROL_2
.fcf2	20 a3 fd	jsr $fda3	   JSR Initialise_IO
.fcf5	20 50 fd	jsr $fd50	   JSR Init_RAM
.fcf8	20 15 fd	jsr $fd15	   JSR Kernal_RESTOR
.fcfb	20 5b ff	jsr $ff5b	   JSR Init_Editor
.fcfe	58		cli		   CLI               ; enable interrupts
.fcff	6c 00 a0	jmp ($a000)	   JMP (BASIC_ROM)   ; start BASIC
.fd02					  Scan_Autostart_Signature
.fd02	a2 05		ldx #$05	   LDX #5            ; five characters to test
.fd04					SAAS_Loop
.fd04	bd 0f fd	lda $fd0f,x	   LDA ROM_SIG-1,X   ; get test character
.fd07	dd 03 80	cmp $8003,x	   CMP OPTION_ROM+3,X; compare with byte in block A000
.fd0a	d0 03		bne $fd0f	   BNE SAAS_Exit     ; exit if no match
.fd0c	ca		dex		   DEX               ; decrement index
.fd0d	d0 f5		bne $fd04	   BNE SAAS_Loop
.fd0f					SAAS_Exit
.fd0f	60		rts		   RTS
>fd10	c3 c2 cd 38 30			ROM_SIG .TEXT $C3,$C2,$CD,"80" ; CBM80
.fd15					  Kernal_RESTOR
.fd15	a2 30		ldx #$30	   LDX #<Kernal_Vectors    ; pointer to vector table low byte
.fd17	a0 fd		ldy #$fd	   LDY #>Kernal_Vectors    ; pointer to vector table high byte
.fd19	18		clc		   CLC               ; flag set vectors
.fd1a					  Kernal_VECTOR
.fd1a	86 c3		stx $c3		   STX MEMUSS
.fd1c	84 c4		sty $c4		   STY MEMUSS+1
.fd1e	a0 1f		ldy #$1f	   LDY #$1F          ; set byte count
.fd20					KeVE_10
.fd20	b9 14 03	lda $0314,y	   LDA CINV,Y        ; read vector byte from vectors
.fd23	b0 02		bcs $fd27	   BCS KeVE_20       ; if read vectors skip the read from XY
.fd25	b1 c3		lda ($c3),y	   LDA (MEMUSS),Y    ; read vector byte from (XY)
.fd27					KeVE_20
.fd27	91 c3		sta ($c3),y	   STA (MEMUSS),Y    ; save byte to (XY) [may be ROM address]
.fd29					KeVe_30
.fd29	99 14 03	sta $0314,y	   STA CINV,Y        ; save byte to vector
.fd2c	88		dey		   DEY               ; decrement index
.fd2d	10 f1		bpl $fd20	   BPL KeVE_10       ; loop if more to do
.fd2f	60		rts		   RTS
.fd30					  Kernal_Vectors
>fd30	31 ea				   .word   Default_IRQ   ; CINV   IRQ vector
>fd32	66 fe				   .word   Default_BRK   ; CBINV  BRK vector
>fd34	47 fe				   .word   Default_NMI   ; NMINV  NMI vector
>fd36	4a f3				   .word   Kernal_OPEN   ; IOPEN  Open a logical file
>fd38	91 f2				   .word   Kernal_CLOSE  ; ICLOSE close a logical file
>fd3a	0e f2				   .word   Kernal_ICHKIN ; ICHKIN open channel for input
>fd3c	50 f2				   .word   Kernal_CHKOUT ; ICKOUT open channel for output
>fd3e	33 f3				   .word   Kernal_CLRCHN ; ICLRCH clear I/O channels
>fd40	57 f1				   .word   Kernal_CHRIN  ; IBASIN get a character from the input channel
>fd42	ca f1				   .word   Kernal_CHROUT ; IBSOUT output a character
>fd44	ed f6				   .word   Kernal_STOP   ; ISTOP  check if stop key is pressed
>fd46	3e f1				   .word   Kernal_GETIN  ; IGETIN get character from keyboard queue
>fd48	2f f3				   .word   Kernal_CLALL  ; ICLALL close all channels and files
>fd4a	66 fe				   .word   Default_BRK   ; USRCMD user function
>fd4c	a5 f4				   .word   Default_LOAD; ILOAD      load
>fd4e	ed f5				   .word   Default_SAVE; ISAVE      save
.fd50					Init_RAM
.fd50	a9 00		lda #$00	   LDA #0
.fd52	a8		tay		   TAY               ; clear index
.fd53					InRA_10
.fd53	99 02 00	sta $0002,y	   STA $0002,Y       ; clear page 0
.fd56	99 00 02	sta $0200,y	   STA $0200,Y       ; clear page 2
.fd59	99 00 03	sta $0300,y	   STA $0300,Y       ; clear page 3
.fd5c	c8		iny		   INY
.fd5d	d0 f4		bne $fd53	   BNE InRA_10       ; loop if more to do
.fd5f	a2 3c		ldx #$3c	   LDX #<TBUFFR      ; set cassette buffer pointer low byte
.fd61	a0 03		ldy #$03	   LDY #>TBUFFR      ; set cassette buffer pointer high byte
.fd63	86 b2		stx $b2		   STX TAPE1         ; save tape buffer start pointer low byte
.fd65	84 b3		sty $b3		   STY TAPE1+1       ; save tape buffer start pointer high byte
.fd67	a8		tay		   TAY
.fd68	a9 03		lda #$03	   LDA #3
.fd6a	85 c2		sta $c2		   STA STAL+1
.fd6c					InRA_20
.fd6c	e6 c2		inc $c2		   INC STAL+1
.fd6e					InRA_30
.fd6e	b1 c1		lda ($c1),y	   LDA (STAL),Y
.fd70	aa		tax		   TAX
.fd71	a9 55		lda #$55	   LDA #$55 ; 'U'
.fd73	91 c1		sta ($c1),y	   STA (STAL),Y
.fd75	d1 c1		cmp ($c1),y	   CMP (STAL),Y
.fd77	d0 0f		bne $fd88	   BNE InRA_40
.fd79	2a		rol a		   ROL A
.fd7a	91 c1		sta ($c1),y	   STA (STAL),Y
.fd7c	d1 c1		cmp ($c1),y	   CMP (STAL),Y
.fd7e	d0 08		bne $fd88	   BNE InRA_40
.fd80	8a		txa		   TXA
.fd81	91 c1		sta ($c1),y	   STA (STAL),Y
.fd83	c8		iny		   INY
.fd84	d0 e8		bne $fd6e	   BNE InRA_30
.fd86	f0 e4		beq $fd6c	   BEQ InRA_20
.fd88					InRA_40
.fd88	98		tya		   TYA
.fd89	aa		tax		   TAX
.fd8a	a4 c2		ldy $c2		   LDY STAL+1
.fd8c	18		clc		   CLC
.fd8d	20 2d fe	jsr $fe2d	   JSR Set_memtop
.fd90	a9 08		lda #$08	   LDA #>BASIC_RAM_START
.fd92	8d 82 02	sta $0282	   STA OSSTAR+1
.fd95	a9 04		lda #$04	   LDA #>BASIC_SCREEN
.fd97	8d 88 02	sta $0288	   STA SCNMPG
.fd9a	60		rts		   RTS
.fd9b					TAPE_IRQ_Vectors
>fd9b	6a fc				   .word   TAPE_Write_Leader ; $08   write tape leader IRQ routine
>fd9d	cd fb				   .word   TAPE_Write_IRQ    ; $0A   tape write IRQ routine
>fd9f	31 ea				   .word   Default_IRQ       ; $0C   normal IRQ vector
>fda1	2c f9				   .word   TAPE_Read_IRQ     ; $0E   read tape bits IRQ routine
.fda3					  Initialise_IO
.fda3	a9 7f		lda #$7f	   LDA #$7f
.fda5	8d 0d dc	sta $dc0d	   STA CIA1_ICR    ; CIA1 Interrupt Control Register
.fda8	8d 0d dd	sta $dd0d	   STA CIA2_ICR
.fdab	8d 00 dc	sta $dc00	   STA KEYB_COL
.fdae	a9 08		lda #$08	   LDA #8
.fdb0	8d 0e dc	sta $dc0e	   STA CIA1_CRA
.fdb3	8d 0e dd	sta $dd0e	   STA CIA2_CRA
.fdb6	8d 0f dc	sta $dc0f	   STA CIA1_CRB    ; CIA1 Control Register B
.fdb9	8d 0f dd	sta $dd0f	   STA CIA2_CRB
.fdbc	a2 00		ldx #$00	   LDX #0
.fdbe	8e 03 dc	stx $dc03	   STX $DC03
.fdc1	8e 03 dd	stx $dd03	   STX $DD03
.fdc4	8e 18 d4	stx $d418	   STX $D418
.fdc7	ca		dex		   DEX
.fdc8	8e 02 dc	stx $dc02	   STX $DC02
.fdcb	a9 07		lda #$07	   LDA #7
.fdcd	8d 00 dd	sta $dd00	   STA $DD00
.fdd0	a9 3f		lda #$3f	   LDA #$3f ; '?'
.fdd2	8d 02 dd	sta $dd02	   STA $DD02
.fdd5	a9 e7		lda #$e7	   LDA #$e7
.fdd7	85 01		sta $01		   STA R6510
.fdd9	a9 2f		lda #$2f	   LDA #$2f ; '/'
.fddb	85 00		sta $00		   STA D6510
.fddd					  Program_Timer_A
.fddd	ad a6 02	lda $02a6	   LDA TVSFLG
.fde0	f0 0a		beq $fdec	   BEQ TASF_10
.fde2	a9 25		lda #$25	   LDA #<$4025       ; 16421
.fde4	8d 04 dc	sta $dc04	   STA CIA1_TALO
.fde7	a9 40		lda #$40	   LDA #>$4025
.fde9	4c f3 fd	jmp $fdf3	   JMP TASF_20
.fdec					TASF_10
.fdec	a9 95		lda #$95	   LDA #<$4295       ; 17045
.fdee	8d 04 dc	sta $dc04	   STA CIA1_TALO
.fdf1	a9 42		lda #$42	   LDA #>$4295
.fdf3					TASF_20
.fdf3	8d 05 dc	sta $dc05	   STA CIA1_TAHI
.fdf6	4c 6e ff	jmp $ff6e	   JMP PTA_10
.fdf9					  Kernal_SETNAM
.fdf9	85 b7		sta $b7		   STA FNLEN         ; set file name length
.fdfb	86 bb		stx $bb		   STX FNADR         ; set file name pointer low byte
.fdfd	84 bc		sty $bc		   STY FNADR+1       ; set file name pointer high byte
.fdff	60		rts		   RTS
.fe00					  Kernal_SETLFS
.fe00	85 b8		sta $b8		   STA LA            ; set logical file
.fe02	86 ba		stx $ba		   STX FA            ; set device number
.fe04	84 b9		sty $b9		   STY SA            ; set secondary address or command
.fe06	60		rts		   RTS
.fe07					  Kernal_READST
.fe07	a5 ba		lda $ba		   LDA FA            ; get device number
.fe09	c9 02		cmp #$02	   CMP #$02          ; compare device with RS232 device
.fe0b	d0 0d		bne $fe1a	   BNE Get_Status    ; branch if not RS232 device
.fe0d	ad 97 02	lda $0297	   LDA RSSTAT        ; read RS232 status word
.fe10	48		pha		   PHA
.fe11	a9 00		lda #$00	   LDA #0
.fe13	8d 97 02	sta $0297	   STA RSSTAT        ; clear RS232 status
.fe16	68		pla		   PLA
.fe17	60		rts		   RTS
.fe18					  Kernal_SETMSG
.fe18	85 9d		sta $9d		   STA MSGFLG        ; set message mode flag
.fe1a					Get_Status
.fe1a	a5 90		lda $90		   LDA STATUS        ; read serial status byte
.fe1c					  Ora_Status
.fe1c	05 90		ora $90		   ORA STATUS        ; OR with serial status byte
.fe1e	85 90		sta $90		   STA STATUS        ; save serial status byte
.fe20	60		rts		   RTS
.fe21					  Kernal_SETTMO
.fe21	8d 85 02	sta $0285	   STA STIMOT        ; save serial bus timeout flag
.fe24	60		rts		   RTS
.fe25					  Kernal_MEMTOP
.fe25	90 06		bcc $fe2d	   BCC Set_memtop      ; if Cb clear go set the top of memory
.fe27					  Read_Memtop
.fe27	ae 83 02	ldx $0283	   LDX OSTOP         ; get memory top low byte
.fe2a	ac 84 02	ldy $0284	   LDY OSTOP+1       ; get memory top high byte
.fe2d					  Set_memtop
.fe2d	8e 83 02	stx $0283	   STX OSTOP         ; set memory top low byte
.fe30	8c 84 02	sty $0284	   STY OSTOP+1       ; set memory top high byte
.fe33	60		rts		   RTS
.fe34					  Kernal_MEMBOT
.fe34	90 06		bcc $fe3c	   BCC MEM_10        ; if Cb clear go set the bottom of memory
.fe36	ae 81 02	ldx $0281	   LDX OSSTAR        ; read OS start of memory low byte
.fe39	ac 82 02	ldy $0282	   LDY OSSTAR+1      ; read OS start of memory high byte
.fe3c					MEM_10
.fe3c	8e 81 02	stx $0281	   STX OSSTAR
.fe3f	8c 82 02	sty $0282	   STY OSSTAR+1
.fe42	60		rts		   RTS
.fe43					  Entry_NMI
.fe43	78		sei		   SEI               ; disable interrupts
.fe44	6c 18 03	jmp ($0318)	   JMP (NMINV)       ; next statement by default
.fe47					  Default_NMI
.fe47	48		pha		   PHA               ; save A
.fe48	8a		txa		   TXA               ; copy X
.fe49	48		pha		   PHA               ; save X
.fe4a	98		tya		   TYA               ; copy Y
.fe4b	48		pha		   PHA               ; save Y
.fe4c	a9 7f		lda #$7f	   LDA #$7F
.fe4e	8d 0d dd	sta $dd0d	   STA CIA2_ICR
.fe51	ac 0d dd	ldy $dd0d	   LDY CIA2_ICR
.fe54	30 1c		bmi $fe72	   BMI RS232_NMI
.fe56	20 02 fd	jsr $fd02	   JSR Scan_Autostart_Signature
.fe59	d0 03		bne $fe5e	   BNE NMI_10        ; branch if no autostart ROM
.fe5b	6c 02 80	jmp ($8002)	   JMP (OPTION_ROM+2); else do autostart ROM break entry
.fe5e					NMI_10
.fe5e	20 bc f6	jsr $f6bc	   JSR Look_For_Special_Keys
.fe61	20 e1 ff	jsr $ffe1	   JSR STOP          ; Check if stop key is pressed
.fe64	d0 0c		bne $fe72	   BNE RS232_NMI
.fe66					  Default_BRK
.fe66	20 15 fd	jsr $fd15	   JSR Kernal_RESTOR
.fe69	20 a3 fd	jsr $fda3	   JSR Initialise_IO
.fe6c	20 18 e5	jsr $e518	   JSR Initialise_Hardware
.fe6f	6c 02 a0	jmp ($a002)	   JMP (BASIC_BRK)
.fe72					  RS232_NMI
.fe72					Bfe72
.fe72	98		tya		   TYA
.fe73	2d a1 02	and $02a1	   AND ENABL
.fe76	aa		tax		   TAX
.fe77	29 01		and #$01	   AND #1
.fe79	f0 28		beq $fea3	   BEQ NMI_20
.fe7b	ad 00 dd	lda $dd00	   LDA $DD00
.fe7e	29 fb		and #$fb	   AND #$fb
.fe80	05 b5		ora $b5		   ORA NXTBIT
.fe82	8d 00 dd	sta $dd00	   STA $DD00
.fe85	ad a1 02	lda $02a1	   LDA ENABL
.fe88	8d 0d dd	sta $dd0d	   STA CIA2_ICR
.fe8b	8a		txa		   TXA
.fe8c	29 12		and #$12	   AND #$12
.fe8e	f0 0d		beq $fe9d	   BEQ Mfe9d
.fe90	29 02		and #$02	   AND #2
.fe92	f0 06		beq $fe9a	   BEQ Bfe9a
.fe94	20 d6 fe	jsr $fed6	   JSR RS232_In
.fe97	4c 9d fe	jmp $fe9d	   JMP Mfe9d
.fe9a					Bfe9a
.fe9a	20 07 ff	jsr $ff07	   JSR RS232_Out
.fe9d					Mfe9d
.fe9d	20 bb ee	jsr $eebb	   JSR RS232_NMI_Transmit
.fea0					JMP_Exit_IRQ
.fea0	4c b6 fe	jmp $feb6	   JMP Bfeb6
.fea3					NMI_20
.fea3	8a		txa		   TXA               ; get active interrupts back
.fea4	29 02		and #$02	   AND #2
.fea6	f0 06		beq $feae	   BEQ NMI_30        ; branch if not T2 interrupt
.fea8	20 d6 fe	jsr $fed6	   JSR RS232_In
.feab	4c b6 fe	jmp $feb6	   JMP Bfeb6
.feae					NMI_30
.feae	8a		txa		   TXA               ; get active interrupts back
.feaf	29 10		and #$10	   AND #$10          ; mask CB1 interrupt, Rx data bit transition
.feb1	f0 03		beq $feb6	   BEQ Bfeb6         ; if no bit restore registers and exit interrupt
.feb3	20 07 ff	jsr $ff07	   JSR RS232_Out
.feb6					Bfeb6
.feb6	ad a1 02	lda $02a1	   LDA ENABL
.feb9	8d 0d dd	sta $dd0d	   STA CIA2_ICR
.febc					  Exit_IRQ
.febc	68		pla		   PLA               ; pull Y
.febd	a8		tay		   TAY               ; restore Y
.febe	68		pla		   PLA               ; pull X
.febf	aa		tax		   TAX               ; restore X
.fec0	68		pla		   PLA               ; restore A
.fec1	40		rti		   RTI
.fec2					  Baudrate
>fec2	c1 27				   .word   $27c1     ;   50   baud
>fec4	3e 1a				   .word   $1a3e     ;   75   baud
>fec6	c5 11				   .word   $11c5     ;  110   baud
>fec8	74 0e				   .word   $0e74     ;  134.5 baud
>feca	ed 0c				   .word   $0ced     ;  150   baud
>fecc	45 06				   .word   $0645     ;  300   baud
>fece	f0 02				   .word   $02f0     ;  600   baud
>fed0	46 01				   .word   $0146     ; 1200   baud
>fed2	b8 00				   .word   $00b8     ; 1800   baud
>fed4	71 00				   .word   $0071     ; 2400   baud
.fed6					  RS232_In
.fed6	ad 01 dd	lda $dd01	   LDA CIA2_PRB
.fed9	29 01		and #$01	   AND #1
.fedb	85 a7		sta $a7		   STA INBIT
.fedd	ad 06 dd	lda $dd06	   LDA CIA2_TBLO
.fee0	e9 1c		sbc #$1c	   SBC #$1c
.fee2	6d 99 02	adc $0299	   ADC BAUDOF
.fee5	8d 06 dd	sta $dd06	   STA CIA2_TBLO
.fee8	ad 07 dd	lda $dd07	   LDA CIA2_TBHI
.feeb	6d 9a 02	adc $029a	   ADC BAUDOF+1
.feee	8d 07 dd	sta $dd07	   STA CIA2_TBHI
.fef1	a9 11		lda #$11	   LDA #$11
.fef3	8d 0f dd	sta $dd0f	   STA CIA2_CRB
.fef6	ad a1 02	lda $02a1	   LDA ENABL
.fef9	8d 0d dd	sta $dd0d	   STA CIA2_ICR
.fefc	a9 ff		lda #$ff	   LDA #$ff
.fefe	8d 06 dd	sta $dd06	   STA CIA2_TBLO
.ff01	8d 07 dd	sta $dd07	   STA CIA2_TBHI
.ff04	4c 59 ef	jmp $ef59	   JMP RS232_NMI_Receive
.ff07					  RS232_Out
.ff07	ad 95 02	lda $0295	   LDA M51AJB
.ff0a	8d 06 dd	sta $dd06	   STA CIA2_TBLO
.ff0d	ad 96 02	lda $0296	   LDA M51AJB+1
.ff10	8d 07 dd	sta $dd07	   STA CIA2_TBHI
.ff13	a9 11		lda #$11	   LDA #$11
.ff15	8d 0f dd	sta $dd0f	   STA CIA2_CRB
.ff18	a9 12		lda #$12	   LDA #$12
.ff1a	4d a1 02	eor $02a1	   EOR ENABL
.ff1d	8d a1 02	sta $02a1	   STA ENABL
.ff20	a9 ff		lda #$ff	   LDA #$ff
.ff22	8d 06 dd	sta $dd06	   STA CIA2_TBLO
.ff25	8d 07 dd	sta $dd07	   STA CIA2_TBHI
.ff28	ae 98 02	ldx $0298	   LDX BITNUM
.ff2b	86 a8		stx $a8		   STX BITCI
.ff2d	60		rts		   RTS
.ff2e					  Set_Baud_Rate
.ff2e	aa		tax		   TAX
.ff2f	ad 96 02	lda $0296	   LDA M51AJB+1
.ff32	2a		rol a		   ROL A
.ff33	a8		tay		   TAY
.ff34	8a		txa		   TXA
.ff35	69 c8		adc #$c8	   ADC #$c8
.ff37	8d 99 02	sta $0299	   STA BAUDOF
.ff3a	98		tya		   TYA
.ff3b	69 00		adc #$00	   ADC #0
.ff3d	8d 9a 02	sta $029a	   STA BAUDOF+1
.ff40	60		rts		   RTS
>ff41	ea ea				   .BYTE $ea,$ea     ; 2 NOP's
.ff43					  Clear_BREAK_Flag
.ff43	08		php		   PHP
.ff44	68		pla		   PLA
.ff45	29 ef		and #$ef	   AND #$ef
.ff47	48		pha		   PHA
.ff48					  Entry_IRQ
.ff48	48		pha		   PHA               ; save A
.ff49	8a		txa		   TXA               ; copy X
.ff4a	48		pha		   PHA               ; save X
.ff4b	98		tya		   TYA               ; copy Y
.ff4c	48		pha		   PHA               ; save Y
.ff4d	ba		tsx		   TSX               ; copy stack pointer
.ff4e	bd 04 01	lda $0104,x	   LDA STACK+4,X     ; get the stacked status register
.ff51	29 10		and #$10	   AND #$10          ; mask the BRK flag bit
.ff53	f0 03		beq $ff58	   BEQ BFF82         ; if not BRK go do the hardware IRQ vector
.ff55	6c 16 03	jmp ($0316)	   JMP (CBINV)       ; else do the BRK vector
.ff58					BFF82
.ff58	6c 14 03	jmp ($0314)	   JMP (CINV)        ; do IRQ vector
.ff5b					  Init_Editor
.ff5b	20 18 e5	jsr $e518	   JSR Initialise_Hardware
.ff5e					InEd_10
.ff5e	ad 12 d0	lda $d012	   LDA $D012
.ff61	d0 fb		bne $ff5e	   BNE InEd_10
.ff63	ad 19 d0	lda $d019	   LDA $D019
.ff66	29 01		and #$01	   AND #1
.ff68	8d a6 02	sta $02a6	   STA TVSFLG
.ff6b	4c dd fd	jmp $fddd	   JMP Program_Timer_A
.ff6e					  PTA_10
.ff6e	a9 81		lda #$81	   LDA #$81          ; Enable timer A interrupt
.ff70	8d 0d dc	sta $dc0d	   STA CIA1_ICR      ; Interrupt Control Register
.ff73	ad 0e dc	lda $dc0e	   LDA CIA1_CRA      ; Read Conrol Register A
.ff76	29 80		and #$80	   AND #$80          ; Clear all values except frequency (50/60 Hz)
.ff78	09 11		ora #$11	   ORA #$11          ; Start time A in single shot mode
.ff7a	8d 0e dc	sta $dc0e	   STA CIA1_CRA      ; run timer A
.ff7d	4c 8e ee	jmp $ee8e	   JMP SET_IEC_CLK
.ff80					  Kernal_Version
>ff80	03				   .BYTE $03
.ff81	4c 5b ff	jmp $ff5b	    JMP Init_Editor
.ff84	4c a3 fd	jmp $fda3	    JMP Initialise_IO
.ff87	4c 50 fd	jmp $fd50	    JMP Init_RAM
.ff8a					  RESTOR
.ff8a	4c 15 fd	jmp $fd15	   JMP Kernal_RESTOR
.ff8d					  VECTOR
.ff8d	4c 1a fd	jmp $fd1a	   JMP Kernal_VECTOR
.ff90					  SETMSG
.ff90	4c 18 fe	jmp $fe18	   JMP Kernal_SETMSG
.ff93					  SECOND
.ff93	4c b9 ed	jmp $edb9	   JMP Kernal_SECOND
.ff96					  TKSA
.ff96	4c c7 ed	jmp $edc7	   JMP Kernal_TKSA
.ff99					  MEMTOP
.ff99	4c 25 fe	jmp $fe25	   JMP Kernal_MEMTOP
.ff9c					  MEMBOT
.ff9c	4c 34 fe	jmp $fe34	   JMP Kernal_MEMBOT
.ff9f					  SCNKEY
.ff9f	4c 87 ea	jmp $ea87	   JMP Kernal_SCNKEY
.ffa2					  SETTMO
.ffa2	4c 21 fe	jmp $fe21	   JMP Kernal_SETTMO
.ffa5					  ACPTR
.ffa5	4c 13 ee	jmp $ee13	   JMP Kernal_ACPTR
.ffa8					  CIOUT
.ffa8	4c dd ed	jmp $eddd	   JMP Kernal_CIOUT
.ffab					  UNTLK
.ffab	4c ef ed	jmp $edef	   JMP Kernal_UNTLK
.ffae					  UNLSN
.ffae	4c fe ed	jmp $edfe	   JMP Kernal_UNLSN
.ffb1					  LISTEN
.ffb1	4c 0c ed	jmp $ed0c	   JMP Kernal_LISTEN
.ffb4					  TALK
.ffb4	4c 09 ed	jmp $ed09	   JMP Kernal_TALK
.ffb7					  READST
.ffb7	4c 07 fe	jmp $fe07	   JMP Kernal_READST
.ffba					  SETLFS
.ffba	4c 00 fe	jmp $fe00	   JMP Kernal_SETLFS
.ffbd					  SETNAM
.ffbd	4c f9 fd	jmp $fdf9	   JMP Kernal_SETNAM
.ffc0					  OPEN
.ffc0	6c 1a 03	jmp ($031a)	   JMP (IOPEN)
.ffc3					  CLOSE
.ffc3	6c 1c 03	jmp ($031c)	   JMP (ICLOSE)
.ffc6					  CHKIN
.ffc6	6c 1e 03	jmp ($031e)	   JMP (ICHKIN)
.ffc9					  CHKOUT
.ffc9	6c 20 03	jmp ($0320)	   JMP (ICKOUT)      ; do open for output vector
.ffcc					  CLRCHN
.ffcc	6c 22 03	jmp ($0322)	   JMP (ICLRCH)
.ffcf					  CHRIN
.ffcf	6c 24 03	jmp ($0324)	   JMP (IBASIN)
.ffd2					  CHROUT
.ffd2	6c 26 03	jmp ($0326)	   JMP (IBSOUT)
.ffd5					  LOAD
.ffd5	4c 9e f4	jmp $f49e	   JMP Kernal_LOAD
.ffd8					  SAVE
.ffd8	4c dd f5	jmp $f5dd	   JMP Kernal_SAVE
.ffdb					  SETTIM
.ffdb	4c e4 f6	jmp $f6e4	   JMP Kernal_SETTIM
.ffde					  RDTIM
.ffde	4c dd f6	jmp $f6dd	   JMP Kernal_RDTIM
.ffe1					  STOP
.ffe1	6c 28 03	jmp ($0328)	   JMP (ISTOP)
.ffe4					  GETIN
.ffe4	6c 2a 03	jmp ($032a)	   JMP (IGETIN)
.ffe7					  CLALL
.ffe7	6c 2c 03	jmp ($032c)	   JMP (ICLALL)
.ffea					  UDTIM
.ffea	4c 9b f6	jmp $f69b	   JMP Kernal_UDTIM
.ffed					  SCREEN
.ffed	4c 05 e5	jmp $e505	   JMP Kernal_SCREEN
.fff0					  PLOT
.fff0	4c 0a e5	jmp $e50a	   JMP Kernal_PLOT
.fff3					  IOBASE
.fff3	4c 00 e5	jmp $e500	   JMP Kernal_IOBASE
>fff6	52 52 42 59			   .text "RRBY"
>fffa	43 fe				   .word   Entry_NMI ; Non Maskable Interrupt vector
>fffc	e2 fc				   .word   Entry_RESET; Reset vector
>fffe	48 ff				   .word   Entry_IRQ ; Interrupt Request vector

;******  End of listing
