              ; *******************************************
              ; The Commodore VIC-20 / C64 operating system
              ; *******************************************

0001          C64 = 1        ; set to 1 for assembling the C64 ROM images
              ;VIC = 1 - C64  ;     or 0 for assembling the VIC ROM images

0000          JIFFY = 0      ; set to 1 for JIFFY DOS
0001          PAL   = 1      ; set to 0 for NTSC

              ; Based on following sources 
              ; ------------------------------------------------------------
              ; Disassembly done with the "Black Smurf Disassembler"
              ; The complete Commodore inner space anthology - Karl Hildon
              ; Vic 20 Programmers reference - Commodore
              ; Many comments merged in from Lee Davison's disassembly
              ; Der MOS 6567/6569 Videocontroller (VIC-II) - Christian Bauer

              ; Recommended assembler
              ; --------------------------------------------------------------
              ; Use the opensource cross assembler BSA (Black Smurf Assembler)
              ; for creating ROM images and assembly listings.
              ; BSA runs on MAC OSX, Linux, Unix and Windows

            MACRO PUSHW(Word)
               LDA Word+1
               PHA
               LDA Word
               PHA
            ENDMAC

            MACRO PULLW(Word)
               PLA
               STA Word
               PLA
               STA Word+1
            ENDMAC

            MACRO LDAX(Word)
               LDA Word
               LDX Word+1
            ENDMAC

            MACRO STAX(Ptr)
               STA Ptr
               STX Ptr+1
            ENDMAC

            MACRO LAYI(Word)
               LDA #<Word
               LDY #>Word
            ENDMAC

            MACRO LDAY(Word)
               LDA Word
               LDY Word+1
            ENDMAC

            MACRO STAY(Ptr)
               STA Ptr
               STY Ptr+1
            ENDMAC

            MACRO LDXY(Word)
               LDX Word
               LDY Word+1
            ENDMAC

            MACRO STXY(Ptr)
               STX Ptr
               STY Ptr+1
            ENDMAC

            MACRO Print_Msg(Msg)
               LDA #<Msg
               LDY #>Msg
               JSR Print_String
            ENDMAC

0001 FALSE    #if VIC
SKIP          
SKIP          VIC_BASE = $9000
SKIP          VIC_REGS = $10
SKIP          
SKIP          ; **************************************
SKIP          ; VIC-20 Video Interface Chip (MOS 6560)
SKIP          ; **************************************
SKIP          
SKIP          ;  #| Adr. |Bit7|Bit6|Bit5|Bit4|Bit3|Bit2|Bit1|Bit0| Function
SKIP          ; --+------+----+----+----+----+----+----+----+----+--------------------
SKIP          ;  0| 9000 |INTL|             HSA                  | horiz. adjustment
SKIP          ; --+------+---------------------------------------+--------------------
SKIP          ;  1| 9001 |                  VSA                  | vertical adjustment  
SKIP          ; --+------+---------------------------------------+--------------------
SKIP          ;  2| 9002 | SA9|             COLS                 | screen columns
SKIP          ; --+------+---------------------------------------+--------------------
SKIP          ;  3| 9003 | RA8|             ROWS                 | screen rows
SKIP          ; --+------+---------------------------------------+--------------------
SKIP          ;  4| 9004 |                  RAST                 | raster value
SKIP          ; --+------+---------------------------------------+--------------------
SKIP          ;  5| 9005 |  1 |    SMA       |      CMA          | screen/char memory
SKIP          ; --+------+---------------------------------------+--------------------
SKIP          ;  6| 9006 |                  LPH                  | light pen horiz.
SKIP          ; --+------+---------------------------------------+--------------------
SKIP          ;  7| 9007 |                  LPV                  | light pen vertical
SKIP          ; --+------+---------------------------------------+--------------------
SKIP          ;  8| 9008 |                  PAD1                 | paddle 1
SKIP          ; --+------+---------------------------------------+--------------------
SKIP          ;  9| 9009 |                  PAD2                 | paddle 2
SKIP          ; --+------+---------------------------------------+--------------------
SKIP          ; 10| 900a | BSW|             BASS                 | bass sound
SKIP          ; --+------+---------------------------------------+--------------------
SKIP          ; 11| 900b | ASW|             ALTO                 | alto sound
SKIP          ; --+------+---------------------------------------+--------------------
SKIP          ; 12| 900c | SSW|             SOPR                 | soprano sound
SKIP          ; --+------+---------------------------------------+--------------------
SKIP          ; 13| 900d | NSW|             NOIS                 | noise sound
SKIP          ; --+------+---------------------------------------+--------------------
SKIP          ; 14| 900e |      AUXC         |      VOL          | aux. color / volume
SKIP          ; --+------+---------------------------------------+--------------------
SKIP          ; 15| 900f |      SCOL         | REV|     BCOL     | screen/border color
SKIP          ; --+------+----+----+----+----+----+----+----+----+--------------------
SKIP          
SKIP          VIC_R0 = $9000       ; interlace / screen origin - horizontal
SKIP                               ; bit 7   : 1 = interlace on
SKIP                               ; bit 6-0 : horizontal screen adjustment (5)
SKIP          
SKIP          VIC_R1 = $9001       ; bit 7-0 : vertical screen adjustment (25)
SKIP          
SKIP          VIC_R2 = $9002       ; screen address and number of colums
SKIP                               ; bit 7   : screen memory address 9
SKIP                               ; bit 6-0 : number of columns (22)
SKIP          
SKIP          VIC_R3 = $9003       ; raster / # of rows / character size
SKIP                               ; bit 7   : bit 8 of raster value
SKIP                               ; bit 6-1 : number of rows (23)
SKIP                               ; bit 0   : 1 = 8 x 16 character size
SKIP          
SKIP          VIC_R4 = $9004       ; raster value
SKIP                               ; bit 7-0 : raster value (bit 8 in R3)
SKIP          
SKIP          VIC_R5 = $9005       ; screen memory / character memory
SKIP                               ; bit 7   : must be 1
SKIP                               ; bit 6-4 : screen memory address 12-10
SKIP                               ; bit 3-0 : character memory
SKIP                               ; --------------------------
SKIP                               ; 0000 ROM  $8000 upper case normal
SKIP                               ; 0001 ROM  $8400 upper case reversed
SKIP                               ; 0010 ROM  $8800 lower case normal
SKIP                               ; 0011 ROM  $8C00 lower case reversed
SKIP                               ; 1100 RAM  $1000 user defined
SKIP                               ; 1101 RAM  $1400 user defined
SKIP                               ; 1110 RAM  $1800 user defined
SKIP                               ; 1111 RAM  $1C00 user defined
SKIP          
SKIP          VIC_R6 = $9006       ; light pen horizontal
SKIP          
SKIP          VIC_R7 = $9007       ; light pen vertical
SKIP          
SKIP          VIC_R8 = $9008       ; paddle 1
SKIP          
SKIP          VIC_R9 = $9009       ; paddle 2
SKIP          
SKIP          VIC_RA = $900A       ; bit 7   : bass sound switch (1 = enable)
SKIP                               ; bit 6-0 : bass frequency (clock / (127 - X))
SKIP          
SKIP          VIC_RB = $900B       ; bit 7   : alto sound switch (1 = enable)
SKIP                               ; bit 6-0 : alto frequency
SKIP          
SKIP          VIC_RC = $900C       ; bit 7   : soprano sound switch (1 = enable)
SKIP                               ; bit 6-0 : soprano frequency
SKIP          
SKIP          VIC_RD = $900D       ; bit 7   : noise sound switch (1 = enable)
SKIP                               ; bit 6-0 : noise frequency
SKIP          
SKIP          VIC_RE = $900E       ; auxiliary color / loudness
SKIP                               ; bit 7-4 : auxiliary color
SKIP                               ; bit 3-0 : loudness (volume)
SKIP          
SKIP          VIC_RF = $900F       ; screen color / reverse mode / border color
SKIP                               ; bit 7-4 : screen color
SKIP                               ; bit 3   : reverse mode (1 = on)
SKIP                               ; bit 2-0 : border color
SKIP          
SKIP          ; ***********************
SKIP          ; VIC-20 VIA 1 (MOS 6522)
SKIP          ; ***********************
SKIP          
SKIP          VIA1_DATB = $9110    ; VIA 1 data register B (I/O)
SKIP                               ; ---------------------------  
SKIP                               ; bit 7   DSR  in
SKIP                               ; bit 6   CTS  in
SKIP                               ; bit 5   
SKIP                               ; bit 4   DCD  in
SKIP                               ; bit 3   RI   in
SKIP                               ; bit 2   DTR  out
SKIP                               ; bit 1   RTS  out
SKIP                               ; bit 0   data in
SKIP          
SKIP          VIA1_DATA = $9111    ; VIA 1 data register A (I/O)
SKIP                               ; ---------------------------  
SKIP                               ; bit 7   IEC ATN out
SKIP                               ; bit 6   cassette switch
SKIP                               ; bit 5   light pen
SKIP                               ; bit 4   joy 2
SKIP                               ; bit 3   joy 1
SKIP                               ; bit 2   joy 0
SKIP                               ; bit 1   IEC DATA in
SKIP                               ; bit 0   IEC CLK  in
SKIP          
SKIP          VIA1_DDRB = $9112    ; VIA 1 data direction register B
SKIP          VIA1_DDRA = $9113    ; VIA 1 data direction register A
SKIP          VIA1_T1CL = $9114    ; VIA 1 timer 1 low  order counter/latch
SKIP          VIA1_T1CH = $9115    ; VIA 1 timer 1 high order counter/latch
SKIP          VIA1_T1LL = $9116    ; VIA 1 timer 1 low  order latch
SKIP          VIA1_T1LH = $9117    ; VIA 1 timer 1 high order latch
SKIP          VIA1_T2CL = $9118    ; VIA 1 timer 2 low  order counter/latch
SKIP          VIA1_T2CH = $9119    ; VIA 1 timer 2 high order counter/latch
SKIP          VIA1_SR   = $911A    ; VIA 1 shift register
SKIP          
SKIP          VIA1_ACR  = $911B    ; VIA 1 auxiliary control register
SKIP                               ; --------------------------------
SKIP                               ; bit 7   : T1 PB7 enabled/disabled
SKIP                               ; bit 6   : T1 free run/one shot
SKIP                               ; bit 5   : T2 clock PB6/Ø2
SKIP                               ; bit 432 : function
SKIP                               ; ------------------
SKIP                               ; 000   shift register disabled
SKIP                               ; 001   shift in , rate controlled by T2
SKIP                               ; 010   shift in , rate controlled by Ø2
SKIP                               ; 011   shift in , rate controlled by external clock
SKIP                               ; 100   shift out, rate controlled by T2, free run
SKIP                               ; 101   shift out, rate controlled by T2
SKIP                               ; 110   shift out, rate controlled by Ø2
SKIP                               ; 111   shift out, rate controlled by external clock
SKIP                               ; bit 1   : PB latch (1 = enabled)
SKIP                               ; bit 0   : PA latch (1 = enabled)
SKIP          
SKIP          VIA1_PCR   = $911C   ; VIA 1 peripheral control register (PCR)
SKIP                               ; bit   function
SKIP                               ; ---   --------
SKIP                               ; 765   CB2 control
SKIP                               ; ---   -----------
SKIP                               ; 000   Interrupt Input Mode
SKIP                               ; 001   Independent Interrupt Input Mode
SKIP                               ; 010   Input Mode
SKIP                               ; 011   Independent Input Mode
SKIP                               ; 100   Handshake Output Mode
SKIP                               ; 101   Pulse Output Mode
SKIP                               ; 110   Manual Output Mode, CB2 low
SKIP                               ; 111   Manual Output Mode, CB2 high
SKIP                               ;  4   CB1 edge positive/negative
SKIP                               ; 321   CA2 control
SKIP                               ; ---   -----------
SKIP                               ; 000   Interrupt Input Mode
SKIP                               ; 001   Independent Interrupt Input Mode
SKIP                               ; 010   Input Mode 
SKIP                               ; 011   Independent Input Mode
SKIP                               ; 100   Handshake Output Mode
SKIP                               ; 101   Pulse Output Mode
SKIP                               ; 110   Manual Output Mode, CA2 low
SKIP                               ; 111   Manual Output Mode, CA2 high
SKIP                               ;  0   CA1 edge positive/negative
SKIP          
SKIP          ; The status bit is a not normal flag. It goes high if both an interrupt
SKIP          ; flag in the IFR and the corresponding enable bit in the IER are set.
SKIP          ; It can be cleared only by clearing all the active flags in the IFR or
SKIP          ; disabling all active interrupts in the IER.
SKIP          
SKIP          VIA1_IFR   = $911D   ; VIA 1 interrupt flag register) (IFR)
SKIP                               ; bit   function      cleared by
SKIP                               ; ---   --------      ----------
SKIP                               ;  7   interrupt status   clearing all enabled interrupts
SKIP                               ;  6   T1 interrupt   read T1C_l, write T1C_h
SKIP                               ;  5   T2 interrupt   read T2C_l, write T2C_h
SKIP                               ;  4   CB1 transition   read or write port B
SKIP                               ;  3   CB2 transition   read or write port B
SKIP                               ;  2   8 shifts done   read or write the shift register
SKIP                               ;  1   CA1 transition   read or write port A
SKIP                               ;  0   CA2 transition   read or write port A
SKIP          
SKIP          ; If enable/disable bit is a zero during a write to this register, each
SKIP          ; 1 in bits 0-6 clears the corresponding bit in the IER. if this bit is
SKIP          ; a one during a write to this register, each 1 in bits 0-6 will set the
SKIP          ; corresponding IER bit
SKIP          
SKIP          VIA1_IER   = $911E   ; VIA 1 interrupt enable register (IER)
SKIP                               ; bit   function
SKIP                               ; ---   --------
SKIP                               ;  7   enable/disable
SKIP                               ;  6   T1 interrupt
SKIP                               ;  5   T2 interrupt
SKIP                               ;  4   CB1 transition
SKIP                               ;  3   CB2 transition
SKIP                               ;  2   8 shifts done
SKIP                               ;  1   CA1 transition
SKIP                               ;  0   CA2 transition
SKIP          
SKIP          VIA1_DATN    = $911F ; VIA 1 DRA, no handshake
SKIP                               ; bit   function
SKIP                               ; ---   --------
SKIP                               ;  7   ATN out
SKIP                               ;  6   cassette switch
SKIP                               ;  5   joystick fire, light pen
SKIP                               ;  4   joystick left
SKIP                               ;  3   joystick down
SKIP                               ;  2   joystick up
SKIP                               ;  1   serial dat in
SKIP                               ;  0   serial clk in
SKIP          
SKIP          ; **********************
SKIP          ; VIC-20 VIA2 (MOS 6522)
SKIP          ; **********************
SKIP          
SKIP          VIA2_DATB  = $9120   ; VIA 2 DRB, keyboard column drive
SKIP          VIA2_DATA  = $9121   ; VIA 2 DRA, keyboard row port
SKIP                               ; Vic 20 keyboard matrix layout
SKIP                               ;       c7   c6   c5   c4   c3   c2   c1   c0
SKIP                               ;   +------------------------------------------------
SKIP                               ; r7|   F7   F5   F3   F1   DN  RGT  RET  DEL
SKIP                               ; r6|    /   UP    =  RSH HOME    ;    *    £
SKIP                               ; r5|    ,    @    :    .    -    L    P    +
SKIP                               ; r4|    0    O    K    M    N    J    I    9
SKIP                               ; r3|    8    U    H    B    V    G    Y    7
SKIP                               ; r2|    6    T    F    C    X    D    R    5
SKIP                               ; r1|    4    E    S    Z  LSH    A    W    3
SKIP                               ; r0|    2    Q  CBM   SP  RUN  CTL  LFT    1
SKIP          
SKIP          VIA2_DDRB  = $9122   ; VIA 2 data direction register B
SKIP          VIA2_DDRA  = $9123   ; VIA 2 data direction register A
SKIP          VIA2_T1CL  = $9124   ; VIA 2 T1 low  order counter/latch
SKIP          VIA2_T1CH  = $9125   ; VIA 2 T1 high order counter/latch
SKIP          VIA2_T1LL  = $9126   ; VIA 2 T1 low  order latch
SKIP          VIA2_T1LH  = $9127   ; VIA 2 T1 high order latch
SKIP          VIA2_T2CL  = $9128   ; VIA 2 T2 low  order counter/latch
SKIP          VIA2_T2CH  = $9129   ; VIA 2 T2 high order counter/latch
SKIP          VIA2_SR    = $912A   ; VIA 2 shift register              (SR)
SKIP          VIA2_ACR   = $912B   ; VIA 2 auxiliary control register  (ACR)
SKIP          VIA2_PCR   = $912C   ; VIA 2 peripheral control register (PCR)
SKIP          
SKIP          ; the status bit is a not normal flag. it goes high if both an interrupt
SKIP          ; flag in the IFR and the corresponding enable bit in the IER are set.
SKIP          ; it can be cleared only by clearing all the active flags in the IFR or
SKIP          ; disabling all active interrupts in the IER.
SKIP          
SKIP          VIA2_IFR   = $912D   ; VIA 1 Interrupt Flag Register (IFR)
SKIP                               ; bit   function        cleared by
SKIP                               ; ---  ---------        ----------
SKIP                               ;  7   interrupt status clearing all enabled interrupts
SKIP                               ;  6   T1 interrupt     read T1C_l, write T1C_h
SKIP                               ;  5   T2 interrupt     read T2C_l, write T2C_h
SKIP                               ;  4   CB1 transition   read or write port B
SKIP                               ;  3   CB2 transition   read or write port B
SKIP                               ;  2   8 shifts done    read or write the shift register
SKIP                               ;  1   CA1 transition   read or write port A
SKIP                               ;  0   CA2 transition   read or write port A
SKIP          
SKIP          ; If enable/disable bit is a zero during a write to this register, each
SKIP          ; 1 in bits 0-6 clears the corresponding bit in the IER. if this bit is
SKIP          ; a one during a write to this register, each 1 in bits 0-6 will set the
SKIP          ; corresponding IER bit
SKIP          
SKIP          VIA2_IER   = $912E   ; VIA 1 Interrupt Enable Register (IER)
SKIP                               ; bit   function
SKIP                               ; ---   --------
SKIP                               ;  7   enable/disable
SKIP                               ;  6   T1 interrupt
SKIP                               ;  5   T2 interrupt
SKIP                               ;  4   CB1 transition
SKIP                               ;  3   CB2 transition
SKIP                               ;  2   8 shifts done
SKIP                               ;  1   CA1 transition
SKIP                               ;  0   CA2 transition
SKIP          
SKIP          VIA2_DATN  = $912F   ; VIA 2 DRA, keyboard row, no handshake
SKIP          
SKIP          ; register names for keyboard driver
SKIP          
SKIP          KEYB_COL   = VIA2_DATB
SKIP          KEYB_ROW   = VIA2_DATA
SKIP          KEYB_ROWN  = VIA2_DATN
SKIP          
SKIP          ; key coordinates
SKIP          
SKIP          CTRL_COL = %11111011 ; $fb = col 2
SKIP          CTRL_ROW = %11111110 ; $fe = row 0
SKIP          
SKIP          STND_COL = %11110111 ; $7f = col 3
SKIP          
SKIP          ; constants for screen editor
SKIP          
SKIP          COLS          =  22 ; screen columns 
SKIP          ROWS          =  23 ; screen rows
SKIP          COLINK        =   4 ; possible physical lines per logical line
SKIP          COLMAX        =  88 ; maximum line length of a logical line
SKIP          COLRAM_PAGE   = $94 ; default page of color RAM
SKIP          Default_Color =   6 ; blue
SKIP          
SKIP          IEC_PCR       = $912C; VIA 2 peripheral control register (PCR)
SKIP          IEC_DRAN      = $911F
SKIP          IEC_TIM_H     = $9129; VIA 2 T2H, timer high
SKIP          IEC_IFR       = $912D; VIA 2 IFR, interrupt flag register
SKIP          IEC_ATN_BIT   = $80
SKIP          IEC_IFR_BIT   = $20
SKIP          IEC_CLK_BIT   = %00000010; $02
SKIP          IEC_DAT_BIT   = %00100000; $20
SKIP          RS232_C_BIT   = %00100000; $20
SKIP          RS2_IRQ_REG   = $911E
SKIP          RS2_DSR_CTS   = $9110
SKIP          RS2_TIM_LOW   = $9114
SKIP          RS2_TIM_HIG   = $9115
SKIP          MEM_CONTROL   = $9005
SKIP          
SKIP          OPTION_ROM    = $A000
SKIP          BASIC_ROM     = $C000
              #endif

0000 TRUE     #if C64

d000          VIC_BASE      = $D000
d011          VIC_CONTROL_1 = $D011
d012          VIC_RASTER    = $D012
d015          VIC_SPR_ENA   = $D015
d016          VIC_CONTROL_2 = $D016

002f          VIC_REGS = $2F

              ; ******************************************
              ; C-64 VIC-II (MOS (6566/7) Video Controller
              ; ******************************************

              ;  #| Adr.  |Bit7|Bit6|Bit5|Bit4|Bit3|Bit2|Bit1|Bit0| Function
              ; --+-------+----+----+----+----+----+----+----+----+------------------------
              ;  0| $d000 |                  M0X                  | X coordinate sprite 0
              ; --+-------+---------------------------------------+------------------------
              ;  1| $d001 |                  M0Y                  | Y coordinate sprite 0
              ; --+-------+---------------------------------------+------------------------
              ;  2| $d002 |                  M1X                  | X coordinate sprite 1
              ; --+-------+---------------------------------------+------------------------
              ;  3| $d003 |                  M1Y                  | Y coordinate sprite 1
              ; --+-------+---------------------------------------+------------------------
              ;  4| $d004 |                  M2X                  | X coordinate sprite 2
              ; --+-------+---------------------------------------+------------------------
              ;  5| $d005 |                  M2Y                  | Y coordinate sprite 2
              ; --+-------+---------------------------------------+------------------------
              ;  6| $d006 |                  M3X                  | X coordinate sprite 3
              ; --+-------+---------------------------------------+------------------------
              ;  7| $d007 |                  M3Y                  | Y coordinate sprite 3
              ; --+-------+---------------------------------------+------------------------
              ;  8| $d008 |                  M4X                  | X coordinate sprite 4
              ; --+-------+---------------------------------------+------------------------
              ;  9| $d009 |                  M4Y                  | Y coordinate sprite 4
              ; --+-------+---------------------------------------+------------------------
              ; 10| $d00a |                  M5X                  | X coordinate sprite 5
              ; --+-------+---------------------------------------+------------------------
              ; 11| $d00b |                  M5Y                  | Y coordinate sprite 5
              ; --+-------+---------------------------------------+------------------------
              ; 12| $d00c |                  M6X                  | X coordinate sprite 6
              ; --+-------+---------------------------------------+------------------------
              ; 13| $d00d |                  M6Y                  | Y coordinate sprite 6
              ; --+-------+---------------------------------------+------------------------
              ; 14| $d00e |                  M7X                  | X coordinate sprite 7
              ; --+-------+---------------------------------------+------------------------
              ; 15| $d00f |                  M7Y                  | Y coordinate sprite 7
              ; --+-------+----+----+----+----+----+----+----+----+------------------------
              ; 16| $d010 |M7X8|M6X8|M5X8|M4X8|M3X8|M2X8|M1X8|M0X8| MSBs of X coordinates
              ; --+-------+----+----+----+----+----+----+----+----+------------------------
              ; 17| $d011 |RST8| ECM| BMM| DEN|RSEL|    YSCROLL   | Control register 1
              ; --+-------+----+----+----+----+----+--------------+------------------------
              ; 18| $d012 |                 RASTER                | VIC_RASTER counter
              ; --+-------+---------------------------------------+------------------------
              ; 19| $d013 |                  LPX                  | Light pen X
              ; --+-------+---------------------------------------+------------------------
              ; 20| $d014 |                  LPY                  | Light pen Y
              ; --+-------+----+----+----+----+----+----+----+----+------------------------
              ; 21| $d015 | M7E| M6E| M5E| M4E| M3E| M2E| M1E| M0E| Sprite enabled
              ; --+-------+----+----+----+----+----+----+----+----+------------------------
              ; 22| $d016 |  - |  - | RES| MCM|CSEL|    XSCROLL   | Control register 2
              ; --+-------+----+----+----+----+----+----+----+----+------------------------
              ; 23| $d017 |M7YE|M6YE|M5YE|M4YE|M3YE|M2YE|M1YE|M0YE| Sprite Y expansion
              ; --+-------+----+----+----+----+----+----+----+----+------------------------
              ; 24| $d018 |VM13|VM12|VM11|VM10|CB13|CB12|CB11|  - | Memory pointers
              ; --+-------+----+----+----+----+----+----+----+----+------------------------
              ; 25| $d019 | IRQ|  - |  - |  - | ILP|IMMC|IMBC|IRST| Interrupt register
              ; --+-------+----+----+----+----+----+----+----+----+------------------------
              ; 26| $d01a |  - |  - |  - |  - | ELP|EMMC|EMBC|ERST| Interrupt enabled
              ; --+-------+----+----+----+----+----+----+----+----+------------------------
              ; 27| $d01b |M7DP|M6DP|M5DP|M4DP|M3DP|M2DP|M1DP|M0DP| Sprite data priority
              ; --+-------+----+----+----+----+----+----+----+----+------------------------
              ; 28| $d01c |M7MC|M6MC|M5MC|M4MC|M3MC|M2MC|M1MC|M0MC| Sprite multicolor
              ; --+-------+----+----+----+----+----+----+----+----+------------------------
              ; 29| $d01d |M7XE|M6XE|M5XE|M4XE|M3XE|M2XE|M1XE|M0XE| Sprite X expansion
              ; --+-------+----+----+----+----+----+----+----+----+------------------------
              ; 30| $d01e | M7M| M6M| M5M| M4M| M3M| M2M| M1M| M0M| Sprite-sprite collision
              ; --+-------+----+----+----+----+----+----+----+----+------------------------
              ; 31| $d01f | M7D| M6D| M5D| M4D| M3D| M2D| M1D| M0D| Sprite-data collision
              ; --+-------+----+----+----+----+----+----+----+----+------------------------
              ; 32| $d020 |  - |  - |  - |  - |         EC        | Border color
              ; --+-------+----+----+----+----+-------------------+------------------------
              ; 33| $d021 |  - |  - |  - |  - |        B0C        | Background color 0
              ; --+-------+----+----+----+----+-------------------+------------------------
              ; 34| $d022 |  - |  - |  - |  - |        B1C        | Background color 1
              ; --+-------+----+----+----+----+-------------------+------------------------
              ; 35| $d023 |  - |  - |  - |  - |        B2C        | Background color 2
              ; --+-------+----+----+----+----+-------------------+------------------------
              ; 36| $d024 |  - |  - |  - |  - |        B3C        | Background color 3
              ; --+-------+----+----+----+----+-------------------+------------------------
              ; 37| $d025 |  - |  - |  - |  - |        MM0        | Sprite multicolor 0
              ; --+-------+----+----+----+----+-------------------+------------------------
              ; 38| $d026 |  - |  - |  - |  - |        MM1        | Sprite multicolor 1
              ; --+-------+----+----+----+----+-------------------+------------------------
              ; 39| $d027 |  - |  - |  - |  - |        M0C        | Color sprite 0
              ; --+-------+----+----+----+----+-------------------+------------------------
              ; 40| $d028 |  - |  - |  - |  - |        M1C        | Color sprite 1
              ; --+-------+----+----+----+----+-------------------+------------------------
              ; 41| $d029 |  - |  - |  - |  - |        M2C        | Color sprite 2
              ; --+-------+----+----+----+----+-------------------+------------------------
              ; 42| $d02a |  - |  - |  - |  - |        M3C        | Color sprite 3
              ; --+-------+----+----+----+----+-------------------+------------------------
              ; 43| $d02b |  - |  - |  - |  - |        M4C        | Color sprite 4
              ; --+-------+----+----+----+----+-------------------+------------------------
              ; 44| $d02c |  - |  - |  - |  - |        M5C        | Color sprite 5
              ; --+-------+----+----+----+----+-------------------+------------------------
              ; 45| $d02d |  - |  - |  - |  - |        M6C        | Color sprite 6
              ; --+-------+----+----+----+----+-------------------+------------------------
              ; 46| $d02e |  - |  - |  - |  - |        M7C        | Color sprite 7
              ; --+-------+----+----+----+----+-------------------+------------------------

              ; **********************************************
              ; C-64 CIA1 (MOS 6526) Complex Interface Adapter
              ; **********************************************

              ;  #| Adr.  |Bit7|Bit6|Bit5|Bit4|Bit3|Bit2|Bit1|Bit0| Function
              ; --+-------+----+----+----+----+----+----+----+----+------------------------
              ;  0| $dc00 |                  PRA                  | Data port A
              ; --+-------+---------------------------------------+------------------------
              ;  1| $dc01 |                  PRB                  | Data port B
              ; --+-------+---------------------------------------+------------------------
              ;  2| $dc02 |                 DDRA                  | Data direction A
              ; --+-------+---------------------------------------+------------------------
              ;  3| $dc03 |                 DDRB                  | Data direction B
              ; --+-------+---------------------------------------+------------------------
              ;  4| $dc04 |                 TALO                  | Timer A low
              ; --+-------+---------------------------------------+------------------------
              ;  5| $dc05 |                 TAHI                  | Timer A high
              ; --+-------+---------------------------------------+------------------------
              ;  6| $dc06 |                 TBLO                  | Timer B low
              ; --+-------+---------------------------------------+------------------------
              ;  7| $dc07 |                 TBHI                  | Timer B high
              ; --+-------+----+----+----+----+----+----+----+----+------------------------
              ;  8| $dc08 | S/A|  0 |  0 |  0 |       TODS        | Time Of Day [1/10 sec]
              ; --+-------+----+----+----+----+----+----+----+----+------------------------
              ;  9| $dc09 |  0 |  TODS [10s]  |     TODS [1s]     | Time Of Day [sec]
              ; --+-------+----+--------------+-------------------+------------------------
              ; 10| $dc0a |  0 |  TODM [10m]  |     TODM [1m]     | Time Of Day [min]
              ; --+-------+----+--------------+-------------------+------------------------
              ; 11| $dc0b |AMPM|  TODH [10h]  |     TODH [1h]     | Time Of Day [hour]
              ; --+-------+----+--------------+-------------------+------------------------
              ; 12| $dc0c |                  SDR                  | Serial Data Register
              ; --+-------+----+----+----+----+----+----+----+----+------------------------
              ; 13| $dc0d |MODE|  0 |  0 |IFLG|ISDR|IARM|ITBU|ITBA| Interrupt Control Reg.
              ; --+-------+----+----+----+----+----+----+----+----+------------------------
              ; 14| $dc0e | Hz |DSDR|CNTP| ONE|CONT|TBUN|TBUN|STOP| Control Timer A
              ; --+-------+----+----+----+----+----+----+----+----+------------------------
              ; 15| $dc0f |MODE|   TACT  | ONE|CONT|TAUN|TAUN|STOP| Control Timer B
              ; --+-------+----+----+----+----+----+----+----+----+------------------------

dc00          CIA1_PRA   = $DC00   ; CIA1 Peripheral data Register A
                                   ; keyboard column

dc01          CIA1_PRB   = $DC01   ; CIA1 Peripheral data Register B
                                   ; keyboard row
                                   ; C64  keyboard matrix layout
                                   ;       c7   c6   c5   c4   c3   c2   c1   c0
                                   ;   +------------------------------------------------
                                   ; r7|  RUN    /    ,    N    V    X  LSH   DN
                                   ; r6|    Q   UP    @    O    U    T    E   F5
                                   ; r5|  CBM    =    :    K    H    F    S   F3
                                   ; r4|   SP  RSH    .    M    B    C    Z   F1
                                   ; r3|    2  HOM    -    0    8    6    4   F7
                                   ; r2|  CTL    ;    L    J    G    D    A  RGT
                                   ; r1|  LFT    *    P    I    Y    R    W  RET
                                   ; r0|    1    £    +    9    7    5    3  DEL

dc02          CIA1_DDRA  = $DC02   ; CIA1 Data Direction  Register A
dc03          CIA1_DDRB  = $DC03   ; CIA1 Data Direction  Register B
dc04          CIA1_TALO  = $DC04   ; CIA1 Timer A Low  register
dc05          CIA1_TAHI  = $DC05   ; CIA1 Timer A High register
dc06          CIA1_TBLO  = $DC06   ; CIA1 Timer B Low  register
dc07          CIA1_TBHI  = $DC07   ; CIA1 Timer B High register
dc08          CIA1_TODT  = $DC08   ; CIA1 Time Of Day 1/10 seconds
dc09          CIA1_TODS  = $DC09   ; CIA1 Time Of Day seconds
dc0a          CIA1_TODM  = $DC0A   ; CIA1 Time Of Day minutes
dc0b          CIA1_TODH  = $DC0B   ; CIA1 Time Of Day hours
dc0c          CIA1_SDR   = $DC0C   ; CIA1 Serial Data Register
dc0d          CIA1_ICR   = $DC0D   ; CIA1 Interrupt Control Register
dc0e          CIA1_CRA   = $DC0E   ; CIA1 Control Register A
dc0f          CIA1_CRB   = $DC0F   ; CIA1 Control Register B

              ; **********************************************
              ; C-64 CIA2 (MOS 6526) Complex Interface Adapter
              ; **********************************************

dd00          CIA2_PRA   = $DD00   ; CIA2 Peripheral data Register A
dd01          CIA2_PRB   = $DD01   ; CIA2 Peripheral data Register B
dd02          CIA2_DDRA  = $DD02   ; CIA2 Data Direction  Register A
dd03          CIA2_DDRB  = $DD03   ; CIA2 Data Direction  Register B
dd04          CIA2_TALO  = $DD04   ; CIA2 Timer A Low  register
dd05          CIA2_TAHI  = $DD05   ; CIA2 Timer A High register
dd06          CIA2_TBLO  = $DD06   ; CIA2 Timer B Low  register
dd07          CIA2_TBHI  = $DD07   ; CIA2 Timer B High register
dd08          CIA2_TODT  = $DD08   ; CIA2 Time Of Day 1/10 seconds
dd09          CIA2_TODS  = $DD09   ; CIA2 Time Of Day seconds
dd0a          CIA2_TODM  = $DD0A   ; CIA2 Time Of Day minutes
dd0b          CIA2_TODH  = $DD0B   ; CIA2 Time Of Day hours
dd0c          CIA2_SDR   = $DD0C   ; CIA2 Serial Data Register
dd0d          CIA2_ICR   = $DD0D   ; CIA2 Interrupt Control Register
dd0e          CIA2_CRA   = $DD0E   ; CIA2 Control Register A
dd0f          CIA2_CRB   = $DD0F   ; CIA2 Control Register B

              ; register names for keyboard driver

dc00          KEYB_COL   = CIA1_PRA
dc01          KEYB_ROW   = CIA1_PRB
dc01          KEYB_ROWN  = CIA1_PRB

              ; key coordinates

007f          CTRL_COL = %01111111 ; $7f = col 7
00fb          CTRL_ROW = %11111011 ; $fb = row 2

007f          STND_COL = %01111111 ; $7f = col 7

0000          D6510       =     0
0001          R6510       =     1

dc0d          VIA2_IER = CIA1_ICR    ; CIA1 Interrupt Control Register
dc07          VIA2_T2CH= $DC07
dc06          VIA2_T2CL= $DC06
dc04          VIA2_T1CL= $DC04
dc05          VIA2_T1CH= $DC05

0028          COLS          =  40
0019          ROWS          =  25
0002          COLINK        =   2
0050          COLMAX        =  80
00d8          COLRAM_PAGE   = $D8
000e          Default_Color = 14   ; Light blue

d018          MEM_CONTROL   = $D018
dc07          IEC_TIM_H     = $DC07; CIA 1 TIH, timer high
dc0d          IEC_IFR       = CIA1_ICR    ; CIA 1 CRB, interrupt flag register
dd00          IEC_PCR       = $DD00; VIA 2 peripheral control register (PCR)
dd00          IEC_DRAN      = $DD00; CIA 2 DRA, IEC bus

              ; bit 7	IEC Bus Data  Input
              ;     6	IEC Bus Clock Input
              ;     5	IEC Bus Data  Output
              ;     4	IEC Bus Clock Output
              ;     3	IEC Bus ATN Signal Output
              ;     2 User port PA2
              ;   0-1 VIC memory address

dd01          RS2_DSR_CTS   = $DD01
dd0d          RS2_IRQ_REG   = CIA2_ICR
dd04          RS2_TIM_LOW   = $DD04
dd05          RS2_TIM_HIG   = $DD05
0008          IEC_ATN_BIT   = $08
0002          IEC_IFR_BIT   = $02
0010          IEC_CLK_BIT   = %00010000; $10
0020          IEC_DAT_BIT   = %00100000; $20
0004          RS232_C_BIT   = %00000100; $04

0400          BASIC_SCREEN    = $0400
0800          BASIC_RAM_START = $0800
8000          OPTION_ROM      = $8000
a000          BASIC_ROM       = $A000
              #endif

              ; Some names for special characters

000d          CR    = $0D ; Carriage Return
000a          LF    = $0A ; Line Feed
0022          QUOTE = $22 ; Quote
003b          SEMIC = $3B ; Semicolon

              ; These locations contain the JMP instruction and traget address of the
              ; USR command. They are initialised so that if you try to execute a USR
              ; call without changing them you will receive an ILLEGAL QUANTITY error
              ; message.

0001 FALSE    #if VIC
SKIP          Basic_USR = $00      ; USR() JMP instruction ($4C)
SKIP          USRVEC    = $01      ; USR() vector (Illegal_Quantity)
              #endif

              ; This vector points to the address of the BASIC routine which converts
              ; a floating point number to an integer, however BASIC does not use this
              ; vector. It may be of assistance to the programmer who wishes to use
              ; data that is stored in floating point format. The parameter passed by
              ; the USR command is available only in that format for example.

0003          ADRAY1 = $03         ; float to fixed vector (Float_To_Integer)

              ; This vector points to the address of the BASIC routine which converts
              ; an integer to a floating point number, however BASIC does not use this
              ; vector. It may be used by the programmer who needs to make such a
              ; conversion for a machine language program that interacts with BASIC.
              ; To return an integer value with the USR command for example.

0005          ADRAY2 = $05         ; fixed to float vector (Integer_To_Float)

              ; The cursor column position prior to the TAB or SPC is moved here from
              ; $D3, and is used to calculate where the cursor ends up after one of
              ; these functions is invoked. Note that the value contained here shows
              ; the position of the cursor on a logical line. Since one logical line
              ; can be up to four VIC or two C64 physical lines long, the value stored
              ; here can range from 0 to 87 on VIC and 0 to 79 on C64.

0007          CHARAC = $07         ; search character
0008          ENDCHR = $08         ; scan quotes flag
0009          TRMPOS = $09         ; TAB column save

              ; The routine that converts the text in the input buffer into lines of
              ; executable program tokens, and the routines that link these program
              ; lines together, use this location as an index into the input buffer
              ; area. After the job of converting text to tokens is done, the value
              ; in this location is equal to the length of the tokenized line.

              ; The routines which build an array or locate an element in an array use
              ; this location to calculate the number of DIMensions called for and the
              ;  amount of storage required for a newly created array, or the number
              ; of subscripts when referencing an array element.

000a          VERCK  = $0A         ; load/verify flag, 0 = load, 1 = verify
000b          COUNT  = $0B         ; line crunch/array access/logic operators

              ; This is used as a flag by the routines that build an array or
              ; reference an existing array. It is used to determine whether a
              ; variable is in an array, whether the array has already been
              ; DIMensioned, and whether a new array should assume default size.

000c          DIMFLG = $0C         ; DIM flag

              ; This flag is used to indicate whether data being operated upon is
              ; string or numeric. A value of $FF in this location indicates string
              ; data while a $00 indicates numeric data.

000d          VALTYP = $0D         ; data type flag, $FF = string, $00 = numeric

              ; If the above flag indicates numeric then a $80 in this location
              ; identifies the number as an integer, and a $00 indicates a floating
              ; point number.

000e          INTFLG = $0E         ; data type flag, $80 = integer, $00 = floating pt.

              ; The garbage collection routine uses this location as a flag to
              ; indicate that garbage collection has already been tried before adding
              ; a new string. If there is still not enough memory, an OUT OF MEMORY
              ; error message will result.

              ; LIST uses this byte as a flag to let it know when it has come to a
              ; character string in quotes. It will then print the string,rather than
              ; search it for BASIC keyword tokens.

              ; This location is also used during the process of converting a line of
              ; text in the BASIC input buffer into a linked program line of BASIC
              ; keyword tokens to flag a DATA line is being processed.

000f          GARBFL = $0F         ; garbage collected/open quote/DATA flag

              ; If an opening parenthesis is found, this flag is set to indicate that
              ; the variable in question is either an array variable or a user-defined
              ; function.

0010          SUBFLG = $10         ; subscript/FNx flag

              ; This location is used to determine whether the sign of the value
              ; returned by the functions SIN, COS, ATN or TAN is positive or negative

              ; Also the comparison routines use this location to indicate the outcome
              ; of the compare. For A <=> B the value here will be $01 if A > B,
              ; $02 if A = B, and $04 if A < B. If more than one comparison operator
              ; was used to compare the two variables then the value here will be a
              ; combination of the above values.

0011          INPFLG = $11         ; input mode, $00 = INPUT, $40 = GET, $98 = READ
0012          TANSGN = $12         ; ATN sign/comparison evaluation flag

              ; When the default input or output device is used the value here will
              ; be a zero, and the format of prompting and output will be the standard
              ; screen output format. The location $B8 is used to decide what device
              ; actually to put input from or output to.

              ; The print CR/LF code at Print_CR suggests that b7 of this byte is
              ; an AutoLF flag bit but if it is used as such it would break lots of
              ; other parts of the code

0013          IOPMPT = $13         ; current I/O channel

              ; Used whenever a 16 bit integer is used e.g. the target line number for
              ; GOTO, LIST, ON, and GOSUB also the number of a BASIC line that is to
              ; be added or replaced. additionally PEEK, POKE, WAIT, and SYS use this
              ; location as a pointer to the address which is the subject of the
              ; command.

0014          LINNUM = $14         ; temporary integer

              ; This location points to the next available slot in the temporary
              ; string descriptor stack located at $19-$21.

0016          TEMPPT = $16         ; descriptor stack pointer, next free

              ; This contains information about temporary strings which hve not yet
              ; been assigned to a string variable.

0017          LASTPT = $17         ; current descriptor stack item pointer
0019          TEMPST = $19         ; to $21, descriptor stack

              ; These locations are used by BASIC multiplication and division
              ; routines. They are also used by the routines which compute the size of
              ; the area required to store an array which is being created.

0022          INDEXA = $22         ; misc temp word
0024          INDEXB = $24         ; misc temp word

0025          FAC3   = $25         ; auxiliary Floating Point Accumulator

0001 FALSE    #if JIFFY
SKIP          COMSAV = $27
              #endif

              ; Two byte pointer to where the BASIC program text is stored.

002b          TXTTAB = $2B         ; start of memory

              ; Two byte pointer to the start of the BASIC variable storage area.

002d          VARTAB = $2D         ; start of variables

              ; Two byte pointer to the start of the BASIC array storage area.

002f          ARYTAB = $2F         ; end of variables

              ; Two byte pointer to end of the start of free RAM.

0031          STREND = $31         ; end of arrays

              ; Two byte pointer to the bottom of the string text storage area.

0033          FRESPC = $33         ; bottom of string space

              ; Used as a temporary pointer to the most current string added by the
              ; routines which build strings or move them in memory.

0035          UTLSTP = $35         ; string utility ptr

              ; Two byte pointer to the highest address used by BASIC +1.

0037          MEMSIZ = $37         ; end of memory

              ; These locations contain the line number of the BASIC statement which
              ; is currently being executed. A value of $FF in location $3A means that
              ; BASIC is in immediate mode.

0039          CURLIN = $39         ; current line number

              ; When program execution ends or stops the last line number executed is
              ; stored here.

003b          OLDLIN = $3B         ; break line number

              ; These locations contain the address of the start of the text of the
              ; BASIC statement that is being executed.  The value of the pointer to
              ; the address of the BASIC text character currently being scanned is
              ; stored here each time a new BASIC statement begins execution.

003d          OLDTXT = $3D         ; continue pointer

              ; These locations hold the line number of the current DATA statement
              ; being READ. If an error concerning the DATA occurs this number will
              ; be moved to $39/$3A so that the error message will show the line that
              ; contains the DATA statement rather than in the line that contains the
              ; READ statement.

003f          DATLIN = $3F         ; current DATA line number

              ; These locations point to the address where the next DATA will be READ
              ; from. RESTORE sets this pointer back to the address indicated by the
              ; start of BASIC pointer.

0041          DATPTR = $41         ; DATA pointer

              ; READ, INPUT and GET all use this as a pointer to the address of the
              ; source of incoming data, such as DATA statements, or the text input
              ; buffer.

0043          INPPTR = $43         ; READ pointer

0045          VARNAM = $45         ; current variable name

              ; These locations point to the value of the current BASIC variable.
              ; Specifically they point to the byte just after the two-character
              ; variable name.

0047          VARPNT = $47         ; current variable address

              ; The address of the BASIC variable which is the subject of a FOR/NEXT
              ; loop is first stored here before being pushed onto the stack.

0049          FORPNT = $49         ; FOR/NEXT variable pointer

              ; The expression evaluation routine creates this to let it know whether
              ; the current comparison operation is a < $01, = $02 or > $04 comparison
              ; or combination.

004b          YSAVE  = $4B         ; BASIC execute pointer temporary/precedence flag

004d          ACCSYM = $4D         ; comparrison evaluation flag

              ; These locations are used as a pointer to the function that is created
              ; during function definition. During function execution it points to
              ; where the evaluation results should be saved.

004e          FUNCPT = $4E         ; FAC temp store/function/variable/garbage pointer

              ; Temporary Pointer to the current string descriptor.

0050          DESCPT = $50         ; FAC temp store/descriptor pointer

0053          GARBSS = $53         ; garbage collection step size

              ; The first byte is the 6502 JMP instruction $4C, followed by the
              ; address of the required function taken from the table at $C052.

0054          JUMPER = $54         ; JMP opcode for functions

0055          FUNJMP = $55         ; functions jump vector

              ; this address is sometimes used as high btye for the FUNJMP
              ; and as rounding byte (5th. byte of mantissa) for FAC1

0056          FAC2M5 = $56         ; FAC2 mantissa 5 = rounding byte

              ; Temporary storage for floating points values (5 bytes)
              ; and temporary pointer (block pointer, array pointer)

0057          FACTPA = $57         ; FAC temp store ($57 - $5B)
0058          TMPPTA = $58         ; temp pointer A
005a          TMPPTB = $5A         ; temp pointer B

              ; Temporary storage for floating points values (5 bytes)
              ; and temporary variables

005c          FACTPB = $5C         ; FAC temp store ($5C - $60)
005d          TMPVA1 = $5D         ; temp variable (counter)
005e          TMPVA2 = $5E         ; temp variable (counter)
005f          TMPPTC = $5F         ; temp pointer C

              ; Floating point accumulator 1

0061          FAC1EX = $61         ; FAC1 exponent
0062          FAC1M1 = $62         ; FAC1 mantissa 1
0063          FAC1M2 = $63         ; FAC1 mantissa 2
0064          FAC1M3 = $64         ; FAC1 mantissa 3
0065          FAC1M4 = $65         ; FAC1 mantissa 4
0066          FAC1SI = $66         ; FAC1 sign

0067          SGNFLG = $67         ; constant count/negative flag
0068          FAC1OV = $68         ; FAC1 overflow

              ; Floating point accumulator 2

0069          FAC2EX = $69         ; FAC2 exponent
006a          FAC2M1 = $6A         ; FAC2 mantissa 1
006b          FAC2M2 = $6B         ; FAC2 mantissa 2
006c          FAC2M3 = $6C         ; FAC2 mantissa 3
006d          FAC2M4 = $6D         ; FAC2 mantissa 4
006e          FAC2SI = $6E         ; FAC2 sign

              ; String pointer and FAC sign comparison and FAC rounding

006f          STRPTR = $6F         ; string pointer & FAC variables

              ; this address is sometimes used as high btye for the STRPTR
              ; and as rounding byte (5th. byte of mantissa) for FAC1

0070          FAC1M5 = $70         ; FAC1 mantissa 5 = rounding byte

0071          TMPPTD = $71         ; temp BASIC execute/array pointer low byte/index

              ; Basic CHRGET (with increment) and CHRGOT (no increment) routine

0073          CHRGET = $73         ; next program byte, BASIC byte get
0079          CHRGOT = $79         ; scan memory, BASIC byte get
007a          TXTPTR = $7A         ; BASIC execute pointer
0080          ISNUM  = $80         ; numeric test entry

008b          RNDX   = $8B         ; RND() seed, five bytes

0090          STATUS = $90         ; serial status byte
                                   ;   function
                                   ; bit   casette      serial bus
                                   ; ---   --------      ----------
                                   ;  7   end of tape      device not present
                                   ;  6   end of file      EOI
                                   ;  5   checksum error
                                   ;  4   read error
                                   ;  3   long block
                                   ;  2   short block
                                   ;  1            time out read
                                   ;  0            time out write

0091          STKEY  = $91         ; keyboard row, bx = 0 = key down
                                   ; bit   key
                                   ; ---   ------
                                   ;  7   [DOWN]
                                   ;  6   /
                                   ;  5   ,
                                   ;  4   N
                                   ;  3   V
                                   ;  2   X
                                   ;  1   [L SHIFT]
                                   ;  0   [STOP]

0092          SVXT   = $92         ; timing constant for tape read
0093          VERCKK = $93         ; load/verify flag, load = $00, verify = $01
0094          C3PO   = $94         ; serial output: deferred character flag
                                   ; $00 = no character waiting, $xx = character waiting
0095          BSOUR  = $95         ; serial output: deferred character
                                   ; $FF = no character waiting, $xx = waiting character
0096          SYNO   = $96         ; cassette block synchronization number
0097          TEMPX  = $97         ; register save

              ; The number of currently open I/O files is stored here. The maximum
              ; number that can be open at one time is ten. The number stored here is
              ; used as the index to the end of the tables that hold the file numbers,
              ; device numbers, and secondary addresses.

0098          LDTND  = $98         ; open file count

              ; The default value of this location is 0.

0099          DFLTN  = $99         ; input device number

              ; The default value of this location is 3.

009a          DFLTO  = $9A         ; output device number
                                   ;
                                   ; number   device
                                   ; ------   ------
                                   ;  0      keyboard
                                   ;  1      cassette
                                   ;  2      RS-232C
                                   ;  3      screen
                                   ;  4-31   serial bus

009b          PRTY   = $9B         ; tape character parity
009c          DPSW   = $9C         ; byte received flag
009d          MSGFLG = $9D         ; message mode flag,
                                   ; $C0 = both control and kernal messages,
                                   ; $80 = control messages only,
                                   ; $40 = kernal messages only,
                                   ; $00 = neither control or kernal messages
009e          PTR1   = $9E         ; index to cassette file name/header ID
009f          PTR2   = $9F         ; tape Pass 2 error log corrected

              ; These three locations form a counter which is updated 60 times a
              ; second, and serves as a software clock which counts the number of
              ; jiffies that have elapsed since the computer was turned on. After 24
              ; hours and one jiffy these locations are set back to $000000.

00a0          JIFFYH = $A0         ; jiffy clock high byte
00a1          JIFFYM = $A1         ; jiffy clock mid byte
00a2          JIFFYL = $A2         ; jiffy clock low byte
00a3          TSFCNT = $A3         ; EOI flag byte/tape bit count or Jiffy device flag
00a4          TBTCNT = $A4         ; tape bit cycle phase
00a5          CNTDN  = $A5         ; tape synch byte count/serial bus bit count
00a6          BUFPNT = $A6         ; tape buffer index
00a7          INBIT  = $A7         ; receiver input bit temp storage
00a8          BITCI  = $A8         ; receiver bit count in
00a9          RINONE = $A9         ; receiver start bit check flag, $90 = no start bit
00aa          RIDATA = $AA         ; receiver byte buffer/assembly location
00ab          RIPRTY = $AB         ; receiver parity bit storage
00ac          SAL    = $AC         ; tape buffer start pointer; scroll screen
00ae          EAL    = $AE         ; tape buffer end   pointer; scroll screen
00b0          CMPO   = $B0         ; tape timing constant (word)

              ; These two locations point to the address of the cassette buffer. This
              ; pointer must be greater than or equal to $0200 or an ILLEGAL DEVICE
              ; NUMBER error will be sent when tape I/O is tried. This pointer must
              ; also be less that $8000 or the routine will terminate early.

00b2          TAPE1  = $B2         ; tape buffer start pointer

              ; RS232 routines use this to count the number of bits transmitted and
              ; for parity and stop bit manipulation. Tape load routines use this
              ; location to flag when they are ready to receive data bytes.

00b4          BITTS  = $B4         ; transmitter bit count out

              ; This location is used by the RS232 routines to hold the next bit to
              ; be sent and by the tape routines to indicate what part of a block the
              ; read routine is currently reading.

00b5          NXTBIT = $B5         ; transmitter next bit to be sent

              ; RS232 routines use this area to disassemble each byte to be sent from
              ; the transmission buffer pointed to by $F9.

00b6          RODATA = $B6         ; transmitter byte buffer/disassembly location

              ; Disk filenames may be up to 16 characters in length while tape
              ; filenames be up to 187 characters in length.
              ; If a tape name is longer than 16 characters the excess will be
              ; truncated by the SEARCHING and FOUND messages, but will still be
              ; present on the tape.
              ; A disk file is always referred to by a name. This location will always
              ; be greater than zero if the current file is a disk file.

              ; An RS232 OPEN command may specify a filename of up to four characters.
              ; These characters are copied to locations $293 to $296 and determine
              ; baud rate, word length, and parity, or they would do if the feature
              ; was fully implemented.

00b7          FNLEN  = $B7         ; file name length

00b8          LA     = $B8         ; logical file
00b9          SA     = $B9         ; secondary address
00ba          FA     = $BA         ; current device number
                                   ; number   device
                                   ; ------   ------
                                   ;  0      keyboard
                                   ;  1      cassette
                                   ;  2      RS-232C
                                   ;  3      screen
                                   ;  4-31   serial bus
00bb          FNADR  = $BB         ; file name pointer
00bd          ROPRTY = $BD         ; tape write byte/RS232 parity byte

              ; Used by the tape routines to count the number of copies of a data
              ; block remaining to be read or written.

0001 FALSE    #if JIFFY
SKIP          Jiffy_Device = $BE
              #endif
00be          FSBLK  = $BE         ; tape copies count
00bf          MYCH   = $BF         ; parity count ??
00c0          CAS1   = $C0         ; tape motor interlock
00c1          STAL   = $C1         ; I/O start addresses
00c3          MEMUSS = $C3         ; kernal setup pointer
00c5          LSTX   = $C5         ; current key pressed
                                   ;
                                   ;  # key    # key    # key    # key
                                   ; -- ---   -- ---   -- ---   -- ---
                                   ; 00 1   10 none   20 [SPACE]   30 Q
                                   ; 01 3   11 A      21 Z      31 E
                                   ; 02 5   12 D      22 C      32 T
                                   ; 03 7   13 G      23 B      33 U
                                   ; 04 9   14 J      24 M      34 O
                                   ; 05 +   15 L      25 .      35 @
                                   ; 06 [UKP]   16 ;      26 none   36 ^
                                   ; 07 [DEL]   17 [CSR R]   27 [F1]   37 [F5]
                                   ; 08 [<-]   18 [STOP]   28 none   38 2
                                   ; 09 W   19 none   29 S      39 4
                                   ; 0A R   1A X      2A F      3A 6
                                   ; 0B Y   1B V      2B H      3B 8
                                   ; 0C I   1C N      2C K      3C 0
                                   ; 0D P   1D ,      2D :      3D -
                                   ; 0E *   1E /      2E =      3E [HOME]
                                   ; 0F [RET]   1F [CSR D]   2F [F3]   3F [F7]

00c6          NDX    = $C6         ; keyboard buffer length/index

              ; When the [CTRL][RVS-ON] characters are printed this flag is set to
              ; $12, and the print routines will add $80 to the screen code of each
              ; character which is printed, so that the caracter will appear on the
              ; screen with its colours reversed.

              ; Note that the contents of this location are cleared not only upon
              ; entry of a [CTRL][RVS-OFF] character but also at every carriage return

00c7          RVS    = $C7         ; reverse flag $12 = reverse, $00 = normal

              ; This pointer indicates the column number of the last nonblank
              ; character on the logical line that is to be input. Since a logical
              ; line can be up to 88 characters long this number can range from 0-87.

00c8          INDX   = $C8         ; input [EOL] pointer

              ; These locations keep track of the logical line that the cursor is on
              ; and its column position on that logical line.

              ; Each logical line may contain up to four 22 column physical lines. So
              ; there may be as many as 23 logical lines, or as few as 6 at any one
              ; time. Therefore, the logical line number might be anywhere from 1-23.
              ; Depending on the length of the logical line, the cursor column may be
              ; from 1-22, 1-44, 1-66 or 1-88.

              ; For a more on logical lines, see the description of the screen line
              ; link table, $D9.

00c9          ICRROW = $C9         ; input cursor row
00ca          ICRCOL = $CA         ; input cursor column

              ; The keyscan interrupt routine uses this location to indicate which key
              ; is currently being pressed. The value here is then used as an index
              ; into the appropriate keyboard table to determine which character to
              ; print when a key is struck.

              ; The correspondence between the key pressed and the number stored here
              ; is as follows:

              ; $00   1      $10   unused $20   [SPC]  $30   Q
              ; $01   3      $11   A      $21   Z      $31   E
              ; $02   5      $12   D      $22   C      $32   T
              ; $03   7      $13   G      $23   B      $33   U
              ; $04   9      $14   J      $24   M      $34   O
              ; $05   +      $15   L      $25   .      $35   @
              ; $06   [PND]  $16   ;      $26   unused $36   [U ARROW]
              ; $07   [DEL]  $17   [RIGHT]$27   [F1]   $37   [F5]   
              ; $08   [<-]   $18   [STOP] $28   unused $38   2
              ; $09   W      $19   unused $29   S      $39   4
              ; $0A   R      $1A   X      $2A   F      $3A   6
              ; $0B   Y      $1B   V      $2B   H      $3B   8
              ; $0C   I      $1C   N      $2C   K      $3C   0
              ; $0D   P      $1D   ,      $2D   :      $3D   -
              ; $0E   *      $1E   /      $2E   =      $3E   [HOME]
              ; $0F   [RET]  $1F   [DOWN] $2F   [F3]   $3F   [F7]

00cb          SFDX   = $CB         ; which key

              ; When this flag is set to a nonzero value, it indicates to the routine
              ; that normally flashes the cursor not to do so. The cursor blink is
              ; turned off when there are characters in the keyboard buffer, or when
              ; the program is running.

00cc          BLNSW  = $CC         ; cursor enable, $00 = flash cursor

              ; The routine that blinks the cursor uses this location to tell when
              ; it's time for a blink. The number 20 is put here and decremented every
              ; jiffy until it reaches zero. Then the cursor state is changed, the
              ; number 20 is put back here, and the cycle starts all over again.

00cd          BLNCT  = $CD         ; cursor timing countdown

              ; The cursor is formed by printing the inverse of the character that
              ; occupies the cursor position. If that characters is the letter A, for
              ; example, the flashing cursor merely alternates between printing an A
              ; and a reverse-A. This location keeps track of the normal screen code
              ; of the character that is located at the cursor position, so that it
              ; may be restored when the cursor moves on.

00ce          GDBLN  = $CE         ; character under cursor

              ; This location keeps track of whether, during the current cursor blink,
              ; the character under the cursor was reversed, or was restored to
              ; normal. This location will contain 0 if the character is reversed, and
              ; 1 if the character is not reversed.

00cf          BLNON  = $CF         ; cursor blink phase

              ; input from keyboard or screen, $xx = input is available from the
              ; screen, $00 = input should be obtained from the keyboard

00d0          INSRC  = $D0         ; input from keyboard or screen

              ; These locations point to the address in screen RAM of the first column
              ; of the logical line upon which the cursor is currently positioned.

00d1          LINPTR = $D1         ; current screen line pointer

              ; This holds the cursor column position within the logical line pointed
              ; to by LINPTR. Since a logical line can comprise up to four physical
              ; lines, this value may be from $00 to $57.

00d3          CSRIDX = $D3         ; cursor column

              ; A nonzero value in this location indicates that the editor is in quote
              ; mode. Quote mode is toggled every time that you type in a quotation
              ; mark on a given line, the first quote mark turns it on, the second
              ; turns it off, the third turns it on, etc.

              ; If the editor is in this mode when a cursor control character or other
              ; nonprinting character is entered, a printed equivalent will appear on
              ; the screen instead of the cursor movement or other control operation
              ; taking place. Instead, that action is deferred until the string is
              ; sent to the string by a PRINT statement, at which time the cursor
              ; movement or other control operation will take place.

              ; The exception to this rule is the DELETE key, which will function
              ; normally within quote mode. The only way to print a character which is
              ; equivalent to the DELETE key is by entering insert mode. Quote mode
              ; may be exited by printing a closing quote or by hitting the RETURN or
              ; SHIFT-RETURN keys.

00d4          CSRMOD = $D4         ; cursor quote flag

              ; The line editor uses this location when the end of a line has been
              ; reached to determine whether another physical line can be added to the
              ; current logical line or if a new logical line must be started.

00d5          LINLEN = $D5         ; current screen line length

              ; This location contains the current physical screen line position of
              ; the cursor, 0 to 22 for VIC or 0 to 24 for C64.

00d6          TBLX   = $D6         ; cursor row

              ; The ASCII value of the last character printed to the screen is held
              ; here temporarily.

00d7          LASTKY = $D7         ; checksum byte/temporary last character

              ; When the INST key is pressed, the screen editor shifts the line to the
              ; right, allocates another physical line to the logical line if
              ; necessary (and possible), updates the screen line length in $D5, and
              ; adjusts the screen line link table at $D9. This location is used to
              ; keep track of the number of spaces that has been opened up in this way.

              ; Until the spaces that have been opened up are filled, the editor acts
              ; as if in quote mode. See location $D4, the quote mode flag. This means
              ; that cursor control characters that are normally nonprinting will
              ; leave a printed equivalent on the screen when entered, instead of
              ; having their normal effect on cursor movement, etc. The only
              ; difference between insert and quote mode is that the DELETE key will
              ; leave a printed equivalent in insert mode, while the INSERT key will
              ; insert spaces as normal.

00d8          INSRTO = $D8         ; insert count

              ; This table contains 23/25 entries, one for each row of the screen
              ; display. Each entry has two functions. Bits 0-3 indicate on which of
              ; the four pages of screen memory the first byte of memory for that row
              ; is located. This is used in calculating the pointer to the starting
              ; address of a screen line at $D1.
              ;
              ; The high byte is calculated by adding the value of the starting page
              ; of screen memory held in $288 to the displacement page held here.
              ;
              ; The other function of this table is to establish the makeup of logical
              ; lines on the screen. While each screen line is only 22/40 characters
              ; long, BASIC allows the entry of program lines that contain up to 88
              ; characters. Therefore, some method must be used to determine which
              ; physical lines are linked into a longer logical line, so that this
              ; longer logical line may be edited as a unit.
              ;
              ; The high bit of each byte here is used as a flag by the screen editor.
              ; That bit is set when a line is the first or only physical line in a
              ; logical line. The high bit is reset to 0 only when a line is an
              ; extension to this logical line.

00d9          SLLTBL = $D9         ; to SLLTBL + $18 inclusive, screen line link table

              ; This pointer is synchronized with the pointer to the address of the
              ; first byte of screen RAM for the current line kept in location $D1. It
              ; holds the address of the first byte of colour RAM for the
              ; corresponding screen line.

0001 FALSE    #if VIC
SKIP          SCROWM = $F2         ; screen row marker
              #endif

00f3          USER   = $F3         ; colour RAM pointer

              ; This pointer points to the address of the keyboard matrix lookup table
              ; currently being used. Although there are only 64 keys on the keyboard
              ; matrix, each key can be used to print up to four different characters,
              ; depending on whether it is struck by itself or in combination with the
              ; SHIFT, CTRL, or C= keys.

              ; These tables hold the ASCII value of each of the 64 keys for one of
              ; these possible combinations of keypresses. When it comes time to print
              ; the character, the table that is used determines which character is
              ; printed.

              ; The addresses of the tables are:

              ;   KBD_NORMAL          ; unshifted
              ;   KBD_SHIFTED         ; shifted
              ;   KBD_CBMKEY          ; commodore
              ;   KBD_CONTROL         ; control

00f5          KBDPTR = $F5         ; keyboard pointer

              ; When device the RS232 channel is opened two buffers of 256 bytes each
              ; are created at the top of memory. These locations point to the address
              ; of the one which is used to store characters as they are received.

00f7          RXPTR  = $F7         ; RS232 Rx pointer

              ; These locations point to the address of the 256 byte output buffer
              ; that is used for transmitting data to RS232 devices.

00f9          TXPTR  = $F9         ; RS232 Tx pointer

00ff          BASSTO = $FF         ; FAC1 to string output base

0100          STACK  = $0100       ; bottom of the stack page

0200          BUF    = $0200       ;   input buffer. for some routines the byte before
                                   ;   the input buffer needs to be set to a specific
                                   ;   value for the routine to work correctly

0259          FILTBL = $0259       ;   .. to $0262 logical file table
0263          DEVTBL = $0263       ;   .. to $026C device number table
026d          SECATB = $026D       ;   .. to $0276 secondary address table
0277          KBUFFR = $0277       ;   .. to $0280 keyboard buffer
0281          OSSTAR = $0281       ;   OS start of memory low byte
0283          OSTOP  = $0283       ;   OS top of memory low byte
0285          STIMOT = $0285       ;   serial bus timeout flag
0286          COLOR  = $0286       ;   current colour code
0287          CSRCLR = $0287       ;   colour under cursor
0288          SCNMPG = $0288       ;   screen memory page
0289          KBMAXL = $0289       ;   maximum keyboard buffer size
028a          KEYRPT = $028A       ;   key repeat. $80 = repeat all, $40 = repeat none,
                                   ;   $00 = repeat cursor movement keys, insert/delete
                                   ;   key and the space bar
028b          KRPTSP = $028B       ;   repeat speed counter
028c          KRPTDL = $028C       ;   repeat delay counter

              ; This flag signals which of the SHIFT, CTRL, or C= keys are currently
              ; being pressed.

              ; A value of $01 signifies that one of the SHIFT keys is being pressed,
              ; a $02 shows that the C= key is down, and $04 means that the CTRL key
              ; is being pressed. If more than one key is held down, these values will
              ; be added e.g $03 indicates that SHIFT and C= are both held down.

              ; Pressing the SHIFT and C= keys at the same time will toggle the
              ; character set that is presently being used between the uppercase/
              ; graphics set, and the lowercase/uppercase set.

              ; While this changes the appearance of all of the characters on the
              ; screen at once it has nothing whatever to do with the keyboard shift
              ; tables and should not be confused with the printing of SHIFTed
              ; characters, which affects only one character at a time.

028d          SHFLAG   = $028D     ; keyboard shift/control flag
                                   ; bit   key(s) 1 = down
                                   ; ---   ---------------
                                   ; 7-3   unused
                                   ;  2   CTRL
                                   ;  1   C=
                                   ;  0   SHIFT

              ; This location, in combination with the one above, is used to debounce
              ; the special SHIFT keys. This will keep the SHIFT/C= combination from
              ; changing character sets back and forth during a single pressing of
              ; both keys.

028e          LSTSHF   = $028E     ; SHIFT/CTRL/C= keypress last pattern

              ; This location points to the address of the Operating System routine
              ; which actually determines which keyboard matrix lookup table will be
              ; used.

              ; The routine looks at the value of the SHIFT flag at $28D, and based on
              ; what value it finds there, stores the address of the correct table to
              ; use at location $F5.

028f          KEYLOG   = $028F     ; keyboard decode logic pointer

              ; This flag is used to enable or disable the feature which lets you
              ; switch between the uppercase/graphics and upper/lowercase character
              ; sets by pressing the SHIFT and Commodore logo keys simultaneously.

0291          MODE     = $0291     ; shift mode switch, $00 = enabled, $80 = locked

              ; This location is used to determine whether moving the cursor past the
              ; xx  column of a logical line will cause another physical line to be
              ; added to the logical line.

              ; A value of 0 enables the screen to scroll the following lines down in
              ; order to add that line; any nonzero value will disable the scroll.

              ; This flag is set to disable the scroll temporarily when there are
              ; characters waiting in the keyboard buffer, these may include cursor
              ; movement characters that would eliminate the need for a scroll.

0292          AUTODN   = $0292     ; screen scrolling flag, $00 = enabled

0293          M51CTR   = $0293     ; pseudo 6551 control register. the first character of
                                   ; the OPEN RS232 filename will be stored here
                                   ; bit   function
                                   ; ---   --------
                                   ;  7   2 stop bits/1 stop bit
                                   ; 65   word length
                                   ; ---   -----------
                                   ; 00   8 bits
                                   ; 01   7 bits
                                   ; 10   6 bits
                                   ; 11   5 bits
                                   ;  4   unused
                                   ; 3210   baud rate
                                   ; ----   ---------
                                   ; 0000   user rate *
                                   ; 0001      50
                                   ; 0010      75
                                   ; 0011     110
                                   ; 0100     134.5
                                   ; 0101     150
                                   ; 0110     300
                                   ; 0111     600
                                   ; 1000    1200
                                   ; 1001    1800
                                   ; 1010    2400
                                   ; 1011    3600
                                   ; 1100    4800 *
                                   ; 1101    7200 *
                                   ; 1110    9600 *
                                   ; 1111   19200 *   * = not implemented
0294          M51CDR   = $0294     ; pseudo 6551 command register. the second character of
                                   ; the OPEN RS232 filename will be stored here
                                   ; bit   function
                                   ; ---   --------
                                   ; 765   parity
                                   ; ---   ------
                                   ; xx0   disabled
                                   ; 001   odd
                                   ; 011   even
                                   ; 101   mark
                                   ; 111   space
                                   ;  4   duplex half/full
                                   ;  3   unused
                                   ;  2   unused
                                   ;  1   unused
                                   ;  0   handshake - X line/3 line
0295          M51AJB   = $0295     ; Nonstandard Bit Timing. the third and fourth character
                                   ; of the OPEN RS232 filename will be stored here
0297          RSSTAT   = $0297     ; RS-232 status register
                                   ; bit   function
                                   ; ---   --------
                                   ;  7   break
                                   ;  6   no DSR detected
                                   ;  5   unused
                                   ;  4   no CTS detected
                                   ;  3   unused
                                   ;  2   Rx buffer overrun
                                   ;  1   framing error
                                   ;  0   parity error
0298          BITNUM   = $0298     ; number of bits to be sent/received
0299          BAUDOF   = $0299     ; time of one bit cell
029b          RIDBE    = $029B     ; index to Rx buffer end
029c          RIDBS    = $029C     ; index to Rx buffer start
029d          RODBS    = $029D     ; index to Tx buffer start
029e          RODBE    = $029E     ; index to Tx buffer end
029f          IRQTMP   = $029F     ; saved IRQ

0000 TRUE     #if C64
02a1          ENABL    = $02A1
02a2          TODSNS   = $02A2
02a3          TRDTMP   = $02A3
02a4          TD1IRQ   = $02A4
02a5          SCROWM   = $02A5     ; screen row marker
02a6          TVSFLG   = $02A6     ; PAL / NTSC flag
              #endif

0300          IERROR   = $0300     ; vector to the print BASIC error message routine
0302          IMAIN    = $0302     ; Vector to the main BASIC program Loop
0304          ICRNCH   = $0304     ; Vector to the the ASCII text to keywords routine
0306          IQPLOP   = $0306     ; Vector to the list BASIC program as ASCII routine
0308          IGONE    = $0308     ; Vector to the execute next BASIC command routine
030a          IEVAL    = $030A     ; Vector to the get value from BASIC line routine

              ; Before every SYS command each of the registers is loaded with the
              ; value found in the corresponding storage address. Upon returning to
              ; BASIC with an RTS instruction, the new value of each register is
              ; stored in the appropriate storage address.

              ; This feature allows you to place the necessary values into the
              ; registers from BASIC before you SYS to a Kernal or BASIC ML routine.
              ; It also enables you to examine the resulting effect of the routine on
              ; the registers, and to preserve the condition of the registers on exit
              ; for subsequent SYS calls.

030c          SAREG    = $030C     ; A for SYS command
030d          SXREG    = $030D     ; X for SYS command
030e          SYREG    = $030E     ; Y for SYS command
030f          SPREG    = $030F     ; P for SYS command

0000 TRUE     #if C64
0310          Basic_USR= $0310     ; USR() JMP instruction ($4C)
0311          USRVEC   = $0311     ; USR() vector
              #endif

0314          CINV     = $0314     ; IRQ vector
0316          CBINV    = $0316     ; BRK vector
0318          NMINV    = $0318     ; NMI vector

031a          IOPEN    = $031A     ; kernal vector - open a logical file
031c          ICLOSE   = $031C     ; kernal vector - close a logical file
031e          ICHKIN   = $031E     ; kernal vector - open channel for input
0320          ICKOUT   = $0320     ; kernal vector - open channel for output
0322          ICLRCH   = $0322     ; kernal vector - close input and output channels
0324          IBASIN   = $0324     ; kernal vector - input character from channel
0326          IBSOUT   = $0326     ; kernal vector - output character to channel
0328          ISTOP    = $0328     ; kernal vector - check if stop key is pressed
032a          IGETIN   = $032A     ; kernal vector - get character from keyboard queue
032c          ICLALL   = $032C     ; kernal vector - close all channels and files
032e          USRCMD   = $032E     ; kernal vector - user IRQ
0330          ILOAD    = $0330     ; kernal vector - load
0332          ISAVE    = $0332     ; kernal vector - save

033c          TBUFFR   = $033C     ; to $03FB - cassette buffer

              ; hardware equates

0000 TRUE     #if C64
dc00             IO_Base_Address = $DC00
              #endif

0001 FALSE    #if VIC
SKIP             IO_Base_Address = $9110
              #endif

              ; command tokens

0080          TK_END     = $80   ; END token
0081          TK_FOR     = $81   ; FOR token
0082          TK_NEXT    = $82   ; NEXT token
0083          TK_DATA    = $83   ; DATA token
0084          TK_INFL    = $84   ; INPUT# token
0085          TK_INPUT   = $85   ; INPUT token
0086          TK_DIM     = $86   ; DIM token
0087          TK_READ    = $87   ; READ token

0088          TK_LET     = $88   ; LET token
0089          TK_GOTO    = $89   ; GOTO token
008a          TK_RUN     = $8A   ; RUN token
008b          TK_IF      = $8B   ; IF token
008c          TK_RESTORE = $8C   ; RESTORE token
008d          TK_GOSUB   = $8D   ; GOSUB token
008e          TK_RETURN  = $8E   ; RETURN token
008f          TK_REM     = $8F   ; REM token

0090          TK_STOP    = $90   ; STOP token
0091          TK_ON      = $91   ; ON token
0092          TK_WAIT    = $92   ; WAIT token
0093          TK_LOAD    = $93   ; LOAD token
0094          TK_SAVE    = $94   ; SAVE token
0095          TK_VERIFY  = $95   ; VERIFY token
0096          TK_DEF     = $96   ; DEF token
0097          TK_POKE    = $97   ; POKE token

0098          TK_PRINFL  = $98   ; PRINT# token
0099          TK_PRINT   = $99   ; PRINT token
009a          TK_CONT    = $9A   ; CONT token
009b          TK_LIST    = $9B   ; LIST token
009c          TK_CLR     = $9C   ; CLR token
009d          TK_CMD     = $9D   ; CMD token
009e          TK_SYS     = $9E   ; SYS token
009f          TK_OPEN    = $9F   ; OPEN token

00a0          TK_CLOSE   = $A0   ; CLOSE token
00a1          TK_GET     = $A1   ; GET token
00a2          TK_NEW     = $A2   ; NEW token

              ; secondary keyword tokens

00a3          TK_TAB     = $A3   ; TAB( token
00a4          TK_TO      = $A4   ; TO token
00a5          TK_FN      = $A5   ; FN token
00a6          TK_SPC     = $A6   ; SPC( token
00a7          TK_THEN    = $A7   ; THEN token

00a8          TK_NOT     = $A8   ; NOT token
00a9          TK_STEP    = $A9   ; STEP token

              ; operator tokens

00aa          TK_PLUS    = $AA   ; + token
00ab          TK_MINUS   = $AB   ; - token
00ac          TK_MUL     = $AC   ; * token
00ad          TK_DIV     = $AD   ; / token
00ae          TK_POWER   = $AE   ; ^ token
00af          TK_AND     = $AF   ; AND token

00b0          TK_OR      = $B0   ; OR token
00b1          TK_GT      = $B1   ; > token
00b2          TK_EQUAL   = $B2   ; = token
00b3          TK_LT      = $B3   ; < token

              ; function tokens

00b4          TK_SGN     = $B4   ; SGN token
00b5          TK_INT     = $B5   ; INT token
00b6          TK_ABS     = $B6   ; ABS token
00b7          TK_USR     = $B7   ; USR token

00b8          TK_FRE     = $B8   ; FRE token
00b9          TK_POS     = $B9   ; POS token
00ba          TK_SQR     = $BA   ; SQR token
00bb          TK_RND     = $BB   ; RND token
00bc          TK_LOG     = $BC   ; LOG token
00bd          TK_EXP     = $BD   ; EXP token
00be          TK_COS     = $BE   ; COS token
00bf          TK_SIN     = $BF   ; SIN token

00c0          TK_TAN     = $C0   ; TAN token
00c1          TK_ATN     = $C1   ; ATN token
00c2          TK_PEEK    = $C2   ; PEEK token
00c3          TK_LEN     = $C3   ; LEN token
00c4          TK_STRS    = $C4   ; STR$ token
00c5          TK_VAL     = $C5   ; VAL token
00c6          TK_ASC     = $C6   ; ASC token
00c7          TK_CHRS    = $C7   ; CHR$ token

00c8          TK_LEFTS   = $C8   ; LEFT$ token
00c9          TK_RIGHTS  = $C9   ; RIGHT$ token
00ca          TK_MIDS    = $CA   ; MID$ token
00cb          TK_GO      = $CB   ; GO token
00ff          TK_PI      = $FF   ; PI token

              ; KERNAL Jump Table
              ; ----------------------------------------------------------------------
              ; ACPTR       $FFA5 65445    Input byte from serial port
              ; CHKIN       $FFC6 65478    Open channel for input
              ; CHKOUT      $FFC9 65481    Open a channel for output
              ; CHRIN       $FFCF 65487    Get a character from the input channel
              ; CHROUT      $FFD2 65490    Output a character
              ; CIOUT       $FFA8 65448    Output byte to serial port
              ; CLALL       $FFE7 65511    Close all channels and files
              ; CLOSE       $FFC3 65475    Close a specified logical file
              ; CLRCHN      $FFCC 65484    Clear I/O channels
              ; GETIN       $FFE4 65512    Get character from keyboard buffer
              ; IOBASE      $FFF3 65523    Define I/O memory page
              ; LISTEN      $FFB1 65457    Command devices on the serial bus to LISTEN
              ; LOAD        $FFD5 65493    Load RAM from a device
              ; MEMBOT      $FF9C 65436    Read/set the bottom of memory
              ; MEMTOP      $FF99 65433    Read/set the top of memory
              ; OPEN        $FFC0 65472    Open a logical file
              ; PLOT        $FFF0 65520    Read or set cursor location
              ; RDTIM       $FFDE 65502    Read system clock
              ; READST      $FFB7 65463    Read I/O status word
              ; RESTOR      $FF8A 65415    Restore default I/O vectors
              ; SAVE        $FFD8 65496    Save RAM to device
              ; SCNKEY      $FF9F 65439    Scan keyboard
              ; SCREEN      $FFED 65517    Return screen format
              ; SECOND      $FF93 65427    Send secondary address after LISTEN
              ; SETLFS      $FFBA 65466    Set logical, first and second addresses
              ; SETMSG      $FF90 65424    Control KERNAL messages
              ; SETNAM      $FFBD 65469    Set filename
              ; SETTIM      $FFDB 65499    Set the system clock
              ; SETTMO      $FFA2 65442    Set timeout on serial bus
              ; STOP        $FFE1 65505    Scan stop key
              ; TALK        $FFB4 65460    Command serial bus device to TALK
              ; TKSA        $FF96 65430    Send secondary address after TALK
              ; UDTIM       $FFEA 65514    Update the system clock
              ; UNLSN       $FFAE 65454    Command serial bus to UNLISTEN
              ; UNTLK       $FFAB 65451    Command serial bus to UNTALK
              ; VECTOR      $FF8D 65421    Read/set vectored I/O


              ; **********************
              ; BASIC scalar variables
              ; **********************

              ; ---------+-----+-----+-----+-----+-----+-----+-----+-----
              ; Type     | Exa.|  0  |  1  |  2  |  3  |  4  |  5  |  6
              ; ---------+-----+-----+-----+-----+-----+-----+-----+-----
              ; Float    | AB  |  A  |  B  | EXP | MSB | MAN | MAN | LSB
              ; ---------+-----+-----+-----+-----+-----+-----+-----+-----
              ; Integer  | AB% |  A^ |  B^ | MSB | LSB |  0  |  0  |  0  
              ; ---------+-----+-----+-----+-----+-----+-----+-----+-----
              ; Function | AB( |  A^ |  B  | LFP | MFP | LBP | MBP |  0  
              ; ---------+-----+-----+-----+-----+-----+-----+-----+-----
              ; String   | AB$ |  A  |  B^ | LEN | LSP | MSP |  0  |  0
              ; ---------+-----+-----+-----+-----+-----+-----+-----+-----

              ; ************
              ; BASIC arrays
              ; ************

              ; ---------+-----+-----+-----+---------------+
              ; Type     | Exa.|  0  |  1  |  Element Size |
              ; ---------+-----+-----+-----+---------------+
              ; Float    | AB  |  A  |  B  |       5       |
              ; ---------+-----+-----+-----+---------------+
              ; Integer  | AB% |  A^ |  B^ |       2       |
              ; ---------+-----+-----+-----+---------------+
              ; String   | AB$ |  A  |  B^ |       3       |
              ; ---------+-----+-----+-----+---------------+

              ; The circumflex ^ indicates characters OR'ed with $80

              ; Array header:

              ; Byte  0   : 1st. character of name
              ; Byte  1   : 2nd, character of name
              ; Byte  2   : dimension count (1, 2, or 3)
              ; Byte  3-4 : Hi/Lo lements of 1st. dimension, (e.g. 11 for dim a(10)
              ; Byte  5-6 : elements of 2nd. dimension if dimension count > 1
              ; Byte  7-8 : elements of 3rd. dimension if dimension count > 2

a000                    .org    BASIC_ROM
0000 TRUE     #if C64
                        .store  BASIC_ROM,$2000,"basic_64.rom"
              #endif
0001 FALSE    #if VIC
SKIP                    .store  BASIC_ROM,$2000,"basic_20.rom"
              #endif
a000 94 e3              .word   Basic_Cold_Start
a002 7b e3    BASIC_BRK .word   Basic_Warm_Start
a004 43 42 4d BASIC_ID  .byte   "CBMBASIC"

              ; *********************
a00c            Basic_Statement_Table
              ; *********************

a00c 30 a8       .word Basic_END      -1; $80
a00e 41 a7       .word Basic_FOR      -1; $81
a010 1d ad       .word Basic_NEXT     -1; $82
a012 f7 a8       .word Basic_DATA     -1; $83
a014 a4 ab       .word Basic_INPUTN   -1; $84
a016 be ab       .word Basic_INPUT    -1; $85
a018 80 b0       .word Basic_DIM      -1; $86
a01a 05 ac       .word Basic_READ     -1; $87
a01c a4 a9       .word Basic_LET      -1; $88
a01e 9f a8       .word Basic_GOTO     -1; $89
a020 70 a8       .word Basic_RUN      -1; $8A
a022 27 a9       .word Basic_IF       -1; $8B
a024 1c a8       .word Basic_RESTORE  -1; $8C
a026 82 a8       .word Basic_GOSUB    -1; $8D
a028 d1 a8       .word Basic_RETURN   -1; $8E
a02a 3a a9       .word Basic_REM      -1; $8F
a02c 2e a8       .word Basic_STOP     -1; $90
a02e 4a a9       .word Basic_ON       -1; $91
a030 2c b8       .word Basic_WAIT     -1; $92
a032 67 e1       .word Basic_LOAD     -1; $93
a034 55 e1       .word Basic_SAVE     -1; $94
a036 64 e1       .word Basic_VERIFY   -1; $95
a038 b2 b3       .word Basic_DEF      -1; $96
a03a 23 b8       .word Basic_POKE     -1; $97
a03c 7f aa       .word Basic_PRINTN   -1; $98
a03e 9f aa       .word Basic_PRINT    -1; $99
a040 56 a8       .word Basic_CONT     -1; $9A
a042 9b a6       .word Basic_LIST     -1; $9B
a044 5d a6       .word Basic_CLR      -1; $9C
a046 85 aa       .word Basic_CMD      -1; $9D
a048 29 e1       .word Basic_SYS      -1; $9E
a04a bd e1       .word Basic_OPEN     -1; $9F
a04c c6 e1       .word Basic_CLOSE    -1; $A0
a04e 7a ab       .word Basic_GET      -1; $A1
a050 41 a6       .word Basic_NEW      -1; $A2

              ; ********************
a052            Basic_Function_Table
              ; ********************

a052 39 bc       .word Basic_SGN   ; $B4
a054 cc bc       .word Basic_INT   ; $B5
a056 58 bc       .word Basic_ABS   ; $B6
a058 10 03       .word Basic_USR   ; $B7
a05a 7d b3       .word Basic_FRE   ; $B8
a05c 9e b3       .word Basic_POS   ; $B9
a05e 71 bf       .word Basic_SQR   ; $BA
a060 97 e0       .word Basic_RND   ; $BB
a062 ea b9       .word Basic_LOG   ; $BC
a064 ed bf       .word Basic_EXP   ; $BD
a066 64 e2       .word Basic_COS   ; $BE
a068 6b e2       .word Basic_SIN   ; $BF
a06a b4 e2       .word Basic_TAN   ; $C0
a06c 0e e3       .word Basic_ATN   ; $C1
a06e 0d b8       .word Basic_PEEK  ; $C2
a070 7c b7       .word Basic_LEN   ; $C3
a072 65 b4       .word Basic_STR   ; $C4
a074 ad b7       .word Basic_VAL   ; $C5
a076 8b b7       .word Basic_ASC   ; $C6
a078 ec b6       .word Basic_CHR   ; $C7
a07a 00 b7       .word Basic_LEFT  ; $C8
a07c 2c b7       .word Basic_RIGHT ; $C9
a07e 37 b7       .word Basic_MID   ; $CA

              ; ********************
a080            Basic_Operator_Table
              ; ********************

a080 79 69 b8    .byte $79,Basic_PLUS     -1 ; $AA
a083 79 52 b8    .byte $79,Basic_MINUS    -1 ; $AB
a086 7b 2a ba    .byte $7B,Basic_MULTIPLY -1 ; $AC
a089 7b 11 bb    .byte $7B,Basic_DIVIDE   -1 ; $AD
a08c 7f 7a bf    .byte $7F,Basic_POWER    -1 ; $AE
a08f 50 e8 af    .byte $50,Basic_AND      -1 ; $AF
a092 46 e5 af    .byte $46,Basic_OR       -1 ; $B0
a095 7d b3 bf    .byte $7D,Basic_GREATER  -1 ; $B1
a098 5a d3 ae    .byte $5A,Basic_EQUAL    -1 ; $B2
a09b 64 15 b0    .byte $64,Basic_LESS     -1 ; $B3

              ; *******************
a09e            Basic_Keyword_Table
              ; *******************

a09e 45 4e c4    .byte   "END"^    ; END
a0a1 46 4f d2    .byte   "FOR"^    ; FOR
a0a4 4e 45 58    .byte   "NEXT"^   ; NEXT
a0a8 44 41 54    .byte   "DATA"^   ; DATA
a0ac 49 4e 50    .byte   "INPUT#"^ ; INPUT#
a0b2 49 4e 50    .byte   "INPUT"^  ; INPUT
a0b7 44 49 cd    .byte   "DIM"^    ; DIM
a0ba 52 45 41    .byte   "READ"^   ; READ
a0be 4c 45 d4    .byte   "LET"^    ; LET
a0c1 47 4f 54    .byte   "GOTO"^   ; GOTO
a0c5 52 55 ce    .byte   "RUN"^    ; RUN
a0c8 49 c6       .byte   "IF"^     ; IF
a0ca 52 45 53    .byte   "RESTORE"^; RESTORE
a0d1 47 4f 53    .byte   "GOSUB"^  ; GOSUB
a0d6 52 45 54    .byte   "RETURN"^ ; RETURN
a0dc 52 45 cd    .byte   "REM"^    ; REM
a0df 53 54 4f    .byte   "STOP"^   ; STOP
a0e3 4f ce       .byte   "ON"^     ; ON
a0e5 57 41 49    .byte   "WAIT"^   ; WAIT
a0e9 4c 4f 41    .byte   "LOAD"^   ; LOAD
a0ed 53 41 56    .byte   "SAVE"^   ; SAVE
a0f1 56 45 52    .byte   "VERIFY"^ ; VERIFY
a0f7 44 45 c6    .byte   "DEF"^    ; DEF
a0fa 50 4f 4b    .byte   "POKE"^   ; POKE
a0fe 50 52 49    .byte   "PRINT#"^ ; PRINT#
a104 50 52 49    .byte   "PRINT"^  ; PRINT
a109 43 4f 4e    .byte   "CONT"^   ; CONT
a10d 4c 49 53    .byte   "LIST"^   ; LIST
a111 43 4c d2    .byte   "CLR"^    ; CLR
a114 43 4d c4    .byte   "CMD"^    ; CMD
a117 53 59 d3    .byte   "SYS"^    ; SYS
a11a 4f 50 45    .byte   "OPEN"^   ; OPEN
a11e 43 4c 4f    .byte   "CLOSE"^  ; CLOSE
a123 47 45 d4    .byte   "GET"^    ; GET
a126 4e 45 d7    .byte   "NEW"^    ; NEW

              ; next are the secondary command keywords, these can not start a statement

a129 54 41 42    .byte   "TAB("^   ; TAB(
a12d 54 cf       .byte   "TO"^     ; TO
a12f 46 ce       .byte   "FN"^     ; FN
a131 53 50 43    .byte   "SPC("^   ; SPC(
a135 54 48 45    .byte   "THEN"^   ; THEN
a139 4e 4f d4    .byte   "NOT"^    ; NOT
a13c 53 54 45    .byte   "STEP"^   ; STEP

              ; the operators

a140 ab          .byte   "+"^      ; +
a141 ad          .byte   "-"^      ; -
a142 aa          .byte   "*"^      ; *
a143 af          .byte   "/"^      ; /
a144 de          .byte   "^"^      ; ^
a145 41 4e c4    .byte   "AND"^    ; AND
a148 4f d2       .byte   "OR"^     ; OR
a14a be          .byte   ">"^      ; >
a14b bd          .byte   "="^      ; =
a14c bc          .byte   "<"^      ; <

              ; the functions

a14d 53 47 ce    .byte   "SGN"^    ; SGN
a150 49 4e d4    .byte   "INT"^    ; INT
a153 41 42 d3    .byte   "ABS"^    ; ABS
a156 55 53 d2    .byte   "USR"^    ; USR
a159 46 52 c5    .byte   "FRE"^    ; FRE
a15c 50 4f d3    .byte   "POS"^    ; POS
a15f 53 51 d2    .byte   "SQR"^    ; SQR
a162 52 4e c4    .byte   "RND"^    ; RND
a165 4c 4f c7    .byte   "LOG"^    ; LOG
a168 45 58 d0    .byte   "EXP"^    ; EXP
a16b 43 4f d3    .byte   "COS"^    ; COS
a16e 53 49 ce    .byte   "SIN"^    ; SIN
a171 54 41 ce    .byte   "TAN"^    ; TAN
a174 41 54 ce    .byte   "ATN"^    ; ATN
a177 50 45 45    .byte   "PEEK"^   ; PEEK
a17b 4c 45 ce    .byte   "LEN"^    ; LEN
a17e 53 54 52    .byte   "STR$"^   ; STR$
a182 56 41 cc    .byte   "VAL"^    ; VAL
a185 41 53 c3    .byte   "ASC"^    ; ASC
a188 43 48 52    .byte   "CHR$"^   ; CHR$
a18c 4c 45 46    .byte   "LEFT$"^  ; LEFT$
a191 52 49 47    .byte   "RIGHT$"^ ; RIGHT$
a197 4d 49 44    .byte   "MID$"^   ; MID$
a19b 47 cf       .byte   "GO"^     ; GO so that GO TO, as well as GOTO, will work
a19d 00          .byte   $00       ; end marker

              ; error messages

a19e 54 4f 4f ERR_01 .byte   "TOO MANY FILES"^
a1ac 46 49 4c ERR_02 .byte   "FILE OPEN"^
a1b5 46 49 4c ERR_03 .byte   "FILE NOT OPEN"^
a1c2 46 49 4c ERR_04 .byte   "FILE NOT FOUND"^
a1d0 44 45 56 ERR_05 .byte   "DEVICE NOT PRESENT"^
a1e2 4e 4f 54 ERR_06 .byte   "NOT INPUT FILE"^
a1f0 4e 4f 54 ERR_07 .byte   "NOT OUTPUT FILE"^
a1ff 4d 49 53 ERR_08 .byte   "MISSING FILE NAME"^
a210 49 4c 4c ERR_09 .byte   "ILLEGAL DEVICE NUMBER"^
a225 4e 45 58 ERR_0A .byte   "NEXT WITHOUT FOR"^
a235 53 59 4e ERR_0B .byte   "SYNTAX"^
a23b 52 45 54 ERR_0C .byte   "RETURN WITHOUT GOSUB"^
a24f 4f 55 54 ERR_0D .byte   "OUT OF DATA"^
a25a 49 4c 4c ERR_0E .byte   "ILLEGAL QUANTITY"^
a26a 4f 56 45 ERR_0F .byte   "OVERFLOW"^
a272 4f 55 54 ERR_10 .byte   "OUT OF MEMORY"^
a27f 55 4e 44 ERR_11 .byte   "UNDEF'D STATEMENT"^
a290 42 41 44 ERR_12 .byte   "BAD SUBSCRIPT"^
a29d 52 45 44 ERR_13 .byte   "REDIM'D ARRAY"^
a2aa 44 49 56 ERR_14 .byte   "DIVISION BY ZERO"^
a2ba 49 4c 4c ERR_15 .byte   "ILLEGAL DIRECT"^
a2c8 54 59 50 ERR_16 .byte   "TYPE MISMATCH"^
a2d5 53 54 52 ERR_17 .byte   "STRING TOO LONG"^
a2e4 46 49 4c ERR_18 .byte   "FILE DATA"^
a2ed 46 4f 52 ERR_19 .byte   "FORMULA TOO COMPLEX"^
a300 43 41 4e ERR_1A .byte   "CAN'T CONTINUE"^
a30e 55 4e 44 ERR_1B .byte   "UNDEF'D FUNCTION"^
a31e 56 45 52 ERR_1C .byte   "VERIFY"^
a324 4c 4f 41 ERR_1D .byte   "LOAD"^

              ; error message pointer table

a328          Basic_Msg_Tab
a328 9e a1       .word   ERR_01  ; TOO MANY FILES
a32a ac a1       .word   ERR_02  ; FILE OPEN
a32c b5 a1       .word   ERR_03  ; FILE NOT OPEN
a32e c2 a1       .word   ERR_04  ; FILE NOT FOUND
a330 d0 a1       .word   ERR_05  ; DEVICE NOT PRESENT
a332 e2 a1       .word   ERR_06  ; NOT INPUT FILE
a334 f0 a1       .word   ERR_07  ; NOT OUTPUT FILE
a336 ff a1       .word   ERR_08  ; MISSING FILE NAME
a338 10 a2       .word   ERR_09  ; ILLEGAL DEVICE NUMBER
a33a 25 a2       .word   ERR_0A  ; NEXT WITHOUT FOR
a33c 35 a2       .word   ERR_0B  ; SYNTAX
a33e 3b a2       .word   ERR_0C  ; RETURN WITHOUT GOSUB
a340 4f a2       .word   ERR_0D  ; OUT OF DATA
a342 5a a2       .word   ERR_0E  ; ILLEGAL QUANTITY
a344 6a a2       .word   ERR_0F  ; OVERFLOW
a346 72 a2       .word   ERR_10  ; OUT OF MEMORY
a348 7f a2       .word   ERR_11  ; UNDEF'D STATEMENT
a34a 90 a2       .word   ERR_12  ; BAD SUBSCRIPT
a34c 9d a2       .word   ERR_13  ; REDIM'D ARRAY
a34e aa a2       .word   ERR_14  ; DIVISION BY ZERO
a350 ba a2       .word   ERR_15  ; ILLEGAL DIRECT
a352 c8 a2       .word   ERR_16  ; TYPE MISMATCH
a354 d5 a2       .word   ERR_17  ; STRING TOO LONG
a356 e4 a2       .word   ERR_18  ; FILE DATA
a358 ed a2       .word   ERR_19  ; FORMULA TOO COMPLEX
a35a 00 a3       .word   ERR_1A  ; CAN'T CONTINUE
a35c 0e a3       .word   ERR_1B  ; UNDEF'D FUNCTION
a35e 1e a3       .word   ERR_1C  ; VERIFY
a360 24 a3       .word   ERR_1D  ; LOAD
a362 83 a3       .word   Msg_Break

              ; BASIC messages

a364 0d 4f 4b Msg_OK    .byte   "\rOK\r",0
0000 TRUE     #if C64
a369 20 20 45 Msg_Err   .byte   "  ERROR",0
              #endif
0001 FALSE    #if VIC
SKIP          Msg_Err   .byte   "\r ERROR",0
              #endif
a371 20 49 4e Msg_IN    .byte   " IN ",0
a376 0d 0a 52 Msg_Ready .byte   "\r\nREADY.\r\n",0
a381 0d 0a    Msg_CrLf  .byte   "\r\n"
a383 42 52 45 Msg_Break .byte   "BREAK",0

a389 a0          .byte $A0 ; unused

              ; ***************
a38a            Find_Active_FOR
              ; ***************

a38a ba          TSX               ; copy stack pointer
a38b e8          INX               ; +1 pass return address
a38c e8          INX               ; +2 pass return address
a38d e8          INX               ; +3 pass calling routine return address
a38e e8          INX               ; +4 pass calling routine return address

a38f          FAF_Loop
a38f bd 01 01    LDA STACK+1,X     ; get token byte from stack
a392 c9 81       CMP #TK_FOR       ; is it FOR token
a394 d0 21       BNE FAF_Ret       ; exit if not FOR token
a396 a5 4a       LDA FORPNT+1      ; get FOR/NEXT variable pointer high byte
a398 d0 0a       BNE FAF_10        ; branch if defined
a39a bd 02 01    LDA STACK+2,X     ; get FOR variable pointer low byte
a39d 85 49       STA FORPNT        ; save FOR/NEXT variable pointer low byte
a39f bd 03 01    LDA STACK+3,X     ; get FOR variable pointer high byte
a3a2 85 4a       STA FORPNT+1      ; save FOR/NEXT variable pointer high byte

a3a4          FAF_10
a3a4 dd 03 01    CMP STACK+3,X     ; compare variable pointer with stacked variable pointer
a3a7 d0 07       BNE FAF_20        ; branch if no match
a3a9 a5 49       LDA FORPNT        ; get FOR/NEXT variable pointer low byte
a3ab dd 02 01    CMP STACK+2,X     ; compare variable pointer with stacked variable pointer
a3ae f0 07       BEQ FAF_Ret       ; exit if match found

a3b0          FAF_20
a3b0 8a          TXA               ; copy index
a3b1 18          CLC
a3b2 69 12       ADC #18           ; add FOR stack use size
a3b4 aa          TAX               ; copy back to index
a3b5 d0 d8       BNE FAF_Loop

a3b7          FAF_Ret
a3b7 60          RTS ;Size   46 [Find_Active_FOR]

              ; *************
a3b8            Open_Up_Space
              ; *************

a3b8 20 08 a4    JSR Check_Mem_Avail
                 STAY(STREND)
a3bb 85 31       STA STREND
a3bd 84 32       STY STREND+1


              ; **********
a3bf            Move_Block
              ; **********

a3bf 38          SEC
a3c0 a5 5a       LDA TMPPTB        ; get block end low byte
a3c2 e5 5f       SBC TMPPTC        ; subtract block start low byte
a3c4 85 22       STA INDEXA        ; save MOD(block length/$100) byte
a3c6 a8          TAY               ; copy MOD(block length/$100) byte to Y
a3c7 a5 5b       LDA TMPPTB+1      ; get block end high byte
a3c9 e5 60       SBC TMPPTC+1      ; subtract block start high byte
a3cb aa          TAX               ; copy block length high byte to X
a3cc e8          INX               ; +1 to allow for count=0 exit
a3cd 98          TYA               ; copy block length low byte to A
a3ce f0 23       BEQ MoBl_20       ; branch if length low byte=0
a3d0 a5 5a       LDA TMPPTB        ; get block end low byte
a3d2 38          SEC
a3d3 e5 22       SBC INDEXA        ; subtract MOD(block length/$100) byte
a3d5 85 5a       STA TMPPTB        ; save corrected old block end low byte
a3d7 b0 03       BCS MoBl_10       ; if no underflow skip the high byte decrement
a3d9 c6 5b       DEC TMPPTB+1      ; else decrement block end high byte
a3db 38          SEC

a3dc          MoBl_10 
a3dc a5 58       LDA TMPPTA        ; get destination end low byte
a3de e5 22       SBC INDEXA        ; subtract MOD(block length/$100) byte
a3e0 85 58       STA TMPPTA        ; save modified new block end low byte
a3e2 b0 08       BCS MoBl_Loop_X   ; if no underflow skip the high byte decrement
a3e4 c6 59       DEC TMPPTA+1      ; else decrement block end high byte
a3e6 90 04       BCC MoBl_Loop_X   ; branch always

a3e8          MoBl_Loop_Y
a3e8 b1 5a       LDA (TMPPTB),Y    ; get byte from source
a3ea 91 58       STA (TMPPTA),Y    ; copy byte to destination

a3ec          MoBl_Loop_X
a3ec 88          DEY
a3ed d0 f9       BNE MoBl_Loop_Y
a3ef b1 5a       LDA (TMPPTB),Y    ; get byte from source
a3f1 91 58       STA (TMPPTA),Y    ; save byte to destination

a3f3          MoBl_20
a3f3 c6 5b       DEC TMPPTB+1      ; decrement source pointer high byte
a3f5 c6 59       DEC TMPPTA+1      ; decrement destination pointer high byte
a3f7 ca          DEX               ; decrement block count
a3f8 d0 f2       BNE MoBl_Loop_X   ; loop until count = $0
a3fa 60          RTS ;Size   60 [Move_Block]

              ; *****************
a3fb            Check_Stack_Avail
              ; *****************

a3fb 0a          ASL A
a3fc 69 3e       ADC #$3E          ; need at least $3E bytes free
a3fe b0 35       BCS Error_Out_Of_Memory
a400 85 22       STA INDEXA        ; save result in temp byte
a402 ba          TSX               ; copy stack
a403 e4 22       CPX INDEXA        ; compare new limit with stack
a405 90 2e       BCC Error_Out_Of_Memory
a407 60          RTS ;Size   13 [Check_Stack_Avail]

              ; ***************
a408            Check_Mem_Avail
              ; ***************

a408 c4 34       CPY FRESPC+1      ; compare with bottom of string space high byte
a40a 90 28       BCC CMA_Ret       ; if less then OK
a40c d0 04       BNE CMA_10        ; skip next test if greater (tested <)
a40e c5 33       CMP FRESPC        ; compare with bottom of string space low byte
a410 90 22       BCC CMA_Ret       ; if less then OK

a412          CMA_10               ; address is > string storage ptr
a412 48          PHA               ; push address low byte
a413 a2 09       LDX #9            ; set index to save 10 bytes (FACTPA & FACTPB)
a415 98          TYA               ; copy address high byte (to push on stack)

a416          CMA_Loop_X
a416 48          PHA               ; push byte
a417 b5 57       LDA FACTPA,X      ; get byte from FACTPA to TMPPTC+1
a419 ca          DEX
a41a 10 fa       BPL CMA_Loop_X
a41c 20 26 b5    JSR Garbage_Collection
a41f a2 f7       LDX #$F7          ; use zero page wrap around

a421          CMA_Loop_2
a421 68          PLA               ; pop byte
a422 95 61       STA FAC1EX,X      ; save byte from FACTPA to FAC1
a424 e8          INX               ; increment index
a425 30 fa       BMI CMA_Loop_2
a427 68          PLA               ; pop address high byte
a428 a8          TAY               ; copy back to Y
a429 68          PLA               ; pop address low byte
a42a c4 34       CPY FRESPC+1      ; compare with bottom of string space high byte
a42c 90 06       BCC CMA_Ret       ; if less then OK
a42e d0 05       BNE Error_Out_Of_Memory
a430 c5 33       CMP FRESPC
a432 b0 01       BCS Error_Out_Of_Memory

a434          CMA_Ret
a434 60          RTS ;Size   45 [Check_Mem_Avail]

              ; ===================
a435            Error_Out_Of_Memory
              ; ===================

a435 a2 10       LDX #$10          ; error code $10, out of memory error

              ; ===========
a437            Basic_Error
              ; ===========

a437 6c 00 03    JMP (IERROR)      ; normally next statement

              ; =============
a43a            Default_Error
              ; =============

a43a 8a          TXA               ; copy error number
a43b 0a          ASL A             ; *2
a43c aa          TAX               ; copy to index
a43d bd 26 a3    LDA Basic_Msg_Tab-2,X  ; get error message pointer low byte
a440 85 22       STA INDEXA        ; save it
a442 bd 27 a3    LDA Basic_Msg_Tab-1,X  ; get error message pointer high byte
a445 85 23       STA INDEXA+1      ; save it
a447 20 c6 ff    JSR CLRCHN        ; Clear I/O channels
a44a a9 00       LDA #0
a44c 85 13       STA IOPMPT        ; clear current I/O channel, flag default
a44e 20 d7 aa    JSR Print_CR
a451 20 45 ab    JSR Print_Question_Mark
a454 a0 00       LDY #0

a456          DeEr_Loop
a456 b1 22       LDA (INDEXA),Y    ; get byte from message
a458 48          PHA               ; save status
a459 29 7f       AND #$7F          ; mask 0xxx xxxx, clear b7
a45b 20 47 ab    JSR Print_Char
a45e c8          INY
a45f 68          PLA               ; restore status
a460 10 f4       BPL DeEr_Loop
a462 20 7a a6    JSR Flush_BASIC_Stack
                 LAYI(Msg_Err)
a465 a9 69       LDA #<Msg_Err
a467 a0 a3       LDY #>Msg_Err


              ; ======================
a469            Display_Msg_Then_Ready
              ; ======================

a469 20 1e ab    JSR Print_String
a46c a4 3a       LDY CURLIN+1      ; get current line number high byte
a46e c8          INY               ; increment it
a46f f0 03       BEQ Basic_Ready   ; CURLIN+1 was $FF = direct mode
a471 20 c2 bd    JSR Print_IN

              ; ===========
a474            Basic_Ready
              ; ===========

                 Print_Msg(Msg_Ready)
a474 a9 76       LDA #<Msg_Ready
a476 a0 a3       LDY #>Msg_Ready
a478 20 1e ab    JSR Print_String

a47b a9 80       LDA #$80          ; set for control messages only
a47d 20 8a ff    JSR SETMSG        ; control kernal messages

              ; ==================
a480            Vectored_Warmstart
              ; ==================

a480 6c 02 03    JMP (IMAIN)       ; normally next statement

              ; =================
a483            Default_Warmstart
              ; =================

a483 20 60 a5    JSR Read_String
                 STXY(TXTPTR)
a486 86 7a       STX TXTPTR
a488 84 7b       STY TXTPTR+1

a48a 20 73 00    JSR CHRGET
a48d aa          TAX               ; copy byte to set flags
a48e f0 f0       BEQ Vectored_Warmstart ; loop if no input

              ; got to interpret input line now ....

a490 a2 ff       LDX #-1           ; indicates direct mode
a492 86 3a       STX CURLIN+1
a494 90 06       BCC New_Basic_Line

a496          Direct_Call          ; used from Jiffy to identify caller
a496 20 79 a5    JSR Tokenize_Line
a499 4c e1 a7    JMP Start_Program

              ; --------------
a49c            New_Basic_Line
              ; --------------

a49c 20 6b a9    JSR Scan_Linenumber
a49f 20 79 a5    JSR Tokenize_Line
a4a2 84 0b       STY COUNT         ; save index pointer to end of crunched line
a4a4 20 13 a6    JSR Find_BASIC_Line
a4a7 90 44       BCC NBL_20        ; if not found skip the line delete

              ; line # already exists so delete it

a4a9 a0 01       LDY #1            ; set index to next line pointer high byte
a4ab b1 5f       LDA (TMPPTC),Y    ; get next line pointer high byte
a4ad 85 23       STA INDEXA+1      ; save it
a4af a5 2d       LDA VARTAB        ; get start of variables low byte
a4b1 85 22       STA INDEXA        ; save it
a4b3 a5 60       LDA TMPPTC+1      ; get found line pointer high byte
a4b5 85 25       STA INDEXB+1      ; save it
a4b7 a5 5f       LDA TMPPTC        ; get found line pointer low byte
a4b9 88          DEY               ; decrement index
a4ba f1 5f       SBC (TMPPTC),Y    ; subtract next line pointer low byte
a4bc 18          CLC
a4bd 65 2d       ADC VARTAB        ; add start of variables low byte
a4bf 85 2d       STA VARTAB        ; set start of variables low byte
a4c1 85 24       STA INDEXB        ; save destination pointer low byte
a4c3 a5 2e       LDA VARTAB+1      ; get start of variables high byte
a4c5 69 ff       ADC #$FF          ; -1 + carry
a4c7 85 2e       STA VARTAB+1      ; set start of variables high byte
a4c9 e5 60       SBC TMPPTC+1      ; subtract found line pointer high byte
a4cb aa          TAX               ; copy to block count
a4cc 38          SEC
a4cd a5 5f       LDA TMPPTC        ; get found line pointer low byte
a4cf e5 2d       SBC VARTAB        ; subtract start of variables low byte
a4d1 a8          TAY               ; copy to bytes in first block count
a4d2 b0 03       BCS NBL_10        ; if no underflow skip the high byte decrement
a4d4 e8          INX               ; increment block count, correct for = 0 loop exit
a4d5 c6 25       DEC INDEXB+1      ; decrement destination high byte

a4d7          NBL_10
a4d7 18          CLC
a4d8 65 22       ADC INDEXA        ; add source pointer low byte
a4da 90 03       BCC NBL_Loop      ; if no underflow skip the high byte decrement
a4dc c6 23       DEC INDEXA+1      ; else decrement source pointer high byte
a4de 18          CLC

a4df          NBL_Loop
a4df b1 22       LDA (INDEXA),Y    ; get byte from source
a4e1 91 24       STA (INDEXB),Y    ; copy to destination
a4e3 c8          INY
a4e4 d0 f9       BNE NBL_Loop      ; while <> 0 do this block
a4e6 e6 23       INC INDEXA+1      ; increment source pointer high byte
a4e8 e6 25       INC INDEXB+1      ; increment destination pointer high byte
a4ea ca          DEX               ; decrement block count
a4eb d0 f2       BNE NBL_Loop      ; loop until all done

a4ed          NBL_20
a4ed 20 59 a6    JSR Reset_BASIC_Execution
a4f0 20 33 a5    JSR Rechain
a4f3 ad 00 02    LDA BUF           ; get first byte from buffer
a4f6 f0 88       BEQ Vectored_Warmstart
a4f8 18          CLC               ; insert line into memory
a4f9 a5 2d       LDA VARTAB        ; get start of variables low byte
a4fb 85 5a       STA TMPPTB        ; save as source end pointer low byte
a4fd 65 0b       ADC COUNT         ; add index pointer to end of crunched line
a4ff 85 58       STA TMPPTA        ; save as destination end pointer low byte
a501 a4 2e       LDY VARTAB+1      ; get start of variables high byte
a503 84 5b       STY TMPPTB+1      ; save as source end pointer high byte
a505 90 01       BCC NBL_30      ; if no carry skip the high byte increment
a507 c8          INY               ; else increment the high byte
a508          NBL_30
a508 84 59       STY TMPPTA+1      ; save as destination end pointer high byte
a50a 20 b8 a3    JSR Open_Up_Space

              ; most of what remains to do is copy the crunched line into the space opened up in memory,
              ; however, before the crunched line comes the next line pointer and the line number. the
              ; line number is retrieved from the temporary integer and stored in memory, this
              ; overwrites the bottom two bytes on the stack. next the line is copied and the next line
              ; pointer is filled with whatever was in two bytes above the line number in the stack.
              ; this is ok because the line pointer gets fixed in the line chain re-build.

                 LDAY(LINNUM)      ; get line number
a50d a5 14       LDA LINNUM
a50f a4 15       LDY LINNUM+1

a511 8d fe 01    STA BUF-2         ; save line number low byte before crunched line
a514 8c ff 01    STY BUF-1         ; save line number high byte before crunched line
                 LDAY(STREND)      ; get end of arrays
a517 a5 31       LDA STREND
a519 a4 32       LDY STREND+1

                 STAY(VARTAB)      ; set start of variables
a51b 85 2d       STA VARTAB
a51d 84 2e       STY VARTAB+1

a51f a4 0b       LDY COUNT         ; get index to end of crunched line
a521 88          DEY               ; -1
a522          NBL_Copy
a522 b9 fc 01    LDA BUF-4,Y       ; get byte from crunched line
a525 91 5f       STA (TMPPTC),Y    ; save byte to memory
a527 88          DEY               ; decrement index
a528 10 f8       BPL NBL_Copy      ; loop while more to do

              ; =================
a52a            Reset_And_Rechain
              ; =================

a52a 20 59 a6    JSR Reset_BASIC_Execution
a52d 20 33 a5    JSR Rechain
a530 4c 80 a4    JMP Vectored_Warmstart

              ; *******
a533            Rechain
              ; *******

                 LDAY(TXTTAB)      ; get start of memory
a533 a5 2b       LDA TXTTAB
a535 a4 2c       LDY TXTTAB+1

                 STAY(INDEXA)      ; set line start pointer
a537 85 22       STA INDEXA
a539 84 23       STY INDEXA+1

a53b 18          CLC

a53c          Rech_Loop
a53c a0 01       LDY #1            ; set index to pointer to next line high byte
a53e b1 22       LDA (INDEXA),Y    ; get pointer to next line high byte
a540 f0 1d       BEQ Rech_Ret      ; exit if null, [EOT]
a542 a0 04       LDY #4            ; point to first code byte of line
                                   ; there is always 1 byte + [EOL] as null entries are deleted
a544          Rech_Loop_2
a544 c8          INY               ; next code byte
a545 b1 22       LDA (INDEXA),Y    ; get byte
a547 d0 fb       BNE Rech_Loop_2   ; loop if not [EOL]
a549 c8          INY               ; point to byte past [EOL], start of next line
a54a 98          TYA               ; copy it
a54b 65 22       ADC INDEXA        ; add line start pointer low byte
a54d aa          TAX               ; copy to X
a54e a0 00       LDY #0            ; point to this line's next line pointer
a550 91 22       STA (INDEXA),Y    ; set next line pointer low byte
a552 a5 23       LDA INDEXA+1      ; get line start pointer high byte
a554 69 00       ADC #$00          ; add any overflow
a556 c8          INY
a557 91 22       STA (INDEXA),Y    ; set next line pointer high byte
a559 86 22       STX INDEXA        ; set line start pointer low byte
a55b 85 23       STA INDEXA+1      ; set line start pointer high byte
a55d 90 dd       BCC Rech_Loop     ; branch always

a55f          Rech_Ret
a55f 60          RTS ;Size   45 [Rechain]

              ; ***********
a560            Read_String
              ; ***********

a560 a2 00       LDX #0            ; set channel 0, keyboard

a562          ReSt_Loop
a562 20 12 e1    JSR Read_Char
a565 c9 0d       CMP #CR
a567 f0 0d       BEQ ReSt_Finish
a569 9d 00 02    STA BUF,X
a56c e8          INX
a56d e0 59       CPX #$59          ; compare with max+1
a56f 90 f1       BCC ReSt_Loop
a571 a2 17       LDX #$17          ; error $17, string too long error
a573 4c 37 a4    JMP Basic_Error

a576          ReSt_Finish
a576 4c ca aa    JMP Terminate_BUF      ; set XY to BUF - 1 and print [CR]

              ; *************
a579            Tokenize_Line
              ; *************

a579 6c 04 03    JMP (ICRNCH)      ; normally next statement

              ; ****************
a57c            Default_Tokenize
              ; ****************

a57c a6 7a       LDX TXTPTR        ; get BASIC execute pointer low byte
a57e a0 04       LDY #4 
a580 84 0f       STY GARBFL        ; clear open quote/DATA flag

a582          Toke_Loop
a582 bd 00 02    LDA BUF,X
a585 10 07       BPL Toke_05       ; plain text
a587 c9 ff       CMP #TK_PI
a589 f0 3e       BEQ Toke_35       ; if PI save & continue
a58b e8          INX               ; next char
a58c d0 f4       BNE Toke_Loop     ; branch always

a58e          Toke_05
a58e c9 20       CMP #' '
a590 f0 37       BEQ Toke_35       ; if [SPACE] save & continue
a592 85 08       STA ENDCHR        ; save buffer byte as search character
a594 c9 22       CMP #QUOTE
a596 f0 56       BEQ Toke_55       ; if quote go copy quoted string
a598 24 0f       BIT GARBFL        ; get open quote/DATA token flag
a59a 70 2d       BVS Toke_35       ; branch if b6 of Oquote set, was DATA
a59c c9 3f       CMP #'?'          ; compare with '?' character
a59e d0 04       BNE Toke_10       ; if not "?" continue crunching
a5a0 a9 99       LDA #TK_PRINT     ; replace '?' by the token for PRINT
a5a2 d0 25       BNE Toke_35       ; branch always

a5a4          Toke_10
a5a4 c9 30       CMP #'0'          ; compare with "0"
a5a6 90 04       BCC Toke_15       ; if < "0" continue crunching
a5a8 c9 3c       CMP #'<'          ; compare with "<"
a5aa 90 1d       BCC Toke_35       ; if <, 0123456789:; save & continue

a5ac          Toke_15
a5ac 84 71       STY TMPPTD        ; copy save index
a5ae a0 00       LDY #0            ; clear table pointer
a5b0 84 0b       STY COUNT         ; clear word index
a5b2 88          DEY               ; Y = $FF
a5b3 86 7a       STX TXTPTR        ; save BASIC execute pointer low byte, buffer index
a5b5 ca          DEX               ; adjust for pre increment loop

a5b6          Toke_20
a5b6 c8          INY               ; next table byte
a5b7 e8          INX               ; next buffer byte

a5b8          Toke_25
a5b8 bd 00 02    LDA BUF,X         ; get byte from input buffer
a5bb 38          SEC
a5bc f9 9e a0    SBC Basic_Keyword_Table,Y
a5bf f0 f5       BEQ Toke_20       ; match so far
a5c1 c9 80       CMP #$80          ; was it end marker match ?
a5c3 d0 30       BNE Toke_60       ; if not go try the next keyword
a5c5 05 0b       ORA COUNT         ; OR with word index, +$80 in A makes token

a5c7          Toke_30
a5c7 a4 71       LDY TMPPTD        ; restore save index

a5c9          Toke_35
a5c9 e8          INX               ; increment buffer read index
a5ca c8          INY               ; increment save index
a5cb 99 fb 01    STA BUF-5,Y       ; save byte to output
a5ce b9 fb 01    LDA BUF-5,Y       ; get byte from output, set flags
a5d1 f0 36       BEQ Toke_70       ; branch if was null [EOL]
a5d3 38          SEC
a5d4 e9 3a       SBC #':'          ; subtract ":"
a5d6 f0 04       BEQ Toke_40       ; branch if it was (A is now 0)
a5d8 c9 49       CMP #TK_DATA-':'  ; compare with the token for DATA-':'
a5da d0 02       BNE Toke_45       ; if not DATA go try REM

a5dc          Toke_40
a5dc 85 0f       STA GARBFL        ; save token-':'

a5de          Toke_45
a5de 38          SEC
a5df e9 55       SBC #TK_REM-':'   ; subtract the token for REM-':'
a5e1 d0 9f       BNE Toke_Loop     ; if wasn't REM go crunch next bit of line

a5e3          Toke_REM             ; target from Jiffy tokenizer
a5e3 85 08       STA ENDCHR        ; else was REM so set search for [EOL]

a5e5          Toke_50
a5e5 bd 00 02    LDA BUF,X         ; get byte from input buffer
a5e8 f0 df       BEQ Toke_35       ; if null [EOL] save byte then continue crunching
a5ea c5 08       CMP ENDCHR        ; compare with stored character
a5ec f0 db       BEQ Toke_35       ; if match save byte then continue crunching

a5ee          Toke_55
a5ee c8          INY               ; increment save index
a5ef 99 fb 01    STA BUF-5,Y       ; save byte to output
a5f2 e8          INX               ; increment buffer index
a5f3 d0 f0       BNE Toke_50       ; branch always

a5f5          Toke_60
a5f5 a6 7a       LDX TXTPTR        ; restore BASIC execute pointer low byte
a5f7 e6 0b       INC COUNT         ; increment word index (next word)

a5f9          Toke_65
a5f9 c8          INY               ; increment table index
a5fa b9 9d a0    LDA Basic_Keyword_Table-1,Y; get table byte
a5fd 10 fa       BPL Toke_65       ; loop if not end of word yet
a5ff b9 9e a0    LDA Basic_Keyword_Table,Y  ; get byte from keyword table
a602 d0 b4       BNE Toke_25       ; go test next word if not zero byte, end of table
a604 bd 00 02    LDA BUF,X         ; restore byte from input buffer
a607 10 be       BPL Toke_30       ; branch always, all unmatched bytes in the buffer are

a609          Toke_70
a609 99 fd 01    STA BUF-3,Y       ; save [EOL]
a60c c6 7b       DEC TXTPTR+1      ; decrement BASIC execute pointer high byte
a60e a9 ff       LDA #$FF          ; point to start of buffer-1
a610 85 7a       STA TXTPTR        ; set BASIC execute pointer low byte
a612 60          RTS ;Size  151 [Default_Tokenize]

              ; ***************
a613            Find_BASIC_Line
              ; ***************

                 LDAX(TXTTAB)      ; get start of memory
a613 a5 2b       LDA TXTTAB
a615 a6 2c       LDX TXTTAB+1


              ; ******************
a617            Find_BASIC_Line_AX
              ; ******************

a617 a0 01       LDY #1            ; set Y to next line link high byte
                 STAX(TMPPTC)      ; save as current
a619 85 5f       STA TMPPTC
a61b 86 60       STX TMPPTC+1

a61d b1 5f       LDA (TMPPTC),Y    ; get line link high byte
a61f f0 1f       BEQ FiBL_Not_Found; 0 = end of program
a621 c8          INY               ; Y = 2
a622 c8          INY               ; Y = 3
a623 a5 15       LDA LINNUM+1      ; target line # high byte
a625 d1 5f       CMP (TMPPTC),Y    ; compare with line # high byte
a627 90 18       BCC FiBL_Ret      ; beyond target line
a629 f0 03       BEQ FiBL_Check    ; go check low byte if =
a62b 88          DEY               ; Y = 2
a62c d0 09       BNE FiBL_Cont     ; branch always

a62e          FiBL_Check
a62e a5 14       LDA LINNUM        ; get target line # low byte
a630 88          DEY               ; Y = 2
a631 d1 5f       CMP (TMPPTC),Y    ; compare with line # low byte
a633 90 0c       BCC FiBL_Ret      ; beyond target line
a635 f0 0a       BEQ FiBL_Ret      ; target line found: exit

a637          FiBL_Cont
a637 88          DEY               ; Y = 1
a638 b1 5f       LDA (TMPPTC),Y    ; get next line link high byte
a63a aa          TAX               ; copy to X
a63b 88          DEY               ; Y = 0
a63c b1 5f       LDA (TMPPTC),Y    ; get next line link low byte
a63e b0 d7       BCS Find_BASIC_Line_AX ; branch always

a640          FiBL_Not_Found
a640 18          CLC               ; clear found flag
a641          FiBL_Ret
a641 60          RTS ;Size   43 [Find_BASIC_Line_AX]

              ; *********
a642            Basic_NEW
              ; *********

a642 d0 fd       BNE FiBL_Ret      ; exit if following byte to allow syntax error

              ; ===========
a644            Perform_NEW
              ; ===========

a644 a9 00       LDA #0
a646 a8          TAY               ; clear index
a647 91 2b       STA (TXTTAB),Y    ; clear pointer to next line low byte
a649 c8          INY
a64a 91 2b       STA (TXTTAB),Y    ; clear pointer to next line high byte, erase program
a64c a5 2b       LDA TXTTAB        ; get start of memory low byte
a64e 18          CLC
a64f 69 02       ADC #2            ; add null program length
a651 85 2d       STA VARTAB        ; set start of variables low byte
a653 a5 2c       LDA TXTTAB+1      ; get start of memory high byte
a655 69 00       ADC #0            ; add carry
a657 85 2e       STA VARTAB+1      ; set start of variables high byte

              ; *********************
a659            Reset_BASIC_Execution
              ; *********************

a659 20 8e a6    JSR Reset_BASIC_Exec_Pointer
a65c a9 00       LDA #$00          ; set Zb for CLR entry

              ; *********
a65e            Basic_CLR
              ; *********

a65e d0 2d       BNE Flush_Ret      ; exit if following byte to allow syntax error

              ; ********************
a660            Clear_Variable_Space
              ; ********************

a660 20 e1 ff    JSR CLALL         ; close all channels and files

              ; ======================
a663            Reset_Variable_Pointer
              ; ======================

                 LDAY(MEMSIZ)
a663 a5 37       LDA MEMSIZ
a665 a4 38       LDY MEMSIZ+1

                 STAY(FRESPC)
a667 85 33       STA FRESPC
a669 84 34       STY FRESPC+1

                 LDAY(VARTAB)
a66b a5 2d       LDA VARTAB
a66d a4 2e       LDY VARTAB+1

                 STAY(ARYTAB)
a66f 85 2f       STA ARYTAB
a671 84 30       STY ARYTAB+1

                 STAY(STREND)
a673 85 31       STA STREND
a675 84 32       STY STREND+1


              ; =======================
a677            Restore_And_Flush_Stack
              ; =======================

a677 20 1d a8    JSR Basic_RESTORE ; perform RESTORE

              ; *****************
a67a            Flush_BASIC_Stack
              ; *****************

a67a a2 19       LDX #TEMPST       ; get descriptor stack start
a67c 86 16       STX TEMPPT        ; set descriptor stack pointer
a67e 68          PLA               ; pull return address low byte
a67f a8          TAY               ; copy it
a680 68          PLA               ; pull return address high byte
a681 a2 fa       LDX #$FA          ; set cleared stack pointer
a683 9a          TXS               ; set stack
a684 48          PHA               ; push return address high byte
a685 98          TYA               ; restore return address low byte
a686 48          PHA               ; push return address low byte
a687 a9 00       LDA #0
a689 85 3e       STA OLDTXT+1      ; clear continue pointer high byte
a68b 85 10       STA SUBFLG        ; clear subscript/FNX flag

a68d          Flush_Ret
a68d 60          RTS ;Size   20 [Flush_BASIC_Stack]

              ; ************************
a68e            Reset_BASIC_Exec_Pointer
              ; ************************

a68e 18          CLC
a68f a5 2b       LDA TXTTAB        ; get start of memory low byte
a691 69 ff       ADC #$FF          ; add -1 low byte
a693 85 7a       STA TXTPTR        ; set BASIC execute pointer low byte
a695 a5 2c       LDA TXTTAB+1      ; get start of memory high byte
a697 69 ff       ADC #$FF          ; add -1 high byte
a699 85 7b       STA TXTPTR+1      ; save BASIC execute pointer high byte
a69b 60          RTS ;Size   14 [Reset_BASIC_Exec_Pointer]

              ; **********
a69c            Basic_LIST
              ; **********

a69c 90 06       BCC LIST_05       ; branch if next character not token (LIST n...)
a69e f0 04       BEQ LIST_05       ; branch if next character [NULL] (LIST)
a6a0 c9 ab       CMP #TK_MINUS     ; the only token allowed here (LIST -m)
a6a2 d0 e9       BNE Flush_Ret

a6a4          LIST_05
a6a4 20 6b a9    JSR Scan_Linenumber
a6a7 20 13 a6    JSR Find_BASIC_Line
a6aa 20 79 00    JSR CHRGOT
a6ad f0 0c       BEQ LIST_10       ; branch if no more chrs
a6af c9 ab       CMP #TK_MINUS     ; compare with "-"
a6b1 d0 8e       BNE FiBL_Ret      ; return if not "-" (will be SN error)
a6b3 20 73 00    JSR CHRGET        ; LIST [n]-m
a6b6 20 6b a9    JSR Scan_Linenumber
a6b9 d0 86       BNE FiBL_Ret      ; exit if not ok

a6bb          LIST_10
a6bb 68          PLA               ; dump return address low byte, exit via warm start
a6bc 68          PLA               ; dump return address high byte
a6bd a5 14       LDA LINNUM        ; get temporary integer low byte
a6bf 05 15       ORA LINNUM+1      ; OR temporary integer high byte
a6c1 d0 06       BNE LIST_15       ; branch if start set

a6c3          LIST_12              ; entry for Jiffy Basic file list
a6c3 a9 ff       LDA #$FF          ; set last line to $FFFF if not specified
a6c5 85 14       STA LINNUM
a6c7 85 15       STA LINNUM+1

a6c9          LIST_15
a6c9 a0 01       LDY #1
a6cb 84 0f       STY GARBFL        ; clear open quote flag
a6cd b1 5f       LDA (TMPPTC),Y    ; get next line pointer high byte
a6cf f0 43       BEQ LIST_45       ; if null all done so exit
a6d1 20 2c a8    JSR Check_STOP

a6d4          LIST_17              ; entry for Jiffy Basic file list
a6d4 20 d7 aa    JSR Print_CR
a6d7 c8          INY
a6d8 b1 5f       LDA (TMPPTC),Y    ; get line number low byte
a6da aa          TAX
a6db c8          INY
a6dc b1 5f       LDA (TMPPTC),Y    ; get line number high byte
a6de c5 15       CMP LINNUM+1      ; compare with temporary integer high byte
a6e0 d0 04       BNE LIST_20       ; branch if no high byte match
a6e2 e4 14       CPX LINNUM        ; compare with temporary integer low byte
a6e4 f0 02       BEQ LIST_25       ; branch if = last line to do, < will pass next branch

a6e6          LIST_20              ; else ...
a6e6 b0 2c       BCS LIST_45       ; if greater all done so exit

a6e8          LIST_25
a6e8 84 49       STY FORPNT        ; save index for line
a6ea 20 cd bd    JSR Print_Integer_XA
a6ed a9 20       LDA #' '          ; print [SPACE] after line #

a6ef          LIST_30
a6ef a4 49       LDY FORPNT        ; get index for line
a6f1 29 7f       AND #$7F          ; mask top out bit of character

a6f3          LIST_35
a6f3 20 47 ab    JSR Print_Char
a6f6 c9 22       CMP #QUOTE
a6f8 d0 06       BNE LIST_40       ; if not skip the quote handle
a6fa a5 0f       LDA GARBFL        ; get open quote flag
a6fc 49 ff       EOR #$FF          ; toggle it
a6fe 85 0f       STA GARBFL        ; save it back

a700          LIST_40
a700 c8          INY
a701 f0 11       BEQ LIST_45       ; line too long so just bail out and do a warm start
a703 b1 5f       LDA (TMPPTC),Y    ; get next byte
a705 d0 10       BNE Vectored_Detokenize      ; if not [EOL] (go print character)
a707 a8          TAY               ; else clear index
a708 b1 5f       LDA (TMPPTC),Y    ; get next line pointer low byte
a70a aa          TAX               ; copy to X
a70b c8          INY
a70c b1 5f       LDA (TMPPTC),Y    ; get next line pointer high byte
a70e 86 5f       STX TMPPTC        ; set pointer to line low byte
a710 85 60       STA TMPPTC+1      ; set pointer to line high byte
a712 d0 b5       BNE LIST_15       ; go do next line if not [EOT]

a714          LIST_45

0000 TRUE     #if C64
a714 4c 86 e3    JMP Vectored_Basic_Ready
              #endif

0001 FALSE    #if VIC
SKIP             JMP Basic_Ready
              #endif

              ; *******************
a717            Vectored_Detokenize
              ; *******************

a717 6c 06 03    JMP (IQPLOP)      ; normally next statement

              ; ******************
a71a            Default_Detokenize
              ; ******************

a71a 10 d7       BPL LIST_35       ; print it if not token byte
a71c c9 ff       CMP #TK_PI        ; compare with the token for PI
a71e f0 d3       BEQ LIST_35       ; just print it if so
a720 24 0f       BIT GARBFL        ; test the open quote flag
a722 30 cf       BMI LIST_35       ; just go print character if open quote set
a724 38          SEC               ; else set carry for subtract
a725 e9 7f       SBC #$7F          ; convert token to inex
a727 aa          TAX               ; copy token # to X
a728 84 49       STY FORPNT        ; save Y
a72a a0 ff       LDY #$FF          ; start from -1, adjust for pre increment

a72c          DeTo_10
a72c ca          DEX               ; decrement token #
a72d f0 08       BEQ DeTo_30       ; if not found go do printing

a72f          DeTo_20
a72f c8          INY
a730 b9 9e a0    LDA Basic_Keyword_Table,Y
a733 10 fa       BPL DeTo_20      ; loop until keyword end marker
a735 30 f5       BMI DeTo_10      ; branch always

a737          DeTo_30
a737 c8          INY
a738 b9 9e a0    LDA Basic_Keyword_Table,Y
a73b 30 b2       BMI LIST_30       ; go restore index, mask byte and print
a73d 20 47 ab    JSR Print_Char
a740 d0 f5       BNE DeTo_30       ; go get next character, branch always

              ; *********
a742            Basic_FOR
              ; *********

a742 a9 80       LDA #$80
a744 85 10       STA SUBFLG        ; set FNX flag
a746 20 a5 a9    JSR Basic_LET
a749 20 8a a3    JSR Find_Active_FOR
a74c d0 05       BNE BaFO_10       ; branch if this FOR variable was not found
a74e 8a          TXA               ; dump the old one
a74f 69 0f       ADC #15           ; add FOR structure size-2
a751 aa          TAX               ; copy to index
a752 9a          TXS               ; set stack (dump FOR structure (-2 bytes))

a753          BaFO_10
a753 68          PLA               ; pull return address
a754 68          PLA               ; pull return address
a755 a9 09       LDA #$09          ; we need 18d bytes !
a757 20 fb a3    JSR Check_Stack_Avail
a75a 20 06 a9    JSR Next_Statement
a75d 18          CLC
a75e 98          TYA               ; copy index to A
a75f 65 7a       ADC TXTPTR        ; add BASIC execute pointer low byte
a761 48          PHA               ; push onto stack
a762 a5 7b       LDA TXTPTR+1      ; get BASIC execute pointer high byte
a764 69 00       ADC #$00          ; add carry
a766 48          PHA               ; push onto stack
                 PUSHW(CURLIN)     ; push current line number
a767 a5 3a       LDA CURLIN+1
a769 48          PHA
a76a a5 39       LDA CURLIN
a76c 48          PHA

a76d a9 a4       LDA #TK_TO        ; set "TO" token
a76f 20 ff ae    JSR Need_A
a772 20 8d ad    JSR Is_Numeric
a775 20 8a ad    JSR Eval_Numeric
a778 a5 66       LDA FAC1SI        ; get FAC1 sign (b7)
a77a 09 7f       ORA #$7F          ; set all non sign bits
a77c 25 62       AND FAC1M1        ; and FAC1 mantissa 1
a77e 85 62       STA FAC1M1        ; save FAC1 mantissa 1
                 LAYI(BaFO_20)
a780 a9 8b       LDA #<BaFO_20
a782 a0 a7       LDY #>BaFO_20

                 STAY(INDEXA)      ; the following jump returns to this address
a784 85 22       STA INDEXA
a786 84 23       STY INDEXA+1

a788 4c 43 ae    JMP Round_And_Push_FAC1

a78b          BaFO_20
                 LAYI(REAL_1)      ; default STEP value = 1.0
a78b a9 bc       LDA #<REAL_1
a78d a0 b9       LDY #>REAL_1

a78f 20 a2 bb    JSR Load_FAC1_AY
a792 20 79 00    JSR CHRGOT
a795 c9 a9       CMP #TK_STEP
a797 d0 06       BNE BaFO_30
a799 20 73 00    JSR CHRGET
a79c 20 8a ad    JSR Eval_Numeric  ; Get STEP value

a79f          BaFO_30
a79f 20 2b bc    JSR Get_FAC1_Sign
a7a2 20 38 ae    JSR Push_FAC1
                 PUSHW(FORPNT)     ; push FOR variable on stack
a7a5 a5 4a       LDA FORPNT+1
a7a7 48          PHA
a7a8 a5 49       LDA FORPNT
a7aa 48          PHA

a7ab a9 81       LDA #TK_FOR       ; push FOR token
a7ad 48          PHA

              ; ================
a7ae            Interpreter_Loop
              ; ================

a7ae 20 2c a8    JSR Check_STOP
                 LDAY(TXTPTR)      ; get BASIC execute pointer
a7b1 a5 7a       LDA TXTPTR
a7b3 a4 7b       LDY TXTPTR+1

a7b5 c0 02       CPY #>BUF         ; direct mode ?
a7b7 ea          NOP               ; unused byte
a7b8 f0 04       BEQ InLo_10       ; in direct mode skip the continue pointer save
                 STAY(OLDTXT)      ; save the continue pointer
a7ba 85 3d       STA OLDTXT
a7bc 84 3e       STY OLDTXT+1


a7be          InLo_10
a7be a0 00       LDY #0
a7c0 b1 7a       LDA (TXTPTR),Y    ; get BASIC byte
a7c2 d0 43       BNE Inte_20      ; if not [EOL] go test for ":"
a7c4 a0 02       LDY #2
a7c6 b1 7a       LDA (TXTPTR),Y    ; get next line pointer high byte
a7c8 18          CLC
a7c9 d0 03       BNE InLo_20       ; branch if not end of program
a7cb 4c 4b a8    JMP End_Of_Exec

a7ce          InLo_20
a7ce c8          INY
a7cf b1 7a       LDA (TXTPTR),Y    ; get line number low byte
a7d1 85 39       STA CURLIN        ; save current line number low byte
a7d3 c8          INY
a7d4 b1 7a       LDA (TXTPTR),Y    ; get line # high byte
a7d6 85 3a       STA CURLIN+1      ; save current line number high byte
a7d8 98          TYA               ; A now = 4
a7d9 65 7a       ADC TXTPTR        ; add BASIC execute pointer low byte, now points to code
a7db 85 7a       STA TXTPTR        ; save BASIC execute pointer low byte
a7dd 90 02       BCC Start_Program      ; if no overflow skip the high byte increment
a7df e6 7b       INC TXTPTR+1      ; else increment BASIC execute pointer high byte

              ; =============
a7e1            Start_Program
              ; =============

a7e1 6c 08 03    JMP (IGONE)       ; normally following code

              ; =============
a7e4            Default_Start
              ; =============

a7e4 20 73 00    JSR CHRGET
a7e7 20 ed a7    JSR Interpret
a7ea 4c ae a7    JMP Interpreter_Loop

              ; *********
a7ed            Interpret
              ; *********

a7ed f0 3c       BEQ BaRE_Ret      ; if the first byte is null just exit

a7ef            Interpret_10
              ; ------------
a7ef e9 80       SBC #$80          ; normalise the token
a7f1 90 11       BCC Inte_10       ; if wasn't token go do LET
a7f3 c9 23       CMP #TK_TAB-$80   ; compare with token for TAB(-$80
a7f5 b0 17       BCS Inte_40       ; branch if >= TAB(
a7f7 0a          ASL A             ; *2 bytes per vector
a7f8 a8          TAY               ; copy to index
a7f9 b9 0d a0    LDA Basic_Statement_Table+1,Y; get vector high byte
a7fc 48          PHA               ; push on stack
a7fd b9 0c a0    LDA Basic_Statement_Table,Y  ; get vector low byte
a800 48          PHA               ; push on stack
a801 4c 73 00    JMP CHRGET        ; the return from CHRGET calls the command code

a804          Inte_10
a804 4c a5 a9    JMP Basic_LET     ; perform LET

a807          Inte_20
a807 c9 3a       CMP #':'          ; comapre with ":"
a809 f0 d6       BEQ Start_Program ; if ":" go execute new code

a80b          Inte_30
a80b 4c 08 af    JMP Syntax_Error

a80e          Inte_40
a80e c9 4b       CMP #TK_GO-$80    ; compare with token for GO
a810 d0 f9       BNE Inte_30       ; if not "GO" do syntax error then warm start
a812 20 73 00    JSR CHRGET
a815 a9 a4       LDA #TK_TO        ; set "TO" token
a817 20 ff ae    JSR Need_A
a81a 4c a0 a8    JMP Basic_GOTO    ; perform GOTO

              ; *************
a81d            Basic_RESTORE
              ; *************

a81d 38          SEC
a81e a5 2b       LDA TXTTAB        ; get start of memory low byte
a820 e9 01       SBC #$01          ; -1
a822 a4 2c       LDY TXTTAB+1      ; get start of memory high byte
a824 b0 01       BCS Store_DATPTR
a826 88          DEY               ; else decrement high byte

a827          Store_DATPTR
                 STAY(DATPTR)
a827 85 41       STA DATPTR
a829 84 42       STY DATPTR+1


a82b          BaRE_Ret
a82b 60          RTS ;Size   15 [Basic_RESTORE]

              ; **********
a82c            Check_STOP
              ; **********

a82c 20 db ff    JSR STOP          ; Check if stop key is pressed

              ; **********
a82f            Basic_STOP
              ; **********

a82f b0 01       BCS BaEN_10       ; if carry set do BREAK instead of just END

              ; *********
a831            Basic_END
              ; *********

a831 18          CLC

a832          BaEN_10
a832 d0 3c       BNE BaCO_Ret      ; return if wasn't CTRL-C
                 LDAY(TXTPTR)      ; get BASIC execute pointer
a834 a5 7a       LDA TXTPTR
a836 a4 7b       LDY TXTPTR+1

a838 a6 3a       LDX CURLIN+1      ; get current line number high byte
a83a e8          INX               ; increment it
a83b f0 0c       BEQ BaEN_20       ; branch if was direct mode
                 STAY(OLDTXT)      ; save continue pointer
a83d 85 3d       STA OLDTXT
a83f 84 3e       STY OLDTXT+1

                 LDAY(CURLIN)      ; get current line number
a841 a5 39       LDA CURLIN
a843 a4 3a       LDY CURLIN+1

                 STAY(OLDLIN)      ; save break line number
a845 85 3b       STA OLDLIN
a847 84 3c       STY OLDLIN+1


a849          BaEN_20
a849 68          PLA               ; dump return address low byte
a84a 68          PLA               ; dump return address high byte

a84b            End_Of_Exec
              ; -----------
                 LAYI(Msg_CrLf)
a84b a9 81       LDA #<Msg_CrLf
a84d a0 a3       LDY #>Msg_CrLf

a84f 90 03       BCC BaEN_30       ; branch if it was program end
a851 4c 69 a4    JMP Display_Msg_Then_Ready

a854          BaEN_30

0000 TRUE     #if C64
a854 4c 86 e3    JMP Vectored_Basic_Ready
              #endif
0001 FALSE    #if VIC
SKIP             JMP Basic_Ready
              #endif

              ; **********
a857            Basic_CONT
              ; **********

a857 d0 17       BNE BaCO_Ret      ; exit if following byte to allow syntax error
a859 a2 1a       LDX #$1A          ; error code $1A, can't continue error
a85b a4 3e       LDY OLDTXT+1      ; get continue pointer high byte
a85d d0 03       BNE BaCO_10       ; go do continue if we can
a85f 4c 37 a4    JMP Basic_Error

a862          BaCO_10
a862 a5 3d       LDA OLDTXT        ; get continue pointer low byte
                 STAY(TXTPTR)      ; save BASIC execute pointer
a864 85 7a       STA TXTPTR
a866 84 7b       STY TXTPTR+1

                 LDAY(OLDLIN)      ; get break line
a868 a5 3b       LDA OLDLIN
a86a a4 3c       LDY OLDLIN+1

                 STAY(CURLIN)      ; set current line
a86c 85 39       STA CURLIN
a86e 84 3a       STY CURLIN+1


a870          BaCO_Ret
a870 60          RTS ;Size   26 [Basic_CONT]

              ; *********
a871            Basic_RUN
              ; *********

a871 08          PHP
a872 a9 00       LDA #0            ; no control or kernal messages
a874 20 8a ff    JSR SETMSG
a877 28          PLP
a878 d0 03       BNE BaRU_10       ; branch if RUN n
a87a 4c 59 a6    JMP Reset_BASIC_Execution

a87d          BaRU_10
a87d 20 60 a6    JSR Clear_Variable_Space
a880 4c 97 a8    JMP Goto_Line

              ; ***********
a883            Basic_GOSUB
              ; ***********

a883 a9 03       LDA #3            ; need 6 bytes for GOSUB
a885 20 fb a3    JSR Check_Stack_Avail
                 PUSHW(TXTPTR)     ; push BASIC execute pointer
a888 a5 7b       LDA TXTPTR+1
a88a 48          PHA
a88b a5 7a       LDA TXTPTR
a88d 48          PHA

                 PUSHW(CURLIN)     ; push current line number
a88e a5 3a       LDA CURLIN+1
a890 48          PHA
a891 a5 39       LDA CURLIN
a893 48          PHA

a894 a9 8d       LDA #TK_GOSUB     ; token for GOSUB
a896 48          PHA               ; save it

a897            Goto_Line
              ; ---------
a897 20 79 00    JSR CHRGOT
a89a 20 a0 a8    JSR Basic_GOTO
a89d 4c ae a7    JMP Interpreter_Loop

              ; **********
a8a0            Basic_GOTO
              ; **********

a8a0 20 6b a9    JSR Scan_Linenumber
a8a3 20 09 a9    JSR Next_Line
a8a6 38          SEC
a8a7 a5 39       LDA CURLIN        ; get current line number low byte
a8a9 e5 14       SBC LINNUM        ; subtract temporary integer low byte
a8ab a5 3a       LDA CURLIN+1      ; get current line number high byte
a8ad e5 15       SBC LINNUM+1      ; subtract temporary integer high byte
a8af b0 0b       BCS BaGO_10       ; if current line # >= temporary search from start
a8b1 98          TYA               ; else copy line index to A
a8b2 38          SEC               ; set carry (+1)
a8b3 65 7a       ADC TXTPTR        ; add BASIC execute pointer low byte
a8b5 a6 7b       LDX TXTPTR+1      ; get BASIC execute pointer high byte
a8b7 90 07       BCC BaGO_20       ; if no overflow skip the high byte increment
a8b9 e8          INX               ; increment high byte
a8ba b0 04       BCS BaGO_20       ; go find the line, branch always

a8bc          BaGO_10
                 LDAX(TXTTAB)      ; get start of memory
a8bc a5 2b       LDA TXTTAB
a8be a6 2c       LDX TXTTAB+1


a8c0          BaGO_20
a8c0 20 17 a6    JSR Find_BASIC_Line_AX
a8c3 90 1e       BCC Undefined_Statement
a8c5 a5 5f       LDA TMPPTC        ; get pointer low byte
a8c7 e9 01       SBC #1            ; -1
a8c9 85 7a       STA TXTPTR        ; save BASIC execute pointer low byte
a8cb a5 60       LDA TMPPTC+1      ; get pointer high byte
a8cd e9 00       SBC #0            ; subtract carry
a8cf 85 7b       STA TXTPTR+1      ; save BASIC execute pointer high byte

a8d1          BaGO_Ret
a8d1 60          RTS ;Size   50 [Basic_GOTO]

              ; ************
a8d2            Basic_RETURN
              ; ************

a8d2 d0 fd       BNE BaGO_Ret      ; exit if following token to allow syntax error
a8d4 a9 ff       LDA #$FF          ; set byte so no match possible
a8d6 85 4a       STA FORPNT+1      ; save FOR/NEXT variable pointer high byte
a8d8 20 8a a3    JSR Find_Active_FOR
a8db 9a          TXS               ; correct the stack
a8dc c9 8d       CMP #TK_GOSUB     ; compare with GOSUB token
a8de f0 0b       BEQ BaRE_20       ; if matching GOSUB go continue RETURN
a8e0 a2 0c       LDX #$0C          ; else error code $04, return without gosub error
a8e2 2c          .byte $2C         ; skip next statement

              ; ===================
a8e3            Undefined_Statement
              ; ===================

a8e3 a2 11       LDX #$11          ; error code $11, undefined statement error
a8e5 4c 37 a4    JMP Basic_Error

a8e8          BaRE_10
a8e8 4c 08 af    JMP Syntax_Error

a8eb          BaRE_20
a8eb 68          PLA               ; dump token byte
                 PULLW(CURLIN)     ; pull current line number
a8ec 68          PLA
a8ed 85 39       STA CURLIN
a8ef 68          PLA
a8f0 85 3a       STA CURLIN+1

                 PULLW(TXTPTR)     ; pull BASIC execute pointer
a8f2 68          PLA
a8f3 85 7a       STA TXTPTR
a8f5 68          PLA
a8f6 85 7b       STA TXTPTR+1


              ; **********
a8f8            Basic_DATA
              ; **********

a8f8 20 06 a9    JSR Next_Statement

              ; **************************
a8fb            Add_Y_To_Execution_Pointer
              ; **************************

a8fb 98          TYA               ; copy index to A

a8fc          Add_To_TXTPTR
a8fc 18          CLC
a8fd 65 7a       ADC TXTPTR        ; add BASIC execute pointer low byte
a8ff 85 7a       STA TXTPTR        ; save BASIC execute pointer low byte
a901 90 02       BCC AYTE_Ret      ; skip increment if no carry
a903 e6 7b       INC TXTPTR+1      ; else increment BASIC execute pointer high byte

a905          AYTE_Ret
a905 60          RTS ;Size   11 [Add_Y_To_Execution_Pointer]

              ; **************
a906            Next_Statement
              ; **************

a906 a2 3a       LDX #':'          ; look for colon
a908 2c          .byte   $2C       ; skip "LDX #0" command

              ; *********
a909            Next_Line
              ; *********

a909 a2 00       LDX #0            ; look for 0 [EOL]
a90b 86 07       STX CHARAC        ; store alternate search character
a90d a0 00       LDY #0            ; set search character = [EOL]
a90f 84 08       STY ENDCHR        ; save the search character

a911          NeLi_10
a911 a5 08       LDA ENDCHR        ; get search character
a913 a6 07       LDX CHARAC        ; get alternate search character
a915 85 07       STA CHARAC        ; make search character = alternate search character

a917          NeLi_15
a917 86 08       STX ENDCHR        ; make alternate search character = search character

a919          NeLi_20
a919 b1 7a       LDA (TXTPTR),Y    ; get BASIC byte
a91b f0 e8       BEQ AYTE_Ret      ; exit if null [EOL]
a91d c5 08       CMP ENDCHR        ; compare with search character
a91f f0 e4       BEQ AYTE_Ret      ; exit if found
a921 c8          INY               ; else increment index
a922 c9 22       CMP #QUOTE
a924 d0 f3       BNE NeLi_20       ; if found go swap search character for alternate search
a926 f0 e9       BEQ NeLi_10       ; loop for next character, branch always

              ; ********
a928            Basic_IF
              ; ********

a928 20 9e ad    JSR Eval_Expression
a92b 20 79 00    JSR CHRGOT
a92e c9 89       CMP #TK_GOTO
a930 f0 05       BEQ BaIF_10       ; do IF ... GOTO
a932 a9 a7       LDA #TK_THEN
a934 20 ff ae    JSR Need_A

a937          BaIF_10
a937 a5 61       LDA FAC1EX        ; get FAC1 exponent
a939 d0 05       BNE BaIF_20      ; if result was non zero continue execution

              ; *********
a93b            Basic_REM
              ; *********

a93b 20 09 a9    JSR Next_Line
a93e f0 bb       BEQ Add_Y_To_Execution_Pointer ; branch always

a940          BaIF_20              ; Basic_IF continued
a940 20 79 00    JSR CHRGOT
a943 b0 03       BCS BaIF_30      ; if not numeric character, is variable or keyword
a945 4c a0 a8    JMP Basic_GOTO    ; else perform GOTO n

a948          BaIF_30
a948 4c ed a7    JMP Interpret

              ; ********
a94b            Basic_ON
              ; ********

a94b 20 9e b7    JSR Get_Byte_Value
a94e 48          PHA               ; push next character
a94f c9 8d       CMP #TK_GOSUB     ; compare with GOSUB token
a951 f0 04       BEQ BaON_20       ; if GOSUB go see if it should be executed

a953          BaON_10
a953 c9 89       CMP #TK_GOTO      ; compare with GOTO token
a955 d0 91       BNE BaRE_10       ; if not GOTO do syntax error then warm start

a957          BaON_20
a957 c6 65       DEC FAC1M4        ; decrement the byte value
a959 d0 04       BNE BaON_30       ; if not zero go see if another line number exists
a95b 68          PLA               ; pull keyword token
a95c 4c ef a7    JMP Interpret_10

a95f          BaON_30
a95f 20 73 00    JSR CHRGET
a962 20 6b a9    JSR Scan_Linenumber
a965 c9 2c       CMP #','          ; compare next character with ","
a967 f0 ee       BEQ BaON_20       ; loop if ","
a969 68          PLA               ; else pull keyword token, ran out of options

a96a          BaON_Ret
a96a 60          RTS ;Size   32 [Basic_ON]

              ; ***************
a96b            Scan_Linenumber
              ; ***************

a96b a2 00       LDX #0
a96d 86 14       STX LINNUM
a96f 86 15       STX LINNUM+1

a971          ScLi_Loop
a971 b0 f7       BCS BaON_Ret      ; return if carry set, end of scan, character was not 0-9
a973 e9 2f       SBC #$2F          ; subtract $30, $2F+carry, from byte
a975 85 07       STA CHARAC        ; store # OPT: TAX
a977 a5 15       LDA LINNUM+1      ; get temporary integer high byte
a979 85 22       STA INDEXA        ; save it for now
a97b c9 19       CMP #$19          ; compare with $19
a97d b0 d4       BCS BaON_10       ; branch if >= this makes the maximum line number 63999
                                   ; because the next bit does $1900 * $0A = $FA00 = 64000
                                   ; decimal. the branch target is really the SYNTAX error
                                   ; at BaRE_10 but that is too far so an intermediate
                                   ; compare and branch to that location is used. the problem
                                   ; with this is that line number that gives a partial result
                                   ; from $8900 to $89FF, 35072x to 35327x, will pass the new
                                   ; target compare and will try to execute the remainder of
                                   ; the ON n GOTO/GOSUB. a solution to this is to copy the
                                   ; byte in A before the branch to X and then branch to
                                   ; BaRE_10 skipping the second compare

a97f a5 14       LDA LINNUM        ; get temporary integer low byte
a981 0a          ASL A             ; *2 low byte
a982 26 22       ROL INDEXA        ; *2 high byte
a984 0a          ASL A             ; *2 low byte
a985 26 22       ROL INDEXA        ; *2 high byte (*4)
a987 65 14       ADC LINNUM        ; + low byte (*5)
a989 85 14       STA LINNUM        ; save it
a98b a5 22       LDA INDEXA        ; get high byte temp
a98d 65 15       ADC LINNUM+1      ; + high byte (*5)
a98f 85 15       STA LINNUM+1      ; save it
a991 06 14       ASL LINNUM        ; *2 low byte (*10d)
a993 26 15       ROL LINNUM+1      ; *2 high byte (*10d)
a995 a5 14       LDA LINNUM        ; get low byte OPT: TXA
a997 65 07       ADC CHARAC        ; add #        OPT: ADC LINNUM
a999 85 14       STA LINNUM        ; save low byte
a99b 90 02       BCC ScLi_10       ; if no overflow skip high byte increment
a99d e6 15       INC LINNUM+1      ; else increment high byte

a99f          ScLi_10
a99f 20 73 00    JSR CHRGET
a9a2 4c 71 a9    JMP ScLi_Loop      ; OPT: BCC ScLi_Loop : RTS

              ; *********
a9a5            Basic_LET
              ; *********

a9a5 20 8b b0    JSR Get_Scalar_Address
                 STAY(FORPNT)      ; save variable address
a9a8 85 49       STA FORPNT
a9aa 84 4a       STY FORPNT+1

a9ac a9 b2       LDA #TK_EQUAL
a9ae 20 ff ae    JSR Need_A        ; '=' is needed
a9b1 a5 0e       LDA INTFLG        ; get data type flag, $80 = integer, $00 = float
a9b3 48          PHA               ; push data type flag
a9b4 a5 0d       LDA VALTYP        ; get data type flag, $FF = string, $00 = numeric
a9b6 48          PHA               ; push data type flag
a9b7 20 9e ad    JSR Eval_Expression
a9ba 68          PLA               ; pop data type flag
a9bb 2a          ROL A             ; string bit into carry
a9bc 20 90 ad    JSR Check_Var_Type
a9bf d0 18       BNE LET_20        ; if string go assign a string value
a9c1 68          PLA               ; pop integer/float data type flag

              ; ***********************
a9c2            Assign_Numeric_variable
              ; ***********************

a9c2 10 12       BPL LET_10        ; if float go assign a floating value
a9c4 20 1b bc    JSR Round_FAC1_Checked
a9c7 20 bf b1    JSR Eval_Integer
a9ca a0 00       LDY #0
a9cc a5 64       LDA FAC1M3        ; get FAC1 mantissa 3
a9ce 91 49       STA (FORPNT),Y    ; save as integer variable low byte
a9d0 c8          INY
a9d1 a5 65       LDA FAC1M4        ; get FAC1 mantissa 4
a9d3 91 49       STA (FORPNT),Y    ; save as integer variable high byte
a9d5 60          RTS ;Size   20 [Assign_Numeric_variable]

a9d6          LET_10
a9d6 4c d0 bb    JMP Assign_FAC1_To_FOR_Index

a9d9          LET_20
a9d9 68          PLA               ; dump integer/float data type flag

              ; **********************
a9da            Assign_String_Variable
              ; **********************

a9da a4 4a       LDY FORPNT+1      ; get variable pointer high byte
a9dc c0 bf       CPY #>NULL_Descriptor ; TI$
a9de d0 4c       BNE Assign_String
a9e0 20 a6 b6    JSR Get_String_Descriptor
a9e3 c9 06       CMP #6            ; TI$ = "hhmmss"
a9e5 d0 3d       BNE Jump_Illegal_Quantity
a9e7 a0 00       LDY #0
a9e9 84 61       STY FAC1EX        ; clear FAC1 exponent
a9eb 84 66       STY FAC1SI        ; clear FAC1 sign (b7)

a9ed          LET_30
a9ed 84 71       STY TMPPTD        ; save index
a9ef 20 1d aa    JSR Eval_Digit    ; check and evaluate numeric digit
a9f2 20 e2 ba    JSR Multiply_FAC1_BY_10
a9f5 e6 71       INC TMPPTD        ; increment index
a9f7 a4 71       LDY TMPPTD        ; restore index
a9f9 20 1d aa    JSR Eval_Digit    ; check and evaluate numeric digit
a9fc 20 0c bc    JSR FAC1_Round_And_Copy_To_FAC2
a9ff aa          TAX               ; copy FAC1 exponent
aa00 f0 05       BEQ LET_40        ; branch if FAC1 zero
aa02 e8          INX               ; increment index, * 2
aa03 8a          TXA               ; copy back to A
aa04 20 ed ba    JSR Multiply_FAC1_By_4

aa07          LET_40
aa07 a4 71       LDY TMPPTD        ; get index
aa09 c8          INY
aa0a c0 06       CPY #6            ; max. 6 digits "hhmmss"
aa0c d0 df       BNE LET_30

aa0e 20 e2 ba    JSR Multiply_FAC1_BY_10
aa11 20 9b bc    JSR FAC1_To_Integer
aa14 a6 64       LDX FAC1M3        ; get FAC1 mantissa 3
aa16 a4 63       LDY FAC1M2        ; get FAC1 mantissa 2
aa18 a5 65       LDA FAC1M4        ; get FAC1 mantissa 4
aa1a 4c d5 ff    JMP SETTIM        ; Set the system clock

              ; **********
aa1d            Eval_Digit
              ; **********

aa1d b1 22       LDA (INDEXA),Y    ; get byte from string
aa1f 20 80 00    JSR ISNUM
aa22 90 03       BCC EvDi_10       ; branch if numeric

aa24          Jump_Illegal_Quantity
aa24 4c 48 b2    JMP Illegal_Quantity

aa27          EvDi_10
aa27 e9 2f       SBC #$2F          ; subtract $2F + carry = '0'
aa29 4c 7e bd    JMP Add_A_To_FAC1

              ; -------------
aa2c            Assign_String
              ; -------------

aa2c a0 02       LDY #2            ; index to string pointer high byte
aa2e b1 64       LDA (FAC1M3),Y    ; get string pointer high byte
aa30 c5 34       CMP FRESPC+1      ; compare with bottom of string space high byte
aa32 90 17       BCC AsSt_20       ; branch if string pointer < bottom of string space
aa34 d0 07       BNE AsSt_10       ; branch if string pointer > bottom of string space
aa36 88          DEY               ; Y = 1
aa37 b1 64       LDA (FAC1M3),Y    ; get string pointer low byte
aa39 c5 33       CMP FRESPC        ; compare with bottom of string space low byte
aa3b 90 0e       BCC AsSt_20       ; branch if string pointer < bottom of string space

aa3d          AsSt_10
aa3d a4 65       LDY FAC1M4        ; get descriptor pointer high byte
aa3f c4 2e       CPY VARTAB+1      ; compare with start of variables high byte
aa41 90 08       BCC AsSt_20       ; branch if less, is on string stack
aa43 d0 0d       BNE AsSt_30       ; if greater make space and copy string
aa45 a5 64       LDA FAC1M3        ; get descriptor pointer low byte
aa47 c5 2d       CMP VARTAB        ; compare with start of variables low byte
aa49 b0 07       BCS AsSt_30       ; if greater or equal make space and copy string

aa4b          AsSt_20
aa4b a5 64       LDA FAC1M3        ; get descriptor pointer low byte
aa4d a4 65       LDY FAC1M4        ; get descriptor pointer high byte
aa4f 4c 68 aa    JMP AsSt_40       ; go copy descriptor to variable

aa52          AsSt_30
aa52 a0 00       LDY #0
aa54 b1 64       LDA (FAC1M3),Y    ; get string length
aa56 20 75 b4    JSR Allocate_String_FAC1
                 LDAY(DESCPT)
aa59 a5 50       LDA DESCPT
aa5b a4 51       LDY DESCPT+1

                 STAY(STRPTR)
aa5d 85 6f       STA STRPTR
aa5f 84 70       STY STRPTR+1

aa61 20 7a b6    JSR Store_String_STRPTR
                 LAYI(FAC1EX)
aa64 a9 61       LDA #<FAC1EX
aa66 a0 00       LDY #>FAC1EX


aa68          AsSt_40
                 STAY( DESCPT)     ; save descriptor pointer
aa68 85 50       STA DESCPT
aa6a 84 51       STY DESCPT+1

aa6c 20 db b6    JSR Pop_Descriptor_Stack
aa6f a0 00       LDY #0
aa71 b1 50       LDA (DESCPT),Y    ; get string length from new descriptor
aa73 91 49       STA (FORPNT),Y    ; copy string length to variable
aa75 c8          INY
aa76 b1 50       LDA (DESCPT),Y    ; get string pointer low byte from new descriptor
aa78 91 49       STA (FORPNT),Y    ; copy string pointer low byte to variable
aa7a c8          INY
aa7b b1 50       LDA (DESCPT),Y    ; get string pointer high byte from new descriptor
aa7d 91 49       STA (FORPNT),Y    ; copy string pointer high byte to variable
aa7f 60          RTS ;Size   99 [Eval_Digit]

              ; ************
aa80            Basic_PRINTN
              ; ************

aa80 20 86 aa    JSR Basic_CMD
aa83 4c b5 ab    JMP Set_Default_Channels

              ; *********
aa86            Basic_CMD
              ; *********

aa86 20 9e b7    JSR Get_Byte_Value
aa89 f0 05       BEQ BCMD_10       ; branch if following byte is ":" or [EOT]
aa8b a9 2c       LDA #','
aa8d 20 ff ae    JSR Need_A

aa90          BCMD_10
aa90 08          PHP               ; save status
aa91 86 13       STX IOPMPT        ; set current I/O channel
aa93 20 18 e1    JSR Select_Output_Channel
aa96 28          PLP               ; restore status
aa97 4c a0 aa    JMP Basic_PRINT   ; perform PRINT

aa9a          BaPR_00
aa9a 20 21 ab    JSR Print_String_From_Descriptor

aa9d          BaPR_05
aa9d 20 79 00    JSR CHRGOT

              ; ***********
aaa0            Basic_PRINT
              ; ***********

aaa0 f0 35       BEQ Print_CR

aaa2          BaPR_10
aaa2 f0 43       BEQ Invert_Ret      ; if nothing following exit, end of PRINT branch
aaa4 c9 a3       CMP #TK_TAB       ; compare with token for TAB(
aaa6 f0 50       BEQ TAB_20      ; if TAB( go handle it
aaa8 c9 a6       CMP #TK_SPC       ; compare with token for SPC(
aaaa 18          CLC               ; flag SPC(
aaab f0 4b       BEQ TAB_20      ; if SPC( go handle it
aaad c9 2c       CMP #','
aaaf f0 37       BEQ TAB_Jump
aab1 c9 3b       CMP #SEMIC
aab3 f0 5e       BEQ TAB_60      ; if ";" go continue the print loop
aab5 20 9e ad    JSR Eval_Expression
aab8 24 0d       BIT VALTYP        ; test data type flag, $FF = string, $00 = numeric
aaba 30 de       BMI BaPR_00      ; if string go print string, scan memory and continue PRINT
aabc 20 dd bd    JSR Format_FAC1
aabf 20 87 b4    JSR Create_String_Descriptor
aac2 20 21 ab    JSR Print_String_From_Descriptor
aac5 20 3b ab    JSR Cursor_Right_Or_Space
aac8 d0 d3       BNE BaPR_05      ; go scan memory and continue PRINT, branch always

              ; =============
aaca            Terminate_BUF
              ; =============

aaca a9 00       LDA #0
aacc 9d 00 02    STA BUF,X         ; terminate string with 0 byte
aacf a2 ff       LDX #<[BUF-1]
aad1 a0 01       LDY #>[BUF-1]
aad3 a5 13       LDA IOPMPT        ; get current I/O channel
aad5 d0 10       BNE Invert_Ret      ; exit if not default channel

              ; ********
aad7            Print_CR
              ; ********

aad7 a9 0d       LDA #CR
aad9 20 47 ab    JSR Print_Char
aadc 24 13       BIT IOPMPT        ; test current I/O channel
aade 10 05       BPL Invert_A      ; needless, because this is always true
aae0 a9 0a       LDA #LF
aae2 20 47 ab    JSR Print_Char

              ; --------
aae5            Invert_A
              ; --------

aae5 49 ff       EOR #$FF          ; invert A

aae7          Invert_Ret
aae7 60          RTS ;Size   17 [Print_CR]

              ; ========
aae8            TAB_Jump
              ; ========

aae8 38          SEC               ; set Cb for read cursor position
aae9 20 ea ff    JSR PLOT          ; Read cursor location
aaec 98          TYA               ; copy cursor Y
aaed 38          SEC

aaee          TAB_10

0000 TRUE     #if C64
aaee e9 0a       SBC #10           ; subtract one TAB length
              #endif
0001 FALSE    #if VIC
SKIP             SBC #11           ; subtract one TAB length
              #endif

aaf0 b0 fc       BCS TAB_10
aaf2 49 ff       EOR #$FF          ; complement it
aaf4 69 01       ADC #1
aaf6 d0 16       BNE TAB_30        ; print A spaces, branch always

aaf8          TAB_20
aaf8 08          PHP               ; save TAB( or SPC( status
aaf9 38          SEC               ; set Cb for read cursor position
aafa 20 ea ff    JSR PLOT          ; Read or set cursor location
aafd 84 09       STY TRMPOS        ; save current cursor position
aaff 20 9b b7    JSR Get_Next_Byte_Value
ab02 c9 29       CMP #$29          ; compare with ")"
ab04 d0 59       BNE BaIn_30       ; if not ")" do syntax error
ab06 28          PLP               ; restore TAB( or SPC( status
ab07 90 06       BCC TAB_40        ; branch if was SPC(
ab09 8a          TXA               ; copy TAB() byte to A
ab0a e5 09       SBC TRMPOS        ; subtract current cursor position
ab0c 90 05       BCC TAB_60        ; go loop for next if already past requited position

ab0e          TAB_30
ab0e aa          TAX               ; copy [SPACE] count to X

ab0f          TAB_40
ab0f e8          INX               ; increment count

ab10          TAB_50
ab10 ca          DEX               ; decrement count
ab11 d0 06       BNE TAB_70        ; branch if count was not zero

ab13          TAB_60
ab13 20 73 00    JSR CHRGET
ab16 4c a2 aa    JMP BaPR_10       ; continue print loop

ab19          TAB_70
ab19 20 3b ab    JSR Cursor_Right_Or_Space
ab1c d0 f2       BNE TAB_50        ; loop, branch always

              ; ************
ab1e            Print_String
              ; ************

ab1e 20 87 b4    JSR Create_String_Descriptor

              ; ----------------------------
ab21            Print_String_From_Descriptor
              ; ----------------------------

ab21 20 a6 b6    JSR Get_String_Descriptor
ab24 aa          TAX               ; copy length
ab25 a0 00       LDY #0
ab27 e8          INX               ; increment length, for pre decrement loop

ab28          PSFD_Loop
ab28 ca          DEX               ; decrement length
ab29 f0 bc       BEQ Invert_Ret    ; exit if done
ab2b b1 22       LDA (INDEXA),Y    ; get byte from string
ab2d 20 47 ab    JSR Print_Char
ab30 c8          INY
ab31 c9 0d       CMP #$0D          ; compare byte with [CR]
ab33 d0 f3       BNE PSFD_Loop
ab35 20 e5 aa    JSR Invert_A      ; nonsense
ab38 4c 28 ab    JMP PSFD_Loop

              ; *********************
ab3b            Cursor_Right_Or_Space
              ; *********************

ab3b a5 13       LDA IOPMPT        ; get current I/O channel
ab3d f0 03       BEQ CROS_10       ; if default channel load [CURSOR RIGHT]
ab3f a9 20       LDA #' '          ; else load [SPACE]
ab41 2c          .byte $2C         ; skip until Print_Char
ab42          CROS_10 
ab42 a9 1d       LDA #$1D          ; load [CURSOR RIGHT]
ab44 2c          .byte $2C         ; skip until Print_Char

              ; *******************
ab45            Print_Question_Mark
              ; *******************

ab45 a9 3f       LDA #'?'

              ; **********
ab47            Print_Char
              ; **********

ab47 20 0c e1    JSR CHROUT_Checked
ab4a 29 ff       AND #$FF          ; set flags
ab4c 60          RTS ;Size    6 [Print_Char]

              ; =========
ab4d            Bad_Input
              ; =========

ab4d a5 11       LDA INPFLG        ; get INPUT mode flag, $00 = INPUT, $40 = GET, $98 = READ
ab4f f0 11       BEQ BaIn_40       ; branch if INPUT
ab51 30 04       BMI BaIn_10       ; branch if READ
ab53 a0 ff       LDY #$FF          ; set current line high byte to -1, indicate immediate mode
ab55 d0 04       BNE BaIn_20       ; branch always

ab57          BaIn_10
                 LDAY(DATLIN)      ; get current DATA line number
ab57 a5 3f       LDA DATLIN
ab59 a4 40       LDY DATLIN+1


ab5b          BaIn_20
                 STAY(CURLIN)      ; set current line number
ab5b 85 39       STA CURLIN
ab5d 84 3a       STY CURLIN+1


ab5f          BaIn_30
ab5f 4c 08 af    JMP Syntax_Error

ab62          BaIn_40
ab62 a5 13       LDA IOPMPT        ; get current I/O channel
ab64 f0 05       BEQ BaIn_50       ; if default channel go do "?REDO FROM START" message
ab66 a2 18       LDX #$18          ; else error $18, file data error
ab68 4c 37 a4    JMP Basic_Error

ab6b          BaIn_50
                 Print_Msg(Msg_Redo_From_Start)
ab6b a9 0c       LDA #<Msg_Redo_From_Start
ab6d a0 ad       LDY #>Msg_Redo_From_Start
ab6f 20 1e ab    JSR Print_String

                 LDAY(OLDTXT)      ; get continue pointer
ab72 a5 3d       LDA OLDTXT
ab74 a4 3e       LDY OLDTXT+1

                 STAY(TXTPTR)      ; save BASIC execute pointer
ab76 85 7a       STA TXTPTR
ab78 84 7b       STY TXTPTR+1

ab7a 60          RTS ;Size   52 [Print_Char]

              ; *********
ab7b            Basic_GET
              ; *********

ab7b 20 a6 b3    JSR Assert_Non_Direct
ab7e c9 23       CMP #'#'          ; compare with "#"
ab80 d0 10       BNE BaGE_10       ; branch if not GET#
ab82 20 73 00    JSR CHRGET
ab85 20 9e b7    JSR Get_Byte_Value
ab88 a9 2c       LDA #','
ab8a 20 ff ae    JSR Need_A
ab8d 86 13       STX IOPMPT        ; set current I/O channel
ab8f 20 1e e1    JSR CHKIN_Checked

ab92          BaGE_10
ab92 a2 01       LDX #<[BUF+1]     ; set BUF+1 pointer low byte
ab94 a0 02       LDY #>[BUF+1]     ; set BUF+1 pointer high byte
ab96 a9 00       LDA #0
ab98 8d 01 02    STA BUF+1         ; ensure null terminator
ab9b a9 40       LDA #$40          ; input mode = GET
ab9d 20 0f ac    JSR Read_Get
aba0 a6 13       LDX IOPMPT        ; get current I/O channel
aba2 d0 13       BNE BaIN_10       ; if not default channel go do channel close and return
aba4 60          RTS ;Size   42 [Basic_GET]

              ; ************
aba5            Basic_INPUTN
              ; ************

aba5 20 9e b7    JSR Get_Byte_Value
aba8 a9 2c       LDA #','
abaa 20 ff ae    JSR Need_A
abad 86 13       STX IOPMPT        ; set current I/O channel
abaf 20 1e e1    JSR CHKIN_Checked
abb2 20 ce ab    JSR Input_String

              ; --------------------
abb5            Set_Default_Channels
              ; --------------------

abb5 a5 13       LDA IOPMPT        ; get current I/O channel

abb7          BaIN_10
abb7 20 c6 ff    JSR CLRCHN        ; Clear I/O channels
abba a2 00       LDX #0
abbc 86 13       STX IOPMPT        ; clear current I/O channel
abbe 60          RTS ;Size   26 [Basic_INPUTN]

              ; ***********
abbf            Basic_INPUT
              ; ***********

abbf c9 22       CMP #QUOTE
abc1 d0 0b       BNE Input_String
abc3 20 bd ae    JSR Make_String_Descriptor_From_Code
abc6 a9 3b       LDA #SEMIC
abc8 20 ff ae    JSR Need_A
abcb 20 21 ab    JSR Print_String_From_Descriptor

              ; ------------
abce            Input_String
              ; ------------

abce 20 a6 b3    JSR Assert_Non_Direct
abd1 a9 2c       LDA #','
abd3 8d ff 01    STA BUF-1         ; save to start of buffer - 1

abd6          BaIN_20
abd6 20 f9 ab    JSR Prompt_And_Input
abd9 a5 13       LDA IOPMPT        ; get current I/O channel
abdb f0 0d       BEQ BaIN_30       ; branch if default I/O channel
abdd 20 b1 ff    JSR READST        ; read I/O status word
abe0 29 02       AND #$02          ; mask no DSR/timeout
abe2 f0 06       BEQ BaIN_30       ; branch if not error
abe4 20 b5 ab    JSR Set_Default_Channels
abe7 4c f8 a8    JMP Basic_DATA    ; perform DATA

abea          BaIN_30
abea ad 00 02    LDA BUF           ; get first byte in input buffer
abed d0 1e       BNE BaIN_50
abef a5 13       LDA IOPMPT        ; get current I/O channel
abf1 d0 e3       BNE BaIN_20       ; if not default channel go get BASIC input
abf3 20 06 a9    JSR Next_Statement
abf6 4c fb a8    JMP Add_Y_To_Execution_Pointer

              ; ****************
abf9            Prompt_And_Input
              ; ****************

abf9 a5 13       LDA IOPMPT        ; get current I/O channel
abfb d0 06       BNE BaIN_40       ; skip "?" prompt if not default channel
abfd 20 45 ab    JSR Print_Question_Mark
ac00 20 3b ab    JSR Cursor_Right_Or_Space
ac03          BaIN_40
ac03 4c 60 a5    JMP Read_String

              ; **********
ac06            Basic_READ
              ; **********

                 LDXY(DATPTR)
ac06 a6 41       LDX DATPTR
ac08 a4 42       LDY DATPTR+1

ac0a a9 98       LDA #$98          ; set input mode = READ
ac0c 2c          .byte   $2C       ; skip next statement
ac0d          BaIN_50
ac0d a9 00       LDA #$00          ; set input mode = INPUT

              ; --------
ac0f            Read_Get
              ; --------

ac0f 85 11       STA INPFLG        ; $00 = INPUT, $40 = GET, $98 = READ
                 STXY(INPPTR)
ac11 86 43       STX INPPTR
ac13 84 44       STY INPPTR+1


ac15          READ_Loop_Var
ac15 20 8b b0    JSR Get_Scalar_Address
                 STAY(FORPNT)      ; save variable address
ac18 85 49       STA FORPNT
ac1a 84 4a       STY FORPNT+1

                 LDAY(TXTPTR)      ; get BASIC execute pointer
ac1c a5 7a       LDA TXTPTR
ac1e a4 7b       LDY TXTPTR+1

                 STAY(YSAVE)       ; save BASIC execute pointer
ac20 85 4b       STA YSAVE
ac22 84 4c       STY YSAVE+1

                 LDXY(INPPTR)      ; get READ pointer
ac24 a6 43       LDX INPPTR
ac26 a4 44       LDY INPPTR+1

                 STXY(TXTPTR)      ; save as BASIC execute pointer
ac28 86 7a       STX TXTPTR
ac2a 84 7b       STY TXTPTR+1

ac2c 20 79 00    JSR CHRGOT
ac2f d0 20       BNE READ_20       ; branch if not null
ac31 24 11       BIT INPFLG        ; $00 = INPUT, $40 = GET, $98 = READ
ac33 50 0c       BVC READ_05       ; branch if not GET
ac35 20 24 e1    JSR GETIN_Checked
ac38 8d 00 02    STA BUF           ; save to buffer
ac3b a2 ff       LDX #<[BUF-1]     ; set BUF-1 pointer low byte
ac3d a0 01       LDY #>[BUF-1]     ; set BUF-1 pointer high byte
ac3f d0 0c       BNE READ_15       ; branch always

ac41          READ_05
ac41 30 75       BMI READ_60      ; branch if READ else it's do INPUT
ac43 a5 13       LDA IOPMPT        ; get current I/O channel
ac45 d0 03       BNE READ_10       ; skip "?" prompt if not default channel
ac47 20 45 ab    JSR Print_Question_Mark

ac4a          READ_10
ac4a 20 f9 ab    JSR Prompt_And_Input

ac4d          READ_15
                 STXY(TXTPTR)
ac4d 86 7a       STX TXTPTR
ac4f 84 7b       STY TXTPTR+1


ac51          READ_20
ac51 20 73 00    JSR CHRGET        ; execute pointer now points to start of next data
ac54 24 0d       BIT VALTYP        ; test data type flag, $FF = string, $00 = numeric
ac56 10 31       BPL READ_45      ; branch if numeric
ac58 24 11       BIT INPFLG        ; $00 = INPUT, $40 = GET, $98 = READ
ac5a 50 09       BVC READ_25       ; branch if not GET
ac5c e8          INX               ; GET string
ac5d 86 7a       STX TXTPTR        ; save BASIC execute pointer low byte
ac5f a9 00       LDA #0
ac61 85 07       STA CHARAC        ; clear search character
ac63 f0 0c       BEQ READ_30       ; branch always

                                   ; is string INPUT or string READ
ac65          READ_25
ac65 85 07       STA CHARAC        ; save search character
ac67 c9 22       CMP #QUOTE
ac69 f0 07       BEQ READ_35       ; if quote only search for "..." string
ac6b a9 3a       LDA #':'          ; set ":"
ac6d 85 07       STA CHARAC        ; set search character
ac6f a9 2c       LDA #','

ac71          READ_30
ac71 18          CLC

ac72          READ_35
ac72 85 08       STA ENDCHR        ; set scan quotes flag
                 LDAY(TXTPTR)      ; get BASIC execute pointer
ac74 a5 7a       LDA TXTPTR
ac76 a4 7b       LDY TXTPTR+1

ac78 69 00       ADC #0            ; INPUT and READ increment by carry
ac7a 90 01       BCC READ_40       ; if no carry skip the high byte increment
ac7c c8          INY               ; else increment pointer high byte

ac7d          READ_40
ac7d 20 8d b4    JSR Create_String_Descriptor_AY
ac80 20 e2 b7    JSR Restore_Execution_Pointer
ac83 20 da a9    JSR Assign_String_Variable
ac86 4c 91 ac    JMP READ_50       ; continue processing command

                                   ; GET, INPUT or READ is numeric
ac89          READ_45
ac89 20 f3 bc    JSR Load_FAC1_From_String
ac8c a5 0e       LDA INTFLG        ; get data type flag, $80 = integer, $00 = float
ac8e 20 c2 a9    JSR Assign_Numeric_variable

ac91          READ_50
ac91 20 79 00    JSR CHRGOT
ac94 f0 07       BEQ READ_55       ; if ":" or [EOL] go handle the string end
ac96 c9 2c       CMP #','          ; comparte with ","
ac98 f0 03       BEQ READ_55       ; if "," go handle the string end
ac9a 4c 4d ab    JMP Bad_Input

ac9d          READ_55
                 LDAY(TXTPTR)      ; get BASIC execute pointer
ac9d a5 7a       LDA TXTPTR
ac9f a4 7b       LDY TXTPTR+1

                 STAY(INPPTR)      ; save READ pointer
aca1 85 43       STA INPPTR
aca3 84 44       STY INPPTR+1

                 LDAY(YSAVE)       ; get saved BASIC execute pointer
aca5 a5 4b       LDA YSAVE
aca7 a4 4c       LDY YSAVE+1

                 STAY(TXTPTR)      ; restore BASIC execute pointer
aca9 85 7a       STA TXTPTR
acab 84 7b       STY TXTPTR+1

acad 20 79 00    JSR CHRGOT
acb0 f0 2d       BEQ READ_70       ; branch if ":" or [EOL]
acb2 20 fd ae    JSR Need_Comma
acb5 4c 15 ac    JMP READ_Loop_Var

acb8          READ_60
acb8 20 06 a9    JSR Next_Statement
acbb c8          INY
acbc aa          TAX               ; copy byte to X
acbd d0 12       BNE READ_65       ; if ":" go look for the next DATA
acbf a2 0d       LDX #$0D          ; else set error $0D, out of data error
acc1 c8          INY
acc2 b1 7a       LDA (TXTPTR),Y    ; get next line pointer high byte
acc4 f0 6c       BEQ NEXT_20      ; if program end go do error, eventually does error X
acc6 c8          INY
acc7 b1 7a       LDA (TXTPTR),Y    ; get next line # low byte
acc9 85 3f       STA DATLIN        ; save current DATA line low byte
accb c8          INY
accc b1 7a       LDA (TXTPTR),Y    ; get next line # high byte
acce c8          INY
accf 85 40       STA DATLIN+1      ; save current DATA line high byte

acd1          READ_65
acd1 20 fb a8    JSR Add_Y_To_Execution_Pointer
acd4 20 79 00    JSR CHRGOT
acd7 aa          TAX               ; copy byte
acd8 e0 83       CPX #TK_DATA      ; compare with token for DATA
acda d0 dc       BNE READ_60       ; loop if not DATA
acdc 4c 51 ac    JMP READ_20       ; continue evaluating READ

acdf          READ_70
acdf a5 43       LDA INPPTR        ; get READ pointer low byte
ace1 a4 44       LDY INPPTR+1      ; get READ pointer high byte
ace3 a6 11       LDX INPFLG        ; get INPUT mode flag, $00 = INPUT, $40 = GET, $98 = READ
ace5 10 03       BPL READ_75       ; if INPUT or GET go exit or ignore extra input
ace7 4c 27 a8    JMP Store_DATPTR

acea          READ_75
acea a0 00       LDY #0
acec b1 43       LDA (INPPTR),Y    ; get READ byte
acee f0 0b       BEQ READ_Ret      ; exit if [EOL]
acf0 a5 13       LDA IOPMPT        ; get current I/O channel
acf2 d0 07       BNE READ_Ret      ; exit if not default channel
                 LAYI(Msg_Extra_Ignored)
acf4 a9 fc       LDA #<Msg_Extra_Ignored
acf6 a0 ac       LDY #>Msg_Extra_Ignored

acf8 4c 1e ab    JMP Print_String

acfb          READ_Ret
acfb 60          RTS ;Size  246 [Basic_READ]

acfc 3f 45 58 Msg_Extra_Ignored   .byte "?EXTRA IGNORED\r",0
ad0c 3f 52 45 Msg_Redo_From_Start .byte "?REDO FROM START\r",0

              ; **********
ad1e            Basic_NEXT
              ; **********

ad1e d0 04       BNE Find_NEXT_Variable
ad20 a0 00       LDY #0
ad22 f0 03       BEQ NEXT_10      ; use any variable, branch always

              ; ******************
ad24            Find_NEXT_Variable
              ; ******************

ad24 20 8b b0    JSR Get_Scalar_Address

ad27          NEXT_10
                 STAY(FORPNT)      ; save FOR/NEXT variable pointer
ad27 85 49       STA FORPNT
ad29 84 4a       STY FORPNT+1

ad2b 20 8a a3    JSR Find_Active_FOR
ad2e f0 05       BEQ NEXT_30       ; if FOR found continue
ad30 a2 0a       LDX #$0A          ; else set error $0A, next without for error

ad32          NEXT_20
ad32 4c 37 a4    JMP Basic_Error

              ; found this FOR variable

ad35          NEXT_30
ad35 9a          TXS               ; update stack pointer
ad36 8a          TXA               ; copy stack pointer
ad37 18          CLC
ad38 69 04       ADC #$04          ; point to STEP value
ad3a 48          PHA               ; save it
ad3b 69 06       ADC #$06          ; point to TO value
ad3d 85 24       STA INDEXB        ; save pointer to TO variable for compare
ad3f 68          PLA               ; restore pointer to STEP value
ad40 a0 01       LDY #$01          ; point to stack page
ad42 20 a2 bb    JSR Load_FAC1_AY
ad45 ba          TSX               ; get stack pointer back
ad46 bd 09 01    LDA STACK+9,X     ; get step sign
ad49 85 66       STA FAC1SI        ; save FAC1 sign (b7)
ad4b a5 49       LDA FORPNT        ; get FOR/NEXT variable pointer low byte
ad4d a4 4a       LDY FORPNT+1      ; get FOR/NEXT variable pointer high byte
ad4f 20 67 b8    JSR Add_Var_AY_To_FAC1
ad52 20 d0 bb    JSR Assign_FAC1_To_FOR_Index
ad55 a0 01       LDY #$01          ; point to stack page
ad57 20 5d bc    JSR Compare_FAC1_INDEXB_Y ; compare FAC1 with TO value
ad5a ba          TSX               ; get stack pointer back
ad5b 38          SEC
ad5c fd 09 01    SBC STACK+9,X     ; subtract step sign
ad5f f0 17       BEQ NEXT_50       ; if = loop complete, go unstack the FOR
ad61 bd 0f 01    LDA STACK+$0F,X   ; get FOR line low byte
ad64 85 39       STA CURLIN        ; save current line number low byte
ad66 bd 10 01    LDA STACK+$10,X   ; get FOR line high byte
ad69 85 3a       STA CURLIN+1      ; save current line number high byte
ad6b bd 12 01    LDA STACK+$12,X   ; get BASIC execute pointer low byte
ad6e 85 7a       STA TXTPTR        ; save BASIC execute pointer low byte
ad70 bd 11 01    LDA STACK+$11,X   ; get BASIC execute pointer high byte
ad73 85 7b       STA TXTPTR+1      ; save BASIC execute pointer high byte

ad75          NEXT_40
ad75 4c ae a7    JMP Interpreter_Loop

ad78          NEXT_50
ad78 8a          TXA               ; stack copy to A
ad79 69 11       ADC #$11          ; add $12, $11 + carry, to dump FOR structure
ad7b aa          TAX               ; copy back to index
ad7c 9a          TXS               ; copy to stack pointer
ad7d 20 79 00    JSR CHRGOT
ad80 c9 2c       CMP #','
ad82 d0 f1       BNE NEXT_40       ; if not "," go do interpreter inner loop
ad84 20 73 00    JSR CHRGET
ad87 20 24 ad    JSR Find_NEXT_Variable

              ; ************
ad8a            Eval_Numeric
              ; ************

ad8a 20 9e ad    JSR Eval_Expression

              ; **********
ad8d            Is_Numeric
              ; **********

ad8d 18          CLC
ad8e 24          .byte   $24       ; skip next byte

              ; ******************
ad8f            Assert_String_Type
              ; ******************

ad8f 38          SEC               ; string required

              ; **************
ad90            Check_Var_Type
              ; **************

ad90 24 0d       BIT VALTYP        ; test data type flag, $FF = string, $00 = numeric
ad92 30 03       BMI CVT_20        ; branch to string check
ad94 b0 03       BCS Type_Missmatch

ad96          CVT_10               ; OK
ad96 60          RTS ;Size    7 [Check_Var_Type]

ad97          CVT_20
ad97 b0 fd       BCS CVT_10        ; exit if string is required

ad99          Type_Missmatch
ad99 a2 16       LDX #$16          ; error code $16, type missmatch error
ad9b 4c 37 a4    JMP Basic_Error

              ; ***************
ad9e            Eval_Expression
              ; ***************

ad9e a6 7a       LDX TXTPTR        ; get BASIC execute pointer low byte
ada0 d0 02       BNE EvEx_05       ; skip next if not zero
ada2 c6 7b       DEC TXTPTR+1      ; else decrement BASIC execute pointer high byte

ada4          EvEx_05
ada4 c6 7a       DEC TXTPTR        ; decrement BASIC execute pointer low byte
ada6 a2 00       LDX #$00          ; set null precedence, flag done
ada8 24          .byte   $24       ; makes next line BIT VARPNT+1

ada9          EvEx_10
ada9 48          PHA               ; push compare evaluation byte if branch to here
adaa 8a          TXA               ; copy precedence byte
adab 48          PHA               ; push precedence byte
adac a9 01       LDA #$01          ; 2 bytes
adae 20 fb a3    JSR Check_Stack_Avail
adb1 20 83 ae    JSR Evaluate
adb4 a9 00       LDA #0
adb6 85 4d       STA ACCSYM        ; clear comparrison evaluation flag

adb8          EvEx_15
adb8 20 79 00    JSR CHRGOT

adbb          EvEx_20
adbb 38          SEC
adbc e9 b1       SBC #TK_GT        ; subtract token for ">"
adbe 90 17       BCC EvEx_25       ; if < ">" skip comparrison test check
adc0 c9 03       CMP #$03          ; compare with ">" to +3
adc2 b0 13       BCS EvEx_25       ; if >= 3 skip comparrison test check
adc4 c9 01       CMP #$01          ; compare with token for =
adc6 2a          ROL A             ; *2, b0 = carry (=1 if token was = or <)
adc7 49 01       EOR #$01          ; toggle b0
adc9 45 4d       EOR ACCSYM        ; EOR with comparrison evaluation flag
adcb c5 4d       CMP ACCSYM        ; compare with comparrison evaluation flag
adcd 90 61       BCC Jump_Syntax_Error      ; if < saved flag do syntax error then warm start
adcf 85 4d       STA ACCSYM        ; save new comparrison evaluation flag
add1 20 73 00    JSR CHRGET
add4 4c bb ad    JMP EvEx_20       ; go do next character

add7          EvEx_25
add7 a6 4d       LDX ACCSYM        ; get comparrison evaluation flag
add9 d0 2c       BNE EvEx_50       ; if compare function flagged go evaluate right hand side
addb b0 7b       BCS Right_Operand      ; apply operator
addd 69 07       ADC #$07          ; add # of operators (+, -, *, /, ^, AND or OR)
addf 90 77       BCC Right_Operand      ; if < + operator go do the function
ade1 65 0d       ADC VALTYP        ; add data type flag, $FF = string, $00 = numeric
ade3 d0 03       BNE EvEx_30       ; if not string or not + token skip concatenate
ade5 4c 3d b6    JMP Concatenate   ; add strings, string 1 is in the descriptor, string 2

ade8          EvEx_30
ade8 69 ff       ADC #$FF          ; -1 (corrects for carry add)
adea 85 22       STA INDEXA        ; save it
adec 0a          ASL A             ; *2
aded 65 22       ADC INDEXA        ; *3
adef a8          TAY               ; copy to index

adf0          EvEx_35
adf0 68          PLA               ; pull previous precedence
adf1 d9 80 a0    CMP Basic_Operator_Table,Y  ; compare with precedence byte
adf4 b0 67       BCS RiOp_20      ; if A >= go do the function
adf6 20 8d ad    JSR Is_Numeric

adf9          EvEx_40
adf9 48          PHA               ; save precedence

adfa          EvEx_45
adfa 20 20 ae    JSR Call_Operator_Function
adfd 68          PLA               ; restore precedence
adfe a4 4b       LDY YSAVE         ; get precedence stacked flag
ae00 10 17       BPL EvEx_60       ; if stacked values go check the precedence
ae02 aa          TAX               ; copy precedence, set flags
ae03 f0 56       BEQ RiOp_10      ; exit if done
ae05 d0 5f       BNE RiOp_40      ; else pop FAC2 and return, branch always

ae07          EvEx_50
ae07 46 0d       LSR VALTYP        ; clear data type flag, $FF = string, $00 = numeric
ae09 8a          TXA               ; copy compare function flag
ae0a 2a          ROL A             ; <<1, shift data type flag into b0, 1 = string, 0 = num
ae0b a6 7a       LDX TXTPTR        ; get BASIC execute pointer low byte
ae0d d0 02       BNE EvEx_55       ; if no underflow skip the high byte decrement
ae0f c6 7b       DEC TXTPTR+1      ; else decrement BASIC execute pointer high byte

ae11          EvEx_55
ae11 c6 7a       DEC TXTPTR        ; decrement BASIC execute pointer low byte
ae13 a0 1b       LDY #$1B          ; set offset to = operator precedence entry
ae15 85 4d       STA ACCSYM        ; save new comparrison evaluation flag
ae17 d0 d7       BNE EvEx_35       ; branch always

ae19          EvEx_60
ae19 d9 80 a0    CMP Basic_Operator_Table,Y  ; compare with stacked function precedence
ae1c b0 48       BCS RiOp_40      ; if A >=, pop FAC2 and return
ae1e 90 d9       BCC EvEx_40       ; else go stack this one and continue, branch always

              ; **********************
ae20            Call_Operator_Function
              ; **********************

ae20 b9 82 a0    LDA Basic_Operator_Table+2,Y
ae23 48          PHA
ae24 b9 81 a0    LDA Basic_Operator_Table+1,Y
ae27 48          PHA
ae28 20 33 ae    JSR Apply_Operator
ae2b a5 4d       LDA ACCSYM        ; get comparrison evaluation flag
ae2d 4c a9 ad    JMP EvEx_10       ; continue evaluating expression

ae30          Jump_Syntax_Error
ae30 4c 08 af    JMP Syntax_Error

              ; **************
ae33            Apply_Operator
              ; **************

ae33 a5 66       LDA FAC1SI        ; get FAC1 sign (b7)
ae35 be 80 a0    LDX Basic_Operator_Table,Y  ; get precedence byte

              ; *********
ae38            Push_FAC1
              ; *********

ae38 a8          TAY               ; copy sign
ae39 68          PLA               ; get return address low byte
ae3a 85 22       STA INDEXA        ; save it
ae3c e6 22       INC INDEXA        ; increment it as return-1 is pushed
ae3e 68          PLA               ; get return address high byte
ae3f 85 23       STA INDEXA+1      ; save it
ae41 98          TYA               ; restore sign
ae42 48          PHA               ; push sign

              ; ===================
ae43            Round_And_Push_FAC1
              ; ===================

ae43 20 1b bc    JSR Round_FAC1_Checked
                 PUSHW(FAC1M3)     ; push mantissa 4 & 3
ae46 a5 65       LDA FAC1M3+1
ae48 48          PHA
ae49 a5 64       LDA FAC1M3
ae4b 48          PHA

                 PUSHW(FAC1M1)     ; push mantissa 2 & 1
ae4c a5 63       LDA FAC1M1+1
ae4e 48          PHA
ae4f a5 62       LDA FAC1M1
ae51 48          PHA

ae52 a5 61       LDA FAC1EX        ; get FAC1 exponent
ae54 48          PHA               ; push it
ae55 6c 22 00    JMP (INDEXA)      ; return, sort of

              ; =============
ae58            Right_Operand
              ; =============

ae58 a0 ff       LDY #$FF          ; flag function
ae5a 68          PLA               ; pull precedence byte

ae5b          RiOp_10
ae5b f0 23       BEQ RiOp_50       ; exit if done

ae5d          RiOp_20
ae5d c9 64       CMP #$64          ; compare previous precedence with $64
ae5f f0 03       BEQ RiOp_30       ; if was $64 (< function) skip the type check
ae61 20 8d ad    JSR Is_Numeric

ae64          RiOp_30
ae64 84 4b       STY YSAVE         ; save precedence stacked flag

ae66          RiOp_40
ae66 68          PLA               ; pop byte
ae67 4a          LSR A             ; shift out comparison evaluation lowest bit
ae68 85 12       STA TANSGN        ; save the comparison evaluation flag
ae6a 68          PLA               ; pop exponent
ae6b 85 69       STA FAC2EX        ; save FAC2 exponent
                 PULLW(FAC2M1)     ; pull FAC2 mantissa 1 & 2
ae6d 68          PLA
ae6e 85 6a       STA FAC2M1
ae70 68          PLA
ae71 85 6b       STA FAC2M1+1

                 PULLW(FAC2M3)     ; pull FAC2 mantissa 3 & 4
ae73 68          PLA
ae74 85 6c       STA FAC2M3
ae76 68          PLA
ae77 85 6d       STA FAC2M3+1

ae79 68          PLA               ; pop sign
ae7a 85 6e       STA FAC2SI        ; save FAC2 sign (b7)
ae7c 45 66       EOR FAC1SI        ; EOR FAC1 sign (b7)
ae7e 85 6f       STA STRPTR        ; save sign compare (FAC1 EOR FAC2)

ae80          RiOp_50
ae80 a5 61       LDA FAC1EX        ; get FAC1 exponent
ae82 60          RTS ;Size   75 [Push_FAC1]

              ; ********
ae83            Evaluate
              ; ********

ae83 6c 0a 03    JMP (IEVAL)       ; normally Default_EVAL

              ; ************
ae86            Default_EVAL
              ; ************

ae86 a9 00       LDA #0
ae88 85 0d       STA VALTYP        ; clear data type flag, $FF = string, $00 = numeric

ae8a          EVA_10
ae8a 20 73 00    JSR CHRGET
ae8d b0 03       BCS EVA_30        ; if not numeric character continue

ae8f          EVA_20
ae8f 4c f3 bc    JMP Load_FAC1_From_String

ae92          EVA_30
ae92 20 13 b1    JSR Is_Alpha
ae95 90 03       BCC EVA_40
ae97 4c 28 af    JMP Get_Var       ; variable name set-up and return

ae9a          EVA_40
ae9a c9 ff       CMP #TK_PI
ae9c d0 0f       BNE EVA_50        ; if not PI continue
                 LAYI(Float_PI)
ae9e a9 a8       LDA #<Float_PI
aea0 a0 ae       LDY #>Float_PI

aea2 20 a2 bb    JSR Load_FAC1_AY
aea5 4c 73 00    JMP CHRGET

aea8 82 49 0f Float_PI .real 3.141592653

aead          EVA_50
aead c9 2e       CMP #'.'
aeaf f0 de       BEQ EVA_20        ; if so get FAC1 from string and return, e.g. was .123
aeb1 c9 ab       CMP #TK_MINUS
aeb3 f0 58       BEQ Prep_Minus_Operation
aeb5 c9 aa       CMP #TK_PLUS
aeb7 f0 d1       BEQ EVA_10        ; if + token ignore the leading +, +1 = 1
aeb9 c9 22       CMP #QUOTE
aebb d0 0f       BNE EVA_70        ; if not open quote continue

              ; ********************************
aebd            Make_String_Descriptor_From_Code
              ; ********************************

                 LDAY(TXTPTR)      ; get BASIC execute pointer
aebd a5 7a       LDA TXTPTR
aebf a4 7b       LDY TXTPTR+1

aec1 69 00       ADC #0            ; add carry to low byte
aec3 90 01       BCC EVA_60        ; branch if no overflow
aec5 c8          INY               ; increment high byte

aec6          EVA_60
aec6 20 87 b4    JSR Create_String_Descriptor
aec9 4c e2 b7    JMP Restore_Execution_Pointer

aecc          EVA_70
aecc c9 a8       CMP #TK_NOT       ; compare with token for NOT
aece d0 13       BNE EVA_80        ; if not token for NOT continue
aed0 a0 18       LDY #$18          ; offset to NOT function
aed2 d0 3b       BNE Prep_Operation      ; do set-up for function then execute, branch always

              ; ***********
aed4            Basic_EQUAL
              ; ***********

aed4 20 bf b1    JSR Eval_Integer
aed7 a5 65       LDA FAC1M4        ; get FAC1 mantissa 4
aed9 49 ff       EOR #$FF          ; invert it
aedb a8          TAY               ; copy it
aedc a5 64       LDA FAC1M3        ; get FAC1 mantissa 3
aede 49 ff       EOR #$FF          ; invert it
aee0 4c 91 b3    JMP Integer_To_Float

aee3          EVA_80
aee3 c9 a5       CMP #TK_FN        ; compare with token for FN
aee5 d0 03       BNE EVA_90        ; if not token for FN continue
aee7 4c f4 b3    JMP Eval_FNX      ; else go evaluate FNx

aeea          EVA_90
aeea c9 b4       CMP #TK_SGN       ; compare with token for SGN
aeec 90 03       BCC Eval_In_Parenthesis
aeee 4c a7 af    JMP Function_Call

              ; *******************
aef1            Eval_In_Parenthesis
              ; *******************

aef1 20 fa ae    JSR Need_Left_Parenthesis
aef4 20 9e ad    JSR Eval_Expression

              ; **********************
aef7            Need_Right_Parenthesis
              ; **********************

aef7 a9 29       LDA #')'
aef9 2c          .byte   $2C       ; skip until Need_A

              ; *********************
aefa            Need_Left_Parenthesis
              ; *********************

aefa a9 28       LDA #'('
aefc 2c          .byte   $2C       ; skip until Need_A

              ; **********
aefd            Need_Comma
              ; **********

aefd a9 2c       LDA #','

              ; ******
aeff            Need_A
              ; ******

aeff a0 00       LDY #0
af01 d1 7a       CMP (TXTPTR),Y    ; compare with BASIC byte
af03 d0 03       BNE Syntax_Error
af05 4c 73 00    JMP CHRGET        ; else next program byte and return

              ; ============
af08            Syntax_Error
              ; ============

af08 a2 0b       LDX #$0B          ; error code $0B, syntax error
af0a 4c 37 a4    JMP Basic_Error

              ; ====================
af0d            Prep_Minus_Operation
              ; ====================

af0d a0 15       LDY #$15          ; set offset from base to > operator

af0f          Prep_Operation
af0f 68          PLA               ; dump return address low byte
af10 68          PLA               ; dump return address high byte
af11 4c fa ad    JMP EvEx_45      ; execute function then continue evaluation

              ; *******************
af14            Is_Inside_BASIC_ROM
              ; *******************

af14 38          SEC
af15 a5 64       LDA FAC1M3        ; get variable address low byte
af17 e9 00       SBC #<BASIC_ROM   ; subtract BASIC_ROM low byte
af19 a5 65       LDA FAC1M4        ; get variable address high byte
af1b e9 a0       SBC #>BASIC_ROM   ; subtract BASIC_ROM high byte
af1d 90 08       BCC IIBR_Ret      ; exit if address < BASIC_ROM
af1f a9 a2       LDA #<CHRGET_ROM  ; get end of BASIC marker low byte
af21 e5 64       SBC FAC1M3        ; subtract variable address low byte
af23 a9 e3       LDA #>CHRGET_ROM  ; get end of BASIC marker high byte
af25 e5 65       SBC FAC1M4        ; subtract variable address high byte

af27          IIBR_Ret
af27 60          RTS ;Size   20 [Is_Inside_BASIC_ROM]

              ; =======
af28            Get_Var
              ; =======

af28 20 8b b0    JSR Get_Scalar_Address
                 STAY(FAC1M3)      ; save variable pointer low byte
af2b 85 64       STA FAC1M3
af2d 84 65       STY FAC1M3+1

                 LDXY(VARNAM)      ; get current variable name first character
af2f a6 45       LDX VARNAM
af31 a4 46       LDY VARNAM+1

af33 a5 0d       LDA VALTYP        ; get data type flag, $FF = string, $00 = numeric
af35 f0 26       BEQ Load_Value    ; if numeric go handle a numeric variable
af37 a9 00       LDA #0
af39 85 70       STA FAC1M5        ; clear FAC1 rounding byte
af3b 20 14 af    JSR Is_Inside_BASIC_ROM
af3e 90 1c       BCC GeVa_Ret      ; exit if not in BASIC ROM
af40 e0 54       CPX #'T'          ; compare variable name first character with "T"
af42 d0 18       BNE GeVa_Ret      ; exit if not "T"
af44 c0 c9       CPY #'I'+$80      ; compare variable name second character with "I$"
af46 d0 14       BNE GeVa_Ret      ; exit if not "I$"
af48 20 84 af    JSR Load_Jiffyclock
af4b 84 5e       STY TMPVA2        ; clear exponent count adjust
af4d 88          DEY               ; Y = $FF
af4e 84 71       STY TMPPTD        ; set output string index, -1 to allow for pre increment
af50 a0 06       LDY #6            ; HH:MM:SS is six digits
af52 84 5d       STY TMPVA1        ; set number of characters before the decimal point
af54 a0 24       LDY #Jiffy_Conversion_Table-Decimal_Conversion_Table
af56 20 68 be    JSR Format_Jiffyclock
af59 4c 6f b4    JMP BaST_10      ; exit via STR$() code tail

af5c          GeVa_Ret
af5c 60          RTS ;Size   73 [Is_Inside_BASIC_ROM]

              ; ==========
af5d            Load_Value
              ; ==========

af5d 24 0e       BIT INTFLG        ; test data type flag, $80 = integer, $00 = float
af5f 10 0d       BPL Load_Float    ; if float go handle float
af61 a0 00       LDY #0
af63 b1 64       LDA (FAC1M3),Y    ; get integer variable low byte
af65 aa          TAX               ; copy to X
af66 c8          INY
af67 b1 64       LDA (FAC1M3),Y    ; get integer variable high byte
af69 a8          TAY               ; copy to Y
af6a 8a          TXA               ; copy loa byte to A
af6b 4c 91 b3    JMP Integer_To_Float

              ; ==========
af6e            Load_Float
              ; ==========

af6e 20 14 af    JSR Is_Inside_BASIC_ROM
af71 90 2d       BCC Load_Float_Var ; if not get pointer and unpack into FAC1
af73 e0 54       CPX #'T'
af75 d0 1b       BNE Check_ST_Var
af77 c0 49       CPY #'I'          ; is it "TI" ?
af79 d0 25       BNE Load_Float_Var
af7b 20 84 af    JSR Load_Jiffyclock
af7e 98          TYA               ; clear A
af7f a2 a0       LDX #$A0          ; set exponent to 32 bit value
af81 4c 4f bc    JMP CITF_10       ; set exponent = X and normalise FAC1

              ; ***************
af84            Load_Jiffyclock
              ; ***************

af84 20 d8 ff    JSR RDTIM         ; Read system clock
af87 86 64       STX FAC1M3        ; save jiffy clock mid byte as  FAC1 mantissa 3
af89 84 63       STY FAC1M2        ; save jiffy clock high byte as  FAC1 mantissa 2
af8b 85 65       STA FAC1M4        ; save jiffy clock low byte as  FAC1 mantissa 4
af8d a0 00       LDY #$00          ; clear Y
af8f 84 62       STY FAC1M1        ; clear FAC1 mantissa 1
af91 60          RTS ;Size   14 [Load_Jiffyclock]

              ; ============
af92            Check_ST_Var
              ; ============

af92 e0 53       CPX #'S'
af94 d0 0a       BNE Load_Float_Var
af96 c0 54       CPY #'T'          ; is it "ST" ?
af98 d0 06       BNE Load_Float_Var
af9a 20 b1 ff    JSR READST
af9d 4c 3c bc    JMP A_To_FAC1

              ; ==============
afa0            Load_Float_Var
              ; ==============

                 LDAY(FAC1M3)      ; get variable pointer
afa0 a5 64       LDA FAC1M3
afa2 a4 65       LDY FAC1M3+1

afa4 4c a2 bb    JMP Load_FAC1_AY

              ; =============
afa7            Function_Call
              ; =============

afa7 0a          ASL A             ; offset = 2 * (token  - $80) : bit 7 shifted out
afa8 48          PHA               ; save function offset
afa9 aa          TAX               ; copy function offset
afaa 20 73 00    JSR CHRGET
afad e0 8f       CPX #[[TK_CHRS - $80] * 2] + 1 ; chr$ index + 1
afaf 90 20       BCC FuCa_10       ; branch if not left$, right$, mid$
afb1 20 fa ae    JSR Need_Left_Parenthesis
afb4 20 9e ad    JSR Eval_Expression
afb7 20 fd ae    JSR Need_Comma
afba 20 8f ad    JSR Assert_String_Type
afbd 68          PLA               ; restore function offset
afbe aa          TAX               ; copy it
                 PUSHW(FAC1M3)     ; push string pointer
afbf a5 65       LDA FAC1M3+1
afc1 48          PHA
afc2 a5 64       LDA FAC1M3
afc4 48          PHA

afc5 8a          TXA               ; restore function offset
afc6 48          PHA               ; save function offset
afc7 20 9e b7    JSR Get_Byte_Value
afca 68          PLA               ; restore function offset
afcb a8          TAY               ; copy function offset
afcc 8a          TXA               ; copy byte parameter to A
afcd 48          PHA               ; push byte parameter
afce 4c d6 af    JMP FuCa_20       ; go call function

afd1          FuCa_10
afd1 20 f1 ae    JSR Eval_In_Parenthesis
afd4 68          PLA               ; restore function offset
afd5 a8          TAY               ; copy to index

afd6          FuCa_20
afd6 b9 ea 9f    LDA Basic_Function_Table-2*[TK_SGN-$80],Y    ; .. -$68
afd9 85 55       STA FUNJMP
afdb b9 eb 9f    LDA Basic_Function_Table-2*[TK_SGN-$80]+1,Y  ; .. -$67
afde 85 56       STA FUNJMP+1
afe0 20 54 00    JSR JUMPER
afe3 4c 8d ad    JMP Is_Numeric

              ; ********
afe6            Basic_OR
              ; ********

afe6 a0 ff       LDY #$FF          ; set Y for OR
afe8 2c          .byte   $2C       ; skip next statement

              ; *********
afe9            Basic_AND
              ; *********

afe9 a0 00       LDY #$00          ; clear Y for AND
afeb 84 0b       STY COUNT         ; set AND/OR invert value
afed 20 bf b1    JSR Eval_Integer
aff0 a5 64       LDA FAC1M3        ; get FAC1 mantissa 3
aff2 45 0b       EOR COUNT         ; EOR low byte
aff4 85 07       STA CHARAC        ; save it
aff6 a5 65       LDA FAC1M4        ; get FAC1 mantissa 4
aff8 45 0b       EOR COUNT         ; EOR high byte
affa 85 08       STA ENDCHR        ; save it
affc 20 fc bb    JSR FAC2_To_FAC1
afff 20 bf b1    JSR Eval_Integer
b002 a5 65       LDA FAC1M4        ; get FAC1 mantissa 4
b004 45 0b       EOR COUNT         ; EOR high byte
b006 25 08       AND ENDCHR        ; AND with expression 1 high byte
b008 45 0b       EOR COUNT         ; EOR result high byte
b00a a8          TAY               ; save in Y
b00b a5 64       LDA FAC1M3        ; get FAC1 mantissa 3
b00d 45 0b       EOR COUNT         ; EOR low byte
b00f 25 07       AND CHARAC        ; AND with expression 1 low byte
b011 45 0b       EOR COUNT         ; EOR result low byte
b013 4c 91 b3    JMP Integer_To_Float

              ; **********
b016            Basic_LESS
              ; **********

b016 20 90 ad    JSR Check_Var_Type
b019 b0 13       BCS BaLE_10       ; if string go do string compare
b01b a5 6e       LDA FAC2SI        ; get FAC2 sign (b7)
b01d 09 7f       ORA #$7F          ; set all non sign bits
b01f 25 6a       AND FAC2M1        ; and FAC2 mantissa 1 (AND in sign bit)
b021 85 6a       STA FAC2M1        ; save FAC2 mantissa 1
                 LAYI(FAC2EX)
b023 a9 69       LDA #<FAC2EX
b025 a0 00       LDY #>FAC2EX

b027 20 5b bc    JSR Compare_FAC1_AY
b02a aa          TAX               ; copy the result
b02b 4c 61 b0    JMP BaLE_40       ; go evaluate result

b02e          BaLE_10              ; compare strings
b02e a9 00       LDA #0
b030 85 0d       STA VALTYP        ; clear data type flag, $FF = string, $00 = numeric
b032 c6 4d       DEC ACCSYM        ; clear < bit in comparrison evaluation flag
b034 20 a6 b6    JSR Get_String_Descriptor
b037 85 61       STA FAC1EX        ; save length
b039 86 62       STX FAC1M1        ; save string pointer low byte
b03b 84 63       STY FAC1M2        ; save string pointer high byte
b03d a5 6c       LDA FAC2M3        ; get descriptor pointer low byte
b03f a4 6d       LDY FAC2M4        ; get descriptor pointer high byte
b041 20 aa b6    JSR Get_String_Descriptor_AY
b044 86 6c       STX FAC2M3        ; save string pointer low byte
b046 84 6d       STY FAC2M4        ; save string pointer high byte
b048 aa          TAX               ; copy length
b049 38          SEC
b04a e5 61       SBC FAC1EX        ; subtract string 1 length
b04c f0 08       BEQ BaLE_20       ; if str 1 length = string 2 length go compare the strings
b04e a9 01       LDA #1            ; set str 1 length > string 2 length
b050 90 04       BCC BaLE_20       ; if so return + 1 if otherwise equal
b052 a6 61       LDX FAC1EX        ; get string 1 length
b054 a9 ff       LDA #$FF          ; set str 1 length < string 2 length

b056          BaLE_20
b056 85 66       STA FAC1SI        ; save length compare
b058 a0 ff       LDY #$FF          ; set index
b05a e8          INX               ; adjust for loop

b05b          BaLE_30
b05b c8          INY
b05c ca          DEX               ; decrement count
b05d d0 07       BNE BaLE_50       ; if still bytes to do go compare them
b05f a6 66       LDX FAC1SI        ; get length compare back

b061          BaLE_40
b061 30 0f       BMI BaLE_60       ; branch if str 1 < str 2
b063 18          CLC               ; flag str 1 <= str 2
b064 90 0c       BCC BaLE_60       ; go evaluate result, branch always

b066          BaLE_50
b066 b1 6c       LDA (FAC2M3),Y    ; get string 2 byte
b068 d1 62       CMP (FAC1M1),Y    ; compare with string 1 byte
b06a f0 ef       BEQ BaLE_30       ; loop if bytes =
b06c a2 ff       LDX #$FF          ; set str 1 < string 2
b06e b0 02       BCS BaLE_60       ; branch if so

b070 a2 01       LDX #$01          ; set str 1 > string 2
b072          BaLE_60
b072 e8          INX               ; x = 0, 1 or 2
b073 8a          TXA               ; copy to A
b074 2a          ROL A             ; * 2 (1, 2 or 4)
b075 25 12       AND TANSGN        ; AND with the comparison evaluation flag
b077 f0 02       BEQ BaLE_70       ; branch if 0 (compare is false)

b079 a9 ff       LDA #$FF          ; else set result true
b07b          BaLE_70
b07b 4c 3c bc    JMP A_To_FAC1

b07e          DIM_00
b07e 20 fd ae    JSR Need_Comma

              ; *********
b081            Basic_DIM
              ; *********

b081 aa          TAX               ; copy "DIM" flag to X
b082 20 90 b0    JSR Get_Array_Address
b085 20 79 00    JSR CHRGOT
b088 d0 f4       BNE DIM_00      ; scan for "," and loop if not null
b08a 60          RTS ;Size   10 [Basic_DIM]

              ; ******************
b08b            Get_Scalar_Address
              ; ******************

b08b a2 00       LDX #$00          ; set DIM flag = $00
b08d 20 79 00    JSR CHRGOT        ; 1st. character

              ; -----------------
b090            Get_Array_Address
              ; -----------------

b090 86 0c       STX DIMFLG        ; save DIM flag

              ; --------------
b092            Get_FN_Address
              ; --------------

b092 85 45       STA VARNAM        ; save 1st character
b094 20 79 00    JSR CHRGOT
b097 20 13 b1    JSR Is_Alpha
b09a b0 03       BCS Get_Address      ; if ok continue

b09c          Var_Syntax_Error
b09c 4c 08 af    JMP Syntax_Error

              ; ===========
b09f            Get_Address
              ; ===========

b09f a2 00       LDX #0            ; clear 2nd character temp
b0a1 86 0d       STX VALTYP        ; clear data type flag, $FF = string, $00 = numeric
b0a3 86 0e       STX INTFLG        ; clear data type flag, $80 = integer, $00 = float
b0a5 20 73 00    JSR CHRGET        ; 2nd character
b0a8 90 05       BCC GAdd_05       ; if character = "0"-"9" (ok) go save 2nd character
b0aa 20 13 b1    JSR Is_Alpha
b0ad 90 0b       BCC GAdd_15       ; if <"A" or >"Z" go check if string

b0af          GAdd_05
b0af aa          TAX               ; copy 2nd character

b0b0          GAdd_10
b0b0 20 73 00    JSR CHRGET        ; 3rd character
b0b3 90 fb       BCC GAdd_10       ; loop if character = "0"-"9" (ignore)
b0b5 20 13 b1    JSR Is_Alpha
b0b8 b0 f6       BCS GAdd_10       ; loop if character = "A"-"Z" (ignore)

b0ba          GAdd_15
b0ba c9 24       CMP #'$'
b0bc d0 06       BNE GAdd_20       ; if not string go check integer
b0be a9 ff       LDA #$FF          ; set data type = string
b0c0 85 0d       STA VALTYP        ; set data type flag, $FF = string, $00 = numeric
b0c2 d0 10       BNE GAdd_25       ; branch always

b0c4          GAdd_20
b0c4 c9 25       CMP #'%'
b0c6 d0 13       BNE GAdd_30       ; if not integer go check for an array
b0c8 a5 10       LDA SUBFLG        ; get subscript/FNX flag
b0ca d0 d0       BNE Var_Syntax_Error      ; if ?? do syntax error then warm start
b0cc a9 80       LDA #$80          ; set integer type
b0ce 85 0e       STA INTFLG        ; set data type = integer
b0d0 05 45       ORA VARNAM        ; OR current variable name first byte
b0d2 85 45       STA VARNAM        ; save current variable name first byte

b0d4          GAdd_25
b0d4 8a          TXA               ; get 2nd character back
b0d5 09 80       ORA #$80          ; set top bit, indicate string or integer variable
b0d7 aa          TAX               ; copy back to 2nd character temp
b0d8 20 73 00    JSR CHRGET

b0db          GAdd_30
b0db 86 46       STX VARNAM+1      ; save 2nd character
b0dd 38          SEC
b0de 05 10       ORA SUBFLG        ; or with subscript/FNX flag - or FN name
b0e0 e9 28       SBC #'('
b0e2 d0 03       BNE GAdd_35       ; if not "(" go find a plain numeric variable
b0e4 4c d1 b1    JMP Find_Array

b0e7          GAdd_35
b0e7 a0 00       LDY #0
b0e9 84 10       STY SUBFLG        ; clear subscript/FNX flag
                 LDAX(VARTAB)      ; get start of variables
b0eb a5 2d       LDA VARTAB
b0ed a6 2e       LDX VARTAB+1


b0ef          GAdd_40
b0ef 86 60       STX TMPPTC+1      ; save search address high byte

b0f1          GAdd_45
b0f1 85 5f       STA TMPPTC        ; save search address low byte
b0f3 e4 30       CPX ARYTAB+1      ; compare with end of variables high byte
b0f5 d0 04       BNE GAdd_50       ; skip next compare if <>
b0f7 c5 2f       CMP ARYTAB        ; compare low address with end of variables low byte
b0f9 f0 22       BEQ Create_Var      ; if not found go make new variable

b0fb          GAdd_50
b0fb a5 45       LDA VARNAM        ; get 1st character of variable to find
b0fd d1 5f       CMP (TMPPTC),Y    ; compare with variable name 1st character
b0ff d0 08       BNE GAdd_55       ; if no match go try the next variable
b101 a5 46       LDA VARNAM+1      ; get 2nd character of variable to find
b103 c8          INY               ; index to point to variable name 2nd character
b104 d1 5f       CMP (TMPPTC),Y    ; compare with variable name 2nd character
b106 f0 7d       BEQ CrVa_70      ; if match go return the variable
b108 88          DEY               ; else decrement index (now = $00)

b109          GAdd_55
b109 18          CLC
b10a a5 5f       LDA TMPPTC        ; get search address low byte
b10c 69 07       ADC #7            ; +7, offset to next variable name
b10e 90 e1       BCC GAdd_45       ; loop if no overflow to high byte
b110 e8          INX               ; else increment high byte
b111 d0 dc       BNE GAdd_40       ; loop always, RAM doesn't extend to $FFFF

              ; ********
b113            Is_Alpha
              ; ********

b113 c9 41       CMP #'A'
b115 90 05       BCC IA_RET
b117 e9 5b       SBC #$5B          ; subtract "Z"+1
b119 38          SEC
b11a e9 a5       SBC #$A5          ; subtract $A5 (restore byte)
                                   ; carry clear if byte > $5A
b11c          IA_RET
b11c 60          RTS ;Size   10 [Is_Alpha]

              ; ==========
b11d            Create_Var
              ; ==========

b11d 68          PLA               ; pop return address low byte
b11e 48          PHA               ; push return address low byte
b11f c9 2a       CMP #<[Get_Var+2] ; compare with expected calling routine return low byte
b121 d0 05       BNE CrVa_20       ; if not get variable go create new variable

              ; this will only drop through if the call was from Get_Var and is only
              ; called from there if it is searching for a variable from the right
              ; hand side of a LET a=b statement, it prevents the creation of
              ; variables not assigned a value. value returned by this is either
              ; numeric zero, exponent byte is 0, or null string, descriptor length
              ; byte is 0. in fact a pointer to any 0 byte would have done.

b123          CrVa_10
                 LAYI(NULL_Descriptor)
b123 a9 13       LDA #<NULL_Descriptor
b125 a0 bf       LDY #>NULL_Descriptor

b127 60          RTS ;Size   21 [Is_Alpha]

b128          CrVa_20
                 LDAY(VARNAM)      ; get variable name first character
b128 a5 45       LDA VARNAM
b12a a4 46       LDY VARNAM+1

b12c c9 54       CMP #'T'
b12e d0 0b       BNE CrVa_40
b130 c0 c9       CPY #'I'+$80      ; is it TI$ ?
b132 f0 ef       BEQ CrVa_10
b134 c0 49       CPY #'I'
b136 d0 03       BNE CrVa_40       ; is it TI ?

b138          CrVa_30
b138 4c 08 af    JMP Syntax_Error

b13b          CrVa_40
b13b c9 53       CMP #'S'          ; compare first character with "S"
b13d d0 04       BNE CrVa_50      ; if not "S" continue
b13f c0 54       CPY #'T'          ; compare second character with "T"
b141 f0 f5       BEQ CrVa_30       ; if name is "ST" do syntax error

b143          CrVa_50
                 LDAY(ARYTAB)
b143 a5 2f       LDA ARYTAB
b145 a4 30       LDY ARYTAB+1

                 STAY(TMPPTC)
b147 85 5f       STA TMPPTC
b149 84 60       STY TMPPTC+1

                 LDAY(STREND)
b14b a5 31       LDA STREND
b14d a4 32       LDY STREND+1

                 STAY(TMPPTB)      ; save old block end
b14f 85 5a       STA TMPPTB
b151 84 5b       STY TMPPTB+1

b153 18          CLC
b154 69 07       ADC #7            ; +7, space for one variable
b156 90 01       BCC CrVa_60       ; if no overflow skip the high byte increment
b158 c8          INY               ; else increment high byte

b159          CrVa_60
                 STAY(TMPPTA)      ; set new block end
b159 85 58       STA TMPPTA
b15b 84 59       STY TMPPTA+1

b15d 20 b8 a3    JSR Open_Up_Space
                 LDAY(TMPPTA)      ; get new start
b160 a5 58       LDA TMPPTA
b162 a4 59       LDY TMPPTA+1

b164 c8          INY               ; correct high byte
                 STAY(ARYTAB)      ; set end of variables
b165 85 2f       STA ARYTAB
b167 84 30       STY ARYTAB+1

b169 a0 00       LDY #0
b16b a5 45       LDA VARNAM        ; get variable name 1st character
b16d 91 5f       STA (TMPPTC),Y    ; save variable name 1st character
b16f c8          INY
b170 a5 46       LDA VARNAM+1      ; get variable name 2nd character
b172 91 5f       STA (TMPPTC),Y    ; save variable name 2nd character
b174 a9 00       LDA #0
b176 c8          INY
b177 91 5f       STA (TMPPTC),Y    ; initialise variable byte
b179 c8          INY
b17a 91 5f       STA (TMPPTC),Y    ; initialise variable byte
b17c c8          INY
b17d 91 5f       STA (TMPPTC),Y    ; initialise variable byte
b17f c8          INY
b180 91 5f       STA (TMPPTC),Y    ; initialise variable byte
b182 c8          INY
b183 91 5f       STA (TMPPTC),Y    ; initialise variable byte

b185          CrVa_70
b185 a5 5f       LDA TMPPTC        ; get variable address low byte
b187 18          CLC
b188 69 02       ADC #$02          ; +2, offset past variable name bytes
b18a a4 60       LDY TMPPTC+1      ; get variable address high byte
b18c 90 01       BCC CrVa_80       ; if no overflow skip the high byte increment
b18e c8          INY               ; else increment high byte

b18f          CrVa_80
                 STAY(VARPNT)
b18f 85 47       STA VARPNT
b191 84 48       STY VARPNT+1

b193 60          RTS ;Size  129 [Is_Alpha]

              ; **********************
b194            Array_Pointer_To_First
              ; **********************

b194 a5 0b       LDA COUNT         ; get # of dimensions (1, 2 or 3)
b196 0a          ASL A             ; *2 (also clears the carry !)
b197 69 05       ADC #$05          ; +5 (result is 7, 9 or 11 here)
b199 65 5f       ADC TMPPTC        ; add array start pointer low byte
b19b a4 60       LDY TMPPTC+1      ; get array pointer high byte
b19d 90 01       BCC APTF_10       ; if no overflow skip the high byte increment
b19f c8          INY               ; else increment high byte

b1a0          APTF_10
                 STAY(TMPPTA)      ; save array data pointer
b1a0 85 58       STA TMPPTA
b1a2 84 59       STY TMPPTA+1

b1a4 60          RTS ;Size   17 [Array_Pointer_To_First]

b1a5 90 80 00 Float_M32768 .real -32768

              ; ****************
b1aa            Float_To_Integer
              ; ****************

b1aa 20 bf b1    JSR Eval_Integer
b1ad a5 64       LDA FAC1M3        ; get result low byte
b1af a4 65       LDY FAC1M4        ; get result high byte
b1b1 60          RTS ;Size    8 [Float_To_Integer]

              ; *********************
b1b2            Eval_Positive_Integer
              ; *********************

b1b2 20 73 00    JSR CHRGET
b1b5 20 9e ad    JSR Eval_Expression

              ; ***************************
b1b8            Eval_Positive_Integer_Check
              ; ***************************

b1b8 20 8d ad    JSR Is_Numeric
b1bb a5 66       LDA FAC1SI        ; get FAC1 sign (b7)
b1bd 30 0d       BMI EvIn_10       ; do illegal quantity error negative

              ; evaluate integer expression, no sign check

              ; ************
b1bf            Eval_Integer
              ; ************

b1bf a5 61       LDA FAC1EX        ; get FAC1 exponent
b1c1 c9 90       CMP #$90          ; compare with exponent = 2^16 (n>2^15)
b1c3 90 09       BCC EvIn_20       ; if n<2^16 go convert FAC1 floating to fixed and return
                 LAYI(Float_M32768); set pointer -32768
b1c5 a9 a5       LDA #<Float_M32768
b1c7 a0 b1       LDY #>Float_M32768

b1c9 20 5b bc    JSR Compare_FAC1_AY

b1cc          EvIn_10
b1cc d0 7a       BNE Illegal_Quantity

b1ce          EvIn_20
b1ce 4c 9b bc    JMP FAC1_To_Integer

              ; **********
b1d1            Find_Array
              ; **********

b1d1 a5 0c       LDA DIMFLG        ; get DIM flag
b1d3 05 0e       ORA INTFLG        ; OR with data type flag
b1d5 48          PHA               ; push it
b1d6 a5 0d       LDA VALTYP        ; get data type flag, $FF = string, $00 = numeric
b1d8 48          PHA               ; push it
b1d9 a0 00       LDY #0            ; clear dimensions count

b1db          FiAr_05              ; get the array dimensions and stack them
b1db 98          TYA               ; copy dimensions count
b1dc 48          PHA               ; save it
                 PUSHW(VARNAM)     ; push array name
b1dd a5 46       LDA VARNAM+1
b1df 48          PHA
b1e0 a5 45       LDA VARNAM
b1e2 48          PHA

b1e3 20 b2 b1    JSR Eval_Positive_Integer
                 PULLW(VARNAM)     ; pull array name
b1e6 68          PLA
b1e7 85 45       STA VARNAM
b1e9 68          PLA
b1ea 85 46       STA VARNAM+1

b1ec 68          PLA               ; pull dimensions count
b1ed a8          TAY               ; restore it
b1ee ba          TSX               ; copy stack pointer
b1ef bd 02 01    LDA STACK+2,X     ; get DIM flag
b1f2 48          PHA               ; push it
b1f3 bd 01 01    LDA STACK+1,X     ; get data type flag
b1f6 48          PHA               ; push it
b1f7 a5 64       LDA FAC1M3        ; get this dimension size high byte
b1f9 9d 02 01    STA STACK+2,X     ; stack before flag bytes
b1fc a5 65       LDA FAC1M4        ; get this dimension size low byte
b1fe 9d 01 01    STA STACK+1,X     ; stack before flag bytes
b201 c8          INY               ; increment dimensions count
b202 20 79 00    JSR CHRGOT
b205 c9 2c       CMP #','
b207 f0 d2       BEQ FiAr_05       ; if found go do next dimension
b209 84 0b       STY COUNT         ; store dimensions count
b20b 20 f7 ae    JSR Need_Right_Parenthesis
b20e 68          PLA               ; pull data type flag
b20f 85 0d       STA VALTYP        ; restore data type flag, $FF = string, $00 = numeric
b211 68          PLA               ; pull data type flag
b212 85 0e       STA INTFLG        ; restore data type flag, $80 = integer, $00 = float
b214 29 7f       AND #$7F          ; mask dim flag
b216 85 0c       STA DIMFLG        ; restore DIM flag
b218 a6 2f       LDX ARYTAB        ; set end of variables low byte
b21a a5 30       LDA ARYTAB+1      ; set end of variables high byte

b21c          FiAr_10
b21c 86 5f       STX TMPPTC        ; save as array start pointer low byte
b21e 85 60       STA TMPPTC+1      ; save as array start pointer high byte
b220 c5 32       CMP STREND+1      ; compare with end of arrays high byte
b222 d0 04       BNE FiAr_15       ; if not reached array memory end continue searching
b224 e4 31       CPX STREND        ; else compare with end of arrays low byte
b226 f0 39       BEQ FiAr_30       ; go build array if not found

b228          FiAr_15
b228 a0 00       LDY #0
b22a b1 5f       LDA (TMPPTC),Y    ; get array name first byte
b22c c8          INY
b22d c5 45       CMP VARNAM        ; compare with this array name first byte
b22f d0 06       BNE FiAr_20       ; if no match go try the next array
b231 a5 46       LDA VARNAM+1      ; else get this array name second byte
b233 d1 5f       CMP (TMPPTC),Y    ; compare with array name second byte
b235 f0 16       BEQ FiAr_25       ; array found so branch

b237          FiAr_20
b237 c8          INY
b238 b1 5f       LDA (TMPPTC),Y    ; get array size low byte
b23a 18          CLC
b23b 65 5f       ADC TMPPTC        ; add array start pointer low byte
b23d aa          TAX               ; copy low byte to X
b23e c8          INY
b23f b1 5f       LDA (TMPPTC),Y    ; get array size high byte
b241 65 60       ADC TMPPTC+1      ; add array memory pointer high byte
b243 90 d7       BCC FiAr_10      ; if no overflow go check next array

              ; =============
b245            Bad_Subscript
              ; =============

b245 a2 12       LDX #$12          ; error $12, bad subscript error
b247 2c          .byte   $2C       ; skip next statement

              ; ================
b248            Illegal_Quantity
              ; ================

b248 a2 0e       LDX #$0E          ; error $0E, illegal quantity error

b24a          Jump_Basic_Error
b24a 4c 37 a4    JMP Basic_Error

b24d          FiAr_25
b24d a2 13       LDX #$13          ; set error $13, double dimension error
b24f a5 0c       LDA DIMFLG        ; get DIM flag
b251 d0 f7       BNE Jump_Basic_Error
b253 20 94 b1    JSR Array_Pointer_To_First
b256 a5 0b       LDA COUNT         ; get dimensions count
b258 a0 04       LDY #4            ; set index to array's # of dimensions
b25a d1 5f       CMP (TMPPTC),Y    ; compare with no of dimensions
b25c d0 e7       BNE Bad_Subscript ; if wrong do bad subscript error
b25e 4c ea b2    JMP Find_Array_Element

b261          FiAr_30
b261 20 94 b1    JSR Array_Pointer_To_First
b264 20 08 a4    JSR Check_Mem_Avail
b267 a0 00       LDY #0
b269 84 72       STY TMPPTD+1      ; clear array data size high byte
b26b a2 05       LDX #5            ; set default element size
b26d a5 45       LDA VARNAM        ; get variable name 1st byte
b26f 91 5f       STA (TMPPTC),Y    ; save array name 1st byte
b271 10 01       BPL FiAr_35       ; branch if not string or floating point array
b273 ca          DEX               ; decrement element size, $04

b274          FiAr_35
b274 c8          INY
b275 a5 46       LDA VARNAM+1      ; get variable name 2nd byte
b277 91 5f       STA (TMPPTC),Y    ; save array name 2nd byte
b279 10 02       BPL FiAr_40       ; branch if not integer or string
b27b ca          DEX               ; decrement element size, $03
b27c ca          DEX               ; decrement element size, $02

b27d          FiAr_40
b27d 86 71       STX TMPPTD        ; save element size
b27f a5 0b       LDA COUNT         ; get dimensions count
b281 c8          INY
b282 c8          INY               ; .. to array  ..
b283 c8          INY               ; .. dimension count
b284 91 5f       STA (TMPPTC),Y    ; save array dimension count

b286          FiAr_45
b286 a2 0b       LDX #11           ; set default dimension size low byte (0:10)
b288 a9 00       LDA #0            ; set default dimension size high byte
b28a 24 0c       BIT DIMFLG        ; test DIM flag
b28c 50 08       BVC FiAr_50       ; if default to be used don't pull a dimension
b28e 68          PLA               ; pull dimension size low byte
b28f 18          CLC
b290 69 01       ADC #1            ; add 1, allow for zeroeth element
b292 aa          TAX               ; copy low byte to X
b293 68          PLA               ; pull dimension size high byte
b294 69 00       ADC #0            ; add carry to high byte

b296          FiAr_50
b296 c8          INY               ; incement index to dimension size high byte
b297 91 5f       STA (TMPPTC),Y    ; save dimension size high byte
b299 c8          INY               ; incement index to dimension size low byte
b29a 8a          TXA               ; copy dimension size low byte
b29b 91 5f       STA (TMPPTC),Y    ; save dimension size low byte
b29d 20 4c b3    JSR Compute_Array_Size
b2a0 86 71       STX TMPPTD        ; save result low byte
b2a2 85 72       STA TMPPTD+1      ; save result high byte
b2a4 a4 22       LDY INDEXA        ; restore index
b2a6 c6 0b       DEC COUNT         ; decrement dimensions count
b2a8 d0 dc       BNE FiAr_45       ; loop if not all done
b2aa 65 59       ADC TMPPTA+1      ; add array data pointer high byte
b2ac b0 5d       BCS FiAE_30       ; if overflow do out of memory error then warm start
b2ae 85 59       STA TMPPTA+1      ; save array data pointer high byte
b2b0 a8          TAY               ; copy array data pointer high byte
b2b1 8a          TXA               ; copy array size low byte
b2b2 65 58       ADC TMPPTA        ; add array data pointer low byte
b2b4 90 03       BCC FiAr_55       ; if no rollover skip the high byte increment
b2b6 c8          INY               ; else increment next array pointer high byte
b2b7 f0 52       BEQ FiAE_30       ; if rolled over do out of memory error then warm start

b2b9          FiAr_55
b2b9 20 08 a4    JSR Check_Mem_Avail
                 STAY(STREND)      ; now we need to zero all the elements in it
b2bc 85 31       STA STREND
b2be 84 32       STY STREND+1

b2c0 a9 00       LDA #0            ; for array clear
b2c2 e6 72       INC TMPPTD+1      ; increment array size high byte, now block count
b2c4 a4 71       LDY TMPPTD        ; get array size low byte, now index to block
b2c6 f0 05       BEQ FiAr_65       ; if $00 go do the high byte decrement

b2c8          FiAr_60
b2c8 88          DEY               ; decrement index, do 0 to n-1
b2c9 91 58       STA (TMPPTA),Y    ; clear array element byte
b2cb d0 fb       BNE FiAr_60       ; loop until this block done

b2cd          FiAr_65
b2cd c6 59       DEC TMPPTA+1      ; decrement array pointer high byte
b2cf c6 72       DEC TMPPTD+1      ; decrement block count high byte
b2d1 d0 f5       BNE FiAr_60       ; loop until all blocks done
b2d3 e6 59       INC TMPPTA+1      ; correct for last loop
b2d5 38          SEC
b2d6 a5 31       LDA STREND        ; get end of arrays low byte
b2d8 e5 5f       SBC TMPPTC        ; subtract array start low byte
b2da a0 02       LDY #$02          ; index to array size low byte
b2dc 91 5f       STA (TMPPTC),Y    ; save array size low byte
b2de a5 32       LDA STREND+1      ; get end of arrays high byte
b2e0 c8          INY               ; index to array size high byte
b2e1 e5 60       SBC TMPPTC+1      ; subtract array start high byte
b2e3 91 5f       STA (TMPPTC),Y    ; save array size high byte
b2e5 a5 0c       LDA DIMFLG        ; get default DIM flag
b2e7 d0 62       BNE FiAE_Ret      ; exit if this was a DIM command
b2e9 c8          INY               ; set index to # of dimensions, the dimension indeces
                                   ; are on the stack and will be removed as the position
                                   ; of the array element is calculated

              ; ==================
b2ea            Find_Array_Element
              ; ==================

b2ea b1 5f       LDA (TMPPTC),Y    ; get array's dimension count
b2ec 85 0b       STA COUNT         ; save it
b2ee a9 00       LDA #0
b2f0 85 71       STA TMPPTD        ; clear array data pointer low byte

b2f2          FiAE_10
b2f2 85 72       STA TMPPTD+1      ; save array data pointer high byte
b2f4 c8          INY
b2f5 68          PLA               ; pull array index low byte
b2f6 aa          TAX               ; copy to X
b2f7 85 64       STA FAC1M3        ; save index low byte to FAC1 mantissa 3
b2f9 68          PLA               ; pull array index high byte
b2fa 85 65       STA FAC1M4        ; save index high byte to FAC1 mantissa 4
b2fc d1 5f       CMP (TMPPTC),Y    ; compare with array bound high byte
b2fe 90 0e       BCC FiAE_40       ; if within bounds continue
b300 d0 06       BNE FiAE_20       ; if outside bounds do bad subscript error
b302 c8          INY               ; index to array bound low byte
b303 8a          TXA               ; get array index low byte
b304 d1 5f       CMP (TMPPTC),Y    ; compare with array bound low byte
b306 90 07       BCC FiAE_50       ; if within bounds continue

b308          FiAE_20
b308 4c 45 b2    JMP Bad_Subscript

b30b          FiAE_30
b30b 4c 35 a4    JMP Error_Out_Of_Memory

b30e          FiAE_40
b30e c8          INY               ; index to array bound low byte

b30f          FiAE_50
b30f a5 72       LDA TMPPTD+1      ; get array data pointer high byte
b311 05 71       ORA TMPPTD        ; OR with array data pointer low byte
b313 18          CLC
b314 f0 0a       BEQ FiAE_60       ; if array data pointer = null skip the multiply
b316 20 4c b3    JSR Compute_Array_Size
b319 8a          TXA               ; get result low byte
b31a 65 64       ADC FAC1M3        ; add index low byte from FAC1 mantissa 3
b31c aa          TAX               ; save result low byte
b31d 98          TYA               ; get result high byte
b31e a4 22       LDY INDEXA        ; restore index

b320          FiAE_60
b320 65 65       ADC FAC1M4        ; add index high byte from FAC1 mantissa 4
b322 86 71       STX TMPPTD        ; save array data pointer low byte
b324 c6 0b       DEC COUNT         ; decrement dimensions count
b326 d0 ca       BNE FiAE_10       ; loop if dimensions still to do
b328 85 72       STA TMPPTD+1      ; save array data pointer high byte
b32a a2 05       LDX #$05          ; set default element size
b32c a5 45       LDA VARNAM        ; get variable name 1st byte
b32e 10 01       BPL FiAE_70       ; branch if not string or floating point array
b330 ca          DEX               ; decrement element size, $04

b331          FiAE_70
b331 a5 46       LDA VARNAM+1      ; get variable name 2nd byte
b333 10 02       BPL FiAE_80       ; branch if not integer or string
b335 ca          DEX               ; decrement element size, $03
b336 ca          DEX               ; decrement element size, $02

b337          FiAE_80
b337 86 28       STX FAC3+3       ; save dimension size low byte
b339 a9 00       LDA #$00          ; clear dimension size high byte
b33b 20 55 b3    JSR Compute_Array_Size_A
b33e 8a          TXA               ; copy array size low byte
b33f 65 58       ADC TMPPTA        ; add array data start pointer low byte
b341 85 47       STA VARPNT        ; save as current variable pointer low byte
b343 98          TYA               ; copy array size high byte
b344 65 59       ADC TMPPTA+1      ; add array data start pointer high byte
b346 85 48       STA VARPNT+1      ; save as current variable pointer high byte
b348 a8          TAY               ; copy high byte to Y
b349 a5 47       LDA VARPNT        ; get current variable pointer low byte
                                   ; pointer to element is now in AY
b34b          FiAE_Ret
b34b 60          RTS ;Size  379 [Find_Array]

              ; ******************
b34c            Compute_Array_Size
              ; ******************

b34c 84 22       STY INDEXA        ; save index
b34e b1 5f       LDA (TMPPTC),Y    ; get dimension size low byte
b350 85 28       STA FAC3+3       ; save dimension size low byte
b352 88          DEY               ; decrement index
b353 b1 5f       LDA (TMPPTC),Y    ; get dimension size high byte

              ; --------------------
b355            Compute_Array_Size_A
              ; --------------------

b355 85 29       STA FAC3+4       ; save dimension size high byte
b357 a9 10       LDA #$10          ; count = $10 (16 bit multiply)
b359 85 5d       STA TMPVA1        ; save bit count
b35b a2 00       LDX #$00          ; clear result low byte
b35d a0 00       LDY #$00          ; clear result high byte

b35f          CAS_10
b35f 8a          TXA               ; get result low byte
b360 0a          ASL A             ; *2
b361 aa          TAX               ; save result low byte
b362 98          TYA               ; get result high byte
b363 2a          ROL A             ; *2
b364 a8          TAY               ; save result high byte
b365 b0 a4       BCS FiAE_30       ; if overflow go do "Out of memory" error
b367 06 71       ASL TMPPTD        ; shift element size low byte
b369 26 72       ROL TMPPTD+1      ; shift element size high byte
b36b 90 0b       BCC CAS_20        ; skip add if no carry
b36d 18          CLC               ; else clear carry for add
b36e 8a          TXA               ; get result low byte
b36f 65 28       ADC FAC3+3       ; add dimension size low byte
b371 aa          TAX               ; save result low byte
b372 98          TYA               ; get result high byte
b373 65 29       ADC FAC3+4       ; add dimension size high byte
b375 a8          TAY               ; save result high byte
b376 b0 93       BCS FiAE_30       ; if overflow go do "Out of memory" error

b378          CAS_20
b378 c6 5d       DEC TMPVA1        ; decrement bit count
b37a d0 e3       BNE CAS_10        ; loop until all done
b37c 60          RTS ;Size   49 [Compute_Array_Size]

              ; *********
b37d            Basic_FRE
              ; *********

b37d a5 0d       LDA VALTYP        ; get data type flag, $FF = string, $00 = numeric
b37f f0 03       BEQ FRE_10        ; if numeric don't pop the string
b381 20 a6 b6    JSR Get_String_Descriptor
                                   ; FRE(n) was numeric so do this
b384          FRE_10
b384 20 26 b5    JSR Garbage_Collection
b387 38          SEC
b388 a5 33       LDA FRESPC        ; get bottom of string space low byte
b38a e5 31       SBC STREND        ; subtract end of arrays low byte
b38c a8          TAY               ; copy result to Y
b38d a5 34       LDA FRESPC+1      ; get bottom of string space high byte
b38f e5 32       SBC STREND+1      ; subtract end of arrays high byte

              ; ***************
b391            Integer_To_Float
              ; ***************

b391 a2 00       LDX #$00          ; set type = numeric
b393 86 0d       STX VALTYP        ; clear data type flag, $FF = string, $00 = numeric
b395 85 62       STA FAC1M1        ; save FAC1 mantissa 1
b397 84 63       STY FAC1M2        ; save FAC1 mantissa 2
b399 a2 90       LDX #$90          ; set exponent=2^16 (integer)
b39b 4c 44 bc    JMP Int_To_Float_Exp_X      ; set exp = X, clear FAC1 3 and 4, normalise and return

              ; *********
b39e            Basic_POS
              ; *********

b39e 38          SEC               ; set Cb for read cursor position
b39f 20 ea ff    JSR PLOT          ; Read or set cursor location

              ; ==========
b3a2            Y_To_Float
              ; ==========

b3a2 a9 00       LDA #0            ; clear high byte
b3a4 f0 eb       BEQ Integer_To_Float

              ; *****************
b3a6            Assert_Non_Direct
              ; *****************

b3a6 a6 3a       LDX CURLIN+1      ; get current line number high byte
b3a8 e8          INX               ; increment it
b3a9 d0 a0       BNE FiAE_Ret      ; return if not direct mode
b3ab a2 15       LDX #$15          ; error $15, illegal direct error
b3ad 2c          .byte   $2C       ; skip next statement

              ; ==================
b3ae            Undefined_Function
              ; ==================

b3ae a2 1b       LDX #$1B          ; error $1B, undefined function error
b3b0 4c 37 a4    JMP Basic_Error

              ; *********
b3b3            Basic_DEF
              ; *********

b3b3 20 e1 b3    JSR Get_FN
b3b6 20 a6 b3    JSR Assert_Non_Direct
b3b9 20 fa ae    JSR Need_Left_Parenthesis
b3bc a9 80       LDA #$80          ; set flag for FNx
b3be 85 10       STA SUBFLG        ; save subscript/FNx flag
b3c0 20 8b b0    JSR Get_Scalar_Address
b3c3 20 8d ad    JSR Is_Numeric
b3c6 20 f7 ae    JSR Need_Right_Parenthesis
b3c9 a9 b2       LDA #TK_EQUAL     ; get = token
b3cb 20 ff ae    JSR Need_A
b3ce 48          PHA               ; push next character
                 PUSHW(VARPNT)     ; push current variable pointer
b3cf a5 48       LDA VARPNT+1
b3d1 48          PHA
b3d2 a5 47       LDA VARPNT
b3d4 48          PHA

                 PUSHW(TXTPTR)     ; push BASIC execute pointer
b3d5 a5 7b       LDA TXTPTR+1
b3d7 48          PHA
b3d8 a5 7a       LDA TXTPTR
b3da 48          PHA

b3db 20 f8 a8    JSR Basic_DATA    ; perform DATA
b3de 4c 4f b4    JMP EvFN_30      ; put execute pointer and variable pointer into function

              ; ******
b3e1            Get_FN
              ; ******

b3e1 a9 a5       LDA #TK_FN        ; set FN token
b3e3 20 ff ae    JSR Need_A
b3e6 09 80       ORA #$80          ; set FN flag bit
b3e8 85 10       STA SUBFLG        ; save FN name
b3ea 20 92 b0    JSR Get_FN_Address
                 STAY(FUNCPT)
b3ed 85 4e       STA FUNCPT
b3ef 84 4f       STY FUNCPT+1

b3f1 4c 8d ad    JMP Is_Numeric

              ; ********
b3f4            Eval_FNX
              ; ********

b3f4 20 e1 b3    JSR Get_FN
                 PUSHW(FUNCPT)     ; push function pointer
b3f7 a5 4f       LDA FUNCPT+1
b3f9 48          PHA
b3fa a5 4e       LDA FUNCPT
b3fc 48          PHA

b3fd 20 f1 ae    JSR Eval_In_Parenthesis
b400 20 8d ad    JSR Is_Numeric
                 PULLW(FUNCPT)     ; pull it
b403 68          PLA
b404 85 4e       STA FUNCPT
b406 68          PLA
b407 85 4f       STA FUNCPT+1

b409 a0 02       LDY #$02          ; index to variable pointer high byte
b40b b1 4e       LDA (FUNCPT),Y    ; get variable address low byte
b40d 85 47       STA VARPNT        ; save current variable pointer low byte
b40f aa          TAX               ; copy address low byte
b410 c8          INY               ; index to variable address high byte
b411 b1 4e       LDA (FUNCPT),Y    ; get variable pointer high byte
b413 f0 99       BEQ Undefined_Function      ; if high byte zero go do undefined function error
b415 85 48       STA VARPNT+1      ; save current variable pointer high byte
b417 c8          INY               ; index to mantissa 3

b418          EvFN_10
b418 b1 47       LDA (VARPNT),Y    ; get byte from variable
b41a 48          PHA               ; stack it
b41b 88          DEY               ; decrement index
b41c 10 fa       BPL EvFN_10      ; loop until variable stacked
b41e a4 48       LDY VARPNT+1      ; get current variable pointer high byte
b420 20 d4 bb    JSR Assign_FAC1_To_Var
                 PUSHW(TXTPTR)     ; push BASIC execute pointer
b423 a5 7b       LDA TXTPTR+1
b425 48          PHA
b426 a5 7a       LDA TXTPTR
b428 48          PHA

b429 b1 4e       LDA (FUNCPT),Y    ; get function execute pointer low byte
b42b 85 7a       STA TXTPTR        ; save BASIC execute pointer low byte
b42d c8          INY               ; index to high byte
b42e b1 4e       LDA (FUNCPT),Y    ; get function execute pointer high byte
b430 85 7b       STA TXTPTR+1      ; save BASIC execute pointer high byte
                 PUSHW(VARPNT)     ; push current variable pointer
b432 a5 48       LDA VARPNT+1
b434 48          PHA
b435 a5 47       LDA VARPNT
b437 48          PHA

b438 20 8a ad    JSR Eval_Numeric
                 PULLW(FUNCPT)     ; pull variable address
b43b 68          PLA
b43c 85 4e       STA FUNCPT
b43e 68          PLA
b43f 85 4f       STA FUNCPT+1

b441 20 79 00    JSR CHRGOT
b444 f0 03       BEQ EvFN_20      ; if null (should be [EOL] marker) continue
b446 4c 08 af    JMP Syntax_Error

b449          EvFN_20
                 PULLW(TXTPTR)     ; pull BASIC execute pointer
b449 68          PLA
b44a 85 7a       STA TXTPTR
b44c 68          PLA
b44d 85 7b       STA TXTPTR+1


b44f          EvFN_30
b44f a0 00       LDY #0
b451 68          PLA               ; pull BASIC execute pointer low byte
b452 91 4e       STA (FUNCPT),Y    ; save to function
b454 68          PLA               ; pull BASIC execute pointer high byte
b455 c8          INY
b456 91 4e       STA (FUNCPT),Y    ; save to function
b458 68          PLA               ; pull current variable address low byte
b459 c8          INY
b45a 91 4e       STA (FUNCPT),Y    ; save to function
b45c 68          PLA               ; pull current variable address high byte
b45d c8          INY
b45e 91 4e       STA (FUNCPT),Y    ; save to function
b460 68          PLA               ; pull ??
b461 c8          INY
b462 91 4e       STA (FUNCPT),Y    ; save to function
b464 60          RTS ;Size  113 [Eval_FNX]

              ; *********
b465            Basic_STR
              ; *********

b465 20 8d ad    JSR Is_Numeric
b468 a0 00       LDY #0
b46a 20 df bd    JSR Format_FAC1_Y
b46d 68          PLA               ; dump return address (skip type check)
b46e 68          PLA               ; dump return address (skip type check)

b46f          BaST_10
                 LAYI(BASSTO)      ; set result string
b46f a9 ff       LDA #<BASSTO
b471 a0 00       LDY #>BASSTO

b473 f0 12       BEQ Create_String_Descriptor

              ; ********************
b475            Allocate_String_FAC1
              ; ********************

                 LDXY(FAC1M3)
b475 a6 64       LDX FAC1M3
b477 a4 65       LDY FAC1M3+1

                 STXY(DESCPT)
b479 86 50       STX DESCPT
b47b 84 51       STY DESCPT+1


              ; *****************
b47d            Allocate_String_A
              ; *****************

b47d 20 f4 b4    JSR Allocate_String_Space
b480 86 62       STX FAC1M1        ; save string pointer low byte
b482 84 63       STY FAC1M2        ; save string pointer high byte
b484 85 61       STA FAC1EX        ; save length
b486 60          RTS ;Size   10 [Allocate_String_A]

              ; ************************
b487            Create_String_Descriptor
              ; ************************

b487 a2 22       LDX #QUOTE
b489 86 07       STX CHARAC        ; set terminator 1
b48b 86 08       STX ENDCHR        ; set terminator 2

              ; ---------------------------
b48d            Create_String_Descriptor_AY
              ; ---------------------------

                 STAY(STRPTR)
b48d 85 6f       STA STRPTR
b48f 84 70       STY STRPTR+1

                 STAY(FAC1M1)
b491 85 62       STA FAC1M1
b493 84 63       STY FAC1M1+1

b495 a0 ff       LDY #$FF          ; set length to -1

b497          CSD_10
b497 c8          INY               ; increment length
b498 b1 6f       LDA (STRPTR),Y    ; get byte from string
b49a f0 0c       BEQ CSD_30        ; exit loop if null byte [EOS]
b49c c5 07       CMP CHARAC        ; compare with search character, terminator 1
b49e f0 04       BEQ CSD_20        ; branch if terminator
b4a0 c5 08       CMP ENDCHR        ; compare with terminator 2
b4a2 d0 f3       BNE CSD_10        ; loop if not terminator 2

b4a4          CSD_20
b4a4 c9 22       CMP #QUOTE
b4a6 f0 01       BEQ CSD_40        ; branch if " (carry set if = !)

b4a8          CSD_30
b4a8 18          CLC

b4a9          CSD_40
b4a9 84 61       STY FAC1EX        ; save length in FAC1 exponent
b4ab 98          TYA               ; copy length to A
b4ac 65 6f       ADC STRPTR        ; add string start low byte
b4ae 85 71       STA TMPPTD        ; save string end low byte
b4b0 a6 70       LDX STRPTR+1      ; get string start high byte
b4b2 90 01       BCC CSD_50        ; if no low byte overflow skip the high byte increment
b4b4 e8          INX               ; else increment high byte

b4b5          CSD_50
b4b5 86 72       STX TMPPTD+1      ; save string end high byte
b4b7 a5 70       LDA STRPTR+1      ; get string start high byte
b4b9 f0 04       BEQ CSD_60        ; branch if in utility area
b4bb c9 02       CMP #$02          ; compare with input buffer memory high byte
b4bd d0 0b       BNE Push_String_Descriptor

b4bf          CSD_60
b4bf 98          TYA               ; copy length to A
b4c0 20 75 b4    JSR Allocate_String_FAC1
                 LDXY(STRPTR)      ; get string start
b4c3 a6 6f       LDX STRPTR
b4c5 a4 70       LDY STRPTR+1


b4c7          Store_And_Push_String
b4c7 20 88 b6    JSR Store_String_XY

              ; ***********************
b4ca             Push_String_Descriptor
              ; ***********************

b4ca a6 16       LDX TEMPPT        ; get descriptor stack pointer
b4cc e0 22       CPX #QUOTE
b4ce d0 05       BNE PSD_20        ; branch if space on string stack
b4d0 a2 19       LDX #$19          ; error $19, string too complex error

b4d2          PSD_10
b4d2 4c 37 a4    JMP Basic_Error

b4d5          PSD_20
b4d5 a5 61       LDA FAC1EX        ; get string length
b4d7 95 00       STA 0,X           ; put on string stack
b4d9 a5 62       LDA FAC1M1        ; get string pointer low byte
b4db 95 01       STA 1,X           ; put on string stack
b4dd a5 63       LDA FAC1M2        ; get string pointer high byte
b4df 95 02       STA 2,X           ; put on string stack
b4e1 a0 00       LDY #0            ; clear Y
                 STXY(FAC1M3)      ; save string descriptor pointer
b4e3 86 64       STX FAC1M3
b4e5 84 65       STY FAC1M3+1

b4e7 84 70       STY FAC1M5        ; clear FAC1 rounding byte
b4e9 88          DEY               ; Y = $FF
b4ea 84 0d       STY VALTYP        ; save data type flag, $FF = string
b4ec 86 17       STX LASTPT        ; save current descriptor stack item pointer low byte
b4ee e8          INX               ; update stack pointer
b4ef e8          INX               ; update stack pointer
b4f0 e8          INX               ; update stack pointer
b4f1 86 16       STX TEMPPT        ; set new descriptor stack pointer
b4f3 60          RTS ;Size   42 [Push_String_Descriptor]

              ; *********************
b4f4            Allocate_String_Space
              ; *********************

b4f4 46 0f       LSR GARBFL        ; clear garbage collected flag (b7)

b4f6          ASS_10
b4f6 48          PHA               ; save string length
b4f7 49 ff       EOR #$FF          ; complement it
b4f9 38          SEC               ; set carry for subtract, two's complement add
b4fa 65 33       ADC FRESPC        ; add bottom of string space low byte, subtract length
b4fc a4 34       LDY FRESPC+1      ; get bottom of string space high byte
b4fe b0 01       BCS ASS_20        ; skip decrement if no underflow
b500 88          DEY               ; decrement bottom of string space high byte

b501          ASS_20
b501 c4 32       CPY STREND+1      ; compare with end of arrays high byte
b503 90 11       BCC ASS_40        ; do out of memory error if less
b505 d0 04       BNE ASS_30        ; if not = skip next test
b507 c5 31       CMP STREND        ; compare with end of arrays low byte
b509 90 0b       BCC ASS_40        ; do out of memory error if less

b50b          ASS_30
                 STAY(FRESPC)
b50b 85 33       STA FRESPC
b50d 84 34       STY FRESPC+1

                 STAY(UTLSTP)      ; save string utility ptr
b50f 85 35       STA UTLSTP
b511 84 36       STY UTLSTP+1

b513 aa          TAX               ; copy low byte to X
b514 68          PLA               ; get string length back
b515 60          RTS ;Size   34 [Allocate_String_Space]

b516          ASS_40
b516 a2 10       LDX #$10          ; error code $10, out of memory error
b518 a5 0f       LDA GARBFL        ; get garbage collected flag
b51a 30 b6       BMI PSD_10        ; if set then do error code X
b51c 20 26 b5    JSR Garbage_Collection
b51f a9 80       LDA #$80          ; flag for garbage collected
b521 85 0f       STA GARBFL        ; set garbage collected flag
b523 68          PLA               ; pull length
b524 d0 d0       BNE ASS_10        ; go try again (loop always, length should never be = $00)

              ; ******************
b526            Garbage_Collection
              ; ******************

              ; This routine marks all strings as uncollected by setting the bottom of
              ; string space FRESPC to MEMSIZ, the top of string space.
              ; Then it scans through all string descriptors starting with those on the
              ; string stack, continuing with scalar string variables and finally all
              ; string arrays. The string with the highest address is then moved to the
              ; top of string space, FRESPC is adjusted and the iteration continues
              ; with searching for the string with the next highest address.

b526 a6 37       LDX MEMSIZ        ; get end of memory low byte
b528 a5 38       LDA MEMSIZ+1      ; get end of memory high byte

b52a          GaCo_Iter
b52a 86 33       STX FRESPC        ; set bottom of string space low byte
b52c 85 34       STA FRESPC+1      ; set bottom of string space high byte
b52e a0 00       LDY #0
b530 84 4f       STY FUNCPT+1      ; clear working pointer high byte
b532 84 4e       STY FUNCPT        ; clear working pointer low byte
                 LDAX(STREND)      ; get end of arrays
b534 a5 31       LDA STREND
b536 a6 32       LDX STREND+1

                 STAX(TMPPTC)      ; save as highest uncollected string pointer
b538 85 5f       STA TMPPTC
b53a 86 60       STX TMPPTC+1

b53c a9 19       LDA #TEMPST       ; set descriptor stack pointer
b53e a2 00       LDX #0            ; check first descriptors on string stack
                 STAX(INDEXA)      ; save descriptor stack pointer
b540 85 22       STA INDEXA
b542 86 23       STX INDEXA+1


b544          GaCo_Loop_1
b544 c5 16       CMP TEMPPT        ; compare with descriptor stack pointer
b546 f0 05       BEQ GaCo_10       ; branch if descripor on stack
b548 20 c7 b5    JSR Check_String  ; 
b54b f0 f7       BEQ GaCo_Loop_1   ; loop always (Check_String returns with LDY #0)

b54d          GaCo_10              ; done stacked strings, now do string variables
b54d a9 07       LDA #7            ; set step size = 7, collecting variables
b54f 85 53       STA GARBSS        ; save garbage collection step size
                 LDAX(VARTAB)      ; get start of variables
b551 a5 2d       LDA VARTAB
b553 a6 2e       LDX VARTAB+1

                 STAX(INDEXA)      ; save as pointer
b555 85 22       STA INDEXA
b557 86 23       STX INDEXA+1


b559          GaCo_20
b559 e4 30       CPX ARYTAB+1      ; compare end of variables high byte,
b55b d0 04       BNE GaCo_30       ; branch if no high byte match
b55d c5 2f       CMP ARYTAB        ; else compare end of variables low byte,
b55f f0 05       BEQ GaCo_40       ; branch if = variable memory end

b561          GaCo_30
b561 20 bd b5    JSR Check_Variable
b564 f0 f3       BEQ GaCo_20       ; loop always

b566          GaCo_40
                 STAX(TMPPTA)      ; save start of arrays low byte as working pointer
b566 85 58       STA TMPPTA
b568 86 59       STX TMPPTA+1

b56a a9 03       LDA #3            ; set step size, collecting descriptors
b56c 85 53       STA GARBSS        ; save step size

b56e          GaCo_50
                 LDAX(TMPPTA)      ; get pointer
b56e a5 58       LDA TMPPTA
b570 a6 59       LDX TMPPTA+1


b572          GaCo_60
b572 e4 32       CPX STREND+1      ; compare with end of arrays high byte
b574 d0 07       BNE GaCo_70       ; branch if not at end
b576 c5 31       CMP STREND        ; else compare with end of arrays low byte
b578 d0 03       BNE GaCo_70       ; branch if not at end
b57a 4c 06 b6    JMP Collect_String

b57d          GaCo_70
                 STAX(INDEXA)      ; save pointer
b57d 85 22       STA INDEXA
b57f 86 23       STX INDEXA+1

b581 a0 00       LDY #0
b583 b1 22       LDA (INDEXA),Y    ; get array name first byte
b585 aa          TAX               ; copy it
b586 c8          INY
b587 b1 22       LDA (INDEXA),Y    ; get array name second byte
b589 08          PHP               ; push the flags
b58a c8          INY
b58b b1 22       LDA (INDEXA),Y    ; get array size low byte
b58d 65 58       ADC TMPPTA        ; add start of this array low byte
b58f 85 58       STA TMPPTA        ; save start of next array low byte
b591 c8          INY
b592 b1 22       LDA (INDEXA),Y    ; get array size high byte
b594 65 59       ADC TMPPTA+1      ; add start of this array high byte
b596 85 59       STA TMPPTA+1      ; save start of next array high byte
b598 28          PLP               ; restore the flags
b599 10 d3       BPL GaCo_50       ; skip if not string array
b59b 8a          TXA               ; get name first byte back
b59c 30 d0       BMI GaCo_50       ; skip if not string array
b59e c8          INY
b59f b1 22       LDA (INDEXA),Y    ; get # of dimensions
b5a1 a0 00       LDY #0
b5a3 0a          ASL A             ; *2
b5a4 69 05       ADC #5            ; +5 (array header size)
b5a6 65 22       ADC INDEXA        ; add pointer low byte
b5a8 85 22       STA INDEXA        ; save pointer low byte
b5aa 90 02       BCC GaCo_80       ; if no rollover skip the high byte increment
b5ac e6 23       INC INDEXA+1      ; else increment pointer hgih byte

b5ae          GaCo_80
b5ae a6 23       LDX INDEXA+1      ; get pointer high byte

b5b0          GaCo_90
b5b0 e4 59       CPX TMPPTA+1      ; compare pointer high byte with end of this array high byte
b5b2 d0 04       BNE GaCo_95       ; branch if not there yet
b5b4 c5 58       CMP TMPPTA        ; compare pointer low byte with end of this array low byte
b5b6 f0 ba       BEQ GaCo_60       ; if at end of this array go check next array

b5b8          GaCo_95
b5b8 20 c7 b5    JSR Check_String
b5bb f0 f3       BEQ GaCo_90      ; loop

              ; **************
b5bd            Check_Variable
              ; **************

b5bd b1 22       LDA (INDEXA),Y    ; get variable name first byte
b5bf 30 35       BMI ChSt_30       ; add step and exit if not string
b5c1 c8          INY
b5c2 b1 22       LDA (INDEXA),Y    ; get variable name second byte
b5c4 10 30       BPL ChSt_30       ; add step and exit if not string
b5c6 c8          INY

              ; ************
b5c7            Check_String
              ; ************

              ; INDEXA points to the string descriptor to be checked.
              ; Following cases are examined for the string address (X/A)
              ; (1) : The length (INDEXA) is zero        -> next string
              ; (2) : (X/A) > FRESPC (already collected) -> next string
              ; (3) : (X/A) < TMPPTC                     -> next string
              ; (4) ; (X/A) > TMMPTC                     -> TPMPTC = (X/A)

              ; INDEXA is updated to point to the next string descriptor by adding
              ; GARBSS which may be 7 for scanning string variables or 3 for scanning
              ; string arrays.

              ; On return (A/X) holds the updated INDEXA, Y=0, Z flag set

b5c7 b1 22       LDA (INDEXA),Y    ; get string length
b5c9 f0 2b       BEQ ChSt_30       ; add step and exit if null string
b5cb c8          INY
b5cc b1 22       LDA (INDEXA),Y    ; get string pointer low byte
b5ce aa          TAX               ; copy to X
b5cf c8          INY
b5d0 b1 22       LDA (INDEXA),Y    ; get string pointer high byte
b5d2 c5 34       CMP FRESPC+1      ; compare string pointer high byte with bottom of string
b5d4 90 06       BCC ChSt_10       ; if less go test against highest
b5d6 d0 1e       BNE ChSt_30       ; bottom of string space less string has been collected
b5d8 e4 33       CPX FRESPC        ; compare string pointer low byte with bottom of string
b5da b0 1a       BCS ChSt_30       ; if bottom of string space less string has been collected

b5dc          ChSt_10
b5dc c5 60       CMP TMPPTC+1      ; compare string pointer high byte with highest uncollected
b5de 90 16       BCC ChSt_30       ; if highest uncollected string is greater then go update
b5e0 d0 04       BNE ChSt_20       ; if highest uncollected string is less then go set this
b5e2 e4 5f       CPX TMPPTC        ; compare string pointer low byte with highest uncollected
b5e4 90 10       BCC ChSt_30       ; if highest uncollected string is greater then go update

b5e6          ChSt_20
b5e6 86 5f       STX TMPPTC        ; save string pointer low byte as highest uncollected string
b5e8 85 60       STA TMPPTC+1      ; save string pointer high byte as highest uncollected
                 LDAX(INDEXA)      ; get descriptor pointer
b5ea a5 22       LDA INDEXA
b5ec a6 23       LDX INDEXA+1

                 STAX(FUNCPT)      ; save working pointer
b5ee 85 4e       STA FUNCPT
b5f0 86 4f       STX FUNCPT+1

b5f2 a5 53       LDA GARBSS        ; get step size
b5f4 85 55       STA FUNJMP        ; copy step size

b5f6          ChSt_30
b5f6 a5 53       LDA GARBSS        ; get step size (7 or 3)
b5f8 18          CLC
b5f9 65 22       ADC INDEXA        ; add pointer low byte
b5fb 85 22       STA INDEXA        ; save pointer low byte
b5fd 90 02       BCC ChSt_40       ; if no rollover skip the high byte increment
b5ff e6 23       INC INDEXA+1      ; else increment pointer high byte

b601          ChSt_40
b601 a6 23       LDX INDEXA+1      ; get pointer high byte
b603 a0 00       LDY #0
b605 60          RTS ;Size   63 [Check_String]

              ; ==============
b606            Collect_String
              ; ==============

b606 a5 4f       LDA FUNCPT+1      ; get working pointer low byte
b608 05 4e       ORA FUNCPT        ; OR working pointer high byte
b60a f0 f5       BEQ ChSt_40       ; exit if nothing to collect
b60c a5 55       LDA FUNJMP        ; get copied step size
b60e 29 04       AND #4            ; mask step size, 4 for variables, 0 for array or stack
b610 4a          LSR A             ; 2 for variables, 0 for descriptors
b611 a8          TAY               ; copy to index
b612 85 55       STA FUNJMP        ; save offset to descriptor start
b614 b1 4e       LDA (FUNCPT),Y    ; get string length
b616 65 5f       ADC TMPPTC        ; add string start low byte
b618 85 5a       STA TMPPTB        ; set block end low byte
b61a a5 60       LDA TMPPTC+1      ; get string start high byte
b61c 69 00       ADC #0            ; add carry
b61e 85 5b       STA TMPPTB+1      ; set block end high byte
                 LDAX(FRESPC)      ; get bottom of string space
b620 a5 33       LDA FRESPC
b622 a6 34       LDX FRESPC+1

                 STAX(TMPPTA)      ; save destination end
b624 85 58       STA TMPPTA
b626 86 59       STX TMPPTA+1

b628 20 bf a3    JSR Move_Block
b62b a4 55       LDY FUNJMP        ; restore offset to descriptor start
b62d c8          INY
b62e a5 58       LDA TMPPTA        ; get new string pointer low byte
b630 91 4e       STA (FUNCPT),Y    ; save new string pointer low byte
b632 aa          TAX               ; copy string pointer low byte
b633 e6 59       INC TMPPTA+1      ; increment new string pointer high byte
b635 a5 59       LDA TMPPTA+1      ; get new string pointer high byte
b637 c8          INY
b638 91 4e       STA (FUNCPT),Y    ; save new string pointer high byte
b63a 4c 2a b5    JMP GaCo_Iter     ; XA holds new bottom of string memory pointer

              ; ===========
b63d            Concatenate
              ; ===========

              ; add strings, the first string is in the descriptor, the second string is in line

                 PUSHW(FAC1M3)     ; push descriptor pointer
b63d a5 65       LDA FAC1M3+1
b63f 48          PHA
b640 a5 64       LDA FAC1M3
b642 48          PHA

b643 20 83 ae    JSR Evaluate
b646 20 8f ad    JSR Assert_String_Type
                 PULLW(STRPTR)     ; pull pointer
b649 68          PLA
b64a 85 6f       STA STRPTR
b64c 68          PLA
b64d 85 70       STA STRPTR+1

b64f a0 00       LDY #0
b651 b1 6f       LDA (STRPTR),Y    ; get length of first string from descriptor
b653 18          CLC
b654 71 64       ADC (FAC1M3),Y    ; add length of second string
b656 90 05       BCC Conc_10       ; if no overflow continue
b658 a2 17       LDX #$17          ; else error $17, string too long error
b65a 4c 37 a4    JMP Basic_Error

b65d          Conc_10
b65d 20 75 b4    JSR Allocate_String_FAC1
b660 20 7a b6    JSR Store_String_STRPTR
                 LDAY(DESCPT)      ; get descriptor pointer
b663 a5 50       LDA DESCPT
b665 a4 51       LDY DESCPT+1

b667 20 aa b6    JSR Get_String_Descriptor_AY
b66a 20 8c b6    JSR Store_String_INDEXA
                 LDAY(STRPTR)      ; get descriptor pointer
b66d a5 6f       LDA STRPTR
b66f a4 70       LDY STRPTR+1

b671 20 aa b6    JSR Get_String_Descriptor_AY
b674 20 ca b4    JSR Push_String_Descriptor
b677 4c b8 ad    JMP EvEx_15      ; continue evaluation

              ; *******************
b67a            Store_String_STRPTR
              ; *******************

b67a a0 00       LDY #0
b67c b1 6f       LDA (STRPTR),Y    ; get string length
b67e 48          PHA               ; save it
b67f c8          INY
b680 b1 6f       LDA (STRPTR),Y    ; get string pointer low byte
b682 aa          TAX               ; copy to X
b683 c8          INY
b684 b1 6f       LDA (STRPTR),Y    ; get string pointer high byte
b686 a8          TAY               ; copy to Y
b687 68          PLA               ; get length back

              ; ***************
b688            Store_String_XY
              ; ***************

                 STXY(INDEXA)
b688 86 22       STX INDEXA
b68a 84 23       STY INDEXA+1


              ; *******************
b68c            Store_String_INDEXA
              ; *******************

b68c a8          TAY               ; copy length as index
b68d f0 0a       BEQ SSIN_20       ; branch if null string
b68f 48          PHA               ; save length

b690          SSIN_10
b690 88          DEY               ; decrement length/index
b691 b1 22       LDA (INDEXA),Y    ; get byte from string
b693 91 35       STA (UTLSTP),Y    ; save byte to destination
b695 98          TYA               ; y = 0 ?
b696 d0 f8       BNE SSIN_10       ; loop if not all done yet
b698 68          PLA               ; restore length

b699          SSIN_20
b699 18          CLC
b69a 65 35       ADC UTLSTP        ; add string utility ptr low byte
b69c 85 35       STA UTLSTP        ; save string utility ptr low byte
b69e 90 02       BCC SSIN_30       ; if no rollover skip the high byte increment
b6a0 e6 36       INC UTLSTP+1      ; increment string utility ptr high byte

b6a2          SSIN_30
b6a2 60          RTS ;Size   23 [Store_String_INDEXA]

              ; ***********
b6a3            Eval_String
              ; ***********

b6a3 20 8f ad    JSR Assert_String_Type

              ; *********************
b6a6            Get_String_Descriptor
              ; *********************

              ; pop string off descriptor stack, or from of string space
              ; returns with A = length, X = pointer low byte, Y = pointer high byte

                 LDAY(FAC1M3)      ; get descriptor pointer
b6a6 a5 64       LDA FAC1M3
b6a8 a4 65       LDY FAC1M3+1


              ; ------------------------
b6aa            Get_String_Descriptor_AY
              ; ------------------------

                 STAY(INDEXA)      ; save descriptor pointer
b6aa 85 22       STA INDEXA
b6ac 84 23       STY INDEXA+1

b6ae 20 db b6    JSR Pop_Descriptor_Stack
b6b1 08          PHP               ; save status flags
b6b2 a0 00       LDY #0
b6b4 b1 22       LDA (INDEXA),Y    ; get length from string descriptor
b6b6 48          PHA
b6b7 c8          INY
b6b8 b1 22       LDA (INDEXA),Y    ; get string pointer low byte from descriptor
b6ba aa          TAX
b6bb c8          INY
b6bc b1 22       LDA (INDEXA),Y    ; get string pointer high byte from descriptor
b6be a8          TAY
b6bf 68          PLA               ; get string length back
b6c0 28          PLP               ; restore status
b6c1 d0 13       BNE GSD_20        ; branch if pointer not popped
b6c3 c4 34       CPY FRESPC+1      ; compare with bottom of string space high byte
b6c5 d0 0f       BNE GSD_20        ; branch if <>
b6c7 e4 33       CPX FRESPC        ; else compare with bottom of string space low byte
b6c9 d0 0b       BNE GSD_20        ; branch if <>
b6cb 48          PHA               ; push string length
b6cc 18          CLC               ; string address is identical to FRESPC,
b6cd 65 33       ADC FRESPC        ; so we can free that memory easyli.
b6cf 85 33       STA FRESPC
b6d1 90 02       BCC GSD_10
b6d3 e6 34       INC FRESPC+1

b6d5          GSD_10
b6d5 68          PLA               ; pull string length

b6d6          GSD_20
                 STXY(INDEXA)
b6d6 86 22       STX INDEXA
b6d8 84 23       STY INDEXA+1

b6da 60          RTS ;Size   53 [Get_String_Descriptor]

              ; ********************
b6db            Pop_Descriptor_Stack
              ; ********************

b6db c4 18       CPY LASTPT+1      ; compare high byte with current descriptor stack item
b6dd d0 0c       BNE PDS_Ret
b6df c5 17       CMP LASTPT        ; compare low byte with current descriptor stack item
b6e1 d0 08       BNE PDS_Ret
b6e3 85 16       STA TEMPPT        ; set descriptor stack pointer
b6e5 e9 03       SBC #3            ; update last string pointer low byte
b6e7 85 17       STA LASTPT        ; save current descriptor stack item pointer low byte
b6e9 a0 00       LDY #0            ; set Z flag : descriptor popped

b6eb          PDS_Ret
b6eb 60          RTS ;Size   17 [Pop_Descriptor_Stack]

              ; *********
b6ec            Basic_CHR
              ; *********

b6ec 20 a1 b7    JSR Eval_Byte
b6ef 8a          TXA               ; copy to A
b6f0 48          PHA               ; save character
b6f1 a9 01       LDA #$01          ; string is single byte
b6f3 20 7d b4    JSR Allocate_String_A
b6f6 68          PLA               ; get character back
b6f7 a0 00       LDY #0
b6f9 91 62       STA (FAC1M1),Y    ; save byte in string - byte IS string!
b6fb 68          PLA               ; dump return address (skip type check)
b6fc 68          PLA               ; dump return address (skip type check)
b6fd 4c ca b4    JMP Push_String_Descriptor

              ; **********
b700            Basic_LEFT
              ; **********

b700 20 61 b7    JSR Pop_String_Descriptor_And_Byte
b703 d1 50       CMP (DESCPT),Y    ; compare byte parameter with string length
b705 98          TYA               ; clear A

b706          LEFT_10
b706 90 04       BCC LEFT_20       ; branch if string length > byte parameter
b708 b1 50       LDA (DESCPT),Y    ; else make parameter = length
b70a aa          TAX               ; copy to byte parameter copy
b70b 98          TYA               ; clear string start offset

b70c          LEFT_20
b70c 48          PHA               ; save string start offset

b70d          LEFT_30
b70d 8a          TXA               ; copy byte parameter (or string length if <)

b70e          LEFT_40
b70e 48          PHA               ; save string length
b70f 20 7d b4    JSR Allocate_String_A
                 LDAY(DESCPT)      ; get descriptor pointer low byte
b712 a5 50       LDA DESCPT
b714 a4 51       LDY DESCPT+1

b716 20 aa b6    JSR Get_String_Descriptor_AY
b719 68          PLA               ; get string length back
b71a a8          TAY               ; copy length to Y
b71b 68          PLA               ; get string start offset back
b71c 18          CLC
b71d 65 22       ADC INDEXA        ; add start offset to string start pointer low byte
b71f 85 22       STA INDEXA        ; save string start pointer low byte
b721 90 02       BCC LEFT_50       ; if no overflow skip the high byte increment
b723 e6 23       INC INDEXA+1      ; else increment string start pointer high byte

b725          LEFT_50
b725 98          TYA               ; copy length to A
b726 20 8c b6    JSR Store_String_INDEXA
b729 4c ca b4    JMP Push_String_Descriptor

              ; ***********
b72c            Basic_RIGHT
              ; ***********

b72c 20 61 b7    JSR Pop_String_Descriptor_And_Byte
b72f 18          CLC
b730 f1 50       SBC (DESCPT),Y    ; subtract string length
b732 49 ff       EOR #$FF          ; invert it (A=LEN(expression$)-l)
b734 4c 06 b7    JMP LEFT_10      ; go do rest of LEFT$()

              ; *********
b737            Basic_MID
              ; *********

b737 a9 ff       LDA #$FF          ; set default length = 255
b739 85 65       STA FAC1M4        ; save default length
b73b 20 79 00    JSR CHRGOT
b73e c9 29       CMP #')'
b740 f0 06       BEQ MID_10        ; no 2nd. byte
b742 20 fd ae    JSR Need_Comma
b745 20 9e b7    JSR Get_Byte_Value

b748          MID_10
b748 20 61 b7    JSR Pop_String_Descriptor_And_Byte
b74b f0 4b       BEQ Jump_To_Illegal_Quantity
b74d ca          DEX               ; decrement start index
b74e 8a          TXA               ; copy to A
b74f 48          PHA               ; save string start offset
b750 18          CLC
b751 a2 00       LDX #0            ; clear output string length
b753 f1 50       SBC (DESCPT),Y    ; start - string length
b755 b0 b6       BCS LEFT_30       ; if start > string length go do null string
b757 49 ff       EOR #$FF          ; complement -length
b759 c5 65       CMP FAC1M4        ; compare with length
b75b 90 b1       BCC LEFT_40       ; if length > remaining string go do RIGHT$
b75d a5 65       LDA FAC1M4        ; get length byte
b75f b0 ad       BCS LEFT_40       ; go do string copy, branch always

              ; ******************************
b761            Pop_String_Descriptor_And_Byte
              ; ******************************

b761 20 f7 ae    JSR Need_Right_Parenthesis
b764 68          PLA
b765 a8          TAY               ; save return address low byte
b766 68          PLA
b767 85 55       STA FUNJMP        ; save return address high byte
b769 68          PLA               ; dump call to function vector low byte
b76a 68          PLA               ; dump call to function vector high byte
b76b 68          PLA               ; pull byte parameter
b76c aa          TAX               ; copy byte parameter to X
                 PULLW(DESCPT)     ; pull string pointer
b76d 68          PLA
b76e 85 50       STA DESCPT
b770 68          PLA
b771 85 51       STA DESCPT+1

b773 a5 55       LDA FUNJMP        ; get return address high byte
b775 48          PHA               ; back on stack
b776 98          TYA               ; get return address low byte
b777 48          PHA               ; back on stack
b778 a0 00       LDY #0
b77a 8a          TXA               ; copy byte parameter
b77b 60          RTS ;Size   27 [Pop_String_Descriptor_And_Byte]

              ; *********
b77c            Basic_LEN
              ; *********

b77c 20 82 b7    JSR Eval_String_And_Len
b77f 4c a2 b3    JMP Y_To_Float      ; convert Y to byte in FAC1 and return

              ; *******************
b782            Eval_String_And_Len
              ; *******************

b782 20 a3 b6    JSR Eval_String
b785 a2 00       LDX #$00          ; set data type = numeric
b787 86 0d       STX VALTYP        ; clear data type flag, $FF = string, $00 = numeric
b789 a8          TAY               ; copy length to Y
b78a 60          RTS ;Size    9 [Eval_String_And_Len]

              ; *********
b78b            Basic_ASC
              ; *********

b78b 20 82 b7    JSR Eval_String_And_Len
b78e f0 08       BEQ Jump_To_Illegal_Quantity
b790 a0 00       LDY #0
b792 b1 22       LDA (INDEXA),Y    ; get 1st. byte
b794 a8          TAY               ; copy to Y
b795 4c a2 b3    JMP Y_To_Float

              ; ========================
b798            Jump_To_Illegal_Quantity
              ; ========================

b798 4c 48 b2    JMP Illegal_Quantity

              ; *******************
b79b            Get_Next_Byte_Value
              ; *******************

b79b 20 73 00    JSR CHRGET

              ; --------------
b79e            Get_Byte_Value
              ; --------------

b79e 20 8a ad    JSR Eval_Numeric

              ; *********
b7a1            Eval_Byte
              ; *********

b7a1 20 b8 b1    JSR Eval_Positive_Integer_Check
b7a4 a6 64       LDX FAC1M3        ; high byte must be 0
b7a6 d0 f0       BNE Jump_To_Illegal_Quantity
b7a8 a6 65       LDX FAC1M4
b7aa 4c 79 00    JMP CHRGOT

              ; *********
b7ad            Basic_VAL
              ; *********

b7ad 20 82 b7    JSR Eval_String_And_Len
b7b0 d0 03       BNE VAL_10        ; if not a null string go evaluate it
b7b2 4c f7 b8    JMP Clear_FAC1_Exp_And_Sign

b7b5          VAL_10
                 LDXY(TXTPTR)
b7b5 a6 7a       LDX TXTPTR
b7b7 a4 7b       LDY TXTPTR+1

                 STXY(TMPPTD)
b7b9 86 71       STX TMPPTD
b7bb 84 72       STY TMPPTD+1

b7bd a6 22       LDX INDEXA        ; get string pointer low byte
b7bf 86 7a       STX TXTPTR        ; save BASIC execute pointer low byte
b7c1 18          CLC
b7c2 65 22       ADC INDEXA        ; add string length
b7c4 85 24       STA INDEXB        ; save string end low byte
b7c6 a6 23       LDX INDEXA+1      ; get string pointer high byte
b7c8 86 7b       STX TXTPTR+1      ; save BASIC execute pointer high byte
b7ca 90 01       BCC VAL_20        ; if no rollover skip the high byte increment
b7cc e8          INX               ; increment string end high byte

b7cd          VAL_20
b7cd 86 25       STX INDEXB+1      ; save string end high byte
b7cf a0 00       LDY #0
b7d1 b1 24       LDA (INDEXB),Y    ; get string end byte
b7d3 48          PHA               ; push it
b7d4 98          TYA               ; clear A
b7d5 91 24       STA (INDEXB),Y    ; terminate string with 0
b7d7 20 79 00    JSR CHRGOT
b7da 20 f3 bc    JSR Load_FAC1_From_String
b7dd 68          PLA               ; restore string end byte
b7de a0 00       LDY #0
b7e0 91 24       STA (INDEXB),Y    ; put string end byte back

              ; -------------------------
b7e2            Restore_Execution_Pointer
              ; -------------------------

                 LDXY(TMPPTD)
b7e2 a6 71       LDX TMPPTD
b7e4 a4 72       LDY TMPPTD+1

                 STXY(TXTPTR)
b7e6 86 7a       STX TXTPTR
b7e8 84 7b       STY TXTPTR+1

b7ea 60          RTS ;Size   62 [Basic_VAL]

              ; *****************
b7eb            Get_Word_And_Byte
              ; *****************

b7eb 20 8a ad    JSR Eval_Numeric
b7ee 20 f7 b7    JSR FAC1_To_LINNUM

              ; *******************
b7f1            Need_Comma_Get_Byte
              ; *******************

b7f1 20 fd ae    JSR Need_Comma
b7f4 4c 9e b7    JMP Get_Byte_Value

              ; **************
b7f7            FAC1_To_LINNUM
              ; **************

b7f7 a5 66       LDA FAC1SI        ; get FAC1 sign
b7f9 30 9d       BMI Jump_To_Illegal_Quantity
b7fb a5 61       LDA FAC1EX        ; get FAC1 exponent
b7fd c9 91       CMP #$91          ; compare with exponent = 2^16
b7ff b0 97       BCS Jump_To_Illegal_Quantity
b801 20 9b bc    JSR FAC1_To_Integer
b804 a5 64       LDA FAC1M3        ; get FAC1 mantissa 3
b806 a4 65       LDY FAC1M4        ; get FAC1 mantissa 4
b808 84 14       STY LINNUM        ; save temporary integer low byte
b80a 85 15       STA LINNUM+1      ; save temporary integer high byte
b80c 60          RTS ;Size   22 [FAC1_To_LINNUM]

              ; **********
b80d            Basic_PEEK
              ; **********

                 PUSHW(LINNUM)
b80d a5 15       LDA LINNUM+1
b80f 48          PHA
b810 a5 14       LDA LINNUM
b812 48          PHA

b813 20 f7 b7    JSR FAC1_To_LINNUM
b816 a0 00       LDY #0
b818 b1 14       LDA (LINNUM),Y    ; read byte
b81a a8          TAY               ; copy byte to Y
                 PULLW(LINNUM)
b81b 68          PLA
b81c 85 14       STA LINNUM
b81e 68          PLA
b81f 85 15       STA LINNUM+1

b821 4c a2 b3    JMP Y_To_Float

              ; **********
b824            Basic_POKE
              ; **********

b824 20 eb b7    JSR Get_Word_And_Byte
b827 8a          TXA               ; copy byte to A
b828 a0 00       LDY #0
b82a 91 14       STA (LINNUM),Y    ; write byte
b82c 60          RTS ;Size    9 [Basic_POKE]

              ; **********
b82d            Basic_WAIT
              ; **********

b82d 20 eb b7    JSR Get_Word_And_Byte
b830 86 49       STX FORPNT        ; save byte
b832 a2 00       LDX #0            ; clear mask
b834 20 79 00    JSR CHRGOT
b837 f0 03       BEQ WAIT_10      ; skip if no third argument
b839 20 f1 b7    JSR Need_Comma_Get_Byte

b83c          WAIT_10
b83c 86 4a       STX FORPNT+1      ; save EOR argument
b83e a0 00       LDY #0

b840          WAIT_20
b840 b1 14       LDA (LINNUM),Y    ; get byte via temporary integer (address)
b842 45 4a       EOR FORPNT+1      ; EOR with second argument       (mask)
b844 25 49       AND FORPNT        ; AND with first argument        (byte)
b846 f0 f8       BEQ WAIT_20       ; loop if result is zero

b848          WAIT_Ret
b848 60          RTS ;Size   28 [Basic_WAIT]

              ; ***************
b849            Add_0_5_To_FAC1
              ; ***************

                 LAYI(Float_0_5)
b849 a9 11       LDA #<Float_0_5
b84b a0 bf       LDY #>Float_0_5

b84d 4c 67 b8    JMP Add_Var_AY_To_FAC1

              ; *************
b850            AY_Minus_FAC1
              ; *************

b850 20 8c ba    JSR Load_FAC2_From_AY

              ; ***********
b853            Basic_MINUS
              ; ***********

b853 a5 66       LDA FAC1SI        ; get FAC1 sign (b7)
b855 49 ff       EOR #$FF          ; complement it
b857 85 66       STA FAC1SI        ; save FAC1 sign (b7)
b859 45 6e       EOR FAC2SI        ; EOR with FAC2 sign (b7)
b85b 85 6f       STA STRPTR        ; save sign compare (FAC1 EOR FAC2)
b85d a5 61       LDA FAC1EX        ; get FAC1 exponent
b85f 4c 6a b8    JMP Basic_PLUS    ; add FAC2 to FAC1 and return

b862          PLUS_00
b862 20 99 b9    JSR Shift_FACX_A
b865 90 3c       BCC PLUS_20      ; go subtract the mantissas, branch always

              ; ******************
b867            Add_Var_AY_To_FAC1
              ; ******************

b867 20 8c ba    JSR Load_FAC2_From_AY

              ; **********
b86a            Basic_PLUS
              ; **********

b86a d0 03       BNE PLUS_05      ; if FAC1 is not zero continue
b86c 4c fc bb    JMP FAC2_To_FAC1

b86f          PLUS_05
b86f a6 70       LDX FAC1M5        ; get FAC1 rounding byte
b871 86 56       STX FAC2M5        ; put FAC2 rounding byte
b873 a2 69       LDX #FAC2EX       ; set index to FAC2
b875 a5 69       LDA FAC2EX        ; get FAC2 exponent

              ; ****************
b877            Add_FAC2_To_FAC1
              ; ****************

b877 a8          TAY               ; copy exponent
b878 f0 ce       BEQ WAIT_Ret      ; exit if FAC2 is zero
b87a 38          SEC
b87b e5 61       SBC FAC1EX        ; FAC2 exponent - FAC1 exponent
b87d f0 24       BEQ PLUS_20       ; if equal go add mantissas
b87f 90 12       BCC PLUS_10       ; if FAC2 < FAC1 then shift FAC2 right
b881 84 61       STY FAC1EX        ; else                shift FAC1 right
b883 a4 6e       LDY FAC2SI        ; get FAC2 sign (b7)
b885 84 66       STY FAC1SI        ; put FAC1 sign (b7)
b887 49 ff       EOR #$FF          ; complement A
b889 69 00       ADC #$00          ; +1, twos complement, carry is set
b88b a0 00       LDY #0
b88d 84 56       STY FAC2M5        ; clear FAC2 rounding byte
b88f a2 61       LDX #FAC1EX       ; set index to FAC1
b891 d0 04       BNE PLUS_15       ; branch always

b893          PLUS_10
b893 a0 00       LDY #0
b895 84 70       STY FAC1M5        ; clear FAC1 rounding byte

b897          PLUS_15              ; shift FAC with lower exponent
b897 c9 f9       CMP #$F9          ; compare exponent diff with $F9
b899 30 c7       BMI PLUS_00       ; branch if range $79-$F8
b89b a8          TAY               ; copy exponent difference to Y
b89c a5 70       LDA FAC1M5        ; get FAC1 rounding byte
b89e 56 01       LSR 1,X           ; shift FAC mantissa 1
b8a0 20 b0 b9    JSR Shift_FACX_Right_Y

b8a3          PLUS_20
b8a3 24 6f       BIT STRPTR        ; test sign compare (FAC1 EOR FAC2)
b8a5 10 57       BPL PLUS_50      ; if = add FAC2 mantissa to FAC1 mantissa and return
b8a7 a0 61       LDY #FAC1EX       ; set index to FAC1 exponent address
b8a9 e0 69       CPX #FAC2EX       ; compare X to FAC2 exponent address
b8ab f0 02       BEQ PLUS_25       ; branch if equal
b8ad a0 69       LDY #FAC2EX       ; else set index to FAC2 exponent address

b8af          PLUS_25
b8af 38          SEC               ; compute FACY - FACX
b8b0 49 ff       EOR #$FF          ; ones complement A
b8b2 65 56       ADC FAC2M5        ; add FAC2 rounding byte
b8b4 85 70       STA FAC1M5        ; put FAC1 rounding byte
b8b6 b9 04 00    LDA 4,Y
b8b9 f5 04       SBC 4,X
b8bb 85 65       STA FAC1M4
b8bd b9 03 00    LDA 3,Y
b8c0 f5 03       SBC 3,X
b8c2 85 64       STA FAC1M3
b8c4 b9 02 00    LDA 2,Y
b8c7 f5 02       SBC 2,X
b8c9 85 63       STA FAC1M2
b8cb b9 01 00    LDA 1,Y
b8ce f5 01       SBC 1,X
b8d0 85 62       STA FAC1M1

b8d2          PLUS_30
b8d2 b0 03       BCS Normalise_FAC1
b8d4 20 47 b9    JSR Negate_FAC1

              ; **************
b8d7            Normalise_FAC1
              ; **************

b8d7 a0 00       LDY #0
b8d9 98          TYA
b8da 18          CLC

b8db          PLUS_35
b8db a6 62       LDX FAC1M1        ; get FAC1 mantissa 1
b8dd d0 4a       BNE PLUS_60      ; if not zero normalise FAC1
b8df a6 63       LDX FAC1M2        ; get FAC1 mantissa 2
b8e1 86 62       STX FAC1M1        ; save FAC1 mantissa 1
b8e3 a6 64       LDX FAC1M3        ; get FAC1 mantissa 3
b8e5 86 63       STX FAC1M2        ; save FAC1 mantissa 2
b8e7 a6 65       LDX FAC1M4        ; get FAC1 mantissa 4
b8e9 86 64       STX FAC1M3        ; save FAC1 mantissa 3
b8eb a6 70       LDX FAC1M5        ; get FAC1 rounding byte
b8ed 86 65       STX FAC1M4        ; save FAC1 mantissa 4
b8ef 84 70       STY FAC1M5        ; clear FAC1 rounding byte
b8f1 69 08       ADC #8            ; add x to exponent offset
b8f3 c9 20       CMP #$20          ; compare with $20, max offset, all bits would be = 0
b8f5 d0 e4       BNE PLUS_35       ; loop if not max

              ; =======================
b8f7            Clear_FAC1_Exp_And_Sign
              ; =======================

b8f7 a9 00       LDA #0
b8f9          PLUS_40
b8f9 85 61       STA FAC1EX        ; set FAC1 exponent

b8fb          PLUS_45
b8fb 85 66       STA FAC1SI        ; save FAC1 sign (b7)
b8fd 60          RTS ;Size   39 [Normalise_FAC1]

b8fe          PLUS_50
b8fe 65 56       ADC FAC2M5
b900 85 70       STA FAC1M5
b902 a5 65       LDA FAC1M4
b904 65 6d       ADC FAC2M4
b906 85 65       STA FAC1M4
b908 a5 64       LDA FAC1M3
b90a 65 6c       ADC FAC2M3
b90c 85 64       STA FAC1M3
b90e a5 63       LDA FAC1M2
b910 65 6b       ADC FAC2M2
b912 85 63       STA FAC1M2
b914 a5 62       LDA FAC1M1
b916 65 6a       ADC FAC2M1
b918 85 62       STA FAC1M1
b91a 4c 36 b9    JMP Test_And_Normalize_FAC1

b91d          PLUS_55
b91d 69 01       ADC #1
b91f 06 70       ASL FAC1M5
b921 26 65       ROL FAC1M4
b923 26 64       ROL FAC1M3
b925 26 63       ROL FAC1M2
b927 26 62       ROL FAC1M1

b929          PLUS_60
b929 10 f2       BPL PLUS_55      ; loop if not normalised
b92b 38          SEC
b92c e5 61       SBC FAC1EX        ; subtract FAC1 exponent
b92e b0 c7       BCS Clear_FAC1_Exp_And_Sign ; branch if underflow (set result = $0)
b930 49 ff       EOR #$FF          ; complement exponent
b932 69 01       ADC #$01          ; +1 (twos complement)
b934 85 61       STA FAC1EX        ; save FAC1 exponent

              ; =======================
b936            Test_And_Normalize_FAC1
              ; =======================

b936 90 0e       BCC TANF_Ret      ; exit if no overflow

b938          TANF_10
b938 e6 61       INC FAC1EX        ; increment FAC1 exponent
b93a f0 42       BEQ Overflow_Error
b93c 66 62       ROR FAC1M1        ; shift FAC1 mantissa 1
b93e 66 63       ROR FAC1M2        ; shift FAC1 mantissa 2
b940 66 64       ROR FAC1M3        ; shift FAC1 mantissa 3
b942 66 65       ROR FAC1M4        ; shift FAC1 mantissa 4
b944 66 70       ROR FAC1M5        ; shift FAC1 rounding byte

b946          TANF_Ret
b946 60          RTS ;Size  112 [Normalise_FAC1]

              ; ***********
b947            Negate_FAC1
              ; ***********

b947 a5 66       LDA FAC1SI        ; get FAC1 sign (b7)
b949 49 ff       EOR #$FF          ; complement it
b94b 85 66       STA FAC1SI        ; save FAC1 sign (b7)

              ; ********************
b94d            Negate_FAC1_Mantissa
              ; ********************

b94d a5 62       LDA FAC1M1
b94f 49 ff       EOR #$FF
b951 85 62       STA FAC1M1
b953 a5 63       LDA FAC1M2
b955 49 ff       EOR #$FF
b957 85 63       STA FAC1M2
b959 a5 64       LDA FAC1M3
b95b 49 ff       EOR #$FF
b95d 85 64       STA FAC1M3
b95f a5 65       LDA FAC1M4
b961 49 ff       EOR #$FF
b963 85 65       STA FAC1M4
b965 a5 70       LDA FAC1M5
b967 49 ff       EOR #$FF
b969 85 70       STA FAC1M5
b96b e6 70       INC FAC1M5
b96d d0 0e       BNE IFM_Ret

              ; *****************
b96f            Inc_FAC1_Mantissa
              ; *****************

b96f e6 65       INC FAC1M4
b971 d0 0a       BNE IFM_Ret
b973 e6 64       INC FAC1M3
b975 d0 06       BNE IFM_Ret
b977 e6 63       INC FAC1M2
b979 d0 02       BNE IFM_Ret
b97b e6 62       INC FAC1M1

b97d          IFM_Ret
b97d 60          RTS ;Size   15 [Inc_FAC1_Mantissa]

              ; ==============
b97e            Overflow_Error
              ; ==============

b97e a2 0f       LDX #$0F          ; error $0F, overflow error
b980 4c 37 a4    JMP Basic_Error

              ; ==========
b983            Shift_FAC3
              ; ==========

b983 a2 25       LDX #FAC3         ; apply shift routines on FAC3

              ; ==========
b985            Shift_FACX
              ; ==========

b985 b4 04       LDY 4,X
b987 84 70       STY FAC1M5      ; mantissa 4 -> rounding byte
b989 b4 03       LDY 3,X
b98b 94 04       STY 4,X           ; mantissa 3 -> 4
b98d b4 02       LDY 2,X
b98f 94 03       STY 3,X           ; mantissa 2 -> 3
b991 b4 01       LDY 1,X
b993 94 02       STY 2,X           ; mantissa 1 -> 2
b995 a4 68       LDY FAC1OV
b997 94 01       STY 1,X           ; overflow -> mantissa 1

              ; ************
b999            Shift_FACX_A
              ; ************

b999 69 08       ADC #8            ; add 8 to shift count
b99b 30 e8       BMI Shift_FACX    ; if still negative shift byte wise
b99d f0 e6       BEQ Shift_FACX    ; 8 shifts to do
b99f e9 08       SBC #8            ; reverse the addition
b9a1 a8          TAY               ; save shift count to Y
b9a2 a5 70       LDA FAC1M5      ; get FAC1 rounding byte
b9a4 b0 14       BCS ShFA_30

b9a6          ShFA_10
b9a6 16 01       ASL 1,X           ; shift sign to carry, bit0 set to 0
b9a8 90 02       BCC ShFA_20       ; branch if positive
b9aa f6 01       INC 1,X           ; bit0 set to 1

b9ac          ShFA_20              ; bit0 equals now sign (in carry)
b9ac 76 01       ROR 1,X           ; shift FACX mantissa 1 with sign extension
b9ae 76 01       ROR 1,X           ; shift FACX mantissa 1 with sign extension

              ; ******************
b9b0            Shift_FACX_Right_Y
              ; ******************

b9b0 76 02       ROR 2,X           ; shift FACX mantissa 2
b9b2 76 03       ROR 3,X           ; shift FACX mantissa 3
b9b4 76 04       ROR 4,X           ; shift FACX mantissa 4
b9b6 6a          ROR A             ; shift FACX rounding byte
b9b7 c8          INY               ; increment exponent diff
b9b8 d0 ec       BNE ShFA_10       ; branch if range adjust not complete

b9ba          ShFA_30
b9ba 18          CLC               ; just clear it
b9bb 60          RTS ;Size   12 [Shift_FACX_Right_Y]

              ; constants and series for LOG(n)

b9bc 81 00 00 REAL_1 .real 1

b9c1          VLOG_A
b9c1 03          .byte   $03            ; series counter
b9c2 7f 5e 56    .real   0.4342559419
b9c7 80 13 9b    .real   0.5765845413
b9cc 80 76 38    .real   0.9618007592
b9d1 82 38 aa    .real   2.8853900731

b9d6 80 35 04 HALF_SQRT_2 .real   0.7071067812  ; 0.5 * sqrt(2.0)
b9db 81 35 04 SQRT_2      .real   1.4142135624  ; sqrt(2.0)
b9e0 80 80 00 MINUS_0_5   .real  -0.5
b9e5 80 31 72 LN_2        .real   0.6931471807  ; ln(2.0)

              ; *********
b9ea            Basic_LOG
              ; *********

b9ea 20 2b bc    JSR Get_FAC1_Sign
b9ed f0 02       BEQ LOG_10        ; if zero do illegal quantity
b9ef 10 03       BPL LOG_20        ; skip error if positive

b9f1          LOG_10
b9f1 4c 48 b2    JMP Illegal_Quantity      ; do illegal quantity error then warm start

b9f4          LOG_20
b9f4 a5 61       LDA FAC1EX        ; get FAC1 exponent
b9f6 e9 7f       SBC #$7F          ; normalise it
b9f8 48          PHA               ; save it
b9f9 a9 80       LDA #$80          ; set exponent to zero
b9fb 85 61       STA FAC1EX        ; save FAC1 exponent
                 LAYI(HALF_SQRT_2)
b9fd a9 d6       LDA #<HALF_SQRT_2
b9ff a0 b9       LDY #>HALF_SQRT_2

ba01 20 67 b8    JSR Add_Var_AY_To_FAC1
                 LAYI(SQRT_2)
ba04 a9 db       LDA #<SQRT_2
ba06 a0 b9       LDY #>SQRT_2

ba08 20 0f bb    JSR AY_Divided_By_FAC1
                 LAYI(REAL_1)
ba0b a9 bc       LDA #<REAL_1
ba0d a0 b9       LDY #>REAL_1

ba0f 20 50 b8    JSR AY_Minus_FAC1
                 LAYI(VLOG_A)
ba12 a9 c1       LDA #<VLOG_A
ba14 a0 b9       LDY #>VLOG_A

ba16 20 43 e0    JSR Square_And_Series_Eval
                 LAYI(MINUS_0_5)
ba19 a9 e0       LDA #<MINUS_0_5
ba1b a0 b9       LDY #>MINUS_0_5

ba1d 20 67 b8    JSR Add_Var_AY_To_FAC1
ba20 68          PLA               ; restore FAC1 exponent
ba21 20 7e bd    JSR Add_A_To_FAC1
                 LAYI(LN_2)
ba24 a9 e5       LDA #<LN_2
ba26 a0 b9       LDY #>LN_2


              ; *********************
ba28            Multiply_FAC1_With_AY
              ; *********************

ba28 20 8c ba    JSR Load_FAC2_From_AY

              ; **************
ba2b            Basic_MULTIPLY
              ; **************

ba2b d0 03       BNE MULT_10       ; multiply FAC1 by FAC2 ??
ba2d 4c 8b ba    JMP Mult_Sub_Ret  ; exit if zero

ba30          MULT_10
ba30 20 b7 ba    JSR Check_FACs
ba33 a9 00       LDA #0
ba35 85 26       STA FAC3+1
ba37 85 27       STA FAC3+2
ba39 85 28       STA FAC3+3
ba3b 85 29       STA FAC3+4
ba3d a5 70       LDA FAC1M5
ba3f 20 59 ba    JSR Mult_SubA
ba42 a5 65       LDA FAC1M4
ba44 20 59 ba    JSR Mult_SubA
ba47 a5 64       LDA FAC1M3
ba49 20 59 ba    JSR Mult_SubA
ba4c a5 63       LDA FAC1M2
ba4e 20 59 ba    JSR Mult_SubA
ba51 a5 62       LDA FAC1M1
ba53 20 5e ba    JSR Mult_SubB
ba56 4c 8f bb    JMP FAC3_To_FAC1

              ; =========
ba59            Mult_SubA
              ; =========

ba59 d0 03       BNE Mult_SubB
ba5b 4c 83 b9    JMP Shift_FAC3

              ; =========
ba5e            Mult_SubB
              ; =========

ba5e 4a          LSR A             ; shift byte
ba5f 09 80       ORA #$80          ; set top bit (mark for 8 times)

ba61          MULT_20
ba61 a8          TAY               ; copy result
ba62 90 19       BCC MULT_30       ; skip next if bit was zero
ba64 18          CLC
ba65 a5 29       LDA FAC3+4
ba67 65 6d       ADC FAC2M4
ba69 85 29       STA FAC3+4
ba6b a5 28       LDA FAC3+3
ba6d 65 6c       ADC FAC2M3
ba6f 85 28       STA FAC3+3
ba71 a5 27       LDA FAC3+2
ba73 65 6b       ADC FAC2M2
ba75 85 27       STA FAC3+2
ba77 a5 26       LDA FAC3+1
ba79 65 6a       ADC FAC2M1
ba7b 85 26       STA FAC3+1

ba7d          MULT_30
ba7d 66 26       ROR FAC3+1
ba7f 66 27       ROR FAC3+2
ba81 66 28       ROR FAC3+3
ba83 66 29       ROR FAC3+4
ba85 66 70       ROR FAC1M5
ba87 98          TYA               ; get byte back
ba88 4a          LSR A             ; shift byte
ba89 d0 d6       BNE MULT_20       ; loop if all bits not done

ba8b          Mult_Sub_Ret
ba8b 60          RTS ;Size   97 [Basic_MULTIPLY]

              ; *****************
ba8c            Load_FAC2_From_AY
              ; *****************

                 STAY(INDEXA)
ba8c 85 22       STA INDEXA
ba8e 84 23       STY INDEXA+1

ba90 a0 04       LDY #4            ; 5 bytes to get (0-4)
ba92 b1 22       LDA (INDEXA),Y    ; get mantissa 4
ba94 85 6d       STA FAC2M4        ; save FAC2 mantissa 4
ba96 88          DEY               ; decrement index
ba97 b1 22       LDA (INDEXA),Y    ; get mantissa 3
ba99 85 6c       STA FAC2M3        ; save FAC2 mantissa 3
ba9b 88          DEY               ; decrement index
ba9c b1 22       LDA (INDEXA),Y    ; get mantissa 2
ba9e 85 6b       STA FAC2M2        ; save FAC2 mantissa 2
baa0 88          DEY               ; decrement index
baa1 b1 22       LDA (INDEXA),Y    ; get mantissa 1 + sign
baa3 85 6e       STA FAC2SI        ; save FAC2 sign (b7)
baa5 45 66       EOR FAC1SI        ; EOR with FAC1 sign (b7)
baa7 85 6f       STA STRPTR        ; save sign compare (FAC1 EOR FAC2)
baa9 a5 6e       LDA FAC2SI        ; recover FAC2 sign (b7)
baab 09 80       ORA #$80          ; set 1xxx xxx (set normal bit)
baad 85 6a       STA FAC2M1        ; save FAC2 mantissa 1
baaf 88          DEY               ; decrement index
bab0 b1 22       LDA (INDEXA),Y    ; get exponent byte
bab2 85 69       STA FAC2EX        ; save FAC2 exponent
bab4 a5 61       LDA FAC1EX        ; get FAC1 exponent
bab6 60          RTS ;Size   43 [Load_FAC2_From_AY]

              ; **********
bab7            Check_FACs
              ; **********

bab7 a5 69       LDA FAC2EX        ; get FAC2 exponent

              ; ------------
bab9            Check_FACs_A
              ; ------------

bab9 f0 1f       BEQ ChFA_30       ; branch if FAC2 = $00 (handle underflow)
babb 18          CLC
babc 65 61       ADC FAC1EX        ; add FAC1 exponent
babe 90 04       BCC ChFA_10       ; branch if sum of exponents < $0100
bac0 30 1d       BMI ChFA_40       ; do overflow error
bac2 18          CLC
bac3 2c          .byte   $2C       ; skip next statement

bac4          ChFA_10
bac4 10 14       BPL ChFA_30       ; if positive go handle underflow
bac6 69 80       ADC #$80          ; adjust exponent
bac8 85 61       STA FAC1EX        ; save FAC1 exponent
baca d0 03       BNE ChFA_20       ; branch if not zero
bacc 4c fb b8    JMP PLUS_45       ; save FAC1 sign and return

bacf          ChFA_20
bacf a5 6f       LDA STRPTR        ; get sign compare (FAC1 EOR FAC2)
bad1 85 66       STA FAC1SI        ; save FAC1 sign (b7)
bad3 60          RTS ;Size   29 [Check_FACs]

              ; **************
bad4            Check_Overflow
              ; **************

bad4 a5 66       LDA FAC1SI        ; get FAC1 sign (b7)
bad6 49 ff       EOR #$FF          ; complement it
bad8 30 05       BMI ChFA_40       ; do overflow error

bada          ChFA_30
bada 68          PLA               ; pop return address low byte
badb 68          PLA               ; pop return address high byte
badc 4c f7 b8    JMP Clear_FAC1_Exp_And_Sign

badf          ChFA_40
badf 4c 7e b9    JMP Overflow_Error

              ; *******************
bae2            Multiply_FAC1_BY_10
              ; *******************

bae2 20 0c bc    JSR FAC1_Round_And_Copy_To_FAC2
bae5 aa          TAX               ; copy exponent (set the flags)
bae6 f0 10       BEQ Mu10_Ret      ; exit if zero
bae8 18          CLC
bae9 69 02       ADC #$02          ; add two to exponent (*4)
baeb b0 f2       BCS ChFA_40       ; do overflow error if > $FF

              ; ------------------
baed            Multiply_FAC1_By_4
              ; ------------------

baed a2 00       LDX #0
baef 86 6f       STX STRPTR        ; clear sign compare (FAC1 EOR FAC2)
baf1 20 77 b8    JSR Add_FAC2_To_FAC1
baf4 e6 61       INC FAC1EX        ; increment FAC1 exponent (*2)
baf6 f0 e7       BEQ ChFA_40       ; if exponent now zero go do overflow error

baf8          Mu10_Ret
baf8 60          RTS ;Size   23 [Multiply_FAC1_BY_10]

baf9 84 20 00 Float_10 .real 10

              ; *****************
bafe            Divide_FAC1_By_10
              ; *****************

bafe 20 0c bc    JSR FAC1_Round_And_Copy_To_FAC2
                 LAYI(Float_10)
bb01 a9 f9       LDA #<Float_10
bb03 a0 ba       LDY #>Float_10

bb05 a2 00       LDX #0            ; clear sign

              ; *****************
bb07            Divide_FAC2_By_AY
              ; *****************

bb07 86 6f       STX STRPTR        ; save sign compare (FAC1 EOR FAC2)
bb09 20 a2 bb    JSR Load_FAC1_AY
bb0c 4c 12 bb    JMP Basic_DIVIDE  ; do FAC2/FAC1

              ; ******************
bb0f            AY_Divided_By_FAC1
              ; ******************

bb0f 20 8c ba    JSR Load_FAC2_From_AY

              ; ************
bb12            Basic_DIVIDE
              ; ************

bb12 f0 76       BEQ Divide_By_Zero; if zero go do /0 error
bb14 20 1b bc    JSR Round_FAC1_Checked
bb17 a9 00       LDA #0
bb19 38          SEC
bb1a e5 61       SBC FAC1EX        ; subtract FAC1 exponent (2s complement)
bb1c 85 61       STA FAC1EX        ; save FAC1 exponent
bb1e 20 b7 ba    JSR Check_FACs
bb21 e6 61       INC FAC1EX        ; increment FAC1 exponent
bb23 f0 ba       BEQ ChFA_40       ; if zero do overflow error
bb25 a2 fc       LDX #$FC          ; set index to FAC temp
bb27 a9 01       LDA #$01          ; set byte

bb29          DIVI_10
bb29 a4 6a       LDY FAC2M1        ; compare mantissa
bb2b c4 62       CPY FAC1M1
bb2d d0 10       BNE DIVI_20
bb2f a4 6b       LDY FAC2M2
bb31 c4 63       CPY FAC1M2
bb33 d0 0a       BNE DIVI_20
bb35 a4 6c       LDY FAC2M3
bb37 c4 64       CPY FAC1M3
bb39 d0 04       BNE DIVI_20
bb3b a4 6d       LDY FAC2M4
bb3d c4 65       CPY FAC1M4

bb3f          DIVI_20
bb3f 08          PHP               ; save the FAC2-FAC1 compare status
bb40 2a          ROL A             ; shift byte
bb41 90 09       BCC DIVI_30       ; skip next if no carry
bb43 e8          INX               ; increment index to FAC temp
bb44 95 29       STA FAC3+4,X
bb46 f0 32       BEQ DIVI_60
bb48 10 34       BPL DIVI_70
bb4a a9 01       LDA #1

bb4c          DIVI_30
bb4c 28          PLP               ; restore FAC2-FAC1 compare status
bb4d b0 0e       BCS DIVI_50       ; if FAC2 >= FAC1 then do subtract

bb4f          DIVI_40
bb4f 06 6d       ASL FAC2M4        ; shift FAC2 mantissa 4
bb51 26 6c       ROL FAC2M3        ; shift FAC2 mantissa 3
bb53 26 6b       ROL FAC2M2        ; shift FAC2 mantissa 2
bb55 26 6a       ROL FAC2M1        ; shift FAC2 mantissa 1
bb57 b0 e6       BCS DIVI_20       ; loop with no compare
bb59 30 ce       BMI DIVI_10       ; loop with compare
bb5b 10 e2       BPL DIVI_20       ; loop always with no compare

bb5d          DIVI_50
bb5d a8          TAY               ; save FAC2-FAC1 compare status
bb5e a5 6d       LDA FAC2M4        ; FAC2 = FAC2 - FAC1
bb60 e5 65       SBC FAC1M4
bb62 85 6d       STA FAC2M4
bb64 a5 6c       LDA FAC2M3
bb66 e5 64       SBC FAC1M3
bb68 85 6c       STA FAC2M3
bb6a a5 6b       LDA FAC2M2
bb6c e5 63       SBC FAC1M2
bb6e 85 6b       STA FAC2M2
bb70 a5 6a       LDA FAC2M1
bb72 e5 62       SBC FAC1M1
bb74 85 6a       STA FAC2M1
bb76 98          TYA               ; restore FAC2-FAC1 compare status
bb77 4c 4f bb    JMP DIVI_40       ; go shift FAC2

bb7a          DIVI_60
bb7a a9 40       LDA #$40
bb7c d0 ce       BNE DIVI_30

bb7e          DIVI_70
bb7e 0a          ASL A
bb7f 0a          ASL A
bb80 0a          ASL A
bb81 0a          ASL A
bb82 0a          ASL A
bb83 0a          ASL A
bb84 85 70       STA FAC1M5        ; save FAC1 rounding byte
bb86 28          PLP               ; dump FAC2-FAC1 compare status
bb87 4c 8f bb    JMP FAC3_To_FAC1

              ; ==============
bb8a            Divide_By_Zero
              ; ==============

bb8a a2 14       LDX #$14          ; error $14, divide by zero error
bb8c 4c 37 a4    JMP Basic_Error

              ; ============
bb8f            FAC3_To_FAC1
              ; ============

bb8f a5 26       LDA FAC3+1
bb91 85 62       STA FAC1M1
bb93 a5 27       LDA FAC3+2
bb95 85 63       STA FAC1M2
bb97 a5 28       LDA FAC3+3
bb99 85 64       STA FAC1M3
bb9b a5 29       LDA FAC3+4
bb9d 85 65       STA FAC1M4
bb9f 4c d7 b8    JMP Normalise_FAC1

              ; ************
bba2            Load_FAC1_AY
              ; ************

                 STAY(INDEXA)
bba2 85 22       STA INDEXA
bba4 84 23       STY INDEXA+1

bba6 a0 04       LDY #$04          ; 5 bytes to do
bba8 b1 22       LDA (INDEXA),Y    ; get fifth byte
bbaa 85 65       STA FAC1M4        ; save FAC1 mantissa 4
bbac 88          DEY               ; decrement index
bbad b1 22       LDA (INDEXA),Y    ; get fourth byte
bbaf 85 64       STA FAC1M3        ; save FAC1 mantissa 3
bbb1 88          DEY               ; decrement index
bbb2 b1 22       LDA (INDEXA),Y    ; get third byte
bbb4 85 63       STA FAC1M2        ; save FAC1 mantissa 2
bbb6 88          DEY               ; decrement index
bbb7 b1 22       LDA (INDEXA),Y    ; get second byte
bbb9 85 66       STA FAC1SI        ; save FAC1 sign (b7)
bbbb 09 80       ORA #$80          ; set 1xxx xxxx (add normal bit)
bbbd 85 62       STA FAC1M1        ; save FAC1 mantissa 1
bbbf 88          DEY               ; decrement index
bbc0 b1 22       LDA (INDEXA),Y    ; get first byte (exponent)
bbc2 85 61       STA FAC1EX        ; save FAC1 exponent
bbc4 84 70       STY FAC1M5        ; clear FAC1 rounding byte
bbc6 60          RTS ;Size   37 [Load_FAC1_AY]

              ; **************
bbc7            FAC1_To_FACTPB
              ; **************

bbc7 a2 5c       LDX #<FACTPB      ; set pointer low byte
bbc9 2c          .byte   $2C       ; skip next statement

              ; **************
bbca            FAC1_To_FACTPA
              ; **************

bbca a2 57       LDX #<FACTPA      ; set pointer low byte
bbcc a0 00       LDY #>FACTPA      ; set pointer high byte
bbce f0 04       BEQ Assign_FAC1_To_Var

              ; ************************
bbd0            Assign_FAC1_To_FOR_Index
              ; ************************

                 LDXY(FORPNT)
bbd0 a6 49       LDX FORPNT
bbd2 a4 4a       LDY FORPNT+1


              ; ******************
bbd4            Assign_FAC1_To_Var
              ; ******************

bbd4 20 1b bc    JSR Round_FAC1_Checked
                 STXY(INDEXA)
bbd7 86 22       STX INDEXA
bbd9 84 23       STY INDEXA+1

bbdb a0 04       LDY #$04          ; set index
bbdd a5 65       LDA FAC1M4        ; get FAC1 mantissa 4
bbdf 91 22       STA (INDEXA),Y    ; store in destination
bbe1 88          DEY               ; decrement index
bbe2 a5 64       LDA FAC1M3        ; get FAC1 mantissa 3
bbe4 91 22       STA (INDEXA),Y    ; store in destination
bbe6 88          DEY               ; decrement index
bbe7 a5 63       LDA FAC1M2        ; get FAC1 mantissa 2
bbe9 91 22       STA (INDEXA),Y    ; store in destination
bbeb 88          DEY               ; decrement index
bbec a5 66       LDA FAC1SI        ; get FAC1 sign (b7)
bbee 09 7f       ORA #$7F          ; set bits x111 1111
bbf0 25 62       AND FAC1M1        ; AND in FAC1 mantissa 1
bbf2 91 22       STA (INDEXA),Y    ; store in destination
bbf4 88          DEY               ; decrement index
bbf5 a5 61       LDA FAC1EX        ; get FAC1 exponent
bbf7 91 22       STA (INDEXA),Y    ; store in destination
bbf9 84 70       STY FAC1M5        ; clear FAC1 rounding byte
bbfb 60          RTS ;Size   40 [Assign_FAC1_To_Var]

              ; ************
bbfc            FAC2_To_FAC1
              ; ************

bbfc a5 6e       LDA FAC2SI        ; get FAC2 sign (b7)

              ; ---------------------
bbfe            Copy_ABS_FAC2_To_FAC1
              ; ---------------------

bbfe 85 66       STA FAC1SI        ; save FAC1 sign (b7)
bc00 a2 05       LDX #5            ; 5 bytes to copy

bc02          F2F1_Loop
bc02 b5 68       LDA FAC2EX-1,X
bc04 95 60       STA FAC1EX-1,X
bc06 ca          DEX
bc07 d0 f9       BNE F2F1_Loop
bc09 86 70       STX FAC1M5        ; clear FAC1 rounding byte
bc0b 60          RTS ;Size   16 [FAC2_To_FAC1]

              ; ***************************
bc0c            FAC1_Round_And_Copy_To_FAC2
              ; ***************************

bc0c 20 1b bc    JSR Round_FAC1_Checked

              ; ************
bc0f            FAC1_To_FAC2
              ; ************

bc0f a2 06       LDX #6

bc11          F1F2_Loop
bc11 b5 60       LDA FAC1EX-1,X
bc13 95 68       STA FAC2EX-1,X
bc15 ca          DEX
bc16 d0 f9       BNE F1F2_Loop
bc18 86 70       STX FAC1M5        ; clear FAC1 rounding byte

bc1a          F1F2_Ret
bc1a 60          RTS ;Size   12 [FAC1_To_FAC2]

              ; ******************
bc1b            Round_FAC1_Checked
              ; ******************

bc1b a5 61       LDA FAC1EX        ; get FAC1 exponent
bc1d f0 fb       BEQ F1F2_Ret      ; exit if zero
bc1f 06 70       ASL FAC1M5        ; shift FAC1 rounding byte
bc21 90 f7       BCC F1F2_Ret      ; exit if no overflow

              ; ----------
bc23            Round_FAC1
              ; ----------

bc23 20 6f b9    JSR Inc_FAC1_Mantissa
bc26 d0 f2       BNE F1F2_Ret      ; branch if no overflow
bc28 4c 38 b9    JMP TANF_10       ; normalise FAC1 for C=1 and return

              ; *************
bc2b            Get_FAC1_Sign
              ; *************

bc2b a5 61       LDA FAC1EX        ; get FAC1 exponent
bc2d f0 09       BEQ GFS_Ret       ; exit if zero

bc2f          GFS_10
bc2f a5 66       LDA FAC1SI        ; else get FAC1 sign (b7)

bc31          GFS_20
bc31 2a          ROL A             ; move sign bit to carry
bc32 a9 ff       LDA #$FF          ; set byte for negative result
bc34 b0 02       BCS GFS_Ret       ; return if sign was set (negative)

bc36 a9 01       LDA #1            ; else set byte for positive result
bc38          GFS_Ret
bc38 60          RTS ;Size   14 [Get_FAC1_Sign]

              ; *********
bc39            Basic_SGN
              ; *********

bc39 20 2b bc    JSR Get_FAC1_Sign

              ; *********
bc3c            A_To_FAC1
              ; *********

bc3c 85 62       STA FAC1M1        ; save FAC1 mantissa 1
bc3e a9 00       LDA #0
bc40 85 63       STA FAC1M2        ; clear FAC1 mantissa 2
bc42 a2 88       LDX #$88          ; set exponent

              ; ==================
bc44            Int_To_Float_Exp_X
              ; ==================

bc44 a5 62       LDA FAC1M1        ; get FAC1 mantissa 1
bc46 49 ff       EOR #$FF          ; complement it
bc48 2a          ROL A             ; sign bit into carry

              ; ****************
bc49            Convert_Integer_To_Float
              ; ****************

bc49 a9 00       LDA #0
bc4b 85 65       STA FAC1M4        ; clear FAC1 mantissa 4
bc4d 85 64       STA FAC1M3        ; clear FAC1 mantissa 3

              ; set exponent = X and normalise FAC1

bc4f          CITF_10
bc4f 86 61       STX FAC1EX        ; set FAC1 exponent
bc51 85 70       STA FAC1M5        ; clear FAC1 rounding byte
bc53 85 66       STA FAC1SI        ; clear FAC1 sign (b7)
bc55 4c d2 b8    JMP PLUS_30       ; do ABS and normalise FAC1

              ; *********
bc58            Basic_ABS
              ; *********

bc58 46 66       LSR FAC1SI        ; clear FAC1 sign, put zero in b7
bc5a 60          RTS ;Size    3 [Basic_ABS]

              ; ***************
bc5b            Compare_FAC1_AY
              ; ***************

bc5b 85 24       STA INDEXB        ; save pointer low byte

              ; returns A =  0 if FAC1 = (AY)
              ; returns A =  1 if FAC1 > (AY)
              ; returns A = -1 if FAC1 < (AY)

              ; ---------------------
bc5d            Compare_FAC1_INDEXB_Y
              ; ---------------------

bc5d 84 25       STY INDEXB+1      ; save pointer high byte
bc5f a0 00       LDY #0
bc61 b1 24       LDA (INDEXB),Y    ; get exponent
bc63 c8          INY
bc64 aa          TAX               ; copy (AY) exponent to X
bc65 f0 c4       BEQ Get_FAC1_Sign
bc67 b1 24       LDA (INDEXB),Y    ; get (AY) mantissa 1, with sign
bc69 45 66       EOR FAC1SI        ; EOR FAC1 sign (b7)
bc6b 30 c2       BMI GFS_10        ; if signs <> do return A = $FF, Cb = 1/negative
bc6d e4 61       CPX FAC1EX        ; compare (AY) exponent with FAC1 exponent
bc6f d0 21       BNE CPFA_10       ; branch if different
bc71 b1 24       LDA (INDEXB),Y    ; get (AY) mantissa 1, with sign
bc73 09 80       ORA #$80          ; normalise top bit
bc75 c5 62       CMP FAC1M1        ; compare with FAC1 mantissa 1
bc77 d0 19       BNE CPFA_10       ; branch if different
bc79 c8          INY
bc7a b1 24       LDA (INDEXB),Y    ; get mantissa 2
bc7c c5 63       CMP FAC1M2        ; compare with FAC1 mantissa 2
bc7e d0 12       BNE CPFA_10       ; branch if different
bc80 c8          INY
bc81 b1 24       LDA (INDEXB),Y    ; get mantissa 3
bc83 c5 64       CMP FAC1M3        ; compare with FAC1 mantissa 3
bc85 d0 0b       BNE CPFA_10       ; branch if different
bc87 c8          INY
bc88 a9 7f       LDA #$7F          ; set for 1/2 value rounding byte
bc8a c5 70       CMP FAC1M5        ; compare with FAC1 rounding byte (set carry)
bc8c b1 24       LDA (INDEXB),Y    ; get mantissa 4
bc8e e5 65       SBC FAC1M4        ; subtract FAC1 mantissa 4
bc90 f0 28       BEQ FATI_20       ; exit if mantissa 4 equal

              ; gets here if number <> FAC1

bc92          CPFA_10
bc92 a5 66       LDA FAC1SI        ; get FAC1 sign (b7)
bc94 90 02       BCC CPFA_20       ; branch if FAC1 > (AY)
bc96 49 ff       EOR #$FF          ; else toggle FAC1 sign

bc98          CPFA_20
bc98 4c 31 bc    JMP GFS_20        ; return A = $FF, Cb = 1/negative A = $01, Cb = 0/positive

              ; ***************
bc9b            FAC1_To_Integer
              ; ***************

bc9b a5 61       LDA FAC1EX
bc9d f0 4a       BEQ Clear_FAC1
bc9f 38          SEC
bca0 e9 a0       SBC #$A0          ; subtract maximum integer range exponent
bca2 24 66       BIT FAC1SI        ; test FAC1 sign (b7)
bca4 10 09       BPL FATI_10       ; branch if FAC1 positive
bca6 aa          TAX               ; copy subtracted exponent
bca7 a9 ff       LDA #$FF          ; overflow for negative number
bca9 85 68       STA FAC1OV        ; set FAC1 overflow byte
bcab 20 4d b9    JSR Negate_FAC1_Mantissa
bcae 8a          TXA               ; restore subtracted exponent

bcaf          FATI_10
bcaf a2 61       LDX #FAC1EX
bcb1 c9 f9       CMP #$F9          ; compare exponent result
bcb3 10 06       BPL FATI_30       ; less than 8 shifts
bcb5 20 99 b9    JSR Shift_FACX_A
bcb8 84 68       STY FAC1OV        ; clear FAC1 overflow byte

bcba          FATI_20
bcba 60          RTS ;Size   32 [FAC1_To_Integer]

bcbb          FATI_30
bcbb a8          TAY               ; copy shift count
bcbc a5 66       LDA FAC1SI        ; get FAC1 sign (b7)
bcbe 29 80       AND #$80          ; mask sign bit only (x000 0000)
bcc0 46 62       LSR FAC1M1        ; shift FAC1 mantissa 1
bcc2 05 62       ORA FAC1M1        ; OR sign in b7 FAC1 mantissa 1
bcc4 85 62       STA FAC1M1        ; save FAC1 mantissa 1
bcc6 20 b0 b9    JSR Shift_FACX_Right_Y
bcc9 84 68       STY FAC1OV        ; clear FAC1 overflow byte
bccb 60          RTS ;Size   49 [FAC1_To_Integer]

              ; *********
bccc            Basic_INT
              ; *********

bccc a5 61       LDA FAC1EX        ; get FAC1 exponent
bcce c9 a0       CMP #$A0          ; compare with max int
bcd0 b0 20       BCS ClF1_Ret      ; exit if >= (allready int, too big for fractional part!)
bcd2 20 9b bc    JSR FAC1_To_Integer
bcd5 84 70       STY FAC1M5        ; save FAC1 rounding byte
bcd7 a5 66       LDA FAC1SI        ; get FAC1 sign (b7)
bcd9 84 66       STY FAC1SI        ; save FAC1 sign (b7)
bcdb 49 80       EOR #$80          ; toggle FAC1 sign
bcdd 2a          ROL A             ; shift into carry
bcde a9 a0       LDA #$A0          ; set new exponent
bce0 85 61       STA FAC1EX        ; save FAC1 exponent
bce2 a5 65       LDA FAC1M4        ; get FAC1 mantissa 4
bce4 85 07       STA CHARAC        ; save FAC1 mantissa 4 for power function
bce6 4c d2 b8    JMP PLUS_30      ; do ABS and normalise FAC1

              ; ==========
bce9            Clear_FAC1
              ; ==========

bce9 85 62       STA FAC1M1
bceb 85 63       STA FAC1M2
bced 85 64       STA FAC1M3
bcef 85 65       STA FAC1M4
bcf1 a8          TAY

bcf2          ClF1_Ret
bcf2 60          RTS ;Size   39 [Basic_INT]

              ; *********************
bcf3            Load_FAC1_From_String
              ; *********************

bcf3 a0 00       LDY #0
bcf5 a2 0a       LDX #10

bcf7          LFFS_05
bcf7 94 5d       STY TMPVA1,X      ; clear 10 bytes TMPVA1 & FAC1 ($5D - $66)
bcf9 ca          DEX
bcfa 10 fb       BPL LFFS_05
bcfc 90 0f       BCC LFFS_20       ; branch if first character is numeric
bcfe c9 2d       CMP #'-'          ; else compare with "-"
bd00 d0 04       BNE LFFS_10       ; branch if not "-"
bd02 86 67       STX SGNFLG        ; set flag for negative n (X = $FF)
bd04 f0 04       BEQ LFFS_15       ; branch always

bd06          LFFS_10
bd06 c9 2b       CMP #'+'          ; else compare with "+"
bd08 d0 05       BNE LFFS_25       ; branch if not "+"

bd0a          LFFS_15
bd0a 20 73 00    JSR CHRGET        ; next char

bd0d          LFFS_20
bd0d 90 5b       BCC LFFS_75       ; branch if numeric character

bd0f          LFFS_25
bd0f c9 2e       CMP #'.'
bd11 f0 2e       BEQ LFFS_40
bd13 c9 45       CMP #'E'
bd15 d0 30       BNE LFFS_45
bd17 20 73 00    JSR CHRGET        ; read exponent
bd1a 90 17       BCC LFFS_37       ; branch if numeric character
bd1c c9 ab       CMP #TK_MINUS
bd1e f0 0e       BEQ LFFS_30
bd20 c9 2d       CMP #'-'
bd22 f0 0a       BEQ LFFS_30
bd24 c9 aa       CMP #TK_PLUS
bd26 f0 08       BEQ LFFS_35
bd28 c9 2b       CMP #'+'
bd2a f0 04       BEQ LFFS_35
bd2c d0 07       BNE LFFS_38       ; branch always

bd2e          LFFS_30
bd2e 66 60       ROR TMPPTC+1      ; set exponent negative flag (ror carry into sign)

bd30          LFFS_35
bd30 20 73 00    JSR CHRGET        ; next char of exponent

bd33          LFFS_37
bd33 90 5c       BCC LFFS_85       ; branch if numeric character

bd35          LFFS_38
bd35 24 60       BIT TMPPTC+1      ; test exponent negative flag
bd37 10 0e       BPL LFFS_45       ; if positive go evaluate exponent
bd39 a9 00       LDA #0
bd3b 38          SEC
bd3c e5 5e       SBC TMPVA2        ; negate exponent
bd3e 4c 49 bd    JMP LFFS_50       ; go evaluate exponent

bd41          LFFS_40
bd41 66 5f       ROR TMPPTC        ; set decimal point flag
bd43 24 5f       BIT TMPPTC        ; test decimal point flag
bd45 50 c3       BVC LFFS_15       ; branch if only one decimal point so far

bd47          LFFS_45
bd47 a5 5e       LDA TMPVA2        ; get exponent count byte

bd49          LFFS_50
bd49 38          SEC
bd4a e5 5d       SBC TMPVA1        ; subtract numerator exponent
bd4c 85 5e       STA TMPVA2        ; save exponent count byte
bd4e f0 12       BEQ LFFS_65       ; branch if no adjustment
bd50 10 09       BPL LFFS_60       ; else if positive go do FAC1*10^expcnt

bd52          LFFS_55
bd52 20 fe ba    JSR Divide_FAC1_By_10
bd55 e6 5e       INC TMPVA2        ; increment exponent count byte
bd57 d0 f9       BNE LFFS_55       ; loop until all done
bd59 f0 07       BEQ LFFS_65       ; branch always

bd5b          LFFS_60
bd5b 20 e2 ba    JSR Multiply_FAC1_BY_10
bd5e c6 5e       DEC TMPVA2        ; decrement exponent count byte
bd60 d0 f9       BNE LFFS_60       ; loop until all done

bd62          LFFS_65
bd62 a5 67       LDA SGNFLG        ; get negative flag
bd64 30 01       BMI LFFS_70       ; if negative do - FAC1 and return
bd66 60          RTS ;Size  116 [Load_FAC1_From_String]

bd67          LFFS_70
bd67 4c b4 bf    JMP Basic_GREATER ; do - FAC1

bd6a          LFFS_75
bd6a 48          PHA               ; save character
bd6b 24 5f       BIT TMPPTC        ; test decimal point flag
bd6d 10 02       BPL LFFS_80       ; skip exponent increment if not set
bd6f e6 5d       INC TMPVA1        ; else increment number exponent

bd71          LFFS_80
bd71 20 e2 ba    JSR Multiply_FAC1_BY_10
bd74 68          PLA               ; restore character
bd75 38          SEC
bd76 e9 30       SBC #'0'          ; convert to binary
bd78 20 7e bd    JSR Add_A_To_FAC1
bd7b 4c 0a bd    JMP LFFS_15      ; go do next character

              ; *************
bd7e            Add_A_To_FAC1
              ; *************

bd7e 48          PHA               ; save digit
bd7f 20 0c bc    JSR FAC1_Round_And_Copy_To_FAC2
bd82 68          PLA               ; restore digit
bd83 20 3c bc    JSR A_To_FAC1
bd86 a5 6e       LDA FAC2SI        ; get FAC2 sign (b7)
bd88 45 66       EOR FAC1SI        ; toggle with FAC1 sign (b7)
bd8a 85 6f       STA STRPTR        ; save sign compare (FAC1 EOR FAC2)
bd8c a6 61       LDX FAC1EX        ; get FAC1 exponent
bd8e 4c 6a b8    JMP Basic_PLUS    ; add FAC2 to FAC1 and return

              ; evaluate next character of exponential part of number

bd91          LFFS_85
bd91 a5 5e       LDA TMPVA2        ; get exponent count byte
bd93 c9 0a       CMP #10           ; compare with 10 decimal
bd95 90 09       BCC LFFS_90       ; branch if less
bd97 a9 64       LDA #$64          ; make all negative exponents = -100 decimal (causes underflow)
bd99 24 60       BIT TMPPTC+1      ; test exponent negative flag
bd9b 30 11       BMI LFFS_95       ; branch if negative
bd9d 4c 7e b9    JMP Overflow_Error

bda0          LFFS_90
bda0 0a          ASL A             ; *2
bda1 0a          ASL A             ; *4
bda2 18          CLC
bda3 65 5e       ADC TMPVA2        ; *5
bda5 0a          ASL A             ; *10
bda6 18          CLC
bda7 a0 00       LDY #0
bda9 71 7a       ADC (TXTPTR),Y    ; add character (will be $30 too much!)
bdab 38          SEC
bdac e9 30       SBC #'0'          ; convert character to binary

bdae          LFFS_95
bdae 85 5e       STA TMPVA2        ; save exponent count byte
bdb0 4c 30 bd    JMP LFFS_35       ; go get next character

bdb3 9b 3e bc MAXREAL_A .real   99999999.90625
bdb8 9e 6e 6b MAXREAL_B .real  999999999.25
bdbd 9e 6e 6b MAXREAL_C .real 1000000000

              ; ********
bdc2            Print_IN
              ; ********

                 LAYI(Msg_IN)
bdc2 a9 71       LDA #<Msg_IN
bdc4 a0 a3       LDY #>Msg_IN

bdc6 20 da bd    JSR To_Print_String
bdc9 a5 3a       LDA CURLIN+1      ; get the current line number high byte
bdcb a6 39       LDX CURLIN        ; get the current line number low byte

              ; ****************
bdcd            Print_Integer_XA
              ; ****************

bdcd 85 62       STA FAC1M1        ; save high byte as FAC1 mantissa1
bdcf 86 63       STX FAC1M2        ; save low byte as FAC1 mantissa2
bdd1 a2 90       LDX #$90          ; set exponent to 16d bits
bdd3 38          SEC               ; set integer is positive flag
bdd4 20 49 bc    JSR Convert_Integer_To_Float
bdd7 20 df bd    JSR Format_FAC1_Y

bdda          To_Print_String
bdda 4c 1e ab    JMP Print_String

              ; ***********
bddd            Format_FAC1
              ; ***********

bddd a0 01       LDY #1
              ; -------------
bddf            Format_FAC1_Y
              ; -------------

bddf a9 20       LDA #' '          ; character = " " (assume positive)
bde1 24 66       BIT FAC1SI        ; test FAC1 sign (b7)
bde3 10 02       BPL FoFA_02       ; if positive skip the - sign set
bde5 a9 2d       LDA #'-'          ; else character = "-"

bde7          FoFA_02
bde7 99 ff 00    STA BASSTO,Y      ; save leading character (" " or "-")
bdea 85 66       STA FAC1SI        ; save FAC1 sign (b7)
bdec 84 71       STY TMPPTD        ; save the index
bdee c8          INY
bdef a9 30       LDA #'0'          ; set character = "0"
bdf1 a6 61       LDX FAC1EX        ; get FAC1 exponent
bdf3 d0 03       BNE FoFA_04       ; if FAC1 not zero format it
bdf5 4c 04 bf    JMP FoFA_52       ; just 0 

bdf8          FoFA_04
bdf8 a9 00       LDA #$00          ; clear (number exponent count)
bdfa e0 80       CPX #$80          ; compare FAC1 exponent with $80 (<1.00000)
bdfc f0 02       BEQ FoFA_06       ; branch if 0.5 <= FAC1 < 1.0
bdfe b0 09       BCS FoFA_08       ; branch if FAC1=>1

be00          FoFA_06
                 LAYI(MAXREAL_C)   ; set 1000000000 pointer
be00 a9 bd       LDA #<MAXREAL_C
be02 a0 bd       LDY #>MAXREAL_C

be04 20 28 ba    JSR Multiply_FAC1_With_AY
be07 a9 f7       LDA #$F7          ; set number exponent count

be09          FoFA_08
be09 85 5d       STA TMPVA1        ; save number exponent count

be0b          FoFA_10
                 LAYI(MAXREAL_B)   ; set 999999999.25 pointer (max before sci note)
be0b a9 b8       LDA #<MAXREAL_B
be0d a0 bd       LDY #>MAXREAL_B

be0f 20 5b bc    JSR Compare_FAC1_AY
be12 f0 1e       BEQ FoFA_20       ; exit if FAC1 = (AY)
be14 10 12       BPL FoFA_16       ; go do /10 if FAC1 > (AY)

be16          FoFA_12
                 LAYI(MAXREAL_A)   ; set 99999999.90625 pointer
be16 a9 b3       LDA #<MAXREAL_A
be18 a0 bd       LDY #>MAXREAL_A

be1a 20 5b bc    JSR Compare_FAC1_AY
be1d f0 02       BEQ FoFA_14       ; branch if FAC1 = (AY) (allow decimal places)
be1f 10 0e       BPL FoFA_18       ; branch if FAC1 > (AY) (no decimal places)

be21          FoFA_14
be21 20 e2 ba    JSR Multiply_FAC1_BY_10
be24 c6 5d       DEC TMPVA1        ; decrement number exponent count
be26 d0 ee       BNE FoFA_12       ; go test again, branch always

be28          FoFA_16
be28 20 fe ba    JSR Divide_FAC1_By_10
be2b e6 5d       INC TMPVA1        ; increment number exponent count
be2d d0 dc       BNE FoFA_10       ; go test again, branch always

be2f          FoFA_18
be2f 20 49 b8    JSR Add_0_5_To_FAC1

be32          FoFA_20
be32 20 9b bc    JSR FAC1_To_Integer
be35 a2 01       LDX #$01          ; set default digits before dp = 1
be37 a5 5d       LDA TMPVA1        ; get number exponent count
be39 18          CLC
be3a 69 0a       ADC #$0A          ; up to 9 digits before point
be3c 30 09       BMI FoFA_22       ; if negative then 1 digit before dp
be3e c9 0b       CMP #$0B          ; A>=$0B if n>=1E9
be40 b0 06       BCS FoFA_24       ; branch if >= $0B
be42 69 ff       ADC #$FF          ; take 1 from digit count
be44 aa          TAX               ; copy to X
be45 a9 02       LDA #$02          ; set the exponent adjust

be47          FoFA_22
be47 38          SEC

be48          FoFA_24
be48 e9 02       SBC #$02          ; -2
be4a 85 5e       STA TMPVA2        ; save the exponent adjust
be4c 86 5d       STX TMPVA1        ; save digits before dp count
be4e 8a          TXA               ; copy digits before dp count to A
be4f f0 02       BEQ FoFA_26       ; if no digits before the dp go do the "."
be51 10 13       BPL FoFA_30       ; if there are digits before the dp go do them

be53          FoFA_26
be53 a4 71       LDY TMPPTD        ; get the output string index
be55 a9 2e       LDA #'.'          ; character "."
be57 c8          INY               ; increment the index
be58 99 ff 00    STA STACK-1,Y     ; save the "." to the output string
be5b 8a          TXA               ; copy digits before dp count to A
be5c f0 06       BEQ FoFA_28       ; if no digits before the dp skip the "0"
be5e a9 30       LDA #'0'          ; character "0"
be60 c8          INY
be61 99 ff 00    STA STACK-1,Y     ; save the "0" to the output string

be64          FoFA_28
be64 84 71       STY TMPPTD        ; save the output string index

be66          FoFA_30
be66 a0 00       LDY #0            ; clear the powers of 10 index (point to -100,000,000)

              ; -----------------
be68            Format_Jiffyclock
              ; -----------------

be68 a2 80       LDX #$80          ; clear the digit, set the test sense
be6a          FoFA_32
be6a a5 65       LDA FAC1M4        ; get FAC1 mantissa 4
be6c 18          CLC
be6d 79 19 bf    ADC Decimal_Conversion_Table+3,Y
be70 85 65       STA FAC1M4        ; save FAC1 mantissa4
be72 a5 64       LDA FAC1M3        ; get FAC1 mantissa 3
be74 79 18 bf    ADC Decimal_Conversion_Table+2,Y
be77 85 64       STA FAC1M3        ; save FAC1 mantissa3
be79 a5 63       LDA FAC1M2        ; get FAC1 mantissa 2
be7b 79 17 bf    ADC Decimal_Conversion_Table+1,Y
be7e 85 63       STA FAC1M2        ; save FAC1 mantissa2
be80 a5 62       LDA FAC1M1        ; get FAC1 mantissa 1
be82 79 16 bf    ADC Decimal_Conversion_Table+0,Y
be85 85 62       STA FAC1M1        ; save FAC1 mantissa1
be87 e8          INX               ; increment the digit, set the sign on the test sense bit
be88 b0 04       BCS FoFA_34       ; if the carry is set go test if the result was positive
be8a 10 de       BPL FoFA_32       ; not negative so try again
be8c 30 02       BMI FoFA_36       ; else done so return the digit

be8e          FoFA_34
be8e 30 da       BMI FoFA_32       ; not positive so try again

be90          FoFA_36
be90 8a          TXA               ; copy the digit
be91 90 04       BCC FoFA_38       ; if Cb=0 just use it
be93 49 ff       EOR #$FF          ; else make the 2's complement ..
be95 69 0a       ADC #$0A          ; .. and subtract it from 10

be97          FoFA_38
be97 69 2f       ADC #'0'-1        ; add "0"-1 to result
be99 c8          INY               ; increment ..
be9a c8          INY               ; .. index to..
be9b c8          INY               ; .. next less ..
be9c c8          INY               ; .. power of ten
be9d 84 47       STY VARPNT        ; save the powers of ten table index
be9f a4 71       LDY TMPPTD        ; get output string index
bea1 c8          INY               ; increment output string index
bea2 aa          TAX               ; copy character to X
bea3 29 7f       AND #$7F          ; mask out top bit
bea5 99 ff 00    STA STACK-1,Y     ; save to output string
bea8 c6 5d       DEC TMPVA1        ; decrement # of characters before the dp
beaa d0 06       BNE FoFA_40       ; if still characters to do skip the decimal point
beac a9 2e       LDA #'.'          ; character "."
beae c8          INY               ; increment output string index
beaf 99 ff 00    STA STACK-1,Y     ; save to output string

beb2          FoFA_40
beb2 84 71       STY TMPPTD        ; save the output string index
beb4 a4 47       LDY VARPNT        ; get the powers of ten table index
beb6 8a          TXA               ; get the character back
beb7 49 ff       EOR #$FF          ; toggle the test sense bit
beb9 29 80       AND #$80          ; clear the digit
bebb aa          TAX               ; copy it to the new digit
bebc c0 24       CPY #Jiffy_Conversion_Table-Decimal_Conversion_Table         
bebe f0 04       BEQ FoFA_42       ; if at the max exit the digit loop
bec0 c0 3c       CPY #End_Of_Conversion-Decimal_Conversion_Table
bec2 d0 a6       BNE FoFA_32       ; loop if not at the max

bec4          FoFA_42
bec4 a4 71       LDY TMPPTD        ; restore the output string index
bec6          FoFA_44
bec6 b9 ff 00    LDA STACK-1,Y     ; get character from output string
bec9 88          DEY               ; decrement output string index
beca c9 30       CMP #'0'          ; compare with "0"
becc f0 f8       BEQ FoFA_44       ; loop until non "0" character found
bece c9 2e       CMP #'.'          ; compare with "."
bed0 f0 01       BEQ FoFA_46       ; branch if was dp
bed2 c8          INY               ; increment output string index

bed3          FoFA_46
bed3 a9 2b       LDA #'+'          ; character "+"
bed5 a6 5e       LDX TMPVA2        ; get exponent count
bed7 f0 2e       BEQ FoFA_54       ; if zero go set null terminator and exit
bed9 10 08       BPL FoFA_48       ; branch if exponent count positive
bedb a9 00       LDA #0
bedd 38          SEC
bede e5 5e       SBC TMPVA2        ; subtract exponent count adjust (convert negative to positive)
bee0 aa          TAX               ; copy exponent count to X
bee1 a9 2d       LDA #'-'          ; character "-"

bee3          FoFA_48
bee3 99 01 01    STA STACK+1,Y     ; save to output string
bee6 a9 45       LDA #'E'          ; character "E"
bee8 99 00 01    STA STACK,Y       ; save exponent sign to output string
beeb 8a          TXA               ; get exponent count back
beec a2 2f       LDX #$2F          ; one less than "0" character
beee 38          SEC

beef          FoFA_50
beef e8          INX               ; increment 10's character
bef0 e9 0a       SBC #$0A          ; subtract 10 from exponent count
bef2 b0 fb       BCS FoFA_50       ; loop while still >= 0
bef4 69 3a       ADC #':'          ; add character ":" ($30+$0A, result is 10 less that value)
bef6 99 03 01    STA STACK+3,Y     ; save to output string
bef9 8a          TXA               ; copy 10's character
befa 99 02 01    STA STACK+2,Y     ; save to output string
befd a9 00       LDA #$00          ; set null terminator
beff 99 04 01    STA STACK+4,Y     ; save to output string
bf02 f0 08       BEQ FoFA_56       ; go set string pointer (AY) and exit, branch always

bf04          FoFA_52
bf04 99 ff 00    STA STACK-1,Y     ; save last character to output string

bf07          FoFA_54
bf07 a9 00       LDA #$00          ; set null terminator
bf09 99 00 01    STA STACK,Y       ; save after last character

bf0c          FoFA_56
                 LAYI(STACK)
bf0c a9 00       LDA #<STACK
bf0e a0 01       LDY #>STACK

bf10 60          RTS ;Size  308 [Format_FAC1]

bf11 80 00    Float_0_5       .byte $80,$00 ; 0.5 (including next 3 bytes)
bf13 00 00 00 NULL_Descriptor .byte 0,0,0 ; null descriptor for undefined variables

              ; ========================
bf16            Decimal_Conversion_Table
              ; ========================

bf16 fa 0a 1f    .quad -100000000
bf1a 00 98 96    .quad  +10000000
bf1e ff f0 bd    .quad   -1000000
bf22 00 01 86    .quad    +100000
bf26 ff ff d8    .quad     -10000
bf2a 00 00 03    .quad      +1000
bf2e ff ff ff    .quad       -100
bf32 00 00 00    .quad        +10
bf36 ff ff ff    .quad         -1

              ; ======================
bf3a            Jiffy_Conversion_Table
              ; ======================

bf3a ff df 0a    .quad -2160000 ; 10s hours
bf3e 00 03 4b    .quad  +216000 ;     hours
bf42 ff ff 73    .quad   -36000 ; 10s mins
bf46 00 00 0e    .quad    +3600 ;     mins
bf4a ff ff fd    .quad     -600 ; 10s secs
bf4e 00 00 00    .quad      +60 ;     secs

bf52          End_Of_Conversion

0000 TRUE     #if C64
bf52 ec          .byte $EC
              #endif
0001 FALSE    #if VIC
SKIP             .byte $BF
              #endif

bf53 aa aa aa    .fill 30 ($AA) ; 30 bytes

              ; *********
bf71            Basic_SQR
              ; *********

bf71 20 0c bc    JSR FAC1_Round_And_Copy_To_FAC2
                 LAYI(Float_0_5)
bf74 a9 11       LDA #<Float_0_5
bf76 a0 bf       LDY #>Float_0_5

bf78 20 a2 bb    JSR Load_FAC1_AY

              ; ***********
bf7b            Basic_POWER
              ; ***********

bf7b f0 70       BEQ Basic_EXP     ; perform EXP()
bf7d a5 69       LDA FAC2EX        ; get FAC2 exponent
bf7f d0 03       BNE POW_10        ; branch if FAC2<>0
bf81 4c f9 b8    JMP PLUS_40       ; clear FAC1 exponent and sign and return

bf84          POW_10
bf84 a2 4e       LDX #<FUNCPT      ; set destination pointer low byte
bf86 a0 00       LDY #>FUNCPT      ; set destination pointer high byte
bf88 20 d4 bb    JSR Assign_FAC1_To_Var
bf8b a5 6e       LDA FAC2SI        ; get FAC2 sign (b7)
bf8d 10 0f       BPL POW_20        ; branch if FAC2>0
bf8f 20 cc bc    JSR Basic_INT     ; perform INT()
                 LAYI(FUNCPT)      ; set source pointer
bf92 a9 4e       LDA #<FUNCPT
bf94 a0 00       LDY #>FUNCPT

bf96 20 5b bc    JSR Compare_FAC1_AY
bf99 d0 03       BNE POW_20        ; branch if FAC1 <> (AY) to allow Function Call error
bf9b 98          TYA               ; clear sign b7
bf9c a4 07       LDY CHARAC        ; get FAC1 mantissa 4 from INT() function as sign in
                                   ; Y for possible later negation, b0 only needed
bf9e          POW_20
bf9e 20 fe bb    JSR Copy_ABS_FAC2_To_FAC1
bfa1 98          TYA               ; copy sign back ..
bfa2 48          PHA               ; .. and save it
bfa3 20 ea b9    JSR Basic_LOG     ; perform LOG()
                 LAYI(FUNCPT)
bfa6 a9 4e       LDA #<FUNCPT
bfa8 a0 00       LDY #>FUNCPT

bfaa 20 28 ba    JSR Multiply_FAC1_With_AY
bfad 20 ed bf    JSR Basic_EXP     ; perform EXP()
bfb0 68          PLA               ; pull sign from stack
bfb1 4a          LSR A             ; b0 is to be tested
bfb2 90 0a       BCC GREA_Ret      ; if no bit then exit

              ; *************
bfb4            Basic_GREATER
              ; *************

bfb4 a5 61       LDA FAC1EX        ; get FAC1 exponent
bfb6 f0 06       BEQ GREA_Ret      ; exit if FAC1_e = $00
bfb8 a5 66       LDA FAC1SI        ; get FAC1 sign (b7)
bfba 49 ff       EOR #$FF          ; complement it
bfbc 85 66       STA FAC1SI        ; save FAC1 sign (b7)

bfbe          GREA_Ret
bfbe 60          RTS ;Size   11 [Basic_GREATER]

bfbf 81 38 aa REV_LOG_2 .real 1.4426950408

bfc4          VAR_EXP
bfc4 07          .byte   7         ; series count

bfc5 71 34 58    .real  2.1498763705E-5
bfca 74 16 7e    .real  1.4352314041E-4
bfcf 77 2f ee    .real  1.3422634825E-3
bfd4 7a 1d 84    .real  9.6140170140E-3
bfd9 7c 63 59    .real  5.5505126870E-2
bfde 7e 75 fd    .real  2.4022638465E-1
bfe3 80 31 72    .real  6.9314718640E-1
bfe8 81 00 00    .real  1.0

              ; *********
bfed            Basic_EXP
              ; *********

                 LAYI(REV_LOG_2)   ; point to 1.0/ln(2.0) = 1.443
bfed a9 bf       LDA #<REV_LOG_2
bfef a0 bf       LDY #>REV_LOG_2

bff1 20 28 ba    JSR Multiply_FAC1_With_AY
bff4 a5 70       LDA FAC1M5        ; get FAC1 rounding byte
bff6 69 50       ADC #$50          ; +$50/$100
bff8 90 03       BCC EXP_10        ; skip rounding if no carry
bffa 20 23 bc    JSR Round_FAC1

bffd          EXP_10

0000 TRUE     #if C64
bffd 4c 00 e0    JMP C64_Kernal_ROM
e000             .org  $E000
e000          C64_Kernal_ROM
              #endif

0000 TRUE     #if C64
                 .store  *,$2000,"kernal_64.rom"
              #endif
0001 FALSE    #if VIC
SKIP             .store  $e000,$2000,"kernal_20.rom"
              #endif

e000 85 56       STA FAC2M5        ; save FAC2 rounding byte
e002 20 0f bc    JSR FAC1_To_FAC2
e005 a5 61       LDA FAC1EX        ; get FAC1 exponent
e007 c9 88       CMP #$88          ; compare with EXP limit (256d)
e009 90 03       BCC EXP_30        ; branch if less

e00b          EXP_20
e00b 20 d4 ba    JSR Check_Overflow

e00e          EXP_30
e00e 20 cc bc    JSR Basic_INT     ; perform INT()
e011 a5 07       LDA CHARAC        ; get mantissa 4 from INT()
e013 18          CLC
e014 69 81       ADC #$81          ; normalise +1
e016 f0 f3       BEQ EXP_20        ; if $00 result has overflowed so go handle it
e018 38          SEC
e019 e9 01       SBC #$01          ; exponent now correct
e01b 48          PHA               ; save FAC2 exponent
e01c a2 05       LDX #$05          ; 4 bytes to do

e01e          EXP_40
e01e b5 69       LDA FAC2EX,X      ; get FAC2,X
e020 b4 61       LDY FAC1EX,X      ; get FAC1,X
e022 95 61       STA FAC1EX,X      ; save FAC1,X
e024 94 69       STY FAC2EX,X      ; save FAC2,X
e026 ca          DEX               ; decrement count/index
e027 10 f5       BPL EXP_40        ; loop if not all done
e029 a5 56       LDA FAC2M5        ; get FAC2 rounding byte
e02b 85 70       STA FAC1M5        ; save as FAC1 rounding byte
e02d 20 53 b8    JSR Basic_MINUS   ; perform subtraction, FAC2 from FAC1
e030 20 b4 bf    JSR Basic_GREATER ; do - FAC1
                 LAYI(VAR_EXP)     ; set counter pointer
e033 a9 c4       LDA #<VAR_EXP
e035 a0 bf       LDY #>VAR_EXP

e037 20 59 e0    JSR Eval_Series_AY
e03a a9 00       LDA #0
e03c 85 6f       STA STRPTR        ; clear sign compare (FAC1 EOR FAC2)
e03e 68          PLA               ; pull the saved FAC2 exponent
e03f 20 b9 ba    JSR Check_FACs_A
e042 60          RTS ;Size 8278 [Basic_EXP]

              ; **********************
e043            Square_And_Series_Eval
              ; **********************

                 STAY(TMPPTD)
e043 85 71       STA TMPPTD
e045 84 72       STY TMPPTD+1

e047 20 ca bb    JSR FAC1_To_FACTPA
e04a a9 57       LDA #<FACTPA      ; set pointer low byte (Y already $00)
e04c 20 28 ba    JSR Multiply_FAC1_With_AY
e04f 20 5d e0    JSR Eval_Series
                 LAYI(FACTPA)      ; pointer to original
e052 a9 57       LDA #<FACTPA
e054 a0 00       LDY #>FACTPA

e056 4c 28 ba    JMP Multiply_FAC1_With_AY

              ; **************
e059            Eval_Series_AY
              ; **************

                 STAY(TMPPTD)
e059 85 71       STA TMPPTD
e05b 84 72       STY TMPPTD+1


              ; -----------
e05d            Eval_Series
              ; -----------

e05d 20 c7 bb    JSR FAC1_To_FACTPB
e060 b1 71       LDA (TMPPTD),Y    ; get constants count
e062 85 67       STA SGNFLG        ; save constants count
e064 a4 71       LDY TMPPTD        ; get count pointer low byte
e066 c8          INY               ; increment it (now constants pointer)
e067 98          TYA               ; copy it
e068 d0 02       BNE EvSe_10       ; skip next if no overflow
e06a e6 72       INC TMPPTD+1      ; else increment high byte

e06c          EvSe_10
e06c 85 71       STA TMPPTD        ; save low byte
e06e a4 72       LDY TMPPTD+1      ; get high byte

e070          EvSe_20
e070 20 28 ba    JSR Multiply_FAC1_With_AY
                 LDAY(TMPPTD)
e073 a5 71       LDA TMPPTD
e075 a4 72       LDY TMPPTD+1

e077 18          CLC
e078 69 05       ADC #$05          ; +5 to low pointer (5 bytes per constant)
e07a 90 01       BCC EvSe_30       ; skip next if no overflow
e07c c8          INY               ; increment high byte

e07d          EvSe_30
                 STAY(TMPPTD)
e07d 85 71       STA TMPPTD
e07f 84 72       STY TMPPTD+1

e081 20 67 b8    JSR Add_Var_AY_To_FAC1
                 LAYI(FACTPB)      ; set pointer to partial
e084 a9 5c       LDA #<FACTPB
e086 a0 00       LDY #>FACTPB

e088 c6 67       DEC SGNFLG        ; decrement constants count
e08a d0 e4       BNE EvSe_20       ; loop until all done
e08c 60          RTS ;Size   52 [Eval_Series_AY]

e08d 98 35 44 RND_VA .real 11879546 
e092 68 28 b1 RND_VB .real 3.927677739E-8

              ; *********
e097            Basic_RND
              ; *********

e097 20 2b bc    JSR Get_FAC1_Sign
e09a 30 37       BMI RND_20        ; if      n<0 copy byte swapped FAC1 into RND() seed
e09c d0 20       BNE RND_10        ; else if n>0 get next number in RND() sequence
e09e 20 ed ff    JSR IOBASE        ; else    n=0 so get the RND() from VIA 1 timers
                 STXY(INDEXA)      ; save pointer low byte
e0a1 86 22       STX INDEXA
e0a3 84 23       STY INDEXA+1

e0a5 a0 04       LDY #$04          ; set index to T1 low byte
e0a7 b1 22       LDA (INDEXA),Y    ; get T1 low byte
e0a9 85 62       STA FAC1M1        ; save FAC1 mantissa 1
e0ab c8          INY
e0ac b1 22       LDA (INDEXA),Y    ; get T1 high byte
e0ae 85 64       STA FAC1M3        ; save FAC1 mantissa 3
e0b0 a0 08       LDY #$08          ; set index to T2 low byte
e0b2 b1 22       LDA (INDEXA),Y    ; get T2 low byte
e0b4 85 63       STA FAC1M2        ; save FAC1 mantissa 2
e0b6 c8          INY
e0b7 b1 22       LDA (INDEXA),Y    ; get T2 high byte
e0b9 85 65       STA FAC1M4        ; save FAC1 mantissa 4
e0bb 4c e3 e0    JMP RND_30        ; set exponent and exit

e0be          RND_10
                 LAYI(RNDX)        ; set seed pointer
e0be a9 8b       LDA #<RNDX
e0c0 a0 00       LDY #>RNDX

e0c2 20 a2 bb    JSR Load_FAC1_AY
                 LAYI(RND_VA)      ; set 11879546 pointer
e0c5 a9 8d       LDA #<RND_VA
e0c7 a0 e0       LDY #>RND_VA

e0c9 20 28 ba    JSR Multiply_FAC1_With_AY
                 LAYI(RND_VB)      ; set 3.927677739E-8 pointer
e0cc a9 92       LDA #<RND_VB
e0ce a0 e0       LDY #>RND_VB

e0d0 20 67 b8    JSR Add_Var_AY_To_FAC1

e0d3          RND_20
e0d3 a6 65       LDX FAC1M4        ; get FAC1 mantissa 4
e0d5 a5 62       LDA FAC1M1        ; get FAC1 mantissa 1
e0d7 85 65       STA FAC1M4        ; save FAC1 mantissa 4
e0d9 86 62       STX FAC1M1        ; save FAC1 mantissa 1
e0db a6 63       LDX FAC1M2        ; get FAC1 mantissa 2
e0dd a5 64       LDA FAC1M3        ; get FAC1 mantissa 3
e0df 85 63       STA FAC1M2        ; save FAC1 mantissa 2
e0e1 86 64       STX FAC1M3        ; save FAC1 mantissa 3

e0e3          RND_30
e0e3 a9 00       LDA #0
e0e5 85 66       STA FAC1SI        ; clear FAC1 sign (always positive)
e0e7 a5 61       LDA FAC1EX        ; get FAC1 exponent
e0e9 85 70       STA FAC1M5        ; save FAC1 rounding byte
e0eb a9 80       LDA #$80          ; set exponent = $80
e0ed 85 61       STA FAC1EX        ; save FAC1 exponent
e0ef 20 d7 b8    JSR Normalise_FAC1
e0f2 a2 8b       LDX #<RNDX        ; set seed pointer low address
e0f4 a0 00       LDY #>RNDX        ; set seed pointer high address

              ; --------------------
e0f6            Go_Assign_FAC1_To_Var
              ; --------------------

e0f6 4c d4 bb    JMP Assign_FAC1_To_Var

              ; =============
e0f9            Error_Handler
              ; =============

e0f9 c9 f0       CMP #$F0          ; compare error with $F0
e0fb d0 07       BNE ErHa_10       ; branch if not $F0
e0fd 84 38       STY MEMSIZ+1      ; set end of memory high byte
e0ff 86 37       STX MEMSIZ        ; set end of memory low byte
e101 4c 63 a6    JMP Reset_Variable_Pointer

e104          ErHa_10
e104 aa          TAX               ; copy error #
e105 d0 02       BNE ErHa_20       ; branch if not $00
e107 a2 1e       LDX #$1E          ; else error $1E, break error

e109          ErHa_20
e109 4c 37 a4    JMP Basic_Error

              ; **************
e10c            CHROUT_Checked
              ; **************

e10c 20 cc ff    JSR CHROUT        ; Output a character
e10f b0 e8       BCS Error_Handler
e111 60          RTS ;Size    6 [CHROUT_Checked]

              ; *********
e112            Read_Char
              ; *********

e112 20 c9 ff    JSR CHRIN
e115 b0 e2       BCS Error_Handler
e117 60          RTS ;Size    6 [Read_Char]

              ; *********************
e118            Select_Output_Channel
              ; *********************

0000 TRUE     #if C64
e118 20 ad e4    JSR CHKOUT_Checked
              #endif

0001 FALSE    #if VIC
SKIP             JSR CHKOUT        ; open channel for output
              #endif

e11b b0 dc       BCS Error_Handler
e11d 60          RTS ;Size    6 [Select_Output_Channel]

              ; *************
e11e            CHKIN_Checked
              ; *************

e11e 20 c0 ff    JSR CHKIN         ; open channel for input
e121 b0 d6       BCS Error_Handler
e123 60          RTS ;Size    6 [CHKIN_Checked]

              ; *************
e124            GETIN_Checked
              ; *************

e124 20 de ff    JSR GETIN         ; get character from input device
e127 b0 d0       BCS Error_Handler
e129 60          RTS ;Size    6 [GETIN_Checked]

              ; *********
e12a            Basic_SYS
              ; *********

e12a 20 8a ad    JSR Eval_Numeric
e12d 20 f7 b7    JSR FAC1_To_LINNUM
e130 a9 e1       LDA #>[SYS_Ret-1] ; get return address high byte
e132 48          PHA               ; push as return address
e133 a9 46       LDA #<[SYS_Ret-1] ; get return address low byte
e135 48          PHA               ; push as return address
e136 ad 0f 03    LDA SPREG         ; get saved status register
e139 48          PHA               ; put on stack
e13a ad 0c 03    LDA SAREG         ; get saved A
e13d ae 0d 03    LDX SXREG         ; get saved X
e140 ac 0e 03    LDY SYREG         ; get saved Y
e143 28          PLP               ; pull processor status
e144 6c 14 00    JMP (LINNUM)      ; call SYS address

              ; -------
e147            SYS_Ret
              ; -------

              ; the SYS_Ret is needed because the following code is to be executed once the user code
              ; returns. this is done by pushing the target return address - 1 onto the stack

e147 08          PHP               ; save status
e148 8d 0c 03    STA SAREG         ; save returned A
e14b 8e 0d 03    STX SXREG         ; save returned X
e14e 8c 0e 03    STY SYREG         ; save returned Y
e151 68          PLA               ; restore saved status
e152 8d 0f 03    STA SPREG         ; save status
e155 60          RTS ;Size   44 [Basic_SYS]

              ; **********
e156            Basic_SAVE
              ; **********

e156 20 d4 e1    JSR Get_Load_Save_Params

e159          Jiffy_SAVE
                 LDXY(VARTAB)      ; get start of variables
e159 a6 2d       LDX VARTAB
e15b a4 2e       LDY VARTAB+1

e15d a9 2b       LDA #TXTTAB       ; index to start of program memory
e15f 20 d2 ff    JSR SAVE          ; save RAM to device, A = index to start address, XY = end
e162 b0 95       BCS Error_Handler
e164 60          RTS ;Size   15 [Basic_SAVE]

              ; ************
e165            Basic_VERIFY
              ; ************

e165 a9 01       LDA #1            ; flag verify
e167 2c          .byte   $2C       ; skip next statement

              ; **********
e168            Basic_LOAD
              ; **********

e168 a9 00       LDA #0            ; flag load
e16a 85 0a       STA VERCK         ; set load/verify flag
e16c 20 d4 e1    JSR Get_Load_Save_Params
e16f a5 0a       LDA VERCK         ; get load/verify flag
                 LDXY(TXTTAB)      ; get start of memory
e171 a6 2b       LDX TXTTAB
e173 a4 2c       LDY TXTTAB+1

e175 20 cf ff    JSR LOAD          ; load RAM from a device
e178 b0 57       BCS Jump_Error_Handler
e17a a5 0a       LDA VERCK         ; get load/verify flag
e17c f0 17       BEQ LOAD_30       ; branch if load

e17e          LOAD_05
e17e a2 1c       LDX #$1C          ; error $1C, verify error
e180 20 b1 ff    JSR READST        ; read I/O status word
e183 29 10       AND #$10          ; mask for tape read error

0000 TRUE     #if C64
e185 d0 17       BNE LOAD_40       ; branch if read error
              #endif
0001 FALSE    #if VIC
SKIP             BEQ LOAD_10       ; branch if no read error
SKIP             JMP Basic_Error
              #endif

e187          LOAD_10
e187 a5 7a       LDA TXTPTR        ; get BASIC execute pointer low byte
e189 c9 02       CMP #2            ; BUG! should be LDA TXTPTR+1:CMP #>BUF:BNE LOAD20
e18b f0 07       BEQ LOAD_20
                 LAYI(Msg_OK)
e18d a9 64       LDA #<Msg_OK
e18f a0 a3       LDY #>Msg_OK

e191 4c 1e ab    JMP Print_String

e194          LOAD_20
e194 60          RTS ;Size   45 [Basic_LOAD]

e195          LOAD_30
e195 20 b1 ff    JSR READST        ; read I/O status word
e198 29 bf       AND #$BF          ; mask x0xx xxxx, clear read error
e19a f0 05       BEQ LOAD_50       ; branch if no errors
e19c a2 1d       LDX #$1D          ; error $1D, load error

e19e          LOAD_40
e19e 4c 37 a4    JMP Basic_Error

e1a1          LOAD_50
e1a1 a5 7b       LDA TXTPTR+1      ; get BASIC execute pointer high byte
e1a3 c9 02       CMP #>BUF
e1a5 d0 0e       BNE LOAD_60       ; branch if not direct mode

e1a7          LOAD_55
                 STXY(VARTAB)
e1a7 86 2d       STX VARTAB
e1a9 84 2e       STY VARTAB+1

                 Print_Msg(Msg_Ready)
e1ab a9 76       LDA #<Msg_Ready
e1ad a0 a3       LDY #>Msg_Ready
e1af 20 1e ab    JSR Print_String

e1b2 4c 2a a5    JMP Reset_And_Rechain

e1b5          LOAD_60
e1b5 20 8e a6    JSR Reset_BASIC_Exec_Pointer

0000 TRUE     #if C64
e1b8 20 33 a5    JSR Rechain
e1bb 4c 77 a6    JMP Restore_And_Flush_Stack      ; do RESTORE, clear stack and return
              #endif
0001 FALSE    #if VIC
SKIP             JMP Rebuild_andRestore      ; rebuild BASIC line chaining, do RESTORE and return
              #endif

              ; **********
e1be            Basic_OPEN
              ; **********

e1be 20 19 e2    JSR Get_Open_Close_Params
e1c1 20 ba ff    JSR OPEN          ; open a logical file
e1c4 b0 0b       BCS Jump_Error_Handler      ; branch if error

e1c6 60          RTS ;Size    9 [Basic_OPEN]

              ; ***********
e1c7            Basic_CLOSE
              ; ***********

e1c7 20 19 e2    JSR Get_Open_Close_Params
e1ca a5 49       LDA FORPNT        ; get logical file number
e1cc 20 bd ff    JSR CLOSE         ; close a specified logical file
e1cf 90 c3       BCC LOAD_20      ; exit if no error

e1d1          Jump_Error_Handler
e1d1 4c f9 e0    JMP Error_Handler

              ; ********************
e1d4            Get_Load_Save_Params
              ; ********************

e1d4 a9 00       LDA #$00          ; clear file name length
e1d6 20 b7 ff    JSR SETNAM        ; clear filename
e1d9 a2 01       LDX #$01          ; set default device number, cassette
e1db a0 00       LDY #$00          ; set default command
0001 FALSE    #if JIFFY
SKIP             JSR Jiffy_SETLFS
              #else
e1dd 20 b4 ff    JSR SETLFS        ; set logical, first and second addresses
              #endif
e1e0 20 06 e2    JSR Exit_On_EOS
e1e3 20 57 e2    JSR Set_Filename
e1e6 20 06 e2    JSR Exit_On_EOS
e1e9 20 00 e2    JSR Get_Byte_Param
e1ec a0 00       LDY #$00          ; clear command
e1ee 86 49       STX FORPNT        ; save device number
e1f0 20 b4 ff    JSR SETLFS        ; set logical, first and second addresses
e1f3 20 06 e2    JSR Exit_On_EOS
e1f6 20 00 e2    JSR Get_Byte_Param
e1f9 8a          TXA               ; copy command to A
e1fa a8          TAY               ; copy command to Y
e1fb a6 49       LDX FORPNT        ; get device number back
e1fd 4c b4 ff    JMP SETLFS        ; set logical, first and second addresses and return

              ; **************
e200            Get_Byte_Param
              ; **************

e200 20 0e e2    JSR Read_Comma_And_Byte
e203 4c 9e b7    JMP Get_Byte_Value

              ; ***********
e206            Exit_On_EOS
              ; ***********

e206 20 79 00    JSR CHRGOT
e209 d0 02       BNE EOE_Ret       ; branch if not [EOL] or ":"
e20b 68          PLA               ; dump return address low byte
e20c 68          PLA               ; dump return address high byte
e20d          EOE_Ret
e20d 60          RTS ;Size    8 [Exit_On_EOS]

              ; *******************
e20e            Read_Comma_And_Byte
              ; *******************

e20e 20 fd ae    JSR Need_Comma

              ; *********
e211            Need_Byte
              ; *********

e211 20 79 00    JSR CHRGOT
e214 d0 f7       BNE EOE_Ret      ; exit if following byte
e216 4c 08 af    JMP Syntax_Error

              ; *********************
e219            Get_Open_Close_Params
              ; *********************

e219 a9 00       LDA #$00          ; clear file name length
e21b 20 b7 ff    JSR SETNAM        ; clear filename
e21e 20 11 e2    JSR Need_Byte
e221 20 9e b7    JSR Get_Byte_Value
e224 86 49       STX FORPNT        ; save logical file number
e226 8a          TXA               ; copy logical file number to A
e227 a2 01       LDX #$01          ; set default device number, cassette

e229          GOCP_05
e229 a0 00       LDY #$00          ; set default command
e22b 20 b4 ff    JSR SETLFS        ; set logical, first and second addresses
e22e 20 06 e2    JSR Exit_On_EOS
e231 20 00 e2    JSR Get_Byte_Param
e234 86 4a       STX FORPNT+1      ; save device number
e236 a0 00       LDY #$00          ; clear command
e238 a5 49       LDA FORPNT        ; get logical file number
e23a e0 03       CPX #$03          ; compare device number with screen
e23c 90 01       BCC GOCP_10       ; branch if less than screen
e23e 88          DEY               ; else decrement command

e23f          GOCP_10
e23f 20 b4 ff    JSR SETLFS        ; set logical, first and second addresses
e242 20 06 e2    JSR Exit_On_EOS
e245 20 00 e2    JSR Get_Byte_Param
e248 8a          TXA               ; copy command to A
e249 a8          TAY               ; copy command to Y
e24a a6 4a       LDX FORPNT+1      ; get device number
e24c a5 49       LDA FORPNT        ; get logical file number
e24e 20 b4 ff    JSR SETLFS        ; set logical, first and second addresses
e251 20 06 e2    JSR Exit_On_EOS
e254 20 0e e2    JSR Read_Comma_And_Byte

              ; ************
e257            Set_Filename
              ; ************

e257 20 9e ad    JSR Eval_Expression

e25a          Set_Filename_From_String
e25a 20 a3 b6    JSR Eval_String
e25d a6 22       LDX INDEXA        ; get string pointer low byte
e25f a4 23       LDY INDEXA+1      ; get string pointer high byte
e261 4c b7 ff    JMP SETNAM        ; set filename and return

              ; *********
e264            Basic_COS
              ; *********

                 LAYI(PI_Half)    ; set pi/2 pointer
e264 a9 e0       LDA #<PI_Half
e266 a0 e2       LDY #>PI_Half

e268 20 67 b8    JSR Add_Var_AY_To_FAC1

              ; *********
e26b            Basic_SIN
              ; *********

e26b 20 0c bc    JSR FAC1_Round_And_Copy_To_FAC2
                 LAYI(Two_PI)
e26e a9 e5       LDA #<Two_PI
e270 a0 e2       LDY #>Two_PI

e272 a6 6e       LDX FAC2SI        ; get FAC2 sign (b7)
e274 20 07 bb    JSR Divide_FAC2_By_AY
e277 20 0c bc    JSR FAC1_Round_And_Copy_To_FAC2
e27a 20 cc bc    JSR Basic_INT
e27d a9 00       LDA #0
e27f 85 6f       STA STRPTR        ; clear sign compare (FAC1 EOR FAC2)
e281 20 53 b8    JSR Basic_MINUS   ; perform subtraction, FAC2 from FAC1
                 LAYI(Float_0_25)
e284 a9 ea       LDA #<Float_0_25
e286 a0 e2       LDY #>Float_0_25

e288 20 50 b8    JSR AY_Minus_FAC1
e28b a5 66       LDA FAC1SI        ; get FAC1 sign (b7)
e28d 48          PHA               ; save FAC1 sign
e28e 10 0d       BPL SIN_10        ; branch if positive
e290 20 49 b8    JSR Add_0_5_To_FAC1
e293 a5 66       LDA FAC1SI        ; get FAC1 sign (b7)
e295 30 09       BMI SIN_20        ; branch if negative
e297 a5 12       LDA TANSGN        ; get the comparison evaluation flag
e299 49 ff       EOR #$FF          ; toggle flag
e29b 85 12       STA TANSGN        ; save the comparison evaluation flag

e29d          SIN_10
e29d 20 b4 bf    JSR Basic_GREATER ; do - FAC1

e2a0          SIN_20
                 LAYI(Float_0_25)  ; set 0.25 pointer
e2a0 a9 ea       LDA #<Float_0_25
e2a2 a0 e2       LDY #>Float_0_25

e2a4 20 67 b8    JSR Add_Var_AY_To_FAC1
e2a7 68          PLA               ; restore FAC1 sign
e2a8 10 03       BPL SIN_30        ; branch if was positive
e2aa 20 b4 bf    JSR Basic_GREATER ; do - FAC1

e2ad          SIN_30
                 LAYI(VAR_SIN)     ; set pointer to counter
e2ad a9 ef       LDA #<VAR_SIN
e2af a0 e2       LDY #>VAR_SIN

e2b1 4c 43 e0    JMP Square_And_Series_Eval

              ; *********
e2b4            Basic_TAN
              ; *********

e2b4 20 ca bb    JSR FAC1_To_FACTPA
e2b7 a9 00       LDA #0
e2b9 85 12       STA TANSGN        ; clear the comparison evaluation flag
e2bb 20 6b e2    JSR Basic_SIN     ; perform SIN()
e2be a2 4e       LDX #<FUNCPT      ; set sin(n) pointer low byte
e2c0 a0 00       LDY #>FUNCPT      ; set sin(n) pointer high byte
e2c2 20 f6 e0    JSR Go_Assign_FAC1_To_Var
                 LAYI(FACTPA)      ; set n pointer
e2c5 a9 57       LDA #<FACTPA
e2c7 a0 00       LDY #>FACTPA

e2c9 20 a2 bb    JSR Load_FAC1_AY
e2cc a9 00       LDA #0
e2ce 85 66       STA FAC1SI        ; clear FAC1 sign (b7)
e2d0 a5 12       LDA TANSGN        ; get the comparison evaluation flag
e2d2 20 dc e2    JSR TAN_10
                 LAYI(FUNCPT)      ; set sin(n) pointer
e2d5 a9 4e       LDA #<FUNCPT
e2d7 a0 00       LDY #>FUNCPT

e2d9 4c 0f bb    JMP AY_Divided_By_FAC1

              ; ======
e2dc            TAN_10
              ; ======

e2dc 48          PHA               ; save comparison flag
e2dd 4c 9d e2    JMP SIN_10      ; add 0.25, ^2 then series evaluation

e2e0 81 49 0f PI_Half    .real 1.5707963271
e2e5 83 49 0f Two_PI     .real 6.283185307
e2ea 7f 00 00 Float_0_25 .real 0.25

e2ef          VAR_SIN
e2ef 05          .byte   $05       ; series counter
e2f0 84 e6 1a    .real -14.381390673
e2f5 86 28 07    .real  42.00779713
e2fa 87 99 68    .real -76.70417028
e2ff 87 23 35    .real  81.60522370
e304 86 a5 5d    .real -41.34170211
e309 83 49 0f    .real   6.283185308

              ; *********
e30e            Basic_ATN
              ; *********

e30e a5 66       LDA FAC1SI        ; get FAC1 sign (b7)
e310 48          PHA               ; save sign
e311 10 03       BPL ATN_10        ; branch if positive
e313 20 b4 bf    JSR Basic_GREATER ; else do - FAC1

e316          ATN_10
e316 a5 61       LDA FAC1EX        ; get FAC1 exponent
e318 48          PHA               ; push exponent
e319 c9 81       CMP #$81          ; compare with 1
e31b 90 07       BCC ATN_20        ; branch if FAC1 < 1
                 LAYI(REAL_1)
e31d a9 bc       LDA #<REAL_1
e31f a0 b9       LDY #>REAL_1

e321 20 0f bb    JSR AY_Divided_By_FAC1

e324          ATN_20
                 LAYI(VAR_ATN)     ; pointer to series
e324 a9 3e       LDA #<VAR_ATN
e326 a0 e3       LDY #>VAR_ATN

e328 20 43 e0    JSR Square_And_Series_Eval
e32b 68          PLA               ; restore old FAC1 exponent
e32c c9 81       CMP #$81          ; compare with 1
e32e 90 07       BCC ATN_30        ; branch if FAC1 < 1
                 LAYI(PI_Half)     ; pointer to (pi/2)
e330 a9 e0       LDA #<PI_Half
e332 a0 e2       LDY #>PI_Half

e334 20 50 b8    JSR AY_Minus_FAC1

e337          ATN_30
e337 68          PLA               ; restore FAC1 sign
e338 10 03       BPL ATN_Ret       ; exit if was positive
e33a 4c b4 bf    JMP Basic_GREATER ; else do - FAC1 and return

e33d          ATN_Ret
e33d 60          RTS ;Size   48 [Basic_ATN]

e33e          VAR_ATN
e33e 0b          .byte 11        ; series counter

e33f 76 b3 83    .real -6.8479391200E-4
e344 79 1e f4    .real  4.8509421570E-3
e349 7b 83 fc    .real -1.6111701850E-2
e34e 7c 0c 1f    .real  3.4209638050E-2
e353 7c de 53    .real -5.4279132770E-2
e358 7d 14 64    .real  7.2457196550E-2
e35d 7d b7 ea    .real -8.9802395400E-2
e362 7d 63 30    .real  1.1093241345E-1
e367 7e 92 44    .real -0.1428398077
e36c 7e 4c cc    .real  0.1999991205
e371 7f aa aa    .real -0.3333333157
e376 81 00 00    .real  1.0

0000 TRUE     #if C64
e37b          Basic_Warm_Start
e37b 20 c6 ff    JSR CLRCHN        ; Clear I/O channels
e37e a9 00       LDA #0
e380 85 13       STA IOPMPT        ; set current I/O channel, flag default
e382 20 7a a6    JSR Flush_BASIC_Stack
e385 58          CLI               ; enable interrupts
e386          Vectored_Basic_Ready
e386 a2 80       LDX #$80
e388 6c 00 03    JMP (IERROR)      ; normally next statement
e38b          Back_To_Prompt
e38b 8a          TXA
e38c 30 03       BMI Jump_READY
e38e 4c 3a a4    JMP Default_Error      ; print error message

e391          Jump_READY
e391 4c 74 a4    JMP Basic_Ready
              #endif

e394          Basic_Cold_Start 
0001 FALSE    #if JIFFY
SKIP             JSR Jiffy_Jump_Vectors
              #else
e394 20 53 e4    JSR Init_BASIC_Jump_Vectors
              #endif
e397 20 bf e3    JSR Init_BASIC_RAM_Vectors
e39a 20 22 e4    JSR Print_Startup_Message
e39d a2 fb       LDX #$FB          ; value for start stack
e39f 9a          TXS               ; set stack pointer
0000 TRUE     #if C64
e3a0 d0 e4       BNE Vectored_Basic_Ready        ; branch always
              #endif

0001 FALSE    #if VIC
SKIP             JMP Basic_Ready
              #endif

              ; **********
e3a2            CHRGET_ROM
              ; **********

e3a2 e6 7a       INC TXTPTR        ; increment BASIC execute pointer low byte
e3a4 d0 02       BNE CHRO_10       ; branch if no carry
e3a6 e6 7b       INC TXTPTR+1      ; increment BASIC execute pointer high byte

e3a8          CHRO_10
e3a8 ad 60 ea    LDA $EA60         ; get byte to scan, address set by call routine
e3ab c9 3a       CMP #':'          ; compare with ":"
e3ad b0 0a       BCS CHRO_Ret      ; exit if>=
e3af c9 20       CMP #' '          ; compare with " "
e3b1 f0 ef       BEQ CHRGET_ROM    ; if " " go do next
e3b3 38          SEC               ; set carry for SBC
e3b4 e9 30       SBC #'0'          ; subtract "0"
e3b6 38          SEC               ; set carry for SBC
e3b7 e9 d0       SBC #$D0          ; subtract -"0"
                                   ; clear carry if byte = "0"-"9"
e3b9          CHRO_Ret
e3b9 60          RTS ;Size   24 [CHRGET_ROM]

e3ba 80 4f c7    .byte   $80,$4F,$C7,$52,$58 ; 0.811635157

              ; **********************
e3bf            Init_BASIC_RAM_Vectors
              ; **********************

e3bf a9 4c       LDA #$4C          ; opcode for JMP
e3c1 85 54       STA JUMPER        ; save for functions vector jump
e3c3 8d 10 03    STA Basic_USR
                 LAYI(Illegal_Quantity)
e3c6 a9 48       LDA #<Illegal_Quantity
e3c8 a0 b2       LDY #>Illegal_Quantity

                 STAY(USRVEC)
e3ca 8d 11 03    STA USRVEC
e3cd 8c 12 03    STY USRVEC+1

                 LAYI(Integer_To_Float)
e3d0 a9 91       LDA #<Integer_To_Float
e3d2 a0 b3       LDY #>Integer_To_Float

                 STAY(ADRAY2)      ; save fixed to float vector low byte
e3d4 85 05       STA ADRAY2
e3d6 84 06       STY ADRAY2+1

                 LAYI(Float_To_Integer)    ; set float to fixed vector
e3d8 a9 aa       LDA #<Float_To_Integer
e3da a0 b1       LDY #>Float_To_Integer

                 STAY(ADRAY1)       ; save float to fixed vector low byte
e3dc 85 03       STA ADRAY1
e3de 84 04       STY ADRAY1+1

e3e0 a2 1c       LDX #$1C          ; set byte count

e3e2          IBRV_10
e3e2 bd a2 e3    LDA CHRGET_ROM,X  ; get byte from table
e3e5 95 73       STA CHRGET,X      ; save byte in page zero
e3e7 ca          DEX               ; decrement count
e3e8 10 f8       BPL IBRV_10       ; loop if not all done
e3ea a9 03       LDA #$03          ; set step size, collecting descriptors
e3ec 85 53       STA GARBSS        ; save garbage collection step size
e3ee a9 00       LDA #0
e3f0 85 68       STA FAC1OV        ; clear FAC1 overflow byte
e3f2 85 13       STA IOPMPT        ; clear current I/O channel, flag default
e3f4 85 18       STA LASTPT+1      ; clear current descriptor stack item pointer high byte
e3f6 a2 01       LDX #$01          ; set X
e3f8 8e fd 01    STX BUF-3         ; set chain link pointer low byte
e3fb 8e fc 01    STX BUF-4         ; set chain link pointer high byte
e3fe a2 19       LDX #TEMPST       ; initial value for descriptor stack
e400 86 16       STX TEMPPT        ; set descriptor stack pointer
e402 38          SEC               ; set Cb = 1 to read the bottom of memory
e403 20 96 ff    JSR MEMBOT        ; read/set the bottom of memory
                 STXY(TXTTAB)      ; save start of memory
e406 86 2b       STX TXTTAB
e408 84 2c       STY TXTTAB+1

e40a 38          SEC               ; set Cb = 1 to read the top of memory
e40b 20 93 ff    JSR MEMTOP        ; read/set the top of memory
                 STXY(MEMSIZ)      ; save end of memory
e40e 86 37       STX MEMSIZ
e410 84 38       STY MEMSIZ+1

                 STXY(FRESPC)      ; set bottom of string space
e412 86 33       STX FRESPC
e414 84 34       STY FRESPC+1

e416 a0 00       LDY #0
e418 98          TYA               ; clear A
e419 91 2b       STA (TXTTAB),Y    ; clear first byte of memory
e41b e6 2b       INC TXTTAB        ; increment start of memory low byte
e41d d0 02       BNE IBRV_Ret      ; branch if no rollover
e41f e6 2c       INC TXTTAB+1      ; increment start of memory high byte

e421          IBRV_Ret
e421 60          RTS ;Size   99 [Init_BASIC_RAM_Vectors]

              ; *********************
e422            Print_Startup_Message
              ; *********************

                 LDAY(TXTTAB)      ; get start of memory
e422 a5 2b       LDA TXTTAB
e424 a4 2c       LDY TXTTAB+1

e426 20 08 a4    JSR Check_Mem_Avail
                 Print_Msg(Start_Message)
e429 a9 73       LDA #<Start_Message
e42b a0 e4       LDY #>Start_Message
e42d 20 1e ab    JSR Print_String

e430 a5 37       LDA MEMSIZ        ; get end of memory low byte
e432 38          SEC
e433 e5 2b       SBC TXTTAB        ; subtract start of memory low byte
e435 aa          TAX               ; copy result to X
e436 a5 38       LDA MEMSIZ+1      ; get end of memory high byte
e438 e5 2c       SBC TXTTAB+1      ; subtract start of memory high byte
e43a 20 cd bd    JSR Print_Integer_XA
                 Print_Msg(Bytes_Free_Message)
e43d a9 60       LDA #<Bytes_Free_Message
e43f a0 e4       LDY #>Bytes_Free_Message
e441 20 1e ab    JSR Print_String

e444 4c 44 a6    JMP Perform_NEW

0001 FALSE    #if VIC
SKIP          Bytes_Free_Message
SKIP             .byte   " BYTES FREE",$0D,$00
SKIP          
SKIP          Start_Message
0001 FALSE    #if JIFFY
SKIP             .byte   $93," JIFFYDOS (C)1989 CMD ",$0D,$00
              #else
SKIP             .byte   $93,"**** CBM BASIC V2 ****",$0D,$00
              #endif
              #endif

              ; BASIC vectors, these are copied to RAM from IERROR   onwards

e447          Basic_Vectors

0000 TRUE     #if C64
0001 FALSE    #if JIFFY
SKIP             .word   Jiffy_Dispatch     ; error message            IERROR  
              #else
e447 8b e3       .word   Back_To_Prompt     ; error message            IERROR  
              #endif
              #endif

0001 FALSE    #if VIC
0001 FALSE    #if JIFFY
SKIP             .word   Jiffy_Dispatch     ; error message            IERROR  
              #else
SKIP             .word   Default_Error      ; error message            IERROR  
              #endif
              #endif

e449 83 a4       .word   Default_Warmstart  ; BASIC warm start         IMAIN
0001 FALSE    #if JIFFY
SKIP             .word   Jiffy_Tokenize     ; crunch BASIC tokens      ICRNCH
              #else
e44b 7c a5       .word   Default_Tokenize   ; crunch BASIC tokens      ICRNCH
              #endif
e44d 1a a7       .word   Default_Detokenize ; uncrunch BASIC tokens    IQPLOP
e44f e4 a7       .word   Default_Start      ; start new BASIC code     IGONE
e451 86 ae       .word   Default_EVAL       ; get arithmetic element   IEVAL

              ; ***********************
e453            Init_BASIC_Jump_Vectors
              ; ***********************

e453 a2 0b       LDX #$0B          ; set byte count

e455          IBJV_10
e455 bd 47 e4    LDA Basic_Vectors,X
e458 9d 00 03    STA IERROR,X      ; save byte to RAM
e45b ca          DEX               ; decrement index
e45c 10 f7       BPL IBJV_10       ; loop if more to do
e45e 60          RTS ;Size   12 [Init_BASIC_Jump_Vectors]

0000 TRUE     #if C64

e45f 00          .BYTE 0

e460          Bytes_Free_Message
e460 20 42 41    .BYTE " BASIC BYTES FREE\r",0

e473          Start_Message
e473 93          .BYTE $93
0001 FALSE    #if JIFFY
SKIP             .BYTE "\r       JIFFYDOS V6.01 (C)1989 CMD  \r"
SKIP             .BYTE "\r C-64 BASIC V2   ",0
              #else
e474 0d 20 20    .BYTE "\r    **** COMMODORE 64 BASIC V2 ****\r"
e499 0d 20 36    .BYTE "\r 64K RAM SYSTEM  ",0
              #endif
e4ac 81          .BYTE $81

              ; **************
e4ad            CHKOUT_Checked
              ; **************

e4ad 48          PHA
e4ae 20 c3 ff    JSR CHKOUT
e4b1 aa          TAX
e4b2 68          PLA
e4b3 90 01       BCC CHCh_Ret
e4b5 8a          TXA

e4b6          CHCh_Ret
e4b6 60          RTS ;Size   10 [CHKOUT_Checked]

              #endif

0001 FALSE    #if VIC
SKIP          ; ****************
SKIP            Basic_Warm_Start
SKIP          ; ****************
SKIP          
SKIP             JSR CLRCHN        ; Clear I/O channels
SKIP             LDA #0
SKIP             STA IOPMPT        ; set current I/O channel, flag default
SKIP             JSR Flush_BASIC_Stack
SKIP             CLI               ; enable interrupts
SKIP             JMP Basic_Ready
SKIP          
SKIP          ; checksum byte, not referenced
SKIP          
0000 TRUE     #if PAL
SKIP             .byte   $e8       ; [PAL]
              #else
SKIP             .byte   $41       ; [NTSC]
              #endif
SKIP          
SKIP          ; rebuild BASIC line chaining and do RESTORE
SKIP          
SKIP          Rebuild_andRestore
SKIP             JSR Rechain
SKIP             JMP Restore_And_Flush_Stack
              #endif

0000 TRUE     #if C64
0001 FALSE    #if JIFFY
SKIP          ; ******************
SKIP            Jiffy_Jump_Vectors
SKIP          ; ******************
SKIP          
SKIP             JSR Init_BASIC_Jump_Vectors
SKIP             LDA #<Jiffy_F1
SKIP             STA CMPO
SKIP             LDA #>Jiffy_F1
SKIP             STA CMPO+1
SKIP          
SKIP          Jiffy_Inx_PRTY
SKIP             INX   
SKIP             STX PRTY
SKIP             RTS   
SKIP          
SKIP          ; ***********
SKIP            Jiffy_CHRIN 
SKIP          ; ***********
SKIP          
SKIP             LDA #$6f
SKIP             JSR Jiffy_CHKIN
SKIP             JSR CHRIN 
SKIP             CMP #'5' 
SKIP             RTS   
SKIP          
SKIP             TAX   
SKIP             TAX   
SKIP          
              #else
e4b7 aa aa aa    .fill 28 ($aa) ; 28 bytes
              #endif

e4d3          Je4d3
e4d3 85 a9       STA RINONE
e4d5 a9 01       LDA #1
e4d7 85 ab       STA RIPRTY
e4d9 60          RTS ;Size   45 [CHKOUT_Checked]

e4da          STA_COLOR
e4da ad 86 02    LDA COLOR
e4dd 91 f3       STA (USER),Y
e4df 60          RTS ;Size   51 [CHKOUT_Checked]

              ; *************
e4e0            Delay_2JiffyM
              ; *************

e4e0 69 02       ADC #2
e4e2          Be4e2
e4e2 a4 91       LDY STKEY
e4e4 c8          INY
e4e5 d0 04       BNE Be4eb
e4e7 c5 a1       CMP JIFFYM
e4e9 d0 f7       BNE Be4e2
e4eb          Be4eb
e4eb 60          RTS ;Size   12 [Delay_2JiffyM]

              ; ********
e4ec            BaudNTSC
              ; ********

e4ec 19 26       .WORD $2619       ;       9753
e4ee 44 19       .WORD $1944       ;       6468
e4f0 1a 11       .WORD $111a       ;       4378
e4f2 e8 0d       .WORD $0de8       ;       3560
e4f4 70 0c       .WORD $0c70       ;       3184
e4f6 06 06       .WORD $0606       ;       1542
e4f8 d1 02       .WORD $02d1       ;        721
e4fa 37 01       .WORD $0137       ;        311
e4fc ae 00       .WORD $00ae       ;        174
e4fe 69 00       .WORD $0069       ;        105

              #endif

0001 FALSE    #if VIC
0001 FALSE    #if JIFFY
SKIP          ; ******************
SKIP            Jiffy_Jump_Vectors
SKIP          ; ******************
SKIP          
SKIP             JSR Init_BASIC_Jump_Vectors
SKIP             LDA #<Jiffy_F1
SKIP             STA CMPO
SKIP             LDA #>Jiffy_F1
SKIP             STA CMPO+1
SKIP          
SKIP          Jiffy_Inx_PRTY
SKIP             INX   
SKIP             STX PRTY
SKIP             RTS   
SKIP          
SKIP          ; ***********
SKIP            Jiffy_CHRIN 
SKIP          ; ***********
SKIP          
SKIP             LDA #$6f
SKIP             JSR Jiffy_CHKIN
SKIP             JSR CHRIN 
SKIP             CMP #'5' 
SKIP             RTS   
SKIP          
SKIP            Jiffy_e496
SKIP          
SKIP             PLA
SKIP             PLA
SKIP             PLA
SKIP             PLA
SKIP             PLA
SKIP             RTS
SKIP          
SKIP            CIA2_PRA
SKIP            VIC_SPR_ENA
SKIP            VIC_CONTROL_1
SKIP            VIC_RASTER
SKIP             .fill 4 (-1)
              #else
SKIP             .fill 36 (-1)
              #endif
SKIP          
SKIP          ; set serial data out high
SKIP          
SKIP          ; ***********
SKIP            CLR_IEC_DAT        ; set serial data high (clear bit)
SKIP          ; ***********
SKIP          
SKIP             LDA IEC_PCR
SKIP             AND #~IEC_DAT_BIT
SKIP             STA IEC_PCR
SKIP             RTS
SKIP          
SKIP          ; set serial data out low
SKIP          
SKIP          SET_IEC_DAT
SKIP             LDA IEC_PCR       ; get VIA 2 PCR
SKIP             ORA #$20          ; set CB2 high, serial data out low
SKIP             STA IEC_PCR       ; set VIA 2 PCR
SKIP             RTS
SKIP          
SKIP          ; ***********
SKIP            GET_IEC_CLK        ; get serial clock status
SKIP          ; ***********
SKIP          
SKIP             LDA IEC_DRAN      ; get VIA 1 DRA, no handshake
SKIP             CMP IEC_DRAN      ; compare with self
SKIP             BNE GET_IEC_CLK   ; loop if changing
SKIP             LSR A             ; shift serial clock to Cb
SKIP             RTS
SKIP          
SKIP          ; **********************
SKIP            Get_SA_Print_Searching
SKIP          ; **********************
SKIP          
SKIP             LDX SA
SKIP             JMP Print_Searching
SKIP          
SKIP          ; ****************
SKIP            Set_Load_Address
SKIP          ; ****************
SKIP          
SKIP             TXA               ; copy secondary address
SKIP             BNE SLA_10        ; load location not set in LOAD call, so
SKIP             LDA MEMUSS        ; get load address low byte
SKIP             STA EAL           ; save program start address low byte
SKIP             LDA MEMUSS+1      ; get load address high byte
SKIP             STA EAL+1         ; save program start address high byte
SKIP          
SKIP          SLA_10
SKIP             JMP Display_LOADING_Or_VERIFYING
SKIP          
SKIP          ; ***********
SKIP            Close_Patch
SKIP          ; ***********
SKIP          
0001 FALSE    #if JIFFY
SKIP          ; *****************
SKIP            Jiffy_Test_Device
SKIP          ; *****************
SKIP          
SKIP             STX FA
SKIP          
SKIP          ; *************
SKIP            Jiffy_Test_FA
SKIP          ; *************
SKIP          
SKIP             TYA
SKIP             PHA
SKIP             JSR Jiffy_Open_Command_Channel    ; open 15,x,15
SKIP             JSR JiDi_60    ; set command channel (15) as output
SKIP             PHP
SKIP             JSR Jiffy_Close_15
SKIP             PLP
SKIP             PLA
SKIP             TAY
SKIP             LDX FA
SKIP             RTS
SKIP          
SKIP          ; **********
SKIP            Jiffy_STOP
SKIP          ; **********
SKIP          
SKIP             TXA
SKIP             PHA
SKIP             TSX
SKIP             LDA STACK+7,X
SKIP             CMP #$f6
SKIP             BNE JTD_09
SKIP             LDA STACK+6,X
SKIP             CMP #$35
SKIP             BEQ JTD_11
SKIP             CMP #$2f
SKIP             BEQ JTD_11
SKIP          
SKIP          JTD_09
SKIP             PLA
SKIP             TAX
SKIP             JMP (ISTOP)
SKIP          
SKIP          JTD_11
SKIP             JMP Jiffy_e496
SKIP          
              #else
SKIP             JSR Init_Tape_Write
SKIP             BCC ClPa_10       ; branch if no error
SKIP             PLA               ; else dump stacked exit code
SKIP             LDA #$00          ; clear exit code
SKIP          
SKIP          ClPa_10
SKIP             JMP KeCL_50      ; go do I/O close
SKIP          
SKIP             .FILL 38 (-1)     ; spare bytes, not referenced
              #endif
              #endif

              ; *************
e500            Kernal_IOBASE      ; return base address of I/O devices
              ; *************

e500 a2 00       LDX #<IO_Base_Address
e502 a0 dc       LDY #>IO_Base_Address
e504 60          RTS ;Size    5 [Kernal_IOBASE]

              ; *************
e505            Kernal_SCREEN      ; Return screen format
              ; *************

e505 a2 28       LDX #COLS
e507 a0 19       LDY #ROWS
e509 60          RTS ;Size    5 [Kernal_SCREEN]

              ; ***********
e50a            Kernal_PLOT        ; read (C=1) or set (C=0) X,Y cursor position
              ; ***********

e50a b0 07       BCS PLOT_10       ; if read cursor skip the set cursor

e50c          PLOT_05
e50c 86 d6       STX TBLX          ; save cursor row
e50e 84 d3       STY CSRIDX        ; save cursor column
e510 20 6c e5    JSR Adjust_Line   ; set screen pointers for cursor row, column

e513          PLOT_10
e513 a6 d6       LDX TBLX          ; get cursor row
e515 a4 d3       LDY CSRIDX        ; get cursor column
e517 60          RTS ;Size   14 [Kernal_PLOT]

              ; *******************
e518            Initialise_Hardware
              ; *******************

e518 20 a0 e5    JSR Set_Default_Devices
0001 FALSE    #if VIC
SKIP             LDA SCNMPG        ; get screen memory page
SKIP             AND #$FD          ; mask xxxx xx0x, all but va9
SKIP             ASL A             ; << 1 xxxx x0x0
SKIP             ASL A             ; << 2 xxxx 0x00
SKIP             ORA #$80          ; set  1xxx 0x00
SKIP             STA VIC_R5        ; set screen and character memory location
SKIP             LDA SCNMPG        ; get screen memory page
SKIP             AND #$02          ; mask bit 9
SKIP             BEQ InHa_10       ; if zero just go normalise screen
SKIP             LDA #$80          ; set b7
SKIP             ORA VIC_R2        ; OR in as video address 9
SKIP             STA VIC_R2        ; save new va9
              #endif

e51b          InHa_10
e51b a9 00       LDA #0
e51d 8d 91 02    STA MODE          ; clear shift mode switch
e520 85 cf       STA BLNON         ; clear cursor blink phase
e522 a9 48       LDA #<Keyboard_Decoder
e524 8d 8f 02    STA KEYLOG
e527 a9 eb       LDA #>Keyboard_Decoder
e529 8d 90 02    STA KEYLOG+1
e52c a9 0a       LDA #$0A          ; 10d
e52e 8d 89 02    STA KBMAXL        ; set maximum size of keyboard buffer
e531 8d 8c 02    STA KRPTDL        ; set repeat delay counter
e534 a9 0e       LDA #Default_Color
e536 8d 86 02    STA COLOR         ; set current colour code
e539 a9 04       LDA #$04          ; speed 4
e53b 8d 8b 02    STA KRPTSP        ; set repeat speed counter
e53e a9 0c       LDA #$0C          ; cursor flash timing
e540 85 cd       STA BLNCT         ; set cursor timing countdown
e542 85 cc       STA BLNSW         ; set cursor enable, $00 = flash cursor

              ; ************
e544            Clear_Screen
              ; ************

e544 ad 88 02    LDA SCNMPG        ; get screen memory page
e547 09 80       ORA #$80          ; set high bit, flag every line is logical line start
e549 a8          TAY               ; copy to Y
e54a a9 00       LDA #$00          ; clear line start low byte
e54c aa          TAX               ; clear index

e54d          ClSc_10
e54d 94 d9       STY SLLTBL,X      ; save start of line X pointer high byte
e54f 18          CLC
e550 69 28       ADC #COLS         ; add line length to low byte
e552 90 01       BCC ClSc_20       ; if no rollover skip the high byte increment
e554 c8          INY               ; else increment high byte

e555          ClSc_20
e555 e8          INX               ; increment line index
e556 e0 1a       CPX #ROWS+1       ; compare with number of lines + 1
e558 d0 f3       BNE ClSc_10       ; loop if not all done
e55a a9 ff       LDA #$FF          ; end of table marker ??
e55c 95 d9       STA SLLTBL,X      ; mark end of table
e55e a2 18       LDX #ROWS-1       ; set line count

e560          ClSc_30
e560 20 ff e9    JSR Clear_Screen_Row_X
e563 ca          DEX               ; decrement count
e564 10 fa       BPL ClSc_30       ; loop if more to do

              ; *******
e566            Do_Home
              ; *******

e566 a0 00       LDY #0
e568 84 d3       STY CSRIDX        ; clear cursor column
e56a 84 d6       STY TBLX          ; clear cursor row

e56c          Adjust_Line
e56c a6 d6       LDX TBLX          ; get cursor row
e56e a5 d3       LDA CSRIDX        ; get cursor column

e570          Home_10
e570 b4 d9       LDY SLLTBL,X      ; get start of line X pointer high byte
e572 30 08       BMI Home_20       ; continue if logical line start
e574 18          CLC               ; else clear carry for add
e575 69 28       ADC #COLS         ; add one line length
e577 85 d3       STA CSRIDX        ; save cursor column
e579 ca          DEX               ; decrement cursor row
e57a 10 f4       BPL Home_10       ; loop, branch always

e57c          Home_20
0000 TRUE     #if C64
e57c 20 f0 e9    JSR Start_Of_Line
              #endif
0001 FALSE    #if VIC
SKIP             LDA SLLTBL,X      ; get start of line X pointer high byte
SKIP             AND #$03          ; mask 0000 00xx, line memory page
SKIP             ORA SCNMPG        ; OR with screen memory page
SKIP             STA LINPTR+1      ; set current screen line pointer high byte
SKIP             LDA Line_Adress_Low,X    ; get start of line low byte from ROM table
SKIP             STA LINPTR        ; set current screen line pointer low byte
              #endif
e57f a9 27       LDA #COLS-1       ; set line length
e581 e8          INX               ; increment cursor row

e582          Home_30
e582 b4 d9       LDY SLLTBL,X      ; get start of line X pointer high byte
e584 30 06       BMI Home_40       ; exit if logical line start
e586 18          CLC               ; else clear carry for add
e587 69 28       ADC #COLS         ; add one line length to current line length
e589 e8          INX               ; increment cursor row
e58a 10 f6       BPL Home_30       ; loop, branch always

e58c          Home_40
e58c 85 d5       STA LINLEN        ; save current screen line length
0001 FALSE    #if VIC
SKIP             RTS
              #endif

0000 TRUE     #if C64
e58e 4c 24 ea    JMP Set_COLRAM_Pointer

e591          Home_50
e591 e4 c9       CPX ICRROW
e593 f0 03       BEQ Home_Ret
e595 4c ed e6    JMP Set_Pointer_To_Start_Of_Logical_Row_X

e598          Home_Ret
e598 60          RTS ;Size   51 [Do_Home]

e599 ea          NOP
              #endif

e59a 20 a0 e5    JSR Set_Default_Devices
e59d 4c 66 e5    JMP Do_Home

              ; *******************
e5a0            Set_Default_Devices
              ; *******************

e5a0 a9 03       LDA #3            ; set screen
e5a2 85 9a       STA DFLTO         ; set output device number
e5a4 a9 00       LDA #0            ; set keyboard
e5a6 85 99       STA DFLTN         ; set input device number

              ; *************
e5a8            Init_VIC_Chip
              ; *************

e5a8 a2 2f       LDX #VIC_REGS

e5aa          IVC_Loop
e5aa bd b8 ec    LDA VIC_INIT-1,X  ; get byte from setup table
e5ad 9d ff cf    STA VIC_BASE-1,X  ; save byte to Vic chip
e5b0 ca          DEX               ; decrement count/index
e5b1 d0 f7       BNE IVC_Loop      ; loop if more to do
e5b3 60          RTS ;Size   12 [Init_VIC_Chip]

              ; *****************************
e5b4            Get_Char_From_Keyboard_Buffer
              ; *****************************

e5b4 ac 77 02    LDY KBUFFR        ; get current character from buffer
e5b7 a2 00       LDX #0

e5b9          GCFK_Loop
e5b9 bd 78 02    LDA KBUFFR+1,X    ; get next character,X from buffer
e5bc 9d 77 02    STA KBUFFR,X      ; save as current character,X in buffer
e5bf e8          INX               ; increment index
e5c0 e4 c6       CPX NDX           ; compare with keyboard buffer index
e5c2 d0 f5       BNE GCFK_Loop     ; loop if more to do
e5c4 c6 c6       DEC NDX           ; decrement keyboard buffer index
e5c6 98          TYA               ; copy key to A
e5c7 58          CLI               ; enable interrupts
e5c8 18          CLC               ; flag got byte
e5c9 60          RTS ;Size   22 [Get_Char_From_Keyboard_Buffer]

              ; ===================
e5ca            Display_And_Get_Key
              ; ===================

e5ca 20 16 e7    JSR Screen_CHROUT ; output character

              ; =======
e5cd            Get_Key
              ; =======

e5cd a5 c6       LDA NDX           ; get keyboard buffer index
e5cf 85 cc       STA BLNSW         ; cursor enable, $00 = flash cursor, $xx = no flash
e5d1 8d 92 02    STA AUTODN        ; screen scrolling flag, $00 = scroll, $xx = no scroll
e5d4 f0 f7       BEQ Get_Key       ; loop if buffer empty
e5d6 78          SEI               ; disable interrupts
e5d7 a5 cf       LDA BLNON         ; get cursor blink phase
e5d9 f0 0c       BEQ GETK_10       ; branch if cursor phase
e5db a5 ce       LDA GDBLN         ; get character under cursor
e5dd ae 87 02    LDX CSRCLR        ; get colour under cursor
e5e0 a0 00       LDY #$00          ; clear Y
e5e2 84 cf       STY BLNON         ; clear cursor blink phase
e5e4 20 13 ea    JSR Display_Char_A_And_Color_X

e5e7          GETK_10
0001 FALSE    #if JIFFY
SKIP             JSR Jiffy_f9e5
              #else
e5e7 20 b4 e5    JSR Get_Char_From_Keyboard_Buffer
              #endif
e5ea c9 83       CMP #$83          ; compare with [SHIFT][RUN]
e5ec d0 10       BNE GETK_30       ; branch if not [SHIFT][RUN]
e5ee a2 09       LDX #9            ; set byte count
e5f0 78          SEI               ; disable interrupts
e5f1 86 c6       STX NDX           ; set keyboard buffer index

e5f3          GETK_20
e5f3 bd e6 ec    LDA RUNKEY-1,X    ; get byte from auto load/run table
e5f6 9d 76 02    STA KBUFFR-1,X    ; save to keyboard buffer
e5f9 ca          DEX               ; decrement count/index
e5fa d0 f7       BNE GETK_20       ; loop while more to do
e5fc f0 cf       BEQ Get_Key       ; loop for next key, branch always

e5fe          GETK_30
e5fe c9 0d       CMP #CR
e600 d0 c8       BNE Display_And_Get_Key
e602 a4 d5       LDY LINLEN        ; get current screen line length
e604 84 d0       STY INSRC         ; input from keyboard or screen, $xx = screen,

e606          GETK_40
e606 b1 d1       LDA (LINPTR),Y    ; get character from current screen line
e608 c9 20       CMP #' '          ; compare with [SPACE]
e60a d0 03       BNE GETK_50       ; branch if not [SPACE]
e60c 88          DEY               ; else eliminate the space, decrement end of input line
e60d d0 f7       BNE GETK_40       ; loop, branch always

e60f          GETK_50
e60f c8          INY               ; increment past last non space character on line
e610 84 c8       STY INDX          ; save input [EOL] pointer
e612 a0 00       LDY #0
e614 8c 92 02    STY AUTODN        ; clear screen scrolling flag, $00 = scroll, $xx = no scroll
e617 84 d3       STY CSRIDX        ; clear cursor column
e619 84 d4       STY CSRMOD        ; clear cursor quote flag, $xx = quote, $00 = no quote
e61b a5 c9       LDA ICRROW        ; get input cursor row
e61d 30 1b       BMI Get_Screen
e61f a6 d6       LDX TBLX          ; get cursor row
0000 TRUE     #if C64
e621 20 91 e5    JSR Home_50
              #endif
0001 FALSE    #if VIC
SKIP             JSR Set_Pointer_To_Start_Of_Logical_Row_X
              #endif
e624 e4 c9       CPX ICRROW        ; compare with input cursor row
e626 d0 12       BNE Get_Screen
0001 FALSE    #if VIC
SKIP             BNE Get_Screen    ; obsolete
              #endif
e628 a5 ca       LDA ICRCOL        ; get input cursor column
e62a 85 d3       STA CSRIDX        ; save cursor column
e62c c5 c8       CMP INDX          ; compare with input [EOL] pointer
e62e 90 0a       BCC Get_Screen    ; branch if less, cursor is in line
e630 b0 2b       BCS GetS_20      ; else cursor is beyond the line end, branch always

              ; ========================
e632            CHRIN_Keyboard_Or_Screen
              ; ========================

e632 98          TYA               ; copy Y
e633 48          PHA               ; save Y
e634 8a          TXA               ; copy X
e635 48          PHA               ; save X
e636 a5 d0       LDA INSRC         ; input from keyboard or screen, $xx = screen,
e638 f0 93       BEQ Get_Key       ; if keyboard go wait for key

              ; ==========
e63a            Get_Screen
              ; ==========

e63a a4 d3       LDY CSRIDX        ; get cursor column
e63c b1 d1       LDA (LINPTR),Y    ; get character from the current screen line
0001 FALSE    #if VIC
SKIP             .fill 23 ($EA)    ; NOP's
              #endif
e63e 85 d7       STA LASTKY        ; save temporary last character
e640 29 3f       AND #$3F          ; mask key bits
e642 06 d7       ASL LASTKY        ; << temporary last character
e644 24 d7       BIT LASTKY        ; test it
e646 10 02       BPL GetS_05       ; branch if not [NO KEY]
e648 09 80       ORA #$80

e64a          GetS_05
e64a 90 04       BCC GetS_10
e64c a6 d4       LDX CSRMOD        ; get cursor quote flag, $xx = quote, $00 = no quote
e64e d0 04       BNE GetS_15       ; branch if in quote mode

e650          GetS_10
e650 70 02       BVS GetS_15
e652 09 40       ORA #$40

e654          GetS_15
e654 e6 d3       INC CSRIDX        ; increment cursor column
e656 20 84 e6    JSR If_Quote_Toggle_Flag
e659 c4 c8       CPY INDX          ; compare with input [EOL] pointer
e65b d0 17       BNE GetS_35       ; branch if not at line end

e65d          GetS_20
e65d a9 00       LDA #$00
e65f 85 d0       STA INSRC         ; clear input from keyboard or screen, $xx = screen,
e661 a9 0d       LDA #$0D          ; set character [CR]
e663 a6 99       LDX DFLTN         ; get input device number
e665 e0 03       CPX #$03          ; compare with screen
e667 f0 06       BEQ GetS_25       ; branch if screen
e669 a6 9a       LDX DFLTO         ; get output device number
e66b e0 03       CPX #$03          ; compare with screen
e66d f0 03       BEQ GetS_30       ; branch if screen

e66f          GetS_25
e66f 20 16 e7    JSR Screen_CHROUT ; output character

e672          GetS_30
e672 a9 0d       LDA #$0D          ; set character [CR]

e674          GetS_35
e674 85 d7       STA LASTKY        ; save character
e676 68          PLA               ; pull X
e677 aa          TAX               ; restore X
e678 68          PLA               ; pull Y
e679 a8          TAY               ; restore Y
e67a a5 d7       LDA LASTKY        ; restore character
e67c c9 de       CMP #$DE
e67e d0 02       BNE GetS_40
e680 a9 ff       LDA #$FF

e682          GetS_40
e682 18          CLC
e683 60          RTS ;Size  208 [Get_Char_From_Keyboard_Buffer]

              ; ********************
e684            If_Quote_Toggle_Flag
              ; ********************

e684 c9 22       CMP #QUOTE
e686 d0 08       BNE IQTF_Ret      ; exit if not "
e688 a5 d4       LDA CSRMOD        ; get cursor quote flag, $xx = quote, $00 = no quote
e68a 49 01       EOR #1            ; toggle it
e68c 85 d4       STA CSRMOD        ; save cursor quote flag
e68e a9 22       LDA #QUOTE

e690          IQTF_Ret
e690 60          RTS ;Size   13 [If_Quote_Toggle_Flag]

              ; ===========
e691            Insert_Char
              ; ===========

e691 09 40       ORA #$40          ; change to uppercase/graphic

e693          InsC_10
e693 a6 c7       LDX RVS           ; get reverse flag
e695 f0 02       BEQ InsC_30       ; branch if not reverse

e697          InsC_20
e697 09 80       ORA #$80          ; reverse character

e699          InsC_30
e699 a6 d8       LDX INSRTO        ; get insert count
e69b f0 02       BEQ InsC_40       ; branch if none
e69d c6 d8       DEC INSRTO        ; else decrement insert count

e69f          InsC_40
e69f ae 86 02    LDX COLOR         ; get current colour code
e6a2 20 13 ea    JSR Display_Char_A_And_Color_X
e6a5 20 b6 e6    JSR Advance_Cursor

e6a8          InsC_50
e6a8 68          PLA               ; pull Y
e6a9 a8          TAY               ; restore Y
e6aa a5 d8       LDA INSRTO        ; get insert count
e6ac f0 02       BEQ InsC_60       ; skip quote flag clear if inserts to do
e6ae 46 d4       LSR CSRMOD        ; clear cursor quote flag, $xx = quote, $00 = no quote

e6b0          InsC_60
e6b0 68          PLA               ; pull X
e6b1 aa          TAX               ; restore X
e6b2 68          PLA               ; restore A
e6b3 18          CLC
e6b4 58          CLI               ; enable interrupts
e6b5 60          RTS ;Size   50 [If_Quote_Toggle_Flag]

              ; **************
e6b6            Advance_Cursor
              ; **************

e6b6 20 b3 e8    JSR Test_Line_Inc
e6b9 e6 d3       INC CSRIDX        ; increment cursor column
e6bb a5 d5       LDA LINLEN        ; get current screen line length
e6bd c5 d3       CMP CSRIDX        ; compare with cursor column
e6bf b0 3f       BCS SPTS_Ret      ; exit if line length >= cursor column
e6c1 c9 4f       CMP #COLMAX-1     ; compare with max length
e6c3 f0 32       BEQ SPTS_20       ; if at max clear column, back cursor up and do newline
e6c5 ad 92 02    LDA AUTODN        ; get autoscroll flag
e6c8 f0 03       BEQ AdCu_10       ; branch if autoscroll on
e6ca 4c 67 e9    JMP InsL_10      ; else open space on screen

e6cd          AdCu_10
e6cd a6 d6       LDX TBLX          ; get cursor row
e6cf e0 19       CPX #ROWS         ; compare with max + 1
e6d1 90 07       BCC Expand_Logical_Line
e6d3 20 ea e8    JSR Scroll_Screen
e6d6 c6 d6       DEC TBLX          ; decrement cursor row
e6d8 a6 d6       LDX TBLX          ; get cursor row

              ; *******************
e6da            Expand_Logical_Line
              ; *******************

e6da 16 d9       ASL SLLTBL,X      ; shift start of line X pointer high byte
e6dc 56 d9       LSR SLLTBL,X      ; clears bit 7
0000 TRUE     #if C64
e6de e8          INX               ; increment screen row
e6df b5 d9       LDA SLLTBL,X      ; get start of line X pointer high byte
e6e1 09 80       ORA #$80          ; mark as start of logical line
e6e3 95 d9       STA SLLTBL,X      ; set start of line X pointer high byte
e6e5 ca          DEX               ; restore screen row
e6e6 a5 d5       LDA LINLEN        ; get current screen line length
e6e8 18          CLC
              #endif
0001 FALSE    #if VIC
SKIP             JMP ELL_10        ; make next screen line start of logical line, increment
              #endif

              ; add one line length and set pointers for start of line

e6e9          ELL_20
e6e9 69 28       ADC #COLS         ; add one line length
e6eb 85 d5       STA LINLEN        ; save current screen line length

              ; *************************************
e6ed            Set_Pointer_To_Start_Of_Logical_Row_X
              ; *************************************

e6ed b5 d9       LDA SLLTBL,X      ; get start of line X pointer high byte
e6ef 30 03       BMI SPTS_10       ; exit loop if start of logical line
e6f1 ca          DEX               ; else back up one line
e6f2 d0 f9       BNE Set_Pointer_To_Start_Of_Logical_Row_X

e6f4          SPTS_10
e6f4 4c f0 e9    JMP Start_Of_Line

e6f7          SPTS_20
e6f7 c6 d6       DEC TBLX          ; decrement cursor row. if the cursor was incremented past
e6f9 20 7c e8    JSR Do_Newline
e6fc a9 00       LDA #0
e6fe 85 d3       STA CSRIDX        ; clear cursor column

e700          SPTS_Ret
e700 60          RTS ;Size   20 [Set_Pointer_To_Start_Of_Logical_Row_X]

              ; *************
e701            Previous_Line
              ; *************

e701 a6 d6       LDX TBLX          ; get cursor row
e703 d0 06       BNE PreL_10       ; branch if not top row
e705 86 d3       STX CSRIDX        ; clear cursor column
e707 68          PLA               ; dump return address low byte
e708 68          PLA               ; dump return address high byte
e709 d0 9d       BNE InsC_50       ; restore registers, set quote flag and exit, branch always

e70b          PreL_10
e70b ca          DEX               ; decrement cursor row
e70c 86 d6       STX TBLX          ; save cursor row
e70e 20 6c e5    JSR Adjust_Line   ; set screen pointers for cursor row, column
e711 a4 d5       LDY LINLEN        ; get current screen line length
e713 84 d3       STY CSRIDX        ; save as cursor column
e715 60          RTS ;Size   21 [Previous_Line]

              ; *************
e716            Screen_CHROUT
              ; *************

e716 48          PHA               ; save character
e717 85 d7       STA LASTKY        ; save temporary last character
e719 8a          TXA               ; copy X
e71a 48          PHA               ; save X
e71b 98          TYA               ; copy Y
e71c 48          PHA               ; save Y
e71d a9 00       LDA #0
e71f 85 d0       STA INSRC         ; clear input from keyboard or screen, $xx = screen,
e721 a4 d3       LDY CSRIDX        ; get cursor column
e723 a5 d7       LDA LASTKY        ; restore last character
e725 10 03       BPL ScrO_02       ; branch if unshifted
e727 4c d4 e7    JMP ScrO_42       ; do shifted characters and return

e72a          ScrO_02
e72a c9 0d       CMP #$0D          ; compare with [CR]
e72c d0 03       BNE ScrO_04       ; branch if not [CR]
e72e 4c 91 e8    JMP Screen_Return

e731          ScrO_04
e731 c9 20       CMP #' '          ; compare with [SPACE]
e733 90 10       BCC ScrO_10       ; branch if < [SPACE]
e735 c9 60       CMP #$60
e737 90 04       BCC ScrO_06       ; branch if $20 to $5F
e739 29 df       AND #$DF
e73b d0 02       BNE ScrO_08

e73d          ScrO_06
e73d 29 3f       AND #$3F

e73f          ScrO_08
e73f 20 84 e6    JSR If_Quote_Toggle_Flag
e742 4c 93 e6    JMP InsC_10

e745          ScrO_10
e745 a6 d8       LDX INSRTO        ; get insert count
e747 f0 03       BEQ ScrO_12       ; branch if no characters to insert
e749 4c 97 e6    JMP InsC_20       ; insert reversed character

e74c          ScrO_12
e74c c9 14       CMP #$14          ; compare with [INSERT]/[DELETE]
e74e d0 2e       BNE ScrO_20       ; branch if not [INSERT]/[DELETE]
e750 98          TYA
e751 d0 06       BNE ScrO_14
e753 20 01 e7    JSR Previous_Line
e756 4c 73 e7    JMP ScrO_18

e759          ScrO_14
e759 20 a1 e8    JSR Test_Line_Dec
e75c 88          DEY               ; decrement index to previous character
e75d 84 d3       STY CSRIDX        ; save cursor column
e75f 20 24 ea    JSR Set_COLRAM_Pointer

e762          ScrO_16
e762 c8          INY
e763 b1 d1       LDA (LINPTR),Y    ; get character from current screen line
e765 88          DEY               ; decrement index to previous character
e766 91 d1       STA (LINPTR),Y    ; save character to current screen line
e768 c8          INY
e769 b1 f3       LDA (USER),Y      ; get colour RAM byte
e76b 88          DEY               ; decrement index to previous character
e76c 91 f3       STA (USER),Y      ; save colour RAM byte
e76e c8          INY
e76f c4 d5       CPY LINLEN        ; compare with current screen line length
e771 d0 ef       BNE ScrO_16       ; loop if not there yet

e773          ScrO_18
e773 a9 20       LDA #' '          ; set [SPACE]
e775 91 d1       STA (LINPTR),Y    ; clear last character on current screen line
e777 ad 86 02    LDA COLOR         ; get current colour code
e77a 91 f3       STA (USER),Y      ; save to colour RAM
e77c 10 4d       BPL ScrO_38       ; branch always

e77e          ScrO_20
e77e a6 d4       LDX CSRMOD        ; get cursor quote flag, $xx = quote, $00 = no quote
e780 f0 03       BEQ ScrO_22       ; branch if not quote mode
e782 4c 97 e6    JMP InsC_20       ; insert reversed character

e785          ScrO_22
e785 c9 12       CMP #$12          ; compare with [RVS ON]
e787 d0 02       BNE ScrO_24       ; branch if not [RVS ON]
e789 85 c7       STA RVS           ; set reverse flag

e78b          ScrO_24
e78b c9 13       CMP #$13          ; compare with [CLR HOME]
e78d d0 03       BNE ScrO_26       ; branch if not [CLR HOME]
e78f 20 66 e5    JSR Do_Home

e792          ScrO_26
e792 c9 1d       CMP #$1D          ; compare with [CURSOR RIGHT]
e794 d0 17       BNE ScrO_32       ; branch if not [CURSOR RIGHT]
e796 c8          INY               ; increment cursor column
e797 20 b3 e8    JSR Test_Line_Inc
e79a 84 d3       STY CSRIDX        ; save cursor column
e79c 88          DEY               ; decrement cursor column
e79d c4 d5       CPY LINLEN        ; compare cursor column with current screen line length
e79f 90 09       BCC ScrO_30       ; exit if less
e7a1 c6 d6       DEC TBLX          ; decrement cursor row
e7a3 20 7c e8    JSR Do_Newline
e7a6 a0 00       LDY #$00          ; clear cursor column

e7a8          ScrO_28
e7a8 84 d3       STY CSRIDX        ; save cursor column

e7aa          ScrO_30
e7aa 4c a8 e6    JMP InsC_50       ; restore registers, set quote flag and exit

e7ad          ScrO_32
e7ad c9 11       CMP #$11          ; compare with [CURSOR DOWN]
e7af d0 1d       BNE ScrO_40       ; branch if not [CURSOR DOWN]
e7b1 18          CLC
e7b2 98          TYA               ; copy cursor column
e7b3 69 28       ADC #COLS         ; add one line
e7b5 a8          TAY               ; copy back to A
e7b6 e6 d6       INC TBLX          ; increment cursor row
e7b8 c5 d5       CMP LINLEN        ; compare cursor column with current screen line length
e7ba 90 ec       BCC ScrO_28       ; save cursor column and exit if less
e7bc f0 ea       BEQ ScrO_28       ; save cursor column and exit if equal
e7be c6 d6       DEC TBLX          ; decrement cursor row

e7c0          ScrO_34
e7c0 e9 28       SBC #COLS         ; subtract one line
e7c2 90 04       BCC ScrO_36       ; exit loop if on previous line
e7c4 85 d3       STA CSRIDX        ; else save cursor column
e7c6 d0 f8       BNE ScrO_34       ; loop if not at start of line

e7c8          ScrO_36
e7c8 20 7c e8    JSR Do_Newline

e7cb          ScrO_38
e7cb 4c a8 e6    JMP InsC_50       ; restore registers, set quote flag and exit

e7ce          ScrO_40
e7ce 20 cb e8    JSR Set_Color
e7d1 4c 44 ec    JMP Switch_Text_Graphics

e7d4          ScrO_42
0001 FALSE    #if VIC
SKIP             .fill 21 ($EA)    ; NOP's
              #endif
e7d4 29 7f       AND #$7F          ; mask 0xxx xxxx, clear b7
e7d6 c9 7f       CMP #$7F          ; was it $FF before the mask
e7d8 d0 02       BNE ScrO_44       ; branch if not
e7da a9 5e       LDA #$5E          ; else make it $5E
e7dc          ScrO_44
0001 FALSE    #if VIC
SKIP             NOP
SKIP             NOP
SKIP             NOP
SKIP             NOP
SKIP             NOP
SKIP             NOP
              #endif
e7dc c9 20       CMP #' '          ; compare with [SPACE]
e7de 90 03       BCC ScrO_46       ; branch if < [SPACE]
e7e0 4c 91 e6    JMP Insert_Char

e7e3          ScrO_46
e7e3 c9 0d       CMP #$0D          ; compare with [CR]
e7e5 d0 03       BNE ScrO_48       ; branch if not [CR]
e7e7 4c 91 e8    JMP Screen_Return      ; else output [CR] and return
                                   ; was not [CR]
e7ea          ScrO_48
e7ea a6 d4       LDX CSRMOD        ; get cursor quote flag, $xx = quote, $00 = no quote
e7ec d0 3f       BNE ScrO_60       ; branch if quote mode
e7ee c9 14       CMP #$14          ; compare with [INSERT DELETE]
e7f0 d0 37       BNE ScrO_58       ; branch if not [INSERT DELETE]
e7f2 a4 d5       LDY LINLEN        ; get current screen line length
e7f4 b1 d1       LDA (LINPTR),Y    ; get character from current screen line
e7f6 c9 20       CMP #' '          ; compare with [SPACE]
e7f8 d0 04       BNE ScrO_50       ; branch if not [SPACE]
e7fa c4 d3       CPY CSRIDX        ; compare current column with cursor column
e7fc d0 07       BNE ScrO_52       ; if not cursor column go open up space on line

e7fe          ScrO_50
e7fe c0 4f       CPY #COLMAX-1     ; compare current column with max line length
e800 f0 24       BEQ ScrO_56       ; exit if at line end
e802 20 65 e9    JSR Insert_Line

e805          ScrO_52
e805 a4 d5       LDY LINLEN        ; get current screen line length
e807 20 24 ea    JSR Set_COLRAM_Pointer

e80a          ScrO_54
e80a 88          DEY               ; decrement index to previous character
e80b b1 d1       LDA (LINPTR),Y    ; get character from current screen line
e80d c8          INY
e80e 91 d1       STA (LINPTR),Y    ; save character to current screen line
e810 88          DEY               ; decrement index to previous character
e811 b1 f3       LDA (USER),Y      ; get current screen line colour RAM byte
e813 c8          INY
e814 91 f3       STA (USER),Y      ; save current screen line colour RAM byte
e816 88          DEY               ; decrement index to previous character
e817 c4 d3       CPY CSRIDX        ; compare with cursor column
e819 d0 ef       BNE ScrO_54       ; loop if not there yet
e81b a9 20       LDA #' '          ; set [SPACE]
e81d 91 d1       STA (LINPTR),Y    ; clear character at cursor position on current screen line
e81f ad 86 02    LDA COLOR         ; get current colour code
e822 91 f3       STA (USER),Y      ; save to cursor position on current screen line colour RAM
e824 e6 d8       INC INSRTO        ; increment insert count

e826          ScrO_56
e826 4c a8 e6    JMP InsC_50       ; restore registers, set quote flag and exit

e829          ScrO_58
e829 a6 d8       LDX INSRTO        ; get insert count
e82b f0 05       BEQ ScrO_62       ; branch if no insert space

e82d          ScrO_60
e82d 09 40       ORA #$40          ; change to uppercase/graphic
e82f 4c 97 e6    JMP InsC_20       ; insert reversed character

e832          ScrO_62
e832 c9 11       CMP #$11          ; compare with [CURSOR UP]
e834 d0 16       BNE ScrO_66       ; branch if not [CURSOR UP]
e836 a6 d6       LDX TBLX          ; get cursor row
e838 f0 37       BEQ ScrO_74       ; branch if on top line
e83a c6 d6       DEC TBLX          ; decrement cursor row
e83c a5 d3       LDA CSRIDX        ; get cursor column
e83e 38          SEC
e83f e9 28       SBC #COLS         ; subtract one line length
e841 90 04       BCC ScrO_64       ; branch if stepped back to previous line
e843 85 d3       STA CSRIDX        ; else save cursor column ..
e845 10 2a       BPL ScrO_74       ; .. and exit, branch always

e847          ScrO_64
e847 20 6c e5    JSR Adjust_Line   ; set screen pointers for cursor row, column ..
e84a d0 25       BNE ScrO_74       ; .. and exit, branch always

e84c          ScrO_66
e84c c9 12       CMP #$12          ; compare with [RVS OFF]
e84e d0 04       BNE ScrO_68       ; branch if not [RVS OFF]
e850 a9 00       LDA #0
e852 85 c7       STA RVS           ; clear reverse flag

e854          ScrO_68
e854 c9 1d       CMP #$1D          ; compare with [CURSOR LEFT]
e856 d0 12       BNE ScrO_72       ; branch if not [CURSOR LEFT]
e858 98          TYA               ; copy cursor column
e859 f0 09       BEQ ScrO_70       ; branch if at start of line
e85b 20 a1 e8    JSR Test_Line_Dec
e85e 88          DEY               ; decrement cursor column
e85f 84 d3       STY CSRIDX        ; save cursor column
e861 4c a8 e6    JMP InsC_50       ; restore registers, set quote flag and exit

e864          ScrO_70
e864 20 01 e7    JSR Previous_Line
e867 4c a8 e6    JMP InsC_50       ; restore registers, set quote flag and exit

e86a          ScrO_72
e86a c9 13       CMP #$13          ; compare with [CLR]
e86c d0 06       BNE ScrO_76       ; branch if not [CLR]
e86e 20 44 e5    JSR Clear_Screen

e871          ScrO_74
e871 4c a8 e6    JMP InsC_50       ; restore registers, set quote flag and exit

e874          ScrO_76
e874 09 80       ORA #$80          ; restore b7, colour can only be black, cyan, magenta
e876 20 cb e8    JSR Set_Color
e879 4c 4f ec    JMP STG_10

              ; **********
e87c            Do_Newline
              ; **********

e87c 46 c9       LSR ICRROW        ; shift >> input cursor row
e87e a6 d6       LDX TBLX          ; get cursor row

e880          NewL_10
e880 e8          INX               ; increment row
e881 e0 19       CPX #ROWS         ; compare with last row + 1
e883 d0 03       BNE NewL_20       ; branch if not last row + 1
e885 20 ea e8    JSR Scroll_Screen

e888          NewL_20
e888 b5 d9       LDA SLLTBL,X      ; get start of line X pointer high byte
e88a 10 f4       BPL NewL_10       ; loop if not start of logical line
e88c 86 d6       STX TBLX          ; else save cursor row
e88e 4c 6c e5    JMP Adjust_Line   ; set screen pointers for cursor row, column and return

              ; =============
e891            Screen_Return
              ; =============

e891 a2 00       LDX #0
e893 86 d8       STX INSRTO        ; clear insert count
e895 86 c7       STX RVS           ; clear reverse flag
e897 86 d4       STX CSRMOD        ; clear cursor quote flag, $xx = quote, $00 = no quote
e899 86 d3       STX CSRIDX        ; clear cursor column
e89b 20 7c e8    JSR Do_Newline
e89e 4c a8 e6    JMP InsC_50      ; restore registers, set quote flag and exit

              ; *************
e8a1            Test_Line_Dec
              ; *************

e8a1 a2 02       LDX #COLINK       ; set count
e8a3 a9 00       LDA #$00          ; set column

e8a5          TLD_10
e8a5 c5 d3       CMP CSRIDX        ; compare with cursor column
e8a7 f0 07       BEQ TLD_20        ; branch if at start of line
e8a9 18          CLC               ; else clear carry for add
e8aa 69 28       ADC #COLS         ; increment to next line
e8ac ca          DEX               ; decrement loop count
e8ad d0 f6       BNE TLD_10        ; loop if more to test
e8af 60          RTS ;Size   15 [Test_Line_Dec]

e8b0          TLD_20
e8b0 c6 d6       DEC TBLX          ; else decrement cursor row
e8b2 60          RTS ;Size   18 [Test_Line_Dec]

              ; *************
e8b3            Test_Line_Inc
              ; *************

e8b3 a2 02       LDX #COLINK       ; set count
e8b5 a9 27       LDA #COLS-1       ; set column

e8b7          TLI_10
e8b7 c5 d3       CMP CSRIDX        ; compare with cursor column
e8b9 f0 07       BEQ TLI_20        ; if at end of line test and possibly increment cursor row
e8bb 18          CLC               ; else clear carry for add
e8bc 69 28       ADC #COLS         ; increment to next line
e8be ca          DEX               ; decrement loop count
e8bf d0 f6       BNE TLI_10        ; loop if more to test
e8c1 60          RTS ;Size   15 [Test_Line_Inc]

                                   ; cursor is at end of line
e8c2          TLI_20
e8c2 a6 d6       LDX TBLX          ; get cursor row
e8c4 e0 19       CPX #ROWS
e8c6 f0 02       BEQ TLI_30        ; exit if end of screen
e8c8 e6 d6       INC TBLX          ; else increment cursor row

e8ca          TLI_30
e8ca 60          RTS ;Size   24 [Test_Line_Inc]

              ; *********
e8cb            Set_Color
              ; *********

e8cb a2 0f       LDX #Color_Codes_End-Color_Codes-1

e8cd          SeCo_Loop
e8cd dd da e8    CMP Color_Codes,X ; compare the character with the table code
e8d0 f0 04       BEQ SeCo_10       ; if a match go save the colour and exit
e8d2 ca          DEX               ; else decrement the index
e8d3 10 f8       BPL SeCo_Loop     ; loop if more to do
e8d5 60          RTS ;Size   11 [Set_Color]

e8d6          SeCo_10
e8d6 8e 86 02    STX COLOR         ; set current colour code
e8d9 60          RTS ;Size   15 [Set_Color]

e8da          Color_Codes

e8da 90          .byte $90         ; black
e8db 05          .byte $05         ; white
e8dc 1c          .byte $1C         ; red
e8dd 9f          .byte $9F         ; cyan
e8de 9c          .byte $9C         ; magenta
e8df 1e          .byte $1E         ; green
e8e0 1f          .byte $1F         ; blue
e8e1 9e          .byte $9E         ; yellow

0000 TRUE     #if C64
e8e2 81          .byte $81         ; orange
e8e3 95          .byte $95         ; brown
e8e4 96          .byte $96         ; light red
e8e5 97          .byte $97         ; grey 1
e8e6 98          .byte $98         ; grey 2
e8e7 99          .byte $99         ; light green
e8e8 9a          .byte $9a         ; light blue
e8e9 9b          .byte $9b         ; grey 3
              #endif

e8ea          Color_Codes_End

              ; 76 bytes of unused VIC data

0001 FALSE    #if VIC
SKIP             .byte   $EF,$A1,$DF,$A6,$E1,$B1,$E2,$B2,$E3,$B3,$E4,$B4,$E5,$B5,$E6,$B6
SKIP             .byte   $E7,$B7,$E8,$B8,$E9,$B9,$FA,$BA,$FB,$BB,$FC,$BC,$EC,$BD,$FE,$BE
SKIP             .byte   $84,$BF,$F7,$C0,$F8,$DB,$F9,$DD,$EA,$DE,$5E,$E0,$5B,$E1,$5D,$E2
SKIP             .byte   $40,$B0,$61,$B1,$78,$DB,$79,$DD,$66,$B6,$77,$C0,$70,$F0,$71,$F1
SKIP             .byte   $72,$F2,$73,$F3,$74,$F4,$75,$F5,$76,$F6,$7D,$FD
              #endif

              ; *************
e8ea            Scroll_Screen
              ; *************

e8ea a5 ac       LDA SAL           ; save SAL & EAL
e8ec 48          PHA
e8ed a5 ad       LDA SAL+1
e8ef 48          PHA
e8f0 a5 ae       LDA EAL
e8f2 48          PHA
e8f3 a5 af       LDA EAL+1
e8f5 48          PHA

e8f6          ScSc_05
e8f6 a2 ff       LDX #-1           ; set for pre increment loop
e8f8 c6 d6       DEC TBLX          ; decrement cursor row
e8fa c6 c9       DEC ICRROW        ; decrement input cursor row
e8fc ce a5 02    DEC SCROWM        ; decrement screen row marker

e8ff          ScSc_10
e8ff e8          INX               ; increment line number
e900 20 f0 e9    JSR Start_Of_Line
e903 e0 18       CPX #ROWS-1       ; compare with last line
e905 b0 0c       BCS ScSc_15       ; branch if on last line
e907 bd f1 ec    LDA Line_Adress_Low+1,X
e90a 85 ac       STA SAL           ; save next line pointer low byte
e90c b5 da       LDA SLLTBL+1,X    ; get start of next line pointer high byte
e90e 20 c8 e9    JSR Shift_Row
e911 30 ec       BMI ScSc_10       ; loop, branch always

e913          ScSc_15
e913 20 ff e9    JSR Clear_Screen_Row_X
e916 a2 00       LDX #0

e918          ScSc_20
e918 b5 d9       LDA SLLTBL,X      ; get start of line X pointer high byte
e91a 29 7f       AND #$7F          ; clear line X start of logical line bit
e91c b4 da       LDY SLLTBL+1,X    ; get start of next line pointer high byte
e91e 10 02       BPL ScSc_25       ; branch if next line not start of line
e920 09 80       ORA #$80          ; set line X start of logical line bit

e922          ScSc_25
e922 95 d9       STA SLLTBL,X      ; set start of line X pointer high byte
e924 e8          INX               ; increment line number
e925 e0 18       CPX #ROWS-1       ; compare with last line
e927 d0 ef       BNE ScSc_20       ; loop if not last line
e929 a5 f1       LDA SLLTBL+ROWS-1 ; get start of last line pointer high byte
e92b 09 80       ORA #$80          ; mark as start of logical line
e92d 85 f1       STA SLLTBL+ROWS-1 ; set start of last line pointer high byte
e92f a5 d9       LDA SLLTBL        ; get start of first line pointer high byte
e931 10 c3       BPL ScSc_05       ; if not start of logical line loop back and
e933 e6 d6       INC TBLX          ; increment cursor row
e935 ee a5 02    INC SCROWM        ; increment screen row marker
e938          ScSc_27
0001 FALSE    #if JIFFY
0000 TRUE     #if C64
SKIP             JSR KeSc_70       ; scan standard column
SKIP             LDA KEYB_ROW      ; get VIA/CIA keyboard row
SKIP             CMP #CTRL_ROW     ; compare with row of [CTRL] key
              #endif
0001 FALSE    #if VIC
SKIP             PHP
SKIP             SEI
SKIP             JMP TASB_20
SKIP          
SKIP          Jiffy_e9c6
SKIP             PLP
SKIP             CPX #$fe
              #endif
              #else
e938 a9 7f       LDA #CTRL_COL     ; set keyboard column for [CTRL] key
e93a 8d 00 dc    STA KEYB_COL      ; set VIA/CIA keyboard column
e93d ad 01 dc    LDA KEYB_ROW      ; get VIA/CIA keyboard row
e940 c9 fb       CMP #CTRL_ROW     ; compare with row of [CTRL] key
              #endif
0001 FALSE    #if JIFFY
SKIP             BNE ScSc_40       ; no [CTRL]
SKIP             LDX NDX           ; chars in keyboard buffer
SKIP             BEQ ScSc_27       ; none
SKIP             LDA KBUFFR-1,X    ; last key
SKIP             SBC #$13          ; [CTRL] S
SKIP             BNE ScSc_40
SKIP             STA NDX           ; clear keyboard buffer
SKIP          
SKIP          ScSc_28
SKIP             CLI
SKIP             CMP NDX
SKIP             BEQ ScSc_28       ; wait until key pressed
SKIP             STA NDX
              #else
e942 08          PHP               ; save status
e943 a9 7f       LDA #STND_COL     ; set standard keyboard col
e945 8d 00 dc    STA KEYB_COL      ; set VIA/CIA keyboard column
e948 28          PLP               ; restore status
e949 d0 0b       BNE ScSc_40       ; skip if no [CTRL] key down
e94b a0 00       LDY #0            ; delay scrolling if [CTRL] key down

e94d          ScSc_30
e94d ea          NOP               ; waste cycles
e94e ca          DEX               ; decrement inner loop count
e94f d0 fc       BNE ScSc_30       ; loop if not all done
e951 88          DEY               ; decrement outer loop count
e952 d0 f9       BNE ScSc_30       ; loop if not all done
e954 84 c6       STY NDX           ; clear keyboard buffer index
              #endif

e956          ScSc_40
e956 a6 d6       LDX TBLX          ; get cursor row

e958          ScSc_45
e958 68          PLA               ; restore EAL & SAL
e959 85 af       STA EAL+1
e95b 68          PLA
e95c 85 ae       STA EAL
e95e 68          PLA
e95f 85 ad       STA SAL+1
e961 68          PLA
e962 85 ac       STA SAL
e964 60          RTS ;Size  123 [Scroll_Screen]

              ; ***********
e965            Insert_Line
              ; ***********

e965 a6 d6       LDX TBLX          ; get cursor row

e967          InsL_10
e967 e8          INX               ; increment row
e968 b5 d9       LDA SLLTBL,X      ; get start of line X pointer high byte
e96a 10 fb       BPL InsL_10       ; branch if not start of logical line
e96c 8e a5 02    STX SCROWM        ; set screen row marker
e96f e0 18       CPX #ROWS-1       ; compare with last line
e971 f0 0e       BEQ InsL_20       ; branch if = last line
e973 90 0c       BCC InsL_20       ; branch if < last line
e975 20 ea e8    JSR Scroll_Screen 
e978 ae a5 02    LDX SCROWM        ; get screen row marker
e97b ca          DEX               ; decrement screen row marker
e97c c6 d6       DEC TBLX          ; decrement cursor row
e97e 4c da e6    JMP Expand_Logical_Line

e981          InsL_20
e981 a5 ac       LDA SAL           ; copy tape buffer pointer
e983 48          PHA               ; save it
e984 a5 ad       LDA SAL+1         ; copy tape buffer pointer
e986 48          PHA               ; save it
e987 a5 ae       LDA EAL           ; copy tape buffer end pointer
e989 48          PHA               ; save it
e98a a5 af       LDA EAL+1         ; copy tape buffer end pointer
e98c 48          PHA               ; save it
e98d a2 19       LDX #ROWS         ; set to end line + 1 for predecrement loop

e98f          InsL_30
e98f ca          DEX               ; decrement line number
e990 20 f0 e9    JSR Start_Of_Line
e993 ec a5 02    CPX SCROWM        ; compare with screen row marker
e996 90 0e       BCC InsL_40       ; branch if < screen row marker
e998 f0 0c       BEQ InsL_40       ; branch if = screen row marker
e99a bd ef ec    LDA Line_Adress_Low-1,X  ; else get start of previous line low byte from ROM table
e99d 85 ac       STA SAL           ; save previous line pointer low byte
e99f b5 d8       LDA SLLTBL-1,X    ; get start of previous line pointer high byte
e9a1 20 c8 e9    JSR Shift_Row
e9a4 30 e9       BMI InsL_30       ; loop, branch always

e9a6          InsL_40
e9a6 20 ff e9    JSR Clear_Screen_Row_X
e9a9 a2 17       LDX #ROWS-2

e9ab          InsL_50
e9ab ec a5 02    CPX SCROWM        ;.compare with screen row marker
e9ae 90 0f       BCC InsL_70
e9b0 b5 da       LDA SLLTBL+1,X
e9b2 29 7f       AND #$7F
e9b4 b4 d9       LDY SLLTBL,X
e9b6 10 02       BPL InsL_60
e9b8 09 80       ORA #$80

e9ba          InsL_60
e9ba 95 da       STA SLLTBL+1,X
e9bc ca          DEX
e9bd d0 ec       BNE InsL_50

e9bf          InsL_70
e9bf ae a5 02    LDX SCROWM        ;.get screen row marker
e9c2 20 da e6    JSR Expand_Logical_Line

0000 TRUE     #if C64
e9c5 4c 58 e9    JMP ScSc_45
              #endif
0001 FALSE    #if VIC
SKIP             PLA               ; pull tape buffer end pointer
SKIP             STA EAL+1         ; restore it
SKIP             PLA               ; pull tape buffer end pointer
SKIP             STA EAL           ; restore it
SKIP             PLA               ; pull tape buffer pointer
SKIP             STA SAL+1         ; restore it
SKIP             PLA               ; pull tape buffer pointer
SKIP             STA SAL           ; restore it
SKIP             RTS
              #endif

              ; *********
e9c8            Shift_Row
              ; *********

e9c8 29 03       AND #$03          ; mask 0000 00xx, line memory page
e9ca 0d 88 02    ORA SCNMPG        ; OR with screen memory page
e9cd 85 ad       STA SAL+1         ; save next/previous line pointer high byte
e9cf 20 e0 e9    JSR Update_Color_RAM_Pointer

e9d2          ShRo_10
e9d2 a0 27       LDY #COLS-1       ; set column count

e9d4          ShRo_20
e9d4 b1 ac       LDA (SAL),Y       ; get character from next/previous screen line
e9d6 91 d1       STA (LINPTR),Y    ; save character to current screen line
e9d8 b1 ae       LDA (EAL),Y       ; get colour from next/previous screen line colour RAM
e9da 91 f3       STA (USER),Y      ; save colour to current screen line colour RAM
e9dc 88          DEY               ; decrement column index/count
e9dd 10 f5       BPL ShRo_20
e9df 60          RTS ;Size   24 [Shift_Row]

              ; ************************
e9e0            Update_Color_RAM_Pointer
              ; ************************

e9e0 20 24 ea    JSR Set_COLRAM_Pointer
e9e3 a5 ac       LDA SAL
e9e5 85 ae       STA EAL
e9e7 a5 ad       LDA SAL+1
e9e9 29 03       AND #$03
0000 TRUE     #if C64
e9eb 09 d8       ORA #$D8          ; C64 color RAM = $D800
              #endif
0001 FALSE    #if VIC
SKIP             ORA #$94          ; VIC color RAM = $9400
              #endif
e9ed 85 af       STA EAL+1
e9ef 60          RTS ;Size   16 [Update_Color_RAM_Pointer]

              ; *************
e9f0            Start_Of_Line
              ; *************

e9f0 bd f0 ec    LDA Line_Adress_Low,X
e9f3 85 d1       STA LINPTR        ; set current screen line pointer low byte
e9f5 b5 d9       LDA SLLTBL,X      ; get start of line high byte from RAM table
e9f7 29 03       AND #$03          ; mask 0000 00xx, line memory page
e9f9 0d 88 02    ORA SCNMPG        ; OR with screen memory page
e9fc 85 d2       STA LINPTR+1      ; set current screen line pointer high byte
e9fe 60          RTS ;Size   15 [Start_Of_Line]

              ; ******************
e9ff            Clear_Screen_Row_X
              ; ******************

e9ff a0 27       LDY #COLS-1       ; set number of columns to clear
ea01 20 f0 e9    JSR Start_Of_Line
ea04 20 24 ea    JSR Set_COLRAM_Pointer

ea07          CSRX_Loop
0000 TRUE     #if C64
ea07 20 da e4    JSR STA_COLOR
              #endif
ea0a a9 20       LDA #' '          ; set [SPACE]
ea0c 91 d1       STA (LINPTR),Y    ; clear character in current screen line
0001 FALSE    #if VIC
SKIP             LDA #1            ; set colour, blue on white
SKIP             STA (USER),Y      ; set colour RAM in current screen line
              #endif
ea0e 88          DEY
ea0f 10 f6       BPL CSRX_Loop
ea11 60          RTS ;Size   19 [Clear_Screen_Row_X]


0000 TRUE     #if C64
ea12 ea          NOP
              #endif

              ; **************************
ea13            Display_Char_A_And_Color_X
              ; **************************

ea13 a8          TAY               ; copy character
ea14 a9 02       LDA #$02          ; set count to $02, usually $14 ??
ea16 85 cd       STA BLNCT         ; set cursor countdown
ea18 20 24 ea    JSR Set_COLRAM_Pointer
ea1b 98          TYA               ; get character back

              ; **********************
ea1c            Display_Char_And_Color
              ; **********************

ea1c a4 d3       LDY CSRIDX        ; get cursor column
ea1e 91 d1       STA (LINPTR),Y    ; save character from current screen line
ea20 8a          TXA               ; copy colour to A
ea21 91 f3       STA (USER),Y      ; save to colour RAM
ea23 60          RTS ;Size    8 [Display_Char_And_Color]

              ; ******************
ea24            Set_COLRAM_Pointer
              ; ******************

ea24 a5 d1       LDA LINPTR        ; get current screen line pointer low byte
ea26 85 f3       STA USER          ; save pointer to colour RAM low byte
ea28 a5 d2       LDA LINPTR+1      ; get current screen line pointer high byte
ea2a 29 03       AND #$03          ; mask 0000 00xx, line memory page
ea2c 09 d8       ORA #COLRAM_PAGE  ; set  1001 01xx, colour memory page
ea2e 85 f4       STA USER+1        ; save pointer to colour RAM high byte
ea30 60          RTS ;Size   13 [Set_COLRAM_Pointer]

              ; ***********
ea31            Default_IRQ
              ; ***********

ea31 20 e4 ff    JSR UDTIM         ; Update the system clock
ea34 a5 cc       LDA BLNSW         ; get cursor enable
ea36 d0 29       BNE DIRQ_20       ; branch if not flash cursor
ea38 c6 cd       DEC BLNCT         ; else decrement cursor timing countdown
ea3a d0 25       BNE DIRQ_20       ; branch if not done
ea3c a9 14       LDA #$14          ; set count
ea3e 85 cd       STA BLNCT         ; save cursor timing countdown
ea40 a4 d3       LDY CSRIDX        ; get cursor column
ea42 46 cf       LSR BLNON         ; shift b0 cursor blink phase into carry
ea44 ae 87 02    LDX CSRCLR        ; get colour under cursor
ea47 b1 d1       LDA (LINPTR),Y    ; get character from current screen line
ea49 b0 11       BCS DIRQ_10       ; branch if cursor phase b0 was 1
ea4b e6 cf       INC BLNON         ; set cursor blink phase to 1
ea4d 85 ce       STA GDBLN         ; save character under cursor
ea4f 20 24 ea    JSR Set_COLRAM_Pointer
ea52 b1 f3       LDA (USER),Y      ; get colour RAM byte
ea54 8d 87 02    STA CSRCLR        ; save colour under cursor
ea57 ae 86 02    LDX COLOR         ; get current colour code
ea5a a5 ce       LDA GDBLN         ; get character under cursor

ea5c          DIRQ_10
ea5c 49 80       EOR #$80          ; toggle b7 of character under cursor
ea5e 20 1c ea    JSR Display_Char_And_Color

ea61          DIRQ_20
0001 FALSE    #if JIFFY
SKIP             JMP DIRQ_50
SKIP          
SKIP          ; **************
SKIP            Jiffy_Tokenize
SKIP          ; **************
SKIP          
SKIP             PLA   
SKIP             PHA   
SKIP             CMP #<[Direct_Call+2]  ; called from direct mode
SKIP             BEQ JiTo_20 
SKIP          
SKIP          JiTo_10
SKIP             JMP Default_Tokenize
SKIP          
SKIP          JiTo_20
SKIP             JSR Jiffy_Test_Command 
SKIP             BNE JiTo_10 
SKIP             LDX TXTPTR
SKIP             LDY #4
SKIP             TYA   
SKIP             JMP Toke_REM
0000 TRUE     #if C64
SKIP             .byte 1
              #endif
SKIP          
0001 FALSE    #if VIC
SKIP          Jiffy_eb08
SKIP             JSR JiDi_60
SKIP             JMP PrSe_10
SKIP             .byte $03  
SKIP             STA VIA1_PCR
              #endif
SKIP          
SKIP          
              #else

0000 TRUE     #if C64
ea61 a5 01       LDA R6510
ea63 29 10       AND #$10          ; mask cassette switch sense
              #endif
0001 FALSE    #if VIC
SKIP             LDA IEC_DRAN      ; get VIA 1 DRA, no handshake
SKIP             AND #$40          ; mask cassette switch sense
              #endif

ea65 f0 0a       BEQ DIRQ_30      ; branch if cassette sense low
ea67 a0 00       LDY #0
ea69 84 c0       STY CAS1          ; clear the tape motor interlock

0000 TRUE     #if C64
ea6b a5 01       LDA R6510
ea6d 09 20       ORA #$20          ; set CA2 high, turn off motor
              #endif
0001 FALSE    #if VIC
SKIP             LDA VIA1_PCR      ; get VIA 1 PCR
SKIP             ORA #$02          ; set CA2 high, turn off motor
              #endif

ea6f d0 08       BNE DIRQ_40      ; branch always

ea71          DIRQ_30
ea71 a5 c0       LDA CAS1          ; get tape motor interlock
ea73 d0 06       BNE DIRQ_50      ; if cassette interlock <> 0 don't turn on motor

0000 TRUE     #if C64
ea75 a5 01       LDA $01           ; R6510
ea77 29 1f       AND #$1F          ; turn on motor
              #endif
0001 FALSE    #if VIC
SKIP             LDA VIA1_PCR      ; get VIA 1 PCR
SKIP             AND #$FD          ; set CA2 low, turn on motor
              #endif

ea79          DIRQ_40

0000 TRUE     #if C64
ea79 85 01       STA R6510
              #endif
0001 FALSE    #if VIC
SKIP             BIT VIA1_IER      ; test VIA 1 IER
SKIP             BVS DIRQ_50       ; if T1 interrupt enabled don't change motor state
SKIP             STA VIA1_PCR      ; set VIA 1 PCR, set CA2 high/low
              #endif

              #endif               ; JIFFY

ea7b          DIRQ_50
ea7b 20 87 ea    JSR Kernal_SCNKEY ; scan keyboard

0000 TRUE     #if C64
ea7e ad 0d dc    LDA CIA1_ICR      ; CIA1 Interrupt Control Register
              #endif
0001 FALSE    #if VIC
SKIP             BIT VIA2_T1CL     ; clear the timer interrupt flag
              #endif

ea81 68          PLA
ea82 a8          TAY
ea83 68          PLA
ea84 aa          TAX
ea85 68          PLA
ea86 40          RTI

              ; *************
ea87            Kernal_SCNKEY
              ; *************

              ; 1) check if key pressed, if not then exit the routine
              ; 2) init I/O ports of VIA 2 for keyboard scan and set pointers to
              ;    decode table 1. clear the character counter
              ; 3) set one line of port B low and test for a closed key on port A by
              ;    shifting the byte read from the port. if the carry is clear then a
              ;    key is closed so save the count which is incremented on each shift.
              ;    check for shift/stop/cbm keys and flag if closed
              ; 4) repeat step 3 for the whole matrix
              ; 5) evaluate the SHIFT/CTRL/C= keys, this may change the decode table
              ;    selected
              ; 6) use the key count saved in step 3 as an index into the table
              ;    selected in step 5
              ; 7) check for key repeat operation
              ; 8) save the decoded key to the buffer if first press or repeat

ea87 a9 00       LDA #0
ea89 8d 8d 02    STA SHFLAG        ; clear keyboard shift/control/c= flag
ea8c a0 40       LDY #$40          ; set no key
ea8e 84 cb       STY SFDX          ; save which key
ea90 8d 00 dc    STA KEYB_COL      ; clear keyboard column
ea93 ae 01 dc    LDX KEYB_ROW      ; get keyboard row
ea96 e0 ff       CPX #$FF          ; compare with all bits set
ea98 f0 61       BEQ KeSc_50       ; if no key pressed clear current key and exit

0000 TRUE     #if C64
ea9a a8          TAY               ; clear key count
              #endif
0001 FALSE    #if VIC
SKIP             LDA #$FE
SKIP             STA KEYB_COL      ; select keyboard col 0
SKIP             LDY #0            ; clear key count
              #endif

ea9b a9 81       LDA #<KBD_NORMAL  ; get decode table low byte
ea9d 85 f5       STA KBDPTR        ; set keyboard pointer low byte
ea9f a9 eb       LDA #>KBD_NORMAL  ; get decode table high byte
eaa1 85 f6       STA KBDPTR+1      ; set keyboard pointer high byte

0000 TRUE     #if C64
eaa3 a9 fe       LDA #$FE
eaa5 8d 00 dc    STA KEYB_COL      ; select keyboard col 0
              #endif

eaa8          KeSc_05
eaa8 a2 08       LDX #8            ; set row count

0000 TRUE     #if C64
eaaa 48          PHA
eaab          KeSc_10
              #endif

eaab ad 01 dc    LDA KEYB_ROW      ; get VIA/CIA keyboard row
eaae cd 01 dc    CMP KEYB_ROW      ; compare with itself

0000 TRUE     #if C64
eab1 d0 f8       BNE KeSc_10       ; loop if changing
              #endif
0001 FALSE    #if VIC
SKIP             BNE KeSc_05      ; loop if changing
              #endif

eab3          KeSc_15
eab3 4a          LSR A             ; shift row to Cb
eab4 b0 16       BCS KeSc_30       ; if no key closed on this row go do next row
eab6 48          PHA               ; save row
eab7 b1 f5       LDA (KBDPTR),Y    ; get character from decode table
eab9 c9 05       CMP #$05          ; compare with $05, there is no $05 key but the control
eabb b0 0c       BCS KeSc_20       ; if not shift/control/c=/stop go save key count
eabd c9 03       CMP #$03          ; compare with $03, stop
eabf f0 08       BEQ KeSc_20       ; if stop go save key count and continue
eac1 0d 8d 02    ORA SHFLAG        ; OR keyboard shift/control/c= flag
eac4 8d 8d 02    STA SHFLAG        ; save keyboard shift/control/c= flag
eac7 10 02       BPL KeSc_25       ; skip save key, branch always

eac9          KeSc_20
eac9 84 cb       STY SFDX          ; save key count

eacb          KeSc_25
eacb 68          PLA               ; restore row

eacc          KeSc_30
eacc c8          INY               ; increment key count
eacd c0 41       CPY #$41          ; compare with max+1
eacf b0 0b       BCS KeSc_35       ; exit loop if >= max+1
ead1 ca          DEX               ; decrement row count
ead2 d0 df       BNE KeSc_15       ; loop if more rows to do
ead4 38          SEC               ; set carry for keyboard column shift

0000 TRUE     #if C64
ead5 68          PLA
ead6 2a          ROL A
ead7 8d 00 dc    STA KEYB_COL   
              #endif
0001 FALSE    #if VIC
SKIP             ROL KEYB_COL      ; shift VIA 2 DRB, keyboard column
              #endif

eada d0 cc       BNE KeSc_05      ; loop for next column, branch always

eadc          KeSc_35
0000 TRUE     #if C64
eadc 68          PLA
              #endif

eadd 6c 8f 02    JMP (KEYLOG)      ; normally Keyboard_Decoder

              ; key decoding continues here after the SHIFT/CTRL/C= keys are evaluated

eae0          KeSc_40
eae0 a4 cb       LDY SFDX          ; get saved key count
eae2 b1 f5       LDA (KBDPTR),Y    ; get character from decode table
eae4 aa          TAX               ; copy character to X
eae5 c4 c5       CPY LSTX          ; compare key count with last key count
eae7 f0 07       BEQ KeSc_45       ; if this key = current key, key held, go test repeat
eae9 a0 10       LDY #$10          ; set repeat delay count
eaeb 8c 8c 02    STY KRPTDL        ; save repeat delay count
eaee d0 36       BNE KeSc_65       ; go save key to buffer and exit, branch always

eaf0          KeSc_45
eaf0 29 7f       AND #$7F          ; clear b7
eaf2 2c 8a 02    BIT KEYRPT        ; test key repeat
eaf5 30 16       BMI KeSc_55       ; branch if repeat all
eaf7 70 49       BVS KeSc_70       ; branch if repeat none
eaf9 c9 7f       CMP #$7F          ; compare with end marker

eafb          KeSc_50
eafb f0 29       BEQ KeSc_65       ; if $00/end marker go save key to buffer and exit
eafd c9 14       CMP #$14          ; compare with [INSERT]/[DELETE]
eaff f0 0c       BEQ KeSc_55       ; if [INSERT]/[DELETE] go test for repeat
eb01 c9 20       CMP #' '          ; compare with [SPACE]
eb03 f0 08       BEQ KeSc_55       ; if [SPACE] go test for repeat
eb05 c9 1d       CMP #$1D          ; compare with [CURSOR RIGHT]
eb07 f0 04       BEQ KeSc_55       ; if [CURSOR RIGHT] go test for repeat
eb09 c9 11       CMP #$11          ; compare with [CURSOR DOWN]
eb0b d0 35       BNE KeSc_70       ; if not [CURSOR DOWN] just exit

eb0d          KeSc_55
eb0d ac 8c 02    LDY KRPTDL        ; get repeat delay counter
eb10 f0 05       BEQ KeSc_60       ; branch if delay expired
eb12 ce 8c 02    DEC KRPTDL        ; else decrement repeat delay counter
eb15 d0 2b       BNE KeSc_70       ; branch if delay not expired

eb17          KeSc_60
eb17 ce 8b 02    DEC KRPTSP        ; decrement repeat speed counter
eb1a d0 26       BNE KeSc_70       ; branch if repeat speed count not expired
eb1c a0 04       LDY #$04          ; set for 4/60ths of a second
eb1e 8c 8b 02    STY KRPTSP        ; set repeat speed counter
eb21 a4 c6       LDY NDX           ; get keyboard buffer index
eb23 88          DEY               ; decrement it
eb24 10 1c       BPL KeSc_70       ; if the buffer isn't empty just exit

eb26          KeSc_65
eb26 a4 cb       LDY SFDX          ; get the key count
eb28 84 c5       STY LSTX          ; save as the current key count
eb2a ac 8d 02    LDY SHFLAG        ; get keyboard shift/control/c= flag
eb2d 8c 8e 02    STY LSTSHF        ; save as last keyboard shift pattern
eb30 e0 ff       CPX #$FF          ; compare character with table end marker or no key
eb32 f0 0e       BEQ KeSc_70       ; if table end marker or no key just exit
eb34 8a          TXA               ; copy character to A
eb35 a6 c6       LDX NDX           ; get keyboard buffer index
eb37 ec 89 02    CPX KBMAXL        ; compare with keyboard buffer size
eb3a b0 06       BCS KeSc_70       ; if buffer full just exit
eb3c 9d 77 02    STA KBUFFR,X      ; save character to keyboard buffer
eb3f e8          INX               ; increment index
eb40 86 c6       STX NDX           ; save keyboard buffer index

eb42          KeSc_70
eb42 a9 7f       LDA #STND_COL     ; col 3 on VIC / col 7 on C64
eb44 8d 00 dc    STA KEYB_COL      ; set VIA/CIA keyboard column
eb47 60          RTS ;Size  193 [Kernal_SCNKEY]

              ; ****************
eb48            Keyboard_Decoder
              ; ****************

eb48 ad 8d 02    LDA SHFLAG        ; get keyboard shift/control/c= flag
eb4b c9 03       CMP #$03          ; compare with [SHIFT][C=]
eb4d d0 15       BNE KeDe_10       ; branch if not
eb4f cd 8e 02    CMP LSTSHF        ; compare with last
eb52 f0 ee       BEQ KeSc_70       ; exit if still the same
eb54 ad 91 02    LDA MODE          ; get shift mode switch $00 = enabled, $80 = locked
eb57 30 1d       BMI KeDe_30       ; if locked continue keyboard decode

0001 FALSE    #if VIC
0000 TRUE     #if !JIFFY
SKIP             .fill 19 ($EA)    ; NOP's
              #endif
              #endif
                                   ; switch character ROM
0000 TRUE     #if C64
eb59 ad 18 d0    LDA MEM_CONTROL   ; get start of character memory, ROM
eb5c 49 02       EOR #$02          ; toggle $8000,$8800
eb5e 8d 18 d0    STA MEM_CONTROL   ; set start of character memory, ROM
              #endif
0001 FALSE    #if VIC
SKIP             LDA VIC_R5        ; get start of character memory, ROM
SKIP             EOR #$02          ; toggle $8000,$8800
SKIP             STA VIC_R5        ; set start of character memory, ROM
0000 TRUE     #if !JIFFY
SKIP             .fill  4 ($EA)    ; NOP's
              #endif
              #endif

0001 FALSE    #if VIC & JIFFY
SKIP             JMP KeSc_40       ; continue keyboard decode
              #else
eb61 4c 76 eb    JMP KeDe_30       ; continue keyboard decode
              #endif

eb64          KeDe_10
eb64 0a          ASL A             ; convert flag to index 
eb65 c9 08       CMP #8            ; compare with [CTRL]
eb67 90 02       BCC KeDe_20       ; branch if not [CTRL] pressed
eb69 a9 06       LDA #6            ; [CTRL] : table 3 : index 6
0001 FALSE    #if VIC
0000 TRUE     #if !JIFFY
SKIP             .fill 2 ($EA)     ; NOP's
              #endif
              #endif

eb6b          KeDe_20
0001 FALSE    #if VIC
0000 TRUE     #if !JIFFY
SKIP             .fill 32 ($EA)    ; NOP's
              #endif
              #endif
eb6b aa          TAX               ; copy index to X
eb6c bd 79 eb    LDA KBD_Decode_Pointer,X
eb6f 85 f5       STA KBDPTR
eb71 bd 7a eb    LDA KBD_Decode_Pointer+1,X
eb74 85 f6       STA KBDPTR+1
eb76          KeDe_30
eb76 4c e0 ea    JMP KeSc_40       ; continue keyboard decode

0001 FALSE    #if VIC & JIFFY
SKIP          KeDe_60
SKIP             LDA #4
SKIP             JSR LISTEN
SKIP             LDA MEM_CONTROL
SKIP             AND #2
SKIP             BEQ KeDe_62
SKIP             LDA #7
SKIP          
SKIP          KeDe_62
SKIP             ORA #$60
SKIP             JSR SECOND
SKIP             LDA CSRIDX
SKIP             PHA
SKIP             LDA TBLX
SKIP             PHA
SKIP             JMP $edaa
SKIP          
SKIP             .fill 15 ($ea)
SKIP          
SKIP             TAX               ; copy index to X
SKIP             LDA KBD_Decode_Pointer,X
SKIP             STA KBDPTR
SKIP             LDA KBD_Decode_Pointer+1,X
SKIP             STA KBDPTR+1
SKIP             JMP KeSc_40       ; continue keyboard decode
SKIP             
              #endif

              ; ==================
eb79            KBD_Decode_Pointer
              ; ==================

eb79 81 eb       .word   KBD_NORMAL  ; 0   normal
eb7b c2 eb       .word   KBD_SHIFTED ; 1   shifted
eb7d 03 ec       .word   KBD_CBMKEY  ; 2   commodore
0001 FALSE    #if VIC & JIFFY
SKIP             .word   KBD_COMMCON ; 6   commodore control
              #else
eb7f 78 ec       .word   KBD_CONTROL ; 3   control
              #endif

0001 FALSE    #if VIC
0001 FALSE    #if JIFFY
SKIP          Jiffy_Combine_Nibbles
SKIP             LDA TAPE1+1
SKIP             AND #15
SKIP             STA TAPE1+1
SKIP             LDA CAS1
SKIP             ASL A
SKIP             ASL A
SKIP             ASL A
SKIP             ASL A
SKIP             ORA TAPE1+1
SKIP             RTS
SKIP             .byte $ed
              #else
SKIP             .word   KBD_NORMAL  ; 4   control
SKIP             .word   KBD_SHIFTED ; 5   shift - control
SKIP             .word   KBD_COMMCON ; 6   commodore control
SKIP             .word   KBD_CONTROL ; 7   shift - commdore - control
SKIP             .word   Switch_Text_Graphics    ; 8   unused
SKIP             .word   KBD_COMMCON ; 9   unused
SKIP             .word   KBD_COMMCON ; a   unused
SKIP             .word   KBD_CONTROL ; b   unused
              #endif
              #endif


eb81          KBD_NORMAL           ; keyboard decode table - unshifted

0000 TRUE     #if C64
eb81 14 0d 1d    .BYTE $14,$0d,$1d,$88,$85,$86,$87,$11
eb89 33 57 41    .BYTE $33,$57,$41,$34,$5a,$53,$45,$01
eb91 35 52 44    .BYTE $35,$52,$44,$36,$43,$46,$54,$58
eb99 37 59 47    .BYTE $37,$59,$47,$38,$42,$48,$55,$56
eba1 39 49 4a    .BYTE $39,$49,$4a,$30,$4d,$4b,$4f,$4e
eba9 2b 50 4c    .BYTE $2b,$50,$4c,$2d,$2e,$3a,$40,$2c
ebb1 5c 2a 3b    .BYTE $5c,$2a,$3b,$13,$01,$3d,$5e,$2f
ebb9 31 5f 04    .BYTE $31,$5f,$04,$32,$20,$02,$51,$03
ebc1 ff          .BYTE $ff
              #endif

0001 FALSE    #if VIC
SKIP             .byte $31,$33,$35,$37,$39,$2B,$5C,$14
SKIP             .byte $5F,$57,$52,$59,$49,$50,$2A,$0D
SKIP             .byte $04,$41,$44,$47,$4A,$4C,$3B,$1D
SKIP             .byte $03,$01,$58,$56,$4E,$2C,$2F,$11
SKIP             .byte $20,$5A,$43,$42,$4D,$2E,$01,$85
SKIP             .byte $02,$53,$46,$48,$4B,$3A,$3D,$86
SKIP             .byte $51,$45,$54,$55,$4F,$40,$5E,$87
SKIP             .byte $32,$34,$36,$38,$30,$2D,$13,$88
SKIP             .byte $FF
              #endif

ebc2          KBD_SHIFTED          ; keyboard decode table - shifted

0000 TRUE     #if C64
ebc2 94 8d 9d    .BYTE $94,$8d,$9d,$8c,$89,$8a,$8b,$91
ebca 23 d7 c1    .BYTE $23,$d7,$c1,$24,$da,$d3,$c5,$01
ebd2 25 d2 c4    .BYTE $25,$d2,$c4,$26,$c3,$c6,$d4,$d8
ebda 27 d9 c7    .BYTE $27,$d9,$c7,$28,$c2,$c8,$d5,$d6
ebe2 29 c9 ca    .BYTE $29,$c9,$ca,$30,$cd,$cb,$cf,$ce
ebea db d0 cc    .BYTE $db,$d0,$cc,$dd,$3e,$5b,$ba,$3c
ebf2 a9 c0 5d    .BYTE $a9,$c0,$5d,$93,$01,$3d,$de,$3f
ebfa 21 5f 04    .BYTE $21,$5f,$04,$22,$a0,$02,$d1,$83
ec02 ff          .BYTE $ff
              #endif

0001 FALSE    #if VIC
SKIP             .byte $21,$23,$25,$27,$29,$DB,$A9,$94
SKIP             .byte $5F,$D7,$D2,$D9,$C9,$D0,$C0,$8D
SKIP             .byte $04,$C1,$C4,$C7,$CA,$CC,$5D,$9D
SKIP             .byte $83,$01,$D8,$D6,$CE,$3C,$3F,$91
SKIP             .byte $A0,$DA,$C3,$C2,$CD,$3E,$01,$89
SKIP             .byte $02,$D3,$C6,$C8,$CB,$5B,$3D,$8A
SKIP             .byte $D1,$C5,$D4,$D5,$CF,$BA,$DE,$8B
SKIP             .byte $22,$24,$26,$28,$30,$DD,$93,$8C
SKIP             .byte $FF
              #endif

ec03          KBD_CBMKEY           ; keyboard decode table - commodore

0000 TRUE     #if C64
ec03 94 8d 9d    .BYTE $94,$8d,$9d,$8c,$89,$8a,$8b,$91
ec0b 96 b3 b0    .BYTE $96,$b3,$b0,$97,$ad,$ae,$b1,$01
ec13 98 b2 ac    .BYTE $98,$b2,$ac,$99,$bc,$bb,$a3,$bd
ec1b 9a b7 a5    .BYTE $9a,$b7,$a5,$9b,$bf,$b4,$b8,$be
ec23 29 a2 b5    .BYTE $29,$a2,$b5,$30,$a7,$a1,$b9,$aa
ec2b a6 af b6    .BYTE $a6,$af,$b6,$dc,$3e,$5b,$a4,$3c
ec33 a8 df 5d    .BYTE $a8,$df,$5d,$93,$01,$3d,$de,$3f
ec3b 81 5f 04    .BYTE $81,$5f,$04,$95,$a0,$02,$ab,$83
ec43 ff          .BYTE $ff
              #endif

0001 FALSE    #if VIC
SKIP             .byte $21,$23,$25,$27,$29,$A6,$A8,$94
SKIP             .byte $5F,$B3,$B2,$B7,$A2,$AF,$DF,$8D
SKIP             .byte $04,$B0,$AC,$A5,$B5,$B6,$5D,$9D
SKIP             .byte $83,$01,$BD,$BE,$AA,$3C,$3F,$91
SKIP             .byte $A0,$AD,$BC,$BF,$A7,$3E,$01,$89
SKIP             .byte $02,$AE,$BB,$B4,$A1,$5B,$3D,$8A
SKIP             .byte $AB,$B1,$A3,$B8,$B9,$A4,$DE,$8B
SKIP             .byte $22,$24,$26,$28,$30,$DC,$93,$8C
SKIP             .byte $FF
              #endif

              ; ====================
ec44            Switch_Text_Graphics
              ; ====================

ec44 c9 0e       CMP #$0E          ; compare with [SWITCH TO LOWER CASE]
ec46 d0 07       BNE STG_10        ; branch if not [SWITCH TO LOWER CASE]

0000 TRUE     #if C64
ec48 ad 18 d0    LDA MEM_CONTROL
ec4b 09 02       ORA #2
ec4d d0 09       BNE STG_20
              #endif
0001 FALSE    #if VIC
SKIP             LDA #$02          ; set for $8800, lower case characters
SKIP             ORA MEM_CONTROL   ; OR with start of character memory, ROM
SKIP             STA MEM_CONTROL   ; save start of character memory, ROM
SKIP             JMP InsC_50       ; restore registers, set quote flag and exit
              #endif

ec4f          STG_10
ec4f c9 8e       CMP #$8E          ; compare with [SWITCH TO UPPER CASE]
ec51 d0 0b       BNE STG_40        ; branch if not [SWITCH TO UPPER CASE]

0000 TRUE     #if C64
ec53 ad 18 d0    LDA MEM_CONTROL
ec56 29 fd       AND #$FD
              #endif
0001 FALSE    #if VIC
SKIP             LDA #$FD          ; set for $8000, upper case characters
SKIP             AND MEM_CONTROL   ; AND with start of character memory, ROM
              #endif

ec58          STG_20
ec58 8d 18 d0    STA MEM_CONTROL   ; save start of character memory, ROM

ec5b          STG_30
ec5b 4c a8 e6    JMP InsC_50       ; restore registers, set quote flag and exit

ec5e          STG_40
ec5e c9 08       CMP #$08          ; compare with disable [SHIFT][C=]
ec60 d0 07       BNE STG_50        ; branch if not disable [SHIFT][C=]
ec62 a9 80       LDA #$80          ; set to lock shift mode switch
ec64 0d 91 02    ORA MODE          ; OR with shift mode switch, $00 = enabled, $80 = locked

0000 TRUE     #if C64
ec67 30 09       BMI STG_60
              #endif
0001 FALSE    #if VIC
SKIP             STA MODE          ; save shift mode switch
SKIP             BMI STG_30        ; branch always
              #endif

ec69          STG_50
ec69 c9 09       CMP #$09          ; compare with enable [SHIFT][C=]
ec6b d0 ee       BNE STG_30        ; exit if not enable [SHIFT][C=]    ##### start ####
ec6d a9 7f       LDA #$7F          ; set to unlock shift mode switch
ec6f 2d 91 02    AND MODE          ; AND with shift mode switch, $00 = enabled, $80 = locked

ec72          STG_60
ec72 8d 91 02    STA MODE          ; save shift mode switch

0000 TRUE     #if C64
ec75 4c a8 e6    JMP InsC_50
              #endif
0001 FALSE    #if VIC
SKIP          
SKIP             BPL STG_30        ; branch always
SKIP          
SKIP          ; VC-20 patch for "Expand Logical Line": make next screen line start of
SKIP          ; logical line, increment line length and set pointers
SKIP          
SKIP          ELL_10
SKIP             INX               ; increment screen row
SKIP             LDA SLLTBL,X      ; get start of line X pointer high byte
SKIP             ORA #$80          ; mark as start of logical line
SKIP             STA SLLTBL,X      ; set start of line X pointer high byte
SKIP             DEX               ; restore screen row
SKIP             LDA LINLEN        ; get current screen line length
SKIP             CLC
SKIP             JMP ELL_20      ; add one line length, set pointers for start of line and
SKIP                               ; return
              #endif

0000 TRUE     #if C64

ec78          KBD_CONTROL          ; keyboard decode table - control

ec78 ff ff ff   .BYTE $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff
ec80 1c 17 01   .BYTE $1c,$17,$01,$9f,$1a,$13,$05,$ff
ec88 9c 12 04   .BYTE $9c,$12,$04,$1e,$03,$06,$14,$18
ec90 1f 19 07   .BYTE $1f,$19,$07,$9e,$02,$08,$15,$16
ec98 12 09 0a   .BYTE $12,$09,$0a,$92,$0d,$0b,$0f,$0e
eca0 ff 10 0c   .BYTE $ff,$10,$0c,$ff,$ff,$1b,$00,$ff
eca8 1c ff 1d   .BYTE $1c,$ff,$1d,$ff,$ff,$1f,$1e,$ff
ecb0 90 06 ff   .BYTE $90,$06,$ff,$05,$ff,$ff,$11,$ff
ecb8 ff         .BYTE $ff

ecb9          VIC_INIT             ; initialise VIC registers

ecb9 00 00 00    .BYTE $00,$00,$00,$00,$00,$00,$00,$00
ecc1 00 00 00    .BYTE $00,$00,$00,$00,$00,$00,$00,$00
ecc9 00 9b 37    .BYTE $00,$9b,$37,$00,$00,$00,$08,$00
ecd1 14 0f 00    .BYTE $14,$0f,$00,$00,$00,$00,$00,$00
ecd9 0e 06 01    .BYTE $0e,$06,$01,$02,$03,$04,$00,$01
ece1 02 03 04    .BYTE $02,$03,$04,$05,$06,$07
              #endif

0001 FALSE    #if VIC
SKIP          KBD_COMMCON         ; keyboard decode table - cbm - control
0001 FALSE    #if JIFFY
SKIP          
SKIP             .byte $90,$1c,$9c,$1f,$12,$ff,$1c,$ff
SKIP             .byte $06,$17,$12,$19,$09,$10,$ff,$ff
SKIP             .byte $ff,$01,$04,$07,$0a,$0c,$1d,$ff
SKIP             .byte $ff,$ff,$18,$16,$0e,$ff,$ff,$ff
SKIP             .byte $ff,$1a,$03,$02,$0d,$ff,$ff,$ff
SKIP             .byte $ff,$13,$06,$08,$0b,$1b,$1f,$ff
SKIP             .byte $11,$05,$14,$15,$0f,$00,$1e,$ff
SKIP             .byte $05,$9f,$1e,$9e,$92,$ff,$ff,$ff
SKIP             .byte $ff
SKIP          
SKIP          JAAA
SKIP             LDY #0
SKIP             STY CSRMOD
SKIP             JSR PLOT_05
SKIP             INC LINLEN
SKIP          
SKIP          JAAA_10
SKIP             JSR CHRI_07
SKIP             JSR Kernal_CIOUT
SKIP             CMP #13
SKIP             BNE JAAA_10
SKIP             INX
SKIP             CPX #$17
SKIP             BCS JAAA_20
SKIP             ASL LINLEN
SKIP             BPL JAAA
SKIP             INX
SKIP             BNE JAAA
SKIP          
SKIP          JAAA_20
SKIP             JSR UNLSN
SKIP             PLA
SKIP             TAX
SKIP             PLA
SKIP             TAY
SKIP             JSR PLOT_05
SKIP          
SKIP          JAAA_30
SKIP             PLA
SKIP          
SKIP          JAAA_40
SKIP             RTS
              #else
SKIP             .byte   $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
SKIP             .byte   $FF,$04,$FF,$FF,$FF,$FF,$FF,$E2
SKIP             .byte   $9D,$83,$01,$FF,$FF,$FF,$FF,$FF
SKIP             .byte   $91,$A0,$FF,$FF,$FF,$FF,$EE,$01
SKIP             .byte   $89,$02,$FF,$FF,$FF,$FF,$E1,$FD
SKIP             .byte   $8A,$FF,$FF,$FF,$FF,$FF,$B0,$E0
SKIP             .byte   $8B,$F2,$F4,$F6,$FF,$F0,$ED,$93
SKIP             .byte   $8C,$FF
SKIP          
SKIP          KBD_CONTROL          ; keyboard decode table - control
SKIP          
SKIP             .byte   $90,$1C,$9C,$1F,$12,$FF,$FF,$FF
SKIP             .byte   $06,$FF,$12,$FF,$FF,$FF,$FF,$FF
SKIP             .byte   $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
SKIP             .byte   $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
SKIP             .byte   $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
SKIP             .byte   $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
SKIP             .byte   $FF,$FF
              #endif
SKIP          
SKIP             .byte $FF,$FF,$FF,$FF,$FF,$FF,$05
SKIP             .byte $9F,$1E,$9E,$92,$FF,$FF,$FF,$FF
SKIP          
SKIP          VIC_INIT             ; initial values for VIC registers
SKIP          
0000 TRUE     #if PAL
SKIP             .byte   $0C       ; horizontal offset [PAL]
SKIP             .byte   $26       ; vertical origin [PAL]
              #else
SKIP             .byte   $05       ; horizontal offset [NTSC]
SKIP             .byte   $19       ; vertical origin [NTSC]
              #endif
SKIP          
SKIP             .byte   $16       ; video address and colums, $9400 for colour RAM
SKIP                               ; bit   function
SKIP                               ; ---   --------
SKIP                               ;  7   video address va9
SKIP                               ; 6-0   number of columns
SKIP             .byte   $2E       ; rows and character size
SKIP                               ; bit   function
SKIP                               ; ---   --------
SKIP                               ;  7   b9 raster line
SKIP                               ; 6-1   number of rows
SKIP                               ;  0   8x16 / 8x8 characters
SKIP             .byte   $00       ; raster line
SKIP             .byte   $C0       ; video memory addresses, RAM $1000, ROM $8000
SKIP                               ; bit   function
SKIP                               ; ---   --------
SKIP                               ;  7   must be 1
SKIP                               ; 6-4   video memory address va12-va10
SKIP                               ; 3-0   character memory start address
SKIP          
SKIP                               ; 0000 ROM   $8000   set 1 - we use this
SKIP                               ; 0001  "   $8400
SKIP                               ; 0010  "   $8800 set 2
SKIP                               ; 0011  "   $8C00
SKIP                               ; 1100 RAM   $1000
SKIP                               ; 1101  "   $1400
SKIP                               ; 1110  "   $1800
SKIP                               ; 1111  "   $1C00
SKIP          
SKIP             .byte   $00       ; light pen horizontal position
SKIP             .byte   $00       ; light pen vertical position
SKIP          
SKIP             .byte   $00       ; paddle X
SKIP             .byte   $00       ; paddle Y
SKIP             .byte   $00       ; oscillator 1 frequency
SKIP             .byte   $00       ; oscillator 2 frequency
SKIP             .byte   $00       ; oscillator 3 frequency
SKIP             .byte   $00       ; noise source frequency
SKIP             .byte   $00       ; aux colour and volume
SKIP                               ; bit   function
SKIP                               ; ---   --------
SKIP                               ; 7-4   auxiliary colour information
SKIP                               ; 3-0   volume
SKIP             .byte   $1B       ; screen and border colour
SKIP                               ; bit   function
SKIP                               ; ---   --------
SKIP                               ; 7-4   background colour
SKIP                               ;  3   inverted or normal mode
SKIP                               ; 2-0   border colour
              #endif

ece7 4c 4f 41 RUNKEY .byte "LOAD",$0D,"RUN",$0D

              ; ***************
ecf0            Line_Adress_Low
              ; ***************

0000 TRUE     #if C64
ecf0 00 28 50    .byte $00,$28,$50,$78,$a0,$c8,$f0,$18
ecf8 40 68 90    .byte $40,$68,$90,$b8,$e0,$08,$30,$58
ed00 80 a8 d0    .byte $80,$a8,$d0,$f8,$20,$48,$70,$98
ed08 c0          .byte $c0
              #endif
0001 FALSE    #if VIC
SKIP             .byte $00,$16,$2C,$42,$58,$6E,$84,$9A
SKIP             .byte $B0,$C6,$DC,$F2,$08,$1E,$34,$4A
SKIP             .byte $60,$76,$8C,$A2,$B8,$CE,$E4
              #endif

              ; ***********
ed09            Kernal_TALK
              ; ***********

ed09 09 40       ORA #$40          ; OR with the TALK command
ed0b 2c          .byte   $2C       ; skip next 2 bytes

              ; *************
ed0c            Kernal_LISTEN
              ; *************

ed0c 09 20       ORA #$20          ; OR with the LISTEN command
ed0e 20 a4 f0    JSR RS232_Stop

              ; *********************
ed11            IEC_Send_Control_Byte
              ; *********************

ed11 48          PHA               ; save device address
ed12 24 94       BIT C3PO          ; test deferred character flag
ed14 10 0a       BPL ISCB_10       ; branch if no defered character
ed16 38          SEC               ; flag EOI
ed17 66 a3       ROR TSFCNT        ; rotate into EOI flag byte
0001 FALSE    #if JIFFY
SKIP             JSR Jiffy_Send_Byte
              #else
ed19 20 40 ed    JSR IEC_Send_Byte
              #endif
ed1c 46 94       LSR C3PO          ; clear deferred character flag
ed1e 46 a3       LSR TSFCNT        ; clear EOI flag

ed20          ISCB_10
ed20 68          PLA               ; device address OR'ed with command
ed21 85 95       STA BSOUR         ; save as serial defered character
0000 TRUE     #if C64
ed23 78          SEI
              #endif
0001 FALSE    #if JIFFY
SKIP             JSR Jiffy_CLR_DAT
              #else
ed24 20 97 ee    JSR CLR_IEC_DAT   ; set IEC data out high (0)
              #endif
ed27 c9 3f       CMP #$3F          ; compare read byte with $3F
ed29 d0 03       BNE ISCB_20       ; branch if not $3F, this branch will always be taken
ed2b 20 85 ee    JSR CLR_IEC_CLK   ; set IEC clock out high (0)

ed2e          ISCB_20
ed2e ad 00 dd    LDA IEC_DRAN      ; get VIA 1 DRA, no handshake
ed31 09 08       ORA #IEC_ATN_BIT  ; set IEC ATN low (1)
ed33 8d 00 dd    STA IEC_DRAN      ; set VIA 1 DRA, no handshake

              ; ***********************
ed36            IEC_Delay_And_Send_Byte
              ; ***********************

0000 TRUE     #if C64
ed36 78          SEI
              #endif
ed37 20 8e ee    JSR SET_IEC_CLK   ; set IEC clock out low
ed3a 20 97 ee    JSR CLR_IEC_DAT   ; set IEC data  out high
ed3d 20 b3 ee    JSR WAIT_1MS      ; 1ms delay

              ; *************
ed40            IEC_Send_Byte
              ; *************

ed40 78          SEI               ; disable interrupts
ed41 20 97 ee    JSR CLR_IEC_DAT   ; set serial data out high
ed44 20 a9 ee    JSR GET_IEC_CLK   ; get serial clock status
0001 FALSE    #if VIC
SKIP             LSR A             ; shift serial data to Cb
              #endif
ed47 b0 64       BCS Device_Not_Present
ed49 20 85 ee    JSR CLR_IEC_CLK   ; set serial clock high
ed4c 24 a3       BIT TSFCNT        ; test EOI flag
ed4e 10 0a       BPL ISCB_50       ; branch if not EOI

              ; I think this is the EOI sequence so the serial clock has been released
              ; and the serial data is being held low by the peripherals. first up
              ; wait for the serial data to rise

ed50          ISCB_30
ed50 20 a9 ee    JSR GET_IEC_CLK   ; get serial clock status
0001 FALSE    #if VIC
SKIP             LSR A             ; shift serial data to Cb
              #endif
ed53 90 fb       BCC ISCB_30       ; loop if data low

              ; now the data is high, EOI is signalled by waiting for at least 200us
              ; without pulling the serial clock line low again. the listener should
              ; respond by pulling the serial data line low

ed55          ISCB_40
ed55 20 a9 ee    JSR GET_IEC_CLK   ; get serial clock status
0001 FALSE    #if VIC
SKIP             LSR A             ; shift serial data to Cb
              #endif
ed58 b0 fb       BCS ISCB_40       ; loop if data high

              ; the serial data has gone low ending the EOI sequence, now just wait
              ; for the serial data line to go high again or, if this isn't an EOI
              ; sequence, just wait for the serial data to go high the first time

ed5a          ISCB_50
ed5a 20 a9 ee    JSR GET_IEC_CLK   ; get serial clock status
0001 FALSE    #if VIC
SKIP             LSR A             ; shift serial data to Cb
              #endif
ed5d 90 fb       BCC ISCB_50       ; loop if data low

              ; serial data is high now pull the clock low, preferably within 60us

ed5f 20 8e ee    JSR SET_IEC_CLK   ; set serial clock low

              ; now the Vic has to send the eight bits, LSB first. first it sets the
              ; serial data line to reflect the bit in the byte, then it sets the
              ; serial clock to high. The serial clock is left high for 26 cycles,
              ; 23us on a PAL Vic, before it is again pulled low and the serial data
              ; is allowed high again

              ; The jiffy routine detecs Jiffy devices within the routine
              ; Jiffy_Detect_Device and X=2 

0001 FALSE    #if JIFFY
SKIP             TXA
SKIP             PHA               ; save X
SKIP             LDX #8            ; eight bits to do
SKIP          
SKIP          ISCB_51
0000 TRUE     #if C64
SKIP             PHA               ; waste 7 cycles
SKIP             PLA
SKIP             BIT IEC_DRAN
SKIP             BMI ISCB_52       ; IEC clock low (1) ?
              #endif
0001 FALSE    #if VIC
SKIP             LDA VIA1_DATN
SKIP             AND #2
SKIP             BNE ISCB_52       ; IEC clock low (1) ?
              #endif
SKIP             PLA               ; no
SKIP             TAX               ; restore X
SKIP             JMP IEC_Timeout
SKIP          
SKIP          ISCB_52
SKIP             JSR CLR_IEC_DAT   ; set IEC data high (0)
SKIP             ROR BSOUR         ; rotate bit to send into carry
SKIP             BCS ISCB_54       ; branch if bit = 1
SKIP             JSR SET_IEC_DAT   ; set IEC data low (1)
SKIP          
SKIP          ISCB_54
SKIP             JSR CLR_IEC_CLK   ; set IEC clock high (0)
SKIP             LDA IEC_PCR
0000 TRUE     #if C64
SKIP             AND #$df          ; set data high (0)
SKIP             ORA #$10          ; set clock low (1)
              #endif
0001 FALSE    #if VIC
SKIP             AND #$dd          ; set data high (0)
SKIP             ORA #$02          ; set clock low (1)
              #endif
SKIP             PHP               ; 
SKIP             PHA 
SKIP             JSR Jiffy_Detect_Device
SKIP             PLA
SKIP             PLP
SKIP             DEX 
SKIP             BNE ISCB_51       ; next bit
SKIP             PLA               ; restore X
SKIP             TAX
0001 FALSE    #if VIC
SKIP             NOP
              #endif
              #else
ed62 a9 08       LDA #$08          ; eight bits to do
ed64 85 a5       STA CNTDN         ; set serial bus bit count

ed66          ISCB_60
ed66 ad 00 dd    LDA IEC_DRAN      ; get VIA 1 DRA, no handshake
ed69 cd 00 dd    CMP IEC_DRAN      ; compare with self
ed6c d0 f8       BNE ISCB_60       ; loop if changing

0000 TRUE     #if C64
ed6e 0a          ASL A             ; serial clock to carry
              #endif
0001 FALSE    #if VIC
SKIP             LSR A             ; serial clock to carry
SKIP             LSR A             ; serial data to carry
              #endif
ed6f 90 3f       BCC IEC_Timeout
ed71 66 95       ROR BSOUR         ; rotate transmit byte
ed73 b0 05       BCS ISCB_70       ; branch if bit = 1
ed75 20 a0 ee    JSR SET_IEC_DAT   ; else set serial data out low
ed78 d0 03       BNE ISCB_80       ; branch always

ed7a          ISCB_70
ed7a 20 97 ee    JSR CLR_IEC_DAT   ; set serial data out high

ed7d          ISCB_80
ed7d 20 85 ee    JSR CLR_IEC_CLK   ; set serial clock high
ed80 ea          NOP
ed81 ea          NOP
ed82 ea          NOP
ed83 ea          NOP
ed84 ad 00 dd    LDA IEC_PCR       ; get VIA/CIA PCR
ed87 29 df       AND #$DF          ; set CB2 low, serial data out high
ed89 09 10       ORA #IEC_CLK_BIT  ; set CA2 high, serial clock out low
ed8b 8d 00 dd    STA IEC_PCR
ed8e c6 a5       DEC CNTDN         ; decrement serial bus bit count
ed90 d0 d4       BNE ISCB_60       ; loop if not all done

              ; now all eight bits have been sent it's up to the peripheral to signal the byte was
              ; received by pulling the serial data low. this should be done within one milisecond

              #endif
ed92 a9 04       LDA #4            ; wait for up to about 1ms
ed94 8d 07 dc    STA IEC_TIM_H     ; set VIA/CIA timer high

ed97          ISCB_90
0000 TRUE     #if C64
ed97 a9 19       LDA #$19
ed99 8d 0f dc    STA CIA1_CRB      ; CIA1 Control Register B
ed9c ad 0d dc    LDA CIA1_ICR      ; CIA1 Interrupt Control Register

ed9f          ISCB_95
ed9f ad 0d dc    LDA CIA1_ICR      ; CIA1 Interrupt Control Register
eda2 29 02       AND #2
eda4 d0 0a       BNE IEC_Timeout
eda6 20 a9 ee    JSR GET_IEC_CLK   ; get serial clock status
eda9 b0 f4       BCS ISCB_95
              #endif
0001 FALSE    #if VIC
SKIP             LDA IEC_IFR       ; get VIA 2 IFR
SKIP             AND #$20          ; mask T2 interrupt
SKIP             BNE IEC_Timeout      ; if T2 interrupt do timeout on serial bus
SKIP             JSR GET_IEC_CLK   ; get serial clock status
SKIP             LSR A             ; shift serial data to Cb
SKIP             BCS ISCB_90       ; if data high go wait some more
              #endif
edab 58          CLI
edac 60          RTS ;Size  109 [IEC_Send_Byte]

              ; ==================
edad            Device_Not_Present
              ; ==================

edad a9 80       LDA #$80          ; error $80, device not present
edaf 2c          .byte   $2C       ; skip next statement

              ; ===========
edb0            IEC_Timeout
              ; ===========

edb0 a9 03       LDA #$03          ; error $03, write timeout

              ; ==============
edb2            Set_IEC_Status
              ; ==============

edb2 20 16 fe    JSR Ora_Status
edb5 58          CLI               ; enable interrupts
edb6 18          CLC               ; clear for branch
edb7 90 4a       BCC KeUN_10      ; ATN high, delay, clock high then data high, branch always

              ; *************
edb9            Kernal_SECOND
              ; *************

edb9 85 95       STA BSOUR         ; save defered byte
edbb 20 36 ed    JSR IEC_Delay_And_Send_Byte

              ; ************
edbe            IEC_ATN_High
              ; ************

edbe ad 00 dd    LDA IEC_DRAN      ; get VIA 1 DRA, no handshake
0000 TRUE     #if C64
edc1 29 f7       AND #$F7          ; set serial ATN high
              #endif
0001 FALSE    #if VIC
SKIP             AND #$7F          ; set serial ATN high
              #endif
edc3 8d 00 dd    STA IEC_DRAN      ; set VIA 1 DRA, no handshake
edc6 60          RTS ;Size    9 [IEC_ATN_High]

              ; ***********
edc7            Kernal_TKSA
              ; ***********

edc7 85 95       STA BSOUR         ; save the secondary address byte to transmit
edc9 20 36 ed    JSR IEC_Delay_And_Send_Byte

              ; ***************
edcc            IEC_Finish_Send
              ; ***************

edcc 78          SEI               ; disable interrupts
edcd 20 a0 ee    JSR SET_IEC_DAT   ; set serial data out low
edd0 20 be ed    JSR IEC_ATN_High  ; set serial ATN high
edd3 20 85 ee    JSR CLR_IEC_CLK   ; set serial clock high

edd6          IFS_10
0001 FALSE    #if JIFFY
0000 TRUE     #if C64
SKIP             BIT IEC_DRAN
SKIP             BVS IFS_10
              #else
SKIP             JSR GET_IEC_CLK
SKIP             BCS IFS_10
              #endif
              #else
edd6 20 a9 ee    JSR GET_IEC_CLK   ; get serial clock status
0000 TRUE     #if C64
edd9 30 fb       BMI IFS_10        ; branch if clock high
              #endif
0001 FALSE    #if VIC
SKIP             BCS IFS_10        ; branch if clock high
              #endif
              #endif               ; JIFFY
eddb 58          CLI               ; enable interrupts
eddc 60          RTS ;Size   17 [IEC_Finish_Send]

              ; ************
eddd            Kernal_CIOUT
              ; ************

eddd 24 94       BIT C3PO          ; test deferred character flag
eddf 30 05       BMI KeCI_10       ; branch if defered character
ede1 38          SEC               ; set carry
ede2 66 94       ROR C3PO          ; shift into deferred character flag
ede4 d0 05       BNE KeCI_20       ; save byte and exit, branch always

ede6          KeCI_10
ede6 48          PHA               ; save byte
0001 FALSE    #if JIFFY
SKIP             JSR Jiffy_Send_Byte
              #else
ede7 20 40 ed    JSR IEC_Send_Byte
              #endif
edea 68          PLA               ; restore byte

edeb          KeCI_20
edeb 85 95       STA BSOUR         ; save defered byte
eded 18          CLC               ; flag ok
edee 60          RTS ;Size   18 [Kernal_CIOUT]

              ; ************
edef            Kernal_UNTLK
              ; ************

0000 TRUE     #if C64
edef 78          SEI
              #endif
0000 TRUE     #if !JIFFY
edf0 20 8e ee    JSR SET_IEC_CLK
              #endif
edf3 ad 00 dd    LDA IEC_DRAN      ; get VIA 1 DRA, no handshake
edf6 09 08       ORA #IEC_ATN_BIT  ; set serial ATN low
edf8 8d 00 dd    STA IEC_DRAN      ; set VIA 1 DRA, no handshake
0001 FALSE    #if JIFFY
SKIP             JSR SET_IEC_CLK
              #endif
edfb a9 5f       LDA #$5F          ; set the UNTALK command
edfd 2c          .byte   $2C       ; skip next two bytes

              ; ************
edfe            Kernal_UNLSN
              ; ************

edfe a9 3f       LDA #$3F          ; set the UNLISTEN command
ee00 20 11 ed    JSR IEC_Send_Control_Byte

ee03          KeUN_10
ee03 20 be ed    JSR IEC_ATN_High  ; set serial ATN high

              ; ****************************
ee06            IEC_Delay_CLK_High_DATA_High
              ; ****************************

ee06 8a          TXA               ; save device number
0000 TRUE     #if C64
ee07 a2 0a       LDX #10           ; short delay
              #endif
0001 FALSE    #if VIC
SKIP             LDX #11           ; short delay
              #endif
ee09          IDel_10
ee09 ca          DEX               ; decrement count
ee0a d0 fd       BNE IDel_10       ; loop if not all done
ee0c aa          TAX               ; restore device number
ee0d 20 85 ee    JSR CLR_IEC_CLK   ; set serial clock high
ee10 4c 97 ee    JMP CLR_IEC_DAT   ; set serial data out high and return

              ; ************
ee13            Kernal_ACPTR
              ; ************

0001 FALSE    #if JIFFY
SKIP             JMP Jiffy_ACPTR
              #else
ee13 78          SEI               ; disable interrupts
ee14 a9 00       LDA #0
              #endif

ee16          KeAC_03
ee16 85 a5       STA CNTDN         ; clear serial bus bit count
ee18 20 85 ee    JSR CLR_IEC_CLK   ; set serial clock high

ee1b          KeAC_05
ee1b 20 a9 ee    JSR GET_IEC_CLK   ; get serial clock status
0000 TRUE     #if C64
ee1e 10 fb       BPL KeAC_05       ; loop while clock low
              #endif
0001 FALSE    #if VIC
SKIP             BCC KeAC_05       ; loop while clock low
SKIP             JSR CLR_IEC_DAT   ; set serial data out high
              #endif

ee20          KeAC_10
ee20 a9 01       LDA #$01          ; set timeout count high byte
ee22 8d 07 dc    STA IEC_TIM_H

ee25          KeAC_15
0000 TRUE     #if C64
ee25 a9 19       LDA #$19
ee27 8d 0f dc    STA CIA1_CRB      ; CIA1 Control Register B
ee2a 20 97 ee    JSR CLR_IEC_DAT   ; set serial data out high
ee2d ad 0d dc    LDA CIA1_ICR      ; CIA1 Interrupt Control Register
ee30          KeAC_20
              #endif

ee30 ad 0d dc    LDA IEC_IFR       ; get VIA 2 IFR
ee33 29 02       AND #IEC_IFR_BIT  ; mask T2 interrupt
ee35 d0 07       BNE KeAC_25       ; branch if T2 interrupt
ee37 20 a9 ee    JSR GET_IEC_CLK   ; get serial clock status

0000 TRUE     #if C64
ee3a 30 f4       BMI KeAC_20       ; loop if clock high
ee3c 10 18       BPL KeAC_35       ; else go se 8 bits to do, branch always
              #endif
0001 FALSE    #if VIC
SKIP             BCS KeAC_15       ; loop if clock high
SKIP             BCC KeAC_35       ; else go se 8 bits to do, branch always
              #endif

ee3e          KeAC_25
ee3e a5 a5       LDA CNTDN         ; get serial bus bit count
ee40 f0 05       BEQ KeAC_30       ; if not already EOI then go flag EOI
ee42 a9 02       LDA #$02          ; error $02, read timeour
ee44 4c b2 ed    JMP Set_IEC_Status

ee47          KeAC_30
ee47 20 a0 ee    JSR SET_IEC_DAT    ; set serial data out low

0000 TRUE     #if C64
ee4a 20 85 ee    JSR CLR_IEC_CLK
              #endif
0001 FALSE    #if VIC
SKIP             JSR IEC_Delay_CLK_High_DATA_High      ; 1ms delay, clock high then data high
              #endif
ee4d a9 40       LDA #$40          ; set EOI
ee4f 20 16 fe    JSR Ora_Status
ee52 e6 a5       INC CNTDN         ; increment serial bus bit count, do error on next timeout
ee54 d0 ca       BNE KeAC_10       ; go try again

ee56          KeAC_35
ee56 a9 08       LDA #$08          ; 8 bits to do
ee58 85 a5       STA CNTDN         ; set serial bus bit count

ee5a          KeAC_40
ee5a ad 00 dd    LDA IEC_DRAN      ; get VIA 1 DRA, no handshake
ee5d cd 00 dd    CMP IEC_DRAN      ; compare with self
ee60 d0 f8       BNE KeAC_40       ; loop if changing

0000 TRUE     #if C64
ee62 0a          ASL A             ; serial clock into carry
ee63 10 f5       BPL KeAC_40       ; loop while serial clock low
              #endif
0001 FALSE    #if VIC
SKIP             LSR A             ; serial clock into carry
SKIP             BCC KeAC_40       ; loop while serial clock low
SKIP             LSR A             ; serial data into carry
              #endif

ee65 66 a4       ROR TBTCNT        ; shift data bit into receive byte
ee67          KeAC_45
ee67 ad 00 dd    LDA IEC_DRAN      ; get VIA 1 DRA, no handshake
ee6a cd 00 dd    CMP IEC_DRAN      ; compare with self
ee6d d0 f8       BNE KeAC_45       ; loop if changing

0000 TRUE     #if C64
ee6f 0a          ASL A             ; serial clock into carry
ee70 30 f5       BMI KeAC_45       ; loop while serial clock high
              #endif
0001 FALSE    #if VIC
SKIP             LSR A             ; serial clock into carry
SKIP             BCS KeAC_45       ; loop while serial clock high
              #endif

ee72 c6 a5       DEC CNTDN         ; decrement serial bus bit count
ee74 d0 e4       BNE KeAC_40       ; loop if not all done
ee76 20 a0 ee    JSR SET_IEC_DAT   ; set serial data out low

0000 TRUE     #if C64
ee79 24 90       BIT STATUS        ; get serial status byte
ee7b 50 03       BVC KeAC_50       ; branch if no error
              #endif
0001 FALSE    #if VIC
SKIP             LDA STATUS        ; get serial status byte
SKIP             BEQ KeAC_50       ; branch if no error
              #endif

ee7d 20 06 ee    JSR IEC_Delay_CLK_High_DATA_High

ee80          KeAC_50
ee80 a5 a4       LDA TBTCNT        ; get receive byte
ee82 58          CLI               ; enable interrupts
ee83 18          CLC
ee84 60          RTS ;Size  114 [Kernal_ACPTR]

              ; ***********
ee85            CLR_IEC_CLK        ; set serial clock high (clear bit)
              ; ***********

ee85 ad 00 dd    LDA IEC_PCR
ee88 29 ef       AND #~IEC_CLK_BIT
ee8a 8d 00 dd    STA IEC_PCR
ee8d 60          RTS ;Size    9 [CLR_IEC_CLK]

              ; ***********
ee8e            SET_IEC_CLK        ; set serial clock low (set bit)
              ; ***********

ee8e ad 00 dd    LDA IEC_PCR
ee91 09 10       ORA #IEC_CLK_BIT
ee93 8d 00 dd    STA IEC_PCR
ee96 60          RTS ;Size    9 [SET_IEC_CLK]

0000 TRUE     #if C64

              ; ***********
ee97            CLR_IEC_DAT        ; set serial data high (clear bit)
              ; ***********

ee97 ad 00 dd    LDA IEC_PCR
ee9a 29 df       AND #~IEC_DAT_BIT
ee9c 8d 00 dd    STA IEC_PCR
ee9f 60          RTS ;Size    9 [CLR_IEC_DAT]

              ; ***********
eea0            SET_IEC_DAT        ; set serial data low (set bit)
              ; ***********

eea0 ad 00 dd    LDA IEC_PCR
eea3 09 20       ORA #IEC_DAT_BIT
eea5 8d 00 dd    STA IEC_PCR
eea8 60          RTS ;Size    9 [SET_IEC_DAT]

              ; ***********
eea9            GET_IEC_CLK        ; set serial clock
              ; ***********

eea9 ad 00 dd    LDA IEC_PCR
eeac cd 00 dd    CMP IEC_PCR
eeaf d0 f8       BNE GET_IEC_CLK
eeb1 0a          ASL A             ; C = data   bit 7 = clock
eeb2 60          RTS ;Size   10 [GET_IEC_CLK]

              #endif

              ; ********
eeb3            WAIT_1MS           ; wait one millesecond
              ; ********

0000 TRUE     #if C64
eeb3 8a          TXA
eeb4 a2 b8       LDX #$B8

eeb6          W1MS_10
eeb6 ca          DEX
eeb7 d0 fd       BNE W1MS_10
eeb9 aa          TAX
eeba 60          RTS ;Size    8 [WAIT_1MS]
              #endif

0001 FALSE    #if VIC
SKIP             LDA #$04          ; set for 1024 cycles
SKIP             STA VIA2_T2CH     ; set VIA 2 T2C_h
SKIP          
SKIP          W1MS_20
SKIP             LDA IEC_IFR       ; get VIA 2 IFR
SKIP             AND #$20          ; mask T2 interrupt
SKIP             BEQ W1MS_20      ; loop until T2 interrupt
SKIP             RTS
              #endif

              ; ******************
eebb            RS232_NMI_Transmit
              ; ******************

eebb a5 b4       LDA BITTS         ; get RS232 bit count
eebd f0 47       BEQ RS232_Setup_Next_Byte_To_Send
eebf 30 3f       BMI RTra_40       ; if negative go do stop bit(s)
eec1 46 b6       LSR RODATA        ; shift RS232 output byte buffer
eec3 a2 00       LDX #$00          ; set $00 for bit = 0
eec5 90 01       BCC RTra_05       ; branch if bit was 0
eec7 ca          DEX               ; set $FF for bit = 1

eec8          RTra_05
eec8 8a          TXA               ; copy bit to A
eec9 45 bd       EOR ROPRTY        ; EOR with RS232 parity byte
eecb 85 bd       STA ROPRTY        ; save RS232 parity byte
eecd c6 b4       DEC BITTS         ; decrement RS232 bit count
eecf f0 06       BEQ RTra_15       ; if RS232 bit count now zero go do parity bit

eed1          RTra_10
eed1 8a          TXA               ; copy bit to A
eed2 29 04       AND #RS232_C_BIT  ; mask for CB2 control bit
eed4 85 b5       STA NXTBIT        ; save RS232 next bit to send
eed6 60          RTS ;Size   28 [RS232_NMI_Transmit]

eed7          RTra_15
eed7 a9 20       LDA #$20          ; mask 00x0 0000, parity enable bit
eed9 2c 94 02    BIT M51CDR        ; test pseudo 6551 command register
eedc f0 14       BEQ RTra_30       ; branch if parity disabled
eede 30 1c       BMI RTra_35       ; branch if fixed mark or space parity
eee0 70 14       BVS RTra_32       ; branch if even parity
eee2 a5 bd       LDA ROPRTY        ; get RS232 parity byte
eee4 d0 01       BNE RTra_25       ; if parity not zero leave parity bit = 0

eee6          RTra_20
eee6 ca          DEX               ; make parity bit = 1

eee7          RTra_25
eee7 c6 b4       DEC BITTS         ; decrement RS232 bit count, 1 stop bit
eee9 ad 93 02    LDA M51CTR        ; get pseudo 6551 control register
eeec 10 e3       BPL RTra_10       ; if 1 stop bit save parity bit and exit
eeee c6 b4       DEC BITTS         ; decrement RS232 bit count, 2 stop bits
eef0 d0 df       BNE RTra_10       ; save bit and exit, branch always

eef2          RTra_30
eef2 e6 b4       INC BITTS         ; increment RS232 bit count, = -1 stop bit
eef4 d0 f0       BNE RTra_20       ; set stop bit = 1 and exit

eef6          RTra_32
eef6 a5 bd       LDA ROPRTY        ; get RS232 parity byte
eef8 f0 ed       BEQ RTra_25       ; if parity zero leave parity bit = 0
eefa d0 ea       BNE RTra_20       ; else make parity bit = 1, branch always

eefc          RTra_35
eefc 70 e9       BVS RTra_25       ; if fixed space parity leave parity bit = 0
eefe 50 e6       BVC RTra_20       ; else fixed mark parity make parity bit = 1, branch always

              ; decrement stop bit count, set stop bit = 1 and exit. $FF is one stop
              ; bit, $FE is two stop bits

ef00          RTra_40
ef00 e6 b4       INC BITTS         ; decrement RS232 bit count
ef02 a2 ff       LDX #$FF          ; set stop bit = 1
ef04 d0 cb       BNE RTra_10       ; save stop bit and exit, branch always

              ; *****************************
ef06            RS232_Setup_Next_Byte_To_Send
              ; *****************************

ef06 ad 94 02    LDA M51CDR        ; get 6551 pseudo command register
ef09 4a          LSR A             ; handshake bit inot Cb
ef0a 90 07       BCC RSNB_10       ; branch if 3 line interface

0000 TRUE     #if C64
ef0c 2c 01 dd    BIT RS2_DSR_CTS
              #endif
0001 FALSE    #if VIC
SKIP             BIT $9120         ; test VIA 2 DRB, this is wrong
              #endif

ef0f 10 1d       BPL RS232_No_DSR_Signal
ef11 50 1e       BVC RNDS_10      ; if CTS = 0 set CTS signal not present and exit

ef13          RSNB_10
ef13 a9 00       LDA #0
ef15 85 bd       STA ROPRTY        ; clear RS232 parity byte
ef17 85 b5       STA NXTBIT        ; clear RS232 next bit to send
ef19 ae 98 02    LDX BITNUM        ; get number of bits to be sent/received
ef1c 86 b4       STX BITTS         ; set RS232 bit count
ef1e ac 9d 02    LDY RODBS         ; get index to Tx buffer start
ef21 cc 9e 02    CPY RODBE         ; compare with index to Tx buffer end
ef24 f0 13       BEQ RNDS_20      ; if all done go disable T1 interrupt and return
ef26 b1 f9       LDA (TXPTR),Y     ; else get byte from buffer
ef28 85 b6       STA RODATA        ; save to RS232 output byte buffer
ef2a ee 9d 02    INC RODBS         ; increment index to Tx buffer start
ef2d 60          RTS ;Size   40 [RS232_Setup_Next_Byte_To_Send]

              ; *******************
ef2e            RS232_No_DSR_Signal
              ; *******************

ef2e a9 40       LDA #$40          ; set DSR signal not present
ef30 2c          .byte   $2C

ef31          RNDS_10
ef31 a9 10       LDA #$10          ; set CTS signal not present
ef33 0d 97 02    ORA RSSTAT        ; OR with RS232 status register
ef36 8d 97 02    STA RSSTAT        ; save RS232 status register

              ; disable T1 interrupt

ef39          RNDS_20

0000 TRUE     #if C64
ef39 a9 01       LDA #1

ef3b          RNDS_30
ef3b 8d 0d dd    STA CIA2_ICR
ef3e 4d a1 02    EOR ENABL
ef41 09 80       ORA #$80
ef43 8d a1 02    STA ENABL
ef46 8d 0d dd    STA CIA2_ICR
              #endif
0001 FALSE    #if VIC
SKIP             LDA #$40          ; disable T1 interrupt
SKIP             STA VIA1_IER      ; set VIA 1 IER
              #endif

ef49 60          RTS ;Size   28 [RS232_No_DSR_Signal]

              ; *******************
ef4a            RS232_Set_Data_Bits
              ; *******************

ef4a a2 09       LDX #$09          ; set bit count to 9, 8 data + 1 stop bit
ef4c a9 20       LDA #$20          ; mask for 8/7 data bits
ef4e 2c 93 02    BIT M51CTR        ; test pseudo 6551 control register
ef51 f0 01       BEQ RSDB_10       ; branch if 8 bits
ef53 ca          DEX               ; else decrement count for 7 data bits

ef54          RSDB_10
ef54 50 02       BVC RSDB_20       ; branch if 7 bits
ef56 ca          DEX               ; else decrement count ..
ef57 ca          DEX               ; .. for 5 data bits

ef58          RSDB_20
ef58 60          RTS ;Size   15 [RS232_Set_Data_Bits]

              ; *****************
ef59            RS232_NMI_Receive
              ; *****************

ef59 a6 a9       LDX RINONE        ; get start bit check flag
ef5b d0 33       BNE RRec_25       ; branch if no start bit received
ef5d c6 a8       DEC BITCI         ; decrement receiver bit count in
ef5f f0 36       BEQ RRec_30
ef61 30 0d       BMI RRec_15
ef63 a5 a7       LDA INBIT
ef65 45 ab       EOR RIPRTY
ef67 85 ab       STA RIPRTY
ef69 46 a7       LSR INBIT         ; shift receiver input bit temporary storage
ef6b 66 aa       ROR RIDATA

ef6d          RRec_05
ef6d 60          RTS ;Size   21 [RS232_NMI_Receive]

ef6e          RRec_10
ef6e c6 a8       DEC BITCI         ; decrement receiver bit count in

ef70          RRec_15
ef70 a5 a7       LDA INBIT         ; get receiver input bit temporary storage
ef72 f0 67       BEQ RRec_65
ef74 ad 93 02    LDA M51CTR        ; get pseudo 6551 control register
ef77 0a          ASL A
ef78 a9 01       LDA #$01
ef7a 65 a8       ADC BITCI         ; add receiver bit count in
ef7c d0 ef       BNE RRec_05

ef7e          RRec_20
ef7e a9 90       LDA #$90          ; enable CB1 interrupt
ef80 8d 0d dd    STA RS2_IRQ_REG   ; set VIA 1 IER
0000 TRUE     #if C64
ef83 0d a1 02    ORA ENABL
ef86 8d a1 02    STA ENABL
ef89 85 a9       STA RINONE
ef8b a9 02       LDA #2
ef8d 4c 3b ef    JMP RNDS_30
              #endif
0001 FALSE    #if VIC
SKIP             STA RINONE        ; set start bit check flag, set no start bit received
SKIP             LDA #$20          ; disable T2 interrupt
SKIP             STA RS2_IRQ_REG   ; set VIA 1 IER
SKIP             RTS
              #endif

ef90          RRec_25
ef90 a5 a7       LDA INBIT         ; get receiver input bit temporary storage
ef92 d0 ea       BNE RRec_20

0000 TRUE     #if C64
ef94 4c d3 e4    JMP Je4d3
              #endif
0001 FALSE    #if VIC
SKIP             STA RINONE        ; set start bit check flag, set start bit received
SKIP             RTS
              #endif

ef97          RRec_30
ef97 ac 9b 02    LDY RIDBE         ; get index to Rx buffer end
ef9a c8          INY
ef9b cc 9c 02    CPY RIDBS         ; compare with index to Rx buffer start
ef9e f0 2a       BEQ RRec_50       ; if buffer full go do Rx overrun error
efa0 8c 9b 02    STY RIDBE         ; save index to Rx buffer end
efa3 88          DEY               ; decrement index
efa4 a5 aa       LDA RIDATA        ; get assembled byte
efa6 ae 98 02    LDX BITNUM        ; get bit count

efa9          RRec_35
efa9 e0 09       CPX #$09          ; compare with byte + stop
efab f0 04       BEQ RRec_40       ; branch if all nine bits received
efad 4a          LSR A             ; else shift byte
efae e8          INX               ; increment bit count
efaf d0 f8       BNE RRec_35       ; loop, branch always

efb1          RRec_40
efb1 91 f7       STA (RXPTR),Y     ; save received byte to Rx buffer
efb3 a9 20       LDA #$20          ; mask 00x0 0000, parity enable bit
efb5 2c 94 02    BIT M51CDR        ; test pseudo 6551 command register
efb8 f0 b4       BEQ RRec_10       ; branch if parity disabled
efba 30 b1       BMI RRec_05       ; branch if mark or space parity
efbc a5 a7       LDA INBIT         ; get receiver input bit temporary storage
efbe 45 ab       EOR RIPRTY
efc0 f0 03       BEQ RRec_45
efc2 70 a9       BVS RRec_05
efc4 2c          .byte   $2C

efc5          RRec_45
efc5 50 a6       BVC RRec_05
efc7 a9 01       LDA #$01          ; set Rx parity error
efc9 2c          .byte   $2C

efca          RRec_50
efca a9 04       LDA #$04          ; set Rx overrun error
efcc 2c          .byte   $2C

efcd          RRec_55
efcd a9 80       LDA #$80          ; Rx break error
efcf 2c          .byte   $2C

efd0          RRec_60
efd0 a9 02       LDA #$02          ; Rx frame error
efd2 0d 97 02    ORA RSSTAT        ; OR with RS232 status byte
efd5 8d 97 02    STA RSSTAT        ; save RS232 status byte
efd8 4c 7e ef    JMP RRec_20

efdb          RRec_65
efdb a5 aa       LDA RIDATA
efdd d0 f1       BNE RRec_60      ; if ?? do frame error
efdf f0 ec       BEQ RRec_55      ; else do break error, branch always

efe1          RRec_70
0001 FALSE    #if VIC
SKIP             JMP Illegal_Jiffy_Device
              #endif

              ; ============
efe1            RS232_CHKOUT
              ; ============

efe1 85 9a       STA DFLTO         ; save output device number
efe3 ad 94 02    LDA M51CDR        ; get pseudo 6551 command register
efe6 4a          LSR A             ; shift handshake bit to carry
efe7 90 29       BCC RSSN_10       ; branch if 3 line interface
efe9 a9 02       LDA #$02          ; mask for RTS out
efeb 2c 01 dd    BIT RS2_DSR_CTS   ; test VIA 1 DRB
efee 10 1d       BPL RS232_Set_Status_No_Signal
eff0 d0 20       BNE RSSN_10       ; if RTS = 1 just exit

eff2          RCHO_10
0000 TRUE     #if C64
eff2 ad a1 02    LDA ENABL
eff5 29 02       AND #2
              #endif
0001 FALSE    #if VIC
SKIP             LDA VIA1_IER      ; get VIA 1 IER
SKIP             AND #$30          ; mask 00xx 0000, T2 and CB1 interrupts
              #endif
eff7 d0 f9       BNE RCHO_10       ; loop while either enabled

eff9          RCHO_20
eff9 2c 01 dd    BIT RS2_DSR_CTS   ; test VIA 1 DRB
effc 70 fb       BVS RCHO_20       ; loop while CTS high
effe ad 01 dd    LDA RS2_DSR_CTS   ; get VIA 1 DRB
f001 09 02       ORA #$02          ; set RTS high
f003 8d 01 dd    STA RS2_DSR_CTS   ; save VIA 1 DRB

f006          RCHO_30
f006 2c 01 dd    BIT RS2_DSR_CTS   ; test VIA 1 DRB
f009 70 07       BVS RSSN_10       ; exit if CTS high
f00b 30 f9       BMI RCHO_30       ; loop while DSR high

              ; **************************
f00d            RS232_Set_Status_No_Signal
              ; **************************

0000 TRUE     #if C64
f00d a9 40       LDA #$40
f00f 8d 97 02    STA RSSTAT
              #endif
0001 FALSE    #if VIC
SKIP             JSR RS232_No_DSR_Signal
              #endif
f012          RSSN_10
f012 18          CLC               ; flag ok
f013 60          RTS ;Size    7 [RS232_Set_Status_No_Signal]

              ; ************************
f014            RS232_Put_Byte_To_Buffer
              ; ************************

0000 TRUE     #if C64
f014 20 28 f0    JSR RPBB_20

f017          RPBB_10
              #endif
f017 ac 9e 02    LDY RODBE         ; get index to Tx buffer end
f01a c8          INY               ; + 1
f01b cc 9d 02    CPY RODBS         ; compare with index to Tx buffer start
f01e f0 f4       BEQ RS232_Put_Byte_To_Buffer
f020 8c 9e 02    STY RODBE         ; set index to Tx buffer end
f023 88          DEY               ; index to available buffer byte
0000 TRUE     #if C64
f024 a5 9e       LDA PTR1
              #endif
f026 91 f9       STA (TXPTR),Y     ; save byte to buffer

f028          RPBB_20
0000 TRUE     #if C64
f028 ad a1 02    LDA ENABL
f02b 4a          LSR A
f02c b0 1e       BCS RPBB_40
f02e a9 10       LDA #$10
f030 8d 0e dd    STA CIA2_CRA
              #endif
0001 FALSE    #if VIC
SKIP             BIT VIA1_IER      ; test VIA 1 IER
SKIP             BVC RPBB_30       ; branch if T1 not enabled
SKIP             RTS
              #endif

f033          RPBB_30
f033 ad 99 02    LDA BAUDOF        ; get baud rate bit time low byte
f036 8d 04 dd    STA RS2_TIM_LOW   ; set VIA 1 T1C_l
f039 ad 9a 02    LDA BAUDOF+1      ; get baud rate bit time high byte
f03c 8d 05 dd    STA RS2_TIM_HIG   ; set VIA 1 T1C_h
0000 TRUE     #if C64
f03f a9 81       LDA #$81
f041 20 3b ef    JSR RNDS_30
f044 20 06 ef    JSR RS232_Setup_Next_Byte_To_Send
f047 a9 11       LDA #$11
f049 8d 0e dd    STA CIA2_CRA

f04c          RPBB_40
f04c 60          RTS ;Size   57 [RS232_Put_Byte_To_Buffer]
              #endif
0001 FALSE    #if VIC
SKIP             LDA #$C0          ; enable T1 interrupt
SKIP             STA VIA1_IER      ; set VIA 1 IER
SKIP             JMP RS232_Setup_Next_Byte_To_Send
              #endif

              ; ===========
f04d            RS232_CHKIN
              ; ===========

f04d 85 99       STA DFLTN         ; save input device number
f04f ad 94 02    LDA M51CDR        ; get pseudo 6551 command register
f052 4a          LSR A
f053 90 28       BCC RCHI_40       ; branch if 3 line interface
f055 29 08       AND #$08          ; mask duplex bit, pseudo 6551 command is >> 1
f057 f0 24       BEQ RCHI_40       ; branch if full duplex
f059 a9 02       LDA #2
f05b 2c 01 dd    BIT RS2_DSR_CTS   ; test VIA 1 DRB
f05e 10 ad       BPL RS232_Set_Status_No_Signal
f060 f0 22       BEQ RCHI_50

f062          RCHI_10
0000 TRUE     #if C64
f062 ad a1 02    LDA ENABL
f065 4a          LSR A
f066 b0 fa       BCS RCHI_10
              #endif
0001 FALSE    #if VIC
SKIP             BIT VIA1_IER      ; test VIA 1 IER
SKIP             BVS RCHI_10       ; loop while T1 interrupt enabled
              #endif
f068 ad 01 dd    LDA RS2_DSR_CTS   ; get VIA 1 DRB
f06b 29 fd       AND #$FD          ; mask xxxx xx0x, clear RTS out
f06d 8d 01 dd    STA RS2_DSR_CTS   ; save VIA 1 DRB

f070          RCHI_20
f070 ad 01 dd    LDA RS2_DSR_CTS   ; get VIA 1 DRB
f073 29 04       AND #$04          ; mask xxxx x1xx, DTR
f075 f0 f9       BEQ RCHI_20       ; loop while DTR low

f077          RCHI_30
f077 a9 90       LDA #$90          ; enable CB1 interrupt
0000 TRUE     #if C64
f079 18          CLC
f07a 4c 3b ef    JMP RNDS_30

f07d          RCHI_40
f07d ad a1 02    LDA ENABL
f080 29 12       AND #$12
f082 f0 f3       BEQ RCHI_30
              #endif
0001 FALSE    #if VIC
SKIP             STA VIA1_IER      ; set VIA 1 IER
              #endif

f084          RCHI_50
f084 18          CLC
f085 60          RTS ;Size  114 [RS232_Put_Byte_To_Buffer]

0001 FALSE    #if VIC
SKIP          RCHI_40
SKIP             LDA VIA1_IER      ; get VIA 1 IER
SKIP             AND #$30          ; mask 0xx0 0000, T1 and T2 interrupts
SKIP             BEQ RCHI_30       ; if both interrupts disabled go enable CB1
SKIP             CLC
SKIP             RTS
              #endif

              ; **************************
f086            RS232_Get_Byte_From_Buffer
              ; **************************

0000 TRUE     #if C64
f086 ad 97 02    LDA RSSTAT
              #endif
f089 ac 9c 02    LDY RIDBS         ; get index to Rx buffer start
f08c cc 9b 02    CPY RIDBE         ; compare with index to Rx buffer end
f08f f0 0b       BEQ RGBB_10       ; return null if buffer empty
0000 TRUE     #if C64
f091 29 f7       AND #$F7
f093 8d 97 02    STA RSSTAT
              #endif
f096 b1 f7       LDA (RXPTR),Y     ; get byte from Rx buffer
f098 ee 9c 02    INC RIDBS         ; increment index to Rx buffer start
f09b 60          RTS ;Size   22 [RS232_Get_Byte_From_Buffer]

f09c          RGBB_10
0000 TRUE     #if C64
f09c 09 08       ORA #8
f09e 8d 97 02    STA RSSTAT
              #endif
f0a1 a9 00       LDA #$00          ; return null
f0a3 60          RTS ;Size   30 [RS232_Get_Byte_From_Buffer]

              ; **********
f0a4            RS232_Stop
              ; **********

f0a4 48          PHA
0000 TRUE     #if C64
f0a5 ad a1 02    LDA ENABL
f0a8 f0 11       BEQ RSTP_30

f0aa          RSTP_10
f0aa ad a1 02    LDA ENABL
f0ad 29 03       AND #3
f0af d0 f9       BNE RSTP_10
              #endif
0001 FALSE    #if VIC
SKIP             LDA RS2_IRQ_REG   ; get VIA 1 IER
SKIP             BEQ RSTP_30       ; branch if no interrupts enabled. this branch will
SKIP          
SKIP          RSTP_20
SKIP             LDA RS2_IRQ_REG   ; get VIA 1 IER
SKIP             AND #$60          ; mask 0xx0 0000, T1 and T2 interrupts
SKIP             BNE RSTP_20       ; loop if T1 or T2 active
              #endif
f0b1 a9 10       LDA #$10          ; disable CB1 interrupt
f0b3 8d 0d dd    STA RS2_IRQ_REG   ; set VIA 1 IER
0000 TRUE     #if C64
f0b6 a9 00       LDA #0
f0b8 8d a1 02    STA ENABL
              #endif

f0bb          RSTP_30
f0bb 68          PLA
f0bc 60          RTS ;Size   25 [RS232_Stop]

f0bd 0d 49 2f Msg_Start     .byte "\rI/O ERROR #"^
f0c9 0d 53 45 Msg_Searching .byte "\rSEARCHING "^
f0d4 46 4f 52 Msg_FOR       .byte "FOR "^

0001 FALSE    #if JIFFY
0000 TRUE     #if C64
SKIP          ; *******************
SKIP            Jiffy_Clear_Sprites
SKIP          ; *******************
SKIP          
SKIP             LDA #0
SKIP             STA VIC_SPR_ENA
SKIP          
SKIP          JCS_10
SKIP             ADC #1
SKIP             BNE JCS_10
SKIP             RTS
              #endif
SKIP          
SKIP          ; ****************
SKIP            Jiffy_CHKIN_PTR2
SKIP          ; ****************
SKIP          
SKIP             LDA PTR2
SKIP          
SKIP          ; ***********
SKIP            Jiffy_CHKIN
SKIP          ; ***********
SKIP          
SKIP             PHA
SKIP             JSR CLRCHN
SKIP             PLA
SKIP             TAX
SKIP             JMP CHKIN
SKIP          
SKIP          ; *************
SKIP            Jiffy_CLR_DAT
SKIP          ; *************
SKIP          
0001 FALSE    #if VIC
SKIP             SEI
              #endif
SKIP             LDA #0
SKIP             STA TSFCNT        ; clear jiffy flag
SKIP             JMP CLR_IEC_DAT   ; continue with IEC routine
SKIP          
SKIP          ; ************************
SKIP            Jiffy_Send_Drive_Command
SKIP          ; ************************
SKIP          
SKIP             TXA
SKIP             PHA
SKIP             JSR JiDi_60
SKIP             PLA
SKIP             TAX
SKIP          Bf0fb
SKIP             LDA Jiffy_Transfer_01,X
SKIP             JSR CHROUT
SKIP             INX
SKIP             DEY
SKIP             BNE Bf0fb
SKIP             RTS
SKIP          
0001 FALSE    #if VIC
SKIP          ; **************
SKIP            Back_To_Prompt
SKIP          ; **************
SKIP          
SKIP             TXA
SKIP             BMI JAAB_10
SKIP             JMP Default_Error
SKIP          
SKIP          JAAB_10
SKIP             JMP Basic_Ready
              #endif
SKIP          
              #else
f0d8 0d 50 52 Msg_Play      .byte "\rPRESS PLAY ON TAPE"^
f0eb 50 52 45 Msg_Record    .byte "PRESS RECORD & PLAY ON TAPE"^
              #endif
f106 0d 4c 4f Msg_Loading   .byte "\rLOADING"^
f10e 0d 53 41 Msg_Saving    .byte "\rSAVING "^
f116 0d 56 45 Msg_Verifying .byte "\rVERIFYING"^
f120 0d 46 4f Msg_Found     .byte "\rFOUND "^
f127 0d 4f 4b Msg_ok        .byte "\rOK\r"^

              ; ==================
f12b            Display_Direct_Msg
              ; ==================

f12b 24 9d       BIT MSGFLG        ; test message mode flag
f12d 10 0d       BPL DDM_10        ; exit if control messages off

              ; *************************
f12f            Display_Kernal_IO_Message
              ; *************************

f12f b9 bd f0    LDA Msg_Start,Y    ; get byte from message table
f132 08          PHP               ; save status
f133 29 7f       AND #$7F          ; clear b7
f135 20 cc ff    JSR CHROUT        ; Output a character
f138 c8          INY
f139 28          PLP               ; restore status
f13a 10 f3       BPL Display_Kernal_IO_Message

f13c          DDM_10
f13c 18          CLC
f13d 60          RTS ;Size   15 [Display_Kernal_IO_Message]

              ; ************
f13e            Kernal_GETIN
              ; ************

f13e a5 99       LDA DFLTN         ; get input device number
f140 d0 08       BNE KeGE_10       ; branch if not keyboard
f142 a5 c6       LDA NDX           ; get keyboard buffer length
0000 TRUE     #if C64
f144 f0 0f       BEQ KeGE_20
              #endif
0001 FALSE    #if VIC
SKIP             BEQ IGB_20      ; if buffer empty go flag no byte and return
              #endif
f146 78          SEI               ; disable inter/rupts
f147 4c b4 e5    JMP Get_Char_From_Keyboard_Buffer

f14a          KeGE_10
f14a c9 02       CMP #$02          ; compare device with RS232 device
f14c d0 18       BNE CHRI_05      ; branch if not RS232 device

              ; **************
f14e            RS232_Get_Byte
              ; **************

f14e 84 97       STY TEMPX         ; save Y
f150 20 86 f0    JSR RS232_Get_Byte_From_Buffer
f153 a4 97       LDY TEMPX         ; restore Y

f155          KeGE_20
f155 18          CLC               ; flag no error
f156 60          RTS ;Size    9 [RS232_Get_Byte]

              ; ************
f157            Kernal_CHRIN       ; Get a character from the input channel
              ; ************

f157 a5 99       LDA DFLTN         ; get input device number
0001 FALSE    #if JIFFY
SKIP             BNE Jiffy_f1a9
              #else
f159 d0 0b       BNE CHRI_05       ; if it's not the keyboard continue
              #endif
f15b a5 d3       LDA CSRIDX        ; get cursor column
f15d 85 ca       STA ICRCOL        ; set input cursor column
f15f a5 d6       LDA TBLX          ; get cursor row
f161 85 c9       STA ICRROW        ; set input cursor row
f163 4c 32 e6    JMP CHRIN_Keyboard_Or_Screen

              ; the input device was not the keyboard

f166          CHRI_05
f166 c9 03       CMP #$03          ; compare device number with screen
f168 d0 09       BNE CHRI_10       ; if it's not the screen continue

f16a          CHRI_07
f16a 85 d0       STA INSRC         ; input from keyboard or screen, $xx = screen,
f16c a5 d5       LDA LINLEN        ; get current screen line length
f16e 85 c8       STA INDX          ; save input [EOL] pointer
f170 4c 32 e6    JMP CHRIN_Keyboard_Or_Screen

f173          CHRI_10
f173 b0 38       BCS IEC_Get_Byte

              ; the input device is < the screen do must be the RS232 or tape device

f175 c9 02       CMP #$02          ; compare device with RS232 device
f177 f0 3f       BEQ RS232_Read_Byte

              ; else there's only the tape device left ..

0001 FALSE    #if JIFFY
SKIP          ; **********************
SKIP            Jiffy_ACPTR_Load_Check
SKIP          ; **********************
SKIP          
SKIP             JSR Jiffy_ACPTR   ; get byte from serial bus
SKIP             PHA               ; temp store on stack
SKIP             BIT TSFCNT        ; test bit6, if serial device is a JiffyDOS device
SKIP             BVC JALC_20       ; no JiffyDOS device
SKIP             CPX #0            
SKIP             BNE JALC_10
SKIP             LDA MEMUSS+1      ; load address high byte
SKIP          
SKIP          JALC_10
SKIP             CMP #4            ; load address < $0400 ?
SKIP             BCC JALC_20       ; don't load with Jiffy
SKIP             LDY #0
SKIP             LDA (FNADR),Y     ; get first character of filename
SKIP             CMP #'$'          ; is it a directory load ?
SKIP             BEQ JALC_20       ; yes, don't load with Jiffy
SKIP             INC SA
SKIP             JSR Jiffy_Talk_TkSA
SKIP             DEC SA
SKIP             ASL TSFCNT        ; continue with Jiffy load
SKIP          
SKIP          JALC_20
SKIP             PLA               ; recover read byte
SKIP             RTS
SKIP          
SKIP          ; ***************
SKIP            Flag_Read_Error
SKIP          ; ***************
SKIP          
SKIP            LDA #16
SKIP            JMP Ora_Status
SKIP          
SKIP          ; *****
SKIP            Vf1a3
SKIP          ; *****
SKIP          
SKIP            .WORD Back_To_Prompt
SKIP            .WORD Default_Warmstart
SKIP            .WORD Default_Tokenize
SKIP          
SKIP          ; **********
SKIP            Jiffy_f1a9
SKIP          ; **********
SKIP          
SKIP             CMP #4
SKIP             BCC CHRI_05
SKIP          
              #else
f179 86 97       STX TEMPX         ; save X
f17b 20 99 f1    JSR TAPE_Get_Byte
f17e b0 16       BCS CHRI_25       ; exit if error
f180 48          PHA               ; save byte
f181 20 99 f1    JSR TAPE_Get_Byte
f184 b0 0d       BCS CHRI_20       ; exit if error
f186 d0 05       BNE CHRI_15       ; branch if end reached
f188 a9 40       LDA #$40          ; set [EOF] bit
f18a 20 16 fe    JSR Ora_Status

f18d          CHRI_15
f18d c6 a6       DEC BUFPNT        ; decrement tape buffer index
f18f a6 97       LDX TEMPX         ; restore X
f191 68          PLA               ; restore saved byte
f192 60          RTS ;Size   60 [Kernal_CHRIN]

              ; error exit from input character

f193          CHRI_20
f193 aa          TAX               ; copy error byte ??
f194 68          PLA               ; dump saved byte
f195 8a          TXA               ; restore error byte ??
f196          CHRI_25
f196 a6 97       LDX TEMPX         ; restore X
f198 60          RTS ;Size   66 [Kernal_CHRIN]

              ; *************
f199            TAPE_Get_Byte
              ; *************

f199 20 07 f8    JSR TAPE_Advance_Buffer_Pointer
f19c d0 0b       BNE TGB_05        ; if not end get next byte and exit
f19e 20 3b f8    JSR TAPE_Init_Read
f1a1 b0 11       BCS IGB_30      ; exit if error flagged
f1a3 a9 00       LDA #0
f1a5 85 a6       STA BUFPNT        ; clear tape buffer index
f1a7 f0 f0       BEQ TAPE_Get_Byte ; branch always

f1a9          TGB_05
f1a9 b1 b2       LDA (TAPE1),Y     ; get next byte from buffer
f1ab 18          CLC               ; flag no error
f1ac 60          RTS ;Size   20 [TAPE_Get_Byte]

              #endif               ; JIFFY

              ; * = $f1ad

              ; ============
f1ad            IEC_Get_Byte
              ; ============

f1ad a5 90       LDA STATUS        ; get serial status byte
f1af f0 04       BEQ IGB_40        ; if no errors flagged go input byte and return

f1b1          IGB_10
f1b1 a9 0d       LDA #$0D          ; else return [EOL]

f1b3          IGB_20
f1b3 18          CLC               ; flag no error

f1b4          IGB_30
f1b4 60          RTS ;Size   28 [TAPE_Get_Byte]

f1b5          IGB_40
0001 FALSE    #if JIFFY
SKIP             JMP Jiffy_ACPTR   ; input a byte from the serial bus and return
              #else
f1b5 4c 13 ee    JMP Kernal_ACPTR
              #endif

              ; ===============
f1b8            RS232_Read_Byte
              ; ===============

f1b8 20 4e f1    JSR RS232_Get_Byte
0000 TRUE     #if C64
f1bb b0 f7       BCS IGB_30
              #endif
0001 FALSE    #if VIC
SKIP             BCS RRB_Ret       ; branch if error, this doesn't get taken as the last
              #endif
f1bd c9 00       CMP #$00          ; compare with null
0000 TRUE     #if C64
f1bf d0 f2       BNE IGB_20
f1c1 ad 97 02    LDA RSSTAT
f1c4 29 60       AND #$60
f1c6 d0 e9       BNE IGB_10
              #endif
f1c8 f0 ee       BEQ RS232_Read_Byte      ; loop if null
0001 FALSE    #if VIC
SKIP             CLC               ; flag no error
SKIP          RRB_Ret
SKIP             RTS
              #endif

              ; *************
f1ca            Kernal_CHROUT      ; Output a character
              ; *************

f1ca 48          PHA               ; save the character to send
f1cb a5 9a       LDA DFLTO         ; get output device number
f1cd c9 03       CMP #$03          ; compare device number with screen
f1cf d0 04       BNE KeCO_10       ; if output device not screen continue

              ; the output device is the screen

f1d1 68          PLA               ; restore character to send
f1d2 4c 16 e7    JMP Screen_CHROUT ; output character and return

              ; the output device was not the screen

f1d5          KeCO_10
f1d5 90 04       BCC KeCO_20       ; if output device < screen continue

              ; the output device was > screen so it is a serial bus device

f1d7 68          PLA               ; restore character to send
f1d8 4c dd ed    JMP Kernal_CIOUT  ; output a byte to the serial bus and return

              ; the output device is < screen

f1db          KeCO_20
0000 TRUE     #if C64
f1db 4a          LSR A
              #endif
0001 FALSE    #if VIC
SKIP             CMP #$02          ; compare the device with RS232 device
SKIP             BEQ RS232_Send_Byte
              #endif

              ; else the output device is the cassette

f1dc 68          PLA               ; restore the character to send

              ; **************
f1dd            TAPE_Send_Byte
              ; **************

0001 FALSE    #if ![VIC & JIFFY]
SKIP             STA PTR1          ; save character to character buffer
0001 FALSE    #if VIC
SKIP             PHA               ; save A
              #endif
SKIP             TXA               ; copy X
SKIP             PHA               ; save X
SKIP             TYA               ; copy Y
SKIP             PHA               ; save Y
              #endif
0000 TRUE     #if C64
f1dd 90 23       BCC RS232_Send_Byte
              #endif
0001 FALSE    #if JIFFY
0000 TRUE     #if C64
SKIP             JMP Pop_Dev_Not_Present
              #else
SKIP             JMP Dev_Not_Present
              #endif
SKIP          
SKIP          ; *****************
SKIP            Jiffy_Disk_Status 
SKIP          ; *****************
SKIP          
SKIP             JSR Jiffy_Open_Command_10 
SKIP             JSR Jiffy_CHRIN 
SKIP             CMP #'0'          ; first char of disk status
SKIP             RTS   
SKIP          
SKIP          ; ************************
SKIP            Jiffy_Set_Default_Device 
SKIP          ; ************************
SKIP          
SKIP             JSR Get_Next_Byte_Value
SKIP             STX FA
SKIP             JSR Jiffy_Validate_FA 
SKIP             STX Jiffy_Device
SKIP             RTS   
              #else
f1df 20 07 f8    JSR TAPE_Advance_Buffer_Pointer
f1e2 d0 0e       BNE TASB_10       ; if not end save next byte and exit
f1e4 20 5e f8    JSR Init_Tape_Write
f1e7 b0 0e       BCS TASB_30       ; exit if error
f1e9 a9 02       LDA #$02          ; set data block type ??
f1eb a0 00       LDY #0
f1ed 91 b2       STA (TAPE1),Y     ; save type to buffer ??
f1ef c8          INY
f1f0 84 a6       STY BUFPNT        ; save tape buffer index

f1f2          TASB_10
f1f2 a5 9e       LDA PTR1          ; restore character from character buffer
f1f4 91 b2       STA (TAPE1),Y     ; save to buffer

              #endif
f1f6          TASB_20
0001 FALSE    #if JIFFY & VIC
SKIP             LDA #$fb
SKIP             STA KEYB_COL
SKIP             LDX KEYB_ROW
SKIP             LDA #$f7
SKIP             STA KEYB_COL
SKIP             JMP Jiffy_e9c6
SKIP             .byte 0
              #else
f1f6 18          CLC               ; flag no error

f1f7          TASB_30
f1f7 68          PLA               ; pull Y
f1f8 a8          TAY               ; restore Y
f1f9 68          PLA               ; pull X
f1fa aa          TAX               ; restore X
0000 TRUE     #if C64
f1fb a5 9e       LDA PTR1
              #endif
0001 FALSE    #if VIC
SKIP             PLA               ; restore A
              #endif
f1fd 90 02       BCC TASB_40       ; exit if no error
f1ff a9 00       LDA #$00          ; else clear A
              #endif

f201          TASB_40
f201 60          RTS ;Size   37 [TAPE_Send_Byte]

              ; ===============
f202            RS232_Send_Byte
              ; ===============

0000 TRUE     #if C64
f202 20 17 f0    JSR RPBB_10
f205 4c f6 f1    JMP TASB_20
              #endif
0001 FALSE    #if VIC
SKIP             PLA               ; restore character to send
SKIP             STX TEMPX         ; save X
SKIP             STY PTR1          ; save Y
SKIP             JSR RS232_Put_Byte_To_Buffer
SKIP             LDX TEMPX         ; restore Y
SKIP             LDY PTR1          ; restore X
SKIP             CLC               ; flag ok
SKIP             RTS
              #endif

              ; *************
f208            Kernal_ICHKIN
              ; *************

f208 20 09 f3    JSR Find_File_X
f20b f0 03       BEQ KICH_10       ; branch if file opened
f20d 4c fb f6    JMP File_Not_Open

f210          KICH_10
f210 20 19 f3    JSR Get_LFS
f213 a5 ba       LDA FA            ; get device number
f215 f0 16       BEQ KICH_30       ; if device was keyboard save device #, flag ok and exit
f217 c9 03       CMP #$03          ; compare device number with screen
f219 f0 12       BEQ KICH_30       ; if device was screen save device #, flag ok and exit
f21b b0 14       BCS KICH_40       ; branch if serial bus device
f21d c9 02       CMP #$02          ; compare device with RS232 device
f21f d0 03       BNE KICH_20       ; branch if not RS 232 device
f221 4c 4d f0    JMP RS232_CHKIN

f224          KICH_20
f224 a6 b9       LDX SA            ; get secondary address
f226 e0 60       CPX #$60
f228 f0 03       BEQ KICH_30
f22a 4c 04 f7    JMP Not_Input_File

f22d          KICH_30
f22d 85 99       STA DFLTN         ; save input device number
f22f 18          CLC               ; flag ok
f230 60          RTS ;Size   41 [Kernal_ICHKIN]

f231          KICH_40              ; CHKIN for IEC device
f231 aa          TAX               ; copy device number to X
f232 20 09 ed    JSR Kernal_TALK   ; command a serial bus device to TALK
f235 a5 b9       LDA SA            ; get secondary address
f237 10 06       BPL KICH_50
f239 20 cc ed    JSR IEC_Finish_Send
f23c 4c 42 f2    JMP KICH_60

f23f          KICH_50
f23f 20 c7 ed    JSR Kernal_TKSA   ; send secondary address after TALK

f242          KICH_60
f242 8a          TXA               ; copy device back to A
f243 24 90       BIT STATUS        ; test serial status byte
f245 10 e6       BPL KICH_30       ; if device present save device number and exit
f247 4c 01 f7    JMP Dev_Not_Present      ; do device not present error and return

              ; *************
f24a            Kernal_CHKOUT      ; Open a channel for output
              ; *************

f24a 20 09 f3    JSR Find_File_X
f24d f0 03       BEQ KCHO_10       ; branch if file found
f24f 4c fb f6    JMP File_Not_Open

f252          KCHO_10
f252 20 19 f3    JSR Get_LFS
f255 a5 ba       LDA FA            ; get device number
f257 d0 03       BNE KCHO_30       ; branch if device is not keyboard

f259          KCHO_20
f259 4c 07 f7    JMP Not_Output_File

f25c          KCHO_30
f25c c9 03       CMP #$03          ; compare device number with screen
f25e f0 0f       BEQ KCHO_50       ; if screen save output device number and exit
f260 b0 11       BCS KCHO_60       ; branch if > screen, serial bus device
f262 c9 02       CMP #$02          ; compare device with RS232 device
f264 d0 03       BNE KCHO_40       ; branch if not RS232 device, must be tape
f266 4c e1 ef    JMP RS232_CHKOUT

f269          KCHO_40
f269 a6 b9       LDX SA            ; get secondary address
f26b e0 60       CPX #$60
f26d f0 ea       BEQ KCHO_20       ; if ?? do not output file error and return

f26f          KCHO_50
f26f 85 9a       STA DFLTO         ; save output device number
f271 18          CLC               ; flag ok
f272 60          RTS ;Size   41 [Kernal_CHKOUT]

f273          KCHO_60
f273 aa          TAX               ; copy device number
f274 20 0c ed    JSR Kernal_LISTEN ; command devices on the serial bus to LISTEN
f277 a5 b9       LDA SA            ; get secondary address
f279 10 05       BPL KCHO_70       ; branch if address to send
f27b 20 be ed    JSR IEC_ATN_High
f27e d0 03       BNE KCHO_80       ; branch always

f280          KCHO_70
f280 20 b9 ed    JSR Kernal_SECOND ; send secondary address after LISTEN

f283          KCHO_80
f283 8a          TXA               ; copy device number back to A
f284 24 90       BIT STATUS        ; test serial status byte
f286 10 e7       BPL KCHO_50       ; if device present save output device number and exit
f288 4c 01 f7    JMP Dev_Not_Present      ; else do device not present error and return

              ; ************
f28b            Kernal_CLOSE
              ; ************

f28b 20 0e f3    JSR Find_File_A
f28e f0 02       BEQ KeCL_10       ; if the file is found go close it
f290 18          CLC               ; else the file was closed so just flag ok
f291 60          RTS ;Size    7 [Kernal_CLOSE]

f292          KeCL_10
f292 20 19 f3    JSR Get_LFS
f295 8a          TXA               ; copy file index to A
f296 48          PHA               ; save file index
f297 a5 ba       LDA FA            ; get device number
f299 f0 50       BEQ KeCL_80       ; if $00, keyboard, restore index and close file
f29b c9 03       CMP #3            ; compare device number with screen
f29d f0 4c       BEQ KeCL_80       ; if screen restore index and close file
f29f b0 47       BCS KeCL_70       ; if > screen go do serial bus device close
f2a1 c9 02       CMP #2            ; compare device with RS232 device
f2a3 d0 1d       BNE KeCL_40       ; branch if not RS232 device
f2a5 68          PLA               ; restore file index
f2a6 20 ec f2    JSR Close_File
0000 TRUE     #if C64
f2a9 20 7d f4    JSR ROPN_50
              #endif
0001 FALSE    #if VIC
SKIP             LDA #$7D          ; disable T1, T2, CB1, CB2, SR and CA2
SKIP             STA RS2_IRQ_REG   ; set VIA 1 IER
SKIP             LDA #$06          ; set DTR and RTS high
SKIP             STA RS2_DSR_CTS   ; set VIA 1 DRB
SKIP             LDA #$EE          ; CB2 high, CB1 negative edge, CA2 high, CA1 negative edge
SKIP             STA VIA1_PCR      ; set VIA 1 PCR
              #endif
f2ac 20 21 fe    JSR Read_Memtop
f2af a5 f8       LDA RXPTR+1       ; get RS232 input buffer pointer high byte
f2b1 f0 01       BEQ KeCL_20       ; branch if no RS232 input buffer
f2b3 c8          INY               ; else reclaim RS232 input buffer memory

f2b4          KeCL_20
f2b4 a5 fa       LDA TXPTR+1       ; get RS232 output buffer pointer high byte
f2b6 f0 01       BEQ KeCL_30       ; branch if no RS232 output buffer
f2b8 c8          INY               ; else reclaim RS232 output buffer memory

f2b9          KeCL_30
f2b9 a9 00       LDA #0
f2bb 85 f8       STA RXPTR+1       ; clear RS232 input buffer pointer high byte
f2bd 85 fa       STA TXPTR+1       ; clear RS232 output buffer pointer high byte
f2bf 4c 77 f4    JMP ROPN_45       ; go set top of memory and exit

f2c2          KeCL_40
0001 FALSE    #if JIFFY
SKIP             PLA
SKIP             JMP Illegal_Jiffy_Device
SKIP          
SKIP          ; **************
SKIP            Jiffy_Close_15
SKIP          ; **************
SKIP          
SKIP             JSR CLRCHN
SKIP          
SKIP          Jiffy_Close_6f
SKIP             LDA #$6f
SKIP             JSR Find_File_A
SKIP             BNE ClFi_Ret
SKIP             JMP ClFi_05
SKIP          
0000 TRUE     #if C64
SKIP          ; *****************
SKIP            Jiffy_Test_Device 
SKIP          ; ***************** 
SKIP          
SKIP             STX FA
SKIP          
SKIP          ; *************
SKIP            Jiffy_Test_FA 
SKIP          ; *************
SKIP          
SKIP             TYA   
SKIP             PHA   
SKIP             JSR Jiffy_Open_Command_Channel    ; open 15,x,15
SKIP             JSR JiDi_60    ; set command channel (15) as output
SKIP             PHP   
SKIP             JSR Jiffy_Close_15
SKIP             PLP   
SKIP             PLA   
              #else
SKIP          JTABC
SKIP             .byte $00,$20,$00,$20,$02,$22,$02,$22
SKIP             .byte $00,$20,$00,$20,$02,$22,$02,$22
              #endif
0000 TRUE     #if C64
SKIP             TAY   
SKIP             LDX FA
SKIP             RTS   
SKIP             .byte $f2
              #endif
              #else
f2c2 a5 b9       LDA SA            ; get secondary address
f2c4 29 0f       AND #$0F
f2c6 f0 23       BEQ KeCL_80
f2c8 20 ca f7    JSR TAPE_Get_Buffer_Address
f2cb a9 00       LDA #0
0000 TRUE     #if C64
f2cd 38          SEC
              #endif
f2ce 20 dd f1    JSR TAPE_Send_Byte
0000 TRUE     #if C64
f2d1 20 5e f8    JSR Init_Tape_Write
f2d4 90 04       BCC KeCL_60
f2d6 68          PLA
f2d7 a9 00       LDA #0
f2d9 60          RTS ;Size   79 [Kernal_CLOSE]
              #endif
0001 FALSE    #if VIC
SKIP             JMP Close_Patch   ; go do CLOSE tail
SKIP          KeCL_50
SKIP             BCS ClFi_Ret      ; just exit if error
              #endif

f2da          KeCL_60
f2da a5 b9       LDA SA            ; get secondary address
f2dc c9 62       CMP #$62
f2de d0 0b       BNE KeCL_80
f2e0 a9 05       LDA #$05          ; set logical end of the tape
f2e2 20 64 f7    JSR TAPE_Write_Header
f2e5 4c eb f2    JMP KeCL_80       ; restore index and close file
              #endif               ; JIFFY

f2e8          KeCL_70
f2e8 20 3c f6    JSR IEC_Close

f2eb          KeCL_80
f2eb 68          PLA               ; restore file index

              ; **********
f2ec            Close_File
              ; **********

f2ec aa          TAX               ; copy index to file to close

f2ed          ClFi_05
f2ed c6 98       DEC LDTND         ; decrement open file count
f2ef e4 98       CPX LDTND         ; compare index with open file count
f2f1 f0 14       BEQ ClFi_10       ; exit if equal, last entry was closing file
f2f3 a4 98       LDY LDTND         ; get open file count as index
f2f5 b9 59 02    LDA FILTBL,Y      ; get last+1 logical file number from logical file table
f2f8 9d 59 02    STA FILTBL,X      ; save logical file number over closed file
f2fb b9 63 02    LDA DEVTBL,Y      ; get last+1 device number from device number table
f2fe 9d 63 02    STA DEVTBL,X      ; save device number over closed file
f301 b9 6d 02    LDA SECATB,Y      ; get last+1 secondary address from secondary address table
f304 9d 6d 02    STA SECATB,X      ; save secondary address over closed file

f307          ClFi_10
f307 18          CLC

f308          ClFi_Ret
f308 60          RTS ;Size   29 [Close_File]

              ; ***********
f309            Find_File_X
              ; ***********

f309 a9 00       LDA #0
f30b 85 90       STA STATUS        ; clear serial status byte
f30d 8a          TXA               ; copy logical file number to A

              ; ***********
f30e            Find_File_A
              ; ***********

f30e a6 98       LDX LDTND         ; get open file count

f310          FiFi_10
f310 ca          DEX               ; decrememnt count to give index
f311 30 15       BMI GLFS_Ret      ; exit if no files
f313 dd 59 02    CMP FILTBL,X      ; compare logical file number with table logical file number
f316 d0 f8       BNE FiFi_10       ; loop if no match
f318 60          RTS ;Size   11 [Find_File_A]

              ; *******
f319            Get_LFS
              ; *******

f319 bd 59 02    LDA FILTBL,X      ; get logical file from logical file table
f31c 85 b8       STA LA            ; set logical file
f31e bd 63 02    LDA DEVTBL,X      ; get device number from device number table
f321 85 ba       STA FA            ; set device number
f323 bd 6d 02    LDA SECATB,X      ; get secondary address from secondary address table
f326 85 b9       STA SA            ; set secondary address

f328          GLFS_Ret
f328 60          RTS ;Size   16 [Get_LFS]

              ; ************
f329            Kernal_CLALL
              ; ************

f329 a9 00       LDA #0
f32b 85 98       STA LDTND         ; clear open file count

              ; *************
f32d            Kernal_CLRCHN
              ; *************

f32d a2 03       LDX #$03          ; set X to screen
f32f e4 9a       CPX DFLTO         ; compare output device number with screen
f331 b0 03       BCS KeCC_10       ; branch if >= screen
f333 20 fe ed    JSR Kernal_UNLSN  ; command the serial bus to UNLISTEN

f336          KeCC_10
f336 e4 99       CPX DFLTN         ; compare input device number with screen
f338 b0 03       BCS KeCC_20       ; branch if >= screen
f33a 20 ef ed    JSR Kernal_UNTLK  ; command the serial bus to UNTALK

f33d          KeCC_20
f33d 86 9a       STX DFLTO         ; set output device number to screen
f33f a9 00       LDA #$00          ; set for keyboard
f341 85 99       STA DFLTN         ; set input device number to keyboard
f343 60          RTS ;Size   23 [Kernal_CLRCHN]

              ; ***********
f344            Kernal_OPEN
              ; ***********

f344 a6 b8       LDX LA            ; get logical file number
f346 d0 03       BNE OPEN_05       ; branch if there is a file
f348 4c 04 f7    JMP Not_Input_File      ; else do not input file error and return

f34b          OPEN_05
f34b 20 09 f3    JSR Find_File_X
f34e d0 03       BNE OPEN_10       ; branch if file not found
f350 4c f8 f6    JMP File_Already_Open      ; else do file already open error and return

f353          OPEN_10
f353 a6 98       LDX LDTND         ; get open file count
f355 e0 0a       CPX #$0A          ; compare with max
f357 90 03       BCC OPEN_15       ; branch if less
f359 4c f5 f6    JMP Too_Many_Files      ; else do too many files error and return

f35c          OPEN_15
f35c e6 98       INC LDTND         ; increment open file count
f35e a5 b8       LDA LA            ; get logical file number
f360 9d 59 02    STA FILTBL,X      ; save to logical file table
f363 a5 b9       LDA SA            ; get secondary address
f365 09 60       ORA #$60          ; OR with the OPEN CHANNEL command
f367 85 b9       STA SA            ; set secondary address
f369 9d 6d 02    STA SECATB,X      ; save to secondary address table
f36c a5 ba       LDA FA            ; get device number
f36e 9d 63 02    STA DEVTBL,X      ; save to device number table
f371 f0 5a       BEQ OPEN_60       ; do ok exit if keyboard
f373 c9 03       CMP #$03          ; compare device number with screen
f375 f0 56       BEQ OPEN_60       ; do ok exit if screen
f377 90 05       BCC OPEN_20       ; branch if < screen, tape or RS232
f379 20 cf f3    JSR IEC_Send_SA_And_Filename
f37c 90 4f       BCC OPEN_60       ; do ok exit

f37e          OPEN_20
0001 FALSE    #if JIFFY
SKIP             CMP #1            ; tape ?
SKIP             BEQ Jmp_Dev_Not_Present
              #else
f37e c9 02       CMP #2            ; RS232 ?
f380 d0 03       BNE OPEN_25
              #endif
f382 4c 03 f4    JMP RS232_Open

0001 FALSE    #if JIFFY
SKIP          Jiffy_Talk_TkSA
SKIP             JSR UNTLK
SKIP             LDA FA
SKIP             JSR TALK
              #else
f385          OPEN_25
f385 20 ca f7    JSR TAPE_Get_Buffer_Address
f388 b0 03       BCS OPEN_30       ; branch if >= $0200
f38a 4c 0d f7    JMP Illegal_Jiffy_Device
              #endif

f38d          OPEN_30
f38d a5 b9       LDA SA            ; get secondary address
0001 FALSE    #if JIFFY
SKIP             JMP TKSA
SKIP          
SKIP          Jiffy_Transfer_01
SKIP             .BYTE "M-W",$00,$06,$1c ; memory write $0600 - $061b
SKIP          
SKIP          Jiffy_Disk_Code_01   ; $1c bytes drive code
SKIP             LDA $0261
SKIP             STA $07
SKIP             LDA #$12
SKIP             STA $06
SKIP             LDX #0
SKIP             STX $f9
SKIP             JSR $d586 
SKIP             LDY $0267 
SKIP             LDA ($30),Y
SKIP             EOR #$40
SKIP             STA ($30),Y
SKIP             JMP $d58a 
SKIP          
SKIP             .BYTE "M-E",$00,$06            ; memory execute at $0600
SKIP             .BYTE "M-W",$6a,$00,$01        ; memory write   at $006a
SKIP             .BYTE "M-W",$69,$00,$01        ; memory write   at $0069
SKIP             .BYTE $50,$6e,$01,$00,$53,$3a
              #else
f38f 29 0f       AND #$0F
f391 d0 1f       BNE OPEN_45
f393 20 11 f8    JSR Wait_For_Play
f396 b0 36       BCS OPEN_Ret      ; exit if STOP was pressed
f398 20 a9 f5    JSR Print_Searching
f39b a5 b7       LDA FNLEN         ; get file name length
f39d f0 0a       BEQ OPEN_40       ; if null file name just go find header
f39f 20 e4 f7    JSR TAPE_Find_Fileheader
f3a2 90 18       BCC OPEN_50       ; branch if no error
f3a4 f0 28       BEQ OPEN_Ret      ; exit if ??

f3a6          OPEN_35
f3a6 4c fe f6    JMP File_Not_Found      ; do file not found error and return

f3a9          OPEN_40
f3a9 20 26 f7    JSR TAPE_Find_Any_Header
f3ac f0 20       BEQ OPEN_Ret      ; exit if end of tape found
f3ae 90 0c       BCC OPEN_50
f3b0 b0 f4       BCS OPEN_35

f3b2          OPEN_45
f3b2 20 32 f8    JSR TAPE_Wait_For_Record
f3b5 b0 17       BCS OPEN_Ret      ; exit if STOP was pressed
f3b7 a9 04       LDA #$04          ; set data file header
f3b9 20 64 f7    JSR TAPE_Write_Header

f3bc          OPEN_50
f3bc a9 bf       LDA #$BF
f3be a4 b9       LDY SA            ; get secondary address
f3c0 c0 60       CPY #$60
f3c2 f0 07       BEQ OPEN_55
f3c4 a0 00       LDY #0
f3c6 a9 02       LDA #$02
f3c8 91 b2       STA (TAPE1),Y     ; save to tape buffer
f3ca 98          TYA               ; clear A
              #endif

f3cb          OPEN_55
f3cb 85 a6       STA BUFPNT        ; save tape buffer index

f3cd          OPEN_60
f3cd 18          CLC               ; flag ok

f3ce          OPEN_Ret
f3ce 60          RTS ;Size  139 [Kernal_OPEN]

              ; ************************
f3cf            IEC_Send_SA_And_Filename
              ; ************************

f3cf a5 b9       LDA SA            ; get secondary address
0000 TRUE     #if C64
f3d1 30 fa       BMI OPEN_60       ; ok exit if negative
              #endif
0001 FALSE    #if VIC
SKIP             BMI ISSF_40       ; ok exit if negative
              #endif
f3d3 a4 b7       LDY FNLEN         ; get file name length
0000 TRUE     #if C64
f3d5 f0 f6       BEQ OPEN_60       ; ok exit if null
              #endif
0001 FALSE    #if VIC
SKIP             BEQ ISSF_40       ; ok exit if null
              #endif
0000 TRUE     #if C64
f3d7 a9 00       LDA #0
f3d9 85 90       STA STATUS
              #endif
f3db a5 ba       LDA FA            ; get device number
f3dd 20 0c ed    JSR Kernal_LISTEN ; command devices on the serial bus to LISTEN
f3e0 a5 b9       LDA SA            ; get the secondary address
f3e2 09 f0       ORA #$F0          ; OR with the OPEN command
f3e4 20 b9 ed    JSR Kernal_SECOND ; send secondary address after LISTEN
f3e7 a5 90       LDA STATUS        ; get serial status byte
f3e9 10 05       BPL ISSF_10       ; branch if device present

f3eb          Pop_Dev_Not_Present
f3eb 68          PLA               ; else dump calling address low byte
f3ec 68          PLA               ; dump calling address high byte

f3ed          Jmp_Dev_Not_Present
f3ed 4c 01 f7    JMP Dev_Not_Present      ; do device not present error and return

f3f0          ISSF_10
f3f0 a5 b7       LDA FNLEN         ; get file name length
f3f2 f0 0c       BEQ ISSF_30       ; branch if null name

f3f4 a0 00       LDY #0
f3f6          ISSF_20
f3f6 b1 bb       LDA (FNADR ),Y    ; get file name byte
f3f8 20 dd ed    JSR Kernal_CIOUT  ; output a byte to the serial bus
f3fb c8          INY
f3fc c4 b7       CPY FNLEN         ; compare with file name length
f3fe d0 f6       BNE ISSF_20       ; loop if not all done

f400          ISSF_30
0000 TRUE     #if C64
f400 4c 4e f6    JMP IClo_10
              #endif
0001 FALSE    #if VIC
SKIP             JSR Kernal_UNLSN
SKIP          ISSF_40
SKIP             CLC               ; flag ok
SKIP             RTS
              #endif

              ; ==========
f403            RS232_Open
              ; ==========

0000 TRUE     #if C64
f403 20 7d f4    JSR ROPN_50
              #endif
0001 FALSE    #if VIC
SKIP             LDA #$06          ; IIII IOOI, DTR and RTS only as outputs
SKIP             STA VIA1_DDRB     ; set VIA 1 DDRB
SKIP             STA RS2_DSR_CTS   ; set VIA 1 DRB, DTR and RTS high
SKIP             LDA #$EE          ; CB2 high, CB1 negative edge, CA2 high, CA1 negative edge
SKIP             STA VIA1_PCR      ; set VIA 1 PCR
SKIP             LDY #0
              #endif
f406 8c 97 02    STY RSSTAT        ; clear RS232 status byte

f409          ROPN_05
f409 c4 b7       CPY FNLEN         ; compare with file name length
f40b f0 0a       BEQ ROPN_10       ; exit loop if done
f40d b1 bb       LDA (FNADR ),Y    ; get file name byte
f40f 99 93 02    STA M51CTR  ,Y    ; copy to 6551 register set
f412 c8          INY
f413 c0 04       CPY #$04          ; compare with $04
f415 d0 f2       BNE ROPN_05       ; loop if not to 4 yet

f417          ROPN_10
f417 20 4a ef    JSR RS232_Set_Data_Bits
f41a 8e 98 02    STX BITNUM        ; save bit count
f41d ad 93 02    LDA M51CTR        ; get pseudo 6551 control register
f420 29 0f       AND #$0F          ; mask 0000 xxxx, baud rate
0000 TRUE     #if C64
f422 f0 1c       BEQ ROPN_30
              #endif
0001 FALSE    #if VIC
SKIP             BNE ROPN_15       ; quirk
              #endif

f424          ROPN_15
f424 0a          ASL A             ; * 2
f425 aa          TAX               ; copy to index
0000 TRUE     #if C64
f426 ad a6 02    LDA TVSFLG        ; TV flag
f429 d0 09       BNE ROPN_20       ; 0 = PAL
f42b bc bb fe    LDY Baudrate-1,X
f42e bd ba fe    LDA Baudrate-2,X
f431 4c 3a f4    JMP ROPN_25

f434          ROPN_20
f434 bc eb e4    LDY BaudNTSC-1,X
f437 bd ea e4    LDA BaudNTSC-2,X

f43a          ROPN_25
f43a 8c 96 02    STY M51AJB+1
f43d 8d 95 02    STA M51AJB

f440          ROPN_30
f440 ad 95 02    LDA M51AJB
f443 0a          ASL A
f444 20 28 ff    JSR Set_Baud_Rate
              #endif
0001 FALSE    #if VIC
SKIP             LDA Baudrate-2,X  ; get timer constant low byte
SKIP             ASL A             ; * 2
SKIP             TAY               ; copy to Y
SKIP             LDA Baudrate-1,X  ; get timer constant high byte
SKIP             ROL A             ; * 2
SKIP             PHA               ; save it
SKIP             TYA               ; get timer constant low byte back
SKIP             ADC #$C8          ; + $C8, carry cleared by previous ROL
SKIP             STA BAUDOF        ; save bit cell time low byte
SKIP             PLA               ; restore high  byte
SKIP             ADC #$00          ; add carry
SKIP             STA BAUDOF+1      ; save bit cell time high byte
              #endif
f447 ad 94 02    LDA M51CDR        ; get pseudo 6551 command register
f44a 4a          LSR A             ; shift b0 into Cb
f44b 90 09       BCC ROPN_35       ; branch if 3 line interface
0000 TRUE     #if C64
f44d ad 01 dd    LDA  CIA2_PRB
              #endif
0001 FALSE    #if VIC
SKIP             LDA VIA2_DATB     ; get VIA 2 DRB, this is wrong, the adress should be
              #endif
f450 0a          ASL A             ; shift DSR into Cb
f451 b0 03       BCS ROPN_35       ; branch if DSR = 1
0000 TRUE     #if C64
f453 20 0d f0    JSR RS232_Set_Status_No_Signal
              #endif
0001 FALSE    #if VIC
SKIP             JMP RS232_No_DSR_Signal
              #endif

f456          ROPN_35
f456 ad 9b 02    LDA RIDBE         ; get index to Rx buffer end
f459 8d 9c 02    STA RIDBS         ; set index to Rx buffer start, clear Rx buffer
f45c ad 9e 02    LDA RODBE         ; get index to Tx buffer end
f45f 8d 9d 02    STA RODBS         ; set index to Tx buffer start, clear Tx buffer
f462 20 21 fe    JSR Read_Memtop
f465 a5 f8       LDA RXPTR+1       ; get Rx buffer pointer high byte
f467 d0 05       BNE ROPN_40       ; branch if buffer already set
f469 88          DEY               ; decrement top of memory high byte, 256 byte buffer
f46a 84 f8       STY RXPTR+1       ; set Rx buffer pointer high byte
f46c 86 f7       STX RXPTR         ; set Rx buffer pointer low byte

f46e          ROPN_40
f46e a5 fa       LDA TXPTR+1       ; get Tx buffer pointer high byte
f470 d0 05       BNE ROPN_45       ; branch if buffer already set
f472 88          DEY               ; decrement Rx buffer pointer high byte, 256 byte buffer
f473 84 fa       STY TXPTR+1       ; set Tx buffer pointer high byte
f475 86 f9       STX TXPTR         ; set Tx buffer pointer low byte

f477          ROPN_45
f477 38          SEC
f478 a9 f0       LDA #$F0
f47a 4c 27 fe    JMP Set_memtop

0000 TRUE     #if C64
f47d          ROPN_50
f47d a9 7f       LDA #$7F
f47f 8d 0d dd    STA CIA2_ICR
f482 a9 06       LDA #6
f484 8d 03 dd    STA CIA2_DDRB
f487 8d 01 dd    STA CIA2_PRB
f48a a9 04       LDA #4
f48c 0d 00 dd    ORA CIA2_PRA
f48f 8d 00 dd    STA CIA2_PRA
f492 a0 00       LDY #0
f494 8c a1 02    STY ENABL
f497 60          RTS ;Size  201 [IEC_Send_SA_And_Filename]
              #endif

              ; ***********
f498            Kernal_LOAD
              ; ***********

                 STXY(MEMUSS)      ; set kernal setup pointer
f498 86 c3       STX MEMUSS
f49a 84 c4       STY MEMUSS+1

f49c 6c 30 03    JMP (ILOAD)       ; do LOAD vector, usually points to Default_LOAD

              ; ************
f49f            Default_LOAD
              ; ************

f49f 85 93       STA VERCKK        ; save load/verify flag
f4a1 a9 00       LDA #0
f4a3 85 90       STA STATUS        ; clear serial status byte
f4a5 a5 ba       LDA FA            ; get device number
f4a7 d0 03       BNE DLOA_10       ; branch if not keyboard

f4a9          DLOA_05
f4a9 4c 0d f7    JMP Illegal_Jiffy_Device

f4ac          DLOA_10
f4ac c9 03       CMP #$03          ; compare device number with screen
f4ae f0 f9       BEQ DLOA_05       ; if screen go do illegal device number and return
0001 FALSE    #if JIFFY
SKIP             BCC DLOA_05       ; no tape with jiffy dos
              #else
f4b0 90 7b       BCC DLOA_55       ; branch if less than screen
              #endif
f4b2 a4 b7       LDY FNLEN         ; get file name length
f4b4 d0 03       BNE DLOA_15       ; branch if not null name
0001 FALSE    #if JIFFY
SKIP             JMP Jiffy_Default_Filename
              #else
f4b6 4c 0a f7    JMP Missing_File_Name
              #endif

f4b9          DLOA_15
0000 TRUE     #if C64
f4b9 a6 b9       LDX SA
f4bb 20 a9 f5    JSR Print_Searching
              #endif
0001 FALSE    #if VIC
SKIP             JSR Get_SA_Print_Searching
              #endif
f4be a9 60       LDA #$60
f4c0 85 b9       STA SA            ; save the secondary address
f4c2 20 cf f3    JSR IEC_Send_SA_And_Filename
f4c5 a5 ba       LDA FA            ; get device number
f4c7 20 09 ed    JSR Kernal_TALK   ; command a serial bus device to TALK
f4ca a5 b9       LDA SA            ; get secondary address
f4cc 20 c7 ed    JSR Kernal_TKSA   ; send secondary address after TALK
f4cf 20 13 ee    JSR Kernal_ACPTR  ; input a byte from the serial bus
f4d2 85 ae       STA EAL           ; save program start address low byte
f4d4 a5 90       LDA STATUS        ; get serial status byte
f4d6 4a          LSR A             ; shift time out read ..
f4d7 4a          LSR A             ; .. into carry bit
f4d8 b0 50       BCS DLOA_50       ; if timed out go do file not found error and return
0001 FALSE    #if JIFFY
SKIP             JSR Jiffy_ACPTR_Load_Check
              #else
f4da 20 13 ee    JSR Kernal_ACPTR  ; input a byte from the serial bus
              #endif
f4dd 85 af       STA EAL+1         ; save program start address high byte
0000 TRUE     #if C64
f4df 8a          TXA
f4e0 d0 08       BNE DLOA_20
f4e2 a5 c3       LDA MEMUSS
f4e4 85 ae       STA EAL
f4e6 a5 c4       LDA MEMUSS+1
f4e8 85 af       STA EAL+1

f4ea          DLOA_20
0001 FALSE    #if JIFFY
SKIP             JMP Jiffy_fac4
              #else
f4ea 20 cc f5    JSR Display_LOADING_Or_VERIFYING
              #endif
              #endif
0001 FALSE    #if VIC
0001 FALSE    #if JIFFY
SKIP             JMP Jiffy_fb05
              #else
SKIP             JSR Set_Load_Address; set LOAD address if secondary address = 0
              #endif
              #endif

f4ed          DLOA_25
0001 FALSE    #if JIFFY
SKIP             JSR STOP
SKIP             BNE DLOA_26 
SKIP             JMP SAVE_50
SKIP          
SKIP          DLOA_26
SKIP             JSR Jiffy_ACPTR
SKIP             LDA STATUS
SKIP             AND #$fd
SKIP             CMP STATUS
SKIP             STA STATUS
SKIP             BNE DLOA_25
SKIP             LDY #0
SKIP             LDX TSFCNT
SKIP             LDA TBTCNT
SKIP             CPY VERCKK
SKIP             BEQ DLOA_31
              #else
f4ed a9 fd       LDA #$FD          ; mask xxxx xx0x, clear time out read bit
f4ef 25 90       AND STATUS        ; mask serial status byte
f4f1 85 90       STA STATUS        ; set serial status byte
f4f3 20 db ff    JSR STOP          ; Check if stop key is pressed
f4f6 d0 03       BNE DLOA_30       ; branch if not [STOP]
f4f8 4c 2d f6    JMP SAVE_50       ; else close the serial bus device and flag stop

f4fb          DLOA_30
f4fb 20 13 ee    JSR Kernal_ACPTR  ; input a byte from the serial bus
f4fe aa          TAX               ; copy byte
f4ff a5 90       LDA STATUS        ; get serial status byte
f501 4a          LSR A             ; shift time out read ..
f502 4a          LSR A             ; .. into carry bit
f503 b0 e8       BCS DLOA_25       ; if timed out go ??
f505 8a          TXA               ; copy received byte back
f506 a4 93       LDY VERCKK        ; get load/verify flag
f508 f0 0c       BEQ DLOA_35       ; branch if load
f50a a0 00       LDY #0
              #endif
f50c d1 ae       CMP (EAL),Y       ; compare byte with previously loaded byte
0001 FALSE    #if JIFFY
SKIP             BEQ DLOA_32 
SKIP             JSR Flag_Read_Error 
SKIP            .BYTE $2c
SKIP          
SKIP          DLOA_31
SKIP             STA (EAL),Y
SKIP          
SKIP          DLOA_32
SKIP             STX TSFCNT
              #else
f50e f0 08       BEQ DLOA_40       ; branch if match
f510 a9 10       LDA #$10          ; flag read error
f512 20 16 fe    JSR Ora_Status
f515 2c          .byte   $2C

f516          DLOA_35
f516 91 ae       STA (EAL),Y       ; save byte to memory
              #endif

f518          DLOA_40
f518 e6 ae       INC EAL           ; increment save pointer low byte
f51a d0 02       BNE DLOA_45       ; if no rollover skip the high byte increment
f51c e6 af       INC EAL+1         ; else increment save pointer high byte

f51e          DLOA_45
f51e 24 90       BIT STATUS        ; test serial status byte
f520 50 cb       BVC DLOA_25       ; loop if not end of file

f522          DLOA_47
f522 20 ef ed    JSR Kernal_UNTLK  ; command the serial bus to UNTALK
f525 20 3c f6    JSR IEC_Close
0001 FALSE    #if JIFFY & VIC
SKIP             BCC DLOA_95
              #else
f528 90 79       BCC DLOA_94       ; if OK exit
              #endif

f52a          DLOA_50
f52a 4c fe f6    JMP File_Not_Found

f52d          DLOA_55
0001 FALSE    #if JIFFY
SKIP          
SKIP          ; *************
SKIP            Jiffy_Exec_At
SKIP          ; *************
SKIP          
SKIP             LDA FNLEN         
SKIP             BEQ JLTF_10       ; no filename
SKIP             LDA (FNADR),Y
SKIP             CMP #'$'          ; display directory ?
SKIP             BEQ JLBF_10 
0001 FALSE    #if VIC
SKIP             JMP Jiffy_eb08
              #else
SKIP             JMP Jiffy_fc9a 
              #endif
SKIP          
SKIP          ; ********************
SKIP            Jiffy_List_Text_File ; Jiffy_List_Text_File
SKIP          ; ********************
SKIP          
SKIP             TYA               ; (Y) contains the command number
SKIP          
SKIP          JLTF_05
SKIP             PHA               ; save command
SKIP             JSR Jiffy_Open_Command_10
SKIP             PLA               ; retrieve
SKIP          
SKIP          JLTF_10
SKIP             STA BUFPNT        ; store
SKIP          
SKIP          JLTF_20
SKIP             JSR Jiffy_Read_Text_Line    ; input charaters to buffer (filename area)
SKIP             BNE JLTF_Ret      ; exit if errors occured
SKIP             LDA BUFPNT        ; get command number, should be $0f
SKIP             PHP   
SKIP             BEQ JLTF_30
SKIP             JSR Jiffy_CHRIN
SKIP             BEQ JLTF_40       ; exit if zero
SKIP          
SKIP          JLTF_30
SKIP             JSR JiDi_50 
SKIP             JSR PrSe_10       ; print filename, ie. the input buffer
0001 FALSE    #if VIC
SKIP             LDA STKEY         ; STKEY FLAG, test if <STOP> is pressed
SKIP             LSR A
SKIP             BCC JLTF_40       ; exit
              #else
SKIP             BIT STKEY         ; STKEY FLAG, test if <STOP> is pressed
SKIP             BPL JLTF_40       ; exit
              #endif
SKIP             PLP   
SKIP             BNE JLTF_20 
SKIP             BVC JLTF_20 
SKIP             .BYTE $24         ; skip PLP statement
SKIP          
SKIP          JLTF_40
SKIP             PLP   
SKIP          
SKIP          JLTF_Ret
SKIP             RTS   
SKIP          
SKIP          ; *********************
SKIP            Jiffy_List_Basic_File 
SKIP          ; *********************
SKIP          
SKIP             LDX #$6c          ; get byte for SA, list basic program
SKIP             .BYTE $2c         ; skip next statement
SKIP          
SKIP          JLBF_10
SKIP             LDX #$60          ; get byte for SA, list directory
SKIP             JSR Jiffy_Open_Command_20    ; open file with current parameters
0000 TRUE     #if C64
SKIP             LDA #$39          ; setup IERROR vector to point to $f739 (RTS)
              #endif
0001 FALSE    #if VIC
SKIP             LDA #$bc          ; setup IERROR vector to point to $f739 (RTS)
              #endif
SKIP             STA IERROR
SKIP             LDY #$fc          ; set up (Y) pointer to 252
SKIP             JSR Jiffy_fca6    ; skip load adddress
SKIP          
SKIP          JLBF_20
SKIP             LDY #0
SKIP          
SKIP          JLBF_30
SKIP             JSR Jiffy_fca6    ; read 254 bytes, store in input buffer
SKIP             BVS JLBF_40       ; exit on EOF
SKIP             CPY #2            ; exit if nothing read
SKIP             BEQ JLBF_40
SKIP             CPY #6
SKIP             BCC JLBF_30
0000 TRUE     #if C64
SKIP             LDX FNADR         ; Fr_Bot = FNADR
SKIP             STX TMPPTC
SKIP             LDX FNADR+1
SKIP             STX TMPPTC+1
SKIP             LDY #1
SKIP             STA (TMPPTC),Y
              #endif
0001 FALSE    #if VIC
SKIP             LDX FNADR+1       ; Fr_Bot = FNADR
SKIP             STX TMPPTC+1
SKIP             LDA FNADR  
SKIP             STA TMPPTC  
SKIP             JSR Jiffy_fbc8
              #endif
SKIP             JSR LIST_12       ; part of Basic LIST routine
SKIP             JSR JiDi_50
SKIP             JSR LIST_17
0000 TRUE     #if C64
SKIP             BIT STKEY
SKIP             BMI JLBF_20       ; continue if no STOP key pressed
              #endif
0001 FALSE    #if VIC
SKIP             LDA STKEY
SKIP             LSR A
SKIP             BCS JLBF_20
              #endif
SKIP          
SKIP          JLBF_40
0000 TRUE     #if C64
SKIP             LDA #$63          ; restore IERROR vector to $f763
              #endif
0001 FALSE    #if VIC
SKIP             LDA #$e6          ; restore IERROR vector to 
              #endif
SKIP             STA IERROR
SKIP             RTS
0001 FALSE    #if VIC & !JIFFY
SKIP             NOP
              #endif
              #else
0000 TRUE     #if C64
f52d 4a          LSR A
f52e b0 03       BCS DLOA_60
f530 4c 0d f7    JMP Illegal_Jiffy_Device
              #endif
0001 FALSE    #if VIC
SKIP             CMP #$02          ; compare device with RS232 device
SKIP             BNE DLOA_60       ; if not RS232 device continue
SKIP             JMP RRec_70       ; else do illegal device number and return
              #endif

f533          DLOA_60
f533 20 ca f7    JSR TAPE_Get_Buffer_Address
f536 b0 03       BCS DLOA_65       ; branch if >= $0200
f538 4c 0d f7    JMP Illegal_Jiffy_Device

f53b          DLOA_65
f53b 20 11 f8    JSR Wait_For_Play
f53e b0 68       BCS DLOA_Ret      ; exit if STOP was pressed
f540 20 a9 f5    JSR Print_Searching

f543          DLOA_70
f543 a5 b7       LDA FNLEN         ; get file name length
f545 f0 09       BEQ DLOA_75
f547 20 e4 f7    JSR TAPE_Find_Fileheader
f54a 90 0b       BCC DLOA_80       ; if no error continue
f54c f0 5a       BEQ DLOA_Ret      ; exit if ??
f54e b0 da       BCS DLOA_50       ; branch always

f550          DLOA_75
f550 20 26 f7    JSR TAPE_Find_Any_Header
f553 f0 53       BEQ DLOA_Ret      ; exit if ??
f555 b0 d3       BCS DLOA_50

f557          DLOA_80
f557 a5 90       LDA STATUS        ; get serial status byte
f559 29 10       AND #$10          ; mask 000x 0000, read error
f55b 38          SEC               ; flag fail
f55c d0 4a       BNE DLOA_Ret      ; if read error just exit
f55e e0 01       CPX #$01
f560 f0 11       BEQ DLOA_90
f562 e0 03       CPX #$03
f564 d0 dd       BNE DLOA_70

f566          DLOA_85
f566 a0 01       LDY #$01
f568 b1 b2       LDA (TAPE1),Y
f56a 85 c3       STA MEMUSS
f56c c8          INY
f56d b1 b2       LDA (TAPE1),Y
f56f 85 c4       STA MEMUSS+1
f571 b0 04       BCS DLOA_92

f573          DLOA_90
f573 a5 b9       LDA SA
f575 d0 ef       BNE DLOA_85

f577          DLOA_92
f577 a0 03       LDY #$03
f579 b1 b2       LDA (TAPE1),Y
f57b a0 01       LDY #$01
f57d f1 b2       SBC (TAPE1),Y
f57f aa          TAX
f580 a0 04       LDY #$04
f582 b1 b2       LDA (TAPE1),Y
f584 a0 02       LDY #$02
f586 f1 b2       SBC (TAPE1),Y
f588 a8          TAY
f589 18          CLC
f58a 8a          TXA
f58b 65 c3       ADC MEMUSS
f58d 85 ae       STA EAL
f58f 98          TYA
f590 65 c4       ADC MEMUSS+1
f592 85 af       STA EAL+1
f594 a5 c3       LDA MEMUSS
f596 85 c1       STA STAL
f598 a5 c4       LDA MEMUSS+1
f59a 85 c2       STA STAL+1
f59c 20 cc f5    JSR Display_LOADING_Or_VERIFYING
f59f 20 44 f8    JSR TAPE_Read
f5a2 24          .byte   $24       ; skip CLC statement
              #endif

f5a3          DLOA_94
f5a3 18          CLC               ; flag ok

f5a4          DLOA_95
f5a4 a6 ae       LDX EAL           ; get the LOAD end pointer low byte
f5a6 a4 af       LDY EAL+1         ; get the LOAD end pointer high byte

f5a8          DLOA_Ret
f5a8 60          RTS ;Size  266 [Default_LOAD]

              ; ***************
f5a9            Print_Searching
              ; ***************

f5a9 a5 9d       LDA MSGFLG
f5ab 10 1e       BPL PrSe_Ret
f5ad a0 0c       LDY #Msg_Searching-Msg_Start
f5af 20 2f f1    JSR Display_Kernal_IO_Message
f5b2 a5 b7       LDA FNLEN
f5b4 f0 15       BEQ PrSe_Ret
f5b6 a0 17       LDY #Msg_FOR-Msg_Start
f5b8 20 2f f1    JSR Display_Kernal_IO_Message

f5bb          PrSe_10
f5bb a4 b7       LDY FNLEN
f5bd f0 0c       BEQ PrSe_Ret

f5bf a0 00       LDY #0
f5c1          PrSe_20
f5c1 b1 bb       LDA (FNADR ),Y
f5c3 20 cc ff    JSR CHROUT
f5c6 c8          INY
f5c7 c4 b7       CPY FNLEN
f5c9 d0 f6       BNE PrSe_20

f5cb          PrSe_Ret
f5cb 60          RTS ;Size   35 [Print_Searching]

              ; ****************************
f5cc            Display_LOADING_Or_VERIFYING
              ; ****************************

f5cc a0 49       LDY #Msg_Loading-Msg_Start
f5ce a5 93       LDA VERCKK        ; get load/verify flag
f5d0 f0 02       BEQ DLV_10        ; branch if load
f5d2 a0 59       LDY #Msg_Verifying-Msg_Start

f5d4          DLV_10
f5d4 4c 2b f1    JMP Display_Direct_Msg

              ; ***********
f5d7            Kernal_SAVE
              ; ***********

f5d7 86 ae       STX EAL           ; save end address low byte
f5d9 84 af       STY EAL+1         ; save end address high byte
f5db aa          TAX               ; copy index to start pointer
f5dc b5 00       LDA 0,X           ; get start address low byte
f5de 85 c1       STA STAL          ; set I/O start addresses low byte
f5e0 b5 01       LDA 1,X           ; get start address high byte
f5e2 85 c2       STA STAL+1        ; set I/O start addresses high byte
f5e4 6c 32 03    JMP (ISAVE)       ; go save, usually points to Default_SAVE

              ; ************
f5e7            Default_SAVE
              ; ************

f5e7 a5 ba       LDA FA            ; get device number
f5e9 d0 03       BNE SAVE_20       ; branch if not keyboard

f5eb          SAVE_10
f5eb 4c 0d f7    JMP Illegal_Jiffy_Device

f5ee          SAVE_20
f5ee c9 03       CMP #$03          ; compare device number with screen
f5f0 f0 f9       BEQ SAVE_10       ; if screen do illegal device number and return
0001 FALSE    #if JIFFY
SKIP             BCC SAVE_10
              #else
f5f2 90 5f       BCC IClo_30      ; branch if < screen
              #endif
f5f4 a9 61       LDA #$61          ; set secondary address to $01
f5f6 85 b9       STA SA            ; save secondary address
f5f8 a4 b7       LDY FNLEN         ; get file name length
f5fa d0 03       BNE SAVE_30       ; branch if filename not null

f5fc          Jmp_Missing_Filename
f5fc 4c 0a f7    JMP Missing_File_Name      ; else do missing file name error and return

f5ff          SAVE_30
f5ff 20 cf f3    JSR IEC_Send_SA_And_Filename
f602 20 89 f6    JSR Display_SAVING_Filename
f605 a5 ba       LDA FA            ; get device number
f607 20 0c ed    JSR Kernal_LISTEN ; command devices on the serial bus to LISTEN
f60a a5 b9       LDA SA            ; get secondary address
f60c 20 b9 ed    JSR Kernal_SECOND ; send secondary address after LISTEN
f60f a0 00       LDY #0
f611 20 88 fb    JSR Set_IO_Start
f614 a5 ac       LDA SAL           ; get buffer address low byte
f616 20 dd ed    JSR Kernal_CIOUT  ; output a byte to the serial bus
f619 a5 ad       LDA SAL+1         ; get buffer address high byte
f61b 20 dd ed    JSR Kernal_CIOUT  ; output a byte to the serial bus

f61e          SAVE_40
f61e 20 cb fc    JSR Check_IO_End
f621 b0 16       BCS SAVE_70       ; go do UNLISTEN if at end
f623 b1 ac       LDA (SAL),Y       ; get byte from buffer
f625 20 dd ed    JSR Kernal_CIOUT  ; output a byte to the serial bus
f628 20 db ff    JSR STOP          ; Check if stop key is pressed
f62b d0 07       BNE SAVE_60       ; if stop not pressed go increment pointer and loop for next

f62d          SAVE_50
f62d 20 3c f6    JSR IEC_Close
f630 a9 00       LDA #0
f632 38          SEC               ; flag stop
f633 60          RTS ;Size   77 [Default_SAVE]

f634          SAVE_60
f634 20 d5 fc    JSR Inc_SAL_Word
f637 d0 e5       BNE SAVE_40       ; loop, branch always

f639          SAVE_70
f639 20 fe ed    JSR Kernal_UNLSN  ; command the serial bus to UNLISTEN

              ; *********
f63c            IEC_Close
              ; *********

f63c 24 b9       BIT SA            ; test the secondary address
f63e 30 11       BMI IClo_20       ; if already closed just exit
f640 a5 ba       LDA FA            ; get the device number
f642 20 0c ed    JSR Kernal_LISTEN ; command devices on the serial bus to LISTEN
f645 a5 b9       LDA SA            ; get secondary address
f647 29 ef       AND #$EF          ; mask the channel number
f649 09 e0       ORA #$E0          ; OR with the CLOSE command
f64b 20 b9 ed    JSR Kernal_SECOND ; send secondary address after LISTEN

f64e          IClo_10
f64e 20 fe ed    JSR Kernal_UNLSN  ; command the serial bus to UNLISTEN

f651          IClo_20
f651 18          CLC               ; flag ok
f652 60          RTS ;Size   23 [IEC_Close]

0001 FALSE    #if JIFFY
SKIP          ; **********************
SKIP            Jiffy_Default_Filename
SKIP          ; **********************
SKIP          
SKIP             LDA NDX
SKIP             BEQ Jmp_Missing_Filename
SKIP             LDA #2
SKIP             STA SA
SKIP             LDX #<[Jiffy_F1+2]
SKIP             LDY #>[Jiffy_F1+2]
SKIP             JSR SETNAM
SKIP             JMP DLOA_15
SKIP          
SKIP          ; *****
SKIP            Jf66b
SKIP          ; *****
SKIP          
SKIP             LDX #$33
SKIP             LDY #4
SKIP             JMP Jiffy_Char_Command
SKIP          
SKIP          ; Function key assignment
SKIP          
SKIP          Jiffy_F1  .BYTE "@$:*\r",0           ; directory
SKIP          Jiffy_F3  .BYTE "/",0                ; load
SKIP          Jiffy_F5  .BYTE "^",0                ; save
SKIP          Jiffy_F7  .BYTE "%",0                ; load ML
SKIP          Jiffy_F2  .BYTE "@D",0
SKIP          Jiffy_F4  .BYTE "@T",0
SKIP          Jiffy_F6  .BYTE "_",0
SKIP          Jiffy_F8  .BYTE "@  ",QUOTE,"S:",0
0001 FALSE    #if VIC
SKIP             .byte $24
              #endif
              #else
f653          IClo_30
0000 TRUE     #if C64
f653 4a          LSR A
f654 b0 03       BCS IClo_40
f656 4c 0d f7    JMP Illegal_Jiffy_Device
              #endif
0001 FALSE    #if VIC
SKIP             CMP #$02          ; compare device with RS232 device
SKIP             BNE IClo_40       ; branch if not RS232 device
SKIP             JMP RRec_70       ; else do illegal device number and return
              #endif

f659          IClo_40
f659 20 ca f7    JSR TAPE_Get_Buffer_Address
f65c 90 8d       BCC SAVE_10
f65e 20 32 f8    JSR TAPE_Wait_For_Record
f661 b0 25       BCS IClo_Ret      ; exit if STOP was pressed
f663 20 89 f6    JSR Display_SAVING_Filename
f666 a2 03       LDX #$03          ; set header for a non relocatable program file
f668 a5 b9       LDA SA            ; get secondary address
f66a 29 01       AND #$01          ; mask non relocatable bit
f66c d0 02       BNE IClo_50       ; branch if non relocatable program
f66e a2 01       LDX #$01          ; else set header for a relocatable program file

f670          IClo_50
f670 8a          TXA               ; copy header type to A
f671 20 64 f7    JSR TAPE_Write_Header
f674 b0 12       BCS IClo_Ret      ; exit if error
f676 20 61 f8    JSR TAPE_Write_With_Lead
f679 b0 0d       BCS IClo_Ret      ; exit if error
f67b a5 b9       LDA SA            ; get secondary address
f67d 29 02       AND #$02          ; mask end of tape flag
f67f f0 06       BEQ IClo_60       ; branch if not end of tape
f681 a9 05       LDA #$05          ; else set logical end of the tape
f683 20 64 f7    JSR TAPE_Write_Header
f686 24          .byte   $24       ; skip next command
              #endif

f687          IClo_60
f687 18          CLC               ; flag ok

f688          IClo_Ret
f688 60          RTS ;Size   77 [IEC_Close]

              ; ***********************
f689            Display_SAVING_Filename
              ; ***********************

f689 a5 9d       LDA MSGFLG        ; get message mode flag
f68b 10 fb       BPL IClo_Ret      ; exit if control messages off
f68d a0 51       LDY #Msg_Saving-Msg_Start
f68f 20 2f f1    JSR Display_Kernal_IO_Message
f692 4c bb f5    JMP PrSe_10      ; print file name and return

              ; ************
f695            Kernal_UDTIM       ; Update the system clock
              ; ************

f695 a2 00       LDX #$00          ; clear X
f697 e6 a2       INC JIFFYL        ; increment jiffy low byte
f699 d0 06       BNE UDTI_10       ; if no rollover skip the mid byte increment
f69b e6 a1       INC JIFFYM        ; increment jiffy mid byte
f69d d0 02       BNE UDTI_10       ; if no rollover skip the high byte increment
f69f e6 a0       INC JIFFYH        ; increment jiffy high byte

f6a1          UDTI_10
f6a1 38          SEC
f6a2 a5 a2       LDA JIFFYL        ; get jiffy clock low byte
f6a4 e9 01       SBC #$01          ; subtract $4F1A01 low byte
f6a6 a5 a1       LDA JIFFYM        ; get jiffy clock mid byte
f6a8 e9 1a       SBC #$1A          ; subtract $4F1A01 mid byte
f6aa a5 a0       LDA JIFFYH        ; get jiffy clock high byte
f6ac e9 4f       SBC #$4F          ; subtract $4F1A01 high byte
f6ae 90 06       BCC Look_For_Special_Keys
f6b0 86 a0       STX JIFFYH        ; clear jiffies high byte
f6b2 86 a1       STX JIFFYM        ; clear jiffies mid byte
f6b4 86 a2       STX JIFFYL        ; clear jiffies low byte

              ; *********************
f6b6            Look_For_Special_Keys
              ; *********************

f6b6 ad 01 dc    LDA KEYB_ROWN     ; get VIA 2 DRA, keyboard row, no handshake
f6b9 cd 01 dc    CMP KEYB_ROWN     ; compare with self
f6bc d0 f8       BNE Look_For_Special_Keys
0000 TRUE     #if C64
f6be aa          TAX
f6bf 30 13       BMI LFSK_20
f6c1 a2 bd       LDX #$bd
f6c3 8e 00 dc    STX KEYB_COL

f6c6          LFSK_10
f6c6 ae 01 dc    LDX KEYB_ROW
f6c9 ec 01 dc    CPX KEYB_ROW
f6cc d0 f8       BNE LFSK_10
f6ce 8d 00 dc    STA KEYB_COL
f6d1 e8          INX
f6d2 d0 02       BNE LFSK_Ret
              #endif

f6d4          LFSK_20
f6d4 85 91       STA STKEY         ; save VIA 2 DRA, keyboard row

f6d6          LFSK_Ret
f6d6 60          RTS ;Size   33 [Look_For_Special_Keys]

              ; ************
f6d7            Kernal_RDTIM       ; Read system clock
              ; ************

f6d7 78          SEI               ; disable interrupts
f6d8 a5 a2       LDA JIFFYL        ; get jiffy clock low byte
f6da a6 a1       LDX JIFFYM        ; get jiffy clock mid byte
f6dc a4 a0       LDY JIFFYH        ; get jiffy clock high byte

              ; *************
f6de            Kernal_SETTIM      ; Set the system clock
              ; *************

f6de 78          SEI               ; disable interrupts
f6df 85 a2       STA JIFFYL        ; save jiffy clock low byte
f6e1 86 a1       STX JIFFYM        ; save jiffy clock mid byte
f6e3 84 a0       STY JIFFYH        ; save jiffy clock high byte
f6e5 58          CLI               ; enable interrupts
f6e6 60          RTS ;Size    9 [Kernal_SETTIM]

              ; ***********
f6e7            Kernal_STOP        ; Check if stop key is pressed
              ; ***********

f6e7 a5 91       LDA STKEY         ; get keyboard row
0000 TRUE     #if C64
f6e9 c9 7f       CMP #$7f
              #endif
0001 FALSE    #if VIC
SKIP             CMP #$FE          ; compare with r0 down
              #endif
f6eb d0 07       BNE STOP_Ret      ; branch if not just r0
f6ed 08          PHP               ; save status
f6ee 20 c6 ff    JSR CLRCHN        ; Clear I/O channels
f6f1 85 c6       STA NDX           ; save keyboard buffer length
f6f3 28          PLP               ; restore status

f6f4          STOP_Ret
f6f4 60          RTS ;Size   14 [Kernal_STOP]

f6f5          Too_Many_Files
f6f5 a9 01       LDA #$01
f6f7 2c          .byte   $2C

f6f8          File_Already_Open
f6f8 a9 02       LDA #$02
f6fa 2c          .byte   $2C

f6fb          File_Not_Open
f6fb a9 03       LDA #$03
f6fd 2c          .byte   $2C

f6fe          File_Not_Found
f6fe a9 04       LDA #$04
f700 2c          .byte   $2C

f701          Dev_Not_Present
f701 a9 05       LDA #$05
f703 2c          .byte   $2C

f704          Not_Input_File
f704 a9 06       LDA #$06
f706 2c          .byte   $2C

f707          Not_Output_File
f707 a9 07       LDA #$07
f709 2c          .byte   $2C

f70a          Missing_File_Name
f70a a9 08       LDA #$08
f70c 2c          .byte   $2C

f70d          Illegal_Jiffy_Device
f70d a9 09       LDA #$09          ; illegal device number
f70f 48          PHA               ; save error #
f710 20 c6 ff    JSR CLRCHN        ; Clear I/O channels
f713 a0 00       LDY #0            ; index to "I/O ERROR #"
f715 24 9d       BIT MSGFLG        ; test message mode flag
f717 50 0a       BVC DIOR_10       ; exit if kernal messages off
f719 20 2f f1    JSR Display_Kernal_IO_Message
f71c 68          PLA               ; restore error #
f71d 48          PHA               ; copy error #
f71e 09 30       ORA #'0'          ; convert to ASCII
f720 20 cc ff    JSR CHROUT        ; Output a character

f723          DIOR_10
f723 68          PLA               ; pull error number
f724 38          SEC               ; flag error

f725          Jiffy_RTS
f725 60          RTS ;Size   63 [Kernal_STOP]

0001 FALSE    #if JIFFY
SKIP          
SKIP          ; ******************
SKIP            Jiffy_Test_Command
SKIP          ; ******************
SKIP          
SKIP             LDY #12
SKIP             JSR CHRGOT
SKIP          
SKIP          ; *******************
SKIP            Jiffy_Test_Commands
SKIP          ; *******************
SKIP          
SKIP             CMP Jiffy_Command_List,Y
SKIP             BEQ JTC_Ret
SKIP             DEY
SKIP             BPL Jiffy_Test_Commands
SKIP          
SKIP          JTC_Ret
SKIP             RTS
SKIP          
SKIP          ; ************
SKIP            Jiffy_SETLFS
SKIP          ; ************
SKIP          
SKIP             JSR SETLFS
SKIP          
SKIP          ; *********************
SKIP            Jiffy_Test_IEC_Device
SKIP          ; *********************
SKIP          
SKIP             CLC
SKIP             PHP
SKIP             LDX Jiffy_Device
SKIP             CPX #8
SKIP             BCC JTID_20       ; device <  8
SKIP          
SKIP          JTID_10
SKIP             CPX #$1f
SKIP             BCC JTID_30       ; device < 31
SKIP          
SKIP          JTID_20
SKIP             PLP
SKIP             BCS Jiffy_Device_Not_Present
SKIP             SEC
SKIP             PHP
SKIP             LDX #8            ; try device 8
SKIP          
SKIP          JTID_30
SKIP             STX Jiffy_Device
SKIP             JSR Jiffy_Test_Device
SKIP             BCC JTID_40
SKIP             INX               ; try next device
SKIP             BNE JTID_10
SKIP          
SKIP          JTID_40
SKIP             PLA
SKIP          
SKIP          JTID_Ret
SKIP             RTS
SKIP          
SKIP          ; *****************
SKIP            Jiffy_Validate_FA
SKIP          ; *****************
SKIP          
SKIP             JSR Jiffy_Test_FA
SKIP             BCC JTID_Ret
SKIP          
SKIP          ; ************************
SKIP            Jiffy_Device_Not_Present
SKIP          ; ************************
SKIP          
SKIP             LDX #5
SKIP          
SKIP          ; **************
SKIP            Jiffy_Dispatch
SKIP          ; **************
SKIP          
SKIP             CPX #11           ; SYNTAX ERROR
SKIP             BEQ JiDi_20
SKIP          
SKIP          JiDi_10
SKIP             JMP Back_To_Prompt
SKIP          
SKIP          JiDi_20
SKIP             JSR Jiffy_Test_Command  ; (Y) = command
SKIP             BNE JiDi_10             ; not a Jiffy command
SKIP             STY COMSAV
SKIP             TAX
SKIP             BMI JiDi_30
SKIP             PLA
SKIP             PLA
SKIP          
SKIP          JiDi_30
SKIP             JSR Jiffy_Test_IEC_Device
SKIP             JSR Jiffy_At_Command
SKIP             LDA COMSAV
SKIP             LDY #0
SKIP             ASL A
SKIP             TAX
SKIP             LDA JTAB,X
SKIP             STA FUNJMP
SKIP             LDA JTAB+1,X
SKIP             STA FUNJMP+1
SKIP          
SKIP          JiDi_40
SKIP             JSR JUMPER        ; execute JiffyDOS command
SKIP             JSR Basic_DATA    ; ignore next statement
SKIP             JSR Jiffy_Close_15
SKIP             LDA PTR2
SKIP             JSR CLOSE
SKIP          
SKIP          ; *******
SKIP            JiDi_50
SKIP          ; *******
SKIP          
SKIP             JSR CLRCHN
SKIP             LDX IOPMPT
SKIP             BEQ JTID_Ret
SKIP             .BYTE $2c         ; ignore next statement
SKIP          
SKIP          ; *******
SKIP            JiDi_60
SKIP          ; *******
SKIP          
SKIP             LDX #$6f
SKIP             JMP CHKOUT
SKIP          
SKIP          ; *************
SKIP            Jiffy_Load_ML
SKIP          ; *************
SKIP          
SKIP             TYA
SKIP             INY
SKIP             .BYTE $2c         ; skip INY and TYA
SKIP          
SKIP          ; ************
SKIP            Jiffy_Verify
SKIP          ; ************
SKIP          
SKIP             INY
SKIP          
SKIP          ; ****************
SKIP            Jiffy_Load_Basic
SKIP          ; ****************
SKIP          
SKIP             TYA
SKIP             STY SA
SKIP             LDX TXTTAB
SKIP             LDY TXTTAB+1
SKIP             JSR LOAD
SKIP             BCC JiLo_30
SKIP             JMP Error_Handler
SKIP          
SKIP          JiLo_10
SKIP             JMP LOAD_30
SKIP          
SKIP          JiLo_20
SKIP             JMP LOAD_05
SKIP          
SKIP          JiLo_30
SKIP             LDA COMSAV
SKIP             CMP #11           ; verify command (´)
SKIP             BEQ JiLo_20       ; output verify OK
SKIP             BCS JiDi_40
SKIP             CMP #8            ; load ml (%)
0000 TRUE     #if C64
SKIP             BEQ JTID_Ret
SKIP             BCC JiLo_10
              #endif
0001 FALSE    #if VIC
SKIP             BNE JAAC_10
SKIP             RTS
SKIP          
SKIP          JAAC_10
SKIP             BCC JiLo_10
              #endif
SKIP             STX VARTAB
SKIP             STY VARTAB+1
SKIP             PLA
SKIP             PLA
SKIP             JSR Print_CR
SKIP             JSR Rechain
SKIP             JMP Basic_RUN
SKIP          
SKIP          ; ******************
SKIP            Jiffy_Command_List
SKIP          ; ******************
SKIP          
SKIP             .byte "@"         ;  0 : disk status and command
SKIP             .byte "_"         ;  1 : <- save file
SKIP             .byte "*"         ;  2 : *  copy file
SKIP             .byte $ac         ;  3 :    copy file
SKIP             .byte QUOTE       ;  4 : nothing
SKIP             .byte $12         ;  5 : nothing
SKIP             .byte "/"         ;  6 : load Basic program
SKIP             .byte $ad         ;  7
SKIP             .byte "%"         ;  8
SKIP             .byte "^"         ;  9
SKIP             .byte $ae         ; 10
SKIP             .byte $27         ; 11 
SKIP             .byte $5c         ; 12 : load file ML
SKIP             .byte "D"         ; 13 : display basic program
SKIP             .byte "L"
SKIP             .byte "T"
SKIP             .byte "#"
SKIP             .byte "B"
SKIP             .byte "F"
SKIP             .byte "O"
SKIP             .byte "P"
SKIP             .byte "Q"
SKIP             .byte "X"
SKIP             .byte "G"
SKIP          
SKIP          ; ****
SKIP            JTAB
SKIP          ; ****
SKIP          
SKIP             .WORD Jiffy_Exec_At            ;  @    0
SKIP             .WORD Jiffy_SAVE               ;  <-   1
SKIP             .WORD Jiffy_Copy               ;  *    2
SKIP             .WORD Jiffy_Copy               ;  $ac  3
SKIP             .WORD Jiffy_RTS                ;  Quo  4
SKIP             .WORD Jiffy_RTS                ;  RVS  5
SKIP             .WORD Jiffy_Load_Basic         ;  /    6
SKIP             .WORD Jiffy_Load_Basic         ;  $ad  7
SKIP             .WORD Jiffy_Load_ML            ;  %    8
SKIP             .WORD Jiffy_Load_Basic         ;  ^    9
SKIP             .WORD Jiffy_Load_Basic         ;  $ae 10
SKIP             .WORD Jiffy_Verify             ;  '   11
SKIP             .WORD Jiffy_Load_ML            ;  \   12  
SKIP             .WORD Jiffy_List_Basic_File    ;  Disp   13
SKIP             .WORD Jiffy_Lock_File          ;  Lock   14
SKIP             .WORD Jiffy_List_Text_File     ;  Text   15
SKIP             .WORD Jiffy_Set_Default_Device ;  #      16
SKIP             .WORD Jiffy_No_Bump            ;  Bump   17
SKIP             .WORD Jiffy_Inx_PRTY           ;  F      18
SKIP             .WORD Jiffy_OLD                ;  Old    19
SKIP             .WORD Jiffy_Toggle_Printer     ;  Print  20
SKIP             .WORD Jiffy_Disable            ;  Quit   21
SKIP             .WORD Jiffy_Destination        ;  Xfer   22
SKIP             .WORD Jiffy_Gap                ;  Gap    23
SKIP          
SKIP          ; *********
SKIP            Jiffy_OLD
SKIP          ; *********
SKIP          
SKIP             INY               ; Y = 1
SKIP             TYA               ; A = 1
SKIP             STA (TXTTAB),Y    ; Create dummy link <> zero
SKIP             JSR Rechain
SKIP             TXA               ; X/A = end of program + 2
SKIP             ADC #2
SKIP             TAX
SKIP             LDA INDEXA+1
SKIP             ADC #0
SKIP             TAY
SKIP             JMP LOAD_55
SKIP          
SKIP          ; This routine is called from the JiffyDOS COMMAND routine and make a
SKIP          ; test for additional command characters after the '@' character. Only
SKIP          ; the command number $0d-$17 is tested. If text after '@' is not a
SKIP          ; JiffyDOS command (ie. a normal DOS command', or JiffyDOS command
SKIP          ; number less than $10, a filename is expected. Tests are made for colon
SKIP          ; and quotes, the filname is evaluated, and parts of the OPEN/CLOSE
SKIP          ; routine is used to SETNAM. A test is made for additional device number
SKIP          ; after a comma. A free line on the screen is found, and some
SKIP          ; string-house keeping is done. Finally, the routine continues through
SKIP          ; to the next routine to open the command channel.
SKIP          
SKIP          ; ****************
SKIP            Jiffy_At_Command
SKIP          ; ****************
SKIP          
SKIP             TYA
SKIP             BNE JAC_05
SKIP             STA FNLEN
SKIP             JSR CHRGET
SKIP             BEQ JAC_45        ; terminator found, exit
SKIP             LDY #$17          ; test 23 commands
SKIP             JSR Jiffy_Test_Commands
SKIP             BNE JAC_10        ; not a Jiffy command
SKIP             CPY #13           ; ignore commands 0 - 12
SKIP             BCC JAC_10
SKIP             STY COMSAV
SKIP             CPY #16
SKIP             BCS JAC_45        ; no filename for commands >= 16
SKIP          
SKIP          JAC_05
SKIP             LDA #1
SKIP             JSR Add_To_TXTPTR
SKIP          
SKIP          JAC_10
SKIP             LDY #$ff
SKIP          
SKIP          JAC_15               ; scan filename
SKIP             INY
SKIP             LDA (TXTPTR),Y
SKIP             BEQ JAC_20
SKIP             CMP #QUOTE
SKIP             BEQ JAC_25
SKIP             CMP #':'
SKIP             BNE JAC_15
SKIP          
SKIP          JAC_20
SKIP             BIT MSGFLG
SKIP             BPL JAC_30
SKIP             CLC
SKIP             JSR Make_String_Descriptor_From_Code
SKIP             JMP JAC_35
SKIP          
SKIP          JAC_25
SKIP             JSR Add_Y_To_Execution_Pointer
SKIP          
SKIP          JAC_30
SKIP             JSR Eval_Expression
SKIP          
SKIP          JAC_35
SKIP             JSR Set_Filename_From_String
SKIP             JSR CHRGOT
SKIP             CMP #','
SKIP             BNE JAC_45
SKIP             JSR Get_Next_Byte_Value
SKIP          
SKIP          JAC_40
SKIP             STX FA
SKIP          
SKIP          JAC_45
SKIP             LDY #0
SKIP             BIT MSGFLG
SKIP             BPL JAC_55
SKIP          
SKIP          JAC_50
SKIP             LDA (LINPTR),Y
SKIP             CMP #' '
SKIP             BEQ JAC_55
SKIP             LDA #13
SKIP             JSR Screen_CHROUT
SKIP             BNE JAC_50
SKIP          
SKIP          JAC_55
SKIP             JSR Jiffy_Validate_FA
SKIP             LDA #$ff
SKIP             JSR Allocate_String_FAC1
SKIP             LDA FNLEN
SKIP             LDX FNADR
SKIP             LDY FNADR+1
SKIP             JSR Store_And_Push_String
SKIP             JSR Eval_String
SKIP             STX FNADR
SKIP             STY FNADR+1
SKIP          
SKIP          ; **************************
SKIP            Jiffy_Open_Command_Channel
SKIP          ; **************************
SKIP          
SKIP             JSR Jiffy_Close_6f; close command channel if open
SKIP             LDA FNLEN         
SKIP             LDX #0
SKIP             STX FNLEN         ; FNLEN = 0
SKIP             LDX #$6f
SKIP             BNE JOC_30        ; branch always
SKIP          
SKIP          ; *********************
SKIP            Jiffy_Open_Command_10
SKIP          ; *********************
SKIP          
SKIP             LDX #$6e
SKIP          
SKIP          ; *********************
SKIP            Jiffy_Open_Command_20
SKIP          ; *********************
SKIP          
SKIP             LDA FNLEN
SKIP          
SKIP          JOC_30
SKIP             STX SA
SKIP             STX PTR2
SKIP          
SKIP          JOC_40
SKIP             PHA
SKIP             STX LA
SKIP             JSR CLRCHN
SKIP             JSR OPEN
SKIP             PLA
SKIP             STA FNLEN         ; restore FNLEN
SKIP          
SKIP          JOC_Ret
SKIP          ;#if C64
SKIP             RTS
SKIP          ;#endif
SKIP          
SKIP          ; ***************
SKIP            Jiffy_Lock_File
SKIP          ; ***************
SKIP          
SKIP             JSR Jiffy_Disk_Status
SKIP             BNE JOC_Ret
SKIP             LDX #0   ; start data at "M-W...."
SKIP             LDY #$22 ; send 34 bytes 
SKIP             JSR Jiffy_Drive_Command
SKIP             LDY #5   ; start data after "M-W" sequence
SKIP             LDX #$22 ; send 34 bytes
SKIP          
SKIP          ; *******************
SKIP            Jiffy_Drive_Command
SKIP          ; *******************
SKIP          
SKIP             JSR Jiffy_Send_Drive_Command
SKIP             JMP CLRCHN
SKIP          
SKIP          ; *******************
SKIP            Jiffy_Detect_Device
SKIP          ; *******************
SKIP          
0000 TRUE     #if C64
SKIP             STA CIA2_PRA
SKIP             AND #8            ; Test ATN out
SKIP             BEQ JIS_Ret
SKIP             LDA BSOUR
SKIP             ROR A
SKIP             ROR A
              #endif
0001 FALSE    #if VIC
SKIP             STA VIA2_PCR
SKIP             BIT VIA1_DATN
SKIP             BPL JIS_Ret
              #endif
SKIP          
SKIP             CPX #2
0000 TRUE     #if C64
SKIP             BNE JIS_Ret
              #endif
0001 FALSE    #if VIC
SKIP             BNE JIS_Ret
SKIP             LDA #2
              #endif
SKIP             LDX #$1e          ; wait for jiffy protocol
SKIP          
SKIP          JIS_10
0000 TRUE     #if C64
SKIP             BIT CIA2_PRA
SKIP             BPL JIS_20        ; data high (0) -> Jiffy signal
              #endif
0001 FALSE    #if VIC
SKIP             BIT VIA1_DATN
SKIP             BEQ JIS_20        ; data high (0) -> Jiffy signal
              #endif
SKIP             DEX
SKIP             BNE JIS_10
0000 TRUE     #if C64
SKIP             BEQ JIS_30        ; no Jiffy device
              #endif
0001 FALSE    #if VIC
SKIP             BEQ JIS_30
              #endif
SKIP          
SKIP          JIS_20
0000 TRUE     #if C64
SKIP             BIT CIA2_PRA
SKIP             BPL JIS_20        ; wait for end of Jiffy signal
              #endif
0001 FALSE    #if VIC
SKIP             BIT IEC_DRAN
SKIP             BEQ JIS_20        ; wait for end of Jiffy signal
SKIP             LDA BSOUR
SKIP             ROR A
SKIP             ROR A
              #endif
SKIP          
SKIP             ORA #$40          ; BSOUR >>2 | $40
SKIP             STA TSFCNT        ; Flag as Jiffy device
SKIP          
SKIP          JIS_30
SKIP             LDX #2
SKIP          
SKIP          JIS_Ret
SKIP             RTS
SKIP          
SKIP          ; ********************
SKIP            Jiffy_Read_Text_Line
SKIP          ; ********************
SKIP          
SKIP             LDY #0
SKIP             JSR Jiffy_CHKIN_PTR2
SKIP          
SKIP          JRTL_10
SKIP             JSR Jfca9
SKIP             BVS JRTL_20
SKIP             BCC JRTL_10
SKIP          
SKIP          JRTL_20
SKIP             STY FNLEN
SKIP             LDA STATUS
SKIP             AND #$82
SKIP             RTS
SKIP          
SKIP          ; *********
SKIP            Jiffy_Gap
SKIP          ; *********
SKIP          
SKIP             JSR Get_Next_Byte_Value
SKIP             TXA
SKIP             LDX #$2d          ; "M-W" 69 00 01
SKIP             BNE Jiffy_6_Char_Command
SKIP          
SKIP          ; *************
SKIP            Jiffy_No_Bump
SKIP          ; *************
SKIP          
SKIP             LDA #$85
SKIP             LDX #$27          ; "M-W" 6a 00 01
SKIP          
SKIP          ; ********************
SKIP            Jiffy_6_Char_Command
SKIP          ; ********************
SKIP          
SKIP             LDY #6
SKIP          
SKIP          ; ******************
SKIP            Jiffy_Char_Command
SKIP          ; ******************
SKIP          
SKIP             PHA
SKIP             JSR Jiffy_Send_Drive_Command
SKIP             PLA
SKIP             JMP CHROUT
SKIP          
SKIP          ; **********************
SKIP            Jiffy_Toggle_Copy_Flag
SKIP          ; **********************
SKIP          
SKIP             LDX #0
SKIP             .BYTE $2c
SKIP          
SKIP          ; *****************************
SKIP            Jiffy_Toggle_Copy_Flag_Single
SKIP          ; *****************************
SKIP          
SKIP             LDX #6
SKIP             JSR Reset_BASIC_Exec_Pointer
SKIP             LDY #5
SKIP             LDA (TXTPTR),Y    ; test 5th. character
SKIP             CMP #$12          ; <RVS ON>?
SKIP             BNE JTD_10         ; if not, directory isn't loaded
SKIP             PLA
SKIP             TXA               ; store (X), the toggle flag, on stack
SKIP             PHA
SKIP             LDY #$23          ; skip diskheader
SKIP          
SKIP          JTCF_10
SKIP             LDX #'"'
SKIP             JSR NeLi_15       ; use part of Next_Line, to search for character
SKIP             DEY
SKIP             JSR Add_Y_To_Execution_Pointer
SKIP             PLA               ; recover flag
SKIP             PHA
SKIP             BEQ JTCF_30       ; toggle all files
SKIP             STA CSRIDX
SKIP             LDY #1
SKIP          
SKIP          JTCF_20
SKIP             INY
SKIP             JSR CHRI_07       ; use part of CHRIN
SKIP             CMP (TXTPTR),Y
SKIP             BNE JTCF_40
SKIP             SBC #'"'
SKIP             BNE JTCF_20
SKIP          
SKIP          JTCF_30
SKIP             TAY
SKIP             LDA (TXTPTR),Y    ; get character
SKIP             EOR #10           ; toggle between ' ' ($20) and '*' ($2a)
SKIP             STA (TXTPTR),Y
SKIP             LDY #4
SKIP             STA (LINPTR),Y
SKIP          
SKIP          JTCF_40
SKIP             JSR Basic_DATA    ; skip rest of line
SKIP             LDY #5
SKIP             SEC
SKIP             LDA (TXTPTR),Y
SKIP             SBC #$42 ; 'B'
SKIP             BNE JTCF_10       ; next file
SKIP             LDY #2
SKIP             STA (TXTPTR),Y
SKIP             PLA
SKIP             BEQ JTCF_50
SKIP             LDA #$8d
SKIP             RTS
SKIP          
SKIP          JTCF_50
SKIP             JMP LIST_05
SKIP          
SKIP          ; ******************
SKIP            Jiffy_Toggle_Drive
SKIP          ; ******************
SKIP          
SKIP             BIT MSGFLG
SKIP             BPL JTD_10
SKIP             TSX
SKIP             LDY STACK+7,X
SKIP             CPY #$e1
SKIP             BNE JTD_10
SKIP             CMP #4
SKIP             BNE Bf9b2
SKIP             INC Jiffy_Device
SKIP             JSR Jiffy_Test_IEC_Device
SKIP             LDA #0
SKIP             JSR Print_Integer_XA
SKIP             JSR Print_CR
SKIP             JSR JiDi_50
SKIP          
SKIP          JTD_10
SKIP             PLA
SKIP             RTS
SKIP          
SKIP          ; *****
SKIP            Bf9b2
SKIP          ; *****
SKIP          
SKIP             CMP #1
SKIP             BEQ Jiffy_Toggle_Copy_Flag
SKIP             CMP #$17
SKIP             BEQ Jiffy_Toggle_Copy_Flag_Single
SKIP             LDY PRTY
SKIP             BNE JTD_10
SKIP             CMP #$8d
SKIP             BCS JTD_10
SKIP             CMP #$85
SKIP             BCC JTD_10
SKIP             PLA
SKIP             SBC #$85
SKIP             TAX
SKIP             BEQ Bf9d5
SKIP          Bf9cc     INY
SKIP             LDA (CMPO),Y
SKIP             BNE Bf9cc
SKIP             DEX
SKIP             BNE Bf9cc
SKIP          Bf9d4     INY
SKIP          Bf9d5     LDA (CMPO),Y
SKIP             BEQ Bf9e2
SKIP             CMP #13
SKIP             BEQ Bf9e4
SKIP             JSR Screen_CHROUT
SKIP             BNE Bf9d4
SKIP          Bf9e2     STA CSRMOD
SKIP          Bf9e4     RTS
SKIP          
SKIP          ; **********
SKIP            Jiffy_f9e5
SKIP          ; **********
SKIP          
SKIP             JSR Get_Char_From_Keyboard_Buffer
SKIP             PHA
SKIP             LDX CSRMOD
0000 TRUE     #if C64
SKIP             BNE Bfa37
              #endif
0001 FALSE    #if VIC
SKIP             BNE JAAD_10
              #endif
SKIP             LDX INSRTO
0000 TRUE     #if C64
SKIP             BNE Bfa37
              #endif
0001 FALSE    #if VIC
SKIP             BNE JAAD_10
              #endif
SKIP             CMP #16
SKIP             BNE Jiffy_Toggle_Drive
0000 TRUE     #if C64
SKIP             LDA #4
              #endif
0001 FALSE    #if VIC
SKIP             JMP KeDe_60
              #endif
SKIP          
SKIP          JAAD_10
0000 TRUE     #if C64
SKIP             JSR LISTEN
SKIP             LDA MEM_CONTROL
SKIP             AND #2
SKIP             BEQ Bfa03
SKIP             LDA #7
SKIP          Bfa03     ORA #$60
SKIP             JSR SECOND
SKIP             LDA CSRIDX
SKIP             PHA
SKIP             LDA TBLX
SKIP             PHA
SKIP          Bfa0e     LDY #0
SKIP             STY CSRMOD
SKIP             JSR PLOT_05
SKIP             INC LINLEN
SKIP          Bfa17     JSR CHRI_07
SKIP             JSR Kernal_CIOUT
SKIP             CMP #13
SKIP             BNE Bfa17
SKIP             INX
SKIP             CPX #$19
SKIP             BCS Bfa2d
SKIP             ASL LINLEN
SKIP             BPL Bfa0e
SKIP             INX
SKIP             BNE Bfa0e
SKIP          Bfa2d     JSR UNLSN
SKIP             PLA
SKIP             TAX
SKIP             PLA
SKIP             TAY
SKIP             JSR PLOT_05
              #endif
SKIP          Bfa37     PLA
SKIP          Bfa38     RTS
SKIP          
SKIP          ; **********
SKIP            Jiffy_Copy
SKIP          ; **********
SKIP          
SKIP             STY FAC3+1
SKIP             JSR Jiffy_Disk_Status
SKIP             BNE Bfa38
SKIP             JSR CHRGOT
SKIP             CMP #$52 ; 'R'
SKIP             BNE Bfa5a
SKIP          
SKIP          Bfa47
SKIP             DEC FAC3+1
SKIP             LDA FAC3+1
SKIP             JSR Jf66b
SKIP             JSR Jiffy_CHRIN
SKIP             BEQ Bfa47
SKIP             LDA #0
SKIP             JSR Jf66b
SKIP             LDA #$4c ; 'L'
SKIP          
SKIP          Bfa5a
SKIP             PHA
SKIP             LDX MYCH
SKIP             CPX FA
SKIP             BEQ Bfa37
SKIP             JSR JAC_40
SKIP             LDX #$37 ; '7'
SKIP             LDY #2
SKIP             JSR Jiffy_Send_Drive_Command
SKIP             JSR PrSe_10
SKIP             LDA #$2c ; ','
SKIP             STA (FNADR),Y
SKIP             INY
SKIP             PLA
SKIP             STA (FNADR),Y
SKIP             INY
SKIP             LDA #$2c ; ','
SKIP             STA (FNADR),Y
SKIP             INY
SKIP             LDA FAC3+1
SKIP             PHA
SKIP             BNE Bfa83
SKIP             LDA #$57 ; 'W'
SKIP          
SKIP          Bfa83
SKIP             STA (FNADR),Y
SKIP             INY
SKIP             STY FNLEN
SKIP             LDY #12
SKIP          Bfa8a
SKIP             JSR Jfab2
SKIP             JSR Jiffy_Test_IEC_Device
SKIP             JSR Jiffy_Open_Command_Channel
SKIP             PLA
SKIP             JSR JLTF_05
SKIP          
SKIP          ; ********************
SKIP            Jiffy_Toggle_Printer
SKIP          ; ********************
SKIP          
SKIP             LDA IOPMPT
SKIP             BEQ Bfaa7
SKIP             CMP #$7f
SKIP             BNE Bfa38
SKIP             JSR BaIN_10
SKIP             LDA #$7f
SKIP             JMP CLOSE
SKIP          
SKIP          Bfaa7
SKIP             LDX #4
SKIP             JSR CHRGET
SKIP             JSR GOCP_05
SKIP             JSR Jiffy_Validate_FA
SKIP          
SKIP          ; *****
SKIP            Jfab2
SKIP          ; *****
SKIP          
SKIP             STY SA
SKIP             LDX #$7f
SKIP             STX IOPMPT
SKIP             LDA FNLEN
SKIP             JMP JOC_40
0000 TRUE     #if C64
SKIP             TAX               ; dead code
SKIP             BNE Bfa8a
SKIP             LDA NXTBIT
SKIP             BEQ JAAE_05+1
SKIP          
SKIP          Jiffy_fac4
SKIP             JSR Display_LOADING_Or_VERIFYING
              #endif
0001 FALSE    #if VIC
SKIP          Jiffy_fb05
SKIP             JSR Set_Load_Address
              #endif
SKIP             TSX
SKIP             LDA STACK+2,X
0000 TRUE     #if C64
SKIP             CMP #$f7          ; high byte of return address
              #endif
0001 FALSE    #if VIC
SKIP             CMP #$f8
              #endif
SKIP          
SKIP          JAAE_05
SKIP             BNE JAAE_10
SKIP             LDA EAL
SKIP             STA FUNJMP
SKIP             LDA EAL+1
SKIP             STA FUNJMP+1
SKIP          
SKIP          JAAE_10
SKIP             BIT TSFCNT
SKIP             BMI Bfade
SKIP             JMP DLOA_25
SKIP          
SKIP          Bfade
SKIP             SEI
0000 TRUE     #if C64
SKIP             LDY #3
SKIP          
SKIP          Bfae1
SKIP             LDA EAL+1,Y
SKIP             PHA
SKIP             DEY
SKIP             BNE Bfae1
SKIP             LDA VIC_SPR_ENA
SKIP             STA CMPO
SKIP             JSR Jiffy_Clear_Sprites
SKIP          
SKIP          Bfaf0
SKIP             JSR Look_For_Special_Keys
SKIP             BPL Bfb27
SKIP             LDA VIC_CONTROL_1
SKIP             AND #7
SKIP             CLC
SKIP             ADC #$2f
SKIP             STA CMPO+1
SKIP             LDA CIA2_PRA
SKIP             AND #7
SKIP             STA TAPE1
SKIP             STA CIA2_PRA
SKIP             ORA #$20
SKIP             TAX
SKIP          
SKIP          Bfb0c
SKIP             BIT CIA2_PRA
SKIP             BVC Bfb0c
SKIP             BPL Jiffy_LOAD
SKIP             LDX #$64
SKIP          Bfb15     BIT CIA2_PRA
SKIP             BVC Bfb20
              #endif
0001 FALSE    #if VIC
SKIP             LDA TAPE1
SKIP             PHA
SKIP             LDY #0
SKIP          
SKIP          JAAH_10
SKIP             JSR Look_For_Special_Keys
SKIP             CMP #$fe
SKIP             BEQ Bfb27
SKIP             LDA IEC_PCR
SKIP             AND #$dd
SKIP             TAX
SKIP             ORA #$20
SKIP             STA TAPE1
SKIP             STX IEC_PCR
SKIP             LDA #$80
SKIP             STA DPSW
SKIP          
SKIP          JAAF_10
SKIP             LDA IEC_DRAN
SKIP             LSR A
SKIP             BCC JAAF_10
SKIP             AND #1
SKIP             BEQ Jiffy_LOAD
SKIP             LDX #$64
SKIP          
SKIP          Bfb15
SKIP             BIT IEC_DRAN
SKIP             BEQ Bfb20
SKIP          Bfaf0
              #endif
SKIP             DEX
SKIP             BNE Bfb15
SKIP             LDA #$42
SKIP             .BYTE $2c
SKIP          
SKIP          Bfb20
SKIP             LDA #$40
SKIP             JSR Ora_Status
SKIP             CLC
SKIP             .BYTE $24
SKIP          
SKIP          Bfb27
SKIP             SEC
0000 TRUE     #if C64
SKIP             LDA CMPO
SKIP             STA VIC_SPR_ENA
SKIP             PLA
SKIP             STA CMPO
SKIP             PLA
SKIP             STA CMPO+1
              #endif
SKIP             PLA
SKIP             STA TAPE1
SKIP             BCS Bfb3b
SKIP             JMP DLOA_47
SKIP          
SKIP          Bfb3b
SKIP             JMP SAVE_50
SKIP          
SKIP          ; **********
SKIP            Jiffy_LOAD
SKIP          ; **********
SKIP          
0000 TRUE     #if C64
SKIP             BIT CIA2_PRA
SKIP             BPL Jiffy_LOAD    ; wait until data (7) = 1
SKIP             SEC               ; [2: 2]
SKIP          
SKIP          JiLO_10
SKIP             LDA VIC_RASTER    ; [4: 4] current raster line
SKIP             SBC CMPO+1        ; [4: 8]  minus fine scroll register 
SKIP             BCC JiLO_20       ; [3:11]  no bad line
SKIP             AND #7
SKIP             BEQ JiLO_10
SKIP          
SKIP          JiLO_20
SKIP             LDA TAPE1         ; [3:14]
SKIP             STX CIA2_PRA      ; [4:18] data (5) and clock (4) output = 0
SKIP             BIT CIA2_PRA      ; [4:22] 
SKIP             BVC Bfaf0         ; [2:24]
SKIP             NOP               ; [2:26] wait
SKIP             STA CIA2_PRA      ; [4:30]
SKIP             ORA CIA2_PRA      ; [4:34] get bit 0 & 1 of byte      <--
SKIP             LSR A             ; [2:36] A = .XX.....
SKIP             LSR A             ; [2:38] A = ..XX....
SKIP             NOP               ; [2:40] wait 2 cycles
SKIP             ORA CIA2_PRA      ; [4:44] get bit 2 & 3 of byte      <--
SKIP             LSR A             ; [2:46] A = .XXXX...
SKIP             LSR A             ; [2:48] A = ..XXXX..
SKIP             EOR TAPE1         ; [3:51] leave bits 2-0 unchanged
SKIP             EOR CIA2_PRA      ; [4:55] get bit 4 & 5 of byte      <--
SKIP             LSR A             ; [2:57] A = .XXXXXX.
SKIP             LSR A             ; [2:59] A = ..XXXXXX
SKIP             EOR TAPE1         ; [3:62] leave bits 2-0 unchanged
SKIP             EOR CIA2_PRA      ; [4:66] get bit 6 & 7 of byte      <--
              #endif
SKIP          
0001 FALSE    #if VIC
SKIP             LDA #2
SKIP          
SKIP          JiLO_05
SKIP             BIT IEC_DRAN
SKIP             BEQ JiLO_05
SKIP          
SKIP          JiLO_10
SKIP             PHA
SKIP             PLA
SKIP             NOP
SKIP             LDA TAPE1
SKIP             STA IEC_PCR
SKIP             LDA #1
SKIP             BIT IEC_DRAN
SKIP             BEQ JAAH_10
SKIP             STX IEC_PCR
SKIP             LDA IEC_DRAN
SKIP             ROR A
SKIP             ROR A
SKIP             AND #$80
SKIP             ORA IEC_DRAN
SKIP             ROL A
SKIP             ROL A
SKIP             STA TAPE1+1
SKIP             LDA IEC_DRAN
SKIP             ROR A
SKIP             ROR A
SKIP             AND DPSW
SKIP             ORA IEC_DRAN
SKIP             ROL A
SKIP             ROL A
SKIP             STA CAS1
SKIP             JSR Jiffy_Combine_Nibbles
              #endif
SKIP          
SKIP             CPY VERCKK
SKIP             BNE JiLO_40
SKIP             STA (EAL),Y
SKIP          
SKIP          JiLO_30
SKIP             INC EAL
SKIP             BNE JiLO_10
SKIP             INC EAL+1
SKIP             JMP JiLO_10
SKIP          
SKIP          JiLO_40
SKIP             CMP (EAL),Y
SKIP             BEQ JiLO_30
0000 TRUE     #if C64
SKIP             SEC
              #endif
SKIP             LDA #16
SKIP             STA STATUS
SKIP             BNE JiLO_30       ; branch always
SKIP          
0001 FALSE    #if VIC
SKIP          JTABB
SKIP             .byte $00,$00,$20,$20,$00,$00,$20,$20
SKIP             .byte $02,$02,$22,$22,$02,$02,$22,$22
SKIP          
SKIP          Jiffy_fbc8
SKIP             LDY #0
SKIP             STA (TMPPTC),Y
SKIP             INY
SKIP             TXA
SKIP             STA (TMPPTC),Y
SKIP             RTS
SKIP          
SKIP             .byte $ff
              #endif
SKIP          
SKIP          ; ************
SKIP            Set_IO_Start
SKIP          ; ************
SKIP          
SKIP             LDA STAL+1
SKIP             STA SAL+1
SKIP             LDA STAL
SKIP             STA SAL
SKIP             RTS
SKIP          
SKIP          ; **************************
SKIP            Jiffy_Disable_Sprite_ACPTR
SKIP          ; **************************
SKIP          
0000 TRUE     #if C64
SKIP             PHA                ; save sprite enable register
SKIP             JSR Jiffy_Clear_Sprites
SKIP             JSR Jiffy_ACPTR_10 ; call Jiffy_ACPTR
SKIP             PLA
SKIP             STA VIC_SPR_ENA    ; restore sprite enable register
SKIP             LDA TBTCNT         ; recover received byte
SKIP             RTS
              #endif
SKIP          
SKIP          ; ***************
SKIP            Jiffy_Jmp_ACPTR
SKIP          ; ***************
SKIP          
SKIP             LDA #0
SKIP             JMP KeAC_03
SKIP          
SKIP          ; This is the JiffyDOS ACPTR routine which fetches a byte from the
SKIP          ; serial bus. Entry point is $fbaa where a test is done by checking $a3
SKIP          ; to see if the current device is a JiffyDOS device. Visible sprites are
SKIP          ; disabled, and raster-timing is done so that no serial access is done
SKIP          ; when there is a "bad rasterline"
SKIP          
SKIP          ; video timing by Marko Makela
SKIP          ; ---------------------------------------------------------------
SKIP          ;  NTSC-M systems:
SKIP          ;
SKIP          ;            Chip      Crystal  Dot      Processor Cycles/ Lines/
SKIP          ;    Host    ID        freq/Hz  clock/Hz clock/Hz  line    frame
SKIP          ;    ------  --------  -------- -------- --------- ------- ------
SKIP          ;    VIC-20  6560-101  14318181  4090909   1022727      65    261
SKIP          ;    C64     6567R56A  14318181  8181818   1022727      64    262
SKIP          ;    C64     6567R8    14318181  8181818   1022727      65    263
SKIP          ;
SKIP          ;  Later NTSC-M video chips were most probably like the 6567R8.  Note
SKIP          ;  that the processor clock is a 14th of the crystal frequency on all
SKIP          ;  NTSC-M systems.
SKIP          ;
SKIP          ;  PAL-B systems:
SKIP          ;
SKIP          ;            Chip      Crystal  Dot      Processor Cycles/ Lines/
SKIP          ;    Host    ID        freq/Hz  clock/Hz clock/Hz  line    frame
SKIP          ;    ------  --------  -------- -------- --------- ------- ------
SKIP          ;    VIC-20  6561-101   4433618  4433618   1108405      71    312
SKIP          ;    C64     6569      17734472  7881988    985248      63    312
SKIP          ;
SKIP          ; ---------------------------------------------------------------
SKIP          ; So the Jiffy routine needs more time than one raster line, to
SKIP          ; receive 1 byte. Therefore we have to make sure, that the bad line
SKIP          ; is not nearer than 2 lines ahead!
SKIP          
SKIP          
SKIP          ; ***********
SKIP            Jiffy_ACPTR
SKIP          ; ***********
SKIP          
SKIP             SEI
SKIP             BIT TSFCNT          ; test to see if the device is a JiffyDOS drive
SKIP             BVC Jiffy_Jmp_ACPTR ; nope, back to normal ACPTR routine
0000 TRUE     #if C64
SKIP             LDA VIC_SPR_ENA     ; are sprites active ?
SKIP             BNE Jiffy_Disable_Sprite_ACPTR
              #endif
SKIP          
SKIP          ; **************
SKIP            Jiffy_ACPTR_10
SKIP          ; **************
SKIP          
0000 TRUE     #if C64
SKIP             LDA CIA2_PRA        ; IEC bus register
SKIP             CMP #%01000000
SKIP             BCC Jiffy_ACPTR_10  ; wait until data (7) or clock (6) = 1
SKIP             AND #7              ; mask bits 2-0
SKIP             PHA                 ; save (carry is set)
SKIP          
SKIP          JiAC_10
SKIP             LDA VIC_RASTER      ; [4: 4] current raster line
SKIP             SBC VIC_CONTROL_1   ; [4: 8]  minus fine scroll register
SKIP             AND #7              ; [2:10] modulo 7
SKIP             CMP #7              ; [2:12] compare with 7
SKIP             BCS JiAC_10         ; [2:14] we're one line before a bad line
SKIP             PLA                 ; [4:18] restore bits 2-0
SKIP             STA CIA2_PRA        ; [4:22] data (5) and clock (4) output = 0
SKIP             STA TBTCNT          ; [3:25] save bits 2-0
SKIP             ORA #%00100000      ; [2:27] data (5) output = 1
SKIP             PHA                 ; [3:30] save
SKIP             NOP                 ; [2:32] wait 2 cycles
SKIP             NOP                 ; [2:34] wait 2 cycles
SKIP             ORA CIA2_PRA        ; [4:38] get bit 0 & 1 of byte      <--
SKIP             LSR A               ; [2:40] A = .XX.....
SKIP             LSR A               ; [2:42] A = ..XX....
SKIP             NOP                 ; [2:44] wait 2 cycles
SKIP             ORA CIA2_PRA        ; [4:48] get bit 2 & 3 of byte      <--
SKIP             LSR A               ; [2:50] A = .XXXX...
SKIP             LSR A               ; [2:52] A = ..XXXX..
SKIP             EOR TBTCNT          ; [3:55] leave bits 2-0 unchanged
SKIP             EOR CIA2_PRA        ; [4:59] get bit 4 & 5 of byte      <--
SKIP             LSR A               ; [2:61] A = .XXXXXX.
SKIP             LSR A               ; [2:63] A = ..XXXXXX
SKIP             EOR TBTCNT          ; [3:66] leave bits 2-0 unchanged
SKIP             EOR CIA2_PRA        ; [4:70] get bit 6 & 7 of byte      <--
SKIP             STA TBTCNT          ; [3:73] byte completed
SKIP             PLA                 ; [4:77] recover %00100000 OR bit 2-0
SKIP             BIT CIA2_PRA        ; [4:81] test data in (7) and clock in (6)
SKIP             STA CIA2_PRA        ; [4:85] data out (5) = 1
SKIP             BVC Jiffy_Set_OK    ; branch on clock in = 0
SKIP             BPL Jiffy_Set_EOI   ; branch on data  in = 0
SKIP             LDA #%01000010      ; EOI (6) and time out (1)
SKIP             JMP Set_IEC_Status
              #endif
SKIP          
SKIP          ; §§
SKIP          
0001 FALSE    #if VIC
SKIP          ; read one byte from IEC bus
SKIP          ; ------------------------------------
SKIP          ; cycle 34: clock = bit1   data = bit0
SKIP          ; cycle 44: clock = bit3   data = bit2
SKIP          ; cycle 55: clock = bit5   data = bit4
SKIP          ; cycle 66: clock = bit7   data = bit6
SKIP          ; ------------------------------------
SKIP          ; cycle 77: status
SKIP          ; cycle 81: finish transmission
SKIP          
SKIP             LDA IEC_DRAN        ; IEC bus register
SKIP             AND #3
SKIP             BEQ Jiffy_ACPTR_10  ; wait until data (1) or clock (0) = 1
SKIP             LDA #$80
SKIP             STA DPSW
SKIP             TXA                 ; [2: 2]
SKIP             PHA                 ; [3: 4] save X
SKIP             PHA                 ; [3: 7] wait 3 cycles
SKIP             PLA                 ; [4:11] wait 4 cycles
SKIP             LDA IEC_PCR         ; [4:15] 
SKIP             AND #%11011101      ; [2:17]
SKIP             STA IEC_PCR         ; [4:21] data (5) and clock (1) = 0
SKIP             ORA #%00100000      ; [2:23]
SKIP             TAX                 ; [2:25] save mask in X
SKIP             BIT DPSW            ; [3:28] wait
SKIP             BIT DPSW            ; [3:31] wait
SKIP             BIT DPSW            ; [3:34] wait
SKIP             LDA IEC_DRAN        ; [4:38] get bit 0 & 1            <--
SKIP             ROR A               ; [2:40] bit 0 (clock) -> bit 7
SKIP             ROR A               ; [2:42] bit 1 (data ) -> carry
SKIP             AND #$80            ; [2:44] mask received bit 0
SKIP             ORA IEC_DRAN        ; [4:48] get bit 2 & 3            <--
SKIP             ROL A               ; [2:50] A = .....XXX
SKIP             ROL A               ; [2:52] A = ....XXXX
SKIP             STA TAPE1+1         ; [3:55] store lower nibble
SKIP             LDA IEC_DRAN        ; [4:59] get bit 4 & 5            <--
SKIP             ROR A               ; [2:61] bit 4 (clock) -> bit 7
SKIP             ROR A               ; [2:63] bit 5 (data ) -> carry
SKIP             AND DPSW            ; [3:66] mask received bit 4
SKIP             ORA IEC_DRAN        ; [4:70] get bit 6 & 7            <--
SKIP             ROL A               ; [2:72] A = .....XXX
SKIP             ROL A               ; [2:74] A = ....XXXX
SKIP             STA CAS1            ; [3:77] store upper nibble
SKIP             LDA IEC_DRAN        ; [4:81] get status bits
SKIP             STX IEC_PCR         ; [4:85] data out (5) = 1
SKIP             STA DPSW            ; save status bits
SKIP             JSR Jiffy_Combine_Nibbles
SKIP             STA TBTCNT          ; received byte
SKIP             PLA
SKIP             TAX                 ; restore X
SKIP             LDA DPSW            ; restore status bits
SKIP             ROR A               ; (clock) -> bit 7
SKIP             ROR A               ; (data ) -> carry
SKIP             BPL Jiffy_Set_OK    ; clock = 0 -> OK
SKIP             BCC Jiffy_Set_EOI   ; data  = 0 -> EOI
SKIP             LDA #%01000010      ; EOI (6) and time out (1) ($42)
SKIP             JMP Set_IEC_Status
              #endif
SKIP          
SKIP          ; ***************
SKIP            Jiffy_Send_Byte
SKIP          ; ***************
SKIP          
SKIP             SEI
SKIP             BIT TSFCNT        ; test to see if the device is a JiffyDOS drive
0000 TRUE     #if C64
SKIP             BVC Jiffy_Send_Byte_20
SKIP          
SKIP          JSB_10
SKIP             LDA VIC_SPR_ENA
SKIP             BEQ Jiffy_Send_Byte_30
SKIP             PHA
SKIP             JSR Jiffy_Clear_Sprites
SKIP             JSR Jiffy_Send_Byte_30
SKIP             PLA
SKIP             STA VIC_SPR_ENA
SKIP             RTS
              #endif
SKIP          
0001 FALSE    #if VIC
SKIP             BVS JSB_10
              #endif
SKIP          
SKIP          ; ******************
SKIP            Jiffy_Send_Byte_20
SKIP          ; ******************
SKIP          
SKIP             LDA TSFCNT
SKIP             CMP #$a0
SKIP             BCS JSB_10
SKIP             JMP IEC_Send_Byte
SKIP          
SKIP          ; *************
SKIP            Jiffy_Set_EOI
SKIP          ; *************
SKIP          
SKIP             LDA #%01000000    ; bit 6 = EOI
SKIP             JSR Ora_Status
SKIP          
SKIP          ; ************
SKIP            Jiffy_Set_OK
SKIP          ; ************
SKIP          
SKIP             LDA TBTCNT
SKIP          
SKIP          Bfc24
SKIP             CLI
SKIP             CLC
SKIP             RTS
0001 FALSE    #if VIC
SKIP          JSB_10
              #endif
SKIP          
SKIP          ; ******************
SKIP            Jiffy_Send_Byte_30
SKIP          ; ******************
SKIP          
0000 TRUE     #if C64
SKIP             TXA
SKIP             PHA
SKIP             LDA BSOUR
SKIP             AND #$f0
SKIP             PHA
SKIP             LDA BSOUR
SKIP             AND #15
SKIP             TAX
SKIP          Bfc33     LDA CIA2_PRA
SKIP             BPL Bfc33
SKIP             AND #7
SKIP             STA BSOUR
SKIP             SEC
SKIP          Bfc3d     LDA VIC_RASTER
SKIP             SBC VIC_CONTROL_1
SKIP             AND #7
SKIP             CMP #6
SKIP             BCS Bfc3d
SKIP             LDA BSOUR
SKIP             STA CIA2_PRA
SKIP             PLA
SKIP             ORA BSOUR
SKIP             STA CIA2_PRA
SKIP             LSR A
SKIP             LSR A
SKIP             AND #$f0
SKIP             ORA BSOUR
SKIP             STA CIA2_PRA
SKIP             LDA Vfc8a,X
SKIP             ORA BSOUR
SKIP             STA CIA2_PRA
SKIP             LSR A
SKIP             LSR A
SKIP             AND #$f0
SKIP             ORA BSOUR
SKIP             STA CIA2_PRA
SKIP             AND #15
SKIP             BIT TSFCNT
SKIP             BMI Bfc76
SKIP             ORA #16
SKIP          
SKIP          Bfc76
SKIP             STA CIA2_PRA
SKIP             PLA
SKIP             TAX
SKIP             LDA BSOUR
SKIP             ORA #16
SKIP             STA CIA2_PRA
SKIP             BIT CIA2_PRA
SKIP             BPL Bfc24
SKIP             JMP IEC_Timeout
SKIP          
SKIP          Vfc8a
SKIP             .BYTE $00,$80,$20,$a0,$40,$c0,$60,$e0
SKIP             .BYTE $10,$90,$30,$b0,$50,$d0,$70,$f0
SKIP          
SKIP          Jiffy_fc9a
SKIP             JSR JiDi_60
SKIP             JMP PrSe_10
SKIP          
              #endif
SKIP          
0001 FALSE    #if VIC
SKIP             TXA
SKIP             PHA
SKIP             LDA BSOUR
SKIP             LSR A
SKIP             LSR A
SKIP             LSR A
SKIP             LSR A
SKIP             TAX
SKIP             LDA JTABA,X
SKIP             PHA
SKIP             TXA
SKIP             LSR A
SKIP             LSR A
SKIP             TAX
SKIP             LDA JTABA,X
SKIP             STA TAPE1+1
SKIP             LDA BSOUR
SKIP             AND #15
SKIP             TAX
SKIP             LDA #2
SKIP          
SKIP          JAAI_10
SKIP             BIT VIA1_DATN
SKIP             BEQ JAAI_10
SKIP             LDA IEC_PCR
SKIP             AND #$dd
SKIP             STA DPSW
SKIP             PHA
SKIP             PLA
SKIP             PHA
SKIP             PLA
SKIP             STA IEC_PCR
SKIP             PLA
SKIP             ORA DPSW
SKIP             STA IEC_PCR
SKIP             LDA TAPE1+1
SKIP             ORA DPSW
SKIP             ORA DPSW
SKIP             STA IEC_PCR
SKIP             LDA JTABB,X
SKIP             ORA DPSW
SKIP             STA IEC_PCR
SKIP             LDA JTABC,X
SKIP             ORA DPSW
SKIP             NOP
SKIP             STA IEC_PCR
SKIP             AND #$dd
SKIP             BIT TSFCNT
SKIP             BMI JAAI_20
SKIP             ORA #2
SKIP          
SKIP          JAAI_20
SKIP             STA IEC_PCR 
SKIP             PLA
SKIP             TAX
SKIP             LDA DPSW
SKIP             ORA #2
SKIP             STA IEC_PCR
SKIP             LDA IEC_DRAN
SKIP             AND #2
SKIP             BEQ Bfc24
SKIP             JMP IEC_Timeout
SKIP          
SKIP          JTABA
SKIP             .byte $00,$02,$20,$22,$00,$02,$20,$22
SKIP             .byte $00,$02,$20,$22,$00,$02,$20,$22
SKIP          
              #endif
SKIP          
SKIP          
SKIP          ; *****************
SKIP            Jiffy_Destination
SKIP          ; *****************
SKIP          
SKIP             JSR Get_Next_Byte_Value
SKIP             STX MYCH
SKIP             RTS
SKIP          
SKIP          ; **********
SKIP            Jiffy_fca6
SKIP          ; **********
SKIP          
SKIP             JSR Jiffy_CHKIN_PTR2
SKIP          
SKIP          ; *****
SKIP            Jfca9
SKIP          ; *****
SKIP          
SKIP             JSR CHRIN
SKIP             STA (FNADR),Y
SKIP             INY
SKIP             BIT STATUS
SKIP             BVS Bfcbb
SKIP             CPY #$fe
SKIP             BCS Bfcbb
SKIP             CMP #1
SKIP             BCS Jfca9
SKIP          Bfcbb     RTS
SKIP          
SKIP          ; *************
SKIP            Jiffy_Disable
SKIP          ; *************
SKIP          
SKIP             LDX #5
SKIP          
SKIP          Bfcbe
SKIP             LDA Vf1a3,X
SKIP             STA IERROR,X
SKIP             DEX
SKIP             BPL Bfcbe
SKIP             STX PRTY
SKIP             RTS
SKIP          
0000 TRUE     #if C64
SKIP             .byte $a5,$a5,$01,$29,$fd,$85,$01
              #endif
SKIP          
0001 FALSE    #if VIC
SKIP             .byte $fd
SKIP          
SKIP             STA CINV
SKIP             LDA $fdea,X
SKIP             STA CINV+1
SKIP             RTS
SKIP          
SKIP             LDA VIA1_PCR
SKIP             ORA #$0e
SKIP             STA VIA1_PCR
SKIP             RTS
SKIP          
              #endif
SKIP          
              #else                ; JIFFY
              ; ********************
f726            TAPE_Find_Any_Header
              ; ********************

f726 a5 93       LDA VERCKK        ; get load/verify flag
f728 48          PHA               ; save load/verify flag
f729 20 3b f8    JSR TAPE_Init_Read
f72c 68          PLA               ; restore load/verify flag
f72d 85 93       STA VERCKK        ; save load/verify flag
f72f b0 32       BCS TFAH_Ret      ; exit if error
f731 a0 00       LDY #0
f733 b1 b2       LDA (TAPE1),Y     ; read first byte from tape buffer
f735 c9 05       CMP #$05          ; compare with logical end of the tape
f737 f0 2a       BEQ TFAH_Ret      ; exit if end of the tape
f739 c9 01       CMP #$01          ; compare with header for a relocatable program file
f73b f0 08       BEQ TFAH_10      ; branch if program file header
f73d c9 03       CMP #$03          ; compare with header for a non relocatable program file
f73f f0 04       BEQ TFAH_10      ; branch if program file header
f741 c9 04       CMP #$04          ; compare with data file header
f743 d0 e1       BNE TAPE_Find_Any_Header

f745          TFAH_10
f745 aa          TAX               ; copy header type
f746 24 9d       BIT MSGFLG        ; get message mode flag
f748 10 17       BPL TFAH_30      ; exit if control messages off
f74a a0 63       LDY #Msg_Found-Msg_Start
f74c 20 2f f1    JSR Display_Kernal_IO_Message
f74f a0 05       LDY #$05          ; index to tape filename

f751          TFAH_20
f751 b1 b2       LDA (TAPE1),Y     ; get byte from tape buffer
f753 20 cc ff    JSR CHROUT        ; Output a character
f756 c8          INY
f757 c0 15       CPY #$15          ; compare with end+1
f759 d0 f6       BNE TFAH_20      ; loop if more to do
0000 TRUE     #if C64
f75b a5 a1       LDA JIFFYM
f75d 20 e0 e4    JSR Delay_2JiffyM
f760 ea          NOP
              #endif

f761          TFAH_30
f761 18          CLC               ; flag no error
f762 88          DEY               ; decrement index

f763          TFAH_Ret
f763 60          RTS ;Size   62 [TAPE_Find_Any_Header]

              ; *****************
f764            TAPE_Write_Header
              ; *****************

f764 85 9e       STA PTR1          ; save header type
f766 20 ca f7    JSR TAPE_Get_Buffer_Address
f769 90 5e       BCC TWH_Ret       ; exit if < $0200
                 PUSHW(STAL)       ; push I/O start address
f76b a5 c2       LDA STAL+1
f76d 48          PHA
f76e a5 c1       LDA STAL
f770 48          PHA

                 PUSHW(EAL)        ; push tape end address
f771 a5 af       LDA EAL+1
f773 48          PHA
f774 a5 ae       LDA EAL
f776 48          PHA

f777 a0 bf       LDY #$BF          ; index to header end
f779 a9 20       LDA #' '          ; clear byte, [SPACE]

f77b          TWH_10
f77b 91 b2       STA (TAPE1),Y     ; clear header byte
f77d 88          DEY               ; decrement index
f77e d0 fb       BNE TWH_10        ; loop if more to do
f780 a5 9e       LDA PTR1          ; get header type back
f782 91 b2       STA (TAPE1),Y     ; write to header
f784 c8          INY
f785 a5 c1       LDA STAL          ; get I/O start address low byte
f787 91 b2       STA (TAPE1),Y     ; write to header
f789 c8          INY
f78a a5 c2       LDA STAL+1        ; get I/O start address high byte
f78c 91 b2       STA (TAPE1),Y     ; write to header
f78e c8          INY
f78f a5 ae       LDA EAL           ; get tape end address low byte
f791 91 b2       STA (TAPE1),Y     ; write to header
f793 c8          INY
f794 a5 af       LDA EAL+1         ; get tape end address high byte
f796 91 b2       STA (TAPE1),Y     ; write to header
f798 c8          INY
f799 84 9f       STY PTR2          ; save index
f79b a0 00       LDY #$00          ; clear Y
f79d 84 9e       STY PTR1          ; clear name index

f79f          TWH_20
f79f a4 9e       LDY PTR1          ; get name index
f7a1 c4 b7       CPY FNLEN         ; compare with file name length
f7a3 f0 0c       BEQ TWH_30        ; exit loop if all done
f7a5 b1 bb       LDA (FNADR ),Y    ; get file name byte
f7a7 a4 9f       LDY PTR2          ; get buffer index
f7a9 91 b2       STA (TAPE1),Y     ; save file name byte to buffer
f7ab e6 9e       INC PTR1          ; increment file name index
f7ad e6 9f       INC PTR2          ; increment tape buffer index
f7af d0 ee       BNE TWH_20        ; loop, branch always

f7b1          TWH_30
f7b1 20 d1 f7    JSR TAPE_Set_Buffer_Pointer
f7b4 a9 69       LDA #$69          ; set write lead cycle count
f7b6 85 ab       STA RIPRTY        ; save write lead cycle count
f7b8 20 65 f8    JSR TAPE_Write
f7bb a8          TAY
                 PULLW(EAL)
f7bc 68          PLA
f7bd 85 ae       STA EAL
f7bf 68          PLA
f7c0 85 af       STA EAL+1

                 PULLW(STAL)
f7c2 68          PLA
f7c3 85 c1       STA STAL
f7c5 68          PLA
f7c6 85 c2       STA STAL+1

f7c8 98          TYA

f7c9          TWH_Ret
f7c9 60          RTS ;Size  102 [TAPE_Write_Header]

              ; ***********************
f7ca            TAPE_Get_Buffer_Address
              ; ***********************

                 LDXY(TAPE1)       ; get tape buffer start pointer low byte
f7ca a6 b2       LDX TAPE1
f7cc a4 b3       LDY TAPE1+1

f7ce c0 02       CPY #2            ; compare high byte with $02xx
f7d0 60          RTS ;Size    7 [TAPE_Get_Buffer_Address]

              ; ***********************
f7d1            TAPE_Set_Buffer_Pointer
              ; ***********************

f7d1 20 ca f7    JSR TAPE_Get_Buffer_Address
f7d4 8a          TXA               ; copy tape buffer start pointer low byte
f7d5 85 c1       STA STAL          ; save as I/O address pointer low byte
f7d7 18          CLC
f7d8 69 c0       ADC #$C0          ; add buffer length low byte
f7da 85 ae       STA EAL           ; save tape buffer end pointer low byte
f7dc 98          TYA               ; copy tape buffer start pointer high byte
f7dd 85 c2       STA STAL+1        ; save as I/O address pointer high byte
f7df 69 00       ADC #$00          ; add buffer length high byte
f7e1 85 af       STA EAL+1         ; save tape buffer end pointer high byte
f7e3 60          RTS ;Size   19 [TAPE_Set_Buffer_Pointer]

              ; ********************
f7e4            TAPE_Find_Fileheader
              ; ********************

f7e4 20 26 f7    JSR TAPE_Find_Any_Header
f7e7 b0 1d       BCS TFF_Ret       ; just exit if error
f7e9 a0 05       LDY #$05          ; index to name
f7eb 84 9f       STY PTR2          ; save as tape buffer index
f7ed a0 00       LDY #$00          ; clear Y
f7ef 84 9e       STY PTR1          ; save as name buffer index

f7f1          TFF_10
f7f1 c4 b7       CPY FNLEN         ; compare with file name length
f7f3 f0 10       BEQ TFF_20        ; ok exit if match
f7f5 b1 bb       LDA (FNADR ),Y    ; get file name byte
f7f7 a4 9f       LDY PTR2          ; get index to tape buffer
f7f9 d1 b2       CMP (TAPE1),Y     ; compare with tape header name byte
f7fb d0 e7       BNE TAPE_Find_Fileheader
f7fd e6 9e       INC PTR1          ; else increment name buffer index
f7ff e6 9f       INC PTR2          ; increment tape buffer index
f801 a4 9e       LDY PTR1          ; get name buffer index
f803 d0 ec       BNE TFF_10        ; loop, branch always

f805          TFF_20
f805 18          CLC               ; flag ok

f806          TFF_Ret
f806 60          RTS ;Size   35 [TAPE_Find_Fileheader]

              ; ***************************
f807            TAPE_Advance_Buffer_Pointer
              ; ***************************

f807 20 ca f7    JSR TAPE_Get_Buffer_Address
f80a e6 a6       INC BUFPNT        ; increment tape buffer index
f80c a4 a6       LDY BUFPNT        ; get tape buffer index
f80e c0 c0       CPY #$C0          ; compare with buffer length
f810 60          RTS ;Size   10 [TAPE_Advance_Buffer_Pointer]

              ; *************
f811            Wait_For_Play
              ; *************

f811 20 28 f8    JSR TAPE_Sense
f814 f0 1a       BEQ TASe_10      ; exit if switch closed
f816 a0 1b       LDY #Msg_Play-Msg_Start

f818          WFP_10
f818 20 2f f1    JSR Display_Kernal_IO_Message

f81b          WFP_20
f81b 20 ca f8    JSR TAPE_Abort_On_STOP
f81e 20 28 f8    JSR TAPE_Sense
f821 d0 f8       BNE WFP_20        ; loop if cassette switch open
f823 a0 6a       LDY #Msg_ok-Msg_Start
f825 4c 2f f1    JMP Display_Kernal_IO_Message

              ; **********
f828            TAPE_Sense
              ; **********

0000 TRUE     #if C64
f828 a9 10       LDA #$10
f82a 24 01       BIT R6510
f82c d0 02       BNE TASe_10
f82e 24 01       BIT R6510
              #endif
0001 FALSE    #if VIC
SKIP             LDA #$40          ; mask for cassette switch
SKIP             BIT IEC_DRAN      ; test VIA 1 DRA, no handshake
SKIP             BNE TASe_10       ; branch if cassette sense high
SKIP             BIT IEC_DRAN      ; test VIA 1 DRA again
              #endif

f830          TASe_10
f830 18          CLC
f831 60          RTS ;Size   10 [TAPE_Sense]

              ; ********************
f832            TAPE_Wait_For_Record
              ; ********************

f832 20 28 f8    JSR TAPE_Sense
f835 f0 f9       BEQ TASe_10       ; exit if switch closed
f837 a0 2e       LDY #Msg_Record-Msg_Start
f839 d0 dd       BNE WFP_10        ; display message and wait for switch, branch always

              ; **************
f83b            TAPE_Init_Read
              ; **************

f83b a9 00       LDA #0
f83d 85 90       STA STATUS        ; clear serial status byte
f83f 85 93       STA VERCKK        ; clear the load/verify flag
f841 20 d1 f7    JSR TAPE_Set_Buffer_Pointer

              ; *********
f844            TAPE_Read
              ; *********

f844 20 11 f8    JSR Wait_For_Play
f847 b0 1f       BCS TAWR_10      ; exit if STOP was pressed, uses further BCS at target
f849 78          SEI               ; disable interrupts
f84a a9 00       LDA #0
f84c 85 aa       STA RIDATA        ;.
f84e 85 b4       STA BITTS         ;.
f850 85 b0       STA CMPO          ; clear tape timing constant min byte
f852 85 9e       STA PTR1          ; clear tape pass 1 error log/char buffer
f854 85 9f       STA PTR2          ; clear tape pass 2 error log corrected
f856 85 9c       STA DPSW          ; clear byte received flag
0000 TRUE     #if C64
f858 a9 90       LDA #$90
              #endif
0001 FALSE    #if VIC
SKIP             LDA #$82          ; enable CA1 interrupt
              #endif
f85a a2 0e       LDX #$0E          ; set index for tape read vector
f85c d0 11       BNE TAWR_20      ; go do tape read/write, branch always

              ; ***************
f85e            Init_Tape_Write
              ; ***************

f85e 20 d1 f7    JSR TAPE_Set_Buffer_Pointer

              ; ********************
f861            TAPE_Write_With_Lead
              ; ********************

f861 a9 14       LDA #20           ; set write lead cycle count
f863 85 ab       STA RIPRTY        ; save write lead cycle count

              ; **********
f865            TAPE_Write
              ; **********

f865 20 32 f8    JSR TAPE_Wait_For_Record

f868          TAWR_10
f868 b0 6c       BCS Clear_Saved_IRQ_Address
f86a 78          SEI               ; disable interrupts
0000 TRUE     #if C64
f86b a9 82       LDA #$82
              #endif
0001 FALSE    #if VIC
SKIP             LDA #$A0          ; enable VIA 2 T2 interrupt
              #endif
f86d a2 08       LDX #$08          ; set index for tape write tape leader vector

f86f          TAWR_20
f86f a0 7f       LDY #$7F          ; disable all interrupts
f871 8c 0d dc    STY VIA2_IER      ; set VIA 2 IER, disable interrupts
f874 8d 0d dc    STA VIA2_IER      ; set VIA 2 IER, enable interrupts according to A
0000 TRUE     #if C64
f877 ad 0e dc    LDA CIA1_CRA
f87a 09 19       ORA #$19
f87c 8d 0f dc    STA CIA1_CRB      ; CIA1 Control Register B
f87f 29 91       AND #$91
f881 8d a2 02    STA TODSNS
              #endif
f884 20 a4 f0    JSR RS232_Stop
0000 TRUE     #if C64
f887 ad 11 d0    LDA VIC_CONTROL_1
f88a 29 ef       AND #$EF          ; clear bit 8 of raster value
f88c 8d 11 d0    STA VIC_CONTROL_1
              #endif
f88f ad 14 03    LDA CINV          ; get IRQ vector low byte
f892 8d 9f 02    STA IRQTMP        ; save IRQ vector low byte
f895 ad 15 03    LDA CINV+1        ; get IRQ vector high byte
f898 8d a0 02    STA IRQTMP+1      ; save IRQ vector high byte
f89b 20 b7 fc    JSR TAPE_Set_IRQ_Vector
f89e a9 02       LDA #$02          ; set copies count. the first copy is the load copy, the
f8a0 85 be       STA FSBLK         ; save copies count
f8a2 20 91 fb    JSR TAPE_New_Byte_Setup
0000 TRUE     #if C64
f8a5 a5 01       LDA R6510
              #endif
0001 FALSE    #if VIC
SKIP             LDA VIA1_PCR      ; get VIA 1 PCR
              #endif
0000 TRUE     #if C64
f8a7 29 1f       AND #$1f
f8a9 85 01       STA R6510
              #endif
0001 FALSE    #if VIC
SKIP             AND #$FD          ; CA2 low, turn on tape motor
SKIP             ORA #$0C          ; manual output mode
SKIP             STA VIA1_PCR      ; set VIA 1 PCR
              #endif
f8ab 85 c0       STA CAS1          ; set tape motor interlock
f8ad a2 ff       LDX #$FF          ; outer loop count

f8af          TAWR_30
f8af a0 ff       LDY #$FF          ; inner loop count

f8b1          TAWR_40
f8b1 88          DEY               ; decrement inner loop count
f8b2 d0 fd       BNE TAWR_40      ; loop if more to do
f8b4 ca          DEX               ; decrement outer loop count
f8b5 d0 f8       BNE TAWR_30      ; loop if more to do
0001 FALSE    #if VIC
SKIP             STA VIA2_T2CH     ; set VIA 2 T2C_h
              #endif
f8b7 58          CLI               ; enable tape interrupts

f8b8          TAWR_50
f8b8 ad a0 02    LDA IRQTMP+1      ; get saved IRQ high byte
f8bb cd 15 03    CMP CINV+1        ; compare with the current IRQ high byte
f8be 18          CLC               ; flag ok
f8bf f0 15       BEQ Clear_Saved_IRQ_Address
f8c1 20 ca f8    JSR TAPE_Abort_On_STOP
0000 TRUE     #if C64
f8c4 20 b6 f6    JSR Look_For_Special_Keys
              #endif
0001 FALSE    #if VIC
SKIP             LDA IEC_IFR       ; get VIA 2 IFR
SKIP             AND #$40          ; mask T1 interrupt
SKIP             BEQ TAWR_50      ; loop if not T1 interrupt
SKIP             LDA RS2_TIM_LOW   ; get VIA 1 T1C_l, clear T1 flag
SKIP             JSR Kernal_UDTIM  ; Update the system clock
              #endif
f8c7 4c b8 f8    JMP TAWR_50      ; loop

              ; ******************
f8ca            TAPE_Abort_On_STOP
              ; ******************

f8ca 20 db ff    JSR STOP          ; Check if stop key is pressed
f8cd 18          CLC               ; flag no stop
f8ce d0 0b       BNE CSIA_Ret      ; exit if no stop
f8d0 20 8d fc    JSR Restoring_After_STOP
f8d3 38          SEC               ; flag stopped
f8d4 68          PLA               ; dump return address low byte
f8d5 68          PLA               ; dump return address high byte

              ; =======================
f8d6            Clear_Saved_IRQ_Address
              ; =======================

f8d6 a9 00       LDA #0
f8d8 8d a0 02    STA IRQTMP+1      ; clear saved IRQ address high byte

f8db          CSIA_Ret
f8db 60          RTS ;Size   18 [TAPE_Abort_On_STOP]

              ; **************
f8dc            TAPE_Set_Timer
              ; **************

f8dc 86 b1       STX CMPO+1        ; save tape timing constant max byte
f8de a5 b0       LDA CMPO          ; get tape timing constant min byte
f8e0 0a          ASL A             ; *2
f8e1 0a          ASL A             ; *4
f8e2 18          CLC
f8e3 65 b0       ADC CMPO          ; add tape timing constant min byte *5
f8e5 18          CLC
f8e6 65 b1       ADC CMPO+1        ; add tape timing constant max byte
f8e8 85 b1       STA CMPO+1        ; save tape timing constant max byte
f8ea a9 00       LDA #$00          ;.
f8ec 24 b0       BIT CMPO          ; test tape timing constant min byte
f8ee 30 01       BMI TST_10        ; branch if b7 set
f8f0 2a          ROL A             ; else shift carry into ??

f8f1          TST_10
f8f1 06 b1       ASL CMPO+1        ; shift tape timing constant max byte
f8f3 2a          ROL A
f8f4 06 b1       ASL CMPO+1        ; shift tape timing constant max byte
f8f6 2a          ROL A
f8f7 aa          TAX

f8f8          TST_20
f8f8 ad 06 dc    LDA VIA2_T2CL     ; get VIA 2 T2C_l
0000 TRUE     #if C64
f8fb c9 16       CMP #$16
              #endif
0001 FALSE    #if VIC
SKIP             CMP #$15
              #endif
f8fd 90 f9       BCC TST_20        ; loop if less
f8ff 65 b1       ADC CMPO+1        ; add tape timing constant max byte
f901 8d 04 dc    STA VIA2_T1CL     ; set VIA 2 T1C_l
f904 8a          TXA
f905 6d 07 dc    ADC VIA2_T2CH     ; add VIA 2 T2C_h
f908 8d 05 dc    STA VIA2_T1CH     ; set VIA 2 T1C_h
0000 TRUE     #if C64
f90b ad a2 02    LDA TODSNS
f90e 8d 0e dc    STA CIA1_CRA
f911 8d a4 02    STA TD1IRQ
f914 ad 0d dc    LDA CIA1_ICR      ; CIA1 Interrupt Control Register
f917 29 10       AND #$10
f919 f0 09       BEQ TST_30
f91b a9 f9       LDA #>TST_30
f91d 48          PHA
f91e a9 24       LDA #<TST_30
f920 48          PHA
f921 4c 3d ff    JMP Clear_BREAK_Flag

f924          TST_30
              #endif
f924 58          CLI
f925 60          RTS ;Size   74 [TAPE_Set_Timer]


              ;**********************************************************************;
              ;
              ;   On Commodore computers, the streams consist of four kinds of symbols
              ;   that denote different kinds of low-to-high-to-low transitions on the
              ;   read or write signals of the Commodore cassette interface.
              ;
              ;   A A break in the communications, or a pulse with very long cycle
              ;      time.
              ;
              ;   B A short pulse, whose cycle time typically ranges from 296 to 424
              ;      microseconds, depending on the computer model.
              ;
              ;   C A medium-length pulse, whose cycle time typically ranges from
              ;      440 to 576 microseconds, depending on the computer model.
              ;
              ;   D A long pulse, whose cycle time typically ranges from 600 to 744
              ;      microseconds, depending on the computer model.
              ;
              ;   The actual interpretation of the serial data takes a little more work to
              ; explain. The typical ROM tape loader (and the turbo loaders) will
              ; initialize a timer with a specified value and start it counting down. If
              ; either the tape data changes or the timer runs out, an IRQ will occur. The
              ; loader will determine which condition caused the IRQ. If the tape data
              ; changed before the timer ran out, we have a short pulse, or a "0" bit. If
              ; the timer ran out first, we have a long pulse, or a "1" bit. Doing this
              ; continuously and we decode the entire file.
              ; read tape bits, IRQ routine
              ; read T2C which has been counting down from $FFFF. subtract this from $FFFF

              ; *************
f926            TAPE_Read_IRQ
              ; *************

f926 ae 07 dc    LDX VIA2_T2CH     ; get VIA 2 T2C_h
f929 a0 ff       LDY #$FF
f92b 98          TYA
f92c ed 06 dc    SBC VIA2_T2CL     ; subtract VIA 2 T2C_l
f92f ec 07 dc    CPX VIA2_T2CH     ; compare VIA 2 T2C_h with previous
f932 d0 f2       BNE TAPE_Read_IRQ ; loop if timer low byte rolled over
f934 86 b1       STX CMPO+1        ; save tape timing constant max byte
f936 aa          TAX               ; copy $FF - T2C_l
f937 8c 06 dc    STY VIA2_T2CL     ; set VIA 2 T2C_l to $FF
f93a 8c 07 dc    STY VIA2_T2CH     ; set VIA 2 T2C_h to $FF
0000 TRUE     #if C64
f93d a9 19       LDA #$19
f93f 8d 0f dc    STA CIA1_CRB      ; CIA1 Control Register B
f942 ad 0d dc    LDA CIA1_ICR      ; CIA1 Interrupt Control Register
f945 8d a3 02    STA TRDTMP
              #endif
f948 98          TYA
f949 e5 b1       SBC CMPO+1        ; subtract tape timing constant max byte
f94b 86 b1       STX CMPO+1        ; save tape timing constant max byte
f94d 4a          LSR A             ; A = $FF - T2C_h >> 1
f94e 66 b1       ROR CMPO+1        ; shift tape timing constant max byte
f950 4a          LSR A             ; A = $FF - T2C_h >> 1
f951 66 b1       ROR CMPO+1        ; shift tape timing constant max byte
f953 a5 b0       LDA CMPO          ; get tape timing constant min byte
f955 18          CLC
f956 69 3c       ADC #$3C
0001 FALSE    #if VIC
SKIP             BIT KEYB_ROW      ; test VIA 2 DRA, keyboard row
              #endif
f958 c5 b1       CMP CMPO+1        ; compare with tape timing constant max byte
f95a b0 4a       BCS TARI_14       ; branch if min + $3C >= ($FFFF - T2C) >> 2
f95c a6 9c       LDX DPSW          ; get byte received flag
f95e f0 03       BEQ TARI_02       ; branch if not byte received
f960 4c 5a fa    JMP TAPE_Store_Char      ; store tape character

f963          TARI_02
f963 a6 a3       LDX TSFCNT        ; get EOI flag byte
f965 30 1b       BMI TARI_04
f967 a2 00       LDX #$00
f969 69 30       ADC #$30
f96b 65 b0       ADC CMPO          ; add tape timing constant min byte
f96d c5 b1       CMP CMPO+1        ; compare with tape timing constant max byte
f96f b0 1c       BCS TARI_08
f971 e8          INX
f972 69 26       ADC #$26
f974 65 b0       ADC CMPO          ; add tape timing constant min byte
f976 c5 b1       CMP CMPO+1        ; compare with tape timing constant max byte
f978 b0 17       BCS TARI_10
f97a 69 2c       ADC #$2C
f97c 65 b0       ADC CMPO          ; add tape timing constant min byte
f97e c5 b1       CMP CMPO+1        ; compare with tape timing constant max byte
f980 90 03       BCC TARI_06

f982          TARI_04
f982 4c 0a fa    JMP TARI_30

f985          TARI_06
f985 a5 b4       LDA BITTS         ; get bit count
f987 f0 1d       BEQ TARI_14       ; branch if zero
f989 85 a8       STA BITCI         ; save receiver bit count in
f98b d0 19       BNE TARI_14       ; branch always

f98d          TARI_08
f98d e6 a9       INC RINONE        ; increment ?? start bit check flag
f98f b0 02       BCS TARI_12

f991          TARI_10
f991 c6 a9       DEC RINONE        ; decrement ?? start bit check flag

f993          TARI_12
f993 38          SEC
f994 e9 13       SBC #$13
f996 e5 b1       SBC CMPO+1        ; subtract tape timing constant max byte
f998 65 92       ADC SVXT          ; add timing constant for tape
f99a 85 92       STA SVXT          ; save timing constant for tape
f99c a5 a4       LDA TBTCNT        ; get tape bit cycle phase
f99e 49 01       EOR #$01
f9a0 85 a4       STA TBTCNT        ; save tape bit cycle phase
f9a2 f0 2b       BEQ TARI_22
f9a4 86 d7       STX LASTKY

f9a6          TARI_14
f9a6 a5 b4       LDA BITTS         ; get bit count
f9a8 f0 22       BEQ TARI_20       ; exit if zero

0000 TRUE     #if C64
f9aa ad a3 02    LDA TRDTMP
f9ad 29 01       AND #1
f9af d0 05       BNE TARI_16
f9b1 ad a4 02    LDA TD1IRQ
f9b4 d0 16       BNE TARI_20

f9b6          TARI_16
              #endif
0001 FALSE    #if VIC  
SKIP             BIT IEC_IFR       ; test get 2 IFR
SKIP             BVC TARI_20       ; exit if no T1 interrupt
              #endif
f9b6 a9 00       LDA #$00
f9b8 85 a4       STA TBTCNT        ; clear tape bit cycle phase
0000 TRUE     #if C64
f9ba 8d a4 02    STA TD1IRQ
              #endif
f9bd a5 a3       LDA TSFCNT        ;.get EOI flag byte
f9bf 10 30       BPL TARI_28
f9c1 30 bf       BMI TARI_04

f9c3          TARI_18
f9c3 a2 a6       LDX #$A6          ; set timimg max byte
f9c5 20 dc f8    JSR TAPE_Set_Timer
f9c8 a5 9b       LDA PRTY
f9ca d0 b9       BNE TARI_06

f9cc          TARI_20
f9cc 4c b6 fe    JMP Exit_IRQ      ; restore registers and exit interrupt

f9cf          TARI_22
f9cf a5 92       LDA SVXT          ; get timing constant for tape
f9d1 f0 07       BEQ TARI_26
f9d3 30 03       BMI TARI_24
f9d5 c6 b0       DEC CMPO          ; decrement tape timing constant min byte
f9d7 2c          .byte   $2C

f9d8          TARI_24
f9d8 e6 b0       INC CMPO          ; increment tape timing constant min byte

f9da          TARI_26
f9da a9 00       LDA #0
f9dc 85 92       STA SVXT          ; clear timing constant for tape
f9de e4 d7       CPX LASTKY
f9e0 d0 0f       BNE TARI_28
f9e2 8a          TXA
f9e3 d0 a0       BNE TARI_06
f9e5 a5 a9       LDA RINONE        ; get start bit check flag
f9e7 30 bd       BMI TARI_14
f9e9 c9 10       CMP #$10
f9eb 90 b9       BCC TARI_14
f9ed 85 96       STA SYNO          ; save cassette block synchronization number
f9ef b0 b5       BCS TARI_14

f9f1          TARI_28
f9f1 8a          TXA
f9f2 45 9b       EOR PRTY
f9f4 85 9b       STA PRTY
f9f6 a5 b4       LDA BITTS
f9f8 f0 d2       BEQ TARI_20
f9fa c6 a3       DEC TSFCNT        ; decrement EOI flag byte
f9fc 30 c5       BMI TARI_18
f9fe 46 d7       LSR LASTKY
fa00 66 bf       ROR MYCH          ; parity count
fa02 a2 da       LDX #$DA          ; set timimg max byte
fa04 20 dc f8    JSR TAPE_Set_Timer
fa07 4c b6 fe    JMP Exit_IRQ      ; restore registers and exit interrupt

fa0a          TARI_30
fa0a a5 96       LDA SYNO          ; get cassette block synchronization number
fa0c f0 04       BEQ TARI_32
fa0e a5 b4       LDA BITTS
fa10 f0 07       BEQ TARI_34

fa12          TARI_32
fa12 a5 a3       LDA TSFCNT        ; get EOI flag byte
0000 TRUE     #if C64
fa14 30 03       BMI TARI_34
fa16 4c 91 f9    JMP TARI_10
              #endif
0001 FALSE    #if VIC
SKIP             BPL TARI_10
              #endif

fa19          TARI_34
fa19 46 b1       LSR CMPO+1        ; shift tape timing constant max byte
fa1b a9 93       LDA #$93
fa1d 38          SEC
fa1e e5 b1       SBC CMPO+1        ; subtract tape timing constant max byte
fa20 65 b0       ADC CMPO          ; add tape timing constant min byte
fa22 0a          ASL A
fa23 aa          TAX               ; copy timimg high byte
fa24 20 dc f8    JSR TAPE_Set_Timer      ; set timing
fa27 e6 9c       INC DPSW
fa29 a5 b4       LDA BITTS
fa2b d0 11       BNE TARI_36
fa2d a5 96       LDA SYNO          ; get cassette block synchronization number
fa2f f0 26       BEQ TARI_40
fa31 85 a8       STA BITCI         ; save receiver bit count in
fa33 a9 00       LDA #$00
fa35 85 96       STA SYNO          ; clear cassette block synchronization number
0000 TRUE     #if C64
fa37 a9 81       LDA #$81
              #endif
0001 FALSE    #if VIC
SKIP             LDA #$C0          ; enable T1 interrupt
              #endif
fa39 8d 0d dc    STA VIA2_IER      ; set VIA 2 IER
fa3c 85 b4       STA BITTS

fa3e          TARI_36
fa3e a5 96       LDA SYNO          ; get cassette block synchronization number
fa40 85 b5       STA NXTBIT
fa42 f0 09       BEQ TARI_38
fa44 a9 00       LDA #$00
fa46 85 b4       STA BITTS
0000 TRUE     #if C64
fa48 a9 01       LDA #1
              #endif
0001 FALSE    #if VIC
SKIP             LDA #$40          ; disable T1 interrupt
              #endif
fa4a 8d 0d dc    STA VIA2_IER      ; set VIA 2 IER

fa4d          TARI_38
fa4d a5 bf       LDA MYCH          ; parity count
fa4f 85 bd       STA ROPRTY        ; save RS232 parity byte
fa51 a5 a8       LDA BITCI         ; get receiver bit count in
fa53 05 a9       ORA RINONE        ; OR with start bit check flag
fa55 85 b6       STA RODATA

fa57          TARI_40
fa57 4c b6 fe    JMP Exit_IRQ      ; restore registers and exit interrupt

              ; ===============
fa5a            TAPE_Store_Char
              ; ===============

fa5a 20 91 fb    JSR TAPE_New_Byte_Setup
fa5d 85 9c       STA DPSW          ; clear byte received flag
fa5f a2 da       LDX #$DA          ; set timimg max byte
fa61 20 dc f8    JSR TAPE_Set_Timer
fa64 a5 be       LDA FSBLK         ; get copies count
fa66 f0 02       BEQ TASC_10
fa68 85 a7       STA INBIT         ; save receiver input bit temporary storage

fa6a          TASC_10
fa6a a9 0f       LDA #$0F
fa6c 24 aa       BIT RIDATA
fa6e 10 17       BPL TASC_40
fa70 a5 b5       LDA NXTBIT
fa72 d0 0c       BNE TASC_20
fa74 a6 be       LDX FSBLK         ; get copies count
fa76 ca          DEX
fa77 d0 0b       BNE TASC_30       ; if ?? restore registers and exit interrupt
fa79 a9 08       LDA #$08          ; set short block
fa7b 20 16 fe    JSR Ora_Status
fa7e d0 04       BNE TASC_30       ; restore registers and exit interrupt, branch always

fa80          TASC_20
fa80 a9 00       LDA #$00
fa82 85 aa       STA RIDATA

fa84          TASC_30
fa84 4c b6 fe    JMP Exit_IRQ      ; restore registers and exit interrupt

fa87          TASC_40
fa87 70 31       BVS TASC_64
fa89 d0 18       BNE TASC_60
fa8b a5 b5       LDA NXTBIT
fa8d d0 f5       BNE TASC_30
fa8f a5 b6       LDA RODATA
fa91 d0 f1       BNE TASC_30
fa93 a5 a7       LDA INBIT         ; get receiver input bit temporary storage
fa95 4a          LSR A
fa96 a5 bd       LDA ROPRTY        ; get RS232 parity byte
fa98 30 03       BMI TASC_50
fa9a 90 18       BCC TASC_62
fa9c 18          CLC

fa9d          TASC_50
fa9d b0 15       BCS TASC_62
fa9f 29 0f       AND #$0F
faa1 85 aa       STA RIDATA

faa3          TASC_60
faa3 c6 aa       DEC RIDATA
faa5 d0 dd       BNE TASC_30
faa7 a9 40       LDA #$40
faa9 85 aa       STA RIDATA
faab 20 88 fb    JSR Set_IO_Start
faae a9 00       LDA #0
fab0 85 ab       STA RIPRTY
fab2 f0 d0       BEQ TASC_30      ; branch always

fab4          TASC_62
fab4 a9 80       LDA #$80
fab6 85 aa       STA RIDATA
fab8 d0 ca       BNE TASC_30      ; restore registers and exit interrupt, branch always

faba          TASC_64
faba a5 b5       LDA NXTBIT
fabc f0 0a       BEQ TASC_66

fabe          TASC_65
fabe a9 04       LDA #$04
fac0 20 16 fe    JSR Ora_Status
fac3 a9 00       LDA #$00
fac5 4c 44 fb    JMP TASC_84

fac8          TASC_66
fac8 20 cb fc    JSR Check_IO_End
facb 90 03       BCC TASC_68
facd 4c 42 fb    JMP TASC_82

fad0          TASC_68
fad0 a6 a7       LDX INBIT         ; get receiver input bit temporary storage
fad2 ca          DEX
fad3 f0 2d       BEQ TASC_72
fad5 a5 93       LDA VERCKK
fad7 f0 0c       BEQ TASC_70
fad9 a0 00       LDY #0
fadb a5 bd       LDA ROPRTY
fadd d1 ac       CMP (SAL),Y
fadf f0 04       BEQ TASC_70
fae1 a9 01       LDA #$01
fae3 85 b6       STA RODATA

fae5          TASC_70
fae5 a5 b6       LDA RODATA
fae7 f0 4b       BEQ TASC_78
fae9 a2 3d       LDX #$3D
faeb e4 9e       CPX PTR1
faed 90 3e       BCC TASC_76
faef a6 9e       LDX PTR1
faf1 a5 ad       LDA SAL+1
faf3 9d 01 01    STA STACK+1,X
faf6 a5 ac       LDA SAL
faf8 9d 00 01    STA STACK,X
fafb e8          INX
fafc e8          INX
fafd 86 9e       STX PTR1
faff 4c 34 fb    JMP TASC_78

fb02          TASC_72
fb02 a6 9f       LDX PTR2
fb04 e4 9e       CPX PTR1
fb06 f0 35       BEQ TASC_80
fb08 a5 ac       LDA SAL
fb0a dd 00 01    CMP STACK,X
fb0d d0 2e       BNE TASC_80
fb0f a5 ad       LDA SAL+1
fb11 dd 01 01    CMP STACK+1,X
fb14 d0 27       BNE TASC_80
fb16 e6 9f       INC PTR2
fb18 e6 9f       INC PTR2
fb1a a5 93       LDA VERCKK        ; get load/verify flag
fb1c f0 0b       BEQ TASC_74      ; branch if load
fb1e a5 bd       LDA ROPRTY        ; get RS232 parity byte
fb20 a0 00       LDY #$00
fb22 d1 ac       CMP (SAL),Y
fb24 f0 17       BEQ TASC_80
fb26 c8          INY
fb27 84 b6       STY RODATA

fb29          TASC_74
fb29 a5 b6       LDA RODATA
fb2b f0 07       BEQ TASC_78

fb2d          TASC_76
fb2d a9 10       LDA #$10
fb2f 20 16 fe    JSR Ora_Status
fb32 d0 09       BNE TASC_80

fb34          TASC_78
fb34 a5 93       LDA VERCKK        ; get load/verify flag
fb36 d0 05       BNE TASC_80       ; branch if verify
fb38 a8          TAY
fb39 a5 bd       LDA ROPRTY        ; get RS232 parity byte
fb3b 91 ac       STA (SAL),Y

fb3d          TASC_80
fb3d 20 d5 fc    JSR Inc_SAL_Word
fb40 d0 43       BNE TASC_92      ; restore registers and exit interrupt, branch always

fb42          TASC_82
fb42 a9 80       LDA #$80

fb44          TASC_84
fb44 85 aa       STA RIDATA
0000 TRUE     #if C64
fb46 78          SEI
fb47 a2 01       LDX #1
fb49 8e 0d dc    STX CIA1_ICR      ; CIA1 Interrupt Control Register
fb4c ae 0d dc    LDX CIA1_ICR      ; CIA1 Interrupt Control Register
              #endif
fb4f a6 be       LDX FSBLK         ; get copies count
fb51 ca          DEX
fb52 30 02       BMI TASC_86
fb54 86 be       STX FSBLK         ; save copies count

fb56          TASC_86
fb56 c6 a7       DEC INBIT         ; decrement receiver input bit temporary storage
fb58 f0 08       BEQ TASC_88
fb5a a5 9e       LDA PTR1
fb5c d0 27       BNE TASC_92       ; if ?? restore registers and exit interrupt
fb5e 85 be       STA FSBLK         ; save copies count
fb60 f0 23       BEQ TASC_92       ; restore registers and exit interrupt, branch always

fb62          TASC_88
fb62 20 8d fc    JSR Restoring_After_STOP
fb65 20 88 fb    JSR Set_IO_Start
fb68 a0 00       LDY #0
fb6a 84 ab       STY RIPRTY        ; clear checksum

fb6c          TASC_90
fb6c b1 ac       LDA (SAL),Y       ; get byte from buffer
fb6e 45 ab       EOR RIPRTY        ; XOR with checksum
fb70 85 ab       STA RIPRTY        ; save new checksum
fb72 20 d5 fc    JSR Inc_SAL_Word
fb75 20 cb fc    JSR Check_IO_End
fb78 90 f2       BCC TASC_90       ; loop if not at end
fb7a a5 ab       LDA RIPRTY        ; get computed checksum
fb7c 45 bd       EOR ROPRTY        ; compare with stored checksum ??
fb7e f0 05       BEQ TASC_92       ; if checksum ok restore registers and exit interrupt
fb80 a9 20       LDA #$20          ; else set checksum error
fb82 20 16 fe    JSR Ora_Status

fb85          TASC_92
fb85 4c b6 fe    JMP Exit_IRQ      ; restore registers and exit interrupt

              ; ************
fb88            Set_IO_Start
              ; ************
fb88 a5 c2       LDA STAL+1        ; get I/O start address high byte
fb8a 85 ad       STA SAL+1         ; set buffer address high byte
fb8c a5 c1       LDA STAL          ; get I/O start address low byte
fb8e 85 ac       STA SAL           ; set buffer address low byte
fb90 60          RTS ;Size    9 [Set_IO_Start]

              ; *******************
fb91            TAPE_New_Byte_Setup
              ; *******************

fb91 a9 08       LDA #$08          ; eight bits to do
fb93 85 a3       STA TSFCNT        ; set bit count
fb95 a9 00       LDA #0
fb97 85 a4       STA TBTCNT        ; clear tape bit cycle phase
fb99 85 a8       STA BITCI         ; clear start bit first cycle done flag
fb9b 85 9b       STA PRTY          ; clear byte parity
fb9d 85 a9       STA RINONE        ; clear start bit check flag, set no start bit yet
fb9f 60          RTS ;Size   15 [TAPE_New_Byte_Setup]

              ; **************
fba0            TAPE_Write_Bit
              ; **************

              ; this routine tests the least significant bit in the tape write byte
              ; and sets VIA 2 T2 depending on the state of the bit. if the bit is a 1
              ; a time of $00B0 cycles is set, if the bot is a 0 a time of $0060
              ; cycles is set. note that this routine does not shift the bits of the
              ; tape write byte but uses a copy of that byte, the byte itself is
              ; shifted elsewhere

fba0 a5 bd       LDA ROPRTY        ; get tape write byte
fba2 4a          LSR A             ; shift lsb into Cb
fba3 a9 60       LDA #$60          ; set time constant low byte for bit = 0
fba5 90 02       BCC TAPE_Write_Timer

              ; *******************
fba7            TAPE_Timer_Bit_Is_1
              ; *******************

fba7 a9 b0       LDA #$B0          ; set time constant low byte for bit = 1

              ; ****************
fba9            TAPE_Write_Timer
              ; ****************

fba9 a2 00       LDX #$00          ; set time constant high byte

              ; ****************
fbab            TAPE_Start_Timer
              ; ****************

fbab 8d 06 dc    STA VIA2_T2CL     ; set VIA 2 T2C_l
fbae 8e 07 dc    STX VIA2_T2CH     ; set VIA 2 T2C_h
0000 TRUE     #if C64
fbb1 ad 0d dc    LDA CIA1_ICR    ; CIA1 Interrupt Control Register
fbb4 a9 19       LDA #$19
fbb6 8d 0f dc    STA CIA1_CRB    ; CIA1 Control Register B
fbb9 a5 01       LDA R6510
              #endif
0001 FALSE    #if VIC
SKIP             LDA KEYB_COL      ; get VIA 2 DRB, keyboard column
              #endif
fbbb 49 08       EOR #$08          ; toggle tape out bit
0000 TRUE     #if C64
fbbd 85 01        STA R6510
              #endif
0001 FALSE    #if VIC
SKIP             STA KEYB_COL      ; set VIA 2 DRB
              #endif
fbbf 29 08       AND #$08          ; mask tape out bit
fbc1 60          RTS ;Size   23 [TAPE_Start_Timer]

fbc2          TAST_10
fbc2 38          SEC               ; set carry flag
0000 TRUE     #if C64
fbc3 66 b6       ROR RODATA
              #endif
0001 FALSE    #if VIC
SKIP             ROR SAL+1         ; set buffer address high byte negative, flag all sync,
              #endif
fbc5 30 3c       BMI TAWI_15      ; restore registers and exit interrupt, branch always

              ; **************
fbc7            TAPE_Write_IRQ
              ; **************

              ; this is the routine that writes the bits to the tape. it is called each time VIA 2 T2
              ; times out and checks if the start bit is done, if so checks if the data bits are done,
              ; if so it checks if the byte is done, if so it checks if the synchronisation bytes are
              ; done, if so it checks if the data bytes are done, if so it checks if the checksum byte
              ; is done, if so it checks if both the load and verify copies have been done, if so it
              ; stops the tape

fbc7 a5 a8       LDA BITCI         ; get start bit first cycle done flag
fbc9 d0 12       BNE TAWI_05       ; if first cycle done go do rest of byte

              ; each byte sent starts with two half cycles of $0110 ststem clocks and the whole block
              ; ends with two more such half cycles

fbcb a9 10       LDA #$10          ; set first start cycle time constant low byte
fbcd a2 01       LDX #$01          ; set first start cycle time constant high byte
fbcf 20 ab fb    JSR TAPE_Start_Timer
fbd2 d0 2f       BNE TAWI_15      ; if first half cycle go restore registers and exit
fbd4 e6 a8       INC BITCI         ; set start bit first start cycle done flag
0000 TRUE     #if C64
fbd6 a5 b6       LDA RODATA
              #endif
0001 FALSE    #if VIC
SKIP             LDA SAL+1         ; get buffer address high byte
              #endif
fbd8 10 29       BPL TAWI_15      ; if block not complete go restore registers and exit
fbda 4c 51 fc    JMP TAWI_55      ; else do tape routine, block complete exit

              ; continue tape byte write. the first start cycle, both half cycles of it, is complete
              ; so the routine drops straight through to here

fbdd          TAWI_05
fbdd a5 a9       LDA RINONE        ; get start bit check flag
fbdf d0 09       BNE TAWI_10       ; if the start bit is complete go send the byte bits

              ; after the two half cycles of $0110 ststem clocks the start bit is completed with two
              ; half cycles of $00B0 system clocks. this is the same as the first part of a 1 bit

fbe1 20 a7 fb    JSR TAPE_Timer_Bit_Is_1
fbe4 d0 1d       BNE TAWI_15       ; if first half cycle go restore registers and exit
fbe6 e6 a9       INC RINONE        ; set start bit check flag
fbe8 d0 19       BNE TAWI_15       ; restore registers and exit interrupt, branch always

              ; continue tape byte write. the start bit, both cycles of it, is complete so the routine
              ; drops straight through to here. now the cycle pairs for each bit, and the parity bit,
              ; are sent

fbea          TAWI_10
fbea 20 a0 fb    JSR TAPE_Write_Bit
fbed d0 14       BNE TAWI_15       ; if first half cycle go restore registers and exit
fbef a5 a4       LDA TBTCNT        ; get tape bit cycle phase
fbf1 49 01       EOR #$01          ; toggle b0
fbf3 85 a4       STA TBTCNT        ; save tape bit cycle phase
fbf5 f0 0f       BEQ TAWI_20       ; if bit cycle phase complete go setup for next bit

              ; each bit is written as two full cycles. a 1 is sent as a full cycle of $0160 system
              ; clocks then a full cycle of $00C0 system clocks. a 0 is sent as a full cycle of $00C0
              ; system clocks then a full cycle of $0160 system clocks. to do this each bit from the
              ; write byte is inverted during the second bit cycle phase. as the bit is inverted it
              ; is also added to the, one bit, parity count for this byte

fbf7 a5 bd       LDA ROPRTY        ; get tape write byte
fbf9 49 01       EOR #$01          ; invert bit being sent
fbfb 85 bd       STA ROPRTY        ; save tape write byte
fbfd 29 01       AND #$01          ; mask b0
fbff 45 9b       EOR PRTY          ; EOR with tape write byte parity bit
fc01 85 9b       STA PRTY          ; save tape write byte parity bit

fc03          TAWI_15
fc03 4c b6 fe    JMP Exit_IRQ      ; restore registers and exit interrupt

              ; the bit cycle phase is complete so shift out the just written bit and test for byte
              ; end

fc06          TAWI_20
fc06 46 bd       LSR ROPRTY        ; shift bit out of tape write byte
fc08 c6 a3       DEC TSFCNT        ; decrement tape write bit count
fc0a a5 a3       LDA TSFCNT        ; get tape write bit count
fc0c f0 3a       BEQ TAWI_45       ; if all the data bits have been written go setup for
fc0e 10 f3       BPL TAWI_15       ; if all the data bits are not yet sent just restore the

              ; do next tape byte
              ; the byte is complete. the start bit, data bits and parity bit have been written to
              ; the tape so setup for the next byte

fc10          TAWI_25
fc10 20 91 fb    JSR TAPE_New_Byte_Setup
fc13 58          CLI               ; enable interrupts
fc14 a5 a5       LDA CNTDN         ; get cassette synchronization character count
fc16 f0 12       BEQ TAWI_35       ; if synchronisation characters done go do block data

              ; at the start of each block sent to tape there are a number of synchronisation bytes
              ; that count down to the actual data. the commodore tape system saves two copies of all
              ; the tape data, the first is loaded and is indicated by the synchronisation bytes
              ; having b7 set, and the second copy is indicated by the synchronisation bytes having b7
              ; clear. the sequence goes $09, $08, ..... $02, $01, data bytes

fc18 a2 00       LDX #$00          ; clear X
fc1a 86 d7       STX LASTKY        ; clear checksum byte
fc1c c6 a5       DEC CNTDN         ; decrement cassette synchronization byte count
fc1e a6 be       LDX FSBLK         ; get cassette copies count
fc20 e0 02       CPX #$02          ; compare with load block indicator
fc22 d0 02       BNE TAWI_30       ; branch if not the load block
fc24 09 80       ORA #$80          ; this is the load block so make the synchronisation count
                                   ; go $89, $88, ..... $82, $81
fc26          TAWI_30
fc26 85 bd       STA ROPRTY        ; save the synchronisation byte as the tape write byte
fc28 d0 d9       BNE TAWI_15       ; restore registers and exit interrupt, branch always

              ; the synchronization bytes have been done so now check and do the actual block data

fc2a          TAWI_35
fc2a 20 cb fc    JSR Check_IO_End
fc2d 90 0a       BCC TAWI_40       ; if not all done yet go get the byte to send
fc2f d0 91       BNE TAST_10       ; if pointer > end go flag block done and exit interrupt
fc31 e6 ad       INC SAL+1         ; increment buffer pointer high byte, this means the block
fc33 a5 d7       LDA LASTKY        ; get checksum byte
fc35 85 bd       STA ROPRTY        ; save checksum as tape write byte
fc37 b0 ca       BCS TAWI_15       ; restore registers and exit interrupt, branch always

              ; the block isn't finished so get the next byte to write to tape

fc39          TAWI_40
fc39 a0 00       LDY #0
fc3b b1 ac       LDA (SAL),Y       ; get byte from buffer
fc3d 85 bd       STA ROPRTY        ; save as tape write byte
fc3f 45 d7       EOR LASTKY        ; XOR with checksum byte
fc41 85 d7       STA LASTKY        ; save new checksum byte
fc43 20 d5 fc    JSR Inc_SAL_Word
fc46 d0 bb       BNE TAWI_15       ; restore registers and exit interrupt, branch always

              ; set parity as next bit and exit interrupt

fc48          TAWI_45
fc48 a5 9b       LDA PRTY          ; get parity bit
fc4a 49 01       EOR #$01          ; toggle it
fc4c 85 bd       STA ROPRTY        ; save as tape write byte

fc4e          TAWI_50
fc4e 4c b6 fe    JMP Exit_IRQ      ; restore registers and exit interrupt

              ; tape routine, block complete exit

fc51          TAWI_55
fc51 c6 be       DEC FSBLK         ; decrement copies remaining to read/write
fc53 d0 03       BNE TAWI_60       ; branch if more to do
fc55 20 c4 fc    JSR TAPE_Stop_Motor

fc58          TAWI_60
fc58 a9 50       LDA #$50          ; set tape write leader count
fc5a 85 a7       STA INBIT         ; save tape write leader count
fc5c a2 08       LDX #$08          ; set index for write tape leader vector
fc5e 78          SEI               ; disable interrupts
fc5f 20 b7 fc    JSR TAPE_Set_IRQ_Vector
fc62 d0 ea       BNE TAWI_50       ; restore registers and exit interrupt, branch always

fc64          TAPE_Write_Leader
fc64 a9 78       LDA #$78          ; set time constant low byte for bit = leader
fc66 20 a9 fb    JSR TAPE_Write_Timer
fc69 d0 e3       BNE TAWI_50       ; if tape bit high restore registers and exit interrupt
fc6b c6 a7       DEC INBIT         ; decrement cycle count
fc6d d0 df       BNE TAWI_50       ; if not all done restore registers and exit interrupt
fc6f 20 91 fb    JSR TAPE_New_Byte_Setup
fc72 c6 ab       DEC RIPRTY        ; decrement cassette leader count
fc74 10 d8       BPL TAWI_50       ; if not all done restore registers and exit interrupt
fc76 a2 0a       LDX #$0A          ; set index for tape write vector
fc78 20 b7 fc    JSR TAPE_Set_IRQ_Vector
fc7b 58          CLI               ; enable interrupts
fc7c e6 ab       INC RIPRTY        ; clear cassette leader counter, was $FF
fc7e a5 be       LDA FSBLK         ; get cassette block count
fc80 f0 30       BEQ Reset_TAPE_IRQ      ; if all done restore everything for STOP and exit interrupt
fc82 20 88 fb    JSR Set_IO_Start
fc85 a2 09       LDX #$09          ; set nine synchronisation bytes
fc87 86 a5       STX CNTDN         ; save cassette synchronization byte count
0000 TRUE     #if C64
fc89 86 b6       STX RODATA
              #endif
fc8b d0 83       BNE TAWI_25      ; go do next tape byte, branch always

              ; ********************
fc8d            Restoring_After_STOP
              ; ********************

fc8d 08          PHP               ; save status
fc8e 78          SEI               ; disable interrupts
0000 TRUE     #if C64
fc8f ad 11 d0    LDA VIC_CONTROL_1
fc92 09 10       ORA #$10          ; set DEN bit
fc94 8d 11 d0    STA VIC_CONTROL_1
              #endif
fc97 20 c4 fc    JSR TAPE_Stop_Motor
fc9a a9 7f       LDA #$7F          ; disable all interrupts
0000 TRUE     #if C64
fc9c 8d 0d dc    STA CIA1_ICR      ; CIA1 Interrupt Control Register
              #endif
0001 FALSE    #if VIC
SKIP             STA $912E
              #endif
0001 FALSE    #if VIC
SKIP             LDA #$F7          ; set keyboard column 3 active
SKIP             STA KEYB_COL      ; set VIA 2 DRB, keyboard column
SKIP             LDA #$40          ; set T1 free run, T2 clock Ø2,
SKIP             STA VIA2_ACR      ; set VIA 2 ACR
              #endif
fc9f 20 d7 fd    JSR Program_Timer_A
fca2 ad a0 02    LDA IRQTMP+1      ; get saved IRQ vector high byte
fca5 f0 09       BEQ RAS_10        ; branch if null
fca7 8d 15 03    STA CINV+1        ; restore IRQ vector high byte
fcaa ad 9f 02    LDA IRQTMP        ; get saved IRQ vector low byte
fcad 8d 14 03    STA CINV          ; restore IRQ vector low byte

fcb0          RAS_10
fcb0 28          PLP               ; restore status
fcb1 60          RTS ;Size   37 [Restoring_After_STOP]

              ; **************
fcb2            Reset_TAPE_IRQ
              ; **************

fcb2 20 8d fc    JSR Restoring_After_STOP
fcb5 f0 97       BEQ TAWI_50      ; restore registers and exit interrupt, branch always

              ; *******************
fcb7            TAPE_Set_IRQ_Vector
              ; *******************

fcb7 bd 8d fd    LDA TAPE_IRQ_Vectors-8,X  ; get tape IRQ vector low byte
fcba 8d 14 03    STA CINV          ; set IRQ vector low byte
fcbd bd 8e fd    LDA TAPE_IRQ_Vectors-7,X  ; get tape IRQ vector high byte
fcc0 8d 15 03    STA CINV+1        ; set IRQ vector high byte
fcc3 60          RTS ;Size   13 [TAPE_Set_IRQ_Vector]

              ; ***************
fcc4            TAPE_Stop_Motor
              ; ***************

0000 TRUE     #if C64
fcc4 a5 01       LDA R6510
fcc6 09 20       ORA #$20
fcc8 85 01       STA R6510
              #endif
0001 FALSE    #if VIC
SKIP             LDA VIA1_PCR      ; get VIA 1 PCR
SKIP             ORA #$0E          ; set CA2 high, cassette motor off
SKIP             STA VIA1_PCR      ; set VIA 1 PCR
              #endif
fcca 60          RTS ;Size    7 [TAPE_Stop_Motor]
              #endif               ; JIFFY

              ; ************
fccb            Check_IO_End
              ; ************

fccb 38          SEC
fccc a5 ac       LDA SAL           ; get buffer address low byte
fcce e5 ae       SBC EAL           ; subtract buffer end low byte
fcd0 a5 ad       LDA SAL+1         ; get buffer address high byte
fcd2 e5 af       SBC EAL+1         ; subtract buffer end high byte
fcd4 60          RTS ;Size   10 [Check_IO_End]

              ; ************
fcd5            Inc_SAL_Word
              ; ************

fcd5 e6 ac       INC SAL
fcd7 d0 02       BNE ISW_Ret
fcd9 e6 ad       INC SAL+1
fcdb          ISW_Ret
fcdb 60          RTS ;Size    7 [Inc_SAL_Word]

              ; ***********
fcdc            Entry_RESET        ; hardware reset
              ; ***********

fcdc a2 ff       LDX #$FF          ; set X for stack
fcde 78          SEI               ; disable interrupts
fcdf 9a          TXS               ; clear stack
fce0 d8          CLD               ; clear decimal mode
fce1 20 fc fc    JSR Scan_Autostart_Signature
fce4 d0 03       BNE HARE_10       ; if not there continue Vic startup
fce6 6c 00 80    JMP (OPTION_ROM)

fce9          HARE_10
0000 TRUE     #if C64
fce9 8e 16 d0    STX VIC_CONTROL_2
fcec 20 9d fd    JSR Initialise_IO
fcef 20 4a fd    JSR Init_RAM
fcf2 20 0f fd    JSR Kernal_RESTOR
fcf5 20 55 ff    JSR Init_Editor
              #endif
0001 FALSE    #if VIC
SKIP             JSR Init_RAM
SKIP             JSR Kernal_RESTOR
SKIP             JSR Initialise_IO
SKIP             JSR Initialise_Hardware
              #endif
fcf8 58          CLI               ; enable interrupts
fcf9 6c 00 a0    JMP (BASIC_ROM)   ; start BASIC

              ; ************************
fcfc            Scan_Autostart_Signature
              ; ************************

fcfc a2 05       LDX #5            ; five characters to test

fcfe          SAAS_Loop
fcfe bd 09 fd    LDA ROM_SIG-1,X   ; get test character
fd01 dd 03 80    CMP OPTION_ROM+3,X; compare with byte in block A000
fd04 d0 03       BNE SAAS_Exit     ; exit if no match
fd06 ca          DEX               ; decrement index
fd07 d0 f5       BNE SAAS_Loop

fd09          SAAS_Exit
fd09 60          RTS ;Size   14 [Scan_Autostart_Signature]

0000 TRUE     #if C64
fd0a c3 c2 cd ROM_SIG .byte $C3,$C2,$CD,"80" ; CBM80
              #endif
0001 FALSE    #if VIC
SKIP          ROM_SIG .byte "A0",$C3,$C2,$CD ; A0CBM
              #endif

              ; *************
fd0f            Kernal_RESTOR
              ; *************

fd0f a2 2a       LDX #<Kernal_Vectors    ; pointer to vector table low byte
fd11 a0 fd       LDY #>Kernal_Vectors    ; pointer to vector table high byte
fd13 18          CLC               ; flag set vectors

              ; *************
fd14            Kernal_VECTOR
              ; *************

                 STXY(MEMUSS)      ; save pointer
fd14 86 c3       STX MEMUSS
fd16 84 c4       STY MEMUSS+1

fd18 a0 1f       LDY #$1F          ; set byte count

fd1a          KeVE_10
0001 FALSE    #if JIFFY & VIC
SKIP             LDA (MEMUSS),Y    ; bugfix for the original code, that writes
SKIP             BCC KeVe_30       ; into the RAM bank at address of the
SKIP             LDA CINV,Y        ; Kernal vectors in ROM
              #else
fd1a b9 14 03    LDA CINV,Y        ; read vector byte from vectors
fd1d b0 02       BCS KeVE_20       ; if read vectors skip the read from XY
fd1f b1 c3       LDA (MEMUSS),Y    ; read vector byte from (XY)
              #endif

fd21          KeVE_20
fd21 91 c3       STA (MEMUSS),Y    ; save byte to (XY) [may be ROM address]

fd23          KeVe_30
fd23 99 14 03    STA CINV,Y        ; save byte to vector
fd26 88          DEY               ; decrement index
fd27 10 f1       BPL KeVE_10       ; loop if more to do
fd29 60          RTS ;Size   22 [Kernal_VECTOR]

              ; **************
fd2a            Kernal_Vectors
              ; **************

fd2a 31 ea       .word   Default_IRQ   ; CINV   IRQ vector
fd2c 60 fe       .word   Default_BRK   ; CBINV  BRK vector
fd2e 41 fe       .word   Default_NMI   ; NMINV  NMI vector
fd30 44 f3       .word   Kernal_OPEN   ; IOPEN  Open a logical file
fd32 8b f2       .word   Kernal_CLOSE  ; ICLOSE close a logical file
fd34 08 f2       .word   Kernal_ICHKIN ; ICHKIN open channel for input
fd36 4a f2       .word   Kernal_CHKOUT ; ICKOUT open channel for output
fd38 2d f3       .word   Kernal_CLRCHN ; ICLRCH clear I/O channels
fd3a 57 f1       .word   Kernal_CHRIN  ; IBASIN get a character from the input channel
fd3c ca f1       .word   Kernal_CHROUT ; IBSOUT output a character
fd3e e7 f6       .word   Kernal_STOP   ; ISTOP  check if stop key is pressed
fd40 3e f1       .word   Kernal_GETIN  ; IGETIN get character from keyboard queue
fd42 29 f3       .word   Kernal_CLALL  ; ICLALL close all channels and files
fd44 60 fe       .word   Default_BRK   ; USRCMD user function

              ; Vector to user defined command, currently points to BRK.

              ; This appears to be a holdover from PET days, when the built-in machine language monitor
              ; would jump through the USRCMD vector when it encountered a command that it did not
              ; understand, allowing the user to add new commands to the monitor.

              ; Although this vector is initialized to point to the routine called by STOP/RESTORE and
              ; the BRK interrupt, and is updated by the kernal vector routine at $FD57, it no longer
              ; has any function.

fd46 9f f4       .word   Default_LOAD; ILOAD      load
fd48 e7 f5       .word   Default_SAVE; ISAVE      save

              ; initialise and test RAM, the RAM from $000 to $03FF is never tested and is just assumed
              ; to work. first a search is done from $0401 for the start of memory and this is saved, if
              ; this start is at or beyond $1100 then the routine dead ends. once the start of memory is
              ; found the routine looks for the end of memory, if this end is before $2000 the routine
              ; again dead ends. lastly, if the end of memory is at $2000 then the screen is set to
              ; $1E00, but if the memory extends to or beyond $2100 then the screen is moved to $1000

fd4a          Init_RAM
fd4a a9 00       LDA #0
0000 TRUE     #if C64 
fd4c a8          TAY               ; clear index

fd4d          InRA_10
fd4d 99 02 00    STA $0002,Y       ; clear page 0
fd50 99 00 02    STA $0200,Y       ; clear page 2
fd53 99 00 03    STA $0300,Y       ; clear page 3
fd56 c8          INY
              #endif
0001 FALSE    #if VIC
SKIP             TAX               ; clear index
SKIP          
SKIP          InRA_10
SKIP             STA $0000,X       ; clear page 0
SKIP             STA $0200,X       ; clear page 2
SKIP             STA $0300,X       ; clear page 3
SKIP             INX               ; increment index
              #endif
fd57 d0 f4       BNE InRA_10       ; loop if more to do
fd59 a2 3c       LDX #<TBUFFR      ; set cassette buffer pointer low byte
fd5b a0 03       LDY #>TBUFFR      ; set cassette buffer pointer high byte
fd5d 86 b2       STX TAPE1         ; save tape buffer start pointer low byte
fd5f 84 b3       STY TAPE1+1       ; save tape buffer start pointer high byte

0000 TRUE     #if C64
fd61 a8          TAY
fd62 a9 03       LDA #3
fd64 85 c2       STA STAL+1

fd66          InRA_20
fd66 e6 c2       INC STAL+1

fd68          InRA_30
fd68 b1 c1       LDA (STAL),Y
fd6a aa          TAX   
fd6b a9 55       LDA #$55 ; 'U' 
fd6d 91 c1       STA (STAL),Y
fd6f d1 c1       CMP (STAL),Y
fd71 d0 0f       BNE InRA_40 
fd73 2a          ROL A 
fd74 91 c1       STA (STAL),Y
fd76 d1 c1       CMP (STAL),Y
fd78 d0 08       BNE InRA_40 
fd7a 8a          TXA   
fd7b 91 c1       STA (STAL),Y
fd7d c8          INY   
fd7e d0 e8       BNE InRA_30 
fd80 f0 e4       BEQ InRA_20 

fd82          InRA_40
fd82 98          TYA   
fd83 aa          TAX   
fd84 a4 c2       LDY STAL+1
fd86 18          CLC   
fd87 20 27 fe    JSR Set_memtop
fd8a a9 08       LDA #>BASIC_RAM_START
fd8c 8d 82 02    STA OSSTAR+1
fd8f a9 04       LDA #>BASIC_SCREEN
fd91 8d 88 02    STA SCNMPG
fd94 60          RTS    ;Size  107 [Kernal_Vectors]
              #endif

0001 FALSE    #if VIC
SKIP             STA STAL          ; clear RAM test pointer low byte
SKIP             STA TEMPX         ; clear looking for end flag
SKIP             STA OSSTAR        ; clear OS start of memory low byte
SKIP             TAY               ; clear Y
SKIP             LDA #$04          ; set RAM test pointer high byte
SKIP             STA STAL+1        ; save RAM test pointer high byte
SKIP          
SKIP          InRA_50
SKIP             INC STAL          ; increment RAM test pointer low byte
SKIP             BNE InRA_55       ; if no rollover skip the high byte increment
SKIP             INC STAL+1        ; increment RAM test pointer high byte
SKIP          
SKIP          InRA_55
SKIP             JSR Test_RAM_byte ; test RAM byte, return Cb=0 if failed
SKIP             LDA TEMPX         ; test looking for end flag
SKIP             BEQ InRA_70       ; branch if not looking for end
SKIP             BCS InRA_50       ; loop if byte test passed
SKIP             LDY STAL+1        ; get test address high byte
SKIP             LDX STAL          ; get test address low byte
SKIP             CPY #$20          ; compare with $2000, RAM should always end at or after
SKIP             BCC InRA_75       ; if end address < $2000 go do dead end loop
SKIP             CPY #$21          ; compare with $2100
SKIP             BCS InRA_65       ; branch if >= $2100
SKIP             LDY #$1E          ; set screen memory page to $1E00
SKIP             STY SCNMPG        ; save screen memory page
SKIP          
SKIP          InRA_60
SKIP             JMP Set_memtop      ; set the top of memory and return
SKIP          
SKIP          InRA_65
SKIP             LDA #$12          ; set OS start of memory high byte
SKIP             STA OSSTAR+1      ; save OS start of memory high byte
SKIP             LDA #$10          ; set screen memory page to $1000
SKIP             STA SCNMPG        ; save screen memory page
SKIP             BNE InRA_60       ; set the top of memory and return, branch always
SKIP          
SKIP          InRA_70
SKIP             BCC InRA_50       ; loop if byte test failed, not found start yet
SKIP             LDA STAL+1        ; get test address high byte
SKIP             STA OSSTAR+1      ; save OS start of memory high byte
SKIP             STA TEMPX         ; set looking for end flag
SKIP             CMP #$11          ; compare start with $1100, RAM should always start before
SKIP             BCC InRA_50       ; go find end of RAM, branch always
SKIP          
SKIP          InRA_75
SKIP             JSR Init_VIC_Chip
SKIP             JMP InRA_75       ; loop forever
              #endif

fd95          TAPE_IRQ_Vectors
0001 FALSE    #if JIFFY
0000 TRUE     #if C64
SKIP             .word   $fc6a             ; $08   write tape leader IRQ routine
SKIP             .word   $fbcd             ; $0A   tape write IRQ routine
SKIP             .word   $ea31             ; $0C   normal IRQ vector
SKIP             .word   $f92c             ; $0E   read tape bits IRQ routine
              #endif
0001 FALSE    #if VIC
SKIP             .word   $fca8             ; $08   write tape leader IRQ routine
SKIP             .word   $fc0b             ; $0A   tape write IRQ routine
SKIP             .word   Default_IRQ       ; $0C   normal IRQ vector
SKIP             .word   $f98e             ; $0E   read tape bits IRQ routine
              #endif
              #else
fd95 64 fc       .word   TAPE_Write_Leader ; $08   write tape leader IRQ routine
fd97 c7 fb       .word   TAPE_Write_IRQ    ; $0A   tape write IRQ routine
fd99 31 ea       .word   Default_IRQ       ; $0C   normal IRQ vector
fd9b 26 f9       .word   TAPE_Read_IRQ     ; $0E   read tape bits IRQ routine
              #endif

              ; *************
fd9d            Initialise_IO
              ; *************

0000 TRUE     #if C64
fd9d a9 7f       LDA #$7f
fd9f 8d 0d dc    STA CIA1_ICR    ; CIA1 Interrupt Control Register
fda2 8d 0d dd    STA CIA2_ICR
fda5 8d 00 dc    STA KEYB_COL
fda8 a9 08       LDA #8
fdaa 8d 0e dc    STA CIA1_CRA
fdad 8d 0e dd    STA CIA2_CRA
fdb0 8d 0f dc    STA CIA1_CRB    ; CIA1 Control Register B
fdb3 8d 0f dd    STA CIA2_CRB
fdb6 a2 00       LDX #0
fdb8 8e 03 dc    STX $DC03
fdbb 8e 03 dd    STX $DD03
fdbe 8e 18 d4    STX $D418
fdc1 ca          DEX
fdc2 8e 02 dc    STX $DC02
fdc5 a9 07       LDA #7
fdc7 8d 00 dd    STA $DD00
fdca a9 3f       LDA #$3f ; '?'
fdcc 8d 02 dd    STA $DD02
fdcf a9 e7       LDA #$e7
fdd1 85 01       STA R6510
fdd3 a9 2f       LDA #$2f ; '/'
fdd5 85 00       STA D6510
              #endif
0001 FALSE    #if VIC
SKIP             LDA #$7F          ; disable all interrupts
SKIP             STA RS2_IRQ_REG   ; on VIA 1 IER ..
SKIP             STA VIA2_IER      ; .. and VIA 2 IER
SKIP             LDA #$40          ; set T1 free run, T2 clock Ø2,
SKIP                               ; SR disabled, latches disabled
SKIP             STA VIA2_ACR      ; set VIA 2 ACR
SKIP             LDA #$40          ; set T1 free run, T2 clock Ø2,
SKIP                               ; SR disabled, latches disabled
SKIP             STA VIA1_ACR      ; set VIA 1 ACR
SKIP             LDA #$FE          ; CB2 high, RS232 Tx
SKIP                               ; CB1 positive edge,
SKIP                               ; CA2 high, tape motor off
SKIP                               ; CA1 negative edge
SKIP             STA VIA1_PCR      ; set VIA 1 PCR
SKIP             LDA #$DE          ; CB2 low, serial data out high
SKIP                               ; CB1 positive edge,
SKIP                               ; CA2 high, serial clock out low
SKIP                               ; CA1 negative edge
SKIP             STA IEC_PCR       ; set VIA 2 PCR
SKIP             LDX #$00          ; all inputs, RS232 interface or parallel user port
SKIP             STX VIA1_DDRB     ; set VIA 1 DDRB
SKIP             LDX #$FF          ; all outputs, keyboard column
SKIP             STX VIA2_DDRB     ; set VIA 2 DDRB
SKIP             LDX #$00          ; all inputs, keyboard row
SKIP             STX VIA2_DDRA     ; set VIA 2 DDRA
SKIP             LDX #$80          ; OIII IIII, ATN out, light pen, joystick, serial data
SKIP                               ; in, serial clk in
SKIP             STX VIA1_DDRA     ; set VIA 1 DDRA
SKIP             LDX #$00          ; ATN out low, set ATN high
SKIP             STX IEC_DRAN      ; set VIA 1 DRA, no handshake
SKIP             JSR CLR_IEC_CLK   ; set serial clock high
SKIP             LDA #$82          ; enable CA1 interrupt, [RESTORE] key
SKIP             STA RS2_IRQ_REG   ; set VIA 1 IER
SKIP             JSR SET_IEC_CLK   ; set serial clock low
              #endif

              ; ***************
fdd7            Program_Timer_A
              ; ***************

0000 TRUE     #if C64
fdd7 ad a6 02    LDA TVSFLG
fdda f0 0a       BEQ TASF_10
fddc a9 25       LDA #<$4025       ; 16421
fdde 8d 04 dc    STA CIA1_TALO
fde1 a9 40       LDA #>$4025
fde3 4c ed fd    JMP TASF_20
fde6          TASF_10
fde6 a9 95       LDA #<$4295       ; 17045
fde8 8d 04 dc    STA CIA1_TALO
fdeb a9 42       LDA #>$4295
fded          TASF_20
fded 8d 05 dc    STA CIA1_TAHI
fdf0 4c 68 ff    JMP PTA_10
              #endif
0001 FALSE    #if VIC
SKIP             LDA #$C0          ; enable T1 interrupt
SKIP             STA VIA2_IER      ; set VIA 2 IER
0000 TRUE     #if PAL
SKIP             LDA #$26          ; set timer constant low byte [PAL]
              #else
SKIP             LDA #$89          ; set timer constant low byte [NTSC]
              #endif
SKIP             STA VIA2_T1CL     ; set VIA 2 T1C_l
0000 TRUE     #if PAL
SKIP             LDA #$48          ; set timer constant high byte [PAL]
              #else
SKIP             LDA #$42          ; set timer constant high byte [NTSC]
              #endif
SKIP             STA VIA2_T1CH     ; set VIA 2 T1C_h
SKIP             RTS
              #endif

              ; *************
fdf3            Kernal_SETNAM
              ; *************

fdf3 85 b7       STA FNLEN         ; set file name length
fdf5 86 bb       STX FNADR         ; set file name pointer low byte
fdf7 84 bc       STY FNADR+1       ; set file name pointer high byte
fdf9 60          RTS ;Size    7 [Kernal_SETNAM]

              ; *************
fdfa            Kernal_SETLFS
              ; *************

fdfa 85 b8       STA LA            ; set logical file
fdfc 86 ba       STX FA            ; set device number
fdfe 84 b9       STY SA            ; set secondary address or command
fe00 60          RTS ;Size    7 [Kernal_SETLFS]

              ; *************
fe01            Kernal_READST
              ; *************

fe01 a5 ba       LDA FA            ; get device number
fe03 c9 02       CMP #$02          ; compare device with RS232 device
fe05 d0 0d       BNE Get_Status    ; branch if not RS232 device
fe07 ad 97 02    LDA RSSTAT        ; read RS232 status word
0000 TRUE     #if C64
fe0a 48          PHA
              #endif
fe0b a9 00       LDA #0
fe0d 8d 97 02    STA RSSTAT        ; clear RS232 status
0000 TRUE     #if C64
fe10 68          PLA
              #endif

              ; the above code is wrong. the RS232 status is in A but A is cleared and that is used
              ; to clear the RS232 status byte. so whatever the status the result is always $00 and
              ; the status byte is always cleared. A solution is to use X to clear the status after
              ; it is read instead of the above like this ..
              ;
              ;   LDX   #$00         ; clear X
              ;   STX   RSSTAT       ; clear RS232 status ##
fe11 60          RTS ;Size   17 [Kernal_READST]

              ; *************
fe12            Kernal_SETMSG
              ; *************

fe12 85 9d       STA MSGFLG        ; set message mode flag

fe14          Get_Status
fe14 a5 90       LDA STATUS        ; read serial status byte

              ; **********
fe16            Ora_Status
              ; **********

fe16 05 90       ORA STATUS        ; OR with serial status byte
fe18 85 90       STA STATUS        ; save serial status byte
fe1a 60          RTS ;Size    5 [Ora_Status]

              ; *************
fe1b            Kernal_SETTMO
              ; *************

fe1b 8d 85 02    STA STIMOT        ; save serial bus timeout flag
fe1e 60          RTS ;Size    4 [Kernal_SETTMO]

              ; *************
fe1f            Kernal_MEMTOP
              ; *************

fe1f 90 06       BCC Set_memtop      ; if Cb clear go set the top of memory

              ; ***********
fe21            Read_Memtop
              ; ***********

fe21 ae 83 02    LDX OSTOP         ; get memory top low byte
fe24 ac 84 02    LDY OSTOP+1       ; get memory top high byte

              ; **********
fe27            Set_memtop
              ; **********

fe27 8e 83 02    STX OSTOP         ; set memory top low byte
fe2a 8c 84 02    STY OSTOP+1       ; set memory top high byte
fe2d 60          RTS ;Size    7 [Set_memtop]

              ; *************
fe2e            Kernal_MEMBOT
              ; *************

fe2e 90 06       BCC MEM_10        ; if Cb clear go set the bottom of memory

              ; read the bottom of memory

fe30 ae 81 02    LDX OSSTAR        ; read OS start of memory low byte
fe33 ac 82 02    LDY OSSTAR+1      ; read OS start of memory high byte

              ; set the bottom of memory

fe36          MEM_10
                 STXY(OSSTAR)      ; set OS start of memory
fe36 8e 81 02    STX OSSTAR
fe39 8c 82 02    STY OSSTAR+1

fe3c 60          RTS ;Size   15 [Kernal_MEMBOT]

0001 FALSE    #if VIC
SKIP          ; *************
SKIP            Test_RAM_byte      ; return (C=1) on failure
SKIP          ; *************
SKIP          
SKIP             LDA (STAL),Y      ; get existing RAM byte
SKIP             TAX               ; copy to X
SKIP             LDA #$55          ; set first test byte
SKIP             STA (STAL),Y      ; save to RAM
SKIP             CMP (STAL),Y      ; compare with saved
SKIP             BNE Exit_No_RAM
SKIP             ROR A             ; make byte $AA, carry is set here
SKIP             STA (STAL),Y      ; save to RAM
SKIP             CMP (STAL),Y      ; compare with saved
SKIP             BNE Exit_No_RAM 
SKIP             .byte   $A9       ; makes next line LDA #$18
SKIP          
SKIP          Exit_No_RAM
SKIP             CLC               ; flag test failed
SKIP             TXA               ; get original byte back
SKIP             STA (STAL),Y      ; restore original byte
SKIP             RTS
              #endif

              ; *********
fe3d            Entry_NMI
              ; *********

fe3d 78          SEI               ; disable interrupts
fe3e 6c 18 03    JMP (NMINV)       ; next statement by default

              ; ***********
fe41            Default_NMI
              ; ***********

fe41 48          PHA               ; save A
fe42 8a          TXA               ; copy X
fe43 48          PHA               ; save X
fe44 98          TYA               ; copy Y
fe45 48          PHA               ; save Y
0000 TRUE     #if C64
fe46 a9 7f       LDA #$7F
fe48 8d 0d dd    STA CIA2_ICR
fe4b ac 0d dd    LDY CIA2_ICR
fe4e 30 1c       BMI RS232_NMI
              #endif
0001 FALSE    #if VIC
SKIP             LDA VIA1_IFR      ; get interrupt flag register
SKIP             BPL JMP_Exit_IRQ  ; if no interrupt restore registers and exit
SKIP             AND RS2_IRQ_REG   ; AND with interrupt enable register
SKIP             TAX               ; copy to X
SKIP             AND #2            ; mask [RESTORE] key
SKIP             BEQ RS232_NMI     ; if not [RESTORE] key continue with RS232
              #endif
fe50 20 fc fc    JSR Scan_Autostart_Signature
fe53 d0 03       BNE NMI_10        ; branch if no autostart ROM
fe55 6c 02 80    JMP (OPTION_ROM+2); else do autostart ROM break entry

fe58          NMI_10
0001 FALSE    #if VIC
SKIP             BIT VIA1_DATA     ; test VIA 1 DRA
              #endif
0000 TRUE     #if C64
fe58 20 b6 f6    JSR Look_For_Special_Keys
              #endif
0001 FALSE    #if VIC
SKIP             JSR Kernal_UDTIM  ; Update the system clock
              #endif
fe5b 20 db ff    JSR STOP          ; Check if stop key is pressed
0000 TRUE     #if C64
fe5e d0 0c       BNE RS232_NMI
              #endif
0001 FALSE    #if VIC
SKIP             BNE JMP_Exit_IRQ  ; if not [STOP] exit interrupt
              #endif

              ; ***********
fe60            Default_BRK
              ; ***********

fe60 20 0f fd    JSR Kernal_RESTOR
fe63 20 9d fd    JSR Initialise_IO
fe66 20 18 e5    JSR Initialise_Hardware
fe69 6c 02 a0    JMP (BASIC_BRK)

              ; *********
fe6c            RS232_NMI
              ; *********

0000 TRUE     #if C64
fe6c          Bfe72
fe6c 98          TYA
fe6d 2d a1 02    AND ENABL
fe70 aa          TAX
fe71 29 01       AND #1
fe73 f0 28       BEQ NMI_20
fe75 ad 00 dd    LDA $DD00
fe78 29 fb       AND #$fb
fe7a 05 b5       ORA NXTBIT
fe7c 8d 00 dd    STA $DD00
fe7f ad a1 02    LDA ENABL
fe82 8d 0d dd    STA CIA2_ICR
fe85 8a          TXA
fe86 29 12       AND #$12
fe88 f0 0d       BEQ Mfe9d
fe8a 29 02       AND #2
fe8c f0 06       BEQ Bfe9a
fe8e 20 d0 fe    JSR RS232_In
fe91 4c 97 fe    JMP Mfe9d
fe94          Bfe9a
fe94 20 01 ff    JSR RS232_Out
              #endif
0001 FALSE    #if VIC
SKIP             LDA RS2_IRQ_REG   ; interrupt enable register
SKIP             ORA #$80          ; set enable bit
SKIP             PHA               ; save to re-enable interrupts
SKIP             LDA #$7F          ; disable all interrupts
SKIP             STA RS2_IRQ_REG   ; interrupt enable register
SKIP             TXA               ; get active interrupts back
SKIP             AND #$40          ; mask T1 interrupt
SKIP             BEQ NMI_20        ; branch if not T1 interrupt
SKIP             LDA #$CE          ; CB2 low, CB1 negative edge, CA2 high, CA1 negative edge
SKIP             ORA NXTBIT        ; OR RS232 next bit to send, sets CB2 high if set
SKIP             STA VIA1_PCR      ; set VIA 1 PCR
SKIP             LDA RS2_TIM_LOW   ; get VIA 1 T1C_l
SKIP             PLA               ; restore interrupt enable mask
SKIP             STA RS2_IRQ_REG   ; interrupt enable register
              #endif
fe97          Mfe9d
fe97 20 bb ee    JSR RS232_NMI_Transmit

fe9a          JMP_Exit_IRQ
0000 TRUE     #if C64
fe9a 4c b0 fe    JMP Bfeb6
              #endif
0001 FALSE    #if VIC
SKIP             JMP Exit_IRQ      ; restore registers and exit interrupt
              #endif

fe9d          NMI_20
fe9d 8a          TXA               ; get active interrupts back
0000 TRUE     #if C64
fe9e 29 02       AND #2
              #endif
0001 FALSE    #if VIC
SKIP             AND #$20          ; mask T2 interrupt
              #endif
fea0 f0 06       BEQ NMI_30        ; branch if not T2 interrupt
0000 TRUE     #if C64
fea2 20 d0 fe    JSR RS232_In
              #endif
0001 FALSE    #if VIC
SKIP             LDA RS2_DSR_CTS   ; get VIA 1 DRB
SKIP             AND #$01          ; mask RS232 data in
SKIP             STA INBIT         ; save receiver input bit temp storage
SKIP             LDA VIA1_T2CL     ; get VIA 1 T2C_l
SKIP             SBC #$16          ;.
SKIP             ADC BAUDOF        ; add baud rate bit time low byte
SKIP             STA VIA1_T2CL     ; set VIA 1 T2C_l
SKIP             LDA VIA1_T2CH     ; get VIA 1 T2C_h
SKIP             ADC BAUDOF+1      ; add baud rate bit time high byte
SKIP             STA VIA1_T2CH     ; set VIA 1 T2C_h
SKIP             PLA               ; restore interrupt enable mask
SKIP             STA RS2_IRQ_REG   ; set VIA 1 IER, restore interrupts
SKIP             JSR RS232_NMI_Receive
              #endif
0000 TRUE     #if C64
fea5 4c b0 fe    JMP Bfeb6
              #endif
0001 FALSE    #if VIC
SKIP             JMP Exit_IRQ      ; restore registers and exit interrupt
              #endif

fea8          NMI_30
fea8 8a          TXA               ; get active interrupts back
fea9 29 10       AND #$10          ; mask CB1 interrupt, Rx data bit transition
feab f0 03       BEQ Bfeb6         ; if no bit restore registers and exit interrupt
0000 TRUE     #if C64
fead 20 01 ff    JSR RS232_Out
              #endif
0001 FALSE    #if VIC
SKIP             LDA M51CTR        ; get pseudo 6551 control register
SKIP             AND #$0F          ; clear non baud bits
SKIP             BNE NMI_40        ; quirk
SKIP          
SKIP          NMI_40
SKIP             ASL A             ; 2 bytes per baud index
SKIP             TAX               ; copy to index
SKIP             LDA Baudrate-2,X  ; get baud count low byte
SKIP             STA VIA1_T2CL     ; set VIA 1 T2C_l
SKIP             LDA Baudrate-1,X  ; get baud count high byte
SKIP             STA VIA1_T2CH     ; set VIA 1 T2C_h
SKIP             LDA RS2_DSR_CTS   ; read VIA 1 DRB, clear interrupt flag
SKIP             PLA               ; restore interrupt enable mask
SKIP             ORA #$20          ; enable T2 interrupt
SKIP             AND #$EF          ; disable CB1 interrupt
SKIP             STA RS2_IRQ_REG   ; set VIA 1 IER
SKIP             LDX BITNUM        ; get number of bits to be sent/received
SKIP             STX BITCI         ; save receiver bit count in
              #endif

feb0          Bfeb6

0000 TRUE     #if C64
feb0 ad a1 02    LDA ENABL
feb3 8d 0d dd    STA CIA2_ICR
              #endif

              ; ********
feb6            Exit_IRQ
              ; ********

feb6 68          PLA               ; pull Y
feb7 a8          TAY               ; restore Y
feb8 68          PLA               ; pull X
feb9 aa          TAX               ; restore X
feba 68          PLA               ; restore A
febb 40          RTI

              ; ********
febc            Baudrate  
              ; ********

0000 TRUE     #if C64
              ; --------------------------------
febc c1 27       .word   $27c1     ;   50   baud
febe 3e 1a       .word   $1a3e     ;   75   baud
fec0 c5 11       .word   $11c5     ;  110   baud
fec2 74 0e       .word   $0e74     ;  134.5 baud
fec4 ed 0c       .word   $0ced     ;  150   baud
fec6 45 06       .word   $0645     ;  300   baud
fec8 f0 02       .word   $02f0     ;  600   baud
feca 46 01       .word   $0146     ; 1200   baud
fecc b8 00       .word   $00b8     ; 1800   baud
fece 71 00       .word   $0071     ; 2400   baud
              #endif
0001 FALSE    #if VIC
0000 TRUE     #if PAL
SKIP          ; PAL Value = 1108404 Hz / baudrate
SKIP          ; --------------------------------
SKIP             .word   $2AE6     ;   50   baud
SKIP             .word   $1C78     ;   75   baud
SKIP             .word   $1349     ;  110   baud
SKIP             .word   $0FB1     ;  134.5 baud
SKIP             .word   $0E0A     ;  150   baud
SKIP             .word   $06D3     ;  300   baud
SKIP             .word   $0338     ;  600   baud
SKIP             .word   $016A     ; 1200   baud
SKIP             .word   $00D0     ; 1800   baud
SKIP             .word   $0083     ; 2400   baud
SKIP             .word   $0036     ; 3600   baud
              #else
SKIP          ; NTSC Value = 1022727 Hz / baudrate
SKIP          ; --------------------------------
SKIP             .word   $2792     ;   50   baud
SKIP             .word   $1A40     ;   75   baud
SKIP             .word   $11C6     ;  110   baud
SKIP             .word   $0E74     ;  134.5 baud
SKIP             .word   $0CEE     ;  150   baud
SKIP             .word   $0645     ;  300   baud
SKIP             .word   $02F1     ;  600   baud
SKIP             .word   $0146     ; 1200   baud
SKIP             .word   $00B8     ; 1800   baud
SKIP             .word   $0071     ; 2400   baud
SKIP             .word   $002A     ; 3600   baud
              #endif
              #endif

0000 TRUE     #if C64
              ; ********
fed0            RS232_In
              ; ********

fed0 ad 01 dd    LDA CIA2_PRB
fed3 29 01       AND #1
fed5 85 a7       STA INBIT
fed7 ad 06 dd    LDA CIA2_TBLO
feda e9 1c       SBC #$1c
fedc 6d 99 02    ADC BAUDOF
fedf 8d 06 dd    STA CIA2_TBLO
fee2 ad 07 dd    LDA CIA2_TBHI
fee5 6d 9a 02    ADC BAUDOF+1
fee8 8d 07 dd    STA CIA2_TBHI
feeb a9 11       LDA #$11
feed 8d 0f dd    STA CIA2_CRB
fef0 ad a1 02    LDA ENABL
fef3 8d 0d dd    STA CIA2_ICR
fef6 a9 ff       LDA #$ff
fef8 8d 06 dd    STA CIA2_TBLO
fefb 8d 07 dd    STA CIA2_TBHI
fefe 4c 59 ef    JMP RS232_NMI_Receive

              ; *********
ff01            RS232_Out
              ; *********

ff01 ad 95 02    LDA M51AJB
ff04 8d 06 dd    STA CIA2_TBLO
ff07 ad 96 02    LDA M51AJB+1
ff0a 8d 07 dd    STA CIA2_TBHI
ff0d a9 11       LDA #$11
ff0f 8d 0f dd    STA CIA2_CRB
ff12 a9 12       LDA #$12
ff14 4d a1 02    EOR ENABL
ff17 8d a1 02    STA ENABL
ff1a a9 ff       LDA #$ff
ff1c 8d 06 dd    STA CIA2_TBLO
ff1f 8d 07 dd    STA CIA2_TBHI
ff22 ae 98 02    LDX BITNUM
ff25 86 a8       STX BITCI
ff27 60          RTS ;Size   39 [RS232_Out]

              ; *************
ff28            Set_Baud_Rate
              ; *************

ff28 aa          TAX
ff29 ad 96 02    LDA M51AJB+1
ff2c 2a          ROL A
ff2d a8          TAY
ff2e 8a          TXA
ff2f 69 c8       ADC #$c8
ff31 8d 99 02    STA BAUDOF
ff34 98          TYA
ff35 69 00       ADC #0
ff37 8d 9a 02    STA BAUDOF+1
ff3a 60          RTS ;Size   19 [Set_Baud_Rate]

ff3b ea ea       .BYTE $ea,$ea     ; 2 NOP's

              ; ****************
ff3d            Clear_BREAK_Flag
              ; ****************

ff3d 08          PHP
ff3e 68          PLA
ff3f 29 ef       AND #$ef
ff41 48          PHA

              #endif
              ; *********
ff42            Entry_IRQ
              ; *********

ff42 48          PHA               ; save A
ff43 8a          TXA               ; copy X
ff44 48          PHA               ; save X
ff45 98          TYA               ; copy Y
ff46 48          PHA               ; save Y
ff47 ba          TSX               ; copy stack pointer
ff48 bd 04 01    LDA STACK+4,X     ; get the stacked status register
ff4b 29 10       AND #$10          ; mask the BRK flag bit
ff4d f0 03       BEQ BFF82         ; if not BRK go do the hardware IRQ vector
ff4f 6c 16 03    JMP (CBINV)       ; else do the BRK vector
ff52          BFF82
ff52 6c 14 03    JMP (CINV)        ; do IRQ vector

0000 TRUE     #if C64
              ; ***********
ff55            Init_Editor
              ; ***********

ff55 20 18 e5    JSR Initialise_Hardware

ff58          InEd_10
ff58 ad 12 d0    LDA $D012
ff5b d0 fb       BNE InEd_10
ff5d ad 19 d0    LDA $D019
ff60 29 01       AND #1
ff62 8d a6 02    STA TVSFLG
ff65 4c d7 fd    JMP Program_Timer_A

              ; ======
ff68            PTA_10             ; continue Program_Timer_A
              ; ======

ff68 a9 81       LDA #$81          ; Enable timer A interrupt
ff6a 8d 0d dc    STA CIA1_ICR      ; Interrupt Control Register
ff6d ad 0e dc    LDA CIA1_CRA      ; Read Conrol Register A
ff70 29 80       AND #$80          ; Clear all values except frequency (50/60 Hz)
ff72 09 11       ORA #$11          ; Start time A in single shot mode
ff74 8d 0e dc    STA CIA1_CRA      ; run timer A
ff77 4c 8e ee    JMP SET_IEC_CLK

              ; **************
ff7a            Kernal_Version
              ; **************

ff7a 03          .BYTE $03

ff7b 4c 55 ff     JMP Init_Editor
ff7e 4c 9d fd     JMP Initialise_IO
ff81 4c 4a fd     JMP Init_RAM

              #endif

0001 FALSE    #if VIC
SKIP             .fill 5 (-1)      ; unused
              #endif

              ; ******
ff84            RESTOR             ; Restore default system and interrupt vectors
              ; ******

              ; Call address: $FF8A
              ; Preparatory routines: None
              ; Error returns: None
              ; Stack requirements: 2
              ; Registers affected: A, X, Y

              ; This routine restores the default values of all system vectors used in
              ; KERNAL and BASIC routines and interrupts. (See appendix D for the
              ; default vector contents). The KERNAL VECTOR routine is used to read
              ; and alter individual system vectors.

              ; 1) Call this routine.

              ; JSR RESTOR

ff84 4c 0f fd    JMP Kernal_RESTOR

              ; ******
ff87            VECTOR             ; Manage RAM vectors
              ; ******

              ; Call address: $FF8D
              ; Communication registers: X, Y
              ; Preparatory routines: None
              ; Error returns: None
              ; Stack requirements: 2
              ; Registers affected: A, X, Y

              ; This routine manages all system vector jump addresses stored in RAM.
              ; Calling this routine with the accumulator carry ait set wili store the
              ; current contents of the RAM vectors in a list pointed to by the X and
              ; Y registers. When this routine is called with the carry clear, the
              ; user list pointed to by the X and Y registers is transferred to the
              ; system RAM vectors. NOTE: This routine requires caution in its use.
              ; The best way to use it is to first read the entire vector contents
              ; into the user area, alter the desired vectors, and then copy the
              ; contents back to the system vectors.

              ; READ THE SYSTEM RAM VECTORS
              ; 1) Set the carry.
              ; 2) Set the X and Y registers to the address to put the vectors.
              ; 3) Call this routine.

              ; LOAD THE SYSTEM RAM VECTORS
              ; 1) Clear the carry bit.
              ; 2) Set the X and Y registers to the address of the vector list in RAM
              ;    that must be loaded
              ; 3) Call this routine.

              ; CHANGE THE INPUT ROUTINES TO NEW SYSTEM
              ; LDX #<USER
              ; LDY #>USER
              ; SEC
              ; JSR VECTOR   ;read old vectors
              ; LDA #<MYINP  ;change input
              ; STA USER+10
              ; LDA #>MYINP
              ; STA USER+11
              ; LDX #<USER
              ; LDY #>USER
              ; CLC
              ; JSR VECTOR  ;alter system
              ; USER * = * + 26

ff87 4c 14 fd    JMP Kernal_VECTOR

              ; ******
ff8a            SETMSG             ; Control system message output
              ; ******

              ; Call address: $FF90
              ; Communication registers: A
              ; Preparatory routines: None
              ; Error returns: None
              ; Stack requirements: 2
              ; Registers affected: A

              ; This routine controls the printing of error and control messages by
              ; the KERNAL. Either print error messages or print control messages can
              ; be selected by setting the accumulator when the routine is called.
              ; FILE NOT FOUND is an example of an error message. PRESS PLAY ON
              ; CASSETTE is an example of a control message. Bits 6 and 7 of this
              ; value determine where the message will come from, ft bit 7 is 1, one
              ; of the error messages from the KERNAL will be printed. If bit 6 is
              ; set, a control message wifl be printed.

              ; 1) Set accumulator to desired value.
              ; 2) Call this routine.

              ; LDA #S40
              ; JSR SETMSG       ; TURN ON CONTROL MESSAGES
              ; LDA #SB0
              ; JSR SETMSG       ; TURN ON ERROR MESSAGES
              ; LDA #0
              ; JSR SETMSG       ; TURN OFF ALL KERNAL MESSAGES

ff8a 4c 12 fe    JMP Kernal_SETMSG

              ; ******
ff8d            SECOND             ; Send secondary address for LISTEN
              ; ******

              ; Call address: $FF93
              ; Communication registers: A
              ; Preparatory routines: LISTEN
              ; Error returns: See READST
              ; Stack requirements: one
              ; Registers affected: .A

              ; This routine is used to send a secondary address to an I/O device
              ; after a call to the LISTEN routine is made, and the device commanded
              ; to LISTEN. The routine cannot be used to send a secondary address
              ; after a call to the TALK routine. A secondary address is usually used
              ; to give set-up information to a device before I;O operations begin.
              ; When a secondary address is to be sent to a device on the serial bus,
              ; the address must first be ORed with $60.

              ; 1) Load the accumulator with the secondary address to be sent.
              ; 2) Call this routine.

              ; ADDRESS DEVICE #8 WITH COMMAND (SECONDARY ADDRESS) #15
              ; LDA #8
              ; JSR LISTEN
              ; LDA #15
              ; ORA #60
              ; JSR SECOND

ff8d 4c b9 ed    JMP Kernal_SECOND

              ; ****
ff90            TKSA  ; Send a secondary address to a device commanded to TALK
              ; ****

              ; Call address: $FF96
              ; Communication registers: A
              ; Preparatory routines: TALK
              ; Error returns: See READST
              ; Slack requirements: None
              ; Registers affected: A

              ; This routine transmits a secondary address on the serial bus for a
              ; TALK device. This routine must be called with a number between 4 and
              ; 31 in the accumulator. The routine will send this number as a
              ; secondary address command over the serial bus. This routine can only
              ; be called after a call to the TALK routine, it will not work after a
              ; LISTEN.

              ; 0) Use the TALK routine.
              ; 1) Load the accumulator with the secondary address.
              ; 2) Call this routine.

              ; ;TELL DEVICE #4 TO TALK WITH COMMAND #7
              ; LDA #4
              ; JSR TALK
              ; LDA #7
              ; JSR TKSA

ff90 4c c7 ed    JMP Kernal_TKSA

              ; ******
ff93            MEMTOP             ; Read or set the top of RAM
              ; ******

              ; Call address: $FF99
              ; Communication registers: X, Y
              ; Preparatory routines: None
              ; Error returns: None
              ; Stack requirements: 2
              ; Registers affected: X, Y

              ; This routine is used to set the top of RAM. When this routine is
              ; called with the carry bit of the accumulator set, the pointer to the
              ; top of RAM will be loaded into the .X and. Y registers. When this
              ; routine is called with the accumulator carry bit clear, the contents
              ; of the X and Y registers will be loaded in the top of memory pointer,
              ; changing the top of memory.

              ; DEALLOCATE THE RS-232 BUFFER
              ; SEC
              ; JSR MEMTOP ;READ TOP OF MEMORY
              ; DEX
              ; CLC
              ; JSR MEMTOP ;SET NEW TOP OF MEMORY

ff93 4c 1f fe    JMP Kernal_MEMTOP

              ; ******
ff96            MEMBOT             ; Read or set bottom of memory
              ; ******

              ; Call address: $FF9C
              ; Communication registers: X, Y
              ; Preparatory routines: None
              ; Error returns: None
              ; Stack requirements: None
              ; Registers affected: X, Y

              ; This routine is used to set the bottom of the memory. If the
              ; accumulator carry bit is set when this routine is called, a pointer to
              ; the lowest byte of RAM will be returned in the X and Y registers. On
              ; the unexpancted VIC the initial value of this pointer is $1000. If the
              ; accumulator carry bit is clear (0) when this routine is called, the
              ; values of the X and Y registers will be transferred to the low and
              ; high bytes respectively of the pointer to the beginning of RAM.

              ; TO READ THE BOTTOM OF RAM
              ; 1) Set the carry.
              ; 2) Call this routine.

              ; TO SET THE BOTTOM OF MEMORY
              ; 1) Clear the carry.
              ; 2) Call this routine.

              ; MOVE BOTTOM OF MEMORY UP 1 PAGE
              ; SEC      ;READ MEMORY BOTTOM
              ; JSR MEMBOT
              ; INY
              ; CLC      ;SET MEMORY BOTTOM TO NEW VALUE
              ; JSR MEMBOT

ff96 4c 2e fe    JMP Kernal_MEMBOT

              ; ******
ff99            SCNKEY             ; Scan the keyboard
              ; ******

              ; Call address: $FF9F
              ; Com muni cation registers: None
              ; Preparatory routines: None
              ; Error returns: None
              ; Stack requirements: None
              ; Registers affected: A, X, Y

              ; This routine will scan the VIC keyboard and check for pressed keys. It
              ; is the same routine called by the interrupt handler. If a key is down,
              ; its ASCII value is placed in the keyboard queue.

              ; 1) Call this routine

              ; GET JSR SCNKEY ;SCAN KEYBOARD
              ;     JSR GETIN  ;GET CHARACTER
              ;     CMP #0     ;IS IT NULL?
              ;     BEQ GET    ;YES, SCAN AGAIN
              ;     JSR CHROUT ;PRINT IT

ff99 4c 87 ea    JMP Kernal_SCNKEY

              ; ******
ff9c            SETTMO             ; Set serial bus timeout flag
              ; ******

              ; Call address: $FFA2
              ; Communication registers: A
              ; Preparatory routines: None
              ; Error returns: None
              ; Stack requirements: 2
              ; Registers affected: None

              ; This routine sets the timeout flag for the serial bus. When the
              ; timeout flag is set, the VIC will wait for a device on the serial port
              ; for 64 milliseconds. If the device does not respond to the VIC's DAV
              ; signal within that time the VIC will recognize an error condition and
              ; leave the handshake sequence. When this routine is called when the
              ; accumulator contains a 0 in bit 7, timeouts are enabled, A 1 in bit 7
              ; will disable the timeouts. NOTE: The VIC uses the timeout feature to
              ; communicate that adisk file is not found on an attempt to OPEN a file.

              ; TO SET THE TIMEOUT FLAG
              ; 1) Set bit 7 of the accumulator to 0,
              ; 2) Call this routine.

              ; TO RESET THE TIMEOUT FLAG
              ; 1) Set bit 7 of the accumulator to 1.
              ; 2) Call this routine,

              ; DISABLE TIMEOUT
              ; LDA #0
              ; JSR SETTMO

ff9c 4c 1b fe    JMP Kernal_SETTMO

              ; *****
ff9f            ACPTR              ; Get data from the serial bus
              ; *****

              ; Call address: $FFA5
              ; Communicaiion registers: A
              ; Preparatory routines: TALK, TKSA
              ; Error returns: See READST
              ; Stack requirements: 13
              ; Registers affected: A X

              ; This is the routine to use to get information from a device on the
              ; serial bus (like the disk). This routine gets a byte of data off the
              ; serial bus using full handshaking. The data is returned in the
              ; accumulator. To prepare for this routine the TALK routine must have
              ; been called first to command the device on the serial bus to send data
              ; on the bus. If the input device needs a secondary command, it must be
              ; sent by using the TKSA KERNAL routine before calling this routine.
              ; Errors are returned in the status word. The READST routine is used to
              ; read the status word.

              ; 0) Command a device on the serial bus to prepare to send data to the
              ;    VIC. (Use the TALK and TKSA kernal routines).
              ; 1) Call this routine (using JSR)
              ; 2) Store or otherwise use the data.

              ; Get a byte from the bus
              ; JSR ACPTR
              ; STA DATA

0001 FALSE    #if JIFFY
SKIP             JMP Jiffy_ACPTR
              #else
ff9f 4c 13 ee    JMP Kernal_ACPTR
              #endif

              ; *****
ffa2            CIOUT              ; Transmit a byte over the serial bus
              ; *****

              ; Call address: $FFA8
              ; Communication registers: A
              ; Preparatory routines: LISTEN, [SECOND]
              ; Error returns: See READST
              ; Stack requirements: None
              ; Registers affected: A

              ; This routine is used to send information to devices on the serial bus.
              ; A call to this routine wilt put a data byte onto the serial bus using
              ; full serial handshaking. Before this routine is called, the LISTEN
              ; KERNAL routine must be used to command a device on the serial bus to
              ; get ready to receive data. (If a device needs a secondary address, it
              ; must also be sent by using the SECOND KERNAL routine.) The accumulator
              ; is loaded with a byte to handshake as data on the serial bus. A device
              ; must be listening or the status word will return a timeout. This
              ; routine always buffers one character. (The routine holds the previous
              ; character to be sent back,) So when a call to the KERNAL UNLSN routine
              ; is made to end the data transmission, the buffered character is sent
              ; with EOl set. Then the UNLSN command is sent to the device.

              ; 0) Use the LISTEN KERNAL routine (and the SECOND routine if needed).
              ; 1) Load the accumulator with a byte of data.
              ; 2) Call this routine to send the data byte.

              ; Send an X to the serial bus
              ; LDA #'X'
              ; JSR CIOUT

ffa2 4c dd ed    JMP Kernal_CIOUT

              ; *****
ffa5            UNTLK              ; Send an UNTALK command
              ; *****

              ; Call address; $FFAB
              ; Communication registers: None
              ; Preparatory routines: None
              ; Error returns: See READST
              ; Stack requirements: None
              ; Registers affected: A

              ; This routine will transmit an UNTALK command on the serial bus. All
              ; devices previously set to TALK will stop sending data when this
              ; command is received.

              ; 1) Call this routine.

              ; JSR UNTALK

ffa5 4c ef ed    JMP Kernal_UNTLK

              ; *****
ffa8            UNLSN              ; Send an UNLISTEN command
              ; *****

              ; Call address: $FFAE
              ; Communication registers: None
              ; Preparatory routines: None
              ; Error returns: See READST
              ; Stack requirements: None
              ; Registers affected: A

              ; This routine commands all devices on the serial bus to stop receiving
              ; data from the VIC. (i.e., UNLISTEN}. Calling this routine results in
              ; an UNLISTEN command being transmitted on the serial bus. Only devices
              ; previously commanded to listen wilt be affected. This routine is
              ; normally used after the VIC is finished sending data to external
              ; devices. Sending the UNLISTEN will command the listening devices to
              ; get off the serial bus so it can be used for other purposes.

              ; 1) Call this routine.

              ; JSR UNLSN

ffa8 4c fe ed    JMP Kernal_UNLSN

              ; ******
ffab            LISTEN             ; Command a device to LISTEN
              ; ******

              ; Call Address: $FFB1
              ; Communication registers: A
              ; Preparatory routines: None
              ; Error returns: See READST
              ; Stack requirements: None
              ; Registers affected: A

              ; This routine will command a device on the serial bus to receive data.
              ; The accumulator must be loaded with a device number between 4 and 31
              ; before calling the routine. LISTEN will OR the number bit by bit to
              ; convert to a listen address, then transmit this data as a command on
              ; the serial bus. The specified device will then go into listen mode,
              ; and be ready to accept information.

              ; 1) Load the accumulator with the number of the device to command to
              ;    LISTEN.
              ; 2) Call this routine using the JSR instruction.

              ; COMMAND DEVICE #8 TO LISTEN
              ; LDA #8
              ; JSR LISTEN

ffab 4c 0c ed    JMP Kernal_LISTEN

              ; ****
ffae            TALK               ; Command a device on the serial bus to TALK
              ; ****

              ; Call address: $FFB4
              ; Communication registers: A
              ; Preparatory routines: None
              ; Error returns: See READST
              ; Stack requirements: None
              ; Registers affected: A

              ; To use this routine the accumulator must first be loaded with a device
              ; number between 4 and 30. When called, this routine then ORs bit by
              ; bits to convert this device number to a talk address. Then this data
              ; is transmitted as a command on the Serial bus.

              ; 1) Load the accumulator with the device number.
              ; 2) Call this routine.

              ; COMMAND DEVICE #4 TO TALK
              ; LDA #4
              ; JSR TALK

ffae 4c 09 ed    JMP Kernal_TALK

              ; ******
ffb1            READST             ; Read status word
              ; ******

              ; Call address: $FFB7
              ; Communication registers: A
              ; Preparatory routines: None
              ; Error returns: None
              ; Stack requirements: 2
              ; Registers affected: A

              ; This routine returns the current status of the I/O devices in the
              ; accumulator. The routine is usually called after new communication to
              ; an I/O device. The routine will give information about device status,
              ; or errors that have occurred during the I/O operation. The bits
              ; returned in the accumulator contain the following information
              ; (see table befow):

              ; How to use:
              ; 1) Call this routine.
              ; 2) Decode the information in the .A register as it refers to your
              ;    program.

              ; CHECK FOR END OF FILE DURING READ
              ; JSR READST
              ; AND #64 ;check eof bit
              ; BNE EOF ;branch on eof

              ; Bit Val Comment
              ; 0    1  timeout writing to   IEC bus
              ; 1    2  timeout reading from IEC bus
              ; 2    4  short block    during tape I/O
              ; 3    8  long  block    during tape I/O
              ; 4   16  read error     during tape I/O
              ; 5   32  checksum error during tape I/O
              ; 6   64  EOF (End-Of-File) on IEC bus
              ; 7 -128  device not present

ffb1 4c 01 fe    JMP Kernal_READST

              ; ******
ffb4            SETLFS             ; Set up a logical file
              ; ******

              ; Call address: $FFBA
              ; Communication registers: A, X, Y
              ; Preparatory routines: None
              ; Error returns: None
              ; Stack requirements: 2
              ; Registers affected: None

              ; This routine will set the logica! file number, device address, and
              ; secondary address (command number) for other KERNAL routines. The
              ; logical fife number is used by the system as a key to the file table
              ; created by the OPEN file routine. Device addresses can range from 0 to
              ; 30. The following codes are used for the following CBM devices.

              ; Addr. DEVICE
              ; ------------
              ;    0  Keyboard
              ;    1  Cassette #1
              ;    2  RS-232C device
              ;    3  CRT display
              ;  4-5  Serial Bus printer
              ;  6-7  Serial Bus plotter
              ;  8-x  Serial bus disk drive

              ; Device numbers 4 or greater automatically refer to devices on the
              ; serial bus. A command to the device is sent as a secondary address on
              ; the serial bus after the device number is sent during the serial
              ; attention handshaking sequence. It no secondary address is to be sent
              ; the Y index register should be set to 255.

              ; 1) Load the accumulator with the logical file number.
              ; 2) Load the X index register with the device number.
              ; 3) Load the Y index register with the command.

              ; For logical file 32, device #4, and no command:
              ; LDA #32
              ; LDX #4
              ; LDY #255
              ; JSR SETLFS

ffb4 4c fa fd    JMP Kernal_SETLFS

              ; ******
ffb7            SETNAM             ; Set up file name
              ; ******

              ; Call address: $FFBD
              ; Communication registers: A, X, Y
              ; Preparatory routines: None
              ; Stack requirements: None
              ; Registers affected: None

              ; This routine is used to set up the file name for the OPEN, SAVE, or
              ; LOAD routines. The accumulator must be loaded with the length of the
              ; file name. The X and Y registers must be loaded with the address of
              ; the file name, in standard 6502 low byte, high byte format.
              ; The address can be any valid memory address in the system where a
              ; string of characters for the file name is stored. If no file name is
              ; desired, the accumulator must be set to 0, representing a zero file
              ; length. The X and Y registers may be set to any memory address in that
              ; case.

              ; 1) Load the accumulator with the length of the file name.
              ; 2) Load the X index register with the low order address of the file
              ;     name.
              ; 3) Load the Y index register with the high order address.
              ; 4) Call this routine.

              ; LDA #NAME2-NAME ;LOAD LENGTH OF FILE NAME
              ; LDX #<NAME
              ; LDY #>NAME
              ; JSR SETNAM

ffb7 4c f3 fd    JMP Kernal_SETNAM

              ; ****
ffba            OPEN               ; Open a logical file
              ; ****

              ; Call address: $FFC0
              ; Communication registers: None
              ; Preparatory routines: SETLFS, SETNAM
              ; Error returns: 1,2,4,5,6
              ; Stack requirements: None
              ; Registers affected: A, X, Y

              ; This routine is used to open a logical file. Once the logical file is
              ; set up, it can be used for input/output operations. Most of the I/O
              ; KERNAL routines call on this routine to create the logical files to
              ; operate on. No arguments need to be set up to use this routine, but
              ; both the SETLFS and SETNAM KERNAL routines must be called before using
              ; this routine.

              ; 0) Use the SETLFS routine.
              ; 1) Use the SETNAM routine.
              ; 2) Call this routine.

              ; This is an implementation of the BASIC statement: OPEN 15,8,15,"I0"
              ; LDA #NAME2-NAME ;LENGTH OF FILE NAME FOR SETLFS
              ; LDY #>NAME
              ; JSR SETNAW
              ; LDA #15
              ; LDX #8
              ; LDY #15
              ; JSR SETLFS
              ; JSR OPEN
              ; NAME  .BYTE "I0"
              ; NAME2

ffba 6c 1a 03    JMP (IOPEN)

              ; *****
ffbd            CLOSE              ; Close a logical file
              ; *****

              ; Call address: $FFC3
              ; Communication registers: A
              ; Preparatory routines: None
              ; Error returns: None
              ; Stack requirements: None
              ; Registers affected: A, X

              ; This routine is used to close a logical file after all I/O operations
              ; have been completed on that file. This routine is called after the
              ; accumulator is loaded with the logical file number to be closed (the
              ; same number used when the file was opened using the OPEN routine).

              ; How to use:
              ; 1) Load the accumulator with the number of the logical file to be
              ;    closed.
              ; 2) Call this routine

              ; CLOSE 15
              ; LDA #15
              ; JSR CLOSE

ffbd 6c 1c 03    JMP (ICLOSE)

              ; *****
ffc0            CHKIN              ; Open a channel for input
              ; *****

              ; Call address: $FFC6
              ; Communication registers: X
              ; Preparatory routines: (OPEN)
              ; Error returns: 3,5,6
              ; Stack requirements: None
              ; Registers affected: A, X

              ; Any logical file that has already been opened by the KERNAL OPEN
              ; routine can be defined as an input channel by this routine. Naturally,
              ; the device on the channel must be an input device. Otherwise, an error
              ; will occur, and the routine will abort. If you are getting data from
              ; anywhere other than the keyboard, this routine must be called before
              ; using either the CHRIN or the GETIN KERNAL routines for data input. If
              ; input from the keyboard is desired, and no other input channels are
              ; opened, then the calls to this routine, and to the OPEN routine, are
              ; not needed. When this routine is used with a device on the serial bus,
              ; this routine automatically sends the talk address (and the secondary
              ; address if one was specified by the OPEN routine) over the bus.

              ; To use this routine:
              ; 0) OPEN the logical file (if necessary; see description above).
              ; 1) Load the .X register with number of the logical file to be used.
              ; 2) Call this routine (using a JSR command}.

              ; Possible errors are:
              ; #3: File not open
              ; #5: Device not present
              ; #6: File not an input file

              ; PREPARE FOR INPUT FROM LOGICAL FILE 2
              ; LDX #2
              ; JSR CHKIN

ffc0 6c 1e 03    JMP (ICHKIN)

              ; ******
ffc3            CHKOUT             ; Open a channel for output
              ; ******

              ; Call address: $FFC9
              ; Communication registers: X
              ; Preparatory routines: (OPEN)
              ; Error returns: 3,5,7
              ; Stack requirements: None
              ; Registers Affected: A, X

              ; Any logical file number which has been created by the KERNAL routine
              ; OPEN can be defined as an output channel. Of course, the device you
              ; intend opening a channel to must be an output device. Otherwise, an
              ; error will occur, and the routine will be aborted. This routine must
              ; be called before any data is sent to any output device unless you want
              ; to use the VIC screen as your output device, If screen output is
              ; desired, and there are no other output channels already defined, then
              ; the calls to this routine, and to the OPEN routine are not needed.
              ; When used to open a channel to a device on the serial bus, this
              ; routine will automatically send the LISTEN address specified by the
              ; OPEN routine (and a secondary address if there was one).

              ; How to use: (This routine is NOT NEEDED to send data to the screen)
              ; 0) Use the KERNAL OPEN routine to specify a logical file number, a
              ;    LISTEN address, and a secondary address (if needed).
              ; 1) Load the X register with the logical file number used in the open
              ;    statement,
              ; 2) Call this routine (by using the JSR instruction).

              ; Possible error returns:
              ; 3: File not open
              ; 5: Device not present
              ; 7: Not an output file

ffc3 6c 20 03    JMP (ICKOUT)      ; do open for output vector

              ; ******
ffc6            CLRCHN             ; Clear I/O channels
              ; ******

              ; Call address: $FFCC
              ; Communication registers: None
              ; Preparatory routines: None
              ; Error routines: None
              ; Stack requirements: 9
              ; Registers affected: A, X

              ; This routine is called to clear all open channels and restore the I/O
              ; channels to their original default values. It is usually called after
              ; opening other I/O channels (like to the disk or tape drive) and using
              ; them for input-output operations. The default input device is 0
              ; (keyboard). The default output device is 3 (the VIC screen). If one of
              ; the channels to be closed is to the serial port, an UNTALK signal is
              ; sent first to clear the input channel or an UNLISTEN is sent to clear
              ; the output channel. By not calling this routine (and leaving
              ; listeners active on the serial bus) several devices can receive the
              ; same data from the VIC at the same time. One way to take advantage of
              ; this would be to command the printer to LISTEN and the disk to TALK.
              ; This would allow direct printing of a disk file.

              ; JSR CLRCHN

ffc6 6c 22 03    JMP (ICLRCH)

              ; *****
ffc9            CHRIN              ; Get a character from the input channel
              ; *****

              ; Call address: $FFCF
              ; Communication registers: A
              ; Preparatory routines: (OPEN, CHKIN)
              ; Error returns: See READST
              ; Stack requirements: None
              ; Registers affected: A, X

              ; This routine wtll get a byte of data from the channel already set up
              ; as the input channel by the KERNAL routine CHKIN. If the CHKIN has
              ; not been used to define another input channel, data is expected from
              ; the keyboard. The data byte is returned in the accumulator. The
              ; channel remains open after the call. Input from the keyboard is
              ; handled in a special way. First, the cursor is turned on, and will
              ; blink until a carriage return is typed on the keyboard. All characters
              ; on the line (up to 88 characters) will be stored in the BASIC input
              ; buffer. Then the characters can be retrieved one at a time by calling
              ; this routine once for each character. When the carriage return is
              ; retrieved, the entire line has been processed. The next time this
              ; routine is called, the whole process begins again, i.e., by flashing
              ; the cursor.

              ; FROM THE KEYBOARD
              ; 1) Call this routine (using the JSR instruction).
              ; 2) Retrieve a byte of data by calling this routine,
              ; 3) Store the data byte.
              ; 4) Check if it is the last data byte (a CR ?). If not, goto step 2.

              ; RD          ; label
              ; LDX #0        ; store 0 in the X register
              ; JSR CHRIN
              ; STA DATA,X    ; store data byte in the Xth location in the data area.
              ; CMP #CR       ; is it a carriage return?
              ; BNE RD        ; no, get another data byte

              ; FROM KEYBOARD
              ; JSR CHRIN
              ; STA DATA

              ; FROM OTHER DEVICES
              ; 0) Use the KERNAL OPEN and CHKIN routines,
              ; 1) Call this routine (using a JSR instruction)-
              ; 2) Store the data.

              ; JSR CHRIN
              ; STA DATA

ffc9 6c 24 03    JMP (IBASIN)

              ; ******
ffcc            CHROUT             ; Output a character
              ; ******

              ; Call address: $FFD2
              ; Communication registers: A
              ; Preparatory routines: (CHKOUT, OPEN)
              ; Error returns: See READST
              ; Stack requirements: None
              ; Registers affected: None

              ; This routine will output a character to an already opened channel. Use
              ; the KERNAL OPEN and CHKOUT routines to set up the output channel
              ; before calling this routine. If this call is omitted, data will be
              ; sent to the default output device (number 3, on the screen). The data
              ; byte to be output is loaded into the accumulator, and this routine is
              ; called. The data is then sent to the specified output device. The
              ; channel is left open after the call.
              ; NOTE: Care must be taken when using this routine to send data to a
              ; serial device since data will be sent to all open output channels on
              ; the bus. Unless this Is desired, all open output channels on the
              ; serial bus other than the actually intended destination channel must
              ; be closed by a call to the KERNAL close channel routine.

              ; How to use:
              ; 0) Use the CHKOUT KERNAL routine if needed (see description above).
              ; 1) Load the data to be output into the accumulator.
              ; 2) Call this routine.

              ; Duplicale the BASIC instruction CMD 4,"A";
              ; LDX #4     ;LOGICAL FILE #4
              ; JSR CHKOUT ;OPEN CHANNEL OUT
              ; LDA #'A'
              ; JSR CHROUT ;SEND CHARACTER

ffcc 6c 26 03    JMP (IBSOUT)

              ; ****
ffcf            LOAD               ; Load RAM from device
              ; ****

              ; Call address: $FFD5
              ; Communication registers: A, X, Y
              ; Preparatory routines: SETLFS, SETNAM
              ; Error returns: 0,4,5,8,9
              ; Stack requirements: None
              ; Registers affected: A, X, Y

              ; This routine will load data bytes from any input device directly into
              ; the memory of the VIC. It can also be used for a verily operation,
              ; comparing data from a device with the data already in memory, leaving
              ; the data stored in RAM unchanged. The accumulator (A) must be set to 0
              ; for a load operation, or 1 for a verify. If the input device was
              ; OPENed with a secondary address (SA) of 0 the header information from
              ; device will be ignored. In this case, the X and Y registers must
              ; contain the starting address for the load. If the device was addressed
              ; with a secondary address of 0, 1, or 2 the data will load into memory
              ; starting at the location specified by the header, This routine returns
              ; the address of the highest RAM location which was loaded. Before this
              ; routine can be called, the KERNAL SETLFS, and SETNAM routines must be
              ; called.

              ; How to use
              ; 0) Call the SETLFS, and SETNAM routines. If a relocated load is
              ;    desired, use the SETLFS routine to send a secondary address of 3.
              ; 1) Set the A register to 0 for load, 1 for verify.
              ; 2) If a relocated load is desired, the X and Y registers must be set
              ;    to the start address for the load.
              ; 3) Call the routine using the JSR instruction.

ffcf 4c 98 f4    JMP Kernal_LOAD

              ; ****
ffd2            SAVE               ; Save memory to a device
              ; ****

              ; Call address: $FFD8
              ; Communication registers: A, X, Y
              ; Preparatory routines: SETLFS, SETNAM
              ; Error returns: 5,8,9
              ; Stack requirements: None
              ; Registers affected: A, X, Y

              ; This routine saves a section of memory. Memory is saved from an
              ; indirect address on page 0 specified by the accumulator to the address
              ; stored in the X and Y registers to a logical file (an input/output
              ; device). The SETLFS and SETNAM routines must be used before calling
              ; this routine. However, a file name is not required to SAVE to device 1
              ; (the cassette tape recorder). Any attempt to save to other devices
              ; without using a file name results in an error.
              ; NOTE: Device 0 (the keyboard) and device 3 (the screen) cannot be
              ; SAVEd to. If the attempt is made, an error will occur, and the SAVE
              ; stopped.

              ; How to use;
              ; 0) Use the SETLFS routine and the SETNAM routine (unless a SAVE with
              ;    no file name is desired on a save Jo the tape recorder).
              ; 1) Load two consecutive locations on page 0 with a pointer to the
              ;    start ol your save (in standard 6502 low byte first, high byte next
              ;    format).
              ; 2) Load the accumulator with the single byte page zero offset to the
              ;    pointer.
              ; 3) Load the X and Y registers with the low byte and high byte
              ;    respectively of the location of the end of the save.
              ; 4) Call this routine.

ffd2 4c d7 f5    JMP Kernal_SAVE

              ; ******
ffd5            SETTIM             ; Set the system clock
              ; ******

              ; Call address: $FFDB
              ; Communication registers: A, X, Y
              ; Preparatory routines: None
              ; Error returns: None
              ; Stack requirements: 2
              ; Registers affected: None

              ; A system clock is maintained by an interrupt routine that updates the
              ; clock every 1/60th of a second (one 'jiffy'). The clock is three bytes
              ; long, which gives it the capability to count up to 5,184,000 jiffies
              ; (24 hours). At that point the clock resets to zero. Before calling
              ; this routine to set the clock, the accumulator must contain the most
              ; significant byte, the X index registerthe next most significant byte,
              ; and the Y index register the least significant byte of the initial
              ; time setting (in jiffies).

              ; How to use:
              ; 1) Load the accumulator with the MSB of the 3 byte number.
              ; 2) Load the X register with the next byte.
              ; 3) Load the Y register with the LSB.
              ; 4) Call this routine.

ffd5 4c de f6    JMP Kernal_SETTIM

              ; *****
ffd8            RDTIM              ; Read system clock
              ; *****

              ; Call address: $FFDE
              ; Communication registers: A, X, Y
              ; Preparatory routines: None
              ; Error returns: None
              ; Stack requirements: 2
              ; Registers affected: A, X, Y

              ; This routine is used to read the system clock. The clock's resolution
              ; is a 60th of a second. Three bytes are returned by the routine. The
              ; accumulator contains the most significant byte, the X index register
              ; contains the next most significant byter and the Y index register
              ; contains the least significant byte.

ffd8 4c d7 f6    JMP Kernal_RDTIM

              ; ****
ffdb            STOP               ; Check if stop key is pressed
              ; ****

              ; Call address: $FFE1
              ; Communication registers: A
              ; Preparatory routines: None
              ; Error returns: None
              ; Stack requirements: None
              ; Registers affected: A, X

              ; If the STOP key on the keyboard is pressed when this routine is
              ; called, the Z flag will be set. All other flags remain unchanged. If
              ; the STOP key is not pressed then the accumulator will contain a byte
              ; representing the last row of the keyboard scan.
              ; The user can also check for certain other keys this way.

              ; How to use this routine:
              ; 1) Call this routine.
              ; 2) Test for the zero flag.

0001 FALSE    #if JIFFY & VIC
SKIP             JMP Jiffy_STOP
              #else
ffdb 6c 28 03    JMP (ISTOP)
              #endif

              ; *****
ffde            GETIN              ; Get a character from the keyboard buffer
              ; *****

              ; Call address: $FFE4
              ; Communication registers: A
              ; Preparatory routines: None
              ; Error returns: None
              ; Stack requirements: None
              ; Registers affected: A, X

              ; This subroutine removes one character from the keyboard queue and
              ; returns it as an ASCII value in the accumulator. If the queue is
              ; empty, the value returned in the accumulator will be zero. Characters
              ; are put into the queue automatically by an interrupt driven keyboard
              ; scan routine which calls the SCNKEY routine. The keyboard buffer can
              ; hold up to ten characters. After the buffer is filled, additional
              ; characters are ignored until at least one character has been removed
              ; from the queue.

              ; How to use:
              ; 1) Call this routine using a JSR instruction
              ; 2) Check for a zero in the accumulator (empty buffer)
              ; 3) Process the data

ffde 6c 2a 03    JMP (IGETIN)

              ; *****
ffe1            CLALL              ; Close all files
              ; *****

              ; Call address: SFFE7
              ; Communication registers: None
              ; Preparatory routines: None
              ; Error returns: None
              ; Stack requirements: 11
              ; Registers affected: A, X

              ; This routine closes all open files. When this routine is called, the
              ; pointers into the open file table are reset, closing all files. Also,
              ; the routine automatically resets the I/O channels.

ffe1 6c 2c 03    JMP (ICLALL)

              ; *****
ffe4            UDTIM              ; Update the system clock
              ; *****

              ; Call address: $FFEA
              ; Communication registers: None
              ; Preparatory routines: None
              ; Error returns: None
              ; Stack requirements: 2
              ; Registers affected: A, X

              ; This routine updates the system clock. Normally this routine is called
              ; by the normal KERNAL interrupt routine every 1 /60th of a second. If
              ; the user program processes its own interrupts this routine must be
              ; called to update the time. Also, the STOP key routine must be called,
              ; if the stop key is to remain functional.

ffe4 4c 95 f6    JMP Kernal_UDTIM

              ; ******
ffe7            SCREEN             ; Return screen format
              ; ******

              ; Call address: $FFED
              ; Communication registers: X, Y
              ; Preparatory routines: None
              ; Stack requirements: 2
              ; Registers affected: X, Y

              ; This routine returns the format of the screen, e.g., 22 columns in X
              ; and 23 lines in Y. This routine can be used to determine what machine
              ; a program is running on, and has been implemented on the VIC to help
              ; upward compatibility in programs.

ffe7 4c 05 e5    JMP Kernal_SCREEN

              ; ****
ffea            PLOT               ; Read or set cursor location
              ; ****

              ; Call address: $FFF0
              ; Communication registers: A, X, Y
              ; Preparatory routines: None
              ; Error returns: None
              ; Stack requirements: 2
              ; Registers affected: A, X, Y

              ; A call to this routine, with the accumulator carry flag set, loads the
              ; current position of the cursor on the screen (in X,Y coordinates) into
              ; the X and Y registers. X is the column number of the cursor location
              ; (0-21), and Y is the row number of the location of the cursor (0-22).
              ; A call with the carry bit clear moves the cursor to X,Y as determined
              ; by the X and Y registers.

              ; READING CURSOR LOCATION
              ; 1) Set the carry flag.
              ; 2) Call this routine.
              ; 3) Get the X and Y position from the X and Y registers respectively.

              ; SETTING CURSOR LOCATION
              ; 1) Clear carry flag.
              ; 2) Set the X and Y registers to the desired cursor location.
              ; 3) Call this routine.

ffea 4c 0a e5    JMP Kernal_PLOT

              ; ******
ffed            IOBASE             ; Define I/O memory page
              ; ******

              ; Call address: $FFF3
              ; Communication registers: X, Y
              ; Preparatory routines: None
              ; Error returns: None ,
              ; Stack requirements: 2
              ; Registers affected: X, Y

              ; This routine will set the X and Y registers to the address of the
              ; memory section where the memory mapped I/O devices are located. This
              ; address can then be used with an offset to access the memory mapped
              ; I/O devices in the VIC. The offset will be the number of locations
              ; from the beginning of the page that the desired I/O register is
              ; located. The X register will contain the low order address byte,
              ; while the Y register will contain the high order address byte.
              ; This routine exists to provide compatibility between the VIC 20 and
              ; future models of the VIC. IF the I/O locations for a machine language
              ; program are set by a call to this routine, they should still remain
              ; compatible with future versions of the VIC, the KERNAL and BASIC.

              ; How to use:
              ; 1) Call this routine by using the JSR instruction.
              ; 2) Store the X and the Y registers in consecutive locations.
              ; 3) Load the Y register with the offset.
              ; 4) Access that I/O location.

ffed 4c 00 e5    JMP Kernal_IOBASE

0000 TRUE     #if C64
fff0 52 52 42    .byte "RRBY"
              #endif
0001 FALSE    #if VIC
SKIP             .FILL   4 (-1)    ; unused
              #endif

fff4 3d fe       .word   Entry_NMI ; Non Maskable Interrupt vector
fff6 dc fc       .word   Entry_RESET; Reset vector
fff8 42 ff       .word   Entry_IRQ ; Interrupt Request vector



 1860 Symbols
-------------
JIFFY                          $0000     8D   829   1144   8042   8297
                                      8408   8420   8428   8436   8467
                                      8520   8596   8694   8987   9706
                                      9727   9991  10283  10297  10302
                                     10314  10321  10333  10369  10376
                                     10589  10758  10772  10858  11037
                                     11069  11088  11094  11132  11828
                                     11970  12003  12119  12193  12206
                                     12248  12444  12651  12660  12674
                                     12960  12967  12994  13009  13016
                                     13024  13062  13094  13104  13233
                                     13397  13465  13699  16493  16666
                                     17610  18263
D6510                          $0000   634D 16713
PAL                            $0001     9D  8506  10659  16774  16780
                                     17132
C64                            $0001     5D   418   1550   1582   1609
                                      1797   2050   2793   3038   3569
                                      7572   7663   7669   7865   7964
                                      8004   8277   8306   8419   8458
                                      8519   8877   8905   9028   9200
                                      9629   9707   9837   9882   9912
                                      9926  10013  10028  10041  10056
                                     10067  10081  10123  10137  10145
                                     10153  10187  10199  10288  10404
                                     10430  10456  10487  10503  10524
                                     10541  10563  10723  10769  10790
                                     10864  10888  10917  10954  11011
                                     11038  11047  11085  11115  11145
                                     11158  11171  11189  11209  11225
                                     11238  11273  11309  11404  11444
                                     11512  11530  11610  11636  11651
                                     11662  11668  11686  11718  11738
                                     11768  11774  11783  11795  11815
                                     11829  11940  12130  12137  12177
                                     12203  12207  12264  12281  12416
                                     12460  12484  12496  12500  12750
                                     12757  12763  12795  12809  12836
                                     12846  12883  12891  12922  12974
                                     13000  13176  13196  13214  13225
                                     13237  13502  13586  13632  13865
                                     14114  14129  14139  14149  14157
                                     14356  14363  14371  14379  14500
                                     14515  14536  14615  14635  14718
                                     14755  14814  14823  14934  14986
                                     15163  15218  15375  15424  15455
                                     15467  15475  15488  15494  15525
                                     15586  15598  15660  15735  15750
                                     15812  15837  15852  16026  16123
                                     16133  16144  16174  16329  16340
                                     16347  16391  16438  16470  16553
                                     16577  16667  16690  16756  16815
                                     16820  16935  16957  16964  16984
                                     17027  17036  17043  17061  17072
                                     17098  17118  17163  17252  18410
R6510                          $0001   635D 10029  10042  10068  15377
                                     15379  15489  15496  16127  16134
                                     16392  16394  16711
IEC_IFR_BIT                    $0002   669D 11167
COLINK                         $0002   645D  9559   9579
ADRAY1                         $0003   703D  8350   8350
RS232_C_BIT                    $0004   672D 11352
ADRAY2                         $0005   711D  8348   8348
CHARAC                         $0007   720D  3195   3201   3202   3287
                                      3316   3847   3852   3856   4533
                                      4546   5406   5421   7129   7609
                                      7687
IEC_ATN_BIT                    $0008   668D 10783  11092
ENDCHR                         $0008   721D  2476   2537   2542   3197
                                      3200   3205   3210   3863   4536
                                      4541   5407   5423
TRMPOS                         $0009   722D  3585   3592
LF                             $000a   683D  3546
VERCK                          $000a   735D  7950   7952   7956
COUNT                          $000b   736D  2300   2358   2380   2495
                                      2511   2553   4529   4532   4535
                                      4540   4542   4545   4547   4846
                                      4934   4995   5022   5050   5100
                                      5144
DIMFLG                         $000c   743D  4646   4906   4941   4992
                                      5031   5089
CR                             $000d   682D  2439   3542   9006
VALTYP                         $000d   749D  3335   3519   3840   4040
                                      4102   4132   4242   4395   4567
                                      4665   4685   4909   4937   5223
                                      5241   5480   6007
INTFLG                         $000e   755D  3333   3878   4422   4666
                                      4694   4907   4939
Default_Color                  $000e   648D  8817
GARBFL                         $000f   770D  2463   2479   2529   2740
                                      2773   2775   2814   5492   5519
                                      5523
IEC_CLK_BIT                    $0010   670D 10941  11260  11269
SUBFLG                         $0010   776D  2688   2844   4691   4707
                                      4714   5286   5305
INPFLG                         $0011   787D  3669   3806   3818   3842
                                      3926
TANSGN                         $0012   788D  4217   4615   8169   8171
                                      8193   8202
IOPMPT                         $0013   799D  2234   3490   3535   3544
                                      3643   3685   3707   3717   3728
                                      3736   3741   3765   3776   3785
                                      3828   3934   8281   8362
LINNUM                         $0014   807D  2375   2375   2587   2595
                                      2729   2730   2735   2736   2752
                                      2754   3104   3106   3281   3282
                                      3288   3303   3308   3309   3311
                                      3312   3313   3314   3315   3317
                                      3319   6118   6119   6126   6126
                                      6129y  6131   6131   6141y  6160y
                                      7908
TEMPPT                         $0016   812D  2677   5461   5485   5555
                                      5871   8368
LASTPT                         $0017   817D  5481   5867   5869   5873
                                      8363
TEMPST                         $0019   818D  2676   5550   8367
ROWS                           $0019   644D  8767   8844   8848   9188
                                      9533   9594   9674   9696   9698
                                      9700   9783   9801   9817
IEC_DAT_BIT                    $0020   671D 11280  11289
INDEXA                         $0022   824D  2115   2125   2133   2163
                                      2165   2229   2231   2240y  2308
                                      2310   2335   2337   2341y  2345
                                      2401   2401   2406y  2412y  2416
                                      2419y  2420   2423y  2424   2425
                                      2876   2876   3289   3305   3307
                                      3310   3410y  3631y  4108   4110
                                      4178   4179   4181   4194   5049
                                      5139   5178   5552   5552   5564
                                      5564   5592   5592   5594y  5597y
                                      5600y  5604y  5612y  5616   5617
                                      5619   5622   5638y  5641y  5662y
                                      5665y  5668y  5685   5685   5693
                                      5694   5696   5699   5783   5783
                                      5795y  5830   5830   5834y  5837y
                                      5840y  5860   5860   5924   5925
                                      5927   6018y  6061   6064   6066
                                      6602   6602   6604y  6607y  6610y
                                      6613y  6621y  6829   6829   6831y
                                      6834y  6837y  6840y  6845y  6876
                                      6876   6879y  6882y  6885y  6890y
                                      6893y  7777   7777   7779y  7782y
                                      7785y  7788y  8137   8138
QUOTE                          $0022   684D  2477   2771   3213   3748
                                      3853   4272   5405   5427   5462
                                      9123   9128
INDEXB/FAC3                    $0024   825D  2312   2319   2331   2342y
                                      2346   3977   6065   6072   6074y
                                      6077y  6082y  7026   7036   7038y
                                      7042y  7047y  7052y  7056y  7062y
                                       827D  5159   5180   5188   5207
                                      5210   6422   6538   6539   6540
                                      6541   6572   6574   6575   6577
                                      6578   6580   6581   6583   6586
                                      6587   6588   6589   6754   6815
                                      6817   6819   6821
COLS                           $0028   643D  8766   8838   8871   8888
                                      8895   9216   9374   9383   9482
                                      9566   9580   9586   9862   9907
TXTTAB                         $002b   835D  2400   2400   2575   2575
                                      2626y  2628y  2629   2633   2698
                                      2701   2986   2988   3117   3117
                                      7933   7953   7953   8371   8371
                                      8378y  8379   8381   8390   8390
                                      8395   8398
VARTAB                         $002d   839D  2309   2317   2318   2320
                                      2322   2327   2356   2360   2379
                                      2379   2632   2635   2662   2662
                                      3437   3441   4715   4715   5563
                                      5563   7932   7932   7997   7997
ARYTAB                         $002f   843D  2663   2663   4722   4724
                                      4797   4797   4811   4811   4942
                                      4943   5567   5569
VIC_REGS                       $002f   426D  8935
STREND                         $0031   847D  2106   2106   2378   2378
                                      2664   2664   4799   4799   4948
                                      4950   5064   5064   5081   5085
                                      5231   5234   5504   5507   5548
                                      5548   5585   5587
FRESPC                         $0033   851D  2173   2176   2200   2203
                                      2661   2661   3427   3432   5230
                                      5233   5498   5499   5511   5511
                                      5543   5544   5669   5672   5721
                                      5721   5845   5847   5851   5852
                                      5854   8375   8375
UTLSTP                         $0035   856D  5512   5512   5796y  5803
                                      5804   5806
MEMSIZ                         $0037   860D  2660   2660   5539   5540
                                      7833   7834   8374   8374   8393
                                      8397
CURLIN                         $0039   866D  2255   2287   2866   2866
                                      2919   2922   3019   3023   3023
                                      3059   3059   3086   3086   3103
                                      3105   3158   3158   3679   3679
                                      3995   3997   5265   7305   7306
OLDLIN                         $003b   871D  3024   3024   3058   3058
SEMIC                          $003b   685D  3516   3751
OLDTXT                         $003d   878D  2687   2904   2904   3022
                                      3022   3051   3056   3692   3692
DATLIN                         $003f   886D  3676   3676   3909   3913
DATPTR                         $0041   892D  2993   2993   3796   3796
INPPTR                         $0043   898D  3807   3807   3814   3814
                                      3890   3890   3924   3925   3932
VARNAM                         $0045   900D  4394   4394   4652   4695
                                      4696   4705   4728   4731   4779
                                      4779   4813   4816   4916   4916
                                      4918   4918   4957   4959   5007
                                      5014   5148   5153
VARPNT                         $0047   906D  4839   4839   5164   5167
                                      5169   5293   5293   5321   5326
                                      5330y  5334   5342   5342   7465
                                      7479
FORPNT                         $0049   911D  2077   2080   2082   2087
                                      2761   2766   2819   2891   2891
                                      3138   3330   3330   3353y  3356y
                                      3369   3463y  3466y  3469y  3811
                                      3811   3960   3960   3984   3985
                                      6149   6156   6161   6162   6869
                                      6869   8027   8052   8058   8101
                                      8110   8112   8123   8124
YSAVE                          $004b   917D  3813   3813   3891   3891
                                      4125   4212
ACCSYM                         $004d   919D  4075   4089   4090   4092
                                      4097   4142   4159   4568
FUNCPT                         $004e   925D  5307   5307   5315   5315
                                      5318   5318   5320y  5324y  5337y
                                      5340y  5344   5344   5355y  5358y
                                      5361y  5364y  5367y  5546   5547
                                      5686   5686   5707   5708   5715y
                                      5727y  5732y  7599   7600   7605
                                      7605   7616   7616   8195   8196
                                      8204   8204
DESCPT                         $0050   929D  3453   3453   3459   3459
                                      3462y  3465y  3468y  5389   5389
                                      5756   5756   5900y  5905y  5918
                                      5918   5940y  5964y  5985   5985
COLMAX                         $0050   646D  9180   9437
GARBSS                         $0053   931D  5562   5579   5687   5691
                                      8359
JUMPER                         $0054   936D  4514   8343
FUNJMP                         $0055   938D  4511   4513   5688   5710
                                      5714   5724   5980   5986
FAC2M5                         $0056   943D  6212   6232   6259   6315
                                      7676   7703
FACTPA                         $0057   948D  2186   6861   6862   7721
                                      7724   7724   8198   8198
TMPPTA                         $0058   949D  2132   2134   2136   2141y
                                      2147y  2151   2359   2365   4807
                                      4807   4809   4809   4855   4855
                                      5052   5054   5057   5072y  5076
                                      5079   5163   5166   5577   5577
                                      5582   5582   5601   5602   5605
                                      5606   5625   5627   5722   5722
                                      5726   5729   5730
TMPPTB                         $005a   950D  2113   2117   2123   2126
                                      2128   2140y  2146y  2150   2357
                                      2361   4800   4800   5717   5720
FACTPB                         $005c   955D  6854   7761   7761
TMPVA1                         $005d   956D  4410   5190   5215   7153
                                      7216   7244   7358   7374   7379
                                      7388   7404   7471
TMPVA2                         $005e   957D  4406   7203   7212   7217
                                      7223   7229   7271   7283   7292
                                      7403   7502   7507
TMPPTC                         $005f   958D  2114   2118   2307y  2311
                                      2313   2315y  2323   2326   2384y
                                      2582   2582   2583y  2588y  2597y
                                      2603y  2606y  2741y  2748y  2751y
                                      2780y  2783y  2786y  2787   2788
                                      3122   3125   4718   4721   4729y
                                      4733y  4739   4798   4798   4814y
                                      4817y  4820y  4822y  4824y  4826y
                                      4828y  4831   4834   4849   4850
                                      4946   4947   4955y  4960y  4965y
                                      4967   4970y  4971   4997y  5008y
                                      5015y  5026y  5042y  5045y  5082
                                      5084y  5087   5088y  5099y  5112y
                                      5117y  5179y  5182y  5549   5549
                                      5676   5679   5683   5684   5716
                                      5718   7190   7199   7207   7208
                                      7242   7275
FAC1EX                         $0061   962D  2194   3229   3376   3456
                                      3456   4192   4228   4570   4580
                                      4584   4890   5398   5434   5470
                                      6112   6190   6223   6226   6233
                                      6251   6308   6342   6346   6355
                                      6503   6507   6623   6638   6647
                                      6690   6728   6729   6731   6846
                                      6892   6912   6931   6944   6961
                                      7010   7045   7080   7093   7117
                                      7127   7265   7342   7627   7678
                                      7698   7699   7813   7816   8237
FAC1M1/FAC1M2                  $0062   963D  2873   2874   4191   4191
                                      4457   4571   4605y  5242   5396
                                      5414   5414   5472   5890y  6272
                                      6287   6290   6326   6328   6337
                                      6357   6378   6380   6406   6550
                                      6738   6784   6816   6843   6889
                                      6986   6995   7049   7106   7107
                                      7108   7136   7312   7442   7444
                                      7780   7802   7804    964D  3402
                                      4454   4572   5243   5397   5474
                                      6269   6289   6292   6323   6325
                                      6336   6358   6381   6383   6404
                                      6548   6741   6781   6818   6838
                                      6884   6988   7053   7137   7313
                                      7439   7441   7786   7805   7807
FAC1M3/FAC1M4                  $0064   965D  3352   3401   3426y  3431y
                                      3440   3445   3451y  4190   4190
                                      4302   4375   4381   4393   4393
                                      4425y  4428y  4453   4475   4475
                                      4494   4494   4531   4544   4865
                                      4926   5109   5136   5388   5388
                                      5477   5477   5741   5741   5748y
                                      5824   5824   6045   6116   6266
                                      6291   6294   6320   6322   6335
                                      6359   6384   6386   6402   6546
                                      6744   6778   6820   6835   6881
                                      7005   7057   7138   7436   7438
                                      7783   7806   7808    966D  3261
                                      3355   3403   3436   3446   4299
                                      4377   4383   4455   4534   4539
                                      4866   4928   5111   5142   5949
                                      5967   5969   6047   6117   6263
                                      6293   6296   6317   6319   6334
                                      6360   6387   6389   6400   6544
                                      6747   6775   6822   6832   6878
                                      7004   7063   7128   7139   7432
                                      7435   7789   7801   7803
FAC1SI                         $0066   967D  2871   3377   3983   4169
                                      4224   4588   4596   4881   6110
                                      6185   6187   6228   6311   6370
                                      6372   6615   6653   6660   6841
                                      6887   6907   6965   7012   7019
                                      7043   7069   7084   7104   7122
                                      7123   7263   7332   7338   7629
                                      7631   7812   8163   8167   8201
                                      8231
SGNFLG                         $0067   969D  7159   7233   7739   7762
FAC1OV                         $0068   970D  6436   7088   7097   7110
                                      8361
FAC2EX                         $0069   974D  4219   4560   4560   6213
                                      6214   6252   6254   6622   6630
                                      6911   6932   7594   7697   7700
FAC2M1                         $006a   975D  4220   4220   4558   4559
                                      6327   6582   6619   6737   6767
                                      6783   6785
FAC2M2                         $006b   976D  6324   6579   6611   6740
                                      6766   6780   6782
FAC2M3/FAC2M4                  $006c   977D  4221   4221   4573   4576
                                      4604y  6321   6576   6608   6743
                                      6765   6777   6779    978D  4574
                                      4577   6318   6573   6605   6746
                                      6764   6774   6776
FAC2SI                         $006e   979D  4223   4556   6188   6227
                                      6614   6617   6901   7262   7602
                                      8154
STRPTR/FAC1M5                  $006f   983D  3454   3454   4225   5413
                                      5413   5419y  5436   5438   5444
                                      5452   5452   5744   5744   5746y
                                      5759   5759   5769y  5772y  5775y
                                      6189   6249   6616   6652   6688
                                      6710   7264   7710   8159    988D
                                      4398   5478   6211   6238   6244
                                      6260   6295   6297   6316   6333
                                      6361   6390   6392   6393   6429
                                      6448   6542   6590   6800   6847
                                      6894   6915   6935   6946   7011
                                      7061   7121   7656   7704   7814
TMPPTD                         $0071   990D  2493   2514   3380   3383
                                      3384   3394   4408   5005   5021
                                      5047   5048   5066   5067   5077
                                      5102   5105   5130   5131   5143
                                      5146   5202   5203   5437   5443
                                      6060   6060   6088   6088   7339
                                      7410   7421   7466   7478   7490
                                      7719   7719   7731   7731   7738y
                                      7740   7744   7747   7748   7752
                                      7752   7759   7759
CHRGET                         $0073   994D  2280   2722   2885   2939
                                      2961   2976   3267   3322   3606
                                      3703   3839   4014   4093   4245
                                      4261   4350   4485   4667   4676
                                      4702   4873   6032   7167   7177
                                      7193   8355
CHRGOT                         $0079   995D  2718   2882   3092   3222
                                      3240   3499   3816   3882   3893
                                      3917   4011   4078   4631   4640
                                      4653   4931   5345   5950   6048
                                      6078   6151   8072   8089
TXTPTR                         $007a   996D  2279   2279   2461   2497
                                      2552   2566   2568   2700   2703
                                      2861   2863   2900   2900   2908y
                                      2911y  2918y  2921y  2924   2925
                                      2927   3018   3018   3057   3057
                                      3085   3085   3110   3111   3124
                                      3127   3159   3159   3175   3176
                                      3178   3208y  3693   3693   3812
                                      3812   3815   3815   3836   3836
                                      3845   3864   3864   3889   3889
                                      3892   3892   3905y  3908y  3911y
                                      3999   4001   4058   4060   4063
                                      4135   4137   4140   4279   4279
                                      4348y  5294   5294   5336   5336
                                      5338   5341   5350   5350   6059
                                      6059   6062   6067   6089   6089
                                      7287y  7973   7992   8318   8320
CTRL_COL                       $007f   629D  9722
STND_COL                       $007f   632D  9743  10266
ISNUM                          $0080   997D  3411
TK_END                         $0080  1619
TK_FOR                         $0081  1620D  2075   2892
TK_NEXT                        $0082  1621
TK_DATA                        $0083  1622D  2525   3919
TK_INFL                        $0084  1623
TK_INPUT                       $0085  1624
TK_DIM                         $0086  1625
TK_READ                        $0087  1626
TK_LET                         $0088  1628
TK_GOTO                        $0089  1629D  3223   3257
TK_RUN                         $008a  1630
RNDX                           $008b   999D  7793   7793   7818   7819
TK_IF                          $008b  1631
TK_RESTORE                     $008c  1632
TK_GOSUB                       $008d  1633D  3087   3141   3253
TK_RETURN                      $008e  1634
TK_REM                         $008f  1635D  2533
STATUS                         $0090  1001D 11239  12106  12339  12390
                                     12557  12765  12772  12950  12990
                                     13043  13044  13052  13088  13272
                                     15406  16840  16846  16847
TK_STOP                        $0090  1637
TK_ON                          $0091  1638
STKEY                          $0091  1014D  8570  13602  13631
SVXT                           $0092  1026D 15723  15724  15767  15778
TK_WAIT                        $0092  1639
TK_LOAD                        $0093  1640
VERCKK                         $0093  1027D 12948  13057  13364  15187
                                     15191  15407  15955  15992  16011
TK_SAVE                        $0094  1641
C3PO                           $0094  1028D 10754  10763  11061  11064
TK_VERIFY                      $0095  1642
BSOUR                          $0095  1030D 10768  10925  11003  11024
                                     11077
TK_DEF                         $0096  1643
SYNO                           $0096  1032D 15787  15805  15832  15836
                                     15847
TK_POKE                        $0097  1644
TEMPX                          $0097  1033D 11957  11959  12055  12067
                                     12078
TK_PRINFL                      $0098  1646
LDTND                          $0098  1040D 12535  12536  12538  12564
                                     12592  12628  12634
DFLTN                          $0099  1044D  8929   9091  11706  11937
                                     11969  12322  12604  12611
TK_PRINT                       $0099  1647D  2483
TK_CONT                        $009a  1648
DFLTO                          $009a  1048D  8927   9094  11600  12155
                                     12373  12599  12609
TK_LIST                        $009b  1649
PRTY                           $009b  1058D 15760  15792  15793  16085
                                     16220  16221  16289
DPSW                           $009c  1059D 15423  15681  15829  15875
TK_CLR                         $009c  1650
MSGFLG                         $009d  1060D 11914  13335  13549  13684
                                     15206  16837
TK_CMD                         $009d  1651
TK_SYS                         $009e  1652
PTR1                           $009e  1065D 11663  12243  12265  15235
                                     15247  15264  15267  15273  15323
                                     15332  15334  15421  15968  15970
                                     15977  15982  16040
TK_OPEN                        $009f  1653
PTR2                           $009f  1066D 15262  15271  15274  15321
                                     15329  15333  15422  15981  15990
                                     15991
TK_CLOSE                       $00a0  1655
JIFFYH                         $00a0  1073D 13564  13572  13575  13614
                                     13623
TK_GET                         $00a1  1656
JIFFYM                         $00a1  1074D  8573  13562  13570  13576
                                     13613  13622  15219
JIFFYL                         $00a2  1075D 13560  13568  13577  13612
                                     13621
TK_NEW                         $00a2  1657
TSFCNT                         $00a3  1076D 10757  10764  10809  15686
                                     15753  15796  15811  16081  16231
                                     16232
TK_TAB                         $00a3  1661D  2953   3509
TK_TO                          $00a4  1662D  2867   2977
TBTCNT                         $00a4  1077D 11219  11250  15725  15727
                                     15749  16083  16205  16207
TK_FN                          $00a5  1663D  4307   5302
CNTDN                          $00a5  1078D 10910  10943  11140  11181
                                     11197  11202  11234  16243  16254
                                     16328
TK_SPC                         $00a6  1664D  3511
BUFPNT                         $00a6  1079D 12066  12090  12240  12737
                                     15348  15349
INBIT                          $00a7  1080D 11488  11491  11501  11527
                                     11561  15880  15909  15952  16038
                                     16305  16315  17170
TK_THEN                        $00a7  1665D  3225
BITCI                          $00a8  1081D 11485  11498  11506  15709
                                     15834  15863  16084  16163  16173
                                     17204
TK_NOT                         $00a8  1667D  4289
RINONE                         $00a9  1082D  8554  11483  11515  15713
                                     15717  15783  15864  16086  16187
                                     16195
TK_STEP                        $00a9  1668D  2883
RIDATA                         $00aa  1083D 11492  11545  11587  15418
                                     15884  15897  15919  15922  15925
                                     15933  16025
TK_PLUS                        $00aa  1672D  4270   7183
TK_MINUS                       $00ab  1673D  2712   2720   4268   7179
RIPRTY                         $00ab  1084D  8556  11489  11490  11562
                                     15280  15444  15928  16049  16053
                                     16054  16058  16318  16323
TK_MUL                         $00ac  1674
SAL                            $00ac  1085D  9656   9658   9677   9767
                                      9769   9793   9795   9810   9858
                                      9865y  9878   9880  13419  13421
                                     13427y 15959y 15971  15973  15984
                                     15987  15996y 16015y 16052y 16071
                                     16073  16270  16279y 16409  16411
                                     16419  16421
TK_DIV                         $00ad  1675
TK_POWER                       $00ae  1676
EAL                            $00ae  1086D  9660   9662   9763   9765
                                      9797   9799   9867y  9879   9888
                                     12989  12999  13004  13006  13061y
                                     13079y 13083  13085  13308  13311
                                     13325  13326  13375  13376  15239
                                     15239  15256  15259  15283  15283
                                     15307  15311  16410  16412
TK_AND                         $00af  1677
CMPO                           $00b0  1087D 15420  15563  15564  15568
                                     15570  15571  15573  15578  15580
                                     15593  15656  15667  15668  15670
                                     15672  15673  15679  15690  15691
                                     15695  15696  15699  15700  15722
                                     15770  15774  15821  15824  15825
TK_OR                          $00b0  1679
TK_GT                          $00b1  1680D  4082
TK_EQUAL                       $00b2  1681D  3331   5290
TAPE1                          $00b2  1094D 12094y 12238y 12244y 12732y
                                     13283y 13286y 13296y 13298y 13301y
                                     13303y 15194y 15213y 15244y 15248y
                                     15251y 15254y 15257y 15260y 15272y
                                     15294  15294  15330y 16574  16575
TK_LT                          $00b3  1682
BITTS                          $00b4  1100D 11335  11347  11369  11372
                                     11376  11392  11419  15419  15707
                                     15732  15794  15807  15830  15844
                                     15851
TK_SGN                         $00b4  1686D  4312   4510   4512
NXTBIT                         $00b5  1106D 11353  11417  15848  15886
                                     15905  15937  16993
TK_INT                         $00b5  1687
RODATA                         $00b6  1111D 11338  11424  15865  15907
                                     15962  15965  15999  16002  16145
                                     16175  16330
TK_ABS                         $00b6  1688
TK_USR                         $00b7  1689
FNLEN                          $00b7  1126D 12704  12756  12783  12791
                                     12823  12965  13259  13339  13345
                                     13353  13404  15268  15326  16793
TK_FRE                         $00b8  1691
LA                             $00b8  1128D 12578  12618  12635  16802
SA                             $00b9  1129D 12316  12329  12368  12380
                                     12491  12514  12582  12637  12639
                                     12673  12727  12749  12769  12975
                                     12982  12986  13291  13403  13415
                                     13449  13453  13520  13531  16804
TK_POS                         $00b9  1692
FA                             $00ba  1130D 12306  12353  12407  12580
                                     12641  12767  12951  12984  13388
                                     13413  13451  16803  16811
TK_SQR                         $00ba  1693
FNADR                          $00bb  1138D 12788y 12825y 13350y 15270y
                                     15328y 16794  16795
TK_RND                         $00bb  1694
TK_LOG                         $00bc  1695
TK_EXP                         $00bd  1696
ROPRTY                         $00bd  1139D 11345  11346  11362  11380
                                     11416  15862  15911  15958  15994
                                     16014  16059  16100  16216  16218
                                     16230  16261  16272  16280  16291
TK_COS                         $00be  1697
FSBLK                          $00be  1147D 15486  15878  15888  16032
                                     16035  16042  16255  16299  16324
MYCH                           $00bf  1148D 15799  15861
TK_SIN                         $00bf  1698
TK_TAN                         $00c0  1700
CAS1                           $00c0  1149D 10039  10053  15503
STAL                           $00c1  1150D 13313  13315  13379  13381
                                     15238  15238  15250  15253  15284
                                     15284  15304  15309  16070  16072
                                     16580  16583  16586y 16589y 16590y
                                     16593y 16594y 16597y 16605
TK_ATN                         $00c1  1701
TK_PEEK                        $00c2  1702
TK_LEN                         $00c3  1703
MEMUSS                         $00c3  1151D 12941  12941  13003  13005
                                     13284  13287  13307  13310  13312
                                     13314  16489  16489  16500y 16504
TK_STRS                        $00c4  1704
TK_VAL                         $00c5  1705
LSTX                           $00c5  1152D 10211  10252
TK_ASC                         $00c6  1706
NDX                            $00c6  1173D  8955   8957   8973   8996
                                      9755  10246  10258  10263  11939
                                     13641
RVS                            $00c7  1183D  9140   9343   9495   9549
TK_CHRS                        $00c7  1707D  4486
INDX                           $00c8  1189D  9020   9041   9084  11990
TK_LEFTS                       $00c8  1709
ICRROW                         $00c9  1203D  8909   9025   9034   9528
                                      9668  11978
TK_RIGHTS                      $00c9  1710
ICRCOL                         $00ca  1204D  9039  11976
TK_MIDS                        $00ca  1711
SFDX                           $00cb  1231D 10117  10174  10208  10251
TK_GO                          $00cb  1712D  2974
BLNSW                          $00cc  1238D  8823   8974   9967
BLNCT                          $00cd  1245D  8822   9936   9969   9972
GDBLN                          $00ce  1254D  8980   9979   9984
BLNON                          $00cf  1261D  8809   8978   8983   9974
                                      9978
INSRC                          $00d0  1266D  9009   9053   9089   9270
                                     11988
LINPTR                         $00d1  1271D  9012y  9061y  9317y  9319y
                                      9330y  9430y  9447y  9449y  9458y
                                      9866y  9896   9900   9916y  9945y
                                      9954   9956   9976
CSRIDX                         $00d3  1277D  8778   8783   8860   8865
                                      8872   9023   9040   9060   9082
                                      9176   9178   9235   9246   9256
                                      9271   9312   9355   9364   9385
                                      9433   9455   9480   9484   9504
                                      9551   9563   9583   9944   9973
                                     11975
CSRMOD                         $00d4  1297D  9024   9074   9125   9127
                                      9161   9336   9425   9550
LINLEN                         $00d5  1303D  8900   9008   9177   9206
                                      9217   9255   9325   9357   9377
                                      9429   9442  11989
TBLX                           $00d6  1308D  8777   8782   8861   8864
                                      9027   9187   9191   9192   9232
                                      9244   9253   9359   9376   9380
                                      9477   9479   9529   9540   9572
                                      9593   9596   9667   9703   9759
                                      9776   9789  11977
LASTKY                         $00d7  1313D  9065   9067   9068   9105
                                      9110   9264   9272  15729  15779
                                     15798  16253  16271  16281  16282
INSRTO                         $00d8  1330D  9147   9149   9159   9297
                                      9461   9467   9548
COLRAM_PAGE                    $00d8   647D  9958
SLLTBL                         $00d9  1353D  8836   8847   8868   8892
                                      9198   9199   9202   9204   9223
                                      9538   9678   9687   9689   9694
                                      9698   9700   9701   9780   9811
                                      9822   9824   9829   9897
USER                           $00f3  1364D  8561y  9321y  9323y  9332y
                                      9451y  9453y  9460y  9868y  9947y
                                      9955   9959   9981
KBDPTR                         $00f5  1384D 10133  10135  10164y 10209y
                                     10327  10329
RXPTR                          $00f7  1390D 11556y 11778y 12428  12439
                                     12904  12907  12908
TXPTR                          $00f9  1395D 11423y 11665y 12433  12440
                                     12911  12914  12915
CTRL_ROW                       $00fb   630D  9725
TK_PI                          $00ff  1713D  2468   2812   4257
BASSTO                         $00ff  1397D  5381   5381   7337
STACK                          $0100  1399D  2074   2079   2081   2085
                                      2088   3982   3992   3994   3996
                                      3998   4000   4922   4924   4927
                                      4929   7413   7418   7470   7475
                                      7492   7512   7514   7524   7526
                                      7528   7532   7536   7539   7539
                                     15972  15974  15985  15988  17245
BUF                            $0200  1401D  2353   2376   2377   2383
                                      2441   2466   2505   2519   2520
                                      2540   2547   2561   2565   2901
                                      3532   3533   3534   3711   3712
                                      3714   3761   3774   3821   3822
                                      3823   7993   8365   8366
FILTBL                         $0259  1405D 12539  12540  12569  12577
                                     12636
DEVTBL                         $0263  1406D 12541  12542  12579  12642
SECATB                         $026d  1407D 12543  12544  12581  12640
KBUFFR                         $0277  1408D  8948   8952   8953   9000
                                     10261
OSSTAR                         $0281  1409D 16609  16886  16887  16892
                                     16892
OSTOP                          $0283  1410D 16867  16868  16874  16875
STIMOT                         $0285  1411D 16854
COLOR                          $0286  1412D  8560   8818   9152   9331
                                      9459   9615   9983
CSRCLR                         $0287  1413D  8981   9975   9982
SCNMPG                         $0288  1414D  8829   9857   9899  16611
KBMAXL                         $0289  1415D  8815  10259
KEYRPT                         $028a  1416D 10219
KRPTSP                         $028b  1419D  8820  10242  10245
KRPTDL                         $028c  1420D  8816  10214  10236  10238
SHFLAG                         $028d  1439D 10115  10169  10170  10253
                                     10274
LSTSHF                         $028e  1452D 10254  10277
KEYLOG                         $028f  1462D  8811   8813  10203
MODE                           $0291  1468D  8808  10279  10522  10536
                                     10539
AUTODN                         $0292  1481D  8975   9022   9182
M51CTR                         $0293  1483D 11370  11467  11503  12826
                                     12834
M51CDR                         $0294  1513D 11358  11400  11558  11601
                                     11707  12880
M51AJB                         $0295  1529D 12858  12859  12862  17191
                                     17193  17212
RSSTAT                         $0297  1531D 11437  11438  11582  11583
                                     11638  11769  11776  11785  12139
                                     12820  16814  16819
BITNUM                         $0298  1542D 11418  11546  12833  17203
BAUDOF                         $0299  1543D 11682  11684  17173  17176
                                     17217  17220
RIDBE                          $029b  1544D 11539  11543  11772  12899
RIDBS                          $029c  1545D 11541  11771  11779  12900
RODBS                          $029d  1546D 11420  11425  11658  12902
RODBE                          $029e  1547D 11421  11656  11660  12901
IRQTMP                         $029f  1548D 15481  15483  15520  15554
                                     16360  16363
ENABL                          $02a1  1551D 11449  11451  11513  11514
                                     11611  11669  11719  11743  11796
                                     11800  11817  12933  16987  16995
                                     17099  17180  17198  17199
TODSNS                         $02a2  1552D 15472  15599
TRDTMP                         $02a3  1553D 15664  15736
TD1IRQ                         $02a4  1554D 15601  15739  15751
SCROWM                         $02a5  1555D  9669   9704   9782   9787
                                      9806   9820   9834
TVSFLG                         $02a6  1556D 12847  16757  17264
IERROR                         $0300  1559D  2219   8286   8453
IMAIN                          $0302  1560D  2272
ICRNCH                         $0304  1561D  2455
IQPLOP                         $0306  1562D  2805
IGONE                          $0308  1563D  2933
IEVAL                          $030a  1564D  4235
SAREG                          $030c  1577D  7904   7918
SXREG                          $030d  1578D  7905   7919
SYREG                          $030e  1579D  7906   7920
SPREG                          $030f  1580D  7902   7922
Basic_USR                      $0310  1583D  1854   8344
USRVEC                         $0311  1584D  8346   8346
CINV                           $0314  1587D 15480  15482  15521  16362
                                     16364  16382  16384  16498  16507
                                     17250
CBINV                          $0316  1588D 17248
NMINV                          $0318  1589D 16924
IOPEN                          $031a  1591D 17902
ICLOSE                         $031c  1592D 17929
ICHKIN                         $031e  1593D 17968
ICKOUT                         $0320  1594D 18005
ICLRCH                         $0322  1595D 18033
IBASIN                         $0324  1596D 18085
IBSOUT                         $0326  1597D 18122
ISTOP                          $0328  1598D 18266
IGETIN                         $032a  1599D 18294
ICLALL                         $032c  1600D 18311
USRCMD                         $032e  1601
ILOAD                          $0330  1602D 12942
ISAVE                          $0332  1603D 13382
TBUFFR                         $033c  1605D 16572  16573
BASIC_SCREEN                   $0400   674D 16610
BASIC_RAM_START                $0800   675D 16608
OPTION_ROM                     $8000   676D 16435  16462  16951
BASIC_ROM                      $a000   677D  1796   1798   4376   4378
                                     16452
BASIC_BRK                      $a002  1804D 16978
BASIC_ID                       $a004  1805
Basic_Statement_Table          $a00c  1808D  2957   2959
Basic_Function_Table           $a052  1848D  4510   4512
Basic_Operator_Table           $a080  1876D  4115   4146   4154   4156
                                      4170
Basic_Keyword_Table            $a09e  1891D  2507   2557   2559   2828
                                      2834
ERR_01                         $a19e  1983D  2016
ERR_02                         $a1ac  1984D  2017
ERR_03                         $a1b5  1985D  2018
ERR_04                         $a1c2  1986D  2019
ERR_05                         $a1d0  1987D  2020
ERR_06                         $a1e2  1988D  2021
ERR_07                         $a1f0  1989D  2022
ERR_08                         $a1ff  1990D  2023
ERR_09                         $a210  1991D  2024
ERR_0A                         $a225  1992D  2025
ERR_0B                         $a235  1993D  2026
ERR_0C                         $a23b  1994D  2027
ERR_0D                         $a24f  1995D  2028
ERR_0E                         $a25a  1996D  2029
ERR_0F                         $a26a  1997D  2030
ERR_10                         $a272  1998D  2031
ERR_11                         $a27f  1999D  2032
ERR_12                         $a290  2000D  2033
ERR_13                         $a29d  2001D  2034
ERR_14                         $a2aa  2002D  2035
ERR_15                         $a2ba  2003D  2036
ERR_16                         $a2c8  2004D  2037
ERR_17                         $a2d5  2005D  2038
ERR_18                         $a2e4  2006D  2039
ERR_19                         $a2ed  2007D  2040
ERR_1A                         $a300  2008D  2041
ERR_1B                         $a30e  2009D  2042
ERR_1C                         $a31e  2010D  2043
ERR_1D                         $a324  2011D  2044
Basic_Msg_Tab                  $a328  2015D  2228   2230
Msg_OK                         $a364  2049D  7976   7976
Msg_Err                        $a369  2051D  2248   2248
Msg_IN                         $a371  2056D  7303   7303
Msg_Ready                      $a376  2057D  2264   2264   7998   7998
Msg_CrLf                       $a381  2058D  3032   3032
Msg_Break                      $a383  2059D  2045
Find_Active_FOR                $a38a  2064D  2846   3139   3961
FAF_Loop                       $a38f  2073D  2096
FAF_10                         $a3a4  2084D  2078
FAF_20                         $a3b0  2091D  2086
FAF_Ret                        $a3b7  2098D  2076   2089
Open_Up_Space                  $a3b8  2102D  2366   4808
Move_Block                     $a3bf  2109D  5723
MoBl_10                        $a3dc  2131D  2127
MoBl_Loop_Y                    $a3e8  2139D  2145
MoBl_Loop_X                    $a3ec  2143D  2135   2137   2153
MoBl_20                        $a3f3  2149D  2122
Check_Stack_Avail              $a3fb  2157D  2857   3084   4072
Check_Mem_Avail                $a408  2170D  2105   5003   5063   8391
CMA_10                         $a412  2179D  2175
CMA_Loop_X                     $a416  2184D  2188
CMA_Loop_2                     $a421  2192D  2196
CMA_Ret                        $a434  2206D  2174   2177   2201
Error_Out_Of_Memory            $a435  2210D  2162   2166   2202   2204
                                      5124
Basic_Error                    $a437  2216D  2446   3053   3151   3688
                                      3966   4052   4357   4988   5276
                                      5467   5751   6416   6809   7843
                                      7989
Default_Error                  $a43a  2222D  8290
DeEr_Loop                      $a456  2239D  2246
Display_Msg_Then_Ready         $a469  2251D  3034
Basic_Ready                    $a474  2261D  2257   8293
Vectored_Warmstart             $a480  2269D  2282   2354   2394
Default_Warmstart              $a483  2275D  8435
Direct_Call                    $a496  2290
New_Basic_Line                 $a49c  2295D  2288
NBL_10                         $a4d7  2333D  2329
NBL_Loop                       $a4df  2340D  2336   2344   2348
NBL_20                         $a4ed  2350D  2302
NBL_30                         $a508  2364D  2362
NBL_Copy                       $a522  2382D  2386
Reset_And_Rechain              $a52a  2389D  7999
Rechain                        $a533  2397D  2352   2393   8005
Rech_Loop                      $a53c  2404D  2426
Rech_Loop_2                    $a544  2410D  2413
Rech_Ret                       $a55f  2428D  2407
Read_String                    $a560  2432D  2278   3790
ReSt_Loop                      $a562  2437D  2444
ReSt_Finish                    $a576  2448D  2440
Tokenize_Line                  $a579  2452D  2291   2299
Default_Tokenize               $a57c  2458D  8439
Toke_Loop                      $a582  2465D  2471   2534
Toke_05                        $a58e  2473D  2467
Toke_10                        $a5a4  2486D  2482
Toke_15                        $a5ac  2492D  2488
Toke_20                        $a5b6  2500D  2508
Toke_25                        $a5b8  2504D  2560
Toke_30                        $a5c7  2513D  2562
Toke_35                        $a5c9  2516D  2469   2475   2480   2484
                                      2490   2541   2543
Toke_40                        $a5dc  2528D  2524
Toke_45                        $a5de  2531D  2526
Toke_REM                       $a5e3  2536
Toke_50                        $a5e5  2539D  2549
Toke_55                        $a5ee  2545D  2478
Toke_60                        $a5f5  2551D  2510
Toke_65                        $a5f9  2555D  2558
Toke_70                        $a609  2564D  2521
Find_BASIC_Line                $a613  2572D  2301   2717
Find_BASIC_Line_AX             $a617  2578D  2607   3120
FiBL_Check                     $a62e  2594D  2590
FiBL_Cont                      $a637  2601D  2592
FiBL_Not_Found                 $a640  2609D  2584
FiBL_Ret                       $a641  2611D  2589   2598   2599   2618
                                      2721   2724
Basic_NEW                      $a642  2615D  1845
Perform_NEW                    $a644  2621D  8401
Reset_BASIC_Execution          $a659  2638D  2351   2392   3073
Basic_CLR                      $a65e  2645D  1839
Clear_Variable_Space           $a660  2651D  3076
Reset_Variable_Pointer         $a663  2657D  7835
Restore_And_Flush_Stack        $a677  2667D  8006
Flush_BASIC_Stack              $a67a  2673D  2247   8282
Flush_Ret                      $a68d  2690D  2648   2713
Reset_BASIC_Exec_Pointer       $a68e  2694D  2641   8002
Basic_LIST                     $a69c  2707D  1838
LIST_05                        $a6a4  2715D  2710   2711
LIST_10                        $a6bb  2726D  2719
LIST_12                        $a6c3  2733
LIST_15                        $a6c9  2738D  2731   2789
LIST_17                        $a6d4  2745
LIST_20                        $a6e6  2757D  2753
LIST_25                        $a6e8  2760D  2755
LIST_30                        $a6ef  2765D  2835
LIST_35                        $a6f3  2769D  2811   2813   2815
LIST_40                        $a700  2777D  2772
LIST_45                        $a714  2791D  2742   2758   2779
Vectored_Detokenize            $a717  2802D  2781
Default_Detokenize             $a71a  2808D  8441
DeTo_10                        $a72c  2822D  2830
DeTo_20                        $a72f  2826D  2829
DeTo_30                        $a737  2832D  2824   2837
Basic_FOR                      $a742  2840D  1812
BaFO_10                        $a753  2853D  2847
BaFO_20                        $a78b  2879D  2875   2875
BaFO_30                        $a79f  2888D  2884
Interpreter_Loop               $a7ae  2896D  2941   3094   4004
InLo_10                        $a7be  2906D  2903
InLo_20                        $a7ce  2916D  2913
Start_Program                  $a7e1  2930D  2292   2926   2968
Default_Start                  $a7e4  2936D  8442
Interpret                      $a7ed  2944D  2940   3245
Interpret_10                   $a7ef  2949D  3264
Inte_10                        $a804  2963D  2952
Inte_20                        $a807  2966D  2909
Inte_30                        $a80b  2970D  2975
Inte_40                        $a80e  2973D  2954
Basic_RESTORE                  $a81d  2982D  1823   2670
Store_DATPTR                   $a827  2992D  2989   3928
BaRE_Ret                       $a82b  2995D  2947
Check_STOP                     $a82c  2999D  2743   2899
Basic_STOP                     $a82f  3005D  1827
Basic_END                      $a831  3011D  1811
BaEN_10                        $a832  3016D  3008
BaEN_20                        $a849  3026D  3021
End_Of_Exec                    $a84b  3030D  2914
BaEN_30                        $a854  3036D  3033
Basic_CONT                     $a857  3046D  1837
BaCO_10                        $a862  3055D  3052
BaCO_Ret                       $a870  3061D  3017   3049
Basic_RUN                      $a871  3065D  1821
BaRU_10                        $a87d  3075D  3072
Basic_GOSUB                    $a883  3080D  1824
Goto_Line                      $a897  3090D  3077
Basic_GOTO                     $a8a0  3097D  1820   2979   3093   3242
BaGO_10                        $a8bc  3116D  3107
BaGO_20                        $a8c0  3119D  3112   3114
BaGO_Ret                       $a8d1  3129D  3136
Basic_RETURN                   $a8d2  3133D  1825
Undefined_Statement            $a8e3  3147D  3121
BaRE_10                        $a8e8  3153D  3258
BaRE_20                        $a8eb  3156D  3142
Basic_DATA                     $a8f8  3162D  1814   3771   5295
Add_Y_To_Execution_Pointer     $a8fb  3168D  3237   3779   3916
Add_To_TXTPTR                  $a8fc  3173
AYTE_Ret                       $a905  3180D  3177   3209   3211
Next_Statement                 $a906  3184D  2858   3165   3778   3899
Next_Line                      $a909  3191D  3101   3236
NeLi_10                        $a911  3199D  3215
NeLi_15                        $a917  3204
NeLi_20                        $a919  3207D  3214
Basic_IF                       $a928  3218D  1822
BaIF_10                        $a937  3228D  3224
Basic_REM                      $a93b  3233D  1826
BaIF_20                        $a940  3239D  3230
BaIF_30                        $a948  3244D  3241
Basic_ON                       $a94b  3248D  1828
BaON_10                        $a953  3256D  3291
BaON_20                        $a957  3260D  3254   3270
BaON_30                        $a95f  3266D  3262
BaON_Ret                       $a96a  3273D  3285
Scan_Linenumber                $a96b  3277D  2298   2716   2723   3100
                                      3268
ScLi_Loop                      $a971  3284D  3323
ScLi_10                        $a99f  3321D  3318
Basic_LET                      $a9a5  3326D  1819   2845   2964
Assign_Numeric_variable        $a9c2  3345D  3879
LET_10                         $a9d6  3359D  3348
LET_20                         $a9d9  3362D  3341
Assign_String_Variable         $a9da  3366D  3872
LET_30                         $a9ed  3379D  3397
LET_40                         $aa07  3393D  3388
Eval_Digit                     $aa1d  3407D  3381   3385
Jump_Illegal_Quantity          $aa24  3414D  3374
EvDi_10                        $aa27  3417D  3412
Assign_String                  $aa2c  3422D  3371
AsSt_10                        $aa3d  3435D  3429
AsSt_20                        $aa4b  3444D  3428   3433   3438
AsSt_30                        $aa52  3449D  3439   3442
AsSt_40                        $aa68  3458D  3447
Basic_PRINTN                   $aa80  3473D  1835
Basic_CMD                      $aa86  3480D  1840   3476
BCMD_10                        $aa90  3488D  3484
BaPR_00                        $aa9a  3495D  3520
BaPR_05                        $aa9d  3498D  3525
Basic_PRINT                    $aaa0  3502D  1836   3493
BaPR_10                        $aaa2  3507D  3607
Terminate_BUF                  $aaca  3528D  2449
Print_CR                       $aad7  3539D  2235   2746   3505
Invert_A                       $aae5  3550D  3545   3636
Invert_Ret                     $aae7  3555D  3508   3536   3630
TAB_Jump                       $aae8  3559D  3515
TAB_10                         $aaee  3567D  3576
TAB_20                         $aaf8  3581D  3510   3513
TAB_30                         $ab0e  3595D  3579
TAB_40                         $ab0f  3598D  3590
TAB_50                         $ab10  3601D  3611
TAB_60                         $ab13  3605D  3517   3593
TAB_70                         $ab19  3609D  3603
Print_String                   $ab1e  3614D  2254   2264   3691   3937
                                      7320   7977   7998   8392   8400
Print_String_From_Descriptor   $ab21  3620D  3496   3523   3753
PSFD_Loop                      $ab28  3628D  3635   3637
Cursor_Right_Or_Space          $ab3b  3640D  3524   3610   3788
CROS_10                        $ab42  3647D  3644
Print_Question_Mark            $ab45  3652D  2236   3787   3830
Print_Char                     $ab47  3658D  2243   2770   2836   3543
                                      3547   3632
Bad_Input                      $ab4d  3666D  3886
BaIn_10                        $ab57  3675D  3671
BaIn_20                        $ab5b  3678D  3673
BaIn_30                        $ab5f  3681D  3588
BaIn_40                        $ab62  3684D  3670
BaIn_50                        $ab6b  3690D  3686
Basic_GET                      $ab7b  3697D  1844
BaGE_10                        $ab92  3710D  3702
Basic_INPUTN                   $aba5  3722D  1815
Set_Default_Channels           $abb5  3733D  3477   3770
BaIN_10                        $abb7  3738D  3718
Basic_INPUT                    $abbf  3745D  1816
Input_String                   $abce  3756D  3730   3749
BaIN_20                        $abd6  3763D  3777
BaIN_30                        $abea  3773D  3766   3769
Prompt_And_Input               $abf9  3782D  3764   3833
BaIN_40                        $ac03  3789D  3786
Basic_READ                     $ac06  3793D  1818
BaIN_50                        $ac0d  3799D  3775
Read_Get                       $ac0f  3803D  3716
READ_Loop_Var                  $ac15  3809D  3896
READ_05                        $ac41  3826D  3819
READ_10                        $ac4a  3832D  3829
READ_15                        $ac4d  3835D  3824
READ_20                        $ac51  3838D  3817   3921
READ_25                        $ac65  3851D  3843
READ_30                        $ac71  3859D  3848
READ_35                        $ac72  3862D  3854
READ_40                        $ac7d  3869D  3866
READ_45                        $ac89  3876D  3841
READ_50                        $ac91  3881D  3873
READ_55                        $ac9d  3888D  3883   3885
READ_60                        $acb8  3898D  3827   3920
READ_65                        $acd1  3915D  3902
READ_70                        $acdf  3923D  3894
READ_75                        $acea  3930D  3927
READ_Ret                       $acfb  3939D  3933   3935
Msg_Extra_Ignored              $acfc  3942D  3936   3936
Msg_Redo_From_Start            $ad0c  3943D  3691   3691
Basic_NEXT                     $ad1e  3946D  1813
Find_NEXT_Variable             $ad24  3954D  3949   4015
NEXT_10                        $ad27  3959D  3951
NEXT_20                        $ad32  3965D  3906
NEXT_30                        $ad35  3970D  3962
NEXT_40                        $ad75  4003D  4013
NEXT_50                        $ad78  4006D  3993
Eval_Numeric                   $ad8a  4018D  2870   2886   5343   6038
                                      6096   7896
Is_Numeric                     $ad8d  4024D  2869   4117   4209   4515
                                      4880   5288   5308   5317   5374
Assert_String_Type             $ad8f  4031D  4491   5743   5815
Check_Var_Type                 $ad90  4037D  3340   4554
CVT_10                         $ad96  4044D  4048
CVT_20                         $ad97  4047D  4041
Type_Missmatch                 $ad99  4050D  4042
Eval_Expression                $ad9e  4055D  3221   3337   3518   4021
                                      4321   4489   4874   8133
EvEx_05                        $ada4  4062D  4059
EvEx_10                        $ada9  4067D  4160
EvEx_15                        $adb8  4077D  5762
EvEx_20                        $adbb  4080D  4094
EvEx_25                        $add7  4096D  4083   4085
EvEx_30                        $ade8  4106D  4103
EvEx_35                        $adf0  4113D  4143
EvEx_40                        $adf9  4119D  4148
EvEx_45                        $adfa  4122D  4368
EvEx_50                        $ae07  4131D  4098
EvEx_55                        $ae11  4139D  4136
EvEx_60                        $ae19  4145D  4126
Call_Operator_Function         $ae20  4151D  4123
Jump_Syntax_Error              $ae30  4162D  4091
Apply_Operator                 $ae33  4166D  4158
Push_FAC1                      $ae38  4173D  2890
Round_And_Push_FAC1            $ae43  4186D  2877
Right_Operand                  $ae58  4197D  4099   4101
RiOp_10                        $ae5b  4203D  4128
RiOp_20                        $ae5d  4206D  4116
RiOp_30                        $ae64  4211D  4208
RiOp_40                        $ae66  4214D  4129   4147
RiOp_50                        $ae80  4227D  4204
Evaluate                       $ae83  4232D  4073   5742
Default_EVAL                   $ae86  4238D  8443
EVA_10                         $ae8a  4244D  4271
EVA_20                         $ae8f  4248D  4267
EVA_30                         $ae92  4251D  4246
EVA_40                         $ae9a  4256D  4253
Float_PI                       $aea8  4263D  4259   4259
EVA_50                         $aead  4265D  4258
Make_String_Descriptor_From_Co $aebd  4276D  3750
EVA_60                         $aec6  4284D  4281
EVA_70                         $aecc  4288D  4273
Basic_EQUAL                    $aed4  4295D  1887
EVA_80                         $aee3  4306D  4290
EVA_90                         $aeea  4311D  4308
Eval_In_Parenthesis            $aef1  4317D  4313   4505   5316
Need_Right_Parenthesis         $aef7  4324D  4935   5289   5976
Need_Left_Parenthesis          $aefa  4331D  4320   4488   5284
Need_Comma                     $aefd  4338D  3895   4490   4623   5953
                                      6103   8083
Need_A                         $aeff  4344D  2868   2978   3226   3332
                                      3486   3706   3727   3752   5291
                                      5303
Syntax_Error                   $af08  4353D  2971   3154   3682   4163
                                      4349   4658   4788   5347   8091
Prep_Minus_Operation           $af0d  4360D  4269
Prep_Operation                 $af0f  4365D  4292
Is_Inside_BASIC_ROM            $af14  4371D  4399   4437
IIBR_Ret                       $af27  4385D  4379
Get_Var                        $af28  4389D  4254   4764
GeVa_Ret                       $af5c  4415D  4400   4402   4404
Load_Value                     $af5d  4419D  4396
Load_Float                     $af6e  4434D  4423
Load_Jiffyclock                $af84  4449D  4405   4443
Check_ST_Var                   $af92  4461D  4440
Load_Float_Var                 $afa0  4472D  4438   4442   4465   4467
Function_Call                  $afa7  4479D  4314
FuCa_10                        $afd1  4504D  4487
FuCa_20                        $afd6  4509D  4502
Basic_OR                       $afe6  4518D  1885
Basic_AND                      $afe9  4525D  1884
Basic_LESS                     $b016  4551D  1888
BaLE_10                        $b02e  4565D  4555
BaLE_20                        $b056  4587D  4581   4583
BaLE_30                        $b05b  4592D  4606
BaLE_40                        $b061  4598D  4563
BaLE_50                        $b066  4603D  4595
BaLE_60                        $b072  4611D  4599   4601   4608
BaLE_70                        $b07b  4619D  4616
DIM_00                         $b07e  4622D  4632
Basic_DIM                      $b081  4626D  1817
Get_Scalar_Address             $b08b  4636D  3329   3810   3957   4392
                                      5287
Get_Array_Address              $b090  4643D  4630
Get_FN_Address                 $b092  4649D  5306
Var_Syntax_Error               $b09c  4657D  4692
Get_Address                    $b09f  4661D  4655
GAdd_05                        $b0af  4672D  4668
GAdd_10                        $b0b0  4675D  4677   4679
GAdd_15                        $b0ba  4681D  4670
GAdd_20                        $b0c4  4688D  4683
GAdd_25                        $b0d4  4698D  4686
GAdd_30                        $b0db  4704D  4690
GAdd_35                        $b0e7  4712D  4709
GAdd_40                        $b0ef  4717D  4743
GAdd_45                        $b0f1  4720D  4741
GAdd_50                        $b0fb  4727D  4723
GAdd_55                        $b109  4737D  4730
Is_Alpha                       $b113  4746D  4252   4654   4669   4678
IA_RET                         $b11c  4755D  4750
Create_Var                     $b11d  4759D  4725
CrVa_10                        $b123  4774D  4783
CrVa_20                        $b128  4778D  4765
CrVa_30                        $b138  4787D  4794
CrVa_40                        $b13b  4790D  4781   4785
CrVa_50                        $b143  4796D  4792
CrVa_60                        $b159  4806D  4803
CrVa_70                        $b185  4830D  4734
CrVa_80                        $b18f  4838D  4835
Array_Pointer_To_First         $b194  4843D  4994   5002
APTF_10                        $b1a0  4854D  4851
Float_M32768                   $b1a5  4858D  4893   4893
Float_To_Integer               $b1aa  4861D  8349   8349
Eval_Positive_Integer          $b1b2  4870D  4917
Eval_Positive_Integer_Check    $b1b8  4877D  6044
Eval_Integer                   $b1bf  4887D  3350   4298   4530   4538
                                      4864
EvIn_10                        $b1cc  4896D  4882
EvIn_20                        $b1ce  4899D  4892
Find_Array                     $b1d1  4903D  4710
FiAr_05                        $b1db  4913D  4933
FiAr_10                        $b21c  4945D  4972
FiAr_15                        $b228  4953D  4949
FiAr_20                        $b237  4963D  4958
Bad_Subscript                  $b245  4975D  4998   5121
Illegal_Quantity               $b248  4982D  3415   4897   6026   6500
                                      8345   8345
Jump_Basic_Error               $b24a  4987D  4993
FiAr_25                        $b24d  4990D  4961
FiAr_30                        $b261  5001D  4951
FiAr_35                        $b274  5012D  5009
FiAr_40                        $b27d  5020D  5016
FiAr_45                        $b286  5028D  5051
FiAr_50                        $b296  5040D  5032
FiAr_55                        $b2b9  5062D  5058
FiAr_60                        $b2c8  5070D  5073   5078
FiAr_65                        $b2cd  5075D  5068
Find_Array_Element             $b2ea  5096D  4999
FiAE_10                        $b2f2  5104D  5145
FiAE_20                        $b308  5120D  5114
FiAE_30                        $b30b  5123D  5053   5060   5201   5212
FiAE_40                        $b30e  5126D  5113
FiAE_50                        $b30f  5129D  5118
FiAE_60                        $b320  5141D  5133
FiAE_70                        $b331  5152D  5149
FiAE_80                        $b337  5158D  5154
FiAE_Ret                       $b34b  5171D  5090   5267
Compute_Array_Size             $b34c  5175D  5046   5134
Compute_Array_Size_A           $b355  5185D  5161
CAS_10                         $b35f  5194D  5216
CAS_20                         $b378  5214D  5204
Basic_FRE                      $b37d  5220D  1855
FRE_10                         $b384  5227D  5224
Integer_To_Float               $b391  5237D  4304   4431   4548   5259
                                      8347   8347
Basic_POS                      $b39e  5248D  1856
Y_To_Float                     $b3a2  5255D  5999   6020   6132
Assert_Non_Direct              $b3a6  5262D  3700   3759   5283
Undefined_Function             $b3ae  5272D  5325
Basic_DEF                      $b3b3  5279D  1833
Get_FN                         $b3e1  5299D  5282   5314
Eval_FNX                       $b3f4  5311D  4309
EvFN_10                        $b418  5329D  5333
EvFN_20                        $b449  5349D  5346
EvFN_30                        $b44f  5352D  5296
Basic_STR                      $b465  5371D  1867
BaST_10                        $b46f  5380D  4413
Allocate_String_FAC1           $b475  5385D  3452   5451   5754
Allocate_String_A              $b47d  5392D  5887   5917
Create_String_Descriptor       $b487  5402D  3522   3617   4285   5382
Create_String_Descriptor_AY    $b48d  5410D  3870
CSD_10                         $b497  5417D  5424
CSD_20                         $b4a4  5426D  5422
CSD_30                         $b4a8  5430D  5420
CSD_40                         $b4a9  5433D  5428
CSD_50                         $b4b5  5442D  5439
CSD_60                         $b4bf  5449D  5445
Store_And_Push_String          $b4c7  5454
Push_String_Descriptor         $b4ca  5458D  5447   5761   5893   5932
PSD_10                         $b4d2  5466D  5520
PSD_20                         $b4d5  5469D  5463
Allocate_String_Space          $b4f4  5489D  5395
ASS_10                         $b4f6  5494D  5525
ASS_20                         $b501  5503D  5500
ASS_30                         $b50b  5510D  5506
ASS_40                         $b516  5517D  5505   5508
Garbage_Collection             $b526  5528D  2189   5228   5521
GaCo_Iter                      $b52a  5542D  5733
GaCo_Loop_1                    $b544  5554D  5558
GaCo_10                        $b54d  5560D  5556
GaCo_20                        $b559  5566D  5574
GaCo_30                        $b561  5572D  5568
GaCo_40                        $b566  5576D  5570
GaCo_50                        $b56e  5581D  5608   5610
GaCo_60                        $b572  5584D  5628
GaCo_70                        $b57d  5591D  5586   5588
GaCo_80                        $b5ae  5621D  5618
GaCo_90                        $b5b0  5624D  5632
GaCo_95                        $b5b8  5630D  5626
Check_Variable                 $b5bd  5635D  5573
Check_String                   $b5c7  5646D  5557   5631
ChSt_10                        $b5dc  5675D  5670
ChSt_20                        $b5e6  5682D  5678
ChSt_30                        $b5f6  5690D  5639   5642   5663   5671
                                      5673   5677   5680
ChSt_40                        $b601  5698D  5695   5709
Collect_String                 $b606  5704D  5589
Concatenate                    $b63d  5736D  4104
Conc_10                        $b65d  5753D  5749
Store_String_STRPTR            $b67a  5765D  3455   5755
Store_String_XY                $b688  5780D  5455
Store_String_INDEXA            $b68c  5786D  5758   5931
SSIN_10                        $b690  5793D  5798
SSIN_20                        $b699  5801D  5790
SSIN_30                        $b6a2  5808D  5805
Eval_String                    $b6a3  5812D  6005   8136
Get_String_Descriptor          $b6a6  5818D  3372   3623   4569   5225
Get_String_Descriptor_AY       $b6aa  5827D  4575   5757   5760   5919
GSD_10                         $b6d5  5856D  5853
GSD_20                         $b6d6  5859D  5844   5846   5848
Pop_Descriptor_Stack           $b6db  5864D  3460   5831
PDS_Ret                        $b6eb  5876D  5868   5870
Basic_CHR                      $b6ec  5880D  1870
Basic_LEFT                     $b700  5896D  1871
LEFT_10                        $b706  5903D  5942
LEFT_20                        $b70c  5909D  5904
LEFT_30                        $b70d  5912D  5965
LEFT_40                        $b70e  5915D  5968   5970
LEFT_50                        $b725  5929D  5926
Basic_RIGHT                    $b72c  5935D  1872
Basic_MID                      $b737  5945D  1873
MID_10                         $b748  5956D  5952
Pop_String_Descriptor_And_Byte $b761  5973D  5899   5938   5957
Basic_LEN                      $b77c  5995D  1866
Eval_String_And_Len            $b782  6002D  5998   6015   6054
Basic_ASC                      $b78b  6012D  1869
Jump_To_Illegal_Quantity       $b798  6023D  5958   6016   6046   6111
                                      6114
Get_Next_Byte_Value            $b79b  6029D  3586
Get_Byte_Value                 $b79e  6035D  3251   3483   3704   3725
                                      4497   5954   6104   8066   8100
Eval_Byte                      $b7a1  6041D  5883
Basic_VAL                      $b7ad  6051D  1868
VAL_10                         $b7b5  6058D  6055
VAL_20                         $b7cd  6071D  6068
Restore_Execution_Pointer      $b7e2  6085D  3871   4286
Get_Word_And_Byte              $b7eb  6093D  6138   6148
Need_Comma_Get_Byte            $b7f1  6100D  6153
FAC1_To_LINNUM                 $b7f7  6107D  6097   6127   7897
Basic_PEEK                     $b80d  6123D  1865
Basic_POKE                     $b824  6135D  1834
Basic_WAIT                     $b82d  6145D  1829
WAIT_10                        $b83c  6155D  6152
WAIT_20                        $b840  6159D  6163
WAIT_Ret                       $b848  6165D  6221
Add_0_5_To_FAC1                $b849  6169D  7383   8166
AY_Minus_FAC1                  $b850  6176D  6513   8162   8251
Basic_MINUS                    $b853  6182D  1880   7705   8160
PLUS_00                        $b862  6193D  6242
Add_Var_AY_To_FAC1             $b867  6198D  3986   6173   6509   6517
                                      7760   7798   8146   8178
Basic_PLUS                     $b86a  6204D  1879   6191   7266
PLUS_05                        $b86f  6210D  6207
Add_FAC2_To_FAC1               $b877  6217D  6689
PLUS_10                        $b893  6236D  6225
PLUS_15                        $b897  6240D  6234
PLUS_20                        $b8a3  6248D  6195   6224
PLUS_25                        $b8af  6256D  6253
PLUS_30                        $b8d2  6274D  7013   7130
Normalise_FAC1                 $b8d7  6279D  6275   6823   7817
PLUS_35                        $b8db  6286D  6300
Clear_FAC1_Exp_And_Sign        $b8f7  6303D  6056   6343   6667
PLUS_40                        $b8f9  6307D  7596
PLUS_45                        $b8fb  6310D  6649
PLUS_50                        $b8fe  6314D  6250
PLUS_55                        $b91d  6331D  6340
PLUS_60                        $b929  6339D  6288
Test_And_Normalize_FAC1        $b936  6349D  6329
TANF_10                        $b938  6354D  6955
TANF_Ret                       $b946  6363D  6352
Negate_FAC1                    $b947  6367D  6276
Negate_FAC1_Mantissa           $b94d  6375D  7089
Inc_FAC1_Mantissa              $b96f  6397D  6953
IFM_Ret                        $b97d  6408D  6394   6401   6403   6405
Overflow_Error                 $b97e  6412D  6356   6670   7277
Shift_FAC3                     $b983  6419D  6559
Shift_FACX                     $b985  6425D  6444   6445
Shift_FACX_A                   $b999  6440D  6194   7096
ShFA_10                        $b9a6  6451D  6469
ShFA_20                        $b9ac  6456D  6453
Shift_FACX_Right_Y             $b9b0  6461D  6246   7109
ShFA_30                        $b9ba  6471D  6449
REAL_1                         $b9bc  6477D  2880   2880   6512   6512
                                      8241   8241
VLOG_A                         $b9c1  6479D  6514   6514
HALF_SQRT_2                    $b9d6  6486D  6508   6508
SQRT_2                         $b9db  6487D  6510   6510
MINUS_0_5                      $b9e0  6488D  6516   6516
LN_2                           $b9e5  6489D  6520   6520
Basic_LOG                      $b9ea  6492D  1859   7615
LOG_10                         $b9f1  6499D  6496
LOG_20                         $b9f4  6502D  6497
Multiply_FAC1_With_AY          $ba28  6523D  7354   7617   7655   7722
                                      7725   7751   7796
Basic_MULTIPLY                 $ba2b  6529D  1881
MULT_10                        $ba30  6535D  6532
Mult_SubA                      $ba59  6555D  6543   6545   6547   6549
Mult_SubB                      $ba5e  6562D  6551   6558
MULT_20                        $ba61  6568D  6593
MULT_30                        $ba7d  6585D  6570
Mult_Sub_Ret                   $ba8b  6595D  6533
Load_FAC2_From_AY              $ba8c  6599D  6179   6201   6526   6718
Check_FACs                     $bab7  6627D  6536   6730
Check_FACs_A                   $bab9  6633D  7712
ChFA_10                        $bac4  6644D  6639
ChFA_20                        $bacf  6651D  6648
Check_Overflow                 $bad4  6657D  7683
ChFA_30                        $bada  6664D  6636   6645
ChFA_40                        $badf  6669D  6640   6662   6681   6691
                                      6732
Multiply_FAC1_BY_10            $bae2  6673D  3382   3399   7228   7247
                                      7373
Multiply_FAC1_By_4             $baed  6684D  3391
Mu10_Ret                       $baf8  6693D  6678
Float_10                       $baf9  6696D  6703   6703
Divide_FAC1_By_10              $bafe  6699D  7222   7378
Divide_FAC2_By_AY              $bb07  6707D  8155
AY_Divided_By_FAC1             $bb0f  6715D  6511   8205   8242
Basic_DIVIDE                   $bb12  6721D  1882   6712
DIVI_10                        $bb29  6736D  6769
DIVI_20                        $bb3f  6749D  6739   6742   6745   6768
                                      6770
DIVI_30                        $bb4c  6759D  6752   6791
DIVI_40                        $bb4f  6763D  6787
DIVI_50                        $bb5d  6772D  6761
DIVI_60                        $bb7a  6789D  6755
DIVI_70                        $bb7e  6793D  6756
Divide_By_Zero                 $bb8a  6805D  6724
FAC3_To_FAC1                   $bb8f  6812D  6552   6802
Load_FAC1_AY                   $bba2  6826D  2881   3980   4260   4476
                                      6711   7587   7794   8199
FAC1_To_FACTPB                 $bbc7  6851D  7737
FAC1_To_FACTPA                 $bbca  6858D  7720   8191
Assign_FAC1_To_FOR_Index       $bbd0  6866D  3360   3987
Assign_FAC1_To_Var             $bbd4  6872D  5335   6863   7601   7825
FAC2_To_FAC1                   $bbfc  6898D  4537   6208
Copy_ABS_FAC2_To_FAC1          $bbfe  6904D  7612
F2F1_Loop                      $bc02  6910D  6914
FAC1_Round_And_Copy_To_FAC2    $bc0c  6919D  3386   6676   6702   7259
                                      7585   8152   8156
FAC1_To_FAC2                   $bc0f  6925D  7677
F1F2_Loop                      $bc11  6930D  6934
F1F2_Ret                       $bc1a  6937D  6945   6947   6954
Round_FAC1_Checked             $bc1b  6941D  3349   4189   6725   6875
                                      6922
Round_FAC1                     $bc23  6950D  7659
Get_FAC1_Sign                  $bc2b  6958D  2889   6495   6980   7041
                                      7773
GFS_10                         $bc2f  6964D  7044
GFS_20                         $bc31  6967D  7074
GFS_Ret                        $bc38  6973D  6962   6970
Basic_SGN                      $bc39  6977D  1851
A_To_FAC1                      $bc3c  6983D  4469   4620   7261
Int_To_Float_Exp_X             $bc44  6992D  5245
Convert_Integer_To_Float       $bc49  7000D  7316
CITF_10                        $bc4f  7009D  4446
Basic_ABS                      $bc58  7016D  1853
Compare_FAC1_AY                $bc5b  7023D  4561   4894   7362   7368
                                      7606
Compare_FAC1_INDEXB_Y          $bc5d  7033D  3989
CPFA_10                        $bc92  7068D  7046   7050   7054   7058
CPFA_20                        $bc98  7073D  7070
FAC1_To_Integer                $bc9b  7077D  3400   4900   6115   7120
                                      7386
FATI_10                        $bcaf  7092D  7085
FATI_20                        $bcba  7099D  7064
FATI_30                        $bcbb  7102D  7095
Basic_INT                      $bccc  7114D  1852   7604   7686   8157
Clear_FAC1                     $bce9  7133D  7081
ClF1_Ret                       $bcf2  7142D  7119
Load_FAC1_From_String          $bcf3  7146D  3877   4249   6079
LFFS_05                        $bcf7  7152D  7155
LFFS_10                        $bd06  7162D  7158
LFFS_15                        $bd0a  7166D  7160   7209   7252
LFFS_20                        $bd0d  7169D  7156
LFFS_25                        $bd0f  7172D  7164
LFFS_30                        $bd2e  7189D  7180   7182
LFFS_35                        $bd30  7192D  7184   7186   7293
LFFS_37                        $bd33  7195D  7178
LFFS_38                        $bd35  7198D  7187
LFFS_40                        $bd41  7206D  7174
LFFS_45                        $bd47  7211D  7176   7200
LFFS_50                        $bd49  7214D  7204
LFFS_55                        $bd52  7221D  7224
LFFS_60                        $bd5b  7227D  7219   7230
LFFS_65                        $bd62  7232D  7218   7225
LFFS_70                        $bd67  7237D  7234
LFFS_75                        $bd6a  7240D  7170
LFFS_80                        $bd71  7246D  7243
Add_A_To_FAC1                  $bd7e  7255D  3419   6519   7251
LFFS_85                        $bd91  7270D  7196
LFFS_90                        $bda0  7279D  7273
LFFS_95                        $bdae  7291D  7276
MAXREAL_A                      $bdb3  7295D  7367   7367
MAXREAL_B                      $bdb8  7296D  7361   7361
MAXREAL_C                      $bdbd  7297D  7353   7353
Print_IN                       $bdc2  7300D  2258
Print_Integer_XA               $bdcd  7309D  2762   8399
To_Print_String                $bdda  7319D  7304
Format_FAC1                    $bddd  7323D  3521
Format_FAC1_Y                  $bddf  7328D  5376   7317
FoFA_02                        $bde7  7336D  7333
FoFA_04                        $bdf8  7346D  7343
FoFA_06                        $be00  7352D  7349
FoFA_08                        $be09  7357D  7350
FoFA_10                        $be0b  7360D  7380
FoFA_12                        $be16  7366D  7375
FoFA_14                        $be21  7372D  7369
FoFA_16                        $be28  7377D  7364
FoFA_18                        $be2f  7382D  7370
FoFA_20                        $be32  7385D  7363
FoFA_22                        $be47  7398D  7391
FoFA_24                        $be48  7401D  7393
FoFA_26                        $be53  7409D  7406
FoFA_28                        $be64  7420D  7415
FoFA_30                        $be66  7423D  7407
Format_Jiffyclock              $be68  7427D  4412
FoFA_32                        $be6a  7431D  7447   7451   7487
FoFA_34                        $be8e  7450D  7446
FoFA_36                        $be90  7453D  7448
FoFA_38                        $be97  7459D  7455
FoFA_40                        $beb2  7477D  7472
FoFA_42                        $bec4  7489D  7485
FoFA_44                        $bec6  7491D  7495
FoFA_46                        $bed3  7500D  7497
FoFA_48                        $bee3  7511D  7504
FoFA_50                        $beef  7519D  7522
FoFA_52                        $bf04  7531D  7344
FoFA_54                        $bf07  7534D  7503
FoFA_56                        $bf0c  7538D  7529
Float_0_5                      $bf11  7542D  6172   6172   7586   7586
NULL_Descriptor                $bf13  7543D  3370   4775   4775
Decimal_Conversion_Table       $bf16  7546D  4411   7434   7437   7440
                                      7443   7484   7486
Jiffy_Conversion_Table         $bf3a  7560D  4411   7484
End_Of_Conversion              $bf52  7570D  7486
Basic_SQR                      $bf71  7582D  1857
Basic_POWER                    $bf7b  7590D  1883
POW_10                         $bf84  7598D  7595
POW_20                         $bf9e  7611D  7603   7607
Basic_GREATER                  $bfb4  7624D  1886   7238   7706   8174
                                      8181   8234   8256
GREA_Ret                       $bfbe  7633D  7621   7628
REV_LOG_2                      $bfbf  7636D  7654   7654
VAR_EXP                        $bfc4  7638D  7707   7707
Basic_EXP                      $bfed  7651D  1860   7593   7618
EXP_10                         $bffd  7661D  7658
VIC_BASE                       $d000   420D  8939
VIC_CONTROL_1                  $d011   421D 15476  15478  16341  16343
VIC_RASTER                     $d012   422
VIC_SPR_ENA                    $d015   423
VIC_CONTROL_2                  $d016   424D 16439
MEM_CONTROL                    $d018   650D 10289  10291  10488  10504
                                     10513
CIA1_PRA                       $dc00   568D   623
IO_Base_Address                $dc00  1610D  8758   8759
KEYB_COL                       $dc00   623D  9723   9744  10118  10139
                                     10190  10267  13590  13596  16694
KEYB_ROWN                      $dc01   625D 13583  13584
CIA1_PRB                       $dc01   571D   624    625
KEYB_ROW                       $dc01   624D  9724  10119  10150  10151
                                     13593  13594
CIA1_DDRA                      $dc02   585
CIA1_DDRB                      $dc03   586
CIA1_TALO                      $dc04   587D 16760  16765
VIA2_T1CL                      $dc04   640D 15594
VIA2_T1CH                      $dc05   641D 15597
CIA1_TAHI                      $dc05   588D 16768
CIA1_TBLO                      $dc06   589
VIA2_T2CL                      $dc06   639D 15585  15653  15658  16121
IEC_TIM_H                      $dc07   651D 10951  11155
VIA2_T2CH                      $dc07   638D 15596  15650  15654  15659
                                     16122
CIA1_TBHI                      $dc07   590
CIA1_TODT                      $dc08   591
CIA1_TODS                      $dc09   592
CIA1_TODM                      $dc0a   593
CIA1_TODH                      $dc0b   594
CIA1_SDR                       $dc0c   595
CIA1_ICR                       $dc0d   596D   637    652  10082  10957
                                     10960  11162  15602  15663  16029
                                     16030  16124  16348  16692  17272
VIA2_IER                       $dc0d   637D 15465  15466  15843  15858
IEC_IFR                        $dc0d   652D 11166
CIA1_CRA                       $dc0e   597D 15468  15600  16696  17273
                                     17276
CIA1_CRB                       $dc0f   598D 10956  11160  15470  15662
                                     16126  16698
CIA2_PRA                       $dd00   604D 12930  12931
IEC_PCR                        $dd00   653D 10939  10942  11259  11261
                                     11268  11270  11279  11281  11288
                                     11290  11297  11298
IEC_DRAN                       $dd00   654D 10782  10784  10913  10914
                                     11010  11017  11091  11093  11205
                                     11206  11221  11222
CIA2_PRB                       $dd01   605D 12884  12928  17168
RS2_DSR_CTS                    $dd01   664D 11405  11605  11621  11623
                                     11625  11628  11713  11727  11729
                                     11732
CIA2_DDRA                      $dd02   606
CIA2_DDRB                      $dd03   607D 12927
CIA2_TALO                      $dd04   608
RS2_TIM_LOW                    $dd04   666D 11683
RS2_TIM_HIG                    $dd05   667D 11685
CIA2_TAHI                      $dd05   609
CIA2_TBLO                      $dd06   610D 17171  17174  17183  17192
                                     17201
CIA2_TBHI                      $dd07   611D 17175  17177  17184  17194
                                     17202
CIA2_TODT                      $dd08   612
CIA2_TODS                      $dd09   613
CIA2_TODM                      $dd0a   614
CIA2_TODH                      $dd0b   615
CIA2_SDR                       $dd0c   616
CIA2_ICR                       $dd0d   617D   665  11448  11452  12925
                                     16693  16937  16938  16996  17100
                                     17181
RS2_IRQ_REG                    $dd0d   665D 11511  11814
CIA2_CRA                       $dd0e   618D 11673  11691  16697
CIA2_CRB                       $dd0f   619D 16699  17179  17196
C64_Kernal_ROM                 $e000  7666D  7664
EXP_20                         $e00b  7682D  7690
EXP_30                         $e00e  7685D  7680
EXP_40                         $e01e  7696D  7702
Square_And_Series_Eval         $e043  7716D  6515   8185   8246
Eval_Series_AY                 $e059  7728D  7708
Eval_Series                    $e05d  7734D  7723
EvSe_10                        $e06c  7746D  7743
EvSe_20                        $e070  7750D  7763
EvSe_30                        $e07d  7758D  7755
RND_VA                         $e08d  7766D  7795   7795
RND_VB                         $e092  7767D  7797   7797
Basic_RND                      $e097  7770D  1858
RND_10                         $e0be  7792D  7775
RND_20                         $e0d3  7800D  7774
RND_30                         $e0e3  7810D  7790
Go_Assign_FAC1_To_Var          $e0f6  7822D  8197
Error_Handler                  $e0f9  7828D  7850   7858   7873   7881
                                      7889   7935   8032
ErHa_10                        $e104  7837D  7832
ErHa_20                        $e109  7842D  7839
CHROUT_Checked                 $e10c  7846D  3661
Read_Char                      $e112  7854D  2438
Select_Output_Channel          $e118  7862D  3491
CHKIN_Checked                  $e11e  7877D  3708   3729
GETIN_Checked                  $e124  7885D  3820
Basic_SYS                      $e12a  7893D  1841
SYS_Ret                        $e147  7911D  7898   7900
Basic_SAVE                     $e156  7926D  1831
Jiffy_SAVE                     $e159  7931
Basic_VERIFY                   $e165  7939D  1832
Basic_LOAD                     $e168  7946D  1830
LOAD_05                        $e17e  7959
LOAD_10                        $e187  7972
LOAD_20                        $e194  7979D  7975   8029
LOAD_30                        $e195  7982D  7957
LOAD_40                        $e19e  7988D  7965
LOAD_50                        $e1a1  7991D  7985
LOAD_55                        $e1a7  7996
LOAD_60                        $e1b5  8001D  7994
Basic_OPEN                     $e1be  8013D  1842
Basic_CLOSE                    $e1c7  8023D  1843
Jump_Error_Handler             $e1d1  8031D  7955   8018
Get_Load_Save_Params           $e1d4  8035D  7929   7951
Get_Byte_Param                 $e200  8062D  8050   8055   8109   8120
Exit_On_EOS                    $e206  8069D  8047   8049   8054   8108
                                      8119   8126
EOE_Ret                        $e20d  8076D  8073   8090
Read_Comma_And_Byte            $e20e  8080D  8065   8127
Need_Byte                      $e211  8086D  8099
Get_Open_Close_Params          $e219  8094D  8016   8026
GOCP_05                        $e229  8105
GOCP_10                        $e23f  8117D  8114
Set_Filename                   $e257  8130D  8048
Set_Filename_From_String       $e25a  8135
Basic_COS                      $e264  8142D  1861
Basic_SIN                      $e26b  8149D  1862   8194
SIN_10                         $e29d  8173D  8165   8212
SIN_20                         $e2a0  8176D  8168
SIN_30                         $e2ad  8183D  8180
Basic_TAN                      $e2b4  8188D  1863
TAN_10                         $e2dc  8208D  8203
PI_Half                        $e2e0  8214D  8145   8145   8250   8250
Two_PI                         $e2e5  8215D  8153   8153
Float_0_25                     $e2ea  8216D  8161   8161   8177   8177
VAR_SIN                        $e2ef  8218D  8184   8184
Basic_ATN                      $e30e  8228D  1864
ATN_10                         $e316  8236D  8233
ATN_20                         $e324  8244D  8240
ATN_30                         $e337  8253D  8249
ATN_Ret                        $e33d  8258D  8255
VAR_ATN                        $e33e  8261D  8245   8245
Basic_Warm_Start               $e37b  8278D  1804
Vectored_Basic_Ready           $e386  8284D  2794   3039   8307
Back_To_Prompt                 $e38b  8287D  8423
Jump_READY                     $e391  8292D  8289
Basic_Cold_Start               $e394  8296D  1803
CHRGET_ROM                     $e3a2  8315D  4380   4382   8327   8354
CHRO_10                        $e3a8  8322D  8319
CHRO_Ret                       $e3b9  8333D  8325
Init_BASIC_RAM_Vectors         $e3bf  8339D  8302
IBRV_10                        $e3e2  8353D  8357
IBRV_Ret                       $e421  8383D  8380
Print_Startup_Message          $e422  8387D  8303
Basic_Vectors                  $e447  8417D  8452
Init_BASIC_Jump_Vectors        $e453  8446D  8300
IBJV_10                        $e455  8451D  8455
Bytes_Free_Message             $e460  8462D  8400   8400
Start_Message                  $e473  8465D  8392   8392
CHKOUT_Checked                 $e4ad  8477D  7866
CHCh_Ret                       $e4b6  8487D  8484
Je4d3                          $e4d3  8553D 11531
STA_COLOR                      $e4da  8559D  9913
Delay_2JiffyM                  $e4e0  8565D 15220
Be4e2                          $e4e2  8569D  8574
Be4eb                          $e4eb  8575D  8572
BaudNTSC                       $e4ec  8579D 12854  12855
Kernal_IOBASE                  $e500  8755D 18408
Kernal_SCREEN                  $e505  8763D 18347
Kernal_PLOT                    $e50a  8771D 18377
PLOT_05                        $e50c  8776
PLOT_10                        $e513  8781D  8774
Initialise_Hardware            $e518  8787D 16977  17257
InHa_10                        $e51b  8806
Clear_Screen                   $e544  8826D  9514
ClSc_10                        $e54d  8835D  8845
ClSc_20                        $e555  8842D  8839
ClSc_30                        $e560  8850D  8853
Do_Home                        $e566  8856D  8920   9348
Adjust_Line                    $e56c  8863D  8779   9254   9488   9541
Home_10                        $e570  8867D  8874
Home_20                        $e57c  8876D  8869
Home_30                        $e582  8891D  8897
Home_40                        $e58c  8899D  8893
Home_50                        $e591  8908D  9029
Home_Ret                       $e598  8913D  8910
Set_Default_Devices            $e5a0  8923D  8790   8919
Init_VIC_Chip                  $e5a8  8932
IVC_Loop                       $e5aa  8937D  8941
Get_Char_From_Keyboard_Buffer  $e5b4  8945D  8990  11947
GCFK_Loop                      $e5b9  8951D  8956
Display_And_Get_Key            $e5ca  8964D  9007
Get_Key                        $e5cd  8970D  8976   9003   9054
GETK_10                        $e5e7  8986D  8979
GETK_20                        $e5f3  8998D  9002
GETK_30                        $e5fe  9005D  8993
GETK_40                        $e606  9011D  9016
GETK_50                        $e60f  9018D  9014
CHRIN_Keyboard_Or_Screen       $e632  9046D 11979  11991
Get_Screen                     $e63a  9057D  9026   9035   9042
GetS_05                        $e64a  9072D  9069
GetS_10                        $e650  9077D  9073
GetS_15                        $e654  9081D  9075   9078
GetS_20                        $e65d  9087D  9043
GetS_25                        $e66f  9098D  9093
GetS_30                        $e672  9101D  9096
GetS_35                        $e674  9104D  9085
GetS_40                        $e682  9115D  9112
If_Quote_Toggle_Flag           $e684  9120D  9083   9293
IQTF_Ret                       $e690  9130D  9124
Insert_Char                    $e691  9134D  9417
InsC_10                        $e693  9139D  9294
InsC_20                        $e697  9143D  9299   9338   9472
InsC_30                        $e699  9146D  9141
InsC_40                        $e69f  9151D  9148
InsC_50                        $e6a8  9156D  9249   9367   9392   9464
                                      9505   9509   9517   9553  10516
                                     10542
InsC_60                        $e6b0  9163D  9160
Advance_Cursor                 $e6b6  9172D  9154
AdCu_10                        $e6cd  9186D  9183
Expand_Logical_Line            $e6da  9195D  9189   9790   9835
ELL_20                         $e6e9  9215
Set_Pointer_To_Start_Of_Logica $e6ed  9220D  8911   9226
SPTS_10                        $e6f4  9228D  9224
SPTS_20                        $e6f7  9231D  9181
SPTS_Ret                       $e700  9237D  9179
Previous_Line                  $e701  9241D  9306   9508
PreL_10                        $e70b  9251D  9245
Screen_CHROUT                  $e716  9260D  8967   9099  12162
ScrO_02                        $e72a  9276D  9273
ScrO_04                        $e731  9281D  9278
ScrO_06                        $e73d  9289D  9285
ScrO_08                        $e73f  9292D  9287
ScrO_10                        $e745  9296D  9283
ScrO_12                        $e74c  9301D  9298
ScrO_14                        $e759  9309D  9305
ScrO_16                        $e762  9315D  9326
ScrO_18                        $e773  9328D  9307
ScrO_20                        $e77e  9335D  9303
ScrO_22                        $e785  9340D  9337
ScrO_24                        $e78b  9345D  9342
ScrO_26                        $e792  9350D  9347
ScrO_28                        $e7a8  9363D  9378   9379
ScrO_30                        $e7aa  9366D  9358
ScrO_32                        $e7ad  9369D  9352
ScrO_34                        $e7c0  9382D  9386
ScrO_36                        $e7c8  9388D  9384
ScrO_38                        $e7cb  9391D  9333
ScrO_40                        $e7ce  9394D  9371
ScrO_42                        $e7d4  9398D  9274
ScrO_44                        $e7dc  9406D  9404
ScrO_46                        $e7e3  9419D  9416
ScrO_48                        $e7ea  9424D  9421
ScrO_50                        $e7fe  9436D  9432
ScrO_52                        $e805  9441D  9434
ScrO_54                        $e80a  9445D  9456
ScrO_56                        $e826  9463D  9438
ScrO_58                        $e829  9466D  9428
ScrO_60                        $e82d  9470D  9426
ScrO_62                        $e832  9474D  9468
ScrO_64                        $e847  9487D  9483
ScrO_66                        $e84c  9491D  9476
ScrO_68                        $e854  9497D  9493
ScrO_70                        $e864  9507D  9501
ScrO_72                        $e86a  9511D  9499
ScrO_74                        $e871  9516D  9478   9485   9489
ScrO_76                        $e874  9519D  9513
Do_Newline                     $e87c  9525D  9233   9360   9389   9552
NewL_10                        $e880  9531D  9539
NewL_20                        $e888  9537D  9534
Screen_Return                  $e891  9544D  9279   9422
Test_Line_Dec                  $e8a1  9556D  9310   9502
TLD_10                         $e8a5  9562D  9568
TLD_20                         $e8b0  9571D  9564
Test_Line_Inc                  $e8b3  9576D  9175   9354
TLI_10                         $e8b7  9582D  9588
TLI_20                         $e8c2  9592D  9584
TLI_30                         $e8ca  9598D  9595
Set_Color                      $e8cb  9602D  9395   9521
SeCo_Loop                      $e8cd  9607D  9611
SeCo_10                        $e8d6  9614D  9609
Color_Codes                    $e8da  9618D  9605   9608
Color_Codes_End                $e8ea  9640D  9605
Scroll_Screen                  $e8ea  9653D  9190   9535   9786
ScSc_05                        $e8f6  9665D  9702
ScSc_10                        $e8ff  9671D  9680
ScSc_15                        $e913  9682D  9675
ScSc_20                        $e918  9686D  9697
ScSc_25                        $e922  9693D  9690
ScSc_27                        $e938  9705
ScSc_30                        $e94d  9749D  9752   9754
ScSc_40                        $e956  9758D  9746
ScSc_45                        $e958  9761D  9838
Insert_Line                    $e965  9773D  9439
InsL_10                        $e967  9778D  9184   9781
InsL_20                        $e981  9792D  9784   9785
InsL_30                        $e98f  9803D  9813
InsL_40                        $e9a6  9815D  9807   9808
InsL_50                        $e9ab  9819D  9831
InsL_60                        $e9ba  9828D  9825
InsL_70                        $e9bf  9833D  9821
Shift_Row                      $e9c8  9853D  9679   9812
ShRo_10                        $e9d2  9861
ShRo_20                        $e9d4  9864D  9870
Update_Color_RAM_Pointer       $e9e0  9874D  9859
Start_Of_Line                  $e9f0  9892D  8878   9229   9673   9805
                                      9908
Clear_Screen_Row_X             $e9ff  9904D  8851   9683   9816
CSRX_Loop                      $ea07  9911D  9922
Display_Char_A_And_Color_X     $ea13  9931D  8984   9153
Display_Char_And_Color         $ea1c  9941D  9988
Set_COLRAM_Pointer             $ea24  9951D  8906   9313   9443   9877
                                      9909   9937   9980
Default_IRQ                    $ea31  9963D 16516  16682
DIRQ_10                        $ea5c  9986D  9977
DIRQ_20                        $ea61  9990D  9968   9970
DIRQ_30                        $ea71 10052D 10037
DIRQ_40                        $ea79 10065D 10050
DIRQ_50                        $ea7b 10078D 10054
Kernal_SCNKEY                  $ea87 10096D 10079  17544
KeSc_05                        $eaa8 10142D 10196
KeSc_10                        $eaab 10147D 10154
KeSc_15                        $eab3 10160D 10184
KeSc_20                        $eac9 10173D 10166  10168
KeSc_25                        $eacb 10176D 10171
KeSc_30                        $eacc 10179D 10162
KeSc_35                        $eadc 10198D 10182
KeSc_40                        $eae0 10207D 10331
KeSc_45                        $eaf0 10217D 10212
KeSc_50                        $eafb 10224D 10121
KeSc_55                        $eb0d 10235D 10220  10227  10229  10231
KeSc_60                        $eb17 10241D 10237
KeSc_65                        $eb26 10250D 10215  10225
KeSc_70                        $eb42 10265D 10221  10233  10239  10243
                                     10248  10256  10260  10278
Keyboard_Decoder               $eb48 10271D  8810   8812
KeDe_10                        $eb64 10308D 10276
KeDe_20                        $eb6b 10319D 10311
KeDe_30                        $eb76 10330D 10280  10305
KBD_Decode_Pointer             $eb79 10363D 10326  10328
KBD_NORMAL                     $eb81 10402D 10132  10134  10366
KBD_SHIFTED                    $ebc2 10428D 10367
KBD_CBMKEY                     $ec03 10454D 10368
Switch_Text_Graphics           $ec44 10481D  9396
STG_10                         $ec4f 10499D  9522  10485
STG_20                         $ec58 10512D 10490
STG_30                         $ec5b 10515D 10534
STG_40                         $ec5e 10518D 10501
STG_50                         $ec69 10532D 10520
STG_60                         $ec72 10538D 10525
KBD_CONTROL                    $ec78 10565D 10372
VIC_INIT                       $ecb9 10577D  8938
RUNKEY                         $ece7 10717D  8999
Line_Adress_Low                $ecf0 10720D  9676   9809   9895
Kernal_TALK                    $ed09 10736D 12328  12985  17747
Kernal_LISTEN                  $ed0c 10743D 12379  12768  13414  13452
                                     17722
IEC_Send_Control_Byte          $ed11 10750D 11105
ISCB_10                        $ed20 10766D 10755
ISCB_20                        $ed2e 10781D 10778
IEC_Delay_And_Send_Byte        $ed36 10787D 11004  11025
IEC_Send_Byte                  $ed40 10798D 10761  11072
ISCB_30                        $ed50 10816D 10821
ISCB_40                        $ed55 10827D 10832
ISCB_50                        $ed5a 10838D 10810  10843
ISCB_60                        $ed66 10912D 10915  10944
ISCB_70                        $ed7a 10930D 10926
ISCB_80                        $ed7d 10933D 10928
ISCB_90                        $ed97 10953
ISCB_95                        $ed9f 10959D 10964
Device_Not_Present             $edad 10978D 10807
IEC_Timeout                    $edb0 10985D 10924  10962
Set_IEC_Status                 $edb2 10991D 11184
Kernal_SECOND                  $edb9 11000D 12386  12771  13416  13456
                                     17426
IEC_ATN_High                   $edbe 11007D 11033  11108  12382
Kernal_TKSA                    $edc7 11021D 12335  12987  17456
IEC_Finish_Send                $edcc 11028D 12331
IFS_10                         $edd6 11036D 11048
Kernal_CIOUT                   $eddd 11058D 12172  12789  13420  13422
                                     13428  17648
KeCI_10                        $ede6 11067D 11062
KeCI_20                        $edeb 11076D 11065
Kernal_UNTLK                   $edef 11082D 12606  13092  17669
Kernal_UNLSN                   $edfe 11101D 12601  13443  13459  17694
KeUN_10                        $ee03 11107D 10997
IEC_Delay_CLK_High_DATA_High   $ee06 11111D 11247
IDel_10                        $ee09 11121D 11123
Kernal_ACPTR                   $ee13 11129D 12122  12988  12997  13050
                                     17613
KeAC_03                        $ee16 11139
KeAC_05                        $ee1b 11143D 11146
KeAC_10                        $ee20 11153D 11198
KeAC_15                        $ee25 11157
KeAC_20                        $ee30 11163D 11172
KeAC_25                        $ee3e 11180D 11168
KeAC_30                        $ee47 11186D 11182
KeAC_35                        $ee56 11200D 11173
KeAC_40                        $ee5a 11204D 11207  11211  11235
KeAC_45                        $ee67 11220D 11223  11227
KeAC_50                        $ee80 11249D 11240
CLR_IEC_CLK                    $ee85 11256D 10779  10808  10934  11034
                                     11125  11141  11190
SET_IEC_CLK                    $ee8e 11265D 10793  10847  11089  17277
CLR_IEC_DAT                    $ee97 11276D 10775  10794  10802  10931
                                     11126  11161
SET_IEC_DAT                    $eea0 11285D 10927  11032  11187  11236
GET_IEC_CLK                    $eea9 11294D 10803  10817  10828  10839
                                     10963  11046  11144  11169  11299
WAIT_1MS                       $eeb3 11306D 10795
W1MS_10                        $eeb6 11313D 11315
RS232_NMI_Transmit             $eebb 11332D 17024
RTra_05                        $eec8 11343D 11340
RTra_10                        $eed1 11350D 11371  11373  11394
RTra_15                        $eed7 11356D 11348
RTra_20                        $eee6 11365D 11377  11382  11386
RTra_25                        $eee7 11368D 11363  11381  11385
RTra_30                        $eef2 11375D 11359
RTra_32                        $eef6 11379D 11361
RTra_35                        $eefc 11384D 11360
RTra_40                        $ef00 11391D 11337
RS232_Setup_Next_Byte_To_Send  $ef06 11397D 11336  11689
RSNB_10                        $ef13 11414D 11402
RS232_No_DSR_Signal            $ef2e 11429D 11411
RNDS_10                        $ef31 11435D 11412
RNDS_20                        $ef39 11442D 11422
RNDS_30                        $ef3b 11447D 11517  11688  11740
RS232_Set_Data_Bits            $ef4a 11462D 12832
RSDB_10                        $ef54 11471D 11468
RSDB_20                        $ef58 11476D 11472
RS232_NMI_Receive              $ef59 11480D 17185
RRec_05                        $ef6d 11494D 11507  11560  11564  11568
RRec_10                        $ef6e 11497D 11559
RRec_15                        $ef70 11500D 11487
RRec_20                        $ef7e 11509D 11528  11584
RRec_25                        $ef90 11526D 11484
RRec_30                        $ef97 11538D 11486
RRec_35                        $efa9 11548D 11553
RRec_40                        $efb1 11555D 11550
RRec_45                        $efc5 11567D 11563
RRec_50                        $efca 11572D 11542
RRec_55                        $efcd 11576D 11589
RRec_60                        $efd0 11580D 11588
RRec_65                        $efdb 11586D 11502
RS232_CHKOUT                   $efe1 11597D 12365
RRec_70                        $efe1 11591
RCHO_10                        $eff2 11609D 11618
RCHO_20                        $eff9 11620D 11622
RCHO_30                        $f006 11627D 11630
RS232_Set_Status_No_Signal     $f00d 11633D 11606  11714  12892
RSSN_10                        $f012 11643D 11603  11607  11629
RS232_Put_Byte_To_Buffer       $f014 11648D 11659
RPBB_10                        $f017 11654D 12282
RPBB_20                        $f028 11667D 11652
RPBB_30                        $f033 11681
RPBB_40                        $f04c 11693D 11671
RS232_CHKIN                    $f04d 11703D 12313
RCHI_10                        $f062 11717D 11721
RCHI_20                        $f070 11731D 11734
RCHI_30                        $f077 11736D 11745
RCHI_40                        $f07d 11742D 11709  11711
RCHI_50                        $f084 11751D 11715
RS232_Get_Byte_From_Buffer     $f086 11765D 11958
RGBB_10                        $f09c 11782D 11773
RS232_Stop                     $f0a4 11791D 10747  15474
RSTP_10                        $f0aa 11799D 11802
RSTP_30                        $f0bb 11820D 11797
Msg_Start                      $f0bd 11824D 11921  13337  13341  13363
                                     13366  13551  15208  15359  15368
                                     15398
Msg_Searching                  $f0c9 11825D 13337
Msg_FOR                        $f0d4 11826D 13341
Msg_Play                       $f0d8 11901D 15359
Msg_Record                     $f0eb 11902D 15398
Msg_Loading                    $f106 11904D 13363
Msg_Saving                     $f10e 11905D 13551
Msg_Verifying                  $f116 11906D 13366
Msg_Found                      $f120 11907D 15208
Msg_ok                         $f127 11908D 15368
Display_Direct_Msg             $f12b 11911D 13369
Display_Kernal_IO_Message      $f12f 11918D 11927  13338  13342  13552
                                     13686  15209  15362  15369
DDM_10                         $f13c 11929D 11915
Kernal_GETIN                   $f13e 11934D 16527
KeGE_10                        $f14a 11949D 11938
RS232_Get_Byte                 $f14e 11954D 12129
KeGE_20                        $f155 11961D 11941
Kernal_CHRIN                   $f157 11966D 16524
CHRI_05                        $f166 11983D 11951  11973
CHRI_07                        $f16a 11987
CHRI_10                        $f173 11993D 11985
CHRI_15                        $f18d 12065D 12061
CHRI_20                        $f193 12073D 12060
CHRI_25                        $f196 12077D 12057
TAPE_Get_Byte                  $f199 12082D 12056  12059  12091
TGB_05                         $f1a9 12093D 12086
IEC_Get_Byte                   $f1ad 12103D 11994
IGB_10                         $f1b1 12109D 12141
IGB_20                         $f1b3 12112D 12138
IGB_30                         $f1b4 12115D 12088  12131
IGB_40                         $f1b5 12118D 12107
RS232_Read_Byte                $f1b8 12126D 11999  12143
Kernal_CHROUT                  $f1ca 12151D 16525
KeCO_10                        $f1d5 12166D 12157
KeCO_20                        $f1db 12176D 12167
TAPE_Send_Byte                 $f1dd 12190D 12499
TASB_10                        $f1f2 12242D 12233
TASB_20                        $f1f6 12247D 12283
TASB_30                        $f1f7 12259D 12235
TASB_40                        $f201 12274D 12270
RS232_Send_Byte                $f202 12278D 12204
Kernal_ICHKIN                  $f208 12297D 16521
KICH_10                        $f210 12304D 12301
KICH_20                        $f224 12315D 12312
KICH_30                        $f22d 12321D 12307  12309  12318  12340
KICH_40                        $f231 12326D 12310
KICH_50                        $f23f 12334D 12330
KICH_60                        $f242 12337D 12332
Kernal_CHKOUT                  $f24a 12344D 16522
KCHO_10                        $f252 12351D 12348
KCHO_20                        $f259 12356D 12370
KCHO_30                        $f25c 12359D 12354
KCHO_40                        $f269 12367D 12364
KCHO_50                        $f26f 12372D 12361  12391
KCHO_60                        $f273 12377D 12362
KCHO_70                        $f280 12385D 12381
KCHO_80                        $f283 12388D 12383
Kernal_CLOSE                   $f28b 12395D 16520
KeCL_10                        $f292 12403D 12399
KeCL_20                        $f2b4 12432D 12429
KeCL_30                        $f2b9 12437D 12434
KeCL_40                        $f2c2 12443D 12413
KeCL_60                        $f2da 12513D 12502
KeCL_70                        $f2e8 12522D 12411
KeCL_80                        $f2eb 12525D 12408  12410  12493  12516
                                     12519
Close_File                     $f2ec 12529D 12415
ClFi_05                        $f2ed 12534
ClFi_10                        $f307 12546D 12537
ClFi_Ret                       $f308 12549
Find_File_X                    $f309 12553D 12300  12347  12623
Find_File_A                    $f30e 12561D 12398
FiFi_10                        $f310 12566D 12570
Get_LFS                        $f319 12574D 12305  12352  12404
GLFS_Ret                       $f328 12584D 12568
Kernal_CLALL                   $f329 12588D 16528
Kernal_CLRCHN                  $f32d 12595D 16523
KeCC_10                        $f336 12603D 12600
KeCC_20                        $f33d 12608D 12605
Kernal_OPEN                    $f344 12615D 16519
OPEN_05                        $f34b 12622D 12619
OPEN_10                        $f353 12627D 12624
OPEN_15                        $f35c 12633D 12630
OPEN_20                        $f37e 12650D 12646
OPEN_25                        $f385 12666D 12656
OPEN_30                        $f38d 12672D 12668
OPEN_35                        $f3a6 12710D 12717
OPEN_40                        $f3a9 12713D 12705
OPEN_45                        $f3b2 12719D 12700
OPEN_50                        $f3bc 12725D 12707  12716
OPEN_55                        $f3cb 12736D 12729
OPEN_60                        $f3cd 12739D 12643  12645  12648  12751
                                     12758
OPEN_Ret                       $f3ce 12742D 12702  12708  12715  12721
IEC_Send_SA_And_Filename       $f3cf 12746D 12647  12983  13411
Pop_Dev_Not_Present            $f3eb 12775
Jmp_Dev_Not_Present            $f3ed 12779
ISSF_10                        $f3f0 12782D 12773
ISSF_20                        $f3f6 12787D 12792
ISSF_30                        $f400 12794D 12784
RS232_Open                     $f403 12806D 12658
ROPN_05                        $f409 12822D 12829
ROPN_10                        $f417 12831D 12824
ROPN_15                        $f424 12843
ROPN_20                        $f434 12853D 12848
ROPN_25                        $f43a 12857D 12851
ROPN_30                        $f440 12861D 12837
ROPN_35                        $f456 12898D 12882  12890
ROPN_40                        $f46e 12910D 12905
ROPN_45                        $f477 12917D 12441  12912
ROPN_50                        $f47d 12923D 12417  12810
Kernal_LOAD                    $f498 12938D 18157
Default_LOAD                   $f49f 12945D 16541
DLOA_05                        $f4a9 12954D 12959
DLOA_10                        $f4ac 12957D 12952
DLOA_15                        $f4b9 12973D 12966
DLOA_20                        $f4ea 13008D 13002
DLOA_25                        $f4ed 13023D 13055  13089
DLOA_30                        $f4fb 13049D 13046
DLOA_35                        $f516 13078D 13058
DLOA_40                        $f518 13082D 13073
DLOA_45                        $f51e 13087D 13084
DLOA_47                        $f522 13091
DLOA_50                        $f52a 13100D 12993  13264  13269
DLOA_55                        $f52d 13103D 12963
DLOA_60                        $f533 13248D 13239
DLOA_65                        $f53b 13253D 13250
DLOA_70                        $f543 13258D 13279
DLOA_75                        $f550 13266D 13260
DLOA_80                        $f557 13271D 13262
DLOA_85                        $f566 13281D 13292
DLOA_90                        $f573 13290D 13277
DLOA_92                        $f577 13294D 13288
DLOA_94                        $f5a3 13321D 13097
DLOA_95                        $f5a4 13324
DLOA_Ret                       $f5a8 13328D 13255  13263  13268  13275
Print_Searching                $f5a9 13332D 12703  12976  13256
PrSe_10                        $f5bb 13344D 13553
PrSe_20                        $f5c1 13349D 13354
PrSe_Ret                       $f5cb 13356D 13336  13340  13346
Display_LOADING_Or_VERIFYING   $f5cc 13360D 13012  13316
DLV_10                         $f5d4 13368D 13365
Kernal_SAVE                    $f5d7 13372D 18193
Default_SAVE                   $f5e7 13385D 16542
SAVE_10                        $f5eb 13391D 13396  13515
SAVE_20                        $f5ee 13394D 13389
Jmp_Missing_Filename           $f5fc 13407
SAVE_30                        $f5ff 13410D 13405
SAVE_40                        $f61e 13424D 13440
SAVE_50                        $f62d 13432D 13047
SAVE_60                        $f634 13438D 13430
SAVE_70                        $f639 13442D 13426
IEC_Close                      $f63c 13446D 12523  13093  13433
IClo_10                        $f64e 13458D 12796
IClo_20                        $f651 13461D 13450
IClo_30                        $f653 13501D 13400
IClo_40                        $f659 13513D 13504
IClo_50                        $f670 13525D 13522
IClo_60                        $f687 13539D 13533
IClo_Ret                       $f688 13542D 13517  13528  13530  13550
Display_SAVING_Filename        $f689 13546D 13412  13518
Kernal_UDTIM                   $f695 13556D 18330
UDTI_10                        $f6a1 13566D 13561  13563
Look_For_Special_Keys          $f6b6 13580D 13574  13585  15526  16958
LFSK_10                        $f6c6 13592D 13595
LFSK_20                        $f6d4 13601D 13588
LFSK_Ret                       $f6d6 13604D 13598
Kernal_RDTIM                   $f6d7 13608D 18240
Kernal_SETTIM                  $f6de 13617D 18221
Kernal_STOP                    $f6e7 13628D 16526
STOP_Ret                       $f6f4 13644D 13638
Too_Many_Files                 $f6f5 13647D 12631
File_Already_Open              $f6f8 13651D 12625
File_Not_Open                  $f6fb 13655D 12302  12349
File_Not_Found                 $f6fe 13659D 12711  13101
Dev_Not_Present                $f701 13663D 12341  12392  12780
Not_Input_File                 $f704 13667D 12319  12620
Not_Output_File                $f707 13671D 12357
Missing_File_Name              $f70a 13675D 12970  13408
Illegal_Jiffy_Device           $f70d 13679D 12669  12955  13240  13251
                                     13392  13505
DIOR_10                        $f723 13692D 13685
Jiffy_RTS                      $f725 13696
TAPE_Find_Any_Header           $f726 15184D 12714  13267  15202  15318
TFAH_10                        $f745 15204D 15198  15200
TFAH_20                        $f751 15212D 15217
TFAH_30                        $f761 15224D 15207
TFAH_Ret                       $f763 15228D 15192  15196
TAPE_Write_Header              $f764 15232D 12518  12723  13527  13535
TWH_10                         $f77b 15243D 15246
TWH_20                         $f79f 15266D 15275
TWH_30                         $f7b1 15277D 15269
TWH_Ret                        $f7c9 15287D 15237
TAPE_Get_Buffer_Address        $f7ca 15291D 12494  12667  13249  13514
                                     15236  15302  15347
TAPE_Set_Buffer_Pointer        $f7d1 15299D 15278  15408  15437
TAPE_Find_Fileheader           $f7e4 15315D 12706  13261  15331
TFF_10                         $f7f1 15325D 15335
TFF_20                         $f805 15337D 15327
TFF_Ret                        $f806 15340D 15319
TAPE_Advance_Buffer_Pointer    $f807 15344D 12085  12232
Wait_For_Play                  $f811 15354D 12701  13254  15414
WFP_10                         $f818 15361D 15399
WFP_20                         $f81b 15364D 15367
TAPE_Sense                     $f828 15372D 15357  15366  15396
TASe_10                        $f830 15388D 15358  15378  15397
TAPE_Wait_For_Record           $f832 15393D 12720  13516  15450
TAPE_Init_Read                 $f83b 15402D 12087  15189
TAPE_Read                      $f844 15411D 13317
Init_Tape_Write                $f85e 15434D 12234  12501
TAPE_Write_With_Lead           $f861 15440D 13529
TAPE_Write                     $f865 15447D 15281
TAWR_10                        $f868 15452D 15415
TAWR_20                        $f86f 15463D 15431
TAWR_30                        $f8af 15506D 15513
TAWR_40                        $f8b1 15509D 15511
TAWR_50                        $f8b8 15519D 15535
TAPE_Abort_On_STOP             $f8ca 15538D 15365  15524
Clear_Saved_IRQ_Address        $f8d6 15550D 15453  15523
CSIA_Ret                       $f8db 15556D 15543
TAPE_Set_Timer                 $f8dc 15560D 15759  15801  15828  15877
TST_10                         $f8f1 15577D 15574
TST_20                         $f8f8 15584D 15592
TST_30                         $f924 15611D 15604  15605  15607
TAPE_Read_IRQ                  $f926 15647D 15655  16683
TARI_02                        $f963 15685D 15682
TARI_04                        $f982 15703D 15687  15755
TARI_06                        $f985 15706D 15701  15761  15782
TARI_08                        $f98d 15712D 15692
TARI_10                        $f991 15716D 15697  15814
TARI_12                        $f993 15719D 15714
TARI_14                        $f9a6 15731D 15680  15708  15710  15784
                                     15786  15788
TARI_16                        $f9b6 15742D 15738
TARI_18                        $f9c3 15757D 15797
TARI_20                        $f9cc 15763D 15733  15740  15795
TARI_22                        $f9cf 15766D 15728
TARI_24                        $f9d8 15773D 15769
TARI_26                        $f9da 15776D 15768
TARI_28                        $f9f1 15790D 15754  15780
TARI_30                        $fa0a 15804D 15704
TARI_32                        $fa12 15810D 15806
TARI_34                        $fa19 15820D 15808  15813
TARI_36                        $fa3e 15846D 15831
TARI_38                        $fa4d 15860D 15849
TARI_40                        $fa57 15867D 15833
TAPE_Store_Char                $fa5a 15871D 15683
TASC_10                        $fa6a 15882D 15879
TASC_20                        $fa80 15895D 15887
TASC_30                        $fa84 15899D 15890  15893  15906  15908
                                     15923  15929  15934
TASC_40                        $fa87 15902D 15885
TASC_50                        $fa9d 15916D 15912
TASC_60                        $faa3 15921D 15904
TASC_62                        $fab4 15931D 15913  15917
TASC_64                        $faba 15936D 15903
TASC_65                        $fabe 15940
TASC_66                        $fac8 15946D 15938
TASC_68                        $fad0 15951D 15948
TASC_70                        $fae5 15964D 15956  15960
TASC_72                        $fb02 15980D 15954
TASC_74                        $fb29 16001D 15993
TASC_76                        $fb2d 16005D 15969
TASC_78                        $fb34 16010D 15966  15978  16003
TASC_80                        $fb3d 16017D 15983  15986  15989  15997
                                     16008  16012
TASC_82                        $fb42 16021D 15949
TASC_84                        $fb44 16024D 15944
TASC_86                        $fb56 16037D 16034
TASC_88                        $fb62 16045D 16039
TASC_90                        $fb6c 16051D 16057
TASC_92                        $fb85 16064D 16019  16041  16043  16060
Set_IO_Start                   $fb88 16068D 13418  15926  16047  16326
TAPE_New_Byte_Setup            $fb91 16077D 15487  15874  16241  16317
TAPE_Write_Bit                 $fba0 16090D 16203
TAPE_Timer_Bit_Is_1            $fba7 16106D 16193
TAPE_Write_Timer               $fba9 16112D 16103  16313
TAPE_Start_Timer               $fbab 16118D 16171
TAST_10                        $fbc2 16142D 16269
TAPE_Write_IRQ                 $fbc7 16153D 16681
TAWI_05                        $fbdd 16186D 16164
TAWI_10                        $fbea 16202D 16188
TAWI_15                        $fc03 16223D 16150  16172  16180  16194
                                     16196  16204  16234  16262  16273
                                     16284
TAWI_20                        $fc06 16229D 16208
TAWI_25                        $fc10 16240D 16332
TAWI_30                        $fc26 16260D 16257
TAWI_35                        $fc2a 16266D 16244
TAWI_40                        $fc39 16277D 16268
TAWI_45                        $fc48 16288D 16233
TAWI_50                        $fc4e 16293D 16309  16314  16316  16319
                                     16375
TAWI_55                        $fc51 16298D 16181
TAWI_60                        $fc58 16303D 16300
TAPE_Write_Leader              $fc64 16311D 16680
Restoring_After_STOP           $fc8d 16335D 15544  16046  16374
RAS_10                         $fcb0 16366D 16361
Reset_TAPE_IRQ                 $fcb2 16371D 16325
TAPE_Set_IRQ_Vector            $fcb7 16378D 15484  16308  16321
TAPE_Stop_Motor                $fcc4 16388D 16301  16345
Check_IO_End                   $fccb 16405D 13425  15947  16056  16267
Inc_SAL_Word                   $fcd5 16416D 13439  16018  16055  16283
ISW_Ret                        $fcdb 16422D 16420
Entry_RESET                    $fcdc 16426D 18418
HARE_10                        $fce9 16437D 16434
Scan_Autostart_Signature       $fcfc 16455D 16433  16949
SAAS_Loop                      $fcfe 16460D 16465
SAAS_Exit                      $fd09 16467D 16463
ROM_SIG                        $fd0a 16471D 16461
Kernal_RESTOR                  $fd0f 16478D 16442  16975  17314
Kernal_VECTOR                  $fd14 16486D 17363
KeVE_10                        $fd1a 16492D 16509
KeVE_20                        $fd21 16503D 16499
KeVe_30                        $fd23 16506
Kernal_Vectors                 $fd2a 16513D 16481  16482
Init_RAM                       $fd4a 16551D 16441  17287
InRA_10                        $fd4d 16556D 16571
InRA_20                        $fd66 16582D 16600
InRA_30                        $fd68 16585D 16599
InRA_40                        $fd82 16602D 16591  16595
TAPE_IRQ_Vectors               $fd95 16665D 16381  16383
Initialise_IO                  $fd9d 16687D 16440  16976  17286
Program_Timer_A                $fdd7 16753D 16359  17265
TASF_10                        $fde6 16763D 16758
TASF_20                        $fded 16767D 16762
Kernal_SETNAM                  $fdf3 16790D 17866
Kernal_SETLFS                  $fdfa 16799D 17833
Kernal_READST                  $fe01 16808D 17788
Kernal_SETMSG                  $fe12 16834D 17395
Get_Status                     $fe14 16839D 16813
Ora_Status                     $fe16 16843D 10994  11196  12063  13075
                                     15892  15942  16007  16062
Kernal_SETTMO                  $fe1b 16851D 17578
Kernal_MEMTOP                  $fe1f 16858D 17483
Read_Memtop                    $fe21 16864D 12427  12903
Set_memtop                     $fe27 16871D 12920  16607  16861
Kernal_MEMBOT                  $fe2e 16879D 17519
MEM_10                         $fe36 16891D 16882
Entry_NMI                      $fe3d 16920D 18417
Default_NMI                    $fe41 16927D 16518
NMI_10                         $fe58 16953D 16950
Default_BRK                    $fe60 16972D 16517  16529
RS232_NMI                      $fe6c 16981D 16939  16965
Bfe72                          $fe6c 16985
Bfe9a                          $fe94 17004D 17001
Mfe9d                          $fe97 17023D 16999  17003
JMP_Exit_IRQ                   $fe9a 17026
NMI_20                         $fe9d 17034D 16990
NMI_30                         $fea8 17068D 17042
Bfeb6                          $feb0 17096D 17028  17062  17071
Exit_IRQ                       $feb6 17104D 15764  15802  15868  15900
                                     16065  16224  16294
Baudrate                       $febc 17115D 12849  12850
RS232_In                       $fed0 17165D 17002  17044
RS232_Out                      $ff01 17188D 17005  17073
Set_Baud_Rate                  $ff28 17208D 12864
Clear_BREAK_Flag               $ff3d 17226D 15609
Entry_IRQ                      $ff42 17236D 18419
BFF82                          $ff52 17249D 17247
Init_Editor                    $ff55 17254D 16443  17285
InEd_10                        $ff58 17259D 17261
PTA_10                         $ff68 17268D 16769
Kernal_Version                 $ff7a 17280
RESTOR                         $ff84 17296
VECTOR                         $ff87 17317
SETMSG                         $ff8a 17366D  2266   3070
SECOND                         $ff8d 17398
TKSA                           $ff90 17429
MEMTOP                         $ff93 17459D  8373
MEMBOT                         $ff96 17486D  8370
SCNKEY                         $ff99 17522
SETTMO                         $ff9c 17547
ACPTR                          $ff9f 17581
CIOUT                          $ffa2 17617
UNTLK                          $ffa5 17651
UNLSN                          $ffa8 17672
LISTEN                         $ffab 17697
TALK                           $ffae 17725
READST                         $ffb1 17750D  3767   4468   7961   7983
SETLFS                         $ffb4 17791D  8045   8053   8059   8107
                                      8118   8125
SETNAM                         $ffb7 17836D  8039   8098   8139
OPEN                           $ffba 17869D  8017
CLOSE                          $ffbd 17905D  8028
CHKIN                          $ffc0 17932D  7880
CHKOUT                         $ffc3 17971D  8481
CLRCHN                         $ffc6 18008D  2232   3739   8279  13640
                                     13682
CHRIN                          $ffc9 18036D  7857
CHROUT                         $ffcc 18088D  7849  11924  13351  13690
                                     15214
LOAD                           $ffcf 18125D  7954
SAVE                           $ffd2 18160D  7934
SETTIM                         $ffd5 18196D  3404
RDTIM                          $ffd8 18224D  4452
STOP                           $ffdb 18243D  3002  13045  13429  15541
                                     16963
GETIN                          $ffde 18270D  7888
CLALL                          $ffe1 18297D  2654
UDTIM                          $ffe4 18314D  9966
SCREEN                         $ffe7 18333
PLOT                           $ffea 18350D  3563   3584   5252
IOBASE                         $ffed 18380D  7776
C64                            $0001     5D   418   1550   1582   1609
                                      1797   2050   2793   3038   3569
                                      7572   7663   7669   7865   7964
                                      8004   8277   8306   8419   8458
                                      8519   8877   8905   9028   9200
                                      9629   9707   9837   9882   9912
                                      9926  10013  10028  10041  10056
                                     10067  10081  10123  10137  10145
                                     10153  10187  10199  10288  10404
                                     10430  10456  10487  10503  10524
                                     10541  10563  10723  10769  10790
                                     10864  10888  10917  10954  11011
                                     11038  11047  11085  11115  11145
                                     11158  11171  11189  11209  11225
                                     11238  11273  11309  11404  11444
                                     11512  11530  11610  11636  11651
                                     11662  11668  11686  11718  11738
                                     11768  11774  11783  11795  11815
                                     11829  11940  12130  12137  12177
                                     12203  12207  12264  12281  12416
                                     12460  12484  12496  12500  12750
                                     12757  12763  12795  12809  12836
                                     12846  12883  12891  12922  12974
                                     13000  13176  13196  13214  13225
                                     13237  13502  13586  13632  13865
                                     14114  14129  14139  14149  14157
                                     14356  14363  14371  14379  14500
                                     14515  14536  14615  14635  14718
                                     14755  14814  14823  14934  14986
                                     15163  15218  15375  15424  15455
                                     15467  15475  15488  15494  15525
                                     15586  15598  15660  15735  15750
                                     15812  15837  15852  16026  16123
                                     16133  16144  16174  16329  16340
                                     16347  16391  16438  16470  16553
                                     16577  16667  16690  16756  16815
                                     16820  16935  16957  16964  16984
                                     17027  17036  17043  17061  17072
                                     17098  17118  17163  17252  18410
INDEXA                         $0022   824D  2115   2125   2133   2163
                                      2165   2229   2231   2240y  2308
                                      2310   2335   2337   2341y  2345
                                      2401   2401   2406y  2412y  2416
                                      2419y  2420   2423y  2424   2425
                                      2876   2876   3289   3305   3307
                                      3310   3410y  3631y  4108   4110
                                      4178   4179   4181   4194   5049
                                      5139   5178   5552   5552   5564
                                      5564   5592   5592   5594y  5597y
                                      5600y  5604y  5612y  5616   5617
                                      5619   5622   5638y  5641y  5662y
                                      5665y  5668y  5685   5685   5693
                                      5694   5696   5699   5783   5783
                                      5795y  5830   5830   5834y  5837y
                                      5840y  5860   5860   5924   5925
                                      5927   6018y  6061   6064   6066
                                      6602   6602   6604y  6607y  6610y
                                      6613y  6621y  6829   6829   6831y
                                      6834y  6837y  6840y  6845y  6876
                                      6876   6879y  6882y  6885y  6890y
                                      6893y  7777   7777   7779y  7782y
                                      7785y  7788y  8137   8138
FAC1M3/FAC1M4                  $0064   965D  3352   3401   3426y  3431y
                                      3440   3445   3451y  4190   4190
                                      4302   4375   4381   4393   4393
                                      4425y  4428y  4453   4475   4475
                                      4494   4494   4531   4544   4865
                                      4926   5109   5136   5388   5388
                                      5477   5477   5741   5741   5748y
                                      5824   5824   6045   6116   6266
                                      6291   6294   6320   6322   6335
                                      6359   6384   6386   6402   6546
                                      6744   6778   6820   6835   6881
                                      7005   7057   7138   7436   7438
                                      7783   7806   7808    966D  3261
                                      3355   3403   3436   3446   4299
                                      4377   4383   4455   4534   4539
                                      4866   4928   5111   5142   5949
                                      5967   5969   6047   6117   6263
                                      6293   6296   6317   6319   6334
                                      6360   6387   6389   6400   6544
                                      6747   6775   6822   6832   6878
                                      7004   7063   7128   7139   7432
                                      7435   7789   7801   7803
TXTPTR                         $007a   996D  2279   2279   2461   2497
                                      2552   2566   2568   2700   2703
                                      2861   2863   2900   2900   2908y
                                      2911y  2918y  2921y  2924   2925
                                      2927   3018   3018   3057   3057
                                      3085   3085   3110   3111   3124
                                      3127   3159   3159   3175   3176
                                      3178   3208y  3693   3693   3812
                                      3812   3815   3815   3836   3836
                                      3845   3864   3864   3889   3889
                                      3892   3892   3905y  3908y  3911y
                                      3999   4001   4058   4060   4063
                                      4135   4137   4140   4279   4279
                                      4348y  5294   5294   5336   5336
                                      5338   5341   5350   5350   6059
                                      6059   6062   6067   6089   6089
                                      7287y  7973   7992   8318   8320
TMPPTC                         $005f   958D  2114   2118   2307y  2311
                                      2313   2315y  2323   2326   2384y
                                      2582   2582   2583y  2588y  2597y
                                      2603y  2606y  2741y  2748y  2751y
                                      2780y  2783y  2786y  2787   2788
                                      3122   3125   4718   4721   4729y
                                      4733y  4739   4798   4798   4814y
                                      4817y  4820y  4822y  4824y  4826y
                                      4828y  4831   4834   4849   4850
                                      4946   4947   4955y  4960y  4965y
                                      4967   4970y  4971   4997y  5008y
                                      5015y  5026y  5042y  5045y  5082
                                      5084y  5087   5088y  5099y  5112y
                                      5117y  5179y  5182y  5549   5549
                                      5676   5679   5683   5684   5716
                                      5718   7190   7199   7207   7208
                                      7242   7275
FAC1M1/FAC1M2                  $0062   963D  2873   2874   4191   4191
                                      4457   4571   4605y  5242   5396
                                      5414   5414   5472   5890y  6272
                                      6287   6290   6326   6328   6337
                                      6357   6378   6380   6406   6550
                                      6738   6784   6816   6843   6889
                                      6986   6995   7049   7106   7107
                                      7108   7136   7312   7442   7444
                                      7780   7802   7804    964D  3402
                                      4454   4572   5243   5397   5474
                                      6269   6289   6292   6323   6325
                                      6336   6358   6381   6383   6404
                                      6548   6741   6781   6818   6838
                                      6884   6988   7053   7137   7313
                                      7439   7441   7786   7805   7807
JIFFY                          $0000     8D   829   1144   8042   8297
                                      8408   8420   8428   8436   8467
                                      8520   8596   8694   8987   9706
                                      9727   9991  10283  10297  10302
                                     10314  10321  10333  10369  10376
                                     10589  10758  10772  10858  11037
                                     11069  11088  11094  11132  11828
                                     11970  12003  12119  12193  12206
                                     12248  12444  12651  12660  12674
                                     12960  12967  12994  13009  13016
                                     13024  13062  13094  13104  13233
                                     13397  13465  13699  16493  16666
                                     17610  18263
STRPTR/FAC1M5                  $006f   983D  3454   3454   4225   5413
                                      5413   5419y  5436   5438   5444
                                      5452   5452   5744   5744   5746y
                                      5759   5759   5769y  5772y  5775y
                                      6189   6249   6616   6652   6688
                                      6710   7264   7710   8159    988D
                                      4398   5478   6211   6238   6244
                                      6260   6295   6297   6316   6333
                                      6361   6390   6392   6393   6429
                                      6448   6542   6590   6800   6847
                                      6894   6915   6935   6946   7011
                                      7061   7121   7656   7704   7814
FAC1EX                         $0061   962D  2194   3229   3376   3456
                                      3456   4192   4228   4570   4580
                                      4584   4890   5398   5434   5470
                                      6112   6190   6223   6226   6233
                                      6251   6308   6342   6346   6355
                                      6503   6507   6623   6638   6647
                                      6690   6728   6729   6731   6846
                                      6892   6912   6931   6944   6961
                                      7010   7045   7080   7093   7117
                                      7127   7265   7342   7627   7678
                                      7698   7699   7813   7816   8237
TMPPTD                         $0071   990D  2493   2514   3380   3383
                                      3384   3394   4408   5005   5021
                                      5047   5048   5066   5067   5077
                                      5102   5105   5130   5131   5143
                                      5146   5202   5203   5437   5443
                                      6060   6060   6088   6088   7339
                                      7410   7421   7466   7478   7490
                                      7719   7719   7731   7731   7738y
                                      7740   7744   7747   7748   7752
                                      7752   7759   7759
INDEXB/FAC3                    $0024   825D  2312   2319   2331   2342y
                                      2346   3977   6065   6072   6074y
                                      6077y  6082y  7026   7036   7038y
                                      7042y  7047y  7052y  7056y  7062y
                                       827D  5159   5180   5188   5207
                                      5210   6422   6538   6539   6540
                                      6541   6572   6574   6575   6577
                                      6578   6580   6581   6583   6586
                                      6587   6588   6589   6754   6815
                                      6817   6819   6821
FAC1SI                         $0066   967D  2871   3377   3983   4169
                                      4224   4588   4596   4881   6110
                                      6185   6187   6228   6311   6370
                                      6372   6615   6653   6660   6841
                                      6887   6907   6965   7012   7019
                                      7043   7069   7084   7104   7122
                                      7123   7263   7332   7338   7629
                                      7631   7812   8163   8167   8201
                                      8231
FORPNT                         $0049   911D  2077   2080   2082   2087
                                      2761   2766   2819   2891   2891
                                      3138   3330   3330   3353y  3356y
                                      3369   3463y  3466y  3469y  3811
                                      3811   3960   3960   3984   3985
                                      6149   6156   6161   6162   6869
                                      6869   8027   8052   8058   8101
                                      8110   8112   8123   8124
TMPPTA                         $0058   949D  2132   2134   2136   2141y
                                      2147y  2151   2359   2365   4807
                                      4807   4809   4809   4855   4855
                                      5052   5054   5057   5072y  5076
                                      5079   5163   5166   5577   5577
                                      5582   5582   5601   5602   5605
                                      5606   5625   5627   5722   5722
                                      5726   5729   5730
FUNCPT                         $004e   925D  5307   5307   5315   5315
                                      5318   5318   5320y  5324y  5337y
                                      5340y  5344   5344   5355y  5358y
                                      5361y  5364y  5367y  5546   5547
                                      5686   5686   5707   5708   5715y
                                      5727y  5732y  7599   7600   7605
                                      7605   7616   7616   8195   8196
                                      8204   8204
LINNUM                         $0014   807D  2375   2375   2587   2595
                                      2729   2730   2735   2736   2752
                                      2754   3104   3106   3281   3282
                                      3288   3303   3308   3309   3311
                                      3312   3313   3314   3315   3317
                                      3319   6118   6119   6126   6126
                                      6129y  6131   6131   6141y  6160y
                                      7908
EAL                            $00ae  1086D  9660   9662   9763   9765
                                      9797   9799   9867y  9879   9888
                                     12989  12999  13004  13006  13061y
                                     13079y 13083  13085  13308  13311
                                     13325  13326  13375  13376  15239
                                     15239  15256  15259  15283  15283
                                     15307  15311  16410  16412
SAL                            $00ac  1085D  9656   9658   9677   9767
                                      9769   9793   9795   9810   9858
                                      9865y  9878   9880  13419  13421
                                     13427y 15959y 15971  15973  15984
                                     15987  15996y 16015y 16052y 16071
                                     16073  16270  16279y 16409  16411
                                     16419  16421
CSRIDX                         $00d3  1277D  8778   8783   8860   8865
                                      8872   9023   9040   9060   9082
                                      9176   9178   9235   9246   9256
                                      9271   9312   9355   9364   9385
                                      9433   9455   9480   9484   9504
                                      9551   9563   9583   9944   9973
                                     11975
CMPO                           $00b0  1087D 15420  15563  15564  15568
                                     15570  15571  15573  15578  15580
                                     15593  15656  15667  15668  15670
                                     15672  15673  15679  15690  15691
                                     15695  15696  15699  15700  15722
                                     15770  15774  15821  15824  15825
TBLX                           $00d6  1308D  8777   8782   8861   8864
                                      9027   9187   9191   9192   9232
                                      9244   9253   9359   9376   9380
                                      9477   9479   9529   9540   9572
                                      9593   9596   9667   9703   9759
                                      9776   9789  11977
FRESPC                         $0033   851D  2173   2176   2200   2203
                                      2661   2661   3427   3432   5230
                                      5233   5498   5499   5511   5511
                                      5543   5544   5669   5672   5721
                                      5721   5845   5847   5851   5852
                                      5854   8375   8375
CHRGET                         $0073   994D  2280   2722   2885   2939
                                      2961   2976   3267   3322   3606
                                      3703   3839   4014   4093   4245
                                      4261   4350   4485   4667   4676
                                      4702   4873   6032   7167   7177
                                      7193   8355
TXTTAB                         $002b   835D  2400   2400   2575   2575
                                      2626y  2628y  2629   2633   2698
                                      2701   2986   2988   3117   3117
                                      7933   7953   7953   8371   8371
                                      8378y  8379   8381   8390   8390
                                      8395   8398
SA                             $00b9  1129D 12316  12329  12368  12380
                                     12491  12514  12582  12637  12639
                                     12673  12727  12749  12769  12975
                                     12982  12986  13291  13403  13415
                                     13449  13453  13520  13531  16804
TAPE1                          $00b2  1094D 12094y 12238y 12244y 12732y
                                     13283y 13286y 13296y 13298y 13301y
                                     13303y 15194y 15213y 15244y 15248y
                                     15251y 15254y 15257y 15260y 15272y
                                     15294  15294  15330y 16574  16575
CURLIN                         $0039   866D  2255   2287   2866   2866
                                      2919   2922   3019   3023   3023
                                      3059   3059   3086   3086   3103
                                      3105   3158   3158   3679   3679
                                      3995   3997   5265   7305   7306
VARTAB                         $002d   839D  2309   2317   2318   2320
                                      2322   2327   2356   2360   2379
                                      2379   2632   2635   2662   2662
                                      3437   3441   4715   4715   5563
                                      5563   7932   7932   7997   7997
SLLTBL                         $00d9  1353D  8836   8847   8868   8892
                                      9198   9199   9202   9204   9223
                                      9538   9678   9687   9689   9694
                                      9698   9700   9701   9780   9811
                                      9822   9824   9829   9897
STAL                           $00c1  1150D 13313  13315  13379  13381
                                     15238  15238  15250  15253  15284
                                     15284  15304  15309  16070  16072
                                     16580  16583  16586y 16589y 16590y
                                     16593y 16594y 16597y 16605
CHRGOT                         $0079   995D  2718   2882   3092   3222
                                      3240   3499   3816   3882   3893
                                      3917   4011   4078   4631   4640
                                      4653   4931   5345   5950   6048
                                      6078   6151   8072   8089
FAC2M3/FAC2M4                  $006c   977D  4221   4221   4573   4576
                                      4604y  6321   6576   6608   6743
                                      6765   6777   6779    978D  4574
                                      4577   6318   6573   6605   6746
                                      6764   6774   6776
VARNAM                         $0045   900D  4394   4394   4652   4695
                                      4696   4705   4728   4731   4779
                                      4779   4813   4816   4916   4916
                                      4918   4918   4957   4959   5007
                                      5014   5148   5153
STREND                         $0031   847D  2106   2106   2378   2378
                                      2664   2664   4799   4799   4948
                                      4950   5064   5064   5081   5085
                                      5231   5234   5504   5507   5548
                                      5548   5585   5587
COUNT                          $000b   736D  2300   2358   2380   2495
                                      2511   2553   4529   4532   4535
                                      4540   4542   4545   4547   4846
                                      4934   4995   5022   5050   5100
                                      5144
ROPRTY                         $00bd  1139D 11345  11346  11362  11380
                                     11416  15862  15911  15958  15994
                                     16014  16059  16100  16216  16218
                                     16230  16261  16272  16280  16291
DESCPT                         $0050   929D  3453   3453   3459   3459
                                      3462y  3465y  3468y  5389   5389
                                      5756   5756   5900y  5905y  5918
                                      5918   5940y  5964y  5985   5985
STATUS                         $0090  1001D 11239  12106  12339  12390
                                     12557  12765  12772  12950  12990
                                     13043  13044  13052  13088  13272
                                     15406  16840  16846  16847
IOPMPT                         $0013   799D  2234   3490   3535   3544
                                      3643   3685   3707   3717   3728
                                      3736   3741   3765   3776   3785
                                      3828   3934   8281   8362
LINPTR                         $00d1  1271D  9012y  9061y  9317y  9319y
                                      9330y  9430y  9447y  9449y  9458y
                                      9866y  9896   9900   9916y  9945y
                                      9954   9956   9976
PTR1                           $009e  1065D 11663  12243  12265  15235
                                     15247  15264  15267  15273  15323
                                     15332  15334  15421  15968  15970
                                     15977  15982  16040
VALTYP                         $000d   749D  3335   3519   3840   4040
                                      4102   4132   4242   4395   4567
                                      4665   4685   4909   4937   5223
                                      5241   5480   6007
BITTS                          $00b4  1100D 11335  11347  11369  11372
                                     11376  11392  11419  15419  15707
                                     15732  15794  15807  15830  15844
                                     15851
VARPNT                         $0047   906D  4839   4839   5164   5167
                                      5169   5293   5293   5321   5326
                                      5330y  5334   5342   5342   7465
                                      7479
CHARAC                         $0007   720D  3195   3201   3202   3287
                                      3316   3847   3852   3856   4533
                                      4546   5406   5421   7129   7609
                                      7687
LASTKY                         $00d7  1313D  9065   9067   9068   9105
                                      9110   9264   9272  15729  15779
                                     15798  16253  16271  16281  16282
MEMUSS                         $00c3  1151D 12941  12941  13003  13005
                                     13284  13287  13307  13310  13312
                                     13314  16489  16489  16500y 16504
FNLEN                          $00b7  1126D 12704  12756  12783  12791
                                     12823  12965  13259  13339  13345
                                     13353  13404  15268  15326  16793
FAC2EX                         $0069   974D  4219   4560   4560   6213
                                      6214   6252   6254   6622   6630
                                      6911   6932   7594   7697   7700
TMPPTB                         $005a   950D  2113   2117   2123   2126
                                      2128   2140y  2146y  2150   2357
                                      2361   4800   4800   5717   5720
COLS                           $0028   643D  8766   8838   8871   8888
                                      8895   9216   9374   9383   9482
                                      9566   9580   9586   9862   9907
FA                             $00ba  1130D 12306  12353  12407  12580
                                     12641  12767  12951  12984  13388
                                     13413  13451  16803  16811
RIPRTY                         $00ab  1084D  8556  11489  11490  11562
                                     15280  15444  15928  16049  16053
                                     16054  16058  16318  16323
ROWS                           $0019   644D  8767   8844   8848   9188
                                      9533   9594   9674   9696   9698
                                      9700   9783   9801   9817
USER                           $00f3  1364D  8561y  9321y  9323y  9332y
                                      9451y  9453y  9460y  9868y  9947y
                                      9955   9959   9981
LINLEN                         $00d5  1303D  8900   9008   9177   9206
                                      9217   9255   9325   9357   9377
                                      9429   9442  11989
INBIT                          $00a7  1080D 11488  11491  11501  11527
                                     11561  15880  15909  15952  16038
                                     16305  16315  17170
TMPVA2                         $005e   957D  4406   7203   7212   7217
                                      7223   7229   7271   7283   7292
                                      7403   7502   7507
TMPVA1                         $005d   956D  4410   5190   5215   7153
                                      7216   7244   7358   7374   7379
                                      7388   7404   7471
ARYTAB                         $002f   843D  2663   2663   4722   4724
                                      4797   4797   4811   4811   4942
                                      4943   5567   5569
ENDCHR                         $0008   721D  2476   2537   2542   3197
                                      3200   3205   3210   3863   4536
                                      4541   5407   5423
R6510                          $0001   635D 10029  10042  10068  15377
                                     15379  15489  15496  16127  16134
                                     16392  16394  16711
RODATA                         $00b6  1111D 11338  11424  15865  15907
                                     15962  15965  15999  16002  16145
                                     16175  16330
RIDATA                         $00aa  1083D 11492  11545  11587  15418
                                     15884  15897  15919  15922  15925
                                     15933  16025
FAC2M1                         $006a   975D  4220   4220   4558   4559
                                      6327   6582   6619   6737   6767
                                      6783   6785
QUOTE                          $0022   684D  2477   2771   3213   3748
                                      3853   4272   5405   5427   5462
                                      9123   9128
NDX                            $00c6  1173D  8955   8957   8973   8996
                                      9755  10246  10258  10263  11939
                                     13641
RINONE                         $00a9  1082D  8554  11483  11515  15713
                                     15717  15783  15864  16086  16187
                                     16195
BITCI                          $00a8  1081D 11485  11498  11506  15709
                                     15834  15863  16084  16163  16173
                                     17204
CNTDN                          $00a5  1078D 10910  10943  11140  11181
                                     11197  11202  11234  16243  16254
                                     16328
TSFCNT                         $00a3  1076D 10757  10764  10809  15686
                                     15753  15796  15811  16081  16231
                                     16232
PTR2                           $009f  1066D 15262  15271  15274  15321
                                     15329  15333  15422  15981  15990
                                     15991
FAC2SI                         $006e   979D  4223   4556   6188   6227
                                      6614   6617   6901   7262   7602
                                      8154
MEMSIZ                         $0037   860D  2660   2660   5539   5540
                                      7833   7834   8374   8374   8393
                                      8397
GARBFL                         $000f   770D  2463   2479   2529   2740
                                      2773   2775   2814   5492   5519
                                      5523
FSBLK                          $00be  1147D 15486  15878  15888  16032
                                     16035  16042  16255  16299  16324
VERCKK                         $0093  1027D 12948  13057  13364  15187
                                     15191  15407  15955  15992  16011
INPPTR                         $0043   898D  3807   3807   3814   3814
                                      3890   3890   3924   3925   3932
OLDTXT                         $003d   878D  2687   2904   2904   3022
                                      3022   3051   3056   3692   3692
CSRMOD                         $00d4  1297D  9024   9074   9125   9127
                                      9161   9336   9425   9550
TBTCNT                         $00a4  1077D 11219  11250  15725  15727
                                     15749  16083  16205  16207
DFLTN                          $0099  1044D  8929   9091  11706  11937
                                     11969  12322  12604  12611
FACTPA                         $0057   948D  2186   6861   6862   7721
                                      7724   7724   8198   8198
FUNJMP                         $0055   938D  4511   4513   5688   5710
                                      5714   5724   5980   5986
ACCSYM                         $004d   919D  4075   4089   4090   4092
                                      4097   4142   4159   4568
TXPTR                          $00f9  1395D 11423y 11665y 12433  12440
                                     12911  12914  12915
RXPTR                          $00f7  1390D 11556y 11778y 12428  12439
                                     12904  12907  12908
INSRTO                         $00d8  1330D  9147   9149   9159   9297
                                      9461   9467   9548
FNADR                          $00bb  1138D 12788y 12825y 13350y 15270y
                                     15328y 16794  16795
NXTBIT                         $00b5  1106D 11353  11417  15848  15886
                                     15905  15937  16993
JIFFYM                         $00a1  1074D  8573  13562  13570  13576
                                     13613  13622  15219
PRTY                           $009b  1058D 15760  15792  15793  16085
                                     16220  16221  16289
DFLTO                          $009a  1048D  8927   9094  11600  12155
                                     12373  12599  12609
LDTND                          $0098  1040D 12535  12536  12538  12564
                                     12592  12628  12634
FAC2M2                         $006b   976D  6324   6579   6611   6740
                                      6766   6780   6782
SUBFLG                         $0010   776D  2688   2844   4691   4707
                                      4714   5286   5305
INTFLG                         $000e   755D  3333   3878   4422   4666
                                      4694   4907   4939
KBDPTR                         $00f5  1384D 10133  10135  10164y 10209y
                                     10327  10329
ICRROW                         $00c9  1203D  8909   9025   9034   9528
                                      9668  11978
BUFPNT                         $00a6  1079D 12066  12090  12240  12737
                                     15348  15349
MSGFLG                         $009d  1060D 11914  13335  13549  13684
                                     15206  16837
FAC2M5                         $0056   943D  6212   6232   6259   6315
                                      7676   7703
YSAVE                          $004b   917D  3813   3813   3891   3891
                                      4125   4212
UTLSTP                         $0035   856D  5512   5512   5796y  5803
                                      5804   5806
TEMPPT                         $0016   812D  2677   5461   5485   5555
                                      5871   8368
TANSGN                         $0012   788D  4217   4615   8169   8171
                                      8193   8202
DIMFLG                         $000c   743D  4646   4906   4941   4992
                                      5031   5089
INSRC                          $00d0  1266D  9009   9053   9089   9270
                                     11988
BLNON                          $00cf  1261D  8809   8978   8983   9974
                                      9978
JIFFYL                         $00a2  1075D 13560  13568  13577  13612
                                     13621
JIFFYH                         $00a0  1073D 13564  13572  13575  13614
                                     13623
TEMPX                          $0097  1033D 11957  11959  12055  12067
                                     12078
SYNO                           $0096  1032D 15787  15805  15832  15836
                                     15847
BSOUR                          $0095  1030D 10768  10925  11003  11024
                                     11077
FAC1OV                         $0068   970D  6436   7088   7097   7110
                                      8361
GARBSS                         $0053   931D  5562   5579   5687   5691
                                      8359
LASTPT                         $0017   817D  5481   5867   5869   5873
                                      8363
INPFLG                         $0011   787D  3669   3806   3818   3842
                                      3926
PAL                            $0001     9D  8506  10659  16774  16780
                                     17132
BLNCT                          $00cd  1245D  8822   9936   9969   9972
SFDX                           $00cb  1231D 10117  10174  10208  10251
INDX                           $00c8  1189D  9020   9041   9084  11990
RVS                            $00c7  1183D  9140   9343   9495   9549
LA                             $00b8  1128D 12578  12618  12635  16802
TK_MINUS                       $00ab  1673D  2712   2720   4268   7179
DPSW                           $009c  1059D 15423  15681  15829  15875
C3PO                           $0094  1028D 10754  10763  11061  11064
SVXT                           $0092  1026D 15723  15724  15767  15778
RNDX                           $008b   999D  7793   7793   7818   7819
SGNFLG                         $0067   969D  7159   7233   7739   7762
DATPTR                         $0041   892D  2993   2993   3796   3796
DATLIN                         $003f   886D  3676   3676   3909   3913
OLDLIN                         $003b   871D  3024   3024   3058   3058
BASSTO                         $00ff  1397D  5381   5381   7337
TK_PI                          $00ff  1713D  2468   2812   4257
GDBLN                          $00ce  1254D  8980   9979   9984
BLNSW                          $00cc  1238D  8823   8974   9967
CAS1                           $00c0  1149D 10039  10053  15503
TK_SGN                         $00b4  1686D  4312   4510   4512
STKEY                          $0091  1014D  8570  13602  13631
TK_GOSUB                       $008d  1633D  3087   3141   3253
FACTPB                         $005c   955D  6854   7761   7761
TEMPST                         $0019   818D  2676   5550   8367
IEC_CLK_BIT                    $0010   670D 10941  11260  11269
CR                             $000d   682D  2439   3542   9006
VERCK                          $000a   735D  7950   7952   7956
ICRCOL                         $00ca  1204D  9039  11976
LSTX                           $00c5  1152D 10211  10252
MYCH                           $00bf  1148D 15799  15861
TK_EQUAL                       $00b2  1681D  3331   5290
TK_PLUS                        $00aa  1672D  4270   7183
TK_FN                          $00a5  1663D  4307   5302
TK_TO                          $00a4  1662D  2867   2977
TK_TAB                         $00a3  1661D  2953   3509
TK_GOTO                        $0089  1629D  3223   3257
TK_DATA                        $0083  1622D  2525   3919
TK_FOR                         $0081  1620D  2075   2892
STND_COL                       $007f   632D  9743  10266
JUMPER                         $0054   936D  4514   8343
COLMAX                         $0050   646D  9180   9437
SEMIC                          $003b   685D  3516   3751
IEC_DAT_BIT                    $0020   671D 11280  11289
TRMPOS                         $0009   722D  3585   3592
IEC_ATN_BIT                    $0008   668D 10783  11092
ADRAY2                         $0005   711D  8348   8348
ADRAY1                         $0003   703D  8350   8350
COLINK                         $0002   645D  9559   9579
CTRL_ROW                       $00fb   630D  9725
COLRAM_PAGE                    $00d8   647D  9958
TK_GO                          $00cb  1712D  2974
TK_CHRS                        $00c7  1707D  4486
TK_GT                          $00b1  1680D  4082
TK_STEP                        $00a9  1668D  2883
TK_NOT                         $00a8  1667D  4289
TK_THEN                        $00a7  1665D  3225
TK_SPC                         $00a6  1664D  3511
TK_PRINT                       $0099  1647D  2483
TK_REM                         $008f  1635D  2533
ISNUM                          $0080   997D  3411
CTRL_COL                       $007f   629D  9722
VIC_REGS                       $002f   426D  8935
Default_Color                  $000e   648D  8817
LF                             $000a   683D  3546
RS232_C_BIT                    $0004   672D 11352
IEC_IFR_BIT                    $0002   669D 11167
D6510                          $0000   634D 16713
TK_MIDS                        $00ca  1711
TK_RIGHTS                      $00c9  1710
TK_LEFTS                       $00c8  1709
TK_ASC                         $00c6  1706
TK_VAL                         $00c5  1705
TK_STRS                        $00c4  1704
TK_LEN                         $00c3  1703
TK_PEEK                        $00c2  1702
TK_ATN                         $00c1  1701
TK_TAN                         $00c0  1700
TK_SIN                         $00bf  1698
TK_COS                         $00be  1697
TK_EXP                         $00bd  1696
TK_LOG                         $00bc  1695
TK_RND                         $00bb  1694
TK_SQR                         $00ba  1693
TK_POS                         $00b9  1692
TK_FRE                         $00b8  1691
TK_USR                         $00b7  1689
TK_ABS                         $00b6  1688
TK_INT                         $00b5  1687
TK_LT                          $00b3  1682
TK_OR                          $00b0  1679
TK_AND                         $00af  1677
TK_POWER                       $00ae  1676
TK_DIV                         $00ad  1675
TK_MUL                         $00ac  1674
TK_NEW                         $00a2  1657
TK_GET                         $00a1  1656
TK_CLOSE                       $00a0  1655
TK_OPEN                        $009f  1653
TK_SYS                         $009e  1652
TK_CMD                         $009d  1651
TK_CLR                         $009c  1650
TK_LIST                        $009b  1649
TK_CONT                        $009a  1648
TK_PRINFL                      $0098  1646
TK_POKE                        $0097  1644
TK_DEF                         $0096  1643
TK_VERIFY                      $0095  1642
TK_SAVE                        $0094  1641
TK_LOAD                        $0093  1640
TK_WAIT                        $0092  1639
TK_ON                          $0091  1638
TK_STOP                        $0090  1637
TK_RETURN                      $008e  1634
TK_RESTORE                     $008c  1632
TK_IF                          $008b  1631
TK_RUN                         $008a  1630
TK_LET                         $0088  1628
TK_READ                        $0087  1626
TK_DIM                         $0086  1625
TK_INPUT                       $0085  1624
TK_INFL                        $0084  1623
TK_NEXT                        $0082  1621
TK_END                         $0080  1619
C64                            $0001     5D   418   1550   1582   1609
                                      1797   2050   2793   3038   3569
                                      7572   7663   7669   7865   7964
                                      8004   8277   8306   8419   8458
                                      8519   8877   8905   9028   9200
                                      9629   9707   9837   9882   9912
                                      9926  10013  10028  10041  10056
                                     10067  10081  10123  10137  10145
                                     10153  10187  10199  10288  10404
                                     10430  10456  10487  10503  10524
                                     10541  10563  10723  10769  10790
                                     10864  10888  10917  10954  11011
                                     11038  11047  11085  11115  11145
                                     11158  11171  11189  11209  11225
                                     11238  11273  11309  11404  11444
                                     11512  11530  11610  11636  11651
                                     11662  11668  11686  11718  11738
                                     11768  11774  11783  11795  11815
                                     11829  11940  12130  12137  12177
                                     12203  12207  12264  12281  12416
                                     12460  12484  12496  12500  12750
                                     12757  12763  12795  12809  12836
                                     12846  12883  12891  12922  12974
                                     13000  13176  13196  13214  13225
                                     13237  13502  13586  13632  13865
                                     14114  14129  14139  14149  14157
                                     14356  14363  14371  14379  14500
                                     14515  14536  14615  14635  14718
                                     14755  14814  14823  14934  14986
                                     15163  15218  15375  15424  15455
                                     15467  15475  15488  15494  15525
                                     15586  15598  15660  15735  15750
                                     15812  15837  15852  16026  16123
                                     16133  16144  16174  16329  16340
                                     16347  16391  16438  16470  16553
                                     16577  16667  16690  16756  16815
                                     16820  16935  16957  16964  16984
                                     17027  17036  17043  17061  17072
                                     17098  17118  17163  17252  18410
INDEXA                         $0022   824D  2115   2125   2133   2163
                                      2165   2229   2231   2240y  2308
                                      2310   2335   2337   2341y  2345
                                      2401   2401   2406y  2412y  2416
                                      2419y  2420   2423y  2424   2425
                                      2876   2876   3289   3305   3307
                                      3310   3410y  3631y  4108   4110
                                      4178   4179   4181   4194   5049
                                      5139   5178   5552   5552   5564
                                      5564   5592   5592   5594y  5597y
                                      5600y  5604y  5612y  5616   5617
                                      5619   5622   5638y  5641y  5662y
                                      5665y  5668y  5685   5685   5693
                                      5694   5696   5699   5783   5783
                                      5795y  5830   5830   5834y  5837y
                                      5840y  5860   5860   5924   5925
                                      5927   6018y  6061   6064   6066
                                      6602   6602   6604y  6607y  6610y
                                      6613y  6621y  6829   6829   6831y
                                      6834y  6837y  6840y  6845y  6876
                                      6876   6879y  6882y  6885y  6890y
                                      6893y  7777   7777   7779y  7782y
                                      7785y  7788y  8137   8138
FAC1M3/FAC1M4                  $0064   965D  3352   3401   3426y  3431y
                                      3440   3445   3451y  4190   4190
                                      4302   4375   4381   4393   4393
                                      4425y  4428y  4453   4475   4475
                                      4494   4494   4531   4544   4865
                                      4926   5109   5136   5388   5388
                                      5477   5477   5741   5741   5748y
                                      5824   5824   6045   6116   6266
                                      6291   6294   6320   6322   6335
                                      6359   6384   6386   6402   6546
                                      6744   6778   6820   6835   6881
                                      7005   7057   7138   7436   7438
                                      7783   7806   7808    966D  3261
                                      3355   3403   3436   3446   4299
                                      4377   4383   4455   4534   4539
                                      4866   4928   5111   5142   5949
                                      5967   5969   6047   6117   6263
                                      6293   6296   6317   6319   6334
                                      6360   6387   6389   6400   6544
                                      6747   6775   6822   6832   6878
                                      7004   7063   7128   7139   7432
                                      7435   7789   7801   7803
TXTPTR                         $007a   996D  2279   2279   2461   2497
                                      2552   2566   2568   2700   2703
                                      2861   2863   2900   2900   2908y
                                      2911y  2918y  2921y  2924   2925
                                      2927   3018   3018   3057   3057
                                      3085   3085   3110   3111   3124
                                      3127   3159   3159   3175   3176
                                      3178   3208y  3693   3693   3812
                                      3812   3815   3815   3836   3836
                                      3845   3864   3864   3889   3889
                                      3892   3892   3905y  3908y  3911y
                                      3999   4001   4058   4060   4063
                                      4135   4137   4140   4279   4279
                                      4348y  5294   5294   5336   5336
                                      5338   5341   5350   5350   6059
                                      6059   6062   6067   6089   6089
                                      7287y  7973   7992   8318   8320
TMPPTC                         $005f   958D  2114   2118   2307y  2311
                                      2313   2315y  2323   2326   2384y
                                      2582   2582   2583y  2588y  2597y
                                      2603y  2606y  2741y  2748y  2751y
                                      2780y  2783y  2786y  2787   2788
                                      3122   3125   4718   4721   4729y
                                      4733y  4739   4798   4798   4814y
                                      4817y  4820y  4822y  4824y  4826y
                                      4828y  4831   4834   4849   4850
                                      4946   4947   4955y  4960y  4965y
                                      4967   4970y  4971   4997y  5008y
                                      5015y  5026y  5042y  5045y  5082
                                      5084y  5087   5088y  5099y  5112y
                                      5117y  5179y  5182y  5549   5549
                                      5676   5679   5683   5684   5716
                                      5718   7190   7199   7207   7208
                                      7242   7275
FAC1M1/FAC1M2                  $0062   963D  2873   2874   4191   4191
                                      4457   4571   4605y  5242   5396
                                      5414   5414   5472   5890y  6272
                                      6287   6290   6326   6328   6337
                                      6357   6378   6380   6406   6550
                                      6738   6784   6816   6843   6889
                                      6986   6995   7049   7106   7107
                                      7108   7136   7312   7442   7444
                                      7780   7802   7804    964D  3402
                                      4454   4572   5243   5397   5474
                                      6269   6289   6292   6323   6325
                                      6336   6358   6381   6383   6404
                                      6548   6741   6781   6818   6838
                                      6884   6988   7053   7137   7313
                                      7439   7441   7786   7805   7807
JIFFY                          $0000     8D   829   1144   8042   8297
                                      8408   8420   8428   8436   8467
                                      8520   8596   8694   8987   9706
                                      9727   9991  10283  10297  10302
                                     10314  10321  10333  10369  10376
                                     10589  10758  10772  10858  11037
                                     11069  11088  11094  11132  11828
                                     11970  12003  12119  12193  12206
                                     12248  12444  12651  12660  12674
                                     12960  12967  12994  13009  13016
                                     13024  13062  13094  13104  13233
                                     13397  13465  13699  16493  16666
                                     17610  18263
STRPTR/FAC1M5                  $006f   983D  3454   3454   4225   5413
                                      5413   5419y  5436   5438   5444
                                      5452   5452   5744   5744   5746y
                                      5759   5759   5769y  5772y  5775y
                                      6189   6249   6616   6652   6688
                                      6710   7264   7710   8159    988D
                                      4398   5478   6211   6238   6244
                                      6260   6295   6297   6316   6333
                                      6361   6390   6392   6393   6429
                                      6448   6542   6590   6800   6847
                                      6894   6915   6935   6946   7011
                                      7061   7121   7656   7704   7814
FAC1EX                         $0061   962D  2194   3229   3376   3456
                                      3456   4192   4228   4570   4580
                                      4584   4890   5398   5434   5470
                                      6112   6190   6223   6226   6233
                                      6251   6308   6342   6346   6355
                                      6503   6507   6623   6638   6647
                                      6690   6728   6729   6731   6846
                                      6892   6912   6931   6944   6961
                                      7010   7045   7080   7093   7117
                                      7127   7265   7342   7627   7678
                                      7698   7699   7813   7816   8237
TMPPTD                         $0071   990D  2493   2514   3380   3383
                                      3384   3394   4408   5005   5021
                                      5047   5048   5066   5067   5077
                                      5102   5105   5130   5131   5143
                                      5146   5202   5203   5437   5443
                                      6060   6060   6088   6088   7339
                                      7410   7421   7466   7478   7490
                                      7719   7719   7731   7731   7738y
                                      7740   7744   7747   7748   7752
                                      7752   7759   7759
INDEXB/FAC3                    $0024   825D  2312   2319   2331   2342y
                                      2346   3977   6065   6072   6074y
                                      6077y  6082y  7026   7036   7038y
                                      7042y  7047y  7052y  7056y  7062y
                                       827D  5159   5180   5188   5207
                                      5210   6422   6538   6539   6540
                                      6541   6572   6574   6575   6577
                                      6578   6580   6581   6583   6586
                                      6587   6588   6589   6754   6815
                                      6817   6819   6821
FAC1SI                         $0066   967D  2871   3377   3983   4169
                                      4224   4588   4596   4881   6110
                                      6185   6187   6228   6311   6370
                                      6372   6615   6653   6660   6841
                                      6887   6907   6965   7012   7019
                                      7043   7069   7084   7104   7122
                                      7123   7263   7332   7338   7629
                                      7631   7812   8163   8167   8201
                                      8231
FORPNT                         $0049   911D  2077   2080   2082   2087
                                      2761   2766   2819   2891   2891
                                      3138   3330   3330   3353y  3356y
                                      3369   3463y  3466y  3469y  3811
                                      3811   3960   3960   3984   3985
                                      6149   6156   6161   6162   6869
                                      6869   8027   8052   8058   8101
                                      8110   8112   8123   8124
TMPPTA                         $0058   949D  2132   2134   2136   2141y
                                      2147y  2151   2359   2365   4807
                                      4807   4809   4809   4855   4855
                                      5052   5054   5057   5072y  5076
                                      5079   5163   5166   5577   5577
                                      5582   5582   5601   5602   5605
                                      5606   5625   5627   5722   5722
                                      5726   5729   5730
FUNCPT                         $004e   925D  5307   5307   5315   5315
                                      5318   5318   5320y  5324y  5337y
                                      5340y  5344   5344   5355y  5358y
                                      5361y  5364y  5367y  5546   5547
                                      5686   5686   5707   5708   5715y
                                      5727y  5732y  7599   7600   7605
                                      7605   7616   7616   8195   8196
                                      8204   8204
LINNUM                         $0014   807D  2375   2375   2587   2595
                                      2729   2730   2735   2736   2752
                                      2754   3104   3106   3281   3282
                                      3288   3303   3308   3309   3311
                                      3312   3313   3314   3315   3317
                                      3319   6118   6119   6126   6126
                                      6129y  6131   6131   6141y  6160y
                                      7908
STACK                          $0100  1399D  2074   2079   2081   2085
                                      2088   3982   3992   3994   3996
                                      3998   4000   4922   4924   4927
                                      4929   7413   7418   7470   7475
                                      7492   7512   7514   7524   7526
                                      7528   7532   7536   7539   7539
                                     15972  15974  15985  15988  17245
EAL                            $00ae  1086D  9660   9662   9763   9765
                                      9797   9799   9867y  9879   9888
                                     12989  12999  13004  13006  13061y
                                     13079y 13083  13085  13308  13311
                                     13325  13326  13375  13376  15239
                                     15239  15256  15259  15283  15283
                                     15307  15311  16410  16412
SAL                            $00ac  1085D  9656   9658   9677   9767
                                      9769   9793   9795   9810   9858
                                      9865y  9878   9880  13419  13421
                                     13427y 15959y 15971  15973  15984
                                     15987  15996y 16015y 16052y 16071
                                     16073  16270  16279y 16409  16411
                                     16419  16421
CSRIDX                         $00d3  1277D  8778   8783   8860   8865
                                      8872   9023   9040   9060   9082
                                      9176   9178   9235   9246   9256
                                      9271   9312   9355   9364   9385
                                      9433   9455   9480   9484   9504
                                      9551   9563   9583   9944   9973
                                     11975
CMPO                           $00b0  1087D 15420  15563  15564  15568
                                     15570  15571  15573  15578  15580
                                     15593  15656  15667  15668  15670
                                     15672  15673  15679  15690  15691
                                     15695  15696  15699  15700  15722
                                     15770  15774  15821  15824  15825
BUF                            $0200  1401D  2353   2376   2377   2383
                                      2441   2466   2505   2519   2520
                                      2540   2547   2561   2565   2901
                                      3532   3533   3534   3711   3712
                                      3714   3761   3774   3821   3822
                                      3823   7993   8365   8366
TBLX                           $00d6  1308D  8777   8782   8861   8864
                                      9027   9187   9191   9192   9232
                                      9244   9253   9359   9376   9380
                                      9477   9479   9529   9540   9572
                                      9593   9596   9667   9703   9759
                                      9776   9789  11977
FRESPC                         $0033   851D  2173   2176   2200   2203
                                      2661   2661   3427   3432   5230
                                      5233   5498   5499   5511   5511
                                      5543   5544   5669   5672   5721
                                      5721   5845   5847   5851   5852
                                      5854   8375   8375
CHRGET                         $0073   994D  2280   2722   2885   2939
                                      2961   2976   3267   3322   3606
                                      3703   3839   4014   4093   4245
                                      4261   4350   4485   4667   4676
                                      4702   4873   6032   7167   7177
                                      7193   8355
TXTTAB                         $002b   835D  2400   2400   2575   2575
                                      2626y  2628y  2629   2633   2698
                                      2701   2986   2988   3117   3117
                                      7933   7953   7953   8371   8371
                                      8378y  8379   8381   8390   8390
                                      8395   8398
SA                             $00b9  1129D 12316  12329  12368  12380
                                     12491  12514  12582  12637  12639
                                     12673  12727  12749  12769  12975
                                     12982  12986  13291  13403  13415
                                     13449  13453  13520  13531  16804
TAPE1                          $00b2  1094D 12094y 12238y 12244y 12732y
                                     13283y 13286y 13296y 13298y 13301y
                                     13303y 15194y 15213y 15244y 15248y
                                     15251y 15254y 15257y 15260y 15272y
                                     15294  15294  15330y 16574  16575
CURLIN                         $0039   866D  2255   2287   2866   2866
                                      2919   2922   3019   3023   3023
                                      3059   3059   3086   3086   3103
                                      3105   3158   3158   3679   3679
                                      3995   3997   5265   7305   7306
VARTAB                         $002d   839D  2309   2317   2318   2320
                                      2322   2327   2356   2360   2379
                                      2379   2632   2635   2662   2662
                                      3437   3441   4715   4715   5563
                                      5563   7932   7932   7997   7997
SLLTBL                         $00d9  1353D  8836   8847   8868   8892
                                      9198   9199   9202   9204   9223
                                      9538   9678   9687   9689   9694
                                      9698   9700   9701   9780   9811
                                      9822   9824   9829   9897
STAL                           $00c1  1150D 13313  13315  13379  13381
                                     15238  15238  15250  15253  15284
                                     15284  15304  15309  16070  16072
                                     16580  16583  16586y 16589y 16590y
                                     16593y 16594y 16597y 16605
CHRGOT                         $0079   995D  2718   2882   3092   3222
                                      3240   3499   3816   3882   3893
                                      3917   4011   4078   4631   4640
                                      4653   4931   5345   5950   6048
                                      6078   6151   8072   8089
FAC2M3/FAC2M4                  $006c   977D  4221   4221   4573   4576
                                      4604y  6321   6576   6608   6743
                                      6765   6777   6779    978D  4574
                                      4577   6318   6573   6605   6746
                                      6764   6774   6776
VARNAM                         $0045   900D  4394   4394   4652   4695
                                      4696   4705   4728   4731   4779
                                      4779   4813   4816   4916   4916
                                      4918   4918   4957   4959   5007
                                      5014   5148   5153
STREND                         $0031   847D  2106   2106   2378   2378
                                      2664   2664   4799   4799   4948
                                      4950   5064   5064   5081   5085
                                      5231   5234   5504   5507   5548
                                      5548   5585   5587
COUNT                          $000b   736D  2300   2358   2380   2495
                                      2511   2553   4529   4532   4535
                                      4540   4542   4545   4547   4846
                                      4934   4995   5022   5050   5100
                                      5144
ROPRTY                         $00bd  1139D 11345  11346  11362  11380
                                     11416  15862  15911  15958  15994
                                     16014  16059  16100  16216  16218
                                     16230  16261  16272  16280  16291
DESCPT                         $0050   929D  3453   3453   3459   3459
                                      3462y  3465y  3468y  5389   5389
                                      5756   5756   5900y  5905y  5918
                                      5918   5940y  5964y  5985   5985
ENABL                          $02a1  1551D 11449  11451  11513  11514
                                     11611  11669  11719  11743  11796
                                     11800  11817  12933  16987  16995
                                     17099  17180  17198  17199
STATUS                         $0090  1001D 11239  12106  12339  12390
                                     12557  12765  12772  12950  12990
                                     13043  13044  13052  13088  13272
                                     15406  16840  16846  16847
IOPMPT                         $0013   799D  2234   3490   3535   3544
                                      3643   3685   3707   3717   3728
                                      3736   3741   3765   3776   3785
                                      3828   3934   8281   8362
LINPTR                         $00d1  1271D  9012y  9061y  9317y  9319y
                                      9330y  9430y  9447y  9449y  9458y
                                      9866y  9896   9900   9916y  9945y
                                      9954   9956   9976
PTR1                           $009e  1065D 11663  12243  12265  15235
                                     15247  15264  15267  15273  15323
                                     15332  15334  15421  15968  15970
                                     15977  15982  16040
VALTYP                         $000d   749D  3335   3519   3840   4040
                                      4102   4132   4242   4395   4567
                                      4665   4685   4909   4937   5223
                                      5241   5480   6007
BITTS                          $00b4  1100D 11335  11347  11369  11372
                                     11376  11392  11419  15419  15707
                                     15732  15794  15807  15830  15844
                                     15851
VARPNT                         $0047   906D  4839   4839   5164   5167
                                      5169   5293   5293   5321   5326
                                      5330y  5334   5342   5342   7465
                                      7479
CHARAC                         $0007   720D  3195   3201   3202   3287
                                      3316   3847   3852   3856   4533
                                      4546   5406   5421   7129   7609
                                      7687
LASTKY                         $00d7  1313D  9065   9067   9068   9105
                                      9110   9264   9272  15729  15779
                                     15798  16253  16271  16281  16282
MEMUSS                         $00c3  1151D 12941  12941  13003  13005
                                     13284  13287  13307  13310  13312
                                     13314  16489  16489  16500y 16504
FNLEN                          $00b7  1126D 12704  12756  12783  12791
                                     12823  12965  13259  13339  13345
                                     13353  13404  15268  15326  16793
FAC2EX                         $0069   974D  4219   4560   4560   6213
                                      6214   6252   6254   6622   6630
                                      6911   6932   7594   7697   7700
TMPPTB                         $005a   950D  2113   2117   2123   2126
                                      2128   2140y  2146y  2150   2357
                                      2361   4800   4800   5717   5720
COLS                           $0028   643D  8766   8838   8871   8888
                                      8895   9216   9374   9383   9482
                                      9566   9580   9586   9862   9907
FA                             $00ba  1130D 12306  12353  12407  12580
                                     12641  12767  12951  12984  13388
                                     13413  13451  16803  16811
RIPRTY                         $00ab  1084D  8556  11489  11490  11562
                                     15280  15444  15928  16049  16053
                                     16054  16058  16318  16323
ROWS                           $0019   644D  8767   8844   8848   9188
                                      9533   9594   9674   9696   9698
                                      9700   9783   9801   9817
RSSTAT                         $0297  1531D 11437  11438  11582  11583
                                     11638  11769  11776  11785  12139
                                     12820  16814  16819
USER                           $00f3  1364D  8561y  9321y  9323y  9332y
                                      9451y  9453y  9460y  9868y  9947y
                                      9955   9959   9981
LINLEN                         $00d5  1303D  8900   9008   9177   9206
                                      9217   9255   9325   9357   9377
                                      9429   9442  11989
INBIT                          $00a7  1080D 11488  11491  11501  11527
                                     11561  15880  15909  15952  16038
                                     16305  16315  17170
TMPVA2                         $005e   957D  4406   7203   7212   7217
                                      7223   7229   7271   7283   7292
                                      7403   7502   7507
TMPVA1                         $005d   956D  4410   5190   5215   7153
                                      7216   7244   7358   7374   7379
                                      7388   7404   7471
ARYTAB                         $002f   843D  2663   2663   4722   4724
                                      4797   4797   4811   4811   4942
                                      4943   5567   5569
ENDCHR                         $0008   721D  2476   2537   2542   3197
                                      3200   3205   3210   3863   4536
                                      4541   5407   5423
R6510                          $0001   635D 10029  10042  10068  15377
                                     15379  15489  15496  16127  16134
                                     16392  16394  16711
RODATA                         $00b6  1111D 11338  11424  15865  15907
                                     15962  15965  15999  16002  16145
                                     16175  16330
RIDATA                         $00aa  1083D 11492  11545  11587  15418
                                     15884  15897  15919  15922  15925
                                     15933  16025
FAC2M1                         $006a   975D  4220   4220   4558   4559
                                      6327   6582   6619   6737   6767
                                      6783   6785
QUOTE                          $0022   684D  2477   2771   3213   3748
                                      3853   4272   5405   5427   5462
                                      9123   9128
CINV                           $0314  1587D 15480  15482  15521  16362
                                     16364  16382  16384  16498  16507
                                     17250
NDX                            $00c6  1173D  8955   8957   8973   8996
                                      9755  10246  10258  10263  11939
                                     13641
RINONE                         $00a9  1082D  8554  11483  11515  15713
                                     15717  15783  15864  16086  16187
                                     16195
BITCI                          $00a8  1081D 11485  11498  11506  15709
                                     15834  15863  16084  16163  16173
                                     17204
CNTDN                          $00a5  1078D 10910  10943  11140  11181
                                     11197  11202  11234  16243  16254
                                     16328
TSFCNT                         $00a3  1076D 10757  10764  10809  15686
                                     15753  15796  15811  16081  16231
                                     16232
PTR2                           $009f  1066D 15262  15271  15274  15321
                                     15329  15333  15422  15981  15990
                                     15991
FAC2SI                         $006e   979D  4223   4556   6188   6227
                                      6614   6617   6901   7262   7602
                                      8154
MEMSIZ                         $0037   860D  2660   2660   5539   5540
                                      7833   7834   8374   8374   8393
                                      8397
GARBFL                         $000f   770D  2463   2479   2529   2740
                                      2773   2775   2814   5492   5519
                                      5523
FSBLK                          $00be  1147D 15486  15878  15888  16032
                                     16035  16042  16255  16299  16324
VERCKK                         $0093  1027D 12948  13057  13364  15187
                                     15191  15407  15955  15992  16011
INPPTR                         $0043   898D  3807   3807   3814   3814
                                      3890   3890   3924   3925   3932
OLDTXT                         $003d   878D  2687   2904   2904   3022
                                      3022   3051   3056   3692   3692
CSRMOD                         $00d4  1297D  9024   9074   9125   9127
                                      9161   9336   9425   9550
TBTCNT                         $00a4  1077D 11219  11250  15725  15727
                                     15749  16083  16205  16207
DFLTN                          $0099  1044D  8929   9091  11706  11937
                                     11969  12322  12604  12611
FACTPA                         $0057   948D  2186   6861   6862   7721
                                      7724   7724   8198   8198
FUNJMP                         $0055   938D  4511   4513   5688   5710
                                      5714   5724   5980   5986
ACCSYM                         $004d   919D  4075   4089   4090   4092
                                      4097   4142   4159   4568
SCROWM                         $02a5  1555D  9669   9704   9782   9787
                                      9806   9820   9834
COLOR                          $0286  1412D  8560   8818   9152   9331
                                      9459   9615   9983
TXPTR                          $00f9  1395D 11423y 11665y 12433  12440
                                     12911  12914  12915
RXPTR                          $00f7  1390D 11556y 11778y 12428  12439
                                     12904  12907  12908
INSRTO                         $00d8  1330D  9147   9149   9159   9297
                                      9461   9467   9548
FNADR                          $00bb  1138D 12788y 12825y 13350y 15270y
                                     15328y 16794  16795
NXTBIT                         $00b5  1106D 11353  11417  15848  15886
                                     15905  15937  16993
JIFFYM                         $00a1  1074D  8573  13562  13570  13576
                                     13613  13622  15219
PRTY                           $009b  1058D 15760  15792  15793  16085
                                     16220  16221  16289
DFLTO                          $009a  1048D  8927   9094  11600  12155
                                     12373  12599  12609
LDTND                          $0098  1040D 12535  12536  12538  12564
                                     12592  12628  12634
FAC2M2                         $006b   976D  6324   6579   6611   6740
                                      6766   6780   6782
SUBFLG                         $0010   776D  2688   2844   4691   4707
                                      4714   5286   5305
INTFLG                         $000e   755D  3333   3878   4422   4666
                                      4694   4907   4939
IRQTMP                         $029f  1548D 15481  15483  15520  15554
                                     16360  16363
BAUDOF                         $0299  1543D 11682  11684  17173  17176
                                     17217  17220
M51AJB                         $0295  1529D 12858  12859  12862  17191
                                     17193  17212
M51CDR                         $0294  1513D 11358  11400  11558  11601
                                     11707  12880
KBDPTR                         $00f5  1384D 10133  10135  10164y 10209y
                                     10327  10329
ICRROW                         $00c9  1203D  8909   9025   9034   9528
                                      9668  11978
BUFPNT                         $00a6  1079D 12066  12090  12240  12737
                                     15348  15349
MSGFLG                         $009d  1060D 11914  13335  13549  13684
                                     15206  16837
FAC2M5                         $0056   943D  6212   6232   6259   6315
                                      7676   7703
YSAVE                          $004b   917D  3813   3813   3891   3891
                                      4125   4212
UTLSTP                         $0035   856D  5512   5512   5796y  5803
                                      5804   5806
TEMPPT                         $0016   812D  2677   5461   5485   5555
                                      5871   8368
TANSGN                         $0012   788D  4217   4615   8169   8171
                                      8193   8202
DIMFLG                         $000c   743D  4646   4906   4941   4992
                                      5031   5089
M51CTR                         $0293  1483D 11370  11467  11503  12826
                                     12834
MODE                           $0291  1468D  8808  10279  10522  10536
                                     10539
SHFLAG                         $028d  1439D 10115  10169  10170  10253
                                     10274
OSSTAR                         $0281  1409D 16609  16886  16887  16892
                                     16892
KBUFFR                         $0277  1408D  8948   8952   8953   9000
                                     10261
FILTBL                         $0259  1405D 12539  12540  12569  12577
                                     12636
INSRC                          $00d0  1266D  9009   9053   9089   9270
                                     11988
BLNON                          $00cf  1261D  8809   8978   8983   9974
                                      9978
JIFFYL                         $00a2  1075D 13560  13568  13577  13612
                                     13621
JIFFYH                         $00a0  1073D 13564  13572  13575  13614
                                     13623
TEMPX                          $0097  1033D 11957  11959  12055  12067
                                     12078
SYNO                           $0096  1032D 15787  15805  15832  15836
                                     15847
BSOUR                          $0095  1030D 10768  10925  11003  11024
                                     11077
FAC1OV                         $0068   970D  6436   7088   7097   7110
                                      8361
GARBSS                         $0053   931D  5562   5579   5687   5691
                                      8359
LASTPT                         $0017   817D  5481   5867   5869   5873
                                      8363
INPFLG                         $0011   787D  3669   3806   3818   3842
                                      3926
PAL                            $0001     9D  8506  10659  16774  16780
                                     17132
RODBE                          $029e  1547D 11421  11656  11660  12901
RODBS                          $029d  1546D 11420  11425  11658  12902
RIDBS                          $029c  1545D 11541  11771  11779  12900
RIDBE                          $029b  1544D 11539  11543  11772  12899
BITNUM                         $0298  1542D 11418  11546  12833  17203
KRPTDL                         $028c  1420D  8816  10214  10236  10238
SCNMPG                         $0288  1414D  8829   9857   9899  16611
OSTOP                          $0283  1410D 16867  16868  16874  16875
SECATB                         $026d  1407D 12543  12544  12581  12640
DEVTBL                         $0263  1406D 12541  12542  12579  12642
BLNCT                          $00cd  1245D  8822   9936   9969   9972
SFDX                           $00cb  1231D 10117  10174  10208  10251
INDX                           $00c8  1189D  9020   9041   9084  11990
RVS                            $00c7  1183D  9140   9343   9495   9549
LA                             $00b8  1128D 12578  12618  12635  16802
TK_MINUS                       $00ab  1673D  2712   2720   4268   7179
DPSW                           $009c  1059D 15423  15681  15829  15875
C3PO                           $0094  1028D 10754  10763  11061  11064
SVXT                           $0092  1026D 15723  15724  15767  15778
RNDX                           $008b   999D  7793   7793   7818   7819
SGNFLG                         $0067   969D  7159   7233   7739   7762
DATPTR                         $0041   892D  2993   2993   3796   3796
DATLIN                         $003f   886D  3676   3676   3909   3913
OLDLIN                         $003b   871D  3024   3024   3058   3058
IERROR                         $0300  1559D  2219   8286   8453
TVSFLG                         $02a6  1556D 12847  16757  17264
TD1IRQ                         $02a4  1554D 15601  15739  15751
AUTODN                         $0292  1481D  8975   9022   9182
KEYLOG                         $028f  1462D  8811   8813  10203
KRPTSP                         $028b  1419D  8820  10242  10245
CSRCLR                         $0287  1413D  8981   9975   9982
BASSTO                         $00ff  1397D  5381   5381   7337
TK_PI                          $00ff  1713D  2468   2812   4257
GDBLN                          $00ce  1254D  8980   9979   9984
BLNSW                          $00cc  1238D  8823   8974   9967
CAS1                           $00c0  1149D 10039  10053  15503
TK_SGN                         $00b4  1686D  4312   4510   4512
STKEY                          $0091  1014D  8570  13602  13631
TK_GOSUB                       $008d  1633D  3087   3141   3253
FACTPB                         $005c   955D  6854   7761   7761
TEMPST                         $0019   818D  2676   5550   8367
IEC_CLK_BIT                    $0010   670D 10941  11260  11269
CR                             $000d   682D  2439   3542   9006
VERCK                          $000a   735D  7950   7952   7956
TBUFFR                         $033c  1605D 16572  16573
USRVEC                         $0311  1584D  8346   8346
Basic_USR                      $0310  1583D  1854   8344
SPREG                          $030f  1580D  7902   7922
SYREG                          $030e  1579D  7906   7920
SXREG                          $030d  1578D  7905   7919
SAREG                          $030c  1577D  7904   7918
TRDTMP                         $02a3  1553D 15664  15736
TODSNS                         $02a2  1552D 15472  15599
LSTSHF                         $028e  1452D 10254  10277
KBMAXL                         $0289  1415D  8815  10259
ICRCOL                         $00ca  1204D  9039  11976
LSTX                           $00c5  1152D 10211  10252
MYCH                           $00bf  1148D 15799  15861
TK_EQUAL                       $00b2  1681D  3331   5290
TK_PLUS                        $00aa  1672D  4270   7183
TK_FN                          $00a5  1663D  4307   5302
TK_TO                          $00a4  1662D  2867   2977
TK_TAB                         $00a3  1661D  2953   3509
TK_GOTO                        $0089  1629D  3223   3257
TK_DATA                        $0083  1622D  2525   3919
TK_FOR                         $0081  1620D  2075   2892
STND_COL                       $007f   632D  9743  10266
JUMPER                         $0054   936D  4514   8343
COLMAX                         $0050   646D  9180   9437
SEMIC                          $003b   685D  3516   3751
IEC_DAT_BIT                    $0020   671D 11280  11289
TRMPOS                         $0009   722D  3585   3592
IEC_ATN_BIT                    $0008   668D 10783  11092
ADRAY2                         $0005   711D  8348   8348
ADRAY1                         $0003   703D  8350   8350
COLINK                         $0002   645D  9559   9579
BASIC_RAM_START                $0800   675D 16608
BASIC_SCREEN                   $0400   674D 16610
ISAVE                          $0332  1603D 13382
ILOAD                          $0330  1602D 12942
ICLALL                         $032c  1600D 18311
IGETIN                         $032a  1599D 18294
ISTOP                          $0328  1598D 18266
IBSOUT                         $0326  1597D 18122
IBASIN                         $0324  1596D 18085
ICLRCH                         $0322  1595D 18033
ICKOUT                         $0320  1594D 18005
ICHKIN                         $031e  1593D 17968
ICLOSE                         $031c  1592D 17929
IOPEN                          $031a  1591D 17902
NMINV                          $0318  1589D 16924
CBINV                          $0316  1588D 17248
IEVAL                          $030a  1564D  4235
IGONE                          $0308  1563D  2933
IQPLOP                         $0306  1562D  2805
ICRNCH                         $0304  1561D  2455
IMAIN                          $0302  1560D  2272
KEYRPT                         $028a  1416D 10219
STIMOT                         $0285  1411D 16854
CTRL_ROW                       $00fb   630D  9725
COLRAM_PAGE                    $00d8   647D  9958
TK_GO                          $00cb  1712D  2974
TK_CHRS                        $00c7  1707D  4486
TK_GT                          $00b1  1680D  4082
TK_STEP                        $00a9  1668D  2883
TK_NOT                         $00a8  1667D  4289
TK_THEN                        $00a7  1665D  3225
TK_SPC                         $00a6  1664D  3511
TK_PRINT                       $0099  1647D  2483
TK_REM                         $008f  1635D  2533
ISNUM                          $0080   997D  3411
CTRL_COL                       $007f   629D  9722
VIC_REGS                       $002f   426D  8935
Default_Color                  $000e   648D  8817
LF                             $000a   683D  3546
RS232_C_BIT                    $0004   672D 11352
IEC_IFR_BIT                    $0002   669D 11167
D6510                          $0000   634D 16713
USRCMD                         $032e  1601
TK_MIDS                        $00ca  1711
TK_RIGHTS                      $00c9  1710
TK_LEFTS                       $00c8  1709
TK_ASC                         $00c6  1706
TK_VAL                         $00c5  1705
TK_STRS                        $00c4  1704
TK_LEN                         $00c3  1703
TK_PEEK                        $00c2  1702
TK_ATN                         $00c1  1701
TK_TAN                         $00c0  1700
TK_SIN                         $00bf  1698
TK_COS                         $00be  1697
TK_EXP                         $00bd  1696
TK_LOG                         $00bc  1695
TK_RND                         $00bb  1694
TK_SQR                         $00ba  1693
TK_POS                         $00b9  1692
TK_FRE                         $00b8  1691
TK_USR                         $00b7  1689
TK_ABS                         $00b6  1688
TK_INT                         $00b5  1687
TK_LT                          $00b3  1682
TK_OR                          $00b0  1679
TK_AND                         $00af  1677
TK_POWER                       $00ae  1676
TK_DIV                         $00ad  1675
TK_MUL                         $00ac  1674
TK_NEW                         $00a2  1657
TK_GET                         $00a1  1656
TK_CLOSE                       $00a0  1655
TK_OPEN                        $009f  1653
TK_SYS                         $009e  1652
TK_CMD                         $009d  1651
TK_CLR                         $009c  1650
TK_LIST                        $009b  1649
TK_CONT                        $009a  1648
TK_PRINFL                      $0098  1646
TK_POKE                        $0097  1644
TK_DEF                         $0096  1643
TK_VERIFY                      $0095  1642
TK_SAVE                        $0094  1641
TK_LOAD                        $0093  1640
TK_WAIT                        $0092  1639
TK_ON                          $0091  1638
TK_STOP                        $0090  1637
TK_RETURN                      $008e  1634
TK_RESTORE                     $008c  1632
TK_IF                          $008b  1631
TK_RUN                         $008a  1630
TK_LET                         $0088  1628
TK_READ                        $0087  1626
TK_DIM                         $0086  1625
TK_INPUT                       $0085  1624
TK_INFL                        $0084  1623
TK_NEXT                        $0082  1621
TK_END                         $0080  1619
