ca65 V2.16 - Git 9a8b7d9
Main file   : C64-LeeV3mod.a65
Current file: C64-LeeV3mod.a65

000000r 1               
000000r 1               ;******************************************************************************
000000r 1               ;******************************************************************************
000000r 1               ;
000000r 1               ;          The almost completely commented C64 ROM disassembly for
000000r 1               ;
000000r 1               ;              the BASIC ROM 901226-01 and Kernal ROM 901227-03
000000r 1               ;
000000r 1               ;               based on Lee Davison's version V1.01 from 2012
000000r 1               ;
000000r 1               ;
000000r 1               ; Changes by Ruud Baltissen:
000000r 1               ; - I splitted the original file in four parts so one can use only those parts
000000r 1               ;   (s)he can use for her/his projects
000000r 1               ; - addapted to his own assembler, MP-ASM
000000r 1               ; - changed names of routines and variables, LAzB_xx and LAzB_xxxx,
000000r 1               ;   into more logical ones
000000r 1               ; - length of lines < 81 (if possible)
000000r 1               ; - combined low and high bytes to one variable
000000r 1               
000000r 1               ; Many references were used to complete this disassembly including, but not
000000r 1               ; limited to, "Mapping the Vic 20", "Mapping the C64", "C64 Programmers
000000r 1               ; reference", "C64 user guide", "The complete Commodore inner space anthology",
000000r 1               ; "VIC Revealed" and various text files, pictures and other documents.
000000r 1               
000000r 1               KERNAL=3
000000r 1               
000000r 1               .include "C64-var.a65"
000000r 2               ;******************************************************************************
000000r 2               ;******************************************************************************
000000r 2               ;
000000r 2               ; The almost completely commented C64 ROM disassembly. V1.01 Lee Davison 2012
000000r 2               
000000r 2               ;******************************************************************************
000000r 2               ;******************************************************************************
000000r 2               ;
000000r 2               ; first a whole load of equates
000000r 2               
000000r 2               D6510		= $00		; 6510 I/O port data direction register
000000r 2               					; bit	default
000000r 2               					; ---	-------
000000r 2               					;  7	unused
000000r 2               					;  6	unused
000000r 2               					;  5	1 = output
000000r 2               					;  4	0 = input
000000r 2               					;  3	1 = output
000000r 2               					;  2	1 = output
000000r 2               					;  1	1 = output
000000r 2               					;  0	1 = output
000000r 2               
000000r 2               P6510		= $01		; 6510 I/O port data register
000000r 2               					; bit	name		function
000000r 2               					; ---	----		--------
000000r 2               					;  7	unused
000000r 2               					;  6	unused
000000r 2               					;  5	cass motor 1 = off, 0 = on
000000r 2               					;  4	cass sw	   1 = off, 0 = on
000000r 2               					;  3	cass data
000000r 2               					;  2	CHAREN     1 = I/O,
000000r 2               					;		   0 = chraracter ROM
000000r 2               					;  1	HIRAM 	1 = Kernal,	0 = RAM
000000r 2               					;  0	LORAM	1 = BASIC,	0 = RAM
000000r 2               
000000r 2               ZP02		= $02		; unused
000000r 2               
000000r 2               
000000r 2               ; This vector points to the address of the BASIC routine which converts a
000000r 2               ; floating point number to an integer, however BASIC does not use this vector.
000000r 2               ; It may be of assistance to the programmer who wishes to use data that is;
000000r 2               ; stored in floating point format. The parameter passed by the USR command is
000000r 2               ; available only in that format for example.
000000r 2               ;
000000r 2               ADRAY1		= $03		; float to fixed vector
000000r 2               ; ... $04
000000r 2               
000000r 2               
000000r 2               ; This vector points to the address of the BASIC routine which converts an
000000r 2               ; integer to a floating point number, however BASIC does not use this vector.
000000r 2               ; It may be used by the programmer who needs to make such a conversion for a
000000r 2               ; machine language program that interacts with BASIC.  To return an integer
000000r 2               ; value with the USR command for example.
000000r 2               ;
000000r 2               ADRAY2		= $05		; fixed to float vector
000000r 2               ; ... $06
000000r 2               
000000r 2               
000000r 2               ; These locations hold searched for characters when BASIC is searching for the
000000r 2               ; end of a srting or crunching BASIC lines
000000r 2               ;
000000r 2               CHARAC		= $07		; search character
000000r 2               ENDCHR		= $08		; scan quotes flag
000000r 2               
000000r 2               
000000r 2               ; The cursor column position prior to the TAB or SPC is moved here from $D3,
000000r 2               ; and is used to calculate where the cursor ends up after one of these
000000r 2               ; functions is invoked.
000000r 2               ;
000000r 2               ; Note that the value contained here shows the position of the cursor on a
000000r 2               ; logical line. Since one logical line can be up to four physical lines long,
000000r 2               ; the value stored here can range from 0 to 87.
000000r 2               ;
000000r 2               TRMPOS		= $09		; TAB column save
000000r 2               
000000r 2               
000000r 2               ; The routine that converts the text in the input buffer into lines of
000000r 2               ; executable program tokes, and the routines that link these program lines
000000r 2               ; together, use this location as an index into the input buffer area. After the
000000r 2               ; job of converting text to tokens is done, the value in this location is equal
000000r 2               ; to the length of the tokenized line.
000000r 2               ;
000000r 2               ; The routines which build an array or locate an element in an array use this
000000r 2               ; location to calculate the number of DIMensions called for and the amount of
000000r 2               ; storage required for a newly created array, or the number of subscripts when
000000r 2               ; referencing an array element.
000000r 2               ;
000000r 2               LoadVerify		= $0A		; load/verify flag, 0 = load, 1 = verify
000000r 2               COUNT		= $0B		; temporary byte, line crunch/array
000000r 2               					; access/logic operators
000000r 2               
000000r 2               ; This is used as a flag by the routines that build an array or reference an
000000r 2               ; existing array. It is used to determine whether a variable is in an array,
000000r 2               ; whether the array has already been DIMensioned, and whether a new array
000000r 2               ; should assume the default size.
000000r 2               ;
000000r 2               DIMFLG		= $0C		; DIM flag
000000r 2               
000000r 2               
000000r 2               ; This flag is used to indicate whether data being operated upon is string or
000000r 2               ; numeric. A value of $FF in this location indicates string data while a $00
000000r 2               ; indicates numeric data.
000000r 2               ;
000000r 2               VALTYP		= $0D		; data type flag, $FF = string,
000000r 2               					;		  $00 = numeric
000000r 2               
000000r 2               ; If the above flag indicates numeric then a $80 in this location identifies
000000r 2               ; the number as an integer, and a $00 indicates a floating point number.
000000r 2               ;
000000r 2               INTFLG		= $0E		; data type flag, $80 = integer,
000000r 2               					;		  $00 = floating point
000000r 2               
000000r 2               ; The garbage collection routine uses this location as a flag to indicate that
000000r 2               ; garbage collection has already been tried before adding a new string. If
000000r 2               ; there is still not; enough memory, an OUT OF MEMORY error message will
000000r 2               ; result.
000000r 2               ;
000000r 2               ; LIST uses this byte as a flag to let it know when it has come to a character
000000r 2               ; string in quotes. It will then print the string,rather than search it for
000000r 2               ; BASIC keyword tokens.
000000r 2               ;
000000r 2               ; This location is also used during the process of converting a line of text in
000000r 2               ; the BASIC input buffer into a linked program line of BASIC keyword tokens to
000000r 2               ; flag a DATA line is being processed.
000000r 2               ;
000000r 2               GARBFL		= $0F		; garbage collected/open quote/DATA flag
000000r 2               
000000r 2               
000000r 2               ; If an opening parenthesis is found, this flag is set to indicate that the
000000r 2               ; variable in; question is either an array variable or a user-defined function.
000000r 2               ;
000000r 2               SUBFLG		= $10		; subscript/FNx flag
000000r 2               
000000r 2               
000000r 2               ; This location is used to determine whether the sign of the value returned by
000000r 2               ; the functions SIN, COS, ATN or TAN is positive or negative.
000000r 2               ;
000000r 2               ; Also the comparison routines use this location to indicate the outcome of the
000000r 2               ; compare. For A <=> B the value here will be $01 if A > B, $02 if A = B, and
000000r 2               ; $04 if A < B. If more than one comparison operator was used to compare the
000000r 2               ; two variables then the value here will be a combination of the above values.
000000r 2               ;
000000r 2               INPFLG		= $11		; input mode flag, $00 = INPUT,
000000r 2               					; $40 = GET, $98 = READ
000000r 2               TANSGN		= $12		; ATN sign/comparison evaluation flag
000000r 2               
000000r 2               
000000r 2               ; When the default input or output device is used the value here will be a
000000r 2               ; zero, and the format of prompting and output will be the standard screen
000000r 2               ; output format. The location $B8 is used to decide what device actually to
000000r 2               ; put input from or output to.
000000r 2               ;
000000r 2               CurIoChan		= $13		; current I/O channel
000000r 2               
000000r 2               
000000r 2               ; Used whenever a 16 bit integer is used e.g. the target line number for GOTO,
000000r 2               ; LIST, ON, and GOSUB also the number of a BASIC line that is to be added or
000000r 2               ; replaced. additionally PEEK, POKE, WAIT, and SYS use this location as a
000000r 2               ; pointer to the address which is the subject of the command.
000000r 2               ;
000000r 2               LINNUM		= $14		; temporary integer
000000r 2               ; ... $15
000000r 2               
000000r 2               LINNUMJ		= $0014		; used with SYS: JMP ($0014)
000000r 2               
000000r 2               
000000r 2               ; This location points to the next available slot in the temporary string
000000r 2               ; descriptor stack located at $19-$21.
000000r 2               ;
000000r 2               TEMPPT		= $16		; descriptor stack pointer, next free
000000r 2               
000000r 2               
000000r 2               ; This contains information about temporary strings which have not yet been
000000r 2               ; assigned to a string variable.
000000r 2               ;
000000r 2               LASTPT		= $17		; current descriptor stack item
000000r 2               ; ... $18
000000r 2               
000000r 2               TEMST		= $19		; stack for temporary strings
000000r 2               ; ... $21
000000r 2               
000000r 2               ; These locations are used by BASIC multiplication and division routines. They
000000r 2               ; are also used by the routines which compute the size of the area required to
000000r 2               ; store an array which is being created.
000000r 2               ;
000000r 2               INDEX		= $22		; misc temp byte
000000r 2               ; ... $25
000000r 2               
000000r 2               RESHO		= $26		; temp mantissa 1
000000r 2               ; ... $29
000000r 2               
000000r 2               
000000r 2               ; Two byte pointer to where the BASIC program text is stored.
000000r 2               ;
000000r 2               TXTTAB		= $2B		; start of memory
000000r 2               ; ... $2C
000000r 2               
000000r 2               
000000r 2               ; Two byte pointer to the start of the BASIC variable storage area.
000000r 2               ;
000000r 2               VARTAB		= $2D		; start of variables
000000r 2               ; ... $2E
000000r 2               
000000r 2               
000000r 2               ; Two byte pointer to the start of the BASIC array storage area.
000000r 2               ;
000000r 2               ARYTAB		= $2F		; end of variables
000000r 2               ; ... $30
000000r 2               
000000r 2               
000000r 2               ; Two byte pointer to end of the start of free RAM.
000000r 2               ;
000000r 2               STREND		= $31		; end of arrays
000000r 2               ; ... $32
000000r 2               
000000r 2               
000000r 2               ; Two byte pointer to the bottom of the string text storage area.
000000r 2               ;
000000r 2               FRETOP		= $33		; bottom of string space
000000r 2               ; ... $34
000000r 2               
000000r 2               
000000r 2               ; Used as a temporary pointer to the most current string added by the routines
000000r 2               ; which build strings or move them in memory.
000000r 2               ;
000000r 2               FRESPC		= $35		; string utility ptr
000000r 2               ; ... $36
000000r 2               
000000r 2               
000000r 2               ; Two byte pointer to the highest address used by BASIC +1.
000000r 2               ;
000000r 2               MEMSIZ		= $37		; end of memory
000000r 2               ; ... $38
000000r 2               
000000r 2               
000000r 2               ; These locations contain the line number of the BASIC statement which is
000000r 2               ; currently being executed. A value of $FF in location $3A means that BASIC is
000000r 2               ; in immediate mode.
000000r 2               ;
000000r 2               CURLIN		= $39		; current line number
000000r 2               ; ... $3A
000000r 2               
000000r 2               
000000r 2               ; When program execution ends or stops the last line number executed is stored
000000r 2               ; here.
000000r 2               ;
000000r 2               OLDLIN		= $3B		; break line number
000000r 2               ; ... $3C
000000r 2               
000000r 2               
000000r 2               ; These locations contain the address of the start of the text of the BASIC
000000r 2               ; statement that is being executed.  The value of the pointer to the address of
000000r 2               ; the BASIC text character currently being scanned is stored here each time a
000000r 2               ; new BASIC statement begins execution.
000000r 2               ;
000000r 2               OLDTXT		= $3D		; continue pointer
000000r 2               ; ... $3E
000000r 2               
000000r 2               
000000r 2               ; These locations hold the line number of the current DATA statement being
000000r 2               ; READ. If an error concerning the DATA occurs this number will be moved to
000000r 2               ; $39/$3A so that the error message will show the line that contains the DATA
000000r 2               ; statement rather than in the line that contains the READ statement.
000000r 2               ;
000000r 2               DATLIN		= $3F		; current DATA line number
000000r 2               ; ... $40
000000r 2               
000000r 2               
000000r 2               ; These locations point to the address where the next DATA will be READ from.
000000r 2               ; RESTORE; sets this pointer back to the address indicated by the start of
000000r 2               ; BASIC pointer.
000000r 2               ;
000000r 2               DATPTR		= $41		; DATA pointer
000000r 2               ; ... $42
000000r 2               
000000r 2               
000000r 2               ; READ, INPUT and GET all use this as a pointer to the address of the source of
000000r 2               ; incoming data, such as DATA statements, or the text input buffer.
000000r 2               ;
000000r 2               INPPTR		= $43		; READ pointer
000000r 2               ; ... $44
000000r 2               
000000r 2               VARNAM		= $45		; current variable name
000000r 2               ; ... $46
000000r 2               
000000r 2               
000000r 2               ; These locations point to the value of the current BASIC variable Specifically
000000r 2               ; they point to the byte just after the two-character variable name.
000000r 2               ;
000000r 2               VARPNT		= $47		; current variable address
000000r 2               ; ... $48
000000r 2               
000000r 2               
000000r 2               ; The address of the BASIC variable which is the subject of a FOR/NEXT loop is
000000r 2               ; first stored here before being pushed onto the stack.
000000r 2               ;
000000r 2               FORPNT		= $49		; FOR/NEXT variable pointer
000000r 2               ; ... $4A
000000r 2               
000000r 2               
000000r 2               ; The expression evaluation routine creates this to let it know whether the
000000r 2               ; current comparison operation is a < $01, = $02 or > $04 comparison or
000000r 2               ; combination.
000000r 2               ;
000000r 2               TEMPSTR		= $4B		; BASIC execute pointer temporary
000000r 2               					; /precedence flag
000000r 2               ; ... $4C
000000r 2               ;
000000r 2               CompEvalFlg		= $4D		; comparrison evaluation flag
000000r 2               
000000r 2               
000000r 2               ; These locations are used as a pointer to the function that is created during
000000r 2               ; function definition . During function execution it points to where the
000000r 2               ; evaluation results should be saved.
000000r 2               ;
000000r 2               GarbagePtr		= $4E		; FAC temp store/function/variable
000000r 2               					;   /garbage pointer
000000r 2               ; ... $4F
000000r 2               
000000r 2               
000000r 2               ; Temporary Pointer to the current string descriptor.
000000r 2               ;
000000r 2               TempPtr		= $50		; FAC temp store/descriptor pointer
000000r 2               ; ... $51
000000r 2               
000000r 2               
000000r 2               GarbColStep		= $53		; garbage collection step size
000000r 2               
000000r 2               
000000r 2               ; The first byte is the 6502 JMP instruction $4C, followed by the address of
000000r 2               ; the required function taken from the table at $C052.
000000r 2               ;
000000r 2               Jump0054		= $54		; JMP opcode for functions
000000r 2               					; $0054 normally contains $4C = JMP
000000r 2               ; ... $56
000000r 2               
000000r 2               FacTempStor		= $57		; FAC temp store
000000r 2               ; ... $60
000000r 2               
000000r 2               
000000r 2               ; floating point accumulator 1
000000r 2               ;
000000r 2               FACEXP		= $61		; FAC1 exponent
000000r 2               FacMantissa		= $62		; FAC1 mantissa 1
000000r 2               ; ... $65
000000r 2               FACSGN		= $66		; FAC1 sign
000000r 2               SGNFLG		= $67		; constant count/-ve flag
000000r 2               BITS		= $68		; FAC1 overflow
000000r 2               
000000r 2               
000000r 2               ; floating point accumulator 2
000000r 2               ;
000000r 2               ARGEXP		= $69		; FAC2 exponent
000000r 2               ArgMantissa		= $6A		; FAC2 mantissa 1
000000r 2               ; ... $6D
000000r 2               ARGSGN		= $6E		; FAC2 sign
000000r 2               ARISGN		= $6F		; FAC sign comparrison
000000r 2               FACOV		= $70		; FAC1 rounding
000000r 2               
000000r 2               FBUFPT		= $71		; temp BASIC execute/array pointer
000000r 2               					;   /index
000000r 2               ; ... $72
000000r 2               
000000r 2               
000000r 2               CHRGET		= $73		; increment and scan memory, BASIC byte get
000000r 2               CHRGOT		= $79		; scan memory, BASIC byte get
000000r 2               TXTPTR		= $7A		; BASIC execute pointer
000000r 2               ; ... $7B
000000r 2               
000000r 2               NumericTest		= $80		; numeric test entry
000000r 2               
000000r 2               RND_seed		= $8B		; RND() seed, five bytes
000000r 2               ; ... $8F
000000r 2               
000000r 2               
000000r 2               ; kernal work area
000000r 2               ;
000000r 2               STATUS		= $90		; serial status byte
000000r 2               					;	function
000000r 2               					; bit	casette		serial bus
000000r 2               					; ---	--------	----------
000000r 2               					;  7	end of tape	device not present
000000r 2               					;  6	end of file	EOI
000000r 2               					;  5	checksum error
000000r 2               					;  4	read error
000000r 2               					;  3	long block
000000r 2               					;  2	short block
000000r 2               					;  1			time out read
000000r 2               					;  0			time out write
000000r 2               
000000r 2               
000000r 2               ; This location is updated every 1/60 second during the IRQ routine. The value
000000r 2               ; saved is the keyboard c7 column byte which contains the stop key
000000r 2               ;
000000r 2               StopKey		= $91		; stop key column
000000r 2               					; bit	key, 0 = pressed
000000r 2               					; ---	--------
000000r 2               					;  7	[RUN]
000000r 2               					;  6	Q
000000r 2               					;  5	[CBM]
000000r 2               					;  4	[SP]
000000r 2               					;  3	2
000000r 2               					;  2	[CTL]
000000r 2               					;  1	[LFT]
000000r 2               					;  0	1
000000r 2               
000000r 2               
000000r 2               ; This location is used as an adjustable timing constant for tape reads to
000000r 2               ; allow for slight speed variations on tapes.
000000r 2               ;
000000r 2               SVXT		= $92		; timing constant for tape read
000000r 2               
000000r 2               
000000r 2               ; The same routine is used for both LOAD and VERIFY, the flag here determines
000000r 2               ; which that routine does.
000000r 2               ;
000000r 2               LoadVerify2		= $93		; load/verify flag, load = $00,
000000r 2               					;		    verify = $01
000000r 2               
000000r 2               
000000r 2               ; This location is used to indecate that a serial byte is waiting to be sent.
000000r 2               ;
000000r 2               C3PO		= $94		; serial output: deferred character flag
000000r 2               					; $00 = no character waiting,
000000r 2               					; $xx = character waiting
000000r 2               
000000r 2               
000000r 2               ; This location holds the serial character waiting to be sent. A value of $FF
000000r 2               ; here means no character is waiting.
000000r 2               ;
000000r 2               BSOUR		= $95		; serial output: deferred character
000000r 2               					; $FF = no character waiting,
000000r 2               					; $xx = waiting character
000000r 2               
000000r 2               SYNO		= $96		; cassette block synchronization number
000000r 2               
000000r 2               
000000r 2               ; X register save location for routines that get and put an ASCII character.
000000r 2               ;
000000r 2               TEMP97		= $97		; X register save
000000r 2               
000000r 2               
000000r 2               ; The number of currently open I/O files is stored here. The maximum number
000000r 2               ; that can be open at one time is ten. The number stored here is used as the
000000r 2               ; index to the end of the tables that hold the file numbers, device numbers,
000000r 2               ; and secondary addresses.
000000r 2               ;
000000r 2               LDTND		= $98		; open file count
000000r 2               
000000r 2               
000000r 2               ; The default value of this location is 0, the keyboard.
000000r 2               ;
000000r 2               DFLTN		= $99		; input device number
000000r 2               
000000r 2               
000000r 2               ; The default value of this location is 3, the screen.
000000r 2               ;
000000r 2               DFLTO		= $9A		; output device number
000000r 2               					; number	device
000000r 2               					; ------	------
000000r 2               					;  0		keyboard
000000r 2               					;  1		cassette
000000r 2               					;  2		RS-232C
000000r 2               					;  3		screen
000000r 2               					;  4-31	serial bus
000000r 2               
000000r 2               
000000r 2               PRTY		= $9B		; tape character parity
000000r 2               DPSW		= $9C		; tape byte received flag
000000r 2               
000000r 2               MSGFLG		= $9D		; message mode flag,
000000r 2               					; $C0 = both control and kernal messages,
000000r 2               					; $80 = control messages only = direct mode
000000r 2               					; $40 = kernal messages only,
000000r 2               					; $00 = neither control or kernal messages
000000r 2               					;     = program mode
000000r 2               
000000r 2               PTR1		= $9E		; tape Pass 1 error log/character buffer
000000r 2               
000000r 2               PTR2		= $9F		; tape Pass 1 error log/character index
000000r 2               
000000r 2               
000000r 2               ; These three locations form a counter which is updated 60 times a second, and
000000r 2               ; serves as a software clock which counts the number of jiffies that have
000000r 2               ; elapsed since the computer was turned on. After 24 hours and one jiffy these
000000r 2               ; locations are set back to $000000.
000000r 2               ;
000000r 2               TimeBytes		= $A0		; jiffy clock high byte
000000r 2               ; ... $A2
000000r 2               
000000r 2               
000000r 2               TEMPA3		= $A3		; EOI flag byte/tape bit count
000000r 2               
000000r 2               ; b0 of this location reflects the current phase of the tape output cycle.
000000r 2               ;
000000r 2               TEMPA4		= $A4		; tape bit cycle phase
000000r 2               
000000r 2               
000000r 2               CNTDN		= $A5		; cassette synchronization byte count/
000000r 2               					;   serial bus bit count
000000r 2               BUFPNT		= $A6		; tape buffer index
000000r 2               INBIT		= $A7		; receiver input bit temp storage
000000r 2               BITCI		= $A8		; receiver bit count in
000000r 2               RINONE		= $A9		; receiver start bit check flag,
000000r 2               					; $90 = no start bit
000000r 2               					; received, $00 = start bit received
000000r 2               RIDATA		= $AA		; receiver byte buffer/assembly location
000000r 2               RIPRTY		= $AB		; receiver parity bit storage
000000r 2               
000000r 2               SAL			= $AC		; tape buffer start pointer
000000r 2               					; scroll screen ?? byte
000000r 2               ; ... $AD
000000r 2               
000000r 2               EAL			= $AE		; tape buffer end pointer
000000r 2               					; scroll screen ?? byte
000000r 2               ; ... $AF
000000r 2               CMPO		= $B0		; tape timing constant
000000r 2               ; ... $B1
000000r 2               
000000r 2               
000000r 2               ; Thess two locations point to the address of the cassette buffer. This pointer
000000r 2               ; must be greater than or equal to $0200 or an ILLEGAL DEVICE NUMBER error will
000000r 2               ; be sent when tape I/O is tried. This pointer must also be less that $8000 or
000000r 2               ; the routine will terminate early.
000000r 2               ;
000000r 2               TapeBufPtr		= $B2		; tape buffer start pointer
000000r 2               ; ... $B3
000000r 2               
000000r 2               
000000r 2               ; RS232 routines use this to count the number of bits transmitted and for
000000r 2               ; parity and stop bit manipulation. Tape load routines use this location to
000000r 2               ; flag when they are ready to receive data bytes.
000000r 2               ;
000000r 2               BITTS		= $B4		; transmitter bit count out
000000r 2               
000000r 2               
000000r 2               ; This location is used by the RS232 routines to hold the next bit to be sent
000000r 2               ; and by the tape routines to indicate what part of a block the read routine is
000000r 2               ; currently reading.
000000r 2               ;
000000r 2               NXTBIT		= $B5		; transmitter next bit to be sent
000000r 2               
000000r 2               
000000r 2               ; RS232 routines use this area to disassemble each byte to be sent from the
000000r 2               ; transmission buffer pointed to by $F9.
000000r 2               ;
000000r 2               RODATA		= $B6		; transmitter byte buffer/disassembly
000000r 2               					; location
000000r 2               
000000r 2               ; Disk filenames may be up to 16 characters in length while tape filenames be
000000r 2               ; up to 187 characters in length.
000000r 2               ;
000000r 2               ; If a tape name is longer than 16 characters the excess will be truncated by
000000r 2               ; the SEARCHING and FOUND messages, but will still be present on the tape.
000000r 2               ;
000000r 2               ; A disk file is always referred to by a name. This location will always be
000000r 2               ; greater than zero if the current file is a disk file.
000000r 2               ;
000000r 2               ; An RS232 OPEN command may specify a filename of up to four characters. These
000000r 2               ; characters are copied to locations $293 to $296 and determine baud rate, word
000000r 2               ; length, and parity, or they would do if the feature was fully implemented.
000000r 2               ;
000000r 2               FNLEN		= $B7		; filename length
000000r 2               
000000r 2               LA			= $B8		; logical file
000000r 2               SA			= $B9		; secondary address
000000r 2               FA			= $BA		; current device number
000000r 2               					; number	device
000000r 2               					; ------	------
000000r 2               					;  0		keyboard
000000r 2               					;  1		cassette
000000r 2               					;  2		RS-232C
000000r 2               					;  3		screen
000000r 2               					;  4-31	serial bus
000000r 2               FNADR		= $BB		; filename pointer
000000r 2               ; ... $BC
000000r 2               ROPRTY		= $BD		; tape write byte/RS232 parity byte
000000r 2               
000000r 2               
000000r 2               ; Used by the tape routines to count the number of copies of a data block
000000r 2               ; remaining to be read or written.
000000r 2               ;
000000r 2               FSBLK		= $BE		; tape copies count
000000r 2               
000000r 2               
000000r 2               MYCH		= $BF		; tape parity count
000000r 2               CAS1		= $C0		; tape motor interlock
000000r 2               STAL		= $C1		; I/O start addresses
000000r 2               ; ... $C2
000000r 2               MEMUSS		= $C3		; kernal setup pointer
000000r 2               ; ... $C4
000000r 2               
000000r 2               
000000r 2               LSTX		= $C5		; current key pressed
000000r 2               					;
000000r 2               					;  # key	 # key
000000r 2               					; -- ---	-- ---
000000r 2               					; 00 1		10 none
000000r 2               					; 01 3		11 A
000000r 2               					; 02 5		12 D
000000r 2               					; 03 7		13 G
000000r 2               					; 04 9		14 J
000000r 2               					; 05 +		15 L
000000r 2               					; 06 [UKP]	16 ;
000000r 2               					; 07 [DEL]	17 [CSR R]
000000r 2               					; 08 [<-]	18 [STOP]
000000r 2               					; 09 W		19 none
000000r 2               					; 0A R		1A X
000000r 2               					; 0B Y		1B V
000000r 2               					; 0C I		1C N
000000r 2               					; 0D P		1D ,
000000r 2               					; 0E *		1E /
000000r 2               					; 0F [RET]	1F [CSR D]
000000r 2               
000000r 2               					; 20 [SPACE]	30 Q
000000r 2               					; 21 Z		31 E
000000r 2               					; 22 C		32 T
000000r 2               					; 23 B		33 U
000000r 2               					; 24 M		34 O
000000r 2               					; 25 .		35 @
000000r 2               					; 26 none	36 ^
000000r 2               					; 27 [F1]	37 [F5]
000000r 2               					; 28 none	38 2
000000r 2               					; 29 S		39 4
000000r 2               					; 2A F		3A 6
000000r 2               					; 2B H		3B 8
000000r 2               					; 2C K		3C 0
000000r 2               					; 2D :		3D -
000000r 2               					; 2E =		3E [HOME]
000000r 2               					; 2F [F3]	3F [F7]
000000r 2               
000000r 2               
000000r 2               NDX			= $C6		; keyboard buffer length/index
000000r 2               
000000r 2               
000000r 2               ; When the [CTRL][RVS-ON] characters are printed this flag is set to $12, and
000000r 2               ; the print; routines will add $80 to the screen code of each character which
000000r 2               ; is printed, so that the caracter will appear on the screen with its colours
000000r 2               ; reversed.
000000r 2               ;
000000r 2               ; Note that the contents of this location are cleared not only upon entry of a
000000r 2               ; [CTRL][RVS-OFF] character but also at every carriage return.
000000r 2               ;
000000r 2               RVS			= $C7		; reverse flag $12 = reverse, $00 = normal
000000r 2               
000000r 2               
000000r 2               ; This pointer indicates the column number of the last nonblank character on
000000r 2               ; the logical line that is to be input. Since a logical line can be up to 88
000000r 2               ; characters long this number can range from 0-87.
000000r 2               ;
000000r 2               INDX		= $C8		; input [EOL] pointer
000000r 2               
000000r 2               
000000r 2               ; These locations keep track of the logical line that the cursor is on and its
000000r 2               ; column position on that logical line.
000000r 2               ;
000000r 2               ; Each logical line may contain up to four 22 column physical lines. So there
000000r 2               ; may be as many as 23 logical lines, or as few as 6 at any one time.
000000r 2               ; Therefore, the logical line number might be anywhere from 1-23. Depending on
000000r 2               ; the length of the logical line, the cursor column may be from 1-22, 1-44,
000000r 2               ; 1-66 or 1-88.
000000r 2               ;
000000r 2               ; For a more on logical lines, see the description of the screen line link
000000r 2               ; table, $D9.
000000r 2               ;
000000r 2               CursorRow		= $C9		; input cursor row
000000r 2               CursorCol		= $CA		; input cursor column
000000r 2               
000000r 2               
000000r 2               ; The keyscan interrupt routine uses this location to indicate which key is
000000r 2               ; currently being pressed. The value here is then used as an index into the
000000r 2               ; appropriate keyboard; table to determine which character to print when a key
000000r 2               ; is struck.
000000r 2               ;
000000r 2               ; The correspondence between the key pressed and the number stored here is as
000000r 2               ; follows:
000000r 2               ;
000000r 2               ; $00	1		$10	not used	$20	[SPACE]		$30	Q	$40	[NO KEY]
000000r 2               ; $01	3		$11	A		$21	Z		$31	E	$xx	invalid
000000r 2               ; $02	5		$12	D		$22	C		$32	T
000000r 2               ; $03	7		$13	G		$23	B		$33	U
000000r 2               ; $04	9		$14	J		$24	M		$34	O
000000r 2               ; $05	+		$15	L		$25	.		$35	@
000000r 2               ; $06	[POUND]		$16	;		$26	not used	$36	[U ARROW]
000000r 2               ; $07	[DEL]		$17	[RIGHT]		$27	[F1]		$37	[F5]
000000r 2               ; $08	[L ARROW]	$18	[STOP]		$28	not used	$38	2
000000r 2               ; $09	W		$19	not used	$29	S		$39	4
000000r 2               ; $0A	R		$1A	X		$2A	F		$3A	6
000000r 2               ; $0B	Y		$1B	V		$2B	H		$3B	8
000000r 2               ; $0C	I		$1C	N		$2C	K		$3C	0
000000r 2               ; $0D	P		$1D	,		$2D	:		$3D	-
000000r 2               ; $0E	*		$1E	/		$2E	=		$3E	[HOME]
000000r 2               ; $0F	[RETURN]	$1F	[DOWN]		$2F	[F3]		$3F	[F7]
000000r 2               ;
000000r 2               SFDX		= $CB		; which key
000000r 2               
000000r 2               
000000r 2               ; When this flag is set to a nonzero value, it indicates to the routine that
000000r 2               ; normally flashes the cursor not to do so. The cursor blink is turned off when
000000r 2               ; there are characters in the keyboard buffer, or when the program is running.
000000r 2               ;
000000r 2               BLNSW		= $CC		; cursor enable, $00 = flash cursor
000000r 2               
000000r 2               
000000r 2               ; The routine that blinks the cursor uses this location to tell when it's time
000000r 2               ; for a blink. The number 20 is put here and decremented every jiffy until it
000000r 2               ; reaches zero. Then the cursor state is changed, the number 20 is put back
000000r 2               ; here, and the cycle starts all over again.
000000r 2               ;
000000r 2               BLNCT		= $CD		; cursor timing countdown
000000r 2               
000000r 2               
000000r 2               ; The cursor is formed by printing the inverse of the character that occupies
000000r 2               ; the cursor position. If that characters is the letter A, for example, the
000000r 2               ; flashing cursor merely alternates between printing an A and a reverse-A. This
000000r 2               ; location keeps track of the normal screen code of the character that is
000000r 2               ; located at the cursor position, so that it may be restored when the cursor
000000r 2               ; moves on.
000000r 2               ;
000000r 2               GDBLN		= $CE		; character under cursor
000000r 2               
000000r 2               
000000r 2               ; This location keeps track of whether, during the current cursor blink, the
000000r 2               ; character under the cursor was reversed, or was restored to normal. This
000000r 2               ; location will contain $00 if the character is reversed, and $01 if the
000000r 2               ; character is not reversed.
000000r 2               BLNON		= $CF		; cursor blink phase
000000r 2               
000000r 2               
000000r 2               CRSW		= $D0		; input from keyboard or screen, $xx = input is available
000000r 2               					; from the screen, $00 = input should be obtained from the
000000r 2               					; keyboard
000000r 2               
000000r 2               
000000r 2               ; These locations point to the address in screen RAM of the first column of the
000000r 2               ; logical line upon which the cursor is currently positioned.
000000r 2               ;
000000r 2               CurScrLine		= $D1		; current screen line pointer
000000r 2               ; ... $D2
000000r 2               
000000r 2               
000000r 2               ; This holds the cursor column position within the logical line pointed to by
000000r 2               ; CurScrLine. Since a logical line can comprise up to four physical lines, this
000000r 2               ; value may be from $00 to $57.
000000r 2               ;
000000r 2               LineCurCol		= $D3		; cursor column
000000r 2               
000000r 2               
000000r 2               ; A nonzero value in this location indicates that the editor is in quote mode.
000000r 2               ; Quote mode is toggled every time that you type in a quotation mark on a given
000000r 2               ; line, the first quote mark turns it on, the second turns it off, the third
000000r 2               ; turns it on, etc.
000000r 2               ;
000000r 2               ; If the editor is in this mode when a cursor control character or other
000000r 2               ; nonprinting character is entered, a printed equivalent will appear on the
000000r 2               ; screen instead of the cursor movement or other control operation taking
000000r 2               ; place. Instead, that action is deferred until the string is sent to the
000000r 2               ; string by a PRINT statement, at which time the cursor movement or other
000000r 2               ; control operation will take place.
000000r 2               ;
000000r 2               ; The exception to this rule is the DELETE key, which will function normally
000000r 2               ; within quote mode. The only way to print a character which is equivalent to
000000r 2               ; the DELETE key is by entering insert mode. Quote mode may be exited by
000000r 2               ; printing a closing quote or by hitting the RETURN or SHIFT-RETURN keys.
000000r 2               ;
000000r 2               QTSW		= $D4		; cursor quote flag
000000r 2               
000000r 2               
000000r 2               ; The line editor uses this location when the end of a line has been reached to
000000r 2               ; determine whether another physical line can be added to the current logical
000000r 2               ; line or if a new logical line must be started.
000000r 2               ;
000000r 2               CurLineLeng		= $D5		; current screen line length
000000r 2               
000000r 2               
000000r 2               ; This location contains the current physical screen line position of the
000000r 2               ; cursor, 0 to 22.
000000r 2               ;
000000r 2               PhysCurRow		= $D6		; cursor row
000000r 2               
000000r 2               ; The ASCII value of the last character printed to the screen is held here
000000r 2               ; temporarily.
000000r 2               ;
000000r 2               TEMPD7		= $D7		; checksum byte/temporary last character
000000r 2               
000000r 2               
000000r 2               ; When the INST key is pressed, the screen editor shifts the line to the right,
000000r 2               ; allocates another physical line to the logical line if necessary (and
000000r 2               ; possible), updates the screen line length in $D5, and adjusts the screen line
000000r 2               ; link table at $D9. This location is used to keep track of the number of
000000r 2               ; spaces that has been opened up in this way.
000000r 2               ;
000000r 2               ; Until the spaces that have been opened up are filled, the editor acts as if
000000r 2               ; in quote mode. See location $D4, the quote mode flag. This means that cursor
000000r 2               ; control characters that are normally nonprinting will leave a printed
000000r 2               ; equivalent on the screen when entered, instead of having their normal effect
000000r 2               ; on cursor movement, etc. The only difference between insert and quote mode is
000000r 2               ; that the DELETE key will leave a printed equivalent in insert mode, while the
000000r 2               ; INSERT key will insert spaces as normal.
000000r 2               ;
000000r 2               InsertCount		= $D8		; insert count
000000r 2               
000000r 2               
000000r 2               ; This table contains 25 entries, one for each row of the screen display. Each
000000r 2               ; entry has two functions. Bits 0-3 indicate on which of the four pages of
000000r 2               ; screen memory the first byte of memory for that row is located. This is used
000000r 2               ; in calculating the pointer to the starting address of a screen line at .eq
000000r 2               ; CurScrLine.
000000r 2               ; The high byte is calculated by adding the value of the starting page of
000000r 2               ; screen memory held in $288 to the displacement page held here.
000000r 2               ;
000000r 2               ; The other function of this table is to establish the makeup of logical lines
000000r 2               ; on the screen. While each screen line is only 40 characters long, BASIC
000000r 2               ; allows the entry of program lines that contain up to 80 characters.
000000r 2               ; Therefore, some method must be used to determine which physical lines are
000000r 2               ; linked into a longer logical line, so that this longer logical line may be
000000r 2               ; edited as a unit.
000000r 2               ; The high bit of each byte here is used as a flag by the screen editor. That
000000r 2               ; bit is set when a line is the first or only physical line in a logical line.
000000r 2               ; The high bit is reset to 0 only when a line is an extension to this logical
000000r 2               ; line.
000000r 2               ;
000000r 2               LDTB1		= $D9		; screen line link table
000000r 2               ; ... $F1
000000r 2               
000000r 2               
000000r 2               ColorRamPtr		= $F3		; colour RAM pointer
000000r 2               ; ... $F4
000000r 2               
000000r 2               
000000r 2               ; This pointer points to the address of the keyboard matrix lookup table
000000r 2               ; currently being used. Although there are only 64 keys on the keyboard matrix,
000000r 2               ; each key can be used to print up to four different characters, depending on
000000r 2               ; whether it is struck by itself or in combination with the SHIFT, CTRL, or C=
000000r 2               ; keys.
000000r 2               ;
000000r 2               ; These tables hold the ASCII value of each of the 64 keys for one of these
000000r 2               ; possible combinations of keypresses. When it comes time to print the
000000r 2               ; character, the table that is used determines which character is printed.
000000r 2               ;
000000r 2               ; The addresses of the tables are:
000000r 2               
000000r 2               ;	TblStandardKeys		; unshifted
000000r 2               ;	TblShiftKeys		; shifted
000000r 2               ;	TblCbmKeys			; commodore
000000r 2               ;	TblControlKeys		; control
000000r 2               ;
000000r 2               KEYTAB		= $F5		; keyboard pointer
000000r 2               ; ... $F6
000000r 2               
000000r 2               
000000r 2               ; When device the RS232 channel is opened two buffers of 256 bytes each are
000000r 2               ; created at the top of memory. These locations point to the address of the one
000000r 2               ; which is used to store characters as they are received.
000000r 2               ;
000000r 2               RIBUF		= $F7		; RS232 Rx pointer
000000r 2               ; ... $F8
000000r 2               
000000r 2               
000000r 2               ; These locations point to the address of the 256 byte output buffer that is
000000r 2               ; used for transmitting data to RS232 devices.
000000r 2               ;
000000r 2               ROBUF		= $F9		; RS232 Tx pointer
000000r 2               ; ... $FA
000000r 2               
000000r 2               
000000r 2               StrConvAddr		= $FF		; string conversion address
000000r 2               
000000r 2               
000000r 2               STACK		= $0100		; processor stack
000000r 2               ; ... $01FF
000000r 2               
000000r 2               
000000r 2               ; Input buffer. For some routines the byte before the input buffer needs to be
000000r 2               ; set to a specific value for the routine to work correctly
000000r 2               ;
000000r 2               CommandBuf		= $0200
000000r 2               
000000r 2               
000000r 2               LogFileTbl		= $0259		; logical file table
000000r 2               ; ... $0262
000000r 2               DevNumTbl		= $0263		; device number table
000000r 2               ; ... $026C
000000r 2               SecAddrTbl		= $026D		; secondary address table
000000r 2               ; ... $0276
000000r 2               KeyboardBuf		= $0277		; keyboard buffer
000000r 2               ; ... $0280
000000r 2               StartOfMem		= $0281		; OS start of memory
000000r 2               ; ... $0282
000000r 2               EndOfMem		= $0283		; OS top of memory
000000r 2               ; ... $0284
000000r 2               TIMOUT		= $0285		; serial bus timeout flag
000000r 2               
000000r 2               COLOR		= $0286		; current colour code
000000r 2               					; $00	black
000000r 2               					; $01	white
000000r 2               					; $02	red
000000r 2               					; $03	cyan
000000r 2               					; $04	magents
000000r 2               					; $05	green
000000r 2               					; $06	blue
000000r 2               					; $07	yellow
000000r 2               					; $08	orange
000000r 2               					; $09	brown
000000r 2               					; $0A	light red
000000r 2               					; $0B	dark grey
000000r 2               					; $0C	medium grey
000000r 2               					; $0D	light green
000000r 2               					; $0E	light blue
000000r 2               					; $0F	light grey
000000r 2               
000000r 2               GDCOL		= $0287		; colour under cursor
000000r 2               HIBASE		= $0288		; screen memory page
000000r 2               XMAX		= $0289		; maximum keyboard buffer size
000000r 2               RPTFLG		= $028A		; key repeat. $80 = repeat all, $40 = repeat none,
000000r 2               					; $00 = repeat cursor movement keys, insert/delete
000000r 2               					; key and the space bar
000000r 2               KOUNT		= $028B		; repeat speed counter
000000r 2               DELAY		= $028C		; repeat delay counter
000000r 2               
000000r 2               
000000r 2               ; This flag signals which of the SHIFT, CTRL, or C= keys are currently being
000000r 2               ; pressed.
000000r 2               ;
000000r 2               ; A value of $01 signifies that one of the SHIFT keys is being pressed, a $02
000000r 2               ; shows that the C= key is down, and $04 means that the CTRL key is being
000000r 2               ; pressed. If more than one key is held down, these values will be added e.g
000000r 2               ; $03 indicates that SHIFT and C= are both held down.
000000r 2               ;
000000r 2               ; Pressing the SHIFT and C= keys at the same time will toggle the character set
000000r 2               ; that is presently being used between the uppercase/graphics set, and the
000000r 2               ; lowercase/uppercase set.
000000r 2               ;
000000r 2               ; While this changes the appearance of all of the characters on the screen at
000000r 2               ; once it has nothing whatever to do with the keyboard shift tables and should
000000r 2               ; not be confused with the printing of SHIFTed characters, which affects only
000000r 2               ; one character at a time.
000000r 2               ;
000000r 2               SHFLAG		= $028D		; keyboard shift/control flag
000000r 2               					; bit	key(s) 1 = down
000000r 2               					; ---	---------------
000000r 2               					; 7-3	unused
000000r 2               					;  2	CTRL
000000r 2               					;  1	C=
000000r 2               					;  0	SHIFT
000000r 2               
000000r 2               
000000r 2               ; This location, in combination with the one above, is used to debounce the
000000r 2               ; special SHIFT keys. This will keep the SHIFT/C= combination from changing
000000r 2               ; character sets back and forth during a single pressing of both keys.
000000r 2               ;
000000r 2               LSTSHF		= $028E		; SHIFT/CTRL/C= keypress last pattern
000000r 2               
000000r 2               
000000r 2               ; This location points to the address of the Operating System routine which
000000r 2               ; actually determines which keyboard matrix lookup table will be used.
000000r 2               ;
000000r 2               ; The routine looks at the value of the SHIFT flag at $28D, and based on what
000000r 2               ; value it finds there, stores the address of the correct table to use at
000000r 2               ; location $F5.
000000r 2               ;
000000r 2               KEYLOG		= $028F		; keyboard decode logic pointer
000000r 2               ; ... $0290
000000r 2               
000000r 2               
000000r 2               ; This flag is used to enable or disable the feature which lets you switch
000000r 2               ; between the uppercase/graphics and upper/lowercase character sets by pressing
000000r 2               ; the SHIFT and Commodore logo keys simultaneously.
000000r 2               ;
000000r 2               MODE		= $0291		; shift mode switch, $00 = enabled, $80 = locked
000000r 2               
000000r 2               
000000r 2               ; This location is used to determine whether moving the cursor past the ??xx
000000r 2               ; column of a logical line will cause another physical line to be added to the
000000r 2               ; logical line.
000000r 2               ;
000000r 2               ; A value of 0 enables the screen to scroll the following lines down in order
000000r 2               ; to add that line; any nonzero value will disable the scroll.
000000r 2               ;
000000r 2               ; This flag is set to disable the scroll temporarily when there are characters
000000r 2               ; waiting in the keyboard buffer, these may include cursor movement characters
000000r 2               ; that would eliminate the need for a scroll.
000000r 2               ;
000000r 2               AUTODN		= $0292		; screen scrolling flag, $00 = enabled
000000r 2               
000000r 2               
000000r 2               M51CTR		= $0293		; pseudo 6551 control register. the first character of
000000r 2               					; the OPEN RS232 filename will be stored here
000000r 2               					; bit	function
000000r 2               					; ---	--------
000000r 2               					;  7	2 stop bits/1 stop bit
000000r 2               					; 65	word length
000000r 2               					; ---	-----------
000000r 2               					; 00	8 bits
000000r 2               					; 01	7 bits
000000r 2               					; 10	6 bits
000000r 2               					; 11	5 bits
000000r 2               					;  4	unused
000000r 2               					; 3210	baud rate
000000r 2               					; ----	---------
000000r 2               					; 0000	user rate *
000000r 2               					; 0001	   50
000000r 2               					; 0010	   75
000000r 2               					; 0011	  110
000000r 2               					; 0100	  134.5
000000r 2               					; 0101	  150
000000r 2               					; 0110	  300
000000r 2               					; 0111	  600
000000r 2               					; 1000	 1200
000000r 2               					; 1001	 1800
000000r 2               					; 1010	 2400
000000r 2               					; 1011	 3600
000000r 2               					; 1100	 4800 *
000000r 2               					; 1101	 7200 *
000000r 2               					; 1110	 9600 *
000000r 2               					; 1111	19200 *	* = not implemented
000000r 2               
000000r 2               M51CDR		= $0294		; pseudo 6551 command register. the second character of
000000r 2               					; the OPEN RS232 filename will be stored here
000000r 2               					; bit	function
000000r 2               					; ---	--------
000000r 2               					; 7-5	parity
000000r 2               					;	xx0 = disabled
000000r 2               					;	001 = odd
000000r 2               					;	011 = even
000000r 2               					;	101 = mark
000000r 2               					;	111 = space
000000r 2               					;  4	duplex half/full
000000r 2               					;  3	unused
000000r 2               					;  2	unused
000000r 2               					;  1	unused
000000r 2               					;  0	handshake - X line/3 line
000000r 2               
000000r 2               M51AJB		= $0295		; nonstandard bit timing. the third
000000r 2               					; character of the OPEN RS232 filename
000000r 2               					; will be stored here
000000r 2               ; ... $0296
000000r 2               
000000r 2               RSSTAT		= $0297		; RS-232 status register
000000r 2               					; bit	function
000000r 2               					; ---	--------
000000r 2               					;  7	break
000000r 2               					;  6	no DSR detected
000000r 2               					;  5	unused
000000r 2               					;  4	no CTS detected
000000r 2               					;  3	unused
000000r 2               					;  2	Rx buffer overrun
000000r 2               					;  1	framing error
000000r 2               					;  0	parity error
000000r 2               
000000r 2               BITNUM		= $0298		; number of bits to be sent/received
000000r 2               BAUDOF		= $0299		; bit time
000000r 2               ; ... $029A
000000r 2               
000000r 2               
000000r 2               ; Time Required to Send a Bit
000000r 2               ;
000000r 2               ; This location holds the prescaler value used by CIA #2 timers A and B.
000000r 2               ; These timers cause an NMI interrupt to drive the RS-232 receive and transmit
000000r 2               ; routines CLOCK/PRESCALER times per second each, where CLOCK is the system 02
000000r 2               ; frequency of 1,022,730 Hz (985,250 if you are using the European PAL
000000r 2               ; television standard rather than the American NTSC standard), and PRESCALER is
000000r 2               ; the value stored at 56580-1 ($DD04-5) and 56582-3 ($DD06-7), in low-byte,
000000r 2               ; high-byte order.  You can use the following formula to figure the correct
000000r 2               ; prescaler value for a particular RS-232 baud rate:
000000r 2               ;
000000r 2               ; PRESCALER=((CLOCK/BAUDRATE)/2)-100
000000r 2               ;
000000r 2               ; The American (NTSC standard) prescaler values for the standard RS-232 baud
000000r 2               ; rates which the control register at 659 ($293) makes available are stored in
000000r 2               ; a table at 65218 ($FEC2), starting with the two-byte value used for 50 baud.
000000r 2               ; The European (PAL standard) version of that table is located at 58604
000000r 2               ; ($E4EC).
000000r 2               ; Location Range: 667-670 ($29B-$29E)
000000r 2               ; Byte Indices to the Beginning and End of Receive and Transmit Buffers
000000r 2               ;
000000r 2               ; The two 256-byte First In, First Out (FIFO) buffers for RS-232 data reception
000000r 2               ; and transmission are dynamic wraparound buffers.  This means that the
000000r 2               ; starting point and the ending point of the buffer can change over time, and
000000r 2               ; either point can be anywhere withing the buffer.  If, for example, the
000000r 2               ; starting point is at byte 100, the buffer will fill towards byte 255, at
000000r 2               ; which point it will wrap around to byte 0 again.  To maintain this system,
000000r 2               ; the following four locations are used as indices to the starting and the
000000r 2               ; ending point of each buffer.
000000r 2               ;
000000r 2               RIDBE		= $029B		; index to Rx buffer end
000000r 2               RIDBS		= $029C		; index to Rx buffer start
000000r 2               RODBE		= $029D		; index to Tx buffer start
000000r 2               RODBS		= $029E		; index to Tx buffer end
000000r 2               
000000r 2               
000000r 2               IRQTMP		= $029F		; saved IRQ
000000r 2               ; ... $02A0
000000r 2               
000000r 2               
000000r 2               ; This location holds the active NMI interrupt flag byte from CIA 2 ICR, .eq
000000r 2               ; CIA2IRQ
000000r 2               ;
000000r 2               ENABL		= $02A1		; RS-232 interrupt enable byte
000000r 2               					; bit	function
000000r 2               					; ---	--------
000000r 2               					;  7	unused
000000r 2               					;  6	unused
000000r 2               					;  5	unused
000000r 2               					;  4	1 = waiting for Rx edge
000000r 2               					;  3	unused
000000r 2               					;  2	unused
000000r 2               					;  1	1 = Rx data timer
000000r 2               					;  0	1 = Tx data timer
000000r 2               
000000r 2               Copy6522CRB		= $02A2		; CIA 1 CRB shadow copy
000000r 2               Copy6522ICR		= $02A3		; CIA 1 ICR shadow copy
000000r 2               Copy6522CRA		= $02A4		; CIA 1 CRA shadow copy
000000r 2               TmpLineScrl		= $02A5		; temp Index to the next line for scrolling
000000r 2               PALNTSC		= $02A6		; PAL/NTSC flag
000000r 2               					; $00 = NTSC
000000r 2               					; $01 = PAL
000000r 2               
000000r 2               ; $02A7 to $02FF - unused
000000r 2               
000000r 2               IERROR		= $0300		; vector to the print BASIC error message routine
000000r 2               IMAIN		= $0302		; Vector to the main BASIC program Loop
000000r 2               ICRNCH		= $0304		; Vector to the the ASCII text to keywords routine
000000r 2               IQPLOP		= $0306		; Vector to the list BASIC program as ASCII routine
000000r 2               IGONE		= $0308		; Vector to the execute next BASIC command routine
000000r 2               IEVAL		= $030A		; Vector to the get value from BASIC line routine
000000r 2               
000000r 2               
000000r 2               ; Before every SYS command each of the registers is loaded with the value found
000000r 2               ; in the corresponding storage address. Upon returning to BASIC with an RTS
000000r 2               ; instruction, the new value of each register is stored in the appropriate
000000r 2               ; storage address.
000000r 2               ;
000000r 2               ; This feature allows you to place the necessary values into the registers from
000000r 2               ; BASIC before you SYS to a Kernal or BASIC ML routine. It also enables you to
000000r 2               ; examine the resulting effect of the routine on the registers, and to preserve
000000r 2               ; the condition of the registers on exit for subsequent SYS calls.
000000r 2               ;
000000r 2               SAREG		= $030C		; A for SYS command
000000r 2               SXREG		= $030D		; X for SYS command
000000r 2               SYREG		= $030E		; Y for SYS command
000000r 2               SPREG		= $030F		; P for SYS command
000000r 2               UserJump		= $0310		; JMP instruction for user function
000000r 2               USRADD		= $0311		; user function vector
000000r 2               ; ... $0312
000000r 2               CINV		= $0314		; IRQ vector
000000r 2               BINV		= $0316		; BRK vector
000000r 2               NMINV		= $0318		; NMI vector
000000r 2               IOPEN		= $031A		; kernal vector - open a logical file
000000r 2               ICLOSE		= $031C		; kernal vector - close a specified logical file
000000r 2               ICHKIN		= $031E		; kernal vector - open channel for input
000000r 2               ICKOUT		= $0320		; kernal vector - open channel for output
000000r 2               ICLRCH		= $0322		; kernal vector - close input and output channels
000000r 2               IBASIN		= $0324		; kernal vector - input character from channel
000000r 2               IBSOUT		= $0326		; kernal vector - output character to channel
000000r 2               ISTOP		= $0328		; kernal vector - scan stop key
000000r 2               IGETIN		= $032A		; kernal vector - get character from keyboard queue
000000r 2               ICLALL		= $032C		; kernal vector - close all channels and files
000000r 2               ; ???
000000r 2               ILOAD		= $0330		; kernal vector - load
000000r 2               ISAVE		= $0332		; kernal vector - save
000000r 2               TapeBuffer		= $033C		; cassette buffer
000000r 2               
000000r 2               VICSCN		= $0400 	; screenmemory
000000r 2               
000000r 2               RomStart		= $8000		; autostart ROM initial entry vector
000000r 2               RomIRQ		= $8002		; autostart ROM break entry
000000r 2               RomIdentStr		= $8004		; autostart ROM identifier string start
000000r 2               
000000r 2               
000000r 2               ;** Input / output
000000r 2               
000000r 2               ;* VIC-II video IC
000000r 2               VIC_chip		= $D000		; vic ii chip base address
000000r 2               VICSP0Y		= $D001		; sprite 0, Y position
000000r 2               VICSP1X		= $D002		; sprite 1, X position
000000r 2               VICSP1Y		= $D003		; sprite 1, Y position
000000r 2               VICSP2X		= $D004		; sprite 2, X position
000000r 2               VICSP2Y		= $D005		; sprite 2, Y position
000000r 2               VICSP3X		= $D006		; sprite 3, X position
000000r 2               VICSP3Y		= $D007		; sprite 3, Y position
000000r 2               VICSP4X		= $D008		; sprite 4, X position
000000r 2               VICSP4Y		= $D009		; sprite 4, Y position
000000r 2               VICSP5X		= $D00A		; sprite 5, X position
000000r 2               VICSP5Y		= $D00B		; sprite 5, Y position
000000r 2               VICSP6X		= $D00C		; sprite 6, X position
000000r 2               VICSP6Y		= $D00D		; sprite 6, Y position
000000r 2               VICSP7X		= $D00E		; sprite 7, X position
000000r 2               VICSP7Y		= $D00F		; sprite 7, Y position
000000r 2               VICSPX		= $D010		; sprites 0/7, MSB X position
000000r 2               VICCTR1		= $D011		; vertical fine scroll and control
000000r 2               VICLINE		= $D012		; raster compare register
000000r 2               VICLPX		= $D013		; lightpen, X position
000000r 2               VICLPY		= $D014		; lightpen, Y position
000000r 2               VICSPEN		= $D015		; enable sprites, 1 = on
000000r 2               VICCTR2		= $D016		; horizontal fine scroll and control
000000r 2               VICESPV		= $D017		; enlarge sprites vertical * 2
000000r 2               VICRAM		= $D018		; memory control
000000r 2               VICIRQ		= $D019		; vic interrupt flag register
000000r 2               VICMIRQ		= $D01A		; interrupt mask register
000000r 2               VICSPBA		= $D01B		; sprite/background priority, 1 = sprite
000000r 2               VICSPMC		= $D01C		; sprite multicolor mode, 1 = multicolor
000000r 2               VICESPH		= $D01D		; enlarge sprites horizontal * 2
000000r 2               VICSSCO		= $D01E		; sprite-sprite collision detection
000000r 2               VICSBCO		= $D01F		; sprite-background collision detection
000000r 2               VICBOCL		= $D020 	; border color
000000r 2               VICBAC0		= $D021		; backgroundcolor 0
000000r 2               VICBAC1		= $D022		; backgroundcolor 1
000000r 2               VICBAC2		= $D023		; backgroundcolor 2
000000r 2               VICBAC3		= $D024		; backgroundcolor 3
000000r 2               VICSMC0		= $D025		; sprite multicolor register 0
000000r 2               VICSMC1		= $D026		; sprite multicolor register 1
000000r 2               VICCSP0		= $D027		; color of sprite 0
000000r 2               VICCSP1		= $D028		; color of sprite 1
000000r 2               VICCSP2		= $D029		; color of sprite 2
000000r 2               VICCSP3		= $D02A		; color of sprite 3
000000r 2               VICCSP4		= $D02B		; color of sprite 4
000000r 2               VICCSP5		= $D02C		; color of sprite 5
000000r 2               VICCSP6		= $D02D		; color of sprite 6
000000r 2               VICCSP7		= $D02E		; color of sprite 7
000000r 2               
000000r 2               
000000r 2               ;* SID sound IC
000000r 2               SIDFMVO		= $D418		; volume and filter select
000000r 2               
000000r 2               
000000r 2               ColourRAM		= $D800		; 1K colour RAM base address
000000r 2               
000000r 2               
000000r 2               ;* CIA 1
000000r 2               CIA1DRA		= $DC00		; CIA 1 DRA, keyboard column drive
000000r 2               CIA1DRB		= $DC01		; CIA 1 DRB, keyboard row port
000000r 2               					;
000000r 2               	; keyboard matrix layout
000000r 2               	;	c7	c6	c5	c4	c3	c2	c1	c0
000000r 2               	;   +----------------------------------------------------------------
000000r 2               	; r7|	[RUN]	/	,	N	V	X	[LSH]	[DN]
000000r 2               	; r6|	Q	[UP]	@	O	U	T	E	[F5]
000000r 2               	; r5|	[CBM]= :	K	H	F	S	[F3]
000000r 2               	; r4|	[SP]	[RSH]	.	M	B	C	Z	[F1]
000000r 2               	; r3|	2	[Home]-	0	8	6	4	[F7]
000000r 2               	; r2|	[CTL]	;	L	J	G	D	A	[RGT]
000000r 2               	; r1|	[LFT]	*	P	I	Y	R	W	[RET]
000000r 2               	; r0|	1		+	9	7	5	3	[DEL]
000000r 2               					;
000000r 2               CIA1DDRA		= $DC02		; CIA 1 DDRA, keyboard column
000000r 2               CIA1DDRB		= $DC03		; CIA 1 DDRB, keyboard row
000000r 2               CIA1TI1L		= $DC04		; CIA 1 timer A low byte
000000r 2               CIA1TI1H		= $DC05		; CIA 1 timer A high byte
000000r 2               CIA1TI2L		= $DC06		; CIA 1 timer B low byte
000000r 2               CIA1TI2H		= $DC07		; CIA 1 timer B high byte
000000r 2               CIA1TOD1		= $DC08		; time of day, 1/10 sec.
000000r 2               CIA1TODS		= $DC09		; time of day, seconds
000000r 2               CIA1TODM		= $DC0A		; time of day, minutes
000000r 2               CIA1TODH		= $DC0B		; time of day, hours
000000r 2               CIA1SDR		= $DC0C		; Serial Data Register
000000r 2               CIA1IRQ		= $DC0D		; CIA 1 ICR
000000r 2               					; bit	function
000000r 2               					; ---	--------
000000r 2               					;  7	interrupt
000000r 2               					;  6	unused
000000r 2               					;  5	unused
000000r 2               					;  4	FLAG
000000r 2               					;  3	shift register
000000r 2               					;  2	TOD alarm
000000r 2               					;  1	timer B
000000r 2               					;  0	timer A
000000r 2               CIA1CTR1		= $DC0E		; CIA 1 CRA
000000r 2               					; bit	function
000000r 2               					; ---	--------
000000r 2               					;  7	TOD clock, 1 = 50Hz, 0 = 60Hz
000000r 2               					;  6	serial port direction, 1 = out, 0 = in
000000r 2               					;  5	timer A input, 1 = phase2, 0 = CNT in
000000r 2               					;  4	1 = force load timer A
000000r 2               					;  3	timer A mode, 1 = single shot, 0 = continuous
000000r 2               					;  2	PB6 mode, 1 = toggle, 0 = single shot
000000r 2               					;  1	1 = timer A to PB6
000000r 2               					;  0	1 = start timer A
000000r 2               CIA1CTR2		= $DC0F		; CIA 1 CRB
000000r 2               					; bit	function
000000r 2               					; ---	--------
000000r 2               					;  7	TOD register select, 1 = clock, 0 = alarm
000000r 2               					; 6-5	timer B mode
000000r 2               					;     11 = timer A with CNT enable
000000r 2               					;     10 = timer A
000000r 2               					;     01 = CNT in
000000r 2               					;     00 = phase 2
000000r 2               					;  4	1 = force load timer B
000000r 2               					;  3	timer B mode, 1 = single shot, 0 = continuous
000000r 2               					;  2	PB7 mode, 1 = toggle, 0 = single shot
000000r 2               					;  1	1 = timer B to PB7
000000r 2               					;  0	1 = start timer B
000000r 2               
000000r 2               
000000r 2               ;* CIA 2
000000r 2               CIA2DRA		= $DD00		; CIA 2 DRA, serial port and video address
000000r 2               					; bit	function
000000r 2               					; ---	--------
000000r 2               					;  7	serial DATA in
000000r 2               					;  6	serial CLK in
000000r 2               					;  5	serial DATA out
000000r 2               					;  4	serial CLK out
000000r 2               					;  3	serial ATN out
000000r 2               					;  2	RS232 Tx DATA
000000r 2               					;  1	video address 15
000000r 2               					;  0	video address 14
000000r 2               CIA2DRB		= $DD01		; CIA 2 DRB, RS232 port / USERPORT
000000r 2               					; bit	function
000000r 2               					; ---	--------
000000r 2               					;  7	RS232 DSR
000000r 2               					;  6	RS232 CTS
000000r 2               					;  5	unused
000000r 2               					;  4	RS232 DCD
000000r 2               					;  3	RS232 RI
000000r 2               					;  2	RS232 DTR
000000r 2               					;  1	RS232 RTS
000000r 2               					;  0	RS232 Rx DATA
000000r 2               CIA2DDRA		= $DD02		; CIA 2 DDRA, serial port and video address
000000r 2               CIA2DDRB		= $DD03		; CIA 2 DDRB, RS232 port / USERPORT
000000r 2               CIA2TI1L		= $DD04		; CIA 2 timer A low byte
000000r 2               CIA2TI1H		= $DD05		; CIA 2 timer A high byte
000000r 2               CIA2TI2L		= $DD06		; CIA 2 timer B low byte
000000r 2               CIA2TI2H		= $DD07		; CIA 2 timer B high byte
000000r 2               CIA2TOD1		= $DD08		; time of day, 1/10 sec.
000000r 2               CIA2TODS		= $DD09		; time of day, seconds
000000r 2               CIA2TODM		= $DD0A		; time of day, minutes
000000r 2               CIA2TODH		= $DD0B		; time of day, hours
000000r 2               CIA2SDR		= $DD0C		; Serial Data Register
000000r 2               CIA2IRQ		= $DD0D		; CIA 2 ICR
000000r 2               					; bit	function
000000r 2               					; ---	--------
000000r 2               					;  7	interrupt
000000r 2               					;  6	unused
000000r 2               					;  5	unused
000000r 2               					;  4	FLAG
000000r 2               					;  3	shift register
000000r 2               					;  2	TOD alarm
000000r 2               					;  1	timer B
000000r 2               					;  0	timer A
000000r 2               CIA2CTR1		= $DD0E		; CIA 2 CRA
000000r 2               					; bit	function
000000r 2               					; ---	--------
000000r 2               					;  7	TOD clock, 1 = 50Hz, 0 = 60Hz
000000r 2               					;  6	serial port direction, 1 = out, 0 = in
000000r 2               					;  5	timer A input, 1 = phase2, 0 = CNT in
000000r 2               					;  4	1 = force load timer A
000000r 2               					;  3	timer A mode, 1 = single shot, 0 = continuous
000000r 2               					;  2	PB6 mode, 1 = toggle, 0 = single shot
000000r 2               					;  1	1 = timer A to PB6
000000r 2               					;  0	1 = start timer A
000000r 2               CIA2CTR2		= $DD0F		; CIA 2 CRB
000000r 2               					; bit	function
000000r 2               					; ---	--------
000000r 2               					;  7	TOD register select, 1 = clock, 0 = alarm
000000r 2               					; 6-5	timer B mode
000000r 2               					;     11 = timer A with CNT enable
000000r 2               					;     10 = timer A
000000r 2               					;     01 = CNT in
000000r 2               					;     00 = phase 2
000000r 2               					;  4	1 = force load timer B
000000r 2               					;  3	timer B mode, 1 = single shot, 0 = continuous
000000r 2               					;  2	PB7 mode, 1 = toggle, 0 = single shot
000000r 2               					;  1	1 = timer B to PB7
000000r 2               					;  0	1 = start timer B
000000r 2               
000000r 2               
000000r 2               ;******************************************************************************
000000r 2               ;
000000r 2               ; BASIC keyword token values. tokens not used in the source are included for
000000r 2               ; completeness but commented out
000000r 2               
000000r 2               ; command tokens
000000r 2               
000000r 2               ; TK_END	= $80			; END token
000000r 2               TK_FOR		= $81		; FOR token
000000r 2               ; TK_NEXT	= $82			; NEXT token
000000r 2               TK_DATA		= $83		; DATA token
000000r 2               ; TK_INFL	= $84			; INPUT# token
000000r 2               ; TK_INPUT	= $85			; INPUT token
000000r 2               ; TK_DIM	= $86			; DIM token
000000r 2               ; TK_READ	= $87			; READ token
000000r 2               
000000r 2               ; TK_LET	= $88			; LET token
000000r 2               TK_GOTO		= $89		; GOTO token
000000r 2               ; TK_RUN	= $8A			; RUN token
000000r 2               ; TK_IF		= $8B			; IF token
000000r 2               ; TK_RESTORE	= $8C			; RESTORE token
000000r 2               TK_GOSUB		= $8D		; GOSUB token
000000r 2               ; TK_RETURN	= $8E			; RETURN token
000000r 2               TK_REM		= $8F		; REM token
000000r 2               
000000r 2               ; TK_STOP	= $90			; STOP token
000000r 2               ; TK_ON		= $91			; ON token
000000r 2               ; TK_WAIT	= $92			; WAIT token
000000r 2               ; TK_LOAD	= $93			; LOAD token
000000r 2               ; TK_SAVE	= $94			; SAVE token
000000r 2               ; TK_VERIFY	= $95			; VERIFY token
000000r 2               ; TK_DEF	= $96			; DEF token
000000r 2               ; TK_POKE	= $97			; POKE token
000000r 2               
000000r 2               ; TK_PRINFL	= $98			; PRINT# token
000000r 2               TK_PRINT		= $99		; PRINT token
000000r 2               ; TK_CONT	= $9A			; CONT token
000000r 2               ; TK_LIST	= $9B			; LIST token
000000r 2               ; TK_CLR	= $9C			; CLR token
000000r 2               ; TK_CMD	= $9D			; CMD token
000000r 2               ; TK_SYS	= $9E			; SYS token
000000r 2               ; TK_OPEN	= $9F			; OPEN token
000000r 2               
000000r 2               ; TK_CLOSE	= $A0			; CLOSE token
000000r 2               ; TK_GET	= $A1			; GET token
000000r 2               ; TK_NEW	= $A2			; NEW token
000000r 2               
000000r 2               ; secondary keyword tokens
000000r 2               
000000r 2               TK_TAB		= $A3		; TAB( token
000000r 2               TK_TO		= $A4		; TO token
000000r 2               TK_FN		= $A5		; FN token
000000r 2               TK_SPC		= $A6		; SPC( token
000000r 2               TK_THEN		= $A7		; THEN token
000000r 2               TK_NOT		= $A8		; NOT token
000000r 2               TK_STEP		= $A9		; STEP token
000000r 2               
000000r 2               ; operator tokens
000000r 2               
000000r 2               TK_PLUS		= $AA		; + token
000000r 2               TK_MINUS		= $AB		; - token
000000r 2               ; TK_MUL	= $AC			; * token
000000r 2               ; TK_DIV	= $AD			; / token
000000r 2               ; TK_POWER	= $AE			; ^ token
000000r 2               ; TK_AND	= $AF			; AND token
000000r 2               
000000r 2               ; TK_OR		= $B0			; OR token
000000r 2               TK_GT		= $B1		; > token
000000r 2               TK_EQUAL		= $B2		; = token
000000r 2               ; TK_LT		= $B3			; < token
000000r 2               
000000r 2               ; function tokens
000000r 2               
000000r 2               TK_SGN		= $B4		; SGN token
000000r 2               ; TK_INT	= $B5			; INT token
000000r 2               ; TK_ABS	= $B6			; ABS token
000000r 2               ; TK_USR	= $B7			; USR token
000000r 2               
000000r 2               ; TK_FRE	= $B8			; FRE token
000000r 2               ; TK_POS	= $B9			; POS token
000000r 2               ; TK_SQR	= $BA			; SQR token
000000r 2               ; TK_RND	= $BB			; RND token
000000r 2               ; TK_LOG	= $BC			; LOG token
000000r 2               ; TK_EXP	= $BD			; EXP token
000000r 2               ; TK_COS	= $BE			; COS token
000000r 2               ; TK_SIN	= $BF			; SIN token
000000r 2               
000000r 2               ; TK_TAN	= $C0			; TAN token
000000r 2               ; TK_ATN	= $C1			; ATN token
000000r 2               ; TK_PEEK	= $C2			; PEEK token
000000r 2               ; TK_LEN	= $C3			; LEN token
000000r 2               ; TK_STRS	= $C4			; STR$ token
000000r 2               ; TK_VAL	= $C5			; VAL token
000000r 2               ; TK_ASC	= $C6			; ASC token
000000r 2               ; TK_CHRS	= $C7			; CHR$ token
000000r 2               
000000r 2               ; TK_LEFTS	= $C8			; LEFT$ token
000000r 2               ; TK_RIGHTS	= $C9			; RIGHT$ token
000000r 2               ; TK_MIDS	= $CA			; MID$ token
000000r 2               TK_GO		= $CB		; GO token
000000r 2               
000000r 2               TK_PI		= $FF		; PI token
000000r 2               
000000r 2               
000000r 2               
000000r 1               
000000r 1               .include "C64-basV1mod.a65"
000000r 2               ;******************************************************************************
000000r 2               ;******************************************************************************
000000r 2               ;
000000r 2               ;         The almost completely commented C64 BASIC ROM disassembly.
000000r 2               ;                 Based on version V1.01 by Lee Davison 2012
000000r 2               ;
000000r 2               
000000r 2               ;******************************************************************************
000000r 2               ;
000000r 2               ; start of the BASIC ROM
000000r 2               ;
000000r 2               ; version 901226-01
000000r 2               ;
000000r 2               
000000r 2               .org	$A000
00A000  2               
00A000  2               BasicCold:
00A000  2  94 E3        .word	BasicColdStart			; BASIC cold start entry point
00A002  2               BasicNMI:
00A002  2  7B E3        .word	BasicWarmStart			; BASIC warm start entry point
00A004  2               
00A004  2               ;A_A004
00A004  2  43 42 4D 42  .byte	"cbmbasic"			; ROM name, unreferenced
00A008  2  41 53 49 43  
00A00C  2               
00A00C  2               
00A00C  2               ;******************************************************************************
00A00C  2               ;
00A00C  2               ; action addresses for primary commands. these are called by pushing the
00A00C  2               ; address onto the stack and doing an RTS so the actual address -1 needs to be
00A00C  2               ; pushed
00A00C  2               ;
00A00C  2               TblBasicInstr:				;				[A00C]
00A00C  2  30 A8        .word	bcEND-1				; perform END		$80
00A00E  2  41 A7        .word	bcFOR-1				; perform FOR		$81
00A010  2  1D AD        .word	bcNEXT-1			; perform NEXT		$82
00A012  2  F7 A8        .word	bcDATA-1			; perform DATA		$83
00A014  2  A4 AB        .word	bcINPUTH-1			; perform INPUT#	$84
00A016  2  BE AB        .word	bcINPUT-1			; perform INPUT		$85
00A018  2  80 B0        .word	bcDIM-1				; perform DIM		$86
00A01A  2  05 AC        .word	bcREAD-1			; perform READ		$87
00A01C  2               
00A01C  2  A4 A9        .word	bcLET-1				; perform LET		$88
00A01E  2  9F A8        .word	bcGOTO-1			; perform GOTO		$89
00A020  2  70 A8        .word	bcRUN-1				; perform RUN		$8A
00A022  2  27 A9        .word	bcIF-1				; perform IF		$8B
00A024  2  1C A8        .word	bcRESTORE-1			; perform RESTORE	$8C
00A026  2  82 A8        .word	bcGOSUB-1			; perform GOSUB		$8D
00A028  2  D1 A8        .word	bcRETURN-1			; perform RETURN	$8E
00A02A  2  3A A9        .word	bcREM-1				; perform REM		$8F
00A02C  2               
00A02C  2  2E A8        .word	bcSTOP-1			; perform STOP		$90
00A02E  2  4A A9        .word	bcON-1				; perform ON		$91
00A030  2  2C B8        .word	bcWAIT-1			; perform WAIT		$92
00A032  2  67 E1        .word	bcLOAD-1			; perform LOAD		$93
00A034  2  55 E1        .word	bcSAVE-1			; perform SAVE		$94
00A036  2  64 E1        .word	bcVERIFY-1			; perform VERIFY	$95
00A038  2  B2 B3        .word	bcDEF-1				; perform DEF		$96
00A03A  2  23 B8        .word	bcPOKE-1			; perform POKE		$97
00A03C  2               
00A03C  2  7F AA        .word	bcPRINTH-1			; perform PRINT#	$98
00A03E  2  9F AA        .word	bcPRINT-1			; perform PRINT		$99
00A040  2  56 A8        .word	bcCONT-1			; perform CONT		$9A
00A042  2  9B A6        .word	bcLIST-1			; perform LIST		$9B
00A044  2  5D A6        .word	bcCLR-1				; perform CLR		$9C
00A046  2  85 AA        .word	bcCMD-1				; perform CMD		$9D
00A048  2  29 E1        .word	bcSYS-1				; perform SYS		$9E
00A04A  2  BD E1        .word	bcOPEN-1			; perform OPEN		$9F
00A04C  2               
00A04C  2  C6 E1        .word	bcCLOSE-1			; perform CLOSE		$A0
00A04E  2  7A AB        .word	bcGET-1				; perform GET		$A1
00A050  2  41 A6        .word	bcNEW-1				; perform NEW		$A2
00A052  2               
00A052  2               
00A052  2               ;******************************************************************************
00A052  2               ;
00A052  2               ; action addresses for functions
00A052  2               ;
00A052  2               TblFunctions:				;				[A052]
00A052  2  39 BC        .word	bcSGN				; perform SGN()		$B4
00A054  2  CC BC        .word	bcINT				; perform INT()		$B5
00A056  2  58 BC        .word	bcABS				; perform ABS()		$B6
00A058  2  10 03        .word	UserJump			; perform USR()		$B7
00A05A  2               
00A05A  2  7D B3        .word	bcFRE				; perform FRE()		$B8
00A05C  2  9E B3        .word	bcPOS				; perform POS()		$B9
00A05E  2  71 BF        .word	bcSQR				; perform SQR()		$BA
00A060  2  97 E0        .word	bcRND				; perform RND()		$BB
00A062  2  EA B9        .word	bcLOG				; perform LOG()		$BC
00A064  2  ED BF        .word	bcEXP				; perform EXP()		$BD
00A066  2  64 E2        .word	bcCOS				; perform COS()		$BE
00A068  2  6B E2        .word	bcSIN				; perform SIN()		$BF
00A06A  2               
00A06A  2  B4 E2        .word	bcTAN				; perform TAN()		$C0
00A06C  2  0E E3        .word	bcATN				; perform ATN()		$C1
00A06E  2  0D B8        .word	bcPEEK				; perform PEEK()	$C2
00A070  2  7C B7        .word	bcLEN				; perform LEN()		$C3
00A072  2  65 B4        .word	bcSTR				; perform STR$()	$C4
00A074  2  AD B7        .word	bcVAL				; perform VAL()		$C5
00A076  2  8B B7        .word	bcASC				; perform ASC()		$C6
00A078  2  EC B6        .word	bcCHR				; perform CHR$()	$C7
00A07A  2               
00A07A  2  00 B7        .word	bcLEFT				; perform LEFT$()	$C8
00A07C  2  2C B7        .word	bcRIGHT				; perform RIGHT$()	$C9
00A07E  2  37 B7        .word	bcMID				; perform MID$()	$CA
00A080  2               
00A080  2               
00A080  2               ;******************************************************************************
00A080  2               ;
00A080  2               ; precedence byte and action addresses for operators. like the primarry
00A080  2               ; commands these are called by pushing the address onto the stack and doing an
00A080  2               ; RTS, so again the actual address -1 needs to be pushed
00A080  2               ;
00A080  2               HierachyCode:				;				[A080]
00A080  2  79           .byte	$79
00A081  2  69 B8        .word	bcPLUS-1			; +
00A083  2  79           .byte	$79
00A084  2  52 B8        .word	bcMINUS-1			; -
00A086  2  7B           .byte	$7B
00A087  2  2A BA        .word	bcMULTIPLY-1			; *
00A089  2  7B           .byte	$7B
00A08A  2  11 BB        .word	bcDIVIDE-1			; /
00A08C  2  7F           .byte	$7F
00A08D  2  7A BF        .word	bcPOWER-1			; ^
00A08F  2  50           .byte	$50
00A090  2  E8 AF        .word	bcAND-1				; AND
00A092  2  46           .byte	$46
00A093  2  E5 AF        .word	bcOR-1				; OR
00A095  2  7D           .byte	$7D
00A096  2  B3 BF        .word	bcGREATER-1			; >
00A098  2  5A           .byte	$5A
00A099  2  D3 AE        .word	bcEQUAL-1			; =
00A09B  2  64           .byte	$64
00A09C  2  15 B0        .word	bcSMALLER-1			; <
00A09E  2               
00A09E  2               
00A09E  2               ;******************************************************************************
00A09E  2               ;
00A09E  2               ; BASIC keywords. each word has bit 7 set in it's last character as an end
00A09E  2               ; marker, even the one character keywords such as "<" or "="
00A09E  2               ;
00A09E  2               ; first are the primary command keywords, only these can start a statement
00A09E  2               ;
00A09E  2               TblBasicCodes:				;				[A09E]
00A09E  2  45 4E C4     D_A09E:		.byte "en", 'd'+$80	; END		$80		128
00A0A1  2  46 4F D2     D_A0A1:		.byte "fo", 'r'+$80	; FOR		$81		129
00A0A4  2  4E 45 58 D4  D_A0A4:		.byte "nex", 't'+$80	; NEXT		$82		130
00A0A8  2  44 41 54 C1  D_A0A8:		.byte "dat", 'a'+$80	; DATA		$83		131
00A0AC  2  49 4E 50 55  D_A0AC:		.byte "input", '#'+$80	; INPUT#	$84		132
00A0B0  2  54 A3        
00A0B2  2  49 4E 50 55  D_A0B2:		.byte "inpu", 't'+$80	; INPUT		$85		133
00A0B6  2  D4           
00A0B7  2  44 49 CD     D_A0B7:		.byte "di", 'm'+$80	; DIM		$86		134
00A0BA  2  52 45 41 C4  D_A0BA:		.byte "rea", 'd'+$80	; READ		$87		135
00A0BE  2  4C 45 D4     D_A0BE:		.byte "le", 't'+$80	; LET		$88		136
00A0C1  2  47 4F 54 CF  D_A0C1:		.byte "got", 'o'+$80	; GOTO		$89		137
00A0C5  2  52 55 CE     D_A0C5:		.byte "ru", 'n'+$80	; RUN		$8A		138
00A0C8  2  49 C6        D_A0C8:		.byte "i", 'f'+$80	; IF		$8B		139
00A0CA  2  52 45 53 54  D_A0CA:		.byte "restor", 'e'+$80	; RESTORE	$8C		140
00A0CE  2  4F 52 C5     
00A0D1  2  47 4F 53 55  D_A0D1:		.byte "gosu", 'b'+$80	; GOSUB		$8D		141
00A0D5  2  C2           
00A0D6  2  52 45 54 55  D_A0D6:		.byte "retur", 'n'+$80	; RETURN	$8E		142
00A0DA  2  52 CE        
00A0DC  2  52 45 CD     D_A0DC:		.byte "re", 'm'+$80	; REM		$8F		143
00A0DF  2  53 54 4F D0  D_A0DF:		.byte "sto", 'p'+$80	; STOP		$90		144
00A0E3  2  4F CE        D_A0E3:		.byte "o", 'n'+$80	; ON		$91		145
00A0E5  2  57 41 49 D4  D_A0E5:		.byte "wai", 't'+$80	; WAIT		$92		146
00A0E9  2  4C 4F 41 C4  D_A0E9:		.byte "loa", 'd'+$80	; LOAD		$93		147
00A0ED  2  53 41 56 C5  D_A0ED:		.byte "sav", 'e'+$80	; SAVE		$94		148
00A0F1  2  56 45 52 49  D_A0F1:		.byte "verif", 'y'+$80	; VERIFY	$95		149
00A0F5  2  46 D9        
00A0F7  2  44 45 C6     D_A0F7:		.byte "de", 'f'+$80	; DEF		$96		150
00A0FA  2  50 4F 4B C5  D_A0FA:		.byte "pok", 'e'+$80	; POKE		$97		151
00A0FE  2  50 52 49 4E  D_A0FE:		.byte "print", '#'+$80	; PRINT#	$98		152
00A102  2  54 A3        
00A104  2  50 52 49 4E  D_A104:		.byte "prin", 't'+$80	; PRINT		$99		153
00A108  2  D4           
00A109  2  43 4F 4E D4  D_A109:		.byte "con", 't'+$80	; CONT		$9A		154
00A10D  2  4C 49 53 D4  D_A10D:		.byte "lis", 't'+$80	; LIST		$9B		155
00A111  2  43 4C D2     D_A111:		.byte "cl", 'r'+$80	; CLR		$9C		156
00A114  2  43 4D C4     D_A114:		.byte "cm", 'd'+$80	; CMD		$9D		157
00A117  2  53 59 D3     D_A117:		.byte "sy", 's'+$80	; SYS		$9E		158
00A11A  2  4F 50 45 CE  D_A11A:		.byte "ope", 'n'+$80	; OPEN		$9F		159
00A11E  2  43 4C 4F 53  D_A11E:		.byte "clos", 'e'+$80	; CLOSE		$A0		160
00A122  2  C5           
00A123  2  47 45 D4     D_A123:		.byte "ge", 't'+$80	; GET		$A1		161
00A126  2  4E 45 D7     D_A126:		.byte "ne", 'w'+$80	; NEW
00A129  2               
00A129  2               ; table of functions, each ended with a +$80
00A129  2               ; next are the secondary command keywords, these can not start a statement
00A129  2               
00A129  2  54 41 42 A8  D_A129:		.byte "tab", '('+$80	; TAB(		$A3		163
00A12D  2  54 CF        D_A12D:		.byte "t", 'o'+$80	; TO		$A4		164
00A12F  2  46 CE        D_A12F:		.byte "f", 'n'+$80	; FN		$A5		165
00A131  2  53 50 43 A8  D_A131:		.byte "spc", '('+$80	; SPC(		$A6		166
00A135  2  54 48 45 CE  D_A135:		.byte "the", 'n'+$80	; THEN		$A7		167
00A139  2  4E 4F D4     D_A139:		.byte "no", 't'+$80	; NOT		$A8		168
00A13C  2  53 54 45 D0  D_A13C:		.byte "ste", 'p'+$80	; STEP
00A140  2               
00A140  2               ; next are the operators
00A140  2               
00A140  2  AB           D_A140:		.byte '+'+$80		; +		$AA		170
00A141  2  AD           D_A141:		.byte '-'+$80		; -		$AB		171
00A142  2  AA           D_A142:		.byte '*'+$80		; *		$AC		172
00A143  2  AF           D_A143:		.byte '/'+$80		; /		$AD		173
00A144  2  DE           D_A144:		.byte '^'+$80		; ^		$AE		174
00A145  2  41 4E C4     D_A145:		.byte "an", 'd'+$80	; AND		$AF		175
00A148  2  4F D2        D_A148:		.byte "o", 'r'+$80	; OR		$B0		176
00A14A  2  BE           D_A14A:		.byte '>'+$80		; >		$B1		177
00A14B  2  BD           D_A14B:		.byte '='+$80		; =		$B2		178
00A14C  2  BC           D_A14C:		.byte '<'+$80		; <		$B3		179
00A14D  2               
00A14D  2               ; and finally the functions
00A14D  2               
00A14D  2  53 47 CE     D_A14D:		.byte "sg", 'n'+$80	; SGN		$B4		180
00A150  2  49 4E D4     D_A150:		.byte "in", 't'+$80	; INT		$B5		181
00A153  2  41 42 D3     D_A153:		.byte "ab", 's'+$80	; ABS		$B6		182
00A156  2  55 53 D2     D_A156:		.byte "us", 'r'+$80	; USR		$B7		183
00A159  2  46 52 C5     D_A159:		.byte "fr", 'e'+$80	; FRE		$B8		184
00A15C  2  50 4F D3     D_A15C:		.byte "po", 's'+$80	; POS		$B9		185
00A15F  2  53 51 D2     D_A15F:		.byte "sq", 'r'+$80	; SQR		$BA		186
00A162  2  52 4E C4     D_A162:		.byte "rn", 'd'+$80	; RND		$BB		187
00A165  2  4C 4F C7     D_A165:		.byte "lo", 'g'+$80	; LOG		$BC		188
00A168  2  45 58 D0     D_A168:		.byte "ex", 'p'+$80	; EXP		$BD		189
00A16B  2  43 4F D3     D_A16B:		.byte "co", 's'+$80	; COS		$BE		190
00A16E  2  53 49 CE     D_A16E:		.byte "si", 'n'+$80	; SIN		$BF		191
00A171  2  54 41 CE     D_A171:		.byte "ta", 'n'+$80	; TAN		$C0		192
00A174  2  41 54 CE     D_A174:		.byte "at", 'n'+$80	; ATN		$C1		193
00A177  2  50 45 45 CB  D_A177:		.byte "pee", 'k'+$80	; PEEK		$C2		194
00A17B  2  4C 45 CE     D_A17B:		.byte "le", 'n'+$80	; LEN		$C3		195
00A17E  2  53 54 52 A4  D_A17E:		.byte "str", '$'+$80	; STR$		$C4		196
00A182  2  56 41 CC     D_A182:		.byte "va", 'l'+$80	; VAL		$C5		197
00A185  2  41 53 C3     D_A185:		.byte "as", 'c'+$80	; ASC		$C6		198
00A188  2  43 48 52 A4  D_A188:		.byte "chr", '$'+$80	; CHR$		$C7		199
00A18C  2  4C 45 46 54  D_A18C:		.byte "left", '$'+$80	; LEFT$		$C8		200
00A190  2  A4           
00A191  2  52 49 47 48  D_A191:		.byte "right", '$'+$80	; RIGHT$	$C9		201
00A195  2  54 A4        
00A197  2  4D 49 44 A4  D_A197:		.byte "mid", '$'+$80	; MID$		$CA		202
00A19B  2               
00A19B  2               ; lastly is GO, this is an add on so that GO TO, as well as GOTO, will work
00A19B  2               
00A19B  2  47 CF        D_A19B:		.byte "g", 'o'+$80	; GO		$CB		203
00A19D  2               
00A19D  2  00           .byte	$00				; end marker
00A19E  2               
00A19E  2               
00A19E  2               ;******************************************************************************
00A19E  2               ;
00A19E  2               ; BASIC error messages
00A19E  2               ;
00A19E  2  54 4F 4F 20  TxtTooManyFile:		.byte "too many file", 's'+$80		;	[A19E]
00A1A2  2  4D 41 4E 59  
00A1A6  2  20 46 49 4C  
00A1AC  2  46 49 4C 45  TxtFileOpen:		.byte "file ope", 'n'+$80		;	[A1AC]
00A1B0  2  20 4F 50 45  
00A1B4  2  CE           
00A1B5  2  46 49 4C 45  TxtFileNotOpen:		.byte "file not ope", 'n'+$80		;	[A1B5]
00A1B9  2  20 4E 4F 54  
00A1BD  2  20 4F 50 45  
00A1C2  2  46 49 4C 45  TxtFileNotFound:	.byte "file not foun", 'd'+$80		;	[A1C2]
00A1C6  2  20 4E 4F 54  
00A1CA  2  20 46 4F 55  
00A1D0  2               ;TxtDevNotPresent:	.byte "device not presen", 't'+$80	;	[A1D0]
00A1D0  2  44 45 56 49  TxtDevNotPrese:	.byte "device not presen", 't'+$80	;	[A1D0]
00A1D4  2  43 45 20 4E  
00A1D8  2  4F 54 20 50  
00A1E2  2  4E 4F 54 20  TxtNotInputFile:	.byte "not input fil", 'e'+$80		;	[A1E2]
00A1E6  2  49 4E 50 55  
00A1EA  2  54 20 46 49  
00A1F0  2               ;TxtNotOutputFile:	.byte "not output fil", 'e'+$80		;	[A1F0]
00A1F0  2  4E 4F 54 20  TxtNotOutputFi:	.byte "not output fil", 'e'+$80		;	[A1F0]
00A1F4  2  4F 55 54 50  
00A1F8  2  55 54 20 46  
00A1FF  2  4D 49 53 53  TxtMissingFile:		.byte "missing file nam", 'e'+$80	;	[A1FF]
00A203  2  49 4E 47 20  
00A207  2  46 49 4C 45  
00A210  2               ;TxtIllegalDevice:	.byte "illegal device numbe", 'r'+$80	;	[A210]
00A210  2  49 4C 4C 45  TxtIllegalDevi:	.byte "illegal device numbe", 'r'+$80	;	[A210]
00A214  2  47 41 4C 20  
00A218  2  44 45 56 49  
00A225  2  4E 45 58 54  TxtNextWithout:		.byte "next without fo", 'r'+$80	;	[A225]
00A229  2  20 57 49 54  
00A22D  2  48 4F 55 54  
00A235  2  53 59 4E 54  TxtSyntax:		.byte "synta", 'x'+$80			;	[A235]
00A239  2  41 D8        
00A23B  2               ;TxtReturnWithout:	.byte "return without gosu", 'b'+$80	;	[A23B]
00A23B  2  52 45 54 55  TxtReturnWitho:	.byte "return without gosu", 'b'+$80	;	[A23B]
00A23F  2  52 4E 20 57  
00A243  2  49 54 48 4F  
00A24F  2  4F 55 54 20  TxtOutOfData:		.byte "out of dat", 'a'+$80		;	[A24F]
00A253  2  4F 46 20 44  
00A257  2  41 54 C1     
00A25A  2  49 4C 4C 45  TxtIllegalQuan:		.byte "illegal quantit", 'y'+$80	;	[A25A]
00A25E  2  47 41 4C 20  
00A262  2  51 55 41 4E  
00A26A  2  4F 56 45 52  TxtOverflow:		.byte "overflo", 'w'+$80		;	[A26A]
00A26E  2  46 4C 4F D7  
00A272  2  4F 55 54 20  TxtOutOfMemory:		.byte "out of memor", 'y'+$80		;	[A272]
00A276  2  4F 46 20 4D  
00A27A  2  45 4D 4F 52  
00A27F  2  55 4E 44 45  TxtUndefdState:		.byte "undef'd statemen", 't'+$80	;	[A27F]
00A283  2  46 27 44 20  
00A287  2  53 54 41 54  
00A290  2               ;TxtBadSubscript:	.byte "bad subscrip", 't'+$80		;	[A290]
00A290  2  42 41 44 20  TxtBadSubscrip:	.byte "bad subscrip", 't'+$80		;	[A290]
00A294  2  53 55 42 53  
00A298  2  43 52 49 50  
00A29D  2  52 45 44 49  TxtRedimdArray:		.byte "redim'd arra", 'y'+$80		;	[A29D]
00A2A1  2  4D 27 44 20  
00A2A5  2  41 52 52 41  
00A2AA  2  44 49 56 49  TxtDivisByZero:		.byte "division by zer", 'o'+$80	;	[A2AA]
00A2AE  2  53 49 4F 4E  
00A2B2  2  20 42 59 20  
00A2BA  2               ;TxtIllegalDirect:	.byte "illegal direc", 't'+$80		;	[A2BA]
00A2BA  2  49 4C 4C 45  TxtIllegalDire:	.byte "illegal direc", 't'+$80		;	[A2BA]
00A2BE  2  47 41 4C 20  
00A2C2  2  44 49 52 45  
00A2C8  2  54 59 50 45  TxtTypeMismatc:		.byte "type mismatc", 'h'+$80		;	[A2C8]
00A2CC  2  20 4D 49 53  
00A2D0  2  4D 41 54 43  
00A2D5  2               ;TxtStringTooLong:	.byte "string too lon", 'g'+$80		;	[A2D5]
00A2D5  2  53 54 52 49  TxtStringTooLo:	.byte "string too lon", 'g'+$80		;	[A2D5]
00A2D9  2  4E 47 20 54  
00A2DD  2  4F 4F 20 4C  
00A2E4  2  46 49 4C 45  TxtFileData:		.byte "file dat", 'a'+$80		;	[A2E4]
00A2E8  2  20 44 41 54  
00A2EC  2  C1           
00A2ED  2  46 4F 52 4D  TxtFormulaTooC:		.byte "formula too comple", 'x'+$80	;	[A2ED]
00A2F1  2  55 4C 41 20  
00A2F5  2  54 4F 4F 20  
00A300  2  43 41 4E 27  TxtCantContinue:	.byte "can't continu", 'e'+$80		;	[A300]
00A304  2  54 20 43 4F  
00A308  2  4E 54 49 4E  
00A30E  2  55 4E 44 45  TxtUndefdFunct:		.byte "undef'd functio", 'n'+$80	;	[A30E]
00A312  2  46 27 44 20  
00A316  2  46 55 4E 43  
00A31E  2  56 45 52 49  TxtVerify:		.byte "verif", 'y'+$80			;	[A31E]
00A322  2  46 D9        
00A324  2  4C 4F 41 C4  TxtLoad:		.byte "loa", 'd'+$80
00A328  2               
00A328  2               
00A328  2               ;******************************************************************************
00A328  2               ;
00A328  2               ; error message pointer table
00A328  2               ;
00A328  2               AddrErrorMsg:				;				[A328]
00A328  2  9E A1        .word	TxtTooManyFile			; $01	TOO MANY FILES
00A32A  2  AC A1        .word	TxtFileOpen			; $02	FILE OPEN
00A32C  2  B5 A1        .word	TxtFileNotOpen			; $03	FILE NOT OPEN
00A32E  2  C2 A1        .word	TxtFileNotFound			; $04	FILE NOT FOUND
00A330  2  D0 A1        .word	TxtDevNotPrese			; $05	DEVICE NOT PRESENT
00A332  2  E2 A1        .word	TxtNotInputFile			; $06	NOT INPUT FILE
00A334  2  F0 A1        .word	TxtNotOutputFi			; $07	NOT OUTPUT FILE
00A336  2  FF A1        .word	TxtMissingFile			; $08	MISSING FILE NAME
00A338  2  10 A2        .word	TxtIllegalDevi			; $09	ILLEGAL DEVICE NUMBER
00A33A  2  25 A2        .word	TxtNextWithout			; $0A	NEXT WITHOUT FOR
00A33C  2  35 A2        .word	TxtSyntax			; $0B	SYNTAX
00A33E  2  3B A2        .word	TxtReturnWitho			; $0C	RETURN WITHOUT GOSUB
00A340  2  4F A2        .word	TxtOutOfData			; $0D	OUT OF DATA
00A342  2  5A A2        .word	TxtIllegalQuan			; $0E	ILLEGAL QUANTITY
00A344  2  6A A2        .word	TxtOverflow			; $0F	OVERFLOW
00A346  2  72 A2        .word	TxtOutOfMemory			; $10	OUT OF MEMORY
00A348  2  7F A2        .word	TxtUndefdState			; $11	UNDEF'D STATEMENT
00A34A  2  90 A2        .word	TxtBadSubscrip			; $12	BAD SUBSCRIPT
00A34C  2  9D A2        .word	TxtRedimdArray			; $13	REDIM'D ARRAY
00A34E  2  AA A2        .word	TxtDivisByZero			; $14	DIVISION BY ZERO
00A350  2  BA A2        .word	TxtIllegalDire			; $15	ILLEGAL DIRECT
00A352  2  C8 A2        .word	TxtTypeMismatc			; $16	TYPE MISMATCH
00A354  2  D5 A2        .word	TxtStringTooLo			; $17	STRING TOO LONG
00A356  2  E4 A2        .word	TxtFileData			; $18	FILE DATA
00A358  2  ED A2        .word	TxtFormulaTooC			; $19	FORMULA TOO COMPLEX
00A35A  2  00 A3        .word	TxtCantContinue			; $1A	CAN'T CONTINUE
00A35C  2  0E A3        .word	TxtUndefdFunct			; $1B	UNDEF'D FUNCTION
00A35E  2  1E A3        .word	TxtVerify			; $1C	VERIFY
00A360  2  24 A3        .word	TxtLoad				; $1D	LOAD
00A362  2  83 A3        .word	TxtBreak2			; $1E	BREAK
00A364  2               
00A364  2               
00A364  2               ;******************************************************************************
00A364  2               ;
00A364  2               ; BASIC messages
00A364  2               ;
00A364  2  0D 4F 4B 0D  TxtOK:		.byte $0D, "ok", $0D, $00
00A368  2  00           
00A369  2  20 20 45 52  TxtError:	.byte "  error", $00
00A36D  2  52 4F 52 00  
00A371  2  20 49 4E 20  TxtIn:		.byte " in ", $00
00A375  2  00           
00A376  2  0D 0A 52 45  TxtReady:	.byte $0D, $0A, "ready.", $0D, $0A, $00
00A37A  2  41 44 59 2E  
00A37E  2  0D 0A 00     
00A381  2  0D 0A        TxtBreak:	.byte $0D, $0A
00A383  2  42 52 45 41  TxtBreak2:	.byte "break", $00
00A387  2  4B 00        
00A389  2               
00A389  2               
00A389  2  A0           A390:		.byte	$A0		; unused
00A38A  2               
00A38A  2               
00A38A  2               ;******************************************************************************
00A38A  2               ;
00A38A  2               ; search the stack for FOR or GOSUB activity
00A38A  2               ; return Zb=1 if FOR variable found
00A38A  2               ;
00A38A  2               SrchForNext:				;				[A38A]
00A38A  2  BA           	tsx				; copy stack pointer
00A38B  2  E8           	inx				; +1 pass return address
00A38C  2  E8           	inx				; +2 pass return address
00A38D  2  E8           	inx				; +3 pass calling routine return address
00A38E  2  E8           	inx				; +4 pass calling routine return address
00A38F  2               A_A38F:					;				[A38F]
00A38F  2  BD 01 01     	lda	STACK+1,X		; get the token byte from the stack
00A392  2  C9 81        	cmp	#TK_FOR			; is it the FOR token
00A394  2  D0 21        	bne	A_A3B7			; if not FOR token just exit
00A396  2               
00A396  2               ; it was the FOR token
00A396  2  A5 4A        	lda	FORPNT+1		; get FOR/NEXT variable pointer HB
00A398  2  D0 0A        	bne	A_A3A4			; branch if not null
00A39A  2               
00A39A  2  BD 02 01     	lda	STACK+2,X		; get FOR variable pointer LB
00A39D  2  85 49        	sta	FORPNT			; save FOR/NEXT variable pointer LB
00A39F  2  BD 03 01     	lda	STACK+3,X		; get FOR variable pointer HB
00A3A2  2  85 4A        	sta	FORPNT+1		; save FOR/NEXT variable pointer HB
00A3A4  2               A_A3A4:					;				[A3A4]
00A3A4  2  DD 03 01     	cmp	STACK+3,X		; compare variable pointer with stacked
00A3A7  2               					; variable pointer HB
00A3A7  2  D0 07        	bne	A_A3B0			; branch if no match
00A3A9  2               
00A3A9  2  A5 49        	lda	FORPNT			; get FOR/NEXT variable pointer LB
00A3AB  2  DD 02 01     	cmp	STACK+2,X		; compare variable pointer with stacked
00A3AE  2               					; variable pointer LB
00A3AE  2  F0 07        	beq	A_A3B7			; exit if match found
00A3B0  2               
00A3B0  2               A_A3B0:					;				[A3B0]
00A3B0  2  8A           	txa				; copy index
00A3B1  2  18           	clc				; clear carry for add
00A3B2  2  69 12        	adc	#$12			; add FOR stack use size
00A3B4  2  AA           	tax				; copy back to index
00A3B5  2  D0 D8        	bne	A_A38F			; loop if not at start of stack
00A3B7  2               A_A3B7:					;				[A3B7]
00A3B7  2  60           	rts
00A3B8  2               
00A3B8  2               
00A3B8  2               ;******************************************************************************
00A3B8  2               ;
00A3B8  2               ; Move a block of memory
00A3B8  2               ; - open up a space in the memory, set the end of arrays
00A3B8  2               ;
00A3B8  2               MoveBlock:				;				[A3B8]
00A3B8  2  20 08 A4     	jsr	CheckAvailMem		; check available memory, do out of
00A3BB  2               					; memory error if no room	[A408]
00A3BB  2  85 31        	sta	STREND			; set end of arrays LB
00A3BD  2  84 32        	sty	STREND+1		; set end of arrays HB
00A3BF  2               
00A3BF  2               ; - open up a space in the memory, don't set the array end
00A3BF  2               MoveBlock2:				;				[A3BF]
00A3BF  2  38           	sec				; set carry for subtract
00A3C0  2  A5 5A        	lda	FacTempStor+3		; get block end LB
00A3C2  2  E5 5F        	sbc	FacTempStor+8		; subtract block start LB
00A3C4  2  85 22        	sta	INDEX			; save MOD(block length/$100) byte
00A3C6  2               
00A3C6  2  A8           	tay				; copy MOD(block length/$100) byte to Y
00A3C7  2  A5 5B        	lda	FacTempStor+4		; get block end HB
00A3C9  2  E5 60        	sbc	FacTempStor+9		; subtract block start HB
00A3CB  2  AA           	tax				; copy block length HB to X
00A3CC  2               
00A3CC  2  E8           	inx				; +1 to allow for count=0 exit
00A3CD  2               
00A3CD  2  98           	tya				; copy block length LB to A
00A3CE  2  F0 23        	beq	A_A3F3			; branch if length LB=0
00A3D0  2               
00A3D0  2               ; block is (X-1)*256+Y bytes, do the Y bytes first
00A3D0  2  A5 5A        	lda	FacTempStor+3		; get block end LB
00A3D2  2  38           	sec				; set carry for subtract
00A3D3  2  E5 22        	sbc	INDEX			; subtract MOD(block length/$100) byte
00A3D5  2  85 5A        	sta	FacTempStor+3		; save corrected old block end LB
00A3D7  2  B0 03        	bcs	A_A3DC			; branch if no underflow
00A3D9  2               
00A3D9  2  C6 5B        	dec	FacTempStor+4		; else decrement block end HB
00A3DB  2  38           	sec				; set carry for subtract
00A3DC  2               A_A3DC:					;				[A3DC]
00A3DC  2  A5 58        	lda	FacTempStor+1		; get destination end LB
00A3DE  2  E5 22        	sbc	INDEX			; subtract MOD(block length/$100) byte
00A3E0  2  85 58        	sta	FacTempStor+1		; save modified new block end LB
00A3E2  2  B0 08        	bcs	A_A3EC			; branch if no underflow
00A3E4  2               
00A3E4  2  C6 59        	dec	FacTempStor+2		; else decrement block end HB
00A3E6  2  90 04        	bcc	A_A3EC			; branch always
00A3E8  2               A_A3E8:					;				[A3E8]
00A3E8  2  B1 5A        	lda	(FacTempStor+3),Y	; get byte from source
00A3EA  2  91 58        	sta	(FacTempStor+1),Y	; copy byte to destination
00A3EC  2               A_A3EC:					;				[A3EC]
00A3EC  2  88           	dey				; decrement index
00A3ED  2  D0 F9        	bne	A_A3E8			; loop until Y=0
00A3EF  2               
00A3EF  2               ; now do Y=0 indexed byte
00A3EF  2  B1 5A        	lda	(FacTempStor+3),Y	; get byte from source
00A3F1  2  91 58        	sta	(FacTempStor+1),Y	; save byte to destination
00A3F3  2               A_A3F3:					;				[A3F3]
00A3F3  2  C6 5B        	dec	FacTempStor+4		; decrement source pointer HB
00A3F5  2  C6 59        	dec	FacTempStor+2		; decrement destination pointer HB
00A3F7  2               
00A3F7  2  CA           	dex				; decrement block count
00A3F8  2  D0 F2        	bne	A_A3EC			; loop until count = $0
00A3FA  2               
00A3FA  2  60           	rts
00A3FB  2               
00A3FB  2               
00A3FB  2               ;******************************************************************************
00A3FB  2               ;
00A3FB  2               ; check room on stack for A bytes
00A3FB  2               ; if stack too deep do out of memory error
00A3FB  2               ;
00A3FB  2               CheckRoomStack:				;				[A3FB]
00A3FB  2  0A           	asl				; *2
00A3FC  2  69 3E        	adc	#$3E			; need at least $3E bytes free
00A3FE  2  B0 35        	bcs	OutOfMemory		; if overflow go do out of memory error
00A400  2               					; then warm start
00A400  2  85 22        	sta	INDEX			; save result in temp byte
00A402  2               
00A402  2  BA           	tsx				; copy stack
00A403  2  E4 22        	cpx	INDEX			; compare new limit with stack
00A405  2  90 2E        	bcc	OutOfMemory		; if stack < limit do out of memory
00A407  2               					; error then warm start
00A407  2  60           	rts
00A408  2               
00A408  2               
00A408  2               ;******************************************************************************
00A408  2               ;
00A408  2               ; check available memory, do out of memory error if no room
00A408  2               ;
00A408  2               CheckAvailMem:
00A408  2  C4 34        	cpy	FRETOP+1		; compare with bottom of string space HB
00A40A  2  90 28        	bcc	A_A434			; if less then exit (is ok)
00A40C  2  D0 04        	bne	A_A412			; skip next test if greater (tested <)
00A40E  2               
00A40E  2               ; HB was =, now do LB
00A40E  2  C5 33        	cmp	FRETOP			; compare with bottom of string space LB
00A410  2  90 22        	bcc	A_A434			; if less then exit (is ok)
00A412  2               
00A412  2               ; address is > string storage ptr (oops!)
00A412  2               A_A412:					;				[A412]
00A412  2  48           	pha				; push address LB
00A413  2               
00A413  2  A2 09        	ldx	#$09			; set index to save FacTempStor to
00A415  2               					; FacTempStor+9 inclusive
00A415  2  98           	tya				; copy address HB (to push on stack)
00A416  2               
00A416  2               ; save misc numeric work area
00A416  2               A_A416:					;				[A416]
00A416  2  48           	pha				; push byte
00A417  2               
00A417  2  B5 57        	lda	FacTempStor,X		; get byte from FacTempStor to
00A419  2               					; FacTempStor+9
00A419  2  CA           	dex				; decrement index
00A41A  2  10 FA        	bpl	A_A416			; loop until all done
00A41C  2               
00A41C  2  20 26 B5     	jsr	CollectGarbage		; do garbage collection routine	[B526]
00A41F  2               
00A41F  2               ; restore misc numeric work area
00A41F  2  A2 F7        	ldx	#$F7			; set index to restore bytes
00A421  2               A_A421:					;				[A421]
00A421  2  68           	pla				; pop byte
00A422  2  95 61        	sta	FacTempStor+9+1,X	; save byte to FacTempStor to
00A424  2               					; FacTempStor+9
00A424  2  E8           	inx				; increment index
00A425  2  30 FA        	bmi	A_A421			; loop while -ve
00A427  2               
00A427  2  68           	pla				; pop address HB
00A428  2  A8           	tay				; copy back to Y
00A429  2               
00A429  2  68           	pla				; pop address LB
00A42A  2               
00A42A  2  C4 34        	cpy	FRETOP+1		; compare with bottom of string space HB
00A42C  2  90 06        	bcc	A_A434			; if less then exit (is ok)
00A42E  2               
00A42E  2  D0 05        	bne	OutOfMemory		; if greater do out of memory error
00A430  2               					; then warm start
00A430  2               ; HB was =, now do LB
00A430  2  C5 33        	cmp	FRETOP			; compare with bottom of string space LB
00A432  2  B0 01        	bcs	OutOfMemory		; if >= do out of memory error then
00A434  2               					; warm start
00A434  2               ; ok exit, carry clear
00A434  2               A_A434:					;				[A434]
00A434  2  60           	rts
00A435  2               
00A435  2               
00A435  2               ;******************************************************************************
00A435  2               ;
00A435  2               ; do out of memory error then warm start
00A435  2               ;
00A435  2               OutOfMemory:
00A435  2  A2 10        	ldx	#$10			; error code $10, out of memory error
00A437  2               
00A437  2               ;******************************************************************************
00A437  2               ;
00A437  2               ; do error #X then warm start
00A437  2               ;
00A437  2               OutputErrMsg:
00A437  2  6C 00 03     	jmp	(IERROR)		; do error message
00A43A  2               
00A43A  2               
00A43A  2               ;******************************************************************************
00A43A  2               ;
00A43A  2               ; do error #X then warm start, the error message vector is initialised to point
00A43A  2               ; here
00A43A  2               ;
00A43A  2               OutputErrMsg2:				;				[A43A]
00A43A  2  8A           	txa				; copy error number
00A43B  2  0A           	asl				; *2
00A43C  2  AA           	tax				; copy to index
00A43D  2               
00A43D  2  BD 26 A3     	lda	AddrErrorMsg-2,X	; get error message pointer LB
00A440  2  85 22        	sta	INDEX			; save it
00A442  2               
00A442  2  BD 27 A3     	lda	AddrErrorMsg-1,X	; get error message pointer HB
00A445  2  85 23        	sta	INDEX+1			; save it
00A447  2               
00A447  2  20 CC FF     	jsr	CloseIoChannls		; close input and output channels [FFCC]
00A44A  2               
00A44A  2  A9 00        	lda	#$00			; clear A
00A44C  2  85 13        	sta	CurIoChan		; clear current I/O channel, flag
00A44E  2               					; default
00A44E  2  20 D7 AA     	jsr	OutCRLF			; print CR/LF			[AAD7]
00A451  2  20 45 AB     	jsr	PrintQuestMark		; print "?"			[AB45]
00A454  2               
00A454  2  A0 00        	ldy	#$00			; clear index
00A456  2               A_A456:					;				[A456]
00A456  2  B1 22        	lda	(INDEX),Y		; get byte from message
00A458  2  48           	pha				; save status
00A459  2  29 7F        	and	#$7F			; mask 0xxx xxxx, clear b7
00A45B  2  20 47 AB     	jsr	PrintChar		; output character		[CB47]
00A45E  2               
00A45E  2  C8           	iny				; increment index
00A45F  2  68           	pla				; restore status
00A460  2  10 F4        	bpl	A_A456			; loop if character was not end marker
00A462  2               
00A462  2  20 7A A6     	jsr	ClrBasicStack		; flush BASIC stack and clear continue
00A465  2               					; pointer			[A67A]
00A465  2  A9 69        	lda	#<TxtError		; set " ERROR" pointer LB
00A467  2  A0 A3        	ldy	#>TxtError		; set " ERROR" pointer HB
00A469  2               
00A469  2               
00A469  2               ;******************************************************************************
00A469  2               ;
00A469  2               ; print string and do warm start, break entry
00A469  2               ;
00A469  2               OutputMessage:				;				[A469]
00A469  2  20 1E AB     	jsr	OutputString		; print null terminated string	[AB1E]
00A46C  2               
00A46C  2  A4 3A        	ldy	CURLIN+1		; get current line number HB
00A46E  2  C8           	iny				; increment it
00A46F  2  F0 03        	beq	OutputREADY		; branch if was in immediate mode
00A471  2               
00A471  2  20 C2 BD     	jsr	Print_IN		; do " IN " line number message	[BDC2]
00A474  2               
00A474  2               
00A474  2               ;******************************************************************************
00A474  2               ;
00A474  2               ; do warm start, print READY on the screen
00A474  2               ;
00A474  2               OutputREADY:				;				[A474]
00A474  2  A9 76        	lda	#<TxtReady		; set "READY." pointer LB
00A476  2  A0 A3        	ldy	#>TxtReady		; set "READY." pointer HB
00A478  2  20 1E AB     	jsr	OutputString		; print null terminated string	[AB1E]
00A47B  2               
00A47B  2  A9 80        	lda	#$80			; set for control messages only
00A47D  2  20 90 FF     	jsr	CtrlKernalMsg		; control kernal messages	[FF90]
00A480  2               
00A480  2               
00A480  2               ;******************************************************************************
00A480  2               ;
00A480  2               ; Main wait loop
00A480  2               ;
00A480  2               MainWaitLoop:
00A480  2  6C 02 03     	jmp	(IMAIN)			; do BASIC warm start
00A483  2               
00A483  2               
00A483  2               ;******************************************************************************
00A483  2               ;
00A483  2               ; BASIC warm start, the warm start vector is initialised to point here
00A483  2               ;
00A483  2               MainWaitLoop2:				;				[A483]
00A483  2  20 60 A5     	jsr	InputNewLine		; call for BASIC input		[A560]
00A486  2  86 7A        	stx	TXTPTR			; save BASIC execute pointer LB
00A488  2  84 7B        	sty	TXTPTR+1		; save BASIC execute pointer HB
00A48A  2               
00A48A  2  20 73 00     	jsr	CHRGET			; increment and scan memory	[0073]
00A48D  2  AA           	tax				; copy byte to set flags
00A48E  2  F0 F0        	beq	MainWaitLoop		; loop if no input
00A490  2               
00A490  2               ; got to interpret the input line now ....
00A490  2  A2 FF        	ldx	#$FF			; current line HB to -1, indicates
00A492  2               					; immediate mode
00A492  2  86 3A        	stx	CURLIN+1		; set current line number HB
00A494  2  90 06        	bcc	A_A49C			; if numeric character go handle new
00A496  2               					; BASIC line
00A496  2               ; no line number .. immediate mode
00A496  2               S_A496:
00A496  2  20 79 A5     	jsr	Text2TokenCode		; crunch keywords into BASIC tokens
00A499  2               					;				[A579]
00A499  2  4C E1 A7     	jmp	InterpretLoop2		; go scan and interpret code	[A7E1]
00A49C  2               
00A49C  2               
00A49C  2               ;******************************************************************************
00A49C  2               ;
00A49C  2               ; handle new BASIC line
00A49C  2               ;
00A49C  2               A_A49C:					;				[A49C]
00A49C  2  20 6B A9     	jsr	LineNum2Addr		; get fixed-point number into temporary
00A49F  2               					; integer			[A96B]
00A49F  2  20 79 A5     	jsr	Text2TokenCode		; crunch keywords into BASIC tokens
00A4A2  2               					;				[A579]
00A4A2  2  84 0B        	sty	COUNT			; save index pointer to end of crunched
00A4A4  2               					; line
00A4A4  2  20 13 A6     	jsr	CalcStartAddr		; search BASIC for temporary integer
00A4A7  2               					; line number			[A613]
00A4A7  2  90 44        	bcc	A_A4ED			; if not found skip the line delete
00A4A9  2               
00A4A9  2               ; line # already exists so delete it
00A4A9  2  A0 01        	ldy	#$01			; set index to next line pointer HB
00A4AB  2  B1 5F        	lda	(FacTempStor+8),Y	; get next line pointer HB
00A4AD  2  85 23        	sta	INDEX+1			; save it
00A4AF  2               
00A4AF  2  A5 2D        	lda	VARTAB			; get start of variables LB
00A4B1  2  85 22        	sta	INDEX			; save it
00A4B3  2               
00A4B3  2  A5 60        	lda	FacTempStor+9		; get found line pointer HB
00A4B5  2  85 25        	sta	INDEX+3			; save it
00A4B7  2               
00A4B7  2  A5 5F        	lda	FacTempStor+8		; get found line pointer LB
00A4B9  2  88           	dey				; decrement index
00A4BA  2  F1 5F        	sbc	(FacTempStor+8),Y	; subtract next line pointer LB
00A4BC  2  18           	clc				; clear carry for add
00A4BD  2  65 2D        	adc	VARTAB			; add start of variables LB
00A4BF  2  85 2D        	sta	VARTAB			; set start of variables LB
00A4C1  2  85 24        	sta	INDEX+2			; save destination pointer LB
00A4C3  2               
00A4C3  2  A5 2E        	lda	VARTAB+1		; get start of variables HB
00A4C5  2  69 FF        	adc	#$FF			; -1 + carry
00A4C7  2  85 2E        	sta	VARTAB+1		; set start of variables HB
00A4C9  2               
00A4C9  2  E5 60        	sbc	FacTempStor+9		; subtract found line pointer HB
00A4CB  2  AA           	tax				; copy to block count
00A4CC  2               
00A4CC  2  38           	sec				; set carry for subtract
00A4CD  2  A5 5F        	lda	FacTempStor+8		; get found line pointer LB
00A4CF  2  E5 2D        	sbc	VARTAB			; subtract start of variables LB
00A4D1  2  A8           	tay				; copy to bytes in first block count
00A4D2  2  B0 03        	bcs	A_A4D7			; branch if no underflow
00A4D4  2               
00A4D4  2  E8           	inx				; increment block count, correct for =
00A4D5  2               					; 0 loop exit
00A4D5  2  C6 25        	dec	INDEX+3			; decrement destination HB
00A4D7  2               A_A4D7:					;				[A4D7]
00A4D7  2  18           	clc				; clear carry for add
00A4D8  2  65 22        	adc	INDEX			; add source pointer LB
00A4DA  2  90 03        	bcc	A_A4DF			; branch if no overflow
00A4DC  2               
00A4DC  2  C6 23        	dec	INDEX+1			; else decrement source pointer HB
00A4DE  2  18           	clc				; clear carry
00A4DF  2               
00A4DF  2               ; close up memory to delete old line
00A4DF  2               A_A4DF:					;				[A4DF]
00A4DF  2  B1 22        	lda	(INDEX),Y		; get byte from source
00A4E1  2  91 24        	sta	(INDEX+2),Y		; copy to destination
00A4E3  2  C8           	iny				; increment index
00A4E4  2  D0 F9        	bne	A_A4DF			; while <> 0 do this block
00A4E6  2               
00A4E6  2  E6 23        	inc	INDEX+1			; increment source pointer HB
00A4E8  2  E6 25        	inc	INDEX+3			; increment destination pointer HB
00A4EA  2               
00A4EA  2  CA           	dex				; decrement block count
00A4EB  2  D0 F2        	bne	A_A4DF			; loop until all done
00A4ED  2               
00A4ED  2               ; got new line in buffer and no existing same #
00A4ED  2               A_A4ED:					;				[A4ED]
00A4ED  2  20 59 A6     	jsr	ResetExecPtr		; reset execution to start, clear
00A4F0  2               					; variables, flush stack	[A659]
00A4F0  2               					; and return
00A4F0  2  20 33 A5     	jsr	BindLine		; rebuild BASIC line chaining	[A533]
00A4F3  2               
00A4F3  2  AD 00 02     	lda	CommandBuf		; get first byte from buffer
00A4F6  2  F0 88        	beq	MainWaitLoop		; if no line go do BASIC warm start
00A4F8  2               
00A4F8  2               ; else insert line into memory
00A4F8  2  18           	clc				; clear carry for add
00A4F9  2  A5 2D        	lda	VARTAB			; get start of variables LB
00A4FB  2  85 5A        	sta	FacTempStor+3		; save as source end pointer LB
00A4FD  2               
00A4FD  2  65 0B        	adc	COUNT			; add index pointer to end of crunched
00A4FF  2               					; line
00A4FF  2  85 58        	sta	FacTempStor+1		; save as destination end pointer LB
00A501  2               
00A501  2  A4 2E        	ldy	VARTAB+1		; get start of variables HB
00A503  2  84 5B        	sty	FacTempStor+4		; save as source end pointer HB
00A505  2  90 01        	bcc	A_A508			; branch if no carry to HB
00A507  2               
00A507  2  C8           	iny				; else increment HB
00A508  2               A_A508:					;				[A508]
00A508  2  84 59        	sty	FacTempStor+2		; save as destination end pointer HB
00A50A  2               
00A50A  2  20 B8 A3     	jsr	MoveBlock		; open up space in memory	[A3B8]
00A50D  2               
00A50D  2               ;******************************************************************************
00A50D  2               ;
00A50D  2               ; Most of what remains to do is copy the crunched line into the space opened up
00A50D  2               ; in memory. However, before the crunched line comes the next line pointer and
00A50D  2               ; the line number, the line number is retrieved from the temporary integer and
00A50D  2               ; stored in memory. This overwrites the bottom two bytes on the stack. Next the
00A50D  2               ; line is copied and the next line pointer is filled with whatever was in two
00A50D  2               ; bytes above the line number in the stack. This is OK because the line pointer
00A50D  2               ; gets fixed in the line chain re-build.
00A50D  2               ;
00A50D  2  A5 14        	lda	LINNUM			; get line number LB
00A50F  2  A4 15        	ldy	LINNUM+1		; get line number HB
00A511  2  8D FE 01     	sta	STACK+$FE		; save line number LB before crunched
00A514  2               					; line
00A514  2  8C FF 01     	sty	CommandBuf-1		; save line number HB before crunched
00A517  2               					; line
00A517  2               
00A517  2  A5 31        	lda	STREND			; get end of arrays LB
00A519  2  A4 32        	ldy	STREND+1		; get end of arrays HB
00A51B  2  85 2D        	sta	VARTAB			; set start of variables LB
00A51D  2  84 2E        	sty	VARTAB+1		; set start of variables HB
00A51F  2               
00A51F  2  A4 0B        	ldy	COUNT			; get index to end of crunched line
00A521  2  88           	dey				; -1
00A522  2               A_A522:					;				[A522]
00A522  2  B9 FC 01     	lda	STACK+$FC,Y		; get byte from crunched line
00A525  2  91 5F        	sta	(FacTempStor+8),Y	; save byte to memory
00A527  2               
00A527  2  88           	dey				; decrement index
00A528  2  10 F8        	bpl	A_A522			; loop while more to do
00A52A  2               
00A52A  2               ;******************************************************************************
00A52A  2               ;
00A52A  2               ; reset execution, clear variables, flush stack, rebuild BASIC chain and do
00A52A  2               ; warm start
00A52A  2               ;
00A52A  2               J_A52A:					;				[A52A]
00A52A  2  20 59 A6     	jsr	ResetExecPtr		; reset execution to start, clear
00A52D  2               					; variables and flush stack	[A659]
00A52D  2  20 33 A5     	jsr	BindLine		; rebuild BASIC line chaining	[A533]
00A530  2  4C 80 A4     	jmp	MainWaitLoop		; go do BASIC warm start	[A480]
00A533  2               
00A533  2               
00A533  2               ;******************************************************************************
00A533  2               ;
00A533  2               ; rebuild BASIC line chaining
00A533  2               ;
00A533  2               BindLine:				;				[A533]
00A533  2  A5 2B        	lda	TXTTAB			; get start of memory LB
00A535  2  A4 2C        	ldy	TXTTAB+1		; get start of memory HB
00A537  2  85 22        	sta	INDEX			; set line start pointer LB
00A539  2  84 23        	sty	INDEX+1			; set line start pointer HB
00A53B  2  18           	clc				; clear carry for add
00A53C  2               A_A53C:					;				[A53C]
00A53C  2  A0 01        	ldy	#$01			; set index to pointer to next line HB
00A53E  2  B1 22        	lda	(INDEX),Y		; get pointer to next line HB
00A540  2  F0 1D        	beq	A_A55F			; exit if null, [EOT]
00A542  2               
00A542  2  A0 04        	ldy	#$04			; point to first code byte of line
00A544  2               					; there is always 1 byte + [EOL] as null
00A544  2               					; entries are deleted
00A544  2               A_A544:					;				[A544]
00A544  2  C8           	iny				; next code byte
00A545  2  B1 22        	lda	(INDEX),Y		; get byte
00A547  2  D0 FB        	bne	A_A544			; loop if not [EOL]
00A549  2               
00A549  2  C8           	iny				; point to byte past [EOL], start of
00A54A  2               					; next line
00A54A  2  98           	tya				; copy it
00A54B  2               
00A54B  2  65 22        	adc	INDEX			; add line start pointer LB
00A54D  2  AA           	tax				; copy to X
00A54E  2               
00A54E  2  A0 00        	ldy	#$00			; clear index, point to this line's next
00A550  2               					; line pointer
00A550  2  91 22        	sta	(INDEX),Y		; set next line pointer LB
00A552  2               
00A552  2  A5 23        	lda	INDEX+1			; get line start pointer HB
00A554  2  69 00        	adc	#$00			; add any overflow
00A556  2  C8           	iny				; increment index to HB
00A557  2  91 22        	sta	(INDEX),Y		; set next line pointer HB
00A559  2  86 22        	stx	INDEX			; set line start pointer LB
00A55B  2  85 23        	sta	INDEX+1			; set line start pointer HB
00A55D  2  90 DD        	bcc	A_A53C			; go do next line, branch always
00A55F  2               
00A55F  2               A_A55F:					;				[A55F]
00A55F  2  60           	rts
00A560  2               
00A560  2               
00A560  2               ;******************************************************************************
00A560  2               ;
00A560  2               ; call for BASIC input
00A560  2               ;
00A560  2               InputNewLine:				;				[A560]
00A560  2  A2 00        	ldx	#$00			; set channel $00, keyboard
00A562  2               A_A562:					;				[A562]
00A562  2  20 12 E1     	jsr	InpCharErrChan		; input character from channel with
00A565  2               					; error check			[E112]
00A565  2  C9 0D        	cmp	#$0D			; compare with [CR]
00A567  2  F0 0D        	beq	A_A576			; if [CR] set XY to Command buffer - 1,
00A569  2               					; print [CR] and exit
00A569  2               ; character was not [CR]
00A569  2  9D 00 02     	sta	CommandBuf,X		; save character to buffer
00A56C  2               
00A56C  2  E8           	inx				; increment buffer index
00A56D  2  E0 59        	cpx	#$59			; compare with max+1
00A56F  2  90 F1        	bcc	A_A562			; branch if < max+1
00A571  2               
00A571  2  A2 17        	ldx	#$17			; error $17, string too long error
00A573  2  4C 37 A4     	jmp	OutputErrMsg		; do error #X then warm start	[A437]
00A576  2               
00A576  2               A_A576:					;				[A576]
00A576  2  4C CA AA     	jmp	SetXY2CmdBuf		; set XY to Command buffer - 1 and
00A579  2               					; print [CR]			[AACA]
00A579  2               
00A579  2               
00A579  2               ;******************************************************************************
00A579  2               ;
00A579  2               ; crunch BASIC tokens vector
00A579  2               ;
00A579  2               Text2TokenCode:				;				[A579]
00A579  2  6C 04 03     	jmp	(ICRNCH)		; do crunch BASIC tokens
00A57C  2               
00A57C  2               
00A57C  2               ;******************************************************************************
00A57C  2               ;
00A57C  2               ; crunch BASIC tokens, the crunch BASIC tokens vector is initialised to point
00A57C  2               ; here
00A57C  2               ;
00A57C  2               Text2TokenCod2:				;				[A57C]
00A57C  2  A6 7A        	ldx	TXTPTR			; get BASIC execute pointer LB
00A57E  2  A0 04        	ldy	#$04			; set save index
00A580  2  84 0F        	sty	GARBFL			; clear open quote/DATA flag
00A582  2               A_A582:					;				[A582]
00A582  2  BD 00 02     	lda	CommandBuf,X		; get a byte from the input buffer
00A585  2  10 07        	bpl	A_A58E			; if b7 clear go do crunching
00A587  2               
00A587  2  C9 FF        	cmp	#TK_PI			; compare with the token for PI, this
00A589  2               					; toke is input directly from the
00A589  2               					; keyboard as the PI character
00A589  2  F0 3E        	beq	A_A5C9			; if PI then save byte and continue
00A58B  2               					; crunching
00A58B  2               
00A58B  2               ; this is the bit of code that stops you being able to enter some keywords as
00A58B  2               ; just single shifted characters. If this dropped through you would be able to
00A58B  2               ; enter GOTO as just [SHIFT]G
00A58B  2  E8           	inx				; increment read index
00A58C  2  D0 F4        	bne	A_A582			; loop if more to do, branch always
00A58E  2               
00A58E  2               A_A58E:					;				[A58E]
00A58E  2  C9 20        	cmp	#' '			; compare with [SPACE]
00A590  2  F0 37        	beq	A_A5C9			; if [SPACE] save byte then continue
00A592  2               					; crunching
00A592  2               
00A592  2  85 08        	sta	ENDCHR			; save buffer byte as search character
00A594  2               
00A594  2  C9 22        	cmp	#'"'			; compare with quote character
00A596  2  F0 56        	beq	A_A5EE			; if quote go copy quoted string
00A598  2               
00A598  2  24 0F        	bit	GARBFL			; get open quote/DATA token flag
00A59A  2  70 2D        	bvs	A_A5C9			; branch if b6 of Oquote set, was DATA
00A59C  2               					; go save byte then continue crunching
00A59C  2               
00A59C  2  C9 3F        	cmp	#'?'			; compare with "?" character
00A59E  2  D0 04        	bne	A_A5A4			; if not "?" continue crunching
00A5A0  2               
00A5A0  2  A9 99        	lda	#TK_PRINT		; else the keyword token is $99, PRINT
00A5A2  2  D0 25        	bne	A_A5C9			; go save byte then continue crunching,
00A5A4  2               					; branch always
00A5A4  2               A_A5A4:					;				[A5A4]
00A5A4  2  C9 30        	cmp	#'0'			; compare with "0"
00A5A6  2  90 04        	bcc	A_A5AC			; branch if <, continue crunching
00A5A8  2               
00A5A8  2  C9 3C        	cmp	#'<'			; compare with "<"
00A5AA  2  90 1D        	bcc	A_A5C9			; if <, 0123456789:; go save byte then
00A5AC  2               					; continue crunching
00A5AC  2               ; gets here with next character not numeric, ";" or ":"
00A5AC  2               A_A5AC:					;				[A5AC]
00A5AC  2  84 71        	sty	FBUFPT			; copy save index
00A5AE  2               
00A5AE  2  A0 00        	ldy	#$00			; clear table pointer
00A5B0  2  84 0B        	sty	COUNT			; clear word index
00A5B2  2               
00A5B2  2  88           	dey				; adjust for pre increment loop
00A5B3  2               
00A5B3  2  86 7A        	stx	TXTPTR			; save BASIC execute pointer LB, buffer
00A5B5  2               					; index
00A5B5  2  CA           	dex				; adjust for pre increment loop
00A5B6  2               A_A5B6:					;				[A5B6]
00A5B6  2  C8           	iny				; next table byte
00A5B7  2  E8           	inx				; next buffer byte
00A5B8  2               A_A5B8:					;				[A5B8]
00A5B8  2  BD 00 02     	lda	CommandBuf,X		; get byte from input buffer
00A5BB  2  38           	sec				; set carry for subtract
00A5BC  2  F9 9E A0     	sbc	TblBasicCodes,Y		; subtract table byte
00A5BF  2  F0 F5        	beq	A_A5B6			; go compare next if match
00A5C1  2               
00A5C1  2  C9 80        	cmp	#$80			; was it end marker match ?
00A5C3  2  D0 30        	bne	A_A5F5			; branch if not, not found keyword
00A5C5  2               
00A5C5  2               ; actually this works even if the input buffer byte is the end marker, i.e. a
00A5C5  2               ; shifted character. As you can't enter any keywords as a single shifted
00A5C5  2               ; character, see above, you can enter keywords in shorthand by shifting any
00A5C5  2               ; character after the first. so RETURN can be entered as R[SHIFT]E, RE[SHIFT]T,
00A5C5  2               ; RET[SHIFT]U or RETU[SHIFT]R. RETUR[SHIFT]N however will not work because the
00A5C5  2               ; [SHIFT]N will match the RETURN end marker so the routine will try to match
00A5C5  2               ; the next character.
00A5C5  2               
00A5C5  2               ; else found keyword
00A5C5  2  05 0B        	ora	COUNT			; OR with word index, +$80 in A makes
00A5C7  2               					; token
00A5C7  2               A_A5C7:					;				[A5C7]
00A5C7  2  A4 71        	ldy	FBUFPT			; restore save index
00A5C9  2               
00A5C9  2               ; save byte then continue crunching
00A5C9  2               A_A5C9:					;				[A5C9]
00A5C9  2  E8           	inx				; increment buffer read index
00A5CA  2  C8           	iny				; increment save index
00A5CB  2  99 FB 01     	sta	CommandBuf-5,Y		; save byte to output
00A5CE  2               
00A5CE  2  B9 FB 01     	lda	CommandBuf-5,Y		; get byte from output, set flags
00A5D1  2  F0 36        	beq	A_A609			; branch if was null [EOL]
00A5D3  2               
00A5D3  2               ; A holds the token here
00A5D3  2  38           	sec				; set carry for subtract
00A5D4  2  E9 3A        	sbc	#':'			; subtract ":"
00A5D6  2  F0 04        	beq	A_A5DC			; branch if it was (is now $00)
00A5D8  2               
00A5D8  2               ; A now holds token-':'
00A5D8  2  C9 49        	cmp	#TK_DATA-':'		; compare with the token for DATA-':'
00A5DA  2  D0 02        	bne	A_A5DE			; if not DATA go try REM
00A5DC  2               
00A5DC  2               ; token was : or DATA
00A5DC  2               A_A5DC:					;				[A5DC]
00A5DC  2  85 0F        	sta	GARBFL			; save the token-$3A
00A5DE  2               A_A5DE:					;				[A5DE]
00A5DE  2  38           	sec				; set carry for subtract
00A5DF  2  E9 55        	sbc	#TK_REM-':'		; subtract the token for REM-':'
00A5E1  2  D0 9F        	bne	A_A582			; if wasn't REM crunch next bit of line
00A5E3  2               S_A5E3:
00A5E3  2  85 08        	sta	ENDCHR			; else was REM so set search for [EOL]
00A5E5  2               
00A5E5  2               ; loop for "..." etc.
00A5E5  2               A_A5E5:					;				[A5E5]
00A5E5  2  BD 00 02     	lda	CommandBuf,X		; get byte from input buffer
00A5E8  2  F0 DF        	beq	A_A5C9			; if null [EOL] save byte then continue
00A5EA  2               					; crunching
00A5EA  2  C5 08        	cmp	ENDCHR			; compare with stored character
00A5EC  2  F0 DB        	beq	A_A5C9			; if match save byte then continue
00A5EE  2               					; crunching
00A5EE  2               A_A5EE:					;				[A5EE]
00A5EE  2  C8           	iny				; increment save index
00A5EF  2  99 FB 01     	sta	CommandBuf-5,Y		; save byte to output
00A5F2  2               
00A5F2  2  E8           	inx				; increment buffer index
00A5F3  2  D0 F0        	bne	A_A5E5			; loop while <> 0, should never reach 0
00A5F5  2               
00A5F5  2               ; not found keyword this go
00A5F5  2               A_A5F5:					;				[A5F5]
00A5F5  2  A6 7A        	ldx	TXTPTR			; restore BASIC execute pointer LB
00A5F7  2  E6 0B        	inc	COUNT			; increment word index (next word)
00A5F9  2               
00A5F9  2               ; now find end of this word in the table
00A5F9  2               A_A5F9:					;				[A5F9]
00A5F9  2  C8           	iny				; increment table index
00A5FA  2  B9 9D A0     	lda	TblBasicCodes-1,Y	; get table byte
00A5FD  2  10 FA        	bpl	A_A5F9			; loop if not end of word yet
00A5FF  2               
00A5FF  2  B9 9E A0     	lda	TblBasicCodes,Y		; get byte from keyword table
00A602  2  D0 B4        	bne	A_A5B8			; go test next word if not zero byte,
00A604  2               					; end of table
00A604  2               ; reached end of table with no match
00A604  2  BD 00 02     	lda	CommandBuf,X		; restore byte from input buffer
00A607  2  10 BE        	bpl	A_A5C7			; branch always, all unmatched bytes in
00A609  2               					; the buffer are $00 to $7F, go save
00A609  2               					; byte in output and continue crunching
00A609  2               ; reached [EOL]
00A609  2               A_A609:					;				[A609]
00A609  2  99 FD 01     	sta	STACK+$FD,Y		; save [EOL]
00A60C  2               
00A60C  2  C6 7B        	dec	TXTPTR+1		; decrement BASIC execute pointer HB
00A60E  2               
00A60E  2  A9 FF        	lda	#$FF			; point to start of buffer-1
00A610  2  85 7A        	sta	TXTPTR			; set BASIC execute pointer LB
00A612  2               
00A612  2  60           	rts
00A613  2               
00A613  2               
00A613  2               ;******************************************************************************
00A613  2               ;
00A613  2               ; search BASIC for temporary integer line number
00A613  2               ;
00A613  2               CalcStartAddr:				;				[A613]
00A613  2  A5 2B        	lda	TXTTAB			; get start of memory LB
00A615  2  A6 2C        	ldx	TXTTAB+1		; get start of memory HB
00A617  2               
00A617  2               
00A617  2               ;******************************************************************************
00A617  2               ;
00A617  2               ; search Basic for temp integer line number from AX
00A617  2               ; returns carry set if found
00A617  2               ;
00A617  2               CalcStartAddr2:				;				[A617]
00A617  2  A0 01        	ldy	#$01			; set index to next line pointer HB
00A619  2  85 5F        	sta	FacTempStor+8		; save LB as current
00A61B  2  86 60        	stx	FacTempStor+9		; save HB as current
00A61D  2               
00A61D  2  B1 5F        	lda	(FacTempStor+8),Y	; get next line pointer HB from address
00A61F  2  F0 1F        	beq	A_A640			; pointer was zero so done, exit
00A621  2               
00A621  2  C8           	iny				; increment index ...
00A622  2  C8           	iny				; ... to line # HB
00A623  2  A5 15        	lda	LINNUM+1		; get temporary integer HB
00A625  2  D1 5F        	cmp	(FacTempStor+8),Y	; compare with line # HB
00A627  2  90 18        	bcc	A_A641			; exit if temp < this line, target line
00A629  2               					; passed
00A629  2  F0 03        	beq	A_A62E			; go check LB if =
00A62B  2               
00A62B  2  88           	dey				; else decrement index
00A62C  2  D0 09        	bne	A_A637			; branch always
00A62E  2               
00A62E  2               A_A62E:					;				[A62E]
00A62E  2  A5 14        	lda	LINNUM			; get temporary integer LB
00A630  2  88           	dey				; decrement index to line # LB
00A631  2  D1 5F        	cmp	(FacTempStor+8),Y	; compare with line # LB
00A633  2  90 0C        	bcc	A_A641			; exit if temp < this line, target line
00A635  2               					; passed
00A635  2  F0 0A        	beq	A_A641			; exit if temp = (found line#)
00A637  2               
00A637  2               ; not quite there yet
00A637  2               A_A637:					;				[A637]
00A637  2  88           	dey				; decrement index to next line pointer
00A638  2               					; HB
00A638  2  B1 5F        	lda	(FacTempStor+8),Y	; get next line pointer HB
00A63A  2  AA           	tax				; copy to X
00A63B  2               
00A63B  2  88           	dey				; decrement index to next line pointer
00A63C  2               					; LB
00A63C  2  B1 5F        	lda	(FacTempStor+8),Y	; get next line pointer LB
00A63E  2  B0 D7        	bcs	CalcStartAddr2		; go search for line # in temporary
00A640  2               					; integer from AX, carry always set
00A640  2               A_A640:					;				[A640]
00A640  2  18           	clc				; clear found flag
00A641  2               A_A641:					;				[A641]
00A641  2  60           	rts
00A642  2               
00A642  2               
00A642  2               ;******************************************************************************
00A642  2               ;
00A642  2               ; perform NEW
00A642  2               ;
00A642  2               bcNEW:					;				[A642]
00A642  2  D0 FD        	bne	A_A641			; exit if following byte to allow syntax
00A644  2               					; error
00A644  2               bcNEW2:					;				[A644]
00A644  2  A9 00        	lda	#$00			; clear A
00A646  2  A8           	tay				; clear index
00A647  2  91 2B        	sta	(TXTTAB),Y		; clear pointer to next line LB
00A649  2               
00A649  2  C8           	iny				; increment index
00A64A  2  91 2B        	sta	(TXTTAB),Y		; clear pointer to next line HB, erase
00A64C  2               					; program
00A64C  2  A5 2B        	lda	TXTTAB			; get start of memory LB
00A64E  2  18           	clc				; clear carry for add
00A64F  2  69 02        	adc	#$02			; add null program length
00A651  2  85 2D        	sta	VARTAB			; set start of variables LB
00A653  2               
00A653  2  A5 2C        	lda	TXTTAB+1		; get start of memory HB
00A655  2  69 00        	adc	#$00			; add carry
00A657  2  85 2E        	sta	VARTAB+1		; set start of variables HB
00A659  2               
00A659  2               
00A659  2               ;******************************************************************************
00A659  2               ;
00A659  2               ; reset execute pointer and do CLR
00A659  2               ;
00A659  2               ResetExecPtr:				;				[A659]
00A659  2  20 8E A6     	jsr	SetBasExecPtr		; set BASIC execute pointer to start of
00A65C  2               					; memory - 1			[A68E]
00A65C  2  A9 00        	lda	#$00			; set Zb for CLR entry
00A65E  2               
00A65E  2               
00A65E  2               ;******************************************************************************
00A65E  2               ;
00A65E  2               ; perform CLR
00A65E  2               ;
00A65E  2               bcCLR:					;				[A65E]
00A65E  2  D0 2D        	bne	A_A68D			; exit if following byte to allow syntax
00A660  2               					; error
00A660  2               bcCLR2:					;				[A660]
00A660  2  20 E7 FF     	jsr	CloseAllChan		; close all channels and files	[FFE7]
00A663  2               bcCLR3:					;				[A663]
00A663  2  A5 37        	lda	MEMSIZ			; get end of memory LB
00A665  2  A4 38        	ldy	MEMSIZ+1		; get end of memory HB
00A667  2  85 33        	sta	FRETOP			; set bottom of string space LB, clear
00A669  2               					; strings
00A669  2  84 34        	sty	FRETOP+1		; set bottom of string space HB
00A66B  2               
00A66B  2  A5 2D        	lda	VARTAB			; get start of variables LB
00A66D  2  A4 2E        	ldy	VARTAB+1		; get start of variables HB
00A66F  2  85 2F        	sta	ARYTAB			; set end of variables LB, clear
00A671  2               					; variables
00A671  2  84 30        	sty	ARYTAB+1		; set end of variables HB
00A673  2  85 31        	sta	STREND			; set end of arrays LB, clear arrays
00A675  2  84 32        	sty	STREND+1		; set end of arrays HB
00A677  2               
00A677  2               
00A677  2               ;******************************************************************************
00A677  2               ;
00A677  2               ; do RESTORE and clear stack
00A677  2               ;
00A677  2               bcCLR4:					;				[A677]
00A677  2  20 1D A8     	jsr	bcRESTORE		; perform RESTORE		[A81D]
00A67A  2               
00A67A  2               
00A67A  2               ;******************************************************************************
00A67A  2               ;
00A67A  2               ; flush BASIC stack and clear the continue pointer
00A67A  2               ;
00A67A  2               ClrBasicStack:				;				[A67A]
00A67A  2  A2 19        	ldx	#LASTPT+2		; get the descriptor stack start
00A67C  2  86 16        	stx	TEMPPT			; set the descriptor stack pointer
00A67E  2               
00A67E  2  68           	pla				; pull the return address LB
00A67F  2  A8           	tay				; copy it
00A680  2               
00A680  2  68           	pla				; pull the return address HB
00A681  2               
00A681  2  A2 FA        	ldx	#$FA			; set the cleared stack pointer
00A683  2  9A           	txs				; set the stack
00A684  2               
00A684  2  48           	pha				; push the return address HB
00A685  2               
00A685  2  98           	tya				; restore the return address LB
00A686  2  48           	pha				; push the return address LB
00A687  2               
00A687  2  A9 00        	lda	#$00			; clear A
00A689  2  85 3E        	sta	OLDTXT+1		; clear the continue pointer HB
00A68B  2  85 10        	sta	SUBFLG			; clear the subscript/FNX flag
00A68D  2               A_A68D:					;				[A68D]
00A68D  2  60           	rts
00A68E  2               
00A68E  2               
00A68E  2               ;******************************************************************************
00A68E  2               ;
00A68E  2               ; set BASIC execute pointer to start of memory - 1
00A68E  2               ;
00A68E  2               SetBasExecPtr:				;				[A68E]
00A68E  2  18           	clc				; clear carry for add
00A68F  2  A5 2B        	lda	TXTTAB			; get start of memory LB
00A691  2  69 FF        	adc	#$FF			; add -1 LB
00A693  2  85 7A        	sta	TXTPTR			; set BASIC execute pointer LB
00A695  2               
00A695  2  A5 2C        	lda	TXTTAB+1		; get start of memory HB
00A697  2  69 FF        	adc	#$FF			; add -1 HB
00A699  2  85 7B        	sta	TXTPTR+1		; save BASIC execute pointer HB
00A69B  2               
00A69B  2  60           	rts
00A69C  2               
00A69C  2               
00A69C  2               ;******************************************************************************
00A69C  2               ;
00A69C  2               ; perform LIST
00A69C  2               ;
00A69C  2               bcLIST:					;				[A69C]
00A69C  2  90 06        	bcc	A_A6A4			; branch if next character not token
00A69E  2               					; (LIST n...)
00A69E  2  F0 04        	beq	A_A6A4			; branch if next character [NULL] (LIST)
00A6A0  2               
00A6A0  2  C9 AB        	cmp	#TK_MINUS		; compare with token for -
00A6A2  2  D0 E9        	bne	A_A68D			; exit if not - (LIST -m)
00A6A4  2               
00A6A4  2               ; LIST [[n][-m]]
00A6A4  2               ; this bit sets the n , if present, as the start and end
00A6A4  2               A_A6A4:					;				[A6A4]
00A6A4  2  20 6B A9     	jsr	LineNum2Addr		; get fixed-point number into temporary
00A6A7  2               					; integer			[A96B]
00A6A7  2  20 13 A6     	jsr	CalcStartAddr		; search BASIC for temporary integer
00A6AA  2               					; line number	[A613]
00A6AA  2  20 79 00     	jsr	CHRGOT			; scan memory			[0079]
00A6AD  2  F0 0C        	beq	A_A6BB			; branch if no more chrs
00A6AF  2               
00A6AF  2               ; this bit checks the - is present
00A6AF  2  C9 AB        	cmp	#TK_MINUS		; compare with token for -
00A6B1  2  D0 8E        	bne	A_A641			; return if not "-" (will be SN error)
00A6B3  2               
00A6B3  2               ; LIST [n]-m
00A6B3  2               ; the - was there so set m as the end value
00A6B3  2  20 73 00     	jsr	CHRGET			; increment and scan memory	[0073]
00A6B6  2               
00A6B6  2  20 6B A9     	jsr	LineNum2Addr		; get fixed-point number into temporary
00A6B9  2               					; integer			[A96B]
00A6B9  2  D0 86        	bne	A_A641			; exit if not ok
00A6BB  2               A_A6BB:					;				[A6BB]
00A6BB  2  68           	pla				; dump return address LB
00A6BC  2  68           	pla				; dump return address HB
00A6BD  2               
00A6BD  2  A5 14        	lda	LINNUM			; get temporary integer LB
00A6BF  2  05 15        	ora	LINNUM+1		; OR temporary integer HB
00A6C1  2  D0 06        	bne	A_A6C9			; branch if start set
00A6C3  2               bcLIST2:				;				[A6C3]
00A6C3  2  A9 FF        	lda	#$FF			; set for -1
00A6C5  2  85 14        	sta	LINNUM			; set temporary integer LB
00A6C7  2  85 15        	sta	LINNUM+1		; set temporary integer HB
00A6C9  2               A_A6C9:					;				[A6C9]
00A6C9  2  A0 01        	ldy	#$01			; set index for line
00A6CB  2  84 0F        	sty	GARBFL			; clear open quote flag
00A6CD  2               
00A6CD  2  B1 5F        	lda	(FacTempStor+8),Y	; get next line pointer HB
00A6CF  2  F0 43        	beq	A_A714			; if null all done so exit
00A6D1  2               
00A6D1  2  20 2C A8     	jsr	BasChkStopKey		; do CRTL-C check vector	[A82C]
00A6D4  2               bcLIST3:				;				[A6D4]
00A6D4  2  20 D7 AA     	jsr	OutCRLF			; print CR/LF			[AAD7]
00A6D7  2               
00A6D7  2  C8           	iny				; increment index for line
00A6D8  2  B1 5F        	lda	(FacTempStor+8),Y	; get line number LB
00A6DA  2  AA           	tax				; copy to X
00A6DB  2               
00A6DB  2  C8           	iny				; increment index
00A6DC  2  B1 5F        	lda	(FacTempStor+8),Y	; get line number HB
00A6DE  2  C5 15        	cmp	LINNUM+1		; compare with temporary integer HB
00A6E0  2  D0 04        	bne	A_A6E6			; branch if no HB match
00A6E2  2               
00A6E2  2  E4 14        	cpx	LINNUM			; compare with temporary integer LB
00A6E4  2  F0 02        	beq	A_A6E8			; branch if = last line to do, < will
00A6E6  2               					; pass next branch
00A6E6  2               A_A6E6:					; else ...:
00A6E6  2  B0 2C        	bcs	A_A714			; if greater all done so exit
00A6E8  2               A_A6E8:					;				[A6E8]
00A6E8  2  84 49        	sty	FORPNT			; save index for line
00A6EA  2               
00A6EA  2  20 CD BD     	jsr	PrintXAasInt		; print XA as unsigned integer	[BDCD]
00A6ED  2               
00A6ED  2  A9 20        	lda	#' '			; space is the next character
00A6EF  2               A_A6EF:					;				[A6EF]
00A6EF  2  A4 49        	ldy	FORPNT			; get index for line
00A6F1  2  29 7F        	and	#$7F			; mask top out bit of character
00A6F3  2               A_A6F3:					;				[A6F3]
00A6F3  2  20 47 AB     	jsr	PrintChar		; go print the character	[AB47]
00A6F6  2  C9 22        	cmp	#'"'			; was it " character
00A6F8  2  D0 06        	bne	A_A700			; if not skip the quote handle
00A6FA  2               
00A6FA  2               ; we are either entering or leaving a pair of quotes
00A6FA  2  A5 0F        	lda	GARBFL			; get open quote flag
00A6FC  2  49 FF        	eor	#$FF			; toggle it
00A6FE  2  85 0F        	sta	GARBFL			; save it back
00A700  2               A_A700:					;				[A700]
00A700  2  C8           	iny				; increment index
00A701  2  F0 11        	beq	A_A714			; line too long so just bail out and do
00A703  2               					; a warm start
00A703  2  B1 5F        	lda	(FacTempStor+8),Y	; get next byte
00A705  2  D0 10        	bne	TokCode2Text		; if not [EOL] (go print character)
00A707  2               
00A707  2               ; was [EOL]
00A707  2  A8           	tay				; else clear index
00A708  2  B1 5F        	lda	(FacTempStor+8),Y	; get next line pointer LB
00A70A  2  AA           	tax				; copy to X
00A70B  2               
00A70B  2  C8           	iny				; increment index
00A70C  2  B1 5F        	lda	(FacTempStor+8),Y	; get next line pointer HB
00A70E  2  86 5F        	stx	FacTempStor+8		; set pointer to line LB
00A710  2  85 60        	sta	FacTempStor+9		; set pointer to line HB
00A712  2  D0 B5        	bne	A_A6C9			; go do next line if not [EOT]
00A714  2               					; else ...
00A714  2               A_A714:					;				[A714]
00A714  2  4C 86 E3     	jmp	BasWarmStart2		; do warm start			[E386]
00A717  2               
00A717  2               
00A717  2               ;******************************************************************************
00A717  2               ;
00A717  2               ; uncrunch BASIC tokens
00A717  2               ;
00A717  2               TokCode2Text:				;				[A717]
00A717  2  6C 06 03     	jmp	(IQPLOP)		; do uncrunch BASIC tokens
00A71A  2               
00A71A  2               
00A71A  2               ;******************************************************************************
00A71A  2               ;
00A71A  2               ; uncrunch BASIC tokens, the uncrunch BASIC tokens vector is initialised to
00A71A  2               ; point here
00A71A  2               ;
00A71A  2               TokCode2Text2:				;				[A71A]
00A71A  2  10 D7        	bpl	A_A6F3			; just go print it if not token byte
00A71C  2               					; else was token byte so uncrunch it
00A71C  2               
00A71C  2  C9 FF        	cmp	#TK_PI			; compare with the token for PI. in this
00A71E  2               					; case the token is the same as the PI
00A71E  2               					; character so it just needs printing
00A71E  2  F0 D3        	beq	A_A6F3			; just print it if so
00A720  2               
00A720  2  24 0F        	bit	GARBFL			; test the open quote flag
00A722  2  30 CF        	bmi	A_A6F3			; just go print char if open quote set
00A724  2               
00A724  2  38           	sec				; else set carry for subtract
00A725  2  E9 7F        	sbc	#$7F			; reduce token range to 1 to whatever
00A727  2  AA           	tax				; copy token # to X
00A728  2               
00A728  2  84 49        	sty	FORPNT			; save index for line
00A72A  2               
00A72A  2  A0 FF        	ldy	#$FF			; start from -1, adjust for pre-
00A72C  2               					; increment
00A72C  2               A_A72C:					;				[A72C]
00A72C  2  CA           	dex				; decrement token #
00A72D  2  F0 08        	beq	A_A737			; if now found go do printing
00A72F  2               A_A72F:					;				[A72F]
00A72F  2  C8           	iny				; else increment index
00A730  2  B9 9E A0     	lda	TblBasicCodes,Y		; get byte from keyword table
00A733  2  10 FA        	bpl	A_A72F			; loop until keyword end marker
00A735  2               
00A735  2  30 F5        	bmi	A_A72C			; go test if this is required keyword,
00A737  2               					; branch always
00A737  2               ; found keyword, it's the next one
00A737  2               A_A737:					;				[A737]
00A737  2  C8           	iny				; increment keyword table index
00A738  2  B9 9E A0     	lda	TblBasicCodes,Y		; get byte from table
00A73B  2  30 B2        	bmi	A_A6EF			; go restore index, mask byte and print
00A73D  2               					; if byte was end marker
00A73D  2  20 47 AB     	jsr	PrintChar		; else go print the character	[AB47]
00A740  2  D0 F5        	bne	A_A737			; go get next character, branch always
00A742  2               
00A742  2               
00A742  2               ;******************************************************************************
00A742  2               ;
00A742  2               ; perform FOR
00A742  2               ;
00A742  2               bcFOR:					;				[A742]
00A742  2  A9 80        	lda	#$80			; set FNX
00A744  2  85 10        	sta	SUBFLG			; set subscript/FNX flag
00A746  2               
00A746  2  20 A5 A9     	jsr	bcLET			; perform LET			[A9A5]
00A749  2               
00A749  2  20 8A A3     	jsr	SrchForNext		; search stack for FOR or GOSUB activity
00A74C  2               					;				[A38A]
00A74C  2  D0 05        	bne	A_A753			; branch if FOR not found
00A74E  2               
00A74E  2               ; FOR, this variable, was found so first we dump the old one
00A74E  2  8A           	txa				; copy index
00A74F  2  69 0F        	adc	#$0F			; add FOR structure size-2
00A751  2  AA           	tax				; copy to index
00A752  2  9A           	txs				; set stack (dump FOR structure)
00A753  2               A_A753:					;				[A753]
00A753  2  68           	pla				; pull return address
00A754  2  68           	pla				; pull return address
00A755  2               
00A755  2  A9 09        	lda	#$09			; we need 18d bytes !
00A757  2  20 FB A3     	jsr	CheckRoomStack		; check room on stack for 2*A bytes
00A75A  2               					;				[A3FB]
00A75A  2  20 06 A9     	jsr	FindNextColon		; scan for next BASIC statement ([:] or
00A75D  2               					; [EOL])			[A906]
00A75D  2               
00A75D  2  18           	clc				; clear carry for add
00A75E  2  98           	tya				; copy index to A
00A75F  2  65 7A        	adc	TXTPTR			; add BASIC execute pointer LB
00A761  2  48           	pha				; push onto stack
00A762  2               
00A762  2  A5 7B        	lda	TXTPTR+1		; get BASIC execute pointer HB
00A764  2  69 00        	adc	#$00			; add carry
00A766  2  48           	pha				; push onto stack
00A767  2               
00A767  2  A5 3A        	lda	CURLIN+1		; get current line number HB
00A769  2  48           	pha				; push onto stack
00A76A  2               
00A76A  2  A5 39        	lda	CURLIN			; get current line number LB
00A76C  2  48           	pha				; push onto stack
00A76D  2               
00A76D  2  A9 A4        	lda	#TK_TO			; set "TO" token
00A76F  2  20 FF AE     	jsr	Chk4CharInA		; scan for CHR$(A), else do syntax error
00A772  2               					; then warm start		[AEFF]
00A772  2  20 8D AD     	jsr	CheckIfNumeric		; check if source is numeric, else do
00A775  2               					; type mismatch			[AD8D]
00A775  2  20 8A AD     	jsr	EvalExpression		; evaluate expression and check is
00A778  2               					; numeric, else do type mismatch [AD8A]
00A778  2  A5 66        	lda	FACSGN			; get FAC1 sign (b7)
00A77A  2  09 7F        	ora	#$7F			; set all non sign bits
00A77C  2  25 62        	and	FacMantissa		; and FAC1 mantissa 1
00A77E  2  85 62        	sta	FacMantissa		; save FAC1 mantissa 1
00A780  2               
00A780  2  A9 8B        	lda	#<bcFOR2		; set return address LB
00A782  2  A0 A7        	ldy	#>bcFOR2		; set return address HB
00A784  2  85 22        	sta	INDEX			; save return address LB
00A786  2  84 23        	sty	INDEX+1			; save return address HB
00A788  2               
00A788  2  4C 43 AE     	jmp	FAC1ToStack		; round FAC1 and put on stack, returns
00A78B  2               					; to next instruction		[AE43]
00A78B  2               
00A78B  2               bcFOR2:					;				[A78B]
00A78B  2  A9 BC        	lda	#<Constant1		; set 1 pointer low address, default
00A78D  2               					; step size
00A78D  2  A0 B9        	ldy	#>Constant1		; set 1 pointer high address
00A78F  2  20 A2 BB     	jsr	UnpackAY2FAC1		; unpack memory (AY) into FAC1	[BBA2]
00A792  2               
00A792  2  20 79 00     	jsr	CHRGOT			; scan memory			[0079]
00A795  2  C9 A9        	cmp	#TK_STEP		; compare with STEP token
00A797  2  D0 06        	bne	A_A79F			; if not "STEP" continue
00A799  2               
00A799  2               ; was step so ....
00A799  2               
00A799  2  20 73 00     	jsr	CHRGET			; increment and scan memory	[0073]
00A79C  2  20 8A AD     	jsr	EvalExpression		; evaluate expression and check is
00A79F  2               					; numeric, else do type mismatch [AD8A]
00A79F  2               A_A79F:					;				[A79F]
00A79F  2  20 2B BC     	jsr	GetFacSign		; get FAC1 sign, return A = $FF -ve,
00A7A2  2               					; A = $01 +ve	[BC2B]
00A7A2  2  20 38 AE     	jsr	SgnFac1ToStack		; push sign, round FAC1 and put on stack
00A7A5  2               					;				[AE38]
00A7A5  2               
00A7A5  2  A5 4A        	lda	FORPNT+1		; get FOR/NEXT variable pointer HB
00A7A7  2  48           	pha				; push on stack
00A7A8  2               
00A7A8  2  A5 49        	lda	FORPNT			; get FOR/NEXT variable pointer LB
00A7AA  2  48           	pha				; push on stack
00A7AB  2               
00A7AB  2  A9 81        	lda	#TK_FOR			; get FOR token
00A7AD  2  48           	pha				; push on stack
00A7AE  2               
00A7AE  2               
00A7AE  2               ;******************************************************************************
00A7AE  2               ;
00A7AE  2               ; interpreter inner loop
00A7AE  2               ;
00A7AE  2               InterpretLoop:				;				[A7AE]
00A7AE  2  20 2C A8     	jsr	BasChkStopKey		; do CRTL-C check vector	[A82C]
00A7B1  2               
00A7B1  2  A5 7A        	lda	TXTPTR			; get the BASIC execute pointer LB
00A7B3  2  A4 7B        	ldy	TXTPTR+1		; get the BASIC execute pointer HB
00A7B5  2  C0 02        	cpy	#$02			; compare the HB with $02xx
00A7B7  2  EA           	nop				; unused byte
00A7B8  2  F0 04        	beq	A_A7BE			; if immediate mode skip the continue
00A7BA  2               					; pointer save
00A7BA  2  85 3D        	sta	OLDTXT			; save the continue pointer LB
00A7BC  2  84 3E        	sty	OLDTXT+1		; save the continue pointer HB
00A7BE  2               A_A7BE:					;				[A7BE]
00A7BE  2  A0 00        	ldy	#$00			; clear the index
00A7C0  2  B1 7A        	lda	(TXTPTR),Y		; get a BASIC byte
00A7C2  2  D0 43        	bne	A_A807			; if not [EOL] go test for ":"
00A7C4  2               
00A7C4  2  A0 02        	ldy	#$02			; else set the index
00A7C6  2  B1 7A        	lda	(TXTPTR),Y		; get next line pointer HB
00A7C8  2  18           	clc				; clear carry for no "BREAK" message
00A7C9  2  D0 03        	bne	A_A7CE			; branch if not end of program
00A7CB  2               
00A7CB  2  4C 4B A8     	jmp	bcEND2			; else go to immediate mode, was
00A7CE  2               					; immediate or [EOT] marker	[A84B]
00A7CE  2               A_A7CE:					;				[A7CE]
00A7CE  2  C8           	iny				; increment index
00A7CF  2  B1 7A        	lda	(TXTPTR),Y		; get line number LB
00A7D1  2  85 39        	sta	CURLIN			; save current line number LB
00A7D3  2               
00A7D3  2  C8           	iny				; increment index
00A7D4  2  B1 7A        	lda	(TXTPTR),Y		; get line # HB
00A7D6  2  85 3A        	sta	CURLIN+1		; save current line number HB
00A7D8  2               
00A7D8  2  98           	tya				; A now = 4
00A7D9  2  65 7A        	adc	TXTPTR			; add BASIC execute pointer LB, now
00A7DB  2               					; points to code
00A7DB  2  85 7A        	sta	TXTPTR			; save BASIC execute pointer LB
00A7DD  2  90 02        	bcc	InterpretLoop2		; branch if no overflow
00A7DF  2               
00A7DF  2  E6 7B        	inc	TXTPTR+1		; else increment BASIC execute pointer
00A7E1  2               					; HB
00A7E1  2               InterpretLoop2:				;				[A7E1]
00A7E1  2  6C 08 03     	jmp	(IGONE)			; do start new BASIC code
00A7E4  2               
00A7E4  2               
00A7E4  2               ;******************************************************************************
00A7E4  2               ;
00A7E4  2               ; start new BASIC code, the start new BASIC code vector is initialised to point
00A7E4  2               ; here
00A7E4  2               ;
00A7E4  2               InterpretLoop3:				;				[A7E4]
00A7E4  2  20 73 00     	jsr	CHRGET			; increment and scan memory	[0073]
00A7E7  2  20 ED A7     	jsr	DecodeBASIC		; go interpret BASIC code from BASIC
00A7EA  2               					; execute pointer		[A7ED]
00A7EA  2  4C AE A7     	jmp	InterpretLoop		; loop				[A7AE]
00A7ED  2               
00A7ED  2               
00A7ED  2               ;******************************************************************************
00A7ED  2               ;
00A7ED  2               ; go interpret BASIC code from BASIC execute pointer
00A7ED  2               ;
00A7ED  2               DecodeBASIC:				;				[A7ED]
00A7ED  2  F0 3C        	beq	A_A82B			; if the first byte is null just exit
00A7EF  2               
00A7EF  2               DecodeBASIC2:				;				[A7EF]
00A7EF  2  E9 80        	sbc	#$80			; normalise the token
00A7F1  2  90 11        	bcc	A_A804			; if wasn't token go do LET
00A7F3  2               
00A7F3  2  C9 23        	cmp	#TK_TAB-$80		; compare with token for TAB(-$80
00A7F5  2  B0 17        	bcs	A_A80E			; branch if >= TAB(
00A7F7  2               
00A7F7  2  0A           	asl				; *2 bytes per vector
00A7F8  2  A8           	tay				; copy to index
00A7F9  2               
00A7F9  2  B9 0D A0     	lda	TblBasicInstr+1,Y	; get vector HB
00A7FC  2  48           	pha				; push on stack
00A7FD  2               
00A7FD  2  B9 0C A0     	lda	TblBasicInstr,Y		; get vector LB
00A800  2  48           	pha				; push on stack
00A801  2               
00A801  2  4C 73 00     	jmp	CHRGET			; increment and scan memory and return.
00A804  2               					; The return in	[0073] this case calls
00A804  2               					; the command code, the return from
00A804  2               					; that will eventually return to the
00A804  2               					; interpreter inner loop above
00A804  2               A_A804:					;				[A804]
00A804  2  4C A5 A9     	jmp	bcLET			; perform LET			[A9A5]
00A807  2               
00A807  2               ; was not [EOL]
00A807  2               A_A807:					;				[A807]
00A807  2  C9 3A        	cmp	#':'			; comapre with ":"
00A809  2  F0 D6        	beq	InterpretLoop2		; if ":" go execute new code
00A80B  2               
00A80B  2               ; else ...
00A80B  2               A_A80B:					;				[A80B]
00A80B  2  4C 08 AF     	jmp	SyntaxError		; do syntax error then warm start [AF08]
00A80E  2               
00A80E  2               ; token was >= TAB(
00A80E  2               A_A80E:					;				[A80E]
00A80E  2  C9 4B        	cmp	#TK_GO-$80		; compare with the token for GO
00A810  2  D0 F9        	bne	A_A80B			; if not "GO" do syntax error then warm
00A812  2               					; start
00A812  2               ; else was "GO"
00A812  2  20 73 00     	jsr	CHRGET			; increment and scan memory	[0073]
00A815  2               
00A815  2  A9 A4        	lda	#TK_TO			; set "TO" token
00A817  2  20 FF AE     	jsr	Chk4CharInA		; scan for CHR$(A), else do syntax error
00A81A  2               					; then warm start		[AEFF]
00A81A  2               
00A81A  2  4C A0 A8     	jmp	bcGOTO			; perform GOTO			[A8A0]
00A81D  2               
00A81D  2               
00A81D  2               ;******************************************************************************
00A81D  2               ;
00A81D  2               ; perform RESTORE
00A81D  2               ;
00A81D  2               bcRESTORE:
00A81D  2  38           	sec				; set carry for subtract
00A81E  2  A5 2B        	lda	TXTTAB			; get start of memory LB
00A820  2  E9 01        	sbc	#$01			; -1
00A822  2  A4 2C        	ldy	TXTTAB+1		; get start of memory HB
00A824  2  B0 01        	bcs	bcRESTORE2		; branch if no rollunder
00A826  2               
00A826  2  88           	dey				; else decrement HB
00A827  2               bcRESTORE2:				;				[A827]
00A827  2  85 41        	sta	DATPTR			; set DATA pointer LB
00A829  2  84 42        	sty	DATPTR+1		; set DATA pointer HB
00A82B  2               A_A82B:					;				[A82B]
00A82B  2  60           	rts
00A82C  2               
00A82C  2               
00A82C  2               ;******************************************************************************
00A82C  2               ;
00A82C  2               ; do CRTL-C check vector
00A82C  2               ;
00A82C  2               BasChkStopKey:				;				[A82C]
00A82C  2  20 E1 FF     	jsr	ScanStopKey		; scan stop key			[FFE1]
00A82F  2               
00A82F  2               
00A82F  2               ;******************************************************************************
00A82F  2               ;
00A82F  2               ; perform STOP
00A82F  2               ;
00A82F  2               bcSTOP:
00A82F  2  B0 01        	bcs	A_A832			; if carry set do BREAK instead of just
00A831  2               					; END
00A831  2               
00A831  2               ;******************************************************************************
00A831  2               ;
00A831  2               ; perform END
00A831  2               ;
00A831  2               bcEND:
00A831  2  18           	clc				; clear carry
00A832  2               A_A832:					;				[A832]
00A832  2  D0 3C        	bne	A_A870			; return if wasn't CTRL-C
00A834  2               
00A834  2  A5 7A        	lda	TXTPTR			; get BASIC execute pointer LB
00A836  2  A4 7B        	ldy	TXTPTR+1		; get BASIC execute pointer HB
00A838  2  A6 3A        	ldx	CURLIN+1		; get current line number HB
00A83A  2               
00A83A  2  E8           	inx				; increment it
00A83B  2  F0 0C        	beq	A_A849			; branch if was immediate mode
00A83D  2               
00A83D  2  85 3D        	sta	OLDTXT			; save continue pointer LB
00A83F  2  84 3E        	sty	OLDTXT+1		; save continue pointer HB
00A841  2               
00A841  2  A5 39        	lda	CURLIN			; get current line number LB
00A843  2  A4 3A        	ldy	CURLIN+1		; get current line number HB
00A845  2  85 3B        	sta	OLDLIN			; save break line number LB
00A847  2  84 3C        	sty	OLDLIN+1		; save break line number HB
00A849  2               A_A849:					;				[A849]
00A849  2  68           	pla				; dump return address LB
00A84A  2  68           	pla				; dump return address HB
00A84B  2               bcEND2:					;				[A84B]
00A84B  2  A9 81        	lda	#<TxtBreak		; set [CR][LF]"BREAK" pointer LB
00A84D  2  A0 A3        	ldy	#>TxtBreak		; set [CR][LF]"BREAK" pointer HB
00A84F  2  90 03        	bcc	A_A854			; if was program end skip the print
00A851  2               					; string
00A851  2  4C 69 A4     	jmp	OutputMessage		; print string and do warm start [A469]
00A854  2               
00A854  2               A_A854:					;				[A854]
00A854  2  4C 86 E3     	jmp	BasWarmStart2		; do warm start			[E386]
00A857  2               
00A857  2               
00A857  2               ;******************************************************************************
00A857  2               ;
00A857  2               ; perform CONT
00A857  2               ;
00A857  2               bcCONT:
00A857  2  D0 17        	bne	A_A870			; exit if following byte to allow
00A859  2               					; syntax error
00A859  2  A2 1A        	ldx	#$1A			; error code $1A, can't continue error
00A85B  2  A4 3E        	ldy	OLDTXT+1		; get continue pointer HB
00A85D  2  D0 03        	bne	A_A862			; go do continue if we can
00A85F  2               
00A85F  2  4C 37 A4     	jmp	OutputErrMsg		; else do error #X then warm start
00A862  2               					; [A437]
00A862  2               ; we can continue so ...
00A862  2               A_A862:					;				[A862]
00A862  2  A5 3D        	lda	OLDTXT			; get continue pointer LB
00A864  2  85 7A        	sta	TXTPTR			; save BASIC execute pointer LB
00A866  2               
00A866  2  84 7B        	sty	TXTPTR+1		; save BASIC execute pointer HB
00A868  2               
00A868  2  A5 3B        	lda	OLDLIN			; get break line LB
00A86A  2  A4 3C        	ldy	OLDLIN+1		; get break line HB
00A86C  2  85 39        	sta	CURLIN			; set current line number LB
00A86E  2  84 3A        	sty	CURLIN+1		; set current line number HB
00A870  2               A_A870:					;				[A870]
00A870  2  60           	rts
00A871  2               
00A871  2               
00A871  2               ;******************************************************************************
00A871  2               ;
00A871  2               ; perform RUN
00A871  2               ;
00A871  2               bcRUN:
00A871  2  08           	php				; save status
00A872  2               
00A872  2  A9 00        	lda	#$00			; no control or kernal messages
00A874  2  20 90 FF     	jsr	CtrlKernalMsg		; control kernal messages	[FF90]
00A877  2               
00A877  2  28           	plp				; restore status
00A878  2  D0 03        	bne	A_A87D			; branch if RUN n
00A87A  2               
00A87A  2  4C 59 A6     	jmp	ResetExecPtr		; reset execution to start, clear
00A87D  2               					; variables, flush stack	[A659]
00A87D  2               					; and return
00A87D  2               A_A87D:					;				[A87D]
00A87D  2  20 60 A6     	jsr	bcCLR2			; go do "CLEAR"			[A660]
00A880  2  4C 97 A8     	jmp	bcGOSUB2		; get n and do GOTO n		[A897]
00A883  2               
00A883  2               
00A883  2               ;******************************************************************************
00A883  2               ;
00A883  2               ; perform GOSUB
00A883  2               ;
00A883  2               bcGOSUB:
00A883  2  A9 03        	lda	#$03			; need 6 bytes for GOSUB
00A885  2  20 FB A3     	jsr	CheckRoomStack		; check room on stack for 2*A bytes
00A888  2               					;				[A3FB]
00A888  2  A5 7B        	lda	TXTPTR+1		; get BASIC execute pointer HB
00A88A  2  48           	pha				; save it
00A88B  2               
00A88B  2  A5 7A        	lda	TXTPTR			; get BASIC execute pointer LB
00A88D  2  48           	pha				; save it
00A88E  2               
00A88E  2  A5 3A        	lda	CURLIN+1		; get current line number HB
00A890  2  48           	pha				; save it
00A891  2               
00A891  2  A5 39        	lda	CURLIN			; get current line number LB
00A893  2  48           	pha				; save it
00A894  2               
00A894  2  A9 8D        	lda	#TK_GOSUB		; token for GOSUB
00A896  2  48           	pha				; save it
00A897  2               bcGOSUB2:				;				[A897]
00A897  2  20 79 00     	jsr	CHRGOT			; scan memory			[0079]
00A89A  2  20 A0 A8     	jsr	bcGOTO			; perform GOTO			[A8A0]
00A89D  2  4C AE A7     	jmp	InterpretLoop		; go do interpreter inner loop	[A7AE]
00A8A0  2               
00A8A0  2               
00A8A0  2               ;******************************************************************************
00A8A0  2               ;
00A8A0  2               ; perform GOTO
00A8A0  2               ;
00A8A0  2               bcGOTO:
00A8A0  2  20 6B A9     	jsr	LineNum2Addr		; get fixed-point number into temporary
00A8A3  2               					; integer			[A96B]
00A8A3  2  20 09 A9     	jsr	FindEndOfLine		; scan for next BASIC line	[A909]
00A8A6  2               
00A8A6  2  38           	sec				; set carry for subtract
00A8A7  2  A5 39        	lda	CURLIN			; get current line number LB
00A8A9  2  E5 14        	sbc	LINNUM			; subtract temporary integer LB
00A8AB  2               
00A8AB  2  A5 3A        	lda	CURLIN+1		; get current line number HB
00A8AD  2  E5 15        	sbc	LINNUM+1		; subtract temporary integer HB
00A8AF  2  B0 0B        	bcs	A_A8BC			; if current line number >= temporary
00A8B1  2               					; integer, go search from the start of
00A8B1  2               					; memory
00A8B1  2  98           	tya				; else copy line index to A
00A8B2  2  38           	sec				; set carry (+1)
00A8B3  2  65 7A        	adc	TXTPTR			; add BASIC execute pointer LB
00A8B5  2  A6 7B        	ldx	TXTPTR+1		; get BASIC execute pointer HB
00A8B7  2  90 07        	bcc	A_A8C0			; branch if no overflow to HB
00A8B9  2               
00A8B9  2  E8           	inx				; increment HB
00A8BA  2  B0 04        	bcs	A_A8C0			; branch always (can never be carry)
00A8BC  2               
00A8BC  2               
00A8BC  2               ;******************************************************************************
00A8BC  2               ;
00A8BC  2               ; search for line number in temporary integer from start of memory pointer
00A8BC  2               ;
00A8BC  2               A_A8BC:					;				[A8BC]
00A8BC  2  A5 2B        	lda	TXTTAB			; get start of memory LB
00A8BE  2  A6 2C        	ldx	TXTTAB+1		; get start of memory HB
00A8C0  2               
00A8C0  2               
00A8C0  2               ;******************************************************************************
00A8C0  2               ;
00A8C0  2               ; search for line # in temporary integer from (AX)
00A8C0  2               ;
00A8C0  2               A_A8C0:					;				[A8C0]
00A8C0  2  20 17 A6     	jsr	CalcStartAddr2		; search Basic for temp integer line
00A8C3  2               					; number from AX		[A617]
00A8C3  2  90 1E        	bcc	A_A8E3			; if carry clear go do unsdefined
00A8C5  2               					; statement error
00A8C5  2               ; carry all ready set for subtract
00A8C5  2  A5 5F        	lda	FacTempStor+8		; get pointer LB
00A8C7  2  E9 01        	sbc	#$01			; -1
00A8C9  2  85 7A        	sta	TXTPTR			; save BASIC execute pointer LB
00A8CB  2               
00A8CB  2  A5 60        	lda	FacTempStor+9		; get pointer HB
00A8CD  2  E9 00        	sbc	#$00			; subtract carry
00A8CF  2  85 7B        	sta	TXTPTR+1		; save BASIC execute pointer HB
00A8D1  2               A_A8D1:					;				[A8D1]
00A8D1  2  60           	rts
00A8D2  2               
00A8D2  2               
00A8D2  2               ;******************************************************************************
00A8D2  2               ;
00A8D2  2               ; perform RETURN
00A8D2  2               ;
00A8D2  2               bcRETURN:
00A8D2  2  D0 FD        	bne	A_A8D1			; exit if following token to allow
00A8D4  2               					; syntax error
00A8D4  2  A9 FF        	lda	#$FF			; set byte so no match possible
00A8D6  2  85 4A        	sta	FORPNT+1		; save FOR/NEXT variable pointer HB
00A8D8  2  20 8A A3     	jsr	SrchForNext		; search the stack for FOR or GOSUB
00A8DB  2               					; activity, get token off stack	[A38A]
00A8DB  2  9A           	txs				; correct the stack
00A8DC  2  C9 8D        	cmp	#TK_GOSUB		; compare with GOSUB token
00A8DE  2  F0 0B        	beq	A_A8EB			; if matching GOSUB go continue RETURN
00A8E0  2               
00A8E0  2  A2 0C        	ldx	#$0C			; else error code $04, return without
00A8E2  2               					; gosub error
00A8E2  2  2C           .byte	$2C				; makes next line BIT $11A2
00A8E3  2               A_A8E3:					;				[A8E3]
00A8E3  2  A2 11        	ldx	#$11			; error code $11, undefined statement
00A8E5  2               					; error
00A8E5  2  4C 37 A4     	jmp	OutputErrMsg		; do error #X then warm start	[A437]
00A8E8  2               
00A8E8  2               A_A8E8:					;				[A8E8]
00A8E8  2  4C 08 AF     	jmp	SyntaxError		; do syntax error then warm start [AF08]
00A8EB  2               
00A8EB  2               ; was matching GOSUB token
00A8EB  2               A_A8EB:					;				[A8EB]
00A8EB  2  68           	pla				; dump token byte
00A8EC  2  68           	pla				; pull return line LB
00A8ED  2  85 39        	sta	CURLIN			; save current line number LB
00A8EF  2  68           	pla				; pull return line HB
00A8F0  2  85 3A        	sta	CURLIN+1		; save current line number HB
00A8F2  2  68           	pla				; pull return address LB
00A8F3  2  85 7A        	sta	TXTPTR			; save BASIC execute pointer LB
00A8F5  2  68           	pla				; pull return address HB
00A8F6  2  85 7B        	sta	TXTPTR+1		; save BASIC execute pointer HB
00A8F8  2               
00A8F8  2               
00A8F8  2               ;******************************************************************************
00A8F8  2               ;
00A8F8  2               ; perform DATA
00A8F8  2               ;
00A8F8  2               bcDATA:
00A8F8  2  20 06 A9     	jsr	FindNextColon		; scan for next BASIC statement ([:] or
00A8FB  2               					; [EOL])			[A906]
00A8FB  2               
00A8FB  2               ;******************************************************************************
00A8FB  2               ;
00A8FB  2               ; add Y to the BASIC execute pointer
00A8FB  2               ;
00A8FB  2               bcDATA2:				;				[A8FB]
00A8FB  2  98           	tya				; copy index to A
00A8FC  2               S_A8FC:
00A8FC  2  18           	clc				; clear carry for add
00A8FD  2  65 7A        	adc	TXTPTR			; add BASIC execute pointer LB
00A8FF  2  85 7A        	sta	TXTPTR			; save BASIC execute pointer LB
00A901  2  90 02        	bcc	A_A905			; skip increment if no carry
00A903  2               
00A903  2  E6 7B        	inc	TXTPTR+1		; else increment BASIC execute pointer
00A905  2               					; HB
00A905  2               A_A905:					;				[A905]
00A905  2  60           	rts
00A906  2               
00A906  2               
00A906  2               ;******************************************************************************
00A906  2               ;
00A906  2               ; scan for next BASIC statement ([:] or [EOL])
00A906  2               ; returns Y as index to [:] or [EOL]
00A906  2               ;
00A906  2               FindNextColon:				;				[A906]
00A906  2  A2 3A        	ldx	#':'			; set look for character = ":"
00A908  2  2C           .byte	$2C				; makes next line BIT $00A2
00A909  2               
00A909  2               
00A909  2               ;******************************************************************************
00A909  2               ;
00A909  2               ; scan for next BASIC line
00A909  2               ; returns Y as index to [EOL]
00A909  2               ;
00A909  2               FindEndOfLine:				;				[A909]
00A909  2  A2 00        	ldx	#$00			; set alternate search character = [EOL]
00A90B  2  86 07        	stx	CHARAC			; store alternate search character
00A90D  2               
00A90D  2  A0 00        	ldy	#$00			; set search character = [EOL]
00A90F  2  84 08        	sty	ENDCHR			; save the search character
00A911  2               A_A911:					;				[A911]
00A911  2  A5 08        	lda	ENDCHR			; get search character
00A913  2  A6 07        	ldx	CHARAC			; get alternate search character
00A915  2  85 07        	sta	CHARAC			; make search character = alternate
00A917  2               					; search character
00A917  2               FindOtherChar:				;				[A917]
00A917  2  86 08        	stx	ENDCHR			; make alternate search character =
00A919  2               					; search character
00A919  2               A_A919:					;				[A919]
00A919  2  B1 7A        	lda	(TXTPTR),Y		; get BASIC byte
00A91B  2  F0 E8        	beq	A_A905			; exit if null [EOL]
00A91D  2               
00A91D  2  C5 08        	cmp	ENDCHR			; compare with search character
00A91F  2  F0 E4        	beq	A_A905			; exit if found
00A921  2               
00A921  2  C8           	iny				; else increment index
00A922  2               
00A922  2  C9 22        	cmp	#'"'			; compare current character with open
00A924  2               					; quote
00A924  2  D0 F3        	bne	A_A919			; if found go swap search character for
00A926  2               					; alternate search character
00A926  2  F0 E9        	beq	A_A911			; loop for next character, branch always
00A928  2               
00A928  2               
00A928  2               ;******************************************************************************
00A928  2               ;
00A928  2               ; perform IF
00A928  2               ;
00A928  2               bcIF:
00A928  2  20 9E AD     	jsr	EvaluateValue		; evaluate expression		[AD9E]
00A92B  2               
00A92B  2  20 79 00     	jsr	CHRGOT			; scan memory			[0079]
00A92E  2  C9 89        	cmp	#TK_GOTO		; compare with "GOTO" token
00A930  2  F0 05        	beq	A_A937			; if it was  the token for GOTO go do
00A932  2               					; IF ... GOTO
00A932  2               ; wasn't IF ... GOTO so must be IF ... THEN
00A932  2  A9 A7        	lda	#TK_THEN		; set "THEN" token
00A934  2  20 FF AE     	jsr	Chk4CharInA		; scan for CHR$(A), else do syntax error
00A937  2               					; then warm start		[AEFF]
00A937  2               A_A937:					;				[A937]
00A937  2  A5 61        	lda	FACEXP			; get FAC1 exponent
00A939  2  D0 05        	bne	A_A940			; if result was non zero continue
00A93B  2               					; execution
00A93B  2               ; else REM rest of line
00A93B  2               
00A93B  2               
00A93B  2               ;******************************************************************************
00A93B  2               ;
00A93B  2               ; perform REM
00A93B  2               ;
00A93B  2               bcREM:
00A93B  2  20 09 A9     	jsr	FindEndOfLine		; scan for next BASIC line	[A909]
00A93E  2  F0 BB        	beq	bcDATA2			; add Y to the BASIC execute pointer and
00A940  2               					; return, branch always
00A940  2               
00A940  2               ; result was non zero so do rest of line
00A940  2               A_A940:					;				[A940]
00A940  2  20 79 00     	jsr	CHRGOT			; scan memory			[0079]
00A943  2  B0 03        	bcs	A_A948			; branch if not numeric character, is
00A945  2               					; variable or keyword
00A945  2  4C A0 A8     	jmp	bcGOTO			; else perform GOTO n		[A8A0]
00A948  2               
00A948  2               ; is variable or keyword
00A948  2               A_A948:					;				[A948]
00A948  2  4C ED A7     	jmp	DecodeBASIC		; interpret BASIC code from BASIC
00A94B  2               					; execute pointer		[A7ED]
00A94B  2               
00A94B  2               ;******************************************************************************
00A94B  2               ;
00A94B  2               ; perform ON
00A94B  2               ;
00A94B  2               bcON:
00A94B  2  20 9E B7     	jsr	GetByteParm2		; get byte parameter		[B79E]
00A94E  2  48           	pha				; push next character
00A94F  2  C9 8D        	cmp	#TK_GOSUB		; compare with GOSUB token
00A951  2  F0 04        	beq	A_A957			; if GOSUB go see if it should be
00A953  2               					; executed
00A953  2               A_A953:					;				[A953]
00A953  2  C9 89        	cmp	#TK_GOTO		; compare with GOTO token
00A955  2  D0 91        	bne	A_A8E8			; if not GOTO do syntax error then warm
00A957  2               					; start
00A957  2               ; next character was GOTO or GOSUB, see if it should be executed
00A957  2               A_A957:					;				[A957]
00A957  2  C6 65        	dec	FacMantissa+3		; decrement the byte value
00A959  2  D0 04        	bne	A_A95F			; if not zero go see if another line
00A95B  2               					; number exists
00A95B  2  68           	pla				; pull keyword token
00A95C  2  4C EF A7     	jmp	DecodeBASIC2		; go execute it			[A7EF]
00A95F  2               
00A95F  2               A_A95F:					;				[A95F]
00A95F  2  20 73 00     	jsr	CHRGET			; increment and scan memory	[0073]
00A962  2  20 6B A9     	jsr	LineNum2Addr		; get fixed-point number into temporary
00A965  2               					; integer			[A96B]
00A965  2  C9 2C        	cmp	#','			; compare next character with ","
00A967  2  F0 EE        	beq	A_A957			; loop if ","
00A969  2               
00A969  2  68           	pla				; else pull keyword token, ran out of
00A96A  2               					; options
00A96A  2               A_A96A:					;				[A96A]
00A96A  2  60           	rts
00A96B  2               
00A96B  2               
00A96B  2               ;******************************************************************************
00A96B  2               ;
00A96B  2               ; get fixed-point number into temporary integer
00A96B  2               ;
00A96B  2               LineNum2Addr:				;				[A96B]
00A96B  2  A2 00        	ldx	#$00			; clear X
00A96D  2  86 14        	stx	LINNUM			; clear temporary integer LB
00A96F  2  86 15        	stx	LINNUM+1		; clear temporary integer HB
00A971  2               LineNum2Addr2:				;				[A971]
00A971  2  B0 F7        	bcs	A_A96A			; return if carry set, end of scan,
00A973  2               					; character was not 0-9
00A973  2  E9 2F        	sbc	#'0'-1			; subtract $30, $2F+carry, from byte
00A975  2  85 07        	sta	CHARAC			; store #
00A977  2               
00A977  2  A5 15        	lda	LINNUM+1		; get temporary integer HB
00A979  2  85 22        	sta	INDEX			; save it for now
00A97B  2  C9 19        	cmp	#$19			; compare with $19
00A97D  2  B0 D4        	bcs	A_A953			; branch if >= this makes the maximum
00A97F  2               					; line number 63999 because the next
00A97F  2               ; bit does $1900 * $0A = $FA00 = 64000 decimal. the branch target is really the
00A97F  2               ; SYNTAX error at A_A8E8 but that is too far so an intermediate; compare and
00A97F  2               ; branch to that location is used. the problem with this is that line number
00A97F  2               ; that gives a partial result from $8900 to $89FF, 35072x to 35327x, will pass
00A97F  2               ; the new target compare and will try to execute the remainder of the ON n
00A97F  2               ; GOTO/GOSUB. a solution to this is to copy the byte in A before the branch to
00A97F  2               ; X and then branch to A_A955 skipping the second compare
00A97F  2               
00A97F  2  A5 14        	lda	LINNUM			; get temporary integer LB
00A981  2  0A           	asl				; *2 LB
00A982  2  26 22        	rol	INDEX			; *2 HB
00A984  2  0A           	asl				; *2 LB
00A985  2  26 22        	rol	INDEX			; *2 HB (*4)
00A987  2  65 14        	adc	LINNUM			; + LB (*5)
00A989  2  85 14        	sta	LINNUM			; save it
00A98B  2               
00A98B  2  A5 22        	lda	INDEX			; get HB temp
00A98D  2  65 15        	adc	LINNUM+1		; + HB (*5)
00A98F  2  85 15        	sta	LINNUM+1		; save it
00A991  2               
00A991  2  06 14        	asl	LINNUM			; *2 LB (*10d)
00A993  2  26 15        	rol	LINNUM+1		; *2 HB (*10d)
00A995  2               
00A995  2  A5 14        	lda	LINNUM			; get LB
00A997  2  65 07        	adc	CHARAC			; add #
00A999  2  85 14        	sta	LINNUM			; save LB
00A99B  2  90 02        	bcc	A_A99F			; branch if no overflow to HB
00A99D  2               
00A99D  2  E6 15        	inc	LINNUM+1		; else increment HB
00A99F  2               A_A99F:					;				[A99F]
00A99F  2  20 73 00     	jsr	CHRGET			; increment and scan memory	[0073]
00A9A2  2  4C 71 A9     	jmp	LineNum2Addr2		; loop for next character	[A971]
00A9A5  2               
00A9A5  2               
00A9A5  2               ;******************************************************************************
00A9A5  2               ;
00A9A5  2               ; perform LET
00A9A5  2               ;
00A9A5  2               bcLET:
00A9A5  2  20 8B B0     	jsr	GetAddrVar		; get variable address		[B08B]
00A9A8  2  85 49        	sta	FORPNT			; save variable address LB
00A9AA  2  84 4A        	sty	FORPNT+1		; save variable address HB
00A9AC  2               
00A9AC  2  A9 B2        	lda	#TK_EQUAL		; $B2 is "=" token
00A9AE  2  20 FF AE     	jsr	Chk4CharInA		; scan for CHR$(A), else do syntax error
00A9B1  2               					; then warm start		[AEFF]
00A9B1  2  A5 0E        	lda	INTFLG			; get data type flag, $80 = integer,
00A9B3  2               					; $00 = float
00A9B3  2  48           	pha				; push data type flag
00A9B4  2               
00A9B4  2  A5 0D        	lda	VALTYP			; get data type flag, $FF = string,
00A9B6  2               					; $00 = numeric
00A9B6  2  48           	pha				; push data type flag
00A9B7  2               
00A9B7  2  20 9E AD     	jsr	EvaluateValue		; evaluate expression		[AD9E]
00A9BA  2               
00A9BA  2  68           	pla				; pop data type flag
00A9BB  2  2A           	rol				; string bit into carry
00A9BC  2  20 90 AD     	jsr	ChkIfNumStr		; do type match check		[AD90]
00A9BF  2  D0 18        	bne	A_A9D9			; branch if string
00A9C1  2               
00A9C1  2  68           	pla				; pop integer/float data type flag
00A9C2  2               
00A9C2  2               ; assign value to numeric variable
00A9C2  2               SetIntegerVar:				;				[A9C2]
00A9C2  2  10 12        	bpl	A_A9D6			; branch if float
00A9C4  2               
00A9C4  2               ; expression is numeric integer
00A9C4  2  20 1B BC     	jsr	RoundFAC1		; round FAC1			[BC1B]
00A9C7  2  20 BF B1     	jsr	EvalInteger3		; evaluate integer expression, no sign
00A9CA  2               					; check				[B1BF]
00A9CA  2  A0 00        	ldy	#$00			; clear index
00A9CC  2  A5 64        	lda	FacMantissa+2		; get FAC1 mantissa 3
00A9CE  2  91 49        	sta	(FORPNT),Y		; save as integer variable LB
00A9D0  2               
00A9D0  2  C8           	iny				; increment index
00A9D1  2  A5 65        	lda	FacMantissa+3		; get FAC1 mantissa 4
00A9D3  2  91 49        	sta	(FORPNT),Y		; save as integer variable HB
00A9D5  2               
00A9D5  2  60           	rts
00A9D6  2               
00A9D6  2               ; Set the value of a real variable
00A9D6  2               A_A9D6:					;				[A9D6]
00A9D6  2  4C D0 BB     	jmp	Fac1ToVarPtr		; pack FAC1 into variable pointer and
00A9D9  2               					; return			[BBD0]
00A9D9  2               
00A9D9  2               ; assign value to numeric variable
00A9D9  2               A_A9D9:					;				[A9D9]
00A9D9  2  68           	pla				; dump integer/float data type flag
00A9DA  2               SetValueString:				;				[A9DA]
00A9DA  2  A4 4A        	ldy	FORPNT+1		; get variable pointer HB
00A9DC  2  C0 BF        	cpy	#>L_BF13		; was it TI$ pointer
00A9DE  2  D0 4C        	bne	A_AA2C			; branch if not
00A9E0  2               
00A9E0  2               ; else it's TI$ = <expr$>
00A9E0  2  20 A6 B6     	jsr	PopStrDescStk		; pop string off descriptor stack, or
00A9E3  2               					; from top of string space returns with
00A9E3  2               					; A = length, X = pointer LB, Y =
00A9E3  2               					; pointer HB			[B6A6]
00A9E3  2  C9 06        	cmp	#$06			; compare length with 6
00A9E5  2  D0 3D        	bne	A_AA24			; if length not 6 do illegal quantity
00A9E7  2               					; error then warm start
00A9E7  2  A0 00        	ldy	#$00			; clear index
00A9E9  2  84 61        	sty	FACEXP			; clear FAC1 exponent
00A9EB  2  84 66        	sty	FACSGN			; clear FAC1 sign (b7)
00A9ED  2               A_A9ED:					;				[A9ED]
00A9ED  2  84 71        	sty	FBUFPT			; save index
00A9EF  2               
00A9EF  2  20 1D AA     	jsr	ChkCharIsNum		; check and evaluate numeric digit
00A9F2  2               					;				[AA1D]
00A9F2  2  20 E2 BA     	jsr	Fac1x10			; multiply FAC1 by 10		[BAE2]
00A9F5  2               
00A9F5  2  E6 71        	inc	FBUFPT			; increment index
00A9F7  2               
00A9F7  2  A4 71        	ldy	FBUFPT			; restore index
00A9F9  2  20 1D AA     	jsr	ChkCharIsNum		; check and evaluate numeric digit
00A9FC  2               					;				[AA1D]
00A9FC  2  20 0C BC     	jsr	CopyFAC1toFAC2		; round and copy FAC1 to FAC2	[BC0C]
00A9FF  2  AA           	tax				; copy FAC1 exponent
00AA00  2  F0 05        	beq	A_AA07			; branch if FAC1 zero
00AA02  2               
00AA02  2  E8           	inx				; increment index, * 2
00AA03  2  8A           	txa				; copy back to A
00AA04  2               
00AA04  2  20 ED BA     	jsr	FAC1plFAC2x2		; FAC1 = (FAC1 + (FAC2 * 2)) * 2 =
00AA07  2               					; FAC1 * 6			[BAED]
00AA07  2               A_AA07:					;				[AA07]
00AA07  2  A4 71        	ldy	FBUFPT			; get index
00AA09  2  C8           	iny				; increment index
00AA0A  2  C0 06        	cpy	#$06			; compare index with 6
00AA0C  2  D0 DF        	bne	A_A9ED			; loop if not 6
00AA0E  2               
00AA0E  2  20 E2 BA     	jsr	Fac1x10			; multiply FAC1 by 10		[BAE2]
00AA11  2  20 9B BC     	jsr	FAC1Float2Fix		; convert FAC1 floating to fixed [BC9B]
00AA14  2               
00AA14  2  A6 64        	ldx	FacMantissa+2		; get FAC1 mantissa 3
00AA16  2  A4 63        	ldy	FacMantissa+1		; get FAC1 mantissa 2
00AA18  2  A5 65        	lda	FacMantissa+3		; get FAC1 mantissa 4
00AA1A  2               
00AA1A  2  4C DB FF     	jmp	SetClock		; set real time clock and return [FFDB]
00AA1D  2               
00AA1D  2               
00AA1D  2               ;******************************************************************************
00AA1D  2               ;
00AA1D  2               ; check and evaluate numeric digit
00AA1D  2               ;
00AA1D  2               ChkCharIsNum:				;				[AA1D]
00AA1D  2  B1 22        	lda	(INDEX),Y		; get byte from string
00AA1F  2  20 80 00     	jsr	NumericTest		; clear Cb if numeric. this call should
00AA22  2               					; be to $84 as the code from NumericTest
00AA22  2               					; first comapres the byte with [SPACE]
00AA22  2               					; and does a BASIC increment and get if
00AA22  2               					; it is				[0080]
00AA22  2  90 03        	bcc	A_AA27			; branch if numeric
00AA24  2               A_AA24:					;				[AA24]
00AA24  2  4C 48 B2     	jmp	IllegalQuant		; do illegal quantity error then warm
00AA27  2               					; start				[B248]
00AA27  2               A_AA27:					;				[AA27]
00AA27  2  E9 2F        	sbc	#'0'-1			; subtract $2F + carry to convert ASCII
00AA29  2               					; to binary
00AA29  2  4C 7E BD     	jmp	EvalNewDigit		; evaluate new ASCII digit and return
00AA2C  2               					;				[BD7E]
00AA2C  2               
00AA2C  2               ;******************************************************************************
00AA2C  2               ;
00AA2C  2               ; assign value to numeric variable, but not TI$
00AA2C  2               ;
00AA2C  2               A_AA2C:					;				[AA2C]
00AA2C  2  A0 02        	ldy	#$02			; index to string pointer HB
00AA2E  2  B1 64        	lda	(FacMantissa+2),Y	; get string pointer HB
00AA30  2  C5 34        	cmp	FRETOP+1		; compare with bottom of string space HB
00AA32  2  90 17        	bcc	A_AA4B			; branch if string pointer HB is less
00AA34  2               					; than bottom of string space HB
00AA34  2               
00AA34  2  D0 07        	bne	A_AA3D			; branch if string pointer HB is greater
00AA36  2               					; than bottom of string space HB
00AA36  2               
00AA36  2               ; else HBs were equal
00AA36  2  88           	dey				; decrement index to string pointer LB
00AA37  2  B1 64        	lda	(FacMantissa+2),Y	; get string pointer LB
00AA39  2  C5 33        	cmp	FRETOP			; compare with bottom of string space LB
00AA3B  2  90 0E        	bcc	A_AA4B			; branch if string pointer LB is less
00AA3D  2               					; than bottom of string space LB
00AA3D  2               
00AA3D  2               A_AA3D:					;				[AA3D]
00AA3D  2  A4 65        	ldy	FacMantissa+3		; get descriptor pointer HB
00AA3F  2  C4 2E        	cpy	VARTAB+1		; compare with start of variables HB
00AA41  2  90 08        	bcc	A_AA4B			; branch if less, is on string stack
00AA43  2               
00AA43  2  D0 0D        	bne	A_AA52			; if greater make space and copy string
00AA45  2               
00AA45  2               ; else HBs were equal
00AA45  2  A5 64        	lda	FacMantissa+2		; get descriptor pointer LB
00AA47  2  C5 2D        	cmp	VARTAB			; compare with start of variables LB
00AA49  2  B0 07        	bcs	A_AA52			; if greater or equal make space and
00AA4B  2               					; copy string
00AA4B  2               A_AA4B:					;				[AA4B]
00AA4B  2  A5 64        	lda	FacMantissa+2		; get descriptor pointer LB
00AA4D  2  A4 65        	ldy	FacMantissa+3		; get descriptor pointer HB
00AA4F  2  4C 68 AA     	jmp	A_AA68			; go copy descriptor to variable [AA68]
00AA52  2               
00AA52  2               A_AA52:					;				[AA52]
00AA52  2  A0 00        	ldy	#$00			; clear index
00AA54  2  B1 64        	lda	(FacMantissa+2),Y	; get string length
00AA56  2  20 75 B4     	jsr	StringVector		; copy descriptor pointer and make
00AA59  2               					; string space A bytes long	[B475]
00AA59  2  A5 50        	lda	TempPtr			; copy old descriptor pointer LB
00AA5B  2  A4 51        	ldy	TempPtr+1		; copy old descriptor pointer HB
00AA5D  2  85 6F        	sta	ARISGN			; save old descriptor pointer LB
00AA5F  2  84 70        	sty	FACOV			; save old descriptor pointer HB
00AA61  2               
00AA61  2  20 7A B6     	jsr	Str2UtilPtr		; copy string from descriptor to utility
00AA64  2               					; pointer			[B67A]
00AA64  2               
00AA64  2  A9 61        	lda	#<FACEXP		; get descriptor pointer LB
00AA66  2  A0 00        	ldy	#>FACEXP		; get descriptor pointer HB
00AA68  2               A_AA68:					;				[AA68]
00AA68  2  85 50        	sta	TempPtr			; save descriptor pointer LB
00AA6A  2  84 51        	sty	TempPtr+1		; save descriptor pointer HB
00AA6C  2               
00AA6C  2  20 DB B6     	jsr	ClrDescrStack		; clean descriptor stack, YA = pointer
00AA6F  2               					;				[B6DB]
00AA6F  2  A0 00        	ldy	#$00			; clear index
00AA71  2  B1 50        	lda	(TempPtr),Y		; get string length from new descriptor
00AA73  2  91 49        	sta	(FORPNT),Y		; copy string length to variable
00AA75  2               
00AA75  2  C8           	iny				; increment index
00AA76  2  B1 50        	lda	(TempPtr),Y		; get string pointer LB from new
00AA78  2               					; descriptor
00AA78  2  91 49        	sta	(FORPNT),Y		; copy string pointer LB to variable
00AA7A  2               
00AA7A  2  C8           	iny				; increment index
00AA7B  2  B1 50        	lda	(TempPtr),Y		; get string pointer HB from new
00AA7D  2               					; descriptor
00AA7D  2  91 49        	sta	(FORPNT),Y		; copy string pointer HB to variable
00AA7F  2               
00AA7F  2  60           	rts
00AA80  2               
00AA80  2               
00AA80  2               ;******************************************************************************
00AA80  2               ;
00AA80  2               ; perform PRINT#
00AA80  2               ;
00AA80  2               bcPRINTH:
00AA80  2  20 86 AA     	jsr	bcCMD			; perform CMD			[AA86]
00AA83  2  4C B5 AB     	jmp	bcINPUTH2		; close input and output channels and
00AA86  2               					; return			[ABB5]
00AA86  2               
00AA86  2               ;******************************************************************************
00AA86  2               ;
00AA86  2               ; perform CMD
00AA86  2               ;
00AA86  2               bcCMD:
00AA86  2  20 9E B7     	jsr	GetByteParm2		; get byte parameter		[B79E]
00AA89  2  F0 05        	beq	A_AA90			; branch if following byte is ":" or
00AA8B  2               					; [EOT]
00AA8B  2  A9 2C        	lda	#','			; set ","
00AA8D  2  20 FF AE     	jsr	Chk4CharInA		; scan for CHR$(A), else do syntax error
00AA90  2               					; then warm start		[AEFF]
00AA90  2               A_AA90:					;				[AA90]
00AA90  2  08           	php				; save status
00AA91  2               
00AA91  2  86 13        	stx	CurIoChan		; set current I/O channel
00AA93  2               
00AA93  2  20 18 E1     	jsr	OpenChan4OutpA		; open channel for output with error
00AA96  2               					; check				[E118]
00AA96  2  28           	plp				; restore status
00AA97  2  4C A0 AA     	jmp	bcPRINT			; perform PRINT			[AAA0]
00AA9A  2               
00AA9A  2               A_AA9A:					;				[AA9A]
00AA9A  2  20 21 AB     	jsr	OutputString2		; print string from utility pointer
00AA9D  2               					;				[AB21]
00AA9D  2               A_AA9D:					;				[AA9D]
00AA9D  2  20 79 00     	jsr	CHRGOT			; scan memory			[0079]
00AAA0  2               
00AAA0  2               
00AAA0  2               ;******************************************************************************
00AAA0  2               ;
00AAA0  2               ; perform PRINT
00AAA0  2               ;
00AAA0  2               bcPRINT:
00AAA0  2  F0 35        	beq	OutCRLF			; if nothing following just print CR/LF
00AAA2  2               
00AAA2  2               bcPRINT2:				;				[AAA2]
00AAA2  2  F0 43        	beq	A_AAE7			; exit if nothing following, end of
00AAA4  2               					; PRINT branch
00AAA4  2  C9 A3        	cmp	#TK_TAB			; compare with token for TAB(
00AAA6  2  F0 50        	beq	A_AAF8			; if TAB( go handle it
00AAA8  2               
00AAA8  2  C9 A6        	cmp	#TK_SPC			; compare with token for SPC(
00AAAA  2  18           	clc				; flag SPC(
00AAAB  2  F0 4B        	beq	A_AAF8			; if SPC( go handle it
00AAAD  2               
00AAAD  2  C9 2C        	cmp	#','			; compare with ","
00AAAF  2  F0 37        	beq	A_AAE8			; if "," go skip to the next TAB
00AAB1  2               					; position
00AAB1  2  C9 3B        	cmp	#';'			; compare with ";"
00AAB3  2  F0 5E        	beq	A_AB13			; if ";" go continue the print loop
00AAB5  2               
00AAB5  2  20 9E AD     	jsr	EvaluateValue		; evaluate expression		[AD9E]
00AAB8  2  24 0D        	bit	VALTYP			; test data type flag, $FF = string,
00AABA  2               					; $00 = numeric
00AABA  2  30 DE        	bmi	A_AA9A			; if string go print string, scan memory
00AABC  2               					; and continue PRINT
00AABC  2               
00AABC  2  20 DD BD     	jsr	FAC1toASCII		; convert FAC1 to ASCII string result
00AABF  2               					; in (AY)			[BDDD]
00AABF  2  20 87 B4     	jsr	QuoteStr2UtPtr		; print " terminated string to utility
00AAC2  2               					; pointer			[B487]
00AAC2  2  20 21 AB     	jsr	OutputString2		; print string from utility pointer
00AAC5  2               					;				[AB21]
00AAC5  2  20 3B AB     	jsr	PrintSpace		; print [SPACE] or [CURSOR RIGHT] [AB3B]
00AAC8  2  D0 D3        	bne	A_AA9D			; always -> go scan memory and continue
00AACA  2               					; PRINT
00AACA  2               
00AACA  2               ;******************************************************************************
00AACA  2               ;
00AACA  2               ; set XY to CommandBuf - 1
00AACA  2               ;
00AACA  2               SetXY2CmdBuf:				;				[AACA]
00AACA  2  A9 00        	lda	#$00			; clear A
00AACC  2  9D 00 02     	sta	CommandBuf,X		; clear first byte of input buffer
00AACF  2               
00AACF  2  A2 FF        	ldx	#<(CommandBuf-1)	; CommandBuf - 1 LB
00AAD1  2  A0 01        	ldy	#>(CommandBuf-1)	; CommandBuf - 1 HB
00AAD3  2               
00AAD3  2  A5 13        	lda	CurIoChan		; get current I/O channel
00AAD5  2  D0 10        	bne	A_AAE7			; exit if not default channel
00AAD7  2               
00AAD7  2               
00AAD7  2               ;******************************************************************************
00AAD7  2               ;
00AAD7  2               ; print CR/LF
00AAD7  2               ;
00AAD7  2               OutCRLF:				;				[AAD7]
00AAD7  2  A9 0D        	lda	#$0D			; set [CR]
00AAD9  2  20 47 AB     	jsr	PrintChar		; print the character		[AB47]
00AADC  2  24 13        	bit	CurIoChan		; test current I/O channel
00AADE  2  10 05        	bpl	EOR_FF			; if ?? toggle A, EOR #$FF and return
00AAE0  2               
00AAE0  2  A9 0A        	lda	#$0A			; set [LF]
00AAE2  2  20 47 AB     	jsr	PrintChar		; print the character		[AB47]
00AAE5  2               
00AAE5  2               ; toggle A
00AAE5  2               EOR_FF:					;				[AAE5]
00AAE5  2  49 FF        	eor	#$FF			; invert A
00AAE7  2               A_AAE7:					;				[AAE7]
00AAE7  2  60           	rts
00AAE8  2               
00AAE8  2               ; was ","
00AAE8  2               A_AAE8:					;				[AAE8]
00AAE8  2  38           	sec				; set C flag for read cursor position
00AAE9  2  20 F0 FF     	jsr	CursorPosXY		; read/set X,Y cursor position	[FFF0]
00AAEC  2  98           	tya				; copy cursor Y
00AAED  2               
00AAED  2  38           	sec				; set carry for subtract
00AAEE  2               A_AAEE:					;				[AAEE]
00AAEE  2  E9 0A        	sbc	#$0A			; subtract one TAB length
00AAF0  2  B0 FC        	bcs	A_AAEE			; loop if result was +ve
00AAF2  2               
00AAF2  2  49 FF        	eor	#$FF			; complement it
00AAF4  2  69 01        	adc	#$01			; +1, twos complement
00AAF6  2  D0 16        	bne	A_AB0E			; always print A spaces, result is
00AAF8  2               					; never $00
00AAF8  2               A_AAF8:					;				[AAF8]
00AAF8  2  08           	php				; save TAB( or SPC( status
00AAF9  2               
00AAF9  2  38           	sec				; set Cb for read cursor position
00AAFA  2  20 F0 FF     	jsr	CursorPosXY		; read/set X,Y cursor position	[FFF0]
00AAFD  2  84 09        	sty	TRMPOS			; save current cursor position
00AAFF  2               
00AAFF  2  20 9B B7     	jsr	GetByteParm		; scan and get byte parameter	[B79B]
00AB02  2  C9 29        	cmp	#')'			; compare with ")"
00AB04  2  D0 59        	bne	A_AB5F			; if not ")" do syntax error
00AB06  2               
00AB06  2  28           	plp				; restore TAB( or SPC( status
00AB07  2  90 06        	bcc	A_AB0F			; branch if was SPC(
00AB09  2               
00AB09  2               ; else was TAB(
00AB09  2  8A           	txa				; copy TAB() byte to A
00AB0A  2  E5 09        	sbc	TRMPOS			; subtract current cursor position
00AB0C  2  90 05        	bcc	A_AB13			; go loop for next if already past
00AB0E  2               					; requited position
00AB0E  2               A_AB0E:					;				[AB0E]
00AB0E  2  AA           	tax				; copy [SPACE] count to X
00AB0F  2               A_AB0F:					;				[AB0F]
00AB0F  2  E8           	inx				; increment count
00AB10  2               A_AB10:					;				[AB10]
00AB10  2  CA           	dex				; decrement count
00AB11  2  D0 06        	bne	A_AB19			; branch if count was not zero
00AB13  2               
00AB13  2               ; was ";" or [SPACES] printed
00AB13  2               A_AB13:					;				[AB13]
00AB13  2  20 73 00     	jsr	CHRGET			; increment and scan memory	[0073]
00AB16  2  4C A2 AA     	jmp	bcPRINT2		; continue print loop		[AAA2]
00AB19  2               
00AB19  2               A_AB19:					;				[AB19]
00AB19  2  20 3B AB     	jsr	PrintSpace		; print [SPACE] or [CURSOR RIGHT] [AB3B]
00AB1C  2  D0 F2        	bne	A_AB10			; loop, branch always
00AB1E  2               
00AB1E  2               
00AB1E  2               ;******************************************************************************
00AB1E  2               ;
00AB1E  2               ; print null terminated string
00AB1E  2               ;
00AB1E  2               OutputString:				;				[AB1E]
00AB1E  2  20 87 B4     	jsr	QuoteStr2UtPtr		; print " terminated string to utility
00AB21  2               					; pointer			[B487]
00AB21  2               
00AB21  2               ;******************************************************************************
00AB21  2               ;
00AB21  2               ; print string from utility pointer
00AB21  2               ;
00AB21  2               OutputString2:				;				[AB21]
00AB21  2  20 A6 B6     	jsr	PopStrDescStk		; pop string off descriptor stack, or
00AB24  2               					; from top of string		[B6A6]
00AB24  2               					; space returns with A = length,
00AB24  2               					; X = pointer LB, Y = pointer HB
00AB24  2  AA           	tax				; copy length
00AB25  2               
00AB25  2  A0 00        	ldy	#$00			; clear index
00AB27  2  E8           	inx				; increment length, for pre decrement
00AB28  2               					; loop
00AB28  2               OutputString3:				;				[AB28]
00AB28  2  CA           	dex				; decrement length
00AB29  2  F0 BC        	beq	A_AAE7			; exit if done
00AB2B  2               
00AB2B  2  B1 22        	lda	(INDEX),Y		; get byte from string
00AB2D  2  20 47 AB     	jsr	PrintChar		; print the character		[AB47]
00AB30  2               
00AB30  2  C8           	iny				; increment index
00AB31  2               
00AB31  2  C9 0D        	cmp	#$0D			; compare byte with [CR]
00AB33  2  D0 F3        	bne	OutputString3		; loop if not [CR]
00AB35  2               
00AB35  2  20 E5 AA     	jsr	EOR_FF			; toggle A, EOR #$FF. what is the point
00AB38  2               					; of this ??			[AAE5]
00AB38  2  4C 28 AB     	jmp	OutputString3		; loop				[AB28]
00AB3B  2               
00AB3B  2               
00AB3B  2               ;******************************************************************************
00AB3B  2               ;
00AB3B  2               ; print [SPACE] or [CURSOR RIGHT]
00AB3B  2               ;
00AB3B  2               PrintSpace:				;				[AB3B]
00AB3B  2  A5 13        	lda	CurIoChan		; get current I/O channel
00AB3D  2  F0 03        	beq	A_AB42			; if default channel go output
00AB3F  2               					; [CURSOR RIGHT]
00AB3F  2  A9 20        	lda	#' '			; else output [SPACE]
00AB41  2  2C           .byte	$2C				; makes next line BIT $1DA9
00AB42  2               A_AB42:					;				[AB42]
00AB42  2  A9 1D        	lda	#$1D			; set [CURSOR RIGHT]
00AB44  2  2C           .byte	$2C				; makes next line BIT $3FA9
00AB45  2               
00AB45  2               
00AB45  2               ;******************************************************************************
00AB45  2               ;
00AB45  2               ; print "?"
00AB45  2               ;
00AB45  2               PrintQuestMark:				;				[AB45]
00AB45  2  A9 3F        	lda	#'?'			; set "?"
00AB47  2               
00AB47  2               
00AB47  2               ;******************************************************************************
00AB47  2               ;
00AB47  2               ; print character
00AB47  2               ;
00AB47  2               PrintChar:				;				[AB47]
00AB47  2  20 0C E1     	jsr	OutCharErrChan		; output character to channel with
00AB4A  2               					; error check			[E10C]
00AB4A  2  29 FF        	and	#$FF			; set the flags on A
00AB4C  2  60           	rts
00AB4D  2               
00AB4D  2               
00AB4D  2               ;******************************************************************************
00AB4D  2               ;
00AB4D  2               ; bad input routine
00AB4D  2               ; Check the variable INPFLG where the error lays
00AB4D  2               ;
00AB4D  2               CheckINPFLG:				;				[AB4D]
00AB4D  2  A5 11        	lda	INPFLG			; get INPUT mode flag, $00 = INPUT,
00AB4F  2               					; $40 = GET, $98 = READ
00AB4F  2  F0 11        	beq	A_AB62			; branch if INPUT
00AB51  2               
00AB51  2  30 04        	bmi	A_AB57			; branch if READ
00AB53  2               
00AB53  2               ; else was GET
00AB53  2  A0 FF        	ldy	#$FF			; set current line HB to -1, indicate
00AB55  2               					; immediate mode
00AB55  2  D0 04        	bne	A_AB5B			; branch always
00AB57  2               
00AB57  2               ; error with READ
00AB57  2               A_AB57:					;				[AB57]
00AB57  2  A5 3F        	lda	DATLIN			; get current DATA line number LB
00AB59  2  A4 40        	ldy	DATLIN+1		; get current DATA line number HB
00AB5B  2               
00AB5B  2               ; error with GET
00AB5B  2               A_AB5B:					;				[AB5B]
00AB5B  2  85 39        	sta	CURLIN			; set current line number LB
00AB5D  2  84 3A        	sty	CURLIN+1		; set current line number HB
00AB5F  2               A_AB5F:					;				[AB5F]
00AB5F  2  4C 08 AF     	jmp	SyntaxError		; do syntax error then warm start [AF08]
00AB62  2               
00AB62  2               ; was INPUT
00AB62  2               ; error with INPUT
00AB62  2               A_AB62:					;				[AB62]
00AB62  2  A5 13        	lda	CurIoChan		; get current I/O channel
00AB64  2  F0 05        	beq	A_AB6B			; branch if default channel
00AB66  2               
00AB66  2  A2 18        	ldx	#$18			; else error $18, file data error
00AB68  2  4C 37 A4     	jmp	OutputErrMsg		; do error #X then warm start	[A437]
00AB6B  2               
00AB6B  2               A_AB6B:					;				[AB6B]
00AB6B  2  A9 0C        	lda	#<txtREDOFROM		; set "?REDO FROM START" pointer LB
00AB6D  2  A0 AD        	ldy	#>txtREDOFROM		; set "?REDO FROM START" pointer HB
00AB6F  2  20 1E AB     	jsr	OutputString		; print null terminated string	[AB1E]
00AB72  2               
00AB72  2  A5 3D        	lda	OLDTXT			; get continue pointer LB
00AB74  2  A4 3E        	ldy	OLDTXT+1		; get continue pointer HB
00AB76  2  85 7A        	sta	TXTPTR			; save BASIC execute pointer LB
00AB78  2  84 7B        	sty	TXTPTR+1		; save BASIC execute pointer HB
00AB7A  2               
00AB7A  2  60           	rts
00AB7B  2               
00AB7B  2               
00AB7B  2               ;******************************************************************************
00AB7B  2               ;
00AB7B  2               ; perform GET
00AB7B  2               ;
00AB7B  2               bcGET:
00AB7B  2  20 A6 B3     	jsr	ChkDirectMode		; check not Direct, back here if ok
00AB7E  2               					;				[B3A6]
00AB7E  2  C9 23        	cmp	#'#'			; compare with "#"
00AB80  2  D0 10        	bne	A_AB92			; branch if not GET#
00AB82  2               
00AB82  2  20 73 00     	jsr	CHRGET			; increment and scan memory	[0073]
00AB85  2  20 9E B7     	jsr	GetByteParm2		; get byte parameter		[B79E]
00AB88  2               
00AB88  2  A9 2C        	lda	#','			; set ","
00AB8A  2  20 FF AE     	jsr	Chk4CharInA		; scan for CHR$(A), else do syntax error
00AB8D  2               					; then warm start		[AEFF]
00AB8D  2  86 13        	stx	CurIoChan		; set current I/O channel
00AB8F  2               
00AB8F  2  20 1E E1     	jsr	OpenChan4Inp0		; open channel for input with error
00AB92  2               					; check				[E11E]
00AB92  2               A_AB92:					;				[AB92]
00AB92  2  A2 01        	ldx	#<(CommandBuf+1)	; set pointer low byte
00AB94  2  A0 02        	ldy	#>(CommandBuf+1)	; set pointer high byte
00AB96  2               
00AB96  2  A9 00        	lda	#$00			; clear A
00AB98  2  8D 01 02     	sta	CommandBuf+1		; ensure null terminator
00AB9B  2               
00AB9B  2  A9 40        	lda	#$40			; input mode = GET
00AB9D  2  20 0F AC     	jsr	bcREAD2			; perform the GET part of READ	[AC0F]
00ABA0  2               
00ABA0  2  A6 13        	ldx	CurIoChan		; get current I/O channel
00ABA2  2  D0 13        	bne	A_ABB7			; if not default channel go do channel
00ABA4  2               					; close and return
00ABA4  2  60           	rts
00ABA5  2               
00ABA5  2               
00ABA5  2               ;******************************************************************************
00ABA5  2               ;
00ABA5  2               ; perform INPUT#
00ABA5  2               ;
00ABA5  2               bcINPUTH:
00ABA5  2  20 9E B7     	jsr	GetByteParm2		; get byte parameter		[B79E]
00ABA8  2               
00ABA8  2  A9 2C        	lda	#','			; set ","
00ABAA  2  20 FF AE     	jsr	Chk4CharInA		; scan for CHR$(A), else do syntax error
00ABAD  2               					; then warm start		[AEFF]
00ABAD  2  86 13        	stx	CurIoChan		; set current I/O channel
00ABAF  2               
00ABAF  2  20 1E E1     	jsr	OpenChan4Inp0		; open channel for input with error
00ABB2  2               					; check				[E11E]
00ABB2  2  20 CE AB     	jsr	bcINPUT2		; perform INPUT with no prompt string
00ABB5  2               					;				[ABCE]
00ABB5  2               
00ABB5  2               
00ABB5  2               ;******************************************************************************
00ABB5  2               ;
00ABB5  2               ; close input and output channels
00ABB5  2               ;
00ABB5  2               bcINPUTH2:				;				[ABB5]
00ABB5  2  A5 13        	lda	CurIoChan		; get current I/O channel
00ABB7  2               A_ABB7:					;				[ABB7]
00ABB7  2  20 CC FF     	jsr	CloseIoChannls		; close input and output channels [FFCC]
00ABBA  2               
00ABBA  2  A2 00        	ldx	#$00			; clear X
00ABBC  2  86 13        	stx	CurIoChan		; clear current I/O channel, flag
00ABBE  2               					; default
00ABBE  2  60           	rts
00ABBF  2               
00ABBF  2               
00ABBF  2               ;******************************************************************************
00ABBF  2               ;
00ABBF  2               ; perform INPUT
00ABBF  2               ;
00ABBF  2               bcINPUT:
00ABBF  2  C9 22        	cmp	#'"'			; compare next byte with open quote
00ABC1  2  D0 0B        	bne	bcINPUT2		; if no prompt string just do INPUT
00ABC3  2               
00ABC3  2  20 BD AE     	jsr	GetNextParm3		; print "..." string		[AEBD]
00ABC6  2               
00ABC6  2  A9 3B        	lda	#';'			; load A with ";"
00ABC8  2  20 FF AE     	jsr	Chk4CharInA		; scan for CHR$(A), else do syntax error
00ABCB  2               					; then warm start		[AEFF]
00ABCB  2  20 21 AB     	jsr	OutputString2		; print string from utility pointer
00ABCE  2               					;				[AB21]
00ABCE  2               ; done with prompt, now get data
00ABCE  2               bcINPUT2:				;				[ABCE]
00ABCE  2  20 A6 B3     	jsr	ChkDirectMode		; check not Direct, back here if ok
00ABD1  2               					;				[B3A6]
00ABD1  2  A9 2C        	lda	#','			; set ","
00ABD3  2  8D FF 01     	sta	CommandBuf-1		; save to start of buffer - 1
00ABD6  2               A_ABD6:					;				[ABD6]
00ABD6  2  20 F9 AB     	jsr	OutQuestMark		; print "? " and get BASIC input [ABF9]
00ABD9  2               
00ABD9  2  A5 13        	lda	CurIoChan		; get current I/O channel
00ABDB  2  F0 0D        	beq	A_ABEA			; branch if default I/O channel
00ABDD  2               
00ABDD  2  20 B7 FF     	jsr	ReadIoStatus		; read I/O status word		[FFB7]
00ABE0  2  29 02        	and	#$02			; mask no DSR/timeout
00ABE2  2  F0 06        	beq	A_ABEA			; branch if not error
00ABE4  2               
00ABE4  2  20 B5 AB     	jsr	bcINPUTH2		; close input and output channels [ABB5]
00ABE7  2  4C F8 A8     	jmp	bcDATA			; perform DATA			[A8F8]
00ABEA  2               
00ABEA  2               A_ABEA:					;				[ABEA]
00ABEA  2  AD 00 02     	lda	CommandBuf		; get first byte in input buffer
00ABED  2  D0 1E        	bne	A_AC0D			; branch if not null
00ABEF  2               
00ABEF  2               ; else ..
00ABEF  2  A5 13        	lda	CurIoChan		; get current I/O channel
00ABF1  2  D0 E3        	bne	A_ABD6			; if not default channel go get BASIC
00ABF3  2               					; input
00ABF3  2  20 06 A9     	jsr	FindNextColon		; scan for next BASIC statement ([:] or
00ABF6  2               					; [EOL])			[A906]
00ABF6  2  4C FB A8     	jmp	bcDATA2			; add Y to the BASIC execute pointer
00ABF9  2               					; and return			[A8FB]
00ABF9  2               
00ABF9  2               ;******************************************************************************
00ABF9  2               ;
00ABF9  2               ; print "? " and get BASIC input
00ABF9  2               ;
00ABF9  2               OutQuestMark:				;				[ABF9]
00ABF9  2  A5 13        	lda	CurIoChan		; get current I/O channel
00ABFB  2  D0 06        	bne	A_AC03			; skip "?" prompt if not default channel
00ABFD  2               
00ABFD  2  20 45 AB     	jsr	PrintQuestMark		; print "?"			[AB45]
00AC00  2  20 3B AB     	jsr	PrintSpace		; print [SPACE] or [CURSOR RIGHT] [AB3B]
00AC03  2               A_AC03:					;				[AC03]
00AC03  2  4C 60 A5     	jmp	InputNewLine		; call for BASIC input and return [A560]
00AC06  2               
00AC06  2               
00AC06  2               ;******************************************************************************
00AC06  2               ;
00AC06  2               ; perform READ
00AC06  2               ;
00AC06  2               bcREAD:
00AC06  2  A6 41        	ldx	DATPTR			; get DATA pointer LB
00AC08  2  A4 42        	ldy	DATPTR+1		; get DATA pointer HB
00AC0A  2  A9 98        	lda	#$98			; set input mode = READ
00AC0C  2  2C           .byte	$2C				; makes next line BIT $00A9
00AC0D  2               A_AC0D:					;				[AC0D]
00AC0D  2  A9 00        	lda	#$00			; set input mode = INPUT
00AC0F  2               
00AC0F  2               
00AC0F  2               ;******************************************************************************
00AC0F  2               ;
00AC0F  2               ; perform GET
00AC0F  2               ;
00AC0F  2               bcREAD2:				;				[AC0F]
00AC0F  2  85 11        	sta	INPFLG			; set input mode flag, $00 = INPUT,
00AC11  2               					; $40 = GET, $98 = READ
00AC11  2  86 43        	stx	INPPTR			; save READ pointer LB
00AC13  2  84 44        	sty	INPPTR+1		; save READ pointer HB
00AC15  2               
00AC15  2               ; READ, GET or INPUT next variable from list
00AC15  2               bcREAD3:				;				[AC15]
00AC15  2  20 8B B0     	jsr	GetAddrVar		; get variable address		[B08B]
00AC18  2  85 49        	sta	FORPNT			; save address LB
00AC1A  2  84 4A        	sty	FORPNT+1		; save address HB
00AC1C  2               
00AC1C  2  A5 7A        	lda	TXTPTR			; get BASIC execute pointer LB
00AC1E  2  A4 7B        	ldy	TXTPTR+1		; get BASIC execute pointer HB
00AC20  2  85 4B        	sta	TEMPSTR			; save BASIC execute pointer LB
00AC22  2  84 4C        	sty	TEMPSTR+1		; save BASIC execute pointer HB
00AC24  2               
00AC24  2  A6 43        	ldx	INPPTR			; get READ pointer LB
00AC26  2  A4 44        	ldy	INPPTR+1		; get READ pointer HB
00AC28  2  86 7A        	stx	TXTPTR			; save as BASIC execute pointer LB
00AC2A  2  84 7B        	sty	TXTPTR+1		; save as BASIC execute pointer HB
00AC2C  2               
00AC2C  2  20 79 00     	jsr	CHRGOT			; scan memory			[0079]
00AC2F  2  D0 20        	bne	bcREAD4			; branch if not null
00AC31  2               
00AC31  2               ; pointer was to null entry
00AC31  2  24 11        	bit	INPFLG			; test input mode flag, $00 = INPUT,
00AC33  2               					; $40 = GET, $98 = READ
00AC33  2  50 0C        	bvc	A_AC41			; branch if not GET
00AC35  2               
00AC35  2               ; else was GET
00AC35  2  20 24 E1     	jsr	GetCharFromIO		; get character from input device with
00AC38  2               					; error check			[E124]
00AC38  2  8D 00 02     	sta	CommandBuf		; save to buffer
00AC3B  2               
00AC3B  2  A2 FF        	ldx	#<(CommandBuf-1)	; CommandBuf - 1 LB
00AC3D  2  A0 01        	ldy	#>(CommandBuf-1)	; CommandBuf - 1 HB
00AC3F  2  D0 0C        	bne	A_AC4D			; go interpret single character
00AC41  2               
00AC41  2               A_AC41:					;				[AC41]
00AC41  2  30 75        	bmi	A_ACB8			; branch if READ
00AC43  2               
00AC43  2               ; else was INPUT
00AC43  2  A5 13        	lda	CurIoChan		; get current I/O channel
00AC45  2  D0 03        	bne	A_AC4A			; skip "?" prompt if not default channel
00AC47  2               
00AC47  2  20 45 AB     	jsr	PrintQuestMark		; print "?"			[AB45]
00AC4A  2               A_AC4A:					;				[AC4A]
00AC4A  2  20 F9 AB     	jsr	OutQuestMark		; print "? " and get BASIC input [ABF9]
00AC4D  2               A_AC4D:					;				[AC4D]
00AC4D  2  86 7A        	stx	TXTPTR			; save BASIC execute pointer LB
00AC4F  2  84 7B        	sty	TXTPTR+1		; save BASIC execute pointer HB
00AC51  2               bcREAD4:				;				[AC51]
00AC51  2  20 73 00     	jsr	CHRGET			; increment and scan memory, execute
00AC54  2               					; pointer now points to		[0073]
00AC54  2               					; start of next data or null terminator
00AC54  2  24 0D        	bit	VALTYP			; test data type flag, $FF = string,
00AC56  2               					; $00 = numeric
00AC56  2  10 31        	bpl	A_AC89			; branch if numeric
00AC58  2               
00AC58  2               ; type is string
00AC58  2  24 11        	bit	INPFLG			; test INPUT mode flag, $00 = INPUT,
00AC5A  2               					; $40 = GET, $98 = READ
00AC5A  2  50 09        	bvc	A_AC65			; branch if not GET
00AC5C  2               
00AC5C  2               ; else do string GET
00AC5C  2  E8           	inx				; clear X ??
00AC5D  2  86 7A        	stx	TXTPTR			; save BASIC execute pointer LB
00AC5F  2               
00AC5F  2  A9 00        	lda	#$00			; clear A
00AC61  2  85 07        	sta	CHARAC			; clear search character
00AC63  2  F0 0C        	beq	A_AC71			; branch always
00AC65  2               
00AC65  2               ; is string INPUT or string READ
00AC65  2               A_AC65:					;				[AC65]
00AC65  2  85 07        	sta	CHARAC			; save search character
00AC67  2               
00AC67  2  C9 22        	cmp	#'"'			; compare with "
00AC69  2  F0 07        	beq	A_AC72			; branch if quote
00AC6B  2               
00AC6B  2               ; string is not in quotes so ":", "," or $00 are the termination characters
00AC6B  2  A9 3A        	lda	#':'			; set ":"
00AC6D  2  85 07        	sta	CHARAC			; set search character
00AC6F  2               
00AC6F  2  A9 2C        	lda	#','			; set ","
00AC71  2               A_AC71:					;				[AC71]
00AC71  2  18           	clc				; clear carry for add
00AC72  2               A_AC72:					;				[AC72]
00AC72  2  85 08        	sta	ENDCHR			; set scan quotes flag
00AC74  2               
00AC74  2               
00AC74  2  A5 7A        	lda	TXTPTR			; get BASIC execute pointer LB
00AC76  2  A4 7B        	ldy	TXTPTR+1		; get BASIC execute pointer HB
00AC78  2  69 00        	adc	#$00			; add to pointer LB. this add increments
00AC7A  2               					; the pointer if the mode is INPUT or
00AC7A  2               					; READ and the data is a "..." string
00AC7A  2  90 01        	bcc	A_AC7D			; branch if no rollover
00AC7C  2               
00AC7C  2  C8           	iny				; else increment pointer HB
00AC7D  2               A_AC7D:					;				[AC7D]
00AC7D  2  20 8D B4     	jsr	PrtStr2UtiPtr		; print string to utility pointer [B48D]
00AC80  2  20 E2 B7     	jsr	RestBasExecPtr		; restore BASIC execute pointer from
00AC83  2               					; temp				[B7E2]
00AC83  2  20 DA A9     	jsr	SetValueString		; perform string LET		[A9DA]
00AC86  2  4C 91 AC     	jmp	bcREAD5			; continue processing command	[AC91]
00AC89  2               
00AC89  2               ; GET, INPUT or READ is numeric
00AC89  2               A_AC89:					;				[AC89]
00AC89  2  20 F3 BC     	jsr	String2FAC1		; get FAC1 from string		[BCF3]
00AC8C  2               
00AC8C  2  A5 0E        	lda	INTFLG			; get data type flag, $80 = integer,
00AC8E  2               					; $00 = float
00AC8E  2  20 C2 A9     	jsr	SetIntegerVar		; assign value to numeric variable
00AC91  2               					;				[A9C2]
00AC91  2               bcREAD5:				;				[AC91]
00AC91  2  20 79 00     	jsr	CHRGOT			; scan memory			[0079]
00AC94  2  F0 07        	beq	A_AC9D			; branch if ":" or [EOL]
00AC96  2               
00AC96  2  C9 2C        	cmp	#','			; comparte with ","
00AC98  2  F0 03        	beq	A_AC9D			; branch if ","
00AC9A  2               
00AC9A  2  4C 4D AB     	jmp	CheckINPFLG		; else go do bad input routine	[AB4D]
00AC9D  2               
00AC9D  2               ; string terminated with ":", "," or $00
00AC9D  2               A_AC9D:					;				[AC9D]
00AC9D  2  A5 7A        	lda	TXTPTR			; get BASIC execute pointer LB
00AC9F  2  A4 7B        	ldy	TXTPTR+1		; get BASIC execute pointer HB
00ACA1  2  85 43        	sta	INPPTR			; save READ pointer LB
00ACA3  2  84 44        	sty	INPPTR+1		; save READ pointer HB
00ACA5  2               
00ACA5  2  A5 4B        	lda	TEMPSTR			; get saved BASIC execute pointer LB
00ACA7  2  A4 4C        	ldy	TEMPSTR+1		; get saved BASIC execute pointer HB
00ACA9  2  85 7A        	sta	TXTPTR			; restore BASIC execute pointer LB
00ACAB  2  84 7B        	sty	TXTPTR+1		; restore BASIC execute pointer HB
00ACAD  2               
00ACAD  2  20 79 00     	jsr	CHRGOT			; scan memory			[0079]
00ACB0  2  F0 2D        	beq	A_ACDF			; branch if ":" or [EOL]
00ACB2  2               
00ACB2  2  20 FD AE     	jsr	Chk4Comma		; scan for ",", else do syntax error
00ACB5  2               					; then warm start		[AEFD]
00ACB5  2  4C 15 AC     	jmp	bcREAD3			; go READ or INPUT next variable from
00ACB8  2               					; list				[AC15]
00ACB8  2               ; was READ
00ACB8  2               A_ACB8:					;				[ACB8]
00ACB8  2  20 06 A9     	jsr	FindNextColon		; scan for next BASIC statement ([:] or
00ACBB  2               					; [EOL])			[A906]
00ACBB  2  C8           	iny				; increment index to next byte
00ACBC  2  AA           	tax				; copy byte to X
00ACBD  2  D0 12        	bne	A_ACD1			; branch if ":"
00ACBF  2               
00ACBF  2  A2 0D        	ldx	#$0D			; else set error $0D, out of data error
00ACC1  2  C8           	iny				; incr. index to next line pointer HB
00ACC2  2  B1 7A        	lda	(TXTPTR),Y		; get next line pointer HB
00ACC4  2  F0 6C        	beq	A_AD32			; branch if program end, eventually does
00ACC6  2               					; error X
00ACC6  2  C8           	iny				; increment index
00ACC7  2  B1 7A        	lda	(TXTPTR),Y		; get next line # LB
00ACC9  2  85 3F        	sta	DATLIN			; save current DATA line LB
00ACCB  2               
00ACCB  2  C8           	iny				; increment index
00ACCC  2  B1 7A        	lda	(TXTPTR),Y		; get next line # HB
00ACCE  2  C8           	iny				; increment index
00ACCF  2  85 40        	sta	DATLIN+1		; save current DATA line HB
00ACD1  2               A_ACD1:					;				[ACD1]
00ACD1  2  20 FB A8     	jsr	bcDATA2			; add Y to the BASIC execute pointer
00ACD4  2               					;				[A8FB]
00ACD4  2  20 79 00     	jsr	CHRGOT			; scan memory			[0079]
00ACD7  2  AA           	tax				; copy the byte
00ACD8  2  E0 83        	cpx	#TK_DATA		; compare it with token for DATA
00ACDA  2  D0 DC        	bne	A_ACB8			; loop if not DATA
00ACDC  2               
00ACDC  2  4C 51 AC     	jmp	bcREAD4			; continue evaluating READ	[AC51]
00ACDF  2               
00ACDF  2               A_ACDF:					;				[ACDF]
00ACDF  2  A5 43        	lda	INPPTR			; get READ pointer LB
00ACE1  2  A4 44        	ldy	INPPTR+1		; get READ pointer HB
00ACE3  2               
00ACE3  2  A6 11        	ldx	INPFLG			; get INPUT mode flag, $00 = INPUT,
00ACE5  2               					; $40 = GET, $98 = READ
00ACE5  2  10 03        	bpl	A_ACEA			; branch if INPUT or GET
00ACE7  2               
00ACE7  2  4C 27 A8     	jmp	bcRESTORE2		; else set data pointer and exit [A827]
00ACEA  2               
00ACEA  2               A_ACEA:					;				[ACEA]
00ACEA  2  A0 00        	ldy	#$00			; clear index
00ACEC  2  B1 43        	lda	(INPPTR),Y		; get READ byte
00ACEE  2  F0 0B        	beq	A_ACFB			; exit if [EOL]
00ACF0  2               
00ACF0  2  A5 13        	lda	CurIoChan		; get current I/O channel
00ACF2  2  D0 07        	bne	A_ACFB			; exit if not default channel
00ACF4  2               
00ACF4  2  A9 FC        	lda	#<txtEXTRA		; set "?EXTRA IGNORED" pointer LB
00ACF6  2  A0 AC        	ldy	#>txtEXTRA		; set "?EXTRA IGNORED" pointer HB
00ACF8  2  4C 1E AB     	jmp	OutputString		; print null terminated string	[AB1E]
00ACFB  2               
00ACFB  2               A_ACFB:					;				[ACFB]
00ACFB  2  60           	rts
00ACFC  2               
00ACFC  2               
00ACFC  2               ;******************************************************************************
00ACFC  2               ;
00ACFC  2               ; input error messages
00ACFC  2               ;
00ACFC  2               txtEXTRA:				;				[ACFC]
00ACFC  2  3F 45 58 54  .byte	"?extra ignored",$0D,$00
00AD00  2  52 41 20 49  
00AD04  2  47 4E 4F 52  
00AD0C  2               
00AD0C  2               txtREDOFROM:				;				[AD0C]
00AD0C  2  3F 52 45 44  .byte	"?redo from start",$0D,$00
00AD10  2  4F 20 46 52  
00AD14  2  4F 4D 20 53  
00AD1E  2               
00AD1E  2               
00AD1E  2               ;******************************************************************************
00AD1E  2               ;
00AD1E  2               ; perform NEXT
00AD1E  2               ;
00AD1E  2               bcNEXT:
00AD1E  2  D0 04        	bne	bcNEXT2			; branch if NEXT variable
00AD20  2               
00AD20  2  A0 00        	ldy	#$00			; else clear Y
00AD22  2  F0 03        	beq	A_AD27			; branch always
00AD24  2               
00AD24  2               ; NEXT variable
00AD24  2               bcNEXT2:				;				[AD24]
00AD24  2  20 8B B0     	jsr	GetAddrVar		; get variable address		[B08B]
00AD27  2               A_AD27:					;				[AD27]
00AD27  2  85 49        	sta	FORPNT			; save FOR/NEXT variable pointer LB
00AD29  2  84 4A        	sty	FORPNT+1		; save FOR/NEXT variable pointer HB
00AD2B  2               					; (HB cleared if no variable defined)
00AD2B  2  20 8A A3     	jsr	SrchForNext		; search the stack for FOR or GOSUB
00AD2E  2               					; activity			[A38A]
00AD2E  2  F0 05        	beq	A_AD35			; branch if FOR, this variable, found
00AD30  2               
00AD30  2  A2 0A        	ldx	#$0A			; else set error $0A, next without for
00AD32  2               					; error
00AD32  2               A_AD32:					;				[AD32]
00AD32  2  4C 37 A4     	jmp	OutputErrMsg		; do error #X then warm start	[A437]
00AD35  2               
00AD35  2               ; found this FOR variable
00AD35  2               A_AD35:					;				[AD35]
00AD35  2  9A           	txs				; update stack pointer
00AD36  2               
00AD36  2  8A           	txa				; copy stack pointer
00AD37  2  18           	clc				; clear carry for add
00AD38  2  69 04        	adc	#$04			; point to STEP value
00AD3A  2  48           	pha				; save it
00AD3B  2               
00AD3B  2  69 06        	adc	#$06			; point to TO value
00AD3D  2  85 24        	sta	INDEX+2			; save pointer to TO variable for
00AD3F  2               					; compare
00AD3F  2  68           	pla				; restore pointer to STEP value
00AD40  2               
00AD40  2  A0 01        	ldy	#$01			; point to stack page
00AD42  2  20 A2 BB     	jsr	UnpackAY2FAC1		; unpack memory (AY) into FAC1	[BBA2]
00AD45  2               
00AD45  2  BA           	tsx				; get stack pointer back
00AD46  2  BD 09 01     	lda	STACK+9,X		; get step sign
00AD49  2  85 66        	sta	FACSGN			; save FAC1 sign (b7)
00AD4B  2               
00AD4B  2  A5 49        	lda	FORPNT			; get FOR/NEXT variable pointer LB
00AD4D  2  A4 4A        	ldy	FORPNT+1		; get FOR/NEXT variable pointer HB
00AD4F  2  20 67 B8     	jsr	AddFORvar2FAC1		; add FOR variable to FAC1	[B867]
00AD52  2               
00AD52  2  20 D0 BB     	jsr	Fac1ToVarPtr		; pack FAC1 into FOR variable	[BBD0]
00AD55  2               
00AD55  2  A0 01        	ldy	#$01			; point to stack page
00AD57  2  20 5D BC     	jsr	CmpFAC1withAY2		; compare FAC1 with TO value	[BC5D]
00AD5A  2               
00AD5A  2  BA           	tsx				; get stack pointer back
00AD5B  2  38           	sec				; set carry for subtract
00AD5C  2  FD 09 01     	sbc	STACK+9,X		; subtract step sign
00AD5F  2  F0 17        	beq	A_AD78			; branch if =, loop complete
00AD61  2               
00AD61  2               ; loop back and do it all again
00AD61  2  BD 0F 01     	lda	STACK+$0F,X		; get FOR line LB
00AD64  2  85 39        	sta	CURLIN			; save current line number LB
00AD66  2               
00AD66  2  BD 10 01     	lda	STACK+$10,X		; get FOR line HB
00AD69  2  85 3A        	sta	CURLIN+1		; save current line number HB
00AD6B  2               
00AD6B  2  BD 12 01     	lda	STACK+$12,X		; get BASIC execute pointer LB
00AD6E  2  85 7A        	sta	TXTPTR			; save BASIC execute pointer LB
00AD70  2               
00AD70  2  BD 11 01     	lda	STACK+$11,X		; get BASIC execute pointer HB
00AD73  2  85 7B        	sta	TXTPTR+1		; save BASIC execute pointer HB
00AD75  2               A_AD75:					;				[AD75]
00AD75  2  4C AE A7     	jmp	InterpretLoop		; go do interpreter inner loop	[A7AE]
00AD78  2               
00AD78  2               ; NEXT loop comlete
00AD78  2               A_AD78:					;				[AD78]
00AD78  2  8A           	txa				; stack copy to A
00AD79  2  69 11        	adc	#$11			; add $12, $11 + carry, to dump FOR
00AD7B  2               					; structure
00AD7B  2  AA           	tax				; copy back to index
00AD7C  2               
00AD7C  2  9A           	txs				; copy to stack pointer
00AD7D  2               
00AD7D  2  20 79 00     	jsr	CHRGOT			; scan memory			[0079]
00AD80  2  C9 2C        	cmp	#','			; compare with ","
00AD82  2  D0 F1        	bne	A_AD75			; if not "," go do interpreter inner
00AD84  2               					; loop
00AD84  2               ; was "," so another NEXT variable to do
00AD84  2  20 73 00     	jsr	CHRGET			; increment and scan memory	[0073]
00AD87  2  20 24 AD     	jsr	bcNEXT2			; do NEXT variable		[AD24]
00AD8A  2               
00AD8A  2               
00AD8A  2               ;******************************************************************************
00AD8A  2               ;
00AD8A  2               ; evaluate expression and check type mismatch
00AD8A  2               ;
00AD8A  2               EvalExpression:				;				[AD8A]
00AD8A  2  20 9E AD     	jsr	EvaluateValue		; evaluate expression		[AD9E]
00AD8D  2               
00AD8D  2               ; check if source and destination are numeric
00AD8D  2               CheckIfNumeric:				;				[AD8D]
00AD8D  2  18           	clc
00AD8E  2  24           .byte	$24				; makes next line BIT MEMSIZ+1
00AD8F  2               
00AD8F  2               ; check if source and destination are string
00AD8F  2               CheckIfString:				;				[AD8F]
00AD8F  2  38           	sec				; destination is string
00AD90  2               
00AD90  2               ; type match check, set C for string, clear C for numeric
00AD90  2               ChkIfNumStr:				;				[AD90]
00AD90  2  24 0D        	bit	VALTYP			; test data type flag, $FF = string,
00AD92  2               					; $00 = numeric
00AD92  2  30 03        	bmi	A_AD97			; branch if string
00AD94  2               
00AD94  2  B0 03        	bcs	A_AD99			; if destiantion is numeric do type
00AD96  2               					; missmatch error
00AD96  2               A_AD96:					;				[AD96]
00AD96  2  60           	rts
00AD97  2               
00AD97  2               A_AD97:					;				[AD97]
00AD97  2  B0 FD        	bcs	A_AD96			; exit if destination is string
00AD99  2               
00AD99  2               ; do type missmatch error
00AD99  2               A_AD99:					;				[AD99]
00AD99  2  A2 16        	ldx	#$16			; error code $16, type missmatch error
00AD9B  2  4C 37 A4     	jmp	OutputErrMsg		; do error #X then warm start	[A437]
00AD9E  2               
00AD9E  2               
00AD9E  2               ;******************************************************************************
00AD9E  2               ;
00AD9E  2               ; evaluate expression
00AD9E  2               ;
00AD9E  2               EvaluateValue:				;				[AD9E]
00AD9E  2  A6 7A        	ldx	TXTPTR			; get BASIC execute pointer LB
00ADA0  2  D0 02        	bne	A_ADA4			; skip next if not zero
00ADA2  2               
00ADA2  2  C6 7B        	dec	TXTPTR+1		; else decr. BASIC execute pointer HB
00ADA4  2               A_ADA4:					;				[ADA4]
00ADA4  2  C6 7A        	dec	TXTPTR			; decrement BASIC execute pointer LB
00ADA6  2               
00ADA6  2  A2 00        	ldx	#$00			; set null precedence, flag done
00ADA8  2  24           .byte	$24				; makes next line BIT VARPNT+1
00ADA9  2               EvaluateValue2:				;				[ADA9]
00ADA9  2  48           	pha				; push compare evaluation byte if branch
00ADAA  2               					; to here
00ADAA  2  8A           	txa				; copy precedence byte
00ADAB  2  48           	pha				; push precedence byte
00ADAC  2               
00ADAC  2  A9 01        	lda	#$01			; 2 bytes
00ADAE  2  20 FB A3     	jsr	CheckRoomStack		; check room on stack for A*2 bytes
00ADB1  2               					;				[A3FB]
00ADB1  2  20 83 AE     	jsr	GetNextParm		; get value from line		[AE83]
00ADB4  2               
00ADB4  2  A9 00        	lda	#$00			; clear A
00ADB6  2  85 4D        	sta	CompEvalFlg		; clear comparrison evaluation flag
00ADB8  2               EvaluateValue3:				;				[ADB8]
00ADB8  2  20 79 00     	jsr	CHRGOT			; scan memory			[0079]
00ADBB  2               EvaluateValue4:				;				[ADBB]
00ADBB  2  38           	sec				; set carry for subtract
00ADBC  2  E9 B1        	sbc	#TK_GT			; subtract the token for ">"
00ADBE  2  90 17        	bcc	A_ADD7			; branch if < ">"
00ADC0  2               
00ADC0  2  C9 03        	cmp	#$03			; compare with ">" to +3
00ADC2  2  B0 13        	bcs	A_ADD7			; branch if >= 3
00ADC4  2               
00ADC4  2               ; was token for ">" "=" or "<"
00ADC4  2  C9 01        	cmp	#$01			; compare with token for =
00ADC6  2  2A           	rol				; b0 := carry (=1 if token was = or <)
00ADC7  2  49 01        	eor	#$01			; toggle b0
00ADC9  2  45 4D        	eor	CompEvalFlg		; EOR with comparrison evaluation flag
00ADCB  2  C5 4D        	cmp	CompEvalFlg		; comp with comparrison evaluation flag
00ADCD  2  90 61        	bcc	A_AE30			; if < saved flag do syntax error then
00ADCF  2               					; warm start
00ADCF  2  85 4D        	sta	CompEvalFlg		; save new comparrison evaluation flag
00ADD1  2               
00ADD1  2  20 73 00     	jsr	CHRGET			; increment and scan memory	[0073]
00ADD4  2  4C BB AD     	jmp	EvaluateValue4		; go do next character		[ADBB]
00ADD7  2               
00ADD7  2               
00ADD7  2               A_ADD7:					;				[ADD7]
00ADD7  2  A6 4D        	ldx	CompEvalFlg		; get comparrison evaluation flag
00ADD9  2  D0 2C        	bne	A_AE07			; branch if compare function
00ADDB  2               
00ADDB  2  B0 7B        	bcs	A_AE58			; go do functions
00ADDD  2               
00ADDD  2               ; else was < TK_GT so is operator or lower
00ADDD  2  69 07        	adc	#$07			; add # of operators (+, -, *, /, ^,
00ADDF  2               					; AND or OR)
00ADDF  2  90 77        	bcc	A_AE58			; branch if < + operator
00ADE1  2               
00ADE1  2               ; carry was set so token was +, -, *, /, ^, AND or OR
00ADE1  2  65 0D        	adc	VALTYP			; add data type flag, $FF = string,
00ADE3  2               					; $00 = numeric
00ADE3  2  D0 03        	bne	A_ADE8			; branch if not string or not + token
00ADE5  2               
00ADE5  2               ; will only be $00 if type is string and token was +
00ADE5  2  4C 3D B6     	jmp	ConcatStrings		; add strings, string 1 is in the
00ADE8  2               					; descriptor, string 2	[B63D]
00ADE8  2               					; is in line, and return
00ADE8  2               A_ADE8:					;				[ADE8]
00ADE8  2  69 FF        	adc	#$FF			; -1 (corrects for carry add)
00ADEA  2  85 22        	sta	INDEX			; save it
00ADEC  2               
00ADEC  2  0A           	asl				; *2
00ADED  2  65 22        	adc	INDEX			; *3
00ADEF  2  A8           	tay				; copy to index
00ADF0  2               A_ADF0:					;				[ADF0]
00ADF0  2  68           	pla				; pull previous precedence
00ADF1  2  D9 80 A0     	cmp	HierachyCode,Y		; compare with precedence byte
00ADF4  2  B0 67        	bcs	A_AE5D			; branch if A >=
00ADF6  2               
00ADF6  2  20 8D AD     	jsr	CheckIfNumeric		; check if source is numeric, else do
00ADF9  2               					; type mismatch			[AD8D]
00ADF9  2               A_ADF9:					;				[ADF9]
00ADF9  2  48           	pha				; save precedence
00ADFA  2               EvaluateValue5:				;				[ADFA]
00ADFA  2  20 20 AE     	jsr	EvaluateValue6		; get vector, execute function then
00ADFD  2               					; continue evaluation		[AE20]
00ADFD  2               
00ADFD  2  68           	pla				; restore precedence
00ADFE  2               
00ADFE  2  A4 4B        	ldy	TEMPSTR			; get precedence stacked flag
00AE00  2  10 17        	bpl	A_AE19			; branch if stacked values
00AE02  2               
00AE02  2  AA           	tax				; copy precedence, set flags
00AE03  2  F0 56        	beq	A_AE5B			; exit if done
00AE05  2               
00AE05  2  D0 5F        	bne	A_AE66			; branch always
00AE07  2               
00AE07  2               A_AE07:					;				[AE07]
00AE07  2  46 0D        	lsr	VALTYP			; clear data type flag, $FF = string,
00AE09  2               					; $00 = numeric
00AE09  2  8A           	txa				; copy compare function flag
00AE0A  2               
00AE0A  2  2A           	rol				; <<1, shift data type flag into b0,
00AE0B  2               					; 1 = string, 0 = num
00AE0B  2  A6 7A        	ldx	TXTPTR			; get BASIC execute pointer LB
00AE0D  2  D0 02        	bne	A_AE11			; branch if no underflow
00AE0F  2               
00AE0F  2  C6 7B        	dec	TXTPTR+1		; else decr. BASIC execute pointer HB
00AE11  2               A_AE11:					;				[AE11]
00AE11  2  C6 7A        	dec	TXTPTR			; decrement BASIC execute pointer LB
00AE13  2               
00AE13  2  A0 1B        	ldy	#$1B			; set offset to = operator precedence
00AE15  2               					; entry
00AE15  2  85 4D        	sta	CompEvalFlg		; save new comparrison evaluation flag
00AE17  2  D0 D7        	bne	A_ADF0			; branch always
00AE19  2               
00AE19  2               A_AE19:					;				[AE19]
00AE19  2  D9 80 A0     	cmp	HierachyCode,Y		; compare with stacked function
00AE1C  2               					; precedence
00AE1C  2  B0 48        	bcs	A_AE66			; if A >=, pop FAC2 and return
00AE1E  2               
00AE1E  2  90 D9        	bcc	A_ADF9			; else go stack this one and continue,
00AE20  2               					; branch always
00AE20  2               
00AE20  2               ;******************************************************************************
00AE20  2               ;
00AE20  2               ; get vector, execute function then continue evaluation
00AE20  2               ;
00AE20  2               EvaluateValue6:				;				[AE20]
00AE20  2  B9 82 A0     	lda	HierachyCode+2,Y	; get function vector HB
00AE23  2  48           	pha				; onto stack
00AE24  2               
00AE24  2  B9 81 A0     	lda	HierachyCode+1,Y	; get function vector LB
00AE27  2  48           	pha				; onto stack
00AE28  2               
00AE28  2               ; now push sign, round FAC1 and put on stack
00AE28  2  20 33 AE     	jsr	EvaluateValue7		; function will return here, then the
00AE2B  2               					; next RTS will call the function [AE33]
00AE2B  2  A5 4D        	lda	CompEvalFlg		; get comparrison evaluation flag
00AE2D  2  4C A9 AD     	jmp	EvaluateValue2		; continue evaluating expression [ADA9]
00AE30  2               
00AE30  2               A_AE30:					;				[AE30]
00AE30  2  4C 08 AF     	jmp	SyntaxError		; do syntax error then warm start [AF08]
00AE33  2               
00AE33  2               EvaluateValue7:				;				[AE33]
00AE33  2  A5 66        	lda	FACSGN			; get FAC1 sign (b7)
00AE35  2  BE 80 A0     	ldx	HierachyCode,Y		; get precedence byte
00AE38  2               
00AE38  2               
00AE38  2               ;******************************************************************************
00AE38  2               ;
00AE38  2               ; push sign, round FAC1 and put on stack
00AE38  2               ;
00AE38  2               SgnFac1ToStack:				;				[AE38]
00AE38  2  A8           	tay				; copy sign
00AE39  2               
00AE39  2  68           	pla				; get return address LB
00AE3A  2  85 22        	sta	INDEX			; save it
00AE3C  2               
00AE3C  2  E6 22        	inc	INDEX			; increment it as return-1 is pushed.
00AE3E  2               ; Note, no check is made on the HB so if the calling routine ever assembles to
00AE3E  2               ; a page edge then this all goes horribly wrong!
00AE3E  2               
00AE3E  2  68           	pla				; get return address HB
00AE3F  2  85 23        	sta	INDEX+1			; save it
00AE41  2               
00AE41  2  98           	tya				; restore sign
00AE42  2  48           	pha				; push sign
00AE43  2               
00AE43  2               
00AE43  2               ;******************************************************************************
00AE43  2               ;
00AE43  2               ; round FAC1 and put on stack
00AE43  2               ;
00AE43  2               FAC1ToStack:				;				[AE43]
00AE43  2  20 1B BC     	jsr	RoundFAC1		; round FAC1			[BC1B]
00AE46  2               
00AE46  2  A5 65        	lda	FacMantissa+3		; get FAC1 mantissa 4
00AE48  2  48           	pha				; save it
00AE49  2               
00AE49  2  A5 64        	lda	FacMantissa+2		; get FAC1 mantissa 3
00AE4B  2  48           	pha				; save it
00AE4C  2               
00AE4C  2  A5 63        	lda	FacMantissa+1		; get FAC1 mantissa 2
00AE4E  2  48           	pha				; save it
00AE4F  2               
00AE4F  2  A5 62        	lda	FacMantissa		; get FAC1 mantissa 1
00AE51  2  48           	pha				; save it
00AE52  2               
00AE52  2  A5 61        	lda	FACEXP			; get FAC1 exponent
00AE54  2  48           	pha				; save it
00AE55  2               
00AE55  2  6C 22 00     	jmp	(INDEX)			; return, sort of
00AE58  2               
00AE58  2               
00AE58  2               ;******************************************************************************
00AE58  2               ;
00AE58  2               ; do functions
00AE58  2               ;
00AE58  2               A_AE58:					;				[AE58]
00AE58  2  A0 FF        	ldy	#$FF			; flag function
00AE5A  2  68           	pla				; pull precedence byte
00AE5B  2               A_AE5B:					;				[AE5B]
00AE5B  2  F0 23        	beq	A_AE80			; exit if done
00AE5D  2               
00AE5D  2               A_AE5D:					;				[AE5D]
00AE5D  2  C9 64        	cmp	#$64			; compare previous precedence with $64
00AE5F  2  F0 03        	beq	A_AE64			; branch if was $64 (< function)
00AE61  2               
00AE61  2  20 8D AD     	jsr	CheckIfNumeric		; check if source is numeric, else do
00AE64  2               					; type mismatch	[AD8D]
00AE64  2               A_AE64:					;				[AE64]
00AE64  2  84 4B        	sty	TEMPSTR			; save precedence stacked flag
00AE66  2               
00AE66  2               ; pop FAC2 and return
00AE66  2               A_AE66:					;				[AE66]
00AE66  2  68           	pla				; pop byte
00AE67  2  4A           	lsr				; shift out comparison evaluation
00AE68  2               					; lowest bit
00AE68  2  85 12        	sta	TANSGN			; save the comparison evaluation flag
00AE6A  2               
00AE6A  2  68           	pla				; pop exponent
00AE6B  2  85 69        	sta	ARGEXP			; save FAC2 exponent
00AE6D  2               
00AE6D  2  68           	pla				; pop mantissa 1
00AE6E  2  85 6A        	sta	ArgMantissa		; save FAC2 mantissa 1
00AE70  2               
00AE70  2  68           	pla				; pop mantissa 2
00AE71  2  85 6B        	sta	ArgMantissa+1		; save FAC2 mantissa 2
00AE73  2               
00AE73  2  68           	pla				; pop mantissa 3
00AE74  2  85 6C        	sta	ArgMantissa+2		; save FAC2 mantissa 3
00AE76  2               
00AE76  2  68           	pla				; pop mantissa 4
00AE77  2  85 6D        	sta	ArgMantissa+3		; save FAC2 mantissa 4
00AE79  2               
00AE79  2  68           	pla				; pop sign
00AE7A  2  85 6E        	sta	ARGSGN			; save FAC2 sign (b7)
00AE7C  2               
00AE7C  2  45 66        	eor	FACSGN			; EOR FAC1 sign (b7)
00AE7E  2  85 6F        	sta	ARISGN			; save sign compare (FAC1 EOR FAC2)
00AE80  2               A_AE80:					;				[AE80]
00AE80  2  A5 61        	lda	FACEXP			; get FAC1 exponent
00AE82  2  60           	rts
00AE83  2               
00AE83  2               
00AE83  2               ;******************************************************************************
00AE83  2               ;
00AE83  2               ; get value from line
00AE83  2               ;
00AE83  2               GetNextParm:				;				[AE83]
00AE83  2  6C 0A 03     	jmp	(IEVAL)			; get arithmetic element
00AE86  2               
00AE86  2               
00AE86  2               ;******************************************************************************
00AE86  2               ;
00AE86  2               ; get arithmetic element, the get arithmetic element vector is initialised to
00AE86  2               ; point here
00AE86  2               ;
00AE86  2               GetNextParm2:				;				[AE86]
00AE86  2  A9 00        	lda	#$00			; clear byte
00AE88  2  85 0D        	sta	VALTYP			; clear data type flag, $FF = string,
00AE8A  2               					; $00 = numeric
00AE8A  2               A_AE8A:					;				[AE8A]
00AE8A  2  20 73 00     	jsr	CHRGET			; increment and scan memory	[0073]
00AE8D  2               A_AE8D:
00AE8D  2  B0 03        	bcs	A_AE92			; branch if not numeric character
00AE8F  2               
00AE8F  2               ; else numeric string found (e.g. 123)
00AE8F  2               A_AE8F:					;				[AE8F]
00AE8F  2  4C F3 BC     	jmp	String2FAC1		; get FAC1 from string and return [BCF3]
00AE92  2               
00AE92  2               ; get value from line .. continued
00AE92  2               
00AE92  2               ; wasn't a number so ...
00AE92  2               A_AE92:					;				[AE92]
00AE92  2  20 13 B1     	jsr	CheckAtoZ		; check byte, return Cb = 0 if < "A" or
00AE95  2               					; > "Z"				[B113]
00AE95  2  90 03        	bcc	A_AE9A			; branch if not variable name
00AE97  2               
00AE97  2  4C 28 AF     	jmp	GetVariable		; variable name set-up and return [AF28]
00AE9A  2               
00AE9A  2               A_AE9A:					;				[AE9A]
00AE9A  2  C9 FF        	cmp	#TK_PI			; compare with token for PI
00AE9C  2  D0 0F        	bne	A_AEAD			; branch if not PI
00AE9E  2               
00AE9E  2  A9 A8        	lda	#<Tbl_PI_Value		; get PI pointer LB
00AEA0  2  A0 AE        	ldy	#>Tbl_PI_Value		; get PI pointer HB
00AEA2  2  20 A2 BB     	jsr	UnpackAY2FAC1		; unpack memory (AY) into FAC1	[BBA2]
00AEA5  2               
00AEA5  2  4C 73 00     	jmp	CHRGET			; increment and scan memory and return
00AEA8  2               					;	[0073]
00AEA8  2               
00AEA8  2               ;******************************************************************************
00AEA8  2               ;
00AEA8  2               ; PI as floating number
00AEA8  2               ;
00AEA8  2               Tbl_PI_Value:				;				[AEA8]
00AEA8  2  82 49 0F DA  .byte	$82,$49,$0F,$DA,$A1		; 3.141592653
00AEAC  2  A1           
00AEAD  2               
00AEAD  2               
00AEAD  2               ;******************************************************************************
00AEAD  2               ;
00AEAD  2               ; get value from line .. continued
00AEAD  2               
00AEAD  2               ; wasn't variable name so ...
00AEAD  2               A_AEAD:					;				[AEAD]
00AEAD  2  C9 2E        	cmp	#'.'			; compare with "."
00AEAF  2  F0 DE        	beq	A_AE8F			; if so get FAC1 from string and return,
00AEB1  2               					; e.g. was .123
00AEB1  2               ; wasn't .123 so ...
00AEB1  2  C9 AB        	cmp	#TK_MINUS		; compare with token for -
00AEB3  2  F0 58        	beq	A_AF0D			; branch if - token, do set-up for
00AEB5  2               					; functions
00AEB5  2               ; wasn't -123 so ...
00AEB5  2  C9 AA        	cmp	#TK_PLUS		; compare with token for +
00AEB7  2  F0 D1        	beq	A_AE8A			; branch if + token, +1 = 1 so ignore
00AEB9  2               					; leading +
00AEB9  2               ; it wasn't any sort of number so ...
00AEB9  2  C9 22        	cmp	#'"'			; compare with "
00AEBB  2  D0 0F        	bne	A_AECC			; branch if not open quote
00AEBD  2               
00AEBD  2               ; was open quote so get the enclosed string
00AEBD  2               
00AEBD  2               
00AEBD  2               ;******************************************************************************
00AEBD  2               ;
00AEBD  2               ; print "..." string to string utility area
00AEBD  2               ;
00AEBD  2               GetNextParm3:				;				[AEBD]
00AEBD  2  A5 7A        	lda	TXTPTR			; get BASIC execute pointer LB
00AEBF  2  A4 7B        	ldy	TXTPTR+1		; get BASIC execute pointer HB
00AEC1  2  69 00        	adc	#$00			; add carry to LB
00AEC3  2  90 01        	bcc	A_AEC6			; branch if no overflow
00AEC5  2               
00AEC5  2  C8           	iny				; increment HB
00AEC6  2               A_AEC6:					;				[AEC6]
00AEC6  2  20 87 B4     	jsr	QuoteStr2UtPtr		; print " terminated string to utility
00AEC9  2               					; pointer			[B487]
00AEC9  2  4C E2 B7     	jmp	RestBasExecPtr		; restore BASIC execute pointer from
00AECC  2               					; temp and return		[B7E2]
00AECC  2               ; get value from line .. continued
00AECC  2               
00AECC  2               ; wasn't a string so ...
00AECC  2               A_AECC:					;				[AECC]
00AECC  2  C9 A8        	cmp	#TK_NOT			; compare with token for NOT
00AECE  2  D0 13        	bne	A_AEE3			; branch if not token for NOT
00AED0  2               
00AED0  2               ; was NOT token
00AED0  2  A0 18        	ldy	#$18			; offset to NOT function
00AED2  2  D0 3B        	bne	A_AF0F			; do set-up for function then execute,
00AED4  2               					; branch always
00AED4  2               ; do = compare
00AED4  2               bcEQUAL:
00AED4  2  20 BF B1     	jsr	EvalInteger3		; evaluate integer expression, no sign
00AED7  2               					; check				[B1BF]
00AED7  2  A5 65        	lda	FacMantissa+3		; get FAC1 mantissa 4
00AED9  2  49 FF        	eor	#$FF			; invert it
00AEDB  2  A8           	tay				; copy it
00AEDC  2               
00AEDC  2  A5 64        	lda	FacMantissa+2		; get FAC1 mantissa 3
00AEDE  2  49 FF        	eor	#$FF			; invert it
00AEE0  2  4C 91 B3     	jmp	ConvertAY2FAC1		; convert fixed integer AY to float FAC1
00AEE3  2               					; and return			[B391]
00AEE3  2               ; get value from line .. continued
00AEE3  2               
00AEE3  2               ; wasn't a string or NOT so ...
00AEE3  2               A_AEE3:					;				[AEE3]
00AEE3  2  C9 A5        	cmp	#TK_FN			; compare with token for FN
00AEE5  2  D0 03        	bne	A_AEEA			; branch if not token for FN
00AEE7  2               
00AEE7  2  4C F4 B3     	jmp	EvaluateFNx		; else go evaluate FNx		[B3F4]
00AEEA  2               
00AEEA  2               ; get value from line .. continued
00AEEA  2               
00AEEA  2               ; wasn't a string, NOT or FN so ...
00AEEA  2               A_AEEA:					;				[AEEA]
00AEEA  2  C9 B4        	cmp	#TK_SGN			; compare with token for SGN
00AEEC  2  90 03        	bcc	Chk4Parens		; if less than SGN token evaluate
00AEEE  2               					; expression in parentheses
00AEEE  2               ; else was a function token
00AEEE  2  4C A7 AF     	jmp	GetReal			; go set up function references	[AFA7]
00AEF1  2               
00AEF1  2               ; get value from line .. continued
00AEF1  2               ; if here it can only be something in brackets so ....
00AEF1  2               
00AEF1  2               ; evaluate expression within parentheses
00AEF1  2               Chk4Parens:				;				[AEF1]
00AEF1  2  20 FA AE     	jsr	Chk4OpenParen		; scan for "(", else do syntax error
00AEF4  2               					; then warm start		[AEFA]
00AEF4  2  20 9E AD     	jsr	EvaluateValue		; evaluate expression		[AD9E]
00AEF7  2               
00AEF7  2               ; all the 'scan for' routines return the character after the sought character
00AEF7  2               
00AEF7  2               ; scan for ")", else do syntax error then warm start
00AEF7  2               Chk4CloseParen:				;				[AEF7]
00AEF7  2  A9 29        	lda	#')'			; load A with ")"
00AEF9  2  2C           .byte	$2C				; makes next line BIT RESHO+2A9
00AEFA  2               
00AEFA  2               ; scan for "(", else do syntax error then warm start
00AEFA  2               Chk4OpenParen:				;				[AEFA]
00AEFA  2  A9 28        	lda	#'('			; load A with "("
00AEFC  2  2C           .byte	$2C				; makes next line BIT TXTTAB+1A9
00AEFD  2               
00AEFD  2               ; scan for ",", else do syntax error then warm start
00AEFD  2               Chk4Comma:				;				[AEFD]
00AEFD  2  A9 2C        	lda	#','			; load A with ","
00AEFF  2               
00AEFF  2               ; scan for CHR$(A), else do syntax error then warm start
00AEFF  2               Chk4CharInA:				;				[AEFF]
00AEFF  2  A0 00        	ldy	#$00			; clear index
00AF01  2  D1 7A        	cmp	(TXTPTR),Y		; compare with BASIC byte
00AF03  2  D0 03        	bne	SyntaxError		; if not expected byte do syntax error
00AF05  2               					; then warm start
00AF05  2  4C 73 00     	jmp	CHRGET			; else increment and scan memory and
00AF08  2               					; return			[0073]
00AF08  2               ; syntax error then warm start
00AF08  2               SyntaxError:				;				[AF08]
00AF08  2  A2 0B        	ldx	#$0B			; error code $0B, syntax error
00AF0A  2  4C 37 A4     	jmp	OutputErrMsg		; do error #X then warm start	[A437]
00AF0D  2               
00AF0D  2               
00AF0D  2               A_AF0D:					;				[AF0D]
00AF0D  2  A0 15        	ldy	#$15			; set offset from base to > operator
00AF0F  2               A_AF0F:					;				[AF0F]
00AF0F  2  68           	pla				; dump return address LB
00AF10  2  68           	pla				; dump return address HB
00AF11  2               
00AF11  2  4C FA AD     	jmp	EvaluateValue5		; execute function then continue
00AF14  2               					; evaluation			[ADFA]
00AF14  2               
00AF14  2               ;******************************************************************************
00AF14  2               ;
00AF14  2               ; check address range, return C = 1 if address in BASIC ROM
00AF14  2               ;
00AF14  2               ChkIfVariable:				;				[AF14]
00AF14  2  38           	sec				; set carry for subtract
00AF15  2  A5 64        	lda	FacMantissa+2		; get variable address LB
00AF17  2  E9 00        	sbc	#<BasicCold		; subtract BasicCold LB
00AF19  2               
00AF19  2  A5 65        	lda	FacMantissa+3		; get variable address HB
00AF1B  2  E9 A0        	sbc	#>BasicCold		; subtract BasicCold HB
00AF1D  2  90 08        	bcc	A_AF27			; exit if address < BasicCold
00AF1F  2               
00AF1F  2  A9 A2        	lda	#<DataCHRGET		; get end of BASIC marker LB
00AF21  2  E5 64        	sbc	FacMantissa+2		; subtract variable address LB
00AF23  2               
00AF23  2  A9 E3        	lda	#>DataCHRGET		; get end of BASIC marker HB
00AF25  2  E5 65        	sbc	FacMantissa+3		; subtract variable address HB
00AF27  2               A_AF27:					;				[AF27]
00AF27  2  60           	rts
00AF28  2               
00AF28  2               
00AF28  2               ;******************************************************************************
00AF28  2               ;
00AF28  2               ; variable name set-up
00AF28  2               ;
00AF28  2               GetVariable:				;				[AF28]
00AF28  2  20 8B B0     	jsr	GetAddrVar		; get variable address		[B08B]
00AF2B  2  85 64        	sta	FacMantissa+2		; save variable pointer LB
00AF2D  2  84 65        	sty	FacMantissa+3		; save variable pointer HB
00AF2F  2               
00AF2F  2  A6 45        	ldx	VARNAM			; get current variable name first char
00AF31  2  A4 46        	ldy	VARNAM+1		; get current variable name second char
00AF33  2               
00AF33  2  A5 0D        	lda	VALTYP			; get data type flag, $FF = string,
00AF35  2               					; $00 = numeric
00AF35  2  F0 26        	beq	A_AF5D			; branch if numeric
00AF37  2               
00AF37  2               ; variable is string
00AF37  2  A9 00        	lda	#$00			; else clear A
00AF39  2  85 70        	sta	FACOV			; clear FAC1 rounding byte
00AF3B  2               
00AF3B  2  20 14 AF     	jsr	ChkIfVariable		; check address range		[AF14]
00AF3E  2  90 1C        	bcc	A_AF5C			; exit if not in BASIC ROM
00AF40  2               
00AF40  2  E0 54        	cpx	#'t'			; compare variable name first character
00AF42  2               					; with "T"
00AF42  2  D0 18        	bne	A_AF5C			; exit if not "T"
00AF44  2               
00AF44  2  C0 C9        	cpy	#'i'+$80		; compare variable name second character
00AF46  2               					; with "I$"
00AF46  2  D0 14        	bne	A_AF5C			; exit if not "I$"
00AF48  2               
00AF48  2               ; variable name was "TI$"
00AF48  2  20 84 AF     	jsr	GetTime			; read real time clock into FAC1
00AF4B  2               					; mantissa, 0HML		[AF84]
00AF4B  2  84 5E        	sty	FacTempStor+7		; clear exponent count adjust
00AF4D  2               
00AF4D  2  88           	dey				; Y = $FF
00AF4E  2  84 71        	sty	FBUFPT			; set output string index, -1 to allow
00AF50  2               					; for pre increment
00AF50  2  A0 06        	ldy	#$06			; HH:MM:SS is six digits
00AF52  2  84 5D        	sty	FacTempStor+6		; set number of characters before the
00AF54  2               					; decimal point
00AF54  2  A0 24        	ldy	#D_BF3A-D_BF16		; index to jiffy conversion table
00AF56  2  20 68 BE     	jsr	JiffyCnt2Str		; convert jiffy count to string	[BE68]
00AF59  2               
00AF59  2  4C 6F B4     	jmp	bcSTR2			; exit via STR$() code tail	[B46F]
00AF5C  2               
00AF5C  2               A_AF5C:					;				[AF5C]
00AF5C  2  60           	rts
00AF5D  2               
00AF5D  2               ; variable name set-up, variable is numeric
00AF5D  2               A_AF5D:					;				[AF5D]
00AF5D  2  24 0E        	bit	INTFLG			; test data type flag, $80 = integer,
00AF5F  2               					; $00 = float
00AF5F  2  10 0D        	bpl	A_AF6E			; branch if float
00AF61  2               
00AF61  2  A0 00        	ldy	#$00			; clear index
00AF63  2  B1 64        	lda	(FacMantissa+2),Y	; get integer variable LB
00AF65  2  AA           	tax				; copy to X
00AF66  2               
00AF66  2  C8           	iny				; increment index
00AF67  2  B1 64        	lda	(FacMantissa+2),Y	; get integer variable HB
00AF69  2  A8           	tay				; copy to Y
00AF6A  2               
00AF6A  2  8A           	txa				; copy loa byte to A
00AF6B  2  4C 91 B3     	jmp	ConvertAY2FAC1		; convert fixed integer AY to float FAC1
00AF6E  2               					; and return			[B391]
00AF6E  2               ; variable name set-up, variable is float
00AF6E  2               A_AF6E:					;				[AF6E]
00AF6E  2  20 14 AF     	jsr	ChkIfVariable		; check address range		[AF14]
00AF71  2  90 2D        	bcc	A_AFA0			; if not in BASIC ROM get pointer and
00AF73  2               					; unpack into FAC1
00AF73  2  E0 54        	cpx	#'t'			; compare variable name first character
00AF75  2               					; with "T"
00AF75  2  D0 1B        	bne	A_AF92			; branch if not "T"
00AF77  2               
00AF77  2  C0 49        	cpy	#'i'			; compare variable name second character
00AF79  2               					; with "I"
00AF79  2  D0 25        	bne	A_AFA0			; branch if not "I"
00AF7B  2               
00AF7B  2               ; variable name was "TI"
00AF7B  2  20 84 AF     	jsr	GetTime			; read real time clock into FAC1
00AF7E  2               					; mantissa, 0HML		[AF84]
00AF7E  2  98           	tya				; clear A
00AF7F  2               
00AF7F  2  A2 A0        	ldx	#$A0			; set exponent to 32 bit value
00AF81  2  4C 4F BC     	jmp	J_BC4F			; set exponent = X and normalise FAC1
00AF84  2               					;				[BC4F]
00AF84  2               
00AF84  2               ;******************************************************************************
00AF84  2               ;
00AF84  2               ; read real time clock into FAC1 mantissa, 0HML
00AF84  2               ;
00AF84  2               GetTime:				;				[AF84]
00AF84  2  20 DE FF     	jsr	ReadClock		; read real time clock		[FFDE]
00AF87  2  86 64        	stx	FacMantissa+2		; save jiffy clock mid byte as  FAC1
00AF89  2               					; mantissa 3
00AF89  2  84 63        	sty	FacMantissa+1		; save jiffy clock HB as  FAC1
00AF8B  2               					; mantissa 2
00AF8B  2  85 65        	sta	FacMantissa+3		; save jiffy clock LB as  FAC1
00AF8D  2               					; mantissa 4
00AF8D  2  A0 00        	ldy	#$00			; clear Y
00AF8F  2  84 62        	sty	FacMantissa		; clear FAC1 mantissa 1
00AF91  2               
00AF91  2  60           	rts
00AF92  2               
00AF92  2               ; variable name set-up, variable is float and not "Tx"
00AF92  2               A_AF92:					;				[AF92]
00AF92  2  E0 53        	cpx	#'s'			; compare variable name first character
00AF94  2               					; with "S"
00AF94  2  D0 0A        	bne	A_AFA0			; if not "S" go do normal floating
00AF96  2               					; variable
00AF96  2  C0 54        	cpy	#'t'			; compare variable name second character
00AF98  2               					; with "T"
00AF98  2  D0 06        	bne	A_AFA0			; if not "T" go do normal floating
00AF9A  2               					; variable
00AF9A  2               ; variable name was "ST"
00AF9A  2  20 B7 FF     	jsr	ReadIoStatus		; read I/O status word		[FFB7]
00AF9D  2  4C 3C BC     	jmp	AtoInteger		; save A as integer byte and return
00AFA0  2               					;				[BC3C]
00AFA0  2               ; variable is float
00AFA0  2               A_AFA0:					;				[AFA0]
00AFA0  2  A5 64        	lda	FacMantissa+2		; get variable pointer LB
00AFA2  2  A4 65        	ldy	FacMantissa+3		; get variable pointer HB
00AFA4  2  4C A2 BB     	jmp	UnpackAY2FAC1		; unpack memory (AY) into FAC1	[BBA2]
00AFA7  2               
00AFA7  2               
00AFA7  2               ;******************************************************************************
00AFA7  2               ;
00AFA7  2               ; get value from line continued
00AFA7  2               ; only functions left so ..
00AFA7  2               ; set up function references
00AFA7  2               ;
00AFA7  2               GetReal:				;				[AFA7]
00AFA7  2  0A           	asl				; *2 (2 bytes per function address)
00AFA8  2  48           	pha				; save function offset
00AFA9  2  AA           	tax				; copy function offset
00AFAA  2               
00AFAA  2  20 73 00     	jsr	CHRGET			; increment and scan memory	[0073]
00AFAD  2  E0 8F        	cpx	#$8F			; compare function offset to CHR$ token
00AFAF  2               					; offset+1
00AFAF  2  90 20        	bcc	A_AFD1			; branch if < LEFT$ (can not be =)
00AFB1  2               
00AFB1  2               ; get value from line .. continued
00AFB1  2               ; was LEFT$, RIGHT$ or MID$ so..
00AFB1  2  20 FA AE     	jsr	Chk4OpenParen		; scan for "(", else do syntax error
00AFB4  2               					; then warm start		[AEFA]
00AFB4  2  20 9E AD     	jsr	EvaluateValue		; evaluate, should be string, expression
00AFB7  2               					;				[AD9E]
00AFB7  2  20 FD AE     	jsr	Chk4Comma		; scan for ",", else do syntax error
00AFBA  2               					; then warm start		[AEFD]
00AFBA  2  20 8F AD     	jsr	CheckIfString		; check if source is string, else do
00AFBD  2               					; type mismatch			[AD8F]
00AFBD  2               
00AFBD  2  68           	pla				; restore function offset
00AFBE  2  AA           	tax				; copy it
00AFBF  2               
00AFBF  2  A5 65        	lda	FacMantissa+3		; get descriptor pointer HB
00AFC1  2  48           	pha				; push string pointer HB
00AFC2  2               
00AFC2  2  A5 64        	lda	FacMantissa+2		; get descriptor pointer LB
00AFC4  2  48           	pha				; push string pointer LB
00AFC5  2               
00AFC5  2  8A           	txa				; restore function offset
00AFC6  2  48           	pha				; save function offset
00AFC7  2               
00AFC7  2  20 9E B7     	jsr	GetByteParm2		; get byte parameter		[B79E]
00AFCA  2               
00AFCA  2  68           	pla				; restore function offset
00AFCB  2  A8           	tay				; copy function offset
00AFCC  2               
00AFCC  2  8A           	txa				; copy byte parameter to A
00AFCD  2  48           	pha				; push byte parameter
00AFCE  2               
00AFCE  2  4C D6 AF     	jmp	J_AFD6			; go call function		[AFD6]
00AFD1  2               
00AFD1  2               ; get value from line .. continued
00AFD1  2               ; was SGN() to CHR$() so..
00AFD1  2               A_AFD1:					;				[AFD1]
00AFD1  2  20 F1 AE     	jsr	Chk4Parens		; evaluate expression within parentheses
00AFD4  2               					;				[AEF1]
00AFD4  2  68           	pla				; restore function offset
00AFD5  2  A8           	tay				; copy to index
00AFD6  2               J_AFD6:					;				[AFD6]
00AFD6  2  B9 EA 9F     	lda	TblFunctions-$68,Y	; get function jump vector LB
00AFD9  2  85 55        	sta	Jump0054+1		; save functions jump vector LB
00AFDB  2               
00AFDB  2  B9 EB 9F     	lda	TblFunctions-$67,Y	; get function jump vector HB
00AFDE  2  85 56        	sta	Jump0054+2		; save functions jump vector HB
00AFE0  2               
00AFE0  2  20 54 00     	jsr	Jump0054		; do function call		[0054]
00AFE3  2  4C 8D AD     	jmp	CheckIfNumeric		; check if source is numeric and RTS,
00AFE6  2               					; else do type mismatch string functions
00AFE6  2               					; avoid this by dumping the return
00AFE6  2               					; address			[AD8D]
00AFE6  2               
00AFE6  2               ;******************************************************************************
00AFE6  2               ;
00AFE6  2               ; perform OR
00AFE6  2               ; this works because NOT(NOT(x) AND NOT(y)) = x OR y
00AFE6  2               ;
00AFE6  2               bcOR:					;				[AFE6]
00AFE6  2  A0 FF        	ldy	#$FF			; set Y for OR
00AFE8  2  2C           .byte	$2C				; makes next line BIT $00A0
00AFE9  2               
00AFE9  2               
00AFE9  2               ;******************************************************************************
00AFE9  2               ;
00AFE9  2               ; perform AND
00AFE9  2               
00AFE9  2               bcAND:					;				[AFE9]
00AFE9  2  A0 00        	ldy	#$00			; clear Y for AND
00AFEB  2  84 0B        	sty	COUNT			; set AND/OR invert value
00AFED  2               
00AFED  2  20 BF B1     	jsr	EvalInteger3		; evaluate integer expression, no sign
00AFF0  2               					; check				[B1BF]
00AFF0  2               
00AFF0  2  A5 64        	lda	FacMantissa+2		; get FAC1 mantissa 3
00AFF2  2  45 0B        	eor	COUNT			; EOR LB
00AFF4  2  85 07        	sta	CHARAC			; save it
00AFF6  2               
00AFF6  2  A5 65        	lda	FacMantissa+3		; get FAC1 mantissa 4
00AFF8  2  45 0B        	eor	COUNT			; EOR HB
00AFFA  2  85 08        	sta	ENDCHR			; save it
00AFFC  2               
00AFFC  2  20 FC BB     	jsr	CopyFAC2toFAC1		; copy FAC2 to FAC1, get 2nd value in
00AFFF  2               					; expression			[BBFC]
00AFFF  2  20 BF B1     	jsr	EvalInteger3		; evaluate integer expression, no sign
00B002  2               					; check				[B1BF]
00B002  2  A5 65        	lda	FacMantissa+3		; get FAC1 mantissa 4
00B004  2  45 0B        	eor	COUNT			; EOR HB
00B006  2  25 08        	and	ENDCHR			; AND with expression 1 HB
00B008  2  45 0B        	eor	COUNT			; EOR result HB
00B00A  2  A8           	tay				; save in Y
00B00B  2               
00B00B  2  A5 64        	lda	FacMantissa+2		; get FAC1 mantissa 3
00B00D  2  45 0B        	eor	COUNT			; EOR LB
00B00F  2  25 07        	and	CHARAC			; AND with expression 1 LB
00B011  2  45 0B        	eor	COUNT			; EOR result LB
00B013  2  4C 91 B3     	jmp	ConvertAY2FAC1		; convert fixed integer AY to float FAC1
00B016  2               					; and return			[B391]
00B016  2               
00B016  2               
00B016  2               ;******************************************************************************
00B016  2               ;
00B016  2               ; perform comparisons
00B016  2               ;
00B016  2               ; do < compare
00B016  2               ;
00B016  2               bcSMALLER:				;				[D016]
00B016  2  20 90 AD     	jsr	ChkIfNumStr		; type match check, set C for string
00B019  2               					;				[AD90]
00B019  2  B0 13        	bcs	A_B02E			; branch if string
00B01B  2               
00B01B  2               ; do numeric < compare
00B01B  2  A5 6E        	lda	ARGSGN			; get FAC2 sign (b7)
00B01D  2  09 7F        	ora	#$7F			; set all non sign bits
00B01F  2  25 6A        	and	ArgMantissa		; and FAC2 mantissa 1 (AND in sign bit)
00B021  2  85 6A        	sta	ArgMantissa		; save FAC2 mantissa 1
00B023  2               
00B023  2  A9 69        	lda	#<ARGEXP		; set pointer LB to FAC2
00B025  2  A0 00        	ldy	#>ARGEXP		; set pointer HB to FAC2
00B027  2  20 5B BC     	jsr	CmpFAC1withAY		; compare FAC1 with (AY)	[BC5B]
00B02A  2  AA           	tax				; copy the result
00B02B  2               
00B02B  2  4C 61 B0     	jmp	J_B061			; go evaluate result		[B061]
00B02E  2               
00B02E  2               ; do string < compare
00B02E  2               A_B02E:					;				[B02E]
00B02E  2  A9 00        	lda	#$00			; clear byte
00B030  2  85 0D        	sta	VALTYP			; clear data type flag, $FF = string,
00B032  2               					; $00 = numeric
00B032  2  C6 4D        	dec	CompEvalFlg		; clear < bit in comparrison evaluation
00B034  2               					; flag
00B034  2  20 A6 B6     	jsr	PopStrDescStk		; pop string off descriptor stack, or
00B037  2               					; from top of string. Space returns with
00B037  2               					; A = length, X = pointer LB,
00B037  2               					; Y = pointer HB		[B6A6]
00B037  2  85 61        	sta	FACEXP			; save length
00B039  2  86 62        	stx	FacMantissa		; save string pointer LB
00B03B  2  84 63        	sty	FacMantissa+1		; save string pointer HB
00B03D  2               
00B03D  2  A5 6C        	lda	ArgMantissa+2		; get descriptor pointer LB
00B03F  2  A4 6D        	ldy	ArgMantissa+3		; get descriptor pointer HB
00B041  2  20 AA B6     	jsr	PopStrDescStk2		; pop (YA) descriptor off stack or from
00B044  2               					; top of string space returns with A =
00B044  2               					; length, X = pointer low byte,
00B044  2               					; Y = pointer high byte		[B6AA]
00B044  2  86 6C        	stx	ArgMantissa+2		; save string pointer LB
00B046  2  84 6D        	sty	ArgMantissa+3		; save string pointer HB
00B048  2               
00B048  2  AA           	tax				; copy length
00B049  2               
00B049  2  38           	sec				; set carry for subtract
00B04A  2  E5 61        	sbc	FACEXP			; subtract string 1 length
00B04C  2  F0 08        	beq	A_B056			; branch if string 1 length = string 2
00B04E  2               					; length
00B04E  2  A9 01        	lda	#$01			; set str 1 length > string 2 length
00B050  2  90 04        	bcc	A_B056			; branch if so
00B052  2               
00B052  2  A6 61        	ldx	FACEXP			; get string 1 length
00B054  2  A9 FF        	lda	#$FF			; set str 1 length < string 2 length
00B056  2               A_B056:					;				[B056]
00B056  2  85 66        	sta	FACSGN			; save length compare
00B058  2               
00B058  2  A0 FF        	ldy	#$FF			; set index
00B05A  2  E8           	inx				; adjust for loop
00B05B  2               A_B05B:					;				[B05B]
00B05B  2  C8           	iny				; increment index
00B05C  2               
00B05C  2  CA           	dex				; decrement count
00B05D  2  D0 07        	bne	A_B066			; branch if still bytes to do
00B05F  2               
00B05F  2  A6 66        	ldx	FACSGN			; get length compare back
00B061  2               J_B061:					;				[B061]
00B061  2  30 0F        	bmi	A_B072			; branch if str 1 < str 2
00B063  2               
00B063  2  18           	clc				; flag str 1 <= str 2
00B064  2  90 0C        	bcc	A_B072			; go evaluate result
00B066  2               
00B066  2               A_B066:					;				[B066]
00B066  2  B1 6C        	lda	(ArgMantissa+2),Y	; get string 2 byte
00B068  2  D1 62        	cmp	(FacMantissa),Y		; compare with string 1 byte
00B06A  2  F0 EF        	beq	A_B05B			; loop if bytes =
00B06C  2               
00B06C  2  A2 FF        	ldx	#$FF			; set str 1 < string 2
00B06E  2  B0 02        	bcs	A_B072			; branch if so
00B070  2               
00B070  2  A2 01        	ldx	#$01			; set str 1 > string 2
00B072  2               A_B072:					;				[B072]
00B072  2  E8           	inx				; x = 0, 1 or 2
00B073  2               
00B073  2  8A           	txa				; copy to A
00B074  2  2A           	rol				; * 2 (1, 2 or 4)
00B075  2  25 12        	and	TANSGN			; AND with the comparison evaluation
00B077  2               					; flag
00B077  2  F0 02        	beq	A_B07B			; branch if 0 (compare is false)
00B079  2               
00B079  2  A9 FF        	lda	#$FF			; else set result true
00B07B  2               A_B07B:					;				[B07B]
00B07B  2  4C 3C BC     	jmp	AtoInteger		; save A as integer byte and return
00B07E  2               					;				[BC3C]
00B07E  2               
00B07E  2               A_B07E:					;				[B07E]
00B07E  2  20 FD AE     	jsr	Chk4Comma		; scan for ",", else do syntax error
00B081  2               					; then warm start		[AEFD]
00B081  2               
00B081  2               ;******************************************************************************
00B081  2               ;
00B081  2               ; perform DIM
00B081  2               ;
00B081  2               bcDIM:					;				[D081]
00B081  2  AA           	tax				; copy "DIM" flag to X
00B082  2  20 90 B0     	jsr	GetAddrVar2		; search for variable		[B090]
00B085  2               
00B085  2  20 79 00     	jsr	CHRGOT			; scan memory			[0079]
00B088  2  D0 F4        	bne	A_B07E			; scan for "," and loop if not null
00B08A  2               
00B08A  2  60           	rts
00B08B  2               
00B08B  2               
00B08B  2               ;******************************************************************************
00B08B  2               ;
00B08B  2               ; search for variable
00B08B  2               ;
00B08B  2               GetAddrVar:				;				[B08B]
00B08B  2  A2 00        	ldx	#$00			; set DIM flag = $00
00B08D  2  20 79 00     	jsr	CHRGOT			; scan memory, 1st character	[0079]
00B090  2               GetAddrVar2:				;				[B090]
00B090  2  86 0C        	stx	DIMFLG			; save DIM flag
00B092  2               GetAddrVar3:				;				[B092]
00B092  2  85 45        	sta	VARNAM			; save 1st character
00B094  2               
00B094  2  20 79 00     	jsr	CHRGOT			; scan memory			[0079]
00B097  2               
00B097  2  20 13 B1     	jsr	CheckAtoZ		; check byte, return Cb = 0 if < "A"
00B09A  2               					; or > "Z"			[B113]
00B09A  2  B0 03        	bcs	A_B09F			; branch if ok
00B09C  2               
00B09C  2               A_B09C:					;				[B09C]
00B09C  2  4C 08 AF     	jmp	SyntaxError		; else syntax error then warm start
00B09F  2               					;				[AF08]
00B09F  2               
00B09F  2               ; was variable name so ...
00B09F  2               A_B09F:					;				[B09F]
00B09F  2  A2 00        	ldx	#$00			; clear 2nd character temp
00B0A1  2  86 0D        	stx	VALTYP			; clear data type flag, $FF = string,
00B0A3  2               					; $00 = numeric
00B0A3  2  86 0E        	stx	INTFLG			; clear data type flag, $80 = integer,
00B0A5  2               					; $00 = float
00B0A5  2  20 73 00     	jsr	CHRGET			; increment and scan memory, 2nd
00B0A8  2               					; character			[0073]
00B0A8  2  90 05        	bcc	A_B0AF			; if character = "0"-"9" (ok) go save
00B0AA  2               					; 2nd character
00B0AA  2               
00B0AA  2               ; 2nd character wasn't "0" to "9" so ...
00B0AA  2  20 13 B1     	jsr	CheckAtoZ		; check byte, return Cb = 0 if < "A" or
00B0AD  2               					; > "Z"				[B113]
00B0AD  2  90 0B        	bcc	A_B0BA			; branch if <"A" or >"Z" (go check if
00B0AF  2               					; string)
00B0AF  2               A_B0AF:					;				[B0AF]
00B0AF  2  AA           	tax				; copy 2nd character
00B0B0  2               
00B0B0  2               ; ignore further (valid) characters in the variable name
00B0B0  2               A_B0B0:					;				[B0B0]
00B0B0  2  20 73 00     	jsr	CHRGET			; increment and scan memory, 3rd
00B0B3  2               					; character			[0073]
00B0B3  2  90 FB        	bcc	A_B0B0			; loop if character = "0"-"9" (ignore)
00B0B5  2               
00B0B5  2  20 13 B1     	jsr	CheckAtoZ		; check byte, return Cb = 0 if < "A" or
00B0B8  2               					; > "Z"				[B113]
00B0B8  2  B0 F6        	bcs	A_B0B0			; loop if character = "A"-"Z" (ignore)
00B0BA  2               
00B0BA  2               ; check if string variable
00B0BA  2               A_B0BA:					;				[B0BA]
00B0BA  2  C9 24        	cmp	#'$'			; compare with "$"
00B0BC  2  D0 06        	bne	A_B0C4			; branch if not string
00B0BE  2               
00B0BE  2               ; type is string
00B0BE  2  A9 FF        	lda	#$FF			; set data type = string
00B0C0  2  85 0D        	sta	VALTYP			; set data type flag, $FF = string,
00B0C2  2               					; $00 = numeric
00B0C2  2  D0 10        	bne	A_B0D4			; branch always
00B0C4  2               
00B0C4  2               A_B0C4:					;				[B0C4]
00B0C4  2  C9 25        	cmp	#'%'			; compare with "%"
00B0C6  2  D0 13        	bne	A_B0DB			; branch if not integer
00B0C8  2               
00B0C8  2  A5 10        	lda	SUBFLG			; get subscript/FNX flag
00B0CA  2  D0 D0        	bne	A_B09C			; if ?? do syntax error then warm start
00B0CC  2               
00B0CC  2  A9 80        	lda	#$80			; set integer type
00B0CE  2  85 0E        	sta	INTFLG			; set data type = integer
00B0D0  2               
00B0D0  2  05 45        	ora	VARNAM			; OR current variable name first byte
00B0D2  2  85 45        	sta	VARNAM			; save current variable name first byte
00B0D4  2               A_B0D4:					;				[B0D4]
00B0D4  2  8A           	txa				; get 2nd character back
00B0D5  2  09 80        	ora	#$80			; set top bit, indicate string or
00B0D7  2               					; integer variable
00B0D7  2  AA           	tax				; copy back to 2nd character temp
00B0D8  2               
00B0D8  2  20 73 00     	jsr	CHRGET			; increment and scan memory	[0073]
00B0DB  2               A_B0DB:					;				[B0DB]
00B0DB  2  86 46        	stx	VARNAM+1		; save 2nd character
00B0DD  2               
00B0DD  2  38           	sec				; set carry for subtract
00B0DE  2  05 10        	ora	SUBFLG			; or with subscript/FNX flag - or FN
00B0E0  2               					; name
00B0E0  2  E9 28        	sbc	#'('			; subtract "("
00B0E2  2  D0 03        	bne	A_B0E7			; branch if not "("
00B0E4  2               
00B0E4  2  4C D1 B1     	jmp	FindMakeArray		; go find, or make, array	[B1D1]
00B0E7  2               
00B0E7  2               ; either find or create variable
00B0E7  2               
00B0E7  2               ; variable name wasn't xx(.... so look for plain variable
00B0E7  2               A_B0E7:					;				[B0E7]
00B0E7  2  A0 00        	ldy	#$00			; clear A
00B0E9  2  84 10        	sty	SUBFLG			; clear subscript/FNX flag
00B0EB  2               
00B0EB  2  A5 2D        	lda	VARTAB			; get start of variables LB
00B0ED  2  A6 2E        	ldx	VARTAB+1		; get start of variables HB
00B0EF  2               A_B0EF:					;				[B0EF]
00B0EF  2  86 60        	stx	FacTempStor+9		; save search address HB
00B0F1  2               A_B0F1:					;				[B0F1]
00B0F1  2  85 5F        	sta	FacTempStor+8		; save search address LB
00B0F3  2               
00B0F3  2  E4 30        	cpx	ARYTAB+1		; compare with end of variables HB
00B0F5  2  D0 04        	bne	A_B0FB			; skip next compare if <>
00B0F7  2               
00B0F7  2               ; high addresses were = so compare low addresses
00B0F7  2  C5 2F        	cmp	ARYTAB			; compare low address with end of
00B0F9  2               					; variables LB
00B0F9  2  F0 22        	beq	A_B11D			; if not found go make new variable
00B0FB  2               
00B0FB  2               A_B0FB:					;				[B0FB]
00B0FB  2  A5 45        	lda	VARNAM			; get 1st character of variable to find
00B0FD  2  D1 5F        	cmp	(FacTempStor+8),Y	; compare with variable name 1st
00B0FF  2               					; character
00B0FF  2  D0 08        	bne	A_B109			; branch if no match
00B101  2               
00B101  2               ; 1st characters match so compare 2nd character
00B101  2  A5 46        	lda	VARNAM+1		; get 2nd character of variable to find
00B103  2  C8           	iny				; index to point to variable name 2nd
00B104  2               					; character
00B104  2  D1 5F        	cmp	(FacTempStor+8),Y	; compare with variable name 2nd
00B106  2               					; character
00B106  2  F0 7D        	beq	A_B185			; branch if match (found variable)
00B108  2               
00B108  2  88           	dey				; else decrement index (now = $00)
00B109  2               A_B109:					;				[B109]
00B109  2  18           	clc				; clear carry for add
00B10A  2  A5 5F        	lda	FacTempStor+8		; get search address LB
00B10C  2  69 07        	adc	#$07			; +7, offset to next variable name
00B10E  2  90 E1        	bcc	A_B0F1			; loop if no overflow to HB
00B110  2               
00B110  2  E8           	inx				; else increment HB
00B111  2  D0 DC        	bne	A_B0EF			; loop always, RAM doesn't extend to
00B113  2               					; $FFFF
00B113  2               ; check byte, return C = 0 if <"A" or >"Z"
00B113  2               CheckAtoZ:				;				[B113]
00B113  2  C9 41        	cmp	#'a'			; compare with "A"
00B115  2  90 05        	bcc	A_B11C			; exit if less
00B117  2               
00B117  2               ; carry is set
00B117  2  E9 5B        	sbc	#'z'+1			; subtract "Z"+1
00B119  2               
00B119  2  38           	sec				; set carry
00B11A  2  E9 A5        	sbc	#$A5			; subtract $A5 (restore byte)
00B11C  2               					; carry clear if byte > $5A
00B11C  2               A_B11C:					;				[B11C]
00B11C  2  60           	rts
00B11D  2               
00B11D  2               ; reached end of variable memory without match
00B11D  2               ; ... so create new variable
00B11D  2               A_B11D:					;				[B11D]
00B11D  2  68           	pla				; pop return address LB
00B11E  2  48           	pha				; push return address LB
00B11F  2               
00B11F  2  C9 2A        	cmp	#<(GetVariable+2)	; compare with expected calling routine
00B121  2               					; return LB
00B121  2  D0 05        	bne	A_B128			; if not get variable go create new
00B123  2               					; variable
00B123  2               
00B123  2               ; this will only drop through if the call was from GetVariable and is only
00B123  2               ; called from there if it is searching for a variable from the right hand side
00B123  2               ; of a LET a=b statement, it prevents the creation of variables not assigned a
00B123  2               ; value.
00B123  2               
00B123  2               ; value returned by this is either numeric zero, exponent byte is $00, or null
00B123  2               ; string, descriptor length byte is $00. in fact a pointer to any $00 byte
00B123  2               ; would have done.
00B123  2               
00B123  2               ; else return dummy null value
00B123  2               A_B123:					;				[B123]
00B123  2  A9 13        	lda	#<L_BF13		; set result pointer LB
00B125  2  A0 BF        	ldy	#>L_BF13		; set result pointer HB
00B127  2  60           	rts
00B128  2               
00B128  2               ; create new numeric variable
00B128  2               A_B128:					;				[B128]
00B128  2  A5 45        	lda	VARNAM			; get variable name first character
00B12A  2               
00B12A  2  A4 46        	ldy	VARNAM+1		; get variable name second character
00B12C  2  C9 54        	cmp	#'t'			; compare first character with "T"
00B12E  2  D0 0B        	bne	A_B13B			; branch if not "T"
00B130  2               
00B130  2  C0 C9        	cpy	#'i'+$80		; compare second character with "I$"
00B132  2  F0 EF        	beq	A_B123			; if "I$" return null value
00B134  2               
00B134  2  C0 49        	cpy	#'i'			; compare second character with "I"
00B136  2  D0 03        	bne	A_B13B			; branch if not "I"
00B138  2               
00B138  2               ; if name is "TI" do syntax error
00B138  2               A_B138:					;				[B138]
00B138  2  4C 08 AF     	jmp	SyntaxError		; do syntax error then warm start [AF08]
00B13B  2               
00B13B  2               A_B13B:					;				[B13B]
00B13B  2  C9 53        	cmp	#'s'			; compare first character with "S"
00B13D  2  D0 04        	bne	A_B143			; branch if not "S"
00B13F  2               
00B13F  2  C0 54        	cpy	#'t'			; compare second character with "T"
00B141  2  F0 F5        	beq	A_B138			; if name is "ST" do syntax error
00B143  2               
00B143  2               A_B143:					;				[B143]
00B143  2  A5 2F        	lda	ARYTAB			; get end of variables LB
00B145  2  A4 30        	ldy	ARYTAB+1		; get end of variables HB
00B147  2  85 5F        	sta	FacTempStor+8		; save old block start LB
00B149  2  84 60        	sty	FacTempStor+9		; save old block start HB
00B14B  2               
00B14B  2  A5 31        	lda	STREND			; get end of arrays LB
00B14D  2  A4 32        	ldy	STREND+1		; get end of arrays HB
00B14F  2  85 5A        	sta	FacTempStor+3		; save old block end LB
00B151  2  84 5B        	sty	FacTempStor+4		; save old block end HB
00B153  2               
00B153  2  18           	clc				; clear carry for add
00B154  2  69 07        	adc	#$07			; +7, space for one variable
00B156  2  90 01        	bcc	A_B159			; branch if no overflow to HB
00B158  2               
00B158  2  C8           	iny				; else increment HB
00B159  2               A_B159:					;				[B159]
00B159  2  85 58        	sta	FacTempStor+1		; set new block end LB
00B15B  2  84 59        	sty	FacTempStor+2		; set new block end HB
00B15D  2               
00B15D  2  20 B8 A3     	jsr	MoveBlock		; open up space in memory	[A3B8]
00B160  2               
00B160  2  A5 58        	lda	FacTempStor+1		; get new start LB
00B162  2  A4 59        	ldy	FacTempStor+2		; get new start HB (-$100)
00B164  2  C8           	iny				; correct HB
00B165  2  85 2F        	sta	ARYTAB			; set end of variables LB
00B167  2  84 30        	sty	ARYTAB+1		; set end of variables HB
00B169  2               
00B169  2  A0 00        	ldy	#$00			; clear index
00B16B  2  A5 45        	lda	VARNAM			; get variable name 1st character
00B16D  2  91 5F        	sta	(FacTempStor+8),Y	; save variable name 1st character
00B16F  2               
00B16F  2  C8           	iny				; increment index
00B170  2  A5 46        	lda	VARNAM+1		; get variable name 2nd character
00B172  2  91 5F        	sta	(FacTempStor+8),Y	; save variable name 2nd character
00B174  2               
00B174  2  A9 00        	lda	#$00			; clear A
00B176  2  C8           	iny				; increment index
00B177  2  91 5F        	sta	(FacTempStor+8),Y	; initialise variable byte
00B179  2               
00B179  2  C8           	iny				; increment index
00B17A  2  91 5F        	sta	(FacTempStor+8),Y	; initialise variable byte
00B17C  2               
00B17C  2  C8           	iny				; increment index
00B17D  2  91 5F        	sta	(FacTempStor+8),Y	; initialise variable byte
00B17F  2               
00B17F  2  C8           	iny				; increment index
00B180  2  91 5F        	sta	(FacTempStor+8),Y	; initialise variable byte
00B182  2               
00B182  2  C8           	iny				; increment index
00B183  2  91 5F        	sta	(FacTempStor+8),Y	; initialise variable byte
00B185  2               
00B185  2               ; found a match for variable
00B185  2               A_B185:					;				[B185]
00B185  2  A5 5F        	lda	FacTempStor+8		; get variable address LB
00B187  2  18           	clc				; clear carry for add
00B188  2  69 02        	adc	#$02			; +2, offset past variable name bytes
00B18A  2  A4 60        	ldy	FacTempStor+9		; get variable address HB
00B18C  2  90 01        	bcc	A_B18F			; branch if no overflow from add
00B18E  2               
00B18E  2  C8           	iny				; else increment HB
00B18F  2               A_B18F:					;				[B18F]
00B18F  2  85 47        	sta	VARPNT			; save current variable pointer LB
00B191  2  84 48        	sty	VARPNT+1		; save current variable pointer HB
00B193  2  60           	rts
00B194  2               
00B194  2               ; set-up array pointer to first element in array
00B194  2               
00B194  2               SetupPointer:				;				[B194]
00B194  2  A5 0B        	lda	COUNT			; get # of dimensions (1, 2 or 3)
00B196  2  0A           	asl				; *2 (also clears the carry !)
00B197  2  69 05        	adc	#$05			; +5 (result is 7, 9 or 11 here)
00B199  2  65 5F        	adc	FacTempStor+8		; add array start pointer LB
00B19B  2  A4 60        	ldy	FacTempStor+9		; get array pointer HB
00B19D  2  90 01        	bcc	A_B1A0			; branch if no overflow
00B19F  2               
00B19F  2  C8           	iny				; else increment HB
00B1A0  2               A_B1A0:					;				[B1A0]
00B1A0  2  85 58        	sta	FacTempStor+1		; save array data pointer LB
00B1A2  2  84 59        	sty	FacTempStor+2		; save array data pointer HB
00B1A4  2  60           	rts
00B1A5  2               
00B1A5  2               
00B1A5  2               ;******************************************************************************
00B1A5  2               ;
00B1A5  2               ; -32768 as floating value
00B1A5  2               ;
00B1A5  2               M32768:					;				[B1A5]
00B1A5  2  90 80 00 00  .byte	$90,$80,$00,$00,$00		; -32768
00B1A9  2  00           
00B1AA  2               
00B1AA  2               
00B1AA  2               ;******************************************************************************
00B1AA  2               ;
00B1AA  2               ; convert float to fixed
00B1AA  2               ;
00B1AA  2               Float2Fixed:				;				[B1AA]
00B1AA  2  20 BF B1     	jsr	EvalInteger3		; evaluate integer expression, no sign
00B1AD  2               					; check	[B1BF]
00B1AD  2               
00B1AD  2  A5 64        	lda	FacMantissa+2		; get result LB
00B1AF  2  A4 65        	ldy	FacMantissa+3		; get result HB
00B1B1  2  60           	rts
00B1B2  2               
00B1B2  2               
00B1B2  2               ;******************************************************************************
00B1B2  2               ;
00B1B2  2               ; evaluate integer expression
00B1B2  2               ;
00B1B2  2               EvalInteger:				;				[B1B2]
00B1B2  2  20 73 00     	jsr	CHRGET			; increment and scan memory	[0073]
00B1B5  2  20 9E AD     	jsr	EvaluateValue		; evaluate expression		[AD9E]
00B1B8  2               
00B1B8  2               ; evaluate integer expression, sign check
00B1B8  2               EvalInteger2:				;				[B1B8]
00B1B8  2  20 8D AD     	jsr	CheckIfNumeric		; check if source is numeric, else do
00B1BB  2               					; type mismatch			[AD8D]
00B1BB  2  A5 66        	lda	FACSGN			; get FAC1 sign (b7)
00B1BD  2  30 0D        	bmi	A_B1CC			; do illegal quantity error if -ve
00B1BF  2               
00B1BF  2               ; evaluate integer expression, no sign check
00B1BF  2               EvalInteger3:				;				[B1BF]
00B1BF  2  A5 61        	lda	FACEXP			; get FAC1 exponent
00B1C1  2  C9 90        	cmp	#$90			; compare with exponent = 2^16 (n>2^15)
00B1C3  2  90 09        	bcc	A_B1CE			; if n<2^16 go convert FAC1 floating to
00B1C5  2               					; fixed and return
00B1C5  2  A9 A5        	lda	#<M32768		; set pointer LB to -32768
00B1C7  2  A0 B1        	ldy	#>M32768		; set pointer HB to -32768
00B1C9  2  20 5B BC     	jsr	CmpFAC1withAY		; compare FAC1 with (AY)	[BC5B]
00B1CC  2               A_B1CC:					;				[B1CC]
00B1CC  2  D0 7A        	bne	IllegalQuant		; if <> do illegal quantity error then
00B1CE  2               					; warm start
00B1CE  2               A_B1CE:					;				[B1CE]
00B1CE  2  4C 9B BC     	jmp	FAC1Float2Fix		; convert FAC1 floating to fixed and
00B1D1  2               					; return			[BC9B]
00B1D1  2               
00B1D1  2               ;******************************************************************************
00B1D1  2               ;
00B1D1  2               ; an array is stored as follows
00B1D1  2               ;
00B1D1  2               ; array name		; two bytes with following patterns for different types
00B1D1  2               ;			; 1st char  2nd char
00B1D1  2               ;			;   b7	      b7      type    element size
00B1D1  2               ;			; --------  --------  -----   ------------
00B1D1  2               ;			;   0	      0	      Real       5
00B1D1  2               ;			;   0         1	      string     3
00B1D1  2               ;			;   1	      1	      integer    2
00B1D1  2               ; offset to next array	; word
00B1D1  2               ; dimension count	; byte
00B1D1  2               ; 1st dimension size	; word, this is the number of elements including 0
00B1D1  2               ; 2nd dimension size	; word, only here if the array has a second dimension
00B1D1  2               ; 2nd dimension size	; word, only here if the array has a third dimension
00B1D1  2               ;			; note: the dimension size word is in HB LB
00B1D1  2               ;			; format, not like most 6502 words
00B1D1  2               ; then for each element the required number of bytes given as the element size
00B1D1  2               ; above
00B1D1  2               ;
00B1D1  2               ; find or make array
00B1D1  2               ;
00B1D1  2               FindMakeArray:				;				[B1D1]
00B1D1  2  A5 0C        	lda	DIMFLG			; get DIM flag
00B1D3  2  05 0E        	ora	INTFLG			; OR with data type flag
00B1D5  2  48           	pha				; push it
00B1D6  2               
00B1D6  2  A5 0D        	lda	VALTYP			; get data type flag, $FF = string,
00B1D8  2               					; $00 = numeric
00B1D8  2  48           	pha				; push it
00B1D9  2               
00B1D9  2  A0 00        	ldy	#$00			; clear dimensions count
00B1DB  2               
00B1DB  2               ; now get the array dimension(s) and stack it (them) before the data type and
00B1DB  2               ; DIM flag
00B1DB  2               A_B1DB:					;				[B1DB]
00B1DB  2  98           	tya				; copy dimensions count
00B1DC  2  48           	pha				; save it
00B1DD  2               
00B1DD  2  A5 46        	lda	VARNAM+1		; get array name 2nd byte
00B1DF  2  48           	pha				; save it
00B1E0  2               
00B1E0  2  A5 45        	lda	VARNAM			; get array name 1st byte
00B1E2  2  48           	pha				; save it
00B1E3  2               
00B1E3  2  20 B2 B1     	jsr	EvalInteger		; evaluate integer expression	[B1B2]
00B1E6  2               
00B1E6  2  68           	pla				; pull array name 1st byte
00B1E7  2  85 45        	sta	VARNAM			; restore array name 1st byte
00B1E9  2               
00B1E9  2  68           	pla				; pull array name 2nd byte
00B1EA  2  85 46        	sta	VARNAM+1		; restore array name 2nd byte
00B1EC  2               
00B1EC  2  68           	pla				; pull dimensions count
00B1ED  2  A8           	tay				; restore it
00B1EE  2               
00B1EE  2  BA           	tsx				; copy stack pointer
00B1EF  2  BD 02 01     	lda	STACK+2,X		; get DIM flag
00B1F2  2  48           	pha				; push it
00B1F3  2               
00B1F3  2  BD 01 01     	lda	STACK+1,X		; get data type flag
00B1F6  2  48           	pha				; push it
00B1F7  2               
00B1F7  2  A5 64        	lda	FacMantissa+2		; get this dimension size HB
00B1F9  2  9D 02 01     	sta	STACK+2,X		; stack before flag bytes
00B1FC  2               
00B1FC  2  A5 65        	lda	FacMantissa+3		; get this dimension size LB
00B1FE  2  9D 01 01     	sta	STACK+1,X		; stack before flag bytes
00B201  2               
00B201  2  C8           	iny				; increment dimensions count
00B202  2               
00B202  2  20 79 00     	jsr	CHRGOT			; scan memory			[0079]
00B205  2  C9 2C        	cmp	#','			; compare with ","
00B207  2  F0 D2        	beq	A_B1DB			; if found go do next dimension
00B209  2               
00B209  2  84 0B        	sty	COUNT			; store dimensions count
00B20B  2               
00B20B  2  20 F7 AE     	jsr	Chk4CloseParen		; scan for ")", else do syntax error
00B20E  2               					; then warm start		[AEF7]
00B20E  2  68           	pla				; pull data type flag
00B20F  2  85 0D        	sta	VALTYP			; restore data type flag, $FF = string,
00B211  2               					; $00 = numeric
00B211  2  68           	pla				; pull data type flag
00B212  2  85 0E        	sta	INTFLG			; restore data type flag, $80 = integer,
00B214  2               					; $00 = float
00B214  2  29 7F        	and	#$7F			; mask dim flag
00B216  2  85 0C        	sta	DIMFLG			; restore DIM flag
00B218  2               
00B218  2  A6 2F        	ldx	ARYTAB			; set end of variables LB
00B21A  2               					; (array memory start LB)
00B21A  2  A5 30        	lda	ARYTAB+1		; set end of variables HB
00B21C  2               					; (array memory start HB)
00B21C  2               
00B21C  2               ; now check to see if we are at the end of array memory, we would be if there
00B21C  2               ; were no arrays.
00B21C  2               A_B21C:					;				[B21C]
00B21C  2  86 5F        	stx	FacTempStor+8		; save as array start pointer LB
00B21E  2  85 60        	sta	FacTempStor+9		; save as array start pointer HB
00B220  2               
00B220  2  C5 32        	cmp	STREND+1		; compare with end of arrays HB
00B222  2  D0 04        	bne	A_B228			; branch if not reached array memory end
00B224  2               
00B224  2  E4 31        	cpx	STREND			; else compare with end of arrays LB
00B226  2  F0 39        	beq	A_B261			; go build array if not found
00B228  2               
00B228  2               ; search for array
00B228  2               A_B228:					;				[B228]
00B228  2  A0 00        	ldy	#$00			; clear index
00B22A  2  B1 5F        	lda	(FacTempStor+8),Y	; get array name first byte
00B22C  2  C8           	iny				; increment index to second name byte
00B22D  2  C5 45        	cmp	VARNAM			; compare with this array name first
00B22F  2               					; byte
00B22F  2  D0 06        	bne	A_B237			; branch if no match
00B231  2               
00B231  2  A5 46        	lda	VARNAM+1		; else get this array name second byte
00B233  2  D1 5F        	cmp	(FacTempStor+8),Y	; compare with array name second byte
00B235  2  F0 16        	beq	A_B24D			; array found so branch
00B237  2               
00B237  2               ; no match
00B237  2               A_B237:					;				[B237]
00B237  2  C8           	iny				; increment index
00B238  2  B1 5F        	lda	(FacTempStor+8),Y	; get array size LB
00B23A  2  18           	clc				; clear carry for add
00B23B  2  65 5F        	adc	FacTempStor+8		; add array start pointer LB
00B23D  2  AA           	tax				; copy LB to X
00B23E  2               
00B23E  2  C8           	iny				; increment index
00B23F  2  B1 5F        	lda	(FacTempStor+8),Y	; get array size HB
00B241  2  65 60        	adc	FacTempStor+9		; add array memory pointer HB
00B243  2  90 D7        	bcc	A_B21C			; if no overflow go check next array
00B245  2               
00B245  2               
00B245  2               ;******************************************************************************
00B245  2               ;
00B245  2               ; do bad subscript error
00B245  2               ;
00B245  2               BadSubscript:				;				[B245]
00B245  2  A2 12        	ldx	#$12			; error $12, bad subscript error
00B247  2  2C           .byte	$2C				; makes next line BIT $0EA2
00B248  2               
00B248  2               
00B248  2               ;******************************************************************************
00B248  2               ;
00B248  2               ; do illegal quantity error
00B248  2               ;
00B248  2               IllegalQuant:				;				[B248]
00B248  2  A2 0E        	ldx	#$0E			; error $0E, illegal quantity error
00B24A  2               A_B24A:					;				[B24A]
00B24A  2  4C 37 A4     	jmp	OutputErrMsg		; do error #X then warm start	[A437]
00B24D  2               
00B24D  2               
00B24D  2               ;******************************************************************************
00B24D  2               ;
00B24D  2               ; found the array
00B24D  2               ;
00B24D  2               A_B24D:					;				[B24D]
00B24D  2  A2 13        	ldx	#$13			; set error $13, double dimension error
00B24F  2               
00B24F  2  A5 0C        	lda	DIMFLG			; get DIM flag
00B251  2  D0 F7        	bne	A_B24A			; if we are trying to dimension it do
00B253  2               					; error #X then warm start
00B253  2               
00B253  2               ; found the array and we're not dimensioning it so we must find an element in
00B253  2               ; it
00B253  2  20 94 B1     	jsr	SetupPointer		; set-up array pointer to first element
00B256  2               					; in array			[B194]
00B256  2  A5 0B        	lda	COUNT			; get dimensions count
00B258  2  A0 04        	ldy	#$04			; set index to array's # of dimensions
00B25A  2  D1 5F        	cmp	(FacTempStor+8),Y	; compare with no of dimensions
00B25C  2  D0 E7        	bne	BadSubscript		; if wrong do bad subscript error
00B25E  2               
00B25E  2  4C EA B2     	jmp	GetArrElement		; found array so go get element	[B2EA]
00B261  2               
00B261  2               ; array not found, so build it
00B261  2               A_B261:					;				[B261]
00B261  2  20 94 B1     	jsr	SetupPointer		; set-up array pointer to first element
00B264  2               					; in array			[B194]
00B264  2  20 08 A4     	jsr	CheckAvailMem		; check available memory, do out of
00B267  2               					; memory error if no room	[A408]
00B267  2  A0 00        	ldy	#$00			; clear Y
00B269  2  84 72        	sty	FBUFPT+1		; clear array data size HB
00B26B  2               
00B26B  2  A2 05        	ldx	#$05			; set default element size
00B26D  2  A5 45        	lda	VARNAM			; get variable name 1st byte
00B26F  2  91 5F        	sta	(FacTempStor+8),Y	; save array name 1st byte
00B271  2  10 01        	bpl	A_B274			; branch if not string or floating
00B273  2               					; point array
00B273  2  CA           	dex				; decrement element size, $04
00B274  2               A_B274:					;				[B274]
00B274  2  C8           	iny				; increment index
00B275  2  A5 46        	lda	VARNAM+1		; get variable name 2nd byte
00B277  2  91 5F        	sta	(FacTempStor+8),Y	; save array name 2nd byte
00B279  2  10 02        	bpl	A_B27D			; branch if not integer or string
00B27B  2               
00B27B  2  CA           	dex				; decrement element size, $03
00B27C  2  CA           	dex				; decrement element size, $02
00B27D  2               A_B27D:					;				[B27D]
00B27D  2  86 71        	stx	FBUFPT			; save element size
00B27F  2               
00B27F  2  A5 0B        	lda	COUNT			; get dimensions count
00B281  2  C8           	iny				; increment index ..
00B282  2  C8           	iny				; .. to array  ..
00B283  2  C8           	iny				; .. dimension count
00B284  2  91 5F        	sta	(FacTempStor+8),Y	; save array dimension count
00B286  2               A_B286:					;				[B286]
00B286  2  A2 0B        	ldx	#$0B			; set default dimension size LB
00B288  2  A9 00        	lda	#$00			; set default dimension size HB
00B28A  2  24 0C        	bit	DIMFLG			; test DIM flag
00B28C  2  50 08        	bvc	A_B296			; branch if default to be used
00B28E  2               
00B28E  2  68           	pla				; pull dimension size LB
00B28F  2  18           	clc				; clear carry for add
00B290  2  69 01        	adc	#$01			; add 1, allow for zeroeth element
00B292  2  AA           	tax				; copy LB to X
00B293  2               
00B293  2  68           	pla				; pull dimension size HB
00B294  2  69 00        	adc	#$00			; add carry to HB
00B296  2               A_B296:					;				[B296]
00B296  2  C8           	iny				; incement index to dimension size HB
00B297  2  91 5F        	sta	(FacTempStor+8),Y	; save dimension size HB
00B299  2               
00B299  2  C8           	iny				; incement index to dimension size LB
00B29A  2  8A           	txa				; copy dimension size LB
00B29B  2  91 5F        	sta	(FacTempStor+8),Y	; save dimension size LB
00B29D  2               
00B29D  2  20 4C B3     	jsr	CalcArraySize		; compute array size		[B34C]
00B2A0  2  86 71        	stx	FBUFPT			; save result LB
00B2A2  2  85 72        	sta	FBUFPT+1		; save result HB
00B2A4  2               
00B2A4  2  A4 22        	ldy	INDEX			; restore index
00B2A6  2  C6 0B        	dec	COUNT			; decrement dimensions count
00B2A8  2  D0 DC        	bne	A_B286			; loop if not all done
00B2AA  2               
00B2AA  2  65 59        	adc	FacTempStor+2		; add array data pointer HB
00B2AC  2  B0 5D        	bcs	A_B30B			; if overflow do out of memory error
00B2AE  2               					; then warm start
00B2AE  2  85 59        	sta	FacTempStor+2		; save array data pointer HB
00B2B0  2               
00B2B0  2  A8           	tay				; copy array data pointer HB
00B2B1  2               
00B2B1  2  8A           	txa				; copy array size LB
00B2B2  2  65 58        	adc	FacTempStor+1		; add array data pointer LB
00B2B4  2  90 03        	bcc	A_B2B9			; branch if no rollover
00B2B6  2               
00B2B6  2  C8           	iny				; else increment next array pointer HB
00B2B7  2  F0 52        	beq	A_B30B			; if rolled over do out of memory error
00B2B9  2               					; then warm start
00B2B9  2               A_B2B9:					;				[B2B9]
00B2B9  2  20 08 A4     	jsr	CheckAvailMem		; check available memory, do out of
00B2BC  2               					; memory error if no room	[A408]
00B2BC  2  85 31        	sta	STREND			; set end of arrays LB
00B2BE  2  84 32        	sty	STREND+1		; set end of arrays HB
00B2C0  2               
00B2C0  2               ; now the aray is created we need to zero all the elements in it
00B2C0  2  A9 00        	lda	#$00			; clear A for array clear
00B2C2  2               
00B2C2  2  E6 72        	inc	FBUFPT+1		; increment array size HB, now block
00B2C4  2               					; count
00B2C4  2  A4 71        	ldy	FBUFPT			; get array size LB, now index to block
00B2C6  2  F0 05        	beq	A_B2CD			; branch if $00
00B2C8  2               A_B2C8:					;				[B2C8]
00B2C8  2  88           	dey				; decrement index, do 0 to n-1
00B2C9  2  91 58        	sta	(FacTempStor+1),Y	; clear array element byte
00B2CB  2  D0 FB        	bne	A_B2C8			; loop until this block done
00B2CD  2               
00B2CD  2               A_B2CD:					;				[B2CD]
00B2CD  2  C6 59        	dec	FacTempStor+2		; decrement array pointer HB
00B2CF  2               
00B2CF  2  C6 72        	dec	FBUFPT+1		; decrement block count HB
00B2D1  2  D0 F5        	bne	A_B2C8			; loop until all blocks done
00B2D3  2               
00B2D3  2  E6 59        	inc	FacTempStor+2		; correct for last loop
00B2D5  2               
00B2D5  2  38           	sec				; set carry for subtract
00B2D6  2  A5 31        	lda	STREND			; get end of arrays LB
00B2D8  2  E5 5F        	sbc	FacTempStor+8		; subtract array start LB
00B2DA  2  A0 02        	ldy	#$02			; index to array size LB
00B2DC  2  91 5F        	sta	(FacTempStor+8),Y	; save array size LB
00B2DE  2               
00B2DE  2  A5 32        	lda	STREND+1		; get end of arrays HB
00B2E0  2  C8           	iny				; index to array size HB
00B2E1  2  E5 60        	sbc	FacTempStor+9		; subtract array start HB
00B2E3  2  91 5F        	sta	(FacTempStor+8),Y	; save array size HB
00B2E5  2               
00B2E5  2  A5 0C        	lda	DIMFLG			; get default DIM flag
00B2E7  2  D0 62        	bne	A_B34B			; exit if this was a DIM command
00B2E9  2               
00B2E9  2               ; else, find element
00B2E9  2  C8           	iny				; set index to # of dimensions, the
00B2EA  2               					; dimension indeces are on the stack and
00B2EA  2               					; and will be removed as the position
00B2EA  2               					; of the array element is calculated
00B2EA  2               
00B2EA  2               GetArrElement:				;				[B2EA]
00B2EA  2  B1 5F        	lda	(FacTempStor+8),Y	; get array's dimension count
00B2EC  2  85 0B        	sta	COUNT			; save it
00B2EE  2               
00B2EE  2  A9 00        	lda	#$00			; clear byte
00B2F0  2  85 71        	sta	FBUFPT			; clear array data pointer LB
00B2F2  2               A_B2F2:					;				[B2F2]
00B2F2  2  85 72        	sta	FBUFPT+1		; save array data pointer HB
00B2F4  2               
00B2F4  2  C8           	iny				; increment index, point to array bound
00B2F5  2               					; HB
00B2F5  2  68           	pla				; pull array index LB
00B2F6  2  AA           	tax				; copy to X
00B2F7  2  85 64        	sta	FacMantissa+2		; save index LB to FAC1 mantissa 3
00B2F9  2               
00B2F9  2  68           	pla				; pull array index HB
00B2FA  2  85 65        	sta	FacMantissa+3		; save index HB to FAC1 mantissa 4
00B2FC  2               
00B2FC  2  D1 5F        	cmp	(FacTempStor+8),Y	; compare with array bound HB
00B2FE  2  90 0E        	bcc	A_B30E			; branch if within bounds
00B300  2               
00B300  2  D0 06        	bne	A_B308			; if outside bounds do bad subscript
00B302  2               					; error
00B302  2               ; else HB was = so test LBs
00B302  2  C8           	iny				; index to array bound LB
00B303  2  8A           	txa				; get array index LB
00B304  2  D1 5F        	cmp	(FacTempStor+8),Y	; compare with array bound LB
00B306  2  90 07        	bcc	A_B30F			; branch if within bounds
00B308  2               
00B308  2               A_B308:					;				[B308]
00B308  2  4C 45 B2     	jmp	BadSubscript		; do bad subscript error	[B245]
00B30B  2               
00B30B  2               A_B30B:					;				[B30B]
00B30B  2  4C 35 A4     	jmp	OutOfMemory		; do out of memory error then warm start
00B30E  2               					;				[A435]
00B30E  2               
00B30E  2               A_B30E:					;				[B30E]
00B30E  2  C8           	iny				; index to array bound LB
00B30F  2               A_B30F:					;				[B30F]
00B30F  2  A5 72        	lda	FBUFPT+1		; get array data pointer HB
00B311  2  05 71        	ora	FBUFPT			; OR with array data pointer LB
00B313  2  18           	clc
00B314  2  F0 0A        	beq	A_B320			; branch if array data pointer = null,
00B316  2               					; skip multiply
00B316  2  20 4C B3     	jsr	CalcArraySize		; compute array size		[B34C]
00B319  2               
00B319  2  8A           	txa				; get result LB
00B31A  2  65 64        	adc	FacMantissa+2		; add index LB from FAC1 mantissa 3
00B31C  2  AA           	tax				; save result LB
00B31D  2               
00B31D  2  98           	tya				; get result HB
00B31E  2  A4 22        	ldy	INDEX			; restore index
00B320  2               A_B320:					;				[B320]
00B320  2  65 65        	adc	FacMantissa+3		; add index HB from FAC1 mantissa 4
00B322  2               
00B322  2  86 71        	stx	FBUFPT			; save array data pointer LB
00B324  2               
00B324  2  C6 0B        	dec	COUNT			; decrement dimensions count
00B326  2  D0 CA        	bne	A_B2F2			; loop if dimensions still to do
00B328  2               
00B328  2  85 72        	sta	FBUFPT+1		; save array data pointer HB
00B32A  2               
00B32A  2  A2 05        	ldx	#$05			; set default element size
00B32C  2               
00B32C  2  A5 45        	lda	VARNAM			; get variable name 1st byte
00B32E  2  10 01        	bpl	A_B331			; branch if not string or floating
00B330  2               					; point array
00B330  2  CA           	dex				; decrement element size, $04
00B331  2               A_B331:					;				[B331]
00B331  2  A5 46        	lda	VARNAM+1		; get variable name 2nd byte
00B333  2  10 02        	bpl	A_B337			; branch if not integer or string
00B335  2               
00B335  2  CA           	dex				; decrement element size, $03
00B336  2  CA           	dex				; decrement element size, $02
00B337  2               A_B337:					;				[B337]
00B337  2  86 28        	stx	RESHO+2			; save dimension size LB
00B339  2               
00B339  2  A9 00        	lda	#$00			; clear dimension size HB
00B33B  2  20 55 B3     	jsr	CalcArraySize2		; compute array size		[B355]
00B33E  2               
00B33E  2  8A           	txa				; copy array size LB
00B33F  2  65 58        	adc	FacTempStor+1		; add array data start pointer LB
00B341  2  85 47        	sta	VARPNT			; save as current variable pointer LB
00B343  2               
00B343  2  98           	tya				; copy array size HB
00B344  2  65 59        	adc	FacTempStor+2		; add array data start pointer HB
00B346  2  85 48        	sta	VARPNT+1		; save as current variable pointer HB
00B348  2               
00B348  2  A8           	tay				; copy HB to Y
00B349  2  A5 47        	lda	VARPNT			; get current variable pointer LB
00B34B  2               					; pointer to element is now in AY
00B34B  2               A_B34B:					;				[B34B]
00B34B  2  60           	rts
00B34C  2               
00B34C  2               
00B34C  2               ;******************************************************************************
00B34C  2               ;
00B34C  2               ; compute array size, result in XY
00B34C  2               ;
00B34C  2               CalcArraySize:				;				[B34C]
00B34C  2  84 22        	sty	INDEX			; save index
00B34E  2  B1 5F        	lda	(FacTempStor+8),Y	; get dimension size LB
00B350  2  85 28        	sta	RESHO+2			; save dimension size LB
00B352  2               
00B352  2  88           	dey				; decrement index
00B353  2  B1 5F        	lda	(FacTempStor+8),Y	; get dimension size HB
00B355  2               CalcArraySize2:				;				[B355]
00B355  2  85 29        	sta	RESHO+3			; save dimension size HB
00B357  2               
00B357  2  A9 10        	lda	#$10			; count = $10 (16 bit multiply)
00B359  2  85 5D        	sta	FacTempStor+6		; save bit count
00B35B  2               
00B35B  2  A2 00        	ldx	#$00			; clear result LB
00B35D  2  A0 00        	ldy	#$00			; clear result HB
00B35F  2               A_B35F:					;				[B35F]
00B35F  2  8A           	txa				; get result LB
00B360  2  0A           	asl				; *2
00B361  2  AA           	tax				; save result LB
00B362  2               
00B362  2  98           	tya				; get result HB
00B363  2  2A           	rol				; *2
00B364  2  A8           	tay				; save result HB
00B365  2  B0 A4        	bcs	A_B30B			; if overflow go do "Out of memory"
00B367  2               					; error
00B367  2  06 71        	asl	FBUFPT			; shift element size LB
00B369  2  26 72        	rol	FBUFPT+1		; shift element size HB
00B36B  2  90 0B        	bcc	A_B378			; skip add if no carry
00B36D  2               
00B36D  2  18           	clc				; else clear carry for add
00B36E  2  8A           	txa				; get result LB
00B36F  2  65 28        	adc	RESHO+2			; add dimension size LB
00B371  2  AA           	tax				; save result LB
00B372  2               
00B372  2  98           	tya				; get result HB
00B373  2  65 29        	adc	RESHO+3			; add dimension size HB
00B375  2  A8           	tay				; save result HB
00B376  2  B0 93        	bcs	A_B30B			; if overflow go do "Out of memory"
00B378  2               					; error
00B378  2               A_B378:					;				[B378]
00B378  2  C6 5D        	dec	FacTempStor+6		; decrement bit count
00B37A  2  D0 E3        	bne	A_B35F			; loop until all done
00B37C  2               
00B37C  2  60           	rts
00B37D  2               
00B37D  2               ;******************************************************************************
00B37D  2               ;
00B37D  2               ; perform FRE()
00B37D  2               ;
00B37D  2               bcFRE:					;				[B37D]
00B37D  2  A5 0D        	lda	VALTYP			; get data type flag, $FF = string,
00B37F  2               					; $00 = numeric
00B37F  2  F0 03        	beq	A_B384			; branch if numeric
00B381  2               
00B381  2  20 A6 B6     	jsr	PopStrDescStk		; pop string off descriptor stack, or
00B384  2               					; from top of string space returns with
00B384  2               					; A = length, X=$71=pointer LB,
00B384  2               					; Y=$72=pointer HB		[B6A6]
00B384  2               ; FRE(n) was numeric so do this
00B384  2               A_B384:					;				[B384]
00B384  2  20 26 B5     	jsr	CollectGarbage		; go do garbage collection	[B526]
00B387  2               
00B387  2  38           	sec				; set carry for subtract
00B388  2  A5 33        	lda	FRETOP			; get bottom of string space LB
00B38A  2  E5 31        	sbc	STREND			; subtract end of arrays LB
00B38C  2  A8           	tay				; copy result to Y
00B38D  2               
00B38D  2  A5 34        	lda	FRETOP+1		; get bottom of string space HB
00B38F  2  E5 32        	sbc	STREND+1		; subtract end of arrays HB
00B391  2               
00B391  2               
00B391  2               ;******************************************************************************
00B391  2               ;
00B391  2               ; convert fixed integer AY to float FAC1
00B391  2               ;
00B391  2               ConvertAY2FAC1:				;				[B391]
00B391  2  A2 00        	ldx	#$00			; set type = numeric
00B393  2  86 0D        	stx	VALTYP			; clear data type flag, $FF = string,
00B395  2               					; $00 = numeric
00B395  2  85 62        	sta	FacMantissa		; save FAC1 mantissa 1
00B397  2  84 63        	sty	FacMantissa+1		; save FAC1 mantissa 2
00B399  2               
00B399  2  A2 90        	ldx	#$90			; set exponent=2^16 (integer)
00B39B  2  4C 44 BC     	jmp	J_BC44			; set exp = X, clear FAC1 3 and 4,
00B39E  2               					; normalise and return		[BC44]
00B39E  2               
00B39E  2               ;******************************************************************************
00B39E  2               ;
00B39E  2               ; perform POS()
00B39E  2               ;
00B39E  2               bcPOS:					;				[B39E]
00B39E  2  38           	sec				; set Cb for read cursor position
00B39F  2  20 F0 FF     	jsr	CursorPosXY		; read/set X,Y cursor position	[FFF0]
00B3A2  2               bcPOS2:					;				[B3A2]
00B3A2  2  A9 00        	lda	#$00			; clear HB
00B3A4  2  F0 EB        	beq	ConvertAY2FAC1		; convert fixed integer AY to float
00B3A6  2               					; FAC1, branch always
00B3A6  2               ; check not Direct, used by DEF and INPUT
00B3A6  2               ChkDirectMode:				;				[B3A6]
00B3A6  2  A6 3A        	ldx	CURLIN+1		; get current line number HB
00B3A8  2  E8           	inx				; increment it
00B3A9  2  D0 A0        	bne	A_B34B			; return if not direct mode
00B3AB  2               
00B3AB  2               ; else do illegal direct error
00B3AB  2  A2 15        	ldx	#$15			; error $15, illegal direct error
00B3AD  2  2C           .byte	$2C				; makes next line BIT $1BA2
00B3AE  2               A_B3AE:					;				[B3AE]
00B3AE  2  A2 1B        	ldx	#$1B			; error $1B, undefined function error
00B3B0  2  4C 37 A4     	jmp	OutputErrMsg		; do error #X then warm start	[A437]
00B3B3  2               
00B3B3  2               
00B3B3  2               ;******************************************************************************
00B3B3  2               ;
00B3B3  2               ; perform DEF
00B3B3  2               ;
00B3B3  2               bcDEF:					;				[B3B3]
00B3B3  2  20 E1 B3     	jsr	ChkFNxSyntax		; check FNx syntax		[B3E1]
00B3B6  2  20 A6 B3     	jsr	ChkDirectMode		; check not direct, back here if ok
00B3B9  2               					;				[B3A6]
00B3B9  2  20 FA AE     	jsr	Chk4OpenParen		; scan for "(", else do syntax error
00B3BC  2               					; then warm start		[AEFA]
00B3BC  2               
00B3BC  2  A9 80        	lda	#$80			; set flag for FNx
00B3BE  2  85 10        	sta	SUBFLG			; save subscript/FNx flag
00B3C0  2               
00B3C0  2  20 8B B0     	jsr	GetAddrVar		; get variable address		[B08B]
00B3C3  2  20 8D AD     	jsr	CheckIfNumeric		; check if source is numeric, else do
00B3C6  2               					; type mismatch			[AD8D]
00B3C6  2  20 F7 AE     	jsr	Chk4CloseParen		; scan for ")", else do syntax error
00B3C9  2               					; then warm start		[AEF7]
00B3C9  2               
00B3C9  2  A9 B2        	lda	#TK_EQUAL		; get = token
00B3CB  2  20 FF AE     	jsr	Chk4CharInA		; scan for CHR$(A), else do syntax
00B3CE  2               					; error then warm start		[AEFF]
00B3CE  2  48           	pha				; push next character
00B3CF  2               
00B3CF  2  A5 48        	lda	VARPNT+1		; get current variable pointer HB
00B3D1  2  48           	pha				; push it
00B3D2  2               
00B3D2  2  A5 47        	lda	VARPNT			; get current variable pointer LB
00B3D4  2  48           	pha				; push it
00B3D5  2               
00B3D5  2  A5 7B        	lda	TXTPTR+1		; get BASIC execute pointer HB
00B3D7  2  48           	pha				; push it
00B3D8  2               
00B3D8  2  A5 7A        	lda	TXTPTR			; get BASIC execute pointer LB
00B3DA  2  48           	pha				; push it
00B3DB  2               
00B3DB  2  20 F8 A8     	jsr	bcDATA			; perform DATA			[A8F8]
00B3DE  2  4C 4F B4     	jmp	Ptrs2Function		; put execute pointer and variable
00B3E1  2               					; pointer into function	and return
00B3E1  2               					;				[B44F]
00B3E1  2               
00B3E1  2               ;******************************************************************************
00B3E1  2               ;
00B3E1  2               ; check FNx syntax
00B3E1  2               ;
00B3E1  2               ChkFNxSyntax:				;				[B3E1]
00B3E1  2  A9 A5        	lda	#TK_FN			; set FN token
00B3E3  2  20 FF AE     	jsr	Chk4CharInA		; scan for CHR$(A), else do syntax error
00B3E6  2               					; then warm start		[AEFF]
00B3E6  2               
00B3E6  2  09 80        	ora	#$80			; set FN flag bit
00B3E8  2  85 10        	sta	SUBFLG			; save FN name
00B3EA  2               
00B3EA  2  20 92 B0     	jsr	GetAddrVar3		; search for FN variable	[B092]
00B3ED  2  85 4E        	sta	GarbagePtr		; save function pointer LB
00B3EF  2  84 4F        	sty	GarbagePtr+1		; save function pointer HB
00B3F1  2               
00B3F1  2  4C 8D AD     	jmp	CheckIfNumeric		; check if source is numeric and return,
00B3F4  2               					; else do type mismatch		[AD8D]
00B3F4  2               
00B3F4  2               ;******************************************************************************
00B3F4  2               ;
00B3F4  2               ; Evaluate FNx
00B3F4  2               ;
00B3F4  2               EvaluateFNx:				;				[B3F4]
00B3F4  2  20 E1 B3     	jsr	ChkFNxSyntax		; check FNx syntax		[B3E1]
00B3F7  2               
00B3F7  2  A5 4F        	lda	GarbagePtr+1		; get function pointer HB
00B3F9  2  48           	pha				; push it
00B3FA  2               
00B3FA  2  A5 4E        	lda	GarbagePtr		; get function pointer LB
00B3FC  2  48           	pha				; push it
00B3FD  2               
00B3FD  2  20 F1 AE     	jsr	Chk4Parens		; evaluate expression within parentheses
00B400  2               					;				[AEF1]
00B400  2  20 8D AD     	jsr	CheckIfNumeric		; check if source is numeric, else do
00B403  2               					; type mismatch			[AD8D]
00B403  2               
00B403  2  68           	pla				; pop function pointer LB
00B404  2  85 4E        	sta	GarbagePtr		; restore it
00B406  2               
00B406  2  68           	pla				; pop function pointer HB
00B407  2  85 4F        	sta	GarbagePtr+1		; restore it
00B409  2               
00B409  2  A0 02        	ldy	#$02			; index to variable pointer HB
00B40B  2  B1 4E        	lda	(GarbagePtr),Y		; get variable address LB
00B40D  2  85 47        	sta	VARPNT			; save current variable pointer LB
00B40F  2               
00B40F  2  AA           	tax				; copy address LB
00B410  2               
00B410  2  C8           	iny				; index to variable address HB
00B411  2  B1 4E        	lda	(GarbagePtr),Y		; get variable pointer HB
00B413  2  F0 99        	beq	A_B3AE			; branch if HB zero
00B415  2               
00B415  2  85 48        	sta	VARPNT+1		; save current variable pointer HB
00B417  2  C8           	iny				; index to mantissa 3
00B418  2               
00B418  2               ; now stack the function variable value before use
00B418  2               A_B418:					;				[B418]
00B418  2  B1 47        	lda	(VARPNT),Y		; get byte from variable
00B41A  2  48           	pha				; stack it
00B41B  2               
00B41B  2  88           	dey				; decrement index
00B41C  2  10 FA        	bpl	A_B418			; loop until variable stacked
00B41E  2               
00B41E  2  A4 48        	ldy	VARPNT+1		; get current variable pointer HB
00B420  2  20 D4 BB     	jsr	PackFAC1intoXY		; pack FAC1 into (XY)		[BBD4]
00B423  2               
00B423  2  A5 7B        	lda	TXTPTR+1		; get BASIC execute pointer HB
00B425  2  48           	pha				; push it
00B426  2               
00B426  2  A5 7A        	lda	TXTPTR			; get BASIC execute pointer LB
00B428  2  48           	pha				; push it
00B429  2               
00B429  2  B1 4E        	lda	(GarbagePtr),Y		; get function execute pointer LB
00B42B  2  85 7A        	sta	TXTPTR			; save BASIC execute pointer LB
00B42D  2               
00B42D  2  C8           	iny				; index to HB
00B42E  2  B1 4E        	lda	(GarbagePtr),Y		; get function execute pointer HB
00B430  2  85 7B        	sta	TXTPTR+1		; save BASIC execute pointer HB
00B432  2               
00B432  2  A5 48        	lda	VARPNT+1		; get current variable pointer HB
00B434  2  48           	pha				; push it
00B435  2               
00B435  2  A5 47        	lda	VARPNT			; get current variable pointer LB
00B437  2  48           	pha				; push it
00B438  2               
00B438  2  20 8A AD     	jsr	EvalExpression		; evaluate expression and check is
00B43B  2               					; numeric, else do type mismatch [AD8A]
00B43B  2  68           	pla				; pull variable address LB
00B43C  2  85 4E        	sta	GarbagePtr		; save variable address LB
00B43E  2               
00B43E  2  68           	pla				; pull variable address HB
00B43F  2  85 4F        	sta	GarbagePtr+1		; save variable address HB
00B441  2               
00B441  2  20 79 00     	jsr	CHRGOT			; scan memory			[0079]
00B444  2  F0 03        	beq	A_B449			; branch if null ([EOL] marker)
00B446  2               
00B446  2  4C 08 AF     	jmp	SyntaxError		; else syntax error then warm start
00B449  2               					;				[AF08]
00B449  2               
00B449  2               ; restore BASIC execute pointer and function variable from stack
00B449  2               A_B449:					;				[B449]
00B449  2  68           	pla				; pull BASIC execute pointer LB
00B44A  2  85 7A        	sta	TXTPTR			; save BASIC execute pointer LB
00B44C  2               
00B44C  2  68           	pla				; pull BASIC execute pointer HB
00B44D  2  85 7B        	sta	TXTPTR+1		; save BASIC execute pointer HB
00B44F  2               
00B44F  2               ;******************************************************************************
00B44F  2               ;
00B44F  2               ; put execute pointer and variable pointer into function
00B44F  2               ;
00B44F  2               Ptrs2Function:				;				[B44F]
00B44F  2  A0 00        	ldy	#$00			; clear index
00B451  2  68           	pla				; pull BASIC execute pointer LB
00B452  2  91 4E        	sta	(GarbagePtr),Y		; save to function
00B454  2               
00B454  2  68           	pla				; pull BASIC execute pointer HB
00B455  2  C8           	iny				; increment index
00B456  2  91 4E        	sta	(GarbagePtr),Y		; save to function
00B458  2               
00B458  2  68           	pla				; pull current variable address LB
00B459  2  C8           	iny				; increment index
00B45A  2  91 4E        	sta	(GarbagePtr),Y		; save to function
00B45C  2               
00B45C  2  68           	pla				; pull current variable address HB
00B45D  2  C8           	iny				; increment index
00B45E  2  91 4E        	sta	(GarbagePtr),Y		; save to function
00B460  2               
00B460  2  68           	pla				; pull ??
00B461  2  C8           	iny				; increment index
00B462  2  91 4E        	sta	(GarbagePtr),Y		; save to function
00B464  2               
00B464  2  60           	rts
00B465  2               
00B465  2               
00B465  2               ;******************************************************************************
00B465  2               ;
00B465  2               ; perform STR$()
00B465  2               ;
00B465  2               bcSTR:					;				[B465]
00B465  2  20 8D AD     	jsr	CheckIfNumeric		; check if source is numeric, else do
00B468  2               					; type mismatch			[AD8D]
00B468  2  A0 00        	ldy	#$00			; set string index
00B46A  2  20 DF BD     	jsr	FAC12String		; convert FAC1 to string	[BDDF]
00B46D  2               
00B46D  2  68           	pla				; dump return address (skip type check)
00B46E  2  68           	pla				; dump return address (skip type check)
00B46F  2               bcSTR2:					;				[B46F]
00B46F  2  A9 FF        	lda	#<StrConvAddr		; set result string low pointer
00B471  2               
00B471  2  A0 00        	ldy	#>StrConvAddr		; set result string high pointer
00B473  2  F0 12        	beq	QuoteStr2UtPtr		; print null terminated string to
00B475  2               					; utility pointer
00B475  2               
00B475  2               ;******************************************************************************
00B475  2               ;
00B475  2               ; do string vector
00B475  2               ; copy descriptor pointer and make string space A bytes long
00B475  2               ;
00B475  2               StringVector:				;				[B475]
00B475  2  A6 64        	ldx	FacMantissa+2		; get descriptor pointer LB
00B477  2  A4 65        	ldy	FacMantissa+3		; get descriptor pointer HB
00B479  2  86 50        	stx	TempPtr			; save descriptor pointer LB
00B47B  2  84 51        	sty	TempPtr+1		; save descriptor pointer HB
00B47D  2               
00B47D  2               
00B47D  2               ;******************************************************************************
00B47D  2               ;
00B47D  2               ; make string space A bytes long
00B47D  2               ;
00B47D  2               StringLengthA:				;				[B47D]
00B47D  2  20 F4 B4     	jsr	CreStrAlong		; make space in string memory for string
00B480  2               					; A long			[B4F4]
00B480  2  86 62        	stx	FacMantissa		; save string pointer LB
00B482  2  84 63        	sty	FacMantissa+1		; save string pointer HB
00B484  2  85 61        	sta	FACEXP			; save length
00B486  2               
00B486  2  60           	rts
00B487  2               
00B487  2               
00B487  2               ;******************************************************************************
00B487  2               ;
00B487  2               ; scan, set up string
00B487  2               ; print " terminated string to utility pointer
00B487  2               ;
00B487  2               QuoteStr2UtPtr:				;				[B487]
00B487  2  A2 22        	ldx	#'"'			; set terminator to "
00B489  2  86 07        	stx	CHARAC			; set search character, terminator 1
00B48B  2  86 08        	stx	ENDCHR			; set terminator 2
00B48D  2               
00B48D  2               ; print search or alternate terminated string to utility pointer
00B48D  2               ; source is AY
00B48D  2               PrtStr2UtiPtr:				;				[B48D]
00B48D  2  85 6F        	sta	ARISGN			; store string start LB
00B48F  2  84 70        	sty	FACOV			; store string start HB
00B491  2  85 62        	sta	FacMantissa		; save string pointer LB
00B493  2  84 63        	sty	FacMantissa+1		; save string pointer HB
00B495  2               
00B495  2  A0 FF        	ldy	#$FF			; set length to -1
00B497  2               A_B497:					;				[B497]
00B497  2  C8           	iny				; increment length
00B498  2  B1 6F        	lda	(ARISGN),Y		; get byte from string
00B49A  2  F0 0C        	beq	A_B4A8			; exit loop if null byte [EOS]
00B49C  2               
00B49C  2  C5 07        	cmp	CHARAC			; compare with search character,
00B49E  2               					; terminator 1
00B49E  2  F0 04        	beq	A_B4A4			; branch if terminator
00B4A0  2               
00B4A0  2  C5 08        	cmp	ENDCHR			; compare with terminator 2
00B4A2  2  D0 F3        	bne	A_B497			; loop if not terminator 2
00B4A4  2               
00B4A4  2               A_B4A4:					;				[B4A4]
00B4A4  2  C9 22        	cmp	#'"'			; compare with "
00B4A6  2  F0 01        	beq	A_B4A9			; branch if " (carry set if = !)
00B4A8  2               
00B4A8  2               A_B4A8:					;				[B4A8]
00B4A8  2  18           	clc				; clear carry for add (only if [EOL]
00B4A9  2               					; terminated string)
00B4A9  2               A_B4A9:					;				[B4A9]
00B4A9  2  84 61        	sty	FACEXP			; save length in FAC1 exponent
00B4AB  2               
00B4AB  2  98           	tya				; copy length to A
00B4AC  2  65 6F        	adc	ARISGN			; add string start LB
00B4AE  2  85 71        	sta	FBUFPT			; save string end LB
00B4B0  2               
00B4B0  2  A6 70        	ldx	FACOV			; get string start HB
00B4B2  2  90 01        	bcc	A_B4B5			; branch if no LB overflow
00B4B4  2               
00B4B4  2  E8           	inx				; else increment HB
00B4B5  2               A_B4B5:					;				[B4B5]
00B4B5  2  86 72        	stx	FBUFPT+1		; save string end HB
00B4B7  2               
00B4B7  2  A5 70        	lda	FACOV			; get string start HB
00B4B9  2  F0 04        	beq	A_B4BF			; branch if in utility area
00B4BB  2               
00B4BB  2  C9 02        	cmp	#$02			; compare with input buffer memory HB
00B4BD  2  D0 0B        	bne	ChkRoomDescStk		; branch if not in input buffer memory
00B4BF  2               
00B4BF  2               ; string in input buffer or utility area, move to string memory
00B4BF  2               A_B4BF:					;				[B4BF]
00B4BF  2  98           	tya				; copy length to A
00B4C0  2  20 75 B4     	jsr	StringVector		; copy descriptor pointer and make
00B4C3  2               					; string space A bytes long	[B475]
00B4C3  2  A6 6F        	ldx	ARISGN			; get string start LB
00B4C5  2  A4 70        	ldy	FACOV			; get string start HB
00B4C7  2               S_B4C7:
00B4C7  2  20 88 B6     	jsr	Str2UtilPtr2		; store string A bytes long from XY to
00B4CA  2               					; utility pointer		[B688]
00B4CA  2               
00B4CA  2               ; check for space on descriptor stack then ...
00B4CA  2               ; put string address and length on descriptor stack and update stack pointers
00B4CA  2               ChkRoomDescStk:				;				[B4CA]
00B4CA  2  A6 16        	ldx	TEMPPT			; get the descriptor stack pointer
00B4CC  2  E0 22        	cpx	#LASTPT+2+9		; compare it with the maximum + 1
00B4CE  2  D0 05        	bne	A_B4D5			; if there is space on the string stack
00B4D0  2               					; continue
00B4D0  2               ; else do string too complex error
00B4D0  2  A2 19        	ldx	#$19			; error $19, string too complex error
00B4D2  2               A_B4D2:					;				[B4D2]
00B4D2  2  4C 37 A4     	jmp	OutputErrMsg		; do error #X then warm start	[A437]
00B4D5  2               
00B4D5  2               ; put string address and length on descriptor stack and update stack pointers
00B4D5  2               A_B4D5:					;				[B4D5]
00B4D5  2  A5 61        	lda	FACEXP			; get the string length
00B4D7  2  95 00        	sta	D6510,X			; put it on the string stack
00B4D9  2               
00B4D9  2  A5 62        	lda	FacMantissa		; get the string pointer LB
00B4DB  2  95 01        	sta	D6510+1,X		; put it on the string stack
00B4DD  2               
00B4DD  2  A5 63        	lda	FacMantissa+1		; get the string pointer HB
00B4DF  2  95 02        	sta	D6510+2,X		; put it on the string stack
00B4E1  2               
00B4E1  2  A0 00        	ldy	#$00			; clear Y
00B4E3  2  86 64        	stx	FacMantissa+2		; save the string descriptor pointer LB
00B4E5  2  84 65        	sty	FacMantissa+3		; save the string descriptor pointer HB,
00B4E7  2               					; always $00
00B4E7  2  84 70        	sty	FACOV			; clear FAC1 rounding byte
00B4E9  2               
00B4E9  2  88           	dey				; Y = $FF
00B4EA  2  84 0D        	sty	VALTYP			; save the data type flag, $FF = string
00B4EC  2  86 17        	stx	LASTPT			; save the current descriptor stack
00B4EE  2               					; item pointer LB
00B4EE  2  E8           	inx				; update the stack pointer
00B4EF  2  E8           	inx				; update the stack pointer
00B4F0  2  E8           	inx				; update the stack pointer
00B4F1  2  86 16        	stx	TEMPPT			; save the new descriptor stack pointer
00B4F3  2               
00B4F3  2  60           	rts
00B4F4  2               
00B4F4  2               
00B4F4  2               ;******************************************************************************
00B4F4  2               ;
00B4F4  2               ; make space in string memory for string A long
00B4F4  2               ; return X = pointer LB, Y = pointer HB
00B4F4  2               ;
00B4F4  2               CreStrAlong:				;				[B4F4]
00B4F4  2  46 0F        	lsr	GARBFL			; clear garbage collected flag (b7)
00B4F6  2               
00B4F6  2               ; make space for string A long
00B4F6  2               A_B4F6:					;				[B4F6]
00B4F6  2  48           	pha				; save string length
00B4F7  2               
00B4F7  2  49 FF        	eor	#$FF			; complement it
00B4F9  2  38           	sec				; set carry for subtract, two's
00B4FA  2               					; complement add
00B4FA  2  65 33        	adc	FRETOP			; add bottom of string space LB,
00B4FC  2               					; subtract length
00B4FC  2  A4 34        	ldy	FRETOP+1		; get bottom of string space HB
00B4FE  2  B0 01        	bcs	A_B501			; skip decrement if no underflow
00B500  2               
00B500  2  88           	dey				; decrement bottom of string space HB
00B501  2               A_B501:					;				[B501]
00B501  2  C4 32        	cpy	STREND+1		; compare with end of arrays HB
00B503  2  90 11        	bcc	A_B516			; do out of memory error if less
00B505  2               
00B505  2  D0 04        	bne	A_B50B			; if not = skip next test
00B507  2               
00B507  2  C5 31        	cmp	STREND			; compare with end of arrays LB
00B509  2  90 0B        	bcc	A_B516			; do out of memory error if less
00B50B  2               
00B50B  2               A_B50B:					;				[B50B]
00B50B  2  85 33        	sta	FRETOP			; save bottom of string space LB
00B50D  2  84 34        	sty	FRETOP+1		; save bottom of string space HB
00B50F  2  85 35        	sta	FRESPC			; save string utility ptr LB
00B511  2  84 36        	sty	FRESPC+1		; save string utility ptr HB
00B513  2               
00B513  2  AA           	tax				; copy LB to X
00B514  2               
00B514  2  68           	pla				; get string length back
00B515  2  60           	rts
00B516  2               
00B516  2               A_B516:					;				[B516]
00B516  2  A2 10        	ldx	#$10			; error code $10, out of memory error
00B518  2               
00B518  2  A5 0F        	lda	GARBFL			; get garbage collected flag
00B51A  2  30 B6        	bmi	A_B4D2			; if set then do error code X
00B51C  2               
00B51C  2  20 26 B5     	jsr	CollectGarbage		; else go do garbage collection	[B526]
00B51F  2               
00B51F  2  A9 80        	lda	#$80			; flag for garbage collected
00B521  2  85 0F        	sta	GARBFL			; set garbage collected flag
00B523  2               
00B523  2  68           	pla				; pull length
00B524  2  D0 D0        	bne	A_B4F6			; go try again (loop always, length
00B526  2               					; should never be = $00)
00B526  2               
00B526  2               ;******************************************************************************
00B526  2               ;
00B526  2               ; garbage collection routine
00B526  2               ;
00B526  2               CollectGarbage:				;				[B526]
00B526  2  A6 37        	ldx	MEMSIZ			; get end of memory LB
00B528  2  A5 38        	lda	MEMSIZ+1		; get end of memory HB
00B52A  2               
00B52A  2               ; re-run routine from last ending
00B52A  2               
00B52A  2               CollectGarbag2:				;				[B52A]
00B52A  2  86 33        	stx	FRETOP			; set bottom of string space LB
00B52C  2  85 34        	sta	FRETOP+1		; set bottom of string space HB
00B52E  2               
00B52E  2  A0 00        	ldy	#$00			; clear index
00B530  2  84 4F        	sty	GarbagePtr+1		; clear working pointer HB
00B532  2  84 4E        	sty	GarbagePtr		; clear working pointer LB
00B534  2               
00B534  2  A5 31        	lda	STREND			; get end of arrays LB
00B536  2  A6 32        	ldx	STREND+1		; get end of arrays HB
00B538  2  85 5F        	sta	FacTempStor+8		; save as highest uncollected string
00B53A  2               					; pointer LB
00B53A  2  86 60        	stx	FacTempStor+9		; save as highest uncollected string
00B53C  2               					; pointer HB
00B53C  2  A9 19        	lda	#LASTPT+2		; set descriptor stack pointer
00B53E  2  A2 00        	ldx	#$00			; clear X
00B540  2  85 22        	sta	INDEX			; save descriptor stack pointer LB
00B542  2  86 23        	stx	INDEX+1			; save descriptor stack pointer HB ($00)
00B544  2               A_B544:					;				[B544]
00B544  2  C5 16        	cmp	TEMPPT			; compare with descriptor stack pointer
00B546  2  F0 05        	beq	A_B54D			; branch if =
00B548  2               
00B548  2  20 C7 B5     	jsr	ChkStrSalvage		; check string salvageability	[B5C7]
00B54B  2  F0 F7        	beq	A_B544			; loop always
00B54D  2               
00B54D  2               ; done stacked strings, now do string variables
00B54D  2               A_B54D:					;				[B54D]
00B54D  2  A9 07        	lda	#$07			; set step size = $07, collecting
00B54F  2               					; variables
00B54F  2  85 53        	sta	GarbColStep		; save garbage collection step size
00B551  2               
00B551  2  A5 2D        	lda	VARTAB			; get start of variables LB
00B553  2  A6 2E        	ldx	VARTAB+1		; get start of variables HB
00B555  2  85 22        	sta	INDEX			; save as pointer LB
00B557  2  86 23        	stx	INDEX+1			; save as pointer HB
00B559  2               A_B559:					;				[B559]
00B559  2  E4 30        	cpx	ARYTAB+1		; compare end of variables HB,
00B55B  2               					; start of arrays HB
00B55B  2  D0 04        	bne	A_B561			; branch if no HB match
00B55D  2               
00B55D  2  C5 2F        	cmp	ARYTAB			; else compare end of variables LB,
00B55F  2               					; start of arrays LB
00B55F  2  F0 05        	beq	A_B566			; branch if = variable memory end
00B561  2               
00B561  2               A_B561:					;				[B561]
00B561  2  20 BD B5     	jsr	ChkVarSalvage		; check variable salvageability	[B5BD]
00B564  2  F0 F3        	beq	A_B559			; loop always
00B566  2               
00B566  2               ; done string variables, now do string arrays
00B566  2               A_B566:					;				[B566]
00B566  2  85 58        	sta	FacTempStor+1		; save start of arrays LB as working
00B568  2               					; pointer
00B568  2  86 59        	stx	FacTempStor+2		; save start of arrays HB as working
00B56A  2               					; pointer
00B56A  2               
00B56A  2  A9 03        	lda	#$03			; set step size, collecting descriptors
00B56C  2  85 53        	sta	GarbColStep		; save step size
00B56E  2               A_B56E:					;				[B56E]
00B56E  2  A5 58        	lda	FacTempStor+1		; get pointer LB
00B570  2  A6 59        	ldx	FacTempStor+2		; get pointer HB
00B572  2               A_B572:					;				[B572]
00B572  2  E4 32        	cpx	STREND+1		; compare with end of arrays HB
00B574  2  D0 07        	bne	A_B57D			; branch if not at end
00B576  2               
00B576  2  C5 31        	cmp	STREND			; else compare with end of arrays LB
00B578  2  D0 03        	bne	A_B57D			; branch if not at end
00B57A  2               
00B57A  2  4C 06 B6     	jmp	CollectString		; collect string, tidy up and exit if
00B57D  2               					; at end ??			[B606]
00B57D  2               
00B57D  2               A_B57D:					;				[B57D]
00B57D  2  85 22        	sta	INDEX			; save pointer LB
00B57F  2  86 23        	stx	INDEX+1			; save pointer HB
00B581  2               
00B581  2  A0 00        	ldy	#$00			; set index
00B583  2  B1 22        	lda	(INDEX),Y		; get array name first byte
00B585  2  AA           	tax				; copy it
00B586  2               
00B586  2  C8           	iny				; increment index
00B587  2  B1 22        	lda	(INDEX),Y		; get array name second byte
00B589  2               
00B589  2  08           	php				; push the flags
00B58A  2               
00B58A  2  C8           	iny				; increment index
00B58B  2  B1 22        	lda	(INDEX),Y		; get array size LB
00B58D  2  65 58        	adc	FacTempStor+1		; add start of this array LB
00B58F  2  85 58        	sta	FacTempStor+1		; save start of next array LB
00B591  2               
00B591  2  C8           	iny				; increment index
00B592  2  B1 22        	lda	(INDEX),Y		; get array size HB
00B594  2  65 59        	adc	FacTempStor+2		; add start of this array HB
00B596  2  85 59        	sta	FacTempStor+2		; save start of next array HB
00B598  2               
00B598  2  28           	plp				; restore the flags
00B599  2  10 D3        	bpl	A_B56E			; skip if not string array
00B59B  2               
00B59B  2               ; was possibly string array so ...
00B59B  2  8A           	txa				; get name first byte back
00B59C  2  30 D0        	bmi	A_B56E			; skip if not string array
00B59E  2               
00B59E  2  C8           	iny				; increment index
00B59F  2  B1 22        	lda	(INDEX),Y		; get # of dimensions
00B5A1  2  A0 00        	ldy	#$00			; clear index
00B5A3  2  0A           	asl				; *2
00B5A4  2  69 05        	adc	#$05			; +5 (array header size)
00B5A6  2  65 22        	adc	INDEX			; add pointer LB
00B5A8  2  85 22        	sta	INDEX			; save pointer LB
00B5AA  2  90 02        	bcc	A_B5AE			; branch if no rollover
00B5AC  2               
00B5AC  2  E6 23        	inc	INDEX+1			; else increment pointer hgih byte
00B5AE  2               A_B5AE:					;				[B5AE]
00B5AE  2  A6 23        	ldx	INDEX+1			; get pointer HB
00B5B0  2               A_B5B0:					;				[B5B0]
00B5B0  2  E4 59        	cpx	FacTempStor+2		; compare pointer HB with end of this
00B5B2  2               					; array HB
00B5B2  2  D0 04        	bne	A_B5B8			; branch if not there yet
00B5B4  2               
00B5B4  2  C5 58        	cmp	FacTempStor+1		; compare pointer LB with end of this
00B5B6  2               					; array LB
00B5B6  2  F0 BA        	beq	A_B572			; if at end of this array go check next
00B5B8  2               					; array
00B5B8  2               A_B5B8:					;				[B5B8]
00B5B8  2  20 C7 B5     	jsr	ChkStrSalvage		; check string salvageability	[B5C7]
00B5BB  2  F0 F3        	beq	A_B5B0			; loop
00B5BD  2               
00B5BD  2               ; check variable salvageability
00B5BD  2               ChkVarSalvage:				;				[B5BD]
00B5BD  2  B1 22        	lda	(INDEX),Y		; get variable name first byte
00B5BF  2  30 35        	bmi	A_B5F6			; add step and exit if not string
00B5C1  2               
00B5C1  2  C8           	iny				; increment index
00B5C2  2  B1 22        	lda	(INDEX),Y		; get variable name second byte
00B5C4  2  10 30        	bpl	A_B5F6			; add step and exit if not string
00B5C6  2               
00B5C6  2  C8           	iny				; increment index
00B5C7  2               
00B5C7  2               ; check string salvageability
00B5C7  2               ChkStrSalvage:				;				[B5C7]
00B5C7  2  B1 22        	lda	(INDEX),Y		; get string length
00B5C9  2  F0 2B        	beq	A_B5F6			; add step and exit if null string
00B5CB  2               
00B5CB  2  C8           	iny				; increment index
00B5CC  2  B1 22        	lda	(INDEX),Y		; get string pointer LB
00B5CE  2  AA           	tax				; copy to X
00B5CF  2               
00B5CF  2  C8           	iny				; increment index
00B5D0  2  B1 22        	lda	(INDEX),Y		; get string pointer HB
00B5D2  2  C5 34        	cmp	FRETOP+1		; compare string pointer HB with bottom
00B5D4  2               					; of string space HB
00B5D4  2  90 06        	bcc	A_B5DC			; if bottom of string space greater, go
00B5D6  2               					; test against highest uncollected
00B5D6  2               					; string
00B5D6  2  D0 1E        	bne	A_B5F6			; if bottom of string space less string
00B5D8  2               					; has been collected so go update
00B5D8  2               					; pointers, step to next and return
00B5D8  2               ; HBs were equal so test LBs
00B5D8  2  E4 33        	cpx	FRETOP			; compare string pointer LB with bottom
00B5DA  2               					; of string space LB
00B5DA  2  B0 1A        	bcs	A_B5F6			; if bottom of string space less string
00B5DC  2               					; has been collected so go update
00B5DC  2               					; pointers, step to next and return
00B5DC  2               ; else test string against highest uncollected string so far
00B5DC  2               A_B5DC:					;				[B5DC]
00B5DC  2  C5 60        	cmp	FacTempStor+9		; compare string pointer HB with highest
00B5DE  2               					; uncollected string HB
00B5DE  2  90 16        	bcc	A_B5F6			; if highest uncollected string is
00B5E0  2               					; greater then go update pointers, step
00B5E0  2               					; to next and return
00B5E0  2  D0 04        	bne	A_B5E6			; if highest uncollected string is less
00B5E2  2               					; then go set this string as highest
00B5E2  2               					; uncollected so far
00B5E2  2               ; HBs were equal so test LBs
00B5E2  2  E4 5F        	cpx	FacTempStor+8		; compare string pointer LB with highest
00B5E4  2               					; uncollected string LB
00B5E4  2  90 10        	bcc	A_B5F6			; if highest uncollected string is
00B5E6  2               					; greater then go update pointers, step
00B5E6  2               					; to next and return
00B5E6  2               ; else set current string as highest uncollected string
00B5E6  2               A_B5E6:					;				[B5E6]
00B5E6  2  86 5F        	stx	FacTempStor+8		; save string pointer LB as highest
00B5E8  2               					; uncollected string LB
00B5E8  2  85 60        	sta	FacTempStor+9		; save string pointer HB as highest
00B5EA  2               					; uncollected string HB
00B5EA  2  A5 22        	lda	INDEX			; get descriptor pointer LB
00B5EC  2  A6 23        	ldx	INDEX+1			; get descriptor pointer HB
00B5EE  2  85 4E        	sta	GarbagePtr		; save working pointer HB
00B5F0  2  86 4F        	stx	GarbagePtr+1		; save working pointer LB
00B5F2  2               
00B5F2  2  A5 53        	lda	GarbColStep		; get step size
00B5F4  2  85 55        	sta	Jump0054+1		; copy step size
00B5F6  2               A_B5F6:					;				[B5F6]
00B5F6  2  A5 53        	lda	GarbColStep		; get step size
00B5F8  2  18           	clc				; clear carry for add
00B5F9  2  65 22        	adc	INDEX			; add pointer LB
00B5FB  2  85 22        	sta	INDEX			; save pointer LB
00B5FD  2  90 02        	bcc	A_B601			; branch if no rollover
00B5FF  2               
00B5FF  2  E6 23        	inc	INDEX+1			; else increment pointer HB
00B601  2               A_B601:					;				[B601]
00B601  2  A6 23        	ldx	INDEX+1			; get pointer HB
00B603  2  A0 00        	ldy	#$00			; flag not moved
00B605  2  60           	rts
00B606  2               
00B606  2               ; collect string
00B606  2               CollectString:				;				[B606]
00B606  2  A5 4F        	lda	GarbagePtr+1		; get working pointer LB
00B608  2  05 4E        	ora	GarbagePtr		; OR working pointer HB
00B60A  2  F0 F5        	beq	A_B601			; exit if nothing to collect
00B60C  2               
00B60C  2  A5 55        	lda	Jump0054+1		; get copied step size
00B60E  2  29 04        	and	#$04			; mask step size, $04 for variables,
00B610  2               					; $00 for array or stack
00B610  2  4A           	lsr				; >> 1
00B611  2  A8           	tay				; copy to index
00B612  2  85 55        	sta	Jump0054+1		; save offset to descriptor start
00B614  2               
00B614  2  B1 4E        	lda	(GarbagePtr),Y		; get string length LB
00B616  2  65 5F        	adc	FacTempStor+8		; add string start LB
00B618  2  85 5A        	sta	FacTempStor+3		; set block end LB
00B61A  2               
00B61A  2  A5 60        	lda	FacTempStor+9		; get string start HB
00B61C  2  69 00        	adc	#$00			; add carry
00B61E  2  85 5B        	sta	FacTempStor+4		; set block end HB
00B620  2               
00B620  2  A5 33        	lda	FRETOP			; get bottom of string space LB
00B622  2  A6 34        	ldx	FRETOP+1		; get bottom of string space HB
00B624  2  85 58        	sta	FacTempStor+1		; save destination end LB
00B626  2  86 59        	stx	FacTempStor+2		; save destination end HB
00B628  2               
00B628  2  20 BF A3     	jsr	MoveBlock2		; open up space in memory, don't set
00B62B  2               					; array end. this copies the string from
00B62B  2               					; where it is to the end of the
00B62B  2               					; uncollected string memory	[A3BF]
00B62B  2  A4 55        	ldy	Jump0054+1		; restore offset to descriptor start
00B62D  2  C8           	iny				; increment index to string pointer LB
00B62E  2  A5 58        	lda	FacTempStor+1		; get new string pointer LB
00B630  2  91 4E        	sta	(GarbagePtr),Y		; save new string pointer LB
00B632  2  AA           	tax				; copy string pointer LB
00B633  2               
00B633  2  E6 59        	inc	FacTempStor+2		; increment new string pointer HB
00B635  2               
00B635  2  A5 59        	lda	FacTempStor+2		; get new string pointer HB
00B637  2  C8           	iny				; increment index to string pointer HB
00B638  2  91 4E        	sta	(GarbagePtr),Y		; save new string pointer HB
00B63A  2               
00B63A  2  4C 2A B5     	jmp	CollectGarbag2		; re-run routine from last ending, XA
00B63D  2               					; holds new bottom		[B52A]
00B63D  2               					; of string memory pointer
00B63D  2               
00B63D  2               
00B63D  2               ;******************************************************************************
00B63D  2               ;
00B63D  2               ; concatenate = add strings, the first string is in the descriptor, the second
00B63D  2               ; string is in the line
00B63D  2               ;
00B63D  2               ConcatStrings:				;				[B63D]
00B63D  2  A5 65        	lda	FacMantissa+3		; get descriptor pointer HB
00B63F  2  48           	pha				; put on stack
00B640  2               
00B640  2  A5 64        	lda	FacMantissa+2		; get descriptor pointer LB
00B642  2  48           	pha				; put on stack
00B643  2               
00B643  2  20 83 AE     	jsr	GetNextParm		; get value from line		[AE83]
00B646  2  20 8F AD     	jsr	CheckIfString		; check if source is string, else do
00B649  2               					; type mismatch			[AD8F]
00B649  2  68           	pla				; get descriptor pointer LB back
00B64A  2  85 6F        	sta	ARISGN			; set pointer LB
00B64C  2               
00B64C  2  68           	pla				; get descriptor pointer HB back
00B64D  2  85 70        	sta	FACOV			; set pointer HB
00B64F  2               
00B64F  2  A0 00        	ldy	#$00			; clear index
00B651  2  B1 6F        	lda	(ARISGN),Y		; get length of first string from
00B653  2               					; descriptor
00B653  2  18           	clc				; clear carry for add
00B654  2  71 64        	adc	(FacMantissa+2),Y	; add length of second string
00B656  2  90 05        	bcc	A_B65D			; branch if no overflow
00B658  2               
00B658  2  A2 17        	ldx	#$17			; else error $17, string too long error
00B65A  2  4C 37 A4     	jmp	OutputErrMsg		; do error #X then warm start	[A437]
00B65D  2               
00B65D  2               A_B65D:					;				[B65D]
00B65D  2  20 75 B4     	jsr	StringVector		; copy descriptor pointer and make
00B660  2               					; string space A bytes long	[B475]
00B660  2  20 7A B6     	jsr	Str2UtilPtr		; copy string from descriptor to utility
00B663  2               					; pointer			[B67A]
00B663  2               
00B663  2  A5 50        	lda	TempPtr			; get descriptor pointer LB
00B665  2  A4 51        	ldy	TempPtr+1		; get descriptor pointer HB
00B667  2  20 AA B6     	jsr	PopStrDescStk2		; pop (YA) descriptor off stack or from
00B66A  2               					; top of string space returns with
00B66A  2               					; A = length, X = pointer LB,
00B66A  2               					; Y = pointer HB		[B6AA]
00B66A  2  20 8C B6     	jsr	Str2UtilPtr3		; store string from pointer to utility
00B66D  2               					; pointer			[B68C]
00B66D  2  A5 6F        	lda	ARISGN			; get descriptor pointer LB
00B66F  2  A4 70        	ldy	FACOV			; get descriptor pointer HB
00B671  2  20 AA B6     	jsr	PopStrDescStk2		; pop (YA) descriptor off stack or from
00B674  2               					; top of string space returns with
00B674  2               					; A = length, X = pointer LB,
00B674  2               					; Y = pointer HB		[B6AA]
00B674  2  20 CA B4     	jsr	ChkRoomDescStk		; check space on descriptor stack then
00B677  2               					; put string address and length on
00B677  2               					; descriptor stack and update stack
00B677  2               					; pointers			[B4CA]
00B677  2  4C B8 AD     	jmp	EvaluateValue3		; continue evaluation		[ADB8]
00B67A  2               
00B67A  2               
00B67A  2               ;******************************************************************************
00B67A  2               ;
00B67A  2               ; copy string from descriptor to utility pointer
00B67A  2               ;
00B67A  2               Str2UtilPtr:				;				[B67A]
00B67A  2  A0 00        	ldy	#$00			; clear index
00B67C  2  B1 6F        	lda	(ARISGN),Y		; get string length
00B67E  2  48           	pha				; save it
00B67F  2               
00B67F  2  C8           	iny				; increment index
00B680  2  B1 6F        	lda	(ARISGN),Y		; get string pointer LB
00B682  2  AA           	tax				; copy to X
00B683  2               
00B683  2  C8           	iny				; increment index
00B684  2  B1 6F        	lda	(ARISGN),Y		; get string pointer HB
00B686  2  A8           	tay				; copy to Y
00B687  2               
00B687  2  68           	pla				; get length back
00B688  2               Str2UtilPtr2:				;				[B688]
00B688  2  86 22        	stx	INDEX			; save string pointer LB
00B68A  2  84 23        	sty	INDEX+1			; save string pointer HB
00B68C  2               
00B68C  2               ; store string from pointer to utility pointer
00B68C  2               Str2UtilPtr3:				;				[B68C]
00B68C  2  A8           	tay				; copy length as index
00B68D  2  F0 0A        	beq	A_B699			; branch if null string
00B68F  2               
00B68F  2  48           	pha				; save length
00B690  2               A_B690:					;				[B690]
00B690  2  88           	dey				; decrement length/index
00B691  2  B1 22        	lda	(INDEX),Y		; get byte from string
00B693  2  91 35        	sta	(FRESPC),Y		; save byte to destination
00B695  2               
00B695  2  98           	tya				; copy length/index
00B696  2  D0 F8        	bne	A_B690			; loop if not all done yet
00B698  2               
00B698  2  68           	pla				; restore length
00B699  2               A_B699:					;				[B699]
00B699  2  18           	clc				; clear carry for add
00B69A  2  65 35        	adc	FRESPC			; add string utility ptr LB
00B69C  2  85 35        	sta	FRESPC			; save string utility ptr LB
00B69E  2  90 02        	bcc	A_B6A2			; branch if no rollover
00B6A0  2               
00B6A0  2  E6 36        	inc	FRESPC+1		; increment string utility ptr HB
00B6A2  2               A_B6A2:					;				[B6A2]
00B6A2  2  60           	rts
00B6A3  2               
00B6A3  2               
00B6A3  2               ;******************************************************************************
00B6A3  2               ;
00B6A3  2               ; evaluate string
00B6A3  2               ;
00B6A3  2               EvalString:				;				[B6A3]
00B6A3  2  20 8F AD     	jsr	CheckIfString		; check if source is string, else do
00B6A6  2               					; type mismatch			[AD8F]
00B6A6  2               
00B6A6  2               ; pop string off descriptor stack, or from top of string space
00B6A6  2               ; returns with A = length, X = pointer LB, Y = pointer HB
00B6A6  2               PopStrDescStk:				;				[B6A6]
00B6A6  2  A5 64        	lda	FacMantissa+2		; get descriptor pointer LB
00B6A8  2  A4 65        	ldy	FacMantissa+3		; get descriptor pointer HB
00B6AA  2               
00B6AA  2               ; pop (YA) descriptor off stack or from top of string space
00B6AA  2               ; returns with A = length, X = pointer LB, Y = pointer HB
00B6AA  2               PopStrDescStk2:				;				[B6AA]
00B6AA  2  85 22        	sta	INDEX			; save string pointer LB
00B6AC  2  84 23        	sty	INDEX+1			; save string pointer HB
00B6AE  2               
00B6AE  2  20 DB B6     	jsr	ClrDescrStack		; clean descriptor stack, YA = pointer
00B6B1  2               					;				[B6DB]
00B6B1  2  08           	php				; save status flags
00B6B2  2               
00B6B2  2  A0 00        	ldy	#$00			; clear index
00B6B4  2  B1 22        	lda	(INDEX),Y		; get length from string descriptor
00B6B6  2  48           	pha				; put on stack
00B6B7  2               
00B6B7  2  C8           	iny				; increment index
00B6B8  2  B1 22        	lda	(INDEX),Y		; get string pointer LB from descriptor
00B6BA  2  AA           	tax				; copy to X
00B6BB  2               
00B6BB  2  C8           	iny				; increment index
00B6BC  2  B1 22        	lda	(INDEX),Y		; get string pointer HB from descriptor
00B6BE  2  A8           	tay				; copy to Y
00B6BF  2               
00B6BF  2  68           	pla				; get string length back
00B6C0  2               
00B6C0  2  28           	plp				; restore status
00B6C1  2  D0 13        	bne	A_B6D6			; branch if pointer <> last_sl,last_sh
00B6C3  2               
00B6C3  2  C4 34        	cpy	FRETOP+1		; compare with bottom of string space HB
00B6C5  2  D0 0F        	bne	A_B6D6			; branch if <>
00B6C7  2               
00B6C7  2  E4 33        	cpx	FRETOP			; else compare with bottom of string
00B6C9  2               					; space LB
00B6C9  2  D0 0B        	bne	A_B6D6			; branch if <>
00B6CB  2               
00B6CB  2  48           	pha				; save string length
00B6CC  2               
00B6CC  2  18           	clc				; clear carry for add
00B6CD  2  65 33        	adc	FRETOP			; add bottom of string space LB
00B6CF  2  85 33        	sta	FRETOP			; set bottom of string space LB
00B6D1  2  90 02        	bcc	A_B6D5			; skip increment if no overflow
00B6D3  2               
00B6D3  2  E6 34        	inc	FRETOP+1		; increment bottom of string space HB
00B6D5  2               A_B6D5:					;				[B6D5]
00B6D5  2  68           	pla				; restore string length
00B6D6  2               A_B6D6:					;				[B6D6]
00B6D6  2  86 22        	stx	INDEX			; save string pointer LB
00B6D8  2  84 23        	sty	INDEX+1			; save string pointer HB
00B6DA  2               
00B6DA  2  60           	rts
00B6DB  2               
00B6DB  2               ; clean descriptor stack, YA = pointer
00B6DB  2               ; checks if AY is on the descriptor stack, if so does a stack discard
00B6DB  2               ClrDescrStack:				;				[B6DB]
00B6DB  2  C4 18        	cpy	LASTPT+1		; compare HB with current descriptor
00B6DD  2               					; stack item pointer HB
00B6DD  2  D0 0C        	bne	A_B6EB			; exit if <>
00B6DF  2               
00B6DF  2  C5 17        	cmp	LASTPT			; compare LB with current descriptor
00B6E1  2               					; stack item pointer LB
00B6E1  2  D0 08        	bne	A_B6EB			; exit if <>
00B6E3  2               
00B6E3  2  85 16        	sta	TEMPPT			; set descriptor stack pointer
00B6E5  2  E9 03        	sbc	#$03			; update last string pointer LB
00B6E7  2  85 17        	sta	LASTPT			; save current descriptor stack item
00B6E9  2               					; pointer LB
00B6E9  2  A0 00        	ldy	#$00			; clear HB
00B6EB  2               A_B6EB:					;				[B6EB]
00B6EB  2  60           	rts
00B6EC  2               
00B6EC  2               
00B6EC  2               ;******************************************************************************
00B6EC  2               ;
00B6EC  2               ; perform CHR$()
00B6EC  2               ;
00B6EC  2               bcCHR:					;				[B6EC]
00B6EC  2  20 A1 B7     	jsr	EvalByteExpr		; evaluate byte expression, result in X
00B6EF  2               					;				[B7A1]
00B6EF  2  8A           	txa				; copy to A
00B6F0  2  48           	pha				; save character
00B6F1  2               
00B6F1  2  A9 01        	lda	#$01			; string is single byte
00B6F3  2  20 7D B4     	jsr	StringLengthA		; make string space A bytes long [B47D]
00B6F6  2               
00B6F6  2  68           	pla				; get character back
00B6F7  2  A0 00        	ldy	#$00			; clear index
00B6F9  2  91 62        	sta	(FacMantissa),Y		; save byte in string - byte IS string!
00B6FB  2               
00B6FB  2  68           	pla				; dump return address (skip type check)
00B6FC  2  68           	pla				; dump return address (skip type check)
00B6FD  2               
00B6FD  2  4C CA B4     	jmp	ChkRoomDescStk		; check space on descriptor stack then
00B700  2               					; put string address and length on
00B700  2               					; descriptor stack and update stack
00B700  2               					; pointers			[B4CA]
00B700  2               
00B700  2               ;******************************************************************************
00B700  2               ;
00B700  2               ; perform LEFT$()
00B700  2               ;
00B700  2               bcLEFT:					;				[B700]
00B700  2  20 61 B7     	jsr	PullStrFromStk		; pull string data and byte parameter
00B703  2               					; from stack return pointer in
00B703  2               					; descriptor, byte in A (and X), Y=0
00B703  2               					;				[B761]
00B703  2  D1 50        	cmp	(TempPtr),Y		; compare byte parameter with string
00B705  2               					; length
00B705  2  98           	tya				; clear A
00B706  2               bcLEFT2:				;				[B706]
00B706  2  90 04        	bcc	A_B70C			; branch if string length > byte param
00B708  2               
00B708  2  B1 50        	lda	(TempPtr),Y		; else make parameter = length
00B70A  2  AA           	tax				; copy to byte parameter copy
00B70B  2               
00B70B  2  98           	tya				; clear string start offset
00B70C  2               A_B70C:					;				[B70C]
00B70C  2  48           	pha				; save string start offset
00B70D  2               A_B70D:					;				[B70D]
00B70D  2  8A           	txa				; copy byte parameter (or string length
00B70E  2               					; if <)
00B70E  2               A_B70E:					;				[B70E]
00B70E  2  48           	pha				; save string length
00B70F  2               
00B70F  2  20 7D B4     	jsr	StringLengthA		; make string space A bytes long [B47D]
00B712  2               
00B712  2  A5 50        	lda	TempPtr			; get descriptor pointer LB
00B714  2  A4 51        	ldy	TempPtr+1		; get descriptor pointer HB
00B716  2  20 AA B6     	jsr	PopStrDescStk2		; pop (YA) descriptor off stack or from
00B719  2               					; top of string space returns with
00B719  2               					; A = length, X = pointer LB,
00B719  2               					; Y = pointer HB		[B6AA]
00B719  2  68           	pla				; get string length back
00B71A  2  A8           	tay				; copy length to Y
00B71B  2               
00B71B  2  68           	pla				; get string start offset back
00B71C  2  18           	clc				; clear carry for add
00B71D  2  65 22        	adc	INDEX			; add start offset to string start
00B71F  2               					; pointer LB
00B71F  2  85 22        	sta	INDEX			; save string start pointer LB
00B721  2  90 02        	bcc	A_B725			; branch if no overflow
00B723  2               
00B723  2  E6 23        	inc	INDEX+1			; else increment string start pointer HB
00B725  2               A_B725:					;				[B725]
00B725  2  98           	tya				; copy length to A
00B726  2  20 8C B6     	jsr	Str2UtilPtr3		; store string from pointer to utility
00B729  2               					; pointer			[B68C]
00B729  2               
00B729  2  4C CA B4     	jmp	ChkRoomDescStk		; check space on descriptor stack then
00B72C  2               					; put string address and length on
00B72C  2               					; descriptor stack and update stack
00B72C  2               					; pointers			[B4CA]
00B72C  2               
00B72C  2               ;******************************************************************************
00B72C  2               ;
00B72C  2               ; perform RIGHT$()
00B72C  2               ;
00B72C  2               bcRIGHT:				;				[B72C]
00B72C  2  20 61 B7     	jsr	PullStrFromStk		; pull string data and byte parameter
00B72F  2               					; from stack return pointer in
00B72F  2               					; descriptor, byte in A (and X), Y=0
00B72F  2               					;				[B761]
00B72F  2  18           	clc				; clear carry for add-1
00B730  2  F1 50        	sbc	(TempPtr),Y		; subtract string length
00B732  2  49 FF        	eor	#$FF			; invert it (A=LEN(expression$)-l)
00B734  2  4C 06 B7     	jmp	bcLEFT2			; go do rest of LEFT$()		[B706]
00B737  2               
00B737  2               
00B737  2               ;******************************************************************************
00B737  2               ;
00B737  2               ; perform MID$()
00B737  2               ;
00B737  2               bcMID:					;				[B737]
00B737  2  A9 FF        	lda	#$FF			; set default length = 255
00B739  2  85 65        	sta	FacMantissa+3		; save default length
00B73B  2               
00B73B  2  20 79 00     	jsr	CHRGOT			; scan memory			[0079]
00B73E  2  C9 29        	cmp	#')'			; compare with ")"
00B740  2  F0 06        	beq	A_B748			; branch if = ")" (skip second byte get)
00B742  2               
00B742  2  20 FD AE     	jsr	Chk4Comma		; scan for ",", else do syntax error
00B745  2               					; then warm start		[AEFD]
00B745  2  20 9E B7     	jsr	GetByteParm2		; get byte parameter		[B79E]
00B748  2               A_B748:					;				[B748]
00B748  2  20 61 B7     	jsr	PullStrFromStk		; pull string data and byte parameter
00B74B  2               					; from stack return pointer in
00B74B  2               					; descriptor, byte in A (and X), Y=0
00B74B  2               					;				[B761]
00B74B  2  F0 4B        	beq	A_B798			; if null do illegal quantity error then
00B74D  2               					; warm start
00B74D  2  CA           	dex				; decrement start index
00B74E  2  8A           	txa				; copy to A
00B74F  2  48           	pha				; save string start offset
00B750  2               
00B750  2  18           	clc				; clear carry for sub-1
00B751  2  A2 00        	ldx	#$00			; clear output string length
00B753  2  F1 50        	sbc	(TempPtr),Y		; subtract string length
00B755  2  B0 B6        	bcs	A_B70D			; if start>string length go do null
00B757  2               					; string
00B757  2  49 FF        	eor	#$FF			; complement -length
00B759  2  C5 65        	cmp	FacMantissa+3		; compare byte parameter
00B75B  2  90 B1        	bcc	A_B70E			; if length > remaining string go do
00B75D  2               					; RIGHT$
00B75D  2  A5 65        	lda	FacMantissa+3		; get length byte
00B75F  2  B0 AD        	bcs	A_B70E			; go do string copy, branch always
00B761  2               
00B761  2               
00B761  2               ;******************************************************************************
00B761  2               ;
00B761  2               ; pull string data and byte parameter from stack
00B761  2               ; return pointer in descriptor, byte in A (and X), Y=0
00B761  2               ;
00B761  2               PullStrFromStk:				;				[B761]
00B761  2  20 F7 AE     	jsr	Chk4CloseParen		; scan for ")", else do syntax error
00B764  2               					; then warm start		[AEF7]
00B764  2  68           	pla				; pull return address LB
00B765  2  A8           	tay				; save return address LB
00B766  2               
00B766  2  68           	pla				; pull return address HB
00B767  2  85 55        	sta	Jump0054+1		; save return address HB
00B769  2               
00B769  2  68           	pla				; dump call to function vector LB
00B76A  2  68           	pla				; dump call to function vector HB
00B76B  2               
00B76B  2  68           	pla				; pull byte parameter
00B76C  2  AA           	tax				; copy byte parameter to X
00B76D  2               
00B76D  2  68           	pla				; pull string pointer LB
00B76E  2  85 50        	sta	TempPtr			; save it
00B770  2               
00B770  2  68           	pla				; pull string pointer HB
00B771  2  85 51        	sta	TempPtr+1		; save it
00B773  2               
00B773  2  A5 55        	lda	Jump0054+1		; get return address HB
00B775  2  48           	pha				; back on stack
00B776  2               
00B776  2  98           	tya				; get return address LB
00B777  2  48           	pha				; back on stack
00B778  2               
00B778  2  A0 00        	ldy	#$00			; clear index
00B77A  2  8A           	txa				; copy byte parameter
00B77B  2               
00B77B  2  60           	rts
00B77C  2               
00B77C  2               
00B77C  2               ;******************************************************************************
00B77C  2               ;
00B77C  2               ; perform LEN()
00B77C  2               ;
00B77C  2               bcLEN:					;				[B77C]
00B77C  2  20 82 B7     	jsr	GetLengthStr		; evaluate string, get length in A
00B77F  2               					; (and Y)			[B782]
00B77F  2  4C A2 B3     	jmp	bcPOS2			; convert Y to byte in FAC1 and return
00B782  2               					;				[B3A2]
00B782  2               
00B782  2               ;******************************************************************************
00B782  2               ;
00B782  2               ; evaluate string, get length in Y
00B782  2               ;
00B782  2               GetLengthStr:				;				[B782]
00B782  2  20 A3 B6     	jsr	EvalString		; evaluate string		[B6A3]
00B785  2               
00B785  2  A2 00        	ldx	#$00			; set data type = numeric
00B787  2  86 0D        	stx	VALTYP			; clear data type flag, $FF = string,
00B789  2               					; $00 = numeric
00B789  2  A8           	tay				; copy length to Y
00B78A  2               
00B78A  2  60           	rts
00B78B  2               
00B78B  2               
00B78B  2               ;******************************************************************************
00B78B  2               ;
00B78B  2               ; perform ASC()
00B78B  2               ;
00B78B  2               bcASC:					;				[B78B]
00B78B  2  20 82 B7     	jsr	GetLengthStr		; evaluate string, get length in A
00B78E  2               					; (and Y)			[B782]
00B78E  2  F0 08        	beq	A_B798			; if null do illegal quantity error then
00B790  2               					; warm start
00B790  2  A0 00        	ldy	#$00			; set index to first character
00B792  2  B1 22        	lda	(INDEX),Y		; get byte
00B794  2  A8           	tay				; copy to Y
00B795  2               
00B795  2  4C A2 B3     	jmp	bcPOS2			; convert Y to byte in FAC1 and return
00B798  2               					;				[B3A2]
00B798  2               
00B798  2               ;******************************************************************************
00B798  2               ;
00B798  2               ; do illegal quantity error then warm start
00B798  2               ;
00B798  2               A_B798:					;				[B798]
00B798  2  4C 48 B2     	jmp	IllegalQuant		; do illegal quantity error then warm
00B79B  2               					; start				[B248]
00B79B  2               
00B79B  2               ;******************************************************************************
00B79B  2               ;
00B79B  2               ; scan and get byte parameter
00B79B  2               ;
00B79B  2               GetByteParm:				;				[B79B]
00B79B  2  20 73 00     	jsr	CHRGET			; increment and scan memory	[0073]
00B79E  2               
00B79E  2               
00B79E  2               ;******************************************************************************
00B79E  2               ;
00B79E  2               ; get byte parameter
00B79E  2               ;
00B79E  2               GetByteParm2:				;				[B79E]
00B79E  2  20 8A AD     	jsr	EvalExpression		; evaluate expression and check is
00B7A1  2               					; numeric, else do type mismatch [AD8A]
00B7A1  2               
00B7A1  2               ;******************************************************************************
00B7A1  2               ;
00B7A1  2               ; evaluate byte expression, result in X
00B7A1  2               ;
00B7A1  2               EvalByteExpr:				;				[B7A1]
00B7A1  2  20 B8 B1     	jsr	EvalInteger2		; evaluate integer expression, sign
00B7A4  2               					; check				[B1B8]
00B7A4  2  A6 64        	ldx	FacMantissa+2		; get FAC1 mantissa 3
00B7A6  2  D0 F0        	bne	A_B798			; if not null do illegal quantity error
00B7A8  2               					; then warm start
00B7A8  2  A6 65        	ldx	FacMantissa+3		; get FAC1 mantissa 4
00B7AA  2  4C 79 00     	jmp	CHRGOT			; scan memory and return	[0079]
00B7AD  2               
00B7AD  2               
00B7AD  2               ;******************************************************************************
00B7AD  2               ;
00B7AD  2               ; perform VAL()
00B7AD  2               ;
00B7AD  2               bcVAL:					;				[B7AD]
00B7AD  2  20 82 B7     	jsr	GetLengthStr		; evaluate string, get length in A
00B7B0  2               					; (and Y)			[B782]
00B7B0  2  D0 03        	bne	A_B7B5			; branch if not null string
00B7B2  2               
00B7B2  2               ; string was null so set result = $00
00B7B2  2  4C F7 B8     	jmp	ClrFAC1ExpSgn		; clear FAC1 exponent and sign and
00B7B5  2               					; return			[B8F7]
00B7B5  2               A_B7B5:					;				[B7B5]
00B7B5  2  A6 7A        	ldx	TXTPTR			; get BASIC execute pointer LB
00B7B7  2  A4 7B        	ldy	TXTPTR+1		; get BASIC execute pointer HB
00B7B9  2  86 71        	stx	FBUFPT			; save BASIC execute pointer LB
00B7BB  2  84 72        	sty	FBUFPT+1		; save BASIC execute pointer HB
00B7BD  2               
00B7BD  2  A6 22        	ldx	INDEX			; get string pointer LB
00B7BF  2  86 7A        	stx	TXTPTR			; save BASIC execute pointer LB
00B7C1  2               
00B7C1  2  18           	clc				; clear carry for add
00B7C2  2  65 22        	adc	INDEX			; add string length
00B7C4  2  85 24        	sta	INDEX+2			; save string end LB
00B7C6  2               
00B7C6  2  A6 23        	ldx	INDEX+1			; get string pointer HB
00B7C8  2  86 7B        	stx	TXTPTR+1		; save BASIC execute pointer HB
00B7CA  2  90 01        	bcc	A_B7CD			; branch if no HB increment
00B7CC  2               
00B7CC  2  E8           	inx				; increment string end HB
00B7CD  2               A_B7CD:					;				[B7CD]
00B7CD  2  86 25        	stx	INDEX+3			; save string end HB
00B7CF  2               
00B7CF  2  A0 00        	ldy	#$00			; set index to $00
00B7D1  2  B1 24        	lda	(INDEX+2),Y		; get string end byte
00B7D3  2  48           	pha				; push it
00B7D4  2               
00B7D4  2  98           	tya				; clear A
00B7D5  2  91 24        	sta	(INDEX+2),Y		; terminate string with $00
00B7D7  2               
00B7D7  2  20 79 00     	jsr	CHRGOT			; scan memory			[0079]
00B7DA  2  20 F3 BC     	jsr	String2FAC1		; get FAC1 from string		[BCF3]
00B7DD  2               
00B7DD  2  68           	pla				; restore string end byte
00B7DE  2  A0 00        	ldy	#$00			; clear index
00B7E0  2  91 24        	sta	(INDEX+2),Y		; put string end byte back
00B7E2  2               
00B7E2  2               
00B7E2  2               ;******************************************************************************
00B7E2  2               ;
00B7E2  2               ; restore BASIC execute pointer from temp
00B7E2  2               ;
00B7E2  2               RestBasExecPtr:				;				[B7E2]
00B7E2  2  A6 71        	ldx	FBUFPT			; get BASIC execute pointer LB back
00B7E4  2  A4 72        	ldy	FBUFPT+1		; get BASIC execute pointer HB back
00B7E6  2  86 7A        	stx	TXTPTR			; save BASIC execute pointer LB
00B7E8  2  84 7B        	sty	TXTPTR+1		; save BASIC execute pointer HB
00B7EA  2               
00B7EA  2  60           	rts
00B7EB  2               
00B7EB  2               
00B7EB  2               ;******************************************************************************
00B7EB  2               ;
00B7EB  2               ; get parameters for POKE/WAIT
00B7EB  2               ;
00B7EB  2               GetParms:				;				[B7EB]
00B7EB  2  20 8A AD     	jsr	EvalExpression		; evaluate expression and check is
00B7EE  2               					; numeric, else do type mismatch [AD8A]
00B7EE  2  20 F7 B7     	jsr	FAC1toTmpInt		; convert FAC_1 to integer in temporary
00B7F1  2               					; integer			[B7F7]
00B7F1  2               GetParms2:				;				[B7F1]
00B7F1  2  20 FD AE     	jsr	Chk4Comma		; scan for ",", else do syntax error
00B7F4  2               					; then warm start		[AEFD]
00B7F4  2  4C 9E B7     	jmp	GetByteParm2		; get byte parameter and return	[B79E]
00B7F7  2               
00B7F7  2               
00B7F7  2               ;******************************************************************************
00B7F7  2               ;
00B7F7  2               ; convert FAC_1 to integer in temporary integer
00B7F7  2               ;
00B7F7  2               FAC1toTmpInt:				;				[B7F7]
00B7F7  2  A5 66        	lda	FACSGN			; get FAC1 sign
00B7F9  2  30 9D        	bmi	A_B798			; if -ve do illegal quantity error then
00B7FB  2               					; warm start
00B7FB  2  A5 61        	lda	FACEXP			; get FAC1 exponent
00B7FD  2  C9 91        	cmp	#$91			; compare with exponent = 2^16
00B7FF  2  B0 97        	bcs	A_B798			; if >= do illegal quantity error then
00B801  2               					; warm start
00B801  2  20 9B BC     	jsr	FAC1Float2Fix		; convert FAC1 floating to fixed [BC9B]
00B804  2               
00B804  2  A5 64        	lda	FacMantissa+2		; get FAC1 mantissa 3
00B806  2  A4 65        	ldy	FacMantissa+3		; get FAC1 mantissa 4
00B808  2  84 14        	sty	LINNUM			; save temporary integer LB
00B80A  2  85 15        	sta	LINNUM+1		; save temporary integer HB
00B80C  2               
00B80C  2  60           	rts
00B80D  2               
00B80D  2               
00B80D  2               ;******************************************************************************
00B80D  2               ;
00B80D  2               ; perform PEEK()
00B80D  2               ;
00B80D  2               bcPEEK:					;				[B80D]
00B80D  2  A5 15        	lda	LINNUM+1		; get line number HB
00B80F  2  48           	pha				; save line number HB
00B810  2               
00B810  2  A5 14        	lda	LINNUM			; get line number LB
00B812  2  48           	pha				; save line number LB
00B813  2               
00B813  2  20 F7 B7     	jsr	FAC1toTmpInt		; convert FAC_1 to integer in temporary
00B816  2               					; integer			[B7F7]
00B816  2  A0 00        	ldy	#$00			; clear index
00B818  2  B1 14        	lda	(LINNUM),Y		; read byte
00B81A  2  A8           	tay				; copy byte to A
00B81B  2               
00B81B  2  68           	pla				; pull byte
00B81C  2  85 14        	sta	LINNUM			; restore line number LB
00B81E  2               
00B81E  2  68           	pla				; pull byte
00B81F  2  85 15        	sta	LINNUM+1		; restore line number HB
00B821  2               
00B821  2  4C A2 B3     	jmp	bcPOS2			; convert Y to byte in FAC_1 and return
00B824  2               					;				[B3A2]
00B824  2               
00B824  2               ;******************************************************************************
00B824  2               ;
00B824  2               ; perform POKE
00B824  2               ;
00B824  2               bcPOKE:					;				[B824]
00B824  2  20 EB B7     	jsr	GetParms		; get parameters for POKE/WAIT	[B7EB]
00B827  2  8A           	txa				; copy byte to A
00B828  2  A0 00        	ldy	#$00			; clear index
00B82A  2  91 14        	sta	(LINNUM),Y		; write byte
00B82C  2  60           	rts
00B82D  2               
00B82D  2               
00B82D  2               ;******************************************************************************
00B82D  2               ;
00B82D  2               ; perform WAIT
00B82D  2               ;
00B82D  2               bcWAIT:					;				[B82D]
00B82D  2  20 EB B7     	jsr	GetParms		; get parameters for POKE/WAIT	[B7EB]
00B830  2  86 49        	stx	FORPNT			; save byte
00B832  2               
00B832  2  A2 00        	ldx	#$00			; clear mask
00B834  2  20 79 00     	jsr	CHRGOT			; scan memory			[0079]
00B837  2  F0 03        	beq	A_B83C			; skip if no third argument
00B839  2               
00B839  2  20 F1 B7     	jsr	GetParms2		; scan for "," and get byte, else syntax
00B83C  2               					; error then warm start	[B7F1]
00B83C  2               A_B83C:					;				[B83C]
00B83C  2  86 4A        	stx	FORPNT+1		; save EOR argument
00B83E  2               
00B83E  2  A0 00        	ldy	#$00			; clear index
00B840  2               A_B840:					;				[B840]
00B840  2  B1 14        	lda	(LINNUM),Y		; get byte via temporary integer
00B842  2  45 4A        	eor	FORPNT+1		; EOR with second argument (mask)
00B844  2  25 49        	and	FORPNT			; AND with first argument (byte)
00B846  2  F0 F8        	beq	A_B840			; loop if result is zero
00B848  2               
00B848  2               A_B848:					;				[B848]
00B848  2  60           	rts
00B849  2               
00B849  2               
00B849  2               ;******************************************************************************
00B849  2               ;
00B849  2               ; add 0.5 to FAC1 (round FAC1)
00B849  2               ;
00B849  2               FAC1plus05:				;				[B849]
00B849  2  A9 11        	lda	#<L_BF11		; set 0.5 pointer LB
00B84B  2  A0 BF        	ldy	#>L_BF11		; set 0.5 pointer HB
00B84D  2  4C 67 B8     	jmp	AddFORvar2FAC1		; add (AY) to FAC1		[B867]
00B850  2               
00B850  2               
00B850  2               ;******************************************************************************
00B850  2               ;
00B850  2               ; perform subtraction, FAC1 from (AY)
00B850  2               ;
00B850  2               AYminusFAC1:				;				[B850]
00B850  2  20 8C BA     	jsr	UnpackAY2FAC2		; unpack memory (AY) into FAC2	[BA8C]
00B853  2               
00B853  2               
00B853  2               ;******************************************************************************
00B853  2               ;
00B853  2               ; perform subtraction, FAC1 from FAC2
00B853  2               ;
00B853  2               bcMINUS:
00B853  2  A5 66        	lda	FACSGN			; get FAC1 sign (b7)
00B855  2  49 FF        	eor	#$FF			; complement it
00B857  2  85 66        	sta	FACSGN			; save FAC1 sign (b7)
00B859  2  45 6E        	eor	ARGSGN			; EOR with FAC2 sign (b7)
00B85B  2  85 6F        	sta	ARISGN			; save sign compare (FAC1 EOR FAC2)
00B85D  2  A5 61        	lda	FACEXP			; get FAC1 exponent
00B85F  2  4C 6A B8     	jmp	bcPLUS			; add FAC2 to FAC1 and return	[B86A]
00B862  2               
00B862  2               A_B862:					;				[B862]
00B862  2  20 99 B9     	jsr	shftFACxAright		; shift FACX A times right (>8 shifts)
00B865  2               					;				[B999]
00B865  2  90 3C        	bcc	A_B8A3			;.go subtract mantissas
00B867  2               
00B867  2               
00B867  2               ;******************************************************************************
00B867  2               ;
00B867  2               ; add (AY) to FAC1
00B867  2               ;
00B867  2               AddFORvar2FAC1:				;				[B867]
00B867  2  20 8C BA     	jsr	UnpackAY2FAC2		; unpack memory (AY) into FAC2	[BA8C]
00B86A  2               
00B86A  2               
00B86A  2               ;******************************************************************************
00B86A  2               ;
00B86A  2               ; add FAC2 to FAC1
00B86A  2               ;
00B86A  2               bcPLUS:					;				[B86A]
00B86A  2  D0 03        	bne	A_B86F			; branch if FAC1 is not zero
00B86C  2               
00B86C  2  4C FC BB     	jmp	CopyFAC2toFAC1		; FAC1 was zero so copy FAC2 to FAC1
00B86F  2               					; and return			[BBFC]
00B86F  2               
00B86F  2               ; FAC1 is non zero
00B86F  2               A_B86F:					;				[B86F]
00B86F  2  A6 70        	ldx	FACOV			; get FAC1 rounding byte
00B871  2  86 56        	stx	Jump0054+2		; save as FAC2 rounding byte
00B873  2               
00B873  2  A2 69        	ldx	#ARGEXP			; set index to FAC2 exponent address
00B875  2  A5 69        	lda	ARGEXP			; get FAC2 exponent
00B877  2               bcPLUS2:				;				[B877]
00B877  2  A8           	tay				; copy exponent
00B878  2  F0 CE        	beq	A_B848			; exit if zero
00B87A  2               
00B87A  2  38           	sec				; set carry for subtract
00B87B  2  E5 61        	sbc	FACEXP			; subtract FAC1 exponent
00B87D  2  F0 24        	beq	A_B8A3			; if equal go add mantissas
00B87F  2               
00B87F  2  90 12        	bcc	A_B893			; if FAC2 < FAC1 then shift FAC2 right
00B881  2               
00B881  2               ; else FAC2 > FAC1
00B881  2  84 61        	sty	FACEXP			; save FAC1 exponent
00B883  2               
00B883  2  A4 6E        	ldy	ARGSGN			; get FAC2 sign (b7)
00B885  2  84 66        	sty	FACSGN			; save FAC1 sign (b7)
00B887  2               
00B887  2  49 FF        	eor	#$FF			; complement A
00B889  2  69 00        	adc	#$00			; +1, twos complement, carry is set
00B88B  2               
00B88B  2  A0 00        	ldy	#$00			; clear Y
00B88D  2  84 56        	sty	Jump0054+2		; clear FAC2 rounding byte
00B88F  2               
00B88F  2  A2 61        	ldx	#FACEXP			; set index to FAC1 exponent address
00B891  2  D0 04        	bne	A_B897			; branch always
00B893  2               
00B893  2               ; FAC2 < FAC1
00B893  2               A_B893:					;				[B893]
00B893  2  A0 00        	ldy	#$00			; clear Y
00B895  2  84 70        	sty	FACOV			; clear FAC1 rounding byte
00B897  2               A_B897:					;				[B897]
00B897  2  C9 F9        	cmp	#$F9			; compare exponent diff with $F9
00B899  2  30 C7        	bmi	A_B862			; branch if range $79-$F8
00B89B  2               
00B89B  2  A8           	tay				; copy exponent difference to Y
00B89C  2               
00B89C  2  A5 70        	lda	FACOV			; get FAC1 rounding byte
00B89E  2               
00B89E  2  56 01        	lsr	D6510+1,X		; shift FAC? mantissa 1
00B8A0  2               
00B8A0  2  20 B0 B9     	jsr	shftFACxYright		; shift FACX Y times right	[B9B0]
00B8A3  2               
00B8A3  2               ; exponents are equal now do mantissa subtract
00B8A3  2               A_B8A3:					;				[B8A3]
00B8A3  2  24 6F        	bit	ARISGN			; test sign compare (FAC1 EOR FAC2)
00B8A5  2  10 57        	bpl	A_B8FE			; if = add FAC2 mantissa to FAC1
00B8A7  2               					; mantissa and return
00B8A7  2  A0 61        	ldy	#FACEXP			; set the Y index to FAC1 exponent
00B8A9  2               					; address
00B8A9  2  E0 69        	cpx	#ARGEXP			; compare X to FAC2 exponent address
00B8AB  2  F0 02        	beq	A_B8AF			; if = continue, Y = FAC1, X = FAC2
00B8AD  2               
00B8AD  2  A0 69        	ldy	#ARGEXP			; else set the Y index to FAC2 exponent
00B8AF  2               					; address
00B8AF  2               ; subtract the smaller from the bigger (take the sign of the bigger)
00B8AF  2               A_B8AF:					;				[B8AF]
00B8AF  2  38           	sec				; set carry for subtract
00B8B0  2  49 FF        	eor	#$FF			; ones complement A
00B8B2  2  65 56        	adc	Jump0054+2		; add FAC2 rounding byte
00B8B4  2  85 70        	sta	FACOV			; save FAC1 rounding byte
00B8B6  2               
00B8B6  2  B9 04 00     	lda	D6510+4,Y		; get FACY mantissa 4
00B8B9  2  F5 04        	sbc	D6510+4,X		; subtract FACX mantissa 4
00B8BB  2  85 65        	sta	FacMantissa+3		; save FAC1 mantissa 4
00B8BD  2               
00B8BD  2  B9 03 00     	lda	D6510+3,Y		; get FACY mantissa 3
00B8C0  2  F5 03        	sbc	D6510+3,X		; subtract FACX mantissa 3
00B8C2  2  85 64        	sta	FacMantissa+2		; save FAC1 mantissa 3
00B8C4  2               
00B8C4  2  B9 02 00     	lda	D6510+2,Y		; get FACY mantissa 2
00B8C7  2  F5 02        	sbc	D6510+2,X		; subtract FACX mantissa 2
00B8C9  2  85 63        	sta	FacMantissa+1		; save FAC1 mantissa 2
00B8CB  2               
00B8CB  2  B9 01 00     	lda	D6510+1,Y		; get FACY mantissa 1
00B8CE  2  F5 01        	sbc	D6510+1,X		; subtract FACX mantissa 1
00B8D0  2  85 62        	sta	FacMantissa		; save FAC1 mantissa 1
00B8D2  2               
00B8D2  2               
00B8D2  2               ;******************************************************************************
00B8D2  2               ;
00B8D2  2               ; do ABS and normalise FAC1
00B8D2  2               ;
00B8D2  2               AbsNormalFAC1:				;				[B8D2]
00B8D2  2  B0 03        	bcs	NormaliseFAC1		; branch if number is positive
00B8D4  2               
00B8D4  2  20 47 B9     	jsr	NegateFAC1		; negate FAC1			[B947]
00B8D7  2               
00B8D7  2               
00B8D7  2               ;******************************************************************************
00B8D7  2               ;
00B8D7  2               ; normalise FAC1
00B8D7  2               ;
00B8D7  2               NormaliseFAC1:				;				[B8D7]
00B8D7  2  A0 00        	ldy	#$00			; clear Y
00B8D9  2  98           	tya				; clear A
00B8DA  2  18           	clc				; clear carry for add
00B8DB  2               A_B8DB:					;				[B8DB]
00B8DB  2  A6 62        	ldx	FacMantissa		; get FAC1 mantissa 1
00B8DD  2  D0 4A        	bne	A_B929			; if not zero normalise FAC1
00B8DF  2               
00B8DF  2  A6 63        	ldx	FacMantissa+1		; get FAC1 mantissa 2
00B8E1  2  86 62        	stx	FacMantissa		; save FAC1 mantissa 1
00B8E3  2               
00B8E3  2  A6 64        	ldx	FacMantissa+2		; get FAC1 mantissa 3
00B8E5  2  86 63        	stx	FacMantissa+1		; save FAC1 mantissa 2
00B8E7  2               
00B8E7  2  A6 65        	ldx	FacMantissa+3		; get FAC1 mantissa 4
00B8E9  2  86 64        	stx	FacMantissa+2		; save FAC1 mantissa 3
00B8EB  2               
00B8EB  2  A6 70        	ldx	FACOV			; get FAC1 rounding byte
00B8ED  2  86 65        	stx	FacMantissa+3		; save FAC1 mantissa 4
00B8EF  2               
00B8EF  2  84 70        	sty	FACOV			; clear FAC1 rounding byte
00B8F1  2               
00B8F1  2  69 08        	adc	#$08			; add x to exponent offset
00B8F3  2  C9 20        	cmp	#$20			; compare with $20, max offset, all bits
00B8F5  2               					; would be = 0
00B8F5  2  D0 E4        	bne	A_B8DB			; loop if not max
00B8F7  2               
00B8F7  2               
00B8F7  2               ;******************************************************************************
00B8F7  2               ;
00B8F7  2               ; clear FAC1 exponent and sign
00B8F7  2               ;
00B8F7  2               ClrFAC1ExpSgn:				;				[B8F7]
00B8F7  2  A9 00        	lda	#$00			; clear A
00B8F9  2               ClrFAC1Exp:				;				[B8F9]
00B8F9  2  85 61        	sta	FACEXP			; set FAC1 exponent
00B8FB  2               
00B8FB  2               
00B8FB  2               ;******************************************************************************
00B8FB  2               ;
00B8FB  2               ; save FAC1 sign
00B8FB  2               ;
00B8FB  2               SaveFAC1Sign:				;				[B8FB]
00B8FB  2  85 66        	sta	FACSGN			; save FAC1 sign (b7)
00B8FD  2  60           	rts
00B8FE  2               
00B8FE  2               
00B8FE  2               ;******************************************************************************
00B8FE  2               ;
00B8FE  2               ; add FAC2 mantissa to FAC1 mantissa
00B8FE  2               ;
00B8FE  2               A_B8FE:					;				[B8FE]
00B8FE  2  65 56        	adc	Jump0054+2		; add FAC2 rounding byte
00B900  2  85 70        	sta	FACOV			; save FAC1 rounding byte
00B902  2               
00B902  2  A5 65        	lda	FacMantissa+3		; get FAC1 mantissa 4
00B904  2  65 6D        	adc	ArgMantissa+3		; add FAC2 mantissa 4
00B906  2  85 65        	sta	FacMantissa+3		; save FAC1 mantissa 4
00B908  2               
00B908  2  A5 64        	lda	FacMantissa+2		; get FAC1 mantissa 3
00B90A  2  65 6C        	adc	ArgMantissa+2		; add FAC2 mantissa 3
00B90C  2  85 64        	sta	FacMantissa+2		; save FAC1 mantissa 3
00B90E  2               
00B90E  2  A5 63        	lda	FacMantissa+1		; get FAC1 mantissa 2
00B910  2  65 6B        	adc	ArgMantissa+1		; add FAC2 mantissa 2
00B912  2  85 63        	sta	FacMantissa+1		; save FAC1 mantissa 2
00B914  2               
00B914  2  A5 62        	lda	FacMantissa		; get FAC1 mantissa 1
00B916  2  65 6A        	adc	ArgMantissa		; add FAC2 mantissa 1
00B918  2  85 62        	sta	FacMantissa		; save FAC1 mantissa 1
00B91A  2               
00B91A  2  4C 36 B9     	jmp	NormaliseFAC12		; test and normalise FAC1 for C=0/1
00B91D  2               					;				[B936]
00B91D  2               
00B91D  2               A_B91D:					;				[B91D]
00B91D  2  69 01        	adc	#$01			; add 1 to exponent offset
00B91F  2  06 70        	asl	FACOV			; shift FAC1 rounding byte
00B921  2  26 65        	rol	FacMantissa+3		; shift FAC1 mantissa 4
00B923  2  26 64        	rol	FacMantissa+2		; shift FAC1 mantissa 3
00B925  2  26 63        	rol	FacMantissa+1		; shift FAC1 mantissa 2
00B927  2  26 62        	rol	FacMantissa		; shift FAC1 mantissa 1
00B929  2               
00B929  2               ; normalise FAC1
00B929  2               A_B929:					;				[B929]
00B929  2  10 F2        	bpl	A_B91D			; loop if not normalised
00B92B  2               
00B92B  2  38           	sec				; set carry for subtract
00B92C  2  E5 61        	sbc	FACEXP			; subtract FAC1 exponent
00B92E  2  B0 C7        	bcs	ClrFAC1ExpSgn		; branch if underflow (set result = $0)
00B930  2               
00B930  2  49 FF        	eor	#$FF			; complement exponent
00B932  2  69 01        	adc	#$01			; +1 (twos complement)
00B934  2  85 61        	sta	FACEXP			; save FAC1 exponent
00B936  2               
00B936  2               ; test and normalise FAC1 for C=0/1
00B936  2               NormaliseFAC12:				;				[B936]
00B936  2  90 0E        	bcc	A_B946			; exit if no overflow
00B938  2               
00B938  2               ; normalise FAC1 for C=1
00B938  2               NormaliseFAC13:				;				[B938]
00B938  2  E6 61        	inc	FACEXP			; increment FAC1 exponent
00B93A  2  F0 42        	beq	OverflowError		; if zero do overflow error then warm
00B93C  2               					; start
00B93C  2  66 62        	ror	FacMantissa		; shift FAC1 mantissa 1
00B93E  2  66 63        	ror	FacMantissa+1		; shift FAC1 mantissa 2
00B940  2  66 64        	ror	FacMantissa+2		; shift FAC1 mantissa 3
00B942  2  66 65        	ror	FacMantissa+3		; shift FAC1 mantissa 4
00B944  2  66 70        	ror	FACOV			; shift FAC1 rounding byte
00B946  2               A_B946:					;				[B946]
00B946  2  60           	rts
00B947  2               
00B947  2               
00B947  2               ;******************************************************************************
00B947  2               ;
00B947  2               ; negate FAC1
00B947  2               ;
00B947  2               NegateFAC1:				;				[B947]
00B947  2  A5 66        	lda	FACSGN			; get FAC1 sign (b7)
00B949  2  49 FF        	eor	#$FF			; complement it
00B94B  2  85 66        	sta	FACSGN			; save FAC1 sign (b7)
00B94D  2               
00B94D  2               ; twos complement FAC1 mantissa
00B94D  2               TwoComplFAC1:				;				[B94D]
00B94D  2  A5 62        	lda	FacMantissa		; get FAC1 mantissa 1
00B94F  2  49 FF        	eor	#$FF			; complement it
00B951  2  85 62        	sta	FacMantissa		; save FAC1 mantissa 1
00B953  2               
00B953  2  A5 63        	lda	FacMantissa+1		; get FAC1 mantissa 2
00B955  2  49 FF        	eor	#$FF			; complement it
00B957  2  85 63        	sta	FacMantissa+1		; save FAC1 mantissa 2
00B959  2               
00B959  2  A5 64        	lda	FacMantissa+2		; get FAC1 mantissa 3
00B95B  2  49 FF        	eor	#$FF			; complement it
00B95D  2  85 64        	sta	FacMantissa+2		; save FAC1 mantissa 3
00B95F  2               
00B95F  2  A5 65        	lda	FacMantissa+3		; get FAC1 mantissa 4
00B961  2  49 FF        	eor	#$FF			; complement it
00B963  2  85 65        	sta	FacMantissa+3		; save FAC1 mantissa 4
00B965  2               
00B965  2  A5 70        	lda	FACOV			; get FAC1 rounding byte
00B967  2  49 FF        	eor	#$FF			; complement it
00B969  2  85 70        	sta	FACOV			; save FAC1 rounding byte
00B96B  2               
00B96B  2  E6 70        	inc	FACOV			; increment FAC1 rounding byte
00B96D  2  D0 0E        	bne	A_B97D			; exit if no overflow
00B96F  2               
00B96F  2               ; increment FAC1 mantissa
00B96F  2               IncFAC1Mant:				;				[B96F]
00B96F  2  E6 65        	inc	FacMantissa+3		; increment FAC1 mantissa 4
00B971  2  D0 0A        	bne	A_B97D			; finished if no rollover
00B973  2               
00B973  2  E6 64        	inc	FacMantissa+2		; increment FAC1 mantissa 3
00B975  2  D0 06        	bne	A_B97D			; finished if no rollover
00B977  2               
00B977  2  E6 63        	inc	FacMantissa+1		; increment FAC1 mantissa 2
00B979  2  D0 02        	bne	A_B97D			; finished if no rollover
00B97B  2               
00B97B  2  E6 62        	inc	FacMantissa		; increment FAC1 mantissa 1
00B97D  2               A_B97D:					;				[B97D]
00B97D  2  60           	rts
00B97E  2               
00B97E  2               
00B97E  2               ;******************************************************************************
00B97E  2               ;
00B97E  2               ; do overflow error then warm start
00B97E  2               ;
00B97E  2               OverflowError:				;				[B97E]
00B97E  2  A2 0F        	ldx	#$0F			; error $0F, overflow error
00B980  2  4C 37 A4     	jmp	OutputErrMsg		; do error #X then warm start	[A437]
00B983  2               
00B983  2               
00B983  2               ;******************************************************************************
00B983  2               ;
00B983  2               ; shift register to the right
00B983  2               ;
00B983  2               ShiftRegRight:				;				[B983]
00B983  2  A2 25        	ldx	#RESHO-1		; set the offset to FACtemp
00B985  2               A_B985:					;				[B985]
00B985  2  B4 04        	ldy	RESHO-$22,X		; get FACX mantissa 4
00B987  2  84 70        	sty	FACOV			; save as FAC1 rounding byte
00B989  2               
00B989  2  B4 03        	ldy	RESHO-$23,X		; get FACX mantissa 3
00B98B  2  94 04        	sty	RESHO-$22,X		; save FACX mantissa 4
00B98D  2               
00B98D  2  B4 02        	ldy	RESHO-$24,X		; get FACX mantissa 2
00B98F  2  94 03        	sty	RESHO-$23,X		; save FACX mantissa 3
00B991  2               
00B991  2  B4 01        	ldy	RESHO-$25,X		; get FACX mantissa 1
00B993  2  94 02        	sty	RESHO-$24,X		; save FACX mantissa 2
00B995  2               
00B995  2  A4 68        	ldy	BITS			; get FAC1 overfLB
00B997  2  94 01        	sty	RESHO-$25,X		; save FACX mantissa 1
00B999  2               
00B999  2               ; shift FACX -A times right (> 8 shifts)
00B999  2               shftFACxAright:				;				[B999]
00B999  2  69 08        	adc	#$08			; add 8 to shift count
00B99B  2  30 E8        	bmi	A_B985			; go do 8 shift if still -ve
00B99D  2               
00B99D  2  F0 E6        	beq	A_B985			; go do 8 shift if zero
00B99F  2               
00B99F  2  E9 08        	sbc	#$08			; else subtract 8 again
00B9A1  2  A8           	tay				; save count to Y
00B9A2  2               
00B9A2  2  A5 70        	lda	FACOV			; get FAC1 rounding byte
00B9A4  2  B0 14        	bcs	A_B9BA			;.
00B9A6  2               
00B9A6  2               A_B9A6:					;				[B9A6]
00B9A6  2  16 01        	asl	D6510+1,X		; shift FACX mantissa 1
00B9A8  2  90 02        	bcc	A_B9AC			; branch if +ve
00B9AA  2               
00B9AA  2  F6 01        	inc	D6510+1,X		; this sets b7 eventually
00B9AC  2               A_B9AC:					;				[B9AC]
00B9AC  2  76 01        	ror	D6510+1,X		; shift FACX mantissa 1, correct for ASL
00B9AE  2  76 01        	ror	D6510+1,X		; shift FACX mantissa 1, put carry in b7
00B9B0  2               
00B9B0  2               ; shift FACX Y times right
00B9B0  2               shftFACxYright:				;				[B9B0]
00B9B0  2  76 02        	ror	D6510+2,X		; shift FACX mantissa 2
00B9B2  2  76 03        	ror	D6510+3,X		; shift FACX mantissa 3
00B9B4  2  76 04        	ror	D6510+4,X		; shift FACX mantissa 4
00B9B6  2  6A           	ror				; shift FACX rounding byte
00B9B7  2               
00B9B7  2  C8           	iny				; increment exponent diff
00B9B8  2  D0 EC        	bne	A_B9A6			; branch if range adjust not complete
00B9BA  2               
00B9BA  2               A_B9BA:					;				[B9BA]
00B9BA  2  18           	clc				; just clear it
00B9BB  2  60           	rts
00B9BC  2               
00B9BC  2               
00B9BC  2               ;******************************************************************************
00B9BC  2               ;
00B9BC  2               ; constants and series for LOG(n)
00B9BC  2               ;
00B9BC  2               Constant1:				;				[B9BC]
00B9BC  2  81 00 00 00  .byte	$81,$00,$00,$00,$00		; 1
00B9C0  2  00           
00B9C1  2               
00B9C1  2               ConstLogCoef:				;				[B9C1]
00B9C1  2  03           .byte	$03				; series counter
00B9C2  2  7F 5E 56 CB  .byte	$7F,$5E,$56,$CB,$79
00B9C6  2  79           
00B9C7  2  80 13 9B 0B  .byte	$80,$13,$9B,$0B,$64
00B9CB  2  64           
00B9CC  2  80 76 38 93  .byte	$80,$76,$38,$93,$16
00B9D0  2  16           
00B9D1  2  82 38 AA 3B  .byte	$82,$38,$AA,$3B,$20
00B9D5  2  20           
00B9D6  2               
00B9D6  2               Const1divSQR2:				;				[B9D6]
00B9D6  2  80 35 04 F3  .byte	$80,$35,$04,$F3,$34		; 0.70711	1/root 2
00B9DA  2  34           
00B9DB  2               ConstSQR2:				;				[B9DB]
00B9DB  2  81 35 04 F3  .byte	$81,$35,$04,$F3,$34		; 1.41421	root 2
00B9DF  2  34           
00B9E0  2               Const05:				;				[B9E0]
00B9E0  2  80 80 00 00  .byte	$80,$80,$00,$00,$00		; -0.5	1/2
00B9E4  2  00           
00B9E5  2               ConstLOG2:				;				[B9E5]
00B9E5  2  80 31 72 17  .byte	$80,$31,$72,$17,$F8		; 0.69315	LOG(2)
00B9E9  2  F8           
00B9EA  2               
00B9EA  2               
00B9EA  2               ;******************************************************************************
00B9EA  2               ;
00B9EA  2               ; perform LOG()
00B9EA  2               ;
00B9EA  2               bcLOG:					;				[B9EA]
00B9EA  2  20 2B BC     	jsr	GetFacSign		; test sign and zero		[BC2B]
00B9ED  2  F0 02        	beq	A_B9F1			; if zero do illegal quantity error then
00B9EF  2               					; warm start
00B9EF  2  10 03        	bpl	A_B9F4			; skip error if +ve
00B9F1  2               
00B9F1  2               A_B9F1:					;				[B9F1]
00B9F1  2  4C 48 B2     	jmp	IllegalQuant		; do illegal quantity error then warm
00B9F4  2               					; start				[B248]
00B9F4  2               A_B9F4:					;				[B9F4]
00B9F4  2  A5 61        	lda	FACEXP			; get FAC1 exponent
00B9F6  2  E9 7F        	sbc	#$7F			; normalise it
00B9F8  2  48           	pha				; save it
00B9F9  2               
00B9F9  2  A9 80        	lda	#$80			; set exponent to zero
00B9FB  2  85 61        	sta	FACEXP			; save FAC1 exponent
00B9FD  2               
00B9FD  2  A9 D6        	lda	#<Const1divSQR2		; pointer to 1/root 2 LB
00B9FF  2  A0 B9        	ldy	#>Const1divSQR2		; pointer to 1/root 2 HB
00BA01  2  20 67 B8     	jsr	AddFORvar2FAC1		; add (AY) to FAC1 (1/root2)	[B867]
00BA04  2               
00BA04  2  A9 DB        	lda	#<ConstSQR2		; pointer to root 2 LB
00BA06  2  A0 B9        	ldy	#>ConstSQR2		; pointer to root 2 HB
00BA08  2  20 0F BB     	jsr	AYdivFAC1		; convert AY and do (AY)/FAC1
00BA0B  2               					; (root2/(x+(1/root2)))		[BB0F]
00BA0B  2               
00BA0B  2  A9 BC        	lda	#<Constant1		; pointer to 1 LB
00BA0D  2  A0 B9        	ldy	#>Constant1		; pointer to 1 HB
00BA0F  2  20 50 B8     	jsr	AYminusFAC1		; subtr FAC1 ((root2/(x+(1/root2)))-1)
00BA12  2               					; from (AY)			[B850]
00BA12  2  A9 C1        	lda	#<ConstLogCoef		; pointer to series for LOG(n) LB
00BA14  2  A0 B9        	ldy	#>ConstLogCoef		; pointer to series for LOG(n) HB
00BA16  2  20 43 E0     	jsr	Power2			; ^2 then series evaluation	[E043]
00BA19  2               
00BA19  2  A9 E0        	lda	#<Const05		; pointer to -0.5 LB
00BA1B  2  A0 B9        	ldy	#>Const05		; pointer to -0.5 HB
00BA1D  2  20 67 B8     	jsr	AddFORvar2FAC1		; add (AY) to FAC1		[B867]
00BA20  2               
00BA20  2  68           	pla				; restore FAC1 exponent
00BA21  2  20 7E BD     	jsr	EvalNewDigit		; evaluate new ASCII digit	[BD7E]
00BA24  2               
00BA24  2  A9 E5        	lda	#<ConstLOG2		; pointer to LOG(2) LB
00BA26  2  A0 B9        	ldy	#>ConstLOG2		; pointer to LOG(2) HB
00BA28  2               
00BA28  2               
00BA28  2               ;******************************************************************************
00BA28  2               ;
00BA28  2               ; do convert AY, FCA1*(AY)
00BA28  2               ;
00BA28  2               FAC1xAY:				;				[BA28]
00BA28  2  20 8C BA     	jsr	UnpackAY2FAC2		; unpack memory (AY) into FAC2	[BA8C]
00BA2B  2               bcMULTIPLY:				;				[BA2B]
00BA2B  2  D0 03        	bne	A_BA30			; multiply FAC1 by FAC2 ??
00BA2D  2               
00BA2D  2  4C 8B BA     	jmp	JmpRTS			; exit if zero			[BA8B]
00BA30  2               
00BA30  2               A_BA30:					;				[BA30]
00BA30  2  20 B7 BA     	jsr	TestAdjFACs		; test and adjust accumulators	[BAB7]
00BA33  2               
00BA33  2  A9 00        	lda	#$00			; clear A
00BA35  2  85 26        	sta	RESHO			; clear temp mantissa 1
00BA37  2  85 27        	sta	RESHO+1			; clear temp mantissa 2
00BA39  2  85 28        	sta	RESHO+2			; clear temp mantissa 3
00BA3B  2  85 29        	sta	RESHO+3			; clear temp mantissa 4
00BA3D  2               
00BA3D  2  A5 70        	lda	FACOV			; get FAC1 rounding byte
00BA3F  2  20 59 BA     	jsr	ShftAddFAC2		; go do shift/add FAC2		[BA59]
00BA42  2               
00BA42  2  A5 65        	lda	FacMantissa+3		; get FAC1 mantissa 4
00BA44  2  20 59 BA     	jsr	ShftAddFAC2		; go do shift/add FAC2		[BA59]
00BA47  2               
00BA47  2  A5 64        	lda	FacMantissa+2		; get FAC1 mantissa 3
00BA49  2  20 59 BA     	jsr	ShftAddFAC2		; go do shift/add FAC2		[BA59]
00BA4C  2               
00BA4C  2  A5 63        	lda	FacMantissa+1		; get FAC1 mantissa 2
00BA4E  2  20 59 BA     	jsr	ShftAddFAC2		; go do shift/add FAC2		[BA59]
00BA51  2               
00BA51  2  A5 62        	lda	FacMantissa		; get FAC1 mantissa 1
00BA53  2  20 5E BA     	jsr	ShftAddFAC22		; go do shift/add FAC2		[BA5E]
00BA56  2               
00BA56  2  4C 8F BB     	jmp	TempToFAC1		; copy temp to FAC1, normalise and
00BA59  2               					; return			[BB8F]
00BA59  2               ShftAddFAC2:				;				[BA59]
00BA59  2  D0 03        	bne	ShftAddFAC22		; branch if byte <> zero
00BA5B  2               
00BA5B  2  4C 83 B9     	jmp	ShiftRegRight		; shift FCAtemp << A+8 times	[B983]
00BA5E  2               
00BA5E  2               ; else do shift and add
00BA5E  2               ShftAddFAC22:				;				[BA5E]
00BA5E  2  4A           	lsr				; shift byte
00BA5F  2  09 80        	ora	#$80			; set top bit (mark for 8 times)
00BA61  2               A_BA61:					;				[BA61]
00BA61  2  A8           	tay				; copy result
00BA62  2  90 19        	bcc	A_BA7D			; skip next if bit was zero
00BA64  2               
00BA64  2  18           	clc				; clear carry for add
00BA65  2  A5 29        	lda	RESHO+3			; get temp mantissa 4
00BA67  2  65 6D        	adc	ArgMantissa+3		; add FAC2 mantissa 4
00BA69  2  85 29        	sta	RESHO+3			; save temp mantissa 4
00BA6B  2               
00BA6B  2  A5 28        	lda	RESHO+2			; get temp mantissa 3
00BA6D  2  65 6C        	adc	ArgMantissa+2		; add FAC2 mantissa 3
00BA6F  2  85 28        	sta	RESHO+2			; save temp mantissa 3
00BA71  2               
00BA71  2  A5 27        	lda	RESHO+1			; get temp mantissa 2
00BA73  2  65 6B        	adc	ArgMantissa+1		; add FAC2 mantissa 2
00BA75  2  85 27        	sta	RESHO+1			; save temp mantissa 2
00BA77  2               
00BA77  2  A5 26        	lda	RESHO			; get temp mantissa 1
00BA79  2  65 6A        	adc	ArgMantissa		; add FAC2 mantissa 1
00BA7B  2  85 26        	sta	RESHO			; save temp mantissa 1
00BA7D  2               A_BA7D:					;				[BA7D]
00BA7D  2  66 26        	ror	RESHO			; shift temp mantissa 1
00BA7F  2  66 27        	ror	RESHO+1			; shift temp mantissa 2
00BA81  2  66 28        	ror	RESHO+2			; shift temp mantissa 3
00BA83  2  66 29        	ror	RESHO+3			; shift temp mantissa 4
00BA85  2  66 70        	ror	FACOV			; shift temp rounding byte
00BA87  2               
00BA87  2  98           	tya				; get byte back
00BA88  2  4A           	lsr				; shift byte
00BA89  2  D0 D6        	bne	A_BA61			; loop if all bits not done
00BA8B  2               
00BA8B  2               JmpRTS:					;				[BA8B]
00BA8B  2  60           	rts
00BA8C  2               
00BA8C  2               
00BA8C  2               ;******************************************************************************
00BA8C  2               ;
00BA8C  2               ; unpack memory (AY) into FAC2
00BA8C  2               ;
00BA8C  2               UnpackAY2FAC2:				;				[BA8C]
00BA8C  2  85 22        	sta	INDEX			; save pointer LB
00BA8E  2  84 23        	sty	INDEX+1			; save pointer HB
00BA90  2               
00BA90  2  A0 04        	ldy	#$04			; 5 bytes to get (0-4)
00BA92  2  B1 22        	lda	(INDEX),Y		; get mantissa 4
00BA94  2  85 6D        	sta	ArgMantissa+3		; save FAC2 mantissa 4
00BA96  2               
00BA96  2  88           	dey				; decrement index
00BA97  2  B1 22        	lda	(INDEX),Y		; get mantissa 3
00BA99  2  85 6C        	sta	ArgMantissa+2		; save FAC2 mantissa 3
00BA9B  2               
00BA9B  2  88           	dey				; decrement index
00BA9C  2  B1 22        	lda	(INDEX),Y		; get mantissa 2
00BA9E  2  85 6B        	sta	ArgMantissa+1		; save FAC2 mantissa 2
00BAA0  2               
00BAA0  2  88           	dey				; decrement index
00BAA1  2  B1 22        	lda	(INDEX),Y		; get mantissa 1 + sign
00BAA3  2  85 6E        	sta	ARGSGN			; save FAC2 sign (b7)
00BAA5  2               
00BAA5  2  45 66        	eor	FACSGN			; EOR with FAC1 sign (b7)
00BAA7  2  85 6F        	sta	ARISGN			; save sign compare (FAC1 EOR FAC2)
00BAA9  2               
00BAA9  2  A5 6E        	lda	ARGSGN			; recover FAC2 sign (b7)
00BAAB  2  09 80        	ora	#$80			; set 1xxx xxx (set normal bit)
00BAAD  2  85 6A        	sta	ArgMantissa		; save FAC2 mantissa 1
00BAAF  2               
00BAAF  2  88           	dey				; decrement index
00BAB0  2  B1 22        	lda	(INDEX),Y		; get exponent byte
00BAB2  2  85 69        	sta	ARGEXP			; save FAC2 exponent
00BAB4  2               
00BAB4  2  A5 61        	lda	FACEXP			; get FAC1 exponent
00BAB6  2  60           	rts
00BAB7  2               
00BAB7  2               
00BAB7  2               ;******************************************************************************
00BAB7  2               ;
00BAB7  2               ; test and adjust accumulators
00BAB7  2               ;
00BAB7  2               TestAdjFACs:				;				[BAB7]
00BAB7  2  A5 69        	lda	ARGEXP			; get FAC2 exponent
00BAB9  2               
00BAB9  2               TestAdjFACs2:				;				[BAB9]
00BAB9  2  F0 1F        	beq	A_BADA			; branch if FAC2 = $00, handle underflow
00BABB  2               
00BABB  2  18           	clc				; clear carry for add
00BABC  2  65 61        	adc	FACEXP			; add FAC1 exponent
00BABE  2  90 04        	bcc	A_BAC4			; branch if sum of exponents < $0100
00BAC0  2               
00BAC0  2  30 1D        	bmi	A_BADF			; do overflow error
00BAC2  2               
00BAC2  2  18           	clc				; clear carry for the add
00BAC3  2  2C           .byte	$2C				; makes next line BIT $1410
00BAC4  2               A_BAC4:					;				[BAC4]
00BAC4  2  10 14        	bpl	A_BADA			; if +ve go handle underflow
00BAC6  2               
00BAC6  2  69 80        	adc	#$80			; adjust exponent
00BAC8  2  85 61        	sta	FACEXP			; save FAC1 exponent
00BACA  2  D0 03        	bne	A_BACF			; branch if not zero
00BACC  2               
00BACC  2  4C FB B8     	jmp	SaveFAC1Sign		; save FAC1 sign and return	[B8FB]
00BACF  2               
00BACF  2               
00BACF  2               A_BACF:					;				[BACF]
00BACF  2  A5 6F        	lda	ARISGN			; get sign compare (FAC1 EOR FAC2)
00BAD1  2  85 66        	sta	FACSGN			; save FAC1 sign (b7)
00BAD3  2               
00BAD3  2  60           	rts
00BAD4  2               
00BAD4  2               ; handle overflow and underflow
00BAD4  2               HndlOvUnFlErr:				;				[BAD4]
00BAD4  2  A5 66        	lda	FACSGN			; get FAC1 sign (b7)
00BAD6  2  49 FF        	eor	#$FF			; complement it
00BAD8  2  30 05        	bmi	A_BADF			; do overflow error
00BADA  2               
00BADA  2               ; handle underflow
00BADA  2               A_BADA:					;				[BADA]
00BADA  2  68           	pla				; pop return address LB
00BADB  2  68           	pla				; pop return address HB
00BADC  2  4C F7 B8     	jmp	ClrFAC1ExpSgn		; clear FAC1 exponent and sign and
00BADF  2               					; return			[B8F7]
00BADF  2               
00BADF  2               A_BADF:					;				[BADF]
00BADF  2  4C 7E B9     	jmp	OverflowError		; do overflow error then warm start
00BAE2  2               					;				[B97E]
00BAE2  2               
00BAE2  2               ;******************************************************************************
00BAE2  2               ;
00BAE2  2               ; multiply FAC1 by 10
00BAE2  2               ;
00BAE2  2               Fac1x10:				;				[BAE2]
00BAE2  2  20 0C BC     	jsr	CopyFAC1toFAC2		; round and copy FAC1 to FAC2	[BC0C]
00BAE5  2  AA           	tax				; copy exponent (set the flags)
00BAE6  2  F0 10        	beq	A_BAF8			; exit if zero
00BAE8  2               
00BAE8  2  18           	clc				; clear carry for add
00BAE9  2  69 02        	adc	#$02			; add two to exponent (*4)
00BAEB  2  B0 F2        	bcs	A_BADF			; do overflow error if > $FF
00BAED  2               
00BAED  2               ; FAC1 = (FAC1 + FAC2) * 2
00BAED  2               FAC1plFAC2x2:				;				[BAED]
00BAED  2  A2 00        	ldx	#$00			; clear byte
00BAEF  2  86 6F        	stx	ARISGN			; clear sign compare (FAC1 EOR FAC2)
00BAF1  2  20 77 B8     	jsr	bcPLUS2			; add FAC2 to FAC1 (*5)		[B877]
00BAF4  2  E6 61        	inc	FACEXP			; increment FAC1 exponent (*10)
00BAF6  2  F0 E7        	beq	A_BADF			; if exponent now zero go do overflow
00BAF8  2               					; error
00BAF8  2               A_BAF8:					;				[BAF8]
00BAF8  2  60           	rts
00BAF9  2               
00BAF9  2               
00BAF9  2               ;******************************************************************************
00BAF9  2               ;
00BAF9  2               ; 10 as a floating value
00BAF9  2               ;
00BAF9  2               Constant10:				;				[BAF9]
00BAF9  2  84 20 00 00  .byte	$84,$20,$00,$00,$00		; 10
00BAFD  2  00           
00BAFE  2               
00BAFE  2               
00BAFE  2               ;******************************************************************************
00BAFE  2               ;
00BAFE  2               ; divide FAC1 by 10
00BAFE  2               ;
00BAFE  2               FAC1div10:				;				[BAFE]
00BAFE  2  20 0C BC     	jsr	CopyFAC1toFAC2		; round and copy FAC1 to FAC2	[BC0C]
00BB01  2               
00BB01  2  A9 F9        	lda	#<Constant10		; set 10 pointer LB
00BB03  2  A0 BA        	ldy	#>Constant10		; set 10 pointer HB
00BB05  2  A2 00        	ldx	#$00			; clear sign
00BB07  2               
00BB07  2               
00BB07  2               ;******************************************************************************
00BB07  2               ;
00BB07  2               ; divide by (AY) (X=sign)
00BB07  2               ;
00BB07  2               FAC1divAY:				;				[BB07]
00BB07  2  86 6F        	stx	ARISGN			; save sign compare (FAC1 EOR FAC2)
00BB09  2  20 A2 BB     	jsr	UnpackAY2FAC1		; unpack memory (AY) into FAC1	[BBA2]
00BB0C  2  4C 12 BB     	jmp	bcDIVIDE		; do FAC2/FAC1			[BB12]
00BB0F  2               
00BB0F  2               
00BB0F  2               ;******************************************************************************
00BB0F  2               ;
00BB0F  2               ; convert AY and do (AY)/FAC1
00BB0F  2               ;
00BB0F  2               AYdivFAC1:				;				[BB0F]
00BB0F  2  20 8C BA     	jsr	UnpackAY2FAC2		; unpack memory (AY) into FAC2	[BA8C]
00BB12  2               bcDIVIDE:
00BB12  2  F0 76        	beq	A_BB8A			; if zero go do /0 error
00BB14  2               
00BB14  2  20 1B BC     	jsr	RoundFAC1		; round FAC1			[BC1B]
00BB17  2               
00BB17  2  A9 00        	lda	#$00			; clear A
00BB19  2  38           	sec				; set carry for subtract
00BB1A  2  E5 61        	sbc	FACEXP			; subtract FAC1 exponent (2s complement)
00BB1C  2  85 61        	sta	FACEXP			; save FAC1 exponent
00BB1E  2               
00BB1E  2  20 B7 BA     	jsr	TestAdjFACs		; test and adjust accumulators	[BAB7]
00BB21  2               
00BB21  2  E6 61        	inc	FACEXP			; increment FAC1 exponent
00BB23  2  F0 BA        	beq	A_BADF			; if zero do overflow error
00BB25  2               
00BB25  2  A2 FC        	ldx	#$FC			; set index to FAC temp
00BB27  2  A9 01        	lda	#$01			;.set byte
00BB29  2               A_BB29:					;				[BB29]
00BB29  2  A4 6A        	ldy	ArgMantissa		; get FAC2 mantissa 1
00BB2B  2  C4 62        	cpy	FacMantissa		; compare FAC1 mantissa 1
00BB2D  2  D0 10        	bne	A_BB3F			; branch if <>
00BB2F  2               
00BB2F  2  A4 6B        	ldy	ArgMantissa+1		; get FAC2 mantissa 2
00BB31  2  C4 63        	cpy	FacMantissa+1		; compare FAC1 mantissa 2
00BB33  2  D0 0A        	bne	A_BB3F			; branch if <>
00BB35  2               
00BB35  2  A4 6C        	ldy	ArgMantissa+2		; get FAC2 mantissa 3
00BB37  2  C4 64        	cpy	FacMantissa+2		; compare FAC1 mantissa 3
00BB39  2  D0 04        	bne	A_BB3F			; branch if <>
00BB3B  2               
00BB3B  2  A4 6D        	ldy	ArgMantissa+3		; get FAC2 mantissa 4
00BB3D  2  C4 65        	cpy	FacMantissa+3		; compare FAC1 mantissa 4
00BB3F  2               A_BB3F:					;				[BB3F]
00BB3F  2  08           	php				; save FAC2-FAC1 compare status
00BB40  2               
00BB40  2  2A           	rol				;.shift byte
00BB41  2  90 09        	bcc	A_BB4C			; skip next if no carry
00BB43  2               
00BB43  2  E8           	inx				; increment index to FAC temp
00BB44  2  95 29        	sta	RESHO+3,X		;.
00BB46  2  F0 32        	beq	A_BB7A			;.
00BB48  2               
00BB48  2  10 34        	bpl	A_BB7E			;.
00BB4A  2               
00BB4A  2  A9 01        	lda	#$01			;.
00BB4C  2               A_BB4C:					;				[BB4C]
00BB4C  2  28           	plp				; restore FAC2-FAC1 compare status
00BB4D  2  B0 0E        	bcs	A_BB5D			; if FAC2 >= FAC1 then do subtract
00BB4F  2               
00BB4F  2               ; FAC2 = FAC2*2
00BB4F  2               FAC2x2:					;				[BB4F]
00BB4F  2  06 6D        	asl	ArgMantissa+3		; shift FAC2 mantissa 4
00BB51  2  26 6C        	rol	ArgMantissa+2		; shift FAC2 mantissa 3
00BB53  2  26 6B        	rol	ArgMantissa+1		; shift FAC2 mantissa 2
00BB55  2  26 6A        	rol	ArgMantissa		; shift FAC2 mantissa 1
00BB57  2  B0 E6        	bcs	A_BB3F			; loop with no compare
00BB59  2               
00BB59  2  30 CE        	bmi	A_BB29			; loop with compare
00BB5B  2               
00BB5B  2  10 E2        	bpl	A_BB3F			; Always -> loop with no compare
00BB5D  2               
00BB5D  2               
00BB5D  2               A_BB5D:					;				[BB5D]
00BB5D  2  A8           	tay				; save FAC2-FAC1 compare status
00BB5E  2               
00BB5E  2  A5 6D        	lda	ArgMantissa+3		; get FAC2 mantissa 4
00BB60  2  E5 65        	sbc	FacMantissa+3		; subtract FAC1 mantissa 4
00BB62  2  85 6D        	sta	ArgMantissa+3		; save FAC2 mantissa 4
00BB64  2               
00BB64  2  A5 6C        	lda	ArgMantissa+2		; get FAC2 mantissa 3
00BB66  2  E5 64        	sbc	FacMantissa+2		; subtract FAC1 mantissa 3
00BB68  2  85 6C        	sta	ArgMantissa+2		; save FAC2 mantissa 3
00BB6A  2               
00BB6A  2  A5 6B        	lda	ArgMantissa+1		; get FAC2 mantissa 2
00BB6C  2  E5 63        	sbc	FacMantissa+1		; subtract FAC1 mantissa 2
00BB6E  2  85 6B        	sta	ArgMantissa+1		; save FAC2 mantissa 2
00BB70  2               
00BB70  2  A5 6A        	lda	ArgMantissa		; get FAC2 mantissa 1
00BB72  2  E5 62        	sbc	FacMantissa		; subtract FAC1 mantissa 1
00BB74  2  85 6A        	sta	ArgMantissa		; save FAC2 mantissa 1
00BB76  2               
00BB76  2  98           	tya				; restore FAC2-FAC1 compare status
00BB77  2  4C 4F BB     	jmp	FAC2x2			;.				[BB4F]
00BB7A  2               
00BB7A  2               
00BB7A  2               A_BB7A:					;				[BB7A]
00BB7A  2  A9 40        	lda	#$40			;.
00BB7C  2  D0 CE        	bne	A_BB4C			; branch always
00BB7E  2               
00BB7E  2               
00BB7E  2               ; do A<<6, save as FAC1 rounding byte, normalise and return
00BB7E  2               ;
00BB7E  2               A_BB7E:					;				[BB7E]
00BB7E  2  0A           	asl				;.
00BB7F  2  0A           	asl				;.
00BB80  2  0A           	asl				;.
00BB81  2  0A           	asl				;.
00BB82  2  0A           	asl				;.
00BB83  2  0A           	asl				;.
00BB84  2  85 70        	sta	FACOV			; save FAC1 rounding byte
00BB86  2  28           	plp				; dump FAC2-FAC1 compare status
00BB87  2  4C 8F BB     	jmp	TempToFAC1		; copy temp to FAC1, normalise and
00BB8A  2               					; return			[BB8F]
00BB8A  2               ; do "Divide by zero" error
00BB8A  2               A_BB8A:					;				[BB8A]
00BB8A  2  A2 14        	ldx	#$14			; error $14, divide by zero error
00BB8C  2  4C 37 A4     	jmp	OutputErrMsg		; do error #X then warm start	[A437]
00BB8F  2               
00BB8F  2               TempToFAC1:				;				[BB8F]
00BB8F  2  A5 26        	lda	RESHO			; get temp mantissa 1
00BB91  2  85 62        	sta	FacMantissa		; save FAC1 mantissa 1
00BB93  2               
00BB93  2  A5 27        	lda	RESHO+1			; get temp mantissa 2
00BB95  2  85 63        	sta	FacMantissa+1		; save FAC1 mantissa 2
00BB97  2               
00BB97  2  A5 28        	lda	RESHO+2			; get temp mantissa 3
00BB99  2  85 64        	sta	FacMantissa+2		; save FAC1 mantissa 3
00BB9B  2               
00BB9B  2  A5 29        	lda	RESHO+3			; get temp mantissa 4
00BB9D  2  85 65        	sta	FacMantissa+3		; save FAC1 mantissa 4
00BB9F  2               
00BB9F  2  4C D7 B8     	jmp	NormaliseFAC1		; normalise FAC1 and return	[B8D7]
00BBA2  2               
00BBA2  2               
00BBA2  2               ;******************************************************************************
00BBA2  2               ;
00BBA2  2               ; unpack memory (AY) into FAC1
00BBA2  2               ;
00BBA2  2               UnpackAY2FAC1:				;				[BBA2]
00BBA2  2  85 22        	sta	INDEX			; save pointer LB
00BBA4  2  84 23        	sty	INDEX+1			; save pointer HB
00BBA6  2               
00BBA6  2  A0 04        	ldy	#$04			; 5 bytes to do
00BBA8  2  B1 22        	lda	(INDEX),Y		; get fifth byte
00BBAA  2  85 65        	sta	FacMantissa+3		; save FAC1 mantissa 4
00BBAC  2               
00BBAC  2  88           	dey				; decrement index
00BBAD  2  B1 22        	lda	(INDEX),Y		; get fourth byte
00BBAF  2  85 64        	sta	FacMantissa+2		; save FAC1 mantissa 3
00BBB1  2               
00BBB1  2  88           	dey				; decrement index
00BBB2  2  B1 22        	lda	(INDEX),Y		; get third byte
00BBB4  2  85 63        	sta	FacMantissa+1		; save FAC1 mantissa 2
00BBB6  2               
00BBB6  2  88           	dey				; decrement index
00BBB7  2  B1 22        	lda	(INDEX),Y		; get second byte
00BBB9  2  85 66        	sta	FACSGN			; save FAC1 sign (b7)
00BBBB  2               
00BBBB  2  09 80        	ora	#$80			; set 1xxx, (add normal bit)
00BBBD  2  85 62        	sta	FacMantissa		; save FAC1 mantissa 1
00BBBF  2               
00BBBF  2  88           	dey				; decrement index
00BBC0  2  B1 22        	lda	(INDEX),Y		; get first byte (exponent)
00BBC2  2  85 61        	sta	FACEXP			; save FAC1 exponent
00BBC4  2  84 70        	sty	FACOV			; clear FAC1 rounding byte
00BBC6  2               
00BBC6  2  60           	rts
00BBC7  2               
00BBC7  2               
00BBC7  2               ;******************************************************************************
00BBC7  2               ;
00BBC7  2               ; pack FAC1 into FacTempStor+5
00BBC7  2               ;
00BBC7  2               FAC1toTemp5:				;				[BBC7]
00BBC7  2  A2 5C        	ldx	#<(FacTempStor+5)	; set pointer LB
00BBC9  2  2C           .byte	$2C				; makes next line BIT FacTempStorA2
00BBCA  2               
00BBCA  2               
00BBCA  2               ;******************************************************************************
00BBCA  2               ;
00BBCA  2               ; pack FAC1 into FacTempStor
00BBCA  2               ;
00BBCA  2               FAC1toTemp:				;				[BBCA]
00BBCA  2  A2 57        	ldx	#<FacTempStor		; set pointer LB
00BBCC  2  A0 00        	ldy	#>FacTempStor		; set pointer HB
00BBCE  2  F0 04        	beq	PackFAC1intoXY		; pack FAC1 into (XY) and return,
00BBD0  2               					; branch always
00BBD0  2               
00BBD0  2               ;******************************************************************************
00BBD0  2               ;
00BBD0  2               ; pack FAC1 into variable pointer
00BBD0  2               ;
00BBD0  2               Fac1ToVarPtr:				;				[BBD0]
00BBD0  2  A6 49        	ldx	FORPNT			; get destination pointer LB
00BBD2  2  A4 4A        	ldy	FORPNT+1		; get destination pointer HB
00BBD4  2               
00BBD4  2               
00BBD4  2               ;******************************************************************************
00BBD4  2               ;
00BBD4  2               ; pack FAC1 into (XY)
00BBD4  2               ;
00BBD4  2               PackFAC1intoXY:				;				[BBD4]
00BBD4  2  20 1B BC     	jsr	RoundFAC1		; round FAC1			[BC1B]
00BBD7  2  86 22        	stx	INDEX			; save pointer LB
00BBD9  2  84 23        	sty	INDEX+1			; save pointer HB
00BBDB  2               
00BBDB  2  A0 04        	ldy	#$04			; set index
00BBDD  2  A5 65        	lda	FacMantissa+3		; get FAC1 mantissa 4
00BBDF  2  91 22        	sta	(INDEX),Y		; store in destination
00BBE1  2               
00BBE1  2  88           	dey				; decrement index
00BBE2  2  A5 64        	lda	FacMantissa+2		; get FAC1 mantissa 3
00BBE4  2  91 22        	sta	(INDEX),Y		; store in destination
00BBE6  2               
00BBE6  2  88           	dey				; decrement index
00BBE7  2  A5 63        	lda	FacMantissa+1		; get FAC1 mantissa 2
00BBE9  2  91 22        	sta	(INDEX),Y		; store in destination
00BBEB  2               
00BBEB  2  88           	dey				; decrement index
00BBEC  2  A5 66        	lda	FACSGN			; get FAC1 sign (b7)
00BBEE  2  09 7F        	ora	#$7F			; set bits x111 1111
00BBF0  2  25 62        	and	FacMantissa		; AND in FAC1 mantissa 1
00BBF2  2  91 22        	sta	(INDEX),Y		; store in destination
00BBF4  2               
00BBF4  2  88           	dey				; decrement index
00BBF5  2  A5 61        	lda	FACEXP			; get FAC1 exponent
00BBF7  2  91 22        	sta	(INDEX),Y		; store in destination
00BBF9  2  84 70        	sty	FACOV			; clear FAC1 rounding byte
00BBFB  2               
00BBFB  2  60           	rts
00BBFC  2               
00BBFC  2               
00BBFC  2               ;******************************************************************************
00BBFC  2               ;
00BBFC  2               ; copy FAC2 to FAC1
00BBFC  2               ;
00BBFC  2               CopyFAC2toFAC1:				;				[BBFC]
00BBFC  2  A5 6E        	lda	ARGSGN			; get FAC2 sign (b7)
00BBFE  2               
00BBFE  2               ; save FAC1 sign and copy ABS(FAC2) to FAC1
00BBFE  2               CpFAC2toFAC12:				;				[BBFE]
00BBFE  2  85 66        	sta	FACSGN			; save FAC1 sign (b7)
00BC00  2  A2 05        	ldx	#$05			; 5 bytes to copy
00BC02  2               A_BC02:					;				[BC02]
00BC02  2  B5 68        	lda	BITS,X			; get byte from FAC2,X
00BC04  2  95 60        	sta	FacTempStor+9,X		; save byte at FAC1,X
00BC06  2               
00BC06  2  CA           	dex				; decrement count
00BC07  2  D0 F9        	bne	A_BC02			; loop if not all done
00BC09  2               
00BC09  2  86 70        	stx	FACOV			; clear FAC1 rounding byte
00BC0B  2  60           	rts
00BC0C  2               
00BC0C  2               
00BC0C  2               ;******************************************************************************
00BC0C  2               ;
00BC0C  2               ; round and copy FAC1 to FAC2
00BC0C  2               ;
00BC0C  2               CopyFAC1toFAC2:				;				[BC0C]
00BC0C  2  20 1B BC     	jsr	RoundFAC1		; round FAC1			[BC1B]
00BC0F  2               
00BC0F  2               ; copy FAC1 to FAC2
00BC0F  2               CpFAC1toFAC22:				;				[BC0F]
00BC0F  2  A2 06        	ldx	#$06			; 6 bytes to copy
00BC11  2               A_BC11:					;				[BC11]
00BC11  2  B5 60        	lda	FacTempStor+9,X		; get byte from FAC1,X
00BC13  2  95 68        	sta	BITS,X			; save byte at FAC2,X
00BC15  2  CA           	dex				; decrement count
00BC16  2  D0 F9        	bne	A_BC11			; loop if not all done
00BC18  2               
00BC18  2  86 70        	stx	FACOV			; clear FAC1 rounding byte
00BC1A  2               A_BC1A:					;				[BC1A]
00BC1A  2  60           	rts
00BC1B  2               
00BC1B  2               
00BC1B  2               ;******************************************************************************
00BC1B  2               ;
00BC1B  2               ; round FAC1
00BC1B  2               ;
00BC1B  2               RoundFAC1:				;				[BC1B]
00BC1B  2  A5 61        	lda	FACEXP			; get FAC1 exponent
00BC1D  2  F0 FB        	beq	A_BC1A			; exit if zero
00BC1F  2               
00BC1F  2  06 70        	asl	FACOV			; shift FAC1 rounding byte
00BC21  2  90 F7        	bcc	A_BC1A			; exit if no overflow
00BC23  2               
00BC23  2               ; round FAC1 (no check)
00BC23  2               RoundFAC12:				;				[BC23]
00BC23  2  20 6F B9     	jsr	IncFAC1Mant		; increment FAC1 mantissa	[B96F]
00BC26  2  D0 F2        	bne	A_BC1A			; branch if no overflow
00BC28  2               
00BC28  2  4C 38 B9     	jmp	NormaliseFAC13		; nornalise FAC1 for C=1 and return
00BC2B  2               					;				[B938]
00BC2B  2               
00BC2B  2               ;******************************************************************************
00BC2B  2               ;
00BC2B  2               ; get FAC1 sign
00BC2B  2               ; return A = $FF, Cb = 1/-ve A = $01, Cb = 0/+ve, A = $00, Cb = ?/0
00BC2B  2               ;
00BC2B  2               GetFacSign:				;				[BC2B]
00BC2B  2  A5 61        	lda	FACEXP			; get FAC1 exponent
00BC2D  2  F0 09        	beq	A_BC38			; exit if zero (allready correct
00BC2F  2               					; SGN(0)=0)
00BC2F  2               
00BC2F  2               ;******************************************************************************
00BC2F  2               ;
00BC2F  2               ; return A = $FF, Cb = 1/-ve A = $01, Cb = 0/+ve
00BC2F  2               ; no = 0 check
00BC2F  2               ;
00BC2F  2               A_BC2F:					;				[BC2F]
00BC2F  2  A5 66        	lda	FACSGN			; else get FAC1 sign (b7)
00BC31  2               
00BC31  2               
00BC31  2               ;******************************************************************************
00BC31  2               ;
00BC31  2               ; return A = $FF, Cb = 1/-ve A = $01, Cb = 0/+ve
00BC31  2               ; no = 0 check, sign in A
00BC31  2               ;
00BC31  2               J_BC31:					;				[BC31]
00BC31  2  2A           	rol				; move sign bit to carry
00BC32  2  A9 FF        	lda	#$FF			; set byte for -ve result
00BC34  2  B0 02        	bcs	A_BC38			; return if sign was set (-ve)
00BC36  2               
00BC36  2  A9 01        	lda	#$01			; else set byte for +ve result
00BC38  2               A_BC38:					;				[BC38]
00BC38  2  60           	rts
00BC39  2               
00BC39  2               
00BC39  2               ;******************************************************************************
00BC39  2               ;
00BC39  2               ; perform SGN()
00BC39  2               ;
00BC39  2               bcSGN:					;				[BC39]
00BC39  2  20 2B BC     	jsr	GetFacSign		; get FAC1 sign, return A = $FF -ve,
00BC3C  2               					; A = $01 +ve			[BC2B]
00BC3C  2               
00BC3C  2               ;******************************************************************************
00BC3C  2               ;
00BC3C  2               ; save A as integer byte
00BC3C  2               ;
00BC3C  2               AtoInteger:				;				[BC3C]
00BC3C  2  85 62        	sta	FacMantissa		; save FAC1 mantissa 1
00BC3E  2               
00BC3E  2  A9 00        	lda	#$00			; clear A
00BC40  2  85 63        	sta	FacMantissa+1		; clear FAC1 mantissa 2
00BC42  2               
00BC42  2  A2 88        	ldx	#$88			; set exponent
00BC44  2               
00BC44  2               ; set exponent = X, clear FAC1 3 and 4 and normalise
00BC44  2               J_BC44:					;				[BC44]
00BC44  2  A5 62        	lda	FacMantissa		; get FAC1 mantissa 1
00BC46  2  49 FF        	eor	#$FF			; complement it
00BC48  2  2A           	rol				; sign bit into carry
00BC49  2               
00BC49  2               ; set exponent = X, clear mantissa 4 and 3 and normalise FAC1
00BC49  2               SetExpontIsX:				;				[BC49]
00BC49  2  A9 00        	lda	#$00			; clear A
00BC4B  2  85 65        	sta	FacMantissa+3		; clear FAC1 mantissa 4
00BC4D  2  85 64        	sta	FacMantissa+2		; clear FAC1 mantissa 3
00BC4F  2               
00BC4F  2               ; set exponent = X and normalise FAC1
00BC4F  2               J_BC4F:					;				[BC4F]
00BC4F  2  86 61        	stx	FACEXP			; set FAC1 exponent
00BC51  2  85 70        	sta	FACOV			; clear FAC1 rounding byte
00BC53  2  85 66        	sta	FACSGN			; clear FAC1 sign (b7)
00BC55  2               
00BC55  2  4C D2 B8     	jmp	AbsNormalFAC1		; do ABS and normalise FAC1	[B8D2]
00BC58  2               
00BC58  2               
00BC58  2               ;******************************************************************************
00BC58  2               ;
00BC58  2               ; perform ABS()
00BC58  2               ;
00BC58  2               bcABS:					;				[BC58]
00BC58  2  46 66        	lsr	FACSGN			; clear FAC1 sign, put zero in b7
00BC5A  2  60           	rts
00BC5B  2               
00BC5B  2               
00BC5B  2               ;******************************************************************************
00BC5B  2               ;
00BC5B  2               ; compare FAC1 with (AY)
00BC5B  2               ; returns A=$00 if FAC1 = (AY)
00BC5B  2               ; returns A=$01 if FAC1 > (AY)
00BC5B  2               ; returns A=$FF if FAC1 < (AY)
00BC5B  2               ;
00BC5B  2               CmpFAC1withAY:				;				[BC5B]
00BC5B  2  85 24        	sta	INDEX+2			; save pointer LB
00BC5D  2               CmpFAC1withAY2:				;				[BC5D]
00BC5D  2  84 25        	sty	INDEX+3			; save pointer HB
00BC5F  2               
00BC5F  2  A0 00        	ldy	#$00			; clear index
00BC61  2  B1 24        	lda	(INDEX+2),Y		; get exponent
00BC63  2  C8           	iny				; increment index
00BC64  2  AA           	tax				; copy (AY) exponent to X
00BC65  2  F0 C4        	beq	GetFacSign		; branch if (AY) exponent=0 and get FAC1
00BC67  2               					; sign A = $FF, Cb = 1/-ve, A = $01,
00BC67  2               					; Cb = 0/+ve
00BC67  2  B1 24        	lda	(INDEX+2),Y		; get (AY) mantissa 1, with sign
00BC69  2  45 66        	eor	FACSGN			; EOR FAC1 sign (b7)
00BC6B  2  30 C2        	bmi	A_BC2F			; if signs <> do return A = $FF,
00BC6D  2               					; Cb = 1/-ve, A = $01, Cb = 0/+ve and
00BC6D  2               					; return
00BC6D  2  E4 61        	cpx	FACEXP			; compare (AY) exponent with FAC1
00BC6F  2               					; exponent
00BC6F  2  D0 21        	bne	A_BC92			; branch if different
00BC71  2               
00BC71  2  B1 24        	lda	(INDEX+2),Y		; get (AY) mantissa 1, with sign
00BC73  2  09 80        	ora	#$80			; normalise top bit
00BC75  2  C5 62        	cmp	FacMantissa		; compare with FAC1 mantissa 1
00BC77  2  D0 19        	bne	A_BC92			; branch if different
00BC79  2               
00BC79  2  C8           	iny				; increment index
00BC7A  2  B1 24        	lda	(INDEX+2),Y		; get mantissa 2
00BC7C  2  C5 63        	cmp	FacMantissa+1		; compare with FAC1 mantissa 2
00BC7E  2  D0 12        	bne	A_BC92			; branch if different
00BC80  2               
00BC80  2  C8           	iny				; increment index
00BC81  2  B1 24        	lda	(INDEX+2),Y		; get mantissa 3
00BC83  2  C5 64        	cmp	FacMantissa+2		; compare with FAC1 mantissa 3
00BC85  2  D0 0B        	bne	A_BC92			; branch if different
00BC87  2               
00BC87  2  C8           	iny				; increment index
00BC88  2  A9 7F        	lda	#$7F			; set for 1/2 value rounding byte
00BC8A  2  C5 70        	cmp	FACOV			; compare with FAC1 rounding byte
00BC8C  2               					; (set carry)
00BC8C  2  B1 24        	lda	(INDEX+2),Y		; get mantissa 4
00BC8E  2  E5 65        	sbc	FacMantissa+3		; subtract FAC1 mantissa 4
00BC90  2  F0 28        	beq	A_BCBA			; exit if mantissa 4 equal
00BC92  2               
00BC92  2               ; gets here if number <> FAC1
00BC92  2               A_BC92:					;				[BC92]
00BC92  2  A5 66        	lda	FACSGN			; get FAC1 sign (b7)
00BC94  2  90 02        	bcc	A_BC98			; branch if FAC1 > (AY)
00BC96  2               
00BC96  2  49 FF        	eor	#$FF			; else toggle FAC1 sign
00BC98  2               A_BC98:					;				[BC98]
00BC98  2  4C 31 BC     	jmp	J_BC31			; return A = $FF, Cb = 1/-ve A = $01,
00BC9B  2               					; Cb = 0/+ve			[BC31]
00BC9B  2               
00BC9B  2               ;******************************************************************************
00BC9B  2               ;
00BC9B  2               ; convert FAC1 floating to fixed
00BC9B  2               ;
00BC9B  2               FAC1Float2Fix:				;				[BC9B]
00BC9B  2  A5 61        	lda	FACEXP			; get FAC1 exponent
00BC9D  2  F0 4A        	beq	A_BCE9			; if zero go clear FAC1 and return
00BC9F  2               
00BC9F  2  38           	sec				; set carry for subtract
00BCA0  2  E9 A0        	sbc	#$A0			; subtract maximum integer range
00BCA2  2               					; exponent
00BCA2  2  24 66        	bit	FACSGN			; test FAC1 sign (b7)
00BCA4  2  10 09        	bpl	A_BCAF			; branch if FAC1 +ve
00BCA6  2               
00BCA6  2               ; FAC1 was -ve
00BCA6  2  AA           	tax				; copy subtracted exponent
00BCA7  2  A9 FF        	lda	#$FF			; overflow for -ve number
00BCA9  2  85 68        	sta	BITS			; set FAC1 overfLB
00BCAB  2               
00BCAB  2  20 4D B9     	jsr	TwoComplFAC1		; twos complement FAC1 mantissa	[B94D]
00BCAE  2  8A           	txa				; restore subtracted exponent
00BCAF  2               A_BCAF:					;				[BCAF]
00BCAF  2  A2 61        	ldx	#$61			; set index to FAC1
00BCB1  2  C9 F9        	cmp	#$F9			; compare exponent result
00BCB3  2  10 06        	bpl	A_BCBB			; if < 8 shifts shift FAC1 A times right
00BCB5  2               					; and return
00BCB5  2  20 99 B9     	jsr	shftFACxAright		; shift FAC1 A times right (> 8 shifts)
00BCB8  2               					;				[B999]
00BCB8  2  84 68        	sty	BITS			; clear FAC1 overfLB
00BCBA  2               A_BCBA:					;				[BCBA]
00BCBA  2  60           	rts
00BCBB  2               
00BCBB  2               
00BCBB  2               ;******************************************************************************
00BCBB  2               ;
00BCBB  2               ; shift FAC1 A times right
00BCBB  2               ;
00BCBB  2               A_BCBB:					;				[BCBB]
00BCBB  2  A8           	tay				; copy shift count
00BCBC  2               
00BCBC  2  A5 66        	lda	FACSGN			; get FAC1 sign (b7)
00BCBE  2  29 80        	and	#$80			; mask sign bit only (x000 0000)
00BCC0  2  46 62        	lsr	FacMantissa		; shift FAC1 mantissa 1
00BCC2  2  05 62        	ora	FacMantissa		; OR sign in b7 FAC1 mantissa 1
00BCC4  2  85 62        	sta	FacMantissa		; save FAC1 mantissa 1
00BCC6  2               
00BCC6  2  20 B0 B9     	jsr	shftFACxYright		; shift FAC1 Y times right	[B9B0]
00BCC9  2  84 68        	sty	BITS			; clear FAC1 overfLB
00BCCB  2               
00BCCB  2  60           	rts
00BCCC  2               
00BCCC  2               
00BCCC  2               ;******************************************************************************
00BCCC  2               ;
00BCCC  2               ; perform INT()
00BCCC  2               ;
00BCCC  2               bcINT:					;				[BCCC]
00BCCC  2  A5 61        	lda	FACEXP			; get FAC1 exponent
00BCCE  2  C9 A0        	cmp	#$A0			; compare with max int
00BCD0  2  B0 20        	bcs	A_BCF2			; exit if >= (allready int, too big for
00BCD2  2               					; fractional part!)
00BCD2  2  20 9B BC     	jsr	FAC1Float2Fix		; convert FAC1 floating to fixed [BC9B]
00BCD5  2  84 70        	sty	FACOV			; save FAC1 rounding byte
00BCD7  2               
00BCD7  2  A5 66        	lda	FACSGN			; get FAC1 sign (b7)
00BCD9  2  84 66        	sty	FACSGN			; save FAC1 sign (b7)
00BCDB  2  49 80        	eor	#$80			; toggle FAC1 sign
00BCDD  2  2A           	rol				; shift into carry
00BCDE  2               
00BCDE  2  A9 A0        	lda	#$A0			; set new exponent
00BCE0  2  85 61        	sta	FACEXP			; save FAC1 exponent
00BCE2  2               
00BCE2  2  A5 65        	lda	FacMantissa+3		; get FAC1 mantissa 4
00BCE4  2  85 07        	sta	CHARAC			; save FAC1 mantissa 4 for power
00BCE6  2               					; function
00BCE6  2  4C D2 B8     	jmp	AbsNormalFAC1		; do ABS and normalise FAC1	[B8D2]
00BCE9  2               
00BCE9  2               
00BCE9  2               ;******************************************************************************
00BCE9  2               ;
00BCE9  2               ; clear FAC1 and return
00BCE9  2               ;
00BCE9  2               A_BCE9:					;				[BCE9]
00BCE9  2  85 62        	sta	FacMantissa		; clear FAC1 mantissa 1
00BCEB  2  85 63        	sta	FacMantissa+1		; clear FAC1 mantissa 2
00BCED  2  85 64        	sta	FacMantissa+2		; clear FAC1 mantissa 3
00BCEF  2  85 65        	sta	FacMantissa+3		; clear FAC1 mantissa 4
00BCF1  2               
00BCF1  2  A8           	tay				; clear Y
00BCF2  2               A_BCF2:					;				[BCF2]
00BCF2  2  60           	rts
00BCF3  2               
00BCF3  2               
00BCF3  2               ;******************************************************************************
00BCF3  2               ;
00BCF3  2               ; get FAC1 from string
00BCF3  2               ;
00BCF3  2               String2FAC1:				;				[BCF3]
00BCF3  2  A0 00        	ldy	#$00			; clear Y
00BCF5  2  A2 0A        	ldx	#$0A			; set index
00BCF7  2               A_BCF7:					;				[BCF7]
00BCF7  2  94 5D        	sty	FacTempStor+6,X		; clear byte
00BCF9  2               
00BCF9  2  CA           	dex				; decrement index
00BCFA  2  10 FB        	bpl	A_BCF7			; loop until numexp to negnum
00BCFC  2               					; (and FAC1 = $00)
00BCFC  2  90 0F        	bcc	A_BD0D			; branch if first character is numeric
00BCFE  2               
00BCFE  2  C9 2D        	cmp	#'-'			; else compare with "-"
00BD00  2  D0 04        	bne	A_BD06			; branch if not "-"
00BD02  2               
00BD02  2  86 67        	stx	SGNFLG			; set flag for -ve n (negnum = $FF)
00BD04  2  F0 04        	beq	J_BD0A			; branch always
00BD06  2               
00BD06  2               A_BD06:					;				[BD06]
00BD06  2  C9 2B        	cmp	#'+'			; else compare with "+"
00BD08  2  D0 05        	bne	A_BD0F			; branch if not "+"
00BD0A  2               
00BD0A  2               J_BD0A:					;				[BD0A]
00BD0A  2  20 73 00     	jsr	CHRGET			; increment and scan memory	[0073]
00BD0D  2               A_BD0D:					;				[BD0D]
00BD0D  2  90 5B        	bcc	A_BD6A			; branch if numeric character
00BD0F  2               
00BD0F  2               A_BD0F:					;				[BD0F]
00BD0F  2  C9 2E        	cmp	#'.'			; else compare with "."
00BD11  2  F0 2E        	beq	A_BD41			; branch if "."
00BD13  2               
00BD13  2  C9 45        	cmp	#'e'			; else compare with "E"
00BD15  2  D0 30        	bne	A_BD47			; branch if not "E"
00BD17  2               
00BD17  2               ; was "E" so evaluate exponential part
00BD17  2  20 73 00     	jsr	CHRGET			; increment and scan memory	[0073]
00BD1A  2  90 17        	bcc	A_BD33			; branch if numeric character
00BD1C  2               
00BD1C  2  C9 AB        	cmp	#TK_MINUS		; else compare with token for -
00BD1E  2  F0 0E        	beq	A_BD2E			; branch if token for -
00BD20  2               
00BD20  2  C9 2D        	cmp	#'-'			; else compare with "-"
00BD22  2  F0 0A        	beq	A_BD2E			; branch if "-"
00BD24  2               
00BD24  2  C9 AA        	cmp	#TK_PLUS		; else compare with token for +
00BD26  2  F0 08        	beq	J_BD30			; branch if token for +
00BD28  2               
00BD28  2  C9 2B        	cmp	#'+'			; else compare with "+"
00BD2A  2  F0 04        	beq	J_BD30			; branch if "+"
00BD2C  2               
00BD2C  2  D0 07        	bne	A_BD35			; branch always
00BD2E  2               
00BD2E  2               A_BD2E:					;				[BD2E]
00BD2E  2  66 60        	ror	FacTempStor+9		; set exponent -ve flag (C, which=1,
00BD30  2               					; into b7)
00BD30  2               J_BD30:					;				[BD30]
00BD30  2  20 73 00     	jsr	CHRGET			; increment and scan memory	[0073]
00BD33  2               A_BD33:					;				[BD33]
00BD33  2  90 5C        	bcc	A_BD91			; branch if numeric character
00BD35  2               
00BD35  2               A_BD35:					;				[BD35]
00BD35  2  24 60        	bit	FacTempStor+9		; test exponent -ve flag
00BD37  2  10 0E        	bpl	A_BD47			; if +ve go evaluate exponent
00BD39  2               
00BD39  2               ; else do exponent = -exponent
00BD39  2  A9 00        	lda	#$00			; clear result
00BD3B  2  38           	sec				; set carry for subtract
00BD3C  2  E5 5E        	sbc	FacTempStor+7		; subtract exponent byte
00BD3E  2               
00BD3E  2  4C 49 BD     	jmp	J_BD49			; go evaluate exponent		[BD49]
00BD41  2               
00BD41  2               A_BD41:					;				[BD41]
00BD41  2  66 5F        	ror	FacTempStor+8		; set decimal point flag
00BD43  2  24 5F        	bit	FacTempStor+8		; test decimal point flag
00BD45  2  50 C3        	bvc	J_BD0A			; branch if only one decimal point so
00BD47  2               					; far
00BD47  2               ; evaluate exponent
00BD47  2               A_BD47:					;				[BD47]
00BD47  2  A5 5E        	lda	FacTempStor+7		; get exponent count byte
00BD49  2               J_BD49:					;				[BD49]
00BD49  2  38           	sec				; set carry for subtract
00BD4A  2  E5 5D        	sbc	FacTempStor+6		; subtract numerator exponent
00BD4C  2  85 5E        	sta	FacTempStor+7		; save exponent count byte
00BD4E  2  F0 12        	beq	A_BD62			; branch if no adjustment
00BD50  2               
00BD50  2  10 09        	bpl	A_BD5B			; else if +ve go do FAC1*10^expcnt
00BD52  2               
00BD52  2               ; else go do FAC1/10^(0-expcnt)
00BD52  2               A_BD52:					;				[BD52]
00BD52  2  20 FE BA     	jsr	FAC1div10		; divide FAC1 by 10		[BAFE]
00BD55  2               
00BD55  2  E6 5E        	inc	FacTempStor+7		; increment exponent count byte
00BD57  2  D0 F9        	bne	A_BD52			; loop until all done
00BD59  2               
00BD59  2  F0 07        	beq	A_BD62			; branch always
00BD5B  2               
00BD5B  2               
00BD5B  2               A_BD5B:					;				[BD5B]
00BD5B  2  20 E2 BA     	jsr	Fac1x10			; multiply FAC1 by 10		[BAE2]
00BD5E  2               
00BD5E  2  C6 5E        	dec	FacTempStor+7		; decrement exponent count byte
00BD60  2  D0 F9        	bne	A_BD5B			; loop until all done
00BD62  2               
00BD62  2               A_BD62:					;				[BD62]
00BD62  2  A5 67        	lda	SGNFLG			; get -ve flag
00BD64  2  30 01        	bmi	A_BD67			; if -ve do - FAC1 and return
00BD66  2               
00BD66  2  60           	rts
00BD67  2               
00BD67  2               
00BD67  2               ;******************************************************************************
00BD67  2               ;
00BD67  2               ; do - FAC1 and return
00BD67  2               ;
00BD67  2               A_BD67:					;				[BD67]
00BD67  2  4C B4 BF     	jmp	bcGREATER		; do - FAC1			[BFB4]
00BD6A  2               
00BD6A  2               ; do unsigned FAC1*10+number
00BD6A  2               A_BD6A:					;				[BD6A]
00BD6A  2  48           	pha				; save character
00BD6B  2               
00BD6B  2  24 5F        	bit	FacTempStor+8		; test decimal point flag
00BD6D  2  10 02        	bpl	A_BD71			; skip exponent increment if not set
00BD6F  2               
00BD6F  2  E6 5D        	inc	FacTempStor+6		; else increment number exponent
00BD71  2               A_BD71:					;				[BD71]
00BD71  2  20 E2 BA     	jsr	Fac1x10			; multiply FAC1 by 10		[BAE2]
00BD74  2               
00BD74  2  68           	pla				; restore character
00BD75  2  38           	sec				; set carry for subtract
00BD76  2  E9 30        	sbc	#'0'			; convert to binary
00BD78  2  20 7E BD     	jsr	EvalNewDigit		; evaluate new ASCII digit	[BD7E]
00BD7B  2               
00BD7B  2  4C 0A BD     	jmp	J_BD0A			; go do next character		[BD0A]
00BD7E  2               
00BD7E  2               ; evaluate new ASCII digit
00BD7E  2               ; multiply FAC1 by 10 then (ABS) add in new digit
00BD7E  2               EvalNewDigit:				;				[BD7E]
00BD7E  2  48           	pha				; save digit
00BD7F  2               
00BD7F  2  20 0C BC     	jsr	CopyFAC1toFAC2		; round and copy FAC1 to FAC2	[BC0C]
00BD82  2               
00BD82  2  68           	pla				; restore digit
00BD83  2  20 3C BC     	jsr	AtoInteger		; save A as integer byte	[BC3C]
00BD86  2               
00BD86  2  A5 6E        	lda	ARGSGN			; get FAC2 sign (b7)
00BD88  2  45 66        	eor	FACSGN			; toggle with FAC1 sign (b7)
00BD8A  2  85 6F        	sta	ARISGN			; save sign compare (FAC1 EOR FAC2)
00BD8C  2               
00BD8C  2  A6 61        	ldx	FACEXP			; get FAC1 exponent
00BD8E  2  4C 6A B8     	jmp	bcPLUS			; add FAC2 to FAC1 and return	[B86A]
00BD91  2               
00BD91  2               ; evaluate next character of exponential part of number
00BD91  2               A_BD91:					;				[BD91]
00BD91  2  A5 5E        	lda	FacTempStor+7		; get exponent count byte
00BD93  2  C9 0A        	cmp	#$0A			; compare with 10 decimal
00BD95  2  90 09        	bcc	A_BDA0			; branch if less
00BD97  2               
00BD97  2  A9 64        	lda	#$64			; make all -ve exponents = -100 decimal
00BD99  2               					; (causes underflow)
00BD99  2  24 60        	bit	FacTempStor+9		; test exponent -ve flag
00BD9B  2  30 11        	bmi	A_BDAE			; branch if -ve
00BD9D  2               
00BD9D  2  4C 7E B9     	jmp	OverflowError		; else do overflow error then warm start
00BDA0  2               					;				[B97E]
00BDA0  2               A_BDA0:					;				[BDA0]
00BDA0  2  0A           	asl				; *2
00BDA1  2  0A           	asl				; *4
00BDA2  2  18           	clc				; clear carry for add
00BDA3  2  65 5E        	adc	FacTempStor+7		; *5
00BDA5  2  0A           	asl				; *10
00BDA6  2  18           	clc				; clear carry for add
00BDA7  2  A0 00        	ldy	#$00			; set index
00BDA9  2  71 7A        	adc	(TXTPTR),Y		; add character (will be $30 too much!)
00BDAB  2  38           	sec				; set carry for subtract
00BDAC  2  E9 30        	sbc	#'0'			; convert character to binary
00BDAE  2               A_BDAE:					;				[BDAE]
00BDAE  2  85 5E        	sta	FacTempStor+7		; save exponent count byte
00BDB0  2               
00BDB0  2  4C 30 BD     	jmp	J_BD30			; go get next character		[BD30]
00BDB3  2               
00BDB3  2               
00BDB3  2               ;******************************************************************************
00BDB3  2               ;
00BDB3  2               ; limits for scientific mode
00BDB3  2               ;
00BDB3  2               C99999999:				;				[BDB3]
00BDB3  2  9B 3E BC 1F  .byte	$9B,$3E,$BC,$1F,$FD		; 99999999.90625, maximum value with at
00BDB7  2  FD           
00BDB8  2               					; least one decimal
00BDB8  2               C999999999:				;				[BDB8]
00BDB8  2  9E 6E 6B 27  .byte	$9E,$6E,$6B,$27,$FD		; 999999999.25, maximum value before
00BDBC  2  FD           
00BDBD  2               					; scientific notation
00BDBD  2               C1000000000:				;				[BDBD]
00BDBD  2  9E 6E 6B 28  .byte	$9E,$6E,$6B,$28,$00		; 1000000000
00BDC1  2  00           
00BDC2  2               
00BDC2  2               
00BDC2  2               ;******************************************************************************
00BDC2  2               ;
00BDC2  2               ; do " IN " line number message
00BDC2  2               ;
00BDC2  2               Print_IN:				;				[BDC2]
00BDC2  2  A9 71        	lda	#<TxtIn			; set " IN " pointer LB
00BDC4  2  A0 A3        	ldy	#>TxtIn			; set " IN " pointer HB
00BDC6  2  20 DA BD     	jsr	OutputString0		; print null terminated string	[BDDA]
00BDC9  2               
00BDC9  2  A5 3A        	lda	CURLIN+1		; get the current line number HB
00BDCB  2  A6 39        	ldx	CURLIN			; get the current line number LB
00BDCD  2               
00BDCD  2               
00BDCD  2               ;******************************************************************************
00BDCD  2               ;
00BDCD  2               ; print XA as unsigned integer
00BDCD  2               ;
00BDCD  2               PrintXAasInt:				;				[BDCD]
00BDCD  2  85 62        	sta	FacMantissa		; save HB as FAC1 mantissa1
00BDCF  2  86 63        	stx	FacMantissa+1		; save LB as FAC1 mantissa2
00BDD1  2               S_BDD1:
00BDD1  2  A2 90        	ldx	#$90			; set exponent to 16d bits
00BDD3  2  38           	sec				; set integer is +ve flag
00BDD4  2  20 49 BC     	jsr	SetExpontIsX		; set exponent = X, clear mantissa 4
00BDD7  2               					; and 3 and normalise FAC1	[BC49]
00BDD7  2  20 DF BD     	jsr	FAC12String		; convert FAC1 to string	[BDDF]
00BDDA  2               OutputString0:				;				[BDDA]
00BDDA  2  4C 1E AB     	jmp	OutputString		; print null terminated string	[AB1E]
00BDDD  2               
00BDDD  2               
00BDDD  2               ;******************************************************************************
00BDDD  2               ;
00BDDD  2               ; convert FAC1 to ASCII string result in (AY)
00BDDD  2               ;
00BDDD  2               FAC1toASCII:				;				[BDDD]
00BDDD  2  A0 01        	ldy	#$01			; set index = 1
00BDDF  2               FAC12String:				;				[BDDF]
00BDDF  2  A9 20        	lda	#' '			; character = " " (assume +ve)
00BDE1  2  24 66        	bit	FACSGN			; test FAC1 sign (b7)
00BDE3  2  10 02        	bpl	A_BDE7			; branch if +ve
00BDE5  2               
00BDE5  2  A9 2D        	lda	#'-'			; else character = "-"
00BDE7  2               A_BDE7:					;				[BDE7]
00BDE7  2  99 FF 00     	sta	StrConvAddr,Y		; save leading character (" " or "-")
00BDEA  2  85 66        	sta	FACSGN			; save FAC1 sign (b7)
00BDEC  2  84 71        	sty	FBUFPT			; save index
00BDEE  2               
00BDEE  2  C8           	iny				; increment index
00BDEF  2               
00BDEF  2  A9 30        	lda	#'0'			; set character = "0"
00BDF1  2               
00BDF1  2  A6 61        	ldx	FACEXP			; get FAC1 exponent
00BDF3  2  D0 03        	bne	A_BDF8			; branch if FAC1<>0
00BDF5  2               
00BDF5  2               ; exponent was $00 so FAC1 is 0
00BDF5  2  4C 04 BF     	jmp	J_BF04			; save last character, [EOT] and exit
00BDF8  2               					;				[BF04]
00BDF8  2               
00BDF8  2               ; FAC1 is some non zero value
00BDF8  2               A_BDF8:					;				[BDF8]
00BDF8  2  A9 00        	lda	#$00			; clear (number exponent count)
00BDFA  2  E0 80        	cpx	#$80			; compare FAC1 exponent with $80
00BDFC  2               					; (<1.00000)
00BDFC  2  F0 02        	beq	A_BE00			; branch if 0.5 <= FAC1 < 1.0
00BDFE  2               
00BDFE  2  B0 09        	bcs	A_BE09			; branch if FAC1=>1
00BE00  2               
00BE00  2               A_BE00:					;				[BE00]
00BE00  2  A9 BD        	lda	#<C1000000000		; set 1000000000 pointer LB
00BE02  2  A0 BD        	ldy	#>C1000000000		; set 1000000000 pointer HB
00BE04  2  20 28 BA     	jsr	FAC1xAY			; do convert AY, FCA1*(AY)	[BA28]
00BE07  2               
00BE07  2  A9 F7        	lda	#$F7			; set number exponent count
00BE09  2               A_BE09:					;				[BE09]
00BE09  2  85 5D        	sta	FacTempStor+6		; save number exponent count
00BE0B  2               A_BE0B:					;				[BE0B]
00BE0B  2  A9 B8        	lda	#<C999999999		; set 999999999.25 pointer LB (max
00BE0D  2               					; before sci note)
00BE0D  2  A0 BD        	ldy	#>C999999999		; set 999999999.25 pointer HB
00BE0F  2  20 5B BC     	jsr	CmpFAC1withAY		; compare FAC1 with (AY)	[BC5B]
00BE12  2  F0 1E        	beq	A_BE32			; exit if FAC1 = (AY)
00BE14  2               
00BE14  2  10 12        	bpl	A_BE28			; go do /10 if FAC1 > (AY)
00BE16  2               
00BE16  2               ; FAC1 < (AY)
00BE16  2               A_BE16:					;				[BE16]
00BE16  2  A9 B3        	lda	#<C99999999		; set 99999999.90625 pointer LB
00BE18  2  A0 BD        	ldy	#>C99999999		; set 99999999.90625 pointer HB
00BE1A  2  20 5B BC     	jsr	CmpFAC1withAY		; compare FAC1 with (AY)	[BC5B]
00BE1D  2  F0 02        	beq	A_BE21			; branch if FAC1 = (AY) (allow decimal
00BE1F  2               					; places)
00BE1F  2  10 0E        	bpl	A_BE2F			; branch if FAC1 > (AY) (no decimal
00BE21  2               					; places)
00BE21  2               ; FAC1 <= (AY)
00BE21  2               A_BE21:					;				[BE21]
00BE21  2  20 E2 BA     	jsr	Fac1x10			; multiply FAC1 by 10		[BAE2]
00BE24  2               
00BE24  2  C6 5D        	dec	FacTempStor+6		; decrement number exponent count
00BE26  2  D0 EE        	bne	A_BE16			; go test again, branch always
00BE28  2               
00BE28  2               A_BE28:					;				[BE28]
00BE28  2  20 FE BA     	jsr	FAC1div10		; divide FAC1 by 10		[BAFE]
00BE2B  2               
00BE2B  2  E6 5D        	inc	FacTempStor+6		; increment number exponent count
00BE2D  2  D0 DC        	bne	A_BE0B			; go test again, branch always
00BE2F  2               
00BE2F  2               ; now we have just the digits to do
00BE2F  2               A_BE2F:					;				[BE2F]
00BE2F  2  20 49 B8     	jsr	FAC1plus05		; add 0.5 to FAC1 (round FAC1)	[B849]
00BE32  2               A_BE32:					;				[BE32]
00BE32  2  20 9B BC     	jsr	FAC1Float2Fix		; convert FAC1 floating to fixed [BC9B]
00BE35  2               
00BE35  2  A2 01        	ldx	#$01			; set default digits before dp = 1
00BE37  2               
00BE37  2  A5 5D        	lda	FacTempStor+6		; get number exponent count
00BE39  2  18           	clc				; clear carry for add
00BE3A  2  69 0A        	adc	#$0A			; up to 9 digits before point
00BE3C  2  30 09        	bmi	A_BE47			; if -ve then 1 digit before dp
00BE3E  2               
00BE3E  2  C9 0B        	cmp	#$0B			; A>=$0B if n>=1E9
00BE40  2  B0 06        	bcs	A_BE48			; branch if >= $0B
00BE42  2               
00BE42  2               ; carry is clear
00BE42  2  69 FF        	adc	#$FF			; take 1 from digit count
00BE44  2  AA           	tax				; copy to X
00BE45  2               
00BE45  2  A9 02        	lda	#$02			;.set exponent adjust
00BE47  2               A_BE47:					;				[BE47]
00BE47  2  38           	sec				; set carry for subtract
00BE48  2               A_BE48:					;				[BE48]
00BE48  2  E9 02        	sbc	#$02			; -2
00BE4A  2  85 5E        	sta	FacTempStor+7		;.save exponent adjust
00BE4C  2  86 5D        	stx	FacTempStor+6		; save digits before dp count
00BE4E  2               
00BE4E  2  8A           	txa				; copy to A
00BE4F  2  F0 02        	beq	A_BE53			; branch if no digits before dp
00BE51  2               
00BE51  2  10 13        	bpl	A_BE66			; branch if digits before dp
00BE53  2               
00BE53  2               A_BE53:					;				[BE53]
00BE53  2  A4 71        	ldy	FBUFPT			; get output string index
00BE55  2  A9 2E        	lda	#'.'			; character "."
00BE57  2  C8           	iny				; increment index
00BE58  2  99 FF 00     	sta	StrConvAddr,Y		; save to output string
00BE5B  2               
00BE5B  2  8A           	txa				;.
00BE5C  2  F0 06        	beq	A_BE64			;.
00BE5E  2               
00BE5E  2  A9 30        	lda	#'0'			; character "0"
00BE60  2  C8           	iny				; increment index
00BE61  2  99 FF 00     	sta	StrConvAddr,Y		; save to output string
00BE64  2               A_BE64:					;				[BE64]
00BE64  2  84 71        	sty	FBUFPT			; save output string index
00BE66  2               A_BE66:					;				[BE66]
00BE66  2  A0 00        	ldy	#$00			; clear index (point to 100,000)
00BE68  2               JiffyCnt2Str:				;				[BE68]
00BE68  2  A2 80        	ldx	#$80			;.
00BE6A  2               A_BE6A:					;				[BE6A]
00BE6A  2  A5 65        	lda	FacMantissa+3		; get FAC1 mantissa 4
00BE6C  2  18           	clc				; clear carry for add
00BE6D  2  79 19 BF     	adc	D_BF16+3,Y		; add byte 4, least significant
00BE70  2  85 65        	sta	FacMantissa+3		; save FAC1 mantissa4
00BE72  2               
00BE72  2  A5 64        	lda	FacMantissa+2		; get FAC1 mantissa 3
00BE74  2  79 18 BF     	adc	D_BF16+2,Y		; add byte 3
00BE77  2  85 64        	sta	FacMantissa+2		; save FAC1 mantissa3
00BE79  2               
00BE79  2  A5 63        	lda	FacMantissa+1		; get FAC1 mantissa 2
00BE7B  2  79 17 BF     	adc	D_BF16+1,Y		; add byte 2
00BE7E  2  85 63        	sta	FacMantissa+1		; save FAC1 mantissa2
00BE80  2               
00BE80  2  A5 62        	lda	FacMantissa		; get FAC1 mantissa 1
00BE82  2  79 16 BF     	adc	D_BF16+0,Y		; add byte 1, most significant
00BE85  2  85 62        	sta	FacMantissa		; save FAC1 mantissa1
00BE87  2               
00BE87  2  E8           	inx				; increment the digit, set the sign on
00BE88  2               					; the test sense bit
00BE88  2  B0 04        	bcs	A_BE8E			; if the carry is set go test if the
00BE8A  2               					; result was positive
00BE8A  2               ; else the result needs to be negative
00BE8A  2  10 DE        	bpl	A_BE6A			; not -ve so try again
00BE8C  2               
00BE8C  2  30 02        	bmi	A_BE90			; else done so return the digit
00BE8E  2               A_BE8E:					;				[BE8E]
00BE8E  2  30 DA        	bmi	A_BE6A			; not +ve so try again
00BE90  2               
00BE90  2               ; else done so return the digit
00BE90  2               A_BE90:					;				[BE90]
00BE90  2  8A           	txa				; copy the digit
00BE91  2  90 04        	bcc	A_BE97			; if Cb=0 just use it
00BE93  2               
00BE93  2  49 FF        	eor	#$FF			; else make the 2's complement ..
00BE95  2  69 0A        	adc	#$0A			; .. and subtract it from 10
00BE97  2               A_BE97:					;				[BE97]
00BE97  2  69 2F        	adc	#'0'-1			; add "0"-1 to result
00BE99  2               
00BE99  2  C8           	iny				; increment ..
00BE9A  2  C8           	iny				; .. index to..
00BE9B  2  C8           	iny				; .. next less ..
00BE9C  2  C8           	iny				; .. power of ten
00BE9D  2  84 47        	sty	VARPNT			; save current variable pointer LB
00BE9F  2               
00BE9F  2  A4 71        	ldy	FBUFPT			; get output string index
00BEA1  2  C8           	iny				; increment output string index
00BEA2  2               
00BEA2  2  AA           	tax				; copy character to X
00BEA3  2               
00BEA3  2  29 7F        	and	#$7F			; mask out top bit
00BEA5  2  99 FF 00     	sta	StrConvAddr,Y		; save to output string
00BEA8  2               
00BEA8  2  C6 5D        	dec	FacTempStor+6		; decrement # of characters before dp
00BEAA  2  D0 06        	bne	A_BEB2			; branch if still characters to do
00BEAC  2               
00BEAC  2               ; else output the point
00BEAC  2  A9 2E        	lda	#'.'			; character "."
00BEAE  2  C8           	iny				; increment output string index
00BEAF  2  99 FF 00     	sta	STACK-1,Y		; save to output string
00BEB2  2               A_BEB2:					;				[BEB2]
00BEB2  2  84 71        	sty	FBUFPT			; save output string index
00BEB4  2               
00BEB4  2  A4 47        	ldy	VARPNT			; get current variable pointer LB
00BEB6  2               
00BEB6  2  8A           	txa				; get character back
00BEB7  2  49 FF        	eor	#$FF			; toggle the test sense bit
00BEB9  2  29 80        	and	#$80			; clear the digit
00BEBB  2  AA           	tax				; copy it to the new digit
00BEBC  2               
00BEBC  2  C0 24        	cpy	#D_BF3A-D_BF16		; compare the table index with the max
00BEBE  2               					; for decimal numbers
00BEBE  2  F0 04        	beq	A_BEC4			; if at the max exit the digit loop
00BEC0  2               
00BEC0  2  C0 3C        	cpy	#D_BF52-D_BF16		; compare the table index with the max
00BEC2  2               					; for time
00BEC2  2  D0 A6        	bne	A_BE6A			; loop if not at the max
00BEC4  2               
00BEC4  2               ; now remove trailing zeroes
00BEC4  2               A_BEC4:					;				[BEC4]
00BEC4  2  A4 71        	ldy	FBUFPT			; restore the output string index
00BEC6  2               A_BEC6:					;				[BEC6]
00BEC6  2  B9 FF 00     	lda	STACK-1,Y		; get character from output string
00BEC9  2  88           	dey				; decrement output string index
00BECA  2  C9 30        	cmp	#'0'			; compare with "0"
00BECC  2  F0 F8        	beq	A_BEC6			; loop until non "0" character found
00BECE  2               
00BECE  2  C9 2E        	cmp	#'.'			; compare with "."
00BED0  2  F0 01        	beq	A_BED3			; branch if was dp
00BED2  2               
00BED2  2               ; restore last character
00BED2  2  C8           	iny				; increment output string index
00BED3  2               A_BED3:					;				[BED3]
00BED3  2  A9 2B        	lda	#'+'			; character "+"
00BED5  2               
00BED5  2  A6 5E        	ldx	FacTempStor+7		; get exponent count
00BED7  2  F0 2E        	beq	A_BF07			; if zero go set null terminator and
00BED9  2               					; exit
00BED9  2               ; exponent isn't zero so write exponent
00BED9  2  10 08        	bpl	A_BEE3			; branch if exponent count +ve
00BEDB  2               
00BEDB  2  A9 00        	lda	#$00			; clear A
00BEDD  2  38           	sec				; set carry for subtract
00BEDE  2  E5 5E        	sbc	FacTempStor+7		; subtract exponent count adjust
00BEE0  2               					; (convert -ve to +ve)
00BEE0  2  AA           	tax				; copy exponent count to X
00BEE1  2               
00BEE1  2  A9 2D        	lda	#'-'			; character "-"
00BEE3  2               A_BEE3:					;				[BEE3]
00BEE3  2  99 01 01     	sta	STACK+1,Y		; save to output string
00BEE6  2               
00BEE6  2  A9 45        	lda	#'e'			; character "E"
00BEE8  2  99 00 01     	sta	STACK,Y			; save exponent sign to output string
00BEEB  2               
00BEEB  2  8A           	txa				; get exponent count back
00BEEC  2               
00BEEC  2  A2 2F        	ldx	#'0'-1			; one less than "0" character
00BEEE  2  38           	sec				; set carry for subtract
00BEEF  2               A_BEEF:					;				[BEEF]
00BEEF  2  E8           	inx				; increment 10's character
00BEF0  2               
00BEF0  2  E9 0A        	sbc	#$0A			;.subtract 10 from exponent count
00BEF2  2  B0 FB        	bcs	A_BEEF			; loop while still >= 0
00BEF4  2               
00BEF4  2  69 3A        	adc	#':'			; add character ":" ($30+$0A, result is
00BEF6  2               					; 10 less that value)
00BEF6  2  99 03 01     	sta	STACK+3,Y		; save to output string
00BEF9  2               
00BEF9  2  8A           	txa				; copy 10's character
00BEFA  2  99 02 01     	sta	STACK+2,Y		; save to output string
00BEFD  2               
00BEFD  2  A9 00        	lda	#$00			; set null terminator
00BEFF  2  99 04 01     	sta	STACK+4,Y		; save to output string
00BF02  2  F0 08        	beq	A_BF0C			; go set string pointer (AY) and exit,
00BF04  2               					; branch always
00BF04  2               ; save last character, [EOT] and exit
00BF04  2               J_BF04:					;				[BF04]
00BF04  2  99 FF 00     	sta	STACK-1,Y		; save last character to output string
00BF07  2               
00BF07  2               ; set null terminator and exit
00BF07  2               A_BF07:					;				[BF07]
00BF07  2  A9 00        	lda	#$00			; set null terminator
00BF09  2  99 00 01     	sta	STACK,Y			; save after last character
00BF0C  2               
00BF0C  2               ; set string pointer (AY) and exit
00BF0C  2               A_BF0C:					;				[BF0C]
00BF0C  2  A9 00        	lda	#<STACK			; set result string pointer LB
00BF0E  2  A0 01        	ldy	#>STACK			; set result string pointer HB
00BF10  2  60           	rts
00BF11  2               
00BF11  2               
00BF11  2               ;******************************************************************************
00BF11  2               ;
00BF11  2               ; constants
00BF11  2               ;
00BF11  2               L_BF11:					;				[BF11]
00BF11  2  80 00        .byte	$80,$00				; 0.5, first two bytes
00BF13  2               L_BF13:					;				[BF13]
00BF13  2  00 00 00     .byte	$00,$00,$00			; null return for undefined variables
00BF16  2               
00BF16  2               D_BF16:					;				[BF16]
00BF16  2  FA 0A 1F 00  .byte	$FA,$0A,$1F,$00			; -100000000
00BF1A  2  00 98 96 80  .byte	$00,$98,$96,$80			;  +10000000
00BF1E  2  FF F0 BD C0  .byte	$FF,$F0,$BD,$C0			;   -1000000
00BF22  2  00 01 86 A0  .byte	$00,$01,$86,$A0			;    +100000
00BF26  2  FF FF D8 F0  .byte	$FF,$FF,$D8,$F0			;     -10000
00BF2A  2  00 00 03 E8  .byte	$00,$00,$03,$E8			;      +1000
00BF2E  2  FF FF FF 9C  .byte	$FF,$FF,$FF,$9C			;       -100
00BF32  2  00 00 00 0A  .byte	$00,$00,$00,$0A			;        +10
00BF36  2  FF FF FF FF  .byte	$FF,$FF,$FF,$FF			;         -1
00BF3A  2               
00BF3A  2               ; jiffy counts
00BF3A  2               D_BF3A:					;				[BF3A]
00BF3A  2  FF DF 0A 80  .byte	$FF,$DF,$0A,$80			; -2160000	10s hours
00BF3E  2  00 03 4B C0  .byte	$00,$03,$4B,$C0			;  +216000	    hours
00BF42  2  FF FF 73 60  .byte	$FF,$FF,$73,$60			;   -36000	10s mins
00BF46  2  00 00 0E 10  .byte	$00,$00,$0E,$10			;    +3600	    mins
00BF4A  2  FF FF FD A8  .byte	$FF,$FF,$FD,$A8			;     -600	10s secs
00BF4E  2  00 00 00 3C  .byte	$00,$00,$00,$3C			;      +60	    secs
00BF52  2               D_BF52:					;				[BF52]
00BF52  2               
00BF52  2               
00BF52  2  EC           .byte	$EC				; checksum byte
00BF53  2               
00BF53  2               
00BF53  2               ; spare bytes, not referenced
00BF53  2               
00BF53  2  AA AA AA AA  .byte	$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA
00BF57  2  AA AA AA AA  
00BF5B  2  AA AA AA AA  
00BF62  2  AA AA AA AA  .byte	$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA
00BF66  2  AA AA AA AA  
00BF6A  2  AA AA AA AA  
00BF71  2               
00BF71  2               
00BF71  2               ;******************************************************************************
00BF71  2               ;
00BF71  2               ; perform SQR()
00BF71  2               ;
00BF71  2               bcSQR:					;				[BF71]
00BF71  2  20 0C BC     	jsr	CopyFAC1toFAC2		; round and copy FAC1 to FAC2	[BC0C]
00BF74  2               
00BF74  2  A9 11        	lda	#<L_BF11		; set 0.5 pointer low address
00BF76  2  A0 BF        	ldy	#>L_BF11		; set 0.5 pointer high address
00BF78  2  20 A2 BB     	jsr	UnpackAY2FAC1		; unpack memory (AY) into FAC1	[BBA2]
00BF7B  2               
00BF7B  2               
00BF7B  2               ;******************************************************************************
00BF7B  2               ;
00BF7B  2               ; perform power function
00BF7B  2               ;
00BF7B  2               bcPOWER:				;				[BF7B]
00BF7B  2  F0 70        	beq	bcEXP			; perform EXP()
00BF7D  2               
00BF7D  2  A5 69        	lda	ARGEXP			; get FAC2 exponent
00BF7F  2  D0 03        	bne	A_BF84			; branch if FAC2<>0
00BF81  2               
00BF81  2  4C F9 B8     	jmp	ClrFAC1Exp		; clear FAC1 exponent and sign and
00BF84  2               					; return			[B8F9]
00BF84  2               A_BF84:					;				[BF84]
00BF84  2  A2 4E        	ldx	#<GarbagePtr		; set destination pointer LB
00BF86  2  A0 00        	ldy	#>GarbagePtr		; set destination pointer HB
00BF88  2  20 D4 BB     	jsr	PackFAC1intoXY		; pack FAC1 into (XY)		[BBD4]
00BF8B  2               
00BF8B  2  A5 6E        	lda	ARGSGN			; get FAC2 sign (b7)
00BF8D  2  10 0F        	bpl	A_BF9E			; branch if FAC2>0
00BF8F  2               
00BF8F  2               ; else FAC2 is -ve and can only be raised to an integer power which gives an
00BF8F  2               ; x + j0 result
00BF8F  2  20 CC BC     	jsr	bcINT			; perform INT()			[BCCC]
00BF92  2               
00BF92  2  A9 4E        	lda	#<GarbagePtr		; set source pointer LB
00BF94  2  A0 00        	ldy	#>GarbagePtr		; set source pointer HB
00BF96  2  20 5B BC     	jsr	CmpFAC1withAY		; compare FAC1 with (AY)	[BC5B]
00BF99  2  D0 03        	bne	A_BF9E			; branch if FAC1 <> (AY) to allow
00BF9B  2               					; Function Call error this will leave
00BF9B  2               					; FAC1 -ve and cause a Function Call
00BF9B  2               					; error when LOG() is called
00BF9B  2  98           	tya				; clear sign b7
00BF9C  2  A4 07        	ldy	CHARAC			; get FAC1 mantissa 4 from INT()
00BF9E  2               					; function as sign in Y for possible
00BF9E  2               					; later negation, b0 only needed
00BF9E  2               A_BF9E:					;				[BF9E]
00BF9E  2  20 FE BB     	jsr	CpFAC2toFAC12		; save FAC1 sign and copy ABS(FAC2) to
00BFA1  2               					; FAC1				[BBFE]
00BFA1  2  98           	tya				; copy sign back ..
00BFA2  2  48           	pha				; .. and save it
00BFA3  2               
00BFA3  2  20 EA B9     	jsr	bcLOG			; perform LOG()			[B9EA]
00BFA6  2               
00BFA6  2  A9 4E        	lda	#<GarbagePtr		; set pointer LB
00BFA8  2  A0 00        	ldy	#>GarbagePtr		; set pointer HB
00BFAA  2  20 28 BA     	jsr	FAC1xAY			; do convert AY, FCA1*(AY)	[BA28]
00BFAD  2               
00BFAD  2  20 ED BF     	jsr	bcEXP			; perform EXP()			[BFED]
00BFB0  2               
00BFB0  2  68           	pla				; pull sign from stack
00BFB1  2  4A           	lsr				; b0 is to be tested
00BFB2  2  90 0A        	bcc	A_BFBE			; if no bit then exit
00BFB4  2               
00BFB4  2               ; do - FAC1
00BFB4  2               bcGREATER:				;				[BFB4]
00BFB4  2  A5 61        	lda	FACEXP			; get FAC1 exponent
00BFB6  2  F0 06        	beq	A_BFBE			; exit if FAC1_e = $00
00BFB8  2               
00BFB8  2  A5 66        	lda	FACSGN			; get FAC1 sign (b7)
00BFBA  2  49 FF        	eor	#$FF			; complement it
00BFBC  2  85 66        	sta	FACSGN			; save FAC1 sign (b7)
00BFBE  2               A_BFBE:					;				[BFBE]
00BFBE  2  60           	rts
00BFBF  2               
00BFBF  2               
00BFBF  2               ;******************************************************************************
00BFBF  2               ;
00BFBF  2               ; exp(n) constant and series
00BFBF  2               ;
00BFBF  2               ConstantEXP:				;				[BFBF]
00BFBF  2  81 38 AA 3B  .byte	$81,$38,$AA,$3B,$29		; 1.443
00BFC3  2  29           
00BFC4  2               
00BFC4  2               TblEXPseries:				;				[BFC4]
00BFC4  2  07           .byte	$07				; series count
00BFC5  2  71 34 58 3E  .byte	$71,$34,$58,$3E,$56		; 2.14987637E-5
00BFC9  2  56           
00BFCA  2  74 16 7E B3  .byte	$74,$16,$7E,$B3,$1B		; 1.43523140E-4
00BFCE  2  1B           
00BFCF  2  77 2F EE E3  .byte	$77,$2F,$EE,$E3,$85		; 1.34226348E-3
00BFD3  2  85           
00BFD4  2  7A 1D 84 1C  .byte	$7A,$1D,$84,$1C,$2A		; 9.61401701E-3
00BFD8  2  2A           
00BFD9  2  7C 63 59 58  .byte	$7C,$63,$59,$58,$0A		; 5.55051269E-2
00BFDD  2  0A           
00BFDE  2  7E 75 FD E7  .byte	$7E,$75,$FD,$E7,$C6		; 2.40226385E-1
00BFE2  2  C6           
00BFE3  2  80 31 72 18  .byte	$80,$31,$72,$18,$10		; 6.93147186E-1
00BFE7  2  10           
00BFE8  2  81 00 00 00  .byte	$81,$00,$00,$00,$00		; 1.00000000
00BFEC  2  00           
00BFED  2               
00BFED  2               
00BFED  2               ;******************************************************************************
00BFED  2               ;
00BFED  2               ; perform EXP()
00BFED  2               ;
00BFED  2               bcEXP:					;				[BFED]
00BFED  2  A9 BF        	lda	#<ConstantEXP		; set 1.443 pointer LB
00BFEF  2  A0 BF        	ldy	#>ConstantEXP		; set 1.443 pointer HB
00BFF1  2  20 28 BA     	jsr	FAC1xAY			; do convert AY, FCA1*(AY)	[BA28]
00BFF4  2               
00BFF4  2  A5 70        	lda	FACOV			; get FAC1 rounding byte
00BFF6  2  69 50        	adc	#$50			; +$50/$100
00BFF8  2  90 03        	bcc	A_BFFD			; skip rounding if no carry
00BFFA  2               
00BFFA  2  20 23 BC     	jsr	RoundFAC12		; round FAC1 (no check)		[BC23]
00BFFD  2               A_BFFD:					;				[BFFD]
00BFFD  2  4C 00 E0     	jmp	bcEXP2			; continue EXP()		[E000]
00C000  2               
00C000  2               
00C000  2               
00C000  1               
00C000  1               ;.include "C64-kerV1mod.a65"
00C000  1               
00C000  1               ;.include "C64-kerV2mod.a65"
00C000  1               
00C000  1               .include "C64-kerV3mod.a65"
00C000  2               ;******************************************************************************
00C000  2               ;******************************************************************************
00C000  2               ;
00C000  2               ;         The almost completely commented C64 BASIC ROM disassembly.
00C000  2               ;                 Based on version V1.01 by Lee Davison 2012
00C000  2               ;
00C000  2               ;******************************************************************************
00C000  2               ;
00C000  2               ; start of the kernal ROM
00C000  2               ;
00C000  2               ; version 901227-01
00C000  2               ;
00C000  2               ; version 901227-02
00C000  2               ;
00C000  2               ; version 901227-03
00C000  2               
00C000  2               .org	$E000
00E000  2               
00E000  2               ;******************************************************************************
00E000  2               ;
00E000  2               ; EXP() continued
00E000  2               ;
00E000  2               bcEXP2:					;				[E000]
00E000  2  85 56        	sta	Jump0054+2		; save FAC2 rounding byte
00E002  2               
00E002  2  20 0F BC     	jsr	CpFAC1toFAC22		; copy FAC1 to FAC2		[BC0F]
00E005  2               
00E005  2  A5 61        	lda	FACEXP			; get FAC1 exponent
00E007  2  C9 88        	cmp	#$88			; less than EXP limit?
00E009  2  90 03        	bcc	A_E00E			; yes, ->
00E00B  2               A_E00B:					;				[E00B]
00E00B  2  20 D4 BA     	jsr	HndlOvUnFlErr		; handle overflow and underflow	[BAD4]
00E00E  2               A_E00E:					;				[E00E]
00E00E  2  20 CC BC     	jsr	bcINT			; perform INT()			[BCCC]
00E011  2  A5 07        	lda	CHARAC			; get mantissa 4 from INT()
00E013  2  18           	clc				; clear carry for add
00E014  2  69 81        	adc	#$81			; normalise +1, result $00?
00E016  2  F0 F3        	beq	A_E00B			; yes, -> go handle it
00E018  2               
00E018  2  38           	sec				; set carry for subtract
00E019  2  E9 01        	sbc	#$01			; exponent now correct
00E01B  2  48           	pha				; save FAC2 exponent
00E01C  2               					; swap FAC1 and FAC2
00E01C  2  A2 05        	ldx	#$05			; 4 bytes to do
00E01E  2               A_E01E:					;				[E01E]
00E01E  2  B5 69        	lda	ARGEXP,X		; get FAC2,X
00E020  2  B4 61        	ldy	FACEXP,X		; get FAC1,X
00E022  2  95 61        	sta	FACEXP,X		; save FAC1,X
00E024  2  94 69        	sty	ARGEXP,X		; save FAC2,X
00E026  2  CA           	dex				; decrement count/index
00E027  2  10 F5        	bpl	A_E01E			; loop if not all done
00E029  2               
00E029  2  A5 56        	lda	Jump0054+2		; get FAC2 rounding byte
00E02B  2  85 70        	sta	FACOV			; save as FAC1 rounding byte
00E02D  2               
00E02D  2  20 53 B8     	jsr	bcMINUS			; perform subtraction, FAC2 from FAC1
00E030  2               					;				[B853]
00E030  2  20 B4 BF     	jsr	bcGREATER		; do - FAC1			[BFB4]
00E033  2               
00E033  2  A9 C4        	lda	#<TblEXPseries		; set counter pointer LB
00E035  2  A0 BF        	ldy	#>TblEXPseries		; set counter pointer HB
00E037  2  20 59 E0     	jsr	CalcPolynome		; go do series evaluation	[E059]
00E03A  2               
00E03A  2  A9 00        	lda	#$00			; clear A
00E03C  2  85 6F        	sta	ARISGN			; clear sign compare (FAC1 EOR FAC2)
00E03E  2               
00E03E  2  68           	pla				;.get saved FAC2 exponent
00E03F  2  20 B9 BA     	jsr	TestAdjFACs2		; test and adjust accumulators	[BAB9]
00E042  2               
00E042  2  60           	rts
00E043  2               
00E043  2               
00E043  2               ;******************************************************************************
00E043  2               ;
00E043  2               ; ^2 then series evaluation
00E043  2               ;
00E043  2               Power2:					;				[E043]
00E043  2  85 71        	sta	FBUFPT			; save count pointer LB
00E045  2  84 72        	sty	FBUFPT+1		; save count pointer HB
00E047  2               
00E047  2  20 CA BB     	jsr	FAC1toTemp		; pack FAC1 into FacTempStor	[BBCA]
00E04A  2               
00E04A  2  A9 57        	lda	#<FacTempStor		; set pointer LB (Y already $00)
00E04C  2  20 28 BA     	jsr	FAC1xAY			; do convert AY, FCA1*(AY)	[BA28]
00E04F  2               
00E04F  2  20 5D E0     	jsr	CalcPolynome2		; go do series evaluation	[E05D]
00E052  2               
00E052  2  A9 57        	lda	#<FacTempStor		; pointer to original # LB
00E054  2  A0 00        	ldy	#>FacTempStor		; pointer to original # HB
00E056  2  4C 28 BA     	jmp	FAC1xAY			; do convert AY, FCA1*(AY)	[BA28]
00E059  2               
00E059  2               
00E059  2               ;******************************************************************************
00E059  2               ;
00E059  2               ; do series evaluation
00E059  2               ;
00E059  2               CalcPolynome:				;				[E059]
00E059  2  85 71        	sta	FBUFPT			; save count pointer LB
00E05B  2  84 72        	sty	FBUFPT+1		; save count pointer HB
00E05D  2               
00E05D  2               CalcPolynome2:				;				[E05D]
00E05D  2  20 C7 BB     	jsr	FAC1toTemp5		; pack FAC1 into FacTempStor+5	[BBC7]
00E060  2               
00E060  2  B1 71        	lda	(FBUFPT),Y		; get constants count
00E062  2  85 67        	sta	SGNFLG			; save constants count
00E064  2               
00E064  2  A4 71        	ldy	FBUFPT			; get count pointer LB
00E066  2  C8           	iny				; increment it (now constants pointer)
00E067  2  98           	tya				; copy it, result = 0?
00E068  2  D0 02        	bne	A_E06C			; no, -> skip next INC
00E06A  2               
00E06A  2  E6 72        	inc	FBUFPT+1		; else increment HB
00E06C  2               A_E06C:					;				[E06C]
00E06C  2  85 71        	sta	FBUFPT			; save LB
00E06E  2               
00E06E  2  A4 72        	ldy	FBUFPT+1		; get HB
00E070  2               A_E070:					;				[E070]
00E070  2  20 28 BA     	jsr	FAC1xAY			; do convert AY, FCA1*(AY)	[BA28]
00E073  2               
00E073  2  A5 71        	lda	FBUFPT			; get constants pointer LB
00E075  2  A4 72        	ldy	FBUFPT+1		; get constants pointer HB
00E077  2  18           	clc				; clear carry for add
00E078  2  69 05        	adc	#$05			; add 5 to low pointer (5 bytes per
00E07A  2               					; constant)
00E07A  2  90 01        	bcc	A_E07D			; skip next if no overflow
00E07C  2               
00E07C  2  C8           	iny				; increment HB
00E07D  2               A_E07D:					;				[E07D]
00E07D  2  85 71        	sta	FBUFPT			; save pointer LB
00E07F  2  84 72        	sty	FBUFPT+1		; save pointer HB
00E081  2               
00E081  2  20 67 B8     	jsr	AddFORvar2FAC1		; add (AY) to FAC1		[B867]
00E084  2               
00E084  2  A9 5C        	lda	#<(FacTempStor+5)	; set pointer low byte to partial
00E086  2  A0 00        	ldy	#>(FacTempStor+5)	; set pointer high byte to partial
00E088  2               
00E088  2  C6 67        	dec	SGNFLG			; decrement constants count, done all?
00E08A  2  D0 E4        	bne	A_E070			; no, -> more...
00E08C  2               
00E08C  2  60           	rts
00E08D  2               
00E08D  2               
00E08D  2               ;******************************************************************************
00E08D  2               ;
00E08D  2               ; RND values
00E08D  2               ;
00E08D  2               ConstRNDmult:				;				[E08D]
00E08D  2  98 35 44 7A  .byte	$98,$35,$44,$7A,$00		; 11879546		multiplier
00E091  2  00           
00E092  2               
00E092  2               ConstRNDoffs:				;				[E092]
00E092  2  68 28 B1 46  .byte	$68,$28,$B1,$46,$00		; 3.927677739E-8	offset
00E096  2  00           
00E097  2               
00E097  2               
00E097  2               ;******************************************************************************
00E097  2               ;
00E097  2               ; perform RND()
00E097  2               ;
00E097  2               bcRND:					;				[E097]
00E097  2  20 2B BC     	jsr	GetFacSign		; get FAC1 sign			[BC2B]
00E09A  2               					; return A = $FF -ve, A = $01 +ve
00E09A  2  30 37        	bmi	A_E0D3			; if (n < 0) copy byte swapped FAC1 into
00E09C  2               					; RND() seed
00E09C  2  D0 20        	bne	A_E0BE			; if (n > 0) get next number in RND()
00E09E  2               					; sequence
00E09E  2               ; else n=0 so get the RND() number from CIA 1 timers
00E09E  2  20 F3 FF     	jsr	GetAddrIoDevs		; return base address of I/O devices
00E0A1  2               					;				[FFF3]
00E0A1  2  86 22        	stx	INDEX			; save pointer LB
00E0A3  2  84 23        	sty	INDEX+1			; save pointer HB
00E0A5  2               
00E0A5  2  A0 04        	ldy	#$04			; set index to T1 LB
00E0A7  2  B1 22        	lda	(INDEX),Y		; get T1 LB
00E0A9  2  85 62        	sta	FacMantissa		; save FAC1 mantissa 1
00E0AB  2               
00E0AB  2  C8           	iny				; increment index
00E0AC  2  B1 22        	lda	(INDEX),Y		; get T1 HB
00E0AE  2  85 64        	sta	FacMantissa+2		; save FAC1 mantissa 3
00E0B0  2               
00E0B0  2  A0 08        	ldy	#$08			; set index to T2 LB
00E0B2  2  B1 22        	lda	(INDEX),Y		; get T2 LB
00E0B4  2  85 63        	sta	FacMantissa+1		; save FAC1 mantissa 2
00E0B6  2               
00E0B6  2  C8           	iny				; increment index
00E0B7  2  B1 22        	lda	(INDEX),Y		; get T2 HB
00E0B9  2  85 65        	sta	FacMantissa+3		; save FAC1 mantissa 4
00E0BB  2               
00E0BB  2  4C E3 E0     	jmp	J_E0E3			; set exponent and exit		[E0E3]
00E0BE  2               
00E0BE  2               
00E0BE  2               A_E0BE:					;				[E0BE]
00E0BE  2  A9 8B        	lda	#<RND_seed		; set seed pointer low address
00E0C0  2  A0 00        	ldy	#>RND_seed		; set seed pointer high address
00E0C2  2  20 A2 BB     	jsr	UnpackAY2FAC1		; unpack memory (AY) into FAC1	[BBA2]
00E0C5  2               
00E0C5  2  A9 8D        	lda	#<ConstRNDmult		; set 11879546 pointer LB
00E0C7  2  A0 E0        	ldy	#>ConstRNDmult		; set 11879546 pointer HB
00E0C9  2  20 28 BA     	jsr	FAC1xAY			; do convert AY, FCA1*(AY)	[BA28]
00E0CC  2               
00E0CC  2  A9 92        	lda	#<ConstRNDoffs		; set 3.927677739E-8 pointer LB
00E0CE  2  A0 E0        	ldy	#>ConstRNDoffs		; set 3.927677739E-8 pointer HB
00E0D0  2  20 67 B8     	jsr	AddFORvar2FAC1		; add (AY) to FAC1		[B867]
00E0D3  2               A_E0D3:					;				[E0D3]
00E0D3  2  A6 65        	ldx	FacMantissa+3		; get FAC1 mantissa 4
00E0D5  2  A5 62        	lda	FacMantissa		; get FAC1 mantissa 1
00E0D7  2  85 65        	sta	FacMantissa+3		; save FAC1 mantissa 4
00E0D9  2  86 62        	stx	FacMantissa		; save FAC1 mantissa 1
00E0DB  2               
00E0DB  2  A6 63        	ldx	FacMantissa+1		; get FAC1 mantissa 2
00E0DD  2  A5 64        	lda	FacMantissa+2		; get FAC1 mantissa 3
00E0DF  2  85 63        	sta	FacMantissa+1		; save FAC1 mantissa 2
00E0E1  2  86 64        	stx	FacMantissa+2		; save FAC1 mantissa 3
00E0E3  2               J_E0E3:					;				[E0E3]
00E0E3  2  A9 00        	lda	#$00			; clear byte
00E0E5  2  85 66        	sta	FACSGN			; clear FAC1 sign (always +ve)
00E0E7  2               
00E0E7  2  A5 61        	lda	FACEXP			; get FAC1 exponent
00E0E9  2  85 70        	sta	FACOV			; save FAC1 rounding byte
00E0EB  2               
00E0EB  2  A9 80        	lda	#$80			; set exponent = $80
00E0ED  2  85 61        	sta	FACEXP			; save FAC1 exponent
00E0EF  2               
00E0EF  2  20 D7 B8     	jsr	NormaliseFAC1		; normalise FAC1		[B8D7]
00E0F2  2               
00E0F2  2  A2 8B        	ldx	#<RND_seed		; set seed pointer low address
00E0F4  2  A0 00        	ldy	#>RND_seed		; set seed pointer high address
00E0F6  2               
00E0F6  2               
00E0F6  2               ;******************************************************************************
00E0F6  2               ;
00E0F6  2               ; pack FAC1 into (XY)
00E0F6  2               ;
00E0F6  2               PackFAC1intoXY0:			;				[E0F6]
00E0F6  2  4C D4 BB     	jmp	PackFAC1intoXY		; pack FAC1 into (XY)		[BBD4]
00E0F9  2               
00E0F9  2               
00E0F9  2               ;******************************************************************************
00E0F9  2               ;
00E0F9  2               ; handle BASIC I/O error
00E0F9  2               ;
00E0F9  2               HndlBasIoErr:				;				[E0F9]
00E0F9  2  C9 F0        	cmp	#$F0			; error = $F0?
00E0FB  2  D0 07        	bne	A_E104			; no, ->
00E0FD  2               
00E0FD  2  84 38        	sty	MEMSIZ+1		; set end of memory HB
00E0FF  2  86 37        	stx	MEMSIZ			; set end of memory LB
00E101  2               
00E101  2  4C 63 A6     	jmp	bcCLR3			; clear from start to end and return
00E104  2               					;				[A663]
00E104  2               ; error was not $F0
00E104  2               A_E104:					;				[E104]
00E104  2  AA           	tax				; copy error #, zero?
00E105  2  D0 02        	bne	A_E109			; no, ->
00E107  2               
00E107  2  A2 1E        	ldx	#$1E			; else error $1E, break error
00E109  2               A_E109:					;				[E109]
00E109  2  4C 37 A4     	jmp	OutputErrMsg		; do error #X then warm start	[A437]
00E10C  2               
00E10C  2               
00E10C  2               ;******************************************************************************
00E10C  2               ;
00E10C  2               ; output character to channel with error check
00E10C  2               ;
00E10C  2               OutCharErrChan:				;				[E10C]
00E10C  2  20 D2 FF     	jsr	OutByteChan		; output character to channel	[FFD2]
00E10F  2  B0 E8        	bcs	HndlBasIoErr		; if error go handle BASIC I/O error
00E111  2               
00E111  2  60           	rts
00E112  2               
00E112  2               
00E112  2               ;******************************************************************************
00E112  2               ;
00E112  2               ; input character from channel with error check
00E112  2               ;
00E112  2               InpCharErrChan:				;				[E112]
00E112  2  20 CF FF     	jsr	ByteFromChan		; input character from channel	[FFCF]
00E115  2  B0 E2        	bcs	HndlBasIoErr		; if error go handle BASIC I/O error
00E117  2               
00E117  2  60           	rts
00E118  2               
00E118  2               
00E118  2               ;******************************************************************************
00E118  2               ;
00E118  2               ; open channel for output with error check
00E118  2               ;
00E118  2               OpenChan4OutpA:				;				[E118]
00E118  2               .if KERNAL = 1
00E118  2               	jsr	OpenChan4Outp		; open channel for output	[FFC9]
00E118  2                     .out "KERNAL01"
00E118  2               .endif
00E118  2               
00E118  2               .if KERNAL = 2 || KERNAL = 3
00E118  2  20 AD E4     	jsr	OpenChan4OutpB		; open channel for output	[E4AD]
00E11B  2                     .out "KERNAL02"
00E11B  2               .endif
00E11B  2               
00E11B  2  B0 DC        	bcs	HndlBasIoErr		; if error go handle BASIC I/O error
00E11D  2               
00E11D  2  60           	rts
00E11E  2               
00E11E  2               
00E11E  2               ;******************************************************************************
00E11E  2               ;
00E11E  2               ; open channel for input with error check
00E11E  2               ;
00E11E  2               OpenChan4Inp0:				;				[E11E]
00E11E  2  20 C6 FF     	jsr	OpenChan4Inp		; open channel for input	[FFC6]
00E121  2  B0 D6        	bcs	HndlBasIoErr		; if error go handle BASIC I/O error
00E123  2               
00E123  2  60           	rts
00E124  2               
00E124  2               
00E124  2               ;******************************************************************************
00E124  2               ;
00E124  2               ; get character from input device with error check
00E124  2               ;
00E124  2               GetCharFromIO:				;				[E124]
00E124  2  20 E4 FF     	jsr	GetCharInpDev		; get character from input device [FFE4]
00E127  2  B0 D0        	bcs	HndlBasIoErr		; if error go handle BASIC I/O error
00E129  2               
00E129  2  60           	rts
00E12A  2               
00E12A  2               
00E12A  2               ;******************************************************************************
00E12A  2               ;
00E12A  2               ; perform SYS
00E12A  2               ;
00E12A  2               bcSYS:					;				[E12A]
00E12A  2  20 8A AD     	jsr	EvalExpression		; evaluate expression and check is
00E12D  2               					; numeric, else do type mismatch [AD8A]
00E12D  2  20 F7 B7     	jsr	FAC1toTmpInt		; convert FAC_1 to integer in temporary
00E130  2               					; integer			[B7F7]
00E130  2  A9 E1        	lda	#>(bcSYS2-1)		; get return address HB
00E132  2  48           	pha				; push as return address
00E133  2               
00E133  2  A9 46        	lda	#<(bcSYS2-1)		; get return address LB
00E135  2  48           	pha				; push as return address
00E136  2               
00E136  2  AD 0F 03     	lda	SPREG			; get saved status register
00E139  2  48           	pha				; put on stack
00E13A  2               
00E13A  2  AD 0C 03     	lda	SAREG			; get saved A
00E13D  2  AE 0D 03     	ldx	SXREG			; get saved X
00E140  2  AC 0E 03     	ldy	SYREG			; get saved Y
00E143  2               
00E143  2  28           	plp				; pull processor status
00E144  2               
00E144  2  6C 14 00     	jmp	(LINNUM)		; call SYS address
00E147  2               
00E147  2               ; tail end of SYS code
00E147  2               bcSYS2:					;				[E147]
00E147  2  08           	php				; save status
00E148  2               
00E148  2  8D 0C 03     	sta	SAREG			; save returned A
00E14B  2  8E 0D 03     	stx	SXREG			; save returned X
00E14E  2  8C 0E 03     	sty	SYREG			; save returned Y
00E151  2               
00E151  2  68           	pla				; restore saved status
00E152  2  8D 0F 03     	sta	SPREG			; save status
00E155  2               
00E155  2  60           	rts
00E156  2               
00E156  2               
00E156  2               ;******************************************************************************
00E156  2               ;
00E156  2               ; perform SAVE
00E156  2               ;
00E156  2               bcSAVE:					;				[E156]
00E156  2  20 D4 E1     	jsr	GetParmLoadSav		; get parameters for LOAD/SAVE	[E1D4]
00E159  2               S_E159:
00E159  2  A6 2D        	ldx	VARTAB			; get start of variables LB
00E15B  2  A4 2E        	ldy	VARTAB+1		; get start of variables HB
00E15D  2  A9 2B        	lda	#TXTTAB			; index to start of program memory
00E15F  2  20 D8 FF     	jsr	SaveRamToDev		; save RAM to device, A = index to start
00E162  2               					; address low/high address, XY = end
00E162  2               					;				[FFD8]
00E162  2  B0 95        	bcs	HndlBasIoErr		; if error go handle BASIC I/O error
00E164  2               
00E164  2  60           	rts
00E165  2               
00E165  2               
00E165  2               ;******************************************************************************
00E165  2               ;
00E165  2               ; perform VERIFY
00E165  2               ;
00E165  2               bcVERIFY:				;				[E165]
00E165  2  A9 01        	lda	#$01			; flag verify
00E167  2  2C           .byte	$2C				; makes next line BIT $00A9
00E168  2               
00E168  2               
00E168  2               ;******************************************************************************
00E168  2               ;
00E168  2               ; perform LOAD
00E168  2               ;
00E168  2               bcLOAD:					;				[E168]
00E168  2  A9 00        	lda	#$00			; flag load
00E16A  2  85 0A        	sta	LoadVerify		; set load/verify flag
00E16C  2               
00E16C  2  20 D4 E1     	jsr	GetParmLoadSav		; get parameters for LOAD/SAVE	[E1D4]
00E16F  2               S_E16F:
00E16F  2  A5 0A        	lda	LoadVerify		; get load/verify flag
00E171  2  A6 2B        	ldx	TXTTAB			; get start of memory LB
00E173  2  A4 2C        	ldy	TXTTAB+1		; get start of memory HB
00E175  2  20 D5 FF     	jsr	LoadRamFrmDev		; load RAM from a device	[FFD5]
00E178  2  B0 57        	bcs	A_E1D1			; if error go handle BASIC I/O error
00E17A  2               
00E17A  2  A5 0A        	lda	LoadVerify		; get load/verify flag
00E17C  2  F0 17        	beq	ReadyBasic		; branch if load
00E17E  2               
00E17E  2  A2 1C        	ldx	#$1C			; error $1C, verify error
00E180  2  20 B7 FF     	jsr	ReadIoStatus		; read I/O status word		[FFB7]
00E183  2  29 10        	and	#$10			; mask for tape read error
00E185  2  D0 17        	bne	A_E19E			; branch if read error
00E187  2               
00E187  2  A5 7A        	lda	TXTPTR			; get the BASIC execute pointer LB
00E189  2  C9 02        	cmp	#$02			; ??? how is TXTPTR used here?
00E18B  2  F0 07        	beq	A_E194			; if ??, -> skip "OK" prompt
00E18D  2               
00E18D  2  A9 64        	lda	#<TxtOK			; set "OK" pointer LB
00E18F  2  A0 A3        	ldy	#>TxtOK			; set "OK" pointer HB
00E191  2  4C 1E AB     	jmp	OutputString		; print null terminated string	[AB1E]
00E194  2               
00E194  2               A_E194:					;				[E194]
00E194  2  60           	rts
00E195  2               
00E195  2               
00E195  2               ;******************************************************************************
00E195  2               ;
00E195  2               ; do READY return to BASIC
00E195  2               ;
00E195  2               ReadyBasic:				;				[E195]
00E195  2  20 B7 FF     	jsr	ReadIoStatus		; read I/O status word		[FFB7]
00E198  2  29 BF        	and	#$BF			; clear read error, error found?
00E19A  2  F0 05        	beq	A_E1A1			; no, ->
00E19C  2               S_E19C:
00E19C  2  A2 1D        	ldx	#$1D			; error $1D, load error
00E19E  2               A_E19E:					;				[E19E]
00E19E  2  4C 37 A4     	jmp	OutputErrMsg		; do error #X then warm start	[A437]
00E1A1  2               
00E1A1  2               A_E1A1:					;				[E1A1]
00E1A1  2  A5 7B        	lda	TXTPTR+1		; get BASIC execute pointer HB
00E1A3  2  C9 02        	cmp	#$02			; immediate mode?
00E1A5  2  D0 0E        	bne	A_E1B5			; no, ->
00E1A7  2               
00E1A7  2  86 2D        	stx	VARTAB			; set start of variables LB
00E1A9  2  84 2E        	sty	VARTAB+1		; set start of variables HB
00E1AB  2               
00E1AB  2  A9 76        	lda	#<TxtReady		; set "READY." pointer LB
00E1AD  2  A0 A3        	ldy	#>TxtReady		; set "READY." pointer HB
00E1AF  2  20 1E AB     	jsr	OutputString		; print null terminated string	[AB1E]
00E1B2  2               
00E1B2  2  4C 2A A5     	jmp	J_A52A			; reset execution, clear variables,
00E1B5  2               					; flush stack, rebuild BASIC chain and
00E1B5  2               					; do warm start			[A52A]
00E1B5  2               A_E1B5:					;				[E1B5]
00E1B5  2  20 8E A6     	jsr	SetBasExecPtr		; set BASIC execute pointer to start of
00E1B8  2               					; memory-1			[A68E]
00E1B8  2  20 33 A5     	jsr	BindLine		; rebuild BASIC line chaining	[A533]
00E1BB  2  4C 77 A6     	jmp	bcCLR4			; rebuild BASIC line chaining, do
00E1BE  2               					; RESTORE and return		[A677]
00E1BE  2               
00E1BE  2               
00E1BE  2               ;******************************************************************************
00E1BE  2               ;
00E1BE  2               ; perform OPEN
00E1BE  2               ;
00E1BE  2               bcOPEN:					;				[E1BE]
00E1BE  2  20 19 E2     	jsr	GetParmOpenClo		; get parameters for OPEN/CLOSE	[E219]
00E1C1  2               
00E1C1  2  20 C0 FF     	jsr	OpenLogFile		; open a logical file		[FFC0]
00E1C4  2  B0 0B        	bcs	A_E1D1			; branch if error
00E1C6  2               
00E1C6  2  60           	rts
00E1C7  2               
00E1C7  2               
00E1C7  2               ;******************************************************************************
00E1C7  2               ;
00E1C7  2               ; perform CLOSE
00E1C7  2               ;
00E1C7  2               bcCLOSE:				;				[E1C7]
00E1C7  2  20 19 E2     	jsr	GetParmOpenClo		; get parameters for OPEN/CLOSE	[E219]
00E1CA  2               
00E1CA  2  A5 49        	lda	FORPNT			; get logical file number
00E1CC  2  20 C3 FF     	jsr	CloseLogFile		; close a specified logical file [FFC3]
00E1CF  2  90 C3        	bcc	A_E194			; exit if no error
00E1D1  2               
00E1D1  2               A_E1D1:					;				[E1D1]
00E1D1  2  4C F9 E0     	jmp	HndlBasIoErr		; go handle BASIC I/O error	[E0F9]
00E1D4  2               
00E1D4  2               
00E1D4  2               ;******************************************************************************
00E1D4  2               ;
00E1D4  2               ; get parameters for LOAD/SAVE
00E1D4  2               ;
00E1D4  2               GetParmLoadSav:				;				[E1D4]
00E1D4  2  A9 00        	lda	#$00			; clear filename length
00E1D6  2  20 BD FF     	jsr	SetFileName		; clear the filename		[FFBD]
00E1D9  2               
00E1D9  2  A2 01        	ldx	#$01			; set default device number, cassette
00E1DB  2  A0 00        	ldy	#$00			; set default command
00E1DD  2  20 BA FF     	jsr	SetAddresses		; set logical, first and second
00E1E0  2               					; addresses			[FFBA]
00E1E0  2  20 06 E2     	jsr	ExitIfEotColl		; exit function if [EOT] or ":"	[E206]
00E1E3  2  20 57 E2     	jsr	GetFileName		; get filename			[E257]
00E1E6  2  20 06 E2     	jsr	ExitIfEotColl		; exit function if [EOT] or ":"	[E206]
00E1E9  2  20 00 E2     	jsr	GetByte			; scan and get byte, else do syntax
00E1EC  2               					; error then warm start		[E200]
00E1EC  2  A0 00        	ldy	#$00			; clear command
00E1EE  2               
00E1EE  2  86 49        	stx	FORPNT			; save device number
00E1F0  2               
00E1F0  2  20 BA FF     	jsr	SetAddresses		; set logical, first and second
00E1F3  2               					; addresses			[FFBA]
00E1F3  2  20 06 E2     	jsr	ExitIfEotColl		; exit function if [EOT] or ":"	[E206]
00E1F6  2               
00E1F6  2  20 00 E2     	jsr	GetByte			; scan and get byte, else do syntax
00E1F9  2               					; error then warm start		[E200]
00E1F9  2  8A           	txa				; copy command to A
00E1FA  2  A8           	tay				; copy command to Y
00E1FB  2               
00E1FB  2  A6 49        	ldx	FORPNT			; get device number back
00E1FD  2  4C BA FF     	jmp	SetAddresses		; set logical, first and second
00E200  2               					; addresses and return		[FFBA]
00E200  2               
00E200  2               
00E200  2               ;******************************************************************************
00E200  2               ;
00E200  2               ; scan and get byte, else do syntax error then warm start
00E200  2               ;
00E200  2               GetByte:				;				[E200]
00E200  2  20 0E E2     	jsr	Chk4ValidByte		; scan for ",byte", else do syntax error
00E203  2               					; then warm start		[E20E]
00E203  2  4C 9E B7     	jmp	GetByteParm2		; get byte parameter and return	[B79E]
00E206  2               
00E206  2               
00E206  2               ;******************************************************************************
00E206  2               ;
00E206  2               ; exit function if [EOT] or ":"
00E206  2               ;
00E206  2               ExitIfEotColl:				;				[E206]
00E206  2  20 79 00     	jsr	CHRGOT			; scan memory, [EOL] or ":"?	[0079]
00E209  2  D0 02        	bne	A_E20D			; no, ->
00E20B  2               
00E20B  2  68           	pla				; dump return address LB
00E20C  2  68           	pla				; dump return address HB
00E20D  2               A_E20D:					;				[E20D]
00E20D  2  60           	rts
00E20E  2               
00E20E  2               
00E20E  2               ;******************************************************************************
00E20E  2               ;
00E20E  2               ; scan for ",valid byte", else do syntax error then warm start
00E20E  2               ;
00E20E  2               Chk4ValidByte:				;				[E20E]
00E20E  2  20 FD AE     	jsr	Chk4Comma		; scan for ",", else do syntax error
00E211  2               					; then warm start		[AEFD]
00E211  2               
00E211  2               
00E211  2               ;******************************************************************************
00E211  2               ;
00E211  2               ; scan for valid byte, not [EOL] or ":", else do syntax error then warm start
00E211  2               ;
00E211  2               Chk4ValidByte2:				;				[E211]
00E211  2  20 79 00     	jsr	CHRGOT			; scan memory, another char?	[0079]
00E214  2  D0 F7        	bne	A_E20D			; yes, -> OK
00E216  2               
00E216  2  4C 08 AF     	jmp	SyntaxError		; syntax error and warm start	[AF08]
00E219  2               
00E219  2               
00E219  2               ;******************************************************************************
00E219  2               ;
00E219  2               ; get parameters for OPEN/CLOSE
00E219  2               ;
00E219  2               GetParmOpenClo:				;				[E219]
00E219  2  A9 00        	lda	#$00			; clear the filename length
00E21B  2  20 BD FF     	jsr	SetFileName		; clear the filename		[FFBD]
00E21E  2  20 11 E2     	jsr	Chk4ValidByte2		; scan for valid byte, else do syntax
00E221  2               					; error then warm start		[E211]
00E221  2               
00E221  2  20 9E B7     	jsr	GetByteParm2		; get byte parameter, logical file
00E224  2               					; number			[B79E]
00E224  2  86 49        	stx	FORPNT			; save logical file number
00E226  2  8A           	txa				; copy logical file number to A
00E227  2               
00E227  2  A2 01        	ldx	#$01			; set default device number, cassette
00E229  2  A0 00        	ldy	#$00			; set default command
00E22B  2  20 BA FF     	jsr	SetAddresses		; set logical, first and second
00E22E  2               					; addresses			[FFBA]
00E22E  2  20 06 E2     	jsr	ExitIfEotColl		; exit function if [EOT] or ":"	[E206]
00E231  2               
00E231  2  20 00 E2     	jsr	GetByte			; scan and get byte, else do syntax
00E234  2               					; error then warm start		[E200]
00E234  2  86 4A        	stx	FORPNT+1		; save device number
00E236  2               
00E236  2  A0 00        	ldy	#$00			; clear command
00E238  2  A5 49        	lda	FORPNT			; get logical file number
00E23A  2               
00E23A  2  E0 03        	cpx	#$03			; compare device number with screen
00E23C  2  90 01        	bcc	A_E23F			; branch if less than screen
00E23E  2               
00E23E  2  88           	dey				; else decrement command
00E23F  2               A_E23F:					;				[E23F]
00E23F  2  20 BA FF     	jsr	SetAddresses		; set logical, first and second
00E242  2               					; addresses			[FFBA]
00E242  2  20 06 E2     	jsr	ExitIfEotColl		; exit function if [EOT] or ":"	[E206]
00E245  2  20 00 E2     	jsr	GetByte			; scan and get byte, else do syntax
00E248  2               					; error then warm start		[E200]
00E248  2  8A           	txa				; copy command to A
00E249  2  A8           	tay				; copy command to Y
00E24A  2               
00E24A  2  A6 4A        	ldx	FORPNT+1		; get device number
00E24C  2  A5 49        	lda	FORPNT			; get logical file number
00E24E  2  20 BA FF     	jsr	SetAddresses		; set logical, first and second
00E251  2               					; addresses			[FFBA]
00E251  2               
00E251  2  20 06 E2     	jsr	ExitIfEotColl		; exit function if [EOT] or ":"	[E206]
00E254  2  20 0E E2     	jsr	Chk4ValidByte		; scan for ",byte", else do syntax
00E257  2               					; error then warm start		[E20E]
00E257  2               
00E257  2               
00E257  2               ;******************************************************************************
00E257  2               ;
00E257  2               ; set filename
00E257  2               ;
00E257  2               GetFileName:				;				[E257]
00E257  2  20 9E AD     	jsr	EvaluateValue		; evaluate expression		[AD9E]
00E25A  2  20 A3 B6     	jsr	EvalString		; evaluate string		[B6A3]
00E25D  2               
00E25D  2  A6 22        	ldx	INDEX			; get string pointer LB
00E25F  2  A4 23        	ldy	INDEX+1			; get string pointer HB
00E261  2  4C BD FF     	jmp	SetFileName		; set the filename and return	[FFBD]
00E264  2               
00E264  2               
00E264  2               ;******************************************************************************
00E264  2               ;
00E264  2               ; perform COS()
00E264  2               ;
00E264  2               bcCOS:					;				[E264]
00E264  2  A9 E0        	lda	#<ConstPIdiv2		; set pi/2 pointer LB
00E266  2  A0 E2        	ldy	#>ConstPIdiv2		; set pi/2 pointer HB
00E268  2  20 67 B8     	jsr	AddFORvar2FAC1		; add (AY) to FAC1		[B867]
00E26B  2               
00E26B  2               
00E26B  2               ;******************************************************************************
00E26B  2               ;
00E26B  2               ; perform SIN()
00E26B  2               ;
00E26B  2               bcSIN:					;				[E26B]
00E26B  2  20 0C BC     	jsr	CopyFAC1toFAC2		; round and copy FAC1 to FAC2	[BC0C]
00E26E  2               
00E26E  2  A9 E5        	lda	#<ConstPIx2		; set 2*pi pointer LB
00E270  2  A0 E2        	ldy	#>ConstPIx2		; set 2*pi pointer HB
00E272  2  A6 6E        	ldx	ARGSGN			; get FAC2 sign (b7)
00E274  2  20 07 BB     	jsr	FAC1divAY		; divide by (AY) (X=sign)	[BB07]
00E277  2               
00E277  2  20 0C BC     	jsr	CopyFAC1toFAC2		; round and copy FAC1 to FAC2	[BC0C]
00E27A  2  20 CC BC     	jsr	bcINT			; perform INT()			[BCCC]
00E27D  2               
00E27D  2  A9 00        	lda	#$00			; clear byte
00E27F  2  85 6F        	sta	ARISGN			; clear sign compare (FAC1 EOR FAC2)
00E281  2               
00E281  2  20 53 B8     	jsr	bcMINUS			; perform subtraction, FAC2 from FAC1
00E284  2               					;				[B853]
00E284  2  A9 EA        	lda	#<Const025		; set 0.25 pointer LB
00E286  2  A0 E2        	ldy	#>Const025		; set 0.25 pointer HB
00E288  2  20 50 B8     	jsr	AYminusFAC1		; perform subtraction, FAC1 from (AY)
00E28B  2               					;				[B850]
00E28B  2  A5 66        	lda	FACSGN			; get FAC1 sign (b7)
00E28D  2  48           	pha				; save FAC1 sign
00E28E  2  10 0D        	bpl	bcSIN2			; branch if +ve
00E290  2               
00E290  2               ; FAC1 sign was -ve
00E290  2  20 49 B8     	jsr	FAC1plus05		; add 0.5 to FAC1 (round FAC1)	[B849]
00E293  2               
00E293  2  A5 66        	lda	FACSGN			; get FAC1 sign (b7), negative?
00E295  2  30 09        	bmi	A_E2A0			; yes, ->
00E297  2               
00E297  2  A5 12        	lda	TANSGN			; get the comparison evaluation flag
00E299  2  49 FF        	eor	#$FF			; toggle flag
00E29B  2  85 12        	sta	TANSGN			; save the comparison evaluation flag
00E29D  2               bcSIN2:					;				[E29D]
00E29D  2  20 B4 BF     	jsr	bcGREATER		; do - FAC1			[BFB4]
00E2A0  2               A_E2A0:					;				[E2A0]
00E2A0  2  A9 EA        	lda	#<Const025		; set 0.25 pointer LB
00E2A2  2  A0 E2        	ldy	#>Const025		; set 0.25 pointer HB
00E2A4  2  20 67 B8     	jsr	AddFORvar2FAC1		; add (AY) to FAC1		[B867]
00E2A7  2               
00E2A7  2  68           	pla				; restore FAC1 sign, positive
00E2A8  2  10 03        	bpl	A_E2AD			; yes, ->
00E2AA  2               
00E2AA  2               ; else correct FAC1
00E2AA  2  20 B4 BF     	jsr	bcGREATER		; do - FAC1			[BFB4]
00E2AD  2               A_E2AD:					;				[E2AD]
00E2AD  2  A9 EF        	lda	#<ConstVCosSin		; set pointer LB to counter
00E2AF  2  A0 E2        	ldy	#>ConstVCosSin		; set pointer HB to counter
00E2B1  2  4C 43 E0     	jmp	Power2			; ^2 then series evaluation and return
00E2B4  2               					;				[E043]
00E2B4  2               
00E2B4  2               
00E2B4  2               ;******************************************************************************
00E2B4  2               ;
00E2B4  2               ; perform TAN()
00E2B4  2               ;
00E2B4  2               bcTAN:					;				[E2B4]
00E2B4  2  20 CA BB     	jsr	FAC1toTemp		; pack FAC1 into FacTempStor	[BBCA]
00E2B7  2               
00E2B7  2  A9 00        	lda	#$00			; clear A
00E2B9  2  85 12        	sta	TANSGN			; clear the comparison evaluation flag
00E2BB  2               
00E2BB  2  20 6B E2     	jsr	bcSIN			; perform SIN()			[E26B]
00E2BE  2               
00E2BE  2  A2 4E        	ldx	#<GarbagePtr		; set sin(n) pointer LB
00E2C0  2  A0 00        	ldy	#>GarbagePtr		; set sin(n) pointer HB
00E2C2  2  20 F6 E0     	jsr	PackFAC1intoXY0		; pack FAC1 into (XY)		[E0F6]
00E2C5  2               
00E2C5  2  A9 57        	lda	#<FacTempStor		; set n pointer LB
00E2C7  2  A0 00        	ldy	#>FacTempStor		; set n pointer HB
00E2C9  2  20 A2 BB     	jsr	UnpackAY2FAC1		; unpack memory (AY) into FAC1	[BBA2]
00E2CC  2               
00E2CC  2  A9 00        	lda	#$00			; clear byte
00E2CE  2  85 66        	sta	FACSGN			; clear FAC1 sign (b7)
00E2D0  2               
00E2D0  2  A5 12        	lda	TANSGN			; get the comparison evaluation flag
00E2D2  2  20 DC E2     	jsr	bcTAN2			; save flag and go do series evaluation
00E2D5  2               					;				[E2DC]
00E2D5  2  A9 4E        	lda	#<GarbagePtr		; set sin(n) pointer LB
00E2D7  2  A0 00        	ldy	#>GarbagePtr		; set sin(n) pointer HB
00E2D9  2  4C 0F BB     	jmp	AYdivFAC1		; convert AY and do (AY)/FAC1	[BB0F]
00E2DC  2               
00E2DC  2               
00E2DC  2               ;******************************************************************************
00E2DC  2               ;
00E2DC  2               ; save comparison flag and do series evaluation
00E2DC  2               
00E2DC  2               bcTAN2:					;				[E2DC]
00E2DC  2  48           	pha				; save comparison flag
00E2DD  2  4C 9D E2     	jmp	bcSIN2			; add 0.25, ^2 then series evaluation
00E2E0  2               					;				[E29D]
00E2E0  2               
00E2E0  2               
00E2E0  2               ;******************************************************************************
00E2E0  2               ;
00E2E0  2               ; constants and series for SIN/COS(n)
00E2E0  2               ;
00E2E0  2               ConstPIdiv2:				;				[E2E0]
00E2E0  2  81 49 0F DA  .byte	$81,$49,$0F,$DA,$A2		; 1.570796371, pi/2, as floating number
00E2E4  2  A2           
00E2E5  2               ConstPIx2:				;				[E2E5]
00E2E5  2  83 49 0F DA  .byte	$83,$49,$0F,$DA,$A2		; 6.28319, 2*pi, as floating number
00E2E9  2  A2           
00E2EA  2               Const025:				;				[E2EA]
00E2EA  2  7F 00 00 00  .byte	$7F,$00,$00,$00,$00		; 0.25
00E2EE  2  00           
00E2EF  2               
00E2EF  2               ConstVCosSin:				;				[E2EF]
00E2EF  2  05           .byte	$05				; series counter
00E2F0  2  84 E6 1A 2D  .byte	$84,$E6,$1A,$2D,$1B		; -14.3813907
00E2F4  2  1B           
00E2F5  2  86 28 07 FB  .byte	$86,$28,$07,$FB,$F8		;  42.0077971
00E2F9  2  F8           
00E2FA  2  87 99 68 89  .byte	$87,$99,$68,$89,$01		; -76.7041703
00E2FE  2  01           
00E2FF  2  87 23 35 DF  .byte	$87,$23,$35,$DF,$E1		;  81.6052237
00E303  2  E1           
00E304  2  86 A5 5D E7  .byte	$86,$A5,$5D,$E7,$28		; -41.3417021
00E308  2  28           
00E309  2  83 49 0F DA  .byte	$83,$49,$0F,$DA,$A2		;  6.28318531
00E30D  2  A2           
00E30E  2               
00E30E  2               
00E30E  2               ;******************************************************************************
00E30E  2               ;
00E30E  2               ; perform ATN()
00E30E  2               
00E30E  2               bcATN:					;				[E30E]
00E30E  2  A5 66        	lda	FACSGN			; get FAC1 sign (b7)
00E310  2  48           	pha				; save sign, positive?
00E311  2  10 03        	bpl	A_E316			; yes, ->
00E313  2               
00E313  2  20 B4 BF     	jsr	bcGREATER		; else do - FAC1		[BFB4]
00E316  2               A_E316:					;				[E316]
00E316  2  A5 61        	lda	FACEXP			; get FAC1 exponent
00E318  2  48           	pha				; push exponent
00E319  2  C9 81        	cmp	#$81			; smaller than 1 ?
00E31B  2  90 07        	bcc	A_E324			; yes, ->
00E31D  2               
00E31D  2  A9 BC        	lda	#<Constant1		; pointer to 1 LB
00E31F  2  A0 B9        	ldy	#>Constant1		; pointer to 1 HB
00E321  2  20 0F BB     	jsr	AYdivFAC1		; convert AY and do (AY)/FAC1	[BB0F]
00E324  2               A_E324:					;				[E324]
00E324  2  A9 3E        	lda	#<ConstATN		; pointer to series LB
00E326  2  A0 E3        	ldy	#>ConstATN		; pointer to series HB
00E328  2  20 43 E0     	jsr	Power2			; ^2 then series evaluation	[E043]
00E32B  2               
00E32B  2  68           	pla				; restore old FAC1 exponent
00E32C  2  C9 81        	cmp	#$81			; smaller than 1 ?
00E32E  2  90 07        	bcc	A_E337			; yes, ->
00E330  2               
00E330  2  A9 E0        	lda	#<ConstPIdiv2		; pointer to (pi/2) LB
00E332  2  A0 E2        	ldy	#>ConstPIdiv2		; pointer to (pi/2) LB
00E334  2  20 50 B8     	jsr	AYminusFAC1		; perform subtraction, FAC1 from (AY)
00E337  2               					;				[B850]
00E337  2               A_E337:					;				[E337]
00E337  2  68           	pla				; restore FAC1 sign, positive
00E338  2  10 03        	bpl	A_E33D			; yes, ->
00E33A  2               
00E33A  2  4C B4 BF     	jmp	bcGREATER		; else do - FAC1 and return	[BFB4]
00E33D  2               
00E33D  2               A_E33D:					;				[E33D]
00E33D  2  60           	rts
00E33E  2               
00E33E  2               
00E33E  2               ;******************************************************************************
00E33E  2               ;
00E33E  2               ; series for ATN(n)
00E33E  2               ;
00E33E  2               ConstATN:				;				[E33E]
00E33E  2  0B           .byte	$0B				; series counter
00E33F  2  76 B3 83 BD  .byte	$76,$B3,$83,$BD,$D3		;-6.84793912e-04
00E343  2  D3           
00E344  2  79 1E F4 A6  .byte	$79,$1E,$F4,$A6,$F5		; 4.85094216e-03
00E348  2  F5           
00E349  2  7B 83 FC B0  .byte	$7B,$83,$FC,$B0,$10		;-0.0161117015
00E34D  2  10           
00E34E  2  7C 0C 1F 67  .byte	$7C,$0C,$1F,$67,$CA		; 0.034209638
00E352  2  CA           
00E353  2  7C DE 53 CB  .byte	$7C,$DE,$53,$CB,$C1		;-0.054279133
00E357  2  C1           
00E358  2  7D 14 64 70  .byte	$7D,$14,$64,$70,$4C		; 0.0724571965
00E35C  2  4C           
00E35D  2  7D B7 EA 51  .byte	$7D,$B7,$EA,$51,$7A		;-0.0898019185
00E361  2  7A           
00E362  2  7D 63 30 88  .byte	$7D,$63,$30,$88,$7E		; 0.110932413
00E366  2  7E           
00E367  2  7E 92 44 99  .byte	$7E,$92,$44,$99,$3A		;-0.142839808
00E36B  2  3A           
00E36C  2  7E 4C CC 91  .byte	$7E,$4C,$CC,$91,$C7		; 0.19999912
00E370  2  C7           
00E371  2  7F AA AA AA  .byte	$7F,$AA,$AA,$AA,$13		;-0.333333316
00E375  2  13           
00E376  2  81 00 00 00  .byte	$81,$00,$00,$00,$00		; 1.000000000
00E37A  2  00           
00E37B  2               
00E37B  2               
00E37B  2               ;******************************************************************************
00E37B  2               ;
00E37B  2               ; BASIC warm start entry point
00E37B  2               ;
00E37B  2               BasicWarmStart:				;				[E37B]
00E37B  2  20 CC FF     	jsr	CloseIoChannls		; close input and output channels [FFCC]
00E37E  2               
00E37E  2  A9 00        	lda	#$00			; clear A
00E380  2  85 13        	sta	CurIoChan		; set current I/O channel, flag default
00E382  2               
00E382  2  20 7A A6     	jsr	ClrBasicStack		; flush BASIC stack and clear continue
00E385  2               					; pointer			[A67A]
00E385  2  58           	cli				; enable the interrupts
00E386  2               BasWarmStart2:				;				[E386]
00E386  2  A2 80        	ldx	#$80			; set -ve error, just do warm start
00E388  2  6C 00 03     	jmp	(IERROR)		; go handle error message, normally
00E38B  2               					; BasWarmStart3 = $E38b, here below
00E38B  2               BasWarmStart3:				;				[E38B]
00E38B  2  8A           	txa				; copy the error number, negative?
00E38C  2  30 03        	bmi	A_E391			; yes, -> do warm start
00E38E  2               
00E38E  2  4C 3A A4     	jmp	OutputErrMsg2		; else do error #X then warm start
00E391  2               					;				[A43A]
00E391  2               
00E391  2               A_E391:					;				[E391]
00E391  2  4C 74 A4     	jmp	OutputREADY		; do warm start			[A474]
00E394  2               
00E394  2               
00E394  2               ;******************************************************************************
00E394  2               ;
00E394  2               ; BASIC cold start entry point
00E394  2               ;
00E394  2               BasicColdStart:				;				[E394]
00E394  2  20 53 E4     	jsr	InitBasicVec		; initialise the BASIC vector table
00E397  2               					;				[E453]
00E397  2  20 BF E3     	jsr	InitBasicRAM		; initialise the BASIC RAM locations
00E39A  2               					;				[E3BF]
00E39A  2  20 22 E4     	jsr	InitMemory		; print the start up message and
00E39D  2               					; initialise the memory pointers [E422]
00E39D  2               S_E39D:
00E39D  2  A2 FB        	ldx	#$FB			; value for start stack
00E39F  2  9A           	txs				; set stack pointer
00E3A0  2  D0 E4        	bne	BasWarmStart2		; do "READY." warm start, branch always
00E3A2  2               
00E3A2  2               
00E3A2  2               ;******************************************************************************
00E3A2  2               ;
00E3A2  2               ; character get subroutine for zero page
00E3A2  2               ;
00E3A2  2               ; the target address for the LDA $EA60 becomes the BASIC execute pointer once
00E3A2  2               ; the block is copied to its destination, any non zero page address will do at
00E3A2  2               ; assembly time, to assemble a three byte instruction. $EA60 is RTS, NOP.
00E3A2  2               ;
00E3A2  2               ; page 0 initialisation table from CHRGET
00E3A2  2               ; increment and scan memory
00E3A2  2               ;
00E3A2  2               DataCHRGET:				;				[E3A2]
00E3A2  2  E6 7A        	inc	TXTPTR			; increment BASIC execute pointer low
00E3A4  2               					; byte, became zero?
00E3A4  2  D0 02        	bne	A_E3A8			; no, ->
00E3A6  2               
00E3A6  2  E6 7B        	inc	TXTPTR+1		; inc. BASIC execute pointer HB
00E3A8  2               
00E3A8  2               ; page 0 initialisation table from CHRGOT, scan memory
00E3A8  2               A_E3A8:					;				[E3A8]
00E3A8  2  AD 60 EA     	lda	$EA60			; get byte to scan, address set by call
00E3AB  2               					; routine
00E3AB  2  C9 3A        	cmp	#':'			; above ":"?
00E3AD  2  B0 0A        	bcs	A_E3B9			; yes, -> exit
00E3AF  2               
00E3AF  2               ; page 0 initialisation table from P_0080, clear Cb if numeric
00E3AF  2  C9 20        	cmp	#' '			; space?
00E3B1  2  F0 EF        	beq	DataCHRGET		; yes, ->
00E3B3  2               
00E3B3  2  38           	sec				; set carry for SBC
00E3B4  2  E9 30        	sbc	#'0'			; subtract "0"
00E3B6  2               
00E3B6  2  38           	sec				; set carry for SBC
00E3B7  2  E9 D0        	sbc	#$D0			; subtract -"0"
00E3B9  2               ; If the character was between "0" and "9", then the Xarry is cleared now.
00E3B9  2               
00E3B9  2               A_E3B9:					;				[E3B9]
00E3B9  2  60           	rts
00E3BA  2               
00E3BA  2               
00E3BA  2               ; spare bytes, not referenced
00E3BA  2  80 4F C7 52  .byte	$80,$4F,$C7,$52,$58		; 0.811635157			[E3BA]
00E3BE  2  58           
00E3BF  2               
00E3BF  2               
00E3BF  2               ;******************************************************************************
00E3BF  2               ;
00E3BF  2               ; initialise BASIC RAM locations
00E3BF  2               ;
00E3BF  2               InitBasicRAM:				;				[E3BF]
00E3BF  2  A9 4C        	lda	#$4C			; opcode for JMP
00E3C1  2  85 54        	sta	Jump0054		; save for functions vector jump
00E3C3  2  8D 10 03     	sta	UserJump		; save for USR() vector jump, set USR()
00E3C6  2               					; vector to illegal quantity error
00E3C6  2  A9 48        	lda	#<IllegalQuant		; set USR() vector LB
00E3C8  2  A0 B2        	ldy	#>IllegalQuant		; set USR() vector HB
00E3CA  2  8D 11 03     	sta	USRADD			; save USR() vector LB
00E3CD  2  8C 12 03     	sty	USRADD+1		; save USR() vector HB
00E3D0  2               
00E3D0  2  A9 91        	lda	#<ConvertAY2FAC1	; set fixed to float vector LB
00E3D2  2  A0 B3        	ldy	#>ConvertAY2FAC1	; set fixed to float vector HB
00E3D4  2  85 05        	sta	ADRAY2			; save fixed to float vector LB
00E3D6  2  84 06        	sty	ADRAY2+1		; save fixed to float vector HB
00E3D8  2               
00E3D8  2  A9 AA        	lda	#<Float2Fixed		; set float to fixed vector LB
00E3DA  2  A0 B1        	ldy	#>Float2Fixed		; set float to fixed vector HB
00E3DC  2  85 03        	sta	ADRAY1			; save float to fixed vector LB
00E3DE  2  84 04        	sty	ADRAY1+1		; save float to fixed vector HB
00E3E0  2               
00E3E0  2               ; copy the character get subroutine from DataCHRGET to CHRGET (= $0073)
00E3E0  2  A2 1C        	ldx	#$1C			; set the byte count
00E3E2  2               A_E3E2:					;				[E3E2]
00E3E2  2  BD A2 E3     	lda	DataCHRGET,X		; get a byte from the table
00E3E5  2  95 73        	sta	CHRGET,X		; save the byte in page zero
00E3E7  2               
00E3E7  2  CA           	dex				; decrement the count
00E3E8  2  10 F8        	bpl	A_E3E2			; loop if not all done
00E3EA  2               
00E3EA  2               ; clear descriptors, strings, program area and mamory pointers
00E3EA  2  A9 03        	lda	#$03			; set step size, collecting descriptors
00E3EC  2  85 53        	sta	GarbColStep		; save the garbage collection step size
00E3EE  2               
00E3EE  2  A9 00        	lda	#$00			; clear A
00E3F0  2  85 68        	sta	BITS			; clear FAC1 overfLB
00E3F2  2  85 13        	sta	CurIoChan		; clear current I/O chan, flag default
00E3F4  2  85 18        	sta	LASTPT+1		; clear current descriptor stack item
00E3F6  2               					; pointer HB
00E3F6  2               
00E3F6  2  A2 01        	ldx	#$01			; set X
00E3F8  2  8E FD 01     	stx	STACK+$FD		; set the chain link pointer LB
00E3FB  2  8E FC 01     	stx	STACK+$FC		; set the chain link pointer HB
00E3FE  2               
00E3FE  2  A2 19        	ldx	#LASTPT+2		; initial the value for descriptor stack
00E400  2  86 16        	stx	TEMPPT			; set descriptor stack pointer
00E402  2               
00E402  2  38           	sec				; Carry = 1 to read the bottom of memory
00E403  2  20 9C FF     	jsr	BottomOfMem		; read/set the bottom of memory	[FF9C]
00E406  2  86 2B        	stx	TXTTAB			; save the start of memory LB
00E408  2  84 2C        	sty	TXTTAB+1		; save the start of memory HB
00E40A  2               
00E40A  2  38           	sec				; set Cb = 1 to read the top of memory
00E40B  2  20 99 FF     	jsr	TopOfMem		; read/set the top of memory	[FF99]
00E40E  2  86 37        	stx	MEMSIZ			; save the end of memory LB
00E410  2  84 38        	sty	MEMSIZ+1		; save the end of memory HB
00E412  2  86 33        	stx	FRETOP			; set bottom of string space LB
00E414  2  84 34        	sty	FRETOP+1		; set bottom of string space HB
00E416  2               
00E416  2  A0 00        	ldy	#$00			; clear the index
00E418  2  98           	tya				; clear the A
00E419  2  91 2B        	sta	(TXTTAB),Y		; clear the the first byte of memory
00E41B  2               
00E41B  2  E6 2B        	inc	TXTTAB			; increment the start of memory LB
00E41D  2  D0 02        	bne	A_E421			; if no rollover, skip next INC
00E41F  2               
00E41F  2  E6 2C        	inc	TXTTAB+1		; increment start of memory HB
00E421  2               A_E421:					;				[E421]
00E421  2  60           	rts
00E422  2               
00E422  2               
00E422  2               ;******************************************************************************
00E422  2               ;
00E422  2               ; print the start up message and initialise the memory pointers
00E422  2               ;
00E422  2               InitMemory:				;				[E422]
00E422  2  A5 2B        	lda	TXTTAB			; get the start of memory LB
00E424  2  A4 2C        	ldy	TXTTAB+1		; get the start of memory HB
00E426  2  20 08 A4     	jsr	CheckAvailMem		; check available memory, do out of
00E429  2               					; memory error if no room	[A408]
00E429  2               
00E429  2  A9 73        	lda	#<TxtCommodore64	; set text pointer LB
00E42B  2  A0 E4        	ldy	#>TxtCommodore64	; set text pointer HB
00E42D  2               S_E42D:
00E42D  2  20 1E AB     	jsr	OutputString		; print a null terminated string [AB1E]
00E430  2               
00E430  2  A5 37        	lda	MEMSIZ			; get the end of memory LB
00E432  2  38           	sec				; set carry for subtract
00E433  2  E5 2B        	sbc	TXTTAB			; subtract the start of memory LB
00E435  2  AA           	tax				; copy the result to X
00E436  2               
00E436  2  A5 38        	lda	MEMSIZ+1		; get the end of memory HB
00E438  2  E5 2C        	sbc	TXTTAB+1		; subtract the start of memory HB
00E43A  2  20 CD BD     	jsr	PrintXAasInt		; print XA as unsigned integer	[BDCD]
00E43D  2               
00E43D  2  A9 60        	lda	#<BasicBytesFree	; set " BYTES FREE" pointer LB
00E43F  2  A0 E4        	ldy	#>BasicBytesFree	; set " BYTES FREE" pointer HB
00E441  2               S_E441:
00E441  2  20 1E AB     	jsr	OutputString		; print a null terminated string [AB1E]
00E444  2               
00E444  2  4C 44 A6     	jmp	bcNEW2			; do NEW, CLEAR, RESTORE and return
00E447  2               					;				[A644]
00E447  2               
00E447  2               
00E447  2               ;******************************************************************************
00E447  2               ;
00E447  2               ; BASIC vectors, these are copied to RAM from IERROR onwards
00E447  2               ;
00E447  2               TblBasVectors:				;				[E447]
00E447  2  8B E3        .word	BasWarmStart3			; error message			IERROR
00E449  2  83 A4        .word	MainWaitLoop2			; BASIC warm start		IMAIN
00E44B  2  7C A5        .word	Text2TokenCod2			; crunch BASIC tokens		ICRNCH
00E44D  2  1A A7        .word	TokCode2Text2			; uncrunch BASIC tokens		IQPLOP
00E44F  2  E4 A7        .word	InterpretLoop3			; start new BASIC code		IGONE
00E451  2  86 AE        .word	GetNextParm2			; get arithmetic element	IEVAL
00E453  2               
00E453  2               
00E453  2               ;******************************************************************************
00E453  2               ;
00E453  2               ; initialise the BASIC vectors
00E453  2               ;
00E453  2               InitBasicVec:				;				[E453]
00E453  2  A2 0B        	ldx	#$0B			; set byte count
00E455  2               A_E455:					;				[E455]
00E455  2  BD 47 E4     	lda	TblBasVectors,X		; get byte from table
00E458  2  9D 00 03     	sta	IERROR,X		; save byte to RAM
00E45B  2               
00E45B  2  CA           	dex				; decrement index
00E45C  2  10 F7        	bpl	A_E455			; loop if more to do
00E45E  2               
00E45E  2  60           	rts
00E45F  2               
00E45F  2               
00E45F  2  00           .byte	$00				; unused byte ??		[E45F]
00E460  2               
00E460  2               
00E460  2               ;******************************************************************************
00E460  2               ;
00E460  2               ; BASIC startup messages
00E460  2               ;
00E460  2               BasicBytesFree:				;				[E460]
00E460  2  20 42 41 53  .byte	" basic bytes free",$0D,$00
00E464  2  49 43 20 42  
00E468  2  59 54 45 53  
00E473  2               
00E473  2               TxtCommodore64:				;				[E473]
00E473  2  93 0D        .byte	$93,$0D
00E475  2  20 20 20 20  .byte	"    **** commodore 64 basic v2 ****"
00E479  2  2A 2A 2A 2A  
00E47D  2  20 43 4F 4D  
00E498  2  0D 0D        .byte	$0D, $0D
00E49A  2  20 36 34 4B  .byte	" 64k ram system  "
00E49E  2  20 52 41 4D  
00E4A2  2  20 53 59 53  
00E4AB  2  00           .byte	$00
00E4AC  2               
00E4AC  2               
00E4AC  2               .if KERNAL = 1
00E4AC  2               E4AC:	.byte	$2B			; unused byte ??
00E4AC  2               .res 83,$AA ;.fb $AA,83
00E4AC  2               .endif
00E4AC  2               
00E4AC  2               .if KERNAL = 2
00E4AC  2               E4AC:	.byte	$5C			; unused byte ??
00E4AC  2               .endif
00E4AC  2               
00E4AC  2               .if KERNAL = 3
00E4AC  2  81           E4AC:	.byte	$81			; unused byte ??
00E4AD  2                     .out "KERNAL03"
00E4AD  2               .endif
00E4AD  2               
00E4AD  2               .if KERNAL = 2 || KERNAL = 3
00E4AD  2                     .out "KERNAL02||03"
00E4AD  2               ;******************************************************************************
00E4AD  2               ;
00E4AD  2               ; open channel for output
00E4AD  2               ;
00E4AD  2               OpenChan4OutpB:				;				[E4AD]
00E4AD  2  48           	pha				; save the flag byte
00E4AE  2               
00E4AE  2  20 C9 FF     	jsr	OpenChan4Outp		; open channel for output	[FFC9]
00E4B1  2  AA           	tax				; copy the returned flag byte
00E4B2  2               
00E4B2  2  68           	pla				; restore the alling flag byte
00E4B3  2  90 01        	bcc	A_E4B6			; if no error, skip copying error flag
00E4B5  2               
00E4B5  2  8A           	txa				; else copy the error flag
00E4B6  2               A_E4B6:					;				[E4B6]
00E4B6  2  60           	rts
00E4B7  2               
00E4B7  2               
00E4B7  2               .if KERNAL = 2
00E4B7  2               .res 35, $AA
00E4B7  2               .endif
00E4B7  2               
00E4B7  2               .if KERNAL = 3
00E4B7  2  AA AA AA AA  .res 28, $AA
00E4BB  2  AA AA AA AA  
00E4BF  2  AA AA AA AA  
00E4D3  2               
00E4D3  2               ;******************************************************************************
00E4D3  2               ;
00E4D3  2               ; flag the RS232 start bit and set the parity
00E4D3  2               ;
00E4D3  2               RS232_SaveSet:				;				[E4D3]
00E4D3  2  85 A9        	sta	RINONE			; save the start bit check flag, set
00E4D5  2               					; start bit received
00E4D5  2  A9 01        	lda	#$01			; set the initial parity state
00E4D7  2  85 AB        	sta	RIPRTY			; save the receiver parity bit
00E4D9  2               
00E4D9  2  60           	rts
00E4DA  2               .endif
00E4DA  2               
00E4DA  2               SaveCurColour:				;				[E4DA]
00E4DA  2               .if KERNAL =2
00E4DA  2               	lda	VICBAC0			; backgroundcolor 0
00E4DA  2               .endif
00E4DA  2               
00E4DA  2               .if KERNAL = 3
00E4DA  2  AD 86 02     	lda	COLOR			; get the current colour code
00E4DD  2               .endif
00E4DD  2               
00E4DD  2  91 F3        	sta	(ColorRamPtr),Y		; save it to the colour RAM
00E4DF  2               
00E4DF  2  60           	rts
00E4E0  2               
00E4E0  2               
00E4E0  2               ;******************************************************************************
00E4E0  2               ;
00E4E0  2               ; wait ~8.5 seconds for any key from the STOP key column
00E4E0  2               ;
00E4E0  2               Wait8Seconds:				;				[E4E0]
00E4E0  2  69 02        	adc	#$02			; set the number of jiffies to wait
00E4E2  2               A_E4E2:					;				[E4E2]
00E4E2  2  A4 91        	ldy	StopKey			; read the stop key column
00E4E4  2  C8           	iny				; test for $FF, no keys pressed
00E4E5  2  D0 04        	bne	A_E4EB			; if any keys were pressed just exit
00E4E7  2               
00E4E7  2  C5 A1        	cmp	TimeBytes+1		; compare the wait time with the jiffy
00E4E9  2               					; clock mid byte
00E4E9  2  D0 F7        	bne	A_E4E2			; if not there yet go wait some more
00E4EB  2               
00E4EB  2               A_E4EB:					;				[E4EB]
00E4EB  2  60           	rts
00E4EC  2               
00E4EC  2               
00E4EC  2               ;******************************************************************************
00E4EC  2               ;
00E4EC  2               ; baud rate word is calculated from ..
00E4EC  2               ;
00E4EC  2               ; (system clock / baud rate) / 2 - 100
00E4EC  2               ;
00E4EC  2               ;		system clock
00E4EC  2               ;		------------
00E4EC  2               ; PAL		  985248 Hz
00E4EC  2               ; NTSC		 1022727 Hz
00E4EC  2               ;
00E4EC  2               ; baud rate tables for PAL C64
00E4EC  2               ;
00E4EC  2               TblBaudRates:				;				[E4EC]
00E4EC  2  19 26        .word	$2619				;   50   baud	985300
00E4EE  2  44 19        .word	$1944				;   75   baud	985200
00E4F0  2  1A 11        .word	$111A				;  110   baud	985160
00E4F2  2  E8 0D        .word	$0DE8				;  134.5 baud	984540
00E4F4  2  70 0C        .word	$0C70				;  150   baud	985200
00E4F6  2  06 06        .word	$0606				;  300   baud	985200
00E4F8  2  D1 02        .word	$02D1				;  600   baud	985200
00E4FA  2  37 01        .word	$0137				; 1200   baud	986400
00E4FC  2  AE 00        .word	$00AE				; 1800   baud	986400
00E4FE  2  69 00        .word	$0069				; 2400   baud	984000
00E500  2               .endif
00E500  2               
00E500  2               
00E500  2               
00E500  2               ;******************************************************************************
00E500  2               ;
00E500  2               ; return the base address of the I/O devices
00E500  2               ;
00E500  2               GetAddrIoDevs2:				;				[E500]
00E500  2  A2 00        	ldx	#<CIA1DRA		; get the I/O base address LB
00E502  2  A0 DC        	ldy	#>CIA1DRA		; get the I/O base address HB
00E504  2  60           	rts
00E505  2               
00E505  2               
00E505  2               ;******************************************************************************
00E505  2               ;
00E505  2               ; return the x,y organization of the screen
00E505  2               ;
00E505  2               GetSizeScreen2:				;				[E505]
00E505  2  A2 28        	ldx	#$28			; get the x size
00E507  2  A0 19        	ldy	#$19			; get the y size
00E509  2  60           	rts
00E50A  2               
00E50A  2               
00E50A  2               ;******************************************************************************
00E50A  2               ;
00E50A  2               ; read/set the x,y cursor position
00E50A  2               ;
00E50A  2               CursorPosXY2:				;				[E50A]
00E50A  2  B0 07        	bcs	A_E513			; if Carry set -> do read
00E50C  2               
00E50C  2               ; Set the cursor position
00E50C  2  86 D6        	stx	PhysCurRow		; save the cursor row
00E50E  2  84 D3        	sty	LineCurCol		; save the cursor column
00E510  2  20 6C E5     	jsr	CalcCursorPos		; set the screen pointers for the
00E513  2               					; cursor row, column		[E56C]
00E513  2               A_E513:					;				[E513]
00E513  2  A6 D6        	ldx	PhysCurRow		; get the cursor row
00E515  2  A4 D3        	ldy	LineCurCol		; get the cursor column
00E517  2  60           	rts
00E518  2               
00E518  2               
00E518  2               ;******************************************************************************
00E518  2               ;
00E518  2               ; initialise the screen and keyboard
00E518  2               ;
00E518  2               InitScreenKeyb:				;				[E518]
00E518  2  20 A0 E5     	jsr	InitVideoIC		; initialise the vic chip	[E5A0]
00E51B  2               
00E51B  2  A9 00        	lda	#$00			; clear A
00E51D  2  8D 91 02     	sta	MODE			; clear the shift mode switch
00E520  2  85 CF        	sta	BLNON			; clear the cursor blink phase
00E522  2               
00E522  2  A9 48        	lda	#<ShftCtrlCbmKey	; get the keyboard decode logic pointer
00E524  2               					; LB
00E524  2  8D 8F 02     	sta	KEYLOG			; save the keyboard decode logic pointer
00E527  2               					; LB
00E527  2               
00E527  2  A9 EB        	lda	#>ShftCtrlCbmKey	; get the keyboard decode logic pointer
00E529  2               					; HB
00E529  2  8D 90 02     	sta	KEYLOG+1		; save the keyboard decode logic pointer
00E52C  2               					; HB
00E52C  2  A9 0A        	lda	#$0A			; set maximum size of keyboard buffer
00E52E  2  8D 89 02     	sta	XMAX			; save maximum size of keyboard buffer
00E531  2  8D 8C 02     	sta	DELAY			; save the repeat delay counter
00E534  2               
00E534  2  A9 0E        	lda	#$0E			; set light blue
00E536  2  8D 86 02     	sta	COLOR			; save the current colour code
00E539  2               
00E539  2  A9 04        	lda	#$04			; speed 4
00E53B  2  8D 8B 02     	sta	KOUNT			; save the repeat speed counter
00E53E  2               
00E53E  2  A9 0C        	lda	#$0C			; set the cursor flash timing
00E540  2  85 CD        	sta	BLNCT			; save the cursor timing countdown
00E542  2  85 CC        	sta	BLNSW			; save cursor enable, $00 = flash cursor
00E544  2               
00E544  2               
00E544  2               ;******************************************************************************
00E544  2               ;
00E544  2               ; clear the screen
00E544  2               ;
00E544  2               ClearScreen:				;				[E544]
00E544  2  AD 88 02     	lda	HIBASE			; get the screen memory page
00E547  2  09 80        	ora	#$80			; set the high bit, flag every line is
00E549  2               					; a logical line start
00E549  2  A8           	tay				; copy to Y
00E54A  2               
00E54A  2  A9 00        	lda	#$00			; clear the line start LB
00E54C  2  AA           	tax				; clear the index
00E54D  2               A_E54D:					;				[E54D]
00E54D  2  94 D9        	sty	LDTB1,X			; save start of line X pointer HB
00E54F  2               
00E54F  2  18           	clc				; clear carry for add
00E550  2  69 28        	adc	#$28			; add the line length to the LB
00E552  2  90 01        	bcc	A_E555			; if no rollover skip the HB
00E554  2               					; increment
00E554  2  C8           	iny				; else increment the HB
00E555  2               A_E555:					;				[E555]
00E555  2  E8           	inx				; increment the line index
00E556  2  E0 1A        	cpx	#$1A			; compare it with number of lines + 1
00E558  2  D0 F3        	bne	A_E54D			; loop if not all done
00E55A  2               
00E55A  2  A9 FF        	lda	#$FF			; set the end of table marker
00E55C  2  95 D9        	sta	LDTB1,X			; mark the end of the table
00E55E  2               
00E55E  2  A2 18        	ldx	#$18			; set the line count, 25 lines to do,
00E560  2               					; 0 to 24
00E560  2               A_E560:					;				[E560]
00E560  2  20 FF E9     	jsr	ClearLineX		; clear screen line X		[E9FF]
00E563  2               
00E563  2  CA           	dex				; decrement the count
00E564  2  10 FA        	bpl	A_E560			; loop if more to do
00E566  2               
00E566  2               
00E566  2               ;******************************************************************************
00E566  2               ;
00E566  2               ; home the cursor
00E566  2               ;
00E566  2               CursorHome:				;				[E566]
00E566  2  A0 00        	ldy	#$00			; clear Y
00E568  2  84 D3        	sty	LineCurCol		; clear the cursor column
00E56A  2  84 D6        	sty	PhysCurRow		; clear the cursor row
00E56C  2               
00E56C  2               
00E56C  2               ;******************************************************************************
00E56C  2               ;
00E56C  2               ; set screen pointers for cursor row, column
00E56C  2               ;
00E56C  2               CalcCursorPos:				;				[E56C]
00E56C  2  A6 D6        	ldx	PhysCurRow		; get the cursor row
00E56E  2  A5 D3        	lda	LineCurCol		; get the cursor column
00E570  2               A_E570:					;				[E570]
00E570  2  B4 D9        	ldy	LDTB1,X			; get start of line X pointer HB
00E572  2  30 08        	bmi	A_E57C			; if it is logical line start, continue
00E574  2               
00E574  2  18           	clc				; else clear carry for add
00E575  2  69 28        	adc	#$28			; add one line length
00E577  2  85 D3        	sta	LineCurCol		; save the cursor column
00E579  2               
00E579  2  CA           	dex				; decrement the cursor row
00E57A  2  10 F4        	bpl	A_E570			; loop, branch always
00E57C  2               
00E57C  2               A_E57C:					;				[E57C]
00E57C  2               .if KERNAL = 2
00E57C  2               	lda	LDTB1,X			; get the start of line X pointer HB
00E57C  2               	and	#$03
00E57C  2               	ora	HIBASE
00E57C  2               	sta	CurScrLine+1
00E57C  2               
00E57C  2               	lda	TblScrLinesLB,X
00E57C  2               	sta	CurScrLine
00E57C  2               
00E57C  2               	lda	#$27			; set the line length
00E57C  2               
00E57C  2               	inx
00E57C  2               A_E58D:					;				[E58D]
00E57C  2               	ldy	LDTB1,X			; get the start of line X pointer HB
00E57C  2               	bmi	A_E597			; if logical line start exit
00E57C  2               
00E57C  2               	clc				; else clear carry for add
00E57C  2               	adc	#$28			; add one line length to the current
00E57C  2               					; line length
00E57C  2               	inx				; increment the cursor row
00E57C  2               	bpl	A_E58D			; loop, branch always
00E57C  2               
00E57C  2               A_E597:					;				[E597]
00E57C  2               	sta	CurLineLeng
00E57C  2               
00E57C  2               	rts
00E57C  2               .endif
00E57C  2               
00E57C  2               .if KERNAL = 3
00E57C  2  20 F0 E9     	jsr	FetchScreenAddr		; fetch a screen address	[E9F0]
00E57F  2               
00E57F  2  A9 27        	lda	#$27			; set the line length
00E581  2               
00E581  2  E8           	inx				; increment the cursor row
00E582  2               A_E582:					;				[E582]
00E582  2  B4 D9        	ldy	LDTB1,X			; get the start of line X pointer HB
00E584  2  30 06        	bmi	A_E58C			; if logical line start exit
00E586  2               
00E586  2  18           	clc				; else clear carry for add
00E587  2  69 28        	adc	#$28			; add one line length to the current
00E589  2               					; line length
00E589  2  E8           	inx				; increment the cursor row
00E58A  2  10 F6        	bpl	A_E582			; loop, branch always
00E58C  2               
00E58C  2               A_E58C:					;				[E58C]
00E58C  2  85 D5        	sta	CurLineLeng		; save current screen line length
00E58E  2               
00E58E  2  4C 24 EA     	jmp	PtrCurLineColRAM	; calculate the pointer to colour RAM
00E591  2               					; and return			[EA24]
00E591  2               
00E591  2               SetPtrLogLine:				;				[E591]
00E591  2  E4 C9        	cpx	CursorRow		; compare it with the input cursor row
00E593  2  F0 03        	beq	A_E598			; if there just exit
00E595  2               
00E595  2  4C ED E6     	jmp	GoStartOfLine		; else go ??			[E6ED]
00E598  2               
00E598  2               A_E598:					;				[E598]
00E598  2  60           	rts
00E599  2               
00E599  2  EA           	nop
00E59A  2               
00E59A  2               .endif
00E59A  2               
00E59A  2               ; Left overs from what ???
00E59A  2  20 A0 E5     	jsr	InitVideoIC		; initialise the vic chip	[E5A0]
00E59D  2  4C 66 E5     	jmp	CursorHome		; home the cursor and return	[E566]
00E5A0  2               
00E5A0  2               
00E5A0  2               ;******************************************************************************
00E5A0  2               ;
00E5A0  2               ; initialise the vic chip
00E5A0  2               ;
00E5A0  2               InitVideoIC:				;				[E5A0]
00E5A0  2  A9 03        	lda	#$03			; set the screen as the output device
00E5A2  2  85 9A        	sta	DFLTO			; save the output device number
00E5A4  2               
00E5A4  2  A9 00        	lda	#$00			; set the keyboard as the input device
00E5A6  2  85 99        	sta	DFLTN			; save the input device number
00E5A8  2               
00E5A8  2  A2 2F        	ldx	#$2F			; set the count/index
00E5AA  2               A_E5AA:					;				[E5AA]
00E5AA  2  BD B8 EC     	lda	TblValuesVIC-1,X	; get a vic ii chip initialisation value
00E5AD  2  9D FF CF     	sta	VIC_chip-1,X		; save it to the vic ii chip
00E5B0  2               
00E5B0  2  CA           	dex				; decrement the count/index
00E5B1  2  D0 F7        	bne	A_E5AA			; loop if more to do
00E5B3  2               
00E5B3  2  60           	rts
00E5B4  2               
00E5B4  2               
00E5B4  2               ;******************************************************************************
00E5B4  2               ;
00E5B4  2               ; input from the keyboard buffer
00E5B4  2               ;
00E5B4  2               GetCharKeybBuf:				;				[E5B4]
00E5B4  2  AC 77 02     	ldy	KeyboardBuf		; get the current character from buffer
00E5B7  2  A2 00        	ldx	#$00			; clear the index
00E5B9  2               A_E5B9:					;				[E5B9]
00E5B9  2  BD 78 02     	lda	KeyboardBuf+1,X		; get next character from the buffer
00E5BC  2  9D 77 02     	sta	KeyboardBuf,X		; save it as current character in buffer
00E5BF  2               
00E5BF  2  E8           	inx				; increment the index
00E5C0  2  E4 C6        	cpx	NDX			; compare it with keyboard buffer index
00E5C2  2  D0 F5        	bne	A_E5B9			; loop if more to do
00E5C4  2               
00E5C4  2  C6 C6        	dec	NDX			; decrement keyboard buffer index
00E5C6  2               
00E5C6  2  98           	tya				; copy the key to A
00E5C7  2               
00E5C7  2  58           	cli				; enable the interrupts
00E5C8  2  18           	clc				; flag got byte
00E5C9  2               
00E5C9  2  60           	rts
00E5CA  2               
00E5CA  2               
00E5CA  2               ;******************************************************************************
00E5CA  2               ;
00E5CA  2               ; write character and wait for key
00E5CA  2               ;
00E5CA  2               OutCharWaitKey:				;				[E5CA]
00E5CA  2  20 16 E7     	jsr	OutputChar		; output character		[E716]
00E5CD  2               
00E5CD  2               
00E5CD  2               ;******************************************************************************
00E5CD  2               ;
00E5CD  2               ; wait for a key from the keyboard
00E5CD  2               ;
00E5CD  2               WaitForKey:				;				[E5CD]
00E5CD  2  A5 C6        	lda	NDX			; get the keyboard buffer index
00E5CF  2  85 CC        	sta	BLNSW			; cursor enable, $00 = flash cursor,
00E5D1  2               					; $xx = no flash
00E5D1  2  8D 92 02     	sta	AUTODN			; screen scrolling flag, $00 = scroll,
00E5D4  2               					; $xx = no scroll. This disables both
00E5D4  2               					; the cursor flash and the screen scroll
00E5D4  2               					; while there are characters in the
00E5D4  2               					; keyboard buffer
00E5D4  2  F0 F7        	beq	WaitForKey		; loop if the buffer is empty
00E5D6  2               
00E5D6  2  78           	sei				; disable the interrupts
00E5D7  2               
00E5D7  2  A5 CF        	lda	BLNON			; get the cursor blink phase
00E5D9  2  F0 0C        	beq	A_E5E7			; if cursor phase skip the overwrite
00E5DB  2               
00E5DB  2               ; else it is the character phase
00E5DB  2  A5 CE        	lda	GDBLN			; get the character under the cursor
00E5DD  2  AE 87 02     	ldx	GDCOL			; get the colour under the cursor
00E5E0  2               
00E5E0  2  A0 00        	ldy	#$00			; clear Y
00E5E2  2  84 CF        	sty	BLNON			; clear the cursor blink phase
00E5E4  2               
00E5E4  2  20 13 EA     	jsr	PrntCharA_ColX		; print character A and colour X [EA13]
00E5E7  2               A_E5E7:					;				[E5E7]
00E5E7  2  20 B4 E5     	jsr	GetCharKeybBuf		; input from the keyboard buffer [E5B4]
00E5EA  2  C9 83        	cmp	#$83			; compare with [SHIFT][RUN]
00E5EC  2  D0 10        	bne	A_E5FE			; if not [SHIFT][RUN] skip buffer fill
00E5EE  2               
00E5EE  2               ; keys are [SHIFT][RUN] so put "LOAD",$0D,"RUN",$0D into the buffer
00E5EE  2  A2 09        	ldx	#9			; set the byte count
00E5F0  2               
00E5F0  2  78           	sei				; disable the interrupts
00E5F1  2               
00E5F1  2  86 C6        	stx	NDX			; set the keyboard buffer index
00E5F3  2               A_E5F3:					;				[E5F3]
00E5F3  2  BD E6 EC     	lda	TblAutoLoadRun-1,X	; get byte from the auto load/run table
00E5F6  2  9D 76 02     	sta	KeyboardBuf-1,X		; save it to the keyboard buffer
00E5F9  2               
00E5F9  2  CA           	dex				; decrement the count/index
00E5FA  2  D0 F7        	bne	A_E5F3			; loop while more to do
00E5FC  2               
00E5FC  2  F0 CF        	beq	WaitForKey		; always -> loop for the next key
00E5FE  2               
00E5FE  2               ; was not [SHIFT][RUN]
00E5FE  2               A_E5FE:					;				[E5FE]
00E5FE  2  C9 0D        	cmp	#$0D			; compare the key with [CR]
00E600  2  D0 C8        	bne	OutCharWaitKey		; if not [CR] print the character and
00E602  2               					; get the next key
00E602  2               ; else it was [CR]
00E602  2  A4 D5        	ldy	CurLineLeng		; get the current screen line length
00E604  2  84 D0        	sty	CRSW			; input from keyboard or screen,
00E606  2               					; $xx = screen, $00 = keyboard
00E606  2               A_E606:					;				[E606]
00E606  2  B1 D1        	lda	(CurScrLine),Y		; get the character from the current
00E608  2               					; screen line
00E608  2  C9 20        	cmp	#' '			; compare it with [SPACE]
00E60A  2  D0 03        	bne	A_E60F			; if not [SPACE] continue
00E60C  2               
00E60C  2  88           	dey				; else eliminate the space, decrement
00E60D  2               					; end of input line
00E60D  2  D0 F7        	bne	A_E606			; loop, branch always
00E60F  2               
00E60F  2               A_E60F:					;				[E60F]
00E60F  2  C8           	iny				; increment past the last non space
00E610  2               					; character on line
00E610  2  84 C8        	sty	INDX			; save the input [EOL] pointer
00E612  2               
00E612  2  A0 00        	ldy	#$00			; clear A
00E614  2  8C 92 02     	sty	AUTODN			; clear the screen scrolling flag,
00E617  2               					; $00 = scroll
00E617  2  84 D3        	sty	LineCurCol		; clear the cursor column
00E619  2  84 D4        	sty	QTSW			; clear the cursor quote flag,
00E61B  2               					; $xx = quote, $00 = no quote
00E61B  2  A5 C9        	lda	CursorRow		; get the input cursor row
00E61D  2  30 1B        	bmi	A_E63A			;.
00E61F  2               
00E61F  2  A6 D6        	ldx	PhysCurRow		; get the cursor row
00E621  2               .if KERNAL = 1 || KERNAL = 2
00E621  2               	jsr	GoStartOfLine		; start of logical line		[E591]
00E621  2               .endif
00E621  2               
00E621  2               .if KERNAL = 3
00E621  2  20 91 E5     	jsr	SetPtrLogLine		; find and set the pointers for the
00E624  2               .endif
00E624  2               
00E624  2  E4 C9        	cpx	CursorRow		; compare with input cursor row
00E626  2  D0 12        	bne	A_E63A			;.
00E628  2               
00E628  2  A5 CA        	lda	CursorCol		; get the input cursor column
00E62A  2  85 D3        	sta	LineCurCol		; save the cursor column
00E62C  2               
00E62C  2  C5 C8        	cmp	INDX			; compare the cursor column with input
00E62E  2               					; [EOL] pointer
00E62E  2  90 0A        	bcc	A_E63A			; if less, cursor is in line, go ??
00E630  2  B0 2B        	bcs	A_E65D			; alway ->
00E632  2               
00E632  2               
00E632  2               ;******************************************************************************
00E632  2               ;
00E632  2               ; input from screen or keyboard
00E632  2               ;
00E632  2               InputScrKeyb:				;				[E632]
00E632  2  98           	tya				; copy Y
00E633  2  48           	pha				; save Y
00E634  2               
00E634  2  8A           	txa				; copy X
00E635  2  48           	pha				; save X
00E636  2               
00E636  2  A5 D0        	lda	CRSW			; input from keyboard or screen,
00E638  2               					; $xx = screen, $00 = keyboard
00E638  2  F0 93        	beq	WaitForKey		; if keyboard go wait for key
00E63A  2               A_E63A:					;				[E63A]
00E63A  2  A4 D3        	ldy	LineCurCol		; get the cursor column
00E63C  2  B1 D1        	lda	(CurScrLine),Y		; get character from current screen line
00E63E  2  85 D7        	sta	TEMPD7			; save temporary last character
00E640  2               
00E640  2  29 3F        	and	#$3F			; mask key bits
00E642  2  06 D7        	asl	TEMPD7			; << temporary last character
00E644  2  24 D7        	bit	TEMPD7			; test it
00E646  2  10 02        	bpl	A_E64A			; branch if not [NO KEY]
00E648  2               
00E648  2  09 80        	ora	#$80			;.
00E64A  2               A_E64A:					;				[E64A]
00E64A  2  90 04        	bcc	A_E650			;.
00E64C  2               
00E64C  2  A6 D4        	ldx	QTSW			; get the cursor quote flag,
00E64E  2               					; $xx = quote, $00 = no quote
00E64E  2  D0 04        	bne	A_E654			; if in quote mode go ??
00E650  2               
00E650  2               A_E650:					;				[E650]
00E650  2  70 02        	bvs	A_E654			;.
00E652  2               
00E652  2  09 40        	ora	#$40			;.
00E654  2               A_E654:					;				[E654]
00E654  2  E6 D3        	inc	LineCurCol		; increment the cursor column
00E656  2               
00E656  2  20 84 E6     	jsr	ToggleCursorFlg		; if open quote toggle cursor quote
00E659  2               					; flag				[E684]
00E659  2  C4 C8        	cpy	INDX			; compare ?? with input [EOL] pointer
00E65B  2  D0 17        	bne	A_E674			; if not at line end go ??
00E65D  2               
00E65D  2               A_E65D:					;				[E65D]
00E65D  2  A9 00        	lda	#$00			; clear A
00E65F  2  85 D0        	sta	CRSW			; clear input from keyboard or screen,
00E661  2               					; $xx = screen, $00 = keyboard
00E661  2  A9 0D        	lda	#$0D			; set character [CR]
00E663  2               
00E663  2  A6 99        	ldx	DFLTN			; get the input device number
00E665  2  E0 03        	cpx	#$03			; compare the input device with screen
00E667  2  F0 06        	beq	A_E66F			; if screen go ??
00E669  2               
00E669  2  A6 9A        	ldx	DFLTO			; get the output device number
00E66B  2  E0 03        	cpx	#$03			; compare the output device with screen
00E66D  2  F0 03        	beq	A_E672			; if screen go ??
00E66F  2               
00E66F  2               A_E66F:					;				[E66F]
00E66F  2  20 16 E7     	jsr	OutputChar		; output the character		[E716]
00E672  2               A_E672:					;				[E672]
00E672  2  A9 0D        	lda	#$0D			; set character [CR]
00E674  2               A_E674:					;				[E674]
00E674  2  85 D7        	sta	TEMPD7			; save character
00E676  2               
00E676  2  68           	pla				; pull X
00E677  2  AA           	tax				; restore X
00E678  2               
00E678  2  68           	pla				; pull Y
00E679  2  A8           	tay				; restore Y
00E67A  2               
00E67A  2  A5 D7        	lda	TEMPD7			; restore character
00E67C  2  C9 DE        	cmp	#$DE			;.
00E67E  2  D0 02        	bne	A_E682			;.
00E680  2               
00E680  2  A9 FF        	lda	#$FF			;.
00E682  2               A_E682:					;				[E682]
00E682  2  18           	clc				; flag ok
00E683  2  60           	rts
00E684  2               
00E684  2               
00E684  2               ;******************************************************************************
00E684  2               ;
00E684  2               ; if open quote toggle cursor quote flag
00E684  2               ;
00E684  2               ToggleCursorFlg:			;				[E684]
00E684  2  C9 22        	cmp	#'"'			; compare byte with "
00E686  2  D0 08        	bne	A_E690			; exit if not "
00E688  2               
00E688  2  A5 D4        	lda	QTSW			; get cursor quote flag, $xx = quote,
00E68A  2               					; $00 = no quote
00E68A  2  49 01        	eor	#$01			; toggle it
00E68C  2  85 D4        	sta	QTSW			; save cursor quote flag
00E68E  2               
00E68E  2  A9 22        	lda	#'"'			; restore the "
00E690  2               A_E690:					;				[E690]
00E690  2  60           	rts
00E691  2               
00E691  2               
00E691  2               ;******************************************************************************
00E691  2               ;
00E691  2               ; insert uppercase/graphic character
00E691  2               ;
00E691  2               UpcChar2Screen:				;				[E691]
00E691  2  09 40        	ora	#$40			; change to uppercase/graphic
00E693  2               Char2Screen:				;				[E693]
00E693  2  A6 C7        	ldx	RVS			; get the reverse flag
00E695  2  F0 02        	beq	A_E699			; branch if not reverse
00E697  2               
00E697  2               ; else insert reversed character
00E697  2               ReverseChar:				;				[E697]
00E697  2  09 80        	ora	#$80			; reverse character
00E699  2               A_E699:					;				[E699]
00E699  2  A6 D8        	ldx	InsertCount		; get the insert count
00E69B  2  F0 02        	beq	A_E69F			; branch if none
00E69D  2               
00E69D  2  C6 D8        	dec	InsertCount		; else decrement the insert count
00E69F  2               A_E69F:					;				[E69F]
00E69F  2  AE 86 02     	ldx	COLOR			; get the current colour code
00E6A2  2  20 13 EA     	jsr	PrntCharA_ColX		; print character A and colour X [EA13]
00E6A5  2  20 B6 E6     	jsr	AdvanceCursor		; advance the cursor		[E6B6]
00E6A8  2               
00E6A8  2               ; restore the registers, set the quote flag and exit
00E6A8  2               RestorRegsQuot:				;				[E6A8]
00E6A8  2  68           	pla				; pull Y
00E6A9  2  A8           	tay				; restore Y
00E6AA  2               
00E6AA  2  A5 D8        	lda	InsertCount		; get the insert count, inserts to do?
00E6AC  2  F0 02        	beq	A_E6B0			; no, ->
00E6AE  2               
00E6AE  2  46 D4        	lsr	QTSW			; clear cursor quote flag, $xx = quote,
00E6B0  2               					; $00 = no quote
00E6B0  2               A_E6B0:					;				[E6B0]
00E6B0  2  68           	pla				; pull X
00E6B1  2  AA           	tax				; restore X
00E6B2  2               
00E6B2  2  68           	pla				; restore A
00E6B3  2               
00E6B3  2  18           	clc				;.
00E6B4  2  58           	cli				; enable the interrupts
00E6B5  2               
00E6B5  2  60           	rts
00E6B6  2               
00E6B6  2               
00E6B6  2               ;******************************************************************************
00E6B6  2               ;
00E6B6  2               ; advance the cursor
00E6B6  2               ;
00E6B6  2               AdvanceCursor:				;				[E6B6]
00E6B6  2  20 B3 E8     	jsr	Test4LineIncr		; test for line increment	[E8B3]
00E6B9  2               
00E6B9  2  E6 D3        	inc	LineCurCol		; increment the cursor column
00E6BB  2               
00E6BB  2  A5 D5        	lda	CurLineLeng		; get current screen line length
00E6BD  2  C5 D3        	cmp	LineCurCol		; compare ?? with the cursor column
00E6BF  2  B0 3F        	bcs	A_E700			; exit if line length >= cursor column
00E6C1  2               
00E6C1  2  C9 4F        	cmp	#$4F			; compare with max length
00E6C3  2  F0 32        	beq	A_E6F7			; if at max clear column, back cursor
00E6C5  2               					; up and do newline
00E6C5  2  AD 92 02     	lda	AUTODN			; get the autoscroll flag
00E6C8  2  F0 03        	beq	A_E6CD			; branch if autoscroll on
00E6CA  2               
00E6CA  2  4C 67 E9     	jmp	InsertLine2		; else open space on screen	[E967]
00E6CD  2               
00E6CD  2               A_E6CD:					;				[E6CD]
00E6CD  2  A6 D6        	ldx	PhysCurRow		; get the cursor row
00E6CF  2  E0 19        	cpx	#$19			; compare with max + 1
00E6D1  2  90 07        	bcc	AddRow2CurLine		; if less than max + 1 go add this row
00E6D3  2               					; to the current logical line
00E6D3  2               
00E6D3  2  20 EA E8     	jsr	ScrollScreen		; else scroll the screen	[E8EA]
00E6D6  2               
00E6D6  2  C6 D6        	dec	PhysCurRow		; decrement the cursor row
00E6D8  2  A6 D6        	ldx	PhysCurRow		; get the cursor row
00E6DA  2               
00E6DA  2               ; add this row to the current logical line
00E6DA  2               AddRow2CurLine:				;				[E6DA]
00E6DA  2  16 D9        	asl	LDTB1,X			; clear bit 7 of start of line X ...
00E6DC  2  56 D9        	lsr	LDTB1,X			;    ... HB back
00E6DE  2               
00E6DE  2               ; make next screen line start of logical line, increment line length and set
00E6DE  2               ; pointers, set b7, start of logical line
00E6DE  2  E8           	inx				; increment screen row
00E6DF  2               
00E6DF  2  B5 D9        	lda	LDTB1,X			; get start of line X pointer HB
00E6E1  2  09 80        	ora	#$80			; mark as start of logical line
00E6E3  2  95 D9        	sta	LDTB1,X			; set start of line X pointer HB
00E6E5  2               
00E6E5  2  CA           	dex				; restore screen row
00E6E6  2               
00E6E6  2  A5 D5        	lda	CurLineLeng		; get current screen line length
00E6E8  2               
00E6E8  2               ; add one line length and set the pointers for the start of the line
00E6E8  2  18           	clc				; clear carry for add
00E6E9  2  69 28        	adc	#$28			; add one line length
00E6EB  2  85 D5        	sta	CurLineLeng		; save current screen line length
00E6ED  2               GoStartOfLine:				;				[E6ED]
00E6ED  2  B5 D9        	lda	LDTB1,X			; get start of line X pointer HB
00E6EF  2  30 03        	bmi	A_E6F4			; exit loop if start of logical line
00E6F1  2               
00E6F1  2  CA           	dex				; else back up one line
00E6F2  2  D0 F9        	bne	GoStartOfLine		; loop if not on first line
00E6F4  2               A_E6F4:					;				[E6F4]
00E6F4  2  4C F0 E9     	jmp	FetchScreenAddr		; fetch a screen address	[E9F0]
00E6F7  2               
00E6F7  2               A_E6F7:					;				[E6F7]
00E6F7  2  C6 D6        	dec	PhysCurRow		; decrement the cursor row
00E6F9  2  20 7C E8     	jsr	NewScreenLine		; do newline			[E87C]
00E6FC  2  A9 00        	lda	#$00			; clear A
00E6FE  2  85 D3        	sta	LineCurCol		; clear the cursor column
00E700  2               A_E700:					;				[E700]
00E700  2  60           	rts
00E701  2               
00E701  2               
00E701  2               ;******************************************************************************
00E701  2               ;
00E701  2               ; back onto the previous line if possible
00E701  2               ;
00E701  2               BackToPrevLine:				;				[E701]
00E701  2  A6 D6        	ldx	PhysCurRow		; get the cursor row
00E703  2  D0 06        	bne	A_E70B			; branch if not top row
00E705  2               
00E705  2  86 D3        	stx	LineCurCol		; clear cursor column
00E707  2               
00E707  2  68           	pla				; dump return address LB
00E708  2               
00E708  2  68           	pla				; dump return address HB
00E709  2  D0 9D        	bne	RestorRegsQuot		; restore registers, set quote flag
00E70B  2               					; and exit, branch always
00E70B  2               A_E70B:					;				[E70B]
00E70B  2  CA           	dex				; decrement the cursor row
00E70C  2  86 D6        	stx	PhysCurRow		; save the cursor row
00E70E  2               
00E70E  2  20 6C E5     	jsr	CalcCursorPos		; set the screen pointers for cursor
00E711  2               					; row, column			[E56C]
00E711  2  A4 D5        	ldy	CurLineLeng		; get current screen line length
00E713  2  84 D3        	sty	LineCurCol		; save the cursor column
00E715  2               
00E715  2  60           	rts
00E716  2               
00E716  2               
00E716  2               ;******************************************************************************
00E716  2               ;
00E716  2               ; output a character to the screen
00E716  2               ;
00E716  2               OutputChar:				;				[E716]
00E716  2  48           	pha				; save character
00E717  2  85 D7        	sta	TEMPD7			; save temporary last character
00E719  2               
00E719  2  8A           	txa				; copy X
00E71A  2  48           	pha				; save X
00E71B  2               
00E71B  2  98           	tya				; copy Y
00E71C  2  48           	pha				; save Y
00E71D  2               
00E71D  2  A9 00        	lda	#$00			; clear A
00E71F  2  85 D0        	sta	CRSW			; clear input from keyboard or screen,
00E721  2               					; $xx = screen, $00 = keyboard
00E721  2  A4 D3        	ldy	LineCurCol		; get cursor column
00E723  2               
00E723  2  A5 D7        	lda	TEMPD7			; restore last character
00E725  2  10 03        	bpl	A_E72A			; branch if unshifted
00E727  2               
00E727  2  4C D4 E7     	jmp	ShiftedChars		; do shifted characters and return
00E72A  2               					;				[E7D4]
00E72A  2               A_E72A:					;				[E72A]
00E72A  2  C9 0D        	cmp	#$0D			; compare with [CR]
00E72C  2  D0 03        	bne	A_E731			; branch if not [CR]
00E72E  2               
00E72E  2  4C 91 E8     	jmp	OutputCR		; else output [CR] and return	[E891]
00E731  2               
00E731  2               A_E731:					;				[E731]
00E731  2  C9 20        	cmp	#' '			; compare with [SPACE]
00E733  2  90 10        	bcc	A_E745			; branch if < [SPACE]
00E735  2               
00E735  2  C9 60        	cmp	#$60			;.
00E737  2  90 04        	bcc	A_E73D			; branch if $20 to $5F
00E739  2               
00E739  2               ; character is $60 or greater
00E739  2  29 DF        	and	#$DF			;.
00E73B  2  D0 02        	bne	A_E73F			;.
00E73D  2               
00E73D  2               A_E73D:					;				[E73D]
00E73D  2  29 3F        	and	#$3F			;.
00E73F  2               A_E73F:					;				[E73F]
00E73F  2  20 84 E6     	jsr	ToggleCursorFlg		; if open quote toggle cursor
00E742  2               					; direct/programmed flag	[E684]
00E742  2  4C 93 E6     	jmp	Char2Screen		;.				[E693]
00E745  2               
00E745  2               ; character was < [SPACE] so is a control character of some sort
00E745  2               A_E745:					;				[E745]
00E745  2  A6 D8        	ldx	InsertCount		; get the insert count
00E747  2  F0 03        	beq	A_E74C			; if no characters to insert continue
00E749  2               
00E749  2  4C 97 E6     	jmp	ReverseChar		; insert reversed character	[E697]
00E74C  2               
00E74C  2               A_E74C:					;				[E74C]
00E74C  2  C9 14        	cmp	#$14			; compare char with [INSERT]/[DELETE]
00E74E  2  D0 2E        	bne	A_E77E			; if not [INSERT]/[DELETE] go ??
00E750  2               
00E750  2  98           	tya				;.
00E751  2  D0 06        	bne	A_E759			;.
00E753  2               
00E753  2  20 01 E7     	jsr	BackToPrevLine		; back onto previous line if possible
00E756  2               					;				[E701]
00E756  2  4C 73 E7     	jmp	J_E773			;.				[E773]
00E759  2               
00E759  2               A_E759:					;				[E759]
00E759  2  20 A1 E8     	jsr	Test4LineDecr		; test for line decrement	[E8A1]
00E75C  2               
00E75C  2               ; now close up the line
00E75C  2  88           	dey				; decrement index to previous character
00E75D  2  84 D3        	sty	LineCurCol		; save the cursor column
00E75F  2               
00E75F  2  20 24 EA     	jsr	PtrCurLineColRAM	; calculate pointer to colour RAM [EA24]
00E762  2               A_E762:					;				[E762]
00E762  2  C8           	iny				; increment index to next character
00E763  2  B1 D1        	lda	(CurScrLine),Y		; get character from current screen line
00E765  2  88           	dey				; decrement index to previous character
00E766  2  91 D1        	sta	(CurScrLine),Y		; save character to current screen line
00E768  2               
00E768  2  C8           	iny				; increment index to next character
00E769  2  B1 F3        	lda	(ColorRamPtr),Y		; get colour RAM byte
00E76B  2  88           	dey				; decrement index to previous character
00E76C  2  91 F3        	sta	(ColorRamPtr),Y		; save colour RAM byte
00E76E  2               
00E76E  2  C8           	iny				; increment index to next character
00E76F  2  C4 D5        	cpy	CurLineLeng		; comp with current screen line length
00E771  2  D0 EF        	bne	A_E762			; loop if not there yet
00E773  2               
00E773  2               J_E773:					;				[E773]
00E773  2  A9 20        	lda	#' '			; set [SPACE]
00E775  2  91 D1        	sta	(CurScrLine),Y		; clear last char on current screen line
00E777  2               
00E777  2  AD 86 02     	lda	COLOR			; get the current colour code
00E77A  2  91 F3        	sta	(ColorRamPtr),Y		; save to colour RAM
00E77C  2  10 4D        	bpl	A_E7CB			; branch always
00E77E  2               
00E77E  2               A_E77E:					;				[E77E]
00E77E  2  A6 D4        	ldx	QTSW			; get cursor quote flag, $xx = quote,
00E780  2               					; $00 = no quote
00E780  2  F0 03        	beq	A_E785			; branch if not quote mode
00E782  2               
00E782  2  4C 97 E6     	jmp	ReverseChar		; insert reversed character	[E697]
00E785  2               
00E785  2               A_E785:					;				[E785]
00E785  2  C9 12        	cmp	#$12			; compare with [RVS ON]
00E787  2  D0 02        	bne	A_E78B			; if not [RVS ON] skip setting the
00E789  2               					; reverse flag
00E789  2  85 C7        	sta	RVS			; else set the reverse flag
00E78B  2               A_E78B:					;				[E78B]
00E78B  2  C9 13        	cmp	#$13			; compare with [CLR HOME]
00E78D  2  D0 03        	bne	A_E792			; if not [CLR HOME] continue
00E78F  2               
00E78F  2  20 66 E5     	jsr	CursorHome		; home the cursor		[E566]
00E792  2               A_E792:					;				[E792]
00E792  2  C9 1D        	cmp	#$1D			; compare with [CURSOR RIGHT]
00E794  2  D0 17        	bne	A_E7AD			; if not [CURSOR RIGHT] go ??
00E796  2               
00E796  2  C8           	iny				; increment the cursor column
00E797  2               
00E797  2  20 B3 E8     	jsr	Test4LineIncr		; test for line increment	[E8B3]
00E79A  2  84 D3        	sty	LineCurCol		; save the cursor column
00E79C  2               
00E79C  2  88           	dey				; decrement the cursor column
00E79D  2  C4 D5        	cpy	CurLineLeng		; compare cursor column with current
00E79F  2               					; screen line length
00E79F  2  90 09        	bcc	A_E7AA			; exit if less
00E7A1  2               
00E7A1  2               ; else the cursor column is >= the current screen line length so back onto the
00E7A1  2               ; current line and do a newline
00E7A1  2  C6 D6        	dec	PhysCurRow		; decrement the cursor row
00E7A3  2               
00E7A3  2  20 7C E8     	jsr	NewScreenLine		; do newline			[E87C]
00E7A6  2               
00E7A6  2  A0 00        	ldy	#$00			; clear cursor column
00E7A8  2               A_E7A8:					;				[E7A8]
00E7A8  2  84 D3        	sty	LineCurCol		; save the cursor column
00E7AA  2               A_E7AA:					;				[E7AA]
00E7AA  2  4C A8 E6     	jmp	RestorRegsQuot		; restore the registers, set the quote
00E7AD  2               					; flag and exit			[E6A8]
00E7AD  2               A_E7AD:					;				[E7AD]
00E7AD  2  C9 11        	cmp	#$11			; compare with [CURSOR DOWN]
00E7AF  2  D0 1D        	bne	A_E7CE			; if not [CURSOR DOWN] go ??
00E7B1  2               
00E7B1  2  18           	clc				; clear carry for add
00E7B2  2  98           	tya				; copy the cursor column
00E7B3  2  69 28        	adc	#$28			; add one line
00E7B5  2  A8           	tay				; copy back to Y
00E7B6  2               
00E7B6  2  E6 D6        	inc	PhysCurRow		; increment the cursor row
00E7B8  2               
00E7B8  2  C5 D5        	cmp	CurLineLeng		; compare cursor column with current
00E7BA  2               					; screen line length
00E7BA  2  90 EC        	bcc	A_E7A8			; if less, save cursor column and exit
00E7BC  2               
00E7BC  2  F0 EA        	beq	A_E7A8			; if equal, save cursor column and exit
00E7BE  2               
00E7BE  2               ; else the cursor has moved beyond the end of this line so back it up until
00E7BE  2               ; it's on the start of the logical line
00E7BE  2  C6 D6        	dec	PhysCurRow		; decrement the cursor row
00E7C0  2               A_E7C0:					;				[E7C0]
00E7C0  2  E9 28        	sbc	#$28			; subtract one line
00E7C2  2  90 04        	bcc	A_E7C8			; if on previous line exit the loop
00E7C4  2               
00E7C4  2  85 D3        	sta	LineCurCol		; else save the cursor column
00E7C6  2  D0 F8        	bne	A_E7C0			; loop if not at the start of the line
00E7C8  2               
00E7C8  2               A_E7C8:					;				[E7C8]
00E7C8  2  20 7C E8     	jsr	NewScreenLine		; do newline			[E87C]
00E7CB  2               A_E7CB:					;				[E7CB]
00E7CB  2  4C A8 E6     	jmp	RestorRegsQuot		; restore the registers, set the quote
00E7CE  2               					; flag and exit			[E6A8]
00E7CE  2               A_E7CE:					;				[E7CE]
00E7CE  2  20 CB E8     	jsr	SetColourCode		; set the colour code		[E8CB]
00E7D1  2  4C 44 EC     	jmp	ChkSpecCodes		; go check for special character codes
00E7D4  2               					;				[EC44]
00E7D4  2               ShiftedChars:				;				[E7D4]
00E7D4  2  29 7F        	and	#$7F			; mask 0xxx, clear b7
00E7D6  2  C9 7F        	cmp	#$7F			; was it $FF before the mask
00E7D8  2  D0 02        	bne	A_E7DC			; branch if not
00E7DA  2               
00E7DA  2  A9 5E        	lda	#$5E			; else make it $5E
00E7DC  2               A_E7DC:					;				[E7DC]
00E7DC  2  C9 20        	cmp	#' '			; compare the character with [SPACE]
00E7DE  2  90 03        	bcc	A_E7E3			; if < [SPACE] go ??
00E7E0  2               
00E7E0  2  4C 91 E6     	jmp	UpcChar2Screen		; insert uppercase/graphic character
00E7E3  2               					; and return			[E691]
00E7E3  2               
00E7E3  2               ; character was $80 to $9F and is now $00 to $1F
00E7E3  2               A_E7E3:					;				[E7E3]
00E7E3  2  C9 0D        	cmp	#$0D			; compare with [CR]
00E7E5  2  D0 03        	bne	A_E7EA			; if not [CR] continue
00E7E7  2               
00E7E7  2  4C 91 E8     	jmp	OutputCR		; else output [CR] and return	[E891]
00E7EA  2               
00E7EA  2               ; was not [CR]
00E7EA  2               A_E7EA:					;				[E7EA]
00E7EA  2  A6 D4        	ldx	QTSW			; get the cursor quote flag,
00E7EC  2               					; $xx = quote, $00 = no quote
00E7EC  2  D0 3F        	bne	A_E82D			; branch if quote mode
00E7EE  2               
00E7EE  2  C9 14        	cmp	#$14			; compare with [INSERT DELETE]
00E7F0  2  D0 37        	bne	A_E829			; if not [INSERT DELETE] go ??
00E7F2  2               
00E7F2  2  A4 D5        	ldy	CurLineLeng		; get current screen line length
00E7F4  2  B1 D1        	lda	(CurScrLine),Y		; get character from current screen line
00E7F6  2  C9 20        	cmp	#' '			; compare the character with [SPACE]
00E7F8  2  D0 04        	bne	A_E7FE			; if not [SPACE] continue
00E7FA  2               
00E7FA  2  C4 D3        	cpy	LineCurCol		; compare the current column with the
00E7FC  2               					; cursor column
00E7FC  2  D0 07        	bne	A_E805			; if not cursor column go open up space
00E7FE  2               					; on line
00E7FE  2               A_E7FE:					;				[E7FE]
00E7FE  2  C0 4F        	cpy	#$4F			; compare current column with max line
00E800  2               					; length
00E800  2  F0 24        	beq	A_E826			; if at line end just exit
00E802  2               
00E802  2  20 65 E9     	jsr	InsertLine		; else open up a space on the screen
00E805  2               					; now open up space on the line to
00E805  2               					; insert a character		[E965]
00E805  2               A_E805:					;				[E805]
00E805  2  A4 D5        	ldy	CurLineLeng		; get current screen line length
00E807  2  20 24 EA     	jsr	PtrCurLineColRAM	; calc the pointer to colour RAM [EA24]
00E80A  2               A_E80A:					;				[E80A]
00E80A  2  88           	dey				; decrement index to previous character
00E80B  2  B1 D1        	lda	(CurScrLine),Y		; get the character from the current
00E80D  2               					; screen line
00E80D  2  C8           	iny				; increment the index to next character
00E80E  2  91 D1        	sta	(CurScrLine),Y		; save the character to the current
00E810  2               					; screen line
00E810  2  88           	dey				; decrement index to previous character
00E811  2  B1 F3        	lda	(ColorRamPtr),Y		; get the current screen line colour
00E813  2               					; RAM byte
00E813  2  C8           	iny				; increment the index to next character
00E814  2  91 F3        	sta	(ColorRamPtr),Y		; save the current screen line colour
00E816  2               					; RAM byte
00E816  2  88           	dey				; decrement index to the previous char
00E817  2  C4 D3        	cpy	LineCurCol		; compare index with the cursor column
00E819  2  D0 EF        	bne	A_E80A			; loop if not there yet
00E81B  2               
00E81B  2  A9 20        	lda	#' '			; set [SPACE]
00E81D  2  91 D1        	sta	(CurScrLine),Y		; clear character at cursor position on
00E81F  2               					; current screen line
00E81F  2  AD 86 02     	lda	COLOR			; get current colour code
00E822  2  91 F3        	sta	(ColorRamPtr),Y		; save to cursor position on current
00E824  2               					; screen line colour RAM
00E824  2  E6 D8        	inc	InsertCount		; increment insert count
00E826  2               A_E826:					;				[E826]
00E826  2  4C A8 E6     	jmp	RestorRegsQuot		; restore the registers, set the quote
00E829  2               					; flag and exit			[E6A8]
00E829  2               A_E829:					;				[E829]
00E829  2  A6 D8        	ldx	InsertCount		; get the insert count
00E82B  2  F0 05        	beq	A_E832			; branch if no insert space
00E82D  2               
00E82D  2               A_E82D:					;				[E82D]
00E82D  2  09 40        	ora	#$40			; change to uppercase/graphic
00E82F  2  4C 97 E6     	jmp	ReverseChar		; insert reversed character	[E697]
00E832  2               
00E832  2               A_E832:					;				[E832]
00E832  2  C9 11        	cmp	#$11			; compare with [CURSOR UP]
00E834  2  D0 16        	bne	A_E84C			; branch if not [CURSOR UP]
00E836  2               
00E836  2  A6 D6        	ldx	PhysCurRow		; get the cursor row
00E838  2  F0 37        	beq	A_E871			; if on the top line go restore the
00E83A  2               					; registers, set quote flag and exit
00E83A  2  C6 D6        	dec	PhysCurRow		; decrement the cursor row
00E83C  2               
00E83C  2  A5 D3        	lda	LineCurCol		; get the cursor column
00E83E  2  38           	sec				; set carry for subtract
00E83F  2  E9 28        	sbc	#$28			; subtract one line length
00E841  2  90 04        	bcc	A_E847			; branch if stepped back to prev line
00E843  2               
00E843  2  85 D3        	sta	LineCurCol		; else save the cursor column ..
00E845  2  10 2A        	bpl	A_E871			; .. and exit, branch always
00E847  2               
00E847  2               A_E847:					;				[E847]
00E847  2  20 6C E5     	jsr	CalcCursorPos		; set the screen pointers for cursor
00E84A  2               					; row, column ..		[E56C]
00E84A  2  D0 25        	bne	A_E871			; .. and exit, branch always
00E84C  2               
00E84C  2               A_E84C:					;				[E84C]
00E84C  2  C9 12        	cmp	#$12			; compare with [RVS OFF]
00E84E  2  D0 04        	bne	A_E854			; if not [RVS OFF] continue
00E850  2               
00E850  2  A9 00        	lda	#$00			; else clear A
00E852  2  85 C7        	sta	RVS			; clear the reverse flag
00E854  2               A_E854:					;				[E854]
00E854  2  C9 1D        	cmp	#$1D			; compare with [CURSOR LEFT]
00E856  2  D0 12        	bne	A_E86A			; if not [CURSOR LEFT] go ??
00E858  2               
00E858  2  98           	tya				; copy the cursor column
00E859  2  F0 09        	beq	A_E864			; if at start of line go back onto the
00E85B  2               					; previous line
00E85B  2  20 A1 E8     	jsr	Test4LineDecr		; test for line decrement	[E8A1]
00E85E  2               
00E85E  2  88           	dey				; decrement the cursor column
00E85F  2  84 D3        	sty	LineCurCol		; save the cursor column
00E861  2               
00E861  2  4C A8 E6     	jmp	RestorRegsQuot		; restore the registers, set the quote
00E864  2               					; flag and exit			[E6A8]
00E864  2               A_E864:					;				[E864]
00E864  2  20 01 E7     	jsr	BackToPrevLine		; back to the previous line if possible
00E867  2               					;				[E701]
00E867  2  4C A8 E6     	jmp	RestorRegsQuot		; restore the registers, set the quote
00E86A  2               					; flag and exit			[E6A8]
00E86A  2               A_E86A:					;				[E86A]
00E86A  2  C9 13        	cmp	#$13			; compare with [CLR]
00E86C  2  D0 06        	bne	A_E874			; if not [CLR] continue
00E86E  2               
00E86E  2  20 44 E5     	jsr	ClearScreen		; clear the screen		[E544]
00E871  2               A_E871:					;				[E871]
00E871  2  4C A8 E6     	jmp	RestorRegsQuot		; restore the registers, set the quote
00E874  2               					; flag and exit			[E6A8]
00E874  2               A_E874:					;				[E874]
00E874  2  09 80        	ora	#$80			; restore b7, colour can only be black,
00E876  2               					; cyan, magenta or yellow
00E876  2  20 CB E8     	jsr	SetColourCode		; set the colour code		[E8CB]
00E879  2  4C 4F EC     	jmp	Chk4SpecChar		; go check for special character codes
00E87C  2               					; except for switch to lower case [EC4F]
00E87C  2               
00E87C  2               ;******************************************************************************
00E87C  2               ;
00E87C  2               ; do newline
00E87C  2               ;
00E87C  2               NewScreenLine:				;				[E87C]
00E87C  2  46 C9        	lsr	CursorRow		; shift >> input cursor row
00E87E  2  A6 D6        	ldx	PhysCurRow		; get the cursor row
00E880  2               A_E880:					;				[E880]
00E880  2  E8           	inx				; increment the row
00E881  2  E0 19        	cpx	#$19			; compare it with last row + 1
00E883  2  D0 03        	bne	A_E888			; if not last row+1 skip screen scroll
00E885  2               
00E885  2  20 EA E8     	jsr	ScrollScreen		; else scroll the screen	[E8EA]
00E888  2               A_E888:					;				[E888]
00E888  2  B5 D9        	lda	LDTB1,X			; get start of line X pointer HB
00E88A  2  10 F4        	bpl	A_E880			; loop if not start of logical line
00E88C  2               
00E88C  2  86 D6        	stx	PhysCurRow		; save the cursor row
00E88E  2               
00E88E  2  4C 6C E5     	jmp	CalcCursorPos		; set the screen pointers for cursor
00E891  2               					; row, column and return	[E56C]
00E891  2               
00E891  2               
00E891  2               ;******************************************************************************
00E891  2               ;
00E891  2               ; output [CR]
00E891  2               ;
00E891  2               OutputCR:				;				[E891]
00E891  2  A2 00        	ldx	#$00			; clear X
00E893  2  86 D8        	stx	InsertCount		; clear the insert count
00E895  2  86 C7        	stx	RVS			; clear the reverse flag
00E897  2  86 D4        	stx	QTSW			; clear the cursor quote flag,
00E899  2               					; $xx = quote, $00 = no quote
00E899  2  86 D3        	stx	LineCurCol		; save the cursor column
00E89B  2               
00E89B  2  20 7C E8     	jsr	NewScreenLine		; do newline			[E87C]
00E89E  2  4C A8 E6     	jmp	RestorRegsQuot		; restore the registers, set the quote
00E8A1  2               					; flag and exit			[E6A8]
00E8A1  2               
00E8A1  2               
00E8A1  2               ;******************************************************************************
00E8A1  2               ;
00E8A1  2               ; test for line decrement
00E8A1  2               ;
00E8A1  2               Test4LineDecr:				;				[E8A1]
00E8A1  2  A2 02        	ldx	#$02			; set the count
00E8A3  2  A9 00        	lda	#$00			; set the column
00E8A5  2               A_E8A5:					;				[E8A5]
00E8A5  2  C5 D3        	cmp	LineCurCol		; compare column with the cursor column
00E8A7  2  F0 07        	beq	A_E8B0			; if at the start of the line, go
00E8A9  2               					; decrement the cursor row and exit
00E8A9  2  18           	clc				; else clear carry for add
00E8AA  2  69 28        	adc	#$28			; increment to next line
00E8AC  2               
00E8AC  2  CA           	dex				; decrement loop count
00E8AD  2  D0 F6        	bne	A_E8A5			; loop if more to test
00E8AF  2               
00E8AF  2  60           	rts
00E8B0  2               
00E8B0  2               A_E8B0:					;				[E8B0]
00E8B0  2  C6 D6        	dec	PhysCurRow		; else decrement the cursor row
00E8B2  2               
00E8B2  2  60           	rts
00E8B3  2               
00E8B3  2               
00E8B3  2               ;******************************************************************************
00E8B3  2               ;
00E8B3  2               ; test for line increment. if at end of the line, but not at end of the last
00E8B3  2               ; line, increment the cursor row
00E8B3  2               ;
00E8B3  2               Test4LineIncr:				;				[E8B3]
00E8B3  2  A2 02        	ldx	#$02			; set the count
00E8B5  2  A9 27        	lda	#$27			; set the column
00E8B7  2               A_E8B7:					;				[E8B7]
00E8B7  2  C5 D3        	cmp	LineCurCol		; compare column with the cursor column
00E8B9  2  F0 07        	beq	A_E8C2			; if at end of line test and possibly
00E8BB  2               					; increment cursor row
00E8BB  2  18           	clc				; else clear carry for add
00E8BC  2  69 28        	adc	#$28			; increment to the next line
00E8BE  2  CA           	dex				; decrement the loop count
00E8BF  2  D0 F6        	bne	A_E8B7			; loop if more to test
00E8C1  2               
00E8C1  2  60           	rts
00E8C2  2               
00E8C2  2               ; cursor is at end of line
00E8C2  2               A_E8C2:					;				[E8C2]
00E8C2  2  A6 D6        	ldx	PhysCurRow		; get the cursor row
00E8C4  2  E0 19        	cpx	#$19			; compare it with the end of the screen
00E8C6  2  F0 02        	beq	A_E8CA			; if at the end of screen just exit
00E8C8  2               
00E8C8  2  E6 D6        	inc	PhysCurRow		; else increment the cursor row
00E8CA  2               A_E8CA:					;				[E8CA]
00E8CA  2  60           	rts
00E8CB  2               
00E8CB  2               
00E8CB  2               ;******************************************************************************
00E8CB  2               ;
00E8CB  2               ; set the colour code. enter with the colour character in A. if A does not
00E8CB  2               ; contain a colour character this routine exits without changing the colour
00E8CB  2               ;
00E8CB  2               SetColourCode:				;				[E8CB]
00E8CB  2  A2 0F        	ldx	#D_E8E9-AscColourCodes	; set the colour code count
00E8CD  2               A_E8CD:					;				[E8CD]
00E8CD  2  DD DA E8     	cmp	AscColourCodes,X	; compare character with a table code
00E8D0  2  F0 04        	beq	A_E8D6			; if a match go save colour and exit
00E8D2  2               
00E8D2  2  CA           	dex				; else decrement the index
00E8D3  2  10 F8        	bpl	A_E8CD			; loop if more to do
00E8D5  2               
00E8D5  2  60           	rts
00E8D6  2               
00E8D6  2               A_E8D6:					;				[E8D6]
00E8D6  2  8E 86 02     	stx	COLOR			; save the current colour code
00E8D9  2               
00E8D9  2  60           	rts
00E8DA  2               
00E8DA  2               
00E8DA  2               ;******************************************************************************
00E8DA  2               ;
00E8DA  2               ; ASCII colour code table
00E8DA  2               ;					; CHR$()	colour
00E8DA  2               AscColourCodes:				; ------	------
00E8DA  2  90           .byte	$90				;  144		black
00E8DB  2  05           .byte	$05				;    5		white
00E8DC  2  1C           .byte	$1C				;   28		red
00E8DD  2  9F           .byte	$9F				;  159		cyan
00E8DE  2  9C           .byte	$9C				;  156		purple
00E8DF  2  1E           .byte	$1E				;   30		green
00E8E0  2  1F           .byte	$1F				;   31		Blue
00E8E1  2  9E           .byte	$9E				;  158		yellow
00E8E2  2  81           .byte	$81				;  129		orange
00E8E3  2  95           .byte	$95				;  149		brown
00E8E4  2  96           .byte	$96				;  150		light red
00E8E5  2  97           .byte	$97				;  151		dark grey
00E8E6  2  98           .byte	$98				;  152		medium grey
00E8E7  2  99           .byte	$99				;  153		light green
00E8E8  2  9A           .byte	$9A				;  154		light blue
00E8E9  2               D_E8E9:					;				[E8E9]
00E8E9  2  9B           .byte	$9B				;  155		light grey
00E8EA  2               
00E8EA  2               
00E8EA  2               ;******************************************************************************
00E8EA  2               ;
00E8EA  2               ; scroll the screen
00E8EA  2               ;
00E8EA  2               ScrollScreen:				;				[E8EA]
00E8EA  2  A5 AC        	lda	SAL			; copy the tape buffer start pointer
00E8EC  2  48           	pha				; save it
00E8ED  2               
00E8ED  2  A5 AD        	lda	SAL+1			; copy the tape buffer start pointer
00E8EF  2  48           	pha				; save it
00E8F0  2               
00E8F0  2  A5 AE        	lda	EAL			; copy the tape buffer end pointer
00E8F2  2  48           	pha				; save it
00E8F3  2               
00E8F3  2  A5 AF        	lda	EAL+1			; copy the tape buffer end pointer
00E8F5  2  48           	pha				; save it
00E8F6  2               A_E8F6:					;				[E8F6]
00E8F6  2  A2 FF        	ldx	#$FF			; set to -1 for pre increment loop
00E8F8  2               
00E8F8  2  C6 D6        	dec	PhysCurRow		; decrement the cursor row
00E8FA  2  C6 C9        	dec	CursorRow		; decrement the input cursor row
00E8FC  2  CE A5 02     	dec	TmpLineScrl		; decrement the screen row marker
00E8FF  2               A_E8FF:					;				[E8FF]
00E8FF  2  E8           	inx				; increment the line number
00E900  2               
00E900  2  20 F0 E9     	jsr	FetchScreenAddr		; fetch a screen address, set the start
00E903  2               					; of line X			[E9F0]
00E903  2  E0 18        	cpx	#$18			; compare with last line
00E905  2  B0 0C        	bcs	A_E913			; branch if >= $16
00E907  2               
00E907  2  BD F1 EC     	lda	TblScrLinesLB+1,X	; get the start of the next line
00E90A  2               					; pointer LB
00E90A  2  85 AC        	sta	SAL			; save the next line pointer LB
00E90C  2               
00E90C  2  B5 DA        	lda	LDTB1+1,X		; get the start of the next line
00E90E  2               					; pointer HB
00E90E  2  20 C8 E9     	jsr	ShiftLineUpDwn		; shift the screen line up	[E9C8]
00E911  2  30 EC        	bmi	A_E8FF			; loop, branch always
00E913  2               
00E913  2               A_E913:					;				[E913]
00E913  2  20 FF E9     	jsr	ClearLineX		; clear screen line X		[E9FF]
00E916  2               
00E916  2               ; now shift up the start of logical line bits
00E916  2  A2 00        	ldx	#$00			; clear index
00E918  2               A_E918:					;				[E918]
00E918  2  B5 D9        	lda	LDTB1,X			; get start of line X pointer HB
00E91A  2  29 7F        	and	#$7F			; clear line X start of logical line bit
00E91C  2               
00E91C  2  B4 DA        	ldy	LDTB1+1,X		; get the start of the next line
00E91E  2               					; pointer HB
00E91E  2  10 02        	bpl	A_E922			; if next line is not a start of line
00E920  2               					; skip the start set
00E920  2  09 80        	ora	#$80			; set line X start of logical line bit
00E922  2               A_E922:					;				[E922]
00E922  2  95 D9        	sta	LDTB1,X			; set start of line X pointer HB
00E924  2               
00E924  2  E8           	inx				; increment line number
00E925  2  E0 18        	cpx	#$18			; compare with last line
00E927  2  D0 EF        	bne	A_E918			; loop if not last line
00E929  2               
00E929  2  A5 F1        	lda	LDTB1+$18		; start of last line pointer HB
00E92B  2  09 80        	ora	#$80			; mark as start of logical line
00E92D  2  85 F1        	sta	LDTB1+$18
00E92F  2               
00E92F  2  A5 D9        	lda	LDTB1			; start of first line pointer HB
00E931  2  10 C3        	bpl	A_E8F6			; if not start of logical line loop back
00E933  2               					; and scroll the screen up another line
00E933  2               
00E933  2  E6 D6        	inc	PhysCurRow		; increment the cursor row
00E935  2  EE A5 02     	inc	TmpLineScrl		; increment screen row marker
00E938  2               
00E938  2  A9 7F        	lda	#$7F			; set keyboard column c7
00E93A  2  8D 00 DC     	sta	CIA1DRA			; save CIA 1 DRA, keyboard column drive
00E93D  2               
00E93D  2  AD 01 DC     	lda	CIA1DRB			; read CIA 1 DRB, keyboard row port
00E940  2  C9 FB        	cmp	#$FB			; compare with row r2 active, [CTL]
00E942  2               
00E942  2  08           	php				; save status
00E943  2               
00E943  2  A9 7F        	lda	#$7F			; set keyboard column c7
00E945  2  8D 00 DC     	sta	CIA1DRA			; save CIA 1 DRA, keyboard column drive
00E948  2               
00E948  2  28           	plp				; restore status
00E949  2  D0 0B        	bne	A_E956			; skip delay if ??
00E94B  2               
00E94B  2               ; first time round the inner loop X will be $16
00E94B  2  A0 00        	ldy	#$00			; clear delay outer loop count, do this
00E94D  2               					; 256 times
00E94D  2               A_E94D:					;				[E94D]
00E94D  2  EA           	nop				; waste cycles
00E94E  2               
00E94E  2  CA           	dex				; decrement inner loop count
00E94F  2  D0 FC        	bne	A_E94D			; loop if not all done
00E951  2               
00E951  2  88           	dey				; decrement outer loop count
00E952  2  D0 F9        	bne	A_E94D			; loop if not all done
00E954  2               
00E954  2  84 C6        	sty	NDX			; clear the keyboard buffer index
00E956  2               A_E956:					;				[E956]
00E956  2  A6 D6        	ldx	PhysCurRow		; get the cursor row
00E958  2               
00E958  2               ; restore the tape buffer pointers and exit
00E958  2               RestrTapBufPtr:				;				[E958]
00E958  2  68           	pla				; pull tape buffer end pointer
00E959  2  85 AF        	sta	EAL+1			; restore it
00E95B  2               
00E95B  2  68           	pla				; pull tape buffer end pointer
00E95C  2  85 AE        	sta	EAL			; restore it
00E95E  2               
00E95E  2  68           	pla				; pull tape buffer pointer
00E95F  2  85 AD        	sta	SAL+1			; restore it
00E961  2               
00E961  2  68           	pla				; pull tape buffer pointer
00E962  2  85 AC        	sta	SAL			; restore it
00E964  2               
00E964  2  60           	rts
00E965  2               
00E965  2               
00E965  2               ;******************************************************************************
00E965  2               ;
00E965  2               ; open up a space on the screen
00E965  2               ;
00E965  2               InsertLine:				;				[E965]
00E965  2  A6 D6        	ldx	PhysCurRow		; get the cursor row
00E967  2               InsertLine2:				;				[E967]
00E967  2  E8           	inx				; increment the row
00E968  2  B5 D9        	lda	LDTB1,X			; get start of line X pointer HB
00E96A  2  10 FB        	bpl	InsertLine2		; loop if not start of logical line
00E96C  2               
00E96C  2  8E A5 02     	stx	TmpLineScrl		; save the screen row marker
00E96F  2               
00E96F  2  E0 18        	cpx	#$18			; compare it with the last line
00E971  2  F0 0E        	beq	A_E981			; if = last line go ??
00E973  2               
00E973  2  90 0C        	bcc	A_E981			; if < last line go ??
00E975  2               
00E975  2               ; else it was > last line
00E975  2  20 EA E8     	jsr	ScrollScreen		; scroll the screen		[E8EA]
00E978  2               
00E978  2  AE A5 02     	ldx	TmpLineScrl		; get the screen row marker
00E97B  2  CA           	dex				; decrement the screen row marker
00E97C  2               
00E97C  2  C6 D6        	dec	PhysCurRow		; decrement the cursor row
00E97E  2               
00E97E  2  4C DA E6     	jmp	AddRow2CurLine		; add this row to the current logical
00E981  2               					; line and return		[E6DA]
00E981  2               A_E981:					;				[E981]
00E981  2  A5 AC        	lda	SAL			; copy tape buffer pointer
00E983  2  48           	pha				; save it
00E984  2               
00E984  2  A5 AD        	lda	SAL+1			; copy tape buffer pointer
00E986  2  48           	pha				; save it
00E987  2               
00E987  2  A5 AE        	lda	EAL			; copy tape buffer end pointer
00E989  2  48           	pha				; save it
00E98A  2               
00E98A  2  A5 AF        	lda	EAL+1			; copy tape buffer end pointer
00E98C  2  48           	pha				; save it
00E98D  2               
00E98D  2  A2 19        	ldx	#$19			; set to end line + 1 for predecrement
00E98F  2               					; loop
00E98F  2               A_E98F:					;				[E98F]
00E98F  2  CA           	dex				; decrement the line number
00E990  2               
00E990  2  20 F0 E9     	jsr	FetchScreenAddr		; fetch a screen address	[E9F0]
00E993  2  EC A5 02     	cpx	TmpLineScrl		; compare it with the screen row marker
00E996  2  90 0E        	bcc	A_E9A6			; if < screen row marker go ??
00E998  2               
00E998  2  F0 0C        	beq	A_E9A6			; if = screen row marker go ??
00E99A  2               
00E99A  2  BD EF EC     	lda	TblScrLinesLB-1,X	; else get the start of the previous
00E99D  2               					; line LB from the ROM table
00E99D  2  85 AC        	sta	SAL			; save previous line pointer LB
00E99F  2               
00E99F  2  B5 D8        	lda	LDTB1-1,X		; get the start of the previous line
00E9A1  2               					; pointer HB
00E9A1  2  20 C8 E9     	jsr	ShiftLineUpDwn		; shift the screen line down	[E9C8]
00E9A4  2  30 E9        	bmi	A_E98F			; loop, branch always
00E9A6  2               
00E9A6  2               A_E9A6:					;				[E9A6]
00E9A6  2  20 FF E9     	jsr	ClearLineX		; clear screen line X		[E9FF]
00E9A9  2               
00E9A9  2  A2 17        	ldx	#$17			;.
00E9AB  2               A_E9AB:					;				[E9AB]
00E9AB  2  EC A5 02     	cpx	TmpLineScrl		; compare it with the screen row marker
00E9AE  2  90 0F        	bcc	A_E9BF			;.
00E9B0  2               
00E9B0  2  B5 DA        	lda	LDTB1+1,X		;.
00E9B2  2  29 7F        	and	#$7F			;.
00E9B4  2               
00E9B4  2  B4 D9        	ldy	LDTB1,X			; get start of line X pointer HB
00E9B6  2  10 02        	bpl	A_E9BA			;.
00E9B8  2               
00E9B8  2  09 80        	ora	#$80			;.
00E9BA  2               A_E9BA:					;				[E9BA]
00E9BA  2  95 DA        	sta	LDTB1+1,X		;.
00E9BC  2               
00E9BC  2  CA           	dex				;.
00E9BD  2  D0 EC        	bne	A_E9AB			;.
00E9BF  2               
00E9BF  2               A_E9BF:					;				[E9BF]
00E9BF  2  AE A5 02     	ldx	TmpLineScrl		; get the screen row marker
00E9C2  2  20 DA E6     	jsr	AddRow2CurLine		; add this row to current logical line
00E9C5  2               					;				[E6DA]
00E9C5  2  4C 58 E9     	jmp	RestrTapBufPtr		; restore tape buffer pointers and exit
00E9C8  2               					;				[E958]
00E9C8  2               
00E9C8  2               ;******************************************************************************
00E9C8  2               ;
00E9C8  2               ; shift screen line up/down
00E9C8  2               ;
00E9C8  2               ShiftLineUpDwn:				;				[E9C8]
00E9C8  2  29 03        	and	#$03			; mask 0000 00xx, line memory page
00E9CA  2  0D 88 02     	ora	HIBASE			; OR with screen memory page
00E9CD  2  85 AD        	sta	SAL+1			; save next/previous line pointer HB
00E9CF  2               
00E9CF  2  20 E0 E9     	jsr	PtrLineColRAM		; calculate pointers to screen lines
00E9D2  2               					; colour RAM			[E9E0]
00E9D2  2  A0 27        	ldy	#$27			; set the column count
00E9D4  2               A_E9D4:					;				[E9D4]
00E9D4  2  B1 AC        	lda	(SAL),Y			; get character from next/previous
00E9D6  2               					; screen line
00E9D6  2  91 D1        	sta	(CurScrLine),Y		; save character to current screen line
00E9D8  2               
00E9D8  2  B1 AE        	lda	(EAL),Y			; get colour from next/previous screen
00E9DA  2               					; line colour RAM
00E9DA  2  91 F3        	sta	(ColorRamPtr),Y		; save colour to current screen line
00E9DC  2               					; colour RAM
00E9DC  2  88           	dey				; decrement column index/count
00E9DD  2  10 F5        	bpl	A_E9D4			; loop if more to do
00E9DF  2               
00E9DF  2  60           	rts
00E9E0  2               
00E9E0  2               
00E9E0  2               ;******************************************************************************
00E9E0  2               ;
00E9E0  2               ; calculate pointers to screen lines colour RAM
00E9E0  2               ;
00E9E0  2               PtrLineColRAM:				;				[E9E0]
00E9E0  2  20 24 EA     	jsr	PtrCurLineColRAM	; calculate the pointer to the current
00E9E3  2               					; screen line colour RAM	[EA24]
00E9E3  2  A5 AC        	lda	SAL			; get the next screen line pointer LB
00E9E5  2  85 AE        	sta	EAL			; save the next screen line colour RAM
00E9E7  2               					; pointer LB
00E9E7  2  A5 AD        	lda	SAL+1			; get the next screen line pointer HB
00E9E9  2  29 03        	and	#$03			; mask 0000 00xx, line memory page
00E9EB  2  09 D8        	ora	#>ColourRAM		; set  1101 01xx, colour memory page
00E9ED  2  85 AF        	sta	EAL+1			; save the next screen line colour RAM
00E9EF  2               					; pointer HB
00E9EF  2  60           	rts
00E9F0  2               
00E9F0  2               
00E9F0  2               ;******************************************************************************
00E9F0  2               ;
00E9F0  2               ; fetch a screen address
00E9F0  2               ;
00E9F0  2               FetchScreenAddr:			;				[E9F0]
00E9F0  2  BD F0 EC     	lda	TblScrLinesLB,X		; get the start of line LB from
00E9F3  2               					; the ROM table
00E9F3  2  85 D1        	sta	CurScrLine		; set current screen line pointer LB
00E9F5  2               
00E9F5  2  B5 D9        	lda	LDTB1,X			; get the start of line HB from
00E9F7  2               					; the RAM table
00E9F7  2  29 03        	and	#$03			; mask 0000 00xx, line memory page
00E9F9  2  0D 88 02     	ora	HIBASE			; OR with the screen memory page
00E9FC  2  85 D2        	sta	CurScrLine+1		; save current screen line pointer HB
00E9FE  2               
00E9FE  2  60           	rts
00E9FF  2               
00E9FF  2               
00E9FF  2               ;******************************************************************************
00E9FF  2               ;
00E9FF  2               ; clear screen line X
00E9FF  2               ;
00E9FF  2               ClearLineX:				;				[E9FF]
00E9FF  2  A0 27        	ldy	#$27			; set number of columns to clear
00EA01  2  20 F0 E9     	jsr	FetchScreenAddr		; fetch a screen address	[E9F0]
00EA04  2               
00EA04  2  20 24 EA     	jsr	PtrCurLineColRAM	; calculate pointer to colour RAM [EA24]
00EA07  2               A_EA07:
00EA07  2               .if KERNAL = 1 || KERNAL = 2					;				[EA07]
00EA07  2               	lda	#' '
00EA07  2               	sta	(CurScrLine),Y		; clear character in current screen line
00EA07  2               .endif
00EA07  2               
00EA07  2               .if KERNAL = 1
00EA07  2               	lda	#$01
00EA07  2               	sta	(ColorRamPtr),Y
00EA07  2               .endif
00EA07  2               
00EA07  2               .if KERNAL = 2
00EA07  2               	jsr	SaveCurColour		; save current colour to colour RAM
00EA07  2               					;				[E4DA]
00EA07  2               	nop
00EA07  2               
00EA07  2               	dey				; decrement index
00EA07  2               	bpl	A_EA07			; loop if more to do
00EA07  2               
00EA07  2               	rts
00EA07  2               .endif
00EA07  2               
00EA07  2               .if KERNAL = 3
00EA07  2  20 DA E4     	jsr	SaveCurColour		; save current colour to colour RAM
00EA0A  2               					;				[E4DA]
00EA0A  2  A9 20        	lda	#' '			; set [SPACE]
00EA0C  2  91 D1        	sta	(CurScrLine),Y		; clear character in current screen line
00EA0E  2               
00EA0E  2  88           	dey				; decrement index
00EA0F  2  10 F6        	bpl	A_EA07			; loop if more to do
00EA11  2               
00EA11  2  60           	rts
00EA12  2               
00EA12  2  EA           	nop				; unused
00EA13  2               .endif
00EA13  2               
00EA13  2               
00EA13  2               ;******************************************************************************
00EA13  2               ;
00EA13  2               ; print character A and colour X
00EA13  2               ;
00EA13  2               PrntCharA_ColX:				;				[EA13]
00EA13  2  A8           	tay				; copy the character
00EA14  2               
00EA14  2  A9 02        	lda	#$02			; set the count to $02, usually $14 ??
00EA16  2  85 CD        	sta	BLNCT			; save the cursor countdown
00EA18  2               
00EA18  2  20 24 EA     	jsr	PtrCurLineColRAM	; calculate pointer to colour RAM [EA24]
00EA1B  2  98           	tya				; get the character back
00EA1C  2               
00EA1C  2               
00EA1C  2               ;******************************************************************************
00EA1C  2               ;
00EA1C  2               ; save the character and colour to the screen @ the cursor
00EA1C  2               ;
00EA1C  2               OutCharCol2Scr:				;				[EA1C]
00EA1C  2  A4 D3        	ldy	LineCurCol		; get the cursor column
00EA1E  2  91 D1        	sta	(CurScrLine),Y		; save char from current screen line
00EA20  2               
00EA20  2  8A           	txa				; copy the colour to A
00EA21  2  91 F3        	sta	(ColorRamPtr),Y		; save to colour RAM
00EA23  2               
00EA23  2  60           	rts
00EA24  2               
00EA24  2               
00EA24  2               ;******************************************************************************
00EA24  2               ;
00EA24  2               ; calculate the pointer to colour RAM
00EA24  2               ;
00EA24  2               PtrCurLineColRAM:			;				[EA24]
00EA24  2  A5 D1        	lda	CurScrLine		; get current screen line pointer LB
00EA26  2  85 F3        	sta	ColorRamPtr		; save pointer to colour RAM LB
00EA28  2               
00EA28  2  A5 D2        	lda	CurScrLine+1		; get current screen line pointer HB
00EA2A  2  29 03        	and	#$03			; mask 0000 00xx, line memory page
00EA2C  2  09 D8        	ora	#>ColourRAM		; set  1101 01xx, colour memory page
00EA2E  2  85 F4        	sta	ColorRamPtr+1		; save pointer to colour RAM HB
00EA30  2               
00EA30  2  60           	rts
00EA31  2               
00EA31  2               
00EA31  2               ;******************************************************************************
00EA31  2               ;
00EA31  2               ; IRQ vector: update the clock, flash the cursor, control the cassette and scan
00EA31  2               ; the keyboard
00EA31  2               ;
00EA31  2               IRQ_vector:				;				[EA31]
00EA31  2  20 EA FF     	jsr	IncrClock		; increment the real time clock	[FFEA]
00EA34  2               
00EA34  2  A5 CC        	lda	BLNSW			; get cursor enable, $00 = flash cursor
00EA36  2  D0 29        	bne	A_EA61			; if flash not enabled skip the flash
00EA38  2               
00EA38  2  C6 CD        	dec	BLNCT			; decrement the cursor timing countdown
00EA3A  2  D0 25        	bne	A_EA61			; if not counted out skip the flash
00EA3C  2               
00EA3C  2  A9 14        	lda	#$14			; set the flash count
00EA3E  2  85 CD        	sta	BLNCT			; save the cursor timing countdown
00EA40  2               
00EA40  2  A4 D3        	ldy	LineCurCol		; get the cursor column
00EA42  2               
00EA42  2  46 CF        	lsr	BLNON			; shift b0 cursor blink phase into carry
00EA44  2               
00EA44  2  AE 87 02     	ldx	GDCOL			; get the colour under the cursor
00EA47  2               
00EA47  2  B1 D1        	lda	(CurScrLine),Y		; get character from current screen line
00EA49  2  B0 11        	bcs	A_EA5C			; branch if cursor phase b0 was 1
00EA4B  2               
00EA4B  2  E6 CF        	inc	BLNON			; set the cursor blink phase to 1
00EA4D  2               
00EA4D  2  85 CE        	sta	GDBLN			; save the character under the cursor
00EA4F  2               
00EA4F  2  20 24 EA     	jsr	PtrCurLineColRAM	; calculate the pointer to colour RAM
00EA52  2               					;				[EA24]
00EA52  2               
00EA52  2  B1 F3        	lda	(ColorRamPtr),Y		; get the colour RAM byte
00EA54  2  8D 87 02     	sta	GDCOL			; save the colour under the cursor
00EA57  2               
00EA57  2  AE 86 02     	ldx	COLOR			; get the current colour code
00EA5A  2  A5 CE        	lda	GDBLN			; get the character under the cursor
00EA5C  2               A_EA5C:					;				[EA5C]
00EA5C  2  49 80        	eor	#$80			; toggle b7 of character under cursor
00EA5E  2  20 1C EA     	jsr	OutCharCol2Scr		; save the character and colour to the
00EA61  2               					; screen @ the cursor		[EA1C]
00EA61  2               A_EA61:					;				[EA61]
00EA61  2  A5 01        	lda	P6510			; read the 6510 I/O port
00EA63  2  29 10        	and	#$10			; mask 000x 0000, cassette switch sense
00EA65  2  F0 0A        	beq	A_EA71			; if the cassette sense is low skip the
00EA67  2               					; motor stop
00EA67  2               ; the cassette sense was high, the switch was open, so turn off the motor and
00EA67  2               ; clear the interlock
00EA67  2  A0 00        	ldy	#$00			; clear Y
00EA69  2  84 C0        	sty	CAS1			; clear the tape motor interlock
00EA6B  2               
00EA6B  2  A5 01        	lda	P6510			; read the 6510 I/O port
00EA6D  2  09 20        	ora	#$20			; mask xx1x, turn off
00EA6F  2               					; the motor
00EA6F  2  D0 08        	bne	A_EA79			; go save the port value, branch always
00EA71  2               
00EA71  2               ; the cassette sense was low so turn the motor on, perhaps
00EA71  2               A_EA71:					;				[EA71]
00EA71  2  A5 C0        	lda	CAS1			; get the tape motor interlock
00EA73  2  D0 06        	bne	A_EA7B			; if the cassette interlock <> 0 don't
00EA75  2               					; turn on motor
00EA75  2               
00EA75  2  A5 01        	lda	P6510			; read the 6510 I/O port
00EA77  2  29 1F        	and	#$1F			; mask xx0x, turn on
00EA79  2               					; the motor
00EA79  2               A_EA79:					;				[EA79]
00EA79  2  85 01        	sta	P6510			; save the 6510 I/O port
00EA7B  2               A_EA7B:					;				[EA7B]
00EA7B  2  20 87 EA     	jsr	ScanKeyboard2		; scan the keyboard		[EA87]
00EA7E  2               
00EA7E  2  AD 0D DC     	lda	CIA1IRQ			; read CIA 1 ICR, clear the timer
00EA81  2               					; interrupt flag
00EA81  2               
00EA81  2  68           	pla				; pull Y
00EA82  2  A8           	tay				; restore Y
00EA83  2               
00EA83  2  68           	pla				; pull X
00EA84  2  AA           	tax				; restore X
00EA85  2               
00EA85  2  68           	pla				; restore A
00EA86  2               
00EA86  2  40           	rti
00EA87  2               
00EA87  2               
00EA87  2               ;******************************************************************************
00EA87  2               ;
00EA87  2               ; scan keyboard performs the following ..
00EA87  2               ;
00EA87  2               ; 1)	check if key pressed, if not then exit the routine
00EA87  2               ;
00EA87  2               ; 2)	init I/O ports of CIA ?? for keyboard scan and set pointers to decode
00EA87  2               ; 	table 1. clear the character counter
00EA87  2               ;
00EA87  2               ; 3)	set one line of port B low and test for a closed key on port A by
00EA87  2               ;	shifting the byte read from the port. if the carry is clear then a key
00EA87  2               ;	is closed so save the	count which is incremented on each shift. check
00EA87  2               ;	for shift/stop/cbm keys and flag if closed
00EA87  2               ;
00EA87  2               ; 4)	repeat step 3 for the whole matrix
00EA87  2               ;
00EA87  2               ; 5)	evaluate the SHIFT/CTRL/C= keys, this may change the decode table
00EA87  2               ;	selected
00EA87  2               ;
00EA87  2               ; 6)	use the key count saved in step 3 as an index into the table selected
00EA87  2               ;	in step 5
00EA87  2               ; 7)	check for key repeat operation
00EA87  2               ;
00EA87  2               ; 8)	save the decoded key to the buffer if first press or repeat
00EA87  2               ;
00EA87  2               ; scan the keyboard
00EA87  2               ;
00EA87  2               ScanKeyboard2:				;				[EA87]
00EA87  2  A9 00        	lda	#$00			; clear A
00EA89  2  8D 8D 02     	sta	SHFLAG			; clear keyboard shift/control/c= flag
00EA8C  2               
00EA8C  2  A0 40        	ldy	#$40			; set no key
00EA8E  2  84 CB        	sty	SFDX			; save which key
00EA90  2               
00EA90  2  8D 00 DC     	sta	CIA1DRA			; clear CIA 1 DRA, keyboard column drive
00EA93  2               
00EA93  2  AE 01 DC     	ldx	CIA1DRB			; read CIA 1 DRB, keyboard row port
00EA96  2  E0 FF        	cpx	#$FF			; compare with all bits set
00EA98  2  F0 61        	beq	A_EAFB			; if no key pressed clear current key
00EA9A  2               					; and exit (does further BEQ to A_EBBA)
00EA9A  2  A8           	tay				; clear the key count
00EA9B  2               
00EA9B  2  A9 81        	lda	#<TblStandardKeys	; get the decode table LB
00EA9D  2  85 F5        	sta	KEYTAB			; save the keyboard pointer LB
00EA9F  2               
00EA9F  2  A9 EB        	lda	#>TblStandardKeys	; get the decode table HB
00EAA1  2  85 F6        	sta	KEYTAB+1		; save the keyboard pointer HB
00EAA3  2               
00EAA3  2  A9 FE        	lda	#$FE			; set column 0 low
00EAA5  2  8D 00 DC     	sta	CIA1DRA			; save CIA 1 DRA, keyboard column drive
00EAA8  2               A_EAA8:					;				[EAA8]
00EAA8  2  A2 08        	ldx	#$08			; set the row count
00EAAA  2               
00EAAA  2  48           	pha				; save the column
00EAAB  2               A_EAAB:					;				[EAAB]
00EAAB  2  AD 01 DC     	lda	CIA1DRB			; read CIA 1 DRB, keyboard row port
00EAAE  2  CD 01 DC     	cmp	CIA1DRB			; compare it with itself
00EAB1  2  D0 F8        	bne	A_EAAB			; loop if changing
00EAB3  2               
00EAB3  2               A_EAB3:					;				[EAB3]
00EAB3  2  4A           	lsr				; shift row to Cb
00EAB4  2  B0 16        	bcs	A_EACC			; if no key closed on this row go do
00EAB6  2               					; next row
00EAB6  2  48           	pha				; save row
00EAB7  2               
00EAB7  2  B1 F5        	lda	(KEYTAB),Y		; get character from decode table
00EAB9  2  C9 05        	cmp	#$05			; there is no $05 key but the control
00EABB  2               					; keys are all less than $05
00EABB  2  B0 0C        	bcs	A_EAC9			; if not shift/control/c=/stop go save
00EABD  2               					; key count
00EABD  2               ; else was shift/control/c=/stop key
00EABD  2  C9 03        	cmp	#$03			; compare with $03, stop
00EABF  2  F0 08        	beq	A_EAC9			; if stop go save key count and continue
00EAC1  2               
00EAC1  2               ; character is $01 - shift, $02 - c= or $04 - control
00EAC1  2  0D 8D 02     	ora	SHFLAG			; OR it with the keyboard
00EAC4  2               					; shift/control/c= flag
00EAC4  2  8D 8D 02     	sta	SHFLAG			; save keyboard shift/control/c= flag
00EAC7  2  10 02        	bpl	A_EACB			; skip save key, branch always
00EAC9  2               
00EAC9  2               A_EAC9:					;				[EAC9]
00EAC9  2  84 CB        	sty	SFDX			; save key count
00EACB  2               A_EACB:					;				[EACB]
00EACB  2  68           	pla				; restore row
00EACC  2               A_EACC:					;				[EACC]
00EACC  2  C8           	iny				; increment key count
00EACD  2  C0 41        	cpy	#$41			; compare with max+1
00EACF  2  B0 0B        	bcs	A_EADC			; exit loop if >= max+1
00EAD1  2               
00EAD1  2               ; else still in matrix
00EAD1  2  CA           	dex				; decrement row count
00EAD2  2  D0 DF        	bne	A_EAB3			; loop if more rows to do
00EAD4  2               
00EAD4  2  38           	sec				; set carry for keyboard column shift
00EAD5  2  68           	pla				; restore the column
00EAD6  2  2A           	rol				; shift the keyboard column
00EAD7  2  8D 00 DC     	sta	CIA1DRA			; save CIA 1 DRA, keyboard column drive
00EADA  2  D0 CC        	bne	A_EAA8			; loop for next column, branch always
00EADC  2               
00EADC  2               A_EADC:					;				[EADC]
00EADC  2  68           	pla				; dump the saved column
00EADD  2  6C 8F 02     	jmp	(KEYLOG)		; evaluate the SHIFT/CTRL/C= keys
00EAE0  2               
00EAE0  2               ; key decoding continues here after the SHIFT/CTRL/C= keys are evaluated
00EAE0  2               DecodeKeys:				;				[EAE0]
00EAE0  2  A4 CB        	ldy	SFDX			; get saved key count
00EAE2  2  B1 F5        	lda	(KEYTAB),Y		; get character from decode table
00EAE4  2  AA           	tax				; copy character to X
00EAE5  2               
00EAE5  2  C4 C5        	cpy	LSTX			; compare key count with last key count
00EAE7  2  F0 07        	beq	A_EAF0			; if this key = current key, key held,
00EAE9  2               					; go test repeat
00EAE9  2  A0 10        	ldy	#$10			; set the repeat delay count
00EAEB  2  8C 8C 02     	sty	DELAY			; save the repeat delay count
00EAEE  2  D0 36        	bne	A_EB26			; branch always
00EAF0  2               
00EAF0  2               A_EAF0:					;				[EAF0]
00EAF0  2  29 7F        	and	#$7F			; clear b7
00EAF2  2  2C 8A 02     	bit	RPTFLG			; test key repeat
00EAF5  2  30 16        	bmi	A_EB0D			; if repeat all go ??
00EAF7  2               
00EAF7  2  70 49        	bvs	EnableStopKey		; if repeat none go ??
00EAF9  2               
00EAF9  2  C9 7F        	cmp	#$7F			; compare with end marker
00EAFB  2               A_EAFB:					;				[EAFB]
00EAFB  2  F0 29        	beq	A_EB26			; if $00/end marker go save key to
00EAFD  2               					; buffer and exit
00EAFD  2  C9 14        	cmp	#$14			; compare with [INSERT]/[DELETE]
00EAFF  2  F0 0C        	beq	A_EB0D			; if equal, go test for repeat
00EB01  2               
00EB01  2  C9 20        	cmp	#' '			; compare with [SPACE]
00EB03  2  F0 08        	beq	A_EB0D			; if [SPACE] go test for repeat
00EB05  2               
00EB05  2  C9 1D        	cmp	#$1D			; compare with [CURSOR RIGHT]
00EB07  2  F0 04        	beq	A_EB0D			; if [CURSOR RIGHT] go test for repeat
00EB09  2               
00EB09  2  C9 11        	cmp	#$11			; compare with [CURSOR DOWN]
00EB0B  2  D0 35        	bne	EnableStopKey		; if not [CURSOR DOWN] just exit
00EB0D  2               
00EB0D  2               ; was one of the cursor movement keys, insert/delete key or the space bar so
00EB0D  2               ; always do repeat tests
00EB0D  2               A_EB0D:					;				[EB0D]
00EB0D  2  AC 8C 02     	ldy	DELAY			; get the repeat delay counter
00EB10  2  F0 05        	beq	A_EB17			; if delay expired go ??
00EB12  2               
00EB12  2  CE 8C 02     	dec	DELAY			; else decrement repeat delay counter
00EB15  2  D0 2B        	bne	EnableStopKey		; if delay not expired go ??
00EB17  2               
00EB17  2               ; repeat delay counter has expired
00EB17  2               A_EB17:					;				[EB17]
00EB17  2  CE 8B 02     	dec	KOUNT			; decrement the repeat speed counter
00EB1A  2  D0 26        	bne	EnableStopKey		; branch if not expired
00EB1C  2               
00EB1C  2  A0 04        	ldy	#$04			; set for 4/60ths of a second
00EB1E  2  8C 8B 02     	sty	KOUNT			; save the repeat speed counter
00EB21  2               
00EB21  2  A4 C6        	ldy	NDX			; get the keyboard buffer index
00EB23  2  88           	dey				; decrement it
00EB24  2  10 1C        	bpl	EnableStopKey		; if the buffer isn't empty just exit
00EB26  2               
00EB26  2               ; else repeat the key immediately
00EB26  2               
00EB26  2               ; possibly save the key to the keyboard buffer. if there was no key pressed or
00EB26  2               ; the key was not found during the scan (possibly due to key bounce) then X
00EB26  2               ; will be $FF here
00EB26  2               A_EB26:					;				[EB26]
00EB26  2  A4 CB        	ldy	SFDX			; get the key count
00EB28  2  84 C5        	sty	LSTX			; save it as the current key count
00EB2A  2               
00EB2A  2  AC 8D 02     	ldy	SHFLAG			; get the keyboard shift/control/c= flag
00EB2D  2  8C 8E 02     	sty	LSTSHF			; save it as last keyboard shift pattern
00EB30  2               
00EB30  2  E0 FF        	cpx	#$FF			; compare the character with the table
00EB32  2               					; end marker or no key
00EB32  2  F0 0E        	beq	EnableStopKey		; if it was the table end marker or no
00EB34  2               					; key, just exit
00EB34  2  8A           	txa				; copy the character to A
00EB35  2               
00EB35  2  A6 C6        	ldx	NDX			; get the keyboard buffer index
00EB37  2  EC 89 02     	cpx	XMAX			; compare it with keyboard buffer size
00EB3A  2  B0 06        	bcs	EnableStopKey		; if the buffer is full just exit
00EB3C  2               
00EB3C  2  9D 77 02     	sta	KeyboardBuf,X		; save character to keyboard buffer
00EB3F  2               
00EB3F  2  E8           	inx				; increment the index
00EB40  2  86 C6        	stx	NDX			; save the keyboard buffer index
00EB42  2               EnableStopKey:				;				[EB42]
00EB42  2  A9 7F        	lda	#$7F			; enable column 7 for the stop key
00EB44  2  8D 00 DC     	sta	CIA1DRA			; save CIA 1 DRA, keyboard column drive
00EB47  2               
00EB47  2  60           	rts
00EB48  2               
00EB48  2               
00EB48  2               ;******************************************************************************
00EB48  2               ;
00EB48  2               ; evaluate the SHIFT/CTRL/C= keys
00EB48  2               ;
00EB48  2               ShftCtrlCbmKey:				;				[EB48]
00EB48  2  AD 8D 02     	lda	SHFLAG			; get the keyboard shift/control/c= flag
00EB4B  2  C9 03        	cmp	#$03			; compare with [SHIFT][C=]
00EB4D  2  D0 15        	bne	A_EB64			; if not [SHIFT][C=] go ??
00EB4F  2               
00EB4F  2  CD 8E 02     	cmp	LSTSHF			; compare with last
00EB52  2  F0 EE        	beq	EnableStopKey		; exit if still the same
00EB54  2               
00EB54  2  AD 91 02     	lda	MODE			; get the shift mode switch,
00EB57  2               					; $00 = enabled, $80 = locked
00EB57  2  30 1D        	bmi	A_EB76			; if locked continue keyboard decode
00EB59  2               
00EB59  2               ; toggle text mode
00EB59  2  AD 18 D0     	lda	VICRAM			; get start of character memory address
00EB5C  2  49 02        	eor	#$02			; toggle address b1
00EB5E  2  8D 18 D0     	sta	VICRAM			; save start of character memory address
00EB61  2               
00EB61  2  4C 76 EB     	jmp	A_EB76			; continue the keyboard decode	[EB76]
00EB64  2               
00EB64  2               ; select keyboard table
00EB64  2               A_EB64:					;				[EB64]
00EB64  2  0A           	asl				; << 1
00EB65  2  C9 08        	cmp	#$08			; compare with [CTRL]
00EB67  2  90 02        	bcc	A_EB6B			; if [CTRL] is not pressed skip the
00EB69  2               					; index change
00EB69  2  A9 06        	lda	#$06			; else [CTRL] was pressed so make the
00EB6B  2               					; index = $06
00EB6B  2               A_EB6B:					;				[EB6B]
00EB6B  2  AA           	tax				; copy the index to X
00EB6C  2               
00EB6C  2  BD 79 EB     	lda	KeyTables,X		; get decode table pointer LB
00EB6F  2  85 F5        	sta	KEYTAB			; save decode table pointer LB
00EB71  2               
00EB71  2  BD 7A EB     	lda	KeyTables+1,X		; get decode table pointer HB
00EB74  2  85 F6        	sta	KEYTAB+1		; save decode table pointer HB
00EB76  2               A_EB76:					;				[EB76]
00EB76  2  4C E0 EA     	jmp	DecodeKeys		; continue the keyboard decode	[EAE0]
00EB79  2               
00EB79  2               
00EB79  2               ;******************************************************************************
00EB79  2               ;
00EB79  2               ; table addresses
00EB79  2               ;
00EB79  2               KeyTables:					;				[EB79]
00EB79  2  81 EB        .word	TblStandardKeys			; standard
00EB7B  2  C2 EB        .word	TblShiftKeys			; shift
00EB7D  2  03 EC        .word	TblCbmKeys			; commodore
00EB7F  2  78 EC        .word	TblControlKeys			; control
00EB81  2               
00EB81  2               
00EB81  2               ;******************************************************************************
00EB81  2               ;
00EB81  2               ; standard keyboard table
00EB81  2               ;
00EB81  2               TblStandardKeys:			;				[EB81]
00EB81  2  14 0D 1D 88  .byte	$14,$0D,$1D,$88,$85,$86,$87,$11
00EB85  2  85 86 87 11  
00EB89  2  33 57 41 34  .byte	$33,$57,$41,$34,$5A,$53,$45,$01
00EB8D  2  5A 53 45 01  
00EB91  2  35 52 44 36  .byte	$35,$52,$44,$36,$43,$46,$54,$58
00EB95  2  43 46 54 58  
00EB99  2  37 59 47 38  .byte	$37,$59,$47,$38,$42,$48,$55,$56
00EB9D  2  42 48 55 56  
00EBA1  2  39 49 4A 30  .byte	$39,$49,$4A,$30,$4D,$4B,$4F,$4E
00EBA5  2  4D 4B 4F 4E  
00EBA9  2  2B 50 4C 2D  .byte	$2B,$50,$4C,$2D,$2E,$3A,$40,$2C
00EBAD  2  2E 3A 40 2C  
00EBB1  2  5C 2A 3B 13  .byte	$5C,$2A,$3B,$13,$01,$3D,$5E,$2F
00EBB5  2  01 3D 5E 2F  
00EBB9  2  31 5F 04 32  .byte	$31,$5F,$04,$32,$20,$02,$51,$03
00EBBD  2  20 02 51 03  
00EBC1  2  FF           .byte	$FF
00EBC2  2               
00EBC2  2               ;	DEL	RETURN	CRSR RI	F7	F1	F3	F5	CRSR DO
00EBC2  2               ;	3	w	a	4	z	s	e	L SHIFT
00EBC2  2               ;	5	r	d	6	c	f	t	x
00EBC2  2               ;	6	y	g	8	b	h	u	v
00EBC2  2               ;	9	i	j	0	m	k	o	n
00EBC2  2               ;	+	p	l	-	.	:	@	,
00EBC2  2               ;		*	;	HOME	R SHIFT	=	^|	/
00EBC2  2               ;	1	<-	CTRL	2	SPACE	CBM	q	STOP
00EBC2  2               
00EBC2  2               
00EBC2  2               ;******************************************************************************
00EBC2  2               ;
00EBC2  2               ; shifted keyboard table
00EBC2  2               ;
00EBC2  2               TblShiftKeys:				;				[EBC2]
00EBC2  2  94 8D 9D 8C  .byte	$94,$8D,$9D,$8C,$89,$8A,$8B,$91
00EBC6  2  89 8A 8B 91  
00EBCA  2  23 D7 C1 24  .byte	$23,$D7,$C1,$24,$DA,$D3,$C5,$01
00EBCE  2  DA D3 C5 01  
00EBD2  2  25 D2 C4 26  .byte	$25,$D2,$C4,$26,$C3,$C6,$D4,$D8
00EBD6  2  C3 C6 D4 D8  
00EBDA  2  27 D9 C7 28  .byte	$27,$D9,$C7,$28,$C2,$C8,$D5,$D6
00EBDE  2  C2 C8 D5 D6  
00EBE2  2  29 C9 CA 30  .byte	$29,$C9,$CA,$30,$CD,$CB,$CF,$CE
00EBE6  2  CD CB CF CE  
00EBEA  2  DB D0 CC DD  .byte	$DB,$D0,$CC,$DD,$3E,$5B,$BA,$3C
00EBEE  2  3E 5B BA 3C  
00EBF2  2  A9 C0 5D 93  .byte	$A9,$C0,$5D,$93,$01,$3D,$DE,$3F
00EBF6  2  01 3D DE 3F  
00EBFA  2  21 5F 04 22  .byte	$21,$5F,$04,$22,$A0,$02,$D1,$83
00EBFE  2  A0 02 D1 83  
00EC02  2  FF           .byte	$FF
00EC03  2               
00EC03  2               ;	INST	RRETURN	CRSR LE	F8	F2	F4	F6	CRSR UP
00EC03  2               ;	#	W	A	$	Z	S	E	LE SHIFT
00EC03  2               ;	%	R	D	&	C	F	T	X
00EC03  2               ;	'	Y	G	(	B	H	U	V
00EC03  2               ;	)	I	J	0	M	K	O	N
00EC03  2               ;	cbm gr	P	L	cbm gr	>	[	cbm gr	<
00EC03  2               ;	cbm gr	cbm gr	[	CLR	R SHIFT	=	pi	?
00EC03  2               ;	!	<-	CTRL	"	SPACE	CBM	Q	RUN
00EC03  2               
00EC03  2               
00EC03  2               ;******************************************************************************
00EC03  2               ;
00EC03  2               ; CBM key keyboard table
00EC03  2               ;
00EC03  2               TblCbmKeys:				;				[EC03]
00EC03  2  94 8D 9D 8C  .byte	$94,$8D,$9D,$8C,$89,$8A,$8B,$91
00EC07  2  89 8A 8B 91  
00EC0B  2  96 B3 B0 97  .byte	$96,$B3,$B0,$97,$AD,$AE,$B1,$01
00EC0F  2  AD AE B1 01  
00EC13  2  98 B2 AC 99  .byte	$98,$B2,$AC,$99,$BC,$BB,$A3,$BD
00EC17  2  BC BB A3 BD  
00EC1B  2  9A B7 A5 9B  .byte	$9A,$B7,$A5,$9B,$BF,$B4,$B8,$BE
00EC1F  2  BF B4 B8 BE  
00EC23  2  29 A2 B5 30  .byte	$29,$A2,$B5,$30,$A7,$A1,$B9,$AA
00EC27  2  A7 A1 B9 AA  
00EC2B  2  A6 AF B6 DC  .byte	$A6,$AF,$B6,$DC,$3E,$5B,$A4,$3C
00EC2F  2  3E 5B A4 3C  
00EC33  2  A8 DF 5D 93  .byte	$A8,$DF,$5D,$93,$01,$3D,$DE,$3F
00EC37  2  01 3D DE 3F  
00EC3B  2  81 5F 04 95  .byte	$81,$5F,$04,$95,$A0,$02,$AB,$83
00EC3F  2  A0 02 AB 83  
00EC43  2  FF           .byte	$FF
00EC44  2               
00EC44  2               ;	INST	RETURN	CRSR LE	F8	F2	F4	F6	CRSR UP
00EC44  2               ;	pink	cbm gr	cbm gr	grey 1	cbm gr	cbm gr	cbm gr	LE SHIFT
00EC44  2               ;	grey 2	cbm gr	cbm gr	ligreen	cbm gr	cbm gr	cbm gr	cbm gr
00EC44  2               ;	li blue	cbm gr	cbm gr	grey 3	cbm gr	cbm gr	cbm gr	cbm gr
00EC44  2               ;	)	cbm gr	cbm gr	0	cbm gr	cbm gr	cbm gr	cbm gr
00EC44  2               ;	cbm gr	cbm gr	cbm gr	cbm gr	>	[	cbm gr	<
00EC44  2               ;	cbm gr	cbm gr	]	CLR	R SHIFT	=	pi	?
00EC44  2               ;	orange	<-	CTRL	brown	SPACE	CBM	cbm gr	RUN
00EC44  2               
00EC44  2               
00EC44  2               ;******************************************************************************
00EC44  2               ;
00EC44  2               ; check for special character codes
00EC44  2               ;
00EC44  2               ChkSpecCodes:				;				[EC44]
00EC44  2  C9 0E        	cmp	#$0E			; compare with [SWITCH TO LOWER CASE]
00EC46  2  D0 07        	bne	Chk4SpecChar		; if not equal, skip the switch
00EC48  2               
00EC48  2  AD 18 D0     	lda	VICRAM			; get start of character memory address
00EC4B  2  09 02        	ora	#$02			; mask xx1x, set lower case characters
00EC4D  2  D0 09        	bne	A_EC58			; go save the new value, branch always
00EC4F  2               
00EC4F  2               ; check for special character codes except fro switch to lower case
00EC4F  2               Chk4SpecChar:				;				[EC4F]
00EC4F  2  C9 8E        	cmp	#$8E			; compare with [SWITCH TO UPPER CASE]
00EC51  2  D0 0B        	bne	CheckShiftCbm		; if not [SWITCH TO UPPER CASE] go do
00EC53  2               					; the [SHIFT]+[C=] key check
00EC53  2  AD 18 D0     	lda	VICRAM			; get start of character memory address
00EC56  2  29 FD        	and	#$FD			; mask xx0x, set upper case characters
00EC58  2               A_EC58:					;				[EC58]
00EC58  2  8D 18 D0     	sta	VICRAM			; save start of character memory address
00EC5B  2               A_EC5B:					;				[EC5B]
00EC5B  2  4C A8 E6     	jmp	RestorRegsQuot		; restore the registers, set the quote
00EC5E  2               					; flag and exit	[E6A8]
00EC5E  2               ; do the [SHIFT]+[C=] key check
00EC5E  2               CheckShiftCbm:				;				[EC5E]
00EC5E  2  C9 08        	cmp	#$08			; compare with disable [SHIFT][C=]
00EC60  2  D0 07        	bne	A_EC69			; if not disable [SHIFT][C=], skip set
00EC62  2               
00EC62  2  A9 80        	lda	#$80			; set to lock shift mode switch
00EC64  2  0D 91 02     	ora	MODE			; OR it with the shift mode switch
00EC67  2  30 09        	bmi	A_EC72			; go save the value, branch always
00EC69  2               A_EC69:					;				[EC69]
00EC69  2  C9 09        	cmp	#$09			; compare with enable [SHIFT][C=]
00EC6B  2  D0 EE        	bne	A_EC5B			; exit if not enable [SHIFT][C=]
00EC6D  2               
00EC6D  2  A9 7F        	lda	#$7F			; set to unlock shift mode switch
00EC6F  2  2D 91 02     	and	MODE			; AND it with the shift mode switch
00EC72  2               A_EC72:					;				[EC72]
00EC72  2  8D 91 02     	sta	MODE			; save the shift mode switch
00EC75  2               					; $00 = enabled, $80 = locked
00EC75  2  4C A8 E6     	jmp	RestorRegsQuot		; restore the registers, set the quote
00EC78  2               					; flag and exit	[E6A8]
00EC78  2               
00EC78  2               ;******************************************************************************
00EC78  2               ;
00EC78  2               ; control keyboard table
00EC78  2               ;
00EC78  2               TblControlKeys:				;				[EC78]
00EC78  2  FF FF FF FF  .byte	$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
00EC7C  2  FF FF FF FF  
00EC80  2  1C 17 01 9F  .byte	$1C,$17,$01,$9F,$1A,$13,$05,$FF
00EC84  2  1A 13 05 FF  
00EC88  2  9C 12 04 1E  .byte	$9C,$12,$04,$1E,$03,$06,$14,$18
00EC8C  2  03 06 14 18  
00EC90  2  1F 19 07 9E  .byte	$1F,$19,$07,$9E,$02,$08,$15,$16
00EC94  2  02 08 15 16  
00EC98  2  12 09 0A 92  .byte	$12,$09,$0A,$92,$0D,$0B,$0F,$0E
00EC9C  2  0D 0B 0F 0E  
00ECA0  2  FF 10 0C FF  .byte	$FF,$10,$0C,$FF,$FF,$1B,$00,$FF
00ECA4  2  FF 1B 00 FF  
00ECA8  2  1C FF 1D FF  .byte	$1C,$FF,$1D,$FF,$FF,$1F,$1E,$FF
00ECAC  2  FF 1F 1E FF  
00ECB0  2  90 06 FF 05  .byte	$90,$06,$FF,$05,$FF,$FF,$11,$FF
00ECB4  2  FF FF 11 FF  
00ECB8  2  FF           .byte	$FF
00ECB9  2               
00ECB9  2               
00ECB9  2               ;******************************************************************************
00ECB9  2               ;
00ECB9  2               ; VIC-II chip initialisation values
00ECB9  2               ;
00ECB9  2               TblValuesVIC:				;				[ECB9]
00ECB9  2  00 00        .byte	$00,$00				; sprite 0 x,y
00ECBB  2  00 00        .byte	$00,$00				; sprite 1 x,y
00ECBD  2  00 00        .byte	$00,$00				; sprite 2 x,y
00ECBF  2  00 00        .byte	$00,$00				; sprite 3 x,y
00ECC1  2  00 00        .byte	$00,$00				; sprite 4 x,y
00ECC3  2  00 00        .byte	$00,$00				; sprite 5 x,y
00ECC5  2  00 00        .byte	$00,$00				; sprite 6 x,y
00ECC7  2  00 00        .byte	$00,$00				; sprite 7 x,y
00ECC9  2               ;+$10
00ECC9  2  00           .byte	$00				; sprites 0 to 7 x bit 8
00ECCA  2               .if KERNAL = 1
00ECCA  2               .byte	$1B
00ECCA  2               					; vertical fine scroll and control
00ECCA  2               					; bit	function
00ECCA  2               					; ---	-------
00ECCA  2               					;  7	raster compare bit 8
00ECCA  2               					;  6	1 = enable extended color text
00ECCA  2               					;	 mode
00ECCA  2               					;  5	1 = enable bitmap graphics mode
00ECCA  2               					;  4	1 = enable screen, 0 = blank
00ECCA  2               					;	 screen
00ECCA  2               					;  3	1 = 25 row display, 0 = 24 row
00ECCA  2               					;	 display
00ECCA  2               					; 2-0	vertical scroll count
00ECCA  2               .byte	$00				; raster compare
00ECCA  2               .endif
00ECCA  2               
00ECCA  2               .if KERNAL = 2 || KERNAL = 3
00ECCA  2  9B           .byte	$9B				; enable screen, enable 25 rows
00ECCB  2               					; vertical fine scroll and control
00ECCB  2               					; bit	function
00ECCB  2               					; ---	-------
00ECCB  2               					;  7	raster compare bit 8
00ECCB  2               					;  6	1 = enable extended color text
00ECCB  2               					;	 mode
00ECCB  2               					;  5	1 = enable bitmap graphics mode
00ECCB  2               					;  4	1 = enable screen, 0 = blank
00ECCB  2               					;	 screen
00ECCB  2               					;  3	1 = 25 row display, 0 = 24 row
00ECCB  2               					;	 display
00ECCB  2               					; 2-0	vertical scroll count
00ECCB  2  37           .byte	$37				; raster compare
00ECCC  2               .endif
00ECCC  2               
00ECCC  2  00           .byte	$00				; light pen x
00ECCD  2  00           .byte	$00				; light pen y
00ECCE  2  00           .byte	$00				; sprite 0 to 7 enable
00ECCF  2  08           .byte	$08				; enable 40 column display
00ECD0  2               					; horizontal fine scroll and control
00ECD0  2               					; bit	function
00ECD0  2               					; ---	-------
00ECD0  2               					; 7-6	unused
00ECD0  2               					;  5	1 = vic reset, 0 = vic on
00ECD0  2               					;  4	1 = enable multicolor mode
00ECD0  2               					;  3	1 = 40 column display, 0 = 38
00ECD0  2               					;	 column display
00ECD0  2               					; 2-0	horizontal scroll count
00ECD0  2  00           .byte	$00				; sprite 0 to 7 y expand
00ECD1  2  14           .byte	$14				; memory control
00ECD2  2               					; bit	function
00ECD2  2               					; ---	-------
00ECD2  2               					; 7-4	video matrix base address
00ECD2  2               					; 3-1	character data base address
00ECD2  2               					;  0	unused
00ECD2  2               .if KERNAL = 1
00ECD2  2               .byte	$00
00ECD2  2               .endif
00ECD2  2               
00ECD2  2               .if KERNAL = 2 || KERNAL = 3
00ECD2  2  0F           .byte	$0F				; clear all interrupts
00ECD3  2               .endif
00ECD3  2               					; interrupt flags
00ECD3  2               					;  7	1 = interrupt
00ECD3  2               					; 6-4	unused
00ECD3  2               					;  3	1 = light pen interrupt
00ECD3  2               					;  2	1 = sprite to sprite collision
00ECD3  2               					;	 interrupt
00ECD3  2               					;  1	1 = sprite to foreground
00ECD3  2               					;	 collision interrupt
00ECD3  2               					;  0	1 = raster compare interrupt
00ECD3  2  00           .byte	$00				; all vic IRQs disabeld
00ECD4  2               					; IRQ enable
00ECD4  2               					; bit	function
00ECD4  2               					; ---	-------
00ECD4  2               					; 7-4	unused
00ECD4  2               					;  3	1 = enable light pen
00ECD4  2               					;  2	1 = enable sprite to sprite
00ECD4  2               					;	 collision
00ECD4  2               					;  1	1 = enable sprite to foreground
00ECD4  2               					;	 collision
00ECD4  2               					;  0	1 = enable raster compare
00ECD4  2  00           .byte	$00				; sprite 0 to 7 foreground priority
00ECD5  2  00           .byte	$00				; sprite 0 to 7 multicolour
00ECD6  2  00           .byte	$00				; sprite 0 to 7 x expand
00ECD7  2  00           .byte	$00				; sprite 0 to 7 sprite collision
00ECD8  2  00           .byte	$00				; sprite 0 to 7 foreground collision
00ECD9  2               ;+$20
00ECD9  2  0E           .byte	$0E				; border colour
00ECDA  2  06           .byte	$06				; background colour 0
00ECDB  2  01           .byte	$01				; background colour 1
00ECDC  2  02           .byte	$02				; background colour 2
00ECDD  2  03           .byte	$03				; background colour 3
00ECDE  2  04           .byte	$04				; sprite multicolour 0
00ECDF  2  00           .byte	$00				; sprite multicolour 1
00ECE0  2  01           .byte	$01				; sprite 0 colour
00ECE1  2  02           .byte	$02				; sprite 1 colour
00ECE2  2  03           .byte	$03				; sprite 2 colour
00ECE3  2  04           .byte	$04				; sprite 3 colour
00ECE4  2  05           .byte	$05				; sprite 4 colour
00ECE5  2  06           .byte	$06				; sprite 5 colour
00ECE6  2  07           .byte	$07				; sprite 6 colour
00ECE7  2               ;	.bytete	$4C			; sprite 7 colour, actually the first
00ECE7  2               					; character of "LOAD"
00ECE7  2               
00ECE7  2               
00ECE7  2               ;******************************************************************************
00ECE7  2               ;
00ECE7  2               ; keyboard buffer for auto load/run
00ECE7  2               ;
00ECE7  2               TblAutoLoadRun:				;				[ECE7]
00ECE7  2  4C 4F 41 44  .byte	"load",$0D,"run",$0D
00ECEB  2  0D 52 55 4E  
00ECEF  2  0D           
00ECF0  2               
00ECF0  2               
00ECF0  2               ;******************************************************************************
00ECF0  2               ;
00ECF0  2               ; LBs of screen line addresses
00ECF0  2               ;
00ECF0  2               TblScrLinesLB:				;				[ECF0]
00ECF0  2  00 28 50 78  .byte	$00,$28,$50,$78,$A0
00ECF4  2  A0           
00ECF5  2  C8 F0 18 40  .byte	$C8,$F0,$18,$40,$68
00ECF9  2  68           
00ECFA  2  90 B8 E0 08  .byte	$90,$B8,$E0,$08,$30
00ECFE  2  30           
00ECFF  2  58 80 A8 D0  .byte	$58,$80,$A8,$D0,$F8
00ED03  2  F8           
00ED04  2  20 48 70 98  .byte	$20,$48,$70,$98,$C0
00ED08  2  C0           
00ED09  2               
00ED09  2               
00ED09  2               ;******************************************************************************
00ED09  2               ;
00ED09  2               ; command serial bus device to TALK
00ED09  2               ;
00ED09  2               CmdTALK2:				;				[ED09]
00ED09  2  09 40        	ora	#$40			; OR with the TALK command
00ED0B  2  2C           .byte	$2C				; makes next line BIT $xx20
00ED0C  2               
00ED0C  2               
00ED0C  2               ;******************************************************************************
00ED0C  2               ;
00ED0C  2               ; command devices on the serial bus to LISTEN
00ED0C  2               ;
00ED0C  2               CmdLISTEN2:				;				[ED0C]
00ED0C  2  09 20        	ora	#$20			; OR with the LISTEN command
00ED0E  2  20 A4 F0     	jsr	IsRS232Idle		; check RS232 bus idle		[F0A4]
00ED11  2               
00ED11  2               
00ED11  2               ;******************************************************************************
00ED11  2               ;
00ED11  2               ; send a control character
00ED11  2               ;
00ED11  2               SendCtrlChar:				;				[ED11]
00ED11  2  48           	pha				; save device address
00ED12  2               
00ED12  2  24 94        	bit	C3PO			; test deferred character flag
00ED14  2  10 0A        	bpl	A_ED20			; if no defered character continue
00ED16  2               
00ED16  2  38           	sec				; else flag EOI
00ED17  2  66 A3        	ror	TEMPA3			; rotate into EOI flag byte
00ED19  2               
00ED19  2  20 40 ED     	jsr	IecByteOut22		; Tx byte on serial bus		[ED40]
00ED1C  2               
00ED1C  2  46 94        	lsr	C3PO			; clear deferred character flag
00ED1E  2  46 A3        	lsr	TEMPA3			; clear EOI flag
00ED20  2               A_ED20:					;				[ED20]
00ED20  2  68           	pla				; restore the device address
00ED21  2  85 95        	sta	BSOUR			; save as serial defered character
00ED23  2               
00ED23  2  78           	sei				; disable the interrupts
00ED24  2               
00ED24  2  20 97 EE     	jsr	IecDataH		; set the serial data out high	[EE97]
00ED27  2  C9 3F        	cmp	#$3F			; compare read byte with $3F
00ED29  2  D0 03        	bne	A_ED2E			; branch if not $3F, this branch will
00ED2B  2               					; always be taken as after CIA 2's PCR
00ED2B  2               					; is read it is ANDed with $DF, so the
00ED2B  2               					; result can never be $3F ??
00ED2B  2               
00ED2B  2  20 85 EE     	jsr	IecClockH		; set the serial clock out high	[EE85]
00ED2E  2               A_ED2E:					;				[ED2E]
00ED2E  2  AD 00 DD     	lda	CIA2DRA			; read CIA 2 DRA, serial port and video
00ED31  2               					; address
00ED31  2  09 08        	ora	#$08			; mask 1xxx, set serial ATN low
00ED33  2  8D 00 DD     	sta	CIA2DRA			; save CIA 2 DRA, serial port and video
00ED36  2               					; address
00ED36  2               
00ED36  2               ; if the code drops through to here the serial clock is low and the serial data
00ED36  2               ; has been released so the following code will have no effect apart from
00ED36  2               ; delaying the first byte by 1ms
00ED36  2               
00ED36  2               ; set the serial clk/data, wait and Tx byte on the serial bus
00ED36  2               PrepareIEC:				;				[ED36]
00ED36  2  78           	sei				; disable the interrupts
00ED37  2               
00ED37  2  20 8E EE     	jsr	IecClockL		; set the serial clock out low	[EE8E]
00ED3A  2  20 97 EE     	jsr	IecDataH		; set the serial data out high	[EE97]
00ED3D  2  20 B3 EE     	jsr	Wait1ms			; 1ms delay			[EEB3]
00ED40  2               
00ED40  2               
00ED40  2               ;******************************************************************************
00ED40  2               ;
00ED40  2               ; Tx byte on serial bus
00ED40  2               ;
00ED40  2               IecByteOut22:				;				[ED40]
00ED40  2  78           	sei				; disable the interrupts
00ED41  2               
00ED41  2  20 97 EE     	jsr	IecDataH		; set the serial data out high	[EE97]
00ED44  2               
00ED44  2  20 A9 EE     	jsr	IecData2Carry		; get serial data status in Cb	[EEA9]
00ED47  2  B0 64        	bcs	A_EDAD			; if the serial data is high go do
00ED49  2               					;'device not present'
00ED49  2  20 85 EE     	jsr	IecClockH		; set the serial clock out high	[EE85]
00ED4C  2               
00ED4C  2  24 A3        	bit	TEMPA3			; test the EOI flag
00ED4E  2  10 0A        	bpl	A_ED5A			; if not EOI go ??
00ED50  2               
00ED50  2               ; I think this is the EOI sequence so the serial clock has been released and
00ED50  2               ; the serial data is being held low by the peripheral. first up wait for the
00ED50  2               ; serial data to rise
00ED50  2               A_ED50:					;				[ED50]
00ED50  2  20 A9 EE     	jsr	IecData2Carry		; get serial data status in Cb	[EEA9]
00ED53  2  90 FB        	bcc	A_ED50			; loop if the data is low
00ED55  2               
00ED55  2               ; now the data is high, EOI is signalled by waiting for at least 200us without
00ED55  2               ; pulling the serial clock line low again. the listener should respond by
00ED55  2               ; pulling the serial data line low
00ED55  2               A_ED55:					;				[ED55]
00ED55  2  20 A9 EE     	jsr	IecData2Carry		; get serial data status in Cb	[EEA9]
00ED58  2  B0 FB        	bcs	A_ED55			; loop if the data is high
00ED5A  2               
00ED5A  2               ; the serial data has gone low ending the EOI sequence, now just wait for the
00ED5A  2               ; serial data line to go high again or, if this isn't an EOI sequence, just
00ED5A  2               ; wait for the serial data to go high the first time
00ED5A  2               A_ED5A:					;				[ED5A]
00ED5A  2  20 A9 EE     	jsr	IecData2Carry		; get serial data status in Cb	[EEA9]
00ED5D  2  90 FB        	bcc	A_ED5A			; loop if the data is low
00ED5F  2               
00ED5F  2               ; serial data is high now pull the clock low, preferably within 60us
00ED5F  2  20 8E EE     	jsr	IecClockL		; set the serial clock out low	[EE8E]
00ED62  2               
00ED62  2               ; now the C64 has to send the eight bits, LSB first. first it sets the serial
00ED62  2               ; data line to reflect the bit in the byte, then it sets the serial clock to
00ED62  2               ; high. The serial clock is left high for 26 cycles, 23us on a PAL Vic, before
00ED62  2               ; it is again pulled low and the serial data is allowed high again
00ED62  2  A9 08        	lda	#$08			; eight bits to do
00ED64  2  85 A5        	sta	CNTDN			; set serial bus bit count
00ED66  2               A_ED66:					;				[ED66]
00ED66  2  AD 00 DD     	lda	CIA2DRA			; read CIA 2 DRA, serial port and video
00ED69  2               					; address
00ED69  2  CD 00 DD     	cmp	CIA2DRA			; compare it with itself
00ED6C  2  D0 F8        	bne	A_ED66			; if changed go try again
00ED6E  2               
00ED6E  2  0A           	asl				; shift the serial data into Cb
00ED6F  2  90 3F        	bcc	TimeOut			; if serial data is low, do serial bus
00ED71  2               					; timeout
00ED71  2  66 95        	ror	BSOUR			; rotate the transmit byte
00ED73  2  B0 05        	bcs	A_ED7A			; if the bit = 1 go set the serial data
00ED75  2               					; out high
00ED75  2  20 A0 EE     	jsr	IecDataL		; else set serial data out low	[EEA0]
00ED78  2  D0 03        	bne	A_ED7D			; continue, branch always
00ED7A  2               A_ED7A:					;				[ED7A]
00ED7A  2  20 97 EE     	jsr	IecDataH		; set the serial data out high	[EE97]
00ED7D  2               A_ED7D:					;				[ED7D]
00ED7D  2  20 85 EE     	jsr	IecClockH		; set the serial clock out high	[EE85]
00ED80  2               
00ED80  2  EA           	nop				; waste ..
00ED81  2  EA           	nop				; .. a ..
00ED82  2  EA           	nop				; .. cycle ..
00ED83  2  EA           	nop				; .. or two
00ED84  2               
00ED84  2  AD 00 DD     	lda	CIA2DRA			; read CIA 2 DRA, serial port and video
00ED87  2               					; address
00ED87  2  29 DF        	and	#$DF			; mask xx0x, set serial data out high
00ED89  2  09 10        	ora	#$10			; mask xxx1, set serial clock out low
00ED8B  2  8D 00 DD     	sta	CIA2DRA			; save CIA 2 DRA, serial port and video
00ED8E  2               					; address
00ED8E  2  C6 A5        	dec	CNTDN			; decrement the serial bus bit count
00ED90  2  D0 D4        	bne	A_ED66			; loop if not all done
00ED92  2               
00ED92  2               ; now all eight bits have been sent it's up to the peripheral to signal the
00ED92  2               ; byte was received by pulling the serial data low. this should be done within
00ED92  2               ; one milisecond
00ED92  2  A9 04        	lda	#$04			; wait for up to about 1ms
00ED94  2  8D 07 DC     	sta	CIA1TI2H		; save CIA 1 timer B HB
00ED97  2               
00ED97  2  A9 19        	lda	#$19			; load timer B, timer B single shot,
00ED99  2               					; start timer B
00ED99  2  8D 0F DC     	sta	CIA1CTR2		; save CIA 1 CRB
00ED9C  2               
00ED9C  2  AD 0D DC     	lda	CIA1IRQ			; read CIA 1 ICR
00ED9F  2               A_ED9F:					;				[ED9F]
00ED9F  2  AD 0D DC     	lda	CIA1IRQ			; read CIA 1 ICR
00EDA2  2  29 02        	and	#$02			; mask 0000 00x0, timer A interrupt
00EDA4  2  D0 0A        	bne	TimeOut			; if timer A interrupt, do serial bus
00EDA6  2               					; timeout
00EDA6  2  20 A9 EE     	jsr	IecData2Carry		; get serial data status in Cb	[EEA9]
00EDA9  2  B0 F4        	bcs	A_ED9F			; if the serial data is high go wait
00EDAB  2               					; some more
00EDAB  2  58           	cli				; enable the interrupts
00EDAC  2  60           	rts
00EDAD  2               
00EDAD  2               ; device not present
00EDAD  2               A_EDAD:					;				[EDAD]
00EDAD  2  A9 80        	lda	#$80			; error $80, device not present
00EDAF  2  2C           .byte	$2C				; makes next line BIT $03A9
00EDB0  2               
00EDB0  2               ; timeout on serial bus
00EDB0  2               TimeOut:				;				[EDB0]
00EDB0  2  A9 03        	lda	#$03			; error $03, read timeout, write timeout
00EDB2  2               SetIecStatus:				;				[EDB2]
00EDB2  2  20 1C FE     	jsr	AorIecStatus		; OR into serial status byte	[FE1C]
00EDB5  2               
00EDB5  2  58           	cli				; enable the interrupts
00EDB6  2               
00EDB6  2  18           	clc				; clear for branch
00EDB7  2  90 4A        	bcc	A_EE03			; branch always
00EDB9  2               
00EDB9  2               
00EDB9  2               ;******************************************************************************
00EDB9  2               ;
00EDB9  2               ; send secondary address after LISTEN
00EDB9  2               ;
00EDB9  2               ; this routine is used to send a secondary address to an I/O device after a
00EDB9  2               ; call to the LISTEN routine is made and the device commanded to LISTEN. The
00EDB9  2               ; routine cannot be used to send a secondary address after a call to the TALK
00EDB9  2               ; routine.
00EDB9  2               ;
00EDB9  2               ; A secondary address is usually used to give set-up information to a device
00EDB9  2               ; before I/O operations begin.
00EDB9  2               ;
00EDB9  2               ; When a secondary address is to be sent to a device on the serial bus the
00EDB9  2               ; address must first be ORed with $60.
00EDB9  2               ;
00EDB9  2               SAafterLISTEN2:				;				[EDB9]
00EDB9  2  85 95        	sta	BSOUR			; save the defered Tx byte
00EDBB  2               
00EDBB  2  20 36 ED     	jsr	PrepareIEC		; set the serial clk/data, wait and Tx
00EDBE  2               					; the byte			[ED36]
00EDBE  2               
00EDBE  2               
00EDBE  2               ;******************************************************************************
00EDBE  2               ;
00EDBE  2               ; set serial ATN high
00EDBE  2               ;
00EDBE  2               IecAtnH:				;				[EDBE]
00EDBE  2  AD 00 DD     	lda	CIA2DRA			; read CIA 2 DRA, serial port and video
00EDC1  2               					; address
00EDC1  2  29 F7        	and	#$F7			; mask 0xxx, set serial ATN high
00EDC3  2  8D 00 DD     	sta	CIA2DRA			; save CIA 2 DRA, serial port and video
00EDC6  2               					; address
00EDC6  2               
00EDC6  2  60           	rts
00EDC7  2               
00EDC7  2               
00EDC7  2               ;******************************************************************************
00EDC7  2               ;
00EDC7  2               ; send secondary address after TALK
00EDC7  2               ;
00EDC7  2               ; this routine transmits a secondary address on the serial bus for a TALK
00EDC7  2               ; device. This routine must be called with a number between 4 and 31 in the
00EDC7  2               ; accumulator. The routine will send this number as a secondary address command
00EDC7  2               ; over the serial bus. This routine can only be called after a call to the TALK
00EDC7  2               ; routine. It will not work after a LISTEN.
00EDC7  2               ;
00EDC7  2               SAafterTALK2:				;				[EDC7]
00EDC7  2  85 95        	sta	BSOUR			; save the defered Tx byte
00EDC9  2               
00EDC9  2  20 36 ED     	jsr	PrepareIEC		; set the serial clk/data, wait and Tx
00EDCC  2               					; the byte			[ED36]
00EDCC  2               
00EDCC  2               
00EDCC  2               ;******************************************************************************
00EDCC  2               ;
00EDCC  2               ; wait for the serial bus end after send
00EDCC  2               ;
00EDCC  2               Wait4IEC:				; return address from patch 6:	[EDCC]
00EDCC  2  78           	sei				; disable the interrupts
00EDCD  2               
00EDCD  2  20 A0 EE     	jsr	IecDataL		; set the serial data out low	[EEA0]
00EDD0  2  20 BE ED     	jsr	IecAtnH			; set serial ATN high		[EDBE]
00EDD3  2  20 85 EE     	jsr	IecClockH		; set the serial clock out high	[EE85]
00EDD6  2               A_EDD6:					;				[EDD6]
00EDD6  2  20 A9 EE     	jsr	IecData2Carry		; get serial data status in Cb	[EEA9]
00EDD9  2  30 FB        	bmi	A_EDD6			; loop if the clock is high
00EDDB  2               
00EDDB  2  58           	cli				; enable the interrupts
00EDDC  2  60           	rts
00EDDD  2               
00EDDD  2               
00EDDD  2               ;******************************************************************************
00EDDD  2               ;
00EDDD  2               ; output a byte to the serial bus
00EDDD  2               ;
00EDDD  2               ; this routine is used to send information to devices on the serial bus. A call
00EDDD  2               ; to this routine will put a data byte onto the serial bus using full
00EDDD  2               ; handshaking. Before this routine is called the LISTEN routine, F_FFB1, must
00EDDD  2               ; be used to command a device on the serial bus to get ready to receive data.
00EDDD  2               ;
00EDDD  2               ; the accumulator is loaded with a byte to output as data on the serial bus. A
00EDDD  2               ; device must be listening or the status word will return a timeout. This
00EDDD  2               ; routine always buffers one character. So when a call to the UNLISTEN routine,
00EDDD  2               ; F_FFAE, is made to end the data transmission, the buffered character is
00EDDD  2               ; sent with EOI set. Then the UNLISTEN command is sent to the device.
00EDDD  2               ;
00EDDD  2               IecByteOut2:				;				[EDDD]
00EDDD  2  24 94        	bit	C3PO			; test the deferred character flag
00EDDF  2  30 05        	bmi	A_EDE6			; if there is a defered character go
00EDE1  2               					; send it
00EDE1  2  38           	sec				; set carry
00EDE2  2  66 94        	ror	C3PO			; shift into the deferred character flag
00EDE4  2  D0 05        	bne	A_EDEB			; save the byte and exit, branch always
00EDE6  2               
00EDE6  2               A_EDE6:					;				[EDE6]
00EDE6  2  48           	pha				; save the byte
00EDE7  2               
00EDE7  2  20 40 ED     	jsr	IecByteOut22		; Tx byte on serial bus		[ED40]
00EDEA  2               
00EDEA  2  68           	pla				; restore the byte
00EDEB  2               A_EDEB:					;				[EDEB]
00EDEB  2  85 95        	sta	BSOUR			; save the defered Tx byte
00EDED  2               
00EDED  2  18           	clc				; flag ok
00EDEE  2               
00EDEE  2  60           	rts
00EDEF  2               
00EDEF  2               
00EDEF  2               ;******************************************************************************
00EDEF  2               ;
00EDEF  2               ; command serial bus to UNTALK
00EDEF  2               ;
00EDEF  2               ; this routine will transmit an UNTALK command on the serial bus. All devices
00EDEF  2               ; previously set to TALK will stop sending data when this command is received.
00EDEF  2               ;
00EDEF  2               IecUNTALK2:				;				[EDEF]
00EDEF  2  78           	sei				; disable the interrupts
00EDF0  2               
00EDF0  2  20 8E EE     	jsr	IecClockL		; set the serial clock out low	[EE8E]
00EDF3  2               
00EDF3  2  AD 00 DD     	lda	CIA2DRA			; read CIA 2 DRA, serial port and video
00EDF6  2               					; address
00EDF6  2  09 08        	ora	#$08			; mask 1xxx, set the serial ATN low
00EDF8  2  8D 00 DD     	sta	CIA2DRA			; save CIA 2 DRA, serial port and video
00EDFB  2               					; address
00EDFB  2  A9 5F        	lda	#$5F			; set the UNTALK command
00EDFD  2  2C           .byte	$2C				; makes next line BIT $3FA9
00EDFE  2               
00EDFE  2               
00EDFE  2               ;******************************************************************************
00EDFE  2               ;
00EDFE  2               ; command serial bus to UNLISTEN
00EDFE  2               ;
00EDFE  2               ; this routine commands all devices on the serial bus to stop receiving data
00EDFE  2               ; from the computer. Calling this routine results in an UNLISTEN command being
00EDFE  2               ; transmitted on the serial bus. Only devices previously commanded to listen
00EDFE  2               ; will be affected.
00EDFE  2               ;
00EDFE  2               ; This routine is normally used after the computer is finished sending data to
00EDFE  2               ; external devices. Sending the UNLISTEN will command the listening devices to
00EDFE  2               ; get off the serial bus so it can be used for other purposes.
00EDFE  2               ;
00EDFE  2               IecUNLISTEN2:				;				[EDFE]
00EDFE  2  A9 3F        	lda	#$3F			; set the UNLISTEN command
00EE00  2  20 11 ED     	jsr	SendCtrlChar		; send a control character	[ED11]
00EE03  2               
00EE03  2               ; ATN high, delay, clock high then data high
00EE03  2               A_EE03:					;				[EE03]
00EE03  2  20 BE ED     	jsr	IecAtnH			; set serial ATN high		[EDBE]
00EE06  2               
00EE06  2               ; 1ms delay, clock high then data high
00EE06  2               ResetIEC:				;				[EE06]
00EE06  2  8A           	txa				; save the device number
00EE07  2  A2 0A        	ldx	#$0A			; short delay
00EE09  2               A_EE09:					;				[EE09]
00EE09  2  CA           	dex				; decrement the count
00EE0A  2  D0 FD        	bne	A_EE09			; loop if not all done
00EE0C  2               
00EE0C  2  AA           	tax				; restore the device number
00EE0D  2               
00EE0D  2  20 85 EE     	jsr	IecClockH		; set the serial clock out high	[EE85]
00EE10  2  4C 97 EE     	jmp	IecDataH		; set serial data out high and return
00EE13  2               					;				[EE97]
00EE13  2               
00EE13  2               ;******************************************************************************
00EE13  2               ;
00EE13  2               ; input a byte from the serial bus
00EE13  2               ;
00EE13  2               ; this routine reads a byte of data from the serial bus using full handshaking.
00EE13  2               ; the data is returned in the accumulator. before using this routine the TALK
00EE13  2               ; routine, CmdTALK/$FFB4, must have been called first to command the device on
00EE13  2               ; the serial bus to send data on the bus. if the input device needs a secondary
00EE13  2               ; command it must be sent by using the TKSA routine, $FF96, before calling
00EE13  2               ; this routine.
00EE13  2               ;
00EE13  2               ; errors are returned in the status word which can be read by calling the
00EE13  2               ; READST routine, ReadIoStatus.
00EE13  2               ;
00EE13  2               IecByteIn2:				;				[EE13]
00EE13  2  78           	sei				; disable the interrupts
00EE14  2               
00EE14  2  A9 00        	lda	#$00			; set 0 bits to do, will flag EOI on
00EE16  2               					; timeout
00EE16  2  85 A5        	sta	CNTDN			; save the serial bus bit count
00EE18  2               
00EE18  2  20 85 EE     	jsr	IecClockH		; set the serial clock out high	[EE85]
00EE1B  2               A_EE1B:					;				[EE1B]
00EE1B  2  20 A9 EE     	jsr	IecData2Carry		; get serial data status in Cb	[EEA9]
00EE1E  2  10 FB        	bpl	A_EE1B			; loop if the serial clock is low
00EE20  2               
00EE20  2               A_EE20:					;				[EE20]
00EE20  2  A9 01        	lda	#$01			; set the timeout count HB
00EE22  2  8D 07 DC     	sta	CIA1TI2H		; save CIA 1 timer B HB
00EE25  2               
00EE25  2  A9 19        	lda	#$19			; load timer B, timer B single shot,
00EE27  2               					; start timer B
00EE27  2  8D 0F DC     	sta	CIA1CTR2		; save CIA 1 CRB
00EE2A  2               
00EE2A  2  20 97 EE     	jsr	IecDataH		; set the serial data out high	[EE97]
00EE2D  2               
00EE2D  2  AD 0D DC     	lda	CIA1IRQ			; read CIA 1 ICR
00EE30  2               A_EE30:					;				[EE30]
00EE30  2  AD 0D DC     	lda	CIA1IRQ			; read CIA 1 ICR
00EE33  2  29 02        	and	#$02			; mask 0000 00x0, timer A interrupt
00EE35  2  D0 07        	bne	A_EE3E			; if timer A interrupt go ??
00EE37  2               
00EE37  2  20 A9 EE     	jsr	IecData2Carry		; get serial data status in Cb	[EEA9]
00EE3A  2  30 F4        	bmi	A_EE30			; loop if the serial clock is low
00EE3C  2               
00EE3C  2  10 18        	bpl	A_EE56			; else go set 8 bits to do, branch
00EE3E  2               					; always
00EE3E  2               ; timer A timed out
00EE3E  2               A_EE3E:					;				[EE3E]
00EE3E  2  A5 A5        	lda	CNTDN			; get the serial bus bit count
00EE40  2  F0 05        	beq	A_EE47			; if not already EOI then go flag EOI
00EE42  2               
00EE42  2  A9 02        	lda	#$02			; else error $02, read timeour
00EE44  2  4C B2 ED     	jmp	SetIecStatus		; set the serial status and exit [EDB2]
00EE47  2               
00EE47  2               A_EE47:					;				[EE47]
00EE47  2  20 A0 EE     	jsr	IecDataL		; set the serial data out low	[EEA0]
00EE4A  2  20 85 EE     	jsr	IecClockH		; set the serial clock out high	[EE85]
00EE4D  2               
00EE4D  2  A9 40        	lda	#$40			; set EOI
00EE4F  2  20 1C FE     	jsr	AorIecStatus		; OR into the serial status byte [FE1C]
00EE52  2               
00EE52  2  E6 A5        	inc	CNTDN			; increment the serial bus bit count,
00EE54  2               					; do error on the next timeout
00EE54  2  D0 CA        	bne	A_EE20			; go try again, branch always
00EE56  2               
00EE56  2               A_EE56:					;				[EE56]
00EE56  2  A9 08        	lda	#$08			; set 8 bits to do
00EE58  2  85 A5        	sta	CNTDN			; save the serial bus bit count
00EE5A  2               A_EE5A:					;				[EE5A]
00EE5A  2  AD 00 DD     	lda	CIA2DRA			; read CIA 2 DRA, serial port and video
00EE5D  2               					; address
00EE5D  2  CD 00 DD     	cmp	CIA2DRA			; compare it with itself
00EE60  2  D0 F8        	bne	A_EE5A			; if changing go try again
00EE62  2               
00EE62  2  0A           	asl				; shift the serial data into the carry
00EE63  2  10 F5        	bpl	A_EE5A			; loop while the serial clock is low
00EE65  2               
00EE65  2  66 A4        	ror	TEMPA4			; shift data bit into receive byte
00EE67  2               A_EE67:					;				[EE67]
00EE67  2  AD 00 DD     	lda	CIA2DRA			; read CIA 2 DRA, serial port and video
00EE6A  2               					; address
00EE6A  2  CD 00 DD     	cmp	CIA2DRA			; compare it with itself
00EE6D  2  D0 F8        	bne	A_EE67			; if changing go try again
00EE6F  2               
00EE6F  2  0A           	asl				; shift the serial data into the carry
00EE70  2  30 F5        	bmi	A_EE67			; loop while the serial clock is high
00EE72  2               
00EE72  2  C6 A5        	dec	CNTDN			; decrement the serial bus bit count
00EE74  2  D0 E4        	bne	A_EE5A			; loop if not all done
00EE76  2               
00EE76  2  20 A0 EE     	jsr	IecDataL		; set the serial data out low	[EEA0]
00EE79  2               
00EE79  2  24 90        	bit	STATUS			; test the serial status byte
00EE7B  2  50 03        	bvc	A_EE80			; if EOI not set, skip bus end sequence
00EE7D  2               
00EE7D  2  20 06 EE     	jsr	ResetIEC		; 1ms delay, clock high then data high
00EE80  2               					;				[EE06]
00EE80  2               A_EE80:					;				[EE80]
00EE80  2  A5 A4        	lda	TEMPA4			; get the receive byte
00EE82  2               
00EE82  2  58           	cli				; enable the interrupts
00EE83  2  18           	clc				; flag ok
00EE84  2               
00EE84  2  60           	rts
00EE85  2               
00EE85  2               
00EE85  2               ;******************************************************************************
00EE85  2               ;
00EE85  2               ; set the serial clock out high
00EE85  2               ;
00EE85  2               IecClockH:				;				[EE85]
00EE85  2  AD 00 DD     	lda	CIA2DRA			; read CIA 2 DRA, serial port and video
00EE88  2               					; address
00EE88  2  29 EF        	and	#$EF			; mask xxx0, set serial clock out high
00EE8A  2  8D 00 DD     	sta	CIA2DRA			; save CIA 2 DRA, serial port and video
00EE8D  2               					; address
00EE8D  2               
00EE8D  2  60           	rts
00EE8E  2               
00EE8E  2               
00EE8E  2               ;******************************************************************************
00EE8E  2               ;
00EE8E  2               ; set the serial clock out low
00EE8E  2               ;
00EE8E  2               IecClockL:				;				[EE8E]
00EE8E  2  AD 00 DD     	lda	CIA2DRA			; read CIA 2 DRA, serial port and video
00EE91  2               					; address
00EE91  2  09 10        	ora	#$10			; mask xxx1, set serial clock out low
00EE93  2  8D 00 DD     	sta	CIA2DRA			; save CIA 2 DRA, serial port and video
00EE96  2               					; address
00EE96  2  60           	rts
00EE97  2               
00EE97  2               
00EE97  2               ;******************************************************************************
00EE97  2               ;
00EE97  2               ; set the serial data out high
00EE97  2               ;
00EE97  2               IecDataH:				;				[EE97]
00EE97  2  AD 00 DD     	lda	CIA2DRA			; read CIA 2 DRA, serial port and video
00EE9A  2               					; address
00EE9A  2  29 DF        	and	#$DF			; mask xx0x, set serial data out high
00EE9C  2  8D 00 DD     	sta	CIA2DRA			; save CIA 2 DRA, serial port and video
00EE9F  2               					; address
00EE9F  2  60           	rts
00EEA0  2               
00EEA0  2               
00EEA0  2               ;******************************************************************************
00EEA0  2               ;
00EEA0  2               ; set the serial data out low
00EEA0  2               ;
00EEA0  2               IecDataL:				;				[EEA0]
00EEA0  2  AD 00 DD     	lda	CIA2DRA			; read CIA 2 DRA, serial port and video
00EEA3  2               					; address
00EEA3  2  09 20        	ora	#$20			; mask xx1x, set serial data out low
00EEA5  2  8D 00 DD     	sta	CIA2DRA			; save CIA 2 DRA, serial port and video
00EEA8  2               					; address
00EEA8  2  60           	rts
00EEA9  2               
00EEA9  2               
00EEA9  2               ;******************************************************************************
00EEA9  2               ;
00EEA9  2               ; get serial data status in Cb
00EEA9  2               ;
00EEA9  2               IecData2Carry:				;				[EEA9]
00EEA9  2  AD 00 DD     	lda	CIA2DRA			; read CIA 2 DRA, serial port and video
00EEAC  2               					; address
00EEAC  2  CD 00 DD     	cmp	CIA2DRA			; compare it with itself
00EEAF  2  D0 F8        	bne	IecData2Carry		; if changing got try again
00EEB1  2               
00EEB1  2  0A           	asl				; shift the serial data into Cb
00EEB2  2               
00EEB2  2  60           	rts
00EEB3  2               
00EEB3  2               
00EEB3  2               ;******************************************************************************
00EEB3  2               ;
00EEB3  2               ; 1ms delay
00EEB3  2               ;
00EEB3  2               Wait1ms:				;				[EEB3]
00EEB3  2  8A           	txa				; save X
00EEB4  2  A2 B8        	ldx	#$B8			; set the loop count
00EEB6  2               A_EEB6:					;				[EEB6]
00EEB6  2  CA           	dex				; decrement the loop count
00EEB7  2  D0 FD        	bne	A_EEB6			; loop if more to do
00EEB9  2               
00EEB9  2  AA           	tax				; restore X
00EEBA  2               
00EEBA  2  60           	rts
00EEBB  2               
00EEBB  2               
00EEBB  2               ;******************************************************************************
00EEBB  2               ;
00EEBB  2               ; RS232 Tx NMI routine
00EEBB  2               ;
00EEBB  2               RS232_TX_NMI:				;				[EEBB]
00EEBB  2  A5 B4        	lda	BITTS			; get RS232 bit count
00EEBD  2  F0 47        	beq	RS232_NextTx		; if zero go setup next RS232 Tx byte
00EEBF  2               					; and return
00EEBF  2  30 3F        	bmi	A_EF00			; if -ve go do stop bit(s)
00EEC1  2               
00EEC1  2               ; else bit count is non zero and +ve
00EEC1  2  46 B6        	lsr	RODATA			; shift RS232 output byte buffer
00EEC3  2               
00EEC3  2  A2 00        	ldx	#$00			; set $00 for bit = 0
00EEC5  2  90 01        	bcc	A_EEC8			; branch if bit was 0
00EEC7  2               
00EEC7  2  CA           	dex				; set $FF for bit = 1
00EEC8  2               A_EEC8:					;				[EEC8]
00EEC8  2  8A           	txa				; copy bit to A
00EEC9  2  45 BD        	eor	ROPRTY			; EOR with RS232 parity byte
00EECB  2  85 BD        	sta	ROPRTY			; save RS232 parity byte
00EECD  2               
00EECD  2  C6 B4        	dec	BITTS			; decrement RS232 bit count
00EECF  2  F0 06        	beq	A_EED7			; if RS232 bit count now zero go do
00EED1  2               					; parity bit
00EED1  2               ; save bit and exit
00EED1  2               A_EED1:					;				[EED1]
00EED1  2  8A           	txa				; copy bit to A
00EED2  2  29 04        	and	#$04			; mask 0000 0x00, RS232 Tx DATA bit
00EED4  2  85 B5        	sta	NXTBIT			; save the next RS232 data bit to send
00EED6  2               
00EED6  2  60           	rts
00EED7  2               
00EED7  2               ; do RS232 parity bit, enters with RS232 bit count = 0
00EED7  2               A_EED7:					;				[EED7]
00EED7  2  A9 20        	lda	#$20			; mask 00x0 0000, parity enable bit
00EED9  2  2C 94 02     	bit	M51CDR			; test the pseudo 6551 command register
00EEDC  2  F0 14        	beq	A_EEF2			; if parity disabled go ??
00EEDE  2               
00EEDE  2  30 1C        	bmi	A_EEFC			; if fixed mark or space parity go ??
00EEE0  2               
00EEE0  2  70 14        	bvs	A_EEF6			; if even parity go ??
00EEE2  2               
00EEE2  2               ; else odd parity
00EEE2  2  A5 BD        	lda	ROPRTY			; get RS232 parity byte
00EEE4  2  D0 01        	bne	A_EEE7			; if not zero leave parity bit = 0
00EEE6  2               
00EEE6  2               A_EEE6:					;				[EEE6]
00EEE6  2  CA           	dex				; make parity bit = 1
00EEE7  2               A_EEE7:					;				[EEE7]
00EEE7  2  C6 B4        	dec	BITTS			; decrement RS232 bit count, 1 stop bit
00EEE9  2               
00EEE9  2  AD 93 02     	lda	M51CTR			; get pseudo 6551 control register
00EEEC  2  10 E3        	bpl	A_EED1			; if 1 stop bit save parity bit and exit
00EEEE  2               
00EEEE  2               ; else two stop bits ..
00EEEE  2  C6 B4        	dec	BITTS			; decrement RS232 bit count, 2 stop bits
00EEF0  2  D0 DF        	bne	A_EED1			; save bit and exit, branch always
00EEF2  2               
00EEF2  2               ; parity is disabled so the parity bit becomes the first, and possibly only,
00EEF2  2               ; stop bit. to do this increment the bit count which effectively decrements the
00EEF2  2               ; stop bit count.
00EEF2  2               A_EEF2:					;				[EEF2]
00EEF2  2  E6 B4        	inc	BITTS			; increment RS232 bit count, = -1 stop
00EEF4  2               					; bit
00EEF4  2  D0 F0        	bne	A_EEE6			; set stop bit = 1 and exit
00EEF6  2               
00EEF6  2               ; do even parity
00EEF6  2               A_EEF6:					;				[EEF6]
00EEF6  2  A5 BD        	lda	ROPRTY			; get RS232 parity byte
00EEF8  2  F0 ED        	beq	A_EEE7			; if parity zero leave parity bit = 0
00EEFA  2               
00EEFA  2  D0 EA        	bne	A_EEE6			; else branch always
00EEFC  2               
00EEFC  2               ; fixed mark or space parity
00EEFC  2               A_EEFC:					;				[EEFC]
00EEFC  2  70 E9        	bvs	A_EEE7			; if fixed space parity leave parity
00EEFE  2               					; bit = 0
00EEFE  2  50 E6        	bvc	A_EEE6			; else fixed mark parity make parity
00EF00  2               					; bit = 1, branch always
00EF00  2               
00EF00  2               ; decrement stop bit count, set stop bit = 1 and exit. $FF is one stop bit, $FE
00EF00  2               ; is two stop bits
00EF00  2               A_EF00:					;				[EF00]
00EF00  2  E6 B4        	inc	BITTS			; decrement RS232 bit count
00EF02  2               
00EF02  2  A2 FF        	ldx	#$FF			; set stop bit = 1
00EF04  2  D0 CB        	bne	A_EED1			; save stop bit and exit, branch always
00EF06  2               
00EF06  2               
00EF06  2               ;******************************************************************************
00EF06  2               ;
00EF06  2               ; setup next RS232 Tx byte
00EF06  2               ;
00EF06  2               RS232_NextTx:				;				[EF06]
00EF06  2  AD 94 02     	lda	M51CDR			; read the 6551 pseudo command register
00EF09  2  4A           	lsr				; handshake bit inot Cb
00EF0A  2  90 07        	bcc	A_EF13			; if 3 line interface go ??
00EF0C  2               
00EF0C  2  2C 01 DD     	bit	CIA2DRB			; test CIA 2 DRB, RS232 port
00EF0F  2               
00EF0F  2  10 1D        	bpl	A_EF2E			; if DSR = 0 set DSR signal not present
00EF11  2               					; and exit
00EF11  2  50 1E        	bvc	A_EF31			; if CTS = 0 set CTS signal not present
00EF13  2               					; and exit
00EF13  2               ; was 3 line interface
00EF13  2               A_EF13:					;				[EF13]
00EF13  2  A9 00        	lda	#$00			; clear A
00EF15  2  85 BD        	sta	ROPRTY			; clear the RS232 parity byte
00EF17  2  85 B5        	sta	NXTBIT			; clear the RS232 next bit to send
00EF19  2               
00EF19  2  AE 98 02     	ldx	BITNUM			; get the number of bits to be
00EF1C  2               					; sent/received
00EF1C  2  86 B4        	stx	BITTS			; set the RS232 bit count
00EF1E  2               
00EF1E  2  AC 9D 02     	ldy	RODBE			; get the index to the Tx buffer start
00EF21  2  CC 9E 02     	cpy	RODBS			; compare it with index of Tx buffer end
00EF24  2  F0 13        	beq	A_EF39			; if all done go disable T?? interrupt
00EF26  2               					; and return
00EF26  2  B1 F9        	lda	(ROBUF),Y		; else get a byte from the buffer
00EF28  2  85 B6        	sta	RODATA			; save it to RS232 output byte buffer
00EF2A  2               
00EF2A  2  EE 9D 02     	inc	RODBE			; increment index of the Tx buffer start
00EF2D  2               
00EF2D  2  60           	rts
00EF2E  2               
00EF2E  2               
00EF2E  2               ;******************************************************************************
00EF2E  2               ;
00EF2E  2               ; set DSR signal not present
00EF2E  2               ;
00EF2E  2               A_EF2E:					;				[EF2E]
00EF2E  2  A9 40        	lda	#$40			; set DSR signal not present
00EF30  2  2C           .byte	$2C				; makes next line BIT $10A9
00EF31  2               
00EF31  2               
00EF31  2               ;******************************************************************************
00EF31  2               ;
00EF31  2               ; set CTS signal not present
00EF31  2               ;
00EF31  2               A_EF31:					;				[EF31]
00EF31  2  A9 10        	lda	#$10			; set CTS signal not present
00EF33  2  0D 97 02     	ora	RSSTAT			; OR it with the RS232 status register
00EF36  2  8D 97 02     	sta	RSSTAT			; save the RS232 status register
00EF39  2               
00EF39  2               
00EF39  2               ;******************************************************************************
00EF39  2               ;
00EF39  2               ; disable timer A interrupt
00EF39  2               ;
00EF39  2               A_EF39:					;				[EF39]
00EF39  2  A9 01        	lda	#$01			; disable timer A interrupt
00EF3B  2               
00EF3B  2               
00EF3B  2               ;******************************************************************************
00EF3B  2               ;
00EF3B  2               ; set CIA 2 ICR from A
00EF3B  2               ;
00EF3B  2               Set_VIA2_ICR:				;				[EF3B]
00EF3B  2  8D 0D DD     	sta	CIA2IRQ			; save CIA 2 ICR
00EF3E  2               
00EF3E  2  4D A1 02     	eor	ENABL			; EOR with RS-232 interrupt enable byte
00EF41  2  09 80        	ora	#$80			; set the interrupts enable bit
00EF43  2  8D A1 02     	sta	ENABL			; save RS-232 interrupt enable byte
00EF46  2  8D 0D DD     	sta	CIA2IRQ			; save CIA 2 ICR
00EF49  2               
00EF49  2  60           	rts
00EF4A  2               
00EF4A  2               
00EF4A  2               ;******************************************************************************
00EF4A  2               ;
00EF4A  2               ; compute bit count
00EF4A  2               ;
00EF4A  2               CalcBitCounts:				;				[EF4A]
00EF4A  2  A2 09        	ldx	#$09			; set bit count to 8 data + 1 stop bit
00EF4C  2               
00EF4C  2  A9 20        	lda	#$20			; mask for 8/7 data bits
00EF4E  2  2C 93 02     	bit	M51CTR			; test pseudo 6551 control register
00EF51  2  F0 01        	beq	A_EF54			; branch if 8 bits
00EF53  2               
00EF53  2  CA           	dex				; else decrement count for 7 data bits
00EF54  2               A_EF54:					;				[EF54]
00EF54  2  50 02        	bvc	A_EF58			; branch if 7 bits
00EF56  2               
00EF56  2  CA           	dex				; else decrement count ..
00EF57  2  CA           	dex				; .. for 5 data bits
00EF58  2               A_EF58:					;				[EF58]
00EF58  2  60           	rts
00EF59  2               
00EF59  2               
00EF59  2               ;******************************************************************************
00EF59  2               ;
00EF59  2               ; RS232 Rx NMI
00EF59  2               ;
00EF59  2               RS232_RX_NMI:				;				[EF59]
00EF59  2  A6 A9        	ldx	RINONE			; get start bit check flag
00EF5B  2  D0 33        	bne	A_EF90			; if no start bit received go ??
00EF5D  2               
00EF5D  2  C6 A8        	dec	BITCI			; decrement receiver bit count in
00EF5F  2  F0 36        	beq	A_EF97			; if the byte is complete go add it to
00EF61  2               					; the buffer
00EF61  2  30 0D        	bmi	A_EF70			;.
00EF63  2               
00EF63  2  A5 A7        	lda	INBIT			; get the RS232 received data bit
00EF65  2  45 AB        	eor	RIPRTY			; EOR with the receiver parity bit
00EF67  2  85 AB        	sta	RIPRTY			; save the receiver parity bit
00EF69  2               
00EF69  2  46 A7        	lsr	INBIT			; shift the RS232 received data bit
00EF6B  2  66 AA        	ror	RIDATA			;.
00EF6D  2               A_EF6D:					;				[EF6D]
00EF6D  2  60           	rts
00EF6E  2               
00EF6E  2               A_EF6E:					;				[EF6E]
00EF6E  2  C6 A8        	dec	BITCI			; decrement receiver bit count in
00EF70  2               A_EF70:					;				[EF70]
00EF70  2  A5 A7        	lda	INBIT			; get the RS232 received data bit
00EF72  2  F0 67        	beq	A_EFDB			;.
00EF74  2               
00EF74  2  AD 93 02     	lda	M51CTR			; get pseudo 6551 control register
00EF77  2  0A           	asl				; shift the stop bit flag to Cb
00EF78  2               
00EF78  2  A9 01        	lda	#$01			; + 1
00EF7A  2  65 A8        	adc	BITCI			; add receiver bit count in
00EF7C  2  D0 EF        	bne	A_EF6D			; exit, branch always
00EF7E  2               
00EF7E  2               
00EF7E  2               ;******************************************************************************
00EF7E  2               ;
00EF7E  2               ; setup to receive an RS232 bit
00EF7E  2               ;
00EF7E  2               SetupRS232_RX:				;				[EF7E]
00EF7E  2  A9 90        	lda	#$90			; enable FLAG interrupt
00EF80  2  8D 0D DD     	sta	CIA2IRQ			; save CIA 2 ICR
00EF83  2               
00EF83  2  0D A1 02     	ora	ENABL			; OR with RS-232 interrupt enable byte
00EF86  2  8D A1 02     	sta	ENABL			; save RS-232 interrupt enable byte
00EF89  2  85 A9        	sta	RINONE			; set start bit check flag, set no start
00EF8B  2               					; bit received
00EF8B  2  A9 02        	lda	#$02			; disable timer B interrupt
00EF8D  2  4C 3B EF     	jmp	Set_VIA2_ICR		; set CIA 2 ICR from A and return [EF3B]
00EF90  2               
00EF90  2               
00EF90  2               ;******************************************************************************
00EF90  2               ;
00EF90  2               ; no RS232 start bit received
00EF90  2               ;
00EF90  2               A_EF90:					;				[EF90]
00EF90  2  A5 A7        	lda	INBIT			; get the RS232 received data bit
00EF92  2  D0 EA        	bne	SetupRS232_RX		; if ?? go setup to receive an RS232
00EF94  2               					; bit and return
00EF94  2               
00EF94  2               .if KERNAL = 1 || KERNAL = 2
00EF94  2               	sta	RINONE
00EF94  2               
00EF94  2                     rts
00EF94  2               .endif
00EF94  2               
00EF94  2               .if KERNAL = 3
00EF94  2  4C D3 E4     	jmp	RS232_SaveSet		; flag RS232 start bit and set parity
00EF97  2               .endif
00EF97  2               
00EF97  2               
00EF97  2               ;******************************************************************************
00EF97  2               ;
00EF97  2               ; received a whole byte, add it to the buffer
00EF97  2               ;
00EF97  2               A_EF97:					;				[EF97]
00EF97  2  AC 9B 02     	ldy	RIDBE			; get index to Rx buffer end
00EF9A  2  C8           	iny				; increment index
00EF9B  2  CC 9C 02     	cpy	RIDBS			; compare with index to Rx buffer start
00EF9E  2  F0 2A        	beq	A_EFCA			; if buffer full go do Rx overrun error
00EFA0  2               
00EFA0  2  8C 9B 02     	sty	RIDBE			; save index to Rx buffer end
00EFA3  2               
00EFA3  2  88           	dey				; decrement index
00EFA4  2               
00EFA4  2  A5 AA        	lda	RIDATA			; get assembled byte
00EFA6  2               
00EFA6  2  AE 98 02     	ldx	BITNUM			; get bit count
00EFA9  2               A_EFA9:					;				[EFA9]
00EFA9  2  E0 09        	cpx	#$09			; compare with byte + stop
00EFAB  2  F0 04        	beq	A_EFB1			; branch if all nine bits received
00EFAD  2               
00EFAD  2  4A           	lsr				; else shift byte
00EFAE  2               
00EFAE  2  E8           	inx				; increment bit count
00EFAF  2  D0 F8        	bne	A_EFA9			; loop, branch always
00EFB1  2               
00EFB1  2               A_EFB1:					;				[EFB1]
00EFB1  2  91 F7        	sta	(RIBUF),Y		; save received byte to Rx buffer
00EFB3  2               
00EFB3  2  A9 20        	lda	#$20			; mask 00x0 0000, parity enable bit
00EFB5  2  2C 94 02     	bit	M51CDR			; test the pseudo 6551 command register
00EFB8  2  F0 B4        	beq	A_EF6E			; branch if parity disabled
00EFBA  2               
00EFBA  2  30 B1        	bmi	A_EF6D			; branch if mark or space parity
00EFBC  2               
00EFBC  2  A5 A7        	lda	INBIT			; get the RS232 received data bit
00EFBE  2  45 AB        	eor	RIPRTY			; EOR with the receiver parity bit
00EFC0  2  F0 03        	beq	A_EFC5			;.
00EFC2  2               
00EFC2  2  70 A9        	bvs	A_EF6D			; if ?? just exit
00EFC4  2               
00EFC4  2  2C           .byte	$2C				; makes next line BIT $xxxx
00EFC5  2               A_EFC5:					;				[EFC5]
00EFC5  2  50 A6        	bvc	A_EF6D			; if ?? just exit
00EFC7  2               
00EFC7  2  A9 01        	lda	#$01			; set Rx parity error
00EFC9  2  2C           .byte	$2C				; makes next line BIT $04A9
00EFCA  2               A_EFCA:					;				[EFCA]
00EFCA  2  A9 04        	lda	#$04			; set Rx overrun error
00EFCC  2  2C           .byte	$2C				; makes next line BIT NumericTestA9
00EFCD  2               A_EFCD:					;				[EFCD]
00EFCD  2  A9 80        	lda	#$80			; set Rx break error
00EFCF  2  2C           .byte	$2C				; makes next line BIT $02A9
00EFD0  2               A_EFD0:					;				[EFD0]
00EFD0  2  A9 02        	lda	#$02			; set Rx frame error
00EFD2  2  0D 97 02     	ora	RSSTAT			; OR it with the RS232 status byte
00EFD5  2  8D 97 02     	sta	RSSTAT			; save the RS232 status byte
00EFD8  2               
00EFD8  2  4C 7E EF     	jmp	SetupRS232_RX		; setup to receive an RS232 bit and
00EFDB  2               					; return			[EF7E]
00EFDB  2               
00EFDB  2               A_EFDB:					;				[EFDB]
00EFDB  2  A5 AA        	lda	RIDATA			;.
00EFDD  2  D0 F1        	bne	A_EFD0			; if ?? do frame error
00EFDF  2               
00EFDF  2  F0 EC        	beq	A_EFCD			; else do break error, branch always
00EFE1  2               
00EFE1  2               
00EFE1  2               ;******************************************************************************
00EFE1  2               ;
00EFE1  2               ; open RS232 channel for output
00EFE1  2               ;
00EFE1  2               OpenRsChan4Out:				;				[EFE1]
00EFE1  2  85 9A        	sta	DFLTO			; save the output device number
00EFE3  2               
00EFE3  2  AD 94 02     	lda	M51CDR			; read the pseudo 6551 command register
00EFE6  2  4A           	lsr				; shift handshake bit to carry
00EFE7  2  90 29        	bcc	A_F012			; if 3 line interface go ??
00EFE9  2               
00EFE9  2  A9 02        	lda	#$02			; mask 0000 00x0, RTS out
00EFEB  2  2C 01 DD     	bit	CIA2DRB			; test CIA 2 DRB, RS232 port
00EFEE  2  10 1D        	bpl	DeactivateDSR		; if DSR=0 set DSR not present and exit
00EFF0  2               
00EFF0  2  D0 20        	bne	A_F012			; if RTS = 1 just exit
00EFF2  2               
00EFF2  2               A_EFF2:					;				[EFF2]
00EFF2  2  AD A1 02     	lda	ENABL			; get RS-232 interrupt enable byte
00EFF5  2  29 02        	and	#$02			; mask 0000 00x0, timer B interrupt
00EFF7  2  D0 F9        	bne	A_EFF2			; loop while timer B interrupt is
00EFF9  2               					; enebled
00EFF9  2               A_EFF9:					;				[EFF9]
00EFF9  2  2C 01 DD     	bit	CIA2DRB			; test CIA 2 DRB, RS232 port
00EFFC  2  70 FB        	bvs	A_EFF9			; loop while CTS high
00EFFE  2               
00EFFE  2  AD 01 DD     	lda	CIA2DRB			; read CIA 2 DRB, RS232 port
00F001  2  09 02        	ora	#$02			; mask xx1x, set RTS high
00F003  2  8D 01 DD     	sta	CIA2DRB			; save CIA 2 DRB, RS232 port
00F006  2               A_F006:					;				[F006]
00F006  2  2C 01 DD     	bit	CIA2DRB			; test CIA 2 DRB, RS232 port
00F009  2  70 07        	bvs	A_F012			; exit if CTS high
00F00B  2               
00F00B  2  30 F9        	bmi	A_F006			; loop while DSR high
00F00D  2               
00F00D  2               ; set no DSR and exit
00F00D  2               DeactivateDSR:				;				[F00D]
00F00D  2  A9 40        	lda	#$40			; set DSR signal not present
00F00F  2  8D 97 02     	sta	RSSTAT			; save the RS232 status register
00F012  2               A_F012:					;				[F012]
00F012  2  18           	clc				; flag ok
00F013  2               
00F013  2  60           	rts
00F014  2               
00F014  2               
00F014  2               ;******************************************************************************
00F014  2               ;
00F014  2               ; send byte to the RS232 buffer
00F014  2               ;
00F014  2               A_F014:					;				[F014]
00F014  2  20 28 F0     	jsr	SetupRS232_TX		; setup for RS232 transmit	[F028]
00F017  2               
00F017  2               ; send byte to the RS232 buffer, no setup
00F017  2               Byte2RS232Buf:				;				[F017]
00F017  2  AC 9E 02     	ldy	RODBS			; get index to Tx buffer end
00F01A  2  C8           	iny				; + 1
00F01B  2  CC 9D 02     	cpy	RODBE			; compare with index to Tx buffer start
00F01E  2  F0 F4        	beq	A_F014			; loop while buffer full
00F020  2               
00F020  2  8C 9E 02     	sty	RODBS			; set index to Tx buffer end
00F023  2               
00F023  2  88           	dey				; index to available buffer byte
00F024  2  A5 9E        	lda	PTR1			; read the RS232 character buffer
00F026  2  91 F9        	sta	(ROBUF),Y		; save the byte to the buffer
00F028  2               
00F028  2               
00F028  2               ;******************************************************************************
00F028  2               ;
00F028  2               ; setup for RS232 transmit
00F028  2               ;
00F028  2               SetupRS232_TX:				;				[F028]
00F028  2  AD A1 02     	lda	ENABL			; get RS-232 interrupt enable byte
00F02B  2  4A           	lsr				; shift the enable bit to Cb
00F02C  2  B0 1E        	bcs	A_F04C			; if interrupts are enabled just exit
00F02E  2               
00F02E  2  A9 10        	lda	#$10			; start timer A
00F030  2  8D 0E DD     	sta	CIA2CTR1		; save CIA 2 CRA
00F033  2               
00F033  2  AD 99 02     	lda	BAUDOF			; get the baud rate bit time LB
00F036  2  8D 04 DD     	sta	CIA2TI1L		; save CIA 2 timer A LB
00F039  2               
00F039  2  AD 9A 02     	lda	BAUDOF+1		; get the baud rate bit time HB
00F03C  2  8D 05 DD     	sta	CIA2TI1H		; save CIA 2 timer A HB
00F03F  2               
00F03F  2  A9 81        	lda	#$81			; enable timer A interrupt
00F041  2  20 3B EF     	jsr	Set_VIA2_ICR		; set CIA 2 ICR from A		[EF3B]
00F044  2               
00F044  2  20 06 EF     	jsr	RS232_NextTx		; setup next RS232 Tx byte	[EF06]
00F047  2               
00F047  2  A9 11        	lda	#$11			; load timer A, start timer A
00F049  2  8D 0E DD     	sta	CIA2CTR1		; save CIA 2 CRA
00F04C  2               A_F04C:					;				[F04C]
00F04C  2  60           	rts
00F04D  2               
00F04D  2               
00F04D  2               ;******************************************************************************
00F04D  2               ;
00F04D  2               ; input from RS232 buffer
00F04D  2               ;
00F04D  2               InputRS232Buf:				;				[F04D]
00F04D  2  85 99        	sta	DFLTN			; save the input device number
00F04F  2               
00F04F  2  AD 94 02     	lda	M51CDR			; get pseudo 6551 command register
00F052  2  4A           	lsr				; shift the handshake bit to Cb
00F053  2  90 28        	bcc	A_F07D			; if 3 line interface go ??
00F055  2               
00F055  2  29 08        	and	#$08			; mask the duplex bit, pseudo 6551
00F057  2               					; command is >> 1
00F057  2  F0 24        	beq	A_F07D			; if full duplex go ??
00F059  2               
00F059  2  A9 02        	lda	#$02			; mask 0000 00x0, RTS out
00F05B  2  2C 01 DD     	bit	CIA2DRB			; test CIA 2 DRB, RS232 port
00F05E  2  10 AD        	bpl	DeactivateDSR		; if DSR = 0 set no DSR and exit
00F060  2               
00F060  2  F0 22        	beq	A_F084			; if RTS = 0 just exit
00F062  2               
00F062  2               A_F062:					;				[F062]
00F062  2  AD A1 02     	lda	ENABL			; get RS-232 interrupt enable byte
00F065  2  4A           	lsr				; shift the timer A interrupt enable
00F066  2               					; bit to Cb
00F066  2  B0 FA        	bcs	A_F062			; loop while the timer A interrupt is
00F068  2               					; enabled
00F068  2               
00F068  2  AD 01 DD     	lda	CIA2DRB			; read CIA 2 DRB, RS232 port
00F06B  2  29 FD        	and	#$FD			; mask xx0x, clear RTS out
00F06D  2  8D 01 DD     	sta	CIA2DRB			; save CIA 2 DRB, RS232 port
00F070  2               A_F070:					;				[F070]
00F070  2  AD 01 DD     	lda	CIA2DRB			; read CIA 2 DRB, RS232 port
00F073  2  29 04        	and	#$04			; mask x1xx, DTR in
00F075  2  F0 F9        	beq	A_F070			; loop while DTR low
00F077  2               
00F077  2               A_F077:					;				[F077]
00F077  2  A9 90        	lda	#$90			; enable the FLAG interrupt
00F079  2  18           	clc				; flag ok
00F07A  2  4C 3B EF     	jmp	Set_VIA2_ICR		; set CIA 2 ICR from A and return [EF3B]
00F07D  2               
00F07D  2               A_F07D:					;				[F07D]
00F07D  2  AD A1 02     	lda	ENABL			; get RS-232 interrupt enable byte
00F080  2  29 12        	and	#$12			; mask 000x 00x0
00F082  2  F0 F3        	beq	A_F077			; if FLAG or timer B bits set go enable
00F084  2               					; the FLAG inetrrupt
00F084  2               A_F084:					;				[F084]
00F084  2  18           	clc				; flag ok
00F085  2               
00F085  2  60           	rts
00F086  2               
00F086  2               
00F086  2               ;******************************************************************************
00F086  2               ;
00F086  2               ; get byte from RS232 buffer
00F086  2               ;
00F086  2               GetBytRS232Buf:				;				[F086]
00F086  2  AD 97 02     	lda	RSSTAT			; get the RS232 status register
00F089  2               
00F089  2  AC 9C 02     	ldy	RIDBS			; get index to Rx buffer start
00F08C  2  CC 9B 02     	cpy	RIDBE			; compare with index to Rx buffer end
00F08F  2  F0 0B        	beq	A_F09C			; return null if buffer empty
00F091  2               
00F091  2  29 F7        	and	#$F7			; clear the Rx buffer empty bit
00F093  2  8D 97 02     	sta	RSSTAT			; save the RS232 status register
00F096  2               
00F096  2  B1 F7        	lda	(RIBUF),Y		; get byte from Rx buffer
00F098  2               
00F098  2  EE 9C 02     	inc	RIDBS			; increment index to Rx buffer start
00F09B  2               
00F09B  2  60           	rts
00F09C  2               
00F09C  2               
00F09C  2               A_F09C:					;				[F09C]
00F09C  2  09 08        	ora	#$08			; set the Rx buffer empty bit
00F09E  2  8D 97 02     	sta	RSSTAT			; save the RS232 status register
00F0A1  2               
00F0A1  2  A9 00        	lda	#$00			; return null
00F0A3  2  60           	rts
00F0A4  2               
00F0A4  2               
00F0A4  2               ;******************************************************************************
00F0A4  2               ;
00F0A4  2               ; check RS232 bus idle
00F0A4  2               ;
00F0A4  2               IsRS232Idle:				;				[F0A4]
00F0A4  2  48           	pha				; save A
00F0A5  2  AD A1 02     	lda	ENABL			; get RS-232 interrupt enable byte
00F0A8  2  F0 11        	beq	A_F0BB			; if no interrupts enabled just exit
00F0AA  2               
00F0AA  2               A_F0AA:					;				[F0AA]
00F0AA  2  AD A1 02     	lda	ENABL			; get RS-232 interrupt enable byte
00F0AD  2  29 03        	and	#$03			; mask 0000 00xx, the error bits
00F0AF  2  D0 F9        	bne	A_F0AA			; if there are errors loop
00F0B1  2               
00F0B1  2  A9 10        	lda	#$10			; disable FLAG interrupt
00F0B3  2  8D 0D DD     	sta	CIA2IRQ			; save CIA 2 ICR
00F0B6  2               
00F0B6  2  A9 00        	lda	#$00			; clear A
00F0B8  2  8D A1 02     	sta	ENABL			; clear RS-232 interrupt enable byte
00F0BB  2               A_F0BB:					;				[F0BB]
00F0BB  2  68           	pla				; restore A
00F0BC  2  60           	rts
00F0BD  2               
00F0BD  2               
00F0BD  2               ;******************************************************************************
00F0BD  2               ;
00F0BD  2               ; kernel I/O messages
00F0BD  2               ;
00F0BD  2               TxtIO_ERROR:				;				[F0BD]
00F0BD  2  0D           .byte	$0D
00F0BE  2  49 2F 4F 20  .byte	"i/o error ",'#'+$80
00F0C2  2  45 52 52 4F  
00F0C6  2  52 20 A3     
00F0C9  2               
00F0C9  2               TxtSEARCHING:				;				[F0C9]
00F0C9  2  0D           .byte	$0D
00F0CA  2  53 45 41 52  .byte	"searching",$20+$80
00F0CE  2  43 48 49 4E  
00F0D2  2  47 A0        
00F0D4  2               
00F0D4  2               TxtFOR:					;				[F0D4]
00F0D4  2  46 4F 52 A0  .byte	"for",$20+$80
00F0D8  2               
00F0D8  2               TxtPRESS_PLAY:				;				[F0D8]
00F0D8  2  0D           .byte	$0D
00F0D9  2  50 52 45 53  .byte	"press play on tap",'e'+$80
00F0DD  2  53 20 50 4C  
00F0E1  2  41 59 20 4F  
00F0EB  2               
00F0EB  2               TxtPRESS_RECO:				;				[F0EB]
00F0EB  2  50 52 45 53  .byte	"press record & play on tap",'e'+$80
00F0EF  2  53 20 52 45  
00F0F3  2  43 4F 52 44  
00F106  2               
00F106  2               TxtLOADING:				;				[F106]
00F106  2  0D           .byte	$0D
00F107  2  4C 4F 41 44  .byte	"loadin",'g'+$80
00F10B  2  49 4E C7     
00F10E  2               
00F10E  2               TxtSAVING:				;				[F10E]
00F10E  2  0D           .byte	$0D
00F10F  2  53 41 56 49  .byte	"saving",$20+$80
00F113  2  4E 47 A0     
00F116  2               
00F116  2               TxtVERIFYING:				;				[F116]
00F116  2  0D           .byte	$0D
00F117  2  56 45 52 49  .byte	"verifyin",'g'+$80
00F11B  2  46 59 49 4E  
00F11F  2  C7           
00F120  2               
00F120  2               TxtFOUND:				;				[F120]
00F120  2  0D           .byte	$0D
00F121  2  46 4F 55 4E  .byte	"found",$20+$80
00F125  2  44 A0        
00F127  2               
00F127  2               TxtOK2:					;				[F127]
00F127  2  0D 4F 4B 8D  .byte	$0D, "ok", $8D
00F12B  2               
00F12B  2               
00F12B  2               ;******************************************************************************
00F12B  2               ;
00F12B  2               ; display control I/O message if in direct mode
00F12B  2               ;
00F12B  2               DisplayIoMsg:				;				[F12B]
00F12B  2  24 9D        	bit	MSGFLG			; test message mode flag
00F12D  2  10 0D        	bpl	A_F13C			; exit if control messages off
00F12F  2               
00F12F  2               ; display kernel I/O message
00F12F  2               DisplayIoMsg2:				;				[F12F]
00F12F  2  B9 BD F0     	lda	TxtIO_ERROR,Y		; get byte from message table
00F132  2  08           	php				; save status
00F133  2  29 7F        	and	#$7F			; clear b7
00F135  2  20 D2 FF     	jsr	OutByteChan		; output character to channel	[FFD2]
00F138  2               
00F138  2  C8           	iny				; increment index
00F139  2               
00F139  2  28           	plp				; restore status
00F13A  2  10 F3        	bpl	DisplayIoMsg2		; loop if not end of message
00F13C  2               
00F13C  2               A_F13C:					;				[F13C]
00F13C  2  18           	clc				;.
00F13D  2               
00F13D  2  60           	rts
00F13E  2               
00F13E  2               
00F13E  2               ;******************************************************************************
00F13E  2               ;
00F13E  2               ; get character from the input device
00F13E  2               ;
00F13E  2               ; in practice this routine operates identically to the CHRIN routine,
00F13E  2               ; ByteFromChan, for all devices except for the keyboard. If the keyboard is the
00F13E  2               ; current input device this routine will get one character from the keyboard
00F13E  2               ; buffer. It depends on the IRQ routine to read the keyboard and put characters
00F13E  2               ; into the buffer.
00F13E  2               ;
00F13E  2               ; If the keyboard buffer is empty the value returned in the accumulator will be
00F13E  2               ; zero
00F13E  2               ;
00F13E  2               GetByteInpDev:				;				[F13E]
00F13E  2  A5 99        	lda	DFLTN			; get the input device number
00F140  2  D0 08        	bne	A_F14A			; if not the keyboard go handle other
00F142  2               					; devices
00F142  2               ; the input device was the keyboard
00F142  2  A5 C6        	lda	NDX			; get the keyboard buffer index
00F144  2  F0 0F        	beq	A_F155			; if the buffer is empty go flag no
00F146  2               					; byte and return
00F146  2  78           	sei				; disable the interrupts
00F147  2               
00F147  2  4C B4 E5     	jmp	GetCharKeybBuf		; get input from the keyboard buffer
00F14A  2               					; and return			[E5B4]
00F14A  2               
00F14A  2               ; the input device was not the keyboard
00F14A  2               A_F14A:					;				[F14A]
00F14A  2  C9 02        	cmp	#$02			; compare device with the RS232 device
00F14C  2  D0 18        	bne	A_F166			; if not the RS232 device, ->
00F14E  2               
00F14E  2               ; the input device is the RS232 device
00F14E  2               GetByteInpDev2:				;				[F14E]
00F14E  2  84 97        	sty	TEMP97			; save Y
00F150  2               
00F150  2  20 86 F0     	jsr	GetBytRS232Buf		; get a byte from RS232 buffer	[F086]
00F153  2               
00F153  2  A4 97        	ldy	TEMP97			; restore Y
00F155  2               A_F155:					;				[F155]
00F155  2  18           	clc				; flag no error
00F156  2               
00F156  2  60           	rts
00F157  2               
00F157  2               
00F157  2               ;******************************************************************************
00F157  2               ;
00F157  2               ; input a character from channel
00F157  2               ;
00F157  2               ; this routine will get a byte of data from the channel already set up as the
00F157  2               ; input channel by the CHKIN routine, OpenChan4Inp.
00F157  2               ;
00F157  2               ; If CHKIN, OpenChan4Inp, has not been used to define another input channel
00F157  2               ; the data is expected to be from the keyboard. the data byte is returned in
00F157  2               ; the accumulator. the channel remains open after the call.
00F157  2               ;
00F157  2               ; input from the keyboard is handled in a special way. first, the cursor is
00F157  2               ; turned on and it will blink until a carriage return is typed on the keyboard.
00F157  2               ; all characters on the logical line, up to 88 characters, will be stored in
00F157  2               ; the BASIC input buffer. then the characters can be returned one at a time by
00F157  2               ; calling this routine once for each character. when the carriage return is
00F157  2               ; returned the entire line has been processed. the next time this routine is
00F157  2               ; called the whole process begins again.
00F157  2               ;
00F157  2               ByteFromChan2:				;				[F157]
00F157  2  A5 99        	lda	DFLTN			; get the input device number
00F159  2  D0 0B        	bne	A_F166			; if not the keyboard continue
00F15B  2               
00F15B  2               ; the input device was the keyboard
00F15B  2  A5 D3        	lda	LineCurCol		; get the cursor column
00F15D  2  85 CA        	sta	CursorCol		; set the input cursor column
00F15F  2               
00F15F  2  A5 D6        	lda	PhysCurRow		; get the cursor row
00F161  2  85 C9        	sta	CursorRow		; set the input cursor row
00F163  2               
00F163  2  4C 32 E6     	jmp	InputScrKeyb		; input from screen or keyboard	[E632]
00F166  2               
00F166  2               ; the input device was not the keyboard
00F166  2               A_F166:					;				[F166]
00F166  2  C9 03        	cmp	#$03			; compare device number with screen
00F168  2  D0 09        	bne	A_F173			; if not screen continue
00F16A  2               
00F16A  2               ; the input device was the screen
00F16A  2  85 D0        	sta	CRSW			; input from keyboard or screen,
00F16C  2               					; $xx = screen, $00 = keyboard
00F16C  2  A5 D5        	lda	CurLineLeng		; get current screen line length
00F16E  2  85 C8        	sta	INDX			; save input [EOL] pointer
00F170  2               
00F170  2  4C 32 E6     	jmp	InputScrKeyb		; input from screen or keyboard	[E632]
00F173  2               
00F173  2               ; the input device was not the screen
00F173  2               A_F173:					;				[F173]
00F173  2  B0 38        	bcs	A_F1AD			; if input device > screen, do IEC
00F175  2               					; devices
00F175  2               ; the input device was < screen
00F175  2  C9 02        	cmp	#$02			; compare device with the RS232 device
00F177  2  F0 3F        	beq	A_F1B8			; if RS232 device, go get a byte from
00F179  2               					; the RS232 device
00F179  2               ; only the tape device left ..
00F179  2  86 97        	stx	TEMP97			; save X
00F17B  2               
00F17B  2  20 99 F1     	jsr	GetByteTape		; get a byte from tape		[F199]
00F17E  2  B0 16        	bcs	A_F196			; if error just exit
00F180  2               
00F180  2  48           	pha				; save the byte
00F181  2               
00F181  2  20 99 F1     	jsr	GetByteTape		; get the next byte from tape	[F199]
00F184  2  B0 0D        	bcs	A_F193			; if error just exit
00F186  2               
00F186  2  D0 05        	bne	A_F18D			; if end reached ??
00F188  2               
00F188  2  A9 40        	lda	#$40			; set EOI
00F18A  2  20 1C FE     	jsr	AorIecStatus		; OR into the serial status byte [FE1C]
00F18D  2               A_F18D:					;				[F18D]
00F18D  2  C6 A6        	dec	BUFPNT			; decrement tape buffer index
00F18F  2               
00F18F  2  A6 97        	ldx	TEMP97			; restore X
00F191  2               
00F191  2  68           	pla				; restore the saved byte
00F192  2  60           	rts
00F193  2               
00F193  2               ; error exit from input character
00F193  2               A_F193:					;				[F193]
00F193  2  AA           	tax				; copy the error byte
00F194  2               
00F194  2  68           	pla				; dump the saved byte
00F195  2  8A           	txa				; restore error byte
00F196  2               A_F196:					;				[F196]
00F196  2  A6 97        	ldx	TEMP97			; restore X
00F198  2  60           	rts
00F199  2               
00F199  2               
00F199  2               ;******************************************************************************
00F199  2               ;
00F199  2               ; get byte from tape
00F199  2               ;
00F199  2               GetByteTape:				;				[F199]
00F199  2  20 0D F8     	jsr	BumpTapePtr		; bump tape pointer		[F80D]
00F19C  2  D0 0B        	bne	A_F1A9			; if not end get next byte and exit
00F19E  2               
00F19E  2  20 41 F8     	jsr	InitTapeRead		; initiate tape read		[F841]
00F1A1  2  B0 11        	bcs	A_F1B4			; exit if error flagged
00F1A3  2               
00F1A3  2  A9 00        	lda	#$00			; clear A
00F1A5  2  85 A6        	sta	BUFPNT			; clear tape buffer index
00F1A7  2  F0 F0        	beq	GetByteTape		; loop, branch always
00F1A9  2               
00F1A9  2               A_F1A9:					;				[F1A9]
00F1A9  2  B1 B2        	lda	(TapeBufPtr),Y		; get next byte from buffer
00F1AB  2               
00F1AB  2  18           	clc				; flag no error
00F1AC  2               
00F1AC  2  60           	rts
00F1AD  2               
00F1AD  2               ; input device was serial bus
00F1AD  2               A_F1AD:					;				[F1AD]
00F1AD  2  A5 90        	lda	STATUS			; get the serial status byte
00F1AF  2  F0 04        	beq	A_F1B5			; if no errors flagged go input byte
00F1B1  2               					; and return
00F1B1  2               A_F1B1:					;				[F1B1]
00F1B1  2  A9 0D        	lda	#$0D			; else return [EOL]
00F1B3  2               A_F1B3:					;				[F1B3]
00F1B3  2  18           	clc				; flag no error
00F1B4  2               A_F1B4:					;				[F1B4]
00F1B4  2  60           	rts
00F1B5  2               
00F1B5  2               A_F1B5:					;				[F1B5]
00F1B5  2  4C 13 EE     	jmp	IecByteIn2		; input byte from serial bus and return
00F1B8  2               					;				[EE13]
00F1B8  2               ; input device was RS232 device
00F1B8  2               A_F1B8:					;				[F1B8]
00F1B8  2  20 4E F1     	jsr	GetByteInpDev2		; get byte from RS232 device	[F14E]
00F1BB  2  B0 F7        	bcs	A_F1B4			; branch if error, this doesn't get
00F1BD  2               					; taken as the last instruction in the
00F1BD  2               					; get byte from RS232 device routine
00F1BD  2               					; is CLC ??
00F1BD  2  C9 00        	cmp	#$00			; compare with null
00F1BF  2  D0 F2        	bne	A_F1B3			; exit if not null
00F1C1  2               
00F1C1  2  AD 97 02     	lda	RSSTAT			; get the RS232 status register
00F1C4  2  29 60        	and	#$60			; mask 0xx0 0000, DSR detected and ??
00F1C6  2  D0 E9        	bne	A_F1B1			; if ?? return null
00F1C8  2               
00F1C8  2  F0 EE        	beq	A_F1B8			; else loop, branch always
00F1CA  2               
00F1CA  2               
00F1CA  2               ;******************************************************************************
00F1CA  2               ;
00F1CA  2               ; output character to channel
00F1CA  2               ;
00F1CA  2               ; this routine will output a character to an already opened channel. Use the
00F1CA  2               ; OPEN routine, OpenLogFile, and the CHKOUT routine, OpenChan4OutpB, to set up
00F1CA  2               ; the output channel before calling this routine. If these calls are omitted,
00F1CA  2               ; data will be sent to the default output device, device 3, the screen. The
00F1CA  2               ; data byte to be output is loaded into the accumulator, and this routine is
00F1CA  2               ; called. The data is then sent to the specified output device. The channel is
00F1CA  2               ; left open after the call.
00F1CA  2               ;
00F1CA  2               ; NOTE: Care must be taken when using routine to send data to a serial device
00F1CA  2               ; since data will be sent to all open output channels on the bus. Unless this
00F1CA  2               ; is desired, all open output channels on the serial bus other than the
00F1CA  2               ; actually intended destination channel must be closed by a call to the KERNAL
00F1CA  2               ; close channel routine.
00F1CA  2               ;
00F1CA  2               OutByteChan2:				;				[F1CA]
00F1CA  2  48           	pha				; save the character to output
00F1CB  2               
00F1CB  2  A5 9A        	lda	DFLTO			; get the output device number
00F1CD  2               S_F1CD:
00F1CD  2  C9 03        	cmp	#$03			; compare the output device with screen
00F1CF  2  D0 04        	bne	A_F1D5			; if not the screen go ??
00F1D1  2               
00F1D1  2               ; the output device is the screen
00F1D1  2  68           	pla				; else restore the output character
00F1D2  2  4C 16 E7     	jmp	OutputChar		; go output the character to the screen
00F1D5  2               					;				[E716]
00F1D5  2               
00F1D5  2               ; the output device was not the screen
00F1D5  2               A_F1D5:					;				[F1D5]
00F1D5  2  90 04        	bcc	OutByteChan2b		; if < screen go ??
00F1D7  2               
00F1D7  2               ; the output device was > screen so it is a serial bus device
00F1D7  2  68           	pla				; else restore the output character
00F1D8  2  4C DD ED     	jmp	IecByteOut2		; go output the character to the serial
00F1DB  2               					; bus				[EDDD]
00F1DB  2               
00F1DB  2               ; the output device is < screen
00F1DB  2               OutByteChan2b:				;				[F1DB]
00F1DB  2  4A           	lsr				; shift b0 of the device into Cb
00F1DC  2               
00F1DC  2  68           	pla				; restore the output character
00F1DD  2               
00F1DD  2               
00F1DD  2               ;******************************************************************************
00F1DD  2               ;
00F1DD  2               ; output the character to the cassette or RS232 device
00F1DD  2               ;
00F1DD  2               OutByteCasRS:				;				[F1DD]
00F1DD  2  85 9E        	sta	PTR1			; save character to character buffer
00F1DF  2               
00F1DF  2  8A           	txa				; copy X
00F1E0  2  48           	pha				; save X
00F1E1  2               
00F1E1  2  98           	tya				; copy Y
00F1E2  2  48           	pha				; save Y
00F1E3  2               
00F1E3  2  90 23        	bcc	A_F208			; if Cb is clear it must be RS232 device
00F1E5  2               
00F1E5  2               ; output the character to the cassette
00F1E5  2  20 0D F8     	jsr	BumpTapePtr		; bump the tape pointer		[F80D]
00F1E8  2  D0 0E        	bne	A_F1F8			; if not end save next byte and exit
00F1EA  2               
00F1EA  2  20 64 F8     	jsr	InitTapeWrite		; initiate tape write		[F864]
00F1ED  2  B0 0E        	bcs	A_F1FD			; exit if error
00F1EF  2               
00F1EF  2  A9 02        	lda	#$02			; set data block type ??
00F1F1  2  A0 00        	ldy	#$00			; clear index
00F1F3  2  91 B2        	sta	(TapeBufPtr),Y		; save type to buffer ??
00F1F5  2               
00F1F5  2  C8           	iny				; increment index
00F1F6  2  84 A6        	sty	BUFPNT			; save tape buffer index
00F1F8  2               A_F1F8:					;				[F1F8]
00F1F8  2  A5 9E        	lda	PTR1			; restore char from character buffer
00F1FA  2  91 B2        	sta	(TapeBufPtr),Y		; save to buffer
00F1FC  2               J_F1FC:					;				[F1FC]
00F1FC  2  18           	clc				; flag no error
00F1FD  2               A_F1FD:					;				[F1FD]
00F1FD  2  68           	pla				; pull Y
00F1FE  2  A8           	tay				; restore Y
00F1FF  2               
00F1FF  2  68           	pla				; pull X
00F200  2  AA           	tax				; restore X
00F201  2               
00F201  2  A5 9E        	lda	PTR1			; get character from character buffer
00F203  2  90 02        	bcc	A_F207			; exit if no error
00F205  2               
00F205  2  A9 00        	lda	#$00			; else clear A
00F207  2               A_F207:					;				[F207]
00F207  2  60           	rts
00F208  2               
00F208  2               ; output the character to the RS232 device
00F208  2               A_F208:					;				[F208]
00F208  2  20 17 F0     	jsr	Byte2RS232Buf		; send byte to RS232 buffer, no setup
00F20B  2               					;				[F017]
00F20B  2  4C FC F1     	jmp	J_F1FC			; do no error exit		[F1FC]
00F20E  2               
00F20E  2               
00F20E  2               ;******************************************************************************
00F20E  2               ;
00F20E  2               ; open channel for input
00F20E  2               ;
00F20E  2               ; any logical file that has already been opened by the OPEN routine,
00F20E  2               ; OpenLogFile, can be defined as an input channel by this routine. the device
00F20E  2               ; on the channel must be an input device or an error will occur and the routine
00F20E  2               ; will abort.
00F20E  2               ;
00F20E  2               ; if you are getting data from anywhere other than the keyboard, this routine
00F20E  2               ; must be called before using either the CHRIN routine, ByteFromChan, or the
00F20E  2               ; GETIN routine, GetCharFromIO12. if you are getting data from the keyboard and
00F20E  2               ; no other input channels are open then the calls to this routine and to the
00F20E  2               ; OPEN routine, OpenLogFile, are not needed.
00F20E  2               ;
00F20E  2               ; when used with a device on the serial bus this routine will automatically
00F20E  2               ; send the listen address specified by the OPEN routine, OpenLogFile, and any
00F20E  2               ; secondary address.
00F20E  2               ;
00F20E  2               ; possible errors are:
00F20E  2               ;
00F20E  2               ;	3 : file not open
00F20E  2               ;	5 : device not present
00F20E  2               ;	6 : file is not an input file
00F20E  2               ;
00F20E  2               OpenChanInput:				;				[F20E]
00F20E  2  20 0F F3     	jsr	FindFile		; find a file			[F30F]
00F211  2  F0 03        	beq	A_F216			; if the file is open continue
00F213  2               
00F213  2  4C 01 F7     	jmp	FileNotOpenErr		; else do 'file not open' error and
00F216  2               					; return			[F701]
00F216  2               A_F216:					;				[F216]
00F216  2  20 1F F3     	jsr	SetFileDetails		; set file details from table,X	[F31F]
00F219  2               S_F219:
00F219  2  A5 BA        	lda	FA			; get the device number
00F21B  2  F0 16        	beq	A_F233			; if the device was the keyboard save
00F21D  2               					; the device #, flag ok and exit
00F21D  2  C9 03        	cmp	#$03			; compare device number with screen
00F21F  2  F0 12        	beq	A_F233			; if the device was the screen save the
00F221  2               					; device #, flag ok and exit
00F221  2  B0 14        	bcs	A_F237			; if device was a serial bus device, ->
00F223  2               
00F223  2  C9 02        	cmp	#$02			; RS232?
00F225  2  D0 03        	bne	A_F22A			; no, -> tape
00F227  2               
00F227  2  4C 4D F0     	jmp	InputRS232Buf		; else go get input from the RS232
00F22A  2               					; buffer and return		[F04D]
00F22A  2               ; Handle tape
00F22A  2               A_F22A:					;				[F22A]
00F22A  2  A6 B9        	ldx	SA			; get the secondary address
00F22C  2  E0 60        	cpx	#$60			;.
00F22E  2  F0 03        	beq	A_F233			;.
00F230  2               
00F230  2  4C 0A F7     	jmp	NoInputFileErr		; go do 'not input file' error and
00F233  2               					; return			[F70A]
00F233  2               
00F233  2               A_F233:					;				[F233]
00F233  2  85 99        	sta	DFLTN			; save the input device number
00F235  2               
00F235  2  18           	clc				; flag ok
00F236  2               
00F236  2  60           	rts
00F237  2               
00F237  2               ; the device was a serial bus device
00F237  2               A_F237:					;				[F237]
00F237  2  AA           	tax				; copy device number to X
00F238  2  20 09 ED     	jsr	CmdTALK2		; command serial device to TALK	[ED09]
00F23B  2               
00F23B  2  A5 B9        	lda	SA			; get the secondary address
00F23D  2  10 06        	bpl	A_F245			;.
00F23F  2               
00F23F  2  20 CC ED     	jsr	Wait4IEC		; wait for the serial bus end after
00F242  2               					; send				[EDCC]
00F242  2  4C 48 F2     	jmp	A_F248			;				[F248]
00F245  2               
00F245  2               A_F245:					;				[F245]
00F245  2  20 C7 ED     	jsr	SAafterTALK2		; send secondary address after TALK
00F248  2               					;				[EDC7]
00F248  2               A_F248:					;				[F248]
00F248  2  8A           	txa				; copy device back to A
00F249  2  24 90        	bit	STATUS			; test the serial status byte
00F24B  2  10 E6        	bpl	A_F233			; if device present save device number
00F24D  2               					; and exit
00F24D  2  4C 07 F7     	jmp	DevNotPresent		; do 'device not present' error and
00F250  2               					; return			[F707]
00F250  2               
00F250  2               ;******************************************************************************
00F250  2               ;
00F250  2               ; open channel for output
00F250  2               ;
00F250  2               ; any logical file that has already been opened by the OPEN routine,
00F250  2               ; OpenLogFile, can be defined as an output channel by this routine the device
00F250  2               ; on the channel must be an output device or an error will occur and the
00F250  2               ; routine will abort.
00F250  2               ;
00F250  2               ; if you are sending data to anywhere other than the screen this routine must
00F250  2               ; be called before using the CHROUT routine, OutByteChan. if you are sending
00F250  2               ; data to the screen and no other output channels are open then the calls to
00F250  2               ; this routine and to the OPEN routine, OpenLogFile, are not needed.
00F250  2               ;
00F250  2               ; when used with a device on the serial bus this routine will automatically
00F250  2               ; send the listen address specified by the OPEN routine, OpenLogFile, and any
00F250  2               ; secondary address.
00F250  2               ;
00F250  2               ; possible errors are:
00F250  2               ;
00F250  2               ;	3 : file not open
00F250  2               ;	5 : device not present
00F250  2               ;	7 : file is not an output file
00F250  2               ;
00F250  2               OpenChanOutput:				;				[F250]
00F250  2  20 0F F3     	jsr	FindFile		; find a file			[F30F]
00F253  2  F0 03        	beq	A_F258			; if file found continue
00F255  2               
00F255  2  4C 01 F7     	jmp	FileNotOpenErr		; else do 'file not open' error and
00F258  2               					; return			[F701]
00F258  2               
00F258  2               A_F258:					;				[F258]
00F258  2  20 1F F3     	jsr	SetFileDetails		; set file details from table,X	[F31F]
00F25B  2               S_F25B:
00F25B  2  A5 BA        	lda	FA			; get the device number
00F25D  2  D0 03        	bne	A_F262			; if not the keyboard, ->
00F25F  2               A_F25F:					;				[F25F]
00F25F  2  4C 0D F7     	jmp	NoOutpFileErr		; go do 'not output file' error and
00F262  2               					; return			[F70D]
00F262  2               A_F262:					;				[F262]
00F262  2  C9 03        	cmp	#$03			; compare the device with the screen
00F264  2  F0 0F        	beq	A_F275			; if device is screen go save output
00F266  2               					; device number and exit
00F266  2  B0 11        	bcs	A_F279			; if > screen then go handle a serial
00F268  2               					; bus device
00F268  2  C9 02        	cmp	#$02			; RS232?
00F26A  2  D0 03        	bne	A_F26F			; no, -> tape
00F26C  2               
00F26C  2  4C E1 EF     	jmp	OpenRsChan4Out		; else go open RS232 channel for output
00F26F  2               					;				[EFE1]
00F26F  2               ; open a tape channel for output
00F26F  2               A_F26F:					;				[F26F]
00F26F  2  A6 B9        	ldx	SA			; get the secondary address
00F271  2  E0 60        	cpx	#$60			;.
00F273  2  F0 EA        	beq	A_F25F			; if ?? do not output file error and
00F275  2               					; return
00F275  2               A_F275:					;				[F275]
00F275  2  85 9A        	sta	DFLTO			; save the output device number
00F277  2               
00F277  2  18           	clc				; flag ok
00F278  2               
00F278  2  60           	rts
00F279  2               
00F279  2               ; open an IEC channel for output
00F279  2               A_F279:					;				[F279]
00F279  2  AA           	tax				; copy the device number
00F27A  2  20 0C ED     	jsr	CmdLISTEN2		; command devices on the serial bus to
00F27D  2               					; LISTEN			[ED0C]
00F27D  2               
00F27D  2  A5 B9        	lda	SA			; get the secondary address
00F27F  2  10 05        	bpl	A_F286			; if address to send go ??
00F281  2               
00F281  2  20 BE ED     	jsr	IecAtnH			; else set serial ATN high	[EDBE]
00F284  2  D0 03        	bne	A_F289			; go ??, branch always
00F286  2               A_F286:					;				[F286]
00F286  2  20 B9 ED     	jsr	SAafterLISTEN2		; send secondary address after LISTEN
00F289  2               					;				[EDB9]
00F289  2               A_F289:					;				[F289]
00F289  2  8A           	txa				; copy device number back to A
00F28A  2  24 90        	bit	STATUS			; test the serial status byte
00F28C  2  10 E7        	bpl	A_F275			; if device is present go save output
00F28E  2               					; device number and exit
00F28E  2  4C 07 F7     	jmp	DevNotPresent		; else do 'device not present error'
00F291  2               					; and return			[F707]
00F291  2               
00F291  2               ;******************************************************************************
00F291  2               ;
00F291  2               ; close a specified logical file
00F291  2               ;
00F291  2               ; this routine is used to close a logical file after all I/O operations have
00F291  2               ; been completed on that file. This routine is called after the accumulator is
00F291  2               ; loaded with the logical file number to be closed, the same number used when
00F291  2               ; the file was opened using the OPEN routine.
00F291  2               ;
00F291  2               CloseLogFile2:				;				[F291]
00F291  2  20 14 F3     	jsr	FindFileA		; find file A			[F314]
00F294  2  F0 02        	beq	A_F298			; if file found go close it
00F296  2               
00F296  2  18           	clc				; else file was closed so just flag ok
00F297  2  60           	rts
00F298  2               
00F298  2               ; file found so close it
00F298  2               A_F298:					;				[F298]
00F298  2  20 1F F3     	jsr	SetFileDetails		; set file details from table,X	[F31F]
00F29B  2  8A           	txa				; copy file index to A
00F29C  2  48           	pha				; save file index
00F29D  2               S_F29D:
00F29D  2  A5 BA        	lda	FA			; get the device number
00F29F  2  F0 50        	beq	J_F2F1			; if it is keyboard go restore index
00F2A1  2               					; and close the file
00F2A1  2  C9 03        	cmp	#$03			; compare device number with screen
00F2A3  2  F0 4C        	beq	J_F2F1			; if it is the screen go restore the
00F2A5  2               					; index and close the file
00F2A5  2  B0 47        	bcs	A_F2EE			; if > screen, do serial device close
00F2A7  2               
00F2A7  2  C9 02        	cmp	#$02			; compare device with RS232 device
00F2A9  2  D0 1D        	bne	A_F2C8			; if not the RS232 device go to tape
00F2AB  2               
00F2AB  2               ; else close RS232 device
00F2AB  2  68           	pla				; restore file index
00F2AC  2  20 F2 F2     	jsr	ClosFileIndxX		; close file index X		[F2F2]
00F2AF  2               
00F2AF  2  20 83 F4     	jsr	InitRS232_TX		; initialise RS232 output	[F483]
00F2B2  2  20 27 FE     	jsr	ReadTopOfMem		; read the top of memory	[FE27]
00F2B5  2               
00F2B5  2  A5 F8        	lda	RIBUF+1			; get RS232 input buffer pointer HB
00F2B7  2  F0 01        	beq	A_F2BA			; if no RS232 input buffer go ??
00F2B9  2               
00F2B9  2  C8           	iny				; else reclaim RS232 input buffer memory
00F2BA  2               A_F2BA:					;				[F2BA]
00F2BA  2  A5 FA        	lda	ROBUF+1			; get RS232 output buffer pointer HB
00F2BC  2  F0 01        	beq	A_F2BF			; if no RS232 output buffer skip reclaim
00F2BE  2               
00F2BE  2  C8           	iny				; else reclaim RS232 output buf memory
00F2BF  2               A_F2BF:					;				[F2BF]
00F2BF  2  A9 00        	lda	#$00			; clear A
00F2C1  2  85 F8        	sta	RIBUF+1			; clear RS232 input buffer pointer HB
00F2C3  2  85 FA        	sta	ROBUF+1			; clear RS232 output buffer pointer HB
00F2C5  2               
00F2C5  2  4C 7D F4     	jmp	SetTopOfMem		; go set top of memory to F0xx 	[F47D]
00F2C8  2               
00F2C8  2               ; is not the RS232 device
00F2C8  2               A_F2C8:					;				[F2C8]
00F2C8  2  A5 B9        	lda	SA			; get the secondary address
00F2CA  2  29 0F        	and	#$0F			; mask the device #
00F2CC  2  F0 23        	beq	J_F2F1			; if ?? restore index and close file
00F2CE  2               
00F2CE  2  20 D0 F7     	jsr	TapeBufPtr2XY		; get tape buffer start pointer in XY
00F2D1  2               					;				[F7D0]
00F2D1  2  A9 00        	lda	#$00			; character $00
00F2D3  2  38           	sec				; flag the tape device
00F2D4  2  20 DD F1     	jsr	OutByteCasRS		; output the character to the cassette
00F2D7  2               					; or RS232 device		[F1DD]
00F2D7  2  20 64 F8     	jsr	InitTapeWrite		; initiate tape write		[F864]
00F2DA  2  90 04        	bcc	A_F2E0			;.
00F2DC  2               
00F2DC  2  68           	pla				;.
00F2DD  2               
00F2DD  2  A9 00        	lda	#$00			;.
00F2DF  2  60           	rts
00F2E0  2               
00F2E0  2               A_F2E0:					;				[F2E0]
00F2E0  2  A5 B9        	lda	SA			; get the secondary address
00F2E2  2  C9 62        	cmp	#$62			;.
00F2E4  2  D0 0B        	bne	J_F2F1			; if not ?? restore index and close file
00F2E6  2               
00F2E6  2  A9 05        	lda	#$05			; set logical end of the tape
00F2E8  2  20 6A F7     	jsr	WriteTapeHdr		; write tape header		[F76A]
00F2EB  2  4C F1 F2     	jmp	J_F2F1			; restore index and close file	[F2F1]
00F2EE  2               
00F2EE  2               
00F2EE  2               ;******************************************************************************
00F2EE  2               ;
00F2EE  2               ; serial bus device close
00F2EE  2               ;
00F2EE  2               A_F2EE:					;				[F2EE]
00F2EE  2  20 42 F6     	jsr	CloseIecDevice		; close serial bus device	[F642]
00F2F1  2               J_F2F1:					;				[F2F1]
00F2F1  2  68           	pla				; restore file index
00F2F2  2               
00F2F2  2               
00F2F2  2               ;******************************************************************************
00F2F2  2               ;
00F2F2  2               ; close file index X
00F2F2  2               ;
00F2F2  2               ClosFileIndxX:				;				[F2F2]
00F2F2  2  AA           	tax				; copy index to file to close
00F2F3  2               S_F2F3:					;				[F2F3]
00F2F3  2  C6 98        	dec	LDTND			; decrement the open file count
00F2F5  2               
00F2F5  2  E4 98        	cpx	LDTND			; compare index with open file count
00F2F7  2  F0 14        	beq	A_F30D			; exit if equal, last entry was closing
00F2F9  2               					; file
00F2F9  2               ; else entry was not last in list so copy last table entry file details over
00F2F9  2               ; the details of the closing one
00F2F9  2  A4 98        	ldy	LDTND			; get the open file count as index
00F2FB  2  B9 59 02     	lda	LogFileTbl,Y		; get last+1 logical file number from
00F2FE  2               					; logical file table
00F2FE  2  9D 59 02     	sta	LogFileTbl,X		; save logical file number over closed
00F301  2               					; file
00F301  2  B9 63 02     	lda	DevNumTbl,Y		; get last+1 device number from device
00F304  2               					; number table
00F304  2  9D 63 02     	sta	DevNumTbl,X		; save device number over closed file
00F307  2               
00F307  2  B9 6D 02     	lda	SecAddrTbl,Y		; get last+1 secondary address from
00F30A  2               					; secondary address table
00F30A  2  9D 6D 02     	sta	SecAddrTbl,X		; save secondary address over closed
00F30D  2               					; file
00F30D  2               A_F30D:					;				[F30D]
00F30D  2  18           	clc				; flag ok
00F30E  2               
00F30E  2  60           	rts
00F30F  2               
00F30F  2               
00F30F  2               ;******************************************************************************
00F30F  2               ;
00F30F  2               ; find a file
00F30F  2               ;
00F30F  2               FindFile:				;				[F30F]
00F30F  2  A9 00        	lda	#$00			; clear A
00F311  2  85 90        	sta	STATUS			; clear the serial status byte
00F313  2               
00F313  2  8A           	txa				; copy the logical file number to A
00F314  2               
00F314  2               
00F314  2               ;******************************************************************************
00F314  2               ;
00F314  2               ; find file A
00F314  2               ;
00F314  2               FindFileA:				;				[F314]
00F314  2  A6 98        	ldx	LDTND			; get the open file count
00F316  2               A_F316:					;				[F316]
00F316  2  CA           	dex				; decrememnt the count to give the index
00F317  2  30 15        	bmi	A_F32E			; if no files just exit
00F319  2               
00F319  2  DD 59 02     	cmp	LogFileTbl,X		; compare the logical file number with
00F31C  2               					; the table logical file number
00F31C  2  D0 F8        	bne	A_F316			; if no match go try again
00F31E  2               
00F31E  2  60           	rts
00F31F  2               
00F31F  2               
00F31F  2               ;******************************************************************************
00F31F  2               ;
00F31F  2               ; set file details from table,X
00F31F  2               ;
00F31F  2               SetFileDetails:				;				[F31F]
00F31F  2  BD 59 02     	lda	LogFileTbl,X		; get logical file from logical file
00F322  2               					; table
00F322  2  85 B8        	sta	LA			; save the logical file
00F324  2               
00F324  2  BD 63 02     	lda	DevNumTbl,X		; get device number from device number
00F327  2               					; table
00F327  2  85 BA        	sta	FA			; save the device number
00F329  2               
00F329  2  BD 6D 02     	lda	SecAddrTbl,X		; get secondary address from secondary
00F32C  2               					; address table
00F32C  2  85 B9        	sta	SA			; save the secondary address
00F32E  2               A_F32E:					;				[F32E]
00F32E  2  60           	rts
00F32F  2               
00F32F  2               
00F32F  2               ;******************************************************************************
00F32F  2               ;
00F32F  2               ; close all channels and files
00F32F  2               ;
00F32F  2               ; this routine closes all open files. When this routine is called, the pointers
00F32F  2               ; into the open file table are reset, closing all files. Also the routine
00F32F  2               ; automatically resets the I/O channels.
00F32F  2               ;
00F32F  2               ClsAllChnFil:				;				[F32F]
00F32F  2  A9 00        	lda	#$00			; clear A
00F331  2  85 98        	sta	LDTND			; clear the open file count
00F333  2               
00F333  2               
00F333  2               ;******************************************************************************
00F333  2               ;
00F333  2               ; close input and output channels
00F333  2               ;
00F333  2               ; this routine is called to clear all open channels and restore the I/O
00F333  2               ; channels to their original default values. It is usually called after opening
00F333  2               ; other I/O channels and using them for input/output operations. The default
00F333  2               ; input device is 0, the keyboard. The default output device is 3, the screen.
00F333  2               ;
00F333  2               ; If one of the channels to be closed is to the serial port, an UNTALK signal
00F333  2               ; is sent first to clear the input channel or an UNLISTEN is sent to clear the
00F333  2               ; output channel. By not calling this routine and leaving listener(s) active on
00F333  2               ; the serial bus, several devices can receive the same data from the VIC at the
00F333  2               ; same time. One way to take advantage of this would be to command the printer
00F333  2               ; to TALK and the disk to LISTEN. This would allow direct printing of a disk
00F333  2               ; file.
00F333  2               ;
00F333  2               CloseIoChans:				;				[F333]
00F333  2  A2 03        	ldx	#$03			; set the screen device
00F335  2  E4 9A        	cpx	DFLTO			; compare the screen with the output
00F337  2               					; device number
00F337  2  B0 03        	bcs	A_F33C			; if <= screen skip serial bus unlisten
00F339  2               
00F339  2  20 FE ED     	jsr	IecUNLISTEN2		; else command the serial bus to
00F33C  2               					; UNLISTEN			[EDFE]
00F33C  2               A_F33C:					;				[F33C]
00F33C  2  E4 99        	cpx	DFLTN			; compare the screen with the input
00F33E  2               					; device number
00F33E  2  B0 03        	bcs	A_F343			; if <= screen skip serial bus untalk
00F340  2               
00F340  2  20 EF ED     	jsr	IecUNTALK2		; else command the serial bus to
00F343  2               					; UNTALK			[EDEF]
00F343  2               A_F343:					;				[F343]
00F343  2  86 9A        	stx	DFLTO			; save the screen as the output
00F345  2               					; device number
00F345  2  A9 00        	lda	#$00			; set the keyboard as the input device
00F347  2  85 99        	sta	DFLTN			; save the input device number
00F349  2               
00F349  2  60           	rts
00F34A  2               
00F34A  2               
00F34A  2               ;******************************************************************************
00F34A  2               ;
00F34A  2               ; open a logical file
00F34A  2               ;
00F34A  2               ; this routine is used to open a logical file. Once the logical file is set up
00F34A  2               ; it can be used for input/output operations. Most of the I/O KERNAL routines
00F34A  2               ; call on this routine to create the logical files to operate on. No arguments
00F34A  2               ; need to be set up to use this routine, but both the SETLFS, SetAddresses, and
00F34A  2               ; SETNAM, SetFileName, KERNAL routines must be called before using this
00F34A  2               ; routine.
00F34A  2               ;
00F34A  2               OpenLogFile2:				;				[F34A]
00F34A  2  A6 B8        	ldx	LA			; get the logical file
00F34C  2  D0 03        	bne	A_F351			; if there is a file continue
00F34E  2               
00F34E  2  4C 0A F7     	jmp	NoInputFileErr		; else do 'not input file error' and
00F351  2               					; return			[F70A]
00F351  2               A_F351:					;				[F351]
00F351  2  20 0F F3     	jsr	FindFile		; find a file			[F30F]
00F354  2  D0 03        	bne	A_F359			; if file not found continue
00F356  2               
00F356  2  4C FE F6     	jmp	FileAlreadyOpen		; else do 'file already open' error and
00F359  2               					; return			[F6FE]
00F359  2               A_F359:					;				[F359]
00F359  2  A6 98        	ldx	LDTND			; get the open file count
00F35B  2  E0 0A        	cpx	#10			; < maximum + 1 ?
00F35D  2  90 03        	bcc	A_F362			; if less than maximum + 1 go open file
00F35F  2               
00F35F  2  4C FB F6     	jmp	TooManyFilesErr		; else do 'too many files error' and
00F362  2               					; return			[F6FB]
00F362  2               A_F362:					;				[F362]
00F362  2  E6 98        	inc	LDTND			; increment the open file count
00F364  2               
00F364  2  A5 B8        	lda	LA			; get the logical file
00F366  2  9D 59 02     	sta	LogFileTbl,X		; save it to the logical file table
00F369  2               
00F369  2  A5 B9        	lda	SA			; get the secondary address
00F36B  2  09 60        	ora	#$60			; OR with the OPEN CHANNEL command
00F36D  2  85 B9        	sta	SA			; save the secondary address
00F36F  2  9D 6D 02     	sta	SecAddrTbl,X		; save it to the secondary address table
00F372  2               
00F372  2  A5 BA        	lda	FA			; get the device number
00F374  2  9D 63 02     	sta	DevNumTbl,X		; save it to the device number table
00F377  2  F0 5A        	beq	A_F3D3			; if it is the keyboard, do ok exit
00F379  2               S_F379:
00F379  2  C9 03        	cmp	#$03			; compare device number with screen
00F37B  2  F0 56        	beq	A_F3D3			; if it is the screen go do the ok exit
00F37D  2  90 05        	bcc	OpenLogFile3		; if tape or RS232 device go ??
00F37F  2               					; else it is a serial bus device
00F37F  2               ; else is serial bus device
00F37F  2  20 D5 F3     	jsr	SndSecAdrFilNm		; send secondary address and filename
00F382  2               					;				[F3D5]
00F382  2  90 4F        	bcc	A_F3D3			; go do ok exit, branch always
00F384  2               
00F384  2               OpenLogFile3:				;				[F384]
00F384  2  C9 02        	cmp	#$02			; RS-232?
00F386  2  D0 03        	bne	A_F38B			; no, ->
00F388  2               
00F388  2  4C 09 F4     	jmp	OpenRS232Dev		; go open RS232 device and return [F409]
00F38B  2               
00F38B  2               A_F38B:					;				[F38B]
00F38B  2  20 D0 F7     	jsr	TapeBufPtr2XY		; get tape buffer start pointer in XY
00F38E  2               					;				[F7D0]
00F38E  2  B0 03        	bcs	A_F393			; if >= $0200 go ??
00F390  2               A_F390:					;				[F390]
00F390  2  4C 13 F7     	jmp	IllegalDevNum		; else do 'illegal device number' and
00F393  2               					; return			[F713]
00F393  2               A_F393:					;				[F393]
00F393  2  A5 B9        	lda	SA			; get the secondary address
00F395  2  29 0F        	and	#$0F			;.
00F397  2  D0 1F        	bne	A_F3B8			;.
00F399  2               
00F399  2  20 17 F8     	jsr	WaitForPlayKey		; wait for PLAY			[F817]
00F39C  2  B0 36        	bcs	A_F3D4			; exit if STOP was pressed
00F39E  2               
00F39E  2  20 AF F5     	jsr	PrtSEARCHING		; print "Searching..."		[F5AF]
00F3A1  2               
00F3A1  2  A5 B7        	lda	FNLEN			; get filename length
00F3A3  2  F0 0A        	beq	A_F3AF			; if null filename just go find header
00F3A5  2               
00F3A5  2  20 EA F7     	jsr	FindTapeHeader		; find specific tape header	[F7EA]
00F3A8  2  90 18        	bcc	A_F3C2			; branch if no error
00F3AA  2               
00F3AA  2  F0 28        	beq	A_F3D4			; exit if ??
00F3AC  2               
00F3AC  2               A_F3AC:					;				[F3AC]
00F3AC  2  4C 04 F7     	jmp	FileNotFound		; do file not found error and return
00F3AF  2               					;	[F704]
00F3AF  2               A_F3AF:					;				[F3AF]
00F3AF  2  20 2C F7     	jsr	FindTapeHdr2		; find tape header, exit with header in
00F3B2  2               					; buffer			[F72C]
00F3B2  2  F0 20        	beq	A_F3D4			; exit if end of tape found
00F3B4  2               
00F3B4  2  90 0C        	bcc	A_F3C2			;.
00F3B6  2               
00F3B6  2  B0 F4        	bcs	A_F3AC			; always ->
00F3B8  2               
00F3B8  2               A_F3B8:					;				[F3B8]
00F3B8  2  20 38 F8     	jsr	WaitForPlayRec		; wait for PLAY/RECORD		[F838]
00F3BB  2  B0 17        	bcs	A_F3D4			; exit if STOP was pressed
00F3BD  2               
00F3BD  2  A9 04        	lda	#$04			; set data file header
00F3BF  2  20 6A F7     	jsr	WriteTapeHdr		; write tape header		[F76A]
00F3C2  2               A_F3C2:					;				[F3C2]
00F3C2  2  A9 BF        	lda	#$BF			;.
00F3C4  2               
00F3C4  2  A4 B9        	ldy	SA			; get the secondary address
00F3C6  2  C0 60        	cpy	#$60			;.
00F3C8  2  F0 07        	beq	A_F3D1			;.
00F3CA  2               
00F3CA  2  A0 00        	ldy	#$00			; clear index
00F3CC  2  A9 02        	lda	#$02			;.
00F3CE  2  91 B2        	sta	(TapeBufPtr),Y		;.save to tape buffer
00F3D0  2               
00F3D0  2  98           	tya				;.clear A
00F3D1  2               A_F3D1:					;				[F3D1]
00F3D1  2  85 A6        	sta	BUFPNT			;.save tape buffer index
00F3D3  2               A_F3D3:					;				[F3D3]
00F3D3  2  18           	clc				; flag ok
00F3D4  2               A_F3D4:					;				[F3D4]
00F3D4  2  60           	rts
00F3D5  2               
00F3D5  2               
00F3D5  2               ;******************************************************************************
00F3D5  2               ;
00F3D5  2               ; send secondary address and filename
00F3D5  2               ;
00F3D5  2               SndSecAdrFilNm:				;				[F3D5]
00F3D5  2  A5 B9        	lda	SA			; get the secondary address
00F3D7  2  30 FA        	bmi	A_F3D3			; ok exit if -ve
00F3D9  2               
00F3D9  2  A4 B7        	ldy	FNLEN			; get filename length
00F3DB  2  F0 F6        	beq	A_F3D3			; ok exit if null
00F3DD  2               
00F3DD  2  A9 00        	lda	#$00			; clear A
00F3DF  2  85 90        	sta	STATUS			; clear the serial status byte
00F3E1  2               
00F3E1  2  A5 BA        	lda	FA			; get the device number
00F3E3  2  20 0C ED     	jsr	CmdLISTEN2		; command devices on the serial bus to
00F3E6  2               					; LISTEN			[ED0C]
00F3E6  2  A5 B9        	lda	SA			; get the secondary address
00F3E8  2  09 F0        	ora	#$F0			; OR with the OPEN command
00F3EA  2  20 B9 ED     	jsr	SAafterLISTEN2		; send secondary address after LISTEN
00F3ED  2               					;				[EDB9]
00F3ED  2  A5 90        	lda	STATUS			; get the serial status byte
00F3EF  2  10 05        	bpl	A_F3F6			; if device present skip the 'device
00F3F1  2               					; not present' error
00F3F1  2               S_F3F1:
00F3F1  2  68           	pla				; else dump calling address LB
00F3F2  2  68           	pla				; dump calling address HB
00F3F3  2               
00F3F3  2  4C 07 F7     	jmp	DevNotPresent		; do 'device not present' error and
00F3F6  2               					; return			[F707]
00F3F6  2               A_F3F6:					;				[F3F6]
00F3F6  2  A5 B7        	lda	FNLEN			; get filename length
00F3F8  2  F0 0C        	beq	A_F406			; branch if null name
00F3FA  2               
00F3FA  2  A0 00        	ldy	#$00			; clear index
00F3FC  2               A_F3FC:					;				[F3FC]
00F3FC  2  B1 BB        	lda	(FNADR),Y		; get filename byte
00F3FE  2  20 DD ED     	jsr	IecByteOut2		; output byte to serial bus	[EDDD]
00F401  2               
00F401  2  C8           	iny				; increment index
00F402  2  C4 B7        	cpy	FNLEN			; compare with filename length
00F404  2  D0 F6        	bne	A_F3FC			; loop if not all done
00F406  2               A_F406:					;				[F406]
00F406  2  4C 54 F6     	jmp	DoUNLISTEN		; command serial bus to UNLISTEN and
00F409  2               					; return			[F654]
00F409  2               
00F409  2               ;******************************************************************************
00F409  2               ;
00F409  2               ; open RS232 device
00F409  2               ;
00F409  2               OpenRS232Dev:				;				[F409]
00F409  2  20 83 F4     	jsr	InitRS232_TX		; initialise RS232 output	[F483]
00F40C  2  8C 97 02     	sty	RSSTAT			; save the RS232 status register
00F40F  2               A_F40F:					;				[F40F]
00F40F  2  C4 B7        	cpy	FNLEN			; compare with filename length
00F411  2  F0 0A        	beq	A_F41D			; exit loop if done
00F413  2               
00F413  2  B1 BB        	lda	(FNADR),Y		; get filename byte
00F415  2  99 93 02     	sta	M51CTR,Y		; copy to 6551 register set
00F418  2               
00F418  2  C8           	iny				; increment index
00F419  2  C0 04        	cpy	#$04			; compare with $04
00F41B  2  D0 F2        	bne	A_F40F			; loop if not to 4 yet
00F41D  2               
00F41D  2               A_F41D:					;				[F41D]
00F41D  2  20 4A EF     	jsr	CalcBitCounts		; compute bit count		[EF4A]
00F420  2  8E 98 02     	stx	BITNUM			; save bit count
00F423  2               
00F423  2  AD 93 02     	lda	M51CTR			; get pseudo 6551 control register
00F426  2  29 0F        	and	#$0F			; mask 0000, baud rate
00F428  2               .if KERNAL = 1
00F428  2               	bne	A_F435
00F428  2               
00F428  2               	lda	M51AJB
00F428  2               	asl	A
00F428  2               	tay
00F428  2               	lda	M51AJB+1
00F428  2               	jmp	J_F43F			;				[F43F]
00F428  2               
00F428  2               A_F435:					;				[F435]
00F428  2               	asl	A
00F428  2               	tax
00F428  2               	lda	TblBaudNTSC-2,X
00F428  2               	asl	A
00F428  2               	tay
00F428  2               	lda	TblBaudNTSC-1,X
00F428  2               J_F43F:					;				[F43F]
00F428  2               	rol	A
00F428  2               	pha
00F428  2               
00F428  2               	tya
00F428  2               	adc	#$C8
00F428  2               	sta	BAUDOF
00F428  2               
00F428  2               	pla
00F428  2               	adc	#$00
00F428  2               	sta	BAUDOF+1
00F428  2               .endif
00F428  2               
00F428  2               .if KERNAL = 2 || KERNAL = 3
00F428  2  F0 1C        	beq	A_F446			; if zero skip the baud rate setup
00F42A  2               
00F42A  2  0A           	asl				; * 2 bytes per entry
00F42B  2  AA           	tax				; copy to the index
00F42C  2               
00F42C  2  AD A6 02     	lda	PALNTSC			; get the PAL/NTSC flag
00F42F  2  D0 09        	bne	A_F43A			; if PAL go set PAL timing
00F431  2               
00F431  2  BC C1 FE     	ldy	TblBaudNTSC-1,X		; get the NTSC baud rate value HB
00F434  2  BD C0 FE     	lda	TblBaudNTSC-2,X		; get the NTSC baud rate value LB
00F437  2  4C 40 F4     	jmp	SaveBaudRate		; go save the baud rate values	[F440]
00F43A  2               
00F43A  2               A_F43A:					;				[F43A]
00F43A  2  BC EB E4     	ldy	TblBaudRates-1,X	; get the PAL baud rate value HB
00F43D  2  BD EA E4     	lda	TblBaudRates-2,X	; get the PAL baud rate value LB
00F440  2               SaveBaudRate:				;				[F440]
00F440  2  8C 96 02     	sty	M51AJB+1		; save the nonstandard bit timing HB
00F443  2  8D 95 02     	sta	M51AJB			; save the nonstandard bit timing LB
00F446  2               A_F446:					;				[F446]
00F446  2  AD 95 02     	lda	M51AJB			; get the nonstandard bit timing LB
00F449  2  0A           	asl				; * 2
00F44A  2  20 2E FF     	jsr	SetTimerBaudR		;.				[FF2E]
00F44D  2               .endif
00F44D  2               
00F44D  2  AD 94 02     	lda	M51CDR			; read the pseudo 6551 command register
00F450  2  4A           	lsr				; shift the X line/3 line bit into Cb
00F451  2  90 09        	bcc	A_F45C			; if 3 line skip the DRS test
00F453  2               
00F453  2  AD 01 DD     	lda	CIA2DRB			; read CIA 2 DRB, RS232 port
00F456  2  0A           	asl				; shift DSR in into Cb
00F457  2  B0 03        	bcs	A_F45C			; if DSR present skip the error set
00F459  2               
00F459  2               .if KERNAL = 1
00F459  2               	jmp	DeactivateDSR		; set no DSR			[F00D]
00F459  2               .endif
00F459  2               
00F459  2               .if KERNAL = 2 || KERNAL = 3
00F459  2  20 0D F0     	jsr	DeactivateDSR		; set no DSR			[F00D]
00F45C  2               .endif
00F45C  2               
00F45C  2               A_F45C:					;				[F45C]
00F45C  2  AD 9B 02     	lda	RIDBE			; get index to Rx buffer end
00F45F  2  8D 9C 02     	sta	RIDBS			; set index to Rx buffer start, clear
00F462  2               					; Rx buffer
00F462  2  AD 9E 02     	lda	RODBS			; get index to Tx buffer end
00F465  2  8D 9D 02     	sta	RODBE			; set index to Tx buffer start, clear
00F468  2               					; Tx buffer
00F468  2  20 27 FE     	jsr	ReadTopOfMem		; read the top of memory	[FE27]
00F46B  2               
00F46B  2  A5 F8        	lda	RIBUF+1			; get RS232 input buffer pointer HB
00F46D  2  D0 05        	bne	A_F474			; if buffer already set skip the save
00F46F  2               
00F46F  2  88           	dey				; decrement top of memory HB, 256 byte
00F470  2               					; buffer
00F470  2  84 F8        	sty	RIBUF+1			; save RS232 input buffer pointer HB
00F472  2  86 F7        	stx	RIBUF			; save RS232 input buffer pointer LB
00F474  2               A_F474:					;				[F474]
00F474  2  A5 FA        	lda	ROBUF+1			; get RS232 output buffer pointer HB
00F476  2  D0 05        	bne	SetTopOfMem		; if > 0 go set the top of memory to
00F478  2               					; $F0xx
00F478  2               
00F478  2  88           	dey				;.
00F479  2  84 FA        	sty	ROBUF+1			; save RS232 output buffer pointer HB
00F47B  2  86 F9        	stx	ROBUF			; save RS232 output buffer pointer LB
00F47D  2               
00F47D  2               
00F47D  2               ;******************************************************************************
00F47D  2               ;
00F47D  2               ; set the top of memory to F0xx
00F47D  2               ;
00F47D  2               SetTopOfMem:				;				[F47D]
00F47D  2  38           	sec				; read the top of memory
00F47E  2  A9 F0        	lda	#$F0			; set $F000
00F480  2  4C 2D FE     	jmp	SetTopOfMem2		; set the top of memory and return
00F483  2               					;				[FE2D]
00F483  2               
00F483  2               ;******************************************************************************
00F483  2               ;
00F483  2               ; initialise RS232 output
00F483  2               ;
00F483  2               InitRS232_TX:				;				[F483]
00F483  2  A9 7F        	lda	#$7F			; disable all interrupts
00F485  2  8D 0D DD     	sta	CIA2IRQ			; save CIA 2 ICR
00F488  2               
00F488  2  A9 06        	lda	#$06			; set RS232 DTR output, RS232 RTS output
00F48A  2  8D 03 DD     	sta	CIA2DDRB		; save CIA 2 DDRB, RS232 port
00F48D  2  8D 01 DD     	sta	CIA2DRB			; save CIA 2 DRB, RS232 port
00F490  2               
00F490  2  A9 04        	lda	#$04			; mask x1xx, set RS232 Tx DATA high
00F492  2  0D 00 DD     	ora	CIA2DRA			; OR it with CIA 2 DRA, serial port and
00F495  2               					; video address
00F495  2  8D 00 DD     	sta	CIA2DRA			; save CIA 2 DRA, serial port and video
00F498  2               					; address
00F498  2  A0 00        	ldy	#$00			; clear Y
00F49A  2  8C A1 02     	sty	ENABL			; clear RS-232 interrupt enable byte
00F49D  2               
00F49D  2  60           	rts
00F49E  2               
00F49E  2               
00F49E  2               ;******************************************************************************
00F49E  2               ;
00F49E  2               ; load RAM from a device
00F49E  2               ;
00F49E  2               ; this routine will load data bytes from any input device directly into the
00F49E  2               ; memory of the computer. It can also be used for a verify operation comparing
00F49E  2               ; data from a device with the data already in memory, leaving the data stored
00F49E  2               ; in RAM unchanged.
00F49E  2               ;
00F49E  2               ; The accumulator must be set to 0 for a load operation or 1 for a verify. If
00F49E  2               ; the input device was OPENed with a secondary address of 0 the header
00F49E  2               ; information from device will be ignored. In this case XY must contain the
00F49E  2               ; starting address for the load. If the device was addressed with a secondary
00F49E  2               ; address of 1 or 2 the data will load into memory starting at the location
00F49E  2               ; specified by the header. This routine returns the address of the highest RAM
00F49E  2               ; location which was loaded.
00F49E  2               ;
00F49E  2               ; Before this routine can be called, the SETLFS, SetAddresses, and SETNAM,
00F49E  2               ; SetFileName, routines must be called.
00F49E  2               ;
00F49E  2               LoadRamFrmDev2:				;				[F49E]
00F49E  2  86 C3        	stx	MEMUSS			; set kernal setup pointer LB
00F4A0  2  84 C4        	sty	MEMUSS+1		; set kernal setup pointer HB
00F4A2  2               
00F4A2  2  6C 30 03     	jmp	(ILOAD)			; do LOAD vector, usually points to
00F4A5  2               					; LoadRamFrmDev22
00F4A5  2               
00F4A5  2               ;******************************************************************************
00F4A5  2               ;
00F4A5  2               ; load
00F4A5  2               ;
00F4A5  2               LoadRamFrmDev22:			;				[F4A5]
00F4A5  2  85 93        	sta	LoadVerify2		; save load/verify flag
00F4A7  2               
00F4A7  2  A9 00        	lda	#$00			; clear A
00F4A9  2  85 90        	sta	STATUS			; clear the serial status byte
00F4AB  2               S_F4AB:
00F4AB  2  A5 BA        	lda	FA			; get the device number
00F4AD  2  D0 03        	bne	A_F4B2			; if not the keyboard continue
00F4AF  2               
00F4AF  2               ; can't load form keyboard so ..
00F4AF  2               A_F4AF:					;				[F4AF]
00F4AF  2  4C 13 F7     	jmp	IllegalDevNum		; else do 'illegal device number' and
00F4B2  2               					; return			[F713]
00F4B2  2               A_F4B2:					;				[F4B2]
00F4B2  2  C9 03        	cmp	#$03			; screen?
00F4B4  2  F0 F9        	beq	A_F4AF			; yes, ->
00F4B6  2               
00F4B6  2  90 7B        	bcc	LoadFromTape		; smaller, -> load from tape
00F4B8  2               
00F4B8  2               ; else is serial bus device
00F4B8  2  A4 B7        	ldy	FNLEN			; get filename length
00F4BA  2  D0 03        	bne	A_F4BF			; if not null name go ??
00F4BC  2               
00F4BC  2  4C 10 F7     	jmp	MissingFileNam		; else do 'missing filename' error and
00F4BF  2               					; return			[F710]
00F4BF  2               A_F4BF:					;				[F4BF]
00F4BF  2  A6 B9        	ldx	SA			; get the secondary address
00F4C1  2  20 AF F5     	jsr	PrtSEARCHING		; print "Searching..."		[F5AF]
00F4C4  2               
00F4C4  2  A9 60        	lda	#$60			;.
00F4C6  2  85 B9        	sta	SA			; save the secondary address
00F4C8  2               
00F4C8  2  20 D5 F3     	jsr	SndSecAdrFilNm		; send secondary address and filename
00F4CB  2               					;				[F3D5]
00F4CB  2  A5 BA        	lda	FA			; get the device number
00F4CD  2  20 09 ED     	jsr	CmdTALK2		; command serial bus device to TALK
00F4D0  2               					;				[ED09]
00F4D0  2  A5 B9        	lda	SA			; get the secondary address
00F4D2  2  20 C7 ED     	jsr	SAafterTALK2		; send secondary address after TALK
00F4D5  2               					;				[EDC7]
00F4D5  2               LoadRamFrmDev22b:			;				[F4D5]
00F4D5  2  20 13 EE     	jsr	IecByteIn2		; input byte from serial bus	[EE13]
00F4D8  2  85 AE        	sta	EAL			; save program start address LB
00F4DA  2               
00F4DA  2  A5 90        	lda	STATUS			; get the serial status byte
00F4DC  2  4A           	lsr				; shift time out read ..
00F4DD  2  4A           	lsr				; .. into carry bit
00F4DE  2  B0 50        	bcs	A_F530			; if timed out go do file not found
00F4E0  2               					; error and return
00F4E0  2  20 13 EE     	jsr	IecByteIn2		; input byte from serial bus	[EE13]
00F4E3  2  85 AF        	sta	EAL+1			; save program start address HB
00F4E5  2               
00F4E5  2  8A           	txa				; copy secondary address
00F4E6  2  D0 08        	bne	A_F4F0			; load location not set in LOAD call,
00F4E8  2               					; so continue with the load
00F4E8  2  A5 C3        	lda	MEMUSS			; get the load address LB
00F4EA  2  85 AE        	sta	EAL			; save the program start address LB
00F4EC  2               
00F4EC  2  A5 C4        	lda	MEMUSS+1		; get the load address HB
00F4EE  2  85 AF        	sta	EAL+1			; save the program start address HB
00F4F0  2               A_F4F0:					;				[F4F0]
00F4F0  2  20 D2 F5     	jsr	LoadVerifying		;.				[F5D2]
00F4F3  2               A_F4F3:					;				[F4F3]
00F4F3  2  A9 FD        	lda	#$FD			; mask xx0x, clear time out read bit
00F4F5  2  25 90        	and	STATUS			; mask the serial status byte
00F4F7  2  85 90        	sta	STATUS			; set the serial status byte
00F4F9  2               
00F4F9  2  20 E1 FF     	jsr	ScanStopKey		; scan stop key, return Zb = 1 = [STOP]
00F4FC  2               					;				[FFE1]
00F4FC  2  D0 03        	bne	A_F501			; if not [STOP] go ??
00F4FE  2               
00F4FE  2  4C 33 F6     	jmp	CloseIecBus		; else close the serial bus device and
00F501  2               					; flag stop			[F633]
00F501  2               A_F501:					;				[F501]
00F501  2  20 13 EE     	jsr	IecByteIn2		; input byte from serial bus	[EE13]
00F504  2  AA           	tax				; copy byte
00F505  2               
00F505  2  A5 90        	lda	STATUS			; get the serial status byte
00F507  2  4A           	lsr				; shift time out read ..
00F508  2  4A           	lsr				; .. into carry bit
00F509  2  B0 E8        	bcs	A_F4F3			; if timed out go try again
00F50B  2               
00F50B  2  8A           	txa				; copy received byte back
00F50C  2               
00F50C  2  A4 93        	ldy	LoadVerify2		; get load/verify flag
00F50E  2  F0 0C        	beq	A_F51C			; if load go load
00F510  2               
00F510  2               ; else is verify
00F510  2  A0 00        	ldy	#$00			; clear index
00F512  2  D1 AE        	cmp	(EAL),Y			; compare byte with previously loaded
00F514  2               					; byte
00F514  2  F0 08        	beq	A_F51E			; if match go ??
00F516  2               
00F516  2  A9 10        	lda	#$10			; flag read error
00F518  2  20 1C FE     	jsr	AorIecStatus		; OR into the serial status byte [FE1C]
00F51B  2  2C           .byte	$2C				; makes next line BIT $AE91
00F51C  2               A_F51C:					;				[F51C]
00F51C  2  91 AE        	sta	(EAL),Y			; save byte to memory
00F51E  2               A_F51E:					;				[F51E]
00F51E  2  E6 AE        	inc	EAL			; increment save pointer LB
00F520  2  D0 02        	bne	A_F524			; if no rollover go ??
00F522  2               
00F522  2  E6 AF        	inc	EAL+1			; else increment save pointer HB
00F524  2               A_F524:					;				[F524]
00F524  2  24 90        	bit	STATUS			; test the serial status byte
00F526  2  50 CB        	bvc	A_F4F3			; loop if not end of file
00F528  2               
00F528  2               ; close file and exit
00F528  2  20 EF ED     	jsr	IecUNTALK2		; command serial bus to UNTALK	[EDEF]
00F52B  2               
00F52B  2  20 42 F6     	jsr	CloseIecDevice		; close serial device, error?	[F642]
00F52E  2  90 79        	bcc	A_F5A9			; no, -> exit
00F530  2               A_F530:					;				[F530]
00F530  2  4C 04 F7     	jmp	FileNotFound		; do file not found error and return
00F533  2               					;				[F704]
00F533  2               
00F533  2               ;******************************************************************************
00F533  2               ;
00F533  2               ; Load from tape
00F533  2               ;
00F533  2               LoadFromTape:				;				[F533]
00F533  2  4A           	lsr				; tape?
00F534  2  B0 03        	bcs	A_F539			; yes, ->
00F536  2               
00F536  2  4C 13 F7     	jmp	IllegalDevNum		; else do 'illegal device number' and
00F539  2               					; return			[F713]
00F539  2               A_F539:					;				[F539]
00F539  2  20 D0 F7     	jsr	TapeBufPtr2XY		; get tape buffer start pointer in XY
00F53C  2               					;				[F7D0]
00F53C  2  B0 03        	bcs	A_F541			; if ??
00F53E  2               
00F53E  2  4C 13 F7     	jmp	IllegalDevNum		; else do 'illegal device number' and
00F541  2               					; return			[F713]
00F541  2               
00F541  2               A_F541:					;				[F541]
00F541  2  20 17 F8     	jsr	WaitForPlayKey		; wait for PLAY			[F817]
00F544  2  B0 68        	bcs	A_F5AE			; exit if STOP was pressed
00F546  2               
00F546  2  20 AF F5     	jsr	PrtSEARCHING		; print "Searching..."		[F5AF]
00F549  2               A_F549:					;				[F549]
00F549  2  A5 B7        	lda	FNLEN			; get filename length
00F54B  2  F0 09        	beq	A_F556			;.
00F54D  2               
00F54D  2  20 EA F7     	jsr	FindTapeHeader		; find specific tape header	[F7EA]
00F550  2  90 0B        	bcc	A_F55D			; if no error continue
00F552  2               
00F552  2  F0 5A        	beq	A_F5AE			; exit if ??
00F554  2               
00F554  2  B0 DA        	bcs	A_F530			; file not found, branch always
00F556  2               
00F556  2               A_F556:					;				[F556]
00F556  2  20 2C F7     	jsr	FindTapeHdr2		; find tape header, exit with header in
00F559  2               					; buffer			[F72C]
00F559  2  F0 53        	beq	A_F5AE			; exit if ??
00F55B  2               
00F55B  2  B0 D3        	bcs	A_F530			;.
00F55D  2               A_F55D:					;				[F55D]
00F55D  2  A5 90        	lda	STATUS			; get the serial status byte
00F55F  2  29 10        	and	#$10			; mask 000x 0000, read error
00F561  2  38           	sec				; flag fail
00F562  2  D0 4A        	bne	A_F5AE			; if read error just exit
00F564  2               
00F564  2  E0 01        	cpx	#$01			;.
00F566  2  F0 11        	beq	A_F579			;.
00F568  2               
00F568  2  E0 03        	cpx	#$03			;.
00F56A  2  D0 DD        	bne	A_F549			;.
00F56C  2               
00F56C  2               A_F56C:					;				[F56C]
00F56C  2  A0 01        	ldy	#$01			;.
00F56E  2  B1 B2        	lda	(TapeBufPtr),Y		;.
00F570  2  85 C3        	sta	MEMUSS			;.
00F572  2               
00F572  2  C8           	iny				;.
00F573  2  B1 B2        	lda	(TapeBufPtr),Y		;.
00F575  2  85 C4        	sta	MEMUSS+1		;.
00F577  2  B0 04        	bcs	A_F57D			;.
00F579  2               
00F579  2               A_F579:					;				[F579]
00F579  2  A5 B9        	lda	SA			; get the secondary address
00F57B  2  D0 EF        	bne	A_F56C			;.
00F57D  2               
00F57D  2               A_F57D:					;				[F57D]
00F57D  2  A0 03        	ldy	#$03			;.
00F57F  2  B1 B2        	lda	(TapeBufPtr),Y		;.
00F581  2  A0 01        	ldy	#$01			;.
00F583  2  F1 B2        	sbc	(TapeBufPtr),Y		;.
00F585  2  AA           	tax				;.
00F586  2               
00F586  2  A0 04        	ldy	#$04			;.
00F588  2  B1 B2        	lda	(TapeBufPtr),Y		;.
00F58A  2  A0 02        	ldy	#$02			;.
00F58C  2  F1 B2        	sbc	(TapeBufPtr),Y		;.
00F58E  2  A8           	tay				;.
00F58F  2               
00F58F  2  18           	clc				;.
00F590  2  8A           	txa				;.
00F591  2  65 C3        	adc	MEMUSS			;.
00F593  2  85 AE        	sta	EAL			;.
00F595  2               
00F595  2  98           	tya				;.
00F596  2  65 C4        	adc	MEMUSS+1		;.
00F598  2  85 AF        	sta	EAL+1			;.
00F59A  2               
00F59A  2  A5 C3        	lda	MEMUSS			;.
00F59C  2  85 C1        	sta	STAL			; set I/O start addresses LB
00F59E  2               
00F59E  2  A5 C4        	lda	MEMUSS+1		;.
00F5A0  2  85 C2        	sta	STAL+1			; set I/O start addresses HB
00F5A2  2               
00F5A2  2  20 D2 F5     	jsr	LoadVerifying		; display "LOADING" or "VERIFYING"
00F5A5  2               					;				[F5D2]
00F5A5  2  20 4A F8     	jsr	ReadTape		; do the tape read		[F84A]
00F5A8  2               
00F5A8  2  24           .byte	$24				; keep the error flag in Carry
00F5A9  2               A_F5A9:					;				[F5A9]
00F5A9  2  18           	clc				; flag ok
00F5AA  2               
00F5AA  2  A6 AE        	ldx	EAL			; get the LOAD end pointer LB
00F5AC  2  A4 AF        	ldy	EAL+1			; get the LOAD end pointer HB
00F5AE  2               A_F5AE:					;				[F5AE]
00F5AE  2  60           	rts
00F5AF  2               
00F5AF  2               
00F5AF  2               ;******************************************************************************
00F5AF  2               ;
00F5AF  2               ; print "Searching..."
00F5AF  2               ;
00F5AF  2               PrtSEARCHING:				;				[F5AF]
00F5AF  2  A5 9D        	lda	MSGFLG			; get message mode flag
00F5B1  2  10 1E        	bpl	A_F5D1			; exit if control messages off
00F5B3  2               
00F5B3  2  A0 0C        	ldy	#TxtSEARCHING-TxtIO_ERROR ; index to "SEARCHING "
00F5B5  2  20 2F F1     	jsr	DisplayIoMsg2		; display kernel I/O message	[F12F]
00F5B8  2               
00F5B8  2  A5 B7        	lda	FNLEN			; get filename length
00F5BA  2  F0 15        	beq	A_F5D1			; exit if null name
00F5BC  2               
00F5BC  2  A0 17        	ldy	#TxtFOR-TxtIO_ERROR	; else index to "FOR "
00F5BE  2  20 2F F1     	jsr	DisplayIoMsg2		; display kernel I/O message	[F12F]
00F5C1  2               
00F5C1  2               
00F5C1  2               ;******************************************************************************
00F5C1  2               ;
00F5C1  2               ; print filename
00F5C1  2               ;
00F5C1  2               PrintFileName:				;				[F5C1]
00F5C1  2  A4 B7        	ldy	FNLEN			; get filename length
00F5C3  2  F0 0C        	beq	A_F5D1			; exit if null filename
00F5C5  2               
00F5C5  2  A0 00        	ldy	#$00			; clear index
00F5C7  2               A_F5C7:					;				[F5C7]
00F5C7  2  B1 BB        	lda	(FNADR),Y		; get filename byte
00F5C9  2  20 D2 FF     	jsr	OutByteChan		; output character to channel	[FFD2]
00F5CC  2  C8           	iny				; increment index
00F5CD  2  C4 B7        	cpy	FNLEN			; compare with filename length
00F5CF  2  D0 F6        	bne	A_F5C7			; loop if more to do
00F5D1  2               
00F5D1  2               A_F5D1:					;				[F5D1]
00F5D1  2  60           	rts
00F5D2  2               
00F5D2  2               
00F5D2  2               ;******************************************************************************
00F5D2  2               ;
00F5D2  2               ; display "LOADING" or "VERIFYING"
00F5D2  2               ;
00F5D2  2               LoadVerifying:				;				[F5D2]
00F5D2  2  A0 49        	ldy	#TxtLOADING-TxtIO_ERROR	; point to "LOADING"
00F5D4  2               
00F5D4  2  A5 93        	lda	LoadVerify2		; get load/verify flag
00F5D6  2  F0 02        	beq	A_F5DA			; branch if load
00F5D8  2               
00F5D8  2  A0 59        	ldy	#TxtVERIFYING-TxtIO_ERROR ; point to "VERIFYING"
00F5DA  2               A_F5DA:					;				[F5DA]
00F5DA  2  4C 2B F1     	jmp	DisplayIoMsg		; display kernel I/O message if in
00F5DD  2               					; direct mode and return	[F12B]
00F5DD  2               
00F5DD  2               ;******************************************************************************
00F5DD  2               ;
00F5DD  2               ; save RAM to device, A = index to start address, XY = end address low/high
00F5DD  2               ;
00F5DD  2               ; this routine saves a section of memory. Memory is saved from an indirect
00F5DD  2               ; address on page 0 specified by A, to the address stored in XY, to a logical
00F5DD  2               ; file. The SETLFS, SetAddresses, and SETNAM, SetFileName, routines must be
00F5DD  2               ; used before calling this routine. However, a filename is not required to
00F5DD  2               ; SAVE to device 1, the cassette. Any attempt to save to other devices without
00F5DD  2               ; using a filename results in an error.
00F5DD  2               ;
00F5DD  2               ; NOTE: device 0, the keyboard, and device 3, the screen, cannot be SAVEd to.
00F5DD  2               ; If the attempt is made, an error will occur, and the SAVE stopped.
00F5DD  2               ;
00F5DD  2               SaveRamToDev2:				;				[F5DD]
00F5DD  2  86 AE        	stx	EAL			; save end address LB
00F5DF  2  84 AF        	sty	EAL+1			; save end address HB
00F5E1  2               
00F5E1  2  AA           	tax				; copy index to start pointer
00F5E2  2               
00F5E2  2  B5 00        	lda	D6510+0,X		; get start address LB
00F5E4  2  85 C1        	sta	STAL			; set I/O start addresses LB
00F5E6  2               
00F5E6  2  B5 01        	lda	D6510+1,X		; get start address HB
00F5E8  2  85 C2        	sta	STAL+1			; set I/O start addresses HB
00F5EA  2               
00F5EA  2  6C 32 03     	jmp	(ISAVE)			; go save, usually points to $F5ED
00F5ED  2               
00F5ED  2               
00F5ED  2               ;******************************************************************************
00F5ED  2               ;
00F5ED  2               ; save
00F5ED  2               ;
00F5ED  2               SaveRamToDev22:				;				[F5ED]
00F5ED  2  A5 BA        	lda	FA			; get the device number, keyboard?
00F5EF  2  D0 03        	bne	A_F5F4			; no, ->
00F5F1  2               
00F5F1  2               ; else ..
00F5F1  2               A_F5F1:					;				[F5F1]
00F5F1  2  4C 13 F7     	jmp	IllegalDevNum		; else do 'illegal device number' and
00F5F4  2               					; return			[F713]
00F5F4  2               A_F5F4:					;				[F5F4]
00F5F4  2  C9 03        	cmp	#$03			; compare device number with screen
00F5F6  2  F0 F9        	beq	A_F5F1			; if screen do illegal device number
00F5F8  2               					; and return
00F5F8  2  90 5F        	bcc	SaveRamToTape		; branch if < screen
00F5FA  2               
00F5FA  2               ; is greater than screen so is serial bus
00F5FA  2  A9 61        	lda	#$61			; set secondary address to $01 when a
00F5FC  2               					; secondary address is to be sent to a
00F5FC  2               					; device on the serial bus the address
00F5FC  2               					; must first be ORed with $60
00F5FC  2  85 B9        	sta	SA			; save the secondary address
00F5FE  2               
00F5FE  2  A4 B7        	ldy	FNLEN			; get the filename length
00F600  2  D0 03        	bne	A_F605			; if filename not null continue
00F602  2               
00F602  2  4C 10 F7     	jmp	MissingFileNam		; else do 'missing filename' error and
00F605  2               					; return			[F710]
00F605  2               A_F605:					;				[F605]
00F605  2  20 D5 F3     	jsr	SndSecAdrFilNm		; send secondary address and filename
00F608  2               					;				[F3D5]
00F608  2  20 8F F6     	jsr	PrtSAVING		; print saving <filename>	[F68F]
00F60B  2               SaveRamToDev22b:
00F60B  2  A5 BA        	lda	FA			; get the device number
00F60D  2  20 0C ED     	jsr	CmdLISTEN2		; command devices on the serial bus to
00F610  2               					; LISTEN			[ED0C]
00F610  2               
00F610  2  A5 B9        	lda	SA			; get the secondary address
00F612  2  20 B9 ED     	jsr	SAafterLISTEN2		; send secondary address after LISTEN
00F615  2               					;				[EDB9]
00F615  2  A0 00        	ldy	#$00			; clear index
00F617  2  20 8E FB     	jsr	CopyIoAdr2Buf		; copy I/O start address to buffer
00F61A  2               					; address			[FB8E]
00F61A  2  A5 AC        	lda	SAL			; get buffer address LB
00F61C  2  20 DD ED     	jsr	IecByteOut2		; output byte to serial bus	[EDDD]
00F61F  2               
00F61F  2  A5 AD        	lda	SAL+1			; get buffer address HB
00F621  2  20 DD ED     	jsr	IecByteOut2		; output byte to serial bus	[EDDD]
00F624  2               A_F624:					;				[F624]
00F624  2  20 D1 FC     	jsr	ChkRdWrPtr		; check read/write pointer, return
00F627  2               					; Cb = 1 if pointer >= end	[FCD1]
00F627  2  B0 16        	bcs	A_F63F			; go do UNLISTEN if at end
00F629  2               
00F629  2  B1 AC        	lda	(SAL),Y			; get byte from buffer
00F62B  2  20 DD ED     	jsr	IecByteOut2		; output byte to serial bus	[EDDD]
00F62E  2               
00F62E  2  20 E1 FF     	jsr	ScanStopKey		; scan stop key			[FFE1]
00F631  2  D0 07        	bne	A_F63A			; if stop not pressed go increment
00F633  2               					; pointer and loop for next
00F633  2               
00F633  2               ; close the serial bus device and flag stop
00F633  2               CloseIecBus:				;				[F633]
00F633  2  20 42 F6     	jsr	CloseIecDevice		; close serial bus device	[F642]
00F636  2               
00F636  2  A9 00        	lda	#$00			;.
00F638  2  38           	sec				; flag stop
00F639  2  60           	rts
00F63A  2               
00F63A  2               
00F63A  2               A_F63A:					;				[F63A]
00F63A  2  20 DB FC     	jsr	IncRdWrPtr		; increment read/write pointer	[FCDB]
00F63D  2  D0 E5        	bne	A_F624			; loop, branch always
00F63F  2               A_F63F:					;				[F63F]
00F63F  2  20 FE ED     	jsr	IecUNLISTEN2		; command serial bus to UNLISTEN [EDFE]
00F642  2               
00F642  2               ; close serial bus device
00F642  2               CloseIecDevice:				;				[F642]
00F642  2  24 B9        	bit	SA			; test the secondary address
00F644  2  30 11        	bmi	A_F657			; if already closed just exit
00F646  2               
00F646  2  A5 BA        	lda	FA			; get the device number
00F648  2  20 0C ED     	jsr	CmdLISTEN2		; command devices on the serial bus to
00F64B  2               					; LISTEN			[ED0C]
00F64B  2               
00F64B  2  A5 B9        	lda	SA			; get the secondary address
00F64D  2  29 EF        	and	#$EF			; mask the channel number
00F64F  2  09 E0        	ora	#$E0			; OR with the CLOSE command
00F651  2  20 B9 ED     	jsr	SAafterLISTEN2		; send secondary address after LISTEN
00F654  2               					;				[EDB9]
00F654  2               DoUNLISTEN:				;				[F654]
00F654  2  20 FE ED     	jsr	IecUNLISTEN2		; command serial bus to UNLISTEN [EDFE]
00F657  2               A_F657:					;				[F657]
00F657  2  18           	clc				; flag ok
00F658  2  60           	rts
00F659  2               
00F659  2               SaveRamToTape:				;				[F659]
00F659  2  4A           	lsr				; bit 0 is set, = tape?
00F65A  2  B0 03        	bcs	A_F65F			; yes, -> OK
00F65C  2               
00F65C  2  4C 13 F7     	jmp	IllegalDevNum		; else do 'illegal device number' and
00F65F  2               					; return			[F713]
00F65F  2               A_F65F:					;				[F65F]
00F65F  2  20 D0 F7     	jsr	TapeBufPtr2XY		; get tape buffer start pointer in XY
00F662  2               					;				[F7D0]
00F662  2  90 8D        	bcc	A_F5F1			; if < $0200 do illegal device number
00F664  2               					; and return
00F664  2  20 38 F8     	jsr	WaitForPlayRec		; wait for PLAY/RECORD		[F838]
00F667  2  B0 25        	bcs	A_F68E			; exit if STOP was pressed
00F669  2               
00F669  2  20 8F F6     	jsr	PrtSAVING		; print saving <filename>	[F68F]
00F66C  2               
00F66C  2  A2 03        	ldx	#$03			; set header for a non relocatable
00F66E  2               					; program file
00F66E  2  A5 B9        	lda	SA			; get the secondary address
00F670  2  29 01        	and	#$01			; mask non relocatable bit
00F672  2  D0 02        	bne	A_F676			; if non relocatable program go ??
00F674  2               
00F674  2  A2 01        	ldx	#$01			; else set header for a relocatable
00F676  2               					; program file
00F676  2               A_F676:					;				[F676]
00F676  2  8A           	txa				; copy header type to A
00F677  2  20 6A F7     	jsr	WriteTapeHdr		; write tape header		[F76A]
00F67A  2  B0 12        	bcs	A_F68E			; exit if error
00F67C  2               
00F67C  2  20 67 F8     	jsr	WriteTape20Cyc		; do tape write, 20 cycle count	[F867]
00F67F  2  B0 0D        	bcs	A_F68E			; exit if error
00F681  2               
00F681  2  A5 B9        	lda	SA			; get the secondary address
00F683  2  29 02        	and	#$02			; mask end of tape flag
00F685  2  F0 06        	beq	A_F68D			; if not end of tape go ??
00F687  2               
00F687  2  A9 05        	lda	#$05			; else set logical end of the tape
00F689  2  20 6A F7     	jsr	WriteTapeHdr		; write tape header		[F76A]
00F68C  2               
00F68C  2  24           .byte	$24				; makes next line BIT LASTPT+1 so Cb is
00F68D  2               					; not changed
00F68D  2               A_F68D:					;				[F68D]
00F68D  2  18           	clc				; flag ok
00F68E  2               A_F68E:					;				[F68E]
00F68E  2  60           	rts
00F68F  2               
00F68F  2               
00F68F  2               ;******************************************************************************
00F68F  2               ;
00F68F  2               ; print saving <filename>
00F68F  2               ;
00F68F  2               PrtSAVING:				;				[F68F]
00F68F  2  A5 9D        	lda	MSGFLG			; get message mode flag
00F691  2  10 FB        	bpl	A_F68E			; exit if control messages off
00F693  2               
00F693  2  A0 51        	ldy	#TxtSAVING-TxtIO_ERROR	; index to "SAVING "
00F695  2  20 2F F1     	jsr	DisplayIoMsg2		; display kernel I/O message	[F12F]
00F698  2               
00F698  2  4C C1 F5     	jmp	PrintFileName		; print filename and return	[F5C1]
00F69B  2               
00F69B  2               
00F69B  2               ;******************************************************************************
00F69B  2               ;
00F69B  2               ; increment the real time clock
00F69B  2               ;
00F69B  2               ; this routine updates the system clock. Normally this routine is called by the
00F69B  2               ; normal KERNAL interrupt routine every 1/60th of a second. If the user program
00F69B  2               ; processes its own interrupts this routine must be called to update the time.
00F69B  2               ; Also, the STOP key routine must be called if the stop key is to remain
00F69B  2               ; functional.
00F69B  2               ;
00F69B  2               IncrClock2:				;				[F69B]
00F69B  2  A2 00        	ldx	#$00			; clear X
00F69D  2               
00F69D  2  E6 A2        	inc	TimeBytes+2		; increment the jiffy clock LB
00F69F  2  D0 06        	bne	A_F6A7			; if no rollover ??
00F6A1  2               
00F6A1  2  E6 A1        	inc	TimeBytes+1		; increment the jiffy clock mid byte
00F6A3  2  D0 02        	bne	A_F6A7			; branch if no rollover
00F6A5  2               
00F6A5  2  E6 A0        	inc	TimeBytes		; increment the jiffy clock HB
00F6A7  2               
00F6A7  2               ; now subtract a days worth of jiffies from current count and remember only the
00F6A7  2               ; Cb result
00F6A7  2               A_F6A7:					;				[F6A7]
00F6A7  2  38           	sec				; set carry for subtract
00F6A8  2  A5 A2        	lda	TimeBytes+2		; get the jiffy clock LB
00F6AA  2  E9 01        	sbc	#$01			; subtract $4F1A01 LB
00F6AC  2               
00F6AC  2  A5 A1        	lda	TimeBytes+1		; get the jiffy clock mid byte
00F6AE  2  E9 1A        	sbc	#$1A			; subtract $4F1A01 mid byte
00F6B0  2               
00F6B0  2  A5 A0        	lda	TimeBytes		; get the jiffy clock HB
00F6B2  2  E9 4F        	sbc	#$4F			; subtract $4F1A01 HB
00F6B4  2  90 06        	bcc	IncrClock22		; if less than $4F1A01 jiffies skip the
00F6B6  2               					; clock reset
00F6B6  2               ; else ..
00F6B6  2  86 A0        	stx	TimeBytes		; clear the jiffy clock HB
00F6B8  2  86 A1        	stx	TimeBytes+1		; clear the jiffy clock mid byte
00F6BA  2  86 A2        	stx	TimeBytes+2		; clear the jiffy clock LB
00F6BC  2               					; this is wrong, there are $4F1A00
00F6BC  2               					; jiffies in a day so the reset to zero
00F6BC  2               					; should occur when the value reaches
00F6BC  2               					; $4F1A00 and not $4F1A01. This would
00F6BC  2               					; give an extra jiffy every day and a
00F6BC  2               					; possible TI value of 24:00:00
00F6BC  2               IncrClock22:				;				[F6BC]
00F6BC  2  AD 01 DC     	lda	CIA1DRB			; read CIA 1 DRB, keyboard row port
00F6BF  2  CD 01 DC     	cmp	CIA1DRB			; compare it with itself
00F6C2  2  D0 F8        	bne	IncrClock22		; loop if changing
00F6C4  2               
00F6C4  2  AA           	tax				; <STOP> key pressed?
00F6C5  2  30 13        	bmi	A_F6DA			; no, -> skip rest
00F6C7  2               
00F6C7  2  A2 BD        	ldx	#$BD			; set c6
00F6C9  2  8E 00 DC     	stx	CIA1DRA			; save CIA 1 DRA, keyboard column drive
00F6CC  2               
00F6CC  2               A_F6CC:					;				[F6CC]
00F6CC  2  AE 01 DC     	ldx	CIA1DRB			; read CIA 1 DRB, keyboard row port
00F6CF  2  EC 01 DC     	cpx	CIA1DRB			; compare it with itself
00F6D2  2  D0 F8        	bne	A_F6CC			; loop if changing
00F6D4  2               
00F6D4  2  8D 00 DC     	sta	CIA1DRA			; save CIA 1 DRA, keyboard column drive
00F6D7  2               
00F6D7  2  E8           	inx				;.
00F6D8  2  D0 02        	bne	A_F6DC			;.
00F6DA  2               
00F6DA  2               A_F6DA:					;				[F6DA]
00F6DA  2  85 91        	sta	StopKey			; save the stop key column
00F6DC  2               A_F6DC:					;				[F6DC]
00F6DC  2  60           	rts
00F6DD  2               
00F6DD  2               
00F6DD  2               ;******************************************************************************
00F6DD  2               ;
00F6DD  2               ; read the real time clock
00F6DD  2               ;
00F6DD  2               ; this routine returns the time, in jiffies, in AXY. The accumulator contains
00F6DD  2               ; the most significant byte.
00F6DD  2               ;
00F6DD  2               ReadClock2:				;				[F6DD]
00F6DD  2  78           	sei				; disable the interrupts
00F6DE  2               
00F6DE  2  A5 A2        	lda	TimeBytes+2		; get the jiffy clock LB
00F6E0  2  A6 A1        	ldx	TimeBytes+1		; get the jiffy clock mid byte
00F6E2  2  A4 A0        	ldy	TimeBytes		; get the jiffy clock HB
00F6E4  2               
00F6E4  2               
00F6E4  2               ;******************************************************************************
00F6E4  2               ;
00F6E4  2               ; set the real time clock
00F6E4  2               ;
00F6E4  2               ; the system clock is maintained by an interrupt routine that updates the clock
00F6E4  2               ; every 1/60th of a second. The clock is three bytes long which gives the
00F6E4  2               ; capability to count from zero up to 5,184,000 jiffies - 24 hours plus one
00F6E4  2               ; jiffy. At that point the clock resets to zero. Before calling this routine to
00F6E4  2               ; set the clock the new time, in jiffies, should be in YXA, the accumulator
00F6E4  2               ; containing the most significant byte.
00F6E4  2               ;
00F6E4  2               SetClock2:				;				[F6E4]
00F6E4  2  78           	sei				; disable the interrupts
00F6E5  2               
00F6E5  2  85 A2        	sta	TimeBytes+2		; save the jiffy clock LB
00F6E7  2  86 A1        	stx	TimeBytes+1		; save the jiffy clock mid byte
00F6E9  2  84 A0        	sty	TimeBytes		; save the jiffy clock HB
00F6EB  2               
00F6EB  2  58           	cli				; enable the interrupts
00F6EC  2               
00F6EC  2  60           	rts
00F6ED  2               
00F6ED  2               
00F6ED  2               ;******************************************************************************
00F6ED  2               ;
00F6ED  2               ; scan the stop key, return Zb = 1 = [STOP]
00F6ED  2               ;
00F6ED  2               ; if the STOP key on the keyboard is pressed when this routine is called the Z
00F6ED  2               ; flag will be set. All other flags remain unchanged. If the STOP key is not
00F6ED  2               ; pressed then the accumulator will contain a byte representing the last row of
00F6ED  2               ; the keyboard scan.
00F6ED  2               ;
00F6ED  2               ; The user can also check for certain other keys this way.
00F6ED  2               ;
00F6ED  2               Scan4StopKey:				;				[F6ED]
00F6ED  2  A5 91        	lda	StopKey			; read the stop key column
00F6EF  2  C9 7F        	cmp	#$7F			; compare with [STP] down
00F6F1  2  D0 07        	bne	A_F6FA			; if not [STOP] or not just [STOP] exit
00F6F3  2               
00F6F3  2               ; just [STOP] was pressed
00F6F3  2  08           	php				; save status
00F6F4  2               
00F6F4  2  20 CC FF     	jsr	CloseIoChannls		; close input and output channels [FFCC]
00F6F7  2  85 C6        	sta	NDX			; save the keyboard buffer index
00F6F9  2               
00F6F9  2  28           	plp				; restore status
00F6FA  2               
00F6FA  2               A_F6FA:					;				[F6FA]
00F6FA  2  60           	rts
00F6FB  2               
00F6FB  2               
00F6FB  2               ;******************************************************************************
00F6FB  2               ;
00F6FB  2               ; file error messages
00F6FB  2               ;
00F6FB  2               TooManyFilesErr:			;				[F6FB]
00F6FB  2  A9 01        	lda	#$01			; 'too many files' error
00F6FD  2  2C           .byte	$2C				; makes next line BIT $02A9
00F6FE  2               
00F6FE  2               FileAlreadyOpen:			;				[F6FE]
00F6FE  2  A9 02        	lda	#$02			; 'file already open' error
00F700  2  2C           .byte	$2C				; makes next line BIT $03A9
00F701  2               
00F701  2               FileNotOpenErr:				;				[F701]
00F701  2  A9 03        	lda	#$03			; 'file not open' error
00F703  2  2C           .byte	$2C				; makes next line BIT $04A9
00F704  2               
00F704  2               FileNotFound:				;				[F704]
00F704  2  A9 04        	lda	#$04			; 'file not found' error
00F706  2  2C           .byte	$2C				; makes next line BIT $05A9
00F707  2               
00F707  2               DevNotPresent:				;				[F707]
00F707  2  A9 05        	lda	#$05			; 'device not present' error
00F709  2  2C           .byte	$2C				; makes next line BIT $06A9
00F70A  2               
00F70A  2               NoInputFileErr:				;				[F70A]
00F70A  2  A9 06        	lda	#$06			; 'not input file' error
00F70C  2  2C           .byte	$2C				; makes next line BIT $07A9
00F70D  2               
00F70D  2               NoOutpFileErr:				;				[F70D]
00F70D  2  A9 07        	lda	#$07			; 'not output file' error
00F70F  2  2C           .byte	$2C				; makes next line BIT $08A9
00F710  2               
00F710  2               MissingFileNam:				;				[F710]
00F710  2  A9 08        	lda	#$08			; 'missing filename' error
00F712  2  2C           .byte	$2C				; makes next line BIT $09A9
00F713  2               
00F713  2               IllegalDevNum:				;				[F713]
00F713  2  A9 09        	lda	#$09			; do 'illegal device number'
00F715  2  48           	pha				; save the error #
00F716  2               
00F716  2  20 CC FF     	jsr	CloseIoChannls		; close input and output channels [FFCC]
00F719  2               
00F719  2  A0 00        	ldy	#TxtIO_ERROR-TxtIO_ERROR	; index to "I/O ERROR #"
00F71B  2               
00F71B  2  24 9D        	bit	MSGFLG			; test message mode flag
00F71D  2  50 0A        	bvc	A_F729			; exit if kernal messages off
00F71F  2               
00F71F  2  20 2F F1     	jsr	DisplayIoMsg2		; display kernel I/O message	[F12F]
00F722  2               
00F722  2  68           	pla				; restore error #
00F723  2  48           	pha				; copy error #
00F724  2               
00F724  2  09 30        	ora	#'0'			; convert to ASCII
00F726  2  20 D2 FF     	jsr	OutByteChan		; output character to channel	[FFD2]
00F729  2               A_F729:					;				[F729]
00F729  2  68           	pla				; pull error number
00F72A  2  38           	sec				; flag error
00F72B  2               
00F72B  2  60           	rts
00F72C  2               
00F72C  2               
00F72C  2               ;******************************************************************************
00F72C  2               ;
00F72C  2               ; find the tape header, exit with header in buffer
00F72C  2               ;
00F72C  2               FindTapeHdr2:				;				[F72C]
00F72C  2  A5 93        	lda	LoadVerify2		; get load/verify flag
00F72E  2  48           	pha				; save load/verify flag
00F72F  2               
00F72F  2  20 41 F8     	jsr	InitTapeRead		; initiate tape read		[F841]
00F732  2               
00F732  2  68           	pla				; restore load/verify flag
00F733  2  85 93        	sta	LoadVerify2		; save load/verify flag
00F735  2  B0 32        	bcs	A_F769			; exit if error
00F737  2               
00F737  2  A0 00        	ldy	#$00			; clear the index
00F739  2  B1 B2        	lda	(TapeBufPtr),Y		; read first byte from tape buffer
00F73B  2  C9 05        	cmp	#$05			; compare with logical end of the tape
00F73D  2  F0 2A        	beq	A_F769			; if end of the tape exit
00F73F  2               
00F73F  2  C9 01        	cmp	#$01			; compare with header for a relocatable
00F741  2               					; program file
00F741  2  F0 08        	beq	A_F74B			; if program file header go ??
00F743  2               
00F743  2  C9 03        	cmp	#$03			; compare with header for a non
00F745  2               					; relocatable program file
00F745  2  F0 04        	beq	A_F74B			; if program file header go  ??
00F747  2               
00F747  2  C9 04        	cmp	#$04			; compare with data file header
00F749  2  D0 E1        	bne	FindTapeHdr2		; if data file loop to find tape header
00F74B  2               
00F74B  2               ; was a program file header
00F74B  2               A_F74B:					;				[F74B]
00F74B  2  AA           	tax				; copy header type
00F74C  2  24 9D        	bit	MSGFLG			; get message mode flag
00F74E  2  10 17        	bpl	A_F767			; exit if control messages off
00F750  2               
00F750  2  A0 63        	ldy	#TxtFOUND-TxtIO_ERROR	; index to "FOUND "
00F752  2  20 2F F1     	jsr	DisplayIoMsg2		; display kernel I/O message	[F12F]
00F755  2               
00F755  2  A0 05        	ldy	#$05			; index to the tape filename
00F757  2               A_F757:					;				[F757]
00F757  2  B1 B2        	lda	(TapeBufPtr),Y		; get byte from tape buffer
00F759  2  20 D2 FF     	jsr	OutByteChan		; output character to channel	[FFD2]
00F75C  2               
00F75C  2  C8           	iny				; increment the index
00F75D  2  C0 15        	cpy	#$15			; compare it with end+1
00F75F  2  D0 F6        	bne	A_F757			; loop if more to do
00F761  2               A_F761:					;				[F761]
00F761  2               .if KERNAL = 1
00F761  2               	lda	StopKey
00F761  2               	cmp	#$FF
00F761  2               	beq	A_F761
00F761  2               .endif
00F761  2               
00F761  2               .if KERNAL = 2 || KERNAL = 3
00F761  2  A5 A1        	lda	TimeBytes+1		; get the jiffy clock mid byte
00F763  2  20 E0 E4     	jsr	Wait8Seconds		; wait ~8.5 seconds for any key from
00F766  2               					; the STOP key column		[E4E0]
00F766  2  EA           	nop				; waste cycles
00F767  2               .endif
00F767  2               
00F767  2               A_F767:					;				[F767]
00F767  2  18           	clc				; flag no error
00F768  2               
00F768  2  88           	dey				; decrement the index
00F769  2               A_F769:					;				[F769]
00F769  2  60           	rts
00F76A  2               
00F76A  2               
00F76A  2               ;******************************************************************************
00F76A  2               ;
00F76A  2               ; write the tape header
00F76A  2               ;
00F76A  2               WriteTapeHdr:				;				[F76A]
00F76A  2  85 9E        	sta	PTR1			; save header type
00F76C  2               
00F76C  2  20 D0 F7     	jsr	TapeBufPtr2XY		; get tape buffer start pointer in XY
00F76F  2               					;				[F7D0]
00F76F  2  90 5E        	bcc	A_F7CF			; if < $0200 just exit ??
00F771  2               
00F771  2  A5 C2        	lda	STAL+1			; get I/O start address HB
00F773  2  48           	pha				; save it
00F774  2               
00F774  2  A5 C1        	lda	STAL			; get I/O start address LB
00F776  2  48           	pha				; save it
00F777  2               
00F777  2  A5 AF        	lda	EAL+1			; get tape end address HB
00F779  2  48           	pha				; save it
00F77A  2               
00F77A  2  A5 AE        	lda	EAL			; get tape end address LB
00F77C  2  48           	pha				; save it
00F77D  2               
00F77D  2  A0 BF        	ldy	#$BF			; index to header end
00F77F  2  A9 20        	lda	#' '			; clear byte, [SPACE]
00F781  2               A_F781:					;				[F781]
00F781  2  91 B2        	sta	(TapeBufPtr),Y		; clear header byte
00F783  2               
00F783  2  88           	dey				; decrement index
00F784  2  D0 FB        	bne	A_F781			; loop if more to do
00F786  2               
00F786  2  A5 9E        	lda	PTR1			; get the header type back
00F788  2  91 B2        	sta	(TapeBufPtr),Y		; write it to header
00F78A  2               
00F78A  2  C8           	iny				; increment the index
00F78B  2  A5 C1        	lda	STAL			; get the I/O start address LB
00F78D  2  91 B2        	sta	(TapeBufPtr),Y		; write it to header
00F78F  2               
00F78F  2  C8           	iny				; increment the index
00F790  2  A5 C2        	lda	STAL+1			; get the I/O start address HB
00F792  2  91 B2        	sta	(TapeBufPtr),Y		; write it to header
00F794  2               
00F794  2  C8           	iny				; increment the index
00F795  2  A5 AE        	lda	EAL			; get the tape end address LB
00F797  2  91 B2        	sta	(TapeBufPtr),Y		; write it to header
00F799  2               
00F799  2  C8           	iny				; increment the index
00F79A  2  A5 AF        	lda	EAL+1			; get the tape end address HB
00F79C  2  91 B2        	sta	(TapeBufPtr),Y		; write it to header
00F79E  2               
00F79E  2  C8           	iny				; increment the index
00F79F  2  84 9F        	sty	PTR2			; save the index
00F7A1  2               
00F7A1  2  A0 00        	ldy	#$00			; clear Y
00F7A3  2  84 9E        	sty	PTR1			; clear the name index
00F7A5  2               A_F7A5:					;				[F7A5]
00F7A5  2  A4 9E        	ldy	PTR1			; get name index
00F7A7  2  C4 B7        	cpy	FNLEN			; compare with filename length
00F7A9  2  F0 0C        	beq	A_F7B7			; if all done exit the loop
00F7AB  2               
00F7AB  2  B1 BB        	lda	(FNADR),Y		; get filename byte
00F7AD  2  A4 9F        	ldy	PTR2			; get buffer index
00F7AF  2  91 B2        	sta	(TapeBufPtr),Y		; save filename byte to buffer
00F7B1  2               
00F7B1  2  E6 9E        	inc	PTR1			; increment filename index
00F7B3  2  E6 9F        	inc	PTR2			; increment tape buffer index
00F7B5  2  D0 EE        	bne	A_F7A5			; loop, branch always
00F7B7  2               
00F7B7  2               A_F7B7:					;				[F7B7]
00F7B7  2  20 D7 F7     	jsr	SetTapeBufStart		; set tape buffer start and end
00F7BA  2               					; pointers			[F7D7]
00F7BA  2  A9 69        	lda	#$69			; set write lead cycle count
00F7BC  2  85 AB        	sta	RIPRTY			; save write lead cycle count
00F7BE  2               
00F7BE  2  20 6B F8     	jsr	WriteTape20		; do tape write, no cycle count set
00F7C1  2               					;				[F86B]
00F7C1  2  A8           	tay				;.
00F7C2  2               
00F7C2  2  68           	pla				; pull tape end address LB
00F7C3  2  85 AE        	sta	EAL			; restore it
00F7C5  2               
00F7C5  2  68           	pla				; pull tape end address HB
00F7C6  2  85 AF        	sta	EAL+1			; restore it
00F7C8  2               
00F7C8  2  68           	pla				; pull I/O start addresses LB
00F7C9  2  85 C1        	sta	STAL			; restore it
00F7CB  2               
00F7CB  2  68           	pla				; pull I/O start addresses HB
00F7CC  2  85 C2        	sta	STAL+1			; restore it
00F7CE  2               
00F7CE  2  98           	tya				;.
00F7CF  2               A_F7CF:					;				[F7CF]
00F7CF  2  60           	rts
00F7D0  2               
00F7D0  2               
00F7D0  2               ;******************************************************************************
00F7D0  2               ;
00F7D0  2               ; get the tape buffer start pointer
00F7D0  2               ;
00F7D0  2               TapeBufPtr2XY:				;				[F7D0]
00F7D0  2  A6 B2        	ldx	TapeBufPtr		; get tape buffer start pointer LB
00F7D2  2               
00F7D2  2  A4 B3        	ldy	TapeBufPtr+1		; get tape buffer start pointer HB
00F7D4  2  C0 02        	cpy	#$02			; compare HB with $02xx
00F7D6  2  60           	rts
00F7D7  2               
00F7D7  2               
00F7D7  2               ;******************************************************************************
00F7D7  2               ;
00F7D7  2               ; set the tape buffer start and end pointers
00F7D7  2               ;
00F7D7  2               SetTapeBufStart:			;				[F7D7]
00F7D7  2  20 D0 F7     	jsr	TapeBufPtr2XY		; get tape buffer start pointer in XY
00F7DA  2               					;				[F7D0]
00F7DA  2  8A           	txa				; copy tape buffer start pointer LB
00F7DB  2  85 C1        	sta	STAL			; save as I/O address pointer LB
00F7DD  2               
00F7DD  2  18           	clc				; clear carry for add
00F7DE  2  69 C0        	adc	#$C0			; add buffer length LB
00F7E0  2  85 AE        	sta	EAL			; save tape buffer end pointer LB
00F7E2  2               
00F7E2  2  98           	tya				; copy tape buffer start pointer HB
00F7E3  2  85 C2        	sta	STAL+1			; save as I/O address pointer HB
00F7E5  2               
00F7E5  2  69 00        	adc	#$00			; add buffer length HB
00F7E7  2  85 AF        	sta	EAL+1			; save tape buffer end pointer HB
00F7E9  2               
00F7E9  2  60           	rts
00F7EA  2               
00F7EA  2               
00F7EA  2               ;******************************************************************************
00F7EA  2               ;
00F7EA  2               ; find specific tape header
00F7EA  2               ;
00F7EA  2               FindTapeHeader:				;				[F7EA]
00F7EA  2  20 2C F7     	jsr	FindTapeHdr2		; find tape header, exit with header in
00F7ED  2               					; buffer			[F72C]
00F7ED  2  B0 1D        	bcs	A_F80C			; just exit if error
00F7EF  2               
00F7EF  2  A0 05        	ldy	#$05			; index to name
00F7F1  2  84 9F        	sty	PTR2			; save as tape buffer index
00F7F3  2               
00F7F3  2  A0 00        	ldy	#$00			; clear Y
00F7F5  2  84 9E        	sty	PTR1			; save as name buffer index
00F7F7  2               A_F7F7:					;				[F7F7]
00F7F7  2  C4 B7        	cpy	FNLEN			; compare with filename length
00F7F9  2  F0 10        	beq	A_F80B			; ok exit if match
00F7FB  2               
00F7FB  2  B1 BB        	lda	(FNADR),Y		; get filename byte
00F7FD  2  A4 9F        	ldy	PTR2			; get index to tape buffer
00F7FF  2  D1 B2        	cmp	(TapeBufPtr),Y		; compare with tape header name byte
00F801  2  D0 E7        	bne	FindTapeHeader		; if no match go get next header
00F803  2               
00F803  2  E6 9E        	inc	PTR1			; else increment name buffer index
00F805  2  E6 9F        	inc	PTR2			; increment tape buffer index
00F807  2               
00F807  2  A4 9E        	ldy	PTR1			; get name buffer index
00F809  2  D0 EC        	bne	A_F7F7			; loop, branch always
00F80B  2               
00F80B  2               A_F80B:					;				[F80B]
00F80B  2  18           	clc				; flag ok
00F80C  2               A_F80C:					;				[F80C]
00F80C  2  60           	rts
00F80D  2               
00F80D  2               
00F80D  2               ;******************************************************************************
00F80D  2               ;
00F80D  2               ; bump tape pointer
00F80D  2               ;
00F80D  2               BumpTapePtr:				;				[F80D]
00F80D  2  20 D0 F7     	jsr	TapeBufPtr2XY		; get tape buffer start pointer in XY
00F810  2               					;				[F7D0]
00F810  2  E6 A6        	inc	BUFPNT			; increment tape buffer index
00F812  2               
00F812  2  A4 A6        	ldy	BUFPNT			; get tape buffer index
00F814  2  C0 C0        	cpy	#$C0			; compare with buffer length
00F816  2  60           	rts
00F817  2               
00F817  2               
00F817  2               ;******************************************************************************
00F817  2               ;
00F817  2               ; wait for PLAY
00F817  2               ;
00F817  2               WaitForPlayKey:				;				[F817]
00F817  2  20 2E F8     	jsr	ReadTapeSense		; return cassette sense in Zb	[F82E]
00F81A  2  F0 1A        	beq	A_F836			; if switch closed just exit
00F81C  2               
00F81C  2               ; cassette switch was open
00F81C  2  A0 1B        	ldy	#TxtPRESS_PLAY-TxtIO_ERROR;	index to "PRESS PLAY ON TAPE"
00F81E  2               A_F81E:					;				[F81E]
00F81E  2  20 2F F1     	jsr	DisplayIoMsg2		; display kernel I/O message	[F12F]
00F821  2               A_F821:					;				[F821]
00F821  2  20 D0 F8     	jsr	ScanStopKey0		; scan stop key and flag abort if
00F824  2               					; pressed			[F8D0]
00F824  2               					; note if STOP was pressed the return
00F824  2               					; is to the routine that called this
00F824  2               					; one and not here
00F824  2  20 2E F8     	jsr	ReadTapeSense		; return cassette sense in Zb	[F82E]
00F827  2  D0 F8        	bne	A_F821			; loop if the cassette switch is open
00F829  2               
00F829  2  A0 6A        	ldy	#TxtOK2-TxtIO_ERROR	; index to "OK"
00F82B  2  4C 2F F1     	jmp	DisplayIoMsg2		; display kernel I/O message and return
00F82E  2               					;				[F12F]
00F82E  2               
00F82E  2               
00F82E  2               ;******************************************************************************
00F82E  2               ;
00F82E  2               ; return cassette sense in Zb
00F82E  2               ;
00F82E  2               ReadTapeSense:				;				[F82E]
00F82E  2  A9 10        	lda	#$10			; set the mask for the cassette switch
00F830  2  24 01        	bit	P6510			; test the 6510 I/O port
00F832  2  D0 02        	bne	A_F836			; branch if cassette sense high
00F834  2               
00F834  2  24 01        	bit	P6510			; test the 6510 I/O port
00F836  2               A_F836:					;				[F836]
00F836  2  18           	clc				;.
00F837  2  60           	rts
00F838  2               
00F838  2               
00F838  2               ;******************************************************************************
00F838  2               ;
00F838  2               ; wait for PLAY/RECORD
00F838  2               ;
00F838  2               WaitForPlayRec:				;				[F838]
00F838  2  20 2E F8     	jsr	ReadTapeSense		; return the cassette sense in Zb [F82E]
00F83B  2  F0 F9        	beq	A_F836			; exit if switch closed
00F83D  2               
00F83D  2               ; cassette switch was open
00F83D  2  A0 2E        	ldy	#TxtPRESS_RECO-TxtIO_ERROR  ; index to "PRESS RECORD & PLAY ON
00F83F  2               					; TAPE"
00F83F  2  D0 DD        	bne	A_F81E			; display message and wait for switch,
00F841  2               					; branch always
00F841  2               
00F841  2               ;******************************************************************************
00F841  2               ;
00F841  2               ; initiate a tape read
00F841  2               ;
00F841  2               InitTapeRead:				;				[F841]
00F841  2  A9 00        	lda	#$00			; clear A
00F843  2  85 90        	sta	STATUS			; clear serial status byte
00F845  2  85 93        	sta	LoadVerify2		; clear the load/verify flag
00F847  2               
00F847  2  20 D7 F7     	jsr	SetTapeBufStart		; set the tape buffer start and end
00F84A  2               					; pointers			[F7D7]
00F84A  2               ReadTape:				;				[F84A]
00F84A  2  20 17 F8     	jsr	WaitForPlayKey		; wait for PLAY			[F817]
00F84D  2  B0 1F        	bcs	A_F86E			; exit if STOP was pressed, uses a
00F84F  2               					; further BCS at the target address to
00F84F  2               					; reach final target at ClrSavIrqAddr
00F84F  2  78           	sei				; disable interrupts
00F850  2               
00F850  2  A9 00        	lda	#$00			; clear A
00F852  2  85 AA        	sta	RIDATA			;.
00F854  2  85 B4        	sta	BITTS			;.
00F856  2  85 B0        	sta	CMPO			; clear tape timing constant min byte
00F858  2  85 9E        	sta	PTR1			; clear tape pass 1 error log/char buf
00F85A  2  85 9F        	sta	PTR2			; clear tape pass 2 error log corrected
00F85C  2  85 9C        	sta	DPSW			; clear byte received flag
00F85E  2               
00F85E  2  A9 90        	lda	#$90			; enable CA1 interrupt ??
00F860  2               
00F860  2  A2 0E        	ldx	#$0E			; set index for tape read vector
00F862  2  D0 11        	bne	A_F875			; go do tape read/write, branch always
00F864  2               
00F864  2               
00F864  2               ;******************************************************************************
00F864  2               ;
00F864  2               ; initiate a tape write
00F864  2               ;
00F864  2               InitTapeWrite:				;				[F864]
00F864  2  20 D7 F7     	jsr	SetTapeBufStart		; set tape buffer start and end
00F867  2               					; pointers			[F7D7]
00F867  2               
00F867  2               ; do tape write, 20 cycle count
00F867  2               WriteTape20Cyc:				;				[F867]
00F867  2  A9 14        	lda	#$14			; set write lead cycle count
00F869  2  85 AB        	sta	RIPRTY			; save write lead cycle count
00F86B  2               
00F86B  2               ; do tape write, no cycle count set
00F86B  2               WriteTape20:				;				[F86B]
00F86B  2  20 38 F8     	jsr	WaitForPlayRec		; wait for PLAY/RECORD		[F838]
00F86E  2               A_F86E:					;				[F86E]
00F86E  2  B0 6C        	bcs	ClrSavIrqAddr		; if STOPped clear save IRQ address and
00F870  2               					; exit
00F870  2  78           	sei				; disable interrupts
00F871  2               
00F871  2  A9 82        	lda	#$82			; enable ?? interrupt
00F873  2  A2 08        	ldx	#$08			; set index for tape write tape leader
00F875  2               					; vector
00F875  2               
00F875  2               ;******************************************************************************
00F875  2               ;
00F875  2               ; tape read/write
00F875  2               ;
00F875  2               A_F875:					;				[F875]
00F875  2  A0 7F        	ldy	#$7F			; disable all interrupts
00F877  2  8C 0D DC     	sty	CIA1IRQ			; save CIA 1 ICR, disable all interrupts
00F87A  2               
00F87A  2  8D 0D DC     	sta	CIA1IRQ			; save CIA 1 ICR, enable interrupts
00F87D  2               					; according to A
00F87D  2               ; check RS232 bus idle
00F87D  2  AD 0E DC     	lda	CIA1CTR1		; read CIA 1 CRA
00F880  2  09 19        	ora	#$19			; load timer B, timer B single shot,
00F882  2               					; start timer B
00F882  2  8D 0F DC     	sta	CIA1CTR2		; save CIA 1 CRB
00F885  2               
00F885  2  29 91        	and	#$91			; mask x00x 000x, TOD clock, load timer
00F887  2               					; A, start timer A
00F887  2  8D A2 02     	sta	Copy6522CRB		; save CIA 1 CRB shadow copy
00F88A  2               
00F88A  2  20 A4 F0     	jsr	IsRS232Idle		;.				[F0A4]
00F88D  2               
00F88D  2  AD 11 D0     	lda	VICCTR1			; read the vertical fine scroll and
00F890  2               					; control register
00F890  2  29 EF        	and	#$EF			; blank the screen
00F892  2  8D 11 D0     	sta	VICCTR1			; save the vertical fine scroll and
00F895  2               					; control register
00F895  2  AD 14 03     	lda	CINV			; get IRQ vector LB
00F898  2  8D 9F 02     	sta	IRQTMP			; save IRQ vector LB
00F89B  2               
00F89B  2  AD 15 03     	lda	CINV+1			; get IRQ vector HB
00F89E  2  8D A0 02     	sta	IRQTMP+1		; save IRQ vector HB
00F8A1  2               
00F8A1  2  20 BD FC     	jsr	SetTapeVector		; set the tape vector		[FCBD]
00F8A4  2               
00F8A4  2  A9 02        	lda	#$02			; set copies count. First copy is load
00F8A6  2               					; copy, the second copy is verify copy
00F8A6  2  85 BE        	sta	FSBLK			; save copies count
00F8A8  2               
00F8A8  2  20 97 FB     	jsr	SetCounter		; new tape byte setup		[FB97]
00F8AB  2               
00F8AB  2  A5 01        	lda	P6510			; read the 6510 I/O port
00F8AD  2  29 1F        	and	#$1F			; mask 000x, cassette motor on ??
00F8AF  2  85 01        	sta	P6510			; save the 6510 I/O port
00F8B1  2  85 C0        	sta	CAS1			; set the tape motor interlock
00F8B3  2               
00F8B3  2               ; 326656 cycle delay, allow tape motor speed to stabilise
00F8B3  2  A2 FF        	ldx	#$FF			; outer loop count
00F8B5  2               A_F8B5:					;				[F8B5]
00F8B5  2  A0 FF        	ldy	#$FF			; inner loop count
00F8B7  2               A_F8B7:					;				[F8B7]
00F8B7  2  88           	dey				; decrement inner loop count
00F8B8  2  D0 FD        	bne	A_F8B7			; loop if more to do
00F8BA  2               
00F8BA  2  CA           	dex				; decrement outer loop count
00F8BB  2  D0 F8        	bne	A_F8B5			; loop if more to do
00F8BD  2               
00F8BD  2  58           	cli				; enable tape interrupts
00F8BE  2               J_F8BE:					;				[F8BE]
00F8BE  2  AD A0 02     	lda	IRQTMP+1		; get saved IRQ HB
00F8C1  2  CD 15 03     	cmp	CINV+1			; compare with the current IRQ HB
00F8C4  2  18           	clc				; flag ok
00F8C5  2  F0 15        	beq	ClrSavIrqAddr		; if tape write done go clear saved IRQ
00F8C7  2               					; address and exit
00F8C7  2  20 D0 F8     	jsr	ScanStopKey0		; scan stop key and flag abort if
00F8CA  2               					; pressed			[F8D0]
00F8CA  2               					; note if STOP was pressed the return
00F8CA  2               					; is to the routine that called this
00F8CA  2               					; one and not here
00F8CA  2  20 BC F6     	jsr	IncrClock22		; increment real time clock	[F6BC]
00F8CD  2  4C BE F8     	jmp	J_F8BE			; loop				[F8BE]
00F8D0  2               
00F8D0  2               
00F8D0  2               ;******************************************************************************
00F8D0  2               ;
00F8D0  2               ; scan stop key and flag abort if pressed
00F8D0  2               ;
00F8D0  2               ScanStopKey0:				;				[F8D0]
00F8D0  2  20 E1 FF     	jsr	ScanStopKey		; scan stop key			[FFE1]
00F8D3  2  18           	clc				; flag no stop
00F8D4  2  D0 0B        	bne	A_F8E1			; exit if no stop
00F8D6  2               
00F8D6  2  20 93 FC     	jsr	StopUsingTape		; restore everything for STOP	[FC93]
00F8D9  2               
00F8D9  2  38           	sec				; flag stopped
00F8DA  2               
00F8DA  2  68           	pla				; dump return address LB
00F8DB  2  68           	pla				; dump return address HB
00F8DC  2               
00F8DC  2               
00F8DC  2               ;******************************************************************************
00F8DC  2               ;
00F8DC  2               ; clear saved IRQ address
00F8DC  2               ;
00F8DC  2               ClrSavIrqAddr:				;				[F8DC]
00F8DC  2  A9 00        	lda	#$00			; clear A
00F8DE  2  8D A0 02     	sta	IRQTMP+1		; clear saved IRQ address HB
00F8E1  2               A_F8E1:					;				[F8E1]
00F8E1  2  60           	rts
00F8E2  2               
00F8E2  2               
00F8E2  2               ;******************************************************************************
00F8E2  2               ;
00F8E2  2               ;## set timing
00F8E2  2               ;
00F8E2  2               InitReadTape:				;				[F8E2]
00F8E2  2  86 B1        	stx	CMPO+1			; save tape timing constant max byte
00F8E4  2               
00F8E4  2  A5 B0        	lda	CMPO			; get tape timing constant min byte
00F8E6  2  0A           	asl				; *2
00F8E7  2  0A           	asl				; *4
00F8E8  2  18           	clc				; clear carry for add
00F8E9  2  65 B0        	adc	CMPO			; add tape timing constant min byte *5
00F8EB  2  18           	clc				; clear carry for add
00F8EC  2  65 B1        	adc	CMPO+1			; add tape timing constant max byte
00F8EE  2  85 B1        	sta	CMPO+1			; save tape timing constant max byte
00F8F0  2               
00F8F0  2  A9 00        	lda	#$00			;.
00F8F2  2  24 B0        	bit	CMPO			; test tape timing constant min byte
00F8F4  2  30 01        	bmi	A_F8F7			; branch if b7 set
00F8F6  2               
00F8F6  2  2A           	rol				; else shift carry into ??
00F8F7  2               A_F8F7:					;				[F8F7]
00F8F7  2  06 B1        	asl	CMPO+1			; shift tape timing constant max byte
00F8F9  2  2A           	rol				;.
00F8FA  2  06 B1        	asl	CMPO+1			; shift tape timing constant max byte
00F8FC  2  2A           	rol				;.
00F8FD  2  AA           	tax				;.
00F8FE  2               A_F8FE:					;				[F8FE]
00F8FE  2  AD 06 DC     	lda	CIA1TI2L		; get CIA 1 timer B LB
00F901  2  C9 16        	cmp	#$16			;.compare with ??
00F903  2  90 F9        	bcc	A_F8FE			; loop if less
00F905  2               
00F905  2  65 B1        	adc	CMPO+1			; add tape timing constant max byte
00F907  2  8D 04 DC     	sta	CIA1TI1L		; save CIA 1 timer A LB
00F90A  2               
00F90A  2  8A           	txa				;.
00F90B  2  6D 07 DC     	adc	CIA1TI2H		; add CIA 1 timer B HB
00F90E  2  8D 05 DC     	sta	CIA1TI1H		; save CIA 1 timer A HB
00F911  2               
00F911  2  AD A2 02     	lda	Copy6522CRB		; read CIA 1 CRB shadow copy
00F914  2  8D 0E DC     	sta	CIA1CTR1		; save CIA 1 CRA
00F917  2  8D A4 02     	sta	Copy6522CRA		; save CIA 1 CRA shadow copy
00F91A  2               
00F91A  2  AD 0D DC     	lda	CIA1IRQ			; read CIA 1 ICR
00F91D  2  29 10        	and	#$10			; mask 000x 0000, FLAG interrupt
00F91F  2  F0 09        	beq	A_F92A			; if no FLAG interrupt just exit
00F921  2               
00F921  2               ; else first call the IRQ routine
00F921  2  A9 F9        	lda	#>A_F92A		; set the return address HB
00F923  2  48           	pha				; push the return address HB
00F924  2               
00F924  2  A9 2A        	lda	#<A_F92A		; set the return address LB
00F926  2  48           	pha				; push the return address LB
00F927  2               
00F927  2  4C 43 FF     	jmp	SaveStatGoIRQ		; save the status and do the IRQ
00F92A  2               					; routine			[FF43]
00F92A  2               
00F92A  2               A_F92A:					;				[F92A]
00F92A  2  58           	cli				; enable interrupts
00F92B  2  60           	rts
00F92C  2               
00F92C  2               
00F92C  2               ;******************************************************************************
00F92C  2               ;
00F92C  2               ;	On Commodore computers, the streams consist of four kinds of symbols
00F92C  2               ;	that denote different kinds of low-to-high-to-low transitions on the
00F92C  2               ;	read or write signals of the Commodore cassette interface.
00F92C  2               ;
00F92C  2               ;	A	A break in the communications, or a pulse with very long cycle
00F92C  2               ;		time.
00F92C  2               ;
00F92C  2               ;	B	A short pulse, whose cycle time typically ranges from 296 to 424
00F92C  2               ;		microseconds, depending on the computer model.
00F92C  2               ;
00F92C  2               ;	C	A medium-length pulse, whose cycle time typically ranges from
00F92C  2               ;		440 to 576 microseconds, depending on the computer model.
00F92C  2               ;
00F92C  2               ;	D	A long pulse, whose cycle time typically ranges from 600 to 744
00F92C  2               ;		microseconds, depending on the computer model.
00F92C  2               ;
00F92C  2               ;  The actual interpretation of the serial data takes a little more work to
00F92C  2               ; explain. The typical ROM tape loader (and the turbo loaders) will initialize
00F92C  2               ; a timer with a specified value and start it counting down. If either the tape
00F92C  2               ; data changes or the timer runs out, an IRQ will occur. The loader will
00F92C  2               ; determine which condition caused the IRQ. If the tape data changed before the
00F92C  2               ; timer ran out, we have a short pulse, or a "0" bit. If the timer ran out
00F92C  2               ; first, we have a long pulse, or a "1" bit. Doing this continuously and we
00F92C  2               ; decode the entire file.
00F92C  2               ;
00F92C  2               ; read tape bits, IRQ routine
00F92C  2               ;
00F92C  2               ; read T2C which has been counting down from $FFFF. subtract this from $FFFF
00F92C  2               ;
00F92C  2               TapeRead_IRQ:				;				[F92C]
00F92C  2  AE 07 DC     	ldx	CIA1TI2H		; read CIA 1 timer B HB
00F92F  2               
00F92F  2  A0 FF        	ldy	#$FF			;.set $FF
00F931  2  98           	tya				;.A = $FF
00F932  2               
00F932  2  ED 06 DC     	sbc	CIA1TI2L		; subtract CIA 1 timer B LB
00F935  2               
00F935  2  EC 07 DC     	cpx	CIA1TI2H		; compare it with CIA 1 timer B HB
00F938  2  D0 F2        	bne	TapeRead_IRQ		; if timer LB rolled over loop
00F93A  2               
00F93A  2  86 B1        	stx	CMPO+1			; save tape timing constant max byte
00F93C  2               
00F93C  2  AA           	tax				;.copy $FF - T2C_l
00F93D  2               
00F93D  2  8C 06 DC     	sty	CIA1TI2L		; save CIA 1 timer B LB
00F940  2  8C 07 DC     	sty	CIA1TI2H		; save CIA 1 timer B HB
00F943  2               
00F943  2  A9 19        	lda	#$19			; load timer B, timer B single shot,
00F945  2               					; start timer B
00F945  2  8D 0F DC     	sta	CIA1CTR2		; save CIA 1 CRB
00F948  2               
00F948  2  AD 0D DC     	lda	CIA1IRQ			; read CIA 1 ICR
00F94B  2  8D A3 02     	sta	Copy6522ICR		; save CIA 1 ICR shadow copy
00F94E  2               
00F94E  2  98           	tya				; y = $FF
00F94F  2  E5 B1        	sbc	CMPO+1			; subtract tape timing constant max byte
00F951  2               					; A = $FF - T2C_h
00F951  2  86 B1        	stx	CMPO+1			; save tape timing constant max byte
00F953  2               					; CMPO+1 = $FF - T2C_l
00F953  2  4A           	lsr				;.A = $FF - T2C_h >> 1
00F954  2  66 B1        	ror	CMPO+1			; shift tape timing constant max byte
00F956  2               					; CMPO+1 = $FF - T2C_l >> 1
00F956  2  4A           	lsr				;.A = $FF - T2C_h >> 1
00F957  2  66 B1        	ror	CMPO+1			; shift tape timing constant max byte
00F959  2               					; CMPO+1 = $FF - T2C_l >> 1
00F959  2  A5 B0        	lda	CMPO			; get tape timing constant min byte
00F95B  2  18           	clc				; clear carry for add
00F95C  2  69 3C        	adc	#$3C			;.
00F95E  2  C5 B1        	cmp	CMPO+1			; compare with tape timing constant max
00F960  2               					; byte compare with ($FFFF - T2C) >> 2
00F960  2  B0 4A        	bcs	A_F9AC			; branch if min+$3C >= ($FFFF-T2C) >> 2
00F962  2               
00F962  2               ;.min + $3C < ($FFFF - T2C) >> 2
00F962  2  A6 9C        	ldx	DPSW			;.get byte received flag
00F964  2  F0 03        	beq	A_F969			;. if not byte received ??
00F966  2               
00F966  2  4C 60 FA     	jmp	StoreTapeChar		;.store the tape character	[FA60]
00F969  2               
00F969  2               A_F969:					;				[F969]
00F969  2  A6 A3        	ldx	TEMPA3			;.get EOI flag byte
00F96B  2  30 1B        	bmi	A_F988			;.
00F96D  2               
00F96D  2  A2 00        	ldx	#$00			;.
00F96F  2               
00F96F  2  69 30        	adc	#$30			;.
00F971  2  65 B0        	adc	CMPO			; add tape timing constant min byte
00F973  2  C5 B1        	cmp	CMPO+1			; compare with tape timing constant max
00F975  2               					; byte
00F975  2  B0 1C        	bcs	A_F993			;.
00F977  2               
00F977  2  E8           	inx				;.
00F978  2               
00F978  2  69 26        	adc	#$26			;.
00F97A  2  65 B0        	adc	CMPO			; add tape timing constant min byte
00F97C  2  C5 B1        	cmp	CMPO+1			; compare with tape timing constant max
00F97E  2               					; byte
00F97E  2  B0 17        	bcs	J_F997			;.
00F980  2               
00F980  2  69 2C        	adc	#$2C			;.
00F982  2  65 B0        	adc	CMPO			; add tape timing constant min byte
00F984  2  C5 B1        	cmp	CMPO+1			; compare with tape timing constant max
00F986  2               					; byte
00F986  2  90 03        	bcc	A_F98B			;.
00F988  2               
00F988  2               A_F988:					;				[F988]
00F988  2  4C 10 FA     	jmp	J_FA10			;.				[FA10]
00F98B  2               
00F98B  2               A_F98B:					;				[F98B]
00F98B  2  A5 B4        	lda	BITTS			; get the bit count
00F98D  2  F0 1D        	beq	A_F9AC			; if all done go ??
00F98F  2               
00F98F  2  85 A8        	sta	BITCI			; save receiver bit count in
00F991  2  D0 19        	bne	A_F9AC			; branch always
00F993  2               
00F993  2               A_F993:					;				[F993]
00F993  2  E6 A9        	inc	RINONE			; increment ?? start bit check flag
00F995  2  B0 02        	bcs	A_F999			;.
00F997  2               
00F997  2               J_F997:					;				[F997]
00F997  2  C6 A9        	dec	RINONE			; decrement ?? start bit check flag
00F999  2               A_F999:					;				[F999]
00F999  2  38           	sec				;.
00F99A  2  E9 13        	sbc	#$13			;.
00F99C  2  E5 B1        	sbc	CMPO+1			; subtract tape timing constant max byte
00F99E  2  65 92        	adc	SVXT			; add timing constant for tape
00F9A0  2  85 92        	sta	SVXT			; save timing constant for tape
00F9A2  2               
00F9A2  2  A5 A4        	lda	TEMPA4			;.get tape bit cycle phase
00F9A4  2  49 01        	eor	#$01			;.
00F9A6  2  85 A4        	sta	TEMPA4			;.save tape bit cycle phase
00F9A8  2  F0 2B        	beq	A_F9D5			;.
00F9AA  2               
00F9AA  2  86 D7        	stx	TEMPD7			;.
00F9AC  2               A_F9AC:					;				[F9AC]
00F9AC  2  A5 B4        	lda	BITTS			; get the bit count
00F9AE  2  F0 22        	beq	A_F9D2			; if all done go ??
00F9B0  2               
00F9B0  2  AD A3 02     	lda	Copy6522ICR		; read CIA 1 ICR shadow copy
00F9B3  2  29 01        	and	#$01			; mask 0000 000x, timer A interrupt
00F9B5  2               					; enabled
00F9B5  2  D0 05        	bne	A_F9BC			; if timer A is enabled go ??
00F9B7  2               
00F9B7  2  AD A4 02     	lda	Copy6522CRA		; read CIA 1 CRA shadow copy
00F9BA  2  D0 16        	bne	A_F9D2			; if ?? just exit
00F9BC  2               
00F9BC  2               A_F9BC:					;				[F9BC]
00F9BC  2  A9 00        	lda	#$00			; clear A
00F9BE  2  85 A4        	sta	TEMPA4			; clear the tape bit cycle phase
00F9C0  2  8D A4 02     	sta	Copy6522CRA		; save CIA 1 CRA shadow copy
00F9C3  2               
00F9C3  2  A5 A3        	lda	TEMPA3			;.get EOI flag byte
00F9C5  2  10 30        	bpl	A_F9F7			;.
00F9C7  2               
00F9C7  2  30 BF        	bmi	A_F988			; always ->
00F9C9  2               
00F9C9  2               A_F9C9:					;				[F9C9]
00F9C9  2  A2 A6        	ldx	#$A6			; set timimg max byte
00F9CB  2  20 E2 F8     	jsr	InitReadTape		; set timing			[F8E2]
00F9CE  2               
00F9CE  2  A5 9B        	lda	PRTY			;.
00F9D0  2  D0 B9        	bne	A_F98B			;.
00F9D2  2               A_F9D2:					;				[F9D2]
00F9D2  2  4C BC FE     	jmp	End_RS232_NMI		; restore registers and exit interrupt
00F9D5  2               					;				[FEBC]
00F9D5  2               A_F9D5:					;				[F9D5]
00F9D5  2  A5 92        	lda	SVXT			; get timing constant for tape
00F9D7  2  F0 07        	beq	A_F9E0			;.
00F9D9  2               
00F9D9  2  30 03        	bmi	A_F9DE			;.
00F9DB  2               
00F9DB  2  C6 B0        	dec	CMPO			; decrement tape timing constant min
00F9DD  2               					; byte
00F9DD  2  2C           .byte	$2C
00F9DE  2               A_F9DE:					;				[F9DE]
00F9DE  2  E6 B0        	inc	CMPO			; increment tape timing constant min
00F9E0  2               					; byte
00F9E0  2               A_F9E0:					;				[F9E0]
00F9E0  2  A9 00        	lda	#$00			;.
00F9E2  2  85 92        	sta	SVXT			; clear timing constant for tape
00F9E4  2               
00F9E4  2  E4 D7        	cpx	TEMPD7			;.
00F9E6  2  D0 0F        	bne	A_F9F7			;.
00F9E8  2               
00F9E8  2  8A           	txa				;.
00F9E9  2  D0 A0        	bne	A_F98B			;.
00F9EB  2               
00F9EB  2  A5 A9        	lda	RINONE			; get start bit check flag
00F9ED  2  30 BD        	bmi	A_F9AC			;.
00F9EF  2               
00F9EF  2  C9 10        	cmp	#$10			;.
00F9F1  2  90 B9        	bcc	A_F9AC			;.
00F9F3  2               
00F9F3  2  85 96        	sta	SYNO			;.save cassette block synchronization
00F9F5  2               					; number
00F9F5  2  B0 B5        	bcs	A_F9AC			;.
00F9F7  2               A_F9F7:					;				[F9F7]
00F9F7  2  8A           	txa				;.
00F9F8  2  45 9B        	eor	PRTY			;.
00F9FA  2  85 9B        	sta	PRTY			;.
00F9FC  2               
00F9FC  2  A5 B4        	lda	BITTS			;.
00F9FE  2  F0 D2        	beq	A_F9D2			;.
00FA00  2               
00FA00  2  C6 A3        	dec	TEMPA3			;.decrement EOI flag byte
00FA02  2  30 C5        	bmi	A_F9C9			;.
00FA04  2               
00FA04  2  46 D7        	lsr	TEMPD7			;.
00FA06  2  66 BF        	ror	MYCH			;.parity count
00FA08  2               
00FA08  2  A2 DA        	ldx	#$DA			; set timimg max byte
00FA0A  2  20 E2 F8     	jsr	InitReadTape		; set timing			[F8E2]
00FA0D  2               
00FA0D  2  4C BC FE     	jmp	End_RS232_NMI		; restore registers and exit interrupt
00FA10  2               					;				[FEBC]
00FA10  2               J_FA10:					;				[FA10]
00FA10  2  A5 96        	lda	SYNO			; get cassette block synchron. number
00FA12  2  F0 04        	beq	A_FA18			;.
00FA14  2               
00FA14  2  A5 B4        	lda	BITTS			;.
00FA16  2  F0 07        	beq	A_FA1F			;.
00FA18  2               
00FA18  2               A_FA18:					;				[FA18]
00FA18  2  A5 A3        	lda	TEMPA3			;.get EOI flag byte
00FA1A  2  30 03        	bmi	A_FA1F			;.
00FA1C  2               
00FA1C  2  4C 97 F9     	jmp	J_F997			;.				[F997]
00FA1F  2               
00FA1F  2               A_FA1F:					;				[FA1F]
00FA1F  2  46 B1        	lsr	CMPO+1			; shift tape timing constant max byte
00FA21  2               
00FA21  2  A9 93        	lda	#$93			;.
00FA23  2  38           	sec				;.
00FA24  2  E5 B1        	sbc	CMPO+1			; subtract tape timing constant max byte
00FA26  2  65 B0        	adc	CMPO			; add tape timing constant min byte
00FA28  2  0A           	asl				;.
00FA29  2  AA           	tax				; copy timimg HB
00FA2A  2               
00FA2A  2  20 E2 F8     	jsr	InitReadTape		; set timing			[F8E2]
00FA2D  2               
00FA2D  2  E6 9C        	inc	DPSW			;.
00FA2F  2               
00FA2F  2  A5 B4        	lda	BITTS			;.
00FA31  2  D0 11        	bne	A_FA44			;.
00FA33  2               
00FA33  2  A5 96        	lda	SYNO			; get cassette block synchron. number
00FA35  2  F0 26        	beq	A_FA5D			;.
00FA37  2               
00FA37  2  85 A8        	sta	BITCI			; save receiver bit count in
00FA39  2               
00FA39  2  A9 00        	lda	#$00			; clear A
00FA3B  2  85 96        	sta	SYNO			; clear cassette block synchron. number
00FA3D  2               
00FA3D  2  A9 81        	lda	#$81			; enable timer A interrupt
00FA3F  2  8D 0D DC     	sta	CIA1IRQ			; save CIA 1 ICR
00FA42  2  85 B4        	sta	BITTS			;.
00FA44  2               A_FA44:					;				[FA44]
00FA44  2  A5 96        	lda	SYNO			; get cassette block synchron. number
00FA46  2  85 B5        	sta	NXTBIT			;.
00FA48  2  F0 09        	beq	A_FA53			;.
00FA4A  2               
00FA4A  2  A9 00        	lda	#$00			;.
00FA4C  2  85 B4        	sta	BITTS			;.
00FA4E  2               
00FA4E  2  A9 01        	lda	#$01			; disable timer A interrupt
00FA50  2  8D 0D DC     	sta	CIA1IRQ			; save CIA 1 ICR
00FA53  2               A_FA53:					;				[FA53]
00FA53  2  A5 BF        	lda	MYCH			;.parity count
00FA55  2  85 BD        	sta	ROPRTY			;.save RS232 parity byte
00FA57  2               
00FA57  2  A5 A8        	lda	BITCI			; get receiver bit count in
00FA59  2  05 A9        	ora	RINONE			; OR with start bit check flag
00FA5B  2  85 B6        	sta	RODATA			;.
00FA5D  2               A_FA5D:					;				[FA5D]
00FA5D  2  4C BC FE     	jmp	End_RS232_NMI		; restore registers and exit interrupt
00FA60  2               					;				[FEBC]
00FA60  2               
00FA60  2               ;******************************************************************************
00FA60  2               ;
00FA60  2               ;## store character
00FA60  2               ;
00FA60  2               StoreTapeChar:				;				[FA60]
00FA60  2  20 97 FB     	jsr	SetCounter		; new tape byte setup		[FB97]
00FA63  2  85 9C        	sta	DPSW			; clear byte received flag
00FA65  2               
00FA65  2  A2 DA        	ldx	#$DA			; set timimg max byte
00FA67  2  20 E2 F8     	jsr	InitReadTape		; set timing			[F8E2]
00FA6A  2               
00FA6A  2  A5 BE        	lda	FSBLK			;.get copies count
00FA6C  2  F0 02        	beq	A_FA70			;.
00FA6E  2               
00FA6E  2  85 A7        	sta	INBIT			; save receiver input bit temporary
00FA70  2               					; storage
00FA70  2               A_FA70:					;				[FA70]
00FA70  2  A9 0F        	lda	#$0F			;.
00FA72  2  24 AA        	bit	RIDATA			;.
00FA74  2  10 17        	bpl	A_FA8D			;.
00FA76  2               
00FA76  2  A5 B5        	lda	NXTBIT			;.
00FA78  2  D0 0C        	bne	A_FA86			;.
00FA7A  2               
00FA7A  2  A6 BE        	ldx	FSBLK			;.get copies count
00FA7C  2  CA           	dex				;.
00FA7D  2  D0 0B        	bne	A_FA8A			; if ?? restore registers and exit
00FA7F  2               					; interrupt
00FA7F  2  A9 08        	lda	#$08			; set short block
00FA81  2  20 1C FE     	jsr	AorIecStatus		; OR into serial status byte	[FE1C]
00FA84  2  D0 04        	bne	A_FA8A			; restore registers and exit interrupt,
00FA86  2               					; branch always
00FA86  2               A_FA86:					;				[FA86]
00FA86  2  A9 00        	lda	#$00			;.
00FA88  2  85 AA        	sta	RIDATA			;.
00FA8A  2               A_FA8A:					;				[FA8A]
00FA8A  2  4C BC FE     	jmp	End_RS232_NMI		; restore registers and exit interrupt
00FA8D  2               					;				[FEBC]
00FA8D  2               A_FA8D:					;				[FA8D]
00FA8D  2  70 31        	bvs	A_FAC0			;.
00FA8F  2               
00FA8F  2  D0 18        	bne	A_FAA9			;.
00FA91  2               
00FA91  2  A5 B5        	lda	NXTBIT			;.
00FA93  2  D0 F5        	bne	A_FA8A			;.
00FA95  2               
00FA95  2  A5 B6        	lda	RODATA			;.
00FA97  2  D0 F1        	bne	A_FA8A			;.
00FA99  2               
00FA99  2  A5 A7        	lda	INBIT			; get receiver input bit temporary
00FA9B  2               					; storage
00FA9B  2  4A           	lsr				;.
00FA9C  2               
00FA9C  2  A5 BD        	lda	ROPRTY			;.get RS232 parity byte
00FA9E  2  30 03        	bmi	A_FAA3			;.
00FAA0  2               
00FAA0  2  90 18        	bcc	A_FABA			;.
00FAA2  2               
00FAA2  2  18           	clc				;.
00FAA3  2               A_FAA3:					;				[FAA3]
00FAA3  2  B0 15        	bcs	A_FABA			;.
00FAA5  2               
00FAA5  2  29 0F        	and	#$0F			;.
00FAA7  2  85 AA        	sta	RIDATA			;.
00FAA9  2               A_FAA9:					;				[FAA9]
00FAA9  2  C6 AA        	dec	RIDATA			;.
00FAAB  2  D0 DD        	bne	A_FA8A			;.
00FAAD  2               
00FAAD  2  A9 40        	lda	#$40			;.
00FAAF  2  85 AA        	sta	RIDATA			;.
00FAB1  2               
00FAB1  2  20 8E FB     	jsr	CopyIoAdr2Buf		; copy I/O start address to buffer
00FAB4  2               					; address			[FB8E]
00FAB4  2  A9 00        	lda	#$00			;.
00FAB6  2  85 AB        	sta	RIPRTY			;.
00FAB8  2  F0 D0        	beq	A_FA8A			;.
00FABA  2               A_FABA:					;				[FABA]
00FABA  2  A9 80        	lda	#$80			;.
00FABC  2  85 AA        	sta	RIDATA			;.
00FABE  2  D0 CA        	bne	A_FA8A			; restore registers and exit interrupt,
00FAC0  2               					; branch always
00FAC0  2               A_FAC0:					;				[FAC0]
00FAC0  2  A5 B5        	lda	NXTBIT			;.
00FAC2  2  F0 0A        	beq	A_FACE			;.
00FAC4  2               
00FAC4  2  A9 04        	lda	#$04			;.
00FAC6  2  20 1C FE     	jsr	AorIecStatus		; OR into serial status byte	[FE1C]
00FAC9  2               
00FAC9  2  A9 00        	lda	#$00			;.
00FACB  2  4C 4A FB     	jmp	J_FB4A			;.				[FB4A]
00FACE  2               
00FACE  2               A_FACE:					;				[FACE]
00FACE  2  20 D1 FC     	jsr	ChkRdWrPtr		; check read/write pointer, return
00FAD1  2               					;Cb = 1 if pointer >= end	[FCD1]
00FAD1  2  90 03        	bcc	A_FAD6			;.
00FAD3  2               
00FAD3  2  4C 48 FB     	jmp	J_FB48			;.				[FB48]
00FAD6  2               
00FAD6  2               A_FAD6:					;				[FAD6]
00FAD6  2  A6 A7        	ldx	INBIT			; get receiver input bit temporary
00FAD8  2               					; storage
00FAD8  2  CA           	dex				;.
00FAD9  2  F0 2D        	beq	A_FB08			;.
00FADB  2               
00FADB  2  A5 93        	lda	LoadVerify2		; get load/verify flag
00FADD  2  F0 0C        	beq	A_FAEB			; if load go ??
00FADF  2               
00FADF  2  A0 00        	ldy	#$00			; clear index
00FAE1  2  A5 BD        	lda	ROPRTY			;.get RS232 parity byte
00FAE3  2  D1 AC        	cmp	(SAL),Y			;.
00FAE5  2  F0 04        	beq	A_FAEB			;.
00FAE7  2               
00FAE7  2  A9 01        	lda	#$01			;.
00FAE9  2  85 B6        	sta	RODATA			;.
00FAEB  2               A_FAEB:					;				[FAEB]
00FAEB  2  A5 B6        	lda	RODATA			;.
00FAED  2  F0 4B        	beq	J_FB3A			;.
00FAEF  2               
00FAEF  2  A2 3D        	ldx	#$3D			;.
00FAF1  2  E4 9E        	cpx	PTR1			;.
00FAF3  2  90 3E        	bcc	A_FB33			;.
00FAF5  2               
00FAF5  2  A6 9E        	ldx	PTR1			;.
00FAF7  2  A5 AD        	lda	SAL+1			;.
00FAF9  2  9D 01 01     	sta	STACK+1,X		;.
00FAFC  2               
00FAFC  2  A5 AC        	lda	SAL			;.
00FAFE  2  9D 00 01     	sta	STACK,X			;.
00FB01  2               
00FB01  2  E8           	inx				;.
00FB02  2  E8           	inx				;.
00FB03  2  86 9E        	stx	PTR1			;.
00FB05  2               
00FB05  2  4C 3A FB     	jmp	J_FB3A			;.				[FB3A]
00FB08  2               
00FB08  2               A_FB08:					;				[FB08]
00FB08  2  A6 9F        	ldx	PTR2			;.
00FB0A  2  E4 9E        	cpx	PTR1			;.
00FB0C  2  F0 35        	beq	A_FB43			;.
00FB0E  2               
00FB0E  2  A5 AC        	lda	SAL			;.
00FB10  2  DD 00 01     	cmp	STACK,X			;.
00FB13  2  D0 2E        	bne	A_FB43			;.
00FB15  2               
00FB15  2  A5 AD        	lda	SAL+1			;.
00FB17  2  DD 01 01     	cmp	STACK+1,X		;.
00FB1A  2  D0 27        	bne	A_FB43			;.
00FB1C  2               
00FB1C  2  E6 9F        	inc	PTR2			;.
00FB1E  2  E6 9F        	inc	PTR2			;.
00FB20  2               
00FB20  2  A5 93        	lda	LoadVerify2		; get load/verify flag
00FB22  2  F0 0B        	beq	A_FB2F			; if load ??
00FB24  2               
00FB24  2  A5 BD        	lda	ROPRTY			;.get RS232 parity byte
00FB26  2  A0 00        	ldy	#$00			;.
00FB28  2  D1 AC        	cmp	(SAL),Y			;.
00FB2A  2  F0 17        	beq	A_FB43			;.
00FB2C  2               
00FB2C  2  C8           	iny				;.
00FB2D  2  84 B6        	sty	RODATA			;.
00FB2F  2               A_FB2F:					;				[FB2F]
00FB2F  2  A5 B6        	lda	RODATA			;.
00FB31  2  F0 07        	beq	J_FB3A			;.
00FB33  2               A_FB33:					;				[FB33]
00FB33  2  A9 10        	lda	#$10			;.
00FB35  2  20 1C FE     	jsr	AorIecStatus		; OR into serial status byte	[FE1C]
00FB38  2  D0 09        	bne	A_FB43			;.
00FB3A  2               J_FB3A:					;				[FB3A]
00FB3A  2  A5 93        	lda	LoadVerify2		; get load/verify flag
00FB3C  2  D0 05        	bne	A_FB43			; if verify go ??
00FB3E  2               
00FB3E  2  A8           	tay				;.
00FB3F  2  A5 BD        	lda	ROPRTY			;.get RS232 parity byte
00FB41  2  91 AC        	sta	(SAL),Y			;.
00FB43  2               A_FB43:					;				[FB43]
00FB43  2  20 DB FC     	jsr	IncRdWrPtr		; increment read/write pointer	[FCDB]
00FB46  2  D0 43        	bne	A_FB8B			; restore registers and exit interrupt,
00FB48  2               					; branch always
00FB48  2               J_FB48:					;				[FB48]
00FB48  2  A9 80        	lda	#$80			;.
00FB4A  2               J_FB4A:					;				[FB4A]
00FB4A  2  85 AA        	sta	RIDATA			;.
00FB4C  2               
00FB4C  2  78           	sei				;.
00FB4D  2               
00FB4D  2  A2 01        	ldx	#$01			; disable timer A interrupt
00FB4F  2  8E 0D DC     	stx	CIA1IRQ			; save CIA 1 ICR
00FB52  2               
00FB52  2  AE 0D DC     	ldx	CIA1IRQ			; read CIA 1 ICR
00FB55  2               
00FB55  2  A6 BE        	ldx	FSBLK			;.get copies count
00FB57  2  CA           	dex				;.
00FB58  2  30 02        	bmi	A_FB5C			;.
00FB5A  2               
00FB5A  2  86 BE        	stx	FSBLK			;.save copies count
00FB5C  2               A_FB5C:					;				[FB5C]
00FB5C  2  C6 A7        	dec	INBIT			; decrement receiver input bit temporary
00FB5E  2               					; storage
00FB5E  2  F0 08        	beq	A_FB68			;.
00FB60  2               
00FB60  2  A5 9E        	lda	PTR1			;.
00FB62  2  D0 27        	bne	A_FB8B			; if ?? restore registers and exit
00FB64  2               					; interrupt
00FB64  2  85 BE        	sta	FSBLK			;.save copies count
00FB66  2  F0 23        	beq	A_FB8B			; restore registers and exit interrupt,
00FB68  2               					; branch always
00FB68  2               A_FB68:					;				[FB68]
00FB68  2  20 93 FC     	jsr	StopUsingTape		; restore everything for STOP	[FC93]
00FB6B  2  20 8E FB     	jsr	CopyIoAdr2Buf		; copy I/O start address to buffer
00FB6E  2               					; address	[FB8E]
00FB6E  2               
00FB6E  2  A0 00        	ldy	#$00			; clear index
00FB70  2  84 AB        	sty	RIPRTY			; clear checksum
00FB72  2               A_FB72:					;				[FB72]
00FB72  2  B1 AC        	lda	(SAL),Y			; get byte from buffer
00FB74  2  45 AB        	eor	RIPRTY			; XOR with checksum
00FB76  2  85 AB        	sta	RIPRTY			; save new checksum
00FB78  2               
00FB78  2  20 DB FC     	jsr	IncRdWrPtr		; increment read/write pointer	[FCDB]
00FB7B  2               
00FB7B  2  20 D1 FC     	jsr	ChkRdWrPtr		; check read/write pointer, return
00FB7E  2               					;Cb = 1 if pointer >= end	[FCD1]
00FB7E  2  90 F2        	bcc	A_FB72			; loop if not at end
00FB80  2               
00FB80  2  A5 AB        	lda	RIPRTY			; get computed checksum
00FB82  2  45 BD        	eor	ROPRTY			; compare with stored checksum ??
00FB84  2  F0 05        	beq	A_FB8B			; if checksum ok restore registers and
00FB86  2               					; exit interrupt
00FB86  2  A9 20        	lda	#$20			; else set checksum error
00FB88  2  20 1C FE     	jsr	AorIecStatus		; OR into the serial status byte [FE1C]
00FB8B  2               A_FB8B:					;				[FB8B]
00FB8B  2  4C BC FE     	jmp	End_RS232_NMI		; restore registers and exit interrupt
00FB8E  2               					;				[FEBC]
00FB8E  2               
00FB8E  2               ;******************************************************************************
00FB8E  2               ;
00FB8E  2               ; copy I/O start address to buffer address
00FB8E  2               ;
00FB8E  2               CopyIoAdr2Buf:				;				[FB8E]
00FB8E  2  A5 C2        	lda	STAL+1			; get I/O start address HB
00FB90  2  85 AD        	sta	SAL+1			; set buffer address HB
00FB92  2               
00FB92  2  A5 C1        	lda	STAL			; get I/O start address LB
00FB94  2  85 AC        	sta	SAL			; set buffer address LB
00FB96  2               
00FB96  2  60           	rts
00FB97  2               
00FB97  2               
00FB97  2               ;******************************************************************************
00FB97  2               ;
00FB97  2               ; new tape byte setup
00FB97  2               ;
00FB97  2               SetCounter:				;				[FB97]
00FB97  2  A9 08        	lda	#$08			; eight bits to do
00FB99  2  85 A3        	sta	TEMPA3			; set bit count
00FB9B  2               
00FB9B  2  A9 00        	lda	#$00			; clear A
00FB9D  2  85 A4        	sta	TEMPA4			; clear tape bit cycle phase
00FB9F  2  85 A8        	sta	BITCI			; clear start bit first cycle done flag
00FBA1  2  85 9B        	sta	PRTY			; clear byte parity
00FBA3  2  85 A9        	sta	RINONE			; clear start bit check flag, set no
00FBA5  2               					; start bit yet
00FBA5  2  60           	rts
00FBA6  2               
00FBA6  2               
00FBA6  2               ;******************************************************************************
00FBA6  2               ;
00FBA6  2               ; send lsb from tape write byte to tape
00FBA6  2               ;
00FBA6  2               ; this routine tests the least significant bit in the tape write byte and sets
00FBA6  2               ; CIA 2 T2 depending on the state of the bit. if the bit is a 1 a time of $00B0
00FBA6  2               ; cycles is set, if the bot is a 0 a time of $0060 cycles is set. note that
00FBA6  2               ; this routine does not shift the bits of the tape write byte but uses a copy
00FBA6  2               ; of that byte, the byte itself is shifted elsewhere
00FBA6  2               ;
00FBA6  2               WriteBitToTape:				;				[FBA6]
00FBA6  2  A5 BD        	lda	ROPRTY			; get tape write byte
00FBA8  2  4A           	lsr				; shift lsb into Cb
00FBA9  2               
00FBA9  2  A9 60        	lda	#$60			; set time constant LB for bit = 0
00FBAB  2  90 02        	bcc	SetTimeHByte		; branch if bit was 0
00FBAD  2               
00FBAD  2               ; set time constant for bit = 1 and toggle tape
00FBAD  2               SetTimeBitIs1:				;				[FBAD]
00FBAD  2  A9 B0        	lda	#$B0			; set time constant LB for bit = 1
00FBAF  2               
00FBAF  2               ; write time constant and toggle tape
00FBAF  2               SetTimeHByte:				;				[FBAF]
00FBAF  2  A2 00        	ldx	#$00			; set time constant HB
00FBB1  2               
00FBB1  2               ; write time constant and toggle tape
00FBB1  2               WrTimeTgglTape:				;				[FBB1]
00FBB1  2  8D 06 DC     	sta	CIA1TI2L		; save CIA 1 timer B LB
00FBB4  2  8E 07 DC     	stx	CIA1TI2H		; save CIA 1 timer B HB
00FBB7  2               
00FBB7  2  AD 0D DC     	lda	CIA1IRQ			; read CIA 1 ICR
00FBBA  2               
00FBBA  2  A9 19        	lda	#$19			; load timer B, timer B single shot,
00FBBC  2               					; start timer B
00FBBC  2  8D 0F DC     	sta	CIA1CTR2		; save CIA 1 CRB
00FBBF  2               
00FBBF  2  A5 01        	lda	P6510			; read the 6510 I/O port
00FBC1  2  49 08        	eor	#$08			; toggle tape out bit
00FBC3  2  85 01        	sta	P6510			; save the 6510 I/O port
00FBC5  2               
00FBC5  2  29 08        	and	#$08			; mask tape out bit
00FBC7  2  60           	rts
00FBC8  2               
00FBC8  2               
00FBC8  2               ;******************************************************************************
00FBC8  2               ;
00FBC8  2               ; flag block done and exit interrupt
00FBC8  2               ;
00FBC8  2               FlagBlockDone:				;				[FBC8]
00FBC8  2  38           	sec				; set carry flag
00FBC9  2  66 B6        	ror	RODATA			; set buffer address HB negative, flag
00FBCB  2               					; all sync, data and checksum bytes
00FBCB  2               					; written
00FBCB  2  30 3C        	bmi	A_FC09			; restore registers and exit interrupt,
00FBCD  2               					; branch always
00FBCD  2               
00FBCD  2               ;******************************************************************************
00FBCD  2               ;
00FBCD  2               ; tape write IRQ routine
00FBCD  2               ;
00FBCD  2               ; this is the routine that writes the bits to the tape. it is called each time
00FBCD  2               ; CIA 2 T2 times out and checks if the start bit is done, if so checks if the
00FBCD  2               ; data bits are done, if so it checks if the byte is done, if so it checks if
00FBCD  2               ; the synchronisation bytes are done, if so it checks if the data bytes are
00FBCD  2               ; done, if so it checks if the checksum byte is done, if so it checks if both
00FBCD  2               ; the load and verify copies have been done, if so it stops the tape
00FBCD  2               ;
00FBCD  2               TapeWrite_IRQ:				;				[FBCD]
00FBCD  2  A5 A8        	lda	BITCI			; get start bit first cycle done flag
00FBCF  2  D0 12        	bne	A_FBE3			; if first cycle done go do rest of byte
00FBD1  2               
00FBD1  2               ; each byte sent starts with two half cycles of $0110 ststem clocks and the
00FBD1  2               ; whole block ends with two more such half cycles
00FBD1  2  A9 10        	lda	#$10			; set first start cycle time constant LB
00FBD3  2  A2 01        	ldx	#$01			; set first start cycle time constant HB
00FBD5  2  20 B1 FB     	jsr	WrTimeTgglTape		; write time constant and toggle tape
00FBD8  2               					;				[FBB1]
00FBD8  2  D0 2F        	bne	A_FC09			; if first half cycle go restore
00FBDA  2               					; registers and exit interrupt
00FBDA  2  E6 A8        	inc	BITCI			; set start bit first start cycle done
00FBDC  2               					; flag
00FBDC  2  A5 B6        	lda	RODATA			; get buffer address HB
00FBDE  2  10 29        	bpl	A_FC09			; if block not complete go restore
00FBE0  2               					; registers and exit interrupt. The end
00FBE0  2               					; of a block is indicated by the tape
00FBE0  2               					; buffer HB b7 being set to 1
00FBE0  2  4C 57 FC     	jmp	J_FC57			; else do tape routine, block complete
00FBE3  2               					; exit				[FC57]
00FBE3  2               
00FBE3  2               ; continue tape byte write. the first start cycle, both half cycles of it, is
00FBE3  2               ; complete so the routine drops straight through to here
00FBE3  2               A_FBE3:					;				[FBE3]
00FBE3  2  A5 A9        	lda	RINONE			; get start bit check flag
00FBE5  2  D0 09        	bne	A_FBF0			; if start bit is complete, go send byte
00FBE7  2               
00FBE7  2               ; after the two half cycles of $0110 ststem clocks the start bit is completed
00FBE7  2               ; with two half cycles of $00B0 system clocks. this is the same as the first
00FBE7  2               ; part of a 1 bit
00FBE7  2  20 AD FB     	jsr	SetTimeBitIs1		; set time constant for bit = 1 and
00FBEA  2               					; toggle tape			[FBAD]
00FBEA  2  D0 1D        	bne	A_FC09			; if first half cycle go restore
00FBEC  2               					; registers and exit interrupt
00FBEC  2  E6 A9        	inc	RINONE			; set start bit check flag
00FBEE  2  D0 19        	bne	A_FC09			; restore registers and exit interrupt,
00FBF0  2               					; branch always
00FBF0  2               
00FBF0  2               ; continue tape byte write. the start bit, both cycles of it, is complete so
00FBF0  2               ; the routine drops straight through to here. now the cycle pairs for each bit,
00FBF0  2               ; and the parity bit, are sent
00FBF0  2               A_FBF0:					;				[FBF0]
00FBF0  2  20 A6 FB     	jsr	WriteBitToTape		; send lsb from tape write byte to tape
00FBF3  2               					;				[FBA6]
00FBF3  2  D0 14        	bne	A_FC09			; if first half cycle go restore
00FBF5  2               					; registers and exit interrupt
00FBF5  2               ; else two half cycles have been done
00FBF5  2  A5 A4        	lda	TEMPA4			; get tape bit cycle phase
00FBF7  2  49 01        	eor	#$01			; toggle b0
00FBF9  2  85 A4        	sta	TEMPA4			; save tape bit cycle phase
00FBFB  2  F0 0F        	beq	A_FC0C			; if bit cycle phase complete go setup
00FBFD  2               					; for next bit
00FBFD  2               
00FBFD  2               ; each bit is written as two full cycles. a 1 is sent as a full cycle of $0160
00FBFD  2               ; system clocks then a full cycle of $00C0 system clocks. a 0 is sent as a full
00FBFD  2               ; cycle of $00C0 system clocks then a full cycle of $0160 system clocks. to do
00FBFD  2               ; this each bit from the write byte is inverted during the second bit cycle
00FBFD  2               ; phase. as the bit is inverted it is also added to the, one bit, parity count
00FBFD  2               ; for this byte
00FBFD  2  A5 BD        	lda	ROPRTY			; get tape write byte
00FBFF  2  49 01        	eor	#$01			; invert bit being sent
00FC01  2  85 BD        	sta	ROPRTY			; save tape write byte
00FC03  2               
00FC03  2  29 01        	and	#$01			; mask b0
00FC05  2  45 9B        	eor	PRTY			; EOR with tape write byte parity bit
00FC07  2  85 9B        	sta	PRTY			; save tape write byte parity bit
00FC09  2               A_FC09:					;				[FC09]
00FC09  2  4C BC FE     	jmp	End_RS232_NMI		; restore registers and exit interrupt
00FC0C  2               					;				[FEBC]
00FC0C  2               
00FC0C  2               ; the bit cycle phase is complete so shift out the just written bit and test
00FC0C  2               ; for byte end
00FC0C  2               A_FC0C:					;				[FC0C]
00FC0C  2  46 BD        	lsr	ROPRTY			; shift bit out of tape write byte
00FC0E  2               
00FC0E  2  C6 A3        	dec	TEMPA3			; decrement tape write bit count
00FC10  2               
00FC10  2  A5 A3        	lda	TEMPA3			; get tape write bit count
00FC12  2  F0 3A        	beq	A_FC4E			; if all data bits have been written, do
00FC14  2               					; setup for sending parity bit next and
00FC14  2               					; exit the interrupt
00FC14  2  10 F3        	bpl	A_FC09			; if all data bits are not yet sent,
00FC16  2               					; just restore registers and exit
00FC16  2               					; interrupt
00FC16  2               ; do next tape byte
00FC16  2               
00FC16  2               ; the byte is complete. the start bit, data bits and parity bit have been
00FC16  2               ; written to the tape so setup for the next byte
00FC16  2               A_FC16:					;				[FC16]
00FC16  2  20 97 FB     	jsr	SetCounter		; new tape byte setup		[FB97]
00FC19  2               
00FC19  2  58           	cli				; enable the interrupts
00FC1A  2               
00FC1A  2  A5 A5        	lda	CNTDN			; get cassette synchronization character
00FC1C  2               					; count
00FC1C  2  F0 12        	beq	A_FC30			; if synchronisation characters done,
00FC1E  2               					; do block data
00FC1E  2               
00FC1E  2               ; at the start of each block sent to tape there are a number of synchronisation
00FC1E  2               ; bytes that count down to the actual data. the commodore tape system saves two
00FC1E  2               ; copies of all the tape data, the first is loaded and is indicated by the
00FC1E  2               ; synchronisation bytes having b7 set, and the second copy is indicated by the
00FC1E  2               ; synchronisation bytes having b7 clear. the sequence goes $09, $08, ..... $02,
00FC1E  2               ; $01, data bytes
00FC1E  2  A2 00        	ldx	#$00			; clear X
00FC20  2  86 D7        	stx	TEMPD7			; clear checksum byte
00FC22  2               
00FC22  2  C6 A5        	dec	CNTDN			; decrement cassette synchronization
00FC24  2               					; byte count
00FC24  2  A6 BE        	ldx	FSBLK			; get cassette copies count
00FC26  2  E0 02        	cpx	#$02			; compare with load block indicator
00FC28  2  D0 02        	bne	A_FC2C			; branch if not the load block
00FC2A  2               
00FC2A  2  09 80        	ora	#$80			; this is the load block so make the
00FC2C  2               					; synchronisation count
00FC2C  2               					; go $89, $88, ..... $82, $81
00FC2C  2               A_FC2C:					;				[FC2C]
00FC2C  2  85 BD        	sta	ROPRTY			; save the synchronisation byte as the
00FC2E  2               					; tape write byte
00FC2E  2  D0 D9        	bne	A_FC09			; restore registers and exit interrupt,
00FC30  2               					; branch always
00FC30  2               
00FC30  2               ; the synchronization bytes have been done so now check and do the actual block
00FC30  2               ; data
00FC30  2               A_FC30:					;				[FC30]
00FC30  2  20 D1 FC     	jsr	ChkRdWrPtr		; check read/write pointer, return
00FC33  2               					; Cb = 1 if pointer >= end	[FCD1]
00FC33  2  90 0A        	bcc	A_FC3F			; if not all done yet go get the byte
00FC35  2               					; to send
00FC35  2  D0 91        	bne	FlagBlockDone		; if pointer > end go flag block done
00FC37  2               					; and exit interrupt
00FC37  2               
00FC37  2               ; else the block is complete, it only remains to write the checksum byte to the
00FC37  2               ; tape so setup for that
00FC37  2  E6 AD        	inc	SAL+1			; increment buffer pointer HB, this
00FC39  2               					; means block done branch will always be
00FC39  2               					; taken next time without having to
00FC39  2               					; worry about the LB wrapping to zero
00FC39  2  A5 D7        	lda	TEMPD7			; get checksum byte
00FC3B  2  85 BD        	sta	ROPRTY			; save checksum as tape write byte
00FC3D  2  B0 CA        	bcs	A_FC09			; restore registers and exit interrupt,
00FC3F  2               					; branch always
00FC3F  2               
00FC3F  2               ; the block isn't finished so get the next byte to write to tape
00FC3F  2               A_FC3F:					;				[FC3F]
00FC3F  2  A0 00        	ldy	#$00			; clear index
00FC41  2  B1 AC        	lda	(SAL),Y			; get byte from buffer
00FC43  2  85 BD        	sta	ROPRTY			; save as tape write byte
00FC45  2               
00FC45  2  45 D7        	eor	TEMPD7			; XOR with checksum byte
00FC47  2  85 D7        	sta	TEMPD7			; save new checksum byte
00FC49  2               
00FC49  2  20 DB FC     	jsr	IncRdWrPtr		; increment read/write pointer	[FCDB]
00FC4C  2  D0 BB        	bne	A_FC09			; restore registers and exit interrupt,
00FC4E  2               					; branch always
00FC4E  2               
00FC4E  2               ; set parity as next bit and exit interrupt
00FC4E  2               A_FC4E:					;				[FC4E]
00FC4E  2  A5 9B        	lda	PRTY			; get parity bit
00FC50  2  49 01        	eor	#$01			; toggle it
00FC52  2  85 BD        	sta	ROPRTY			; save as tape write byte
00FC54  2               A_FC54:					;				[FC54]
00FC54  2  4C BC FE     	jmp	End_RS232_NMI		; restore registers and exit interrupt
00FC57  2               					;	[FEBC]
00FC57  2               
00FC57  2               ; tape routine, block complete exit
00FC57  2               J_FC57:					;				[FC57]
00FC57  2  C6 BE        	dec	FSBLK			; decrement copies remaining to
00FC59  2               					; read/write
00FC59  2  D0 03        	bne	A_FC5E			; branch if more to do
00FC5B  2               
00FC5B  2  20 CA FC     	jsr	StopTapeMotor		; stop the cassette motor	[FCCA]
00FC5E  2               A_FC5E:					;				[FC5E]
00FC5E  2  A9 50        	lda	#$50			; set tape write leader count
00FC60  2  85 A7        	sta	INBIT			; save tape write leader count
00FC62  2               
00FC62  2  A2 08        	ldx	#$08			; set index for write tape leader vector
00FC64  2               
00FC64  2  78           	sei				; disable the interrupts
00FC65  2               
00FC65  2  20 BD FC     	jsr	SetTapeVector		; set the tape vector		[FCBD]
00FC68  2  D0 EA        	bne	A_FC54			; restore registers and exit interrupt,
00FC6A  2               					; branch always
00FC6A  2               
00FC6A  2               
00FC6A  2               ;******************************************************************************
00FC6A  2               ;
00FC6A  2               ; write tape leader IRQ routine
00FC6A  2               ;
00FC6A  2               TapeLeader_IRQ:				;				[FC6A]
00FC6A  2  A9 78        	lda	#$78			; set time constant LB for bit = leader
00FC6C  2  20 AF FB     	jsr	SetTimeHByte		; write time constant and toggle tape
00FC6F  2               					;				[FBAF]
00FC6F  2  D0 E3        	bne	A_FC54			; if tape bit high restore registers
00FC71  2               					; and exit interrupt
00FC71  2  C6 A7        	dec	INBIT			; decrement cycle count
00FC73  2  D0 DF        	bne	A_FC54			; if not all done restore registers and
00FC75  2               					; exit interrupt
00FC75  2  20 97 FB     	jsr	SetCounter		; new tape byte setup		[FB97]
00FC78  2               
00FC78  2  C6 AB        	dec	RIPRTY			; decrement cassette leader count
00FC7A  2  10 D8        	bpl	A_FC54			; if not all done restore registers and
00FC7C  2               					; exit interrupt
00FC7C  2  A2 0A        	ldx	#$0A			; set index for tape write vector
00FC7E  2  20 BD FC     	jsr	SetTapeVector		; set the tape vector		[FCBD]
00FC81  2               
00FC81  2  58           	cli				; enable the interrupts
00FC82  2               
00FC82  2  E6 AB        	inc	RIPRTY			; clear cassette leader counter, was $FF
00FC84  2               
00FC84  2  A5 BE        	lda	FSBLK			; get cassette block count
00FC86  2  F0 30        	beq	A_FCB8			; if all done restore everything for
00FC88  2               					; STOP and exit the interrupt
00FC88  2  20 8E FB     	jsr	CopyIoAdr2Buf		; copy I/O start address to buffer
00FC8B  2               					; address			[FB8E]
00FC8B  2  A2 09        	ldx	#$09			; set nine synchronisation bytes
00FC8D  2  86 A5        	stx	CNTDN			; save cassette synchron. byte count
00FC8F  2  86 B6        	stx	RODATA			;.
00FC91  2  D0 83        	bne	A_FC16			; go do next tape byte, branch always
00FC93  2               
00FC93  2               
00FC93  2               ;******************************************************************************
00FC93  2               ;
00FC93  2               ; restore everything for STOP
00FC93  2               ;
00FC93  2               StopUsingTape:				;				[FC93]
00FC93  2  08           	php				; save status
00FC94  2               
00FC94  2  78           	sei				; disable the interrupts
00FC95  2               
00FC95  2  AD 11 D0     	lda	VICCTR1			; read the vertical fine scroll and
00FC98  2               					; control register
00FC98  2  09 10        	ora	#$10			; unblank the screen
00FC9A  2  8D 11 D0     	sta	VICCTR1			; save the vertical fine scroll and
00FC9D  2               					; control register
00FC9D  2  20 CA FC     	jsr	StopTapeMotor		; stop the cassette motor	[FCCA]
00FCA0  2               
00FCA0  2  A9 7F        	lda	#$7F			; disable all interrupts
00FCA2  2  8D 0D DC     	sta	CIA1IRQ			; save CIA 1 ICR
00FCA5  2               
00FCA5  2  20 DD FD     	jsr	TimingPalNtsc		;.				[FDDD]
00FCA8  2               
00FCA8  2  AD A0 02     	lda	IRQTMP+1		; get saved IRQ vector HB
00FCAB  2  F0 09        	beq	A_FCB6			; branch if null
00FCAD  2               
00FCAD  2  8D 15 03     	sta	CINV+1			; restore IRQ vector HB
00FCB0  2               
00FCB0  2  AD 9F 02     	lda	IRQTMP			; get saved IRQ vector LB
00FCB3  2  8D 14 03     	sta	CINV			; restore IRQ vector LB
00FCB6  2               A_FCB6:					;				[FCB6]
00FCB6  2  28           	plp				; restore status
00FCB7  2               
00FCB7  2  60           	rts
00FCB8  2               
00FCB8  2               
00FCB8  2               ;******************************************************************************
00FCB8  2               ;
00FCB8  2               ; reset vector
00FCB8  2               ;
00FCB8  2               A_FCB8:					;				[FCB8]
00FCB8  2  20 93 FC     	jsr	StopUsingTape		; restore everything for STOP	[FC93]
00FCBB  2  F0 97        	beq	A_FC54			; restore registers and exit interrupt,
00FCBD  2               					; branch always
00FCBD  2               
00FCBD  2               ;******************************************************************************
00FCBD  2               ;
00FCBD  2               ; set tape vector
00FCBD  2               ;
00FCBD  2               SetTapeVector:				;				[FCBD]
00FCBD  2  BD 93 FD     	lda	TapeIrqVectors-8,X	; get tape IRQ vector LB
00FCC0  2  8D 14 03     	sta	CINV			; set IRQ vector LB
00FCC3  2               
00FCC3  2  BD 94 FD     	lda	TapeIrqVectors-7,X	; get tape IRQ vector HB
00FCC6  2  8D 15 03     	sta	CINV+1			; set IRQ vector HB
00FCC9  2               
00FCC9  2  60           	rts
00FCCA  2               
00FCCA  2               
00FCCA  2               ;******************************************************************************
00FCCA  2               ;
00FCCA  2               ; stop the cassette motor
00FCCA  2               ;
00FCCA  2               StopTapeMotor:				;				[FCCA]
00FCCA  2  A5 01        	lda	P6510			; read the 6510 I/O port
00FCCC  2  09 20        	ora	#$20			; mask xx1x, turn the cassette motor off
00FCCE  2  85 01        	sta	P6510			; save the 6510 I/O port
00FCD0  2               
00FCD0  2  60           	rts
00FCD1  2               
00FCD1  2               
00FCD1  2               ;******************************************************************************
00FCD1  2               ;
00FCD1  2               ; check read/write pointer
00FCD1  2               ; return Cb = 1 if pointer >= end
00FCD1  2               ;
00FCD1  2               ChkRdWrPtr:				;				[FCD1]
00FCD1  2  38           	sec				; set carry for subtract
00FCD2  2  A5 AC        	lda	SAL			; get buffer address LB
00FCD4  2  E5 AE        	sbc	EAL			; subtract buffer end LB
00FCD6  2               
00FCD6  2  A5 AD        	lda	SAL+1			; get buffer address HB
00FCD8  2  E5 AF        	sbc	EAL+1			; subtract buffer end HB
00FCDA  2               
00FCDA  2  60           	rts
00FCDB  2               
00FCDB  2               
00FCDB  2               ;******************************************************************************
00FCDB  2               ;
00FCDB  2               ; increment read/write pointer
00FCDB  2               ;
00FCDB  2               IncRdWrPtr:				;				[FCDB]
00FCDB  2  E6 AC        	inc	SAL			; increment buffer address LB
00FCDD  2  D0 02        	bne	A_FCE1			; branch if no overflow
00FCDF  2               
00FCDF  2  E6 AD        	inc	SAL+1			; increment buffer address LB
00FCE1  2               A_FCE1:					;				[FCE1]
00FCE1  2  60           	rts
00FCE2  2               
00FCE2  2               
00FCE2  2               ;******************************************************************************
00FCE2  2               ;
00FCE2  2               ; RESET, hardware reset starts here
00FCE2  2               ;
00FCE2  2               RESET_routine:				;				[FCE2]
00FCE2  2  A2 FF        	ldx	#$FF			; set X for stack
00FCE4  2  78           	sei				; disable the interrupts
00FCE5  2  9A           	txs				; clear stack
00FCE6  2               
00FCE6  2  D8           	cld				; clear decimal mode
00FCE7  2               
00FCE7  2  20 02 FD     	jsr	Chk4Cartridge		; scan for autostart ROM at $8000 [FD02]
00FCEA  2  D0 03        	bne	A_FCEF			; if not there continue startup
00FCEC  2               
00FCEC  2  6C 00 80     	jmp	(RomStart)		; else call ROM start code
00FCEF  2               
00FCEF  2               A_FCEF:					;				[FCEF]
00FCEF  2  8E 16 D0     	stx	VICCTR2			; read the horizontal fine scroll and
00FCF2  2               					;control register
00FCF2  2  20 A3 FD     	jsr	InitSidCIAIrq2		; initialise SID, CIA and IRQ	[FDA3]
00FCF5  2  20 50 FD     	jsr	TestRAM2		; RAM test and find RAM end	[FD50]
00FCF8  2  20 15 FD     	jsr	SetVectorsIO2		; restore default I/O vectors	[FD15]
00FCFB  2               .if KERNAL = 1
00FCFB  2               	jsr	InitScreenKeyb		;				[E518]
00FCFB  2               .endif
00FCFB  2               
00FCFB  2               .if KERNAL = 2 || KERNAL = 3
00FCFB  2  20 5B FF     	jsr	InitialiseVIC2		; initialise VIC and screen editor
00FCFE  2               .endif
00FCFE  2               
00FCFE  2  58           	cli				; enable the interrupts
00FCFF  2               
00FCFF  2  6C 00 A0     	jmp	(BasicCold)		; execute BASIC
00FD02  2               
00FD02  2               
00FD02  2               ;******************************************************************************
00FD02  2               ;
00FD02  2               ; scan for autostart ROM at $8000, returns Zb=1 if ROM found
00FD02  2               ;
00FD02  2               Chk4Cartridge:				;				[FD02]
00FD02  2  A2 05        	ldx	#$05			; five characters to test
00FD04  2               A_FD04:					;				[FD04]
00FD04  2  BD 0F FD     	lda	RomSignature-1,X	; get test character
00FD07  2  DD 03 80     	cmp	RomIdentStr-1,X		; compare wiith byte in ROM space
00FD0A  2  D0 03        	bne	D_FD0F			; exit if no match
00FD0C  2               
00FD0C  2  CA           	dex				; decrement index
00FD0D  2  D0 F5        	bne	A_FD04			; loop if not all done
00FD0F  2               
00FD0F  2               D_FD0F:					;				[FD0F]
00FD0F  2  60           	rts
00FD10  2               
00FD10  2               
00FD10  2               ;******************************************************************************
00FD10  2               ;
00FD10  2               ; autostart ROM signature
00FD10  2               ;
00FD10  2               RomSignature:				;				[FD10]
00FD10  2  C3 C2 CD 38  .byte	$C3,$C2,$CD,$38,$30		; CBM80
00FD14  2  30           
00FD15  2               
00FD15  2               
00FD15  2               ;******************************************************************************
00FD15  2               ;
00FD15  2               ; restore default I/O vectors
00FD15  2               ;
00FD15  2               ; This routine restores the default values of all system vectors used in KERNAL
00FD15  2               ; and BASIC routines and interrupts. The KERNAL VECTOR routine is used to read
00FD15  2               ; and alter individual system vectors.
00FD15  2               ;
00FD15  2               SetVectorsIO2:				;				[FD15]
00FD15  2  A2 30        	ldx	#<TblVectors		; pointer to vector table LB
00FD17  2  A0 FD        	ldy	#>TblVectors		; pointer to vector table HB
00FD19  2               S_FD19:
00FD19  2  18           	clc				; flag set vectors
00FD1A  2               
00FD1A  2               
00FD1A  2               ;******************************************************************************
00FD1A  2               ;
00FD1A  2               ; set/read vectored I/O from (XY), Cb = 1 to read, Cb = 0 to set
00FD1A  2               ;
00FD1A  2               ; this routine manages all system vector jump addresses stored in RAM. calling
00FD1A  2               ; this routine with the accumulator carry bit set will store the current
00FD1A  2               ; contents of the RAM vectors in a list pointed to by the X and Y registers.
00FD1A  2               ;
00FD1A  2               ; When this routine is called with the carry bit clear, the user list pointed
00FD1A  2               ; to by the X and Y registers is transferred to the system RAM vectors.
00FD1A  2               ;
00FD1A  2               ; NOTE: This routine requires caution in its use. The best way to use it is to
00FD1A  2               ; first read the entire vector contents into the user area, alter the desired
00FD1A  2               ; vectors, and then copy the contents back to the system vectors.
00FD1A  2               ;
00FD1A  2               CopyVectorsIO2:				;				[FD1A]
00FD1A  2  86 C3        	stx	MEMUSS			; save pointer LB
00FD1C  2  84 C4        	sty	MEMUSS+1		; save pointer HB
00FD1E  2  A0 1F        	ldy	#$1F			; set byte count
00FD20  2               A_FD20:					;				[FD20]
00FD20  2  B9 14 03     	lda	CINV,Y			; read vector byte from vectors
00FD23  2  B0 02        	bcs	A_FD27			; branch if read vectors
00FD25  2               
00FD25  2  B1 C3        	lda	(MEMUSS),Y		; read vector byte from (XY)
00FD27  2               A_FD27:					;				[FD27]
00FD27  2  91 C3        	sta	(MEMUSS),Y		; save byte to (XY)
00FD29  2  99 14 03     	sta	CINV,Y			; save byte to vector
00FD2C  2  88           	dey				; decrement index
00FD2D  2  10 F1        	bpl	A_FD20			; loop if more to do
00FD2F  2               
00FD2F  2  60           	rts
00FD30  2               
00FD30  2               ; The above code works but it tries to write to the ROM. while this is usually
00FD30  2               ; harmless systems that use flash ROM may suffer. Here is a version that makes
00FD30  2               ; the extra write to RAM instead but is otherwise identical in function. ##
00FD30  2               ;
00FD30  2               ; set/read vectored I/O from (XY), Cb = 1 to read, Cb = 0 to set
00FD30  2               ;
00FD30  2               ;CopyVectorsIO2
00FD30  2               ;	STX	MEMUSS			; save pointer LB
00FD30  2               ;	STY	MEMUSS+1		; save pointer HB
00FD30  2               ;	LDY	#$1F			; set byte count
00FD30  2               ;A_FD20:
00FD30  2               ;	LDA	(MEMUSS),Y		; read vector byte from (XY)
00FD30  2               ;	BCC	A_FD29			; branch if set vectors
00FD30  2               ;
00FD30  2               ;	LDA	CINV,Y			; else read vector byte from vectors
00FD30  2               ;	STA	(MEMUSS),Y		; save byte to (XY)
00FD30  2               ;A_FD29:
00FD30  2               ;	STA	CINV,Y			; save byte to vector
00FD30  2               ;	DEY				; decrement index
00FD30  2               ;	BPL	A_FD20			; loop if more to do
00FD30  2               ;
00FD30  2               ;	RTS
00FD30  2               
00FD30  2               
00FD30  2               ;******************************************************************************
00FD30  2               ;
00FD30  2               ; kernal vectors
00FD30  2               ;
00FD30  2               TblVectors:				;				[FD30]
00FD30  2  31 EA        .word	IRQ_vector		; CINV    IRQ vector
00FD32  2  66 FE        .word	BRK_vector		; BINV    BRK vector
00FD34  2  47 FE        .word	NMI_vector		; NMINV   NMI vector
00FD36  2  4A F3        .word	OpenLogFile2		; IOPEN   open a logical file
00FD38  2  91 F2        .word	CloseLogFile2		; ICLOSE  close a specified logical file
00FD3A  2  0E F2        .word	OpenChanInput		; ICHKIN  open channel for input
00FD3C  2  50 F2        .word	OpenChanOutput		; ICKOUT  open channel for output
00FD3E  2  33 F3        .word	CloseIoChans		; ICLRCH  close input and output channels
00FD40  2  57 F1        .word	ByteFromChan2		; IBASIN  input character from channel
00FD42  2  CA F1        .word	OutByteChan2		; IBSOUT  output character to channel
00FD44  2  ED F6        .word	Scan4StopKey		; ISTOP   scan stop key
00FD46  2  3E F1        .word	GetByteInpDev		; IGETIN  get character from the input device
00FD48  2  2F F3        .word	ClsAllChnFil		; ICLALL  close all channels and files
00FD4A  2  66 FE        .word	BRK_vector		; UserFn  user function
00FD4C  2               
00FD4C  2               
00FD4C  2               ; Vector to user defined command, currently points to BRK.
00FD4C  2               ;
00FD4C  2               ; This appears to be a holdover from PET days, when the built-in machine
00FD4C  2               ; language monitor would jump through the UserFn vector when it encountered a
00FD4C  2               ; command that it did not understand, allowing the user to add new commands to
00FD4C  2               ; the monitor.
00FD4C  2               ;
00FD4C  2               ; Although this vector is initialized to point to the routine called by
00FD4C  2               ; STOP/RESTORE and the BRK interrupt, and is updated by the kernal vector
00FD4C  2               ; routine at $FD57, it no longer has any function.
00FD4C  2               
00FD4C  2  A5 F4        .word	LoadRamFrmDev22			; ILOAD	load
00FD4E  2  ED F5        .word	SaveRamToDev22			; ISAVE	save
00FD50  2               
00FD50  2               
00FD50  2               ;******************************************************************************
00FD50  2               ;
00FD50  2               ; test RAM and find RAM end
00FD50  2               ;
00FD50  2               TestRAM2:				;				[FD50]
00FD50  2  A9 00        	lda	#$00			; clear A
00FD52  2  A8           	tay				; clear index
00FD53  2               A_FD53:					;				[FD53]
00FD53  2  99 02 00     	sta	D6510+2,Y		; clear page 0, don't do $0000 or $0001
00FD56  2  99 00 02     	sta	CommandBuf,Y		; clear page 2
00FD59  2  99 00 03     	sta	IERROR,Y		; clear page 3
00FD5C  2               
00FD5C  2  C8           	iny				; increment index
00FD5D  2  D0 F4        	bne	A_FD53			; loop if more to do
00FD5F  2               
00FD5F  2  A2 3C        	ldx	#<TapeBuffer		; set cassette buffer pointer LB
00FD61  2  A0 03        	ldy	#>TapeBuffer		; set cassette buffer pointer HB
00FD63  2  86 B2        	stx	TapeBufPtr		; save tape buffer start pointer LB
00FD65  2  84 B3        	sty	TapeBufPtr+1		; save tape buffer start pointer HB
00FD67  2               
00FD67  2  A8           	tay				; clear Y
00FD68  2               
00FD68  2  A9 03        	lda	#$03			; set RAM test pointer HB
00FD6A  2  85 C2        	sta	STAL+1			; save RAM test pointer HB
00FD6C  2               A_FD6C:					;				[FD6C]
00FD6C  2  E6 C2        	inc	STAL+1			; increment RAM test pointer HB
00FD6E  2               A_FD6E:					;				[FD6E]
00FD6E  2  B1 C1        	lda	(STAL),Y		;.
00FD70  2  AA           	tax				;.
00FD71  2               
00FD71  2  A9 55        	lda	#$55			;.
00FD73  2  91 C1        	sta	(STAL),Y		;.
00FD75  2  D1 C1        	cmp	(STAL),Y		;.
00FD77  2  D0 0F        	bne	A_FD88			;.
00FD79  2               
00FD79  2  2A           	rol				;.
00FD7A  2  91 C1        	sta	(STAL),Y		;.
00FD7C  2               
00FD7C  2  D1 C1        	cmp	(STAL),Y		;.
00FD7E  2  D0 08        	bne	A_FD88			;.
00FD80  2               
00FD80  2  8A           	txa				;.
00FD81  2  91 C1        	sta	(STAL),Y		;.
00FD83  2               
00FD83  2  C8           	iny				;.
00FD84  2  D0 E8        	bne	A_FD6E			;.
00FD86  2  F0 E4        	beq	A_FD6C			; always ->
00FD88  2               
00FD88  2               A_FD88:					;				[FD88]
00FD88  2  98           	tya				;.
00FD89  2  AA           	tax				;.
00FD8A  2               
00FD8A  2  A4 C2        	ldy	STAL+1			;.
00FD8C  2  18           	clc				;.
00FD8D  2  20 2D FE     	jsr	SetTopOfMem2		; set the top of memory		[FE2D]
00FD90  2               
00FD90  2  A9 08        	lda	#$08			;.
00FD92  2  8D 82 02     	sta	StartOfMem+1		; save the OS start of memory HB
00FD95  2               
00FD95  2  A9 04        	lda	#$04			;.
00FD97  2  8D 88 02     	sta	HIBASE			; save the screen memory page
00FD9A  2               
00FD9A  2  60           	rts
00FD9B  2               
00FD9B  2               
00FD9B  2               ;******************************************************************************
00FD9B  2               ;
00FD9B  2               ; tape IRQ vectors
00FD9B  2               ;
00FD9B  2               TapeIrqVectors:				;				[FD9B]
00FD9B  2  6A FC        .word	TapeLeader_IRQ			; $08	write tape leader IRQ routine
00FD9D  2  CD FB        .word	TapeWrite_IRQ			; $0A	tape write IRQ routine
00FD9F  2  31 EA        .word	IRQ_vector			; $0C	normal IRQ vector
00FDA1  2  2C F9        .word	TapeRead_IRQ			; $0E	read tape bits IRQ routine
00FDA3  2               
00FDA3  2               
00FDA3  2               ;******************************************************************************
00FDA3  2               ;
00FDA3  2               ; initialise SID, CIA and IRQ
00FDA3  2               ;
00FDA3  2               InitSidCIAIrq2:				;				[FDA3]
00FDA3  2  A9 7F        	lda	#$7F			; disable all interrupts
00FDA5  2  8D 0D DC     	sta	CIA1IRQ			; save CIA 1 ICR
00FDA8  2  8D 0D DD     	sta	CIA2IRQ			; save CIA 2 ICR
00FDAB  2  8D 00 DC     	sta	CIA1DRA			; save CIA 1 DRA, keyboard column drive
00FDAE  2               
00FDAE  2  A9 08        	lda	#$08			; set timer single shot
00FDB0  2  8D 0E DC     	sta	CIA1CTR1		; save CIA 1 CRA
00FDB3  2  8D 0E DD     	sta	CIA2CTR1		; save CIA 2 CRA
00FDB6  2  8D 0F DC     	sta	CIA1CTR2		; save CIA 1 CRB
00FDB9  2  8D 0F DD     	sta	CIA2CTR2		; save CIA 2 CRB
00FDBC  2               
00FDBC  2  A2 00        	ldx	#$00			; set all inputs
00FDBE  2  8E 03 DC     	stx	CIA1DDRB		; save CIA 1 DDRB, keyboard row
00FDC1  2  8E 03 DD     	stx	CIA2DDRB		; save CIA 2 DDRB, RS232 port
00FDC4  2  8E 18 D4     	stx	SIDFMVO			; clear the volume and filter select
00FDC7  2               					; register
00FDC7  2               
00FDC7  2  CA           	dex				; set X = $FF
00FDC8  2  8E 02 DC     	stx	CIA1DDRA		; save CIA 1 DDRA, keyboard column
00FDCB  2               
00FDCB  2  A9 07        	lda	#$07			; DATA out high, CLK out high, ATN out
00FDCD  2               					; high, RE232 Tx DATA, high, video
00FDCD  2               					; address 15 = 1, video address 14 = 1
00FDCD  2  8D 00 DD     	sta	CIA2DRA			; save CIA 2 DRA, serial port and video
00FDD0  2               					; address
00FDD0  2  A9 3F        	lda	#$3F			; set serial DATA and serial CLK input
00FDD2  2  8D 02 DD     	sta	CIA2DDRA		; save CIA 2 DDRA, serial port and video
00FDD5  2               					; address
00FDD5  2  A9 E7        	lda	#$E7			; set 1110 0111, motor off, enable I/O,
00FDD7  2               					; enable KERNAL, enable BASIC
00FDD7  2  85 01        	sta	P6510			; save the 6510 I/O port
00FDD9  2               
00FDD9  2  A9 2F        	lda	#$2F			; set 0010 1111, 0 = input, 1 = output
00FDDB  2  85 00        	sta	D6510			; save 6510 I/O port direction register
00FDDD  2               TimingPalNtsc:				;				[FDDD]
00FDDD  2               .if KERNAL = 1
00FDDD  2               	lda	#$1B
00FDDD  2               	sta	CIA1TI1L
00FDDD  2               
00FDDD  2               	lda	#$41
00FDDD  2               	sta	CIA1TI1H
00FDDD  2               
00FDDD  2               	lda	#$81
00FDDD  2               	sta	CIA1IRQ
00FDDD  2               
00FDDD  2               	lda	CIA1CTR1
00FDDD  2               	and	#$80
00FDDD  2               	ora	#$11
00FDDD  2               	sta	CIA1CTR1
00FDDD  2               
00FDDD  2               	jmp	IecClockL		;				[EE8E]
00FDDD  2               .endif
00FDDD  2               
00FDDD  2               .if KERNAL = 2 || KERNAL = 3
00FDDD  2  AD A6 02     	lda	PALNTSC			; get the PAL/NTSC flag
00FDE0  2  F0 0A        	beq	A_FDEC			; if NTSC go set NTSC timing
00FDE2  2               
00FDE2  2               ; else set PAL timing
00FDE2  2  A9 25        	lda	#$25			;.
00FDE4  2  8D 04 DC     	sta	CIA1TI1L		; save CIA 1 timer A LB
00FDE7  2               
00FDE7  2  A9 40        	lda	#$40			;.
00FDE9  2  4C F3 FD     	jmp	J_FDF3			;.				[FDF3]
00FDEC  2               
00FDEC  2               A_FDEC:					;				[FDEC]
00FDEC  2  A9 95        	lda	#$95			;.
00FDEE  2  8D 04 DC     	sta	CIA1TI1L		; save CIA 1 timer A LB
00FDF1  2               
00FDF1  2  A9 42        	lda	#$42			;.
00FDF3  2               J_FDF3:					;				[FDF3]
00FDF3  2  8D 05 DC     	sta	CIA1TI1H		; save CIA 1 timer A HB
00FDF6  2               
00FDF6  2  4C 6E FF     	jmp	SetTimerIRQ		;.				[FF6E]
00FDF9  2               .endif
00FDF9  2               
00FDF9  2               
00FDF9  2               ;******************************************************************************
00FDF9  2               ;
00FDF9  2               ; set filename
00FDF9  2               ;
00FDF9  2               ; this routine is used to set up the filename for the OPEN, SAVE, or LOAD
00FDF9  2               ; routines. The accumulator must be loaded with the length of the file and XY
00FDF9  2               ; with the pointer to filename, X being the LB. The address can be any
00FDF9  2               ; valid memory address in the system where a string of characters for the file
00FDF9  2               ; name is stored. If no filename desired the accumulator must be set to 0,
00FDF9  2               ; representing a zero file length, in that case  XY may be set to any memory
00FDF9  2               ; address.
00FDF9  2               ;
00FDF9  2               SetFileName2:				;				[FDF9]
00FDF9  2  85 B7        	sta	FNLEN			; set filename length
00FDFB  2  86 BB        	stx	FNADR			; set filename pointer LB
00FDFD  2  84 BC        	sty	FNADR+1			; set filename pointer HB
00FDFF  2               
00FDFF  2  60           	rts
00FE00  2               
00FE00  2               
00FE00  2               ;******************************************************************************
00FE00  2               ;
00FE00  2               ; set logical, first and second addresses
00FE00  2               ;
00FE00  2               ; this routine will set the logical file number, device address, and secondary
00FE00  2               ; address, command number, for other KERNAL routines.
00FE00  2               ;
00FE00  2               ; the logical file number is used by the system as a key to the file table
00FE00  2               ; created by the OPEN file routine. Device addresses can range from 0 to 30.
00FE00  2               ; The following codes are used by the computer to stand for the following CBM
00FE00  2               ; devices:
00FE00  2               ;
00FE00  2               ; ADDRESS	DEVICE
00FE00  2               ; =======	======
00FE00  2               ;  0		Keyboard
00FE00  2               ;  1		Cassette #1
00FE00  2               ;  2		RS-232C device
00FE00  2               ;  3		CRT display
00FE00  2               ;  4		Serial bus printer
00FE00  2               ;  8		CBM Serial bus disk drive
00FE00  2               ;
00FE00  2               ; device numbers of four or greater automatically refer to devices on the
00FE00  2               ; serial bus.
00FE00  2               ;
00FE00  2               ; a command to the device is sent as a secondary address on the serial bus
00FE00  2               ; after the device number is sent during the serial attention handshaking
00FE00  2               ; sequence. If no secondary address is to be sent Y should be set to $FF.
00FE00  2               ;
00FE00  2               SetAddresses2:				;				[FE00]
00FE00  2  85 B8        	sta	LA			; save the logical file
00FE02  2  86 BA        	stx	FA			; save the device number
00FE04  2  84 B9        	sty	SA			; save the secondary address
00FE06  2               
00FE06  2  60           	rts
00FE07  2               
00FE07  2               
00FE07  2               ;******************************************************************************
00FE07  2               ;
00FE07  2               ; read I/O status word
00FE07  2               ;
00FE07  2               ; this routine returns the current status of the I/O device in the accumulator.
00FE07  2               ; The routine is usually called after new communication to an I/O device. The
00FE07  2               ; routine will give information about device status, or errors that have
00FE07  2               ; occurred during the I/O operation.
00FE07  2               ;
00FE07  2               ReadIoStatus2:				;				[FE07]
00FE07  2  A5 BA        	lda	FA			; get the device number
00FE09  2  C9 02        	cmp	#$02			; compare device with RS232 device
00FE0B  2  D0 0D        	bne	A_FE1A			; if not RS232 device go ??
00FE0D  2               
00FE0D  2               ; get RS232 device status
00FE0D  2  AD 97 02     	lda	RSSTAT			; get the RS232 status register
00FE10  2  48           	pha				; save the RS232 status value
00FE11  2               
00FE11  2  A9 00        	lda	#$00			; clear A
00FE13  2  8D 97 02     	sta	RSSTAT			; clear the RS232 status register
00FE16  2               
00FE16  2  68           	pla				; restore the RS232 status value
00FE17  2  60           	rts
00FE18  2               
00FE18  2               
00FE18  2               ;******************************************************************************
00FE18  2               ;
00FE18  2               ; control kernal messages
00FE18  2               ;
00FE18  2               ; this routine controls the printing of error and control messages by the
00FE18  2               ; KERNAL. Either print error messages or print control messages can be selected
00FE18  2               ; by setting the accumulator when the routine is called.
00FE18  2               ;
00FE18  2               ; FILE NOT FOUND is an example of an error message. PRESS PLAY ON CASSETTE is
00FE18  2               ; an example of a control message.
00FE18  2               ;
00FE18  2               ; bits 6 and 7 of this value determine where the message will come from. If bit
00FE18  2               ; 7 is set one of the error messages from the KERNAL will be printed. If bit 6
00FE18  2               ; is set a control message will be printed.
00FE18  2               ;
00FE18  2               CtrlKernalMsg2:				;				[FE18]
00FE18  2  85 9D        	sta	MSGFLG			; set message mode flag
00FE1A  2               A_FE1A:					;				[FE1A]
00FE1A  2  A5 90        	lda	STATUS			; read the serial status byte
00FE1C  2               
00FE1C  2               
00FE1C  2               ;******************************************************************************
00FE1C  2               ;
00FE1C  2               ; OR into the serial status byte
00FE1C  2               ;
00FE1C  2               AorIecStatus:				;				[FE1C]
00FE1C  2  05 90        	ora	STATUS			; OR with the serial status byte
00FE1E  2  85 90        	sta	STATUS			; save the serial status byte
00FE20  2               
00FE20  2  60           	rts
00FE21  2               
00FE21  2               
00FE21  2               ;******************************************************************************
00FE21  2               ;
00FE21  2               ; set timeout on serial bus
00FE21  2               ;
00FE21  2               ; this routine sets the timeout flag for the serial bus. When the timeout flag
00FE21  2               ; is set, the computer will wait for a device on the serial port for 64
00FE21  2               ; milliseconds. If the device does not respond to the computer's DAV signal
00FE21  2               ; within that time the computer will recognize an error condition and leave the
00FE21  2               ; handshake sequence. When this routine is called and the accumulator contains
00FE21  2               ; a 0 in bit 7, timeouts are enabled. A 1 in bit 7 will disable the timeouts.
00FE21  2               ;
00FE21  2               ; NOTE: The the timeout feature is used to communicate that a disk file is not
00FE21  2               ; found on an attempt to OPEN a file.
00FE21  2               ;
00FE21  2               IecTimeout2:				;				[FE21]
00FE21  2  8D 85 02     	sta	TIMOUT			; save serial bus timeout flag
00FE24  2               
00FE24  2  60           	rts
00FE25  2               
00FE25  2               
00FE25  2               ;******************************************************************************
00FE25  2               ;
00FE25  2               ; read/set the top of memory, Cb = 1 to read, Cb = 0 to set
00FE25  2               ;
00FE25  2               ; this routine is used to read and set the top of RAM. When this routine is
00FE25  2               ; called with the carry bit set the pointer to the top of RAM will be loaded
00FE25  2               ; into XY. When this routine is called with the carry bit clear XY will be
00FE25  2               ; saved as the top of memory pointer changing the top of memory.
00FE25  2               ;
00FE25  2               TopOfMem2:				;				[FE25]
00FE25  2  90 06        	bcc	SetTopOfMem2		; if Cb clear go set the top of memory
00FE27  2               
00FE27  2               
00FE27  2               ;******************************************************************************
00FE27  2               ;
00FE27  2               ; read the top of memory
00FE27  2               ;
00FE27  2               ReadTopOfMem:				;				[FE27]
00FE27  2  AE 83 02     	ldx	EndOfMem		; get memory top LB
00FE2A  2  AC 84 02     	ldy	EndOfMem+1		; get memory top HB
00FE2D  2               
00FE2D  2               
00FE2D  2               ;******************************************************************************
00FE2D  2               ;
00FE2D  2               ; set the top of memory
00FE2D  2               ;
00FE2D  2               SetTopOfMem2:				;				[FE2D]
00FE2D  2  8E 83 02     	stx	EndOfMem		; set memory top LB
00FE30  2  8C 84 02     	sty	EndOfMem+1		; set memory top HB
00FE33  2               
00FE33  2  60           	rts
00FE34  2               
00FE34  2               
00FE34  2               ;******************************************************************************
00FE34  2               ;
00FE34  2               ; read/set the bottom of memory, Cb = 1 to read, Cb = 0 to set
00FE34  2               ;
00FE34  2               ; this routine is used to read and set the bottom of RAM. When this routine is
00FE34  2               ; called with the carry bit set the pointer to the bottom of RAM will be loaded
00FE34  2               ; into XY. When this routine is called with the carry bit clear XY will be
00FE34  2               ; saved as the bottom of memory pointer changing the bottom of memory.
00FE34  2               ;
00FE34  2               BottomOfMem2:				;				[FE34]
00FE34  2  90 06        	bcc	A_FE3C			; if Cb clear go set bottom of memory
00FE36  2               
00FE36  2  AE 81 02     	ldx	StartOfMem		; get the OS start of memory LB
00FE39  2  AC 82 02     	ldy	StartOfMem+1		; get the OS start of memory HB
00FE3C  2               
00FE3C  2               ; set the bottom of memory
00FE3C  2               A_FE3C:					;				[FE3C]
00FE3C  2  8E 81 02     	stx	StartOfMem		; save the OS start of memory LB
00FE3F  2  8C 82 02     	sty	StartOfMem+1		; save the OS start of memory HB
00FE42  2               
00FE42  2  60           	rts
00FE43  2               
00FE43  2               
00FE43  2               ;******************************************************************************
00FE43  2               ;
00FE43  2               ; NMI vector
00FE43  2               ;
00FE43  2               NMI_routine:				;				[FE43]
00FE43  2  78           	sei				; disable the interrupts
00FE44  2               
00FE44  2  6C 18 03     	jmp	(NMINV)			; do NMI vector
00FE47  2               
00FE47  2               
00FE47  2               ;******************************************************************************
00FE47  2               ;
00FE47  2               ; NMI handler
00FE47  2               ;
00FE47  2               NMI_vector:				;				[FE47]
00FE47  2  48           	pha				; save A
00FE48  2               
00FE48  2  8A           	txa				; copy X
00FE49  2  48           	pha				; save X
00FE4A  2               
00FE4A  2  98           	tya				; copy Y
00FE4B  2  48           	pha				; save Y
00FE4C  2               
00FE4C  2  A9 7F        	lda	#$7F			; disable all interrupts
00FE4E  2  8D 0D DD     	sta	CIA2IRQ			; save CIA 2 ICR
00FE51  2               
00FE51  2  AC 0D DD     	ldy	CIA2IRQ			; NMI from RS-232 ?
00FE54  2  30 1C        	bmi	RS232_NMI		; yes, ->
00FE56  2               
00FE56  2  20 02 FD     	jsr	Chk4Cartridge		; scan for autostart ROM at $8000 [FD02]
00FE59  2  D0 03        	bne	A_FE5E			; branch if no autostart ROM
00FE5B  2               
00FE5B  2  6C 02 80     	jmp	(RomIRQ)		; else do autostart ROM break entry
00FE5E  2               
00FE5E  2               A_FE5E:					;				[FE5E]
00FE5E  2  20 BC F6     	jsr	IncrClock22		; increment real time clock	[F6BC]
00FE61  2               
00FE61  2  20 E1 FF     	jsr	ScanStopKey		; scan stop key			[FFE1]
00FE64  2  D0 0C        	bne	RS232_NMI		; if not [STOP] restore registers and
00FE66  2               					; exit interrupt
00FE66  2               
00FE66  2               
00FE66  2               ;******************************************************************************
00FE66  2               ;
00FE66  2               ; user function default vector
00FE66  2               ; BRK handler
00FE66  2               ;
00FE66  2               BRK_vector:				;				[FE66]
00FE66  2  20 15 FD     	jsr	SetVectorsIO2		; restore default I/O vectors	[FD15]
00FE69  2  20 A3 FD     	jsr	InitSidCIAIrq2		; initialise SID, CIA and IRQ	[FDA3]
00FE6C  2  20 18 E5     	jsr	InitScreenKeyb		; initialise the screen and keyboard
00FE6F  2               					;				[E518]
00FE6F  2  6C 02 A0     	jmp	(BasicNMI)		; do BASIC break entry
00FE72  2               
00FE72  2               
00FE72  2               ;******************************************************************************
00FE72  2               ;
00FE72  2               ; RS232 NMI routine
00FE72  2               ;
00FE72  2               RS232_NMI:				;				[FE72]
00FE72  2  98           	tya				;.
00FE73  2  2D A1 02     	and	ENABL			; AND with RS-232 interrupt enable byte
00FE76  2  AA           	tax				;.
00FE77  2               
00FE77  2  29 01        	and	#$01			;.
00FE79  2  F0 28        	beq	A_FEA3			;.
00FE7B  2               
00FE7B  2  AD 00 DD     	lda	CIA2DRA			; read CIA 2 DRA, serial port and video
00FE7E  2               					; address
00FE7E  2  29 FB        	and	#$FB			; mask x0xx, clear RS232 Tx DATA
00FE80  2  05 B5        	ora	NXTBIT			; OR in the RS232 transmit data bit
00FE82  2  8D 00 DD     	sta	CIA2DRA			; save CIA 2 DRA, serial port and video
00FE85  2               					; address
00FE85  2  AD A1 02     	lda	ENABL			; get RS-232 interrupt enable byte
00FE88  2  8D 0D DD     	sta	CIA2IRQ			; save CIA 2 ICR
00FE8B  2               
00FE8B  2  8A           	txa				;.
00FE8C  2  29 12        	and	#$12			;.
00FE8E  2  F0 0D        	beq	J_FE9D			;.
00FE90  2               
00FE90  2  29 02        	and	#$02			;.
00FE92  2  F0 06        	beq	A_FE9A			;.
00FE94  2               
00FE94  2  20 D6 FE     	jsr	ReadFromRS232		;.				[FED6]
00FE97  2  4C 9D FE     	jmp	J_FE9D			;.				[FE9D]
00FE9A  2               
00FE9A  2               A_FE9A:					;				[FE9A]
00FE9A  2  20 07 FF     	jsr	WriteToRS232		;.				[FF07]
00FE9D  2               J_FE9D:					;				[FE9D]
00FE9D  2  20 BB EE     	jsr	RS232_TX_NMI		;.				[EEBB]
00FEA0  2  4C B6 FE     	jmp	J_FEB6			;.				[FEB6]
00FEA3  2               
00FEA3  2               A_FEA3:					;				[FEA3]
00FEA3  2  8A           	txa				; get active interrupts back
00FEA4  2  29 02        	and	#$02			; mask ?? interrupt
00FEA6  2  F0 06        	beq	A_FEAE			; branch if not ?? interrupt
00FEA8  2               
00FEA8  2               ; was ?? interrupt
00FEA8  2  20 D6 FE     	jsr	ReadFromRS232		;.				[FED6]
00FEAB  2  4C B6 FE     	jmp	J_FEB6			;.				[FEB6]
00FEAE  2               
00FEAE  2               A_FEAE:					;				[FEAE]
00FEAE  2  8A           	txa				; get active interrupts back
00FEAF  2  29 10        	and	#$10			; mask CB1 interrupt, Rx data bit
00FEB1  2               					; transition
00FEB1  2  F0 03        	beq	J_FEB6			; if no bit restore registers and exit
00FEB3  2               					; interrupt
00FEB3  2  20 07 FF     	jsr	WriteToRS232		;.				[FF07]
00FEB6  2               J_FEB6:					;				[FEB6]
00FEB6  2  AD A1 02     	lda	ENABL			; get RS-232 interrupt enable byte
00FEB9  2  8D 0D DD     	sta	CIA2IRQ			; save CIA 2 ICR
00FEBC  2               End_RS232_NMI:				;				[FEBC]
00FEBC  2  68           	pla				; pull Y
00FEBD  2  A8           	tay				; restore Y
00FEBE  2               
00FEBE  2  68           	pla				; pull X
00FEBF  2  AA           	tax				; restore X
00FEC0  2               
00FEC0  2  68           	pla				; restore A
00FEC1  2               
00FEC1  2  40           	rti
00FEC2  2               
00FEC2  2               
00FEC2  2               ;******************************************************************************
00FEC2  2               ;
00FEC2  2               ; baud rate word is calculated from ..
00FEC2  2               ;
00FEC2  2               ; (system clock / baud rate) / 2 - 100
00FEC2  2               ;
00FEC2  2               ;		system clock
00FEC2  2               ;		------------
00FEC2  2               ; PAL		  985248 Hz
00FEC2  2               ; NTSC	 	 1022727 Hz
00FEC2  2               ;
00FEC2  2               ; baud rate tables for NTSC C64
00FEC2  2               ;
00FEC2  2               TblBaudNTSC:				;				[FEC2]
00FEC2  2               .if KERNAL = 1
00FEC2  2               .byte $AC, $26, $A7, $19, $5D, $11, $1F, $0E
00FEC2  2               .byte $A1, $0C, $1F, $06, $DD, $02, $3D, $01
00FEC2  2               .byte $B2, $00, $6C, $00
00FEC2  2               .endif
00FEC2  2               
00FEC2  2               .if KERNAL = 2 || KERNAL = 3
00FEC2  2  C1 27        .word	$27C1				;   50   baud	1027700
00FEC4  2  3E 1A        .word	$1A3E				;   75   baud	1022700
00FEC6  2  C5 11        .word	$11C5				;  110   baud	1022780
00FEC8  2  74 0E        .word	$0E74				;  134.5 baud	1022200
00FECA  2  ED 0C        .word	$0CED				;  150   baud	1022700
00FECC  2  45 06        .word	$0645				;  300   baud	1023000
00FECE  2  F0 02        .word	$02F0				;  600   baud	1022400
00FED0  2  46 01        .word	$0146				; 1200   baud	1022400
00FED2  2  B8 00        .word	$00B8				; 1800   baud	1022400
00FED4  2  71 00        .word	$0071				; 2400   baud	1022400
00FED6  2               .endif
00FED6  2               
00FED6  2               
00FED6  2               ;******************************************************************************
00FED6  2               ;
00FED6  2               ; Read from RS-232
00FED6  2               ;
00FED6  2               ReadFromRS232:				;				[FED6]
00FED6  2  AD 01 DD     	lda	CIA2DRB			; read CIA 2 DRB, RS232 port
00FED9  2  29 01        	and	#$01			; mask 0000 000x, RS232 Rx DATA
00FEDB  2  85 A7        	sta	INBIT			; save the RS232 received data bit
00FEDD  2               
00FEDD  2  AD 06 DD     	lda	CIA2TI2L		; get CIA 2 timer B LB
00FEE0  2  E9 1C        	sbc	#$1C			;.
00FEE2  2  6D 99 02     	adc	BAUDOF			;.
00FEE5  2  8D 06 DD     	sta	CIA2TI2L		; save CIA 2 timer B LB
00FEE8  2               
00FEE8  2  AD 07 DD     	lda	CIA2TI2H		; get CIA 2 timer B HB
00FEEB  2  6D 9A 02     	adc	BAUDOF+1		;.
00FEEE  2  8D 07 DD     	sta	CIA2TI2H		; save CIA 2 timer B HB
00FEF1  2               
00FEF1  2  A9 11        	lda	#$11			; set timer B single shot, start timer B
00FEF3  2  8D 0F DD     	sta	CIA2CTR2		; save CIA 2 CRB
00FEF6  2               
00FEF6  2  AD A1 02     	lda	ENABL			; get RS-232 interrupt enable byte
00FEF9  2  8D 0D DD     	sta	CIA2IRQ			; save CIA 2 ICR
00FEFC  2               
00FEFC  2  A9 FF        	lda	#$FF			;.
00FEFE  2  8D 06 DD     	sta	CIA2TI2L		; save CIA 2 timer B LB
00FF01  2  8D 07 DD     	sta	CIA2TI2H		; save CIA 2 timer B HB
00FF04  2               
00FF04  2  4C 59 EF     	jmp	RS232_RX_NMI		;.				[EF59]
00FF07  2               
00FF07  2               
00FF07  2               
00FF07  2               ;******************************************************************************
00FF07  2               ;
00FF07  2               ; Write to RS-232
00FF07  2               ;
00FF07  2               WriteToRS232:				;				[FF07]
00FF07  2               .if KERNAL = 1
00FF07  2               	lda	M51CTR
00FF07  2               	and	#$0F
00FF07  2               	bne	A_FF1A
00FF07  2               
00FF07  2               	lda	M51AJB
00FF07  2               	sta	CIA2TI2L
00FF07  2               
00FF07  2               	lda	M51AJB+1
00FF07  2               	jmp	J_FF25			;				[FF25]
00FF07  2               
00FF07  2               A_FF1A:					;				[FF1A]
00FF07  2               	asl	A
00FF07  2               	tax
00FF07  2               	lda	TblBaudNTSC-2,X
00FF07  2               	sta	CIA2TI2L
00FF07  2               
00FF07  2               	lda	TblBaudNTSC-1,X
00FF07  2               J_FF25:					;				[FF25]
00FF07  2               	sta	CIA2TI2H
00FF07  2               
00FF07  2               	lda	#$11
00FF07  2               	sta	CIA2CTR2
00FF07  2               
00FF07  2               	lda	#$12
00FF07  2               	eor	ENABL
00FF07  2               	sta	ENABL
00FF07  2               
00FF07  2               	lda	#$FF
00FF07  2               	sta	CIA2TI2L
00FF07  2               	sta	CIA2TI2H
00FF07  2               
00FF07  2               	ldx	BITNUM
00FF07  2               	stx	BITCI
00FF07  2               
00FF07  2               	rts
00FF07  2               .endif
00FF07  2               
00FF07  2               .if KERNAL = 2 || KERNAL = 3
00FF07  2  AD 95 02     	lda	M51AJB			; nonstandard bit timing LB
00FF0A  2  8D 06 DD     	sta	CIA2TI2L		; save CIA 2 timer B LB
00FF0D  2               
00FF0D  2  AD 96 02     	lda	M51AJB+1		; nonstandard bit timing HB
00FF10  2  8D 07 DD     	sta	CIA2TI2H		; save CIA 2 timer B HB
00FF13  2               
00FF13  2  A9 11        	lda	#$11			; set timer B single shot, start timer B
00FF15  2  8D 0F DD     	sta	CIA2CTR2		; save CIA 2 CRB
00FF18  2               
00FF18  2  A9 12        	lda	#$12			;.
00FF1A  2  4D A1 02     	eor	ENABL			; EOR with RS-232 interrupt enable byte
00FF1D  2  8D A1 02     	sta	ENABL			; save RS-232 interrupt enable byte
00FF20  2               
00FF20  2  A9 FF        	lda	#$FF			;.
00FF22  2  8D 06 DD     	sta	CIA2TI2L		; save CIA 2 timer B LB
00FF25  2  8D 07 DD     	sta	CIA2TI2H		; save CIA 2 timer B HB
00FF28  2               
00FF28  2  AE 98 02     	ldx	BITNUM			;.
00FF2B  2  86 A8        	stx	BITCI			;.
00FF2D  2               
00FF2D  2  60           	rts
00FF2E  2               
00FF2E  2               
00FF2E  2               ;******************************************************************************
00FF2E  2               ;
00FF2E  2               ; Set the timer for the Baud rate
00FF2E  2               ;
00FF2E  2               SetTimerBaudR:				;				[FF2E]
00FF2E  2  AA           	tax				;.
00FF2F  2               
00FF2F  2  AD 96 02     	lda	M51AJB+1		; nonstandard bit timing HB
00FF32  2  2A           	rol				;.
00FF33  2  A8           	tay				;.
00FF34  2               
00FF34  2  8A           	txa				;.
00FF35  2  69 C8        	adc	#$C8			;.
00FF37  2  8D 99 02     	sta	BAUDOF			;.
00FF3A  2               
00FF3A  2  98           	tya				;.
00FF3B  2  69 00        	adc	#$00			; add any carry
00FF3D  2  8D 9A 02     	sta	BAUDOF+1		;.
00FF40  2               
00FF40  2  60           	rts
00FF41  2               
00FF41  2               
00FF41  2               ;S_FF41
00FF41  2  EA           	nop				; waste cycles
00FF42  2  EA           	nop				; waste cycles
00FF43  2               .endif
00FF43  2               
00FF43  2               
00FF43  2               ;******************************************************************************
00FF43  2               ;
00FF43  2               ; save the status and do the IRQ routine
00FF43  2               ;
00FF43  2               SaveStatGoIRQ:				;				[FF43]
00FF43  2  08           	php				; save the processor status
00FF44  2               
00FF44  2  68           	pla				; pull the processor status
00FF45  2  29 EF        	and	#$EF			; mask xxx0, clear the break bit
00FF47  2  48           	pha				; save the modified processor status
00FF48  2               
00FF48  2               
00FF48  2               ;******************************************************************************
00FF48  2               ;
00FF48  2               ; IRQ vector
00FF48  2               ;
00FF48  2               IRQ_routine:				;				[FF48]
00FF48  2  48           	pha				; save A
00FF49  2               
00FF49  2  8A           	txa				; copy X
00FF4A  2  48           	pha				; save X
00FF4B  2               
00FF4B  2  98           	tya				; copy Y
00FF4C  2  48           	pha				; save Y
00FF4D  2               
00FF4D  2  BA           	tsx				; copy stack pointer
00FF4E  2  BD 04 01     	lda	STACK+4,X		; get stacked status register
00FF51  2  29 10        	and	#$10			; mask BRK flag
00FF53  2  F0 03        	beq	A_FF58			; branch if not BRK
00FF55  2               
00FF55  2  6C 16 03     	jmp	(BINV)			; else do BRK vector (iBRK)
00FF58  2               
00FF58  2               A_FF58:					;				[FF58]
00FF58  2  6C 14 03     	jmp	(CINV)			; do IRQ vector (iIRQ)
00FF5B  2               
00FF5B  2               
00FF5B  2               .if KERNAL = 1
00FF5B  2               .res 38,$AA ;.fb $AA,38				;				[FF5B]
00FF5B  2               
00FF5B  2               
00FF5B  2               InitialiseVIC:				;				[FF81]
00FF5B  2               	jmp	InitScreenKeyb		;				[E518]
00FF5B  2               .endif
00FF5B  2               
00FF5B  2               .if KERNAL = 2 || KERNAL = 3
00FF5B  2               ;******************************************************************************
00FF5B  2               ;
00FF5B  2               ; initialise VIC and screen editor
00FF5B  2               ;
00FF5B  2               InitialiseVIC2:				;				[FF5B]
00FF5B  2  20 18 E5     	jsr	InitScreenKeyb		; initialise the screen and keyboard
00FF5E  2               					;				[E518]
00FF5E  2               A_FF5E:					;				[FF5E]
00FF5E  2  AD 12 D0     	lda	VICLINE			; read the raster compare register
00FF61  2  D0 FB        	bne	A_FF5E			; loop if not raster line $00
00FF63  2               A_FF63:					;				[FF63]
00FF63  2  AD 19 D0     	lda	VICIRQ			; read the vic interrupt flag register
00FF66  2  29 01        	and	#$01			; mask the raster compare flag
00FF68  2  8D A6 02     	sta	PALNTSC			; save the PAL/NTSC flag
00FF6B  2  4C DD FD     	jmp	TimingPalNtsc		;.				[FDDD]
00FF6E  2               
00FF6E  2               
00FF6E  2               ;******************************************************************************
00FF6E  2               ;
00FF6E  2               ; Set the timer that generates the interrupts
00FF6E  2               ;
00FF6E  2               SetTimerIRQ:				;				[FF6E]
00FF6E  2  A9 81        	lda	#$81			; enable timer A interrupt
00FF70  2  8D 0D DC     	sta	CIA1IRQ			; save CIA 1 ICR
00FF73  2               
00FF73  2  AD 0E DC     	lda	CIA1CTR1		; read CIA 1 CRA
00FF76  2  29 80        	and	#$80			; mask x000 0000, TOD clock
00FF78  2  09 11        	ora	#$11			; mask xxx1 xxx1, load timer A, start
00FF7A  2               					; timer A
00FF7A  2  8D 0E DC     	sta	CIA1CTR1		; save CIA 1 CRA
00FF7D  2               
00FF7D  2  4C 8E EE     	jmp	IecClockL		; set the serial clock out low and
00FF80  2               					; return			[EE8E]
00FF80  2               
00FF80  2               .if KERNAL = 2
00FF80  2               FF80:	.byte	$00			; checksum ??
00FF80  2               .endif
00FF80  2               
00FF80  2               .if KERNAL = 3
00FF80  2  03           FF80:	.byte	$03			; checksum ??
00FF81  2               .endif
00FF81  2               
00FF81  2               
00FF81  2  4C 5B FF     	jmp	InitialiseVIC2		; initialise VIC and screen editor
00FF84  2               .endif
00FF84  2               
00FF84  2               
00FF84  2               ;******************************************************************************
00FF84  2               ;
00FF84  2               ; initialise SID, CIA and IRQ, unused
00FF84  2               ;
00FF84  2               InitSidCIAIrq:				;				[FF84]
00FF84  2  4C A3 FD     	jmp	InitSidCIAIrq2		; initialise SID, CIA and IRQ	[FDA3]
00FF87  2               
00FF87  2               
00FF87  2               ;******************************************************************************
00FF87  2               ;
00FF87  2               ; RAM test and find RAM end
00FF87  2               ;					;				[FF87]
00FF87  2  4C 50 FD     	jmp	TestRAM2		; RAM test and find RAM end	[FD50]
00FF8A  2               
00FF8A  2               
00FF8A  2               ;******************************************************************************
00FF8A  2               ;
00FF8A  2               ; restore default I/O vectors
00FF8A  2               ;
00FF8A  2               ; this routine restores the default values of all system vectors used in KERNAL
00FF8A  2               ; and BASIC routines and interrupts.
00FF8A  2               ;
00FF8A  2               SetVectorsIO:				;				[FF8A]
00FF8A  2  4C 15 FD     	jmp	SetVectorsIO2		; restore default I/O vectors	[FD15]
00FF8D  2               
00FF8D  2               
00FF8D  2               ;******************************************************************************
00FF8D  2               ;
00FF8D  2               ; read/set vectored I/O
00FF8D  2               ;
00FF8D  2               ; this routine manages all system vector jump addresses stored in RAM. Calling
00FF8D  2               ; this routine with the carry bit set will store the current contents of the
00FF8D  2               ; RAM vectors in a list pointed to by the X and Y registers. When this routine
00FF8D  2               ; is called with the carry bit clear, the user list pointed to by the X and Y
00FF8D  2               ; registers is copied to the system RAM vectors.
00FF8D  2               ;
00FF8D  2               ; NOTE: This routine requires caution in its use. The best way to use it is to
00FF8D  2               ; first read the entire vector contents into the user area, alter the desired
00FF8D  2               ; vectors and then copy the contents back to the system vectors.
00FF8D  2               ;
00FF8D  2               CopyVectorsIO:				;				[FF8D]
00FF8D  2  4C 1A FD     	jmp	CopyVectorsIO2		; read/set vectored I/O		[FD1A]
00FF90  2               
00FF90  2               
00FF90  2               ;******************************************************************************
00FF90  2               ;
00FF90  2               ; control kernal messages
00FF90  2               ;
00FF90  2               ; this routine controls the printing of error and control messages by the
00FF90  2               ; KERNAL. Either print error messages or print control messages can be selected
00FF90  2               ; by setting the accumulator when the routine is called.
00FF90  2               ;
00FF90  2               ; FILE NOT FOUND is an example of an error message. PRESS PLAY ON CASSETTE is
00FF90  2               ; an example of a control message.
00FF90  2               ;
00FF90  2               ; bits 6 and 7 of this value determine where the message will come from. If bit
00FF90  2               ; 7 is set one of the error messages from the KERNAL will be printed. If bit 6
00FF90  2               ; is set a control message will be printed.
00FF90  2               ;
00FF90  2               CtrlKernalMsg:				;				[FF90]
00FF90  2  4C 18 FE     	jmp	CtrlKernalMsg2		; control kernal messages	[FE18]
00FF93  2               
00FF93  2               
00FF93  2               ;******************************************************************************
00FF93  2               ;
00FF93  2               ; send secondary address after LISTEN
00FF93  2               ;
00FF93  2               ; this routine is used to send a secondary address to an I/O device after a
00FF93  2               ; call to the LISTEN routine is made and the device commanded to LISTEN. The
00FF93  2               ; routine cannot be used to send a secondary address after a call to the TALK
00FF93  2               ; routine.
00FF93  2               ;
00FF93  2               ; A secondary address is usually used to give set-up information to a device
00FF93  2               ; before I/O operations begin.
00FF93  2               ;
00FF93  2               ; When a secondary address is to be sent to a device on the serial bus the
00FF93  2               ; address must first be ORed with $60.
00FF93  2               ;
00FF93  2               SAafterLISTEN:				;				[FF93]
00FF93  2  4C B9 ED     	jmp	SAafterLISTEN2		; send secondary address after LISTEN
00FF96  2               					;	[EDB9]
00FF96  2               
00FF96  2               ;******************************************************************************
00FF96  2               ;
00FF96  2               ; send secondary address after TALK
00FF96  2               ;
00FF96  2               ; this routine transmits a secondary address on the serial bus for a TALK
00FF96  2               ; device. This routine must be called with a number between 4 and 31 in the
00FF96  2               ; accumulator. The routine will send this number as a secondary address command
00FF96  2               ; over the serial bus. This routine can only be called after a call to the TALK
00FF96  2               ; routine. It will not work after a LISTEN.
00FF96  2               ;
00FF96  2               SAafterTALK:				;				[FF96]
00FF96  2  4C C7 ED     	jmp	SAafterTALK2		; send secondary address after TALK
00FF99  2               					;				[EDC7]
00FF99  2               
00FF99  2               ;******************************************************************************
00FF99  2               ;
00FF99  2               ; read/set the top of memory
00FF99  2               ;
00FF99  2               ; this routine is used to read and set the top of RAM. When this routine is
00FF99  2               ; called with the carry bit set the pointer to the top of RAM will be loaded
00FF99  2               ; into XY. When this routine is called with the carry bit clear XY will be
00FF99  2               ; saved as the top of memory pointer changing the top of memory.
00FF99  2               ;
00FF99  2               TopOfMem:				;				[FF99]
00FF99  2  4C 25 FE     	jmp	TopOfMem2		; read/set the top of memory	[FE25]
00FF9C  2               
00FF9C  2               
00FF9C  2               ;******************************************************************************
00FF9C  2               ;
00FF9C  2               ; read/set the bottom of memory
00FF9C  2               ;
00FF9C  2               ; this routine is used to read and set the bottom of RAM. When this routine is
00FF9C  2               ; called with the carry bit set the pointer to the bottom of RAM will be loaded
00FF9C  2               ; into XY. When this routine is called with the carry bit clear XY will be
00FF9C  2               ; saved as the bottom of memory pointer changing the bottom of memory.
00FF9C  2               ;
00FF9C  2               BottomOfMem:				;				[FF9C]
00FF9C  2  4C 34 FE     	jmp	BottomOfMem2		; read/set the bottom of memory	[FE34]
00FF9F  2               
00FF9F  2               
00FF9F  2               ;******************************************************************************
00FF9F  2               ;
00FF9F  2               ; scan the keyboard
00FF9F  2               ;
00FF9F  2               ; this routine will scan the keyboard and check for pressed keys. It is the
00FF9F  2               ; same routine called by the interrupt handler. If a key is down, its ASCII
00FF9F  2               ; value is placed in the keyboard queue.
00FF9F  2               ;
00FF9F  2               ScanKeyboard:				;				[FF9F]
00FF9F  2  4C 87 EA     	jmp	ScanKeyboard2		; scan keyboard			[EA87]
00FFA2  2               
00FFA2  2               
00FFA2  2               ;******************************************************************************
00FFA2  2               ;
00FFA2  2               ; set timeout on serial bus
00FFA2  2               ;
00FFA2  2               ; this routine sets the timeout flag for the serial bus. When the timeout flag
00FFA2  2               ; is set, the computer will wait for a device on the serial port for 64
00FFA2  2               ; milliseconds. If the device does not respond to the computer's DAV signal
00FFA2  2               ; within that time the computer will recognize an error condition and leave the
00FFA2  2               ; handshake sequence. When this routine is called and the accumulator contains
00FFA2  2               ; a 0 in bit 7, timeouts are enabled. A 1 in bit 7 will disable the timeouts.
00FFA2  2               ;
00FFA2  2               ; NOTE: The the timeout feature is used to communicate that a disk file is not
00FFA2  2               ; found on an attempt to OPEN a file.
00FFA2  2               ;
00FFA2  2               IecTimeout:				;				[FFA2]
00FFA2  2  4C 21 FE     	jmp	IecTimeout2		; set timeout on serial bus	[FE21]
00FFA5  2               
00FFA5  2               
00FFA5  2               ;******************************************************************************
00FFA5  2               ;
00FFA5  2               ; input byte from serial bus
00FFA5  2               ;
00FFA5  2               ; this routine reads a byte of data from the serial bus using full handshaking.
00FFA5  2               ; the data is returned in the accumulator. before using this routine the TALK
00FFA5  2               ; routine, $FFB4, must have been called first to command the device on the
00FFA5  2               ; serial bus to send data on the bus. if the input device needs a secondary
00FFA5  2               ; command it must be sent by using the TKSA routine, $FF96, before calling
00FFA5  2               ; this routine.
00FFA5  2               ; errors are returned in the status word which can be read by calling the
00FFA5  2               ; READST routine, ReadIoStatus.
00FFA5  2               ;
00FFA5  2               IecByteIn:				;				[FFA5]
00FFA5  2  4C 13 EE     	jmp	IecByteIn2		; input byte from serial bus	[EE13]
00FFA8  2               
00FFA8  2               
00FFA8  2               ;******************************************************************************
00FFA8  2               ;
00FFA8  2               ; output a byte to serial bus
00FFA8  2               ;
00FFA8  2               ; this routine is used to send information to devices on the serial bus. A call
00FFA8  2               ; to this routine will put a data byte onto the serial bus using full
00FFA8  2               ; handshaking. Before this routine is called the LISTEN routine, F_FFB1, must
00FFA8  2               ; be used to command a device on the serial bus to get ready to receive data.
00FFA8  2               ;
00FFA8  2               ; the accumulator is loaded with a byte to output as data on the serial bus. A
00FFA8  2               ; device must be listening or the status word will return a timeout. This
00FFA8  2               ; routine always buffers one character. So when a call to the UNLISTEN routine,
00FFA8  2               ; F_FFAE, is made to end the data transmission, the buffered character is
00FFA8  2               ; sent with EOI set. Then the UNLISTEN command is sent to the device.
00FFA8  2               ;
00FFA8  2               IecByteOut:				;				[FFA8]
00FFA8  2  4C DD ED     	jmp	IecByteOut2		; output byte to serial bus	[EDDD]
00FFAB  2               
00FFAB  2               
00FFAB  2               ;******************************************************************************
00FFAB  2               ;
00FFAB  2               ; command serial bus to UNTALK
00FFAB  2               ;
00FFAB  2               ; this routine will transmit an UNTALK command on the serial bus. All devices
00FFAB  2               ; previously set to TALK will stop sending data when this command is received.
00FFAB  2               ;
00FFAB  2               IecUNTALK:				;				[FFAB]
00FFAB  2  4C EF ED     	jmp	IecUNTALK2		; command serial bus to UNTALK	[EDEF]
00FFAE  2               
00FFAE  2               
00FFAE  2               ;******************************************************************************
00FFAE  2               ;
00FFAE  2               ; command serial bus to UNLISTEN
00FFAE  2               ;
00FFAE  2               ; this routine commands all devices on the serial bus to stop receiving data
00FFAE  2               ; from the computer. Calling this routine results in an UNLISTEN command being
00FFAE  2               ; transmitted on the serial bus. Only devices previously commanded to listen
00FFAE  2               ; will be affected.
00FFAE  2               ;
00FFAE  2               ; This routine is normally used after the computer is finished sending data to
00FFAE  2               ; external devices. Sending the UNLISTEN will command the listening devices to
00FFAE  2               ; get off the serial bus so it can be used for other purposes.
00FFAE  2               ;
00FFAE  2               IecUNLISTEN:				;				[FFAE]
00FFAE  2  4C FE ED     	jmp	IecUNLISTEN2		; command serial bus to UNLISTEN [EDFE]
00FFB1  2               
00FFB1  2               
00FFB1  2               ;******************************************************************************
00FFB1  2               ;
00FFB1  2               ; command devices on the serial bus to LISTEN
00FFB1  2               ;
00FFB1  2               ; this routine will command a device on the serial bus to receive data. The
00FFB1  2               ; accumulator must be loaded with a device number between 4 and 31 before
00FFB1  2               ; calling this routine. LISTEN convert this to a listen address then transmit
00FFB1  2               ; this data as a command on the serial bus. The specified device will then go
00FFB1  2               ; into listen mode and be ready to accept information.
00FFB1  2               ;
00FFB1  2               CmdLISTEN:				;				[FFB1]
00FFB1  2  4C 0C ED     	jmp	CmdLISTEN2		; command devices on the serial bus to
00FFB4  2               					; LISTEN			[ED0C]
00FFB4  2               
00FFB4  2               ;******************************************************************************
00FFB4  2               ;
00FFB4  2               ; command serial bus device to TALK
00FFB4  2               ;
00FFB4  2               ; to use this routine the accumulator must first be loaded with a device number
00FFB4  2               ; between 4 and 30. When called this routine converts this device number to a
00FFB4  2               ; talk address. Then this data is transmitted as a command on the Serial bus.
00FFB4  2               ;
00FFB4  2               CmdTALK:				;				[FFB4]
00FFB4  2  4C 09 ED     	jmp	CmdTALK2		; command serial bus device to TALK
00FFB7  2               					;				[ED09]
00FFB7  2               
00FFB7  2               ;******************************************************************************
00FFB7  2               ;
00FFB7  2               ; read I/O status word
00FFB7  2               ;
00FFB7  2               ; this routine returns the current status of the I/O device in the accumulator.
00FFB7  2               ; The routine is usually called after new communication to an I/O device. The
00FFB7  2               ; routine will give information about device status, or errors that have
00FFB7  2               ; occurred during the I/O operation.
00FFB7  2               ;
00FFB7  2               ReadIoStatus:				;				[FFB7]
00FFB7  2  4C 07 FE     	jmp	ReadIoStatus2		; read I/O status word		[FE07]
00FFBA  2               
00FFBA  2               
00FFBA  2               ;******************************************************************************
00FFBA  2               ;
00FFBA  2               ; set logical, first and second addresses
00FFBA  2               ;
00FFBA  2               ; this routine will set the logical file number, device address, and secondary
00FFBA  2               ; address, command number, for other KERNAL routines.
00FFBA  2               ;
00FFBA  2               ; the logical file number is used by the system as a key to the file table
00FFBA  2               ; created by the OPEN file routine. Device addresses can range from 0 to 30.
00FFBA  2               ; The following codes are used by the computer to stand for the following CBM
00FFBA  2               ; devices:
00FFBA  2               ;
00FFBA  2               ; ADDRESS	DEVICE
00FFBA  2               ; =======	======
00FFBA  2               ;  0		Keyboard
00FFBA  2               ;  1		Cassette #1
00FFBA  2               ;  2		RS-232C device
00FFBA  2               ;  3		CRT display
00FFBA  2               ;  4		Serial bus printer
00FFBA  2               ;  8		CBM Serial bus disk drive
00FFBA  2               ;
00FFBA  2               ; device numbers of four or greater automatically refer to devices on the
00FFBA  2               ; serial bus.
00FFBA  2               ;
00FFBA  2               ; a command to the device is sent as a secondary address on the serial bus
00FFBA  2               ; after the device number is sent during the serial attention handshaking
00FFBA  2               ; sequence. If no secondary address is to be sent Y should be set to $FF.
00FFBA  2               ;
00FFBA  2               SetAddresses:				;				[FFBA]
00FFBA  2  4C 00 FE     	jmp	SetAddresses2		; set logical, first and second
00FFBD  2               					; addresses			[FE00]
00FFBD  2               
00FFBD  2               ;******************************************************************************
00FFBD  2               ;
00FFBD  2               ; set the filename
00FFBD  2               ;
00FFBD  2               ; this routine is used to set up the filename for the OPEN, SAVE, or LOAD
00FFBD  2               ; routines. The accumulator must be loaded with the length of the file and XY
00FFBD  2               ; with the pointer to filename, X being th LB. The address can be any
00FFBD  2               ; valid memory address in the system where a string of characters for the file
00FFBD  2               ; name is stored. If no filename desired the accumulator must be set to 0,
00FFBD  2               ; representing a zero file length, in that case  XY may be set to any memory
00FFBD  2               ; address.
00FFBD  2               ;
00FFBD  2               SetFileName:				;				[FFBD]
00FFBD  2  4C F9 FD     	jmp	SetFileName2		; set the filename		[FDF9]
00FFC0  2               
00FFC0  2               
00FFC0  2               ;******************************************************************************
00FFC0  2               ;
00FFC0  2               ; open a logical file
00FFC0  2               ;
00FFC0  2               ; this routine is used to open a logical file. Once the logical file is set up
00FFC0  2               ; it can be used for input/output operations. Most of the I/O KERNAL routines
00FFC0  2               ; call on this routine to create the logical files to operate on. No arguments
00FFC0  2               ; need to be set up to use this routine, but both the SETLFS, SetAddresses, and
00FFC0  2               ; SETNAM, SetFileName, KERNAL routines must be called before using this routine.
00FFC0  2               ;
00FFC0  2               OpenLogFile:				;				[FFC0]
00FFC0  2  6C 1A 03     	jmp	(IOPEN)			; do open a logical file
00FFC3  2               
00FFC3  2               
00FFC3  2               ;******************************************************************************
00FFC3  2               ;
00FFC3  2               ; close a specified logical file
00FFC3  2               ;
00FFC3  2               ; this routine is used to close a logical file after all I/O operations have
00FFC3  2               ; been completed on that file. This routine is called after the accumulator is
00FFC3  2               ; loaded with the logical file number to be closed, the same number used when
00FFC3  2               ; the file was opened using the OPEN routine.
00FFC3  2               ;
00FFC3  2               CloseLogFile:				;				[FFC3]
00FFC3  2  6C 1C 03     	jmp	(ICLOSE)		; do close a specified logical file
00FFC6  2               
00FFC6  2               
00FFC6  2               ;******************************************************************************
00FFC6  2               ;
00FFC6  2               ; open channel for input
00FFC6  2               ;
00FFC6  2               ; any logical file that has already been opened by the OPEN routine,
00FFC6  2               ; OpenLogFile, can be defined as an input channel by this routine. the device
00FFC6  2               ; on the channel must be an input device or an error will occur and the routine
00FFC6  2               ; will abort.
00FFC6  2               ;
00FFC6  2               ; if you are getting data from anywhere other than the keyboard, this routine
00FFC6  2               ; must be called before using either the CHRIN routine, ByteFromChan, or the
00FFC6  2               ; GETIN; routine, GetCharInpDev. if you are getting data from the keyboard and
00FFC6  2               ; no other input channels are open then the calls to this routine and to the
00FFC6  2               ; OPEN routine, OpenLogFile, are not needed.
00FFC6  2               ; when used with a device on the serial bus this routine will automatically
00FFC6  2               ; send the listen address specified by the OPEN routine, OpenLogFile, and any
00FFC6  2               ; secondary address.
00FFC6  2               ; possible errors are:
00FFC6  2               ;
00FFC6  2               ;	3 : file not open
00FFC6  2               ;	5 : device not present
00FFC6  2               ;	6 : file is not an input file
00FFC6  2               ;
00FFC6  2               OpenChan4Inp:				;				[FFC6]
00FFC6  2  6C 1E 03     	jmp	(ICHKIN)		; do open channel for input
00FFC9  2               
00FFC9  2               
00FFC9  2               ;******************************************************************************
00FFC9  2               ;
00FFC9  2               ; open channel for output
00FFC9  2               ;
00FFC9  2               ; any logical file that has already been opened by the OPEN routine,
00FFC9  2               ; OpenLogFile, can be defined as an output channel by this routine the device
00FFC9  2               ; on the channel must be an output device or an error will occur and the
00FFC9  2               ; routine will abort.
00FFC9  2               ;
00FFC9  2               ; if you are sending data to anywhere other than the screen this routine must
00FFC9  2               ; be called before using the CHROUT routine, OutByteChan. if you are sending
00FFC9  2               ; data to the screen and no other output channels are open then the calls to
00FFC9  2               ; this routine and to the OPEN routine, OpenLogFile, are not needed.
00FFC9  2               ;
00FFC9  2               ; when used with a device on the serial bus this routine will automatically
00FFC9  2               ; send the listen address specified by the OPEN routine, OpenLogFile, and any
00FFC9  2               ; secondary address.
00FFC9  2               ; possible errors are:
00FFC9  2               ;
00FFC9  2               ;	3 : file not open
00FFC9  2               ;	5 : device not present
00FFC9  2               ;	7 : file is not an output file
00FFC9  2               ;
00FFC9  2               OpenChan4Outp:				;				[FFC9]
00FFC9  2  6C 20 03     	jmp	(ICKOUT)		; do open channel for output
00FFCC  2               
00FFCC  2               
00FFCC  2               ;******************************************************************************
00FFCC  2               ;
00FFCC  2               ; close input and output channels
00FFCC  2               ;
00FFCC  2               ; this routine is called to clear all open channels and restore the I/O
00FFCC  2               ; channels to their original default values. It is usually called after opening
00FFCC  2               ; other I/O channels and using them for input/output operations. The default
00FFCC  2               ; input device is 0, the keyboard. The default output device is 3, the screen.
00FFCC  2               ;
00FFCC  2               ; If one of the channels to be closed is to the serial port, an UNTALK signal
00FFCC  2               ; is sent first to clear the input channel or an UNLISTEN is sent to clear the
00FFCC  2               ; output channel. By not calling this routine and leaving listener(s) active on
00FFCC  2               ; the serial bus, several devices can receive the same data from the VIC at the
00FFCC  2               ; same time. One way to take advantage of this would be to command the printer
00FFCC  2               ; to TALK and the disk to LISTEN. This would allow direct printing of a disk
00FFCC  2               ; file.
00FFCC  2               ;
00FFCC  2               CloseIoChannls:				;				[FFCC]
00FFCC  2  6C 22 03     	jmp	(ICLRCH)		; do close input and output channels
00FFCF  2               
00FFCF  2               
00FFCF  2               ;******************************************************************************
00FFCF  2               ;
00FFCF  2               ; input character from channel
00FFCF  2               ;
00FFCF  2               ; this routine will get a byte of data from the channel already set up as the
00FFCF  2               ; input channel by the CHKIN routine, OpenChan4Inp.
00FFCF  2               ;
00FFCF  2               ; If CHKIN, OpenChan4Inp, has not been used to define another input channel the
00FFCF  2               ; data is expected to be from the keyboard. the data byte is returned in the
00FFCF  2               ; accumulator. the channel remains open after the call.
00FFCF  2               ;
00FFCF  2               ; input from the keyboard is handled in a special way. first, the cursor is
00FFCF  2               ; turned on and it will blink until a carriage return is typed on the keyboard.
00FFCF  2               ; all characters on the logical line, up to 80 characters, will be stored in
00FFCF  2               ; the BASIC input buffer. then the characters can be returned one at a time by
00FFCF  2               ; calling this routine once for each character. when the carriage return is
00FFCF  2               ; returned the entire line has been processed. the next time this routine is
00FFCF  2               ; called the whole process begins again.
00FFCF  2               ;
00FFCF  2               ByteFromChan:				;				[FFCF]
00FFCF  2  6C 24 03     	jmp	(IBASIN)		; do input character from channel
00FFD2  2               
00FFD2  2               
00FFD2  2               ;******************************************************************************
00FFD2  2               ;
00FFD2  2               ; output character to channel
00FFD2  2               ;
00FFD2  2               ; this routine will output a character to an already opened channel. Use the
00FFD2  2               ; OPEN routine, OpenLogFile, and the CHKOUT routine, OpenChan4Outp, to set up
00FFD2  2               ; the output channel before calling this routine. If these calls are omitted,
00FFD2  2               ; data will be sent to the default output device, device 3, the screen. The data
00FFD2  2               ; byte to be output is loaded into the accumulator, and this routine is called.
00FFD2  2               ; The data is then sent to the specified output device. The channel is left
00FFD2  2               ; open after the call.
00FFD2  2               ;
00FFD2  2               ; NOTE: Care must be taken when using routine to send data to a serial device
00FFD2  2               ; since data will be sent to all open output channels on the bus. Unless this
00FFD2  2               ; is desired, all open output channels on the serial bus other than the
00FFD2  2               ; actually intended destination channel must be closed by a call to the KERNAL
00FFD2  2               ; close channel routine.
00FFD2  2               ;
00FFD2  2               OutByteChan:				;				[FFD2]
00FFD2  2  6C 26 03     	jmp	(IBSOUT)		; do output character to channel
00FFD5  2               
00FFD5  2               
00FFD5  2               ;******************************************************************************
00FFD5  2               ;
00FFD5  2               ; load RAM from a device
00FFD5  2               ;
00FFD5  2               ; this routine will load data bytes from any input device directly into the
00FFD5  2               ; memory of the computer. It can also be used for a verify operation comparing
00FFD5  2               ; data from a device with the data already in memory, leaving the data stored
00FFD5  2               ; in RAM unchanged.
00FFD5  2               ;
00FFD5  2               ; The accumulator must be set to 0 for a load operation or 1 for a verify. If
00FFD5  2               ; the input device was OPENed with a secondary address of 0 the header
00FFD5  2               ; information from device will be ignored. In this case XY must contain the
00FFD5  2               ; starting address for the load. If the device was addressed with a secondary
00FFD5  2               ; address of 1 or 2 the data will load into memory starting at the location
00FFD5  2               ; specified by the header. This routine returns the address of the highest RAM
00FFD5  2               ; location which was loaded.
00FFD5  2               ;
00FFD5  2               ; Before this routine can be called, the SETLFS, SetAddresses, and SETNAM,
00FFD5  2               ; SetFileName, routines must be called.
00FFD5  2               ;
00FFD5  2               LoadRamFrmDev:				;				[FFD5]
00FFD5  2  4C 9E F4     	jmp	LoadRamFrmDev2		; load RAM from a device	[F49E]
00FFD8  2               
00FFD8  2               
00FFD8  2               ;******************************************************************************
00FFD8  2               ;
00FFD8  2               ; save RAM to a device
00FFD8  2               ;
00FFD8  2               ; this routine saves a section of memory. Memory is saved from an indirect
00FFD8  2               ; address on page 0 specified by A, to the address stored in XY, to a logical
00FFD8  2               ; file. The SETLFS, SetAddresses, and SETNAM, SetFileName, routines must be used
00FFD8  2               ; before calling this routine. However, a filename is not required to SAVE to
00FFD8  2               ; device 1, the cassette. Any attempt to save to other devices without using a
00FFD8  2               ; filename results in an error.
00FFD8  2               ;
00FFD8  2               ; NOTE: device 0, the keyboard, and device 3, the screen, cannot be SAVEd to.
00FFD8  2               ; If the attempt is made, an error will occur, and the SAVE stopped.
00FFD8  2               ;
00FFD8  2               SaveRamToDev:				;				[FFD8]
00FFD8  2  4C DD F5     	jmp	SaveRamToDev2		; save RAM to device		[F5DD]
00FFDB  2               
00FFDB  2               
00FFDB  2               ;******************************************************************************
00FFDB  2               ;
00FFDB  2               ; set the real time clock
00FFDB  2               ;
00FFDB  2               ; the system clock is maintained by an interrupt routine that updates the clock
00FFDB  2               ; every 1/60th of a second. The clock is three bytes long which gives the
00FFDB  2               ; capability to count from zero up to 5,184,000 jiffies - 24 hours plus one
00FFDB  2               ; jiffy. At that point the clock resets to zero. Before calling this routine to
00FFDB  2               ; set the clock the new time, in jiffies, should be in YXA, the accumulator
00FFDB  2               ; containing the most significant byte.
00FFDB  2               ;
00FFDB  2               SetClock:				;				[FFDB]
00FFDB  2  4C E4 F6     	jmp	SetClock2		; set real time clock		[F6E4]
00FFDE  2               
00FFDE  2               
00FFDE  2               ;******************************************************************************
00FFDE  2               ;
00FFDE  2               ; read the real time clock
00FFDE  2               ;
00FFDE  2               ; this routine returns the time, in jiffies, in AXY. The accumulator contains
00FFDE  2               ; the most significant byte.
00FFDE  2               ;
00FFDE  2               ReadClock:				;				[FFDE]
00FFDE  2  4C DD F6     	jmp	ReadClock2		; read real time clock		[F6DD]
00FFE1  2               
00FFE1  2               
00FFE1  2               ;******************************************************************************
00FFE1  2               ;
00FFE1  2               ; scan the stop key
00FFE1  2               ;
00FFE1  2               ; if the STOP key on the keyboard is pressed when this routine is called the Z
00FFE1  2               ; flag will be set. All other flags remain unchanged. If the STOP key is not
00FFE1  2               ; pressed then the accumulator will contain a byte representing the last row of
00FFE1  2               ; the keyboard scan.
00FFE1  2               ;
00FFE1  2               ; The user can also check for certain other keys this way.
00FFE1  2               ;
00FFE1  2               ScanStopKey:				;				[FFE1]
00FFE1  2  6C 28 03     	jmp	(ISTOP)			; do scan stop key
00FFE4  2               
00FFE4  2               
00FFE4  2               ;******************************************************************************
00FFE4  2               ;
00FFE4  2               ; get character from input device
00FFE4  2               ;
00FFE4  2               ; in practice this routine operates identically to the CHRIN routine,
00FFE4  2               ; ByteFromChan, for all devices except for the keyboard. If the keyboard is the
00FFE4  2               ; current input device this routine will get one character from the keyboard
00FFE4  2               ; buffer. It depends on the IRQ routine to read the keyboard and put characters
00FFE4  2               ; into the buffer.
00FFE4  2               ;
00FFE4  2               ; If the keyboard buffer is empty the value returned in the accumulator will be
00FFE4  2               ; zero.
00FFE4  2               ;
00FFE4  2               GetCharInpDev:				;				[FFE4]
00FFE4  2  6C 2A 03     	jmp	(IGETIN)		; do get character from input device
00FFE7  2               
00FFE7  2               
00FFE7  2               ;******************************************************************************
00FFE7  2               ;
00FFE7  2               ; close all channels and files
00FFE7  2               ;
00FFE7  2               ; this routine closes all open files. When this routine is called, the pointers
00FFE7  2               ; into the open file table are reset, closing all files. Also the routine
00FFE7  2               ; automatically resets the I/O channels.
00FFE7  2               ;
00FFE7  2               CloseAllChan:				;				[FFE7]
00FFE7  2  6C 2C 03     	jmp	(ICLALL)		; do close all channels and files
00FFEA  2               
00FFEA  2               
00FFEA  2               ;******************************************************************************
00FFEA  2               ;
00FFEA  2               ; increment real time clock
00FFEA  2               ;
00FFEA  2               ; this routine updates the system clock. Normally this routine is called by the
00FFEA  2               ; normal KERNAL interrupt routine every 1/60th of a second. If the user program
00FFEA  2               ; processes its own interrupts this routine must be called to update the time.
00FFEA  2               ; Also, the STOP key routine must be called if the stop key is to remain
00FFEA  2               ; functional.
00FFEA  2               ;
00FFEA  2               IncrClock:				;				[FFEA]
00FFEA  2  4C 9B F6     	jmp	IncrClock2		; increment real time clock	[F69B]
00FFED  2               
00FFED  2               
00FFED  2               ;******************************************************************************
00FFED  2               ;
00FFED  2               ; return X,Y organization of screen
00FFED  2               ;
00FFED  2               ; this routine returns the x,y organisation of the screen in X,Y
00FFED  2               ;
00FFED  2               GetSizeScreen:				;				[FFED]
00FFED  2  4C 05 E5     	jmp	GetSizeScreen2		; return X,Y organization of screen
00FFF0  2               					;				[E505]
00FFF0  2               
00FFF0  2               
00FFF0  2               ;******************************************************************************
00FFF0  2               ;
00FFF0  2               ; read/set X,Y cursor position
00FFF0  2               ;
00FFF0  2               ; this routine, when called with the carry flag set, loads the current position
00FFF0  2               ; of the cursor on the screen into the X and Y registers. X is the column
00FFF0  2               ; number of the cursor location and Y is the row number of the cursor. A call
00FFF0  2               ; with the carry bit clear moves the cursor to the position determined by the X
00FFF0  2               ; and Y registers.
00FFF0  2               ;
00FFF0  2               CursorPosXY:				;				[FFF0]
00FFF0  2  4C 0A E5     	jmp	CursorPosXY2		; read/set X,Y cursor position	[E50A]
00FFF3  2               
00FFF3  2               
00FFF3  2               ;******************************************************************************
00FFF3  2               ;
00FFF3  2               ; return the base address of the I/O devices
00FFF3  2               ;
00FFF3  2               ; this routine will set XY to the address of the memory section where the
00FFF3  2               ; memory mapped I/O devices are located. This address can then be used with an
00FFF3  2               ; offset to access the memory mapped I/O devices in the computer.
00FFF3  2               
00FFF3  2               GetAddrIoDevs:				;				[FFF3]
00FFF3  2  4C 00 E5     	jmp	GetAddrIoDevs2		; return the base address of the I/O
00FFF6  2               					; devices			[E500]
00FFF6  2               
00FFF6  2               
00FFF6  2               ;S_FFF6
00FFF6  2  52 52 42 59  .byte	"rrby"
00FFFA  2               
00FFFA  2               ; hardware vectors							[FFFA]
00FFFA  2  43 FE        .word	NMI_routine			; NMI vector			[FE43]
00FFFC  2  E2 FC        .word	RESET_routine			; RESET vector			[FCE2]
00FFFE  2  48 FF        .word	IRQ_routine			; IRQ vector			[FF48]
010000  2               
010000  2               
010000  2               ;******************************************************************************
010000  2               
010000  2               
010000  2               
010000  1               
010000  1               ;.ov
010000  1               ;.include "C64-kerV2.a65"
010000  1               ;.include "C64-kerV3.a65"
010000  1               ;.oo
010000  1               
010000  1               .end
