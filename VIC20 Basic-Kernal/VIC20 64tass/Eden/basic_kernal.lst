
; 64tass Turbo Assembler Macro V1.53.1515 listing file
; 64tass -L basic_kernal.lst -o basic_kernal.prg basic_kernal.asm
; Thu Jan 11 20:03:50 2018

;Offset	;Hex		;Monitor	;Source

;******  Processing input file: basic_kernal.asm

=$00					USRPPOK = $00			; USR() JMP instruction
=$01					ADDPRC	= $01			; USR() vector
=$03					ADRAY1	= $03			; float to fixed vector
=$05					ADRAY2	= $05			; fixed to float vector
=$07					CHARAC	= $07			; search character
=$08					ENDCHR	= $08			; scan quotes flag
=$09					TRMPOS	= $09			; TAB column save
=$0a					VERCHK	= $0A			; load/verify flag, 0 = load, 1 = verify
=$0b					COUNT	= $0B			; temporary byte, line crunch/array access/logic operators
=$0c					DIMFLG	= $0C			; DIM flag
=$0d					VALTYP	= $0D			; data type flag, $FF = string, $00 = numeric
=$0e					INTFLG	= $0E			; data type flag, $80 = integer, $00 = floating point
=$0f					GARBFL	= $0F			; garbage collected/open quote/DATA flag
=$10					SUBFLG	= $10			; subscript/FNx flag
=$11					INPFLG	= $11			; input mode flag, $00 = INPUT, $40 = GET, $98 = READ
=$12					TANSGN	= $12			; ATN sign/comparison evaluation flag
=$13					CHANNL	= $13			; current I/O channel
=$14					LINNUM	= $14			; temporary integer low byte
=$16					TEMPPT	= $16			; descriptor stack pointer, next free
=$17					LASTPT	= $17			; current descriptor stack item pointer low byte
=$19					TEMPST	= $19			; to $21, descriptor stack
=$22					INDEX	= $22			; misc temp byte
=$26					RESHO	= $26			; temp mantissa 1
=$2b					TXTTAB	= $2B			; start of memory low byte
=$2d					VARTAB	= $2D			; start of variables low byte
=$2f					ARYTAB	= $2F			; end of variables low byte
=$31					STREND	= $31			; end of arrays low byte
=$33					FRETOP	= $33			; bottom of string space low byte
=$35					FRESPC	= $35			; string utility ptr low byte
=$37					MEMSIZ	= $37			; end of memory low byte
=$39					CURLIN	= $39			; current line number low byte
=$3b					OLDLIN	= $3B			; break line number low byte
=$3d					OLDTXT	= $3D			; continue pointer low byte
=$3f					DATLIN	= $3F			; current DATA line number low byte
=$41					DATPTR	= $41			; DATA pointer low byte
=$43					INPPTR	= $43			; READ pointer low byte
=$45					VARNAM	= $45			; current variable name first byte
=$47					VARPNT	= $47			; current variable address low byte
=$49					FORPNT	= $49			; FOR/NEXT variable pointer low byte
=$4b					OPPTR	= $4B			; BASIC execute pointer temporary low byte/precedence flag
=$4d					OPMASK	= $4D			; comparison evaluation flag
=$4e					DEFPNT	= $4E			; FAC temp store/function/variable/garbage pointer low byte
=$50					DSCPTN	= $50			; FAC temp store/descriptor pointer low byte
=$53					FOUR6	= $53			; garbage collection step size
=$54					JMPER	= $54			; JMP opcode for functions
=$57					TEMPF3	= $57			; FAC temp store
=$58					GENPTR	= $58			; FAC temp store
=$5a					GEN2PTR = $5A			; FAC temp store
=$5c					LAB_5C	= $5C			; FAC temp store
=$5d					LAB_5D	= $5D			; FAC temp store
=$5e					EXPCNT	= $5E			; exponent count byte
=$5f					TMPPTR	= $5F
=$61					FAC1	= $61			; FAC1 exponent
=$67					SGNFLG	= $67			; constant count/-ve flag
=$68					BITS	= $68			; FAC1 overflow
=$69					FAC2	= $69			; FAC2 exponent
=$6f					ARISGN	= $6F			; FAC sign comparison
=$70					FACOV	= $70			; FAC1 rounding
=$71					FBUFPT	= $71			; temp BASIC execute/array pointer low byte/index
=$73					CHRGET	= $73			; increment and scan memory, BASIC byte get
=$79					CHRGOT	= $79			; scan memory, BASIC byte get
=$80					CHRSPC	= $80			; numeric test entry
=$8b					RNDX	= $8B			; RND() seed, five bytes
=$90					STATUS	= $90			; I/O status byte
=$91					STKEY	= $91			; keyboard row, bx = 0 = key down
=$92					SVXT	= $92			; timing constant for tape read
=$93					VERCK	= $93			; load/verify flag, load = $00, verify = $01
=$94					C3PO	= $94			; serial output: deferred character flag
=$95					BSOUR	= $95			; serial output: deferred character
=$96					SYNO	= $96			; tape: leader length
=$97					XSAV	= $97			; register save
=$98					LDTND	= $98			; open file count
=$99					DFLTN	= $99			; input device number
=$9a					DFLTO	= $9A			; output device number
=$9b					PRTY	= $9B			; tape character parity
=$9c					DPSW	= $9C			; tape dipole switch/byte received flag
=$9d					MSGFLG	= $9D			; KERNAL message mode flag,
=$9e					PTR1	= $9E			; tape pass 1 error log/character buffer
=$9f					PTR2	= $9F			; tape pass 2 error log corrected
=$a0					TIME	= $A0			; jiffy clock high byte
=$a3					PCNTR	= $A3			; serial input bit count/tape bit count
=$a4					FIRT	= $A4			; input byte/tape bit cycle phase
=$a5					CNTDN	= $A5			; tape synchronisation byte count/serial bus bit count
=$a6					BUFPNT	= $A6			; tape buffer index
=$a7					INBIT	= $A7			; tape write leader count/block count/RS-232 input bit
=$a8					BITCI	= $A8			; tape error flags/tape long word marker/RS-232 input bit count
=$a9					RINONE	= $A9			; tape dipole count/tape medium word marker/RS-232 start bit flag,
=$aa					RIDATA	= $AA			; tape input status/tape sync status/RS-232 byte assembly
=$ab					RIPRTY	= $AB			; tape leader counter/tape read checksum/RS-232 parity bit
=$ac					SAL	= $AC			; tape buffer start pointer low byte
=$ae					EAL	= $AE			; tape buffer end pointer low byte
=$b0					CMP0	= $B0			; tape timing constant min byte
=$b2					TAPE1	= $B2			; tape buffer start pointer low byte
=$b4					BITTS	= $B4			; transmitter bit count out
=$b5					NXTBIT	= $B5			; transmitter next bit to be sent
=$b6					RODATA	= $B6			; transmitter byte buffer/disassembly location
=$b7					FNLEN	= $B7			; file name length
=$b8					LA	= $B8			; logical file
=$b9					SA	= $B9			; secondary address
=$ba					FA	= $BA			; current device number
=$bb					FNADR	= $BB			; file name pointer low byte
=$bd					ROPRTY	= $BD			; tape write byte/RS-232 parity byte
=$be					FSBLK	= $BE			; tape copies remaining
=$bf					MYCH	= $BF			; tape read byte
=$c0					CAS1	= $C0			; tape motor interlock
=$c1					STAL	= $C1			; I/O start address low byte
=$c3					MEMUSS	= $C3			; load start address low byte
=$c5					LSTX	= $C5			; last key pressed
=$c6					NDX	= $C6			; keyboard buffer length/index
=$c7					RVS	= $C7			; reverse flag, $12 = reverse, $00 = normal
=$c8					INDX	= $C8			; input EOL pointer
=$c9					LXSP	= $C9			; input cursor row
=$cb					SFDX	= $CB			; which key
=$cc					BLNSW	= $CC			; cursor enable, $00 = flash cursor
=$cd					BLNCT	= $CD			; cursor timing countdown
=$ce					CDBLN	= $CE			; character under cursor
=$cf					BLNON	= $CF			; cursor blink phase
=$d0					CRSW	= $D0			; input from keyboard or screen, $xx = input is available
=$d1					PNT	= $D1			; current screen line pointer low byte
=$d3					PNTR	= $D3			; cursor column
=$d4					QTSW	= $D4			; cursor quote flag
=$d5					LNMX	= $D5			; current screen line length
=$d6					TBLX	= $D6			; cursor row
=$d7					ASCII	= $D7			; checksum byte/temporary last character
=$d8					INSRT	= $D8			; insert count
=$d9					LDTB1	= $D9			; to LDTB1 + $18 inclusive, screen line link table
=$f2					LLNKSV	= $F2			; screen row marker
=$f3					USER	= $F3			; colour RAM pointer low byte
=$f5					KEYTAB	= $F5			; keyboard pointer low byte
=$f7					RIBUF	= $F7			; RS-232 Rx pointer low byte
=$f9					ROBUF	= $F9			; RS-232 Tx pointer low byte
=$ff					BASZPT	= $FF			; FAC1 to string output base
=$0100					STACK	= $0100			; bottom of the stack page
=$01fc					CHNLNK	= $01FC			; chain link pointer high byte
=$01fe					PREVLN	= $01FE			; line number low byte before crunched line
=$0200					BUF	= $0200			; input buffer, for some routines the byte before the input
=$0259					LAT	= $0259			; .. to $0262 logical file table
=$0263					FAT	= $0263			; .. to $026C device number table
=$026d					SAT	= $026D			; .. to $0276 secondary address table
=$0277					KEYD	= $0277			; .. to $0280 keyboard buffer
=$0281					MEMSTR	= $0281			; OS start of memory low byte
=$0283					MEMHIGH = $0283			; OS top of memory low byte
=$0285					TIMOUT	= $0285			; IEEE-488 bus timeout flag ( unused )
=$0286					COLOR	= $0286			; current colour code
=$0287					GDCOL	= $0287			; colour under cursor
=$0288					HIBASE	= $0288			; screen memory page
=$0289					XMAX	= $0289			; maximum keyboard buffer size
=$028a					RPTFLG	= $028A			; key repeat. $80 = repeat all, $40 = repeat none,
=$028b					KOUNT	= $028B			; repeat speed counter
=$028c					DELAY	= $028C			; repeat delay counter
=$028d					SHFLAG	= $028D			; keyboard shift/control flag
=$028e					LSTSHF	= $028E			; SHIFT/CTRL/C= keypress last pattern
=$028f					KEYLOG	= $028F			; keyboard decode logic pointer low byte
=$0291					MODE	= $0291			; shift mode switch, $00 = enabled, $80 = locked
=$0292					AUTODN	= $0292			; screen scrolling flag, $00 = enabled
=$0293					M51CTR	= $0293			; pseudo 6551 control register. the first character of
=$0294					M51CDR	= $0294			; pseudo 6551 command register. the second character of
=$0297					RSSTAT	= $0297			; RS-232 status register
=$0298					BITNUM	= $0298			; number of bits to be sent/received
=$0299					BAUDOF	= $0299			; time of one bit cell low byte
=$029b					RIDBE	= $029B			; index to Rx buffer end
=$029c					RIDBS	= $029C			; index to Rx buffer start
=$029d					RODBS	= $029D			; index to Tx buffer start
=$029e					RODBE	= $029E			; index to Tx buffer end
=$029f					IRQTMP	= $029F			; saved IRQ low byte
=$0300					IERROR	= $0300			; BASIC vector - print error message
=$0302					IMAIN	= $0302			; BASIC vector - main command processor
=$0304					ICRNCH	= $0304			; BASIC vector - tokenise keywords
=$0306					IQPLOP	= $0306			; BASIC vector - list program
=$0308					IGONE	= $0308			; BASIC vector - execute next command
=$030a					IEVAL	= $030A			; BASIC vector - get value from line
=$030c					SAREG	= $030C			; .A for SYS command
=$030d					SXREG	= $030D			; .X for SYS command
=$030e					SYREG	= $030E			; .Y for SYS command
=$030f					SPREG	= $030F			; .P for SYS command
=$0314					CINV	= $0314			; IRQ vector
=$0316					CBINV	= $0316			; BRK vector
=$0318					NMINV	= $0318			; NMI vector
=$031a					IOPEN	= $031A			; KERNAL vector - open a logical file
=$031c					ICLOSE	= $031C			; KERNAL vector - close a specified logical file
=$031e					ICHKIN	= $031E			; KERNAL vector - open channel for input
=$0320					ICKOUT	= $0320			; KERNAL vector - open channel for output
=$0322					ICLRCN	= $0322			; KERNAL vector - close input and output channels
=$0324					IBASIN	= $0324			; KERNAL vector - input character from channel
=$0326					IBSOUT	= $0326			; KERNAL vector - output character to channel
=$0328					ISTOP	= $0328			; KERNAL vector - scan stop key
=$032a					IGETIN	= $032A			; KERNAL vector - get character from keyboard queue
=$032c					ICLALL	= $032C			; KERNAL vector - close all channels and files
=$032e					USRCMD	= $032E			; User vector ( unused )
=$0330					ILOAD	= $0330			; KERNAL vector - load
=$0332					ISAVE	= $0332			; KERNAL vector - save
=$033c					TBUFFR	= $033C			; to $03FB - cassette buffer
=$9000					VICCR0	= $9000			; screen origin - horizontal
=$9001					VICCR1	= $9001			; screen origin - vertical
=$9002					VICCR2	= $9002			; video address and screen columns
=$9003					VICCR3	= $9003			; screen rows and character height
=$9004					VICCR4	= $9004			; raster line b8-b1
=$9005					VICCR5	= $9005			; video and character memory addresses
=$9006					VICCR6	= $9006			; light pen horizontal position
=$9007					VICCR7	= $9007			; light pen vertical position
=$9008					VICCR8	= $9008			; paddle X
=$9009					VICCR9	= $9009			; paddle Y
=$900a					VICCRA	= $900A			; oscillator 1
=$900b					VICCRB	= $900B			; oscillator 2
=$900c					VICCRC	= $900C			; oscillator 3
=$900d					VICCRD	= $900D			; white noise
=$900e					VICCRE	= $900E			; auxiliary colour and volume
=$900f					VICCRF	= $900F			; background and border colour
=$9110					VIA1PB		= $9110		; VIA 1 DRB
=$9111					VIA1PA1		= $9111		; VIA 1 DRA
=$9112					VIA1DDRB	= $9112		; VIA 1 DDRB
=$9113					VIA1DDRA	= $9113		; VIA 1 DDRA
=$9114					VIA1T1CL	= $9114		; VIA 1 T1C_l
=$9115					VIA1T1CH	= $9115		; VIA 1 T1C_h
=$9118					VIA1T2CL	= $9118		; VIA 1 T2C_l
=$9119					VIA1T2CH	= $9119		; VIA 1 T2C_h
=$911b					VIA1ACR		= $911B		; VIA 1 ACR
=$911c					VIA1PCR		= $911C		; VIA 1 PCR
=$911d					VIA1IFR		= $911D		; VIA 1 IFR
=$911e					VIA1IER		= $911E		; VIA 1 IER
=$911f					VIA1PA2		= $911F		; VIA 1 DRA, no handshake
=$9120					VIA2PB		= $9120		; VIA 2 DRB, keyboard column
=$9121					VIA2PA1		= $9121		; VIA 2 DRA, keyboard row
=$9122					VIA2DDRB	= $9122		; VIA 2 DDRB
=$9123					VIA2DDRA	= $9123		; VIA 2 DDRA
=$9124					VIA2T1CL	= $9124		; VIA 2 T1C_l
=$9125					VIA2T1CH	= $9125		; VIA 2 T1C_h
=$9128					VIA2T2CL	= $9128		; VIA 2 T2C_l
=$9129					VIA2T2CH	= $9129		; VIA 2 T2C_h
=$912b					VIA2ACR		= $912B		; VIA 2 ACR
=$912c					VIA2PCR		= $912C		; VIA 2 PCR
=$912d					VIA2IFR		= $912D		; VIA 2 IFR
=$912e					VIA2IER		= $912E		; VIA 2 IER
=$912f					VIA2PA2		= $912F		; VIA 2 DRA, keyboard row, no handshake
=$a000					XROMCOLD	= $A000		; autostart ROM initial entry vector
=$a002					XROMWARM	= $A002		; autostart ROM break entry vector
=$a004					XROMID		= $A004		; .. to $A008 autostart ROM identifier string start
=$80					TK_END		= $80			; END token
=$81					TK_FOR		= $81			; FOR token
=$82					TK_NEXT		= $82			; NEXT token
=$83					TK_DATA		= $83			; DATA token
=$84					TK_INFL		= $84			; INPUT# token
=$85					TK_INPUT	= $85			; INPUT token
=$86					TK_DIM		= $86			; DIM token
=$87					TK_READ		= $87			; READ token
=$88					TK_LET		= $88			; LET token
=$89					TK_GOTO		= $89			; GOTO token
=$8a					TK_RUN		= $8A			; RUN token
=$8b					TK_IF		= $8B			; IF token
=$8c					TK_RESTORE	= $8C			; RESTORE token
=$8d					TK_GOSUB	= $8D			; GOSUB token
=$8e					TK_RETURN	= $8E			; RETURN token
=$8f					TK_REM		= $8F			; REM token
=$90					TK_STOP		= $90			; STOP token
=$91					TK_ON		= $91			; ON token
=$92					TK_WAIT		= $92			; WAIT token
=$93					TK_LOAD		= $93			; LOAD token
=$94					TK_SAVE		= $94			; SAVE token
=$95					TK_VERIFY	= $95			; VERIFY token
=$96					TK_DEF		= $96			; DEF token
=$97					TK_POKE		= $97			; POKE token
=$98					TK_PRINFL	= $98			; PRINT# token
=$99					TK_PRINT	= $99			; PRINT token
=$9a					TK_CONT		= $9A			; CONT token
=$9b					TK_LIST		= $9B			; LIST token
=$9c					TK_CLR		= $9C			; CLR token
=$9d					TK_CMD		= $9D			; CMD token
=$9e					TK_SYS		= $9E			; SYS token
=$9f					TK_OPEN		= $9F			; OPEN token
=$a0					TK_CLOSE	= $A0			; CLOSE token
=$a1					TK_GET		= $A1			; GET token
=$a2					TK_NEW		= $A2			; NEW token
=$a3					TK_TAB		= $A3			; TAB( token
=$a4					TK_TO		= $A4			; TO token
=$a5					TK_FN		= $A5			; FN token
=$a6					TK_SPC		= $A6			; SPC( token
=$a7					TK_THEN		= $A7			; THEN token
=$a8					TK_NOT		= $A8			; NOT token
=$a9					TK_STEP		= $A9			; STEP token
=$aa					TK_PLUS		= $AA			; + token
=$ab					TK_MINUS	= $AB			; - token
=$ac					TK_MUL		= $AC			; * token
=$ad					TK_DIV		= $AD			; / token
=$ae					TK_POWER	= $AE			; ^ token
=$af					TK_AND		= $AF			; AND token
=$b0					TK_OR		= $B0			; OR token
=$b1					TK_GT		= $B1			; > token
=$b2					TK_EQUAL	= $B2			; = token
=$b3					TK_LT		= $B3			; < token
=$b4					TK_SGN		= $B4			; SGN token
=$b5					TK_INT		= $B5			; INT token
=$b6					TK_ABS		= $B6			; ABS token
=$b7					TK_USR		= $B7			; USR token
=$b8					TK_FRE		= $B8			; FRE token
=$b9					TK_POS		= $B9			; POS token
=$ba					TK_SQR		= $BA			; SQR token
=$bb					TK_RND		= $BB			; RND token
=$bc					TK_LOG		= $BC			; LOG token
=$bd					TK_EXP		= $BD			; EXP token
=$be					TK_COS		= $BE			; COS token
=$bf					TK_SIN		= $BF			; SIN token
=$c0					TK_TAN		= $C0			; TAN token
=$c1					TK_ATN		= $C1			; ATN token
=$c2					TK_PEEK		= $C2			; PEEK token
=$c3					TK_LEN		= $C3			; LEN token
=$c4					TK_STRS		= $C4			; STR$ token
=$c5					TK_VAL		= $C5			; VAL token
=$c6					TK_ASC		= $C6			; ASC token
=$c7					TK_CHRS		= $C7			; CHR$ token
=$c8					TK_LEFTS	= $C8			; LEFT$ token
=$c9					TK_RIGHTS	= $C9			; RIGHT$ token
=$ca					TK_MIDS		= $CA			; MID$ token
=$cb					TK_GO		= $CB			; GO token
=$ff					TK_PI		= $FF			; PI token
=$00					FAC_EXPT	= $00
=$01					FAC_MANT	= $01
=$05					FAC_SIGN	= $05
.c000					COLDST
>c000	78 e3					.word	COLDBA			; BASIC cold start entry point
.c002					WARMST
>c002	67 e4					.word	WARMBAS			; BASIC warm start entry point
>c004	43 42 4d 42 41 53 49 43			.text	"CBMBASIC"		; ROM name, unreferenced
.c00c					STMDSP
>c00c	30 c8					.word	END-1			; perform END
>c00e	41 c7					.word	FOR-1			; perform FOR
>c010	1d cd					.word	NEXT-1			; perform NEXT
>c012	f7 c8					.word	SKIPST-1		; perform DATA
>c014	a4 cb					.word	INPUTN-1		; perform INPUT#
>c016	be cb					.word	INPUT-1			; perform INPUT
>c018	80 d0					.word	DIM-1			; perform DIM
>c01a	05 cc					.word	READ-1			; perform READ
>c01c	a4 c9					.word	LET-1			; perform LET
>c01e	9f c8					.word	GOTO-1			; perform GOTO
>c020	70 c8					.word	RUN-1			; perform RUN
>c022	27 c9					.word	IF-1			; perform IF
>c024	1c c8					.word	RESTORE-1		; perform RESTORE
>c026	82 c8					.word	GOSUB-1			; perform GOSUB
>c028	d1 c8					.word	RETURN-1		; perform RETURN
>c02a	3a c9					.word	REM-1			; perform REM
>c02c	2e c8					.word	BSTOP-1			; perform STOP
>c02e	4a c9					.word	ON-1			; perform ON
>c030	2c d8					.word	WAIT-1			; perform WAIT
>c032	64 e1					.word	BLOAD-1			; perform LOAD
>c034	52 e1					.word	BSAVE-1			; perform SAVE
>c036	61 e1					.word	BVERIF-1		; perform VERIFY
>c038	b2 d3					.word	DEF-1			; perform DEF
>c03a	23 d8					.word	POKE-1			; perform POKE
>c03c	7f ca					.word	PRINTN-1		; perform PRINT#
>c03e	9f ca					.word	PRINT-1			; perform PRINT
>c040	56 c8					.word	CONT-1			; perform CONT
>c042	9b c6					.word	LIST-1			; perform LIST
>c044	5d c6					.word	CLR-1			; perform CLR
>c046	85 ca					.word	CMD-1			; perform CMD
>c048	26 e1					.word	SYSTEM-1		; perform SYS
>c04a	ba e1					.word	BOPEN-1			; perform OPEN
>c04c	c3 e1					.word	BCLOSE-1		; perform CLOSE
>c04e	7a cb					.word	GET-1			; perform GET
>c050	41 c6					.word	NEW-1			; perform NEW
.c052					FUNDSP
>c052	39 dc					.word	SGN			; perform SGN()
>c054	cc dc					.word	INT			; perform INT()
>c056	58 dc					.word	ABS			; perform ABS()
>c058	00 00					.word	USRPPOK			; perform USR()
>c05a	7d d3					.word	FRE			; perform FRE()
>c05c	9e d3					.word	POS			; perform POS()
>c05e	71 df					.word	SQR			; perform SQR()
>c060	94 e0					.word	RND			; perform RND()
>c062	ea d9					.word	LOG			; perform LOG()
>c064	ed df					.word	EXP			; perform EXP()
>c066	61 e2					.word	COS			; perform COS()
>c068	68 e2					.word	SIN			; perform SIN()
>c06a	b1 e2					.word	TAN			; perform TAN()
>c06c	0b e3					.word	ATN			; perform ATN()
>c06e	0d d8					.word	PEEK			; perform PEEK()
>c070	7c d7					.word	LEN			; perform LEN()
>c072	65 d4					.word	STR			; perform STR$()
>c074	ad d7					.word	VAL			; perform VAL()
>c076	8b d7					.word	ASC			; perform ASC()
>c078	ec d6					.word	CHR			; perform CHR$()
>c07a	00 d7					.word	LEFT			; perform LEFT$()
>c07c	2c d7					.word	RIGHT			; perform RIGHT$()
>c07e	37 d7					.word	MID			; perform MID$()
.c080					OPTAB
>c080	79					.byte	$79
>c081	69 d8					.word	PLUS-1			; +
>c083	79					.byte	$79
>c084	52 d8					.word	SUB-1			; -
>c086	7b					.byte	$7B
>c087	2a da					.word	MULT-1			; *
>c089	7b					.byte	$7B
>c08a	11 db					.word	DIVIDE-1		; /
>c08c	7f					.byte	$7F
>c08d	7a df					.word	EXPONT-1		; ^
>c08f	50					.byte	$50
>c090	e8 cf					.word	ANDD-1			; AND
>c092	46					.byte	$46
>c093	e5 cf					.word	ORR-1			; OR
>c095	7d					.byte	$7D
>c096	b3 df					.word	NEGFAC-1		; >
>c098	5a					.byte	$5A
>c099	d3 ce					.word	EQUAL-1			; =
.c09b					LAB_C09B
>c09b	64					.byte	$64
>c09c	15 d0					.word	COMPAR-1		; <
.c09e					RESLST
>c09e	45 4e c4				.text	"EN",'D'+$80		; END
>c0a1	46 4f d2				.text	"FO",'R'+$80		; FOR
>c0a4	4e 45 58 d4				.text	"NEX",'T'+$80		; NEXT
>c0a8	44 41 54 c1				.text	"DAT",'A'+$80		; DATA
>c0ac	49 4e 50 55 54 a3			.text	"INPUT",'#'+$80		; INPUT#
>c0b2	49 4e 50 55 d4				.text	"INPU",'T'+$80		; INPUT
>c0b7	44 49 cd				.text	"DI",'M'+$80		; DIM
>c0ba	52 45 41 c4				.text	"REA",'D'+$80		; READ
>c0be	4c 45 d4				.text	"LE",'T'+$80		; LET
>c0c1	47 4f 54 cf				.text	"GOT",'O'+$80		; GOTO
>c0c5	52 55 ce				.text	"RU",'N'+$80		; RUN
>c0c8	49 c6					.text	"I",'F'+$80		; IF
>c0ca	52 45 53 54 4f 52 c5			.text	"RESTOR",'E'+$80	; RESTORE
>c0d1	47 4f 53 55 c2				.text	"GOSU",'B'+$80		; GOSUB
>c0d6	52 45 54 55 52 ce			.text	"RETUR",'N'+$80		; RETURN
>c0dc	52 45 cd				.text	"RE",'M'+$80		; REM
>c0df	53 54 4f d0				.text	"STO",'P'+$80		; STOP
>c0e3	4f ce					.text	"O",'N'+$80		; ON
>c0e5	57 41 49 d4				.text	"WAI",'T'+$80		; WAIT
>c0e9	4c 4f 41 c4				.text	"LOA",'D'+$80		; LOAD
>c0ed	53 41 56 c5				.text	"SAV",'E'+$80		; SAVE
>c0f1	56 45 52 49 46 d9			.text	"VERIF",'Y'+$80		; VERIFY
>c0f7	44 45 c6				.text	"DE",'F'+$80		; DEF
>c0fa	50 4f 4b c5				.text	"POK",'E'+$80		; POKE
>c0fe	50 52 49 4e 54 a3			.text	"PRINT",'#'+$80		; PRINT#
>c104	50 52 49 4e d4				.text	"PRIN",'T'+$80		; PRINT
>c109	43 4f 4e d4				.text	"CON",'T'+$80		; CONT
>c10d	4c 49 53 d4				.text	"LIS",'T'+$80		; LIST
>c111	43 4c d2				.text	"CL",'R'+$80		; CLR
>c114	43 4d c4				.text	"CM",'D'+$80		; CMD
>c117	53 59 d3				.text	"SY",'S'+$80		; SYS
>c11a	4f 50 45 ce				.text	"OPE",'N'+$80		; OPEN
>c11e	43 4c 4f 53 c5				.text	"CLOS",'E'+$80		; CLOSE
>c123	47 45 d4				.text	"GE",'T'+$80		; GET
>c126	4e 45 d7				.text	"NE",'W'+$80		; NEW
>c129	54 41 42 a8				.text	"TAB",'('+$80		; TAB(
>c12d	54 cf					.text	"T",'O'+$80		; TO
>c12f	46 ce					.text	"F",'N'+$80		; FN
>c131	53 50 43 a8				.text	"SPC",'('+$80		; SPC(
>c135	54 48 45 ce				.text	"THE",'N'+$80		; THEN
>c139	4e 4f d4				.text	"NO",'T'+$80		; NOT
>c13c	53 54 45 d0				.text	"STE",'P'+$80		; STEP
>c140	ab					.text	'+'+$80			; +
>c141	ad					.text	'-'+$80			; -
>c142	aa					.text	'*'+$80			; *
>c143	af					.text	'/'+$80			; /
>c144	de					.text	'^'+$80			; ^
>c145	41 4e c4				.text	"AN",'D'+$80		; AND
>c148	4f d2					.text	"O",'R'+$80		; OR
>c14a	be					.text	'>'+$80			; >
>c14b	bd					.text	'='+$80			; =
>c14c	bc					.text	'<'+$80			; <
>c14d	53 47 ce				.text	"SG",'N'+$80		; SGN
>c150	49 4e d4				.text	"IN",'T'+$80		; INT
>c153	41 42 d3				.text	"AB",'S'+$80		; ABS
>c156	55 53 d2				.text	"US",'R'+$80		; USR
>c159	46 52 c5				.text	"FR",'E'+$80		; FRE
>c15c	50 4f d3				.text	"PO",'S'+$80		; POS
>c15f	53 51 d2				.text	"SQ",'R'+$80		; SQR
>c162	52 4e c4				.text	"RN",'D'+$80		; RND
>c165	4c 4f c7				.text	"LO",'G'+$80		; LOG
>c168	45 58 d0				.text	"EX",'P'+$80		; EXP
>c16b	43 4f d3				.text	"CO",'S'+$80		; COS
>c16e	53 49 ce				.text	"SI",'N'+$80		; SIN
>c171	54 41 ce				.text	"TA",'N'+$80		; TAN
>c174	41 54 ce				.text	"AT",'N'+$80		; ATN
>c177	50 45 45 cb				.text	"PEE",'K'+$80		; PEEK
>c17b	4c 45 ce				.text	"LE",'N'+$80		; LEN
>c17e	53 54 52 a4				.text	"STR",'$'+$80		; STR$
>c182	56 41 cc				.text	"VA",'L'+$80		; VAL
>c185	41 53 c3				.text	"AS",'C'+$80		; ASC
>c188	43 48 52 a4				.text	"CHR",'$'+$80		; CHR$
>c18c	4c 45 46 54 a4				.text	"LEFT",'$'+$80		; LEFT$
>c191	52 49 47 48 54 a4			.text	"RIGHT",'$'+$80		; RIGHT$
>c197	4d 49 44 a4				.text	"MID",'$'+$80		; MID$
>c19b	47 cf					.text	"G",'O'+$80		; GO
>c19d	00					.byte	$00			; end marker
=$00					ER_STOP		= $00
=$01					ER_2MANYF	= $01
=$02					ER_FOPEN	= $02
=$03					ER_FNOTOPEN	= $03
=$04					ER_FNOTFND	= $04
=$05					ER_DEVNOTP	= $05
=$06					ER_NOTINF	= $06
=$07					ER_NOTOUTF	= $07
=$08					ER_MISSFNAM	= $08
=$09					ER_ILLDEVN	= $09
=$0a					ER_NXTWOFOR	= $0A
=$0b					ER_SYNTAX	= $0B
=$0c					ER_RETWOGSB	= $0C
=$0d					ER_OODATA	= $0D
=$0e					ER_ILLQUAN	= $0E
=$0f					ER_OVFLOW	= $0F
=$10					ER_OOMEM	= $10
=$11					ER_UNDSMNT	= $11
=$12					ER_BADSSCPT	= $12
=$13					ER_REDIMARY	= $13
=$14					ER_DIVBY0	= $14
=$15					ER_ILLDIR	= $15
=$16					ER_TYPMSMCH	= $16
=$17					ER_STR2LONG	= $17
=$18					ER_FDATA	= $18
=$19					ER_FMLA2CPLX	= $19
=$1a					ER_CANTCONT	= $1A
=$1b					ER_UNDEFUN	= $1B
=$1c					ER_VERIFY	= $1C
=$1d					ER_LOAD		= $1D
=$1e					ER_BREAK	= $1E
.c19e					ERRSTR01
>c19e	54 4f 4f 20 4d 41 4e 59			.text	"TOO MANY FILE",'S'+$80
>c1a6	20 46 49 4c 45 d3
.c1ac					ERRSTR02
>c1ac	46 49 4c 45 20 4f 50 45			.text	"FILE OPE",'N'+$80
>c1b4	ce
.c1b5					ERRSTR03
>c1b5	46 49 4c 45 20 4e 4f 54			.text	"FILE NOT OPE",'N'+$80
>c1bd	20 4f 50 45 ce
.c1c2					ERRSTR04
>c1c2	46 49 4c 45 20 4e 4f 54			.text	"FILE NOT FOUN",'D'+$80
>c1ca	20 46 4f 55 4e c4
.c1d0					ERRSTR05
>c1d0	44 45 56 49 43 45 20 4e			.text	"DEVICE NOT PRESEN",'T'+$80
>c1d8	4f 54 20 50 52 45 53 45 4e d4
.c1e2					ERRSTR06
>c1e2	4e 4f 54 20 49 4e 50 55			.text	"NOT INPUT FIL",'E'+$80
>c1ea	54 20 46 49 4c c5
.c1f0					ERRSTR07
>c1f0	4e 4f 54 20 4f 55 54 50			.text	"NOT OUTPUT FIL",'E'+$80
>c1f8	55 54 20 46 49 4c c5
.c1ff					ERRSTR08
>c1ff	4d 49 53 53 49 4e 47 20			.text	"MISSING FILE NAM",'E'+$80
>c207	46 49 4c 45 20 4e 41 4d c5
.c210					ERRSTR09
>c210	49 4c 4c 45 47 41 4c 20			.text	"ILLEGAL DEVICE NUMBE",'R'+$80
>c218	44 45 56 49 43 45 20 4e 55 4d 42 45 d2
.c225					ERRSTR0A
>c225	4e 45 58 54 20 57 49 54			.text	"NEXT WITHOUT FO",'R'+$80
>c22d	48 4f 55 54 20 46 4f d2
.c235					ERRSTR0B
>c235	53 59 4e 54 41 d8			.text	"SYNTA",'X'+$80
.c23b					ERRSTR0C
>c23b	52 45 54 55 52 4e 20 57			.text	"RETURN WITHOUT GOSU",'B'+$80
>c243	49 54 48 4f 55 54 20 47 4f 53 55 c2
.c24f					ERRSTR0D
>c24f	4f 55 54 20 4f 46 20 44			.text	"OUT OF DAT",'A'+$80
>c257	41 54 c1
.c25a					ERRSTR0E
>c25a	49 4c 4c 45 47 41 4c 20			.text	"ILLEGAL QUANTIT",'Y'+$80
>c262	51 55 41 4e 54 49 54 d9
.c26a					ERRSTR0F
>c26a	4f 56 45 52 46 4c 4f d7			.text	"OVERFLO",'W'+$80
.c272					ERRSTR10
>c272	4f 55 54 20 4f 46 20 4d			.text	"OUT OF MEMOR",'Y'+$80
>c27a	45 4d 4f 52 d9
.c27f					ERRSTR11
>c27f	55 4e 44 45 46 27 44 20			.text	"UNDEF'D STATEMEN",'T'+$80
>c287	53 54 41 54 45 4d 45 4e d4
.c290					ERRSTR12
>c290	42 41 44 20 53 55 42 53			.text	"BAD SUBSCRIP",'T'+$80
>c298	43 52 49 50 d4
.c29d					ERRSTR13
>c29d	52 45 44 49 4d 27 44 20			.text	"REDIM'D ARRA",'Y'+$80
>c2a5	41 52 52 41 d9
.c2aa					ERRSTR14
>c2aa	44 49 56 49 53 49 4f 4e			.text	"DIVISION BY ZER",'O'+$80
>c2b2	20 42 59 20 5a 45 52 cf
.c2ba					ERRSTR15
>c2ba	49 4c 4c 45 47 41 4c 20			.text	"ILLEGAL DIREC",'T'+$80
>c2c2	44 49 52 45 43 d4
.c2c8					ERRSTR16
>c2c8	54 59 50 45 20 4d 49 53			.text	"TYPE MISMATC",'H'+$80
>c2d0	4d 41 54 43 c8
.c2d5					ERRSTR17
>c2d5	53 54 52 49 4e 47 20 54			.text	"STRING TOO LON",'G'+$80
>c2dd	4f 4f 20 4c 4f 4e c7
.c2e4					ERRSTR18
>c2e4	46 49 4c 45 20 44 41 54			.text	"FILE DAT",'A'+$80
>c2ec	c1
.c2ed					ERRSTR19
>c2ed	46 4f 52 4d 55 4c 41 20			.text	"FORMULA TOO COMPLE",'X'+$80
>c2f5	54 4f 4f 20 43 4f 4d 50 4c 45 d8
.c300					ERRSTR1A
>c300	43 41 4e 27 54 20 43 4f			.text	"CAN'T CONTINU",'E'+$80
>c308	4e 54 49 4e 55 c5
.c30e					ERRSTR1B
>c30e	55 4e 44 45 46 27 44 20			.text	"UNDEF'D FUNCTIO",'N'+$80
>c316	46 55 4e 43 54 49 4f ce
.c31e					ERRSTR1C
>c31e	56 45 52 49 46 d9			.text	"VERIF",'Y'+$80
.c324					ERRSTR1D
>c324	4c 4f 41 c4				.text	"LOA",'D'+$80
.c328					BMSGS
>c328	9e c1					.word	ERRSTR01		; $01	TOO MANY FILES
>c32a	ac c1					.word	ERRSTR02		; $02	FILE OPEN
>c32c	b5 c1					.word	ERRSTR03		; $03	FILE NOT OPEN
>c32e	c2 c1					.word	ERRSTR04		; $04	FILE NOT FOUND
>c330	d0 c1					.word	ERRSTR05		; $05	DEVICE NOT PRESENT
>c332	e2 c1					.word	ERRSTR06		; $06	NOT INPUT FILE
>c334	f0 c1					.word	ERRSTR07		; $07	NOT OUTPUT FILE
>c336	ff c1					.word	ERRSTR08		; $08	MISSING FILE NAME
>c338	10 c2					.word	ERRSTR09		; $09	ILLEGAL DEVICE NUMBER
>c33a	25 c2					.word	ERRSTR0A		; $0A	NEXT WITHOUT FOR
>c33c	35 c2					.word	ERRSTR0B		; $0B	SYNTAX
>c33e	3b c2					.word	ERRSTR0C		; $0C	RETURN WITHOUT GOSUB
>c340	4f c2					.word	ERRSTR0D		; $0D	OUT OF DATA
>c342	5a c2					.word	ERRSTR0E		; $0E	ILLEGAL QUANTITY
>c344	6a c2					.word	ERRSTR0F		; $0F	OVERFLOW
>c346	72 c2					.word	ERRSTR10		; $10	OUT OF MEMORY
>c348	7f c2					.word	ERRSTR11		; $11	UNDEF'D STATEMENT
>c34a	90 c2					.word	ERRSTR12		; $12	BAD SUBSCRIPT
>c34c	9d c2					.word	ERRSTR13		; $13	REDIM'D ARRAY
>c34e	aa c2					.word	ERRSTR14		; $14	DIVISION BY ZERO
>c350	ba c2					.word	ERRSTR15		; $15	ILLEGAL DIRECT
>c352	c8 c2					.word	ERRSTR16		; $16	TYPE MISMATCH
>c354	d5 c2					.word	ERRSTR17		; $17	STRING TOO LONG
>c356	e4 c2					.word	ERRSTR18		; $18	FILE DATA
>c358	ed c2					.word	ERRSTR19		; $19	FORMULA TOO COMPLEX
>c35a	00 c3					.word	ERRSTR1A		; $1A	CAN'T CONTINUE
>c35c	0e c3					.word	ERRSTR1B		; $1B	UNDEF'D FUNCTION
>c35e	1e c3					.word	ERRSTR1C		; $1C	VERIFY
>c360	24 c3					.word	ERRSTR1D		; $1D	LOAD
>c362	83 c3					.word	BREAKSTR		; $1E	BREAK
.c364					OKSTR
>c364	0d 4f 4b 0d 00				.text	$0D,"OK",$0D,$00
.c369					ERRORSTR
>c369	0d 20 45 52 52 4f 52 00			.text	$0D," ERROR",$00
.c371					INSTR
>c371	20 49 4e 20 00				.text	" IN ",$00
.c376					READYSTR
>c376	0d 0a 52 45 41 44 59 2e			.text	$0D,$0A,"READY.",$0D,$0A,$00
>c37e	0d 0a 00
.c381					CRLFBRK
>c381	0d 0a					.byte	$0D,$0A
.c383					BREAKSTR
>c383	42 52 45 41 4b 00			.text	"BREAK",$00
>c389	a0					.byte	$A0
.c38a					SCNSTK
.c38a	ba		tsx			TSX				; copy stack pointer
.c38b	e8		inx			INX				; +1 pass return address
.c38c	e8		inx			INX				; +2 pass return address
.c38d	e8		inx			INX				; +3 pass calling routine return address
.c38e	e8		inx			INX				; +4 pass calling routine return address
.c38f					LAB_C38F
.c38f	bd 01 01	lda $0101,x		LDA	STACK+1,X		; get token byte from stack
.c392	c9 81		cmp #$81		CMP	#TK_FOR			; is it FOR token
.c394	d0 21		bne $c3b7		BNE	LAB_C3B7		; exit if not FOR token
.c396	a5 4a		lda $4a			LDA	FORPNT+1		; get FOR/NEXT variable pointer high byte
.c398	d0 0a		bne $c3a4		BNE	LAB_C3A4		; branch if not null
.c39a	bd 02 01	lda $0102,x		LDA	STACK+2,X		; get FOR variable pointer low byte
.c39d	85 49		sta $49			STA	FORPNT			; save FOR/NEXT variable pointer low byte
.c39f	bd 03 01	lda $0103,x		LDA	STACK+3,X		; get FOR variable pointer high byte
.c3a2	85 4a		sta $4a			STA	FORPNT+1		; save FOR/NEXT variable pointer high byte
.c3a4					LAB_C3A4
.c3a4	dd 03 01	cmp $0103,x		CMP	STACK+3,X		; compare variable pointer with stacked variable pointer
.c3a7	d0 07		bne $c3b0		BNE	LAB_C3B0		; branch if no match
.c3a9	a5 49		lda $49			LDA	FORPNT			; get FOR/NEXT variable pointer low byte
.c3ab	dd 02 01	cmp $0102,x		CMP	STACK+2,X		; compare variable pointer with stacked variable pointer
.c3ae	f0 07		beq $c3b7		BEQ	LAB_C3B7		; exit if match found
.c3b0					LAB_C3B0
.c3b0	8a		txa			TXA				; copy index
.c3b1	18		clc			CLC				; clear carry for add
.c3b2	69 12		adc #$12		ADC	#$12			; add FOR stack use size
.c3b4	aa		tax			TAX				; copy back to index
.c3b5	d0 d8		bne $c38f		BNE	LAB_C38F		; loop if not at start of stack
.c3b7					LAB_C3B7
.c3b7	60		rts			RTS
.c3b8					MAKSPC
.c3b8	20 08 c4	jsr $c408		JSR	RAMSPC			; check available memory, do out of memory error if no room
.c3bb	85 31		sta $31			STA	STREND			; set end of arrays low byte
.c3bd	84 32		sty $32			STY	STREND+1		; set end of arrays high byte
.c3bf					MOVEBL
.c3bf	38		sec			SEC				; set carry for subtract
.c3c0	a5 5a		lda $5a			LDA	GEN2PTR			; get block end low byte
.c3c2	e5 5f		sbc $5f			SBC	TMPPTR			; subtract block start low byte
.c3c4	85 22		sta $22			STA	INDEX			; save MOD(block length/$100) byte
.c3c6	a8		tay			TAY				; copy MOD(block length/$100) byte to .Y
.c3c7	a5 5b		lda $5b			LDA	GEN2PTR+1		; get block end high byte
.c3c9	e5 60		sbc $60			SBC	TMPPTR+1		; subtract block start high byte
.c3cb	aa		tax			TAX				; copy block length high byte to .X
.c3cc	e8		inx			INX				; +1 to allow for count=0 exit
.c3cd	98		tya			TYA				; copy block length low byte to .A
.c3ce	f0 23		beq $c3f3		BEQ	LAB_C3F3		; branch if length low byte=0
.c3d0	a5 5a		lda $5a			LDA	GEN2PTR			; get block end low byte
.c3d2	38		sec			SEC				; set carry for subtract
.c3d3	e5 22		sbc $22			SBC	INDEX			; subtract MOD(block length/$100) byte
.c3d5	85 5a		sta $5a			STA	GEN2PTR			; save corrected old block end low byte
.c3d7	b0 03		bcs $c3dc		BCS	LAB_C3DC		; if no underflow skip the high byte decrement
.c3d9	c6 5b		dec $5b			DEC	GEN2PTR+1		; else decrement block end high byte
.c3db	38		sec			SEC				; set carry for subtract
.c3dc					LAB_C3DC
.c3dc	a5 58		lda $58			LDA	GENPTR			; get destination end low byte
.c3de	e5 22		sbc $22			SBC	INDEX			; subtract MOD(block length/$100) byte
.c3e0	85 58		sta $58			STA	GENPTR			; save modified new block end low byte
.c3e2	b0 08		bcs $c3ec		BCS	LAB_C3EC		; if no underflow skip the high byte decrement
.c3e4	c6 59		dec $59			DEC	GENPTR+1		; else decrement block end high byte
.c3e6	90 04		bcc $c3ec		BCC	LAB_C3EC		; branch always
.c3e8					LAB_C3E8
.c3e8	b1 5a		lda ($5a),y		LDA	(GEN2PTR),Y		; get byte from source
.c3ea	91 58		sta ($58),y		STA	(GENPTR),Y		; copy byte to destination
.c3ec					LAB_C3EC
.c3ec	88		dey			DEY				; decrement index
.c3ed	d0 f9		bne $c3e8		BNE	LAB_C3E8		; loop until .Y=0
.c3ef	b1 5a		lda ($5a),y		LDA	(GEN2PTR),Y		; get byte from source
.c3f1	91 58		sta ($58),y		STA	(GENPTR),Y		; save byte to destination
.c3f3					LAB_C3F3
.c3f3	c6 5b		dec $5b			DEC	GEN2PTR+1		; decrement source pointer high byte
.c3f5	c6 59		dec $59			DEC	GENPTR+1		; decrement destination pointer high byte
.c3f7	ca		dex			DEX				; decrement block count
.c3f8	d0 f2		bne $c3ec		BNE	LAB_C3EC		; loop until count = $0
.c3fa	60		rts			RTS
.c3fb					STKSPC
.c3fb	0a		asl a			ASL				; *2
.c3fc	69 3e		adc #$3e		ADC	#$3E			; need at least 62d bytes free
.c3fe	b0 35		bcs $c435		BCS	MEMERR			; if overflow go do out of memory error then warm start
.c400	85 22		sta $22			STA	INDEX			; save result in temp byte
.c402	ba		tsx			TSX				; copy stack
.c403	e4 22		cpx $22			CPX	INDEX			; compare new limit with stack
.c405	90 2e		bcc $c435		BCC	MEMERR			; if stack < limit do out of memory error then warm start
.c407	60		rts			RTS
.c408					RAMSPC
.c408	c4 34		cpy $34			CPY	FRETOP+1		; compare with bottom of string space high byte
.c40a	90 28		bcc $c434		BCC	LAB_C434		; if less then exit (is ok)
.c40c	d0 04		bne $c412		BNE	LAB_C412		; skip next test if greater (tested <)
.c40e	c5 33		cmp $33			CMP	FRETOP			; compare with bottom of string space low byte
.c410	90 22		bcc $c434		BCC	LAB_C434		; if less then exit (is ok)
.c412					LAB_C412
.c412	48		pha			PHA				; push address low byte
.c413	a2 09		ldx #$09		LDX	#$09			; set index to save TEMPF3 to TMPPTR+1 inclusive
.c415	98		tya			TYA				; copy address high byte (to push on stack)
.c416					LAB_C416
.c416	48		pha			PHA				; push byte
.c417	b5 57		lda $57,x		LDA	TEMPF3,X		; get byte from TEMPF3 to TMPPTR+1
.c419	ca		dex			DEX				; decrement index
.c41a	10 fa		bpl $c416		BPL	LAB_C416		; loop until all done
.c41c	20 26 d5	jsr $d526		JSR	GRBCOL			; do garbage collection routine
.c41f	a2 f7		ldx #$f7		LDX	#$F7			; set index to restore bytes
.c421					LAB_C421
.c421	68		pla			PLA				; pop byte
.c422	95 61		sta $61,x		STA	TMPPTR+2,X		; save byte to TEMPF3 to TMPPTR+2
.c424	e8		inx			INX				; increment index
.c425	30 fa		bmi $c421		BMI	LAB_C421		; loop while -ve
.c427	68		pla			PLA				; pop address high byte
.c428	a8		tay			TAY				; copy back to .Y
.c429	68		pla			PLA				; pop address low byte
.c42a	c4 34		cpy $34			CPY	FRETOP+1		; compare with bottom of string space high byte
.c42c	90 06		bcc $c434		BCC	LAB_C434		; if less then exit (is ok)
.c42e	d0 05		bne $c435		BNE	MEMERR			; if greater do out of memory error then warm start
.c430	c5 33		cmp $33			CMP	FRETOP			; compare with bottom of string space low byte
.c432	b0 01		bcs $c435		BCS	MEMERR			; if >= do out of memory error then warm start
.c434					LAB_C434
.c434	60		rts			RTS
.c435					MEMERR
.c435	a2 10		ldx #$10		LDX	#ER_OOMEM		; error code $10, out of memory error
.c437					ERROR
.c437	6c 00 03	jmp ($0300)		JMP	(IERROR)		; do error message
.c43a					ERROR2
.c43a	8a		txa			TXA				; copy error number
.c43b	0a		asl a			ASL				; *2
.c43c	aa		tax			TAX				; copy to index
.c43d	bd 26 c3	lda $c326,x		LDA	BMSGS-2,X		; get error message pointer low byte
.c440	85 22		sta $22			STA	INDEX			; save it
.c442	bd 27 c3	lda $c327,x		LDA	BMSGS-1,X		; get error message pointer high byte
.c445	85 23		sta $23			STA	INDEX+1			; save it
.c447	20 cc ff	jsr $ffcc		JSR	CLRCHN			; close input and output channels
.c44a	a9 00		lda #$00		LDA	#$00			; clear .A
.c44c	85 13		sta $13			STA	CHANNL			; clear current I/O channel, flag default
.c44e	20 d7 ca	jsr $cad7		JSR	LAB_CAD7		; print CR/LF
.c451	20 45 cb	jsr $cb45		JSR	LAB_CB45		; print "?"
.c454	a0 00		ldy #$00		LDY	#$00			; clear index
.c456					LAB_C456
.c456	b1 22		lda ($22),y		LDA	(INDEX),Y		; get byte from message
.c458	48		pha			PHA				; save status
.c459	29 7f		and #$7f		AND	#$7F			; mask 0xxx xxxx, clear b7
.c45b	20 47 cb	jsr $cb47		JSR	LAB_CB47		; output character
.c45e	c8		iny			INY				; increment index
.c45f	68		pla			PLA				; restore status
.c460	10 f4		bpl $c456		BPL	LAB_C456		; loop if character was not end marker
.c462	20 7a c6	jsr $c67a		JSR	LAB_C67A		; flush BASIC stack and clear continue pointer
.c465	a9 69		lda #$69		LDA	#<ERRORSTR		; set " ERROR" pointer low byte
.c467	a0 c3		ldy #$c3		LDY	#>ERRORSTR		; set " ERROR" pointer high byte
.c469					PRDY
.c469	20 1e cb	jsr $cb1e		JSR	PRTSTR			; print null terminated string
.c46c	a4 3a		ldy $3a			LDY	CURLIN+1		; get current line number high byte
.c46e	c8		iny			INY				; increment it
.c46f	f0 03		beq $c474		BEQ	READY			; branch if was in immediate mode
.c471	20 c2 dd	jsr $ddc2		JSR	PRTIN			; do " IN " line number message
.c474					READY
.c474	a9 76		lda #$76		LDA	#<READYSTR		; set "READY." pointer low byte
.c476	a0 c3		ldy #$c3		LDY	#>READYSTR		; set "READY." pointer high byte
.c478	20 1e cb	jsr $cb1e		JSR	PRTSTR			; print null terminated string
.c47b	a9 80		lda #$80		LDA	#$80			; set for control messages only
.c47d	20 90 ff	jsr $ff90		JSR	SETMSG			; control KERNAL messages
.c480					MAIN
.c480	6c 02 03	jmp ($0302)		JMP	(IMAIN)			; do BASIC warm start
.c483					MAIN2
.c483	20 60 c5	jsr $c560		JSR	GETLIN			; call for BASIC input
.c486	86 7a		stx $7a			STX	CHRGOT+1		; save BASIC execute pointer low byte
.c488	84 7b		sty $7b			STY	CHRGOT+2		; save BASIC execute pointer high byte
.c48a	20 73 00	jsr $0073		JSR	CHRGET			; increment and scan memory
.c48d	aa		tax			TAX				; copy byte to set flags
.c48e	f0 f0		beq $c480		BEQ	MAIN			; loop if no input
.c490	a2 ff		ldx #$ff		LDX	#$FF			; current line high byte to -1, indicates immediate mode
.c492	86 3a		stx $3a			STX	CURLIN+1		; set current line number high byte
.c494	90 06		bcc $c49c		BCC	NEWLIN			; if numeric character go handle new BASIC line
.c496	20 79 c5	jsr $c579		JSR	CRNCH			; crunch keywords into BASIC tokens
.c499	4c e1 c7	jmp $c7e1		JMP	LAB_C7E1		; go scan and interpret code
.c49c					NEWLIN
.c49c	20 6b c9	jsr $c96b		JSR	DECBIN			; get fixed-point number into temporary integer
.c49f	20 79 c5	jsr $c579		JSR	CRNCH			; crunch keywords into BASIC tokens
.c4a2	84 0b		sty $0b			STY	COUNT			; save index pointer to end of crunched line
.c4a4	20 13 c6	jsr $c613		JSR	FINLIN			; search BASIC for temporary integer line number
.c4a7	90 44		bcc $c4ed		BCC	LAB_C4ED		; if not found skip the line delete
.c4a9	a0 01		ldy #$01		LDY	#$01			; set index to next line pointer high byte
.c4ab	b1 5f		lda ($5f),y		LDA	(TMPPTR),Y		; get next line pointer high byte
.c4ad	85 23		sta $23			STA	INDEX+1			; save it
.c4af	a5 2d		lda $2d			LDA	VARTAB			; get start of variables low byte
.c4b1	85 22		sta $22			STA	INDEX			; save it
.c4b3	a5 60		lda $60			LDA	TMPPTR+1		; get found line pointer high byte
.c4b5	85 25		sta $25			STA	INDEX+3			; save it
.c4b7	a5 5f		lda $5f			LDA	TMPPTR			; get found line pointer low byte
.c4b9	88		dey			DEY				; decrement index
.c4ba	f1 5f		sbc ($5f),y		SBC	(TMPPTR),Y		; subtract next line pointer low byte
.c4bc	18		clc			CLC				; clear carry for add
.c4bd	65 2d		adc $2d			ADC	VARTAB			; add start of variables low byte
.c4bf	85 2d		sta $2d			STA	VARTAB			; set start of variables low byte
.c4c1	85 24		sta $24			STA	INDEX+2			; save destination pointer low byte
.c4c3	a5 2e		lda $2e			LDA	VARTAB+1		; get start of variables high byte
.c4c5	69 ff		adc #$ff		ADC	#$FF			; -1 + carry
.c4c7	85 2e		sta $2e			STA	VARTAB+1		; set start of variables high byte
.c4c9	e5 60		sbc $60			SBC	TMPPTR+1		; subtract found line pointer high byte
.c4cb	aa		tax			TAX				; copy to block count
.c4cc	38		sec			SEC				; set carry for subtract
.c4cd	a5 5f		lda $5f			LDA	TMPPTR			; get found line pointer low byte
.c4cf	e5 2d		sbc $2d			SBC	VARTAB			; subtract start of variables low byte
.c4d1	a8		tay			TAY				; copy to bytes in first block count
.c4d2	b0 03		bcs $c4d7		BCS	LAB_C4D7		; if no underflow skip the high byte decrement
.c4d4	e8		inx			INX				; increment block count, correct for = 0 loop exit
.c4d5	c6 25		dec $25			DEC	INDEX+3			; decrement destination high byte
.c4d7					LAB_C4D7
.c4d7	18		clc			CLC				; clear carry for add
.c4d8	65 22		adc $22			ADC	INDEX			; add source pointer low byte
.c4da	90 03		bcc $c4df		BCC	LAB_C4DF		; if no underflow skip the high byte decrement
.c4dc	c6 23		dec $23			DEC	INDEX+1			; else decrement source pointer high byte
.c4de	18		clc			CLC				; clear carry
.c4df					LAB_C4DF
.c4df	b1 22		lda ($22),y		LDA	(INDEX),Y		; get byte from source
.c4e1	91 24		sta ($24),y		STA	(INDEX+2),Y		; copy to destination
.c4e3	c8		iny			INY				; increment index
.c4e4	d0 f9		bne $c4df		BNE	LAB_C4DF		; while <> 0 do this block
.c4e6	e6 23		inc $23			INC	INDEX+1			; increment source pointer high byte
.c4e8	e6 25		inc $25			INC	INDEX+3			; increment destination pointer high byte
.c4ea	ca		dex			DEX				; decrement block count
.c4eb	d0 f2		bne $c4df		BNE	LAB_C4DF		; loop until all done
.c4ed					LAB_C4ED
.c4ed	20 59 c6	jsr $c659		JSR	LAB_C659		; reset execution to start, clear variables, flush stack
.c4f0	20 33 c5	jsr $c533		JSR	LNKPRG			; rebuild BASIC line chaining
.c4f3	ad 00 02	lda $0200		LDA	BUF			; get first byte from buffer
.c4f6	f0 88		beq $c480		BEQ	MAIN			; if no line go do BASIC warm start
.c4f8	18		clc			CLC				; clear carry for add
.c4f9	a5 2d		lda $2d			LDA	VARTAB			; get start of variables low byte
.c4fb	85 5a		sta $5a			STA	GEN2PTR			; save as source end pointer low byte
.c4fd	65 0b		adc $0b			ADC	COUNT			; add index pointer to end of crunched line
.c4ff	85 58		sta $58			STA	GENPTR			; save as destination end pointer low byte
.c501	a4 2e		ldy $2e			LDY	VARTAB+1		; get start of variables high byte
.c503	84 5b		sty $5b			STY	GEN2PTR+1		; save as source end pointer high byte
.c505	90 01		bcc $c508		BCC	LAB_C508		; if no carry skip the high byte increment
.c507	c8		iny			INY				; else increment the high byte
.c508					LAB_C508
.c508	84 59		sty $59			STY	GENPTR+1		; save as destination end pointer high byte
.c50a	20 b8 c3	jsr $c3b8		JSR	MAKSPC			; open up space in memory
.c50d	a5 14		lda $14			LDA	LINNUM			; get line number low byte
.c50f	a4 15		ldy $15			LDY	LINNUM+1		; get line number high byte
.c511	8d fe 01	sta $01fe		STA	PREVLN			; save line number low byte before crunched line
.c514	8c ff 01	sty $01ff		STY	PREVLN+1		; save line number high byte before crunched line
.c517	a5 31		lda $31			LDA	STREND			; get end of arrays low byte
.c519	a4 32		ldy $32			LDY	STREND+1		; get end of arrays high byte
.c51b	85 2d		sta $2d			STA	VARTAB			; set start of variables low byte
.c51d	84 2e		sty $2e			STY	VARTAB+1		; set start of variables high byte
.c51f	a4 0b		ldy $0b			LDY	COUNT			; get index to end of crunched line
.c521	88		dey			DEY				; -1
.c522					LAB_C522
.c522	b9 fc 01	lda $01fc,y		LDA	CHNLNK,Y		; get byte from crunched line
.c525	91 5f		sta ($5f),y		STA	(TMPPTR),Y		; save byte to memory
.c527	88		dey			DEY				; decrement index
.c528	10 f8		bpl $c522		BPL	LAB_C522		; loop while more to do
.c52a					LAB_C52A
.c52a	20 59 c6	jsr $c659		JSR	LAB_C659		; reset execution to start, clear variables and flush stack
.c52d	20 33 c5	jsr $c533		JSR	LNKPRG			; rebuild BASIC line chaining
.c530	4c 80 c4	jmp $c480		JMP	MAIN			; go do BASIC warm start
.c533					LNKPRG
.c533	a5 2b		lda $2b			LDA	TXTTAB			; get start of memory low byte
.c535	a4 2c		ldy $2c			LDY	TXTTAB+1		; get start of memory high byte
.c537	85 22		sta $22			STA	INDEX			; set line start pointer low byte
.c539	84 23		sty $23			STY	INDEX+1			; set line start pointer high byte
.c53b	18		clc			CLC				; clear carry for add
.c53c					LAB_C53C
.c53c	a0 01		ldy #$01		LDY	#$01			; set index to pointer to next line high byte
.c53e	b1 22		lda ($22),y		LDA	(INDEX),Y		; get pointer to next line high byte
.c540	f0 1d		beq $c55f		BEQ	LAB_C55F		; exit if null, [EOT]
.c542	a0 04		ldy #$04		LDY	#$04			; point to first code byte of line
.c544					LAB_C544
.c544	c8		iny			INY				; next code byte
.c545	b1 22		lda ($22),y		LDA	(INDEX),Y		; get byte
.c547	d0 fb		bne $c544		BNE	LAB_C544		; loop if not [EOL]
.c549	c8		iny			INY				; point to byte past [EOL], start of next line
.c54a	98		tya			TYA				; copy it
.c54b	65 22		adc $22			ADC	INDEX			; add line start pointer low byte
.c54d	aa		tax			TAX				; copy to .X
.c54e	a0 00		ldy #$00		LDY	#$00			; clear index, point to this line's next line pointer
.c550	91 22		sta ($22),y		STA	(INDEX),Y		; set next line pointer low byte
.c552	a5 23		lda $23			LDA	INDEX+1			; get line start pointer high byte
.c554	69 00		adc #$00		ADC	#$00			; add any overflow
.c556	c8		iny			INY				; increment index to high byte
.c557	91 22		sta ($22),y		STA	(INDEX),Y		; set next line pointer high byte
.c559	86 22		stx $22			STX	INDEX			; set line start pointer low byte
.c55b	85 23		sta $23			STA	INDEX+1			; set line start pointer high byte
.c55d	90 dd		bcc $c53c		BCC	LAB_C53C		; go do next line, branch always
.c55f					LAB_C55F
.c55f	60		rts			RTS
.c560					GETLIN
.c560	a2 00		ldx #$00		LDX	#$00			; set channel $00, keyboard
.c562					LAB_C562
.c562	20 0f e1	jsr $e10f		JSR	LAB_E10F		; input character from channel with error check
.c565	c9 0d		cmp #$0d		CMP	#$0D			; compare with [RETURN]
.c567	f0 0d		beq $c576		BEQ	LAB_C576		; if [RETURN] set .X.Y to BUF - 1, print [RETURN] and exit
.c569	9d 00 02	sta $0200,x		STA	BUF,X			; save character to buffer
.c56c	e8		inx			INX				; increment buffer index
.c56d	e0 59		cpx #$59		CPX	#$59			; compare with max+1
.c56f	90 f1		bcc $c562		BCC	LAB_C562		; branch if < max+1
.c571	a2 17		ldx #$17		LDX	#ER_STR2LONG		; error $17, string too long error
.c573	4c 37 c4	jmp $c437		JMP	ERROR			; do error #.X then warm start
.c576					LAB_C576
.c576	4c ca ca	jmp $caca		JMP	LAB_CACA		; set .X.Y to BUF - 1 and print [CR]
.c579					CRNCH
.c579	6c 04 03	jmp ($0304)		JMP	(ICRNCH)		; do crunch BASIC tokens
.c57c					CRNCH2
.c57c	a6 7a		ldx $7a			LDX	CHRGOT+1		; get BASIC execute pointer low byte
.c57e	a0 04		ldy #$04		LDY	#$04			; set save index
.c580	84 0f		sty $0f			STY	GARBFL			; clear open quote/DATA flag
.c582					LAB_C582
.c582	bd 00 02	lda $0200,x		LDA	BUF,X			; get a byte from the input buffer
.c585	10 07		bpl $c58e		BPL	LAB_C58E		; if b7 clear go do crunching
.c587	c9 ff		cmp #$ff		CMP	#TK_PI			; compare with the token for PI, this token is input
.c589	f0 3e		beq $c5c9		BEQ	LAB_C5C9		; if PI save byte then continue crunching
.c58b	e8		inx			INX				; increment read index
.c58c	d0 f4		bne $c582		BNE	LAB_C582		; loop if more to do, branch always
.c58e					LAB_C58E
.c58e	c9 20		cmp #$20		CMP	#' '			; compare with [SPACE]
.c590	f0 37		beq $c5c9		BEQ	LAB_C5C9		; if [SPACE] save byte then continue crunching
.c592	85 08		sta $08			STA	ENDCHR			; save buffer byte as search character
.c594	c9 22		cmp #$22		CMP	#$22			; compare with quote character
.c596	f0 56		beq $c5ee		BEQ	LAB_C5EE		; if quote go copy quoted string
.c598	24 0f		bit $0f			BIT	GARBFL			; get open quote/DATA token flag
.c59a	70 2d		bvs $c5c9		BVS	LAB_C5C9		; branch if b6 of open quote set, was DATA
.c59c	c9 3f		cmp #$3f		CMP	#'?'			; compare with "?" character
.c59e	d0 04		bne $c5a4		BNE	LAB_C5A4		; if not "?" continue crunching
.c5a0	a9 99		lda #$99		LDA	#TK_PRINT		; else set the token for PRINT
.c5a2	d0 25		bne $c5c9		BNE	LAB_C5C9		; go save byte then continue crunching, branch always
.c5a4					LAB_C5A4
.c5a4	c9 30		cmp #$30		CMP	#'0'			; compare with "0"
.c5a6	90 04		bcc $c5ac		BCC	LAB_C5AC		; if < "0" continue crunching
.c5a8	c9 3c		cmp #$3c		CMP	#'<'			; compare with "<"
.c5aa	90 1d		bcc $c5c9		BCC	LAB_C5C9		; if <, 0123456789:; go save byte then continue crunching
.c5ac					LAB_C5AC
.c5ac	84 71		sty $71			STY	FBUFPT			; copy save index
.c5ae	a0 00		ldy #$00		LDY	#$00			; clear table pointer
.c5b0	84 0b		sty $0b			STY	COUNT			; clear word index
.c5b2	88		dey			DEY				; adjust for pre increment loop
.c5b3	86 7a		stx $7a			STX	CHRGOT+1		; save BASIC execute pointer low byte, buffer index
.c5b5	ca		dex			DEX				; adjust for pre increment loop
.c5b6					LAB_C5B6
.c5b6	c8		iny			INY				; next table byte
.c5b7	e8		inx			INX				; next buffer byte
.c5b8					LAB_C5B8
.c5b8	bd 00 02	lda $0200,x		LDA	BUF,X			; get byte from input buffer
.c5bb	38		sec			SEC				; set carry for subtract
.c5bc	f9 9e c0	sbc $c09e,y		SBC	RESLST,Y		; subtract table byte
.c5bf	f0 f5		beq $c5b6		BEQ	LAB_C5B6		; go compare next if match
.c5c1	c9 80		cmp #$80		CMP	#$80			; was it end marker match ?
.c5c3	d0 30		bne $c5f5		BNE	LAB_C5F5		; if not go try the next keyword
.c5c5	05 0b		ora $0b			ORA	COUNT			; OR with word index, +$80 in .A makes token
.c5c7					LAB_C5C7
.c5c7	a4 71		ldy $71			LDY	FBUFPT			; restore save index
.c5c9					LAB_C5C9
.c5c9	e8		inx			INX				; increment buffer read index
.c5ca	c8		iny			INY				; increment save index
.c5cb	99 fb 01	sta $01fb,y		STA	BUF-5,Y			; save byte to output
.c5ce	b9 fb 01	lda $01fb,y		LDA	BUF-5,Y			; get byte from output, set flags
.c5d1	f0 36		beq $c609		BEQ	LAB_C609		; branch if was null [EOL]
.c5d3	38		sec			SEC				; set carry for subtract
.c5d4	e9 3a		sbc #$3a		SBC	#':'			; subtract ":"
.c5d6	f0 04		beq $c5dc		BEQ	LAB_C5DC		; branch if it was (is now $00)
.c5d8	c9 49		cmp #$49		CMP	#TK_DATA-':'		; compare with the token for DATA-':'
.c5da	d0 02		bne $c5de		BNE	LAB_C5DE		; if not DATA go try REM
.c5dc					LAB_C5DC
.c5dc	85 0f		sta $0f			STA	GARBFL			; save token-':'
.c5de					LAB_C5DE
.c5de	38		sec			SEC				; set carry for subtract
.c5df	e9 55		sbc #$55		SBC	#TK_REM-':'		; subtract the token for REM-':'
.c5e1	d0 9f		bne $c582		BNE	LAB_C582		; if wasn't REM go crunch next bit of line
.c5e3	85 08		sta $08			STA	ENDCHR			; else was REM so set search for [EOL]
.c5e5					LAB_C5E5
.c5e5	bd 00 02	lda $0200,x		LDA	BUF,X			; get byte from input buffer
.c5e8	f0 df		beq $c5c9		BEQ	LAB_C5C9		; if null [EOL] save byte then continue crunching
.c5ea	c5 08		cmp $08			CMP	ENDCHR			; compare with stored character
.c5ec	f0 db		beq $c5c9		BEQ	LAB_C5C9		; if match save byte then continue crunching
.c5ee					LAB_C5EE
.c5ee	c8		iny			INY				; increment save index
.c5ef	99 fb 01	sta $01fb,y		STA	BUF-5,Y			; save byte to output
.c5f2	e8		inx			INX				; increment buffer index
.c5f3	d0 f0		bne $c5e5		BNE	LAB_C5E5		; loop while <> 0, should never reach 0
.c5f5					LAB_C5F5
.c5f5	a6 7a		ldx $7a			LDX	CHRGOT+1		; restore BASIC execute pointer low byte
.c5f7	e6 0b		inc $0b			INC	COUNT			; increment word index (next word)
.c5f9					LAB_C5F9
.c5f9	c8		iny			INY				; increment table index
.c5fa	b9 9d c0	lda $c09d,y		LDA	RESLST-1,Y		; get table byte
.c5fd	10 fa		bpl $c5f9		BPL	LAB_C5F9		; loop if not end of word yet
.c5ff	b9 9e c0	lda $c09e,y		LDA	RESLST,Y		; get byte from keyword table
.c602	d0 b4		bne $c5b8		BNE	LAB_C5B8		; go test next word if not zero byte, end of table
.c604	bd 00 02	lda $0200,x		LDA	BUF,X			; restore byte from input buffer
.c607	10 be		bpl $c5c7		BPL	LAB_C5C7		; branch always, all unmatched bytes in the buffer are
.c609					LAB_C609
.c609	99 fd 01	sta $01fd,y		STA	BUF-3,Y			; save [EOL]
.c60c	c6 7b		dec $7b			DEC	CHRGOT+2		; decrement BASIC execute pointer high byte
.c60e	a9 ff		lda #$ff		LDA	#$FF			; point to start of buffer - 1
.c610	85 7a		sta $7a			STA	CHRGOT+1		; set BASIC execute pointer low byte
.c612	60		rts			RTS
.c613					FINLIN
.c613	a5 2b		lda $2b			LDA	TXTTAB			; get start of memory low byte
.c615	a6 2c		ldx $2c			LDX	TXTTAB+1		; get start of memory high byte
.c617					LAB_C617
.c617	a0 01		ldy #$01		LDY	#$01			; set index to next line pointer high byte
.c619	85 5f		sta $5f			STA	TMPPTR			; save low byte as current
.c61b	86 60		stx $60			STX	TMPPTR+1		; save high byte as current
.c61d	b1 5f		lda ($5f),y		LDA	(TMPPTR),Y		; get next line pointer high byte from address
.c61f	f0 1f		beq $c640		BEQ	LAB_C640		; pointer was zero so done, exit
.c621	c8		iny			INY				; increment index ...
.c622	c8		iny			INY				; ... to line # high byte
.c623	a5 15		lda $15			LDA	LINNUM+1		; get temporary integer high byte
.c625	d1 5f		cmp ($5f),y		CMP	(TMPPTR),Y		; compare with line # high byte
.c627	90 18		bcc $c641		BCC	LAB_C641		; exit if temp < this line, target line passed
.c629	f0 03		beq $c62e		BEQ	LAB_C62E		; go check low byte if =
.c62b	88		dey			DEY				; else decrement index
.c62c	d0 09		bne $c637		BNE	LAB_C637		; branch always
.c62e					LAB_C62E
.c62e	a5 14		lda $14			LDA	LINNUM			; get temporary integer low byte
.c630	88		dey			DEY				; decrement index to line # low byte
.c631	d1 5f		cmp ($5f),y		CMP	(TMPPTR),Y		; compare with line # low byte
.c633	90 0c		bcc $c641		BCC	LAB_C641		; exit if temp < this line, target line passed
.c635	f0 0a		beq $c641		BEQ	LAB_C641		; exit if temp = (found line#)
.c637					LAB_C637
.c637	88		dey			DEY				; decrement index to next line pointer high byte
.c638	b1 5f		lda ($5f),y		LDA	(TMPPTR),Y		; get next line pointer high byte
.c63a	aa		tax			TAX				; copy to .X
.c63b	88		dey			DEY				; decrement index to next line pointer low byte
.c63c	b1 5f		lda ($5f),y		LDA	(TMPPTR),Y		; get next line pointer low byte
.c63e	b0 d7		bcs $c617		BCS	LAB_C617		; go search for line # in temporary integer
.c640					LAB_C640
.c640	18		clc			CLC				; clear found flag
.c641					LAB_C641
.c641	60		rts			RTS
.c642					NEW
.c642	d0 fd		bne $c641		BNE	LAB_C641		; exit if following byte to allow syntax error
.c644					LAB_C644
.c644	a9 00		lda #$00		LDA	#$00			; clear .A
.c646	a8		tay			TAY				; clear index
.c647	91 2b		sta ($2b),y		STA	(TXTTAB),Y		; clear pointer to next line low byte
.c649	c8		iny			INY				; increment index
.c64a	91 2b		sta ($2b),y		STA	(TXTTAB),Y		; clear pointer to next line high byte, erase program
.c64c	a5 2b		lda $2b			LDA	TXTTAB			; get start of memory low byte
.c64e	18		clc			CLC				; clear carry for add
.c64f	69 02		adc #$02		ADC	#$02			; add null program length
.c651	85 2d		sta $2d			STA	VARTAB			; set start of variables low byte
.c653	a5 2c		lda $2c			LDA	TXTTAB+1		; get start of memory high byte
.c655	69 00		adc #$00		ADC	#$00			; add carry
.c657	85 2e		sta $2e			STA	VARTAB+1		; set start of variables high byte
.c659					LAB_C659
.c659	20 8e c6	jsr $c68e		JSR	STXTPT			; set BASIC execute pointer to start of memory - 1
.c65c	a9 00		lda #$00		LDA	#$00			; set Zb for CLR entry
.c65e					CLR
.c65e	d0 2d		bne $c68d		BNE	LAB_C68D		; exit if following byte to allow syntax error
.c660					LAB_C660
.c660	20 e7 ff	jsr $ffe7		JSR	CLALL			; close all channels and files
.c663					LAB_C663
.c663	a5 37		lda $37			LDA	MEMSIZ			; get end of memory low byte
.c665	a4 38		ldy $38			LDY	MEMSIZ+1		; get end of memory high byte
.c667	85 33		sta $33			STA	FRETOP			; set bottom of string space low byte, clear strings
.c669	84 34		sty $34			STY	FRETOP+1		; set bottom of string space high byte
.c66b	a5 2d		lda $2d			LDA	VARTAB			; get start of variables low byte
.c66d	a4 2e		ldy $2e			LDY	VARTAB+1		; get start of variables high byte
.c66f	85 2f		sta $2f			STA	ARYTAB			; set end of variables low byte, clear variables
.c671	84 30		sty $30			STY	ARYTAB+1		; set end of variables high byte
.c673	85 31		sta $31			STA	STREND			; set end of arrays low byte, clear arrays
.c675	84 32		sty $32			STY	STREND+1		; set end of arrays high byte
.c677					LAB_C677
.c677	20 1d c8	jsr $c81d		JSR	RESTORE			; perform RESTORE
.c67a					LAB_C67A
.c67a	a2 19		ldx #$19		LDX	#TEMPST			; get descriptor stack start
.c67c	86 16		stx $16			STX	TEMPPT			; set descriptor stack pointer
.c67e	68		pla			PLA				; pull return address low byte
.c67f	a8		tay			TAY				; copy it
.c680	68		pla			PLA				; pull return address high byte
.c681	a2 fa		ldx #$fa		LDX	#$FA			; set cleared stack pointer
.c683	9a		txs			TXS				; set stack
.c684	48		pha			PHA				; push return address high byte
.c685	98		tya			TYA				; restore return address low byte
.c686	48		pha			PHA				; push return address low byte
.c687	a9 00		lda #$00		LDA	#$00			; clear .A
.c689	85 3e		sta $3e			STA	OLDTXT+1		; clear continue pointer high byte
.c68b	85 10		sta $10			STA	SUBFLG			; clear subscript/FNx flag
.c68d					LAB_C68D
.c68d	60		rts			RTS
.c68e					STXTPT
.c68e	18		clc			CLC				; clear carry for add
.c68f	a5 2b		lda $2b			LDA	TXTTAB			; get start of memory low byte
.c691	69 ff		adc #$ff		ADC	#$FF			; add -1 low byte
.c693	85 7a		sta $7a			STA	CHRGOT+1		; set BASIC execute pointer low byte
.c695	a5 2c		lda $2c			LDA	TXTTAB+1		; get start of memory high byte
.c697	69 ff		adc #$ff		ADC	#$FF			; add -1 high byte
.c699	85 7b		sta $7b			STA	CHRGOT+2		; save BASIC execute pointer high byte
.c69b	60		rts			RTS
.c69c					LIST
.c69c	90 06		bcc $c6a4		BCC	LAB_C6A4		; branch if next character not token (LIST n...)
.c69e	f0 04		beq $c6a4		BEQ	LAB_C6A4		; branch if next character [NULL] (LIST)
.c6a0	c9 ab		cmp #$ab		CMP	#TK_MINUS		; compare with token for "-"
.c6a2	d0 e9		bne $c68d		BNE	LAB_C68D		; exit if not - (LIST -m)
.c6a4					LAB_C6A4
.c6a4	20 6b c9	jsr $c96b		JSR	DECBIN			; get fixed-point number into temporary integer
.c6a7	20 13 c6	jsr $c613		JSR	FINLIN			; search BASIC for temporary integer line number
.c6aa	20 79 00	jsr $0079		JSR	CHRGOT			; scan memory
.c6ad	f0 0c		beq $c6bb		BEQ	LAB_C6BB		; branch if no more chrs
.c6af	c9 ab		cmp #$ab		CMP	#TK_MINUS		; compare with token for "-"
.c6b1	d0 8e		bne $c641		BNE	LAB_C641		; return if not "-" (will be SN error)
.c6b3	20 73 00	jsr $0073		JSR	CHRGET			; increment and scan memory
.c6b6	20 6b c9	jsr $c96b		JSR	DECBIN			; get fixed-point number into temporary integer
.c6b9	d0 86		bne $c641		BNE	LAB_C641		; exit if not ok
.c6bb					LAB_C6BB
.c6bb	68		pla			PLA				; dump return address low byte, exit via warm start
.c6bc	68		pla			PLA				; dump return address high byte
.c6bd	a5 14		lda $14			LDA	LINNUM			; get temporary integer low byte
.c6bf	05 15		ora $15			ORA	LINNUM+1		; OR temporary integer high byte
.c6c1	d0 06		bne $c6c9		BNE	LAB_C6C9		; branch if start set
.c6c3	a9 ff		lda #$ff		LDA	#$FF			; set for -1
.c6c5	85 14		sta $14			STA	LINNUM			; set temporary integer low byte
.c6c7	85 15		sta $15			STA	LINNUM+1		; set temporary integer high byte
.c6c9					LAB_C6C9
.c6c9	a0 01		ldy #$01		LDY	#$01			; set index for line
.c6cb	84 0f		sty $0f			STY	GARBFL			; clear open quote flag
.c6cd	b1 5f		lda ($5f),y		LDA	(TMPPTR),Y		; get next line pointer high byte
.c6cf	f0 43		beq $c714		BEQ	LAB_C714		; if null all done so exit
.c6d1	20 2c c8	jsr $c82c		JSR	TSTSTOP			; do STOP check vector
.c6d4	20 d7 ca	jsr $cad7		JSR	LAB_CAD7		; print CR/LF
.c6d7	c8		iny			INY				; increment index for line
.c6d8	b1 5f		lda ($5f),y		LDA	(TMPPTR),Y		; get line number low byte
.c6da	aa		tax			TAX				; copy to .X
.c6db	c8		iny			INY				; increment index
.c6dc	b1 5f		lda ($5f),y		LDA	(TMPPTR),Y		; get line number high byte
.c6de	c5 15		cmp $15			CMP	LINNUM+1		; compare with temporary integer high byte
.c6e0	d0 04		bne $c6e6		BNE	LAB_C6E6		; branch if no high byte match
.c6e2	e4 14		cpx $14			CPX	LINNUM			; compare with temporary integer low byte
.c6e4	f0 02		beq $c6e8		BEQ	LAB_C6E8		; branch if = last line to do, < will pass next branch
.c6e6					LAB_C6E6
.c6e6	b0 2c		bcs $c714		BCS	LAB_C714		; if greater all done so exit
.c6e8					LAB_C6E8
.c6e8	84 49		sty $49			STY	FORPNT			; save index for line
.c6ea	20 cd dd	jsr $ddcd		JSR	PRTFIX			; print .X.A as unsigned integer
.c6ed	a9 20		lda #$20		LDA	#' '			; space is the next character
.c6ef					LAB_C6EF
.c6ef	a4 49		ldy $49			LDY	FORPNT			; get index for line
.c6f1	29 7f		and #$7f		AND	#$7F			; mask top out bit of character
.c6f3					LAB_C6F3
.c6f3	20 47 cb	jsr $cb47		JSR	LAB_CB47		; go print the character
.c6f6	c9 22		cmp #$22		CMP	#$22			; was it " character
.c6f8	d0 06		bne $c700		BNE	LAB_C700		; if not skip the quote handle
.c6fa	a5 0f		lda $0f			LDA	GARBFL			; get open quote flag
.c6fc	49 ff		eor #$ff		EOR	#$FF			; toggle it
.c6fe	85 0f		sta $0f			STA	GARBFL			; save it back
.c700					LAB_C700
.c700	c8		iny			INY				; increment index
.c701	f0 11		beq $c714		BEQ	LAB_C714		; line too long so just bail out and do a warm start
.c703	b1 5f		lda ($5f),y		LDA	(TMPPTR),Y		; get next byte
.c705	d0 10		bne $c717		BNE	LAB_C717		; if not [EOL] (go print character)
.c707	a8		tay			TAY				; else clear index
.c708	b1 5f		lda ($5f),y		LDA	(TMPPTR),Y		; get next line pointer low byte
.c70a	aa		tax			TAX				; copy to .X
.c70b	c8		iny			INY				; increment index
.c70c	b1 5f		lda ($5f),y		LDA	(TMPPTR),Y		; get next line pointer high byte
.c70e	86 5f		stx $5f			STX	TMPPTR			; set pointer to line low byte
.c710	85 60		sta $60			STA	TMPPTR+1		; set pointer to line high byte
.c712	d0 b5		bne $c6c9		BNE	LAB_C6C9		; go do next line if not [EOT]
.c714					LAB_C714
.c714	4c 74 c4	jmp $c474		JMP	READY			; do warm start
.c717					LAB_C717
.c717	6c 06 03	jmp ($0306)		JMP	(IQPLOP)		; do uncrunch BASIC tokens
.c71a					QPLOP
.c71a	10 d7		bpl $c6f3		BPL	LAB_C6F3		; just go print it if not token byte
.c71c	c9 ff		cmp #$ff		CMP	#TK_PI			; compare with the token for PI. in this case the token
.c71e	f0 d3		beq $c6f3		BEQ	LAB_C6F3		; just print it if so
.c720	24 0f		bit $0f			BIT	GARBFL			; test the open quote flag
.c722	30 cf		bmi $c6f3		BMI	LAB_C6F3		; just go print character if open quote set
.c724	38		sec			SEC				; else set carry for subtract
.c725	e9 7f		sbc #$7f		SBC	#$7F			; reduce token range to 1 to whatever
.c727	aa		tax			TAX				; copy token # to .X
.c728	84 49		sty $49			STY	FORPNT			; save index for line
.c72a	a0 ff		ldy #$ff		LDY	#$FF			; start from -1, adjust for pre increment
.c72c					LAB_C72C
.c72c	ca		dex			DEX				; decrement token #
.c72d	f0 08		beq $c737		BEQ	LAB_C737		; if now found go do printing
.c72f					LAB_C72F
.c72f	c8		iny			INY				; else increment index
.c730	b9 9e c0	lda $c09e,y		LDA	RESLST,Y		; get byte from keyword table
.c733	10 fa		bpl $c72f		BPL	LAB_C72F		; loop until keyword end marker
.c735	30 f5		bmi $c72c		BMI	LAB_C72C		; go test if this is required keyword, branch always
.c737					LAB_C737
.c737	c8		iny			INY				; increment keyword table index
.c738	b9 9e c0	lda $c09e,y		LDA	RESLST,Y		; get byte from table
.c73b	30 b2		bmi $c6ef		BMI	LAB_C6EF		; go restore index, mask byte and print if
.c73d	20 47 cb	jsr $cb47		JSR	LAB_CB47		; else go print the character
.c740	d0 f5		bne $c737		BNE	LAB_C737		; go get next character, branch always
.c742					FOR
.c742	a9 80		lda #$80		LDA	#$80			; set FNx
.c744	85 10		sta $10			STA	SUBFLG			; set subscript/FNx flag
.c746	20 a5 c9	jsr $c9a5		JSR	LET			; perform LET
.c749	20 8a c3	jsr $c38a		JSR	SCNSTK			; search the stack for FOR or GOSUB activity
.c74c	d0 05		bne $c753		BNE	LAB_C753		; branch if FOR, this variable, not found
.c74e	8a		txa			TXA				; copy index
.c74f	69 0f		adc #$0f		ADC	#$0F			; add FOR structure size-2
.c751	aa		tax			TAX				; copy to index
.c752	9a		txs			TXS				; set stack (dump FOR structure (-2 bytes))
.c753					LAB_C753
.c753	68		pla			PLA				; pull return address
.c754	68		pla			PLA				; pull return address
.c755	a9 09		lda #$09		LDA	#$09			; we need 18d bytes !
.c757	20 fb c3	jsr $c3fb		JSR	STKSPC			; check room on stack for 2*.A bytes
.c75a	20 06 c9	jsr $c906		JSR	FIND2			; scan for next BASIC statement ([:] or [EOL])
.c75d	18		clc			CLC				; clear carry for add
.c75e	98		tya			TYA				; copy index to .A
.c75f	65 7a		adc $7a			ADC	CHRGOT+1		; add BASIC execute pointer low byte
.c761	48		pha			PHA				; push onto stack
.c762	a5 7b		lda $7b			LDA	CHRGOT+2		; get BASIC execute pointer high byte
.c764	69 00		adc #$00		ADC	#$00			; add carry
.c766	48		pha			PHA				; push onto stack
.c767	a5 3a		lda $3a			LDA	CURLIN+1		; get current line number high byte
.c769	48		pha			PHA				; push onto stack
.c76a	a5 39		lda $39			LDA	CURLIN			; get current line number low byte
.c76c	48		pha			PHA				; push onto stack
.c76d	a9 a4		lda #$a4		LDA	#TK_TO			; set TO token
.c76f	20 ff ce	jsr $ceff		JSR	SYNCHR			; scan for CHR$(.A), else do syntax error then warm start
.c772	20 8d cd	jsr $cd8d		JSR	LAB_CD8D		; check if source is numeric, else do type mismatch
.c775	20 8a cd	jsr $cd8a		JSR	TYPCHK			; evaluate expression and check is numeric, else do
.c778	a5 66		lda $66			LDA	FAC1+FAC_SIGN		; get FAC1 sign (b7)
.c77a	09 7f		ora #$7f		ORA	#$7F			; set all non sign bits
.c77c	25 62		and $62			AND	FAC1+FAC_MANT		; and FAC1 mantissa 1
.c77e	85 62		sta $62			STA	FAC1+FAC_MANT		; save FAC1 mantissa 1
.c780	a9 8b		lda #$8b		LDA	#<LAB_C78B		; set return address low byte
.c782	a0 c7		ldy #$c7		LDY	#>LAB_C78B		; set return address high byte
.c784	85 22		sta $22			STA	INDEX			; save return address low byte
.c786	84 23		sty $23			STY	INDEX+1			; save return address high byte
.c788	4c 43 ce	jmp $ce43		JMP	LAB_CE43		; round FAC1 and put on stack, returns to next instruction
.c78b					LAB_C78B
.c78b	a9 bc		lda #$bc		LDA	#<FPC1			; set 1 pointer low address, default step size
.c78d	a0 d9		ldy #$d9		LDY	#>FPC1			; set 1 pointer high address
.c78f	20 a2 db	jsr $dba2		JSR	LODFAC			; unpack memory (.A.Y) into FAC1
.c792	20 79 00	jsr $0079		JSR	CHRGOT			; scan memory
.c795	c9 a9		cmp #$a9		CMP	#TK_STEP		; compare with STEP token
.c797	d0 06		bne $c79f		BNE	LAB_C79F		; branch if not STEP
.c799	20 73 00	jsr $0073		JSR	CHRGET			; increment and scan memory
.c79c	20 8a cd	jsr $cd8a		JSR	TYPCHK			; evaluate expression and check is numeric, else do
.c79f					LAB_C79F
.c79f	20 2b dc	jsr $dc2b		JSR	SGNFAC			; get FAC1 sign, return .A = $FF -ve, .A = $01 +ve
.c7a2	20 38 ce	jsr $ce38		JSR	LAB_CE38		; push sign, round FAC1 and put on stack
.c7a5	a5 4a		lda $4a			LDA	FORPNT+1		; get FOR/NEXT variable pointer high byte
.c7a7	48		pha			PHA				; push on stack
.c7a8	a5 49		lda $49			LDA	FORPNT			; get FOR/NEXT variable pointer low byte
.c7aa	48		pha			PHA				; push on stack
.c7ab	a9 81		lda #$81		LDA	#TK_FOR			; get FOR token
.c7ad	48		pha			PHA				; push on stack
.c7ae					NEWSTT
.c7ae	20 2c c8	jsr $c82c		JSR	TSTSTOP			; do STOP check vector
.c7b1	a5 7a		lda $7a			LDA	CHRGOT+1		; get BASIC execute pointer low byte
.c7b3	a4 7b		ldy $7b			LDY	CHRGOT+2		; get BASIC execute pointer high byte
.c7b5	c0 02		cpy #$02		CPY	#>BUF			; compare with input buffer high byte
.c7b7	ea		nop			NOP				; unused byte
.c7b8	f0 04		beq $c7be		BEQ	LAB_C7BE		; if immediate mode skip the continue pointer save
.c7ba	85 3d		sta $3d			STA	OLDTXT			; save the continue pointer low byte
.c7bc	84 3e		sty $3e			STY	OLDTXT+1		; save the continue pointer high byte
.c7be					LAB_C7BE
.c7be	a0 00		ldy #$00		LDY	#$00			; clear the index
.c7c0	b1 7a		lda ($7a),y		LDA	(CHRGOT+1),Y		; get BASIC byte
.c7c2	d0 43		bne $c807		BNE	LAB_C807		; if not [EOL] go test for ":"
.c7c4	a0 02		ldy #$02		LDY	#$02			; else set the index
.c7c6	b1 7a		lda ($7a),y		LDA	(CHRGOT+1),Y		; get next line pointer high byte
.c7c8	18		clc			CLC				; clear carry for no "BREAK" message
.c7c9	d0 03		bne $c7ce		BNE	LAB_C7CE		; branch if not end of program
.c7cb	4c 4b c8	jmp $c84b		JMP	LAB_C84B		; else go to immediate mode,was immediate or [EOT] marker
.c7ce					LAB_C7CE
.c7ce	c8		iny			INY				; increment index
.c7cf	b1 7a		lda ($7a),y		LDA	(CHRGOT+1),Y		; get line number low byte
.c7d1	85 39		sta $39			STA	CURLIN			; save current line number low byte
.c7d3	c8		iny			INY				; increment index
.c7d4	b1 7a		lda ($7a),y		LDA	(CHRGOT+1),Y		; get line # high byte
.c7d6	85 3a		sta $3a			STA	CURLIN+1		; save current line number high byte
.c7d8	98		tya			TYA				; .A now = 4
.c7d9	65 7a		adc $7a			ADC	CHRGOT+1		; add BASIC execute pointer low byte, now points to code
.c7db	85 7a		sta $7a			STA	CHRGOT+1		; save BASIC execute pointer low byte
.c7dd	90 02		bcc $c7e1		BCC	LAB_C7E1		; if no overflow skip the high byte increment
.c7df	e6 7b		inc $7b			INC	CHRGOT+2		; else increment BASIC execute pointer high byte
.c7e1					LAB_C7E1
.c7e1	6c 08 03	jmp ($0308)		JMP	(IGONE)			; do start new BASIC code
.c7e4					GONE
.c7e4	20 73 00	jsr $0073		JSR	CHRGET			; increment and scan memory
.c7e7	20 ed c7	jsr $c7ed		JSR	LAB_C7ED		; go interpret BASIC code from BASIC execute pointer
.c7ea	4c ae c7	jmp $c7ae		JMP	NEWSTT			; loop
.c7ed					LAB_C7ED
.c7ed	f0 3c		beq $c82b		BEQ	LAB_C82B		; if the first byte is null just exit
.c7ef					LAB_C7EF
.c7ef	e9 80		sbc #$80		SBC	#$80			; normalise the token
.c7f1	90 11		bcc $c804		BCC	LAB_C804		; if wasn't token go do LET
.c7f3	c9 23		cmp #$23		CMP	#TK_TAB-$80		; compare with token for TAB(-$80
.c7f5	b0 17		bcs $c80e		BCS	LAB_C80E		; branch if >= TAB(
.c7f7	0a		asl a			ASL				; *2 bytes per vector
.c7f8	a8		tay			TAY				; copy to index
.c7f9	b9 0d c0	lda $c00d,y		LDA	STMDSP+1,Y		; get vector high byte
.c7fc	48		pha			PHA				; push on stack
.c7fd	b9 0c c0	lda $c00c,y		LDA	STMDSP,Y		; get vector low byte
.c800	48		pha			PHA				; push on stack
.c801	4c 73 00	jmp $0073		JMP	CHRGET			; increment and scan memory and return. the return in
.c804					LAB_C804
.c804	4c a5 c9	jmp $c9a5		JMP	LET			; perform LET
.c807					LAB_C807
.c807	c9 3a		cmp #$3a		CMP	#':'			; compare with ":"
.c809	f0 d6		beq $c7e1		BEQ	LAB_C7E1		; if ":" go execute new code
.c80b					LAB_C80B
.c80b	4c 08 cf	jmp $cf08		JMP	LAB_CF08		; do syntax error then warm start
.c80e					LAB_C80E
.c80e	c9 4b		cmp #$4b		CMP	#TK_GO-$80		; compare with token for GO
.c810	d0 f9		bne $c80b		BNE	LAB_C80B		; if not GO do syntax error then warm start
.c812	20 73 00	jsr $0073		JSR	CHRGET			; increment and scan memory
.c815	a9 a4		lda #$a4		LDA	#TK_TO			; set TO token
.c817	20 ff ce	jsr $ceff		JSR	SYNCHR			; scan for CHR$(.A), else do syntax error then warm start
.c81a	4c a0 c8	jmp $c8a0		JMP	GOTO			; perform GOTO
.c81d					RESTORE
.c81d	38		sec			SEC				; set carry for subtract
.c81e	a5 2b		lda $2b			LDA	TXTTAB			; get start of memory low byte
.c820	e9 01		sbc #$01		SBC	#$01			; -1
.c822	a4 2c		ldy $2c			LDY	TXTTAB+1		; get start of memory high byte
.c824	b0 01		bcs $c827		BCS	LAB_C827		; if no rollunder skip the high byte decrement
.c826	88		dey			DEY				; else decrement high byte
.c827					LAB_C827
.c827	85 41		sta $41			STA	DATPTR			; set DATA pointer low byte
.c829	84 42		sty $42			STY	DATPTR+1		; set DATA pointer high byte
.c82b					LAB_C82B
.c82b	60		rts			RTS
.c82c					TSTSTOP
.c82c	20 e1 ff	jsr $ffe1		JSR	STOP			; scan [STOP] key
.c82f					BSTOP
.c82f	b0 01		bcs $c832		BCS	LAB_C832		; if carry set do BREAK instead of just END
.c831					END
.c831	18		clc			CLC				; clear carry
.c832					LAB_C832
.c832	d0 3c		bne $c870		BNE	LAB_C870		; return if wasn't STOP
.c834	a5 7a		lda $7a			LDA	CHRGOT+1		; get BASIC execute pointer low byte
.c836	a4 7b		ldy $7b			LDY	CHRGOT+2		; get BASIC execute pointer high byte
.c838	a6 3a		ldx $3a			LDX	CURLIN+1		; get current line number high byte
.c83a	e8		inx			INX				; increment it
.c83b	f0 0c		beq $c849		BEQ	LAB_C849		; branch if was immediate mode
.c83d	85 3d		sta $3d			STA	OLDTXT			; save continue pointer low byte
.c83f	84 3e		sty $3e			STY	OLDTXT+1		; save continue pointer high byte
.c841	a5 39		lda $39			LDA	CURLIN			; get current line number low byte
.c843	a4 3a		ldy $3a			LDY	CURLIN+1		; get current line number high byte
.c845	85 3b		sta $3b			STA	OLDLIN			; save break line number low byte
.c847	84 3c		sty $3c			STY	OLDLIN+1		; save break line number high byte
.c849					LAB_C849
.c849	68		pla			PLA				; dump return address low byte
.c84a	68		pla			PLA				; dump return address high byte
.c84b					LAB_C84B
.c84b	a9 81		lda #$81		LDA	#<CRLFBRK		; set [CR][LF]"BREAK" pointer low byte
.c84d	a0 c3		ldy #$c3		LDY	#>CRLFBRK		; set [CR][LF]"BREAK" pointer high byte
.c84f	90 03		bcc $c854		BCC	LAB_C854		; branch if was program end
.c851	4c 69 c4	jmp $c469		JMP	PRDY			; print string and do warm start
.c854					LAB_C854
.c854	4c 74 c4	jmp $c474		JMP	READY			; do warm start
.c857					CONT
.c857	d0 17		bne $c870		BNE	LAB_C870		; exit if following byte to allow syntax error
.c859	a2 1a		ldx #$1a		LDX	#ER_CANTCONT		; error code $1A, can't continue error
.c85b	a4 3e		ldy $3e			LDY	OLDTXT+1		; get continue pointer high byte
.c85d	d0 03		bne $c862		BNE	LAB_C862		; go do continue if we can
.c85f	4c 37 c4	jmp $c437		JMP	ERROR			; else do error #.X then warm start
.c862					LAB_C862
.c862	a5 3d		lda $3d			LDA	OLDTXT			; get continue pointer low byte
.c864	85 7a		sta $7a			STA	CHRGOT+1		; save BASIC execute pointer low byte
.c866	84 7b		sty $7b			STY	CHRGOT+2		; save BASIC execute pointer high byte
.c868	a5 3b		lda $3b			LDA	OLDLIN			; get break line low byte
.c86a	a4 3c		ldy $3c			LDY	OLDLIN+1		; get break line high byte
.c86c	85 39		sta $39			STA	CURLIN			; set current line number low byte
.c86e	84 3a		sty $3a			STY	CURLIN+1		; set current line number high byte
.c870					LAB_C870
.c870	60		rts			RTS
.c871					RUN
.c871	08		php			PHP				; save status
.c872	a9 00		lda #$00		LDA	#$00			; no control or KERNAL messages
.c874	20 90 ff	jsr $ff90		JSR	SETMSG			; control KERNAL messages
.c877	28		plp			PLP				; restore status
.c878	d0 03		bne $c87d		BNE	LAB_C87D		; branch if RUN n
.c87a	4c 59 c6	jmp $c659		JMP	LAB_C659		; reset execution to start, clear variables, flush stack
.c87d					LAB_C87D
.c87d	20 60 c6	jsr $c660		JSR	LAB_C660		; go do CLR
.c880	4c 97 c8	jmp $c897		JMP	LAB_C897		; get n and do GOTO n
.c883					GOSUB
.c883	a9 03		lda #$03		LDA	#$03			; need 6 bytes for GOSUB
.c885	20 fb c3	jsr $c3fb		JSR	STKSPC			; check room on stack for 2*.A bytes
.c888	a5 7b		lda $7b			LDA	CHRGOT+2		; get BASIC execute pointer high byte
.c88a	48		pha			PHA				; save it
.c88b	a5 7a		lda $7a			LDA	CHRGOT+1		; get BASIC execute pointer low byte
.c88d	48		pha			PHA				; save it
.c88e	a5 3a		lda $3a			LDA	CURLIN+1		; get current line number high byte
.c890	48		pha			PHA				; save it
.c891	a5 39		lda $39			LDA	CURLIN			; get current line number low byte
.c893	48		pha			PHA				; save it
.c894	a9 8d		lda #$8d		LDA	#TK_GOSUB		; token for GOSUB
.c896	48		pha			PHA				; save it
.c897					LAB_C897
.c897	20 79 00	jsr $0079		JSR	CHRGOT			; scan memory
.c89a	20 a0 c8	jsr $c8a0		JSR	GOTO			; perform GOTO
.c89d	4c ae c7	jmp $c7ae		JMP	NEWSTT			; go do interpreter inner loop
.c8a0					GOTO
.c8a0	20 6b c9	jsr $c96b		JSR	DECBIN			; get fixed-point number into temporary integer
.c8a3	20 09 c9	jsr $c909		JSR	LAB_C909		; scan for next BASIC line
.c8a6	38		sec			SEC				; set carry for subtract
.c8a7	a5 39		lda $39			LDA	CURLIN			; get current line number low byte
.c8a9	e5 14		sbc $14			SBC	LINNUM			; subtract temporary integer low byte
.c8ab	a5 3a		lda $3a			LDA	CURLIN+1		; get current line number high byte
.c8ad	e5 15		sbc $15			SBC	LINNUM+1		; subtract temporary integer high byte
.c8af	b0 0b		bcs $c8bc		BCS	LAB_C8BC		; if current line number >= temporary integer, go search
.c8b1	98		tya			TYA				; else copy line index to .A
.c8b2	38		sec			SEC				; set carry (+1)
.c8b3	65 7a		adc $7a			ADC	CHRGOT+1		; add BASIC execute pointer low byte
.c8b5	a6 7b		ldx $7b			LDX	CHRGOT+2		; get BASIC execute pointer high byte
.c8b7	90 07		bcc $c8c0		BCC	LAB_C8C0		; if no overflow skip the high byte increment
.c8b9	e8		inx			INX				; increment high byte
.c8ba	b0 04		bcs $c8c0		BCS	LAB_C8C0		; go find the line, branch always
.c8bc					LAB_C8BC
.c8bc	a5 2b		lda $2b			LDA	TXTTAB			; get start of memory low byte
.c8be	a6 2c		ldx $2c			LDX	TXTTAB+1		; get start of memory high byte
.c8c0					LAB_C8C0
.c8c0	20 17 c6	jsr $c617		JSR	LAB_C617		; search BASIC for temp integer line number from .A.X
.c8c3	90 1e		bcc $c8e3		BCC	LAB_C8E3		; if carry clear go do undefined statement error
.c8c5	a5 5f		lda $5f			LDA	TMPPTR			; get pointer low byte
.c8c7	e9 01		sbc #$01		SBC	#$01			; -1
.c8c9	85 7a		sta $7a			STA	CHRGOT+1		; save BASIC execute pointer low byte
.c8cb	a5 60		lda $60			LDA	TMPPTR+1		; get pointer high byte
.c8cd	e9 00		sbc #$00		SBC	#$00			; subtract carry
.c8cf	85 7b		sta $7b			STA	CHRGOT+2		; save BASIC execute pointer high byte
.c8d1					LAB_C8D1
.c8d1	60		rts			RTS
.c8d2					RETURN
.c8d2	d0 fd		bne $c8d1		BNE	LAB_C8D1		; exit if following token to allow syntax error
.c8d4	a9 ff		lda #$ff		LDA	#$FF			; set byte so no match possible
.c8d6	85 4a		sta $4a			STA	FORPNT+1		; save FOR/NEXT variable pointer high byte
.c8d8	20 8a c3	jsr $c38a		JSR	SCNSTK			; search the stack for FOR or GOSUB activity,
.c8db	9a		txs			TXS				; correct the stack
.c8dc	c9 8d		cmp #$8d		CMP	#TK_GOSUB		; compare with GOSUB token
.c8de	f0 0b		beq $c8eb		BEQ	LAB_C8EB		; if matching GOSUB go continue RETURN
.c8e0	a2 0c		ldx #$0c		LDX	#ER_RETWOGSB		; else error code $0C, return without gosub error
>c8e2	2c					.byte	$2C			; makes next line BIT $11A2
.c8e3					LAB_C8E3
.c8e3	a2 11		ldx #$11		LDX	#ER_UNDSMNT		; error code $11, undefined statement error
.c8e5	4c 37 c4	jmp $c437		JMP	ERROR			; do error #.X then warm start
.c8e8					LAB_C8E8
.c8e8	4c 08 cf	jmp $cf08		JMP	LAB_CF08		; do syntax error then warm start
.c8eb					LAB_C8EB
.c8eb	68		pla			PLA				; dump token byte
.c8ec	68		pla			PLA				; pull return line low byte
.c8ed	85 39		sta $39			STA	CURLIN			; save current line number low byte
.c8ef	68		pla			PLA				; pull return line high byte
.c8f0	85 3a		sta $3a			STA	CURLIN+1		; save current line number high byte
.c8f2	68		pla			PLA				; pull return address low byte
.c8f3	85 7a		sta $7a			STA	CHRGOT+1		; save BASIC execute pointer low byte
.c8f5	68		pla			PLA				; pull return address high byte
.c8f6	85 7b		sta $7b			STA	CHRGOT+2		; save BASIC execute pointer high byte
.c8f8					SKIPST
.c8f8	20 06 c9	jsr $c906		JSR	FIND2			; scan for next BASIC statement ([:] or [EOL])
.c8fb					BUMPTP
.c8fb	98		tya			TYA				; copy index to .A
.c8fc	18		clc			CLC				; clear carry for add
.c8fd	65 7a		adc $7a			ADC	CHRGOT+1		; add BASIC execute pointer low byte
.c8ff	85 7a		sta $7a			STA	CHRGOT+1		; save BASIC execute pointer low byte
.c901	90 02		bcc $c905		BCC	LAB_C905		; skip increment if no carry
.c903	e6 7b		inc $7b			INC	CHRGOT+2		; else increment BASIC execute pointer high byte
.c905					LAB_C905
.c905	60		rts			RTS
.c906					FIND2
.c906	a2 3a		ldx #$3a		LDX	#':'			; set look for character = ":"
>c908	2c					.byte	$2C			; makes next line BIT $00A2
.c909					LAB_C909
.c909	a2 00		ldx #$00		LDX	#$00			; set alternate search character = [EOL]
.c90b	86 07		stx $07			STX	CHARAC			; store alternate search character
.c90d	a0 00		ldy #$00		LDY	#$00			; set search character = [EOL]
.c90f	84 08		sty $08			STY	ENDCHR			; save the search character
.c911					LAB_C911
.c911	a5 08		lda $08			LDA	ENDCHR			; get search character
.c913	a6 07		ldx $07			LDX	CHARAC			; get alternate search character
.c915	85 07		sta $07			STA	CHARAC			; make search character = alternate search character
.c917	86 08		stx $08			STX	ENDCHR			; make alternate search character = search character
.c919					LAB_C919
.c919	b1 7a		lda ($7a),y		LDA	(CHRGOT+1),Y		; get BASIC byte
.c91b	f0 e8		beq $c905		BEQ	LAB_C905		; exit if null [EOL]
.c91d	c5 08		cmp $08			CMP	ENDCHR			; compare with search character
.c91f	f0 e4		beq $c905		BEQ	LAB_C905		; exit if found
.c921	c8		iny			INY				; else increment index
.c922	c9 22		cmp #$22		CMP	#$22			; compare current character with open quote
.c924	d0 f3		bne $c919		BNE	LAB_C919		; if found go swap search character for alternate search
.c926	f0 e9		beq $c911		BEQ	LAB_C911		; loop for next character, branch always
.c928					IF
.c928	20 9e cd	jsr $cd9e		JSR	FRMEVL			; evaluate expression
.c92b	20 79 00	jsr $0079		JSR	CHRGOT			; scan memory
.c92e	c9 89		cmp #$89		CMP	#TK_GOTO		; compare with GOTO token
.c930	f0 05		beq $c937		BEQ	LAB_C937		; if it was the token for GOTO go do IF ... GOTO
.c932	a9 a7		lda #$a7		LDA	#TK_THEN		; $A7 = "THEN" token
.c934	20 ff ce	jsr $ceff		JSR	SYNCHR			; scan for CHR$(.A), else do syntax error then warm start
.c937					LAB_C937
.c937	a5 61		lda $61			LDA	FAC1+FAC_EXPT		; get FAC1 exponent
.c939	d0 05		bne $c940		BNE	LAB_C940		; if result was non zero continue execution
.c93b					REM
.c93b	20 09 c9	jsr $c909		JSR	LAB_C909		; scan for next BASIC line
.c93e	f0 bb		beq $c8fb		BEQ	BUMPTP			; add .Y to the BASIC execute pointer and return, branch
.c940					LAB_C940
.c940	20 79 00	jsr $0079		JSR	CHRGOT			; scan memory
.c943	b0 03		bcs $c948		BCS	LAB_C948		; if not numeric character, is variable or keyword
.c945	4c a0 c8	jmp $c8a0		JMP	GOTO			; else perform GOTO n
.c948					LAB_C948
.c948	4c ed c7	jmp $c7ed		JMP	LAB_C7ED		; interpret BASIC code from BASIC execute pointer
.c94b					ON
.c94b	20 9e d7	jsr $d79e		JSR	LAB_D79E		; get byte parameter
.c94e	48		pha			PHA				; push next character
.c94f	c9 8d		cmp #$8d		CMP	#TK_GOSUB		; compare with GOSUB token
.c951	f0 04		beq $c957		BEQ	LAB_C957		; if GOSUB go see if it should be executed
.c953					LAB_C953
.c953	c9 89		cmp #$89		CMP	#TK_GOTO		; compare with GOTO token
.c955	d0 91		bne $c8e8		BNE	LAB_C8E8		; if not GOTO do syntax error then warm start
.c957					LAB_C957
.c957	c6 65		dec $65			DEC	FAC1+4			; decrement the byte value
.c959	d0 04		bne $c95f		BNE	LAB_C95F		; if not zero go see if another line number exists
.c95b	68		pla			PLA				; pull keyword token
.c95c	4c ef c7	jmp $c7ef		JMP	LAB_C7EF		; go execute it
.c95f					LAB_C95F
.c95f	20 73 00	jsr $0073		JSR	CHRGET			; increment and scan memory
.c962	20 6b c9	jsr $c96b		JSR	DECBIN			; get fixed-point number into temporary integer
.c965	c9 2c		cmp #$2c		CMP	#','			; compare next character with ","
.c967	f0 ee		beq $c957		BEQ	LAB_C957		; loop if ","
.c969	68		pla			PLA				; else pull keyword token, ran out of options
.c96a					LAB_C96A
.c96a	60		rts			RTS
.c96b					DECBIN
.c96b	a2 00		ldx #$00		LDX	#$00			; clear .X
.c96d	86 14		stx $14			STX	LINNUM			; clear temporary integer low byte
.c96f	86 15		stx $15			STX	LINNUM+1		; clear temporary integer high byte
.c971					LAB_C971
.c971	b0 f7		bcs $c96a		BCS	LAB_C96A		; return if carry set, end of scan, character was not 0-9
.c973	e9 2f		sbc #$2f		SBC	#'0'-1			; subtract $30, $2F+carry, from byte
.c975	85 07		sta $07			STA	CHARAC			; store #
.c977	a5 15		lda $15			LDA	LINNUM+1		; get temporary integer high byte
.c979	85 22		sta $22			STA	INDEX			; save it for now
.c97b	c9 19		cmp #$19		CMP	#$19			; compare with $19
.c97d	b0 d4		bcs $c953		BCS	LAB_C953		; branch if >= this makes the maximum line number 63999
.c97f	a5 14		lda $14			LDA	LINNUM			; get temporary integer low byte
.c981	0a		asl a			ASL				; *2 low byte
.c982	26 22		rol $22			ROL	INDEX			; *2 high byte
.c984	0a		asl a			ASL				; *2 low byte
.c985	26 22		rol $22			ROL	INDEX			; *2 high byte (*4)
.c987	65 14		adc $14			ADC	LINNUM			; + low byte (*5)
.c989	85 14		sta $14			STA	LINNUM			; save it
.c98b	a5 22		lda $22			LDA	INDEX			; get high byte temp
.c98d	65 15		adc $15			ADC	LINNUM+1		; + high byte (*5)
.c98f	85 15		sta $15			STA	LINNUM+1		; save it
.c991	06 14		asl $14			ASL	LINNUM			; *2 low byte (*10d)
.c993	26 15		rol $15			ROL	LINNUM+1		; *2 high byte (*10d)
.c995	a5 14		lda $14			LDA	LINNUM			; get low byte
.c997	65 07		adc $07			ADC	CHARAC			; add #
.c999	85 14		sta $14			STA	LINNUM			; save low byte
.c99b	90 02		bcc $c99f		BCC	LAB_C99F		; if no overflow skip high byte increment
.c99d	e6 15		inc $15			INC	LINNUM+1		; else increment high byte
.c99f					LAB_C99F
.c99f	20 73 00	jsr $0073		JSR	CHRGET			; increment and scan memory
.c9a2	4c 71 c9	jmp $c971		JMP	LAB_C971		; loop for next character
.c9a5					LET
.c9a5	20 8b d0	jsr $d08b		JSR	EVLVAR			; get variable address
.c9a8	85 49		sta $49			STA	FORPNT			; save variable address low byte
.c9aa	84 4a		sty $4a			STY	FORPNT+1		; save variable address high byte
.c9ac	a9 b2		lda #$b2		LDA	#TK_EQUAL		; $B2 is "=" token
.c9ae	20 ff ce	jsr $ceff		JSR	SYNCHR			; scan for CHR$(.A), else do syntax error then warm start
.c9b1	a5 0e		lda $0e			LDA	INTFLG			; get data type flag, $80 = integer, $00 = float
.c9b3	48		pha			PHA				; push data type flag
.c9b4	a5 0d		lda $0d			LDA	VALTYP			; get data type flag, $FF = string, $00 = numeric
.c9b6	48		pha			PHA				; push data type flag
.c9b7	20 9e cd	jsr $cd9e		JSR	FRMEVL			; evaluate expression
.c9ba	68		pla			PLA				; pop data type flag
.c9bb	2a		rol a			ROL				; string bit into carry
.c9bc	20 90 cd	jsr $cd90		JSR	LAB_CD90		; do type match check
.c9bf	d0 18		bne $c9d9		BNE	LAB_C9D9		; if string go assign a string value
.c9c1	68		pla			PLA				; pop integer/float data type flag
.c9c2					LET2
.c9c2	10 12		bpl $c9d6		BPL	LAB_C9D6		; if float go assign a floating value
.c9c4	20 1b dc	jsr $dc1b		JSR	ROUND			; round FAC1
.c9c7	20 bf d1	jsr $d1bf		JSR	MAKINT			; evaluate integer expression, no sign check
.c9ca	a0 00		ldy #$00		LDY	#$00			; clear index
.c9cc	a5 64		lda $64			LDA	FAC1+FAC_MANT+2		; get FAC1 mantissa 3
.c9ce	91 49		sta ($49),y		STA	(FORPNT),Y		; save as integer variable low byte
.c9d0	c8		iny			INY				; increment index
.c9d1	a5 65		lda $65			LDA	FAC1+FAC_MANT+3		; get FAC1 mantissa 4
.c9d3	91 49		sta ($49),y		STA	(FORPNT),Y		; save as integer variable high byte
.c9d5	60		rts			RTS
.c9d6					LAB_C9D6
.c9d6	4c d0 db	jmp $dbd0		JMP	FACTFP			; pack FAC1 into variable pointer and return
.c9d9					LAB_C9D9
.c9d9	68		pla			PLA				; dump integer/float data type flag
.c9da					LET5
.c9da	a4 4a		ldy $4a			LDY	FORPNT+1		; get variable pointer high byte
.c9dc	c0 df		cpy #$df		CPY	#>NULLVAR		; was it TI$ pointer
.c9de	d0 4c		bne $ca2c		BNE	LET9			; branch if not
.c9e0	20 a6 d6	jsr $d6a6		JSR	LAB_D6A6		; pop string off descriptor stack, or from top of string
.c9e3	c9 06		cmp #$06		CMP	#$06			; compare length with 6
.c9e5	d0 3d		bne $ca24		BNE	LAB_CA24		; if length not 6 do illegal quantity error then warm start
.c9e7	a0 00		ldy #$00		LDY	#$00			; clear index
.c9e9	84 61		sty $61			STY	FAC1+FAC_EXPT		; clear FAC1 exponent
.c9eb	84 66		sty $66			STY	FAC1+FAC_SIGN		; clear FAC1 sign (b7)
.c9ed					LAB_C9ED
.c9ed	84 71		sty $71			STY	FBUFPT			; save index
.c9ef	20 1d ca	jsr $ca1d		JSR	LAB_CA1D		; check and evaluate numeric digit
.c9f2	20 e2 da	jsr $dae2		JSR	MULTEN			; multiply FAC1 by 10
.c9f5	e6 71		inc $71			INC	FBUFPT			; increment index
.c9f7	a4 71		ldy $71			LDY	FBUFPT			; restore index
.c9f9	20 1d ca	jsr $ca1d		JSR	LAB_CA1D		; check and evaluate numeric digit
.c9fc	20 0c dc	jsr $dc0c		JSR	RFTOA			; round and copy FAC1 to FAC2
.c9ff	aa		tax			TAX				; copy FAC1 exponent
.ca00	f0 05		beq $ca07		BEQ	LAB_CA07		; branch if FAC1 zero
.ca02	e8		inx			INX				; increment index, * 2
.ca03	8a		txa			TXA				; copy back to .A
.ca04	20 ed da	jsr $daed		JSR	LAB_DAED		; FAC1 = (FAC1 + (FAC2 * 2)) * 2 = FAC1 * 6
.ca07					LAB_CA07
.ca07	a4 71		ldy $71			LDY	FBUFPT			; get index
.ca09	c8		iny			INY				; increment index
.ca0a	c0 06		cpy #$06		CPY	#$06			; compare index with 6
.ca0c	d0 df		bne $c9ed		BNE	LAB_C9ED		; loop if not 6
.ca0e	20 e2 da	jsr $dae2		JSR	MULTEN			; multiply FAC1 by 10
.ca11	20 9b dc	jsr $dc9b		JSR	FPINT			; convert FAC1 floating to fixed
.ca14	a6 64		ldx $64			LDX	FAC1+FAC_MANT+2		; get FAC1 mantissa 3
.ca16	a4 63		ldy $63			LDY	FAC1+FAC_MANT+1		; get FAC1 mantissa 2
.ca18	a5 65		lda $65			LDA	FAC1+FAC_MANT+3		; get FAC1 mantissa 4
.ca1a	4c db ff	jmp $ffdb		JMP	SETTIM			; set real time clock and return
.ca1d					LAB_CA1D
.ca1d	b1 22		lda ($22),y		LDA	(INDEX),Y		; get byte from string
.ca1f	20 80 00	jsr $0080		JSR	CHRSPC			; clear Cb if numeric. this call should be to CHRSPC+4
.ca22	90 03		bcc $ca27		BCC	LAB_CA27		; branch if numeric
.ca24					LAB_CA24
.ca24	4c 48 d2	jmp $d248		JMP	ILQUAN			; do illegal quantity error then warm start
.ca27					LAB_CA27
.ca27	e9 2f		sbc #$2f		SBC	#'0'-1			; subtract $2F + carry to convert ASCII to binary
.ca29	4c 7e dd	jmp $dd7e		JMP	ASCI8			; evaluate new ASCII digit and return
.ca2c					LET9
.ca2c	a0 02		ldy #$02		LDY	#$02			; index to string pointer high byte
.ca2e	b1 64		lda ($64),y		LDA	(FAC1+3),Y		; get string pointer high byte
.ca30	c5 34		cmp $34			CMP	FRETOP+1		; compare with bottom of string space high byte
.ca32	90 17		bcc $ca4b		BCC	LAB_CA4B		; branch if string pointer high byte is less than bottom
.ca34	d0 07		bne $ca3d		BNE	LAB_CA3D		; branch if string pointer high byte is greater than
.ca36	88		dey			DEY				; decrement index to string pointer low byte
.ca37	b1 64		lda ($64),y		LDA	(FAC1+3),Y		; get string pointer low byte
.ca39	c5 33		cmp $33			CMP	FRETOP			; compare with bottom of string space low byte
.ca3b	90 0e		bcc $ca4b		BCC	LAB_CA4B		; branch if string pointer low byte is less than bottom
.ca3d					LAB_CA3D
.ca3d	a4 65		ldy $65			LDY	FAC1+4			; get descriptor pointer high byte
.ca3f	c4 2e		cpy $2e			CPY	VARTAB+1		; compare with start of variables high byte
.ca41	90 08		bcc $ca4b		BCC	LAB_CA4B		; branch if less, is on string stack
.ca43	d0 0d		bne $ca52		BNE	LAB_CA52		; if greater make space and copy string
.ca45	a5 64		lda $64			LDA	FAC1+3			; get descriptor pointer low byte
.ca47	c5 2d		cmp $2d			CMP	VARTAB			; compare with start of variables low byte
.ca49	b0 07		bcs $ca52		BCS	LAB_CA52		; if greater or equal make space and copy string
.ca4b					LAB_CA4B
.ca4b	a5 64		lda $64			LDA	FAC1+3			; get descriptor pointer low byte
.ca4d	a4 65		ldy $65			LDY	FAC1+4			; get descriptor pointer high byte
.ca4f	4c 68 ca	jmp $ca68		JMP	LAB_CA68		; go copy descriptor to variable
.ca52					LAB_CA52
.ca52	a0 00		ldy #$00		LDY	#$00			; clear index
.ca54	b1 64		lda ($64),y		LDA	(FAC1+3),Y		; get string length
.ca56	20 75 d4	jsr $d475		JSR	ALC1			; copy descriptor pointer and make string space .A bytes long
.ca59	a5 50		lda $50			LDA	DSCPTN			; copy old descriptor pointer low byte
.ca5b	a4 51		ldy $51			LDY	DSCPTN+1		; copy old descriptor pointer high byte
.ca5d	85 6f		sta $6f			STA	ARISGN			; save old descriptor pointer low byte
.ca5f	84 70		sty $70			STY	FACOV			; save old descriptor pointer high byte
.ca61	20 7a d6	jsr $d67a		JSR	XFERSTR			; copy string from descriptor to utility pointer
.ca64	a9 61		lda #$61		LDA	#<FAC1			; get descriptor pointer low byte
.ca66	a0 00		ldy #$00		LDY	#>FAC1			; get descriptor pointer high byte
.ca68					LAB_CA68
.ca68	85 50		sta $50			STA	DSCPTN			; save descriptor pointer low byte
.ca6a	84 51		sty $51			STY	DSCPTN+1		; save descriptor pointer high byte
.ca6c	20 db d6	jsr $d6db		JSR	DELTSD			; clean descriptor stack, .Y.A = pointer
.ca6f	a0 00		ldy #$00		LDY	#$00			; clear index
.ca71	b1 50		lda ($50),y		LDA	(DSCPTN),Y		; get string length from new descriptor
.ca73	91 49		sta ($49),y		STA	(FORPNT),Y		; copy string length to variable
.ca75	c8		iny			INY				; increment index
.ca76	b1 50		lda ($50),y		LDA	(DSCPTN),Y		; get string pointer low byte from new descriptor
.ca78	91 49		sta ($49),y		STA    (FORPNT),Y		; copy string pointer low byte to variable
.ca7a	c8		iny			INY				; increment index
.ca7b	b1 50		lda ($50),y		LDA	(DSCPTN),Y		; get string pointer high byte from new descriptor
.ca7d	91 49		sta ($49),y		STA	(FORPNT),Y		; copy string pointer high byte to variable
.ca7f	60		rts			RTS
.ca80					PRINTN
.ca80	20 86 ca	jsr $ca86		JSR	CMD			; perform CMD
.ca83	4c b5 cb	jmp $cbb5		JMP	LAB_CBB5		; close input and output channels and return
.ca86					CMD
.ca86	20 9e d7	jsr $d79e		JSR	LAB_D79E		; get byte parameter
.ca89	f0 05		beq $ca90		BEQ	LAB_CA90		; branch if following byte is ":" or [EOT]
.ca8b	a9 2c		lda #$2c		LDA	#','			; set ","
.ca8d	20 ff ce	jsr $ceff		JSR	SYNCHR			; scan for CHR$(.A), else do syntax error then warm start
.ca90					LAB_CA90
.ca90	08		php			PHP				; save status
.ca91	86 13		stx $13			STX	CHANNL			; set current I/O channel
.ca93	20 15 e1	jsr $e115		JSR	LAB_E115		; open channel for output with error check
.ca96	28		plp			PLP				; restore status
.ca97	4c a0 ca	jmp $caa0		JMP	PRINT			; perform PRINT
.ca9a					PRT1
.ca9a	20 21 cb	jsr $cb21		JSR	LAB_CB21		; print string from utility pointer
.ca9d					LAB_CA9D
.ca9d	20 79 00	jsr $0079		JSR	CHRGOT			; scan memory
.caa0					PRINT
.caa0	f0 35		beq $cad7		BEQ	LAB_CAD7		; if nothing following just print CR/LF
.caa2					LAB_CAA2
.caa2	f0 43		beq $cae7		BEQ	LAB_CAE7		; if nothing following exit, end of PRINT branch
.caa4	c9 a3		cmp #$a3		CMP	#TK_TAB			; compare with token for TAB(
.caa6	f0 50		beq $caf8		BEQ	PRT7			; if TAB( go handle it
.caa8	c9 a6		cmp #$a6		CMP	#TK_SPC			; compare with token for SPC(
.caaa	18		clc			CLC				; flag SPC(
.caab	f0 4b		beq $caf8		BEQ	PRT7			; if SPC( go handle it
.caad	c9 2c		cmp #$2c		CMP	#','			; compare with ","
.caaf	f0 37		beq $cae8		BEQ	PRT6			; if "," go skip to the next TAB position
.cab1	c9 3b		cmp #$3b		CMP	#';'			; compare with ";"
.cab3	f0 5e		beq $cb13		BEQ	LAB_CB13		; if ";" go continue the print loop
.cab5	20 9e cd	jsr $cd9e		JSR	FRMEVL			; evaluate expression
.cab8	24 0d		bit $0d			BIT	VALTYP			; test data type flag, $FF = string, $00 = numeric
.caba	30 de		bmi $ca9a		BMI	PRT1			; if string go print string, scan memory and continue PRINT
.cabc	20 dd dd	jsr $dddd		JSR	FLTASC			; convert FAC1 to ASCII string result in (.A.Y)
.cabf	20 87 d4	jsr $d487		JSR	MAKSTR			; print " terminated string to utility pointer
.cac2	20 21 cb	jsr $cb21		JSR	LAB_CB21		; print string from utility pointer
.cac5	20 3b cb	jsr $cb3b		JSR	PRTOS			; print [SPACE] or [CURSOR RIGHT]
.cac8	d0 d3		bne $ca9d		BNE	LAB_CA9D		; go scan memory and continue PRINT, branch always
.caca					LAB_CACA
.caca	a9 00		lda #$00		LDA	#$00			; clear .A
.cacc	9d 00 02	sta $0200,x		STA	BUF,X			; clear first byte of input buffer
.cacf	a2 ff		ldx #$ff		LDX	#<BUF-1			; BUF - 1 low byte
.cad1	a0 01		ldy #$01		LDY	#>BUF-1			; BUF - 1 high byte
.cad3	a5 13		lda $13			LDA	CHANNL			; get current I/O channel
.cad5	d0 10		bne $cae7		BNE	LAB_CAE7		; exit if not default channel
.cad7					LAB_CAD7
.cad7	a9 0d		lda #$0d		LDA	#$0D			; set [CR]
.cad9	20 47 cb	jsr $cb47		JSR	LAB_CB47		; print the character
.cadc	24 13		bit $13			BIT	CHANNL			; test current I/O channel
.cade	10 05		bpl $cae5		BPL	LAB_CAE5		; if the AutoLF bit is not set skip the [LF]
.cae0	a9 0a		lda #$0a		LDA	#$0A			; set [LF]
.cae2	20 47 cb	jsr $cb47		JSR	LAB_CB47		; print the character
.cae5					LAB_CAE5
.cae5	49 ff		eor #$ff		EOR	#$FF			; ones' complement .A
.cae7					LAB_CAE7
.cae7	60		rts			RTS
.cae8					PRT6
.cae8	38		sec			SEC				; set Cb for read cursor position
.cae9	20 f0 ff	jsr $fff0		JSR	PLOT			; read/set X,Y cursor position
.caec	98		tya			TYA				; copy cursor .Y
.caed	38		sec			SEC				; set carry for subtract
.caee					LAB_CAEE
.caee	e9 0b		sbc #$0b		SBC	#$0B			; subtract one TAB length
.caf0	b0 fc		bcs $caee		BCS	LAB_CAEE		; loop if result was +ve
.caf2	49 ff		eor #$ff		EOR	#$FF			; complement it
.caf4	69 01		adc #$01		ADC	#$01			; +1, two's complement
.caf6	d0 16		bne $cb0e		BNE	LAB_CB0E		; print .A spaces, branch always, result is never $00
.caf8					PRT7
.caf8	08		php			PHP				; save TAB( or SPC( status
.caf9	38		sec			SEC				; set Cb for read cursor position
.cafa	20 f0 ff	jsr $fff0		JSR	PLOT			; read/set X,Y cursor position
.cafd	84 09		sty $09			STY	TRMPOS			; save current cursor position
.caff	20 9b d7	jsr $d79b		JSR	GETBYT			; scan and get byte parameter
.cb02	c9 29		cmp #$29		CMP	#')'			; compare with ")"
.cb04	d0 59		bne $cb5f		BNE	LAB_CB5F		; if not ")" do syntax error
.cb06	28		plp			PLP				; restore TAB( or SPC( status
.cb07	90 06		bcc $cb0f		BCC	LAB_CB0F		; branch if was SPC(
.cb09	8a		txa			TXA				; copy TAB() byte to .A
.cb0a	e5 09		sbc $09			SBC	TRMPOS			; subtract current cursor position
.cb0c	90 05		bcc $cb13		BCC	LAB_CB13		; go loop for next if already past required position
.cb0e					LAB_CB0E
.cb0e	aa		tax			TAX				; copy [SPACE] count to .X
.cb0f					LAB_CB0F
.cb0f	e8		inx			INX				; increment count
.cb10					LAB_CB10
.cb10	ca		dex			DEX				; decrement count
.cb11	d0 06		bne $cb19		BNE	LAB_CB19		; branch if count was not zero
.cb13					LAB_CB13
.cb13	20 73 00	jsr $0073		JSR	CHRGET			; increment and scan memory
.cb16	4c a2 ca	jmp $caa2		JMP	LAB_CAA2		; continue print loop
.cb19					LAB_CB19
.cb19	20 3b cb	jsr $cb3b		JSR	PRTOS			; print [SPACE] or [CURSOR RIGHT]
.cb1c	d0 f2		bne $cb10		BNE	LAB_CB10		; loop, branch always
.cb1e					PRTSTR
.cb1e	20 87 d4	jsr $d487		JSR	MAKSTR			; print " terminated string to utility pointer
.cb21					LAB_CB21
.cb21	20 a6 d6	jsr $d6a6		JSR	LAB_D6A6		; pop string off descriptor stack, or from top of string
.cb24	aa		tax			TAX				; copy length
.cb25	a0 00		ldy #$00		LDY	#$00			; clear index
.cb27	e8		inx			INX				; increment length, for pre decrement loop
.cb28					LAB_CB28
.cb28	ca		dex			DEX				; decrement length
.cb29	f0 bc		beq $cae7		BEQ	LAB_CAE7		; exit if done
.cb2b	b1 22		lda ($22),y		LDA	(INDEX),Y		; get byte from string
.cb2d	20 47 cb	jsr $cb47		JSR	LAB_CB47		; print the character
.cb30	c8		iny			INY				; increment index
.cb31	c9 0d		cmp #$0d		CMP	#$0D			; compare byte with [CR]
.cb33	d0 f3		bne $cb28		BNE	LAB_CB28		; loop if not [CR]
.cb35	20 e5 ca	jsr $cae5		JSR	LAB_CAE5		; toggle .A, EOR #$FF. what is the point of this ??
.cb38	4c 28 cb	jmp $cb28		JMP	LAB_CB28		; loop
.cb3b					PRTOS
.cb3b	a5 13		lda $13			LDA	CHANNL			; get current I/O channel
.cb3d	f0 03		beq $cb42		BEQ	LAB_CB42		; if default channel go output [CURSOR RIGHT]
.cb3f	a9 20		lda #$20		LDA	#' '			; else output [SPACE]
>cb41	2c					.byte	$2C			; makes next line BIT $1DA9
.cb42					LAB_CB42
.cb42	a9 1d		lda #$1d		LDA	#$1D			; set [CURSOR RIGHT]
>cb44	2c					.byte	$2C			; makes next line BIT $3FA9
.cb45					LAB_CB45
.cb45	a9 3f		lda #$3f		LDA	#'?'			; set "?"
.cb47					LAB_CB47
.cb47	20 09 e1	jsr $e109		JSR	LAB_E109		; output character to channel with error check
.cb4a	29 ff		and #$ff		AND	#$FF			; set the flags on .A
.cb4c	60		rts			RTS
.cb4d					IGRERR
.cb4d	a5 11		lda $11			LDA	INPFLG			; get INPUT mode flag, $00 = INPUT, $40 = GET, $98 = READ
.cb4f	f0 11		beq $cb62		BEQ	LAB_CB62		; branch if INPUT
.cb51	30 04		bmi $cb57		BMI	LAB_CB57		; branch if READ
.cb53	a0 ff		ldy #$ff		LDY	#$FF			; set current line high byte to -1, indicate immediate mode
.cb55	d0 04		bne $cb5b		BNE	LAB_CB5B		; branch always
.cb57					LAB_CB57
.cb57	a5 3f		lda $3f			LDA	DATLIN			; get current DATA line number low byte
.cb59	a4 40		ldy $40			LDY	DATLIN+1		; get current DATA line number high byte
.cb5b					LAB_CB5B
.cb5b	85 39		sta $39			STA	CURLIN			; set current line number low byte
.cb5d	84 3a		sty $3a			STY	CURLIN+1		; set current line number high byte
.cb5f					LAB_CB5F
.cb5f	4c 08 cf	jmp $cf08		JMP	LAB_CF08		; do syntax error then warm start
.cb62					LAB_CB62
.cb62	a5 13		lda $13			LDA	CHANNL			; get current I/O channel
.cb64	f0 05		beq $cb6b		BEQ	LAB_CB6B		; if default channel go do "?REDO FROM START" message
.cb66	a2 18		ldx #$18		LDX	#ER_FDATA		; else error $18, file data error
.cb68	4c 37 c4	jmp $c437		JMP	ERROR			; do error #.X then warm start
.cb6b					LAB_CB6B
.cb6b	a9 0c		lda #$0c		LDA	#<LAB_CD0C		; set "?REDO FROM START" pointer low byte
.cb6d	a0 cd		ldy #$cd		LDY	#>LAB_CD0C		; set "?REDO FROM START" pointer high byte
.cb6f	20 1e cb	jsr $cb1e		JSR	PRTSTR			; print null terminated string
.cb72	a5 3d		lda $3d			LDA	OLDTXT			; get continue pointer low byte
.cb74	a4 3e		ldy $3e			LDY	OLDTXT+1		; get continue pointer high byte
.cb76	85 7a		sta $7a			STA	CHRGOT+1		; save BASIC execute pointer low byte
.cb78	84 7b		sty $7b			STY	CHRGOT+2		; save BASIC execute pointer high byte
.cb7a	60		rts			RTS
.cb7b					GET
.cb7b	20 a6 d3	jsr $d3a6		JSR	NODIRM			; check not Direct, back here if ok
.cb7e	c9 23		cmp #$23		CMP	#'#'			; compare with "#"
.cb80	d0 10		bne $cb92		BNE	LAB_CB92		; branch if not GET#
.cb82	20 73 00	jsr $0073		JSR	CHRGET			; increment and scan memory
.cb85	20 9e d7	jsr $d79e		JSR	LAB_D79E		; get byte parameter
.cb88	a9 2c		lda #$2c		LDA	#','			; set ","
.cb8a	20 ff ce	jsr $ceff		JSR	SYNCHR			; scan for CHR$(.A), else do syntax error then warm start
.cb8d	86 13		stx $13			STX	CHANNL			; set current I/O channel
.cb8f	20 1b e1	jsr $e11b		JSR	LAB_E11B		; open channel for input with error check
.cb92					LAB_CB92
.cb92	a2 01		ldx #$01		LDX	#<BUF+1			; set BUF+1 pointer low byte
.cb94	a0 02		ldy #$02		LDY	#>BUF+1			; set BUF+1 pointer high byte
.cb96	a9 00		lda #$00		LDA	#$00			; clear .A
.cb98	8d 01 02	sta $0201		STA	BUF+1			; ensure null terminator
.cb9b	a9 40		lda #$40		LDA	#$40			; input mode = GET
.cb9d	20 0f cc	jsr $cc0f		JSR	LAB_CC0F		; perform GET part of READ
.cba0	a6 13		ldx $13			LDX	CHANNL			; get current I/O channel
.cba2	d0 13		bne $cbb7		BNE	LAB_CBB7		; if not default channel go do channel close and return
.cba4	60		rts			RTS
.cba5					INPUTN
.cba5	20 9e d7	jsr $d79e		JSR	LAB_D79E		; get byte parameter
.cba8	a9 2c		lda #$2c		LDA	#','			; set ","
.cbaa	20 ff ce	jsr $ceff		JSR	SYNCHR			; scan for CHR$(.A), else do syntax error then warm start
.cbad	86 13		stx $13			STX	CHANNL			; set current I/O channel
.cbaf	20 1b e1	jsr $e11b		JSR	LAB_E11B		; open channel for input with error check
.cbb2	20 ce cb	jsr $cbce		JSR	LAB_CBCE		; perform INPUT with no prompt string
.cbb5					LAB_CBB5
.cbb5	a5 13		lda $13			LDA	CHANNL			; get current I/O channel
.cbb7					LAB_CBB7
.cbb7	20 cc ff	jsr $ffcc		JSR	CLRCHN			; close input and output channels
.cbba	a2 00		ldx #$00		LDX	#$00			; clear .X
.cbbc	86 13		stx $13			STX	CHANNL			; clear current I/O channel, flag default
.cbbe	60		rts			RTS
.cbbf					INPUT
.cbbf	c9 22		cmp #$22		CMP	#$22			; compare next byte with open quote
.cbc1	d0 0b		bne $cbce		BNE	LAB_CBCE		; if no prompt string just do INPUT
.cbc3	20 bd ce	jsr $cebd		JSR	LAB_CEBD		; print "..." string
.cbc6	a9 3b		lda #$3b		LDA	#';'			; load .A with ";"
.cbc8	20 ff ce	jsr $ceff		JSR	SYNCHR			; scan for CHR$(.A), else do syntax error then warm start
.cbcb	20 21 cb	jsr $cb21		JSR	LAB_CB21		; print string from utility pointer
.cbce					LAB_CBCE
.cbce	20 a6 d3	jsr $d3a6		JSR	NODIRM			; check not Direct, back here if ok
.cbd1	a9 2c		lda #$2c		LDA	#','			; set ","
.cbd3	8d ff 01	sta $01ff		STA	BUF-1			; save to start of buffer - 1
.cbd6					LAB_CBD6
.cbd6	20 f9 cb	jsr $cbf9		JSR	LAB_CBF9		; print "? " and get BASIC input
.cbd9	a5 13		lda $13			LDA	CHANNL			; get current I/O channel
.cbdb	f0 0d		beq $cbea		BEQ	LAB_CBEA		; branch if default I/O channel
.cbdd	20 b7 ff	jsr $ffb7		JSR	READST			; read I/O status word
.cbe0	29 02		and #$02		AND	#$02			; mask no DSR/timeout
.cbe2	f0 06		beq $cbea		BEQ	LAB_CBEA		; branch if not error
.cbe4	20 b5 cb	jsr $cbb5		JSR	LAB_CBB5		; close input and output channels
.cbe7	4c f8 c8	jmp $c8f8		JMP	SKIPST			; perform DATA
.cbea					LAB_CBEA
.cbea	ad 00 02	lda $0200		LDA	BUF			; get first byte in input buffer
.cbed	d0 1e		bne $cc0d		BNE	LAB_CC0D		; branch if not null
.cbef	a5 13		lda $13			LDA	CHANNL			; get current I/O channel
.cbf1	d0 e3		bne $cbd6		BNE	LAB_CBD6		; if not default channel go get BASIC input
.cbf3	20 06 c9	jsr $c906		JSR	FIND2			; scan for next BASIC statement ([:] or [EOL])
.cbf6	4c fb c8	jmp $c8fb		JMP	BUMPTP			; add .Y to the BASIC execute pointer and return
.cbf9					LAB_CBF9
.cbf9	a5 13		lda $13			LDA	CHANNL			; get current I/O channel
.cbfb	d0 06		bne $cc03		BNE	LAB_CC03		; skip "?" prompt if not default channel
.cbfd	20 45 cb	jsr $cb45		JSR	LAB_CB45		; print "?"
.cc00	20 3b cb	jsr $cb3b		JSR	PRTOS			; print [SPACE] or [CURSOR RIGHT]
.cc03					LAB_CC03
.cc03	4c 60 c5	jmp $c560		JMP	GETLIN			; call for BASIC input and return
.cc06					READ
.cc06	a6 41		ldx $41			LDX	DATPTR			; get DATA pointer low byte
.cc08	a4 42		ldy $42			LDY	DATPTR+1		; get DATA pointer high byte
.cc0a	a9 98		lda #$98		LDA	#$98			; set input mode = READ
>cc0c	2c					.byte	$2C			; makes next line BIT $00A9
.cc0d					LAB_CC0D
.cc0d	a9 00		lda #$00		LDA	#$00			; set input mode = INPUT
.cc0f					LAB_CC0F
.cc0f	85 11		sta $11			STA	INPFLG			; set input mode flag, $00 = INPUT, $40 = GET, $98 = READ
.cc11	86 43		stx $43			STX	INPPTR			; save READ pointer low byte
.cc13	84 44		sty $44			STY	INPPTR+1		; save READ pointer high byte
.cc15					LAB_CC15
.cc15	20 8b d0	jsr $d08b		JSR	EVLVAR			; get variable address
.cc18	85 49		sta $49			STA	FORPNT			; save address low byte
.cc1a	84 4a		sty $4a			STY	FORPNT+1		; save address high byte
.cc1c	a5 7a		lda $7a			LDA	CHRGOT+1		; get BASIC execute pointer low byte
.cc1e	a4 7b		ldy $7b			LDY	CHRGOT+2		; get BASIC execute pointer high byte
.cc20	85 4b		sta $4b			STA	OPPTR			; save BASIC execute pointer low byte
.cc22	84 4c		sty $4c			STY	OPPTR+1			; save BASIC execute pointer high byte
.cc24	a6 43		ldx $43			LDX	INPPTR			; get READ pointer low byte
.cc26	a4 44		ldy $44			LDY	INPPTR+1		; get READ pointer high byte
.cc28	86 7a		stx $7a			STX	CHRGOT+1		; save as BASIC execute pointer low byte
.cc2a	84 7b		sty $7b			STY	CHRGOT+2		; save as BASIC execute pointer high byte
.cc2c	20 79 00	jsr $0079		JSR	CHRGOT			; scan memory
.cc2f	d0 20		bne $cc51		BNE	LAB_CC51		; branch if not null
.cc31	24 11		bit $11			BIT	INPFLG			; test input mode flag, $00 = INPUT, $40 = GET, $98 = READ
.cc33	50 0c		bvc $cc41		BVC	LAB_CC41		; branch if not GET
.cc35	20 21 e1	jsr $e121		JSR	LAB_E121		; get character from input device with error check
.cc38	8d 00 02	sta $0200		STA	BUF			; save to buffer
.cc3b	a2 ff		ldx #$ff		LDX	#<BUF-1			; set BUF-1 pointer low byte
.cc3d	a0 01		ldy #$01		LDY	#>BUF-1			; set BUF-1 pointer high byte
.cc3f	d0 0c		bne $cc4d		BNE	LAB_CC4D		; go interpret single character
.cc41					LAB_CC41
.cc41	30 75		bmi $ccb8		BMI	LAB_CCB8		; if READ go get some DATA
.cc43	a5 13		lda $13			LDA	CHANNL			; get current I/O channel
.cc45	d0 03		bne $cc4a		BNE	LAB_CC4A		; skip "?" prompt if not default channel
.cc47	20 45 cb	jsr $cb45		JSR	LAB_CB45		; print "?"
.cc4a					LAB_CC4A
.cc4a	20 f9 cb	jsr $cbf9		JSR	LAB_CBF9		; print "? " and get BASIC input
.cc4d					LAB_CC4D
.cc4d	86 7a		stx $7a			STX	CHRGOT+1		; save BASIC execute pointer low byte
.cc4f	84 7b		sty $7b			STY	CHRGOT+2		; save BASIC execute pointer high byte
.cc51					LAB_CC51
.cc51	20 73 00	jsr $0073		JSR	CHRGET			; increment and scan memory, execute pointer now points to
.cc54	24 0d		bit $0d			BIT	VALTYP			; test data type flag, $FF = string, $00 = numeric
.cc56	10 31		bpl $cc89		BPL	LAB_CC89		; branch if numeric
.cc58	24 11		bit $11			BIT	INPFLG			; test INPUT mode flag, $00 = INPUT, $40 = GET, $98 = READ
.cc5a	50 09		bvc $cc65		BVC	LAB_CC65		; branch if not GET
.cc5c	e8		inx			INX				; clear .X ??
.cc5d	86 7a		stx $7a			STX	CHRGOT+1		; save BASIC execute pointer low byte
.cc5f	a9 00		lda #$00		LDA	#$00			; clear .A
.cc61	85 07		sta $07			STA	CHARAC			; clear search character
.cc63	f0 0c		beq $cc71		BEQ	LAB_CC71		; branch always
.cc65					LAB_CC65
.cc65	85 07		sta $07			STA	CHARAC			; save search character
.cc67	c9 22		cmp #$22		CMP	#$22			; compare with "
.cc69	f0 07		beq $cc72		BEQ	LAB_CC72		; if quote only search for "..." string
.cc6b	a9 3a		lda #$3a		LDA	#':'			; set ":"
.cc6d	85 07		sta $07			STA	CHARAC			; set search character
.cc6f	a9 2c		lda #$2c		LDA	#','			; set ","
.cc71					LAB_CC71
.cc71	18		clc			CLC				; clear carry for add
.cc72					LAB_CC72
.cc72	85 08		sta $08			STA	ENDCHR			; set scan quotes flag
.cc74	a5 7a		lda $7a			LDA	CHRGOT+1		; get BASIC execute pointer low byte
.cc76	a4 7b		ldy $7b			LDY	CHRGOT+2		; get BASIC execute pointer high byte
.cc78	69 00		adc #$00		ADC	#$00			; add to pointer low byte. this add increments the pointer
.cc7a	90 01		bcc $cc7d		BCC	LAB_CC7D		; if no rollover skip the high byte increment
.cc7c	c8		iny			INY				; else increment pointer high byte
.cc7d					LAB_CC7D
.cc7d	20 8d d4	jsr $d48d		JSR	LAB_D48D		; print string to utility pointer
.cc80	20 e2 d7	jsr $d7e2		JSR	LAB_D7E2		; restore BASIC execute pointer from temp
.cc83	20 da c9	jsr $c9da		JSR	LET5			; perform string LET
.cc86	4c 91 cc	jmp $cc91		JMP	LAB_CC91		; continue processing command
.cc89					LAB_CC89
.cc89	20 f3 dc	jsr $dcf3		JSR	ASCFLT			; get FAC1 from string
.cc8c	a5 0e		lda $0e			LDA	INTFLG			; get data type flag, $80 = integer, $00 = float
.cc8e	20 c2 c9	jsr $c9c2		JSR	LET2			; assign value to numeric variable
.cc91					LAB_CC91
.cc91	20 79 00	jsr $0079		JSR	CHRGOT			; scan memory
.cc94	f0 07		beq $cc9d		BEQ	LAB_CC9D		; if ":" or [EOL] go handle the string end
.cc96	c9 2c		cmp #$2c		CMP	#','			; compare with ","
.cc98	f0 03		beq $cc9d		BEQ	LAB_CC9D		; if "," go handle the string end
.cc9a	4c 4d cb	jmp $cb4d		JMP	IGRERR			; else go do bad input routine
.cc9d					LAB_CC9D
.cc9d	a5 7a		lda $7a			LDA	CHRGOT+1		; get BASIC execute pointer low byte
.cc9f	a4 7b		ldy $7b			LDY	CHRGOT+2		; get BASIC execute pointer high byte
.cca1	85 43		sta $43			STA	INPPTR			; save READ pointer low byte
.cca3	84 44		sty $44			STY	INPPTR+1		; save READ pointer high byte
.cca5	a5 4b		lda $4b			LDA	OPPTR			; get saved BASIC execute pointer low byte
.cca7	a4 4c		ldy $4c			LDY	OPPTR+1			; get saved BASIC execute pointer high byte
.cca9	85 7a		sta $7a			STA	CHRGOT+1		; restore BASIC execute pointer low byte
.ccab	84 7b		sty $7b			STY	CHRGOT+2		; restore BASIC execute pointer high byte
.ccad	20 79 00	jsr $0079		JSR	CHRGOT			; scan memory
.ccb0	f0 2d		beq $ccdf		BEQ	LAB_CCDF		; branch if ":" or [EOL]
.ccb2	20 fd ce	jsr $cefd		JSR	COMCHK			; scan for ",", else do syntax error then warm start
.ccb5	4c 15 cc	jmp $cc15		JMP	LAB_CC15		; go READ or INPUT next variable from list
.ccb8					LAB_CCB8
.ccb8	20 06 c9	jsr $c906		JSR	FIND2			; scan for next BASIC statement ([:] or [EOL])
.ccbb	c8		iny			INY				; increment index to next byte
.ccbc	aa		tax			TAX				; copy byte to .X
.ccbd	d0 12		bne $ccd1		BNE	LAB_CCD1		; if ":" go look for the next DATA
.ccbf	a2 0d		ldx #$0d		LDX	#ER_OODATA		; else set error $0D, out of data error
.ccc1	c8		iny			INY				; increment index to next line pointer high byte
.ccc2	b1 7a		lda ($7a),y		LDA	(CHRGOT+1),Y		; get next line pointer high byte
.ccc4	f0 6c		beq $cd32		BEQ	LAB_CD32		; if program end go do error, eventually does error .X
.ccc6	c8		iny			INY				; increment index
.ccc7	b1 7a		lda ($7a),y		LDA	(CHRGOT+1),Y		; get next line # low byte
.ccc9	85 3f		sta $3f			STA	DATLIN			; save current DATA line low byte
.cccb	c8		iny			INY				; increment index
.cccc	b1 7a		lda ($7a),y		LDA	(CHRGOT+1),Y		; get next line # high byte
.ccce	c8		iny			INY				; increment index
.cccf	85 40		sta $40			STA	DATLIN+1		; save current DATA line high byte
.ccd1					LAB_CCD1
.ccd1	20 fb c8	jsr $c8fb		JSR	BUMPTP			; add .Y to the BASIC execute pointer
.ccd4	20 79 00	jsr $0079		JSR	CHRGOT			; scan memory
.ccd7	aa		tax			TAX				; copy byte
.ccd8	e0 83		cpx #$83		CPX	#TK_DATA		; compare with token for DATA
.ccda	d0 dc		bne $ccb8		BNE	LAB_CCB8		; loop if not DATA
.ccdc	4c 51 cc	jmp $cc51		JMP	LAB_CC51		; continue evaluating READ
.ccdf					LAB_CCDF
.ccdf	a5 43		lda $43			LDA	INPPTR			; get READ pointer low byte
.cce1	a4 44		ldy $44			LDY	INPPTR+1		; get READ pointer high byte
.cce3	a6 11		ldx $11			LDX	INPFLG			; get INPUT mode flag, $00 = INPUT, $40 = GET, $98 = READ
.cce5	10 03		bpl $ccea		BPL	LAB_CCEA		; if INPUT or GET go exit or ignore extra input
.cce7	4c 27 c8	jmp $c827		JMP	LAB_C827		; else set data pointer and exit
.ccea					LAB_CCEA
.ccea	a0 00		ldy #$00		LDY	#$00			; clear index
.ccec	b1 43		lda ($43),y		LDA	(INPPTR),Y		; get READ byte
.ccee	f0 0b		beq $ccfb		BEQ	LAB_CCFB		; exit if [EOL]
.ccf0	a5 13		lda $13			LDA	CHANNL			; get current I/O channel
.ccf2	d0 07		bne $ccfb		BNE	LAB_CCFB		; exit if not default channel
.ccf4	a9 fc		lda #$fc		LDA	#<EXTRA			; set "?EXTRA IGNORED" pointer low byte
.ccf6	a0 cc		ldy #$cc		LDY	#>EXTRA			; set "?EXTRA IGNORED" pointer high byte
.ccf8	4c 1e cb	jmp $cb1e		JMP	PRTSTR			; print null terminated string
.ccfb					LAB_CCFB
.ccfb	60		rts			RTS
.ccfc					EXTRA
>ccfc	3f 45 58 54 52 41 20 49			.text	"?EXTRA IGNORED",$0D,$00
>cd04	47 4e 4f 52 45 44 0d 00
.cd0c					LAB_CD0C
>cd0c	3f 52 45 44 4f 20 46 52			.text	"?REDO FROM START",$0D,$00
>cd14	4f 4d 20 53 54 41 52 54 0d 00
.cd1e					NEXT
.cd1e	d0 04		bne $cd24		BNE	LAB_CD24		; if NEXT variable go find the variable
.cd20	a0 00		ldy #$00		LDY	#$00			; else clear .Y
.cd22	f0 03		beq $cd27		BEQ	LAB_CD27		; use any variable, branch always
.cd24					LAB_CD24
.cd24	20 8b d0	jsr $d08b		JSR	EVLVAR			; get variable address
.cd27					LAB_CD27
.cd27	85 49		sta $49			STA	FORPNT			; save FOR/NEXT variable pointer low byte
.cd29	84 4a		sty $4a			STY	FORPNT+1		; save FOR/NEXT variable pointer high byte
.cd2b	20 8a c3	jsr $c38a		JSR	SCNSTK			; search the stack for FOR or GOSUB activity
.cd2e	f0 05		beq $cd35		BEQ	LAB_CD35		; if FOR found continue
.cd30	a2 0a		ldx #$0a		LDX	#ER_NXTWOFOR		; else set error $0A, next without for error
.cd32					LAB_CD32
.cd32	4c 37 c4	jmp $c437		JMP	ERROR			; do error #.X then warm start
.cd35					LAB_CD35
.cd35	9a		txs			TXS				; update stack pointer
.cd36	8a		txa			TXA				; copy stack pointer
.cd37	18		clc			CLC				; clear carry for add
.cd38	69 04		adc #$04		ADC	#$04			; point to STEP value
.cd3a	48		pha			PHA				; save it
.cd3b	69 06		adc #$06		ADC	#$06			; point to TO value
.cd3d	85 24		sta $24			STA	INDEX+2			; save pointer to TO variable for compare
.cd3f	68		pla			PLA				; restore pointer to STEP value
.cd40	a0 01		ldy #$01		LDY	#$01			; point to stack page
.cd42	20 a2 db	jsr $dba2		JSR	LODFAC			; unpack memory (.A.Y) into FAC1
.cd45	ba		tsx			TSX				; get stack pointer back
.cd46	bd 09 01	lda $0109,x		LDA	STACK+9,X		; get step sign
.cd49	85 66		sta $66			STA	FAC1+FAC_SIGN		; save FAC1 sign (b7)
.cd4b	a5 49		lda $49			LDA	FORPNT			; get FOR/NEXT variable pointer low byte
.cd4d	a4 4a		ldy $4a			LDY	FORPNT+1		; get FOR/NEXT variable pointer high byte
.cd4f	20 67 d8	jsr $d867		JSR	LAPLUS			; add FOR variable to FAC1
.cd52	20 d0 db	jsr $dbd0		JSR	FACTFP			; pack FAC1 into FOR variable
.cd55	a0 01		ldy #$01		LDY	#$01			; point to stack page
.cd57	20 5d dc	jsr $dc5d		JSR	LAB_DC5D		; compare FAC1 with TO value
.cd5a	ba		tsx			TSX				; get stack pointer back
.cd5b	38		sec			SEC				; set carry for subtract
.cd5c	fd 09 01	sbc $0109,x		SBC	STACK+9,X		; subtract step sign
.cd5f	f0 17		beq $cd78		BEQ	LAB_CD78		; if = loop complete, go unstack the FOR
.cd61	bd 0f 01	lda $010f,x		LDA	STACK+$0F,X		; get FOR line low byte
.cd64	85 39		sta $39			STA	CURLIN			; save current line number low byte
.cd66	bd 10 01	lda $0110,x		LDA	STACK+$10,X		; get FOR line high byte
.cd69	85 3a		sta $3a			STA	CURLIN+1		; save current line number high byte
.cd6b	bd 12 01	lda $0112,x		LDA	STACK+$12,X		; get BASIC execute pointer low byte
.cd6e	85 7a		sta $7a			STA	CHRGOT+1		; save BASIC execute pointer low byte
.cd70	bd 11 01	lda $0111,x		LDA	STACK+$11,X		; get BASIC execute pointer high byte
.cd73	85 7b		sta $7b			STA	CHRGOT+2		; save BASIC execute pointer high byte
.cd75					LAB_CD75
.cd75	4c ae c7	jmp $c7ae		JMP	NEWSTT			; go do interpreter inner loop
.cd78					LAB_CD78
.cd78	8a		txa			TXA				; stack copy to .A
.cd79	69 11		adc #$11		ADC	#$11			; add $12, $11 + carry, to dump FOR structure
.cd7b	aa		tax			TAX				; copy back to index
.cd7c	9a		txs			TXS				; copy to stack pointer
.cd7d	20 79 00	jsr $0079		JSR	CHRGOT			; scan memory
.cd80	c9 2c		cmp #$2c		CMP	#','			; compare with ","
.cd82	d0 f1		bne $cd75		BNE	LAB_CD75		; if not "," go do interpreter inner loop
.cd84	20 73 00	jsr $0073		JSR	CHRGET			; increment and scan memory
.cd87	20 24 cd	jsr $cd24		JSR	LAB_CD24		; do NEXT variable
.cd8a					TYPCHK
.cd8a	20 9e cd	jsr $cd9e		JSR	FRMEVL			; evaluate expression
.cd8d					LAB_CD8D
.cd8d	18		clc			CLC
>cd8e	24					.byte	$24			; makes next line BIT $38
.cd8f					LAB_CD8F
.cd8f	38		sec			SEC				; destination is string
.cd90					LAB_CD90
.cd90	24 0d		bit $0d			BIT	VALTYP			; test data type flag, $FF = string, $00 = numeric
.cd92	30 03		bmi $cd97		BMI	LAB_CD97		; if string go check string is required
.cd94	b0 03		bcs $cd99		BCS	LAB_CD99		; if string is required go do type mismatch error
.cd96					LAB_CD96
.cd96	60		rts			RTS
.cd97					LAB_CD97
.cd97	b0 fd		bcs $cd96		BCS	LAB_CD96		; exit if string is required
.cd99					LAB_CD99
.cd99	a2 16		ldx #$16		LDX	#ER_TYPMSMCH		; error code $16, type mismatch error
.cd9b	4c 37 c4	jmp $c437		JMP	ERROR			; do error #.X then warm start
.cd9e					FRMEVL
.cd9e	a6 7a		ldx $7a			LDX	CHRGOT+1		; get BASIC execute pointer low byte
.cda0	d0 02		bne $cda4		BNE	LAB_CDA4		; skip next if not zero
.cda2	c6 7b		dec $7b			DEC	CHRGOT+2		; else decrement BASIC execute pointer high byte
.cda4					LAB_CDA4
.cda4	c6 7a		dec $7a			DEC	CHRGOT+1		; decrement BASIC execute pointer low byte
.cda6	a2 00		ldx #$00		LDX	#$00			; set null precedence, flag done
>cda8	24					.byte	$24			; makes next line BIT $48
.cda9					LAB_CDA9
.cda9	48		pha			PHA				; push compare evaluation byte if branch to here
.cdaa	8a		txa			TXA				; copy precedence byte
.cdab	48		pha			PHA				; push precedence byte
.cdac	a9 01		lda #$01		LDA	#$01			; 2 bytes
.cdae	20 fb c3	jsr $c3fb		JSR	STKSPC			; check room on stack for .A*2 bytes
.cdb1	20 83 ce	jsr $ce83		JSR	EVAL			; get value from line
.cdb4	a9 00		lda #$00		LDA	#$00			; clear .A
.cdb6	85 4d		sta $4d			STA	OPMASK			; clear comparison evaluation flag
.cdb8					LAB_CDB8
.cdb8	20 79 00	jsr $0079		JSR	CHRGOT			; scan memory
.cdbb					LAB_CDBB
.cdbb	38		sec			SEC				; set carry for subtract
.cdbc	e9 b1		sbc #$b1		SBC	#TK_GT			; subtract token for ">"
.cdbe	90 17		bcc $cdd7		BCC	LAB_CDD7		; if < ">" skip comparison test check
.cdc0	c9 03		cmp #$03		CMP	#$03			; compare with ">" to +3
.cdc2	b0 13		bcs $cdd7		BCS	LAB_CDD7		; if >= 3 skip comparison test check
.cdc4	c9 01		cmp #$01		CMP	#$01			; compare with token for "="
.cdc6	2a		rol a			ROL				; *2, b0 = carry (=1 if token was "=" or "<")
.cdc7	49 01		eor #$01		EOR	#$01			; toggle b0
.cdc9	45 4d		eor $4d			EOR	OPMASK			; XOR with comparison evaluation flag
.cdcb	c5 4d		cmp $4d			CMP	OPMASK			; compare with comparison evaluation flag
.cdcd	90 61		bcc $ce30		BCC	LAB_CE30		; if < saved flag do syntax error then warm start
.cdcf	85 4d		sta $4d			STA	OPMASK			; save new comparison evaluation flag
.cdd1	20 73 00	jsr $0073		JSR	CHRGET			; increment and scan memory
.cdd4	4c bb cd	jmp $cdbb		JMP	LAB_CDBB		; go do next character
.cdd7					LAB_CDD7
.cdd7	a6 4d		ldx $4d			LDX	OPMASK			; get comparison evaluation flag
.cdd9	d0 2c		bne $ce07		BNE	LAB_CE07		; if compare function flagged go evaluate right hand side
.cddb	b0 7b		bcs $ce58		BCS	LAB_CE58		; go do functions
.cddd	69 07		adc #$07		ADC	#$07			; add # of operators (+, -, *, /, ^, AND or OR)
.cddf	90 77		bcc $ce58		BCC	LAB_CE58		; if < + operator go do the function
.cde1	65 0d		adc $0d			ADC	VALTYP			; add data type flag, $FF = string, $00 = numeric
.cde3	d0 03		bne $cde8		BNE	LAB_CDE8		; if not string or not + token skip concatenate
.cde5	4c 3d d6	jmp $d63d		JMP	ADDSTR			; add strings, string 1 is in the descriptor, string 2
.cde8					LAB_CDE8
.cde8	69 ff		adc #$ff		ADC	#$FF			; -1 (corrects for carry add)
.cdea	85 22		sta $22			STA	INDEX			; save it
.cdec	0a		asl a			ASL				; *2
.cded	65 22		adc $22			ADC	INDEX			; *3
.cdef	a8		tay			TAY				; copy to index
.cdf0					LAB_CDF0
.cdf0	68		pla			PLA				; pull previous precedence
.cdf1	d9 80 c0	cmp $c080,y		CMP	OPTAB,Y			; compare with precedence byte
.cdf4	b0 67		bcs $ce5d		BCS	LAB_CE5D		; if .A >= go do the function
.cdf6	20 8d cd	jsr $cd8d		JSR	LAB_CD8D		; check if source is numeric, else do type mismatch
.cdf9					LAB_CDF9
.cdf9	48		pha			PHA				; save precedence
.cdfa					LAB_CDFA
.cdfa	20 20 ce	jsr $ce20		JSR	LAB_CE20		; get vector, execute function then continue evaluation
.cdfd	68		pla			PLA				; restore precedence
.cdfe	a4 4b		ldy $4b			LDY	OPPTR			; get precedence stacked flag
.ce00	10 17		bpl $ce19		BPL	LAB_CE19		; if stacked values go check the precedence
.ce02	aa		tax			TAX				; copy precedence, set flags
.ce03	f0 56		beq $ce5b		BEQ	LAB_CE5B		; exit if done
.ce05	d0 5f		bne $ce66		BNE	LAB_CE66		; else pop FAC2 and return, branch always
.ce07					LAB_CE07
.ce07	46 0d		lsr $0d			LSR	VALTYP			; clear data type flag, $FF = string, $00 = numeric
.ce09	8a		txa			TXA				; copy compare function flag
.ce0a	2a		rol a			ROL				; <<1, shift data type flag into b0, 1 = string, 0 = num
.ce0b	a6 7a		ldx $7a			LDX	CHRGOT+1		; get BASIC execute pointer low byte
.ce0d	d0 02		bne $ce11		BNE	LAB_CE11		; if no underflow skip the high byte decrement
.ce0f	c6 7b		dec $7b			DEC	CHRGOT+2		; else decrement BASIC execute pointer high byte
.ce11					LAB_CE11
.ce11	c6 7a		dec $7a			DEC	CHRGOT+1		; decrement BASIC execute pointer low byte
.ce13	a0 1b		ldy #$1b		LDY	#LAB_C09B-OPTAB
.ce15	85 4d		sta $4d			STA	OPMASK			; save new comparison evaluation flag
.ce17	d0 d7		bne $cdf0		BNE	LAB_CDF0		; branch always
.ce19					LAB_CE19
.ce19	d9 80 c0	cmp $c080,y		CMP	OPTAB,Y			; compare with stacked function precedence
.ce1c	b0 48		bcs $ce66		BCS	LAB_CE66		; if .A >=, pop FAC2 and return
.ce1e	90 d9		bcc $cdf9		BCC	LAB_CDF9		; else go stack this one and continue, branch always
.ce20					LAB_CE20
.ce20	b9 82 c0	lda $c082,y		LDA	OPTAB+2,Y		; get function vector high byte
.ce23	48		pha			PHA				; onto stack
.ce24	b9 81 c0	lda $c081,y		LDA	OPTAB+1,Y		; get function vector low byte
.ce27	48		pha			PHA				; onto stack
.ce28	20 33 ce	jsr $ce33		JSR	LAB_CE33		; function will return here, then the next RTS will call
.ce2b	a5 4d		lda $4d			LDA	OPMASK			; get comparison evaluation flag
.ce2d	4c a9 cd	jmp $cda9		JMP	LAB_CDA9		; continue evaluating expression
.ce30					LAB_CE30
.ce30	4c 08 cf	jmp $cf08		JMP	LAB_CF08		; do syntax error then warm start
.ce33					LAB_CE33
.ce33	a5 66		lda $66			LDA	FAC1+FAC_SIGN		; get FAC1 sign (b7)
.ce35	be 80 c0	ldx $c080,y		LDX	OPTAB,Y			; get precedence byte
.ce38					LAB_CE38
.ce38	a8		tay			TAY				; copy sign
.ce39	68		pla			PLA				; get return address low byte
.ce3a	85 22		sta $22			STA	INDEX			; save it
.ce3c	e6 22		inc $22			INC	INDEX			; increment it as return - 1 is pushed
.ce3e	68		pla			PLA				; get return address high byte
.ce3f	85 23		sta $23			STA	INDEX+1			; save it
.ce41	98		tya			TYA				; restore sign
.ce42	48		pha			PHA				; push sign
.ce43					LAB_CE43
.ce43	20 1b dc	jsr $dc1b		JSR	ROUND			; round FAC1
.ce46	a5 65		lda $65			LDA	FAC1+FAC_MANT+3		; get FAC1 mantissa 4
.ce48	48		pha			PHA				; save it
.ce49	a5 64		lda $64			LDA	FAC1+FAC_MANT+2		; get FAC1 mantissa 3
.ce4b	48		pha			PHA				; save it
.ce4c	a5 63		lda $63			LDA	FAC1+FAC_MANT+1		; get FAC1 mantissa 2
.ce4e	48		pha			PHA				; save it
.ce4f	a5 62		lda $62			LDA	FAC1+FAC_MANT		; get FAC1 mantissa 1
.ce51	48		pha			PHA				; save it
.ce52	a5 61		lda $61			LDA	FAC1+FAC_EXPT		; get FAC1 exponent
.ce54	48		pha			PHA				; save it
.ce55	6c 22 00	jmp ($0022)		JMP	(INDEX)			; return, sort of
.ce58					LAB_CE58
.ce58	a0 ff		ldy #$ff		LDY	#$FF			; flag function
.ce5a	68		pla			PLA				; pull precedence byte
.ce5b					LAB_CE5B
.ce5b	f0 23		beq $ce80		BEQ	LAB_CE80		; exit if done
.ce5d					LAB_CE5D
.ce5d	c9 64		cmp #$64		CMP	#$64			; compare previous precedence with $64
.ce5f	f0 03		beq $ce64		BEQ	LAB_CE64		; if was $64 (< function) skip the type check
.ce61	20 8d cd	jsr $cd8d		JSR	LAB_CD8D		; check if source is numeric, else do type mismatch
.ce64					LAB_CE64
.ce64	84 4b		sty $4b			STY	OPPTR			; save precedence stacked flag
.ce66					LAB_CE66
.ce66	68		pla			PLA				; pop byte
.ce67	4a		lsr a			LSR				; shift out comparison evaluation lowest bit
.ce68	85 12		sta $12			STA	TANSGN			; save the comparison evaluation flag
.ce6a	68		pla			PLA				; pop exponent
.ce6b	85 69		sta $69			STA	FAC2+FAC_EXPT		; save FAC2 exponent
.ce6d	68		pla			PLA				; pop mantissa 1
.ce6e	85 6a		sta $6a			STA	FAC2+FAC_MANT		; save FAC2 mantissa 1
.ce70	68		pla			PLA				; pop mantissa 2
.ce71	85 6b		sta $6b			STA	FAC2+FAC_MANT+1		; save FAC2 mantissa 2
.ce73	68		pla			PLA				; pop mantissa 3
.ce74	85 6c		sta $6c			STA	FAC2+FAC_MANT+2		; save FAC2 mantissa 3
.ce76	68		pla			PLA				; pop mantissa 4
.ce77	85 6d		sta $6d			STA	FAC2+FAC_MANT+3		; save FAC2 mantissa 4
.ce79	68		pla			PLA				; pop sign
.ce7a	85 6e		sta $6e			STA	FAC2+FAC_SIGN		; save FAC2 sign (b7)
.ce7c	45 66		eor $66			EOR	FAC1+FAC_SIGN		; XOR FAC1 sign (b7)
.ce7e	85 6f		sta $6f			STA	ARISGN			; save sign compare (FAC1 XOR FAC2)
.ce80					LAB_CE80
.ce80	a5 61		lda $61			LDA	FAC1+FAC_EXPT		; get FAC1 exponent
.ce82	60		rts			RTS
.ce83					EVAL
.ce83	6c 0a 03	jmp ($030a)		JMP	(IEVAL)			; get arithmetic element
.ce86					FEVAL
.ce86	a9 00		lda #$00		LDA	#$00			; clear byte
.ce88	85 0d		sta $0d			STA	VALTYP			; clear data type flag, $FF = string, $00 = numeric
.ce8a					LAB_CE8A
.ce8a	20 73 00	jsr $0073		JSR	CHRGET			; increment and scan memory
.ce8d	b0 03		bcs $ce92		BCS	LAB_CE92		; if not numeric character continue
.ce8f					LAB_CE8F
.ce8f	4c f3 dc	jmp $dcf3		JMP	ASCFLT			; get FAC1 from string and return
.ce92					LAB_CE92
.ce92	20 13 d1	jsr $d113		JSR	CHRTST			; check byte, return Cb = 0 if <"A" or >"Z"
.ce95	90 03		bcc $ce9a		BCC	LAB_CE9A		; if not variable name continue
.ce97	4c 28 cf	jmp $cf28		JMP	FACT12			; variable name set-up and return
.ce9a					LAB_CE9A
.ce9a	c9 ff		cmp #$ff		CMP	#TK_PI			; compare with token for PI
.ce9c	d0 0f		bne $cead		BNE	LAB_CEAD		; if not PI continue
.ce9e	a9 a8		lda #$a8		LDA	#<PIVAL			; get PI pointer low byte
.cea0	a0 ce		ldy #$ce		LDY	#>PIVAL			; get PI pointer high byte
.cea2	20 a2 db	jsr $dba2		JSR	LODFAC			; unpack memory (.A.Y) into FAC1
.cea5	4c 73 00	jmp $0073		JMP	CHRGET			; increment and scan memory and return
.cea8					PIVAL
>cea8	82 49 0f da a1				.byte	$82,$49,$0F,$DA,$A1
.cead					LAB_CEAD
.cead	c9 2e		cmp #$2e		CMP	#'.'			; compare with "."
.ceaf	f0 de		beq $ce8f		BEQ	LAB_CE8F		; if so get FAC1 from string and return, e.g. was .123
.ceb1	c9 ab		cmp #$ab		CMP	#TK_MINUS		; compare with token for "-"
.ceb3	f0 58		beq $cf0d		BEQ	FACT10			; if "-" token, do set-up for functions
.ceb5	c9 aa		cmp #$aa		CMP	#TK_PLUS		; compare with token for "+"
.ceb7	f0 d1		beq $ce8a		BEQ	LAB_CE8A		; if "+" token ignore the leading +, +1 = 1
.ceb9	c9 22		cmp #$22		CMP	#$22			; compare with "
.cebb	d0 0f		bne $cecc		BNE	LAB_CECC		; if not open quote continue
.cebd					LAB_CEBD
.cebd	a5 7a		lda $7a			LDA	CHRGOT+1		; get BASIC execute pointer low byte
.cebf	a4 7b		ldy $7b			LDY	CHRGOT+2		; get BASIC execute pointer high byte
.cec1	69 00		adc #$00		ADC	#$00			; add carry to low byte
.cec3	90 01		bcc $cec6		BCC	LAB_CEC6		; branch if no overflow
.cec5	c8		iny			INY				; increment high byte
.cec6					LAB_CEC6
.cec6	20 87 d4	jsr $d487		JSR	MAKSTR			; print " terminated string to utility pointer
.cec9	4c e2 d7	jmp $d7e2		JMP	LAB_D7E2		; restore BASIC execute pointer from temp and return
.cecc					LAB_CECC
.cecc	c9 a8		cmp #$a8		CMP	#TK_NOT			; compare with token for NOT
.cece	d0 13		bne $cee3		BNE	LAB_CEE3		; if not token for NOT continue
.ced0	a0 18		ldy #$18		LDY	#$18			; offset to NOT function
.ced2	d0 3b		bne $cf0f		BNE	LAB_CF0F		; do set-up for function then execute, branch always
.ced4					EQUAL
.ced4	20 bf d1	jsr $d1bf		JSR	MAKINT			; evaluate integer expression, no sign check
.ced7	a5 65		lda $65			LDA	FAC1+FAC_MANT+3		; get FAC1 mantissa 4
.ced9	49 ff		eor #$ff		EOR	#$FF			; invert it
.cedb	a8		tay			TAY				; copy it
.cedc	a5 64		lda $64			LDA	FAC1+FAC_MANT+2		; get FAC1 mantissa 3
.cede	49 ff		eor #$ff		EOR	#$FF			; invert it
.cee0	4c 91 d3	jmp $d391		JMP	MAKFP			; convert fixed integer .A.Y to float FAC1 and return
.cee3					LAB_CEE3
.cee3	c9 a5		cmp #$a5		CMP	#TK_FN			; compare with token for FN
.cee5	d0 03		bne $ceea		BNE	LAB_CEEA		; if not token for FN continue
.cee7	4c f4 d3	jmp $d3f4		JMP	EVALFN			; else go evaluate FNx
.ceea					LAB_CEEA
.ceea	c9 b4		cmp #$b4		CMP	#TK_SGN			; compare with token for SGN
.ceec	90 03		bcc $cef1		BCC	PAREXP			; if less than SGN token go evaluate expression in ()
.ceee	4c a7 cf	jmp $cfa7		JMP	FACT17			; go set up function references, branch always
.cef1					PAREXP
.cef1	20 fa ce	jsr $cefa		JSR	LPACHK			; scan for "(", else do syntax error then warm start
.cef4	20 9e cd	jsr $cd9e		JSR	FRMEVL			; evaluate expression
.cef7					RPACHK
.cef7	a9 29		lda #$29		LDA	#')'			; load .A with ")"
>cef9	2c					.byte	$2C			; makes next line BIT $28A9
.cefa					LPACHK
.cefa	a9 28		lda #$28		LDA	#'('			; load .A with "("
>cefc	2c					.byte	$2C			; makes next line BIT $2CA9
.cefd					COMCHK
.cefd	a9 2c		lda #$2c		LDA	#','			; load .A with ","
.ceff					SYNCHR
.ceff	a0 00		ldy #$00		LDY	#$00			; clear index
.cf01	d1 7a		cmp ($7a),y		CMP	(CHRGOT+1),Y		; compare with BASIC byte
.cf03	d0 03		bne $cf08		BNE	LAB_CF08		; if not expected byte do syntax error then warm start
.cf05	4c 73 00	jmp $0073		JMP	CHRGET			; else increment and scan memory and return
.cf08					LAB_CF08
.cf08	a2 0b		ldx #$0b		LDX	#ER_SYNTAX		; error code $0B, syntax error
.cf0a	4c 37 c4	jmp $c437		JMP	ERROR			; do error #.X then warm start
.cf0d					FACT10
.cf0d	a0 15		ldy #$15		LDY	#$15			; set offset from base to > operator
.cf0f					LAB_CF0F
.cf0f	68		pla			PLA				; dump return address low byte
.cf10	68		pla			PLA				; dump return address high byte
.cf11	4c fa cd	jmp $cdfa		JMP	LAB_CDFA		; execute function then continue evaluation
.cf14					VARRANGE
.cf14	38		sec			SEC				; set carry for subtract
.cf15	a5 64		lda $64			LDA	FAC1+3			; get variable address low byte
.cf17	e9 00		sbc #$00		SBC	#<COLDST		; subtract $C000 low byte
.cf19	a5 65		lda $65			LDA	FAC1+4			; get variable address high byte
.cf1b	e9 c0		sbc #$c0		SBC	#>COLDST		; subtract $C000 high byte
.cf1d	90 08		bcc $cf27		BCC	LAB_CF27		; exit if address < $C000
.cf1f	a9 87		lda #$87		LDA	#<CGIMAG		; get end of BASIC marker low byte
.cf21	e5 64		sbc $64			SBC	FAC1+3			; subtract variable address low byte
.cf23	a9 e3		lda #$e3		LDA	#>CGIMAG		; get end of BASIC marker high byte
.cf25	e5 65		sbc $65			SBC	FAC1+4			; subtract variable address high byte
.cf27					LAB_CF27
.cf27	60		rts			RTS
.cf28					FACT12
.cf28	20 8b d0	jsr $d08b		JSR	EVLVAR			; get variable address
.cf2b	85 64		sta $64			STA	FAC1+3			; save variable pointer low byte
.cf2d	84 65		sty $65			STY	FAC1+4			; save variable pointer high byte
.cf2f	a6 45		ldx $45			LDX	VARNAM			; get current variable name first character
.cf31	a4 46		ldy $46			LDY	VARNAM+1		; get current variable name second character
.cf33	a5 0d		lda $0d			LDA	VALTYP			; get data type flag, $FF = string, $00 = numeric
.cf35	f0 26		beq $cf5d		BEQ	LAB_CF5D		; if numeric go handle a numeric variable
.cf37	a9 00		lda #$00		LDA	#$00			; else clear .A
.cf39	85 70		sta $70			STA	FACOV			; clear FAC1 rounding byte
.cf3b	20 14 cf	jsr $cf14		JSR	VARRANGE		; check address range
.cf3e	90 1c		bcc $cf5c		BCC	LAB_CF5C		; exit if not in BASIC ROM
.cf40	e0 54		cpx #$54		CPX	#'T'			; compare variable name first character with "T"
.cf42	d0 18		bne $cf5c		BNE	LAB_CF5C		; exit if not "T"
.cf44	c0 c9		cpy #$c9		CPY	#'I'+$80		; compare variable name second character with "I$"
.cf46	d0 14		bne $cf5c		BNE	LAB_CF5C		; exit if not "I$"
.cf48	20 84 cf	jsr $cf84		JSR	LAB_CF84		; read real time clock into FAC1 mantissa, 0HML
.cf4b	84 5e		sty $5e			STY	EXPCNT			; clear exponent count adjust
.cf4d	88		dey			DEY				; .Y = $FF
.cf4e	84 71		sty $71			STY	FBUFPT			; set output string index, -1 to allow for pre increment
.cf50	a0 06		ldy #$06		LDY	#$06			; HH:MM:SS is six digits
.cf52	84 5d		sty $5d			STY	LAB_5D			; set number of characters before the decimal point
.cf54	a0 24		ldy #$24		LDY	#HMSCON-FLTCON
.cf56	20 68 de	jsr $de68		JSR	LAB_DE68		; convert jiffy count to string
.cf59	4c 6f d4	jmp $d46f		JMP	LAB_D46F		; exit via STR$() code tail
.cf5c					LAB_CF5C
.cf5c	60		rts			RTS
.cf5d					LAB_CF5D
.cf5d	24 0e		bit $0e			BIT	INTFLG			; test data type flag, $80 = integer, $00 = float
.cf5f	10 0d		bpl $cf6e		BPL	LAB_CF6E		; if float go handle float
.cf61	a0 00		ldy #$00		LDY	#$00			; clear index
.cf63	b1 64		lda ($64),y		LDA	(FAC1+3),Y		; get integer variable low byte
.cf65	aa		tax			TAX				; copy to .X
.cf66	c8		iny			INY				; increment index
.cf67	b1 64		lda ($64),y		LDA	(FAC1+3),Y		; get integer variable high byte
.cf69	a8		tay			TAY				; copy to .Y
.cf6a	8a		txa			TXA				; copy low byte to .A
.cf6b	4c 91 d3	jmp $d391		JMP	MAKFP			; convert fixed integer .A.Y to float FAC1 and return
.cf6e					LAB_CF6E
.cf6e	20 14 cf	jsr $cf14		JSR	VARRANGE		; check address range
.cf71	90 2d		bcc $cfa0		BCC	LAB_CFA0		; if not in BASIC ROM get pointer and unpack into FAC1
.cf73	e0 54		cpx #$54		CPX	#'T'			; compare variable name first character with "T"
.cf75	d0 1b		bne $cf92		BNE	LAB_CF92		; if not "T" skip Tx variables
.cf77	c0 49		cpy #$49		CPY	#'I'			; compare variable name second character with "I"
.cf79	d0 25		bne $cfa0		BNE	LAB_CFA0		; if not "I" go do plain float
.cf7b	20 84 cf	jsr $cf84		JSR	LAB_CF84		; read real time clock into FAC1 mantissa, 0HML
.cf7e	98		tya			TYA				; clear .A
.cf7f	a2 a0		ldx #$a0		LDX	#$A0			; set exponent to 32 bit value
.cf81	4c 4f dc	jmp $dc4f		JMP	LAB_DC4F		; set exponent = .X and normalise FAC1
.cf84					LAB_CF84
.cf84	20 de ff	jsr $ffde		JSR	RDTIM			; read real time clock
.cf87	86 64		stx $64			STX	FAC1+FAC_MANT+2		; save jiffy clock mid byte as FAC1 mantissa 3
.cf89	84 63		sty $63			STY	FAC1+FAC_MANT+1		; save jiffy clock high byte as FAC1 mantissa 2
.cf8b	85 65		sta $65			STA	FAC1+FAC_MANT+3		; save jiffy clock low byte as FAC1 mantissa 4
.cf8d	a0 00		ldy #$00		LDY	#$00			; clear .Y
.cf8f	84 62		sty $62			STY	FAC1+FAC_MANT		; clear FAC1 mantissa 1
.cf91	60		rts			RTS
.cf92					LAB_CF92
.cf92	e0 53		cpx #$53		CPX	#'S'			; compare variable name first character with "S"
.cf94	d0 0a		bne $cfa0		BNE	LAB_CFA0		; if not "S" go do normal floating variable
.cf96	c0 54		cpy #$54		CPY	#'T'			; compare variable name second character with "T"
.cf98	d0 06		bne $cfa0		BNE	LAB_CFA0		; if not "T" go do normal floating variable
.cf9a	20 b7 ff	jsr $ffb7		JSR	READST			; read I/O status word
.cf9d	4c 3c dc	jmp $dc3c		JMP	INTFP			; save .A as integer byte and return
.cfa0					LAB_CFA0
.cfa0	a5 64		lda $64			LDA	FAC1+3			; get variable pointer low byte
.cfa2	a4 65		ldy $65			LDY	FAC1+4			; get variable pointer high byte
.cfa4	4c a2 db	jmp $dba2		JMP	LODFAC			; unpack memory (.A.Y) into FAC1
.cfa7					FACT17
.cfa7	0a		asl a			ASL				; *2 (2 bytes per function address)
.cfa8	48		pha			PHA				; save function offset
.cfa9	aa		tax			TAX				; copy function offset
.cfaa	20 73 00	jsr $0073		JSR	CHRGET			; increment and scan memory
.cfad	e0 8f		cpx #$8f		CPX	#$8F			; compare function offset to CHR$ token offset+1
.cfaf	90 20		bcc $cfd1		BCC	LAB_CFD1		; if < LEFT$ (cannot be =) go do function setup
.cfb1	20 fa ce	jsr $cefa		JSR	LPACHK			; scan for "(", else do syntax error then warm start
.cfb4	20 9e cd	jsr $cd9e		JSR	FRMEVL			; evaluate, should be string, expression
.cfb7	20 fd ce	jsr $cefd		JSR	COMCHK			; scan for ",", else do syntax error then warm start
.cfba	20 8f cd	jsr $cd8f		JSR	LAB_CD8F		; check if source is string, else do type mismatch
.cfbd	68		pla			PLA				; restore function offset
.cfbe	aa		tax			TAX				; copy it
.cfbf	a5 65		lda $65			LDA	FAC1+4			; get descriptor pointer high byte
.cfc1	48		pha			PHA				; push string pointer high byte
.cfc2	a5 64		lda $64			LDA	FAC1+3			; get descriptor pointer low byte
.cfc4	48		pha			PHA				; push string pointer low byte
.cfc5	8a		txa			TXA				; restore function offset
.cfc6	48		pha			PHA				; save function offset
.cfc7	20 9e d7	jsr $d79e		JSR	LAB_D79E		; get byte parameter
.cfca	68		pla			PLA				; restore function offset
.cfcb	a8		tay			TAY				; copy function offset
.cfcc	8a		txa			TXA				; copy byte parameter to .A
.cfcd	48		pha			PHA				; push byte parameter
.cfce	4c d6 cf	jmp $cfd6		JMP	LAB_CFD6		; go call function
.cfd1					LAB_CFD1
.cfd1	20 f1 ce	jsr $cef1		JSR	PAREXP			; evaluate expression within parentheses
.cfd4	68		pla			PLA				; restore function offset
.cfd5	a8		tay			TAY				; copy to index
.cfd6					LAB_CFD6
.cfd6	b9 ea bf	lda $bfea,y		LDA	FUNDSP-$68,Y		; get function jump vector low byte
.cfd9	85 55		sta $55			STA	JMPER+1			; save functions jump vector low byte
.cfdb	b9 eb bf	lda $bfeb,y		LDA	FUNDSP-$67,Y		; get function jump vector high byte
.cfde	85 56		sta $56			STA	JMPER+2			; save functions jump vector high byte
.cfe0	20 54 00	jsr $0054		JSR	JMPER			; do function call
.cfe3	4c 8d cd	jmp $cd8d		JMP	LAB_CD8D		; check if source is numeric and RTS, else do type mismatch
.cfe6					ORR
.cfe6	a0 ff		ldy #$ff		LDY	#$FF			; set .Y for OR
>cfe8	2c					.byte	$2C			; makes next line BIT $00A0
.cfe9					ANDD
.cfe9	a0 00		ldy #$00		LDY	#$00			; clear .Y for AND
.cfeb	84 0b		sty $0b			STY	COUNT			; set AND/OR invert value
.cfed	20 bf d1	jsr $d1bf		JSR	MAKINT			; evaluate integer expression, no sign check
.cff0	a5 64		lda $64			LDA	FAC1+FAC_MANT+2		; get FAC1 mantissa 3
.cff2	45 0b		eor $0b			EOR	COUNT			; XOR low byte
.cff4	85 07		sta $07			STA	CHARAC			; save it
.cff6	a5 65		lda $65			LDA	FAC1+FAC_MANT+3		; get FAC1 mantissa 4
.cff8	45 0b		eor $0b			EOR	COUNT			; XOR high byte
.cffa	85 08		sta $08			STA	ENDCHR			; save it
.cffc	20 fc db	jsr $dbfc		JSR	ATOF			; copy FAC2 to FAC1, get 2nd value in expression
.cfff	20 bf d1	jsr $d1bf		JSR	MAKINT			; evaluate integer expression, no sign check
.d002	a5 65		lda $65			LDA	FAC1+FAC_MANT+3		; get FAC1 mantissa 4
.d004	45 0b		eor $0b			EOR	COUNT			; XOR high byte
.d006	25 08		and $08			AND	ENDCHR			; AND with expression 1 high byte
.d008	45 0b		eor $0b			EOR	COUNT			; XOR result high byte
.d00a	a8		tay			TAY				; save in .Y
.d00b	a5 64		lda $64			LDA	FAC1+FAC_MANT+2		; get FAC1 mantissa 3
.d00d	45 0b		eor $0b			EOR	COUNT			; XOR low byte
.d00f	25 07		and $07			AND	CHARAC			; AND with expression 1 low byte
.d011	45 0b		eor $0b			EOR	COUNT			; XOR result low byte
.d013	4c 91 d3	jmp $d391		JMP	MAKFP			; convert fixed integer .A.Y to float FAC1 and return
.d016					COMPAR
.d016	20 90 cd	jsr $cd90		JSR	LAB_CD90		; type match check, set Cb for string
.d019	b0 13		bcs $d02e		BCS	CMPST			; if string go do string compare
.d01b	a5 6e		lda $6e			LDA	FAC2+FAC_SIGN		; get FAC2 sign (b7)
.d01d	09 7f		ora #$7f		ORA	#$7F			; set all non sign bits
.d01f	25 6a		and $6a			AND	FAC2+FAC_MANT		; and FAC2 mantissa 1 (AND in sign bit)
.d021	85 6a		sta $6a			STA	FAC2+FAC_MANT		; save FAC2 mantissa 1
.d023	a9 69		lda #$69		LDA	#<FAC2			; set pointer low byte to FAC2
.d025	a0 00		ldy #$00		LDY	#>FAC2			; set pointer high byte to FAC2
.d027	20 5b dc	jsr $dc5b		JSR	CMPFAC			; compare FAC1 with (.A.Y)
.d02a	aa		tax			TAX				; copy the result
.d02b	4c 61 d0	jmp $d061		JMP	LAB_D061		; go evaluate result
.d02e					CMPST
.d02e	a9 00		lda #$00		LDA	#$00			; clear byte
.d030	85 0d		sta $0d			STA	VALTYP			; clear data type flag, $FF = string, $00 = numeric
.d032	c6 4d		dec $4d			DEC	OPMASK			; clear < bit in comparison evaluation flag
.d034	20 a6 d6	jsr $d6a6		JSR	LAB_D6A6		; pop string off descriptor stack, or from top of string
.d037	85 61		sta $61			STA	FAC1			; save length
.d039	86 62		stx $62			STX	FAC1+1			; save string pointer low byte
.d03b	84 63		sty $63			STY	FAC1+2			; save string pointer high byte
.d03d	a5 6c		lda $6c			LDA	FAC2+3			; get descriptor pointer low byte
.d03f	a4 6d		ldy $6d			LDY	FAC2+4			; get descriptor pointer high byte
.d041	20 aa d6	jsr $d6aa		JSR	LAB_D6AA		; pop (.Y.A) descriptor off stack or from top of string space
.d044	86 6c		stx $6c			STX	FAC2+3			; save string pointer low byte
.d046	84 6d		sty $6d			STY	FAC2+4			; save string pointer high byte
.d048	aa		tax			TAX				; copy length
.d049	38		sec			SEC				; set carry for subtract
.d04a	e5 61		sbc $61			SBC	FAC1			; subtract string 1 length
.d04c	f0 08		beq $d056		BEQ	LAB_D056		; if str 1 length = string 2 length go compare the strings
.d04e	a9 01		lda #$01		LDA	#$01			; set str 1 length > string 2 length
.d050	90 04		bcc $d056		BCC	LAB_D056		; if so return +1 if otherwise equal
.d052	a6 61		ldx $61			LDX	FAC1			; get string 1 length
.d054	a9 ff		lda #$ff		LDA	#$FF			; set str 1 length < string 2 length
.d056					LAB_D056
.d056	85 66		sta $66			STA	FAC1+5			; save length compare
.d058	a0 ff		ldy #$ff		LDY	#$FF			; set index
.d05a	e8		inx			INX				; adjust for loop
.d05b					LAB_D05B
.d05b	c8		iny			INY				; increment index
.d05c	ca		dex			DEX				; decrement count
.d05d	d0 07		bne $d066		BNE	LAB_D066		; if still bytes to do go compare them
.d05f	a6 66		ldx $66			LDX	FAC1+5			; get length compare back
.d061					LAB_D061
.d061	30 0f		bmi $d072		BMI	LAB_D072		; branch if str 1 < str 2
.d063	18		clc			CLC				; flag str 1 <= str 2
.d064	90 0c		bcc $d072		BCC	LAB_D072		; go evaluate result, branch always
.d066					LAB_D066
.d066	b1 6c		lda ($6c),y		LDA	(FAC2+3),Y		; get string 2 byte
.d068	d1 62		cmp ($62),y		CMP	(FAC1+1),Y		; compare with string 1 byte
.d06a	f0 ef		beq $d05b		BEQ	LAB_D05B		; loop if bytes =
.d06c	a2 ff		ldx #$ff		LDX	#$FF			; set str 1 < string 2
.d06e	b0 02		bcs $d072		BCS	LAB_D072		; branch if so
.d070	a2 01		ldx #$01		LDX	#$01			; set str 1 > string 2
.d072					LAB_D072
.d072	e8		inx			INX				; x = 0, 1 or 2
.d073	8a		txa			TXA				; copy to .A
.d074	2a		rol a			ROL				; * 2 (1, 2 or 4)
.d075	25 12		and $12			AND	TANSGN			; AND with the comparison evaluation flag
.d077	f0 02		beq $d07b		BEQ	LAB_D07B		; branch if 0 (compare is false)
.d079	a9 ff		lda #$ff		LDA	#$FF			; else set result true
.d07b					LAB_D07B
.d07b	4c 3c dc	jmp $dc3c		JMP	INTFP			; save .A as integer byte and return
.d07e					LAB_D07E
.d07e	20 fd ce	jsr $cefd		JSR	COMCHK			; scan for ",", else do syntax error then warm start
.d081					DIM
.d081	aa		tax			TAX				; copy "DIM" flag to .X
.d082	20 90 d0	jsr $d090		JSR	LAB_D090		; search for variable
.d085	20 79 00	jsr $0079		JSR	CHRGOT			; scan memory
.d088	d0 f4		bne $d07e		BNE	LAB_D07E		; scan for "," and loop if not null
.d08a	60		rts			RTS
.d08b					EVLVAR
.d08b	a2 00		ldx #$00		LDX	#$00			; set DIM flag = $00
.d08d	20 79 00	jsr $0079		JSR	CHRGOT			; scan memory, 1st character
.d090					LAB_D090
.d090	86 0c		stx $0c			STX	DIMFLG			; save DIM flag
.d092					LAB_D092
.d092	85 45		sta $45			STA	VARNAM			; save 1st character
.d094	20 79 00	jsr $0079		JSR	CHRGOT			; scan memory
.d097	20 13 d1	jsr $d113		JSR	CHRTST			; check byte, return Cb = 0 if <"A" or >"Z"
.d09a	b0 03		bcs $d09f		BCS	LAB_D09F		; if ok continue
.d09c					LAB_D09C
.d09c	4c 08 cf	jmp $cf08		JMP	LAB_CF08		; else syntax error then warm start
.d09f					LAB_D09F
.d09f	a2 00		ldx #$00		LDX	#$00			; clear 2nd character temp
.d0a1	86 0d		stx $0d			STX	VALTYP			; clear data type flag, $FF = string, $00 = numeric
.d0a3	86 0e		stx $0e			STX	INTFLG			; clear data type flag, $80 = integer, $00 = float
.d0a5	20 73 00	jsr $0073		JSR	CHRGET			; increment and scan memory, 2nd character
.d0a8	90 05		bcc $d0af		BCC	LAB_D0AF		; if character = "0"-"9" (ok) go save 2nd character
.d0aa	20 13 d1	jsr $d113		JSR	CHRTST			; check byte, return Cb = 0 if <"A" or >"Z"
.d0ad	90 0b		bcc $d0ba		BCC	LAB_D0BA		; if <"A" or >"Z" go check if string
.d0af					LAB_D0AF
.d0af	aa		tax			TAX				; copy 2nd character
.d0b0					LAB_D0B0
.d0b0	20 73 00	jsr $0073		JSR	CHRGET			; increment and scan memory, 3rd character
.d0b3	90 fb		bcc $d0b0		BCC	LAB_D0B0		; loop if character = "0"-"9" (ignore)
.d0b5	20 13 d1	jsr $d113		JSR	CHRTST			; check byte, return Cb = 0 if <"A" or >"Z"
.d0b8	b0 f6		bcs $d0b0		BCS	LAB_D0B0		; loop if character = "A"-"Z" (ignore)
.d0ba					LAB_D0BA
.d0ba	c9 24		cmp #$24		CMP	#'$'			; compare with "$"
.d0bc	d0 06		bne $d0c4		BNE	LAB_D0C4		; if not string go check integer
.d0be	a9 ff		lda #$ff		LDA	#$FF			; set data type = string
.d0c0	85 0d		sta $0d			STA	VALTYP			; set data type flag, $FF = string, $00 = numeric
.d0c2	d0 10		bne $d0d4		BNE	LAB_D0D4		; branch always
.d0c4					LAB_D0C4
.d0c4	c9 25		cmp #$25		CMP	#'%'			; compare with "%"
.d0c6	d0 13		bne $d0db		BNE	LAB_D0DB		; if not integer go check for an array
.d0c8	a5 10		lda $10			LDA	SUBFLG			; get subscript/FNx flag
.d0ca	d0 d0		bne $d09c		BNE	LAB_D09C		; if ?? do syntax error then warm start
.d0cc	a9 80		lda #$80		LDA	#$80			; set integer type
.d0ce	85 0e		sta $0e			STA	INTFLG			; set data type = integer
.d0d0	05 45		ora $45			ORA	VARNAM			; OR current variable name first byte
.d0d2	85 45		sta $45			STA	VARNAM			; save current variable name first byte
.d0d4					LAB_D0D4
.d0d4	8a		txa			TXA				; get 2nd character back
.d0d5	09 80		ora #$80		ORA	#$80			; set top bit, indicate string or integer variable
.d0d7	aa		tax			TAX				; copy back to 2nd character temp
.d0d8	20 73 00	jsr $0073		JSR	CHRGET			; increment and scan memory
.d0db					LAB_D0DB
.d0db	86 46		stx $46			STX	VARNAM+1		; save 2nd character
.d0dd	38		sec			SEC				; set carry for subtract
.d0de	05 10		ora $10			ORA	SUBFLG			; or with subscript/FNx flag - or FN name
.d0e0	e9 28		sbc #$28		SBC	#'('			; subtract "("
.d0e2	d0 03		bne $d0e7		BNE	FNDVAR			; if not "(" go find a plain numeric variable
.d0e4	4c d1 d1	jmp $d1d1		JMP	ARY			; else go find, or make, array
.d0e7					FNDVAR
.d0e7	a0 00		ldy #$00		LDY	#$00			; clear .Y
.d0e9	84 10		sty $10			STY	SUBFLG			; clear subscript/FNx flag
.d0eb	a5 2d		lda $2d			LDA	VARTAB			; get start of variables low byte
.d0ed	a6 2e		ldx $2e			LDX	VARTAB+1		; get start of variables high byte
.d0ef					LAB_D0EF
.d0ef	86 60		stx $60			STX	TMPPTR+1		; save search address high byte
.d0f1					LAB_D0F1
.d0f1	85 5f		sta $5f			STA	TMPPTR			; save search address low byte
.d0f3	e4 30		cpx $30			CPX	ARYTAB+1		; compare with end of variables high byte
.d0f5	d0 04		bne $d0fb		BNE	LAB_D0FB		; skip next compare if <>
.d0f7	c5 2f		cmp $2f			CMP	ARYTAB			; compare low address with end of variables low byte
.d0f9	f0 22		beq $d11d		BEQ	MAKVAR			; if not found go make new variable
.d0fb					LAB_D0FB
.d0fb	a5 45		lda $45			LDA	VARNAM			; get 1st character of variable to find
.d0fd	d1 5f		cmp ($5f),y		CMP	(TMPPTR),Y		; compare with variable name 1st character
.d0ff	d0 08		bne $d109		BNE	LAB_D109		; if no match go try the next variable
.d101	a5 46		lda $46			LDA	VARNAM+1		; get 2nd character of variable to find
.d103	c8		iny			INY				; index to point to variable name 2nd character
.d104	d1 5f		cmp ($5f),y		CMP	(TMPPTR),Y		; compare with variable name 2nd character
.d106	f0 7d		beq $d185		BEQ	RETVP			; if match go return the variable
.d108	88		dey			DEY				; else decrement index (now = $00)
.d109					LAB_D109
.d109	18		clc			CLC				; clear carry for add
.d10a	a5 5f		lda $5f			LDA	TMPPTR			; get search address low byte
.d10c	69 07		adc #$07		ADC	#$07			; +7, offset to next variable name
.d10e	90 e1		bcc $d0f1		BCC	LAB_D0F1		; loop if no overflow to high byte
.d110	e8		inx			INX				; else increment high byte
.d111	d0 dc		bne $d0ef		BNE	LAB_D0EF		; loop always, RAM doesn't extend to $FFFF
.d113					CHRTST
.d113	c9 41		cmp #$41		CMP	#'A'			; compare with "A"
.d115	90 05		bcc $d11c		BCC	LAB_D11C		; exit if less
.d117	e9 5b		sbc #$5b		SBC	#'Z'+1			; subtract "Z"+1
.d119	38		sec			SEC				; set carry
.d11a	e9 a5		sbc #$a5		SBC	#$A5			; subtract $A5 (restore byte)
.d11c					LAB_D11C
.d11c	60		rts			RTS
.d11d					MAKVAR
.d11d	68		pla			PLA				; pop return address low byte
.d11e	48		pha			PHA				; push return address low byte
.d11f	c9 2a		cmp #$2a		CMP	#<FACT12+2		; compare with expected calling routine return low byte
.d121	d0 05		bne $d128		BNE	LAB_D128		; if not get variable go create new variable
.d123					LAB_D123
.d123	a9 13		lda #$13		LDA	#<NULLVAR		; set result pointer low byte
.d125	a0 df		ldy #$df		LDY	#>NULLVAR		; set result pointer high byte
.d127	60		rts			RTS
.d128					LAB_D128
.d128	a5 45		lda $45			LDA	VARNAM			; get variable name first character
.d12a	a4 46		ldy $46			LDY	VARNAM+1		; get variable name second character
.d12c	c9 54		cmp #$54		CMP	#'T'			; compare first character with "T"
.d12e	d0 0b		bne $d13b		BNE	LAB_D13B		; if not "T" continue
.d130	c0 c9		cpy #$c9		CPY	#'I'+$80		; compare second character with "I$"
.d132	f0 ef		beq $d123		BEQ	LAB_D123		; if "I$" return null value
.d134	c0 49		cpy #$49		CPY	#'I'			; compare second character with "I"
.d136	d0 03		bne $d13b		BNE	LAB_D13B		; if not "I" continue
.d138					LAB_D138
.d138	4c 08 cf	jmp $cf08		JMP	LAB_CF08		; do syntax error then warm start
.d13b					LAB_D13B
.d13b	c9 53		cmp #$53		CMP	#'S'			; compare first character with "S"
.d13d	d0 04		bne $d143		BNE	LAB_D143		; if not "S" continue
.d13f	c0 54		cpy #$54		CPY	#'T'			; compare second character with "T"
.d141	f0 f5		beq $d138		BEQ	LAB_D138		; if name is "ST" do syntax error
.d143					LAB_D143
.d143	a5 2f		lda $2f			LDA	ARYTAB			; get end of variables low byte
.d145	a4 30		ldy $30			LDY	ARYTAB+1		; get end of variables high byte
.d147	85 5f		sta $5f			STA	TMPPTR			; save old block start low byte
.d149	84 60		sty $60			STY	TMPPTR+1		; save old block start high byte
.d14b	a5 31		lda $31			LDA	STREND			; get end of arrays low byte
.d14d	a4 32		ldy $32			LDY	STREND+1		; get end of arrays high byte
.d14f	85 5a		sta $5a			STA	GEN2PTR			; save old block end low byte
.d151	84 5b		sty $5b			STY	GEN2PTR+1		; save old block end high byte
.d153	18		clc			CLC				; clear carry for add
.d154	69 07		adc #$07		ADC	#$07			; +7, space for one variable
.d156	90 01		bcc $d159		BCC	LAB_D159		; if no overflow skip the high byte increment
.d158	c8		iny			INY				; else increment high byte
.d159					LAB_D159
.d159	85 58		sta $58			STA	GENPTR			; set new block end low byte
.d15b	84 59		sty $59			STY	GENPTR+1		; set new block end high byte
.d15d	20 b8 c3	jsr $c3b8		JSR	MAKSPC			; open up space in memory
.d160	a5 58		lda $58			LDA	GENPTR			; get new start low byte
.d162	a4 59		ldy $59			LDY	GENPTR+1		; get new start high byte (-$100)
.d164	c8		iny			INY				; correct high byte
.d165	85 2f		sta $2f			STA	ARYTAB			; set end of variables low byte
.d167	84 30		sty $30			STY	ARYTAB+1		; set end of variables high byte
.d169	a0 00		ldy #$00		LDY	#$00			; clear index
.d16b	a5 45		lda $45			LDA	VARNAM			; get variable name 1st character
.d16d	91 5f		sta ($5f),y		STA	(TMPPTR),Y		; save variable name 1st character
.d16f	c8		iny			INY				; increment index
.d170	a5 46		lda $46			LDA	VARNAM+1		; get variable name 2nd character
.d172	91 5f		sta ($5f),y		STA	(TMPPTR),Y		; save variable name 2nd character
.d174	a9 00		lda #$00		LDA	#$00			; clear .A
.d176	c8		iny			INY				; increment index
.d177	91 5f		sta ($5f),y		STA	(TMPPTR),Y		; initialise variable byte
.d179	c8		iny			INY				; increment index
.d17a	91 5f		sta ($5f),y		STA	(TMPPTR),Y		; initialise variable byte
.d17c	c8		iny			INY				; increment index
.d17d	91 5f		sta ($5f),y		STA	(TMPPTR),Y		; initialise variable byte
.d17f	c8		iny			INY				; increment index
.d180	91 5f		sta ($5f),y		STA	(TMPPTR),Y		; initialise variable byte
.d182	c8		iny			INY				; increment index
.d183	91 5f		sta ($5f),y		STA	(TMPPTR),Y		; initialise variable byte
.d185					RETVP
.d185	a5 5f		lda $5f			LDA	TMPPTR			; get variable address low byte
.d187	18		clc			CLC				; clear carry for add
.d188	69 02		adc #$02		ADC	#$02			; +2, offset past variable name bytes
.d18a	a4 60		ldy $60			LDY	TMPPTR+1		; get variable address high byte
.d18c	90 01		bcc $d18f		BCC	LAB_D18F		; if no overflow skip the high byte increment
.d18e	c8		iny			INY				; else increment high byte
.d18f					LAB_D18F
.d18f	85 47		sta $47			STA	VARPNT			; save current variable pointer low byte
.d191	84 48		sty $48			STY	VARPNT+1		; save current variable pointer high byte
.d193	60		rts			RTS
.d194					ARYHED
.d194	a5 0b		lda $0b			LDA	COUNT			; get # of dimensions (1, 2 or 3)
.d196	0a		asl a			ASL				; *2 (also clears the carry !)
.d197	69 05		adc #$05		ADC	#$05			; +5 (result is 7, 9 or 11 here)
.d199	65 5f		adc $5f			ADC	TMPPTR			; add array start pointer low byte
.d19b	a4 60		ldy $60			LDY	TMPPTR+1		; get array pointer high byte
.d19d	90 01		bcc $d1a0		BCC	LAB_D1A0		; if no overflow skip the high byte increment
.d19f	c8		iny			INY				; else increment high byte
.d1a0					LAB_D1A0
.d1a0	85 58		sta $58			STA	GENPTR			; save array data pointer low byte
.d1a2	84 59		sty $59			STY	GENPTR+1		; save array data pointer high byte
.d1a4	60		rts			RTS
.d1a5					MAXINT
>d1a5	90 80 00 00 00				.byte	$90,$80,$00,$00,$00	; -32768
.d1aa					INTIDX
.d1aa	20 bf d1	jsr $d1bf		JSR	MAKINT			; evaluate integer expression, no sign check
.d1ad	a5 64		lda $64			LDA	FAC1+3			; get result low byte
.d1af	a4 65		ldy $65			LDY	FAC1+4			; get result high byte
.d1b1	60		rts			RTS
.d1b2					GETSUB
.d1b2	20 73 00	jsr $0073		JSR	CHRGET			; increment and scan memory
.d1b5	20 9e cd	jsr $cd9e		JSR	FRMEVL			; evaluate expression
.d1b8					LAB_D1B8
.d1b8	20 8d cd	jsr $cd8d		JSR	LAB_CD8D		; check if source is numeric, else do type mismatch
.d1bb	a5 66		lda $66			LDA	FAC1+FAC_SIGN		; get FAC1 sign (b7)
.d1bd	30 0d		bmi $d1cc		BMI	LAB_D1CC		; do illegal quantity error if -ve
.d1bf					MAKINT
.d1bf	a5 61		lda $61			LDA	FAC1+FAC_EXPT		; get FAC1 exponent
.d1c1	c9 90		cmp #$90		CMP	#$90			; compare with exponent = 2^16 (n>2^15)
.d1c3	90 09		bcc $d1ce		BCC	LAB_D1CE		; if n<2^16 go convert FAC1 floating to fixed and return
.d1c5	a9 a5		lda #$a5		LDA	#<MAXINT		; set pointer low byte to -32768
.d1c7	a0 d1		ldy #$d1		LDY	#>MAXINT		; set pointer high byte to -32768
.d1c9	20 5b dc	jsr $dc5b		JSR	CMPFAC			; compare FAC1 with (.A.Y)
.d1cc					LAB_D1CC
.d1cc	d0 7a		bne $d248		BNE	ILQUAN			; if <> do illegal quantity error then warm start
.d1ce					LAB_D1CE
.d1ce	4c 9b dc	jmp $dc9b		JMP	FPINT			; convert FAC1 floating to fixed and return
.d1d1					ARY
.d1d1	a5 0c		lda $0c			LDA	DIMFLG			; get DIM flag
.d1d3	05 0e		ora $0e			ORA	INTFLG			; OR with data type flag
.d1d5	48		pha			PHA				; push it
.d1d6	a5 0d		lda $0d			LDA	VALTYP			; get data type flag, $FF = string, $00 = numeric
.d1d8	48		pha			PHA				; push it
.d1d9	a0 00		ldy #$00		LDY	#$00			; clear dimensions count
.d1db					LAB_D1DB
.d1db	98		tya			TYA				; copy dimensions count
.d1dc	48		pha			PHA				; save it
.d1dd	a5 46		lda $46			LDA	VARNAM+1		; get array name 2nd byte
.d1df	48		pha			PHA				; save it
.d1e0	a5 45		lda $45			LDA	VARNAM			; get array name 1st byte
.d1e2	48		pha			PHA				; save it
.d1e3	20 b2 d1	jsr $d1b2		JSR	GETSUB			; evaluate integer expression
.d1e6	68		pla			PLA				; pull array name 1st byte
.d1e7	85 45		sta $45			STA	VARNAM			; restore array name 1st byte
.d1e9	68		pla			PLA				; pull array name 2nd byte
.d1ea	85 46		sta $46			STA	VARNAM+1		; restore array name 2nd byte
.d1ec	68		pla			PLA				; pull dimensions count
.d1ed	a8		tay			TAY				; restore it
.d1ee	ba		tsx			TSX				; copy stack pointer
.d1ef	bd 02 01	lda $0102,x		LDA	STACK+2,X		; get DIM flag
.d1f2	48		pha			PHA				; push it
.d1f3	bd 01 01	lda $0101,x		LDA	STACK+1,X		; get data type flag
.d1f6	48		pha			PHA				; push it
.d1f7	a5 64		lda $64			LDA	FAC1+3			; get this dimension size high byte
.d1f9	9d 02 01	sta $0102,x		STA	STACK+2,X		; stack before flag bytes
.d1fc	a5 65		lda $65			LDA	FAC1+4			; get this dimension size low byte
.d1fe	9d 01 01	sta $0101,x		STA	STACK+1,X		; stack before flag bytes
.d201	c8		iny			INY				; increment dimensions count
.d202	20 79 00	jsr $0079		JSR	CHRGOT			; scan memory
.d205	c9 2c		cmp #$2c		CMP	#','			; compare with ","
.d207	f0 d2		beq $d1db		BEQ	LAB_D1DB		; if found go do next dimension
.d209	84 0b		sty $0b			STY	COUNT			; store dimensions count
.d20b	20 f7 ce	jsr $cef7		JSR	RPACHK			; scan for ")", else do syntax error then warm start
.d20e	68		pla			PLA				; pull data type flag
.d20f	85 0d		sta $0d			STA	VALTYP			; restore data type flag, $FF = string, $00 = numeric
.d211	68		pla			PLA				; pull data type flag
.d212	85 0e		sta $0e			STA	INTFLG			; restore data type flag, $80 = integer, $00 = float
.d214	29 7f		and #$7f		AND	#$7F			; mask dim flag
.d216	85 0c		sta $0c			STA	DIMFLG			; restore DIM flag
.d218	a6 2f		ldx $2f			LDX	ARYTAB			; set end of variables low byte
.d21a	a5 30		lda $30			LDA	ARYTAB+1		; set end of variables high byte
.d21c					LAB_D21C
.d21c	86 5f		stx $5f			STX	TMPPTR			; save as array start pointer low byte
.d21e	85 60		sta $60			STA	TMPPTR+1		; save as array start pointer high byte
.d220	c5 32		cmp $32			CMP	STREND+1		; compare with end of arrays high byte
.d222	d0 04		bne $d228		BNE	LAB_D228		; if not reached array memory end continue searching
.d224	e4 31		cpx $31			CPX	STREND			; else compare with end of arrays low byte
.d226	f0 39		beq $d261		BEQ	ARY6			; go build array if not found
.d228					LAB_D228
.d228	a0 00		ldy #$00		LDY	#$00			; clear index
.d22a	b1 5f		lda ($5f),y		LDA	(TMPPTR),Y		; get array name first byte
.d22c	c8		iny			INY				; increment index to second name byte
.d22d	c5 45		cmp $45			CMP	VARNAM			; compare with this array name first byte
.d22f	d0 06		bne $d237		BNE	LAB_D237		; if no match go try the next array
.d231	a5 46		lda $46			LDA	VARNAM+1		; else get this array name second byte
.d233	d1 5f		cmp ($5f),y		CMP	(TMPPTR),Y		; compare with array name second byte
.d235	f0 16		beq $d24d		BEQ	ARY2			; array found so branch
.d237					LAB_D237
.d237	c8		iny			INY				; increment index
.d238	b1 5f		lda ($5f),y		LDA	(TMPPTR),Y		; get array size low byte
.d23a	18		clc			CLC				; clear carry for add
.d23b	65 5f		adc $5f			ADC	TMPPTR			; add array start pointer low byte
.d23d	aa		tax			TAX				; copy low byte to .X
.d23e	c8		iny			INY				; increment index
.d23f	b1 5f		lda ($5f),y		LDA	(TMPPTR),Y		; get array size high byte
.d241	65 60		adc $60			ADC	TMPPTR+1		; add array memory pointer high byte
.d243	90 d7		bcc $d21c		BCC	LAB_D21C		; if no overflow go check next array
.d245					BADSUB
.d245	a2 12		ldx #$12		LDX	#ER_BADSSCPT		; error $12, bad subscript error
>d247	2c					.byte	$2C			; makes next line BIT $0EA2
.d248					ILQUAN
.d248	a2 0e		ldx #$0e		LDX	#ER_ILLQUAN		; error $0E, illegal quantity error
.d24a					LAB_D24A
.d24a	4c 37 c4	jmp $c437		JMP	ERROR			; do error #.X then warm start
.d24d					ARY2
.d24d	a2 13		ldx #$13		LDX	#ER_REDIMARY		; set error $13, double dimension error
.d24f	a5 0c		lda $0c			LDA	DIMFLG			; get DIM flag
.d251	d0 f7		bne $d24a		BNE	LAB_D24A		; if we are trying to dimension it do error #.X then warm
.d253	20 94 d1	jsr $d194		JSR	ARYHED			; set-up array pointer to first element in array
.d256	a5 0b		lda $0b			LDA	COUNT			; get dimensions count
.d258	a0 04		ldy #$04		LDY	#$04			; set index to array's # of dimensions
.d25a	d1 5f		cmp ($5f),y		CMP	(TMPPTR),Y		; compare with no of dimensions
.d25c	d0 e7		bne $d245		BNE	BADSUB			; if wrong do bad subscript error
.d25e	4c ea d2	jmp $d2ea		JMP	ARY14			; found array so go get element
.d261					ARY6
.d261	20 94 d1	jsr $d194		JSR	ARYHED			; set-up array pointer to first element in array
.d264	20 08 c4	jsr $c408		JSR	RAMSPC			; check available memory, do out of memory error if no room
.d267	a0 00		ldy #$00		LDY	#$00			; clear .Y
.d269	84 72		sty $72			STY	FBUFPT+1		; clear array data size high byte
.d26b	a2 05		ldx #$05		LDX	#$05			; set default element size
.d26d	a5 45		lda $45			LDA	VARNAM			; get variable name 1st byte
.d26f	91 5f		sta ($5f),y		STA	(TMPPTR),Y		; save array name 1st byte
.d271	10 01		bpl $d274		BPL	LAB_D274		; branch if not string or floating point array
.d273	ca		dex			DEX				; decrement element size, $04
.d274					LAB_D274
.d274	c8		iny			INY				; increment index
.d275	a5 46		lda $46			LDA	VARNAM+1		; get variable name 2nd byte
.d277	91 5f		sta ($5f),y		STA	(TMPPTR),Y		; save array name 2nd byte
.d279	10 02		bpl $d27d		BPL	LAB_D27D		; branch if not integer or string
.d27b	ca		dex			DEX				; decrement element size, $03
.d27c	ca		dex			DEX				; decrement element size, $02
.d27d					LAB_D27D
.d27d	86 71		stx $71			STX	FBUFPT			; save element size
.d27f	a5 0b		lda $0b			LDA	COUNT			; get dimensions count
.d281	c8		iny			INY				; increment index ..
.d282	c8		iny			INY				; .. to array  ..
.d283	c8		iny			INY				; .. dimension count
.d284	91 5f		sta ($5f),y		STA	(TMPPTR),Y		; save array dimension count
.d286					LAB_D286
.d286	a2 0b		ldx #$0b		LDX	#$0B			; set default dimension size low byte
.d288	a9 00		lda #$00		LDA	#$00			; set default dimension size high byte
.d28a	24 0c		bit $0c			BIT	DIMFLG			; test DIM flag
.d28c	50 08		bvc $d296		BVC	LAB_D296		; if default to be used don't pull a dimension
.d28e	68		pla			PLA				; pull dimension size low byte
.d28f	18		clc			CLC				; clear carry for add
.d290	69 01		adc #$01		ADC	#$01			; add 1, allow for zeroth element
.d292	aa		tax			TAX				; copy low byte to .X
.d293	68		pla			PLA				; pull dimension size high byte
.d294	69 00		adc #$00		ADC	#$00			; add carry to high byte
.d296					LAB_D296
.d296	c8		iny			INY				; increment index to dimension size high byte
.d297	91 5f		sta ($5f),y		STA	(TMPPTR),Y		; save dimension size high byte
.d299	c8		iny			INY				; increment index to dimension size low byte
.d29a	8a		txa			TXA				; copy dimension size low byte
.d29b	91 5f		sta ($5f),y		STA	(TMPPTR),Y		; save dimension size low byte
.d29d	20 4c d3	jsr $d34c		JSR	M16			; compute array size
.d2a0	86 71		stx $71			STX	FBUFPT			; save result low byte
.d2a2	85 72		sta $72			STA	FBUFPT+1		; save result high byte
.d2a4	a4 22		ldy $22			LDY	INDEX			; restore index
.d2a6	c6 0b		dec $0b			DEC	COUNT			; decrement dimensions count
.d2a8	d0 dc		bne $d286		BNE	LAB_D286		; loop if not all done
.d2aa	65 59		adc $59			ADC	GENPTR+1		; add array data pointer high byte
.d2ac	b0 5d		bcs $d30b		BCS	LAB_D30B		; if overflow do out of memory error then warm start
.d2ae	85 59		sta $59			STA	GENPTR+1		; save array data pointer high byte
.d2b0	a8		tay			TAY				; copy array data pointer high byte
.d2b1	8a		txa			TXA				; copy array size low byte
.d2b2	65 58		adc $58			ADC	GENPTR			; add array data pointer low byte
.d2b4	90 03		bcc $d2b9		BCC	LAB_D2B9		; if no rollover skip the high byte increment
.d2b6	c8		iny			INY				; else increment next array pointer high byte
.d2b7	f0 52		beq $d30b		BEQ	LAB_D30B		; if rolled over do out of memory error then warm start
.d2b9					LAB_D2B9
.d2b9	20 08 c4	jsr $c408		JSR	RAMSPC			; check available memory, do out of memory error if no room
.d2bc	85 31		sta $31			STA	STREND			; set end of arrays low byte
.d2be	84 32		sty $32			STY	STREND+1		; set end of arrays high byte
.d2c0	a9 00		lda #$00		LDA	#$00			; clear .A for array clear
.d2c2	e6 72		inc $72			INC	FBUFPT+1		; increment array size high byte, now block count
.d2c4	a4 71		ldy $71			LDY	FBUFPT			; get array size low byte, now index to block
.d2c6	f0 05		beq $d2cd		BEQ	LAB_D2CD		; if $00 go do the high byte decrement
.d2c8					LAB_D2C8
.d2c8	88		dey			DEY				; decrement index, do 0 to n - 1
.d2c9	91 58		sta ($58),y		STA	(GENPTR),Y		; clear array element byte
.d2cb	d0 fb		bne $d2c8		BNE	LAB_D2C8		; loop until this block done
.d2cd					LAB_D2CD
.d2cd	c6 59		dec $59			DEC	GENPTR+1		; decrement array pointer high byte
.d2cf	c6 72		dec $72			DEC	FBUFPT+1		; decrement block count high byte
.d2d1	d0 f5		bne $d2c8		BNE	LAB_D2C8		; loop until all blocks done
.d2d3	e6 59		inc $59			INC	GENPTR+1		; correct for last loop
.d2d5	38		sec			SEC				; set carry for subtract
.d2d6	a5 31		lda $31			LDA	STREND			; get end of arrays low byte
.d2d8	e5 5f		sbc $5f			SBC	TMPPTR			; subtract array start low byte
.d2da	a0 02		ldy #$02		LDY	#$02			; index to array size low byte
.d2dc	91 5f		sta ($5f),y		STA	(TMPPTR),Y		; save array size low byte
.d2de	a5 32		lda $32			LDA	STREND+1		; get end of arrays high byte
.d2e0	c8		iny			INY				; index to array size high byte
.d2e1	e5 60		sbc $60			SBC	TMPPTR+1		; subtract array start high byte
.d2e3	91 5f		sta ($5f),y		STA	(TMPPTR),Y		; save array size high byte
.d2e5	a5 0c		lda $0c			LDA	DIMFLG			; get default DIM flag
.d2e7	d0 62		bne $d34b		BNE	LAB_D34B		; exit if this was a DIM command
.d2e9	c8		iny			INY				; set index to # of dimensions, the dimension indices
.d2ea					ARY14
.d2ea	b1 5f		lda ($5f),y		LDA	(TMPPTR),Y		; get array's dimension count
.d2ec	85 0b		sta $0b			STA	COUNT			; save it
.d2ee	a9 00		lda #$00		LDA	#$00			; clear byte
.d2f0	85 71		sta $71			STA	FBUFPT			; clear array data pointer low byte
.d2f2					LAB_D2F2
.d2f2	85 72		sta $72			STA	FBUFPT+1		; save array data pointer high byte
.d2f4	c8		iny			INY				; increment index, point to array bound high byte
.d2f5	68		pla			PLA				; pull array index low byte
.d2f6	aa		tax			TAX				; copy to .X
.d2f7	85 64		sta $64			STA	FAC1+FAC_MANT+2		; save index low byte to FAC1 mantissa 3
.d2f9	68		pla			PLA				; pull array index high byte
.d2fa	85 65		sta $65			STA	FAC1+FAC_MANT+3		; save index high byte to FAC1 mantissa 4
.d2fc	d1 5f		cmp ($5f),y		CMP	(TMPPTR),Y		; compare with array bound high byte
.d2fe	90 0e		bcc $d30e		BCC	LAB_D30E		; if within bounds continue
.d300	d0 06		bne $d308		BNE	LAB_D308		; if outside bounds do bad subscript error
.d302	c8		iny			INY				; index to array bound low byte
.d303	8a		txa			TXA				; get array index low byte
.d304	d1 5f		cmp ($5f),y		CMP	(TMPPTR),Y		; compare with array bound low byte
.d306	90 07		bcc $d30f		BCC	LAB_D30F		; if within bounds continue
.d308					LAB_D308
.d308	4c 45 d2	jmp $d245		JMP	BADSUB			; do bad subscript error
.d30b					LAB_D30B
.d30b	4c 35 c4	jmp $c435		JMP	MEMERR			; do out of memory error then warm start
.d30e					LAB_D30E
.d30e	c8		iny			INY				; index to array bound low byte
.d30f					LAB_D30F
.d30f	a5 72		lda $72			LDA	FBUFPT+1		; get array data pointer high byte
.d311	05 71		ora $71			ORA	FBUFPT			; OR with array data pointer low byte
.d313	18		clc			CLC				; clear carry for either add, carry always clear here ??
.d314	f0 0a		beq $d320		BEQ	LAB_D320		; if array data pointer = null skip the multiply
.d316	20 4c d3	jsr $d34c		JSR	M16			; compute array size
.d319	8a		txa			TXA				; get result low byte
.d31a	65 64		adc $64			ADC	FAC1+FAC_MANT+2		; add index low byte from FAC1 mantissa 3
.d31c	aa		tax			TAX				; save result low byte
.d31d	98		tya			TYA				; get result high byte
.d31e	a4 22		ldy $22			LDY	INDEX			; restore index
.d320					LAB_D320
.d320	65 65		adc $65			ADC	FAC1+FAC_MANT+3		; add index high byte from FAC1 mantissa 4
.d322	86 71		stx $71			STX	FBUFPT			; save array data pointer low byte
.d324	c6 0b		dec $0b			DEC	COUNT			; decrement dimensions count
.d326	d0 ca		bne $d2f2		BNE	LAB_D2F2		; loop if dimensions still to do
.d328	85 72		sta $72			STA	FBUFPT+1		; save array data pointer high byte
.d32a	a2 05		ldx #$05		LDX	#$05			; set default element size
.d32c	a5 45		lda $45			LDA	VARNAM			; get variable name 1st byte
.d32e	10 01		bpl $d331		BPL	LAB_D331		; branch if not string or floating point array
.d330	ca		dex			DEX				; decrement element size, $04
.d331					LAB_D331
.d331	a5 46		lda $46			LDA	VARNAM+1		; get variable name 2nd byte
.d333	10 02		bpl $d337		BPL	LAB_D337		; branch if not integer or string
.d335	ca		dex			DEX				; decrement element size, $03
.d336	ca		dex			DEX				; decrement element size, $02
.d337					LAB_D337
.d337	86 28		stx $28			STX	RESHO+2			; save dimension size low byte
.d339	a9 00		lda #$00		LDA	#$00			; clear dimension size high byte
.d33b	20 55 d3	jsr $d355		JSR	LAB_D355		; compute array size
.d33e	8a		txa			TXA				; copy array size low byte
.d33f	65 58		adc $58			ADC	GENPTR			; add array data start pointer low byte
.d341	85 47		sta $47			STA	VARPNT			; save as current variable pointer low byte
.d343	98		tya			TYA				; copy array size high byte
.d344	65 59		adc $59			ADC	GENPTR+1		; add array data start pointer high byte
.d346	85 48		sta $48			STA	VARPNT+1		; save as current variable pointer high byte
.d348	a8		tay			TAY				; copy high byte to .Y
.d349	a5 47		lda $47			LDA	VARPNT			; get current variable pointer low byte
.d34b					LAB_D34B
.d34b	60		rts			RTS
.d34c					M16
.d34c	84 22		sty $22			STY	INDEX			; save index
.d34e	b1 5f		lda ($5f),y		LDA	(TMPPTR),Y		; get dimension size low byte
.d350	85 28		sta $28			STA	RESHO+2			; save dimension size low byte
.d352	88		dey			DEY				; decrement index
.d353	b1 5f		lda ($5f),y		LDA	(TMPPTR),Y		; get dimension size high byte
.d355					LAB_D355
.d355	85 29		sta $29			STA	RESHO+3			; save dimension size high byte
.d357	a9 10		lda #$10		LDA	#$10			; count = $10 (16 bit multiply)
.d359	85 5d		sta $5d			STA	LAB_5D			; save bit count
.d35b	a2 00		ldx #$00		LDX	#$00			; clear result low byte
.d35d	a0 00		ldy #$00		LDY	#$00			; clear result high byte
.d35f					LAB_D35F
.d35f	8a		txa			TXA				; get result low byte
.d360	0a		asl a			ASL				; *2
.d361	aa		tax			TAX				; save result low byte
.d362	98		tya			TYA				; get result high byte
.d363	2a		rol a			ROL				; *2
.d364	a8		tay			TAY				; save result high byte
.d365	b0 a4		bcs $d30b		BCS	LAB_D30B		; if overflow go do "Out of memory" error
.d367	06 71		asl $71			ASL	FBUFPT			; shift element size low byte
.d369	26 72		rol $72			ROL	FBUFPT+1		; shift element size high byte
.d36b	90 0b		bcc $d378		BCC	LAB_D378		; skip add if no carry
.d36d	18		clc			CLC				; else clear carry for add
.d36e	8a		txa			TXA				; get result low byte
.d36f	65 28		adc $28			ADC	RESHO+2			; add dimension size low byte
.d371	aa		tax			TAX				; save result low byte
.d372	98		tya			TYA				; get result high byte
.d373	65 29		adc $29			ADC	RESHO+3			; add dimension size high byte
.d375	a8		tay			TAY				; save result high byte
.d376	b0 93		bcs $d30b		BCS	LAB_D30B		; if overflow go do "Out of memory" error
.d378					LAB_D378
.d378	c6 5d		dec $5d			DEC	LAB_5D			; decrement bit count
.d37a	d0 e3		bne $d35f		BNE	LAB_D35F		; loop until all done
.d37c	60		rts			RTS
.d37d					FRE
.d37d	a5 0d		lda $0d			LDA	VALTYP			; get data type flag, $FF = string, $00 = numeric
.d37f	f0 03		beq $d384		BEQ	LAB_D384		; if numeric don't pop the string
.d381	20 a6 d6	jsr $d6a6		JSR	LAB_D6A6		; pop string off descriptor stack, or from top of string
.d384					LAB_D384
.d384	20 26 d5	jsr $d526		JSR	GRBCOL			; go do garbage collection
.d387	38		sec			SEC				; set carry for subtract
.d388	a5 33		lda $33			LDA	FRETOP			; get bottom of string space low byte
.d38a	e5 31		sbc $31			SBC	STREND			; subtract end of arrays low byte
.d38c	a8		tay			TAY				; copy result to .Y
.d38d	a5 34		lda $34			LDA	FRETOP+1		; get bottom of string space high byte
.d38f	e5 32		sbc $32			SBC	STREND+1		; subtract end of arrays high byte
.d391					MAKFP
.d391	a2 00		ldx #$00		LDX	#$00			; set type = numeric
.d393	86 0d		stx $0d			STX	VALTYP			; clear data type flag, $FF = string, $00 = numeric
.d395	85 62		sta $62			STA	FAC1+FAC_MANT		; save FAC1 mantissa 1
.d397	84 63		sty $63			STY	FAC1+FAC_MANT+1		; save FAC1 mantissa 2
.d399	a2 90		ldx #$90		LDX	#$90			; set exponent=2^16 (integer)
.d39b	4c 44 dc	jmp $dc44		JMP	INTFP1			; set exp = .X, clear FAC1 3 and 4, normalise and return
.d39e					POS
.d39e	38		sec			SEC				; set Cb for read cursor position
.d39f	20 f0 ff	jsr $fff0		JSR	PLOT			; read/set X,Y cursor position
.d3a2					LAB_D3A2
.d3a2	a9 00		lda #$00		LDA	#$00			; clear high byte
.d3a4	f0 eb		beq $d391		BEQ	MAKFP			; convert fixed integer .A.Y to float FAC1, branch always
.d3a6					NODIRM
.d3a6	a6 3a		ldx $3a			LDX	CURLIN+1		; get current line number high byte
.d3a8	e8		inx			INX				; increment it
.d3a9	d0 a0		bne $d34b		BNE	LAB_D34B		; return if not direct mode
.d3ab	a2 15		ldx #$15		LDX	#ER_ILLDIR		; error $15, illegal direct error
>d3ad	2c					.byte	$2C			; makes next line BIT $1BA2
.d3ae					UNDEF
.d3ae	a2 1b		ldx #$1b		LDX	#ER_UNDEFUN		; error $1B, undefined function error
.d3b0	4c 37 c4	jmp $c437		JMP	ERROR			; do error #.X then warm start
.d3b3					DEF
.d3b3	20 e1 d3	jsr $d3e1		JSR	FN			; check FNx syntax
.d3b6	20 a6 d3	jsr $d3a6		JSR	NODIRM			; check not direct, back here if ok
.d3b9	20 fa ce	jsr $cefa		JSR	LPACHK			; scan for "(", else do syntax error then warm start
.d3bc	a9 80		lda #$80		LDA	#$80			; set flag for FNx
.d3be	85 10		sta $10			STA	SUBFLG			; save subscript/FNx flag
.d3c0	20 8b d0	jsr $d08b		JSR	EVLVAR			; get variable address
.d3c3	20 8d cd	jsr $cd8d		JSR	LAB_CD8D		; check if source is numeric, else do type mismatch
.d3c6	20 f7 ce	jsr $cef7		JSR	RPACHK			; scan for ")", else do syntax error then warm start
.d3c9	a9 b2		lda #$b2		LDA	#TK_EQUAL		; get = token
.d3cb	20 ff ce	jsr $ceff		JSR	SYNCHR			; scan for CHR$(.A), else do syntax error then warm start
.d3ce	48		pha			PHA				; push next character
.d3cf	a5 48		lda $48			LDA	VARPNT+1		; get current variable pointer high byte
.d3d1	48		pha			PHA				; push it
.d3d2	a5 47		lda $47			LDA	VARPNT			; get current variable pointer low byte
.d3d4	48		pha			PHA				; push it
.d3d5	a5 7b		lda $7b			LDA	CHRGOT+2		; get BASIC execute pointer high byte
.d3d7	48		pha			PHA				; push it
.d3d8	a5 7a		lda $7a			LDA	CHRGOT+1		; get BASIC execute pointer low byte
.d3da	48		pha			PHA				; push it
.d3db	20 f8 c8	jsr $c8f8		JSR	SKIPST			; perform DATA
.d3de	4c 4f d4	jmp $d44f		JMP	EVFN3			; put execute pointer and variable pointer into function
.d3e1					FN
.d3e1	a9 a5		lda #$a5		LDA	#TK_FN			; set FN token
.d3e3	20 ff ce	jsr $ceff		JSR	SYNCHR			; scan for CHR$(.A), else do syntax error then warm start
.d3e6	09 80		ora #$80		ORA	#$80			; set FN flag bit
.d3e8	85 10		sta $10			STA	SUBFLG			; save FN name
.d3ea	20 92 d0	jsr $d092		JSR	LAB_D092		; search for FN variable
.d3ed	85 4e		sta $4e			STA	DEFPNT			; save function pointer low byte
.d3ef	84 4f		sty $4f			STY	DEFPNT+1		; save function pointer high byte
.d3f1	4c 8d cd	jmp $cd8d		JMP	LAB_CD8D		; check if source is numeric and return, else do type
.d3f4					EVALFN
.d3f4	20 e1 d3	jsr $d3e1		JSR	FN			; check FNx syntax
.d3f7	a5 4f		lda $4f			LDA	DEFPNT+1		; get function pointer high byte
.d3f9	48		pha			PHA				; push it
.d3fa	a5 4e		lda $4e			LDA	DEFPNT			; get function pointer low byte
.d3fc	48		pha			PHA				; push it
.d3fd	20 f1 ce	jsr $cef1		JSR	PAREXP			; evaluate expression within parentheses
.d400	20 8d cd	jsr $cd8d		JSR	LAB_CD8D		; check if source is numeric, else do type mismatch
.d403	68		pla			PLA				; pop function pointer low byte
.d404	85 4e		sta $4e			STA	DEFPNT			; restore it
.d406	68		pla			PLA				; pop function pointer high byte
.d407	85 4f		sta $4f			STA	DEFPNT+1		; restore it
.d409	a0 02		ldy #$02		LDY	#$02			; index to variable pointer high byte
.d40b	b1 4e		lda ($4e),y		LDA	(DEFPNT),Y		; get variable address low byte
.d40d	85 47		sta $47			STA	VARPNT			; save current variable pointer low byte
.d40f	aa		tax			TAX				; copy address low byte
.d410	c8		iny			INY				; index to variable address high byte
.d411	b1 4e		lda ($4e),y		LDA	(DEFPNT),Y		; get variable pointer high byte
.d413	f0 99		beq $d3ae		BEQ	UNDEF			; if high byte zero go do undefined function error
.d415	85 48		sta $48			STA	VARPNT+1		; save current variable pointer high byte
.d417	c8		iny			INY				; index to mantissa 3
.d418					LAB_D418
.d418	b1 47		lda ($47),y		LDA	(VARPNT),Y		; get byte from variable
.d41a	48		pha			PHA				; stack it
.d41b	88		dey			DEY				; decrement index
.d41c	10 fa		bpl $d418		BPL	LAB_D418		; loop until variable stacked
.d41e	a4 48		ldy $48			LDY	VARPNT+1		; get current variable pointer high byte
.d420	20 d4 db	jsr $dbd4		JSR	STORFAC			; pack FAC1 into (.X.Y)
.d423	a5 7b		lda $7b			LDA	CHRGOT+2		; get BASIC execute pointer high byte
.d425	48		pha			PHA				; push it
.d426	a5 7a		lda $7a			LDA	CHRGOT+1		; get BASIC execute pointer low byte
.d428	48		pha			PHA				; push it
.d429	b1 4e		lda ($4e),y		LDA	(DEFPNT),Y		; get function execute pointer low byte
.d42b	85 7a		sta $7a			STA	CHRGOT+1		; save BASIC execute pointer low byte
.d42d	c8		iny			INY				; index to high byte
.d42e	b1 4e		lda ($4e),y		LDA	(DEFPNT),Y		; get function execute pointer high byte
.d430	85 7b		sta $7b			STA	CHRGOT+2		; save BASIC execute pointer high byte
.d432	a5 48		lda $48			LDA	VARPNT+1		; get current variable pointer high byte
.d434	48		pha			PHA				; push it
.d435	a5 47		lda $47			LDA	VARPNT			; get current variable pointer low byte
.d437	48		pha			PHA				; push it
.d438	20 8a cd	jsr $cd8a		JSR	TYPCHK			; evaluate expression and check is numeric, else do
.d43b	68		pla			PLA				; pull variable address low byte
.d43c	85 4e		sta $4e			STA	DEFPNT			; save variable address low byte
.d43e	68		pla			PLA				; pull variable address high byte
.d43f	85 4f		sta $4f			STA	DEFPNT+1		; save variable address high byte
.d441	20 79 00	jsr $0079		JSR	CHRGOT			; scan memory
.d444	f0 03		beq $d449		BEQ	LAB_D449		; if null (should be [EOL] marker) continue
.d446	4c 08 cf	jmp $cf08		JMP	LAB_CF08		; else syntax error then warm start
.d449					LAB_D449
.d449	68		pla			PLA				; pull BASIC execute pointer low byte
.d44a	85 7a		sta $7a			STA	CHRGOT+1		; save BASIC execute pointer low byte
.d44c	68		pla			PLA				; pull BASIC execute pointer high byte
.d44d	85 7b		sta $7b			STA	CHRGOT+2		; save BASIC execute pointer high byte
.d44f					EVFN3
.d44f	a0 00		ldy #$00		LDY	#$00			; clear index
.d451	68		pla			PLA				; pull BASIC execute pointer low byte
.d452	91 4e		sta ($4e),y		STA	(DEFPNT),Y		; save to function
.d454	68		pla			PLA				; pull BASIC execute pointer high byte
.d455	c8		iny			INY				; increment index
.d456	91 4e		sta ($4e),y		STA	(DEFPNT),Y		; save to function
.d458	68		pla			PLA				; pull current variable address low byte
.d459	c8		iny			INY				; increment index
.d45a	91 4e		sta ($4e),y		STA	(DEFPNT),Y		; save to function
.d45c	68		pla			PLA				; pull current variable address high byte
.d45d	c8		iny			INY				; increment index
.d45e	91 4e		sta ($4e),y		STA	(DEFPNT),Y		; save to function
.d460	68		pla			PLA				; pull character following '='
.d461	c8		iny			INY				; increment index
.d462	91 4e		sta ($4e),y		STA	(DEFPNT),Y		; save to function
.d464	60		rts			RTS
.d465					STR
.d465	20 8d cd	jsr $cd8d		JSR	LAB_CD8D		; check if source is numeric, else do type mismatch
.d468	a0 00		ldy #$00		LDY	#$00			; set string index
.d46a	20 df dd	jsr $dddf		JSR	LAB_DDDF		; convert FAC1 to string
.d46d	68		pla			PLA				; dump return address (skip type check)
.d46e	68		pla			PLA				; dump return address (skip type check)
.d46f					LAB_D46F
.d46f	a9 ff		lda #$ff		LDA	#<BASZPT		; set result string low pointer
.d471	a0 00		ldy #$00		LDY	#>BASZPT		; set result string high pointer
.d473	f0 12		beq $d487		BEQ	MAKSTR			; print null terminated string to utility pointer
.d475					ALC1
.d475	a6 64		ldx $64			LDX	FAC1+3			; get descriptor pointer low byte
.d477	a4 65		ldy $65			LDY	FAC1+4			; get descriptor pointer high byte
.d479	86 50		stx $50			STX	DSCPTN			; save descriptor pointer low byte
.d47b	84 51		sty $51			STY	DSCPTN+1		; save descriptor pointer high byte
.d47d					LAB_D47D
.d47d	20 f4 d4	jsr $d4f4		JSR	ALCSPAC			; make space in string memory for string .A long
.d480	86 62		stx $62			STX	FAC1+1			; save string pointer low byte
.d482	84 63		sty $63			STY	FAC1+2			; save string pointer high byte
.d484	85 61		sta $61			STA	FAC1			; save length
.d486	60		rts			RTS
.d487					MAKSTR
.d487	a2 22		ldx #$22		LDX	#$22			; set terminator to "
.d489	86 07		stx $07			STX	CHARAC			; set search character, terminator 1
.d48b	86 08		stx $08			STX	ENDCHR			; set terminator 2
.d48d					LAB_D48D
.d48d	85 6f		sta $6f			STA	ARISGN			; store string start low byte
.d48f	84 70		sty $70			STY	FACOV			; store string start high byte
.d491	85 62		sta $62			STA	FAC1+1			; save string pointer low byte
.d493	84 63		sty $63			STY	FAC1+2			; save string pointer high byte
.d495	a0 ff		ldy #$ff		LDY	#$FF			; set length to -1
.d497					LAB_D497
.d497	c8		iny			INY				; increment length
.d498	b1 6f		lda ($6f),y		LDA	(ARISGN),Y		; get byte from string
.d49a	f0 0c		beq $d4a8		BEQ	LAB_D4A8		; exit loop if null byte [EOS]
.d49c	c5 07		cmp $07			CMP	CHARAC			; compare with search character, terminator 1
.d49e	f0 04		beq $d4a4		BEQ	LAB_D4A4		; branch if terminator
.d4a0	c5 08		cmp $08			CMP	ENDCHR			; compare with terminator 2
.d4a2	d0 f3		bne $d497		BNE	LAB_D497		; loop if not terminator 2
.d4a4					LAB_D4A4
.d4a4	c9 22		cmp #$22		CMP	#$22			; compare with "
.d4a6	f0 01		beq $d4a9		BEQ	LAB_D4A9		; branch if " (carry set if = !)
.d4a8					LAB_D4A8
.d4a8	18		clc			CLC				; clear carry for add (only if [EOL] terminated string)
.d4a9					LAB_D4A9
.d4a9	84 61		sty $61			STY	FAC1+FAC_EXPT		; save length in FAC1 exponent
.d4ab	98		tya			TYA				; copy length to .A
.d4ac	65 6f		adc $6f			ADC	ARISGN			; add string start low byte
.d4ae	85 71		sta $71			STA	FBUFPT			; save string end low byte
.d4b0	a6 70		ldx $70			LDX	FACOV			; get string start high byte
.d4b2	90 01		bcc $d4b5		BCC	LAB_D4B5		; if no low byte overflow skip the high byte increment
.d4b4	e8		inx			INX				; else increment high byte
.d4b5					LAB_D4B5
.d4b5	86 72		stx $72			STX	FBUFPT+1		; save string end high byte
.d4b7	a5 70		lda $70			LDA	FACOV			; get string start high byte
.d4b9	f0 04		beq $d4bf		BEQ	LAB_D4BF		; branch if in utility area
.d4bb	c9 02		cmp #$02		CMP	#$02			; compare with input buffer memory high byte
.d4bd	d0 0b		bne $d4ca		BNE	LAB_D4CA		; branch if not in input buffer memory
.d4bf					LAB_D4BF
.d4bf	98		tya			TYA				; copy length to .A
.d4c0	20 75 d4	jsr $d475		JSR	ALC1			; copy descriptor pointer and make string space .A bytes long
.d4c3	a6 6f		ldx $6f			LDX	ARISGN			; get string start low byte
.d4c5	a4 70		ldy $70			LDY	FACOV			; get string start high byte
.d4c7	20 88 d6	jsr $d688		JSR	LAB_D688		; store string .A bytes long from .X.Y to utility pointer
.d4ca					LAB_D4CA
.d4ca	a6 16		ldx $16			LDX	TEMPPT			; get descriptor stack pointer
.d4cc	e0 22		cpx #$22		CPX	#$22			; compare with max+1
.d4ce	d0 05		bne $d4d5		BNE	LAB_D4D5		; branch if space on string stack
.d4d0	a2 19		ldx #$19		LDX	#ER_FMLA2CPLX		; error $19, formula too complex error
.d4d2					LAB_D4D2
.d4d2	4c 37 c4	jmp $c437		JMP	ERROR			; do error #.X then warm start
.d4d5					LAB_D4D5
.d4d5	a5 61		lda $61			LDA	FAC1			; get string length
.d4d7	95 00		sta $00,x		STA	$00,X			; put on string stack
.d4d9	a5 62		lda $62			LDA	FAC1+1			; get string pointer low byte
.d4db	95 01		sta $01,x		STA	$01,X			; put on string stack
.d4dd	a5 63		lda $63			LDA	FAC1+2			; get string pointer high byte
.d4df	95 02		sta $02,x		STA	$02,X			; put on string stack
.d4e1	a0 00		ldy #$00		LDY	#$00			; clear .Y
.d4e3	86 64		stx $64			STX	FAC1+3			; save string descriptor pointer low byte
.d4e5	84 65		sty $65			STY	FAC1+4			; save string descriptor pointer high byte, always $00
.d4e7	84 70		sty $70			STY	FACOV			; clear FAC1 rounding byte
.d4e9	88		dey			DEY				; .Y = $FF
.d4ea	84 0d		sty $0d			STY	VALTYP			; save data type flag, $FF = string
.d4ec	86 17		stx $17			STX	LASTPT			; save current descriptor stack item pointer low byte
.d4ee	e8		inx			INX				; update stack pointer
.d4ef	e8		inx			INX				; update stack pointer
.d4f0	e8		inx			INX				; update stack pointer
.d4f1	86 16		stx $16			STX	TEMPPT			; set new descriptor stack pointer
.d4f3	60		rts			RTS
.d4f4					ALCSPAC
.d4f4	46 0f		lsr $0f			LSR	GARBFL			; clear garbage collected flag (b7)
.d4f6					LAB_D4F6
.d4f6	48		pha			PHA				; save string length
.d4f7	49 ff		eor #$ff		EOR	#$FF			; complement it
.d4f9	38		sec			SEC				; set carry for subtract, two's complement add
.d4fa	65 33		adc $33			ADC	FRETOP			; add bottom of string space low byte, subtract length
.d4fc	a4 34		ldy $34			LDY	FRETOP+1		; get bottom of string space high byte
.d4fe	b0 01		bcs $d501		BCS	LAB_D501		; skip decrement if no underflow
.d500	88		dey			DEY				; decrement bottom of string space high byte
.d501					LAB_D501
.d501	c4 32		cpy $32			CPY	STREND+1		; compare with end of arrays high byte
.d503	90 11		bcc $d516		BCC	LAB_D516		; do out of memory error if less
.d505	d0 04		bne $d50b		BNE	LAB_D50B		; if not = skip next test
.d507	c5 31		cmp $31			CMP	STREND			; compare with end of arrays low byte
.d509	90 0b		bcc $d516		BCC	LAB_D516		; do out of memory error if less
.d50b					LAB_D50B
.d50b	85 33		sta $33			STA	FRETOP			; save bottom of string space low byte
.d50d	84 34		sty $34			STY	FRETOP+1		; save bottom of string space high byte
.d50f	85 35		sta $35			STA	FRESPC			; save string utility ptr low byte
.d511	84 36		sty $36			STY	FRESPC+1		; save string utility ptr high byte
.d513	aa		tax			TAX				; copy low byte to .X
.d514	68		pla			PLA				; get string length back
.d515	60		rts			RTS
.d516					LAB_D516
.d516	a2 10		ldx #$10		LDX	#$10			; error code $10, out of memory error
.d518	a5 0f		lda $0f			LDA	GARBFL			; get garbage collected flag
.d51a	30 b6		bmi $d4d2		BMI	LAB_D4D2		; if set then do error code .X
.d51c	20 26 d5	jsr $d526		JSR	GRBCOL			; else go do garbage collection
.d51f	a9 80		lda #$80		LDA	#$80			; flag for garbage collected
.d521	85 0f		sta $0f			STA	GARBFL			; set garbage collected flag
.d523	68		pla			PLA				; pull length
.d524	d0 d0		bne $d4f6		BNE	LAB_D4F6		; go try again (loop always, length should never be = $00)
.d526					GRBCOL
.d526	a6 37		ldx $37			LDX	MEMSIZ			; get end of memory low byte
.d528	a5 38		lda $38			LDA	MEMSIZ+1		; get end of memory high byte
.d52a					LAB_D52A
.d52a	86 33		stx $33			STX	FRETOP			; set bottom of string space low byte
.d52c	85 34		sta $34			STA	FRETOP+1		; set bottom of string space high byte
.d52e	a0 00		ldy #$00		LDY	#$00			; clear index
.d530	84 4f		sty $4f			STY	DEFPNT+1		; clear working pointer high byte
.d532	84 4e		sty $4e			STY	DEFPNT			; clear working pointer low byte
.d534	a5 31		lda $31			LDA	STREND			; get end of arrays low byte
.d536	a6 32		ldx $32			LDX	STREND+1		; get end of arrays high byte
.d538	85 5f		sta $5f			STA	TMPPTR			; save as highest uncollected string pointer low byte
.d53a	86 60		stx $60			STX	TMPPTR+1		; save as highest uncollected string pointer high byte
.d53c	a9 19		lda #$19		LDA	#TEMPST			; set descriptor stack pointer
.d53e	a2 00		ldx #$00		LDX	#$00			; clear .X
.d540	85 22		sta $22			STA	INDEX			; save descriptor stack pointer low byte
.d542	86 23		stx $23			STX	INDEX+1			; save descriptor stack pointer high byte ($00)
.d544					LAB_D544
.d544	c5 16		cmp $16			CMP	TEMPPT			; compare with descriptor stack pointer
.d546	f0 05		beq $d54d		BEQ	LAB_D54D		; branch if =
.d548	20 c7 d5	jsr $d5c7		JSR	LAB_D5C7		; check string salvageability
.d54b	f0 f7		beq $d544		BEQ	LAB_D544		; loop always
.d54d					LAB_D54D
.d54d	a9 07		lda #$07		LDA	#$07			; set step size = $07, collecting variables
.d54f	85 53		sta $53			STA	FOUR6			; save garbage collection step size
.d551	a5 2d		lda $2d			LDA	VARTAB			; get start of variables low byte
.d553	a6 2e		ldx $2e			LDX	VARTAB+1		; get start of variables high byte
.d555	85 22		sta $22			STA	INDEX			; save as pointer low byte
.d557	86 23		stx $23			STX	INDEX+1			; save as pointer high byte
.d559					LAB_D559
.d559	e4 30		cpx $30			CPX	ARYTAB+1		; compare end of variables high byte,
.d55b	d0 04		bne $d561		BNE	LAB_D561		; branch if no high byte match
.d55d	c5 2f		cmp $2f			CMP	ARYTAB			; else compare end of variables low byte,
.d55f	f0 05		beq $d566		BEQ	LAB_D566		; branch if = variable memory end
.d561					LAB_D561
.d561	20 bd d5	jsr $d5bd		JSR	GCOL13			; check variable salvageability
.d564	f0 f3		beq $d559		BEQ	LAB_D559		; loop always
.d566					LAB_D566
.d566	85 58		sta $58			STA	GENPTR			; save start of arrays low byte as working pointer
.d568	86 59		stx $59			STX	GENPTR+1		; save start of arrays high byte as working pointer
.d56a	a9 03		lda #$03		LDA	#$03			; set step size, collecting descriptors
.d56c	85 53		sta $53			STA	FOUR6			; save step size
.d56e					LAB_D56E
.d56e	a5 58		lda $58			LDA	GENPTR			; get pointer low byte
.d570	a6 59		ldx $59			LDX	GENPTR+1		; get pointer high byte
.d572					LAB_D572
.d572	e4 32		cpx $32			CPX	STREND+1		; compare with end of arrays high byte
.d574	d0 07		bne $d57d		BNE	LAB_D57D		; branch if not at end
.d576	c5 31		cmp $31			CMP	STREND			; else compare with end of arrays low byte
.d578	d0 03		bne $d57d		BNE	LAB_D57D		; branch if not at end
.d57a	4c 06 d6	jmp $d606		JMP	COLLECT			; collect string, tidy up and exit if at end ??
.d57d					LAB_D57D
.d57d	85 22		sta $22			STA	INDEX			; save pointer low byte
.d57f	86 23		stx $23			STX	INDEX+1			; save pointer high byte
.d581	a0 00		ldy #$00		LDY	#$00			; set index
.d583	b1 22		lda ($22),y		LDA	(INDEX),Y		; get array name first byte
.d585	aa		tax			TAX				; copy it
.d586	c8		iny			INY				; increment index
.d587	b1 22		lda ($22),y		LDA	(INDEX),Y		; get array name second byte
.d589	08		php			PHP				; push the flags
.d58a	c8		iny			INY				; increment index
.d58b	b1 22		lda ($22),y		LDA	(INDEX),Y		; get array size low byte
.d58d	65 58		adc $58			ADC	GENPTR			; add start of this array low byte
.d58f	85 58		sta $58			STA	GENPTR			; save start of next array low byte
.d591	c8		iny			INY				; increment index
.d592	b1 22		lda ($22),y		LDA	(INDEX),Y		; get array size high byte
.d594	65 59		adc $59			ADC	GENPTR+1		; add start of this array high byte
.d596	85 59		sta $59			STA	GENPTR+1		; save start of next array high byte
.d598	28		plp			PLP				; restore the flags
.d599	10 d3		bpl $d56e		BPL	LAB_D56E		; skip if not string array
.d59b	8a		txa			TXA				; get name first byte back
.d59c	30 d0		bmi $d56e		BMI	LAB_D56E		; skip if not string array
.d59e	c8		iny			INY				; increment index
.d59f	b1 22		lda ($22),y		LDA	(INDEX),Y		; get # of dimensions
.d5a1	a0 00		ldy #$00		LDY	#$00			; clear index
.d5a3	0a		asl a			ASL				; *2
.d5a4	69 05		adc #$05		ADC	#$05			; +5 (array header size)
.d5a6	65 22		adc $22			ADC	INDEX			; add pointer low byte
.d5a8	85 22		sta $22			STA	INDEX			; save pointer low byte
.d5aa	90 02		bcc $d5ae		BCC	LAB_D5AE		; if no rollover skip the high byte increment
.d5ac	e6 23		inc $23			INC	INDEX+1			; else increment pointer high byte
.d5ae					LAB_D5AE
.d5ae	a6 23		ldx $23			LDX	INDEX+1			; get pointer high byte
.d5b0					LAB_D5B0
.d5b0	e4 59		cpx $59			CPX	GENPTR+1		; compare pointer high byte with end of this array high byte
.d5b2	d0 04		bne $d5b8		BNE	LAB_D5B8		; branch if not there yet
.d5b4	c5 58		cmp $58			CMP	GENPTR			; compare pointer low byte with end of this array low byte
.d5b6	f0 ba		beq $d572		BEQ	LAB_D572		; if at end of this array go check next array
.d5b8					LAB_D5B8
.d5b8	20 c7 d5	jsr $d5c7		JSR	LAB_D5C7		; check string salvageability
.d5bb	f0 f3		beq $d5b0		BEQ	LAB_D5B0		; loop
.d5bd					GCOL13
.d5bd	b1 22		lda ($22),y		LDA	(INDEX),Y		; get variable name first byte
.d5bf	30 35		bmi $d5f6		BMI	LAB_D5F6		; add step and exit if not string
.d5c1	c8		iny			INY				; increment index
.d5c2	b1 22		lda ($22),y		LDA	(INDEX),Y		; get variable name second byte
.d5c4	10 30		bpl $d5f6		BPL	LAB_D5F6		; add step and exit if not string
.d5c6	c8		iny			INY				; increment index
.d5c7					LAB_D5C7
.d5c7	b1 22		lda ($22),y		LDA	(INDEX),Y		; get string length
.d5c9	f0 2b		beq $d5f6		BEQ	LAB_D5F6		; add step and exit if null string
.d5cb	c8		iny			INY				; increment index
.d5cc	b1 22		lda ($22),y		LDA	(INDEX),Y		; get string pointer low byte
.d5ce	aa		tax			TAX				; copy to .X
.d5cf	c8		iny			INY				; increment index
.d5d0	b1 22		lda ($22),y		LDA	(INDEX),Y		; get string pointer high byte
.d5d2	c5 34		cmp $34			CMP	FRETOP+1		; compare string pointer high byte with bottom of string
.d5d4	90 06		bcc $d5dc		BCC	LAB_D5DC		; if bottom of string space greater go test against highest
.d5d6	d0 1e		bne $d5f6		BNE	LAB_D5F6		; if bottom of string space less string has been collected
.d5d8	e4 33		cpx $33			CPX	FRETOP			; compare string pointer low byte with bottom of string
.d5da	b0 1a		bcs $d5f6		BCS	LAB_D5F6		; if bottom of string space less string has been collected
.d5dc					LAB_D5DC
.d5dc	c5 60		cmp $60			CMP	TMPPTR+1		; compare string pointer high byte with highest uncollected
.d5de	90 16		bcc $d5f6		BCC	LAB_D5F6		; if highest uncollected string is greater then go update
.d5e0	d0 04		bne $d5e6		BNE	LAB_D5E6		; if highest uncollected string is less then go set this
.d5e2	e4 5f		cpx $5f			CPX	TMPPTR			; compare string pointer low byte with highest uncollected
.d5e4	90 10		bcc $d5f6		BCC	LAB_D5F6		; if highest uncollected string is greater then go update
.d5e6					LAB_D5E6
.d5e6	86 5f		stx $5f			STX	TMPPTR			; save string pointer low byte as highest uncollected string
.d5e8	85 60		sta $60			STA	TMPPTR+1		; save string pointer high byte as highest uncollected
.d5ea	a5 22		lda $22			LDA	INDEX			; get descriptor pointer low byte
.d5ec	a6 23		ldx $23			LDX	INDEX+1			; get descriptor pointer high byte
.d5ee	85 4e		sta $4e			STA	DEFPNT			; save working pointer high byte
.d5f0	86 4f		stx $4f			STX	DEFPNT+1		; save working pointer low byte
.d5f2	a5 53		lda $53			LDA	FOUR6			; get step size
.d5f4	85 55		sta $55			STA	JMPER+1			; copy step size
.d5f6					LAB_D5F6
.d5f6	a5 53		lda $53			LDA	FOUR6			; get step size
.d5f8	18		clc			CLC				; clear carry for add
.d5f9	65 22		adc $22			ADC	INDEX			; add pointer low byte
.d5fb	85 22		sta $22			STA	INDEX			; save pointer low byte
.d5fd	90 02		bcc $d601		BCC	LAB_D601		; if no rollover skip the high byte increment
.d5ff	e6 23		inc $23			INC	INDEX+1			; else increment pointer high byte
.d601					LAB_D601
.d601	a6 23		ldx $23			LDX	INDEX+1			; get pointer high byte
.d603	a0 00		ldy #$00		LDY	#$00			; flag not moved
.d605	60		rts			RTS
.d606					COLLECT
.d606	a5 4f		lda $4f			LDA	DEFPNT+1		; get working pointer low byte
.d608	05 4e		ora $4e			ORA	DEFPNT			; OR working pointer high byte
.d60a	f0 f5		beq $d601		BEQ	LAB_D601		; exit if nothing to collect
.d60c	a5 55		lda $55			LDA	JMPER+1			; get copied step size
.d60e	29 04		and #$04		AND	#$04			; mask step size, $04 for variables, $00 for array or stack
.d610	4a		lsr a			LSR				; >> 1
.d611	a8		tay			TAY				; copy to index
.d612	85 55		sta $55			STA	JMPER+1			; save offset to descriptor start
.d614	b1 4e		lda ($4e),y		LDA	(DEFPNT),Y		; get string length low byte
.d616	65 5f		adc $5f			ADC	TMPPTR			; add string start low byte
.d618	85 5a		sta $5a			STA	GEN2PTR			; set block end low byte
.d61a	a5 60		lda $60			LDA	TMPPTR+1		; get string start high byte
.d61c	69 00		adc #$00		ADC	#$00			; add carry
.d61e	85 5b		sta $5b			STA	GEN2PTR+1		; set block end high byte
.d620	a5 33		lda $33			LDA	FRETOP			; get bottom of string space low byte
.d622	a6 34		ldx $34			LDX	FRETOP+1		; get bottom of string space high byte
.d624	85 58		sta $58			STA	GENPTR			; save destination end low byte
.d626	86 59		stx $59			STX	GENPTR+1		; save destination end high byte
.d628	20 bf c3	jsr $c3bf		JSR	MOVEBL			; open up space in memory, don't set array end. this
.d62b	a4 55		ldy $55			LDY	JMPER+1			; restore offset to descriptor start
.d62d	c8		iny			INY				; increment index to string pointer low byte
.d62e	a5 58		lda $58			LDA	GENPTR			; get new string pointer low byte
.d630	91 4e		sta ($4e),y		STA	(DEFPNT),Y		; save new string pointer low byte
.d632	aa		tax			TAX				; copy string pointer low byte
.d633	e6 59		inc $59			INC	GENPTR+1		; increment new string pointer high byte
.d635	a5 59		lda $59			LDA	GENPTR+1		; get new string pointer high byte
.d637	c8		iny			INY				; increment index to string pointer high byte
.d638	91 4e		sta ($4e),y		STA	(DEFPNT),Y		; save new string pointer high byte
.d63a	4c 2a d5	jmp $d52a		JMP	LAB_D52A		; re-run routine from last ending, .X.A holds new bottom
.d63d					ADDSTR
.d63d	a5 65		lda $65			LDA	FAC1+4			; get descriptor pointer high byte
.d63f	48		pha			PHA				; put on stack
.d640	a5 64		lda $64			LDA	FAC1+3			; get descriptor pointer low byte
.d642	48		pha			PHA				; put on stack
.d643	20 83 ce	jsr $ce83		JSR	EVAL			; get value from line
.d646	20 8f cd	jsr $cd8f		JSR	LAB_CD8F		; check if source is string, else do type mismatch
.d649	68		pla			PLA				; get descriptor pointer low byte back
.d64a	85 6f		sta $6f			STA	ARISGN			; set pointer low byte
.d64c	68		pla			PLA				; get descriptor pointer high byte back
.d64d	85 70		sta $70			STA	FACOV			; set pointer high byte
.d64f	a0 00		ldy #$00		LDY	#$00			; clear index
.d651	b1 6f		lda ($6f),y		LDA	(ARISGN),Y		; get length of first string from descriptor
.d653	18		clc			CLC				; clear carry for add
.d654	71 64		adc ($64),y		ADC	(FAC1+3),Y		; add length of second string
.d656	90 05		bcc $d65d		BCC	LAB_D65D		; if no overflow continue
.d658	a2 17		ldx #$17		LDX	#ER_STR2LONG		; else error $17, string too long error
.d65a	4c 37 c4	jmp $c437		JMP	ERROR			; do error #.X then warm start
.d65d					LAB_D65D
.d65d	20 75 d4	jsr $d475		JSR	ALC1			; copy descriptor pointer and make string space .A bytes long
.d660	20 7a d6	jsr $d67a		JSR	XFERSTR			; copy string from descriptor to utility pointer
.d663	a5 50		lda $50			LDA	DSCPTN			; get descriptor pointer low byte
.d665	a4 51		ldy $51			LDY	DSCPTN+1		; get descriptor pointer high byte
.d667	20 aa d6	jsr $d6aa		JSR	LAB_D6AA		; pop (.Y.A) descriptor off stack or from top of string space
.d66a	20 8c d6	jsr $d68c		JSR	LAB_D68C		; store string from pointer to utility pointer
.d66d	a5 6f		lda $6f			LDA	ARISGN			; get descriptor pointer low byte
.d66f	a4 70		ldy $70			LDY	FACOV			; get descriptor pointer high byte
.d671	20 aa d6	jsr $d6aa		JSR	LAB_D6AA		; pop (.Y.A) descriptor off stack or from top of string space
.d674	20 ca d4	jsr $d4ca		JSR	LAB_D4CA		; check space on descriptor stack then put string address
.d677	4c b8 cd	jmp $cdb8		JMP	LAB_CDB8		; continue evaluation
.d67a					XFERSTR
.d67a	a0 00		ldy #$00		LDY	#$00			; clear index
.d67c	b1 6f		lda ($6f),y		LDA	(ARISGN),Y		; get string length
.d67e	48		pha			PHA				; save it
.d67f	c8		iny			INY				; increment index
.d680	b1 6f		lda ($6f),y		LDA	(ARISGN),Y		; get string pointer low byte
.d682	aa		tax			TAX				; copy to .X
.d683	c8		iny			INY				; increment index
.d684	b1 6f		lda ($6f),y		LDA	(ARISGN),Y		; get string pointer high byte
.d686	a8		tay			TAY				; copy to .Y
.d687	68		pla			PLA				; get length back
.d688					LAB_D688
.d688	86 22		stx $22			STX	INDEX			; save string pointer low byte
.d68a	84 23		sty $23			STY	INDEX+1			; save string pointer high byte
.d68c					LAB_D68C
.d68c	a8		tay			TAY				; copy length as index
.d68d	f0 0a		beq $d699		BEQ	LAB_D699		; branch if null string
.d68f	48		pha			PHA				; save length
.d690					LAB_D690
.d690	88		dey			DEY				; decrement length/index
.d691	b1 22		lda ($22),y		LDA	(INDEX),Y		; get byte from string
.d693	91 35		sta ($35),y		STA	(FRESPC),Y		; save byte to destination
.d695	98		tya			TYA				; copy length/index
.d696	d0 f8		bne $d690		BNE	LAB_D690		; loop if not all done yet
.d698	68		pla			PLA				; restore length
.d699					LAB_D699
.d699	18		clc			CLC				; clear carry for add
.d69a	65 35		adc $35			ADC	FRESPC			; add string utility ptr low byte
.d69c	85 35		sta $35			STA	FRESPC			; save string utility ptr low byte
.d69e	90 02		bcc $d6a2		BCC	LAB_D6A2		; if no rollover skip the high byte increment
.d6a0	e6 36		inc $36			INC	FRESPC+1		; increment string utility ptr high byte
.d6a2					LAB_D6A2
.d6a2	60		rts			RTS
.d6a3					DELST
.d6a3	20 8f cd	jsr $cd8f		JSR	LAB_CD8F		; check if source is string, else do type mismatch
.d6a6					LAB_D6A6
.d6a6	a5 64		lda $64			LDA	FAC1+3			; get descriptor pointer low byte
.d6a8	a4 65		ldy $65			LDY	FAC1+4			; get descriptor pointer high byte
.d6aa					LAB_D6AA
.d6aa	85 22		sta $22			STA	INDEX			; save string pointer low byte
.d6ac	84 23		sty $23			STY	INDEX+1			; save string pointer high byte
.d6ae	20 db d6	jsr $d6db		JSR	DELTSD			; clean descriptor stack, .Y.A = pointer
.d6b1	08		php			PHP				; save status flags
.d6b2	a0 00		ldy #$00		LDY	#$00			; clear index
.d6b4	b1 22		lda ($22),y		LDA	(INDEX),Y		; get length from string descriptor
.d6b6	48		pha			PHA				; put on stack
.d6b7	c8		iny			INY				; increment index
.d6b8	b1 22		lda ($22),y		LDA	(INDEX),Y		; get string pointer low byte from descriptor
.d6ba	aa		tax			TAX				; copy to .X
.d6bb	c8		iny			INY				; increment index
.d6bc	b1 22		lda ($22),y		LDA	(INDEX),Y		; get string pointer high byte from descriptor
.d6be	a8		tay			TAY				; copy to .Y
.d6bf	68		pla			PLA				; get string length back
.d6c0	28		plp			PLP				; restore status
.d6c1	d0 13		bne $d6d6		BNE	LAB_D6D6		; branch if pointer <> last_sl,last_sh
.d6c3	c4 34		cpy $34			CPY	FRETOP+1		; compare with bottom of string space high byte
.d6c5	d0 0f		bne $d6d6		BNE	LAB_D6D6		; branch if <>
.d6c7	e4 33		cpx $33			CPX	FRETOP			; else compare with bottom of string space low byte
.d6c9	d0 0b		bne $d6d6		BNE	LAB_D6D6		; branch if <>
.d6cb	48		pha			PHA				; save string length
.d6cc	18		clc			CLC				; clear carry for add
.d6cd	65 33		adc $33			ADC	FRETOP			; add bottom of string space low byte
.d6cf	85 33		sta $33			STA	FRETOP			; set bottom of string space low byte
.d6d1	90 02		bcc $d6d5		BCC	LAB_D6D5		; skip increment if no overflow
.d6d3	e6 34		inc $34			INC	FRETOP+1		; increment bottom of string space high byte
.d6d5					LAB_D6D5
.d6d5	68		pla			PLA				; restore string length
.d6d6					LAB_D6D6
.d6d6	86 22		stx $22			STX	INDEX			; save string pointer low byte
.d6d8	84 23		sty $23			STY	INDEX+1			; save string pointer high byte
.d6da	60		rts			RTS
.d6db					DELTSD
.d6db	c4 18		cpy $18			CPY	LASTPT+1		; compare high byte with current descriptor stack item
.d6dd	d0 0c		bne $d6eb		BNE	LAB_D6EB		; exit if <>
.d6df	c5 17		cmp $17			CMP	LASTPT			; compare low byte with current descriptor stack item
.d6e1	d0 08		bne $d6eb		BNE	LAB_D6EB		; exit if <>
.d6e3	85 16		sta $16			STA	TEMPPT			; set descriptor stack pointer
.d6e5	e9 03		sbc #$03		SBC	#$03			; update last string pointer low byte
.d6e7	85 17		sta $17			STA	LASTPT			; save current descriptor stack item pointer low byte
.d6e9	a0 00		ldy #$00		LDY	#$00			; clear high byte
.d6eb					LAB_D6EB
.d6eb	60		rts			RTS
.d6ec					CHR
.d6ec	20 a1 d7	jsr $d7a1		JSR	LAB_D7A1		; evaluate byte expression, result in .X
.d6ef	8a		txa			TXA				; copy to .A
.d6f0	48		pha			PHA				; save character
.d6f1	a9 01		lda #$01		LDA	#$01			; string is single byte
.d6f3	20 7d d4	jsr $d47d		JSR	LAB_D47D		; make string space A bytes long
.d6f6	68		pla			PLA				; get character back
.d6f7	a0 00		ldy #$00		LDY	#$00			; clear index
.d6f9	91 62		sta ($62),y		STA	(FAC1+1),Y		; save byte in string - byte IS string!
.d6fb	68		pla			PLA				; dump return address (skip type check)
.d6fc	68		pla			PLA				; dump return address (skip type check)
.d6fd	4c ca d4	jmp $d4ca		JMP	LAB_D4CA		; check space on descriptor stack then put string address
.d700					LEFT
.d700	20 61 d7	jsr $d761		JSR	FINLMR			; pull string data and byte parameter from stack
.d703	d1 50		cmp ($50),y		CMP	(DSCPTN),Y		; compare byte parameter with string length
.d705	98		tya			TYA				; clear .A
.d706					LAB_D706
.d706	90 04		bcc $d70c		BCC	LAB_D70C		; branch if string length > byte parameter
.d708	b1 50		lda ($50),y		LDA	(DSCPTN),Y		; else make parameter = length
.d70a	aa		tax			TAX				; copy to byte parameter copy
.d70b	98		tya			TYA				; clear string start offset
.d70c					LAB_D70C
.d70c	48		pha			PHA				; save string start offset
.d70d					LAB_D70D
.d70d	8a		txa			TXA				; copy byte parameter (or string length if <)
.d70e					LAB_D70E
.d70e	48		pha			PHA				; save string length
.d70f	20 7d d4	jsr $d47d		JSR	LAB_D47D		; make string space .A bytes long
.d712	a5 50		lda $50			LDA	DSCPTN			; get descriptor pointer low byte
.d714	a4 51		ldy $51			LDY	DSCPTN+1		; get descriptor pointer high byte
.d716	20 aa d6	jsr $d6aa		JSR	LAB_D6AA		; pop (.Y.A) descriptor off stack or from top of string space
.d719	68		pla			PLA				; get string length back
.d71a	a8		tay			TAY				; copy length to .Y
.d71b	68		pla			PLA				; get string start offset back
.d71c	18		clc			CLC				; clear carry for add
.d71d	65 22		adc $22			ADC	INDEX			; add start offset to string start pointer low byte
.d71f	85 22		sta $22			STA	INDEX			; save string start pointer low byte
.d721	90 02		bcc $d725		BCC	LAB_D725		; if no overflow skip the high byte increment
.d723	e6 23		inc $23			INC	INDEX+1			; else increment string start pointer high byte
.d725					LAB_D725
.d725	98		tya			TYA				; copy length to .A
.d726	20 8c d6	jsr $d68c		JSR	LAB_D68C		; store string from pointer to utility pointer
.d729	4c ca d4	jmp $d4ca		JMP	LAB_D4CA		; check space on descriptor stack then put string address
.d72c					RIGHT
.d72c	20 61 d7	jsr $d761		JSR	FINLMR			; pull string data and byte parameter from stack
.d72f	18		clc			CLC				; clear carry for add - 1
.d730	f1 50		sbc ($50),y		SBC	(DSCPTN),Y		; subtract string length
.d732	49 ff		eor #$ff		EOR	#$FF			; invert it (.A=LEN(expression$)-l)
.d734	4c 06 d7	jmp $d706		JMP	LAB_D706		; go do rest of LEFT$()
.d737					MID
.d737	a9 ff		lda #$ff		LDA	#$FF			; set default length = 255
.d739	85 65		sta $65			STA	FAC1+4			; save default length
.d73b	20 79 00	jsr $0079		JSR	CHRGOT			; scan memory
.d73e	c9 29		cmp #$29		CMP	#')'			; compare with ")"
.d740	f0 06		beq $d748		BEQ	LAB_D748		; branch if = ")" (skip second byte get)
.d742	20 fd ce	jsr $cefd		JSR	COMCHK			; scan for ",", else do syntax error then warm start
.d745	20 9e d7	jsr $d79e		JSR	LAB_D79E		; get byte parameter
.d748					LAB_D748
.d748	20 61 d7	jsr $d761		JSR	FINLMR			; pull string data and byte parameter from stack
.d74b	f0 4b		beq $d798		BEQ	LAB_D798		; if null do illegal quantity error then warm start
.d74d	ca		dex			DEX				; decrement start index
.d74e	8a		txa			TXA				; copy to .A
.d74f	48		pha			PHA				; save string start offset
.d750	18		clc			CLC				; clear carry for sub - 1
.d751	a2 00		ldx #$00		LDX	#$00			; clear output string length
.d753	f1 50		sbc ($50),y		SBC	(DSCPTN),Y		; subtract string length
.d755	b0 b6		bcs $d70d		BCS	LAB_D70D		; if start>string length go do null string
.d757	49 ff		eor #$ff		EOR	#$FF			; complement -length
.d759	c5 65		cmp $65			CMP	FAC1+4			; compare byte parameter
.d75b	90 b1		bcc $d70e		BCC	LAB_D70E		; if length>remaining string go do RIGHT$
.d75d	a5 65		lda $65			LDA	FAC1+4			; get length byte
.d75f	b0 ad		bcs $d70e		BCS	LAB_D70E		; go do string copy, branch always
.d761					FINLMR
.d761	20 f7 ce	jsr $cef7		JSR	RPACHK			; scan for ")", else do syntax error then warm start
.d764	68		pla			PLA				; pull return address low byte
.d765	a8		tay			TAY				; save return address low byte
.d766	68		pla			PLA				; pull return address high byte
.d767	85 55		sta $55			STA	JMPER+1			; save return address high byte
.d769	68		pla			PLA				; dump call to function vector low byte
.d76a	68		pla			PLA				; dump call to function vector high byte
.d76b	68		pla			PLA				; pull byte parameter
.d76c	aa		tax			TAX				; copy byte parameter to .X
.d76d	68		pla			PLA				; pull string pointer low byte
.d76e	85 50		sta $50			STA	DSCPTN			; save it
.d770	68		pla			PLA				; pull string pointer high byte
.d771	85 51		sta $51			STA	DSCPTN+1		; save it
.d773	a5 55		lda $55			LDA	JMPER+1			; get return address high byte
.d775	48		pha			PHA				; back on stack
.d776	98		tya			TYA				; get return address low byte
.d777	48		pha			PHA				; back on stack
.d778	a0 00		ldy #$00		LDY	#$00			; clear index
.d77a	8a		txa			TXA				; copy byte parameter
.d77b	60		rts			RTS
.d77c					LEN
.d77c	20 82 d7	jsr $d782		JSR	GSINFO			; evaluate string, get length in .A (and .Y)
.d77f	4c a2 d3	jmp $d3a2		JMP	LAB_D3A2		; convert .Y to byte in FAC1 and return
.d782					GSINFO
.d782	20 a3 d6	jsr $d6a3		JSR	DELST			; evaluate string
.d785	a2 00		ldx #$00		LDX	#$00			; set data type = numeric
.d787	86 0d		stx $0d			STX	VALTYP			; clear data type flag, $FF = string, $00 = numeric
.d789	a8		tay			TAY				; copy length to .Y
.d78a	60		rts			RTS
.d78b					ASC
.d78b	20 82 d7	jsr $d782		JSR	GSINFO			; evaluate string, get length in .A (and .Y)
.d78e	f0 08		beq $d798		BEQ	LAB_D798		; if null do illegal quantity error then warm start
.d790	a0 00		ldy #$00		LDY	#$00			; set index to first character
.d792	b1 22		lda ($22),y		LDA	(INDEX),Y		; get byte
.d794	a8		tay			TAY				; copy to .Y
.d795	4c a2 d3	jmp $d3a2		JMP	LAB_D3A2		; convert .Y to byte in FAC1 and return
.d798					LAB_D798
.d798	4c 48 d2	jmp $d248		JMP	ILQUAN			; do illegal quantity error then warm start
.d79b					GETBYT
.d79b	20 73 00	jsr $0073		JSR	CHRGET			; increment and scan memory
.d79e					LAB_D79E
.d79e	20 8a cd	jsr $cd8a		JSR	TYPCHK			; evaluate expression and check is numeric, else do
.d7a1					LAB_D7A1
.d7a1	20 b8 d1	jsr $d1b8		JSR	LAB_D1B8		; evaluate integer expression, sign check
.d7a4	a6 64		ldx $64			LDX	FAC1+FAC_MANT+2		; get FAC1 mantissa 3
.d7a6	d0 f0		bne $d798		BNE	LAB_D798		; if not null do illegal quantity error then warm start
.d7a8	a6 65		ldx $65			LDX	FAC1+FAC_MANT+3		; get FAC1 mantissa 4
.d7aa	4c 79 00	jmp $0079		JMP	CHRGOT			; scan memory and return
.d7ad					VAL
.d7ad	20 82 d7	jsr $d782		JSR	GSINFO			; evaluate string, get length in .A (and .Y)
.d7b0	d0 03		bne $d7b5		BNE	LAB_D7B5		; if not a null string go evaluate it
.d7b2	4c f7 d8	jmp $d8f7		JMP	ZERFAC			; clear FAC1 exponent and sign and return
.d7b5					LAB_D7B5
.d7b5	a6 7a		ldx $7a			LDX	CHRGOT+1		; get BASIC execute pointer low byte
.d7b7	a4 7b		ldy $7b			LDY	CHRGOT+2		; get BASIC execute pointer high byte
.d7b9	86 71		stx $71			STX	FBUFPT			; save BASIC execute pointer low byte
.d7bb	84 72		sty $72			STY	FBUFPT+1		; save BASIC execute pointer high byte
.d7bd	a6 22		ldx $22			LDX	INDEX			; get string pointer low byte
.d7bf	86 7a		stx $7a			STX	CHRGOT+1		; save BASIC execute pointer low byte
.d7c1	18		clc			CLC				; clear carry for add
.d7c2	65 22		adc $22			ADC	INDEX			; add string length
.d7c4	85 24		sta $24			STA	INDEX+2			; save string end low byte
.d7c6	a6 23		ldx $23			LDX	INDEX+1			; get string pointer high byte
.d7c8	86 7b		stx $7b			STX	CHRGOT+2		; save BASIC execute pointer high byte
.d7ca	90 01		bcc $d7cd		BCC	LAB_D7CD		; if no rollover skip the high byte increment
.d7cc	e8		inx			INX				; increment string end high byte
.d7cd					LAB_D7CD
.d7cd	86 25		stx $25			STX	INDEX+3			; save string end high byte
.d7cf	a0 00		ldy #$00		LDY	#$00			; set index to $00
.d7d1	b1 24		lda ($24),y		LDA	(INDEX+2),Y		; get string end byte
.d7d3	48		pha			PHA				; push it
.d7d4	98		tya			TYA				; clear .A
.d7d5	91 24		sta ($24),y		STA	(INDEX+2),Y		; terminate string with $00
.d7d7	20 79 00	jsr $0079		JSR	CHRGOT			; scan memory
.d7da	20 f3 dc	jsr $dcf3		JSR	ASCFLT			; get FAC1 from string
.d7dd	68		pla			PLA				; restore string end byte
.d7de	a0 00		ldy #$00		LDY	#$00			; clear index
.d7e0	91 24		sta ($24),y		STA	(INDEX+2),Y		; put string end byte back
.d7e2					LAB_D7E2
.d7e2	a6 71		ldx $71			LDX	FBUFPT			; get BASIC execute pointer low byte back
.d7e4	a4 72		ldy $72			LDY	FBUFPT+1		; get BASIC execute pointer high byte back
.d7e6	86 7a		stx $7a			STX	CHRGOT+1		; save BASIC execute pointer low byte
.d7e8	84 7b		sty $7b			STY	CHRGOT+2		; save BASIC execute pointer high byte
.d7ea	60		rts			RTS
.d7eb					GETAD
.d7eb	20 8a cd	jsr $cd8a		JSR	TYPCHK			; evaluate expression and check is numeric, else do
.d7ee	20 f7 d7	jsr $d7f7		JSR	MAKADR			; convert FAC1 to integer in temporary integer
.d7f1					LAB_D7F1
.d7f1	20 fd ce	jsr $cefd		JSR	COMCHK			; scan for ",", else do syntax error then warm start
.d7f4	4c 9e d7	jmp $d79e		JMP	LAB_D79E		; get byte parameter and return
.d7f7					MAKADR
.d7f7	a5 66		lda $66			LDA	FAC1+FAC_SIGN		; get FAC1 sign
.d7f9	30 9d		bmi $d798		BMI	LAB_D798		; if -ve do illegal quantity error then warm start
.d7fb	a5 61		lda $61			LDA	FAC1+FAC_EXPT		; get FAC1 exponent
.d7fd	c9 91		cmp #$91		CMP	#$91			; compare with exponent = 2^16
.d7ff	b0 97		bcs $d798		BCS	LAB_D798		; if >= do illegal quantity error then warm start
.d801	20 9b dc	jsr $dc9b		JSR	FPINT			; convert FAC1 floating to fixed
.d804	a5 64		lda $64			LDA	FAC1+FAC_MANT+2		; get FAC1 mantissa 3
.d806	a4 65		ldy $65			LDY	FAC1+FAC_MANT+3		; get FAC1 mantissa 4
.d808	84 14		sty $14			STY	LINNUM			; save temporary integer low byte
.d80a	85 15		sta $15			STA	LINNUM+1		; save temporary integer high byte
.d80c	60		rts			RTS
.d80d					PEEK
.d80d	a5 15		lda $15			LDA	LINNUM+1		; get line number high byte
.d80f	48		pha			PHA				; save line number high byte
.d810	a5 14		lda $14			LDA	LINNUM			; get line number low byte
.d812	48		pha			PHA				; save line number low byte
.d813	20 f7 d7	jsr $d7f7		JSR	MAKADR			; convert FAC1 to integer in temporary integer
.d816	a0 00		ldy #$00		LDY	#$00			; clear index
.d818	b1 14		lda ($14),y		LDA	(LINNUM),Y		; read byte
.d81a	a8		tay			TAY				; copy byte to .A
.d81b	68		pla			PLA				; pull byte
.d81c	85 14		sta $14			STA	LINNUM			; restore line number low byte
.d81e	68		pla			PLA				; pull byte
.d81f	85 15		sta $15			STA	LINNUM+1		; restore line number high byte
.d821	4c a2 d3	jmp $d3a2		JMP	LAB_D3A2		; convert .Y to byte in FAC1 and return
.d824					POKE
.d824	20 eb d7	jsr $d7eb		JSR	GETAD			; get parameters for POKE/WAIT
.d827	8a		txa			TXA				; copy byte to .A
.d828	a0 00		ldy #$00		LDY	#$00			; clear index
.d82a	91 14		sta ($14),y		STA	(LINNUM),Y		; write byte
.d82c	60		rts			RTS
.d82d					WAIT
.d82d	20 eb d7	jsr $d7eb		JSR	GETAD			; get parameters for POKE/WAIT
.d830	86 49		stx $49			STX	FORPNT			; save byte
.d832	a2 00		ldx #$00		LDX	#$00			; clear mask
.d834	20 79 00	jsr $0079		JSR	CHRGOT			; scan memory
.d837	f0 03		beq $d83c		BEQ	LAB_D83C		; skip if no third argument
.d839	20 f1 d7	jsr $d7f1		JSR	LAB_D7F1		; scan for "," and get byte, else syntax error then
.d83c					LAB_D83C
.d83c	86 4a		stx $4a			STX	FORPNT+1		; save XOR argument
.d83e	a0 00		ldy #$00		LDY	#$00			; clear index
.d840					LAB_D840
.d840	b1 14		lda ($14),y		LDA	(LINNUM),Y		; get byte via temporary integer	(address)
.d842	45 4a		eor $4a			EOR	FORPNT+1		; XOR with second argument		(mask)
.d844	25 49		and $49			AND	FORPNT			; AND with first argument		(byte)
.d846	f0 f8		beq $d840		BEQ	LAB_D840		; loop if result is zero
.d848					LAB_D848
.d848	60		rts			RTS
.d849					ADD05
.d849	a9 11		lda #$11		LDA	#<FLP05			; set 0.5 pointer low byte
.d84b	a0 df		ldy #$df		LDY	#>FLP05			; set 0.5 pointer high byte
.d84d	4c 67 d8	jmp $d867		JMP	LAPLUS			; add (.A.Y) to FAC1
.d850					LAMIN
.d850	20 8c da	jsr $da8c		JSR	LODARG			; unpack memory (.A.Y) into FAC2
.d853					SUB
.d853	a5 66		lda $66			LDA	FAC1+FAC_SIGN		; get FAC1 sign (b7)
.d855	49 ff		eor #$ff		EOR	#$FF			; complement it
.d857	85 66		sta $66			STA	FAC1+FAC_SIGN		; save FAC1 sign (b7)
.d859	45 6e		eor $6e			EOR	FAC2+FAC_SIGN		; XOR with FAC2 sign (b7)
.d85b	85 6f		sta $6f			STA	ARISGN			; save sign compare (FAC1 XOR FAC2)
.d85d	a5 61		lda $61			LDA	FAC1+FAC_EXPT		; get FAC1 exponent
.d85f	4c 6a d8	jmp $d86a		JMP	PLUS			; add FAC2 to FAC1 and return
.d862					PLUS1
.d862	20 99 d9	jsr $d999		JSR	LAB_D999		; shift FAC.X .A times right (>8 shifts)
.d865	90 3c		bcc $d8a3		BCC	LAB_D8A3		; go subtract the mantissas, branch always
.d867					LAPLUS
.d867	20 8c da	jsr $da8c		JSR	LODARG			; unpack memory (.A.Y) into FAC2
.d86a					PLUS
.d86a	d0 03		bne $d86f		BNE	LAB_D86F		; if FAC1 is not zero go do the add
.d86c	4c fc db	jmp $dbfc		JMP	ATOF			; FAC1 was zero so copy FAC2 to FAC1 and return
.d86f					LAB_D86F
.d86f	a6 70		ldx $70			LDX	FACOV			; get FAC1 rounding byte
.d871	86 56		stx $56			STX	JMPER+2			; save as FAC2 rounding byte
.d873	a2 69		ldx #$69		LDX	#FAC2			; set index to FAC2 exponent address
.d875	a5 69		lda $69			LDA	FAC2			; get FAC2 exponent
.d877					LAB_D877
.d877	a8		tay			TAY				; copy exponent
.d878	f0 ce		beq $d848		BEQ	LAB_D848		; exit if zero
.d87a	38		sec			SEC				; set carry for subtract
.d87b	e5 61		sbc $61			SBC	FAC1+FAC_EXPT		; subtract FAC1 exponent
.d87d	f0 24		beq $d8a3		BEQ	LAB_D8A3		; if equal go add mantissas
.d87f	90 12		bcc $d893		BCC	LAB_D893		; if FAC2 < FAC1 then go shift FAC2 right
.d881	84 61		sty $61			STY	FAC1+FAC_EXPT		; save FAC1 exponent
.d883	a4 6e		ldy $6e			LDY	FAC2+FAC_SIGN		; get FAC2 sign (b7)
.d885	84 66		sty $66			STY	FAC1+FAC_SIGN		; save FAC1 sign (b7)
.d887	49 ff		eor #$ff		EOR	#$FF			; complement .A
.d889	69 00		adc #$00		ADC	#$00			; +1, two's complement, carry is set
.d88b	a0 00		ldy #$00		LDY	#$00			; clear .Y
.d88d	84 56		sty $56			STY	JMPER+2			; clear FAC2 rounding byte
.d88f	a2 61		ldx #$61		LDX	#FAC1+FAC_EXPT		; set index to FAC1 exponent address
.d891	d0 04		bne $d897		BNE	LAB_D897		; branch always
.d893					LAB_D893
.d893	a0 00		ldy #$00		LDY	#$00			; clear .Y
.d895	84 70		sty $70			STY	FACOV			; clear FAC1 rounding byte
.d897					LAB_D897
.d897	c9 f9		cmp #$f9		CMP	#$F9			; compare exponent diff with $F9
.d899	30 c7		bmi $d862		BMI	PLUS1			; branch if range $79-$F8
.d89b	a8		tay			TAY				; copy exponent difference to .Y
.d89c	a5 70		lda $70			LDA	FACOV			; get FAC1 rounding byte
.d89e	56 01		lsr $01,x		LSR	FAC_MANT,X		; shift FAC.X mantissa 1
.d8a0	20 b0 d9	jsr $d9b0		JSR	LAB_D9B0		; shift FAC.X .Y times right
.d8a3					LAB_D8A3
.d8a3	24 6f		bit $6f			BIT	ARISGN			; test sign compare (FAC1 XOR FAC2)
.d8a5	10 57		bpl $d8fe		BPL	NORMLZ			; if = add FAC2 mantissa to FAC1 mantissa and return
.d8a7	a0 61		ldy #$61		LDY	#FAC1+FAC_EXPT		; set index to FAC1 exponent address
.d8a9	e0 69		cpx #$69		CPX	#FAC2+FAC_EXPT		; compare .X to FAC2 exponent address
.d8ab	f0 02		beq $d8af		BEQ	LAB_D8AF		; branch if =
.d8ad	a0 69		ldy #$69		LDY	#FAC2+FAC_EXPT		; else set index to FAC2 exponent address
.d8af					LAB_D8AF
.d8af	38		sec			SEC				; set carry for subtract
.d8b0	49 ff		eor #$ff		EOR	#$FF			; ones' complement .A
.d8b2	65 56		adc $56			ADC	JMPER+2			; add FAC2 rounding byte
.d8b4	85 70		sta $70			STA	FACOV			; save FAC1 rounding byte
.d8b6	b9 04 00	lda $0004,y		LDA	FAC_MANT+3,Y		; get FAC.Y mantissa 4
.d8b9	f5 04		sbc $04,x		SBC	FAC_MANT+3,X		; subtract FAC.X mantissa 4
.d8bb	85 65		sta $65			STA	FAC1+FAC_MANT+3		; save FAC1 mantissa 4
.d8bd	b9 03 00	lda $0003,y		LDA	FAC_MANT+2,Y		; get FAC.Y mantissa 3
.d8c0	f5 03		sbc $03,x		SBC	FAC_MANT+2,X		; subtract FAC.X mantissa 3
.d8c2	85 64		sta $64			STA	FAC1+FAC_MANT+2		; save FAC1 mantissa 3
.d8c4	b9 02 00	lda $0002,y		LDA	FAC_MANT+1,Y		; get FAC.Y mantissa 2
.d8c7	f5 02		sbc $02,x		SBC	FAC_MANT+1,X		; subtract FAC.X mantissa 2
.d8c9	85 63		sta $63			STA	FAC1+FAC_MANT+1		; save FAC1 mantissa 2
.d8cb	b9 01 00	lda $0001,y		LDA	FAC_MANT,Y		; get FAC.Y mantissa 1
.d8ce	f5 01		sbc $01,x		SBC	FAC_MANT,X		; subtract FAC.X mantissa 1
.d8d0	85 62		sta $62			STA	FAC1+FAC_MANT		; save FAC1 mantissa 1
.d8d2					LAB_D8D2
.d8d2	b0 03		bcs $d8d7		BCS	LAB_D8D7		; branch if number is +ve
.d8d4	20 47 d9	jsr $d947		JSR	COMFAC			; negate FAC1
.d8d7					LAB_D8D7
.d8d7	a0 00		ldy #$00		LDY	#$00			; clear .Y
.d8d9	98		tya			TYA				; clear .A
.d8da	18		clc			CLC				; clear carry for add
.d8db					LAB_D8DB
.d8db	a6 62		ldx $62			LDX	FAC1+FAC_MANT		; get FAC1 mantissa 1
.d8dd	d0 4a		bne $d929		BNE	LAB_D929		; if not zero normalise FAC1
.d8df	a6 63		ldx $63			LDX	FAC1+FAC_MANT+1		; get FAC1 mantissa 2
.d8e1	86 62		stx $62			STX	FAC1+FAC_MANT		; save FAC1 mantissa 1
.d8e3	a6 64		ldx $64			LDX	FAC1+FAC_MANT+2		; get FAC1 mantissa 3
.d8e5	86 63		stx $63			STX	FAC1+FAC_MANT+1		; save FAC1 mantissa 2
.d8e7	a6 65		ldx $65			LDX	FAC1+FAC_MANT+3		; get FAC1 mantissa 4
.d8e9	86 64		stx $64			STX	FAC1+FAC_MANT+2		; save FAC1 mantissa 3
.d8eb	a6 70		ldx $70			LDX	FACOV			; get FAC1 rounding byte
.d8ed	86 65		stx $65			STX	FAC1+FAC_MANT+3		; save FAC1 mantissa 4
.d8ef	84 70		sty $70			STY	FACOV			; clear FAC1 rounding byte
.d8f1	69 08		adc #$08		ADC	#$08			; add x to exponent offset
.d8f3	c9 20		cmp #$20		CMP	#$20			; compare with $20, max offset, all bits would be = 0
.d8f5	d0 e4		bne $d8db		BNE	LAB_D8DB		; loop if not max
.d8f7					ZERFAC
.d8f7	a9 00		lda #$00		LDA	#$00			; clear .A
.d8f9					LAB_D8F9
.d8f9	85 61		sta $61			STA	FAC1+FAC_EXPT		; set FAC1 exponent
.d8fb					LAB_D8FB
.d8fb	85 66		sta $66			STA	FAC1+FAC_SIGN		; save FAC1 sign (b7)
.d8fd	60		rts			RTS
.d8fe					NORMLZ
.d8fe	65 56		adc $56			ADC	JMPER+2			; add FAC2 rounding byte
.d900	85 70		sta $70			STA	FACOV			; save FAC1 rounding byte
.d902	a5 65		lda $65			LDA	FAC1+FAC_MANT+3		; get FAC1 mantissa 4
.d904	65 6d		adc $6d			ADC	FAC2+FAC_MANT+3		; add FAC2 mantissa 4
.d906	85 65		sta $65			STA	FAC1+FAC_MANT+3		; save FAC1 mantissa 4
.d908	a5 64		lda $64			LDA	FAC1+FAC_MANT+2		; get FAC1 mantissa 3
.d90a	65 6c		adc $6c			ADC	FAC2+FAC_MANT+2		; add FAC2 mantissa 3
.d90c	85 64		sta $64			STA	FAC1+FAC_MANT+2		; save FAC1 mantissa 3
.d90e	a5 63		lda $63			LDA	FAC1+FAC_MANT+1		; get FAC1 mantissa 2
.d910	65 6b		adc $6b			ADC	FAC2+FAC_MANT+1		; add FAC2 mantissa 2
.d912	85 63		sta $63			STA	FAC1+FAC_MANT+1		; save FAC1 mantissa 2
.d914	a5 62		lda $62			LDA	FAC1+FAC_MANT		; get FAC1 mantissa 1
.d916	65 6a		adc $6a			ADC	FAC2+FAC_MANT		; add FAC2 mantissa 1
.d918	85 62		sta $62			STA	FAC1+FAC_MANT		; save FAC1 mantissa 1
.d91a	4c 36 d9	jmp $d936		JMP	LAB_D936		; test and normalise FAC1 for Cb=0/1
.d91d					LAB_D91D
.d91d	69 01		adc #$01		ADC	#$01			; add 1 to exponent offset
.d91f	06 70		asl $70			ASL	FACOV			; shift FAC1 rounding byte
.d921	26 65		rol $65			ROL	FAC1+FAC_MANT+3		; shift FAC1 mantissa 4
.d923	26 64		rol $64			ROL	FAC1+FAC_MANT+2		; shift FAC1 mantissa 3
.d925	26 63		rol $63			ROL	FAC1+FAC_MANT+1		; shift FAC1 mantissa 2
.d927	26 62		rol $62			ROL	FAC1+FAC_MANT		; shift FAC1 mantissa 1
.d929					LAB_D929
.d929	10 f2		bpl $d91d		BPL	LAB_D91D		; loop if not normalised
.d92b	38		sec			SEC				; set carry for subtract
.d92c	e5 61		sbc $61			SBC	FAC1+FAC_EXPT		; subtract FAC1 exponent
.d92e	b0 c7		bcs $d8f7		BCS	ZERFAC			; branch if underflow (set result = $0)
.d930	49 ff		eor #$ff		EOR	#$FF			; complement exponent
.d932	69 01		adc #$01		ADC	#$01			; +1 (two's complement)
.d934	85 61		sta $61			STA	FAC1+FAC_EXPT		; save FAC1 exponent
.d936					LAB_D936
.d936	90 0e		bcc $d946		BCC	LAB_D946		; exit if no overflow
.d938					LAB_D938
.d938	e6 61		inc $61			INC	FAC1+FAC_EXPT		; increment FAC1 exponent
.d93a	f0 42		beq $d97e		BEQ	OVERFL			; if zero do overflow error then warm start
.d93c	66 62		ror $62			ROR	FAC1+FAC_MANT		; shift FAC1 mantissa 1
.d93e	66 63		ror $63			ROR	FAC1+FAC_MANT+1		; shift FAC1 mantissa 2
.d940	66 64		ror $64			ROR	FAC1+FAC_MANT+2		; shift FAC1 mantissa 3
.d942	66 65		ror $65			ROR	FAC1+FAC_MANT+3		; shift FAC1 mantissa 4
.d944	66 70		ror $70			ROR	FACOV			; shift FAC1 rounding byte
.d946					LAB_D946
.d946	60		rts			RTS
.d947					COMFAC
.d947	a5 66		lda $66			LDA	FAC1+FAC_SIGN		; get FAC1 sign (b7)
.d949	49 ff		eor #$ff		EOR	#$FF			; complement it
.d94b	85 66		sta $66			STA	FAC1+FAC_SIGN		; save FAC1 sign (b7)
.d94d					LAB_D94D
.d94d	a5 62		lda $62			LDA	FAC1+FAC_MANT		; get FAC1 mantissa 1
.d94f	49 ff		eor #$ff		EOR	#$FF			; complement it
.d951	85 62		sta $62			STA	FAC1+FAC_MANT		; save FAC1 mantissa 1
.d953	a5 63		lda $63			LDA	FAC1+FAC_MANT+1		; get FAC1 mantissa 2
.d955	49 ff		eor #$ff		EOR	#$FF			; complement it
.d957	85 63		sta $63			STA	FAC1+FAC_MANT+1		; save FAC1 mantissa 2
.d959	a5 64		lda $64			LDA	FAC1+FAC_MANT+2		; get FAC1 mantissa 3
.d95b	49 ff		eor #$ff		EOR	#$FF			; complement it
.d95d	85 64		sta $64			STA	FAC1+FAC_MANT+2		; save FAC1 mantissa 3
.d95f	a5 65		lda $65			LDA	FAC1+FAC_MANT+3		; get FAC1 mantissa 4
.d961	49 ff		eor #$ff		EOR	#$FF			; complement it
.d963	85 65		sta $65			STA	FAC1+FAC_MANT+3		; save FAC1 mantissa 4
.d965	a5 70		lda $70			LDA	FACOV			; get FAC1 rounding byte
.d967	49 ff		eor #$ff		EOR	#$FF			; complement it
.d969	85 70		sta $70			STA	FACOV			; save FAC1 rounding byte
.d96b	e6 70		inc $70			INC	FACOV			; increment FAC1 rounding byte
.d96d	d0 0e		bne $d97d		BNE	LAB_D97D		; exit if no overflow
.d96f					LAB_D96F
.d96f	e6 65		inc $65			INC	FAC1+FAC_MANT+3		; increment FAC1 mantissa 4
.d971	d0 0a		bne $d97d		BNE	LAB_D97D		; finished if no rollover
.d973	e6 64		inc $64			INC	FAC1+FAC_MANT+2		; increment FAC1 mantissa 3
.d975	d0 06		bne $d97d		BNE	LAB_D97D		; finished if no rollover
.d977	e6 63		inc $63			INC	FAC1+FAC_MANT+1		; increment FAC1 mantissa 2
.d979	d0 02		bne $d97d		BNE	LAB_D97D		; finished if no rollover
.d97b	e6 62		inc $62			INC	FAC1+FAC_MANT		; increment FAC1 mantissa 1
.d97d					LAB_D97D
.d97d	60		rts			RTS
.d97e					OVERFL
.d97e	a2 0f		ldx #$0f		LDX	#ER_OVFLOW		; error $0F, overflow error
.d980	4c 37 c4	jmp $c437		JMP	ERROR			; do error #.X then warm start
.d983					ASRRES
.d983	a2 25		ldx #$25		LDX	#$25			; set offset to FACtemp
.d985					LAB_D985
.d985	b4 04		ldy $04,x		LDY	FAC_MANT+3,X		; get FAC.X mantissa 4
.d987	84 70		sty $70			STY	FACOV			; save as FAC1 rounding byte
.d989	b4 03		ldy $03,x		LDY	FAC_MANT+2,X		; get FAC.X mantissa 3
.d98b	94 04		sty $04,x		STY	FAC_MANT+3,X		; save FAC.X mantissa 4
.d98d	b4 02		ldy $02,x		LDY	FAC_MANT+1,X		; get FAC.X mantissa 2
.d98f	94 03		sty $03,x		STY	FAC_MANT+2,X		; save FAC.X mantissa 3
.d991	b4 01		ldy $01,x		LDY	FAC_MANT,X		; get FAC.X mantissa 1
.d993	94 02		sty $02,x		STY	FAC_MANT+1,X		; save FAC.X mantissa 2
.d995	a4 68		ldy $68			LDY	BITS			; get FAC1 overflow byte
.d997	94 01		sty $01,x		STY	FAC_MANT,X		; save FAC.X mantissa 1
.d999					LAB_D999
.d999	69 08		adc #$08		ADC	#$08			; add 8 to shift count
.d99b	30 e8		bmi $d985		BMI	LAB_D985		; go do 8 shift if still -ve
.d99d	f0 e6		beq $d985		BEQ	LAB_D985		; go do 8 shift if zero
.d99f	e9 08		sbc #$08		SBC	#$08			; else subtract 8 again
.d9a1	a8		tay			TAY				; save count to .Y
.d9a2	a5 70		lda $70			LDA	FACOV			; get FAC1 rounding byte
.d9a4	b0 14		bcs $d9ba		BCS	LAB_D9BA		;.
.d9a6					LAB_D9A6
.d9a6	16 01		asl $01,x		ASL	FAC_MANT,X		; shift FAC.X mantissa 1
.d9a8	90 02		bcc $d9ac		BCC	LAB_D9AC		; branch if +ve
.d9aa	f6 01		inc $01,x		INC	FAC_MANT,X		; this sets b7 eventually
.d9ac					LAB_D9AC
.d9ac	76 01		ror $01,x		ROR	FAC_MANT,X		; shift FAC.X mantissa 1 (correct for ASL)
.d9ae	76 01		ror $01,x		ROR	FAC_MANT,X		; shift FAC.X mantissa 1 (put carry in b7)
.d9b0					LAB_D9B0
.d9b0	76 02		ror $02,x		ROR	FAC_MANT+1,X		; shift FAC.X mantissa 2
.d9b2	76 03		ror $03,x		ROR	FAC_MANT+2,X		; shift FAC.X mantissa 3
.d9b4	76 04		ror $04,x		ROR	FAC_MANT+3,X		; shift FAC.X mantissa 4
.d9b6	6a		ror a			ROR				; shift FAC.X rounding byte
.d9b7	c8		iny			INY				; increment exponent diff
.d9b8	d0 ec		bne $d9a6		BNE	LAB_D9A6		; branch if range adjust not complete
.d9ba					LAB_D9BA
.d9ba	18		clc			CLC				; just clear it
.d9bb	60		rts			RTS
.d9bc					FPC1
>d9bc	81 00 00 00 00				.byte	$81,$00,$00,$00,$00	; 1
.d9c1					LOGCON
>d9c1	03					.byte	$03			; series counter
>d9c2	7f 5e 56 cb 79				.byte	$7F,$5E,$56,$CB,$79	; 0.43425	LOG10(e)
>d9c7	80 13 9b 0b 64				.byte	$80,$13,$9B,$0B,$64	; 0.57658
>d9cc	80 76 38 93 16				.byte	$80,$76,$38,$93,$16	; 0.9618
>d9d1	82 38 aa 3b 20				.byte	$82,$38,$AA,$3B,$20	; 2.88539	2/LOG(2)
.d9d6					LAB_D9D6
>d9d6	80 35 04 f3 34				.byte	$80,$35,$04,$F3,$34	; 0.70711	1/root 2
.d9db					LAB_D9DB
>d9db	81 35 04 f3 34				.byte	$81,$35,$04,$F3,$34	; 1.41421	root 2
.d9e0					LAB_D9E0
>d9e0	80 80 00 00 00				.byte	$80,$80,$00,$00,$00	; -0.5		1/2
.d9e5					LAB_D9E5
>d9e5	80 31 72 17 f8				.byte	$80,$31,$72,$17,$F8	; 0.69315	LOG(2)
.d9ea					LOG
.d9ea	20 2b dc	jsr $dc2b		JSR	SGNFAC			; test sign and zero
.d9ed	f0 02		beq $d9f1		BEQ	LAB_D9F1		; if zero do illegal quantity error then warm start
.d9ef	10 03		bpl $d9f4		BPL	LAB_D9F4		; skip error if +ve
.d9f1					LAB_D9F1
.d9f1	4c 48 d2	jmp $d248		JMP	ILQUAN			; do illegal quantity error then warm start
.d9f4					LAB_D9F4
.d9f4	a5 61		lda $61			LDA	FAC1+FAC_EXPT		; get FAC1 exponent
.d9f6	e9 7f		sbc #$7f		SBC	#$7F			; normalise it
.d9f8	48		pha			PHA				; save it
.d9f9	a9 80		lda #$80		LDA	#$80			; set exponent to zero
.d9fb	85 61		sta $61			STA	FAC1+FAC_EXPT		; save FAC1 exponent
.d9fd	a9 d6		lda #$d6		LDA	#<LAB_D9D6		; pointer to 1/root 2 low byte
.d9ff	a0 d9		ldy #$d9		LDY	#>LAB_D9D6		; pointer to 1/root 2 high byte
.da01	20 67 d8	jsr $d867		JSR	LAPLUS			; add (.A.Y) to FAC1 (1/root2)
.da04	a9 db		lda #$db		LDA	#<LAB_D9DB		; pointer to root 2 low byte
.da06	a0 d9		ldy #$d9		LDY	#>LAB_D9DB		; pointer to root 2 high byte
.da08	20 0f db	jsr $db0f		JSR	LADIV			; convert .A.Y and do (.A.Y)/FAC1 (root2/(x+(1/root2)))
.da0b	a9 bc		lda #$bc		LDA	#<FPC1			; pointer to 1 low byte
.da0d	a0 d9		ldy #$d9		LDY	#>FPC1			; pointer to 1 high byte
.da0f	20 50 d8	jsr $d850		JSR	LAMIN			; subtract FAC1 ((root2/(x+(1/root2)))-1) from (.A.Y)
.da12	a9 c1		lda #$c1		LDA	#<LOGCON		; pointer to series for LOG(n) low byte
.da14	a0 d9		ldy #$d9		LDY	#>LOGCON		; pointer to series for LOG(n) high byte
.da16	20 40 e0	jsr $e040		JSR	SEREVL			; ^2 then series evaluation
.da19	a9 e0		lda #$e0		LDA	#<LAB_D9E0		; pointer to -0.5 low byte
.da1b	a0 d9		ldy #$d9		LDY	#>LAB_D9E0		; pointer to -0.5 high byte
.da1d	20 67 d8	jsr $d867		JSR	LAPLUS			; add (.A.Y) to FAC1
.da20	68		pla			PLA				; restore FAC1 exponent
.da21	20 7e dd	jsr $dd7e		JSR	ASCI8			; evaluate new ASCII digit
.da24	a9 e5		lda #$e5		LDA	#<LAB_D9E5		; pointer to LOG(2) low byte
.da26	a0 d9		ldy #$d9		LDY	#>LAB_D9E5		; pointer to LOG(2) high byte
.da28					TIMES
.da28	20 8c da	jsr $da8c		JSR	LODARG			; unpack memory (.A.Y) into FAC2
.da2b					MULT
.da2b	d0 03		bne $da30		BNE	LAB_DA30		; multiply FAC1 by FAC2 ??
.da2d	4c 8b da	jmp $da8b		JMP	LAB_DA8B		; exit if zero
.da30					LAB_DA30
.da30	20 b7 da	jsr $dab7		JSR	MULDIV			; test and adjust accumulators
.da33	a9 00		lda #$00		LDA	#$00			; clear .A
.da35	85 26		sta $26			STA	RESHO			; clear temp mantissa 1
.da37	85 27		sta $27			STA	RESHO+1			; clear temp mantissa 2
.da39	85 28		sta $28			STA	RESHO+2			; clear temp mantissa 3
.da3b	85 29		sta $29			STA	RESHO+3			; clear temp mantissa 4
.da3d	a5 70		lda $70			LDA	FACOV			; get FAC1 rounding byte
.da3f	20 59 da	jsr $da59		JSR	TIMES3			; go do shift/add FAC2
.da42	a5 65		lda $65			LDA	FAC1+FAC_MANT+3		; get FAC1 mantissa 4
.da44	20 59 da	jsr $da59		JSR	TIMES3			; go do shift/add FAC2
.da47	a5 64		lda $64			LDA	FAC1+FAC_MANT+2		; get FAC1 mantissa 3
.da49	20 59 da	jsr $da59		JSR	TIMES3			; go do shift/add FAC2
.da4c	a5 63		lda $63			LDA	FAC1+FAC_MANT+1		; get FAC1 mantissa 2
.da4e	20 59 da	jsr $da59		JSR	TIMES3			; go do shift/add FAC2
.da51	a5 62		lda $62			LDA	FAC1+FAC_MANT		; get FAC1 mantissa 1
.da53	20 5e da	jsr $da5e		JSR	LAB_DA5E		; go do shift/add FAC2
.da56	4c 8f db	jmp $db8f		JMP	LAB_DB8F		; copy temp to FAC1, normalise and return
.da59					TIMES3
.da59	d0 03		bne $da5e		BNE	LAB_DA5E		; branch if byte <> zero
.da5b	4c 83 d9	jmp $d983		JMP	ASRRES			; shift FACtemp << .A+8 times
.da5e					LAB_DA5E
.da5e	4a		lsr a			LSR				; shift byte
.da5f	09 80		ora #$80		ORA	#$80			; set top bit (mark for 8 times)
.da61					LAB_DA61
.da61	a8		tay			TAY				; copy result
.da62	90 19		bcc $da7d		BCC	LAB_DA7D		; skip next if bit was zero
.da64	18		clc			CLC				; clear carry for add
.da65	a5 29		lda $29			LDA	RESHO+3			; get temp mantissa 4
.da67	65 6d		adc $6d			ADC	FAC2+FAC_MANT+3		; add FAC2 mantissa 4
.da69	85 29		sta $29			STA	RESHO+3			; save temp mantissa 4
.da6b	a5 28		lda $28			LDA	RESHO+2			; get temp mantissa 3
.da6d	65 6c		adc $6c			ADC	FAC2+FAC_MANT+2		; add FAC2 mantissa 3
.da6f	85 28		sta $28			STA	RESHO+2			; save temp mantissa 3
.da71	a5 27		lda $27			LDA	RESHO+1			; get temp mantissa 2
.da73	65 6b		adc $6b			ADC	FAC2+FAC_MANT+1		; add FAC2 mantissa 2
.da75	85 27		sta $27			STA	RESHO+1			; save temp mantissa 2
.da77	a5 26		lda $26			LDA	RESHO			; get temp mantissa 1
.da79	65 6a		adc $6a			ADC	FAC2+FAC_MANT		; add FAC2 mantissa 1
.da7b	85 26		sta $26			STA	RESHO			; save temp mantissa 1
.da7d					LAB_DA7D
.da7d	66 26		ror $26			ROR	RESHO			; shift temp mantissa 1
.da7f	66 27		ror $27			ROR	RESHO+1			; shift temp mantissa 2
.da81	66 28		ror $28			ROR	RESHO+2			; shift temp mantissa 3
.da83	66 29		ror $29			ROR	RESHO+3			; shift temp mantissa 4
.da85	66 70		ror $70			ROR	FACOV			; shift temp rounding byte
.da87	98		tya			TYA				; get byte back
.da88	4a		lsr a			LSR				; shift byte
.da89	d0 d6		bne $da61		BNE	LAB_DA61		; loop if all bits not done
.da8b					LAB_DA8B
.da8b	60		rts			RTS
.da8c					LODARG
.da8c	85 22		sta $22			STA	INDEX			; save pointer low byte
.da8e	84 23		sty $23			STY	INDEX+1			; save pointer high byte
.da90	a0 04		ldy #$04		LDY	#$04			; 5 bytes to get (0-4)
.da92	b1 22		lda ($22),y		LDA	(INDEX),Y		; get mantissa 4
.da94	85 6d		sta $6d			STA	FAC2+FAC_MANT+3		; save FAC2 mantissa 4
.da96	88		dey			DEY				; decrement index
.da97	b1 22		lda ($22),y		LDA	(INDEX),Y		; get mantissa 3
.da99	85 6c		sta $6c			STA	FAC2+FAC_MANT+2		; save FAC2 mantissa 3
.da9b	88		dey			DEY				; decrement index
.da9c	b1 22		lda ($22),y		LDA	(INDEX),Y		; get mantissa 2
.da9e	85 6b		sta $6b			STA	FAC2+FAC_MANT+1		; save FAC2 mantissa 2
.daa0	88		dey			DEY				; decrement index
.daa1	b1 22		lda ($22),y		LDA	(INDEX),Y		; get mantissa 1 + sign
.daa3	85 6e		sta $6e			STA	FAC2+FAC_SIGN		; save FAC2 sign (b7)
.daa5	45 66		eor $66			EOR	FAC1+FAC_SIGN		; XOR with FAC1 sign (b7)
.daa7	85 6f		sta $6f			STA	ARISGN			; save sign compare (FAC1 XOR FAC2)
.daa9	a5 6e		lda $6e			LDA	FAC2+FAC_SIGN		; recover FAC2 sign (b7)
.daab	09 80		ora #$80		ORA	#$80			; set 1xxx xxxx (set normal bit)
.daad	85 6a		sta $6a			STA	FAC2+FAC_MANT		; save FAC2 mantissa 1
.daaf	88		dey			DEY				; decrement index
.dab0	b1 22		lda ($22),y		LDA	(INDEX),Y		; get exponent byte
.dab2	85 69		sta $69			STA	FAC2+FAC_EXPT		; save FAC2 exponent
.dab4	a5 61		lda $61			LDA	FAC1+FAC_EXPT		; get FAC1 exponent
.dab6	60		rts			RTS
.dab7					MULDIV
.dab7	a5 69		lda $69			LDA	FAC2+FAC_EXPT		; get FAC2 exponent
.dab9					LAB_DAB9
.dab9	f0 1f		beq $dada		BEQ	LAB_DADA		; branch if FAC2 = $00 (handle underflow)
.dabb	18		clc			CLC				; clear carry for add
.dabc	65 61		adc $61			ADC	FAC1+FAC_EXPT		; add FAC1 exponent
.dabe	90 04		bcc $dac4		BCC	LAB_DAC4		; branch if sum of exponents < $0100
.dac0	30 1d		bmi $dadf		BMI	LAB_DADF		; do overflow error
.dac2	18		clc			CLC				; clear carry for the add
>dac3	2c					.byte	$2C			; makes next line BIT $1410
.dac4					LAB_DAC4
.dac4	10 14		bpl $dada		BPL	LAB_DADA		; if +ve go handle underflow
.dac6	69 80		adc #$80		ADC	#$80			; adjust exponent
.dac8	85 61		sta $61			STA	FAC1+FAC_EXPT		; save FAC1 exponent
.daca	d0 03		bne $dacf		BNE	LAB_DACF		; branch if not zero
.dacc	4c fb d8	jmp $d8fb		JMP	LAB_D8FB		; save FAC1 sign and return
.dacf					LAB_DACF
.dacf	a5 6f		lda $6f			LDA	ARISGN			; get sign compare (FAC1 XOR FAC2)
.dad1	85 66		sta $66			STA	FAC1+FAC_SIGN		; save FAC1 sign (b7)
.dad3	60		rts			RTS
.dad4					LAB_DAD4
.dad4	a5 66		lda $66			LDA	FAC1+FAC_SIGN		; get FAC1 sign (b7)
.dad6	49 ff		eor #$ff		EOR	#$FF			; complement it
.dad8	30 05		bmi $dadf		BMI	LAB_DADF		; do overflow error
.dada					LAB_DADA
.dada	68		pla			PLA				; pop return address low byte
.dadb	68		pla			PLA				; pop return address high byte
.dadc	4c f7 d8	jmp $d8f7		JMP	ZERFAC			; clear FAC1 exponent and sign and return
.dadf					LAB_DADF
.dadf	4c 7e d9	jmp $d97e		JMP	OVERFL			; do overflow error then warm start
.dae2					MULTEN
.dae2	20 0c dc	jsr $dc0c		JSR	RFTOA			; round and copy FAC1 to FAC2
.dae5	aa		tax			TAX				; copy exponent (set the flags)
.dae6	f0 10		beq $daf8		BEQ	LAB_DAF8		; exit if zero
.dae8	18		clc			CLC				; clear carry for add
.dae9	69 02		adc #$02		ADC	#$02			; add two to exponent (*4)
.daeb	b0 f2		bcs $dadf		BCS	LAB_DADF		; do overflow error if > $FF
.daed					LAB_DAED
.daed	a2 00		ldx #$00		LDX	#$00			; clear byte
.daef	86 6f		stx $6f			STX	ARISGN			; clear sign compare (FAC1 XOR FAC2)
.daf1	20 77 d8	jsr $d877		JSR	LAB_D877		; add FAC2 to FAC1 (*5)
.daf4	e6 61		inc $61			INC	FAC1+FAC_EXPT		; increment FAC1 exponent (*10)
.daf6	f0 e7		beq $dadf		BEQ	LAB_DADF		; if exponent now zero go do overflow error
.daf8					LAB_DAF8
.daf8	60		rts			RTS
.daf9					FPCTEN
>daf9	84 20 00 00 00				.byte	$84,$20,$00,$00,$00	; 10
.dafe					DIVTEN
.dafe	20 0c dc	jsr $dc0c		JSR	RFTOA			; round and copy FAC1 to FAC2
.db01	a9 f9		lda #$f9		LDA	#<FPCTEN		; set 10 pointer low byte
.db03	a0 da		ldy #$da		LDY	#>FPCTEN		; set 10 pointer high byte
.db05	a2 00		ldx #$00		LDX	#$00			; clear sign
.db07					LAB_DB07
.db07	86 6f		stx $6f			STX	ARISGN			; save sign compare (FAC1 XOR FAC2)
.db09	20 a2 db	jsr $dba2		JSR	LODFAC			; unpack memory (.A.Y) into FAC1
.db0c	4c 12 db	jmp $db12		JMP	DIVIDE			; do FAC2/FAC1
.db0f					LADIV
.db0f	20 8c da	jsr $da8c		JSR	LODARG			; unpack memory (.A.Y) into FAC2
.db12					DIVIDE
.db12	f0 76		beq $db8a		BEQ	LAB_DB8A		; if zero go do /0 error
.db14	20 1b dc	jsr $dc1b		JSR	ROUND			; round FAC1
.db17	a9 00		lda #$00		LDA	#$00			; clear .A
.db19	38		sec			SEC				; set carry for subtract
.db1a	e5 61		sbc $61			SBC	FAC1+FAC_EXPT		; subtract FAC1 exponent (2's complement)
.db1c	85 61		sta $61			STA	FAC1+FAC_EXPT		; save FAC1 exponent
.db1e	20 b7 da	jsr $dab7		JSR	MULDIV			; test and adjust accumulators
.db21	e6 61		inc $61			INC	FAC1+FAC_EXPT		; increment FAC1 exponent
.db23	f0 ba		beq $dadf		BEQ	LAB_DADF		; if zero do overflow error
.db25	a2 fc		ldx #$fc		LDX	#$FC			; set index to FAC temp
.db27	a9 01		lda #$01		LDA	#$01			;.set byte
.db29					LAB_DB29
.db29	a4 6a		ldy $6a			LDY	FAC2+FAC_MANT		; get FAC2 mantissa 1
.db2b	c4 62		cpy $62			CPY	FAC1+FAC_MANT		; compare FAC1 mantissa 1
.db2d	d0 10		bne $db3f		BNE	LAB_DB3F		; if <> go use the result
.db2f	a4 6b		ldy $6b			LDY	FAC2+FAC_MANT+1		; get FAC2 mantissa 2
.db31	c4 63		cpy $63			CPY	FAC1+FAC_MANT+1		; compare FAC1 mantissa 2
.db33	d0 0a		bne $db3f		BNE	LAB_DB3F		; if <> go use the result
.db35	a4 6c		ldy $6c			LDY	FAC2+FAC_MANT+2		; get FAC2 mantissa 3
.db37	c4 64		cpy $64			CPY	FAC1+FAC_MANT+2		; compare FAC1 mantissa 3
.db39	d0 04		bne $db3f		BNE	LAB_DB3F		; if <> go use the result
.db3b	a4 6d		ldy $6d			LDY	FAC2+FAC_MANT+3		; get FAC2 mantissa 4
.db3d	c4 65		cpy $65			CPY	FAC1+FAC_MANT+3		; compare FAC1 mantissa 4
.db3f					LAB_DB3F
.db3f	08		php			PHP				; save the FAC2-FAC1 compare status
.db40	2a		rol a			ROL				;.shift byte
.db41	90 09		bcc $db4c		BCC	LAB_DB4C		; skip next if no carry
.db43	e8		inx			INX				; increment index to FAC temp
.db44	95 29		sta $29,x		STA	RESHO+3,X		;.
.db46	f0 32		beq $db7a		BEQ	LAB_DB7A		;.
.db48	10 34		bpl $db7e		BPL	LAB_DB7E		;.
.db4a	a9 01		lda #$01		LDA	#$01			;.
.db4c					LAB_DB4C
.db4c	28		plp			PLP				; restore FAC2-FAC1 compare status
.db4d	b0 0e		bcs $db5d		BCS	LAB_DB5D		; if FAC2 >= FAC1 then do subtract
.db4f					LAB_DB4F
.db4f	06 6d		asl $6d			ASL	FAC2+FAC_MANT+3		; shift FAC2 mantissa 4
.db51	26 6c		rol $6c			ROL	FAC2+FAC_MANT+2		; shift FAC2 mantissa 3
.db53	26 6b		rol $6b			ROL	FAC2+FAC_MANT+1		; shift FAC2 mantissa 2
.db55	26 6a		rol $6a			ROL	FAC2+FAC_MANT		; shift FAC2 mantissa 1
.db57	b0 e6		bcs $db3f		BCS	LAB_DB3F		; loop with no compare
.db59	30 ce		bmi $db29		BMI	LAB_DB29		; loop with compare
.db5b	10 e2		bpl $db3f		BPL	LAB_DB3F		; loop always with no compare
.db5d					LAB_DB5D
.db5d	a8		tay			TAY				; save FAC2-FAC1 compare status
.db5e	a5 6d		lda $6d			LDA	FAC2+FAC_MANT+3		; get FAC2 mantissa 4
.db60	e5 65		sbc $65			SBC	FAC1+FAC_MANT+3		; subtract FAC1 mantissa 4
.db62	85 6d		sta $6d			STA	FAC2+FAC_MANT+3		; save FAC2 mantissa 4
.db64	a5 6c		lda $6c			LDA	FAC2+FAC_MANT+2		; get FAC2 mantissa 3
.db66	e5 64		sbc $64			SBC	FAC1+FAC_MANT+2		; subtract FAC1 mantissa 3
.db68	85 6c		sta $6c			STA	FAC2+FAC_MANT+2		; save FAC2 mantissa 3
.db6a	a5 6b		lda $6b			LDA	FAC2+FAC_MANT+1		; get FAC2 mantissa 2
.db6c	e5 63		sbc $63			SBC	FAC1+FAC_MANT+1		; subtract FAC1 mantissa 2
.db6e	85 6b		sta $6b			STA	FAC2+FAC_MANT+1		; save FAC2 mantissa 2
.db70	a5 6a		lda $6a			LDA	FAC2+FAC_MANT		; get FAC2 mantissa 1
.db72	e5 62		sbc $62			SBC	FAC1+FAC_MANT		; subtract FAC1 mantissa 1
.db74	85 6a		sta $6a			STA	FAC2+FAC_MANT		; save FAC2 mantissa 1
.db76	98		tya			TYA				; restore FAC2-FAC1 compare status
.db77	4c 4f db	jmp $db4f		JMP	LAB_DB4F		; go shift FAC2
.db7a					LAB_DB7A
.db7a	a9 40		lda #$40		LDA	#$40			;.
.db7c	d0 ce		bne $db4c		BNE	LAB_DB4C		; branch always
.db7e					LAB_DB7E
.db7e	0a		asl a			ASL				;
.db7f	0a		asl a			ASL				;
.db80	0a		asl a			ASL				;
.db81	0a		asl a			ASL				;
.db82	0a		asl a			ASL				;
.db83	0a		asl a			ASL				;
.db84	85 70		sta $70			STA	FACOV			; save FAC1 rounding byte
.db86	28		plp			PLP				; dump FAC2-FAC1 compare status
.db87	4c 8f db	jmp $db8f		JMP	LAB_DB8F		; copy temp to FAC1, normalise and return
.db8a					LAB_DB8A
.db8a	a2 14		ldx #$14		LDX	#ER_DIVBY0		; error $14, divide by zero error
.db8c	4c 37 c4	jmp $c437		JMP	ERROR			; do error #.X then warm start
.db8f					LAB_DB8F
.db8f	a5 26		lda $26			LDA	RESHO			; get temp mantissa 1
.db91	85 62		sta $62			STA	FAC1+FAC_MANT		; save FAC1 mantissa 1
.db93	a5 27		lda $27			LDA	RESHO+1			; get temp mantissa 2
.db95	85 63		sta $63			STA	FAC1+FAC_MANT+1		; save FAC1 mantissa 2
.db97	a5 28		lda $28			LDA	RESHO+2			; get temp mantissa 3
.db99	85 64		sta $64			STA	FAC1+FAC_MANT+2		; save FAC1 mantissa 3
.db9b	a5 29		lda $29			LDA	RESHO+3			; get temp mantissa 4
.db9d	85 65		sta $65			STA	FAC1+FAC_MANT+3		; save FAC1 mantissa 4
.db9f	4c d7 d8	jmp $d8d7		JMP	LAB_D8D7		; normalise FAC1 and return
.dba2					LODFAC
.dba2	85 22		sta $22			STA	INDEX			; save pointer low byte
.dba4	84 23		sty $23			STY	INDEX+1			; save pointer high byte
.dba6	a0 04		ldy #$04		LDY	#$04			; 5 bytes to do
.dba8	b1 22		lda ($22),y		LDA	(INDEX),Y		; get fifth byte
.dbaa	85 65		sta $65			STA	FAC1+FAC_MANT+3		; save FAC1 mantissa 4
.dbac	88		dey			DEY				; decrement index
.dbad	b1 22		lda ($22),y		LDA	(INDEX),Y		; get fourth byte
.dbaf	85 64		sta $64			STA	FAC1+FAC_MANT+2		; save FAC1 mantissa 3
.dbb1	88		dey			DEY				; decrement index
.dbb2	b1 22		lda ($22),y		LDA	(INDEX),Y		; get third byte
.dbb4	85 63		sta $63			STA	FAC1+FAC_MANT+1		; save FAC1 mantissa 2
.dbb6	88		dey			DEY				; decrement index
.dbb7	b1 22		lda ($22),y		LDA	(INDEX),Y		; get second byte
.dbb9	85 66		sta $66			STA	FAC1+FAC_SIGN		; save FAC1 sign (b7)
.dbbb	09 80		ora #$80		ORA	#$80			; set 1xxx xxxx (add normal bit)
.dbbd	85 62		sta $62			STA	FAC1+FAC_MANT		; save FAC1 mantissa 1
.dbbf	88		dey			DEY				; decrement index
.dbc0	b1 22		lda ($22),y		LDA	(INDEX),Y		; get first byte (exponent)
.dbc2	85 61		sta $61			STA	FAC1+FAC_EXPT		; save FAC1 exponent
.dbc4	84 70		sty $70			STY	FACOV			; clear FAC1 rounding byte
.dbc6	60		rts			RTS
.dbc7					FACTF2
.dbc7	a2 5c		ldx #$5c		LDX	#<LAB_5C		; set pointer low byte
>dbc9	2c					.byte	$2C			; makes next line BIT $57A2
.dbca					FACTF1
.dbca	a2 57		ldx #$57		LDX	#<TEMPF3		; set pointer low byte
.dbcc	a0 00		ldy #$00		LDY	#>TEMPF3		; set pointer high byte
.dbce	f0 04		beq $dbd4		BEQ	STORFAC			; pack FAC1 into (.X.Y) and return, branch always
.dbd0					FACTFP
.dbd0	a6 49		ldx $49			LDX	FORPNT			; get destination pointer low byte
.dbd2	a4 4a		ldy $4a			LDY	FORPNT+1		; get destination pointer high byte
.dbd4					STORFAC
.dbd4	20 1b dc	jsr $dc1b		JSR	ROUND			; round FAC1
.dbd7	86 22		stx $22			STX	INDEX			; save pointer low byte
.dbd9	84 23		sty $23			STY	INDEX+1			; save pointer high byte
.dbdb	a0 04		ldy #$04		LDY	#$04			; set index
.dbdd	a5 65		lda $65			LDA	FAC1+FAC_MANT+3		; get FAC1 mantissa 4
.dbdf	91 22		sta ($22),y		STA	(INDEX),Y		; store in destination
.dbe1	88		dey			DEY				; decrement index
.dbe2	a5 64		lda $64			LDA	FAC1+FAC_MANT+2		; get FAC1 mantissa 3
.dbe4	91 22		sta ($22),y		STA	(INDEX),Y		; store in destination
.dbe6	88		dey			DEY				; decrement index
.dbe7	a5 63		lda $63			LDA	FAC1+FAC_MANT+1		; get FAC1 mantissa 2
.dbe9	91 22		sta ($22),y		STA	(INDEX),Y		; store in destination
.dbeb	88		dey			DEY				; decrement index
.dbec	a5 66		lda $66			LDA	FAC1+FAC_SIGN		; get FAC1 sign (b7)
.dbee	09 7f		ora #$7f		ORA	#$7F			; set bits x111 1111
.dbf0	25 62		and $62			AND	FAC1+FAC_MANT		; AND in FAC1 mantissa 1
.dbf2	91 22		sta ($22),y		STA	(INDEX),Y		; store in destination
.dbf4	88		dey			DEY				; decrement index
.dbf5	a5 61		lda $61			LDA	FAC1+FAC_EXPT		; get FAC1 exponent
.dbf7	91 22		sta ($22),y		STA	(INDEX),Y		; store in destination
.dbf9	84 70		sty $70			STY	FACOV			; clear FAC1 rounding byte
.dbfb	60		rts			RTS
.dbfc					ATOF
.dbfc	a5 6e		lda $6e			LDA	FAC2+FAC_SIGN		; get FAC2 sign (b7)
.dbfe					LAB_DBFE
.dbfe	85 66		sta $66			STA	FAC1+FAC_SIGN		; save FAC1 sign (b7)
.dc00	a2 05		ldx #$05		LDX	#$05			; 5 bytes to copy
.dc02					LAB_DC02
.dc02	b5 68		lda $68,x		LDA	FAC2-1,X		; get byte from FAC2,X
.dc04	95 60		sta $60,x		STA	FAC1-1,X		; save byte at FAC1,X
.dc06	ca		dex			DEX				; decrement count
.dc07	d0 f9		bne $dc02		BNE	LAB_DC02		; loop if not all done
.dc09	86 70		stx $70			STX	FACOV			; clear FAC1 rounding byte
.dc0b	60		rts			RTS
.dc0c					RFTOA
.dc0c	20 1b dc	jsr $dc1b		JSR	ROUND			; round FAC1
.dc0f					FTOA
.dc0f	a2 06		ldx #$06		LDX	#$06			; 6 bytes to copy
.dc11					LAB_DC11
.dc11	b5 60		lda $60,x		LDA	FAC1-1,X		; get byte from FAC1,X
.dc13	95 68		sta $68,x		STA	FAC2-1,X		; save byte at FAC2,X
.dc15	ca		dex			DEX				; decrement count
.dc16	d0 f9		bne $dc11		BNE	LAB_DC11		; loop if not all done
.dc18	86 70		stx $70			STX	FACOV			; clear FAC1 rounding byte
.dc1a					LAB_DC1A
.dc1a	60		rts			RTS
.dc1b					ROUND
.dc1b	a5 61		lda $61			LDA	FAC1+FAC_EXPT		; get FAC1 exponent
.dc1d	f0 fb		beq $dc1a		BEQ	LAB_DC1A		; exit if zero
.dc1f	06 70		asl $70			ASL	FACOV			; shift FAC1 rounding byte
.dc21	90 f7		bcc $dc1a		BCC	LAB_DC1A		; exit if no overflow
.dc23					LAB_DC23
.dc23	20 6f d9	jsr $d96f		JSR	LAB_D96F		; increment FAC1 mantissa
.dc26	d0 f2		bne $dc1a		BNE	LAB_DC1A		; branch if no overflow
.dc28	4c 38 d9	jmp $d938		JMP	LAB_D938		; normalise FAC1 for Cb=1 and return
.dc2b					SGNFAC
.dc2b	a5 61		lda $61			LDA	FAC1+FAC_EXPT		; get FAC1 exponent
.dc2d	f0 09		beq $dc38		BEQ	LAB_DC38		; exit if zero (already correct SGN(0)=0)
.dc2f					LAB_DC2F
.dc2f	a5 66		lda $66			LDA	FAC1+FAC_SIGN		; else get FAC1 sign (b7)
.dc31					LAB_DC31
.dc31	2a		rol a			ROL				; move sign bit to carry
.dc32	a9 ff		lda #$ff		LDA	#$FF			; set byte for -ve result
.dc34	b0 02		bcs $dc38		BCS	LAB_DC38		; return if sign was set (-ve)
.dc36	a9 01		lda #$01		LDA	#$01			; else set byte for +ve result
.dc38					LAB_DC38
.dc38	60		rts			RTS
.dc39					SGN
.dc39	20 2b dc	jsr $dc2b		JSR	SGNFAC			; get FAC1 sign, return .A = $FF -ve, .A = $01 +ve
.dc3c					INTFP
.dc3c	85 62		sta $62			STA	FAC1+FAC_MANT		; save FAC1 mantissa 1
.dc3e	a9 00		lda #$00		LDA	#$00			; clear A
.dc40	85 63		sta $63			STA	FAC1+FAC_MANT+1		; clear FAC1 mantissa 2
.dc42	a2 88		ldx #$88		LDX	#$88			; set exponent
.dc44					INTFP1
.dc44	a5 62		lda $62			LDA	FAC1+FAC_MANT		; get FAC1 mantissa 1
.dc46	49 ff		eor #$ff		EOR	#$FF			; complement it
.dc48	2a		rol a			ROL				; sign bit into carry
.dc49					LAB_DC49
.dc49	a9 00		lda #$00		LDA	#$00			; clear .A
.dc4b	85 65		sta $65			STA	FAC1+FAC_MANT+3		; clear FAC1 mantissa 4
.dc4d	85 64		sta $64			STA	FAC1+FAC_MANT+2		; clear FAC1 mantissa 3
.dc4f					LAB_DC4F
.dc4f	86 61		stx $61			STX	FAC1+FAC_EXPT		; set FAC1 exponent
.dc51	85 70		sta $70			STA	FACOV			; clear FAC1 rounding byte
.dc53	85 66		sta $66			STA	FAC1+FAC_SIGN		; clear FAC1 sign (b7)
.dc55	4c d2 d8	jmp $d8d2		JMP	LAB_D8D2		; do ABS and normalise FAC1
.dc58					ABS
.dc58	46 66		lsr $66			LSR	FAC1+FAC_SIGN		; clear FAC1 sign, put zero in b7
.dc5a	60		rts			RTS
.dc5b					CMPFAC
.dc5b	85 24		sta $24			STA	INDEX+2			; save pointer low byte
.dc5d					LAB_DC5D
.dc5d	84 25		sty $25			STY	INDEX+3			; save pointer high byte
.dc5f	a0 00		ldy #$00		LDY	#$00			; clear index
.dc61	b1 24		lda ($24),y		LDA	(INDEX+2),Y		; get exponent
.dc63	c8		iny			INY				; increment index
.dc64	aa		tax			TAX				; copy (.A.Y) exponent to .X
.dc65	f0 c4		beq $dc2b		BEQ	SGNFAC			; branch if (.A.Y) exponent=0 and get FAC1 sign
.dc67	b1 24		lda ($24),y		LDA	(INDEX+2),Y		; get (.A.Y) mantissa 1, with sign
.dc69	45 66		eor $66			EOR	FAC1+FAC_SIGN		; XOR FAC1 sign (b7)
.dc6b	30 c2		bmi $dc2f		BMI	LAB_DC2F		; if signs <> do return .A = $FF, Cb = 1/-ve
.dc6d	e4 61		cpx $61			CPX	FAC1+FAC_EXPT		; compare (.A.Y) exponent with FAC1 exponent
.dc6f	d0 21		bne $dc92		BNE	LAB_DC92		; branch if different
.dc71	b1 24		lda ($24),y		LDA	(INDEX+2),Y		; get (.A.Y) mantissa 1, with sign
.dc73	09 80		ora #$80		ORA	#$80			; normalise top bit
.dc75	c5 62		cmp $62			CMP	FAC1+FAC_MANT		; compare with FAC1 mantissa 1
.dc77	d0 19		bne $dc92		BNE	LAB_DC92		; branch if different
.dc79	c8		iny			INY				; increment index
.dc7a	b1 24		lda ($24),y		LDA	(INDEX+2),Y		; get mantissa 2
.dc7c	c5 63		cmp $63			CMP	FAC1+FAC_MANT+1		; compare with FAC1 mantissa 2
.dc7e	d0 12		bne $dc92		BNE	LAB_DC92		; branch if different
.dc80	c8		iny			INY				; increment index
.dc81	b1 24		lda ($24),y		LDA	(INDEX+2),Y		; get mantissa 3
.dc83	c5 64		cmp $64			CMP	FAC1+FAC_MANT+2		; compare with FAC1 mantissa 3
.dc85	d0 0b		bne $dc92		BNE	LAB_DC92		; branch if different
.dc87	c8		iny			INY				; increment index
.dc88	a9 7f		lda #$7f		LDA	#$7F			; set for 1/2 value rounding byte
.dc8a	c5 70		cmp $70			CMP	FACOV			; compare with FAC1 rounding byte (set carry)
.dc8c	b1 24		lda ($24),y		LDA	(INDEX+2),Y		; get mantissa 4
.dc8e	e5 65		sbc $65			SBC	FAC1+FAC_MANT+3		; subtract FAC1 mantissa 4
.dc90	f0 28		beq $dcba		BEQ	LAB_DCBA		; exit if mantissa 4 equal
.dc92					LAB_DC92
.dc92	a5 66		lda $66			LDA	FAC1+FAC_SIGN		; get FAC1 sign (b7)
.dc94	90 02		bcc $dc98		BCC	LAB_DC98		; branch if FAC1 > (.A.Y)
.dc96	49 ff		eor #$ff		EOR	#$FF			; else toggle FAC1 sign
.dc98					LAB_DC98
.dc98	4c 31 dc	jmp $dc31		JMP	LAB_DC31		; return .A = $FF, Cb = 1/-ve .A = $01, Cb = 0/+ve
.dc9b					FPINT
.dc9b	a5 61		lda $61			LDA	FAC1+FAC_EXPT		; get FAC1 exponent
.dc9d	f0 4a		beq $dce9		BEQ	FILFAC			; if zero go clear FAC1 and return
.dc9f	38		sec			SEC				; set carry for subtract
.dca0	e9 a0		sbc #$a0		SBC	#$A0			; subtract maximum integer range exponent
.dca2	24 66		bit $66			BIT	FAC1+FAC_SIGN		; test FAC1 sign (b7)
.dca4	10 09		bpl $dcaf		BPL	LAB_DCAF		; branch if FAC1 +ve
.dca6	aa		tax			TAX				; copy subtracted exponent
.dca7	a9 ff		lda #$ff		LDA	#$FF			; overflow for -ve number
.dca9	85 68		sta $68			STA	BITS			; set FAC1 overflow byte
.dcab	20 4d d9	jsr $d94d		JSR	LAB_D94D		; two's complement FAC1 mantissa
.dcae	8a		txa			TXA				; restore subtracted exponent
.dcaf					LAB_DCAF
.dcaf	a2 61		ldx #$61		LDX	#FAC1			; set index to FAC1
.dcb1	c9 f9		cmp #$f9		CMP	#$F9			; compare exponent result
.dcb3	10 06		bpl $dcbb		BPL	LAB_DCBB		; if < 8 shifts shift FAC1 .A times right and return
.dcb5	20 99 d9	jsr $d999		JSR	LAB_D999		; shift FAC1 .A times right (> 8 shifts)
.dcb8	84 68		sty $68			STY	BITS			; clear FAC1 overflow byte
.dcba					LAB_DCBA
.dcba	60		rts			RTS
.dcbb					LAB_DCBB
.dcbb	a8		tay			TAY				; copy shift count
.dcbc	a5 66		lda $66			LDA	FAC1+FAC_SIGN		; get FAC1 sign (b7)
.dcbe	29 80		and #$80		AND	#$80			; mask sign bit only (x000 0000)
.dcc0	46 62		lsr $62			LSR	FAC1+FAC_MANT		; shift FAC1 mantissa 1
.dcc2	05 62		ora $62			ORA	FAC1+FAC_MANT		; OR sign in b7 FAC1 mantissa 1
.dcc4	85 62		sta $62			STA	FAC1+FAC_MANT		; save FAC1 mantissa 1
.dcc6	20 b0 d9	jsr $d9b0		JSR	LAB_D9B0		; shift FAC1 .Y times right
.dcc9	84 68		sty $68			STY	BITS			; clear FAC1 overflow byte
.dccb	60		rts			RTS
.dccc					INT
.dccc	a5 61		lda $61			LDA	FAC1+FAC_EXPT		; get FAC1 exponent
.dcce	c9 a0		cmp #$a0		CMP	#$A0			; compare with max int
.dcd0	b0 20		bcs $dcf2		BCS	LAB_DCF2		; exit if >= (already int, too big for fractional part!)
.dcd2	20 9b dc	jsr $dc9b		JSR	FPINT			; convert FAC1 floating to fixed
.dcd5	84 70		sty $70			STY	FACOV			; save FAC1 rounding byte
.dcd7	a5 66		lda $66			LDA	FAC1+FAC_SIGN		; get FAC1 sign (b7)
.dcd9	84 66		sty $66			STY	FAC1+FAC_SIGN		; save FAC1 sign (b7)
.dcdb	49 80		eor #$80		EOR	#$80			; toggle FAC1 sign
.dcdd	2a		rol a			ROL				; shift into carry
.dcde	a9 a0		lda #$a0		LDA	#$A0			; set new exponent
.dce0	85 61		sta $61			STA	FAC1+FAC_EXPT		; save FAC1 exponent
.dce2	a5 65		lda $65			LDA	FAC1+FAC_MANT+3		; get FAC1 mantissa 4
.dce4	85 07		sta $07			STA	CHARAC			; save FAC1 mantissa 4 for power function
.dce6	4c d2 d8	jmp $d8d2		JMP	LAB_D8D2		; do ABS and normalise FAC1
.dce9					FILFAC
.dce9	85 62		sta $62			STA	FAC1+FAC_MANT		; clear FAC1 mantissa 1
.dceb	85 63		sta $63			STA	FAC1+FAC_MANT+1		; clear FAC1 mantissa 2
.dced	85 64		sta $64			STA	FAC1+FAC_MANT+2		; clear FAC1 mantissa 3
.dcef	85 65		sta $65			STA	FAC1+FAC_MANT+3		; clear FAC1 mantissa 4
.dcf1	a8		tay			TAY				; clear .Y
.dcf2					LAB_DCF2
.dcf2	60		rts			RTS
.dcf3					ASCFLT
.dcf3	a0 00		ldy #$00		LDY	#$00			; clear .Y
.dcf5	a2 0a		ldx #$0a		LDX	#$0A			; set index
.dcf7					LAB_DCF7
.dcf7	94 5d		sty $5d,x		STY	LAB_5D,X		; clear byte
.dcf9	ca		dex			DEX				; decrement index
.dcfa	10 fb		bpl $dcf7		BPL	LAB_DCF7		; loop until numexp to negnum (and FAC1) = $00
.dcfc	90 0f		bcc $dd0d		BCC	LAB_DD0D		; branch if first character is numeric
.dcfe	c9 2d		cmp #$2d		CMP	#'-'			; else compare with "-"
.dd00	d0 04		bne $dd06		BNE	LAB_DD06		; branch if not "-"
.dd02	86 67		stx $67			STX	SGNFLG			; set flag for -ve n (negnum = $FF)
.dd04	f0 04		beq $dd0a		BEQ	LAB_DD0A		; branch always
.dd06					LAB_DD06
.dd06	c9 2b		cmp #$2b		CMP	#'+'			; else compare with "+"
.dd08	d0 05		bne $dd0f		BNE	LAB_DD0F		; branch if not "+"
.dd0a					LAB_DD0A
.dd0a	20 73 00	jsr $0073		JSR	CHRGET			; increment and scan memory
.dd0d					LAB_DD0D
.dd0d	90 5b		bcc $dd6a		BCC	LAB_DD6A		; branch if numeric character
.dd0f					LAB_DD0F
.dd0f	c9 2e		cmp #$2e		CMP	#'.'			; else compare with "."
.dd11	f0 2e		beq $dd41		BEQ	LAB_DD41		; branch if "."
.dd13	c9 45		cmp #$45		CMP	#'E'			; else compare with "E"
.dd15	d0 30		bne $dd47		BNE	LAB_DD47		; branch if not "E"
.dd17	20 73 00	jsr $0073		JSR	CHRGET			; increment and scan memory
.dd1a	90 17		bcc $dd33		BCC	LAB_DD33		; branch if numeric character
.dd1c	c9 ab		cmp #$ab		CMP	#TK_MINUS		; else compare with token for "-"
.dd1e	f0 0e		beq $dd2e		BEQ	LAB_DD2E		; branch if token for "-"
.dd20	c9 2d		cmp #$2d		CMP	#'-'			; else compare with "-"
.dd22	f0 0a		beq $dd2e		BEQ	LAB_DD2E		; branch if "-"
.dd24	c9 aa		cmp #$aa		CMP	#TK_PLUS		; else compare with token for "+"
.dd26	f0 08		beq $dd30		BEQ	LAB_DD30		; branch if token for "+"
.dd28	c9 2b		cmp #$2b		CMP	#'+'			; else compare with "+"
.dd2a	f0 04		beq $dd30		BEQ	LAB_DD30		; branch if "+"
.dd2c	d0 07		bne $dd35		BNE	LAB_DD35		; branch always
.dd2e					LAB_DD2E
.dd2e	66 60		ror $60			ROR	TMPPTR+1		; set exponent -ve flag (C, which=1, into b7)
.dd30					LAB_DD30
.dd30	20 73 00	jsr $0073		JSR	CHRGET			; increment and scan memory
.dd33					LAB_DD33
.dd33	90 5c		bcc $dd91		BCC	LAB_DD91		; branch if numeric character
.dd35					LAB_DD35
.dd35	24 60		bit $60			BIT	TMPPTR+1		; test exponent -ve flag
.dd37	10 0e		bpl $dd47		BPL	LAB_DD47		; if +ve go evaluate exponent
.dd39	a9 00		lda #$00		LDA	#$00			; clear result
.dd3b	38		sec			SEC				; set carry for subtract
.dd3c	e5 5e		sbc $5e			SBC	EXPCNT			; subtract exponent byte
.dd3e	4c 49 dd	jmp $dd49		JMP	LAB_DD49		; go evaluate exponent
.dd41					LAB_DD41
.dd41	66 5f		ror $5f			ROR	TMPPTR			; set decimal point flag
.dd43	24 5f		bit $5f			BIT	TMPPTR			; test decimal point flag
.dd45	50 c3		bvc $dd0a		BVC	LAB_DD0A		; branch if only one decimal point so far
.dd47					LAB_DD47
.dd47	a5 5e		lda $5e			LDA	EXPCNT			; get exponent count byte
.dd49					LAB_DD49
.dd49	38		sec			SEC				; set carry for subtract
.dd4a	e5 5d		sbc $5d			SBC	LAB_5D			; subtract numerator exponent
.dd4c	85 5e		sta $5e			STA	EXPCNT			; save exponent count byte
.dd4e	f0 12		beq $dd62		BEQ	LAB_DD62		; branch if no adjustment
.dd50	10 09		bpl $dd5b		BPL	LAB_DD5B		; else if +ve go do FAC1*10^expcnt
.dd52					LAB_DD52
.dd52	20 fe da	jsr $dafe		JSR	DIVTEN			; divide FAC1 by 10
.dd55	e6 5e		inc $5e			INC	EXPCNT			; increment exponent count byte
.dd57	d0 f9		bne $dd52		BNE	LAB_DD52		; loop until all done
.dd59	f0 07		beq $dd62		BEQ	LAB_DD62		; branch always
.dd5b					LAB_DD5B
.dd5b	20 e2 da	jsr $dae2		JSR	MULTEN			; multiply FAC1 by 10
.dd5e	c6 5e		dec $5e			DEC	EXPCNT			; decrement exponent count byte
.dd60	d0 f9		bne $dd5b		BNE	LAB_DD5B		; loop until all done
.dd62					LAB_DD62
.dd62	a5 67		lda $67			LDA	SGNFLG			; get -ve flag
.dd64	30 01		bmi $dd67		BMI	LAB_DD67		; if -ve do - FAC1 and return
.dd66	60		rts			RTS
.dd67					LAB_DD67
.dd67	4c b4 df	jmp $dfb4		JMP	NEGFAC			; do - FAC1
.dd6a					LAB_DD6A
.dd6a	48		pha			PHA				; save character
.dd6b	24 5f		bit $5f			BIT	TMPPTR			; test decimal point flag
.dd6d	10 02		bpl $dd71		BPL	LAB_DD71		; skip exponent increment if not set
.dd6f	e6 5d		inc $5d			INC	LAB_5D			; else increment number exponent
.dd71					LAB_DD71
.dd71	20 e2 da	jsr $dae2		JSR	MULTEN			; multiply FAC1 by 10
.dd74	68		pla			PLA				; restore character
.dd75	38		sec			SEC				; set carry for subtract
.dd76	e9 30		sbc #$30		SBC	#'0'			; convert to binary
.dd78	20 7e dd	jsr $dd7e		JSR	ASCI8			; evaluate new ASCII digit
.dd7b	4c 0a dd	jmp $dd0a		JMP	LAB_DD0A		; go do next character
.dd7e					ASCI8
.dd7e	48		pha			PHA				; save digit
.dd7f	20 0c dc	jsr $dc0c		JSR	RFTOA			; round and copy FAC1 to FAC2
.dd82	68		pla			PLA				; restore digit
.dd83	20 3c dc	jsr $dc3c		JSR	INTFP			; save .A as integer byte
.dd86	a5 6e		lda $6e			LDA	FAC2+FAC_SIGN		; get FAC2 sign (b7)
.dd88	45 66		eor $66			EOR	FAC1+FAC_SIGN		; toggle with FAC1 sign (b7)
.dd8a	85 6f		sta $6f			STA	ARISGN			; save sign compare (FAC1 XOR FAC2)
.dd8c	a6 61		ldx $61			LDX	FAC1+FAC_EXPT		; get FAC1 exponent
.dd8e	4c 6a d8	jmp $d86a		JMP	PLUS			; add FAC2 to FAC1 and return
.dd91					LAB_DD91
.dd91	a5 5e		lda $5e			LDA	EXPCNT			; get exponent count byte
.dd93	c9 0a		cmp #$0a		CMP	#$0A			; compare with 10 decimal
.dd95	90 09		bcc $dda0		BCC	LAB_DDA0		; branch if less
.dd97	a9 64		lda #$64		LDA	#$64			; make all -ve exponents = -100 decimal (causes underflow)
.dd99	24 60		bit $60			BIT	TMPPTR+1		; test exponent -ve flag
.dd9b	30 11		bmi $ddae		BMI	LAB_DDAE		; branch if -ve
.dd9d	4c 7e d9	jmp $d97e		JMP	OVERFL			; else do overflow error then warm start
.dda0					LAB_DDA0
.dda0	0a		asl a			ASL				; *2
.dda1	0a		asl a			ASL				; *4
.dda2	18		clc			CLC				; clear carry for add
.dda3	65 5e		adc $5e			ADC	EXPCNT			; *5
.dda5	0a		asl a			ASL				; *10
.dda6	18		clc			CLC				; clear carry for add
.dda7	a0 00		ldy #$00		LDY	#$00			; set index
.dda9	71 7a		adc ($7a),y		ADC	(CHRGOT+1),Y		; add character (will be $30 too much!)
.ddab	38		sec			SEC				; set carry for subtract
.ddac	e9 30		sbc #$30		SBC	#'0'			; convert character to binary
.ddae					LAB_DDAE
.ddae	85 5e		sta $5e			STA	EXPCNT			; save exponent count byte
.ddb0	4c 30 dd	jmp $dd30		JMP	LAB_DD30		; go get next character
.ddb3					FPC12
>ddb3	9b 3e bc 1f fd				.byte	$9B,$3E,$BC,$1F,$FD
.ddb8					LAB_DDB8
>ddb8	9e 6e 6b 27 fd				.byte	$9E,$6E,$6B,$27,$FD
.ddbd					LAB_DDBD
>ddbd	9e 6e 6b 28 00				.byte	$9E,$6E,$6B,$28,$00
.ddc2					PRTIN
.ddc2	a9 71		lda #$71		LDA	#<INSTR			; set " IN " pointer low byte
.ddc4	a0 c3		ldy #$c3		LDY	#>INSTR			; set " IN " pointer high byte
.ddc6	20 da dd	jsr $ddda		JSR	LAB_DDDA		; print null terminated string
.ddc9	a5 3a		lda $3a			LDA	CURLIN+1		; get the current line number high byte
.ddcb	a6 39		ldx $39			LDX	CURLIN			; get the current line number low byte
.ddcd					PRTFIX
.ddcd	85 62		sta $62			STA	FAC1+FAC_MANT		; save high byte as FAC1 mantissa 1
.ddcf	86 63		stx $63			STX	FAC1+FAC_MANT+1		; save low byte as FAC1 mantissa 2
.ddd1	a2 90		ldx #$90		LDX	#$90			; set exponent to 16d bits
.ddd3	38		sec			SEC				; set integer is +ve flag
.ddd4	20 49 dc	jsr $dc49		JSR	LAB_DC49		; set exponent = .X, clear mantissa 4 and 3 and normalise
.ddd7	20 df dd	jsr $dddf		JSR	LAB_DDDF		; convert FAC1 to string
.ddda					LAB_DDDA
.ddda	4c 1e cb	jmp $cb1e		JMP	PRTSTR			; print null terminated string
.dddd					FLTASC
.dddd	a0 01		ldy #$01		LDY	#$01			; set index = 1
.dddf					LAB_DDDF
.dddf	a9 20		lda #$20		LDA	#' '			; character = " " (assume +ve)
.dde1	24 66		bit $66			BIT	FAC1+FAC_SIGN		; test FAC1 sign (b7)
.dde3	10 02		bpl $dde7		BPL	LAB_DDE7		; if +ve skip the - sign set
.dde5	a9 2d		lda #$2d		LDA	#'-'			; else character = "-"
.dde7					LAB_DDE7
.dde7	99 ff 00	sta $00ff,y		STA	BASZPT,Y		; save leading character (" " or "-")
.ddea	85 66		sta $66			STA	FAC1+FAC_SIGN		; save FAC1 sign (b7)
.ddec	84 71		sty $71			STY	FBUFPT			; save the index
.ddee	c8		iny			INY				; increment index
.ddef	a9 30		lda #$30		LDA	#'0'			; set character = "0"
.ddf1	a6 61		ldx $61			LDX	FAC1+FAC_EXPT		; get FAC1 exponent
.ddf3	d0 03		bne $ddf8		BNE	LAB_DDF8		; if FAC1<>0 go convert it
.ddf5	4c 04 df	jmp $df04		JMP	LAB_DF04		; save last character, [EOT] and exit
.ddf8					LAB_DDF8
.ddf8	a9 00		lda #$00		LDA	#$00			; clear (number exponent count)
.ddfa	e0 80		cpx #$80		CPX	#$80			; compare FAC1 exponent with $80 (<1.00000)
.ddfc	f0 02		beq $de00		BEQ	LAB_DE00		; branch if 0.5 <= FAC1 < 1.0
.ddfe	b0 09		bcs $de09		BCS	LAB_DE09		; branch if FAC1=>1
.de00					LAB_DE00
.de00	a9 bd		lda #$bd		LDA	#<LAB_DDBD		; set 1000000000 pointer low byte
.de02	a0 dd		ldy #$dd		LDY	#>LAB_DDBD		; set 1000000000 pointer high byte
.de04	20 28 da	jsr $da28		JSR	TIMES			; do convert .A.Y, FAC1*(.A.Y)
.de07	a9 f7		lda #$f7		LDA	#$F7			; set number exponent count
.de09					LAB_DE09
.de09	85 5d		sta $5d			STA	LAB_5D			; save number exponent count
.de0b					LAB_DE0B
.de0b	a9 b8		lda #$b8		LDA	#<LAB_DDB8		; set 999999999.25 pointer low byte (max before sci note)
.de0d	a0 dd		ldy #$dd		LDY	#>LAB_DDB8		; set 999999999.25 pointer high byte
.de0f	20 5b dc	jsr $dc5b		JSR	CMPFAC			; compare FAC1 with (.A.Y)
.de12	f0 1e		beq $de32		BEQ	LAB_DE32		; exit if FAC1 = (.A.Y)
.de14	10 12		bpl $de28		BPL	LAB_DE28		; go do /10 if FAC1 > (.A.Y)
.de16					LAB_DE16
.de16	a9 b3		lda #$b3		LDA	#<FPC12			; set 99999999.90625 pointer low byte
.de18	a0 dd		ldy #$dd		LDY	#>FPC12			; set 99999999.90625 pointer high byte
.de1a	20 5b dc	jsr $dc5b		JSR	CMPFAC			; compare FAC1 with (.A.Y)
.de1d	f0 02		beq $de21		BEQ	LAB_DE21		; branch if FAC1 = (.A.Y) (allow decimal places)
.de1f	10 0e		bpl $de2f		BPL	LAB_DE2F		; branch if FAC1 > (.A.Y) (no decimal places)
.de21					LAB_DE21
.de21	20 e2 da	jsr $dae2		JSR	MULTEN			; multiply FAC1 by 10
.de24	c6 5d		dec $5d			DEC	LAB_5D			; decrement number exponent count
.de26	d0 ee		bne $de16		BNE	LAB_DE16		; go test again, branch always
.de28					LAB_DE28
.de28	20 fe da	jsr $dafe		JSR	DIVTEN			; divide FAC1 by 10
.de2b	e6 5d		inc $5d			INC	LAB_5D			; increment number exponent count
.de2d	d0 dc		bne $de0b		BNE	LAB_DE0B		; go test again, branch always
.de2f					LAB_DE2F
.de2f	20 49 d8	jsr $d849		JSR	ADD05			; add 0.5 to FAC1 (round FAC1)
.de32					LAB_DE32
.de32	20 9b dc	jsr $dc9b		JSR	FPINT			; convert FAC1 floating to fixed
.de35	a2 01		ldx #$01		LDX	#$01			; set default digits before dp = 1
.de37	a5 5d		lda $5d			LDA	LAB_5D			; get number exponent count
.de39	18		clc			CLC				; clear carry for add
.de3a	69 0a		adc #$0a		ADC	#$0A			; up to 9 digits before point
.de3c	30 09		bmi $de47		BMI	LAB_DE47		; if -ve then 1 digit before dp
.de3e	c9 0b		cmp #$0b		CMP	#$0B			; .A>=$0B if n>=1E9
.de40	b0 06		bcs $de48		BCS	LAB_DE48		; branch if >= $0B
.de42	69 ff		adc #$ff		ADC	#$FF			; take 1 from digit count
.de44	aa		tax			TAX				; copy to .X
.de45	a9 02		lda #$02		LDA	#$02			; set the exponent adjust
.de47					LAB_DE47
.de47	38		sec			SEC				; set carry for subtract
.de48					LAB_DE48
.de48	e9 02		sbc #$02		SBC	#$02			; -2
.de4a	85 5e		sta $5e			STA	EXPCNT			; save the exponent adjust
.de4c	86 5d		stx $5d			STX	LAB_5D			; save digits before dp count
.de4e	8a		txa			TXA				; copy digits before dp count to .A
.de4f	f0 02		beq $de53		BEQ	LAB_DE53		; if no digits before the dp go do the "."
.de51	10 13		bpl $de66		BPL	LAB_DE66		; if there are digits before the dp go do them
.de53					LAB_DE53
.de53	a4 71		ldy $71			LDY	FBUFPT			; get the output string index
.de55	a9 2e		lda #$2e		LDA	#'.'			; character "."
.de57	c8		iny			INY				; increment the index
.de58	99 ff 00	sta $00ff,y		STA	STACK-1,Y		; save the "." to the output string
.de5b	8a		txa			TXA				; copy digits before dp count to .A
.de5c	f0 06		beq $de64		BEQ	LAB_DE64		; if no digits before the dp skip the "0"
.de5e	a9 30		lda #$30		LDA	#'0'			; character "0"
.de60	c8		iny			INY				; increment index
.de61	99 ff 00	sta $00ff,y		STA	STACK-1,Y		; save the "0" to the output string
.de64					LAB_DE64
.de64	84 71		sty $71			STY	FBUFPT			; save the output string index
.de66					LAB_DE66
.de66	a0 00		ldy #$00		LDY	#$00			; clear the powers of 10 index (point to -100,000,000)
.de68					LAB_DE68
.de68	a2 80		ldx #$80		LDX	#$80			; clear the digit, set the test sense
.de6a					LAB_DE6A
.de6a	a5 65		lda $65			LDA	FAC1+FAC_MANT+3		; get FAC1 mantissa 4
.de6c	18		clc			CLC				; clear carry for add
.de6d	79 19 df	adc $df19,y		ADC	FLTCON+3,Y		; add byte 4, least significant
.de70	85 65		sta $65			STA	FAC1+FAC_MANT+3		; save FAC1 mantissa 4
.de72	a5 64		lda $64			LDA	FAC1+FAC_MANT+2		; get FAC1 mantissa 3
.de74	79 18 df	adc $df18,y		ADC	FLTCON+2,Y		; add byte 3
.de77	85 64		sta $64			STA	FAC1+FAC_MANT+2		; save FAC1 mantissa 3
.de79	a5 63		lda $63			LDA	FAC1+FAC_MANT+1		; get FAC1 mantissa 2
.de7b	79 17 df	adc $df17,y		ADC	FLTCON+1,Y		; add byte 2
.de7e	85 63		sta $63			STA	FAC1+FAC_MANT+1		; save FAC1 mantissa 2
.de80	a5 62		lda $62			LDA	FAC1+FAC_MANT		; get FAC1 mantissa 1
.de82	79 16 df	adc $df16,y		ADC	FLTCON+0,Y		; add byte 1, most significant
.de85	85 62		sta $62			STA	FAC1+FAC_MANT		; save FAC1 mantissa 1
.de87	e8		inx			INX				; increment the digit, set the sign on the test sense bit
.de88	b0 04		bcs $de8e		BCS	LAB_DE8E		; if the carry is set go test if the result was positive
.de8a	10 de		bpl $de6a		BPL	LAB_DE6A		; not -ve so try again
.de8c	30 02		bmi $de90		BMI	LAB_DE90		; else done so return the digit
.de8e					LAB_DE8E
.de8e	30 da		bmi $de6a		BMI	LAB_DE6A		; not +ve so try again
.de90					LAB_DE90
.de90	8a		txa			TXA				; copy the digit
.de91	90 04		bcc $de97		BCC	LAB_DE97		; if Cb=0 just use it
.de93	49 ff		eor #$ff		EOR	#$FF			; else make the two's complement ..
.de95	69 0a		adc #$0a		ADC	#$0A			; .. and subtract it from 10
.de97					LAB_DE97
.de97	69 2f		adc #$2f		ADC	#'0'-1			; add "0"-1 to result
.de99	c8		iny			INY				; increment ..
.de9a	c8		iny			INY				; .. index to..
.de9b	c8		iny			INY				; .. next less ..
.de9c	c8		iny			INY				; .. power of ten
.de9d	84 47		sty $47			STY	VARPNT			; save the powers of ten table index
.de9f	a4 71		ldy $71			LDY	FBUFPT			; get output string index
.dea1	c8		iny			INY				; increment output string index
.dea2	aa		tax			TAX				; copy character to .X
.dea3	29 7f		and #$7f		AND	#$7F			; mask out top bit
.dea5	99 ff 00	sta $00ff,y		STA	STACK-1,Y		; save to output string
.dea8	c6 5d		dec $5d			DEC	LAB_5D			; decrement # of characters before the dp
.deaa	d0 06		bne $deb2		BNE	LAB_DEB2		; if still characters to do skip the decimal point
.deac	a9 2e		lda #$2e		LDA	#'.'			; character "."
.deae	c8		iny			INY				; increment output string index
.deaf	99 ff 00	sta $00ff,y		STA	STACK-1,Y		; save to output string
.deb2					LAB_DEB2
.deb2	84 71		sty $71			STY	FBUFPT			; save the output string index
.deb4	a4 47		ldy $47			LDY	VARPNT			; get the powers of ten table index
.deb6	8a		txa			TXA				; get the character back
.deb7	49 ff		eor #$ff		EOR	#$FF			; toggle the test sense bit
.deb9	29 80		and #$80		AND	#$80			; clear the digit
.debb	aa		tax			TAX				; copy it to the new digit
.debc	c0 24		cpy #$24		CPY	#HMSCON-FLTCON
.debe	f0 04		beq $dec4		BEQ	LAB_DEC4		; if at the max exit the digit loop
.dec0	c0 3c		cpy #$3c		CPY	#LAB_DF52-FLTCON
.dec2	d0 a6		bne $de6a		BNE	LAB_DE6A		; loop if not at the max
.dec4					LAB_DEC4
.dec4	a4 71		ldy $71			LDY	FBUFPT			; restore the output string index
.dec6					LAB_DEC6
.dec6	b9 ff 00	lda $00ff,y		LDA	STACK-1,Y		; get character from output string
.dec9	88		dey			DEY				; decrement output string index
.deca	c9 30		cmp #$30		CMP	#'0'			; compare with "0"
.decc	f0 f8		beq $dec6		BEQ	LAB_DEC6		; loop until non "0" character found
.dece	c9 2e		cmp #$2e		CMP	#'.'			; compare with "."
.ded0	f0 01		beq $ded3		BEQ	LAB_DED3		; branch if was dp
.ded2	c8		iny			INY				; increment output string index
.ded3					LAB_DED3
.ded3	a9 2b		lda #$2b		LDA	#'+'			; character "+"
.ded5	a6 5e		ldx $5e			LDX	EXPCNT			; get exponent count
.ded7	f0 2e		beq $df07		BEQ	LAB_DF07		; if zero go set null terminator and exit
.ded9	10 08		bpl $dee3		BPL	LAB_DEE3		; branch if exponent count +ve
.dedb	a9 00		lda #$00		LDA	#$00			; clear .A
.dedd	38		sec			SEC				; set carry for subtract
.dede	e5 5e		sbc $5e			SBC	EXPCNT			; subtract exponent count adjust (convert -ve to +ve)
.dee0	aa		tax			TAX				; copy exponent count to .X
.dee1	a9 2d		lda #$2d		LDA	#'-'			; character "-"
.dee3					LAB_DEE3
.dee3	99 01 01	sta $0101,y		STA	STACK+1,Y		; save to output string
.dee6	a9 45		lda #$45		LDA	#'E'			; character "E"
.dee8	99 00 01	sta $0100,y		STA	STACK,Y			; save exponent sign to output string
.deeb	8a		txa			TXA				; get exponent count back
.deec	a2 2f		ldx #$2f		LDX	#'0'-1			; one less than "0" character
.deee	38		sec			SEC				; set carry for subtract
.deef					LAB_DEEF
.deef	e8		inx			INX				; increment 10's character
.def0	e9 0a		sbc #$0a		SBC	#$0A			; subtract 10 from exponent count
.def2	b0 fb		bcs $deef		BCS	LAB_DEEF		; loop while still >= 0
.def4	69 3a		adc #$3a		ADC	#':'			; add character ":" ($30+$0A, result is 10 less that value)
.def6	99 03 01	sta $0103,y		STA	STACK+3,Y		; save to output string
.def9	8a		txa			TXA				; copy 10's character
.defa	99 02 01	sta $0102,y		STA	STACK+2,Y		; save to output string
.defd	a9 00		lda #$00		LDA	#$00			; set null terminator
.deff	99 04 01	sta $0104,y		STA	STACK+4,Y		; save to output string
.df02	f0 08		beq $df0c		BEQ	LAB_DF0C		; go set string pointer (.A.Y) and exit, branch always
.df04					LAB_DF04
.df04	99 ff 00	sta $00ff,y		STA	STACK-1,Y		; save last character to output string
.df07					LAB_DF07
.df07	a9 00		lda #$00		LDA	#$00			; set null terminator
.df09	99 00 01	sta $0100,y		STA	STACK,Y			; save after last character
.df0c					LAB_DF0C
.df0c	a9 00		lda #$00		LDA	#<STACK			; set result string pointer low byte
.df0e	a0 01		ldy #$01		LDY	#>STACK			; set result string pointer high byte
.df10	60		rts			RTS
.df11					FLP05
>df11	80 00					.byte	$80,$00			; 0.5, first two bytes
.df13					NULLVAR
>df13	00 00 00				.byte	$00,$00,$00		; null return for undefined variables
.df16					FLTCON
>df16	fa 0a 1f 00				.byte	$FA,$0A,$1F,$00 ; -100000000
>df1a	00 98 96 80				.byte	$00,$98,$96,$80 ;  +10000000
>df1e	ff f0 bd c0				.byte	$FF,$F0,$BD,$C0 ;   -1000000
>df22	00 01 86 a0				.byte	$00,$01,$86,$A0 ;    +100000
>df26	ff ff d8 f0				.byte	$FF,$FF,$D8,$F0 ;     -10000
>df2a	00 00 03 e8				.byte	$00,$00,$03,$E8 ;      +1000
>df2e	ff ff ff 9c				.byte	$FF,$FF,$FF,$9C ;	-100
>df32	00 00 00 0a				.byte	$00,$00,$00,$0A ;	 +10
>df36	ff ff ff ff				.byte	$FF,$FF,$FF,$FF ;	  -1
.df3a					HMSCON
>df3a	ff df 0a 80				.byte	$FF,$DF,$0A,$80 ; -2160000	10s hours
>df3e	00 03 4b c0				.byte	$00,$03,$4B,$C0 ;  +216000	    hours
>df42	ff ff 73 60				.byte	$FF,$FF,$73,$60 ;   -36000	10s mins
>df46	00 00 0e 10				.byte	$00,$00,$0E,$10 ;    +3600	    mins
>df4a	ff ff fd a8				.byte	$FF,$FF,$FD,$A8 ;     -600	10s secs
>df4e	00 00 00 3c				.byte	$00,$00,$00,$3C ;      +60	    secs
.df52					LAB_DF52
>df52	bf aa aa aa aa aa aa aa			.byte	$BF,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA
>df5a	aa aa aa aa aa aa aa aa
>df62	aa aa aa aa aa aa aa aa			.byte	$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA
>df6a	aa aa aa aa aa aa aa
.df71					SQR
.df71	20 0c dc	jsr $dc0c		JSR	RFTOA			; round and copy FAC1 to FAC2
.df74	a9 11		lda #$11		LDA	#<FLP05			; set 0.5 pointer low address
.df76	a0 df		ldy #$df		LDY	#>FLP05			; set 0.5 pointer high address
.df78	20 a2 db	jsr $dba2		JSR	LODFAC			; unpack memory (.A.Y) into FAC1
.df7b					EXPONT
.df7b	f0 70		beq $dfed		BEQ	EXP			; perform EXP()
.df7d	a5 69		lda $69			LDA	FAC2+FAC_EXPT		; get FAC2 exponent
.df7f	d0 03		bne $df84		BNE	LAB_DF84		; branch if FAC2<>0
.df81	4c f9 d8	jmp $d8f9		JMP	LAB_D8F9		; clear FAC1 exponent and sign and return
.df84					LAB_DF84
.df84	a2 4e		ldx #$4e		LDX	#<DEFPNT		; set destination pointer low byte
.df86	a0 00		ldy #$00		LDY	#>DEFPNT		; set destination pointer high byte
.df88	20 d4 db	jsr $dbd4		JSR	STORFAC			; pack FAC1 into (.X.Y)
.df8b	a5 6e		lda $6e			LDA	FAC2+FAC_SIGN		; get FAC2 sign (b7)
.df8d	10 0f		bpl $df9e		BPL	LAB_DF9E		; branch if FAC2>0
.df8f	20 cc dc	jsr $dccc		JSR	INT			; perform INT()
.df92	a9 4e		lda #$4e		LDA	#<DEFPNT		; set source pointer low byte
.df94	a0 00		ldy #$00		LDY	#>DEFPNT		; set source pointer high byte
.df96	20 5b dc	jsr $dc5b		JSR	CMPFAC			; compare FAC1 with (.A.Y)
.df99	d0 03		bne $df9e		BNE	LAB_DF9E		; branch if FAC1 <> (.A.Y) to allow Function Call error
.df9b	98		tya			TYA				; clear sign b7
.df9c	a4 07		ldy $07			LDY	CHARAC			; get FAC1 mantissa 4 from INT() function as sign in
.df9e					LAB_DF9E
.df9e	20 fe db	jsr $dbfe		JSR	LAB_DBFE		; save FAC1 sign and copy ABS(FAC2) to FAC1
.dfa1	98		tya			TYA				; copy sign back ..
.dfa2	48		pha			PHA				; .. and save it
.dfa3	20 ea d9	jsr $d9ea		JSR	LOG			; perform LOG()
.dfa6	a9 4e		lda #$4e		LDA	#<DEFPNT		; set pointer low byte
.dfa8	a0 00		ldy #$00		LDY	#>DEFPNT		; set pointer high byte
.dfaa	20 28 da	jsr $da28		JSR	TIMES			; do convert .A.Y, FAC1*(.A.Y)
.dfad	20 ed df	jsr $dfed		JSR	EXP			; perform EXP()
.dfb0	68		pla			PLA				; pull sign from stack
.dfb1	4a		lsr a			LSR				; b0 is to be tested
.dfb2	90 0a		bcc $dfbe		BCC	LAB_DFBE		; if no bit then exit
.dfb4					NEGFAC
.dfb4	a5 61		lda $61			LDA	FAC1+FAC_EXPT		; get FAC1 exponent
.dfb6	f0 06		beq $dfbe		BEQ	LAB_DFBE		; exit if FAC1_e = $00
.dfb8	a5 66		lda $66			LDA	FAC1+FAC_SIGN		; get FAC1 sign (b7)
.dfba	49 ff		eor #$ff		EOR	#$FF			; complement it
.dfbc	85 66		sta $66			STA	FAC1+FAC_SIGN		; save FAC1 sign (b7)
.dfbe					LAB_DFBE
.dfbe	60		rts			RTS
.dfbf					EXPCON
>dfbf	81 38 aa 3b 29				.byte	$81,$38,$AA,$3B,$29	; 1.443
.dfc4					LAB_DFC4
>dfc4	07					.byte	$07			; series count
>dfc5	71 34 58 3e 56				.byte	$71,$34,$58,$3E,$56	; 2.14987637E-5
>dfca	74 16 7e b3 1b				.byte	$74,$16,$7E,$B3,$1B	; 1.43523140E-4
>dfcf	77 2f ee e3 85				.byte	$77,$2F,$EE,$E3,$85	; 1.34226348E-3
>dfd4	7a 1d 84 1c 2a				.byte	$7A,$1D,$84,$1C,$2A	; 9.61401701E-3
>dfd9	7c 63 59 58 0a				.byte	$7C,$63,$59,$58,$0A	; 5.55051269E-2
>dfde	7e 75 fd e7 c6				.byte	$7E,$75,$FD,$E7,$C6	; 2.40226385E-1
>dfe3	80 31 72 18 10				.byte	$80,$31,$72,$18,$10	; 6.93147186E-1
>dfe8	81 00 00 00 00				.byte	$81,$00,$00,$00,$00	; 1.00000000
.dfed					EXP
.dfed	a9 bf		lda #$bf		LDA	#<EXPCON		; set 1.443 pointer low byte
.dfef	a0 df		ldy #$df		LDY	#>EXPCON		; set 1.443 pointer high byte
.dff1	20 28 da	jsr $da28		JSR	TIMES			; do convert .A.Y, FAC1*(.A.Y)
.dff4	a5 70		lda $70			LDA	FACOV			; get FAC1 rounding byte
.dff6	69 50		adc #$50		ADC	#$50			; +$50/$100
.dff8	90 03		bcc $dffd		BCC	LAB_DFFD		; skip rounding if no carry
.dffa	20 23 dc	jsr $dc23		JSR	LAB_DC23		; round FAC1 (no check)
.dffd					LAB_DFFD
.dffd	85 56		sta $56			STA	JMPER+2			; save FAC2 rounding byte
.dfff	20 0f dc	jsr $dc0f		JSR	FTOA			; copy FAC1 to FAC2
.e002	a5 61		lda $61			LDA	FAC1+FAC_EXPT		; get FAC1 exponent
.e004	c9 88		cmp #$88		CMP	#$88			; compare with EXP limit (256)
.e006	90 03		bcc $e00b		BCC	LAB_E00B		; branch if less
.e008					LAB_E008
.e008	20 d4 da	jsr $dad4		JSR	LAB_DAD4		; handle overflow and underflow
.e00b					LAB_E00B
.e00b	20 cc dc	jsr $dccc		JSR	INT			; perform INT()
.e00e	a5 07		lda $07			LDA	CHARAC			; get mantissa 4 from INT()
.e010	18		clc			CLC				; clear carry for add
.e011	69 81		adc #$81		ADC	#$81			; normalise +1
.e013	f0 f3		beq $e008		BEQ	LAB_E008		; if $00 result has overflowed so go handle it
.e015	38		sec			SEC				; set carry for subtract
.e016	e9 01		sbc #$01		SBC	#$01			; exponent now correct
.e018	48		pha			PHA				; save FAC2 exponent
.e019	a2 05		ldx #$05		LDX	#$05			; 4 bytes to do
.e01b					LAB_E01B
.e01b	b5 69		lda $69,x		LDA	FAC2,X			; get FAC2,X
.e01d	b4 61		ldy $61,x		LDY	FAC1,X			; get FAC1,X
.e01f	95 61		sta $61,x		STA	FAC1,X			; save FAC1,X
.e021	94 69		sty $69,x		STY	FAC2,X			; save FAC2,X
.e023	ca		dex			DEX				; decrement count/index
.e024	10 f5		bpl $e01b		BPL	LAB_E01B		; loop if not all done
.e026	a5 56		lda $56			LDA	JMPER+2			; get FAC2 rounding byte
.e028	85 70		sta $70			STA	FACOV			; save as FAC1 rounding byte
.e02a	20 53 d8	jsr $d853		JSR	SUB			; perform subtraction, FAC2 from FAC1
.e02d	20 b4 df	jsr $dfb4		JSR	NEGFAC			; do - FAC1
.e030	a9 c4		lda #$c4		LDA	#<LAB_DFC4		; set counter pointer low byte
.e032	a0 df		ldy #$df		LDY	#>LAB_DFC4		; set counter pointer high byte
.e034	20 56 e0	jsr $e056		JSR	SER2			; go do series evaluation
.e037	a9 00		lda #$00		LDA	#$00			; clear .A
.e039	85 6f		sta $6f			STA	ARISGN			; clear sign compare (FAC1 XOR FAC2)
.e03b	68		pla			PLA				; pull the saved FAC2 exponent
.e03c	20 b9 da	jsr $dab9		JSR	LAB_DAB9		; test and adjust accumulators
.e03f	60		rts			RTS
.e040					SEREVL
.e040	85 71		sta $71			STA	FBUFPT			; save count pointer low byte
.e042	84 72		sty $72			STY	FBUFPT+1		; save count pointer high byte
.e044	20 ca db	jsr $dbca		JSR	FACTF1			; pack FAC1 into LAB_57
.e047	a9 57		lda #$57		LDA	#<TEMPF3		; set pointer low byte (.Y already $00)
.e049	20 28 da	jsr $da28		JSR	TIMES			; do convert .A.Y, FAC1*(.A.Y)
.e04c	20 5a e0	jsr $e05a		JSR	LAB_E05A		; go do series evaluation
.e04f	a9 57		lda #$57		LDA	#<TEMPF3		; pointer to original # low byte
.e051	a0 00		ldy #$00		LDY	#>TEMPF3		; pointer to original # high byte
.e053	4c 28 da	jmp $da28		JMP	TIMES			; do convert .A.Y, FAC1*(.A.Y)
.e056					SER2
.e056	85 71		sta $71			STA	FBUFPT			; save count pointer low byte
.e058	84 72		sty $72			STY	FBUFPT+1		; save count pointer high byte
.e05a					LAB_E05A
.e05a	20 c7 db	jsr $dbc7		JSR	FACTF2			; pack FAC1 into LAB_5C
.e05d	b1 71		lda ($71),y		LDA	(FBUFPT),Y		; get constants count
.e05f	85 67		sta $67			STA	SGNFLG			; save constants count
.e061	a4 71		ldy $71			LDY	FBUFPT			; get count pointer low byte
.e063	c8		iny			INY				; increment it (now constants pointer)
.e064	98		tya			TYA				; copy it
.e065	d0 02		bne $e069		BNE	LAB_E069		; skip next if no overflow
.e067	e6 72		inc $72			INC	FBUFPT+1		; else increment high byte
.e069					LAB_E069
.e069	85 71		sta $71			STA	FBUFPT			; save low byte
.e06b	a4 72		ldy $72			LDY	FBUFPT+1		; get high byte
.e06d					LAB_E06D
.e06d	20 28 da	jsr $da28		JSR	TIMES			; do convert .A.Y, FAC1*(.A.Y)
.e070	a5 71		lda $71			LDA	FBUFPT			; get constants pointer low byte
.e072	a4 72		ldy $72			LDY	FBUFPT+1		; get constants pointer high byte
.e074	18		clc			CLC				; clear carry for add
.e075	69 05		adc #$05		ADC	#$05			; +5 to low pointer (5 bytes per constant)
.e077	90 01		bcc $e07a		BCC	LAB_E07A		; skip next if no overflow
.e079	c8		iny			INY				; increment high byte
.e07a					LAB_E07A
.e07a	85 71		sta $71			STA	FBUFPT			; save pointer low byte
.e07c	84 72		sty $72			STY	FBUFPT+1		; save pointer high byte
.e07e	20 67 d8	jsr $d867		JSR	LAPLUS			; add (.A.Y) to FAC1
.e081	a9 5c		lda #$5c		LDA	#<LAB_5C		; set pointer low byte to partial
.e083	a0 00		ldy #$00		LDY	#>LAB_5C		; set pointer high byte to partial
.e085	c6 67		dec $67			DEC	SGNFLG			; decrement constants count
.e087	d0 e4		bne $e06d		BNE	LAB_E06D		; loop until all done
.e089	60		rts			RTS
.e08a					RNDC1
>e08a	98 35 44 7a 00				.byte	$98,$35,$44,$7A,$00
.e08f					LAB_E08F
>e08f	68 28 b1 46 00				.byte	$68,$28,$B1,$46,$00
.e094					RND
.e094	20 2b dc	jsr $dc2b		JSR	SGNFAC			; get FAC1 sign
.e097	30 37		bmi $e0d0		BMI	LAB_E0D0		; if n<0 copy byte swapped FAC1 into RND() seed
.e099	d0 20		bne $e0bb		BNE	LAB_E0BB		; if n>0 get next number in RND() sequence
.e09b	20 f3 ff	jsr $fff3		JSR	IOBASE			; return base address of I/O devices
.e09e	86 22		stx $22			STX	INDEX			; save pointer low byte
.e0a0	84 23		sty $23			STY	INDEX+1			; save pointer high byte
.e0a2	a0 04		ldy #$04		LDY	#$04			; set index to T1 low byte
.e0a4	b1 22		lda ($22),y		LDA	(INDEX),Y		; get T1 low byte
.e0a6	85 62		sta $62			STA	FAC1+FAC_MANT		; save FAC1 mantissa 1
.e0a8	c8		iny			INY				; increment index
.e0a9	b1 22		lda ($22),y		LDA	(INDEX),Y		; get T1 high byte
.e0ab	85 64		sta $64			STA	FAC1+FAC_MANT+2		; save FAC1 mantissa 3
.e0ad	a0 08		ldy #$08		LDY	#$08			; set index to T2 low byte
.e0af	b1 22		lda ($22),y		LDA	(INDEX),Y		; get T2 low byte
.e0b1	85 63		sta $63			STA	FAC1+FAC_MANT+1		; save FAC1 mantissa 2
.e0b3	c8		iny			INY				; increment index
.e0b4	b1 22		lda ($22),y		LDA	(INDEX),Y		; get T2 high byte
.e0b6	85 65		sta $65			STA	FAC1+FAC_MANT+3		; save FAC1 mantissa 4
.e0b8	4c e0 e0	jmp $e0e0		JMP	LAB_E0E0		; set exponent and exit
.e0bb					LAB_E0BB
.e0bb	a9 8b		lda #$8b		LDA	#<RNDX			; set seed pointer low address
.e0bd	a0 00		ldy #$00		LDY	#>RNDX			; set seed pointer high address
.e0bf	20 a2 db	jsr $dba2		JSR	LODFAC			; unpack memory (.A.Y) into FAC1
.e0c2	a9 8a		lda #$8a		LDA	#<RNDC1			; set 11879546 pointer low byte
.e0c4	a0 e0		ldy #$e0		LDY	#>RNDC1			; set 11879546 pointer high byte
.e0c6	20 28 da	jsr $da28		JSR	TIMES			; do convert .A.Y, FAC1*(.A.Y)
.e0c9	a9 8f		lda #$8f		LDA	#<LAB_E08F		; set 3.927677739E-8 pointer low byte
.e0cb	a0 e0		ldy #$e0		LDY	#>LAB_E08F		; set 3.927677739E-8 pointer high byte
.e0cd	20 67 d8	jsr $d867		JSR	LAPLUS			; add (.A.Y) to FAC1
.e0d0					LAB_E0D0
.e0d0	a6 65		ldx $65			LDX	FAC1+FAC_MANT+3		; get FAC1 mantissa 4
.e0d2	a5 62		lda $62			LDA	FAC1+FAC_MANT		; get FAC1 mantissa 1
.e0d4	85 65		sta $65			STA	FAC1+FAC_MANT+3		; save FAC1 mantissa 4
.e0d6	86 62		stx $62			STX	FAC1+FAC_MANT		; save FAC1 mantissa 1
.e0d8	a6 63		ldx $63			LDX	FAC1+FAC_MANT+1		; get FAC1 mantissa 2
.e0da	a5 64		lda $64			LDA	FAC1+FAC_MANT+2		; get FAC1 mantissa 3
.e0dc	85 63		sta $63			STA	FAC1+FAC_MANT+1		; save FAC1 mantissa 2
.e0de	86 64		stx $64			STX	FAC1+FAC_MANT+2		; save FAC1 mantissa 3
.e0e0					LAB_E0E0
.e0e0	a9 00		lda #$00		LDA	#$00			; clear byte
.e0e2	85 66		sta $66			STA	FAC1+FAC_SIGN		; clear FAC1 sign (always +ve)
.e0e4	a5 61		lda $61			LDA	FAC1+FAC_EXPT		; get FAC1 exponent
.e0e6	85 70		sta $70			STA	FACOV			; save FAC1 rounding byte
.e0e8	a9 80		lda #$80		LDA	#$80			; set exponent = $80
.e0ea	85 61		sta $61			STA	FAC1+FAC_EXPT		; save FAC1 exponent
.e0ec	20 d7 d8	jsr $d8d7		JSR	LAB_D8D7		; normalise FAC1
.e0ef	a2 8b		ldx #$8b		LDX	#<RNDX			; set seed pointer low address
.e0f1	a0 00		ldy #$00		LDY	#>RNDX			; set seed pointer high address
.e0f3					LAB_E0F3
.e0f3	4c d4 db	jmp $dbd4		JMP	STORFAC			; pack FAC1 into (.X.Y)
.e0f6					PATCHBAS
.e0f6	c9 f0		cmp #$f0		CMP	#$F0			; compare error with $F0
.e0f8	d0 07		bne $e101		BNE	LAB_E101		; branch if not $F0
.e0fa	84 38		sty $38			STY	MEMSIZ+1		; set end of memory high byte
.e0fc	86 37		stx $37			STX	MEMSIZ			; set end of memory low byte
.e0fe	4c 63 c6	jmp $c663		JMP	LAB_C663		; clear from start to end and return
.e101					LAB_E101
.e101	aa		tax			TAX				; copy error #
.e102	d0 02		bne $e106		BNE	LAB_E106		; branch if not $00
.e104	a2 1e		ldx #$1e		LDX	#ER_BREAK		; else error $1E, break error
.e106					LAB_E106
.e106	4c 37 c4	jmp $c437		JMP	ERROR			; do error #.X then warm start
.e109					LAB_E109
.e109	20 d2 ff	jsr $ffd2		JSR	CHROUT			; output character to channel
.e10c	b0 e8		bcs $e0f6		BCS	PATCHBAS		; if error go handle BASIC I/O error
.e10e	60		rts			RTS
.e10f					LAB_E10F
.e10f	20 cf ff	jsr $ffcf		JSR	CHRIN			; input character from channel
.e112	b0 e2		bcs $e0f6		BCS	PATCHBAS		; if error go handle BASIC I/O error
.e114	60		rts			RTS
.e115					LAB_E115
.e115	20 c9 ff	jsr $ffc9		JSR	CHKOUT			; open channel for output
.e118	b0 dc		bcs $e0f6		BCS	PATCHBAS		; if error go handle BASIC I/O error
.e11a	60		rts			RTS
.e11b					LAB_E11B
.e11b	20 c6 ff	jsr $ffc6		JSR	CHKIN			; open channel for input
.e11e	b0 d6		bcs $e0f6		BCS	PATCHBAS		; if error go handle BASIC I/O error
.e120	60		rts			RTS
.e121					LAB_E121
.e121	20 e4 ff	jsr $ffe4		JSR	GETIN			; get character from input device
.e124	b0 d0		bcs $e0f6		BCS	PATCHBAS		; if error go handle BASIC I/O error
.e126	60		rts			RTS
.e127					SYSTEM
.e127	20 8a cd	jsr $cd8a		JSR	TYPCHK			; evaluate expression and check is numeric, else do
.e12a	20 f7 d7	jsr $d7f7		JSR	MAKADR			; convert FAC1 to integer in temporary integer
.e12d	a9 e1		lda #$e1		LDA	#>LAB_E144-1		; get return address high byte
.e12f	48		pha			PHA				; push as return address
.e130	a9 43		lda #$43		LDA	#<LAB_E144-1		; get return address low byte
.e132	48		pha			PHA				; push as return address
.e133	ad 0f 03	lda $030f		LDA	SPREG			; get saved status register
.e136	48		pha			PHA				; put on stack
.e137	ad 0c 03	lda $030c		LDA	SAREG			; get saved .A
.e13a	ae 0d 03	ldx $030d		LDX	SXREG			; get saved .X
.e13d	ac 0e 03	ldy $030e		LDY	SYREG			; get saved .Y
.e140	28		plp			PLP				; pull processor status
.e141	6c 14 00	jmp ($0014)		JMP	(LINNUM)		; call SYS address
.e144					LAB_E144
.e144	08		php			PHP				; save status
.e145	8d 0c 03	sta $030c		STA	SAREG			; save returned .A
.e148	8e 0d 03	stx $030d		STX	SXREG			; save returned .X
.e14b	8c 0e 03	sty $030e		STY	SYREG			; save returned .Y
.e14e	68		pla			PLA				; restore saved status
.e14f	8d 0f 03	sta $030f		STA	SPREG			; save status
.e152	60		rts			RTS
.e153					BSAVE
.e153	20 d1 e1	jsr $e1d1		JSR	PARSL			; get parameters for LOAD/SAVE
.e156	a6 2d		ldx $2d			LDX	VARTAB			; get start of variables low byte
.e158	a4 2e		ldy $2e			LDY	VARTAB+1		; get start of variables high byte
.e15a	a9 2b		lda #$2b		LDA	#TXTTAB			; index to start of program memory
.e15c	20 d8 ff	jsr $ffd8		JSR	SAVE			; save RAM to device, .A = index to start address, .X.Y = end
.e15f	b0 95		bcs $e0f6		BCS	PATCHBAS		; if error go handle BASIC I/O error
.e161	60		rts			RTS
.e162					BVERIF
.e162	a9 01		lda #$01		LDA	#$01			; flag verify
>e164	2c					.byte	$2C			; makes next line BIT $00A9
.e165					BLOAD
.e165	a9 00		lda #$00		LDA	#$00			; flag load
.e167	85 0a		sta $0a			STA	VERCHK			; set load/verify flag
.e169	20 d1 e1	jsr $e1d1		JSR	PARSL			; get parameters for LOAD/SAVE
.e16c	a5 0a		lda $0a			LDA	VERCHK			; get load/verify flag
.e16e	a6 2b		ldx $2b			LDX	TXTTAB			; get start of memory low byte
.e170	a4 2c		ldy $2c			LDY	TXTTAB+1		; get start of memory high byte
.e172	20 d5 ff	jsr $ffd5		JSR	LOAD			; load RAM from a device
.e175	b0 57		bcs $e1ce		BCS	LAB_E1CE		; if error go handle BASIC I/O error
.e177	a5 0a		lda $0a			LDA	VERCHK			; get load/verify flag
.e179	f0 1a		beq $e195		BEQ	LAB_E195		; branch if load
.e17b	a2 1c		ldx #$1c		LDX	#ER_VERIFY		; error $1C, verify error
.e17d	20 b7 ff	jsr $ffb7		JSR	READST			; read I/O status word
.e180	29 10		and #$10		AND	#$10			; mask for tape read error
.e182	f0 03		beq $e187		BEQ	LAB_E187		; branch if no read error
.e184	4c 37 c4	jmp $c437		JMP	ERROR			; do error #.X then warm start
.e187					LAB_E187
.e187	a5 7a		lda $7a			LDA	CHRGOT+1		; get BASIC execute pointer low byte
.e189	c9 02		cmp #$02		CMP	#>BUF			; compare with input buffer high byte
.e18b	f0 07		beq $e194		BEQ	LAB_E194		; if immediate mode skip "OK" prompt
.e18d	a9 64		lda #$64		LDA	#<OKSTR			; set "OK" pointer low byte
.e18f	a0 c3		ldy #$c3		LDY	#>OKSTR			; set "OK" pointer high byte
.e191	4c 1e cb	jmp $cb1e		JMP	PRTSTR			; print null terminated string
.e194					LAB_E194
.e194	60		rts			RTS
.e195					LAB_E195
.e195	20 b7 ff	jsr $ffb7		JSR	READST			; read I/O status word
.e198	29 bf		and #$bf		AND	#$BF			; mask x0xx xxxx, all except EOF
.e19a	f0 05		beq $e1a1		BEQ	LAB_E1A1		; branch if no errors
.e19c	a2 1d		ldx #$1d		LDX	#ER_LOAD		; error $1D, load error
.e19e	4c 37 c4	jmp $c437		JMP	ERROR			; do error #.X then warm start
.e1a1					LAB_E1A1
.e1a1	a5 7b		lda $7b			LDA	CHRGOT+2		; get BASIC execute pointer high byte
.e1a3	c9 02		cmp #$02		CMP	#>BUF			; compare with input buffer high byte
.e1a5	d0 0e		bne $e1b5		BNE	LAB_E1B5		; branch if not immediate mode
.e1a7	86 2d		stx $2d			STX	VARTAB			; set start of variables low byte
.e1a9	84 2e		sty $2e			STY	VARTAB+1		; set start of variables high byte
.e1ab	a9 76		lda #$76		LDA	#<READYSTR		; set "READY." pointer low byte
.e1ad	a0 c3		ldy #$c3		LDY	#>READYSTR		; set "READY." pointer high byte
.e1af	20 1e cb	jsr $cb1e		JSR	PRTSTR			; print null terminated string
.e1b2	4c 2a c5	jmp $c52a		JMP	LAB_C52A		; reset execution, clear variables, flush stack,
.e1b5					LAB_E1B5
.e1b5	20 8e c6	jsr $c68e		JSR	STXTPT			; set BASIC execute pointer to start of memory - 1
.e1b8	4c 76 e4	jmp $e476		JMP	PATCHER			; rebuild BASIC line chaining, do RESTORE and return
.e1bb					BOPEN
.e1bb	20 16 e2	jsr $e216		JSR	PAROC			; get parameters for OPEN/CLOSE
.e1be	20 c0 ff	jsr $ffc0		JSR	OPEN			; open a logical file
.e1c1	b0 0b		bcs $e1ce		BCS	LAB_E1CE		; branch if error
.e1c3	60		rts			RTS
.e1c4					BCLOSE
.e1c4	20 16 e2	jsr $e216		JSR	PAROC			; get parameters for OPEN/CLOSE
.e1c7	a5 49		lda $49			LDA	FORPNT			; get logical file number
.e1c9	20 c3 ff	jsr $ffc3		JSR	CLOSE			; close a specified logical file
.e1cc	90 c6		bcc $e194		BCC	LAB_E194		; exit if no error
.e1ce					LAB_E1CE
.e1ce	4c f6 e0	jmp $e0f6		JMP	PATCHBAS		; go handle BASIC I/O error
.e1d1					PARSL
.e1d1	a9 00		lda #$00		LDA	#$00			; clear file name length
.e1d3	20 bd ff	jsr $ffbd		JSR	SETNAM			; clear filename
.e1d6	a2 01		ldx #$01		LDX	#$01			; set default device number, cassette
.e1d8	a0 00		ldy #$00		LDY	#$00			; set default command
.e1da	20 ba ff	jsr $ffba		JSR	SETLFS			; set logical, first and second addresses
.e1dd	20 03 e2	jsr $e203		JSR	IFCHRG			; exit function if [EOT] or ":"
.e1e0	20 54 e2	jsr $e254		JSR	LAB_E254		; set filename
.e1e3	20 03 e2	jsr $e203		JSR	IFCHRG			; exit function if [EOT] or ":"
.e1e6	20 fd e1	jsr $e1fd		JSR	LAB_E1FD		; scan and get byte, else do syntax error then warm start
.e1e9	a0 00		ldy #$00		LDY	#$00			; clear command
.e1eb	86 49		stx $49			STX	FORPNT			; save device number
.e1ed	20 ba ff	jsr $ffba		JSR	SETLFS			; set logical, first and second addresses
.e1f0	20 03 e2	jsr $e203		JSR	IFCHRG			; exit function if [EOT] or ":"
.e1f3	20 fd e1	jsr $e1fd		JSR	LAB_E1FD		; scan and get byte, else do syntax error then warm start
.e1f6	8a		txa			TXA				; copy command to .A
.e1f7	a8		tay			TAY				; copy command to .Y
.e1f8	a6 49		ldx $49			LDX	FORPNT			; get device number back
.e1fa	4c ba ff	jmp $ffba		JMP	SETLFS			; set logical, first and second addresses and return
.e1fd					LAB_E1FD
.e1fd	20 0b e2	jsr $e20b		JSR	SKPCOM			; scan for ",byte", else do syntax error then warm start
.e200	4c 9e d7	jmp $d79e		JMP	LAB_D79E		; get byte parameter and return
.e203					IFCHRG
.e203	20 79 00	jsr $0079		JSR	CHRGOT			; scan memory
.e206	d0 02		bne $e20a		BNE	LAB_E20A		; branch if not [EOL] or ":"
.e208	68		pla			PLA				; dump return address low byte
.e209	68		pla			PLA				; dump return address high byte
.e20a					LAB_E20A
.e20a	60		rts			RTS
.e20b					SKPCOM
.e20b	20 fd ce	jsr $cefd		JSR	COMCHK			; scan for ",", else do syntax error then warm start
.e20e					CHRERR
.e20e	20 79 00	jsr $0079		JSR	CHRGOT			; scan memory
.e211	d0 f7		bne $e20a		BNE	LAB_E20A		; exit if following byte
.e213	4c 08 cf	jmp $cf08		JMP	LAB_CF08		; else do syntax error then warm start
.e216					PAROC
.e216	a9 00		lda #$00		LDA	#$00			; clear file name length
.e218	20 bd ff	jsr $ffbd		JSR	SETNAM			; clear filename
.e21b	20 0e e2	jsr $e20e		JSR	CHRERR			; scan for valid byte, else do syntax error then warm start
.e21e	20 9e d7	jsr $d79e		JSR	LAB_D79E		; get byte parameter, logical file number
.e221	86 49		stx $49			STX	FORPNT			; save logical file number
.e223	8a		txa			TXA				; copy logical file number to .A
.e224	a2 01		ldx #$01		LDX	#$01			; set default device number, cassette
.e226	a0 00		ldy #$00		LDY	#$00			; set default command
.e228	20 ba ff	jsr $ffba		JSR	SETLFS			; set logical, first and second addresses
.e22b	20 03 e2	jsr $e203		JSR	IFCHRG			; exit function if [EOT] or ":"
.e22e	20 fd e1	jsr $e1fd		JSR	LAB_E1FD		; scan and get byte, else do syntax error then warm start
.e231	86 4a		stx $4a			STX	FORPNT+1		; save device number
.e233	a0 00		ldy #$00		LDY	#$00			; clear command
.e235	a5 49		lda $49			LDA	FORPNT			; get logical file number
.e237	e0 03		cpx #$03		CPX	#$03			; compare device number with screen
.e239	90 01		bcc $e23c		BCC	LAB_E23C		; branch if less than screen
.e23b	88		dey			DEY				; else decrement command
.e23c					LAB_E23C
.e23c	20 ba ff	jsr $ffba		JSR	SETLFS			; set logical, first and second addresses
.e23f	20 03 e2	jsr $e203		JSR	IFCHRG			; exit function if [EOT] or ":"
.e242	20 fd e1	jsr $e1fd		JSR	LAB_E1FD		; scan and get byte, else do syntax error then warm start
.e245	8a		txa			TXA				; copy command to .A
.e246	a8		tay			TAY				; copy command to .Y
.e247	a6 4a		ldx $4a			LDX	FORPNT+1		; get device number
.e249	a5 49		lda $49			LDA	FORPNT			; get logical file number
.e24b	20 ba ff	jsr $ffba		JSR	SETLFS			; set logical, first and second addresses
.e24e	20 03 e2	jsr $e203		JSR	IFCHRG			; exit function if [EOT] or ":"
.e251	20 0b e2	jsr $e20b		JSR	SKPCOM			; scan for ",byte", else do syntax error then warm start
.e254					LAB_E254
.e254	20 9e cd	jsr $cd9e		JSR	FRMEVL			; evaluate expression
.e257	20 a3 d6	jsr $d6a3		JSR	DELST			; evaluate string
.e25a	a6 22		ldx $22			LDX	INDEX			; get string pointer low byte
.e25c	a4 23		ldy $23			LDY	INDEX+1			; get string pointer high byte
.e25e	4c bd ff	jmp $ffbd		JMP	SETNAM			; set filename and return
.e261					COS
.e261	a9 dd		lda #$dd		LDA	#<FPC20			; set pi/2 pointer low byte
.e263	a0 e2		ldy #$e2		LDY	#>FPC20			; set pi/2 pointer high byte
.e265	20 67 d8	jsr $d867		JSR	LAPLUS			; add (.A.Y) to FAC1
.e268					SIN
.e268	20 0c dc	jsr $dc0c		JSR	RFTOA			; round and copy FAC1 to FAC2
.e26b	a9 e2		lda #$e2		LDA	#<LAB_E2E2		; set 2*pi pointer low byte
.e26d	a0 e2		ldy #$e2		LDY	#>LAB_E2E2		; set 2*pi pointer high byte
.e26f	a6 6e		ldx $6e			LDX	FAC2+FAC_SIGN		; get FAC2 sign (b7)
.e271	20 07 db	jsr $db07		JSR	LAB_DB07		; divide by (.A.Y) (.X=sign)
.e274	20 0c dc	jsr $dc0c		JSR	RFTOA			; round and copy FAC1 to FAC2
.e277	20 cc dc	jsr $dccc		JSR	INT			; perform INT()
.e27a	a9 00		lda #$00		LDA	#$00			; clear byte
.e27c	85 6f		sta $6f			STA	ARISGN			; clear sign compare (FAC1 XOR FAC2)
.e27e	20 53 d8	jsr $d853		JSR	SUB			; perform subtraction, FAC2 from FAC1
.e281	a9 e7		lda #$e7		LDA	#<LAB_E2E7		; set 0.25 pointer low byte
.e283	a0 e2		ldy #$e2		LDY	#>LAB_E2E7		; set 0.25 pointer high byte
.e285	20 50 d8	jsr $d850		JSR	LAMIN			; perform subtraction, FAC1 from (.A.Y)
.e288	a5 66		lda $66			LDA	FAC1+FAC_SIGN		; get FAC1 sign (b7)
.e28a	48		pha			PHA				; save FAC1 sign
.e28b	10 0d		bpl $e29a		BPL	LAB_E29A		; branch if +ve
.e28d	20 49 d8	jsr $d849		JSR	ADD05			; add 0.5 to FAC1 (round FAC1)
.e290	a5 66		lda $66			LDA	FAC1+FAC_SIGN		; get FAC1 sign (b7)
.e292	30 09		bmi $e29d		BMI	LAB_E29D		; branch if -ve
.e294	a5 12		lda $12			LDA	TANSGN			; get the comparison evaluation flag
.e296	49 ff		eor #$ff		EOR	#$FF			; toggle flag
.e298	85 12		sta $12			STA	TANSGN			; save the comparison evaluation flag
.e29a					LAB_E29A
.e29a	20 b4 df	jsr $dfb4		JSR	NEGFAC			; do - FAC1
.e29d					LAB_E29D
.e29d	a9 e7		lda #$e7		LDA	#<LAB_E2E7		; set 0.25 pointer low byte
.e29f	a0 e2		ldy #$e2		LDY	#>LAB_E2E7		; set 0.25 pointer high byte
.e2a1	20 67 d8	jsr $d867		JSR	LAPLUS			; add (.A.Y) to FAC1
.e2a4	68		pla			PLA				; restore FAC1 sign
.e2a5	10 03		bpl $e2aa		BPL	LAB_E2AA		; branch if was +ve
.e2a7	20 b4 df	jsr $dfb4		JSR	NEGFAC			; do - FAC1
.e2aa					LAB_E2AA
.e2aa	a9 ec		lda #$ec		LDA	#<LAB_E2EC		; set pointer low byte to counter
.e2ac	a0 e2		ldy #$e2		LDY	#>LAB_E2EC		; set pointer high byte to counter
.e2ae	4c 40 e0	jmp $e040		JMP	SEREVL			; ^2 then series evaluation and return
.e2b1					TAN
.e2b1	20 ca db	jsr $dbca		JSR	FACTF1			; pack FAC1 into LAB_57
.e2b4	a9 00		lda #$00		LDA	#$00			; clear .A
.e2b6	85 12		sta $12			STA	TANSGN			; clear the comparison evaluation flag
.e2b8	20 68 e2	jsr $e268		JSR	SIN			; perform SIN()
.e2bb	a2 4e		ldx #$4e		LDX	#<DEFPNT		; set sin(n) pointer low byte
.e2bd	a0 00		ldy #$00		LDY	#>DEFPNT		; set sin(n) pointer high byte
.e2bf	20 f3 e0	jsr $e0f3		JSR	LAB_E0F3		; pack FAC1 into (.X.Y)
.e2c2	a9 57		lda #$57		LDA	#<TEMPF3		; set n pointer low byte
.e2c4	a0 00		ldy #$00		LDY	#>TEMPF3		; set n pointer high byte
.e2c6	20 a2 db	jsr $dba2		JSR	LODFAC			; unpack memory (.A.Y) into FAC1
.e2c9	a9 00		lda #$00		LDA	#$00			; clear byte
.e2cb	85 66		sta $66			STA	FAC1+FAC_SIGN		; clear FAC1 sign (b7)
.e2cd	a5 12		lda $12			LDA	TANSGN			; get the comparison evaluation flag
.e2cf	20 d9 e2	jsr $e2d9		JSR	LAB_E2D9		; save flag and go do series evaluation
.e2d2	a9 4e		lda #$4e		LDA	#<DEFPNT		; set sin(n) pointer low byte
.e2d4	a0 00		ldy #$00		LDY	#>DEFPNT		; set sin(n) pointer high byte
.e2d6	4c 0f db	jmp $db0f		JMP	LADIV			; convert .A.Y and do (.A.Y)/FAC1
.e2d9					LAB_E2D9
.e2d9	48		pha			PHA				; save comparison flag
.e2da	4c 9a e2	jmp $e29a		JMP	LAB_E29A		; add 0.25, ^2 then series evaluation
.e2dd					FPC20
>e2dd	81 49 0f da a2				.byte	$81,$49,$0F,$DA,$A2	; 1.570796371, pi/2, as floating number
.e2e2					LAB_E2E2
>e2e2	83 49 0f da a2				.byte	$83,$49,$0F,$DA,$A2	; 6.28319, 2*pi, as floating number
.e2e7					LAB_E2E7
>e2e7	7f 00 00 00 00				.byte	$7F,$00,$00,$00,$00	; 0.25
.e2ec					LAB_E2EC
>e2ec	05					.byte	$05			; series counter
>e2ed	84 e6 1a 2d 1b				.byte	$84,$E6,$1A,$2D,$1B	; -14.3813907
>e2f2	86 28 07 fb f8				.byte	$86,$28,$07,$FB,$F8	;  42.0077971
>e2f7	87 99 68 89 01				.byte	$87,$99,$68,$89,$01	; -76.7041703
>e2fc	87 23 35 df e1				.byte	$87,$23,$35,$DF,$E1	;  81.6052237
>e301	86 a5 5d e7 28				.byte	$86,$A5,$5D,$E7,$28	; -41.3417021
>e306	83 49 0f da a2				.byte	$83,$49,$0F,$DA,$A2	;  6.28318531
.e30b					ATN
.e30b	a5 66		lda $66			LDA	FAC1+FAC_SIGN		; get FAC1 sign (b7)
.e30d	48		pha			PHA				; save sign
.e30e	10 03		bpl $e313		BPL	LAB_E313		; branch if +ve
.e310	20 b4 df	jsr $dfb4		JSR	NEGFAC			; else do - FAC1
.e313					LAB_E313
.e313	a5 61		lda $61			LDA	FAC1+FAC_EXPT		; get FAC1 exponent
.e315	48		pha			PHA				; push exponent
.e316	c9 81		cmp #$81		CMP	#$81			; compare with 1
.e318	90 07		bcc $e321		BCC	LAB_E321		; branch if FAC1 < 1
.e31a	a9 bc		lda #$bc		LDA	#<FPC1			; pointer to 1 low byte
.e31c	a0 d9		ldy #$d9		LDY	#>FPC1			; pointer to 1 high byte
.e31e	20 0f db	jsr $db0f		JSR	LADIV			; convert .A.Y and do (.A.Y)/FAC1
.e321					LAB_E321
.e321	a9 3b		lda #$3b		LDA	#<ATNCON		; pointer to series low byte
.e323	a0 e3		ldy #$e3		LDY	#>ATNCON		; pointer to series high byte
.e325	20 40 e0	jsr $e040		JSR	SEREVL			; ^2 then series evaluation
.e328	68		pla			PLA				; restore old FAC1 exponent
.e329	c9 81		cmp #$81		CMP	#$81			; compare with 1
.e32b	90 07		bcc $e334		BCC	LAB_E334		; branch if FAC1 < 1
.e32d	a9 dd		lda #$dd		LDA	#<FPC20			; pointer to (pi/2) low byte
.e32f	a0 e2		ldy #$e2		LDY	#>FPC20			; pointer to (pi/2) low byte
.e331	20 50 d8	jsr $d850		JSR	LAMIN			; perform subtraction, FAC1 from (.A.Y)
.e334					LAB_E334
.e334	68		pla			PLA				; restore FAC1 sign
.e335	10 03		bpl $e33a		BPL	LAB_E33A		; exit if was +ve
.e337	4c b4 df	jmp $dfb4		JMP	NEGFAC			; else do - FAC1 and return
.e33a					LAB_E33A
.e33a	60		rts			RTS
.e33b					ATNCON
>e33b	0b					.byte	$0B			; series counter
>e33c	76 b3 83 bd d3				.byte	$76,$B3,$83,$BD,$D3	; -6.84793912e-04
>e341	79 1e f4 a6 f5				.byte	$79,$1E,$F4,$A6,$F5	;  4.85094216e-03
>e346	7b 83 fc b0 10				.byte	$7B,$83,$FC,$B0,$10	; -0.0161117015
>e34b	7c 0c 1f 67 ca				.byte	$7C,$0C,$1F,$67,$CA	;  0.034209638
>e350	7c de 53 cb c1				.byte	$7C,$DE,$53,$CB,$C1	; -0.054279133
>e355	7d 14 64 70 4c				.byte	$7D,$14,$64,$70,$4C	;  0.0724571965
>e35a	7d b7 ea 51 7a				.byte	$7D,$B7,$EA,$51,$7A	; -0.0898019185
>e35f	7d 63 30 88 7e				.byte	$7D,$63,$30,$88,$7E	;  0.110932413
>e364	7e 92 44 99 3a				.byte	$7E,$92,$44,$99,$3A	; -0.142839808
>e369	7e 4c cc 91 c7				.byte	$7E,$4C,$CC,$91,$C7	;  0.19999912
>e36e	7f aa aa aa 13				.byte	$7F,$AA,$AA,$AA,$13	; -0.333333316
>e373	81 00 00 00 00				.byte	$81,$00,$00,$00,$00	;  1.000000000
.e378					COLDBA
.e378	20 5b e4	jsr $e45b		JSR	INITVCTRS		; initialise BASIC vector table
.e37b	20 a4 e3	jsr $e3a4		JSR	INITBA			; initialise BASIC RAM locations
.e37e	20 04 e4	jsr $e404		JSR	FREMSG			; print start up message and initialise memory pointers
.e381	a2 fb		ldx #$fb		LDX	#$FB			; value for start stack
.e383	9a		txs			TXS				; set stack pointer
.e384	4c 74 c4	jmp $c474		JMP	READY			; do "READY." warm start
.e387					CGIMAG
.e387	e6 7a		inc $7a			INC	CHRGOT+1		; increment BASIC execute pointer low byte
.e389	d0 02		bne $e38d		BNE	LAB_E38D		; branch if no carry
.e38b	e6 7b		inc $7b			INC	CHRGOT+2		; increment BASIC execute pointer high byte
.e38d					LAB_E38D
.e38d	ad 60 ea	lda $ea60		LDA	LAB_EA60		; get byte to scan, address set by call routine
.e390	c9 3a		cmp #$3a		CMP	#':'			; compare with ":"
.e392	b0 0a		bcs $e39e		BCS	LAB_E39E		; exit if >=
.e394	c9 20		cmp #$20		CMP	#' '			; compare with " "
.e396	f0 ef		beq $e387		BEQ	CGIMAG			; if " " go do next
.e398	38		sec			SEC				; set carry for SBC
.e399	e9 30		sbc #$30		SBC	#'0'			; subtract "0"
.e39b	38		sec			SEC				; set carry for SBC
.e39c	e9 d0		sbc #$d0		SBC	#$D0			; subtract -"0"
.e39e					LAB_E39E
.e39e	60		rts			RTS
>e39f	80 4f c7 52 58				.byte	$80,$4F,$C7,$52,$58
.e3a4					INITBA
.e3a4	a9 4c		lda #$4c		LDA	#$4C			; opcode for JMP
.e3a6	85 54		sta $54			STA	JMPER			; save for functions vector jump
.e3a8	85 00		sta $00			STA	USRPPOK			; save for USR() vector jump
.e3aa	a9 48		lda #$48		LDA	#<ILQUAN		; set USR() vector low byte
.e3ac	a0 d2		ldy #$d2		LDY	#>ILQUAN		; set USR() vector high byte
.e3ae	85 01		sta $01			STA	ADDPRC			; save USR() vector low byte
.e3b0	84 02		sty $02			STY	ADDPRC+1		; save USR() vector high byte
.e3b2	a9 91		lda #$91		LDA	#<MAKFP			; set fixed to float vector low byte
.e3b4	a0 d3		ldy #$d3		LDY	#>MAKFP			; set fixed to float vector high byte
.e3b6	85 05		sta $05			STA	ADRAY2			; save fixed to float vector low byte
.e3b8	84 06		sty $06			STY	ADRAY2+1		; save fixed to float vector high byte
.e3ba	a9 aa		lda #$aa		LDA	#<INTIDX		; set float to fixed vector low byte
.e3bc	a0 d1		ldy #$d1		LDY	#>INTIDX		; set float to fixed vector high byte
.e3be	85 03		sta $03			STA	ADRAY1			; save float to fixed vector low byte
.e3c0	84 04		sty $04			STY	ADRAY1+1		; save float to fixed vector high byte
.e3c2	a2 1c		ldx #$1c		LDX	#$1C			; set byte count
.e3c4					LAB_E3C4
.e3c4	bd 87 e3	lda $e387,x		LDA	CGIMAG,X		; get byte from table
.e3c7	95 73		sta $73,x		STA	CHRGET,X		; save byte in page zero
.e3c9	ca		dex			DEX				; decrement count
.e3ca	10 f8		bpl $e3c4		BPL	LAB_E3C4		; loop if not all done
.e3cc	a9 03		lda #$03		LDA	#$03			; set step size, collecting descriptors
.e3ce	85 53		sta $53			STA	FOUR6			; save garbage collection step size
.e3d0	a9 00		lda #$00		LDA	#$00			; clear .A
.e3d2	85 68		sta $68			STA	BITS			; clear FAC1 overflow byte
.e3d4	85 13		sta $13			STA	CHANNL			; clear current I/O channel, flag default
.e3d6	85 18		sta $18			STA	LASTPT+1		; clear current descriptor stack item pointer high byte
.e3d8	a2 01		ldx #$01		LDX	#$01			; set .X
.e3da	8e fd 01	stx $01fd		STX	CHNLNK+1		; set chain link pointer low byte
.e3dd	8e fc 01	stx $01fc		STX	CHNLNK			; set chain link pointer high byte
.e3e0	a2 19		ldx #$19		LDX	#TEMPST			; initial value for descriptor stack
.e3e2	86 16		stx $16			STX	TEMPPT			; set descriptor stack pointer
.e3e4	38		sec			SEC				; set Cb = 1 to read the bottom of memory
.e3e5	20 9c ff	jsr $ff9c		JSR	MEMBOT			; read/set the bottom of memory
.e3e8	86 2b		stx $2b			STX	TXTTAB			; save start of memory low byte
.e3ea	84 2c		sty $2c			STY	TXTTAB+1		; save start of memory high byte
.e3ec	38		sec			SEC				; set Cb = 1 to read the top of memory
.e3ed	20 99 ff	jsr $ff99		JSR	MEMTOP			; read/set the top of memory
.e3f0	86 37		stx $37			STX	MEMSIZ			; save end of memory low byte
.e3f2	84 38		sty $38			STY	MEMSIZ+1		; save end of memory high byte
.e3f4	86 33		stx $33			STX	FRETOP			; set bottom of string space low byte
.e3f6	84 34		sty $34			STY	FRETOP+1		; set bottom of string space high byte
.e3f8	a0 00		ldy #$00		LDY	#$00			; clear index
.e3fa	98		tya			TYA				; clear .A
.e3fb	91 2b		sta ($2b),y		STA	(TXTTAB),Y		; clear first byte of memory
.e3fd	e6 2b		inc $2b			INC	TXTTAB			; increment start of memory low byte
.e3ff	d0 02		bne $e403		BNE	LAB_E403		; branch if no rollover
.e401	e6 2c		inc $2c			INC	TXTTAB+1		; increment start of memory high byte
.e403					LAB_E403
.e403	60		rts			RTS
.e404					FREMSG
.e404	a5 2b		lda $2b			LDA	TXTTAB			; get start of memory low byte
.e406	a4 2c		ldy $2c			LDY	TXTTAB+1		; get start of memory high byte
.e408	20 08 c4	jsr $c408		JSR	RAMSPC			; check available memory, do out of memory error if no room
.e40b	a9 36		lda #$36		LDA	#<BASMSG		; set "**** CBM BASIC V2 ****" pointer low byte
.e40d	a0 e4		ldy #$e4		LDY	#>BASMSG		; set "**** CBM BASIC V2 ****" pointer high byte
.e40f	20 1e cb	jsr $cb1e		JSR	PRTSTR			; print null terminated string
.e412	a5 37		lda $37			LDA	MEMSIZ			; get end of memory low byte
.e414	38		sec			SEC				; set carry for subtract
.e415	e5 2b		sbc $2b			SBC	TXTTAB			; subtract start of memory low byte
.e417	aa		tax			TAX				; copy result to .X
.e418	a5 38		lda $38			LDA	MEMSIZ+1		; get end of memory high byte
.e41a	e5 2c		sbc $2c			SBC	TXTTAB+1		; subtract start of memory high byte
.e41c	20 cd dd	jsr $ddcd		JSR	PRTFIX			; print .X.A as unsigned integer
.e41f	a9 29		lda #$29		LDA	#<BFREMSG		; set " BYTES FREE" pointer low byte
.e421	a0 e4		ldy #$e4		LDY	#>BFREMSG		; set " BYTES FREE" pointer high byte
.e423	20 1e cb	jsr $cb1e		JSR	PRTSTR			; print null terminated string
.e426	4c 44 c6	jmp $c644		JMP	LAB_C644		; do NEW, CLR, RESTORE and return
.e429					BFREMSG
>e429	20 42 59 54 45 53 20 46			.text	" BYTES FREE",$0D,$00
>e431	52 45 45 0d 00
.e436					BASMSG
>e436	93 2a 2a 2a 2a 20 43 42			.text	$93,"**** CBM BASIC V2 ****",$0D,$00
>e43e	4d 20 42 41 53 49 43 20 56 32 20 2a 2a 2a 2a 0d
>e44e	00
.e44f					BASVCTRS
>e44f	3a c4					.word	ERROR2			; error message				IERROR
>e451	83 c4					.word	MAIN2			; BASIC warm start			IMAIN
>e453	7c c5					.word	CRNCH2			; crunch BASIC tokens			ICRNCH
>e455	1a c7					.word	QPLOP			; uncrunch BASIC tokens			IQPLOP
>e457	e4 c7					.word	GONE			; start new BASIC code			IGONE
>e459	86 ce					.word	FEVAL			; get arithmetic element		IEVAL
.e45b					INITVCTRS
.e45b	a2 0b		ldx #$0b		LDX	#$0B			; set byte count
.e45d					LAB_E45D
.e45d	bd 4f e4	lda $e44f,x		LDA	BASVCTRS,X		; get byte from table
.e460	9d 00 03	sta $0300,x		STA	IERROR,X		; save byte to RAM
.e463	ca		dex			DEX				; decrement index
.e464	10 f7		bpl $e45d		BPL	LAB_E45D		; loop if more to do
.e466	60		rts			RTS
.e467					WARMBAS
.e467	20 cc ff	jsr $ffcc		JSR	CLRCHN			; close input and output channels
.e46a	a9 00		lda #$00		LDA	#$00			; clear .A
.e46c	85 13		sta $13			STA	CHANNL			; set current I/O channel, flag default
.e46e	20 7a c6	jsr $c67a		JSR	LAB_C67A		; flush BASIC stack and clear continue pointer
.e471	58		cli			CLI				; enable interrupts
.e472	4c 74 c4	jmp $c474		JMP	READY			; do warm start
>e475	e8					.byte	$E8			; [PAL]
.e476					PATCHER
.e476	20 33 c5	jsr $c533		JSR	LNKPRG			; rebuild BASIC line chaining
.e479	4c 77 c6	jmp $c677		JMP	LAB_C677		; do RESTORE, clear stack and return
>e47c	ff ff ff ff ff ff ff ff			.byte	$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
>e484	ff ff ff ff ff ff ff ff
>e48c	ff ff ff ff ff ff ff ff			.byte	$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
>e494	ff ff ff ff ff ff ff ff
>e49c	ff ff ff ff				.byte	$FF,$FF,$FF,$FF
.e4a0					SEROUT1
.e4a0	ad 2c 91	lda $912c		LDA	VIA2PCR			; get VIA 2 PCR
.e4a3	29 df		and #$df		AND	#$DF			; set CB2 low, serial DATA out high
.e4a5	8d 2c 91	sta $912c		STA	VIA2PCR			; set VIA 2 PCR
.e4a8	60		rts			RTS
.e4a9					SEROUT0
.e4a9	ad 2c 91	lda $912c		LDA	VIA2PCR			; get VIA 2 PCR
.e4ac	09 20		ora #$20		ORA	#$20			; set CB2 high, serial DATA out low
.e4ae	8d 2c 91	sta $912c		STA	VIA2PCR			; set VIA 2 PCR
.e4b1	60		rts			RTS
.e4b2					SERGET
.e4b2	ad 1f 91	lda $911f		LDA	VIA1PA2			; get VIA 1 DRA, no handshake
.e4b5	cd 1f 91	cmp $911f		CMP	VIA1PA2			; compare with self
.e4b8	d0 f8		bne $e4b2		BNE	SERGET			; loop if changing
.e4ba	4a		lsr a			LSR				; shift serial CLK in to Cb
.e4bb	60		rts			RTS
.e4bc					PATCH1
.e4bc	a6 b9		ldx $b9			LDX	SA			; get secondary address
.e4be	4c 47 f6	jmp $f647		JMP	SRCHING			; print "SEARCHING..." and return
.e4c1					PATCH2
.e4c1	8a		txa			TXA				; copy secondary address
.e4c2	d0 08		bne $e4cc		BNE	LAB_E4CC		; load location not set in LOAD call, so
.e4c4	a5 c3		lda $c3			LDA	MEMUSS			; get load start address low byte
.e4c6	85 ae		sta $ae			STA	EAL			; save program start address low byte
.e4c8	a5 c4		lda $c4			LDA	MEMUSS+1		; get load start address high byte
.e4ca	85 af		sta $af			STA	EAL+1			; save program start address high byte
.e4cc					LAB_E4CC
.e4cc	4c 6a f6	jmp $f66a		JMP	LDVRMSG			; display "LOADING" or "VERIFYING" and return
.e4cf					PATCH3
.e4cf	20 e3 f8	jsr $f8e3		JSR	WBLK			; initiate tape write
.e4d2	90 03		bcc $e4d7		BCC	LAB_E4D7		; branch if no error
.e4d4	68		pla			PLA				; else dump stacked exit code
.e4d5	a9 00		lda #$00		LDA	#$00			; clear exit code
.e4d7					LAB_E4D7
.e4d7	4c 9e f3	jmp $f39e		JMP	LAB_F39E		; go do I/O close
>e4da	ff ff ff ff ff ff ff ff			.byte	$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
>e4e2	ff ff ff ff ff ff ff ff
>e4ea	ff ff ff ff ff ff ff ff			.byte	$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
>e4f2	ff ff ff ff ff ff ff ff
>e4fa	ff ff ff ff ff ff			.byte	$FF,$FF,$FF,$FF,$FF,$FF
.e500					FIOBASE
.e500	a2 10		ldx #$10		LDX	#<VIA1PB		; get I/O base address low byte
.e502	a0 91		ldy #$91		LDY	#>VIA1PB		; get I/O base address high byte
.e504	60		rts			RTS
.e505					FSCREEN
.e505	a2 16		ldx #$16		LDX	#$16			; get screen X, 22 columns
.e507	a0 17		ldy #$17		LDY	#$17			; get screen Y, 23 rows
.e509	60		rts			RTS
.e50a					FPLOT
.e50a	b0 07		bcs $e513		BCS	LAB_E513		; if read cursor skip the set cursor
.e50c	86 d6		stx $d6			STX	TBLX			; save cursor row
.e50e	84 d3		sty $d3			STY	PNTR			; save cursor column
.e510	20 87 e5	jsr $e587		JSR	SETSLINK		; set screen pointers for cursor row, column
.e513					LAB_E513
.e513	a6 d6		ldx $d6			LDX	TBLX			; get cursor row
.e515	a4 d3		ldy $d3			LDY	PNTR			; get cursor column
.e517	60		rts			RTS
.e518					INITSK
.e518	20 bb e5	jsr $e5bb		JSR	SETIODEF		; set default devices and initialise VIC chip
.e51b	ad 88 02	lda $0288		LDA	HIBASE			; get screen memory page
.e51e	29 fd		and #$fd		AND	#$FD			; mask xxxx xx0x, all but va9
.e520	0a		asl a			ASL				; << 1 xxxx x0x0
.e521	0a		asl a			ASL				; << 2 xxxx 0x00
.e522	09 80		ora #$80		ORA	#$80			; set  1xxx 0x00
.e524	8d 05 90	sta $9005		STA	VICCR5			; set screen and character memory location
.e527	ad 88 02	lda $0288		LDA	HIBASE			; get screen memory page
.e52a	29 02		and #$02		AND	#$02			; mask va9 bit
.e52c	f0 08		beq $e536		BEQ	LAB_E536		; if zero just go normalise screen
.e52e	a9 80		lda #$80		LDA	#$80			; set b7
.e530	0d 02 90	ora $9002		ORA	VICCR2			; OR in as video address 9
.e533	8d 02 90	sta $9002		STA	VICCR2			; save new video address
.e536					LAB_E536
.e536	a9 00		lda #$00		LDA	#$00			; clear .A
.e538	8d 91 02	sta $0291		STA	MODE			; clear shift mode switch
.e53b	85 cf		sta $cf			STA	BLNON			; clear cursor blink phase
.e53d	a9 dc		lda #$dc		LDA	#<SETKEYS		; get keyboard decode logic pointer low byte
.e53f	8d 8f 02	sta $028f		STA	KEYLOG			; set keyboard decode logic pointer low byte
.e542	a9 eb		lda #$eb		LDA	#>SETKEYS		; get keyboard decode logic pointer high byte
.e544	8d 90 02	sta $0290		STA	KEYLOG+1		; set keyboard decode logic pointer high byte
.e547	a9 0a		lda #$0a		LDA	#$0A			; 10d
.e549	8d 89 02	sta $0289		STA	XMAX			; set maximum size of keyboard buffer
.e54c	8d 8c 02	sta $028c		STA	DELAY			; set repeat delay counter
.e54f	a9 06		lda #$06		LDA	#$06			; colour blue
.e551	8d 86 02	sta $0286		STA	COLOR			; set current colour code
.e554	a9 04		lda #$04		LDA	#$04			; speed 4
.e556	8d 8b 02	sta $028b		STA	KOUNT			; set repeat speed counter
.e559	a9 0c		lda #$0c		LDA	#$0C			; cursor flash timing
.e55b	85 cd		sta $cd			STA	BLNCT			; set cursor timing countdown
.e55d	85 cc		sta $cc			STA	BLNSW			; set cursor enable, $00 = flash cursor
.e55f					CLSR
.e55f	ad 88 02	lda $0288		LDA	HIBASE			; get screen memory page
.e562	09 80		ora #$80		ORA	#$80			; set high bit, flag every line is logical line start
.e564	a8		tay			TAY				; copy to .Y
.e565	a9 00		lda #$00		LDA	#$00			; clear line start low byte
.e567	aa		tax			TAX				; clear index
.e568					LAB_E568
.e568	94 d9		sty $d9,x		STY	LDTB1,X			; save start of line .X pointer high byte
.e56a	18		clc			CLC				; clear carry for add
.e56b	69 16		adc #$16		ADC	#$16			; add line length to low byte
.e56d	90 01		bcc $e570		BCC	LAB_E570		; if no rollover skip the high byte increment
.e56f	c8		iny			INY				; else increment high byte
.e570					LAB_E570
.e570	e8		inx			INX				; increment line index
.e571	e0 18		cpx #$18		CPX	#$18			; compare with number of lines + 1
.e573	d0 f3		bne $e568		BNE	LAB_E568		; loop if not all done
.e575	a9 ff		lda #$ff		LDA	#$FF			; end of table marker ??
.e577	95 d9		sta $d9,x		STA	LDTB1,X			; mark end of table
.e579	a2 16		ldx #$16		LDX	#$16			; set line count, 23 lines to do, 0 to 22
.e57b					LAB_E57B
.e57b	20 8d ea	jsr $ea8d		JSR	CLRALINE		; clear screen line .X
.e57e	ca		dex			DEX				; decrement count
.e57f	10 fa		bpl $e57b		BPL	LAB_E57B		; loop if more to do
.e581					HOME
.e581	a0 00		ldy #$00		LDY	#$00			; clear .Y
.e583	84 d3		sty $d3			STY	PNTR			; clear cursor column
.e585	84 d6		sty $d6			STY	TBLX			; clear cursor row
.e587					SETSLINK
.e587	a6 d6		ldx $d6			LDX	TBLX			; get cursor row
.e589	a5 d3		lda $d3			LDA	PNTR			; get cursor column
.e58b					LAB_E58B
.e58b	b4 d9		ldy $d9,x		LDY	LDTB1,X			; get start of line .X pointer high byte
.e58d	30 08		bmi $e597		BMI	LAB_E597		; continue if logical line start
.e58f	18		clc			CLC				; else clear carry for add
.e590	69 16		adc #$16		ADC	#$16			; add one line length
.e592	85 d3		sta $d3			STA	PNTR			; save cursor column
.e594	ca		dex			DEX				; decrement cursor row
.e595	10 f4		bpl $e58b		BPL	LAB_E58B		; loop, branch always
.e597					LAB_E597
.e597	b5 d9		lda $d9,x		LDA	LDTB1,X			; get start of line .X pointer high byte
.e599	29 03		and #$03		AND	#$03			; mask 0000 00xx, line memory page
.e59b	0d 88 02	ora $0288		ORA	HIBASE			; OR with screen memory page
.e59e	85 d2		sta $d2			STA	PNT+1			; set current screen line pointer high byte
.e5a0	bd fd ed	lda $edfd,x		LDA	LDTB2,X			; get start of line low byte from ROM table
.e5a3	85 d1		sta $d1			STA	PNT			; set current screen line pointer low byte
.e5a5	a9 15		lda #$15		LDA	#$15			; set line length
.e5a7	e8		inx			INX				; increment cursor row
.e5a8					LAB_E5A8
.e5a8	b4 d9		ldy $d9,x		LDY	LDTB1,X			; get start of line .X pointer high byte
.e5aa	30 06		bmi $e5b2		BMI	LAB_E5B2		; exit if logical line start
.e5ac	18		clc			CLC				; else clear carry for add
.e5ad	69 16		adc #$16		ADC	#$16			; add one line length to current line length
.e5af	e8		inx			INX				; increment cursor row
.e5b0	10 f6		bpl $e5a8		BPL	LAB_E5A8		; loop, branch always
.e5b2					LAB_E5B2
.e5b2	85 d5		sta $d5			STA	LNMX			; save current screen line length
.e5b4	60		rts			RTS
.e5b5	20 bb e5	jsr $e5bb		JSR	SETIODEF		; set default devices and initialise VIC chip
.e5b8	4c 81 e5	jmp $e581		JMP	HOME			; home cursor and return
.e5bb					SETIODEF
.e5bb	a9 03		lda #$03		LDA	#$03			; set screen
.e5bd	85 9a		sta $9a			STA	DFLTO			; set output device number
.e5bf	a9 00		lda #$00		LDA	#$00			; set keyboard
.e5c1	85 99		sta $99			STA	DFLTN			; set input device number
.e5c3					INITVIC
.e5c3	a2 10		ldx #$10		LDX	#$10			; set byte count
.e5c5					LAB_E5C5
.e5c5	bd e3 ed	lda $ede3,x		LDA	VICINIT-1,X		; get byte from setup table
.e5c8	9d ff 8f	sta $8fff,x		STA	VICCR0-1,X		; save byte to VIC chip
.e5cb	ca		dex			DEX				; decrement count/index
.e5cc	d0 f7		bne $e5c5		BNE	LAB_E5C5		; loop if more to do
.e5ce	60		rts			RTS
.e5cf					LP2
.e5cf	ac 77 02	ldy $0277		LDY	KEYD			; get current character from buffer
.e5d2	a2 00		ldx #$00		LDX	#$00			; clear index
.e5d4					LAB_E5D4
.e5d4	bd 78 02	lda $0278,x		LDA	KEYD+1,X		; get next character,.X from buffer
.e5d7	9d 77 02	sta $0277,x		STA	KEYD,X			; save as current character,.X in buffer
.e5da	e8		inx			INX				; increment index
.e5db	e4 c6		cpx $c6			CPX	NDX			; compare with keyboard buffer index
.e5dd	d0 f5		bne $e5d4		BNE	LAB_E5D4		; loop if more to do
.e5df	c6 c6		dec $c6			DEC	NDX			; decrement keyboard buffer index
.e5e1	98		tya			TYA				; copy key to .A
.e5e2	58		cli			CLI				; enable interrupts
.e5e3	18		clc			CLC				; flag got byte
.e5e4	60		rts			RTS
.e5e5					GETQUE
.e5e5	20 42 e7	jsr $e742		JSR	SCRNOUT			; output character
.e5e8					LAB_E5E8
.e5e8	a5 c6		lda $c6			LDA	NDX			; get keyboard buffer index
.e5ea	85 cc		sta $cc			STA	BLNSW			; cursor enable, $00 = flash cursor, $xx = no flash
.e5ec	8d 92 02	sta $0292		STA	AUTODN			; screen scrolling flag, $00 = scroll, $xx = no scroll
.e5ef	f0 f7		beq $e5e8		BEQ	LAB_E5E8		; loop if buffer empty
.e5f1	78		sei			SEI				; disable interrupts
.e5f2	a5 cf		lda $cf			LDA	BLNON			; get cursor blink phase
.e5f4	f0 0c		beq $e602		BEQ	LAB_E602		; branch if cursor phase
.e5f6	a5 ce		lda $ce			LDA	CDBLN			; get character under cursor
.e5f8	ae 87 02	ldx $0287		LDX	GDCOL			; get colour under cursor
.e5fb	a0 00		ldy #$00		LDY	#$00			; clear .Y
.e5fd	84 cf		sty $cf			STY	BLNON			; clear cursor blink phase
.e5ff	20 a1 ea	jsr $eaa1		JSR	SYNPRT			; print character .A and colour .X
.e602					LAB_E602
.e602	20 cf e5	jsr $e5cf		JSR	LP2			; input from keyboard buffer
.e605	c9 83		cmp #$83		CMP	#$83			; compare with [RUN]
.e607	d0 10		bne $e619		BNE	GET2RTN			; branch if not [RUN]
.e609	a2 09		ldx #$09		LDX	#$09			; set byte count
.e60b	78		sei			SEI				; disable interrupts
.e60c	86 c6		stx $c6			STX	NDX			; set keyboard buffer index
.e60e					LAB_E60E
.e60e	bd f3 ed	lda $edf3,x		LDA	RUNTB-1,X		; get byte from auto load/run table
.e611	9d 76 02	sta $0276,x		STA	KEYD-1,X		; save to keyboard buffer
.e614	ca		dex			DEX				; decrement count/index
.e615	d0 f7		bne $e60e		BNE	LAB_E60E		; loop while more to do
.e617	f0 cf		beq $e5e8		BEQ	LAB_E5E8		; loop for next key, branch always
.e619					GET2RTN
.e619	c9 0d		cmp #$0d		CMP	#$0D			; compare with [RETURN]
.e61b	d0 c8		bne $e5e5		BNE	GETQUE			; if not [RETURN] print character and get next key
.e61d	a4 d5		ldy $d5			LDY	LNMX			; get current screen line length
.e61f	84 d0		sty $d0			STY	CRSW			; set input from screen
.e621					LAB_E621
.e621	b1 d1		lda ($d1),y		LDA	(PNT),Y			; get character from current screen line
.e623	c9 20		cmp #$20		CMP	#' '			; compare with [SPACE]
.e625	d0 03		bne $e62a		BNE	LAB_E62A		; branch if not [SPACE]
.e627	88		dey			DEY				; else eliminate the space, decrement end of input line
.e628	d0 f7		bne $e621		BNE	LAB_E621		; loop, branch always
.e62a					LAB_E62A
.e62a	c8		iny			INY				; increment past last non space character on line
.e62b	84 c8		sty $c8			STY	INDX			; save input EOL pointer
.e62d	a0 00		ldy #$00		LDY	#$00			; clear .Y
.e62f	8c 92 02	sty $0292		STY	AUTODN			; clear screen scrolling flag, $00 = scroll, $xx = no scroll
.e632	84 d3		sty $d3			STY	PNTR			; clear cursor column
.e634	84 d4		sty $d4			STY	QTSW			; clear cursor quote flag
.e636	a5 c9		lda $c9			LDA	LXSP			; get input cursor row
.e638	30 1d		bmi $e657		BMI	LAB_E657		; branch if input cursor row has become -ve
.e63a	a6 d6		ldx $d6			LDX	TBLX			; get cursor row
.e63c	20 19 e7	jsr $e719		JSR	LAB_E719		; find and set pointers for start of logical line
.e63f	e4 c9		cpx $c9			CPX	LXSP			; compare with input cursor row
.e641	d0 14		bne $e657		BNE	LAB_E657		;.
.e643	d0 12		bne $e657		BNE	LAB_E657		;.?? what's this? just to make sure or something
.e645	a5 ca		lda $ca			LDA	LXSP+1			; get input cursor column
.e647	85 d3		sta $d3			STA	PNTR			; save cursor column
.e649	c5 c8		cmp $c8			CMP	INDX			; compare with input EOL pointer
.e64b	90 0a		bcc $e657		BCC	LAB_E657		; branch if less, cursor is in line
.e64d	b0 42		bcs $e691		BCS	LAB_E691		; else cursor is beyond the line end, branch always
.e64f					GETSCRN
.e64f	98		tya			TYA				; copy .Y
.e650	48		pha			PHA				; save .Y
.e651	8a		txa			TXA				; copy .X
.e652	48		pha			PHA				; save .X
.e653	a5 d0		lda $d0			LDA	CRSW			; get input from keyboard or screen, $xx = screen,
.e655	f0 91		beq $e5e8		BEQ	LAB_E5E8		; if keyboard go wait for key
.e657					LAB_E657
.e657	a4 d3		ldy $d3			LDY	PNTR			; get cursor column
.e659	b1 d1		lda ($d1),y		LDA	(PNT),Y			; get character from the current screen line
.e65b	ea		nop			NOP				;
.e65c	ea		nop			NOP				;
.e65d	ea		nop			NOP				;
.e65e	ea		nop			NOP				;
.e65f	ea		nop			NOP				;
.e660	ea		nop			NOP				;
.e661	ea		nop			NOP				;
.e662	ea		nop			NOP				;
.e663	ea		nop			NOP				; just a few wasted cycles
.e664	ea		nop			NOP				;
.e665	ea		nop			NOP				;
.e666	ea		nop			NOP				;
.e667	ea		nop			NOP				;
.e668	ea		nop			NOP				;
.e669	ea		nop			NOP				;
.e66a	ea		nop			NOP				;
.e66b	ea		nop			NOP				;
.e66c	ea		nop			NOP				;
.e66d	ea		nop			NOP				;
.e66e	ea		nop			NOP				;
.e66f	ea		nop			NOP				;
.e670	ea		nop			NOP				;
.e671	ea		nop			NOP				;
.e672	85 d7		sta $d7			STA	ASCII			; save temporary last character
.e674	29 3f		and #$3f		AND	#$3F			; leave b5 to b0 in .A
.e676	06 d7		asl $d7			ASL	ASCII			; shift b7 into Cb
.e678	24 d7		bit $d7			BIT	ASCII			; copy b6 into Sb, b5 into Ob
.e67a	10 02		bpl $e67e		BPL	LAB_E67E		; branch if b6 = 0
.e67c	09 80		ora #$80		ORA	#$80			; map $40-$7F to $C0-$FF
.e67e					LAB_E67E
.e67e	90 04		bcc $e684		BCC	LAB_E684		; branch if b7 = 0
.e680	a6 d4		ldx $d4			LDX	QTSW			; get cursor quote flag, $01 = quote, $00 = no quote
.e682	d0 04		bne $e688		BNE	LAB_E688		; branch if in quote mode
.e684					LAB_E684
.e684	70 02		bvs $e688		BVS	LAB_E688		; branch if b5 = 1
.e686	09 40		ora #$40		ORA	#$40			; map $00-$1F to $40-5F
.e688					LAB_E688
.e688	e6 d3		inc $d3			INC	PNTR			; increment cursor column
.e68a	20 b8 e6	jsr $e6b8		JSR	QUOTECK			; if open quote toggle cursor quote flag
.e68d	c4 c8		cpy $c8			CPY	INDX			; compare with input EOL pointer
.e68f	d0 17		bne $e6a8		BNE	LAB_E6A8		; branch if not at line end
.e691					LAB_E691
.e691	a9 00		lda #$00		LDA	#$00			; clear .A
.e693	85 d0		sta $d0			STA	CRSW			; set input from keyboard
.e695	a9 0d		lda #$0d		LDA	#$0D			; set character [CR]
.e697	a6 99		ldx $99			LDX	DFLTN			; get input device number
.e699	e0 03		cpx #$03		CPX	#$03			; compare with screen
.e69b	f0 06		beq $e6a3		BEQ	LAB_E6A3		; branch if screen
.e69d	a6 9a		ldx $9a			LDX	DFLTO			; get output device number
.e69f	e0 03		cpx #$03		CPX	#$03			; compare with screen
.e6a1	f0 03		beq $e6a6		BEQ	LAB_E6A6		; branch if screen
.e6a3					LAB_E6A3
.e6a3	20 42 e7	jsr $e742		JSR	SCRNOUT			; output character
.e6a6					LAB_E6A6
.e6a6	a9 0d		lda #$0d		LDA	#$0D			; set character [CR]
.e6a8					LAB_E6A8
.e6a8	85 d7		sta $d7			STA	ASCII			; save character
.e6aa	68		pla			PLA				; pull .X
.e6ab	aa		tax			TAX				; restore .X
.e6ac	68		pla			PLA				; pull .Y
.e6ad	a8		tay			TAY				; restore .Y
.e6ae	a5 d7		lda $d7			LDA	ASCII			; restore character
.e6b0	c9 de		cmp #$de		CMP	#$DE			; compare with [PI]
.e6b2	d0 02		bne $e6b6		BNE	LAB_E6B6		; exit if not [PI]
.e6b4	a9 ff		lda #$ff		LDA	#TK_PI			; set character to BASIC token
.e6b6					LAB_E6B6
.e6b6	18		clc			CLC				; flag ok
.e6b7	60		rts			RTS
.e6b8					QUOTECK
.e6b8	c9 22		cmp #$22		CMP	#$22			; compare byte with "
.e6ba	d0 08		bne $e6c4		BNE	LAB_E6C4		; exit if not "
.e6bc	a5 d4		lda $d4			LDA	QTSW			; get cursor quote flag
.e6be	49 01		eor #$01		EOR	#$01			; toggle b0
.e6c0	85 d4		sta $d4			STA	QTSW			; save cursor quote flag
.e6c2	a9 22		lda #$22		LDA	#$22			; restore the "
.e6c4					LAB_E6C4
.e6c4	60		rts			RTS
.e6c5					SETCHAR
.e6c5	09 40		ora #$40		ORA	#$40			; change to uppercase/graphic
.e6c7					LAB_E6C7
.e6c7	a6 c7		ldx $c7			LDX	RVS			; get reverse flag
.e6c9	f0 02		beq $e6cd		BEQ	LAB_E6CD		; branch if not reverse
.e6cb					LAB_E6CB
.e6cb	09 80		ora #$80		ORA	#$80			; reverse character
.e6cd					LAB_E6CD
.e6cd	a6 d8		ldx $d8			LDX	INSRT			; get insert count
.e6cf	f0 02		beq $e6d3		BEQ	LAB_E6D3		; branch if none
.e6d1	c6 d8		dec $d8			DEC	INSRT			; else decrement insert count
.e6d3					LAB_E6D3
.e6d3	ae 86 02	ldx $0286		LDX	COLOR			; get current colour code
.e6d6	20 a1 ea	jsr $eaa1		JSR	SYNPRT			; print character .A and colour .X
.e6d9	20 ea e6	jsr $e6ea		JSR	SCROLL			; advance cursor
.e6dc					LAB_E6DC
.e6dc	68		pla			PLA				; pull .Y
.e6dd	a8		tay			TAY				; restore .Y
.e6de	a5 d8		lda $d8			LDA	INSRT			; get insert count
.e6e0	f0 02		beq $e6e4		BEQ	LAB_E6E4		; skip quote flag clear if inserts to do
.e6e2	46 d4		lsr $d4			LSR	QTSW			; clear cursor quote flag
.e6e4					LAB_E6E4
.e6e4	68		pla			PLA				; pull .X
.e6e5	aa		tax			TAX				; restore .X
.e6e6	68		pla			PLA				; restore .A
.e6e7	18		clc			CLC				; flag ok
.e6e8	58		cli			CLI				; enable interrupts
.e6e9	60		rts			RTS
.e6ea					SCROLL
.e6ea	20 fa e8	jsr $e8fa		JSR	FORWARD			; test for line increment
.e6ed	e6 d3		inc $d3			INC	PNTR			; increment cursor column
.e6ef	a5 d5		lda $d5			LDA	LNMX			; get current screen line length
.e6f1	c5 d3		cmp $d3			CMP	PNTR			; compare with cursor column
.e6f3	b0 37		bcs $e72c		BCS	LAB_E72C		; exit if line length >= cursor column
.e6f5	c9 57		cmp #$57		CMP	#$57			; compare with max length
.e6f7	f0 2a		beq $e723		BEQ	LAB_E723		; if at max clear column, back cursor up and do newline
.e6f9	ad 92 02	lda $0292		LDA	AUTODN			; get autoscroll flag
.e6fc	f0 03		beq $e701		BEQ	LAB_E701		; branch if autoscroll on
.e6fe	4c f0 e9	jmp $e9f0		JMP	LAB_E9F0		; else open space on screen
.e701					LAB_E701
.e701	a6 d6		ldx $d6			LDX	TBLX			; get cursor row
.e703	e0 17		cpx #$17		CPX	#$17			; compare with max + 1
.e705	90 07		bcc $e70e		BCC	LAB_E70E		; if less than max + 1 go add this row to the current
.e707	20 75 e9	jsr $e975		JSR	SCRL			; else scroll screen
.e70a	c6 d6		dec $d6			DEC	TBLX			; decrement cursor row
.e70c	a6 d6		ldx $d6			LDX	TBLX			; get cursor row
.e70e					LAB_E70E
.e70e	16 d9		asl $d9,x		ASL	LDTB1,X			; shift start of line .X pointer high byte
.e710	56 d9		lsr $d9,x		LSR	LDTB1,X			; shift start of line .X pointer high byte back,
.e712	4c 5b ed	jmp $ed5b		JMP	WRAPLINE		; make next screen line start of logical line, increment
.e715					LAB_E715
.e715	69 16		adc #$16		ADC	#$16			; add one line length
.e717	85 d5		sta $d5			STA	LNMX			; save current screen line length
.e719					LAB_E719
.e719	b5 d9		lda $d9,x		LDA	LDTB1,X			; get start of line .X pointer high byte
.e71b	30 03		bmi $e720		BMI	LAB_E720		; exit loop if start of logical line
.e71d	ca		dex			DEX				; else back up one line
.e71e	d0 f9		bne $e719		BNE	LAB_E719		; loop if not on first line
.e720					LAB_E720
.e720	4c 7e ea	jmp $ea7e		JMP	LINPTR			; set start of line .X and return
.e723					LAB_E723
.e723	c6 d6		dec $d6			DEC	TBLX			; decrement cursor row. if the cursor was incremented past
.e725	20 c3 e8	jsr $e8c3		JSR	NXTLINE			; do newline
.e728	a9 00		lda #$00		LDA	#$00			; clear .A
.e72a	85 d3		sta $d3			STA	PNTR			; clear cursor column
.e72c					LAB_E72C
.e72c	60		rts			RTS
.e72d					RETREAT
.e72d	a6 d6		ldx $d6			LDX	TBLX			; get cursor row
.e72f	d0 06		bne $e737		BNE	LAB_E737		; branch if not top row
.e731	86 d3		stx $d3			STX	PNTR			; clear cursor column
.e733	68		pla			PLA				; dump return address low byte
.e734	68		pla			PLA				; dump return address high byte
.e735	d0 a5		bne $e6dc		BNE	LAB_E6DC		; restore registers, set quote flag and exit, branch always
.e737					LAB_E737
.e737	ca		dex			DEX				; decrement cursor row
.e738	86 d6		stx $d6			STX	TBLX			; save cursor row
.e73a	20 87 e5	jsr $e587		JSR	SETSLINK		; set screen pointers for cursor row, column
.e73d	a4 d5		ldy $d5			LDY	LNMX			; get current screen line length
.e73f	84 d3		sty $d3			STY	PNTR			; save as cursor column
.e741	60		rts			RTS
.e742					SCRNOUT
.e742	48		pha			PHA				; save character
.e743	85 d7		sta $d7			STA	ASCII			; save temporary last character
.e745	8a		txa			TXA				; copy .X
.e746	48		pha			PHA				; save .X
.e747	98		tya			TYA				; copy .Y
.e748	48		pha			PHA				; save .Y
.e749	a9 00		lda #$00		LDA	#$00			; clear .A
.e74b	85 d0		sta $d0			STA	CRSW			; set input from keyboard
.e74d	a4 d3		ldy $d3			LDY	PNTR			; get cursor column
.e74f	a5 d7		lda $d7			LDA	ASCII			; restore last character
.e751	10 03		bpl $e756		BPL	LAB_E756		; branch if unshifted
.e753	4c 00 e8	jmp $e800		JMP	LAB_E800		; do shifted characters and return
.e756					LAB_E756
.e756	c9 0d		cmp #$0d		CMP	#$0D			; compare with [CR]
.e758	d0 03		bne $e75d		BNE	LAB_E75D		; branch if not [CR]
.e75a	4c d8 e8	jmp $e8d8		JMP	RTRN			; else output [CR] and return
.e75d					LAB_E75D
.e75d	c9 20		cmp #$20		CMP	#' '			; compare with [SPACE]
.e75f	90 10		bcc $e771		BCC	LAB_E771		; branch if < [SPACE]
.e761	c9 60		cmp #$60		CMP	#$60			; compare with first graphic character
.e763	90 04		bcc $e769		BCC	LAB_E769		; branch if $20 to $5F
.e765	29 df		and #$df		AND	#$DF			; mask xx0x xxxx, map to $40-$5F
.e767	d0 02		bne $e76b		BNE	LAB_E76B		; branch always
.e769					LAB_E769
.e769	29 3f		and #$3f		AND	#$3F			; mask 00xx xxxx, map $40-$5F to $00-$1F
.e76b					LAB_E76B
.e76b	20 b8 e6	jsr $e6b8		JSR	QUOTECK			; if open quote toggle cursor direct/programmed flag
.e76e	4c c7 e6	jmp $e6c7		JMP	LAB_E6C7		; print character, scroll if needed and exit
.e771					LAB_E771
.e771	a6 d8		ldx $d8			LDX	INSRT			; get insert count
.e773	f0 03		beq $e778		BEQ	LAB_E778		; branch if no characters to insert
.e775	4c cb e6	jmp $e6cb		JMP	LAB_E6CB		; insert reversed character
.e778					LAB_E778
.e778	c9 14		cmp #$14		CMP	#$14			; compare with [DELETE]
.e77a	d0 2e		bne $e7aa		BNE	LAB_E7AA		; branch if not [DELETE]
.e77c	98		tya			TYA				; copy cursor column to .A
.e77d	d0 06		bne $e785		BNE	LAB_E785		; branch if not at start of line
.e77f	20 2d e7	jsr $e72d		JSR	RETREAT			; back onto previous line if possible
.e782	4c 9f e7	jmp $e79f		JMP	LAB_E79F		; clear last character on current screen line
.e785					LAB_E785
.e785	20 e8 e8	jsr $e8e8		JSR	BACKUP			; test for line decrement
.e788	88		dey			DEY				; decrement index to previous character
.e789	84 d3		sty $d3			STY	PNTR			; save cursor column
.e78b	20 b2 ea	jsr $eab2		JSR	COLORSYN		; calculate pointer to colour RAM
.e78e					LAB_E78E
.e78e	c8		iny			INY				; increment index to next character
.e78f	b1 d1		lda ($d1),y		LDA	(PNT),Y			; get character from current screen line
.e791	88		dey			DEY				; decrement index to previous character
.e792	91 d1		sta ($d1),y		STA	(PNT),Y			; save character to current screen line
.e794	c8		iny			INY				; increment index to next character
.e795	b1 f3		lda ($f3),y		LDA	(USER),Y		; get colour RAM byte
.e797	88		dey			DEY				; decrement index to previous character
.e798	91 f3		sta ($f3),y		STA	(USER),Y		; save colour RAM byte
.e79a	c8		iny			INY				; increment index to next character
.e79b	c4 d5		cpy $d5			CPY	LNMX			; compare with current screen line length
.e79d	d0 ef		bne $e78e		BNE	LAB_E78E		; loop if not there yet
.e79f					LAB_E79F
.e79f	a9 20		lda #$20		LDA	#' '			; set [SPACE]
.e7a1	91 d1		sta ($d1),y		STA	(PNT),Y			; clear last character on current screen line
.e7a3	ad 86 02	lda $0286		LDA	COLOR			; get current colour code
.e7a6	91 f3		sta ($f3),y		STA	(USER),Y		; save to colour RAM
.e7a8	10 4d		bpl $e7f7		BPL	LAB_E7F7		; restore registers, set quote flag and exit, branch always
.e7aa					LAB_E7AA
.e7aa	a6 d4		ldx $d4			LDX	QTSW			; get cursor quote flag, $01 = quote, $00 = no quote
.e7ac	f0 03		beq $e7b1		BEQ	LAB_E7B1		; branch if not quote mode
.e7ae	4c cb e6	jmp $e6cb		JMP	LAB_E6CB		; insert reversed character, scroll if needed and exit
.e7b1					LAB_E7B1
.e7b1	c9 12		cmp #$12		CMP	#$12			; compare with [RVS ON]
.e7b3	d0 02		bne $e7b7		BNE	LAB_E7B7		; branch if not [RVS ON]
.e7b5	85 c7		sta $c7			STA	RVS			; set reverse flag
.e7b7					LAB_E7B7
.e7b7	c9 13		cmp #$13		CMP	#$13			; compare with [HOME]
.e7b9	d0 03		bne $e7be		BNE	LAB_E7BE		; branch if not [HOME]
.e7bb	20 81 e5	jsr $e581		JSR	HOME			; home cursor
.e7be					LAB_E7BE
.e7be	c9 1d		cmp #$1d		CMP	#$1D			; compare with [CURSOR RIGHT]
.e7c0	d0 17		bne $e7d9		BNE	LAB_E7D9		; branch if not [CURSOR RIGHT]
.e7c2	c8		iny			INY				; increment cursor column
.e7c3	20 fa e8	jsr $e8fa		JSR	FORWARD			; test for line increment
.e7c6	84 d3		sty $d3			STY	PNTR			; save cursor column
.e7c8	88		dey			DEY				; decrement cursor column
.e7c9	c4 d5		cpy $d5			CPY	LNMX			; compare cursor column with current screen line length
.e7cb	90 09		bcc $e7d6		BCC	LAB_E7D6		; exit if less
.e7cd	c6 d6		dec $d6			DEC	TBLX			; decrement cursor row
.e7cf	20 c3 e8	jsr $e8c3		JSR	NXTLINE			; do newline
.e7d2	a0 00		ldy #$00		LDY	#$00			; clear cursor column
.e7d4					LAB_E7D4
.e7d4	84 d3		sty $d3			STY	PNTR			; save cursor column
.e7d6					LAB_E7D6
.e7d6	4c dc e6	jmp $e6dc		JMP	LAB_E6DC		; restore registers, set quote flag and exit
.e7d9					LAB_E7D9
.e7d9	c9 11		cmp #$11		CMP	#$11			; compare with [CURSOR DOWN]
.e7db	d0 1d		bne $e7fa		BNE	LAB_E7FA		; branch if not [CURSOR DOWN]
.e7dd	18		clc			CLC				; clear carry for add
.e7de	98		tya			TYA				; copy cursor column
.e7df	69 16		adc #$16		ADC	#$16			; add one line
.e7e1	a8		tay			TAY				; copy back to .A
.e7e2	e6 d6		inc $d6			INC	TBLX			; increment cursor row
.e7e4	c5 d5		cmp $d5			CMP	LNMX			; compare cursor column with current screen line length
.e7e6	90 ec		bcc $e7d4		BCC	LAB_E7D4		; save cursor column and exit if less
.e7e8	f0 ea		beq $e7d4		BEQ	LAB_E7D4		; save cursor column and exit if equal
.e7ea	c6 d6		dec $d6			DEC	TBLX			; decrement cursor row
.e7ec					LAB_E7EC
.e7ec	e9 16		sbc #$16		SBC	#$16			; subtract one line
.e7ee	90 04		bcc $e7f4		BCC	LAB_E7F4		; exit loop if on previous line
.e7f0	85 d3		sta $d3			STA	PNTR			; else save cursor column
.e7f2	d0 f8		bne $e7ec		BNE	LAB_E7EC		; loop if not at start of line
.e7f4					LAB_E7F4
.e7f4	20 c3 e8	jsr $e8c3		JSR	NXTLINE			; do newline
.e7f7					LAB_E7F7
.e7f7	4c dc e6	jmp $e6dc		JMP	LAB_E6DC		; restore registers, set quote flag and exit
.e7fa					LAB_E7FA
.e7fa	20 12 e9	jsr $e912		JSR	COLORSET		; set the colour from the character in .A
.e7fd	4c 21 ed	jmp $ed21		JMP	CHARSET			; select VIC character set
.e800					LAB_E800
.e800	ea		nop			NOP				; just a few wasted cycles
.e801	ea		nop			NOP				;
.e802	ea		nop			NOP				;
.e803	ea		nop			NOP				;
.e804	ea		nop			NOP				;
.e805	ea		nop			NOP				;
.e806	ea		nop			NOP				;
.e807	ea		nop			NOP				;
.e808	ea		nop			NOP				;
.e809	ea		nop			NOP				;
.e80a	ea		nop			NOP				;
.e80b	ea		nop			NOP				;
.e80c	ea		nop			NOP				;
.e80d	ea		nop			NOP				;
.e80e	ea		nop			NOP				;
.e80f	ea		nop			NOP				;
.e810	ea		nop			NOP				;
.e811	ea		nop			NOP				;
.e812	ea		nop			NOP				;
.e813	ea		nop			NOP				;
.e814	ea		nop			NOP				;
.e815	29 7f		and #$7f		AND	#$7F			; mask 0xxx xxxx, clear b7
.e817	c9 7f		cmp #$7f		CMP	#$7F			; was it [PI] before the mask
.e819	d0 02		bne $e81d		BNE	LAB_E81D		; branch if not
.e81b	a9 5e		lda #$5e		LDA	#$5E			; else make it $5E
.e81d					LAB_E81D
.e81d	ea		nop			NOP				; just a few wasted cycles
.e81e	ea		nop			NOP				;
.e81f	ea		nop			NOP				;
.e820	ea		nop			NOP				;
.e821	ea		nop			NOP				;
.e822	ea		nop			NOP				;
.e823	c9 20		cmp #$20		CMP	#' '			; compare with [SPACE]
.e825	90 03		bcc $e82a		BCC	LAB_E82A		; branch if < [SPACE]
.e827	4c c5 e6	jmp $e6c5		JMP	SETCHAR			; insert uppercase/graphic character and return
.e82a					LAB_E82A
.e82a	c9 0d		cmp #$0d		CMP	#$0D			; compare with [CR]
.e82c	d0 03		bne $e831		BNE	LAB_E831		; branch if not [CR]
.e82e	4c d8 e8	jmp $e8d8		JMP	RTRN			; else output [CR] and return
.e831					LAB_E831
.e831	a6 d4		ldx $d4			LDX	QTSW			; get cursor quote flag, $01 = quote, $00 = no quote
.e833	d0 3f		bne $e874		BNE	LAB_E874		; branch if quote mode
.e835	c9 14		cmp #$14		CMP	#$14			; compare with [DELETE]
.e837	d0 37		bne $e870		BNE	LAB_E870		; branch if not [DELETE]
.e839	a4 d5		ldy $d5			LDY	LNMX			; get current screen line length
.e83b	b1 d1		lda ($d1),y		LDA	(PNT),Y			; get character from current screen line
.e83d	c9 20		cmp #$20		CMP	#' '			; compare with [SPACE]
.e83f	d0 04		bne $e845		BNE	LAB_E845		; branch if not [SPACE]
.e841	c4 d3		cpy $d3			CPY	PNTR			; compare current column with cursor column
.e843	d0 07		bne $e84c		BNE	LAB_E84C		; if not cursor column go open up space on line
.e845					LAB_E845
.e845	c0 57		cpy #$57		CPY	#$57			; compare current column with max line length
.e847	f0 24		beq $e86d		BEQ	LAB_E86D		; exit if at line end
.e849	20 ee e9	jsr $e9ee		JSR	OPENLIN			; else open space on screen
.e84c					LAB_E84C
.e84c	a4 d5		ldy $d5			LDY	LNMX			; get current screen line length
.e84e	20 b2 ea	jsr $eab2		JSR	COLORSYN		; calculate pointer to colour RAM
.e851					LAB_E851
.e851	88		dey			DEY				; decrement index to previous character
.e852	b1 d1		lda ($d1),y		LDA	(PNT),Y			; get character from current screen line
.e854	c8		iny			INY				; increment index to next character
.e855	91 d1		sta ($d1),y		STA	(PNT),Y			; save character to current screen line
.e857	88		dey			DEY				; decrement index to previous character
.e858	b1 f3		lda ($f3),y		LDA	(USER),Y		; get current screen line colour RAM byte
.e85a	c8		iny			INY				; increment index to next character
.e85b	91 f3		sta ($f3),y		STA	(USER),Y		; save current screen line colour RAM byte
.e85d	88		dey			DEY				; decrement index to previous character
.e85e	c4 d3		cpy $d3			CPY	PNTR			; compare with cursor column
.e860	d0 ef		bne $e851		BNE	LAB_E851		; loop if not there yet
.e862	a9 20		lda #$20		LDA	#' '			; set [SPACE]
.e864	91 d1		sta ($d1),y		STA	(PNT),Y			; clear character at cursor position on current screen line
.e866	ad 86 02	lda $0286		LDA	COLOR			; get current colour code
.e869	91 f3		sta ($f3),y		STA	(USER),Y		; save to cursor position on current screen line colour RAM
.e86b	e6 d8		inc $d8			INC	INSRT			; increment insert count
.e86d					LAB_E86D
.e86d	4c dc e6	jmp $e6dc		JMP	LAB_E6DC		; restore registers, set quote flag and exit
.e870					LAB_E870
.e870	a6 d8		ldx $d8			LDX	INSRT			; get insert count
.e872	f0 05		beq $e879		BEQ	LAB_E879		; branch if no insert space
.e874					LAB_E874
.e874	09 40		ora #$40		ORA	#$40			; change to uppercase/graphic
.e876	4c cb e6	jmp $e6cb		JMP	LAB_E6CB		; insert reversed character, scroll if needed and exit
.e879					LAB_E879
.e879	c9 11		cmp #$11		CMP	#$11			; compare with [CURSOR UP]
.e87b	d0 16		bne $e893		BNE	LAB_E893		; branch if not [CURSOR UP]
.e87d	a6 d6		ldx $d6			LDX	TBLX			; get cursor row
.e87f	f0 37		beq $e8b8		BEQ	LAB_E8B8		; branch if on top line
.e881	c6 d6		dec $d6			DEC	TBLX			; decrement cursor row
.e883	a5 d3		lda $d3			LDA	PNTR			; get cursor column
.e885	38		sec			SEC				; set carry for subtract
.e886	e9 16		sbc #$16		SBC	#$16			; subtract one line length
.e888	90 04		bcc $e88e		BCC	LAB_E88E		; branch if stepped back to previous line
.e88a	85 d3		sta $d3			STA	PNTR			; else save cursor column ..
.e88c	10 2a		bpl $e8b8		BPL	LAB_E8B8		; .. and exit, branch always
.e88e					LAB_E88E
.e88e	20 87 e5	jsr $e587		JSR	SETSLINK		; set screen pointers for cursor row, column ..
.e891	d0 25		bne $e8b8		BNE	LAB_E8B8		; .. and exit, branch always
.e893					LAB_E893
.e893	c9 12		cmp #$12		CMP	#$12			; compare with [RVS OFF]
.e895	d0 04		bne $e89b		BNE	LAB_E89B		; branch if not [RVS OFF]
.e897	a9 00		lda #$00		LDA	#$00			; clear .A
.e899	85 c7		sta $c7			STA	RVS			; clear reverse flag
.e89b					LAB_E89B
.e89b	c9 1d		cmp #$1d		CMP	#$1D			; compare with [CURSOR LEFT]
.e89d	d0 12		bne $e8b1		BNE	LAB_E8B1		; branch if not [CURSOR LEFT]
.e89f	98		tya			TYA				; copy cursor column
.e8a0	f0 09		beq $e8ab		BEQ	LAB_E8AB		; branch if at start of line
.e8a2	20 e8 e8	jsr $e8e8		JSR	BACKUP			; test for line decrement
.e8a5	88		dey			DEY				; decrement cursor column
.e8a6	84 d3		sty $d3			STY	PNTR			; save cursor column
.e8a8	4c dc e6	jmp $e6dc		JMP	LAB_E6DC		; restore registers, set quote flag and exit
.e8ab					LAB_E8AB
.e8ab	20 2d e7	jsr $e72d		JSR	RETREAT			; back onto previous line if possible
.e8ae	4c dc e6	jmp $e6dc		JMP	LAB_E6DC		; restore registers, set quote flag and exit
.e8b1					LAB_E8B1
.e8b1	c9 13		cmp #$13		CMP	#$13			; compare with [CLR]
.e8b3	d0 06		bne $e8bb		BNE	LAB_E8BB		; branch if not [CLR]
.e8b5	20 5f e5	jsr $e55f		JSR	CLSR			; clear screen
.e8b8					LAB_E8B8
.e8b8	4c dc e6	jmp $e6dc		JMP	LAB_E6DC		; restore registers, set quote flag and exit
.e8bb					LAB_E8BB
.e8bb	09 80		ora #$80		ORA	#$80			; restore b7, colour can only be black, cyan, magenta
.e8bd	20 12 e9	jsr $e912		JSR	COLORSET		; set the colour from the character in .A
.e8c0	4c 30 ed	jmp $ed30		JMP	GRAPHMODE		; select VIC character set
.e8c3					NXTLINE
.e8c3	46 c9		lsr $c9			LSR	LXSP			; shift >> input cursor row
.e8c5	a6 d6		ldx $d6			LDX	TBLX			; get cursor row
.e8c7					LAB_E8C7
.e8c7	e8		inx			INX				; increment row
.e8c8	e0 17		cpx #$17		CPX	#$17			; compare with last row + 1
.e8ca	d0 03		bne $e8cf		BNE	LAB_E8CF		; branch if not last row + 1
.e8cc	20 75 e9	jsr $e975		JSR	SCRL			; else scroll screen
.e8cf					LAB_E8CF
.e8cf	b5 d9		lda $d9,x		LDA	LDTB1,X			; get start of line .X pointer high byte
.e8d1	10 f4		bpl $e8c7		BPL	LAB_E8C7		; loop if not start of logical line
.e8d3	86 d6		stx $d6			STX	TBLX			; else save cursor row
.e8d5	4c 87 e5	jmp $e587		JMP	SETSLINK		; set screen pointers for cursor row, column and return
.e8d8					RTRN
.e8d8	a2 00		ldx #$00		LDX	#$00			; clear .X
.e8da	86 d8		stx $d8			STX	INSRT			; clear insert count
.e8dc	86 c7		stx $c7			STX	RVS			; clear reverse flag
.e8de	86 d4		stx $d4			STX	QTSW			; clear cursor quote flag
.e8e0	86 d3		stx $d3			STX	PNTR			; clear cursor column
.e8e2	20 c3 e8	jsr $e8c3		JSR	NXTLINE			; do newline
.e8e5	4c dc e6	jmp $e6dc		JMP	LAB_E6DC		; restore registers, set quote flag and exit
.e8e8					BACKUP
.e8e8	a2 04		ldx #$04		LDX	#$04			; set count
.e8ea	a9 00		lda #$00		LDA	#$00			; set column
.e8ec					LAB_E8EC
.e8ec	c5 d3		cmp $d3			CMP	PNTR			; compare with cursor column
.e8ee	f0 07		beq $e8f7		BEQ	LAB_E8F7		; branch if at start of line
.e8f0	18		clc			CLC				; else clear carry for add
.e8f1	69 16		adc #$16		ADC	#$16			; increment to next line
.e8f3	ca		dex			DEX				; decrement loop count
.e8f4	d0 f6		bne $e8ec		BNE	LAB_E8EC		; loop if more to test
.e8f6	60		rts			RTS
.e8f7					LAB_E8F7
.e8f7	c6 d6		dec $d6			DEC	TBLX			; else decrement cursor row
.e8f9	60		rts			RTS
.e8fa					FORWARD
.e8fa	a2 04		ldx #$04		LDX	#$04			; set count
.e8fc	a9 15		lda #$15		LDA	#$15			; set column
.e8fe					LAB_E8FE
.e8fe	c5 d3		cmp $d3			CMP	PNTR			; compare with cursor column
.e900	f0 07		beq $e909		BEQ	LAB_E909		; if at end of line test and possibly increment cursor row
.e902	18		clc			CLC				; else clear carry for add
.e903	69 16		adc #$16		ADC	#$16			; increment to next line
.e905	ca		dex			DEX				; decrement loop count
.e906	d0 f6		bne $e8fe		BNE	LAB_E8FE		; loop if more to test
.e908	60		rts			RTS
.e909					LAB_E909
.e909	a6 d6		ldx $d6			LDX	TBLX			; get cursor row
.e90b	e0 17		cpx #$17		CPX	#$17			; compare with end of screen
.e90d	f0 02		beq $e911		BEQ	LAB_E911		; exit if end of screen
.e90f	e6 d6		inc $d6			INC	TBLX			; else increment cursor row
.e911					LAB_E911
.e911	60		rts			RTS
.e912					COLORSET
.e912	a2 07		ldx #$07		LDX	#LAB_E928-COLORTBL
.e914					LAB_E914
.e914	dd 21 e9	cmp $e921,x		CMP	COLORTBL,X		; compare the character with the table code
.e917	f0 04		beq $e91d		BEQ	LAB_E91D		; if a match go save the colour and exit
.e919	ca		dex			DEX				; else decrement the index
.e91a	10 f8		bpl $e914		BPL	LAB_E914		; loop if more to do
.e91c	60		rts			RTS
.e91d					LAB_E91D
.e91d	8e 86 02	stx $0286		STX	COLOR			; set current colour code
.e920	60		rts			RTS
.e921					COLORTBL
>e921	90					.byte	$90			;  144		black
>e922	05					.byte	$05			;    5		white
>e923	1c					.byte	$1C			;   28		red
>e924	9f					.byte	$9F			;  159		cyan
>e925	9c					.byte	$9C			;  156		magenta
>e926	1e					.byte	$1E			;   30		green
>e927	1f					.byte	$1F			;   31		blue
.e928					LAB_E928
>e928	9e					.byte	$9E			;  158		yellow
>e929	ef a1 df a6 e1 b1 e2 b2			.byte	$EF,$A1,$DF,$A6,$E1,$B1,$E2,$B2,$E3,$B3,$E4,$B4,$E5,$B5,$E6,$B6
>e931	e3 b3 e4 b4 e5 b5 e6 b6
>e939	e7 b7 e8 b8 e9 b9 fa ba			.byte	$E7,$B7,$E8,$B8,$E9,$B9,$FA,$BA,$FB,$BB,$FC,$BC,$EC,$BD,$FE,$BE
>e941	fb bb fc bc ec bd fe be
>e949	84 bf f7 c0 f8 db f9 dd			.byte	$84,$BF,$F7,$C0,$F8,$DB,$F9,$DD,$EA,$DE,$5E,$E0,$5B,$E1,$5D,$E2
>e951	ea de 5e e0 5b e1 5d e2
>e959	40 b0 61 b1 78 db 79 dd			.byte	$40,$B0,$61,$B1,$78,$DB,$79,$DD,$66,$B6,$77,$C0,$70,$F0,$71,$F1
>e961	66 b6 77 c0 70 f0 71 f1
>e969	72 f2 73 f3 74 f4 75 f5			.byte	$72,$F2,$73,$F3,$74,$F4,$75,$F5,$76,$F6,$7D,$FD
>e971	76 f6 7d fd
.e975					SCRL
.e975	a5 ac		lda $ac			LDA	SAL			; copy tape buffer start pointer
.e977	48		pha			PHA				; save it
.e978	a5 ad		lda $ad			LDA	SAL+1			; copy tape buffer start pointer
.e97a	48		pha			PHA				; save it
.e97b	a5 ae		lda $ae			LDA	EAL			; copy tape buffer end pointer
.e97d	48		pha			PHA				; save it
.e97e	a5 af		lda $af			LDA	EAL+1			; copy tape buffer end pointer
.e980	48		pha			PHA				; save it
.e981					LAB_E981
.e981	a2 ff		ldx #$ff		LDX	#$FF			; set to -1 for pre increment loop
.e983	c6 d6		dec $d6			DEC	TBLX			; decrement cursor row
.e985	c6 c9		dec $c9			DEC	LXSP			; decrement input cursor row
.e987	c6 f2		dec $f2			DEC	LLNKSV			; decrement screen row marker
.e989					LAB_E989
.e989	e8		inx			INX				; increment line number
.e98a	20 7e ea	jsr $ea7e		JSR	LINPTR			; set start of line .X
.e98d	e0 16		cpx #$16		CPX	#$16			; compare with last line
.e98f	b0 0c		bcs $e99d		BCS	LAB_E99D		; branch if >= $16
.e991	bd fe ed	lda $edfe,x		LDA	LDTB2+1,X		; get start of next line pointer low byte
.e994	85 ac		sta $ac			STA	SAL			; save next line pointer low byte
.e996	b5 da		lda $da,x		LDA	LDTB1+1,X		; get start of next line pointer high byte
.e998	20 56 ea	jsr $ea56		JSR	MOVLIN			; shift screen line up
.e99b	30 ec		bmi $e989		BMI	LAB_E989		; loop, branch always
.e99d					LAB_E99D
.e99d	20 8d ea	jsr $ea8d		JSR	CLRALINE		; clear screen line .X
.e9a0	a2 00		ldx #$00		LDX	#$00			; clear index
.e9a2					LAB_E9A2
.e9a2	b5 d9		lda $d9,x		LDA	LDTB1,X			; get start of line .X pointer high byte
.e9a4	29 7f		and #$7f		AND	#$7F			; clear line .X start of logical line bit
.e9a6	b4 da		ldy $da,x		LDY	LDTB1+1,X		; get start of next line pointer high byte
.e9a8	10 02		bpl $e9ac		BPL	LAB_E9AC		; branch if next line not start of line
.e9aa	09 80		ora #$80		ORA	#$80			; set line .X start of logical line bit
.e9ac					LAB_E9AC
.e9ac	95 d9		sta $d9,x		STA	LDTB1,X			; set start of line .X pointer high byte
.e9ae	e8		inx			INX				; increment line number
.e9af	e0 16		cpx #$16		CPX	#$16			; compare with last line
.e9b1	d0 ef		bne $e9a2		BNE	LAB_E9A2		; loop if not last line
.e9b3	a5 ef		lda $ef			LDA	LDTB1+$16		; get start of last line pointer high byte
.e9b5	09 80		ora #$80		ORA	#$80			; mark as start of logical line
.e9b7	85 ef		sta $ef			STA	LDTB1+$16		; set start of last line pointer high byte
.e9b9	a5 d9		lda $d9			LDA	LDTB1			; get start of first line pointer high byte
.e9bb	10 c4		bpl $e981		BPL	LAB_E981		; if not start of logical line loop back and
.e9bd	e6 d6		inc $d6			INC	TBLX			; increment cursor row
.e9bf	e6 f2		inc $f2			INC	LLNKSV			; increment screen row marker
.e9c1	a9 fb		lda #$fb		LDA	#$FB			; set keyboard column c2
.e9c3	8d 20 91	sta $9120		STA	VIA2PB			; set VIA 2 DRB, keyboard column
.e9c6	ad 21 91	lda $9121		LDA	VIA2PA1			; get VIA 2 DRA, keyboard row
.e9c9	c9 fe		cmp #$fe		CMP	#$FE			; compare with row r0 active, [CTRL]
.e9cb	08		php			PHP				; save status
.e9cc	a9 f7		lda #$f7		LDA	#$F7			; set keyboard column c3
.e9ce	8d 20 91	sta $9120		STA	VIA2PB			; set VIA 2 DRB, keyboard column
.e9d1	28		plp			PLP				; restore status
.e9d2	d0 0b		bne $e9df		BNE	LAB_E9DF		; skip delay if [CTRL] not pressed
.e9d4	a0 00		ldy #$00		LDY	#$00			; clear delay outer loop count, do this 256 times
.e9d6					LAB_E9D6
.e9d6	ea		nop			NOP				; waste cycles
.e9d7	ca		dex			DEX				; decrement inner loop count
.e9d8	d0 fc		bne $e9d6		BNE	LAB_E9D6		; loop if not all done
.e9da	88		dey			DEY				; decrement outer loop count
.e9db	d0 f9		bne $e9d6		BNE	LAB_E9D6		; loop if not all done
.e9dd	84 c6		sty $c6			STY	NDX			; clear keyboard buffer index
.e9df					LAB_E9DF
.e9df	a6 d6		ldx $d6			LDX	TBLX			; get cursor row
.e9e1	68		pla			PLA				; pull tape buffer end pointer
.e9e2	85 af		sta $af			STA	EAL+1			; restore it
.e9e4	68		pla			PLA				; pull tape buffer end pointer
.e9e5	85 ae		sta $ae			STA	EAL			; restore it
.e9e7	68		pla			PLA				; pull tape buffer pointer
.e9e8	85 ad		sta $ad			STA	SAL+1			; restore it
.e9ea	68		pla			PLA				; pull tape buffer pointer
.e9eb	85 ac		sta $ac			STA	SAL			; restore it
.e9ed	60		rts			RTS
.e9ee					OPENLIN
.e9ee	a6 d6		ldx $d6			LDX	TBLX			; get cursor row
.e9f0					LAB_E9F0
.e9f0	e8		inx			INX				; increment row
.e9f1	b5 d9		lda $d9,x		LDA	LDTB1,X			; get start of line .X pointer high byte
.e9f3	10 fb		bpl $e9f0		BPL	LAB_E9F0		; branch if not start of logical line
.e9f5	86 f2		stx $f2			STX	LLNKSV			; set screen row marker
.e9f7	e0 16		cpx #$16		CPX	#$16			; compare with last line
.e9f9	f0 0d		beq $ea08		BEQ	LAB_EA08		; branch if = last line
.e9fb	90 0b		bcc $ea08		BCC	LAB_EA08		; branch if < last line
.e9fd	20 75 e9	jsr $e975		JSR	SCRL			; else scroll screen
.ea00	a6 f2		ldx $f2			LDX	LLNKSV			; get screen row marker
.ea02	ca		dex			DEX				; decrement screen row marker
.ea03	c6 d6		dec $d6			DEC	TBLX			; decrement cursor row
.ea05	4c 0e e7	jmp $e70e		JMP	LAB_E70E		; add this row to the current logical line and return
.ea08					LAB_EA08
.ea08	a5 ac		lda $ac			LDA	SAL			; copy tape buffer pointer
.ea0a	48		pha			PHA				; save it
.ea0b	a5 ad		lda $ad			LDA	SAL+1			; copy tape buffer pointer
.ea0d	48		pha			PHA				; save it
.ea0e	a5 ae		lda $ae			LDA	EAL			; copy tape buffer end pointer
.ea10	48		pha			PHA				; save it
.ea11	a5 af		lda $af			LDA	EAL+1			; copy tape buffer end pointer
.ea13	48		pha			PHA				; save it
.ea14	a2 17		ldx #$17		LDX	#$17			; set to end line + 1 for predecrement loop
.ea16					LAB_EA16
.ea16	ca		dex			DEX				; decrement line number
.ea17	20 7e ea	jsr $ea7e		JSR	LINPTR			; set start of line .X
.ea1a	e4 f2		cpx $f2			CPX	LLNKSV			; compare with screen row marker
.ea1c	90 0e		bcc $ea2c		BCC	LAB_EA2C		; branch if < screen row marker
.ea1e	f0 0c		beq $ea2c		BEQ	LAB_EA2C		; branch if = screen row marker
.ea20	bd fc ed	lda $edfc,x		LDA	LDTB2-1,X		; else get start of previous line low byte from ROM table
.ea23	85 ac		sta $ac			STA	SAL			; save previous line pointer low byte
.ea25	b5 d8		lda $d8,x		LDA	LDTB1-1,X		; get start of previous line pointer high byte
.ea27	20 56 ea	jsr $ea56		JSR	MOVLIN			; shift screen line down
.ea2a	30 ea		bmi $ea16		BMI	LAB_EA16		; loop, branch always
.ea2c					LAB_EA2C
.ea2c	20 8d ea	jsr $ea8d		JSR	CLRALINE		; clear screen line .X
.ea2f	a2 15		ldx #$15		LDX	#$15			; set index to last screen row - 1
.ea31					LAB_EA31
.ea31	e4 f2		cpx $f2			CPX	LLNKSV			; compare with saved screen row
.ea33	90 0f		bcc $ea44		BCC	LAB_EA44		; reached insertion point so stop
.ea35	b5 da		lda $da,x		LDA	LDTB1+1,X		; get start of line .X + 1 pointer high byte
.ea37	29 7f		and #$7f		AND	#$7F			; clear start of logical line bit
.ea39	b4 d9		ldy $d9,x		LDY	LDTB1,X			; get start of line .X pointer high byte
.ea3b	10 02		bpl $ea3f		BPL	LAB_EA3F		; branch if start of logical line bit clear
.ea3d	09 80		ora #$80		ORA	#$80			; set start of logical line bit
.ea3f					LAB_EA3F
.ea3f	95 da		sta $da,x		STA	LDTB1+1,X		; update start of line .X + 1 pointer high byte
.ea41	ca		dex			DEX				; decrement index
.ea42	d0 ed		bne $ea31		BNE	LAB_EA31		; branch always
.ea44					LAB_EA44
.ea44	a6 f2		ldx $f2			LDX	LLNKSV			; get saved screen row
.ea46	20 0e e7	jsr $e70e		JSR	LAB_E70E		; add this row to the current logical line
.ea49	68		pla			PLA				; pull tape buffer end pointer
.ea4a	85 af		sta $af			STA	EAL+1			; restore it
.ea4c	68		pla			PLA				; pull tape buffer end pointer
.ea4d	85 ae		sta $ae			STA	EAL			; restore it
.ea4f	68		pla			PLA				; pull tape buffer pointer
.ea50	85 ad		sta $ad			STA	SAL+1			; restore it
.ea52	68		pla			PLA				; pull tape buffer pointer
.ea53	85 ac		sta $ac			STA	SAL			; restore it
.ea55	60		rts			RTS
.ea56					MOVLIN
.ea56	29 03		and #$03		AND	#$03			; mask 0000 00xx, line memory page
.ea58	0d 88 02	ora $0288		ORA	HIBASE			; OR with screen memory page
.ea5b	85 ad		sta $ad			STA	SAL+1			; save next/previous line pointer high byte
.ea5d	20 6e ea	jsr $ea6e		JSR	SETADDR			; calculate pointers to screen lines colour RAM
.ea60					LAB_EA60
.ea60	a0 15		ldy #$15		LDY	#$15			; set column count
.ea62					LAB_EA62
.ea62	b1 ac		lda ($ac),y		LDA	(SAL),Y			; get character from next/previous screen line
.ea64	91 d1		sta ($d1),y		STA	(PNT),Y			; save character to current screen line
.ea66	b1 ae		lda ($ae),y		LDA	(EAL),Y			; get colour from next/previous screen line colour RAM
.ea68	91 f3		sta ($f3),y		STA	(USER),Y		; save colour to current screen line colour RAM
.ea6a	88		dey			DEY				; decrement column index/count
.ea6b	10 f5		bpl $ea62		BPL	LAB_EA62		; loop if more to do
.ea6d	60		rts			RTS
.ea6e					SETADDR
.ea6e	20 b2 ea	jsr $eab2		JSR	COLORSYN		; calculate pointer to current screen line colour RAM
.ea71	a5 ac		lda $ac			LDA	SAL			; get next screen line pointer low byte
.ea73	85 ae		sta $ae			STA	EAL			; save next screen line colour RAM pointer low byte
.ea75	a5 ad		lda $ad			LDA	SAL+1			; get next screen line pointer high byte
.ea77	29 03		and #$03		AND	#$03			; mask 0000 00xx, line memory page
.ea79	09 94		ora #$94		ORA	#$94			; set  1001 01xx, colour memory page
.ea7b	85 af		sta $af			STA	EAL+1			; save next screen line colour RAM pointer high byte
.ea7d	60		rts			RTS
.ea7e					LINPTR
.ea7e	bd fd ed	lda $edfd,x		LDA	LDTB2,X			; get start of line low byte from ROM table
.ea81	85 d1		sta $d1			STA	PNT			; set current screen line pointer low byte
.ea83	b5 d9		lda $d9,x		LDA	LDTB1,X			; get start of line high byte from RAM table
.ea85	29 03		and #$03		AND	#$03			; mask 0000 00xx, line memory page
.ea87	0d 88 02	ora $0288		ORA	HIBASE			; OR with screen memory page
.ea8a	85 d2		sta $d2			STA	PNT+1			; set current screen line pointer high byte
.ea8c	60		rts			RTS
.ea8d					CLRALINE
.ea8d	a0 15		ldy #$15		LDY	#$15			; set number of columns to clear
.ea8f	20 7e ea	jsr $ea7e		JSR	LINPTR			; set start of line .X
.ea92	20 b2 ea	jsr $eab2		JSR	COLORSYN		; calculate pointer to colour RAM
.ea95					LAB_EA95
.ea95	a9 20		lda #$20		LDA	#' '			; set [SPACE]
.ea97	91 d1		sta ($d1),y		STA	(PNT),Y			; clear character in current screen line
.ea99	a9 01		lda #$01		LDA	#$01			; set colour, blue on white
.ea9b	91 f3		sta ($f3),y		STA	(USER),Y		; set colour RAM in current screen line
.ea9d	88		dey			DEY				; decrement index
.ea9e	10 f5		bpl $ea95		BPL	LAB_EA95		; loop if more to do
.eaa0	60		rts			RTS
.eaa1					SYNPRT
.eaa1	a8		tay			TAY				; copy character
.eaa2	a9 02		lda #$02		LDA	#$02			; set count to $02, usually $14 ??
.eaa4	85 cd		sta $cd			STA	BLNCT			; set cursor countdown
.eaa6	20 b2 ea	jsr $eab2		JSR	COLORSYN		; calculate pointer to colour RAM
.eaa9	98		tya			TYA				; get character back
.eaaa					PUTSCRN
.eaaa	a4 d3		ldy $d3			LDY	PNTR			; get cursor column
.eaac	91 d1		sta ($d1),y		STA	(PNT),Y			; save character from current screen line
.eaae	8a		txa			TXA				; copy colour to .A
.eaaf	91 f3		sta ($f3),y		STA	(USER),Y		; save to colour RAM
.eab1	60		rts			RTS
.eab2					COLORSYN
.eab2	a5 d1		lda $d1			LDA	PNT			; get current screen line pointer low byte
.eab4	85 f3		sta $f3			STA	USER			; save pointer to colour RAM low byte
.eab6	a5 d2		lda $d2			LDA	PNT+1			; get current screen line pointer high byte
.eab8	29 03		and #$03		AND	#$03			; mask 0000 00xx, line memory page
.eaba	09 94		ora #$94		ORA	#$94			; set  1001 01xx, colour memory page
.eabc	85 f4		sta $f4			STA	USER+1			; save pointer to colour RAM high byte
.eabe	60		rts			RTS
.eabf					IRQ
.eabf	20 ea ff	jsr $ffea		JSR	UDTIM			; increment real time clock
.eac2	a5 cc		lda $cc			LDA	BLNSW			; get cursor enable
.eac4	d0 29		bne $eaef		BNE	LAB_EAEF		; branch if not flash cursor
.eac6	c6 cd		dec $cd			DEC	BLNCT			; else decrement cursor timing countdown
.eac8	d0 25		bne $eaef		BNE	LAB_EAEF		; branch if not done
.eaca	a9 14		lda #$14		LDA	#$14			; set count
.eacc	85 cd		sta $cd			STA	BLNCT			; save cursor timing countdown
.eace	a4 d3		ldy $d3			LDY	PNTR			; get cursor column
.ead0	46 cf		lsr $cf			LSR	BLNON			; shift b0 cursor blink phase into carry
.ead2	ae 87 02	ldx $0287		LDX	GDCOL			; get colour under cursor
.ead5	b1 d1		lda ($d1),y		LDA	(PNT),Y			; get character from current screen line
.ead7	b0 11		bcs $eaea		BCS	LAB_EAEA		; branch if cursor phase b0 was 1
.ead9	e6 cf		inc $cf			INC	BLNON			; set cursor blink phase to 1
.eadb	85 ce		sta $ce			STA	CDBLN			; save character under cursor
.eadd	20 b2 ea	jsr $eab2		JSR	COLORSYN		; calculate pointer to colour RAM
.eae0	b1 f3		lda ($f3),y		LDA	(USER),Y		; get colour RAM byte
.eae2	8d 87 02	sta $0287		STA	GDCOL			; save colour under cursor
.eae5	ae 86 02	ldx $0286		LDX	COLOR			; get current colour code
.eae8	a5 ce		lda $ce			LDA	CDBLN			; get character under cursor
.eaea					LAB_EAEA
.eaea	49 80		eor #$80		EOR	#$80			; toggle b7 of character under cursor
.eaec	20 aa ea	jsr $eaaa		JSR	PUTSCRN			; save character and colour to screen @ cursor
.eaef					LAB_EAEF
.eaef	ad 1f 91	lda $911f		LDA	VIA1PA2			; get VIA 1 DRA, no handshake
.eaf2	29 40		and #$40		AND	#$40			; mask cassette switch sense
.eaf4	f0 0b		beq $eb01		BEQ	LAB_EB01		; branch if cassette sense low
.eaf6	a0 00		ldy #$00		LDY	#$00			; clear .Y
.eaf8	84 c0		sty $c0			STY	CAS1			; clear the tape motor interlock
.eafa	ad 1c 91	lda $911c		LDA	VIA1PCR			; get VIA 1 PCR
.eafd	09 02		ora #$02		ORA	#$02			; set CA2 high, turn off motor
.eaff	d0 09		bne $eb0a		BNE	LAB_EB0A		; branch always
.eb01					LAB_EB01
.eb01	a5 c0		lda $c0			LDA	CAS1			; get tape motor interlock
.eb03	d0 0d		bne $eb12		BNE	LAB_EB12		; if cassette interlock <> 0 don't turn on motor
.eb05	ad 1c 91	lda $911c		LDA	VIA1PCR			; get VIA 1 PCR
.eb08	29 fd		and #$fd		AND	#$FD			; set CA2 low, turn on motor
.eb0a					LAB_EB0A
.eb0a	2c 1e 91	bit $911e		BIT	VIA1IER			; test VIA 1 IER
.eb0d	70 03		bvs $eb12		BVS	LAB_EB12		; if T1 interrupt enabled don't change motor state
.eb0f	8d 1c 91	sta $911c		STA	VIA1PCR			; set VIA 1 PCR, set CA2 high/low
.eb12					LAB_EB12
.eb12	20 1e eb	jsr $eb1e		JSR	FSCNKEY			; scan keyboard
.eb15	2c 24 91	bit $9124		BIT	VIA2T1CL		; test VIA 2 T1C_l, clear the timer interrupt flag
.eb18	68		pla			PLA				; pull .Y
.eb19	a8		tay			TAY				; restore .Y
.eb1a	68		pla			PLA				; pull .X
.eb1b	aa		tax			TAX				; restore .X
.eb1c	68		pla			PLA				; restore .A
.eb1d	40		rti			RTI
.eb1e					FSCNKEY
.eb1e	a9 00		lda #$00		LDA	#$00			; clear .A
.eb20	8d 8d 02	sta $028d		STA	SHFLAG			; clear keyboard shift/control/C= flag
.eb23	a0 40		ldy #$40		LDY	#$40			; set no key
.eb25	84 cb		sty $cb			STY	SFDX			; save which key
.eb27	8d 20 91	sta $9120		STA	VIA2PB			; clear VIA 2 DRB, keyboard column
.eb2a	ae 21 91	ldx $9121		LDX	VIA2PA1			; get VIA 2 DRA, keyboard row
.eb2d	e0 ff		cpx #$ff		CPX	#$FF			; compare with all bits set
.eb2f	f0 5e		beq $eb8f		BEQ	LAB_EB8F		; if no key pressed clear current key and exit (does
.eb31	a9 fe		lda #$fe		LDA	#$FE			; set column 0 low
.eb33	8d 20 91	sta $9120		STA	VIA2PB			; set VIA 2 DRB, keyboard column
.eb36	a0 00		ldy #$00		LDY	#$00			; clear key count
.eb38	a9 5e		lda #$5e		LDA	#<NORMKEYS		; get decode table low byte
.eb3a	85 f5		sta $f5			STA	KEYTAB			; set keyboard pointer low byte
.eb3c	a9 ec		lda #$ec		LDA	#>NORMKEYS		; get decode table high byte
.eb3e	85 f6		sta $f6			STA	KEYTAB+1		; set keyboard pointer high byte
.eb40					LAB_EB40
.eb40	a2 08		ldx #$08		LDX	#$08			; set row count
.eb42	ad 21 91	lda $9121		LDA	VIA2PA1			; get VIA 2 DRA, keyboard row
.eb45	cd 21 91	cmp $9121		CMP	VIA2PA1			; compare with itself
.eb48	d0 f6		bne $eb40		BNE	LAB_EB40		; loop if changing
.eb4a					LAB_EB4A
.eb4a	4a		lsr a			LSR				; shift row to Cb
.eb4b	b0 16		bcs $eb63		BCS	LAB_EB63		; if no key closed on this row go do next row
.eb4d	48		pha			PHA				; save row
.eb4e	b1 f5		lda ($f5),y		LDA	(KEYTAB),Y		; get character from decode table
.eb50	c9 05		cmp #$05		CMP	#$05			; compare with $05, there is no $05 key but the control
.eb52	b0 0c		bcs $eb60		BCS	LAB_EB60		; if not shift/control/C=/stop go save key count
.eb54	c9 03		cmp #$03		CMP	#$03			; compare with $03, stop
.eb56	f0 08		beq $eb60		BEQ	LAB_EB60		; if stop go save key count and continue
.eb58	0d 8d 02	ora $028d		ORA	SHFLAG			; OR keyboard shift/control/C= flag
.eb5b	8d 8d 02	sta $028d		STA	SHFLAG			; save keyboard shift/control/C= flag
.eb5e	10 02		bpl $eb62		BPL	LAB_EB62		; skip save key, branch always
.eb60					LAB_EB60
.eb60	84 cb		sty $cb			STY	SFDX			; save which key
.eb62					LAB_EB62
.eb62	68		pla			PLA				; restore row
.eb63					LAB_EB63
.eb63	c8		iny			INY				; increment key count
.eb64	c0 41		cpy #$41		CPY	#$41			; compare with max+1
.eb66	b0 09		bcs $eb71		BCS	LAB_EB71		; exit loop if >= max+1
.eb68	ca		dex			DEX				; decrement row count
.eb69	d0 df		bne $eb4a		BNE	LAB_EB4A		; loop if more rows to do
.eb6b	38		sec			SEC				; set carry for keyboard column shift
.eb6c	2e 20 91	rol $9120		ROL	VIA2PB			; shift VIA 2 DRB, keyboard column
.eb6f	d0 cf		bne $eb40		BNE	LAB_EB40		; loop for next column, branch always
.eb71					LAB_EB71
.eb71	6c 8f 02	jmp ($028f)		JMP	(KEYLOG)		; evaluate the SHIFT/CTRL/C= keys, SETKEYS
.eb74					LAB_EB74
.eb74	a4 cb		ldy $cb			LDY	SFDX			; get which key
.eb76	b1 f5		lda ($f5),y		LDA	(KEYTAB),Y		; get character from decode table
.eb78	aa		tax			TAX				; copy character to .X
.eb79	c4 c5		cpy $c5			CPY	LSTX			; compare which key with last key
.eb7b	f0 07		beq $eb84		BEQ	LAB_EB84		; if this key = current key, key held, go test repeat
.eb7d	a0 10		ldy #$10		LDY	#$10			; set repeat delay count
.eb7f	8c 8c 02	sty $028c		STY	DELAY			; save repeat delay count
.eb82	d0 36		bne $ebba		BNE	LAB_EBBA		; go save key to buffer and exit, branch always
.eb84					LAB_EB84
.eb84	29 7f		and #$7f		AND	#$7F			; clear b7
.eb86	2c 8a 02	bit $028a		BIT	RPTFLG			; test key repeat
.eb89	30 16		bmi $eba1		BMI	LAB_EBA1		; branch if repeat all
.eb8b	70 49		bvs $ebd6		BVS	LAB_EBD6		; branch if repeat none
.eb8d	c9 7f		cmp #$7f		CMP	#$7F			; compare with end marker
.eb8f					LAB_EB8F
.eb8f	f0 29		beq $ebba		BEQ	LAB_EBBA		; if $00/end marker go save key to buffer and exit
.eb91	c9 14		cmp #$14		CMP	#$14			; compare with [INSERT]/[DELETE]
.eb93	f0 0c		beq $eba1		BEQ	LAB_EBA1		; if [INSERT]/[DELETE] go test for repeat
.eb95	c9 20		cmp #$20		CMP	#' '			; compare with [SPACE]
.eb97	f0 08		beq $eba1		BEQ	LAB_EBA1		; if [SPACE] go test for repeat
.eb99	c9 1d		cmp #$1d		CMP	#$1D			; compare with [CURSOR RIGHT]/[CURSOR LEFT]
.eb9b	f0 04		beq $eba1		BEQ	LAB_EBA1		; if [CURSOR RIGHT]/[CURSOR LEFT] go test for repeat
.eb9d	c9 11		cmp #$11		CMP	#$11			; compare with [CURSOR DOWN]/[CURSOR UP]
.eb9f	d0 35		bne $ebd6		BNE	LAB_EBD6		; if not [CURSOR DOWN]/[CURSOR UP] just exit
.eba1					LAB_EBA1
.eba1	ac 8c 02	ldy $028c		LDY	DELAY			; get repeat delay counter
.eba4	f0 05		beq $ebab		BEQ	LAB_EBAB		; branch if delay expired
.eba6	ce 8c 02	dec $028c		DEC	DELAY			; else decrement repeat delay counter
.eba9	d0 2b		bne $ebd6		BNE	LAB_EBD6		; branch if delay not expired
.ebab					LAB_EBAB
.ebab	ce 8b 02	dec $028b		DEC	KOUNT			; decrement repeat speed counter
.ebae	d0 26		bne $ebd6		BNE	LAB_EBD6		; branch if repeat speed count not expired
.ebb0	a0 04		ldy #$04		LDY	#$04			; set for 4/60ths of a second
.ebb2	8c 8b 02	sty $028b		STY	KOUNT			; set repeat speed counter
.ebb5	a4 c6		ldy $c6			LDY	NDX			; get keyboard buffer index
.ebb7	88		dey			DEY				; decrement it
.ebb8	10 1c		bpl $ebd6		BPL	LAB_EBD6		; if the buffer isn't empty just exit
.ebba					LAB_EBBA
.ebba	a4 cb		ldy $cb			LDY	SFDX			; get which key
.ebbc	84 c5		sty $c5			STY	LSTX			; save as last key pressed
.ebbe	ac 8d 02	ldy $028d		LDY	SHFLAG			; get keyboard shift/control/C= flag
.ebc1	8c 8e 02	sty $028e		STY	LSTSHF			; save as last keyboard shift pattern
.ebc4	e0 ff		cpx #$ff		CPX	#$FF			; compare character with table end marker or no key
.ebc6	f0 0e		beq $ebd6		BEQ	LAB_EBD6		; if table end marker or no key just exit
.ebc8	8a		txa			TXA				; copy character to .A
.ebc9	a6 c6		ldx $c6			LDX	NDX			; get keyboard buffer index
.ebcb	ec 89 02	cpx $0289		CPX	XMAX			; compare with keyboard buffer size
.ebce	b0 06		bcs $ebd6		BCS	LAB_EBD6		; if buffer full just exit
.ebd0	9d 77 02	sta $0277,x		STA	KEYD,X			; save character to keyboard buffer
.ebd3	e8		inx			INX				; increment index
.ebd4	86 c6		stx $c6			STX	NDX			; save keyboard buffer index
.ebd6					LAB_EBD6
.ebd6	a9 f7		lda #$f7		LDA	#$F7			; enable column 3 for stop key
.ebd8	8d 20 91	sta $9120		STA	VIA2PB			; set VIA 2 DRB, keyboard column
.ebdb	60		rts			RTS
.ebdc					SETKEYS
.ebdc	ad 8d 02	lda $028d		LDA	SHFLAG			; get keyboard shift/control/C= flag
.ebdf	c9 03		cmp #$03		CMP	#$03			; compare with [SHIFT][C=]
.ebe1	d0 2c		bne $ec0f		BNE	LAB_EC0F		; branch if not [SHIFT][C=]
.ebe3	cd 8e 02	cmp $028e		CMP	LSTSHF			; compare with last
.ebe6	f0 ee		beq $ebd6		BEQ	LAB_EBD6		; exit if still the same
.ebe8	ad 91 02	lda $0291		LDA	MODE			; get shift mode switch $00 = enabled, $80 = locked
.ebeb	30 56		bmi $ec43		BMI	LAB_EC43		; if locked continue keyboard decode
.ebed	ea		nop			NOP				; just a few wasted cycles
.ebee	ea		nop			NOP				;
.ebef	ea		nop			NOP				;
.ebf0	ea		nop			NOP				;
.ebf1	ea		nop			NOP				;
.ebf2	ea		nop			NOP				;
.ebf3	ea		nop			NOP				;
.ebf4	ea		nop			NOP				;
.ebf5	ea		nop			NOP				;
.ebf6	ea		nop			NOP				;
.ebf7	ea		nop			NOP				;
.ebf8	ea		nop			NOP				;
.ebf9	ea		nop			NOP				;
.ebfa	ea		nop			NOP				;
.ebfb	ea		nop			NOP				;
.ebfc	ea		nop			NOP				;
.ebfd	ea		nop			NOP				;
.ebfe	ea		nop			NOP				;
.ebff	ea		nop			NOP				;
.ec00	ad 05 90	lda $9005		LDA	VICCR5			; get start of character memory, ROM
.ec03	49 02		eor #$02		EOR	#$02			; toggle $8000,$8800
.ec05	8d 05 90	sta $9005		STA	VICCR5			; set start of character memory, ROM
.ec08	ea		nop			NOP				;
.ec09	ea		nop			NOP				;
.ec0a	ea		nop			NOP				;
.ec0b	ea		nop			NOP				;
.ec0c	4c 43 ec	jmp $ec43		JMP	LAB_EC43		; continue keyboard decode
.ec0f					LAB_EC0F
.ec0f	0a		asl a			ASL				; << 1
.ec10	c9 08		cmp #$08		CMP	#$08			; compare with [CTRL]
.ec12	90 04		bcc $ec18		BCC	LAB_EC18		; branch if not [CTRL] pressed
.ec14	a9 06		lda #$06		LDA	#$06			; else [CTRL] was pressed so make index = $06
.ec16	ea		nop			NOP				;
.ec17	ea		nop			NOP				;
.ec18					LAB_EC18
.ec18	ea		nop			NOP				; just a few wasted cycles
.ec19	ea		nop			NOP				;
.ec1a	ea		nop			NOP				;
.ec1b	ea		nop			NOP				;
.ec1c	ea		nop			NOP				;
.ec1d	ea		nop			NOP				;
.ec1e	ea		nop			NOP				;
.ec1f	ea		nop			NOP				;
.ec20	ea		nop			NOP				;
.ec21	ea		nop			NOP				;
.ec22	ea		nop			NOP				;
.ec23	ea		nop			NOP				;
.ec24	ea		nop			NOP				;
.ec25	ea		nop			NOP				;
.ec26	ea		nop			NOP				;
.ec27	ea		nop			NOP				;
.ec28	ea		nop			NOP				;
.ec29	ea		nop			NOP				;
.ec2a	ea		nop			NOP				;
.ec2b	ea		nop			NOP				;
.ec2c	ea		nop			NOP				;
.ec2d	ea		nop			NOP				;
.ec2e	ea		nop			NOP				;
.ec2f	ea		nop			NOP				;
.ec30	ea		nop			NOP				;
.ec31	ea		nop			NOP				;
.ec32	ea		nop			NOP				;
.ec33	ea		nop			NOP				;
.ec34	ea		nop			NOP				;
.ec35	ea		nop			NOP				;
.ec36	ea		nop			NOP				;
.ec37	ea		nop			NOP				;
.ec38	aa		tax			TAX				; copy index to .X
.ec39	bd 46 ec	lda $ec46,x		LDA	KEYVCTRS,X		; get decode table pointer low byte
.ec3c	85 f5		sta $f5			STA	KEYTAB			; save decode table pointer low byte
.ec3e	bd 47 ec	lda $ec47,x		LDA	KEYVCTRS+1,X		; get decode table pointer high byte
.ec41	85 f6		sta $f6			STA	KEYTAB+1		; save decode table pointer high byte
.ec43					LAB_EC43
.ec43	4c 74 eb	jmp $eb74		JMP	LAB_EB74		; continue keyboard decode
.ec46					KEYVCTRS
>ec46	5e ec					.word	NORMKEYS		; unshifted
>ec48	9f ec					.word	SHFTKEYS		; shifted
>ec4a	e0 ec					.word	LOGOKEYS		; commodore
>ec4c	a3 ed					.word	CTRLKEYS		; control
>ec4e	5e ec					.word	NORMKEYS		; unshifted
>ec50	9f ec					.word	SHFTKEYS		; shifted
>ec52	69 ed					.word	WHATKEYS		; shifted
>ec54	a3 ed					.word	CTRLKEYS		; control
>ec56	21 ed					.word	CHARSET			; graphics/text control
>ec58	69 ed					.word	WHATKEYS		; shifted
>ec5a	69 ed					.word	WHATKEYS		; shifted
>ec5c	a3 ed					.word	CTRLKEYS		; control
.ec5e					NORMKEYS
>ec5e	31 33 35 37 39 2b 5c 14			.byte	$31,$33,$35,$37,$39,$2B,$5C,$14
>ec66	5f 57 52 59 49 50 2a 0d			.byte	$5F,$57,$52,$59,$49,$50,$2A,$0D
>ec6e	04 41 44 47 4a 4c 3b 1d			.byte	$04,$41,$44,$47,$4A,$4C,$3B,$1D
>ec76	03 01 58 56 4e 2c 2f 11			.byte	$03,$01,$58,$56,$4E,$2C,$2F,$11
>ec7e	20 5a 43 42 4d 2e 01 85			.byte	$20,$5A,$43,$42,$4D,$2E,$01,$85
>ec86	02 53 46 48 4b 3a 3d 86			.byte	$02,$53,$46,$48,$4B,$3A,$3D,$86
>ec8e	51 45 54 55 4f 40 5e 87			.byte	$51,$45,$54,$55,$4F,$40,$5E,$87
>ec96	32 34 36 38 30 2d 13 88			.byte	$32,$34,$36,$38,$30,$2D,$13,$88
>ec9e	ff					.byte	$FF
.ec9f					SHFTKEYS
>ec9f	21 23 25 27 29 db a9 94			.byte	$21,$23,$25,$27,$29,$DB,$A9,$94
>eca7	5f d7 d2 d9 c9 d0 c0 8d			.byte	$5F,$D7,$D2,$D9,$C9,$D0,$C0,$8D
>ecaf	04 c1 c4 c7 ca cc 5d 9d			.byte	$04,$C1,$C4,$C7,$CA,$CC,$5D,$9D
>ecb7	83 01 d8 d6 ce 3c 3f 91			.byte	$83,$01,$D8,$D6,$CE,$3C,$3F,$91
>ecbf	a0 da c3 c2 cd 3e 01 89			.byte	$A0,$DA,$C3,$C2,$CD,$3E,$01,$89
>ecc7	02 d3 c6 c8 cb 5b 3d 8a			.byte	$02,$D3,$C6,$C8,$CB,$5B,$3D,$8A
>eccf	d1 c5 d4 d5 cf ba de 8b			.byte	$D1,$C5,$D4,$D5,$CF,$BA,$DE,$8B
>ecd7	22 24 26 28 30 dd 93 8c			.byte	$22,$24,$26,$28,$30,$DD,$93,$8C
>ecdf	ff					.byte	$FF
.ece0					LOGOKEYS
>ece0	21 23 25 27 29 a6 a8 94			.byte	$21,$23,$25,$27,$29,$A6,$A8,$94
>ece8	5f b3 b2 b7 a2 af df 8d			.byte	$5F,$B3,$B2,$B7,$A2,$AF,$DF,$8D
>ecf0	04 b0 ac a5 b5 b6 5d 9d			.byte	$04,$B0,$AC,$A5,$B5,$B6,$5D,$9D
>ecf8	83 01 bd be aa 3c 3f 91			.byte	$83,$01,$BD,$BE,$AA,$3C,$3F,$91
>ed00	a0 ad bc bf a7 3e 01 89			.byte	$A0,$AD,$BC,$BF,$A7,$3E,$01,$89
>ed08	02 ae bb b4 a1 5b 3d 8a			.byte	$02,$AE,$BB,$B4,$A1,$5B,$3D,$8A
>ed10	ab b1 a3 b8 b9 a4 de 8b			.byte	$AB,$B1,$A3,$B8,$B9,$A4,$DE,$8B
>ed18	22 24 26 28 30 dc 93 8c			.byte	$22,$24,$26,$28,$30,$DC,$93,$8C
>ed20	ff					.byte	$FF
.ed21					CHARSET
.ed21	c9 0e		cmp #$0e		CMP	#$0E			; compare with [SWITCH TO LOWER CASE]
.ed23	d0 0b		bne $ed30		BNE	GRAPHMODE		; branch if not [SWITCH TO LOWER CASE]
.ed25	a9 02		lda #$02		LDA	#$02			; set for $8800, lower case characters
.ed27	0d 05 90	ora $9005		ORA	VICCR5			; OR with start of character memory, ROM
.ed2a	8d 05 90	sta $9005		STA	VICCR5			; save start of character memory, ROM
.ed2d	4c dc e6	jmp $e6dc		JMP	LAB_E6DC		; restore registers, set quote flag and exit
.ed30					GRAPHMODE
.ed30	c9 8e		cmp #$8e		CMP	#$8E			; compare with [SWITCH TO UPPER CASE]
.ed32	d0 0b		bne $ed3f		BNE	LAB_ED3F		; branch if not [SWITCH TO UPPER CASE]
.ed34	a9 fd		lda #$fd		LDA	#$FD			; set for $8000, upper case characters
.ed36	2d 05 90	and $9005		AND	VICCR5			; AND with start of character memory, ROM
.ed39	8d 05 90	sta $9005		STA	VICCR5			; save start of character memory, ROM
.ed3c					LAB_ED3C
.ed3c	4c dc e6	jmp $e6dc		JMP	LAB_E6DC		; restore registers, set quote flag and exit
.ed3f					LAB_ED3F
.ed3f	c9 08		cmp #$08		CMP	#$08			; compare with disable [SHIFT][C=]
.ed41	d0 0a		bne $ed4d		BNE	LAB_ED4D		; branch if not disable [SHIFT][C=]
.ed43	a9 80		lda #$80		LDA	#$80			; set to lock shift mode switch
.ed45	0d 91 02	ora $0291		ORA	MODE			; OR with shift mode switch, $00 = enabled, $80 = locked
.ed48	8d 91 02	sta $0291		STA	MODE			; save shift mode switch
.ed4b	30 ef		bmi $ed3c		BMI	LAB_ED3C		; branch always
.ed4d					LAB_ED4D
.ed4d	c9 09		cmp #$09		CMP	#$09			; compare with enable [SHIFT][C=]
.ed4f	d0 eb		bne $ed3c		BNE	LAB_ED3C		; exit if not enable [SHIFT][C=]
.ed51	a9 7f		lda #$7f		LDA	#$7F			; set to unlock shift mode switch
.ed53	2d 91 02	and $0291		AND	MODE			; AND with shift mode switch, $00 = enabled, $80 = locked
.ed56	8d 91 02	sta $0291		STA	MODE			; save shift mode switch
.ed59	10 e1		bpl $ed3c		BPL	LAB_ED3C		; branch always
.ed5b					WRAPLINE
.ed5b	e8		inx			INX				; increment screen row
.ed5c	b5 d9		lda $d9,x		LDA	LDTB1,X			; get start of line X pointer high byte
.ed5e	09 80		ora #$80		ORA	#$80			; mark as start of logical line
.ed60	95 d9		sta $d9,x		STA	LDTB1,X			; set start of line X pointer high byte
.ed62	ca		dex			DEX				; restore screen row
.ed63	a5 d5		lda $d5			LDA	LNMX			; get current screen line length
.ed65	18		clc			CLC				; clear carry for add
.ed66	4c 15 e7	jmp $e715		JMP	LAB_E715		; add one line length, set pointers for start of line and
.ed69					WHATKEYS
>ed69	ff ff ff ff ff ff ff ff			.byte	$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
>ed71	ff 04 ff ff ff ff ff e2			.byte	$FF,$04,$FF,$FF,$FF,$FF,$FF,$E2
>ed79	9d 83 01 ff ff ff ff ff			.byte	$9D,$83,$01,$FF,$FF,$FF,$FF,$FF
>ed81	91 a0 ff ff ff ff ee 01			.byte	$91,$A0,$FF,$FF,$FF,$FF,$EE,$01
>ed89	89 02 ff ff ff ff e1 fd			.byte	$89,$02,$FF,$FF,$FF,$FF,$E1,$FD
>ed91	8a ff ff ff ff ff b0 e0			.byte	$8A,$FF,$FF,$FF,$FF,$FF,$B0,$E0
>ed99	8b f2 f4 f6 ff f0 ed 93			.byte	$8B,$F2,$F4,$F6,$FF,$F0,$ED,$93
>eda1	8c ff					.byte	$8C,$FF
.eda3					CTRLKEYS
>eda3	90 1c 9c 1f 12 ff ff ff			.byte	$90,$1C,$9C,$1F,$12,$FF,$FF,$FF
>edab	06 ff 12 ff ff ff ff ff			.byte	$06,$FF,$12,$FF,$FF,$FF,$FF,$FF
>edb3	ff ff ff ff ff ff ff ff			.byte	$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
>edbb	ff ff ff ff ff ff ff ff			.byte	$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
>edc3	ff ff ff ff ff ff ff ff			.byte	$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
>edcb	ff ff ff ff ff ff ff ff			.byte	$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
>edd3	ff ff ff ff ff ff ff ff			.byte	$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
>eddb	05 9f 1e 9e 92 ff ff ff			.byte	$05,$9F,$1E,$9E,$92,$FF,$FF,$FF
>ede3	ff					.byte	$FF
.ede4					VICINIT
>ede4	0c					.byte	$0C			; interlace and horizontal origin [PAL]
>ede5	26					.byte	$26			; vertical origin [PAL]
>ede6	16					.byte	$16			; video address and columns, $9400 for colour RAM
>ede7	2e					.byte	$2E			; screen rows and character height
>ede8	00					.byte	$00			; b8-b1 raster line
>ede9	c0					.byte	$C0			; video memory addresses, RAM $1000, ROM $8000
>edea	00					.byte	$00			; light pen horizontal position
>edeb	00					.byte	$00			; light pen vertical position
>edec	00					.byte	$00			; paddle X
>eded	00					.byte	$00			; paddle Y
>edee	00					.byte	$00			; oscillator 1 frequency
>edef	00					.byte	$00			; oscillator 2 frequency
>edf0	00					.byte	$00			; oscillator 3 frequency
>edf1	00					.byte	$00			; white noise frequency
>edf2	00					.byte	$00			; auxiliary colour and volume
>edf3	1b					.byte	$1B			; background and border colour
.edf4					RUNTB
>edf4	4c 4f 41 44 0d 52 55 4e			.text	"LOAD",$0D,"RUN",$0D
>edfc	0d
.edfd					LDTB2
>edfd	00 16 2c 42				.byte	$00,$16,$2C,$42
>ee01	58 6e 84 9a				.byte	$58,$6E,$84,$9A
>ee05	b0 c6 dc f2				.byte	$B0,$C6,$DC,$F2
>ee09	08 1e 34 4a				.byte	$08,$1E,$34,$4A
>ee0d	60 76 8c a2				.byte	$60,$76,$8C,$A2
>ee11	b8 ce e4				.byte	$B8,$CE,$E4
.ee14					FTALK
.ee14	09 40		ora #$40		ORA	#$40			; OR with the TALK command
>ee16	2c					.byte	$2C			; makes next line BIT $2009
.ee17					FLISTEN
.ee17	09 20		ora #$20		ORA	#$20			; OR with the LISTEN command
.ee19	20 60 f1	jsr $f160		JSR	RSPAUSE			; check RS-232 bus idle
.ee1c					LIST1
.ee1c	48		pha			PHA				; save device address
.ee1d	24 94		bit $94			BIT	C3PO			; test deferred character flag
.ee1f	10 0a		bpl $ee2b		BPL	LAB_EE2B		; branch if no deferred character
.ee21	38		sec			SEC				; flag EOI
.ee22	66 a3		ror $a3			ROR	PCNTR			; rotate into EOI flag
.ee24	20 49 ee	jsr $ee49		JSR	SRSEND			; Tx byte on serial bus
.ee27	46 94		lsr $94			LSR	C3PO			; clear deferred character flag
.ee29	46 a3		lsr $a3			LSR	PCNTR			; clear EOI flag
.ee2b					LAB_EE2B
.ee2b	68		pla			PLA				; restore device address
.ee2c	85 95		sta $95			STA	BSOUR			; save as serial deferred character
.ee2e	20 a0 e4	jsr $e4a0		JSR	SEROUT1			; set serial DATA high
.ee31	c9 3f		cmp #$3f		CMP	#$3F			; compare read byte with $3F
.ee33	d0 03		bne $ee38		BNE	LAB_EE38		; branch if not $3F, this branch will always be taken as
.ee35	20 84 ef	jsr $ef84		JSR	SRCLKHI			; set serial CLK high
.ee38					LAB_EE38
.ee38	ad 1f 91	lda $911f		LDA	VIA1PA2			; get VIA 1 DRA, no handshake
.ee3b	09 80		ora #$80		ORA	#$80			; set serial ATN out low
.ee3d	8d 1f 91	sta $911f		STA	VIA1PA2			; set VIA 1 DRA, no handshake
.ee40					LAB_EE40
.ee40	20 8d ef	jsr $ef8d		JSR	SRCLKLO			; set serial CLK low
.ee43	20 a0 e4	jsr $e4a0		JSR	SEROUT1			; set serial DATA high
.ee46	20 96 ef	jsr $ef96		JSR	WAITABIT		; 1ms delay
.ee49					SRSEND
.ee49	78		sei			SEI				; disable interrupts
.ee4a	20 a0 e4	jsr $e4a0		JSR	SEROUT1			; set serial DATA high
.ee4d	20 b2 e4	jsr $e4b2		JSR	SERGET			; get serial CLK status
.ee50	4a		lsr a			LSR				; shift serial DATA to Cb
.ee51	b0 61		bcs $eeb4		BCS	SRBAD			; if DATA high do device not present
.ee53	20 84 ef	jsr $ef84		JSR	SRCLKHI			; set serial CLK high
.ee56	24 a3		bit $a3			BIT	PCNTR			; test EOI flag
.ee58	10 0c		bpl $ee66		BPL	LAB_EE66		; branch if not EOI
.ee5a					LAB_EE5A
.ee5a	20 b2 e4	jsr $e4b2		JSR	SERGET			; get serial CLK status
.ee5d	4a		lsr a			LSR				; shift serial DATA to Cb
.ee5e	90 fa		bcc $ee5a		BCC	LAB_EE5A		; loop if DATA low
.ee60					LAB_EE60
.ee60	20 b2 e4	jsr $e4b2		JSR	SERGET			; get serial CLK status
.ee63	4a		lsr a			LSR				; shift serial DATA to Cb
.ee64	b0 fa		bcs $ee60		BCS	LAB_EE60		; loop if DATA high
.ee66					LAB_EE66
.ee66	20 b2 e4	jsr $e4b2		JSR	SERGET			; get serial CLK status
.ee69	4a		lsr a			LSR				; shift serial DATA to Cb
.ee6a	90 fa		bcc $ee66		BCC	LAB_EE66		; loop if DATA low
.ee6c	20 8d ef	jsr $ef8d		JSR	SRCLKLO			; set serial CLK low
.ee6f	a9 08		lda #$08		LDA	#$08			; eight bits to do
.ee71	85 a5		sta $a5			STA	CNTDN			; set serial bus bit count
.ee73					LAB_EE73
.ee73	ad 1f 91	lda $911f		LDA	VIA1PA2			; get VIA 1 DRA, no handshake
.ee76	cd 1f 91	cmp $911f		CMP	VIA1PA2			; compare with self
.ee79	d0 f8		bne $ee73		BNE	LAB_EE73		; loop if changing
.ee7b	4a		lsr a			LSR				; serial CLK to carry
.ee7c	4a		lsr a			LSR				; serial DATA to carry
.ee7d	90 38		bcc $eeb7		BCC	LAB_EEB7		; if DATA low do timeout on serial bus
.ee7f	66 95		ror $95			ROR	BSOUR			; rotate transmit byte
.ee81	b0 05		bcs $ee88		BCS	LAB_EE88		; branch if bit = 1
.ee83	20 a9 e4	jsr $e4a9		JSR	SEROUT0			; else set serial DATA low
.ee86	d0 03		bne $ee8b		BNE	LAB_EE8B		; branch always
.ee88					LAB_EE88
.ee88	20 a0 e4	jsr $e4a0		JSR	SEROUT1			; set serial DATA high
.ee8b					LAB_EE8B
.ee8b	20 84 ef	jsr $ef84		JSR	SRCLKHI			; set serial CLK high
.ee8e	ea		nop			NOP				; waste ..
.ee8f	ea		nop			NOP				; .. a ..
.ee90	ea		nop			NOP				; .. cycle ..
.ee91	ea		nop			NOP				; .. or two
.ee92	ad 2c 91	lda $912c		LDA	VIA2PCR			; get VIA 2 PCR
.ee95	29 df		and #$df		AND	#$DF			; set CB2 low, serial DATA out high
.ee97	09 02		ora #$02		ORA	#$02			; set CA2 high, serial CLK out low
.ee99	8d 2c 91	sta $912c		STA	VIA2PCR			; save VIA 2 PCR
.ee9c	c6 a5		dec $a5			DEC	CNTDN			; decrement serial bus bit count
.ee9e	d0 d3		bne $ee73		BNE	LAB_EE73		; loop if not all done
.eea0	a9 04		lda #$04		LDA	#$04			; wait for up to about 1ms
.eea2	8d 29 91	sta $9129		STA	VIA2T2CH		; set VIA 2 T2C_h
.eea5					LAB_EEA5
.eea5	ad 2d 91	lda $912d		LDA	VIA2IFR			; get VIA 2 IFR
.eea8	29 20		and #$20		AND	#$20			; mask T2 interrupt
.eeaa	d0 0b		bne $eeb7		BNE	LAB_EEB7		; if T2 interrupt do timeout on serial bus
.eeac	20 b2 e4	jsr $e4b2		JSR	SERGET			; get serial CLK status
.eeaf	4a		lsr a			LSR				; shift serial DATA to Cb
.eeb0	b0 f3		bcs $eea5		BCS	LAB_EEA5		; if DATA high go wait some more
.eeb2	58		cli			CLI				; enable interrupts
.eeb3	60		rts			RTS
.eeb4					SRBAD
.eeb4	a9 80		lda #$80		LDA	#$80			; set device not present bit
>eeb6	2c					.byte	$2C			; makes next line BIT $03A9
.eeb7					LAB_EEB7
.eeb7	a9 03		lda #$03		LDA	#$03			; set time out read and write bits
.eeb9					LAB_EEB9
.eeb9	20 6a fe	jsr $fe6a		JSR	ORIOST			; OR into I/O status byte
.eebc	58		cli			CLI				; enable interrupts
.eebd	18		clc			CLC				; clear for branch
.eebe	90 49		bcc $ef09		BCC	LAB_EF09		; ATN high, delay, CLK high then DATA high, branch always
.eec0					FSECOND
.eec0	85 95		sta $95			STA	BSOUR			; save deferred byte
.eec2	20 40 ee	jsr $ee40		JSR	LAB_EE40		; set CLK/DATA, wait and Tx byte on serial bus
.eec5					SCATN
.eec5	ad 1f 91	lda $911f		LDA	VIA1PA2			; get VIA 1 DRA, no handshake
.eec8	29 7f		and #$7f		AND	#$7F			; set serial ATN high
.eeca	8d 1f 91	sta $911f		STA	VIA1PA2			; set VIA 1 DRA, no handshake
.eecd	60		rts			RTS
.eece					FTKSA
.eece	85 95		sta $95			STA	BSOUR			; save the secondary address byte to transmit
.eed0	20 40 ee	jsr $ee40		JSR	LAB_EE40		; set CLK/DATA, wait and Tx byte on serial bus
.eed3					LAB_EED3
.eed3	78		sei			SEI				; disable interrupts
.eed4	20 a9 e4	jsr $e4a9		JSR	SEROUT0			; set serial DATA low
.eed7	20 c5 ee	jsr $eec5		JSR	SCATN			; set serial ATN high
.eeda	20 84 ef	jsr $ef84		JSR	SRCLKHI			; set serial CLOCK high
.eedd					LAB_EEDD
.eedd	20 b2 e4	jsr $e4b2		JSR	SERGET			; get serial CLK status
.eee0	b0 fb		bcs $eedd		BCS	LAB_EEDD		; branch if CLK high
.eee2	58		cli			CLI				; enable interrupts
.eee3	60		rts			RTS
.eee4					FCIOUT
.eee4	24 94		bit $94			BIT	C3PO			; test deferred character flag
.eee6	30 05		bmi $eeed		BMI	LAB_EEED		; branch if deferred character
.eee8	38		sec			SEC				; set carry
.eee9	66 94		ror $94			ROR	C3PO			; shift into deferred character flag
.eeeb	d0 05		bne $eef2		BNE	LAB_EEF2		; save byte and exit, branch always
.eeed					LAB_EEED
.eeed	48		pha			PHA				; save byte
.eeee	20 49 ee	jsr $ee49		JSR	SRSEND			; Tx byte on serial bus
.eef1	68		pla			PLA				; restore byte
.eef2					LAB_EEF2
.eef2	85 95		sta $95			STA	BSOUR			; save deferred byte
.eef4	18		clc			CLC				; flag ok
.eef5	60		rts			RTS
.eef6					FUNTLK
.eef6	20 8d ef	jsr $ef8d		JSR	SRCLKLO			; set serial CLK low
.eef9	ad 1f 91	lda $911f		LDA	VIA1PA2			; get VIA 1 DRA, no handshake
.eefc	09 80		ora #$80		ORA	#$80			; set serial ATN low
.eefe	8d 1f 91	sta $911f		STA	VIA1PA2			; set VIA 1 DRA, no handshake
.ef01	a9 5f		lda #$5f		LDA	#$5F			; set the UNTALK command
>ef03	2c					.byte	$2C			; makes next line BIT $3FA9
.ef04					FUNLSN
.ef04	a9 3f		lda #$3f		LDA	#$3F			; set the UNLISTEN command
.ef06	20 1c ee	jsr $ee1c		JSR	LIST1			; send control character
.ef09					LAB_EF09
.ef09	20 c5 ee	jsr $eec5		JSR	SCATN			; set serial ATN high
.ef0c					LAB_EF0C
.ef0c	8a		txa			TXA				; save device number
.ef0d	a2 0b		ldx #$0b		LDX	#$0B			; short delay
.ef0f					LAB_EF0F
.ef0f	ca		dex			DEX				; decrement count
.ef10	d0 fd		bne $ef0f		BNE	LAB_EF0F		; loop if not all done
.ef12	aa		tax			TAX				; restore device number
.ef13	20 84 ef	jsr $ef84		JSR	SRCLKHI			; set serial CLK high
.ef16	4c a0 e4	jmp $e4a0		JMP	SEROUT1			; set serial DATA high and return
.ef19					FACPTR
.ef19	78		sei			SEI				; disable interrupts
.ef1a	a9 00		lda #$00		LDA	#$00			; clear .A
.ef1c	85 a5		sta $a5			STA	CNTDN			; clear serial bus bit count
.ef1e	20 84 ef	jsr $ef84		JSR	SRCLKHI			; set serial CLK high
.ef21					LAB_EF21
.ef21	20 b2 e4	jsr $e4b2		JSR	SERGET			; get serial CLK status
.ef24	90 fb		bcc $ef21		BCC	LAB_EF21		; loop while CLK low
.ef26	20 a0 e4	jsr $e4a0		JSR	SEROUT1			; set serial DATA high
.ef29					LAB_EF29
.ef29	a9 01		lda #$01		LDA	#$01			; set timeout count high byte
.ef2b	8d 29 91	sta $9129		STA	VIA2T2CH		; set VIA 2 T2C_h
.ef2e					LAB_EF2E
.ef2e	ad 2d 91	lda $912d		LDA	VIA2IFR			; get VIA 2 IFR
.ef31	29 20		and #$20		AND	#$20			; mask T2 interrupt
.ef33	d0 07		bne $ef3c		BNE	LAB_EF3C		; branch if T2 interrupt
.ef35	20 b2 e4	jsr $e4b2		JSR	SERGET			; get serial CLK status
.ef38	b0 f4		bcs $ef2e		BCS	LAB_EF2E		; loop if CLK high
.ef3a	90 18		bcc $ef54		BCC	LAB_EF54		; else go set 8 bits to do, branch always
.ef3c					LAB_EF3C
.ef3c	a5 a5		lda $a5			LDA	CNTDN			; get serial bus bit count
.ef3e	f0 05		beq $ef45		BEQ	LAB_EF45		; if not already EOI then go flag EOI
.ef40	a9 02		lda #$02		LDA	#$02			; error $02, read timeout
.ef42	4c b9 ee	jmp $eeb9		JMP	LAB_EEB9		; set I/O status and exit
.ef45					LAB_EF45
.ef45	20 a9 e4	jsr $e4a9		JSR	SEROUT0			; set serial DATA low
.ef48	20 0c ef	jsr $ef0c		JSR	LAB_EF0C		; 1ms delay, CLK high then DATA high
.ef4b	a9 40		lda #$40		LDA	#$40			; set EOI bit
.ef4d	20 6a fe	jsr $fe6a		JSR	ORIOST			; OR into I/O status byte
.ef50	e6 a5		inc $a5			INC	CNTDN			; increment serial bus bit count, do error on next timeout
.ef52	d0 d5		bne $ef29		BNE	LAB_EF29		; go try again
.ef54					LAB_EF54
.ef54	a9 08		lda #$08		LDA	#$08			; 8 bits to do
.ef56	85 a5		sta $a5			STA	CNTDN			; set serial bus bit count
.ef58					LAB_EF58
.ef58	ad 1f 91	lda $911f		LDA	VIA1PA2			; get VIA 1 DRA, no handshake
.ef5b	cd 1f 91	cmp $911f		CMP	VIA1PA2			; compare with self
.ef5e	d0 f8		bne $ef58		BNE	LAB_EF58		; loop if changing
.ef60	4a		lsr a			LSR				; serial CLK into carry
.ef61	90 f5		bcc $ef58		BCC	LAB_EF58		; loop while serial CLK low
.ef63	4a		lsr a			LSR				; serial DATA into carry
.ef64	66 a4		ror $a4			ROR	FIRT			; shift data bit into input byte
.ef66					LAB_EF66
.ef66	ad 1f 91	lda $911f		LDA	VIA1PA2			; get VIA 1 DRA, no handshake
.ef69	cd 1f 91	cmp $911f		CMP	VIA1PA2			; compare with self
.ef6c	d0 f8		bne $ef66		BNE	LAB_EF66		; loop if changing
.ef6e	4a		lsr a			LSR				; serial CLK into carry
.ef6f	b0 f5		bcs $ef66		BCS	LAB_EF66		; loop while serial CLK high
.ef71	c6 a5		dec $a5			DEC	CNTDN			; decrement serial bus bit count
.ef73	d0 e3		bne $ef58		BNE	LAB_EF58		; loop if not all done
.ef75	20 a9 e4	jsr $e4a9		JSR	SEROUT0			; set serial DATA low
.ef78	a5 90		lda $90			LDA	STATUS			; get I/O status byte
.ef7a	f0 03		beq $ef7f		BEQ	LAB_EF7F		; branch if no error
.ef7c	20 0c ef	jsr $ef0c		JSR	LAB_EF0C		; 1ms delay, CLK high then DATA high
.ef7f					LAB_EF7F
.ef7f	a5 a4		lda $a4			LDA	FIRT			; get input byte
.ef81	58		cli			CLI				; enable interrupts
.ef82	18		clc			CLC				; flag ok
.ef83	60		rts			RTS
.ef84					SRCLKHI
.ef84	ad 2c 91	lda $912c		LDA	VIA2PCR			; get VIA 2 PCR
.ef87	29 fd		and #$fd		AND	#$FD			; set CA2 low, serial CLK out high
.ef89	8d 2c 91	sta $912c		STA	VIA2PCR			; set VIA 2 PCR
.ef8c	60		rts			RTS
.ef8d					SRCLKLO
.ef8d	ad 2c 91	lda $912c		LDA	VIA2PCR			; get VIA 2 PCR
.ef90	09 02		ora #$02		ORA	#$02			; set CA2 high, serial CLK out low
.ef92	8d 2c 91	sta $912c		STA	VIA2PCR			; set VIA 2 PCR
.ef95	60		rts			RTS
.ef96					WAITABIT
.ef96	a9 04		lda #$04		LDA	#$04			; set for 1024 cycles
.ef98	8d 29 91	sta $9129		STA	VIA2T2CH		; set VIA 2 T2C_h
.ef9b					LAB_EF9B
.ef9b	ad 2d 91	lda $912d		LDA	VIA2IFR			; get VIA 2 IFR
.ef9e	29 20		and #$20		AND	#$20			; mask T2 interrupt
.efa0	f0 f9		beq $ef9b		BEQ	LAB_EF9B		; loop until T2 interrupt
.efa2	60		rts			RTS
.efa3					RSNXTBIT
.efa3	a5 b4		lda $b4			LDA	BITTS			; get RS-232 bit count
.efa5	f0 47		beq $efee		BEQ	RSNXTBYT		; if zero go setup next RS-232 Tx byte and return
.efa7	30 3f		bmi $efe8		BMI	RSSTOPS			; if -ve go do stop bit(s)
.efa9	46 b6		lsr $b6			LSR	RODATA			; shift RS-232 output byte buffer
.efab	a2 00		ldx #$00		LDX	#$00			; set $00 for bit = 0
.efad	90 01		bcc $efb0		BCC	LAB_EFB0		; branch if bit was 0
.efaf	ca		dex			DEX				; set $FF for bit = 1
.efb0					LAB_EFB0
.efb0	8a		txa			TXA				; copy bit to .A
.efb1	45 bd		eor $bd			EOR	ROPRTY			; XOR with RS-232 parity byte
.efb3	85 bd		sta $bd			STA	ROPRTY			; save RS-232 parity byte
.efb5	c6 b4		dec $b4			DEC	BITTS			; decrement RS-232 bit count
.efb7	f0 06		beq $efbf		BEQ	RSPRTY			; if RS-232 bit count now zero go do parity bit
.efb9					LAB_EFB9
.efb9	8a		txa			TXA				; copy bit to .A
.efba	29 20		and #$20		AND	#$20			; mask for CB2 control bit
.efbc	85 b5		sta $b5			STA	NXTBIT			; save RS-232 next bit to send
.efbe	60		rts			RTS
.efbf					RSPRTY
.efbf	a9 20		lda #$20		LDA	#$20			; mask 00x0 0000, parity enable bit
.efc1	2c 94 02	bit $0294		BIT	M51CDR			; test pseudo 6551 command register
.efc4	f0 14		beq $efda		BEQ	LAB_EFDA		; branch if parity disabled
.efc6	30 1c		bmi $efe4		BMI	LAB_EFE4		; branch if fixed mark or space parity
.efc8	70 14		bvs $efde		BVS	LAB_EFDE		; branch if even parity
.efca	a5 bd		lda $bd			LDA	ROPRTY			; get RS-232 parity byte
.efcc	d0 01		bne $efcf		BNE	LAB_EFCF		; if parity not zero leave parity bit = 0
.efce					LAB_EFCE
.efce	ca		dex			DEX				; make parity bit = 1
.efcf					LAB_EFCF
.efcf	c6 b4		dec $b4			DEC	BITTS			; decrement RS-232 bit count, 1 stop bit
.efd1	ad 93 02	lda $0293		LDA	M51CTR			; get pseudo 6551 control register
.efd4	10 e3		bpl $efb9		BPL	LAB_EFB9		; if 1 stop bit save parity bit and exit
.efd6	c6 b4		dec $b4			DEC	BITTS			; decrement RS-232 bit count, 2 stop bits
.efd8	d0 df		bne $efb9		BNE	LAB_EFB9		; save bit and exit, branch always
.efda					LAB_EFDA
.efda	e6 b4		inc $b4			INC	BITTS			; increment RS-232 bit count, = -1 stop bit
.efdc	d0 f0		bne $efce		BNE	LAB_EFCE		; set stop bit = 1 and exit, branch always
.efde					LAB_EFDE
.efde	a5 bd		lda $bd			LDA	ROPRTY			; get RS-232 parity byte
.efe0	f0 ed		beq $efcf		BEQ	LAB_EFCF		; if parity zero leave parity bit = 0
.efe2	d0 ea		bne $efce		BNE	LAB_EFCE		; else make parity bit = 1, branch always
.efe4					LAB_EFE4
.efe4	70 e9		bvs $efcf		BVS	LAB_EFCF		; if fixed space parity leave parity bit = 0
.efe6	50 e6		bvc $efce		BVC	LAB_EFCE		; else fixed mark parity make parity bit = 1, branch always
.efe8					RSSTOPS
.efe8	e6 b4		inc $b4			INC	BITTS			; decrement RS-232 bit count
.efea	a2 ff		ldx #$ff		LDX	#$FF			; set stop bit = 1
.efec	d0 cb		bne $efb9		BNE	LAB_EFB9		; save stop bit and exit, branch always
.efee					RSNXTBYT
.efee	ad 94 02	lda $0294		LDA	M51CDR			; get pseudo 6551 command register
.eff1	4a		lsr a			LSR				; handshake bit into Cb
.eff2	90 07		bcc $effb		BCC	LAB_EFFB		; branch if 3 line interface
.eff4	2c 20 91	bit $9120		BIT	VIA2PB			; test VIA 2 DRB
.eff7	10 1d		bpl $f016		BPL	RSMISSNG		; if DSR = 0 set DSR signal not present and exit
.eff9	50 1e		bvc $f019		BVC	LAB_F019		; if CTS = 0 set CTS signal not present and exit
.effb					LAB_EFFB
.effb	a9 00		lda #$00		LDA	#$00			; clear .A
.effd	85 bd		sta $bd			STA	ROPRTY			; clear RS-232 parity byte
.efff	85 b5		sta $b5			STA	NXTBIT			; clear RS-232 next bit to send
.f001	ae 98 02	ldx $0298		LDX	BITNUM			; get number of bits to be sent/received
.f004	86 b4		stx $b4			STX	BITTS			; set RS-232 bit count
.f006	ac 9d 02	ldy $029d		LDY	RODBS			; get index to Tx buffer start
.f009	cc 9e 02	cpy $029e		CPY	RODBE			; compare with index to Tx buffer end
.f00c	f0 13		beq $f021		BEQ	LAB_F021		; if all done go disable T1 interrupt and return
.f00e	b1 f9		lda ($f9),y		LDA	(ROBUF),Y		; else get byte from buffer
.f010	85 b6		sta $b6			STA	RODATA			; save to RS-232 output byte buffer
.f012	ee 9d 02	inc $029d		INC	RODBS			; increment index to Tx buffer start
.f015	60		rts			RTS
.f016					RSMISSNG
.f016	a9 40		lda #$40		LDA	#$40			; set DSR signal not present
>f018	2c					.byte	$2C			; makes next line BIT $10A9
.f019					LAB_F019
.f019	a9 10		lda #$10		LDA	#$10			; set CTS signal not present
.f01b	0d 97 02	ora $0297		ORA	RSSTAT			; OR with RS-232 status register
.f01e	8d 97 02	sta $0297		STA	RSSTAT			; save RS-232 status register
.f021					LAB_F021
.f021	a9 40		lda #$40		LDA	#$40			; disable T1 interrupt
.f023	8d 1e 91	sta $911e		STA	VIA1IER			; set VIA 1 IER
.f026	60		rts			RTS
.f027					RSCPTBIT
.f027	a2 09		ldx #$09		LDX	#$09			; set bit count to 9, 8 data + 1 stop bit
.f029	a9 20		lda #$20		LDA	#$20			; mask for 8/7 data bits
.f02b	2c 93 02	bit $0293		BIT	M51CTR			; test pseudo 6551 control register
.f02e	f0 01		beq $f031		BEQ	LAB_F031		; branch if 8 bits
.f030	ca		dex			DEX				; else decrement count for 7 data bits
.f031					LAB_F031
.f031	50 02		bvc $f035		BVC	LAB_F035		; branch if 7 bits
.f033	ca		dex			DEX				; else decrement count ..
.f034	ca		dex			DEX				; .. for 5 data bits
.f035					LAB_F035
.f035	60		rts			RTS
.f036					RSINBIT
.f036	a6 a9		ldx $a9			LDX	RINONE			; get RS-232 start bit check flag
.f038	d0 2e		bne $f068		BNE	RSSTRBIT		; branch if no start bit received
.f03a	c6 a8		dec $a8			DEC	BITCI			; decrement RS-232 input bit count
.f03c	f0 31		beq $f06f		BEQ	RSINBYTE		; if the byte is complete go add it to the buffer
.f03e	30 0d		bmi $f04d		BMI	LAB_F04D		; determine if all stop bits have been received
.f040	a5 a7		lda $a7			LDA	INBIT			; get RS-232 input bit
.f042	45 ab		eor $ab			EOR	RIPRTY			; XOR with RS-232 parity bit
.f044	85 ab		sta $ab			STA	RIPRTY			; save in RS-232 parity bit
.f046	46 a7		lsr $a7			LSR	INBIT			; shift RS-232 input bit into Cb
.f048	66 aa		ror $aa			ROR	RIDATA			; shift Cb into RS-232 byte assembly
.f04a					LAB_F04A
.f04a	60		rts			RTS
.f04b					RSSTPBIT
.f04b	c6 a8		dec $a8			DEC	BITCI			; decrement RS-232 input bit count
.f04d					LAB_F04D
.f04d	a5 a7		lda $a7			LDA	INBIT			; get RS-232 input bit
.f04f	f0 62		beq $f0b3		BEQ	LAB_F0B3		; branch if bit clear
.f051	ad 93 02	lda $0293		LDA	M51CTR			; get pseudo 6551 control register
.f054	0a		asl a			ASL				; shift stop bits into Cb
.f055	a9 01		lda #$01		LDA	#$01			; one stop bit
.f057	65 a8		adc $a8			ADC	BITCI			; add stop bits to RS-232 input bit count
.f059	d0 ef		bne $f04a		BNE	LAB_F04A		; branch always
.f05b					RSPREPIN
.f05b	a9 90		lda #$90		LDA	#$90			; enable CB1 interrupt, Rx data bit transition
.f05d	8d 1e 91	sta $911e		STA	VIA1IER			; set VIA 1 IER
.f060	85 a9		sta $a9			STA	RINONE			; set RS-232 start bit check flag, no start bit received
.f062	a9 20		lda #$20		LDA	#$20			; disable T2 interrupt
.f064	8d 1e 91	sta $911e		STA	VIA1IER			; set VIA 1 IER
.f067	60		rts			RTS
.f068					RSSTRBIT
.f068	a5 a7		lda $a7			LDA	INBIT			; get RS-232 input bit
.f06a	d0 ef		bne $f05b		BNE	RSPREPIN		; branch if bit set
.f06c	85 a9		sta $a9			STA	RINONE			; set RS-232 start bit check flag, start bit received
.f06e	60		rts			RTS
.f06f					RSINBYTE
.f06f	ac 9b 02	ldy $029b		LDY	RIDBE			; get index to Rx buffer end
.f072	c8		iny			INY				; increment index
.f073	cc 9c 02	cpy $029c		CPY	RIDBS			; compare with index to Rx buffer start
.f076	f0 2a		beq $f0a2		BEQ	RSOVERUN		; if buffer full go do Rx overrun error
.f078	8c 9b 02	sty $029b		STY	RIDBE			; save index to Rx buffer end
.f07b	88		dey			DEY				; decrement index
.f07c	a5 aa		lda $aa			LDA	RIDATA			; get assembled byte
.f07e	ae 98 02	ldx $0298		LDX	BITNUM			; get bit count
.f081					LAB_F081
.f081	e0 09		cpx #$09		CPX	#$09			; compare with byte + stop
.f083	f0 04		beq $f089		BEQ	LAB_F089		; branch if all nine bits received
.f085	4a		lsr a			LSR				; else shift byte
.f086	e8		inx			INX				; increment bit count
.f087	d0 f8		bne $f081		BNE	LAB_F081		; loop, branch always
.f089					LAB_F089
.f089	91 f7		sta ($f7),y		STA	(RIBUF),Y		; save received byte to RS-232 Rx buffer
.f08b	a9 20		lda #$20		LDA	#$20			; mask 00x0 0000, parity enable bit
.f08d	2c 94 02	bit $0294		BIT	M51CDR			; test pseudo 6551 command register
.f090	f0 b9		beq $f04b		BEQ	RSSTPBIT		; branch if parity disabled
.f092	30 b6		bmi $f04a		BMI	LAB_F04A		; exit if mark or space parity
.f094	a5 a7		lda $a7			LDA	INBIT			; get RS-232 input bit
.f096	45 ab		eor $ab			EOR	RIPRTY			; XOR with RS-232 parity bit
.f098	f0 03		beq $f09d		BEQ	RSPRTYER		; branch if parity error
.f09a	70 ae		bvs $f04a		BVS	LAB_F04A		; exit if even parity
>f09c	2c					.byte	$2C			; makes next line BIT $AB50
.f09d					RSPRTYER
.f09d	50 ab		bvc $f04a		BVC	LAB_F04A		; exit if odd parity
.f09f	a9 01		lda #$01		LDA	#$01			; set Rx parity error
>f0a1	2c					.byte	$2C			; makes next line BIT $04A9
.f0a2					RSOVERUN
.f0a2	a9 04		lda #$04		LDA	#$04			; set Rx overrun error
>f0a4	2c					.byte	$2C			; makes next line BIT $80A9
.f0a5					RSBREAK
.f0a5	a9 80		lda #$80		LDA	#$80			; Rx break error
>f0a7	2c					.byte	$2C			; makes next line BIT $02A9
.f0a8					RSFRAMER
.f0a8	a9 02		lda #$02		LDA	#$02			; Rx frame error
.f0aa	0d 97 02	ora $0297		ORA	RSSTAT			; OR with RS-232 status byte
.f0ad	8d 97 02	sta $0297		STA	RSSTAT			; save RS-232 status byte
.f0b0	4c 5b f0	jmp $f05b		JMP	RSPREPIN		; prepare to receive next input byte
.f0b3					LAB_F0B3
.f0b3	a5 aa		lda $aa			LDA	RIDATA			; get assembled byte
.f0b5	d0 f1		bne $f0a8		BNE	RSFRAMER		; if not break do frame error
.f0b7	f0 ec		beq $f0a5		BEQ	RSBREAK			; else do break error, branch always
.f0b9					RSDVCERR
.f0b9	4c 96 f7	jmp $f796		JMP	FE_ILDEV		; do illegal device number and return
.f0bc					RSOPNOUT
.f0bc	85 9a		sta $9a			STA	DFLTO			; save output device number
.f0be	ad 94 02	lda $0294		LDA	M51CDR			; get pseudo 6551 command register
.f0c1	4a		lsr a			LSR				; shift handshake bit to carry
.f0c2	90 27		bcc $f0eb		BCC	LAB_F0EB		; branch if 3 line interface
.f0c4	a9 02		lda #$02		LDA	#$02			; mask for RTS out
.f0c6	2c 10 91	bit $9110		BIT	VIA1PB			; test VIA 1 DRB
.f0c9	10 1d		bpl $f0e8		BPL	LAB_F0E8		; if DSR = 0 set DSR not present and exit
.f0cb	d0 1e		bne $f0eb		BNE	LAB_F0EB		; if RTS = 1 just exit
.f0cd					LAB_F0CD
.f0cd	ad 1e 91	lda $911e		LDA	VIA1IER			; get VIA 1 IER
.f0d0	29 30		and #$30		AND	#$30			; mask 00xx 0000, T2 and CB1 interrupts
.f0d2	d0 f9		bne $f0cd		BNE	LAB_F0CD		; loop while either enabled
.f0d4					LAB_F0D4
.f0d4	2c 10 91	bit $9110		BIT	VIA1PB			; test VIA 1 DRB
.f0d7	70 fb		bvs $f0d4		BVS	LAB_F0D4		; loop while CTS high
.f0d9	ad 10 91	lda $9110		LDA	VIA1PB			; get VIA 1 DRB
.f0dc	09 02		ora #$02		ORA	#$02			; set RTS high
.f0de	8d 10 91	sta $9110		STA	VIA1PB			; save VIA 1 DRB
.f0e1					LAB_F0E1
.f0e1	2c 10 91	bit $9110		BIT	VIA1PB			; test VIA 1 DRB
.f0e4	70 05		bvs $f0eb		BVS	LAB_F0EB		; exit if CTS high
.f0e6	30 f9		bmi $f0e1		BMI	LAB_F0E1		; loop while DSR high
.f0e8					LAB_F0E8
.f0e8	20 16 f0	jsr $f016		JSR	RSMISSNG		; set DSR signal not present
.f0eb					LAB_F0EB
.f0eb	18		clc			CLC				; flag ok
.f0ec	60		rts			RTS
.f0ed					RSOUTSAV
.f0ed	ac 9e 02	ldy $029e		LDY	RODBE			; get index to Tx buffer end
.f0f0	c8		iny			INY				; + 1
.f0f1	cc 9d 02	cpy $029d		CPY	RODBS			; compare with index to Tx buffer start
.f0f4	f0 f7		beq $f0ed		BEQ	RSOUTSAV		; loop while buffer full
.f0f6	8c 9e 02	sty $029e		STY	RODBE			; set index to Tx buffer end
.f0f9	88		dey			DEY				; index to available buffer byte
.f0fa	91 f9		sta ($f9),y		STA	(ROBUF),Y		; save byte to buffer
.f0fc	2c 1e 91	bit $911e		BIT	VIA1IER			; test VIA 1 IER
.f0ff	50 01		bvc $f102		BVC	RSPREPOT		; branch if T1 not enabled
.f101	60		rts			RTS
.f102					RSPREPOT
.f102	ad 99 02	lda $0299		LDA	BAUDOF			; get baud rate bit time low byte
.f105	8d 14 91	sta $9114		STA	VIA1T1CL		; set VIA 1 T1C_l
.f108	ad 9a 02	lda $029a		LDA	BAUDOF+1		; get baud rate bit time high byte
.f10b	8d 15 91	sta $9115		STA	VIA1T1CH		; set VIA 1 T1C_h
.f10e	a9 c0		lda #$c0		LDA	#$C0			; enable T1 interrupt
.f110	8d 1e 91	sta $911e		STA	VIA1IER			; set VIA 1 IER
.f113	4c ee ef	jmp $efee		JMP	RSNXTBYT		; setup next RS-232 Tx byte and return
.f116					RSOPNIN
.f116	85 99		sta $99			STA	DFLTN			; save input device number
.f118	ad 94 02	lda $0294		LDA	M51CDR			; get pseudo 6551 command register
.f11b	4a		lsr a			LSR				; shift b0 into Cb
.f11c	90 28		bcc $f146		BCC	LAB_F146		; branch if 3 line interface
.f11e	29 08		and #$08		AND	#$08			; mask duplex bit, pseudo 6551 command is >> 1
.f120	f0 24		beq $f146		BEQ	LAB_F146		; branch if full duplex
.f122	a9 02		lda #$02		LDA	#$02			; mask for RTS out
.f124	2c 10 91	bit $9110		BIT	VIA1PB			; test VIA 1 DRB
.f127	10 bf		bpl $f0e8		BPL	LAB_F0E8		; if DSR = 0 set DSR not present and exit
.f129	f0 19		beq $f144		BEQ	LAB_F144		; if RTS = 0 just exit
.f12b					LAB_F12B
.f12b	2c 1e 91	bit $911e		BIT	VIA1IER			; test VIA 1 IER
.f12e	70 fb		bvs $f12b		BVS	LAB_F12B		; loop while T1 interrupt enabled
.f130	ad 10 91	lda $9110		LDA	VIA1PB			; get VIA 1 DRB
.f133	29 fd		and #$fd		AND	#$FD			; mask xxxx xx0x, clear RTS out
.f135	8d 10 91	sta $9110		STA	VIA1PB			; save VIA 1 DRB
.f138					LAB_F138
.f138	ad 10 91	lda $9110		LDA	VIA1PB			; get VIA 1 DRB
.f13b	29 04		and #$04		AND	#$04			; mask xxxx x1xx, DTR out
.f13d	f0 f9		beq $f138		BEQ	LAB_F138		; loop while DTR low
.f13f					LAB_F13F
.f13f	a9 90		lda #$90		LDA	#$90			; enable CB1 interrupt, Rx data bit transition
.f141	8d 1e 91	sta $911e		STA	VIA1IER			; set VIA 1 IER
.f144					LAB_F144
.f144	18		clc			CLC				; flag no error
.f145	60		rts			RTS
.f146					LAB_F146
.f146	ad 1e 91	lda $911e		LDA	VIA1IER			; get VIA 1 IER
.f149	29 30		and #$30		AND	#$30			; mask 0xx0 0000, T1 and T2 interrupts
.f14b	f0 f2		beq $f13f		BEQ	LAB_F13F		; if both interrupts disabled go enable CB1
.f14d	18		clc			CLC				; flag no error
.f14e	60		rts			RTS
.f14f					RSNXTIN
.f14f	ac 9c 02	ldy $029c		LDY	RIDBS			; get index to Rx buffer start
.f152	cc 9b 02	cpy $029b		CPY	RIDBE			; compare with index to Rx buffer end
.f155	f0 06		beq $f15d		BEQ	LAB_F15D		; return null if buffer empty
.f157	b1 f7		lda ($f7),y		LDA	(RIBUF),Y		; get byte from RS-232 Rx buffer
.f159	ee 9c 02	inc $029c		INC	RIDBS			; increment index to Rx buffer start
.f15c	60		rts			RTS
.f15d					LAB_F15D
.f15d	a9 00		lda #$00		LDA	#$00			; return null
.f15f	60		rts			RTS
.f160					RSPAUSE
.f160	48		pha			PHA				; save .A
.f161	ad 1e 91	lda $911e		LDA	VIA1IER			; get VIA 1 IER
.f164	f0 0c		beq $f172		BEQ	LAB_F172		; branch if no interrupts enabled. b7 is clear on a
.f166					LAB_F166
.f166	ad 1e 91	lda $911e		LDA	VIA1IER			; get VIA 1 IER
.f169	29 60		and #$60		AND	#$60			; mask 0xx0 0000, T1 and T2 interrupts
.f16b	d0 f9		bne $f166		BNE	LAB_F166		; loop if T1 or T2 active
.f16d	a9 10		lda #$10		LDA	#$10			; disable CB1 interrupt, Rx data bit transition
.f16f	8d 1e 91	sta $911e		STA	VIA1IER			; set VIA 1 IER
.f172					LAB_F172
.f172	68		pla			PLA				; restore .A
.f173	60		rts			RTS
.f174					KMSGTBL
.f174					KM_IOERR
>f174	0d 49 2f 4f 20 45 52 52			.text	$0D,"I/O ERROR ",'#'+$80
>f17c	4f 52 20 a3
.f180					KM_SRCHG
>f180	0d 53 45 41 52 43 48 49			.text	$0D,"SEARCHING",' '+$80
>f188	4e 47 a0
.f18b					KM_FOR
>f18b	46 4f 52 a0				.text	"FOR",' '+$80
.f18f					KM_PRPLY
>f18f	0d 50 52 45 53 53 20 50			.text	$0D,"PRESS PLAY ON TAP",'E'+$80
>f197	4c 41 59 20 4f 4e 20 54 41 50 c5
.f1a2					KM_RECPY
>f1a2	50 52 45 53 53 20 52 45			.text	"PRESS RECORD & PLAY ON TAP",'E'+$80
>f1aa	43 4f 52 44 20 26 20 50 4c 41 59 20 4f 4e 20 54
>f1ba	41 50 c5
.f1bd					KM_LODNG
>f1bd	0d 4c 4f 41 44 49 4e c7			.text	$0D,"LOADIN",'G'+$80
.f1c5					KM_SAVNG
>f1c5	0d 53 41 56 49 4e 47 a0			.text	$0D,"SAVING",' '+$80
.f1cd					KM_VFYNG
>f1cd	0d 56 45 52 49 46 59 49			.text	$0D,"VERIFYIN",'G'+$80
>f1d5	4e c7
.f1d7					KM_FOUND
>f1d7	0d 46 4f 55 4e 44 a0			.text	$0D,"FOUND",' '+$80
.f1de					KM_OK
>f1de	0d 4f 4b 8d				.text	$0D,"OK",$0D+$80
.f1e2					SPMSG
.f1e2	24 9d		bit $9d			BIT	MSGFLG			; test KERNAL message mode flag
.f1e4	10 0d		bpl $f1f3		BPL	LAB_F1F3		; exit if control messages off
.f1e6					KMSGSHOW
.f1e6	b9 74 f1	lda $f174,y		LDA	KMSGTBL,Y		; get byte from message table
.f1e9	08		php			PHP				; save status
.f1ea	29 7f		and #$7f		AND	#$7F			; clear b7
.f1ec	20 d2 ff	jsr $ffd2		JSR	CHROUT			; output character to channel
.f1ef	c8		iny			INY				; increment index
.f1f0	28		plp			PLP				; restore status
.f1f1	10 f3		bpl $f1e6		BPL	KMSGSHOW		; loop if not end of message
.f1f3					LAB_F1F3
.f1f3	18		clc			CLC				; flag no error
.f1f4	60		rts			RTS
.f1f5					FGETIN
.f1f5	a5 99		lda $99			LDA	DFLTN			; get input device number
.f1f7	d0 08		bne $f201		BNE	LAB_F201		; branch if not keyboard
.f1f9	a5 c6		lda $c6			LDA	NDX			; get keyboard buffer length
.f1fb	f0 6d		beq $f26a		BEQ	LAB_F26A		; if buffer empty go flag no byte and return
.f1fd	78		sei			SEI				; disable interrupts
.f1fe	4c cf e5	jmp $e5cf		JMP	LP2			; input from keyboard buffer and return
.f201					LAB_F201
.f201	c9 02		cmp #$02		CMP	#$02			; compare device with RS-232 device
.f203	d0 18		bne $f21d		BNE	LAB_F21D		; branch if not RS-232 device
.f205					LAB_F205
.f205	84 97		sty $97			STY	XSAV			; save .Y
.f207	20 4f f1	jsr $f14f		JSR	RSNXTIN			; get byte from RS-232 buffer
.f20a	a4 97		ldy $97			LDY	XSAV			; restore .Y
.f20c	18		clc			CLC				; flag no error
.f20d	60		rts			RTS
.f20e					FCHRIN
.f20e	a5 99		lda $99			LDA	DFLTN			; get input device number
.f210	d0 0b		bne $f21d		BNE	LAB_F21D		; if it's not the keyboard continue
.f212	a5 d3		lda $d3			LDA	PNTR			; get cursor column
.f214	85 ca		sta $ca			STA	LXSP+1			; set input cursor column
.f216	a5 d6		lda $d6			LDA	TBLX			; get cursor row
.f218	85 c9		sta $c9			STA	LXSP			; set input cursor row
.f21a	4c 4f e6	jmp $e64f		JMP	GETSCRN			; go get input from the keyboard
.f21d					LAB_F21D
.f21d	c9 03		cmp #$03		CMP	#$03			; compare device number with screen
.f21f	d0 09		bne $f22a		BNE	LAB_F22A		; if it's not the screen continue
.f221	85 d0		sta $d0			STA	CRSW			; set input from screen
.f223	a5 d5		lda $d5			LDA	LNMX			; get current screen line length
.f225	85 c8		sta $c8			STA	INDX			; save input EOL pointer
.f227	4c 4f e6	jmp $e64f		JMP	GETSCRN			; go get input from the screen
.f22a					LAB_F22A
.f22a	b0 38		bcs $f264		BCS	CHRINSR			; if input device is the serial bus go handle it
.f22c	c9 02		cmp #$02		CMP	#$02			; compare device with RS-232 device
.f22e	f0 3f		beq $f26f		BEQ	CHRINRS			; if it's the RS-232 device go handle it
.f230	86 97		stx $97			STX	XSAV			; save .X
.f232	20 50 f2	jsr $f250		JSR	CHRINTP2		; get byte from tape
.f235	b0 16		bcs $f24d		BCS	LAB_F24D		; exit if error
.f237	48		pha			PHA				; save byte
.f238	20 50 f2	jsr $f250		JSR	CHRINTP2		; get next byte from tape
.f23b	b0 0d		bcs $f24a		BCS	LAB_F24A		; exit if error
.f23d	d0 05		bne $f244		BNE	LAB_F244		; branch if end not reached
.f23f	a9 40		lda #$40		LDA	#$40			; set EOF bit
.f241	20 6a fe	jsr $fe6a		JSR	ORIOST			; OR into I/O status byte
.f244					LAB_F244
.f244	c6 a6		dec $a6			DEC	BUFPNT			; back up tape buffer index
.f246	a6 97		ldx $97			LDX	XSAV			; restore .X
.f248	68		pla			PLA				; restore saved byte
.f249	60		rts			RTS
.f24a					LAB_F24A
.f24a	aa		tax			TAX				; copy error byte
.f24b	68		pla			PLA				; dump saved byte
.f24c	8a		txa			TXA				; restore error byte
.f24d					LAB_F24D
.f24d	a6 97		ldx $97			LDX	XSAV			; restore .X
.f24f	60		rts			RTS
.f250					CHRINTP2
.f250	20 8a f8	jsr $f88a		JSR	JTP20			; bump tape pointer
.f253	d0 0b		bne $f260		BNE	LAB_F260		; if not end get next byte and exit
.f255	20 c0 f8	jsr $f8c0		JSR	RDTPBLKS		; initiate tape read
.f258	b0 11		bcs $f26b		BCS	LAB_F26B		; exit if error flagged
.f25a	a9 00		lda #$00		LDA	#$00			; clear .A
.f25c	85 a6		sta $a6			STA	BUFPNT			; clear tape buffer index
.f25e	f0 f0		beq $f250		BEQ	CHRINTP2		; loop, branch always
.f260					LAB_F260
.f260	b1 b2		lda ($b2),y		LDA	(TAPE1),Y		; get next byte from buffer
.f262	18		clc			CLC				; flag no error
.f263	60		rts			RTS
.f264					CHRINSR
.f264	a5 90		lda $90			LDA	STATUS			; get I/O status byte
.f266	f0 04		beq $f26c		BEQ	LAB_F26C		; if no errors flagged go input byte and return
.f268	a9 0d		lda #$0d		LDA	#$0D			; else return [EOL]
.f26a					LAB_F26A
.f26a	18		clc			CLC				; flag no error
.f26b					LAB_F26B
.f26b	60		rts			RTS
.f26c					LAB_F26C
.f26c	4c 19 ef	jmp $ef19		JMP	FACPTR			; input a byte from the serial bus and return
.f26f					CHRINRS
.f26f	20 05 f2	jsr $f205		JSR	LAB_F205		; get byte from RS-232 device
.f272	b0 05		bcs $f279		BCS	LAB_F279		; branch if error, this doesn't get taken as the last
.f274	c9 00		cmp #$00		CMP	#$00			; compare with null
.f276	f0 f7		beq $f26f		BEQ	CHRINRS			; loop if null
.f278	18		clc			CLC				; flag no error
.f279					LAB_F279
.f279	60		rts			RTS
.f27a					FCHROUT
.f27a	48		pha			PHA				; save the character to send
.f27b	a5 9a		lda $9a			LDA	DFLTO			; get output device number
.f27d	c9 03		cmp #$03		CMP	#$03			; compare device number with screen
.f27f	d0 04		bne $f285		BNE	LAB_F285		; if output device not screen continue
.f281	68		pla			PLA				; restore character to send
.f282	4c 42 e7	jmp $e742		JMP	SCRNOUT			; output character and return
.f285					LAB_F285
.f285	90 04		bcc $f28b		BCC	LAB_F28B		; if output device < screen continue
.f287	68		pla			PLA				; restore character to send
.f288	4c e4 ee	jmp $eee4		JMP	FCIOUT			; output a byte to the serial bus and return
.f28b					LAB_F28B
.f28b	c9 02		cmp #$02		CMP	#$02			; compare the device with RS-232 device
.f28d	f0 2a		beq $f2b9		BEQ	LAB_F2B9		; if output device is RS-232 device go handle it
.f28f	68		pla			PLA				; restore the character to send
.f290					CHROUTTP
.f290	85 9e		sta $9e			STA	PTR1			; save character to character buffer
.f292	48		pha			PHA				; save .A
.f293	8a		txa			TXA				; copy .X
.f294	48		pha			PHA				; save .X
.f295	98		tya			TYA				; copy .Y
.f296	48		pha			PHA				; save .Y
.f297	20 8a f8	jsr $f88a		JSR	JTP20			; bump tape pointer
.f29a	d0 0e		bne $f2aa		BNE	LAB_F2AA		; if not end save next byte and exit
.f29c	20 e3 f8	jsr $f8e3		JSR	WBLK			; initiate tape write
.f29f	b0 0e		bcs $f2af		BCS	LAB_F2AF		; exit if error
.f2a1	a9 02		lda #$02		LDA	#$02			; set data block file type
.f2a3	a0 00		ldy #$00		LDY	#$00			; clear index
.f2a5	91 b2		sta ($b2),y		STA	(TAPE1),Y		; save file type to tape buffer
.f2a7	c8		iny			INY				; increment index
.f2a8	84 a6		sty $a6			STY	BUFPNT			; save tape buffer index
.f2aa					LAB_F2AA
.f2aa	a5 9e		lda $9e			LDA	PTR1			; restore character from character buffer
.f2ac	91 b2		sta ($b2),y		STA	(TAPE1),Y		; save to buffer
.f2ae	18		clc			CLC				; flag no error
.f2af					LAB_F2AF
.f2af	68		pla			PLA				; pull .Y
.f2b0	a8		tay			TAY				; restore .Y
.f2b1	68		pla			PLA				; pull .X
.f2b2	aa		tax			TAX				; restore .X
.f2b3	68		pla			PLA				; restore .A
.f2b4	90 02		bcc $f2b8		BCC	LAB_F2B8		; exit if no error
.f2b6	a9 00		lda #$00		LDA	#$00			; else clear .A
.f2b8					LAB_F2B8
.f2b8	60		rts			RTS
.f2b9					LAB_F2B9
.f2b9	68		pla			PLA				; restore character to send
.f2ba	86 97		stx $97			STX	XSAV			; save .X
.f2bc	84 9e		sty $9e			STY	PTR1			; save .Y
.f2be	20 ed f0	jsr $f0ed		JSR	RSOUTSAV		; send byte to RS-232 buffer
.f2c1	a6 97		ldx $97			LDX	XSAV			; restore .Y
.f2c3	a4 9e		ldy $9e			LDY	PTR1			; restore .X
.f2c5	18		clc			CLC				; flag ok
.f2c6	60		rts			RTS
.f2c7					FCHKIN
.f2c7	20 cf f3	jsr $f3cf		JSR	FNDFLNO			; find file
.f2ca	f0 03		beq $f2cf		BEQ	LAB_F2CF		; branch if file opened
.f2cc	4c 84 f7	jmp $f784		JMP	FE_NTOPN		; do file not open error and return
.f2cf					LAB_F2CF
.f2cf	20 df f3	jsr $f3df		JSR	SETFLCH			; set file details from table,.X
.f2d2	a5 ba		lda $ba			LDA	FA			; get device number
.f2d4	f0 16		beq $f2ec		BEQ	LAB_F2EC		; if device was keyboard save device #, flag ok and exit
.f2d6	c9 03		cmp #$03		CMP	#$03			; compare device number with screen
.f2d8	f0 12		beq $f2ec		BEQ	LAB_F2EC		; if device was screen save device #, flag ok and exit
.f2da	b0 14		bcs $f2f0		BCS	LAB_F2F0		; branch if serial bus device
.f2dc	c9 02		cmp #$02		CMP	#$02			; compare device with RS-232 device
.f2de	d0 03		bne $f2e3		BNE	LAB_F2E3		; branch if not RS-232 device
.f2e0	4c 16 f1	jmp $f116		JMP	RSOPNIN			; open RS-232 channel for input
.f2e3					LAB_F2E3
.f2e3	a6 b9		ldx $b9			LDX	SA			; get secondary address
.f2e5	e0 60		cpx #$60		CPX	#$60			; compare with read
.f2e7	f0 03		beq $f2ec		BEQ	LAB_F2EC		; branch if read
.f2e9	4c 8d f7	jmp $f78d		JMP	FE_NTINP		; do not input file error and return
.f2ec					LAB_F2EC
.f2ec	85 99		sta $99			STA	DFLTN			; save input device number
.f2ee	18		clc			CLC				; flag ok
.f2ef	60		rts			RTS
.f2f0					LAB_F2F0
.f2f0	aa		tax			TAX				; copy device number to .X
.f2f1	20 14 ee	jsr $ee14		JSR	FTALK			; command a serial bus device to TALK
.f2f4	a5 b9		lda $b9			LDA	SA			; get secondary address
.f2f6	10 06		bpl $f2fe		BPL	LAB_F2FE		; branch if address to send
.f2f8	20 d3 ee	jsr $eed3		JSR	LAB_EED3		; wait for bus end after send
.f2fb	4c 01 f3	jmp $f301		JMP	LAB_F301		; do I/O status test
.f2fe					LAB_F2FE
.f2fe	20 ce ee	jsr $eece		JSR	FTKSA			; send secondary address after TALK
.f301					LAB_F301
.f301	8a		txa			TXA				; copy device back to .A
.f302	24 90		bit $90			BIT	STATUS			; test I/O status byte
.f304	10 e6		bpl $f2ec		BPL	LAB_F2EC		; if device present save device number and exit
.f306	4c 8a f7	jmp $f78a		JMP	FE_DVNTP		; do device not present error and return
.f309					FCHKOUT
.f309	20 cf f3	jsr $f3cf		JSR	FNDFLNO			; find file
.f30c	f0 03		beq $f311		BEQ	LAB_F311		; branch if file found
.f30e	4c 84 f7	jmp $f784		JMP	FE_NTOPN		; do file not open error and return
.f311					LAB_F311
.f311	20 df f3	jsr $f3df		JSR	SETFLCH			; set file details from table,.X
.f314	a5 ba		lda $ba			LDA	FA			; get device number
.f316	d0 03		bne $f31b		BNE	LAB_F31B		; branch if device is not keyboard
.f318					LAB_F318
.f318	4c 90 f7	jmp $f790		JMP	FE_NTOUT		; do not output file error and return
.f31b					LAB_F31B
.f31b	c9 03		cmp #$03		CMP	#$03			; compare device number with screen
.f31d	f0 0f		beq $f32e		BEQ	LAB_F32E		; if screen save output device number and exit
.f31f	b0 11		bcs $f332		BCS	LAB_F332		; branch if > screen, serial bus device
.f321	c9 02		cmp #$02		CMP	#$02			; compare device with RS-232 device
.f323	d0 03		bne $f328		BNE	LAB_F328		; branch if not RS-232 device, must be tape
.f325	4c bc f0	jmp $f0bc		JMP	RSOPNOUT		; open RS-232 channel for output
.f328					LAB_F328
.f328	a6 b9		ldx $b9			LDX	SA			; get secondary address
.f32a	e0 60		cpx #$60		CPX	#$60			; compare with read
.f32c	f0 ea		beq $f318		BEQ	LAB_F318		; if read do not output file error and return
.f32e					LAB_F32E
.f32e	85 9a		sta $9a			STA	DFLTO			; save output device number
.f330	18		clc			CLC				; flag ok
.f331	60		rts			RTS
.f332					LAB_F332
.f332	aa		tax			TAX				; copy device number
.f333	20 17 ee	jsr $ee17		JSR	FLISTEN			; command devices on the serial bus to LISTEN
.f336	a5 b9		lda $b9			LDA	SA			; get secondary address
.f338	10 05		bpl $f33f		BPL	LAB_F33F		; branch if address to send
.f33a	20 c5 ee	jsr $eec5		JSR	SCATN			; else set serial ATN high
.f33d	d0 03		bne $f342		BNE	LAB_F342		; branch always
.f33f					LAB_F33F
.f33f	20 c0 ee	jsr $eec0		JSR	FSECOND			; send secondary address after LISTEN
.f342					LAB_F342
.f342	8a		txa			TXA				; copy device number back to .A
.f343	24 90		bit $90			BIT	STATUS			; test I/O status byte
.f345	10 e7		bpl $f32e		BPL	LAB_F32E		; if device present save output device number and exit
.f347	4c 8a f7	jmp $f78a		JMP	FE_DVNTP		; else do device not present error and return
.f34a					FCLOSE
.f34a	20 d4 f3	jsr $f3d4		JSR	LAB_F3D4		; find file .A
.f34d	f0 02		beq $f351		BEQ	LAB_F351		; if the file is found go close it
.f34f	18		clc			CLC				; else the file was closed so just flag ok
.f350	60		rts			RTS
.f351					LAB_F351
.f351	20 df f3	jsr $f3df		JSR	SETFLCH			; set file details from table,.X
.f354	8a		txa			TXA				; copy file index to .A
.f355	48		pha			PHA				; save file index
.f356	a5 ba		lda $ba			LDA	FA			; get device number
.f358	f0 57		beq $f3b1		BEQ	LAB_F3B1		; if $00, keyboard, restore index and close file
.f35a	c9 03		cmp #$03		CMP	#$03			; compare device number with screen
.f35c	f0 53		beq $f3b1		BEQ	LAB_F3B1		; if screen restore index and close file
.f35e	b0 4e		bcs $f3ae		BCS	LAB_F3AE		; if > screen go do serial bus device close
.f360	c9 02		cmp #$02		CMP	#$02			; compare device with RS-232 device
.f362	d0 29		bne $f38d		BNE	LAB_F38D		; branch if not RS-232 device
.f364	68		pla			PLA				; restore file index
.f365	20 b2 f3	jsr $f3b2		JSR	LAB_F3B2		; close file index .A
.f368	a9 7d		lda #$7d		LDA	#$7D			; disable T1, T2, CB1, CB2, SR and CA2
.f36a	8d 1e 91	sta $911e		STA	VIA1IER			; set VIA 1 IER
.f36d	a9 06		lda #$06		LDA	#$06			; set DTR and RTS high
.f36f	8d 10 91	sta $9110		STA	VIA1PB			; set VIA 1 DRB
.f372	a9 ee		lda #$ee		LDA	#$EE			; CB2 high, RS-232 Tx
.f374	8d 1c 91	sta $911c		STA	VIA1PCR			; set VIA 1 PCR
.f377	20 75 fe	jsr $fe75		JSR	LAB_FE75		; read the top of memory
.f37a	a5 f8		lda $f8			LDA	RIBUF+1			; get RS-232 Rx buffer pointer high byte
.f37c	f0 01		beq $f37f		BEQ	LAB_F37F		; branch if no RS-232 input buffer
.f37e	c8		iny			INY				; else reclaim RS-232 input buffer memory
.f37f					LAB_F37F
.f37f	a5 fa		lda $fa			LDA	ROBUF+1			; get RS-232 Tx buffer pointer high byte
.f381	f0 01		beq $f384		BEQ	LAB_F384		; branch if no RS-232 output buffer
.f383	c8		iny			INY				; else reclaim RS-232 output buffer memory
.f384					LAB_F384
.f384	a9 00		lda #$00		LDA	#$00			; clear .A
.f386	85 f8		sta $f8			STA	RIBUF+1			; clear RS-232 Rx buffer pointer high byte
.f388	85 fa		sta $fa			STA	ROBUF+1			; clear RS-232 Tx buffer pointer high byte
.f38a	4c 3c f5	jmp $f53c		JMP	LAB_F53C		; go set top of memory and exit
.f38d					LAB_F38D
.f38d	a5 b9		lda $b9			LDA	SA			; get secondary address
.f38f	29 0f		and #$0f		AND	#$0F			; mask the OPEN CHANNEL command
.f391	f0 1e		beq $f3b1		BEQ	LAB_F3B1		; if read restore index and close file
.f393	20 4d f8	jsr $f84d		JSR	TPBUFA			; get tape buffer start pointer in .X.Y
.f396	a9 00		lda #$00		LDA	#$00			; character $00
.f398	20 90 f2	jsr $f290		JSR	CHROUTTP		; output character to cassette
.f39b	4c cf e4	jmp $e4cf		JMP	PATCH3			; go do CLOSE tail
.f39e					LAB_F39E
.f39e	b0 2e		bcs $f3ce		BCS	LAB_F3CE		; just exit if error
.f3a0	a5 b9		lda $b9			LDA	SA			; get secondary address
.f3a2	c9 62		cmp #$62		CMP	#$62			; compare with end of tape flag
.f3a4	d0 0b		bne $f3b1		BNE	LAB_F3B1		; if not end of tape restore index and close file
.f3a6	a9 05		lda #$05		LDA	#$05			; set logical end of the tape
.f3a8	20 e7 f7	jsr $f7e7		JSR	TAPEH			; write tape header
.f3ab	4c b1 f3	jmp $f3b1		JMP	LAB_F3B1		; restore index and close file
.f3ae					LAB_F3AE
.f3ae	20 da f6	jsr $f6da		JSR	LAB_F6DA		; close serial bus device
.f3b1					LAB_F3B1
.f3b1	68		pla			PLA				; restore file index
.f3b2					LAB_F3B2
.f3b2	aa		tax			TAX				; copy index to file to close
.f3b3	c6 98		dec $98			DEC	LDTND			; decrement open file count
.f3b5	e4 98		cpx $98			CPX	LDTND			; compare index with open file count
.f3b7	f0 14		beq $f3cd		BEQ	LAB_F3CD		; exit if equal, last entry was closing file
.f3b9	a4 98		ldy $98			LDY	LDTND			; get open file count as index
.f3bb	b9 59 02	lda $0259,y		LDA	LAT,Y			; get last+1 logical file number from logical file table
.f3be	9d 59 02	sta $0259,x		STA	LAT,X			; save logical file number over closed file
.f3c1	b9 63 02	lda $0263,y		LDA	FAT,Y			; get last+1 device number from device number table
.f3c4	9d 63 02	sta $0263,x		STA	FAT,X			; save device number over closed file
.f3c7	b9 6d 02	lda $026d,y		LDA	SAT,Y			; get last+1 secondary address from secondary address table
.f3ca	9d 6d 02	sta $026d,x		STA	SAT,X			; save secondary address over closed file
.f3cd					LAB_F3CD
.f3cd	18		clc			CLC				; flag no error
.f3ce					LAB_F3CE
.f3ce	60		rts			RTS
.f3cf					FNDFLNO
.f3cf	a9 00		lda #$00		LDA	#$00			; clear .A
.f3d1	85 90		sta $90			STA	STATUS			; clear I/O status byte
.f3d3	8a		txa			TXA				; copy logical file number to .A
.f3d4					LAB_F3D4
.f3d4	a6 98		ldx $98			LDX	LDTND			; get open file count
.f3d6					LAB_F3D6
.f3d6	ca		dex			DEX				; decrement count to give index
.f3d7	30 15		bmi $f3ee		BMI	LAB_F3EE		; exit if no files
.f3d9	dd 59 02	cmp $0259,x		CMP	LAT,X			; compare logical file number with table logical file number
.f3dc	d0 f8		bne $f3d6		BNE	LAB_F3D6		; loop if no match
.f3de	60		rts			RTS
.f3df					SETFLCH
.f3df	bd 59 02	lda $0259,x		LDA	LAT,X			; get logical file from logical file table
.f3e2	85 b8		sta $b8			STA	LA			; set logical file
.f3e4	bd 63 02	lda $0263,x		LDA	FAT,X			; get device number from device number table
.f3e7	85 ba		sta $ba			STA	FA			; set device number
.f3e9	bd 6d 02	lda $026d,x		LDA	SAT,X			; get secondary address from secondary address table
.f3ec	85 b9		sta $b9			STA	SA			; set secondary address
.f3ee					LAB_F3EE
.f3ee	60		rts			RTS
.f3ef					FCLALL
.f3ef	a9 00		lda #$00		LDA	#$00			; clear .A
.f3f1	85 98		sta $98			STA	LDTND			; clear open file count
.f3f3					FCLRCHN
.f3f3	a2 03		ldx #$03		LDX	#$03			; set .X to screen
.f3f5	e4 9a		cpx $9a			CPX	DFLTO			; compare output device number with screen
.f3f7	b0 03		bcs $f3fc		BCS	LAB_F3FC		; branch if screen >= device
.f3f9	20 04 ef	jsr $ef04		JSR	FUNLSN			; command the serial bus to UNLISTEN
.f3fc					LAB_F3FC
.f3fc	e4 99		cpx $99			CPX	DFLTN			; compare input device number with screen
.f3fe	b0 03		bcs $f403		BCS	LAB_F403		; branch if screen >= device
.f400	20 f6 ee	jsr $eef6		JSR	FUNTLK			; command the serial bus to UNTALK
.f403					LAB_F403
.f403	86 9a		stx $9a			STX	DFLTO			; set output device number to screen
.f405	a9 00		lda #$00		LDA	#$00			; set for keyboard
.f407	85 99		sta $99			STA	DFLTN			; set input device number to keyboard
.f409	60		rts			RTS
.f40a					FOPEN
.f40a	a6 b8		ldx $b8			LDX	LA			; get logical file
.f40c	d0 03		bne $f411		BNE	LAB_F411		; branch if there is a file
.f40e	4c 8d f7	jmp $f78d		JMP	FE_NTINP		; else do not input file error and return
.f411					LAB_F411
.f411	20 cf f3	jsr $f3cf		JSR	FNDFLNO			; find file
.f414	d0 03		bne $f419		BNE	LAB_F419		; branch if file not found
.f416	4c 81 f7	jmp $f781		JMP	FE_ALOPN		; else do file already open error and return
.f419					LAB_F419
.f419	a6 98		ldx $98			LDX	LDTND			; get open file count
.f41b	e0 0a		cpx #$0a		CPX	#$0A			; compare with max
.f41d	90 03		bcc $f422		BCC	LAB_F422		; branch if less
.f41f	4c 7e f7	jmp $f77e		JMP	FE_2MNYF		; else do too many files error and return
.f422					LAB_F422
.f422	e6 98		inc $98			INC	LDTND			; increment open file count
.f424	a5 b8		lda $b8			LDA	LA			; get logical file
.f426	9d 59 02	sta $0259,x		STA	LAT,X			; save to logical file table
.f429	a5 b9		lda $b9			LDA	SA			; get secondary address
.f42b	09 60		ora #$60		ORA	#$60			; OR with the OPEN CHANNEL command
.f42d	85 b9		sta $b9			STA	SA			; set secondary address
.f42f	9d 6d 02	sta $026d,x		STA	SAT,X			; save to secondary address table
.f432	a5 ba		lda $ba			LDA	FA			; get device number
.f434	9d 63 02	sta $0263,x		STA	FAT,X			; save to device number table
.f437	f0 5a		beq $f493		BEQ	LAB_F493		; do ok exit if keyboard
.f439	c9 03		cmp #$03		CMP	#$03			; compare device number with screen
.f43b	f0 56		beq $f493		BEQ	LAB_F493		; do ok exit if screen
.f43d	90 05		bcc $f444		BCC	LAB_F444		; branch if < screen, tape or RS-232
.f43f	20 95 f4	jsr $f495		JSR	SERNAME			; send secondary address and filename
.f442	90 4f		bcc $f493		BCC	LAB_F493		; do ok exit, branch always
.f444					LAB_F444
.f444	c9 02		cmp #$02		CMP	#$02			; compare device with RS-232 device
.f446	d0 03		bne $f44b		BNE	LAB_F44B		; branch if not RS-232 device, must be tape
.f448	4c c7 f4	jmp $f4c7		JMP	OPENRS			; go open RS-232 device and return
.f44b					LAB_F44B
.f44b	20 4d f8	jsr $f84d		JSR	TPBUFA			; get tape buffer start pointer in .X.Y
.f44e	b0 03		bcs $f453		BCS	LAB_F453		; branch if >= $0200
.f450	4c 96 f7	jmp $f796		JMP	FE_ILDEV		; do illegal device number and return
.f453					LAB_F453
.f453	a5 b9		lda $b9			LDA	SA			; get secondary address
.f455	29 0f		and #$0f		AND	#$0F			; mask the OPEN CHANNEL command
.f457	d0 1f		bne $f478		BNE	LAB_F478		; branch if write
.f459	20 94 f8	jsr $f894		JSR	CSTEL			; wait for PLAY
.f45c	b0 36		bcs $f494		BCS	LAB_F494		; exit if [STOP] was pressed
.f45e	20 47 f6	jsr $f647		JSR	SRCHING			; print "SEARCHING..."
.f461	a5 b7		lda $b7			LDA	FNLEN			; get file name length
.f463	f0 0a		beq $f46f		BEQ	LAB_F46F		; if null file name just go find header
.f465	20 67 f8	jsr $f867		JSR	FNDHDR			; find specific tape header
.f468	90 18		bcc $f482		BCC	LAB_F482		; branch if no error
.f46a	f0 28		beq $f494		BEQ	LAB_F494		; branch always
.f46c					LAB_F46C
.f46c	4c 87 f7	jmp $f787		JMP	FE_NTFND		; do file not found error and return
.f46f					LAB_F46F
.f46f	20 af f7	jsr $f7af		JSR	FAH			; find tape header, exit with header in buffer
.f472	f0 20		beq $f494		BEQ	LAB_F494		; exit if end of tape found
.f474	90 0c		bcc $f482		BCC	LAB_F482		; branch if no error
.f476	b0 f4		bcs $f46c		BCS	LAB_F46C		; branch if error
.f478					LAB_F478
.f478	20 b7 f8	jsr $f8b7		JSR	CSTE2			; wait for PLAY/RECORD
.f47b	b0 17		bcs $f494		BCS	LAB_F494		; exit if [STOP] was pressed
.f47d	a9 04		lda #$04		LDA	#$04			; set data file header
.f47f	20 e7 f7	jsr $f7e7		JSR	TAPEH			; write tape header
.f482					LAB_F482
.f482	a9 bf		lda #$bf		LDA	#$BF			; set tape buffer length
.f484	a4 b9		ldy $b9			LDY	SA			; get secondary address
.f486	c0 60		cpy #$60		CPY	#$60			; compare with read
.f488	f0 07		beq $f491		BEQ	LAB_F491		; branch if read
.f48a	a0 00		ldy #$00		LDY	#$00			; clear index
.f48c	a9 02		lda #$02		LDA	#$02			; set data file block file type
.f48e	91 b2		sta ($b2),y		STA	(TAPE1),Y		; save file type to tape buffer
.f490	98		tya			TYA				; clear .A
.f491					LAB_F491
.f491	85 a6		sta $a6			STA	BUFPNT			; save tape buffer index
.f493					LAB_F493
.f493	18		clc			CLC				; flag ok
.f494					LAB_F494
.f494	60		rts			RTS
.f495					SERNAME
.f495	a5 b9		lda $b9			LDA	SA			; get secondary address
.f497	30 2c		bmi $f4c5		BMI	LAB_F4C5		; ok exit if no address
.f499	a4 b7		ldy $b7			LDY	FNLEN			; get file name length
.f49b	f0 28		beq $f4c5		BEQ	LAB_F4C5		; ok exit if null
.f49d	a5 ba		lda $ba			LDA	FA			; get device number
.f49f	20 17 ee	jsr $ee17		JSR	FLISTEN			; command devices on the serial bus to LISTEN
.f4a2	a5 b9		lda $b9			LDA	SA			; get the secondary address
.f4a4	09 f0		ora #$f0		ORA	#$F0			; OR with the OPEN command
.f4a6	20 c0 ee	jsr $eec0		JSR	FSECOND			; send secondary address after LISTEN
.f4a9	a5 90		lda $90			LDA	STATUS			; get I/O status byte
.f4ab	10 05		bpl $f4b2		BPL	LAB_F4B2		; branch if device present
.f4ad	68		pla			PLA				; else dump calling address low byte
.f4ae	68		pla			PLA				; dump calling address high byte
.f4af	4c 8a f7	jmp $f78a		JMP	FE_DVNTP		; do device not present error and return
.f4b2					LAB_F4B2
.f4b2	a5 b7		lda $b7			LDA	FNLEN			; get file name length
.f4b4	f0 0c		beq $f4c2		BEQ	LAB_F4C2		; branch if null name
.f4b6	a0 00		ldy #$00		LDY	#$00			; clear index
.f4b8					LAB_F4B8
.f4b8	b1 bb		lda ($bb),y		LDA	(FNADR),Y		; get file name byte
.f4ba	20 e4 ee	jsr $eee4		JSR	FCIOUT			; output a byte to the serial bus
.f4bd	c8		iny			INY				; increment index
.f4be	c4 b7		cpy $b7			CPY	FNLEN			; compare with file name length
.f4c0	d0 f6		bne $f4b8		BNE	LAB_F4B8		; loop if not all done
.f4c2					LAB_F4C2
.f4c2	20 04 ef	jsr $ef04		JSR	FUNLSN			; command the serial bus to UNLISTEN
.f4c5					LAB_F4C5
.f4c5	18		clc			CLC				; flag ok
.f4c6	60		rts			RTS
.f4c7					OPENRS
.f4c7	a9 06		lda #$06		LDA	#$06			; IIII IOOI, DTR and RTS only as outputs
.f4c9	8d 12 91	sta $9112		STA	VIA1DDRB		; set VIA 1 DDRB
.f4cc	8d 10 91	sta $9110		STA	VIA1PB			; set VIA 1 DRB, DTR and RTS high
.f4cf	a9 ee		lda #$ee		LDA	#$EE			; CB2 high, RS-232 Tx
.f4d1	8d 1c 91	sta $911c		STA	VIA1PCR			; set VIA 1 PCR
.f4d4	a0 00		ldy #$00		LDY	#$00			; clear index
.f4d6	8c 97 02	sty $0297		STY	RSSTAT			; clear RS-232 status byte
.f4d9					LAB_F4D9
.f4d9	c4 b7		cpy $b7			CPY	FNLEN			; compare with file name length
.f4db	f0 0a		beq $f4e7		BEQ	LAB_F4E7		; exit loop if done
.f4dd	b1 bb		lda ($bb),y		LDA	(FNADR),Y		; get file name byte
.f4df	99 93 02	sta $0293,y		STA	M51CTR,Y		; copy to pseudo 6551 register set
.f4e2	c8		iny			INY				; increment index
.f4e3	c0 04		cpy #$04		CPY	#$04			; compare with $04
.f4e5	d0 f2		bne $f4d9		BNE	LAB_F4D9		; loop if not to 4 yet
.f4e7					LAB_F4E7
.f4e7	20 27 f0	jsr $f027		JSR	RSCPTBIT		; compute bit count
.f4ea	8e 98 02	stx $0298		STX	BITNUM			; save bit count
.f4ed	ad 93 02	lda $0293		LDA	M51CTR			; get pseudo 6551 control register
.f4f0	29 0f		and #$0f		AND	#$0F			; mask 0000 xxxx, baud rate
.f4f2	d0 00		bne $f4f4		BNE	LAB_F4F4		; short delay. was this intended to skip code used to
.f4f4					LAB_F4F4
.f4f4	0a		asl a			ASL				; * 2, 2 bytes per baud count
.f4f5	aa		tax			TAX				; copy to index
.f4f6	bd 5a ff	lda $ff5a,x		LDA	BAUDTBL-2,X		; get timer constant low byte
.f4f9	0a		asl a			ASL				; * 2
.f4fa	a8		tay			TAY				; copy to .Y
.f4fb	bd 5b ff	lda $ff5b,x		LDA	BAUDTBL-1,X		; get timer constant high byte
.f4fe	2a		rol a			ROL				; * 2
.f4ff	48		pha			PHA				; save it
.f500	98		tya			TYA				; get timer constant low byte back
.f501	69 c8		adc #$c8		ADC	#$C8			; + 200, carry cleared by previous ROL
.f503	8d 99 02	sta $0299		STA	BAUDOF			; save bit cell time low byte
.f506	68		pla			PLA				; restore high byte
.f507	69 00		adc #$00		ADC	#$00			; add carry
.f509	8d 9a 02	sta $029a		STA	BAUDOF+1		; save bit cell time high byte
.f50c	ad 94 02	lda $0294		LDA	M51CDR			; get pseudo 6551 command register
.f50f	4a		lsr a			LSR				; shift b0 into Cb
.f510	90 09		bcc $f51b		BCC	LAB_F51B		; branch if 3 line interface
.f512	ad 20 91	lda $9120		LDA	VIA2PB			; get VIA 2 DRB
.f515	0a		asl a			ASL				; shift DSR into Cb
.f516	b0 03		bcs $f51b		BCS	LAB_F51B		; branch if DSR = 1
.f518	4c 16 f0	jmp $f016		JMP	RSMISSNG		; set DSR signal not present and return
.f51b					LAB_F51B
.f51b	ad 9b 02	lda $029b		LDA	RIDBE			; get index to Rx buffer end
.f51e	8d 9c 02	sta $029c		STA	RIDBS			; set index to Rx buffer start, clear Rx buffer
.f521	ad 9e 02	lda $029e		LDA	RODBE			; get index to Tx buffer end
.f524	8d 9d 02	sta $029d		STA	RODBS			; set index to Tx buffer start, clear Tx buffer
.f527	20 75 fe	jsr $fe75		JSR	LAB_FE75		; read the top of memory
.f52a	a5 f8		lda $f8			LDA	RIBUF+1			; get RS-232 Rx buffer pointer high byte
.f52c	d0 05		bne $f533		BNE	LAB_F533		; branch if buffer already set
.f52e	88		dey			DEY				; decrement top of memory high byte, 256 byte buffer
.f52f	84 f8		sty $f8			STY	RIBUF+1			; set RS-232 Rx buffer pointer high byte
.f531	86 f7		stx $f7			STX	RIBUF			; set RS-232 Rx buffer pointer low byte
.f533					LAB_F533
.f533	a5 fa		lda $fa			LDA	ROBUF+1			; get RS-232 Tx buffer pointer high byte
.f535	d0 05		bne $f53c		BNE	LAB_F53C		; branch if buffer already set
.f537	88		dey			DEY				; decrement Rx buffer pointer high byte, 256 byte buffer
.f538	84 fa		sty $fa			STY	ROBUF+1			; set RS-232 Tx buffer pointer high byte
.f53a	86 f9		stx $f9			STX	ROBUF			; set RS-232 Tx buffer pointer low byte
.f53c					LAB_F53C
.f53c	38		sec			SEC				; non-standard exit, Cb set
.f53d	a9 f0		lda #$f0		LDA	#$F0			; non-standard exit, $F0 error code
.f53f	4c 7b fe	jmp $fe7b		JMP	LAB_FE7B		; set the top of memory and return
.f542					FLOAD
.f542	86 c3		stx $c3			STX	MEMUSS			; set load start address low byte
.f544	84 c4		sty $c4			STY	MEMUSS+1		; set load start address high byte
.f546	6c 30 03	jmp ($0330)		JMP	(ILOAD)			; do LOAD vector, usually points to FLOAD2
.f549					FLOAD2
.f549	85 93		sta $93			STA	VERCK			; save load/verify flag
.f54b	a9 00		lda #$00		LDA	#$00			; clear .A
.f54d	85 90		sta $90			STA	STATUS			; clear I/O status byte
.f54f	a5 ba		lda $ba			LDA	FA			; get device number
.f551	d0 03		bne $f556		BNE	LAB_F556		; branch if not keyboard
.f553					LAB_F553
.f553	4c 96 f7	jmp $f796		JMP	FE_ILDEV		; do illegal device number and return
.f556					LAB_F556
.f556	c9 03		cmp #$03		CMP	#$03			; compare device number with screen
.f558	f0 f9		beq $f553		BEQ	LAB_F553		; if screen go do illegal device number and return
.f55a	90 6e		bcc $f5ca		BCC	LAB_F5CA		; branch if less than screen
.f55c	a4 b7		ldy $b7			LDY	FNLEN			; get file name length
.f55e	d0 03		bne $f563		BNE	LAB_F563		; branch if not null name
.f560	4c 93 f7	jmp $f793		JMP	FE_MISFN		; else do missing file name error and return
.f563					LAB_F563
.f563	20 bc e4	jsr $e4bc		JSR	PATCH1			; get secondary address and print "SEARCHING..."
.f566	a9 60		lda #$60		LDA	#$60			; set secondary address to $00
.f568	85 b9		sta $b9			STA	SA			; save secondary address
.f56a	20 95 f4	jsr $f495		JSR	SERNAME			; send secondary address and filename
.f56d	a5 ba		lda $ba			LDA	FA			; get device number
.f56f	20 14 ee	jsr $ee14		JSR	FTALK			; command a serial bus device to TALK
.f572	a5 b9		lda $b9			LDA	SA			; get secondary address
.f574	20 ce ee	jsr $eece		JSR	FTKSA			; send secondary address after TALK
.f577	20 19 ef	jsr $ef19		JSR	FACPTR			; input a byte from the serial bus
.f57a	85 ae		sta $ae			STA	EAL			; save program start address low byte
.f57c	a5 90		lda $90			LDA	STATUS			; get I/O status byte
.f57e	4a		lsr a			LSR				; shift time out read ..
.f57f	4a		lsr a			LSR				; .. into carry bit
.f580	b0 45		bcs $f5c7		BCS	LAB_F5C7		; if timed out go do file not found error and return
.f582	20 19 ef	jsr $ef19		JSR	FACPTR			; input a byte from the serial bus
.f585	85 af		sta $af			STA	EAL+1			; save program start address high byte
.f587	20 c1 e4	jsr $e4c1		JSR	PATCH2			; set LOAD address if secondary address = 0
.f58a					LAB_F58A
.f58a	a9 fd		lda #$fd		LDA	#$FD			; mask xxxx xx0x, clear time out read bit
.f58c	25 90		and $90			AND	STATUS			; mask I/O status byte
.f58e	85 90		sta $90			STA	STATUS			; set I/O status byte
.f590	20 e1 ff	jsr $ffe1		JSR	STOP			; scan stop key, return Zb = 1 = [STOP]
.f593	d0 03		bne $f598		BNE	LAB_F598		; branch if not [STOP]
.f595	4c cb f6	jmp $f6cb		JMP	LAB_F6CB		; else close the serial bus device and flag stop
.f598					LAB_F598
.f598	20 19 ef	jsr $ef19		JSR	FACPTR			; input a byte from the serial bus
.f59b	aa		tax			TAX				; copy byte
.f59c	a5 90		lda $90			LDA	STATUS			; get I/O status byte
.f59e	4a		lsr a			LSR				; shift time out read ..
.f59f	4a		lsr a			LSR				; .. into carry bit
.f5a0	b0 e8		bcs $f58a		BCS	LAB_F58A		; if timed out clear I/O status and retry
.f5a2	8a		txa			TXA				; copy received byte back
.f5a3	a4 93		ldy $93			LDY	VERCK			; get load/verify flag
.f5a5	f0 0c		beq $f5b3		BEQ	LAB_F5B3		; branch if load
.f5a7	a0 00		ldy #$00		LDY	#$00			; clear index
.f5a9	d1 ae		cmp ($ae),y		CMP	(EAL),Y			; compare byte with previously loaded byte
.f5ab	f0 08		beq $f5b5		BEQ	LAB_F5B5		; branch if match
.f5ad	a9 10		lda #$10		LDA	#$10			; set read error bit
.f5af	20 6a fe	jsr $fe6a		JSR	ORIOST			; OR into I/O status byte
>f5b2	2c					.byte	$2C			; makes next line BIT $AE91
.f5b3					LAB_F5B3
.f5b3	91 ae		sta ($ae),y		STA	(EAL),Y			; save byte to memory
.f5b5					LAB_F5B5
.f5b5	e6 ae		inc $ae			INC	EAL			; increment save pointer low byte
.f5b7	d0 02		bne $f5bb		BNE	LAB_F5BB		; if no rollover skip the high byte increment
.f5b9	e6 af		inc $af			INC	EAL+1			; else increment save pointer high byte
.f5bb					LAB_F5BB
.f5bb	24 90		bit $90			BIT	STATUS			; test I/O status byte
.f5bd	50 cb		bvc $f58a		BVC	LAB_F58A		; loop if not end of file
.f5bf	20 f6 ee	jsr $eef6		JSR	FUNTLK			; command the serial bus to UNTALK
.f5c2	20 da f6	jsr $f6da		JSR	LAB_F6DA		; close serial bus device
.f5c5	90 7a		bcc $f641		BCC	LAB_F641		; if no error go flag ok and exit
.f5c7					LAB_F5C7
.f5c7	4c 87 f7	jmp $f787		JMP	FE_NTFND		; do file not found error and return
.f5ca					LAB_F5CA
.f5ca	c9 02		cmp #$02		CMP	#$02			; compare device with RS-232 device
.f5cc	d0 03		bne $f5d1		BNE	LOADTP			; if not RS-232 device continue
.f5ce	4c b9 f0	jmp $f0b9		JMP	RSDVCERR		; else do illegal device number and return
.f5d1					LOADTP
.f5d1	20 4d f8	jsr $f84d		JSR	TPBUFA			; get tape buffer start pointer in .X.Y
.f5d4	b0 03		bcs $f5d9		BCS	LAB_F5D9		; branch if >= $0200
.f5d6	4c 96 f7	jmp $f796		JMP	FE_ILDEV		; do illegal device number and return
.f5d9					LAB_F5D9
.f5d9	20 94 f8	jsr $f894		JSR	CSTEL			; wait for PLAY
.f5dc	b0 68		bcs $f646		BCS	LAB_F646		; exit if [STOP] was pressed
.f5de	20 47 f6	jsr $f647		JSR	SRCHING			; print "SEARCHING..."
.f5e1					LAB_F5E1
.f5e1	a5 b7		lda $b7			LDA	FNLEN			; get file name length
.f5e3	f0 09		beq $f5ee		BEQ	LAB_F5EE
.f5e5	20 67 f8	jsr $f867		JSR	FNDHDR			; find specific tape header
.f5e8	90 0b		bcc $f5f5		BCC	LAB_F5F5		; if no error continue
.f5ea	f0 5a		beq $f646		BEQ	LAB_F646		; exit if end of tape found
.f5ec	b0 d9		bcs $f5c7		BCS	LAB_F5C7		; exit on error
.f5ee					LAB_F5EE
.f5ee	20 af f7	jsr $f7af		JSR	FAH			; find tape header, exit with header in buffer
.f5f1	f0 53		beq $f646		BEQ	LAB_F646		; exit if end of tape found
.f5f3	b0 d2		bcs $f5c7		BCS	LAB_F5C7		; exit on error
.f5f5					LAB_F5F5
.f5f5	a5 90		lda $90			LDA	STATUS			; get I/O status byte
.f5f7	29 10		and #$10		AND	#$10			; mask 000x 0000, read error
.f5f9	38		sec			SEC				; flag fail
.f5fa	d0 4a		bne $f646		BNE	LAB_F646		; if read error just exit
.f5fc	e0 01		cpx #$01		CPX	#$01			; compare file type with relocatable program
.f5fe	f0 11		beq $f611		BEQ	LAB_F611		; branch if relocatable program
.f600	e0 03		cpx #$03		CPX	#$03			; compare file type with non relocatable program
.f602	d0 dd		bne $f5e1		BNE	LAB_F5E1		; branch if not non relocatable program
.f604					LAB_F604
.f604	a0 01		ldy #$01		LDY	#$01			; index to start address
.f606	b1 b2		lda ($b2),y		LDA	(TAPE1),Y		; get start address low byte
.f608	85 c3		sta $c3			STA	MEMUSS			; save load start address low byte
.f60a	c8		iny			INY				; increment index
.f60b	b1 b2		lda ($b2),y		LDA	(TAPE1),Y		; get start address high byte
.f60d	85 c4		sta $c4			STA	MEMUSS+1		; set load start address high byte
.f60f	b0 04		bcs $f615		BCS	LAB_F615		; branch always
.f611					LAB_F611
.f611	a5 b9		lda $b9			LDA	SA			; get secondary address
.f613	d0 ef		bne $f604		BNE	LAB_F604		; branch if not relocatable
.f615					LAB_F615
.f615	a0 03		ldy #$03		LDY	#$03			; index to end address low byte
.f617	b1 b2		lda ($b2),y		LDA	(TAPE1),Y		; get end address low byte
.f619	a0 01		ldy #$01		LDY	#$01			; index to start address low byte
.f61b	f1 b2		sbc ($b2),y		SBC	(TAPE1),Y		; subtract start address low byte
.f61d	aa		tax			TAX				; copy file length low byte
.f61e	a0 04		ldy #$04		LDY	#$04			; index to end address high byte
.f620	b1 b2		lda ($b2),y		LDA	(TAPE1),Y		; get end address high byte
.f622	a0 02		ldy #$02		LDY	#$02			; index to start address high byte
.f624	f1 b2		sbc ($b2),y		SBC	(TAPE1),Y		; subtract start address high byte
.f626	a8		tay			TAY				; copy file length high byte
.f627	18		clc			CLC				; clear carry for add
.f628	8a		txa			TXA				; get file length low byte back
.f629	65 c3		adc $c3			ADC	MEMUSS			; add load start address low byte
.f62b	85 ae		sta $ae			STA	EAL			; save LOAD end pointer low byte
.f62d	98		tya			TYA				; get file length high byte back
.f62e	65 c4		adc $c4			ADC	MEMUSS+1		; add load start address high byte
.f630	85 af		sta $af			STA	EAL+1			; save LOAD end pointer high byte
.f632	a5 c3		lda $c3			LDA	MEMUSS			; get load start address low byte
.f634	85 c1		sta $c1			STA	STAL			; save I/O start address low byte
.f636	a5 c4		lda $c4			LDA	MEMUSS+1		; get load start address high byte
.f638	85 c2		sta $c2			STA	STAL+1			; save I/O start address high byte
.f63a	20 6a f6	jsr $f66a		JSR	LDVRMSG			; display "LOADING" or "VERIFYING"
.f63d	20 c9 f8	jsr $f8c9		JSR	RBLK			; do the tape read
>f640	24					.byte	$24			; makes next line BIT $18, keep the error flag in Cb
.f641					LAB_F641
.f641	18		clc			CLC				; flag ok
.f642	a6 ae		ldx $ae			LDX	EAL			; get the LOAD end pointer low byte
.f644	a4 af		ldy $af			LDY	EAL+1			; get the LOAD end pointer high byte
.f646					LAB_F646
.f646	60		rts			RTS
.f647					SRCHING
.f647	a5 9d		lda $9d			LDA	MSGFLG			; get KERNAL message mode flag
.f649	10 1e		bpl $f669		BPL	LAB_F669		; exit if control messages off
.f64b	a0 0c		ldy #$0c		LDY	#KM_SRCHG-KMSGTBL
.f64d	20 e6 f1	jsr $f1e6		JSR	KMSGSHOW		; display KERNAL I/O message
.f650	a5 b7		lda $b7			LDA	FNLEN			; get file name length
.f652	f0 15		beq $f669		BEQ	LAB_F669		; exit if null name
.f654	a0 17		ldy #$17		LDY	#KM_FOR-KMSGTBL
.f656	20 e6 f1	jsr $f1e6		JSR	KMSGSHOW		; display KERNAL I/O message
.f659					FILENAME
.f659	a4 b7		ldy $b7			LDY	FNLEN			; get file name length
.f65b	f0 0c		beq $f669		BEQ	LAB_F669		; exit if null file name
.f65d	a0 00		ldy #$00		LDY	#$00			; clear index
.f65f					LAB_F65F
.f65f	b1 bb		lda ($bb),y		LDA	(FNADR),Y		; get file name byte
.f661	20 d2 ff	jsr $ffd2		JSR	CHROUT			; output character to channel
.f664	c8		iny			INY				; increment index
.f665	c4 b7		cpy $b7			CPY	FNLEN			; compare with file name length
.f667	d0 f6		bne $f65f		BNE	LAB_F65F		; loop if more to do
.f669					LAB_F669
.f669	60		rts			RTS
.f66a					LDVRMSG
.f66a	a0 49		ldy #$49		LDY	#KM_LODNG-KMSGTBL
.f66c	a5 93		lda $93			LDA	VERCK			; get load/verify flag
.f66e	f0 02		beq $f672		BEQ	LAB_F672		; branch if load
.f670	a0 59		ldy #$59		LDY	#KM_VFYNG-KMSGTBL
.f672					LAB_F672
.f672	4c e2 f1	jmp $f1e2		JMP	SPMSG			; display KERNAL I/O message if in direct mode and return
.f675					FSAVE
.f675	86 ae		stx $ae			STX	EAL			; save end address low byte
.f677	84 af		sty $af			STY	EAL+1			; save end address high byte
.f679	aa		tax			TAX				; copy index to start pointer
.f67a	b5 00		lda $00,x		LDA	$00,X			; get start address low byte
.f67c	85 c1		sta $c1			STA	STAL			; set I/O start address low byte
.f67e	b5 01		lda $01,x		LDA	$01,X			; get start address high byte
.f680	85 c2		sta $c2			STA	STAL+1			; set I/O start address high byte
.f682	6c 32 03	jmp ($0332)		JMP	(ISAVE)			; go save, usually points to FSAVE2
.f685					FSAVE2
.f685	a5 ba		lda $ba			LDA	FA			; get device number
.f687	d0 03		bne $f68c		BNE	LAB_F68C		; branch if not keyboard
.f689					LAB_F689
.f689	4c 96 f7	jmp $f796		JMP	FE_ILDEV		; do illegal device number and return
.f68c					LAB_F68C
.f68c	c9 03		cmp #$03		CMP	#$03			; compare device number with screen
.f68e	f0 f9		beq $f689		BEQ	LAB_F689		; if screen do illegal device number and return
.f690	90 5f		bcc $f6f1		BCC	SAVETP			; branch if < screen
.f692	a9 61		lda #$61		LDA	#$61			; set secondary address to $01
.f694	85 b9		sta $b9			STA	SA			; save secondary address
.f696	a4 b7		ldy $b7			LDY	FNLEN			; get file name length
.f698	d0 03		bne $f69d		BNE	LAB_F69D		; branch if filename not null
.f69a	4c 93 f7	jmp $f793		JMP	FE_MISFN		; else do missing file name error and return
.f69d					LAB_F69D
.f69d	20 95 f4	jsr $f495		JSR	SERNAME			; send secondary address and filename
.f6a0	20 28 f7	jsr $f728		JSR	SAVING			; print "SAVING <file name>"
.f6a3	a5 ba		lda $ba			LDA	FA			; get device number
.f6a5	20 17 ee	jsr $ee17		JSR	FLISTEN			; command devices on the serial bus to LISTEN
.f6a8	a5 b9		lda $b9			LDA	SA			; get secondary address
.f6aa	20 c0 ee	jsr $eec0		JSR	FSECOND			; send secondary address after LISTEN
.f6ad	a0 00		ldy #$00		LDY	#$00			; clear index
.f6af	20 d2 fb	jsr $fbd2		JSR	RD300			; copy I/O start address to buffer address
.f6b2	a5 ac		lda $ac			LDA	SAL			; get buffer address low byte
.f6b4	20 e4 ee	jsr $eee4		JSR	FCIOUT			; output a byte to the serial bus
.f6b7	a5 ad		lda $ad			LDA	SAL+1			; get buffer address high byte
.f6b9	20 e4 ee	jsr $eee4		JSR	FCIOUT			; output a byte to the serial bus
.f6bc					LAB_F6BC
.f6bc	20 11 fd	jsr $fd11		JSR	VPRTY			; check read/write pointer, return Cb = 1 if pointer >= end
.f6bf	b0 16		bcs $f6d7		BCS	LAB_F6D7		; go do UNLISTEN if at end
.f6c1	b1 ac		lda ($ac),y		LDA	(SAL),Y			; get byte from buffer
.f6c3	20 e4 ee	jsr $eee4		JSR	FCIOUT			; output a byte to the serial bus
.f6c6	20 e1 ff	jsr $ffe1		JSR	STOP			; scan stop key
.f6c9	d0 07		bne $f6d2		BNE	LAB_F6D2		; if stop not pressed go increment pointer and loop for next
.f6cb					LAB_F6CB
.f6cb	20 da f6	jsr $f6da		JSR	LAB_F6DA		; close serial bus device
.f6ce	a9 00		lda #$00		LDA	#ER_STOP		; terminated by [STOP] key
.f6d0	38		sec			SEC				; flag stop
.f6d1	60		rts			RTS
.f6d2					LAB_F6D2
.f6d2	20 1b fd	jsr $fd1b		JSR	WRT62			; increment read/write pointer
.f6d5	d0 e5		bne $f6bc		BNE	LAB_F6BC		; loop, branch always
.f6d7					LAB_F6D7
.f6d7	20 04 ef	jsr $ef04		JSR	FUNLSN			; command the serial bus to UNLISTEN
.f6da					LAB_F6DA
.f6da	24 b9		bit $b9			BIT	SA			; test the secondary address
.f6dc	30 11		bmi $f6ef		BMI	LAB_F6EF		; if already closed just exit
.f6de	a5 ba		lda $ba			LDA	FA			; get device number
.f6e0	20 17 ee	jsr $ee17		JSR	FLISTEN			; command devices on the serial bus to LISTEN
.f6e3	a5 b9		lda $b9			LDA	SA			; get secondary address
.f6e5	29 ef		and #$ef		AND	#$EF			; mask the channel number
.f6e7	09 e0		ora #$e0		ORA	#$E0			; OR with the CLOSE command
.f6e9	20 c0 ee	jsr $eec0		JSR	FSECOND			; send secondary address after LISTEN
.f6ec	20 04 ef	jsr $ef04		JSR	FUNLSN			; command the serial bus to UNLISTEN
.f6ef					LAB_F6EF
.f6ef	18		clc			CLC				; flag ok
.f6f0	60		rts			RTS
.f6f1					SAVETP
.f6f1	c9 02		cmp #$02		CMP	#$02			; compare device with RS-232 device
.f6f3	d0 03		bne $f6f8		BNE	LAB_F6F8		; branch if not RS-232 device
.f6f5	4c b9 f0	jmp $f0b9		JMP	RSDVCERR		; else do illegal device number and return
.f6f8					LAB_F6F8
.f6f8	20 4d f8	jsr $f84d		JSR	TPBUFA			; get tape buffer start pointer in .X.Y
.f6fb	90 8c		bcc $f689		BCC	LAB_F689		; if < $0200 do illegal device number and return
.f6fd	20 b7 f8	jsr $f8b7		JSR	CSTE2			; wait for PLAY/RECORD
.f700	b0 25		bcs $f727		BCS	LAB_F727		; exit if [STOP] was pressed
.f702	20 28 f7	jsr $f728		JSR	SAVING			; print "SAVING <file name>"
.f705	a2 03		ldx #$03		LDX	#$03			; set header for a non relocatable program file
.f707	a5 b9		lda $b9			LDA	SA			; get secondary address
.f709	29 01		and #$01		AND	#$01			; mask non relocatable bit
.f70b	d0 02		bne $f70f		BNE	LAB_F70F		; branch if non relocatable program
.f70d	a2 01		ldx #$01		LDX	#$01			; else set header for a relocatable program file
.f70f					LAB_F70F
.f70f	8a		txa			TXA				; copy header type to .A
.f710	20 e7 f7	jsr $f7e7		JSR	TAPEH			; write tape header
.f713	b0 12		bcs $f727		BCS	LAB_F727		; exit if error
.f715	20 e6 f8	jsr $f8e6		JSR	LAB_F8E6		; do tape write, 20 cycle count
.f718	b0 0d		bcs $f727		BCS	LAB_F727		; exit if error
.f71a	a5 b9		lda $b9			LDA	SA			; get secondary address
.f71c	29 02		and #$02		AND	#$02			; mask end of tape flag
.f71e	f0 06		beq $f726		BEQ	LAB_F726		; branch if not end of tape
.f720	a9 05		lda #$05		LDA	#$05			; else set logical end of the tape
.f722	20 e7 f7	jsr $f7e7		JSR	TAPEH			; write tape header
>f725	24					.byte	$24			; makes next line BIT $18 so Cb is not changed
.f726					LAB_F726
.f726	18		clc			CLC				; flag ok
.f727					LAB_F727
.f727	60		rts			RTS
.f728					SAVING
.f728	a5 9d		lda $9d			LDA	MSGFLG			; get KERNAL message mode flag
.f72a	10 fb		bpl $f727		BPL	LAB_F727		; exit if control messages off
.f72c	a0 51		ldy #$51		LDY	#KM_SAVNG-KMSGTBL
.f72e	20 e6 f1	jsr $f1e6		JSR	KMSGSHOW		; display KERNAL I/O message
.f731	4c 59 f6	jmp $f659		JMP	FILENAME		; print file name and return
.f734					FUDTIM
.f734	a2 00		ldx #$00		LDX	#$00			; clear .X
.f736	e6 a2		inc $a2			INC	TIME+2			; increment jiffy low byte
.f738	d0 06		bne $f740		BNE	LAB_F740		; if no rollover skip the mid byte increment
.f73a	e6 a1		inc $a1			INC	TIME+1			; increment jiffy mid byte
.f73c	d0 02		bne $f740		BNE	LAB_F740		; if no rollover skip the high byte increment
.f73e	e6 a0		inc $a0			INC	TIME			; increment jiffy high byte
.f740					LAB_F740
.f740	38		sec			SEC				; set carry for subtract
.f741	a5 a2		lda $a2			LDA	TIME+2			; get jiffy clock low byte
.f743	e9 01		sbc #$01		SBC	#$01			; subtract $4F1A01 low byte
.f745	a5 a1		lda $a1			LDA	TIME+1			; get jiffy clock mid byte
.f747	e9 1a		sbc #$1a		SBC	#$1A			; subtract $4F1A01 mid byte
.f749	a5 a0		lda $a0			LDA	TIME			; get jiffy clock high byte
.f74b	e9 4f		sbc #$4f		SBC	#$4F			; subtract $4F1A01 high byte
.f74d	90 06		bcc $f755		BCC	LAB_F755		; branch if less than $4F1A01 jiffies
.f74f	86 a0		stx $a0			STX	TIME			; clear jiffies high byte
.f751	86 a1		stx $a1			STX	TIME+1			; clear jiffies mid byte
.f753	86 a2		stx $a2			STX	TIME+2			; clear jiffies low byte
.f755					LAB_F755
.f755	ad 2f 91	lda $912f		LDA	VIA2PA2			; get VIA 2 DRA, keyboard row, no handshake
.f758	cd 2f 91	cmp $912f		CMP	VIA2PA2			; compare with self
.f75b	d0 f8		bne $f755		BNE	LAB_F755		; loop if changing
.f75d	85 91		sta $91			STA	STKEY			; save VIA 2 DRA, keyboard row
.f75f	60		rts			RTS
.f760					FRDTIM
.f760	78		sei			SEI				; disable interrupts
.f761	a5 a2		lda $a2			LDA	TIME+2			; get jiffy clock low byte
.f763	a6 a1		ldx $a1			LDX	TIME+1			; get jiffy clock mid byte
.f765	a4 a0		ldy $a0			LDY	TIME			; get jiffy clock high byte
.f767					FSETTIM
.f767	78		sei			SEI				; disable interrupts
.f768	85 a2		sta $a2			STA	TIME+2			; save jiffy clock low byte
.f76a	86 a1		stx $a1			STX	TIME+1			; save jiffy clock mid byte
.f76c	84 a0		sty $a0			STY	TIME			; save jiffy clock high byte
.f76e	58		cli			CLI				; enable interrupts
.f76f	60		rts			RTS
.f770					FSTOP
.f770	a5 91		lda $91			LDA	STKEY			; get keyboard row
.f772	c9 fe		cmp #$fe		CMP	#$FE			; compare with r0 down
.f774	d0 07		bne $f77d		BNE	LAB_F77D		; branch if not just r0
.f776	08		php			PHP				; save status
.f777	20 cc ff	jsr $ffcc		JSR	CLRCHN			; close input and output channels
.f77a	85 c6		sta $c6			STA	NDX			; save keyboard buffer length
.f77c	28		plp			PLP				; restore status
.f77d					LAB_F77D
.f77d	60		rts			RTS
.f77e					FE_2MNYF
.f77e	a9 01		lda #$01		LDA	#$01			; too many files
>f780	2c					.byte	$2C			; makes next line BIT $02A9
.f781					FE_ALOPN
.f781	a9 02		lda #$02		LDA	#$02			; file already open
>f783	2c					.byte	$2C			; makes next line BIT $03A9
.f784					FE_NTOPN
.f784	a9 03		lda #$03		LDA	#$03			; file not open
>f786	2c					.byte	$2C			; makes next line BIT $04A9
.f787					FE_NTFND
.f787	a9 04		lda #$04		LDA	#$04			; file not found
>f789	2c					.byte	$2C			; makes next line BIT $05A9
.f78a					FE_DVNTP
.f78a	a9 05		lda #$05		LDA	#$05			; device not present
>f78c	2c					.byte	$2C			; makes next line BIT $06A9
.f78d					FE_NTINP
.f78d	a9 06		lda #$06		LDA	#$06			; not input file
>f78f	2c					.byte	$2C			; makes next line BIT $07A9
.f790					FE_NTOUT
.f790	a9 07		lda #$07		LDA	#$07			; not output file
>f792	2c					.byte	$2C			; makes next line BIT $08A9
.f793					FE_MISFN
.f793	a9 08		lda #$08		LDA	#$08			; missing file name
>f795	2c					.byte	$2C			; makes next line BIT $09A9
.f796					FE_ILDEV
.f796	a9 09		lda #$09		LDA	#$09			; illegal device number
.f798	48		pha			PHA				; save error #
.f799	20 cc ff	jsr $ffcc		JSR	CLRCHN			; close input and output channels
.f79c	a0 00		ldy #$00		LDY	#KM_IOERR-KMSGTBL
.f79e	24 9d		bit $9d			BIT	MSGFLG			; test KERNAL message mode flag
.f7a0	50 0a		bvc $f7ac		BVC	LAB_F7AC		; exit if error messages off
.f7a2	20 e6 f1	jsr $f1e6		JSR	KMSGSHOW		; display KERNAL I/O message
.f7a5	68		pla			PLA				; restore error #
.f7a6	48		pha			PHA				; copy error #
.f7a7	09 30		ora #$30		ORA	#'0'			; convert to ASCII
.f7a9	20 d2 ff	jsr $ffd2		JSR	CHROUT			; output character to channel
.f7ac					LAB_F7AC
.f7ac	68		pla			PLA				; pull error number
.f7ad	38		sec			SEC				; flag error
.f7ae	60		rts			RTS
.f7af					FAH
.f7af	a5 93		lda $93			LDA	VERCK			; get load/verify flag
.f7b1	48		pha			PHA				; save load/verify flag
.f7b2	20 c0 f8	jsr $f8c0		JSR	RDTPBLKS		; initiate tape read
.f7b5	68		pla			PLA				; restore load/verify flag
.f7b6	85 93		sta $93			STA	VERCK			; save load/verify flag
.f7b8	b0 2c		bcs $f7e6		BCS	LAB_F7E6		; exit if error
.f7ba	a0 00		ldy #$00		LDY	#$00			; clear index
.f7bc	b1 b2		lda ($b2),y		LDA	(TAPE1),Y		; read first byte from tape buffer
.f7be	c9 05		cmp #$05		CMP	#$05			; compare with logical end of the tape
.f7c0	f0 24		beq $f7e6		BEQ	LAB_F7E6		; exit if end of the tape
.f7c2	c9 01		cmp #$01		CMP	#$01			; compare with header for a relocatable program file
.f7c4	f0 08		beq $f7ce		BEQ	LAB_F7CE		; branch if program file header
.f7c6	c9 03		cmp #$03		CMP	#$03			; compare with header for a non relocatable program file
.f7c8	f0 04		beq $f7ce		BEQ	LAB_F7CE		; branch if program file header
.f7ca	c9 04		cmp #$04		CMP	#$04			; compare with data file header
.f7cc	d0 e1		bne $f7af		BNE	FAH			; if data file loop to find tape header
.f7ce					LAB_F7CE
.f7ce	aa		tax			TAX				; copy header type
.f7cf	24 9d		bit $9d			BIT	MSGFLG			; get KERNAL message mode flag
.f7d1	10 11		bpl $f7e4		BPL	LAB_F7E4		; exit if control messages off
.f7d3	a0 63		ldy #$63		LDY	#KM_FOUND-KMSGTBL
.f7d5	20 e6 f1	jsr $f1e6		JSR	KMSGSHOW		; display KERNAL I/O message
.f7d8	a0 05		ldy #$05		LDY	#$05			; index to tape filename
.f7da					LAB_F7DA
.f7da	b1 b2		lda ($b2),y		LDA	(TAPE1),Y		; get byte from tape buffer
.f7dc	20 d2 ff	jsr $ffd2		JSR	CHROUT			; output character to channel
.f7df	c8		iny			INY				; increment index
.f7e0	c0 15		cpy #$15		CPY	#$15			; compare with end+1
.f7e2	d0 f6		bne $f7da		BNE	LAB_F7DA		; loop if more to do
.f7e4					LAB_F7E4
.f7e4	18		clc			CLC				; flag no error
.f7e5	88		dey			DEY				; decrement index
.f7e6					LAB_F7E6
.f7e6	60		rts			RTS
.f7e7					TAPEH
.f7e7	85 9e		sta $9e			STA	PTR1			; save header type
.f7e9	20 4d f8	jsr $f84d		JSR	TPBUFA			; get tape buffer start pointer in .X.Y
.f7ec	90 5e		bcc $f84c		BCC	LAB_F84C		; exit if < $0200
.f7ee	a5 c2		lda $c2			LDA	STAL+1			; get I/O start address high byte
.f7f0	48		pha			PHA				; save it
.f7f1	a5 c1		lda $c1			LDA	STAL			; get I/O start address low byte
.f7f3	48		pha			PHA				; save it
.f7f4	a5 af		lda $af			LDA	EAL+1			; get tape end address high byte
.f7f6	48		pha			PHA				; save it
.f7f7	a5 ae		lda $ae			LDA	EAL			; get tape end address low byte
.f7f9	48		pha			PHA				; save it
.f7fa	a0 bf		ldy #$bf		LDY	#$BF			; index to header end
.f7fc	a9 20		lda #$20		LDA	#' '			; clear byte, [SPACE]
.f7fe					LAB_F7FE
.f7fe	91 b2		sta ($b2),y		STA	(TAPE1),Y		; clear header byte
.f800	88		dey			DEY				; decrement index
.f801	d0 fb		bne $f7fe		BNE	LAB_F7FE		; loop if more to do
.f803	a5 9e		lda $9e			LDA	PTR1			; get header type back
.f805	91 b2		sta ($b2),y		STA	(TAPE1),Y		; write to header
.f807	c8		iny			INY				; increment index
.f808	a5 c1		lda $c1			LDA	STAL			; get I/O start address low byte
.f80a	91 b2		sta ($b2),y		STA	(TAPE1),Y		; write to header
.f80c	c8		iny			INY				; increment index
.f80d	a5 c2		lda $c2			LDA	STAL+1			; get I/O start address high byte
.f80f	91 b2		sta ($b2),y		STA	(TAPE1),Y		; write to header
.f811	c8		iny			INY				; increment index
.f812	a5 ae		lda $ae			LDA	EAL			; get tape end address low byte
.f814	91 b2		sta ($b2),y		STA	(TAPE1),Y		; write to header
.f816	c8		iny			INY				; increment index
.f817	a5 af		lda $af			LDA	EAL+1			; get tape end address high byte
.f819	91 b2		sta ($b2),y		STA	(TAPE1),Y		; write to header
.f81b	c8		iny			INY				; increment index
.f81c	84 9f		sty $9f			STY	PTR2			; save index
.f81e	a0 00		ldy #$00		LDY	#$00			; clear .Y
.f820	84 9e		sty $9e			STY	PTR1			; clear name index
.f822					LAB_F822
.f822	a4 9e		ldy $9e			LDY	PTR1			; get name index
.f824	c4 b7		cpy $b7			CPY	FNLEN			; compare with file name length
.f826	f0 0c		beq $f834		BEQ	LAB_F834		; exit loop if all done
.f828	b1 bb		lda ($bb),y		LDA	(FNADR),Y		; get file name byte
.f82a	a4 9f		ldy $9f			LDY	PTR2			; get buffer index
.f82c	91 b2		sta ($b2),y		STA	(TAPE1),Y		; save file name byte to buffer
.f82e	e6 9e		inc $9e			INC	PTR1			; increment file name index
.f830	e6 9f		inc $9f			INC	PTR2			; increment tape buffer index
.f832	d0 ee		bne $f822		BNE	LAB_F822		; loop, branch always
.f834					LAB_F834
.f834	20 54 f8	jsr $f854		JSR	LDAD1			; set tape buffer start and end pointers
.f837	a9 69		lda #$69		LDA	#$69			; set write lead cycle count
.f839	85 ab		sta $ab			STA	RIPRTY			; save write lead cycle count
.f83b	20 ea f8	jsr $f8ea		JSR	LAB_F8EA		; do tape write, no cycle count set
.f83e	a8		tay			TAY				;.
.f83f	68		pla			PLA				; pull tape end address low byte
.f840	85 ae		sta $ae			STA	EAL			; restore it
.f842	68		pla			PLA				; pull tape end address high byte
.f843	85 af		sta $af			STA	EAL+1			; restore it
.f845	68		pla			PLA				; pull I/O start address low byte
.f846	85 c1		sta $c1			STA	STAL			; restore it
.f848	68		pla			PLA				; pull I/O start address high byte
.f849	85 c2		sta $c2			STA	STAL+1			; restore it
.f84b	98		tya			TYA				;.
.f84c					LAB_F84C
.f84c	60		rts			RTS
.f84d					TPBUFA
.f84d	a6 b2		ldx $b2			LDX	TAPE1			; get tape buffer start pointer low byte
.f84f	a4 b3		ldy $b3			LDY	TAPE1+1			; get tape buffer start pointer high byte
.f851	c0 02		cpy #$02		CPY	#$02			; compare high byte with $02xx
.f853	60		rts			RTS
.f854					LDAD1
.f854	20 4d f8	jsr $f84d		JSR	TPBUFA			; get tape buffer start pointer in .X.Y
.f857	8a		txa			TXA				; copy tape buffer start pointer low byte
.f858	85 c1		sta $c1			STA	STAL			; save as I/O address low byte
.f85a	18		clc			CLC				; clear carry for add
.f85b	69 c0		adc #$c0		ADC	#$C0			; add buffer length low byte
.f85d	85 ae		sta $ae			STA	EAL			; save tape buffer end pointer low byte
.f85f	98		tya			TYA				; copy tape buffer start pointer high byte
.f860	85 c2		sta $c2			STA	STAL+1			; save as I/O address high byte
.f862	69 00		adc #$00		ADC	#$00			; add buffer length high byte
.f864	85 af		sta $af			STA	EAL+1			; save tape buffer end pointer high byte
.f866	60		rts			RTS
.f867					FNDHDR
.f867	20 af f7	jsr $f7af		JSR	FAH			; find tape header, exit with header in buffer
.f86a	b0 1d		bcs $f889		BCS	LAB_F889		; just exit if error
.f86c	a0 05		ldy #$05		LDY	#$05			; index to name
.f86e	84 9f		sty $9f			STY	PTR2			; save as tape buffer index
.f870	a0 00		ldy #$00		LDY	#$00			; clear .Y
.f872	84 9e		sty $9e			STY	PTR1			; save as name buffer index
.f874					LAB_F874
.f874	c4 b7		cpy $b7			CPY	FNLEN			; compare with file name length
.f876	f0 10		beq $f888		BEQ	LAB_F888		; ok exit if match
.f878	b1 bb		lda ($bb),y		LDA	(FNADR),Y		; get file name byte
.f87a	a4 9f		ldy $9f			LDY	PTR2			; get index to tape buffer
.f87c	d1 b2		cmp ($b2),y		CMP	(TAPE1),Y		; compare with tape header name byte
.f87e	d0 e7		bne $f867		BNE	FNDHDR			; if no match go get next header
.f880	e6 9e		inc $9e			INC	PTR1			; else increment name buffer index
.f882	e6 9f		inc $9f			INC	PTR2			; increment tape buffer index
.f884	a4 9e		ldy $9e			LDY	PTR1			; get name buffer index
.f886	d0 ec		bne $f874		BNE	LAB_F874		; loop, branch always
.f888					LAB_F888
.f888	18		clc			CLC				; flag ok
.f889					LAB_F889
.f889	60		rts			RTS
.f88a					JTP20
.f88a	20 4d f8	jsr $f84d		JSR	TPBUFA			; get tape buffer start pointer in .X.Y
.f88d	e6 a6		inc $a6			INC	BUFPNT			; increment tape buffer index
.f88f	a4 a6		ldy $a6			LDY	BUFPNT			; get tape buffer index
.f891	c0 c0		cpy #$c0		CPY	#$C0			; compare with buffer length
.f893	60		rts			RTS
.f894					CSTEL
.f894	20 ab f8	jsr $f8ab		JSR	CS10			; return cassette sense in Zb
.f897	f0 1c		beq $f8b5		BEQ	LAB_F8B5		; exit if switch closed
.f899	a0 1b		ldy #$1b		LDY	#KM_PRPLY-KMSGTBL
.f89b					LAB_F89B
.f89b	20 e6 f1	jsr $f1e6		JSR	KMSGSHOW		; display KERNAL I/O message
.f89e					LAB_F89E
.f89e	20 4b f9	jsr $f94b		JSR	TSTOP			; scan stop key and flag abort if pressed
.f8a1	20 ab f8	jsr $f8ab		JSR	CS10			; return cassette sense in Zb
.f8a4	d0 f8		bne $f89e		BNE	LAB_F89E		; loop if cassette switch open
.f8a6	a0 6a		ldy #$6a		LDY	#KM_OK-KMSGTBL
.f8a8	4c e6 f1	jmp $f1e6		JMP	KMSGSHOW		; display KERNAL I/O message and return
.f8ab					CS10
.f8ab	a9 40		lda #$40		LDA	#$40			; mask for cassette switch
.f8ad	2c 1f 91	bit $911f		BIT	VIA1PA2			; test VIA 1 DRA, no handshake
.f8b0	d0 03		bne $f8b5		BNE	LAB_F8B5		; branch if cassette sense high
.f8b2	2c 1f 91	bit $911f		BIT	VIA1PA2			; test VIA 1 DRA again
.f8b5					LAB_F8B5
.f8b5	18		clc			CLC
.f8b6	60		rts			RTS
.f8b7					CSTE2
.f8b7	20 ab f8	jsr $f8ab		JSR	CS10			; return cassette sense in Zb
.f8ba	f0 f9		beq $f8b5		BEQ	LAB_F8B5		; exit if switch closed
.f8bc	a0 2e		ldy #$2e		LDY	#KM_RECPY-KMSGTBL
.f8be	d0 db		bne $f89b		BNE	LAB_F89B		; display message and wait for switch, branch always
.f8c0					RDTPBLKS
.f8c0	a9 00		lda #$00		LDA	#$00			; clear .A
.f8c2	85 90		sta $90			STA	STATUS			; clear I/O status byte
.f8c4	85 93		sta $93			STA	VERCK			; clear the load/verify flag
.f8c6	20 54 f8	jsr $f854		JSR	LDAD1			; set tape buffer start and end pointers
.f8c9					RBLK
.f8c9	20 94 f8	jsr $f894		JSR	CSTEL			; wait for PLAY
.f8cc	b0 1f		bcs $f8ed		BCS	LAB_F8ED		; exit if [STOP] was pressed, uses further BCS at target
.f8ce	78		sei			SEI				; disable interrupts
.f8cf	a9 00		lda #$00		LDA	#$00			; clear .A
.f8d1	85 aa		sta $aa			STA	RIDATA			; clear tape input status
.f8d3	85 b4		sta $b4			STA	BITTS			; clear tape read ready
.f8d5	85 b0		sta $b0			STA	CMP0			; clear tape timing constant min byte
.f8d7	85 9e		sta $9e			STA	PTR1			; clear tape pass 1 error log/char buffer
.f8d9	85 9f		sta $9f			STA	PTR2			; clear tape pass 2 error log corrected
.f8db	85 9c		sta $9c			STA	DPSW			; clear tape dipole switch
.f8dd	a9 82		lda #$82		LDA	#$82			; enable CA1 interrupt
.f8df	a2 0e		ldx #$0e		LDX	#$0E			; set index for tape read vector
.f8e1	d0 11		bne $f8f4		BNE	TAPE			; go do tape read/write, branch always
.f8e3					WBLK
.f8e3	20 54 f8	jsr $f854		JSR	LDAD1			; set tape buffer start and end pointers
.f8e6					LAB_F8E6
.f8e6	a9 14		lda #$14		LDA	#$14			; set write lead cycle count
.f8e8	85 ab		sta $ab			STA	RIPRTY			; save write lead cycle count
.f8ea					LAB_F8EA
.f8ea	20 b7 f8	jsr $f8b7		JSR	CSTE2			; wait for PLAY/RECORD
.f8ed					LAB_F8ED
.f8ed	b0 68		bcs $f957		BCS	LAB_F957		; if STOPped clear save IRQ address and exit
.f8ef	78		sei			SEI				; disable interrupts
.f8f0	a9 a0		lda #$a0		LDA	#$A0			; enable VIA 2 T2 interrupt
.f8f2	a2 08		ldx #$08		LDX	#$08			; set index for tape write tape leader vector
.f8f4					TAPE
.f8f4	a0 7f		ldy #$7f		LDY	#$7F			; disable all interrupts
.f8f6	8c 2e 91	sty $912e		STY	VIA2IER			; set VIA 2 IER, disable interrupts
.f8f9	8d 2e 91	sta $912e		STA	VIA2IER			; set VIA 2 IER, enable interrupts according to .A
.f8fc	20 60 f1	jsr $f160		JSR	RSPAUSE			; check RS-232 bus idle
.f8ff	ad 14 03	lda $0314		LDA	CINV			; get IRQ vector low byte
.f902	8d 9f 02	sta $029f		STA	IRQTMP			; save IRQ vector low byte
.f905	ad 15 03	lda $0315		LDA	CINV+1			; get IRQ vector high byte
.f908	8d a0 02	sta $02a0		STA	IRQTMP+1		; save IRQ vector high byte
.f90b	20 fb fc	jsr $fcfb		JSR	LAB_FCFB		; set tape vector
.f90e	a9 02		lda #$02		LDA	#$02			; set copies remaining. the first copy is the load copy, the
.f910	85 be		sta $be			STA	FSBLK			; save copies remaining
.f912	20 db fb	jsr $fbdb		JSR	NEWCH			; new tape byte setup
.f915	ad 1c 91	lda $911c		LDA	VIA1PCR			; get VIA 1 PCR
.f918	29 fd		and #$fd		AND	#$FD			; CA2 low, turn on tape motor
.f91a	09 0c		ora #$0c		ORA	#$0C			; manual output mode
.f91c	8d 1c 91	sta $911c		STA	VIA1PCR			; set VIA 1 PCR
.f91f	85 c0		sta $c0			STA	CAS1			; set tape motor interlock
.f921	a2 ff		ldx #$ff		LDX	#$FF			; outer loop count
.f923					LAB_F923
.f923	a0 ff		ldy #$ff		LDY	#$FF			; inner loop count
.f925					LAB_F925
.f925	88		dey			DEY				; decrement inner loop count
.f926	d0 fd		bne $f925		BNE	LAB_F925		; loop if more to do
.f928	ca		dex			DEX				; decrement outer loop count
.f929	d0 f8		bne $f923		BNE	LAB_F923		; loop if more to do
.f92b	8d 29 91	sta $9129		STA	VIA2T2CH		; set VIA 2 T2C_h
.f92e	58		cli			CLI				; enable tape interrupts
.f92f					LAB_F92F
.f92f	ad a0 02	lda $02a0		LDA	IRQTMP+1		; get saved IRQ high byte
.f932	cd 15 03	cmp $0315		CMP	CINV+1			; compare with the current IRQ high byte
.f935	18		clc			CLC				; flag ok
.f936	f0 1f		beq $f957		BEQ	LAB_F957		; if tape write done go clear saved IRQ address and exit
.f938	20 4b f9	jsr $f94b		JSR	TSTOP			; scan stop key and flag abort if pressed
.f93b	ad 2d 91	lda $912d		LDA	VIA2IFR			; get VIA 2 IFR
.f93e	29 40		and #$40		AND	#$40			; mask T1 interrupt
.f940	f0 ed		beq $f92f		BEQ	LAB_F92F		; loop if not T1 interrupt
.f942	ad 14 91	lda $9114		LDA	VIA1T1CL		; get VIA 1 T1C_l, clear T1 interrupt
.f945	20 34 f7	jsr $f734		JSR	FUDTIM			; increment the real time clock
.f948	4c 2f f9	jmp $f92f		JMP	LAB_F92F		; loop
.f94b					TSTOP
.f94b	20 e1 ff	jsr $ffe1		JSR	STOP			; scan stop key
.f94e	18		clc			CLC				; flag no stop
.f94f	d0 0b		bne $f95c		BNE	LAB_F95C		; exit if no stop
.f951	20 cf fc	jsr $fccf		JSR	TNIF			; restore everything for [STOP]
.f954	38		sec			SEC				; flag stopped
.f955	68		pla			PLA				; dump return address low byte
.f956	68		pla			PLA				; dump return address high byte
.f957					LAB_F957
.f957	a9 00		lda #$00		LDA	#$00			; clear .A
.f959	8d a0 02	sta $02a0		STA	IRQTMP+1		; clear saved IRQ address high byte
.f95c					LAB_F95C
.f95c	60		rts			RTS
.f95d					STT1
.f95d	86 b1		stx $b1			STX	CMP0+1			; save tape timing constant max byte
.f95f	a5 b0		lda $b0			LDA	CMP0			; get tape timing constant min byte
.f961	0a		asl a			ASL				; *2
.f962	0a		asl a			ASL				; *4
.f963	18		clc			CLC				; clear carry for add
.f964	65 b0		adc $b0			ADC	CMP0			; add tape timing constant min byte *5
.f966	18		clc			CLC				; clear carry for add
.f967	65 b1		adc $b1			ADC	CMP0+1			; add tape timing constant max byte
.f969	85 b1		sta $b1			STA	CMP0+1			; save tape timing constant max byte
.f96b	a9 00		lda #$00		LDA	#$00			;.
.f96d	24 b0		bit $b0			BIT	CMP0			; test tape timing constant min byte
.f96f	30 01		bmi $f972		BMI	LAB_F972		; branch if b7 set
.f971	2a		rol a			ROL				; else shift carry into ??
.f972					LAB_F972
.f972	06 b1		asl $b1			ASL	CMP0+1			; shift tape timing constant max byte
.f974	2a		rol a			ROL				;.
.f975	06 b1		asl $b1			ASL	CMP0+1			; shift tape timing constant max byte
.f977	2a		rol a			ROL				;.
.f978	aa		tax			TAX				;.
.f979					LAB_F979
.f979	ad 28 91	lda $9128		LDA	VIA2T2CL		; get VIA 2 T2C_l
.f97c	c9 15		cmp #$15		CMP	#$15			;.compare with ??
.f97e	90 f9		bcc $f979		BCC	LAB_F979		; loop if less
.f980	65 b1		adc $b1			ADC	CMP0+1			; add tape timing constant max byte
.f982	8d 24 91	sta $9124		STA	VIA2T1CL		; set VIA 2 T1C_l
.f985	8a		txa			TXA				;.
.f986	6d 29 91	adc $9129		ADC	VIA2T2CH		; add VIA 2 T2C_h
.f989	8d 25 91	sta $9125		STA	VIA2T1CH		; set VIA 2 T1C_h
.f98c	58		cli			CLI				; enable interrupts
.f98d	60		rts			RTS
.f98e					READT
.f98e	ae 29 91	ldx $9129		LDX	VIA2T2CH		; get VIA 2 T2C_h
.f991	a0 ff		ldy #$ff		LDY	#$FF			;.set $FF
.f993	98		tya			TYA				; .A = $FF
.f994	ed 28 91	sbc $9128		SBC	VIA2T2CL		; subtract VIA 2 T2C_l
.f997	ec 29 91	cpx $9129		CPX	VIA2T2CH		; compare VIA 2 T2C_h with previous
.f99a	d0 f2		bne $f98e		BNE	READT			; loop if timer low byte rolled over
.f99c	86 b1		stx $b1			STX	CMP0+1			; save tape timing constant max byte
.f99e	aa		tax			TAX				;.copy $FF - T2C_l
.f99f	8c 28 91	sty $9128		STY	VIA2T2CL		; set VIA 2 T2C_l to $FF
.f9a2	8c 29 91	sty $9129		STY	VIA2T2CH		; set VIA 2 T2C_h to $FF
.f9a5	98		tya			TYA				;.$FF
.f9a6	e5 b1		sbc $b1			SBC	CMP0+1			; subtract tape timing constant max byte
.f9a8	86 b1		stx $b1			STX	CMP0+1			; save tape timing constant max byte
.f9aa	4a		lsr a			LSR				; .A = $FF - T2C_h >> 1
.f9ab	66 b1		ror $b1			ROR	CMP0+1			; shift tape timing constant max byte
.f9ad	4a		lsr a			LSR				; .A = $FF - T2C_h >> 1
.f9ae	66 b1		ror $b1			ROR	CMP0+1			; shift tape timing constant max byte
.f9b0	a5 b0		lda $b0			LDA	CMP0			; get tape timing constant min byte
.f9b2	18		clc			CLC				; clear carry for add
.f9b3	69 3c		adc #$3c		ADC	#$3C			;.
.f9b5	2c 21 91	bit $9121		BIT	VIA2PA1			; test VIA 2 DRA, keyboard row
.f9b8	c5 b1		cmp $b1			CMP	CMP0+1			; compare with tape timing constant max byte
.f9ba	b0 4a		bcs $fa06		BCS	LAB_FA06		;.branch if min + $3C >= ($FFFF - T2C) >> 2
.f9bc	a6 9c		ldx $9c			LDX	DPSW			; get tape byte received flag
.f9be	f0 03		beq $f9c3		BEQ	LAB_F9C3		; branch if not byte received
.f9c0	4c ad fa	jmp $faad		JMP	TPSTORE			;.store tape character
.f9c3					LAB_F9C3
.f9c3	a6 a3		ldx $a3			LDX	PCNTR			; get tape bit count
.f9c5	30 1b		bmi $f9e2		BMI	LAB_F9E2		; branch if character complete
.f9c7	a2 00		ldx #$00		LDX	#$00			; clear .X
.f9c9	69 30		adc #$30		ADC	#$30			;.
.f9cb	65 b0		adc $b0			ADC	CMP0			; add tape timing constant min byte
.f9cd	c5 b1		cmp $b1			CMP	CMP0+1			; compare with tape timing constant max byte
.f9cf	b0 1c		bcs $f9ed		BCS	LAB_F9ED		;.
.f9d1	e8		inx			INX				;.
.f9d2	69 26		adc #$26		ADC	#$26			;.
.f9d4	65 b0		adc $b0			ADC	CMP0			; add tape timing constant min byte
.f9d6	c5 b1		cmp $b1			CMP	CMP0+1			; compare with tape timing constant max byte
.f9d8	b0 17		bcs $f9f1		BCS	LAB_F9F1		;.
.f9da	69 2c		adc #$2c		ADC	#$2C			;.
.f9dc	65 b0		adc $b0			ADC	CMP0			; add tape timing constant min byte
.f9de	c5 b1		cmp $b1			CMP	CMP0+1			; compare with tape timing constant max byte
.f9e0	90 03		bcc $f9e5		BCC	LAB_F9E5		;.
.f9e2					LAB_F9E2
.f9e2	4c 60 fa	jmp $fa60		JMP	LAB_FA60		;.
.f9e5					LAB_F9E5
.f9e5	a5 b4		lda $b4			LDA	BITTS			; get tape read ready
.f9e7	f0 1d		beq $fa06		BEQ	LAB_FA06		; branch if zero
.f9e9	85 a8		sta $a8			STA	BITCI			; save tape long word marker
.f9eb	d0 19		bne $fa06		BNE	LAB_FA06		; branch always
.f9ed					LAB_F9ED
.f9ed	e6 a9		inc $a9			INC	RINONE			; increment tape dipole count
.f9ef	b0 02		bcs $f9f3		BCS	LAB_F9F3		;.
.f9f1					LAB_F9F1
.f9f1	c6 a9		dec $a9			DEC	RINONE			; decrement tape dipole count
.f9f3					LAB_F9F3
.f9f3	38		sec			SEC				;.
.f9f4	e9 13		sbc #$13		SBC	#$13			;.
.f9f6	e5 b1		sbc $b1			SBC	CMP0+1			; subtract tape timing constant max byte
.f9f8	65 92		adc $92			ADC	SVXT			; add timing constant for tape
.f9fa	85 92		sta $92			STA	SVXT			; save timing constant for tape
.f9fc	a5 a4		lda $a4			LDA	FIRT			; get tape bit cycle phase
.f9fe	49 01		eor #$01		EOR	#$01			; toggle b0
.fa00	85 a4		sta $a4			STA	FIRT			; save tape bit cycle phase
.fa02	f0 21		beq $fa25		BEQ	LAB_FA25		; if first cycle complete go to second cycle
.fa04	86 d7		stx $d7			STX	ASCII			; save bit value
.fa06					LAB_FA06
.fa06	a5 b4		lda $b4			LDA	BITTS			; get tape read ready
.fa08	f0 18		beq $fa22		BEQ	LAB_FA22		; exit if zero
.fa0a	2c 2d 91	bit $912d		BIT	VIA2IFR			; test get 2 IFR
.fa0d	50 13		bvc $fa22		BVC	LAB_FA22		; exit if no T1 interrupt
.fa0f	a9 00		lda #$00		LDA	#$00			; clear .A
.fa11	85 a4		sta $a4			STA	FIRT			; clear tape bit cycle phase
.fa13	a5 a3		lda $a3			LDA	PCNTR			; get tape bit count
.fa15	10 30		bpl $fa47		BPL	LAB_FA47		; branch of more bits
.fa17	30 c9		bmi $f9e2		BMI	LAB_F9E2		; branch always
.fa19					LAB_FA19
.fa19	a2 a6		ldx #$a6		LDX	#$A6			; set timing max byte
.fa1b	20 5d f9	jsr $f95d		JSR	STT1			; set timing
.fa1e	a5 9b		lda $9b			LDA	PRTY			; get tape character parity
.fa20	d0 c3		bne $f9e5		BNE	LAB_F9E5		;.
.fa22					LAB_FA22
.fa22	4c 56 ff	jmp $ff56		JMP	RRTI			; restore registers and exit interrupt
.fa25					LAB_FA25
.fa25	a5 92		lda $92			LDA	SVXT			; get timing constant for tape
.fa27	f0 07		beq $fa30		BEQ	LAB_FA30		;.
.fa29	30 03		bmi $fa2e		BMI	LAB_FA2E		;.
.fa2b	c6 b0		dec $b0			DEC	CMP0			; decrement tape timing constant min byte
>fa2d	2c					.byte	$2C			; makes next line BIT $B0E6
.fa2e					LAB_FA2E
.fa2e	e6 b0		inc $b0			INC	CMP0			; increment tape timing constant min byte
.fa30					LAB_FA30
.fa30	a9 00		lda #$00		LDA	#$00			; clear .A
.fa32	85 92		sta $92			STA	SVXT			; clear timing constant for tape
.fa34	e4 d7		cpx $d7			CPX	ASCII			;.
.fa36	d0 0f		bne $fa47		BNE	LAB_FA47		;.
.fa38	8a		txa			TXA				;.
.fa39	d0 aa		bne $f9e5		BNE	LAB_F9E5		;.
.fa3b	a5 a9		lda $a9			LDA	RINONE			; get tape dipole count
.fa3d	30 c7		bmi $fa06		BMI	LAB_FA06		;.
.fa3f	c9 10		cmp #$10		CMP	#$10			;.
.fa41	90 c3		bcc $fa06		BCC	LAB_FA06		;.
.fa43	85 96		sta $96			STA	SYNO			; save leader length
.fa45	b0 bf		bcs $fa06		BCS	LAB_FA06		; branch always
.fa47					LAB_FA47
.fa47	8a		txa			TXA
.fa48	45 9b		eor $9b			EOR	PRTY			; XOR with tape character parity
.fa4a	85 9b		sta $9b			STA	PRTY			; save tape character parity
.fa4c	a5 b4		lda $b4			LDA	BITTS			; get tape read ready
.fa4e	f0 d2		beq $fa22		BEQ	LAB_FA22		; if zero exit interrupt
.fa50	c6 a3		dec $a3			DEC	PCNTR			; decrement tape bit count
.fa52	30 c5		bmi $fa19		BMI	LAB_FA19		; branch if character complete
.fa54	46 d7		lsr $d7			LSR	ASCII			; shift dipole into Cb
.fa56	66 bf		ror $bf			ROR	MYCH			; rotate Cb into tape read byte
.fa58	a2 da		ldx #$da		LDX	#$DA			; set timing max byte
.fa5a	20 5d f9	jsr $f95d		JSR	STT1			; set timing
.fa5d	4c 56 ff	jmp $ff56		JMP	RRTI			; restore registers and exit interrupt
.fa60					LAB_FA60
.fa60	a5 96		lda $96			LDA	SYNO			; get leader length
.fa62	f0 04		beq $fa68		BEQ	LAB_FA68		; branch if no block
.fa64	a5 b4		lda $b4			LDA	BITTS			; get tape read ready
.fa66	f0 04		beq $fa6c		BEQ	LAB_FA6C		;.
.fa68					LAB_FA68
.fa68	a5 a3		lda $a3			LDA	PCNTR			; get tape bit count
.fa6a	10 85		bpl $f9f1		BPL	LAB_F9F1		; branch if more bits
.fa6c					LAB_FA6C
.fa6c	46 b1		lsr $b1			LSR	CMP0+1			; shift tape timing constant max byte
.fa6e	a9 93		lda #$93		LDA	#$93			;.
.fa70	38		sec			SEC				;.
.fa71	e5 b1		sbc $b1			SBC	CMP0+1			; subtract tape timing constant max byte
.fa73	65 b0		adc $b0			ADC	CMP0			; add tape timing constant min byte
.fa75	0a		asl a			ASL				;.
.fa76	aa		tax			TAX				; copy timing high byte
.fa77	20 5d f9	jsr $f95d		JSR	STT1			; set timing
.fa7a	e6 9c		inc $9c			INC	DPSW			; increment tape dipole switch/byte received flag
.fa7c	a5 b4		lda $b4			LDA	BITTS			; get tape read ready
.fa7e	d0 11		bne $fa91		BNE	LAB_FA91		;.
.fa80	a5 96		lda $96			LDA	SYNO			; get leader length
.fa82	f0 26		beq $faaa		BEQ	LAB_FAAA		; branch if no block
.fa84	85 a8		sta $a8			STA	BITCI			; save tape long word marker
.fa86	a9 00		lda #$00		LDA	#$00			; clear .A
.fa88	85 96		sta $96			STA	SYNO			; clear leader length
.fa8a	a9 c0		lda #$c0		LDA	#$C0			; enable T1 interrupt
.fa8c	8d 2e 91	sta $912e		STA	VIA2IER			; set VIA 2 IER
.fa8f	85 b4		sta $b4			STA	BITTS			; save tape read ready
.fa91					LAB_FA91
.fa91	a5 96		lda $96			LDA	SYNO			; get leader length
.fa93	85 b5		sta $b5			STA	NXTBIT			;.
.fa95	f0 09		beq $faa0		BEQ	LAB_FAA0		;.
.fa97	a9 00		lda #$00		LDA	#$00			; clear .A
.fa99	85 b4		sta $b4			STA	BITTS			; save tape read ready
.fa9b	a9 40		lda #$40		LDA	#$40			; disable T1 interrupt
.fa9d	8d 2e 91	sta $912e		STA	VIA2IER			; set VIA 2 IER
.faa0					LAB_FAA0
.faa0	a5 bf		lda $bf			LDA	MYCH			; get tape read byte
.faa2	85 bd		sta $bd			STA	ROPRTY			; save tape byte read
.faa4	a5 a8		lda $a8			LDA	BITCI			; get tape error flags
.faa6	05 a9		ora $a9			ORA	RINONE			;.
.faa8	85 b6		sta $b6			STA	RODATA			; save tape read errors
.faaa					LAB_FAAA
.faaa	4c 56 ff	jmp $ff56		JMP	RRTI			; restore registers and exit interrupt
.faad					TPSTORE
.faad	20 db fb	jsr $fbdb		JSR	NEWCH			; new tape byte setup
.fab0	85 9c		sta $9c			STA	DPSW			; clear tape dipole switch/byte received flag
.fab2	a2 da		ldx #$da		LDX	#$DA			; set timing max byte
.fab4	20 5d f9	jsr $f95d		JSR	STT1			; set timing
.fab7	a5 be		lda $be			LDA	FSBLK			; get tape copies remaining
.fab9	f0 02		beq $fabd		BEQ	LAB_FABD		; branch if all copies done
.fabb	85 a7		sta $a7			STA	INBIT			; save tape read block count
.fabd					LAB_FABD
.fabd	a9 0f		lda #$0f		LDA	#$0F			; set block countdown bits
.fabf	24 aa		bit $aa			BIT	RIDATA			; mask from tape input status
.fac1	10 17		bpl $fada		BPL	LAB_FADA		; branch in first block has been loaded
.fac3	a5 b5		lda $b5			LDA	NXTBIT			;.
.fac5	d0 0c		bne $fad3		BNE	LAB_FAD3		;.
.fac7	a6 be		ldx $be			LDX	FSBLK			; get tape copies remaining
.fac9	ca		dex			DEX				; decrement copies remaining
.faca	d0 0b		bne $fad7		BNE	LAB_FAD7		; if copies remaining restore registers and exit interrupt
.facc	a9 08		lda #$08		LDA	#$08			; set long block bit
.face	20 6a fe	jsr $fe6a		JSR	ORIOST			; OR into I/O status byte
.fad1	d0 04		bne $fad7		BNE	LAB_FAD7		; restore registers and exit interrupt, branch always
.fad3					LAB_FAD3
.fad3	a9 00		lda #$00		LDA	#$00			; clear .A
.fad5	85 aa		sta $aa			STA	RIDATA			; clear tape input status flags
.fad7					LAB_FAD7
.fad7	4c 56 ff	jmp $ff56		JMP	RRTI			; restore registers and exit interrupt
.fada					LAB_FADA
.fada	70 31		bvs $fb0d		BVS	LAB_FB0D		; branch if valid data byte received
.fadc	d0 18		bne $faf6		BNE	LAB_FAF6		; branch if block countdown bytes received
.fade	a5 b5		lda $b5			LDA	NXTBIT			;.
.fae0	d0 f5		bne $fad7		BNE	LAB_FAD7		;.
.fae2	a5 b6		lda $b6			LDA	RODATA			; get tape read errors
.fae4	d0 f1		bne $fad7		BNE	LAB_FAD7		; if errors then exit interrupt
.fae6	a5 a7		lda $a7			LDA	INBIT			; get tape write leader count
.fae8	4a		lsr a			LSR				; shift b0 into Cb
.fae9	a5 bd		lda $bd			LDA	ROPRTY			; get tape write byte
.faeb	30 03		bmi $faf0		BMI	LAB_FAF0		; branch if b7 set
.faed	90 18		bcc $fb07		BCC	LAB_FB07		;.
.faef	18		clc			CLC				;.
.faf0					LAB_FAF0
.faf0	b0 15		bcs $fb07		BCS	LAB_FB07		;.
.faf2	29 0f		and #$0f		AND	#$0F			; mask block countdown and first block flags
.faf4	85 aa		sta $aa			STA	RIDATA			; clear tape input status flags
.faf6					LAB_FAF6
.faf6	c6 aa		dec $aa			DEC	RIDATA			; decrement block countdown
.faf8	d0 dd		bne $fad7		BNE	LAB_FAD7		; exit if block countdown bytes received
.fafa	a9 40		lda #$40		LDA	#$40			; set valid block countdown
.fafc	85 aa		sta $aa			STA	RIDATA			; set tape input status flags
.fafe	20 d2 fb	jsr $fbd2		JSR	RD300			; copy I/O start address to buffer address
.fb01	a9 00		lda #$00		LDA	#$00			; clear .A
.fb03	85 ab		sta $ab			STA	RIPRTY			; clear tape read checksum
.fb05	f0 d0		beq $fad7		BEQ	LAB_FAD7		; exit interrupt always
.fb07					LAB_FB07
.fb07	a9 80		lda #$80		LDA	#$80			; set first block loaded
.fb09	85 aa		sta $aa			STA	RIDATA			; save tape input status flags
.fb0b	d0 ca		bne $fad7		BNE	LAB_FAD7		; restore registers and exit interrupt, branch always
.fb0d					LAB_FB0D
.fb0d	a5 b5		lda $b5			LDA	NXTBIT			;.
.fb0f	f0 0a		beq $fb1b		BEQ	LAB_FB1B		;.
.fb11	a9 04		lda #$04		LDA	#$04			; set short block bit
.fb13	20 6a fe	jsr $fe6a		JSR	ORIOST			; OR into I/O status byte
.fb16	a9 00		lda #$00		LDA	#$00			;.
.fb18	4c 97 fb	jmp $fb97		JMP	LAB_FB97		;.
.fb1b					LAB_FB1B
.fb1b	20 11 fd	jsr $fd11		JSR	VPRTY			; check read/write pointer, return Cb = 1 if pointer >= end
.fb1e	90 03		bcc $fb23		BCC	LAB_FB23		; branch if not at end
.fb20	4c 95 fb	jmp $fb95		JMP	LAB_FB95		;.
.fb23					LAB_FB23
.fb23	a6 a7		ldx $a7			LDX	INBIT			; get tape write leader count
.fb25	ca		dex			DEX				; decrement count
.fb26	f0 2d		beq $fb55		BEQ	LAB_FB55		; branch if all blocks loaded
.fb28	a5 93		lda $93			LDA	VERCK			; get load/verify flag
.fb2a	f0 0c		beq $fb38		BEQ	LAB_FB38		; branch if load
.fb2c	a0 00		ldy #$00		LDY	#$00			; clear index
.fb2e	a5 bd		lda $bd			LDA	ROPRTY			;.get tape byte read
.fb30	d1 ac		cmp ($ac),y		CMP	(SAL),Y			; compare with byte in buffer
.fb32	f0 04		beq $fb38		BEQ	LAB_FB38		; branch if equal
.fb34	a9 01		lda #$01		LDA	#$01			; set read error
.fb36	85 b6		sta $b6			STA	RODATA			; save read errors
.fb38					LAB_FB38
.fb38	a5 b6		lda $b6			LDA	RODATA			; get read errors
.fb3a	f0 4b		beq $fb87		BEQ	LAB_FB87		; branch if no error
.fb3c	a2 3d		ldx #$3d		LDX	#$3D			; maximum pass 1 errors
.fb3e	e4 9e		cpx $9e			CPX	PTR1			; compare with tape pass 1 error index
.fb40	90 3e		bcc $fb80		BCC	LAB_FB80		; branch if space
.fb42	a6 9e		ldx $9e			LDX	PTR1			; get tape pass 1 error index
.fb44	a5 ad		lda $ad			LDA	SAL+1			;.
.fb46	9d 01 01	sta $0101,x		STA	STACK+1,X		; store in error log
.fb49	a5 ac		lda $ac			LDA	SAL			;.
.fb4b	9d 00 01	sta $0100,x		STA	STACK,X			; store in error log
.fb4e	e8		inx			INX				; increment index
.fb4f	e8		inx			INX				; increment index
.fb50	86 9e		stx $9e			STX	PTR1			; store in tape pass 1 error index
.fb52	4c 87 fb	jmp $fb87		JMP	LAB_FB87		;.
.fb55					LAB_FB55
.fb55	a6 9f		ldx $9f			LDX	PTR2			; get tape pass 2 error index
.fb57	e4 9e		cpx $9e			CPX	PTR1			; compare with tape pass 1 error index
.fb59	f0 35		beq $fb90		BEQ	LAB_FB90		; branch if equal
.fb5b	a5 ac		lda $ac			LDA	SAL			;.
.fb5d	dd 00 01	cmp $0100,x		CMP	STACK,X			; compare with pass 1 error
.fb60	d0 2e		bne $fb90		BNE	LAB_FB90		; branch if not equal
.fb62	a5 ad		lda $ad			LDA	SAL+1			;.
.fb64	dd 01 01	cmp $0101,x		CMP	STACK+1,X		; compare with pass 1 error
.fb67	d0 27		bne $fb90		BNE	LAB_FB90		; branch if not equal
.fb69	e6 9f		inc $9f			INC	PTR2			; increment tape pass 2 error index
.fb6b	e6 9f		inc $9f			INC	PTR2			; increment tape pass 2 error index
.fb6d	a5 93		lda $93			LDA	VERCK			; get load/verify flag
.fb6f	f0 0b		beq $fb7c		BEQ	LAB_FB7C		; branch if load
.fb71	a5 bd		lda $bd			LDA	ROPRTY			; get tape byte read
.fb73	a0 00		ldy #$00		LDY	#$00			; clear index
.fb75	d1 ac		cmp ($ac),y		CMP	(SAL),Y			; compare with byte in buffer
.fb77	f0 17		beq $fb90		BEQ	LAB_FB90		; branch if equal
.fb79	c8		iny			INY				; increment read errors
.fb7a	84 b6		sty $b6			STY	RODATA			; save read errors
.fb7c					LAB_FB7C
.fb7c	a5 b6		lda $b6			LDA	RODATA			; get read errors
.fb7e	f0 07		beq $fb87		BEQ	LAB_FB87		; branch if no error
.fb80					LAB_FB80
.fb80	a9 10		lda #$10		LDA	#$10			; set read error bit
.fb82	20 6a fe	jsr $fe6a		JSR	ORIOST			; OR into I/O status byte
.fb85	d0 09		bne $fb90		BNE	LAB_FB90		; branch always
.fb87					LAB_FB87
.fb87	a5 93		lda $93			LDA	VERCK			; get load/verify flag
.fb89	d0 05		bne $fb90		BNE	LAB_FB90		; branch if verify
.fb8b	a8		tay			TAY				; save load/verify flag
.fb8c	a5 bd		lda $bd			LDA	ROPRTY			; get tape byte read
.fb8e	91 ac		sta ($ac),y		STA	(SAL),Y			; save byte into buffer
.fb90					LAB_FB90
.fb90	20 1b fd	jsr $fd1b		JSR	WRT62			; increment read/write pointer
.fb93	d0 3a		bne $fbcf		BNE	LAB_FBCF		; restore registers and exit interrupt, branch always
.fb95					LAB_FB95
.fb95	a9 80		lda #$80		LDA	#$80			; set first block loaded
.fb97					LAB_FB97
.fb97	85 aa		sta $aa			STA	RIDATA			; save tape input status flags
.fb99	a6 be		ldx $be			LDX	FSBLK			; get tape copies remaining
.fb9b	ca		dex			DEX				; decrement copies remaining
.fb9c	30 02		bmi $fba0		BMI	LAB_FBA0		; branch if become -ve
.fb9e	86 be		stx $be			STX	FSBLK			; save copies remaining
.fba0					LAB_FBA0
.fba0	c6 a7		dec $a7			DEC	INBIT			; decrement tape write leader count
.fba2	f0 08		beq $fbac		BEQ	LAB_FBAC		;.
.fba4	a5 9e		lda $9e			LDA	PTR1			; get tape pass 1 error log
.fba6	d0 27		bne $fbcf		BNE	LAB_FBCF		; if errors restore registers and exit interrupt
.fba8	85 be		sta $be			STA	FSBLK			; save tape copies remaining
.fbaa	f0 23		beq $fbcf		BEQ	LAB_FBCF		; restore registers and exit interrupt, branch always
.fbac					LAB_FBAC
.fbac	20 cf fc	jsr $fccf		JSR	TNIF			; restore everything for [STOP]
.fbaf	20 d2 fb	jsr $fbd2		JSR	RD300			; copy I/O start address to buffer address
.fbb2	a0 00		ldy #$00		LDY	#$00			; clear index
.fbb4	84 ab		sty $ab			STY	RIPRTY			; clear tape read checksum
.fbb6					LAB_FBB6
.fbb6	b1 ac		lda ($ac),y		LDA	(SAL),Y			; get byte from buffer
.fbb8	45 ab		eor $ab			EOR	RIPRTY			; XOR with read checksum
.fbba	85 ab		sta $ab			STA	RIPRTY			; save new read checksum
.fbbc	20 1b fd	jsr $fd1b		JSR	WRT62			; increment read/write pointer
.fbbf	20 11 fd	jsr $fd11		JSR	VPRTY			; check read/write pointer, return Cb = 1 if pointer >= end
.fbc2	90 f2		bcc $fbb6		BCC	LAB_FBB6		; loop if not at end
.fbc4	a5 ab		lda $ab			LDA	RIPRTY			; get computed checksum
.fbc6	45 bd		eor $bd			EOR	ROPRTY			; compare with tape write byte
.fbc8	f0 05		beq $fbcf		BEQ	LAB_FBCF		; if checksum ok restore registers and exit interrupt
.fbca	a9 20		lda #$20		LDA	#$20			; else set checksum error bit
.fbcc	20 6a fe	jsr $fe6a		JSR	ORIOST			; OR into I/O status byte
.fbcf					LAB_FBCF
.fbcf	4c 56 ff	jmp $ff56		JMP	RRTI			; restore registers and exit interrupt
.fbd2					RD300
.fbd2	a5 c2		lda $c2			LDA	STAL+1			; get I/O start address high byte
.fbd4	85 ad		sta $ad			STA	SAL+1			; set buffer address high byte
.fbd6	a5 c1		lda $c1			LDA	STAL			; get I/O start address low byte
.fbd8	85 ac		sta $ac			STA	SAL			; set buffer address low byte
.fbda	60		rts			RTS
.fbdb					NEWCH
.fbdb	a9 08		lda #$08		LDA	#$08			; eight bits to do
.fbdd	85 a3		sta $a3			STA	PCNTR			; set tape bit count
.fbdf	a9 00		lda #$00		LDA	#$00			; clear .A
.fbe1	85 a4		sta $a4			STA	FIRT			; clear tape bit cycle phase
.fbe3	85 a8		sta $a8			STA	BITCI			; clear tape error flags
.fbe5	85 9b		sta $9b			STA	PRTY			; clear tape character parity
.fbe7	85 a9		sta $a9			STA	RINONE			; clear tape dipole count
.fbe9	60		rts			RTS
.fbea					TPTOGLE
.fbea	a5 bd		lda $bd			LDA	ROPRTY			; get tape write byte
.fbec	4a		lsr a			LSR				; shift LSB into Cb
.fbed	a9 60		lda #$60		LDA	#$60			; set time constant low byte for bit = 0
.fbef	90 02		bcc $fbf3		BCC	LAB_FBF3		; branch if bit was 0
.fbf1					LAB_FBF1
.fbf1	a9 b0		lda #$b0		LDA	#$B0			; set time constant low byte for bit = 1
.fbf3					LAB_FBF3
.fbf3	a2 00		ldx #$00		LDX	#$00			; set time constant high byte
.fbf5					LAB_FBF5
.fbf5	8d 28 91	sta $9128		STA	VIA2T2CL		; set VIA 2 T2C_l
.fbf8	8e 29 91	stx $9129		STX	VIA2T2CH		; set VIA 2 T2C_h
.fbfb	ad 20 91	lda $9120		LDA	VIA2PB			; get VIA 2 DRB, keyboard column
.fbfe	49 08		eor #$08		EOR	#$08			; toggle tape out bit
.fc00	8d 20 91	sta $9120		STA	VIA2PB			; set VIA 2 DRB
.fc03	29 08		and #$08		AND	#$08			; mask tape out bit
.fc05	60		rts			RTS
.fc06					BLKEND
.fc06	38		sec			SEC				; set carry flag
.fc07	66 ad		ror $ad			ROR	SAL+1			; set buffer address high byte negative, flag all sync,
.fc09	30 3c		bmi $fc47		BMI	LAB_FC47		; restore registers and exit interrupt, branch always
.fc0b					WRITE
.fc0b	a5 a8		lda $a8			LDA	BITCI			; get tape long word marker
.fc0d	d0 12		bne $fc21		BNE	LAB_FC21		; if long word marker done go do rest of byte
.fc0f	a9 10		lda #$10		LDA	#$10			; set first start cycle time constant low byte
.fc11	a2 01		ldx #$01		LDX	#$01			; set first start cycle time constant high byte
.fc13	20 f5 fb	jsr $fbf5		JSR	LAB_FBF5		; write time constant and toggle tape
.fc16	d0 2f		bne $fc47		BNE	LAB_FC47		; if first half cycle go restore registers and exit
.fc18	e6 a8		inc $a8			INC	BITCI			; set tape long word marker
.fc1a	a5 ad		lda $ad			LDA	SAL+1			; get buffer address high byte
.fc1c	10 29		bpl $fc47		BPL	LAB_FC47		; if block not complete go restore registers and exit
.fc1e	4c 95 fc	jmp $fc95		JMP	WRTN1			; else do tape routine, block complete exit
.fc21					LAB_FC21
.fc21	a5 a9		lda $a9			LDA	RINONE			; get tape medium word marker
.fc23	d0 09		bne $fc2e		BNE	LAB_FC2E		; if word marker already written go send the byte bits
.fc25	20 f1 fb	jsr $fbf1		JSR	LAB_FBF1		; set time constant for bit = 1 and toggle tape
.fc28	d0 1d		bne $fc47		BNE	LAB_FC47		; if first half cycle go restore registers and exit
.fc2a	e6 a9		inc $a9			INC	RINONE			; set tape medium word marker
.fc2c	d0 19		bne $fc47		BNE	LAB_FC47		; restore registers and exit interrupt, branch always
.fc2e					LAB_FC2E
.fc2e	20 ea fb	jsr $fbea		JSR	TPTOGLE			; send LSB from tape write byte to tape
.fc31	d0 14		bne $fc47		BNE	LAB_FC47		; if first half cycle go restore registers and exit
.fc33	a5 a4		lda $a4			LDA	FIRT			; get tape bit cycle phase
.fc35	49 01		eor #$01		EOR	#$01			; toggle b0
.fc37	85 a4		sta $a4			STA	FIRT			; save tape bit cycle phase
.fc39	f0 0f		beq $fc4a		BEQ	LAB_FC4A		; if bit cycle phase complete go setup for next bit
.fc3b	a5 bd		lda $bd			LDA	ROPRTY			; get tape write byte
.fc3d	49 01		eor #$01		EOR	#$01			; invert bit being sent
.fc3f	85 bd		sta $bd			STA	ROPRTY			; save tape write byte
.fc41	29 01		and #$01		AND	#$01			; mask b0
.fc43	45 9b		eor $9b			EOR	PRTY			; XOR with tape write byte parity bit
.fc45	85 9b		sta $9b			STA	PRTY			; save tape write byte parity bit
.fc47					LAB_FC47
.fc47	4c 56 ff	jmp $ff56		JMP	RRTI			; restore registers and exit interrupt
.fc4a					LAB_FC4A
.fc4a	46 bd		lsr $bd			LSR	ROPRTY			; shift bit out of tape write byte
.fc4c	c6 a3		dec $a3			DEC	PCNTR			; decrement tape bit count
.fc4e	a5 a3		lda $a3			LDA	PCNTR			; get tape bit count
.fc50	f0 3a		beq $fc8c		BEQ	LAB_FC8C		; if all the data bits have been written go setup for
.fc52	10 f3		bpl $fc47		BPL	LAB_FC47		; if all the data bits are not yet sent just restore the
.fc54					LAB_FC54
.fc54	20 db fb	jsr $fbdb		JSR	NEWCH			; new tape byte setup
.fc57	58		cli			CLI				; enable interrupts
.fc58	a5 a5		lda $a5			LDA	CNTDN			; get tape synchronisation character count
.fc5a	f0 12		beq $fc6e		BEQ	LAB_FC6E		; if synchronisation characters done go do block data
.fc5c	a2 00		ldx #$00		LDX	#$00			; clear .X
.fc5e	86 d7		stx $d7			STX	ASCII			; clear checksum byte
.fc60	c6 a5		dec $a5			DEC	CNTDN			; decrement tape synchronisation byte count
.fc62	a6 be		ldx $be			LDX	FSBLK			; get tape copies remaining
.fc64	e0 02		cpx #$02		CPX	#$02			; compare with load block indicator
.fc66	d0 02		bne $fc6a		BNE	LAB_FC6A		; branch if not the load block
.fc68	09 80		ora #$80		ORA	#$80			; this is the load block so make the synchronisation count
.fc6a					LAB_FC6A
.fc6a	85 bd		sta $bd			STA	ROPRTY			; save the synchronisation byte as the tape write byte
.fc6c	d0 d9		bne $fc47		BNE	LAB_FC47		; restore registers and exit interrupt, branch always
.fc6e					LAB_FC6E
.fc6e	20 11 fd	jsr $fd11		JSR	VPRTY			; check read/write pointer, return Cb = 1 if pointer >= end
.fc71	90 0a		bcc $fc7d		BCC	LAB_FC7D		; if not all done yet go get the byte to send
.fc73	d0 91		bne $fc06		BNE	BLKEND			; if pointer > end go flag block done and exit interrupt
.fc75	e6 ad		inc $ad			INC	SAL+1			; increment buffer pointer high byte, this means the block
.fc77	a5 d7		lda $d7			LDA	ASCII			; get checksum byte
.fc79	85 bd		sta $bd			STA	ROPRTY			; save checksum as tape write byte
.fc7b	b0 ca		bcs $fc47		BCS	LAB_FC47		; restore registers and exit interrupt, branch always
.fc7d					LAB_FC7D
.fc7d	a0 00		ldy #$00		LDY	#$00			; clear index
.fc7f	b1 ac		lda ($ac),y		LDA	(SAL),Y			; get byte from buffer
.fc81	85 bd		sta $bd			STA	ROPRTY			; save as tape write byte
.fc83	45 d7		eor $d7			EOR	ASCII			; XOR with checksum byte
.fc85	85 d7		sta $d7			STA	ASCII			; save new checksum byte
.fc87	20 1b fd	jsr $fd1b		JSR	WRT62			; increment read/write pointer
.fc8a	d0 bb		bne $fc47		BNE	LAB_FC47		; restore registers and exit interrupt, branch always
.fc8c					LAB_FC8C
.fc8c	a5 9b		lda $9b			LDA	PRTY			; get tape write byte parity bit
.fc8e	49 01		eor #$01		EOR	#$01			; toggle it
.fc90	85 bd		sta $bd			STA	ROPRTY			; save as tape write byte
.fc92					LAB_FC92
.fc92	4c 56 ff	jmp $ff56		JMP	RRTI			; restore registers and exit interrupt
.fc95					WRTN1
.fc95	c6 be		dec $be			DEC	FSBLK			; decrement tape copies remaining to read/write
.fc97	d0 03		bne $fc9c		BNE	LAB_FC9C		; branch if more to do
.fc99	20 08 fd	jsr $fd08		JSR	TNOFF			; else stop cassette motor
.fc9c					LAB_FC9C
.fc9c	a9 50		lda #$50		LDA	#$50			; set tape write leader count
.fc9e	85 a7		sta $a7			STA	INBIT			; save tape write leader count
.fca0	a2 08		ldx #$08		LDX	#$08			; set index for write tape leader vector
.fca2	78		sei			SEI				; disable interrupts
.fca3	20 fb fc	jsr $fcfb		JSR	LAB_FCFB		; set tape vector
.fca6	d0 ea		bne $fc92		BNE	LAB_FC92		; restore registers and exit interrupt, branch always
.fca8					WRTZ
.fca8	a9 78		lda #$78		LDA	#$78			; set time constant low byte for bit = leader
.fcaa	20 f3 fb	jsr $fbf3		JSR	LAB_FBF3		; write time constant and toggle tape
.fcad	d0 e3		bne $fc92		BNE	LAB_FC92		; if tape bit high restore registers and exit interrupt
.fcaf	c6 a7		dec $a7			DEC	INBIT			; decrement tape write leader count
.fcb1	d0 df		bne $fc92		BNE	LAB_FC92		; if not all done restore registers and exit interrupt
.fcb3	20 db fb	jsr $fbdb		JSR	NEWCH			; new tape byte setup
.fcb6	c6 ab		dec $ab			DEC	RIPRTY			; decrement tape leader count
.fcb8	10 d8		bpl $fc92		BPL	LAB_FC92		; if not all done restore registers and exit interrupt
.fcba	a2 0a		ldx #$0a		LDX	#$0A			; set index for tape write vector
.fcbc	20 fb fc	jsr $fcfb		JSR	LAB_FCFB		; set tape vector
.fcbf	58		cli			CLI				; enable interrupts
.fcc0	e6 ab		inc $ab			INC	RIPRTY			; clear clear leader counter, was $FF
.fcc2	a5 be		lda $be			LDA	FSBLK			; get tape copies remaining
.fcc4	f0 30		beq $fcf6		BEQ	BSIV			; if all done restore everything for [STOP] and exit interrupt
.fcc6	20 d2 fb	jsr $fbd2		JSR	RD300			; copy I/O start address to buffer address
.fcc9	a2 09		ldx #$09		LDX	#$09			; set nine synchronisation bytes
.fccb	86 a5		stx $a5			STX	CNTDN			; save tape synchronisation byte count
.fccd	d0 85		bne $fc54		BNE	LAB_FC54		; go do next tape byte, branch always
.fccf					TNIF
.fccf	08		php			PHP				; save status
.fcd0	78		sei			SEI				; disable interrupts
.fcd1	20 08 fd	jsr $fd08		JSR	TNOFF			; stop cassette motor
.fcd4	a9 7f		lda #$7f		LDA	#$7F			; disable all interrupts
.fcd6	8d 2e 91	sta $912e		STA	VIA2IER			; set VIA 2 IER
.fcd9	a9 f7		lda #$f7		LDA	#$F7			; set keyboard column 3 active
.fcdb	8d 20 91	sta $9120		STA	VIA2PB			; set VIA 2 DRB, keyboard column
.fcde	a9 40		lda #$40		LDA	#$40			; set T1 free run, T2 clock Ã¸2,
.fce0	8d 2b 91	sta $912b		STA	VIA2ACR			; set VIA 2 ACR
.fce3	20 39 fe	jsr $fe39		JSR	LAB_FE39		; set 60Hz and enable timer
.fce6	ad a0 02	lda $02a0		LDA	IRQTMP+1		; get saved IRQ vector high byte
.fce9	f0 09		beq $fcf4		BEQ	LAB_FCF4		; branch if null
.fceb	8d 15 03	sta $0315		STA	CINV+1			; restore IRQ vector high byte
.fcee	ad 9f 02	lda $029f		LDA	IRQTMP			; get saved IRQ vector low byte
.fcf1	8d 14 03	sta $0314		STA	CINV			; restore IRQ vector low byte
.fcf4					LAB_FCF4
.fcf4	28		plp			PLP				; restore status
.fcf5	60		rts			RTS
.fcf6					BSIV
.fcf6	20 cf fc	jsr $fccf		JSR	TNIF			; restore everything for [STOP]
.fcf9	f0 97		beq $fc92		BEQ	LAB_FC92		; restore registers and exit interrupt, branch always
.fcfb					LAB_FCFB
.fcfb	bd e9 fd	lda $fde9,x		LDA	IRQVCTRS-8,X		; get tape IRQ vector low byte
.fcfe	8d 14 03	sta $0314		STA	CINV			; set IRQ vector low byte
.fd01	bd ea fd	lda $fdea,x		LDA	IRQVCTRS-7,X		; get tape IRQ vector high byte
.fd04	8d 15 03	sta $0315		STA	CINV+1			; set IRQ vector high byte
.fd07	60		rts			RTS
.fd08					TNOFF
.fd08	ad 1c 91	lda $911c		LDA	VIA1PCR			; get VIA 1 PCR
.fd0b	09 0e		ora #$0e		ORA	#$0E			; set CA2 high, cassette motor off
.fd0d	8d 1c 91	sta $911c		STA	VIA1PCR			; set VIA 1 PCR
.fd10	60		rts			RTS
.fd11					VPRTY
.fd11	38		sec			SEC				; set carry for subtract
.fd12	a5 ac		lda $ac			LDA	SAL			; get buffer address low byte
.fd14	e5 ae		sbc $ae			SBC	EAL			; subtract buffer end low byte
.fd16	a5 ad		lda $ad			LDA	SAL+1			; get buffer address high byte
.fd18	e5 af		sbc $af			SBC	EAL+1			; subtract buffer end high byte
.fd1a	60		rts			RTS
.fd1b					WRT62
.fd1b	e6 ac		inc $ac			INC	SAL			; increment buffer address low byte
.fd1d	d0 02		bne $fd21		BNE	LAB_FD21		; if no overflow skip the high byte increment
.fd1f	e6 ad		inc $ad			INC	SAL+1			; increment buffer address high byte
.fd21					LAB_FD21
.fd21	60		rts			RTS
.fd22					START
.fd22	a2 ff		ldx #$ff		LDX	#$FF			; set .X for stack
.fd24	78		sei			SEI				; disable interrupts
.fd25	9a		txs			TXS				; clear stack
.fd26	d8		cld			CLD				; clear decimal mode
.fd27	20 3f fd	jsr $fd3f		JSR	CHKAUTO			; scan for autostart ROM at $A000
.fd2a	d0 03		bne $fd2f		BNE	LAB_FD2F		; if not there continue VIC startup
.fd2c	6c 00 a0	jmp ($a000)		JMP	(XROMCOLD)		; call ROM start code
.fd2f					LAB_FD2F
.fd2f	20 8d fd	jsr $fd8d		JSR	INITMEM			; initialise and test RAM
.fd32	20 52 fd	jsr $fd52		JSR	FRESTOR			; restore default I/O vectors
.fd35	20 f9 fd	jsr $fdf9		JSR	INITVIA			; initialise I/O registers
.fd38	20 18 e5	jsr $e518		JSR	INITSK			; initialise hardware
.fd3b	58		cli			CLI				; enable interrupts
.fd3c	6c 00 c0	jmp ($c000)		JMP	(COLDST)		; execute BASIC
.fd3f					CHKAUTO
.fd3f	a2 05		ldx #$05		LDX	#$05			; five characters to test
.fd41					LAB_FD41
.fd41	bd 4c fd	lda $fd4c,x		LDA	A0CBM-1,X		; get test character
.fd44	dd 03 a0	cmp $a003,x		CMP	XROMID-1,X		; compare with byte in ROM space
.fd47	d0 03		bne $fd4c		BNE	LAB_FD4C		; exit if no match
.fd49	ca		dex			DEX				; decrement index
.fd4a	d0 f5		bne $fd41		BNE	LAB_FD41		; loop if not all done
.fd4c					LAB_FD4C
.fd4c	60		rts			RTS
.fd4d					A0CBM
>fd4d	41 30 c3 c2 cd				.text	"A0",$C3,$C2,$CD	; A0CBM
.fd52					FRESTOR
.fd52	a2 6d		ldx #$6d		LDX	#<VECTORS		; pointer to vector table low byte
.fd54	a0 fd		ldy #$fd		LDY	#>VECTORS		; pointer to vector table high byte
.fd56	18		clc			CLC				; flag set vectors
.fd57					FVECTOR
.fd57	86 c3		stx $c3			STX	MEMUSS			; save pointer low byte
.fd59	84 c4		sty $c4			STY	MEMUSS+1		; save pointer high byte
.fd5b	a0 1f		ldy #$1f		LDY	#$1F			; set byte count
.fd5d					LAB_FD5D
.fd5d	b9 14 03	lda $0314,y		LDA	CINV,Y			; read vector byte from vectors
.fd60	b0 02		bcs $fd64		BCS	LAB_FD64		; if read vectors skip the read from .X.Y
.fd62	b1 c3		lda ($c3),y		LDA	(MEMUSS),Y		; read vector byte from (.X.Y)
.fd64					LAB_FD64
.fd64	91 c3		sta ($c3),y		STA	(MEMUSS),Y		; save byte to (.X.Y)
.fd66	99 14 03	sta $0314,y		STA	CINV,Y			; save byte to vector
.fd69	88		dey			DEY				; decrement index
.fd6a	10 f1		bpl $fd5d		BPL	LAB_FD5D		; loop if more to do
.fd6c	60		rts			RTS
.fd6d					VECTORS
>fd6d	bf ea					.word	IRQ			; CINV		IRQ vector
>fd6f	d2 fe					.word	BREAK			; CBINV		BRK vector
>fd71	ad fe					.word	NMI2			; NMINV		NMI vector
>fd73	0a f4					.word	FOPEN			; IOPEN		open a logical file
>fd75	4a f3					.word	FCLOSE			; ICLOSE	close a specified logical file
>fd77	c7 f2					.word	FCHKIN			; ICHKIN	open channel for input
>fd79	09 f3					.word	FCHKOUT			; ICKOUT	open channel for output
>fd7b	f3 f3					.word	FCLRCHN			; ICLRCN	close input and output channels
>fd7d	0e f2					.word	FCHRIN			; IBASIN	input character from channel
>fd7f	7a f2					.word	FCHROUT			; IBSOUT	output character to channel
>fd81	70 f7					.word	FSTOP			; ISTOP		scan stop key
>fd83	f5 f1					.word	FGETIN			; IGETIN	get character from keyboard queue
>fd85	ef f3					.word	FCLALL			; ICLALL	close all channels and files
>fd87	d2 fe					.word	BREAK			; USRCMD	user function
>fd89	49 f5					.word	FLOAD2			; ILOAD		load
>fd8b	85 f6					.word	FSAVE2			; ISAVE		save
.fd8d					INITMEM
.fd8d	a9 00		lda #$00		LDA	#$00			; clear .A
.fd8f	aa		tax			TAX				; clear index
.fd90					LAB_FD90
.fd90	95 00		sta $00,x		STA	USRPPOK,X		; clear page 0
.fd92	9d 00 02	sta $0200,x		STA	BUF,X			; clear page 2
.fd95	9d 00 03	sta $0300,x		STA	IERROR,X		; clear page 3
.fd98	e8		inx			INX				; increment index
.fd99	d0 f5		bne $fd90		BNE	LAB_FD90		; loop if more to do
.fd9b	a2 3c		ldx #$3c		LDX	#<TBUFFR		; set cassette buffer pointer low byte
.fd9d	a0 03		ldy #$03		LDY	#>TBUFFR		; set cassette buffer pointer high byte
.fd9f	86 b2		stx $b2			STX	TAPE1			; save tape buffer start pointer low byte
.fda1	84 b3		sty $b3			STY	TAPE1+1			; save tape buffer start pointer high byte
.fda3	85 c1		sta $c1			STA	STAL			; clear RAM test pointer low byte
.fda5	85 97		sta $97			STA	XSAV			; clear looking for end flag
.fda7	8d 81 02	sta $0281		STA	MEMSTR			; clear OS start of memory low byte
.fdaa	a8		tay			TAY				; clear .Y
.fdab	a9 04		lda #$04		LDA	#$04			; set RAM test pointer high byte
.fdad	85 c2		sta $c2			STA	STAL+1			; save RAM test pointer high byte
.fdaf					LAB_FDAF
.fdaf	e6 c1		inc $c1			INC	STAL			; increment RAM test pointer low byte
.fdb1	d0 02		bne $fdb5		BNE	LAB_FDB5		; if no rollover skip the high byte increment
.fdb3	e6 c2		inc $c2			INC	STAL+1			; increment RAM test pointer high byte
.fdb5					LAB_FDB5
.fdb5	20 91 fe	jsr $fe91		JSR	TSTMEM			; test RAM byte, return Cb=0 if failed
.fdb8	a5 97		lda $97			LDA	XSAV			; test looking for end flag
.fdba	f0 22		beq $fdde		BEQ	LAB_FDDE		; branch if not looking for end
.fdbc	b0 f1		bcs $fdaf		BCS	LAB_FDAF		; loop if byte test passed
.fdbe	a4 c2		ldy $c2			LDY	STAL+1			; get test address high byte
.fdc0	a6 c1		ldx $c1			LDX	STAL			; get test address low byte
.fdc2	c0 20		cpy #$20		CPY	#$20			; compare with $2000, RAM should always end at or after
.fdc4	90 25		bcc $fdeb		BCC	LAB_FDEB		; if end address < $2000 go do dead end loop
.fdc6	c0 21		cpy #$21		CPY	#$21			; compare with $2100
.fdc8	b0 08		bcs $fdd2		BCS	LAB_FDD2		; branch if >= $2100
.fdca	a0 1e		ldy #$1e		LDY	#$1E			; set screen memory page to $1E00
.fdcc	8c 88 02	sty $0288		STY	HIBASE			; save screen memory page
.fdcf					LAB_FDCF
.fdcf	4c 7b fe	jmp $fe7b		JMP	LAB_FE7B		; set the top of memory and return
.fdd2					LAB_FDD2
.fdd2	a9 12		lda #$12		LDA	#$12			; set OS start of memory high byte
.fdd4	8d 82 02	sta $0282		STA	MEMSTR+1		; save OS start of memory high byte
.fdd7	a9 10		lda #$10		LDA	#$10			; set screen memory page to $1000
.fdd9	8d 88 02	sta $0288		STA	HIBASE			; save screen memory page
.fddc	d0 f1		bne $fdcf		BNE	LAB_FDCF		; set the top of memory and return, branch always
.fdde					LAB_FDDE
.fdde	90 cf		bcc $fdaf		BCC	LAB_FDAF		; loop if byte test failed, not found start yet
.fde0	a5 c2		lda $c2			LDA	STAL+1			; get test address high byte
.fde2	8d 82 02	sta $0282		STA	MEMSTR+1		; save OS start of memory high byte
.fde5	85 97		sta $97			STA	XSAV			; set looking for end flag
.fde7	c9 11		cmp #$11		CMP	#$11			; compare start with $1100, RAM should always start before
.fde9	90 c4		bcc $fdaf		BCC	LAB_FDAF		; go find end of RAM, branch always
.fdeb					LAB_FDEB
.fdeb	20 c3 e5	jsr $e5c3		JSR	INITVIC			; initialise VIC chip
.fdee	4c eb fd	jmp $fdeb		JMP	LAB_FDEB		; loop forever
.fdf1					IRQVCTRS
>fdf1	a8 fc					.word	WRTZ			; $08	write tape leader IRQ routine
>fdf3	0b fc					.word	WRITE			; $0A	tape write IRQ routine
>fdf5	bf ea					.word	IRQ			; $0C	normal IRQ vector
>fdf7	8e f9					.word	READT			; $0E	read tape bits IRQ routine
.fdf9					INITVIA
.fdf9	a9 7f		lda #$7f		LDA	#$7F			; disable all interrupts
.fdfb	8d 1e 91	sta $911e		STA	VIA1IER			; on VIA 1 IER ..
.fdfe	8d 2e 91	sta $912e		STA	VIA2IER			; .. and VIA 2 IER
.fe01	a9 40		lda #$40		LDA	#$40			; set T1 free run, T2 clock Ã¸2,
.fe03	8d 2b 91	sta $912b		STA	VIA2ACR			; set VIA 2 ACR
.fe06	a9 40		lda #$40		LDA	#$40			; set T1 free run, T2 clock Ã¸2,
.fe08	8d 1b 91	sta $911b		STA	VIA1ACR			; set VIA 1 ACR
.fe0b	a9 fe		lda #$fe		LDA	#$FE			; CB2 high, RS-232 Tx
.fe0d	8d 1c 91	sta $911c		STA	VIA1PCR			; set VIA 1 PCR
.fe10	a9 de		lda #$de		LDA	#$DE			; CB2 low, serial DATA out high
.fe12	8d 2c 91	sta $912c		STA	VIA2PCR			; set VIA 2 PCR
.fe15	a2 00		ldx #$00		LDX	#$00			; all inputs, RS-232 interface or parallel user port
.fe17	8e 12 91	stx $9112		STX	VIA1DDRB		; set VIA 1 DDRB
.fe1a	a2 ff		ldx #$ff		LDX	#$FF			; all outputs, keyboard column
.fe1c	8e 22 91	stx $9122		STX	VIA2DDRB		; set VIA 2 DDRB
.fe1f	a2 00		ldx #$00		LDX	#$00			; all inputs, keyboard row
.fe21	8e 23 91	stx $9123		STX	VIA2DDRA		; set VIA 2 DDRA
.fe24	a2 80		ldx #$80		LDX	#$80			; OIII IIII, serial ATN out, light pen, joystick, serial data
.fe26	8e 13 91	stx $9113		STX	VIA1DDRA		; set VIA 1 DDRA
.fe29	a2 00		ldx #$00		LDX	#$00			; ATN out low, set ATN high
.fe2b	8e 1f 91	stx $911f		STX	VIA1PA2			; set VIA 1 DRA, no handshake
.fe2e	20 84 ef	jsr $ef84		JSR	SRCLKHI			; set serial clock high
.fe31	a9 82		lda #$82		LDA	#$82			; enable CA1 interrupt, [RESTORE] key
.fe33	8d 1e 91	sta $911e		STA	VIA1IER			; set VIA 1 IER
.fe36	20 8d ef	jsr $ef8d		JSR	SRCLKLO			; set serial clock low
.fe39					LAB_FE39
.fe39	a9 c0		lda #$c0		LDA	#$C0			; enable T1 interrupt
.fe3b	8d 2e 91	sta $912e		STA	VIA2IER			; set VIA 2 IER
.fe3e	a9 26		lda #$26		LDA	#$26			; set timer constant low byte [PAL]
.fe40	8d 24 91	sta $9124		STA	VIA2T1CL		; set VIA 2 T1C_l
.fe43	a9 48		lda #$48		LDA	#$48			; set timer constant high byte [PAL]
.fe45	8d 25 91	sta $9125		STA	VIA2T1CH		; set VIA 2 T1C_h
.fe48	60		rts			RTS
.fe49					FSETNAM
.fe49	85 b7		sta $b7			STA	FNLEN			; set file name length
.fe4b	86 bb		stx $bb			STX	FNADR			; set file name pointer low byte
.fe4d	84 bc		sty $bc			STY	FNADR+1			; set file name pointer high byte
.fe4f	60		rts			RTS
.fe50					FSETLFS
.fe50	85 b8		sta $b8			STA	LA			; set logical file
.fe52	86 ba		stx $ba			STX	FA			; set device number
.fe54	84 b9		sty $b9			STY	SA			; set secondary address or command
.fe56	60		rts			RTS
.fe57					FREADST
.fe57	a5 ba		lda $ba			LDA	FA			; get device number
.fe59	c9 02		cmp #$02		CMP	#$02			; compare device with RS-232 device
.fe5b	d0 0b		bne $fe68		BNE	READIOST		; branch if not RS-232 device
.fe5d	ad 97 02	lda $0297		LDA	RSSTAT			; read RS-232 status word
.fe60	a9 00		lda #$00		LDA	#$00			; clear .A
.fe62	8d 97 02	sta $0297		STA	RSSTAT			; clear RS-232 status
.fe65	60		rts			RTS
.fe66					FSETMSG
.fe66	85 9d		sta $9d			STA	MSGFLG			; set KERNAL message mode flag
.fe68					READIOST
.fe68	a5 90		lda $90			LDA	STATUS			; read I/O status byte
.fe6a					ORIOST
.fe6a	05 90		ora $90			ORA	STATUS			; OR with I/O status byte
.fe6c	85 90		sta $90			STA	STATUS			; save I/O status byte
.fe6e	60		rts			RTS
.fe6f					FSETTMO
.fe6f	8d 85 02	sta $0285		STA	TIMOUT			; save serial bus timeout flag
.fe72	60		rts			RTS
.fe73					FMEMTOP
.fe73	90 06		bcc $fe7b		BCC	LAB_FE7B		; if Cb clear go set the top of memory
.fe75					LAB_FE75
.fe75	ae 83 02	ldx $0283		LDX	MEMHIGH			; get memory top low byte
.fe78	ac 84 02	ldy $0284		LDY	MEMHIGH+1		; get memory top high byte
.fe7b					LAB_FE7B
.fe7b	8e 83 02	stx $0283		STX	MEMHIGH			; set memory top low byte
.fe7e	8c 84 02	sty $0284		STY	MEMHIGH+1		; set memory top high byte
.fe81	60		rts			RTS
.fe82					FMEMBOT
.fe82	90 06		bcc $fe8a		BCC	LAB_FE8A		; if Cb clear go set the bottom of memory
.fe84	ae 81 02	ldx $0281		LDX	MEMSTR			; read OS start of memory low byte
.fe87	ac 82 02	ldy $0282		LDY	MEMSTR+1		; read OS start of memory high byte
.fe8a					LAB_FE8A
.fe8a	8e 81 02	stx $0281		STX	MEMSTR			; set OS start of memory low byte
.fe8d	8c 82 02	sty $0282		STY	MEMSTR+1		; set OS start of memory high byte
.fe90	60		rts			RTS
.fe91					TSTMEM
.fe91	b1 c1		lda ($c1),y		LDA	(STAL),Y		; get existing RAM byte
.fe93	aa		tax			TAX				; copy to .X
.fe94	a9 55		lda #$55		LDA	#$55			; set first test byte
.fe96	91 c1		sta ($c1),y		STA	(STAL),Y		; save to RAM
.fe98	d1 c1		cmp ($c1),y		CMP	(STAL),Y		; compare with saved
.fe9a	d0 08		bne $fea4		BNE	LAB_FEA4		; branch if fail
.fe9c	6a		ror a			ROR				; make byte $AA, carry is set here
.fe9d	91 c1		sta ($c1),y		STA	(STAL),Y		; save to RAM
.fe9f	d1 c1		cmp ($c1),y		CMP	(STAL),Y		; compare with saved
.fea1	d0 01		bne $fea4		BNE	LAB_FEA4		; branch if fail
>fea3	a9					.byte	$A9			; makes next line LDA #$18
.fea4					LAB_FEA4
.fea4	18		clc			CLC				; flag test failed
.fea5	8a		txa			TXA				; get original byte back
.fea6	91 c1		sta ($c1),y		STA	(STAL),Y		; restore original byte
.fea8	60		rts			RTS
.fea9					NMI
.fea9	78		sei			SEI				; disable interrupts
.feaa	6c 18 03	jmp ($0318)		JMP	(NMINV)			; do NMI vector
.fead					NMI2
.fead	48		pha			PHA				; save .A
.feae	8a		txa			TXA				; copy .X
.feaf	48		pha			PHA				; save .X
.feb0	98		tya			TYA				; copy .Y
.feb1	48		pha			PHA				; save .Y
.feb2	ad 1d 91	lda $911d		LDA	VIA1IFR			; get VIA 1 IFR
.feb5	10 48		bpl $feff		BPL	LAB_FEFF		; if no interrupt restore registers and exit
.feb7	2d 1e 91	and $911e		AND	VIA1IER			; AND with VIA 1 IER
.feba	aa		tax			TAX				; copy to .X
.febb	29 02		and #$02		AND	#$02			; mask CA1 interrupt, [RESTORE] key
.febd	f0 1f		beq $fede		BEQ	RSNMI			; branch if not [RESTORE] key
.febf	20 3f fd	jsr $fd3f		JSR	CHKAUTO			; scan for autostart ROM at $A000
.fec2	d0 03		bne $fec7		BNE	LAB_FEC7		; branch if no autostart ROM
.fec4	6c 02 a0	jmp ($a002)		JMP	(XROMWARM)		; else do autostart ROM break entry
.fec7					LAB_FEC7
.fec7	2c 11 91	bit $9111		BIT	VIA1PA1			; test VIA 1 DRA, clear CA1 interrupt
.feca	20 34 f7	jsr $f734		JSR	FUDTIM			; increment the real time clock
.fecd	20 e1 ff	jsr $ffe1		JSR	STOP			; scan stop key
.fed0	d0 2d		bne $feff		BNE	LAB_FEFF		; if not [STOP] restore registers and exit interrupt
.fed2					BREAK
.fed2	20 52 fd	jsr $fd52		JSR	FRESTOR			; restore default I/O vectors
.fed5	20 f9 fd	jsr $fdf9		JSR	INITVIA			; initialise I/O registers
.fed8	20 18 e5	jsr $e518		JSR	INITSK			; initialise hardware
.fedb	6c 02 c0	jmp ($c002)		JMP	(WARMST)		; do BASIC break entry
.fede					RSNMI
.fede	ad 1e 91	lda $911e		LDA	VIA1IER			; get VIA 1 IER
.fee1	09 80		ora #$80		ORA	#$80			; set enable bit, b7 is clear on a read for a MOS 6522
.fee3	48		pha			PHA				; save to re-enable interrupts
.fee4	a9 7f		lda #$7f		LDA	#$7F			; disable all interrupts
.fee6	8d 1e 91	sta $911e		STA	VIA1IER			; set VIA 1 IER
.fee9	8a		txa			TXA				; get active interrupts back
.feea	29 40		and #$40		AND	#$40			; mask T1 interrupt
.feec	f0 14		beq $ff02		BEQ	LAB_FF02		; branch if not T1 interrupt
.feee	a9 ce		lda #$ce		LDA	#$CE			; CB2 low, CB1 -ve edge, CA2 high, CA1 -ve edge
.fef0	05 b5		ora $b5			ORA	NXTBIT			; OR RS-232 next bit to send, sets CB2 high if set
.fef2	8d 1c 91	sta $911c		STA	VIA1PCR			; set VIA 1 PCR
.fef5	ad 14 91	lda $9114		LDA	VIA1T1CL		; get VIA 1 T1C_l, clear T1 interrupt
.fef8	68		pla			PLA				; restore interrupt enable byte to restore previously
.fef9	8d 1e 91	sta $911e		STA	VIA1IER			; set VIA 1 IER
.fefc	20 a3 ef	jsr $efa3		JSR	RSNXTBIT		; RS-232 Tx NMI routine
.feff					LAB_FEFF
.feff	4c 56 ff	jmp $ff56		JMP	RRTI			; restore registers and exit interrupt
.ff02					LAB_FF02
.ff02	8a		txa			TXA				; get active interrupts back
.ff03	29 20		and #$20		AND	#$20			; mask T2 interrupt
.ff05	f0 25		beq $ff2c		BEQ	LAB_FF2C		; branch if not T2 interrupt
.ff07	ad 10 91	lda $9110		LDA	VIA1PB			; get VIA 1 DRB
.ff0a	29 01		and #$01		AND	#$01			; mask RS-232 data in
.ff0c	85 a7		sta $a7			STA	INBIT			; save RS-232 input bit
.ff0e	ad 18 91	lda $9118		LDA	VIA1T2CL		; get VIA 1 T2C_l, clear T2 interrupt
.ff11	e9 16		sbc #$16		SBC	#$16			; adjust by 22 cycles to cover time taken by the
.ff13	6d 99 02	adc $0299		ADC	BAUDOF			; add baud rate bit time low byte
.ff16	8d 18 91	sta $9118		STA	VIA1T2CL		; set VIA 1 T2C_l
.ff19	ad 19 91	lda $9119		LDA	VIA1T2CH		; get VIA 1 T2C_h
.ff1c	6d 9a 02	adc $029a		ADC	BAUDOF+1		; add baud rate bit time high byte
.ff1f	8d 19 91	sta $9119		STA	VIA1T2CH		; set VIA 1 T2C_h
.ff22	68		pla			PLA				; restore interrupt enable byte to restore previously
.ff23	8d 1e 91	sta $911e		STA	VIA1IER			; set VIA 1 IER, restore interrupts
.ff26	20 36 f0	jsr $f036		JSR	RSINBIT			; RS-232 Rx
.ff29	4c 56 ff	jmp $ff56		JMP	RRTI			; restore registers and exit interrupt
.ff2c					LAB_FF2C
.ff2c	8a		txa			TXA				; get active interrupts back
.ff2d	29 10		and #$10		AND	#$10			; mask CB1 interrupt
.ff2f	f0 25		beq $ff56		BEQ	RRTI			; if no bit restore registers and exit interrupt
.ff31	ad 93 02	lda $0293		LDA	M51CTR			; get pseudo 6551 control register
.ff34	29 0f		and #$0f		AND	#$0F			; mask 0000 xxxx, baud rate
.ff36	d0 00		bne $ff38		BNE	LAB_FF38		; short delay. was this intended to skip code used to
.ff38					LAB_FF38
.ff38	0a		asl a			ASL				; *2, 2 bytes per baud count
.ff39	aa		tax			TAX				; copy to index
.ff3a	bd 5a ff	lda $ff5a,x		LDA	BAUDTBL-2,X		; get baud count low byte
.ff3d	8d 18 91	sta $9118		STA	VIA1T2CL		; set VIA 1 T2C_l
.ff40	bd 5b ff	lda $ff5b,x		LDA	BAUDTBL-1,X		; get baud count high byte
.ff43	8d 19 91	sta $9119		STA	VIA1T2CH		; set VIA 1 T2C_h
.ff46	ad 10 91	lda $9110		LDA	VIA1PB			; read VIA 1 DRB, clear interrupt flag
.ff49	68		pla			PLA				; restore interrupt enable byte to restore previously
.ff4a	09 20		ora #$20		ORA	#$20			; enable T2 interrupt
.ff4c	29 ef		and #$ef		AND	#$EF			; disable CB1 interrupt, Rx data bit transition
.ff4e	8d 1e 91	sta $911e		STA	VIA1IER			; set VIA 1 IER
.ff51	ae 98 02	ldx $0298		LDX	BITNUM			; get number of bits to be sent/received
.ff54	86 a8		stx $a8			STX	BITCI			; save RS-232 input bit count
.ff56					RRTI
.ff56	68		pla			PLA				; pull .Y
.ff57	a8		tay			TAY				; restore .Y
.ff58	68		pla			PLA				; pull .X
.ff59	aa		tax			TAX				; restore .X
.ff5a	68		pla			PLA				; restore .A
.ff5b	40		rti			RTI
.ff5c					BAUDTBL
>ff5c	e6 2a					.word	$2AE6			;   50	 baud
>ff5e	78 1c					.word	$1C78			;   75	 baud
>ff60	49 13					.word	$1349			;  110	 baud
>ff62	b1 0f					.word	$0FB1			;  134.5 baud
>ff64	0a 0e					.word	$0E0A			;  150	 baud
>ff66	d3 06					.word	$06D3			;  300	 baud
>ff68	38 03					.word	$0338			;  600	 baud
>ff6a	6a 01					.word	$016A			; 1200	 baud
>ff6c	d0 00					.word	$00D0			; 1800	 baud
>ff6e	83 00					.word	$0083			; 2400	 baud
>ff70	36 00					.word	$0036			; 3600	 baud
.ff72					IRQROUT
.ff72	48		pha			PHA				; save .A
.ff73	8a		txa			TXA				; copy .X
.ff74	48		pha			PHA				; save .X
.ff75	98		tya			TYA				; copy .Y
.ff76	48		pha			PHA				; save .Y
.ff77	ba		tsx			TSX				; copy stack pointer
.ff78	bd 04 01	lda $0104,x		LDA	STACK+4,X		; get the stacked status register
.ff7b	29 10		and #$10		AND	#$10			; mask the BRK flag bit
.ff7d	f0 03		beq $ff82		BEQ	LAB_FF82		; if not BRK go do the hardware IRQ vector
.ff7f	6c 16 03	jmp ($0316)		JMP	(CBINV)			; else do the BRK vector (iBRK)
.ff82					LAB_FF82
.ff82	6c 14 03	jmp ($0314)		JMP	(CINV)			; do IRQ vector (iIRQ)
>ff85	ff ff ff ff ff				.byte	$FF,$FF,$FF,$FF,$FF
.ff8a					RESTOR
.ff8a	4c 52 fd	jmp $fd52		JMP	FRESTOR			; restore default I/O vectors
.ff8d					VECTOR
.ff8d	4c 57 fd	jmp $fd57		JMP	FVECTOR			; set/read vectored I/O from (.X.Y)
.ff90					SETMSG
.ff90	4c 66 fe	jmp $fe66		JMP	FSETMSG			; control KERNAL messages
.ff93					SECOND
.ff93	4c c0 ee	jmp $eec0		JMP	FSECOND			; send secondary address after LISTEN
.ff96					TKSA
.ff96	4c ce ee	jmp $eece		JMP	FTKSA			; send secondary address after TALK
.ff99					MEMTOP
.ff99	4c 73 fe	jmp $fe73		JMP	FMEMTOP			; read/set the top of memory
.ff9c					MEMBOT
.ff9c	4c 82 fe	jmp $fe82		JMP	FMEMBOT			; read/set the bottom of memory
.ff9f					SCNKEY
.ff9f	4c 1e eb	jmp $eb1e		JMP	FSCNKEY			; scan keyboard
.ffa2					SETTMO
.ffa2	4c 6f fe	jmp $fe6f		JMP	FSETTMO			; set timeout on serial bus
.ffa5					ACPTR
.ffa5	4c 19 ef	jmp $ef19		JMP	FACPTR			; input byte from serial bus
.ffa8					CIOUT
.ffa8	4c e4 ee	jmp $eee4		JMP	FCIOUT			; output a byte to the serial bus
.ffab					UNTLK
.ffab	4c f6 ee	jmp $eef6		JMP	FUNTLK			; command the serial bus to UNTALK
.ffae					UNLSN
.ffae	4c 04 ef	jmp $ef04		JMP	FUNLSN			; command the serial bus to UNLISTEN
.ffb1					LISTEN
.ffb1	4c 17 ee	jmp $ee17		JMP	FLISTEN			; command devices on the serial bus to LISTEN
.ffb4					TALK
.ffb4	4c 14 ee	jmp $ee14		JMP	FTALK			; command serial bus device to TALK
.ffb7					READST
.ffb7	4c 57 fe	jmp $fe57		JMP	FREADST			; read I/O status word
.ffba					SETLFS
.ffba	4c 50 fe	jmp $fe50		JMP	FSETLFS			; set logical, first and second addresses
.ffbd					SETNAM
.ffbd	4c 49 fe	jmp $fe49		JMP	FSETNAM			; set filename
.ffc0					OPEN
.ffc0	6c 1a 03	jmp ($031a)		JMP	(IOPEN)			; do open file vector
.ffc3					CLOSE
.ffc3	6c 1c 03	jmp ($031c)		JMP	(ICLOSE)		; do close file vector
.ffc6					CHKIN
.ffc6	6c 1e 03	jmp ($031e)		JMP	(ICHKIN)		; do open for input vector
.ffc9					CHKOUT
.ffc9	6c 20 03	jmp ($0320)		JMP	(ICKOUT)		; do open for output vector
.ffcc					CLRCHN
.ffcc	6c 22 03	jmp ($0322)		JMP	(ICLRCN)		; do close vector
.ffcf					CHRIN
.ffcf	6c 24 03	jmp ($0324)		JMP	(IBASIN)		; do input vector
.ffd2					CHROUT
.ffd2	6c 26 03	jmp ($0326)		JMP	(IBSOUT)		; do output vector
.ffd5					LOAD
.ffd5	4c 42 f5	jmp $f542		JMP	FLOAD			; load RAM from a device
.ffd8					SAVE
.ffd8	4c 75 f6	jmp $f675		JMP	FSAVE			; save RAM to device
.ffdb					SETTIM
.ffdb	4c 67 f7	jmp $f767		JMP	FSETTIM			; set real time clock
.ffde					RDTIM
.ffde	4c 60 f7	jmp $f760		JMP	FRDTIM			; read real time clock
.ffe1					STOP
.ffe1	6c 28 03	jmp ($0328)		JMP	(ISTOP)			; do stop key vector
.ffe4					GETIN
.ffe4	6c 2a 03	jmp ($032a)		JMP	(IGETIN)		; do get vector
.ffe7					CLALL
.ffe7	6c 2c 03	jmp ($032c)		JMP	(ICLALL)		; do close all vector
.ffea					UDTIM
.ffea	4c 34 f7	jmp $f734		JMP	FUDTIM			; increment real time clock
.ffed					SCREEN
.ffed	4c 05 e5	jmp $e505		JMP	FSCREEN			; return X,Y organisation of screen
.fff0					PLOT
.fff0	4c 0a e5	jmp $e50a		JMP	FPLOT			; read/set X,Y cursor position
.fff3					IOBASE
.fff3	4c 00 e5	jmp $e500		JMP	FIOBASE			; return base address of I/O devices
>fff6	ff ff ff ff				.byte	$FF,$FF,$FF,$FF
>fffa	a9 fe					.word	NMI			; NMI vector
>fffc	22 fd					.word	START			; RESET vector
>fffe	72 ff					.word	IRQROUT			; IRQ vector

;******  End of listing
