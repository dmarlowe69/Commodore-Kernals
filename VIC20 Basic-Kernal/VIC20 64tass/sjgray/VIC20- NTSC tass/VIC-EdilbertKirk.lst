
; 64tass Turbo Assembler Macro V1.53.1515 listing file
; 64tass -L VIC-EdilbertKirk.lst -o VIC-EdilbertKirk.prg VIC-EdilbertKirk.asm
; Wed Feb 07 20:46:31 2018

;Offset	;Hex		;Monitor	;Source

;******  Processing input file: VIC-EdilbertKirk.asm

=0					C64 = 0        ; set to 1 for assembling the C64 ROM images
=1					VIC = 1 - C64  ;     or 0 for assembling the VIC ROM images
=0					JIFFY = 0      ; set to 1 for JIFFY DOS
=0					PAL   = 0      ; set to 0 for NTSC
=$9000					VIC_BASE = $9000
=$10					VIC_REGS = $10
=$9000					VIC_R0 = $9000       ; interlace / screen origin - horizontal
=$9001					VIC_R1 = $9001       ; bit 7-0 : vertical screen adjustment (25)
=$9002					VIC_R2 = $9002       ; screen address and number of colums
=$9003					VIC_R3 = $9003       ; raster / # of rows / character size
=$9004					VIC_R4 = $9004       ; raster value
=$9005					VIC_R5 = $9005       ; screen memory / character memory
=$9006					VIC_R6 = $9006       ; light pen horizontal
=$9007					VIC_R7 = $9007       ; light pen vertical
=$9008					VIC_R8 = $9008       ; paddle 1
=$9009					VIC_R9 = $9009       ; paddle 2
=$900a					VIC_RA = $900A       ; bit 7   : bass sound switch (1 = enable)
=$900b					VIC_RB = $900B       ; bit 7   : alto sound switch (1 = enable)
=$900c					VIC_RC = $900C       ; bit 7   : soprano sound switch (1 = enable)
=$900d					VIC_RD = $900D       ; bit 7   : noise sound switch (1 = enable)
=$900e					VIC_RE = $900E       ; auxiliary color / loudness
=$900f					VIC_RF = $900F       ; screen color / reverse mode / border color
=$9110					VIA1_DATB = $9110    ; VIA 1 data register B (I/O)
=$9111					VIA1_DATA = $9111    ; VIA 1 data register A (I/O)
=$9112					VIA1_DDRB = $9112    ; VIA 1 data direction register B
=$9113					VIA1_DDRA = $9113    ; VIA 1 data direction register A
=$9114					VIA1_T1CL = $9114    ; VIA 1 timer 1 low  order counter/latch
=$9115					VIA1_T1CH = $9115    ; VIA 1 timer 1 high order counter/latch
=$9116					VIA1_T1LL = $9116    ; VIA 1 timer 1 low  order latch
=$9117					VIA1_T1LH = $9117    ; VIA 1 timer 1 high order latch
=$9118					VIA1_T2CL = $9118    ; VIA 1 timer 2 low  order counter/latch
=$9119					VIA1_T2CH = $9119    ; VIA 1 timer 2 high order counter/latch
=$911a					VIA1_SR   = $911A    ; VIA 1 shift register
=$911b					VIA1_ACR  = $911B    ; VIA 1 auxiliary control register
=$911c					VIA1_PCR   = $911C   ; VIA 1 peripheral control register (PCR)
=$911d					VIA1_IFR   = $911D   ; VIA 1 interrupt flag register) (IFR)
=$911e					VIA1_IER   = $911E   ; VIA 1 interrupt enable register (IER)
=$911f					VIA1_DATN    = $911F ; VIA 1 DRA, no handshake
=$9120					VIA2_DATB  = $9120   ; VIA 2 DRB, keyboard column drive
=$9121					VIA2_DATA  = $9121   ; VIA 2 DRA, keyboard row port
=$9122					VIA2_DDRB  = $9122   ; VIA 2 data direction register B
=$9123					VIA2_DDRA  = $9123   ; VIA 2 data direction register A
=$9124					VIA2_T1CL  = $9124   ; VIA 2 T1 low  order counter/latch
=$9125					VIA2_T1CH  = $9125   ; VIA 2 T1 high order counter/latch
=$9126					VIA2_T1LL  = $9126   ; VIA 2 T1 low  order latch
=$9127					VIA2_T1LH  = $9127   ; VIA 2 T1 high order latch
=$9128					VIA2_T2CL  = $9128   ; VIA 2 T2 low  order counter/latch
=$9129					VIA2_T2CH  = $9129   ; VIA 2 T2 high order counter/latch
=$912a					VIA2_SR    = $912A   ; VIA 2 shift register              (SR)
=$912b					VIA2_ACR   = $912B   ; VIA 2 auxiliary control register  (ACR)
=$912c					VIA2_PCR   = $912C   ; VIA 2 peripheral control register (PCR)
=$912d					VIA2_IFR   = $912D   ; VIA 1 Interrupt Flag Register (IFR)
=$912e					VIA2_IER   = $912E   ; VIA 1 Interrupt Enable Register (IER)
=$912f					VIA2_DATN  = $912F   ; VIA 2 DRA, keyboard row, no handshake
=$9120					KEYB_COL   = VIA2_DATB
=$9121					KEYB_ROW   = VIA2_DATA
=$912f					KEYB_ROWN  = VIA2_DATN
=$fb					CTRL_COL = %11111011 ; $fb = col 2
=$fe					CTRL_ROW = %11111110 ; $fe = row 0
=$f7					STND_COL = %11110111 ; $7f = col 3
=22					COLS          =  22 ; screen columns
=23					ROWS          =  23 ; screen rows
=4					COLINK        =   4 ; possible physical lines per logical line
=88					COLMAX        =  88 ; maximum line length of a logical line
=$94					COLRAM_PAGE   = $94 ; default page of color RAM
=6					Default_Color =   6 ; blue
=$912c					IEC_PCR       = $912C; VIA 2 peripheral control register (PCR)
=$911f					IEC_DRAN      = $911F
=$9129					IEC_TIM_H     = $9129; VIA 2 T2H, timer high
=$912d					IEC_IFR       = $912D; VIA 2 IFR, interrupt flag register
=$80					IEC_ATN_BIT   = $80
=$20					IEC_IFR_BIT   = $20
=$02					IEC_CLK_BIT   = %00000010; $02
=$20					IEC_DAT_BIT   = %00100000; $20
=$20					RS232_C_BIT   = %00100000; $20
=$911e					RS2_IRQ_REG   = $911E
=$9110					RS2_DSR_CTS   = $9110
=$9114					RS2_TIM_LOW   = $9114
=$9115					RS2_TIM_HIG   = $9115
=$9005					MEM_CONTROL   = $9005
=$a000					OPTION_ROM    = $A000
=$c000					BASIC_ROM     = $C000
=$0d					CR    = $0D ; Carriage Return
=$0a					LF    = $0A ; Line Feed
=$22					QUOTE = $22 ; Quote
=$3b					SEMIC = $3B ; Semicolon
=$00					Basic_USR = $00      ; USR() JMP instruction ($4C)
=$01					USRVEC    = $01      ; USR() vector (Illegal_Quantity)
=$03					ADRAY1 = $03         ; float to fixed vector (Float_To_Integer)
=$05					ADRAY2 = $05         ; fixed to float vector (Integer_To_Float)
=$07					CHARAC = $07         ; search character
=$08					ENDCHR = $08         ; scan quotes flag
=$09					TRMPOS = $09         ; TAB column save
=$0a					VERCK  = $0A         ; load/verify flag, 0 = load, 1 = verify
=$0b					COUNT  = $0B         ; line crunch/array access/logic operators
=$0c					DIMFLG = $0C         ; DIM flag
=$0d					VALTYP = $0D         ; data type flag, $FF = string, $00 = numeric
=$0e					INTFLG = $0E         ; data type flag, $80 = integer, $00 = floating pt.
=$0f					GARBFL = $0F         ; garbage collected/open quote/DATA flag
=$10					SUBFLG = $10         ; subscript/FNx flag
=$11					INPFLG = $11         ; input mode, $00 = INPUT, $40 = GET, $98 = READ
=$12					TANSGN = $12         ; ATN sign/comparison evaluation flag
=$13					IOPMPT = $13         ; current I/O channel
=$14					LINNUM = $14         ; temporary integer
=$16					TEMPPT = $16         ; descriptor stack pointer, next free
=$17					LASTPT = $17         ; current descriptor stack item pointer
=$19					TEMPST = $19         ; to $21, descriptor stack
=$22					INDEXA = $22         ; misc temp word
=$24					INDEXB = $24         ; misc temp word
=$25					FAC3   = $25         ; auxiliary Floating Point Accumulator
=$2b					TXTTAB = $2B         ; start of memory
=$2d					VARTAB = $2D         ; start of variables
=$2f					ARYTAB = $2F         ; end of variables
=$31					STREND = $31         ; end of arrays
=$33					FRESPC = $33         ; bottom of string space
=$35					UTLSTP = $35         ; string utility ptr
=$37					MEMSIZ = $37         ; end of memory
=$39					CURLIN = $39         ; current line number
=$3b					OLDLIN = $3B         ; break line number
=$3d					OLDTXT = $3D         ; continue pointer
=$3f					DATLIN = $3F         ; current DATA line number
=$41					DATPTR = $41         ; DATA pointer
=$43					INPPTR = $43         ; READ pointer
=$45					VARNAM = $45         ; current variable name
=$47					VARPNT = $47         ; current variable address
=$49					FORPNT = $49         ; FOR/NEXT variable pointer
=$4b					YSAVE  = $4B         ; BASIC execute pointer temporary/precedence flag
=$4d					ACCSYM = $4D         ; comparrison evaluation flag
=$4e					FUNCPT = $4E         ; FAC temp store/function/variable/garbage pointer
=$50					DESCPT = $50         ; FAC temp store/descriptor pointer
=$53					GARBSS = $53         ; garbage collection step size
=$54					JUMPER = $54         ; JMP opcode for functions
=$55					FUNJMP = $55         ; functions jump vector
=$56					FAC2M5 = $56         ; FAC2 mantissa 5 = rounding byte
=$57					FACTPA = $57         ; FAC temp store ($57 - $5B)
=$58					TMPPTA = $58         ; temp pointer A
=$5a					TMPPTB = $5A         ; temp pointer B
=$5c					FACTPB = $5C         ; FAC temp store ($5C - $60)
=$5d					TMPVA1 = $5D         ; temp variable (counter)
=$5e					TMPVA2 = $5E         ; temp variable (counter)
=$5f					TMPPTC = $5F         ; temp pointer C
=$61					FAC1EX = $61         ; FAC1 exponent
=$62					FAC1M1 = $62         ; FAC1 mantissa 1
=$63					FAC1M2 = $63         ; FAC1 mantissa 2
=$64					FAC1M3 = $64         ; FAC1 mantissa 3
=$65					FAC1M4 = $65         ; FAC1 mantissa 4
=$66					FAC1SI = $66         ; FAC1 sign
=$67					SGNFLG = $67         ; constant count/negative flag
=$68					FAC1OV = $68         ; FAC1 overflow
=$69					FAC2EX = $69         ; FAC2 exponent
=$6a					FAC2M1 = $6A         ; FAC2 mantissa 1
=$6b					FAC2M2 = $6B         ; FAC2 mantissa 2
=$6c					FAC2M3 = $6C         ; FAC2 mantissa 3
=$6d					FAC2M4 = $6D         ; FAC2 mantissa 4
=$6e					FAC2SI = $6E         ; FAC2 sign
=$6f					STRPTR = $6F         ; string pointer & FAC variables
=$70					FAC1M5 = $70         ; FAC1 mantissa 5 = rounding byte
=$71					TMPPTD = $71         ; temp BASIC execute/array pointer low byte/index
=$73					CHRGET = $73         ; next program byte, BASIC byte get
=$79					CHRGOT = $79         ; scan memory, BASIC byte get
=$7a					TXTPTR = $7A         ; BASIC execute pointer
=$80					ISNUM  = $80         ; numeric test entry
=$8b					RNDX   = $8B         ; RND() seed, five bytes
=$90					STATUS = $90         ; serial status byte
=$91					STKEY  = $91         ; keyboard row, bx = 0 = key down
=$92					SVXT   = $92         ; timing constant for tape read
=$93					VERCKK = $93         ; load/verify flag, load = $00, verify = $01
=$94					C3PO   = $94         ; serial output: deferred character flag
=$95					BSOUR  = $95         ; serial output: deferred character
=$96					SYNO   = $96         ; cassette block synchronization number
=$97					TEMPX  = $97         ; register save
=$98					LDTND  = $98         ; open file count
=$99					DFLTN  = $99         ; input device number
=$9a					DFLTO  = $9A         ; output device number
=$9b					PRTY   = $9B         ; tape character parity
=$9c					DPSW   = $9C         ; byte received flag
=$9d					MSGFLG = $9D         ; message mode flag,
=$9e					PTR1   = $9E         ; index to cassette file name/header ID
=$9f					PTR2   = $9F         ; tape Pass 2 error log corrected
=$a0					JIFFYH = $A0         ; jiffy clock high byte
=$a1					JIFFYM = $A1         ; jiffy clock mid byte
=$a2					JIFFYL = $A2         ; jiffy clock low byte
=$a3					TSFCNT = $A3         ; EOI flag byte/tape bit count or Jiffy device flag
=$a4					TBTCNT = $A4         ; tape bit cycle phase
=$a5					CNTDN  = $A5         ; tape synch byte count/serial bus bit count
=$a6					BUFPNT = $A6         ; tape buffer index
=$a7					INBIT  = $A7         ; receiver input bit temp storage
=$a8					BITCI  = $A8         ; receiver bit count in
=$a9					RINONE = $A9         ; receiver start bit check flag, $90 = no start bit
=$aa					RIDATA = $AA         ; receiver byte buffer/assembly location
=$ab					RIPRTY = $AB         ; receiver parity bit storage
=$ac					SAL    = $AC         ; tape buffer start pointer; scroll screen
=$ae					EAL    = $AE         ; tape buffer end   pointer; scroll screen
=$b0					CMPO   = $B0         ; tape timing constant (word)
=$b2					TAPE1  = $B2         ; tape buffer start pointer
=$b4					BITTS  = $B4         ; transmitter bit count out
=$b5					NXTBIT = $B5         ; transmitter next bit to be sent
=$b6					RODATA = $B6         ; transmitter byte buffer/disassembly location
=$b7					FNLEN  = $B7         ; file name length
=$b8					LA     = $B8         ; logical file
=$b9					SA     = $B9         ; secondary address
=$ba					FA     = $BA         ; current device number
=$bb					FNADR  = $BB         ; file name pointer
=$bd					ROPRTY = $BD         ; tape write byte/RS232 parity byte
=$be					FSBLK  = $BE         ; tape copies count
=$bf					MYCH   = $BF         ; parity count ??
=$c0					CAS1   = $C0         ; tape motor interlock
=$c1					STAL   = $C1         ; I/O start addresses
=$c3					MEMUSS = $C3         ; kernal setup pointer
=$c5					LSTX   = $C5         ; current key pressed
=$c6					NDX    = $C6         ; keyboard buffer length/index
=$c7					RVS    = $C7         ; reverse flag $12 = reverse, $00 = normal
=$c8					INDX   = $C8         ; input [EOL] pointer
=$c9					ICRROW = $C9         ; input cursor row
=$ca					ICRCOL = $CA         ; input cursor column
=$cb					SFDX   = $CB         ; which key
=$cc					BLNSW  = $CC         ; cursor enable, $00 = flash cursor
=$cd					BLNCT  = $CD         ; cursor timing countdown
=$ce					GDBLN  = $CE         ; character under cursor
=$cf					BLNON  = $CF         ; cursor blink phase
=$d0					INSRC  = $D0         ; input from keyboard or screen
=$d1					LINPTR = $D1         ; current screen line pointer
=$d3					CSRIDX = $D3         ; cursor column
=$d4					CSRMOD = $D4         ; cursor quote flag
=$d5					LINLEN = $D5         ; current screen line length
=$d6					TBLX   = $D6         ; cursor row
=$d7					LASTKY = $D7         ; checksum byte/temporary last character
=$d8					INSRTO = $D8         ; insert count
=$d9					SLLTBL = $D9         ; to SLLTBL + $18 inclusive, screen line link table
=$f2					SCROWM = $F2         ; screen row marker
=$f3					USER   = $F3         ; colour RAM pointer
=$f5					KBDPTR = $F5         ; keyboard pointer
=$f7					RXPTR  = $F7         ; RS232 Rx pointer
=$f9					TXPTR  = $F9         ; RS232 Tx pointer
=$ff					BASSTO = $FF         ; FAC1 to string output base
=$0100					STACK  = $0100       ; bottom of the stack page
=$0200					BUF    = $0200       ;   input buffer. for some routines the byte before
=$0259					FILTBL = $0259       ;   .. to $0262 logical file table
=$0263					DEVTBL = $0263       ;   .. to $026C device number table
=$026d					SECATB = $026D       ;   .. to $0276 secondary address table
=$0277					KBUFFR = $0277       ;   .. to $0280 keyboard buffer
=$0281					OSSTAR = $0281       ;   OS start of memory low byte
=$0283					OSTOP  = $0283       ;   OS top of memory low byte
=$0285					STIMOT = $0285       ;   serial bus timeout flag
=$0286					COLOR  = $0286       ;   current colour code
=$0287					CSRCLR = $0287       ;   colour under cursor
=$0288					SCNMPG = $0288       ;   screen memory page
=$0289					KBMAXL = $0289       ;   maximum keyboard buffer size
=$028a					KEYRPT = $028A       ;   key repeat. $80 = repeat all, $40 = repeat none,
=$028b					KRPTSP = $028B       ;   repeat speed counter
=$028c					KRPTDL = $028C       ;   repeat delay counter
=$028d					SHFLAG   = $028D     ; keyboard shift/control flag
=$028e					LSTSHF   = $028E     ; SHIFT/CTRL/C= keypress last pattern
=$028f					KEYLOG   = $028F     ; keyboard decode logic pointer
=$0291					MODE     = $0291     ; shift mode switch, $00 = enabled, $80 = locked
=$0292					AUTODN   = $0292     ; screen scrolling flag, $00 = enabled
=$0293					M51CTR   = $0293     ; pseudo 6551 control register. the first character of
=$0294					M51CDR   = $0294     ; pseudo 6551 command register. the second character of
=$0295					M51AJB   = $0295     ; Nonstandard Bit Timing. the third and fourth character
=$0297					RSSTAT   = $0297     ; RS-232 status register
=$0298					BITNUM   = $0298     ; number of bits to be sent/received
=$0299					BAUDOF   = $0299     ; time of one bit cell
=$029b					RIDBE    = $029B     ; index to Rx buffer end
=$029c					RIDBS    = $029C     ; index to Rx buffer start
=$029d					RODBS    = $029D     ; index to Tx buffer start
=$029e					RODBE    = $029E     ; index to Tx buffer end
=$029f					IRQTMP   = $029F     ; saved IRQ
=$0300					IERROR   = $0300     ; vector to the print BASIC error message routine
=$0302					IMAIN    = $0302     ; Vector to the main BASIC program Loop
=$0304					ICRNCH   = $0304     ; Vector to the the ASCII text to keywords routine
=$0306					IQPLOP   = $0306     ; Vector to the list BASIC program as ASCII routine
=$0308					IGONE    = $0308     ; Vector to the execute next BASIC command routine
=$030a					IEVAL    = $030A     ; Vector to the get value from BASIC line routine
=$030c					SAREG    = $030C     ; A for SYS command
=$030d					SXREG    = $030D     ; X for SYS command
=$030e					SYREG    = $030E     ; Y for SYS command
=$030f					SPREG    = $030F     ; P for SYS command
=$0314					CINV     = $0314     ; IRQ vector
=$0316					CBINV    = $0316     ; BRK vector
=$0318					NMINV    = $0318     ; NMI vector
=$031a					IOPEN    = $031A     ; kernal vector - open a logical file
=$031c					ICLOSE   = $031C     ; kernal vector - close a logical file
=$031e					ICHKIN   = $031E     ; kernal vector - open channel for input
=$0320					ICKOUT   = $0320     ; kernal vector - open channel for output
=$0322					ICLRCH   = $0322     ; kernal vector - close input and output channels
=$0324					IBASIN   = $0324     ; kernal vector - input character from channel
=$0326					IBSOUT   = $0326     ; kernal vector - output character to channel
=$0328					ISTOP    = $0328     ; kernal vector - check if stop key is pressed
=$032a					IGETIN   = $032A     ; kernal vector - get character from keyboard queue
=$032c					ICLALL   = $032C     ; kernal vector - close all channels and files
=$032e					USRCMD   = $032E     ; kernal vector - user IRQ
=$0330					ILOAD    = $0330     ; kernal vector - load
=$0332					ISAVE    = $0332     ; kernal vector - save
=$033c					TBUFFR   = $033C     ; to $03FB - cassette buffer
=$9110					   IO_Base_Address = $9110
=$80					TK_END     = $80   ; END token
=$81					TK_FOR     = $81   ; FOR token
=$82					TK_NEXT    = $82   ; NEXT token
=$83					TK_DATA    = $83   ; DATA token
=$84					TK_INFL    = $84   ; INPUT# token
=$85					TK_INPUT   = $85   ; INPUT token
=$86					TK_DIM     = $86   ; DIM token
=$87					TK_READ    = $87   ; READ token
=$88					TK_LET     = $88   ; LET token
=$89					TK_GOTO    = $89   ; GOTO token
=$8a					TK_RUN     = $8A   ; RUN token
=$8b					TK_IF      = $8B   ; IF token
=$8c					TK_RESTORE = $8C   ; RESTORE token
=$8d					TK_GOSUB   = $8D   ; GOSUB token
=$8e					TK_RETURN  = $8E   ; RETURN token
=$8f					TK_REM     = $8F   ; REM token
=$90					TK_STOP    = $90   ; STOP token
=$91					TK_ON      = $91   ; ON token
=$92					TK_WAIT    = $92   ; WAIT token
=$93					TK_LOAD    = $93   ; LOAD token
=$94					TK_SAVE    = $94   ; SAVE token
=$95					TK_VERIFY  = $95   ; VERIFY token
=$96					TK_DEF     = $96   ; DEF token
=$97					TK_POKE    = $97   ; POKE token
=$98					TK_PRINFL  = $98   ; PRINT# token
=$99					TK_PRINT   = $99   ; PRINT token
=$9a					TK_CONT    = $9A   ; CONT token
=$9b					TK_LIST    = $9B   ; LIST token
=$9c					TK_CLR     = $9C   ; CLR token
=$9d					TK_CMD     = $9D   ; CMD token
=$9e					TK_SYS     = $9E   ; SYS token
=$9f					TK_OPEN    = $9F   ; OPEN token
=$a0					TK_CLOSE   = $A0   ; CLOSE token
=$a1					TK_GET     = $A1   ; GET token
=$a2					TK_NEW     = $A2   ; NEW token
=$a3					TK_TAB     = $A3   ; TAB( token
=$a4					TK_TO      = $A4   ; TO token
=$a5					TK_FN      = $A5   ; FN token
=$a6					TK_SPC     = $A6   ; SPC( token
=$a7					TK_THEN    = $A7   ; THEN token
=$a8					TK_NOT     = $A8   ; NOT token
=$a9					TK_STEP    = $A9   ; STEP token
=$aa					TK_PLUS    = $AA   ; + token
=$ab					TK_MINUS   = $AB   ; - token
=$ac					TK_MUL     = $AC   ; * token
=$ad					TK_DIV     = $AD   ; / token
=$ae					TK_POWER   = $AE   ; ^ token
=$af					TK_AND     = $AF   ; AND token
=$b0					TK_OR      = $B0   ; OR token
=$b1					TK_GT      = $B1   ; > token
=$b2					TK_EQUAL   = $B2   ; = token
=$b3					TK_LT      = $B3   ; < token
=$b4					TK_SGN     = $B4   ; SGN token
=$b5					TK_INT     = $B5   ; INT token
=$b6					TK_ABS     = $B6   ; ABS token
=$b7					TK_USR     = $B7   ; USR token
=$b8					TK_FRE     = $B8   ; FRE token
=$b9					TK_POS     = $B9   ; POS token
=$ba					TK_SQR     = $BA   ; SQR token
=$bb					TK_RND     = $BB   ; RND token
=$bc					TK_LOG     = $BC   ; LOG token
=$bd					TK_EXP     = $BD   ; EXP token
=$be					TK_COS     = $BE   ; COS token
=$bf					TK_SIN     = $BF   ; SIN token
=$c0					TK_TAN     = $C0   ; TAN token
=$c1					TK_ATN     = $C1   ; ATN token
=$c2					TK_PEEK    = $C2   ; PEEK token
=$c3					TK_LEN     = $C3   ; LEN token
=$c4					TK_STRS    = $C4   ; STR$ token
=$c5					TK_VAL     = $C5   ; VAL token
=$c6					TK_ASC     = $C6   ; ASC token
=$c7					TK_CHRS    = $C7   ; CHR$ token
=$c8					TK_LEFTS   = $C8   ; LEFT$ token
=$c9					TK_RIGHTS  = $C9   ; RIGHT$ token
=$ca					TK_MIDS    = $CA   ; MID$ token
=$cb					TK_GO      = $CB   ; GO token
=$ff					TK_PI      = $FF   ; PI token
>c000	78 e3				          .word   Basic_Cold_Start
>c002	67 e4				BASIC_BRK .word   Basic_Warm_Start
>c004	43 42 4d 42 41 53 49 43		BASIC_ID  .TEXT   "CBMBASIC"
.c00c					  Basic_Statement_Table
>c00c	30 c8				   .word Basic_END      -1; $80
>c00e	41 c7				   .word Basic_FOR      -1; $81
>c010	1d cd				   .word Basic_NEXT     -1; $82
>c012	f7 c8				   .word Basic_DATA     -1; $83
>c014	a4 cb				   .word Basic_INPUTN   -1; $84
>c016	be cb				   .word Basic_INPUT    -1; $85
>c018	80 d0				   .word Basic_DIM      -1; $86
>c01a	05 cc				   .word Basic_READ     -1; $87
>c01c	a4 c9				   .word Basic_LET      -1; $88
>c01e	9f c8				   .word Basic_GOTO     -1; $89
>c020	70 c8				   .word Basic_RUN      -1; $8A
>c022	27 c9				   .word Basic_IF       -1; $8B
>c024	1c c8				   .word Basic_RESTORE  -1; $8C
>c026	82 c8				   .word Basic_GOSUB    -1; $8D
>c028	d1 c8				   .word Basic_RETURN   -1; $8E
>c02a	3a c9				   .word Basic_REM      -1; $8F
>c02c	2e c8				   .word Basic_STOP     -1; $90
>c02e	4a c9				   .word Basic_ON       -1; $91
>c030	2c d8				   .word Basic_WAIT     -1; $92
>c032	64 e1				   .word Basic_LOAD     -1; $93
>c034	52 e1				   .word Basic_SAVE     -1; $94
>c036	61 e1				   .word Basic_VERIFY   -1; $95
>c038	b2 d3				   .word Basic_DEF      -1; $96
>c03a	23 d8				   .word Basic_POKE     -1; $97
>c03c	7f ca				   .word Basic_PRINTN   -1; $98
>c03e	9f ca				   .word Basic_PRINT    -1; $99
>c040	56 c8				   .word Basic_CONT     -1; $9A
>c042	9b c6				   .word Basic_LIST     -1; $9B
>c044	5d c6				   .word Basic_CLR      -1; $9C
>c046	85 ca				   .word Basic_CMD      -1; $9D
>c048	26 e1				   .word Basic_SYS      -1; $9E
>c04a	ba e1				   .word Basic_OPEN     -1; $9F
>c04c	c3 e1				   .word Basic_CLOSE    -1; $A0
>c04e	7a cb				   .word Basic_GET      -1; $A1
>c050	41 c6				   .word Basic_NEW      -1; $A2
.c052					  Basic_Function_Table
>c052	39 dc				   .word Basic_SGN   ; $B4
>c054	cc dc				   .word Basic_INT   ; $B5
>c056	58 dc				   .word Basic_ABS   ; $B6
>c058	00 00				   .word Basic_USR   ; $B7
>c05a	7d d3				   .word Basic_FRE   ; $B8
>c05c	9e d3				   .word Basic_POS   ; $B9
>c05e	71 df				   .word Basic_SQR   ; $BA
>c060	94 e0				   .word Basic_RND   ; $BB
>c062	ea d9				   .word Basic_LOG   ; $BC
>c064	ed df				   .word Basic_EXP   ; $BD
>c066	61 e2				   .word Basic_COS   ; $BE
>c068	68 e2				   .word Basic_SIN   ; $BF
>c06a	b1 e2				   .word Basic_TAN   ; $C0
>c06c	0b e3				   .word Basic_ATN   ; $C1
>c06e	0d d8				   .word Basic_PEEK  ; $C2
>c070	7c d7				   .word Basic_LEN   ; $C3
>c072	65 d4				   .word Basic_STR   ; $C4
>c074	ad d7				   .word Basic_VAL   ; $C5
>c076	8b d7				   .word Basic_ASC   ; $C6
>c078	ec d6				   .word Basic_CHR   ; $C7
>c07a	00 d7				   .word Basic_LEFT  ; $C8
>c07c	2c d7				   .word Basic_RIGHT ; $C9
>c07e	37 d7				   .word Basic_MID   ; $CA
.c080					  Basic_Operator_Table
>c080	79 69 d8			   .byte $79,<Basic_PLUS-1     ,>Basic_PLUS-1     ; $AA
>c083	79 52 d8			   .byte $79,<Basic_MINUS-1    ,>Basic_MINUS-1    ; $AB
>c086	7b 2a da			   .byte $7B,<Basic_MULTIPLY-1 ,>Basic_MULTIPLY-1 ; $AC
>c089	7b 11 db			   .byte $7B,<Basic_DIVIDE-1   ,>Basic_DIVIDE-1   ; $AD
>c08c	7f 7a df			   .byte $7F,<Basic_POWER-1    ,>Basic_POWER-1    ; $AE
>c08f	50 e8 cf			   .byte $50,<Basic_AND-1      ,>Basic_AND-1      ; $AF
>c092	46 e5 cf			   .byte $46,<Basic_OR-1       ,>Basic_OR-1       ; $B0
>c095	7d b3 df			   .byte $7D,<Basic_GREATER-1  ,>Basic_GREATER-1  ; $B1
>c098	5a d3 ce			   .byte $5A,<Basic_EQUAL-1    ,>Basic_EQUAL-1    ; $B2
>c09b	64 15 d0			   .byte $64,<Basic_LESS-1     ,>Basic_LESS-1     ; $B3
.c09e					  Basic_Keyword_Table
>c09e	45 4e c4			   .SHIFT   "END" ;^    ; END
>c0a1	46 4f d2			   .SHIFT   "FOR" ;^    ; FOR
>c0a4	4e 45 58 d4			   .SHIFT   "NEXT" ;^   ; NEXT
>c0a8	44 41 54 c1			   .SHIFT   "DATA" ;^   ; DATA
>c0ac	49 4e 50 55 54 a3		   .SHIFT   "INPUT#" ;^ ; INPUT#
>c0b2	49 4e 50 55 d4			   .SHIFT   "INPUT" ;^  ; INPUT
>c0b7	44 49 cd			   .SHIFT   "DIM" ;^    ; DIM
>c0ba	52 45 41 c4			   .SHIFT   "READ" ;^   ; READ
>c0be	4c 45 d4			   .SHIFT   "LET" ;^    ; LET
>c0c1	47 4f 54 cf			   .SHIFT   "GOTO" ;^   ; GOTO
>c0c5	52 55 ce			   .SHIFT   "RUN" ;^    ; RUN
>c0c8	49 c6				   .SHIFT   "IF" ;^     ; IF
>c0ca	52 45 53 54 4f 52 c5		   .SHIFT   "RESTORE" ;^; RESTORE
>c0d1	47 4f 53 55 c2			   .SHIFT   "GOSUB" ;^  ; GOSUB
>c0d6	52 45 54 55 52 ce		   .SHIFT   "RETURN" ;^ ; RETURN
>c0dc	52 45 cd			   .SHIFT   "REM" ;^    ; REM
>c0df	53 54 4f d0			   .SHIFT   "STOP" ;^   ; STOP
>c0e3	4f ce				   .SHIFT   "ON" ;^     ; ON
>c0e5	57 41 49 d4			   .SHIFT   "WAIT" ;^   ; WAIT
>c0e9	4c 4f 41 c4			   .SHIFT   "LOAD" ;^   ; LOAD
>c0ed	53 41 56 c5			   .SHIFT   "SAVE" ;^   ; SAVE
>c0f1	56 45 52 49 46 d9		   .SHIFT   "VERIFY" ;^ ; VERIFY
>c0f7	44 45 c6			   .SHIFT   "DEF" ;^    ; DEF
>c0fa	50 4f 4b c5			   .SHIFT   "POKE" ;^   ; POKE
>c0fe	50 52 49 4e 54 a3		   .SHIFT   "PRINT#" ;^ ; PRINT#
>c104	50 52 49 4e d4			   .SHIFT   "PRINT" ;^  ; PRINT
>c109	43 4f 4e d4			   .SHIFT   "CONT" ;^   ; CONT
>c10d	4c 49 53 d4			   .SHIFT   "LIST" ;^   ; LIST
>c111	43 4c d2			   .SHIFT   "CLR" ;^    ; CLR
>c114	43 4d c4			   .SHIFT   "CMD" ;^    ; CMD
>c117	53 59 d3			   .SHIFT   "SYS" ;^    ; SYS
>c11a	4f 50 45 ce			   .SHIFT   "OPEN" ;^   ; OPEN
>c11e	43 4c 4f 53 c5			   .SHIFT   "CLOSE" ;^  ; CLOSE
>c123	47 45 d4			   .SHIFT   "GET" ;^    ; GET
>c126	4e 45 d7			   .SHIFT   "NEW" ;^    ; NEW
>c129	54 41 42 a8			   .SHIFT   "TAB(" ;^   ; TAB(
>c12d	54 cf				   .SHIFT   "TO" ;^     ; TO
>c12f	46 ce				   .SHIFT   "FN" ;^     ; FN
>c131	53 50 43 a8			   .SHIFT   "SPC(" ;^   ; SPC(
>c135	54 48 45 ce			   .SHIFT   "THEN" ;^   ; THEN
>c139	4e 4f d4			   .SHIFT   "NOT" ;^    ; NOT
>c13c	53 54 45 d0			   .SHIFT   "STEP" ;^   ; STEP
>c140	ab				   .SHIFT   "+" ;^      ; +
>c141	ad				   .SHIFT   "-" ;^      ; -
>c142	aa				   .SHIFT   "*" ;^      ; *
>c143	af				   .SHIFT   "/" ;^      ; /
>c144	de				   .SHIFT   "^" ;^      ; ^
>c145	41 4e c4			   .SHIFT   "AND" ;^    ; AND
>c148	4f d2				   .SHIFT   "OR" ;^     ; OR
>c14a	be				   .SHIFT   ">" ;^      ; >
>c14b	bd				   .SHIFT   "=" ;^      ; =
>c14c	bc				   .SHIFT   "<" ;^      ; <
>c14d	53 47 ce			   .SHIFT   "SGN" ;^    ; SGN
>c150	49 4e d4			   .SHIFT   "INT" ;^    ; INT
>c153	41 42 d3			   .SHIFT   "ABS" ;^    ; ABS
>c156	55 53 d2			   .SHIFT   "USR" ;^    ; USR
>c159	46 52 c5			   .SHIFT   "FRE" ;^    ; FRE
>c15c	50 4f d3			   .SHIFT   "POS" ;^    ; POS
>c15f	53 51 d2			   .SHIFT   "SQR" ;^    ; SQR
>c162	52 4e c4			   .SHIFT   "RND" ;^    ; RND
>c165	4c 4f c7			   .SHIFT   "LOG" ;^    ; LOG
>c168	45 58 d0			   .SHIFT   "EXP" ;^    ; EXP
>c16b	43 4f d3			   .SHIFT   "COS" ;^    ; COS
>c16e	53 49 ce			   .SHIFT   "SIN" ;^    ; SIN
>c171	54 41 ce			   .SHIFT   "TAN" ;^    ; TAN
>c174	41 54 ce			   .SHIFT   "ATN" ;^    ; ATN
>c177	50 45 45 cb			   .SHIFT   "PEEK" ;^   ; PEEK
>c17b	4c 45 ce			   .SHIFT   "LEN" ;^    ; LEN
>c17e	53 54 52 a4			   .SHIFT   "STR$" ;^   ; STR$
>c182	56 41 cc			   .SHIFT   "VAL" ;^    ; VAL
>c185	41 53 c3			   .SHIFT   "ASC" ;^    ; ASC
>c188	43 48 52 a4			   .SHIFT   "CHR$" ;^   ; CHR$
>c18c	4c 45 46 54 a4			   .SHIFT   "LEFT$" ;^  ; LEFT$
>c191	52 49 47 48 54 a4		   .SHIFT   "RIGHT$" ;^ ; RIGHT$
>c197	4d 49 44 a4			   .SHIFT   "MID$" ;^   ; MID$
>c19b	47 cf				   .SHIFT   "GO" ;^     ; GO so that GO TO, as well as GOTO, will work
>c19d	00				   .BYTE   $00       ; end marker
>c19e	54 4f 4f 20 4d 41 4e 59		ERR_01 .SHIFT   "TOO MANY FILES" ;^
>c1a6	20 46 49 4c 45 d3
>c1ac	46 49 4c 45 20 4f 50 45		ERR_02 .SHIFT   "FILE OPEN" ;^
>c1b4	ce
>c1b5	46 49 4c 45 20 4e 4f 54		ERR_03 .SHIFT   "FILE NOT OPEN" ;^
>c1bd	20 4f 50 45 ce
>c1c2	46 49 4c 45 20 4e 4f 54		ERR_04 .SHIFT   "FILE NOT FOUND" ;^
>c1ca	20 46 4f 55 4e c4
>c1d0	44 45 56 49 43 45 20 4e		ERR_05 .SHIFT   "DEVICE NOT PRESENT" ;^
>c1d8	4f 54 20 50 52 45 53 45 4e d4
>c1e2	4e 4f 54 20 49 4e 50 55		ERR_06 .SHIFT   "NOT INPUT FILE" ;^
>c1ea	54 20 46 49 4c c5
>c1f0	4e 4f 54 20 4f 55 54 50		ERR_07 .SHIFT   "NOT OUTPUT FILE" ;^
>c1f8	55 54 20 46 49 4c c5
>c1ff	4d 49 53 53 49 4e 47 20		ERR_08 .SHIFT   "MISSING FILE NAME" ;^
>c207	46 49 4c 45 20 4e 41 4d c5
>c210	49 4c 4c 45 47 41 4c 20		ERR_09 .SHIFT   "ILLEGAL DEVICE NUMBER" ;^
>c218	44 45 56 49 43 45 20 4e 55 4d 42 45 d2
>c225	4e 45 58 54 20 57 49 54		ERR_0A .SHIFT   "NEXT WITHOUT FOR" ;^
>c22d	48 4f 55 54 20 46 4f d2
>c235	53 59 4e 54 41 d8		ERR_0B .SHIFT   "SYNTAX" ;^
>c23b	52 45 54 55 52 4e 20 57		ERR_0C .SHIFT   "RETURN WITHOUT GOSUB" ;^
>c243	49 54 48 4f 55 54 20 47 4f 53 55 c2
>c24f	4f 55 54 20 4f 46 20 44		ERR_0D .SHIFT   "OUT OF DATA" ;^
>c257	41 54 c1
>c25a	49 4c 4c 45 47 41 4c 20		ERR_0E .SHIFT   "ILLEGAL QUANTITY" ;^
>c262	51 55 41 4e 54 49 54 d9
>c26a	4f 56 45 52 46 4c 4f d7		ERR_0F .SHIFT   "OVERFLOW" ;^
>c272	4f 55 54 20 4f 46 20 4d		ERR_10 .SHIFT   "OUT OF MEMORY" ;^
>c27a	45 4d 4f 52 d9
>c27f	55 4e 44 45 46 27 44 20		ERR_11 .SHIFT   "UNDEF'D STATEMENT" ;^
>c287	53 54 41 54 45 4d 45 4e d4
>c290	42 41 44 20 53 55 42 53		ERR_12 .SHIFT   "BAD SUBSCRIPT" ;^
>c298	43 52 49 50 d4
>c29d	52 45 44 49 4d 27 44 20		ERR_13 .SHIFT   "REDIM'D ARRAY" ;^
>c2a5	41 52 52 41 d9
>c2aa	44 49 56 49 53 49 4f 4e		ERR_14 .SHIFT   "DIVISION BY ZERO" ;^
>c2b2	20 42 59 20 5a 45 52 cf
>c2ba	49 4c 4c 45 47 41 4c 20		ERR_15 .SHIFT   "ILLEGAL DIRECT" ;^
>c2c2	44 49 52 45 43 d4
>c2c8	54 59 50 45 20 4d 49 53		ERR_16 .SHIFT   "TYPE MISMATCH" ;^
>c2d0	4d 41 54 43 c8
>c2d5	53 54 52 49 4e 47 20 54		ERR_17 .SHIFT   "STRING TOO LONG" ;^
>c2dd	4f 4f 20 4c 4f 4e c7
>c2e4	46 49 4c 45 20 44 41 54		ERR_18 .SHIFT   "FILE DATA" ;^
>c2ec	c1
>c2ed	46 4f 52 4d 55 4c 41 20		ERR_19 .SHIFT   "FORMULA TOO COMPLEX" ;^
>c2f5	54 4f 4f 20 43 4f 4d 50 4c 45 d8
>c300	43 41 4e 27 54 20 43 4f		ERR_1A .SHIFT   "CAN'T CONTINUE" ;^
>c308	4e 54 49 4e 55 c5
>c30e	55 4e 44 45 46 27 44 20		ERR_1B .SHIFT   "UNDEF'D FUNCTION" ;^
>c316	46 55 4e 43 54 49 4f ce
>c31e	56 45 52 49 46 d9		ERR_1C .SHIFT   "VERIFY" ;^
>c324	4c 4f 41 c4			ERR_1D .SHIFT   "LOAD" ;^
.c328					Basic_Msg_Tab
>c328	9e c1				   .word   ERR_01  ; TOO MANY FILES
>c32a	ac c1				   .word   ERR_02  ; FILE OPEN
>c32c	b5 c1				   .word   ERR_03  ; FILE NOT OPEN
>c32e	c2 c1				   .word   ERR_04  ; FILE NOT FOUND
>c330	d0 c1				   .word   ERR_05  ; DEVICE NOT PRESENT
>c332	e2 c1				   .word   ERR_06  ; NOT INPUT FILE
>c334	f0 c1				   .word   ERR_07  ; NOT OUTPUT FILE
>c336	ff c1				   .word   ERR_08  ; MISSING FILE NAME
>c338	10 c2				   .word   ERR_09  ; ILLEGAL DEVICE NUMBER
>c33a	25 c2				   .word   ERR_0A  ; NEXT WITHOUT FOR
>c33c	35 c2				   .word   ERR_0B  ; SYNTAX
>c33e	3b c2				   .word   ERR_0C  ; RETURN WITHOUT GOSUB
>c340	4f c2				   .word   ERR_0D  ; OUT OF DATA
>c342	5a c2				   .word   ERR_0E  ; ILLEGAL QUANTITY
>c344	6a c2				   .word   ERR_0F  ; OVERFLOW
>c346	72 c2				   .word   ERR_10  ; OUT OF MEMORY
>c348	7f c2				   .word   ERR_11  ; UNDEF'D STATEMENT
>c34a	90 c2				   .word   ERR_12  ; BAD SUBSCRIPT
>c34c	9d c2				   .word   ERR_13  ; REDIM'D ARRAY
>c34e	aa c2				   .word   ERR_14  ; DIVISION BY ZERO
>c350	ba c2				   .word   ERR_15  ; ILLEGAL DIRECT
>c352	c8 c2				   .word   ERR_16  ; TYPE MISMATCH
>c354	d5 c2				   .word   ERR_17  ; STRING TOO LONG
>c356	e4 c2				   .word   ERR_18  ; FILE DATA
>c358	ed c2				   .word   ERR_19  ; FORMULA TOO COMPLEX
>c35a	00 c3				   .word   ERR_1A  ; CAN'T CONTINUE
>c35c	0e c3				   .word   ERR_1B  ; UNDEF'D FUNCTION
>c35e	1e c3				   .word   ERR_1C  ; VERIFY
>c360	24 c3				   .word   ERR_1D  ; LOAD
>c362	83 c3				   .word   Msg_Break
>c364	0d 4f 4b 0d 00			Msg_OK    .TEXT   "\rOK\r",0
>c369	0d 20 45 52 52 4f 52 00		Msg_Err   .TEXT   "\r ERROR",0
>c371	20 49 4e 20 00			Msg_IN    .TEXT   " IN ",0
>c376	0d 0a 52 45 41 44 59 2e		Msg_Ready .TEXT   "\r\nREADY.\r\n",0
>c37e	0d 0a 00
>c381	0d 0a				Msg_CrLf  .TEXT   "\r\n"
>c383	42 52 45 41 4b 00		Msg_Break .TEXT   "BREAK",0
>c389	a0				   .byte $A0 ; unused
.c38a					  Find_Active_FOR
.c38a	ba		tsx		   TSX               ; copy stack pointer
.c38b	e8		inx		   INX               ; +1 pass return address
.c38c	e8		inx		   INX               ; +2 pass return address
.c38d	e8		inx		   INX               ; +3 pass calling routine return address
.c38e	e8		inx		   INX               ; +4 pass calling routine return address
.c38f					FAF_Loop
.c38f	bd 01 01	lda $0101,x	   LDA STACK+1,X     ; get token byte from stack
.c392	c9 81		cmp #$81	   CMP #TK_FOR       ; is it FOR token
.c394	d0 21		bne $c3b7	   BNE FAF_Ret       ; exit if not FOR token
.c396	a5 4a		lda $4a		   LDA FORPNT+1      ; get FOR/NEXT variable pointer high byte
.c398	d0 0a		bne $c3a4	   BNE FAF_10        ; branch if defined
.c39a	bd 02 01	lda $0102,x	   LDA STACK+2,X     ; get FOR variable pointer low byte
.c39d	85 49		sta $49		   STA FORPNT        ; save FOR/NEXT variable pointer low byte
.c39f	bd 03 01	lda $0103,x	   LDA STACK+3,X     ; get FOR variable pointer high byte
.c3a2	85 4a		sta $4a		   STA FORPNT+1      ; save FOR/NEXT variable pointer high byte
.c3a4					FAF_10
.c3a4	dd 03 01	cmp $0103,x	   CMP STACK+3,X     ; compare variable pointer with stacked variable pointer
.c3a7	d0 07		bne $c3b0	   BNE FAF_20        ; branch if no match
.c3a9	a5 49		lda $49		   LDA FORPNT        ; get FOR/NEXT variable pointer low byte
.c3ab	dd 02 01	cmp $0102,x	   CMP STACK+2,X     ; compare variable pointer with stacked variable pointer
.c3ae	f0 07		beq $c3b7	   BEQ FAF_Ret       ; exit if match found
.c3b0					FAF_20
.c3b0	8a		txa		   TXA               ; copy index
.c3b1	18		clc		   CLC
.c3b2	69 12		adc #$12	   ADC #18           ; add FOR stack use size
.c3b4	aa		tax		   TAX               ; copy back to index
.c3b5	d0 d8		bne $c38f	   BNE FAF_Loop
.c3b7					FAF_Ret
.c3b7	60		rts		   RTS
.c3b8					  Open_Up_Space
.c3b8	20 08 c4	jsr $c408	   JSR Check_Mem_Avail
.c3bb	85 31		sta $31		   STA STREND
.c3bd	84 32		sty $32		   STY STREND+1
.c3bf					  Move_Block
.c3bf	38		sec		   SEC
.c3c0	a5 5a		lda $5a		   LDA TMPPTB        ; get block end low byte
.c3c2	e5 5f		sbc $5f		   SBC TMPPTC        ; subtract block start low byte
.c3c4	85 22		sta $22		   STA INDEXA        ; save MOD(block length/$100) byte
.c3c6	a8		tay		   TAY               ; copy MOD(block length/$100) byte to Y
.c3c7	a5 5b		lda $5b		   LDA TMPPTB+1      ; get block end high byte
.c3c9	e5 60		sbc $60		   SBC TMPPTC+1      ; subtract block start high byte
.c3cb	aa		tax		   TAX               ; copy block length high byte to X
.c3cc	e8		inx		   INX               ; +1 to allow for count=0 exit
.c3cd	98		tya		   TYA               ; copy block length low byte to A
.c3ce	f0 23		beq $c3f3	   BEQ MoBl_20       ; branch if length low byte=0
.c3d0	a5 5a		lda $5a		   LDA TMPPTB        ; get block end low byte
.c3d2	38		sec		   SEC
.c3d3	e5 22		sbc $22		   SBC INDEXA        ; subtract MOD(block length/$100) byte
.c3d5	85 5a		sta $5a		   STA TMPPTB        ; save corrected old block end low byte
.c3d7	b0 03		bcs $c3dc	   BCS MoBl_10       ; if no underflow skip the high byte decrement
.c3d9	c6 5b		dec $5b		   DEC TMPPTB+1      ; else decrement block end high byte
.c3db	38		sec		   SEC
.c3dc					MoBl_10
.c3dc	a5 58		lda $58		   LDA TMPPTA        ; get destination end low byte
.c3de	e5 22		sbc $22		   SBC INDEXA        ; subtract MOD(block length/$100) byte
.c3e0	85 58		sta $58		   STA TMPPTA        ; save modified new block end low byte
.c3e2	b0 08		bcs $c3ec	   BCS MoBl_Loop_X   ; if no underflow skip the high byte decrement
.c3e4	c6 59		dec $59		   DEC TMPPTA+1      ; else decrement block end high byte
.c3e6	90 04		bcc $c3ec	   BCC MoBl_Loop_X   ; branch always
.c3e8					MoBl_Loop_Y
.c3e8	b1 5a		lda ($5a),y	   LDA (TMPPTB),Y    ; get byte from source
.c3ea	91 58		sta ($58),y	   STA (TMPPTA),Y    ; copy byte to destination
.c3ec					MoBl_Loop_X
.c3ec	88		dey		   DEY
.c3ed	d0 f9		bne $c3e8	   BNE MoBl_Loop_Y
.c3ef	b1 5a		lda ($5a),y	   LDA (TMPPTB),Y    ; get byte from source
.c3f1	91 58		sta ($58),y	   STA (TMPPTA),Y    ; save byte to destination
.c3f3					MoBl_20
.c3f3	c6 5b		dec $5b		   DEC TMPPTB+1      ; decrement source pointer high byte
.c3f5	c6 59		dec $59		   DEC TMPPTA+1      ; decrement destination pointer high byte
.c3f7	ca		dex		   DEX               ; decrement block count
.c3f8	d0 f2		bne $c3ec	   BNE MoBl_Loop_X   ; loop until count = $0
.c3fa	60		rts		   RTS
.c3fb					  Check_Stack_Avail
.c3fb	0a		asl a		   ASL A
.c3fc	69 3e		adc #$3e	   ADC #$3E          ; need at least $3E bytes free
.c3fe	b0 35		bcs $c435	   BCS Error_Out_Of_Memory
.c400	85 22		sta $22		   STA INDEXA        ; save result in temp byte
.c402	ba		tsx		   TSX               ; copy stack
.c403	e4 22		cpx $22		   CPX INDEXA        ; compare new limit with stack
.c405	90 2e		bcc $c435	   BCC Error_Out_Of_Memory
.c407	60		rts		   RTS
.c408					  Check_Mem_Avail
.c408	c4 34		cpy $34		   CPY FRESPC+1      ; compare with bottom of string space high byte
.c40a	90 28		bcc $c434	   BCC CMA_Ret       ; if less then OK
.c40c	d0 04		bne $c412	   BNE CMA_10        ; skip next test if greater (tested <)
.c40e	c5 33		cmp $33		   CMP FRESPC        ; compare with bottom of string space low byte
.c410	90 22		bcc $c434	   BCC CMA_Ret       ; if less then OK
.c412					CMA_10
.c412	48		pha		   PHA               ; push address low byte
.c413	a2 09		ldx #$09	   LDX #9            ; set index to save 10 bytes (FACTPA & FACTPB)
.c415	98		tya		   TYA               ; copy address high byte (to push on stack)
.c416					CMA_Loop_X
.c416	48		pha		   PHA               ; push byte
.c417	b5 57		lda $57,x	   LDA FACTPA,X      ; get byte from FACTPA to TMPPTC+1
.c419	ca		dex		   DEX
.c41a	10 fa		bpl $c416	   BPL CMA_Loop_X
.c41c	20 26 d5	jsr $d526	   JSR Garbage_Collection
.c41f	a2 f7		ldx #$f7	   LDX #$F7          ; use zero page wrap around
.c421					CMA_Loop_2
.c421	68		pla		   PLA               ; pop byte
.c422	95 61		sta $61,x	   STA FAC1EX,X      ; save byte from FACTPA to FAC1
.c424	e8		inx		   INX               ; increment index
.c425	30 fa		bmi $c421	   BMI CMA_Loop_2
.c427	68		pla		   PLA               ; pop address high byte
.c428	a8		tay		   TAY               ; copy back to Y
.c429	68		pla		   PLA               ; pop address low byte
.c42a	c4 34		cpy $34		   CPY FRESPC+1      ; compare with bottom of string space high byte
.c42c	90 06		bcc $c434	   BCC CMA_Ret       ; if less then OK
.c42e	d0 05		bne $c435	   BNE Error_Out_Of_Memory
.c430	c5 33		cmp $33		   CMP FRESPC
.c432	b0 01		bcs $c435	   BCS Error_Out_Of_Memory
.c434					CMA_Ret
.c434	60		rts		   RTS
.c435					  Error_Out_Of_Memory
.c435	a2 10		ldx #$10	   LDX #$10          ; error code $10, out of memory error
.c437					  Basic_Error
.c437	6c 00 03	jmp ($0300)	   JMP (IERROR)      ; normally next statement
.c43a					  Default_Error
.c43a	8a		txa		   TXA               ; copy error number
.c43b	0a		asl a		   ASL A             ; *2
.c43c	aa		tax		   TAX               ; copy to index
.c43d	bd 26 c3	lda $c326,x	   LDA Basic_Msg_Tab-2,X  ; get error message pointer low byte
.c440	85 22		sta $22		   STA INDEXA        ; save it
.c442	bd 27 c3	lda $c327,x	   LDA Basic_Msg_Tab-1,X  ; get error message pointer high byte
.c445	85 23		sta $23		   STA INDEXA+1      ; save it
.c447	20 cc ff	jsr $ffcc	   JSR CLRCHN        ; Clear I/O channels
.c44a	a9 00		lda #$00	   LDA #0
.c44c	85 13		sta $13		   STA IOPMPT        ; clear current I/O channel, flag default
.c44e	20 d7 ca	jsr $cad7	   JSR Print_CR
.c451	20 45 cb	jsr $cb45	   JSR Print_Question_Mark
.c454	a0 00		ldy #$00	   LDY #0
.c456					DeEr_Loop
.c456	b1 22		lda ($22),y	   LDA (INDEXA),Y    ; get byte from message
.c458	48		pha		   PHA               ; save status
.c459	29 7f		and #$7f	   AND #$7F          ; mask 0xxx xxxx, clear b7
.c45b	20 47 cb	jsr $cb47	   JSR Print_Char
.c45e	c8		iny		   INY
.c45f	68		pla		   PLA               ; restore status
.c460	10 f4		bpl $c456	   BPL DeEr_Loop
.c462	20 7a c6	jsr $c67a	   JSR Flush_BASIC_Stack
.c465	a9 69		lda #$69	   LDA #<Msg_Err ;#<addr
.c467	a0 c3		ldy #$c3	   LDY #>Msg_Err ;#>addr
.c469					  Display_Msg_Then_Ready
.c469	20 1e cb	jsr $cb1e	   JSR Print_String
.c46c	a4 3a		ldy $3a		   LDY CURLIN+1      ; get current line number high byte
.c46e	c8		iny		   INY               ; increment it
.c46f	f0 03		beq $c474	   BEQ Basic_Ready   ; CURLIN+1 was $FF = direct mode
.c471	20 c2 dd	jsr $ddc2	   JSR Print_IN
.c474					  Basic_Ready
.c474	a9 76		lda #$76	   LDA #<Msg_Ready
.c476	a0 c3		ldy #$c3	   LDY #>Msg_Ready
.c478	20 1e cb	jsr $cb1e	   JSR Print_String
.c47b	a9 80		lda #$80	   LDA #$80          ; set for control messages only
.c47d	20 90 ff	jsr $ff90	   JSR SETMSG        ; control kernal messages
.c480					  Vectored_Warmstart
.c480	6c 02 03	jmp ($0302)	   JMP (IMAIN)       ; normally next statement
.c483					  Default_Warmstart
.c483	20 60 c5	jsr $c560	   JSR Read_String
.c486	86 7a		stx $7a		   STX TXTPTR
.c488	84 7b		sty $7b		   STY TXTPTR+1
.c48a	20 73 00	jsr $0073	   JSR CHRGET
.c48d	aa		tax		   TAX               ; copy byte to set flags
.c48e	f0 f0		beq $c480	   BEQ Vectored_Warmstart ; loop if no input
.c490	a2 ff		ldx #$ff	   LDX #-1           ; indicates direct mode
.c492	86 3a		stx $3a		   STX CURLIN+1
.c494	90 06		bcc $c49c	   BCC New_Basic_Line
.c496					Direct_Call
.c496	20 79 c5	jsr $c579	   JSR Tokenize_Line
.c499	4c e1 c7	jmp $c7e1	   JMP Start_Program
.c49c					  New_Basic_Line
.c49c	20 6b c9	jsr $c96b	   JSR Scan_Linenumber
.c49f	20 79 c5	jsr $c579	   JSR Tokenize_Line
.c4a2	84 0b		sty $0b		   STY COUNT         ; save index pointer to end of crunched line
.c4a4	20 13 c6	jsr $c613	   JSR Find_BASIC_Line
.c4a7	90 44		bcc $c4ed	   BCC NBL_20        ; if not found skip the line delete
.c4a9	a0 01		ldy #$01	   LDY #1            ; set index to next line pointer high byte
.c4ab	b1 5f		lda ($5f),y	   LDA (TMPPTC),Y    ; get next line pointer high byte
.c4ad	85 23		sta $23		   STA INDEXA+1      ; save it
.c4af	a5 2d		lda $2d		   LDA VARTAB        ; get start of variables low byte
.c4b1	85 22		sta $22		   STA INDEXA        ; save it
.c4b3	a5 60		lda $60		   LDA TMPPTC+1      ; get found line pointer high byte
.c4b5	85 25		sta $25		   STA INDEXB+1      ; save it
.c4b7	a5 5f		lda $5f		   LDA TMPPTC        ; get found line pointer low byte
.c4b9	88		dey		   DEY               ; decrement index
.c4ba	f1 5f		sbc ($5f),y	   SBC (TMPPTC),Y    ; subtract next line pointer low byte
.c4bc	18		clc		   CLC
.c4bd	65 2d		adc $2d		   ADC VARTAB        ; add start of variables low byte
.c4bf	85 2d		sta $2d		   STA VARTAB        ; set start of variables low byte
.c4c1	85 24		sta $24		   STA INDEXB        ; save destination pointer low byte
.c4c3	a5 2e		lda $2e		   LDA VARTAB+1      ; get start of variables high byte
.c4c5	69 ff		adc #$ff	   ADC #$FF          ; -1 + carry
.c4c7	85 2e		sta $2e		   STA VARTAB+1      ; set start of variables high byte
.c4c9	e5 60		sbc $60		   SBC TMPPTC+1      ; subtract found line pointer high byte
.c4cb	aa		tax		   TAX               ; copy to block count
.c4cc	38		sec		   SEC
.c4cd	a5 5f		lda $5f		   LDA TMPPTC        ; get found line pointer low byte
.c4cf	e5 2d		sbc $2d		   SBC VARTAB        ; subtract start of variables low byte
.c4d1	a8		tay		   TAY               ; copy to bytes in first block count
.c4d2	b0 03		bcs $c4d7	   BCS NBL_10        ; if no underflow skip the high byte decrement
.c4d4	e8		inx		   INX               ; increment block count, correct for = 0 loop exit
.c4d5	c6 25		dec $25		   DEC INDEXB+1      ; decrement destination high byte
.c4d7					NBL_10
.c4d7	18		clc		   CLC
.c4d8	65 22		adc $22		   ADC INDEXA        ; add source pointer low byte
.c4da	90 03		bcc $c4df	   BCC NBL_Loop      ; if no underflow skip the high byte decrement
.c4dc	c6 23		dec $23		   DEC INDEXA+1      ; else decrement source pointer high byte
.c4de	18		clc		   CLC
.c4df					NBL_Loop
.c4df	b1 22		lda ($22),y	   LDA (INDEXA),Y    ; get byte from source
.c4e1	91 24		sta ($24),y	   STA (INDEXB),Y    ; copy to destination
.c4e3	c8		iny		   INY
.c4e4	d0 f9		bne $c4df	   BNE NBL_Loop      ; while <> 0 do this block
.c4e6	e6 23		inc $23		   INC INDEXA+1      ; increment source pointer high byte
.c4e8	e6 25		inc $25		   INC INDEXB+1      ; increment destination pointer high byte
.c4ea	ca		dex		   DEX               ; decrement block count
.c4eb	d0 f2		bne $c4df	   BNE NBL_Loop      ; loop until all done
.c4ed					NBL_20
.c4ed	20 59 c6	jsr $c659	   JSR Reset_BASIC_Execution
.c4f0	20 33 c5	jsr $c533	   JSR Rechain
.c4f3	ad 00 02	lda $0200	   LDA BUF           ; get first byte from buffer
.c4f6	f0 88		beq $c480	   BEQ Vectored_Warmstart
.c4f8	18		clc		   CLC               ; insert line into memory
.c4f9	a5 2d		lda $2d		   LDA VARTAB        ; get start of variables low byte
.c4fb	85 5a		sta $5a		   STA TMPPTB        ; save as source end pointer low byte
.c4fd	65 0b		adc $0b		   ADC COUNT         ; add index pointer to end of crunched line
.c4ff	85 58		sta $58		   STA TMPPTA        ; save as destination end pointer low byte
.c501	a4 2e		ldy $2e		   LDY VARTAB+1      ; get start of variables high byte
.c503	84 5b		sty $5b		   STY TMPPTB+1      ; save as source end pointer high byte
.c505	90 01		bcc $c508	   BCC NBL_30      ; if no carry skip the high byte increment
.c507	c8		iny		   INY               ; else increment the high byte
.c508					NBL_30
.c508	84 59		sty $59		   STY TMPPTA+1      ; save as destination end pointer high byte
.c50a	20 b8 c3	jsr $c3b8	   JSR Open_Up_Space
.c50d	a5 14		lda $14		   LDA LINNUM
.c50f	a4 15		ldy $15		   LDY LINNUM+1
.c511	8d fe 01	sta $01fe	   STA BUF-2         ; save line number low byte before crunched line
.c514	8c ff 01	sty $01ff	   STY BUF-1         ; save line number high byte before crunched line
.c517	a5 31		lda $31		   LDA STREND
.c519	a4 32		ldy $32		   LDY STREND+1
.c51b	85 2d		sta $2d		   STA VARTAB
.c51d	84 2e		sty $2e		   STY VARTAB+1
.c51f	a4 0b		ldy $0b		   LDY COUNT         ; get index to end of crunched line
.c521	88		dey		   DEY               ; -1
.c522					NBL_Copy
.c522	b9 fc 01	lda $01fc,y	   LDA BUF-4,Y       ; get byte from crunched line
.c525	91 5f		sta ($5f),y	   STA (TMPPTC),Y    ; save byte to memory
.c527	88		dey		   DEY               ; decrement index
.c528	10 f8		bpl $c522	   BPL NBL_Copy      ; loop while more to do
.c52a					  Reset_And_Rechain
.c52a	20 59 c6	jsr $c659	   JSR Reset_BASIC_Execution
.c52d	20 33 c5	jsr $c533	   JSR Rechain
.c530	4c 80 c4	jmp $c480	   JMP Vectored_Warmstart
.c533					  Rechain
.c533	a5 2b		lda $2b		   LDA TXTTAB
.c535	a4 2c		ldy $2c		   LDY TXTTAB+1
.c537	85 22		sta $22		   STA INDEXA
.c539	84 23		sty $23		   STY INDEXA+1
.c53b	18		clc		   CLC
.c53c					Rech_Loop
.c53c	a0 01		ldy #$01	   LDY #1            ; set index to pointer to next line high byte
.c53e	b1 22		lda ($22),y	   LDA (INDEXA),Y    ; get pointer to next line high byte
.c540	f0 1d		beq $c55f	   BEQ Rech_Ret      ; exit if null, [EOT]
.c542	a0 04		ldy #$04	   LDY #4            ; point to first code byte of line
.c544					Rech_Loop_2
.c544	c8		iny		   INY               ; next code byte
.c545	b1 22		lda ($22),y	   LDA (INDEXA),Y    ; get byte
.c547	d0 fb		bne $c544	   BNE Rech_Loop_2   ; loop if not [EOL]
.c549	c8		iny		   INY               ; point to byte past [EOL], start of next line
.c54a	98		tya		   TYA               ; copy it
.c54b	65 22		adc $22		   ADC INDEXA        ; add line start pointer low byte
.c54d	aa		tax		   TAX               ; copy to X
.c54e	a0 00		ldy #$00	   LDY #0            ; point to this line's next line pointer
.c550	91 22		sta ($22),y	   STA (INDEXA),Y    ; set next line pointer low byte
.c552	a5 23		lda $23		   LDA INDEXA+1      ; get line start pointer high byte
.c554	69 00		adc #$00	   ADC #$00          ; add any overflow
.c556	c8		iny		   INY
.c557	91 22		sta ($22),y	   STA (INDEXA),Y    ; set next line pointer high byte
.c559	86 22		stx $22		   STX INDEXA        ; set line start pointer low byte
.c55b	85 23		sta $23		   STA INDEXA+1      ; set line start pointer high byte
.c55d	90 dd		bcc $c53c	   BCC Rech_Loop     ; branch always
.c55f					Rech_Ret
.c55f	60		rts		   RTS
.c560					  Read_String
.c560	a2 00		ldx #$00	   LDX #0            ; set channel 0, keyboard
.c562					ReSt_Loop
.c562	20 0f e1	jsr $e10f	   JSR Read_Char
.c565	c9 0d		cmp #$0d	   CMP #CR
.c567	f0 0d		beq $c576	   BEQ ReSt_Finish
.c569	9d 00 02	sta $0200,x	   STA BUF,X
.c56c	e8		inx		   INX
.c56d	e0 59		cpx #$59	   CPX #$59          ; compare with max+1
.c56f	90 f1		bcc $c562	   BCC ReSt_Loop
.c571	a2 17		ldx #$17	   LDX #$17          ; error $17, string too long error
.c573	4c 37 c4	jmp $c437	   JMP Basic_Error
.c576					ReSt_Finish
.c576	4c ca ca	jmp $caca	   JMP Terminate_BUF      ; set XY to BUF - 1 and print [CR]
.c579					  Tokenize_Line
.c579	6c 04 03	jmp ($0304)	   JMP (ICRNCH)      ; normally next statement
.c57c					  Default_Tokenize
.c57c	a6 7a		ldx $7a		   LDX TXTPTR        ; get BASIC execute pointer low byte
.c57e	a0 04		ldy #$04	   LDY #4
.c580	84 0f		sty $0f		   STY GARBFL        ; clear open quote/DATA flag
.c582					Toke_Loop
.c582	bd 00 02	lda $0200,x	   LDA BUF,X
.c585	10 07		bpl $c58e	   BPL Toke_05       ; plain text
.c587	c9 ff		cmp #$ff	   CMP #TK_PI
.c589	f0 3e		beq $c5c9	   BEQ Toke_35       ; if PI save & continue
.c58b	e8		inx		   INX               ; next char
.c58c	d0 f4		bne $c582	   BNE Toke_Loop     ; branch always
.c58e					Toke_05
.c58e	c9 20		cmp #$20	   CMP #' '
.c590	f0 37		beq $c5c9	   BEQ Toke_35       ; if [SPACE] save & continue
.c592	85 08		sta $08		   STA ENDCHR        ; save buffer byte as search character
.c594	c9 22		cmp #$22	   CMP #QUOTE
.c596	f0 56		beq $c5ee	   BEQ Toke_55       ; if quote go copy quoted string
.c598	24 0f		bit $0f		   BIT GARBFL        ; get open quote/DATA token flag
.c59a	70 2d		bvs $c5c9	   BVS Toke_35       ; branch if b6 of Oquote set, was DATA
.c59c	c9 3f		cmp #$3f	   CMP #'?'          ; compare with '?' character
.c59e	d0 04		bne $c5a4	   BNE Toke_10       ; if not "?" continue crunching
.c5a0	a9 99		lda #$99	   LDA #TK_PRINT     ; replace '?' by the token for PRINT
.c5a2	d0 25		bne $c5c9	   BNE Toke_35       ; branch always
.c5a4					Toke_10
.c5a4	c9 30		cmp #$30	   CMP #'0'          ; compare with "0"
.c5a6	90 04		bcc $c5ac	   BCC Toke_15       ; if < "0" continue crunching
.c5a8	c9 3c		cmp #$3c	   CMP #'<'          ; compare with "<"
.c5aa	90 1d		bcc $c5c9	   BCC Toke_35       ; if <, 0123456789:; save & continue
.c5ac					Toke_15
.c5ac	84 71		sty $71		   STY TMPPTD        ; copy save index
.c5ae	a0 00		ldy #$00	   LDY #0            ; clear table pointer
.c5b0	84 0b		sty $0b		   STY COUNT         ; clear word index
.c5b2	88		dey		   DEY               ; Y = $FF
.c5b3	86 7a		stx $7a		   STX TXTPTR        ; save BASIC execute pointer low byte, buffer index
.c5b5	ca		dex		   DEX               ; adjust for pre increment loop
.c5b6					Toke_20
.c5b6	c8		iny		   INY               ; next table byte
.c5b7	e8		inx		   INX               ; next buffer byte
.c5b8					Toke_25
.c5b8	bd 00 02	lda $0200,x	   LDA BUF,X         ; get byte from input buffer
.c5bb	38		sec		   SEC
.c5bc	f9 9e c0	sbc $c09e,y	   SBC Basic_Keyword_Table,Y
.c5bf	f0 f5		beq $c5b6	   BEQ Toke_20       ; match so far
.c5c1	c9 80		cmp #$80	   CMP #$80          ; was it end marker match ?
.c5c3	d0 30		bne $c5f5	   BNE Toke_60       ; if not go try the next keyword
.c5c5	05 0b		ora $0b		   ORA COUNT         ; OR with word index, +$80 in A makes token
.c5c7					Toke_30
.c5c7	a4 71		ldy $71		   LDY TMPPTD        ; restore save index
.c5c9					Toke_35
.c5c9	e8		inx		   INX               ; increment buffer read index
.c5ca	c8		iny		   INY               ; increment save index
.c5cb	99 fb 01	sta $01fb,y	   STA BUF-5,Y       ; save byte to output
.c5ce	b9 fb 01	lda $01fb,y	   LDA BUF-5,Y       ; get byte from output, set flags
.c5d1	f0 36		beq $c609	   BEQ Toke_70       ; branch if was null [EOL]
.c5d3	38		sec		   SEC
.c5d4	e9 3a		sbc #$3a	   SBC #':'          ; subtract ":"
.c5d6	f0 04		beq $c5dc	   BEQ Toke_40       ; branch if it was (A is now 0)
.c5d8	c9 49		cmp #$49	   CMP #TK_DATA-':'  ; compare with the token for DATA-':'
.c5da	d0 02		bne $c5de	   BNE Toke_45       ; if not DATA go try REM
.c5dc					Toke_40
.c5dc	85 0f		sta $0f		   STA GARBFL        ; save token-':'
.c5de					Toke_45
.c5de	38		sec		   SEC
.c5df	e9 55		sbc #$55	   SBC #TK_REM-':'   ; subtract the token for REM-':'
.c5e1	d0 9f		bne $c582	   BNE Toke_Loop     ; if wasn't REM go crunch next bit of line
.c5e3					Toke_REM
.c5e3	85 08		sta $08		   STA ENDCHR        ; else was REM so set search for [EOL]
.c5e5					Toke_50
.c5e5	bd 00 02	lda $0200,x	   LDA BUF,X         ; get byte from input buffer
.c5e8	f0 df		beq $c5c9	   BEQ Toke_35       ; if null [EOL] save byte then continue crunching
.c5ea	c5 08		cmp $08		   CMP ENDCHR        ; compare with stored character
.c5ec	f0 db		beq $c5c9	   BEQ Toke_35       ; if match save byte then continue crunching
.c5ee					Toke_55
.c5ee	c8		iny		   INY               ; increment save index
.c5ef	99 fb 01	sta $01fb,y	   STA BUF-5,Y       ; save byte to output
.c5f2	e8		inx		   INX               ; increment buffer index
.c5f3	d0 f0		bne $c5e5	   BNE Toke_50       ; branch always
.c5f5					Toke_60
.c5f5	a6 7a		ldx $7a		   LDX TXTPTR        ; restore BASIC execute pointer low byte
.c5f7	e6 0b		inc $0b		   INC COUNT         ; increment word index (next word)
.c5f9					Toke_65
.c5f9	c8		iny		   INY               ; increment table index
.c5fa	b9 9d c0	lda $c09d,y	   LDA Basic_Keyword_Table-1,Y; get table byte
.c5fd	10 fa		bpl $c5f9	   BPL Toke_65       ; loop if not end of word yet
.c5ff	b9 9e c0	lda $c09e,y	   LDA Basic_Keyword_Table,Y  ; get byte from keyword table
.c602	d0 b4		bne $c5b8	   BNE Toke_25       ; go test next word if not zero byte, end of table
.c604	bd 00 02	lda $0200,x	   LDA BUF,X         ; restore byte from input buffer
.c607	10 be		bpl $c5c7	   BPL Toke_30       ; branch always, all unmatched bytes in the buffer are
.c609					Toke_70
.c609	99 fd 01	sta $01fd,y	   STA BUF-3,Y       ; save [EOL]
.c60c	c6 7b		dec $7b		   DEC TXTPTR+1      ; decrement BASIC execute pointer high byte
.c60e	a9 ff		lda #$ff	   LDA #$FF          ; point to start of buffer-1
.c610	85 7a		sta $7a		   STA TXTPTR        ; set BASIC execute pointer low byte
.c612	60		rts		   RTS
.c613					  Find_BASIC_Line
.c613	a5 2b		lda $2b		   LDA TXTTAB
.c615	a6 2c		ldx $2c		   LDX TXTTAB+1
.c617					  Find_BASIC_Line_AX
.c617	a0 01		ldy #$01	   LDY #1            ; set Y to next line link high byte
.c619	85 5f		sta $5f		   STA TMPPTC
.c61b	86 60		stx $60		   STX TMPPTC+1
.c61d	b1 5f		lda ($5f),y	   LDA (TMPPTC),Y    ; get line link high byte
.c61f	f0 1f		beq $c640	   BEQ FiBL_Not_Found; 0 = end of program
.c621	c8		iny		   INY               ; Y = 2
.c622	c8		iny		   INY               ; Y = 3
.c623	a5 15		lda $15		   LDA LINNUM+1      ; target line # high byte
.c625	d1 5f		cmp ($5f),y	   CMP (TMPPTC),Y    ; compare with line # high byte
.c627	90 18		bcc $c641	   BCC FiBL_Ret      ; beyond target line
.c629	f0 03		beq $c62e	   BEQ FiBL_Check    ; go check low byte if =
.c62b	88		dey		   DEY               ; Y = 2
.c62c	d0 09		bne $c637	   BNE FiBL_Cont     ; branch always
.c62e					FiBL_Check
.c62e	a5 14		lda $14		   LDA LINNUM        ; get target line # low byte
.c630	88		dey		   DEY               ; Y = 2
.c631	d1 5f		cmp ($5f),y	   CMP (TMPPTC),Y    ; compare with line # low byte
.c633	90 0c		bcc $c641	   BCC FiBL_Ret      ; beyond target line
.c635	f0 0a		beq $c641	   BEQ FiBL_Ret      ; target line found: exit
.c637					FiBL_Cont
.c637	88		dey		   DEY               ; Y = 1
.c638	b1 5f		lda ($5f),y	   LDA (TMPPTC),Y    ; get next line link high byte
.c63a	aa		tax		   TAX               ; copy to X
.c63b	88		dey		   DEY               ; Y = 0
.c63c	b1 5f		lda ($5f),y	   LDA (TMPPTC),Y    ; get next line link low byte
.c63e	b0 d7		bcs $c617	   BCS Find_BASIC_Line_AX ; branch always
.c640					FiBL_Not_Found
.c640	18		clc		   CLC               ; clear found flag
.c641					FiBL_Ret
.c641	60		rts		   RTS
.c642					  Basic_NEW
.c642	d0 fd		bne $c641	   BNE FiBL_Ret      ; exit if following byte to allow syntax error
.c644					  Perform_NEW
.c644	a9 00		lda #$00	   LDA #0
.c646	a8		tay		   TAY               ; clear index
.c647	91 2b		sta ($2b),y	   STA (TXTTAB),Y    ; clear pointer to next line low byte
.c649	c8		iny		   INY
.c64a	91 2b		sta ($2b),y	   STA (TXTTAB),Y    ; clear pointer to next line high byte, erase program
.c64c	a5 2b		lda $2b		   LDA TXTTAB        ; get start of memory low byte
.c64e	18		clc		   CLC
.c64f	69 02		adc #$02	   ADC #2            ; add null program length
.c651	85 2d		sta $2d		   STA VARTAB        ; set start of variables low byte
.c653	a5 2c		lda $2c		   LDA TXTTAB+1      ; get start of memory high byte
.c655	69 00		adc #$00	   ADC #0            ; add carry
.c657	85 2e		sta $2e		   STA VARTAB+1      ; set start of variables high byte
.c659					  Reset_BASIC_Execution
.c659	20 8e c6	jsr $c68e	   JSR Reset_BASIC_Exec_Pointer
.c65c	a9 00		lda #$00	   LDA #$00          ; set Zb for CLR entry
.c65e					  Basic_CLR
.c65e	d0 2d		bne $c68d	   BNE Flush_Ret      ; exit if following byte to allow syntax error
.c660					  Clear_Variable_Space
.c660	20 e7 ff	jsr $ffe7	   JSR CLALL         ; close all channels and files
.c663					  Reset_Variable_Pointer
.c663	a5 37		lda $37		   LDA MEMSIZ
.c665	a4 38		ldy $38		   LDY MEMSIZ+1
.c667	85 33		sta $33		   STA FRESPC
.c669	84 34		sty $34		   STY FRESPC+1
.c66b	a5 2d		lda $2d		   LDA VARTAB
.c66d	a4 2e		ldy $2e		   LDY VARTAB+1
.c66f	85 2f		sta $2f		   STA ARYTAB
.c671	84 30		sty $30		   STY ARYTAB+1
.c673	85 31		sta $31		   STA STREND
.c675	84 32		sty $32		   STY STREND+1
.c677					  Restore_And_Flush_Stack
.c677	20 1d c8	jsr $c81d	   JSR Basic_RESTORE ; perform RESTORE
.c67a					  Flush_BASIC_Stack
.c67a	a2 19		ldx #$19	   LDX #TEMPST       ; get descriptor stack start
.c67c	86 16		stx $16		   STX TEMPPT        ; set descriptor stack pointer
.c67e	68		pla		   PLA               ; pull return address low byte
.c67f	a8		tay		   TAY               ; copy it
.c680	68		pla		   PLA               ; pull return address high byte
.c681	a2 fa		ldx #$fa	   LDX #$FA          ; set cleared stack pointer
.c683	9a		txs		   TXS               ; set stack
.c684	48		pha		   PHA               ; push return address high byte
.c685	98		tya		   TYA               ; restore return address low byte
.c686	48		pha		   PHA               ; push return address low byte
.c687	a9 00		lda #$00	   LDA #0
.c689	85 3e		sta $3e		   STA OLDTXT+1      ; clear continue pointer high byte
.c68b	85 10		sta $10		   STA SUBFLG        ; clear subscript/FNX flag
.c68d					Flush_Ret
.c68d	60		rts		   RTS
.c68e					  Reset_BASIC_Exec_Pointer
.c68e	18		clc		   CLC
.c68f	a5 2b		lda $2b		   LDA TXTTAB        ; get start of memory low byte
.c691	69 ff		adc #$ff	   ADC #$FF          ; add -1 low byte
.c693	85 7a		sta $7a		   STA TXTPTR        ; set BASIC execute pointer low byte
.c695	a5 2c		lda $2c		   LDA TXTTAB+1      ; get start of memory high byte
.c697	69 ff		adc #$ff	   ADC #$FF          ; add -1 high byte
.c699	85 7b		sta $7b		   STA TXTPTR+1      ; save BASIC execute pointer high byte
.c69b	60		rts		   RTS
.c69c					  Basic_LIST
.c69c	90 06		bcc $c6a4	   BCC LIST_05       ; branch if next character not token (LIST n...)
.c69e	f0 04		beq $c6a4	   BEQ LIST_05       ; branch if next character [NULL] (LIST)
.c6a0	c9 ab		cmp #$ab	   CMP #TK_MINUS     ; the only token allowed here (LIST -m)
.c6a2	d0 e9		bne $c68d	   BNE Flush_Ret
.c6a4					LIST_05
.c6a4	20 6b c9	jsr $c96b	   JSR Scan_Linenumber
.c6a7	20 13 c6	jsr $c613	   JSR Find_BASIC_Line
.c6aa	20 79 00	jsr $0079	   JSR CHRGOT
.c6ad	f0 0c		beq $c6bb	   BEQ LIST_10       ; branch if no more chrs
.c6af	c9 ab		cmp #$ab	   CMP #TK_MINUS     ; compare with "-"
.c6b1	d0 8e		bne $c641	   BNE FiBL_Ret      ; return if not "-" (will be SN error)
.c6b3	20 73 00	jsr $0073	   JSR CHRGET        ; LIST [n]-m
.c6b6	20 6b c9	jsr $c96b	   JSR Scan_Linenumber
.c6b9	d0 86		bne $c641	   BNE FiBL_Ret      ; exit if not ok
.c6bb					LIST_10
.c6bb	68		pla		   PLA               ; dump return address low byte, exit via warm start
.c6bc	68		pla		   PLA               ; dump return address high byte
.c6bd	a5 14		lda $14		   LDA LINNUM        ; get temporary integer low byte
.c6bf	05 15		ora $15		   ORA LINNUM+1      ; OR temporary integer high byte
.c6c1	d0 06		bne $c6c9	   BNE LIST_15       ; branch if start set
.c6c3					LIST_12
.c6c3	a9 ff		lda #$ff	   LDA #$FF          ; set last line to $FFFF if not specified
.c6c5	85 14		sta $14		   STA LINNUM
.c6c7	85 15		sta $15		   STA LINNUM+1
.c6c9					LIST_15
.c6c9	a0 01		ldy #$01	   LDY #1
.c6cb	84 0f		sty $0f		   STY GARBFL        ; clear open quote flag
.c6cd	b1 5f		lda ($5f),y	   LDA (TMPPTC),Y    ; get next line pointer high byte
.c6cf	f0 43		beq $c714	   BEQ LIST_45       ; if null all done so exit
.c6d1	20 2c c8	jsr $c82c	   JSR Check_STOP
.c6d4					LIST_17
.c6d4	20 d7 ca	jsr $cad7	   JSR Print_CR
.c6d7	c8		iny		   INY
.c6d8	b1 5f		lda ($5f),y	   LDA (TMPPTC),Y    ; get line number low byte
.c6da	aa		tax		   TAX
.c6db	c8		iny		   INY
.c6dc	b1 5f		lda ($5f),y	   LDA (TMPPTC),Y    ; get line number high byte
.c6de	c5 15		cmp $15		   CMP LINNUM+1      ; compare with temporary integer high byte
.c6e0	d0 04		bne $c6e6	   BNE LIST_20       ; branch if no high byte match
.c6e2	e4 14		cpx $14		   CPX LINNUM        ; compare with temporary integer low byte
.c6e4	f0 02		beq $c6e8	   BEQ LIST_25       ; branch if = last line to do, < will pass next branch
.c6e6					LIST_20
.c6e6	b0 2c		bcs $c714	   BCS LIST_45       ; if greater all done so exit
.c6e8					LIST_25
.c6e8	84 49		sty $49		   STY FORPNT        ; save index for line
.c6ea	20 cd dd	jsr $ddcd	   JSR Print_Integer_XA
.c6ed	a9 20		lda #$20	   LDA #' '          ; print [SPACE]after line #
.c6ef					LIST_30
.c6ef	a4 49		ldy $49		   LDY FORPNT        ; get index for line
.c6f1	29 7f		and #$7f	   AND #$7F          ; mask top out bit of character
.c6f3					LIST_35
.c6f3	20 47 cb	jsr $cb47	   JSR Print_Char
.c6f6	c9 22		cmp #$22	   CMP #QUOTE
.c6f8	d0 06		bne $c700	   BNE LIST_40       ; if not skip the quote handle
.c6fa	a5 0f		lda $0f		   LDA GARBFL        ; get open quote flag
.c6fc	49 ff		eor #$ff	   EOR #$FF          ; toggle it
.c6fe	85 0f		sta $0f		   STA GARBFL        ; save it back
.c700					LIST_40
.c700	c8		iny		   INY
.c701	f0 11		beq $c714	   BEQ LIST_45       ; line too long so just bail out and do a warm start
.c703	b1 5f		lda ($5f),y	   LDA (TMPPTC),Y    ; get next byte
.c705	d0 10		bne $c717	   BNE Vectored_Detokenize      ; if not [EOL] (go print character)
.c707	a8		tay		   TAY               ; else clear index
.c708	b1 5f		lda ($5f),y	   LDA (TMPPTC),Y    ; get next line pointer low byte
.c70a	aa		tax		   TAX               ; copy to X
.c70b	c8		iny		   INY
.c70c	b1 5f		lda ($5f),y	   LDA (TMPPTC),Y    ; get next line pointer high byte
.c70e	86 5f		stx $5f		   STX TMPPTC        ; set pointer to line low byte
.c710	85 60		sta $60		   STA TMPPTC+1      ; set pointer to line high byte
.c712	d0 b5		bne $c6c9	   BNE LIST_15       ; go do next line if not [EOT]
.c714					LIST_45
.c714	4c 74 c4	jmp $c474	   JMP Basic_Ready
.c717					  Vectored_Detokenize
.c717	6c 06 03	jmp ($0306)	   JMP (IQPLOP)      ; normally next statement
.c71a					  Default_Detokenize
.c71a	10 d7		bpl $c6f3	   BPL LIST_35       ; print it if not token byte
.c71c	c9 ff		cmp #$ff	   CMP #TK_PI        ; compare with the token for PI
.c71e	f0 d3		beq $c6f3	   BEQ LIST_35       ; just print it if so
.c720	24 0f		bit $0f		   BIT GARBFL        ; test the open quote flag
.c722	30 cf		bmi $c6f3	   BMI LIST_35       ; just go print character if open quote set
.c724	38		sec		   SEC               ; else set carry for subtract
.c725	e9 7f		sbc #$7f	   SBC #$7F          ; convert token to inex
.c727	aa		tax		   TAX               ; copy token # to X
.c728	84 49		sty $49		   STY FORPNT        ; save Y
.c72a	a0 ff		ldy #$ff	   LDY #$FF          ; start from -1, adjust for pre increment
.c72c					DeTo_10
.c72c	ca		dex		   DEX               ; decrement token #
.c72d	f0 08		beq $c737	   BEQ DeTo_30       ; if not found go do printing
.c72f					DeTo_20
.c72f	c8		iny		   INY
.c730	b9 9e c0	lda $c09e,y	   LDA Basic_Keyword_Table,Y
.c733	10 fa		bpl $c72f	   BPL DeTo_20      ; loop until keyword end marker
.c735	30 f5		bmi $c72c	   BMI DeTo_10      ; branch always
.c737					DeTo_30
.c737	c8		iny		   INY
.c738	b9 9e c0	lda $c09e,y	   LDA Basic_Keyword_Table,Y
.c73b	30 b2		bmi $c6ef	   BMI LIST_30       ; go restore index, mask byte and print
.c73d	20 47 cb	jsr $cb47	   JSR Print_Char
.c740	d0 f5		bne $c737	   BNE DeTo_30       ; go get next character, branch always
.c742					  Basic_FOR
.c742	a9 80		lda #$80	   LDA #$80
.c744	85 10		sta $10		   STA SUBFLG        ; set FNX flag
.c746	20 a5 c9	jsr $c9a5	   JSR Basic_LET
.c749	20 8a c3	jsr $c38a	   JSR Find_Active_FOR
.c74c	d0 05		bne $c753	   BNE BaFO_10       ; branch if this FOR variable was not found
.c74e	8a		txa		   TXA               ; dump the old one
.c74f	69 0f		adc #$0f	   ADC #15           ; add FOR structure size-2
.c751	aa		tax		   TAX               ; copy to index
.c752	9a		txs		   TXS               ; set stack (dump FOR structure (-2 bytes))
.c753					BaFO_10
.c753	68		pla		   PLA               ; pull return address
.c754	68		pla		   PLA               ; pull return address
.c755	a9 09		lda #$09	   LDA #$09          ; we need 18d bytes !
.c757	20 fb c3	jsr $c3fb	   JSR Check_Stack_Avail
.c75a	20 06 c9	jsr $c906	   JSR Next_Statement
.c75d	18		clc		   CLC
.c75e	98		tya		   TYA               ; copy index to A
.c75f	65 7a		adc $7a		   ADC TXTPTR        ; add BASIC execute pointer low byte
.c761	48		pha		   PHA               ; push onto stack
.c762	a5 7b		lda $7b		   LDA TXTPTR+1      ; get BASIC execute pointer high byte
.c764	69 00		adc #$00	   ADC #$00          ; add carry
.c766	48		pha		   PHA               ; push onto stack
.c767	a5 3a		lda $3a		   LDA CURLIN+1
.c769	48		pha		   PHA
.c76a	a5 39		lda $39		   LDA CURLIN
.c76c	48		pha		   PHA
.c76d	a9 a4		lda #$a4	   LDA #TK_TO        ; set "TO" token
.c76f	20 ff ce	jsr $ceff	   JSR Need_A
.c772	20 8d cd	jsr $cd8d	   JSR Is_Numeric
.c775	20 8a cd	jsr $cd8a	   JSR Eval_Numeric
.c778	a5 66		lda $66		   LDA FAC1SI        ; get FAC1 sign (b7)
.c77a	09 7f		ora #$7f	   ORA #$7F          ; set all non sign bits
.c77c	25 62		and $62		   AND FAC1M1        ; and FAC1 mantissa 1
.c77e	85 62		sta $62		   STA FAC1M1        ; save FAC1 mantissa 1
.c780	a9 8b		lda #$8b	   LDA #<BaFO_20 ;#<addr
.c782	a0 c7		ldy #$c7	   LDY #>BaFO_20 ;#>addr
.c784	85 22		sta $22		   STA INDEXA
.c786	84 23		sty $23		   STY INDEXA+1
.c788	4c 43 ce	jmp $ce43	   JMP Round_And_Push_FAC1
.c78b					BaFO_20
.c78b	a9 bc		lda #$bc	   LDA #<REAL_1 ;#<addr
.c78d	a0 d9		ldy #$d9	   LDY #>REAL_1 ;#>addr
.c78f	20 a2 db	jsr $dba2	   JSR Load_FAC1_AY
.c792	20 79 00	jsr $0079	   JSR CHRGOT
.c795	c9 a9		cmp #$a9	   CMP #TK_STEP
.c797	d0 06		bne $c79f	   BNE BaFO_30
.c799	20 73 00	jsr $0073	   JSR CHRGET
.c79c	20 8a cd	jsr $cd8a	   JSR Eval_Numeric  ; Get STEP value
.c79f					BaFO_30
.c79f	20 2b dc	jsr $dc2b	   JSR Get_FAC1_Sign
.c7a2	20 38 ce	jsr $ce38	   JSR Push_FAC1
.c7a5	a5 4a		lda $4a		   LDA FORPNT+1
.c7a7	48		pha		   PHA
.c7a8	a5 49		lda $49		   LDA FORPNT
.c7aa	48		pha		   PHA
.c7ab	a9 81		lda #$81	   LDA #TK_FOR       ; push FOR token
.c7ad	48		pha		   PHA
.c7ae					  Interpreter_Loop
.c7ae	20 2c c8	jsr $c82c	   JSR Check_STOP
.c7b1	a5 7a		lda $7a		   LDA TXTPTR
.c7b3	a4 7b		ldy $7b		   LDY TXTPTR+1
.c7b5	c0 02		cpy #$02	   CPY #>BUF         ; direct mode ?
.c7b7	ea		nop		   NOP               ; unused byte
.c7b8	f0 04		beq $c7be	   BEQ InLo_10       ; in direct mode skip the continue pointer save
.c7ba	85 3d		sta $3d		   STA OLDTXT
.c7bc	84 3e		sty $3e		   STY OLDTXT+1
.c7be					InLo_10
.c7be	a0 00		ldy #$00	   LDY #0
.c7c0	b1 7a		lda ($7a),y	   LDA (TXTPTR),Y    ; get BASIC byte
.c7c2	d0 43		bne $c807	   BNE Inte_20      ; if not [EOL] go test for ":"
.c7c4	a0 02		ldy #$02	   LDY #2
.c7c6	b1 7a		lda ($7a),y	   LDA (TXTPTR),Y    ; get next line pointer high byte
.c7c8	18		clc		   CLC
.c7c9	d0 03		bne $c7ce	   BNE InLo_20       ; branch if not end of program
.c7cb	4c 4b c8	jmp $c84b	   JMP End_Of_Exec
.c7ce					InLo_20
.c7ce	c8		iny		   INY
.c7cf	b1 7a		lda ($7a),y	   LDA (TXTPTR),Y    ; get line number low byte
.c7d1	85 39		sta $39		   STA CURLIN        ; save current line number low byte
.c7d3	c8		iny		   INY
.c7d4	b1 7a		lda ($7a),y	   LDA (TXTPTR),Y    ; get line # high byte
.c7d6	85 3a		sta $3a		   STA CURLIN+1      ; save current line number high byte
.c7d8	98		tya		   TYA               ; A now = 4
.c7d9	65 7a		adc $7a		   ADC TXTPTR        ; add BASIC execute pointer low byte, now points to code
.c7db	85 7a		sta $7a		   STA TXTPTR        ; save BASIC execute pointer low byte
.c7dd	90 02		bcc $c7e1	   BCC Start_Program      ; if no overflow skip the high byte increment
.c7df	e6 7b		inc $7b		   INC TXTPTR+1      ; else increment BASIC execute pointer high byte
.c7e1					  Start_Program
.c7e1	6c 08 03	jmp ($0308)	   JMP (IGONE)       ; normally following code
.c7e4					  Default_Start
.c7e4	20 73 00	jsr $0073	   JSR CHRGET
.c7e7	20 ed c7	jsr $c7ed	   JSR Interpret
.c7ea	4c ae c7	jmp $c7ae	   JMP Interpreter_Loop
.c7ed					  Interpret
.c7ed	f0 3c		beq $c82b	   BEQ BaRE_Ret      ; if the first byte is null just exit
.c7ef					  Interpret_10
.c7ef	e9 80		sbc #$80	   SBC #$80          ; normalise the token
.c7f1	90 11		bcc $c804	   BCC Inte_10       ; if wasn't token go do LET
.c7f3	c9 23		cmp #$23	   CMP #TK_TAB-$80   ; compare with token for TAB(-$80
.c7f5	b0 17		bcs $c80e	   BCS Inte_40       ; branch if >= TAB(
.c7f7	0a		asl a		   ASL A             ; *2 bytes per vector
.c7f8	a8		tay		   TAY               ; copy to index
.c7f9	b9 0d c0	lda $c00d,y	   LDA Basic_Statement_Table+1,Y; get vector high byte
.c7fc	48		pha		   PHA               ; push on stack
.c7fd	b9 0c c0	lda $c00c,y	   LDA Basic_Statement_Table,Y  ; get vector low byte
.c800	48		pha		   PHA               ; push on stack
.c801	4c 73 00	jmp $0073	   JMP CHRGET        ; the return from CHRGET calls the command code
.c804					Inte_10
.c804	4c a5 c9	jmp $c9a5	   JMP Basic_LET     ; perform LET
.c807					Inte_20
.c807	c9 3a		cmp #$3a	   CMP #':'          ; comapre with ":"
.c809	f0 d6		beq $c7e1	   BEQ Start_Program ; if ":" go execute new code
.c80b					Inte_30
.c80b	4c 08 cf	jmp $cf08	   JMP Syntax_Error
.c80e					Inte_40
.c80e	c9 4b		cmp #$4b	   CMP #TK_GO-$80    ; compare with token for GO
.c810	d0 f9		bne $c80b	   BNE Inte_30       ; if not "GO" do syntax error then warm start
.c812	20 73 00	jsr $0073	   JSR CHRGET
.c815	a9 a4		lda #$a4	   LDA #TK_TO        ; set "TO" token
.c817	20 ff ce	jsr $ceff	   JSR Need_A
.c81a	4c a0 c8	jmp $c8a0	   JMP Basic_GOTO    ; perform GOTO
.c81d					  Basic_RESTORE
.c81d	38		sec		   SEC
.c81e	a5 2b		lda $2b		   LDA TXTTAB        ; get start of memory low byte
.c820	e9 01		sbc #$01	   SBC #$01          ; -1
.c822	a4 2c		ldy $2c		   LDY TXTTAB+1      ; get start of memory high byte
.c824	b0 01		bcs $c827	   BCS Store_DATPTR
.c826	88		dey		   DEY               ; else decrement high byte
.c827					Store_DATPTR
.c827	85 41		sta $41		   STA DATPTR
.c829	84 42		sty $42		   STY DATPTR+1
.c82b					BaRE_Ret
.c82b	60		rts		   RTS
.c82c					  Check_STOP
.c82c	20 e1 ff	jsr $ffe1	   JSR STOP          ; Check if stop key is pressed
.c82f					  Basic_STOP
.c82f	b0 01		bcs $c832	   BCS BaEN_10       ; if carry set do BREAK instead of just END
.c831					  Basic_END
.c831	18		clc		   CLC
.c832					BaEN_10
.c832	d0 3c		bne $c870	   BNE BaCO_Ret      ; return if wasn't CTRL-C
.c834	a5 7a		lda $7a		   LDA TXTPTR
.c836	a4 7b		ldy $7b		   LDY TXTPTR+1
.c838	a6 3a		ldx $3a		   LDX CURLIN+1      ; get current line number high byte
.c83a	e8		inx		   INX               ; increment it
.c83b	f0 0c		beq $c849	   BEQ BaEN_20       ; branch if was direct mode
.c83d	85 3d		sta $3d		   STA OLDTXT
.c83f	84 3e		sty $3e		   STY OLDTXT+1
.c841	a5 39		lda $39		   LDA CURLIN
.c843	a4 3a		ldy $3a		   LDY CURLIN+1
.c845	85 3b		sta $3b		   STA OLDLIN
.c847	84 3c		sty $3c		   STY OLDLIN+1
.c849					BaEN_20
.c849	68		pla		   PLA               ; dump return address low byte
.c84a	68		pla		   PLA               ; dump return address high byte
.c84b					  End_Of_Exec
.c84b	a9 81		lda #$81	   LDA #<Msg_CrLf ;#<addr
.c84d	a0 c3		ldy #$c3	   LDY #>Msg_CrLf ;#>addr
.c84f	90 03		bcc $c854	   BCC BaEN_30       ; branch if it was program end
.c851	4c 69 c4	jmp $c469	   JMP Display_Msg_Then_Ready
.c854					BaEN_30
.c854	4c 74 c4	jmp $c474	   JMP Basic_Ready
.c857					  Basic_CONT
.c857	d0 17		bne $c870	   BNE BaCO_Ret      ; exit if following byte to allow syntax error
.c859	a2 1a		ldx #$1a	   LDX #$1A          ; error code $1A, can't continue error
.c85b	a4 3e		ldy $3e		   LDY OLDTXT+1      ; get continue pointer high byte
.c85d	d0 03		bne $c862	   BNE BaCO_10       ; go do continue if we can
.c85f	4c 37 c4	jmp $c437	   JMP Basic_Error
.c862					BaCO_10
.c862	a5 3d		lda $3d		   LDA OLDTXT        ; get continue pointer low byte
.c864	85 7a		sta $7a		   STA TXTPTR
.c866	84 7b		sty $7b		   STY TXTPTR+1
.c868	a5 3b		lda $3b		   LDA OLDLIN
.c86a	a4 3c		ldy $3c		   LDY OLDLIN+1
.c86c	85 39		sta $39		   STA CURLIN
.c86e	84 3a		sty $3a		   STY CURLIN+1
.c870					BaCO_Ret
.c870	60		rts		   RTS
.c871					  Basic_RUN
.c871	08		php		   PHP
.c872	a9 00		lda #$00	   LDA #0            ; no control or kernal messages
.c874	20 90 ff	jsr $ff90	   JSR SETMSG
.c877	28		plp		   PLP
.c878	d0 03		bne $c87d	   BNE BaRU_10       ; branch if RUN n
.c87a	4c 59 c6	jmp $c659	   JMP Reset_BASIC_Execution
.c87d					BaRU_10
.c87d	20 60 c6	jsr $c660	   JSR Clear_Variable_Space
.c880	4c 97 c8	jmp $c897	   JMP Goto_Line
.c883					  Basic_GOSUB
.c883	a9 03		lda #$03	   LDA #3            ; need 6 bytes for GOSUB
.c885	20 fb c3	jsr $c3fb	   JSR Check_Stack_Avail
.c888	a5 7b		lda $7b		   LDA TXTPTR+1
.c88a	48		pha		   PHA
.c88b	a5 7a		lda $7a		   LDA TXTPTR
.c88d	48		pha		   PHA
.c88e	a5 3a		lda $3a		   LDA CURLIN+1
.c890	48		pha		   PHA
.c891	a5 39		lda $39		   LDA CURLIN
.c893	48		pha		   PHA
.c894	a9 8d		lda #$8d	   LDA #TK_GOSUB     ; token for GOSUB
.c896	48		pha		   PHA               ; save it
.c897					  Goto_Line
.c897	20 79 00	jsr $0079	   JSR CHRGOT
.c89a	20 a0 c8	jsr $c8a0	   JSR Basic_GOTO
.c89d	4c ae c7	jmp $c7ae	   JMP Interpreter_Loop
.c8a0					  Basic_GOTO
.c8a0	20 6b c9	jsr $c96b	   JSR Scan_Linenumber
.c8a3	20 09 c9	jsr $c909	   JSR Next_Line
.c8a6	38		sec		   SEC
.c8a7	a5 39		lda $39		   LDA CURLIN        ; get current line number low byte
.c8a9	e5 14		sbc $14		   SBC LINNUM        ; subtract temporary integer low byte
.c8ab	a5 3a		lda $3a		   LDA CURLIN+1      ; get current line number high byte
.c8ad	e5 15		sbc $15		   SBC LINNUM+1      ; subtract temporary integer high byte
.c8af	b0 0b		bcs $c8bc	   BCS BaGO_10       ; if current line # >= temporary search from start
.c8b1	98		tya		   TYA               ; else copy line index to A
.c8b2	38		sec		   SEC               ; set carry (+1)
.c8b3	65 7a		adc $7a		   ADC TXTPTR        ; add BASIC execute pointer low byte
.c8b5	a6 7b		ldx $7b		   LDX TXTPTR+1      ; get BASIC execute pointer high byte
.c8b7	90 07		bcc $c8c0	   BCC BaGO_20       ; if no overflow skip the high byte increment
.c8b9	e8		inx		   INX               ; increment high byte
.c8ba	b0 04		bcs $c8c0	   BCS BaGO_20       ; go find the line, branch always
.c8bc					BaGO_10
.c8bc	a5 2b		lda $2b		   LDA TXTTAB
.c8be	a6 2c		ldx $2c		   LDX TXTTAB+1
.c8c0					BaGO_20
.c8c0	20 17 c6	jsr $c617	   JSR Find_BASIC_Line_AX
.c8c3	90 1e		bcc $c8e3	   BCC Undefined_Statement
.c8c5	a5 5f		lda $5f		   LDA TMPPTC        ; get pointer low byte
.c8c7	e9 01		sbc #$01	   SBC #1            ; -1
.c8c9	85 7a		sta $7a		   STA TXTPTR        ; save BASIC execute pointer low byte
.c8cb	a5 60		lda $60		   LDA TMPPTC+1      ; get pointer high byte
.c8cd	e9 00		sbc #$00	   SBC #0            ; subtract carry
.c8cf	85 7b		sta $7b		   STA TXTPTR+1      ; save BASIC execute pointer high byte
.c8d1					BaGO_Ret
.c8d1	60		rts		   RTS
.c8d2					  Basic_RETURN
.c8d2	d0 fd		bne $c8d1	   BNE BaGO_Ret      ; exit if following token to allow syntax error
.c8d4	a9 ff		lda #$ff	   LDA #$FF          ; set byte so no match possible
.c8d6	85 4a		sta $4a		   STA FORPNT+1      ; save FOR/NEXT variable pointer high byte
.c8d8	20 8a c3	jsr $c38a	   JSR Find_Active_FOR
.c8db	9a		txs		   TXS               ; correct the stack
.c8dc	c9 8d		cmp #$8d	   CMP #TK_GOSUB     ; compare with GOSUB token
.c8de	f0 0b		beq $c8eb	   BEQ BaRE_20       ; if matching GOSUB go continue RETURN
.c8e0	a2 0c		ldx #$0c	   LDX #$0C          ; else error code $04, return without gosub error
>c8e2	2c				   .byte $2C         ; skip next statement
.c8e3					  Undefined_Statement
.c8e3	a2 11		ldx #$11	   LDX #$11          ; error code $11, undefined statement error
.c8e5	4c 37 c4	jmp $c437	   JMP Basic_Error
.c8e8					BaRE_10
.c8e8	4c 08 cf	jmp $cf08	   JMP Syntax_Error
.c8eb					BaRE_20
.c8eb	68		pla		   PLA               ; dump token byte
.c8ec	68		pla		   PLA
.c8ed	85 39		sta $39		   STA CURLIN
.c8ef	68		pla		   PLA
.c8f0	85 3a		sta $3a		   STA CURLIN+1
.c8f2	68		pla		   PLA
.c8f3	85 7a		sta $7a		   STA TXTPTR
.c8f5	68		pla		   PLA
.c8f6	85 7b		sta $7b		   STA TXTPTR+1
.c8f8					  Basic_DATA
.c8f8	20 06 c9	jsr $c906	   JSR Next_Statement
.c8fb					  Add_Y_To_Execution_Pointer
.c8fb	98		tya		   TYA               ; copy index to A
.c8fc					Add_To_TXTPTR
.c8fc	18		clc		   CLC
.c8fd	65 7a		adc $7a		   ADC TXTPTR        ; add BASIC execute pointer low byte
.c8ff	85 7a		sta $7a		   STA TXTPTR        ; save BASIC execute pointer low byte
.c901	90 02		bcc $c905	   BCC AYTE_Ret      ; skip increment if no carry
.c903	e6 7b		inc $7b		   INC TXTPTR+1      ; else increment BASIC execute pointer high byte
.c905					AYTE_Ret
.c905	60		rts		   RTS
.c906					  Next_Statement
.c906	a2 3a		ldx #$3a	   LDX #':'          ; look for colon
>c908	2c				   .byte   $2C       ; skip "LDX #0" command
.c909					  Next_Line
.c909	a2 00		ldx #$00	   LDX #0            ; look for 0 [EOL]
.c90b	86 07		stx $07		   STX CHARAC        ; store alternate search character
.c90d	a0 00		ldy #$00	   LDY #0            ; set search character = [EOL]
.c90f	84 08		sty $08		   STY ENDCHR        ; save the search character
.c911					NeLi_10
.c911	a5 08		lda $08		   LDA ENDCHR        ; get search character
.c913	a6 07		ldx $07		   LDX CHARAC        ; get alternate search character
.c915	85 07		sta $07		   STA CHARAC        ; make search character = alternate search character
.c917					NeLi_15
.c917	86 08		stx $08		   STX ENDCHR        ; make alternate search character = search character
.c919					NeLi_20
.c919	b1 7a		lda ($7a),y	   LDA (TXTPTR),Y    ; get BASIC byte
.c91b	f0 e8		beq $c905	   BEQ AYTE_Ret      ; exit if null [EOL]
.c91d	c5 08		cmp $08		   CMP ENDCHR        ; compare with search character
.c91f	f0 e4		beq $c905	   BEQ AYTE_Ret      ; exit if found
.c921	c8		iny		   INY               ; else increment index
.c922	c9 22		cmp #$22	   CMP #QUOTE
.c924	d0 f3		bne $c919	   BNE NeLi_20       ; if found go swap search character for alternate search
.c926	f0 e9		beq $c911	   BEQ NeLi_10       ; loop for next character, branch always
.c928					  Basic_IF
.c928	20 9e cd	jsr $cd9e	   JSR Eval_Expression
.c92b	20 79 00	jsr $0079	   JSR CHRGOT
.c92e	c9 89		cmp #$89	   CMP #TK_GOTO
.c930	f0 05		beq $c937	   BEQ BaIF_10       ; do IF ... GOTO
.c932	a9 a7		lda #$a7	   LDA #TK_THEN
.c934	20 ff ce	jsr $ceff	   JSR Need_A
.c937					BaIF_10
.c937	a5 61		lda $61		   LDA FAC1EX        ; get FAC1 exponent
.c939	d0 05		bne $c940	   BNE BaIF_20      ; if result was non zero continue execution
.c93b					  Basic_REM
.c93b	20 09 c9	jsr $c909	   JSR Next_Line
.c93e	f0 bb		beq $c8fb	   BEQ Add_Y_To_Execution_Pointer ; branch always
.c940					BaIF_20
.c940	20 79 00	jsr $0079	   JSR CHRGOT
.c943	b0 03		bcs $c948	   BCS BaIF_30      ; if not numeric character, is variable or keyword
.c945	4c a0 c8	jmp $c8a0	   JMP Basic_GOTO    ; else perform GOTO n
.c948					BaIF_30
.c948	4c ed c7	jmp $c7ed	   JMP Interpret
.c94b					  Basic_ON
.c94b	20 9e d7	jsr $d79e	   JSR Get_Byte_Value
.c94e	48		pha		   PHA               ; push next character
.c94f	c9 8d		cmp #$8d	   CMP #TK_GOSUB     ; compare with GOSUB token
.c951	f0 04		beq $c957	   BEQ BaON_20       ; if GOSUB go see if it should be executed
.c953					BaON_10
.c953	c9 89		cmp #$89	   CMP #TK_GOTO      ; compare with GOTO token
.c955	d0 91		bne $c8e8	   BNE BaRE_10       ; if not GOTO do syntax error then warm start
.c957					BaON_20
.c957	c6 65		dec $65		   DEC FAC1M4        ; decrement the byte value
.c959	d0 04		bne $c95f	   BNE BaON_30       ; if not zero go see if another line number exists
.c95b	68		pla		   PLA               ; pull keyword token
.c95c	4c ef c7	jmp $c7ef	   JMP Interpret_10
.c95f					BaON_30
.c95f	20 73 00	jsr $0073	   JSR CHRGET
.c962	20 6b c9	jsr $c96b	   JSR Scan_Linenumber
.c965	c9 2c		cmp #$2c	   CMP #','          ; compare next character with ","
.c967	f0 ee		beq $c957	   BEQ BaON_20       ; loop if ","
.c969	68		pla		   PLA               ; else pull keyword token, ran out of options
.c96a					BaON_Ret
.c96a	60		rts		   RTS
.c96b					  Scan_Linenumber
.c96b	a2 00		ldx #$00	   LDX #0
.c96d	86 14		stx $14		   STX LINNUM
.c96f	86 15		stx $15		   STX LINNUM+1
.c971					ScLi_Loop
.c971	b0 f7		bcs $c96a	   BCS BaON_Ret      ; return if carry set, end of scan, character was not 0-9
.c973	e9 2f		sbc #$2f	   SBC #$2F          ; subtract $30, $2F+carry, from byte
.c975	85 07		sta $07		   STA CHARAC        ; store # OPT: TAX
.c977	a5 15		lda $15		   LDA LINNUM+1      ; get temporary integer high byte
.c979	85 22		sta $22		   STA INDEXA        ; save it for now
.c97b	c9 19		cmp #$19	   CMP #$19          ; compare with $19
.c97d	b0 d4		bcs $c953	   BCS BaON_10       ; branch if >= this makes the maximum line number 63999
.c97f	a5 14		lda $14		   LDA LINNUM        ; get temporary integer low byte
.c981	0a		asl a		   ASL A             ; *2 low byte
.c982	26 22		rol $22		   ROL INDEXA        ; *2 high byte
.c984	0a		asl a		   ASL A             ; *2 low byte
.c985	26 22		rol $22		   ROL INDEXA        ; *2 high byte (*4)
.c987	65 14		adc $14		   ADC LINNUM        ; + low byte (*5)
.c989	85 14		sta $14		   STA LINNUM        ; save it
.c98b	a5 22		lda $22		   LDA INDEXA        ; get high byte temp
.c98d	65 15		adc $15		   ADC LINNUM+1      ; + high byte (*5)
.c98f	85 15		sta $15		   STA LINNUM+1      ; save it
.c991	06 14		asl $14		   ASL LINNUM        ; *2 low byte (*10d)
.c993	26 15		rol $15		   ROL LINNUM+1      ; *2 high byte (*10d)
.c995	a5 14		lda $14		   LDA LINNUM        ; get low byte OPT: TXA
.c997	65 07		adc $07		   ADC CHARAC        ; add #        OPT: ADC LINNUM
.c999	85 14		sta $14		   STA LINNUM        ; save low byte
.c99b	90 02		bcc $c99f	   BCC ScLi_10       ; if no overflow skip high byte increment
.c99d	e6 15		inc $15		   INC LINNUM+1      ; else increment high byte
.c99f					ScLi_10
.c99f	20 73 00	jsr $0073	   JSR CHRGET
.c9a2	4c 71 c9	jmp $c971	   JMP ScLi_Loop      ; OPT: BCC ScLi_Loop : RTS
.c9a5					  Basic_LET
.c9a5	20 8b d0	jsr $d08b	   JSR Get_Scalar_Address
.c9a8	85 49		sta $49		   STA FORPNT
.c9aa	84 4a		sty $4a		   STY FORPNT+1
.c9ac	a9 b2		lda #$b2	   LDA #TK_EQUAL
.c9ae	20 ff ce	jsr $ceff	   JSR Need_A        ; '=' is needed
.c9b1	a5 0e		lda $0e		   LDA INTFLG        ; get data type flag, $80 = integer, $00 = float
.c9b3	48		pha		   PHA               ; push data type flag
.c9b4	a5 0d		lda $0d		   LDA VALTYP        ; get data type flag, $FF = string, $00 = numeric
.c9b6	48		pha		   PHA               ; push data type flag
.c9b7	20 9e cd	jsr $cd9e	   JSR Eval_Expression
.c9ba	68		pla		   PLA               ; pop data type flag
.c9bb	2a		rol a		   ROL A             ; string bit into carry
.c9bc	20 90 cd	jsr $cd90	   JSR Check_Var_Type
.c9bf	d0 18		bne $c9d9	   BNE LET_20        ; if string go assign a string value
.c9c1	68		pla		   PLA               ; pop integer/float data type flag
.c9c2					  Assign_Numeric_variable
.c9c2	10 12		bpl $c9d6	   BPL LET_10        ; if float go assign a floating value
.c9c4	20 1b dc	jsr $dc1b	   JSR Round_FAC1_Checked
.c9c7	20 bf d1	jsr $d1bf	   JSR Eval_Integer
.c9ca	a0 00		ldy #$00	   LDY #0
.c9cc	a5 64		lda $64		   LDA FAC1M3        ; get FAC1 mantissa 3
.c9ce	91 49		sta ($49),y	   STA (FORPNT),Y    ; save as integer variable low byte
.c9d0	c8		iny		   INY
.c9d1	a5 65		lda $65		   LDA FAC1M4        ; get FAC1 mantissa 4
.c9d3	91 49		sta ($49),y	   STA (FORPNT),Y    ; save as integer variable high byte
.c9d5	60		rts		   RTS
.c9d6					LET_10
.c9d6	4c d0 db	jmp $dbd0	   JMP Assign_FAC1_To_FOR_Index
.c9d9					LET_20
.c9d9	68		pla		   PLA               ; dump integer/float data type flag
.c9da					  Assign_String_Variable
.c9da	a4 4a		ldy $4a		   LDY FORPNT+1      ; get variable pointer high byte
.c9dc	c0 df		cpy #$df	   CPY #>NULL_Descriptor ; TI$
.c9de	d0 4c		bne $ca2c	   BNE Assign_String
.c9e0	20 a6 d6	jsr $d6a6	   JSR Get_String_Descriptor
.c9e3	c9 06		cmp #$06	   CMP #6            ; TI$ = "hhmmss"
.c9e5	d0 3d		bne $ca24	   BNE Jump_Illegal_Quantity
.c9e7	a0 00		ldy #$00	   LDY #0
.c9e9	84 61		sty $61		   STY FAC1EX        ; clear FAC1 exponent
.c9eb	84 66		sty $66		   STY FAC1SI        ; clear FAC1 sign (b7)
.c9ed					LET_30
.c9ed	84 71		sty $71		   STY TMPPTD        ; save index
.c9ef	20 1d ca	jsr $ca1d	   JSR Eval_Digit    ; check and evaluate numeric digit
.c9f2	20 e2 da	jsr $dae2	   JSR Multiply_FAC1_BY_10
.c9f5	e6 71		inc $71		   INC TMPPTD        ; increment index
.c9f7	a4 71		ldy $71		   LDY TMPPTD        ; restore index
.c9f9	20 1d ca	jsr $ca1d	   JSR Eval_Digit    ; check and evaluate numeric digit
.c9fc	20 0c dc	jsr $dc0c	   JSR FAC1_Round_And_Copy_To_FAC2
.c9ff	aa		tax		   TAX               ; copy FAC1 exponent
.ca00	f0 05		beq $ca07	   BEQ LET_40        ; branch if FAC1 zero
.ca02	e8		inx		   INX               ; increment index, * 2
.ca03	8a		txa		   TXA               ; copy back to A
.ca04	20 ed da	jsr $daed	   JSR Multiply_FAC1_By_4
.ca07					LET_40
.ca07	a4 71		ldy $71		   LDY TMPPTD        ; get index
.ca09	c8		iny		   INY
.ca0a	c0 06		cpy #$06	   CPY #6            ; max. 6 digits "hhmmss"
.ca0c	d0 df		bne $c9ed	   BNE LET_30
.ca0e	20 e2 da	jsr $dae2	   JSR Multiply_FAC1_BY_10
.ca11	20 9b dc	jsr $dc9b	   JSR FAC1_To_Integer
.ca14	a6 64		ldx $64		   LDX FAC1M3        ; get FAC1 mantissa 3
.ca16	a4 63		ldy $63		   LDY FAC1M2        ; get FAC1 mantissa 2
.ca18	a5 65		lda $65		   LDA FAC1M4        ; get FAC1 mantissa 4
.ca1a	4c db ff	jmp $ffdb	   JMP SETTIM        ; Set the system clock
.ca1d					  Eval_Digit
.ca1d	b1 22		lda ($22),y	   LDA (INDEXA),Y    ; get byte from string
.ca1f	20 80 00	jsr $0080	   JSR ISNUM
.ca22	90 03		bcc $ca27	   BCC EvDi_10       ; branch if numeric
.ca24					Jump_Illegal_Quantity
.ca24	4c 48 d2	jmp $d248	   JMP Illegal_Quantity
.ca27					EvDi_10
.ca27	e9 2f		sbc #$2f	   SBC #$2F          ; subtract $2F + carry = '0'
.ca29	4c 7e dd	jmp $dd7e	   JMP Add_A_To_FAC1
.ca2c					  Assign_String
.ca2c	a0 02		ldy #$02	   LDY #2            ; index to string pointer high byte
.ca2e	b1 64		lda ($64),y	   LDA (FAC1M3),Y    ; get string pointer high byte
.ca30	c5 34		cmp $34		   CMP FRESPC+1      ; compare with bottom of string space high byte
.ca32	90 17		bcc $ca4b	   BCC AsSt_20       ; branch if string pointer < bottom of string space
.ca34	d0 07		bne $ca3d	   BNE AsSt_10       ; branch if string pointer > bottom of string space
.ca36	88		dey		   DEY               ; Y = 1
.ca37	b1 64		lda ($64),y	   LDA (FAC1M3),Y    ; get string pointer low byte
.ca39	c5 33		cmp $33		   CMP FRESPC        ; compare with bottom of string space low byte
.ca3b	90 0e		bcc $ca4b	   BCC AsSt_20       ; branch if string pointer < bottom of string space
.ca3d					AsSt_10
.ca3d	a4 65		ldy $65		   LDY FAC1M4        ; get descriptor pointer high byte
.ca3f	c4 2e		cpy $2e		   CPY VARTAB+1      ; compare with start of variables high byte
.ca41	90 08		bcc $ca4b	   BCC AsSt_20       ; branch if less, is on string stack
.ca43	d0 0d		bne $ca52	   BNE AsSt_30       ; if greater make space and copy string
.ca45	a5 64		lda $64		   LDA FAC1M3        ; get descriptor pointer low byte
.ca47	c5 2d		cmp $2d		   CMP VARTAB        ; compare with start of variables low byte
.ca49	b0 07		bcs $ca52	   BCS AsSt_30       ; if greater or equal make space and copy string
.ca4b					AsSt_20
.ca4b	a5 64		lda $64		   LDA FAC1M3        ; get descriptor pointer low byte
.ca4d	a4 65		ldy $65		   LDY FAC1M4        ; get descriptor pointer high byte
.ca4f	4c 68 ca	jmp $ca68	   JMP AsSt_40       ; go copy descriptor to variable
.ca52					AsSt_30
.ca52	a0 00		ldy #$00	   LDY #0
.ca54	b1 64		lda ($64),y	   LDA (FAC1M3),Y    ; get string length
.ca56	20 75 d4	jsr $d475	   JSR Allocate_String_FAC1
.ca59	a5 50		lda $50		   LDA DESCPT
.ca5b	a4 51		ldy $51		   LDY DESCPT+1
.ca5d	85 6f		sta $6f		   STA STRPTR
.ca5f	84 70		sty $70		   STY STRPTR+1
.ca61	20 7a d6	jsr $d67a	   JSR Store_String_STRPTR
.ca64	a9 61		lda #$61	   LDA #<FAC1EX ;#<addr
.ca66	a0 00		ldy #$00	   LDY #>FAC1EX ;#>addr
.ca68					AsSt_40
.ca68	85 50		sta $50		   STA DESCPT
.ca6a	84 51		sty $51		   STY DESCPT+1
.ca6c	20 db d6	jsr $d6db	   JSR Pop_Descriptor_Stack
.ca6f	a0 00		ldy #$00	   LDY #0
.ca71	b1 50		lda ($50),y	   LDA (DESCPT),Y    ; get string length from new descriptor
.ca73	91 49		sta ($49),y	   STA (FORPNT),Y    ; copy string length to variable
.ca75	c8		iny		   INY
.ca76	b1 50		lda ($50),y	   LDA (DESCPT),Y    ; get string pointer low byte from new descriptor
.ca78	91 49		sta ($49),y	   STA (FORPNT),Y    ; copy string pointer low byte to variable
.ca7a	c8		iny		   INY
.ca7b	b1 50		lda ($50),y	   LDA (DESCPT),Y    ; get string pointer high byte from new descriptor
.ca7d	91 49		sta ($49),y	   STA (FORPNT),Y    ; copy string pointer high byte to variable
.ca7f	60		rts		   RTS
.ca80					  Basic_PRINTN
.ca80	20 86 ca	jsr $ca86	   JSR Basic_CMD
.ca83	4c b5 cb	jmp $cbb5	   JMP Set_Default_Channels
.ca86					  Basic_CMD
.ca86	20 9e d7	jsr $d79e	   JSR Get_Byte_Value
.ca89	f0 05		beq $ca90	   BEQ BCMD_10       ; branch if following byte is ":" or [EOT]
.ca8b	a9 2c		lda #$2c	   LDA #','
.ca8d	20 ff ce	jsr $ceff	   JSR Need_A
.ca90					BCMD_10
.ca90	08		php		   PHP               ; save status
.ca91	86 13		stx $13		   STX IOPMPT        ; set current I/O channel
.ca93	20 15 e1	jsr $e115	   JSR Select_Output_Channel
.ca96	28		plp		   PLP               ; restore status
.ca97	4c a0 ca	jmp $caa0	   JMP Basic_PRINT   ; perform PRINT
.ca9a					BaPR_00
.ca9a	20 21 cb	jsr $cb21	   JSR Print_String_From_Descriptor
.ca9d					BaPR_05
.ca9d	20 79 00	jsr $0079	   JSR CHRGOT
.caa0					  Basic_PRINT
.caa0	f0 35		beq $cad7	   BEQ Print_CR
.caa2					BaPR_10
.caa2	f0 43		beq $cae7	   BEQ Invert_Ret      ; if nothing following exit, end of PRINT branch
.caa4	c9 a3		cmp #$a3	   CMP #TK_TAB       ; compare with token for TAB(
.caa6	f0 50		beq $caf8	   BEQ TAB_20      ; if TAB( go handle it
.caa8	c9 a6		cmp #$a6	   CMP #TK_SPC       ; compare with token for SPC(
.caaa	18		clc		   CLC               ; flag SPC(
.caab	f0 4b		beq $caf8	   BEQ TAB_20      ; if SPC( go handle it
.caad	c9 2c		cmp #$2c	   CMP #','
.caaf	f0 37		beq $cae8	   BEQ TAB_Jump
.cab1	c9 3b		cmp #$3b	   CMP #SEMIC
.cab3	f0 5e		beq $cb13	   BEQ TAB_60      ; if ";" go continue the print loop
.cab5	20 9e cd	jsr $cd9e	   JSR Eval_Expression
.cab8	24 0d		bit $0d		   BIT VALTYP        ; test data type flag, $FF = string, $00 = numeric
.caba	30 de		bmi $ca9a	   BMI BaPR_00      ; if string go print string, scan memory and continue PRINT
.cabc	20 dd dd	jsr $dddd	   JSR Format_FAC1
.cabf	20 87 d4	jsr $d487	   JSR Create_String_Descriptor
.cac2	20 21 cb	jsr $cb21	   JSR Print_String_From_Descriptor
.cac5	20 3b cb	jsr $cb3b	   JSR Cursor_Right_Or_Space
.cac8	d0 d3		bne $ca9d	   BNE BaPR_05      ; go scan memory and continue PRINT, branch always
.caca					  Terminate_BUF
.caca	a9 00		lda #$00	   LDA #0
.cacc	9d 00 02	sta $0200,x	   STA BUF,X         ; terminate string with 0 byte
.cacf	a2 ff		ldx #$ff	   LDX #<BUF-1
.cad1	a0 01		ldy #$01	   LDY #>BUF-1
.cad3	a5 13		lda $13		   LDA IOPMPT        ; get current I/O channel
.cad5	d0 10		bne $cae7	   BNE Invert_Ret      ; exit if not default channel
.cad7					  Print_CR
.cad7	a9 0d		lda #$0d	   LDA #CR
.cad9	20 47 cb	jsr $cb47	   JSR Print_Char
.cadc	24 13		bit $13		   BIT IOPMPT        ; test current I/O channel
.cade	10 05		bpl $cae5	   BPL Invert_A      ; needless, because this is always true
.cae0	a9 0a		lda #$0a	   LDA #LF
.cae2	20 47 cb	jsr $cb47	   JSR Print_Char
.cae5					  Invert_A
.cae5	49 ff		eor #$ff	   EOR #$FF          ; invert A
.cae7					Invert_Ret
.cae7	60		rts		   RTS
.cae8					  TAB_Jump
.cae8	38		sec		   SEC               ; set Cb for read cursor position
.cae9	20 f0 ff	jsr $fff0	   JSR PLOT          ; Read cursor location
.caec	98		tya		   TYA               ; copy cursor Y
.caed	38		sec		   SEC
.caee					TAB_10
.caee	e9 0b		sbc #$0b	   SBC #11           ; subtract one TAB length
.caf0	b0 fc		bcs $caee	   BCS TAB_10
.caf2	49 ff		eor #$ff	   EOR #$FF          ; complement it
.caf4	69 01		adc #$01	   ADC #1
.caf6	d0 16		bne $cb0e	   BNE TAB_30        ; print A spaces, branch always
.caf8					TAB_20
.caf8	08		php		   PHP               ; save TAB( or SPC( status
.caf9	38		sec		   SEC               ; set Cb for read cursor position
.cafa	20 f0 ff	jsr $fff0	   JSR PLOT          ; Read or set cursor location
.cafd	84 09		sty $09		   STY TRMPOS        ; save current cursor position
.caff	20 9b d7	jsr $d79b	   JSR Get_Next_Byte_Value
.cb02	c9 29		cmp #$29	   CMP #$29          ; compare with ")"
.cb04	d0 59		bne $cb5f	   BNE BaIn_30       ; if not ")" do syntax error
.cb06	28		plp		   PLP               ; restore TAB( or SPC( status
.cb07	90 06		bcc $cb0f	   BCC TAB_40        ; branch if was SPC(
.cb09	8a		txa		   TXA               ; copy TAB() byte to A
.cb0a	e5 09		sbc $09		   SBC TRMPOS        ; subtract current cursor position
.cb0c	90 05		bcc $cb13	   BCC TAB_60        ; go loop for next if already past requited position
.cb0e					TAB_30
.cb0e	aa		tax		   TAX               ; copy [SPACE] count to X
.cb0f					TAB_40
.cb0f	e8		inx		   INX               ; increment count
.cb10					TAB_50
.cb10	ca		dex		   DEX               ; decrement count
.cb11	d0 06		bne $cb19	   BNE TAB_70        ; branch if count was not zero
.cb13					TAB_60
.cb13	20 73 00	jsr $0073	   JSR CHRGET
.cb16	4c a2 ca	jmp $caa2	   JMP BaPR_10       ; continue print loop
.cb19					TAB_70
.cb19	20 3b cb	jsr $cb3b	   JSR Cursor_Right_Or_Space
.cb1c	d0 f2		bne $cb10	   BNE TAB_50        ; loop, branch always
.cb1e					  Print_String
.cb1e	20 87 d4	jsr $d487	   JSR Create_String_Descriptor
.cb21					  Print_String_From_Descriptor
.cb21	20 a6 d6	jsr $d6a6	   JSR Get_String_Descriptor
.cb24	aa		tax		   TAX               ; copy length
.cb25	a0 00		ldy #$00	   LDY #0
.cb27	e8		inx		   INX               ; increment length, for pre decrement loop
.cb28					PSFD_Loop
.cb28	ca		dex		   DEX               ; decrement length
.cb29	f0 bc		beq $cae7	   BEQ Invert_Ret    ; exit if done
.cb2b	b1 22		lda ($22),y	   LDA (INDEXA),Y    ; get byte from string
.cb2d	20 47 cb	jsr $cb47	   JSR Print_Char
.cb30	c8		iny		   INY
.cb31	c9 0d		cmp #$0d	   CMP #$0D          ; compare byte with [CR]
.cb33	d0 f3		bne $cb28	   BNE PSFD_Loop
.cb35	20 e5 ca	jsr $cae5	   JSR Invert_A      ; nonsense
.cb38	4c 28 cb	jmp $cb28	   JMP PSFD_Loop
.cb3b					  Cursor_Right_Or_Space
.cb3b	a5 13		lda $13		   LDA IOPMPT        ; get current I/O channel
.cb3d	f0 03		beq $cb42	   BEQ CROS_10       ; if default channel load [CURSOR RIGHT]
.cb3f	a9 20		lda #$20	   LDA #' '          ; else load [SPACE]
>cb41	2c				   .byte $2C         ; skip until Print_Char
.cb42					CROS_10
.cb42	a9 1d		lda #$1d	   LDA #$1D          ; load [CURSOR RIGHT]
>cb44	2c				   .byte $2C         ; skip until Print_Char
.cb45					  Print_Question_Mark
.cb45	a9 3f		lda #$3f	   LDA #'?'
.cb47					  Print_Char
.cb47	20 09 e1	jsr $e109	   JSR CHROUT_Checked
.cb4a	29 ff		and #$ff	   AND #$FF          ; set flags
.cb4c	60		rts		   RTS
.cb4d					  Bad_Input
.cb4d	a5 11		lda $11		   LDA INPFLG        ; get INPUT mode flag, $00 = INPUT, $40 = GET, $98 = READ
.cb4f	f0 11		beq $cb62	   BEQ BaIn_40       ; branch if INPUT
.cb51	30 04		bmi $cb57	   BMI BaIn_10       ; branch if READ
.cb53	a0 ff		ldy #$ff	   LDY #$FF          ; set current line high byte to -1, indicate immediate mode
.cb55	d0 04		bne $cb5b	   BNE BaIn_20       ; branch always
.cb57					BaIn_10
.cb57	a5 3f		lda $3f		   LDA DATLIN
.cb59	a4 40		ldy $40		   LDY DATLIN+1
.cb5b					BaIn_20
.cb5b	85 39		sta $39		   STA CURLIN
.cb5d	84 3a		sty $3a		   STY CURLIN+1
.cb5f					BaIn_30
.cb5f	4c 08 cf	jmp $cf08	   JMP Syntax_Error
.cb62					BaIn_40
.cb62	a5 13		lda $13		   LDA IOPMPT        ; get current I/O channel
.cb64	f0 05		beq $cb6b	   BEQ BaIn_50       ; if default channel go do "?REDO FROM START" message
.cb66	a2 18		ldx #$18	   LDX #$18          ; else error $18, file data error
.cb68	4c 37 c4	jmp $c437	   JMP Basic_Error
.cb6b					BaIn_50
.cb6b	a9 0c		lda #$0c	   LDA #<Msg_Redo_From_Start
.cb6d	a0 cd		ldy #$cd	   LDY #>Msg_Redo_From_Start
.cb6f	20 1e cb	jsr $cb1e	   JSR Print_String
.cb72	a5 3d		lda $3d		   LDA OLDTXT
.cb74	a4 3e		ldy $3e		   LDY OLDTXT+1
.cb76	85 7a		sta $7a		   STA TXTPTR
.cb78	84 7b		sty $7b		   STY TXTPTR+1
.cb7a	60		rts		   RTS
.cb7b					  Basic_GET
.cb7b	20 a6 d3	jsr $d3a6	   JSR Assert_Non_Direct
.cb7e	c9 23		cmp #$23	   CMP #'#'          ; compare with "#"
.cb80	d0 10		bne $cb92	   BNE BaGE_10       ; branch if not GET#
.cb82	20 73 00	jsr $0073	   JSR CHRGET
.cb85	20 9e d7	jsr $d79e	   JSR Get_Byte_Value
.cb88	a9 2c		lda #$2c	   LDA #','
.cb8a	20 ff ce	jsr $ceff	   JSR Need_A
.cb8d	86 13		stx $13		   STX IOPMPT        ; set current I/O channel
.cb8f	20 1b e1	jsr $e11b	   JSR CHKIN_Checked
.cb92					BaGE_10
.cb92	a2 01		ldx #$01	   LDX #<BUF+1     ; set BUF+1 pointer low byte
.cb94	a0 02		ldy #$02	   LDY #>BUF+1     ; set BUF+1 pointer high byte
.cb96	a9 00		lda #$00	   LDA #0
.cb98	8d 01 02	sta $0201	   STA BUF+1         ; ensure null terminator
.cb9b	a9 40		lda #$40	   LDA #$40          ; input mode = GET
.cb9d	20 0f cc	jsr $cc0f	   JSR Read_Get
.cba0	a6 13		ldx $13		   LDX IOPMPT        ; get current I/O channel
.cba2	d0 13		bne $cbb7	   BNE BaIN_101       ; if not default channel go do channel close and return
.cba4	60		rts		   RTS
.cba5					  Basic_INPUTN
.cba5	20 9e d7	jsr $d79e	   JSR Get_Byte_Value
.cba8	a9 2c		lda #$2c	   LDA #','
.cbaa	20 ff ce	jsr $ceff	   JSR Need_A
.cbad	86 13		stx $13		   STX IOPMPT        ; set current I/O channel
.cbaf	20 1b e1	jsr $e11b	   JSR CHKIN_Checked
.cbb2	20 ce cb	jsr $cbce	   JSR Input_String
.cbb5					  Set_Default_Channels
.cbb5	a5 13		lda $13		   LDA IOPMPT        ; get current I/O channel
.cbb7					BaIN_101
.cbb7	20 cc ff	jsr $ffcc	   JSR CLRCHN        ; Clear I/O channels
.cbba	a2 00		ldx #$00	   LDX #0
.cbbc	86 13		stx $13		   STX IOPMPT        ; clear current I/O channel
.cbbe	60		rts		   RTS
.cbbf					  Basic_INPUT
.cbbf	c9 22		cmp #$22	   CMP #QUOTE
.cbc1	d0 0b		bne $cbce	   BNE Input_String
.cbc3	20 bd ce	jsr $cebd	   JSR Make_String_Descriptor_From_Code
.cbc6	a9 3b		lda #$3b	   LDA #SEMIC
.cbc8	20 ff ce	jsr $ceff	   JSR Need_A
.cbcb	20 21 cb	jsr $cb21	   JSR Print_String_From_Descriptor
.cbce					  Input_String
.cbce	20 a6 d3	jsr $d3a6	   JSR Assert_Non_Direct
.cbd1	a9 2c		lda #$2c	   LDA #','
.cbd3	8d ff 01	sta $01ff	   STA BUF-1         ; save to start of buffer - 1
.cbd6					BaIN_201
.cbd6	20 f9 cb	jsr $cbf9	   JSR Prompt_And_Input
.cbd9	a5 13		lda $13		   LDA IOPMPT        ; get current I/O channel
.cbdb	f0 0d		beq $cbea	   BEQ BaIN_301       ; branch if default I/O channel
.cbdd	20 b7 ff	jsr $ffb7	   JSR READST        ; read I/O status word
.cbe0	29 02		and #$02	   AND #$02          ; mask no DSR/timeout
.cbe2	f0 06		beq $cbea	   BEQ BaIN_301       ; branch if not error
.cbe4	20 b5 cb	jsr $cbb5	   JSR Set_Default_Channels
.cbe7	4c f8 c8	jmp $c8f8	   JMP Basic_DATA    ; perform DATA
.cbea					BaIN_301
.cbea	ad 00 02	lda $0200	   LDA BUF           ; get first byte in input buffer
.cbed	d0 1e		bne $cc0d	   BNE BaIN_501
.cbef	a5 13		lda $13		   LDA IOPMPT        ; get current I/O channel
.cbf1	d0 e3		bne $cbd6	   BNE BaIN_201       ; if not default channel go get BASIC input
.cbf3	20 06 c9	jsr $c906	   JSR Next_Statement
.cbf6	4c fb c8	jmp $c8fb	   JMP Add_Y_To_Execution_Pointer
.cbf9					  Prompt_And_Input
.cbf9	a5 13		lda $13		   LDA IOPMPT        ; get current I/O channel
.cbfb	d0 06		bne $cc03	   BNE BaIN_401       ; skip "?" prompt if not default channel
.cbfd	20 45 cb	jsr $cb45	   JSR Print_Question_Mark
.cc00	20 3b cb	jsr $cb3b	   JSR Cursor_Right_Or_Space
.cc03					BaIN_401
.cc03	4c 60 c5	jmp $c560	   JMP Read_String
.cc06					  Basic_READ
.cc06	a6 41		ldx $41		   LDX DATPTR
.cc08	a4 42		ldy $42		   LDY DATPTR+1
.cc0a	a9 98		lda #$98	   LDA #$98          ; set input mode = READ
>cc0c	2c				   .byte   $2C       ; skip next statement
.cc0d					BaIN_501
.cc0d	a9 00		lda #$00	   LDA #$00          ; set input mode = INPUT
.cc0f					  Read_Get
.cc0f	85 11		sta $11		   STA INPFLG        ; $00 = INPUT, $40 = GET, $98 = READ
.cc11	86 43		stx $43		   STX INPPTR
.cc13	84 44		sty $44		   STY INPPTR+1
.cc15					READ_Loop_Var
.cc15	20 8b d0	jsr $d08b	   JSR Get_Scalar_Address
.cc18	85 49		sta $49		   STA FORPNT
.cc1a	84 4a		sty $4a		   STY FORPNT+1
.cc1c	a5 7a		lda $7a		   LDA TXTPTR
.cc1e	a4 7b		ldy $7b		   LDY TXTPTR+1
.cc20	85 4b		sta $4b		   STA YSAVE
.cc22	84 4c		sty $4c		   STY YSAVE+1
.cc24	a6 43		ldx $43		   LDX INPPTR
.cc26	a4 44		ldy $44		   LDY INPPTR+1
.cc28	86 7a		stx $7a		   STX TXTPTR
.cc2a	84 7b		sty $7b		   STY TXTPTR+1
.cc2c	20 79 00	jsr $0079	   JSR CHRGOT
.cc2f	d0 20		bne $cc51	   BNE READ_20       ; branch if not null
.cc31	24 11		bit $11		   BIT INPFLG        ; $00 = INPUT, $40 = GET, $98 = READ
.cc33	50 0c		bvc $cc41	   BVC READ_05       ; branch if not GET
.cc35	20 21 e1	jsr $e121	   JSR GETIN_Checked
.cc38	8d 00 02	sta $0200	   STA BUF           ; save to buffer
.cc3b	a2 ff		ldx #$ff	   LDX #<BUF-1     ; set BUF-1 pointer low byte
.cc3d	a0 01		ldy #$01	   LDY #>BUF-1     ; set BUF-1 pointer high byte
.cc3f	d0 0c		bne $cc4d	   BNE READ_15       ; branch always
.cc41					READ_05
.cc41	30 75		bmi $ccb8	   BMI READ_60      ; branch if READ else it's do INPUT
.cc43	a5 13		lda $13		   LDA IOPMPT        ; get current I/O channel
.cc45	d0 03		bne $cc4a	   BNE READ_10       ; skip "?" prompt if not default channel
.cc47	20 45 cb	jsr $cb45	   JSR Print_Question_Mark
.cc4a					READ_10
.cc4a	20 f9 cb	jsr $cbf9	   JSR Prompt_And_Input
.cc4d					READ_15
.cc4d	86 7a		stx $7a		   STX TXTPTR
.cc4f	84 7b		sty $7b		   STY TXTPTR+1
.cc51					READ_20
.cc51	20 73 00	jsr $0073	   JSR CHRGET        ; execute pointer now points to start of next data
.cc54	24 0d		bit $0d		   BIT VALTYP        ; test data type flag, $FF = string, $00 = numeric
.cc56	10 31		bpl $cc89	   BPL READ_45      ; branch if numeric
.cc58	24 11		bit $11		   BIT INPFLG        ; $00 = INPUT, $40 = GET, $98 = READ
.cc5a	50 09		bvc $cc65	   BVC READ_25       ; branch if not GET
.cc5c	e8		inx		   INX               ; GET string
.cc5d	86 7a		stx $7a		   STX TXTPTR        ; save BASIC execute pointer low byte
.cc5f	a9 00		lda #$00	   LDA #0
.cc61	85 07		sta $07		   STA CHARAC        ; clear search character
.cc63	f0 0c		beq $cc71	   BEQ READ_30       ; branch always
.cc65					READ_25
.cc65	85 07		sta $07		   STA CHARAC        ; save search character
.cc67	c9 22		cmp #$22	   CMP #QUOTE
.cc69	f0 07		beq $cc72	   BEQ READ_35       ; if quote only search for "..." string
.cc6b	a9 3a		lda #$3a	   LDA #':'          ; set ":"
.cc6d	85 07		sta $07		   STA CHARAC        ; set search character
.cc6f	a9 2c		lda #$2c	   LDA #','
.cc71					READ_30
.cc71	18		clc		   CLC
.cc72					READ_35
.cc72	85 08		sta $08		   STA ENDCHR        ; set scan quotes flag
.cc74	a5 7a		lda $7a		   LDA TXTPTR
.cc76	a4 7b		ldy $7b		   LDY TXTPTR+1
.cc78	69 00		adc #$00	   ADC #0            ; INPUT and READ increment by carry
.cc7a	90 01		bcc $cc7d	   BCC READ_40       ; if no carry skip the high byte increment
.cc7c	c8		iny		   INY               ; else increment pointer high byte
.cc7d					READ_40
.cc7d	20 8d d4	jsr $d48d	   JSR Create_String_Descriptor_AY
.cc80	20 e2 d7	jsr $d7e2	   JSR Restore_Execution_Pointer
.cc83	20 da c9	jsr $c9da	   JSR Assign_String_Variable
.cc86	4c 91 cc	jmp $cc91	   JMP READ_50       ; continue processing command
.cc89					READ_45
.cc89	20 f3 dc	jsr $dcf3	   JSR Load_FAC1_From_String
.cc8c	a5 0e		lda $0e		   LDA INTFLG        ; get data type flag, $80 = integer, $00 = float
.cc8e	20 c2 c9	jsr $c9c2	   JSR Assign_Numeric_variable
.cc91					READ_50
.cc91	20 79 00	jsr $0079	   JSR CHRGOT
.cc94	f0 07		beq $cc9d	   BEQ READ_55       ; if ":" or [EOL] go handle the string end
.cc96	c9 2c		cmp #$2c	   CMP #','          ; comparte with ","
.cc98	f0 03		beq $cc9d	   BEQ READ_55       ; if "," go handle the string end
.cc9a	4c 4d cb	jmp $cb4d	   JMP Bad_Input
.cc9d					READ_55
.cc9d	a5 7a		lda $7a		   LDA TXTPTR
.cc9f	a4 7b		ldy $7b		   LDY TXTPTR+1
.cca1	85 43		sta $43		   STA INPPTR
.cca3	84 44		sty $44		   STY INPPTR+1
.cca5	a5 4b		lda $4b		   LDA YSAVE
.cca7	a4 4c		ldy $4c		   LDY YSAVE+1
.cca9	85 7a		sta $7a		   STA TXTPTR
.ccab	84 7b		sty $7b		   STY TXTPTR+1
.ccad	20 79 00	jsr $0079	   JSR CHRGOT
.ccb0	f0 2d		beq $ccdf	   BEQ READ_70       ; branch if ":" or [EOL]
.ccb2	20 fd ce	jsr $cefd	   JSR Need_Comma
.ccb5	4c 15 cc	jmp $cc15	   JMP READ_Loop_Var
.ccb8					READ_60
.ccb8	20 06 c9	jsr $c906	   JSR Next_Statement
.ccbb	c8		iny		   INY
.ccbc	aa		tax		   TAX               ; copy byte to X
.ccbd	d0 12		bne $ccd1	   BNE READ_65       ; if ":" go look for the next DATA
.ccbf	a2 0d		ldx #$0d	   LDX #$0D          ; else set error $0D, out of data error
.ccc1	c8		iny		   INY
.ccc2	b1 7a		lda ($7a),y	   LDA (TXTPTR),Y    ; get next line pointer high byte
.ccc4	f0 6c		beq $cd32	   BEQ NEXT_20      ; if program end go do error, eventually does error X
.ccc6	c8		iny		   INY
.ccc7	b1 7a		lda ($7a),y	   LDA (TXTPTR),Y    ; get next line # low byte
.ccc9	85 3f		sta $3f		   STA DATLIN        ; save current DATA line low byte
.cccb	c8		iny		   INY
.cccc	b1 7a		lda ($7a),y	   LDA (TXTPTR),Y    ; get next line # high byte
.ccce	c8		iny		   INY
.cccf	85 40		sta $40		   STA DATLIN+1      ; save current DATA line high byte
.ccd1					READ_65
.ccd1	20 fb c8	jsr $c8fb	   JSR Add_Y_To_Execution_Pointer
.ccd4	20 79 00	jsr $0079	   JSR CHRGOT
.ccd7	aa		tax		   TAX               ; copy byte
.ccd8	e0 83		cpx #$83	   CPX #TK_DATA      ; compare with token for DATA
.ccda	d0 dc		bne $ccb8	   BNE READ_60       ; loop if not DATA
.ccdc	4c 51 cc	jmp $cc51	   JMP READ_20       ; continue evaluating READ
.ccdf					READ_70
.ccdf	a5 43		lda $43		   LDA INPPTR        ; get READ pointer low byte
.cce1	a4 44		ldy $44		   LDY INPPTR+1      ; get READ pointer high byte
.cce3	a6 11		ldx $11		   LDX INPFLG        ; get INPUT mode flag, $00 = INPUT, $40 = GET, $98 = READ
.cce5	10 03		bpl $ccea	   BPL READ_75       ; if INPUT or GET go exit or ignore extra input
.cce7	4c 27 c8	jmp $c827	   JMP Store_DATPTR
.ccea					READ_75
.ccea	a0 00		ldy #$00	   LDY #0
.ccec	b1 43		lda ($43),y	   LDA (INPPTR),Y    ; get READ byte
.ccee	f0 0b		beq $ccfb	   BEQ READ_Ret      ; exit if [EOL]
.ccf0	a5 13		lda $13		   LDA IOPMPT        ; get current I/O channel
.ccf2	d0 07		bne $ccfb	   BNE READ_Ret      ; exit if not default channel
.ccf4	a9 fc		lda #$fc	   LDA #<Msg_Extra_Ignored ;#<addr
.ccf6	a0 cc		ldy #$cc	   LDY #>Msg_Extra_Ignored ;#>addr
.ccf8	4c 1e cb	jmp $cb1e	   JMP Print_String
.ccfb					READ_Ret
.ccfb	60		rts		   RTS
>ccfc	3f 45 58 54 52 41 20 49		Msg_Extra_Ignored   .TEXT "?EXTRA IGNORED\r",0
>cd04	47 4e 4f 52 45 44 0d 00
>cd0c	3f 52 45 44 4f 20 46 52		Msg_Redo_From_Start .TEXT "?REDO FROM START\r",0
>cd14	4f 4d 20 53 54 41 52 54 0d 00
.cd1e					  Basic_NEXT
.cd1e	d0 04		bne $cd24	   BNE Find_NEXT_Variable
.cd20	a0 00		ldy #$00	   LDY #0
.cd22	f0 03		beq $cd27	   BEQ NEXT_10      ; use any variable, branch always
.cd24					  Find_NEXT_Variable
.cd24	20 8b d0	jsr $d08b	   JSR Get_Scalar_Address
.cd27					NEXT_10
.cd27	85 49		sta $49		   STA FORPNT
.cd29	84 4a		sty $4a		   STY FORPNT+1
.cd2b	20 8a c3	jsr $c38a	   JSR Find_Active_FOR
.cd2e	f0 05		beq $cd35	   BEQ NEXT_30       ; if FOR found continue
.cd30	a2 0a		ldx #$0a	   LDX #$0A          ; else set error $0A, next without for error
.cd32					NEXT_20
.cd32	4c 37 c4	jmp $c437	   JMP Basic_Error
.cd35					NEXT_30
.cd35	9a		txs		   TXS               ; update stack pointer
.cd36	8a		txa		   TXA               ; copy stack pointer
.cd37	18		clc		   CLC
.cd38	69 04		adc #$04	   ADC #$04          ; point to STEP value
.cd3a	48		pha		   PHA               ; save it
.cd3b	69 06		adc #$06	   ADC #$06          ; point to TO value
.cd3d	85 24		sta $24		   STA INDEXB        ; save pointer to TO variable for compare
.cd3f	68		pla		   PLA               ; restore pointer to STEP value
.cd40	a0 01		ldy #$01	   LDY #$01          ; point to stack page
.cd42	20 a2 db	jsr $dba2	   JSR Load_FAC1_AY
.cd45	ba		tsx		   TSX               ; get stack pointer back
.cd46	bd 09 01	lda $0109,x	   LDA STACK+9,X     ; get step sign
.cd49	85 66		sta $66		   STA FAC1SI        ; save FAC1 sign (b7)
.cd4b	a5 49		lda $49		   LDA FORPNT        ; get FOR/NEXT variable pointer low byte
.cd4d	a4 4a		ldy $4a		   LDY FORPNT+1      ; get FOR/NEXT variable pointer high byte
.cd4f	20 67 d8	jsr $d867	   JSR Add_Var_AY_To_FAC1
.cd52	20 d0 db	jsr $dbd0	   JSR Assign_FAC1_To_FOR_Index
.cd55	a0 01		ldy #$01	   LDY #$01          ; point to stack page
.cd57	20 5d dc	jsr $dc5d	   JSR Compare_FAC1_INDEXB_Y ; compare FAC1 with TO value
.cd5a	ba		tsx		   TSX               ; get stack pointer back
.cd5b	38		sec		   SEC
.cd5c	fd 09 01	sbc $0109,x	   SBC STACK+9,X     ; subtract step sign
.cd5f	f0 17		beq $cd78	   BEQ NEXT_50       ; if = loop complete, go unstack the FOR
.cd61	bd 0f 01	lda $010f,x	   LDA STACK+$0F,X   ; get FOR line low byte
.cd64	85 39		sta $39		   STA CURLIN        ; save current line number low byte
.cd66	bd 10 01	lda $0110,x	   LDA STACK+$10,X   ; get FOR line high byte
.cd69	85 3a		sta $3a		   STA CURLIN+1      ; save current line number high byte
.cd6b	bd 12 01	lda $0112,x	   LDA STACK+$12,X   ; get BASIC execute pointer low byte
.cd6e	85 7a		sta $7a		   STA TXTPTR        ; save BASIC execute pointer low byte
.cd70	bd 11 01	lda $0111,x	   LDA STACK+$11,X   ; get BASIC execute pointer high byte
.cd73	85 7b		sta $7b		   STA TXTPTR+1      ; save BASIC execute pointer high byte
.cd75					NEXT_40
.cd75	4c ae c7	jmp $c7ae	   JMP Interpreter_Loop
.cd78					NEXT_50
.cd78	8a		txa		   TXA               ; stack copy to A
.cd79	69 11		adc #$11	   ADC #$11          ; add $12, $11 + carry, to dump FOR structure
.cd7b	aa		tax		   TAX               ; copy back to index
.cd7c	9a		txs		   TXS               ; copy to stack pointer
.cd7d	20 79 00	jsr $0079	   JSR CHRGOT
.cd80	c9 2c		cmp #$2c	   CMP #','
.cd82	d0 f1		bne $cd75	   BNE NEXT_40       ; if not "," go do interpreter inner loop
.cd84	20 73 00	jsr $0073	   JSR CHRGET
.cd87	20 24 cd	jsr $cd24	   JSR Find_NEXT_Variable
.cd8a					  Eval_Numeric
.cd8a	20 9e cd	jsr $cd9e	   JSR Eval_Expression
.cd8d					  Is_Numeric
.cd8d	18		clc		   CLC
>cd8e	24				   .byte   $24       ; skip next byte
.cd8f					  Assert_String_Type
.cd8f	38		sec		   SEC               ; string required
.cd90					  Check_Var_Type
.cd90	24 0d		bit $0d		   BIT VALTYP        ; test data type flag, $FF = string, $00 = numeric
.cd92	30 03		bmi $cd97	   BMI CVT_20        ; branch to string check
.cd94	b0 03		bcs $cd99	   BCS Type_Missmatch
.cd96					CVT_10
.cd96	60		rts		   RTS
.cd97					CVT_20
.cd97	b0 fd		bcs $cd96	   BCS CVT_10        ; exit if string is required
.cd99					Type_Missmatch
.cd99	a2 16		ldx #$16	   LDX #$16          ; error code $16, type missmatch error
.cd9b	4c 37 c4	jmp $c437	   JMP Basic_Error
.cd9e					  Eval_Expression
.cd9e	a6 7a		ldx $7a		   LDX TXTPTR        ; get BASIC execute pointer low byte
.cda0	d0 02		bne $cda4	   BNE EvEx_05       ; skip next if not zero
.cda2	c6 7b		dec $7b		   DEC TXTPTR+1      ; else decrement BASIC execute pointer high byte
.cda4					EvEx_05
.cda4	c6 7a		dec $7a		   DEC TXTPTR        ; decrement BASIC execute pointer low byte
.cda6	a2 00		ldx #$00	   LDX #$00          ; set null precedence, flag done
>cda8	24				   .byte   $24       ; makes next line BIT VARPNT+1
.cda9					EvEx_10
.cda9	48		pha		   PHA               ; push compare evaluation byte if branch to here
.cdaa	8a		txa		   TXA               ; copy precedence byte
.cdab	48		pha		   PHA               ; push precedence byte
.cdac	a9 01		lda #$01	   LDA #$01          ; 2 bytes
.cdae	20 fb c3	jsr $c3fb	   JSR Check_Stack_Avail
.cdb1	20 83 ce	jsr $ce83	   JSR Evaluate
.cdb4	a9 00		lda #$00	   LDA #0
.cdb6	85 4d		sta $4d		   STA ACCSYM        ; clear comparrison evaluation flag
.cdb8					EvEx_15
.cdb8	20 79 00	jsr $0079	   JSR CHRGOT
.cdbb					EvEx_20
.cdbb	38		sec		   SEC
.cdbc	e9 b1		sbc #$b1	   SBC #TK_GT        ; subtract token for ">"
.cdbe	90 17		bcc $cdd7	   BCC EvEx_25       ; if < ">" skip comparrison test check
.cdc0	c9 03		cmp #$03	   CMP #$03          ; compare with ">" to +3
.cdc2	b0 13		bcs $cdd7	   BCS EvEx_25       ; if >= 3 skip comparrison test check
.cdc4	c9 01		cmp #$01	   CMP #$01          ; compare with token for =
.cdc6	2a		rol a		   ROL A             ; *2, b0 = carry (=1 if token was = or <)
.cdc7	49 01		eor #$01	   EOR #$01          ; toggle b0
.cdc9	45 4d		eor $4d		   EOR ACCSYM        ; EOR with comparrison evaluation flag
.cdcb	c5 4d		cmp $4d		   CMP ACCSYM        ; compare with comparrison evaluation flag
.cdcd	90 61		bcc $ce30	   BCC Jump_Syntax_Error      ; if < saved flag do syntax error then warm start
.cdcf	85 4d		sta $4d		   STA ACCSYM        ; save new comparrison evaluation flag
.cdd1	20 73 00	jsr $0073	   JSR CHRGET
.cdd4	4c bb cd	jmp $cdbb	   JMP EvEx_20       ; go do next character
.cdd7					EvEx_25
.cdd7	a6 4d		ldx $4d		   LDX ACCSYM        ; get comparrison evaluation flag
.cdd9	d0 2c		bne $ce07	   BNE EvEx_50       ; if compare function flagged go evaluate right hand side
.cddb	b0 7b		bcs $ce58	   BCS Right_Operand      ; apply operator
.cddd	69 07		adc #$07	   ADC #$07          ; add # of operators (+, -, *, /, ^, AND or OR)
.cddf	90 77		bcc $ce58	   BCC Right_Operand      ; if < + operator go do the function
.cde1	65 0d		adc $0d		   ADC VALTYP        ; add data type flag, $FF = string, $00 = numeric
.cde3	d0 03		bne $cde8	   BNE EvEx_30       ; if not string or not + token skip concatenate
.cde5	4c 3d d6	jmp $d63d	   JMP Concatenate   ; add strings, string 1 is in the descriptor, string 2
.cde8					EvEx_30
.cde8	69 ff		adc #$ff	   ADC #$FF          ; -1 (corrects for carry add)
.cdea	85 22		sta $22		   STA INDEXA        ; save it
.cdec	0a		asl a		   ASL A             ; *2
.cded	65 22		adc $22		   ADC INDEXA        ; *3
.cdef	a8		tay		   TAY               ; copy to index
.cdf0					EvEx_35
.cdf0	68		pla		   PLA               ; pull previous precedence
.cdf1	d9 80 c0	cmp $c080,y	   CMP Basic_Operator_Table,Y  ; compare with precedence byte
.cdf4	b0 67		bcs $ce5d	   BCS RiOp_20      ; if A >= go do the function
.cdf6	20 8d cd	jsr $cd8d	   JSR Is_Numeric
.cdf9					EvEx_40
.cdf9	48		pha		   PHA               ; save precedence
.cdfa					EvEx_45
.cdfa	20 20 ce	jsr $ce20	   JSR Call_Operator_Function
.cdfd	68		pla		   PLA               ; restore precedence
.cdfe	a4 4b		ldy $4b		   LDY YSAVE         ; get precedence stacked flag
.ce00	10 17		bpl $ce19	   BPL EvEx_60       ; if stacked values go check the precedence
.ce02	aa		tax		   TAX               ; copy precedence, set flags
.ce03	f0 56		beq $ce5b	   BEQ RiOp_10      ; exit if done
.ce05	d0 5f		bne $ce66	   BNE RiOp_40      ; else pop FAC2 and return, branch always
.ce07					EvEx_50
.ce07	46 0d		lsr $0d		   LSR VALTYP        ; clear data type flag, $FF = string, $00 = numeric
.ce09	8a		txa		   TXA               ; copy compare function flag
.ce0a	2a		rol a		   ROL A             ; <<1, shift data type flag into b0, 1 = string, 0 = num
.ce0b	a6 7a		ldx $7a		   LDX TXTPTR        ; get BASIC execute pointer low byte
.ce0d	d0 02		bne $ce11	   BNE EvEx_55       ; if no underflow skip the high byte decrement
.ce0f	c6 7b		dec $7b		   DEC TXTPTR+1      ; else decrement BASIC execute pointer high byte
.ce11					EvEx_55
.ce11	c6 7a		dec $7a		   DEC TXTPTR        ; decrement BASIC execute pointer low byte
.ce13	a0 1b		ldy #$1b	   LDY #$1B          ; set offset to = operator precedence entry
.ce15	85 4d		sta $4d		   STA ACCSYM        ; save new comparrison evaluation flag
.ce17	d0 d7		bne $cdf0	   BNE EvEx_35       ; branch always
.ce19					EvEx_60
.ce19	d9 80 c0	cmp $c080,y	   CMP Basic_Operator_Table,Y  ; compare with stacked function precedence
.ce1c	b0 48		bcs $ce66	   BCS RiOp_40      ; if A >=, pop FAC2 and return
.ce1e	90 d9		bcc $cdf9	   BCC EvEx_40       ; else go stack this one and continue, branch always
.ce20					  Call_Operator_Function
.ce20	b9 82 c0	lda $c082,y	   LDA Basic_Operator_Table+2,Y
.ce23	48		pha		   PHA
.ce24	b9 81 c0	lda $c081,y	   LDA Basic_Operator_Table+1,Y
.ce27	48		pha		   PHA
.ce28	20 33 ce	jsr $ce33	   JSR Apply_Operator
.ce2b	a5 4d		lda $4d		   LDA ACCSYM        ; get comparrison evaluation flag
.ce2d	4c a9 cd	jmp $cda9	   JMP EvEx_10       ; continue evaluating expression
.ce30					Jump_Syntax_Error
.ce30	4c 08 cf	jmp $cf08	   JMP Syntax_Error
.ce33					  Apply_Operator
.ce33	a5 66		lda $66		   LDA FAC1SI        ; get FAC1 sign (b7)
.ce35	be 80 c0	ldx $c080,y	   LDX Basic_Operator_Table,Y  ; get precedence byte
.ce38					  Push_FAC1
.ce38	a8		tay		   TAY               ; copy sign
.ce39	68		pla		   PLA               ; get return address low byte
.ce3a	85 22		sta $22		   STA INDEXA        ; save it
.ce3c	e6 22		inc $22		   INC INDEXA        ; increment it as return-1 is pushed
.ce3e	68		pla		   PLA               ; get return address high byte
.ce3f	85 23		sta $23		   STA INDEXA+1      ; save it
.ce41	98		tya		   TYA               ; restore sign
.ce42	48		pha		   PHA               ; push sign
.ce43					  Round_And_Push_FAC1
.ce43	20 1b dc	jsr $dc1b	   JSR Round_FAC1_Checked
.ce46	a5 65		lda $65		   LDA FAC1M3+1
.ce48	48		pha		   PHA
.ce49	a5 64		lda $64		   LDA FAC1M3
.ce4b	48		pha		   PHA
.ce4c	a5 63		lda $63		   LDA FAC1M1+1
.ce4e	48		pha		   PHA
.ce4f	a5 62		lda $62		   LDA FAC1M1
.ce51	48		pha		   PHA
.ce52	a5 61		lda $61		   LDA FAC1EX        ; get FAC1 exponent
.ce54	48		pha		   PHA               ; push it
.ce55	6c 22 00	jmp ($0022)	   JMP (INDEXA)      ; return, sort of
.ce58					  Right_Operand
.ce58	a0 ff		ldy #$ff	   LDY #$FF          ; flag function
.ce5a	68		pla		   PLA               ; pull precedence byte
.ce5b					RiOp_10
.ce5b	f0 23		beq $ce80	   BEQ RiOp_50       ; exit if done
.ce5d					RiOp_20
.ce5d	c9 64		cmp #$64	   CMP #$64          ; compare previous precedence with $64
.ce5f	f0 03		beq $ce64	   BEQ RiOp_30       ; if was $64 (< function) skip the type check
.ce61	20 8d cd	jsr $cd8d	   JSR Is_Numeric
.ce64					RiOp_30
.ce64	84 4b		sty $4b		   STY YSAVE         ; save precedence stacked flag
.ce66					RiOp_40
.ce66	68		pla		   PLA               ; pop byte
.ce67	4a		lsr a		   LSR A             ; shift out comparison evaluation lowest bit
.ce68	85 12		sta $12		   STA TANSGN        ; save the comparison evaluation flag
.ce6a	68		pla		   PLA               ; pop exponent
.ce6b	85 69		sta $69		   STA FAC2EX        ; save FAC2 exponent
.ce6d	68		pla		   PLA
.ce6e	85 6a		sta $6a		   STA FAC2M1
.ce70	68		pla		   PLA
.ce71	85 6b		sta $6b		   STA FAC2M1+1
.ce73	68		pla		   PLA
.ce74	85 6c		sta $6c		   STA FAC2M3
.ce76	68		pla		   PLA
.ce77	85 6d		sta $6d		   STA FAC2M3+1
.ce79	68		pla		   PLA               ; pop sign
.ce7a	85 6e		sta $6e		   STA FAC2SI        ; save FAC2 sign (b7)
.ce7c	45 66		eor $66		   EOR FAC1SI        ; EOR FAC1 sign (b7)
.ce7e	85 6f		sta $6f		   STA STRPTR        ; save sign compare (FAC1 EOR FAC2)
.ce80					RiOp_50
.ce80	a5 61		lda $61		   LDA FAC1EX        ; get FAC1 exponent
.ce82	60		rts		   RTS
.ce83					  Evaluate
.ce83	6c 0a 03	jmp ($030a)	   JMP (IEVAL)       ; normally Default_EVAL
.ce86					  Default_EVAL
.ce86	a9 00		lda #$00	   LDA #0
.ce88	85 0d		sta $0d		   STA VALTYP        ; clear data type flag, $FF = string, $00 = numeric
.ce8a					EVA_10
.ce8a	20 73 00	jsr $0073	   JSR CHRGET
.ce8d	b0 03		bcs $ce92	   BCS EVA_30        ; if not numeric character continue
.ce8f					EVA_20
.ce8f	4c f3 dc	jmp $dcf3	   JMP Load_FAC1_From_String
.ce92					EVA_30
.ce92	20 13 d1	jsr $d113	   JSR Is_Alpha
.ce95	90 03		bcc $ce9a	   BCC EVA_40
.ce97	4c 28 cf	jmp $cf28	   JMP Get_Var       ; variable name set-up and return
.ce9a					EVA_40
.ce9a	c9 ff		cmp #$ff	   CMP #TK_PI
.ce9c	d0 0f		bne $cead	   BNE EVA_50        ; if not PI continue
.ce9e	a9 a8		lda #$a8	   LDA #<Float_PI ;#<addr
.cea0	a0 ce		ldy #$ce	   LDY #>Float_PI ;#>addr
.cea2	20 a2 db	jsr $dba2	   JSR Load_FAC1_AY
.cea5	4c 73 00	jmp $0073	   JMP CHRGET
>cea8	82 49 0f da a1			Float_PI .byte $82,$49,$0F,$DA,$A1 ;.real 3.141592653
.cead					EVA_50
.cead	c9 2e		cmp #$2e	   CMP #'.'
.ceaf	f0 de		beq $ce8f	   BEQ EVA_20        ; if so get FAC1 from string and return, e.g. was .123
.ceb1	c9 ab		cmp #$ab	   CMP #TK_MINUS
.ceb3	f0 58		beq $cf0d	   BEQ Prep_Minus_Operation
.ceb5	c9 aa		cmp #$aa	   CMP #TK_PLUS
.ceb7	f0 d1		beq $ce8a	   BEQ EVA_10        ; if + token ignore the leading +, +1 = 1
.ceb9	c9 22		cmp #$22	   CMP #QUOTE
.cebb	d0 0f		bne $cecc	   BNE EVA_70        ; if not open quote continue
.cebd					  Make_String_Descriptor_From_Code
.cebd	a5 7a		lda $7a		   LDA TXTPTR
.cebf	a4 7b		ldy $7b		   LDY TXTPTR+1
.cec1	69 00		adc #$00	   ADC #0            ; add carry to low byte
.cec3	90 01		bcc $cec6	   BCC EVA_60        ; branch if no overflow
.cec5	c8		iny		   INY               ; increment high byte
.cec6					EVA_60
.cec6	20 87 d4	jsr $d487	   JSR Create_String_Descriptor
.cec9	4c e2 d7	jmp $d7e2	   JMP Restore_Execution_Pointer
.cecc					EVA_70
.cecc	c9 a8		cmp #$a8	   CMP #TK_NOT       ; compare with token for NOT
.cece	d0 13		bne $cee3	   BNE EVA_80        ; if not token for NOT continue
.ced0	a0 18		ldy #$18	   LDY #$18          ; offset to NOT function
.ced2	d0 3b		bne $cf0f	   BNE Prep_Operation      ; do set-up for function then execute, branch always
.ced4					  Basic_EQUAL
.ced4	20 bf d1	jsr $d1bf	   JSR Eval_Integer
.ced7	a5 65		lda $65		   LDA FAC1M4        ; get FAC1 mantissa 4
.ced9	49 ff		eor #$ff	   EOR #$FF          ; invert it
.cedb	a8		tay		   TAY               ; copy it
.cedc	a5 64		lda $64		   LDA FAC1M3        ; get FAC1 mantissa 3
.cede	49 ff		eor #$ff	   EOR #$FF          ; invert it
.cee0	4c 91 d3	jmp $d391	   JMP Integer_To_Float
.cee3					EVA_80
.cee3	c9 a5		cmp #$a5	   CMP #TK_FN        ; compare with token for FN
.cee5	d0 03		bne $ceea	   BNE EVA_90        ; if not token for FN continue
.cee7	4c f4 d3	jmp $d3f4	   JMP Eval_FNX      ; else go evaluate FNx
.ceea					EVA_90
.ceea	c9 b4		cmp #$b4	   CMP #TK_SGN       ; compare with token for SGN
.ceec	90 03		bcc $cef1	   BCC Eval_In_Parenthesis
.ceee	4c a7 cf	jmp $cfa7	   JMP Function_Call
.cef1					  Eval_In_Parenthesis
.cef1	20 fa ce	jsr $cefa	   JSR Need_Left_Parenthesis
.cef4	20 9e cd	jsr $cd9e	   JSR Eval_Expression
.cef7					  Need_Right_Parenthesis
.cef7	a9 29		lda #$29	   LDA #')'
>cef9	2c				   .byte   $2C       ; skip until Need_A
.cefa					  Need_Left_Parenthesis
.cefa	a9 28		lda #$28	   LDA #'('
>cefc	2c				   .byte   $2C       ; skip until Need_A
.cefd					  Need_Comma
.cefd	a9 2c		lda #$2c	   LDA #','
.ceff					  Need_A
.ceff	a0 00		ldy #$00	   LDY #0
.cf01	d1 7a		cmp ($7a),y	   CMP (TXTPTR),Y    ; compare with BASIC byte
.cf03	d0 03		bne $cf08	   BNE Syntax_Error
.cf05	4c 73 00	jmp $0073	   JMP CHRGET        ; else next program byte and return
.cf08					  Syntax_Error
.cf08	a2 0b		ldx #$0b	   LDX #$0B          ; error code $0B, syntax error
.cf0a	4c 37 c4	jmp $c437	   JMP Basic_Error
.cf0d					  Prep_Minus_Operation
.cf0d	a0 15		ldy #$15	   LDY #$15          ; set offset from base to > operator
.cf0f					Prep_Operation
.cf0f	68		pla		   PLA               ; dump return address low byte
.cf10	68		pla		   PLA               ; dump return address high byte
.cf11	4c fa cd	jmp $cdfa	   JMP EvEx_45      ; execute function then continue evaluation
.cf14					  Is_Inside_BASIC_ROM
.cf14	38		sec		   SEC
.cf15	a5 64		lda $64		   LDA FAC1M3        ; get variable address low byte
.cf17	e9 00		sbc #$00	   SBC #<BASIC_ROM   ; subtract BASIC_ROM low byte
.cf19	a5 65		lda $65		   LDA FAC1M4        ; get variable address high byte
.cf1b	e9 c0		sbc #$c0	   SBC #>BASIC_ROM   ; subtract BASIC_ROM high byte
.cf1d	90 08		bcc $cf27	   BCC IIBR_Ret      ; exit if address < BASIC_ROM
.cf1f	a9 87		lda #$87	   LDA #<CHRGET_ROM  ; get end of BASIC marker low byte
.cf21	e5 64		sbc $64		   SBC FAC1M3        ; subtract variable address low byte
.cf23	a9 e3		lda #$e3	   LDA #>CHRGET_ROM  ; get end of BASIC marker high byte
.cf25	e5 65		sbc $65		   SBC FAC1M4        ; subtract variable address high byte
.cf27					IIBR_Ret
.cf27	60		rts		   RTS
.cf28					  Get_Var
.cf28	20 8b d0	jsr $d08b	   JSR Get_Scalar_Address
.cf2b	85 64		sta $64		   STA FAC1M3
.cf2d	84 65		sty $65		   STY FAC1M3+1
.cf2f	a6 45		ldx $45		   LDX VARNAM
.cf31	a4 46		ldy $46		   LDY VARNAM+1
.cf33	a5 0d		lda $0d		   LDA VALTYP        ; get data type flag, $FF = string, $00 = numeric
.cf35	f0 26		beq $cf5d	   BEQ Load_Value    ; if numeric go handle a numeric variable
.cf37	a9 00		lda #$00	   LDA #0
.cf39	85 70		sta $70		   STA FAC1M5        ; clear FAC1 rounding byte
.cf3b	20 14 cf	jsr $cf14	   JSR Is_Inside_BASIC_ROM
.cf3e	90 1c		bcc $cf5c	   BCC GeVa_Ret      ; exit if not in BASIC ROM
.cf40	e0 54		cpx #$54	   CPX #'T'          ; compare variable name first character with "T"
.cf42	d0 18		bne $cf5c	   BNE GeVa_Ret      ; exit if not "T"
.cf44	c0 c9		cpy #$c9	   CPY #'I'+$80      ; compare variable name second character with "I$"
.cf46	d0 14		bne $cf5c	   BNE GeVa_Ret      ; exit if not "I$"
.cf48	20 84 cf	jsr $cf84	   JSR Load_Jiffyclock
.cf4b	84 5e		sty $5e		   STY TMPVA2        ; clear exponent count adjust
.cf4d	88		dey		   DEY               ; Y = $FF
.cf4e	84 71		sty $71		   STY TMPPTD        ; set output string index, -1 to allow for pre increment
.cf50	a0 06		ldy #$06	   LDY #6            ; HH:MM:SS is six digits
.cf52	84 5d		sty $5d		   STY TMPVA1        ; set number of characters before the decimal point
.cf54	a0 24		ldy #$24	   LDY #Jiffy_Conversion_Table-Decimal_Conversion_Table
.cf56	20 68 de	jsr $de68	   JSR Format_Jiffyclock
.cf59	4c 6f d4	jmp $d46f	   JMP BaST_10      ; exit via STR$() code tail
.cf5c					GeVa_Ret
.cf5c	60		rts		   RTS
.cf5d					  Load_Value
.cf5d	24 0e		bit $0e		   BIT INTFLG        ; test data type flag, $80 = integer, $00 = float
.cf5f	10 0d		bpl $cf6e	   BPL Load_Float    ; if float go handle float
.cf61	a0 00		ldy #$00	   LDY #0
.cf63	b1 64		lda ($64),y	   LDA (FAC1M3),Y    ; get integer variable low byte
.cf65	aa		tax		   TAX               ; copy to X
.cf66	c8		iny		   INY
.cf67	b1 64		lda ($64),y	   LDA (FAC1M3),Y    ; get integer variable high byte
.cf69	a8		tay		   TAY               ; copy to Y
.cf6a	8a		txa		   TXA               ; copy loa byte to A
.cf6b	4c 91 d3	jmp $d391	   JMP Integer_To_Float
.cf6e					  Load_Float
.cf6e	20 14 cf	jsr $cf14	   JSR Is_Inside_BASIC_ROM
.cf71	90 2d		bcc $cfa0	   BCC Load_Float_Var ; if not get pointer and unpack into FAC1
.cf73	e0 54		cpx #$54	   CPX #'T'
.cf75	d0 1b		bne $cf92	   BNE Check_ST_Var
.cf77	c0 49		cpy #$49	   CPY #'I'          ; is it "TI" ?
.cf79	d0 25		bne $cfa0	   BNE Load_Float_Var
.cf7b	20 84 cf	jsr $cf84	   JSR Load_Jiffyclock
.cf7e	98		tya		   TYA               ; clear A
.cf7f	a2 a0		ldx #$a0	   LDX #$A0          ; set exponent to 32 bit value
.cf81	4c 4f dc	jmp $dc4f	   JMP CITF_10       ; set exponent = X and normalise FAC1
.cf84					  Load_Jiffyclock
.cf84	20 de ff	jsr $ffde	   JSR RDTIM         ; Read system clock
.cf87	86 64		stx $64		   STX FAC1M3        ; save jiffy clock mid byte as  FAC1 mantissa 3
.cf89	84 63		sty $63		   STY FAC1M2        ; save jiffy clock high byte as  FAC1 mantissa 2
.cf8b	85 65		sta $65		   STA FAC1M4        ; save jiffy clock low byte as  FAC1 mantissa 4
.cf8d	a0 00		ldy #$00	   LDY #$00          ; clear Y
.cf8f	84 62		sty $62		   STY FAC1M1        ; clear FAC1 mantissa 1
.cf91	60		rts		   RTS
.cf92					  Check_ST_Var
.cf92	e0 53		cpx #$53	   CPX #'S'
.cf94	d0 0a		bne $cfa0	   BNE Load_Float_Var
.cf96	c0 54		cpy #$54	   CPY #'T'          ; is it "ST" ?
.cf98	d0 06		bne $cfa0	   BNE Load_Float_Var
.cf9a	20 b7 ff	jsr $ffb7	   JSR READST
.cf9d	4c 3c dc	jmp $dc3c	   JMP A_To_FAC1
.cfa0					  Load_Float_Var
.cfa0	a5 64		lda $64		   LDA FAC1M3
.cfa2	a4 65		ldy $65		   LDY FAC1M3+1
.cfa4	4c a2 db	jmp $dba2	   JMP Load_FAC1_AY
.cfa7					  Function_Call
.cfa7	0a		asl a		   ASL A             ; offset = 2 * (token  - $80) : bit 7 shifted out
.cfa8	48		pha		   PHA               ; save function offset
.cfa9	aa		tax		   TAX               ; copy function offset
.cfaa	20 73 00	jsr $0073	   JSR CHRGET
.cfad	e0 8f		cpx #$8f	   CPX #$8F ;#((TK_CHRS - $80) * 2) + 1 ; chr$ index + 1
.cfaf	90 20		bcc $cfd1	   BCC FuCa_10       ; branch if not left$, right$, mid$
.cfb1	20 fa ce	jsr $cefa	   JSR Need_Left_Parenthesis
.cfb4	20 9e cd	jsr $cd9e	   JSR Eval_Expression
.cfb7	20 fd ce	jsr $cefd	   JSR Need_Comma
.cfba	20 8f cd	jsr $cd8f	   JSR Assert_String_Type
.cfbd	68		pla		   PLA               ; restore function offset
.cfbe	aa		tax		   TAX               ; copy it
.cfbf	a5 65		lda $65		   LDA FAC1M3+1
.cfc1	48		pha		   PHA
.cfc2	a5 64		lda $64		   LDA FAC1M3
.cfc4	48		pha		   PHA
.cfc5	8a		txa		   TXA               ; restore function offset
.cfc6	48		pha		   PHA               ; save function offset
.cfc7	20 9e d7	jsr $d79e	   JSR Get_Byte_Value
.cfca	68		pla		   PLA               ; restore function offset
.cfcb	a8		tay		   TAY               ; copy function offset
.cfcc	8a		txa		   TXA               ; copy byte parameter to A
.cfcd	48		pha		   PHA               ; push byte parameter
.cfce	4c d6 cf	jmp $cfd6	   JMP FuCa_20       ; go call function
.cfd1					FuCa_10
.cfd1	20 f1 ce	jsr $cef1	   JSR Eval_In_Parenthesis
.cfd4	68		pla		   PLA               ; restore function offset
.cfd5	a8		tay		   TAY               ; copy to index
.cfd6					FuCa_20
.cfd6	b9 ea bf	lda $bfea,y	   LDA $BFEA,y ;Basic_Function_Table-2*(TK_SGN-$80),Y    ; .. -$68
.cfd9	85 55		sta $55		   STA FUNJMP
.cfdb	b9 eb bf	lda $bfeb,y	   LDA $BFEB,y ;Basic_Function_Table-2*(TK_SGN-$80)+1,Y  ; .. -$67
.cfde	85 56		sta $56		   STA FUNJMP+1
.cfe0	20 54 00	jsr $0054	   JSR JUMPER
.cfe3	4c 8d cd	jmp $cd8d	   JMP Is_Numeric
.cfe6					  Basic_OR
.cfe6	a0 ff		ldy #$ff	   LDY #$FF          ; set Y for OR
>cfe8	2c				   .byte   $2C       ; skip next statement
.cfe9					  Basic_AND
.cfe9	a0 00		ldy #$00	   LDY #$00          ; clear Y for AND
.cfeb	84 0b		sty $0b		   STY COUNT         ; set AND/OR invert value
.cfed	20 bf d1	jsr $d1bf	   JSR Eval_Integer
.cff0	a5 64		lda $64		   LDA FAC1M3        ; get FAC1 mantissa 3
.cff2	45 0b		eor $0b		   EOR COUNT         ; EOR low byte
.cff4	85 07		sta $07		   STA CHARAC        ; save it
.cff6	a5 65		lda $65		   LDA FAC1M4        ; get FAC1 mantissa 4
.cff8	45 0b		eor $0b		   EOR COUNT         ; EOR high byte
.cffa	85 08		sta $08		   STA ENDCHR        ; save it
.cffc	20 fc db	jsr $dbfc	   JSR FAC2_To_FAC1
.cfff	20 bf d1	jsr $d1bf	   JSR Eval_Integer
.d002	a5 65		lda $65		   LDA FAC1M4        ; get FAC1 mantissa 4
.d004	45 0b		eor $0b		   EOR COUNT         ; EOR high byte
.d006	25 08		and $08		   AND ENDCHR        ; AND with expression 1 high byte
.d008	45 0b		eor $0b		   EOR COUNT         ; EOR result high byte
.d00a	a8		tay		   TAY               ; save in Y
.d00b	a5 64		lda $64		   LDA FAC1M3        ; get FAC1 mantissa 3
.d00d	45 0b		eor $0b		   EOR COUNT         ; EOR low byte
.d00f	25 07		and $07		   AND CHARAC        ; AND with expression 1 low byte
.d011	45 0b		eor $0b		   EOR COUNT         ; EOR result low byte
.d013	4c 91 d3	jmp $d391	   JMP Integer_To_Float
.d016					  Basic_LESS
.d016	20 90 cd	jsr $cd90	   JSR Check_Var_Type
.d019	b0 13		bcs $d02e	   BCS BaLE_10       ; if string go do string compare
.d01b	a5 6e		lda $6e		   LDA FAC2SI        ; get FAC2 sign (b7)
.d01d	09 7f		ora #$7f	   ORA #$7F          ; set all non sign bits
.d01f	25 6a		and $6a		   AND FAC2M1        ; and FAC2 mantissa 1 (AND in sign bit)
.d021	85 6a		sta $6a		   STA FAC2M1        ; save FAC2 mantissa 1
.d023	a9 69		lda #$69	   LDA #<FAC2EX ;#<addr
.d025	a0 00		ldy #$00	   LDY #>FAC2EX ;#>addr
.d027	20 5b dc	jsr $dc5b	   JSR Compare_FAC1_AY
.d02a	aa		tax		   TAX               ; copy the result
.d02b	4c 61 d0	jmp $d061	   JMP BaLE_40       ; go evaluate result
.d02e					BaLE_10
.d02e	a9 00		lda #$00	   LDA #0
.d030	85 0d		sta $0d		   STA VALTYP        ; clear data type flag, $FF = string, $00 = numeric
.d032	c6 4d		dec $4d		   DEC ACCSYM        ; clear < bit in comparrison evaluation flag
.d034	20 a6 d6	jsr $d6a6	   JSR Get_String_Descriptor
.d037	85 61		sta $61		   STA FAC1EX        ; save length
.d039	86 62		stx $62		   STX FAC1M1        ; save string pointer low byte
.d03b	84 63		sty $63		   STY FAC1M2        ; save string pointer high byte
.d03d	a5 6c		lda $6c		   LDA FAC2M3        ; get descriptor pointer low byte
.d03f	a4 6d		ldy $6d		   LDY FAC2M4        ; get descriptor pointer high byte
.d041	20 aa d6	jsr $d6aa	   JSR Get_String_Descriptor_AY
.d044	86 6c		stx $6c		   STX FAC2M3        ; save string pointer low byte
.d046	84 6d		sty $6d		   STY FAC2M4        ; save string pointer high byte
.d048	aa		tax		   TAX               ; copy length
.d049	38		sec		   SEC
.d04a	e5 61		sbc $61		   SBC FAC1EX        ; subtract string 1 length
.d04c	f0 08		beq $d056	   BEQ BaLE_20       ; if str 1 length = string 2 length go compare the strings
.d04e	a9 01		lda #$01	   LDA #1            ; set str 1 length > string 2 length
.d050	90 04		bcc $d056	   BCC BaLE_20       ; if so return + 1 if otherwise equal
.d052	a6 61		ldx $61		   LDX FAC1EX        ; get string 1 length
.d054	a9 ff		lda #$ff	   LDA #$FF          ; set str 1 length < string 2 length
.d056					BaLE_20
.d056	85 66		sta $66		   STA FAC1SI        ; save length compare
.d058	a0 ff		ldy #$ff	   LDY #$FF          ; set index
.d05a	e8		inx		   INX               ; adjust for loop
.d05b					BaLE_30
.d05b	c8		iny		   INY
.d05c	ca		dex		   DEX               ; decrement count
.d05d	d0 07		bne $d066	   BNE BaLE_50       ; if still bytes to do go compare them
.d05f	a6 66		ldx $66		   LDX FAC1SI        ; get length compare back
.d061					BaLE_40
.d061	30 0f		bmi $d072	   BMI BaLE_60       ; branch if str 1 < str 2
.d063	18		clc		   CLC               ; flag str 1 <= str 2
.d064	90 0c		bcc $d072	   BCC BaLE_60       ; go evaluate result, branch always
.d066					BaLE_50
.d066	b1 6c		lda ($6c),y	   LDA (FAC2M3),Y    ; get string 2 byte
.d068	d1 62		cmp ($62),y	   CMP (FAC1M1),Y    ; compare with string 1 byte
.d06a	f0 ef		beq $d05b	   BEQ BaLE_30       ; loop if bytes =
.d06c	a2 ff		ldx #$ff	   LDX #$FF          ; set str 1 < string 2
.d06e	b0 02		bcs $d072	   BCS BaLE_60       ; branch if so
.d070	a2 01		ldx #$01	   LDX #$01          ; set str 1 > string 2
.d072					BaLE_60
.d072	e8		inx		   INX               ; x = 0, 1 or 2
.d073	8a		txa		   TXA               ; copy to A
.d074	2a		rol a		   ROL A             ; * 2 (1, 2 or 4)
.d075	25 12		and $12		   AND TANSGN        ; AND with the comparison evaluation flag
.d077	f0 02		beq $d07b	   BEQ BaLE_70       ; branch if 0 (compare is false)
.d079	a9 ff		lda #$ff	   LDA #$FF          ; else set result true
.d07b					BaLE_70
.d07b	4c 3c dc	jmp $dc3c	   JMP A_To_FAC1
.d07e					DIM_00
.d07e	20 fd ce	jsr $cefd	   JSR Need_Comma
.d081					  Basic_DIM
.d081	aa		tax		   TAX               ; copy "DIM" flag to X
.d082	20 90 d0	jsr $d090	   JSR Get_Array_Address
.d085	20 79 00	jsr $0079	   JSR CHRGOT
.d088	d0 f4		bne $d07e	   BNE DIM_00      ; scan for "," and loop if not null
.d08a	60		rts		   RTS
.d08b					  Get_Scalar_Address
.d08b	a2 00		ldx #$00	   LDX #$00          ; set DIM flag = $00
.d08d	20 79 00	jsr $0079	   JSR CHRGOT        ; 1st. character
.d090					  Get_Array_Address
.d090	86 0c		stx $0c		   STX DIMFLG        ; save DIM flag
.d092					  Get_FN_Address
.d092	85 45		sta $45		   STA VARNAM        ; save 1st character
.d094	20 79 00	jsr $0079	   JSR CHRGOT
.d097	20 13 d1	jsr $d113	   JSR Is_Alpha
.d09a	b0 03		bcs $d09f	   BCS Get_Address      ; if ok continue
.d09c					Var_Syntax_Error
.d09c	4c 08 cf	jmp $cf08	   JMP Syntax_Error
.d09f					  Get_Address
.d09f	a2 00		ldx #$00	   LDX #0            ; clear 2nd character temp
.d0a1	86 0d		stx $0d		   STX VALTYP        ; clear data type flag, $FF = string, $00 = numeric
.d0a3	86 0e		stx $0e		   STX INTFLG        ; clear data type flag, $80 = integer, $00 = float
.d0a5	20 73 00	jsr $0073	   JSR CHRGET        ; 2nd character
.d0a8	90 05		bcc $d0af	   BCC GAdd_05       ; if character = "0"-"9" (ok) go save 2nd character
.d0aa	20 13 d1	jsr $d113	   JSR Is_Alpha
.d0ad	90 0b		bcc $d0ba	   BCC GAdd_15       ; if <"A" or >"Z" go check if string
.d0af					GAdd_05
.d0af	aa		tax		   TAX               ; copy 2nd character
.d0b0					GAdd_10
.d0b0	20 73 00	jsr $0073	   JSR CHRGET        ; 3rd character
.d0b3	90 fb		bcc $d0b0	   BCC GAdd_10       ; loop if character = "0"-"9" (ignore)
.d0b5	20 13 d1	jsr $d113	   JSR Is_Alpha
.d0b8	b0 f6		bcs $d0b0	   BCS GAdd_10       ; loop if character = "A"-"Z" (ignore)
.d0ba					GAdd_15
.d0ba	c9 24		cmp #$24	   CMP #'$'
.d0bc	d0 06		bne $d0c4	   BNE GAdd_20       ; if not string go check integer
.d0be	a9 ff		lda #$ff	   LDA #$FF          ; set data type = string
.d0c0	85 0d		sta $0d		   STA VALTYP        ; set data type flag, $FF = string, $00 = numeric
.d0c2	d0 10		bne $d0d4	   BNE GAdd_25       ; branch always
.d0c4					GAdd_20
.d0c4	c9 25		cmp #$25	   CMP #'%'
.d0c6	d0 13		bne $d0db	   BNE GAdd_30       ; if not integer go check for an array
.d0c8	a5 10		lda $10		   LDA SUBFLG        ; get subscript/FNX flag
.d0ca	d0 d0		bne $d09c	   BNE Var_Syntax_Error      ; if ?? do syntax error then warm start
.d0cc	a9 80		lda #$80	   LDA #$80          ; set integer type
.d0ce	85 0e		sta $0e		   STA INTFLG        ; set data type = integer
.d0d0	05 45		ora $45		   ORA VARNAM        ; OR current variable name first byte
.d0d2	85 45		sta $45		   STA VARNAM        ; save current variable name first byte
.d0d4					GAdd_25
.d0d4	8a		txa		   TXA               ; get 2nd character back
.d0d5	09 80		ora #$80	   ORA #$80          ; set top bit, indicate string or integer variable
.d0d7	aa		tax		   TAX               ; copy back to 2nd character temp
.d0d8	20 73 00	jsr $0073	   JSR CHRGET
.d0db					GAdd_30
.d0db	86 46		stx $46		   STX VARNAM+1      ; save 2nd character
.d0dd	38		sec		   SEC
.d0de	05 10		ora $10		   ORA SUBFLG        ; or with subscript/FNX flag - or FN name
.d0e0	e9 28		sbc #$28	   SBC #'('
.d0e2	d0 03		bne $d0e7	   BNE GAdd_35       ; if not "(" go find a plain numeric variable
.d0e4	4c d1 d1	jmp $d1d1	   JMP Find_Array
.d0e7					GAdd_35
.d0e7	a0 00		ldy #$00	   LDY #0
.d0e9	84 10		sty $10		   STY SUBFLG        ; clear subscript/FNX flag
.d0eb	a5 2d		lda $2d		   LDA VARTAB
.d0ed	a6 2e		ldx $2e		   LDX VARTAB+1
.d0ef					GAdd_40
.d0ef	86 60		stx $60		   STX TMPPTC+1      ; save search address high byte
.d0f1					GAdd_45
.d0f1	85 5f		sta $5f		   STA TMPPTC        ; save search address low byte
.d0f3	e4 30		cpx $30		   CPX ARYTAB+1      ; compare with end of variables high byte
.d0f5	d0 04		bne $d0fb	   BNE GAdd_50       ; skip next compare if <>
.d0f7	c5 2f		cmp $2f		   CMP ARYTAB        ; compare low address with end of variables low byte
.d0f9	f0 22		beq $d11d	   BEQ Create_Var      ; if not found go make new variable
.d0fb					GAdd_50
.d0fb	a5 45		lda $45		   LDA VARNAM        ; get 1st character of variable to find
.d0fd	d1 5f		cmp ($5f),y	   CMP (TMPPTC),Y    ; compare with variable name 1st character
.d0ff	d0 08		bne $d109	   BNE GAdd_55       ; if no match go try the next variable
.d101	a5 46		lda $46		   LDA VARNAM+1      ; get 2nd character of variable to find
.d103	c8		iny		   INY               ; index to point to variable name 2nd character
.d104	d1 5f		cmp ($5f),y	   CMP (TMPPTC),Y    ; compare with variable name 2nd character
.d106	f0 7d		beq $d185	   BEQ CrVa_70      ; if match go return the variable
.d108	88		dey		   DEY               ; else decrement index (now = $00)
.d109					GAdd_55
.d109	18		clc		   CLC
.d10a	a5 5f		lda $5f		   LDA TMPPTC        ; get search address low byte
.d10c	69 07		adc #$07	   ADC #7            ; +7, offset to next variable name
.d10e	90 e1		bcc $d0f1	   BCC GAdd_45       ; loop if no overflow to high byte
.d110	e8		inx		   INX               ; else increment high byte
.d111	d0 dc		bne $d0ef	   BNE GAdd_40       ; loop always, RAM doesn't extend to $FFFF
.d113					  Is_Alpha
.d113	c9 41		cmp #$41	   CMP #'A'
.d115	90 05		bcc $d11c	   BCC IA_RET
.d117	e9 5b		sbc #$5b	   SBC #$5B          ; subtract "Z"+1
.d119	38		sec		   SEC
.d11a	e9 a5		sbc #$a5	   SBC #$A5          ; subtract $A5 (restore byte)
.d11c					IA_RET
.d11c	60		rts		   RTS
.d11d					  Create_Var
.d11d	68		pla		   PLA               ; pop return address low byte
.d11e	48		pha		   PHA               ; push return address low byte
.d11f	c9 2a		cmp #$2a	   CMP #<Get_Var+2 ; compare with expected calling routine return low byte
.d121	d0 05		bne $d128	   BNE CrVa_20       ; if not get variable go create new variable
.d123					CrVa_10
.d123	a9 13		lda #$13	   LDA #<NULL_Descriptor ;#<addr
.d125	a0 df		ldy #$df	   LDY #>NULL_Descriptor ;#>addr
.d127	60		rts		   RTS
.d128					CrVa_20
.d128	a5 45		lda $45		   LDA VARNAM
.d12a	a4 46		ldy $46		   LDY VARNAM+1
.d12c	c9 54		cmp #$54	   CMP #'T'
.d12e	d0 0b		bne $d13b	   BNE CrVa_40
.d130	c0 c9		cpy #$c9	   CPY #'I'+$80      ; is it TI$ ?
.d132	f0 ef		beq $d123	   BEQ CrVa_10
.d134	c0 49		cpy #$49	   CPY #'I'
.d136	d0 03		bne $d13b	   BNE CrVa_40       ; is it TI ?
.d138					CrVa_30
.d138	4c 08 cf	jmp $cf08	   JMP Syntax_Error
.d13b					CrVa_40
.d13b	c9 53		cmp #$53	   CMP #'S'          ; compare first character with "S"
.d13d	d0 04		bne $d143	   BNE CrVa_50      ; if not "S" continue
.d13f	c0 54		cpy #$54	   CPY #'T'          ; compare second character with "T"
.d141	f0 f5		beq $d138	   BEQ CrVa_30       ; if name is "ST" do syntax error
.d143					CrVa_50
.d143	a5 2f		lda $2f		   LDA ARYTAB
.d145	a4 30		ldy $30		   LDY ARYTAB+1
.d147	85 5f		sta $5f		   STA TMPPTC
.d149	84 60		sty $60		   STY TMPPTC+1
.d14b	a5 31		lda $31		   LDA STREND
.d14d	a4 32		ldy $32		   LDY STREND+1
.d14f	85 5a		sta $5a		   STA TMPPTB
.d151	84 5b		sty $5b		   STY TMPPTB+1
.d153	18		clc		   CLC
.d154	69 07		adc #$07	   ADC #7            ; +7, space for one variable
.d156	90 01		bcc $d159	   BCC CrVa_60       ; if no overflow skip the high byte increment
.d158	c8		iny		   INY               ; else increment high byte
.d159					CrVa_60
.d159	85 58		sta $58		   STA TMPPTA
.d15b	84 59		sty $59		   STY TMPPTA+1
.d15d	20 b8 c3	jsr $c3b8	   JSR Open_Up_Space
.d160	a5 58		lda $58		   LDA TMPPTA
.d162	a4 59		ldy $59		   LDY TMPPTA+1
.d164	c8		iny		   INY               ; correct high byte
.d165	85 2f		sta $2f		   STA ARYTAB
.d167	84 30		sty $30		   STY ARYTAB+1
.d169	a0 00		ldy #$00	   LDY #0
.d16b	a5 45		lda $45		   LDA VARNAM        ; get variable name 1st character
.d16d	91 5f		sta ($5f),y	   STA (TMPPTC),Y    ; save variable name 1st character
.d16f	c8		iny		   INY
.d170	a5 46		lda $46		   LDA VARNAM+1      ; get variable name 2nd character
.d172	91 5f		sta ($5f),y	   STA (TMPPTC),Y    ; save variable name 2nd character
.d174	a9 00		lda #$00	   LDA #0
.d176	c8		iny		   INY
.d177	91 5f		sta ($5f),y	   STA (TMPPTC),Y    ; initialise variable byte
.d179	c8		iny		   INY
.d17a	91 5f		sta ($5f),y	   STA (TMPPTC),Y    ; initialise variable byte
.d17c	c8		iny		   INY
.d17d	91 5f		sta ($5f),y	   STA (TMPPTC),Y    ; initialise variable byte
.d17f	c8		iny		   INY
.d180	91 5f		sta ($5f),y	   STA (TMPPTC),Y    ; initialise variable byte
.d182	c8		iny		   INY
.d183	91 5f		sta ($5f),y	   STA (TMPPTC),Y    ; initialise variable byte
.d185					CrVa_70
.d185	a5 5f		lda $5f		   LDA TMPPTC        ; get variable address low byte
.d187	18		clc		   CLC
.d188	69 02		adc #$02	   ADC #$02          ; +2, offset past variable name bytes
.d18a	a4 60		ldy $60		   LDY TMPPTC+1      ; get variable address high byte
.d18c	90 01		bcc $d18f	   BCC CrVa_80       ; if no overflow skip the high byte increment
.d18e	c8		iny		   INY               ; else increment high byte
.d18f					CrVa_80
.d18f	85 47		sta $47		   STA VARPNT
.d191	84 48		sty $48		   STY VARPNT+1
.d193	60		rts		   RTS
.d194					  Array_Pointer_To_First
.d194	a5 0b		lda $0b		   LDA COUNT         ; get # of dimensions (1, 2 or 3)
.d196	0a		asl a		   ASL A             ; *2 (also clears the carry !)
.d197	69 05		adc #$05	   ADC #$05          ; +5 (result is 7, 9 or 11 here)
.d199	65 5f		adc $5f		   ADC TMPPTC        ; add array start pointer low byte
.d19b	a4 60		ldy $60		   LDY TMPPTC+1      ; get array pointer high byte
.d19d	90 01		bcc $d1a0	   BCC APTF_10       ; if no overflow skip the high byte increment
.d19f	c8		iny		   INY               ; else increment high byte
.d1a0					APTF_10
.d1a0	85 58		sta $58		   STA TMPPTA
.d1a2	84 59		sty $59		   STY TMPPTA+1
.d1a4	60		rts		   RTS
>d1a5	90 80 00 00 00			Float_M32768 .byte $90,$80,$00,$00,$00 ;.real -32768
.d1aa					  Float_To_Integer
.d1aa	20 bf d1	jsr $d1bf	   JSR Eval_Integer
.d1ad	a5 64		lda $64		   LDA FAC1M3        ; get result low byte
.d1af	a4 65		ldy $65		   LDY FAC1M4        ; get result high byte
.d1b1	60		rts		   RTS
.d1b2					  Eval_Positive_Integer
.d1b2	20 73 00	jsr $0073	   JSR CHRGET
.d1b5	20 9e cd	jsr $cd9e	   JSR Eval_Expression
.d1b8					  Eval_Positive_Integer_Check
.d1b8	20 8d cd	jsr $cd8d	   JSR Is_Numeric
.d1bb	a5 66		lda $66		   LDA FAC1SI        ; get FAC1 sign (b7)
.d1bd	30 0d		bmi $d1cc	   BMI EvIn_10       ; do illegal quantity error negative
.d1bf					  Eval_Integer
.d1bf	a5 61		lda $61		   LDA FAC1EX        ; get FAC1 exponent
.d1c1	c9 90		cmp #$90	   CMP #$90          ; compare with exponent = 2^16 (n>2^15)
.d1c3	90 09		bcc $d1ce	   BCC EvIn_20       ; if n<2^16 go convert FAC1 floating to fixed and return
.d1c5	a9 a5		lda #$a5	   LDA #<Float_M32768 ;#<addr
.d1c7	a0 d1		ldy #$d1	   LDY #>Float_M32768 ;#>addr
.d1c9	20 5b dc	jsr $dc5b	   JSR Compare_FAC1_AY
.d1cc					EvIn_10
.d1cc	d0 7a		bne $d248	   BNE Illegal_Quantity
.d1ce					EvIn_20
.d1ce	4c 9b dc	jmp $dc9b	   JMP FAC1_To_Integer
.d1d1					  Find_Array
.d1d1	a5 0c		lda $0c		   LDA DIMFLG        ; get DIM flag
.d1d3	05 0e		ora $0e		   ORA INTFLG        ; OR with data type flag
.d1d5	48		pha		   PHA               ; push it
.d1d6	a5 0d		lda $0d		   LDA VALTYP        ; get data type flag, $FF = string, $00 = numeric
.d1d8	48		pha		   PHA               ; push it
.d1d9	a0 00		ldy #$00	   LDY #0            ; clear dimensions count
.d1db					FiAr_05
.d1db	98		tya		   TYA               ; copy dimensions count
.d1dc	48		pha		   PHA               ; save it
.d1dd	a5 46		lda $46		   LDA VARNAM+1
.d1df	48		pha		   PHA
.d1e0	a5 45		lda $45		   LDA VARNAM
.d1e2	48		pha		   PHA
.d1e3	20 b2 d1	jsr $d1b2	   JSR Eval_Positive_Integer
.d1e6	68		pla		   PLA
.d1e7	85 45		sta $45		   STA VARNAM
.d1e9	68		pla		   PLA
.d1ea	85 46		sta $46		   STA VARNAM+1
.d1ec	68		pla		   PLA               ; pull dimensions count
.d1ed	a8		tay		   TAY               ; restore it
.d1ee	ba		tsx		   TSX               ; copy stack pointer
.d1ef	bd 02 01	lda $0102,x	   LDA STACK+2,X     ; get DIM flag
.d1f2	48		pha		   PHA               ; push it
.d1f3	bd 01 01	lda $0101,x	   LDA STACK+1,X     ; get data type flag
.d1f6	48		pha		   PHA               ; push it
.d1f7	a5 64		lda $64		   LDA FAC1M3        ; get this dimension size high byte
.d1f9	9d 02 01	sta $0102,x	   STA STACK+2,X     ; stack before flag bytes
.d1fc	a5 65		lda $65		   LDA FAC1M4        ; get this dimension size low byte
.d1fe	9d 01 01	sta $0101,x	   STA STACK+1,X     ; stack before flag bytes
.d201	c8		iny		   INY               ; increment dimensions count
.d202	20 79 00	jsr $0079	   JSR CHRGOT
.d205	c9 2c		cmp #$2c	   CMP #','
.d207	f0 d2		beq $d1db	   BEQ FiAr_05       ; if found go do next dimension
.d209	84 0b		sty $0b		   STY COUNT         ; store dimensions count
.d20b	20 f7 ce	jsr $cef7	   JSR Need_Right_Parenthesis
.d20e	68		pla		   PLA               ; pull data type flag
.d20f	85 0d		sta $0d		   STA VALTYP        ; restore data type flag, $FF = string, $00 = numeric
.d211	68		pla		   PLA               ; pull data type flag
.d212	85 0e		sta $0e		   STA INTFLG        ; restore data type flag, $80 = integer, $00 = float
.d214	29 7f		and #$7f	   AND #$7F          ; mask dim flag
.d216	85 0c		sta $0c		   STA DIMFLG        ; restore DIM flag
.d218	a6 2f		ldx $2f		   LDX ARYTAB        ; set end of variables low byte
.d21a	a5 30		lda $30		   LDA ARYTAB+1      ; set end of variables high byte
.d21c					FiAr_10
.d21c	86 5f		stx $5f		   STX TMPPTC        ; save as array start pointer low byte
.d21e	85 60		sta $60		   STA TMPPTC+1      ; save as array start pointer high byte
.d220	c5 32		cmp $32		   CMP STREND+1      ; compare with end of arrays high byte
.d222	d0 04		bne $d228	   BNE FiAr_15       ; if not reached array memory end continue searching
.d224	e4 31		cpx $31		   CPX STREND        ; else compare with end of arrays low byte
.d226	f0 39		beq $d261	   BEQ FiAr_30       ; go build array if not found
.d228					FiAr_15
.d228	a0 00		ldy #$00	   LDY #0
.d22a	b1 5f		lda ($5f),y	   LDA (TMPPTC),Y    ; get array name first byte
.d22c	c8		iny		   INY
.d22d	c5 45		cmp $45		   CMP VARNAM        ; compare with this array name first byte
.d22f	d0 06		bne $d237	   BNE FiAr_20       ; if no match go try the next array
.d231	a5 46		lda $46		   LDA VARNAM+1      ; else get this array name second byte
.d233	d1 5f		cmp ($5f),y	   CMP (TMPPTC),Y    ; compare with array name second byte
.d235	f0 16		beq $d24d	   BEQ FiAr_25       ; array found so branch
.d237					FiAr_20
.d237	c8		iny		   INY
.d238	b1 5f		lda ($5f),y	   LDA (TMPPTC),Y    ; get array size low byte
.d23a	18		clc		   CLC
.d23b	65 5f		adc $5f		   ADC TMPPTC        ; add array start pointer low byte
.d23d	aa		tax		   TAX               ; copy low byte to X
.d23e	c8		iny		   INY
.d23f	b1 5f		lda ($5f),y	   LDA (TMPPTC),Y    ; get array size high byte
.d241	65 60		adc $60		   ADC TMPPTC+1      ; add array memory pointer high byte
.d243	90 d7		bcc $d21c	   BCC FiAr_10      ; if no overflow go check next array
.d245					  Bad_Subscript
.d245	a2 12		ldx #$12	   LDX #$12          ; error $12, bad subscript error
>d247	2c				   .byte   $2C       ; skip next statement
.d248					  Illegal_Quantity
.d248	a2 0e		ldx #$0e	   LDX #$0E          ; error $0E, illegal quantity error
.d24a					Jump_Basic_Error
.d24a	4c 37 c4	jmp $c437	   JMP Basic_Error
.d24d					FiAr_25
.d24d	a2 13		ldx #$13	   LDX #$13          ; set error $13, double dimension error
.d24f	a5 0c		lda $0c		   LDA DIMFLG        ; get DIM flag
.d251	d0 f7		bne $d24a	   BNE Jump_Basic_Error
.d253	20 94 d1	jsr $d194	   JSR Array_Pointer_To_First
.d256	a5 0b		lda $0b		   LDA COUNT         ; get dimensions count
.d258	a0 04		ldy #$04	   LDY #4            ; set index to array's # of dimensions
.d25a	d1 5f		cmp ($5f),y	   CMP (TMPPTC),Y    ; compare with no of dimensions
.d25c	d0 e7		bne $d245	   BNE Bad_Subscript ; if wrong do bad subscript error
.d25e	4c ea d2	jmp $d2ea	   JMP Find_Array_Element
.d261					FiAr_30
.d261	20 94 d1	jsr $d194	   JSR Array_Pointer_To_First
.d264	20 08 c4	jsr $c408	   JSR Check_Mem_Avail
.d267	a0 00		ldy #$00	   LDY #0
.d269	84 72		sty $72		   STY TMPPTD+1      ; clear array data size high byte
.d26b	a2 05		ldx #$05	   LDX #5            ; set default element size
.d26d	a5 45		lda $45		   LDA VARNAM        ; get variable name 1st byte
.d26f	91 5f		sta ($5f),y	   STA (TMPPTC),Y    ; save array name 1st byte
.d271	10 01		bpl $d274	   BPL FiAr_35       ; branch if not string or floating point array
.d273	ca		dex		   DEX               ; decrement element size, $04
.d274					FiAr_35
.d274	c8		iny		   INY
.d275	a5 46		lda $46		   LDA VARNAM+1      ; get variable name 2nd byte
.d277	91 5f		sta ($5f),y	   STA (TMPPTC),Y    ; save array name 2nd byte
.d279	10 02		bpl $d27d	   BPL FiAr_40       ; branch if not integer or string
.d27b	ca		dex		   DEX               ; decrement element size, $03
.d27c	ca		dex		   DEX               ; decrement element size, $02
.d27d					FiAr_40
.d27d	86 71		stx $71		   STX TMPPTD        ; save element size
.d27f	a5 0b		lda $0b		   LDA COUNT         ; get dimensions count
.d281	c8		iny		   INY
.d282	c8		iny		   INY               ; .. to array  ..
.d283	c8		iny		   INY               ; .. dimension count
.d284	91 5f		sta ($5f),y	   STA (TMPPTC),Y    ; save array dimension count
.d286					FiAr_45
.d286	a2 0b		ldx #$0b	   LDX #11           ; set default dimension size low byte (0:10)
.d288	a9 00		lda #$00	   LDA #0            ; set default dimension size high byte
.d28a	24 0c		bit $0c		   BIT DIMFLG        ; test DIM flag
.d28c	50 08		bvc $d296	   BVC FiAr_50       ; if default to be used don't pull a dimension
.d28e	68		pla		   PLA               ; pull dimension size low byte
.d28f	18		clc		   CLC
.d290	69 01		adc #$01	   ADC #1            ; add 1, allow for zeroeth element
.d292	aa		tax		   TAX               ; copy low byte to X
.d293	68		pla		   PLA               ; pull dimension size high byte
.d294	69 00		adc #$00	   ADC #0            ; add carry to high byte
.d296					FiAr_50
.d296	c8		iny		   INY               ; incement index to dimension size high byte
.d297	91 5f		sta ($5f),y	   STA (TMPPTC),Y    ; save dimension size high byte
.d299	c8		iny		   INY               ; incement index to dimension size low byte
.d29a	8a		txa		   TXA               ; copy dimension size low byte
.d29b	91 5f		sta ($5f),y	   STA (TMPPTC),Y    ; save dimension size low byte
.d29d	20 4c d3	jsr $d34c	   JSR Compute_Array_Size
.d2a0	86 71		stx $71		   STX TMPPTD        ; save result low byte
.d2a2	85 72		sta $72		   STA TMPPTD+1      ; save result high byte
.d2a4	a4 22		ldy $22		   LDY INDEXA        ; restore index
.d2a6	c6 0b		dec $0b		   DEC COUNT         ; decrement dimensions count
.d2a8	d0 dc		bne $d286	   BNE FiAr_45       ; loop if not all done
.d2aa	65 59		adc $59		   ADC TMPPTA+1      ; add array data pointer high byte
.d2ac	b0 5d		bcs $d30b	   BCS FiAE_30       ; if overflow do out of memory error then warm start
.d2ae	85 59		sta $59		   STA TMPPTA+1      ; save array data pointer high byte
.d2b0	a8		tay		   TAY               ; copy array data pointer high byte
.d2b1	8a		txa		   TXA               ; copy array size low byte
.d2b2	65 58		adc $58		   ADC TMPPTA        ; add array data pointer low byte
.d2b4	90 03		bcc $d2b9	   BCC FiAr_55       ; if no rollover skip the high byte increment
.d2b6	c8		iny		   INY               ; else increment next array pointer high byte
.d2b7	f0 52		beq $d30b	   BEQ FiAE_30       ; if rolled over do out of memory error then warm start
.d2b9					FiAr_55
.d2b9	20 08 c4	jsr $c408	   JSR Check_Mem_Avail
.d2bc	85 31		sta $31		   STA STREND
.d2be	84 32		sty $32		   STY STREND+1
.d2c0	a9 00		lda #$00	   LDA #0            ; for array clear
.d2c2	e6 72		inc $72		   INC TMPPTD+1      ; increment array size high byte, now block count
.d2c4	a4 71		ldy $71		   LDY TMPPTD        ; get array size low byte, now index to block
.d2c6	f0 05		beq $d2cd	   BEQ FiAr_65       ; if $00 go do the high byte decrement
.d2c8					FiAr_60
.d2c8	88		dey		   DEY               ; decrement index, do 0 to n-1
.d2c9	91 58		sta ($58),y	   STA (TMPPTA),Y    ; clear array element byte
.d2cb	d0 fb		bne $d2c8	   BNE FiAr_60       ; loop until this block done
.d2cd					FiAr_65
.d2cd	c6 59		dec $59		   DEC TMPPTA+1      ; decrement array pointer high byte
.d2cf	c6 72		dec $72		   DEC TMPPTD+1      ; decrement block count high byte
.d2d1	d0 f5		bne $d2c8	   BNE FiAr_60       ; loop until all blocks done
.d2d3	e6 59		inc $59		   INC TMPPTA+1      ; correct for last loop
.d2d5	38		sec		   SEC
.d2d6	a5 31		lda $31		   LDA STREND        ; get end of arrays low byte
.d2d8	e5 5f		sbc $5f		   SBC TMPPTC        ; subtract array start low byte
.d2da	a0 02		ldy #$02	   LDY #$02          ; index to array size low byte
.d2dc	91 5f		sta ($5f),y	   STA (TMPPTC),Y    ; save array size low byte
.d2de	a5 32		lda $32		   LDA STREND+1      ; get end of arrays high byte
.d2e0	c8		iny		   INY               ; index to array size high byte
.d2e1	e5 60		sbc $60		   SBC TMPPTC+1      ; subtract array start high byte
.d2e3	91 5f		sta ($5f),y	   STA (TMPPTC),Y    ; save array size high byte
.d2e5	a5 0c		lda $0c		   LDA DIMFLG        ; get default DIM flag
.d2e7	d0 62		bne $d34b	   BNE FiAE_Ret      ; exit if this was a DIM command
.d2e9	c8		iny		   INY               ; set index to # of dimensions, the dimension indeces
.d2ea					  Find_Array_Element
.d2ea	b1 5f		lda ($5f),y	   LDA (TMPPTC),Y    ; get array's dimension count
.d2ec	85 0b		sta $0b		   STA COUNT         ; save it
.d2ee	a9 00		lda #$00	   LDA #0
.d2f0	85 71		sta $71		   STA TMPPTD        ; clear array data pointer low byte
.d2f2					FiAE_10
.d2f2	85 72		sta $72		   STA TMPPTD+1      ; save array data pointer high byte
.d2f4	c8		iny		   INY
.d2f5	68		pla		   PLA               ; pull array index low byte
.d2f6	aa		tax		   TAX               ; copy to X
.d2f7	85 64		sta $64		   STA FAC1M3        ; save index low byte to FAC1 mantissa 3
.d2f9	68		pla		   PLA               ; pull array index high byte
.d2fa	85 65		sta $65		   STA FAC1M4        ; save index high byte to FAC1 mantissa 4
.d2fc	d1 5f		cmp ($5f),y	   CMP (TMPPTC),Y    ; compare with array bound high byte
.d2fe	90 0e		bcc $d30e	   BCC FiAE_40       ; if within bounds continue
.d300	d0 06		bne $d308	   BNE FiAE_20       ; if outside bounds do bad subscript error
.d302	c8		iny		   INY               ; index to array bound low byte
.d303	8a		txa		   TXA               ; get array index low byte
.d304	d1 5f		cmp ($5f),y	   CMP (TMPPTC),Y    ; compare with array bound low byte
.d306	90 07		bcc $d30f	   BCC FiAE_50       ; if within bounds continue
.d308					FiAE_20
.d308	4c 45 d2	jmp $d245	   JMP Bad_Subscript
.d30b					FiAE_30
.d30b	4c 35 c4	jmp $c435	   JMP Error_Out_Of_Memory
.d30e					FiAE_40
.d30e	c8		iny		   INY               ; index to array bound low byte
.d30f					FiAE_50
.d30f	a5 72		lda $72		   LDA TMPPTD+1      ; get array data pointer high byte
.d311	05 71		ora $71		   ORA TMPPTD        ; OR with array data pointer low byte
.d313	18		clc		   CLC
.d314	f0 0a		beq $d320	   BEQ FiAE_60       ; if array data pointer = null skip the multiply
.d316	20 4c d3	jsr $d34c	   JSR Compute_Array_Size
.d319	8a		txa		   TXA               ; get result low byte
.d31a	65 64		adc $64		   ADC FAC1M3        ; add index low byte from FAC1 mantissa 3
.d31c	aa		tax		   TAX               ; save result low byte
.d31d	98		tya		   TYA               ; get result high byte
.d31e	a4 22		ldy $22		   LDY INDEXA        ; restore index
.d320					FiAE_60
.d320	65 65		adc $65		   ADC FAC1M4        ; add index high byte from FAC1 mantissa 4
.d322	86 71		stx $71		   STX TMPPTD        ; save array data pointer low byte
.d324	c6 0b		dec $0b		   DEC COUNT         ; decrement dimensions count
.d326	d0 ca		bne $d2f2	   BNE FiAE_10       ; loop if dimensions still to do
.d328	85 72		sta $72		   STA TMPPTD+1      ; save array data pointer high byte
.d32a	a2 05		ldx #$05	   LDX #$05          ; set default element size
.d32c	a5 45		lda $45		   LDA VARNAM        ; get variable name 1st byte
.d32e	10 01		bpl $d331	   BPL FiAE_70       ; branch if not string or floating point array
.d330	ca		dex		   DEX               ; decrement element size, $04
.d331					FiAE_70
.d331	a5 46		lda $46		   LDA VARNAM+1      ; get variable name 2nd byte
.d333	10 02		bpl $d337	   BPL FiAE_80       ; branch if not integer or string
.d335	ca		dex		   DEX               ; decrement element size, $03
.d336	ca		dex		   DEX               ; decrement element size, $02
.d337					FiAE_80
.d337	86 28		stx $28		   STX FAC3+3       ; save dimension size low byte
.d339	a9 00		lda #$00	   LDA #$00          ; clear dimension size high byte
.d33b	20 55 d3	jsr $d355	   JSR Compute_Array_Size_A
.d33e	8a		txa		   TXA               ; copy array size low byte
.d33f	65 58		adc $58		   ADC TMPPTA        ; add array data start pointer low byte
.d341	85 47		sta $47		   STA VARPNT        ; save as current variable pointer low byte
.d343	98		tya		   TYA               ; copy array size high byte
.d344	65 59		adc $59		   ADC TMPPTA+1      ; add array data start pointer high byte
.d346	85 48		sta $48		   STA VARPNT+1      ; save as current variable pointer high byte
.d348	a8		tay		   TAY               ; copy high byte to Y
.d349	a5 47		lda $47		   LDA VARPNT        ; get current variable pointer low byte
.d34b					FiAE_Ret
.d34b	60		rts		   RTS
.d34c					  Compute_Array_Size
.d34c	84 22		sty $22		   STY INDEXA        ; save index
.d34e	b1 5f		lda ($5f),y	   LDA (TMPPTC),Y    ; get dimension size low byte
.d350	85 28		sta $28		   STA FAC3+3       ; save dimension size low byte
.d352	88		dey		   DEY               ; decrement index
.d353	b1 5f		lda ($5f),y	   LDA (TMPPTC),Y    ; get dimension size high byte
.d355					  Compute_Array_Size_A
.d355	85 29		sta $29		   STA FAC3+4       ; save dimension size high byte
.d357	a9 10		lda #$10	   LDA #$10          ; count = $10 (16 bit multiply)
.d359	85 5d		sta $5d		   STA TMPVA1        ; save bit count
.d35b	a2 00		ldx #$00	   LDX #$00          ; clear result low byte
.d35d	a0 00		ldy #$00	   LDY #$00          ; clear result high byte
.d35f					CAS_10
.d35f	8a		txa		   TXA               ; get result low byte
.d360	0a		asl a		   ASL A             ; *2
.d361	aa		tax		   TAX               ; save result low byte
.d362	98		tya		   TYA               ; get result high byte
.d363	2a		rol a		   ROL A             ; *2
.d364	a8		tay		   TAY               ; save result high byte
.d365	b0 a4		bcs $d30b	   BCS FiAE_30       ; if overflow go do "Out of memory" error
.d367	06 71		asl $71		   ASL TMPPTD        ; shift element size low byte
.d369	26 72		rol $72		   ROL TMPPTD+1      ; shift element size high byte
.d36b	90 0b		bcc $d378	   BCC CAS_20        ; skip add if no carry
.d36d	18		clc		   CLC               ; else clear carry for add
.d36e	8a		txa		   TXA               ; get result low byte
.d36f	65 28		adc $28		   ADC FAC3+3       ; add dimension size low byte
.d371	aa		tax		   TAX               ; save result low byte
.d372	98		tya		   TYA               ; get result high byte
.d373	65 29		adc $29		   ADC FAC3+4       ; add dimension size high byte
.d375	a8		tay		   TAY               ; save result high byte
.d376	b0 93		bcs $d30b	   BCS FiAE_30       ; if overflow go do "Out of memory" error
.d378					CAS_20
.d378	c6 5d		dec $5d		   DEC TMPVA1        ; decrement bit count
.d37a	d0 e3		bne $d35f	   BNE CAS_10        ; loop until all done
.d37c	60		rts		   RTS
.d37d					  Basic_FRE
.d37d	a5 0d		lda $0d		   LDA VALTYP        ; get data type flag, $FF = string, $00 = numeric
.d37f	f0 03		beq $d384	   BEQ FRE_10        ; if numeric don't pop the string
.d381	20 a6 d6	jsr $d6a6	   JSR Get_String_Descriptor
.d384					FRE_10
.d384	20 26 d5	jsr $d526	   JSR Garbage_Collection
.d387	38		sec		   SEC
.d388	a5 33		lda $33		   LDA FRESPC        ; get bottom of string space low byte
.d38a	e5 31		sbc $31		   SBC STREND        ; subtract end of arrays low byte
.d38c	a8		tay		   TAY               ; copy result to Y
.d38d	a5 34		lda $34		   LDA FRESPC+1      ; get bottom of string space high byte
.d38f	e5 32		sbc $32		   SBC STREND+1      ; subtract end of arrays high byte
.d391					  Integer_To_Float
.d391	a2 00		ldx #$00	   LDX #$00          ; set type = numeric
.d393	86 0d		stx $0d		   STX VALTYP        ; clear data type flag, $FF = string, $00 = numeric
.d395	85 62		sta $62		   STA FAC1M1        ; save FAC1 mantissa 1
.d397	84 63		sty $63		   STY FAC1M2        ; save FAC1 mantissa 2
.d399	a2 90		ldx #$90	   LDX #$90          ; set exponent=2^16 (integer)
.d39b	4c 44 dc	jmp $dc44	   JMP Int_To_Float_Exp_X      ; set exp = X, clear FAC1 3 and 4, normalise and return
.d39e					  Basic_POS
.d39e	38		sec		   SEC               ; set Cb for read cursor position
.d39f	20 f0 ff	jsr $fff0	   JSR PLOT          ; Read or set cursor location
.d3a2					  Y_To_Float
.d3a2	a9 00		lda #$00	   LDA #0            ; clear high byte
.d3a4	f0 eb		beq $d391	   BEQ Integer_To_Float
.d3a6					  Assert_Non_Direct
.d3a6	a6 3a		ldx $3a		   LDX CURLIN+1      ; get current line number high byte
.d3a8	e8		inx		   INX               ; increment it
.d3a9	d0 a0		bne $d34b	   BNE FiAE_Ret      ; return if not direct mode
.d3ab	a2 15		ldx #$15	   LDX #$15          ; error $15, illegal direct error
>d3ad	2c				   .byte   $2C       ; skip next statement
.d3ae					  Undefined_Function
.d3ae	a2 1b		ldx #$1b	   LDX #$1B          ; error $1B, undefined function error
.d3b0	4c 37 c4	jmp $c437	   JMP Basic_Error
.d3b3					  Basic_DEF
.d3b3	20 e1 d3	jsr $d3e1	   JSR Get_FN
.d3b6	20 a6 d3	jsr $d3a6	   JSR Assert_Non_Direct
.d3b9	20 fa ce	jsr $cefa	   JSR Need_Left_Parenthesis
.d3bc	a9 80		lda #$80	   LDA #$80          ; set flag for FNx
.d3be	85 10		sta $10		   STA SUBFLG        ; save subscript/FNx flag
.d3c0	20 8b d0	jsr $d08b	   JSR Get_Scalar_Address
.d3c3	20 8d cd	jsr $cd8d	   JSR Is_Numeric
.d3c6	20 f7 ce	jsr $cef7	   JSR Need_Right_Parenthesis
.d3c9	a9 b2		lda #$b2	   LDA #TK_EQUAL     ; get = token
.d3cb	20 ff ce	jsr $ceff	   JSR Need_A
.d3ce	48		pha		   PHA               ; push next character
.d3cf	a5 48		lda $48		   LDA VARPNT+1
.d3d1	48		pha		   PHA
.d3d2	a5 47		lda $47		   LDA VARPNT
.d3d4	48		pha		   PHA
.d3d5	a5 7b		lda $7b		   LDA TXTPTR+1
.d3d7	48		pha		   PHA
.d3d8	a5 7a		lda $7a		   LDA TXTPTR
.d3da	48		pha		   PHA
.d3db	20 f8 c8	jsr $c8f8	   JSR Basic_DATA    ; perform DATA
.d3de	4c 4f d4	jmp $d44f	   JMP EvFN_30      ; put execute pointer and variable pointer into function
.d3e1					  Get_FN
.d3e1	a9 a5		lda #$a5	   LDA #TK_FN        ; set FN token
.d3e3	20 ff ce	jsr $ceff	   JSR Need_A
.d3e6	09 80		ora #$80	   ORA #$80          ; set FN flag bit
.d3e8	85 10		sta $10		   STA SUBFLG        ; save FN name
.d3ea	20 92 d0	jsr $d092	   JSR Get_FN_Address
.d3ed	85 4e		sta $4e		   STA FUNCPT
.d3ef	84 4f		sty $4f		   STY FUNCPT+1
.d3f1	4c 8d cd	jmp $cd8d	   JMP Is_Numeric
.d3f4					  Eval_FNX
.d3f4	20 e1 d3	jsr $d3e1	   JSR Get_FN
.d3f7	a5 4f		lda $4f		   LDA FUNCPT+1
.d3f9	48		pha		   PHA
.d3fa	a5 4e		lda $4e		   LDA FUNCPT
.d3fc	48		pha		   PHA
.d3fd	20 f1 ce	jsr $cef1	   JSR Eval_In_Parenthesis
.d400	20 8d cd	jsr $cd8d	   JSR Is_Numeric
.d403	68		pla		   PLA
.d404	85 4e		sta $4e		   STA FUNCPT
.d406	68		pla		   PLA
.d407	85 4f		sta $4f		   STA FUNCPT+1
.d409	a0 02		ldy #$02	   LDY #$02          ; index to variable pointer high byte
.d40b	b1 4e		lda ($4e),y	   LDA (FUNCPT),Y    ; get variable address low byte
.d40d	85 47		sta $47		   STA VARPNT        ; save current variable pointer low byte
.d40f	aa		tax		   TAX               ; copy address low byte
.d410	c8		iny		   INY               ; index to variable address high byte
.d411	b1 4e		lda ($4e),y	   LDA (FUNCPT),Y    ; get variable pointer high byte
.d413	f0 99		beq $d3ae	   BEQ Undefined_Function      ; if high byte zero go do undefined function error
.d415	85 48		sta $48		   STA VARPNT+1      ; save current variable pointer high byte
.d417	c8		iny		   INY               ; index to mantissa 3
.d418					EvFN_10
.d418	b1 47		lda ($47),y	   LDA (VARPNT),Y    ; get byte from variable
.d41a	48		pha		   PHA               ; stack it
.d41b	88		dey		   DEY               ; decrement index
.d41c	10 fa		bpl $d418	   BPL EvFN_10      ; loop until variable stacked
.d41e	a4 48		ldy $48		   LDY VARPNT+1      ; get current variable pointer high byte
.d420	20 d4 db	jsr $dbd4	   JSR Assign_FAC1_To_Var
.d423	a5 7b		lda $7b		   LDA TXTPTR+1
.d425	48		pha		   PHA
.d426	a5 7a		lda $7a		   LDA TXTPTR
.d428	48		pha		   PHA
.d429	b1 4e		lda ($4e),y	   LDA (FUNCPT),Y    ; get function execute pointer low byte
.d42b	85 7a		sta $7a		   STA TXTPTR        ; save BASIC execute pointer low byte
.d42d	c8		iny		   INY               ; index to high byte
.d42e	b1 4e		lda ($4e),y	   LDA (FUNCPT),Y    ; get function execute pointer high byte
.d430	85 7b		sta $7b		   STA TXTPTR+1      ; save BASIC execute pointer high byte
.d432	a5 48		lda $48		   LDA VARPNT+1
.d434	48		pha		   PHA
.d435	a5 47		lda $47		   LDA VARPNT
.d437	48		pha		   PHA
.d438	20 8a cd	jsr $cd8a	   JSR Eval_Numeric
.d43b	68		pla		   PLA
.d43c	85 4e		sta $4e		   STA FUNCPT
.d43e	68		pla		   PLA
.d43f	85 4f		sta $4f		   STA FUNCPT+1
.d441	20 79 00	jsr $0079	   JSR CHRGOT
.d444	f0 03		beq $d449	   BEQ EvFN_20      ; if null (should be [EOL] marker) continue
.d446	4c 08 cf	jmp $cf08	   JMP Syntax_Error
.d449					EvFN_20
.d449	68		pla		   PLA
.d44a	85 7a		sta $7a		   STA TXTPTR
.d44c	68		pla		   PLA
.d44d	85 7b		sta $7b		   STA TXTPTR+1
.d44f					EvFN_30
.d44f	a0 00		ldy #$00	   LDY #0
.d451	68		pla		   PLA               ; pull BASIC execute pointer low byte
.d452	91 4e		sta ($4e),y	   STA (FUNCPT),Y    ; save to function
.d454	68		pla		   PLA               ; pull BASIC execute pointer high byte
.d455	c8		iny		   INY
.d456	91 4e		sta ($4e),y	   STA (FUNCPT),Y    ; save to function
.d458	68		pla		   PLA               ; pull current variable address low byte
.d459	c8		iny		   INY
.d45a	91 4e		sta ($4e),y	   STA (FUNCPT),Y    ; save to function
.d45c	68		pla		   PLA               ; pull current variable address high byte
.d45d	c8		iny		   INY
.d45e	91 4e		sta ($4e),y	   STA (FUNCPT),Y    ; save to function
.d460	68		pla		   PLA               ; pull ??
.d461	c8		iny		   INY
.d462	91 4e		sta ($4e),y	   STA (FUNCPT),Y    ; save to function
.d464	60		rts		   RTS
.d465					  Basic_STR
.d465	20 8d cd	jsr $cd8d	   JSR Is_Numeric
.d468	a0 00		ldy #$00	   LDY #0
.d46a	20 df dd	jsr $dddf	   JSR Format_FAC1_Y
.d46d	68		pla		   PLA               ; dump return address (skip type check)
.d46e	68		pla		   PLA               ; dump return address (skip type check)
.d46f					BaST_10
.d46f	a9 ff		lda #$ff	   LDA #<BASSTO ;#<addr
.d471	a0 00		ldy #$00	   LDY #>BASSTO ;#>addr
.d473	f0 12		beq $d487	   BEQ Create_String_Descriptor
.d475					  Allocate_String_FAC1
.d475	a6 64		ldx $64		   LDX FAC1M3
.d477	a4 65		ldy $65		   LDY FAC1M3+1
.d479	86 50		stx $50		   STX DESCPT
.d47b	84 51		sty $51		   STY DESCPT+1
.d47d					  Allocate_String_A
.d47d	20 f4 d4	jsr $d4f4	   JSR Allocate_String_Space
.d480	86 62		stx $62		   STX FAC1M1        ; save string pointer low byte
.d482	84 63		sty $63		   STY FAC1M2        ; save string pointer high byte
.d484	85 61		sta $61		   STA FAC1EX        ; save length
.d486	60		rts		   RTS
.d487					  Create_String_Descriptor
.d487	a2 22		ldx #$22	   LDX #QUOTE
.d489	86 07		stx $07		   STX CHARAC        ; set terminator 1
.d48b	86 08		stx $08		   STX ENDCHR        ; set terminator 2
.d48d					  Create_String_Descriptor_AY
.d48d	85 6f		sta $6f		   STA STRPTR
.d48f	84 70		sty $70		   STY STRPTR+1
.d491	85 62		sta $62		   STA FAC1M1
.d493	84 63		sty $63		   STY FAC1M1+1
.d495	a0 ff		ldy #$ff	   LDY #$FF          ; set length to -1
.d497					CSD_10
.d497	c8		iny		   INY               ; increment length
.d498	b1 6f		lda ($6f),y	   LDA (STRPTR),Y    ; get byte from string
.d49a	f0 0c		beq $d4a8	   BEQ CSD_30        ; exit loop if null byte [EOS]
.d49c	c5 07		cmp $07		   CMP CHARAC        ; compare with search character, terminator 1
.d49e	f0 04		beq $d4a4	   BEQ CSD_20        ; branch if terminator
.d4a0	c5 08		cmp $08		   CMP ENDCHR        ; compare with terminator 2
.d4a2	d0 f3		bne $d497	   BNE CSD_10        ; loop if not terminator 2
.d4a4					CSD_20
.d4a4	c9 22		cmp #$22	   CMP #QUOTE
.d4a6	f0 01		beq $d4a9	   BEQ CSD_40        ; branch if " (carry set if = !)
.d4a8					CSD_30
.d4a8	18		clc		   CLC
.d4a9					CSD_40
.d4a9	84 61		sty $61		   STY FAC1EX        ; save length in FAC1 exponent
.d4ab	98		tya		   TYA               ; copy length to A
.d4ac	65 6f		adc $6f		   ADC STRPTR        ; add string start low byte
.d4ae	85 71		sta $71		   STA TMPPTD        ; save string end low byte
.d4b0	a6 70		ldx $70		   LDX STRPTR+1      ; get string start high byte
.d4b2	90 01		bcc $d4b5	   BCC CSD_50        ; if no low byte overflow skip the high byte increment
.d4b4	e8		inx		   INX               ; else increment high byte
.d4b5					CSD_50
.d4b5	86 72		stx $72		   STX TMPPTD+1      ; save string end high byte
.d4b7	a5 70		lda $70		   LDA STRPTR+1      ; get string start high byte
.d4b9	f0 04		beq $d4bf	   BEQ CSD_60        ; branch if in utility area
.d4bb	c9 02		cmp #$02	   CMP #$02          ; compare with input buffer memory high byte
.d4bd	d0 0b		bne $d4ca	   BNE Push_String_Descriptor
.d4bf					CSD_60
.d4bf	98		tya		   TYA               ; copy length to A
.d4c0	20 75 d4	jsr $d475	   JSR Allocate_String_FAC1
.d4c3	a6 6f		ldx $6f		   LDX STRPTR
.d4c5	a4 70		ldy $70		   LDY STRPTR+1
.d4c7					Store_And_Push_String
.d4c7	20 88 d6	jsr $d688	   JSR Store_String_XY
.d4ca					   Push_String_Descriptor
.d4ca	a6 16		ldx $16		   LDX TEMPPT        ; get descriptor stack pointer
.d4cc	e0 22		cpx #$22	   CPX #QUOTE
.d4ce	d0 05		bne $d4d5	   BNE PSD_20        ; branch if space on string stack
.d4d0	a2 19		ldx #$19	   LDX #$19          ; error $19, string too complex error
.d4d2					PSD_10
.d4d2	4c 37 c4	jmp $c437	   JMP Basic_Error
.d4d5					PSD_20
.d4d5	a5 61		lda $61		   LDA FAC1EX        ; get string length
.d4d7	95 00		sta $00,x	   STA 0,X           ; put on string stack
.d4d9	a5 62		lda $62		   LDA FAC1M1        ; get string pointer low byte
.d4db	95 01		sta $01,x	   STA 1,X           ; put on string stack
.d4dd	a5 63		lda $63		   LDA FAC1M2        ; get string pointer high byte
.d4df	95 02		sta $02,x	   STA 2,X           ; put on string stack
.d4e1	a0 00		ldy #$00	   LDY #0            ; clear Y
.d4e3	86 64		stx $64		   STX FAC1M3
.d4e5	84 65		sty $65		   STY FAC1M3+1
.d4e7	84 70		sty $70		   STY FAC1M5        ; clear FAC1 rounding byte
.d4e9	88		dey		   DEY               ; Y = $FF
.d4ea	84 0d		sty $0d		   STY VALTYP        ; save data type flag, $FF = string
.d4ec	86 17		stx $17		   STX LASTPT        ; save current descriptor stack item pointer low byte
.d4ee	e8		inx		   INX               ; update stack pointer
.d4ef	e8		inx		   INX               ; update stack pointer
.d4f0	e8		inx		   INX               ; update stack pointer
.d4f1	86 16		stx $16		   STX TEMPPT        ; set new descriptor stack pointer
.d4f3	60		rts		   RTS
.d4f4					  Allocate_String_Space
.d4f4	46 0f		lsr $0f		   LSR GARBFL        ; clear garbage collected flag (b7)
.d4f6					ASS_10
.d4f6	48		pha		   PHA               ; save string length
.d4f7	49 ff		eor #$ff	   EOR #$FF          ; complement it
.d4f9	38		sec		   SEC               ; set carry for subtract, two's complement add
.d4fa	65 33		adc $33		   ADC FRESPC        ; add bottom of string space low byte, subtract length
.d4fc	a4 34		ldy $34		   LDY FRESPC+1      ; get bottom of string space high byte
.d4fe	b0 01		bcs $d501	   BCS ASS_20        ; skip decrement if no underflow
.d500	88		dey		   DEY               ; decrement bottom of string space high byte
.d501					ASS_20
.d501	c4 32		cpy $32		   CPY STREND+1      ; compare with end of arrays high byte
.d503	90 11		bcc $d516	   BCC ASS_40        ; do out of memory error if less
.d505	d0 04		bne $d50b	   BNE ASS_30        ; if not = skip next test
.d507	c5 31		cmp $31		   CMP STREND        ; compare with end of arrays low byte
.d509	90 0b		bcc $d516	   BCC ASS_40        ; do out of memory error if less
.d50b					ASS_30
.d50b	85 33		sta $33		   STA FRESPC
.d50d	84 34		sty $34		   STY FRESPC+1
.d50f	85 35		sta $35		   STA UTLSTP
.d511	84 36		sty $36		   STY UTLSTP+1
.d513	aa		tax		   TAX               ; copy low byte to X
.d514	68		pla		   PLA               ; get string length back
.d515	60		rts		   RTS
.d516					ASS_40
.d516	a2 10		ldx #$10	   LDX #$10          ; error code $10, out of memory error
.d518	a5 0f		lda $0f		   LDA GARBFL        ; get garbage collected flag
.d51a	30 b6		bmi $d4d2	   BMI PSD_10        ; if set then do error code X
.d51c	20 26 d5	jsr $d526	   JSR Garbage_Collection
.d51f	a9 80		lda #$80	   LDA #$80          ; flag for garbage collected
.d521	85 0f		sta $0f		   STA GARBFL        ; set garbage collected flag
.d523	68		pla		   PLA               ; pull length
.d524	d0 d0		bne $d4f6	   BNE ASS_10        ; go try again (loop always, length should never be = $00)
.d526					  Garbage_Collection
.d526	a6 37		ldx $37		   LDX MEMSIZ        ; get end of memory low byte
.d528	a5 38		lda $38		   LDA MEMSIZ+1      ; get end of memory high byte
.d52a					GaCo_Iter
.d52a	86 33		stx $33		   STX FRESPC        ; set bottom of string space low byte
.d52c	85 34		sta $34		   STA FRESPC+1      ; set bottom of string space high byte
.d52e	a0 00		ldy #$00	   LDY #0
.d530	84 4f		sty $4f		   STY FUNCPT+1      ; clear working pointer high byte
.d532	84 4e		sty $4e		   STY FUNCPT        ; clear working pointer low byte
.d534	a5 31		lda $31		   LDA STREND
.d536	a6 32		ldx $32		   LDX STREND+1
.d538	85 5f		sta $5f		   STA TMPPTC
.d53a	86 60		stx $60		   STX TMPPTC+1
.d53c	a9 19		lda #$19	   LDA #TEMPST       ; set descriptor stack pointer
.d53e	a2 00		ldx #$00	   LDX #0            ; check first descriptors on string stack
.d540	85 22		sta $22		   STA INDEXA
.d542	86 23		stx $23		   STX INDEXA+1
.d544					GaCo_Loop_1
.d544	c5 16		cmp $16		   CMP TEMPPT        ; compare with descriptor stack pointer
.d546	f0 05		beq $d54d	   BEQ GaCo_10       ; branch if descripor on stack
.d548	20 c7 d5	jsr $d5c7	   JSR Check_String  ;
.d54b	f0 f7		beq $d544	   BEQ GaCo_Loop_1   ; loop always (Check_String returns with LDY #0)
.d54d					GaCo_10
.d54d	a9 07		lda #$07	   LDA #7            ; set step size = 7, collecting variables
.d54f	85 53		sta $53		   STA GARBSS        ; save garbage collection step size
.d551	a5 2d		lda $2d		   LDA VARTAB
.d553	a6 2e		ldx $2e		   LDX VARTAB+1
.d555	85 22		sta $22		   STA INDEXA
.d557	86 23		stx $23		   STX INDEXA+1
.d559					GaCo_20
.d559	e4 30		cpx $30		   CPX ARYTAB+1      ; compare end of variables high byte,
.d55b	d0 04		bne $d561	   BNE GaCo_30       ; branch if no high byte match
.d55d	c5 2f		cmp $2f		   CMP ARYTAB        ; else compare end of variables low byte,
.d55f	f0 05		beq $d566	   BEQ GaCo_40       ; branch if = variable memory end
.d561					GaCo_30
.d561	20 bd d5	jsr $d5bd	   JSR Check_Variable
.d564	f0 f3		beq $d559	   BEQ GaCo_20       ; loop always
.d566					GaCo_40
.d566	85 58		sta $58		   STA TMPPTA
.d568	86 59		stx $59		   STX TMPPTA+1
.d56a	a9 03		lda #$03	   LDA #3            ; set step size, collecting descriptors
.d56c	85 53		sta $53		   STA GARBSS        ; save step size
.d56e					GaCo_50
.d56e	a5 58		lda $58		   LDA TMPPTA
.d570	a6 59		ldx $59		   LDX TMPPTA+1
.d572					GaCo_60
.d572	e4 32		cpx $32		   CPX STREND+1      ; compare with end of arrays high byte
.d574	d0 07		bne $d57d	   BNE GaCo_70       ; branch if not at end
.d576	c5 31		cmp $31		   CMP STREND        ; else compare with end of arrays low byte
.d578	d0 03		bne $d57d	   BNE GaCo_70       ; branch if not at end
.d57a	4c 06 d6	jmp $d606	   JMP Collect_String
.d57d					GaCo_70
.d57d	85 22		sta $22		   STA INDEXA
.d57f	86 23		stx $23		   STX INDEXA+1
.d581	a0 00		ldy #$00	   LDY #0
.d583	b1 22		lda ($22),y	   LDA (INDEXA),Y    ; get array name first byte
.d585	aa		tax		   TAX               ; copy it
.d586	c8		iny		   INY
.d587	b1 22		lda ($22),y	   LDA (INDEXA),Y    ; get array name second byte
.d589	08		php		   PHP               ; push the flags
.d58a	c8		iny		   INY
.d58b	b1 22		lda ($22),y	   LDA (INDEXA),Y    ; get array size low byte
.d58d	65 58		adc $58		   ADC TMPPTA        ; add start of this array low byte
.d58f	85 58		sta $58		   STA TMPPTA        ; save start of next array low byte
.d591	c8		iny		   INY
.d592	b1 22		lda ($22),y	   LDA (INDEXA),Y    ; get array size high byte
.d594	65 59		adc $59		   ADC TMPPTA+1      ; add start of this array high byte
.d596	85 59		sta $59		   STA TMPPTA+1      ; save start of next array high byte
.d598	28		plp		   PLP               ; restore the flags
.d599	10 d3		bpl $d56e	   BPL GaCo_50       ; skip if not string array
.d59b	8a		txa		   TXA               ; get name first byte back
.d59c	30 d0		bmi $d56e	   BMI GaCo_50       ; skip if not string array
.d59e	c8		iny		   INY
.d59f	b1 22		lda ($22),y	   LDA (INDEXA),Y    ; get # of dimensions
.d5a1	a0 00		ldy #$00	   LDY #0
.d5a3	0a		asl a		   ASL A             ; *2
.d5a4	69 05		adc #$05	   ADC #5            ; +5 (array header size)
.d5a6	65 22		adc $22		   ADC INDEXA        ; add pointer low byte
.d5a8	85 22		sta $22		   STA INDEXA        ; save pointer low byte
.d5aa	90 02		bcc $d5ae	   BCC GaCo_80       ; if no rollover skip the high byte increment
.d5ac	e6 23		inc $23		   INC INDEXA+1      ; else increment pointer hgih byte
.d5ae					GaCo_80
.d5ae	a6 23		ldx $23		   LDX INDEXA+1      ; get pointer high byte
.d5b0					GaCo_90
.d5b0	e4 59		cpx $59		   CPX TMPPTA+1      ; compare pointer high byte with end of this array high byte
.d5b2	d0 04		bne $d5b8	   BNE GaCo_95       ; branch if not there yet
.d5b4	c5 58		cmp $58		   CMP TMPPTA        ; compare pointer low byte with end of this array low byte
.d5b6	f0 ba		beq $d572	   BEQ GaCo_60       ; if at end of this array go check next array
.d5b8					GaCo_95
.d5b8	20 c7 d5	jsr $d5c7	   JSR Check_String
.d5bb	f0 f3		beq $d5b0	   BEQ GaCo_90      ; loop
.d5bd					  Check_Variable
.d5bd	b1 22		lda ($22),y	   LDA (INDEXA),Y    ; get variable name first byte
.d5bf	30 35		bmi $d5f6	   BMI ChSt_30       ; add step and exit if not string
.d5c1	c8		iny		   INY
.d5c2	b1 22		lda ($22),y	   LDA (INDEXA),Y    ; get variable name second byte
.d5c4	10 30		bpl $d5f6	   BPL ChSt_30       ; add step and exit if not string
.d5c6	c8		iny		   INY
.d5c7					  Check_String
.d5c7	b1 22		lda ($22),y	   LDA (INDEXA),Y    ; get string length
.d5c9	f0 2b		beq $d5f6	   BEQ ChSt_30       ; add step and exit if null string
.d5cb	c8		iny		   INY
.d5cc	b1 22		lda ($22),y	   LDA (INDEXA),Y    ; get string pointer low byte
.d5ce	aa		tax		   TAX               ; copy to X
.d5cf	c8		iny		   INY
.d5d0	b1 22		lda ($22),y	   LDA (INDEXA),Y    ; get string pointer high byte
.d5d2	c5 34		cmp $34		   CMP FRESPC+1      ; compare string pointer high byte with bottom of string
.d5d4	90 06		bcc $d5dc	   BCC ChSt_10       ; if less go test against highest
.d5d6	d0 1e		bne $d5f6	   BNE ChSt_30       ; bottom of string space less string has been collected
.d5d8	e4 33		cpx $33		   CPX FRESPC        ; compare string pointer low byte with bottom of string
.d5da	b0 1a		bcs $d5f6	   BCS ChSt_30       ; if bottom of string space less string has been collected
.d5dc					ChSt_10
.d5dc	c5 60		cmp $60		   CMP TMPPTC+1      ; compare string pointer high byte with highest uncollected
.d5de	90 16		bcc $d5f6	   BCC ChSt_30       ; if highest uncollected string is greater then go update
.d5e0	d0 04		bne $d5e6	   BNE ChSt_20       ; if highest uncollected string is less then go set this
.d5e2	e4 5f		cpx $5f		   CPX TMPPTC        ; compare string pointer low byte with highest uncollected
.d5e4	90 10		bcc $d5f6	   BCC ChSt_30       ; if highest uncollected string is greater then go update
.d5e6					ChSt_20
.d5e6	86 5f		stx $5f		   STX TMPPTC        ; save string pointer low byte as highest uncollected string
.d5e8	85 60		sta $60		   STA TMPPTC+1      ; save string pointer high byte as highest uncollected
.d5ea	a5 22		lda $22		   LDA INDEXA
.d5ec	a6 23		ldx $23		   LDX INDEXA+1
.d5ee	85 4e		sta $4e		   STA FUNCPT
.d5f0	86 4f		stx $4f		   STX FUNCPT+1
.d5f2	a5 53		lda $53		   LDA GARBSS        ; get step size
.d5f4	85 55		sta $55		   STA FUNJMP        ; copy step size
.d5f6					ChSt_30
.d5f6	a5 53		lda $53		   LDA GARBSS        ; get step size (7 or 3)
.d5f8	18		clc		   CLC
.d5f9	65 22		adc $22		   ADC INDEXA        ; add pointer low byte
.d5fb	85 22		sta $22		   STA INDEXA        ; save pointer low byte
.d5fd	90 02		bcc $d601	   BCC ChSt_40       ; if no rollover skip the high byte increment
.d5ff	e6 23		inc $23		   INC INDEXA+1      ; else increment pointer high byte
.d601					ChSt_40
.d601	a6 23		ldx $23		   LDX INDEXA+1      ; get pointer high byte
.d603	a0 00		ldy #$00	   LDY #0
.d605	60		rts		   RTS
.d606					  Collect_String
.d606	a5 4f		lda $4f		   LDA FUNCPT+1      ; get working pointer low byte
.d608	05 4e		ora $4e		   ORA FUNCPT        ; OR working pointer high byte
.d60a	f0 f5		beq $d601	   BEQ ChSt_40       ; exit if nothing to collect
.d60c	a5 55		lda $55		   LDA FUNJMP        ; get copied step size
.d60e	29 04		and #$04	   AND #4            ; mask step size, 4 for variables, 0 for array or stack
.d610	4a		lsr a		   LSR A             ; 2 for variables, 0 for descriptors
.d611	a8		tay		   TAY               ; copy to index
.d612	85 55		sta $55		   STA FUNJMP        ; save offset to descriptor start
.d614	b1 4e		lda ($4e),y	   LDA (FUNCPT),Y    ; get string length
.d616	65 5f		adc $5f		   ADC TMPPTC        ; add string start low byte
.d618	85 5a		sta $5a		   STA TMPPTB        ; set block end low byte
.d61a	a5 60		lda $60		   LDA TMPPTC+1      ; get string start high byte
.d61c	69 00		adc #$00	   ADC #0            ; add carry
.d61e	85 5b		sta $5b		   STA TMPPTB+1      ; set block end high byte
.d620	a5 33		lda $33		   LDA FRESPC
.d622	a6 34		ldx $34		   LDX FRESPC+1
.d624	85 58		sta $58		   STA TMPPTA
.d626	86 59		stx $59		   STX TMPPTA+1
.d628	20 bf c3	jsr $c3bf	   JSR Move_Block
.d62b	a4 55		ldy $55		   LDY FUNJMP        ; restore offset to descriptor start
.d62d	c8		iny		   INY
.d62e	a5 58		lda $58		   LDA TMPPTA        ; get new string pointer low byte
.d630	91 4e		sta ($4e),y	   STA (FUNCPT),Y    ; save new string pointer low byte
.d632	aa		tax		   TAX               ; copy string pointer low byte
.d633	e6 59		inc $59		   INC TMPPTA+1      ; increment new string pointer high byte
.d635	a5 59		lda $59		   LDA TMPPTA+1      ; get new string pointer high byte
.d637	c8		iny		   INY
.d638	91 4e		sta ($4e),y	   STA (FUNCPT),Y    ; save new string pointer high byte
.d63a	4c 2a d5	jmp $d52a	   JMP GaCo_Iter     ; XA holds new bottom of string memory pointer
.d63d					  Concatenate
.d63d	a5 65		lda $65		   LDA FAC1M3+1
.d63f	48		pha		   PHA
.d640	a5 64		lda $64		   LDA FAC1M3
.d642	48		pha		   PHA
.d643	20 83 ce	jsr $ce83	   JSR Evaluate
.d646	20 8f cd	jsr $cd8f	   JSR Assert_String_Type
.d649	68		pla		   PLA
.d64a	85 6f		sta $6f		   STA STRPTR
.d64c	68		pla		   PLA
.d64d	85 70		sta $70		   STA STRPTR+1
.d64f	a0 00		ldy #$00	   LDY #0
.d651	b1 6f		lda ($6f),y	   LDA (STRPTR),Y    ; get length of first string from descriptor
.d653	18		clc		   CLC
.d654	71 64		adc ($64),y	   ADC (FAC1M3),Y    ; add length of second string
.d656	90 05		bcc $d65d	   BCC Conc_10       ; if no overflow continue
.d658	a2 17		ldx #$17	   LDX #$17          ; else error $17, string too long error
.d65a	4c 37 c4	jmp $c437	   JMP Basic_Error
.d65d					Conc_10
.d65d	20 75 d4	jsr $d475	   JSR Allocate_String_FAC1
.d660	20 7a d6	jsr $d67a	   JSR Store_String_STRPTR
.d663	a5 50		lda $50		   LDA DESCPT
.d665	a4 51		ldy $51		   LDY DESCPT+1
.d667	20 aa d6	jsr $d6aa	   JSR Get_String_Descriptor_AY
.d66a	20 8c d6	jsr $d68c	   JSR Store_String_INDEXA
.d66d	a5 6f		lda $6f		   LDA STRPTR
.d66f	a4 70		ldy $70		   LDY STRPTR+1
.d671	20 aa d6	jsr $d6aa	   JSR Get_String_Descriptor_AY
.d674	20 ca d4	jsr $d4ca	   JSR Push_String_Descriptor
.d677	4c b8 cd	jmp $cdb8	   JMP EvEx_15      ; continue evaluation
.d67a					  Store_String_STRPTR
.d67a	a0 00		ldy #$00	   LDY #0
.d67c	b1 6f		lda ($6f),y	   LDA (STRPTR),Y    ; get string length
.d67e	48		pha		   PHA               ; save it
.d67f	c8		iny		   INY
.d680	b1 6f		lda ($6f),y	   LDA (STRPTR),Y    ; get string pointer low byte
.d682	aa		tax		   TAX               ; copy to X
.d683	c8		iny		   INY
.d684	b1 6f		lda ($6f),y	   LDA (STRPTR),Y    ; get string pointer high byte
.d686	a8		tay		   TAY               ; copy to Y
.d687	68		pla		   PLA               ; get length back
.d688					  Store_String_XY
.d688	86 22		stx $22		   STX INDEXA
.d68a	84 23		sty $23		   STY INDEXA+1
.d68c					  Store_String_INDEXA
.d68c	a8		tay		   TAY               ; copy length as index
.d68d	f0 0a		beq $d699	   BEQ SSIN_20       ; branch if null string
.d68f	48		pha		   PHA               ; save length
.d690					SSIN_10
.d690	88		dey		   DEY               ; decrement length/index
.d691	b1 22		lda ($22),y	   LDA (INDEXA),Y    ; get byte from string
.d693	91 35		sta ($35),y	   STA (UTLSTP),Y    ; save byte to destination
.d695	98		tya		   TYA               ; y = 0 ?
.d696	d0 f8		bne $d690	   BNE SSIN_10       ; loop if not all done yet
.d698	68		pla		   PLA               ; restore length
.d699					SSIN_20
.d699	18		clc		   CLC
.d69a	65 35		adc $35		   ADC UTLSTP        ; add string utility ptr low byte
.d69c	85 35		sta $35		   STA UTLSTP        ; save string utility ptr low byte
.d69e	90 02		bcc $d6a2	   BCC SSIN_30       ; if no rollover skip the high byte increment
.d6a0	e6 36		inc $36		   INC UTLSTP+1      ; increment string utility ptr high byte
.d6a2					SSIN_30
.d6a2	60		rts		   RTS
.d6a3					  Eval_String
.d6a3	20 8f cd	jsr $cd8f	   JSR Assert_String_Type
.d6a6					  Get_String_Descriptor
.d6a6	a5 64		lda $64		   LDA FAC1M3
.d6a8	a4 65		ldy $65		   LDY FAC1M3+1
.d6aa					  Get_String_Descriptor_AY
.d6aa	85 22		sta $22		   STA INDEXA
.d6ac	84 23		sty $23		   STY INDEXA+1
.d6ae	20 db d6	jsr $d6db	   JSR Pop_Descriptor_Stack
.d6b1	08		php		   PHP               ; save status flags
.d6b2	a0 00		ldy #$00	   LDY #0
.d6b4	b1 22		lda ($22),y	   LDA (INDEXA),Y    ; get length from string descriptor
.d6b6	48		pha		   PHA
.d6b7	c8		iny		   INY
.d6b8	b1 22		lda ($22),y	   LDA (INDEXA),Y    ; get string pointer low byte from descriptor
.d6ba	aa		tax		   TAX
.d6bb	c8		iny		   INY
.d6bc	b1 22		lda ($22),y	   LDA (INDEXA),Y    ; get string pointer high byte from descriptor
.d6be	a8		tay		   TAY
.d6bf	68		pla		   PLA               ; get string length back
.d6c0	28		plp		   PLP               ; restore status
.d6c1	d0 13		bne $d6d6	   BNE GSD_20        ; branch if pointer not popped
.d6c3	c4 34		cpy $34		   CPY FRESPC+1      ; compare with bottom of string space high byte
.d6c5	d0 0f		bne $d6d6	   BNE GSD_20        ; branch if <>
.d6c7	e4 33		cpx $33		   CPX FRESPC        ; else compare with bottom of string space low byte
.d6c9	d0 0b		bne $d6d6	   BNE GSD_20        ; branch if <>
.d6cb	48		pha		   PHA               ; push string length
.d6cc	18		clc		   CLC               ; string address is identical to FRESPC,
.d6cd	65 33		adc $33		   ADC FRESPC        ; so we can free that memory easyli.
.d6cf	85 33		sta $33		   STA FRESPC
.d6d1	90 02		bcc $d6d5	   BCC GSD_10
.d6d3	e6 34		inc $34		   INC FRESPC+1
.d6d5					GSD_10
.d6d5	68		pla		   PLA               ; pull string length
.d6d6					GSD_20
.d6d6	86 22		stx $22		   STX INDEXA
.d6d8	84 23		sty $23		   STY INDEXA+1
.d6da	60		rts		   RTS
.d6db					  Pop_Descriptor_Stack
.d6db	c4 18		cpy $18		   CPY LASTPT+1      ; compare high byte with current descriptor stack item
.d6dd	d0 0c		bne $d6eb	   BNE PDS_Ret
.d6df	c5 17		cmp $17		   CMP LASTPT        ; compare low byte with current descriptor stack item
.d6e1	d0 08		bne $d6eb	   BNE PDS_Ret
.d6e3	85 16		sta $16		   STA TEMPPT        ; set descriptor stack pointer
.d6e5	e9 03		sbc #$03	   SBC #3            ; update last string pointer low byte
.d6e7	85 17		sta $17		   STA LASTPT        ; save current descriptor stack item pointer low byte
.d6e9	a0 00		ldy #$00	   LDY #0            ; set Z flag : descriptor popped
.d6eb					PDS_Ret
.d6eb	60		rts		   RTS
.d6ec					  Basic_CHR
.d6ec	20 a1 d7	jsr $d7a1	   JSR Eval_Byte
.d6ef	8a		txa		   TXA               ; copy to A
.d6f0	48		pha		   PHA               ; save character
.d6f1	a9 01		lda #$01	   LDA #$01          ; string is single byte
.d6f3	20 7d d4	jsr $d47d	   JSR Allocate_String_A
.d6f6	68		pla		   PLA               ; get character back
.d6f7	a0 00		ldy #$00	   LDY #0
.d6f9	91 62		sta ($62),y	   STA (FAC1M1),Y    ; save byte in string - byte IS string!
.d6fb	68		pla		   PLA               ; dump return address (skip type check)
.d6fc	68		pla		   PLA               ; dump return address (skip type check)
.d6fd	4c ca d4	jmp $d4ca	   JMP Push_String_Descriptor
.d700					  Basic_LEFT
.d700	20 61 d7	jsr $d761	   JSR Pop_String_Descriptor_And_Byte
.d703	d1 50		cmp ($50),y	   CMP (DESCPT),Y    ; compare byte parameter with string length
.d705	98		tya		   TYA               ; clear A
.d706					LEFT_10
.d706	90 04		bcc $d70c	   BCC LEFT_20       ; branch if string length > byte parameter
.d708	b1 50		lda ($50),y	   LDA (DESCPT),Y    ; else make parameter = length
.d70a	aa		tax		   TAX               ; copy to byte parameter copy
.d70b	98		tya		   TYA               ; clear string start offset
.d70c					LEFT_20
.d70c	48		pha		   PHA               ; save string start offset
.d70d					LEFT_30
.d70d	8a		txa		   TXA               ; copy byte parameter (or string length if <)
.d70e					LEFT_40
.d70e	48		pha		   PHA               ; save string length
.d70f	20 7d d4	jsr $d47d	   JSR Allocate_String_A
.d712	a5 50		lda $50		   LDA DESCPT
.d714	a4 51		ldy $51		   LDY DESCPT+1
.d716	20 aa d6	jsr $d6aa	   JSR Get_String_Descriptor_AY
.d719	68		pla		   PLA               ; get string length back
.d71a	a8		tay		   TAY               ; copy length to Y
.d71b	68		pla		   PLA               ; get string start offset back
.d71c	18		clc		   CLC
.d71d	65 22		adc $22		   ADC INDEXA        ; add start offset to string start pointer low byte
.d71f	85 22		sta $22		   STA INDEXA        ; save string start pointer low byte
.d721	90 02		bcc $d725	   BCC LEFT_50       ; if no overflow skip the high byte increment
.d723	e6 23		inc $23		   INC INDEXA+1      ; else increment string start pointer high byte
.d725					LEFT_50
.d725	98		tya		   TYA               ; copy length to A
.d726	20 8c d6	jsr $d68c	   JSR Store_String_INDEXA
.d729	4c ca d4	jmp $d4ca	   JMP Push_String_Descriptor
.d72c					  Basic_RIGHT
.d72c	20 61 d7	jsr $d761	   JSR Pop_String_Descriptor_And_Byte
.d72f	18		clc		   CLC
.d730	f1 50		sbc ($50),y	   SBC (DESCPT),Y    ; subtract string length
.d732	49 ff		eor #$ff	   EOR #$FF          ; invert it (A=LEN(expression$)-l)
.d734	4c 06 d7	jmp $d706	   JMP LEFT_10      ; go do rest of LEFT$()
.d737					  Basic_MID
.d737	a9 ff		lda #$ff	   LDA #$FF          ; set default length = 255
.d739	85 65		sta $65		   STA FAC1M4        ; save default length
.d73b	20 79 00	jsr $0079	   JSR CHRGOT
.d73e	c9 29		cmp #$29	   CMP #')'
.d740	f0 06		beq $d748	   BEQ MID_10        ; no 2nd. byte
.d742	20 fd ce	jsr $cefd	   JSR Need_Comma
.d745	20 9e d7	jsr $d79e	   JSR Get_Byte_Value
.d748					MID_10
.d748	20 61 d7	jsr $d761	   JSR Pop_String_Descriptor_And_Byte
.d74b	f0 4b		beq $d798	   BEQ Jump_To_Illegal_Quantity
.d74d	ca		dex		   DEX               ; decrement start index
.d74e	8a		txa		   TXA               ; copy to A
.d74f	48		pha		   PHA               ; save string start offset
.d750	18		clc		   CLC
.d751	a2 00		ldx #$00	   LDX #0            ; clear output string length
.d753	f1 50		sbc ($50),y	   SBC (DESCPT),Y    ; start - string length
.d755	b0 b6		bcs $d70d	   BCS LEFT_30       ; if start > string length go do null string
.d757	49 ff		eor #$ff	   EOR #$FF          ; complement -length
.d759	c5 65		cmp $65		   CMP FAC1M4        ; compare with length
.d75b	90 b1		bcc $d70e	   BCC LEFT_40       ; if length > remaining string go do RIGHT$
.d75d	a5 65		lda $65		   LDA FAC1M4        ; get length byte
.d75f	b0 ad		bcs $d70e	   BCS LEFT_40       ; go do string copy, branch always
.d761					  Pop_String_Descriptor_And_Byte
.d761	20 f7 ce	jsr $cef7	   JSR Need_Right_Parenthesis
.d764	68		pla		   PLA
.d765	a8		tay		   TAY               ; save return address low byte
.d766	68		pla		   PLA
.d767	85 55		sta $55		   STA FUNJMP        ; save return address high byte
.d769	68		pla		   PLA               ; dump call to function vector low byte
.d76a	68		pla		   PLA               ; dump call to function vector high byte
.d76b	68		pla		   PLA               ; pull byte parameter
.d76c	aa		tax		   TAX               ; copy byte parameter to X
.d76d	68		pla		   PLA
.d76e	85 50		sta $50		   STA DESCPT
.d770	68		pla		   PLA
.d771	85 51		sta $51		   STA DESCPT+1
.d773	a5 55		lda $55		   LDA FUNJMP        ; get return address high byte
.d775	48		pha		   PHA               ; back on stack
.d776	98		tya		   TYA               ; get return address low byte
.d777	48		pha		   PHA               ; back on stack
.d778	a0 00		ldy #$00	   LDY #0
.d77a	8a		txa		   TXA               ; copy byte parameter
.d77b	60		rts		   RTS
.d77c					  Basic_LEN
.d77c	20 82 d7	jsr $d782	   JSR Eval_String_And_Len
.d77f	4c a2 d3	jmp $d3a2	   JMP Y_To_Float      ; convert Y to byte in FAC1 and return
.d782					  Eval_String_And_Len
.d782	20 a3 d6	jsr $d6a3	   JSR Eval_String
.d785	a2 00		ldx #$00	   LDX #$00          ; set data type = numeric
.d787	86 0d		stx $0d		   STX VALTYP        ; clear data type flag, $FF = string, $00 = numeric
.d789	a8		tay		   TAY               ; copy length to Y
.d78a	60		rts		   RTS
.d78b					  Basic_ASC
.d78b	20 82 d7	jsr $d782	   JSR Eval_String_And_Len
.d78e	f0 08		beq $d798	   BEQ Jump_To_Illegal_Quantity
.d790	a0 00		ldy #$00	   LDY #0
.d792	b1 22		lda ($22),y	   LDA (INDEXA),Y    ; get 1st. byte
.d794	a8		tay		   TAY               ; copy to Y
.d795	4c a2 d3	jmp $d3a2	   JMP Y_To_Float
.d798					  Jump_To_Illegal_Quantity
.d798	4c 48 d2	jmp $d248	   JMP Illegal_Quantity
.d79b					  Get_Next_Byte_Value
.d79b	20 73 00	jsr $0073	   JSR CHRGET
.d79e					  Get_Byte_Value
.d79e	20 8a cd	jsr $cd8a	   JSR Eval_Numeric
.d7a1					  Eval_Byte
.d7a1	20 b8 d1	jsr $d1b8	   JSR Eval_Positive_Integer_Check
.d7a4	a6 64		ldx $64		   LDX FAC1M3        ; high byte must be 0
.d7a6	d0 f0		bne $d798	   BNE Jump_To_Illegal_Quantity
.d7a8	a6 65		ldx $65		   LDX FAC1M4
.d7aa	4c 79 00	jmp $0079	   JMP CHRGOT
.d7ad					  Basic_VAL
.d7ad	20 82 d7	jsr $d782	   JSR Eval_String_And_Len
.d7b0	d0 03		bne $d7b5	   BNE VAL_10        ; if not a null string go evaluate it
.d7b2	4c f7 d8	jmp $d8f7	   JMP Clear_FAC1_Exp_And_Sign
.d7b5					VAL_10
.d7b5	a6 7a		ldx $7a		   LDX TXTPTR
.d7b7	a4 7b		ldy $7b		   LDY TXTPTR+1
.d7b9	86 71		stx $71		   STX TMPPTD
.d7bb	84 72		sty $72		   STY TMPPTD+1
.d7bd	a6 22		ldx $22		   LDX INDEXA        ; get string pointer low byte
.d7bf	86 7a		stx $7a		   STX TXTPTR        ; save BASIC execute pointer low byte
.d7c1	18		clc		   CLC
.d7c2	65 22		adc $22		   ADC INDEXA        ; add string length
.d7c4	85 24		sta $24		   STA INDEXB        ; save string end low byte
.d7c6	a6 23		ldx $23		   LDX INDEXA+1      ; get string pointer high byte
.d7c8	86 7b		stx $7b		   STX TXTPTR+1      ; save BASIC execute pointer high byte
.d7ca	90 01		bcc $d7cd	   BCC VAL_20        ; if no rollover skip the high byte increment
.d7cc	e8		inx		   INX               ; increment string end high byte
.d7cd					VAL_20
.d7cd	86 25		stx $25		   STX INDEXB+1      ; save string end high byte
.d7cf	a0 00		ldy #$00	   LDY #0
.d7d1	b1 24		lda ($24),y	   LDA (INDEXB),Y    ; get string end byte
.d7d3	48		pha		   PHA               ; push it
.d7d4	98		tya		   TYA               ; clear A
.d7d5	91 24		sta ($24),y	   STA (INDEXB),Y    ; terminate string with 0
.d7d7	20 79 00	jsr $0079	   JSR CHRGOT
.d7da	20 f3 dc	jsr $dcf3	   JSR Load_FAC1_From_String
.d7dd	68		pla		   PLA               ; restore string end byte
.d7de	a0 00		ldy #$00	   LDY #0
.d7e0	91 24		sta ($24),y	   STA (INDEXB),Y    ; put string end byte back
.d7e2					  Restore_Execution_Pointer
.d7e2	a6 71		ldx $71		   LDX TMPPTD
.d7e4	a4 72		ldy $72		   LDY TMPPTD+1
.d7e6	86 7a		stx $7a		   STX TXTPTR
.d7e8	84 7b		sty $7b		   STY TXTPTR+1
.d7ea	60		rts		   RTS
.d7eb					  Get_Word_And_Byte
.d7eb	20 8a cd	jsr $cd8a	   JSR Eval_Numeric
.d7ee	20 f7 d7	jsr $d7f7	   JSR FAC1_To_LINNUM
.d7f1					  Need_Comma_Get_Byte
.d7f1	20 fd ce	jsr $cefd	   JSR Need_Comma
.d7f4	4c 9e d7	jmp $d79e	   JMP Get_Byte_Value
.d7f7					  FAC1_To_LINNUM
.d7f7	a5 66		lda $66		   LDA FAC1SI        ; get FAC1 sign
.d7f9	30 9d		bmi $d798	   BMI Jump_To_Illegal_Quantity
.d7fb	a5 61		lda $61		   LDA FAC1EX        ; get FAC1 exponent
.d7fd	c9 91		cmp #$91	   CMP #$91          ; compare with exponent = 2^16
.d7ff	b0 97		bcs $d798	   BCS Jump_To_Illegal_Quantity
.d801	20 9b dc	jsr $dc9b	   JSR FAC1_To_Integer
.d804	a5 64		lda $64		   LDA FAC1M3        ; get FAC1 mantissa 3
.d806	a4 65		ldy $65		   LDY FAC1M4        ; get FAC1 mantissa 4
.d808	84 14		sty $14		   STY LINNUM        ; save temporary integer low byte
.d80a	85 15		sta $15		   STA LINNUM+1      ; save temporary integer high byte
.d80c	60		rts		   RTS
.d80d					  Basic_PEEK
.d80d	a5 15		lda $15		   LDA LINNUM+1
.d80f	48		pha		   PHA
.d810	a5 14		lda $14		   LDA LINNUM
.d812	48		pha		   PHA
.d813	20 f7 d7	jsr $d7f7	   JSR FAC1_To_LINNUM
.d816	a0 00		ldy #$00	   LDY #0
.d818	b1 14		lda ($14),y	   LDA (LINNUM),Y    ; read byte
.d81a	a8		tay		   TAY               ; copy byte to Y
.d81b	68		pla		   PLA
.d81c	85 14		sta $14		   STA LINNUM
.d81e	68		pla		   PLA
.d81f	85 15		sta $15		   STA LINNUM+1
.d821	4c a2 d3	jmp $d3a2	   JMP Y_To_Float
.d824					  Basic_POKE
.d824	20 eb d7	jsr $d7eb	   JSR Get_Word_And_Byte
.d827	8a		txa		   TXA               ; copy byte to A
.d828	a0 00		ldy #$00	   LDY #0
.d82a	91 14		sta ($14),y	   STA (LINNUM),Y    ; write byte
.d82c	60		rts		   RTS
.d82d					  Basic_WAIT
.d82d	20 eb d7	jsr $d7eb	   JSR Get_Word_And_Byte
.d830	86 49		stx $49		   STX FORPNT        ; save byte
.d832	a2 00		ldx #$00	   LDX #0            ; clear mask
.d834	20 79 00	jsr $0079	   JSR CHRGOT
.d837	f0 03		beq $d83c	   BEQ WAIT_10      ; skip if no third argument
.d839	20 f1 d7	jsr $d7f1	   JSR Need_Comma_Get_Byte
.d83c					WAIT_10
.d83c	86 4a		stx $4a		   STX FORPNT+1      ; save EOR argument
.d83e	a0 00		ldy #$00	   LDY #0
.d840					WAIT_20
.d840	b1 14		lda ($14),y	   LDA (LINNUM),Y    ; get byte via temporary integer (address)
.d842	45 4a		eor $4a		   EOR FORPNT+1      ; EOR with second argument       (mask)
.d844	25 49		and $49		   AND FORPNT        ; AND with first argument        (byte)
.d846	f0 f8		beq $d840	   BEQ WAIT_20       ; loop if result is zero
.d848					WAIT_Ret
.d848	60		rts		   RTS
.d849					  Add_0_5_To_FAC1
.d849	a9 11		lda #$11	   LDA #<Float_0_5 ;#<addr
.d84b	a0 df		ldy #$df	   LDY #>Float_0_5 ;#>addr
.d84d	4c 67 d8	jmp $d867	   JMP Add_Var_AY_To_FAC1
.d850					  AY_Minus_FAC1
.d850	20 8c da	jsr $da8c	   JSR Load_FAC2_From_AY
.d853					  Basic_MINUS
.d853	a5 66		lda $66		   LDA FAC1SI        ; get FAC1 sign (b7)
.d855	49 ff		eor #$ff	   EOR #$FF          ; complement it
.d857	85 66		sta $66		   STA FAC1SI        ; save FAC1 sign (b7)
.d859	45 6e		eor $6e		   EOR FAC2SI        ; EOR with FAC2 sign (b7)
.d85b	85 6f		sta $6f		   STA STRPTR        ; save sign compare (FAC1 EOR FAC2)
.d85d	a5 61		lda $61		   LDA FAC1EX        ; get FAC1 exponent
.d85f	4c 6a d8	jmp $d86a	   JMP Basic_PLUS    ; add FAC2 to FAC1 and return
.d862					PLUS_00
.d862	20 99 d9	jsr $d999	   JSR Shift_FACX_A
.d865	90 3c		bcc $d8a3	   BCC PLUS_20      ; go subtract the mantissas, branch always
.d867					  Add_Var_AY_To_FAC1
.d867	20 8c da	jsr $da8c	   JSR Load_FAC2_From_AY
.d86a					  Basic_PLUS
.d86a	d0 03		bne $d86f	   BNE PLUS_05      ; if FAC1 is not zero continue
.d86c	4c fc db	jmp $dbfc	   JMP FAC2_To_FAC1
.d86f					PLUS_05
.d86f	a6 70		ldx $70		   LDX FAC1M5        ; get FAC1 rounding byte
.d871	86 56		stx $56		   STX FAC2M5        ; put FAC2 rounding byte
.d873	a2 69		ldx #$69	   LDX #FAC2EX       ; set index to FAC2
.d875	a5 69		lda $69		   LDA FAC2EX        ; get FAC2 exponent
.d877					  Add_FAC2_To_FAC1
.d877	a8		tay		   TAY               ; copy exponent
.d878	f0 ce		beq $d848	   BEQ WAIT_Ret      ; exit if FAC2 is zero
.d87a	38		sec		   SEC
.d87b	e5 61		sbc $61		   SBC FAC1EX        ; FAC2 exponent - FAC1 exponent
.d87d	f0 24		beq $d8a3	   BEQ PLUS_20       ; if equal go add mantissas
.d87f	90 12		bcc $d893	   BCC PLUS_10       ; if FAC2 < FAC1 then shift FAC2 right
.d881	84 61		sty $61		   STY FAC1EX        ; else                shift FAC1 right
.d883	a4 6e		ldy $6e		   LDY FAC2SI        ; get FAC2 sign (b7)
.d885	84 66		sty $66		   STY FAC1SI        ; put FAC1 sign (b7)
.d887	49 ff		eor #$ff	   EOR #$FF          ; complement A
.d889	69 00		adc #$00	   ADC #$00          ; +1, twos complement, carry is set
.d88b	a0 00		ldy #$00	   LDY #0
.d88d	84 56		sty $56		   STY FAC2M5        ; clear FAC2 rounding byte
.d88f	a2 61		ldx #$61	   LDX #FAC1EX       ; set index to FAC1
.d891	d0 04		bne $d897	   BNE PLUS_15       ; branch always
.d893					PLUS_10
.d893	a0 00		ldy #$00	   LDY #0
.d895	84 70		sty $70		   STY FAC1M5        ; clear FAC1 rounding byte
.d897					PLUS_15
.d897	c9 f9		cmp #$f9	   CMP #$F9          ; compare exponent diff with $F9
.d899	30 c7		bmi $d862	   BMI PLUS_00       ; branch if range $79-$F8
.d89b	a8		tay		   TAY               ; copy exponent difference to Y
.d89c	a5 70		lda $70		   LDA FAC1M5        ; get FAC1 rounding byte
.d89e	56 01		lsr $01,x	   LSR 1,X           ; shift FAC mantissa 1
.d8a0	20 b0 d9	jsr $d9b0	   JSR Shift_FACX_Right_Y
.d8a3					PLUS_20
.d8a3	24 6f		bit $6f		   BIT STRPTR        ; test sign compare (FAC1 EOR FAC2)
.d8a5	10 57		bpl $d8fe	   BPL PLUS_50      ; if = add FAC2 mantissa to FAC1 mantissa and return
.d8a7	a0 61		ldy #$61	   LDY #FAC1EX       ; set index to FAC1 exponent address
.d8a9	e0 69		cpx #$69	   CPX #FAC2EX       ; compare X to FAC2 exponent address
.d8ab	f0 02		beq $d8af	   BEQ PLUS_25       ; branch if equal
.d8ad	a0 69		ldy #$69	   LDY #FAC2EX       ; else set index to FAC2 exponent address
.d8af					PLUS_25
.d8af	38		sec		   SEC               ; compute FACY - FACX
.d8b0	49 ff		eor #$ff	   EOR #$FF          ; ones complement A
.d8b2	65 56		adc $56		   ADC FAC2M5        ; add FAC2 rounding byte
.d8b4	85 70		sta $70		   STA FAC1M5        ; put FAC1 rounding byte
.d8b6	b9 04 00	lda $0004,y	   LDA 4,Y
.d8b9	f5 04		sbc $04,x	   SBC 4,X
.d8bb	85 65		sta $65		   STA FAC1M4
.d8bd	b9 03 00	lda $0003,y	   LDA 3,Y
.d8c0	f5 03		sbc $03,x	   SBC 3,X
.d8c2	85 64		sta $64		   STA FAC1M3
.d8c4	b9 02 00	lda $0002,y	   LDA 2,Y
.d8c7	f5 02		sbc $02,x	   SBC 2,X
.d8c9	85 63		sta $63		   STA FAC1M2
.d8cb	b9 01 00	lda $0001,y	   LDA 1,Y
.d8ce	f5 01		sbc $01,x	   SBC 1,X
.d8d0	85 62		sta $62		   STA FAC1M1
.d8d2					PLUS_30
.d8d2	b0 03		bcs $d8d7	   BCS Normalise_FAC1
.d8d4	20 47 d9	jsr $d947	   JSR Negate_FAC1
.d8d7					  Normalise_FAC1
.d8d7	a0 00		ldy #$00	   LDY #0
.d8d9	98		tya		   TYA
.d8da	18		clc		   CLC
.d8db					PLUS_35
.d8db	a6 62		ldx $62		   LDX FAC1M1        ; get FAC1 mantissa 1
.d8dd	d0 4a		bne $d929	   BNE PLUS_60      ; if not zero normalise FAC1
.d8df	a6 63		ldx $63		   LDX FAC1M2        ; get FAC1 mantissa 2
.d8e1	86 62		stx $62		   STX FAC1M1        ; save FAC1 mantissa 1
.d8e3	a6 64		ldx $64		   LDX FAC1M3        ; get FAC1 mantissa 3
.d8e5	86 63		stx $63		   STX FAC1M2        ; save FAC1 mantissa 2
.d8e7	a6 65		ldx $65		   LDX FAC1M4        ; get FAC1 mantissa 4
.d8e9	86 64		stx $64		   STX FAC1M3        ; save FAC1 mantissa 3
.d8eb	a6 70		ldx $70		   LDX FAC1M5        ; get FAC1 rounding byte
.d8ed	86 65		stx $65		   STX FAC1M4        ; save FAC1 mantissa 4
.d8ef	84 70		sty $70		   STY FAC1M5        ; clear FAC1 rounding byte
.d8f1	69 08		adc #$08	   ADC #8            ; add x to exponent offset
.d8f3	c9 20		cmp #$20	   CMP #$20          ; compare with $20, max offset, all bits would be = 0
.d8f5	d0 e4		bne $d8db	   BNE PLUS_35       ; loop if not max
.d8f7					  Clear_FAC1_Exp_And_Sign
.d8f7	a9 00		lda #$00	   LDA #0
.d8f9					PLUS_40
.d8f9	85 61		sta $61		   STA FAC1EX        ; set FAC1 exponent
.d8fb					PLUS_45
.d8fb	85 66		sta $66		   STA FAC1SI        ; save FAC1 sign (b7)
.d8fd	60		rts		   RTS
.d8fe					PLUS_50
.d8fe	65 56		adc $56		   ADC FAC2M5
.d900	85 70		sta $70		   STA FAC1M5
.d902	a5 65		lda $65		   LDA FAC1M4
.d904	65 6d		adc $6d		   ADC FAC2M4
.d906	85 65		sta $65		   STA FAC1M4
.d908	a5 64		lda $64		   LDA FAC1M3
.d90a	65 6c		adc $6c		   ADC FAC2M3
.d90c	85 64		sta $64		   STA FAC1M3
.d90e	a5 63		lda $63		   LDA FAC1M2
.d910	65 6b		adc $6b		   ADC FAC2M2
.d912	85 63		sta $63		   STA FAC1M2
.d914	a5 62		lda $62		   LDA FAC1M1
.d916	65 6a		adc $6a		   ADC FAC2M1
.d918	85 62		sta $62		   STA FAC1M1
.d91a	4c 36 d9	jmp $d936	   JMP Test_And_Normalize_FAC1
.d91d					PLUS_55
.d91d	69 01		adc #$01	   ADC #1
.d91f	06 70		asl $70		   ASL FAC1M5
.d921	26 65		rol $65		   ROL FAC1M4
.d923	26 64		rol $64		   ROL FAC1M3
.d925	26 63		rol $63		   ROL FAC1M2
.d927	26 62		rol $62		   ROL FAC1M1
.d929					PLUS_60
.d929	10 f2		bpl $d91d	   BPL PLUS_55      ; loop if not normalised
.d92b	38		sec		   SEC
.d92c	e5 61		sbc $61		   SBC FAC1EX        ; subtract FAC1 exponent
.d92e	b0 c7		bcs $d8f7	   BCS Clear_FAC1_Exp_And_Sign ; branch if underflow (set result = $0)
.d930	49 ff		eor #$ff	   EOR #$FF          ; complement exponent
.d932	69 01		adc #$01	   ADC #$01          ; +1 (twos complement)
.d934	85 61		sta $61		   STA FAC1EX        ; save FAC1 exponent
.d936					  Test_And_Normalize_FAC1
.d936	90 0e		bcc $d946	   BCC TANF_Ret      ; exit if no overflow
.d938					TANF_10
.d938	e6 61		inc $61		   INC FAC1EX        ; increment FAC1 exponent
.d93a	f0 42		beq $d97e	   BEQ Overflow_Error
.d93c	66 62		ror $62		   ROR FAC1M1        ; shift FAC1 mantissa 1
.d93e	66 63		ror $63		   ROR FAC1M2        ; shift FAC1 mantissa 2
.d940	66 64		ror $64		   ROR FAC1M3        ; shift FAC1 mantissa 3
.d942	66 65		ror $65		   ROR FAC1M4        ; shift FAC1 mantissa 4
.d944	66 70		ror $70		   ROR FAC1M5        ; shift FAC1 rounding byte
.d946					TANF_Ret
.d946	60		rts		   RTS
.d947					  Negate_FAC1
.d947	a5 66		lda $66		   LDA FAC1SI        ; get FAC1 sign (b7)
.d949	49 ff		eor #$ff	   EOR #$FF          ; complement it
.d94b	85 66		sta $66		   STA FAC1SI        ; save FAC1 sign (b7)
.d94d					  Negate_FAC1_Mantissa
.d94d	a5 62		lda $62		   LDA FAC1M1
.d94f	49 ff		eor #$ff	   EOR #$FF
.d951	85 62		sta $62		   STA FAC1M1
.d953	a5 63		lda $63		   LDA FAC1M2
.d955	49 ff		eor #$ff	   EOR #$FF
.d957	85 63		sta $63		   STA FAC1M2
.d959	a5 64		lda $64		   LDA FAC1M3
.d95b	49 ff		eor #$ff	   EOR #$FF
.d95d	85 64		sta $64		   STA FAC1M3
.d95f	a5 65		lda $65		   LDA FAC1M4
.d961	49 ff		eor #$ff	   EOR #$FF
.d963	85 65		sta $65		   STA FAC1M4
.d965	a5 70		lda $70		   LDA FAC1M5
.d967	49 ff		eor #$ff	   EOR #$FF
.d969	85 70		sta $70		   STA FAC1M5
.d96b	e6 70		inc $70		   INC FAC1M5
.d96d	d0 0e		bne $d97d	   BNE IFM_Ret
.d96f					  Inc_FAC1_Mantissa
.d96f	e6 65		inc $65		   INC FAC1M4
.d971	d0 0a		bne $d97d	   BNE IFM_Ret
.d973	e6 64		inc $64		   INC FAC1M3
.d975	d0 06		bne $d97d	   BNE IFM_Ret
.d977	e6 63		inc $63		   INC FAC1M2
.d979	d0 02		bne $d97d	   BNE IFM_Ret
.d97b	e6 62		inc $62		   INC FAC1M1
.d97d					IFM_Ret
.d97d	60		rts		   RTS
.d97e					  Overflow_Error
.d97e	a2 0f		ldx #$0f	   LDX #$0F          ; error $0F, overflow error
.d980	4c 37 c4	jmp $c437	   JMP Basic_Error
.d983					  Shift_FAC3
.d983	a2 25		ldx #$25	   LDX #FAC3         ; apply shift routines on FAC3
.d985					  Shift_FACX
.d985	b4 04		ldy $04,x	   LDY 4,X
.d987	84 70		sty $70		   STY FAC1M5      ; mantissa 4 -> rounding byte
.d989	b4 03		ldy $03,x	   LDY 3,X
.d98b	94 04		sty $04,x	   STY 4,X           ; mantissa 3 -> 4
.d98d	b4 02		ldy $02,x	   LDY 2,X
.d98f	94 03		sty $03,x	   STY 3,X           ; mantissa 2 -> 3
.d991	b4 01		ldy $01,x	   LDY 1,X
.d993	94 02		sty $02,x	   STY 2,X           ; mantissa 1 -> 2
.d995	a4 68		ldy $68		   LDY FAC1OV
.d997	94 01		sty $01,x	   STY 1,X           ; overflow -> mantissa 1
.d999					  Shift_FACX_A
.d999	69 08		adc #$08	   ADC #8            ; add 8 to shift count
.d99b	30 e8		bmi $d985	   BMI Shift_FACX    ; if still negative shift byte wise
.d99d	f0 e6		beq $d985	   BEQ Shift_FACX    ; 8 shifts to do
.d99f	e9 08		sbc #$08	   SBC #8            ; reverse the addition
.d9a1	a8		tay		   TAY               ; save shift count to Y
.d9a2	a5 70		lda $70		   LDA FAC1M5      ; get FAC1 rounding byte
.d9a4	b0 14		bcs $d9ba	   BCS ShFA_30
.d9a6					ShFA_10
.d9a6	16 01		asl $01,x	   ASL 1,X           ; shift sign to carry, bit0 set to 0
.d9a8	90 02		bcc $d9ac	   BCC ShFA_20       ; branch if positive
.d9aa	f6 01		inc $01,x	   INC 1,X           ; bit0 set to 1
.d9ac					ShFA_20
.d9ac	76 01		ror $01,x	   ROR 1,X           ; shift FACX mantissa 1 with sign extension
.d9ae	76 01		ror $01,x	   ROR 1,X           ; shift FACX mantissa 1 with sign extension
.d9b0					  Shift_FACX_Right_Y
.d9b0	76 02		ror $02,x	   ROR 2,X           ; shift FACX mantissa 2
.d9b2	76 03		ror $03,x	   ROR 3,X           ; shift FACX mantissa 3
.d9b4	76 04		ror $04,x	   ROR 4,X           ; shift FACX mantissa 4
.d9b6	6a		ror a		   ROR A             ; shift FACX rounding byte
.d9b7	c8		iny		   INY               ; increment exponent diff
.d9b8	d0 ec		bne $d9a6	   BNE ShFA_10       ; branch if range adjust not complete
.d9ba					ShFA_30
.d9ba	18		clc		   CLC               ; just clear it
.d9bb	60		rts		   RTS
>d9bc	81 00 00 00 00			REAL_1 .byte $81,$00,$00,$00,$00 ;.real 1
.d9c1					VLOG_A
>d9c1	03				   .byte   $03            ; series counter
>d9c2	7f 5e 56 cb 79			   .byte $7F,$5E,$56,$CB,$79 ;.real   0.4342559419
>d9c7	80 13 9b 0b 64			   .byte $80,$13,$9B,$0B,$64 ;.real   0.5765845413
>d9cc	80 76 38 93 16			   .byte $80,$76,$38,$93,$16 ;.real   0.9618007592
>d9d1	82 38 aa 3b 20			   .byte $82,$38,$AA,$3B,$20 ;.real   2.8853900731
>d9d6	80 35 04 f3 34			HALF_SQRT_2 .byte $80,$35,$04,$F3,$34 ;.real   0.7071067812  ; 0.5 * sqrt(2.0)
>d9db	81 35 04 f3 34			SQRT_2      .byte $81,$35,$04,$F3,$34 ;.real   1.4142135624  ; sqrt(2.0)
>d9e0	80 80 00 00 00			MINUS_0_5   .byte $80,$80,$00,$00,$00 ;.real  -0.5
>d9e5	80 31 72 17 f8			LN_2        .byte $80,$31,$72,$17,$F8 ;.real   0.6931471807  ; ln(2.0)
.d9ea					  Basic_LOG
.d9ea	20 2b dc	jsr $dc2b	   JSR Get_FAC1_Sign
.d9ed	f0 02		beq $d9f1	   BEQ LOG_10        ; if zero do illegal quantity
.d9ef	10 03		bpl $d9f4	   BPL LOG_20        ; skip error if positive
.d9f1					LOG_10
.d9f1	4c 48 d2	jmp $d248	   JMP Illegal_Quantity      ; do illegal quantity error then warm start
.d9f4					LOG_20
.d9f4	a5 61		lda $61		   LDA FAC1EX        ; get FAC1 exponent
.d9f6	e9 7f		sbc #$7f	   SBC #$7F          ; normalise it
.d9f8	48		pha		   PHA               ; save it
.d9f9	a9 80		lda #$80	   LDA #$80          ; set exponent to zero
.d9fb	85 61		sta $61		   STA FAC1EX        ; save FAC1 exponent
.d9fd	a9 d6		lda #$d6	   LDA #<HALF_SQRT_2 ;#<addr
.d9ff	a0 d9		ldy #$d9	   LDY #>HALF_SQRT_2 ;#>addr
.da01	20 67 d8	jsr $d867	   JSR Add_Var_AY_To_FAC1
.da04	a9 db		lda #$db	   LDA #<SQRT_2 ;#<addr
.da06	a0 d9		ldy #$d9	   LDY #>SQRT_2 ;#>addr
.da08	20 0f db	jsr $db0f	   JSR AY_Divided_By_FAC1
.da0b	a9 bc		lda #$bc	   LDA #<REAL_1 ;#<addr
.da0d	a0 d9		ldy #$d9	   LDY #>REAL_1 ;#>addr
.da0f	20 50 d8	jsr $d850	   JSR AY_Minus_FAC1
.da12	a9 c1		lda #$c1	   LDA #<VLOG_A ;#<addr
.da14	a0 d9		ldy #$d9	   LDY #>VLOG_A ;#>addr
.da16	20 40 e0	jsr $e040	   JSR Square_And_Series_Eval
.da19	a9 e0		lda #$e0	   LDA #<MINUS_0_5 ;#<addr
.da1b	a0 d9		ldy #$d9	   LDY #>MINUS_0_5 ;#>addr
.da1d	20 67 d8	jsr $d867	   JSR Add_Var_AY_To_FAC1
.da20	68		pla		   PLA               ; restore FAC1 exponent
.da21	20 7e dd	jsr $dd7e	   JSR Add_A_To_FAC1
.da24	a9 e5		lda #$e5	   LDA #<LN_2 ;#<addr
.da26	a0 d9		ldy #$d9	   LDY #>LN_2 ;#>addr
.da28					  Multiply_FAC1_With_AY
.da28	20 8c da	jsr $da8c	   JSR Load_FAC2_From_AY
.da2b					  Basic_MULTIPLY
.da2b	d0 03		bne $da30	   BNE MULT_10       ; multiply FAC1 by FAC2 ??
.da2d	4c 8b da	jmp $da8b	   JMP Mult_Sub_Ret  ; exit if zero
.da30					MULT_10
.da30	20 b7 da	jsr $dab7	   JSR Check_FACs
.da33	a9 00		lda #$00	   LDA #0
.da35	85 26		sta $26		   STA FAC3+1
.da37	85 27		sta $27		   STA FAC3+2
.da39	85 28		sta $28		   STA FAC3+3
.da3b	85 29		sta $29		   STA FAC3+4
.da3d	a5 70		lda $70		   LDA FAC1M5
.da3f	20 59 da	jsr $da59	   JSR Mult_SubA
.da42	a5 65		lda $65		   LDA FAC1M4
.da44	20 59 da	jsr $da59	   JSR Mult_SubA
.da47	a5 64		lda $64		   LDA FAC1M3
.da49	20 59 da	jsr $da59	   JSR Mult_SubA
.da4c	a5 63		lda $63		   LDA FAC1M2
.da4e	20 59 da	jsr $da59	   JSR Mult_SubA
.da51	a5 62		lda $62		   LDA FAC1M1
.da53	20 5e da	jsr $da5e	   JSR Mult_SubB
.da56	4c 8f db	jmp $db8f	   JMP FAC3_To_FAC1
.da59					  Mult_SubA
.da59	d0 03		bne $da5e	   BNE Mult_SubB
.da5b	4c 83 d9	jmp $d983	   JMP Shift_FAC3
.da5e					  Mult_SubB
.da5e	4a		lsr a		   LSR A             ; shift byte
.da5f	09 80		ora #$80	   ORA #$80          ; set top bit (mark for 8 times)
.da61					MULT_20
.da61	a8		tay		   TAY               ; copy result
.da62	90 19		bcc $da7d	   BCC MULT_30       ; skip next if bit was zero
.da64	18		clc		   CLC
.da65	a5 29		lda $29		   LDA FAC3+4
.da67	65 6d		adc $6d		   ADC FAC2M4
.da69	85 29		sta $29		   STA FAC3+4
.da6b	a5 28		lda $28		   LDA FAC3+3
.da6d	65 6c		adc $6c		   ADC FAC2M3
.da6f	85 28		sta $28		   STA FAC3+3
.da71	a5 27		lda $27		   LDA FAC3+2
.da73	65 6b		adc $6b		   ADC FAC2M2
.da75	85 27		sta $27		   STA FAC3+2
.da77	a5 26		lda $26		   LDA FAC3+1
.da79	65 6a		adc $6a		   ADC FAC2M1
.da7b	85 26		sta $26		   STA FAC3+1
.da7d					MULT_30
.da7d	66 26		ror $26		   ROR FAC3+1
.da7f	66 27		ror $27		   ROR FAC3+2
.da81	66 28		ror $28		   ROR FAC3+3
.da83	66 29		ror $29		   ROR FAC3+4
.da85	66 70		ror $70		   ROR FAC1M5
.da87	98		tya		   TYA               ; get byte back
.da88	4a		lsr a		   LSR A             ; shift byte
.da89	d0 d6		bne $da61	   BNE MULT_20       ; loop if all bits not done
.da8b					Mult_Sub_Ret
.da8b	60		rts		   RTS
.da8c					  Load_FAC2_From_AY
.da8c	85 22		sta $22		   STA INDEXA
.da8e	84 23		sty $23		   STY INDEXA+1
.da90	a0 04		ldy #$04	   LDY #4            ; 5 bytes to get (0-4)
.da92	b1 22		lda ($22),y	   LDA (INDEXA),Y    ; get mantissa 4
.da94	85 6d		sta $6d		   STA FAC2M4        ; save FAC2 mantissa 4
.da96	88		dey		   DEY               ; decrement index
.da97	b1 22		lda ($22),y	   LDA (INDEXA),Y    ; get mantissa 3
.da99	85 6c		sta $6c		   STA FAC2M3        ; save FAC2 mantissa 3
.da9b	88		dey		   DEY               ; decrement index
.da9c	b1 22		lda ($22),y	   LDA (INDEXA),Y    ; get mantissa 2
.da9e	85 6b		sta $6b		   STA FAC2M2        ; save FAC2 mantissa 2
.daa0	88		dey		   DEY               ; decrement index
.daa1	b1 22		lda ($22),y	   LDA (INDEXA),Y    ; get mantissa 1 + sign
.daa3	85 6e		sta $6e		   STA FAC2SI        ; save FAC2 sign (b7)
.daa5	45 66		eor $66		   EOR FAC1SI        ; EOR with FAC1 sign (b7)
.daa7	85 6f		sta $6f		   STA STRPTR        ; save sign compare (FAC1 EOR FAC2)
.daa9	a5 6e		lda $6e		   LDA FAC2SI        ; recover FAC2 sign (b7)
.daab	09 80		ora #$80	   ORA #$80          ; set 1xxx xxx (set normal bit)
.daad	85 6a		sta $6a		   STA FAC2M1        ; save FAC2 mantissa 1
.daaf	88		dey		   DEY               ; decrement index
.dab0	b1 22		lda ($22),y	   LDA (INDEXA),Y    ; get exponent byte
.dab2	85 69		sta $69		   STA FAC2EX        ; save FAC2 exponent
.dab4	a5 61		lda $61		   LDA FAC1EX        ; get FAC1 exponent
.dab6	60		rts		   RTS
.dab7					  Check_FACs
.dab7	a5 69		lda $69		   LDA FAC2EX        ; get FAC2 exponent
.dab9					  Check_FACs_A
.dab9	f0 1f		beq $dada	   BEQ ChFA_30       ; branch if FAC2 = $00 (handle underflow)
.dabb	18		clc		   CLC
.dabc	65 61		adc $61		   ADC FAC1EX        ; add FAC1 exponent
.dabe	90 04		bcc $dac4	   BCC ChFA_10       ; branch if sum of exponents < $0100
.dac0	30 1d		bmi $dadf	   BMI ChFA_40       ; do overflow error
.dac2	18		clc		   CLC
>dac3	2c				   .byte   $2C       ; skip next statement
.dac4					ChFA_10
.dac4	10 14		bpl $dada	   BPL ChFA_30       ; if positive go handle underflow
.dac6	69 80		adc #$80	   ADC #$80          ; adjust exponent
.dac8	85 61		sta $61		   STA FAC1EX        ; save FAC1 exponent
.daca	d0 03		bne $dacf	   BNE ChFA_20       ; branch if not zero
.dacc	4c fb d8	jmp $d8fb	   JMP PLUS_45       ; save FAC1 sign and return
.dacf					ChFA_20
.dacf	a5 6f		lda $6f		   LDA STRPTR        ; get sign compare (FAC1 EOR FAC2)
.dad1	85 66		sta $66		   STA FAC1SI        ; save FAC1 sign (b7)
.dad3	60		rts		   RTS
.dad4					  Check_Overflow
.dad4	a5 66		lda $66		   LDA FAC1SI        ; get FAC1 sign (b7)
.dad6	49 ff		eor #$ff	   EOR #$FF          ; complement it
.dad8	30 05		bmi $dadf	   BMI ChFA_40       ; do overflow error
.dada					ChFA_30
.dada	68		pla		   PLA               ; pop return address low byte
.dadb	68		pla		   PLA               ; pop return address high byte
.dadc	4c f7 d8	jmp $d8f7	   JMP Clear_FAC1_Exp_And_Sign
.dadf					ChFA_40
.dadf	4c 7e d9	jmp $d97e	   JMP Overflow_Error
.dae2					  Multiply_FAC1_BY_10
.dae2	20 0c dc	jsr $dc0c	   JSR FAC1_Round_And_Copy_To_FAC2
.dae5	aa		tax		   TAX               ; copy exponent (set the flags)
.dae6	f0 10		beq $daf8	   BEQ Mu10_Ret      ; exit if zero
.dae8	18		clc		   CLC
.dae9	69 02		adc #$02	   ADC #$02          ; add two to exponent (*4)
.daeb	b0 f2		bcs $dadf	   BCS ChFA_40       ; do overflow error if > $FF
.daed					  Multiply_FAC1_By_4
.daed	a2 00		ldx #$00	   LDX #0
.daef	86 6f		stx $6f		   STX STRPTR        ; clear sign compare (FAC1 EOR FAC2)
.daf1	20 77 d8	jsr $d877	   JSR Add_FAC2_To_FAC1
.daf4	e6 61		inc $61		   INC FAC1EX        ; increment FAC1 exponent (*2)
.daf6	f0 e7		beq $dadf	   BEQ ChFA_40       ; if exponent now zero go do overflow error
.daf8					Mu10_Ret
.daf8	60		rts		   RTS
>daf9	84 20 00 00 00			Float_10 .byte $84,$20,$00,$00,$00 ;.real 10
.dafe					  Divide_FAC1_By_10
.dafe	20 0c dc	jsr $dc0c	   JSR FAC1_Round_And_Copy_To_FAC2
.db01	a9 f9		lda #$f9	   LDA #<Float_10 ;#<addr
.db03	a0 da		ldy #$da	   LDY #>Float_10 ;#>addr
.db05	a2 00		ldx #$00	   LDX #0            ; clear sign
.db07					  Divide_FAC2_By_AY
.db07	86 6f		stx $6f		   STX STRPTR        ; save sign compare (FAC1 EOR FAC2)
.db09	20 a2 db	jsr $dba2	   JSR Load_FAC1_AY
.db0c	4c 12 db	jmp $db12	   JMP Basic_DIVIDE  ; do FAC2/FAC1
.db0f					  AY_Divided_By_FAC1
.db0f	20 8c da	jsr $da8c	   JSR Load_FAC2_From_AY
.db12					  Basic_DIVIDE
.db12	f0 76		beq $db8a	   BEQ Divide_By_Zero; if zero go do /0 error
.db14	20 1b dc	jsr $dc1b	   JSR Round_FAC1_Checked
.db17	a9 00		lda #$00	   LDA #0
.db19	38		sec		   SEC
.db1a	e5 61		sbc $61		   SBC FAC1EX        ; subtract FAC1 exponent (2s complement)
.db1c	85 61		sta $61		   STA FAC1EX        ; save FAC1 exponent
.db1e	20 b7 da	jsr $dab7	   JSR Check_FACs
.db21	e6 61		inc $61		   INC FAC1EX        ; increment FAC1 exponent
.db23	f0 ba		beq $dadf	   BEQ ChFA_40       ; if zero do overflow error
.db25	a2 fc		ldx #$fc	   LDX #$FC          ; set index to FAC temp
.db27	a9 01		lda #$01	   LDA #$01          ; set byte
.db29					DIVI_10
.db29	a4 6a		ldy $6a		   LDY FAC2M1        ; compare mantissa
.db2b	c4 62		cpy $62		   CPY FAC1M1
.db2d	d0 10		bne $db3f	   BNE DIVI_20
.db2f	a4 6b		ldy $6b		   LDY FAC2M2
.db31	c4 63		cpy $63		   CPY FAC1M2
.db33	d0 0a		bne $db3f	   BNE DIVI_20
.db35	a4 6c		ldy $6c		   LDY FAC2M3
.db37	c4 64		cpy $64		   CPY FAC1M3
.db39	d0 04		bne $db3f	   BNE DIVI_20
.db3b	a4 6d		ldy $6d		   LDY FAC2M4
.db3d	c4 65		cpy $65		   CPY FAC1M4
.db3f					DIVI_20
.db3f	08		php		   PHP               ; save the FAC2-FAC1 compare status
.db40	2a		rol a		   ROL A             ; shift byte
.db41	90 09		bcc $db4c	   BCC DIVI_30       ; skip next if no carry
.db43	e8		inx		   INX               ; increment index to FAC temp
.db44	95 29		sta $29,x	   STA FAC3+4,X
.db46	f0 32		beq $db7a	   BEQ DIVI_60
.db48	10 34		bpl $db7e	   BPL DIVI_70
.db4a	a9 01		lda #$01	   LDA #1
.db4c					DIVI_30
.db4c	28		plp		   PLP               ; restore FAC2-FAC1 compare status
.db4d	b0 0e		bcs $db5d	   BCS DIVI_50       ; if FAC2 >= FAC1 then do subtract
.db4f					DIVI_40
.db4f	06 6d		asl $6d		   ASL FAC2M4        ; shift FAC2 mantissa 4
.db51	26 6c		rol $6c		   ROL FAC2M3        ; shift FAC2 mantissa 3
.db53	26 6b		rol $6b		   ROL FAC2M2        ; shift FAC2 mantissa 2
.db55	26 6a		rol $6a		   ROL FAC2M1        ; shift FAC2 mantissa 1
.db57	b0 e6		bcs $db3f	   BCS DIVI_20       ; loop with no compare
.db59	30 ce		bmi $db29	   BMI DIVI_10       ; loop with compare
.db5b	10 e2		bpl $db3f	   BPL DIVI_20       ; loop always with no compare
.db5d					DIVI_50
.db5d	a8		tay		   TAY               ; save FAC2-FAC1 compare status
.db5e	a5 6d		lda $6d		   LDA FAC2M4        ; FAC2 = FAC2 - FAC1
.db60	e5 65		sbc $65		   SBC FAC1M4
.db62	85 6d		sta $6d		   STA FAC2M4
.db64	a5 6c		lda $6c		   LDA FAC2M3
.db66	e5 64		sbc $64		   SBC FAC1M3
.db68	85 6c		sta $6c		   STA FAC2M3
.db6a	a5 6b		lda $6b		   LDA FAC2M2
.db6c	e5 63		sbc $63		   SBC FAC1M2
.db6e	85 6b		sta $6b		   STA FAC2M2
.db70	a5 6a		lda $6a		   LDA FAC2M1
.db72	e5 62		sbc $62		   SBC FAC1M1
.db74	85 6a		sta $6a		   STA FAC2M1
.db76	98		tya		   TYA               ; restore FAC2-FAC1 compare status
.db77	4c 4f db	jmp $db4f	   JMP DIVI_40       ; go shift FAC2
.db7a					DIVI_60
.db7a	a9 40		lda #$40	   LDA #$40
.db7c	d0 ce		bne $db4c	   BNE DIVI_30
.db7e					DIVI_70
.db7e	0a		asl a		   ASL A
.db7f	0a		asl a		   ASL A
.db80	0a		asl a		   ASL A
.db81	0a		asl a		   ASL A
.db82	0a		asl a		   ASL A
.db83	0a		asl a		   ASL A
.db84	85 70		sta $70		   STA FAC1M5        ; save FAC1 rounding byte
.db86	28		plp		   PLP               ; dump FAC2-FAC1 compare status
.db87	4c 8f db	jmp $db8f	   JMP FAC3_To_FAC1
.db8a					  Divide_By_Zero
.db8a	a2 14		ldx #$14	   LDX #$14          ; error $14, divide by zero error
.db8c	4c 37 c4	jmp $c437	   JMP Basic_Error
.db8f					  FAC3_To_FAC1
.db8f	a5 26		lda $26		   LDA FAC3+1
.db91	85 62		sta $62		   STA FAC1M1
.db93	a5 27		lda $27		   LDA FAC3+2
.db95	85 63		sta $63		   STA FAC1M2
.db97	a5 28		lda $28		   LDA FAC3+3
.db99	85 64		sta $64		   STA FAC1M3
.db9b	a5 29		lda $29		   LDA FAC3+4
.db9d	85 65		sta $65		   STA FAC1M4
.db9f	4c d7 d8	jmp $d8d7	   JMP Normalise_FAC1
.dba2					  Load_FAC1_AY
.dba2	85 22		sta $22		   STA INDEXA
.dba4	84 23		sty $23		   STY INDEXA+1
.dba6	a0 04		ldy #$04	   LDY #$04          ; 5 bytes to do
.dba8	b1 22		lda ($22),y	   LDA (INDEXA),Y    ; get fifth byte
.dbaa	85 65		sta $65		   STA FAC1M4        ; save FAC1 mantissa 4
.dbac	88		dey		   DEY               ; decrement index
.dbad	b1 22		lda ($22),y	   LDA (INDEXA),Y    ; get fourth byte
.dbaf	85 64		sta $64		   STA FAC1M3        ; save FAC1 mantissa 3
.dbb1	88		dey		   DEY               ; decrement index
.dbb2	b1 22		lda ($22),y	   LDA (INDEXA),Y    ; get third byte
.dbb4	85 63		sta $63		   STA FAC1M2        ; save FAC1 mantissa 2
.dbb6	88		dey		   DEY               ; decrement index
.dbb7	b1 22		lda ($22),y	   LDA (INDEXA),Y    ; get second byte
.dbb9	85 66		sta $66		   STA FAC1SI        ; save FAC1 sign (b7)
.dbbb	09 80		ora #$80	   ORA #$80          ; set 1xxx xxxx (add normal bit)
.dbbd	85 62		sta $62		   STA FAC1M1        ; save FAC1 mantissa 1
.dbbf	88		dey		   DEY               ; decrement index
.dbc0	b1 22		lda ($22),y	   LDA (INDEXA),Y    ; get first byte (exponent)
.dbc2	85 61		sta $61		   STA FAC1EX        ; save FAC1 exponent
.dbc4	84 70		sty $70		   STY FAC1M5        ; clear FAC1 rounding byte
.dbc6	60		rts		   RTS
.dbc7					  FAC1_To_FACTPB
.dbc7	a2 5c		ldx #$5c	   LDX #<FACTPB      ; set pointer low byte
>dbc9	2c				   .byte   $2C       ; skip next statement
.dbca					  FAC1_To_FACTPA
.dbca	a2 57		ldx #$57	   LDX #<FACTPA      ; set pointer low byte
.dbcc	a0 00		ldy #$00	   LDY #>FACTPA      ; set pointer high byte
.dbce	f0 04		beq $dbd4	   BEQ Assign_FAC1_To_Var
.dbd0					  Assign_FAC1_To_FOR_Index
.dbd0	a6 49		ldx $49		   LDX FORPNT
.dbd2	a4 4a		ldy $4a		   LDY FORPNT+1
.dbd4					  Assign_FAC1_To_Var
.dbd4	20 1b dc	jsr $dc1b	   JSR Round_FAC1_Checked
.dbd7	86 22		stx $22		   STX INDEXA
.dbd9	84 23		sty $23		   STY INDEXA+1
.dbdb	a0 04		ldy #$04	   LDY #$04          ; set index
.dbdd	a5 65		lda $65		   LDA FAC1M4        ; get FAC1 mantissa 4
.dbdf	91 22		sta ($22),y	   STA (INDEXA),Y    ; store in destination
.dbe1	88		dey		   DEY               ; decrement index
.dbe2	a5 64		lda $64		   LDA FAC1M3        ; get FAC1 mantissa 3
.dbe4	91 22		sta ($22),y	   STA (INDEXA),Y    ; store in destination
.dbe6	88		dey		   DEY               ; decrement index
.dbe7	a5 63		lda $63		   LDA FAC1M2        ; get FAC1 mantissa 2
.dbe9	91 22		sta ($22),y	   STA (INDEXA),Y    ; store in destination
.dbeb	88		dey		   DEY               ; decrement index
.dbec	a5 66		lda $66		   LDA FAC1SI        ; get FAC1 sign (b7)
.dbee	09 7f		ora #$7f	   ORA #$7F          ; set bits x111 1111
.dbf0	25 62		and $62		   AND FAC1M1        ; AND in FAC1 mantissa 1
.dbf2	91 22		sta ($22),y	   STA (INDEXA),Y    ; store in destination
.dbf4	88		dey		   DEY               ; decrement index
.dbf5	a5 61		lda $61		   LDA FAC1EX        ; get FAC1 exponent
.dbf7	91 22		sta ($22),y	   STA (INDEXA),Y    ; store in destination
.dbf9	84 70		sty $70		   STY FAC1M5        ; clear FAC1 rounding byte
.dbfb	60		rts		   RTS
.dbfc					  FAC2_To_FAC1
.dbfc	a5 6e		lda $6e		   LDA FAC2SI        ; get FAC2 sign (b7)
.dbfe					  Copy_ABS_FAC2_To_FAC1
.dbfe	85 66		sta $66		   STA FAC1SI        ; save FAC1 sign (b7)
.dc00	a2 05		ldx #$05	   LDX #5            ; 5 bytes to copy
.dc02					F2F1_Loop
.dc02	b5 68		lda $68,x	   LDA FAC2EX-1,X
.dc04	95 60		sta $60,x	   STA FAC1EX-1,X
.dc06	ca		dex		   DEX
.dc07	d0 f9		bne $dc02	   BNE F2F1_Loop
.dc09	86 70		stx $70		   STX FAC1M5        ; clear FAC1 rounding byte
.dc0b	60		rts		   RTS
.dc0c					  FAC1_Round_And_Copy_To_FAC2
.dc0c	20 1b dc	jsr $dc1b	   JSR Round_FAC1_Checked
.dc0f					  FAC1_To_FAC2
.dc0f	a2 06		ldx #$06	   LDX #6
.dc11					F1F2_Loop
.dc11	b5 60		lda $60,x	   LDA FAC1EX-1,X
.dc13	95 68		sta $68,x	   STA FAC2EX-1,X
.dc15	ca		dex		   DEX
.dc16	d0 f9		bne $dc11	   BNE F1F2_Loop
.dc18	86 70		stx $70		   STX FAC1M5        ; clear FAC1 rounding byte
.dc1a					F1F2_Ret
.dc1a	60		rts		   RTS
.dc1b					  Round_FAC1_Checked
.dc1b	a5 61		lda $61		   LDA FAC1EX        ; get FAC1 exponent
.dc1d	f0 fb		beq $dc1a	   BEQ F1F2_Ret      ; exit if zero
.dc1f	06 70		asl $70		   ASL FAC1M5        ; shift FAC1 rounding byte
.dc21	90 f7		bcc $dc1a	   BCC F1F2_Ret      ; exit if no overflow
.dc23					  Round_FAC1
.dc23	20 6f d9	jsr $d96f	   JSR Inc_FAC1_Mantissa
.dc26	d0 f2		bne $dc1a	   BNE F1F2_Ret      ; branch if no overflow
.dc28	4c 38 d9	jmp $d938	   JMP TANF_10       ; normalise FAC1 for C=1 and return
.dc2b					  Get_FAC1_Sign
.dc2b	a5 61		lda $61		   LDA FAC1EX        ; get FAC1 exponent
.dc2d	f0 09		beq $dc38	   BEQ GFS_Ret       ; exit if zero
.dc2f					GFS_10
.dc2f	a5 66		lda $66		   LDA FAC1SI        ; else get FAC1 sign (b7)
.dc31					GFS_20
.dc31	2a		rol a		   ROL A             ; move sign bit to carry
.dc32	a9 ff		lda #$ff	   LDA #$FF          ; set byte for negative result
.dc34	b0 02		bcs $dc38	   BCS GFS_Ret       ; return if sign was set (negative)
.dc36	a9 01		lda #$01	   LDA #1            ; else set byte for positive result
.dc38					GFS_Ret
.dc38	60		rts		   RTS
.dc39					  Basic_SGN
.dc39	20 2b dc	jsr $dc2b	   JSR Get_FAC1_Sign
.dc3c					  A_To_FAC1
.dc3c	85 62		sta $62		   STA FAC1M1        ; save FAC1 mantissa 1
.dc3e	a9 00		lda #$00	   LDA #0
.dc40	85 63		sta $63		   STA FAC1M2        ; clear FAC1 mantissa 2
.dc42	a2 88		ldx #$88	   LDX #$88          ; set exponent
.dc44					  Int_To_Float_Exp_X
.dc44	a5 62		lda $62		   LDA FAC1M1        ; get FAC1 mantissa 1
.dc46	49 ff		eor #$ff	   EOR #$FF          ; complement it
.dc48	2a		rol a		   ROL A             ; sign bit into carry
.dc49					  Convert_Integer_To_Float
.dc49	a9 00		lda #$00	   LDA #0
.dc4b	85 65		sta $65		   STA FAC1M4        ; clear FAC1 mantissa 4
.dc4d	85 64		sta $64		   STA FAC1M3        ; clear FAC1 mantissa 3
.dc4f					CITF_10
.dc4f	86 61		stx $61		   STX FAC1EX        ; set FAC1 exponent
.dc51	85 70		sta $70		   STA FAC1M5        ; clear FAC1 rounding byte
.dc53	85 66		sta $66		   STA FAC1SI        ; clear FAC1 sign (b7)
.dc55	4c d2 d8	jmp $d8d2	   JMP PLUS_30       ; do ABS and normalise FAC1
.dc58					  Basic_ABS
.dc58	46 66		lsr $66		   LSR FAC1SI        ; clear FAC1 sign, put zero in b7
.dc5a	60		rts		   RTS
.dc5b					  Compare_FAC1_AY
.dc5b	85 24		sta $24		   STA INDEXB        ; save pointer low byte
.dc5d					  Compare_FAC1_INDEXB_Y
.dc5d	84 25		sty $25		   STY INDEXB+1      ; save pointer high byte
.dc5f	a0 00		ldy #$00	   LDY #0
.dc61	b1 24		lda ($24),y	   LDA (INDEXB),Y    ; get exponent
.dc63	c8		iny		   INY
.dc64	aa		tax		   TAX               ; copy (AY) exponent to X
.dc65	f0 c4		beq $dc2b	   BEQ Get_FAC1_Sign
.dc67	b1 24		lda ($24),y	   LDA (INDEXB),Y    ; get (AY) mantissa 1, with sign
.dc69	45 66		eor $66		   EOR FAC1SI        ; EOR FAC1 sign (b7)
.dc6b	30 c2		bmi $dc2f	   BMI GFS_10        ; if signs <> do return A = $FF, Cb = 1/negative
.dc6d	e4 61		cpx $61		   CPX FAC1EX        ; compare (AY) exponent with FAC1 exponent
.dc6f	d0 21		bne $dc92	   BNE CPFA_10       ; branch if different
.dc71	b1 24		lda ($24),y	   LDA (INDEXB),Y    ; get (AY) mantissa 1, with sign
.dc73	09 80		ora #$80	   ORA #$80          ; normalise top bit
.dc75	c5 62		cmp $62		   CMP FAC1M1        ; compare with FAC1 mantissa 1
.dc77	d0 19		bne $dc92	   BNE CPFA_10       ; branch if different
.dc79	c8		iny		   INY
.dc7a	b1 24		lda ($24),y	   LDA (INDEXB),Y    ; get mantissa 2
.dc7c	c5 63		cmp $63		   CMP FAC1M2        ; compare with FAC1 mantissa 2
.dc7e	d0 12		bne $dc92	   BNE CPFA_10       ; branch if different
.dc80	c8		iny		   INY
.dc81	b1 24		lda ($24),y	   LDA (INDEXB),Y    ; get mantissa 3
.dc83	c5 64		cmp $64		   CMP FAC1M3        ; compare with FAC1 mantissa 3
.dc85	d0 0b		bne $dc92	   BNE CPFA_10       ; branch if different
.dc87	c8		iny		   INY
.dc88	a9 7f		lda #$7f	   LDA #$7F          ; set for 1/2 value rounding byte
.dc8a	c5 70		cmp $70		   CMP FAC1M5        ; compare with FAC1 rounding byte (set carry)
.dc8c	b1 24		lda ($24),y	   LDA (INDEXB),Y    ; get mantissa 4
.dc8e	e5 65		sbc $65		   SBC FAC1M4        ; subtract FAC1 mantissa 4
.dc90	f0 28		beq $dcba	   BEQ FATI_20       ; exit if mantissa 4 equal
.dc92					CPFA_10
.dc92	a5 66		lda $66		   LDA FAC1SI        ; get FAC1 sign (b7)
.dc94	90 02		bcc $dc98	   BCC CPFA_20       ; branch if FAC1 > (AY)
.dc96	49 ff		eor #$ff	   EOR #$FF          ; else toggle FAC1 sign
.dc98					CPFA_20
.dc98	4c 31 dc	jmp $dc31	   JMP GFS_20        ; return A = $FF, Cb = 1/negative A = $01, Cb = 0/positive
.dc9b					  FAC1_To_Integer
.dc9b	a5 61		lda $61		   LDA FAC1EX
.dc9d	f0 4a		beq $dce9	   BEQ Clear_FAC1
.dc9f	38		sec		   SEC
.dca0	e9 a0		sbc #$a0	   SBC #$A0          ; subtract maximum integer range exponent
.dca2	24 66		bit $66		   BIT FAC1SI        ; test FAC1 sign (b7)
.dca4	10 09		bpl $dcaf	   BPL FATI_10       ; branch if FAC1 positive
.dca6	aa		tax		   TAX               ; copy subtracted exponent
.dca7	a9 ff		lda #$ff	   LDA #$FF          ; overflow for negative number
.dca9	85 68		sta $68		   STA FAC1OV        ; set FAC1 overflow byte
.dcab	20 4d d9	jsr $d94d	   JSR Negate_FAC1_Mantissa
.dcae	8a		txa		   TXA               ; restore subtracted exponent
.dcaf					FATI_10
.dcaf	a2 61		ldx #$61	   LDX #FAC1EX
.dcb1	c9 f9		cmp #$f9	   CMP #$F9          ; compare exponent result
.dcb3	10 06		bpl $dcbb	   BPL FATI_30       ; less than 8 shifts
.dcb5	20 99 d9	jsr $d999	   JSR Shift_FACX_A
.dcb8	84 68		sty $68		   STY FAC1OV        ; clear FAC1 overflow byte
.dcba					FATI_20
.dcba	60		rts		   RTS
.dcbb					FATI_30
.dcbb	a8		tay		   TAY               ; copy shift count
.dcbc	a5 66		lda $66		   LDA FAC1SI        ; get FAC1 sign (b7)
.dcbe	29 80		and #$80	   AND #$80          ; mask sign bit only (x000 0000)
.dcc0	46 62		lsr $62		   LSR FAC1M1        ; shift FAC1 mantissa 1
.dcc2	05 62		ora $62		   ORA FAC1M1        ; OR sign in b7 FAC1 mantissa 1
.dcc4	85 62		sta $62		   STA FAC1M1        ; save FAC1 mantissa 1
.dcc6	20 b0 d9	jsr $d9b0	   JSR Shift_FACX_Right_Y
.dcc9	84 68		sty $68		   STY FAC1OV        ; clear FAC1 overflow byte
.dccb	60		rts		   RTS
.dccc					  Basic_INT
.dccc	a5 61		lda $61		   LDA FAC1EX        ; get FAC1 exponent
.dcce	c9 a0		cmp #$a0	   CMP #$A0          ; compare with max int
.dcd0	b0 20		bcs $dcf2	   BCS ClF1_Ret      ; exit if >= (allready int, too big for fractional part!)
.dcd2	20 9b dc	jsr $dc9b	   JSR FAC1_To_Integer
.dcd5	84 70		sty $70		   STY FAC1M5        ; save FAC1 rounding byte
.dcd7	a5 66		lda $66		   LDA FAC1SI        ; get FAC1 sign (b7)
.dcd9	84 66		sty $66		   STY FAC1SI        ; save FAC1 sign (b7)
.dcdb	49 80		eor #$80	   EOR #$80          ; toggle FAC1 sign
.dcdd	2a		rol a		   ROL A             ; shift into carry
.dcde	a9 a0		lda #$a0	   LDA #$A0          ; set new exponent
.dce0	85 61		sta $61		   STA FAC1EX        ; save FAC1 exponent
.dce2	a5 65		lda $65		   LDA FAC1M4        ; get FAC1 mantissa 4
.dce4	85 07		sta $07		   STA CHARAC        ; save FAC1 mantissa 4 for power function
.dce6	4c d2 d8	jmp $d8d2	   JMP PLUS_30      ; do ABS and normalise FAC1
.dce9					  Clear_FAC1
.dce9	85 62		sta $62		   STA FAC1M1
.dceb	85 63		sta $63		   STA FAC1M2
.dced	85 64		sta $64		   STA FAC1M3
.dcef	85 65		sta $65		   STA FAC1M4
.dcf1	a8		tay		   TAY
.dcf2					ClF1_Ret
.dcf2	60		rts		   RTS
.dcf3					  Load_FAC1_From_String
.dcf3	a0 00		ldy #$00	   LDY #0
.dcf5	a2 0a		ldx #$0a	   LDX #10
.dcf7					LFFS_05
.dcf7	94 5d		sty $5d,x	   STY TMPVA1,X      ; clear 10 bytes TMPVA1 & FAC1 ($5D - $66)
.dcf9	ca		dex		   DEX
.dcfa	10 fb		bpl $dcf7	   BPL LFFS_05
.dcfc	90 0f		bcc $dd0d	   BCC LFFS_20       ; branch if first character is numeric
.dcfe	c9 2d		cmp #$2d	   CMP #'-'          ; else compare with "-"
.dd00	d0 04		bne $dd06	   BNE LFFS_10       ; branch if not "-"
.dd02	86 67		stx $67		   STX SGNFLG        ; set flag for negative n (X = $FF)
.dd04	f0 04		beq $dd0a	   BEQ LFFS_15       ; branch always
.dd06					LFFS_10
.dd06	c9 2b		cmp #$2b	   CMP #'+'          ; else compare with "+"
.dd08	d0 05		bne $dd0f	   BNE LFFS_25       ; branch if not "+"
.dd0a					LFFS_15
.dd0a	20 73 00	jsr $0073	   JSR CHRGET        ; next char
.dd0d					LFFS_20
.dd0d	90 5b		bcc $dd6a	   BCC LFFS_75       ; branch if numeric character
.dd0f					LFFS_25
.dd0f	c9 2e		cmp #$2e	   CMP #'.'
.dd11	f0 2e		beq $dd41	   BEQ LFFS_40
.dd13	c9 45		cmp #$45	   CMP #'E'
.dd15	d0 30		bne $dd47	   BNE LFFS_45
.dd17	20 73 00	jsr $0073	   JSR CHRGET        ; read exponent
.dd1a	90 17		bcc $dd33	   BCC LFFS_37       ; branch if numeric character
.dd1c	c9 ab		cmp #$ab	   CMP #TK_MINUS
.dd1e	f0 0e		beq $dd2e	   BEQ LFFS_30
.dd20	c9 2d		cmp #$2d	   CMP #'-'
.dd22	f0 0a		beq $dd2e	   BEQ LFFS_30
.dd24	c9 aa		cmp #$aa	   CMP #TK_PLUS
.dd26	f0 08		beq $dd30	   BEQ LFFS_35
.dd28	c9 2b		cmp #$2b	   CMP #'+'
.dd2a	f0 04		beq $dd30	   BEQ LFFS_35
.dd2c	d0 07		bne $dd35	   BNE LFFS_38       ; branch always
.dd2e					LFFS_30
.dd2e	66 60		ror $60		   ROR TMPPTC+1      ; set exponent negative flag (ror carry into sign)
.dd30					LFFS_35
.dd30	20 73 00	jsr $0073	   JSR CHRGET        ; next char of exponent
.dd33					LFFS_37
.dd33	90 5c		bcc $dd91	   BCC LFFS_85       ; branch if numeric character
.dd35					LFFS_38
.dd35	24 60		bit $60		   BIT TMPPTC+1      ; test exponent negative flag
.dd37	10 0e		bpl $dd47	   BPL LFFS_45       ; if positive go evaluate exponent
.dd39	a9 00		lda #$00	   LDA #0
.dd3b	38		sec		   SEC
.dd3c	e5 5e		sbc $5e		   SBC TMPVA2        ; negate exponent
.dd3e	4c 49 dd	jmp $dd49	   JMP LFFS_50       ; go evaluate exponent
.dd41					LFFS_40
.dd41	66 5f		ror $5f		   ROR TMPPTC        ; set decimal point flag
.dd43	24 5f		bit $5f		   BIT TMPPTC        ; test decimal point flag
.dd45	50 c3		bvc $dd0a	   BVC LFFS_15       ; branch if only one decimal point so far
.dd47					LFFS_45
.dd47	a5 5e		lda $5e		   LDA TMPVA2        ; get exponent count byte
.dd49					LFFS_50
.dd49	38		sec		   SEC
.dd4a	e5 5d		sbc $5d		   SBC TMPVA1        ; subtract numerator exponent
.dd4c	85 5e		sta $5e		   STA TMPVA2        ; save exponent count byte
.dd4e	f0 12		beq $dd62	   BEQ LFFS_65       ; branch if no adjustment
.dd50	10 09		bpl $dd5b	   BPL LFFS_60       ; else if positive go do FAC1*10^expcnt
.dd52					LFFS_55
.dd52	20 fe da	jsr $dafe	   JSR Divide_FAC1_By_10
.dd55	e6 5e		inc $5e		   INC TMPVA2        ; increment exponent count byte
.dd57	d0 f9		bne $dd52	   BNE LFFS_55       ; loop until all done
.dd59	f0 07		beq $dd62	   BEQ LFFS_65       ; branch always
.dd5b					LFFS_60
.dd5b	20 e2 da	jsr $dae2	   JSR Multiply_FAC1_BY_10
.dd5e	c6 5e		dec $5e		   DEC TMPVA2        ; decrement exponent count byte
.dd60	d0 f9		bne $dd5b	   BNE LFFS_60       ; loop until all done
.dd62					LFFS_65
.dd62	a5 67		lda $67		   LDA SGNFLG        ; get negative flag
.dd64	30 01		bmi $dd67	   BMI LFFS_70       ; if negative do - FAC1 and return
.dd66	60		rts		   RTS
.dd67					LFFS_70
.dd67	4c b4 df	jmp $dfb4	   JMP Basic_GREATER ; do - FAC1
.dd6a					LFFS_75
.dd6a	48		pha		   PHA               ; save character
.dd6b	24 5f		bit $5f		   BIT TMPPTC        ; test decimal point flag
.dd6d	10 02		bpl $dd71	   BPL LFFS_80       ; skip exponent increment if not set
.dd6f	e6 5d		inc $5d		   INC TMPVA1        ; else increment number exponent
.dd71					LFFS_80
.dd71	20 e2 da	jsr $dae2	   JSR Multiply_FAC1_BY_10
.dd74	68		pla		   PLA               ; restore character
.dd75	38		sec		   SEC
.dd76	e9 30		sbc #$30	   SBC #'0'          ; convert to binary
.dd78	20 7e dd	jsr $dd7e	   JSR Add_A_To_FAC1
.dd7b	4c 0a dd	jmp $dd0a	   JMP LFFS_15      ; go do next character
.dd7e					  Add_A_To_FAC1
.dd7e	48		pha		   PHA               ; save digit
.dd7f	20 0c dc	jsr $dc0c	   JSR FAC1_Round_And_Copy_To_FAC2
.dd82	68		pla		   PLA               ; restore digit
.dd83	20 3c dc	jsr $dc3c	   JSR A_To_FAC1
.dd86	a5 6e		lda $6e		   LDA FAC2SI        ; get FAC2 sign (b7)
.dd88	45 66		eor $66		   EOR FAC1SI        ; toggle with FAC1 sign (b7)
.dd8a	85 6f		sta $6f		   STA STRPTR        ; save sign compare (FAC1 EOR FAC2)
.dd8c	a6 61		ldx $61		   LDX FAC1EX        ; get FAC1 exponent
.dd8e	4c 6a d8	jmp $d86a	   JMP Basic_PLUS    ; add FAC2 to FAC1 and return
.dd91					LFFS_85
.dd91	a5 5e		lda $5e		   LDA TMPVA2        ; get exponent count byte
.dd93	c9 0a		cmp #$0a	   CMP #10           ; compare with 10 decimal
.dd95	90 09		bcc $dda0	   BCC LFFS_90       ; branch if less
.dd97	a9 64		lda #$64	   LDA #$64          ; make all negative exponents = -100 decimal (causes underflow)
.dd99	24 60		bit $60		   BIT TMPPTC+1      ; test exponent negative flag
.dd9b	30 11		bmi $ddae	   BMI LFFS_95       ; branch if negative
.dd9d	4c 7e d9	jmp $d97e	   JMP Overflow_Error
.dda0					LFFS_90
.dda0	0a		asl a		   ASL A             ; *2
.dda1	0a		asl a		   ASL A             ; *4
.dda2	18		clc		   CLC
.dda3	65 5e		adc $5e		   ADC TMPVA2        ; *5
.dda5	0a		asl a		   ASL A             ; *10
.dda6	18		clc		   CLC
.dda7	a0 00		ldy #$00	   LDY #0
.dda9	71 7a		adc ($7a),y	   ADC (TXTPTR),Y    ; add character (will be $30 too much!)
.ddab	38		sec		   SEC
.ddac	e9 30		sbc #$30	   SBC #'0'          ; convert character to binary
.ddae					LFFS_95
.ddae	85 5e		sta $5e		   STA TMPVA2        ; save exponent count byte
.ddb0	4c 30 dd	jmp $dd30	   JMP LFFS_35       ; go get next character
>ddb3	9b 3e bc 1f fd			MAXREAL_A .byte $9B,$3E,$BC,$1F,$FD ;.real   99999999.90625
>ddb8	9e 6e 6b 27 fd			MAXREAL_B .byte $9E,$6E,$6B,$27,$FD ;.real  999999999.25
>ddbd	9e 6e 6b 28 00			MAXREAL_C .byte $9E,$6E,$6B,$28,$00 ;.real 1000000000
.ddc2					  Print_IN
.ddc2	a9 71		lda #$71	   LDA #<Msg_IN ;#<addr
.ddc4	a0 c3		ldy #$c3	   LDY #>Msg_IN ;#>addr
.ddc6	20 da dd	jsr $ddda	   JSR To_Print_String
.ddc9	a5 3a		lda $3a		   LDA CURLIN+1      ; get the current line number high byte
.ddcb	a6 39		ldx $39		   LDX CURLIN        ; get the current line number low byte
.ddcd					  Print_Integer_XA
.ddcd	85 62		sta $62		   STA FAC1M1        ; save high byte as FAC1 mantissa1
.ddcf	86 63		stx $63		   STX FAC1M2        ; save low byte as FAC1 mantissa2
.ddd1	a2 90		ldx #$90	   LDX #$90          ; set exponent to 16d bits
.ddd3	38		sec		   SEC               ; set integer is positive flag
.ddd4	20 49 dc	jsr $dc49	   JSR Convert_Integer_To_Float
.ddd7	20 df dd	jsr $dddf	   JSR Format_FAC1_Y
.ddda					To_Print_String
.ddda	4c 1e cb	jmp $cb1e	   JMP Print_String
.dddd					  Format_FAC1
.dddd	a0 01		ldy #$01	   LDY #1
.dddf					  Format_FAC1_Y
.dddf	a9 20		lda #$20	   LDA #' '          ; character = " " (assume positive)
.dde1	24 66		bit $66		   BIT FAC1SI        ; test FAC1 sign (b7)
.dde3	10 02		bpl $dde7	   BPL FoFA_02       ; if positive skip the - sign set
.dde5	a9 2d		lda #$2d	   LDA #'-'          ; else character = "-"
.dde7					FoFA_02
.dde7	99 ff 00	sta $00ff,y	   STA BASSTO,Y      ; save leading character (" " or "-")
.ddea	85 66		sta $66		   STA FAC1SI        ; save FAC1 sign (b7)
.ddec	84 71		sty $71		   STY TMPPTD        ; save the index
.ddee	c8		iny		   INY
.ddef	a9 30		lda #$30	   LDA #'0'          ; set character = "0"
.ddf1	a6 61		ldx $61		   LDX FAC1EX        ; get FAC1 exponent
.ddf3	d0 03		bne $ddf8	   BNE FoFA_04       ; if FAC1 not zero format it
.ddf5	4c 04 df	jmp $df04	   JMP FoFA_52       ; just 0
.ddf8					FoFA_04
.ddf8	a9 00		lda #$00	   LDA #$00          ; clear (number exponent count)
.ddfa	e0 80		cpx #$80	   CPX #$80          ; compare FAC1 exponent with $80 (<1.00000)
.ddfc	f0 02		beq $de00	   BEQ FoFA_06       ; branch if 0.5 <= FAC1 < 1.0
.ddfe	b0 09		bcs $de09	   BCS FoFA_08       ; branch if FAC1=>1
.de00					FoFA_06
.de00	a9 bd		lda #$bd	   LDA #<MAXREAL_C ;#<addr
.de02	a0 dd		ldy #$dd	   LDY #>MAXREAL_C ;#>addr
.de04	20 28 da	jsr $da28	   JSR Multiply_FAC1_With_AY
.de07	a9 f7		lda #$f7	   LDA #$F7          ; set number exponent count
.de09					FoFA_08
.de09	85 5d		sta $5d		   STA TMPVA1        ; save number exponent count
.de0b					FoFA_10
.de0b	a9 b8		lda #$b8	   LDA #<MAXREAL_B ;#<addr
.de0d	a0 dd		ldy #$dd	   LDY #>MAXREAL_B ;#>addr
.de0f	20 5b dc	jsr $dc5b	   JSR Compare_FAC1_AY
.de12	f0 1e		beq $de32	   BEQ FoFA_20       ; exit if FAC1 = (AY)
.de14	10 12		bpl $de28	   BPL FoFA_16       ; go do /10 if FAC1 > (AY)
.de16					FoFA_12
.de16	a9 b3		lda #$b3	   LDA #<MAXREAL_A ;#<addr
.de18	a0 dd		ldy #$dd	   LDY #>MAXREAL_A ;#>addr
.de1a	20 5b dc	jsr $dc5b	   JSR Compare_FAC1_AY
.de1d	f0 02		beq $de21	   BEQ FoFA_14       ; branch if FAC1 = (AY) (allow decimal places)
.de1f	10 0e		bpl $de2f	   BPL FoFA_18       ; branch if FAC1 > (AY) (no decimal places)
.de21					FoFA_14
.de21	20 e2 da	jsr $dae2	   JSR Multiply_FAC1_BY_10
.de24	c6 5d		dec $5d		   DEC TMPVA1        ; decrement number exponent count
.de26	d0 ee		bne $de16	   BNE FoFA_12       ; go test again, branch always
.de28					FoFA_16
.de28	20 fe da	jsr $dafe	   JSR Divide_FAC1_By_10
.de2b	e6 5d		inc $5d		   INC TMPVA1        ; increment number exponent count
.de2d	d0 dc		bne $de0b	   BNE FoFA_10       ; go test again, branch always
.de2f					FoFA_18
.de2f	20 49 d8	jsr $d849	   JSR Add_0_5_To_FAC1
.de32					FoFA_20
.de32	20 9b dc	jsr $dc9b	   JSR FAC1_To_Integer
.de35	a2 01		ldx #$01	   LDX #$01          ; set default digits before dp = 1
.de37	a5 5d		lda $5d		   LDA TMPVA1        ; get number exponent count
.de39	18		clc		   CLC
.de3a	69 0a		adc #$0a	   ADC #$0A          ; up to 9 digits before point
.de3c	30 09		bmi $de47	   BMI FoFA_22       ; if negative then 1 digit before dp
.de3e	c9 0b		cmp #$0b	   CMP #$0B          ; A>=$0B if n>=1E9
.de40	b0 06		bcs $de48	   BCS FoFA_24       ; branch if >= $0B
.de42	69 ff		adc #$ff	   ADC #$FF          ; take 1 from digit count
.de44	aa		tax		   TAX               ; copy to X
.de45	a9 02		lda #$02	   LDA #$02          ; set the exponent adjust
.de47					FoFA_22
.de47	38		sec		   SEC
.de48					FoFA_24
.de48	e9 02		sbc #$02	   SBC #$02          ; -2
.de4a	85 5e		sta $5e		   STA TMPVA2        ; save the exponent adjust
.de4c	86 5d		stx $5d		   STX TMPVA1        ; save digits before dp count
.de4e	8a		txa		   TXA               ; copy digits before dp count to A
.de4f	f0 02		beq $de53	   BEQ FoFA_26       ; if no digits before the dp go do the "."
.de51	10 13		bpl $de66	   BPL FoFA_30       ; if there are digits before the dp go do them
.de53					FoFA_26
.de53	a4 71		ldy $71		   LDY TMPPTD        ; get the output string index
.de55	a9 2e		lda #$2e	   LDA #'.'          ; character "."
.de57	c8		iny		   INY               ; increment the index
.de58	99 ff 00	sta $00ff,y	   STA STACK-1,Y     ; save the "." to the output string
.de5b	8a		txa		   TXA               ; copy digits before dp count to A
.de5c	f0 06		beq $de64	   BEQ FoFA_28       ; if no digits before the dp skip the "0"
.de5e	a9 30		lda #$30	   LDA #'0'          ; character "0"
.de60	c8		iny		   INY
.de61	99 ff 00	sta $00ff,y	   STA STACK-1,Y     ; save the "0" to the output string
.de64					FoFA_28
.de64	84 71		sty $71		   STY TMPPTD        ; save the output string index
.de66					FoFA_30
.de66	a0 00		ldy #$00	   LDY #0            ; clear the powers of 10 index (point to -100,000,000)
.de68					  Format_Jiffyclock
.de68	a2 80		ldx #$80	   LDX #$80          ; clear the digit, set the test sense
.de6a					FoFA_32
.de6a	a5 65		lda $65		   LDA FAC1M4        ; get FAC1 mantissa 4
.de6c	18		clc		   CLC
.de6d	79 19 df	adc $df19,y	   ADC Decimal_Conversion_Table+3,Y
.de70	85 65		sta $65		   STA FAC1M4        ; save FAC1 mantissa4
.de72	a5 64		lda $64		   LDA FAC1M3        ; get FAC1 mantissa 3
.de74	79 18 df	adc $df18,y	   ADC Decimal_Conversion_Table+2,Y
.de77	85 64		sta $64		   STA FAC1M3        ; save FAC1 mantissa3
.de79	a5 63		lda $63		   LDA FAC1M2        ; get FAC1 mantissa 2
.de7b	79 17 df	adc $df17,y	   ADC Decimal_Conversion_Table+1,Y
.de7e	85 63		sta $63		   STA FAC1M2        ; save FAC1 mantissa2
.de80	a5 62		lda $62		   LDA FAC1M1        ; get FAC1 mantissa 1
.de82	79 16 df	adc $df16,y	   ADC Decimal_Conversion_Table+0,Y
.de85	85 62		sta $62		   STA FAC1M1        ; save FAC1 mantissa1
.de87	e8		inx		   INX               ; increment the digit, set the sign on the test sense bit
.de88	b0 04		bcs $de8e	   BCS FoFA_34       ; if the carry is set go test if the result was positive
.de8a	10 de		bpl $de6a	   BPL FoFA_32       ; not negative so try again
.de8c	30 02		bmi $de90	   BMI FoFA_36       ; else done so return the digit
.de8e					FoFA_34
.de8e	30 da		bmi $de6a	   BMI FoFA_32       ; not positive so try again
.de90					FoFA_36
.de90	8a		txa		   TXA               ; copy the digit
.de91	90 04		bcc $de97	   BCC FoFA_38       ; if Cb=0 just use it
.de93	49 ff		eor #$ff	   EOR #$FF          ; else make the 2's complement ..
.de95	69 0a		adc #$0a	   ADC #$0A          ; .. and subtract it from 10
.de97					FoFA_38
.de97	69 2f		adc #$2f	   ADC #'0'-1        ; add "0"-1 to result
.de99	c8		iny		   INY               ; increment ..
.de9a	c8		iny		   INY               ; .. index to..
.de9b	c8		iny		   INY               ; .. next less ..
.de9c	c8		iny		   INY               ; .. power of ten
.de9d	84 47		sty $47		   STY VARPNT        ; save the powers of ten table index
.de9f	a4 71		ldy $71		   LDY TMPPTD        ; get output string index
.dea1	c8		iny		   INY               ; increment output string index
.dea2	aa		tax		   TAX               ; copy character to X
.dea3	29 7f		and #$7f	   AND #$7F          ; mask out top bit
.dea5	99 ff 00	sta $00ff,y	   STA STACK-1,Y     ; save to output string
.dea8	c6 5d		dec $5d		   DEC TMPVA1        ; decrement # of characters before the dp
.deaa	d0 06		bne $deb2	   BNE FoFA_40       ; if still characters to do skip the decimal point
.deac	a9 2e		lda #$2e	   LDA #'.'          ; character "."
.deae	c8		iny		   INY               ; increment output string index
.deaf	99 ff 00	sta $00ff,y	   STA STACK-1,Y     ; save to output string
.deb2					FoFA_40
.deb2	84 71		sty $71		   STY TMPPTD        ; save the output string index
.deb4	a4 47		ldy $47		   LDY VARPNT        ; get the powers of ten table index
.deb6	8a		txa		   TXA               ; get the character back
.deb7	49 ff		eor #$ff	   EOR #$FF          ; toggle the test sense bit
.deb9	29 80		and #$80	   AND #$80          ; clear the digit
.debb	aa		tax		   TAX               ; copy it to the new digit
.debc	c0 24		cpy #$24	   CPY #Jiffy_Conversion_Table-Decimal_Conversion_Table
.debe	f0 04		beq $dec4	   BEQ FoFA_42       ; if at the max exit the digit loop
.dec0	c0 3c		cpy #$3c	   CPY #End_Of_Conversion-Decimal_Conversion_Table
.dec2	d0 a6		bne $de6a	   BNE FoFA_32       ; loop if not at the max
.dec4					FoFA_42
.dec4	a4 71		ldy $71		   LDY TMPPTD        ; restore the output string index
.dec6					FoFA_44
.dec6	b9 ff 00	lda $00ff,y	   LDA STACK-1,Y     ; get character from output string
.dec9	88		dey		   DEY               ; decrement output string index
.deca	c9 30		cmp #$30	   CMP #'0'          ; compare with "0"
.decc	f0 f8		beq $dec6	   BEQ FoFA_44       ; loop until non "0" character found
.dece	c9 2e		cmp #$2e	   CMP #'.'          ; compare with "."
.ded0	f0 01		beq $ded3	   BEQ FoFA_46       ; branch if was dp
.ded2	c8		iny		   INY               ; increment output string index
.ded3					FoFA_46
.ded3	a9 2b		lda #$2b	   LDA #'+'          ; character "+"
.ded5	a6 5e		ldx $5e		   LDX TMPVA2        ; get exponent count
.ded7	f0 2e		beq $df07	   BEQ FoFA_54       ; if zero go set null terminator and exit
.ded9	10 08		bpl $dee3	   BPL FoFA_48       ; branch if exponent count positive
.dedb	a9 00		lda #$00	   LDA #0
.dedd	38		sec		   SEC
.dede	e5 5e		sbc $5e		   SBC TMPVA2        ; subtract exponent count adjust (convert negative to positive)
.dee0	aa		tax		   TAX               ; copy exponent count to X
.dee1	a9 2d		lda #$2d	   LDA #'-'          ; character "-"
.dee3					FoFA_48
.dee3	99 01 01	sta $0101,y	   STA STACK+1,Y     ; save to output string
.dee6	a9 45		lda #$45	   LDA #'E'          ; character "E"
.dee8	99 00 01	sta $0100,y	   STA STACK,Y       ; save exponent sign to output string
.deeb	8a		txa		   TXA               ; get exponent count back
.deec	a2 2f		ldx #$2f	   LDX #$2F          ; one less than "0" character
.deee	38		sec		   SEC
.deef					FoFA_50
.deef	e8		inx		   INX               ; increment 10's character
.def0	e9 0a		sbc #$0a	   SBC #$0A          ; subtract 10 from exponent count
.def2	b0 fb		bcs $deef	   BCS FoFA_50       ; loop while still >= 0
.def4	69 3a		adc #$3a	   ADC #':'          ; add character ":" ($30+$0A, result is 10 less that value)
.def6	99 03 01	sta $0103,y	   STA STACK+3,Y     ; save to output string
.def9	8a		txa		   TXA               ; copy 10's character
.defa	99 02 01	sta $0102,y	   STA STACK+2,Y     ; save to output string
.defd	a9 00		lda #$00	   LDA #$00          ; set null terminator
.deff	99 04 01	sta $0104,y	   STA STACK+4,Y     ; save to output string
.df02	f0 08		beq $df0c	   BEQ FoFA_56       ; go set string pointer (AY) and exit, branch always
.df04					FoFA_52
.df04	99 ff 00	sta $00ff,y	   STA STACK-1,Y     ; save last character to output string
.df07					FoFA_54
.df07	a9 00		lda #$00	   LDA #$00          ; set null terminator
.df09	99 00 01	sta $0100,y	   STA STACK,Y       ; save after last character
.df0c					FoFA_56
.df0c	a9 00		lda #$00	   LDA #<STACK ;#<addr
.df0e	a0 01		ldy #$01	   LDY #>STACK ;#>addr
.df10	60		rts		   RTS
>df11	80 00				Float_0_5       .byte $80,$00 ; 0.5 (including next 3 bytes)
>df13	00 00 00			NULL_Descriptor .byte 0,0,0 ; null descriptor for undefined variables
.df16					  Decimal_Conversion_Table
>df16	fa 0a 1f 00			   .byte $FA,$0A,$1F,$00 ;.quad -100000000
>df1a	00 98 96 80			   .byte $00,$98,$96,$80 ;.quad  +10000000
>df1e	ff f0 bd c0			   .byte $FF,$F0,$BD,$C0 ;.quad   -1000000
>df22	00 01 86 a0			   .byte $00,$01,$86,$A0 ;.quad    +100000
>df26	ff ff d8 f0			   .byte $FF,$FF,$D8,$F0 ;.quad     -10000
>df2a	00 00 03 e8			   .byte $00,$00,$03,$E8 ;.quad      +1000
>df2e	ff ff ff 9c			   .byte $FF,$FF,$FF,$9C ;.quad       -100
>df32	00 00 00 0a			   .byte $00,$00,$00,$0A ;.quad        +10
>df36	ff ff ff ff			   .byte $FF,$FF,$FF,$FF ;.quad         -1
.df3a					  Jiffy_Conversion_Table
>df3a	ff df 0a 80			   .byte $FF,$DF,$0A,$80 ;.quad -2160000 ; 10s hours
>df3e	00 03 4b c0			   .byte $00,$03,$4B,$C0 ;.quad  +216000 ;     hours
>df42	ff ff 73 60			   .byte $FF,$FF,$73,$60 ;.quad   -36000 ; 10s mins
>df46	00 00 0e 10			   .byte $00,$00,$0E,$10 ;.quad    +3600 ;     mins
>df4a	ff ff fd a8			   .byte $FF,$FF,$FD,$A8 ;.quad     -600 ; 10s secs
>df4e	00 00 00 3c			   .byte $00,$00,$00,$3C ;.quad      +60 ;     secs
.df52					End_Of_Conversion
>df52	bf				   .byte $BF
>df53	aa aa aa aa aa aa aa aa		   .fill 30 ,$AA
>df5b	aa aa aa aa aa aa aa aa aa aa aa aa aa aa aa aa
>df6b	aa aa aa aa aa aa
.df71					  Basic_SQR
.df71	20 0c dc	jsr $dc0c	   JSR FAC1_Round_And_Copy_To_FAC2
.df74	a9 11		lda #$11	   LDA #<Float_0_5 ;#<addr
.df76	a0 df		ldy #$df	   LDY #>Float_0_5 ;#>addr
.df78	20 a2 db	jsr $dba2	   JSR Load_FAC1_AY
.df7b					  Basic_POWER
.df7b	f0 70		beq $dfed	   BEQ Basic_EXP     ; perform EXP()
.df7d	a5 69		lda $69		   LDA FAC2EX        ; get FAC2 exponent
.df7f	d0 03		bne $df84	   BNE POW_10        ; branch if FAC2<>0
.df81	4c f9 d8	jmp $d8f9	   JMP PLUS_40       ; clear FAC1 exponent and sign and return
.df84					POW_10
.df84	a2 4e		ldx #$4e	   LDX #<FUNCPT      ; set destination pointer low byte
.df86	a0 00		ldy #$00	   LDY #>FUNCPT      ; set destination pointer high byte
.df88	20 d4 db	jsr $dbd4	   JSR Assign_FAC1_To_Var
.df8b	a5 6e		lda $6e		   LDA FAC2SI        ; get FAC2 sign (b7)
.df8d	10 0f		bpl $df9e	   BPL POW_20        ; branch if FAC2>0
.df8f	20 cc dc	jsr $dccc	   JSR Basic_INT     ; perform INT()
.df92	a9 4e		lda #$4e	   LDA #<FUNCPT ;#<addr
.df94	a0 00		ldy #$00	   LDY #>FUNCPT ;#>addr
.df96	20 5b dc	jsr $dc5b	   JSR Compare_FAC1_AY
.df99	d0 03		bne $df9e	   BNE POW_20        ; branch if FAC1 <> (AY) to allow Function Call error
.df9b	98		tya		   TYA               ; clear sign b7
.df9c	a4 07		ldy $07		   LDY CHARAC        ; get FAC1 mantissa 4 from INT() function as sign in
.df9e					POW_20
.df9e	20 fe db	jsr $dbfe	   JSR Copy_ABS_FAC2_To_FAC1
.dfa1	98		tya		   TYA               ; copy sign back ..
.dfa2	48		pha		   PHA               ; .. and save it
.dfa3	20 ea d9	jsr $d9ea	   JSR Basic_LOG     ; perform LOG()
.dfa6	a9 4e		lda #$4e	   LDA #<FUNCPT ;#<addr
.dfa8	a0 00		ldy #$00	   LDY #>FUNCPT ;#>addr
.dfaa	20 28 da	jsr $da28	   JSR Multiply_FAC1_With_AY
.dfad	20 ed df	jsr $dfed	   JSR Basic_EXP     ; perform EXP()
.dfb0	68		pla		   PLA               ; pull sign from stack
.dfb1	4a		lsr a		   LSR A             ; b0 is to be tested
.dfb2	90 0a		bcc $dfbe	   BCC GREA_Ret      ; if no bit then exit
.dfb4					  Basic_GREATER
.dfb4	a5 61		lda $61		   LDA FAC1EX        ; get FAC1 exponent
.dfb6	f0 06		beq $dfbe	   BEQ GREA_Ret      ; exit if FAC1_e = $00
.dfb8	a5 66		lda $66		   LDA FAC1SI        ; get FAC1 sign (b7)
.dfba	49 ff		eor #$ff	   EOR #$FF          ; complement it
.dfbc	85 66		sta $66		   STA FAC1SI        ; save FAC1 sign (b7)
.dfbe					GREA_Ret
.dfbe	60		rts		   RTS
>dfbf	81 38 aa 3b 29			REV_LOG_2 .byte $81,$38,$AA,$3B,$29 ;.real 1.4426950408
.dfc4					VAR_EXP
>dfc4	07				   .byte   7         ; series count
>dfc5	71 34 58 3e 56			   .byte $71,$34,$58,$3E,$56 ;.real  2.1498763705E-5
>dfca	74 16 7e b3 1b			   .byte $74,$16,$7E,$B3,$1B ;.real  1.4352314041E-4
>dfcf	77 2f ee e3 85			   .byte $77,$2F,$EE,$E3,$85 ;.real  1.3422634825E-3
>dfd4	7a 1d 84 1c 2a			   .byte $7A,$1D,$84,$1C,$2A ;.real  9.6140170140E-3
>dfd9	7c 63 59 58 0a			   .byte $7C,$63,$59,$58,$0A ;.real  5.5505126870E-2
>dfde	7e 75 fd e7 c6			   .byte $7E,$75,$FD,$E7,$C6 ;.real  2.4022638465E-1
>dfe3	80 31 72 18 10			   .byte $80,$31,$72,$18,$10 ;.real  6.9314718640E-1
>dfe8	81 00 00 00 00			   .byte $81,$00,$00,$00,$00 ;.real  1.0
.dfed					  Basic_EXP
.dfed	a9 bf		lda #$bf	   LDA #<REV_LOG_2 ;#<addr
.dfef	a0 df		ldy #$df	   LDY #>REV_LOG_2 ;#>addr
.dff1	20 28 da	jsr $da28	   JSR Multiply_FAC1_With_AY
.dff4	a5 70		lda $70		   LDA FAC1M5        ; get FAC1 rounding byte
.dff6	69 50		adc #$50	   ADC #$50          ; +$50/$100
.dff8	90 03		bcc $dffd	   BCC EXP_10        ; skip rounding if no carry
.dffa	20 23 dc	jsr $dc23	   JSR Round_FAC1
.dffd					EXP_10
.dffd	85 56		sta $56		   STA FAC2M5        ; save FAC2 rounding byte
.dfff	20 0f dc	jsr $dc0f	   JSR FAC1_To_FAC2
.e002	a5 61		lda $61		   LDA FAC1EX        ; get FAC1 exponent
.e004	c9 88		cmp #$88	   CMP #$88          ; compare with EXP limit (256d)
.e006	90 03		bcc $e00b	   BCC EXP_30        ; branch if less
.e008					EXP_20
.e008	20 d4 da	jsr $dad4	   JSR Check_Overflow
.e00b					EXP_30
.e00b	20 cc dc	jsr $dccc	   JSR Basic_INT     ; perform INT()
.e00e	a5 07		lda $07		   LDA CHARAC        ; get mantissa 4 from INT()
.e010	18		clc		   CLC
.e011	69 81		adc #$81	   ADC #$81          ; normalise +1
.e013	f0 f3		beq $e008	   BEQ EXP_20        ; if $00 result has overflowed so go handle it
.e015	38		sec		   SEC
.e016	e9 01		sbc #$01	   SBC #$01          ; exponent now correct
.e018	48		pha		   PHA               ; save FAC2 exponent
.e019	a2 05		ldx #$05	   LDX #$05          ; 4 bytes to do
.e01b					EXP_40
.e01b	b5 69		lda $69,x	   LDA FAC2EX,X      ; get FAC2,X
.e01d	b4 61		ldy $61,x	   LDY FAC1EX,X      ; get FAC1,X
.e01f	95 61		sta $61,x	   STA FAC1EX,X      ; save FAC1,X
.e021	94 69		sty $69,x	   STY FAC2EX,X      ; save FAC2,X
.e023	ca		dex		   DEX               ; decrement count/index
.e024	10 f5		bpl $e01b	   BPL EXP_40        ; loop if not all done
.e026	a5 56		lda $56		   LDA FAC2M5        ; get FAC2 rounding byte
.e028	85 70		sta $70		   STA FAC1M5        ; save as FAC1 rounding byte
.e02a	20 53 d8	jsr $d853	   JSR Basic_MINUS   ; perform subtraction, FAC2 from FAC1
.e02d	20 b4 df	jsr $dfb4	   JSR Basic_GREATER ; do - FAC1
.e030	a9 c4		lda #$c4	   LDA #<VAR_EXP ;#<addr
.e032	a0 df		ldy #$df	   LDY #>VAR_EXP ;#>addr
.e034	20 56 e0	jsr $e056	   JSR Eval_Series_AY
.e037	a9 00		lda #$00	   LDA #0
.e039	85 6f		sta $6f		   STA STRPTR        ; clear sign compare (FAC1 EOR FAC2)
.e03b	68		pla		   PLA               ; pull the saved FAC2 exponent
.e03c	20 b9 da	jsr $dab9	   JSR Check_FACs_A
.e03f	60		rts		   RTS
.e040					  Square_And_Series_Eval
.e040	85 71		sta $71		   STA TMPPTD
.e042	84 72		sty $72		   STY TMPPTD+1
.e044	20 ca db	jsr $dbca	   JSR FAC1_To_FACTPA
.e047	a9 57		lda #$57	   LDA #<FACTPA      ; set pointer low byte (Y already $00)
.e049	20 28 da	jsr $da28	   JSR Multiply_FAC1_With_AY
.e04c	20 5a e0	jsr $e05a	   JSR Eval_Series
.e04f	a9 57		lda #$57	   LDA #<FACTPA ;#<addr
.e051	a0 00		ldy #$00	   LDY #>FACTPA ;#>addr
.e053	4c 28 da	jmp $da28	   JMP Multiply_FAC1_With_AY
.e056					  Eval_Series_AY
.e056	85 71		sta $71		   STA TMPPTD
.e058	84 72		sty $72		   STY TMPPTD+1
.e05a					  Eval_Series
.e05a	20 c7 db	jsr $dbc7	   JSR FAC1_To_FACTPB
.e05d	b1 71		lda ($71),y	   LDA (TMPPTD),Y    ; get constants count
.e05f	85 67		sta $67		   STA SGNFLG        ; save constants count
.e061	a4 71		ldy $71		   LDY TMPPTD        ; get count pointer low byte
.e063	c8		iny		   INY               ; increment it (now constants pointer)
.e064	98		tya		   TYA               ; copy it
.e065	d0 02		bne $e069	   BNE EvSe_10       ; skip next if no overflow
.e067	e6 72		inc $72		   INC TMPPTD+1      ; else increment high byte
.e069					EvSe_10
.e069	85 71		sta $71		   STA TMPPTD        ; save low byte
.e06b	a4 72		ldy $72		   LDY TMPPTD+1      ; get high byte
.e06d					EvSe_20
.e06d	20 28 da	jsr $da28	   JSR Multiply_FAC1_With_AY
.e070	a5 71		lda $71		   LDA TMPPTD
.e072	a4 72		ldy $72		   LDY TMPPTD+1
.e074	18		clc		   CLC
.e075	69 05		adc #$05	   ADC #$05          ; +5 to low pointer (5 bytes per constant)
.e077	90 01		bcc $e07a	   BCC EvSe_30       ; skip next if no overflow
.e079	c8		iny		   INY               ; increment high byte
.e07a					EvSe_30
.e07a	85 71		sta $71		   STA TMPPTD
.e07c	84 72		sty $72		   STY TMPPTD+1
.e07e	20 67 d8	jsr $d867	   JSR Add_Var_AY_To_FAC1
.e081	a9 5c		lda #$5c	   LDA #<FACTPB ;#<addr
.e083	a0 00		ldy #$00	   LDY #>FACTPB ;#>addr
.e085	c6 67		dec $67		   DEC SGNFLG        ; decrement constants count
.e087	d0 e4		bne $e06d	   BNE EvSe_20       ; loop until all done
.e089	60		rts		   RTS
>e08a	98 35 44 7a 00			RND_VA .byte $98,$35,$44,$7A,$00 ;.real 11879546
>e08f	68 28 b1 46 00			RND_VB .byte $68,$28,$B1,$46,$00 ;.real 3.927677739E-8
.e094					  Basic_RND
.e094	20 2b dc	jsr $dc2b	   JSR Get_FAC1_Sign
.e097	30 37		bmi $e0d0	   BMI RND_20        ; if      n<0 copy byte swapped FAC1 into RND() seed
.e099	d0 20		bne $e0bb	   BNE RND_10        ; else if n>0 get next number in RND() sequence
.e09b	20 f3 ff	jsr $fff3	   JSR IOBASE        ; else    n=0 so get the RND() from VIA 1 timers
.e09e	86 22		stx $22		   STX INDEXA
.e0a0	84 23		sty $23		   STY INDEXA+1
.e0a2	a0 04		ldy #$04	   LDY #$04          ; set index to T1 low byte
.e0a4	b1 22		lda ($22),y	   LDA (INDEXA),Y    ; get T1 low byte
.e0a6	85 62		sta $62		   STA FAC1M1        ; save FAC1 mantissa 1
.e0a8	c8		iny		   INY
.e0a9	b1 22		lda ($22),y	   LDA (INDEXA),Y    ; get T1 high byte
.e0ab	85 64		sta $64		   STA FAC1M3        ; save FAC1 mantissa 3
.e0ad	a0 08		ldy #$08	   LDY #$08          ; set index to T2 low byte
.e0af	b1 22		lda ($22),y	   LDA (INDEXA),Y    ; get T2 low byte
.e0b1	85 63		sta $63		   STA FAC1M2        ; save FAC1 mantissa 2
.e0b3	c8		iny		   INY
.e0b4	b1 22		lda ($22),y	   LDA (INDEXA),Y    ; get T2 high byte
.e0b6	85 65		sta $65		   STA FAC1M4        ; save FAC1 mantissa 4
.e0b8	4c e0 e0	jmp $e0e0	   JMP RND_30        ; set exponent and exit
.e0bb					RND_10
.e0bb	a9 8b		lda #$8b	   LDA #<RNDX ;#<addr
.e0bd	a0 00		ldy #$00	   LDY #>RNDX ;#>addr
.e0bf	20 a2 db	jsr $dba2	   JSR Load_FAC1_AY
.e0c2	a9 8a		lda #$8a	   LDA #<RND_VA ;#<addr
.e0c4	a0 e0		ldy #$e0	   LDY #>RND_VA ;#>addr
.e0c6	20 28 da	jsr $da28	   JSR Multiply_FAC1_With_AY
.e0c9	a9 8f		lda #$8f	   LDA #<RND_VB ;#<addr
.e0cb	a0 e0		ldy #$e0	   LDY #>RND_VB ;#>addr
.e0cd	20 67 d8	jsr $d867	   JSR Add_Var_AY_To_FAC1
.e0d0					RND_20
.e0d0	a6 65		ldx $65		   LDX FAC1M4        ; get FAC1 mantissa 4
.e0d2	a5 62		lda $62		   LDA FAC1M1        ; get FAC1 mantissa 1
.e0d4	85 65		sta $65		   STA FAC1M4        ; save FAC1 mantissa 4
.e0d6	86 62		stx $62		   STX FAC1M1        ; save FAC1 mantissa 1
.e0d8	a6 63		ldx $63		   LDX FAC1M2        ; get FAC1 mantissa 2
.e0da	a5 64		lda $64		   LDA FAC1M3        ; get FAC1 mantissa 3
.e0dc	85 63		sta $63		   STA FAC1M2        ; save FAC1 mantissa 2
.e0de	86 64		stx $64		   STX FAC1M3        ; save FAC1 mantissa 3
.e0e0					RND_30
.e0e0	a9 00		lda #$00	   LDA #0
.e0e2	85 66		sta $66		   STA FAC1SI        ; clear FAC1 sign (always positive)
.e0e4	a5 61		lda $61		   LDA FAC1EX        ; get FAC1 exponent
.e0e6	85 70		sta $70		   STA FAC1M5        ; save FAC1 rounding byte
.e0e8	a9 80		lda #$80	   LDA #$80          ; set exponent = $80
.e0ea	85 61		sta $61		   STA FAC1EX        ; save FAC1 exponent
.e0ec	20 d7 d8	jsr $d8d7	   JSR Normalise_FAC1
.e0ef	a2 8b		ldx #$8b	   LDX #<RNDX        ; set seed pointer low address
.e0f1	a0 00		ldy #$00	   LDY #>RNDX        ; set seed pointer high address
.e0f3					  Go_Assign_FAC1_To_Var
.e0f3	4c d4 db	jmp $dbd4	   JMP Assign_FAC1_To_Var
.e0f6					  Error_Handler
.e0f6	c9 f0		cmp #$f0	   CMP #$F0          ; compare error with $F0
.e0f8	d0 07		bne $e101	   BNE ErHa_10       ; branch if not $F0
.e0fa	84 38		sty $38		   STY MEMSIZ+1      ; set end of memory high byte
.e0fc	86 37		stx $37		   STX MEMSIZ        ; set end of memory low byte
.e0fe	4c 63 c6	jmp $c663	   JMP Reset_Variable_Pointer
.e101					ErHa_10
.e101	aa		tax		   TAX               ; copy error #
.e102	d0 02		bne $e106	   BNE ErHa_20       ; branch if not $00
.e104	a2 1e		ldx #$1e	   LDX #$1E          ; else error $1E, break error
.e106					ErHa_20
.e106	4c 37 c4	jmp $c437	   JMP Basic_Error
.e109					  CHROUT_Checked
.e109	20 d2 ff	jsr $ffd2	   JSR CHROUT        ; Output a character
.e10c	b0 e8		bcs $e0f6	   BCS Error_Handler
.e10e	60		rts		   RTS
.e10f					  Read_Char
.e10f	20 cf ff	jsr $ffcf	   JSR CHRIN
.e112	b0 e2		bcs $e0f6	   BCS Error_Handler
.e114	60		rts		   RTS
.e115					  Select_Output_Channel
.e115	20 c9 ff	jsr $ffc9	   JSR CHKOUT        ; open channel for output
.e118	b0 dc		bcs $e0f6	   BCS Error_Handler
.e11a	60		rts		   RTS
.e11b					  CHKIN_Checked
.e11b	20 c6 ff	jsr $ffc6	   JSR CHKIN         ; open channel for input
.e11e	b0 d6		bcs $e0f6	   BCS Error_Handler
.e120	60		rts		   RTS
.e121					  GETIN_Checked
.e121	20 e4 ff	jsr $ffe4	   JSR GETIN         ; get character from input device
.e124	b0 d0		bcs $e0f6	   BCS Error_Handler
.e126	60		rts		   RTS
.e127					  Basic_SYS
.e127	20 8a cd	jsr $cd8a	   JSR Eval_Numeric
.e12a	20 f7 d7	jsr $d7f7	   JSR FAC1_To_LINNUM
.e12d	a9 e1		lda #$e1	   LDA #>SYS_Ret-1   ; get return address high byte
.e12f	48		pha		   PHA               ; push as return address
.e130	a9 43		lda #$43	   LDA #<SYS_Ret-1   ; get return address low byte
.e132	48		pha		   PHA               ; push as return address
.e133	ad 0f 03	lda $030f	   LDA SPREG         ; get saved status register
.e136	48		pha		   PHA               ; put on stack
.e137	ad 0c 03	lda $030c	   LDA SAREG         ; get saved A
.e13a	ae 0d 03	ldx $030d	   LDX SXREG         ; get saved X
.e13d	ac 0e 03	ldy $030e	   LDY SYREG         ; get saved Y
.e140	28		plp		   PLP               ; pull processor status
.e141	6c 14 00	jmp ($0014)	   JMP (LINNUM)      ; call SYS address
.e144					  SYS_Ret
.e144	08		php		   PHP               ; save status
.e145	8d 0c 03	sta $030c	   STA SAREG         ; save returned A
.e148	8e 0d 03	stx $030d	   STX SXREG         ; save returned X
.e14b	8c 0e 03	sty $030e	   STY SYREG         ; save returned Y
.e14e	68		pla		   PLA               ; restore saved status
.e14f	8d 0f 03	sta $030f	   STA SPREG         ; save status
.e152	60		rts		   RTS
.e153					  Basic_SAVE
.e153	20 d1 e1	jsr $e1d1	   JSR Get_Load_Save_Params
.e156					Jiffy_SAVE
.e156	a6 2d		ldx $2d		   LDX VARTAB
.e158	a4 2e		ldy $2e		   LDY VARTAB+1
.e15a	a9 2b		lda #$2b	   LDA #TXTTAB       ; index to start of program memory
.e15c	20 d8 ff	jsr $ffd8	   JSR SAVE          ; save RAM to device, A = index to start address, XY = end
.e15f	b0 95		bcs $e0f6	   BCS Error_Handler
.e161	60		rts		   RTS
.e162					  Basic_VERIFY
.e162	a9 01		lda #$01	   LDA #1            ; flag verify
>e164	2c				   .byte   $2C       ; skip next statement
.e165					  Basic_LOAD
.e165	a9 00		lda #$00	   LDA #0            ; flag load
.e167	85 0a		sta $0a		   STA VERCK         ; set load/verify flag
.e169	20 d1 e1	jsr $e1d1	   JSR Get_Load_Save_Params
.e16c	a5 0a		lda $0a		   LDA VERCK         ; get load/verify flag
.e16e	a6 2b		ldx $2b		   LDX TXTTAB
.e170	a4 2c		ldy $2c		   LDY TXTTAB+1
.e172	20 d5 ff	jsr $ffd5	   JSR LOAD          ; load RAM from a device
.e175	b0 57		bcs $e1ce	   BCS Jump_Error_Handler
.e177	a5 0a		lda $0a		   LDA VERCK         ; get load/verify flag
.e179	f0 1a		beq $e195	   BEQ LOAD_30       ; branch if load
.e17b					LOAD_05
.e17b	a2 1c		ldx #$1c	   LDX #$1C          ; error $1C, verify error
.e17d	20 b7 ff	jsr $ffb7	   JSR READST        ; read I/O status word
.e180	29 10		and #$10	   AND #$10          ; mask for tape read error
.e182	f0 03		beq $e187	   BEQ LOAD_10       ; branch if no read error
.e184	4c 37 c4	jmp $c437	   JMP Basic_Error
.e187					LOAD_10
.e187	a5 7a		lda $7a		   LDA TXTPTR        ; get BASIC execute pointer low byte
.e189	c9 02		cmp #$02	   CMP #2            ; BUG! should be LDA TXTPTR+1:CMP #>BUF:BNE LOAD20
.e18b	f0 07		beq $e194	   BEQ LOAD_20
.e18d	a9 64		lda #$64	   LDA #<Msg_OK ;#<addr
.e18f	a0 c3		ldy #$c3	   LDY #>Msg_OK ;#>addr
.e191	4c 1e cb	jmp $cb1e	   JMP Print_String
.e194					LOAD_20
.e194	60		rts		   RTS
.e195					LOAD_30
.e195	20 b7 ff	jsr $ffb7	   JSR READST        ; read I/O status word
.e198	29 bf		and #$bf	   AND #$BF          ; mask x0xx xxxx, clear read error
.e19a	f0 05		beq $e1a1	   BEQ LOAD_50       ; branch if no errors
.e19c	a2 1d		ldx #$1d	   LDX #$1D          ; error $1D, load error
.e19e					LOAD_40
.e19e	4c 37 c4	jmp $c437	   JMP Basic_Error
.e1a1					LOAD_50
.e1a1	a5 7b		lda $7b		   LDA TXTPTR+1      ; get BASIC execute pointer high byte
.e1a3	c9 02		cmp #$02	   CMP #>BUF
.e1a5	d0 0e		bne $e1b5	   BNE LOAD_60       ; branch if not direct mode
.e1a7					LOAD_55
.e1a7	86 2d		stx $2d		   STX VARTAB
.e1a9	84 2e		sty $2e		   STY VARTAB+1
.e1ab	a9 76		lda #$76	   LDA #<Msg_Ready
.e1ad	a0 c3		ldy #$c3	   LDY #>Msg_Ready
.e1af	20 1e cb	jsr $cb1e	   JSR Print_String
.e1b2	4c 2a c5	jmp $c52a	   JMP Reset_And_Rechain
.e1b5					LOAD_60
.e1b5	20 8e c6	jsr $c68e	   JSR Reset_BASIC_Exec_Pointer
.e1b8	4c 76 e4	jmp $e476	   JMP Rebuild_andRestore      ; rebuild BASIC line chaining, do RESTORE and return
.e1bb					  Basic_OPEN
.e1bb	20 16 e2	jsr $e216	   JSR Get_Open_Close_Params
.e1be	20 c0 ff	jsr $ffc0	   JSR OPEN          ; open a logical file
.e1c1	b0 0b		bcs $e1ce	   BCS Jump_Error_Handler      ; branch if error
.e1c3	60		rts		   RTS
.e1c4					  Basic_CLOSE
.e1c4	20 16 e2	jsr $e216	   JSR Get_Open_Close_Params
.e1c7	a5 49		lda $49		   LDA FORPNT        ; get logical file number
.e1c9	20 c3 ff	jsr $ffc3	   JSR CLOSE         ; close a specified logical file
.e1cc	90 c6		bcc $e194	   BCC LOAD_20      ; exit if no error
.e1ce					Jump_Error_Handler
.e1ce	4c f6 e0	jmp $e0f6	   JMP Error_Handler
.e1d1					  Get_Load_Save_Params
.e1d1	a9 00		lda #$00	   LDA #$00          ; clear file name length
.e1d3	20 bd ff	jsr $ffbd	   JSR SETNAM        ; clear filename
.e1d6	a2 01		ldx #$01	   LDX #$01          ; set default device number, cassette
.e1d8	a0 00		ldy #$00	   LDY #$00          ; set default command
.e1da	20 ba ff	jsr $ffba	   JSR SETLFS        ; set logical, first and second addresses
.e1dd	20 03 e2	jsr $e203	   JSR Exit_On_EOS
.e1e0	20 54 e2	jsr $e254	   JSR Set_Filename
.e1e3	20 03 e2	jsr $e203	   JSR Exit_On_EOS
.e1e6	20 fd e1	jsr $e1fd	   JSR Get_Byte_Param
.e1e9	a0 00		ldy #$00	   LDY #$00          ; clear command
.e1eb	86 49		stx $49		   STX FORPNT        ; save device number
.e1ed	20 ba ff	jsr $ffba	   JSR SETLFS        ; set logical, first and second addresses
.e1f0	20 03 e2	jsr $e203	   JSR Exit_On_EOS
.e1f3	20 fd e1	jsr $e1fd	   JSR Get_Byte_Param
.e1f6	8a		txa		   TXA               ; copy command to A
.e1f7	a8		tay		   TAY               ; copy command to Y
.e1f8	a6 49		ldx $49		   LDX FORPNT        ; get device number back
.e1fa	4c ba ff	jmp $ffba	   JMP SETLFS        ; set logical, first and second addresses and return
.e1fd					  Get_Byte_Param
.e1fd	20 0b e2	jsr $e20b	   JSR Read_Comma_And_Byte
.e200	4c 9e d7	jmp $d79e	   JMP Get_Byte_Value
.e203					  Exit_On_EOS
.e203	20 79 00	jsr $0079	   JSR CHRGOT
.e206	d0 02		bne $e20a	   BNE EOE_Ret       ; branch if not [EOL] or ":"
.e208	68		pla		   PLA               ; dump return address low byte
.e209	68		pla		   PLA               ; dump return address high byte
.e20a					EOE_Ret
.e20a	60		rts		   RTS
.e20b					  Read_Comma_And_Byte
.e20b	20 fd ce	jsr $cefd	   JSR Need_Comma
.e20e					  Need_Byte
.e20e	20 79 00	jsr $0079	   JSR CHRGOT
.e211	d0 f7		bne $e20a	   BNE EOE_Ret      ; exit if following byte
.e213	4c 08 cf	jmp $cf08	   JMP Syntax_Error
.e216					  Get_Open_Close_Params
.e216	a9 00		lda #$00	   LDA #$00          ; clear file name length
.e218	20 bd ff	jsr $ffbd	   JSR SETNAM        ; clear filename
.e21b	20 0e e2	jsr $e20e	   JSR Need_Byte
.e21e	20 9e d7	jsr $d79e	   JSR Get_Byte_Value
.e221	86 49		stx $49		   STX FORPNT        ; save logical file number
.e223	8a		txa		   TXA               ; copy logical file number to A
.e224	a2 01		ldx #$01	   LDX #$01          ; set default device number, cassette
.e226					GOCP_05
.e226	a0 00		ldy #$00	   LDY #$00          ; set default command
.e228	20 ba ff	jsr $ffba	   JSR SETLFS        ; set logical, first and second addresses
.e22b	20 03 e2	jsr $e203	   JSR Exit_On_EOS
.e22e	20 fd e1	jsr $e1fd	   JSR Get_Byte_Param
.e231	86 4a		stx $4a		   STX FORPNT+1      ; save device number
.e233	a0 00		ldy #$00	   LDY #$00          ; clear command
.e235	a5 49		lda $49		   LDA FORPNT        ; get logical file number
.e237	e0 03		cpx #$03	   CPX #$03          ; compare device number with screen
.e239	90 01		bcc $e23c	   BCC GOCP_10       ; branch if less than screen
.e23b	88		dey		   DEY               ; else decrement command
.e23c					GOCP_10
.e23c	20 ba ff	jsr $ffba	   JSR SETLFS        ; set logical, first and second addresses
.e23f	20 03 e2	jsr $e203	   JSR Exit_On_EOS
.e242	20 fd e1	jsr $e1fd	   JSR Get_Byte_Param
.e245	8a		txa		   TXA               ; copy command to A
.e246	a8		tay		   TAY               ; copy command to Y
.e247	a6 4a		ldx $4a		   LDX FORPNT+1      ; get device number
.e249	a5 49		lda $49		   LDA FORPNT        ; get logical file number
.e24b	20 ba ff	jsr $ffba	   JSR SETLFS        ; set logical, first and second addresses
.e24e	20 03 e2	jsr $e203	   JSR Exit_On_EOS
.e251	20 0b e2	jsr $e20b	   JSR Read_Comma_And_Byte
.e254					  Set_Filename
.e254	20 9e cd	jsr $cd9e	   JSR Eval_Expression
.e257					Set_Filename_From_String
.e257	20 a3 d6	jsr $d6a3	   JSR Eval_String
.e25a	a6 22		ldx $22		   LDX INDEXA        ; get string pointer low byte
.e25c	a4 23		ldy $23		   LDY INDEXA+1      ; get string pointer high byte
.e25e	4c bd ff	jmp $ffbd	   JMP SETNAM        ; set filename and return
.e261					  Basic_COS
.e261	a9 dd		lda #$dd	   LDA #<PI_Half ;#<addr
.e263	a0 e2		ldy #$e2	   LDY #>PI_Half ;#>addr
.e265	20 67 d8	jsr $d867	   JSR Add_Var_AY_To_FAC1
.e268					  Basic_SIN
.e268	20 0c dc	jsr $dc0c	   JSR FAC1_Round_And_Copy_To_FAC2
.e26b	a9 e2		lda #$e2	   LDA #<Two_PI ;#<addr
.e26d	a0 e2		ldy #$e2	   LDY #>Two_PI ;#>addr
.e26f	a6 6e		ldx $6e		   LDX FAC2SI        ; get FAC2 sign (b7)
.e271	20 07 db	jsr $db07	   JSR Divide_FAC2_By_AY
.e274	20 0c dc	jsr $dc0c	   JSR FAC1_Round_And_Copy_To_FAC2
.e277	20 cc dc	jsr $dccc	   JSR Basic_INT
.e27a	a9 00		lda #$00	   LDA #0
.e27c	85 6f		sta $6f		   STA STRPTR        ; clear sign compare (FAC1 EOR FAC2)
.e27e	20 53 d8	jsr $d853	   JSR Basic_MINUS   ; perform subtraction, FAC2 from FAC1
.e281	a9 e7		lda #$e7	   LDA #<Float_0_25 ;#<addr
.e283	a0 e2		ldy #$e2	   LDY #>Float_0_25 ;#>addr
.e285	20 50 d8	jsr $d850	   JSR AY_Minus_FAC1
.e288	a5 66		lda $66		   LDA FAC1SI        ; get FAC1 sign (b7)
.e28a	48		pha		   PHA               ; save FAC1 sign
.e28b	10 0d		bpl $e29a	   BPL SIN_10        ; branch if positive
.e28d	20 49 d8	jsr $d849	   JSR Add_0_5_To_FAC1
.e290	a5 66		lda $66		   LDA FAC1SI        ; get FAC1 sign (b7)
.e292	30 09		bmi $e29d	   BMI SIN_20        ; branch if negative
.e294	a5 12		lda $12		   LDA TANSGN        ; get the comparison evaluation flag
.e296	49 ff		eor #$ff	   EOR #$FF          ; toggle flag
.e298	85 12		sta $12		   STA TANSGN        ; save the comparison evaluation flag
.e29a					SIN_10
.e29a	20 b4 df	jsr $dfb4	   JSR Basic_GREATER ; do - FAC1
.e29d					SIN_20
.e29d	a9 e7		lda #$e7	   LDA #<Float_0_25 ;#<addr
.e29f	a0 e2		ldy #$e2	   LDY #>Float_0_25 ;#>addr
.e2a1	20 67 d8	jsr $d867	   JSR Add_Var_AY_To_FAC1
.e2a4	68		pla		   PLA               ; restore FAC1 sign
.e2a5	10 03		bpl $e2aa	   BPL SIN_30        ; branch if was positive
.e2a7	20 b4 df	jsr $dfb4	   JSR Basic_GREATER ; do - FAC1
.e2aa					SIN_30
.e2aa	a9 ec		lda #$ec	   LDA #<VAR_SIN ;#<addr
.e2ac	a0 e2		ldy #$e2	   LDY #>VAR_SIN ;#>addr
.e2ae	4c 40 e0	jmp $e040	   JMP Square_And_Series_Eval
.e2b1					  Basic_TAN
.e2b1	20 ca db	jsr $dbca	   JSR FAC1_To_FACTPA
.e2b4	a9 00		lda #$00	   LDA #0
.e2b6	85 12		sta $12		   STA TANSGN        ; clear the comparison evaluation flag
.e2b8	20 68 e2	jsr $e268	   JSR Basic_SIN     ; perform SIN()
.e2bb	a2 4e		ldx #$4e	   LDX #<FUNCPT      ; set sin(n) pointer low byte
.e2bd	a0 00		ldy #$00	   LDY #>FUNCPT      ; set sin(n) pointer high byte
.e2bf	20 f3 e0	jsr $e0f3	   JSR Go_Assign_FAC1_To_Var
.e2c2	a9 57		lda #$57	   LDA #<FACTPA ;#<addr
.e2c4	a0 00		ldy #$00	   LDY #>FACTPA ;#>addr
.e2c6	20 a2 db	jsr $dba2	   JSR Load_FAC1_AY
.e2c9	a9 00		lda #$00	   LDA #0
.e2cb	85 66		sta $66		   STA FAC1SI        ; clear FAC1 sign (b7)
.e2cd	a5 12		lda $12		   LDA TANSGN        ; get the comparison evaluation flag
.e2cf	20 d9 e2	jsr $e2d9	   JSR TAN_10
.e2d2	a9 4e		lda #$4e	   LDA #<FUNCPT ;#<addr
.e2d4	a0 00		ldy #$00	   LDY #>FUNCPT ;#>addr
.e2d6	4c 0f db	jmp $db0f	   JMP AY_Divided_By_FAC1
.e2d9					  TAN_10
.e2d9	48		pha		   PHA               ; save comparison flag
.e2da	4c 9a e2	jmp $e29a	   JMP SIN_10      ; add 0.25, ^2 then series evaluation
>e2dd	81 49 0f da a2			PI_Half    .byte $81,$49,$0F,$DA,$A2 ;.real 1.5707963271
>e2e2	83 49 0f da a2			Two_PI     .byte $83,$49,$0F,$DA,$A2 ;.real 6.283185307
>e2e7	7f 00 00 00 00			Float_0_25 .byte $7F,$00,$00,$00,$00 ;.real 0.25
.e2ec					VAR_SIN
>e2ec	05				   .byte   $05       ; series counter
>e2ed	84 e6 1a 2d 1b			   .byte $84,$E6,$1A,$2D,$1B ;.real -14.381390673
>e2f2	86 28 07 fb f8			   .byte $86,$28,$07,$FB,$F8 ;.real  42.00779713
>e2f7	87 99 68 89 01			   .byte $87,$99,$68,$89,$01 ;.real -76.70417028
>e2fc	87 23 35 df e1			   .byte $87,$23,$35,$DF,$E1 ;.real  81.60522370
>e301	86 a5 5d e7 28			   .byte $86,$A5,$5D,$E7,$28 ;.real -41.34170211
>e306	83 49 0f da a2			   .byte $83,$49,$0F,$DA,$A2 ;.real   6.283185308
.e30b					  Basic_ATN
.e30b	a5 66		lda $66		   LDA FAC1SI        ; get FAC1 sign (b7)
.e30d	48		pha		   PHA               ; save sign
.e30e	10 03		bpl $e313	   BPL ATN_10        ; branch if positive
.e310	20 b4 df	jsr $dfb4	   JSR Basic_GREATER ; else do - FAC1
.e313					ATN_10
.e313	a5 61		lda $61		   LDA FAC1EX        ; get FAC1 exponent
.e315	48		pha		   PHA               ; push exponent
.e316	c9 81		cmp #$81	   CMP #$81          ; compare with 1
.e318	90 07		bcc $e321	   BCC ATN_20        ; branch if FAC1 < 1
.e31a	a9 bc		lda #$bc	   LDA #<REAL_1 ;#<addr
.e31c	a0 d9		ldy #$d9	   LDY #>REAL_1 ;#>addr
.e31e	20 0f db	jsr $db0f	   JSR AY_Divided_By_FAC1
.e321					ATN_20
.e321	a9 3b		lda #$3b	   LDA #<VAR_ATN ;#<addr
.e323	a0 e3		ldy #$e3	   LDY #>VAR_ATN ;#>addr
.e325	20 40 e0	jsr $e040	   JSR Square_And_Series_Eval
.e328	68		pla		   PLA               ; restore old FAC1 exponent
.e329	c9 81		cmp #$81	   CMP #$81          ; compare with 1
.e32b	90 07		bcc $e334	   BCC ATN_30        ; branch if FAC1 < 1
.e32d	a9 dd		lda #$dd	   LDA #<PI_Half ;#<addr
.e32f	a0 e2		ldy #$e2	   LDY #>PI_Half ;#>addr
.e331	20 50 d8	jsr $d850	   JSR AY_Minus_FAC1
.e334					ATN_30
.e334	68		pla		   PLA               ; restore FAC1 sign
.e335	10 03		bpl $e33a	   BPL ATN_Ret       ; exit if was positive
.e337	4c b4 df	jmp $dfb4	   JMP Basic_GREATER ; else do - FAC1 and return
.e33a					ATN_Ret
.e33a	60		rts		   RTS
.e33b					VAR_ATN
>e33b	0b				   .byte 11        ; series counter
>e33c	76 b3 83 bd d3			   .byte $76,$B3,$83,$BD,$D3 ;.real -6.8479391200E-4
>e341	79 1e f4 a6 f5			   .byte $79,$1E,$F4,$A6,$F5 ;.real  4.8509421570E-3
>e346	7b 83 fc b0 10			   .byte $7B,$83,$FC,$B0,$10 ;.real -1.6111701850E-2
>e34b	7c 0c 1f 67 ca			   .byte $7C,$0C,$1F,$67,$CA ;.real  3.4209638050E-2
>e350	7c de 53 cb c1			   .byte $7C,$DE,$53,$CB,$C1 ;.real -5.4279132770E-2
>e355	7d 14 64 70 4c			   .byte $7D,$14,$64,$70,$4C ;.real  7.2457196550E-2
>e35a	7d b7 ea 51 7a			   .byte $7D,$B7,$EA,$51,$7A ;.real -8.9802395400E-2
>e35f	7d 63 30 88 7e			   .byte $7D,$63,$30,$88,$7E ;.real  1.1093241345E-1
>e364	7e 92 44 99 3a			   .byte $7E,$92,$44,$99,$3A ;.real -0.1428398077
>e369	7e 4c cc 91 c7			   .byte $7E,$4C,$CC,$91,$C7 ;.real  0.1999991205
>e36e	7f aa aa aa 13			   .byte $7F,$AA,$AA,$AA,$13 ;.real -0.3333333157
>e373	81 00 00 00 00			   .byte $81,$00,$00,$00,$00 ;.real  1.0
.e378					Basic_Cold_Start
.e378	20 5b e4	jsr $e45b	   JSR Init_BASIC_Jump_Vectors
.e37b	20 a4 e3	jsr $e3a4	   JSR Init_BASIC_RAM_Vectors
.e37e	20 04 e4	jsr $e404	   JSR Print_Startup_Message
.e381	a2 fb		ldx #$fb	   LDX #$FB          ; value for start stack
.e383	9a		txs		   TXS               ; set stack pointer
.e384	4c 74 c4	jmp $c474	   JMP Basic_Ready
.e387					  CHRGET_ROM
.e387	e6 7a		inc $7a		   INC TXTPTR        ; increment BASIC execute pointer low byte
.e389	d0 02		bne $e38d	   BNE CHRO_10       ; branch if no carry
.e38b	e6 7b		inc $7b		   INC TXTPTR+1      ; increment BASIC execute pointer high byte
.e38d					CHRO_10
.e38d	ad 60 ea	lda $ea60	   LDA $EA60         ; get byte to scan, address set by call routine
.e390	c9 3a		cmp #$3a	   CMP #':'          ; compare with ":"
.e392	b0 0a		bcs $e39e	   BCS CHRO_Ret      ; exit if>=
.e394	c9 20		cmp #$20	   CMP #' '          ; compare with " "
.e396	f0 ef		beq $e387	   BEQ CHRGET_ROM    ; if " " go do next
.e398	38		sec		   SEC               ; set carry for SBC
.e399	e9 30		sbc #$30	   SBC #'0'          ; subtract "0"
.e39b	38		sec		   SEC               ; set carry for SBC
.e39c	e9 d0		sbc #$d0	   SBC #$D0          ; subtract -"0"
.e39e					CHRO_Ret
.e39e	60		rts		   RTS
>e39f	80 4f c7 52 58			   .byte   $80,$4F,$C7,$52,$58 ; 0.811635157
.e3a4					  Init_BASIC_RAM_Vectors
.e3a4	a9 4c		lda #$4c	   LDA #$4C          ; opcode for JMP
.e3a6	85 54		sta $54		   STA JUMPER        ; save for functions vector jump
.e3a8	85 00		sta $00		   STA Basic_USR
.e3aa	a9 48		lda #$48	   LDA #<Illegal_Quantity ;#<addr
.e3ac	a0 d2		ldy #$d2	   LDY #>Illegal_Quantity ;#>addr
.e3ae	85 01		sta $01		   STA USRVEC
.e3b0	84 02		sty $02		   STY USRVEC+1
.e3b2	a9 91		lda #$91	   LDA #<Integer_To_Float ;#<addr
.e3b4	a0 d3		ldy #$d3	   LDY #>Integer_To_Float ;#>addr
.e3b6	85 05		sta $05		   STA ADRAY2
.e3b8	84 06		sty $06		   STY ADRAY2+1
.e3ba	a9 aa		lda #$aa	   LDA #<Float_To_Integer ;#<addr
.e3bc	a0 d1		ldy #$d1	   LDY #>Float_To_Integer ;#>addr
.e3be	85 03		sta $03		   STA ADRAY1
.e3c0	84 04		sty $04		   STY ADRAY1+1
.e3c2	a2 1c		ldx #$1c	   LDX #$1C          ; set byte count
.e3c4					IBRV_10
.e3c4	bd 87 e3	lda $e387,x	   LDA CHRGET_ROM,X  ; get byte from table
.e3c7	95 73		sta $73,x	   STA CHRGET,X      ; save byte in page zero
.e3c9	ca		dex		   DEX               ; decrement count
.e3ca	10 f8		bpl $e3c4	   BPL IBRV_10       ; loop if not all done
.e3cc	a9 03		lda #$03	   LDA #$03          ; set step size, collecting descriptors
.e3ce	85 53		sta $53		   STA GARBSS        ; save garbage collection step size
.e3d0	a9 00		lda #$00	   LDA #0
.e3d2	85 68		sta $68		   STA FAC1OV        ; clear FAC1 overflow byte
.e3d4	85 13		sta $13		   STA IOPMPT        ; clear current I/O channel, flag default
.e3d6	85 18		sta $18		   STA LASTPT+1      ; clear current descriptor stack item pointer high byte
.e3d8	a2 01		ldx #$01	   LDX #$01          ; set X
.e3da	8e fd 01	stx $01fd	   STX BUF-3         ; set chain link pointer low byte
.e3dd	8e fc 01	stx $01fc	   STX BUF-4         ; set chain link pointer high byte
.e3e0	a2 19		ldx #$19	   LDX #TEMPST       ; initial value for descriptor stack
.e3e2	86 16		stx $16		   STX TEMPPT        ; set descriptor stack pointer
.e3e4	38		sec		   SEC               ; set Cb = 1 to read the bottom of memory
.e3e5	20 9c ff	jsr $ff9c	   JSR MEMBOT        ; read/set the bottom of memory
.e3e8	86 2b		stx $2b		   STX TXTTAB
.e3ea	84 2c		sty $2c		   STY TXTTAB+1
.e3ec	38		sec		   SEC               ; set Cb = 1 to read the top of memory
.e3ed	20 99 ff	jsr $ff99	   JSR MEMTOP        ; read/set the top of memory
.e3f0	86 37		stx $37		   STX MEMSIZ
.e3f2	84 38		sty $38		   STY MEMSIZ+1
.e3f4	86 33		stx $33		   STX FRESPC
.e3f6	84 34		sty $34		   STY FRESPC+1
.e3f8	a0 00		ldy #$00	   LDY #0
.e3fa	98		tya		   TYA               ; clear A
.e3fb	91 2b		sta ($2b),y	   STA (TXTTAB),Y    ; clear first byte of memory
.e3fd	e6 2b		inc $2b		   INC TXTTAB        ; increment start of memory low byte
.e3ff	d0 02		bne $e403	   BNE IBRV_Ret      ; branch if no rollover
.e401	e6 2c		inc $2c		   INC TXTTAB+1      ; increment start of memory high byte
.e403					IBRV_Ret
.e403	60		rts		   RTS
.e404					  Print_Startup_Message
.e404	a5 2b		lda $2b		   LDA TXTTAB
.e406	a4 2c		ldy $2c		   LDY TXTTAB+1
.e408	20 08 c4	jsr $c408	   JSR Check_Mem_Avail
.e40b	a9 36		lda #$36	   LDA #<Start_Message
.e40d	a0 e4		ldy #$e4	   LDY #>Start_Message
.e40f	20 1e cb	jsr $cb1e	   JSR Print_String
.e412	a5 37		lda $37		   LDA MEMSIZ        ; get end of memory low byte
.e414	38		sec		   SEC
.e415	e5 2b		sbc $2b		   SBC TXTTAB        ; subtract start of memory low byte
.e417	aa		tax		   TAX               ; copy result to X
.e418	a5 38		lda $38		   LDA MEMSIZ+1      ; get end of memory high byte
.e41a	e5 2c		sbc $2c		   SBC TXTTAB+1      ; subtract start of memory high byte
.e41c	20 cd dd	jsr $ddcd	   JSR Print_Integer_XA
.e41f	a9 29		lda #$29	   LDA #<Bytes_Free_Message
.e421	a0 e4		ldy #$e4	   LDY #>Bytes_Free_Message
.e423	20 1e cb	jsr $cb1e	   JSR Print_String
.e426	4c 44 c6	jmp $c644	   JMP Perform_NEW
.e429					Bytes_Free_Message
>e429	20 42 59 54 45 53 20 46		   .TEXT   " BYTES FREE",$0D,$00
>e431	52 45 45 0d 00
.e436					Start_Message
>e436	93 2a 2a 2a 2a 20 43 42		   .TEXT   $93,"**** CBM BASIC V2 ****",$0D,$00
>e43e	4d 20 42 41 53 49 43 20 56 32 20 2a 2a 2a 2a 0d
>e44e	00
.e44f					Basic_Vectors
>e44f	3a c4				   .word   Default_Error      ; error message            IERROR
>e451	83 c4				   .word   Default_Warmstart  ; BASIC warm start         IMAIN
>e453	7c c5				   .word   Default_Tokenize   ; crunch BASIC tokens      ICRNCH
>e455	1a c7				   .word   Default_Detokenize ; uncrunch BASIC tokens    IQPLOP
>e457	e4 c7				   .word   Default_Start      ; start new BASIC code     IGONE
>e459	86 ce				   .word   Default_EVAL       ; get arithmetic element   IEVAL
.e45b					  Init_BASIC_Jump_Vectors
.e45b	a2 0b		ldx #$0b	   LDX #$0B          ; set byte count
.e45d					IBJV_10
.e45d	bd 4f e4	lda $e44f,x	   LDA Basic_Vectors,X
.e460	9d 00 03	sta $0300,x	   STA IERROR,X      ; save byte to RAM
.e463	ca		dex		   DEX               ; decrement index
.e464	10 f7		bpl $e45d	   BPL IBJV_10       ; loop if more to do
.e466	60		rts		   RTS
.e467					  Basic_Warm_Start
.e467	20 cc ff	jsr $ffcc	   JSR CLRCHN        ; Clear I/O channels
.e46a	a9 00		lda #$00	   LDA #0
.e46c	85 13		sta $13		   STA IOPMPT        ; set current I/O channel, flag default
.e46e	20 7a c6	jsr $c67a	   JSR Flush_BASIC_Stack
.e471	58		cli		   CLI               ; enable interrupts
.e472	4c 74 c4	jmp $c474	   JMP Basic_Ready
>e475	e8				   .byte   $E8 ;i$41       ; [NTSC]
.e476					Rebuild_andRestore
.e476	20 33 c5	jsr $c533	   JSR Rechain
.e479	4c 77 c6	jmp $c677	   JMP Restore_And_Flush_Stack
>e47c	ff ff ff ff ff ff ff ff		   .fill 36 ,$ff
>e484	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
>e494	ff ff ff ff ff ff ff ff ff ff ff ff
.e4a0					  CLR_IEC_DAT
.e4a0	ad 2c 91	lda $912c	   LDA IEC_PCR
.e4a3	29 df		and #$df	   AND #~IEC_DAT_BIT
.e4a5	8d 2c 91	sta $912c	   STA IEC_PCR
.e4a8	60		rts		   RTS
.e4a9					SET_IEC_DAT
.e4a9	ad 2c 91	lda $912c	   LDA IEC_PCR       ; get VIA 2 PCR
.e4ac	09 20		ora #$20	   ORA #$20          ; set CB2 high, serial data out low
.e4ae	8d 2c 91	sta $912c	   STA IEC_PCR       ; set VIA 2 PCR
.e4b1	60		rts		   RTS
.e4b2					  GET_IEC_CLK
.e4b2	ad 1f 91	lda $911f	   LDA IEC_DRAN      ; get VIA 1 DRA, no handshake
.e4b5	cd 1f 91	cmp $911f	   CMP IEC_DRAN      ; compare with self
.e4b8	d0 f8		bne $e4b2	   BNE GET_IEC_CLK   ; loop if changing
.e4ba	4a		lsr a		   LSR A             ; shift serial clock to Cb
.e4bb	60		rts		   RTS
.e4bc					  Get_SA_Print_Searching
.e4bc	a6 b9		ldx $b9		   LDX SA
.e4be	4c 47 f6	jmp $f647	   JMP Print_Searching
.e4c1					  Set_Load_Address
.e4c1	8a		txa		   TXA               ; copy secondary address
.e4c2	d0 08		bne $e4cc	   BNE SLA_10        ; load location not set in LOAD call, so
.e4c4	a5 c3		lda $c3		   LDA MEMUSS        ; get load address low byte
.e4c6	85 ae		sta $ae		   STA EAL           ; save program start address low byte
.e4c8	a5 c4		lda $c4		   LDA MEMUSS+1      ; get load address high byte
.e4ca	85 af		sta $af		   STA EAL+1         ; save program start address high byte
.e4cc					SLA_10
.e4cc	4c 6a f6	jmp $f66a	   JMP Display_LOADING_Or_VERIFYING
.e4cf					  Close_Patch
.e4cf	20 e3 f8	jsr $f8e3	   JSR Init_Tape_Write
.e4d2	90 03		bcc $e4d7	   BCC ClPa_10       ; branch if no error
.e4d4	68		pla		   PLA               ; else dump stacked exit code
.e4d5	a9 00		lda #$00	   LDA #$00          ; clear exit code
.e4d7					ClPa_10
.e4d7	4c 9e f3	jmp $f39e	   JMP KeCL_50      ; go do I/O close
>e4da	ff ff ff ff ff ff ff ff		   .FILL 38 ,$ff     ; spare bytes, not referenced
>e4e2	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff
>e4f2	ff ff ff ff ff ff ff ff ff ff ff ff ff ff
.e500					  Kernal_IOBASE
.e500	a2 10		ldx #$10	   LDX #<IO_Base_Address
.e502	a0 91		ldy #$91	   LDY #>IO_Base_Address
.e504	60		rts		   RTS
.e505					  Kernal_SCREEN
.e505	a2 16		ldx #$16	   LDX #COLS
.e507	a0 17		ldy #$17	   LDY #ROWS
.e509	60		rts		   RTS
.e50a					  Kernal_PLOT
.e50a	b0 07		bcs $e513	   BCS PLOT_10       ; if read cursor skip the set cursor
.e50c					PLOT_05
.e50c	86 d6		stx $d6		   STX TBLX          ; save cursor row
.e50e	84 d3		sty $d3		   STY CSRIDX        ; save cursor column
.e510	20 87 e5	jsr $e587	   JSR Adjust_Line   ; set screen pointers for cursor row, column
.e513					PLOT_10
.e513	a6 d6		ldx $d6		   LDX TBLX          ; get cursor row
.e515	a4 d3		ldy $d3		   LDY CSRIDX        ; get cursor column
.e517	60		rts		   RTS
.e518					  Initialise_Hardware
.e518	20 bb e5	jsr $e5bb	   JSR Set_Default_Devices
.e51b	ad 88 02	lda $0288	   LDA SCNMPG        ; get screen memory page
.e51e	29 fd		and #$fd	   AND #$FD          ; mask xxxx xx0x, all but va9
.e520	0a		asl a		   ASL A             ; << 1 xxxx x0x0
.e521	0a		asl a		   ASL A             ; << 2 xxxx 0x00
.e522	09 80		ora #$80	   ORA #$80          ; set  1xxx 0x00
.e524	8d 05 90	sta $9005	   STA VIC_R5        ; set screen and character memory location
.e527	ad 88 02	lda $0288	   LDA SCNMPG        ; get screen memory page
.e52a	29 02		and #$02	   AND #$02          ; mask bit 9
.e52c	f0 08		beq $e536	   BEQ InHa_10       ; if zero just go normalise screen
.e52e	a9 80		lda #$80	   LDA #$80          ; set b7
.e530	0d 02 90	ora $9002	   ORA VIC_R2        ; OR in as video address 9
.e533	8d 02 90	sta $9002	   STA VIC_R2        ; save new va9
.e536					InHa_10
.e536	a9 00		lda #$00	   LDA #0
.e538	8d 91 02	sta $0291	   STA MODE          ; clear shift mode switch
.e53b	85 cf		sta $cf		   STA BLNON         ; clear cursor blink phase
.e53d	a9 dc		lda #$dc	   LDA #<Keyboard_Decoder
.e53f	8d 8f 02	sta $028f	   STA KEYLOG
.e542	a9 eb		lda #$eb	   LDA #>Keyboard_Decoder
.e544	8d 90 02	sta $0290	   STA KEYLOG+1
.e547	a9 0a		lda #$0a	   LDA #$0A          ; 10d
.e549	8d 89 02	sta $0289	   STA KBMAXL        ; set maximum size of keyboard buffer
.e54c	8d 8c 02	sta $028c	   STA KRPTDL        ; set repeat delay counter
.e54f	a9 06		lda #$06	   LDA #Default_Color
.e551	8d 86 02	sta $0286	   STA COLOR         ; set current colour code
.e554	a9 04		lda #$04	   LDA #$04          ; speed 4
.e556	8d 8b 02	sta $028b	   STA KRPTSP        ; set repeat speed counter
.e559	a9 0c		lda #$0c	   LDA #$0C          ; cursor flash timing
.e55b	85 cd		sta $cd		   STA BLNCT         ; set cursor timing countdown
.e55d	85 cc		sta $cc		   STA BLNSW         ; set cursor enable, $00 = flash cursor
.e55f					  Clear_Screen
.e55f	ad 88 02	lda $0288	   LDA SCNMPG        ; get screen memory page
.e562	09 80		ora #$80	   ORA #$80          ; set high bit, flag every line is logical line start
.e564	a8		tay		   TAY               ; copy to Y
.e565	a9 00		lda #$00	   LDA #$00          ; clear line start low byte
.e567	aa		tax		   TAX               ; clear index
.e568					ClSc_10
.e568	94 d9		sty $d9,x	   STY SLLTBL,X      ; save start of line X pointer high byte
.e56a	18		clc		   CLC
.e56b	69 16		adc #$16	   ADC #COLS         ; add line length to low byte
.e56d	90 01		bcc $e570	   BCC ClSc_20       ; if no rollover skip the high byte increment
.e56f	c8		iny		   INY               ; else increment high byte
.e570					ClSc_20
.e570	e8		inx		   INX               ; increment line index
.e571	e0 18		cpx #$18	   CPX #ROWS+1       ; compare with number of lines + 1
.e573	d0 f3		bne $e568	   BNE ClSc_10       ; loop if not all done
.e575	a9 ff		lda #$ff	   LDA #$FF          ; end of table marker ??
.e577	95 d9		sta $d9,x	   STA SLLTBL,X      ; mark end of table
.e579	a2 16		ldx #$16	   LDX #ROWS-1       ; set line count
.e57b					ClSc_30
.e57b	20 8d ea	jsr $ea8d	   JSR Clear_Screen_Row_X
.e57e	ca		dex		   DEX               ; decrement count
.e57f	10 fa		bpl $e57b	   BPL ClSc_30       ; loop if more to do
.e581					  Do_Home
.e581	a0 00		ldy #$00	   LDY #0
.e583	84 d3		sty $d3		   STY CSRIDX        ; clear cursor column
.e585	84 d6		sty $d6		   STY TBLX          ; clear cursor row
.e587					Adjust_Line
.e587	a6 d6		ldx $d6		   LDX TBLX          ; get cursor row
.e589	a5 d3		lda $d3		   LDA CSRIDX        ; get cursor column
.e58b					Home_10
.e58b	b4 d9		ldy $d9,x	   LDY SLLTBL,X      ; get start of line X pointer high byte
.e58d	30 08		bmi $e597	   BMI Home_20       ; continue if logical line start
.e58f	18		clc		   CLC               ; else clear carry for add
.e590	69 16		adc #$16	   ADC #COLS         ; add one line length
.e592	85 d3		sta $d3		   STA CSRIDX        ; save cursor column
.e594	ca		dex		   DEX               ; decrement cursor row
.e595	10 f4		bpl $e58b	   BPL Home_10       ; loop, branch always
.e597					Home_20
.e597	b5 d9		lda $d9,x	   LDA SLLTBL,X      ; get start of line X pointer high byte
.e599	29 03		and #$03	   AND #$03          ; mask 0000 00xx, line memory page
.e59b	0d 88 02	ora $0288	   ORA SCNMPG        ; OR with screen memory page
.e59e	85 d2		sta $d2		   STA LINPTR+1      ; set current screen line pointer high byte
.e5a0	bd fd ed	lda $edfd,x	   LDA Line_Adress_Low,X    ; get start of line low byte from ROM table
.e5a3	85 d1		sta $d1		   STA LINPTR        ; set current screen line pointer low byte
.e5a5	a9 15		lda #$15	   LDA #COLS-1       ; set line length
.e5a7	e8		inx		   INX               ; increment cursor row
.e5a8					Home_30
.e5a8	b4 d9		ldy $d9,x	   LDY SLLTBL,X      ; get start of line X pointer high byte
.e5aa	30 06		bmi $e5b2	   BMI Home_40       ; exit if logical line start
.e5ac	18		clc		   CLC               ; else clear carry for add
.e5ad	69 16		adc #$16	   ADC #COLS         ; add one line length to current line length
.e5af	e8		inx		   INX               ; increment cursor row
.e5b0	10 f6		bpl $e5a8	   BPL Home_30       ; loop, branch always
.e5b2					Home_40
.e5b2	85 d5		sta $d5		   STA LINLEN        ; save current screen line length
.e5b4	60		rts		   RTS
.e5b5	20 bb e5	jsr $e5bb	   JSR Set_Default_Devices
.e5b8	4c 81 e5	jmp $e581	   JMP Do_Home
.e5bb					  Set_Default_Devices
.e5bb	a9 03		lda #$03	   LDA #3            ; set screen
.e5bd	85 9a		sta $9a		   STA DFLTO         ; set output device number
.e5bf	a9 00		lda #$00	   LDA #0            ; set keyboard
.e5c1	85 99		sta $99		   STA DFLTN         ; set input device number
.e5c3					  Init_VIC_Chip
.e5c3	a2 10		ldx #$10	   LDX #VIC_REGS
.e5c5					IVC_Loop
.e5c5	bd e3 ed	lda $ede3,x	   LDA VIC_INIT-1,X  ; get byte from setup table
.e5c8	9d ff 8f	sta $8fff,x	   STA VIC_BASE-1,X  ; save byte to Vic chip
.e5cb	ca		dex		   DEX               ; decrement count/index
.e5cc	d0 f7		bne $e5c5	   BNE IVC_Loop      ; loop if more to do
.e5ce	60		rts		   RTS
.e5cf					  Get_Char_From_Keyboard_Buffer
.e5cf	ac 77 02	ldy $0277	   LDY KBUFFR        ; get current character from buffer
.e5d2	a2 00		ldx #$00	   LDX #0
.e5d4					GCFK_Loop
.e5d4	bd 78 02	lda $0278,x	   LDA KBUFFR+1,X    ; get next character,X from buffer
.e5d7	9d 77 02	sta $0277,x	   STA KBUFFR,X      ; save as current character,X in buffer
.e5da	e8		inx		   INX               ; increment index
.e5db	e4 c6		cpx $c6		   CPX NDX           ; compare with keyboard buffer index
.e5dd	d0 f5		bne $e5d4	   BNE GCFK_Loop     ; loop if more to do
.e5df	c6 c6		dec $c6		   DEC NDX           ; decrement keyboard buffer index
.e5e1	98		tya		   TYA               ; copy key to A
.e5e2	58		cli		   CLI               ; enable interrupts
.e5e3	18		clc		   CLC               ; flag got byte
.e5e4	60		rts		   RTS
.e5e5					  Display_And_Get_Key
.e5e5	20 42 e7	jsr $e742	   JSR Screen_CHROUT ; output character
.e5e8					  Get_Key
.e5e8	a5 c6		lda $c6		   LDA NDX           ; get keyboard buffer index
.e5ea	85 cc		sta $cc		   STA BLNSW         ; cursor enable, $00 = flash cursor, $xx = no flash
.e5ec	8d 92 02	sta $0292	   STA AUTODN        ; screen scrolling flag, $00 = scroll, $xx = no scroll
.e5ef	f0 f7		beq $e5e8	   BEQ Get_Key       ; loop if buffer empty
.e5f1	78		sei		   SEI               ; disable interrupts
.e5f2	a5 cf		lda $cf		   LDA BLNON         ; get cursor blink phase
.e5f4	f0 0c		beq $e602	   BEQ GETK_10       ; branch if cursor phase
.e5f6	a5 ce		lda $ce		   LDA GDBLN         ; get character under cursor
.e5f8	ae 87 02	ldx $0287	   LDX CSRCLR        ; get colour under cursor
.e5fb	a0 00		ldy #$00	   LDY #$00          ; clear Y
.e5fd	84 cf		sty $cf		   STY BLNON         ; clear cursor blink phase
.e5ff	20 a1 ea	jsr $eaa1	   JSR Display_Char_A_And_Color_X
.e602					GETK_10
.e602	20 cf e5	jsr $e5cf	   JSR Get_Char_From_Keyboard_Buffer
.e605	c9 83		cmp #$83	   CMP #$83          ; compare with [SHIFT][RUN]
.e607	d0 10		bne $e619	   BNE GETK_30       ; branch if not [SHIFT][RUN]
.e609	a2 09		ldx #$09	   LDX #9            ; set byte count
.e60b	78		sei		   SEI               ; disable interrupts
.e60c	86 c6		stx $c6		   STX NDX           ; set keyboard buffer index
.e60e					GETK_20
.e60e	bd f3 ed	lda $edf3,x	   LDA RUNKEY-1,X    ; get byte from auto load/run table
.e611	9d 76 02	sta $0276,x	   STA KBUFFR-1,X    ; save to keyboard buffer
.e614	ca		dex		   DEX               ; decrement count/index
.e615	d0 f7		bne $e60e	   BNE GETK_20       ; loop while more to do
.e617	f0 cf		beq $e5e8	   BEQ Get_Key       ; loop for next key, branch always
.e619					GETK_30
.e619	c9 0d		cmp #$0d	   CMP #CR
.e61b	d0 c8		bne $e5e5	   BNE Display_And_Get_Key
.e61d	a4 d5		ldy $d5		   LDY LINLEN        ; get current screen line length
.e61f	84 d0		sty $d0		   STY INSRC         ; input from keyboard or screen, $xx = screen,
.e621					GETK_40
.e621	b1 d1		lda ($d1),y	   LDA (LINPTR),Y    ; get character from current screen line
.e623	c9 20		cmp #$20	   CMP #' '          ; compare with [SPACE]
.e625	d0 03		bne $e62a	   BNE GETK_50       ; branch if not [SPACE]
.e627	88		dey		   DEY               ; else eliminate the space, decrement end of input line
.e628	d0 f7		bne $e621	   BNE GETK_40       ; loop, branch always
.e62a					GETK_50
.e62a	c8		iny		   INY               ; increment past last non space character on line
.e62b	84 c8		sty $c8		   STY INDX          ; save input [EOL] pointer
.e62d	a0 00		ldy #$00	   LDY #0
.e62f	8c 92 02	sty $0292	   STY AUTODN        ; clear screen scrolling flag, $00 = scroll, $xx = no scroll
.e632	84 d3		sty $d3		   STY CSRIDX        ; clear cursor column
.e634	84 d4		sty $d4		   STY CSRMOD        ; clear cursor quote flag, $xx = quote, $00 = no quote
.e636	a5 c9		lda $c9		   LDA ICRROW        ; get input cursor row
.e638	30 1d		bmi $e657	   BMI Get_Screen
.e63a	a6 d6		ldx $d6		   LDX TBLX          ; get cursor row
.e63c	20 19 e7	jsr $e719	   JSR Set_Pointer_To_Start_Of_Logical_Row_X
.e63f	e4 c9		cpx $c9		   CPX ICRROW        ; compare with input cursor row
.e641	d0 14		bne $e657	   BNE Get_Screen
.e643	d0 12		bne $e657	   BNE Get_Screen    ; obsolete
.e645	a5 ca		lda $ca		   LDA ICRCOL        ; get input cursor column
.e647	85 d3		sta $d3		   STA CSRIDX        ; save cursor column
.e649	c5 c8		cmp $c8		   CMP INDX          ; compare with input [EOL] pointer
.e64b	90 0a		bcc $e657	   BCC Get_Screen    ; branch if less, cursor is in line
.e64d	b0 42		bcs $e691	   BCS GetS_20      ; else cursor is beyond the line end, branch always
.e64f					  CHRIN_Keyboard_Or_Screen
.e64f	98		tya		   TYA               ; copy Y
.e650	48		pha		   PHA               ; save Y
.e651	8a		txa		   TXA               ; copy X
.e652	48		pha		   PHA               ; save X
.e653	a5 d0		lda $d0		   LDA INSRC         ; input from keyboard or screen, $xx = screen,
.e655	f0 91		beq $e5e8	   BEQ Get_Key       ; if keyboard go wait for key
.e657					  Get_Screen
.e657	a4 d3		ldy $d3		   LDY CSRIDX        ; get cursor column
.e659	b1 d1		lda ($d1),y	   LDA (LINPTR),Y    ; get character from the current screen line
>e65b	ea ea ea ea ea ea ea ea		   .fill 23 ,$EA    ; NOP's
>e663	ea ea ea ea ea ea ea ea ea ea ea ea ea ea ea
.e672	85 d7		sta $d7		   STA LASTKY        ; save temporary last character
.e674	29 3f		and #$3f	   AND #$3F          ; mask key bits
.e676	06 d7		asl $d7		   ASL LASTKY        ; << temporary last character
.e678	24 d7		bit $d7		   BIT LASTKY        ; test it
.e67a	10 02		bpl $e67e	   BPL GetS_05       ; branch if not [NO KEY]
.e67c	09 80		ora #$80	   ORA #$80
.e67e					GetS_05
.e67e	90 04		bcc $e684	   BCC GetS_10
.e680	a6 d4		ldx $d4		   LDX CSRMOD        ; get cursor quote flag, $xx = quote, $00 = no quote
.e682	d0 04		bne $e688	   BNE GetS_15       ; branch if in quote mode
.e684					GetS_10
.e684	70 02		bvs $e688	   BVS GetS_15
.e686	09 40		ora #$40	   ORA #$40
.e688					GetS_15
.e688	e6 d3		inc $d3		   INC CSRIDX        ; increment cursor column
.e68a	20 b8 e6	jsr $e6b8	   JSR If_Quote_Toggle_Flag
.e68d	c4 c8		cpy $c8		   CPY INDX          ; compare with input [EOL] pointer
.e68f	d0 17		bne $e6a8	   BNE GetS_35       ; branch if not at line end
.e691					GetS_20
.e691	a9 00		lda #$00	   LDA #$00
.e693	85 d0		sta $d0		   STA INSRC         ; clear input from keyboard or screen, $xx = screen,
.e695	a9 0d		lda #$0d	   LDA #$0D          ; set character [CR]
.e697	a6 99		ldx $99		   LDX DFLTN         ; get input device number
.e699	e0 03		cpx #$03	   CPX #$03          ; compare with screen
.e69b	f0 06		beq $e6a3	   BEQ GetS_25       ; branch if screen
.e69d	a6 9a		ldx $9a		   LDX DFLTO         ; get output device number
.e69f	e0 03		cpx #$03	   CPX #$03          ; compare with screen
.e6a1	f0 03		beq $e6a6	   BEQ GetS_30       ; branch if screen
.e6a3					GetS_25
.e6a3	20 42 e7	jsr $e742	   JSR Screen_CHROUT ; output character
.e6a6					GetS_30
.e6a6	a9 0d		lda #$0d	   LDA #$0D          ; set character [CR]
.e6a8					GetS_35
.e6a8	85 d7		sta $d7		   STA LASTKY        ; save character
.e6aa	68		pla		   PLA               ; pull X
.e6ab	aa		tax		   TAX               ; restore X
.e6ac	68		pla		   PLA               ; pull Y
.e6ad	a8		tay		   TAY               ; restore Y
.e6ae	a5 d7		lda $d7		   LDA LASTKY        ; restore character
.e6b0	c9 de		cmp #$de	   CMP #$DE
.e6b2	d0 02		bne $e6b6	   BNE GetS_40
.e6b4	a9 ff		lda #$ff	   LDA #$FF
.e6b6					GetS_40
.e6b6	18		clc		   CLC
.e6b7	60		rts		   RTS
.e6b8					  If_Quote_Toggle_Flag
.e6b8	c9 22		cmp #$22	   CMP #QUOTE
.e6ba	d0 08		bne $e6c4	   BNE IQTF_Ret      ; exit if not "
.e6bc	a5 d4		lda $d4		   LDA CSRMOD        ; get cursor quote flag, $xx = quote, $00 = no quote
.e6be	49 01		eor #$01	   EOR #1            ; toggle it
.e6c0	85 d4		sta $d4		   STA CSRMOD        ; save cursor quote flag
.e6c2	a9 22		lda #$22	   LDA #QUOTE
.e6c4					IQTF_Ret
.e6c4	60		rts		   RTS
.e6c5					  Insert_Char
.e6c5	09 40		ora #$40	   ORA #$40          ; change to uppercase/graphic
.e6c7					InsC_10
.e6c7	a6 c7		ldx $c7		   LDX RVS           ; get reverse flag
.e6c9	f0 02		beq $e6cd	   BEQ InsC_30       ; branch if not reverse
.e6cb					InsC_20
.e6cb	09 80		ora #$80	   ORA #$80          ; reverse character
.e6cd					InsC_30
.e6cd	a6 d8		ldx $d8		   LDX INSRTO        ; get insert count
.e6cf	f0 02		beq $e6d3	   BEQ InsC_40       ; branch if none
.e6d1	c6 d8		dec $d8		   DEC INSRTO        ; else decrement insert count
.e6d3					InsC_40
.e6d3	ae 86 02	ldx $0286	   LDX COLOR         ; get current colour code
.e6d6	20 a1 ea	jsr $eaa1	   JSR Display_Char_A_And_Color_X
.e6d9	20 ea e6	jsr $e6ea	   JSR Advance_Cursor
.e6dc					InsC_50
.e6dc	68		pla		   PLA               ; pull Y
.e6dd	a8		tay		   TAY               ; restore Y
.e6de	a5 d8		lda $d8		   LDA INSRTO        ; get insert count
.e6e0	f0 02		beq $e6e4	   BEQ InsC_60       ; skip quote flag clear if inserts to do
.e6e2	46 d4		lsr $d4		   LSR CSRMOD        ; clear cursor quote flag, $xx = quote, $00 = no quote
.e6e4					InsC_60
.e6e4	68		pla		   PLA               ; pull X
.e6e5	aa		tax		   TAX               ; restore X
.e6e6	68		pla		   PLA               ; restore A
.e6e7	18		clc		   CLC
.e6e8	58		cli		   CLI               ; enable interrupts
.e6e9	60		rts		   RTS
.e6ea					  Advance_Cursor
.e6ea	20 fa e8	jsr $e8fa	   JSR Test_Line_Inc
.e6ed	e6 d3		inc $d3		   INC CSRIDX        ; increment cursor column
.e6ef	a5 d5		lda $d5		   LDA LINLEN        ; get current screen line length
.e6f1	c5 d3		cmp $d3		   CMP CSRIDX        ; compare with cursor column
.e6f3	b0 37		bcs $e72c	   BCS SPTS_Ret      ; exit if line length >= cursor column
.e6f5	c9 57		cmp #$57	   CMP #COLMAX-1     ; compare with max length
.e6f7	f0 2a		beq $e723	   BEQ SPTS_20       ; if at max clear column, back cursor up and do newline
.e6f9	ad 92 02	lda $0292	   LDA AUTODN        ; get autoscroll flag
.e6fc	f0 03		beq $e701	   BEQ AdCu_10       ; branch if autoscroll on
.e6fe	4c f0 e9	jmp $e9f0	   JMP InsL_10      ; else open space on screen
.e701					AdCu_10
.e701	a6 d6		ldx $d6		   LDX TBLX          ; get cursor row
.e703	e0 17		cpx #$17	   CPX #ROWS         ; compare with max + 1
.e705	90 07		bcc $e70e	   BCC Expand_Logical_Line
.e707	20 75 e9	jsr $e975	   JSR Scroll_Screen
.e70a	c6 d6		dec $d6		   DEC TBLX          ; decrement cursor row
.e70c	a6 d6		ldx $d6		   LDX TBLX          ; get cursor row
.e70e					  Expand_Logical_Line
.e70e	16 d9		asl $d9,x	   ASL SLLTBL,X      ; shift start of line X pointer high byte
.e710	56 d9		lsr $d9,x	   LSR SLLTBL,X      ; clears bit 7
.e712	4c 5b ed	jmp $ed5b	   JMP ELL_10        ; make next screen line start of logical line, increment
.e715					ELL_20
.e715	69 16		adc #$16	   ADC #COLS         ; add one line length
.e717	85 d5		sta $d5		   STA LINLEN        ; save current screen line length
.e719					  Set_Pointer_To_Start_Of_Logical_Row_X
.e719	b5 d9		lda $d9,x	   LDA SLLTBL,X      ; get start of line X pointer high byte
.e71b	30 03		bmi $e720	   BMI SPTS_10       ; exit loop if start of logical line
.e71d	ca		dex		   DEX               ; else back up one line
.e71e	d0 f9		bne $e719	   BNE Set_Pointer_To_Start_Of_Logical_Row_X
.e720					SPTS_10
.e720	4c 7e ea	jmp $ea7e	   JMP Start_Of_Line
.e723					SPTS_20
.e723	c6 d6		dec $d6		   DEC TBLX          ; decrement cursor row. if the cursor was incremented past
.e725	20 c3 e8	jsr $e8c3	   JSR Do_Newline
.e728	a9 00		lda #$00	   LDA #0
.e72a	85 d3		sta $d3		   STA CSRIDX        ; clear cursor column
.e72c					SPTS_Ret
.e72c	60		rts		   RTS
.e72d					  Previous_Line
.e72d	a6 d6		ldx $d6		   LDX TBLX          ; get cursor row
.e72f	d0 06		bne $e737	   BNE PreL_10       ; branch if not top row
.e731	86 d3		stx $d3		   STX CSRIDX        ; clear cursor column
.e733	68		pla		   PLA               ; dump return address low byte
.e734	68		pla		   PLA               ; dump return address high byte
.e735	d0 a5		bne $e6dc	   BNE InsC_50       ; restore registers, set quote flag and exit, branch always
.e737					PreL_10
.e737	ca		dex		   DEX               ; decrement cursor row
.e738	86 d6		stx $d6		   STX TBLX          ; save cursor row
.e73a	20 87 e5	jsr $e587	   JSR Adjust_Line   ; set screen pointers for cursor row, column
.e73d	a4 d5		ldy $d5		   LDY LINLEN        ; get current screen line length
.e73f	84 d3		sty $d3		   STY CSRIDX        ; save as cursor column
.e741	60		rts		   RTS
.e742					  Screen_CHROUT
.e742	48		pha		   PHA               ; save character
.e743	85 d7		sta $d7		   STA LASTKY        ; save temporary last character
.e745	8a		txa		   TXA               ; copy X
.e746	48		pha		   PHA               ; save X
.e747	98		tya		   TYA               ; copy Y
.e748	48		pha		   PHA               ; save Y
.e749	a9 00		lda #$00	   LDA #0
.e74b	85 d0		sta $d0		   STA INSRC         ; clear input from keyboard or screen, $xx = screen,
.e74d	a4 d3		ldy $d3		   LDY CSRIDX        ; get cursor column
.e74f	a5 d7		lda $d7		   LDA LASTKY        ; restore last character
.e751	10 03		bpl $e756	   BPL ScrO_02       ; branch if unshifted
.e753	4c 00 e8	jmp $e800	   JMP ScrO_42       ; do shifted characters and return
.e756					ScrO_02
.e756	c9 0d		cmp #$0d	   CMP #$0D          ; compare with [CR]
.e758	d0 03		bne $e75d	   BNE ScrO_04       ; branch if not [CR]
.e75a	4c d8 e8	jmp $e8d8	   JMP Screen_Return
.e75d					ScrO_04
.e75d	c9 20		cmp #$20	   CMP #' '          ; compare with [SPACE]
.e75f	90 10		bcc $e771	   BCC ScrO_10       ; branch if < [SPACE]
.e761	c9 60		cmp #$60	   CMP #$60
.e763	90 04		bcc $e769	   BCC ScrO_06       ; branch if $20 to $5F
.e765	29 df		and #$df	   AND #$DF
.e767	d0 02		bne $e76b	   BNE ScrO_08
.e769					ScrO_06
.e769	29 3f		and #$3f	   AND #$3F
.e76b					ScrO_08
.e76b	20 b8 e6	jsr $e6b8	   JSR If_Quote_Toggle_Flag
.e76e	4c c7 e6	jmp $e6c7	   JMP InsC_10
.e771					ScrO_10
.e771	a6 d8		ldx $d8		   LDX INSRTO        ; get insert count
.e773	f0 03		beq $e778	   BEQ ScrO_12       ; branch if no characters to insert
.e775	4c cb e6	jmp $e6cb	   JMP InsC_20       ; insert reversed character
.e778					ScrO_12
.e778	c9 14		cmp #$14	   CMP #$14          ; compare with [INSERT]/[DELETE]
.e77a	d0 2e		bne $e7aa	   BNE ScrO_20       ; branch if not [INSERT]/[DELETE]
.e77c	98		tya		   TYA
.e77d	d0 06		bne $e785	   BNE ScrO_14
.e77f	20 2d e7	jsr $e72d	   JSR Previous_Line
.e782	4c 9f e7	jmp $e79f	   JMP ScrO_18
.e785					ScrO_14
.e785	20 e8 e8	jsr $e8e8	   JSR Test_Line_Dec
.e788	88		dey		   DEY               ; decrement index to previous character
.e789	84 d3		sty $d3		   STY CSRIDX        ; save cursor column
.e78b	20 b2 ea	jsr $eab2	   JSR Set_COLRAM_Pointer
.e78e					ScrO_16
.e78e	c8		iny		   INY
.e78f	b1 d1		lda ($d1),y	   LDA (LINPTR),Y    ; get character from current screen line
.e791	88		dey		   DEY               ; decrement index to previous character
.e792	91 d1		sta ($d1),y	   STA (LINPTR),Y    ; save character to current screen line
.e794	c8		iny		   INY
.e795	b1 f3		lda ($f3),y	   LDA (USER),Y      ; get colour RAM byte
.e797	88		dey		   DEY               ; decrement index to previous character
.e798	91 f3		sta ($f3),y	   STA (USER),Y      ; save colour RAM byte
.e79a	c8		iny		   INY
.e79b	c4 d5		cpy $d5		   CPY LINLEN        ; compare with current screen line length
.e79d	d0 ef		bne $e78e	   BNE ScrO_16       ; loop if not there yet
.e79f					ScrO_18
.e79f	a9 20		lda #$20	   LDA #' '          ; set [SPACE]
.e7a1	91 d1		sta ($d1),y	   STA (LINPTR),Y    ; clear last character on current screen line
.e7a3	ad 86 02	lda $0286	   LDA COLOR         ; get current colour code
.e7a6	91 f3		sta ($f3),y	   STA (USER),Y      ; save to colour RAM
.e7a8	10 4d		bpl $e7f7	   BPL ScrO_38       ; branch always
.e7aa					ScrO_20
.e7aa	a6 d4		ldx $d4		   LDX CSRMOD        ; get cursor quote flag, $xx = quote, $00 = no quote
.e7ac	f0 03		beq $e7b1	   BEQ ScrO_22       ; branch if not quote mode
.e7ae	4c cb e6	jmp $e6cb	   JMP InsC_20       ; insert reversed character
.e7b1					ScrO_22
.e7b1	c9 12		cmp #$12	   CMP #$12          ; compare with [RVS ON]
.e7b3	d0 02		bne $e7b7	   BNE ScrO_24       ; branch if not [RVS ON]
.e7b5	85 c7		sta $c7		   STA RVS           ; set reverse flag
.e7b7					ScrO_24
.e7b7	c9 13		cmp #$13	   CMP #$13          ; compare with [CLR HOME]
.e7b9	d0 03		bne $e7be	   BNE ScrO_26       ; branch if not [CLR HOME]
.e7bb	20 81 e5	jsr $e581	   JSR Do_Home
.e7be					ScrO_26
.e7be	c9 1d		cmp #$1d	   CMP #$1D          ; compare with [CURSOR RIGHT]
.e7c0	d0 17		bne $e7d9	   BNE ScrO_32       ; branch if not [CURSOR RIGHT]
.e7c2	c8		iny		   INY               ; increment cursor column
.e7c3	20 fa e8	jsr $e8fa	   JSR Test_Line_Inc
.e7c6	84 d3		sty $d3		   STY CSRIDX        ; save cursor column
.e7c8	88		dey		   DEY               ; decrement cursor column
.e7c9	c4 d5		cpy $d5		   CPY LINLEN        ; compare cursor column with current screen line length
.e7cb	90 09		bcc $e7d6	   BCC ScrO_30       ; exit if less
.e7cd	c6 d6		dec $d6		   DEC TBLX          ; decrement cursor row
.e7cf	20 c3 e8	jsr $e8c3	   JSR Do_Newline
.e7d2	a0 00		ldy #$00	   LDY #$00          ; clear cursor column
.e7d4					ScrO_28
.e7d4	84 d3		sty $d3		   STY CSRIDX        ; save cursor column
.e7d6					ScrO_30
.e7d6	4c dc e6	jmp $e6dc	   JMP InsC_50       ; restore registers, set quote flag and exit
.e7d9					ScrO_32
.e7d9	c9 11		cmp #$11	   CMP #$11          ; compare with [CURSOR DOWN]
.e7db	d0 1d		bne $e7fa	   BNE ScrO_40       ; branch if not [CURSOR DOWN]
.e7dd	18		clc		   CLC
.e7de	98		tya		   TYA               ; copy cursor column
.e7df	69 16		adc #$16	   ADC #COLS         ; add one line
.e7e1	a8		tay		   TAY               ; copy back to A
.e7e2	e6 d6		inc $d6		   INC TBLX          ; increment cursor row
.e7e4	c5 d5		cmp $d5		   CMP LINLEN        ; compare cursor column with current screen line length
.e7e6	90 ec		bcc $e7d4	   BCC ScrO_28       ; save cursor column and exit if less
.e7e8	f0 ea		beq $e7d4	   BEQ ScrO_28       ; save cursor column and exit if equal
.e7ea	c6 d6		dec $d6		   DEC TBLX          ; decrement cursor row
.e7ec					ScrO_34
.e7ec	e9 16		sbc #$16	   SBC #COLS         ; subtract one line
.e7ee	90 04		bcc $e7f4	   BCC ScrO_36       ; exit loop if on previous line
.e7f0	85 d3		sta $d3		   STA CSRIDX        ; else save cursor column
.e7f2	d0 f8		bne $e7ec	   BNE ScrO_34       ; loop if not at start of line
.e7f4					ScrO_36
.e7f4	20 c3 e8	jsr $e8c3	   JSR Do_Newline
.e7f7					ScrO_38
.e7f7	4c dc e6	jmp $e6dc	   JMP InsC_50       ; restore registers, set quote flag and exit
.e7fa					ScrO_40
.e7fa	20 12 e9	jsr $e912	   JSR Set_Color
.e7fd	4c 21 ed	jmp $ed21	   JMP Switch_Text_Graphics
.e800					ScrO_42
>e800	ea ea ea ea ea ea ea ea		   .fill 21 ,$EA    ; NOP's
>e808	ea ea ea ea ea ea ea ea ea ea ea ea ea
.e815	29 7f		and #$7f	   AND #$7F          ; mask 0xxx xxxx, clear b7
.e817	c9 7f		cmp #$7f	   CMP #$7F          ; was it $FF before the mask
.e819	d0 02		bne $e81d	   BNE ScrO_44       ; branch if not
.e81b	a9 5e		lda #$5e	   LDA #$5E          ; else make it $5E
.e81d					ScrO_44
.e81d	ea		nop		   NOP
.e81e	ea		nop		   NOP
.e81f	ea		nop		   NOP
.e820	ea		nop		   NOP
.e821	ea		nop		   NOP
.e822	ea		nop		   NOP
.e823	c9 20		cmp #$20	   CMP #' '          ; compare with [SPACE]
.e825	90 03		bcc $e82a	   BCC ScrO_46       ; branch if < [SPACE]
.e827	4c c5 e6	jmp $e6c5	   JMP Insert_Char
.e82a					ScrO_46
.e82a	c9 0d		cmp #$0d	   CMP #$0D          ; compare with [CR]
.e82c	d0 03		bne $e831	   BNE ScrO_48       ; branch if not [CR]
.e82e	4c d8 e8	jmp $e8d8	   JMP Screen_Return      ; else output [CR] and return
.e831					ScrO_48
.e831	a6 d4		ldx $d4		   LDX CSRMOD        ; get cursor quote flag, $xx = quote, $00 = no quote
.e833	d0 3f		bne $e874	   BNE ScrO_60       ; branch if quote mode
.e835	c9 14		cmp #$14	   CMP #$14          ; compare with [INSERT DELETE]
.e837	d0 37		bne $e870	   BNE ScrO_58       ; branch if not [INSERT DELETE]
.e839	a4 d5		ldy $d5		   LDY LINLEN        ; get current screen line length
.e83b	b1 d1		lda ($d1),y	   LDA (LINPTR),Y    ; get character from current screen line
.e83d	c9 20		cmp #$20	   CMP #' '          ; compare with [SPACE]
.e83f	d0 04		bne $e845	   BNE ScrO_50       ; branch if not [SPACE]
.e841	c4 d3		cpy $d3		   CPY CSRIDX        ; compare current column with cursor column
.e843	d0 07		bne $e84c	   BNE ScrO_52       ; if not cursor column go open up space on line
.e845					ScrO_50
.e845	c0 57		cpy #$57	   CPY #COLMAX-1     ; compare current column with max line length
.e847	f0 24		beq $e86d	   BEQ ScrO_56       ; exit if at line end
.e849	20 ee e9	jsr $e9ee	   JSR Insert_Line
.e84c					ScrO_52
.e84c	a4 d5		ldy $d5		   LDY LINLEN        ; get current screen line length
.e84e	20 b2 ea	jsr $eab2	   JSR Set_COLRAM_Pointer
.e851					ScrO_54
.e851	88		dey		   DEY               ; decrement index to previous character
.e852	b1 d1		lda ($d1),y	   LDA (LINPTR),Y    ; get character from current screen line
.e854	c8		iny		   INY
.e855	91 d1		sta ($d1),y	   STA (LINPTR),Y    ; save character to current screen line
.e857	88		dey		   DEY               ; decrement index to previous character
.e858	b1 f3		lda ($f3),y	   LDA (USER),Y      ; get current screen line colour RAM byte
.e85a	c8		iny		   INY
.e85b	91 f3		sta ($f3),y	   STA (USER),Y      ; save current screen line colour RAM byte
.e85d	88		dey		   DEY               ; decrement index to previous character
.e85e	c4 d3		cpy $d3		   CPY CSRIDX        ; compare with cursor column
.e860	d0 ef		bne $e851	   BNE ScrO_54       ; loop if not there yet
.e862	a9 20		lda #$20	   LDA #' '          ; set [SPACE]
.e864	91 d1		sta ($d1),y	   STA (LINPTR),Y    ; clear character at cursor position on current screen line
.e866	ad 86 02	lda $0286	   LDA COLOR         ; get current colour code
.e869	91 f3		sta ($f3),y	   STA (USER),Y      ; save to cursor position on current screen line colour RAM
.e86b	e6 d8		inc $d8		   INC INSRTO        ; increment insert count
.e86d					ScrO_56
.e86d	4c dc e6	jmp $e6dc	   JMP InsC_50       ; restore registers, set quote flag and exit
.e870					ScrO_58
.e870	a6 d8		ldx $d8		   LDX INSRTO        ; get insert count
.e872	f0 05		beq $e879	   BEQ ScrO_62       ; branch if no insert space
.e874					ScrO_60
.e874	09 40		ora #$40	   ORA #$40          ; change to uppercase/graphic
.e876	4c cb e6	jmp $e6cb	   JMP InsC_20       ; insert reversed character
.e879					ScrO_62
.e879	c9 11		cmp #$11	   CMP #$11          ; compare with [CURSOR UP]
.e87b	d0 16		bne $e893	   BNE ScrO_66       ; branch if not [CURSOR UP]
.e87d	a6 d6		ldx $d6		   LDX TBLX          ; get cursor row
.e87f	f0 37		beq $e8b8	   BEQ ScrO_74       ; branch if on top line
.e881	c6 d6		dec $d6		   DEC TBLX          ; decrement cursor row
.e883	a5 d3		lda $d3		   LDA CSRIDX        ; get cursor column
.e885	38		sec		   SEC
.e886	e9 16		sbc #$16	   SBC #COLS         ; subtract one line length
.e888	90 04		bcc $e88e	   BCC ScrO_64       ; branch if stepped back to previous line
.e88a	85 d3		sta $d3		   STA CSRIDX        ; else save cursor column ..
.e88c	10 2a		bpl $e8b8	   BPL ScrO_74       ; .. and exit, branch always
.e88e					ScrO_64
.e88e	20 87 e5	jsr $e587	   JSR Adjust_Line   ; set screen pointers for cursor row, column ..
.e891	d0 25		bne $e8b8	   BNE ScrO_74       ; .. and exit, branch always
.e893					ScrO_66
.e893	c9 12		cmp #$12	   CMP #$12          ; compare with [RVS OFF]
.e895	d0 04		bne $e89b	   BNE ScrO_68       ; branch if not [RVS OFF]
.e897	a9 00		lda #$00	   LDA #0
.e899	85 c7		sta $c7		   STA RVS           ; clear reverse flag
.e89b					ScrO_68
.e89b	c9 1d		cmp #$1d	   CMP #$1D          ; compare with [CURSOR LEFT]
.e89d	d0 12		bne $e8b1	   BNE ScrO_72       ; branch if not [CURSOR LEFT]
.e89f	98		tya		   TYA               ; copy cursor column
.e8a0	f0 09		beq $e8ab	   BEQ ScrO_70       ; branch if at start of line
.e8a2	20 e8 e8	jsr $e8e8	   JSR Test_Line_Dec
.e8a5	88		dey		   DEY               ; decrement cursor column
.e8a6	84 d3		sty $d3		   STY CSRIDX        ; save cursor column
.e8a8	4c dc e6	jmp $e6dc	   JMP InsC_50       ; restore registers, set quote flag and exit
.e8ab					ScrO_70
.e8ab	20 2d e7	jsr $e72d	   JSR Previous_Line
.e8ae	4c dc e6	jmp $e6dc	   JMP InsC_50       ; restore registers, set quote flag and exit
.e8b1					ScrO_72
.e8b1	c9 13		cmp #$13	   CMP #$13          ; compare with [CLR]
.e8b3	d0 06		bne $e8bb	   BNE ScrO_76       ; branch if not [CLR]
.e8b5	20 5f e5	jsr $e55f	   JSR Clear_Screen
.e8b8					ScrO_74
.e8b8	4c dc e6	jmp $e6dc	   JMP InsC_50       ; restore registers, set quote flag and exit
.e8bb					ScrO_76
.e8bb	09 80		ora #$80	   ORA #$80          ; restore b7, colour can only be black, cyan, magenta
.e8bd	20 12 e9	jsr $e912	   JSR Set_Color
.e8c0	4c 30 ed	jmp $ed30	   JMP STG_10
.e8c3					  Do_Newline
.e8c3	46 c9		lsr $c9		   LSR ICRROW        ; shift >> input cursor row
.e8c5	a6 d6		ldx $d6		   LDX TBLX          ; get cursor row
.e8c7					NewL_10
.e8c7	e8		inx		   INX               ; increment row
.e8c8	e0 17		cpx #$17	   CPX #ROWS         ; compare with last row + 1
.e8ca	d0 03		bne $e8cf	   BNE NewL_20       ; branch if not last row + 1
.e8cc	20 75 e9	jsr $e975	   JSR Scroll_Screen
.e8cf					NewL_20
.e8cf	b5 d9		lda $d9,x	   LDA SLLTBL,X      ; get start of line X pointer high byte
.e8d1	10 f4		bpl $e8c7	   BPL NewL_10       ; loop if not start of logical line
.e8d3	86 d6		stx $d6		   STX TBLX          ; else save cursor row
.e8d5	4c 87 e5	jmp $e587	   JMP Adjust_Line   ; set screen pointers for cursor row, column and return
.e8d8					  Screen_Return
.e8d8	a2 00		ldx #$00	   LDX #0
.e8da	86 d8		stx $d8		   STX INSRTO        ; clear insert count
.e8dc	86 c7		stx $c7		   STX RVS           ; clear reverse flag
.e8de	86 d4		stx $d4		   STX CSRMOD        ; clear cursor quote flag, $xx = quote, $00 = no quote
.e8e0	86 d3		stx $d3		   STX CSRIDX        ; clear cursor column
.e8e2	20 c3 e8	jsr $e8c3	   JSR Do_Newline
.e8e5	4c dc e6	jmp $e6dc	   JMP InsC_50      ; restore registers, set quote flag and exit
.e8e8					  Test_Line_Dec
.e8e8	a2 04		ldx #$04	   LDX #COLINK       ; set count
.e8ea	a9 00		lda #$00	   LDA #$00          ; set column
.e8ec					TLD_10
.e8ec	c5 d3		cmp $d3		   CMP CSRIDX        ; compare with cursor column
.e8ee	f0 07		beq $e8f7	   BEQ TLD_20        ; branch if at start of line
.e8f0	18		clc		   CLC               ; else clear carry for add
.e8f1	69 16		adc #$16	   ADC #COLS         ; increment to next line
.e8f3	ca		dex		   DEX               ; decrement loop count
.e8f4	d0 f6		bne $e8ec	   BNE TLD_10        ; loop if more to test
.e8f6	60		rts		   RTS
.e8f7					TLD_20
.e8f7	c6 d6		dec $d6		   DEC TBLX          ; else decrement cursor row
.e8f9	60		rts		   RTS
.e8fa					  Test_Line_Inc
.e8fa	a2 04		ldx #$04	   LDX #COLINK       ; set count
.e8fc	a9 15		lda #$15	   LDA #COLS-1       ; set column
.e8fe					TLI_10
.e8fe	c5 d3		cmp $d3		   CMP CSRIDX        ; compare with cursor column
.e900	f0 07		beq $e909	   BEQ TLI_20        ; if at end of line test and possibly increment cursor row
.e902	18		clc		   CLC               ; else clear carry for add
.e903	69 16		adc #$16	   ADC #COLS         ; increment to next line
.e905	ca		dex		   DEX               ; decrement loop count
.e906	d0 f6		bne $e8fe	   BNE TLI_10        ; loop if more to test
.e908	60		rts		   RTS
.e909					TLI_20
.e909	a6 d6		ldx $d6		   LDX TBLX          ; get cursor row
.e90b	e0 17		cpx #$17	   CPX #ROWS
.e90d	f0 02		beq $e911	   BEQ TLI_30        ; exit if end of screen
.e90f	e6 d6		inc $d6		   INC TBLX          ; else increment cursor row
.e911					TLI_30
.e911	60		rts		   RTS
.e912					  Set_Color
.e912	a2 07		ldx #$07	   LDX #Color_Codes_End-Color_Codes-1
.e914					SeCo_Loop
.e914	dd 21 e9	cmp $e921,x	   CMP Color_Codes,X ; compare the character with the table code
.e917	f0 04		beq $e91d	   BEQ SeCo_10       ; if a match go save the colour and exit
.e919	ca		dex		   DEX               ; else decrement the index
.e91a	10 f8		bpl $e914	   BPL SeCo_Loop     ; loop if more to do
.e91c	60		rts		   RTS
.e91d					SeCo_10
.e91d	8e 86 02	stx $0286	   STX COLOR         ; set current colour code
.e920	60		rts		   RTS
.e921					Color_Codes
>e921	90				   .byte $90         ; black
>e922	05				   .byte $05         ; white
>e923	1c				   .byte $1C         ; red
>e924	9f				   .byte $9F         ; cyan
>e925	9c				   .byte $9C         ; magenta
>e926	1e				   .byte $1E         ; green
>e927	1f				   .byte $1F         ; blue
>e928	9e				   .byte $9E         ; yellow
.e929					Color_Codes_End
>e929	ef a1 df a6 e1 b1 e2 b2		   .byte   $EF,$A1,$DF,$A6,$E1,$B1,$E2,$B2,$E3,$B3,$E4,$B4,$E5,$B5,$E6,$B6
>e931	e3 b3 e4 b4 e5 b5 e6 b6
>e939	e7 b7 e8 b8 e9 b9 fa ba		   .byte   $E7,$B7,$E8,$B8,$E9,$B9,$FA,$BA,$FB,$BB,$FC,$BC,$EC,$BD,$FE,$BE
>e941	fb bb fc bc ec bd fe be
>e949	84 bf f7 c0 f8 db f9 dd		   .byte   $84,$BF,$F7,$C0,$F8,$DB,$F9,$DD,$EA,$DE,$5E,$E0,$5B,$E1,$5D,$E2
>e951	ea de 5e e0 5b e1 5d e2
>e959	40 b0 61 b1 78 db 79 dd		   .byte   $40,$B0,$61,$B1,$78,$DB,$79,$DD,$66,$B6,$77,$C0,$70,$F0,$71,$F1
>e961	66 b6 77 c0 70 f0 71 f1
>e969	72 f2 73 f3 74 f4 75 f5		   .byte   $72,$F2,$73,$F3,$74,$F4,$75,$F5,$76,$F6,$7D,$FD
>e971	76 f6 7d fd
.e975					  Scroll_Screen
.e975	a5 ac		lda $ac		   LDA SAL           ; save SAL & EAL
.e977	48		pha		   PHA
.e978	a5 ad		lda $ad		   LDA SAL+1
.e97a	48		pha		   PHA
.e97b	a5 ae		lda $ae		   LDA EAL
.e97d	48		pha		   PHA
.e97e	a5 af		lda $af		   LDA EAL+1
.e980	48		pha		   PHA
.e981					ScSc_05
.e981	a2 ff		ldx #$ff	   LDX #-1           ; set for pre increment loop
.e983	c6 d6		dec $d6		   DEC TBLX          ; decrement cursor row
.e985	c6 c9		dec $c9		   DEC ICRROW        ; decrement input cursor row
.e987	c6 f2		dec $f2		   DEC SCROWM        ; decrement screen row marker
.e989					ScSc_10
.e989	e8		inx		   INX               ; increment line number
.e98a	20 7e ea	jsr $ea7e	   JSR Start_Of_Line
.e98d	e0 16		cpx #$16	   CPX #ROWS-1       ; compare with last line
.e98f	b0 0c		bcs $e99d	   BCS ScSc_15       ; branch if on last line
.e991	bd fe ed	lda $edfe,x	   LDA Line_Adress_Low+1,X
.e994	85 ac		sta $ac		   STA SAL           ; save next line pointer low byte
.e996	b5 da		lda $da,x	   LDA SLLTBL+1,X    ; get start of next line pointer high byte
.e998	20 56 ea	jsr $ea56	   JSR Shift_Row
.e99b	30 ec		bmi $e989	   BMI ScSc_10       ; loop, branch always
.e99d					ScSc_15
.e99d	20 8d ea	jsr $ea8d	   JSR Clear_Screen_Row_X
.e9a0	a2 00		ldx #$00	   LDX #0
.e9a2					ScSc_20
.e9a2	b5 d9		lda $d9,x	   LDA SLLTBL,X      ; get start of line X pointer high byte
.e9a4	29 7f		and #$7f	   AND #$7F          ; clear line X start of logical line bit
.e9a6	b4 da		ldy $da,x	   LDY SLLTBL+1,X    ; get start of next line pointer high byte
.e9a8	10 02		bpl $e9ac	   BPL ScSc_25       ; branch if next line not start of line
.e9aa	09 80		ora #$80	   ORA #$80          ; set line X start of logical line bit
.e9ac					ScSc_25
.e9ac	95 d9		sta $d9,x	   STA SLLTBL,X      ; set start of line X pointer high byte
.e9ae	e8		inx		   INX               ; increment line number
.e9af	e0 16		cpx #$16	   CPX #ROWS-1       ; compare with last line
.e9b1	d0 ef		bne $e9a2	   BNE ScSc_20       ; loop if not last line
.e9b3	a5 ef		lda $ef		   LDA SLLTBL+ROWS-1 ; get start of last line pointer high byte
.e9b5	09 80		ora #$80	   ORA #$80          ; mark as start of logical line
.e9b7	85 ef		sta $ef		   STA SLLTBL+ROWS-1 ; set start of last line pointer high byte
.e9b9	a5 d9		lda $d9		   LDA SLLTBL        ; get start of first line pointer high byte
.e9bb	10 c4		bpl $e981	   BPL ScSc_05       ; if not start of logical line loop back and
.e9bd	e6 d6		inc $d6		   INC TBLX          ; increment cursor row
.e9bf	e6 f2		inc $f2		   INC SCROWM        ; increment screen row marker
.e9c1					ScSc_27
.e9c1	a9 fb		lda #$fb	   LDA #CTRL_COL     ; set keyboard column for [CTRL]key
.e9c3	8d 20 91	sta $9120	   STA KEYB_COL      ; set VIA/CIA keyboard column
.e9c6	ad 21 91	lda $9121	   LDA KEYB_ROW      ; get VIA/CIA keyboard row
.e9c9	c9 fe		cmp #$fe	   CMP #CTRL_ROW     ; compare with row of [CTRL] key
.e9cb	08		php		   PHP               ; save status
.e9cc	a9 f7		lda #$f7	   LDA #STND_COL     ; set standard keyboard col
.e9ce	8d 20 91	sta $9120	   STA KEYB_COL      ; set VIA/CIA keyboard column
.e9d1	28		plp		   PLP               ; restore status
.e9d2	d0 0b		bne $e9df	   BNE ScSc_40       ; skip if no [CTRL]key down
.e9d4	a0 00		ldy #$00	   LDY #0            ; delay scrolling if [CTRL]key down
.e9d6					ScSc_30
.e9d6	ea		nop		   NOP               ; waste cycles
.e9d7	ca		dex		   DEX               ; decrement inner loop count
.e9d8	d0 fc		bne $e9d6	   BNE ScSc_30       ; loop if not all done
.e9da	88		dey		   DEY               ; decrement outer loop count
.e9db	d0 f9		bne $e9d6	   BNE ScSc_30       ; loop if not all done
.e9dd	84 c6		sty $c6		   STY NDX           ; clear keyboard buffer index
.e9df					ScSc_40
.e9df	a6 d6		ldx $d6		   LDX TBLX          ; get cursor row
.e9e1					ScSc_45
.e9e1	68		pla		   PLA               ; restore EAL & SAL
.e9e2	85 af		sta $af		   STA EAL+1
.e9e4	68		pla		   PLA
.e9e5	85 ae		sta $ae		   STA EAL
.e9e7	68		pla		   PLA
.e9e8	85 ad		sta $ad		   STA SAL+1
.e9ea	68		pla		   PLA
.e9eb	85 ac		sta $ac		   STA SAL
.e9ed	60		rts		   RTS
.e9ee					  Insert_Line
.e9ee	a6 d6		ldx $d6		   LDX TBLX          ; get cursor row
.e9f0					InsL_10
.e9f0	e8		inx		   INX               ; increment row
.e9f1	b5 d9		lda $d9,x	   LDA SLLTBL,X      ; get start of line X pointer high byte
.e9f3	10 fb		bpl $e9f0	   BPL InsL_10       ; branch if not start of logical line
.e9f5	86 f2		stx $f2		   STX SCROWM        ; set screen row marker
.e9f7	e0 16		cpx #$16	   CPX #ROWS-1       ; compare with last line
.e9f9	f0 0d		beq $ea08	   BEQ InsL_20       ; branch if = last line
.e9fb	90 0b		bcc $ea08	   BCC InsL_20       ; branch if < last line
.e9fd	20 75 e9	jsr $e975	   JSR Scroll_Screen
.ea00	a6 f2		ldx $f2		   LDX SCROWM        ; get screen row marker
.ea02	ca		dex		   DEX               ; decrement screen row marker
.ea03	c6 d6		dec $d6		   DEC TBLX          ; decrement cursor row
.ea05	4c 0e e7	jmp $e70e	   JMP Expand_Logical_Line
.ea08					InsL_20
.ea08	a5 ac		lda $ac		   LDA SAL           ; copy tape buffer pointer
.ea0a	48		pha		   PHA               ; save it
.ea0b	a5 ad		lda $ad		   LDA SAL+1         ; copy tape buffer pointer
.ea0d	48		pha		   PHA               ; save it
.ea0e	a5 ae		lda $ae		   LDA EAL           ; copy tape buffer end pointer
.ea10	48		pha		   PHA               ; save it
.ea11	a5 af		lda $af		   LDA EAL+1         ; copy tape buffer end pointer
.ea13	48		pha		   PHA               ; save it
.ea14	a2 17		ldx #$17	   LDX #ROWS         ; set to end line + 1 for predecrement loop
.ea16					InsL_30
.ea16	ca		dex		   DEX               ; decrement line number
.ea17	20 7e ea	jsr $ea7e	   JSR Start_Of_Line
.ea1a	e4 f2		cpx $f2		   CPX SCROWM        ; compare with screen row marker
.ea1c	90 0e		bcc $ea2c	   BCC InsL_40       ; branch if < screen row marker
.ea1e	f0 0c		beq $ea2c	   BEQ InsL_40       ; branch if = screen row marker
.ea20	bd fc ed	lda $edfc,x	   LDA Line_Adress_Low-1,X  ; else get start of previous line low byte from ROM table
.ea23	85 ac		sta $ac		   STA SAL           ; save previous line pointer low byte
.ea25	b5 d8		lda $d8,x	   LDA SLLTBL-1,X    ; get start of previous line pointer high byte
.ea27	20 56 ea	jsr $ea56	   JSR Shift_Row
.ea2a	30 ea		bmi $ea16	   BMI InsL_30       ; loop, branch always
.ea2c					InsL_40
.ea2c	20 8d ea	jsr $ea8d	   JSR Clear_Screen_Row_X
.ea2f	a2 15		ldx #$15	   LDX #ROWS-2
.ea31					InsL_50
.ea31	e4 f2		cpx $f2		   CPX SCROWM        ;.compare with screen row marker
.ea33	90 0f		bcc $ea44	   BCC InsL_70
.ea35	b5 da		lda $da,x	   LDA SLLTBL+1,X
.ea37	29 7f		and #$7f	   AND #$7F
.ea39	b4 d9		ldy $d9,x	   LDY SLLTBL,X
.ea3b	10 02		bpl $ea3f	   BPL InsL_60
.ea3d	09 80		ora #$80	   ORA #$80
.ea3f					InsL_60
.ea3f	95 da		sta $da,x	   STA SLLTBL+1,X
.ea41	ca		dex		   DEX
.ea42	d0 ed		bne $ea31	   BNE InsL_50
.ea44					InsL_70
.ea44	a6 f2		ldx $f2		   LDX SCROWM        ;.get screen row marker
.ea46	20 0e e7	jsr $e70e	   JSR Expand_Logical_Line
.ea49	68		pla		   PLA               ; pull tape buffer end pointer
.ea4a	85 af		sta $af		   STA EAL+1         ; restore it
.ea4c	68		pla		   PLA               ; pull tape buffer end pointer
.ea4d	85 ae		sta $ae		   STA EAL           ; restore it
.ea4f	68		pla		   PLA               ; pull tape buffer pointer
.ea50	85 ad		sta $ad		   STA SAL+1         ; restore it
.ea52	68		pla		   PLA               ; pull tape buffer pointer
.ea53	85 ac		sta $ac		   STA SAL           ; restore it
.ea55	60		rts		   RTS
.ea56					  Shift_Row
.ea56	29 03		and #$03	   AND #$03          ; mask 0000 00xx, line memory page
.ea58	0d 88 02	ora $0288	   ORA SCNMPG        ; OR with screen memory page
.ea5b	85 ad		sta $ad		   STA SAL+1         ; save next/previous line pointer high byte
.ea5d	20 6e ea	jsr $ea6e	   JSR Update_Color_RAM_Pointer
.ea60					ShRo_10
.ea60	a0 15		ldy #$15	   LDY #COLS-1       ; set column count
.ea62					ShRo_20
.ea62	b1 ac		lda ($ac),y	   LDA (SAL),Y       ; get character from next/previous screen line
.ea64	91 d1		sta ($d1),y	   STA (LINPTR),Y    ; save character to current screen line
.ea66	b1 ae		lda ($ae),y	   LDA (EAL),Y       ; get colour from next/previous screen line colour RAM
.ea68	91 f3		sta ($f3),y	   STA (USER),Y      ; save colour to current screen line colour RAM
.ea6a	88		dey		   DEY               ; decrement column index/count
.ea6b	10 f5		bpl $ea62	   BPL ShRo_20
.ea6d	60		rts		   RTS
.ea6e					  Update_Color_RAM_Pointer
.ea6e	20 b2 ea	jsr $eab2	   JSR Set_COLRAM_Pointer
.ea71	a5 ac		lda $ac		   LDA SAL
.ea73	85 ae		sta $ae		   STA EAL
.ea75	a5 ad		lda $ad		   LDA SAL+1
.ea77	29 03		and #$03	   AND #$03
.ea79	09 94		ora #$94	   ORA #$94          ; VIC color RAM = $9400
.ea7b	85 af		sta $af		   STA EAL+1
.ea7d	60		rts		   RTS
.ea7e					  Start_Of_Line
.ea7e	bd fd ed	lda $edfd,x	   LDA Line_Adress_Low,X
.ea81	85 d1		sta $d1		   STA LINPTR        ; set current screen line pointer low byte
.ea83	b5 d9		lda $d9,x	   LDA SLLTBL,X      ; get start of line high byte from RAM table
.ea85	29 03		and #$03	   AND #$03          ; mask 0000 00xx, line memory page
.ea87	0d 88 02	ora $0288	   ORA SCNMPG        ; OR with screen memory page
.ea8a	85 d2		sta $d2		   STA LINPTR+1      ; set current screen line pointer high byte
.ea8c	60		rts		   RTS
.ea8d					  Clear_Screen_Row_X
.ea8d	a0 15		ldy #$15	   LDY #COLS-1       ; set number of columns to clear
.ea8f	20 7e ea	jsr $ea7e	   JSR Start_Of_Line
.ea92	20 b2 ea	jsr $eab2	   JSR Set_COLRAM_Pointer
.ea95					CSRX_Loop
.ea95	a9 20		lda #$20	   LDA #' '          ; set [SPACE]
.ea97	91 d1		sta ($d1),y	   STA (LINPTR),Y    ; clear character in current screen line
.ea99	a9 01		lda #$01	   LDA #1            ; set colour, blue on white
.ea9b	91 f3		sta ($f3),y	   STA (USER),Y      ; set colour RAM in current screen line
.ea9d	88		dey		   DEY
.ea9e	10 f5		bpl $ea95	   BPL CSRX_Loop
.eaa0	60		rts		   RTS
.eaa1					  Display_Char_A_And_Color_X
.eaa1	a8		tay		   TAY               ; copy character
.eaa2	a9 02		lda #$02	   LDA #$02          ; set count to $02, usually $14 ??
.eaa4	85 cd		sta $cd		   STA BLNCT         ; set cursor countdown
.eaa6	20 b2 ea	jsr $eab2	   JSR Set_COLRAM_Pointer
.eaa9	98		tya		   TYA               ; get character back
.eaaa					  Display_Char_And_Color
.eaaa	a4 d3		ldy $d3		   LDY CSRIDX        ; get cursor column
.eaac	91 d1		sta ($d1),y	   STA (LINPTR),Y    ; save character from current screen line
.eaae	8a		txa		   TXA               ; copy colour to A
.eaaf	91 f3		sta ($f3),y	   STA (USER),Y      ; save to colour RAM
.eab1	60		rts		   RTS
.eab2					  Set_COLRAM_Pointer
.eab2	a5 d1		lda $d1		   LDA LINPTR        ; get current screen line pointer low byte
.eab4	85 f3		sta $f3		   STA USER          ; save pointer to colour RAM low byte
.eab6	a5 d2		lda $d2		   LDA LINPTR+1      ; get current screen line pointer high byte
.eab8	29 03		and #$03	   AND #$03          ; mask 0000 00xx, line memory page
.eaba	09 94		ora #$94	   ORA #COLRAM_PAGE  ; set  1001 01xx, colour memory page
.eabc	85 f4		sta $f4		   STA USER+1        ; save pointer to colour RAM high byte
.eabe	60		rts		   RTS
.eabf					  Default_IRQ
.eabf	20 ea ff	jsr $ffea	   JSR UDTIM         ; Update the system clock
.eac2	a5 cc		lda $cc		   LDA BLNSW         ; get cursor enable
.eac4	d0 29		bne $eaef	   BNE DIRQ_20       ; branch if not flash cursor
.eac6	c6 cd		dec $cd		   DEC BLNCT         ; else decrement cursor timing countdown
.eac8	d0 25		bne $eaef	   BNE DIRQ_20       ; branch if not done
.eaca	a9 14		lda #$14	   LDA #$14          ; set count
.eacc	85 cd		sta $cd		   STA BLNCT         ; save cursor timing countdown
.eace	a4 d3		ldy $d3		   LDY CSRIDX        ; get cursor column
.ead0	46 cf		lsr $cf		   LSR BLNON         ; shift b0 cursor blink phase into carry
.ead2	ae 87 02	ldx $0287	   LDX CSRCLR        ; get colour under cursor
.ead5	b1 d1		lda ($d1),y	   LDA (LINPTR),Y    ; get character from current screen line
.ead7	b0 11		bcs $eaea	   BCS DIRQ_10       ; branch if cursor phase b0 was 1
.ead9	e6 cf		inc $cf		   INC BLNON         ; set cursor blink phase to 1
.eadb	85 ce		sta $ce		   STA GDBLN         ; save character under cursor
.eadd	20 b2 ea	jsr $eab2	   JSR Set_COLRAM_Pointer
.eae0	b1 f3		lda ($f3),y	   LDA (USER),Y      ; get colour RAM byte
.eae2	8d 87 02	sta $0287	   STA CSRCLR        ; save colour under cursor
.eae5	ae 86 02	ldx $0286	   LDX COLOR         ; get current colour code
.eae8	a5 ce		lda $ce		   LDA GDBLN         ; get character under cursor
.eaea					DIRQ_10
.eaea	49 80		eor #$80	   EOR #$80          ; toggle b7 of character under cursor
.eaec	20 aa ea	jsr $eaaa	   JSR Display_Char_And_Color
.eaef					DIRQ_20
.eaef	ad 1f 91	lda $911f	   LDA IEC_DRAN      ; get VIA 1 DRA, no handshake
.eaf2	29 40		and #$40	   AND #$40          ; mask cassette switch sense
.eaf4	f0 0b		beq $eb01	   BEQ DIRQ_30      ; branch if cassette sense low
.eaf6	a0 00		ldy #$00	   LDY #0
.eaf8	84 c0		sty $c0		   STY CAS1          ; clear the tape motor interlock
.eafa	ad 1c 91	lda $911c	   LDA VIA1_PCR      ; get VIA 1 PCR
.eafd	09 02		ora #$02	   ORA #$02          ; set CA2 high, turn off motor
.eaff	d0 09		bne $eb0a	   BNE DIRQ_40      ; branch always
.eb01					DIRQ_30
.eb01	a5 c0		lda $c0		   LDA CAS1          ; get tape motor interlock
.eb03	d0 0d		bne $eb12	   BNE DIRQ_50      ; if cassette interlock <> 0 don't turn on motor
.eb05	ad 1c 91	lda $911c	   LDA VIA1_PCR      ; get VIA 1 PCR
.eb08	29 fd		and #$fd	   AND #$FD          ; set CA2 low, turn on motor
.eb0a					DIRQ_40
.eb0a	2c 1e 91	bit $911e	   BIT VIA1_IER      ; test VIA 1 IER
.eb0d	70 03		bvs $eb12	   BVS DIRQ_50       ; if T1 interrupt enabled don't change motor state
.eb0f	8d 1c 91	sta $911c	   STA VIA1_PCR      ; set VIA 1 PCR, set CA2 high/low
.eb12					DIRQ_50
.eb12	20 1e eb	jsr $eb1e	   JSR Kernal_SCNKEY ; scan keyboard
.eb15	2c 24 91	bit $9124	   BIT VIA2_T1CL     ; clear the timer interrupt flag
.eb18	68		pla		   PLA
.eb19	a8		tay		   TAY
.eb1a	68		pla		   PLA
.eb1b	aa		tax		   TAX
.eb1c	68		pla		   PLA
.eb1d	40		rti		   RTI
.eb1e					  Kernal_SCNKEY
.eb1e	a9 00		lda #$00	   LDA #0
.eb20	8d 8d 02	sta $028d	   STA SHFLAG        ; clear keyboard shift/control/c= flag
.eb23	a0 40		ldy #$40	   LDY #$40          ; set no key
.eb25	84 cb		sty $cb		   STY SFDX          ; save which key
.eb27	8d 20 91	sta $9120	   STA KEYB_COL      ; clear keyboard column
.eb2a	ae 21 91	ldx $9121	   LDX KEYB_ROW      ; get keyboard row
.eb2d	e0 ff		cpx #$ff	   CPX #$FF          ; compare with all bits set
.eb2f	f0 5e		beq $eb8f	   BEQ KeSc_50       ; if no key pressed clear current key and exit
.eb31	a9 fe		lda #$fe	   LDA #$FE
.eb33	8d 20 91	sta $9120	   STA KEYB_COL      ; select keyboard col 0
.eb36	a0 00		ldy #$00	   LDY #0            ; clear key count
.eb38	a9 5e		lda #$5e	   LDA #<KBD_NORMAL  ; get decode table low byte
.eb3a	85 f5		sta $f5		   STA KBDPTR        ; set keyboard pointer low byte
.eb3c	a9 ec		lda #$ec	   LDA #>KBD_NORMAL  ; get decode table high byte
.eb3e	85 f6		sta $f6		   STA KBDPTR+1      ; set keyboard pointer high byte
.eb40					KeSc_05
.eb40	a2 08		ldx #$08	   LDX #8            ; set row count
.eb42	ad 21 91	lda $9121	   LDA KEYB_ROW      ; get VIA/CIA keyboard row
.eb45	cd 21 91	cmp $9121	   CMP KEYB_ROW      ; compare with itself
.eb48	d0 f6		bne $eb40	   BNE KeSc_05      ; loop if changing
.eb4a					KeSc_15
.eb4a	4a		lsr a		   LSR A             ; shift row to Cb
.eb4b	b0 16		bcs $eb63	   BCS KeSc_30       ; if no key closed on this row go do next row
.eb4d	48		pha		   PHA               ; save row
.eb4e	b1 f5		lda ($f5),y	   LDA (KBDPTR),Y    ; get character from decode table
.eb50	c9 05		cmp #$05	   CMP #$05          ; compare with $05, there is no $05 key but the control
.eb52	b0 0c		bcs $eb60	   BCS KeSc_20       ; if not shift/control/c=/stop go save key count
.eb54	c9 03		cmp #$03	   CMP #$03          ; compare with $03, stop
.eb56	f0 08		beq $eb60	   BEQ KeSc_20       ; if stop go save key count and continue
.eb58	0d 8d 02	ora $028d	   ORA SHFLAG        ; OR keyboard shift/control/c= flag
.eb5b	8d 8d 02	sta $028d	   STA SHFLAG        ; save keyboard shift/control/c= flag
.eb5e	10 02		bpl $eb62	   BPL KeSc_25       ; skip save key, branch always
.eb60					KeSc_20
.eb60	84 cb		sty $cb		   STY SFDX          ; save key count
.eb62					KeSc_25
.eb62	68		pla		   PLA               ; restore row
.eb63					KeSc_30
.eb63	c8		iny		   INY               ; increment key count
.eb64	c0 41		cpy #$41	   CPY #$41          ; compare with max+1
.eb66	b0 09		bcs $eb71	   BCS KeSc_35       ; exit loop if >= max+1
.eb68	ca		dex		   DEX               ; decrement row count
.eb69	d0 df		bne $eb4a	   BNE KeSc_15       ; loop if more rows to do
.eb6b	38		sec		   SEC               ; set carry for keyboard column shift
.eb6c	2e 20 91	rol $9120	   ROL KEYB_COL      ; shift VIA 2 DRB, keyboard column
.eb6f	d0 cf		bne $eb40	   BNE KeSc_05      ; loop for next column, branch always
.eb71					KeSc_35
.eb71	6c 8f 02	jmp ($028f)	   JMP (KEYLOG)      ; normally Keyboard_Decoder
.eb74					KeSc_40
.eb74	a4 cb		ldy $cb		   LDY SFDX          ; get saved key count
.eb76	b1 f5		lda ($f5),y	   LDA (KBDPTR),Y    ; get character from decode table
.eb78	aa		tax		   TAX               ; copy character to X
.eb79	c4 c5		cpy $c5		   CPY LSTX          ; compare key count with last key count
.eb7b	f0 07		beq $eb84	   BEQ KeSc_45       ; if this key = current key, key held, go test repeat
.eb7d	a0 10		ldy #$10	   LDY #$10          ; set repeat delay count
.eb7f	8c 8c 02	sty $028c	   STY KRPTDL        ; save repeat delay count
.eb82	d0 36		bne $ebba	   BNE KeSc_65       ; go save key to buffer and exit, branch always
.eb84					KeSc_45
.eb84	29 7f		and #$7f	   AND #$7F          ; clear b7
.eb86	2c 8a 02	bit $028a	   BIT KEYRPT        ; test key repeat
.eb89	30 16		bmi $eba1	   BMI KeSc_55       ; branch if repeat all
.eb8b	70 49		bvs $ebd6	   BVS KeSc_70       ; branch if repeat none
.eb8d	c9 7f		cmp #$7f	   CMP #$7F          ; compare with end marker
.eb8f					KeSc_50
.eb8f	f0 29		beq $ebba	   BEQ KeSc_65       ; if $00/end marker go save key to buffer and exit
.eb91	c9 14		cmp #$14	   CMP #$14          ; compare with [INSERT]/[DELETE]
.eb93	f0 0c		beq $eba1	   BEQ KeSc_55       ; if [INSERT]/[DELETE] go test for repeat
.eb95	c9 20		cmp #$20	   CMP #' '          ; compare with [SPACE]
.eb97	f0 08		beq $eba1	   BEQ KeSc_55       ; if [SPACE] go test for repeat
.eb99	c9 1d		cmp #$1d	   CMP #$1D          ; compare with [CURSOR RIGHT]
.eb9b	f0 04		beq $eba1	   BEQ KeSc_55       ; if [CURSOR RIGHT] go test for repeat
.eb9d	c9 11		cmp #$11	   CMP #$11          ; compare with [CURSOR DOWN]
.eb9f	d0 35		bne $ebd6	   BNE KeSc_70       ; if not [CURSOR DOWN] just exit
.eba1					KeSc_55
.eba1	ac 8c 02	ldy $028c	   LDY KRPTDL        ; get repeat delay counter
.eba4	f0 05		beq $ebab	   BEQ KeSc_60       ; branch if delay expired
.eba6	ce 8c 02	dec $028c	   DEC KRPTDL        ; else decrement repeat delay counter
.eba9	d0 2b		bne $ebd6	   BNE KeSc_70       ; branch if delay not expired
.ebab					KeSc_60
.ebab	ce 8b 02	dec $028b	   DEC KRPTSP        ; decrement repeat speed counter
.ebae	d0 26		bne $ebd6	   BNE KeSc_70       ; branch if repeat speed count not expired
.ebb0	a0 04		ldy #$04	   LDY #$04          ; set for 4/60ths of a second
.ebb2	8c 8b 02	sty $028b	   STY KRPTSP        ; set repeat speed counter
.ebb5	a4 c6		ldy $c6		   LDY NDX           ; get keyboard buffer index
.ebb7	88		dey		   DEY               ; decrement it
.ebb8	10 1c		bpl $ebd6	   BPL KeSc_70       ; if the buffer isn't empty just exit
.ebba					KeSc_65
.ebba	a4 cb		ldy $cb		   LDY SFDX          ; get the key count
.ebbc	84 c5		sty $c5		   STY LSTX          ; save as the current key count
.ebbe	ac 8d 02	ldy $028d	   LDY SHFLAG        ; get keyboard shift/control/c= flag
.ebc1	8c 8e 02	sty $028e	   STY LSTSHF        ; save as last keyboard shift pattern
.ebc4	e0 ff		cpx #$ff	   CPX #$FF          ; compare character with table end marker or no key
.ebc6	f0 0e		beq $ebd6	   BEQ KeSc_70       ; if table end marker or no key just exit
.ebc8	8a		txa		   TXA               ; copy character to A
.ebc9	a6 c6		ldx $c6		   LDX NDX           ; get keyboard buffer index
.ebcb	ec 89 02	cpx $0289	   CPX KBMAXL        ; compare with keyboard buffer size
.ebce	b0 06		bcs $ebd6	   BCS KeSc_70       ; if buffer full just exit
.ebd0	9d 77 02	sta $0277,x	   STA KBUFFR,X      ; save character to keyboard buffer
.ebd3	e8		inx		   INX               ; increment index
.ebd4	86 c6		stx $c6		   STX NDX           ; save keyboard buffer index
.ebd6					KeSc_70
.ebd6	a9 f7		lda #$f7	   LDA #STND_COL     ; col 3 on VIC / col 7 on C64
.ebd8	8d 20 91	sta $9120	   STA KEYB_COL      ; set VIA/CIA keyboard column
.ebdb	60		rts		   RTS
.ebdc					  Keyboard_Decoder
.ebdc	ad 8d 02	lda $028d	   LDA SHFLAG        ; get keyboard shift/control/c= flag
.ebdf	c9 03		cmp #$03	   CMP #$03          ; compare with [SHIFT][C=]
.ebe1	d0 2c		bne $ec0f	   BNE KeDe_10       ; branch if not
.ebe3	cd 8e 02	cmp $028e	   CMP LSTSHF        ; compare with last
.ebe6	f0 ee		beq $ebd6	   BEQ KeSc_70       ; exit if still the same
.ebe8	ad 91 02	lda $0291	   LDA MODE          ; get shift mode switch $00 = enabled, $80 = locked
.ebeb	30 56		bmi $ec43	   BMI KeDe_30       ; if locked continue keyboard decode
>ebed	ea ea ea ea ea ea ea ea		   .fill 19 ,$EA    ; NOP's
>ebf5	ea ea ea ea ea ea ea ea ea ea ea
.ec00	ad 05 90	lda $9005	   LDA VIC_R5        ; get start of character memory, ROM
.ec03	49 02		eor #$02	   EOR #$02          ; toggle $8000,$8800
.ec05	8d 05 90	sta $9005	   STA VIC_R5        ; set start of character memory, ROM
>ec08	ea ea ea ea			   .fill  4 ,$EA    ; NOP's
.ec0c	4c 43 ec	jmp $ec43	   JMP KeDe_30       ; continue keyboard decode
.ec0f					KeDe_10
.ec0f	0a		asl a		   ASL A             ; convert flag to index
.ec10	c9 08		cmp #$08	   CMP #8            ; compare with [CTRL]
.ec12	90 04		bcc $ec18	   BCC KeDe_20       ; branch if not [CTRL] pressed
.ec14	a9 06		lda #$06	   LDA #6            ; [CTRL] : table 3 : index 6
>ec16	ea ea				   .fill 2 ,$EA     ; NOP's
.ec18					KeDe_20
>ec18	ea ea ea ea ea ea ea ea		   .fill 32 ,$EA    ; NOP's
>ec20	ea ea ea ea ea ea ea ea ea ea ea ea ea ea ea ea
>ec30	ea ea ea ea ea ea ea ea
.ec38	aa		tax		   TAX               ; copy index to X
.ec39	bd 46 ec	lda $ec46,x	   LDA KBD_Decode_Pointer,X
.ec3c	85 f5		sta $f5		   STA KBDPTR
.ec3e	bd 47 ec	lda $ec47,x	   LDA KBD_Decode_Pointer+1,X
.ec41	85 f6		sta $f6		   STA KBDPTR+1
.ec43					KeDe_30
.ec43	4c 74 eb	jmp $eb74	   JMP KeSc_40       ; continue keyboard decode
.ec46					  KBD_Decode_Pointer
>ec46	5e ec				   .word   KBD_NORMAL  ; 0   normal
>ec48	9f ec				   .word   KBD_SHIFTED ; 1   shifted
>ec4a	e0 ec				   .word   KBD_CBMKEY  ; 2   commodore
>ec4c	a3 ed				   .word   KBD_CONTROL ; 3   control
>ec4e	5e ec				   .word   KBD_NORMAL  ; 4   control
>ec50	9f ec				   .word   KBD_SHIFTED ; 5   shift - control
>ec52	69 ed				   .word   KBD_COMMCON ; 6   commodore control
>ec54	a3 ed				   .word   KBD_CONTROL ; 7   shift - commdore - control
>ec56	21 ed				   .word   Switch_Text_Graphics    ; 8   unused
>ec58	69 ed				   .word   KBD_COMMCON ; 9   unused
>ec5a	69 ed				   .word   KBD_COMMCON ; a   unused
>ec5c	a3 ed				   .word   KBD_CONTROL ; b   unused
.ec5e					KBD_NORMAL
>ec5e	31 33 35 37 39 2b 5c 14		   .byte $31,$33,$35,$37,$39,$2B,$5C,$14
>ec66	5f 57 52 59 49 50 2a 0d		   .byte $5F,$57,$52,$59,$49,$50,$2A,$0D
>ec6e	04 41 44 47 4a 4c 3b 1d		   .byte $04,$41,$44,$47,$4A,$4C,$3B,$1D
>ec76	03 01 58 56 4e 2c 2f 11		   .byte $03,$01,$58,$56,$4E,$2C,$2F,$11
>ec7e	20 5a 43 42 4d 2e 01 85		   .byte $20,$5A,$43,$42,$4D,$2E,$01,$85
>ec86	02 53 46 48 4b 3a 3d 86		   .byte $02,$53,$46,$48,$4B,$3A,$3D,$86
>ec8e	51 45 54 55 4f 40 5e 87		   .byte $51,$45,$54,$55,$4F,$40,$5E,$87
>ec96	32 34 36 38 30 2d 13 88		   .byte $32,$34,$36,$38,$30,$2D,$13,$88
>ec9e	ff				   .byte $FF
.ec9f					KBD_SHIFTED
>ec9f	21 23 25 27 29 db a9 94		   .byte $21,$23,$25,$27,$29,$DB,$A9,$94
>eca7	5f d7 d2 d9 c9 d0 c0 8d		   .byte $5F,$D7,$D2,$D9,$C9,$D0,$C0,$8D
>ecaf	04 c1 c4 c7 ca cc 5d 9d		   .byte $04,$C1,$C4,$C7,$CA,$CC,$5D,$9D
>ecb7	83 01 d8 d6 ce 3c 3f 91		   .byte $83,$01,$D8,$D6,$CE,$3C,$3F,$91
>ecbf	a0 da c3 c2 cd 3e 01 89		   .byte $A0,$DA,$C3,$C2,$CD,$3E,$01,$89
>ecc7	02 d3 c6 c8 cb 5b 3d 8a		   .byte $02,$D3,$C6,$C8,$CB,$5B,$3D,$8A
>eccf	d1 c5 d4 d5 cf ba de 8b		   .byte $D1,$C5,$D4,$D5,$CF,$BA,$DE,$8B
>ecd7	22 24 26 28 30 dd 93 8c		   .byte $22,$24,$26,$28,$30,$DD,$93,$8C
>ecdf	ff				   .byte $FF
.ece0					KBD_CBMKEY
>ece0	21 23 25 27 29 a6 a8 94		   .byte $21,$23,$25,$27,$29,$A6,$A8,$94
>ece8	5f b3 b2 b7 a2 af df 8d		   .byte $5F,$B3,$B2,$B7,$A2,$AF,$DF,$8D
>ecf0	04 b0 ac a5 b5 b6 5d 9d		   .byte $04,$B0,$AC,$A5,$B5,$B6,$5D,$9D
>ecf8	83 01 bd be aa 3c 3f 91		   .byte $83,$01,$BD,$BE,$AA,$3C,$3F,$91
>ed00	a0 ad bc bf a7 3e 01 89		   .byte $A0,$AD,$BC,$BF,$A7,$3E,$01,$89
>ed08	02 ae bb b4 a1 5b 3d 8a		   .byte $02,$AE,$BB,$B4,$A1,$5B,$3D,$8A
>ed10	ab b1 a3 b8 b9 a4 de 8b		   .byte $AB,$B1,$A3,$B8,$B9,$A4,$DE,$8B
>ed18	22 24 26 28 30 dc 93 8c		   .byte $22,$24,$26,$28,$30,$DC,$93,$8C
>ed20	ff				   .byte $FF
.ed21					  Switch_Text_Graphics
.ed21	c9 0e		cmp #$0e	   CMP #$0E          ; compare with [SWITCH TO LOWER CASE]
.ed23	d0 0b		bne $ed30	   BNE STG_10        ; branch if not [SWITCH TO LOWER CASE]
.ed25	a9 02		lda #$02	   LDA #$02          ; set for $8800, lower case characters
.ed27	0d 05 90	ora $9005	   ORA MEM_CONTROL   ; OR with start of character memory, ROM
.ed2a	8d 05 90	sta $9005	   STA MEM_CONTROL   ; save start of character memory, ROM
.ed2d	4c dc e6	jmp $e6dc	   JMP InsC_50       ; restore registers, set quote flag and exit
.ed30					STG_10
.ed30	c9 8e		cmp #$8e	   CMP #$8E          ; compare with [SWITCH TO UPPER CASE]
.ed32	d0 0b		bne $ed3f	   BNE STG_40        ; branch if not [SWITCH TO UPPER CASE]
.ed34	a9 fd		lda #$fd	   LDA #$FD          ; set for $8000, upper case characters
.ed36	2d 05 90	and $9005	   AND MEM_CONTROL   ; AND with start of character memory, ROM
.ed39					STG_20
.ed39	8d 05 90	sta $9005	   STA MEM_CONTROL   ; save start of character memory, ROM
.ed3c					STG_30
.ed3c	4c dc e6	jmp $e6dc	   JMP InsC_50       ; restore registers, set quote flag and exit
.ed3f					STG_40
.ed3f	c9 08		cmp #$08	   CMP #$08          ; compare with disable [SHIFT][C=]
.ed41	d0 0a		bne $ed4d	   BNE STG_50        ; branch if not disable [SHIFT][C=]
.ed43	a9 80		lda #$80	   LDA #$80          ; set to lock shift mode switch
.ed45	0d 91 02	ora $0291	   ORA MODE          ; OR with shift mode switch, $00 = enabled, $80 = locked
.ed48	8d 91 02	sta $0291	   STA MODE          ; save shift mode switch
.ed4b	30 ef		bmi $ed3c	   BMI STG_30        ; branch always
.ed4d					STG_50
.ed4d	c9 09		cmp #$09	   CMP #$09          ; compare with enable [SHIFT][C=]
.ed4f	d0 eb		bne $ed3c	   BNE STG_30        ; exit if not enable [SHIFT][C=]    ##### start ####
.ed51	a9 7f		lda #$7f	   LDA #$7F          ; set to unlock shift mode switch
.ed53	2d 91 02	and $0291	   AND MODE          ; AND with shift mode switch, $00 = enabled, $80 = locked
.ed56					STG_60
.ed56	8d 91 02	sta $0291	   STA MODE          ; save shift mode switch
.ed59	10 e1		bpl $ed3c	   BPL STG_30        ; branch always
.ed5b					ELL_10
.ed5b	e8		inx		   INX               ; increment screen row
.ed5c	b5 d9		lda $d9,x	   LDA SLLTBL,X      ; get start of line X pointer high byte
.ed5e	09 80		ora #$80	   ORA #$80          ; mark as start of logical line
.ed60	95 d9		sta $d9,x	   STA SLLTBL,X      ; set start of line X pointer high byte
.ed62	ca		dex		   DEX               ; restore screen row
.ed63	a5 d5		lda $d5		   LDA LINLEN        ; get current screen line length
.ed65	18		clc		   CLC
.ed66	4c 15 e7	jmp $e715	   JMP ELL_20      ; add one line length, set pointers for start of line and
.ed69					KBD_COMMCON
>ed69	ff ff ff ff ff ff ff ff		   .byte   $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
>ed71	ff 04 ff ff ff ff ff e2		   .byte   $FF,$04,$FF,$FF,$FF,$FF,$FF,$E2
>ed79	9d 83 01 ff ff ff ff ff		   .byte   $9D,$83,$01,$FF,$FF,$FF,$FF,$FF
>ed81	91 a0 ff ff ff ff ee 01		   .byte   $91,$A0,$FF,$FF,$FF,$FF,$EE,$01
>ed89	89 02 ff ff ff ff e1 fd		   .byte   $89,$02,$FF,$FF,$FF,$FF,$E1,$FD
>ed91	8a ff ff ff ff ff b0 e0		   .byte   $8A,$FF,$FF,$FF,$FF,$FF,$B0,$E0
>ed99	8b f2 f4 f6 ff f0 ed 93		   .byte   $8B,$F2,$F4,$F6,$FF,$F0,$ED,$93
>eda1	8c ff				   .byte   $8C,$FF
.eda3					KBD_CONTROL
>eda3	90 1c 9c 1f 12 ff ff ff		   .byte   $90,$1C,$9C,$1F,$12,$FF,$FF,$FF
>edab	06 ff 12 ff ff ff ff ff		   .byte   $06,$FF,$12,$FF,$FF,$FF,$FF,$FF
>edb3	ff ff ff ff ff ff ff ff		   .byte   $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
>edbb	ff ff ff ff ff ff ff ff		   .byte   $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
>edc3	ff ff ff ff ff ff ff ff		   .byte   $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
>edcb	ff ff ff ff ff ff ff ff		   .byte   $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
>edd3	ff ff				   .byte   $FF,$FF
>edd5	ff ff ff ff ff ff 05		   .byte $FF,$FF,$FF,$FF,$FF,$FF,$05
>eddc	9f 1e 9e 92 ff ff ff ff		   .byte $9F,$1E,$9E,$92,$FF,$FF,$FF,$FF
.ede4					VIC_INIT
>ede4	0c				   .byte   $0C ;$05       ; horizontal offset [NTSC]
>ede5	26				   .byte   $26 ;$19       ; vertical origin [NTSC]
>ede6	16				   .byte   $16       ; video address and colums, $9400 for colour RAM
>ede7	2e				   .byte   $2E       ; rows and character size
>ede8	00				   .byte   $00       ; raster line
>ede9	c0				   .byte   $C0       ; video memory addresses, RAM $1000, ROM $8000
>edea	00				   .byte   $00       ; light pen horizontal position
>edeb	00				   .byte   $00       ; light pen vertical position
>edec	00				   .byte   $00       ; paddle X
>eded	00				   .byte   $00       ; paddle Y
>edee	00				   .byte   $00       ; oscillator 1 frequency
>edef	00				   .byte   $00       ; oscillator 2 frequency
>edf0	00				   .byte   $00       ; oscillator 3 frequency
>edf1	00				   .byte   $00       ; noise source frequency
>edf2	00				   .byte   $00       ; aux colour and volume
>edf3	1b				   .byte   $1B       ; screen and border colour
>edf4	4c 4f 41 44 0d 52 55 4e		RUNKEY .TEXT "LOAD",$0D,"RUN",$0D
>edfc	0d
.edfd					  Line_Adress_Low
>edfd	00 16 2c 42 58 6e 84 9a		   .byte $00,$16,$2C,$42,$58,$6E,$84,$9A
>ee05	b0 c6 dc f2 08 1e 34 4a		   .byte $B0,$C6,$DC,$F2,$08,$1E,$34,$4A
>ee0d	60 76 8c a2 b8 ce e4		   .byte $60,$76,$8C,$A2,$B8,$CE,$E4
.ee14					  Kernal_TALK
.ee14	09 40		ora #$40	   ORA #$40          ; OR with the TALK command
>ee16	2c				   .byte   $2C       ; skip next 2 bytes
.ee17					  Kernal_LISTEN
.ee17	09 20		ora #$20	   ORA #$20          ; OR with the LISTEN command
.ee19	20 60 f1	jsr $f160	   JSR RS232_Stop
.ee1c					  IEC_Send_Control_Byte
.ee1c	48		pha		   PHA               ; save device address
.ee1d	24 94		bit $94		   BIT C3PO          ; test deferred character flag
.ee1f	10 0a		bpl $ee2b	   BPL ISCB_10       ; branch if no defered character
.ee21	38		sec		   SEC               ; flag EOI
.ee22	66 a3		ror $a3		   ROR TSFCNT        ; rotate into EOI flag byte
.ee24	20 49 ee	jsr $ee49	   JSR IEC_Send_Byte
.ee27	46 94		lsr $94		   LSR C3PO          ; clear deferred character flag
.ee29	46 a3		lsr $a3		   LSR TSFCNT        ; clear EOI flag
.ee2b					ISCB_10
.ee2b	68		pla		   PLA               ; device address OR'ed with command
.ee2c	85 95		sta $95		   STA BSOUR         ; save as serial defered character
.ee2e	20 a0 e4	jsr $e4a0	   JSR CLR_IEC_DAT   ; set IEC data out high (0)
.ee31	c9 3f		cmp #$3f	   CMP #$3F          ; compare read byte with $3F
.ee33	d0 03		bne $ee38	   BNE ISCB_20       ; branch if not $3F, this branch will always be taken
.ee35	20 84 ef	jsr $ef84	   JSR CLR_IEC_CLK   ; set IEC clock out high (0)
.ee38					ISCB_20
.ee38	ad 1f 91	lda $911f	   LDA IEC_DRAN      ; get VIA 1 DRA, no handshake
.ee3b	09 80		ora #$80	   ORA #IEC_ATN_BIT  ; set IEC ATN low (1)
.ee3d	8d 1f 91	sta $911f	   STA IEC_DRAN      ; set VIA 1 DRA, no handshake
.ee40					  IEC_Delay_And_Send_Byte
.ee40	20 8d ef	jsr $ef8d	   JSR SET_IEC_CLK   ; set IEC clock out low
.ee43	20 a0 e4	jsr $e4a0	   JSR CLR_IEC_DAT   ; set IEC data  out high
.ee46	20 96 ef	jsr $ef96	   JSR WAIT_1MS      ; 1ms delay
.ee49					  IEC_Send_Byte
.ee49	78		sei		   SEI               ; disable interrupts
.ee4a	20 a0 e4	jsr $e4a0	   JSR CLR_IEC_DAT   ; set serial data out high
.ee4d	20 b2 e4	jsr $e4b2	   JSR GET_IEC_CLK   ; get serial clock status
.ee50	4a		lsr a		   LSR A             ; shift serial data to Cb
.ee51	b0 61		bcs $eeb4	   BCS Device_Not_Present
.ee53	20 84 ef	jsr $ef84	   JSR CLR_IEC_CLK   ; set serial clock high
.ee56	24 a3		bit $a3		   BIT TSFCNT        ; test EOI flag
.ee58	10 0c		bpl $ee66	   BPL ISCB_50       ; branch if not EOI
.ee5a					ISCB_30
.ee5a	20 b2 e4	jsr $e4b2	   JSR GET_IEC_CLK   ; get serial clock status
.ee5d	4a		lsr a		   LSR A             ; shift serial data to Cb
.ee5e	90 fa		bcc $ee5a	   BCC ISCB_30       ; loop if data low
.ee60					ISCB_40
.ee60	20 b2 e4	jsr $e4b2	   JSR GET_IEC_CLK   ; get serial clock status
.ee63	4a		lsr a		   LSR A             ; shift serial data to Cb
.ee64	b0 fa		bcs $ee60	   BCS ISCB_40       ; loop if data high
.ee66					ISCB_50
.ee66	20 b2 e4	jsr $e4b2	   JSR GET_IEC_CLK   ; get serial clock status
.ee69	4a		lsr a		   LSR A             ; shift serial data to Cb
.ee6a	90 fa		bcc $ee66	   BCC ISCB_50       ; loop if data low
.ee6c	20 8d ef	jsr $ef8d	   JSR SET_IEC_CLK   ; set serial clock low
.ee6f	a9 08		lda #$08	   LDA #$08          ; eight bits to do
.ee71	85 a5		sta $a5		   STA CNTDN         ; set serial bus bit count
.ee73					ISCB_60
.ee73	ad 1f 91	lda $911f	   LDA IEC_DRAN      ; get VIA 1 DRA, no handshake
.ee76	cd 1f 91	cmp $911f	   CMP IEC_DRAN      ; compare with self
.ee79	d0 f8		bne $ee73	   BNE ISCB_60       ; loop if changing
.ee7b	4a		lsr a		   LSR A             ; serial clock to carry
.ee7c	4a		lsr a		   LSR A             ; serial data to carry
.ee7d	90 38		bcc $eeb7	   BCC IEC_Timeout
.ee7f	66 95		ror $95		   ROR BSOUR         ; rotate transmit byte
.ee81	b0 05		bcs $ee88	   BCS ISCB_70       ; branch if bit = 1
.ee83	20 a9 e4	jsr $e4a9	   JSR SET_IEC_DAT   ; else set serial data out low
.ee86	d0 03		bne $ee8b	   BNE ISCB_80       ; branch always
.ee88					ISCB_70
.ee88	20 a0 e4	jsr $e4a0	   JSR CLR_IEC_DAT   ; set serial data out high
.ee8b					ISCB_80
.ee8b	20 84 ef	jsr $ef84	   JSR CLR_IEC_CLK   ; set serial clock high
.ee8e	ea		nop		   NOP
.ee8f	ea		nop		   NOP
.ee90	ea		nop		   NOP
.ee91	ea		nop		   NOP
.ee92	ad 2c 91	lda $912c	   LDA IEC_PCR       ; get VIA/CIA PCR
.ee95	29 df		and #$df	   AND #$DF          ; set CB2 low, serial data out high
.ee97	09 02		ora #$02	   ORA #IEC_CLK_BIT  ; set CA2 high, serial clock out low
.ee99	8d 2c 91	sta $912c	   STA IEC_PCR
.ee9c	c6 a5		dec $a5		   DEC CNTDN         ; decrement serial bus bit count
.ee9e	d0 d3		bne $ee73	   BNE ISCB_60       ; loop if not all done
.eea0	a9 04		lda #$04	   LDA #4            ; wait for up to about 1ms
.eea2	8d 29 91	sta $9129	   STA IEC_TIM_H     ; set VIA/CIA timer high
.eea5					ISCB_90
.eea5	ad 2d 91	lda $912d	   LDA IEC_IFR       ; get VIA 2 IFR
.eea8	29 20		and #$20	   AND #$20          ; mask T2 interrupt
.eeaa	d0 0b		bne $eeb7	   BNE IEC_Timeout      ; if T2 interrupt do timeout on serial bus
.eeac	20 b2 e4	jsr $e4b2	   JSR GET_IEC_CLK   ; get serial clock status
.eeaf	4a		lsr a		   LSR A             ; shift serial data to Cb
.eeb0	b0 f3		bcs $eea5	   BCS ISCB_90       ; if data high go wait some more
.eeb2	58		cli		   CLI
.eeb3	60		rts		   RTS
.eeb4					  Device_Not_Present
.eeb4	a9 80		lda #$80	   LDA #$80          ; error $80, device not present
>eeb6	2c				   .byte   $2C       ; skip next statement
.eeb7					  IEC_Timeout
.eeb7	a9 03		lda #$03	   LDA #$03          ; error $03, write timeout
.eeb9					  Set_IEC_Status
.eeb9	20 6a fe	jsr $fe6a	   JSR Ora_Status
.eebc	58		cli		   CLI               ; enable interrupts
.eebd	18		clc		   CLC               ; clear for branch
.eebe	90 49		bcc $ef09	   BCC KeUN_10      ; ATN high, delay, clock high then data high, branch always
.eec0					  Kernal_SECOND
.eec0	85 95		sta $95		   STA BSOUR         ; save defered byte
.eec2	20 40 ee	jsr $ee40	   JSR IEC_Delay_And_Send_Byte
.eec5					  IEC_ATN_High
.eec5	ad 1f 91	lda $911f	   LDA IEC_DRAN      ; get VIA 1 DRA, no handshake
.eec8	29 7f		and #$7f	   AND #$7F          ; set serial ATN high
.eeca	8d 1f 91	sta $911f	   STA IEC_DRAN      ; set VIA 1 DRA, no handshake
.eecd	60		rts		   RTS
.eece					  Kernal_TKSA
.eece	85 95		sta $95		   STA BSOUR         ; save the secondary address byte to transmit
.eed0	20 40 ee	jsr $ee40	   JSR IEC_Delay_And_Send_Byte
.eed3					  IEC_Finish_Send
.eed3	78		sei		   SEI               ; disable interrupts
.eed4	20 a9 e4	jsr $e4a9	   JSR SET_IEC_DAT   ; set serial data out low
.eed7	20 c5 ee	jsr $eec5	   JSR IEC_ATN_High  ; set serial ATN high
.eeda	20 84 ef	jsr $ef84	   JSR CLR_IEC_CLK   ; set serial clock high
.eedd					IFS_10
.eedd	20 b2 e4	jsr $e4b2	   JSR GET_IEC_CLK   ; get serial clock status
.eee0	b0 fb		bcs $eedd	   BCS IFS_10        ; branch if clock high
.eee2	58		cli		   CLI               ; enable interrupts
.eee3	60		rts		   RTS
.eee4					  Kernal_CIOUT
.eee4	24 94		bit $94		   BIT C3PO          ; test deferred character flag
.eee6	30 05		bmi $eeed	   BMI KeCI_10       ; branch if defered character
.eee8	38		sec		   SEC               ; set carry
.eee9	66 94		ror $94		   ROR C3PO          ; shift into deferred character flag
.eeeb	d0 05		bne $eef2	   BNE KeCI_20       ; save byte and exit, branch always
.eeed					KeCI_10
.eeed	48		pha		   PHA               ; save byte
.eeee	20 49 ee	jsr $ee49	   JSR IEC_Send_Byte
.eef1	68		pla		   PLA               ; restore byte
.eef2					KeCI_20
.eef2	85 95		sta $95		   STA BSOUR         ; save defered byte
.eef4	18		clc		   CLC               ; flag ok
.eef5	60		rts		   RTS
.eef6					  Kernal_UNTLK
.eef6	20 8d ef	jsr $ef8d	   JSR SET_IEC_CLK
.eef9	ad 1f 91	lda $911f	   LDA IEC_DRAN      ; get VIA 1 DRA, no handshake
.eefc	09 80		ora #$80	   ORA #IEC_ATN_BIT  ; set serial ATN low
.eefe	8d 1f 91	sta $911f	   STA IEC_DRAN      ; set VIA 1 DRA, no handshake
.ef01	a9 5f		lda #$5f	   LDA #$5F          ; set the UNTALK command
>ef03	2c				   .byte   $2C       ; skip next two bytes
.ef04					  Kernal_UNLSN
.ef04	a9 3f		lda #$3f	   LDA #$3F          ; set the UNLISTEN command
.ef06	20 1c ee	jsr $ee1c	   JSR IEC_Send_Control_Byte
.ef09					KeUN_10
.ef09	20 c5 ee	jsr $eec5	   JSR IEC_ATN_High  ; set serial ATN high
.ef0c					  IEC_Delay_CLK_High_DATA_High
.ef0c	8a		txa		   TXA               ; save device number
.ef0d	a2 0b		ldx #$0b	   LDX #11           ; short delay
.ef0f					IDel_10
.ef0f	ca		dex		   DEX               ; decrement count
.ef10	d0 fd		bne $ef0f	   BNE IDel_10       ; loop if not all done
.ef12	aa		tax		   TAX               ; restore device number
.ef13	20 84 ef	jsr $ef84	   JSR CLR_IEC_CLK   ; set serial clock high
.ef16	4c a0 e4	jmp $e4a0	   JMP CLR_IEC_DAT   ; set serial data out high and return
.ef19					  Kernal_ACPTR
.ef19	78		sei		   SEI               ; disable interrupts
.ef1a	a9 00		lda #$00	   LDA #0
.ef1c					KeAC_03
.ef1c	85 a5		sta $a5		   STA CNTDN         ; clear serial bus bit count
.ef1e	20 84 ef	jsr $ef84	   JSR CLR_IEC_CLK   ; set serial clock high
.ef21					KeAC_05
.ef21	20 b2 e4	jsr $e4b2	   JSR GET_IEC_CLK   ; get serial clock status
.ef24	90 fb		bcc $ef21	   BCC KeAC_05       ; loop while clock low
.ef26	20 a0 e4	jsr $e4a0	   JSR CLR_IEC_DAT   ; set serial data out high
.ef29					KeAC_10
.ef29	a9 01		lda #$01	   LDA #$01          ; set timeout count high byte
.ef2b	8d 29 91	sta $9129	   STA IEC_TIM_H
.ef2e					KeAC_15
.ef2e	ad 2d 91	lda $912d	   LDA IEC_IFR       ; get VIA 2 IFR
.ef31	29 20		and #$20	   AND #IEC_IFR_BIT  ; mask T2 interrupt
.ef33	d0 07		bne $ef3c	   BNE KeAC_25       ; branch if T2 interrupt
.ef35	20 b2 e4	jsr $e4b2	   JSR GET_IEC_CLK   ; get serial clock status
.ef38	b0 f4		bcs $ef2e	   BCS KeAC_15       ; loop if clock high
.ef3a	90 18		bcc $ef54	   BCC KeAC_35       ; else go se 8 bits to do, branch always
.ef3c					KeAC_25
.ef3c	a5 a5		lda $a5		   LDA CNTDN         ; get serial bus bit count
.ef3e	f0 05		beq $ef45	   BEQ KeAC_30       ; if not already EOI then go flag EOI
.ef40	a9 02		lda #$02	   LDA #$02          ; error $02, read timeour
.ef42	4c b9 ee	jmp $eeb9	   JMP Set_IEC_Status
.ef45					KeAC_30
.ef45	20 a9 e4	jsr $e4a9	   JSR SET_IEC_DAT    ; set serial data out low
.ef48	20 0c ef	jsr $ef0c	   JSR IEC_Delay_CLK_High_DATA_High      ; 1ms delay, clock high then data high
.ef4b	a9 40		lda #$40	   LDA #$40          ; set EOI
.ef4d	20 6a fe	jsr $fe6a	   JSR Ora_Status
.ef50	e6 a5		inc $a5		   INC CNTDN         ; increment serial bus bit count, do error on next timeout
.ef52	d0 d5		bne $ef29	   BNE KeAC_10       ; go try again
.ef54					KeAC_35
.ef54	a9 08		lda #$08	   LDA #$08          ; 8 bits to do
.ef56	85 a5		sta $a5		   STA CNTDN         ; set serial bus bit count
.ef58					KeAC_40
.ef58	ad 1f 91	lda $911f	   LDA IEC_DRAN      ; get VIA 1 DRA, no handshake
.ef5b	cd 1f 91	cmp $911f	   CMP IEC_DRAN      ; compare with self
.ef5e	d0 f8		bne $ef58	   BNE KeAC_40       ; loop if changing
.ef60	4a		lsr a		   LSR A             ; serial clock into carry
.ef61	90 f5		bcc $ef58	   BCC KeAC_40       ; loop while serial clock low
.ef63	4a		lsr a		   LSR A             ; serial data into carry
.ef64	66 a4		ror $a4		   ROR TBTCNT        ; shift data bit into receive byte
.ef66					KeAC_45
.ef66	ad 1f 91	lda $911f	   LDA IEC_DRAN      ; get VIA 1 DRA, no handshake
.ef69	cd 1f 91	cmp $911f	   CMP IEC_DRAN      ; compare with self
.ef6c	d0 f8		bne $ef66	   BNE KeAC_45       ; loop if changing
.ef6e	4a		lsr a		   LSR A             ; serial clock into carry
.ef6f	b0 f5		bcs $ef66	   BCS KeAC_45       ; loop while serial clock high
.ef71	c6 a5		dec $a5		   DEC CNTDN         ; decrement serial bus bit count
.ef73	d0 e3		bne $ef58	   BNE KeAC_40       ; loop if not all done
.ef75	20 a9 e4	jsr $e4a9	   JSR SET_IEC_DAT   ; set serial data out low
.ef78	a5 90		lda $90		   LDA STATUS        ; get serial status byte
.ef7a	f0 03		beq $ef7f	   BEQ KeAC_50       ; branch if no error
.ef7c	20 0c ef	jsr $ef0c	   JSR IEC_Delay_CLK_High_DATA_High
.ef7f					KeAC_50
.ef7f	a5 a4		lda $a4		   LDA TBTCNT        ; get receive byte
.ef81	58		cli		   CLI               ; enable interrupts
.ef82	18		clc		   CLC
.ef83	60		rts		   RTS
.ef84					  CLR_IEC_CLK
.ef84	ad 2c 91	lda $912c	   LDA IEC_PCR
.ef87	29 fd		and #$fd	   AND #~IEC_CLK_BIT
.ef89	8d 2c 91	sta $912c	   STA IEC_PCR
.ef8c	60		rts		   RTS
.ef8d					  SET_IEC_CLK
.ef8d	ad 2c 91	lda $912c	   LDA IEC_PCR
.ef90	09 02		ora #$02	   ORA #IEC_CLK_BIT
.ef92	8d 2c 91	sta $912c	   STA IEC_PCR
.ef95	60		rts		   RTS
.ef96					  WAIT_1MS
.ef96	a9 04		lda #$04	   LDA #$04          ; set for 1024 cycles
.ef98	8d 29 91	sta $9129	   STA VIA2_T2CH     ; set VIA 2 T2C_h
.ef9b					W1MS_20
.ef9b	ad 2d 91	lda $912d	   LDA IEC_IFR       ; get VIA 2 IFR
.ef9e	29 20		and #$20	   AND #$20          ; mask T2 interrupt
.efa0	f0 f9		beq $ef9b	   BEQ W1MS_20      ; loop until T2 interrupt
.efa2	60		rts		   RTS
.efa3					  RS232_NMI_Transmit
.efa3	a5 b4		lda $b4		   LDA BITTS         ; get RS232 bit count
.efa5	f0 47		beq $efee	   BEQ RS232_Setup_Next_Byte_To_Send
.efa7	30 3f		bmi $efe8	   BMI RTra_40       ; if negative go do stop bit(s)
.efa9	46 b6		lsr $b6		   LSR RODATA        ; shift RS232 output byte buffer
.efab	a2 00		ldx #$00	   LDX #$00          ; set $00 for bit = 0
.efad	90 01		bcc $efb0	   BCC RTra_05       ; branch if bit was 0
.efaf	ca		dex		   DEX               ; set $FF for bit = 1
.efb0					RTra_05
.efb0	8a		txa		   TXA               ; copy bit to A
.efb1	45 bd		eor $bd		   EOR ROPRTY        ; EOR with RS232 parity byte
.efb3	85 bd		sta $bd		   STA ROPRTY        ; save RS232 parity byte
.efb5	c6 b4		dec $b4		   DEC BITTS         ; decrement RS232 bit count
.efb7	f0 06		beq $efbf	   BEQ RTra_15       ; if RS232 bit count now zero go do parity bit
.efb9					RTra_10
.efb9	8a		txa		   TXA               ; copy bit to A
.efba	29 20		and #$20	   AND #RS232_C_BIT  ; mask for CB2 control bit
.efbc	85 b5		sta $b5		   STA NXTBIT        ; save RS232 next bit to send
.efbe	60		rts		   RTS
.efbf					RTra_15
.efbf	a9 20		lda #$20	   LDA #$20          ; mask 00x0 0000, parity enable bit
.efc1	2c 94 02	bit $0294	   BIT M51CDR        ; test pseudo 6551 command register
.efc4	f0 14		beq $efda	   BEQ RTra_30       ; branch if parity disabled
.efc6	30 1c		bmi $efe4	   BMI RTra_35       ; branch if fixed mark or space parity
.efc8	70 14		bvs $efde	   BVS RTra_32       ; branch if even parity
.efca	a5 bd		lda $bd		   LDA ROPRTY        ; get RS232 parity byte
.efcc	d0 01		bne $efcf	   BNE RTra_25       ; if parity not zero leave parity bit = 0
.efce					RTra_20
.efce	ca		dex		   DEX               ; make parity bit = 1
.efcf					RTra_25
.efcf	c6 b4		dec $b4		   DEC BITTS         ; decrement RS232 bit count, 1 stop bit
.efd1	ad 93 02	lda $0293	   LDA M51CTR        ; get pseudo 6551 control register
.efd4	10 e3		bpl $efb9	   BPL RTra_10       ; if 1 stop bit save parity bit and exit
.efd6	c6 b4		dec $b4		   DEC BITTS         ; decrement RS232 bit count, 2 stop bits
.efd8	d0 df		bne $efb9	   BNE RTra_10       ; save bit and exit, branch always
.efda					RTra_30
.efda	e6 b4		inc $b4		   INC BITTS         ; increment RS232 bit count, = -1 stop bit
.efdc	d0 f0		bne $efce	   BNE RTra_20       ; set stop bit = 1 and exit
.efde					RTra_32
.efde	a5 bd		lda $bd		   LDA ROPRTY        ; get RS232 parity byte
.efe0	f0 ed		beq $efcf	   BEQ RTra_25       ; if parity zero leave parity bit = 0
.efe2	d0 ea		bne $efce	   BNE RTra_20       ; else make parity bit = 1, branch always
.efe4					RTra_35
.efe4	70 e9		bvs $efcf	   BVS RTra_25       ; if fixed space parity leave parity bit = 0
.efe6	50 e6		bvc $efce	   BVC RTra_20       ; else fixed mark parity make parity bit = 1, branch always
.efe8					RTra_40
.efe8	e6 b4		inc $b4		   INC BITTS         ; decrement RS232 bit count
.efea	a2 ff		ldx #$ff	   LDX #$FF          ; set stop bit = 1
.efec	d0 cb		bne $efb9	   BNE RTra_10       ; save stop bit and exit, branch always
.efee					  RS232_Setup_Next_Byte_To_Send
.efee	ad 94 02	lda $0294	   LDA M51CDR        ; get 6551 pseudo command register
.eff1	4a		lsr a		   LSR A             ; handshake bit inot Cb
.eff2	90 07		bcc $effb	   BCC RSNB_10       ; branch if 3 line interface
.eff4	2c 20 91	bit $9120	   BIT $9120         ; test VIA 2 DRB, this is wrong
.eff7	10 1d		bpl $f016	   BPL RS232_No_DSR_Signal
.eff9	50 1e		bvc $f019	   BVC RNDS_10      ; if CTS = 0 set CTS signal not present and exit
.effb					RSNB_10
.effb	a9 00		lda #$00	   LDA #0
.effd	85 bd		sta $bd		   STA ROPRTY        ; clear RS232 parity byte
.efff	85 b5		sta $b5		   STA NXTBIT        ; clear RS232 next bit to send
.f001	ae 98 02	ldx $0298	   LDX BITNUM        ; get number of bits to be sent/received
.f004	86 b4		stx $b4		   STX BITTS         ; set RS232 bit count
.f006	ac 9d 02	ldy $029d	   LDY RODBS         ; get index to Tx buffer start
.f009	cc 9e 02	cpy $029e	   CPY RODBE         ; compare with index to Tx buffer end
.f00c	f0 13		beq $f021	   BEQ RNDS_20      ; if all done go disable T1 interrupt and return
.f00e	b1 f9		lda ($f9),y	   LDA (TXPTR),Y     ; else get byte from buffer
.f010	85 b6		sta $b6		   STA RODATA        ; save to RS232 output byte buffer
.f012	ee 9d 02	inc $029d	   INC RODBS         ; increment index to Tx buffer start
.f015	60		rts		   RTS
.f016					  RS232_No_DSR_Signal
.f016	a9 40		lda #$40	   LDA #$40          ; set DSR signal not present
>f018	2c				   .byte   $2C
.f019					RNDS_10
.f019	a9 10		lda #$10	   LDA #$10          ; set CTS signal not present
.f01b	0d 97 02	ora $0297	   ORA RSSTAT        ; OR with RS232 status register
.f01e	8d 97 02	sta $0297	   STA RSSTAT        ; save RS232 status register
.f021					RNDS_20
.f021	a9 40		lda #$40	   LDA #$40          ; disable T1 interrupt
.f023	8d 1e 91	sta $911e	   STA VIA1_IER      ; set VIA 1 IER
.f026	60		rts		   RTS
.f027					  RS232_Set_Data_Bits
.f027	a2 09		ldx #$09	   LDX #$09          ; set bit count to 9, 8 data + 1 stop bit
.f029	a9 20		lda #$20	   LDA #$20          ; mask for 8/7 data bits
.f02b	2c 93 02	bit $0293	   BIT M51CTR        ; test pseudo 6551 control register
.f02e	f0 01		beq $f031	   BEQ RSDB_10       ; branch if 8 bits
.f030	ca		dex		   DEX               ; else decrement count for 7 data bits
.f031					RSDB_10
.f031	50 02		bvc $f035	   BVC RSDB_20       ; branch if 7 bits
.f033	ca		dex		   DEX               ; else decrement count ..
.f034	ca		dex		   DEX               ; .. for 5 data bits
.f035					RSDB_20
.f035	60		rts		   RTS
.f036					  RS232_NMI_Receive
.f036	a6 a9		ldx $a9		   LDX RINONE        ; get start bit check flag
.f038	d0 2e		bne $f068	   BNE RRec_25       ; branch if no start bit received
.f03a	c6 a8		dec $a8		   DEC BITCI         ; decrement receiver bit count in
.f03c	f0 31		beq $f06f	   BEQ RRec_30
.f03e	30 0d		bmi $f04d	   BMI RRec_15
.f040	a5 a7		lda $a7		   LDA INBIT
.f042	45 ab		eor $ab		   EOR RIPRTY
.f044	85 ab		sta $ab		   STA RIPRTY
.f046	46 a7		lsr $a7		   LSR INBIT         ; shift receiver input bit temporary storage
.f048	66 aa		ror $aa		   ROR RIDATA
.f04a					RRec_05
.f04a	60		rts		   RTS
.f04b					RRec_10
.f04b	c6 a8		dec $a8		   DEC BITCI         ; decrement receiver bit count in
.f04d					RRec_15
.f04d	a5 a7		lda $a7		   LDA INBIT         ; get receiver input bit temporary storage
.f04f	f0 62		beq $f0b3	   BEQ RRec_65
.f051	ad 93 02	lda $0293	   LDA M51CTR        ; get pseudo 6551 control register
.f054	0a		asl a		   ASL A
.f055	a9 01		lda #$01	   LDA #$01
.f057	65 a8		adc $a8		   ADC BITCI         ; add receiver bit count in
.f059	d0 ef		bne $f04a	   BNE RRec_05
.f05b					RRec_20
.f05b	a9 90		lda #$90	   LDA #$90          ; enable CB1 interrupt
.f05d	8d 1e 91	sta $911e	   STA RS2_IRQ_REG   ; set VIA 1 IER
.f060	85 a9		sta $a9		   STA RINONE        ; set start bit check flag, set no start bit received
.f062	a9 20		lda #$20	   LDA #$20          ; disable T2 interrupt
.f064	8d 1e 91	sta $911e	   STA RS2_IRQ_REG   ; set VIA 1 IER
.f067	60		rts		   RTS
.f068					RRec_25
.f068	a5 a7		lda $a7		   LDA INBIT         ; get receiver input bit temporary storage
.f06a	d0 ef		bne $f05b	   BNE RRec_20
.f06c	85 a9		sta $a9		   STA RINONE        ; set start bit check flag, set start bit received
.f06e	60		rts		   RTS
.f06f					RRec_30
.f06f	ac 9b 02	ldy $029b	   LDY RIDBE         ; get index to Rx buffer end
.f072	c8		iny		   INY
.f073	cc 9c 02	cpy $029c	   CPY RIDBS         ; compare with index to Rx buffer start
.f076	f0 2a		beq $f0a2	   BEQ RRec_50       ; if buffer full go do Rx overrun error
.f078	8c 9b 02	sty $029b	   STY RIDBE         ; save index to Rx buffer end
.f07b	88		dey		   DEY               ; decrement index
.f07c	a5 aa		lda $aa		   LDA RIDATA        ; get assembled byte
.f07e	ae 98 02	ldx $0298	   LDX BITNUM        ; get bit count
.f081					RRec_35
.f081	e0 09		cpx #$09	   CPX #$09          ; compare with byte + stop
.f083	f0 04		beq $f089	   BEQ RRec_40       ; branch if all nine bits received
.f085	4a		lsr a		   LSR A             ; else shift byte
.f086	e8		inx		   INX               ; increment bit count
.f087	d0 f8		bne $f081	   BNE RRec_35       ; loop, branch always
.f089					RRec_40
.f089	91 f7		sta ($f7),y	   STA (RXPTR),Y     ; save received byte to Rx buffer
.f08b	a9 20		lda #$20	   LDA #$20          ; mask 00x0 0000, parity enable bit
.f08d	2c 94 02	bit $0294	   BIT M51CDR        ; test pseudo 6551 command register
.f090	f0 b9		beq $f04b	   BEQ RRec_10       ; branch if parity disabled
.f092	30 b6		bmi $f04a	   BMI RRec_05       ; branch if mark or space parity
.f094	a5 a7		lda $a7		   LDA INBIT         ; get receiver input bit temporary storage
.f096	45 ab		eor $ab		   EOR RIPRTY
.f098	f0 03		beq $f09d	   BEQ RRec_45
.f09a	70 ae		bvs $f04a	   BVS RRec_05
>f09c	2c				   .byte   $2C
.f09d					RRec_45
.f09d	50 ab		bvc $f04a	   BVC RRec_05
.f09f	a9 01		lda #$01	   LDA #$01          ; set Rx parity error
>f0a1	2c				   .byte   $2C
.f0a2					RRec_50
.f0a2	a9 04		lda #$04	   LDA #$04          ; set Rx overrun error
>f0a4	2c				   .byte   $2C
.f0a5					RRec_55
.f0a5	a9 80		lda #$80	   LDA #$80          ; Rx break error
>f0a7	2c				   .byte   $2C
.f0a8					RRec_60
.f0a8	a9 02		lda #$02	   LDA #$02          ; Rx frame error
.f0aa	0d 97 02	ora $0297	   ORA RSSTAT        ; OR with RS232 status byte
.f0ad	8d 97 02	sta $0297	   STA RSSTAT        ; save RS232 status byte
.f0b0	4c 5b f0	jmp $f05b	   JMP RRec_20
.f0b3					RRec_65
.f0b3	a5 aa		lda $aa		   LDA RIDATA
.f0b5	d0 f1		bne $f0a8	   BNE RRec_60      ; if ?? do frame error
.f0b7	f0 ec		beq $f0a5	   BEQ RRec_55      ; else do break error, branch always
.f0b9					RRec_70
.f0b9	4c 96 f7	jmp $f796	   JMP Illegal_Jiffy_Device
.f0bc					  RS232_CHKOUT
.f0bc	85 9a		sta $9a		   STA DFLTO         ; save output device number
.f0be	ad 94 02	lda $0294	   LDA M51CDR        ; get pseudo 6551 command register
.f0c1	4a		lsr a		   LSR A             ; shift handshake bit to carry
.f0c2	90 27		bcc $f0eb	   BCC RSSN_10       ; branch if 3 line interface
.f0c4	a9 02		lda #$02	   LDA #$02          ; mask for RTS out
.f0c6	2c 10 91	bit $9110	   BIT RS2_DSR_CTS   ; test VIA 1 DRB
.f0c9	10 1d		bpl $f0e8	   BPL RS232_Set_Status_No_Signal
.f0cb	d0 1e		bne $f0eb	   BNE RSSN_10       ; if RTS = 1 just exit
.f0cd					RCHO_10
.f0cd	ad 1e 91	lda $911e	   LDA VIA1_IER      ; get VIA 1 IER
.f0d0	29 30		and #$30	   AND #$30          ; mask 00xx 0000, T2 and CB1 interrupts
.f0d2	d0 f9		bne $f0cd	   BNE RCHO_10       ; loop while either enabled
.f0d4					RCHO_20
.f0d4	2c 10 91	bit $9110	   BIT RS2_DSR_CTS   ; test VIA 1 DRB
.f0d7	70 fb		bvs $f0d4	   BVS RCHO_20       ; loop while CTS high
.f0d9	ad 10 91	lda $9110	   LDA RS2_DSR_CTS   ; get VIA 1 DRB
.f0dc	09 02		ora #$02	   ORA #$02          ; set RTS high
.f0de	8d 10 91	sta $9110	   STA RS2_DSR_CTS   ; save VIA 1 DRB
.f0e1					RCHO_30
.f0e1	2c 10 91	bit $9110	   BIT RS2_DSR_CTS   ; test VIA 1 DRB
.f0e4	70 05		bvs $f0eb	   BVS RSSN_10       ; exit if CTS high
.f0e6	30 f9		bmi $f0e1	   BMI RCHO_30       ; loop while DSR high
.f0e8					  RS232_Set_Status_No_Signal
.f0e8	20 16 f0	jsr $f016	   JSR RS232_No_DSR_Signal
.f0eb					RSSN_10
.f0eb	18		clc		   CLC               ; flag ok
.f0ec	60		rts		   RTS
.f0ed					  RS232_Put_Byte_To_Buffer
.f0ed	ac 9e 02	ldy $029e	   LDY RODBE         ; get index to Tx buffer end
.f0f0	c8		iny		   INY               ; + 1
.f0f1	cc 9d 02	cpy $029d	   CPY RODBS         ; compare with index to Tx buffer start
.f0f4	f0 f7		beq $f0ed	   BEQ RS232_Put_Byte_To_Buffer
.f0f6	8c 9e 02	sty $029e	   STY RODBE         ; set index to Tx buffer end
.f0f9	88		dey		   DEY               ; index to available buffer byte
.f0fa	91 f9		sta ($f9),y	   STA (TXPTR),Y     ; save byte to buffer
.f0fc					RPBB_20
.f0fc	2c 1e 91	bit $911e	   BIT VIA1_IER      ; test VIA 1 IER
.f0ff	50 01		bvc $f102	   BVC RPBB_30       ; branch if T1 not enabled
.f101	60		rts		   RTS
.f102					RPBB_30
.f102	ad 99 02	lda $0299	   LDA BAUDOF        ; get baud rate bit time low byte
.f105	8d 14 91	sta $9114	   STA RS2_TIM_LOW   ; set VIA 1 T1C_l
.f108	ad 9a 02	lda $029a	   LDA BAUDOF+1      ; get baud rate bit time high byte
.f10b	8d 15 91	sta $9115	   STA RS2_TIM_HIG   ; set VIA 1 T1C_h
.f10e	a9 c0		lda #$c0	   LDA #$C0          ; enable T1 interrupt
.f110	8d 1e 91	sta $911e	   STA VIA1_IER      ; set VIA 1 IER
.f113	4c ee ef	jmp $efee	   JMP RS232_Setup_Next_Byte_To_Send
.f116					  RS232_CHKIN
.f116	85 99		sta $99		   STA DFLTN         ; save input device number
.f118	ad 94 02	lda $0294	   LDA M51CDR        ; get pseudo 6551 command register
.f11b	4a		lsr a		   LSR A
.f11c	90 28		bcc $f146	   BCC RCHI_40       ; branch if 3 line interface
.f11e	29 08		and #$08	   AND #$08          ; mask duplex bit, pseudo 6551 command is >> 1
.f120	f0 24		beq $f146	   BEQ RCHI_40       ; branch if full duplex
.f122	a9 02		lda #$02	   LDA #2
.f124	2c 10 91	bit $9110	   BIT RS2_DSR_CTS   ; test VIA 1 DRB
.f127	10 bf		bpl $f0e8	   BPL RS232_Set_Status_No_Signal
.f129	f0 19		beq $f144	   BEQ RCHI_50
.f12b					RCHI_10
.f12b	2c 1e 91	bit $911e	   BIT VIA1_IER      ; test VIA 1 IER
.f12e	70 fb		bvs $f12b	   BVS RCHI_10       ; loop while T1 interrupt enabled
.f130	ad 10 91	lda $9110	   LDA RS2_DSR_CTS   ; get VIA 1 DRB
.f133	29 fd		and #$fd	   AND #$FD          ; mask xxxx xx0x, clear RTS out
.f135	8d 10 91	sta $9110	   STA RS2_DSR_CTS   ; save VIA 1 DRB
.f138					RCHI_20
.f138	ad 10 91	lda $9110	   LDA RS2_DSR_CTS   ; get VIA 1 DRB
.f13b	29 04		and #$04	   AND #$04          ; mask xxxx x1xx, DTR
.f13d	f0 f9		beq $f138	   BEQ RCHI_20       ; loop while DTR low
.f13f					RCHI_30
.f13f	a9 90		lda #$90	   LDA #$90          ; enable CB1 interrupt
.f141	8d 1e 91	sta $911e	   STA VIA1_IER      ; set VIA 1 IER
.f144					RCHI_50
.f144	18		clc		   CLC
.f145	60		rts		   RTS
.f146					RCHI_40
.f146	ad 1e 91	lda $911e	   LDA VIA1_IER      ; get VIA 1 IER
.f149	29 30		and #$30	   AND #$30          ; mask 0xx0 0000, T1 and T2 interrupts
.f14b	f0 f2		beq $f13f	   BEQ RCHI_30       ; if both interrupts disabled go enable CB1
.f14d	18		clc		   CLC
.f14e	60		rts		   RTS
.f14f					  RS232_Get_Byte_From_Buffer
.f14f	ac 9c 02	ldy $029c	   LDY RIDBS         ; get index to Rx buffer start
.f152	cc 9b 02	cpy $029b	   CPY RIDBE         ; compare with index to Rx buffer end
.f155	f0 06		beq $f15d	   BEQ RGBB_10       ; return null if buffer empty
.f157	b1 f7		lda ($f7),y	   LDA (RXPTR),Y     ; get byte from Rx buffer
.f159	ee 9c 02	inc $029c	   INC RIDBS         ; increment index to Rx buffer start
.f15c	60		rts		   RTS
.f15d					RGBB_10
.f15d	a9 00		lda #$00	   LDA #$00          ; return null
.f15f	60		rts		   RTS
.f160					  RS232_Stop
.f160	48		pha		   PHA
.f161	ad 1e 91	lda $911e	   LDA RS2_IRQ_REG   ; get VIA 1 IER
.f164	f0 0c		beq $f172	   BEQ RSTP_30       ; branch if no interrupts enabled. this branch will
.f166					RSTP_20
.f166	ad 1e 91	lda $911e	   LDA RS2_IRQ_REG   ; get VIA 1 IER
.f169	29 60		and #$60	   AND #$60          ; mask 0xx0 0000, T1 and T2 interrupts
.f16b	d0 f9		bne $f166	   BNE RSTP_20       ; loop if T1 or T2 active
.f16d	a9 10		lda #$10	   LDA #$10          ; disable CB1 interrupt
.f16f	8d 1e 91	sta $911e	   STA RS2_IRQ_REG   ; set VIA 1 IER
.f172					RSTP_30
.f172	68		pla		   PLA
.f173	60		rts		   RTS
>f174	0d 49 2f 4f 20 45 52 52		Msg_Start     .SHIFT "\rI/O ERROR #" ;^
>f17c	4f 52 20 a3
>f180	0d 53 45 41 52 43 48 49		Msg_Searching .SHIFT "\rSEARCHING "  ;^
>f188	4e 47 a0
>f18b	46 4f 52 a0			Msg_FOR       .SHIFT "FOR "          ;^
>f18f	0d 50 52 45 53 53 20 50		Msg_Play      .SHIFT "\rPRESS PLAY ON TAPE"        ;^
>f197	4c 41 59 20 4f 4e 20 54 41 50 c5
>f1a2	50 52 45 53 53 20 52 45		Msg_Record    .SHIFT "PRESS RECORD & PLAY ON TAPE" ;^
>f1aa	43 4f 52 44 20 26 20 50 4c 41 59 20 4f 4e 20 54
>f1ba	41 50 c5
>f1bd	0d 4c 4f 41 44 49 4e c7		Msg_Loading   .SHIFT "\rLOADING"     ;^
>f1c5	0d 53 41 56 49 4e 47 a0		Msg_Saving    .SHIFT "\rSAVING "     ;^
>f1cd	0d 56 45 52 49 46 59 49		Msg_Verifying .SHIFT "\rVERIFYING"   ;^
>f1d5	4e c7
>f1d7	0d 46 4f 55 4e 44 a0		Msg_Found     .SHIFT "\rFOUND "      ;^
>f1de	0d 4f 4b 8d			Msg_okIO      .SHIFT "\rOK\r"        ;^
.f1e2					  Display_Direct_Msg
.f1e2	24 9d		bit $9d		   BIT MSGFLG        ; test message mode flag
.f1e4	10 0d		bpl $f1f3	   BPL DDM_10        ; exit if control messages off
.f1e6					  Display_Kernal_IO_Message
.f1e6	b9 74 f1	lda $f174,y	   LDA Msg_Start,Y    ; get byte from message table
.f1e9	08		php		   PHP               ; save status
.f1ea	29 7f		and #$7f	   AND #$7F          ; clear b7
.f1ec	20 d2 ff	jsr $ffd2	   JSR CHROUT        ; Output a character
.f1ef	c8		iny		   INY
.f1f0	28		plp		   PLP               ; restore status
.f1f1	10 f3		bpl $f1e6	   BPL Display_Kernal_IO_Message
.f1f3					DDM_10
.f1f3	18		clc		   CLC
.f1f4	60		rts		   RTS
.f1f5					  Kernal_GETIN
.f1f5	a5 99		lda $99		   LDA DFLTN         ; get input device number
.f1f7	d0 08		bne $f201	   BNE KeGE_10       ; branch if not keyboard
.f1f9	a5 c6		lda $c6		   LDA NDX           ; get keyboard buffer length
.f1fb	f0 6d		beq $f26a	   BEQ IGB_20      ; if buffer empty go flag no byte and return
.f1fd	78		sei		   SEI               ; disable inter/rupts
.f1fe	4c cf e5	jmp $e5cf	   JMP Get_Char_From_Keyboard_Buffer
.f201					KeGE_10
.f201	c9 02		cmp #$02	   CMP #$02          ; compare device with RS232 device
.f203	d0 18		bne $f21d	   BNE CHRI_05      ; branch if not RS232 device
.f205					  RS232_Get_Byte
.f205	84 97		sty $97		   STY TEMPX         ; save Y
.f207	20 4f f1	jsr $f14f	   JSR RS232_Get_Byte_From_Buffer
.f20a	a4 97		ldy $97		   LDY TEMPX         ; restore Y
.f20c					KeGE_20
.f20c	18		clc		   CLC               ; flag no error
.f20d	60		rts		   RTS
.f20e					  Kernal_CHRIN
.f20e	a5 99		lda $99		   LDA DFLTN         ; get input device number
.f210	d0 0b		bne $f21d	   BNE CHRI_05       ; if it's not the keyboard continue
.f212	a5 d3		lda $d3		   LDA CSRIDX        ; get cursor column
.f214	85 ca		sta $ca		   STA ICRCOL        ; set input cursor column
.f216	a5 d6		lda $d6		   LDA TBLX          ; get cursor row
.f218	85 c9		sta $c9		   STA ICRROW        ; set input cursor row
.f21a	4c 4f e6	jmp $e64f	   JMP CHRIN_Keyboard_Or_Screen
.f21d					CHRI_05
.f21d	c9 03		cmp #$03	   CMP #$03          ; compare device number with screen
.f21f	d0 09		bne $f22a	   BNE CHRI_10       ; if it's not the screen continue
.f221					CHRI_07
.f221	85 d0		sta $d0		   STA INSRC         ; input from keyboard or screen, $xx = screen,
.f223	a5 d5		lda $d5		   LDA LINLEN        ; get current screen line length
.f225	85 c8		sta $c8		   STA INDX          ; save input [EOL] pointer
.f227	4c 4f e6	jmp $e64f	   JMP CHRIN_Keyboard_Or_Screen
.f22a					CHRI_10
.f22a	b0 38		bcs $f264	   BCS IEC_Get_Byte
.f22c	c9 02		cmp #$02	   CMP #$02          ; compare device with RS232 device
.f22e	f0 3f		beq $f26f	   BEQ RS232_Read_Byte
.f230	86 97		stx $97		   STX TEMPX         ; save X
.f232	20 50 f2	jsr $f250	   JSR TAPE_Get_Byte
.f235	b0 16		bcs $f24d	   BCS CHRI_25       ; exit if error
.f237	48		pha		   PHA               ; save byte
.f238	20 50 f2	jsr $f250	   JSR TAPE_Get_Byte
.f23b	b0 0d		bcs $f24a	   BCS CHRI_20       ; exit if error
.f23d	d0 05		bne $f244	   BNE CHRI_15       ; branch if end reached
.f23f	a9 40		lda #$40	   LDA #$40          ; set [EOF] bit
.f241	20 6a fe	jsr $fe6a	   JSR Ora_Status
.f244					CHRI_15
.f244	c6 a6		dec $a6		   DEC BUFPNT        ; decrement tape buffer index
.f246	a6 97		ldx $97		   LDX TEMPX         ; restore X
.f248	68		pla		   PLA               ; restore saved byte
.f249	60		rts		   RTS
.f24a					CHRI_20
.f24a	aa		tax		   TAX               ; copy error byte ??
.f24b	68		pla		   PLA               ; dump saved byte
.f24c	8a		txa		   TXA               ; restore error byte ??
.f24d					CHRI_25
.f24d	a6 97		ldx $97		   LDX TEMPX         ; restore X
.f24f	60		rts		   RTS
.f250					  TAPE_Get_Byte
.f250	20 8a f8	jsr $f88a	   JSR TAPE_Advance_Buffer_Pointer
.f253	d0 0b		bne $f260	   BNE TGB_05        ; if not end get next byte and exit
.f255	20 c0 f8	jsr $f8c0	   JSR TAPE_Init_Read
.f258	b0 11		bcs $f26b	   BCS IGB_30      ; exit if error flagged
.f25a	a9 00		lda #$00	   LDA #0
.f25c	85 a6		sta $a6		   STA BUFPNT        ; clear tape buffer index
.f25e	f0 f0		beq $f250	   BEQ TAPE_Get_Byte ; branch always
.f260					TGB_05
.f260	b1 b2		lda ($b2),y	   LDA (TAPE1),Y     ; get next byte from buffer
.f262	18		clc		   CLC               ; flag no error
.f263	60		rts		   RTS
.f264					  IEC_Get_Byte
.f264	a5 90		lda $90		   LDA STATUS        ; get serial status byte
.f266	f0 04		beq $f26c	   BEQ IGB_40        ; if no errors flagged go input byte and return
.f268					IGB_10
.f268	a9 0d		lda #$0d	   LDA #$0D          ; else return [EOL]
.f26a					IGB_20
.f26a	18		clc		   CLC               ; flag no error
.f26b					IGB_30
.f26b	60		rts		   RTS
.f26c					IGB_40
.f26c	4c 19 ef	jmp $ef19	   JMP Kernal_ACPTR
.f26f					  RS232_Read_Byte
.f26f	20 05 f2	jsr $f205	   JSR RS232_Get_Byte
.f272	b0 05		bcs $f279	   BCS RRB_Ret       ; branch if error, this doesn't get taken as the last
.f274	c9 00		cmp #$00	   CMP #$00          ; compare with null
.f276	f0 f7		beq $f26f	   BEQ RS232_Read_Byte      ; loop if null
.f278	18		clc		   CLC               ; flag no error
.f279					RRB_Ret
.f279	60		rts		   RTS
.f27a					  Kernal_CHROUT
.f27a	48		pha		   PHA               ; save the character to send
.f27b	a5 9a		lda $9a		   LDA DFLTO         ; get output device number
.f27d	c9 03		cmp #$03	   CMP #$03          ; compare device number with screen
.f27f	d0 04		bne $f285	   BNE KeCO_10       ; if output device not screen continue
.f281	68		pla		   PLA               ; restore character to send
.f282	4c 42 e7	jmp $e742	   JMP Screen_CHROUT ; output character and return
.f285					KeCO_10
.f285	90 04		bcc $f28b	   BCC KeCO_20       ; if output device < screen continue
.f287	68		pla		   PLA               ; restore character to send
.f288	4c e4 ee	jmp $eee4	   JMP Kernal_CIOUT  ; output a byte to the serial bus and return
.f28b					KeCO_20
.f28b	c9 02		cmp #$02	   CMP #$02          ; compare the device with RS232 device
.f28d	f0 2a		beq $f2b9	   BEQ RS232_Send_Byte
.f28f	68		pla		   PLA               ; restore the character to send
.f290					  TAPE_Send_Byte
.f290	85 9e		sta $9e		   STA PTR1          ; save character to character buffer
.f292	48		pha		   PHA               ; save A
.f293	8a		txa		   TXA               ; copy X
.f294	48		pha		   PHA               ; save X
.f295	98		tya		   TYA               ; copy Y
.f296	48		pha		   PHA               ; save Y
.f297	20 8a f8	jsr $f88a	   JSR TAPE_Advance_Buffer_Pointer
.f29a	d0 0e		bne $f2aa	   BNE TASB_10       ; if not end save next byte and exit
.f29c	20 e3 f8	jsr $f8e3	   JSR Init_Tape_Write
.f29f	b0 0e		bcs $f2af	   BCS TASB_30       ; exit if error
.f2a1	a9 02		lda #$02	   LDA #$02          ; set data block type ??
.f2a3	a0 00		ldy #$00	   LDY #0
.f2a5	91 b2		sta ($b2),y	   STA (TAPE1),Y     ; save type to buffer ??
.f2a7	c8		iny		   INY
.f2a8	84 a6		sty $a6		   STY BUFPNT        ; save tape buffer index
.f2aa					TASB_10
.f2aa	a5 9e		lda $9e		   LDA PTR1          ; restore character from character buffer
.f2ac	91 b2		sta ($b2),y	   STA (TAPE1),Y     ; save to buffer
.f2ae					TASB_20
.f2ae	18		clc		   CLC               ; flag no error
.f2af					TASB_30
.f2af	68		pla		   PLA               ; pull Y
.f2b0	a8		tay		   TAY               ; restore Y
.f2b1	68		pla		   PLA               ; pull X
.f2b2	aa		tax		   TAX               ; restore X
.f2b3	68		pla		   PLA               ; restore A
.f2b4	90 02		bcc $f2b8	   BCC TASB_40       ; exit if no error
.f2b6	a9 00		lda #$00	   LDA #$00          ; else clear A
.f2b8					TASB_40
.f2b8	60		rts		   RTS
.f2b9					  RS232_Send_Byte
.f2b9	68		pla		   PLA               ; restore character to send
.f2ba	86 97		stx $97		   STX TEMPX         ; save X
.f2bc	84 9e		sty $9e		   STY PTR1          ; save Y
.f2be	20 ed f0	jsr $f0ed	   JSR RS232_Put_Byte_To_Buffer
.f2c1	a6 97		ldx $97		   LDX TEMPX         ; restore Y
.f2c3	a4 9e		ldy $9e		   LDY PTR1          ; restore X
.f2c5	18		clc		   CLC               ; flag ok
.f2c6	60		rts		   RTS
.f2c7					  Kernal_ICHKIN
.f2c7	20 cf f3	jsr $f3cf	   JSR Find_File_X
.f2ca	f0 03		beq $f2cf	   BEQ KICH_10       ; branch if file opened
.f2cc	4c 84 f7	jmp $f784	   JMP File_Not_Open
.f2cf					KICH_10
.f2cf	20 df f3	jsr $f3df	   JSR Get_LFS
.f2d2	a5 ba		lda $ba		   LDA FA            ; get device number
.f2d4	f0 16		beq $f2ec	   BEQ KICH_30       ; if device was keyboard save device #, flag ok and exit
.f2d6	c9 03		cmp #$03	   CMP #$03          ; compare device number with screen
.f2d8	f0 12		beq $f2ec	   BEQ KICH_30       ; if device was screen save device #, flag ok and exit
.f2da	b0 14		bcs $f2f0	   BCS KICH_40       ; branch if serial bus device
.f2dc	c9 02		cmp #$02	   CMP #$02          ; compare device with RS232 device
.f2de	d0 03		bne $f2e3	   BNE KICH_20       ; branch if not RS 232 device
.f2e0	4c 16 f1	jmp $f116	   JMP RS232_CHKIN
.f2e3					KICH_20
.f2e3	a6 b9		ldx $b9		   LDX SA            ; get secondary address
.f2e5	e0 60		cpx #$60	   CPX #$60
.f2e7	f0 03		beq $f2ec	   BEQ KICH_30
.f2e9	4c 8d f7	jmp $f78d	   JMP Not_Input_File
.f2ec					KICH_30
.f2ec	85 99		sta $99		   STA DFLTN         ; save input device number
.f2ee	18		clc		   CLC               ; flag ok
.f2ef	60		rts		   RTS
.f2f0					KICH_40
.f2f0	aa		tax		   TAX               ; copy device number to X
.f2f1	20 14 ee	jsr $ee14	   JSR Kernal_TALK   ; command a serial bus device to TALK
.f2f4	a5 b9		lda $b9		   LDA SA            ; get secondary address
.f2f6	10 06		bpl $f2fe	   BPL KICH_50
.f2f8	20 d3 ee	jsr $eed3	   JSR IEC_Finish_Send
.f2fb	4c 01 f3	jmp $f301	   JMP KICH_60
.f2fe					KICH_50
.f2fe	20 ce ee	jsr $eece	   JSR Kernal_TKSA   ; send secondary address after TALK
.f301					KICH_60
.f301	8a		txa		   TXA               ; copy device back to A
.f302	24 90		bit $90		   BIT STATUS        ; test serial status byte
.f304	10 e6		bpl $f2ec	   BPL KICH_30       ; if device present save device number and exit
.f306	4c 8a f7	jmp $f78a	   JMP Dev_Not_Present      ; do device not present error and return
.f309					  Kernal_CHKOUT
.f309	20 cf f3	jsr $f3cf	   JSR Find_File_X
.f30c	f0 03		beq $f311	   BEQ KCHO_10       ; branch if file found
.f30e	4c 84 f7	jmp $f784	   JMP File_Not_Open
.f311					KCHO_10
.f311	20 df f3	jsr $f3df	   JSR Get_LFS
.f314	a5 ba		lda $ba		   LDA FA            ; get device number
.f316	d0 03		bne $f31b	   BNE KCHO_30       ; branch if device is not keyboard
.f318					KCHO_20
.f318	4c 90 f7	jmp $f790	   JMP Not_Output_File
.f31b					KCHO_30
.f31b	c9 03		cmp #$03	   CMP #$03          ; compare device number with screen
.f31d	f0 0f		beq $f32e	   BEQ KCHO_50       ; if screen save output device number and exit
.f31f	b0 11		bcs $f332	   BCS KCHO_60       ; branch if > screen, serial bus device
.f321	c9 02		cmp #$02	   CMP #$02          ; compare device with RS232 device
.f323	d0 03		bne $f328	   BNE KCHO_40       ; branch if not RS232 device, must be tape
.f325	4c bc f0	jmp $f0bc	   JMP RS232_CHKOUT
.f328					KCHO_40
.f328	a6 b9		ldx $b9		   LDX SA            ; get secondary address
.f32a	e0 60		cpx #$60	   CPX #$60
.f32c	f0 ea		beq $f318	   BEQ KCHO_20       ; if ?? do not output file error and return
.f32e					KCHO_50
.f32e	85 9a		sta $9a		   STA DFLTO         ; save output device number
.f330	18		clc		   CLC               ; flag ok
.f331	60		rts		   RTS
.f332					KCHO_60
.f332	aa		tax		   TAX               ; copy device number
.f333	20 17 ee	jsr $ee17	   JSR Kernal_LISTEN ; command devices on the serial bus to LISTEN
.f336	a5 b9		lda $b9		   LDA SA            ; get secondary address
.f338	10 05		bpl $f33f	   BPL KCHO_70       ; branch if address to send
.f33a	20 c5 ee	jsr $eec5	   JSR IEC_ATN_High
.f33d	d0 03		bne $f342	   BNE KCHO_80       ; branch always
.f33f					KCHO_70
.f33f	20 c0 ee	jsr $eec0	   JSR Kernal_SECOND ; send secondary address after LISTEN
.f342					KCHO_80
.f342	8a		txa		   TXA               ; copy device number back to A
.f343	24 90		bit $90		   BIT STATUS        ; test serial status byte
.f345	10 e7		bpl $f32e	   BPL KCHO_50       ; if device present save output device number and exit
.f347	4c 8a f7	jmp $f78a	   JMP Dev_Not_Present      ; else do device not present error and return
.f34a					  Kernal_CLOSE
.f34a	20 d4 f3	jsr $f3d4	   JSR Find_File_A
.f34d	f0 02		beq $f351	   BEQ KeCL_10       ; if the file is found go close it
.f34f	18		clc		   CLC               ; else the file was closed so just flag ok
.f350	60		rts		   RTS
.f351					KeCL_10
.f351	20 df f3	jsr $f3df	   JSR Get_LFS
.f354	8a		txa		   TXA               ; copy file index to A
.f355	48		pha		   PHA               ; save file index
.f356	a5 ba		lda $ba		   LDA FA            ; get device number
.f358	f0 57		beq $f3b1	   BEQ KeCL_80       ; if $00, keyboard, restore index and close file
.f35a	c9 03		cmp #$03	   CMP #3            ; compare device number with screen
.f35c	f0 53		beq $f3b1	   BEQ KeCL_80       ; if screen restore index and close file
.f35e	b0 4e		bcs $f3ae	   BCS KeCL_70       ; if > screen go do serial bus device close
.f360	c9 02		cmp #$02	   CMP #2            ; compare device with RS232 device
.f362	d0 29		bne $f38d	   BNE KeCL_40       ; branch if not RS232 device
.f364	68		pla		   PLA               ; restore file index
.f365	20 b2 f3	jsr $f3b2	   JSR Close_File
.f368	a9 7d		lda #$7d	   LDA #$7D          ; disable T1, T2, CB1, CB2, SR and CA2
.f36a	8d 1e 91	sta $911e	   STA RS2_IRQ_REG   ; set VIA 1 IER
.f36d	a9 06		lda #$06	   LDA #$06          ; set DTR and RTS high
.f36f	8d 10 91	sta $9110	   STA RS2_DSR_CTS   ; set VIA 1 DRB
.f372	a9 ee		lda #$ee	   LDA #$EE          ; CB2 high, CB1 negative edge, CA2 high, CA1 negative edge
.f374	8d 1c 91	sta $911c	   STA VIA1_PCR      ; set VIA 1 PCR
.f377	20 75 fe	jsr $fe75	   JSR Read_Memtop
.f37a	a5 f8		lda $f8		   LDA RXPTR+1       ; get RS232 input buffer pointer high byte
.f37c	f0 01		beq $f37f	   BEQ KeCL_20       ; branch if no RS232 input buffer
.f37e	c8		iny		   INY               ; else reclaim RS232 input buffer memory
.f37f					KeCL_20
.f37f	a5 fa		lda $fa		   LDA TXPTR+1       ; get RS232 output buffer pointer high byte
.f381	f0 01		beq $f384	   BEQ KeCL_30       ; branch if no RS232 output buffer
.f383	c8		iny		   INY               ; else reclaim RS232 output buffer memory
.f384					KeCL_30
.f384	a9 00		lda #$00	   LDA #0
.f386	85 f8		sta $f8		   STA RXPTR+1       ; clear RS232 input buffer pointer high byte
.f388	85 fa		sta $fa		   STA TXPTR+1       ; clear RS232 output buffer pointer high byte
.f38a	4c 3c f5	jmp $f53c	   JMP ROPN_45       ; go set top of memory and exit
.f38d					KeCL_40
.f38d	a5 b9		lda $b9		   LDA SA            ; get secondary address
.f38f	29 0f		and #$0f	   AND #$0F
.f391	f0 1e		beq $f3b1	   BEQ KeCL_80
.f393	20 4d f8	jsr $f84d	   JSR TAPE_Get_Buffer_Address
.f396	a9 00		lda #$00	   LDA #0
.f398	20 90 f2	jsr $f290	   JSR TAPE_Send_Byte
.f39b	4c cf e4	jmp $e4cf	   JMP Close_Patch   ; go do CLOSE tail
.f39e					KeCL_50
.f39e	b0 2e		bcs $f3ce	   BCS ClFi_Ret      ; just exit if error
.f3a0					KeCL_60
.f3a0	a5 b9		lda $b9		   LDA SA            ; get secondary address
.f3a2	c9 62		cmp #$62	   CMP #$62
.f3a4	d0 0b		bne $f3b1	   BNE KeCL_80
.f3a6	a9 05		lda #$05	   LDA #$05          ; set logical end of the tape
.f3a8	20 e7 f7	jsr $f7e7	   JSR TAPE_Write_Header
.f3ab	4c b1 f3	jmp $f3b1	   JMP KeCL_80       ; restore index and close file
.f3ae					KeCL_70
.f3ae	20 da f6	jsr $f6da	   JSR IEC_Close
.f3b1					KeCL_80
.f3b1	68		pla		   PLA               ; restore file index
.f3b2					  Close_File
.f3b2	aa		tax		   TAX               ; copy index to file to close
.f3b3					ClFi_05
.f3b3	c6 98		dec $98		   DEC LDTND         ; decrement open file count
.f3b5	e4 98		cpx $98		   CPX LDTND         ; compare index with open file count
.f3b7	f0 14		beq $f3cd	   BEQ ClFi_10       ; exit if equal, last entry was closing file
.f3b9	a4 98		ldy $98		   LDY LDTND         ; get open file count as index
.f3bb	b9 59 02	lda $0259,y	   LDA FILTBL,Y      ; get last+1 logical file number from logical file table
.f3be	9d 59 02	sta $0259,x	   STA FILTBL,X      ; save logical file number over closed file
.f3c1	b9 63 02	lda $0263,y	   LDA DEVTBL,Y      ; get last+1 device number from device number table
.f3c4	9d 63 02	sta $0263,x	   STA DEVTBL,X      ; save device number over closed file
.f3c7	b9 6d 02	lda $026d,y	   LDA SECATB,Y      ; get last+1 secondary address from secondary address table
.f3ca	9d 6d 02	sta $026d,x	   STA SECATB,X      ; save secondary address over closed file
.f3cd					ClFi_10
.f3cd	18		clc		   CLC
.f3ce					ClFi_Ret
.f3ce	60		rts		   RTS
.f3cf					  Find_File_X
.f3cf	a9 00		lda #$00	   LDA #0
.f3d1	85 90		sta $90		   STA STATUS        ; clear serial status byte
.f3d3	8a		txa		   TXA               ; copy logical file number to A
.f3d4					  Find_File_A
.f3d4	a6 98		ldx $98		   LDX LDTND         ; get open file count
.f3d6					FiFi_10
.f3d6	ca		dex		   DEX               ; decrememnt count to give index
.f3d7	30 15		bmi $f3ee	   BMI GLFS_Ret      ; exit if no files
.f3d9	dd 59 02	cmp $0259,x	   CMP FILTBL,X      ; compare logical file number with table logical file number
.f3dc	d0 f8		bne $f3d6	   BNE FiFi_10       ; loop if no match
.f3de	60		rts		   RTS
.f3df					  Get_LFS
.f3df	bd 59 02	lda $0259,x	   LDA FILTBL,X      ; get logical file from logical file table
.f3e2	85 b8		sta $b8		   STA LA            ; set logical file
.f3e4	bd 63 02	lda $0263,x	   LDA DEVTBL,X      ; get device number from device number table
.f3e7	85 ba		sta $ba		   STA FA            ; set device number
.f3e9	bd 6d 02	lda $026d,x	   LDA SECATB,X      ; get secondary address from secondary address table
.f3ec	85 b9		sta $b9		   STA SA            ; set secondary address
.f3ee					GLFS_Ret
.f3ee	60		rts		   RTS
.f3ef					  Kernal_CLALL
.f3ef	a9 00		lda #$00	   LDA #0
.f3f1	85 98		sta $98		   STA LDTND         ; clear open file count
.f3f3					  Kernal_CLRCHN
.f3f3	a2 03		ldx #$03	   LDX #$03          ; set X to screen
.f3f5	e4 9a		cpx $9a		   CPX DFLTO         ; compare output device number with screen
.f3f7	b0 03		bcs $f3fc	   BCS KeCC_10       ; branch if >= screen
.f3f9	20 04 ef	jsr $ef04	   JSR Kernal_UNLSN  ; command the serial bus to UNLISTEN
.f3fc					KeCC_10
.f3fc	e4 99		cpx $99		   CPX DFLTN         ; compare input device number with screen
.f3fe	b0 03		bcs $f403	   BCS KeCC_20       ; branch if >= screen
.f400	20 f6 ee	jsr $eef6	   JSR Kernal_UNTLK  ; command the serial bus to UNTALK
.f403					KeCC_20
.f403	86 9a		stx $9a		   STX DFLTO         ; set output device number to screen
.f405	a9 00		lda #$00	   LDA #$00          ; set for keyboard
.f407	85 99		sta $99		   STA DFLTN         ; set input device number to keyboard
.f409	60		rts		   RTS
.f40a					  Kernal_OPEN
.f40a	a6 b8		ldx $b8		   LDX LA            ; get logical file number
.f40c	d0 03		bne $f411	   BNE OPEN_05       ; branch if there is a file
.f40e	4c 8d f7	jmp $f78d	   JMP Not_Input_File      ; else do not input file error and return
.f411					OPEN_05
.f411	20 cf f3	jsr $f3cf	   JSR Find_File_X
.f414	d0 03		bne $f419	   BNE OPEN_10       ; branch if file not found
.f416	4c 81 f7	jmp $f781	   JMP File_Already_Open      ; else do file already open error and return
.f419					OPEN_10
.f419	a6 98		ldx $98		   LDX LDTND         ; get open file count
.f41b	e0 0a		cpx #$0a	   CPX #$0A          ; compare with max
.f41d	90 03		bcc $f422	   BCC OPEN_15       ; branch if less
.f41f	4c 7e f7	jmp $f77e	   JMP Too_Many_Files      ; else do too many files error and return
.f422					OPEN_15
.f422	e6 98		inc $98		   INC LDTND         ; increment open file count
.f424	a5 b8		lda $b8		   LDA LA            ; get logical file number
.f426	9d 59 02	sta $0259,x	   STA FILTBL,X      ; save to logical file table
.f429	a5 b9		lda $b9		   LDA SA            ; get secondary address
.f42b	09 60		ora #$60	   ORA #$60          ; OR with the OPEN CHANNEL command
.f42d	85 b9		sta $b9		   STA SA            ; set secondary address
.f42f	9d 6d 02	sta $026d,x	   STA SECATB,X      ; save to secondary address table
.f432	a5 ba		lda $ba		   LDA FA            ; get device number
.f434	9d 63 02	sta $0263,x	   STA DEVTBL,X      ; save to device number table
.f437	f0 5a		beq $f493	   BEQ OPEN_60       ; do ok exit if keyboard
.f439	c9 03		cmp #$03	   CMP #$03          ; compare device number with screen
.f43b	f0 56		beq $f493	   BEQ OPEN_60       ; do ok exit if screen
.f43d	90 05		bcc $f444	   BCC OPEN_20       ; branch if < screen, tape or RS232
.f43f	20 95 f4	jsr $f495	   JSR IEC_Send_SA_And_Filename
.f442	90 4f		bcc $f493	   BCC OPEN_60       ; do ok exit
.f444					OPEN_20
.f444	c9 02		cmp #$02	   CMP #2            ; RS232 ?
.f446	d0 03		bne $f44b	   BNE OPEN_25
.f448	4c c7 f4	jmp $f4c7	   JMP RS232_Open
.f44b					OPEN_25
.f44b	20 4d f8	jsr $f84d	   JSR TAPE_Get_Buffer_Address
.f44e	b0 03		bcs $f453	   BCS OPEN_30       ; branch if >= $0200
.f450	4c 96 f7	jmp $f796	   JMP Illegal_Jiffy_Device
.f453					OPEN_30
.f453	a5 b9		lda $b9		   LDA SA            ; get secondary address
.f455	29 0f		and #$0f	   AND #$0F
.f457	d0 1f		bne $f478	   BNE OPEN_45
.f459	20 94 f8	jsr $f894	   JSR Wait_For_Play
.f45c	b0 36		bcs $f494	   BCS OPEN_Ret      ; exit if STOP was pressed
.f45e	20 47 f6	jsr $f647	   JSR Print_Searching
.f461	a5 b7		lda $b7		   LDA FNLEN         ; get file name length
.f463	f0 0a		beq $f46f	   BEQ OPEN_40       ; if null file name just go find header
.f465	20 67 f8	jsr $f867	   JSR TAPE_Find_Fileheader
.f468	90 18		bcc $f482	   BCC OPEN_50       ; branch if no error
.f46a	f0 28		beq $f494	   BEQ OPEN_Ret      ; exit if ??
.f46c					OPEN_35
.f46c	4c 87 f7	jmp $f787	   JMP File_Not_Found      ; do file not found error and return
.f46f					OPEN_40
.f46f	20 af f7	jsr $f7af	   JSR TAPE_Find_Any_Header
.f472	f0 20		beq $f494	   BEQ OPEN_Ret      ; exit if end of tape found
.f474	90 0c		bcc $f482	   BCC OPEN_50
.f476	b0 f4		bcs $f46c	   BCS OPEN_35
.f478					OPEN_45
.f478	20 b7 f8	jsr $f8b7	   JSR TAPE_Wait_For_Record
.f47b	b0 17		bcs $f494	   BCS OPEN_Ret      ; exit if STOP was pressed
.f47d	a9 04		lda #$04	   LDA #$04          ; set data file header
.f47f	20 e7 f7	jsr $f7e7	   JSR TAPE_Write_Header
.f482					OPEN_50
.f482	a9 bf		lda #$bf	   LDA #$BF
.f484	a4 b9		ldy $b9		   LDY SA            ; get secondary address
.f486	c0 60		cpy #$60	   CPY #$60
.f488	f0 07		beq $f491	   BEQ OPEN_55
.f48a	a0 00		ldy #$00	   LDY #0
.f48c	a9 02		lda #$02	   LDA #$02
.f48e	91 b2		sta ($b2),y	   STA (TAPE1),Y     ; save to tape buffer
.f490	98		tya		   TYA               ; clear A
.f491					OPEN_55
.f491	85 a6		sta $a6		   STA BUFPNT        ; save tape buffer index
.f493					OPEN_60
.f493	18		clc		   CLC               ; flag ok
.f494					OPEN_Ret
.f494	60		rts		   RTS
.f495					  IEC_Send_SA_And_Filename
.f495	a5 b9		lda $b9		   LDA SA            ; get secondary address
.f497	30 2c		bmi $f4c5	   BMI ISSF_40       ; ok exit if negative
.f499	a4 b7		ldy $b7		   LDY FNLEN         ; get file name length
.f49b	f0 28		beq $f4c5	   BEQ ISSF_40       ; ok exit if null
.f49d	a5 ba		lda $ba		   LDA FA            ; get device number
.f49f	20 17 ee	jsr $ee17	   JSR Kernal_LISTEN ; command devices on the serial bus to LISTEN
.f4a2	a5 b9		lda $b9		   LDA SA            ; get the secondary address
.f4a4	09 f0		ora #$f0	   ORA #$F0          ; OR with the OPEN command
.f4a6	20 c0 ee	jsr $eec0	   JSR Kernal_SECOND ; send secondary address after LISTEN
.f4a9	a5 90		lda $90		   LDA STATUS        ; get serial status byte
.f4ab	10 05		bpl $f4b2	   BPL ISSF_10       ; branch if device present
.f4ad					Pop_Dev_Not_Present
.f4ad	68		pla		   PLA               ; else dump calling address low byte
.f4ae	68		pla		   PLA               ; dump calling address high byte
.f4af					Jmp_Dev_Not_Present
.f4af	4c 8a f7	jmp $f78a	   JMP Dev_Not_Present      ; do device not present error and return
.f4b2					ISSF_10
.f4b2	a5 b7		lda $b7		   LDA FNLEN         ; get file name length
.f4b4	f0 0c		beq $f4c2	   BEQ ISSF_30       ; branch if null name
.f4b6	a0 00		ldy #$00	   LDY #0
.f4b8					ISSF_20
.f4b8	b1 bb		lda ($bb),y	   LDA (FNADR ),Y    ; get file name byte
.f4ba	20 e4 ee	jsr $eee4	   JSR Kernal_CIOUT  ; output a byte to the serial bus
.f4bd	c8		iny		   INY
.f4be	c4 b7		cpy $b7		   CPY FNLEN         ; compare with file name length
.f4c0	d0 f6		bne $f4b8	   BNE ISSF_20       ; loop if not all done
.f4c2					ISSF_30
.f4c2	20 04 ef	jsr $ef04	   JSR Kernal_UNLSN
.f4c5					ISSF_40
.f4c5	18		clc		   CLC               ; flag ok
.f4c6	60		rts		   RTS
.f4c7					  RS232_Open
.f4c7	a9 06		lda #$06	   LDA #$06          ; IIII IOOI, DTR and RTS only as outputs
.f4c9	8d 12 91	sta $9112	   STA VIA1_DDRB     ; set VIA 1 DDRB
.f4cc	8d 10 91	sta $9110	   STA RS2_DSR_CTS   ; set VIA 1 DRB, DTR and RTS high
.f4cf	a9 ee		lda #$ee	   LDA #$EE          ; CB2 high, CB1 negative edge, CA2 high, CA1 negative edge
.f4d1	8d 1c 91	sta $911c	   STA VIA1_PCR      ; set VIA 1 PCR
.f4d4	a0 00		ldy #$00	   LDY #0
.f4d6	8c 97 02	sty $0297	   STY RSSTAT        ; clear RS232 status byte
.f4d9					ROPN_05
.f4d9	c4 b7		cpy $b7		   CPY FNLEN         ; compare with file name length
.f4db	f0 0a		beq $f4e7	   BEQ ROPN_10       ; exit loop if done
.f4dd	b1 bb		lda ($bb),y	   LDA (FNADR ),Y    ; get file name byte
.f4df	99 93 02	sta $0293,y	   STA M51CTR  ,Y    ; copy to 6551 register set
.f4e2	c8		iny		   INY
.f4e3	c0 04		cpy #$04	   CPY #$04          ; compare with $04
.f4e5	d0 f2		bne $f4d9	   BNE ROPN_05       ; loop if not to 4 yet
.f4e7					ROPN_10
.f4e7	20 27 f0	jsr $f027	   JSR RS232_Set_Data_Bits
.f4ea	8e 98 02	stx $0298	   STX BITNUM        ; save bit count
.f4ed	ad 93 02	lda $0293	   LDA M51CTR        ; get pseudo 6551 control register
.f4f0	29 0f		and #$0f	   AND #$0F          ; mask 0000 xxxx, baud rate
.f4f2	d0 00		bne $f4f4	   BNE ROPN_15       ; quirk
.f4f4					ROPN_15
.f4f4	0a		asl a		   ASL A             ; * 2
.f4f5	aa		tax		   TAX               ; copy to index
.f4f6	bd 5a ff	lda $ff5a,x	   LDA Baudrate-2,X  ; get timer constant low byte
.f4f9	0a		asl a		   ASL A             ; * 2
.f4fa	a8		tay		   TAY               ; copy to Y
.f4fb	bd 5b ff	lda $ff5b,x	   LDA Baudrate-1,X  ; get timer constant high byte
.f4fe	2a		rol a		   ROL A             ; * 2
.f4ff	48		pha		   PHA               ; save it
.f500	98		tya		   TYA               ; get timer constant low byte back
.f501	69 c8		adc #$c8	   ADC #$C8          ; + $C8, carry cleared by previous ROL
.f503	8d 99 02	sta $0299	   STA BAUDOF        ; save bit cell time low byte
.f506	68		pla		   PLA               ; restore high  byte
.f507	69 00		adc #$00	   ADC #$00          ; add carry
.f509	8d 9a 02	sta $029a	   STA BAUDOF+1      ; save bit cell time high byte
.f50c	ad 94 02	lda $0294	   LDA M51CDR        ; get pseudo 6551 command register
.f50f	4a		lsr a		   LSR A             ; shift b0 into Cb
.f510	90 09		bcc $f51b	   BCC ROPN_35       ; branch if 3 line interface
.f512	ad 20 91	lda $9120	   LDA VIA2_DATB     ; get VIA 2 DRB, this is wrong, the adress should be
.f515	0a		asl a		   ASL A             ; shift DSR into Cb
.f516	b0 03		bcs $f51b	   BCS ROPN_35       ; branch if DSR = 1
.f518	4c 16 f0	jmp $f016	   JMP RS232_No_DSR_Signal
.f51b					ROPN_35
.f51b	ad 9b 02	lda $029b	   LDA RIDBE         ; get index to Rx buffer end
.f51e	8d 9c 02	sta $029c	   STA RIDBS         ; set index to Rx buffer start, clear Rx buffer
.f521	ad 9e 02	lda $029e	   LDA RODBE         ; get index to Tx buffer end
.f524	8d 9d 02	sta $029d	   STA RODBS         ; set index to Tx buffer start, clear Tx buffer
.f527	20 75 fe	jsr $fe75	   JSR Read_Memtop
.f52a	a5 f8		lda $f8		   LDA RXPTR+1       ; get Rx buffer pointer high byte
.f52c	d0 05		bne $f533	   BNE ROPN_40       ; branch if buffer already set
.f52e	88		dey		   DEY               ; decrement top of memory high byte, 256 byte buffer
.f52f	84 f8		sty $f8		   STY RXPTR+1       ; set Rx buffer pointer high byte
.f531	86 f7		stx $f7		   STX RXPTR         ; set Rx buffer pointer low byte
.f533					ROPN_40
.f533	a5 fa		lda $fa		   LDA TXPTR+1       ; get Tx buffer pointer high byte
.f535	d0 05		bne $f53c	   BNE ROPN_45       ; branch if buffer already set
.f537	88		dey		   DEY               ; decrement Rx buffer pointer high byte, 256 byte buffer
.f538	84 fa		sty $fa		   STY TXPTR+1       ; set Tx buffer pointer high byte
.f53a	86 f9		stx $f9		   STX TXPTR         ; set Tx buffer pointer low byte
.f53c					ROPN_45
.f53c	38		sec		   SEC
.f53d	a9 f0		lda #$f0	   LDA #$F0
.f53f	4c 7b fe	jmp $fe7b	   JMP Set_memtop
.f542					  Kernal_LOAD
.f542	86 c3		stx $c3		   STX MEMUSS
.f544	84 c4		sty $c4		   STY MEMUSS+1
.f546	6c 30 03	jmp ($0330)	   JMP (ILOAD)       ; do LOAD vector, usually points to Default_LOAD
.f549					  Default_LOAD
.f549	85 93		sta $93		   STA VERCKK        ; save load/verify flag
.f54b	a9 00		lda #$00	   LDA #0
.f54d	85 90		sta $90		   STA STATUS        ; clear serial status byte
.f54f	a5 ba		lda $ba		   LDA FA            ; get device number
.f551	d0 03		bne $f556	   BNE DLOA_10       ; branch if not keyboard
.f553					DLOA_05
.f553	4c 96 f7	jmp $f796	   JMP Illegal_Jiffy_Device
.f556					DLOA_10
.f556	c9 03		cmp #$03	   CMP #$03          ; compare device number with screen
.f558	f0 f9		beq $f553	   BEQ DLOA_05       ; if screen go do illegal device number and return
.f55a	90 6e		bcc $f5ca	   BCC DLOA_55       ; branch if less than screen
.f55c	a4 b7		ldy $b7		   LDY FNLEN         ; get file name length
.f55e	d0 03		bne $f563	   BNE DLOA_15       ; branch if not null name
.f560	4c 93 f7	jmp $f793	   JMP Missing_File_Name
.f563					DLOA_15
.f563	20 bc e4	jsr $e4bc	   JSR Get_SA_Print_Searching
.f566	a9 60		lda #$60	   LDA #$60
.f568	85 b9		sta $b9		   STA SA            ; save the secondary address
.f56a	20 95 f4	jsr $f495	   JSR IEC_Send_SA_And_Filename
.f56d	a5 ba		lda $ba		   LDA FA            ; get device number
.f56f	20 14 ee	jsr $ee14	   JSR Kernal_TALK   ; command a serial bus device to TALK
.f572	a5 b9		lda $b9		   LDA SA            ; get secondary address
.f574	20 ce ee	jsr $eece	   JSR Kernal_TKSA   ; send secondary address after TALK
.f577	20 19 ef	jsr $ef19	   JSR Kernal_ACPTR  ; input a byte from the serial bus
.f57a	85 ae		sta $ae		   STA EAL           ; save program start address low byte
.f57c	a5 90		lda $90		   LDA STATUS        ; get serial status byte
.f57e	4a		lsr a		   LSR A             ; shift time out read ..
.f57f	4a		lsr a		   LSR A             ; .. into carry bit
.f580	b0 45		bcs $f5c7	   BCS DLOA_50       ; if timed out go do file not found error and return
.f582	20 19 ef	jsr $ef19	   JSR Kernal_ACPTR  ; input a byte from the serial bus
.f585	85 af		sta $af		   STA EAL+1         ; save program start address high byte
.f587	20 c1 e4	jsr $e4c1	   JSR Set_Load_Address; set LOAD address if secondary address = 0
.f58a					DLOA_25
.f58a	a9 fd		lda #$fd	   LDA #$FD          ; mask xxxx xx0x, clear time out read bit
.f58c	25 90		and $90		   AND STATUS        ; mask serial status byte
.f58e	85 90		sta $90		   STA STATUS        ; set serial status byte
.f590	20 e1 ff	jsr $ffe1	   JSR STOP          ; Check if stop key is pressed
.f593	d0 03		bne $f598	   BNE DLOA_30       ; branch if not [STOP]
.f595	4c cb f6	jmp $f6cb	   JMP SAVE_50       ; else close the serial bus device and flag stop
.f598					DLOA_30
.f598	20 19 ef	jsr $ef19	   JSR Kernal_ACPTR  ; input a byte from the serial bus
.f59b	aa		tax		   TAX               ; copy byte
.f59c	a5 90		lda $90		   LDA STATUS        ; get serial status byte
.f59e	4a		lsr a		   LSR A             ; shift time out read ..
.f59f	4a		lsr a		   LSR A             ; .. into carry bit
.f5a0	b0 e8		bcs $f58a	   BCS DLOA_25       ; if timed out go ??
.f5a2	8a		txa		   TXA               ; copy received byte back
.f5a3	a4 93		ldy $93		   LDY VERCKK        ; get load/verify flag
.f5a5	f0 0c		beq $f5b3	   BEQ DLOA_35       ; branch if load
.f5a7	a0 00		ldy #$00	   LDY #0
.f5a9	d1 ae		cmp ($ae),y	   CMP (EAL),Y       ; compare byte with previously loaded byte
.f5ab	f0 08		beq $f5b5	   BEQ DLOA_40       ; branch if match
.f5ad	a9 10		lda #$10	   LDA #$10          ; flag read error
.f5af	20 6a fe	jsr $fe6a	   JSR Ora_Status
>f5b2	2c				   .byte   $2C
.f5b3					DLOA_35
.f5b3	91 ae		sta ($ae),y	   STA (EAL),Y       ; save byte to memory
.f5b5					DLOA_40
.f5b5	e6 ae		inc $ae		   INC EAL           ; increment save pointer low byte
.f5b7	d0 02		bne $f5bb	   BNE DLOA_45       ; if no rollover skip the high byte increment
.f5b9	e6 af		inc $af		   INC EAL+1         ; else increment save pointer high byte
.f5bb					DLOA_45
.f5bb	24 90		bit $90		   BIT STATUS        ; test serial status byte
.f5bd	50 cb		bvc $f58a	   BVC DLOA_25       ; loop if not end of file
.f5bf					DLOA_47
.f5bf	20 f6 ee	jsr $eef6	   JSR Kernal_UNTLK  ; command the serial bus to UNTALK
.f5c2	20 da f6	jsr $f6da	   JSR IEC_Close
.f5c5	90 7a		bcc $f641	   BCC DLOA_94       ; if OK exit
.f5c7					DLOA_50
.f5c7	4c 87 f7	jmp $f787	   JMP File_Not_Found
.f5ca					DLOA_55
.f5ca	c9 02		cmp #$02	   CMP #$02          ; compare device with RS232 device
.f5cc	d0 03		bne $f5d1	   BNE DLOA_60       ; if not RS232 device continue
.f5ce	4c b9 f0	jmp $f0b9	   JMP RRec_70       ; else do illegal device number and return
.f5d1					DLOA_60
.f5d1	20 4d f8	jsr $f84d	   JSR TAPE_Get_Buffer_Address
.f5d4	b0 03		bcs $f5d9	   BCS DLOA_65       ; branch if >= $0200
.f5d6	4c 96 f7	jmp $f796	   JMP Illegal_Jiffy_Device
.f5d9					DLOA_65
.f5d9	20 94 f8	jsr $f894	   JSR Wait_For_Play
.f5dc	b0 68		bcs $f646	   BCS DLOA_Ret      ; exit if STOP was pressed
.f5de	20 47 f6	jsr $f647	   JSR Print_Searching
.f5e1					DLOA_70
.f5e1	a5 b7		lda $b7		   LDA FNLEN         ; get file name length
.f5e3	f0 09		beq $f5ee	   BEQ DLOA_75
.f5e5	20 67 f8	jsr $f867	   JSR TAPE_Find_Fileheader
.f5e8	90 0b		bcc $f5f5	   BCC DLOA_80       ; if no error continue
.f5ea	f0 5a		beq $f646	   BEQ DLOA_Ret      ; exit if ??
.f5ec	b0 d9		bcs $f5c7	   BCS DLOA_50       ; branch always
.f5ee					DLOA_75
.f5ee	20 af f7	jsr $f7af	   JSR TAPE_Find_Any_Header
.f5f1	f0 53		beq $f646	   BEQ DLOA_Ret      ; exit if ??
.f5f3	b0 d2		bcs $f5c7	   BCS DLOA_50
.f5f5					DLOA_80
.f5f5	a5 90		lda $90		   LDA STATUS        ; get serial status byte
.f5f7	29 10		and #$10	   AND #$10          ; mask 000x 0000, read error
.f5f9	38		sec		   SEC               ; flag fail
.f5fa	d0 4a		bne $f646	   BNE DLOA_Ret      ; if read error just exit
.f5fc	e0 01		cpx #$01	   CPX #$01
.f5fe	f0 11		beq $f611	   BEQ DLOA_90
.f600	e0 03		cpx #$03	   CPX #$03
.f602	d0 dd		bne $f5e1	   BNE DLOA_70
.f604					DLOA_85
.f604	a0 01		ldy #$01	   LDY #$01
.f606	b1 b2		lda ($b2),y	   LDA (TAPE1),Y
.f608	85 c3		sta $c3		   STA MEMUSS
.f60a	c8		iny		   INY
.f60b	b1 b2		lda ($b2),y	   LDA (TAPE1),Y
.f60d	85 c4		sta $c4		   STA MEMUSS+1
.f60f	b0 04		bcs $f615	   BCS DLOA_92
.f611					DLOA_90
.f611	a5 b9		lda $b9		   LDA SA
.f613	d0 ef		bne $f604	   BNE DLOA_85
.f615					DLOA_92
.f615	a0 03		ldy #$03	   LDY #$03
.f617	b1 b2		lda ($b2),y	   LDA (TAPE1),Y
.f619	a0 01		ldy #$01	   LDY #$01
.f61b	f1 b2		sbc ($b2),y	   SBC (TAPE1),Y
.f61d	aa		tax		   TAX
.f61e	a0 04		ldy #$04	   LDY #$04
.f620	b1 b2		lda ($b2),y	   LDA (TAPE1),Y
.f622	a0 02		ldy #$02	   LDY #$02
.f624	f1 b2		sbc ($b2),y	   SBC (TAPE1),Y
.f626	a8		tay		   TAY
.f627	18		clc		   CLC
.f628	8a		txa		   TXA
.f629	65 c3		adc $c3		   ADC MEMUSS
.f62b	85 ae		sta $ae		   STA EAL
.f62d	98		tya		   TYA
.f62e	65 c4		adc $c4		   ADC MEMUSS+1
.f630	85 af		sta $af		   STA EAL+1
.f632	a5 c3		lda $c3		   LDA MEMUSS
.f634	85 c1		sta $c1		   STA STAL
.f636	a5 c4		lda $c4		   LDA MEMUSS+1
.f638	85 c2		sta $c2		   STA STAL+1
.f63a	20 6a f6	jsr $f66a	   JSR Display_LOADING_Or_VERIFYING
.f63d	20 c9 f8	jsr $f8c9	   JSR TAPE_Read
>f640	24				   .byte   $24       ; skip CLC statement
.f641					DLOA_94
.f641	18		clc		   CLC               ; flag ok
.f642					DLOA_95
.f642	a6 ae		ldx $ae		   LDX EAL           ; get the LOAD end pointer low byte
.f644	a4 af		ldy $af		   LDY EAL+1         ; get the LOAD end pointer high byte
.f646					DLOA_Ret
.f646	60		rts		   RTS
.f647					  Print_Searching
.f647	a5 9d		lda $9d		   LDA MSGFLG
.f649	10 1e		bpl $f669	   BPL PrSe_Ret
.f64b	a0 0c		ldy #$0c	   LDY #Msg_Searching-Msg_Start
.f64d	20 e6 f1	jsr $f1e6	   JSR Display_Kernal_IO_Message
.f650	a5 b7		lda $b7		   LDA FNLEN
.f652	f0 15		beq $f669	   BEQ PrSe_Ret
.f654	a0 17		ldy #$17	   LDY #Msg_FOR-Msg_Start
.f656	20 e6 f1	jsr $f1e6	   JSR Display_Kernal_IO_Message
.f659					PrSe_10
.f659	a4 b7		ldy $b7		   LDY FNLEN
.f65b	f0 0c		beq $f669	   BEQ PrSe_Ret
.f65d	a0 00		ldy #$00	   LDY #0
.f65f					PrSe_20
.f65f	b1 bb		lda ($bb),y	   LDA (FNADR ),Y
.f661	20 d2 ff	jsr $ffd2	   JSR CHROUT
.f664	c8		iny		   INY
.f665	c4 b7		cpy $b7		   CPY FNLEN
.f667	d0 f6		bne $f65f	   BNE PrSe_20
.f669					PrSe_Ret
.f669	60		rts		   RTS
.f66a					  Display_LOADING_Or_VERIFYING
.f66a	a0 49		ldy #$49	   LDY #Msg_Loading-Msg_Start
.f66c	a5 93		lda $93		   LDA VERCKK        ; get load/verify flag
.f66e	f0 02		beq $f672	   BEQ DLV_10        ; branch if load
.f670	a0 59		ldy #$59	   LDY #Msg_Verifying-Msg_Start
.f672					DLV_10
.f672	4c e2 f1	jmp $f1e2	   JMP Display_Direct_Msg
.f675					  Kernal_SAVE
.f675	86 ae		stx $ae		   STX EAL           ; save end address low byte
.f677	84 af		sty $af		   STY EAL+1         ; save end address high byte
.f679	aa		tax		   TAX               ; copy index to start pointer
.f67a	b5 00		lda $00,x	   LDA 0,X           ; get start address low byte
.f67c	85 c1		sta $c1		   STA STAL          ; set I/O start addresses low byte
.f67e	b5 01		lda $01,x	   LDA 1,X           ; get start address high byte
.f680	85 c2		sta $c2		   STA STAL+1        ; set I/O start addresses high byte
.f682	6c 32 03	jmp ($0332)	   JMP (ISAVE)       ; go save, usually points to Default_SAVE
.f685					  Default_SAVE
.f685	a5 ba		lda $ba		   LDA FA            ; get device number
.f687	d0 03		bne $f68c	   BNE SAVE_20       ; branch if not keyboard
.f689					SAVE_10
.f689	4c 96 f7	jmp $f796	   JMP Illegal_Jiffy_Device
.f68c					SAVE_20
.f68c	c9 03		cmp #$03	   CMP #$03          ; compare device number with screen
.f68e	f0 f9		beq $f689	   BEQ SAVE_10       ; if screen do illegal device number and return
.f690	90 5f		bcc $f6f1	   BCC IClo_30      ; branch if < screen
.f692	a9 61		lda #$61	   LDA #$61          ; set secondary address to $01
.f694	85 b9		sta $b9		   STA SA            ; save secondary address
.f696	a4 b7		ldy $b7		   LDY FNLEN         ; get file name length
.f698	d0 03		bne $f69d	   BNE SAVE_30       ; branch if filename not null
.f69a					Jmp_Missing_Filename
.f69a	4c 93 f7	jmp $f793	   JMP Missing_File_Name      ; else do missing file name error and return
.f69d					SAVE_30
.f69d	20 95 f4	jsr $f495	   JSR IEC_Send_SA_And_Filename
.f6a0	20 28 f7	jsr $f728	   JSR Display_SAVING_Filename
.f6a3	a5 ba		lda $ba		   LDA FA            ; get device number
.f6a5	20 17 ee	jsr $ee17	   JSR Kernal_LISTEN ; command devices on the serial bus to LISTEN
.f6a8	a5 b9		lda $b9		   LDA SA            ; get secondary address
.f6aa	20 c0 ee	jsr $eec0	   JSR Kernal_SECOND ; send secondary address after LISTEN
.f6ad	a0 00		ldy #$00	   LDY #0
.f6af	20 d2 fb	jsr $fbd2	   JSR Set_IO_Start
.f6b2	a5 ac		lda $ac		   LDA SAL           ; get buffer address low byte
.f6b4	20 e4 ee	jsr $eee4	   JSR Kernal_CIOUT  ; output a byte to the serial bus
.f6b7	a5 ad		lda $ad		   LDA SAL+1         ; get buffer address high byte
.f6b9	20 e4 ee	jsr $eee4	   JSR Kernal_CIOUT  ; output a byte to the serial bus
.f6bc					SAVE_40
.f6bc	20 11 fd	jsr $fd11	   JSR Check_IO_End
.f6bf	b0 16		bcs $f6d7	   BCS SAVE_70       ; go do UNLISTEN if at end
.f6c1	b1 ac		lda ($ac),y	   LDA (SAL),Y       ; get byte from buffer
.f6c3	20 e4 ee	jsr $eee4	   JSR Kernal_CIOUT  ; output a byte to the serial bus
.f6c6	20 e1 ff	jsr $ffe1	   JSR STOP          ; Check if stop key is pressed
.f6c9	d0 07		bne $f6d2	   BNE SAVE_60       ; if stop not pressed go increment pointer and loop for next
.f6cb					SAVE_50
.f6cb	20 da f6	jsr $f6da	   JSR IEC_Close
.f6ce	a9 00		lda #$00	   LDA #0
.f6d0	38		sec		   SEC               ; flag stop
.f6d1	60		rts		   RTS
.f6d2					SAVE_60
.f6d2	20 1b fd	jsr $fd1b	   JSR Inc_SAL_Word
.f6d5	d0 e5		bne $f6bc	   BNE SAVE_40       ; loop, branch always
.f6d7					SAVE_70
.f6d7	20 04 ef	jsr $ef04	   JSR Kernal_UNLSN  ; command the serial bus to UNLISTEN
.f6da					  IEC_Close
.f6da	24 b9		bit $b9		   BIT SA            ; test the secondary address
.f6dc	30 11		bmi $f6ef	   BMI IClo_20       ; if already closed just exit
.f6de	a5 ba		lda $ba		   LDA FA            ; get the device number
.f6e0	20 17 ee	jsr $ee17	   JSR Kernal_LISTEN ; command devices on the serial bus to LISTEN
.f6e3	a5 b9		lda $b9		   LDA SA            ; get secondary address
.f6e5	29 ef		and #$ef	   AND #$EF          ; mask the channel number
.f6e7	09 e0		ora #$e0	   ORA #$E0          ; OR with the CLOSE command
.f6e9	20 c0 ee	jsr $eec0	   JSR Kernal_SECOND ; send secondary address after LISTEN
.f6ec					IClo_10
.f6ec	20 04 ef	jsr $ef04	   JSR Kernal_UNLSN  ; command the serial bus to UNLISTEN
.f6ef					IClo_20
.f6ef	18		clc		   CLC               ; flag ok
.f6f0	60		rts		   RTS
.f6f1					IClo_30
.f6f1	c9 02		cmp #$02	   CMP #$02          ; compare device with RS232 device
.f6f3	d0 03		bne $f6f8	   BNE IClo_40       ; branch if not RS232 device
.f6f5	4c b9 f0	jmp $f0b9	   JMP RRec_70       ; else do illegal device number and return
.f6f8					IClo_40
.f6f8	20 4d f8	jsr $f84d	   JSR TAPE_Get_Buffer_Address
.f6fb	90 8c		bcc $f689	   BCC SAVE_10
.f6fd	20 b7 f8	jsr $f8b7	   JSR TAPE_Wait_For_Record
.f700	b0 25		bcs $f727	   BCS IClo_Ret      ; exit if STOP was pressed
.f702	20 28 f7	jsr $f728	   JSR Display_SAVING_Filename
.f705	a2 03		ldx #$03	   LDX #$03          ; set header for a non relocatable program file
.f707	a5 b9		lda $b9		   LDA SA            ; get secondary address
.f709	29 01		and #$01	   AND #$01          ; mask non relocatable bit
.f70b	d0 02		bne $f70f	   BNE IClo_50       ; branch if non relocatable program
.f70d	a2 01		ldx #$01	   LDX #$01          ; else set header for a relocatable program file
.f70f					IClo_50
.f70f	8a		txa		   TXA               ; copy header type to A
.f710	20 e7 f7	jsr $f7e7	   JSR TAPE_Write_Header
.f713	b0 12		bcs $f727	   BCS IClo_Ret      ; exit if error
.f715	20 e6 f8	jsr $f8e6	   JSR TAPE_Write_With_Lead
.f718	b0 0d		bcs $f727	   BCS IClo_Ret      ; exit if error
.f71a	a5 b9		lda $b9		   LDA SA            ; get secondary address
.f71c	29 02		and #$02	   AND #$02          ; mask end of tape flag
.f71e	f0 06		beq $f726	   BEQ IClo_60       ; branch if not end of tape
.f720	a9 05		lda #$05	   LDA #$05          ; else set logical end of the tape
.f722	20 e7 f7	jsr $f7e7	   JSR TAPE_Write_Header
>f725	24				   .byte   $24       ; skip next command
.f726					IClo_60
.f726	18		clc		   CLC               ; flag ok
.f727					IClo_Ret
.f727	60		rts		   RTS
.f728					  Display_SAVING_Filename
.f728	a5 9d		lda $9d		   LDA MSGFLG        ; get message mode flag
.f72a	10 fb		bpl $f727	   BPL IClo_Ret      ; exit if control messages off
.f72c	a0 51		ldy #$51	   LDY #Msg_Saving-Msg_Start
.f72e	20 e6 f1	jsr $f1e6	   JSR Display_Kernal_IO_Message
.f731	4c 59 f6	jmp $f659	   JMP PrSe_10      ; print file name and return
.f734					  Kernal_UDTIM
.f734	a2 00		ldx #$00	   LDX #$00          ; clear X
.f736	e6 a2		inc $a2		   INC JIFFYL        ; increment jiffy low byte
.f738	d0 06		bne $f740	   BNE UDTI_10       ; if no rollover skip the mid byte increment
.f73a	e6 a1		inc $a1		   INC JIFFYM        ; increment jiffy mid byte
.f73c	d0 02		bne $f740	   BNE UDTI_10       ; if no rollover skip the high byte increment
.f73e	e6 a0		inc $a0		   INC JIFFYH        ; increment jiffy high byte
.f740					UDTI_10
.f740	38		sec		   SEC
.f741	a5 a2		lda $a2		   LDA JIFFYL        ; get jiffy clock low byte
.f743	e9 01		sbc #$01	   SBC #$01          ; subtract $4F1A01 low byte
.f745	a5 a1		lda $a1		   LDA JIFFYM        ; get jiffy clock mid byte
.f747	e9 1a		sbc #$1a	   SBC #$1A          ; subtract $4F1A01 mid byte
.f749	a5 a0		lda $a0		   LDA JIFFYH        ; get jiffy clock high byte
.f74b	e9 4f		sbc #$4f	   SBC #$4F          ; subtract $4F1A01 high byte
.f74d	90 06		bcc $f755	   BCC Look_For_Special_Keys
.f74f	86 a0		stx $a0		   STX JIFFYH        ; clear jiffies high byte
.f751	86 a1		stx $a1		   STX JIFFYM        ; clear jiffies mid byte
.f753	86 a2		stx $a2		   STX JIFFYL        ; clear jiffies low byte
.f755					  Look_For_Special_Keys
.f755	ad 2f 91	lda $912f	   LDA KEYB_ROWN     ; get VIA 2 DRA, keyboard row, no handshake
.f758	cd 2f 91	cmp $912f	   CMP KEYB_ROWN     ; compare with self
.f75b	d0 f8		bne $f755	   BNE Look_For_Special_Keys
.f75d					LFSK_20
.f75d	85 91		sta $91		   STA STKEY         ; save VIA 2 DRA, keyboard row
.f75f					LFSK_Ret
.f75f	60		rts		   RTS
.f760					  Kernal_RDTIM
.f760	78		sei		   SEI               ; disable interrupts
.f761	a5 a2		lda $a2		   LDA JIFFYL        ; get jiffy clock low byte
.f763	a6 a1		ldx $a1		   LDX JIFFYM        ; get jiffy clock mid byte
.f765	a4 a0		ldy $a0		   LDY JIFFYH        ; get jiffy clock high byte
.f767					  Kernal_SETTIM
.f767	78		sei		   SEI               ; disable interrupts
.f768	85 a2		sta $a2		   STA JIFFYL        ; save jiffy clock low byte
.f76a	86 a1		stx $a1		   STX JIFFYM        ; save jiffy clock mid byte
.f76c	84 a0		sty $a0		   STY JIFFYH        ; save jiffy clock high byte
.f76e	58		cli		   CLI               ; enable interrupts
.f76f	60		rts		   RTS
.f770					  Kernal_STOP
.f770	a5 91		lda $91		   LDA STKEY         ; get keyboard row
.f772	c9 fe		cmp #$fe	   CMP #$FE          ; compare with r0 down
.f774	d0 07		bne $f77d	   BNE STOP_Ret      ; branch if not just r0
.f776	08		php		   PHP               ; save status
.f777	20 cc ff	jsr $ffcc	   JSR CLRCHN        ; Clear I/O channels
.f77a	85 c6		sta $c6		   STA NDX           ; save keyboard buffer length
.f77c	28		plp		   PLP               ; restore status
.f77d					STOP_Ret
.f77d	60		rts		   RTS
.f77e					Too_Many_Files
.f77e	a9 01		lda #$01	   LDA #$01
>f780	2c				   .byte   $2C
.f781					File_Already_Open
.f781	a9 02		lda #$02	   LDA #$02
>f783	2c				   .byte   $2C
.f784					File_Not_Open
.f784	a9 03		lda #$03	   LDA #$03
>f786	2c				   .byte   $2C
.f787					File_Not_Found
.f787	a9 04		lda #$04	   LDA #$04
>f789	2c				   .byte   $2C
.f78a					Dev_Not_Present
.f78a	a9 05		lda #$05	   LDA #$05
>f78c	2c				   .byte   $2C
.f78d					Not_Input_File
.f78d	a9 06		lda #$06	   LDA #$06
>f78f	2c				   .byte   $2C
.f790					Not_Output_File
.f790	a9 07		lda #$07	   LDA #$07
>f792	2c				   .byte   $2C
.f793					Missing_File_Name
.f793	a9 08		lda #$08	   LDA #$08
>f795	2c				   .byte   $2C
.f796					Illegal_Jiffy_Device
.f796	a9 09		lda #$09	   LDA #$09          ; illegal device number
.f798	48		pha		   PHA               ; save error #
.f799	20 cc ff	jsr $ffcc	   JSR CLRCHN        ; Clear I/O channels
.f79c	a0 00		ldy #$00	   LDY #0            ; index to "I/O ERROR #"
.f79e	24 9d		bit $9d		   BIT MSGFLG        ; test message mode flag
.f7a0	50 0a		bvc $f7ac	   BVC DIOR_10       ; exit if kernal messages off
.f7a2	20 e6 f1	jsr $f1e6	   JSR Display_Kernal_IO_Message
.f7a5	68		pla		   PLA               ; restore error #
.f7a6	48		pha		   PHA               ; copy error #
.f7a7	09 30		ora #$30	   ORA #'0'          ; convert to ASCII
.f7a9	20 d2 ff	jsr $ffd2	   JSR CHROUT        ; Output a character
.f7ac					DIOR_10
.f7ac	68		pla		   PLA               ; pull error number
.f7ad	38		sec		   SEC               ; flag error
.f7ae					Jiffy_RTS
.f7ae	60		rts		   RTS
.f7af					  TAPE_Find_Any_Header
.f7af	a5 93		lda $93		   LDA VERCKK        ; get load/verify flag
.f7b1	48		pha		   PHA               ; save load/verify flag
.f7b2	20 c0 f8	jsr $f8c0	   JSR TAPE_Init_Read
.f7b5	68		pla		   PLA               ; restore load/verify flag
.f7b6	85 93		sta $93		   STA VERCKK        ; save load/verify flag
.f7b8	b0 2c		bcs $f7e6	   BCS TFAH_Ret      ; exit if error
.f7ba	a0 00		ldy #$00	   LDY #0
.f7bc	b1 b2		lda ($b2),y	   LDA (TAPE1),Y     ; read first byte from tape buffer
.f7be	c9 05		cmp #$05	   CMP #$05          ; compare with logical end of the tape
.f7c0	f0 24		beq $f7e6	   BEQ TFAH_Ret      ; exit if end of the tape
.f7c2	c9 01		cmp #$01	   CMP #$01          ; compare with header for a relocatable program file
.f7c4	f0 08		beq $f7ce	   BEQ TFAH_10      ; branch if program file header
.f7c6	c9 03		cmp #$03	   CMP #$03          ; compare with header for a non relocatable program file
.f7c8	f0 04		beq $f7ce	   BEQ TFAH_10      ; branch if program file header
.f7ca	c9 04		cmp #$04	   CMP #$04          ; compare with data file header
.f7cc	d0 e1		bne $f7af	   BNE TAPE_Find_Any_Header
.f7ce					TFAH_10
.f7ce	aa		tax		   TAX               ; copy header type
.f7cf	24 9d		bit $9d		   BIT MSGFLG        ; get message mode flag
.f7d1	10 11		bpl $f7e4	   BPL TFAH_30      ; exit if control messages off
.f7d3	a0 63		ldy #$63	   LDY #Msg_Found-Msg_Start
.f7d5	20 e6 f1	jsr $f1e6	   JSR Display_Kernal_IO_Message
.f7d8	a0 05		ldy #$05	   LDY #$05          ; index to tape filename
.f7da					TFAH_20
.f7da	b1 b2		lda ($b2),y	   LDA (TAPE1),Y     ; get byte from tape buffer
.f7dc	20 d2 ff	jsr $ffd2	   JSR CHROUT        ; Output a character
.f7df	c8		iny		   INY
.f7e0	c0 15		cpy #$15	   CPY #$15          ; compare with end+1
.f7e2	d0 f6		bne $f7da	   BNE TFAH_20      ; loop if more to do
.f7e4					TFAH_30
.f7e4	18		clc		   CLC               ; flag no error
.f7e5	88		dey		   DEY               ; decrement index
.f7e6					TFAH_Ret
.f7e6	60		rts		   RTS
.f7e7					  TAPE_Write_Header
.f7e7	85 9e		sta $9e		   STA PTR1          ; save header type
.f7e9	20 4d f8	jsr $f84d	   JSR TAPE_Get_Buffer_Address
.f7ec	90 5e		bcc $f84c	   BCC TWH_Ret       ; exit if < $0200
.f7ee	a5 c2		lda $c2		   LDA STAL+1
.f7f0	48		pha		   PHA
.f7f1	a5 c1		lda $c1		   LDA STAL
.f7f3	48		pha		   PHA
.f7f4	a5 af		lda $af		   LDA EAL+1
.f7f6	48		pha		   PHA
.f7f7	a5 ae		lda $ae		   LDA EAL
.f7f9	48		pha		   PHA
.f7fa	a0 bf		ldy #$bf	   LDY #$BF          ; index to header end
.f7fc	a9 20		lda #$20	   LDA #' '          ; clear byte, [SPACE]
.f7fe					TWH_10
.f7fe	91 b2		sta ($b2),y	   STA (TAPE1),Y     ; clear header byte
.f800	88		dey		   DEY               ; decrement index
.f801	d0 fb		bne $f7fe	   BNE TWH_10        ; loop if more to do
.f803	a5 9e		lda $9e		   LDA PTR1          ; get header type back
.f805	91 b2		sta ($b2),y	   STA (TAPE1),Y     ; write to header
.f807	c8		iny		   INY
.f808	a5 c1		lda $c1		   LDA STAL          ; get I/O start address low byte
.f80a	91 b2		sta ($b2),y	   STA (TAPE1),Y     ; write to header
.f80c	c8		iny		   INY
.f80d	a5 c2		lda $c2		   LDA STAL+1        ; get I/O start address high byte
.f80f	91 b2		sta ($b2),y	   STA (TAPE1),Y     ; write to header
.f811	c8		iny		   INY
.f812	a5 ae		lda $ae		   LDA EAL           ; get tape end address low byte
.f814	91 b2		sta ($b2),y	   STA (TAPE1),Y     ; write to header
.f816	c8		iny		   INY
.f817	a5 af		lda $af		   LDA EAL+1         ; get tape end address high byte
.f819	91 b2		sta ($b2),y	   STA (TAPE1),Y     ; write to header
.f81b	c8		iny		   INY
.f81c	84 9f		sty $9f		   STY PTR2          ; save index
.f81e	a0 00		ldy #$00	   LDY #$00          ; clear Y
.f820	84 9e		sty $9e		   STY PTR1          ; clear name index
.f822					TWH_20
.f822	a4 9e		ldy $9e		   LDY PTR1          ; get name index
.f824	c4 b7		cpy $b7		   CPY FNLEN         ; compare with file name length
.f826	f0 0c		beq $f834	   BEQ TWH_30        ; exit loop if all done
.f828	b1 bb		lda ($bb),y	   LDA (FNADR ),Y    ; get file name byte
.f82a	a4 9f		ldy $9f		   LDY PTR2          ; get buffer index
.f82c	91 b2		sta ($b2),y	   STA (TAPE1),Y     ; save file name byte to buffer
.f82e	e6 9e		inc $9e		   INC PTR1          ; increment file name index
.f830	e6 9f		inc $9f		   INC PTR2          ; increment tape buffer index
.f832	d0 ee		bne $f822	   BNE TWH_20        ; loop, branch always
.f834					TWH_30
.f834	20 54 f8	jsr $f854	   JSR TAPE_Set_Buffer_Pointer
.f837	a9 69		lda #$69	   LDA #$69          ; set write lead cycle count
.f839	85 ab		sta $ab		   STA RIPRTY        ; save write lead cycle count
.f83b	20 ea f8	jsr $f8ea	   JSR TAPE_Write
.f83e	a8		tay		   TAY
.f83f	68		pla		   PLA
.f840	85 ae		sta $ae		   STA EAL
.f842	68		pla		   PLA
.f843	85 af		sta $af		   STA EAL+1
.f845	68		pla		   PLA
.f846	85 c1		sta $c1		   STA STAL
.f848	68		pla		   PLA
.f849	85 c2		sta $c2		   STA STAL+1
.f84b	98		tya		   TYA
.f84c					TWH_Ret
.f84c	60		rts		   RTS
.f84d					  TAPE_Get_Buffer_Address
.f84d	a6 b2		ldx $b2		   LDX TAPE1
.f84f	a4 b3		ldy $b3		   LDY TAPE1+1
.f851	c0 02		cpy #$02	   CPY #2            ; compare high byte with $02xx
.f853	60		rts		   RTS
.f854					  TAPE_Set_Buffer_Pointer
.f854	20 4d f8	jsr $f84d	   JSR TAPE_Get_Buffer_Address
.f857	8a		txa		   TXA               ; copy tape buffer start pointer low byte
.f858	85 c1		sta $c1		   STA STAL          ; save as I/O address pointer low byte
.f85a	18		clc		   CLC
.f85b	69 c0		adc #$c0	   ADC #$C0          ; add buffer length low byte
.f85d	85 ae		sta $ae		   STA EAL           ; save tape buffer end pointer low byte
.f85f	98		tya		   TYA               ; copy tape buffer start pointer high byte
.f860	85 c2		sta $c2		   STA STAL+1        ; save as I/O address pointer high byte
.f862	69 00		adc #$00	   ADC #$00          ; add buffer length high byte
.f864	85 af		sta $af		   STA EAL+1         ; save tape buffer end pointer high byte
.f866	60		rts		   RTS
.f867					  TAPE_Find_Fileheader
.f867	20 af f7	jsr $f7af	   JSR TAPE_Find_Any_Header
.f86a	b0 1d		bcs $f889	   BCS TFF_Ret       ; just exit if error
.f86c	a0 05		ldy #$05	   LDY #$05          ; index to name
.f86e	84 9f		sty $9f		   STY PTR2          ; save as tape buffer index
.f870	a0 00		ldy #$00	   LDY #$00          ; clear Y
.f872	84 9e		sty $9e		   STY PTR1          ; save as name buffer index
.f874					TFF_10
.f874	c4 b7		cpy $b7		   CPY FNLEN         ; compare with file name length
.f876	f0 10		beq $f888	   BEQ TFF_20        ; ok exit if match
.f878	b1 bb		lda ($bb),y	   LDA (FNADR ),Y    ; get file name byte
.f87a	a4 9f		ldy $9f		   LDY PTR2          ; get index to tape buffer
.f87c	d1 b2		cmp ($b2),y	   CMP (TAPE1),Y     ; compare with tape header name byte
.f87e	d0 e7		bne $f867	   BNE TAPE_Find_Fileheader
.f880	e6 9e		inc $9e		   INC PTR1          ; else increment name buffer index
.f882	e6 9f		inc $9f		   INC PTR2          ; increment tape buffer index
.f884	a4 9e		ldy $9e		   LDY PTR1          ; get name buffer index
.f886	d0 ec		bne $f874	   BNE TFF_10        ; loop, branch always
.f888					TFF_20
.f888	18		clc		   CLC               ; flag ok
.f889					TFF_Ret
.f889	60		rts		   RTS
.f88a					  TAPE_Advance_Buffer_Pointer
.f88a	20 4d f8	jsr $f84d	   JSR TAPE_Get_Buffer_Address
.f88d	e6 a6		inc $a6		   INC BUFPNT        ; increment tape buffer index
.f88f	a4 a6		ldy $a6		   LDY BUFPNT        ; get tape buffer index
.f891	c0 c0		cpy #$c0	   CPY #$C0          ; compare with buffer length
.f893	60		rts		   RTS
.f894					  Wait_For_Play
.f894	20 ab f8	jsr $f8ab	   JSR TAPE_Sense
.f897	f0 1c		beq $f8b5	   BEQ TASe_10      ; exit if switch closed
.f899	a0 1b		ldy #$1b	   LDY #Msg_Play-Msg_Start
.f89b					WFP_10
.f89b	20 e6 f1	jsr $f1e6	   JSR Display_Kernal_IO_Message
.f89e					WFP_20
.f89e	20 4b f9	jsr $f94b	   JSR TAPE_Abort_On_STOP
.f8a1	20 ab f8	jsr $f8ab	   JSR TAPE_Sense
.f8a4	d0 f8		bne $f89e	   BNE WFP_20        ; loop if cassette switch open
.f8a6	a0 6a		ldy #$6a	   LDY #Msg_okIO-Msg_Start
.f8a8	4c e6 f1	jmp $f1e6	   JMP Display_Kernal_IO_Message
.f8ab					  TAPE_Sense
.f8ab	a9 40		lda #$40	   LDA #$40          ; mask for cassette switch
.f8ad	2c 1f 91	bit $911f	   BIT IEC_DRAN      ; test VIA 1 DRA, no handshake
.f8b0	d0 03		bne $f8b5	   BNE TASe_10       ; branch if cassette sense high
.f8b2	2c 1f 91	bit $911f	   BIT IEC_DRAN      ; test VIA 1 DRA again
.f8b5					TASe_10
.f8b5	18		clc		   CLC
.f8b6	60		rts		   RTS
.f8b7					  TAPE_Wait_For_Record
.f8b7	20 ab f8	jsr $f8ab	   JSR TAPE_Sense
.f8ba	f0 f9		beq $f8b5	   BEQ TASe_10       ; exit if switch closed
.f8bc	a0 2e		ldy #$2e	   LDY #Msg_Record-Msg_Start
.f8be	d0 db		bne $f89b	   BNE WFP_10        ; display message and wait for switch, branch always
.f8c0					  TAPE_Init_Read
.f8c0	a9 00		lda #$00	   LDA #0
.f8c2	85 90		sta $90		   STA STATUS        ; clear serial status byte
.f8c4	85 93		sta $93		   STA VERCKK        ; clear the load/verify flag
.f8c6	20 54 f8	jsr $f854	   JSR TAPE_Set_Buffer_Pointer
.f8c9					  TAPE_Read
.f8c9	20 94 f8	jsr $f894	   JSR Wait_For_Play
.f8cc	b0 1f		bcs $f8ed	   BCS TAWR_10      ; exit if STOP was pressed, uses further BCS at target
.f8ce	78		sei		   SEI               ; disable interrupts
.f8cf	a9 00		lda #$00	   LDA #0
.f8d1	85 aa		sta $aa		   STA RIDATA        ;.
.f8d3	85 b4		sta $b4		   STA BITTS         ;.
.f8d5	85 b0		sta $b0		   STA CMPO          ; clear tape timing constant min byte
.f8d7	85 9e		sta $9e		   STA PTR1          ; clear tape pass 1 error log/char buffer
.f8d9	85 9f		sta $9f		   STA PTR2          ; clear tape pass 2 error log corrected
.f8db	85 9c		sta $9c		   STA DPSW          ; clear byte received flag
.f8dd	a9 82		lda #$82	   LDA #$82          ; enable CA1 interrupt
.f8df	a2 0e		ldx #$0e	   LDX #$0E          ; set index for tape read vector
.f8e1	d0 11		bne $f8f4	   BNE TAWR_20      ; go do tape read/write, branch always
.f8e3					  Init_Tape_Write
.f8e3	20 54 f8	jsr $f854	   JSR TAPE_Set_Buffer_Pointer
.f8e6					  TAPE_Write_With_Lead
.f8e6	a9 14		lda #$14	   LDA #20           ; set write lead cycle count
.f8e8	85 ab		sta $ab		   STA RIPRTY        ; save write lead cycle count
.f8ea					  TAPE_Write
.f8ea	20 b7 f8	jsr $f8b7	   JSR TAPE_Wait_For_Record
.f8ed					TAWR_10
.f8ed	b0 68		bcs $f957	   BCS Clear_Saved_IRQ_Address
.f8ef	78		sei		   SEI               ; disable interrupts
.f8f0	a9 a0		lda #$a0	   LDA #$A0          ; enable VIA 2 T2 interrupt
.f8f2	a2 08		ldx #$08	   LDX #$08          ; set index for tape write tape leader vector
.f8f4					TAWR_20
.f8f4	a0 7f		ldy #$7f	   LDY #$7F          ; disable all interrupts
.f8f6	8c 2e 91	sty $912e	   STY VIA2_IER      ; set VIA 2 IER, disable interrupts
.f8f9	8d 2e 91	sta $912e	   STA VIA2_IER      ; set VIA 2 IER, enable interrupts according to A
.f8fc	20 60 f1	jsr $f160	   JSR RS232_Stop
.f8ff	ad 14 03	lda $0314	   LDA CINV          ; get IRQ vector low byte
.f902	8d 9f 02	sta $029f	   STA IRQTMP        ; save IRQ vector low byte
.f905	ad 15 03	lda $0315	   LDA CINV+1        ; get IRQ vector high byte
.f908	8d a0 02	sta $02a0	   STA IRQTMP+1      ; save IRQ vector high byte
.f90b	20 fb fc	jsr $fcfb	   JSR TAPE_Set_IRQ_Vector
.f90e	a9 02		lda #$02	   LDA #$02          ; set copies count. the first copy is the load copy, the
.f910	85 be		sta $be		   STA FSBLK         ; save copies count
.f912	20 db fb	jsr $fbdb	   JSR TAPE_New_Byte_Setup
.f915	ad 1c 91	lda $911c	   LDA VIA1_PCR      ; get VIA 1 PCR
.f918	29 fd		and #$fd	   AND #$FD          ; CA2 low, turn on tape motor
.f91a	09 0c		ora #$0c	   ORA #$0C          ; manual output mode
.f91c	8d 1c 91	sta $911c	   STA VIA1_PCR      ; set VIA 1 PCR
.f91f	85 c0		sta $c0		   STA CAS1          ; set tape motor interlock
.f921	a2 ff		ldx #$ff	   LDX #$FF          ; outer loop count
.f923					TAWR_30
.f923	a0 ff		ldy #$ff	   LDY #$FF          ; inner loop count
.f925					TAWR_40
.f925	88		dey		   DEY               ; decrement inner loop count
.f926	d0 fd		bne $f925	   BNE TAWR_40      ; loop if more to do
.f928	ca		dex		   DEX               ; decrement outer loop count
.f929	d0 f8		bne $f923	   BNE TAWR_30      ; loop if more to do
.f92b	8d 29 91	sta $9129	   STA VIA2_T2CH     ; set VIA 2 T2C_h
.f92e	58		cli		   CLI               ; enable tape interrupts
.f92f					TAWR_50
.f92f	ad a0 02	lda $02a0	   LDA IRQTMP+1      ; get saved IRQ high byte
.f932	cd 15 03	cmp $0315	   CMP CINV+1        ; compare with the current IRQ high byte
.f935	18		clc		   CLC               ; flag ok
.f936	f0 1f		beq $f957	   BEQ Clear_Saved_IRQ_Address
.f938	20 4b f9	jsr $f94b	   JSR TAPE_Abort_On_STOP
.f93b	ad 2d 91	lda $912d	   LDA IEC_IFR       ; get VIA 2 IFR
.f93e	29 40		and #$40	   AND #$40          ; mask T1 interrupt
.f940	f0 ed		beq $f92f	   BEQ TAWR_50      ; loop if not T1 interrupt
.f942	ad 14 91	lda $9114	   LDA RS2_TIM_LOW   ; get VIA 1 T1C_l, clear T1 flag
.f945	20 34 f7	jsr $f734	   JSR Kernal_UDTIM  ; Update the system clock
.f948	4c 2f f9	jmp $f92f	   JMP TAWR_50      ; loop
.f94b					  TAPE_Abort_On_STOP
.f94b	20 e1 ff	jsr $ffe1	   JSR STOP          ; Check if stop key is pressed
.f94e	18		clc		   CLC               ; flag no stop
.f94f	d0 0b		bne $f95c	   BNE CSIA_Ret      ; exit if no stop
.f951	20 cf fc	jsr $fccf	   JSR Restoring_After_STOP
.f954	38		sec		   SEC               ; flag stopped
.f955	68		pla		   PLA               ; dump return address low byte
.f956	68		pla		   PLA               ; dump return address high byte
.f957					  Clear_Saved_IRQ_Address
.f957	a9 00		lda #$00	   LDA #0
.f959	8d a0 02	sta $02a0	   STA IRQTMP+1      ; clear saved IRQ address high byte
.f95c					CSIA_Ret
.f95c	60		rts		   RTS
.f95d					  TAPE_Set_Timer
.f95d	86 b1		stx $b1		   STX CMPO+1        ; save tape timing constant max byte
.f95f	a5 b0		lda $b0		   LDA CMPO          ; get tape timing constant min byte
.f961	0a		asl a		   ASL A             ; *2
.f962	0a		asl a		   ASL A             ; *4
.f963	18		clc		   CLC
.f964	65 b0		adc $b0		   ADC CMPO          ; add tape timing constant min byte *5
.f966	18		clc		   CLC
.f967	65 b1		adc $b1		   ADC CMPO+1        ; add tape timing constant max byte
.f969	85 b1		sta $b1		   STA CMPO+1        ; save tape timing constant max byte
.f96b	a9 00		lda #$00	   LDA #$00          ;.
.f96d	24 b0		bit $b0		   BIT CMPO          ; test tape timing constant min byte
.f96f	30 01		bmi $f972	   BMI TST_10        ; branch if b7 set
.f971	2a		rol a		   ROL A             ; else shift carry into ??
.f972					TST_10
.f972	06 b1		asl $b1		   ASL CMPO+1        ; shift tape timing constant max byte
.f974	2a		rol a		   ROL A
.f975	06 b1		asl $b1		   ASL CMPO+1        ; shift tape timing constant max byte
.f977	2a		rol a		   ROL A
.f978	aa		tax		   TAX
.f979					TST_20
.f979	ad 28 91	lda $9128	   LDA VIA2_T2CL     ; get VIA 2 T2C_l
.f97c	c9 15		cmp #$15	   CMP #$15
.f97e	90 f9		bcc $f979	   BCC TST_20        ; loop if less
.f980	65 b1		adc $b1		   ADC CMPO+1        ; add tape timing constant max byte
.f982	8d 24 91	sta $9124	   STA VIA2_T1CL     ; set VIA 2 T1C_l
.f985	8a		txa		   TXA
.f986	6d 29 91	adc $9129	   ADC VIA2_T2CH     ; add VIA 2 T2C_h
.f989	8d 25 91	sta $9125	   STA VIA2_T1CH     ; set VIA 2 T1C_h
.f98c	58		cli		   CLI
.f98d	60		rts		   RTS
.f98e					  TAPE_Read_IRQ
.f98e	ae 29 91	ldx $9129	   LDX VIA2_T2CH     ; get VIA 2 T2C_h
.f991	a0 ff		ldy #$ff	   LDY #$FF
.f993	98		tya		   TYA
.f994	ed 28 91	sbc $9128	   SBC VIA2_T2CL     ; subtract VIA 2 T2C_l
.f997	ec 29 91	cpx $9129	   CPX VIA2_T2CH     ; compare VIA 2 T2C_h with previous
.f99a	d0 f2		bne $f98e	   BNE TAPE_Read_IRQ ; loop if timer low byte rolled over
.f99c	86 b1		stx $b1		   STX CMPO+1        ; save tape timing constant max byte
.f99e	aa		tax		   TAX               ; copy $FF - T2C_l
.f99f	8c 28 91	sty $9128	   STY VIA2_T2CL     ; set VIA 2 T2C_l to $FF
.f9a2	8c 29 91	sty $9129	   STY VIA2_T2CH     ; set VIA 2 T2C_h to $FF
.f9a5	98		tya		   TYA
.f9a6	e5 b1		sbc $b1		   SBC CMPO+1        ; subtract tape timing constant max byte
.f9a8	86 b1		stx $b1		   STX CMPO+1        ; save tape timing constant max byte
.f9aa	4a		lsr a		   LSR A             ; A = $FF - T2C_h >> 1
.f9ab	66 b1		ror $b1		   ROR CMPO+1        ; shift tape timing constant max byte
.f9ad	4a		lsr a		   LSR A             ; A = $FF - T2C_h >> 1
.f9ae	66 b1		ror $b1		   ROR CMPO+1        ; shift tape timing constant max byte
.f9b0	a5 b0		lda $b0		   LDA CMPO          ; get tape timing constant min byte
.f9b2	18		clc		   CLC
.f9b3	69 3c		adc #$3c	   ADC #$3C
.f9b5	2c 21 91	bit $9121	   BIT KEYB_ROW      ; test VIA 2 DRA, keyboard row
.f9b8	c5 b1		cmp $b1		   CMP CMPO+1        ; compare with tape timing constant max byte
.f9ba	b0 4a		bcs $fa06	   BCS TARI_14       ; branch if min + $3C >= ($FFFF - T2C) >> 2
.f9bc	a6 9c		ldx $9c		   LDX DPSW          ; get byte received flag
.f9be	f0 03		beq $f9c3	   BEQ TARI_02       ; branch if not byte received
.f9c0	4c ad fa	jmp $faad	   JMP TAPE_Store_Char      ; store tape character
.f9c3					TARI_02
.f9c3	a6 a3		ldx $a3		   LDX TSFCNT        ; get EOI flag byte
.f9c5	30 1b		bmi $f9e2	   BMI TARI_04
.f9c7	a2 00		ldx #$00	   LDX #$00
.f9c9	69 30		adc #$30	   ADC #$30
.f9cb	65 b0		adc $b0		   ADC CMPO          ; add tape timing constant min byte
.f9cd	c5 b1		cmp $b1		   CMP CMPO+1        ; compare with tape timing constant max byte
.f9cf	b0 1c		bcs $f9ed	   BCS TARI_08
.f9d1	e8		inx		   INX
.f9d2	69 26		adc #$26	   ADC #$26
.f9d4	65 b0		adc $b0		   ADC CMPO          ; add tape timing constant min byte
.f9d6	c5 b1		cmp $b1		   CMP CMPO+1        ; compare with tape timing constant max byte
.f9d8	b0 17		bcs $f9f1	   BCS TARI_10
.f9da	69 2c		adc #$2c	   ADC #$2C
.f9dc	65 b0		adc $b0		   ADC CMPO          ; add tape timing constant min byte
.f9de	c5 b1		cmp $b1		   CMP CMPO+1        ; compare with tape timing constant max byte
.f9e0	90 03		bcc $f9e5	   BCC TARI_06
.f9e2					TARI_04
.f9e2	4c 60 fa	jmp $fa60	   JMP TARI_30
.f9e5					TARI_06
.f9e5	a5 b4		lda $b4		   LDA BITTS         ; get bit count
.f9e7	f0 1d		beq $fa06	   BEQ TARI_14       ; branch if zero
.f9e9	85 a8		sta $a8		   STA BITCI         ; save receiver bit count in
.f9eb	d0 19		bne $fa06	   BNE TARI_14       ; branch always
.f9ed					TARI_08
.f9ed	e6 a9		inc $a9		   INC RINONE        ; increment ?? start bit check flag
.f9ef	b0 02		bcs $f9f3	   BCS TARI_12
.f9f1					TARI_10
.f9f1	c6 a9		dec $a9		   DEC RINONE        ; decrement ?? start bit check flag
.f9f3					TARI_12
.f9f3	38		sec		   SEC
.f9f4	e9 13		sbc #$13	   SBC #$13
.f9f6	e5 b1		sbc $b1		   SBC CMPO+1        ; subtract tape timing constant max byte
.f9f8	65 92		adc $92		   ADC SVXT          ; add timing constant for tape
.f9fa	85 92		sta $92		   STA SVXT          ; save timing constant for tape
.f9fc	a5 a4		lda $a4		   LDA TBTCNT        ; get tape bit cycle phase
.f9fe	49 01		eor #$01	   EOR #$01
.fa00	85 a4		sta $a4		   STA TBTCNT        ; save tape bit cycle phase
.fa02	f0 21		beq $fa25	   BEQ TARI_22
.fa04	86 d7		stx $d7		   STX LASTKY
.fa06					TARI_14
.fa06	a5 b4		lda $b4		   LDA BITTS         ; get bit count
.fa08	f0 18		beq $fa22	   BEQ TARI_20       ; exit if zero
.fa0a	2c 2d 91	bit $912d	   BIT IEC_IFR       ; test get 2 IFR
.fa0d	50 13		bvc $fa22	   BVC TARI_20       ; exit if no T1 interrupt
.fa0f	a9 00		lda #$00	   LDA #$00
.fa11	85 a4		sta $a4		   STA TBTCNT        ; clear tape bit cycle phase
.fa13	a5 a3		lda $a3		   LDA TSFCNT        ;.get EOI flag byte
.fa15	10 30		bpl $fa47	   BPL TARI_28
.fa17	30 c9		bmi $f9e2	   BMI TARI_04
.fa19					TARI_18
.fa19	a2 a6		ldx #$a6	   LDX #$A6          ; set timimg max byte
.fa1b	20 5d f9	jsr $f95d	   JSR TAPE_Set_Timer
.fa1e	a5 9b		lda $9b		   LDA PRTY
.fa20	d0 c3		bne $f9e5	   BNE TARI_06
.fa22					TARI_20
.fa22	4c 56 ff	jmp $ff56	   JMP Exit_IRQ      ; restore registers and exit interrupt
.fa25					TARI_22
.fa25	a5 92		lda $92		   LDA SVXT          ; get timing constant for tape
.fa27	f0 07		beq $fa30	   BEQ TARI_26
.fa29	30 03		bmi $fa2e	   BMI TARI_24
.fa2b	c6 b0		dec $b0		   DEC CMPO          ; decrement tape timing constant min byte
>fa2d	2c				   .byte   $2C
.fa2e					TARI_24
.fa2e	e6 b0		inc $b0		   INC CMPO          ; increment tape timing constant min byte
.fa30					TARI_26
.fa30	a9 00		lda #$00	   LDA #0
.fa32	85 92		sta $92		   STA SVXT          ; clear timing constant for tape
.fa34	e4 d7		cpx $d7		   CPX LASTKY
.fa36	d0 0f		bne $fa47	   BNE TARI_28
.fa38	8a		txa		   TXA
.fa39	d0 aa		bne $f9e5	   BNE TARI_06
.fa3b	a5 a9		lda $a9		   LDA RINONE        ; get start bit check flag
.fa3d	30 c7		bmi $fa06	   BMI TARI_14
.fa3f	c9 10		cmp #$10	   CMP #$10
.fa41	90 c3		bcc $fa06	   BCC TARI_14
.fa43	85 96		sta $96		   STA SYNO          ; save cassette block synchronization number
.fa45	b0 bf		bcs $fa06	   BCS TARI_14
.fa47					TARI_28
.fa47	8a		txa		   TXA
.fa48	45 9b		eor $9b		   EOR PRTY
.fa4a	85 9b		sta $9b		   STA PRTY
.fa4c	a5 b4		lda $b4		   LDA BITTS
.fa4e	f0 d2		beq $fa22	   BEQ TARI_20
.fa50	c6 a3		dec $a3		   DEC TSFCNT        ; decrement EOI flag byte
.fa52	30 c5		bmi $fa19	   BMI TARI_18
.fa54	46 d7		lsr $d7		   LSR LASTKY
.fa56	66 bf		ror $bf		   ROR MYCH          ; parity count
.fa58	a2 da		ldx #$da	   LDX #$DA          ; set timimg max byte
.fa5a	20 5d f9	jsr $f95d	   JSR TAPE_Set_Timer
.fa5d	4c 56 ff	jmp $ff56	   JMP Exit_IRQ      ; restore registers and exit interrupt
.fa60					TARI_30
.fa60	a5 96		lda $96		   LDA SYNO          ; get cassette block synchronization number
.fa62	f0 04		beq $fa68	   BEQ TARI_32
.fa64	a5 b4		lda $b4		   LDA BITTS
.fa66	f0 04		beq $fa6c	   BEQ TARI_34
.fa68					TARI_32
.fa68	a5 a3		lda $a3		   LDA TSFCNT        ; get EOI flag byte
.fa6a	10 85		bpl $f9f1	   BPL TARI_10
.fa6c					TARI_34
.fa6c	46 b1		lsr $b1		   LSR CMPO+1        ; shift tape timing constant max byte
.fa6e	a9 93		lda #$93	   LDA #$93
.fa70	38		sec		   SEC
.fa71	e5 b1		sbc $b1		   SBC CMPO+1        ; subtract tape timing constant max byte
.fa73	65 b0		adc $b0		   ADC CMPO          ; add tape timing constant min byte
.fa75	0a		asl a		   ASL A
.fa76	aa		tax		   TAX               ; copy timimg high byte
.fa77	20 5d f9	jsr $f95d	   JSR TAPE_Set_Timer      ; set timing
.fa7a	e6 9c		inc $9c		   INC DPSW
.fa7c	a5 b4		lda $b4		   LDA BITTS
.fa7e	d0 11		bne $fa91	   BNE TARI_36
.fa80	a5 96		lda $96		   LDA SYNO          ; get cassette block synchronization number
.fa82	f0 26		beq $faaa	   BEQ TARI_40
.fa84	85 a8		sta $a8		   STA BITCI         ; save receiver bit count in
.fa86	a9 00		lda #$00	   LDA #$00
.fa88	85 96		sta $96		   STA SYNO          ; clear cassette block synchronization number
.fa8a	a9 c0		lda #$c0	   LDA #$C0          ; enable T1 interrupt
.fa8c	8d 2e 91	sta $912e	   STA VIA2_IER      ; set VIA 2 IER
.fa8f	85 b4		sta $b4		   STA BITTS
.fa91					TARI_36
.fa91	a5 96		lda $96		   LDA SYNO          ; get cassette block synchronization number
.fa93	85 b5		sta $b5		   STA NXTBIT
.fa95	f0 09		beq $faa0	   BEQ TARI_38
.fa97	a9 00		lda #$00	   LDA #$00
.fa99	85 b4		sta $b4		   STA BITTS
.fa9b	a9 40		lda #$40	   LDA #$40          ; disable T1 interrupt
.fa9d	8d 2e 91	sta $912e	   STA VIA2_IER      ; set VIA 2 IER
.faa0					TARI_38
.faa0	a5 bf		lda $bf		   LDA MYCH          ; parity count
.faa2	85 bd		sta $bd		   STA ROPRTY        ; save RS232 parity byte
.faa4	a5 a8		lda $a8		   LDA BITCI         ; get receiver bit count in
.faa6	05 a9		ora $a9		   ORA RINONE        ; OR with start bit check flag
.faa8	85 b6		sta $b6		   STA RODATA
.faaa					TARI_40
.faaa	4c 56 ff	jmp $ff56	   JMP Exit_IRQ      ; restore registers and exit interrupt
.faad					  TAPE_Store_Char
.faad	20 db fb	jsr $fbdb	   JSR TAPE_New_Byte_Setup
.fab0	85 9c		sta $9c		   STA DPSW          ; clear byte received flag
.fab2	a2 da		ldx #$da	   LDX #$DA          ; set timimg max byte
.fab4	20 5d f9	jsr $f95d	   JSR TAPE_Set_Timer
.fab7	a5 be		lda $be		   LDA FSBLK         ; get copies count
.fab9	f0 02		beq $fabd	   BEQ TASC_10
.fabb	85 a7		sta $a7		   STA INBIT         ; save receiver input bit temporary storage
.fabd					TASC_10
.fabd	a9 0f		lda #$0f	   LDA #$0F
.fabf	24 aa		bit $aa		   BIT RIDATA
.fac1	10 17		bpl $fada	   BPL TASC_40
.fac3	a5 b5		lda $b5		   LDA NXTBIT
.fac5	d0 0c		bne $fad3	   BNE TASC_20
.fac7	a6 be		ldx $be		   LDX FSBLK         ; get copies count
.fac9	ca		dex		   DEX
.faca	d0 0b		bne $fad7	   BNE TASC_30       ; if ?? restore registers and exit interrupt
.facc	a9 08		lda #$08	   LDA #$08          ; set short block
.face	20 6a fe	jsr $fe6a	   JSR Ora_Status
.fad1	d0 04		bne $fad7	   BNE TASC_30       ; restore registers and exit interrupt, branch always
.fad3					TASC_20
.fad3	a9 00		lda #$00	   LDA #$00
.fad5	85 aa		sta $aa		   STA RIDATA
.fad7					TASC_30
.fad7	4c 56 ff	jmp $ff56	   JMP Exit_IRQ      ; restore registers and exit interrupt
.fada					TASC_40
.fada	70 31		bvs $fb0d	   BVS TASC_64
.fadc	d0 18		bne $faf6	   BNE TASC_60
.fade	a5 b5		lda $b5		   LDA NXTBIT
.fae0	d0 f5		bne $fad7	   BNE TASC_30
.fae2	a5 b6		lda $b6		   LDA RODATA
.fae4	d0 f1		bne $fad7	   BNE TASC_30
.fae6	a5 a7		lda $a7		   LDA INBIT         ; get receiver input bit temporary storage
.fae8	4a		lsr a		   LSR A
.fae9	a5 bd		lda $bd		   LDA ROPRTY        ; get RS232 parity byte
.faeb	30 03		bmi $faf0	   BMI TASC_50
.faed	90 18		bcc $fb07	   BCC TASC_62
.faef	18		clc		   CLC
.faf0					TASC_50
.faf0	b0 15		bcs $fb07	   BCS TASC_62
.faf2	29 0f		and #$0f	   AND #$0F
.faf4	85 aa		sta $aa		   STA RIDATA
.faf6					TASC_60
.faf6	c6 aa		dec $aa		   DEC RIDATA
.faf8	d0 dd		bne $fad7	   BNE TASC_30
.fafa	a9 40		lda #$40	   LDA #$40
.fafc	85 aa		sta $aa		   STA RIDATA
.fafe	20 d2 fb	jsr $fbd2	   JSR Set_IO_Start
.fb01	a9 00		lda #$00	   LDA #0
.fb03	85 ab		sta $ab		   STA RIPRTY
.fb05	f0 d0		beq $fad7	   BEQ TASC_30      ; branch always
.fb07					TASC_62
.fb07	a9 80		lda #$80	   LDA #$80
.fb09	85 aa		sta $aa		   STA RIDATA
.fb0b	d0 ca		bne $fad7	   BNE TASC_30      ; restore registers and exit interrupt, branch always
.fb0d					TASC_64
.fb0d	a5 b5		lda $b5		   LDA NXTBIT
.fb0f	f0 0a		beq $fb1b	   BEQ TASC_66
.fb11					TASC_65
.fb11	a9 04		lda #$04	   LDA #$04
.fb13	20 6a fe	jsr $fe6a	   JSR Ora_Status
.fb16	a9 00		lda #$00	   LDA #$00
.fb18	4c 97 fb	jmp $fb97	   JMP TASC_84
.fb1b					TASC_66
.fb1b	20 11 fd	jsr $fd11	   JSR Check_IO_End
.fb1e	90 03		bcc $fb23	   BCC TASC_68
.fb20	4c 95 fb	jmp $fb95	   JMP TASC_82
.fb23					TASC_68
.fb23	a6 a7		ldx $a7		   LDX INBIT         ; get receiver input bit temporary storage
.fb25	ca		dex		   DEX
.fb26	f0 2d		beq $fb55	   BEQ TASC_72
.fb28	a5 93		lda $93		   LDA VERCKK
.fb2a	f0 0c		beq $fb38	   BEQ TASC_70
.fb2c	a0 00		ldy #$00	   LDY #0
.fb2e	a5 bd		lda $bd		   LDA ROPRTY
.fb30	d1 ac		cmp ($ac),y	   CMP (SAL),Y
.fb32	f0 04		beq $fb38	   BEQ TASC_70
.fb34	a9 01		lda #$01	   LDA #$01
.fb36	85 b6		sta $b6		   STA RODATA
.fb38					TASC_70
.fb38	a5 b6		lda $b6		   LDA RODATA
.fb3a	f0 4b		beq $fb87	   BEQ TASC_78
.fb3c	a2 3d		ldx #$3d	   LDX #$3D
.fb3e	e4 9e		cpx $9e		   CPX PTR1
.fb40	90 3e		bcc $fb80	   BCC TASC_76
.fb42	a6 9e		ldx $9e		   LDX PTR1
.fb44	a5 ad		lda $ad		   LDA SAL+1
.fb46	9d 01 01	sta $0101,x	   STA STACK+1,X
.fb49	a5 ac		lda $ac		   LDA SAL
.fb4b	9d 00 01	sta $0100,x	   STA STACK,X
.fb4e	e8		inx		   INX
.fb4f	e8		inx		   INX
.fb50	86 9e		stx $9e		   STX PTR1
.fb52	4c 87 fb	jmp $fb87	   JMP TASC_78
.fb55					TASC_72
.fb55	a6 9f		ldx $9f		   LDX PTR2
.fb57	e4 9e		cpx $9e		   CPX PTR1
.fb59	f0 35		beq $fb90	   BEQ TASC_80
.fb5b	a5 ac		lda $ac		   LDA SAL
.fb5d	dd 00 01	cmp $0100,x	   CMP STACK,X
.fb60	d0 2e		bne $fb90	   BNE TASC_80
.fb62	a5 ad		lda $ad		   LDA SAL+1
.fb64	dd 01 01	cmp $0101,x	   CMP STACK+1,X
.fb67	d0 27		bne $fb90	   BNE TASC_80
.fb69	e6 9f		inc $9f		   INC PTR2
.fb6b	e6 9f		inc $9f		   INC PTR2
.fb6d	a5 93		lda $93		   LDA VERCKK        ; get load/verify flag
.fb6f	f0 0b		beq $fb7c	   BEQ TASC_74      ; branch if load
.fb71	a5 bd		lda $bd		   LDA ROPRTY        ; get RS232 parity byte
.fb73	a0 00		ldy #$00	   LDY #$00
.fb75	d1 ac		cmp ($ac),y	   CMP (SAL),Y
.fb77	f0 17		beq $fb90	   BEQ TASC_80
.fb79	c8		iny		   INY
.fb7a	84 b6		sty $b6		   STY RODATA
.fb7c					TASC_74
.fb7c	a5 b6		lda $b6		   LDA RODATA
.fb7e	f0 07		beq $fb87	   BEQ TASC_78
.fb80					TASC_76
.fb80	a9 10		lda #$10	   LDA #$10
.fb82	20 6a fe	jsr $fe6a	   JSR Ora_Status
.fb85	d0 09		bne $fb90	   BNE TASC_80
.fb87					TASC_78
.fb87	a5 93		lda $93		   LDA VERCKK        ; get load/verify flag
.fb89	d0 05		bne $fb90	   BNE TASC_80       ; branch if verify
.fb8b	a8		tay		   TAY
.fb8c	a5 bd		lda $bd		   LDA ROPRTY        ; get RS232 parity byte
.fb8e	91 ac		sta ($ac),y	   STA (SAL),Y
.fb90					TASC_80
.fb90	20 1b fd	jsr $fd1b	   JSR Inc_SAL_Word
.fb93	d0 3a		bne $fbcf	   BNE TASC_92      ; restore registers and exit interrupt, branch always
.fb95					TASC_82
.fb95	a9 80		lda #$80	   LDA #$80
.fb97					TASC_84
.fb97	85 aa		sta $aa		   STA RIDATA
.fb99	a6 be		ldx $be		   LDX FSBLK         ; get copies count
.fb9b	ca		dex		   DEX
.fb9c	30 02		bmi $fba0	   BMI TASC_86
.fb9e	86 be		stx $be		   STX FSBLK         ; save copies count
.fba0					TASC_86
.fba0	c6 a7		dec $a7		   DEC INBIT         ; decrement receiver input bit temporary storage
.fba2	f0 08		beq $fbac	   BEQ TASC_88
.fba4	a5 9e		lda $9e		   LDA PTR1
.fba6	d0 27		bne $fbcf	   BNE TASC_92       ; if ?? restore registers and exit interrupt
.fba8	85 be		sta $be		   STA FSBLK         ; save copies count
.fbaa	f0 23		beq $fbcf	   BEQ TASC_92       ; restore registers and exit interrupt, branch always
.fbac					TASC_88
.fbac	20 cf fc	jsr $fccf	   JSR Restoring_After_STOP
.fbaf	20 d2 fb	jsr $fbd2	   JSR Set_IO_Start
.fbb2	a0 00		ldy #$00	   LDY #0
.fbb4	84 ab		sty $ab		   STY RIPRTY        ; clear checksum
.fbb6					TASC_90
.fbb6	b1 ac		lda ($ac),y	   LDA (SAL),Y       ; get byte from buffer
.fbb8	45 ab		eor $ab		   EOR RIPRTY        ; XOR with checksum
.fbba	85 ab		sta $ab		   STA RIPRTY        ; save new checksum
.fbbc	20 1b fd	jsr $fd1b	   JSR Inc_SAL_Word
.fbbf	20 11 fd	jsr $fd11	   JSR Check_IO_End
.fbc2	90 f2		bcc $fbb6	   BCC TASC_90       ; loop if not at end
.fbc4	a5 ab		lda $ab		   LDA RIPRTY        ; get computed checksum
.fbc6	45 bd		eor $bd		   EOR ROPRTY        ; compare with stored checksum ??
.fbc8	f0 05		beq $fbcf	   BEQ TASC_92       ; if checksum ok restore registers and exit interrupt
.fbca	a9 20		lda #$20	   LDA #$20          ; else set checksum error
.fbcc	20 6a fe	jsr $fe6a	   JSR Ora_Status
.fbcf					TASC_92
.fbcf	4c 56 ff	jmp $ff56	   JMP Exit_IRQ      ; restore registers and exit interrupt
.fbd2					Set_IO_Start
.fbd2	a5 c2		lda $c2		   LDA STAL+1        ; get I/O start address high byte
.fbd4	85 ad		sta $ad		   STA SAL+1         ; set buffer address high byte
.fbd6	a5 c1		lda $c1		   LDA STAL          ; get I/O start address low byte
.fbd8	85 ac		sta $ac		   STA SAL           ; set buffer address low byte
.fbda	60		rts		   RTS
.fbdb					  TAPE_New_Byte_Setup
.fbdb	a9 08		lda #$08	   LDA #$08          ; eight bits to do
.fbdd	85 a3		sta $a3		   STA TSFCNT        ; set bit count
.fbdf	a9 00		lda #$00	   LDA #0
.fbe1	85 a4		sta $a4		   STA TBTCNT        ; clear tape bit cycle phase
.fbe3	85 a8		sta $a8		   STA BITCI         ; clear start bit first cycle done flag
.fbe5	85 9b		sta $9b		   STA PRTY          ; clear byte parity
.fbe7	85 a9		sta $a9		   STA RINONE        ; clear start bit check flag, set no start bit yet
.fbe9	60		rts		   RTS
.fbea					  TAPE_Write_Bit
.fbea	a5 bd		lda $bd		   LDA ROPRTY        ; get tape write byte
.fbec	4a		lsr a		   LSR A             ; shift lsb into Cb
.fbed	a9 60		lda #$60	   LDA #$60          ; set time constant low byte for bit = 0
.fbef	90 02		bcc $fbf3	   BCC TAPE_Write_Timer
.fbf1					  TAPE_Timer_Bit_Is_1
.fbf1	a9 b0		lda #$b0	   LDA #$B0          ; set time constant low byte for bit = 1
.fbf3					  TAPE_Write_Timer
.fbf3	a2 00		ldx #$00	   LDX #$00          ; set time constant high byte
.fbf5					  TAPE_Start_Timer
.fbf5	8d 28 91	sta $9128	   STA VIA2_T2CL     ; set VIA 2 T2C_l
.fbf8	8e 29 91	stx $9129	   STX VIA2_T2CH     ; set VIA 2 T2C_h
.fbfb	ad 20 91	lda $9120	   LDA KEYB_COL      ; get VIA 2 DRB, keyboard column
.fbfe	49 08		eor #$08	   EOR #$08          ; toggle tape out bit
.fc00	8d 20 91	sta $9120	   STA KEYB_COL      ; set VIA 2 DRB
.fc03	29 08		and #$08	   AND #$08          ; mask tape out bit
.fc05	60		rts		   RTS
.fc06					TAST_10
.fc06	38		sec		   SEC               ; set carry flag
.fc07	66 ad		ror $ad		   ROR SAL+1         ; set buffer address high byte negative, flag all sync,
.fc09	30 3c		bmi $fc47	   BMI TAWI_15      ; restore registers and exit interrupt, branch always
.fc0b					  TAPE_Write_IRQ
.fc0b	a5 a8		lda $a8		   LDA BITCI         ; get start bit first cycle done flag
.fc0d	d0 12		bne $fc21	   BNE TAWI_05       ; if first cycle done go do rest of byte
.fc0f	a9 10		lda #$10	   LDA #$10          ; set first start cycle time constant low byte
.fc11	a2 01		ldx #$01	   LDX #$01          ; set first start cycle time constant high byte
.fc13	20 f5 fb	jsr $fbf5	   JSR TAPE_Start_Timer
.fc16	d0 2f		bne $fc47	   BNE TAWI_15      ; if first half cycle go restore registers and exit
.fc18	e6 a8		inc $a8		   INC BITCI         ; set start bit first start cycle done flag
.fc1a	a5 ad		lda $ad		   LDA SAL+1         ; get buffer address high byte
.fc1c	10 29		bpl $fc47	   BPL TAWI_15      ; if block not complete go restore registers and exit
.fc1e	4c 95 fc	jmp $fc95	   JMP TAWI_55      ; else do tape routine, block complete exit
.fc21					TAWI_05
.fc21	a5 a9		lda $a9		   LDA RINONE        ; get start bit check flag
.fc23	d0 09		bne $fc2e	   BNE TAWI_10       ; if the start bit is complete go send the byte bits
.fc25	20 f1 fb	jsr $fbf1	   JSR TAPE_Timer_Bit_Is_1
.fc28	d0 1d		bne $fc47	   BNE TAWI_15       ; if first half cycle go restore registers and exit
.fc2a	e6 a9		inc $a9		   INC RINONE        ; set start bit check flag
.fc2c	d0 19		bne $fc47	   BNE TAWI_15       ; restore registers and exit interrupt, branch always
.fc2e					TAWI_10
.fc2e	20 ea fb	jsr $fbea	   JSR TAPE_Write_Bit
.fc31	d0 14		bne $fc47	   BNE TAWI_15       ; if first half cycle go restore registers and exit
.fc33	a5 a4		lda $a4		   LDA TBTCNT        ; get tape bit cycle phase
.fc35	49 01		eor #$01	   EOR #$01          ; toggle b0
.fc37	85 a4		sta $a4		   STA TBTCNT        ; save tape bit cycle phase
.fc39	f0 0f		beq $fc4a	   BEQ TAWI_20       ; if bit cycle phase complete go setup for next bit
.fc3b	a5 bd		lda $bd		   LDA ROPRTY        ; get tape write byte
.fc3d	49 01		eor #$01	   EOR #$01          ; invert bit being sent
.fc3f	85 bd		sta $bd		   STA ROPRTY        ; save tape write byte
.fc41	29 01		and #$01	   AND #$01          ; mask b0
.fc43	45 9b		eor $9b		   EOR PRTY          ; EOR with tape write byte parity bit
.fc45	85 9b		sta $9b		   STA PRTY          ; save tape write byte parity bit
.fc47					TAWI_15
.fc47	4c 56 ff	jmp $ff56	   JMP Exit_IRQ      ; restore registers and exit interrupt
.fc4a					TAWI_20
.fc4a	46 bd		lsr $bd		   LSR ROPRTY        ; shift bit out of tape write byte
.fc4c	c6 a3		dec $a3		   DEC TSFCNT        ; decrement tape write bit count
.fc4e	a5 a3		lda $a3		   LDA TSFCNT        ; get tape write bit count
.fc50	f0 3a		beq $fc8c	   BEQ TAWI_45       ; if all the data bits have been written go setup for
.fc52	10 f3		bpl $fc47	   BPL TAWI_15       ; if all the data bits are not yet sent just restore the
.fc54					TAWI_25
.fc54	20 db fb	jsr $fbdb	   JSR TAPE_New_Byte_Setup
.fc57	58		cli		   CLI               ; enable interrupts
.fc58	a5 a5		lda $a5		   LDA CNTDN         ; get cassette synchronization character count
.fc5a	f0 12		beq $fc6e	   BEQ TAWI_35       ; if synchronisation characters done go do block data
.fc5c	a2 00		ldx #$00	   LDX #$00          ; clear X
.fc5e	86 d7		stx $d7		   STX LASTKY        ; clear checksum byte
.fc60	c6 a5		dec $a5		   DEC CNTDN         ; decrement cassette synchronization byte count
.fc62	a6 be		ldx $be		   LDX FSBLK         ; get cassette copies count
.fc64	e0 02		cpx #$02	   CPX #$02          ; compare with load block indicator
.fc66	d0 02		bne $fc6a	   BNE TAWI_30       ; branch if not the load block
.fc68	09 80		ora #$80	   ORA #$80          ; this is the load block so make the synchronisation count
.fc6a					TAWI_30
.fc6a	85 bd		sta $bd		   STA ROPRTY        ; save the synchronisation byte as the tape write byte
.fc6c	d0 d9		bne $fc47	   BNE TAWI_15       ; restore registers and exit interrupt, branch always
.fc6e					TAWI_35
.fc6e	20 11 fd	jsr $fd11	   JSR Check_IO_End
.fc71	90 0a		bcc $fc7d	   BCC TAWI_40       ; if not all done yet go get the byte to send
.fc73	d0 91		bne $fc06	   BNE TAST_10       ; if pointer > end go flag block done and exit interrupt
.fc75	e6 ad		inc $ad		   INC SAL+1         ; increment buffer pointer high byte, this means the block
.fc77	a5 d7		lda $d7		   LDA LASTKY        ; get checksum byte
.fc79	85 bd		sta $bd		   STA ROPRTY        ; save checksum as tape write byte
.fc7b	b0 ca		bcs $fc47	   BCS TAWI_15       ; restore registers and exit interrupt, branch always
.fc7d					TAWI_40
.fc7d	a0 00		ldy #$00	   LDY #0
.fc7f	b1 ac		lda ($ac),y	   LDA (SAL),Y       ; get byte from buffer
.fc81	85 bd		sta $bd		   STA ROPRTY        ; save as tape write byte
.fc83	45 d7		eor $d7		   EOR LASTKY        ; XOR with checksum byte
.fc85	85 d7		sta $d7		   STA LASTKY        ; save new checksum byte
.fc87	20 1b fd	jsr $fd1b	   JSR Inc_SAL_Word
.fc8a	d0 bb		bne $fc47	   BNE TAWI_15       ; restore registers and exit interrupt, branch always
.fc8c					TAWI_45
.fc8c	a5 9b		lda $9b		   LDA PRTY          ; get parity bit
.fc8e	49 01		eor #$01	   EOR #$01          ; toggle it
.fc90	85 bd		sta $bd		   STA ROPRTY        ; save as tape write byte
.fc92					TAWI_50
.fc92	4c 56 ff	jmp $ff56	   JMP Exit_IRQ      ; restore registers and exit interrupt
.fc95					TAWI_55
.fc95	c6 be		dec $be		   DEC FSBLK         ; decrement copies remaining to read/write
.fc97	d0 03		bne $fc9c	   BNE TAWI_60       ; branch if more to do
.fc99	20 08 fd	jsr $fd08	   JSR TAPE_Stop_Motor
.fc9c					TAWI_60
.fc9c	a9 50		lda #$50	   LDA #$50          ; set tape write leader count
.fc9e	85 a7		sta $a7		   STA INBIT         ; save tape write leader count
.fca0	a2 08		ldx #$08	   LDX #$08          ; set index for write tape leader vector
.fca2	78		sei		   SEI               ; disable interrupts
.fca3	20 fb fc	jsr $fcfb	   JSR TAPE_Set_IRQ_Vector
.fca6	d0 ea		bne $fc92	   BNE TAWI_50       ; restore registers and exit interrupt, branch always
.fca8					TAPE_Write_Leader
.fca8	a9 78		lda #$78	   LDA #$78          ; set time constant low byte for bit = leader
.fcaa	20 f3 fb	jsr $fbf3	   JSR TAPE_Write_Timer
.fcad	d0 e3		bne $fc92	   BNE TAWI_50       ; if tape bit high restore registers and exit interrupt
.fcaf	c6 a7		dec $a7		   DEC INBIT         ; decrement cycle count
.fcb1	d0 df		bne $fc92	   BNE TAWI_50       ; if not all done restore registers and exit interrupt
.fcb3	20 db fb	jsr $fbdb	   JSR TAPE_New_Byte_Setup
.fcb6	c6 ab		dec $ab		   DEC RIPRTY        ; decrement cassette leader count
.fcb8	10 d8		bpl $fc92	   BPL TAWI_50       ; if not all done restore registers and exit interrupt
.fcba	a2 0a		ldx #$0a	   LDX #$0A          ; set index for tape write vector
.fcbc	20 fb fc	jsr $fcfb	   JSR TAPE_Set_IRQ_Vector
.fcbf	58		cli		   CLI               ; enable interrupts
.fcc0	e6 ab		inc $ab		   INC RIPRTY        ; clear cassette leader counter, was $FF
.fcc2	a5 be		lda $be		   LDA FSBLK         ; get cassette block count
.fcc4	f0 30		beq $fcf6	   BEQ Reset_TAPE_IRQ      ; if all done restore everything for STOP and exit interrupt
.fcc6	20 d2 fb	jsr $fbd2	   JSR Set_IO_Start
.fcc9	a2 09		ldx #$09	   LDX #$09          ; set nine synchronisation bytes
.fccb	86 a5		stx $a5		   STX CNTDN         ; save cassette synchronization byte count
.fccd	d0 85		bne $fc54	   BNE TAWI_25      ; go do next tape byte, branch always
.fccf					  Restoring_After_STOP
.fccf	08		php		   PHP               ; save status
.fcd0	78		sei		   SEI               ; disable interrupts
.fcd1	20 08 fd	jsr $fd08	   JSR TAPE_Stop_Motor
.fcd4	a9 7f		lda #$7f	   LDA #$7F          ; disable all interrupts
.fcd6	8d 2e 91	sta $912e	   STA $912E
.fcd9	a9 f7		lda #$f7	   LDA #$F7          ; set keyboard column 3 active
.fcdb	8d 20 91	sta $9120	   STA KEYB_COL      ; set VIA 2 DRB, keyboard column
.fcde	a9 40		lda #$40	   LDA #$40          ; set T1 free run, T2 clock 2,
.fce0	8d 2b 91	sta $912b	   STA VIA2_ACR      ; set VIA 2 ACR
.fce3	20 39 fe	jsr $fe39	   JSR Program_Timer_A
.fce6	ad a0 02	lda $02a0	   LDA IRQTMP+1      ; get saved IRQ vector high byte
.fce9	f0 09		beq $fcf4	   BEQ RAS_10        ; branch if null
.fceb	8d 15 03	sta $0315	   STA CINV+1        ; restore IRQ vector high byte
.fcee	ad 9f 02	lda $029f	   LDA IRQTMP        ; get saved IRQ vector low byte
.fcf1	8d 14 03	sta $0314	   STA CINV          ; restore IRQ vector low byte
.fcf4					RAS_10
.fcf4	28		plp		   PLP               ; restore status
.fcf5	60		rts		   RTS
.fcf6					  Reset_TAPE_IRQ
.fcf6	20 cf fc	jsr $fccf	   JSR Restoring_After_STOP
.fcf9	f0 97		beq $fc92	   BEQ TAWI_50      ; restore registers and exit interrupt, branch always
.fcfb					  TAPE_Set_IRQ_Vector
.fcfb	bd e9 fd	lda $fde9,x	   LDA TAPE_IRQ_Vectors-8,X  ; get tape IRQ vector low byte
.fcfe	8d 14 03	sta $0314	   STA CINV          ; set IRQ vector low byte
.fd01	bd ea fd	lda $fdea,x	   LDA TAPE_IRQ_Vectors-7,X  ; get tape IRQ vector high byte
.fd04	8d 15 03	sta $0315	   STA CINV+1        ; set IRQ vector high byte
.fd07	60		rts		   RTS
.fd08					  TAPE_Stop_Motor
.fd08	ad 1c 91	lda $911c	   LDA VIA1_PCR      ; get VIA 1 PCR
.fd0b	09 0e		ora #$0e	   ORA #$0E          ; set CA2 high, cassette motor off
.fd0d	8d 1c 91	sta $911c	   STA VIA1_PCR      ; set VIA 1 PCR
.fd10	60		rts		   RTS
.fd11					  Check_IO_End
.fd11	38		sec		   SEC
.fd12	a5 ac		lda $ac		   LDA SAL           ; get buffer address low byte
.fd14	e5 ae		sbc $ae		   SBC EAL           ; subtract buffer end low byte
.fd16	a5 ad		lda $ad		   LDA SAL+1         ; get buffer address high byte
.fd18	e5 af		sbc $af		   SBC EAL+1         ; subtract buffer end high byte
.fd1a	60		rts		   RTS
.fd1b					  Inc_SAL_Word
.fd1b	e6 ac		inc $ac		   INC SAL
.fd1d	d0 02		bne $fd21	   BNE ISW_Ret
.fd1f	e6 ad		inc $ad		   INC SAL+1
.fd21					ISW_Ret
.fd21	60		rts		   RTS
.fd22					  Entry_RESET
.fd22	a2 ff		ldx #$ff	   LDX #$FF          ; set X for stack
.fd24	78		sei		   SEI               ; disable interrupts
.fd25	9a		txs		   TXS               ; clear stack
.fd26	d8		cld		   CLD               ; clear decimal mode
.fd27	20 3f fd	jsr $fd3f	   JSR Scan_Autostart_Signature
.fd2a	d0 03		bne $fd2f	   BNE HARE_10       ; if not there continue Vic startup
.fd2c	6c 00 a0	jmp ($a000)	   JMP (OPTION_ROM)
.fd2f					HARE_10
.fd2f	20 8d fd	jsr $fd8d	   JSR Init_RAM
.fd32	20 52 fd	jsr $fd52	   JSR Kernal_RESTOR
.fd35	20 f9 fd	jsr $fdf9	   JSR Initialise_IO
.fd38	20 18 e5	jsr $e518	   JSR Initialise_Hardware
.fd3b	58		cli		   CLI               ; enable interrupts
.fd3c	6c 00 c0	jmp ($c000)	   JMP (BASIC_ROM)   ; start BASIC
.fd3f					  Scan_Autostart_Signature
.fd3f	a2 05		ldx #$05	   LDX #5            ; five characters to test
.fd41					SAAS_Loop
.fd41	bd 4c fd	lda $fd4c,x	   LDA ROM_SIG-1,X   ; get test character
.fd44	dd 03 a0	cmp $a003,x	   CMP OPTION_ROM+3,X; compare with byte in block A000
.fd47	d0 03		bne $fd4c	   BNE SAAS_Exit     ; exit if no match
.fd49	ca		dex		   DEX               ; decrement index
.fd4a	d0 f5		bne $fd41	   BNE SAAS_Loop
.fd4c					SAAS_Exit
.fd4c	60		rts		   RTS
>fd4d	41 30 c3 c2 cd			ROM_SIG .TEXT "A0",$C3,$C2,$CD ; A0CBM
.fd52					  Kernal_RESTOR
.fd52	a2 6d		ldx #$6d	   LDX #<Kernal_Vectors    ; pointer to vector table low byte
.fd54	a0 fd		ldy #$fd	   LDY #>Kernal_Vectors    ; pointer to vector table high byte
.fd56	18		clc		   CLC               ; flag set vectors
.fd57					  Kernal_VECTOR
.fd57	86 c3		stx $c3		   STX MEMUSS
.fd59	84 c4		sty $c4		   STY MEMUSS+1
.fd5b	a0 1f		ldy #$1f	   LDY #$1F          ; set byte count
.fd5d					KeVE_10
.fd5d	b9 14 03	lda $0314,y	   LDA CINV,Y        ; read vector byte from vectors
.fd60	b0 02		bcs $fd64	   BCS KeVE_20       ; if read vectors skip the read from XY
.fd62	b1 c3		lda ($c3),y	   LDA (MEMUSS),Y    ; read vector byte from (XY)
.fd64					KeVE_20
.fd64	91 c3		sta ($c3),y	   STA (MEMUSS),Y    ; save byte to (XY) [may be ROM address]
.fd66					KeVe_30
.fd66	99 14 03	sta $0314,y	   STA CINV,Y        ; save byte to vector
.fd69	88		dey		   DEY               ; decrement index
.fd6a	10 f1		bpl $fd5d	   BPL KeVE_10       ; loop if more to do
.fd6c	60		rts		   RTS
.fd6d					  Kernal_Vectors
>fd6d	bf ea				   .word   Default_IRQ   ; CINV   IRQ vector
>fd6f	d2 fe				   .word   Default_BRK   ; CBINV  BRK vector
>fd71	ad fe				   .word   Default_NMI   ; NMINV  NMI vector
>fd73	0a f4				   .word   Kernal_OPEN   ; IOPEN  Open a logical file
>fd75	4a f3				   .word   Kernal_CLOSE  ; ICLOSE close a logical file
>fd77	c7 f2				   .word   Kernal_ICHKIN ; ICHKIN open channel for input
>fd79	09 f3				   .word   Kernal_CHKOUT ; ICKOUT open channel for output
>fd7b	f3 f3				   .word   Kernal_CLRCHN ; ICLRCH clear I/O channels
>fd7d	0e f2				   .word   Kernal_CHRIN  ; IBASIN get a character from the input channel
>fd7f	7a f2				   .word   Kernal_CHROUT ; IBSOUT output a character
>fd81	70 f7				   .word   Kernal_STOP   ; ISTOP  check if stop key is pressed
>fd83	f5 f1				   .word   Kernal_GETIN  ; IGETIN get character from keyboard queue
>fd85	ef f3				   .word   Kernal_CLALL  ; ICLALL close all channels and files
>fd87	d2 fe				   .word   Default_BRK   ; USRCMD user function
>fd89	49 f5				   .word   Default_LOAD; ILOAD      load
>fd8b	85 f6				   .word   Default_SAVE; ISAVE      save
.fd8d					Init_RAM
.fd8d	a9 00		lda #$00	   LDA #0
.fd8f	aa		tax		   TAX               ; clear index
.fd90					InRA_10
.fd90	95 00		sta $00,x	   STA $0000,X       ; clear page 0
.fd92	9d 00 02	sta $0200,x	   STA $0200,X       ; clear page 2
.fd95	9d 00 03	sta $0300,x	   STA $0300,X       ; clear page 3
.fd98	e8		inx		   INX               ; increment index
.fd99	d0 f5		bne $fd90	   BNE InRA_10       ; loop if more to do
.fd9b	a2 3c		ldx #$3c	   LDX #<TBUFFR      ; set cassette buffer pointer low byte
.fd9d	a0 03		ldy #$03	   LDY #>TBUFFR      ; set cassette buffer pointer high byte
.fd9f	86 b2		stx $b2		   STX TAPE1         ; save tape buffer start pointer low byte
.fda1	84 b3		sty $b3		   STY TAPE1+1       ; save tape buffer start pointer high byte
.fda3	85 c1		sta $c1		   STA STAL          ; clear RAM test pointer low byte
.fda5	85 97		sta $97		   STA TEMPX         ; clear looking for end flag
.fda7	8d 81 02	sta $0281	   STA OSSTAR        ; clear OS start of memory low byte
.fdaa	a8		tay		   TAY               ; clear Y
.fdab	a9 04		lda #$04	   LDA #$04          ; set RAM test pointer high byte
.fdad	85 c2		sta $c2		   STA STAL+1        ; save RAM test pointer high byte
.fdaf					InRA_50
.fdaf	e6 c1		inc $c1		   INC STAL          ; increment RAM test pointer low byte
.fdb1	d0 02		bne $fdb5	   BNE InRA_55       ; if no rollover skip the high byte increment
.fdb3	e6 c2		inc $c2		   INC STAL+1        ; increment RAM test pointer high byte
.fdb5					InRA_55
.fdb5	20 91 fe	jsr $fe91	   JSR Test_RAM_byte ; test RAM byte, return Cb=0 if failed
.fdb8	a5 97		lda $97		   LDA TEMPX         ; test looking for end flag
.fdba	f0 22		beq $fdde	   BEQ InRA_70       ; branch if not looking for end
.fdbc	b0 f1		bcs $fdaf	   BCS InRA_50       ; loop if byte test passed
.fdbe	a4 c2		ldy $c2		   LDY STAL+1        ; get test address high byte
.fdc0	a6 c1		ldx $c1		   LDX STAL          ; get test address low byte
.fdc2	c0 20		cpy #$20	   CPY #$20          ; compare with $2000, RAM should always end at or after
.fdc4	90 25		bcc $fdeb	   BCC InRA_75       ; if end address < $2000 go do dead end loop
.fdc6	c0 21		cpy #$21	   CPY #$21          ; compare with $2100
.fdc8	b0 08		bcs $fdd2	   BCS InRA_65       ; branch if >= $2100
.fdca	a0 1e		ldy #$1e	   LDY #$1E          ; set screen memory page to $1E00
.fdcc	8c 88 02	sty $0288	   STY SCNMPG        ; save screen memory page
.fdcf					InRA_60
.fdcf	4c 7b fe	jmp $fe7b	   JMP Set_memtop      ; set the top of memory and return
.fdd2					InRA_65
.fdd2	a9 12		lda #$12	   LDA #$12          ; set OS start of memory high byte
.fdd4	8d 82 02	sta $0282	   STA OSSTAR+1      ; save OS start of memory high byte
.fdd7	a9 10		lda #$10	   LDA #$10          ; set screen memory page to $1000
.fdd9	8d 88 02	sta $0288	   STA SCNMPG        ; save screen memory page
.fddc	d0 f1		bne $fdcf	   BNE InRA_60       ; set the top of memory and return, branch always
.fdde					InRA_70
.fdde	90 cf		bcc $fdaf	   BCC InRA_50       ; loop if byte test failed, not found start yet
.fde0	a5 c2		lda $c2		   LDA STAL+1        ; get test address high byte
.fde2	8d 82 02	sta $0282	   STA OSSTAR+1      ; save OS start of memory high byte
.fde5	85 97		sta $97		   STA TEMPX         ; set looking for end flag
.fde7	c9 11		cmp #$11	   CMP #$11          ; compare start with $1100, RAM should always start before
.fde9	90 c4		bcc $fdaf	   BCC InRA_50       ; go find end of RAM, branch always
.fdeb					InRA_75
.fdeb	20 c3 e5	jsr $e5c3	   JSR Init_VIC_Chip
.fdee	4c eb fd	jmp $fdeb	   JMP InRA_75       ; loop forever
.fdf1					TAPE_IRQ_Vectors
>fdf1	a8 fc				   .word   TAPE_Write_Leader ; $08   write tape leader IRQ routine
>fdf3	0b fc				   .word   TAPE_Write_IRQ    ; $0A   tape write IRQ routine
>fdf5	bf ea				   .word   Default_IRQ       ; $0C   normal IRQ vector
>fdf7	8e f9				   .word   TAPE_Read_IRQ     ; $0E   read tape bits IRQ routine
.fdf9					  Initialise_IO
.fdf9	a9 7f		lda #$7f	   LDA #$7F          ; disable all interrupts
.fdfb	8d 1e 91	sta $911e	   STA RS2_IRQ_REG   ; on VIA 1 IER ..
.fdfe	8d 2e 91	sta $912e	   STA VIA2_IER      ; .. and VIA 2 IER
.fe01	a9 40		lda #$40	   LDA #$40          ; set T1 free run, T2 clock 2,
.fe03	8d 2b 91	sta $912b	   STA VIA2_ACR      ; set VIA 2 ACR
.fe06	a9 40		lda #$40	   LDA #$40          ; set T1 free run, T2 clock 2,
.fe08	8d 1b 91	sta $911b	   STA VIA1_ACR      ; set VIA 1 ACR
.fe0b	a9 fe		lda #$fe	   LDA #$FE          ; CB2 high, RS232 Tx
.fe0d	8d 1c 91	sta $911c	   STA VIA1_PCR      ; set VIA 1 PCR
.fe10	a9 de		lda #$de	   LDA #$DE          ; CB2 low, serial data out high
.fe12	8d 2c 91	sta $912c	   STA IEC_PCR       ; set VIA 2 PCR
.fe15	a2 00		ldx #$00	   LDX #$00          ; all inputs, RS232 interface or parallel user port
.fe17	8e 12 91	stx $9112	   STX VIA1_DDRB     ; set VIA 1 DDRB
.fe1a	a2 ff		ldx #$ff	   LDX #$FF          ; all outputs, keyboard column
.fe1c	8e 22 91	stx $9122	   STX VIA2_DDRB     ; set VIA 2 DDRB
.fe1f	a2 00		ldx #$00	   LDX #$00          ; all inputs, keyboard row
.fe21	8e 23 91	stx $9123	   STX VIA2_DDRA     ; set VIA 2 DDRA
.fe24	a2 80		ldx #$80	   LDX #$80          ; OIII IIII, ATN out, light pen, joystick, serial data
.fe26	8e 13 91	stx $9113	   STX VIA1_DDRA     ; set VIA 1 DDRA
.fe29	a2 00		ldx #$00	   LDX #$00          ; ATN out low, set ATN high
.fe2b	8e 1f 91	stx $911f	   STX IEC_DRAN      ; set VIA 1 DRA, no handshake
.fe2e	20 84 ef	jsr $ef84	   JSR CLR_IEC_CLK   ; set serial clock high
.fe31	a9 82		lda #$82	   LDA #$82          ; enable CA1 interrupt, [RESTORE] key
.fe33	8d 1e 91	sta $911e	   STA RS2_IRQ_REG   ; set VIA 1 IER
.fe36	20 8d ef	jsr $ef8d	   JSR SET_IEC_CLK   ; set serial clock low
.fe39					  Program_Timer_A
.fe39	a9 c0		lda #$c0	   LDA #$C0          ; enable T1 interrupt
.fe3b	8d 2e 91	sta $912e	   STA VIA2_IER      ; set VIA 2 IER
.fe3e	a9 26		lda #$26	   LDA #$26 ;#$89          ; set timer constant low byte [NTSC]
.fe40	8d 24 91	sta $9124	   STA VIA2_T1CL     ; set VIA 2 T1C_l
.fe43	a9 48		lda #$48	   LDA #$48 ;#$42          ; set timer constant high byte [NTSC]
.fe45	8d 25 91	sta $9125	   STA VIA2_T1CH     ; set VIA 2 T1C_h
.fe48	60		rts		   RTS
.fe49					  Kernal_SETNAM
.fe49	85 b7		sta $b7		   STA FNLEN         ; set file name length
.fe4b	86 bb		stx $bb		   STX FNADR         ; set file name pointer low byte
.fe4d	84 bc		sty $bc		   STY FNADR+1       ; set file name pointer high byte
.fe4f	60		rts		   RTS
.fe50					  Kernal_SETLFS
.fe50	85 b8		sta $b8		   STA LA            ; set logical file
.fe52	86 ba		stx $ba		   STX FA            ; set device number
.fe54	84 b9		sty $b9		   STY SA            ; set secondary address or command
.fe56	60		rts		   RTS
.fe57					  Kernal_READST
.fe57	a5 ba		lda $ba		   LDA FA            ; get device number
.fe59	c9 02		cmp #$02	   CMP #$02          ; compare device with RS232 device
.fe5b	d0 0b		bne $fe68	   BNE Get_Status    ; branch if not RS232 device
.fe5d	ad 97 02	lda $0297	   LDA RSSTAT        ; read RS232 status word
.fe60	a9 00		lda #$00	   LDA #0
.fe62	8d 97 02	sta $0297	   STA RSSTAT        ; clear RS232 status
.fe65	60		rts		   RTS
.fe66					  Kernal_SETMSG
.fe66	85 9d		sta $9d		   STA MSGFLG        ; set message mode flag
.fe68					Get_Status
.fe68	a5 90		lda $90		   LDA STATUS        ; read serial status byte
.fe6a					  Ora_Status
.fe6a	05 90		ora $90		   ORA STATUS        ; OR with serial status byte
.fe6c	85 90		sta $90		   STA STATUS        ; save serial status byte
.fe6e	60		rts		   RTS
.fe6f					  Kernal_SETTMO
.fe6f	8d 85 02	sta $0285	   STA STIMOT        ; save serial bus timeout flag
.fe72	60		rts		   RTS
.fe73					  Kernal_MEMTOP
.fe73	90 06		bcc $fe7b	   BCC Set_memtop      ; if Cb clear go set the top of memory
.fe75					  Read_Memtop
.fe75	ae 83 02	ldx $0283	   LDX OSTOP         ; get memory top low byte
.fe78	ac 84 02	ldy $0284	   LDY OSTOP+1       ; get memory top high byte
.fe7b					  Set_memtop
.fe7b	8e 83 02	stx $0283	   STX OSTOP         ; set memory top low byte
.fe7e	8c 84 02	sty $0284	   STY OSTOP+1       ; set memory top high byte
.fe81	60		rts		   RTS
.fe82					  Kernal_MEMBOT
.fe82	90 06		bcc $fe8a	   BCC MEM_10        ; if Cb clear go set the bottom of memory
.fe84	ae 81 02	ldx $0281	   LDX OSSTAR        ; read OS start of memory low byte
.fe87	ac 82 02	ldy $0282	   LDY OSSTAR+1      ; read OS start of memory high byte
.fe8a					MEM_10
.fe8a	8e 81 02	stx $0281	   STX OSSTAR
.fe8d	8c 82 02	sty $0282	   STY OSSTAR+1
.fe90	60		rts		   RTS
.fe91					  Test_RAM_byte
.fe91	b1 c1		lda ($c1),y	   LDA (STAL),Y      ; get existing RAM byte
.fe93	aa		tax		   TAX               ; copy to X
.fe94	a9 55		lda #$55	   LDA #$55          ; set first test byte
.fe96	91 c1		sta ($c1),y	   STA (STAL),Y      ; save to RAM
.fe98	d1 c1		cmp ($c1),y	   CMP (STAL),Y      ; compare with saved
.fe9a	d0 08		bne $fea4	   BNE Exit_No_RAM
.fe9c	6a		ror a		   ROR A             ; make byte $AA, carry is set here
.fe9d	91 c1		sta ($c1),y	   STA (STAL),Y      ; save to RAM
.fe9f	d1 c1		cmp ($c1),y	   CMP (STAL),Y      ; compare with saved
.fea1	d0 01		bne $fea4	   BNE Exit_No_RAM
>fea3	a9				   .byte   $A9       ; makes next line LDA #$18
.fea4					Exit_No_RAM
.fea4	18		clc		   CLC               ; flag test failed
.fea5	8a		txa		   TXA               ; get original byte back
.fea6	91 c1		sta ($c1),y	   STA (STAL),Y      ; restore original byte
.fea8	60		rts		   RTS
.fea9					  Entry_NMI
.fea9	78		sei		   SEI               ; disable interrupts
.feaa	6c 18 03	jmp ($0318)	   JMP (NMINV)       ; next statement by default
.fead					  Default_NMI
.fead	48		pha		   PHA               ; save A
.feae	8a		txa		   TXA               ; copy X
.feaf	48		pha		   PHA               ; save X
.feb0	98		tya		   TYA               ; copy Y
.feb1	48		pha		   PHA               ; save Y
.feb2	ad 1d 91	lda $911d	   LDA VIA1_IFR      ; get interrupt flag register
.feb5	10 48		bpl $feff	   BPL JMP_Exit_IRQ  ; if no interrupt restore registers and exit
.feb7	2d 1e 91	and $911e	   AND RS2_IRQ_REG   ; AND with interrupt enable register
.feba	aa		tax		   TAX               ; copy to X
.febb	29 02		and #$02	   AND #2            ; mask [RESTORE] key
.febd	f0 1f		beq $fede	   BEQ RS232_NMI     ; if not [RESTORE] key continue with RS232
.febf	20 3f fd	jsr $fd3f	   JSR Scan_Autostart_Signature
.fec2	d0 03		bne $fec7	   BNE NMI_10        ; branch if no autostart ROM
.fec4	6c 02 a0	jmp ($a002)	   JMP (OPTION_ROM+2); else do autostart ROM break entry
.fec7					NMI_10
.fec7	2c 11 91	bit $9111	   BIT VIA1_DATA     ; test VIA 1 DRA
.feca	20 34 f7	jsr $f734	   JSR Kernal_UDTIM  ; Update the system clock
.fecd	20 e1 ff	jsr $ffe1	   JSR STOP          ; Check if stop key is pressed
.fed0	d0 2d		bne $feff	   BNE JMP_Exit_IRQ  ; if not [STOP] exit interrupt
.fed2					  Default_BRK
.fed2	20 52 fd	jsr $fd52	   JSR Kernal_RESTOR
.fed5	20 f9 fd	jsr $fdf9	   JSR Initialise_IO
.fed8	20 18 e5	jsr $e518	   JSR Initialise_Hardware
.fedb	6c 02 c0	jmp ($c002)	   JMP (BASIC_BRK)
.fede					  RS232_NMI
.fede	ad 1e 91	lda $911e	   LDA RS2_IRQ_REG   ; interrupt enable register
.fee1	09 80		ora #$80	   ORA #$80          ; set enable bit
.fee3	48		pha		   PHA               ; save to re-enable interrupts
.fee4	a9 7f		lda #$7f	   LDA #$7F          ; disable all interrupts
.fee6	8d 1e 91	sta $911e	   STA RS2_IRQ_REG   ; interrupt enable register
.fee9	8a		txa		   TXA               ; get active interrupts back
.feea	29 40		and #$40	   AND #$40          ; mask T1 interrupt
.feec	f0 14		beq $ff02	   BEQ NMI_20        ; branch if not T1 interrupt
.feee	a9 ce		lda #$ce	   LDA #$CE          ; CB2 low, CB1 negative edge, CA2 high, CA1 negative edge
.fef0	05 b5		ora $b5		   ORA NXTBIT        ; OR RS232 next bit to send, sets CB2 high if set
.fef2	8d 1c 91	sta $911c	   STA VIA1_PCR      ; set VIA 1 PCR
.fef5	ad 14 91	lda $9114	   LDA RS2_TIM_LOW   ; get VIA 1 T1C_l
.fef8	68		pla		   PLA               ; restore interrupt enable mask
.fef9	8d 1e 91	sta $911e	   STA RS2_IRQ_REG   ; interrupt enable register
.fefc					Mfe9d
.fefc	20 a3 ef	jsr $efa3	   JSR RS232_NMI_Transmit
.feff					JMP_Exit_IRQ
.feff	4c 56 ff	jmp $ff56	   JMP Exit_IRQ      ; restore registers and exit interrupt
.ff02					NMI_20
.ff02	8a		txa		   TXA               ; get active interrupts back
.ff03	29 20		and #$20	   AND #$20          ; mask T2 interrupt
.ff05	f0 25		beq $ff2c	   BEQ NMI_30        ; branch if not T2 interrupt
.ff07	ad 10 91	lda $9110	   LDA RS2_DSR_CTS   ; get VIA 1 DRB
.ff0a	29 01		and #$01	   AND #$01          ; mask RS232 data in
.ff0c	85 a7		sta $a7		   STA INBIT         ; save receiver input bit temp storage
.ff0e	ad 18 91	lda $9118	   LDA VIA1_T2CL     ; get VIA 1 T2C_l
.ff11	e9 16		sbc #$16	   SBC #$16          ;.
.ff13	6d 99 02	adc $0299	   ADC BAUDOF        ; add baud rate bit time low byte
.ff16	8d 18 91	sta $9118	   STA VIA1_T2CL     ; set VIA 1 T2C_l
.ff19	ad 19 91	lda $9119	   LDA VIA1_T2CH     ; get VIA 1 T2C_h
.ff1c	6d 9a 02	adc $029a	   ADC BAUDOF+1      ; add baud rate bit time high byte
.ff1f	8d 19 91	sta $9119	   STA VIA1_T2CH     ; set VIA 1 T2C_h
.ff22	68		pla		   PLA               ; restore interrupt enable mask
.ff23	8d 1e 91	sta $911e	   STA RS2_IRQ_REG   ; set VIA 1 IER, restore interrupts
.ff26	20 36 f0	jsr $f036	   JSR RS232_NMI_Receive
.ff29	4c 56 ff	jmp $ff56	   JMP Exit_IRQ      ; restore registers and exit interrupt
.ff2c					NMI_30
.ff2c	8a		txa		   TXA               ; get active interrupts back
.ff2d	29 10		and #$10	   AND #$10          ; mask CB1 interrupt, Rx data bit transition
.ff2f	f0 25		beq $ff56	   BEQ Bfeb6         ; if no bit restore registers and exit interrupt
.ff31	ad 93 02	lda $0293	   LDA M51CTR        ; get pseudo 6551 control register
.ff34	29 0f		and #$0f	   AND #$0F          ; clear non baud bits
.ff36	d0 00		bne $ff38	   BNE NMI_40        ; quirk
.ff38					NMI_40
.ff38	0a		asl a		   ASL A             ; 2 bytes per baud index
.ff39	aa		tax		   TAX               ; copy to index
.ff3a	bd 5a ff	lda $ff5a,x	   LDA Baudrate-2,X  ; get baud count low byte
.ff3d	8d 18 91	sta $9118	   STA VIA1_T2CL     ; set VIA 1 T2C_l
.ff40	bd 5b ff	lda $ff5b,x	   LDA Baudrate-1,X  ; get baud count high byte
.ff43	8d 19 91	sta $9119	   STA VIA1_T2CH     ; set VIA 1 T2C_h
.ff46	ad 10 91	lda $9110	   LDA RS2_DSR_CTS   ; read VIA 1 DRB, clear interrupt flag
.ff49	68		pla		   PLA               ; restore interrupt enable mask
.ff4a	09 20		ora #$20	   ORA #$20          ; enable T2 interrupt
.ff4c	29 ef		and #$ef	   AND #$EF          ; disable CB1 interrupt
.ff4e	8d 1e 91	sta $911e	   STA RS2_IRQ_REG   ; set VIA 1 IER
.ff51	ae 98 02	ldx $0298	   LDX BITNUM        ; get number of bits to be sent/received
.ff54	86 a8		stx $a8		   STX BITCI         ; save receiver bit count in
.ff56					Bfeb6
.ff56					  Exit_IRQ
.ff56	68		pla		   PLA               ; pull Y
.ff57	a8		tay		   TAY               ; restore Y
.ff58	68		pla		   PLA               ; pull X
.ff59	aa		tax		   TAX               ; restore X
.ff5a	68		pla		   PLA               ; restore A
.ff5b	40		rti		   RTI
.ff5c					  Baudrate
>ff5c	e6 2a				   .word	$2AE6 ;.word   $2792     ;   50   baud
>ff5e	78 1c				   .word	$1C78 ;.word   $1A40     ;   75   baud
>ff60	49 13				   .word	$1349 ;.word   $11C6     ;  110   baud
>ff62	b1 0f				   .word	$0FB1 ;.word   $0E74     ;  134.5 baud
>ff64	0a 0e				   .word	$0E0A ;.word   $0CEE     ;  150   baud
>ff66	d3 06				   .word	$06D3 ;.word   $0645     ;  300   baud
>ff68	38 03				   .word	$0338 ;.word   $02F1     ;  600   baud
>ff6a	6a 01				   .word	$016A ;.word   $0146     ; 1200   baud
>ff6c	d0 00				   .word	$00D0 ;.word   $00B8     ; 1800   baud
>ff6e	83 00				   .word	$0083 ;.word   $0071     ; 2400   baud
>ff70	36 00				   .word	$0036 ;.word   $002A     ; 3600   baud
.ff72					  Entry_IRQ
.ff72	48		pha		   PHA               ; save A
.ff73	8a		txa		   TXA               ; copy X
.ff74	48		pha		   PHA               ; save X
.ff75	98		tya		   TYA               ; copy Y
.ff76	48		pha		   PHA               ; save Y
.ff77	ba		tsx		   TSX               ; copy stack pointer
.ff78	bd 04 01	lda $0104,x	   LDA STACK+4,X     ; get the stacked status register
.ff7b	29 10		and #$10	   AND #$10          ; mask the BRK flag bit
.ff7d	f0 03		beq $ff82	   BEQ BFF82         ; if not BRK go do the hardware IRQ vector
.ff7f	6c 16 03	jmp ($0316)	   JMP (CBINV)       ; else do the BRK vector
.ff82					BFF82
.ff82	6c 14 03	jmp ($0314)	   JMP (CINV)        ; do IRQ vector
>ff85	ff ff ff ff ff			   .fill 5 ,$ff      ; unused
.ff8a					  RESTOR
.ff8a	4c 52 fd	jmp $fd52	   JMP Kernal_RESTOR
.ff8d					  VECTOR
.ff8d	4c 57 fd	jmp $fd57	   JMP Kernal_VECTOR
.ff90					  SETMSG
.ff90	4c 66 fe	jmp $fe66	   JMP Kernal_SETMSG
.ff93					  SECOND
.ff93	4c c0 ee	jmp $eec0	   JMP Kernal_SECOND
.ff96					  TKSA
.ff96	4c ce ee	jmp $eece	   JMP Kernal_TKSA
.ff99					  MEMTOP
.ff99	4c 73 fe	jmp $fe73	   JMP Kernal_MEMTOP
.ff9c					  MEMBOT
.ff9c	4c 82 fe	jmp $fe82	   JMP Kernal_MEMBOT
.ff9f					  SCNKEY
.ff9f	4c 1e eb	jmp $eb1e	   JMP Kernal_SCNKEY
.ffa2					  SETTMO
.ffa2	4c 6f fe	jmp $fe6f	   JMP Kernal_SETTMO
.ffa5					  ACPTR
.ffa5	4c 19 ef	jmp $ef19	   JMP Kernal_ACPTR
.ffa8					  CIOUT
.ffa8	4c e4 ee	jmp $eee4	   JMP Kernal_CIOUT
.ffab					  UNTLK
.ffab	4c f6 ee	jmp $eef6	   JMP Kernal_UNTLK
.ffae					  UNLSN
.ffae	4c 04 ef	jmp $ef04	   JMP Kernal_UNLSN
.ffb1					  LISTEN
.ffb1	4c 17 ee	jmp $ee17	   JMP Kernal_LISTEN
.ffb4					  TALK
.ffb4	4c 14 ee	jmp $ee14	   JMP Kernal_TALK
.ffb7					  READST
.ffb7	4c 57 fe	jmp $fe57	   JMP Kernal_READST
.ffba					  SETLFS
.ffba	4c 50 fe	jmp $fe50	   JMP Kernal_SETLFS
.ffbd					  SETNAM
.ffbd	4c 49 fe	jmp $fe49	   JMP Kernal_SETNAM
.ffc0					  OPEN
.ffc0	6c 1a 03	jmp ($031a)	   JMP (IOPEN)
.ffc3					  CLOSE
.ffc3	6c 1c 03	jmp ($031c)	   JMP (ICLOSE)
.ffc6					  CHKIN
.ffc6	6c 1e 03	jmp ($031e)	   JMP (ICHKIN)
.ffc9					  CHKOUT
.ffc9	6c 20 03	jmp ($0320)	   JMP (ICKOUT)      ; do open for output vector
.ffcc					  CLRCHN
.ffcc	6c 22 03	jmp ($0322)	   JMP (ICLRCH)
.ffcf					  CHRIN
.ffcf	6c 24 03	jmp ($0324)	   JMP (IBASIN)
.ffd2					  CHROUT
.ffd2	6c 26 03	jmp ($0326)	   JMP (IBSOUT)
.ffd5					  LOAD
.ffd5	4c 42 f5	jmp $f542	   JMP Kernal_LOAD
.ffd8					  SAVE
.ffd8	4c 75 f6	jmp $f675	   JMP Kernal_SAVE
.ffdb					  SETTIM
.ffdb	4c 67 f7	jmp $f767	   JMP Kernal_SETTIM
.ffde					  RDTIM
.ffde	4c 60 f7	jmp $f760	   JMP Kernal_RDTIM
.ffe1					  STOP
.ffe1	6c 28 03	jmp ($0328)	   JMP (ISTOP)
.ffe4					  GETIN
.ffe4	6c 2a 03	jmp ($032a)	   JMP (IGETIN)
.ffe7					  CLALL
.ffe7	6c 2c 03	jmp ($032c)	   JMP (ICLALL)
.ffea					  UDTIM
.ffea	4c 34 f7	jmp $f734	   JMP Kernal_UDTIM
.ffed					  SCREEN
.ffed	4c 05 e5	jmp $e505	   JMP Kernal_SCREEN
.fff0					  PLOT
.fff0	4c 0a e5	jmp $e50a	   JMP Kernal_PLOT
.fff3					  IOBASE
.fff3	4c 00 e5	jmp $e500	   JMP Kernal_IOBASE
>fff6	ff ff ff ff			   .FILL   4 ,$ff    ; unused
>fffa	a9 fe				   .word   Entry_NMI ; Non Maskable Interrupt vector
>fffc	22 fd				   .word   Entry_RESET; Reset vector
>fffe	72 ff				   .word   Entry_IRQ ; Interrupt Request vector

;******  End of listing
