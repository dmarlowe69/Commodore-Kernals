              ; *******************************************
              ; The Commodore VIC-20 / C64 operating system
              ; *******************************************

0000          C64 = 0        ; set to 1 for assembling the C64 ROM images
0001          VIC = 1 - C64  ;     or 0 for assembling the VIC ROM images

0000          JIFFY = 0      ; set to 1 for JIFFY DOS
0000          PAL   = 0      ; set to 0 for NTSC

              ; Based on following sources 
              ; ------------------------------------------------------------
              ; Disassembly done with the "Black Smurf Disassembler"
              ; The complete Commodore inner space anthology - Karl Hildon
              ; Vic 20 Programmers reference - Commodore
              ; Many comments merged in from Lee Davison's disassembly
              ; Der MOS 6567/6569 Videocontroller (VIC-II) - Christian Bauer

              ; Recommended assembler
              ; --------------------------------------------------------------
              ; Use the opensource cross assembler BSA (Black Smurf Assembler)
              ; for creating ROM images and assembly listings.
              ; BSA runs on MAC OSX, Linux, Unix and Windows

            MACRO PUSHW(Word)
               LDA Word+1
               PHA
               LDA Word
               PHA
            ENDMAC

            MACRO PULLW(Word)
               PLA
               STA Word
               PLA
               STA Word+1
            ENDMAC

            MACRO LDAX(Word)
               LDA Word
               LDX Word+1
            ENDMAC

            MACRO STAX(Ptr)
               STA Ptr
               STX Ptr+1
            ENDMAC

            MACRO LAYI(Word)
               LDA #<Word
               LDY #>Word
            ENDMAC

            MACRO LDAY(Word)
               LDA Word
               LDY Word+1
            ENDMAC

            MACRO STAY(Ptr)
               STA Ptr
               STY Ptr+1
            ENDMAC

            MACRO LDXY(Word)
               LDX Word
               LDY Word+1
            ENDMAC

            MACRO STXY(Ptr)
               STX Ptr
               STY Ptr+1
            ENDMAC

            MACRO Print_Msg(Msg)
               LDA #<Msg
               LDY #>Msg
               JSR Print_String
            ENDMAC

0000 TRUE     #if VIC

9000          VIC_BASE = $9000
0010          VIC_REGS = $10

              ; **************************************
              ; VIC-20 Video Interface Chip (MOS 6560)
              ; **************************************

              ;  #| Adr. |Bit7|Bit6|Bit5|Bit4|Bit3|Bit2|Bit1|Bit0| Function
              ; --+------+----+----+----+----+----+----+----+----+--------------------
              ;  0| 9000 |INTL|             HSA                  | horiz. adjustment
              ; --+------+---------------------------------------+--------------------
              ;  1| 9001 |                  VSA                  | vertical adjustment  
              ; --+------+---------------------------------------+--------------------
              ;  2| 9002 | SA9|             COLS                 | screen columns
              ; --+------+---------------------------------------+--------------------
              ;  3| 9003 | RA8|             ROWS                 | screen rows
              ; --+------+---------------------------------------+--------------------
              ;  4| 9004 |                  RAST                 | raster value
              ; --+------+---------------------------------------+--------------------
              ;  5| 9005 |  1 |    SMA       |      CMA          | screen/char memory
              ; --+------+---------------------------------------+--------------------
              ;  6| 9006 |                  LPH                  | light pen horiz.
              ; --+------+---------------------------------------+--------------------
              ;  7| 9007 |                  LPV                  | light pen vertical
              ; --+------+---------------------------------------+--------------------
              ;  8| 9008 |                  PAD1                 | paddle 1
              ; --+------+---------------------------------------+--------------------
              ;  9| 9009 |                  PAD2                 | paddle 2
              ; --+------+---------------------------------------+--------------------
              ; 10| 900a | BSW|             BASS                 | bass sound
              ; --+------+---------------------------------------+--------------------
              ; 11| 900b | ASW|             ALTO                 | alto sound
              ; --+------+---------------------------------------+--------------------
              ; 12| 900c | SSW|             SOPR                 | soprano sound
              ; --+------+---------------------------------------+--------------------
              ; 13| 900d | NSW|             NOIS                 | noise sound
              ; --+------+---------------------------------------+--------------------
              ; 14| 900e |      AUXC         |      VOL          | aux. color / volume
              ; --+------+---------------------------------------+--------------------
              ; 15| 900f |      SCOL         | REV|     BCOL     | screen/border color
              ; --+------+----+----+----+----+----+----+----+----+--------------------

9000          VIC_R0 = $9000       ; interlace / screen origin - horizontal
                                   ; bit 7   : 1 = interlace on
                                   ; bit 6-0 : horizontal screen adjustment (5)

9001          VIC_R1 = $9001       ; bit 7-0 : vertical screen adjustment (25)

9002          VIC_R2 = $9002       ; screen address and number of colums
                                   ; bit 7   : screen memory address 9
                                   ; bit 6-0 : number of columns (22)

9003          VIC_R3 = $9003       ; raster / # of rows / character size
                                   ; bit 7   : bit 8 of raster value
                                   ; bit 6-1 : number of rows (23)
                                   ; bit 0   : 1 = 8 x 16 character size

9004          VIC_R4 = $9004       ; raster value
                                   ; bit 7-0 : raster value (bit 8 in R3)

9005          VIC_R5 = $9005       ; screen memory / character memory
                                   ; bit 7   : must be 1
                                   ; bit 6-4 : screen memory address 12-10
                                   ; bit 3-0 : character memory
                                   ; --------------------------
                                   ; 0000 ROM  $8000 upper case normal
                                   ; 0001 ROM  $8400 upper case reversed
                                   ; 0010 ROM  $8800 lower case normal
                                   ; 0011 ROM  $8C00 lower case reversed
                                   ; 1100 RAM  $1000 user defined
                                   ; 1101 RAM  $1400 user defined
                                   ; 1110 RAM  $1800 user defined
                                   ; 1111 RAM  $1C00 user defined

9006          VIC_R6 = $9006       ; light pen horizontal

9007          VIC_R7 = $9007       ; light pen vertical

9008          VIC_R8 = $9008       ; paddle 1

9009          VIC_R9 = $9009       ; paddle 2

900a          VIC_RA = $900A       ; bit 7   : bass sound switch (1 = enable)
                                   ; bit 6-0 : bass frequency (clock / (127 - X))

900b          VIC_RB = $900B       ; bit 7   : alto sound switch (1 = enable)
                                   ; bit 6-0 : alto frequency

900c          VIC_RC = $900C       ; bit 7   : soprano sound switch (1 = enable)
                                   ; bit 6-0 : soprano frequency

900d          VIC_RD = $900D       ; bit 7   : noise sound switch (1 = enable)
                                   ; bit 6-0 : noise frequency

900e          VIC_RE = $900E       ; auxiliary color / loudness
                                   ; bit 7-4 : auxiliary color
                                   ; bit 3-0 : loudness (volume)

900f          VIC_RF = $900F       ; screen color / reverse mode / border color
                                   ; bit 7-4 : screen color
                                   ; bit 3   : reverse mode (1 = on)
                                   ; bit 2-0 : border color

              ; ***********************
              ; VIC-20 VIA 1 (MOS 6522)
              ; ***********************

9110          VIA1_DATB = $9110    ; VIA 1 data register B (I/O)
                                   ; ---------------------------  
                                   ; bit 7   DSR  in
                                   ; bit 6   CTS  in
                                   ; bit 5   
                                   ; bit 4   DCD  in
                                   ; bit 3   RI   in
                                   ; bit 2   DTR  out
                                   ; bit 1   RTS  out
                                   ; bit 0   data in

9111          VIA1_DATA = $9111    ; VIA 1 data register A (I/O)
                                   ; ---------------------------  
                                   ; bit 7   IEC ATN out
                                   ; bit 6   cassette switch
                                   ; bit 5   light pen
                                   ; bit 4   joy 2
                                   ; bit 3   joy 1
                                   ; bit 2   joy 0
                                   ; bit 1   IEC DATA in
                                   ; bit 0   IEC CLK  in

9112          VIA1_DDRB = $9112    ; VIA 1 data direction register B
9113          VIA1_DDRA = $9113    ; VIA 1 data direction register A
9114          VIA1_T1CL = $9114    ; VIA 1 timer 1 low  order counter/latch
9115          VIA1_T1CH = $9115    ; VIA 1 timer 1 high order counter/latch
9116          VIA1_T1LL = $9116    ; VIA 1 timer 1 low  order latch
9117          VIA1_T1LH = $9117    ; VIA 1 timer 1 high order latch
9118          VIA1_T2CL = $9118    ; VIA 1 timer 2 low  order counter/latch
9119          VIA1_T2CH = $9119    ; VIA 1 timer 2 high order counter/latch
911a          VIA1_SR   = $911A    ; VIA 1 shift register

911b          VIA1_ACR  = $911B    ; VIA 1 auxiliary control register
                                   ; --------------------------------
                                   ; bit 7   : T1 PB7 enabled/disabled
                                   ; bit 6   : T1 free run/one shot
                                   ; bit 5   : T2 clock PB6/Ø2
                                   ; bit 432 : function
                                   ; ------------------
                                   ; 000   shift register disabled
                                   ; 001   shift in , rate controlled by T2
                                   ; 010   shift in , rate controlled by Ø2
                                   ; 011   shift in , rate controlled by external clock
                                   ; 100   shift out, rate controlled by T2, free run
                                   ; 101   shift out, rate controlled by T2
                                   ; 110   shift out, rate controlled by Ø2
                                   ; 111   shift out, rate controlled by external clock
                                   ; bit 1   : PB latch (1 = enabled)
                                   ; bit 0   : PA latch (1 = enabled)

911c          VIA1_PCR   = $911C   ; VIA 1 peripheral control register (PCR)
                                   ; bit   function
                                   ; ---   --------
                                   ; 765   CB2 control
                                   ; ---   -----------
                                   ; 000   Interrupt Input Mode
                                   ; 001   Independent Interrupt Input Mode
                                   ; 010   Input Mode
                                   ; 011   Independent Input Mode
                                   ; 100   Handshake Output Mode
                                   ; 101   Pulse Output Mode
                                   ; 110   Manual Output Mode, CB2 low
                                   ; 111   Manual Output Mode, CB2 high
                                   ;  4   CB1 edge positive/negative
                                   ; 321   CA2 control
                                   ; ---   -----------
                                   ; 000   Interrupt Input Mode
                                   ; 001   Independent Interrupt Input Mode
                                   ; 010   Input Mode 
                                   ; 011   Independent Input Mode
                                   ; 100   Handshake Output Mode
                                   ; 101   Pulse Output Mode
                                   ; 110   Manual Output Mode, CA2 low
                                   ; 111   Manual Output Mode, CA2 high
                                   ;  0   CA1 edge positive/negative

              ; The status bit is a not normal flag. It goes high if both an interrupt
              ; flag in the IFR and the corresponding enable bit in the IER are set.
              ; It can be cleared only by clearing all the active flags in the IFR or
              ; disabling all active interrupts in the IER.

911d          VIA1_IFR   = $911D   ; VIA 1 interrupt flag register) (IFR)
                                   ; bit   function      cleared by
                                   ; ---   --------      ----------
                                   ;  7   interrupt status   clearing all enabled interrupts
                                   ;  6   T1 interrupt   read T1C_l, write T1C_h
                                   ;  5   T2 interrupt   read T2C_l, write T2C_h
                                   ;  4   CB1 transition   read or write port B
                                   ;  3   CB2 transition   read or write port B
                                   ;  2   8 shifts done   read or write the shift register
                                   ;  1   CA1 transition   read or write port A
                                   ;  0   CA2 transition   read or write port A

              ; If enable/disable bit is a zero during a write to this register, each
              ; 1 in bits 0-6 clears the corresponding bit in the IER. if this bit is
              ; a one during a write to this register, each 1 in bits 0-6 will set the
              ; corresponding IER bit

911e          VIA1_IER   = $911E   ; VIA 1 interrupt enable register (IER)
                                   ; bit   function
                                   ; ---   --------
                                   ;  7   enable/disable
                                   ;  6   T1 interrupt
                                   ;  5   T2 interrupt
                                   ;  4   CB1 transition
                                   ;  3   CB2 transition
                                   ;  2   8 shifts done
                                   ;  1   CA1 transition
                                   ;  0   CA2 transition

911f          VIA1_DATN    = $911F ; VIA 1 DRA, no handshake
                                   ; bit   function
                                   ; ---   --------
                                   ;  7   ATN out
                                   ;  6   cassette switch
                                   ;  5   joystick fire, light pen
                                   ;  4   joystick left
                                   ;  3   joystick down
                                   ;  2   joystick up
                                   ;  1   serial dat in
                                   ;  0   serial clk in

              ; **********************
              ; VIC-20 VIA2 (MOS 6522)
              ; **********************

9120          VIA2_DATB  = $9120   ; VIA 2 DRB, keyboard column drive
9121          VIA2_DATA  = $9121   ; VIA 2 DRA, keyboard row port
                                   ; Vic 20 keyboard matrix layout
                                   ;       c7   c6   c5   c4   c3   c2   c1   c0
                                   ;   +------------------------------------------------
                                   ; r7|   F7   F5   F3   F1   DN  RGT  RET  DEL
                                   ; r6|    /   UP    =  RSH HOME    ;    *    £
                                   ; r5|    ,    @    :    .    -    L    P    +
                                   ; r4|    0    O    K    M    N    J    I    9
                                   ; r3|    8    U    H    B    V    G    Y    7
                                   ; r2|    6    T    F    C    X    D    R    5
                                   ; r1|    4    E    S    Z  LSH    A    W    3
                                   ; r0|    2    Q  CBM   SP  RUN  CTL  LFT    1

9122          VIA2_DDRB  = $9122   ; VIA 2 data direction register B
9123          VIA2_DDRA  = $9123   ; VIA 2 data direction register A
9124          VIA2_T1CL  = $9124   ; VIA 2 T1 low  order counter/latch
9125          VIA2_T1CH  = $9125   ; VIA 2 T1 high order counter/latch
9126          VIA2_T1LL  = $9126   ; VIA 2 T1 low  order latch
9127          VIA2_T1LH  = $9127   ; VIA 2 T1 high order latch
9128          VIA2_T2CL  = $9128   ; VIA 2 T2 low  order counter/latch
9129          VIA2_T2CH  = $9129   ; VIA 2 T2 high order counter/latch
912a          VIA2_SR    = $912A   ; VIA 2 shift register              (SR)
912b          VIA2_ACR   = $912B   ; VIA 2 auxiliary control register  (ACR)
912c          VIA2_PCR   = $912C   ; VIA 2 peripheral control register (PCR)

              ; the status bit is a not normal flag. it goes high if both an interrupt
              ; flag in the IFR and the corresponding enable bit in the IER are set.
              ; it can be cleared only by clearing all the active flags in the IFR or
              ; disabling all active interrupts in the IER.

912d          VIA2_IFR   = $912D   ; VIA 1 Interrupt Flag Register (IFR)
                                   ; bit   function        cleared by
                                   ; ---  ---------        ----------
                                   ;  7   interrupt status clearing all enabled interrupts
                                   ;  6   T1 interrupt     read T1C_l, write T1C_h
                                   ;  5   T2 interrupt     read T2C_l, write T2C_h
                                   ;  4   CB1 transition   read or write port B
                                   ;  3   CB2 transition   read or write port B
                                   ;  2   8 shifts done    read or write the shift register
                                   ;  1   CA1 transition   read or write port A
                                   ;  0   CA2 transition   read or write port A

              ; If enable/disable bit is a zero during a write to this register, each
              ; 1 in bits 0-6 clears the corresponding bit in the IER. if this bit is
              ; a one during a write to this register, each 1 in bits 0-6 will set the
              ; corresponding IER bit

912e          VIA2_IER   = $912E   ; VIA 1 Interrupt Enable Register (IER)
                                   ; bit   function
                                   ; ---   --------
                                   ;  7   enable/disable
                                   ;  6   T1 interrupt
                                   ;  5   T2 interrupt
                                   ;  4   CB1 transition
                                   ;  3   CB2 transition
                                   ;  2   8 shifts done
                                   ;  1   CA1 transition
                                   ;  0   CA2 transition

912f          VIA2_DATN  = $912F   ; VIA 2 DRA, keyboard row, no handshake

              ; register names for keyboard driver

9120          KEYB_COL   = VIA2_DATB
9121          KEYB_ROW   = VIA2_DATA
912f          KEYB_ROWN  = VIA2_DATN

              ; key coordinates

00fb          CTRL_COL = %11111011 ; $fb = col 2
00fe          CTRL_ROW = %11111110 ; $fe = row 0

00f7          STND_COL = %11110111 ; $7f = col 3

              ; constants for screen editor

0016          COLS          =  22 ; screen columns 
0017          ROWS          =  23 ; screen rows
0004          COLINK        =   4 ; possible physical lines per logical line
0058          COLMAX        =  88 ; maximum line length of a logical line
0094          COLRAM_PAGE   = $94 ; default page of color RAM
0006          Default_Color =   6 ; blue

912c          IEC_PCR       = $912C; VIA 2 peripheral control register (PCR)
911f          IEC_DRAN      = $911F
9129          IEC_TIM_H     = $9129; VIA 2 T2H, timer high
912d          IEC_IFR       = $912D; VIA 2 IFR, interrupt flag register
0080          IEC_ATN_BIT   = $80
0020          IEC_IFR_BIT   = $20
0002          IEC_CLK_BIT   = %00000010; $02
0020          IEC_DAT_BIT   = %00100000; $20
0020          RS232_C_BIT   = %00100000; $20
911e          RS2_IRQ_REG   = $911E
9110          RS2_DSR_CTS   = $9110
9114          RS2_TIM_LOW   = $9114
9115          RS2_TIM_HIG   = $9115
9005          MEM_CONTROL   = $9005

a000          OPTION_ROM    = $A000
c000          BASIC_ROM     = $C000
              #endif

0001 FALSE    #if C64
SKIP          
SKIP          VIC_BASE      = $D000
SKIP          VIC_CONTROL_1 = $D011
SKIP          VIC_RASTER    = $D012
SKIP          VIC_SPR_ENA   = $D015
SKIP          VIC_CONTROL_2 = $D016
SKIP          
SKIP          VIC_REGS = $2F
SKIP          
SKIP          ; ******************************************
SKIP          ; C-64 VIC-II (MOS (6566/7) Video Controller
SKIP          ; ******************************************
SKIP          
SKIP          ;  #| Adr.  |Bit7|Bit6|Bit5|Bit4|Bit3|Bit2|Bit1|Bit0| Function
SKIP          ; --+-------+----+----+----+----+----+----+----+----+------------------------
SKIP          ;  0| $d000 |                  M0X                  | X coordinate sprite 0
SKIP          ; --+-------+---------------------------------------+------------------------
SKIP          ;  1| $d001 |                  M0Y                  | Y coordinate sprite 0
SKIP          ; --+-------+---------------------------------------+------------------------
SKIP          ;  2| $d002 |                  M1X                  | X coordinate sprite 1
SKIP          ; --+-------+---------------------------------------+------------------------
SKIP          ;  3| $d003 |                  M1Y                  | Y coordinate sprite 1
SKIP          ; --+-------+---------------------------------------+------------------------
SKIP          ;  4| $d004 |                  M2X                  | X coordinate sprite 2
SKIP          ; --+-------+---------------------------------------+------------------------
SKIP          ;  5| $d005 |                  M2Y                  | Y coordinate sprite 2
SKIP          ; --+-------+---------------------------------------+------------------------
SKIP          ;  6| $d006 |                  M3X                  | X coordinate sprite 3
SKIP          ; --+-------+---------------------------------------+------------------------
SKIP          ;  7| $d007 |                  M3Y                  | Y coordinate sprite 3
SKIP          ; --+-------+---------------------------------------+------------------------
SKIP          ;  8| $d008 |                  M4X                  | X coordinate sprite 4
SKIP          ; --+-------+---------------------------------------+------------------------
SKIP          ;  9| $d009 |                  M4Y                  | Y coordinate sprite 4
SKIP          ; --+-------+---------------------------------------+------------------------
SKIP          ; 10| $d00a |                  M5X                  | X coordinate sprite 5
SKIP          ; --+-------+---------------------------------------+------------------------
SKIP          ; 11| $d00b |                  M5Y                  | Y coordinate sprite 5
SKIP          ; --+-------+---------------------------------------+------------------------
SKIP          ; 12| $d00c |                  M6X                  | X coordinate sprite 6
SKIP          ; --+-------+---------------------------------------+------------------------
SKIP          ; 13| $d00d |                  M6Y                  | Y coordinate sprite 6
SKIP          ; --+-------+---------------------------------------+------------------------
SKIP          ; 14| $d00e |                  M7X                  | X coordinate sprite 7
SKIP          ; --+-------+---------------------------------------+------------------------
SKIP          ; 15| $d00f |                  M7Y                  | Y coordinate sprite 7
SKIP          ; --+-------+----+----+----+----+----+----+----+----+------------------------
SKIP          ; 16| $d010 |M7X8|M6X8|M5X8|M4X8|M3X8|M2X8|M1X8|M0X8| MSBs of X coordinates
SKIP          ; --+-------+----+----+----+----+----+----+----+----+------------------------
SKIP          ; 17| $d011 |RST8| ECM| BMM| DEN|RSEL|    YSCROLL   | Control register 1
SKIP          ; --+-------+----+----+----+----+----+--------------+------------------------
SKIP          ; 18| $d012 |                 RASTER                | VIC_RASTER counter
SKIP          ; --+-------+---------------------------------------+------------------------
SKIP          ; 19| $d013 |                  LPX                  | Light pen X
SKIP          ; --+-------+---------------------------------------+------------------------
SKIP          ; 20| $d014 |                  LPY                  | Light pen Y
SKIP          ; --+-------+----+----+----+----+----+----+----+----+------------------------
SKIP          ; 21| $d015 | M7E| M6E| M5E| M4E| M3E| M2E| M1E| M0E| Sprite enabled
SKIP          ; --+-------+----+----+----+----+----+----+----+----+------------------------
SKIP          ; 22| $d016 |  - |  - | RES| MCM|CSEL|    XSCROLL   | Control register 2
SKIP          ; --+-------+----+----+----+----+----+----+----+----+------------------------
SKIP          ; 23| $d017 |M7YE|M6YE|M5YE|M4YE|M3YE|M2YE|M1YE|M0YE| Sprite Y expansion
SKIP          ; --+-------+----+----+----+----+----+----+----+----+------------------------
SKIP          ; 24| $d018 |VM13|VM12|VM11|VM10|CB13|CB12|CB11|  - | Memory pointers
SKIP          ; --+-------+----+----+----+----+----+----+----+----+------------------------
SKIP          ; 25| $d019 | IRQ|  - |  - |  - | ILP|IMMC|IMBC|IRST| Interrupt register
SKIP          ; --+-------+----+----+----+----+----+----+----+----+------------------------
SKIP          ; 26| $d01a |  - |  - |  - |  - | ELP|EMMC|EMBC|ERST| Interrupt enabled
SKIP          ; --+-------+----+----+----+----+----+----+----+----+------------------------
SKIP          ; 27| $d01b |M7DP|M6DP|M5DP|M4DP|M3DP|M2DP|M1DP|M0DP| Sprite data priority
SKIP          ; --+-------+----+----+----+----+----+----+----+----+------------------------
SKIP          ; 28| $d01c |M7MC|M6MC|M5MC|M4MC|M3MC|M2MC|M1MC|M0MC| Sprite multicolor
SKIP          ; --+-------+----+----+----+----+----+----+----+----+------------------------
SKIP          ; 29| $d01d |M7XE|M6XE|M5XE|M4XE|M3XE|M2XE|M1XE|M0XE| Sprite X expansion
SKIP          ; --+-------+----+----+----+----+----+----+----+----+------------------------
SKIP          ; 30| $d01e | M7M| M6M| M5M| M4M| M3M| M2M| M1M| M0M| Sprite-sprite collision
SKIP          ; --+-------+----+----+----+----+----+----+----+----+------------------------
SKIP          ; 31| $d01f | M7D| M6D| M5D| M4D| M3D| M2D| M1D| M0D| Sprite-data collision
SKIP          ; --+-------+----+----+----+----+----+----+----+----+------------------------
SKIP          ; 32| $d020 |  - |  - |  - |  - |         EC        | Border color
SKIP          ; --+-------+----+----+----+----+-------------------+------------------------
SKIP          ; 33| $d021 |  - |  - |  - |  - |        B0C        | Background color 0
SKIP          ; --+-------+----+----+----+----+-------------------+------------------------
SKIP          ; 34| $d022 |  - |  - |  - |  - |        B1C        | Background color 1
SKIP          ; --+-------+----+----+----+----+-------------------+------------------------
SKIP          ; 35| $d023 |  - |  - |  - |  - |        B2C        | Background color 2
SKIP          ; --+-------+----+----+----+----+-------------------+------------------------
SKIP          ; 36| $d024 |  - |  - |  - |  - |        B3C        | Background color 3
SKIP          ; --+-------+----+----+----+----+-------------------+------------------------
SKIP          ; 37| $d025 |  - |  - |  - |  - |        MM0        | Sprite multicolor 0
SKIP          ; --+-------+----+----+----+----+-------------------+------------------------
SKIP          ; 38| $d026 |  - |  - |  - |  - |        MM1        | Sprite multicolor 1
SKIP          ; --+-------+----+----+----+----+-------------------+------------------------
SKIP          ; 39| $d027 |  - |  - |  - |  - |        M0C        | Color sprite 0
SKIP          ; --+-------+----+----+----+----+-------------------+------------------------
SKIP          ; 40| $d028 |  - |  - |  - |  - |        M1C        | Color sprite 1
SKIP          ; --+-------+----+----+----+----+-------------------+------------------------
SKIP          ; 41| $d029 |  - |  - |  - |  - |        M2C        | Color sprite 2
SKIP          ; --+-------+----+----+----+----+-------------------+------------------------
SKIP          ; 42| $d02a |  - |  - |  - |  - |        M3C        | Color sprite 3
SKIP          ; --+-------+----+----+----+----+-------------------+------------------------
SKIP          ; 43| $d02b |  - |  - |  - |  - |        M4C        | Color sprite 4
SKIP          ; --+-------+----+----+----+----+-------------------+------------------------
SKIP          ; 44| $d02c |  - |  - |  - |  - |        M5C        | Color sprite 5
SKIP          ; --+-------+----+----+----+----+-------------------+------------------------
SKIP          ; 45| $d02d |  - |  - |  - |  - |        M6C        | Color sprite 6
SKIP          ; --+-------+----+----+----+----+-------------------+------------------------
SKIP          ; 46| $d02e |  - |  - |  - |  - |        M7C        | Color sprite 7
SKIP          ; --+-------+----+----+----+----+-------------------+------------------------
SKIP          
SKIP          ; **********************************************
SKIP          ; C-64 CIA1 (MOS 6526) Complex Interface Adapter
SKIP          ; **********************************************
SKIP          
SKIP          ;  #| Adr.  |Bit7|Bit6|Bit5|Bit4|Bit3|Bit2|Bit1|Bit0| Function
SKIP          ; --+-------+----+----+----+----+----+----+----+----+------------------------
SKIP          ;  0| $dc00 |                  PRA                  | Data port A
SKIP          ; --+-------+---------------------------------------+------------------------
SKIP          ;  1| $dc01 |                  PRB                  | Data port B
SKIP          ; --+-------+---------------------------------------+------------------------
SKIP          ;  2| $dc02 |                 DDRA                  | Data direction A
SKIP          ; --+-------+---------------------------------------+------------------------
SKIP          ;  3| $dc03 |                 DDRB                  | Data direction B
SKIP          ; --+-------+---------------------------------------+------------------------
SKIP          ;  4| $dc04 |                 TALO                  | Timer A low
SKIP          ; --+-------+---------------------------------------+------------------------
SKIP          ;  5| $dc05 |                 TAHI                  | Timer A high
SKIP          ; --+-------+---------------------------------------+------------------------
SKIP          ;  6| $dc06 |                 TBLO                  | Timer B low
SKIP          ; --+-------+---------------------------------------+------------------------
SKIP          ;  7| $dc07 |                 TBHI                  | Timer B high
SKIP          ; --+-------+----+----+----+----+----+----+----+----+------------------------
SKIP          ;  8| $dc08 | S/A|  0 |  0 |  0 |       TODS        | Time Of Day [1/10 sec]
SKIP          ; --+-------+----+----+----+----+----+----+----+----+------------------------
SKIP          ;  9| $dc09 |  0 |  TODS [10s]  |     TODS [1s]     | Time Of Day [sec]
SKIP          ; --+-------+----+--------------+-------------------+------------------------
SKIP          ; 10| $dc0a |  0 |  TODM [10m]  |     TODM [1m]     | Time Of Day [min]
SKIP          ; --+-------+----+--------------+-------------------+------------------------
SKIP          ; 11| $dc0b |AMPM|  TODH [10h]  |     TODH [1h]     | Time Of Day [hour]
SKIP          ; --+-------+----+--------------+-------------------+------------------------
SKIP          ; 12| $dc0c |                  SDR                  | Serial Data Register
SKIP          ; --+-------+----+----+----+----+----+----+----+----+------------------------
SKIP          ; 13| $dc0d |MODE|  0 |  0 |IFLG|ISDR|IARM|ITBU|ITBA| Interrupt Control Reg.
SKIP          ; --+-------+----+----+----+----+----+----+----+----+------------------------
SKIP          ; 14| $dc0e | Hz |DSDR|CNTP| ONE|CONT|TBUN|TBUN|STOP| Control Timer A
SKIP          ; --+-------+----+----+----+----+----+----+----+----+------------------------
SKIP          ; 15| $dc0f |MODE|   TACT  | ONE|CONT|TAUN|TAUN|STOP| Control Timer B
SKIP          ; --+-------+----+----+----+----+----+----+----+----+------------------------
SKIP          
SKIP          CIA1_PRA   = $DC00   ; CIA1 Peripheral data Register A
SKIP                               ; keyboard column
SKIP          
SKIP          CIA1_PRB   = $DC01   ; CIA1 Peripheral data Register B
SKIP                               ; keyboard row
SKIP                               ; C64  keyboard matrix layout
SKIP                               ;       c7   c6   c5   c4   c3   c2   c1   c0
SKIP                               ;   +------------------------------------------------
SKIP                               ; r7|  RUN    /    ,    N    V    X  LSH   DN
SKIP                               ; r6|    Q   UP    @    O    U    T    E   F5
SKIP                               ; r5|  CBM    =    :    K    H    F    S   F3
SKIP                               ; r4|   SP  RSH    .    M    B    C    Z   F1
SKIP                               ; r3|    2  HOM    -    0    8    6    4   F7
SKIP                               ; r2|  CTL    ;    L    J    G    D    A  RGT
SKIP                               ; r1|  LFT    *    P    I    Y    R    W  RET
SKIP                               ; r0|    1    £    +    9    7    5    3  DEL
SKIP          
SKIP          CIA1_DDRA  = $DC02   ; CIA1 Data Direction  Register A
SKIP          CIA1_DDRB  = $DC03   ; CIA1 Data Direction  Register B
SKIP          CIA1_TALO  = $DC04   ; CIA1 Timer A Low  register
SKIP          CIA1_TAHI  = $DC05   ; CIA1 Timer A High register
SKIP          CIA1_TBLO  = $DC06   ; CIA1 Timer B Low  register
SKIP          CIA1_TBHI  = $DC07   ; CIA1 Timer B High register
SKIP          CIA1_TODT  = $DC08   ; CIA1 Time Of Day 1/10 seconds
SKIP          CIA1_TODS  = $DC09   ; CIA1 Time Of Day seconds
SKIP          CIA1_TODM  = $DC0A   ; CIA1 Time Of Day minutes
SKIP          CIA1_TODH  = $DC0B   ; CIA1 Time Of Day hours
SKIP          CIA1_SDR   = $DC0C   ; CIA1 Serial Data Register
SKIP          CIA1_ICR   = $DC0D   ; CIA1 Interrupt Control Register
SKIP          CIA1_CRA   = $DC0E   ; CIA1 Control Register A
SKIP          CIA1_CRB   = $DC0F   ; CIA1 Control Register B
SKIP          
SKIP          ; **********************************************
SKIP          ; C-64 CIA2 (MOS 6526) Complex Interface Adapter
SKIP          ; **********************************************
SKIP          
SKIP          CIA2_PRA   = $DD00   ; CIA2 Peripheral data Register A
SKIP          CIA2_PRB   = $DD01   ; CIA2 Peripheral data Register B
SKIP          CIA2_DDRA  = $DD02   ; CIA2 Data Direction  Register A
SKIP          CIA2_DDRB  = $DD03   ; CIA2 Data Direction  Register B
SKIP          CIA2_TALO  = $DD04   ; CIA2 Timer A Low  register
SKIP          CIA2_TAHI  = $DD05   ; CIA2 Timer A High register
SKIP          CIA2_TBLO  = $DD06   ; CIA2 Timer B Low  register
SKIP          CIA2_TBHI  = $DD07   ; CIA2 Timer B High register
SKIP          CIA2_TODT  = $DD08   ; CIA2 Time Of Day 1/10 seconds
SKIP          CIA2_TODS  = $DD09   ; CIA2 Time Of Day seconds
SKIP          CIA2_TODM  = $DD0A   ; CIA2 Time Of Day minutes
SKIP          CIA2_TODH  = $DD0B   ; CIA2 Time Of Day hours
SKIP          CIA2_SDR   = $DD0C   ; CIA2 Serial Data Register
SKIP          CIA2_ICR   = $DD0D   ; CIA2 Interrupt Control Register
SKIP          CIA2_CRA   = $DD0E   ; CIA2 Control Register A
SKIP          CIA2_CRB   = $DD0F   ; CIA2 Control Register B
SKIP          
SKIP          ; register names for keyboard driver
SKIP          
SKIP          KEYB_COL   = CIA1_PRA
SKIP          KEYB_ROW   = CIA1_PRB
SKIP          KEYB_ROWN  = CIA1_PRB
SKIP          
SKIP          ; key coordinates
SKIP          
SKIP          CTRL_COL = %01111111 ; $7f = col 7
SKIP          CTRL_ROW = %11111011 ; $fb = row 2
SKIP          
SKIP          STND_COL = %01111111 ; $7f = col 7
SKIP          
SKIP          D6510       =     0
SKIP          R6510       =     1
SKIP          
SKIP          VIA2_IER = CIA1_ICR    ; CIA1 Interrupt Control Register
SKIP          VIA2_T2CH= $DC07
SKIP          VIA2_T2CL= $DC06
SKIP          VIA2_T1CL= $DC04
SKIP          VIA2_T1CH= $DC05
SKIP          
SKIP          COLS          =  40
SKIP          ROWS          =  25
SKIP          COLINK        =   2
SKIP          COLMAX        =  80
SKIP          COLRAM_PAGE   = $D8
SKIP          Default_Color = 14   ; Light blue
SKIP          
SKIP          MEM_CONTROL   = $D018
SKIP          IEC_TIM_H     = $DC07; CIA 1 TIH, timer high
SKIP          IEC_IFR       = CIA1_ICR    ; CIA 1 CRB, interrupt flag register
SKIP          IEC_PCR       = $DD00; VIA 2 peripheral control register (PCR)
SKIP          IEC_DRAN      = $DD00; CIA 2 DRA, IEC bus
SKIP          
SKIP          ; bit 7	IEC Bus Data  Input
SKIP          ;     6	IEC Bus Clock Input
SKIP          ;     5	IEC Bus Data  Output
SKIP          ;     4	IEC Bus Clock Output
SKIP          ;     3	IEC Bus ATN Signal Output
SKIP          ;     2 User port PA2
SKIP          ;   0-1 VIC memory address
SKIP          
SKIP          RS2_DSR_CTS   = $DD01
SKIP          RS2_IRQ_REG   = CIA2_ICR
SKIP          RS2_TIM_LOW   = $DD04
SKIP          RS2_TIM_HIG   = $DD05
SKIP          IEC_ATN_BIT   = $08
SKIP          IEC_IFR_BIT   = $02
SKIP          IEC_CLK_BIT   = %00010000; $10
SKIP          IEC_DAT_BIT   = %00100000; $20
SKIP          RS232_C_BIT   = %00000100; $04
SKIP          
SKIP          BASIC_SCREEN    = $0400
SKIP          BASIC_RAM_START = $0800
SKIP          OPTION_ROM      = $8000
SKIP          BASIC_ROM       = $A000
              #endif

              ; Some names for special characters

000d          CR    = $0D ; Carriage Return
000a          LF    = $0A ; Line Feed
0022          QUOTE = $22 ; Quote
003b          SEMIC = $3B ; Semicolon

              ; These locations contain the JMP instruction and traget address of the
              ; USR command. They are initialised so that if you try to execute a USR
              ; call without changing them you will receive an ILLEGAL QUANTITY error
              ; message.

0000 TRUE     #if VIC
0000          Basic_USR = $00      ; USR() JMP instruction ($4C)
0001          USRVEC    = $01      ; USR() vector (Illegal_Quantity)
              #endif

              ; This vector points to the address of the BASIC routine which converts
              ; a floating point number to an integer, however BASIC does not use this
              ; vector. It may be of assistance to the programmer who wishes to use
              ; data that is stored in floating point format. The parameter passed by
              ; the USR command is available only in that format for example.

0003          ADRAY1 = $03         ; float to fixed vector (Float_To_Integer)

              ; This vector points to the address of the BASIC routine which converts
              ; an integer to a floating point number, however BASIC does not use this
              ; vector. It may be used by the programmer who needs to make such a
              ; conversion for a machine language program that interacts with BASIC.
              ; To return an integer value with the USR command for example.

0005          ADRAY2 = $05         ; fixed to float vector (Integer_To_Float)

              ; The cursor column position prior to the TAB or SPC is moved here from
              ; $D3, and is used to calculate where the cursor ends up after one of
              ; these functions is invoked. Note that the value contained here shows
              ; the position of the cursor on a logical line. Since one logical line
              ; can be up to four VIC or two C64 physical lines long, the value stored
              ; here can range from 0 to 87 on VIC and 0 to 79 on C64.

0007          CHARAC = $07         ; search character
0008          ENDCHR = $08         ; scan quotes flag
0009          TRMPOS = $09         ; TAB column save

              ; The routine that converts the text in the input buffer into lines of
              ; executable program tokens, and the routines that link these program
              ; lines together, use this location as an index into the input buffer
              ; area. After the job of converting text to tokens is done, the value
              ; in this location is equal to the length of the tokenized line.

              ; The routines which build an array or locate an element in an array use
              ; this location to calculate the number of DIMensions called for and the
              ;  amount of storage required for a newly created array, or the number
              ; of subscripts when referencing an array element.

000a          VERCK  = $0A         ; load/verify flag, 0 = load, 1 = verify
000b          COUNT  = $0B         ; line crunch/array access/logic operators

              ; This is used as a flag by the routines that build an array or
              ; reference an existing array. It is used to determine whether a
              ; variable is in an array, whether the array has already been
              ; DIMensioned, and whether a new array should assume default size.

000c          DIMFLG = $0C         ; DIM flag

              ; This flag is used to indicate whether data being operated upon is
              ; string or numeric. A value of $FF in this location indicates string
              ; data while a $00 indicates numeric data.

000d          VALTYP = $0D         ; data type flag, $FF = string, $00 = numeric

              ; If the above flag indicates numeric then a $80 in this location
              ; identifies the number as an integer, and a $00 indicates a floating
              ; point number.

000e          INTFLG = $0E         ; data type flag, $80 = integer, $00 = floating pt.

              ; The garbage collection routine uses this location as a flag to
              ; indicate that garbage collection has already been tried before adding
              ; a new string. If there is still not enough memory, an OUT OF MEMORY
              ; error message will result.

              ; LIST uses this byte as a flag to let it know when it has come to a
              ; character string in quotes. It will then print the string,rather than
              ; search it for BASIC keyword tokens.

              ; This location is also used during the process of converting a line of
              ; text in the BASIC input buffer into a linked program line of BASIC
              ; keyword tokens to flag a DATA line is being processed.

000f          GARBFL = $0F         ; garbage collected/open quote/DATA flag

              ; If an opening parenthesis is found, this flag is set to indicate that
              ; the variable in question is either an array variable or a user-defined
              ; function.

0010          SUBFLG = $10         ; subscript/FNx flag

              ; This location is used to determine whether the sign of the value
              ; returned by the functions SIN, COS, ATN or TAN is positive or negative

              ; Also the comparison routines use this location to indicate the outcome
              ; of the compare. For A <=> B the value here will be $01 if A > B,
              ; $02 if A = B, and $04 if A < B. If more than one comparison operator
              ; was used to compare the two variables then the value here will be a
              ; combination of the above values.

0011          INPFLG = $11         ; input mode, $00 = INPUT, $40 = GET, $98 = READ
0012          TANSGN = $12         ; ATN sign/comparison evaluation flag

              ; When the default input or output device is used the value here will
              ; be a zero, and the format of prompting and output will be the standard
              ; screen output format. The location $B8 is used to decide what device
              ; actually to put input from or output to.

              ; The print CR/LF code at Print_CR suggests that b7 of this byte is
              ; an AutoLF flag bit but if it is used as such it would break lots of
              ; other parts of the code

0013          IOPMPT = $13         ; current I/O channel

              ; Used whenever a 16 bit integer is used e.g. the target line number for
              ; GOTO, LIST, ON, and GOSUB also the number of a BASIC line that is to
              ; be added or replaced. additionally PEEK, POKE, WAIT, and SYS use this
              ; location as a pointer to the address which is the subject of the
              ; command.

0014          LINNUM = $14         ; temporary integer

              ; This location points to the next available slot in the temporary
              ; string descriptor stack located at $19-$21.

0016          TEMPPT = $16         ; descriptor stack pointer, next free

              ; This contains information about temporary strings which hve not yet
              ; been assigned to a string variable.

0017          LASTPT = $17         ; current descriptor stack item pointer
0019          TEMPST = $19         ; to $21, descriptor stack

              ; These locations are used by BASIC multiplication and division
              ; routines. They are also used by the routines which compute the size of
              ; the area required to store an array which is being created.

0022          INDEXA = $22         ; misc temp word
0024          INDEXB = $24         ; misc temp word

0025          FAC3   = $25         ; auxiliary Floating Point Accumulator

0001 FALSE    #if JIFFY
SKIP          COMSAV = $27
              #endif

              ; Two byte pointer to where the BASIC program text is stored.

002b          TXTTAB = $2B         ; start of memory

              ; Two byte pointer to the start of the BASIC variable storage area.

002d          VARTAB = $2D         ; start of variables

              ; Two byte pointer to the start of the BASIC array storage area.

002f          ARYTAB = $2F         ; end of variables

              ; Two byte pointer to end of the start of free RAM.

0031          STREND = $31         ; end of arrays

              ; Two byte pointer to the bottom of the string text storage area.

0033          FRESPC = $33         ; bottom of string space

              ; Used as a temporary pointer to the most current string added by the
              ; routines which build strings or move them in memory.

0035          UTLSTP = $35         ; string utility ptr

              ; Two byte pointer to the highest address used by BASIC +1.

0037          MEMSIZ = $37         ; end of memory

              ; These locations contain the line number of the BASIC statement which
              ; is currently being executed. A value of $FF in location $3A means that
              ; BASIC is in immediate mode.

0039          CURLIN = $39         ; current line number

              ; When program execution ends or stops the last line number executed is
              ; stored here.

003b          OLDLIN = $3B         ; break line number

              ; These locations contain the address of the start of the text of the
              ; BASIC statement that is being executed.  The value of the pointer to
              ; the address of the BASIC text character currently being scanned is
              ; stored here each time a new BASIC statement begins execution.

003d          OLDTXT = $3D         ; continue pointer

              ; These locations hold the line number of the current DATA statement
              ; being READ. If an error concerning the DATA occurs this number will
              ; be moved to $39/$3A so that the error message will show the line that
              ; contains the DATA statement rather than in the line that contains the
              ; READ statement.

003f          DATLIN = $3F         ; current DATA line number

              ; These locations point to the address where the next DATA will be READ
              ; from. RESTORE sets this pointer back to the address indicated by the
              ; start of BASIC pointer.

0041          DATPTR = $41         ; DATA pointer

              ; READ, INPUT and GET all use this as a pointer to the address of the
              ; source of incoming data, such as DATA statements, or the text input
              ; buffer.

0043          INPPTR = $43         ; READ pointer

0045          VARNAM = $45         ; current variable name

              ; These locations point to the value of the current BASIC variable.
              ; Specifically they point to the byte just after the two-character
              ; variable name.

0047          VARPNT = $47         ; current variable address

              ; The address of the BASIC variable which is the subject of a FOR/NEXT
              ; loop is first stored here before being pushed onto the stack.

0049          FORPNT = $49         ; FOR/NEXT variable pointer

              ; The expression evaluation routine creates this to let it know whether
              ; the current comparison operation is a < $01, = $02 or > $04 comparison
              ; or combination.

004b          YSAVE  = $4B         ; BASIC execute pointer temporary/precedence flag

004d          ACCSYM = $4D         ; comparrison evaluation flag

              ; These locations are used as a pointer to the function that is created
              ; during function definition. During function execution it points to
              ; where the evaluation results should be saved.

004e          FUNCPT = $4E         ; FAC temp store/function/variable/garbage pointer

              ; Temporary Pointer to the current string descriptor.

0050          DESCPT = $50         ; FAC temp store/descriptor pointer

0053          GARBSS = $53         ; garbage collection step size

              ; The first byte is the 6502 JMP instruction $4C, followed by the
              ; address of the required function taken from the table at $C052.

0054          JUMPER = $54         ; JMP opcode for functions

0055          FUNJMP = $55         ; functions jump vector

              ; this address is sometimes used as high btye for the FUNJMP
              ; and as rounding byte (5th. byte of mantissa) for FAC1

0056          FAC2M5 = $56         ; FAC2 mantissa 5 = rounding byte

              ; Temporary storage for floating points values (5 bytes)
              ; and temporary pointer (block pointer, array pointer)

0057          FACTPA = $57         ; FAC temp store ($57 - $5B)
0058          TMPPTA = $58         ; temp pointer A
005a          TMPPTB = $5A         ; temp pointer B

              ; Temporary storage for floating points values (5 bytes)
              ; and temporary variables

005c          FACTPB = $5C         ; FAC temp store ($5C - $60)
005d          TMPVA1 = $5D         ; temp variable (counter)
005e          TMPVA2 = $5E         ; temp variable (counter)
005f          TMPPTC = $5F         ; temp pointer C

              ; Floating point accumulator 1

0061          FAC1EX = $61         ; FAC1 exponent
0062          FAC1M1 = $62         ; FAC1 mantissa 1
0063          FAC1M2 = $63         ; FAC1 mantissa 2
0064          FAC1M3 = $64         ; FAC1 mantissa 3
0065          FAC1M4 = $65         ; FAC1 mantissa 4
0066          FAC1SI = $66         ; FAC1 sign

0067          SGNFLG = $67         ; constant count/negative flag
0068          FAC1OV = $68         ; FAC1 overflow

              ; Floating point accumulator 2

0069          FAC2EX = $69         ; FAC2 exponent
006a          FAC2M1 = $6A         ; FAC2 mantissa 1
006b          FAC2M2 = $6B         ; FAC2 mantissa 2
006c          FAC2M3 = $6C         ; FAC2 mantissa 3
006d          FAC2M4 = $6D         ; FAC2 mantissa 4
006e          FAC2SI = $6E         ; FAC2 sign

              ; String pointer and FAC sign comparison and FAC rounding

006f          STRPTR = $6F         ; string pointer & FAC variables

              ; this address is sometimes used as high btye for the STRPTR
              ; and as rounding byte (5th. byte of mantissa) for FAC1

0070          FAC1M5 = $70         ; FAC1 mantissa 5 = rounding byte

0071          TMPPTD = $71         ; temp BASIC execute/array pointer low byte/index

              ; Basic CHRGET (with increment) and CHRGOT (no increment) routine

0073          CHRGET = $73         ; next program byte, BASIC byte get
0079          CHRGOT = $79         ; scan memory, BASIC byte get
007a          TXTPTR = $7A         ; BASIC execute pointer
0080          ISNUM  = $80         ; numeric test entry

008b          RNDX   = $8B         ; RND() seed, five bytes

0090          STATUS = $90         ; serial status byte
                                   ;   function
                                   ; bit   casette      serial bus
                                   ; ---   --------      ----------
                                   ;  7   end of tape      device not present
                                   ;  6   end of file      EOI
                                   ;  5   checksum error
                                   ;  4   read error
                                   ;  3   long block
                                   ;  2   short block
                                   ;  1            time out read
                                   ;  0            time out write

0091          STKEY  = $91         ; keyboard row, bx = 0 = key down
                                   ; bit   key
                                   ; ---   ------
                                   ;  7   [DOWN]
                                   ;  6   /
                                   ;  5   ,
                                   ;  4   N
                                   ;  3   V
                                   ;  2   X
                                   ;  1   [L SHIFT]
                                   ;  0   [STOP]

0092          SVXT   = $92         ; timing constant for tape read
0093          VERCKK = $93         ; load/verify flag, load = $00, verify = $01
0094          C3PO   = $94         ; serial output: deferred character flag
                                   ; $00 = no character waiting, $xx = character waiting
0095          BSOUR  = $95         ; serial output: deferred character
                                   ; $FF = no character waiting, $xx = waiting character
0096          SYNO   = $96         ; cassette block synchronization number
0097          TEMPX  = $97         ; register save

              ; The number of currently open I/O files is stored here. The maximum
              ; number that can be open at one time is ten. The number stored here is
              ; used as the index to the end of the tables that hold the file numbers,
              ; device numbers, and secondary addresses.

0098          LDTND  = $98         ; open file count

              ; The default value of this location is 0.

0099          DFLTN  = $99         ; input device number

              ; The default value of this location is 3.

009a          DFLTO  = $9A         ; output device number
                                   ;
                                   ; number   device
                                   ; ------   ------
                                   ;  0      keyboard
                                   ;  1      cassette
                                   ;  2      RS-232C
                                   ;  3      screen
                                   ;  4-31   serial bus

009b          PRTY   = $9B         ; tape character parity
009c          DPSW   = $9C         ; byte received flag
009d          MSGFLG = $9D         ; message mode flag,
                                   ; $C0 = both control and kernal messages,
                                   ; $80 = control messages only,
                                   ; $40 = kernal messages only,
                                   ; $00 = neither control or kernal messages
009e          PTR1   = $9E         ; index to cassette file name/header ID
009f          PTR2   = $9F         ; tape Pass 2 error log corrected

              ; These three locations form a counter which is updated 60 times a
              ; second, and serves as a software clock which counts the number of
              ; jiffies that have elapsed since the computer was turned on. After 24
              ; hours and one jiffy these locations are set back to $000000.

00a0          JIFFYH = $A0         ; jiffy clock high byte
00a1          JIFFYM = $A1         ; jiffy clock mid byte
00a2          JIFFYL = $A2         ; jiffy clock low byte
00a3          TSFCNT = $A3         ; EOI flag byte/tape bit count or Jiffy device flag
00a4          TBTCNT = $A4         ; tape bit cycle phase
00a5          CNTDN  = $A5         ; tape synch byte count/serial bus bit count
00a6          BUFPNT = $A6         ; tape buffer index
00a7          INBIT  = $A7         ; receiver input bit temp storage
00a8          BITCI  = $A8         ; receiver bit count in
00a9          RINONE = $A9         ; receiver start bit check flag, $90 = no start bit
00aa          RIDATA = $AA         ; receiver byte buffer/assembly location
00ab          RIPRTY = $AB         ; receiver parity bit storage
00ac          SAL    = $AC         ; tape buffer start pointer; scroll screen
00ae          EAL    = $AE         ; tape buffer end   pointer; scroll screen
00b0          CMPO   = $B0         ; tape timing constant (word)

              ; These two locations point to the address of the cassette buffer. This
              ; pointer must be greater than or equal to $0200 or an ILLEGAL DEVICE
              ; NUMBER error will be sent when tape I/O is tried. This pointer must
              ; also be less that $8000 or the routine will terminate early.

00b2          TAPE1  = $B2         ; tape buffer start pointer

              ; RS232 routines use this to count the number of bits transmitted and
              ; for parity and stop bit manipulation. Tape load routines use this
              ; location to flag when they are ready to receive data bytes.

00b4          BITTS  = $B4         ; transmitter bit count out

              ; This location is used by the RS232 routines to hold the next bit to
              ; be sent and by the tape routines to indicate what part of a block the
              ; read routine is currently reading.

00b5          NXTBIT = $B5         ; transmitter next bit to be sent

              ; RS232 routines use this area to disassemble each byte to be sent from
              ; the transmission buffer pointed to by $F9.

00b6          RODATA = $B6         ; transmitter byte buffer/disassembly location

              ; Disk filenames may be up to 16 characters in length while tape
              ; filenames be up to 187 characters in length.
              ; If a tape name is longer than 16 characters the excess will be
              ; truncated by the SEARCHING and FOUND messages, but will still be
              ; present on the tape.
              ; A disk file is always referred to by a name. This location will always
              ; be greater than zero if the current file is a disk file.

              ; An RS232 OPEN command may specify a filename of up to four characters.
              ; These characters are copied to locations $293 to $296 and determine
              ; baud rate, word length, and parity, or they would do if the feature
              ; was fully implemented.

00b7          FNLEN  = $B7         ; file name length

00b8          LA     = $B8         ; logical file
00b9          SA     = $B9         ; secondary address
00ba          FA     = $BA         ; current device number
                                   ; number   device
                                   ; ------   ------
                                   ;  0      keyboard
                                   ;  1      cassette
                                   ;  2      RS-232C
                                   ;  3      screen
                                   ;  4-31   serial bus
00bb          FNADR  = $BB         ; file name pointer
00bd          ROPRTY = $BD         ; tape write byte/RS232 parity byte

              ; Used by the tape routines to count the number of copies of a data
              ; block remaining to be read or written.

0001 FALSE    #if JIFFY
SKIP          Jiffy_Device = $BE
              #endif
00be          FSBLK  = $BE         ; tape copies count
00bf          MYCH   = $BF         ; parity count ??
00c0          CAS1   = $C0         ; tape motor interlock
00c1          STAL   = $C1         ; I/O start addresses
00c3          MEMUSS = $C3         ; kernal setup pointer
00c5          LSTX   = $C5         ; current key pressed
                                   ;
                                   ;  # key    # key    # key    # key
                                   ; -- ---   -- ---   -- ---   -- ---
                                   ; 00 1   10 none   20 [SPACE]   30 Q
                                   ; 01 3   11 A      21 Z      31 E
                                   ; 02 5   12 D      22 C      32 T
                                   ; 03 7   13 G      23 B      33 U
                                   ; 04 9   14 J      24 M      34 O
                                   ; 05 +   15 L      25 .      35 @
                                   ; 06 [UKP]   16 ;      26 none   36 ^
                                   ; 07 [DEL]   17 [CSR R]   27 [F1]   37 [F5]
                                   ; 08 [<-]   18 [STOP]   28 none   38 2
                                   ; 09 W   19 none   29 S      39 4
                                   ; 0A R   1A X      2A F      3A 6
                                   ; 0B Y   1B V      2B H      3B 8
                                   ; 0C I   1C N      2C K      3C 0
                                   ; 0D P   1D ,      2D :      3D -
                                   ; 0E *   1E /      2E =      3E [HOME]
                                   ; 0F [RET]   1F [CSR D]   2F [F3]   3F [F7]

00c6          NDX    = $C6         ; keyboard buffer length/index

              ; When the [CTRL][RVS-ON] characters are printed this flag is set to
              ; $12, and the print routines will add $80 to the screen code of each
              ; character which is printed, so that the caracter will appear on the
              ; screen with its colours reversed.

              ; Note that the contents of this location are cleared not only upon
              ; entry of a [CTRL][RVS-OFF] character but also at every carriage return

00c7          RVS    = $C7         ; reverse flag $12 = reverse, $00 = normal

              ; This pointer indicates the column number of the last nonblank
              ; character on the logical line that is to be input. Since a logical
              ; line can be up to 88 characters long this number can range from 0-87.

00c8          INDX   = $C8         ; input [EOL] pointer

              ; These locations keep track of the logical line that the cursor is on
              ; and its column position on that logical line.

              ; Each logical line may contain up to four 22 column physical lines. So
              ; there may be as many as 23 logical lines, or as few as 6 at any one
              ; time. Therefore, the logical line number might be anywhere from 1-23.
              ; Depending on the length of the logical line, the cursor column may be
              ; from 1-22, 1-44, 1-66 or 1-88.

              ; For a more on logical lines, see the description of the screen line
              ; link table, $D9.

00c9          ICRROW = $C9         ; input cursor row
00ca          ICRCOL = $CA         ; input cursor column

              ; The keyscan interrupt routine uses this location to indicate which key
              ; is currently being pressed. The value here is then used as an index
              ; into the appropriate keyboard table to determine which character to
              ; print when a key is struck.

              ; The correspondence between the key pressed and the number stored here
              ; is as follows:

              ; $00   1      $10   unused $20   [SPC]  $30   Q
              ; $01   3      $11   A      $21   Z      $31   E
              ; $02   5      $12   D      $22   C      $32   T
              ; $03   7      $13   G      $23   B      $33   U
              ; $04   9      $14   J      $24   M      $34   O
              ; $05   +      $15   L      $25   .      $35   @
              ; $06   [PND]  $16   ;      $26   unused $36   [U ARROW]
              ; $07   [DEL]  $17   [RIGHT]$27   [F1]   $37   [F5]   
              ; $08   [<-]   $18   [STOP] $28   unused $38   2
              ; $09   W      $19   unused $29   S      $39   4
              ; $0A   R      $1A   X      $2A   F      $3A   6
              ; $0B   Y      $1B   V      $2B   H      $3B   8
              ; $0C   I      $1C   N      $2C   K      $3C   0
              ; $0D   P      $1D   ,      $2D   :      $3D   -
              ; $0E   *      $1E   /      $2E   =      $3E   [HOME]
              ; $0F   [RET]  $1F   [DOWN] $2F   [F3]   $3F   [F7]

00cb          SFDX   = $CB         ; which key

              ; When this flag is set to a nonzero value, it indicates to the routine
              ; that normally flashes the cursor not to do so. The cursor blink is
              ; turned off when there are characters in the keyboard buffer, or when
              ; the program is running.

00cc          BLNSW  = $CC         ; cursor enable, $00 = flash cursor

              ; The routine that blinks the cursor uses this location to tell when
              ; it's time for a blink. The number 20 is put here and decremented every
              ; jiffy until it reaches zero. Then the cursor state is changed, the
              ; number 20 is put back here, and the cycle starts all over again.

00cd          BLNCT  = $CD         ; cursor timing countdown

              ; The cursor is formed by printing the inverse of the character that
              ; occupies the cursor position. If that characters is the letter A, for
              ; example, the flashing cursor merely alternates between printing an A
              ; and a reverse-A. This location keeps track of the normal screen code
              ; of the character that is located at the cursor position, so that it
              ; may be restored when the cursor moves on.

00ce          GDBLN  = $CE         ; character under cursor

              ; This location keeps track of whether, during the current cursor blink,
              ; the character under the cursor was reversed, or was restored to
              ; normal. This location will contain 0 if the character is reversed, and
              ; 1 if the character is not reversed.

00cf          BLNON  = $CF         ; cursor blink phase

              ; input from keyboard or screen, $xx = input is available from the
              ; screen, $00 = input should be obtained from the keyboard

00d0          INSRC  = $D0         ; input from keyboard or screen

              ; These locations point to the address in screen RAM of the first column
              ; of the logical line upon which the cursor is currently positioned.

00d1          LINPTR = $D1         ; current screen line pointer

              ; This holds the cursor column position within the logical line pointed
              ; to by LINPTR. Since a logical line can comprise up to four physical
              ; lines, this value may be from $00 to $57.

00d3          CSRIDX = $D3         ; cursor column

              ; A nonzero value in this location indicates that the editor is in quote
              ; mode. Quote mode is toggled every time that you type in a quotation
              ; mark on a given line, the first quote mark turns it on, the second
              ; turns it off, the third turns it on, etc.

              ; If the editor is in this mode when a cursor control character or other
              ; nonprinting character is entered, a printed equivalent will appear on
              ; the screen instead of the cursor movement or other control operation
              ; taking place. Instead, that action is deferred until the string is
              ; sent to the string by a PRINT statement, at which time the cursor
              ; movement or other control operation will take place.

              ; The exception to this rule is the DELETE key, which will function
              ; normally within quote mode. The only way to print a character which is
              ; equivalent to the DELETE key is by entering insert mode. Quote mode
              ; may be exited by printing a closing quote or by hitting the RETURN or
              ; SHIFT-RETURN keys.

00d4          CSRMOD = $D4         ; cursor quote flag

              ; The line editor uses this location when the end of a line has been
              ; reached to determine whether another physical line can be added to the
              ; current logical line or if a new logical line must be started.

00d5          LINLEN = $D5         ; current screen line length

              ; This location contains the current physical screen line position of
              ; the cursor, 0 to 22 for VIC or 0 to 24 for C64.

00d6          TBLX   = $D6         ; cursor row

              ; The ASCII value of the last character printed to the screen is held
              ; here temporarily.

00d7          LASTKY = $D7         ; checksum byte/temporary last character

              ; When the INST key is pressed, the screen editor shifts the line to the
              ; right, allocates another physical line to the logical line if
              ; necessary (and possible), updates the screen line length in $D5, and
              ; adjusts the screen line link table at $D9. This location is used to
              ; keep track of the number of spaces that has been opened up in this way.

              ; Until the spaces that have been opened up are filled, the editor acts
              ; as if in quote mode. See location $D4, the quote mode flag. This means
              ; that cursor control characters that are normally nonprinting will
              ; leave a printed equivalent on the screen when entered, instead of
              ; having their normal effect on cursor movement, etc. The only
              ; difference between insert and quote mode is that the DELETE key will
              ; leave a printed equivalent in insert mode, while the INSERT key will
              ; insert spaces as normal.

00d8          INSRTO = $D8         ; insert count

              ; This table contains 23/25 entries, one for each row of the screen
              ; display. Each entry has two functions. Bits 0-3 indicate on which of
              ; the four pages of screen memory the first byte of memory for that row
              ; is located. This is used in calculating the pointer to the starting
              ; address of a screen line at $D1.
              ;
              ; The high byte is calculated by adding the value of the starting page
              ; of screen memory held in $288 to the displacement page held here.
              ;
              ; The other function of this table is to establish the makeup of logical
              ; lines on the screen. While each screen line is only 22/40 characters
              ; long, BASIC allows the entry of program lines that contain up to 88
              ; characters. Therefore, some method must be used to determine which
              ; physical lines are linked into a longer logical line, so that this
              ; longer logical line may be edited as a unit.
              ;
              ; The high bit of each byte here is used as a flag by the screen editor.
              ; That bit is set when a line is the first or only physical line in a
              ; logical line. The high bit is reset to 0 only when a line is an
              ; extension to this logical line.

00d9          SLLTBL = $D9         ; to SLLTBL + $18 inclusive, screen line link table

              ; This pointer is synchronized with the pointer to the address of the
              ; first byte of screen RAM for the current line kept in location $D1. It
              ; holds the address of the first byte of colour RAM for the
              ; corresponding screen line.

0000 TRUE     #if VIC
00f2          SCROWM = $F2         ; screen row marker
              #endif

00f3          USER   = $F3         ; colour RAM pointer

              ; This pointer points to the address of the keyboard matrix lookup table
              ; currently being used. Although there are only 64 keys on the keyboard
              ; matrix, each key can be used to print up to four different characters,
              ; depending on whether it is struck by itself or in combination with the
              ; SHIFT, CTRL, or C= keys.

              ; These tables hold the ASCII value of each of the 64 keys for one of
              ; these possible combinations of keypresses. When it comes time to print
              ; the character, the table that is used determines which character is
              ; printed.

              ; The addresses of the tables are:

              ;   KBD_NORMAL          ; unshifted
              ;   KBD_SHIFTED         ; shifted
              ;   KBD_CBMKEY          ; commodore
              ;   KBD_CONTROL         ; control

00f5          KBDPTR = $F5         ; keyboard pointer

              ; When device the RS232 channel is opened two buffers of 256 bytes each
              ; are created at the top of memory. These locations point to the address
              ; of the one which is used to store characters as they are received.

00f7          RXPTR  = $F7         ; RS232 Rx pointer

              ; These locations point to the address of the 256 byte output buffer
              ; that is used for transmitting data to RS232 devices.

00f9          TXPTR  = $F9         ; RS232 Tx pointer

00ff          BASSTO = $FF         ; FAC1 to string output base

0100          STACK  = $0100       ; bottom of the stack page

0200          BUF    = $0200       ;   input buffer. for some routines the byte before
                                   ;   the input buffer needs to be set to a specific
                                   ;   value for the routine to work correctly

0259          FILTBL = $0259       ;   .. to $0262 logical file table
0263          DEVTBL = $0263       ;   .. to $026C device number table
026d          SECATB = $026D       ;   .. to $0276 secondary address table
0277          KBUFFR = $0277       ;   .. to $0280 keyboard buffer
0281          OSSTAR = $0281       ;   OS start of memory low byte
0283          OSTOP  = $0283       ;   OS top of memory low byte
0285          STIMOT = $0285       ;   serial bus timeout flag
0286          COLOR  = $0286       ;   current colour code
0287          CSRCLR = $0287       ;   colour under cursor
0288          SCNMPG = $0288       ;   screen memory page
0289          KBMAXL = $0289       ;   maximum keyboard buffer size
028a          KEYRPT = $028A       ;   key repeat. $80 = repeat all, $40 = repeat none,
                                   ;   $00 = repeat cursor movement keys, insert/delete
                                   ;   key and the space bar
028b          KRPTSP = $028B       ;   repeat speed counter
028c          KRPTDL = $028C       ;   repeat delay counter

              ; This flag signals which of the SHIFT, CTRL, or C= keys are currently
              ; being pressed.

              ; A value of $01 signifies that one of the SHIFT keys is being pressed,
              ; a $02 shows that the C= key is down, and $04 means that the CTRL key
              ; is being pressed. If more than one key is held down, these values will
              ; be added e.g $03 indicates that SHIFT and C= are both held down.

              ; Pressing the SHIFT and C= keys at the same time will toggle the
              ; character set that is presently being used between the uppercase/
              ; graphics set, and the lowercase/uppercase set.

              ; While this changes the appearance of all of the characters on the
              ; screen at once it has nothing whatever to do with the keyboard shift
              ; tables and should not be confused with the printing of SHIFTed
              ; characters, which affects only one character at a time.

028d          SHFLAG   = $028D     ; keyboard shift/control flag
                                   ; bit   key(s) 1 = down
                                   ; ---   ---------------
                                   ; 7-3   unused
                                   ;  2   CTRL
                                   ;  1   C=
                                   ;  0   SHIFT

              ; This location, in combination with the one above, is used to debounce
              ; the special SHIFT keys. This will keep the SHIFT/C= combination from
              ; changing character sets back and forth during a single pressing of
              ; both keys.

028e          LSTSHF   = $028E     ; SHIFT/CTRL/C= keypress last pattern

              ; This location points to the address of the Operating System routine
              ; which actually determines which keyboard matrix lookup table will be
              ; used.

              ; The routine looks at the value of the SHIFT flag at $28D, and based on
              ; what value it finds there, stores the address of the correct table to
              ; use at location $F5.

028f          KEYLOG   = $028F     ; keyboard decode logic pointer

              ; This flag is used to enable or disable the feature which lets you
              ; switch between the uppercase/graphics and upper/lowercase character
              ; sets by pressing the SHIFT and Commodore logo keys simultaneously.

0291          MODE     = $0291     ; shift mode switch, $00 = enabled, $80 = locked

              ; This location is used to determine whether moving the cursor past the
              ; xx  column of a logical line will cause another physical line to be
              ; added to the logical line.

              ; A value of 0 enables the screen to scroll the following lines down in
              ; order to add that line; any nonzero value will disable the scroll.

              ; This flag is set to disable the scroll temporarily when there are
              ; characters waiting in the keyboard buffer, these may include cursor
              ; movement characters that would eliminate the need for a scroll.

0292          AUTODN   = $0292     ; screen scrolling flag, $00 = enabled

0293          M51CTR   = $0293     ; pseudo 6551 control register. the first character of
                                   ; the OPEN RS232 filename will be stored here
                                   ; bit   function
                                   ; ---   --------
                                   ;  7   2 stop bits/1 stop bit
                                   ; 65   word length
                                   ; ---   -----------
                                   ; 00   8 bits
                                   ; 01   7 bits
                                   ; 10   6 bits
                                   ; 11   5 bits
                                   ;  4   unused
                                   ; 3210   baud rate
                                   ; ----   ---------
                                   ; 0000   user rate *
                                   ; 0001      50
                                   ; 0010      75
                                   ; 0011     110
                                   ; 0100     134.5
                                   ; 0101     150
                                   ; 0110     300
                                   ; 0111     600
                                   ; 1000    1200
                                   ; 1001    1800
                                   ; 1010    2400
                                   ; 1011    3600
                                   ; 1100    4800 *
                                   ; 1101    7200 *
                                   ; 1110    9600 *
                                   ; 1111   19200 *   * = not implemented
0294          M51CDR   = $0294     ; pseudo 6551 command register. the second character of
                                   ; the OPEN RS232 filename will be stored here
                                   ; bit   function
                                   ; ---   --------
                                   ; 765   parity
                                   ; ---   ------
                                   ; xx0   disabled
                                   ; 001   odd
                                   ; 011   even
                                   ; 101   mark
                                   ; 111   space
                                   ;  4   duplex half/full
                                   ;  3   unused
                                   ;  2   unused
                                   ;  1   unused
                                   ;  0   handshake - X line/3 line
0295          M51AJB   = $0295     ; Nonstandard Bit Timing. the third and fourth character
                                   ; of the OPEN RS232 filename will be stored here
0297          RSSTAT   = $0297     ; RS-232 status register
                                   ; bit   function
                                   ; ---   --------
                                   ;  7   break
                                   ;  6   no DSR detected
                                   ;  5   unused
                                   ;  4   no CTS detected
                                   ;  3   unused
                                   ;  2   Rx buffer overrun
                                   ;  1   framing error
                                   ;  0   parity error
0298          BITNUM   = $0298     ; number of bits to be sent/received
0299          BAUDOF   = $0299     ; time of one bit cell
029b          RIDBE    = $029B     ; index to Rx buffer end
029c          RIDBS    = $029C     ; index to Rx buffer start
029d          RODBS    = $029D     ; index to Tx buffer start
029e          RODBE    = $029E     ; index to Tx buffer end
029f          IRQTMP   = $029F     ; saved IRQ

0001 FALSE    #if C64
SKIP          ENABL    = $02A1
SKIP          TODSNS   = $02A2
SKIP          TRDTMP   = $02A3
SKIP          TD1IRQ   = $02A4
SKIP          SCROWM   = $02A5     ; screen row marker
SKIP          TVSFLG   = $02A6     ; PAL / NTSC flag
              #endif

0300          IERROR   = $0300     ; vector to the print BASIC error message routine
0302          IMAIN    = $0302     ; Vector to the main BASIC program Loop
0304          ICRNCH   = $0304     ; Vector to the the ASCII text to keywords routine
0306          IQPLOP   = $0306     ; Vector to the list BASIC program as ASCII routine
0308          IGONE    = $0308     ; Vector to the execute next BASIC command routine
030a          IEVAL    = $030A     ; Vector to the get value from BASIC line routine

              ; Before every SYS command each of the registers is loaded with the
              ; value found in the corresponding storage address. Upon returning to
              ; BASIC with an RTS instruction, the new value of each register is
              ; stored in the appropriate storage address.

              ; This feature allows you to place the necessary values into the
              ; registers from BASIC before you SYS to a Kernal or BASIC ML routine.
              ; It also enables you to examine the resulting effect of the routine on
              ; the registers, and to preserve the condition of the registers on exit
              ; for subsequent SYS calls.

030c          SAREG    = $030C     ; A for SYS command
030d          SXREG    = $030D     ; X for SYS command
030e          SYREG    = $030E     ; Y for SYS command
030f          SPREG    = $030F     ; P for SYS command

0001 FALSE    #if C64
SKIP          Basic_USR= $0310     ; USR() JMP instruction ($4C)
SKIP          USRVEC   = $0311     ; USR() vector
              #endif

0314          CINV     = $0314     ; IRQ vector
0316          CBINV    = $0316     ; BRK vector
0318          NMINV    = $0318     ; NMI vector

031a          IOPEN    = $031A     ; kernal vector - open a logical file
031c          ICLOSE   = $031C     ; kernal vector - close a logical file
031e          ICHKIN   = $031E     ; kernal vector - open channel for input
0320          ICKOUT   = $0320     ; kernal vector - open channel for output
0322          ICLRCH   = $0322     ; kernal vector - close input and output channels
0324          IBASIN   = $0324     ; kernal vector - input character from channel
0326          IBSOUT   = $0326     ; kernal vector - output character to channel
0328          ISTOP    = $0328     ; kernal vector - check if stop key is pressed
032a          IGETIN   = $032A     ; kernal vector - get character from keyboard queue
032c          ICLALL   = $032C     ; kernal vector - close all channels and files
032e          USRCMD   = $032E     ; kernal vector - user IRQ
0330          ILOAD    = $0330     ; kernal vector - load
0332          ISAVE    = $0332     ; kernal vector - save

033c          TBUFFR   = $033C     ; to $03FB - cassette buffer

              ; hardware equates

0001 FALSE    #if C64
SKIP             IO_Base_Address = $DC00
              #endif

0000 TRUE     #if VIC
9110             IO_Base_Address = $9110
              #endif

              ; command tokens

0080          TK_END     = $80   ; END token
0081          TK_FOR     = $81   ; FOR token
0082          TK_NEXT    = $82   ; NEXT token
0083          TK_DATA    = $83   ; DATA token
0084          TK_INFL    = $84   ; INPUT# token
0085          TK_INPUT   = $85   ; INPUT token
0086          TK_DIM     = $86   ; DIM token
0087          TK_READ    = $87   ; READ token

0088          TK_LET     = $88   ; LET token
0089          TK_GOTO    = $89   ; GOTO token
008a          TK_RUN     = $8A   ; RUN token
008b          TK_IF      = $8B   ; IF token
008c          TK_RESTORE = $8C   ; RESTORE token
008d          TK_GOSUB   = $8D   ; GOSUB token
008e          TK_RETURN  = $8E   ; RETURN token
008f          TK_REM     = $8F   ; REM token

0090          TK_STOP    = $90   ; STOP token
0091          TK_ON      = $91   ; ON token
0092          TK_WAIT    = $92   ; WAIT token
0093          TK_LOAD    = $93   ; LOAD token
0094          TK_SAVE    = $94   ; SAVE token
0095          TK_VERIFY  = $95   ; VERIFY token
0096          TK_DEF     = $96   ; DEF token
0097          TK_POKE    = $97   ; POKE token

0098          TK_PRINFL  = $98   ; PRINT# token
0099          TK_PRINT   = $99   ; PRINT token
009a          TK_CONT    = $9A   ; CONT token
009b          TK_LIST    = $9B   ; LIST token
009c          TK_CLR     = $9C   ; CLR token
009d          TK_CMD     = $9D   ; CMD token
009e          TK_SYS     = $9E   ; SYS token
009f          TK_OPEN    = $9F   ; OPEN token

00a0          TK_CLOSE   = $A0   ; CLOSE token
00a1          TK_GET     = $A1   ; GET token
00a2          TK_NEW     = $A2   ; NEW token

              ; secondary keyword tokens

00a3          TK_TAB     = $A3   ; TAB( token
00a4          TK_TO      = $A4   ; TO token
00a5          TK_FN      = $A5   ; FN token
00a6          TK_SPC     = $A6   ; SPC( token
00a7          TK_THEN    = $A7   ; THEN token

00a8          TK_NOT     = $A8   ; NOT token
00a9          TK_STEP    = $A9   ; STEP token

              ; operator tokens

00aa          TK_PLUS    = $AA   ; + token
00ab          TK_MINUS   = $AB   ; - token
00ac          TK_MUL     = $AC   ; * token
00ad          TK_DIV     = $AD   ; / token
00ae          TK_POWER   = $AE   ; ^ token
00af          TK_AND     = $AF   ; AND token

00b0          TK_OR      = $B0   ; OR token
00b1          TK_GT      = $B1   ; > token
00b2          TK_EQUAL   = $B2   ; = token
00b3          TK_LT      = $B3   ; < token

              ; function tokens

00b4          TK_SGN     = $B4   ; SGN token
00b5          TK_INT     = $B5   ; INT token
00b6          TK_ABS     = $B6   ; ABS token
00b7          TK_USR     = $B7   ; USR token

00b8          TK_FRE     = $B8   ; FRE token
00b9          TK_POS     = $B9   ; POS token
00ba          TK_SQR     = $BA   ; SQR token
00bb          TK_RND     = $BB   ; RND token
00bc          TK_LOG     = $BC   ; LOG token
00bd          TK_EXP     = $BD   ; EXP token
00be          TK_COS     = $BE   ; COS token
00bf          TK_SIN     = $BF   ; SIN token

00c0          TK_TAN     = $C0   ; TAN token
00c1          TK_ATN     = $C1   ; ATN token
00c2          TK_PEEK    = $C2   ; PEEK token
00c3          TK_LEN     = $C3   ; LEN token
00c4          TK_STRS    = $C4   ; STR$ token
00c5          TK_VAL     = $C5   ; VAL token
00c6          TK_ASC     = $C6   ; ASC token
00c7          TK_CHRS    = $C7   ; CHR$ token

00c8          TK_LEFTS   = $C8   ; LEFT$ token
00c9          TK_RIGHTS  = $C9   ; RIGHT$ token
00ca          TK_MIDS    = $CA   ; MID$ token
00cb          TK_GO      = $CB   ; GO token
00ff          TK_PI      = $FF   ; PI token

              ; KERNAL Jump Table
              ; ----------------------------------------------------------------------
              ; ACPTR       $FFA5 65445    Input byte from serial port
              ; CHKIN       $FFC6 65478    Open channel for input
              ; CHKOUT      $FFC9 65481    Open a channel for output
              ; CHRIN       $FFCF 65487    Get a character from the input channel
              ; CHROUT      $FFD2 65490    Output a character
              ; CIOUT       $FFA8 65448    Output byte to serial port
              ; CLALL       $FFE7 65511    Close all channels and files
              ; CLOSE       $FFC3 65475    Close a specified logical file
              ; CLRCHN      $FFCC 65484    Clear I/O channels
              ; GETIN       $FFE4 65512    Get character from keyboard buffer
              ; IOBASE      $FFF3 65523    Define I/O memory page
              ; LISTEN      $FFB1 65457    Command devices on the serial bus to LISTEN
              ; LOAD        $FFD5 65493    Load RAM from a device
              ; MEMBOT      $FF9C 65436    Read/set the bottom of memory
              ; MEMTOP      $FF99 65433    Read/set the top of memory
              ; OPEN        $FFC0 65472    Open a logical file
              ; PLOT        $FFF0 65520    Read or set cursor location
              ; RDTIM       $FFDE 65502    Read system clock
              ; READST      $FFB7 65463    Read I/O status word
              ; RESTOR      $FF8A 65415    Restore default I/O vectors
              ; SAVE        $FFD8 65496    Save RAM to device
              ; SCNKEY      $FF9F 65439    Scan keyboard
              ; SCREEN      $FFED 65517    Return screen format
              ; SECOND      $FF93 65427    Send secondary address after LISTEN
              ; SETLFS      $FFBA 65466    Set logical, first and second addresses
              ; SETMSG      $FF90 65424    Control KERNAL messages
              ; SETNAM      $FFBD 65469    Set filename
              ; SETTIM      $FFDB 65499    Set the system clock
              ; SETTMO      $FFA2 65442    Set timeout on serial bus
              ; STOP        $FFE1 65505    Scan stop key
              ; TALK        $FFB4 65460    Command serial bus device to TALK
              ; TKSA        $FF96 65430    Send secondary address after TALK
              ; UDTIM       $FFEA 65514    Update the system clock
              ; UNLSN       $FFAE 65454    Command serial bus to UNLISTEN
              ; UNTLK       $FFAB 65451    Command serial bus to UNTALK
              ; VECTOR      $FF8D 65421    Read/set vectored I/O


              ; **********************
              ; BASIC scalar variables
              ; **********************

              ; ---------+-----+-----+-----+-----+-----+-----+-----+-----
              ; Type     | Exa.|  0  |  1  |  2  |  3  |  4  |  5  |  6
              ; ---------+-----+-----+-----+-----+-----+-----+-----+-----
              ; Float    | AB  |  A  |  B  | EXP | MSB | MAN | MAN | LSB
              ; ---------+-----+-----+-----+-----+-----+-----+-----+-----
              ; Integer  | AB% |  A^ |  B^ | MSB | LSB |  0  |  0  |  0  
              ; ---------+-----+-----+-----+-----+-----+-----+-----+-----
              ; Function | AB( |  A^ |  B  | LFP | MFP | LBP | MBP |  0  
              ; ---------+-----+-----+-----+-----+-----+-----+-----+-----
              ; String   | AB$ |  A  |  B^ | LEN | LSP | MSP |  0  |  0
              ; ---------+-----+-----+-----+-----+-----+-----+-----+-----

              ; ************
              ; BASIC arrays
              ; ************

              ; ---------+-----+-----+-----+---------------+
              ; Type     | Exa.|  0  |  1  |  Element Size |
              ; ---------+-----+-----+-----+---------------+
              ; Float    | AB  |  A  |  B  |       5       |
              ; ---------+-----+-----+-----+---------------+
              ; Integer  | AB% |  A^ |  B^ |       2       |
              ; ---------+-----+-----+-----+---------------+
              ; String   | AB$ |  A  |  B^ |       3       |
              ; ---------+-----+-----+-----+---------------+

              ; The circumflex ^ indicates characters OR'ed with $80

              ; Array header:

              ; Byte  0   : 1st. character of name
              ; Byte  1   : 2nd, character of name
              ; Byte  2   : dimension count (1, 2, or 3)
              ; Byte  3-4 : Hi/Lo lements of 1st. dimension, (e.g. 11 for dim a(10)
              ; Byte  5-6 : elements of 2nd. dimension if dimension count > 1
              ; Byte  7-8 : elements of 3rd. dimension if dimension count > 2

c000                    .org    BASIC_ROM
0001 FALSE    #if C64
SKIP                    .store  BASIC_ROM,$2000,"basic_64.rom"
              #endif
0000 TRUE     #if VIC
                        .store  BASIC_ROM,$2000,"basic_20.rom"
              #endif
c000 78 e3              .word   Basic_Cold_Start
c002 67 e4    BASIC_BRK .word   Basic_Warm_Start
c004 43 42 4d BASIC_ID  .byte   "CBMBASIC"

              ; *********************
c00c            Basic_Statement_Table
              ; *********************

c00c 30 c8       .word Basic_END      -1; $80
c00e 41 c7       .word Basic_FOR      -1; $81
c010 1d cd       .word Basic_NEXT     -1; $82
c012 f7 c8       .word Basic_DATA     -1; $83
c014 a4 cb       .word Basic_INPUTN   -1; $84
c016 be cb       .word Basic_INPUT    -1; $85
c018 80 d0       .word Basic_DIM      -1; $86
c01a 05 cc       .word Basic_READ     -1; $87
c01c a4 c9       .word Basic_LET      -1; $88
c01e 9f c8       .word Basic_GOTO     -1; $89
c020 70 c8       .word Basic_RUN      -1; $8A
c022 27 c9       .word Basic_IF       -1; $8B
c024 1c c8       .word Basic_RESTORE  -1; $8C
c026 82 c8       .word Basic_GOSUB    -1; $8D
c028 d1 c8       .word Basic_RETURN   -1; $8E
c02a 3a c9       .word Basic_REM      -1; $8F
c02c 2e c8       .word Basic_STOP     -1; $90
c02e 4a c9       .word Basic_ON       -1; $91
c030 2c d8       .word Basic_WAIT     -1; $92
c032 64 e1       .word Basic_LOAD     -1; $93
c034 52 e1       .word Basic_SAVE     -1; $94
c036 61 e1       .word Basic_VERIFY   -1; $95
c038 b2 d3       .word Basic_DEF      -1; $96
c03a 23 d8       .word Basic_POKE     -1; $97
c03c 7f ca       .word Basic_PRINTN   -1; $98
c03e 9f ca       .word Basic_PRINT    -1; $99
c040 56 c8       .word Basic_CONT     -1; $9A
c042 9b c6       .word Basic_LIST     -1; $9B
c044 5d c6       .word Basic_CLR      -1; $9C
c046 85 ca       .word Basic_CMD      -1; $9D
c048 26 e1       .word Basic_SYS      -1; $9E
c04a ba e1       .word Basic_OPEN     -1; $9F
c04c c3 e1       .word Basic_CLOSE    -1; $A0
c04e 7a cb       .word Basic_GET      -1; $A1
c050 41 c6       .word Basic_NEW      -1; $A2

              ; ********************
c052            Basic_Function_Table
              ; ********************

c052 39 dc       .word Basic_SGN   ; $B4
c054 cc dc       .word Basic_INT   ; $B5
c056 58 dc       .word Basic_ABS   ; $B6
c058 00 00       .word Basic_USR   ; $B7
c05a 7d d3       .word Basic_FRE   ; $B8
c05c 9e d3       .word Basic_POS   ; $B9
c05e 71 df       .word Basic_SQR   ; $BA
c060 94 e0       .word Basic_RND   ; $BB
c062 ea d9       .word Basic_LOG   ; $BC
c064 ed df       .word Basic_EXP   ; $BD
c066 61 e2       .word Basic_COS   ; $BE
c068 68 e2       .word Basic_SIN   ; $BF
c06a b1 e2       .word Basic_TAN   ; $C0
c06c 0b e3       .word Basic_ATN   ; $C1
c06e 0d d8       .word Basic_PEEK  ; $C2
c070 7c d7       .word Basic_LEN   ; $C3
c072 65 d4       .word Basic_STR   ; $C4
c074 ad d7       .word Basic_VAL   ; $C5
c076 8b d7       .word Basic_ASC   ; $C6
c078 ec d6       .word Basic_CHR   ; $C7
c07a 00 d7       .word Basic_LEFT  ; $C8
c07c 2c d7       .word Basic_RIGHT ; $C9
c07e 37 d7       .word Basic_MID   ; $CA

              ; ********************
c080            Basic_Operator_Table
              ; ********************

c080 79 69 d8    .byte $79,Basic_PLUS     -1 ; $AA
c083 79 52 d8    .byte $79,Basic_MINUS    -1 ; $AB
c086 7b 2a da    .byte $7B,Basic_MULTIPLY -1 ; $AC
c089 7b 11 db    .byte $7B,Basic_DIVIDE   -1 ; $AD
c08c 7f 7a df    .byte $7F,Basic_POWER    -1 ; $AE
c08f 50 e8 cf    .byte $50,Basic_AND      -1 ; $AF
c092 46 e5 cf    .byte $46,Basic_OR       -1 ; $B0
c095 7d b3 df    .byte $7D,Basic_GREATER  -1 ; $B1
c098 5a d3 ce    .byte $5A,Basic_EQUAL    -1 ; $B2
c09b 64 15 d0    .byte $64,Basic_LESS     -1 ; $B3

              ; *******************
c09e            Basic_Keyword_Table
              ; *******************

c09e 45 4e c4    .byte   "END"^    ; END
c0a1 46 4f d2    .byte   "FOR"^    ; FOR
c0a4 4e 45 58    .byte   "NEXT"^   ; NEXT
c0a8 44 41 54    .byte   "DATA"^   ; DATA
c0ac 49 4e 50    .byte   "INPUT#"^ ; INPUT#
c0b2 49 4e 50    .byte   "INPUT"^  ; INPUT
c0b7 44 49 cd    .byte   "DIM"^    ; DIM
c0ba 52 45 41    .byte   "READ"^   ; READ
c0be 4c 45 d4    .byte   "LET"^    ; LET
c0c1 47 4f 54    .byte   "GOTO"^   ; GOTO
c0c5 52 55 ce    .byte   "RUN"^    ; RUN
c0c8 49 c6       .byte   "IF"^     ; IF
c0ca 52 45 53    .byte   "RESTORE"^; RESTORE
c0d1 47 4f 53    .byte   "GOSUB"^  ; GOSUB
c0d6 52 45 54    .byte   "RETURN"^ ; RETURN
c0dc 52 45 cd    .byte   "REM"^    ; REM
c0df 53 54 4f    .byte   "STOP"^   ; STOP
c0e3 4f ce       .byte   "ON"^     ; ON
c0e5 57 41 49    .byte   "WAIT"^   ; WAIT
c0e9 4c 4f 41    .byte   "LOAD"^   ; LOAD
c0ed 53 41 56    .byte   "SAVE"^   ; SAVE
c0f1 56 45 52    .byte   "VERIFY"^ ; VERIFY
c0f7 44 45 c6    .byte   "DEF"^    ; DEF
c0fa 50 4f 4b    .byte   "POKE"^   ; POKE
c0fe 50 52 49    .byte   "PRINT#"^ ; PRINT#
c104 50 52 49    .byte   "PRINT"^  ; PRINT
c109 43 4f 4e    .byte   "CONT"^   ; CONT
c10d 4c 49 53    .byte   "LIST"^   ; LIST
c111 43 4c d2    .byte   "CLR"^    ; CLR
c114 43 4d c4    .byte   "CMD"^    ; CMD
c117 53 59 d3    .byte   "SYS"^    ; SYS
c11a 4f 50 45    .byte   "OPEN"^   ; OPEN
c11e 43 4c 4f    .byte   "CLOSE"^  ; CLOSE
c123 47 45 d4    .byte   "GET"^    ; GET
c126 4e 45 d7    .byte   "NEW"^    ; NEW

              ; next are the secondary command keywords, these can not start a statement

c129 54 41 42    .byte   "TAB("^   ; TAB(
c12d 54 cf       .byte   "TO"^     ; TO
c12f 46 ce       .byte   "FN"^     ; FN
c131 53 50 43    .byte   "SPC("^   ; SPC(
c135 54 48 45    .byte   "THEN"^   ; THEN
c139 4e 4f d4    .byte   "NOT"^    ; NOT
c13c 53 54 45    .byte   "STEP"^   ; STEP

              ; the operators

c140 ab          .byte   "+"^      ; +
c141 ad          .byte   "-"^      ; -
c142 aa          .byte   "*"^      ; *
c143 af          .byte   "/"^      ; /
c144 de          .byte   "^"^      ; ^
c145 41 4e c4    .byte   "AND"^    ; AND
c148 4f d2       .byte   "OR"^     ; OR
c14a be          .byte   ">"^      ; >
c14b bd          .byte   "="^      ; =
c14c bc          .byte   "<"^      ; <

              ; the functions

c14d 53 47 ce    .byte   "SGN"^    ; SGN
c150 49 4e d4    .byte   "INT"^    ; INT
c153 41 42 d3    .byte   "ABS"^    ; ABS
c156 55 53 d2    .byte   "USR"^    ; USR
c159 46 52 c5    .byte   "FRE"^    ; FRE
c15c 50 4f d3    .byte   "POS"^    ; POS
c15f 53 51 d2    .byte   "SQR"^    ; SQR
c162 52 4e c4    .byte   "RND"^    ; RND
c165 4c 4f c7    .byte   "LOG"^    ; LOG
c168 45 58 d0    .byte   "EXP"^    ; EXP
c16b 43 4f d3    .byte   "COS"^    ; COS
c16e 53 49 ce    .byte   "SIN"^    ; SIN
c171 54 41 ce    .byte   "TAN"^    ; TAN
c174 41 54 ce    .byte   "ATN"^    ; ATN
c177 50 45 45    .byte   "PEEK"^   ; PEEK
c17b 4c 45 ce    .byte   "LEN"^    ; LEN
c17e 53 54 52    .byte   "STR$"^   ; STR$
c182 56 41 cc    .byte   "VAL"^    ; VAL
c185 41 53 c3    .byte   "ASC"^    ; ASC
c188 43 48 52    .byte   "CHR$"^   ; CHR$
c18c 4c 45 46    .byte   "LEFT$"^  ; LEFT$
c191 52 49 47    .byte   "RIGHT$"^ ; RIGHT$
c197 4d 49 44    .byte   "MID$"^   ; MID$
c19b 47 cf       .byte   "GO"^     ; GO so that GO TO, as well as GOTO, will work
c19d 00          .byte   $00       ; end marker

              ; error messages

c19e 54 4f 4f ERR_01 .byte   "TOO MANY FILES"^
c1ac 46 49 4c ERR_02 .byte   "FILE OPEN"^
c1b5 46 49 4c ERR_03 .byte   "FILE NOT OPEN"^
c1c2 46 49 4c ERR_04 .byte   "FILE NOT FOUND"^
c1d0 44 45 56 ERR_05 .byte   "DEVICE NOT PRESENT"^
c1e2 4e 4f 54 ERR_06 .byte   "NOT INPUT FILE"^
c1f0 4e 4f 54 ERR_07 .byte   "NOT OUTPUT FILE"^
c1ff 4d 49 53 ERR_08 .byte   "MISSING FILE NAME"^
c210 49 4c 4c ERR_09 .byte   "ILLEGAL DEVICE NUMBER"^
c225 4e 45 58 ERR_0A .byte   "NEXT WITHOUT FOR"^
c235 53 59 4e ERR_0B .byte   "SYNTAX"^
c23b 52 45 54 ERR_0C .byte   "RETURN WITHOUT GOSUB"^
c24f 4f 55 54 ERR_0D .byte   "OUT OF DATA"^
c25a 49 4c 4c ERR_0E .byte   "ILLEGAL QUANTITY"^
c26a 4f 56 45 ERR_0F .byte   "OVERFLOW"^
c272 4f 55 54 ERR_10 .byte   "OUT OF MEMORY"^
c27f 55 4e 44 ERR_11 .byte   "UNDEF'D STATEMENT"^
c290 42 41 44 ERR_12 .byte   "BAD SUBSCRIPT"^
c29d 52 45 44 ERR_13 .byte   "REDIM'D ARRAY"^
c2aa 44 49 56 ERR_14 .byte   "DIVISION BY ZERO"^
c2ba 49 4c 4c ERR_15 .byte   "ILLEGAL DIRECT"^
c2c8 54 59 50 ERR_16 .byte   "TYPE MISMATCH"^
c2d5 53 54 52 ERR_17 .byte   "STRING TOO LONG"^
c2e4 46 49 4c ERR_18 .byte   "FILE DATA"^
c2ed 46 4f 52 ERR_19 .byte   "FORMULA TOO COMPLEX"^
c300 43 41 4e ERR_1A .byte   "CAN'T CONTINUE"^
c30e 55 4e 44 ERR_1B .byte   "UNDEF'D FUNCTION"^
c31e 56 45 52 ERR_1C .byte   "VERIFY"^
c324 4c 4f 41 ERR_1D .byte   "LOAD"^

              ; error message pointer table

c328          Basic_Msg_Tab
c328 9e c1       .word   ERR_01  ; TOO MANY FILES
c32a ac c1       .word   ERR_02  ; FILE OPEN
c32c b5 c1       .word   ERR_03  ; FILE NOT OPEN
c32e c2 c1       .word   ERR_04  ; FILE NOT FOUND
c330 d0 c1       .word   ERR_05  ; DEVICE NOT PRESENT
c332 e2 c1       .word   ERR_06  ; NOT INPUT FILE
c334 f0 c1       .word   ERR_07  ; NOT OUTPUT FILE
c336 ff c1       .word   ERR_08  ; MISSING FILE NAME
c338 10 c2       .word   ERR_09  ; ILLEGAL DEVICE NUMBER
c33a 25 c2       .word   ERR_0A  ; NEXT WITHOUT FOR
c33c 35 c2       .word   ERR_0B  ; SYNTAX
c33e 3b c2       .word   ERR_0C  ; RETURN WITHOUT GOSUB
c340 4f c2       .word   ERR_0D  ; OUT OF DATA
c342 5a c2       .word   ERR_0E  ; ILLEGAL QUANTITY
c344 6a c2       .word   ERR_0F  ; OVERFLOW
c346 72 c2       .word   ERR_10  ; OUT OF MEMORY
c348 7f c2       .word   ERR_11  ; UNDEF'D STATEMENT
c34a 90 c2       .word   ERR_12  ; BAD SUBSCRIPT
c34c 9d c2       .word   ERR_13  ; REDIM'D ARRAY
c34e aa c2       .word   ERR_14  ; DIVISION BY ZERO
c350 ba c2       .word   ERR_15  ; ILLEGAL DIRECT
c352 c8 c2       .word   ERR_16  ; TYPE MISMATCH
c354 d5 c2       .word   ERR_17  ; STRING TOO LONG
c356 e4 c2       .word   ERR_18  ; FILE DATA
c358 ed c2       .word   ERR_19  ; FORMULA TOO COMPLEX
c35a 00 c3       .word   ERR_1A  ; CAN'T CONTINUE
c35c 0e c3       .word   ERR_1B  ; UNDEF'D FUNCTION
c35e 1e c3       .word   ERR_1C  ; VERIFY
c360 24 c3       .word   ERR_1D  ; LOAD
c362 83 c3       .word   Msg_Break

              ; BASIC messages

c364 0d 4f 4b Msg_OK    .byte   "\rOK\r",0
0001 FALSE    #if C64
SKIP          Msg_Err   .byte   "  ERROR",0
              #endif
0000 TRUE     #if VIC
c369 0d 20 45 Msg_Err   .byte   "\r ERROR",0
              #endif
c371 20 49 4e Msg_IN    .byte   " IN ",0
c376 0d 0a 52 Msg_Ready .byte   "\r\nREADY.\r\n",0
c381 0d 0a    Msg_CrLf  .byte   "\r\n"
c383 42 52 45 Msg_Break .byte   "BREAK",0

c389 a0          .byte $A0 ; unused

              ; ***************
c38a            Find_Active_FOR
              ; ***************

c38a ba          TSX               ; copy stack pointer
c38b e8          INX               ; +1 pass return address
c38c e8          INX               ; +2 pass return address
c38d e8          INX               ; +3 pass calling routine return address
c38e e8          INX               ; +4 pass calling routine return address

c38f          FAF_Loop
c38f bd 01 01    LDA STACK+1,X     ; get token byte from stack
c392 c9 81       CMP #TK_FOR       ; is it FOR token
c394 d0 21       BNE FAF_Ret       ; exit if not FOR token
c396 a5 4a       LDA FORPNT+1      ; get FOR/NEXT variable pointer high byte
c398 d0 0a       BNE FAF_10        ; branch if defined
c39a bd 02 01    LDA STACK+2,X     ; get FOR variable pointer low byte
c39d 85 49       STA FORPNT        ; save FOR/NEXT variable pointer low byte
c39f bd 03 01    LDA STACK+3,X     ; get FOR variable pointer high byte
c3a2 85 4a       STA FORPNT+1      ; save FOR/NEXT variable pointer high byte

c3a4          FAF_10
c3a4 dd 03 01    CMP STACK+3,X     ; compare variable pointer with stacked variable pointer
c3a7 d0 07       BNE FAF_20        ; branch if no match
c3a9 a5 49       LDA FORPNT        ; get FOR/NEXT variable pointer low byte
c3ab dd 02 01    CMP STACK+2,X     ; compare variable pointer with stacked variable pointer
c3ae f0 07       BEQ FAF_Ret       ; exit if match found

c3b0          FAF_20
c3b0 8a          TXA               ; copy index
c3b1 18          CLC
c3b2 69 12       ADC #18           ; add FOR stack use size
c3b4 aa          TAX               ; copy back to index
c3b5 d0 d8       BNE FAF_Loop

c3b7          FAF_Ret
c3b7 60          RTS ;Size   46 [Find_Active_FOR]

              ; *************
c3b8            Open_Up_Space
              ; *************

c3b8 20 08 c4    JSR Check_Mem_Avail
                 STAY(STREND)
c3bb 85 31       STA STREND
c3bd 84 32       STY STREND+1


              ; **********
c3bf            Move_Block
              ; **********

c3bf 38          SEC
c3c0 a5 5a       LDA TMPPTB        ; get block end low byte
c3c2 e5 5f       SBC TMPPTC        ; subtract block start low byte
c3c4 85 22       STA INDEXA        ; save MOD(block length/$100) byte
c3c6 a8          TAY               ; copy MOD(block length/$100) byte to Y
c3c7 a5 5b       LDA TMPPTB+1      ; get block end high byte
c3c9 e5 60       SBC TMPPTC+1      ; subtract block start high byte
c3cb aa          TAX               ; copy block length high byte to X
c3cc e8          INX               ; +1 to allow for count=0 exit
c3cd 98          TYA               ; copy block length low byte to A
c3ce f0 23       BEQ MoBl_20       ; branch if length low byte=0
c3d0 a5 5a       LDA TMPPTB        ; get block end low byte
c3d2 38          SEC
c3d3 e5 22       SBC INDEXA        ; subtract MOD(block length/$100) byte
c3d5 85 5a       STA TMPPTB        ; save corrected old block end low byte
c3d7 b0 03       BCS MoBl_10       ; if no underflow skip the high byte decrement
c3d9 c6 5b       DEC TMPPTB+1      ; else decrement block end high byte
c3db 38          SEC

c3dc          MoBl_10 
c3dc a5 58       LDA TMPPTA        ; get destination end low byte
c3de e5 22       SBC INDEXA        ; subtract MOD(block length/$100) byte
c3e0 85 58       STA TMPPTA        ; save modified new block end low byte
c3e2 b0 08       BCS MoBl_Loop_X   ; if no underflow skip the high byte decrement
c3e4 c6 59       DEC TMPPTA+1      ; else decrement block end high byte
c3e6 90 04       BCC MoBl_Loop_X   ; branch always

c3e8          MoBl_Loop_Y
c3e8 b1 5a       LDA (TMPPTB),Y    ; get byte from source
c3ea 91 58       STA (TMPPTA),Y    ; copy byte to destination

c3ec          MoBl_Loop_X
c3ec 88          DEY
c3ed d0 f9       BNE MoBl_Loop_Y
c3ef b1 5a       LDA (TMPPTB),Y    ; get byte from source
c3f1 91 58       STA (TMPPTA),Y    ; save byte to destination

c3f3          MoBl_20
c3f3 c6 5b       DEC TMPPTB+1      ; decrement source pointer high byte
c3f5 c6 59       DEC TMPPTA+1      ; decrement destination pointer high byte
c3f7 ca          DEX               ; decrement block count
c3f8 d0 f2       BNE MoBl_Loop_X   ; loop until count = $0
c3fa 60          RTS ;Size   60 [Move_Block]

              ; *****************
c3fb            Check_Stack_Avail
              ; *****************

c3fb 0a          ASL A
c3fc 69 3e       ADC #$3E          ; need at least $3E bytes free
c3fe b0 35       BCS Error_Out_Of_Memory
c400 85 22       STA INDEXA        ; save result in temp byte
c402 ba          TSX               ; copy stack
c403 e4 22       CPX INDEXA        ; compare new limit with stack
c405 90 2e       BCC Error_Out_Of_Memory
c407 60          RTS ;Size   13 [Check_Stack_Avail]

              ; ***************
c408            Check_Mem_Avail
              ; ***************

c408 c4 34       CPY FRESPC+1      ; compare with bottom of string space high byte
c40a 90 28       BCC CMA_Ret       ; if less then OK
c40c d0 04       BNE CMA_10        ; skip next test if greater (tested <)
c40e c5 33       CMP FRESPC        ; compare with bottom of string space low byte
c410 90 22       BCC CMA_Ret       ; if less then OK

c412          CMA_10               ; address is > string storage ptr
c412 48          PHA               ; push address low byte
c413 a2 09       LDX #9            ; set index to save 10 bytes (FACTPA & FACTPB)
c415 98          TYA               ; copy address high byte (to push on stack)

c416          CMA_Loop_X
c416 48          PHA               ; push byte
c417 b5 57       LDA FACTPA,X      ; get byte from FACTPA to TMPPTC+1
c419 ca          DEX
c41a 10 fa       BPL CMA_Loop_X
c41c 20 26 d5    JSR Garbage_Collection
c41f a2 f7       LDX #$F7          ; use zero page wrap around

c421          CMA_Loop_2
c421 68          PLA               ; pop byte
c422 95 61       STA FAC1EX,X      ; save byte from FACTPA to FAC1
c424 e8          INX               ; increment index
c425 30 fa       BMI CMA_Loop_2
c427 68          PLA               ; pop address high byte
c428 a8          TAY               ; copy back to Y
c429 68          PLA               ; pop address low byte
c42a c4 34       CPY FRESPC+1      ; compare with bottom of string space high byte
c42c 90 06       BCC CMA_Ret       ; if less then OK
c42e d0 05       BNE Error_Out_Of_Memory
c430 c5 33       CMP FRESPC
c432 b0 01       BCS Error_Out_Of_Memory

c434          CMA_Ret
c434 60          RTS ;Size   45 [Check_Mem_Avail]

              ; ===================
c435            Error_Out_Of_Memory
              ; ===================

c435 a2 10       LDX #$10          ; error code $10, out of memory error

              ; ===========
c437            Basic_Error
              ; ===========

c437 6c 00 03    JMP (IERROR)      ; normally next statement

              ; =============
c43a            Default_Error
              ; =============

c43a 8a          TXA               ; copy error number
c43b 0a          ASL A             ; *2
c43c aa          TAX               ; copy to index
c43d bd 26 c3    LDA Basic_Msg_Tab-2,X  ; get error message pointer low byte
c440 85 22       STA INDEXA        ; save it
c442 bd 27 c3    LDA Basic_Msg_Tab-1,X  ; get error message pointer high byte
c445 85 23       STA INDEXA+1      ; save it
c447 20 cc ff    JSR CLRCHN        ; Clear I/O channels
c44a a9 00       LDA #0
c44c 85 13       STA IOPMPT        ; clear current I/O channel, flag default
c44e 20 d7 ca    JSR Print_CR
c451 20 45 cb    JSR Print_Question_Mark
c454 a0 00       LDY #0

c456          DeEr_Loop
c456 b1 22       LDA (INDEXA),Y    ; get byte from message
c458 48          PHA               ; save status
c459 29 7f       AND #$7F          ; mask 0xxx xxxx, clear b7
c45b 20 47 cb    JSR Print_Char
c45e c8          INY
c45f 68          PLA               ; restore status
c460 10 f4       BPL DeEr_Loop
c462 20 7a c6    JSR Flush_BASIC_Stack
                 LAYI(Msg_Err)
c465 a9 69       LDA #<Msg_Err
c467 a0 c3       LDY #>Msg_Err


              ; ======================
c469            Display_Msg_Then_Ready
              ; ======================

c469 20 1e cb    JSR Print_String
c46c a4 3a       LDY CURLIN+1      ; get current line number high byte
c46e c8          INY               ; increment it
c46f f0 03       BEQ Basic_Ready   ; CURLIN+1 was $FF = direct mode
c471 20 c2 dd    JSR Print_IN

              ; ===========
c474            Basic_Ready
              ; ===========

                 Print_Msg(Msg_Ready)
c474 a9 76       LDA #<Msg_Ready
c476 a0 c3       LDY #>Msg_Ready
c478 20 1e cb    JSR Print_String

c47b a9 80       LDA #$80          ; set for control messages only
c47d 20 90 ff    JSR SETMSG        ; control kernal messages

              ; ==================
c480            Vectored_Warmstart
              ; ==================

c480 6c 02 03    JMP (IMAIN)       ; normally next statement

              ; =================
c483            Default_Warmstart
              ; =================

c483 20 60 c5    JSR Read_String
                 STXY(TXTPTR)
c486 86 7a       STX TXTPTR
c488 84 7b       STY TXTPTR+1

c48a 20 73 00    JSR CHRGET
c48d aa          TAX               ; copy byte to set flags
c48e f0 f0       BEQ Vectored_Warmstart ; loop if no input

              ; got to interpret input line now ....

c490 a2 ff       LDX #-1           ; indicates direct mode
c492 86 3a       STX CURLIN+1
c494 90 06       BCC New_Basic_Line

c496          Direct_Call          ; used from Jiffy to identify caller
c496 20 79 c5    JSR Tokenize_Line
c499 4c e1 c7    JMP Start_Program

              ; --------------
c49c            New_Basic_Line
              ; --------------

c49c 20 6b c9    JSR Scan_Linenumber
c49f 20 79 c5    JSR Tokenize_Line
c4a2 84 0b       STY COUNT         ; save index pointer to end of crunched line
c4a4 20 13 c6    JSR Find_BASIC_Line
c4a7 90 44       BCC NBL_20        ; if not found skip the line delete

              ; line # already exists so delete it

c4a9 a0 01       LDY #1            ; set index to next line pointer high byte
c4ab b1 5f       LDA (TMPPTC),Y    ; get next line pointer high byte
c4ad 85 23       STA INDEXA+1      ; save it
c4af a5 2d       LDA VARTAB        ; get start of variables low byte
c4b1 85 22       STA INDEXA        ; save it
c4b3 a5 60       LDA TMPPTC+1      ; get found line pointer high byte
c4b5 85 25       STA INDEXB+1      ; save it
c4b7 a5 5f       LDA TMPPTC        ; get found line pointer low byte
c4b9 88          DEY               ; decrement index
c4ba f1 5f       SBC (TMPPTC),Y    ; subtract next line pointer low byte
c4bc 18          CLC
c4bd 65 2d       ADC VARTAB        ; add start of variables low byte
c4bf 85 2d       STA VARTAB        ; set start of variables low byte
c4c1 85 24       STA INDEXB        ; save destination pointer low byte
c4c3 a5 2e       LDA VARTAB+1      ; get start of variables high byte
c4c5 69 ff       ADC #$FF          ; -1 + carry
c4c7 85 2e       STA VARTAB+1      ; set start of variables high byte
c4c9 e5 60       SBC TMPPTC+1      ; subtract found line pointer high byte
c4cb aa          TAX               ; copy to block count
c4cc 38          SEC
c4cd a5 5f       LDA TMPPTC        ; get found line pointer low byte
c4cf e5 2d       SBC VARTAB        ; subtract start of variables low byte
c4d1 a8          TAY               ; copy to bytes in first block count
c4d2 b0 03       BCS NBL_10        ; if no underflow skip the high byte decrement
c4d4 e8          INX               ; increment block count, correct for = 0 loop exit
c4d5 c6 25       DEC INDEXB+1      ; decrement destination high byte

c4d7          NBL_10
c4d7 18          CLC
c4d8 65 22       ADC INDEXA        ; add source pointer low byte
c4da 90 03       BCC NBL_Loop      ; if no underflow skip the high byte decrement
c4dc c6 23       DEC INDEXA+1      ; else decrement source pointer high byte
c4de 18          CLC

c4df          NBL_Loop
c4df b1 22       LDA (INDEXA),Y    ; get byte from source
c4e1 91 24       STA (INDEXB),Y    ; copy to destination
c4e3 c8          INY
c4e4 d0 f9       BNE NBL_Loop      ; while <> 0 do this block
c4e6 e6 23       INC INDEXA+1      ; increment source pointer high byte
c4e8 e6 25       INC INDEXB+1      ; increment destination pointer high byte
c4ea ca          DEX               ; decrement block count
c4eb d0 f2       BNE NBL_Loop      ; loop until all done

c4ed          NBL_20
c4ed 20 59 c6    JSR Reset_BASIC_Execution
c4f0 20 33 c5    JSR Rechain
c4f3 ad 00 02    LDA BUF           ; get first byte from buffer
c4f6 f0 88       BEQ Vectored_Warmstart
c4f8 18          CLC               ; insert line into memory
c4f9 a5 2d       LDA VARTAB        ; get start of variables low byte
c4fb 85 5a       STA TMPPTB        ; save as source end pointer low byte
c4fd 65 0b       ADC COUNT         ; add index pointer to end of crunched line
c4ff 85 58       STA TMPPTA        ; save as destination end pointer low byte
c501 a4 2e       LDY VARTAB+1      ; get start of variables high byte
c503 84 5b       STY TMPPTB+1      ; save as source end pointer high byte
c505 90 01       BCC NBL_30      ; if no carry skip the high byte increment
c507 c8          INY               ; else increment the high byte
c508          NBL_30
c508 84 59       STY TMPPTA+1      ; save as destination end pointer high byte
c50a 20 b8 c3    JSR Open_Up_Space

              ; most of what remains to do is copy the crunched line into the space opened up in memory,
              ; however, before the crunched line comes the next line pointer and the line number. the
              ; line number is retrieved from the temporary integer and stored in memory, this
              ; overwrites the bottom two bytes on the stack. next the line is copied and the next line
              ; pointer is filled with whatever was in two bytes above the line number in the stack.
              ; this is ok because the line pointer gets fixed in the line chain re-build.

                 LDAY(LINNUM)      ; get line number
c50d a5 14       LDA LINNUM
c50f a4 15       LDY LINNUM+1

c511 8d fe 01    STA BUF-2         ; save line number low byte before crunched line
c514 8c ff 01    STY BUF-1         ; save line number high byte before crunched line
                 LDAY(STREND)      ; get end of arrays
c517 a5 31       LDA STREND
c519 a4 32       LDY STREND+1

                 STAY(VARTAB)      ; set start of variables
c51b 85 2d       STA VARTAB
c51d 84 2e       STY VARTAB+1

c51f a4 0b       LDY COUNT         ; get index to end of crunched line
c521 88          DEY               ; -1
c522          NBL_Copy
c522 b9 fc 01    LDA BUF-4,Y       ; get byte from crunched line
c525 91 5f       STA (TMPPTC),Y    ; save byte to memory
c527 88          DEY               ; decrement index
c528 10 f8       BPL NBL_Copy      ; loop while more to do

              ; =================
c52a            Reset_And_Rechain
              ; =================

c52a 20 59 c6    JSR Reset_BASIC_Execution
c52d 20 33 c5    JSR Rechain
c530 4c 80 c4    JMP Vectored_Warmstart

              ; *******
c533            Rechain
              ; *******

                 LDAY(TXTTAB)      ; get start of memory
c533 a5 2b       LDA TXTTAB
c535 a4 2c       LDY TXTTAB+1

                 STAY(INDEXA)      ; set line start pointer
c537 85 22       STA INDEXA
c539 84 23       STY INDEXA+1

c53b 18          CLC

c53c          Rech_Loop
c53c a0 01       LDY #1            ; set index to pointer to next line high byte
c53e b1 22       LDA (INDEXA),Y    ; get pointer to next line high byte
c540 f0 1d       BEQ Rech_Ret      ; exit if null, [EOT]
c542 a0 04       LDY #4            ; point to first code byte of line
                                   ; there is always 1 byte + [EOL] as null entries are deleted
c544          Rech_Loop_2
c544 c8          INY               ; next code byte
c545 b1 22       LDA (INDEXA),Y    ; get byte
c547 d0 fb       BNE Rech_Loop_2   ; loop if not [EOL]
c549 c8          INY               ; point to byte past [EOL], start of next line
c54a 98          TYA               ; copy it
c54b 65 22       ADC INDEXA        ; add line start pointer low byte
c54d aa          TAX               ; copy to X
c54e a0 00       LDY #0            ; point to this line's next line pointer
c550 91 22       STA (INDEXA),Y    ; set next line pointer low byte
c552 a5 23       LDA INDEXA+1      ; get line start pointer high byte
c554 69 00       ADC #$00          ; add any overflow
c556 c8          INY
c557 91 22       STA (INDEXA),Y    ; set next line pointer high byte
c559 86 22       STX INDEXA        ; set line start pointer low byte
c55b 85 23       STA INDEXA+1      ; set line start pointer high byte
c55d 90 dd       BCC Rech_Loop     ; branch always

c55f          Rech_Ret
c55f 60          RTS ;Size   45 [Rechain]

              ; ***********
c560            Read_String
              ; ***********

c560 a2 00       LDX #0            ; set channel 0, keyboard

c562          ReSt_Loop
c562 20 0f e1    JSR Read_Char
c565 c9 0d       CMP #CR
c567 f0 0d       BEQ ReSt_Finish
c569 9d 00 02    STA BUF,X
c56c e8          INX
c56d e0 59       CPX #$59          ; compare with max+1
c56f 90 f1       BCC ReSt_Loop
c571 a2 17       LDX #$17          ; error $17, string too long error
c573 4c 37 c4    JMP Basic_Error

c576          ReSt_Finish
c576 4c ca ca    JMP Terminate_BUF      ; set XY to BUF - 1 and print [CR]

              ; *************
c579            Tokenize_Line
              ; *************

c579 6c 04 03    JMP (ICRNCH)      ; normally next statement

              ; ****************
c57c            Default_Tokenize
              ; ****************

c57c a6 7a       LDX TXTPTR        ; get BASIC execute pointer low byte
c57e a0 04       LDY #4 
c580 84 0f       STY GARBFL        ; clear open quote/DATA flag

c582          Toke_Loop
c582 bd 00 02    LDA BUF,X
c585 10 07       BPL Toke_05       ; plain text
c587 c9 ff       CMP #TK_PI
c589 f0 3e       BEQ Toke_35       ; if PI save & continue
c58b e8          INX               ; next char
c58c d0 f4       BNE Toke_Loop     ; branch always

c58e          Toke_05
c58e c9 20       CMP #' '
c590 f0 37       BEQ Toke_35       ; if [SPACE] save & continue
c592 85 08       STA ENDCHR        ; save buffer byte as search character
c594 c9 22       CMP #QUOTE
c596 f0 56       BEQ Toke_55       ; if quote go copy quoted string
c598 24 0f       BIT GARBFL        ; get open quote/DATA token flag
c59a 70 2d       BVS Toke_35       ; branch if b6 of Oquote set, was DATA
c59c c9 3f       CMP #'?'          ; compare with '?' character
c59e d0 04       BNE Toke_10       ; if not "?" continue crunching
c5a0 a9 99       LDA #TK_PRINT     ; replace '?' by the token for PRINT
c5a2 d0 25       BNE Toke_35       ; branch always

c5a4          Toke_10
c5a4 c9 30       CMP #'0'          ; compare with "0"
c5a6 90 04       BCC Toke_15       ; if < "0" continue crunching
c5a8 c9 3c       CMP #'<'          ; compare with "<"
c5aa 90 1d       BCC Toke_35       ; if <, 0123456789:; save & continue

c5ac          Toke_15
c5ac 84 71       STY TMPPTD        ; copy save index
c5ae a0 00       LDY #0            ; clear table pointer
c5b0 84 0b       STY COUNT         ; clear word index
c5b2 88          DEY               ; Y = $FF
c5b3 86 7a       STX TXTPTR        ; save BASIC execute pointer low byte, buffer index
c5b5 ca          DEX               ; adjust for pre increment loop

c5b6          Toke_20
c5b6 c8          INY               ; next table byte
c5b7 e8          INX               ; next buffer byte

c5b8          Toke_25
c5b8 bd 00 02    LDA BUF,X         ; get byte from input buffer
c5bb 38          SEC
c5bc f9 9e c0    SBC Basic_Keyword_Table,Y
c5bf f0 f5       BEQ Toke_20       ; match so far
c5c1 c9 80       CMP #$80          ; was it end marker match ?
c5c3 d0 30       BNE Toke_60       ; if not go try the next keyword
c5c5 05 0b       ORA COUNT         ; OR with word index, +$80 in A makes token

c5c7          Toke_30
c5c7 a4 71       LDY TMPPTD        ; restore save index

c5c9          Toke_35
c5c9 e8          INX               ; increment buffer read index
c5ca c8          INY               ; increment save index
c5cb 99 fb 01    STA BUF-5,Y       ; save byte to output
c5ce b9 fb 01    LDA BUF-5,Y       ; get byte from output, set flags
c5d1 f0 36       BEQ Toke_70       ; branch if was null [EOL]
c5d3 38          SEC
c5d4 e9 3a       SBC #':'          ; subtract ":"
c5d6 f0 04       BEQ Toke_40       ; branch if it was (A is now 0)
c5d8 c9 49       CMP #TK_DATA-':'  ; compare with the token for DATA-':'
c5da d0 02       BNE Toke_45       ; if not DATA go try REM

c5dc          Toke_40
c5dc 85 0f       STA GARBFL        ; save token-':'

c5de          Toke_45
c5de 38          SEC
c5df e9 55       SBC #TK_REM-':'   ; subtract the token for REM-':'
c5e1 d0 9f       BNE Toke_Loop     ; if wasn't REM go crunch next bit of line

c5e3          Toke_REM             ; target from Jiffy tokenizer
c5e3 85 08       STA ENDCHR        ; else was REM so set search for [EOL]

c5e5          Toke_50
c5e5 bd 00 02    LDA BUF,X         ; get byte from input buffer
c5e8 f0 df       BEQ Toke_35       ; if null [EOL] save byte then continue crunching
c5ea c5 08       CMP ENDCHR        ; compare with stored character
c5ec f0 db       BEQ Toke_35       ; if match save byte then continue crunching

c5ee          Toke_55
c5ee c8          INY               ; increment save index
c5ef 99 fb 01    STA BUF-5,Y       ; save byte to output
c5f2 e8          INX               ; increment buffer index
c5f3 d0 f0       BNE Toke_50       ; branch always

c5f5          Toke_60
c5f5 a6 7a       LDX TXTPTR        ; restore BASIC execute pointer low byte
c5f7 e6 0b       INC COUNT         ; increment word index (next word)

c5f9          Toke_65
c5f9 c8          INY               ; increment table index
c5fa b9 9d c0    LDA Basic_Keyword_Table-1,Y; get table byte
c5fd 10 fa       BPL Toke_65       ; loop if not end of word yet
c5ff b9 9e c0    LDA Basic_Keyword_Table,Y  ; get byte from keyword table
c602 d0 b4       BNE Toke_25       ; go test next word if not zero byte, end of table
c604 bd 00 02    LDA BUF,X         ; restore byte from input buffer
c607 10 be       BPL Toke_30       ; branch always, all unmatched bytes in the buffer are

c609          Toke_70
c609 99 fd 01    STA BUF-3,Y       ; save [EOL]
c60c c6 7b       DEC TXTPTR+1      ; decrement BASIC execute pointer high byte
c60e a9 ff       LDA #$FF          ; point to start of buffer-1
c610 85 7a       STA TXTPTR        ; set BASIC execute pointer low byte
c612 60          RTS ;Size  151 [Default_Tokenize]

              ; ***************
c613            Find_BASIC_Line
              ; ***************

                 LDAX(TXTTAB)      ; get start of memory
c613 a5 2b       LDA TXTTAB
c615 a6 2c       LDX TXTTAB+1


              ; ******************
c617            Find_BASIC_Line_AX
              ; ******************

c617 a0 01       LDY #1            ; set Y to next line link high byte
                 STAX(TMPPTC)      ; save as current
c619 85 5f       STA TMPPTC
c61b 86 60       STX TMPPTC+1

c61d b1 5f       LDA (TMPPTC),Y    ; get line link high byte
c61f f0 1f       BEQ FiBL_Not_Found; 0 = end of program
c621 c8          INY               ; Y = 2
c622 c8          INY               ; Y = 3
c623 a5 15       LDA LINNUM+1      ; target line # high byte
c625 d1 5f       CMP (TMPPTC),Y    ; compare with line # high byte
c627 90 18       BCC FiBL_Ret      ; beyond target line
c629 f0 03       BEQ FiBL_Check    ; go check low byte if =
c62b 88          DEY               ; Y = 2
c62c d0 09       BNE FiBL_Cont     ; branch always

c62e          FiBL_Check
c62e a5 14       LDA LINNUM        ; get target line # low byte
c630 88          DEY               ; Y = 2
c631 d1 5f       CMP (TMPPTC),Y    ; compare with line # low byte
c633 90 0c       BCC FiBL_Ret      ; beyond target line
c635 f0 0a       BEQ FiBL_Ret      ; target line found: exit

c637          FiBL_Cont
c637 88          DEY               ; Y = 1
c638 b1 5f       LDA (TMPPTC),Y    ; get next line link high byte
c63a aa          TAX               ; copy to X
c63b 88          DEY               ; Y = 0
c63c b1 5f       LDA (TMPPTC),Y    ; get next line link low byte
c63e b0 d7       BCS Find_BASIC_Line_AX ; branch always

c640          FiBL_Not_Found
c640 18          CLC               ; clear found flag
c641          FiBL_Ret
c641 60          RTS ;Size   43 [Find_BASIC_Line_AX]

              ; *********
c642            Basic_NEW
              ; *********

c642 d0 fd       BNE FiBL_Ret      ; exit if following byte to allow syntax error

              ; ===========
c644            Perform_NEW
              ; ===========

c644 a9 00       LDA #0
c646 a8          TAY               ; clear index
c647 91 2b       STA (TXTTAB),Y    ; clear pointer to next line low byte
c649 c8          INY
c64a 91 2b       STA (TXTTAB),Y    ; clear pointer to next line high byte, erase program
c64c a5 2b       LDA TXTTAB        ; get start of memory low byte
c64e 18          CLC
c64f 69 02       ADC #2            ; add null program length
c651 85 2d       STA VARTAB        ; set start of variables low byte
c653 a5 2c       LDA TXTTAB+1      ; get start of memory high byte
c655 69 00       ADC #0            ; add carry
c657 85 2e       STA VARTAB+1      ; set start of variables high byte

              ; *********************
c659            Reset_BASIC_Execution
              ; *********************

c659 20 8e c6    JSR Reset_BASIC_Exec_Pointer
c65c a9 00       LDA #$00          ; set Zb for CLR entry

              ; *********
c65e            Basic_CLR
              ; *********

c65e d0 2d       BNE Flush_Ret      ; exit if following byte to allow syntax error

              ; ********************
c660            Clear_Variable_Space
              ; ********************

c660 20 e7 ff    JSR CLALL         ; close all channels and files

              ; ======================
c663            Reset_Variable_Pointer
              ; ======================

                 LDAY(MEMSIZ)
c663 a5 37       LDA MEMSIZ
c665 a4 38       LDY MEMSIZ+1

                 STAY(FRESPC)
c667 85 33       STA FRESPC
c669 84 34       STY FRESPC+1

                 LDAY(VARTAB)
c66b a5 2d       LDA VARTAB
c66d a4 2e       LDY VARTAB+1

                 STAY(ARYTAB)
c66f 85 2f       STA ARYTAB
c671 84 30       STY ARYTAB+1

                 STAY(STREND)
c673 85 31       STA STREND
c675 84 32       STY STREND+1


              ; =======================
c677            Restore_And_Flush_Stack
              ; =======================

c677 20 1d c8    JSR Basic_RESTORE ; perform RESTORE

              ; *****************
c67a            Flush_BASIC_Stack
              ; *****************

c67a a2 19       LDX #TEMPST       ; get descriptor stack start
c67c 86 16       STX TEMPPT        ; set descriptor stack pointer
c67e 68          PLA               ; pull return address low byte
c67f a8          TAY               ; copy it
c680 68          PLA               ; pull return address high byte
c681 a2 fa       LDX #$FA          ; set cleared stack pointer
c683 9a          TXS               ; set stack
c684 48          PHA               ; push return address high byte
c685 98          TYA               ; restore return address low byte
c686 48          PHA               ; push return address low byte
c687 a9 00       LDA #0
c689 85 3e       STA OLDTXT+1      ; clear continue pointer high byte
c68b 85 10       STA SUBFLG        ; clear subscript/FNX flag

c68d          Flush_Ret
c68d 60          RTS ;Size   20 [Flush_BASIC_Stack]

              ; ************************
c68e            Reset_BASIC_Exec_Pointer
              ; ************************

c68e 18          CLC
c68f a5 2b       LDA TXTTAB        ; get start of memory low byte
c691 69 ff       ADC #$FF          ; add -1 low byte
c693 85 7a       STA TXTPTR        ; set BASIC execute pointer low byte
c695 a5 2c       LDA TXTTAB+1      ; get start of memory high byte
c697 69 ff       ADC #$FF          ; add -1 high byte
c699 85 7b       STA TXTPTR+1      ; save BASIC execute pointer high byte
c69b 60          RTS ;Size   14 [Reset_BASIC_Exec_Pointer]

              ; **********
c69c            Basic_LIST
              ; **********

c69c 90 06       BCC LIST_05       ; branch if next character not token (LIST n...)
c69e f0 04       BEQ LIST_05       ; branch if next character [NULL] (LIST)
c6a0 c9 ab       CMP #TK_MINUS     ; the only token allowed here (LIST -m)
c6a2 d0 e9       BNE Flush_Ret

c6a4          LIST_05
c6a4 20 6b c9    JSR Scan_Linenumber
c6a7 20 13 c6    JSR Find_BASIC_Line
c6aa 20 79 00    JSR CHRGOT
c6ad f0 0c       BEQ LIST_10       ; branch if no more chrs
c6af c9 ab       CMP #TK_MINUS     ; compare with "-"
c6b1 d0 8e       BNE FiBL_Ret      ; return if not "-" (will be SN error)
c6b3 20 73 00    JSR CHRGET        ; LIST [n]-m
c6b6 20 6b c9    JSR Scan_Linenumber
c6b9 d0 86       BNE FiBL_Ret      ; exit if not ok

c6bb          LIST_10
c6bb 68          PLA               ; dump return address low byte, exit via warm start
c6bc 68          PLA               ; dump return address high byte
c6bd a5 14       LDA LINNUM        ; get temporary integer low byte
c6bf 05 15       ORA LINNUM+1      ; OR temporary integer high byte
c6c1 d0 06       BNE LIST_15       ; branch if start set

c6c3          LIST_12              ; entry for Jiffy Basic file list
c6c3 a9 ff       LDA #$FF          ; set last line to $FFFF if not specified
c6c5 85 14       STA LINNUM
c6c7 85 15       STA LINNUM+1

c6c9          LIST_15
c6c9 a0 01       LDY #1
c6cb 84 0f       STY GARBFL        ; clear open quote flag
c6cd b1 5f       LDA (TMPPTC),Y    ; get next line pointer high byte
c6cf f0 43       BEQ LIST_45       ; if null all done so exit
c6d1 20 2c c8    JSR Check_STOP

c6d4          LIST_17              ; entry for Jiffy Basic file list
c6d4 20 d7 ca    JSR Print_CR
c6d7 c8          INY
c6d8 b1 5f       LDA (TMPPTC),Y    ; get line number low byte
c6da aa          TAX
c6db c8          INY
c6dc b1 5f       LDA (TMPPTC),Y    ; get line number high byte
c6de c5 15       CMP LINNUM+1      ; compare with temporary integer high byte
c6e0 d0 04       BNE LIST_20       ; branch if no high byte match
c6e2 e4 14       CPX LINNUM        ; compare with temporary integer low byte
c6e4 f0 02       BEQ LIST_25       ; branch if = last line to do, < will pass next branch

c6e6          LIST_20              ; else ...
c6e6 b0 2c       BCS LIST_45       ; if greater all done so exit

c6e8          LIST_25
c6e8 84 49       STY FORPNT        ; save index for line
c6ea 20 cd dd    JSR Print_Integer_XA
c6ed a9 20       LDA #' '          ; print [SPACE] after line #

c6ef          LIST_30
c6ef a4 49       LDY FORPNT        ; get index for line
c6f1 29 7f       AND #$7F          ; mask top out bit of character

c6f3          LIST_35
c6f3 20 47 cb    JSR Print_Char
c6f6 c9 22       CMP #QUOTE
c6f8 d0 06       BNE LIST_40       ; if not skip the quote handle
c6fa a5 0f       LDA GARBFL        ; get open quote flag
c6fc 49 ff       EOR #$FF          ; toggle it
c6fe 85 0f       STA GARBFL        ; save it back

c700          LIST_40
c700 c8          INY
c701 f0 11       BEQ LIST_45       ; line too long so just bail out and do a warm start
c703 b1 5f       LDA (TMPPTC),Y    ; get next byte
c705 d0 10       BNE Vectored_Detokenize      ; if not [EOL] (go print character)
c707 a8          TAY               ; else clear index
c708 b1 5f       LDA (TMPPTC),Y    ; get next line pointer low byte
c70a aa          TAX               ; copy to X
c70b c8          INY
c70c b1 5f       LDA (TMPPTC),Y    ; get next line pointer high byte
c70e 86 5f       STX TMPPTC        ; set pointer to line low byte
c710 85 60       STA TMPPTC+1      ; set pointer to line high byte
c712 d0 b5       BNE LIST_15       ; go do next line if not [EOT]

c714          LIST_45

0001 FALSE    #if C64
SKIP             JMP Vectored_Basic_Ready
              #endif

0000 TRUE     #if VIC
c714 4c 74 c4    JMP Basic_Ready
              #endif

              ; *******************
c717            Vectored_Detokenize
              ; *******************

c717 6c 06 03    JMP (IQPLOP)      ; normally next statement

              ; ******************
c71a            Default_Detokenize
              ; ******************

c71a 10 d7       BPL LIST_35       ; print it if not token byte
c71c c9 ff       CMP #TK_PI        ; compare with the token for PI
c71e f0 d3       BEQ LIST_35       ; just print it if so
c720 24 0f       BIT GARBFL        ; test the open quote flag
c722 30 cf       BMI LIST_35       ; just go print character if open quote set
c724 38          SEC               ; else set carry for subtract
c725 e9 7f       SBC #$7F          ; convert token to inex
c727 aa          TAX               ; copy token # to X
c728 84 49       STY FORPNT        ; save Y
c72a a0 ff       LDY #$FF          ; start from -1, adjust for pre increment

c72c          DeTo_10
c72c ca          DEX               ; decrement token #
c72d f0 08       BEQ DeTo_30       ; if not found go do printing

c72f          DeTo_20
c72f c8          INY
c730 b9 9e c0    LDA Basic_Keyword_Table,Y
c733 10 fa       BPL DeTo_20      ; loop until keyword end marker
c735 30 f5       BMI DeTo_10      ; branch always

c737          DeTo_30
c737 c8          INY
c738 b9 9e c0    LDA Basic_Keyword_Table,Y
c73b 30 b2       BMI LIST_30       ; go restore index, mask byte and print
c73d 20 47 cb    JSR Print_Char
c740 d0 f5       BNE DeTo_30       ; go get next character, branch always

              ; *********
c742            Basic_FOR
              ; *********

c742 a9 80       LDA #$80
c744 85 10       STA SUBFLG        ; set FNX flag
c746 20 a5 c9    JSR Basic_LET
c749 20 8a c3    JSR Find_Active_FOR
c74c d0 05       BNE BaFO_10       ; branch if this FOR variable was not found
c74e 8a          TXA               ; dump the old one
c74f 69 0f       ADC #15           ; add FOR structure size-2
c751 aa          TAX               ; copy to index
c752 9a          TXS               ; set stack (dump FOR structure (-2 bytes))

c753          BaFO_10
c753 68          PLA               ; pull return address
c754 68          PLA               ; pull return address
c755 a9 09       LDA #$09          ; we need 18d bytes !
c757 20 fb c3    JSR Check_Stack_Avail
c75a 20 06 c9    JSR Next_Statement
c75d 18          CLC
c75e 98          TYA               ; copy index to A
c75f 65 7a       ADC TXTPTR        ; add BASIC execute pointer low byte
c761 48          PHA               ; push onto stack
c762 a5 7b       LDA TXTPTR+1      ; get BASIC execute pointer high byte
c764 69 00       ADC #$00          ; add carry
c766 48          PHA               ; push onto stack
                 PUSHW(CURLIN)     ; push current line number
c767 a5 3a       LDA CURLIN+1
c769 48          PHA
c76a a5 39       LDA CURLIN
c76c 48          PHA

c76d a9 a4       LDA #TK_TO        ; set "TO" token
c76f 20 ff ce    JSR Need_A
c772 20 8d cd    JSR Is_Numeric
c775 20 8a cd    JSR Eval_Numeric
c778 a5 66       LDA FAC1SI        ; get FAC1 sign (b7)
c77a 09 7f       ORA #$7F          ; set all non sign bits
c77c 25 62       AND FAC1M1        ; and FAC1 mantissa 1
c77e 85 62       STA FAC1M1        ; save FAC1 mantissa 1
                 LAYI(BaFO_20)
c780 a9 8b       LDA #<BaFO_20
c782 a0 c7       LDY #>BaFO_20

                 STAY(INDEXA)      ; the following jump returns to this address
c784 85 22       STA INDEXA
c786 84 23       STY INDEXA+1

c788 4c 43 ce    JMP Round_And_Push_FAC1

c78b          BaFO_20
                 LAYI(REAL_1)      ; default STEP value = 1.0
c78b a9 bc       LDA #<REAL_1
c78d a0 d9       LDY #>REAL_1

c78f 20 a2 db    JSR Load_FAC1_AY
c792 20 79 00    JSR CHRGOT
c795 c9 a9       CMP #TK_STEP
c797 d0 06       BNE BaFO_30
c799 20 73 00    JSR CHRGET
c79c 20 8a cd    JSR Eval_Numeric  ; Get STEP value

c79f          BaFO_30
c79f 20 2b dc    JSR Get_FAC1_Sign
c7a2 20 38 ce    JSR Push_FAC1
                 PUSHW(FORPNT)     ; push FOR variable on stack
c7a5 a5 4a       LDA FORPNT+1
c7a7 48          PHA
c7a8 a5 49       LDA FORPNT
c7aa 48          PHA

c7ab a9 81       LDA #TK_FOR       ; push FOR token
c7ad 48          PHA

              ; ================
c7ae            Interpreter_Loop
              ; ================

c7ae 20 2c c8    JSR Check_STOP
                 LDAY(TXTPTR)      ; get BASIC execute pointer
c7b1 a5 7a       LDA TXTPTR
c7b3 a4 7b       LDY TXTPTR+1

c7b5 c0 02       CPY #>BUF         ; direct mode ?
c7b7 ea          NOP               ; unused byte
c7b8 f0 04       BEQ InLo_10       ; in direct mode skip the continue pointer save
                 STAY(OLDTXT)      ; save the continue pointer
c7ba 85 3d       STA OLDTXT
c7bc 84 3e       STY OLDTXT+1


c7be          InLo_10
c7be a0 00       LDY #0
c7c0 b1 7a       LDA (TXTPTR),Y    ; get BASIC byte
c7c2 d0 43       BNE Inte_20      ; if not [EOL] go test for ":"
c7c4 a0 02       LDY #2
c7c6 b1 7a       LDA (TXTPTR),Y    ; get next line pointer high byte
c7c8 18          CLC
c7c9 d0 03       BNE InLo_20       ; branch if not end of program
c7cb 4c 4b c8    JMP End_Of_Exec

c7ce          InLo_20
c7ce c8          INY
c7cf b1 7a       LDA (TXTPTR),Y    ; get line number low byte
c7d1 85 39       STA CURLIN        ; save current line number low byte
c7d3 c8          INY
c7d4 b1 7a       LDA (TXTPTR),Y    ; get line # high byte
c7d6 85 3a       STA CURLIN+1      ; save current line number high byte
c7d8 98          TYA               ; A now = 4
c7d9 65 7a       ADC TXTPTR        ; add BASIC execute pointer low byte, now points to code
c7db 85 7a       STA TXTPTR        ; save BASIC execute pointer low byte
c7dd 90 02       BCC Start_Program      ; if no overflow skip the high byte increment
c7df e6 7b       INC TXTPTR+1      ; else increment BASIC execute pointer high byte

              ; =============
c7e1            Start_Program
              ; =============

c7e1 6c 08 03    JMP (IGONE)       ; normally following code

              ; =============
c7e4            Default_Start
              ; =============

c7e4 20 73 00    JSR CHRGET
c7e7 20 ed c7    JSR Interpret
c7ea 4c ae c7    JMP Interpreter_Loop

              ; *********
c7ed            Interpret
              ; *********

c7ed f0 3c       BEQ BaRE_Ret      ; if the first byte is null just exit

c7ef            Interpret_10
              ; ------------
c7ef e9 80       SBC #$80          ; normalise the token
c7f1 90 11       BCC Inte_10       ; if wasn't token go do LET
c7f3 c9 23       CMP #TK_TAB-$80   ; compare with token for TAB(-$80
c7f5 b0 17       BCS Inte_40       ; branch if >= TAB(
c7f7 0a          ASL A             ; *2 bytes per vector
c7f8 a8          TAY               ; copy to index
c7f9 b9 0d c0    LDA Basic_Statement_Table+1,Y; get vector high byte
c7fc 48          PHA               ; push on stack
c7fd b9 0c c0    LDA Basic_Statement_Table,Y  ; get vector low byte
c800 48          PHA               ; push on stack
c801 4c 73 00    JMP CHRGET        ; the return from CHRGET calls the command code

c804          Inte_10
c804 4c a5 c9    JMP Basic_LET     ; perform LET

c807          Inte_20
c807 c9 3a       CMP #':'          ; comapre with ":"
c809 f0 d6       BEQ Start_Program ; if ":" go execute new code

c80b          Inte_30
c80b 4c 08 cf    JMP Syntax_Error

c80e          Inte_40
c80e c9 4b       CMP #TK_GO-$80    ; compare with token for GO
c810 d0 f9       BNE Inte_30       ; if not "GO" do syntax error then warm start
c812 20 73 00    JSR CHRGET
c815 a9 a4       LDA #TK_TO        ; set "TO" token
c817 20 ff ce    JSR Need_A
c81a 4c a0 c8    JMP Basic_GOTO    ; perform GOTO

              ; *************
c81d            Basic_RESTORE
              ; *************

c81d 38          SEC
c81e a5 2b       LDA TXTTAB        ; get start of memory low byte
c820 e9 01       SBC #$01          ; -1
c822 a4 2c       LDY TXTTAB+1      ; get start of memory high byte
c824 b0 01       BCS Store_DATPTR
c826 88          DEY               ; else decrement high byte

c827          Store_DATPTR
                 STAY(DATPTR)
c827 85 41       STA DATPTR
c829 84 42       STY DATPTR+1


c82b          BaRE_Ret
c82b 60          RTS ;Size   15 [Basic_RESTORE]

              ; **********
c82c            Check_STOP
              ; **********

c82c 20 e1 ff    JSR STOP          ; Check if stop key is pressed

              ; **********
c82f            Basic_STOP
              ; **********

c82f b0 01       BCS BaEN_10       ; if carry set do BREAK instead of just END

              ; *********
c831            Basic_END
              ; *********

c831 18          CLC

c832          BaEN_10
c832 d0 3c       BNE BaCO_Ret      ; return if wasn't CTRL-C
                 LDAY(TXTPTR)      ; get BASIC execute pointer
c834 a5 7a       LDA TXTPTR
c836 a4 7b       LDY TXTPTR+1

c838 a6 3a       LDX CURLIN+1      ; get current line number high byte
c83a e8          INX               ; increment it
c83b f0 0c       BEQ BaEN_20       ; branch if was direct mode
                 STAY(OLDTXT)      ; save continue pointer
c83d 85 3d       STA OLDTXT
c83f 84 3e       STY OLDTXT+1

                 LDAY(CURLIN)      ; get current line number
c841 a5 39       LDA CURLIN
c843 a4 3a       LDY CURLIN+1

                 STAY(OLDLIN)      ; save break line number
c845 85 3b       STA OLDLIN
c847 84 3c       STY OLDLIN+1


c849          BaEN_20
c849 68          PLA               ; dump return address low byte
c84a 68          PLA               ; dump return address high byte

c84b            End_Of_Exec
              ; -----------
                 LAYI(Msg_CrLf)
c84b a9 81       LDA #<Msg_CrLf
c84d a0 c3       LDY #>Msg_CrLf

c84f 90 03       BCC BaEN_30       ; branch if it was program end
c851 4c 69 c4    JMP Display_Msg_Then_Ready

c854          BaEN_30

0001 FALSE    #if C64
SKIP             JMP Vectored_Basic_Ready
              #endif
0000 TRUE     #if VIC
c854 4c 74 c4    JMP Basic_Ready
              #endif

              ; **********
c857            Basic_CONT
              ; **********

c857 d0 17       BNE BaCO_Ret      ; exit if following byte to allow syntax error
c859 a2 1a       LDX #$1A          ; error code $1A, can't continue error
c85b a4 3e       LDY OLDTXT+1      ; get continue pointer high byte
c85d d0 03       BNE BaCO_10       ; go do continue if we can
c85f 4c 37 c4    JMP Basic_Error

c862          BaCO_10
c862 a5 3d       LDA OLDTXT        ; get continue pointer low byte
                 STAY(TXTPTR)      ; save BASIC execute pointer
c864 85 7a       STA TXTPTR
c866 84 7b       STY TXTPTR+1

                 LDAY(OLDLIN)      ; get break line
c868 a5 3b       LDA OLDLIN
c86a a4 3c       LDY OLDLIN+1

                 STAY(CURLIN)      ; set current line
c86c 85 39       STA CURLIN
c86e 84 3a       STY CURLIN+1


c870          BaCO_Ret
c870 60          RTS ;Size   26 [Basic_CONT]

              ; *********
c871            Basic_RUN
              ; *********

c871 08          PHP
c872 a9 00       LDA #0            ; no control or kernal messages
c874 20 90 ff    JSR SETMSG
c877 28          PLP
c878 d0 03       BNE BaRU_10       ; branch if RUN n
c87a 4c 59 c6    JMP Reset_BASIC_Execution

c87d          BaRU_10
c87d 20 60 c6    JSR Clear_Variable_Space
c880 4c 97 c8    JMP Goto_Line

              ; ***********
c883            Basic_GOSUB
              ; ***********

c883 a9 03       LDA #3            ; need 6 bytes for GOSUB
c885 20 fb c3    JSR Check_Stack_Avail
                 PUSHW(TXTPTR)     ; push BASIC execute pointer
c888 a5 7b       LDA TXTPTR+1
c88a 48          PHA
c88b a5 7a       LDA TXTPTR
c88d 48          PHA

                 PUSHW(CURLIN)     ; push current line number
c88e a5 3a       LDA CURLIN+1
c890 48          PHA
c891 a5 39       LDA CURLIN
c893 48          PHA

c894 a9 8d       LDA #TK_GOSUB     ; token for GOSUB
c896 48          PHA               ; save it

c897            Goto_Line
              ; ---------
c897 20 79 00    JSR CHRGOT
c89a 20 a0 c8    JSR Basic_GOTO
c89d 4c ae c7    JMP Interpreter_Loop

              ; **********
c8a0            Basic_GOTO
              ; **********

c8a0 20 6b c9    JSR Scan_Linenumber
c8a3 20 09 c9    JSR Next_Line
c8a6 38          SEC
c8a7 a5 39       LDA CURLIN        ; get current line number low byte
c8a9 e5 14       SBC LINNUM        ; subtract temporary integer low byte
c8ab a5 3a       LDA CURLIN+1      ; get current line number high byte
c8ad e5 15       SBC LINNUM+1      ; subtract temporary integer high byte
c8af b0 0b       BCS BaGO_10       ; if current line # >= temporary search from start
c8b1 98          TYA               ; else copy line index to A
c8b2 38          SEC               ; set carry (+1)
c8b3 65 7a       ADC TXTPTR        ; add BASIC execute pointer low byte
c8b5 a6 7b       LDX TXTPTR+1      ; get BASIC execute pointer high byte
c8b7 90 07       BCC BaGO_20       ; if no overflow skip the high byte increment
c8b9 e8          INX               ; increment high byte
c8ba b0 04       BCS BaGO_20       ; go find the line, branch always

c8bc          BaGO_10
                 LDAX(TXTTAB)      ; get start of memory
c8bc a5 2b       LDA TXTTAB
c8be a6 2c       LDX TXTTAB+1


c8c0          BaGO_20
c8c0 20 17 c6    JSR Find_BASIC_Line_AX
c8c3 90 1e       BCC Undefined_Statement
c8c5 a5 5f       LDA TMPPTC        ; get pointer low byte
c8c7 e9 01       SBC #1            ; -1
c8c9 85 7a       STA TXTPTR        ; save BASIC execute pointer low byte
c8cb a5 60       LDA TMPPTC+1      ; get pointer high byte
c8cd e9 00       SBC #0            ; subtract carry
c8cf 85 7b       STA TXTPTR+1      ; save BASIC execute pointer high byte

c8d1          BaGO_Ret
c8d1 60          RTS ;Size   50 [Basic_GOTO]

              ; ************
c8d2            Basic_RETURN
              ; ************

c8d2 d0 fd       BNE BaGO_Ret      ; exit if following token to allow syntax error
c8d4 a9 ff       LDA #$FF          ; set byte so no match possible
c8d6 85 4a       STA FORPNT+1      ; save FOR/NEXT variable pointer high byte
c8d8 20 8a c3    JSR Find_Active_FOR
c8db 9a          TXS               ; correct the stack
c8dc c9 8d       CMP #TK_GOSUB     ; compare with GOSUB token
c8de f0 0b       BEQ BaRE_20       ; if matching GOSUB go continue RETURN
c8e0 a2 0c       LDX #$0C          ; else error code $04, return without gosub error
c8e2 2c          .byte $2C         ; skip next statement

              ; ===================
c8e3            Undefined_Statement
              ; ===================

c8e3 a2 11       LDX #$11          ; error code $11, undefined statement error
c8e5 4c 37 c4    JMP Basic_Error

c8e8          BaRE_10
c8e8 4c 08 cf    JMP Syntax_Error

c8eb          BaRE_20
c8eb 68          PLA               ; dump token byte
                 PULLW(CURLIN)     ; pull current line number
c8ec 68          PLA
c8ed 85 39       STA CURLIN
c8ef 68          PLA
c8f0 85 3a       STA CURLIN+1

                 PULLW(TXTPTR)     ; pull BASIC execute pointer
c8f2 68          PLA
c8f3 85 7a       STA TXTPTR
c8f5 68          PLA
c8f6 85 7b       STA TXTPTR+1


              ; **********
c8f8            Basic_DATA
              ; **********

c8f8 20 06 c9    JSR Next_Statement

              ; **************************
c8fb            Add_Y_To_Execution_Pointer
              ; **************************

c8fb 98          TYA               ; copy index to A

c8fc          Add_To_TXTPTR
c8fc 18          CLC
c8fd 65 7a       ADC TXTPTR        ; add BASIC execute pointer low byte
c8ff 85 7a       STA TXTPTR        ; save BASIC execute pointer low byte
c901 90 02       BCC AYTE_Ret      ; skip increment if no carry
c903 e6 7b       INC TXTPTR+1      ; else increment BASIC execute pointer high byte

c905          AYTE_Ret
c905 60          RTS ;Size   11 [Add_Y_To_Execution_Pointer]

              ; **************
c906            Next_Statement
              ; **************

c906 a2 3a       LDX #':'          ; look for colon
c908 2c          .byte   $2C       ; skip "LDX #0" command

              ; *********
c909            Next_Line
              ; *********

c909 a2 00       LDX #0            ; look for 0 [EOL]
c90b 86 07       STX CHARAC        ; store alternate search character
c90d a0 00       LDY #0            ; set search character = [EOL]
c90f 84 08       STY ENDCHR        ; save the search character

c911          NeLi_10
c911 a5 08       LDA ENDCHR        ; get search character
c913 a6 07       LDX CHARAC        ; get alternate search character
c915 85 07       STA CHARAC        ; make search character = alternate search character

c917          NeLi_15
c917 86 08       STX ENDCHR        ; make alternate search character = search character

c919          NeLi_20
c919 b1 7a       LDA (TXTPTR),Y    ; get BASIC byte
c91b f0 e8       BEQ AYTE_Ret      ; exit if null [EOL]
c91d c5 08       CMP ENDCHR        ; compare with search character
c91f f0 e4       BEQ AYTE_Ret      ; exit if found
c921 c8          INY               ; else increment index
c922 c9 22       CMP #QUOTE
c924 d0 f3       BNE NeLi_20       ; if found go swap search character for alternate search
c926 f0 e9       BEQ NeLi_10       ; loop for next character, branch always

              ; ********
c928            Basic_IF
              ; ********

c928 20 9e cd    JSR Eval_Expression
c92b 20 79 00    JSR CHRGOT
c92e c9 89       CMP #TK_GOTO
c930 f0 05       BEQ BaIF_10       ; do IF ... GOTO
c932 a9 a7       LDA #TK_THEN
c934 20 ff ce    JSR Need_A

c937          BaIF_10
c937 a5 61       LDA FAC1EX        ; get FAC1 exponent
c939 d0 05       BNE BaIF_20      ; if result was non zero continue execution

              ; *********
c93b            Basic_REM
              ; *********

c93b 20 09 c9    JSR Next_Line
c93e f0 bb       BEQ Add_Y_To_Execution_Pointer ; branch always

c940          BaIF_20              ; Basic_IF continued
c940 20 79 00    JSR CHRGOT
c943 b0 03       BCS BaIF_30      ; if not numeric character, is variable or keyword
c945 4c a0 c8    JMP Basic_GOTO    ; else perform GOTO n

c948          BaIF_30
c948 4c ed c7    JMP Interpret

              ; ********
c94b            Basic_ON
              ; ********

c94b 20 9e d7    JSR Get_Byte_Value
c94e 48          PHA               ; push next character
c94f c9 8d       CMP #TK_GOSUB     ; compare with GOSUB token
c951 f0 04       BEQ BaON_20       ; if GOSUB go see if it should be executed

c953          BaON_10
c953 c9 89       CMP #TK_GOTO      ; compare with GOTO token
c955 d0 91       BNE BaRE_10       ; if not GOTO do syntax error then warm start

c957          BaON_20
c957 c6 65       DEC FAC1M4        ; decrement the byte value
c959 d0 04       BNE BaON_30       ; if not zero go see if another line number exists
c95b 68          PLA               ; pull keyword token
c95c 4c ef c7    JMP Interpret_10

c95f          BaON_30
c95f 20 73 00    JSR CHRGET
c962 20 6b c9    JSR Scan_Linenumber
c965 c9 2c       CMP #','          ; compare next character with ","
c967 f0 ee       BEQ BaON_20       ; loop if ","
c969 68          PLA               ; else pull keyword token, ran out of options

c96a          BaON_Ret
c96a 60          RTS ;Size   32 [Basic_ON]

              ; ***************
c96b            Scan_Linenumber
              ; ***************

c96b a2 00       LDX #0
c96d 86 14       STX LINNUM
c96f 86 15       STX LINNUM+1

c971          ScLi_Loop
c971 b0 f7       BCS BaON_Ret      ; return if carry set, end of scan, character was not 0-9
c973 e9 2f       SBC #$2F          ; subtract $30, $2F+carry, from byte
c975 85 07       STA CHARAC        ; store # OPT: TAX
c977 a5 15       LDA LINNUM+1      ; get temporary integer high byte
c979 85 22       STA INDEXA        ; save it for now
c97b c9 19       CMP #$19          ; compare with $19
c97d b0 d4       BCS BaON_10       ; branch if >= this makes the maximum line number 63999
                                   ; because the next bit does $1900 * $0A = $FA00 = 64000
                                   ; decimal. the branch target is really the SYNTAX error
                                   ; at BaRE_10 but that is too far so an intermediate
                                   ; compare and branch to that location is used. the problem
                                   ; with this is that line number that gives a partial result
                                   ; from $8900 to $89FF, 35072x to 35327x, will pass the new
                                   ; target compare and will try to execute the remainder of
                                   ; the ON n GOTO/GOSUB. a solution to this is to copy the
                                   ; byte in A before the branch to X and then branch to
                                   ; BaRE_10 skipping the second compare

c97f a5 14       LDA LINNUM        ; get temporary integer low byte
c981 0a          ASL A             ; *2 low byte
c982 26 22       ROL INDEXA        ; *2 high byte
c984 0a          ASL A             ; *2 low byte
c985 26 22       ROL INDEXA        ; *2 high byte (*4)
c987 65 14       ADC LINNUM        ; + low byte (*5)
c989 85 14       STA LINNUM        ; save it
c98b a5 22       LDA INDEXA        ; get high byte temp
c98d 65 15       ADC LINNUM+1      ; + high byte (*5)
c98f 85 15       STA LINNUM+1      ; save it
c991 06 14       ASL LINNUM        ; *2 low byte (*10d)
c993 26 15       ROL LINNUM+1      ; *2 high byte (*10d)
c995 a5 14       LDA LINNUM        ; get low byte OPT: TXA
c997 65 07       ADC CHARAC        ; add #        OPT: ADC LINNUM
c999 85 14       STA LINNUM        ; save low byte
c99b 90 02       BCC ScLi_10       ; if no overflow skip high byte increment
c99d e6 15       INC LINNUM+1      ; else increment high byte

c99f          ScLi_10
c99f 20 73 00    JSR CHRGET
c9a2 4c 71 c9    JMP ScLi_Loop      ; OPT: BCC ScLi_Loop : RTS

              ; *********
c9a5            Basic_LET
              ; *********

c9a5 20 8b d0    JSR Get_Scalar_Address
                 STAY(FORPNT)      ; save variable address
c9a8 85 49       STA FORPNT
c9aa 84 4a       STY FORPNT+1

c9ac a9 b2       LDA #TK_EQUAL
c9ae 20 ff ce    JSR Need_A        ; '=' is needed
c9b1 a5 0e       LDA INTFLG        ; get data type flag, $80 = integer, $00 = float
c9b3 48          PHA               ; push data type flag
c9b4 a5 0d       LDA VALTYP        ; get data type flag, $FF = string, $00 = numeric
c9b6 48          PHA               ; push data type flag
c9b7 20 9e cd    JSR Eval_Expression
c9ba 68          PLA               ; pop data type flag
c9bb 2a          ROL A             ; string bit into carry
c9bc 20 90 cd    JSR Check_Var_Type
c9bf d0 18       BNE LET_20        ; if string go assign a string value
c9c1 68          PLA               ; pop integer/float data type flag

              ; ***********************
c9c2            Assign_Numeric_variable
              ; ***********************

c9c2 10 12       BPL LET_10        ; if float go assign a floating value
c9c4 20 1b dc    JSR Round_FAC1_Checked
c9c7 20 bf d1    JSR Eval_Integer
c9ca a0 00       LDY #0
c9cc a5 64       LDA FAC1M3        ; get FAC1 mantissa 3
c9ce 91 49       STA (FORPNT),Y    ; save as integer variable low byte
c9d0 c8          INY
c9d1 a5 65       LDA FAC1M4        ; get FAC1 mantissa 4
c9d3 91 49       STA (FORPNT),Y    ; save as integer variable high byte
c9d5 60          RTS ;Size   20 [Assign_Numeric_variable]

c9d6          LET_10
c9d6 4c d0 db    JMP Assign_FAC1_To_FOR_Index

c9d9          LET_20
c9d9 68          PLA               ; dump integer/float data type flag

              ; **********************
c9da            Assign_String_Variable
              ; **********************

c9da a4 4a       LDY FORPNT+1      ; get variable pointer high byte
c9dc c0 df       CPY #>NULL_Descriptor ; TI$
c9de d0 4c       BNE Assign_String
c9e0 20 a6 d6    JSR Get_String_Descriptor
c9e3 c9 06       CMP #6            ; TI$ = "hhmmss"
c9e5 d0 3d       BNE Jump_Illegal_Quantity
c9e7 a0 00       LDY #0
c9e9 84 61       STY FAC1EX        ; clear FAC1 exponent
c9eb 84 66       STY FAC1SI        ; clear FAC1 sign (b7)

c9ed          LET_30
c9ed 84 71       STY TMPPTD        ; save index
c9ef 20 1d ca    JSR Eval_Digit    ; check and evaluate numeric digit
c9f2 20 e2 da    JSR Multiply_FAC1_BY_10
c9f5 e6 71       INC TMPPTD        ; increment index
c9f7 a4 71       LDY TMPPTD        ; restore index
c9f9 20 1d ca    JSR Eval_Digit    ; check and evaluate numeric digit
c9fc 20 0c dc    JSR FAC1_Round_And_Copy_To_FAC2
c9ff aa          TAX               ; copy FAC1 exponent
ca00 f0 05       BEQ LET_40        ; branch if FAC1 zero
ca02 e8          INX               ; increment index, * 2
ca03 8a          TXA               ; copy back to A
ca04 20 ed da    JSR Multiply_FAC1_By_4

ca07          LET_40
ca07 a4 71       LDY TMPPTD        ; get index
ca09 c8          INY
ca0a c0 06       CPY #6            ; max. 6 digits "hhmmss"
ca0c d0 df       BNE LET_30

ca0e 20 e2 da    JSR Multiply_FAC1_BY_10
ca11 20 9b dc    JSR FAC1_To_Integer
ca14 a6 64       LDX FAC1M3        ; get FAC1 mantissa 3
ca16 a4 63       LDY FAC1M2        ; get FAC1 mantissa 2
ca18 a5 65       LDA FAC1M4        ; get FAC1 mantissa 4
ca1a 4c db ff    JMP SETTIM        ; Set the system clock

              ; **********
ca1d            Eval_Digit
              ; **********

ca1d b1 22       LDA (INDEXA),Y    ; get byte from string
ca1f 20 80 00    JSR ISNUM
ca22 90 03       BCC EvDi_10       ; branch if numeric

ca24          Jump_Illegal_Quantity
ca24 4c 48 d2    JMP Illegal_Quantity

ca27          EvDi_10
ca27 e9 2f       SBC #$2F          ; subtract $2F + carry = '0'
ca29 4c 7e dd    JMP Add_A_To_FAC1

              ; -------------
ca2c            Assign_String
              ; -------------

ca2c a0 02       LDY #2            ; index to string pointer high byte
ca2e b1 64       LDA (FAC1M3),Y    ; get string pointer high byte
ca30 c5 34       CMP FRESPC+1      ; compare with bottom of string space high byte
ca32 90 17       BCC AsSt_20       ; branch if string pointer < bottom of string space
ca34 d0 07       BNE AsSt_10       ; branch if string pointer > bottom of string space
ca36 88          DEY               ; Y = 1
ca37 b1 64       LDA (FAC1M3),Y    ; get string pointer low byte
ca39 c5 33       CMP FRESPC        ; compare with bottom of string space low byte
ca3b 90 0e       BCC AsSt_20       ; branch if string pointer < bottom of string space

ca3d          AsSt_10
ca3d a4 65       LDY FAC1M4        ; get descriptor pointer high byte
ca3f c4 2e       CPY VARTAB+1      ; compare with start of variables high byte
ca41 90 08       BCC AsSt_20       ; branch if less, is on string stack
ca43 d0 0d       BNE AsSt_30       ; if greater make space and copy string
ca45 a5 64       LDA FAC1M3        ; get descriptor pointer low byte
ca47 c5 2d       CMP VARTAB        ; compare with start of variables low byte
ca49 b0 07       BCS AsSt_30       ; if greater or equal make space and copy string

ca4b          AsSt_20
ca4b a5 64       LDA FAC1M3        ; get descriptor pointer low byte
ca4d a4 65       LDY FAC1M4        ; get descriptor pointer high byte
ca4f 4c 68 ca    JMP AsSt_40       ; go copy descriptor to variable

ca52          AsSt_30
ca52 a0 00       LDY #0
ca54 b1 64       LDA (FAC1M3),Y    ; get string length
ca56 20 75 d4    JSR Allocate_String_FAC1
                 LDAY(DESCPT)
ca59 a5 50       LDA DESCPT
ca5b a4 51       LDY DESCPT+1

                 STAY(STRPTR)
ca5d 85 6f       STA STRPTR
ca5f 84 70       STY STRPTR+1

ca61 20 7a d6    JSR Store_String_STRPTR
                 LAYI(FAC1EX)
ca64 a9 61       LDA #<FAC1EX
ca66 a0 00       LDY #>FAC1EX


ca68          AsSt_40
                 STAY( DESCPT)     ; save descriptor pointer
ca68 85 50       STA DESCPT
ca6a 84 51       STY DESCPT+1

ca6c 20 db d6    JSR Pop_Descriptor_Stack
ca6f a0 00       LDY #0
ca71 b1 50       LDA (DESCPT),Y    ; get string length from new descriptor
ca73 91 49       STA (FORPNT),Y    ; copy string length to variable
ca75 c8          INY
ca76 b1 50       LDA (DESCPT),Y    ; get string pointer low byte from new descriptor
ca78 91 49       STA (FORPNT),Y    ; copy string pointer low byte to variable
ca7a c8          INY
ca7b b1 50       LDA (DESCPT),Y    ; get string pointer high byte from new descriptor
ca7d 91 49       STA (FORPNT),Y    ; copy string pointer high byte to variable
ca7f 60          RTS ;Size   99 [Eval_Digit]

              ; ************
ca80            Basic_PRINTN
              ; ************

ca80 20 86 ca    JSR Basic_CMD
ca83 4c b5 cb    JMP Set_Default_Channels

              ; *********
ca86            Basic_CMD
              ; *********

ca86 20 9e d7    JSR Get_Byte_Value
ca89 f0 05       BEQ BCMD_10       ; branch if following byte is ":" or [EOT]
ca8b a9 2c       LDA #','
ca8d 20 ff ce    JSR Need_A

ca90          BCMD_10
ca90 08          PHP               ; save status
ca91 86 13       STX IOPMPT        ; set current I/O channel
ca93 20 15 e1    JSR Select_Output_Channel
ca96 28          PLP               ; restore status
ca97 4c a0 ca    JMP Basic_PRINT   ; perform PRINT

ca9a          BaPR_00
ca9a 20 21 cb    JSR Print_String_From_Descriptor

ca9d          BaPR_05
ca9d 20 79 00    JSR CHRGOT

              ; ***********
caa0            Basic_PRINT
              ; ***********

caa0 f0 35       BEQ Print_CR

caa2          BaPR_10
caa2 f0 43       BEQ Invert_Ret      ; if nothing following exit, end of PRINT branch
caa4 c9 a3       CMP #TK_TAB       ; compare with token for TAB(
caa6 f0 50       BEQ TAB_20      ; if TAB( go handle it
caa8 c9 a6       CMP #TK_SPC       ; compare with token for SPC(
caaa 18          CLC               ; flag SPC(
caab f0 4b       BEQ TAB_20      ; if SPC( go handle it
caad c9 2c       CMP #','
caaf f0 37       BEQ TAB_Jump
cab1 c9 3b       CMP #SEMIC
cab3 f0 5e       BEQ TAB_60      ; if ";" go continue the print loop
cab5 20 9e cd    JSR Eval_Expression
cab8 24 0d       BIT VALTYP        ; test data type flag, $FF = string, $00 = numeric
caba 30 de       BMI BaPR_00      ; if string go print string, scan memory and continue PRINT
cabc 20 dd dd    JSR Format_FAC1
cabf 20 87 d4    JSR Create_String_Descriptor
cac2 20 21 cb    JSR Print_String_From_Descriptor
cac5 20 3b cb    JSR Cursor_Right_Or_Space
cac8 d0 d3       BNE BaPR_05      ; go scan memory and continue PRINT, branch always

              ; =============
caca            Terminate_BUF
              ; =============

caca a9 00       LDA #0
cacc 9d 00 02    STA BUF,X         ; terminate string with 0 byte
cacf a2 ff       LDX #<[BUF-1]
cad1 a0 01       LDY #>[BUF-1]
cad3 a5 13       LDA IOPMPT        ; get current I/O channel
cad5 d0 10       BNE Invert_Ret      ; exit if not default channel

              ; ********
cad7            Print_CR
              ; ********

cad7 a9 0d       LDA #CR
cad9 20 47 cb    JSR Print_Char
cadc 24 13       BIT IOPMPT        ; test current I/O channel
cade 10 05       BPL Invert_A      ; needless, because this is always true
cae0 a9 0a       LDA #LF
cae2 20 47 cb    JSR Print_Char

              ; --------
cae5            Invert_A
              ; --------

cae5 49 ff       EOR #$FF          ; invert A

cae7          Invert_Ret
cae7 60          RTS ;Size   17 [Print_CR]

              ; ========
cae8            TAB_Jump
              ; ========

cae8 38          SEC               ; set Cb for read cursor position
cae9 20 f0 ff    JSR PLOT          ; Read cursor location
caec 98          TYA               ; copy cursor Y
caed 38          SEC

caee          TAB_10

0001 FALSE    #if C64
SKIP             SBC #10           ; subtract one TAB length
              #endif
0000 TRUE     #if VIC
caee e9 0b       SBC #11           ; subtract one TAB length
              #endif

caf0 b0 fc       BCS TAB_10
caf2 49 ff       EOR #$FF          ; complement it
caf4 69 01       ADC #1
caf6 d0 16       BNE TAB_30        ; print A spaces, branch always

caf8          TAB_20
caf8 08          PHP               ; save TAB( or SPC( status
caf9 38          SEC               ; set Cb for read cursor position
cafa 20 f0 ff    JSR PLOT          ; Read or set cursor location
cafd 84 09       STY TRMPOS        ; save current cursor position
caff 20 9b d7    JSR Get_Next_Byte_Value
cb02 c9 29       CMP #$29          ; compare with ")"
cb04 d0 59       BNE BaIn_30       ; if not ")" do syntax error
cb06 28          PLP               ; restore TAB( or SPC( status
cb07 90 06       BCC TAB_40        ; branch if was SPC(
cb09 8a          TXA               ; copy TAB() byte to A
cb0a e5 09       SBC TRMPOS        ; subtract current cursor position
cb0c 90 05       BCC TAB_60        ; go loop for next if already past requited position

cb0e          TAB_30
cb0e aa          TAX               ; copy [SPACE] count to X

cb0f          TAB_40
cb0f e8          INX               ; increment count

cb10          TAB_50
cb10 ca          DEX               ; decrement count
cb11 d0 06       BNE TAB_70        ; branch if count was not zero

cb13          TAB_60
cb13 20 73 00    JSR CHRGET
cb16 4c a2 ca    JMP BaPR_10       ; continue print loop

cb19          TAB_70
cb19 20 3b cb    JSR Cursor_Right_Or_Space
cb1c d0 f2       BNE TAB_50        ; loop, branch always

              ; ************
cb1e            Print_String
              ; ************

cb1e 20 87 d4    JSR Create_String_Descriptor

              ; ----------------------------
cb21            Print_String_From_Descriptor
              ; ----------------------------

cb21 20 a6 d6    JSR Get_String_Descriptor
cb24 aa          TAX               ; copy length
cb25 a0 00       LDY #0
cb27 e8          INX               ; increment length, for pre decrement loop

cb28          PSFD_Loop
cb28 ca          DEX               ; decrement length
cb29 f0 bc       BEQ Invert_Ret    ; exit if done
cb2b b1 22       LDA (INDEXA),Y    ; get byte from string
cb2d 20 47 cb    JSR Print_Char
cb30 c8          INY
cb31 c9 0d       CMP #$0D          ; compare byte with [CR]
cb33 d0 f3       BNE PSFD_Loop
cb35 20 e5 ca    JSR Invert_A      ; nonsense
cb38 4c 28 cb    JMP PSFD_Loop

              ; *********************
cb3b            Cursor_Right_Or_Space
              ; *********************

cb3b a5 13       LDA IOPMPT        ; get current I/O channel
cb3d f0 03       BEQ CROS_10       ; if default channel load [CURSOR RIGHT]
cb3f a9 20       LDA #' '          ; else load [SPACE]
cb41 2c          .byte $2C         ; skip until Print_Char
cb42          CROS_10 
cb42 a9 1d       LDA #$1D          ; load [CURSOR RIGHT]
cb44 2c          .byte $2C         ; skip until Print_Char

              ; *******************
cb45            Print_Question_Mark
              ; *******************

cb45 a9 3f       LDA #'?'

              ; **********
cb47            Print_Char
              ; **********

cb47 20 09 e1    JSR CHROUT_Checked
cb4a 29 ff       AND #$FF          ; set flags
cb4c 60          RTS ;Size    6 [Print_Char]

              ; =========
cb4d            Bad_Input
              ; =========

cb4d a5 11       LDA INPFLG        ; get INPUT mode flag, $00 = INPUT, $40 = GET, $98 = READ
cb4f f0 11       BEQ BaIn_40       ; branch if INPUT
cb51 30 04       BMI BaIn_10       ; branch if READ
cb53 a0 ff       LDY #$FF          ; set current line high byte to -1, indicate immediate mode
cb55 d0 04       BNE BaIn_20       ; branch always

cb57          BaIn_10
                 LDAY(DATLIN)      ; get current DATA line number
cb57 a5 3f       LDA DATLIN
cb59 a4 40       LDY DATLIN+1


cb5b          BaIn_20
                 STAY(CURLIN)      ; set current line number
cb5b 85 39       STA CURLIN
cb5d 84 3a       STY CURLIN+1


cb5f          BaIn_30
cb5f 4c 08 cf    JMP Syntax_Error

cb62          BaIn_40
cb62 a5 13       LDA IOPMPT        ; get current I/O channel
cb64 f0 05       BEQ BaIn_50       ; if default channel go do "?REDO FROM START" message
cb66 a2 18       LDX #$18          ; else error $18, file data error
cb68 4c 37 c4    JMP Basic_Error

cb6b          BaIn_50
                 Print_Msg(Msg_Redo_From_Start)
cb6b a9 0c       LDA #<Msg_Redo_From_Start
cb6d a0 cd       LDY #>Msg_Redo_From_Start
cb6f 20 1e cb    JSR Print_String

                 LDAY(OLDTXT)      ; get continue pointer
cb72 a5 3d       LDA OLDTXT
cb74 a4 3e       LDY OLDTXT+1

                 STAY(TXTPTR)      ; save BASIC execute pointer
cb76 85 7a       STA TXTPTR
cb78 84 7b       STY TXTPTR+1

cb7a 60          RTS ;Size   52 [Print_Char]

              ; *********
cb7b            Basic_GET
              ; *********

cb7b 20 a6 d3    JSR Assert_Non_Direct
cb7e c9 23       CMP #'#'          ; compare with "#"
cb80 d0 10       BNE BaGE_10       ; branch if not GET#
cb82 20 73 00    JSR CHRGET
cb85 20 9e d7    JSR Get_Byte_Value
cb88 a9 2c       LDA #','
cb8a 20 ff ce    JSR Need_A
cb8d 86 13       STX IOPMPT        ; set current I/O channel
cb8f 20 1b e1    JSR CHKIN_Checked

cb92          BaGE_10
cb92 a2 01       LDX #<[BUF+1]     ; set BUF+1 pointer low byte
cb94 a0 02       LDY #>[BUF+1]     ; set BUF+1 pointer high byte
cb96 a9 00       LDA #0
cb98 8d 01 02    STA BUF+1         ; ensure null terminator
cb9b a9 40       LDA #$40          ; input mode = GET
cb9d 20 0f cc    JSR Read_Get
cba0 a6 13       LDX IOPMPT        ; get current I/O channel
cba2 d0 13       BNE BaIN_10       ; if not default channel go do channel close and return
cba4 60          RTS ;Size   42 [Basic_GET]

              ; ************
cba5            Basic_INPUTN
              ; ************

cba5 20 9e d7    JSR Get_Byte_Value
cba8 a9 2c       LDA #','
cbaa 20 ff ce    JSR Need_A
cbad 86 13       STX IOPMPT        ; set current I/O channel
cbaf 20 1b e1    JSR CHKIN_Checked
cbb2 20 ce cb    JSR Input_String

              ; --------------------
cbb5            Set_Default_Channels
              ; --------------------

cbb5 a5 13       LDA IOPMPT        ; get current I/O channel

cbb7          BaIN_10
cbb7 20 cc ff    JSR CLRCHN        ; Clear I/O channels
cbba a2 00       LDX #0
cbbc 86 13       STX IOPMPT        ; clear current I/O channel
cbbe 60          RTS ;Size   26 [Basic_INPUTN]

              ; ***********
cbbf            Basic_INPUT
              ; ***********

cbbf c9 22       CMP #QUOTE
cbc1 d0 0b       BNE Input_String
cbc3 20 bd ce    JSR Make_String_Descriptor_From_Code
cbc6 a9 3b       LDA #SEMIC
cbc8 20 ff ce    JSR Need_A
cbcb 20 21 cb    JSR Print_String_From_Descriptor

              ; ------------
cbce            Input_String
              ; ------------

cbce 20 a6 d3    JSR Assert_Non_Direct
cbd1 a9 2c       LDA #','
cbd3 8d ff 01    STA BUF-1         ; save to start of buffer - 1

cbd6          BaIN_20
cbd6 20 f9 cb    JSR Prompt_And_Input
cbd9 a5 13       LDA IOPMPT        ; get current I/O channel
cbdb f0 0d       BEQ BaIN_30       ; branch if default I/O channel
cbdd 20 b7 ff    JSR READST        ; read I/O status word
cbe0 29 02       AND #$02          ; mask no DSR/timeout
cbe2 f0 06       BEQ BaIN_30       ; branch if not error
cbe4 20 b5 cb    JSR Set_Default_Channels
cbe7 4c f8 c8    JMP Basic_DATA    ; perform DATA

cbea          BaIN_30
cbea ad 00 02    LDA BUF           ; get first byte in input buffer
cbed d0 1e       BNE BaIN_50
cbef a5 13       LDA IOPMPT        ; get current I/O channel
cbf1 d0 e3       BNE BaIN_20       ; if not default channel go get BASIC input
cbf3 20 06 c9    JSR Next_Statement
cbf6 4c fb c8    JMP Add_Y_To_Execution_Pointer

              ; ****************
cbf9            Prompt_And_Input
              ; ****************

cbf9 a5 13       LDA IOPMPT        ; get current I/O channel
cbfb d0 06       BNE BaIN_40       ; skip "?" prompt if not default channel
cbfd 20 45 cb    JSR Print_Question_Mark
cc00 20 3b cb    JSR Cursor_Right_Or_Space
cc03          BaIN_40
cc03 4c 60 c5    JMP Read_String

              ; **********
cc06            Basic_READ
              ; **********

                 LDXY(DATPTR)
cc06 a6 41       LDX DATPTR
cc08 a4 42       LDY DATPTR+1

cc0a a9 98       LDA #$98          ; set input mode = READ
cc0c 2c          .byte   $2C       ; skip next statement
cc0d          BaIN_50
cc0d a9 00       LDA #$00          ; set input mode = INPUT

              ; --------
cc0f            Read_Get
              ; --------

cc0f 85 11       STA INPFLG        ; $00 = INPUT, $40 = GET, $98 = READ
                 STXY(INPPTR)
cc11 86 43       STX INPPTR
cc13 84 44       STY INPPTR+1


cc15          READ_Loop_Var
cc15 20 8b d0    JSR Get_Scalar_Address
                 STAY(FORPNT)      ; save variable address
cc18 85 49       STA FORPNT
cc1a 84 4a       STY FORPNT+1

                 LDAY(TXTPTR)      ; get BASIC execute pointer
cc1c a5 7a       LDA TXTPTR
cc1e a4 7b       LDY TXTPTR+1

                 STAY(YSAVE)       ; save BASIC execute pointer
cc20 85 4b       STA YSAVE
cc22 84 4c       STY YSAVE+1

                 LDXY(INPPTR)      ; get READ pointer
cc24 a6 43       LDX INPPTR
cc26 a4 44       LDY INPPTR+1

                 STXY(TXTPTR)      ; save as BASIC execute pointer
cc28 86 7a       STX TXTPTR
cc2a 84 7b       STY TXTPTR+1

cc2c 20 79 00    JSR CHRGOT
cc2f d0 20       BNE READ_20       ; branch if not null
cc31 24 11       BIT INPFLG        ; $00 = INPUT, $40 = GET, $98 = READ
cc33 50 0c       BVC READ_05       ; branch if not GET
cc35 20 21 e1    JSR GETIN_Checked
cc38 8d 00 02    STA BUF           ; save to buffer
cc3b a2 ff       LDX #<[BUF-1]     ; set BUF-1 pointer low byte
cc3d a0 01       LDY #>[BUF-1]     ; set BUF-1 pointer high byte
cc3f d0 0c       BNE READ_15       ; branch always

cc41          READ_05
cc41 30 75       BMI READ_60      ; branch if READ else it's do INPUT
cc43 a5 13       LDA IOPMPT        ; get current I/O channel
cc45 d0 03       BNE READ_10       ; skip "?" prompt if not default channel
cc47 20 45 cb    JSR Print_Question_Mark

cc4a          READ_10
cc4a 20 f9 cb    JSR Prompt_And_Input

cc4d          READ_15
                 STXY(TXTPTR)
cc4d 86 7a       STX TXTPTR
cc4f 84 7b       STY TXTPTR+1


cc51          READ_20
cc51 20 73 00    JSR CHRGET        ; execute pointer now points to start of next data
cc54 24 0d       BIT VALTYP        ; test data type flag, $FF = string, $00 = numeric
cc56 10 31       BPL READ_45      ; branch if numeric
cc58 24 11       BIT INPFLG        ; $00 = INPUT, $40 = GET, $98 = READ
cc5a 50 09       BVC READ_25       ; branch if not GET
cc5c e8          INX               ; GET string
cc5d 86 7a       STX TXTPTR        ; save BASIC execute pointer low byte
cc5f a9 00       LDA #0
cc61 85 07       STA CHARAC        ; clear search character
cc63 f0 0c       BEQ READ_30       ; branch always

                                   ; is string INPUT or string READ
cc65          READ_25
cc65 85 07       STA CHARAC        ; save search character
cc67 c9 22       CMP #QUOTE
cc69 f0 07       BEQ READ_35       ; if quote only search for "..." string
cc6b a9 3a       LDA #':'          ; set ":"
cc6d 85 07       STA CHARAC        ; set search character
cc6f a9 2c       LDA #','

cc71          READ_30
cc71 18          CLC

cc72          READ_35
cc72 85 08       STA ENDCHR        ; set scan quotes flag
                 LDAY(TXTPTR)      ; get BASIC execute pointer
cc74 a5 7a       LDA TXTPTR
cc76 a4 7b       LDY TXTPTR+1

cc78 69 00       ADC #0            ; INPUT and READ increment by carry
cc7a 90 01       BCC READ_40       ; if no carry skip the high byte increment
cc7c c8          INY               ; else increment pointer high byte

cc7d          READ_40
cc7d 20 8d d4    JSR Create_String_Descriptor_AY
cc80 20 e2 d7    JSR Restore_Execution_Pointer
cc83 20 da c9    JSR Assign_String_Variable
cc86 4c 91 cc    JMP READ_50       ; continue processing command

                                   ; GET, INPUT or READ is numeric
cc89          READ_45
cc89 20 f3 dc    JSR Load_FAC1_From_String
cc8c a5 0e       LDA INTFLG        ; get data type flag, $80 = integer, $00 = float
cc8e 20 c2 c9    JSR Assign_Numeric_variable

cc91          READ_50
cc91 20 79 00    JSR CHRGOT
cc94 f0 07       BEQ READ_55       ; if ":" or [EOL] go handle the string end
cc96 c9 2c       CMP #','          ; comparte with ","
cc98 f0 03       BEQ READ_55       ; if "," go handle the string end
cc9a 4c 4d cb    JMP Bad_Input

cc9d          READ_55
                 LDAY(TXTPTR)      ; get BASIC execute pointer
cc9d a5 7a       LDA TXTPTR
cc9f a4 7b       LDY TXTPTR+1

                 STAY(INPPTR)      ; save READ pointer
cca1 85 43       STA INPPTR
cca3 84 44       STY INPPTR+1

                 LDAY(YSAVE)       ; get saved BASIC execute pointer
cca5 a5 4b       LDA YSAVE
cca7 a4 4c       LDY YSAVE+1

                 STAY(TXTPTR)      ; restore BASIC execute pointer
cca9 85 7a       STA TXTPTR
ccab 84 7b       STY TXTPTR+1

ccad 20 79 00    JSR CHRGOT
ccb0 f0 2d       BEQ READ_70       ; branch if ":" or [EOL]
ccb2 20 fd ce    JSR Need_Comma
ccb5 4c 15 cc    JMP READ_Loop_Var

ccb8          READ_60
ccb8 20 06 c9    JSR Next_Statement
ccbb c8          INY
ccbc aa          TAX               ; copy byte to X
ccbd d0 12       BNE READ_65       ; if ":" go look for the next DATA
ccbf a2 0d       LDX #$0D          ; else set error $0D, out of data error
ccc1 c8          INY
ccc2 b1 7a       LDA (TXTPTR),Y    ; get next line pointer high byte
ccc4 f0 6c       BEQ NEXT_20      ; if program end go do error, eventually does error X
ccc6 c8          INY
ccc7 b1 7a       LDA (TXTPTR),Y    ; get next line # low byte
ccc9 85 3f       STA DATLIN        ; save current DATA line low byte
cccb c8          INY
cccc b1 7a       LDA (TXTPTR),Y    ; get next line # high byte
ccce c8          INY
cccf 85 40       STA DATLIN+1      ; save current DATA line high byte

ccd1          READ_65
ccd1 20 fb c8    JSR Add_Y_To_Execution_Pointer
ccd4 20 79 00    JSR CHRGOT
ccd7 aa          TAX               ; copy byte
ccd8 e0 83       CPX #TK_DATA      ; compare with token for DATA
ccda d0 dc       BNE READ_60       ; loop if not DATA
ccdc 4c 51 cc    JMP READ_20       ; continue evaluating READ

ccdf          READ_70
ccdf a5 43       LDA INPPTR        ; get READ pointer low byte
cce1 a4 44       LDY INPPTR+1      ; get READ pointer high byte
cce3 a6 11       LDX INPFLG        ; get INPUT mode flag, $00 = INPUT, $40 = GET, $98 = READ
cce5 10 03       BPL READ_75       ; if INPUT or GET go exit or ignore extra input
cce7 4c 27 c8    JMP Store_DATPTR

ccea          READ_75
ccea a0 00       LDY #0
ccec b1 43       LDA (INPPTR),Y    ; get READ byte
ccee f0 0b       BEQ READ_Ret      ; exit if [EOL]
ccf0 a5 13       LDA IOPMPT        ; get current I/O channel
ccf2 d0 07       BNE READ_Ret      ; exit if not default channel
                 LAYI(Msg_Extra_Ignored)
ccf4 a9 fc       LDA #<Msg_Extra_Ignored
ccf6 a0 cc       LDY #>Msg_Extra_Ignored

ccf8 4c 1e cb    JMP Print_String

ccfb          READ_Ret
ccfb 60          RTS ;Size  246 [Basic_READ]

ccfc 3f 45 58 Msg_Extra_Ignored   .byte "?EXTRA IGNORED\r",0
cd0c 3f 52 45 Msg_Redo_From_Start .byte "?REDO FROM START\r",0

              ; **********
cd1e            Basic_NEXT
              ; **********

cd1e d0 04       BNE Find_NEXT_Variable
cd20 a0 00       LDY #0
cd22 f0 03       BEQ NEXT_10      ; use any variable, branch always

              ; ******************
cd24            Find_NEXT_Variable
              ; ******************

cd24 20 8b d0    JSR Get_Scalar_Address

cd27          NEXT_10
                 STAY(FORPNT)      ; save FOR/NEXT variable pointer
cd27 85 49       STA FORPNT
cd29 84 4a       STY FORPNT+1

cd2b 20 8a c3    JSR Find_Active_FOR
cd2e f0 05       BEQ NEXT_30       ; if FOR found continue
cd30 a2 0a       LDX #$0A          ; else set error $0A, next without for error

cd32          NEXT_20
cd32 4c 37 c4    JMP Basic_Error

              ; found this FOR variable

cd35          NEXT_30
cd35 9a          TXS               ; update stack pointer
cd36 8a          TXA               ; copy stack pointer
cd37 18          CLC
cd38 69 04       ADC #$04          ; point to STEP value
cd3a 48          PHA               ; save it
cd3b 69 06       ADC #$06          ; point to TO value
cd3d 85 24       STA INDEXB        ; save pointer to TO variable for compare
cd3f 68          PLA               ; restore pointer to STEP value
cd40 a0 01       LDY #$01          ; point to stack page
cd42 20 a2 db    JSR Load_FAC1_AY
cd45 ba          TSX               ; get stack pointer back
cd46 bd 09 01    LDA STACK+9,X     ; get step sign
cd49 85 66       STA FAC1SI        ; save FAC1 sign (b7)
cd4b a5 49       LDA FORPNT        ; get FOR/NEXT variable pointer low byte
cd4d a4 4a       LDY FORPNT+1      ; get FOR/NEXT variable pointer high byte
cd4f 20 67 d8    JSR Add_Var_AY_To_FAC1
cd52 20 d0 db    JSR Assign_FAC1_To_FOR_Index
cd55 a0 01       LDY #$01          ; point to stack page
cd57 20 5d dc    JSR Compare_FAC1_INDEXB_Y ; compare FAC1 with TO value
cd5a ba          TSX               ; get stack pointer back
cd5b 38          SEC
cd5c fd 09 01    SBC STACK+9,X     ; subtract step sign
cd5f f0 17       BEQ NEXT_50       ; if = loop complete, go unstack the FOR
cd61 bd 0f 01    LDA STACK+$0F,X   ; get FOR line low byte
cd64 85 39       STA CURLIN        ; save current line number low byte
cd66 bd 10 01    LDA STACK+$10,X   ; get FOR line high byte
cd69 85 3a       STA CURLIN+1      ; save current line number high byte
cd6b bd 12 01    LDA STACK+$12,X   ; get BASIC execute pointer low byte
cd6e 85 7a       STA TXTPTR        ; save BASIC execute pointer low byte
cd70 bd 11 01    LDA STACK+$11,X   ; get BASIC execute pointer high byte
cd73 85 7b       STA TXTPTR+1      ; save BASIC execute pointer high byte

cd75          NEXT_40
cd75 4c ae c7    JMP Interpreter_Loop

cd78          NEXT_50
cd78 8a          TXA               ; stack copy to A
cd79 69 11       ADC #$11          ; add $12, $11 + carry, to dump FOR structure
cd7b aa          TAX               ; copy back to index
cd7c 9a          TXS               ; copy to stack pointer
cd7d 20 79 00    JSR CHRGOT
cd80 c9 2c       CMP #','
cd82 d0 f1       BNE NEXT_40       ; if not "," go do interpreter inner loop
cd84 20 73 00    JSR CHRGET
cd87 20 24 cd    JSR Find_NEXT_Variable

              ; ************
cd8a            Eval_Numeric
              ; ************

cd8a 20 9e cd    JSR Eval_Expression

              ; **********
cd8d            Is_Numeric
              ; **********

cd8d 18          CLC
cd8e 24          .byte   $24       ; skip next byte

              ; ******************
cd8f            Assert_String_Type
              ; ******************

cd8f 38          SEC               ; string required

              ; **************
cd90            Check_Var_Type
              ; **************

cd90 24 0d       BIT VALTYP        ; test data type flag, $FF = string, $00 = numeric
cd92 30 03       BMI CVT_20        ; branch to string check
cd94 b0 03       BCS Type_Missmatch

cd96          CVT_10               ; OK
cd96 60          RTS ;Size    7 [Check_Var_Type]

cd97          CVT_20
cd97 b0 fd       BCS CVT_10        ; exit if string is required

cd99          Type_Missmatch
cd99 a2 16       LDX #$16          ; error code $16, type missmatch error
cd9b 4c 37 c4    JMP Basic_Error

              ; ***************
cd9e            Eval_Expression
              ; ***************

cd9e a6 7a       LDX TXTPTR        ; get BASIC execute pointer low byte
cda0 d0 02       BNE EvEx_05       ; skip next if not zero
cda2 c6 7b       DEC TXTPTR+1      ; else decrement BASIC execute pointer high byte

cda4          EvEx_05
cda4 c6 7a       DEC TXTPTR        ; decrement BASIC execute pointer low byte
cda6 a2 00       LDX #$00          ; set null precedence, flag done
cda8 24          .byte   $24       ; makes next line BIT VARPNT+1

cda9          EvEx_10
cda9 48          PHA               ; push compare evaluation byte if branch to here
cdaa 8a          TXA               ; copy precedence byte
cdab 48          PHA               ; push precedence byte
cdac a9 01       LDA #$01          ; 2 bytes
cdae 20 fb c3    JSR Check_Stack_Avail
cdb1 20 83 ce    JSR Evaluate
cdb4 a9 00       LDA #0
cdb6 85 4d       STA ACCSYM        ; clear comparrison evaluation flag

cdb8          EvEx_15
cdb8 20 79 00    JSR CHRGOT

cdbb          EvEx_20
cdbb 38          SEC
cdbc e9 b1       SBC #TK_GT        ; subtract token for ">"
cdbe 90 17       BCC EvEx_25       ; if < ">" skip comparrison test check
cdc0 c9 03       CMP #$03          ; compare with ">" to +3
cdc2 b0 13       BCS EvEx_25       ; if >= 3 skip comparrison test check
cdc4 c9 01       CMP #$01          ; compare with token for =
cdc6 2a          ROL A             ; *2, b0 = carry (=1 if token was = or <)
cdc7 49 01       EOR #$01          ; toggle b0
cdc9 45 4d       EOR ACCSYM        ; EOR with comparrison evaluation flag
cdcb c5 4d       CMP ACCSYM        ; compare with comparrison evaluation flag
cdcd 90 61       BCC Jump_Syntax_Error      ; if < saved flag do syntax error then warm start
cdcf 85 4d       STA ACCSYM        ; save new comparrison evaluation flag
cdd1 20 73 00    JSR CHRGET
cdd4 4c bb cd    JMP EvEx_20       ; go do next character

cdd7          EvEx_25
cdd7 a6 4d       LDX ACCSYM        ; get comparrison evaluation flag
cdd9 d0 2c       BNE EvEx_50       ; if compare function flagged go evaluate right hand side
cddb b0 7b       BCS Right_Operand      ; apply operator
cddd 69 07       ADC #$07          ; add # of operators (+, -, *, /, ^, AND or OR)
cddf 90 77       BCC Right_Operand      ; if < + operator go do the function
cde1 65 0d       ADC VALTYP        ; add data type flag, $FF = string, $00 = numeric
cde3 d0 03       BNE EvEx_30       ; if not string or not + token skip concatenate
cde5 4c 3d d6    JMP Concatenate   ; add strings, string 1 is in the descriptor, string 2

cde8          EvEx_30
cde8 69 ff       ADC #$FF          ; -1 (corrects for carry add)
cdea 85 22       STA INDEXA        ; save it
cdec 0a          ASL A             ; *2
cded 65 22       ADC INDEXA        ; *3
cdef a8          TAY               ; copy to index

cdf0          EvEx_35
cdf0 68          PLA               ; pull previous precedence
cdf1 d9 80 c0    CMP Basic_Operator_Table,Y  ; compare with precedence byte
cdf4 b0 67       BCS RiOp_20      ; if A >= go do the function
cdf6 20 8d cd    JSR Is_Numeric

cdf9          EvEx_40
cdf9 48          PHA               ; save precedence

cdfa          EvEx_45
cdfa 20 20 ce    JSR Call_Operator_Function
cdfd 68          PLA               ; restore precedence
cdfe a4 4b       LDY YSAVE         ; get precedence stacked flag
ce00 10 17       BPL EvEx_60       ; if stacked values go check the precedence
ce02 aa          TAX               ; copy precedence, set flags
ce03 f0 56       BEQ RiOp_10      ; exit if done
ce05 d0 5f       BNE RiOp_40      ; else pop FAC2 and return, branch always

ce07          EvEx_50
ce07 46 0d       LSR VALTYP        ; clear data type flag, $FF = string, $00 = numeric
ce09 8a          TXA               ; copy compare function flag
ce0a 2a          ROL A             ; <<1, shift data type flag into b0, 1 = string, 0 = num
ce0b a6 7a       LDX TXTPTR        ; get BASIC execute pointer low byte
ce0d d0 02       BNE EvEx_55       ; if no underflow skip the high byte decrement
ce0f c6 7b       DEC TXTPTR+1      ; else decrement BASIC execute pointer high byte

ce11          EvEx_55
ce11 c6 7a       DEC TXTPTR        ; decrement BASIC execute pointer low byte
ce13 a0 1b       LDY #$1B          ; set offset to = operator precedence entry
ce15 85 4d       STA ACCSYM        ; save new comparrison evaluation flag
ce17 d0 d7       BNE EvEx_35       ; branch always

ce19          EvEx_60
ce19 d9 80 c0    CMP Basic_Operator_Table,Y  ; compare with stacked function precedence
ce1c b0 48       BCS RiOp_40      ; if A >=, pop FAC2 and return
ce1e 90 d9       BCC EvEx_40       ; else go stack this one and continue, branch always

              ; **********************
ce20            Call_Operator_Function
              ; **********************

ce20 b9 82 c0    LDA Basic_Operator_Table+2,Y
ce23 48          PHA
ce24 b9 81 c0    LDA Basic_Operator_Table+1,Y
ce27 48          PHA
ce28 20 33 ce    JSR Apply_Operator
ce2b a5 4d       LDA ACCSYM        ; get comparrison evaluation flag
ce2d 4c a9 cd    JMP EvEx_10       ; continue evaluating expression

ce30          Jump_Syntax_Error
ce30 4c 08 cf    JMP Syntax_Error

              ; **************
ce33            Apply_Operator
              ; **************

ce33 a5 66       LDA FAC1SI        ; get FAC1 sign (b7)
ce35 be 80 c0    LDX Basic_Operator_Table,Y  ; get precedence byte

              ; *********
ce38            Push_FAC1
              ; *********

ce38 a8          TAY               ; copy sign
ce39 68          PLA               ; get return address low byte
ce3a 85 22       STA INDEXA        ; save it
ce3c e6 22       INC INDEXA        ; increment it as return-1 is pushed
ce3e 68          PLA               ; get return address high byte
ce3f 85 23       STA INDEXA+1      ; save it
ce41 98          TYA               ; restore sign
ce42 48          PHA               ; push sign

              ; ===================
ce43            Round_And_Push_FAC1
              ; ===================

ce43 20 1b dc    JSR Round_FAC1_Checked
                 PUSHW(FAC1M3)     ; push mantissa 4 & 3
ce46 a5 65       LDA FAC1M3+1
ce48 48          PHA
ce49 a5 64       LDA FAC1M3
ce4b 48          PHA

                 PUSHW(FAC1M1)     ; push mantissa 2 & 1
ce4c a5 63       LDA FAC1M1+1
ce4e 48          PHA
ce4f a5 62       LDA FAC1M1
ce51 48          PHA

ce52 a5 61       LDA FAC1EX        ; get FAC1 exponent
ce54 48          PHA               ; push it
ce55 6c 22 00    JMP (INDEXA)      ; return, sort of

              ; =============
ce58            Right_Operand
              ; =============

ce58 a0 ff       LDY #$FF          ; flag function
ce5a 68          PLA               ; pull precedence byte

ce5b          RiOp_10
ce5b f0 23       BEQ RiOp_50       ; exit if done

ce5d          RiOp_20
ce5d c9 64       CMP #$64          ; compare previous precedence with $64
ce5f f0 03       BEQ RiOp_30       ; if was $64 (< function) skip the type check
ce61 20 8d cd    JSR Is_Numeric

ce64          RiOp_30
ce64 84 4b       STY YSAVE         ; save precedence stacked flag

ce66          RiOp_40
ce66 68          PLA               ; pop byte
ce67 4a          LSR A             ; shift out comparison evaluation lowest bit
ce68 85 12       STA TANSGN        ; save the comparison evaluation flag
ce6a 68          PLA               ; pop exponent
ce6b 85 69       STA FAC2EX        ; save FAC2 exponent
                 PULLW(FAC2M1)     ; pull FAC2 mantissa 1 & 2
ce6d 68          PLA
ce6e 85 6a       STA FAC2M1
ce70 68          PLA
ce71 85 6b       STA FAC2M1+1

                 PULLW(FAC2M3)     ; pull FAC2 mantissa 3 & 4
ce73 68          PLA
ce74 85 6c       STA FAC2M3
ce76 68          PLA
ce77 85 6d       STA FAC2M3+1

ce79 68          PLA               ; pop sign
ce7a 85 6e       STA FAC2SI        ; save FAC2 sign (b7)
ce7c 45 66       EOR FAC1SI        ; EOR FAC1 sign (b7)
ce7e 85 6f       STA STRPTR        ; save sign compare (FAC1 EOR FAC2)

ce80          RiOp_50
ce80 a5 61       LDA FAC1EX        ; get FAC1 exponent
ce82 60          RTS ;Size   75 [Push_FAC1]

              ; ********
ce83            Evaluate
              ; ********

ce83 6c 0a 03    JMP (IEVAL)       ; normally Default_EVAL

              ; ************
ce86            Default_EVAL
              ; ************

ce86 a9 00       LDA #0
ce88 85 0d       STA VALTYP        ; clear data type flag, $FF = string, $00 = numeric

ce8a          EVA_10
ce8a 20 73 00    JSR CHRGET
ce8d b0 03       BCS EVA_30        ; if not numeric character continue

ce8f          EVA_20
ce8f 4c f3 dc    JMP Load_FAC1_From_String

ce92          EVA_30
ce92 20 13 d1    JSR Is_Alpha
ce95 90 03       BCC EVA_40
ce97 4c 28 cf    JMP Get_Var       ; variable name set-up and return

ce9a          EVA_40
ce9a c9 ff       CMP #TK_PI
ce9c d0 0f       BNE EVA_50        ; if not PI continue
                 LAYI(Float_PI)
ce9e a9 a8       LDA #<Float_PI
cea0 a0 ce       LDY #>Float_PI

cea2 20 a2 db    JSR Load_FAC1_AY
cea5 4c 73 00    JMP CHRGET

cea8 82 49 0f Float_PI .real 3.141592653

cead          EVA_50
cead c9 2e       CMP #'.'
ceaf f0 de       BEQ EVA_20        ; if so get FAC1 from string and return, e.g. was .123
ceb1 c9 ab       CMP #TK_MINUS
ceb3 f0 58       BEQ Prep_Minus_Operation
ceb5 c9 aa       CMP #TK_PLUS
ceb7 f0 d1       BEQ EVA_10        ; if + token ignore the leading +, +1 = 1
ceb9 c9 22       CMP #QUOTE
cebb d0 0f       BNE EVA_70        ; if not open quote continue

              ; ********************************
cebd            Make_String_Descriptor_From_Code
              ; ********************************

                 LDAY(TXTPTR)      ; get BASIC execute pointer
cebd a5 7a       LDA TXTPTR
cebf a4 7b       LDY TXTPTR+1

cec1 69 00       ADC #0            ; add carry to low byte
cec3 90 01       BCC EVA_60        ; branch if no overflow
cec5 c8          INY               ; increment high byte

cec6          EVA_60
cec6 20 87 d4    JSR Create_String_Descriptor
cec9 4c e2 d7    JMP Restore_Execution_Pointer

cecc          EVA_70
cecc c9 a8       CMP #TK_NOT       ; compare with token for NOT
cece d0 13       BNE EVA_80        ; if not token for NOT continue
ced0 a0 18       LDY #$18          ; offset to NOT function
ced2 d0 3b       BNE Prep_Operation      ; do set-up for function then execute, branch always

              ; ***********
ced4            Basic_EQUAL
              ; ***********

ced4 20 bf d1    JSR Eval_Integer
ced7 a5 65       LDA FAC1M4        ; get FAC1 mantissa 4
ced9 49 ff       EOR #$FF          ; invert it
cedb a8          TAY               ; copy it
cedc a5 64       LDA FAC1M3        ; get FAC1 mantissa 3
cede 49 ff       EOR #$FF          ; invert it
cee0 4c 91 d3    JMP Integer_To_Float

cee3          EVA_80
cee3 c9 a5       CMP #TK_FN        ; compare with token for FN
cee5 d0 03       BNE EVA_90        ; if not token for FN continue
cee7 4c f4 d3    JMP Eval_FNX      ; else go evaluate FNx

ceea          EVA_90
ceea c9 b4       CMP #TK_SGN       ; compare with token for SGN
ceec 90 03       BCC Eval_In_Parenthesis
ceee 4c a7 cf    JMP Function_Call

              ; *******************
cef1            Eval_In_Parenthesis
              ; *******************

cef1 20 fa ce    JSR Need_Left_Parenthesis
cef4 20 9e cd    JSR Eval_Expression

              ; **********************
cef7            Need_Right_Parenthesis
              ; **********************

cef7 a9 29       LDA #')'
cef9 2c          .byte   $2C       ; skip until Need_A

              ; *********************
cefa            Need_Left_Parenthesis
              ; *********************

cefa a9 28       LDA #'('
cefc 2c          .byte   $2C       ; skip until Need_A

              ; **********
cefd            Need_Comma
              ; **********

cefd a9 2c       LDA #','

              ; ******
ceff            Need_A
              ; ******

ceff a0 00       LDY #0
cf01 d1 7a       CMP (TXTPTR),Y    ; compare with BASIC byte
cf03 d0 03       BNE Syntax_Error
cf05 4c 73 00    JMP CHRGET        ; else next program byte and return

              ; ============
cf08            Syntax_Error
              ; ============

cf08 a2 0b       LDX #$0B          ; error code $0B, syntax error
cf0a 4c 37 c4    JMP Basic_Error

              ; ====================
cf0d            Prep_Minus_Operation
              ; ====================

cf0d a0 15       LDY #$15          ; set offset from base to > operator

cf0f          Prep_Operation
cf0f 68          PLA               ; dump return address low byte
cf10 68          PLA               ; dump return address high byte
cf11 4c fa cd    JMP EvEx_45      ; execute function then continue evaluation

              ; *******************
cf14            Is_Inside_BASIC_ROM
              ; *******************

cf14 38          SEC
cf15 a5 64       LDA FAC1M3        ; get variable address low byte
cf17 e9 00       SBC #<BASIC_ROM   ; subtract BASIC_ROM low byte
cf19 a5 65       LDA FAC1M4        ; get variable address high byte
cf1b e9 c0       SBC #>BASIC_ROM   ; subtract BASIC_ROM high byte
cf1d 90 08       BCC IIBR_Ret      ; exit if address < BASIC_ROM
cf1f a9 87       LDA #<CHRGET_ROM  ; get end of BASIC marker low byte
cf21 e5 64       SBC FAC1M3        ; subtract variable address low byte
cf23 a9 e3       LDA #>CHRGET_ROM  ; get end of BASIC marker high byte
cf25 e5 65       SBC FAC1M4        ; subtract variable address high byte

cf27          IIBR_Ret
cf27 60          RTS ;Size   20 [Is_Inside_BASIC_ROM]

              ; =======
cf28            Get_Var
              ; =======

cf28 20 8b d0    JSR Get_Scalar_Address
                 STAY(FAC1M3)      ; save variable pointer low byte
cf2b 85 64       STA FAC1M3
cf2d 84 65       STY FAC1M3+1

                 LDXY(VARNAM)      ; get current variable name first character
cf2f a6 45       LDX VARNAM
cf31 a4 46       LDY VARNAM+1

cf33 a5 0d       LDA VALTYP        ; get data type flag, $FF = string, $00 = numeric
cf35 f0 26       BEQ Load_Value    ; if numeric go handle a numeric variable
cf37 a9 00       LDA #0
cf39 85 70       STA FAC1M5        ; clear FAC1 rounding byte
cf3b 20 14 cf    JSR Is_Inside_BASIC_ROM
cf3e 90 1c       BCC GeVa_Ret      ; exit if not in BASIC ROM
cf40 e0 54       CPX #'T'          ; compare variable name first character with "T"
cf42 d0 18       BNE GeVa_Ret      ; exit if not "T"
cf44 c0 c9       CPY #'I'+$80      ; compare variable name second character with "I$"
cf46 d0 14       BNE GeVa_Ret      ; exit if not "I$"
cf48 20 84 cf    JSR Load_Jiffyclock
cf4b 84 5e       STY TMPVA2        ; clear exponent count adjust
cf4d 88          DEY               ; Y = $FF
cf4e 84 71       STY TMPPTD        ; set output string index, -1 to allow for pre increment
cf50 a0 06       LDY #6            ; HH:MM:SS is six digits
cf52 84 5d       STY TMPVA1        ; set number of characters before the decimal point
cf54 a0 24       LDY #Jiffy_Conversion_Table-Decimal_Conversion_Table
cf56 20 68 de    JSR Format_Jiffyclock
cf59 4c 6f d4    JMP BaST_10      ; exit via STR$() code tail

cf5c          GeVa_Ret
cf5c 60          RTS ;Size   73 [Is_Inside_BASIC_ROM]

              ; ==========
cf5d            Load_Value
              ; ==========

cf5d 24 0e       BIT INTFLG        ; test data type flag, $80 = integer, $00 = float
cf5f 10 0d       BPL Load_Float    ; if float go handle float
cf61 a0 00       LDY #0
cf63 b1 64       LDA (FAC1M3),Y    ; get integer variable low byte
cf65 aa          TAX               ; copy to X
cf66 c8          INY
cf67 b1 64       LDA (FAC1M3),Y    ; get integer variable high byte
cf69 a8          TAY               ; copy to Y
cf6a 8a          TXA               ; copy loa byte to A
cf6b 4c 91 d3    JMP Integer_To_Float

              ; ==========
cf6e            Load_Float
              ; ==========

cf6e 20 14 cf    JSR Is_Inside_BASIC_ROM
cf71 90 2d       BCC Load_Float_Var ; if not get pointer and unpack into FAC1
cf73 e0 54       CPX #'T'
cf75 d0 1b       BNE Check_ST_Var
cf77 c0 49       CPY #'I'          ; is it "TI" ?
cf79 d0 25       BNE Load_Float_Var
cf7b 20 84 cf    JSR Load_Jiffyclock
cf7e 98          TYA               ; clear A
cf7f a2 a0       LDX #$A0          ; set exponent to 32 bit value
cf81 4c 4f dc    JMP CITF_10       ; set exponent = X and normalise FAC1

              ; ***************
cf84            Load_Jiffyclock
              ; ***************

cf84 20 de ff    JSR RDTIM         ; Read system clock
cf87 86 64       STX FAC1M3        ; save jiffy clock mid byte as  FAC1 mantissa 3
cf89 84 63       STY FAC1M2        ; save jiffy clock high byte as  FAC1 mantissa 2
cf8b 85 65       STA FAC1M4        ; save jiffy clock low byte as  FAC1 mantissa 4
cf8d a0 00       LDY #$00          ; clear Y
cf8f 84 62       STY FAC1M1        ; clear FAC1 mantissa 1
cf91 60          RTS ;Size   14 [Load_Jiffyclock]

              ; ============
cf92            Check_ST_Var
              ; ============

cf92 e0 53       CPX #'S'
cf94 d0 0a       BNE Load_Float_Var
cf96 c0 54       CPY #'T'          ; is it "ST" ?
cf98 d0 06       BNE Load_Float_Var
cf9a 20 b7 ff    JSR READST
cf9d 4c 3c dc    JMP A_To_FAC1

              ; ==============
cfa0            Load_Float_Var
              ; ==============

                 LDAY(FAC1M3)      ; get variable pointer
cfa0 a5 64       LDA FAC1M3
cfa2 a4 65       LDY FAC1M3+1

cfa4 4c a2 db    JMP Load_FAC1_AY

              ; =============
cfa7            Function_Call
              ; =============

cfa7 0a          ASL A             ; offset = 2 * (token  - $80) : bit 7 shifted out
cfa8 48          PHA               ; save function offset
cfa9 aa          TAX               ; copy function offset
cfaa 20 73 00    JSR CHRGET
cfad e0 8f       CPX #[[TK_CHRS - $80] * 2] + 1 ; chr$ index + 1
cfaf 90 20       BCC FuCa_10       ; branch if not left$, right$, mid$
cfb1 20 fa ce    JSR Need_Left_Parenthesis
cfb4 20 9e cd    JSR Eval_Expression
cfb7 20 fd ce    JSR Need_Comma
cfba 20 8f cd    JSR Assert_String_Type
cfbd 68          PLA               ; restore function offset
cfbe aa          TAX               ; copy it
                 PUSHW(FAC1M3)     ; push string pointer
cfbf a5 65       LDA FAC1M3+1
cfc1 48          PHA
cfc2 a5 64       LDA FAC1M3
cfc4 48          PHA

cfc5 8a          TXA               ; restore function offset
cfc6 48          PHA               ; save function offset
cfc7 20 9e d7    JSR Get_Byte_Value
cfca 68          PLA               ; restore function offset
cfcb a8          TAY               ; copy function offset
cfcc 8a          TXA               ; copy byte parameter to A
cfcd 48          PHA               ; push byte parameter
cfce 4c d6 cf    JMP FuCa_20       ; go call function

cfd1          FuCa_10
cfd1 20 f1 ce    JSR Eval_In_Parenthesis
cfd4 68          PLA               ; restore function offset
cfd5 a8          TAY               ; copy to index

cfd6          FuCa_20
cfd6 b9 ea bf    LDA Basic_Function_Table-2*[TK_SGN-$80],Y    ; .. -$68
cfd9 85 55       STA FUNJMP
cfdb b9 eb bf    LDA Basic_Function_Table-2*[TK_SGN-$80]+1,Y  ; .. -$67
cfde 85 56       STA FUNJMP+1
cfe0 20 54 00    JSR JUMPER
cfe3 4c 8d cd    JMP Is_Numeric

              ; ********
cfe6            Basic_OR
              ; ********

cfe6 a0 ff       LDY #$FF          ; set Y for OR
cfe8 2c          .byte   $2C       ; skip next statement

              ; *********
cfe9            Basic_AND
              ; *********

cfe9 a0 00       LDY #$00          ; clear Y for AND
cfeb 84 0b       STY COUNT         ; set AND/OR invert value
cfed 20 bf d1    JSR Eval_Integer
cff0 a5 64       LDA FAC1M3        ; get FAC1 mantissa 3
cff2 45 0b       EOR COUNT         ; EOR low byte
cff4 85 07       STA CHARAC        ; save it
cff6 a5 65       LDA FAC1M4        ; get FAC1 mantissa 4
cff8 45 0b       EOR COUNT         ; EOR high byte
cffa 85 08       STA ENDCHR        ; save it
cffc 20 fc db    JSR FAC2_To_FAC1
cfff 20 bf d1    JSR Eval_Integer
d002 a5 65       LDA FAC1M4        ; get FAC1 mantissa 4
d004 45 0b       EOR COUNT         ; EOR high byte
d006 25 08       AND ENDCHR        ; AND with expression 1 high byte
d008 45 0b       EOR COUNT         ; EOR result high byte
d00a a8          TAY               ; save in Y
d00b a5 64       LDA FAC1M3        ; get FAC1 mantissa 3
d00d 45 0b       EOR COUNT         ; EOR low byte
d00f 25 07       AND CHARAC        ; AND with expression 1 low byte
d011 45 0b       EOR COUNT         ; EOR result low byte
d013 4c 91 d3    JMP Integer_To_Float

              ; **********
d016            Basic_LESS
              ; **********

d016 20 90 cd    JSR Check_Var_Type
d019 b0 13       BCS BaLE_10       ; if string go do string compare
d01b a5 6e       LDA FAC2SI        ; get FAC2 sign (b7)
d01d 09 7f       ORA #$7F          ; set all non sign bits
d01f 25 6a       AND FAC2M1        ; and FAC2 mantissa 1 (AND in sign bit)
d021 85 6a       STA FAC2M1        ; save FAC2 mantissa 1
                 LAYI(FAC2EX)
d023 a9 69       LDA #<FAC2EX
d025 a0 00       LDY #>FAC2EX

d027 20 5b dc    JSR Compare_FAC1_AY
d02a aa          TAX               ; copy the result
d02b 4c 61 d0    JMP BaLE_40       ; go evaluate result

d02e          BaLE_10              ; compare strings
d02e a9 00       LDA #0
d030 85 0d       STA VALTYP        ; clear data type flag, $FF = string, $00 = numeric
d032 c6 4d       DEC ACCSYM        ; clear < bit in comparrison evaluation flag
d034 20 a6 d6    JSR Get_String_Descriptor
d037 85 61       STA FAC1EX        ; save length
d039 86 62       STX FAC1M1        ; save string pointer low byte
d03b 84 63       STY FAC1M2        ; save string pointer high byte
d03d a5 6c       LDA FAC2M3        ; get descriptor pointer low byte
d03f a4 6d       LDY FAC2M4        ; get descriptor pointer high byte
d041 20 aa d6    JSR Get_String_Descriptor_AY
d044 86 6c       STX FAC2M3        ; save string pointer low byte
d046 84 6d       STY FAC2M4        ; save string pointer high byte
d048 aa          TAX               ; copy length
d049 38          SEC
d04a e5 61       SBC FAC1EX        ; subtract string 1 length
d04c f0 08       BEQ BaLE_20       ; if str 1 length = string 2 length go compare the strings
d04e a9 01       LDA #1            ; set str 1 length > string 2 length
d050 90 04       BCC BaLE_20       ; if so return + 1 if otherwise equal
d052 a6 61       LDX FAC1EX        ; get string 1 length
d054 a9 ff       LDA #$FF          ; set str 1 length < string 2 length

d056          BaLE_20
d056 85 66       STA FAC1SI        ; save length compare
d058 a0 ff       LDY #$FF          ; set index
d05a e8          INX               ; adjust for loop

d05b          BaLE_30
d05b c8          INY
d05c ca          DEX               ; decrement count
d05d d0 07       BNE BaLE_50       ; if still bytes to do go compare them
d05f a6 66       LDX FAC1SI        ; get length compare back

d061          BaLE_40
d061 30 0f       BMI BaLE_60       ; branch if str 1 < str 2
d063 18          CLC               ; flag str 1 <= str 2
d064 90 0c       BCC BaLE_60       ; go evaluate result, branch always

d066          BaLE_50
d066 b1 6c       LDA (FAC2M3),Y    ; get string 2 byte
d068 d1 62       CMP (FAC1M1),Y    ; compare with string 1 byte
d06a f0 ef       BEQ BaLE_30       ; loop if bytes =
d06c a2 ff       LDX #$FF          ; set str 1 < string 2
d06e b0 02       BCS BaLE_60       ; branch if so

d070 a2 01       LDX #$01          ; set str 1 > string 2
d072          BaLE_60
d072 e8          INX               ; x = 0, 1 or 2
d073 8a          TXA               ; copy to A
d074 2a          ROL A             ; * 2 (1, 2 or 4)
d075 25 12       AND TANSGN        ; AND with the comparison evaluation flag
d077 f0 02       BEQ BaLE_70       ; branch if 0 (compare is false)

d079 a9 ff       LDA #$FF          ; else set result true
d07b          BaLE_70
d07b 4c 3c dc    JMP A_To_FAC1

d07e          DIM_00
d07e 20 fd ce    JSR Need_Comma

              ; *********
d081            Basic_DIM
              ; *********

d081 aa          TAX               ; copy "DIM" flag to X
d082 20 90 d0    JSR Get_Array_Address
d085 20 79 00    JSR CHRGOT
d088 d0 f4       BNE DIM_00      ; scan for "," and loop if not null
d08a 60          RTS ;Size   10 [Basic_DIM]

              ; ******************
d08b            Get_Scalar_Address
              ; ******************

d08b a2 00       LDX #$00          ; set DIM flag = $00
d08d 20 79 00    JSR CHRGOT        ; 1st. character

              ; -----------------
d090            Get_Array_Address
              ; -----------------

d090 86 0c       STX DIMFLG        ; save DIM flag

              ; --------------
d092            Get_FN_Address
              ; --------------

d092 85 45       STA VARNAM        ; save 1st character
d094 20 79 00    JSR CHRGOT
d097 20 13 d1    JSR Is_Alpha
d09a b0 03       BCS Get_Address      ; if ok continue

d09c          Var_Syntax_Error
d09c 4c 08 cf    JMP Syntax_Error

              ; ===========
d09f            Get_Address
              ; ===========

d09f a2 00       LDX #0            ; clear 2nd character temp
d0a1 86 0d       STX VALTYP        ; clear data type flag, $FF = string, $00 = numeric
d0a3 86 0e       STX INTFLG        ; clear data type flag, $80 = integer, $00 = float
d0a5 20 73 00    JSR CHRGET        ; 2nd character
d0a8 90 05       BCC GAdd_05       ; if character = "0"-"9" (ok) go save 2nd character
d0aa 20 13 d1    JSR Is_Alpha
d0ad 90 0b       BCC GAdd_15       ; if <"A" or >"Z" go check if string

d0af          GAdd_05
d0af aa          TAX               ; copy 2nd character

d0b0          GAdd_10
d0b0 20 73 00    JSR CHRGET        ; 3rd character
d0b3 90 fb       BCC GAdd_10       ; loop if character = "0"-"9" (ignore)
d0b5 20 13 d1    JSR Is_Alpha
d0b8 b0 f6       BCS GAdd_10       ; loop if character = "A"-"Z" (ignore)

d0ba          GAdd_15
d0ba c9 24       CMP #'$'
d0bc d0 06       BNE GAdd_20       ; if not string go check integer
d0be a9 ff       LDA #$FF          ; set data type = string
d0c0 85 0d       STA VALTYP        ; set data type flag, $FF = string, $00 = numeric
d0c2 d0 10       BNE GAdd_25       ; branch always

d0c4          GAdd_20
d0c4 c9 25       CMP #'%'
d0c6 d0 13       BNE GAdd_30       ; if not integer go check for an array
d0c8 a5 10       LDA SUBFLG        ; get subscript/FNX flag
d0ca d0 d0       BNE Var_Syntax_Error      ; if ?? do syntax error then warm start
d0cc a9 80       LDA #$80          ; set integer type
d0ce 85 0e       STA INTFLG        ; set data type = integer
d0d0 05 45       ORA VARNAM        ; OR current variable name first byte
d0d2 85 45       STA VARNAM        ; save current variable name first byte

d0d4          GAdd_25
d0d4 8a          TXA               ; get 2nd character back
d0d5 09 80       ORA #$80          ; set top bit, indicate string or integer variable
d0d7 aa          TAX               ; copy back to 2nd character temp
d0d8 20 73 00    JSR CHRGET

d0db          GAdd_30
d0db 86 46       STX VARNAM+1      ; save 2nd character
d0dd 38          SEC
d0de 05 10       ORA SUBFLG        ; or with subscript/FNX flag - or FN name
d0e0 e9 28       SBC #'('
d0e2 d0 03       BNE GAdd_35       ; if not "(" go find a plain numeric variable
d0e4 4c d1 d1    JMP Find_Array

d0e7          GAdd_35
d0e7 a0 00       LDY #0
d0e9 84 10       STY SUBFLG        ; clear subscript/FNX flag
                 LDAX(VARTAB)      ; get start of variables
d0eb a5 2d       LDA VARTAB
d0ed a6 2e       LDX VARTAB+1


d0ef          GAdd_40
d0ef 86 60       STX TMPPTC+1      ; save search address high byte

d0f1          GAdd_45
d0f1 85 5f       STA TMPPTC        ; save search address low byte
d0f3 e4 30       CPX ARYTAB+1      ; compare with end of variables high byte
d0f5 d0 04       BNE GAdd_50       ; skip next compare if <>
d0f7 c5 2f       CMP ARYTAB        ; compare low address with end of variables low byte
d0f9 f0 22       BEQ Create_Var      ; if not found go make new variable

d0fb          GAdd_50
d0fb a5 45       LDA VARNAM        ; get 1st character of variable to find
d0fd d1 5f       CMP (TMPPTC),Y    ; compare with variable name 1st character
d0ff d0 08       BNE GAdd_55       ; if no match go try the next variable
d101 a5 46       LDA VARNAM+1      ; get 2nd character of variable to find
d103 c8          INY               ; index to point to variable name 2nd character
d104 d1 5f       CMP (TMPPTC),Y    ; compare with variable name 2nd character
d106 f0 7d       BEQ CrVa_70      ; if match go return the variable
d108 88          DEY               ; else decrement index (now = $00)

d109          GAdd_55
d109 18          CLC
d10a a5 5f       LDA TMPPTC        ; get search address low byte
d10c 69 07       ADC #7            ; +7, offset to next variable name
d10e 90 e1       BCC GAdd_45       ; loop if no overflow to high byte
d110 e8          INX               ; else increment high byte
d111 d0 dc       BNE GAdd_40       ; loop always, RAM doesn't extend to $FFFF

              ; ********
d113            Is_Alpha
              ; ********

d113 c9 41       CMP #'A'
d115 90 05       BCC IA_RET
d117 e9 5b       SBC #$5B          ; subtract "Z"+1
d119 38          SEC
d11a e9 a5       SBC #$A5          ; subtract $A5 (restore byte)
                                   ; carry clear if byte > $5A
d11c          IA_RET
d11c 60          RTS ;Size   10 [Is_Alpha]

              ; ==========
d11d            Create_Var
              ; ==========

d11d 68          PLA               ; pop return address low byte
d11e 48          PHA               ; push return address low byte
d11f c9 2a       CMP #<[Get_Var+2] ; compare with expected calling routine return low byte
d121 d0 05       BNE CrVa_20       ; if not get variable go create new variable

              ; this will only drop through if the call was from Get_Var and is only
              ; called from there if it is searching for a variable from the right
              ; hand side of a LET a=b statement, it prevents the creation of
              ; variables not assigned a value. value returned by this is either
              ; numeric zero, exponent byte is 0, or null string, descriptor length
              ; byte is 0. in fact a pointer to any 0 byte would have done.

d123          CrVa_10
                 LAYI(NULL_Descriptor)
d123 a9 13       LDA #<NULL_Descriptor
d125 a0 df       LDY #>NULL_Descriptor

d127 60          RTS ;Size   21 [Is_Alpha]

d128          CrVa_20
                 LDAY(VARNAM)      ; get variable name first character
d128 a5 45       LDA VARNAM
d12a a4 46       LDY VARNAM+1

d12c c9 54       CMP #'T'
d12e d0 0b       BNE CrVa_40
d130 c0 c9       CPY #'I'+$80      ; is it TI$ ?
d132 f0 ef       BEQ CrVa_10
d134 c0 49       CPY #'I'
d136 d0 03       BNE CrVa_40       ; is it TI ?

d138          CrVa_30
d138 4c 08 cf    JMP Syntax_Error

d13b          CrVa_40
d13b c9 53       CMP #'S'          ; compare first character with "S"
d13d d0 04       BNE CrVa_50      ; if not "S" continue
d13f c0 54       CPY #'T'          ; compare second character with "T"
d141 f0 f5       BEQ CrVa_30       ; if name is "ST" do syntax error

d143          CrVa_50
                 LDAY(ARYTAB)
d143 a5 2f       LDA ARYTAB
d145 a4 30       LDY ARYTAB+1

                 STAY(TMPPTC)
d147 85 5f       STA TMPPTC
d149 84 60       STY TMPPTC+1

                 LDAY(STREND)
d14b a5 31       LDA STREND
d14d a4 32       LDY STREND+1

                 STAY(TMPPTB)      ; save old block end
d14f 85 5a       STA TMPPTB
d151 84 5b       STY TMPPTB+1

d153 18          CLC
d154 69 07       ADC #7            ; +7, space for one variable
d156 90 01       BCC CrVa_60       ; if no overflow skip the high byte increment
d158 c8          INY               ; else increment high byte

d159          CrVa_60
                 STAY(TMPPTA)      ; set new block end
d159 85 58       STA TMPPTA
d15b 84 59       STY TMPPTA+1

d15d 20 b8 c3    JSR Open_Up_Space
                 LDAY(TMPPTA)      ; get new start
d160 a5 58       LDA TMPPTA
d162 a4 59       LDY TMPPTA+1

d164 c8          INY               ; correct high byte
                 STAY(ARYTAB)      ; set end of variables
d165 85 2f       STA ARYTAB
d167 84 30       STY ARYTAB+1

d169 a0 00       LDY #0
d16b a5 45       LDA VARNAM        ; get variable name 1st character
d16d 91 5f       STA (TMPPTC),Y    ; save variable name 1st character
d16f c8          INY
d170 a5 46       LDA VARNAM+1      ; get variable name 2nd character
d172 91 5f       STA (TMPPTC),Y    ; save variable name 2nd character
d174 a9 00       LDA #0
d176 c8          INY
d177 91 5f       STA (TMPPTC),Y    ; initialise variable byte
d179 c8          INY
d17a 91 5f       STA (TMPPTC),Y    ; initialise variable byte
d17c c8          INY
d17d 91 5f       STA (TMPPTC),Y    ; initialise variable byte
d17f c8          INY
d180 91 5f       STA (TMPPTC),Y    ; initialise variable byte
d182 c8          INY
d183 91 5f       STA (TMPPTC),Y    ; initialise variable byte

d185          CrVa_70
d185 a5 5f       LDA TMPPTC        ; get variable address low byte
d187 18          CLC
d188 69 02       ADC #$02          ; +2, offset past variable name bytes
d18a a4 60       LDY TMPPTC+1      ; get variable address high byte
d18c 90 01       BCC CrVa_80       ; if no overflow skip the high byte increment
d18e c8          INY               ; else increment high byte

d18f          CrVa_80
                 STAY(VARPNT)
d18f 85 47       STA VARPNT
d191 84 48       STY VARPNT+1

d193 60          RTS ;Size  129 [Is_Alpha]

              ; **********************
d194            Array_Pointer_To_First
              ; **********************

d194 a5 0b       LDA COUNT         ; get # of dimensions (1, 2 or 3)
d196 0a          ASL A             ; *2 (also clears the carry !)
d197 69 05       ADC #$05          ; +5 (result is 7, 9 or 11 here)
d199 65 5f       ADC TMPPTC        ; add array start pointer low byte
d19b a4 60       LDY TMPPTC+1      ; get array pointer high byte
d19d 90 01       BCC APTF_10       ; if no overflow skip the high byte increment
d19f c8          INY               ; else increment high byte

d1a0          APTF_10
                 STAY(TMPPTA)      ; save array data pointer
d1a0 85 58       STA TMPPTA
d1a2 84 59       STY TMPPTA+1

d1a4 60          RTS ;Size   17 [Array_Pointer_To_First]

d1a5 90 80 00 Float_M32768 .real -32768

              ; ****************
d1aa            Float_To_Integer
              ; ****************

d1aa 20 bf d1    JSR Eval_Integer
d1ad a5 64       LDA FAC1M3        ; get result low byte
d1af a4 65       LDY FAC1M4        ; get result high byte
d1b1 60          RTS ;Size    8 [Float_To_Integer]

              ; *********************
d1b2            Eval_Positive_Integer
              ; *********************

d1b2 20 73 00    JSR CHRGET
d1b5 20 9e cd    JSR Eval_Expression

              ; ***************************
d1b8            Eval_Positive_Integer_Check
              ; ***************************

d1b8 20 8d cd    JSR Is_Numeric
d1bb a5 66       LDA FAC1SI        ; get FAC1 sign (b7)
d1bd 30 0d       BMI EvIn_10       ; do illegal quantity error negative

              ; evaluate integer expression, no sign check

              ; ************
d1bf            Eval_Integer
              ; ************

d1bf a5 61       LDA FAC1EX        ; get FAC1 exponent
d1c1 c9 90       CMP #$90          ; compare with exponent = 2^16 (n>2^15)
d1c3 90 09       BCC EvIn_20       ; if n<2^16 go convert FAC1 floating to fixed and return
                 LAYI(Float_M32768); set pointer -32768
d1c5 a9 a5       LDA #<Float_M32768
d1c7 a0 d1       LDY #>Float_M32768

d1c9 20 5b dc    JSR Compare_FAC1_AY

d1cc          EvIn_10
d1cc d0 7a       BNE Illegal_Quantity

d1ce          EvIn_20
d1ce 4c 9b dc    JMP FAC1_To_Integer

              ; **********
d1d1            Find_Array
              ; **********

d1d1 a5 0c       LDA DIMFLG        ; get DIM flag
d1d3 05 0e       ORA INTFLG        ; OR with data type flag
d1d5 48          PHA               ; push it
d1d6 a5 0d       LDA VALTYP        ; get data type flag, $FF = string, $00 = numeric
d1d8 48          PHA               ; push it
d1d9 a0 00       LDY #0            ; clear dimensions count

d1db          FiAr_05              ; get the array dimensions and stack them
d1db 98          TYA               ; copy dimensions count
d1dc 48          PHA               ; save it
                 PUSHW(VARNAM)     ; push array name
d1dd a5 46       LDA VARNAM+1
d1df 48          PHA
d1e0 a5 45       LDA VARNAM
d1e2 48          PHA

d1e3 20 b2 d1    JSR Eval_Positive_Integer
                 PULLW(VARNAM)     ; pull array name
d1e6 68          PLA
d1e7 85 45       STA VARNAM
d1e9 68          PLA
d1ea 85 46       STA VARNAM+1

d1ec 68          PLA               ; pull dimensions count
d1ed a8          TAY               ; restore it
d1ee ba          TSX               ; copy stack pointer
d1ef bd 02 01    LDA STACK+2,X     ; get DIM flag
d1f2 48          PHA               ; push it
d1f3 bd 01 01    LDA STACK+1,X     ; get data type flag
d1f6 48          PHA               ; push it
d1f7 a5 64       LDA FAC1M3        ; get this dimension size high byte
d1f9 9d 02 01    STA STACK+2,X     ; stack before flag bytes
d1fc a5 65       LDA FAC1M4        ; get this dimension size low byte
d1fe 9d 01 01    STA STACK+1,X     ; stack before flag bytes
d201 c8          INY               ; increment dimensions count
d202 20 79 00    JSR CHRGOT
d205 c9 2c       CMP #','
d207 f0 d2       BEQ FiAr_05       ; if found go do next dimension
d209 84 0b       STY COUNT         ; store dimensions count
d20b 20 f7 ce    JSR Need_Right_Parenthesis
d20e 68          PLA               ; pull data type flag
d20f 85 0d       STA VALTYP        ; restore data type flag, $FF = string, $00 = numeric
d211 68          PLA               ; pull data type flag
d212 85 0e       STA INTFLG        ; restore data type flag, $80 = integer, $00 = float
d214 29 7f       AND #$7F          ; mask dim flag
d216 85 0c       STA DIMFLG        ; restore DIM flag
d218 a6 2f       LDX ARYTAB        ; set end of variables low byte
d21a a5 30       LDA ARYTAB+1      ; set end of variables high byte

d21c          FiAr_10
d21c 86 5f       STX TMPPTC        ; save as array start pointer low byte
d21e 85 60       STA TMPPTC+1      ; save as array start pointer high byte
d220 c5 32       CMP STREND+1      ; compare with end of arrays high byte
d222 d0 04       BNE FiAr_15       ; if not reached array memory end continue searching
d224 e4 31       CPX STREND        ; else compare with end of arrays low byte
d226 f0 39       BEQ FiAr_30       ; go build array if not found

d228          FiAr_15
d228 a0 00       LDY #0
d22a b1 5f       LDA (TMPPTC),Y    ; get array name first byte
d22c c8          INY
d22d c5 45       CMP VARNAM        ; compare with this array name first byte
d22f d0 06       BNE FiAr_20       ; if no match go try the next array
d231 a5 46       LDA VARNAM+1      ; else get this array name second byte
d233 d1 5f       CMP (TMPPTC),Y    ; compare with array name second byte
d235 f0 16       BEQ FiAr_25       ; array found so branch

d237          FiAr_20
d237 c8          INY
d238 b1 5f       LDA (TMPPTC),Y    ; get array size low byte
d23a 18          CLC
d23b 65 5f       ADC TMPPTC        ; add array start pointer low byte
d23d aa          TAX               ; copy low byte to X
d23e c8          INY
d23f b1 5f       LDA (TMPPTC),Y    ; get array size high byte
d241 65 60       ADC TMPPTC+1      ; add array memory pointer high byte
d243 90 d7       BCC FiAr_10      ; if no overflow go check next array

              ; =============
d245            Bad_Subscript
              ; =============

d245 a2 12       LDX #$12          ; error $12, bad subscript error
d247 2c          .byte   $2C       ; skip next statement

              ; ================
d248            Illegal_Quantity
              ; ================

d248 a2 0e       LDX #$0E          ; error $0E, illegal quantity error

d24a          Jump_Basic_Error
d24a 4c 37 c4    JMP Basic_Error

d24d          FiAr_25
d24d a2 13       LDX #$13          ; set error $13, double dimension error
d24f a5 0c       LDA DIMFLG        ; get DIM flag
d251 d0 f7       BNE Jump_Basic_Error
d253 20 94 d1    JSR Array_Pointer_To_First
d256 a5 0b       LDA COUNT         ; get dimensions count
d258 a0 04       LDY #4            ; set index to array's # of dimensions
d25a d1 5f       CMP (TMPPTC),Y    ; compare with no of dimensions
d25c d0 e7       BNE Bad_Subscript ; if wrong do bad subscript error
d25e 4c ea d2    JMP Find_Array_Element

d261          FiAr_30
d261 20 94 d1    JSR Array_Pointer_To_First
d264 20 08 c4    JSR Check_Mem_Avail
d267 a0 00       LDY #0
d269 84 72       STY TMPPTD+1      ; clear array data size high byte
d26b a2 05       LDX #5            ; set default element size
d26d a5 45       LDA VARNAM        ; get variable name 1st byte
d26f 91 5f       STA (TMPPTC),Y    ; save array name 1st byte
d271 10 01       BPL FiAr_35       ; branch if not string or floating point array
d273 ca          DEX               ; decrement element size, $04

d274          FiAr_35
d274 c8          INY
d275 a5 46       LDA VARNAM+1      ; get variable name 2nd byte
d277 91 5f       STA (TMPPTC),Y    ; save array name 2nd byte
d279 10 02       BPL FiAr_40       ; branch if not integer or string
d27b ca          DEX               ; decrement element size, $03
d27c ca          DEX               ; decrement element size, $02

d27d          FiAr_40
d27d 86 71       STX TMPPTD        ; save element size
d27f a5 0b       LDA COUNT         ; get dimensions count
d281 c8          INY
d282 c8          INY               ; .. to array  ..
d283 c8          INY               ; .. dimension count
d284 91 5f       STA (TMPPTC),Y    ; save array dimension count

d286          FiAr_45
d286 a2 0b       LDX #11           ; set default dimension size low byte (0:10)
d288 a9 00       LDA #0            ; set default dimension size high byte
d28a 24 0c       BIT DIMFLG        ; test DIM flag
d28c 50 08       BVC FiAr_50       ; if default to be used don't pull a dimension
d28e 68          PLA               ; pull dimension size low byte
d28f 18          CLC
d290 69 01       ADC #1            ; add 1, allow for zeroeth element
d292 aa          TAX               ; copy low byte to X
d293 68          PLA               ; pull dimension size high byte
d294 69 00       ADC #0            ; add carry to high byte

d296          FiAr_50
d296 c8          INY               ; incement index to dimension size high byte
d297 91 5f       STA (TMPPTC),Y    ; save dimension size high byte
d299 c8          INY               ; incement index to dimension size low byte
d29a 8a          TXA               ; copy dimension size low byte
d29b 91 5f       STA (TMPPTC),Y    ; save dimension size low byte
d29d 20 4c d3    JSR Compute_Array_Size
d2a0 86 71       STX TMPPTD        ; save result low byte
d2a2 85 72       STA TMPPTD+1      ; save result high byte
d2a4 a4 22       LDY INDEXA        ; restore index
d2a6 c6 0b       DEC COUNT         ; decrement dimensions count
d2a8 d0 dc       BNE FiAr_45       ; loop if not all done
d2aa 65 59       ADC TMPPTA+1      ; add array data pointer high byte
d2ac b0 5d       BCS FiAE_30       ; if overflow do out of memory error then warm start
d2ae 85 59       STA TMPPTA+1      ; save array data pointer high byte
d2b0 a8          TAY               ; copy array data pointer high byte
d2b1 8a          TXA               ; copy array size low byte
d2b2 65 58       ADC TMPPTA        ; add array data pointer low byte
d2b4 90 03       BCC FiAr_55       ; if no rollover skip the high byte increment
d2b6 c8          INY               ; else increment next array pointer high byte
d2b7 f0 52       BEQ FiAE_30       ; if rolled over do out of memory error then warm start

d2b9          FiAr_55
d2b9 20 08 c4    JSR Check_Mem_Avail
                 STAY(STREND)      ; now we need to zero all the elements in it
d2bc 85 31       STA STREND
d2be 84 32       STY STREND+1

d2c0 a9 00       LDA #0            ; for array clear
d2c2 e6 72       INC TMPPTD+1      ; increment array size high byte, now block count
d2c4 a4 71       LDY TMPPTD        ; get array size low byte, now index to block
d2c6 f0 05       BEQ FiAr_65       ; if $00 go do the high byte decrement

d2c8          FiAr_60
d2c8 88          DEY               ; decrement index, do 0 to n-1
d2c9 91 58       STA (TMPPTA),Y    ; clear array element byte
d2cb d0 fb       BNE FiAr_60       ; loop until this block done

d2cd          FiAr_65
d2cd c6 59       DEC TMPPTA+1      ; decrement array pointer high byte
d2cf c6 72       DEC TMPPTD+1      ; decrement block count high byte
d2d1 d0 f5       BNE FiAr_60       ; loop until all blocks done
d2d3 e6 59       INC TMPPTA+1      ; correct for last loop
d2d5 38          SEC
d2d6 a5 31       LDA STREND        ; get end of arrays low byte
d2d8 e5 5f       SBC TMPPTC        ; subtract array start low byte
d2da a0 02       LDY #$02          ; index to array size low byte
d2dc 91 5f       STA (TMPPTC),Y    ; save array size low byte
d2de a5 32       LDA STREND+1      ; get end of arrays high byte
d2e0 c8          INY               ; index to array size high byte
d2e1 e5 60       SBC TMPPTC+1      ; subtract array start high byte
d2e3 91 5f       STA (TMPPTC),Y    ; save array size high byte
d2e5 a5 0c       LDA DIMFLG        ; get default DIM flag
d2e7 d0 62       BNE FiAE_Ret      ; exit if this was a DIM command
d2e9 c8          INY               ; set index to # of dimensions, the dimension indeces
                                   ; are on the stack and will be removed as the position
                                   ; of the array element is calculated

              ; ==================
d2ea            Find_Array_Element
              ; ==================

d2ea b1 5f       LDA (TMPPTC),Y    ; get array's dimension count
d2ec 85 0b       STA COUNT         ; save it
d2ee a9 00       LDA #0
d2f0 85 71       STA TMPPTD        ; clear array data pointer low byte

d2f2          FiAE_10
d2f2 85 72       STA TMPPTD+1      ; save array data pointer high byte
d2f4 c8          INY
d2f5 68          PLA               ; pull array index low byte
d2f6 aa          TAX               ; copy to X
d2f7 85 64       STA FAC1M3        ; save index low byte to FAC1 mantissa 3
d2f9 68          PLA               ; pull array index high byte
d2fa 85 65       STA FAC1M4        ; save index high byte to FAC1 mantissa 4
d2fc d1 5f       CMP (TMPPTC),Y    ; compare with array bound high byte
d2fe 90 0e       BCC FiAE_40       ; if within bounds continue
d300 d0 06       BNE FiAE_20       ; if outside bounds do bad subscript error
d302 c8          INY               ; index to array bound low byte
d303 8a          TXA               ; get array index low byte
d304 d1 5f       CMP (TMPPTC),Y    ; compare with array bound low byte
d306 90 07       BCC FiAE_50       ; if within bounds continue

d308          FiAE_20
d308 4c 45 d2    JMP Bad_Subscript

d30b          FiAE_30
d30b 4c 35 c4    JMP Error_Out_Of_Memory

d30e          FiAE_40
d30e c8          INY               ; index to array bound low byte

d30f          FiAE_50
d30f a5 72       LDA TMPPTD+1      ; get array data pointer high byte
d311 05 71       ORA TMPPTD        ; OR with array data pointer low byte
d313 18          CLC
d314 f0 0a       BEQ FiAE_60       ; if array data pointer = null skip the multiply
d316 20 4c d3    JSR Compute_Array_Size
d319 8a          TXA               ; get result low byte
d31a 65 64       ADC FAC1M3        ; add index low byte from FAC1 mantissa 3
d31c aa          TAX               ; save result low byte
d31d 98          TYA               ; get result high byte
d31e a4 22       LDY INDEXA        ; restore index

d320          FiAE_60
d320 65 65       ADC FAC1M4        ; add index high byte from FAC1 mantissa 4
d322 86 71       STX TMPPTD        ; save array data pointer low byte
d324 c6 0b       DEC COUNT         ; decrement dimensions count
d326 d0 ca       BNE FiAE_10       ; loop if dimensions still to do
d328 85 72       STA TMPPTD+1      ; save array data pointer high byte
d32a a2 05       LDX #$05          ; set default element size
d32c a5 45       LDA VARNAM        ; get variable name 1st byte
d32e 10 01       BPL FiAE_70       ; branch if not string or floating point array
d330 ca          DEX               ; decrement element size, $04

d331          FiAE_70
d331 a5 46       LDA VARNAM+1      ; get variable name 2nd byte
d333 10 02       BPL FiAE_80       ; branch if not integer or string
d335 ca          DEX               ; decrement element size, $03
d336 ca          DEX               ; decrement element size, $02

d337          FiAE_80
d337 86 28       STX FAC3+3       ; save dimension size low byte
d339 a9 00       LDA #$00          ; clear dimension size high byte
d33b 20 55 d3    JSR Compute_Array_Size_A
d33e 8a          TXA               ; copy array size low byte
d33f 65 58       ADC TMPPTA        ; add array data start pointer low byte
d341 85 47       STA VARPNT        ; save as current variable pointer low byte
d343 98          TYA               ; copy array size high byte
d344 65 59       ADC TMPPTA+1      ; add array data start pointer high byte
d346 85 48       STA VARPNT+1      ; save as current variable pointer high byte
d348 a8          TAY               ; copy high byte to Y
d349 a5 47       LDA VARPNT        ; get current variable pointer low byte
                                   ; pointer to element is now in AY
d34b          FiAE_Ret
d34b 60          RTS ;Size  379 [Find_Array]

              ; ******************
d34c            Compute_Array_Size
              ; ******************

d34c 84 22       STY INDEXA        ; save index
d34e b1 5f       LDA (TMPPTC),Y    ; get dimension size low byte
d350 85 28       STA FAC3+3       ; save dimension size low byte
d352 88          DEY               ; decrement index
d353 b1 5f       LDA (TMPPTC),Y    ; get dimension size high byte

              ; --------------------
d355            Compute_Array_Size_A
              ; --------------------

d355 85 29       STA FAC3+4       ; save dimension size high byte
d357 a9 10       LDA #$10          ; count = $10 (16 bit multiply)
d359 85 5d       STA TMPVA1        ; save bit count
d35b a2 00       LDX #$00          ; clear result low byte
d35d a0 00       LDY #$00          ; clear result high byte

d35f          CAS_10
d35f 8a          TXA               ; get result low byte
d360 0a          ASL A             ; *2
d361 aa          TAX               ; save result low byte
d362 98          TYA               ; get result high byte
d363 2a          ROL A             ; *2
d364 a8          TAY               ; save result high byte
d365 b0 a4       BCS FiAE_30       ; if overflow go do "Out of memory" error
d367 06 71       ASL TMPPTD        ; shift element size low byte
d369 26 72       ROL TMPPTD+1      ; shift element size high byte
d36b 90 0b       BCC CAS_20        ; skip add if no carry
d36d 18          CLC               ; else clear carry for add
d36e 8a          TXA               ; get result low byte
d36f 65 28       ADC FAC3+3       ; add dimension size low byte
d371 aa          TAX               ; save result low byte
d372 98          TYA               ; get result high byte
d373 65 29       ADC FAC3+4       ; add dimension size high byte
d375 a8          TAY               ; save result high byte
d376 b0 93       BCS FiAE_30       ; if overflow go do "Out of memory" error

d378          CAS_20
d378 c6 5d       DEC TMPVA1        ; decrement bit count
d37a d0 e3       BNE CAS_10        ; loop until all done
d37c 60          RTS ;Size   49 [Compute_Array_Size]

              ; *********
d37d            Basic_FRE
              ; *********

d37d a5 0d       LDA VALTYP        ; get data type flag, $FF = string, $00 = numeric
d37f f0 03       BEQ FRE_10        ; if numeric don't pop the string
d381 20 a6 d6    JSR Get_String_Descriptor
                                   ; FRE(n) was numeric so do this
d384          FRE_10
d384 20 26 d5    JSR Garbage_Collection
d387 38          SEC
d388 a5 33       LDA FRESPC        ; get bottom of string space low byte
d38a e5 31       SBC STREND        ; subtract end of arrays low byte
d38c a8          TAY               ; copy result to Y
d38d a5 34       LDA FRESPC+1      ; get bottom of string space high byte
d38f e5 32       SBC STREND+1      ; subtract end of arrays high byte

              ; ***************
d391            Integer_To_Float
              ; ***************

d391 a2 00       LDX #$00          ; set type = numeric
d393 86 0d       STX VALTYP        ; clear data type flag, $FF = string, $00 = numeric
d395 85 62       STA FAC1M1        ; save FAC1 mantissa 1
d397 84 63       STY FAC1M2        ; save FAC1 mantissa 2
d399 a2 90       LDX #$90          ; set exponent=2^16 (integer)
d39b 4c 44 dc    JMP Int_To_Float_Exp_X      ; set exp = X, clear FAC1 3 and 4, normalise and return

              ; *********
d39e            Basic_POS
              ; *********

d39e 38          SEC               ; set Cb for read cursor position
d39f 20 f0 ff    JSR PLOT          ; Read or set cursor location

              ; ==========
d3a2            Y_To_Float
              ; ==========

d3a2 a9 00       LDA #0            ; clear high byte
d3a4 f0 eb       BEQ Integer_To_Float

              ; *****************
d3a6            Assert_Non_Direct
              ; *****************

d3a6 a6 3a       LDX CURLIN+1      ; get current line number high byte
d3a8 e8          INX               ; increment it
d3a9 d0 a0       BNE FiAE_Ret      ; return if not direct mode
d3ab a2 15       LDX #$15          ; error $15, illegal direct error
d3ad 2c          .byte   $2C       ; skip next statement

              ; ==================
d3ae            Undefined_Function
              ; ==================

d3ae a2 1b       LDX #$1B          ; error $1B, undefined function error
d3b0 4c 37 c4    JMP Basic_Error

              ; *********
d3b3            Basic_DEF
              ; *********

d3b3 20 e1 d3    JSR Get_FN
d3b6 20 a6 d3    JSR Assert_Non_Direct
d3b9 20 fa ce    JSR Need_Left_Parenthesis
d3bc a9 80       LDA #$80          ; set flag for FNx
d3be 85 10       STA SUBFLG        ; save subscript/FNx flag
d3c0 20 8b d0    JSR Get_Scalar_Address
d3c3 20 8d cd    JSR Is_Numeric
d3c6 20 f7 ce    JSR Need_Right_Parenthesis
d3c9 a9 b2       LDA #TK_EQUAL     ; get = token
d3cb 20 ff ce    JSR Need_A
d3ce 48          PHA               ; push next character
                 PUSHW(VARPNT)     ; push current variable pointer
d3cf a5 48       LDA VARPNT+1
d3d1 48          PHA
d3d2 a5 47       LDA VARPNT
d3d4 48          PHA

                 PUSHW(TXTPTR)     ; push BASIC execute pointer
d3d5 a5 7b       LDA TXTPTR+1
d3d7 48          PHA
d3d8 a5 7a       LDA TXTPTR
d3da 48          PHA

d3db 20 f8 c8    JSR Basic_DATA    ; perform DATA
d3de 4c 4f d4    JMP EvFN_30      ; put execute pointer and variable pointer into function

              ; ******
d3e1            Get_FN
              ; ******

d3e1 a9 a5       LDA #TK_FN        ; set FN token
d3e3 20 ff ce    JSR Need_A
d3e6 09 80       ORA #$80          ; set FN flag bit
d3e8 85 10       STA SUBFLG        ; save FN name
d3ea 20 92 d0    JSR Get_FN_Address
                 STAY(FUNCPT)
d3ed 85 4e       STA FUNCPT
d3ef 84 4f       STY FUNCPT+1

d3f1 4c 8d cd    JMP Is_Numeric

              ; ********
d3f4            Eval_FNX
              ; ********

d3f4 20 e1 d3    JSR Get_FN
                 PUSHW(FUNCPT)     ; push function pointer
d3f7 a5 4f       LDA FUNCPT+1
d3f9 48          PHA
d3fa a5 4e       LDA FUNCPT
d3fc 48          PHA

d3fd 20 f1 ce    JSR Eval_In_Parenthesis
d400 20 8d cd    JSR Is_Numeric
                 PULLW(FUNCPT)     ; pull it
d403 68          PLA
d404 85 4e       STA FUNCPT
d406 68          PLA
d407 85 4f       STA FUNCPT+1

d409 a0 02       LDY #$02          ; index to variable pointer high byte
d40b b1 4e       LDA (FUNCPT),Y    ; get variable address low byte
d40d 85 47       STA VARPNT        ; save current variable pointer low byte
d40f aa          TAX               ; copy address low byte
d410 c8          INY               ; index to variable address high byte
d411 b1 4e       LDA (FUNCPT),Y    ; get variable pointer high byte
d413 f0 99       BEQ Undefined_Function      ; if high byte zero go do undefined function error
d415 85 48       STA VARPNT+1      ; save current variable pointer high byte
d417 c8          INY               ; index to mantissa 3

d418          EvFN_10
d418 b1 47       LDA (VARPNT),Y    ; get byte from variable
d41a 48          PHA               ; stack it
d41b 88          DEY               ; decrement index
d41c 10 fa       BPL EvFN_10      ; loop until variable stacked
d41e a4 48       LDY VARPNT+1      ; get current variable pointer high byte
d420 20 d4 db    JSR Assign_FAC1_To_Var
                 PUSHW(TXTPTR)     ; push BASIC execute pointer
d423 a5 7b       LDA TXTPTR+1
d425 48          PHA
d426 a5 7a       LDA TXTPTR
d428 48          PHA

d429 b1 4e       LDA (FUNCPT),Y    ; get function execute pointer low byte
d42b 85 7a       STA TXTPTR        ; save BASIC execute pointer low byte
d42d c8          INY               ; index to high byte
d42e b1 4e       LDA (FUNCPT),Y    ; get function execute pointer high byte
d430 85 7b       STA TXTPTR+1      ; save BASIC execute pointer high byte
                 PUSHW(VARPNT)     ; push current variable pointer
d432 a5 48       LDA VARPNT+1
d434 48          PHA
d435 a5 47       LDA VARPNT
d437 48          PHA

d438 20 8a cd    JSR Eval_Numeric
                 PULLW(FUNCPT)     ; pull variable address
d43b 68          PLA
d43c 85 4e       STA FUNCPT
d43e 68          PLA
d43f 85 4f       STA FUNCPT+1

d441 20 79 00    JSR CHRGOT
d444 f0 03       BEQ EvFN_20      ; if null (should be [EOL] marker) continue
d446 4c 08 cf    JMP Syntax_Error

d449          EvFN_20
                 PULLW(TXTPTR)     ; pull BASIC execute pointer
d449 68          PLA
d44a 85 7a       STA TXTPTR
d44c 68          PLA
d44d 85 7b       STA TXTPTR+1


d44f          EvFN_30
d44f a0 00       LDY #0
d451 68          PLA               ; pull BASIC execute pointer low byte
d452 91 4e       STA (FUNCPT),Y    ; save to function
d454 68          PLA               ; pull BASIC execute pointer high byte
d455 c8          INY
d456 91 4e       STA (FUNCPT),Y    ; save to function
d458 68          PLA               ; pull current variable address low byte
d459 c8          INY
d45a 91 4e       STA (FUNCPT),Y    ; save to function
d45c 68          PLA               ; pull current variable address high byte
d45d c8          INY
d45e 91 4e       STA (FUNCPT),Y    ; save to function
d460 68          PLA               ; pull ??
d461 c8          INY
d462 91 4e       STA (FUNCPT),Y    ; save to function
d464 60          RTS ;Size  113 [Eval_FNX]

              ; *********
d465            Basic_STR
              ; *********

d465 20 8d cd    JSR Is_Numeric
d468 a0 00       LDY #0
d46a 20 df dd    JSR Format_FAC1_Y
d46d 68          PLA               ; dump return address (skip type check)
d46e 68          PLA               ; dump return address (skip type check)

d46f          BaST_10
                 LAYI(BASSTO)      ; set result string
d46f a9 ff       LDA #<BASSTO
d471 a0 00       LDY #>BASSTO

d473 f0 12       BEQ Create_String_Descriptor

              ; ********************
d475            Allocate_String_FAC1
              ; ********************

                 LDXY(FAC1M3)
d475 a6 64       LDX FAC1M3
d477 a4 65       LDY FAC1M3+1

                 STXY(DESCPT)
d479 86 50       STX DESCPT
d47b 84 51       STY DESCPT+1


              ; *****************
d47d            Allocate_String_A
              ; *****************

d47d 20 f4 d4    JSR Allocate_String_Space
d480 86 62       STX FAC1M1        ; save string pointer low byte
d482 84 63       STY FAC1M2        ; save string pointer high byte
d484 85 61       STA FAC1EX        ; save length
d486 60          RTS ;Size   10 [Allocate_String_A]

              ; ************************
d487            Create_String_Descriptor
              ; ************************

d487 a2 22       LDX #QUOTE
d489 86 07       STX CHARAC        ; set terminator 1
d48b 86 08       STX ENDCHR        ; set terminator 2

              ; ---------------------------
d48d            Create_String_Descriptor_AY
              ; ---------------------------

                 STAY(STRPTR)
d48d 85 6f       STA STRPTR
d48f 84 70       STY STRPTR+1

                 STAY(FAC1M1)
d491 85 62       STA FAC1M1
d493 84 63       STY FAC1M1+1

d495 a0 ff       LDY #$FF          ; set length to -1

d497          CSD_10
d497 c8          INY               ; increment length
d498 b1 6f       LDA (STRPTR),Y    ; get byte from string
d49a f0 0c       BEQ CSD_30        ; exit loop if null byte [EOS]
d49c c5 07       CMP CHARAC        ; compare with search character, terminator 1
d49e f0 04       BEQ CSD_20        ; branch if terminator
d4a0 c5 08       CMP ENDCHR        ; compare with terminator 2
d4a2 d0 f3       BNE CSD_10        ; loop if not terminator 2

d4a4          CSD_20
d4a4 c9 22       CMP #QUOTE
d4a6 f0 01       BEQ CSD_40        ; branch if " (carry set if = !)

d4a8          CSD_30
d4a8 18          CLC

d4a9          CSD_40
d4a9 84 61       STY FAC1EX        ; save length in FAC1 exponent
d4ab 98          TYA               ; copy length to A
d4ac 65 6f       ADC STRPTR        ; add string start low byte
d4ae 85 71       STA TMPPTD        ; save string end low byte
d4b0 a6 70       LDX STRPTR+1      ; get string start high byte
d4b2 90 01       BCC CSD_50        ; if no low byte overflow skip the high byte increment
d4b4 e8          INX               ; else increment high byte

d4b5          CSD_50
d4b5 86 72       STX TMPPTD+1      ; save string end high byte
d4b7 a5 70       LDA STRPTR+1      ; get string start high byte
d4b9 f0 04       BEQ CSD_60        ; branch if in utility area
d4bb c9 02       CMP #$02          ; compare with input buffer memory high byte
d4bd d0 0b       BNE Push_String_Descriptor

d4bf          CSD_60
d4bf 98          TYA               ; copy length to A
d4c0 20 75 d4    JSR Allocate_String_FAC1
                 LDXY(STRPTR)      ; get string start
d4c3 a6 6f       LDX STRPTR
d4c5 a4 70       LDY STRPTR+1


d4c7          Store_And_Push_String
d4c7 20 88 d6    JSR Store_String_XY

              ; ***********************
d4ca             Push_String_Descriptor
              ; ***********************

d4ca a6 16       LDX TEMPPT        ; get descriptor stack pointer
d4cc e0 22       CPX #QUOTE
d4ce d0 05       BNE PSD_20        ; branch if space on string stack
d4d0 a2 19       LDX #$19          ; error $19, string too complex error

d4d2          PSD_10
d4d2 4c 37 c4    JMP Basic_Error

d4d5          PSD_20
d4d5 a5 61       LDA FAC1EX        ; get string length
d4d7 95 00       STA 0,X           ; put on string stack
d4d9 a5 62       LDA FAC1M1        ; get string pointer low byte
d4db 95 01       STA 1,X           ; put on string stack
d4dd a5 63       LDA FAC1M2        ; get string pointer high byte
d4df 95 02       STA 2,X           ; put on string stack
d4e1 a0 00       LDY #0            ; clear Y
                 STXY(FAC1M3)      ; save string descriptor pointer
d4e3 86 64       STX FAC1M3
d4e5 84 65       STY FAC1M3+1

d4e7 84 70       STY FAC1M5        ; clear FAC1 rounding byte
d4e9 88          DEY               ; Y = $FF
d4ea 84 0d       STY VALTYP        ; save data type flag, $FF = string
d4ec 86 17       STX LASTPT        ; save current descriptor stack item pointer low byte
d4ee e8          INX               ; update stack pointer
d4ef e8          INX               ; update stack pointer
d4f0 e8          INX               ; update stack pointer
d4f1 86 16       STX TEMPPT        ; set new descriptor stack pointer
d4f3 60          RTS ;Size   42 [Push_String_Descriptor]

              ; *********************
d4f4            Allocate_String_Space
              ; *********************

d4f4 46 0f       LSR GARBFL        ; clear garbage collected flag (b7)

d4f6          ASS_10
d4f6 48          PHA               ; save string length
d4f7 49 ff       EOR #$FF          ; complement it
d4f9 38          SEC               ; set carry for subtract, two's complement add
d4fa 65 33       ADC FRESPC        ; add bottom of string space low byte, subtract length
d4fc a4 34       LDY FRESPC+1      ; get bottom of string space high byte
d4fe b0 01       BCS ASS_20        ; skip decrement if no underflow
d500 88          DEY               ; decrement bottom of string space high byte

d501          ASS_20
d501 c4 32       CPY STREND+1      ; compare with end of arrays high byte
d503 90 11       BCC ASS_40        ; do out of memory error if less
d505 d0 04       BNE ASS_30        ; if not = skip next test
d507 c5 31       CMP STREND        ; compare with end of arrays low byte
d509 90 0b       BCC ASS_40        ; do out of memory error if less

d50b          ASS_30
                 STAY(FRESPC)
d50b 85 33       STA FRESPC
d50d 84 34       STY FRESPC+1

                 STAY(UTLSTP)      ; save string utility ptr
d50f 85 35       STA UTLSTP
d511 84 36       STY UTLSTP+1

d513 aa          TAX               ; copy low byte to X
d514 68          PLA               ; get string length back
d515 60          RTS ;Size   34 [Allocate_String_Space]

d516          ASS_40
d516 a2 10       LDX #$10          ; error code $10, out of memory error
d518 a5 0f       LDA GARBFL        ; get garbage collected flag
d51a 30 b6       BMI PSD_10        ; if set then do error code X
d51c 20 26 d5    JSR Garbage_Collection
d51f a9 80       LDA #$80          ; flag for garbage collected
d521 85 0f       STA GARBFL        ; set garbage collected flag
d523 68          PLA               ; pull length
d524 d0 d0       BNE ASS_10        ; go try again (loop always, length should never be = $00)

              ; ******************
d526            Garbage_Collection
              ; ******************

              ; This routine marks all strings as uncollected by setting the bottom of
              ; string space FRESPC to MEMSIZ, the top of string space.
              ; Then it scans through all string descriptors starting with those on the
              ; string stack, continuing with scalar string variables and finally all
              ; string arrays. The string with the highest address is then moved to the
              ; top of string space, FRESPC is adjusted and the iteration continues
              ; with searching for the string with the next highest address.

d526 a6 37       LDX MEMSIZ        ; get end of memory low byte
d528 a5 38       LDA MEMSIZ+1      ; get end of memory high byte

d52a          GaCo_Iter
d52a 86 33       STX FRESPC        ; set bottom of string space low byte
d52c 85 34       STA FRESPC+1      ; set bottom of string space high byte
d52e a0 00       LDY #0
d530 84 4f       STY FUNCPT+1      ; clear working pointer high byte
d532 84 4e       STY FUNCPT        ; clear working pointer low byte
                 LDAX(STREND)      ; get end of arrays
d534 a5 31       LDA STREND
d536 a6 32       LDX STREND+1

                 STAX(TMPPTC)      ; save as highest uncollected string pointer
d538 85 5f       STA TMPPTC
d53a 86 60       STX TMPPTC+1

d53c a9 19       LDA #TEMPST       ; set descriptor stack pointer
d53e a2 00       LDX #0            ; check first descriptors on string stack
                 STAX(INDEXA)      ; save descriptor stack pointer
d540 85 22       STA INDEXA
d542 86 23       STX INDEXA+1


d544          GaCo_Loop_1
d544 c5 16       CMP TEMPPT        ; compare with descriptor stack pointer
d546 f0 05       BEQ GaCo_10       ; branch if descripor on stack
d548 20 c7 d5    JSR Check_String  ; 
d54b f0 f7       BEQ GaCo_Loop_1   ; loop always (Check_String returns with LDY #0)

d54d          GaCo_10              ; done stacked strings, now do string variables
d54d a9 07       LDA #7            ; set step size = 7, collecting variables
d54f 85 53       STA GARBSS        ; save garbage collection step size
                 LDAX(VARTAB)      ; get start of variables
d551 a5 2d       LDA VARTAB
d553 a6 2e       LDX VARTAB+1

                 STAX(INDEXA)      ; save as pointer
d555 85 22       STA INDEXA
d557 86 23       STX INDEXA+1


d559          GaCo_20
d559 e4 30       CPX ARYTAB+1      ; compare end of variables high byte,
d55b d0 04       BNE GaCo_30       ; branch if no high byte match
d55d c5 2f       CMP ARYTAB        ; else compare end of variables low byte,
d55f f0 05       BEQ GaCo_40       ; branch if = variable memory end

d561          GaCo_30
d561 20 bd d5    JSR Check_Variable
d564 f0 f3       BEQ GaCo_20       ; loop always

d566          GaCo_40
                 STAX(TMPPTA)      ; save start of arrays low byte as working pointer
d566 85 58       STA TMPPTA
d568 86 59       STX TMPPTA+1

d56a a9 03       LDA #3            ; set step size, collecting descriptors
d56c 85 53       STA GARBSS        ; save step size

d56e          GaCo_50
                 LDAX(TMPPTA)      ; get pointer
d56e a5 58       LDA TMPPTA
d570 a6 59       LDX TMPPTA+1


d572          GaCo_60
d572 e4 32       CPX STREND+1      ; compare with end of arrays high byte
d574 d0 07       BNE GaCo_70       ; branch if not at end
d576 c5 31       CMP STREND        ; else compare with end of arrays low byte
d578 d0 03       BNE GaCo_70       ; branch if not at end
d57a 4c 06 d6    JMP Collect_String

d57d          GaCo_70
                 STAX(INDEXA)      ; save pointer
d57d 85 22       STA INDEXA
d57f 86 23       STX INDEXA+1

d581 a0 00       LDY #0
d583 b1 22       LDA (INDEXA),Y    ; get array name first byte
d585 aa          TAX               ; copy it
d586 c8          INY
d587 b1 22       LDA (INDEXA),Y    ; get array name second byte
d589 08          PHP               ; push the flags
d58a c8          INY
d58b b1 22       LDA (INDEXA),Y    ; get array size low byte
d58d 65 58       ADC TMPPTA        ; add start of this array low byte
d58f 85 58       STA TMPPTA        ; save start of next array low byte
d591 c8          INY
d592 b1 22       LDA (INDEXA),Y    ; get array size high byte
d594 65 59       ADC TMPPTA+1      ; add start of this array high byte
d596 85 59       STA TMPPTA+1      ; save start of next array high byte
d598 28          PLP               ; restore the flags
d599 10 d3       BPL GaCo_50       ; skip if not string array
d59b 8a          TXA               ; get name first byte back
d59c 30 d0       BMI GaCo_50       ; skip if not string array
d59e c8          INY
d59f b1 22       LDA (INDEXA),Y    ; get # of dimensions
d5a1 a0 00       LDY #0
d5a3 0a          ASL A             ; *2
d5a4 69 05       ADC #5            ; +5 (array header size)
d5a6 65 22       ADC INDEXA        ; add pointer low byte
d5a8 85 22       STA INDEXA        ; save pointer low byte
d5aa 90 02       BCC GaCo_80       ; if no rollover skip the high byte increment
d5ac e6 23       INC INDEXA+1      ; else increment pointer hgih byte

d5ae          GaCo_80
d5ae a6 23       LDX INDEXA+1      ; get pointer high byte

d5b0          GaCo_90
d5b0 e4 59       CPX TMPPTA+1      ; compare pointer high byte with end of this array high byte
d5b2 d0 04       BNE GaCo_95       ; branch if not there yet
d5b4 c5 58       CMP TMPPTA        ; compare pointer low byte with end of this array low byte
d5b6 f0 ba       BEQ GaCo_60       ; if at end of this array go check next array

d5b8          GaCo_95
d5b8 20 c7 d5    JSR Check_String
d5bb f0 f3       BEQ GaCo_90      ; loop

              ; **************
d5bd            Check_Variable
              ; **************

d5bd b1 22       LDA (INDEXA),Y    ; get variable name first byte
d5bf 30 35       BMI ChSt_30       ; add step and exit if not string
d5c1 c8          INY
d5c2 b1 22       LDA (INDEXA),Y    ; get variable name second byte
d5c4 10 30       BPL ChSt_30       ; add step and exit if not string
d5c6 c8          INY

              ; ************
d5c7            Check_String
              ; ************

              ; INDEXA points to the string descriptor to be checked.
              ; Following cases are examined for the string address (X/A)
              ; (1) : The length (INDEXA) is zero        -> next string
              ; (2) : (X/A) > FRESPC (already collected) -> next string
              ; (3) : (X/A) < TMPPTC                     -> next string
              ; (4) ; (X/A) > TMMPTC                     -> TPMPTC = (X/A)

              ; INDEXA is updated to point to the next string descriptor by adding
              ; GARBSS which may be 7 for scanning string variables or 3 for scanning
              ; string arrays.

              ; On return (A/X) holds the updated INDEXA, Y=0, Z flag set

d5c7 b1 22       LDA (INDEXA),Y    ; get string length
d5c9 f0 2b       BEQ ChSt_30       ; add step and exit if null string
d5cb c8          INY
d5cc b1 22       LDA (INDEXA),Y    ; get string pointer low byte
d5ce aa          TAX               ; copy to X
d5cf c8          INY
d5d0 b1 22       LDA (INDEXA),Y    ; get string pointer high byte
d5d2 c5 34       CMP FRESPC+1      ; compare string pointer high byte with bottom of string
d5d4 90 06       BCC ChSt_10       ; if less go test against highest
d5d6 d0 1e       BNE ChSt_30       ; bottom of string space less string has been collected
d5d8 e4 33       CPX FRESPC        ; compare string pointer low byte with bottom of string
d5da b0 1a       BCS ChSt_30       ; if bottom of string space less string has been collected

d5dc          ChSt_10
d5dc c5 60       CMP TMPPTC+1      ; compare string pointer high byte with highest uncollected
d5de 90 16       BCC ChSt_30       ; if highest uncollected string is greater then go update
d5e0 d0 04       BNE ChSt_20       ; if highest uncollected string is less then go set this
d5e2 e4 5f       CPX TMPPTC        ; compare string pointer low byte with highest uncollected
d5e4 90 10       BCC ChSt_30       ; if highest uncollected string is greater then go update

d5e6          ChSt_20
d5e6 86 5f       STX TMPPTC        ; save string pointer low byte as highest uncollected string
d5e8 85 60       STA TMPPTC+1      ; save string pointer high byte as highest uncollected
                 LDAX(INDEXA)      ; get descriptor pointer
d5ea a5 22       LDA INDEXA
d5ec a6 23       LDX INDEXA+1

                 STAX(FUNCPT)      ; save working pointer
d5ee 85 4e       STA FUNCPT
d5f0 86 4f       STX FUNCPT+1

d5f2 a5 53       LDA GARBSS        ; get step size
d5f4 85 55       STA FUNJMP        ; copy step size

d5f6          ChSt_30
d5f6 a5 53       LDA GARBSS        ; get step size (7 or 3)
d5f8 18          CLC
d5f9 65 22       ADC INDEXA        ; add pointer low byte
d5fb 85 22       STA INDEXA        ; save pointer low byte
d5fd 90 02       BCC ChSt_40       ; if no rollover skip the high byte increment
d5ff e6 23       INC INDEXA+1      ; else increment pointer high byte

d601          ChSt_40
d601 a6 23       LDX INDEXA+1      ; get pointer high byte
d603 a0 00       LDY #0
d605 60          RTS ;Size   63 [Check_String]

              ; ==============
d606            Collect_String
              ; ==============

d606 a5 4f       LDA FUNCPT+1      ; get working pointer low byte
d608 05 4e       ORA FUNCPT        ; OR working pointer high byte
d60a f0 f5       BEQ ChSt_40       ; exit if nothing to collect
d60c a5 55       LDA FUNJMP        ; get copied step size
d60e 29 04       AND #4            ; mask step size, 4 for variables, 0 for array or stack
d610 4a          LSR A             ; 2 for variables, 0 for descriptors
d611 a8          TAY               ; copy to index
d612 85 55       STA FUNJMP        ; save offset to descriptor start
d614 b1 4e       LDA (FUNCPT),Y    ; get string length
d616 65 5f       ADC TMPPTC        ; add string start low byte
d618 85 5a       STA TMPPTB        ; set block end low byte
d61a a5 60       LDA TMPPTC+1      ; get string start high byte
d61c 69 00       ADC #0            ; add carry
d61e 85 5b       STA TMPPTB+1      ; set block end high byte
                 LDAX(FRESPC)      ; get bottom of string space
d620 a5 33       LDA FRESPC
d622 a6 34       LDX FRESPC+1

                 STAX(TMPPTA)      ; save destination end
d624 85 58       STA TMPPTA
d626 86 59       STX TMPPTA+1

d628 20 bf c3    JSR Move_Block
d62b a4 55       LDY FUNJMP        ; restore offset to descriptor start
d62d c8          INY
d62e a5 58       LDA TMPPTA        ; get new string pointer low byte
d630 91 4e       STA (FUNCPT),Y    ; save new string pointer low byte
d632 aa          TAX               ; copy string pointer low byte
d633 e6 59       INC TMPPTA+1      ; increment new string pointer high byte
d635 a5 59       LDA TMPPTA+1      ; get new string pointer high byte
d637 c8          INY
d638 91 4e       STA (FUNCPT),Y    ; save new string pointer high byte
d63a 4c 2a d5    JMP GaCo_Iter     ; XA holds new bottom of string memory pointer

              ; ===========
d63d            Concatenate
              ; ===========

              ; add strings, the first string is in the descriptor, the second string is in line

                 PUSHW(FAC1M3)     ; push descriptor pointer
d63d a5 65       LDA FAC1M3+1
d63f 48          PHA
d640 a5 64       LDA FAC1M3
d642 48          PHA

d643 20 83 ce    JSR Evaluate
d646 20 8f cd    JSR Assert_String_Type
                 PULLW(STRPTR)     ; pull pointer
d649 68          PLA
d64a 85 6f       STA STRPTR
d64c 68          PLA
d64d 85 70       STA STRPTR+1

d64f a0 00       LDY #0
d651 b1 6f       LDA (STRPTR),Y    ; get length of first string from descriptor
d653 18          CLC
d654 71 64       ADC (FAC1M3),Y    ; add length of second string
d656 90 05       BCC Conc_10       ; if no overflow continue
d658 a2 17       LDX #$17          ; else error $17, string too long error
d65a 4c 37 c4    JMP Basic_Error

d65d          Conc_10
d65d 20 75 d4    JSR Allocate_String_FAC1
d660 20 7a d6    JSR Store_String_STRPTR
                 LDAY(DESCPT)      ; get descriptor pointer
d663 a5 50       LDA DESCPT
d665 a4 51       LDY DESCPT+1

d667 20 aa d6    JSR Get_String_Descriptor_AY
d66a 20 8c d6    JSR Store_String_INDEXA
                 LDAY(STRPTR)      ; get descriptor pointer
d66d a5 6f       LDA STRPTR
d66f a4 70       LDY STRPTR+1

d671 20 aa d6    JSR Get_String_Descriptor_AY
d674 20 ca d4    JSR Push_String_Descriptor
d677 4c b8 cd    JMP EvEx_15      ; continue evaluation

              ; *******************
d67a            Store_String_STRPTR
              ; *******************

d67a a0 00       LDY #0
d67c b1 6f       LDA (STRPTR),Y    ; get string length
d67e 48          PHA               ; save it
d67f c8          INY
d680 b1 6f       LDA (STRPTR),Y    ; get string pointer low byte
d682 aa          TAX               ; copy to X
d683 c8          INY
d684 b1 6f       LDA (STRPTR),Y    ; get string pointer high byte
d686 a8          TAY               ; copy to Y
d687 68          PLA               ; get length back

              ; ***************
d688            Store_String_XY
              ; ***************

                 STXY(INDEXA)
d688 86 22       STX INDEXA
d68a 84 23       STY INDEXA+1


              ; *******************
d68c            Store_String_INDEXA
              ; *******************

d68c a8          TAY               ; copy length as index
d68d f0 0a       BEQ SSIN_20       ; branch if null string
d68f 48          PHA               ; save length

d690          SSIN_10
d690 88          DEY               ; decrement length/index
d691 b1 22       LDA (INDEXA),Y    ; get byte from string
d693 91 35       STA (UTLSTP),Y    ; save byte to destination
d695 98          TYA               ; y = 0 ?
d696 d0 f8       BNE SSIN_10       ; loop if not all done yet
d698 68          PLA               ; restore length

d699          SSIN_20
d699 18          CLC
d69a 65 35       ADC UTLSTP        ; add string utility ptr low byte
d69c 85 35       STA UTLSTP        ; save string utility ptr low byte
d69e 90 02       BCC SSIN_30       ; if no rollover skip the high byte increment
d6a0 e6 36       INC UTLSTP+1      ; increment string utility ptr high byte

d6a2          SSIN_30
d6a2 60          RTS ;Size   23 [Store_String_INDEXA]

              ; ***********
d6a3            Eval_String
              ; ***********

d6a3 20 8f cd    JSR Assert_String_Type

              ; *********************
d6a6            Get_String_Descriptor
              ; *********************

              ; pop string off descriptor stack, or from of string space
              ; returns with A = length, X = pointer low byte, Y = pointer high byte

                 LDAY(FAC1M3)      ; get descriptor pointer
d6a6 a5 64       LDA FAC1M3
d6a8 a4 65       LDY FAC1M3+1


              ; ------------------------
d6aa            Get_String_Descriptor_AY
              ; ------------------------

                 STAY(INDEXA)      ; save descriptor pointer
d6aa 85 22       STA INDEXA
d6ac 84 23       STY INDEXA+1

d6ae 20 db d6    JSR Pop_Descriptor_Stack
d6b1 08          PHP               ; save status flags
d6b2 a0 00       LDY #0
d6b4 b1 22       LDA (INDEXA),Y    ; get length from string descriptor
d6b6 48          PHA
d6b7 c8          INY
d6b8 b1 22       LDA (INDEXA),Y    ; get string pointer low byte from descriptor
d6ba aa          TAX
d6bb c8          INY
d6bc b1 22       LDA (INDEXA),Y    ; get string pointer high byte from descriptor
d6be a8          TAY
d6bf 68          PLA               ; get string length back
d6c0 28          PLP               ; restore status
d6c1 d0 13       BNE GSD_20        ; branch if pointer not popped
d6c3 c4 34       CPY FRESPC+1      ; compare with bottom of string space high byte
d6c5 d0 0f       BNE GSD_20        ; branch if <>
d6c7 e4 33       CPX FRESPC        ; else compare with bottom of string space low byte
d6c9 d0 0b       BNE GSD_20        ; branch if <>
d6cb 48          PHA               ; push string length
d6cc 18          CLC               ; string address is identical to FRESPC,
d6cd 65 33       ADC FRESPC        ; so we can free that memory easyli.
d6cf 85 33       STA FRESPC
d6d1 90 02       BCC GSD_10
d6d3 e6 34       INC FRESPC+1

d6d5          GSD_10
d6d5 68          PLA               ; pull string length

d6d6          GSD_20
                 STXY(INDEXA)
d6d6 86 22       STX INDEXA
d6d8 84 23       STY INDEXA+1

d6da 60          RTS ;Size   53 [Get_String_Descriptor]

              ; ********************
d6db            Pop_Descriptor_Stack
              ; ********************

d6db c4 18       CPY LASTPT+1      ; compare high byte with current descriptor stack item
d6dd d0 0c       BNE PDS_Ret
d6df c5 17       CMP LASTPT        ; compare low byte with current descriptor stack item
d6e1 d0 08       BNE PDS_Ret
d6e3 85 16       STA TEMPPT        ; set descriptor stack pointer
d6e5 e9 03       SBC #3            ; update last string pointer low byte
d6e7 85 17       STA LASTPT        ; save current descriptor stack item pointer low byte
d6e9 a0 00       LDY #0            ; set Z flag : descriptor popped

d6eb          PDS_Ret
d6eb 60          RTS ;Size   17 [Pop_Descriptor_Stack]

              ; *********
d6ec            Basic_CHR
              ; *********

d6ec 20 a1 d7    JSR Eval_Byte
d6ef 8a          TXA               ; copy to A
d6f0 48          PHA               ; save character
d6f1 a9 01       LDA #$01          ; string is single byte
d6f3 20 7d d4    JSR Allocate_String_A
d6f6 68          PLA               ; get character back
d6f7 a0 00       LDY #0
d6f9 91 62       STA (FAC1M1),Y    ; save byte in string - byte IS string!
d6fb 68          PLA               ; dump return address (skip type check)
d6fc 68          PLA               ; dump return address (skip type check)
d6fd 4c ca d4    JMP Push_String_Descriptor

              ; **********
d700            Basic_LEFT
              ; **********

d700 20 61 d7    JSR Pop_String_Descriptor_And_Byte
d703 d1 50       CMP (DESCPT),Y    ; compare byte parameter with string length
d705 98          TYA               ; clear A

d706          LEFT_10
d706 90 04       BCC LEFT_20       ; branch if string length > byte parameter
d708 b1 50       LDA (DESCPT),Y    ; else make parameter = length
d70a aa          TAX               ; copy to byte parameter copy
d70b 98          TYA               ; clear string start offset

d70c          LEFT_20
d70c 48          PHA               ; save string start offset

d70d          LEFT_30
d70d 8a          TXA               ; copy byte parameter (or string length if <)

d70e          LEFT_40
d70e 48          PHA               ; save string length
d70f 20 7d d4    JSR Allocate_String_A
                 LDAY(DESCPT)      ; get descriptor pointer low byte
d712 a5 50       LDA DESCPT
d714 a4 51       LDY DESCPT+1

d716 20 aa d6    JSR Get_String_Descriptor_AY
d719 68          PLA               ; get string length back
d71a a8          TAY               ; copy length to Y
d71b 68          PLA               ; get string start offset back
d71c 18          CLC
d71d 65 22       ADC INDEXA        ; add start offset to string start pointer low byte
d71f 85 22       STA INDEXA        ; save string start pointer low byte
d721 90 02       BCC LEFT_50       ; if no overflow skip the high byte increment
d723 e6 23       INC INDEXA+1      ; else increment string start pointer high byte

d725          LEFT_50
d725 98          TYA               ; copy length to A
d726 20 8c d6    JSR Store_String_INDEXA
d729 4c ca d4    JMP Push_String_Descriptor

              ; ***********
d72c            Basic_RIGHT
              ; ***********

d72c 20 61 d7    JSR Pop_String_Descriptor_And_Byte
d72f 18          CLC
d730 f1 50       SBC (DESCPT),Y    ; subtract string length
d732 49 ff       EOR #$FF          ; invert it (A=LEN(expression$)-l)
d734 4c 06 d7    JMP LEFT_10      ; go do rest of LEFT$()

              ; *********
d737            Basic_MID
              ; *********

d737 a9 ff       LDA #$FF          ; set default length = 255
d739 85 65       STA FAC1M4        ; save default length
d73b 20 79 00    JSR CHRGOT
d73e c9 29       CMP #')'
d740 f0 06       BEQ MID_10        ; no 2nd. byte
d742 20 fd ce    JSR Need_Comma
d745 20 9e d7    JSR Get_Byte_Value

d748          MID_10
d748 20 61 d7    JSR Pop_String_Descriptor_And_Byte
d74b f0 4b       BEQ Jump_To_Illegal_Quantity
d74d ca          DEX               ; decrement start index
d74e 8a          TXA               ; copy to A
d74f 48          PHA               ; save string start offset
d750 18          CLC
d751 a2 00       LDX #0            ; clear output string length
d753 f1 50       SBC (DESCPT),Y    ; start - string length
d755 b0 b6       BCS LEFT_30       ; if start > string length go do null string
d757 49 ff       EOR #$FF          ; complement -length
d759 c5 65       CMP FAC1M4        ; compare with length
d75b 90 b1       BCC LEFT_40       ; if length > remaining string go do RIGHT$
d75d a5 65       LDA FAC1M4        ; get length byte
d75f b0 ad       BCS LEFT_40       ; go do string copy, branch always

              ; ******************************
d761            Pop_String_Descriptor_And_Byte
              ; ******************************

d761 20 f7 ce    JSR Need_Right_Parenthesis
d764 68          PLA
d765 a8          TAY               ; save return address low byte
d766 68          PLA
d767 85 55       STA FUNJMP        ; save return address high byte
d769 68          PLA               ; dump call to function vector low byte
d76a 68          PLA               ; dump call to function vector high byte
d76b 68          PLA               ; pull byte parameter
d76c aa          TAX               ; copy byte parameter to X
                 PULLW(DESCPT)     ; pull string pointer
d76d 68          PLA
d76e 85 50       STA DESCPT
d770 68          PLA
d771 85 51       STA DESCPT+1

d773 a5 55       LDA FUNJMP        ; get return address high byte
d775 48          PHA               ; back on stack
d776 98          TYA               ; get return address low byte
d777 48          PHA               ; back on stack
d778 a0 00       LDY #0
d77a 8a          TXA               ; copy byte parameter
d77b 60          RTS ;Size   27 [Pop_String_Descriptor_And_Byte]

              ; *********
d77c            Basic_LEN
              ; *********

d77c 20 82 d7    JSR Eval_String_And_Len
d77f 4c a2 d3    JMP Y_To_Float      ; convert Y to byte in FAC1 and return

              ; *******************
d782            Eval_String_And_Len
              ; *******************

d782 20 a3 d6    JSR Eval_String
d785 a2 00       LDX #$00          ; set data type = numeric
d787 86 0d       STX VALTYP        ; clear data type flag, $FF = string, $00 = numeric
d789 a8          TAY               ; copy length to Y
d78a 60          RTS ;Size    9 [Eval_String_And_Len]

              ; *********
d78b            Basic_ASC
              ; *********

d78b 20 82 d7    JSR Eval_String_And_Len
d78e f0 08       BEQ Jump_To_Illegal_Quantity
d790 a0 00       LDY #0
d792 b1 22       LDA (INDEXA),Y    ; get 1st. byte
d794 a8          TAY               ; copy to Y
d795 4c a2 d3    JMP Y_To_Float

              ; ========================
d798            Jump_To_Illegal_Quantity
              ; ========================

d798 4c 48 d2    JMP Illegal_Quantity

              ; *******************
d79b            Get_Next_Byte_Value
              ; *******************

d79b 20 73 00    JSR CHRGET

              ; --------------
d79e            Get_Byte_Value
              ; --------------

d79e 20 8a cd    JSR Eval_Numeric

              ; *********
d7a1            Eval_Byte
              ; *********

d7a1 20 b8 d1    JSR Eval_Positive_Integer_Check
d7a4 a6 64       LDX FAC1M3        ; high byte must be 0
d7a6 d0 f0       BNE Jump_To_Illegal_Quantity
d7a8 a6 65       LDX FAC1M4
d7aa 4c 79 00    JMP CHRGOT

              ; *********
d7ad            Basic_VAL
              ; *********

d7ad 20 82 d7    JSR Eval_String_And_Len
d7b0 d0 03       BNE VAL_10        ; if not a null string go evaluate it
d7b2 4c f7 d8    JMP Clear_FAC1_Exp_And_Sign

d7b5          VAL_10
                 LDXY(TXTPTR)
d7b5 a6 7a       LDX TXTPTR
d7b7 a4 7b       LDY TXTPTR+1

                 STXY(TMPPTD)
d7b9 86 71       STX TMPPTD
d7bb 84 72       STY TMPPTD+1

d7bd a6 22       LDX INDEXA        ; get string pointer low byte
d7bf 86 7a       STX TXTPTR        ; save BASIC execute pointer low byte
d7c1 18          CLC
d7c2 65 22       ADC INDEXA        ; add string length
d7c4 85 24       STA INDEXB        ; save string end low byte
d7c6 a6 23       LDX INDEXA+1      ; get string pointer high byte
d7c8 86 7b       STX TXTPTR+1      ; save BASIC execute pointer high byte
d7ca 90 01       BCC VAL_20        ; if no rollover skip the high byte increment
d7cc e8          INX               ; increment string end high byte

d7cd          VAL_20
d7cd 86 25       STX INDEXB+1      ; save string end high byte
d7cf a0 00       LDY #0
d7d1 b1 24       LDA (INDEXB),Y    ; get string end byte
d7d3 48          PHA               ; push it
d7d4 98          TYA               ; clear A
d7d5 91 24       STA (INDEXB),Y    ; terminate string with 0
d7d7 20 79 00    JSR CHRGOT
d7da 20 f3 dc    JSR Load_FAC1_From_String
d7dd 68          PLA               ; restore string end byte
d7de a0 00       LDY #0
d7e0 91 24       STA (INDEXB),Y    ; put string end byte back

              ; -------------------------
d7e2            Restore_Execution_Pointer
              ; -------------------------

                 LDXY(TMPPTD)
d7e2 a6 71       LDX TMPPTD
d7e4 a4 72       LDY TMPPTD+1

                 STXY(TXTPTR)
d7e6 86 7a       STX TXTPTR
d7e8 84 7b       STY TXTPTR+1

d7ea 60          RTS ;Size   62 [Basic_VAL]

              ; *****************
d7eb            Get_Word_And_Byte
              ; *****************

d7eb 20 8a cd    JSR Eval_Numeric
d7ee 20 f7 d7    JSR FAC1_To_LINNUM

              ; *******************
d7f1            Need_Comma_Get_Byte
              ; *******************

d7f1 20 fd ce    JSR Need_Comma
d7f4 4c 9e d7    JMP Get_Byte_Value

              ; **************
d7f7            FAC1_To_LINNUM
              ; **************

d7f7 a5 66       LDA FAC1SI        ; get FAC1 sign
d7f9 30 9d       BMI Jump_To_Illegal_Quantity
d7fb a5 61       LDA FAC1EX        ; get FAC1 exponent
d7fd c9 91       CMP #$91          ; compare with exponent = 2^16
d7ff b0 97       BCS Jump_To_Illegal_Quantity
d801 20 9b dc    JSR FAC1_To_Integer
d804 a5 64       LDA FAC1M3        ; get FAC1 mantissa 3
d806 a4 65       LDY FAC1M4        ; get FAC1 mantissa 4
d808 84 14       STY LINNUM        ; save temporary integer low byte
d80a 85 15       STA LINNUM+1      ; save temporary integer high byte
d80c 60          RTS ;Size   22 [FAC1_To_LINNUM]

              ; **********
d80d            Basic_PEEK
              ; **********

                 PUSHW(LINNUM)
d80d a5 15       LDA LINNUM+1
d80f 48          PHA
d810 a5 14       LDA LINNUM
d812 48          PHA

d813 20 f7 d7    JSR FAC1_To_LINNUM
d816 a0 00       LDY #0
d818 b1 14       LDA (LINNUM),Y    ; read byte
d81a a8          TAY               ; copy byte to Y
                 PULLW(LINNUM)
d81b 68          PLA
d81c 85 14       STA LINNUM
d81e 68          PLA
d81f 85 15       STA LINNUM+1

d821 4c a2 d3    JMP Y_To_Float

              ; **********
d824            Basic_POKE
              ; **********

d824 20 eb d7    JSR Get_Word_And_Byte
d827 8a          TXA               ; copy byte to A
d828 a0 00       LDY #0
d82a 91 14       STA (LINNUM),Y    ; write byte
d82c 60          RTS ;Size    9 [Basic_POKE]

              ; **********
d82d            Basic_WAIT
              ; **********

d82d 20 eb d7    JSR Get_Word_And_Byte
d830 86 49       STX FORPNT        ; save byte
d832 a2 00       LDX #0            ; clear mask
d834 20 79 00    JSR CHRGOT
d837 f0 03       BEQ WAIT_10      ; skip if no third argument
d839 20 f1 d7    JSR Need_Comma_Get_Byte

d83c          WAIT_10
d83c 86 4a       STX FORPNT+1      ; save EOR argument
d83e a0 00       LDY #0

d840          WAIT_20
d840 b1 14       LDA (LINNUM),Y    ; get byte via temporary integer (address)
d842 45 4a       EOR FORPNT+1      ; EOR with second argument       (mask)
d844 25 49       AND FORPNT        ; AND with first argument        (byte)
d846 f0 f8       BEQ WAIT_20       ; loop if result is zero

d848          WAIT_Ret
d848 60          RTS ;Size   28 [Basic_WAIT]

              ; ***************
d849            Add_0_5_To_FAC1
              ; ***************

                 LAYI(Float_0_5)
d849 a9 11       LDA #<Float_0_5
d84b a0 df       LDY #>Float_0_5

d84d 4c 67 d8    JMP Add_Var_AY_To_FAC1

              ; *************
d850            AY_Minus_FAC1
              ; *************

d850 20 8c da    JSR Load_FAC2_From_AY

              ; ***********
d853            Basic_MINUS
              ; ***********

d853 a5 66       LDA FAC1SI        ; get FAC1 sign (b7)
d855 49 ff       EOR #$FF          ; complement it
d857 85 66       STA FAC1SI        ; save FAC1 sign (b7)
d859 45 6e       EOR FAC2SI        ; EOR with FAC2 sign (b7)
d85b 85 6f       STA STRPTR        ; save sign compare (FAC1 EOR FAC2)
d85d a5 61       LDA FAC1EX        ; get FAC1 exponent
d85f 4c 6a d8    JMP Basic_PLUS    ; add FAC2 to FAC1 and return

d862          PLUS_00
d862 20 99 d9    JSR Shift_FACX_A
d865 90 3c       BCC PLUS_20      ; go subtract the mantissas, branch always

              ; ******************
d867            Add_Var_AY_To_FAC1
              ; ******************

d867 20 8c da    JSR Load_FAC2_From_AY

              ; **********
d86a            Basic_PLUS
              ; **********

d86a d0 03       BNE PLUS_05      ; if FAC1 is not zero continue
d86c 4c fc db    JMP FAC2_To_FAC1

d86f          PLUS_05
d86f a6 70       LDX FAC1M5        ; get FAC1 rounding byte
d871 86 56       STX FAC2M5        ; put FAC2 rounding byte
d873 a2 69       LDX #FAC2EX       ; set index to FAC2
d875 a5 69       LDA FAC2EX        ; get FAC2 exponent

              ; ****************
d877            Add_FAC2_To_FAC1
              ; ****************

d877 a8          TAY               ; copy exponent
d878 f0 ce       BEQ WAIT_Ret      ; exit if FAC2 is zero
d87a 38          SEC
d87b e5 61       SBC FAC1EX        ; FAC2 exponent - FAC1 exponent
d87d f0 24       BEQ PLUS_20       ; if equal go add mantissas
d87f 90 12       BCC PLUS_10       ; if FAC2 < FAC1 then shift FAC2 right
d881 84 61       STY FAC1EX        ; else                shift FAC1 right
d883 a4 6e       LDY FAC2SI        ; get FAC2 sign (b7)
d885 84 66       STY FAC1SI        ; put FAC1 sign (b7)
d887 49 ff       EOR #$FF          ; complement A
d889 69 00       ADC #$00          ; +1, twos complement, carry is set
d88b a0 00       LDY #0
d88d 84 56       STY FAC2M5        ; clear FAC2 rounding byte
d88f a2 61       LDX #FAC1EX       ; set index to FAC1
d891 d0 04       BNE PLUS_15       ; branch always

d893          PLUS_10
d893 a0 00       LDY #0
d895 84 70       STY FAC1M5        ; clear FAC1 rounding byte

d897          PLUS_15              ; shift FAC with lower exponent
d897 c9 f9       CMP #$F9          ; compare exponent diff with $F9
d899 30 c7       BMI PLUS_00       ; branch if range $79-$F8
d89b a8          TAY               ; copy exponent difference to Y
d89c a5 70       LDA FAC1M5        ; get FAC1 rounding byte
d89e 56 01       LSR 1,X           ; shift FAC mantissa 1
d8a0 20 b0 d9    JSR Shift_FACX_Right_Y

d8a3          PLUS_20
d8a3 24 6f       BIT STRPTR        ; test sign compare (FAC1 EOR FAC2)
d8a5 10 57       BPL PLUS_50      ; if = add FAC2 mantissa to FAC1 mantissa and return
d8a7 a0 61       LDY #FAC1EX       ; set index to FAC1 exponent address
d8a9 e0 69       CPX #FAC2EX       ; compare X to FAC2 exponent address
d8ab f0 02       BEQ PLUS_25       ; branch if equal
d8ad a0 69       LDY #FAC2EX       ; else set index to FAC2 exponent address

d8af          PLUS_25
d8af 38          SEC               ; compute FACY - FACX
d8b0 49 ff       EOR #$FF          ; ones complement A
d8b2 65 56       ADC FAC2M5        ; add FAC2 rounding byte
d8b4 85 70       STA FAC1M5        ; put FAC1 rounding byte
d8b6 b9 04 00    LDA 4,Y
d8b9 f5 04       SBC 4,X
d8bb 85 65       STA FAC1M4
d8bd b9 03 00    LDA 3,Y
d8c0 f5 03       SBC 3,X
d8c2 85 64       STA FAC1M3
d8c4 b9 02 00    LDA 2,Y
d8c7 f5 02       SBC 2,X
d8c9 85 63       STA FAC1M2
d8cb b9 01 00    LDA 1,Y
d8ce f5 01       SBC 1,X
d8d0 85 62       STA FAC1M1

d8d2          PLUS_30
d8d2 b0 03       BCS Normalise_FAC1
d8d4 20 47 d9    JSR Negate_FAC1

              ; **************
d8d7            Normalise_FAC1
              ; **************

d8d7 a0 00       LDY #0
d8d9 98          TYA
d8da 18          CLC

d8db          PLUS_35
d8db a6 62       LDX FAC1M1        ; get FAC1 mantissa 1
d8dd d0 4a       BNE PLUS_60      ; if not zero normalise FAC1
d8df a6 63       LDX FAC1M2        ; get FAC1 mantissa 2
d8e1 86 62       STX FAC1M1        ; save FAC1 mantissa 1
d8e3 a6 64       LDX FAC1M3        ; get FAC1 mantissa 3
d8e5 86 63       STX FAC1M2        ; save FAC1 mantissa 2
d8e7 a6 65       LDX FAC1M4        ; get FAC1 mantissa 4
d8e9 86 64       STX FAC1M3        ; save FAC1 mantissa 3
d8eb a6 70       LDX FAC1M5        ; get FAC1 rounding byte
d8ed 86 65       STX FAC1M4        ; save FAC1 mantissa 4
d8ef 84 70       STY FAC1M5        ; clear FAC1 rounding byte
d8f1 69 08       ADC #8            ; add x to exponent offset
d8f3 c9 20       CMP #$20          ; compare with $20, max offset, all bits would be = 0
d8f5 d0 e4       BNE PLUS_35       ; loop if not max

              ; =======================
d8f7            Clear_FAC1_Exp_And_Sign
              ; =======================

d8f7 a9 00       LDA #0
d8f9          PLUS_40
d8f9 85 61       STA FAC1EX        ; set FAC1 exponent

d8fb          PLUS_45
d8fb 85 66       STA FAC1SI        ; save FAC1 sign (b7)
d8fd 60          RTS ;Size   39 [Normalise_FAC1]

d8fe          PLUS_50
d8fe 65 56       ADC FAC2M5
d900 85 70       STA FAC1M5
d902 a5 65       LDA FAC1M4
d904 65 6d       ADC FAC2M4
d906 85 65       STA FAC1M4
d908 a5 64       LDA FAC1M3
d90a 65 6c       ADC FAC2M3
d90c 85 64       STA FAC1M3
d90e a5 63       LDA FAC1M2
d910 65 6b       ADC FAC2M2
d912 85 63       STA FAC1M2
d914 a5 62       LDA FAC1M1
d916 65 6a       ADC FAC2M1
d918 85 62       STA FAC1M1
d91a 4c 36 d9    JMP Test_And_Normalize_FAC1

d91d          PLUS_55
d91d 69 01       ADC #1
d91f 06 70       ASL FAC1M5
d921 26 65       ROL FAC1M4
d923 26 64       ROL FAC1M3
d925 26 63       ROL FAC1M2
d927 26 62       ROL FAC1M1

d929          PLUS_60
d929 10 f2       BPL PLUS_55      ; loop if not normalised
d92b 38          SEC
d92c e5 61       SBC FAC1EX        ; subtract FAC1 exponent
d92e b0 c7       BCS Clear_FAC1_Exp_And_Sign ; branch if underflow (set result = $0)
d930 49 ff       EOR #$FF          ; complement exponent
d932 69 01       ADC #$01          ; +1 (twos complement)
d934 85 61       STA FAC1EX        ; save FAC1 exponent

              ; =======================
d936            Test_And_Normalize_FAC1
              ; =======================

d936 90 0e       BCC TANF_Ret      ; exit if no overflow

d938          TANF_10
d938 e6 61       INC FAC1EX        ; increment FAC1 exponent
d93a f0 42       BEQ Overflow_Error
d93c 66 62       ROR FAC1M1        ; shift FAC1 mantissa 1
d93e 66 63       ROR FAC1M2        ; shift FAC1 mantissa 2
d940 66 64       ROR FAC1M3        ; shift FAC1 mantissa 3
d942 66 65       ROR FAC1M4        ; shift FAC1 mantissa 4
d944 66 70       ROR FAC1M5        ; shift FAC1 rounding byte

d946          TANF_Ret
d946 60          RTS ;Size  112 [Normalise_FAC1]

              ; ***********
d947            Negate_FAC1
              ; ***********

d947 a5 66       LDA FAC1SI        ; get FAC1 sign (b7)
d949 49 ff       EOR #$FF          ; complement it
d94b 85 66       STA FAC1SI        ; save FAC1 sign (b7)

              ; ********************
d94d            Negate_FAC1_Mantissa
              ; ********************

d94d a5 62       LDA FAC1M1
d94f 49 ff       EOR #$FF
d951 85 62       STA FAC1M1
d953 a5 63       LDA FAC1M2
d955 49 ff       EOR #$FF
d957 85 63       STA FAC1M2
d959 a5 64       LDA FAC1M3
d95b 49 ff       EOR #$FF
d95d 85 64       STA FAC1M3
d95f a5 65       LDA FAC1M4
d961 49 ff       EOR #$FF
d963 85 65       STA FAC1M4
d965 a5 70       LDA FAC1M5
d967 49 ff       EOR #$FF
d969 85 70       STA FAC1M5
d96b e6 70       INC FAC1M5
d96d d0 0e       BNE IFM_Ret

              ; *****************
d96f            Inc_FAC1_Mantissa
              ; *****************

d96f e6 65       INC FAC1M4
d971 d0 0a       BNE IFM_Ret
d973 e6 64       INC FAC1M3
d975 d0 06       BNE IFM_Ret
d977 e6 63       INC FAC1M2
d979 d0 02       BNE IFM_Ret
d97b e6 62       INC FAC1M1

d97d          IFM_Ret
d97d 60          RTS ;Size   15 [Inc_FAC1_Mantissa]

              ; ==============
d97e            Overflow_Error
              ; ==============

d97e a2 0f       LDX #$0F          ; error $0F, overflow error
d980 4c 37 c4    JMP Basic_Error

              ; ==========
d983            Shift_FAC3
              ; ==========

d983 a2 25       LDX #FAC3         ; apply shift routines on FAC3

              ; ==========
d985            Shift_FACX
              ; ==========

d985 b4 04       LDY 4,X
d987 84 70       STY FAC1M5      ; mantissa 4 -> rounding byte
d989 b4 03       LDY 3,X
d98b 94 04       STY 4,X           ; mantissa 3 -> 4
d98d b4 02       LDY 2,X
d98f 94 03       STY 3,X           ; mantissa 2 -> 3
d991 b4 01       LDY 1,X
d993 94 02       STY 2,X           ; mantissa 1 -> 2
d995 a4 68       LDY FAC1OV
d997 94 01       STY 1,X           ; overflow -> mantissa 1

              ; ************
d999            Shift_FACX_A
              ; ************

d999 69 08       ADC #8            ; add 8 to shift count
d99b 30 e8       BMI Shift_FACX    ; if still negative shift byte wise
d99d f0 e6       BEQ Shift_FACX    ; 8 shifts to do
d99f e9 08       SBC #8            ; reverse the addition
d9a1 a8          TAY               ; save shift count to Y
d9a2 a5 70       LDA FAC1M5      ; get FAC1 rounding byte
d9a4 b0 14       BCS ShFA_30

d9a6          ShFA_10
d9a6 16 01       ASL 1,X           ; shift sign to carry, bit0 set to 0
d9a8 90 02       BCC ShFA_20       ; branch if positive
d9aa f6 01       INC 1,X           ; bit0 set to 1

d9ac          ShFA_20              ; bit0 equals now sign (in carry)
d9ac 76 01       ROR 1,X           ; shift FACX mantissa 1 with sign extension
d9ae 76 01       ROR 1,X           ; shift FACX mantissa 1 with sign extension

              ; ******************
d9b0            Shift_FACX_Right_Y
              ; ******************

d9b0 76 02       ROR 2,X           ; shift FACX mantissa 2
d9b2 76 03       ROR 3,X           ; shift FACX mantissa 3
d9b4 76 04       ROR 4,X           ; shift FACX mantissa 4
d9b6 6a          ROR A             ; shift FACX rounding byte
d9b7 c8          INY               ; increment exponent diff
d9b8 d0 ec       BNE ShFA_10       ; branch if range adjust not complete

d9ba          ShFA_30
d9ba 18          CLC               ; just clear it
d9bb 60          RTS ;Size   12 [Shift_FACX_Right_Y]

              ; constants and series for LOG(n)

d9bc 81 00 00 REAL_1 .real 1

d9c1          VLOG_A
d9c1 03          .byte   $03            ; series counter
d9c2 7f 5e 56    .real   0.4342559419
d9c7 80 13 9b    .real   0.5765845413
d9cc 80 76 38    .real   0.9618007592
d9d1 82 38 aa    .real   2.8853900731

d9d6 80 35 04 HALF_SQRT_2 .real   0.7071067812  ; 0.5 * sqrt(2.0)
d9db 81 35 04 SQRT_2      .real   1.4142135624  ; sqrt(2.0)
d9e0 80 80 00 MINUS_0_5   .real  -0.5
d9e5 80 31 72 LN_2        .real   0.6931471807  ; ln(2.0)

              ; *********
d9ea            Basic_LOG
              ; *********

d9ea 20 2b dc    JSR Get_FAC1_Sign
d9ed f0 02       BEQ LOG_10        ; if zero do illegal quantity
d9ef 10 03       BPL LOG_20        ; skip error if positive

d9f1          LOG_10
d9f1 4c 48 d2    JMP Illegal_Quantity      ; do illegal quantity error then warm start

d9f4          LOG_20
d9f4 a5 61       LDA FAC1EX        ; get FAC1 exponent
d9f6 e9 7f       SBC #$7F          ; normalise it
d9f8 48          PHA               ; save it
d9f9 a9 80       LDA #$80          ; set exponent to zero
d9fb 85 61       STA FAC1EX        ; save FAC1 exponent
                 LAYI(HALF_SQRT_2)
d9fd a9 d6       LDA #<HALF_SQRT_2
d9ff a0 d9       LDY #>HALF_SQRT_2

da01 20 67 d8    JSR Add_Var_AY_To_FAC1
                 LAYI(SQRT_2)
da04 a9 db       LDA #<SQRT_2
da06 a0 d9       LDY #>SQRT_2

da08 20 0f db    JSR AY_Divided_By_FAC1
                 LAYI(REAL_1)
da0b a9 bc       LDA #<REAL_1
da0d a0 d9       LDY #>REAL_1

da0f 20 50 d8    JSR AY_Minus_FAC1
                 LAYI(VLOG_A)
da12 a9 c1       LDA #<VLOG_A
da14 a0 d9       LDY #>VLOG_A

da16 20 40 e0    JSR Square_And_Series_Eval
                 LAYI(MINUS_0_5)
da19 a9 e0       LDA #<MINUS_0_5
da1b a0 d9       LDY #>MINUS_0_5

da1d 20 67 d8    JSR Add_Var_AY_To_FAC1
da20 68          PLA               ; restore FAC1 exponent
da21 20 7e dd    JSR Add_A_To_FAC1
                 LAYI(LN_2)
da24 a9 e5       LDA #<LN_2
da26 a0 d9       LDY #>LN_2


              ; *********************
da28            Multiply_FAC1_With_AY
              ; *********************

da28 20 8c da    JSR Load_FAC2_From_AY

              ; **************
da2b            Basic_MULTIPLY
              ; **************

da2b d0 03       BNE MULT_10       ; multiply FAC1 by FAC2 ??
da2d 4c 8b da    JMP Mult_Sub_Ret  ; exit if zero

da30          MULT_10
da30 20 b7 da    JSR Check_FACs
da33 a9 00       LDA #0
da35 85 26       STA FAC3+1
da37 85 27       STA FAC3+2
da39 85 28       STA FAC3+3
da3b 85 29       STA FAC3+4
da3d a5 70       LDA FAC1M5
da3f 20 59 da    JSR Mult_SubA
da42 a5 65       LDA FAC1M4
da44 20 59 da    JSR Mult_SubA
da47 a5 64       LDA FAC1M3
da49 20 59 da    JSR Mult_SubA
da4c a5 63       LDA FAC1M2
da4e 20 59 da    JSR Mult_SubA
da51 a5 62       LDA FAC1M1
da53 20 5e da    JSR Mult_SubB
da56 4c 8f db    JMP FAC3_To_FAC1

              ; =========
da59            Mult_SubA
              ; =========

da59 d0 03       BNE Mult_SubB
da5b 4c 83 d9    JMP Shift_FAC3

              ; =========
da5e            Mult_SubB
              ; =========

da5e 4a          LSR A             ; shift byte
da5f 09 80       ORA #$80          ; set top bit (mark for 8 times)

da61          MULT_20
da61 a8          TAY               ; copy result
da62 90 19       BCC MULT_30       ; skip next if bit was zero
da64 18          CLC
da65 a5 29       LDA FAC3+4
da67 65 6d       ADC FAC2M4
da69 85 29       STA FAC3+4
da6b a5 28       LDA FAC3+3
da6d 65 6c       ADC FAC2M3
da6f 85 28       STA FAC3+3
da71 a5 27       LDA FAC3+2
da73 65 6b       ADC FAC2M2
da75 85 27       STA FAC3+2
da77 a5 26       LDA FAC3+1
da79 65 6a       ADC FAC2M1
da7b 85 26       STA FAC3+1

da7d          MULT_30
da7d 66 26       ROR FAC3+1
da7f 66 27       ROR FAC3+2
da81 66 28       ROR FAC3+3
da83 66 29       ROR FAC3+4
da85 66 70       ROR FAC1M5
da87 98          TYA               ; get byte back
da88 4a          LSR A             ; shift byte
da89 d0 d6       BNE MULT_20       ; loop if all bits not done

da8b          Mult_Sub_Ret
da8b 60          RTS ;Size   97 [Basic_MULTIPLY]

              ; *****************
da8c            Load_FAC2_From_AY
              ; *****************

                 STAY(INDEXA)
da8c 85 22       STA INDEXA
da8e 84 23       STY INDEXA+1

da90 a0 04       LDY #4            ; 5 bytes to get (0-4)
da92 b1 22       LDA (INDEXA),Y    ; get mantissa 4
da94 85 6d       STA FAC2M4        ; save FAC2 mantissa 4
da96 88          DEY               ; decrement index
da97 b1 22       LDA (INDEXA),Y    ; get mantissa 3
da99 85 6c       STA FAC2M3        ; save FAC2 mantissa 3
da9b 88          DEY               ; decrement index
da9c b1 22       LDA (INDEXA),Y    ; get mantissa 2
da9e 85 6b       STA FAC2M2        ; save FAC2 mantissa 2
daa0 88          DEY               ; decrement index
daa1 b1 22       LDA (INDEXA),Y    ; get mantissa 1 + sign
daa3 85 6e       STA FAC2SI        ; save FAC2 sign (b7)
daa5 45 66       EOR FAC1SI        ; EOR with FAC1 sign (b7)
daa7 85 6f       STA STRPTR        ; save sign compare (FAC1 EOR FAC2)
daa9 a5 6e       LDA FAC2SI        ; recover FAC2 sign (b7)
daab 09 80       ORA #$80          ; set 1xxx xxx (set normal bit)
daad 85 6a       STA FAC2M1        ; save FAC2 mantissa 1
daaf 88          DEY               ; decrement index
dab0 b1 22       LDA (INDEXA),Y    ; get exponent byte
dab2 85 69       STA FAC2EX        ; save FAC2 exponent
dab4 a5 61       LDA FAC1EX        ; get FAC1 exponent
dab6 60          RTS ;Size   43 [Load_FAC2_From_AY]

              ; **********
dab7            Check_FACs
              ; **********

dab7 a5 69       LDA FAC2EX        ; get FAC2 exponent

              ; ------------
dab9            Check_FACs_A
              ; ------------

dab9 f0 1f       BEQ ChFA_30       ; branch if FAC2 = $00 (handle underflow)
dabb 18          CLC
dabc 65 61       ADC FAC1EX        ; add FAC1 exponent
dabe 90 04       BCC ChFA_10       ; branch if sum of exponents < $0100
dac0 30 1d       BMI ChFA_40       ; do overflow error
dac2 18          CLC
dac3 2c          .byte   $2C       ; skip next statement

dac4          ChFA_10
dac4 10 14       BPL ChFA_30       ; if positive go handle underflow
dac6 69 80       ADC #$80          ; adjust exponent
dac8 85 61       STA FAC1EX        ; save FAC1 exponent
daca d0 03       BNE ChFA_20       ; branch if not zero
dacc 4c fb d8    JMP PLUS_45       ; save FAC1 sign and return

dacf          ChFA_20
dacf a5 6f       LDA STRPTR        ; get sign compare (FAC1 EOR FAC2)
dad1 85 66       STA FAC1SI        ; save FAC1 sign (b7)
dad3 60          RTS ;Size   29 [Check_FACs]

              ; **************
dad4            Check_Overflow
              ; **************

dad4 a5 66       LDA FAC1SI        ; get FAC1 sign (b7)
dad6 49 ff       EOR #$FF          ; complement it
dad8 30 05       BMI ChFA_40       ; do overflow error

dada          ChFA_30
dada 68          PLA               ; pop return address low byte
dadb 68          PLA               ; pop return address high byte
dadc 4c f7 d8    JMP Clear_FAC1_Exp_And_Sign

dadf          ChFA_40
dadf 4c 7e d9    JMP Overflow_Error

              ; *******************
dae2            Multiply_FAC1_BY_10
              ; *******************

dae2 20 0c dc    JSR FAC1_Round_And_Copy_To_FAC2
dae5 aa          TAX               ; copy exponent (set the flags)
dae6 f0 10       BEQ Mu10_Ret      ; exit if zero
dae8 18          CLC
dae9 69 02       ADC #$02          ; add two to exponent (*4)
daeb b0 f2       BCS ChFA_40       ; do overflow error if > $FF

              ; ------------------
daed            Multiply_FAC1_By_4
              ; ------------------

daed a2 00       LDX #0
daef 86 6f       STX STRPTR        ; clear sign compare (FAC1 EOR FAC2)
daf1 20 77 d8    JSR Add_FAC2_To_FAC1
daf4 e6 61       INC FAC1EX        ; increment FAC1 exponent (*2)
daf6 f0 e7       BEQ ChFA_40       ; if exponent now zero go do overflow error

daf8          Mu10_Ret
daf8 60          RTS ;Size   23 [Multiply_FAC1_BY_10]

daf9 84 20 00 Float_10 .real 10

              ; *****************
dafe            Divide_FAC1_By_10
              ; *****************

dafe 20 0c dc    JSR FAC1_Round_And_Copy_To_FAC2
                 LAYI(Float_10)
db01 a9 f9       LDA #<Float_10
db03 a0 da       LDY #>Float_10

db05 a2 00       LDX #0            ; clear sign

              ; *****************
db07            Divide_FAC2_By_AY
              ; *****************

db07 86 6f       STX STRPTR        ; save sign compare (FAC1 EOR FAC2)
db09 20 a2 db    JSR Load_FAC1_AY
db0c 4c 12 db    JMP Basic_DIVIDE  ; do FAC2/FAC1

              ; ******************
db0f            AY_Divided_By_FAC1
              ; ******************

db0f 20 8c da    JSR Load_FAC2_From_AY

              ; ************
db12            Basic_DIVIDE
              ; ************

db12 f0 76       BEQ Divide_By_Zero; if zero go do /0 error
db14 20 1b dc    JSR Round_FAC1_Checked
db17 a9 00       LDA #0
db19 38          SEC
db1a e5 61       SBC FAC1EX        ; subtract FAC1 exponent (2s complement)
db1c 85 61       STA FAC1EX        ; save FAC1 exponent
db1e 20 b7 da    JSR Check_FACs
db21 e6 61       INC FAC1EX        ; increment FAC1 exponent
db23 f0 ba       BEQ ChFA_40       ; if zero do overflow error
db25 a2 fc       LDX #$FC          ; set index to FAC temp
db27 a9 01       LDA #$01          ; set byte

db29          DIVI_10
db29 a4 6a       LDY FAC2M1        ; compare mantissa
db2b c4 62       CPY FAC1M1
db2d d0 10       BNE DIVI_20
db2f a4 6b       LDY FAC2M2
db31 c4 63       CPY FAC1M2
db33 d0 0a       BNE DIVI_20
db35 a4 6c       LDY FAC2M3
db37 c4 64       CPY FAC1M3
db39 d0 04       BNE DIVI_20
db3b a4 6d       LDY FAC2M4
db3d c4 65       CPY FAC1M4

db3f          DIVI_20
db3f 08          PHP               ; save the FAC2-FAC1 compare status
db40 2a          ROL A             ; shift byte
db41 90 09       BCC DIVI_30       ; skip next if no carry
db43 e8          INX               ; increment index to FAC temp
db44 95 29       STA FAC3+4,X
db46 f0 32       BEQ DIVI_60
db48 10 34       BPL DIVI_70
db4a a9 01       LDA #1

db4c          DIVI_30
db4c 28          PLP               ; restore FAC2-FAC1 compare status
db4d b0 0e       BCS DIVI_50       ; if FAC2 >= FAC1 then do subtract

db4f          DIVI_40
db4f 06 6d       ASL FAC2M4        ; shift FAC2 mantissa 4
db51 26 6c       ROL FAC2M3        ; shift FAC2 mantissa 3
db53 26 6b       ROL FAC2M2        ; shift FAC2 mantissa 2
db55 26 6a       ROL FAC2M1        ; shift FAC2 mantissa 1
db57 b0 e6       BCS DIVI_20       ; loop with no compare
db59 30 ce       BMI DIVI_10       ; loop with compare
db5b 10 e2       BPL DIVI_20       ; loop always with no compare

db5d          DIVI_50
db5d a8          TAY               ; save FAC2-FAC1 compare status
db5e a5 6d       LDA FAC2M4        ; FAC2 = FAC2 - FAC1
db60 e5 65       SBC FAC1M4
db62 85 6d       STA FAC2M4
db64 a5 6c       LDA FAC2M3
db66 e5 64       SBC FAC1M3
db68 85 6c       STA FAC2M3
db6a a5 6b       LDA FAC2M2
db6c e5 63       SBC FAC1M2
db6e 85 6b       STA FAC2M2
db70 a5 6a       LDA FAC2M1
db72 e5 62       SBC FAC1M1
db74 85 6a       STA FAC2M1
db76 98          TYA               ; restore FAC2-FAC1 compare status
db77 4c 4f db    JMP DIVI_40       ; go shift FAC2

db7a          DIVI_60
db7a a9 40       LDA #$40
db7c d0 ce       BNE DIVI_30

db7e          DIVI_70
db7e 0a          ASL A
db7f 0a          ASL A
db80 0a          ASL A
db81 0a          ASL A
db82 0a          ASL A
db83 0a          ASL A
db84 85 70       STA FAC1M5        ; save FAC1 rounding byte
db86 28          PLP               ; dump FAC2-FAC1 compare status
db87 4c 8f db    JMP FAC3_To_FAC1

              ; ==============
db8a            Divide_By_Zero
              ; ==============

db8a a2 14       LDX #$14          ; error $14, divide by zero error
db8c 4c 37 c4    JMP Basic_Error

              ; ============
db8f            FAC3_To_FAC1
              ; ============

db8f a5 26       LDA FAC3+1
db91 85 62       STA FAC1M1
db93 a5 27       LDA FAC3+2
db95 85 63       STA FAC1M2
db97 a5 28       LDA FAC3+3
db99 85 64       STA FAC1M3
db9b a5 29       LDA FAC3+4
db9d 85 65       STA FAC1M4
db9f 4c d7 d8    JMP Normalise_FAC1

              ; ************
dba2            Load_FAC1_AY
              ; ************

                 STAY(INDEXA)
dba2 85 22       STA INDEXA
dba4 84 23       STY INDEXA+1

dba6 a0 04       LDY #$04          ; 5 bytes to do
dba8 b1 22       LDA (INDEXA),Y    ; get fifth byte
dbaa 85 65       STA FAC1M4        ; save FAC1 mantissa 4
dbac 88          DEY               ; decrement index
dbad b1 22       LDA (INDEXA),Y    ; get fourth byte
dbaf 85 64       STA FAC1M3        ; save FAC1 mantissa 3
dbb1 88          DEY               ; decrement index
dbb2 b1 22       LDA (INDEXA),Y    ; get third byte
dbb4 85 63       STA FAC1M2        ; save FAC1 mantissa 2
dbb6 88          DEY               ; decrement index
dbb7 b1 22       LDA (INDEXA),Y    ; get second byte
dbb9 85 66       STA FAC1SI        ; save FAC1 sign (b7)
dbbb 09 80       ORA #$80          ; set 1xxx xxxx (add normal bit)
dbbd 85 62       STA FAC1M1        ; save FAC1 mantissa 1
dbbf 88          DEY               ; decrement index
dbc0 b1 22       LDA (INDEXA),Y    ; get first byte (exponent)
dbc2 85 61       STA FAC1EX        ; save FAC1 exponent
dbc4 84 70       STY FAC1M5        ; clear FAC1 rounding byte
dbc6 60          RTS ;Size   37 [Load_FAC1_AY]

              ; **************
dbc7            FAC1_To_FACTPB
              ; **************

dbc7 a2 5c       LDX #<FACTPB      ; set pointer low byte
dbc9 2c          .byte   $2C       ; skip next statement

              ; **************
dbca            FAC1_To_FACTPA
              ; **************

dbca a2 57       LDX #<FACTPA      ; set pointer low byte
dbcc a0 00       LDY #>FACTPA      ; set pointer high byte
dbce f0 04       BEQ Assign_FAC1_To_Var

              ; ************************
dbd0            Assign_FAC1_To_FOR_Index
              ; ************************

                 LDXY(FORPNT)
dbd0 a6 49       LDX FORPNT
dbd2 a4 4a       LDY FORPNT+1


              ; ******************
dbd4            Assign_FAC1_To_Var
              ; ******************

dbd4 20 1b dc    JSR Round_FAC1_Checked
                 STXY(INDEXA)
dbd7 86 22       STX INDEXA
dbd9 84 23       STY INDEXA+1

dbdb a0 04       LDY #$04          ; set index
dbdd a5 65       LDA FAC1M4        ; get FAC1 mantissa 4
dbdf 91 22       STA (INDEXA),Y    ; store in destination
dbe1 88          DEY               ; decrement index
dbe2 a5 64       LDA FAC1M3        ; get FAC1 mantissa 3
dbe4 91 22       STA (INDEXA),Y    ; store in destination
dbe6 88          DEY               ; decrement index
dbe7 a5 63       LDA FAC1M2        ; get FAC1 mantissa 2
dbe9 91 22       STA (INDEXA),Y    ; store in destination
dbeb 88          DEY               ; decrement index
dbec a5 66       LDA FAC1SI        ; get FAC1 sign (b7)
dbee 09 7f       ORA #$7F          ; set bits x111 1111
dbf0 25 62       AND FAC1M1        ; AND in FAC1 mantissa 1
dbf2 91 22       STA (INDEXA),Y    ; store in destination
dbf4 88          DEY               ; decrement index
dbf5 a5 61       LDA FAC1EX        ; get FAC1 exponent
dbf7 91 22       STA (INDEXA),Y    ; store in destination
dbf9 84 70       STY FAC1M5        ; clear FAC1 rounding byte
dbfb 60          RTS ;Size   40 [Assign_FAC1_To_Var]

              ; ************
dbfc            FAC2_To_FAC1
              ; ************

dbfc a5 6e       LDA FAC2SI        ; get FAC2 sign (b7)

              ; ---------------------
dbfe            Copy_ABS_FAC2_To_FAC1
              ; ---------------------

dbfe 85 66       STA FAC1SI        ; save FAC1 sign (b7)
dc00 a2 05       LDX #5            ; 5 bytes to copy

dc02          F2F1_Loop
dc02 b5 68       LDA FAC2EX-1,X
dc04 95 60       STA FAC1EX-1,X
dc06 ca          DEX
dc07 d0 f9       BNE F2F1_Loop
dc09 86 70       STX FAC1M5        ; clear FAC1 rounding byte
dc0b 60          RTS ;Size   16 [FAC2_To_FAC1]

              ; ***************************
dc0c            FAC1_Round_And_Copy_To_FAC2
              ; ***************************

dc0c 20 1b dc    JSR Round_FAC1_Checked

              ; ************
dc0f            FAC1_To_FAC2
              ; ************

dc0f a2 06       LDX #6

dc11          F1F2_Loop
dc11 b5 60       LDA FAC1EX-1,X
dc13 95 68       STA FAC2EX-1,X
dc15 ca          DEX
dc16 d0 f9       BNE F1F2_Loop
dc18 86 70       STX FAC1M5        ; clear FAC1 rounding byte

dc1a          F1F2_Ret
dc1a 60          RTS ;Size   12 [FAC1_To_FAC2]

              ; ******************
dc1b            Round_FAC1_Checked
              ; ******************

dc1b a5 61       LDA FAC1EX        ; get FAC1 exponent
dc1d f0 fb       BEQ F1F2_Ret      ; exit if zero
dc1f 06 70       ASL FAC1M5        ; shift FAC1 rounding byte
dc21 90 f7       BCC F1F2_Ret      ; exit if no overflow

              ; ----------
dc23            Round_FAC1
              ; ----------

dc23 20 6f d9    JSR Inc_FAC1_Mantissa
dc26 d0 f2       BNE F1F2_Ret      ; branch if no overflow
dc28 4c 38 d9    JMP TANF_10       ; normalise FAC1 for C=1 and return

              ; *************
dc2b            Get_FAC1_Sign
              ; *************

dc2b a5 61       LDA FAC1EX        ; get FAC1 exponent
dc2d f0 09       BEQ GFS_Ret       ; exit if zero

dc2f          GFS_10
dc2f a5 66       LDA FAC1SI        ; else get FAC1 sign (b7)

dc31          GFS_20
dc31 2a          ROL A             ; move sign bit to carry
dc32 a9 ff       LDA #$FF          ; set byte for negative result
dc34 b0 02       BCS GFS_Ret       ; return if sign was set (negative)

dc36 a9 01       LDA #1            ; else set byte for positive result
dc38          GFS_Ret
dc38 60          RTS ;Size   14 [Get_FAC1_Sign]

              ; *********
dc39            Basic_SGN
              ; *********

dc39 20 2b dc    JSR Get_FAC1_Sign

              ; *********
dc3c            A_To_FAC1
              ; *********

dc3c 85 62       STA FAC1M1        ; save FAC1 mantissa 1
dc3e a9 00       LDA #0
dc40 85 63       STA FAC1M2        ; clear FAC1 mantissa 2
dc42 a2 88       LDX #$88          ; set exponent

              ; ==================
dc44            Int_To_Float_Exp_X
              ; ==================

dc44 a5 62       LDA FAC1M1        ; get FAC1 mantissa 1
dc46 49 ff       EOR #$FF          ; complement it
dc48 2a          ROL A             ; sign bit into carry

              ; ****************
dc49            Convert_Integer_To_Float
              ; ****************

dc49 a9 00       LDA #0
dc4b 85 65       STA FAC1M4        ; clear FAC1 mantissa 4
dc4d 85 64       STA FAC1M3        ; clear FAC1 mantissa 3

              ; set exponent = X and normalise FAC1

dc4f          CITF_10
dc4f 86 61       STX FAC1EX        ; set FAC1 exponent
dc51 85 70       STA FAC1M5        ; clear FAC1 rounding byte
dc53 85 66       STA FAC1SI        ; clear FAC1 sign (b7)
dc55 4c d2 d8    JMP PLUS_30       ; do ABS and normalise FAC1

              ; *********
dc58            Basic_ABS
              ; *********

dc58 46 66       LSR FAC1SI        ; clear FAC1 sign, put zero in b7
dc5a 60          RTS ;Size    3 [Basic_ABS]

              ; ***************
dc5b            Compare_FAC1_AY
              ; ***************

dc5b 85 24       STA INDEXB        ; save pointer low byte

              ; returns A =  0 if FAC1 = (AY)
              ; returns A =  1 if FAC1 > (AY)
              ; returns A = -1 if FAC1 < (AY)

              ; ---------------------
dc5d            Compare_FAC1_INDEXB_Y
              ; ---------------------

dc5d 84 25       STY INDEXB+1      ; save pointer high byte
dc5f a0 00       LDY #0
dc61 b1 24       LDA (INDEXB),Y    ; get exponent
dc63 c8          INY
dc64 aa          TAX               ; copy (AY) exponent to X
dc65 f0 c4       BEQ Get_FAC1_Sign
dc67 b1 24       LDA (INDEXB),Y    ; get (AY) mantissa 1, with sign
dc69 45 66       EOR FAC1SI        ; EOR FAC1 sign (b7)
dc6b 30 c2       BMI GFS_10        ; if signs <> do return A = $FF, Cb = 1/negative
dc6d e4 61       CPX FAC1EX        ; compare (AY) exponent with FAC1 exponent
dc6f d0 21       BNE CPFA_10       ; branch if different
dc71 b1 24       LDA (INDEXB),Y    ; get (AY) mantissa 1, with sign
dc73 09 80       ORA #$80          ; normalise top bit
dc75 c5 62       CMP FAC1M1        ; compare with FAC1 mantissa 1
dc77 d0 19       BNE CPFA_10       ; branch if different
dc79 c8          INY
dc7a b1 24       LDA (INDEXB),Y    ; get mantissa 2
dc7c c5 63       CMP FAC1M2        ; compare with FAC1 mantissa 2
dc7e d0 12       BNE CPFA_10       ; branch if different
dc80 c8          INY
dc81 b1 24       LDA (INDEXB),Y    ; get mantissa 3
dc83 c5 64       CMP FAC1M3        ; compare with FAC1 mantissa 3
dc85 d0 0b       BNE CPFA_10       ; branch if different
dc87 c8          INY
dc88 a9 7f       LDA #$7F          ; set for 1/2 value rounding byte
dc8a c5 70       CMP FAC1M5        ; compare with FAC1 rounding byte (set carry)
dc8c b1 24       LDA (INDEXB),Y    ; get mantissa 4
dc8e e5 65       SBC FAC1M4        ; subtract FAC1 mantissa 4
dc90 f0 28       BEQ FATI_20       ; exit if mantissa 4 equal

              ; gets here if number <> FAC1

dc92          CPFA_10
dc92 a5 66       LDA FAC1SI        ; get FAC1 sign (b7)
dc94 90 02       BCC CPFA_20       ; branch if FAC1 > (AY)
dc96 49 ff       EOR #$FF          ; else toggle FAC1 sign

dc98          CPFA_20
dc98 4c 31 dc    JMP GFS_20        ; return A = $FF, Cb = 1/negative A = $01, Cb = 0/positive

              ; ***************
dc9b            FAC1_To_Integer
              ; ***************

dc9b a5 61       LDA FAC1EX
dc9d f0 4a       BEQ Clear_FAC1
dc9f 38          SEC
dca0 e9 a0       SBC #$A0          ; subtract maximum integer range exponent
dca2 24 66       BIT FAC1SI        ; test FAC1 sign (b7)
dca4 10 09       BPL FATI_10       ; branch if FAC1 positive
dca6 aa          TAX               ; copy subtracted exponent
dca7 a9 ff       LDA #$FF          ; overflow for negative number
dca9 85 68       STA FAC1OV        ; set FAC1 overflow byte
dcab 20 4d d9    JSR Negate_FAC1_Mantissa
dcae 8a          TXA               ; restore subtracted exponent

dcaf          FATI_10
dcaf a2 61       LDX #FAC1EX
dcb1 c9 f9       CMP #$F9          ; compare exponent result
dcb3 10 06       BPL FATI_30       ; less than 8 shifts
dcb5 20 99 d9    JSR Shift_FACX_A
dcb8 84 68       STY FAC1OV        ; clear FAC1 overflow byte

dcba          FATI_20
dcba 60          RTS ;Size   32 [FAC1_To_Integer]

dcbb          FATI_30
dcbb a8          TAY               ; copy shift count
dcbc a5 66       LDA FAC1SI        ; get FAC1 sign (b7)
dcbe 29 80       AND #$80          ; mask sign bit only (x000 0000)
dcc0 46 62       LSR FAC1M1        ; shift FAC1 mantissa 1
dcc2 05 62       ORA FAC1M1        ; OR sign in b7 FAC1 mantissa 1
dcc4 85 62       STA FAC1M1        ; save FAC1 mantissa 1
dcc6 20 b0 d9    JSR Shift_FACX_Right_Y
dcc9 84 68       STY FAC1OV        ; clear FAC1 overflow byte
dccb 60          RTS ;Size   49 [FAC1_To_Integer]

              ; *********
dccc            Basic_INT
              ; *********

dccc a5 61       LDA FAC1EX        ; get FAC1 exponent
dcce c9 a0       CMP #$A0          ; compare with max int
dcd0 b0 20       BCS ClF1_Ret      ; exit if >= (allready int, too big for fractional part!)
dcd2 20 9b dc    JSR FAC1_To_Integer
dcd5 84 70       STY FAC1M5        ; save FAC1 rounding byte
dcd7 a5 66       LDA FAC1SI        ; get FAC1 sign (b7)
dcd9 84 66       STY FAC1SI        ; save FAC1 sign (b7)
dcdb 49 80       EOR #$80          ; toggle FAC1 sign
dcdd 2a          ROL A             ; shift into carry
dcde a9 a0       LDA #$A0          ; set new exponent
dce0 85 61       STA FAC1EX        ; save FAC1 exponent
dce2 a5 65       LDA FAC1M4        ; get FAC1 mantissa 4
dce4 85 07       STA CHARAC        ; save FAC1 mantissa 4 for power function
dce6 4c d2 d8    JMP PLUS_30      ; do ABS and normalise FAC1

              ; ==========
dce9            Clear_FAC1
              ; ==========

dce9 85 62       STA FAC1M1
dceb 85 63       STA FAC1M2
dced 85 64       STA FAC1M3
dcef 85 65       STA FAC1M4
dcf1 a8          TAY

dcf2          ClF1_Ret
dcf2 60          RTS ;Size   39 [Basic_INT]

              ; *********************
dcf3            Load_FAC1_From_String
              ; *********************

dcf3 a0 00       LDY #0
dcf5 a2 0a       LDX #10

dcf7          LFFS_05
dcf7 94 5d       STY TMPVA1,X      ; clear 10 bytes TMPVA1 & FAC1 ($5D - $66)
dcf9 ca          DEX
dcfa 10 fb       BPL LFFS_05
dcfc 90 0f       BCC LFFS_20       ; branch if first character is numeric
dcfe c9 2d       CMP #'-'          ; else compare with "-"
dd00 d0 04       BNE LFFS_10       ; branch if not "-"
dd02 86 67       STX SGNFLG        ; set flag for negative n (X = $FF)
dd04 f0 04       BEQ LFFS_15       ; branch always

dd06          LFFS_10
dd06 c9 2b       CMP #'+'          ; else compare with "+"
dd08 d0 05       BNE LFFS_25       ; branch if not "+"

dd0a          LFFS_15
dd0a 20 73 00    JSR CHRGET        ; next char

dd0d          LFFS_20
dd0d 90 5b       BCC LFFS_75       ; branch if numeric character

dd0f          LFFS_25
dd0f c9 2e       CMP #'.'
dd11 f0 2e       BEQ LFFS_40
dd13 c9 45       CMP #'E'
dd15 d0 30       BNE LFFS_45
dd17 20 73 00    JSR CHRGET        ; read exponent
dd1a 90 17       BCC LFFS_37       ; branch if numeric character
dd1c c9 ab       CMP #TK_MINUS
dd1e f0 0e       BEQ LFFS_30
dd20 c9 2d       CMP #'-'
dd22 f0 0a       BEQ LFFS_30
dd24 c9 aa       CMP #TK_PLUS
dd26 f0 08       BEQ LFFS_35
dd28 c9 2b       CMP #'+'
dd2a f0 04       BEQ LFFS_35
dd2c d0 07       BNE LFFS_38       ; branch always

dd2e          LFFS_30
dd2e 66 60       ROR TMPPTC+1      ; set exponent negative flag (ror carry into sign)

dd30          LFFS_35
dd30 20 73 00    JSR CHRGET        ; next char of exponent

dd33          LFFS_37
dd33 90 5c       BCC LFFS_85       ; branch if numeric character

dd35          LFFS_38
dd35 24 60       BIT TMPPTC+1      ; test exponent negative flag
dd37 10 0e       BPL LFFS_45       ; if positive go evaluate exponent
dd39 a9 00       LDA #0
dd3b 38          SEC
dd3c e5 5e       SBC TMPVA2        ; negate exponent
dd3e 4c 49 dd    JMP LFFS_50       ; go evaluate exponent

dd41          LFFS_40
dd41 66 5f       ROR TMPPTC        ; set decimal point flag
dd43 24 5f       BIT TMPPTC        ; test decimal point flag
dd45 50 c3       BVC LFFS_15       ; branch if only one decimal point so far

dd47          LFFS_45
dd47 a5 5e       LDA TMPVA2        ; get exponent count byte

dd49          LFFS_50
dd49 38          SEC
dd4a e5 5d       SBC TMPVA1        ; subtract numerator exponent
dd4c 85 5e       STA TMPVA2        ; save exponent count byte
dd4e f0 12       BEQ LFFS_65       ; branch if no adjustment
dd50 10 09       BPL LFFS_60       ; else if positive go do FAC1*10^expcnt

dd52          LFFS_55
dd52 20 fe da    JSR Divide_FAC1_By_10
dd55 e6 5e       INC TMPVA2        ; increment exponent count byte
dd57 d0 f9       BNE LFFS_55       ; loop until all done
dd59 f0 07       BEQ LFFS_65       ; branch always

dd5b          LFFS_60
dd5b 20 e2 da    JSR Multiply_FAC1_BY_10
dd5e c6 5e       DEC TMPVA2        ; decrement exponent count byte
dd60 d0 f9       BNE LFFS_60       ; loop until all done

dd62          LFFS_65
dd62 a5 67       LDA SGNFLG        ; get negative flag
dd64 30 01       BMI LFFS_70       ; if negative do - FAC1 and return
dd66 60          RTS ;Size  116 [Load_FAC1_From_String]

dd67          LFFS_70
dd67 4c b4 df    JMP Basic_GREATER ; do - FAC1

dd6a          LFFS_75
dd6a 48          PHA               ; save character
dd6b 24 5f       BIT TMPPTC        ; test decimal point flag
dd6d 10 02       BPL LFFS_80       ; skip exponent increment if not set
dd6f e6 5d       INC TMPVA1        ; else increment number exponent

dd71          LFFS_80
dd71 20 e2 da    JSR Multiply_FAC1_BY_10
dd74 68          PLA               ; restore character
dd75 38          SEC
dd76 e9 30       SBC #'0'          ; convert to binary
dd78 20 7e dd    JSR Add_A_To_FAC1
dd7b 4c 0a dd    JMP LFFS_15      ; go do next character

              ; *************
dd7e            Add_A_To_FAC1
              ; *************

dd7e 48          PHA               ; save digit
dd7f 20 0c dc    JSR FAC1_Round_And_Copy_To_FAC2
dd82 68          PLA               ; restore digit
dd83 20 3c dc    JSR A_To_FAC1
dd86 a5 6e       LDA FAC2SI        ; get FAC2 sign (b7)
dd88 45 66       EOR FAC1SI        ; toggle with FAC1 sign (b7)
dd8a 85 6f       STA STRPTR        ; save sign compare (FAC1 EOR FAC2)
dd8c a6 61       LDX FAC1EX        ; get FAC1 exponent
dd8e 4c 6a d8    JMP Basic_PLUS    ; add FAC2 to FAC1 and return

              ; evaluate next character of exponential part of number

dd91          LFFS_85
dd91 a5 5e       LDA TMPVA2        ; get exponent count byte
dd93 c9 0a       CMP #10           ; compare with 10 decimal
dd95 90 09       BCC LFFS_90       ; branch if less
dd97 a9 64       LDA #$64          ; make all negative exponents = -100 decimal (causes underflow)
dd99 24 60       BIT TMPPTC+1      ; test exponent negative flag
dd9b 30 11       BMI LFFS_95       ; branch if negative
dd9d 4c 7e d9    JMP Overflow_Error

dda0          LFFS_90
dda0 0a          ASL A             ; *2
dda1 0a          ASL A             ; *4
dda2 18          CLC
dda3 65 5e       ADC TMPVA2        ; *5
dda5 0a          ASL A             ; *10
dda6 18          CLC
dda7 a0 00       LDY #0
dda9 71 7a       ADC (TXTPTR),Y    ; add character (will be $30 too much!)
ddab 38          SEC
ddac e9 30       SBC #'0'          ; convert character to binary

ddae          LFFS_95
ddae 85 5e       STA TMPVA2        ; save exponent count byte
ddb0 4c 30 dd    JMP LFFS_35       ; go get next character

ddb3 9b 3e bc MAXREAL_A .real   99999999.90625
ddb8 9e 6e 6b MAXREAL_B .real  999999999.25
ddbd 9e 6e 6b MAXREAL_C .real 1000000000

              ; ********
ddc2            Print_IN
              ; ********

                 LAYI(Msg_IN)
ddc2 a9 71       LDA #<Msg_IN
ddc4 a0 c3       LDY #>Msg_IN

ddc6 20 da dd    JSR To_Print_String
ddc9 a5 3a       LDA CURLIN+1      ; get the current line number high byte
ddcb a6 39       LDX CURLIN        ; get the current line number low byte

              ; ****************
ddcd            Print_Integer_XA
              ; ****************

ddcd 85 62       STA FAC1M1        ; save high byte as FAC1 mantissa1
ddcf 86 63       STX FAC1M2        ; save low byte as FAC1 mantissa2
ddd1 a2 90       LDX #$90          ; set exponent to 16d bits
ddd3 38          SEC               ; set integer is positive flag
ddd4 20 49 dc    JSR Convert_Integer_To_Float
ddd7 20 df dd    JSR Format_FAC1_Y

ddda          To_Print_String
ddda 4c 1e cb    JMP Print_String

              ; ***********
dddd            Format_FAC1
              ; ***********

dddd a0 01       LDY #1
              ; -------------
dddf            Format_FAC1_Y
              ; -------------

dddf a9 20       LDA #' '          ; character = " " (assume positive)
dde1 24 66       BIT FAC1SI        ; test FAC1 sign (b7)
dde3 10 02       BPL FoFA_02       ; if positive skip the - sign set
dde5 a9 2d       LDA #'-'          ; else character = "-"

dde7          FoFA_02
dde7 99 ff 00    STA BASSTO,Y      ; save leading character (" " or "-")
ddea 85 66       STA FAC1SI        ; save FAC1 sign (b7)
ddec 84 71       STY TMPPTD        ; save the index
ddee c8          INY
ddef a9 30       LDA #'0'          ; set character = "0"
ddf1 a6 61       LDX FAC1EX        ; get FAC1 exponent
ddf3 d0 03       BNE FoFA_04       ; if FAC1 not zero format it
ddf5 4c 04 df    JMP FoFA_52       ; just 0 

ddf8          FoFA_04
ddf8 a9 00       LDA #$00          ; clear (number exponent count)
ddfa e0 80       CPX #$80          ; compare FAC1 exponent with $80 (<1.00000)
ddfc f0 02       BEQ FoFA_06       ; branch if 0.5 <= FAC1 < 1.0
ddfe b0 09       BCS FoFA_08       ; branch if FAC1=>1

de00          FoFA_06
                 LAYI(MAXREAL_C)   ; set 1000000000 pointer
de00 a9 bd       LDA #<MAXREAL_C
de02 a0 dd       LDY #>MAXREAL_C

de04 20 28 da    JSR Multiply_FAC1_With_AY
de07 a9 f7       LDA #$F7          ; set number exponent count

de09          FoFA_08
de09 85 5d       STA TMPVA1        ; save number exponent count

de0b          FoFA_10
                 LAYI(MAXREAL_B)   ; set 999999999.25 pointer (max before sci note)
de0b a9 b8       LDA #<MAXREAL_B
de0d a0 dd       LDY #>MAXREAL_B

de0f 20 5b dc    JSR Compare_FAC1_AY
de12 f0 1e       BEQ FoFA_20       ; exit if FAC1 = (AY)
de14 10 12       BPL FoFA_16       ; go do /10 if FAC1 > (AY)

de16          FoFA_12
                 LAYI(MAXREAL_A)   ; set 99999999.90625 pointer
de16 a9 b3       LDA #<MAXREAL_A
de18 a0 dd       LDY #>MAXREAL_A

de1a 20 5b dc    JSR Compare_FAC1_AY
de1d f0 02       BEQ FoFA_14       ; branch if FAC1 = (AY) (allow decimal places)
de1f 10 0e       BPL FoFA_18       ; branch if FAC1 > (AY) (no decimal places)

de21          FoFA_14
de21 20 e2 da    JSR Multiply_FAC1_BY_10
de24 c6 5d       DEC TMPVA1        ; decrement number exponent count
de26 d0 ee       BNE FoFA_12       ; go test again, branch always

de28          FoFA_16
de28 20 fe da    JSR Divide_FAC1_By_10
de2b e6 5d       INC TMPVA1        ; increment number exponent count
de2d d0 dc       BNE FoFA_10       ; go test again, branch always

de2f          FoFA_18
de2f 20 49 d8    JSR Add_0_5_To_FAC1

de32          FoFA_20
de32 20 9b dc    JSR FAC1_To_Integer
de35 a2 01       LDX #$01          ; set default digits before dp = 1
de37 a5 5d       LDA TMPVA1        ; get number exponent count
de39 18          CLC
de3a 69 0a       ADC #$0A          ; up to 9 digits before point
de3c 30 09       BMI FoFA_22       ; if negative then 1 digit before dp
de3e c9 0b       CMP #$0B          ; A>=$0B if n>=1E9
de40 b0 06       BCS FoFA_24       ; branch if >= $0B
de42 69 ff       ADC #$FF          ; take 1 from digit count
de44 aa          TAX               ; copy to X
de45 a9 02       LDA #$02          ; set the exponent adjust

de47          FoFA_22
de47 38          SEC

de48          FoFA_24
de48 e9 02       SBC #$02          ; -2
de4a 85 5e       STA TMPVA2        ; save the exponent adjust
de4c 86 5d       STX TMPVA1        ; save digits before dp count
de4e 8a          TXA               ; copy digits before dp count to A
de4f f0 02       BEQ FoFA_26       ; if no digits before the dp go do the "."
de51 10 13       BPL FoFA_30       ; if there are digits before the dp go do them

de53          FoFA_26
de53 a4 71       LDY TMPPTD        ; get the output string index
de55 a9 2e       LDA #'.'          ; character "."
de57 c8          INY               ; increment the index
de58 99 ff 00    STA STACK-1,Y     ; save the "." to the output string
de5b 8a          TXA               ; copy digits before dp count to A
de5c f0 06       BEQ FoFA_28       ; if no digits before the dp skip the "0"
de5e a9 30       LDA #'0'          ; character "0"
de60 c8          INY
de61 99 ff 00    STA STACK-1,Y     ; save the "0" to the output string

de64          FoFA_28
de64 84 71       STY TMPPTD        ; save the output string index

de66          FoFA_30
de66 a0 00       LDY #0            ; clear the powers of 10 index (point to -100,000,000)

              ; -----------------
de68            Format_Jiffyclock
              ; -----------------

de68 a2 80       LDX #$80          ; clear the digit, set the test sense
de6a          FoFA_32
de6a a5 65       LDA FAC1M4        ; get FAC1 mantissa 4
de6c 18          CLC
de6d 79 19 df    ADC Decimal_Conversion_Table+3,Y
de70 85 65       STA FAC1M4        ; save FAC1 mantissa4
de72 a5 64       LDA FAC1M3        ; get FAC1 mantissa 3
de74 79 18 df    ADC Decimal_Conversion_Table+2,Y
de77 85 64       STA FAC1M3        ; save FAC1 mantissa3
de79 a5 63       LDA FAC1M2        ; get FAC1 mantissa 2
de7b 79 17 df    ADC Decimal_Conversion_Table+1,Y
de7e 85 63       STA FAC1M2        ; save FAC1 mantissa2
de80 a5 62       LDA FAC1M1        ; get FAC1 mantissa 1
de82 79 16 df    ADC Decimal_Conversion_Table+0,Y
de85 85 62       STA FAC1M1        ; save FAC1 mantissa1
de87 e8          INX               ; increment the digit, set the sign on the test sense bit
de88 b0 04       BCS FoFA_34       ; if the carry is set go test if the result was positive
de8a 10 de       BPL FoFA_32       ; not negative so try again
de8c 30 02       BMI FoFA_36       ; else done so return the digit

de8e          FoFA_34
de8e 30 da       BMI FoFA_32       ; not positive so try again

de90          FoFA_36
de90 8a          TXA               ; copy the digit
de91 90 04       BCC FoFA_38       ; if Cb=0 just use it
de93 49 ff       EOR #$FF          ; else make the 2's complement ..
de95 69 0a       ADC #$0A          ; .. and subtract it from 10

de97          FoFA_38
de97 69 2f       ADC #'0'-1        ; add "0"-1 to result
de99 c8          INY               ; increment ..
de9a c8          INY               ; .. index to..
de9b c8          INY               ; .. next less ..
de9c c8          INY               ; .. power of ten
de9d 84 47       STY VARPNT        ; save the powers of ten table index
de9f a4 71       LDY TMPPTD        ; get output string index
dea1 c8          INY               ; increment output string index
dea2 aa          TAX               ; copy character to X
dea3 29 7f       AND #$7F          ; mask out top bit
dea5 99 ff 00    STA STACK-1,Y     ; save to output string
dea8 c6 5d       DEC TMPVA1        ; decrement # of characters before the dp
deaa d0 06       BNE FoFA_40       ; if still characters to do skip the decimal point
deac a9 2e       LDA #'.'          ; character "."
deae c8          INY               ; increment output string index
deaf 99 ff 00    STA STACK-1,Y     ; save to output string

deb2          FoFA_40
deb2 84 71       STY TMPPTD        ; save the output string index
deb4 a4 47       LDY VARPNT        ; get the powers of ten table index
deb6 8a          TXA               ; get the character back
deb7 49 ff       EOR #$FF          ; toggle the test sense bit
deb9 29 80       AND #$80          ; clear the digit
debb aa          TAX               ; copy it to the new digit
debc c0 24       CPY #Jiffy_Conversion_Table-Decimal_Conversion_Table         
debe f0 04       BEQ FoFA_42       ; if at the max exit the digit loop
dec0 c0 3c       CPY #End_Of_Conversion-Decimal_Conversion_Table
dec2 d0 a6       BNE FoFA_32       ; loop if not at the max

dec4          FoFA_42
dec4 a4 71       LDY TMPPTD        ; restore the output string index
dec6          FoFA_44
dec6 b9 ff 00    LDA STACK-1,Y     ; get character from output string
dec9 88          DEY               ; decrement output string index
deca c9 30       CMP #'0'          ; compare with "0"
decc f0 f8       BEQ FoFA_44       ; loop until non "0" character found
dece c9 2e       CMP #'.'          ; compare with "."
ded0 f0 01       BEQ FoFA_46       ; branch if was dp
ded2 c8          INY               ; increment output string index

ded3          FoFA_46
ded3 a9 2b       LDA #'+'          ; character "+"
ded5 a6 5e       LDX TMPVA2        ; get exponent count
ded7 f0 2e       BEQ FoFA_54       ; if zero go set null terminator and exit
ded9 10 08       BPL FoFA_48       ; branch if exponent count positive
dedb a9 00       LDA #0
dedd 38          SEC
dede e5 5e       SBC TMPVA2        ; subtract exponent count adjust (convert negative to positive)
dee0 aa          TAX               ; copy exponent count to X
dee1 a9 2d       LDA #'-'          ; character "-"

dee3          FoFA_48
dee3 99 01 01    STA STACK+1,Y     ; save to output string
dee6 a9 45       LDA #'E'          ; character "E"
dee8 99 00 01    STA STACK,Y       ; save exponent sign to output string
deeb 8a          TXA               ; get exponent count back
deec a2 2f       LDX #$2F          ; one less than "0" character
deee 38          SEC

deef          FoFA_50
deef e8          INX               ; increment 10's character
def0 e9 0a       SBC #$0A          ; subtract 10 from exponent count
def2 b0 fb       BCS FoFA_50       ; loop while still >= 0
def4 69 3a       ADC #':'          ; add character ":" ($30+$0A, result is 10 less that value)
def6 99 03 01    STA STACK+3,Y     ; save to output string
def9 8a          TXA               ; copy 10's character
defa 99 02 01    STA STACK+2,Y     ; save to output string
defd a9 00       LDA #$00          ; set null terminator
deff 99 04 01    STA STACK+4,Y     ; save to output string
df02 f0 08       BEQ FoFA_56       ; go set string pointer (AY) and exit, branch always

df04          FoFA_52
df04 99 ff 00    STA STACK-1,Y     ; save last character to output string

df07          FoFA_54
df07 a9 00       LDA #$00          ; set null terminator
df09 99 00 01    STA STACK,Y       ; save after last character

df0c          FoFA_56
                 LAYI(STACK)
df0c a9 00       LDA #<STACK
df0e a0 01       LDY #>STACK

df10 60          RTS ;Size  308 [Format_FAC1]

df11 80 00    Float_0_5       .byte $80,$00 ; 0.5 (including next 3 bytes)
df13 00 00 00 NULL_Descriptor .byte 0,0,0 ; null descriptor for undefined variables

              ; ========================
df16            Decimal_Conversion_Table
              ; ========================

df16 fa 0a 1f    .quad -100000000
df1a 00 98 96    .quad  +10000000
df1e ff f0 bd    .quad   -1000000
df22 00 01 86    .quad    +100000
df26 ff ff d8    .quad     -10000
df2a 00 00 03    .quad      +1000
df2e ff ff ff    .quad       -100
df32 00 00 00    .quad        +10
df36 ff ff ff    .quad         -1

              ; ======================
df3a            Jiffy_Conversion_Table
              ; ======================

df3a ff df 0a    .quad -2160000 ; 10s hours
df3e 00 03 4b    .quad  +216000 ;     hours
df42 ff ff 73    .quad   -36000 ; 10s mins
df46 00 00 0e    .quad    +3600 ;     mins
df4a ff ff fd    .quad     -600 ; 10s secs
df4e 00 00 00    .quad      +60 ;     secs

df52          End_Of_Conversion

0001 FALSE    #if C64
SKIP             .byte $EC
              #endif
0000 TRUE     #if VIC
df52 bf          .byte $BF
              #endif

df53 aa aa aa    .fill 30 ($AA) ; 30 bytes

              ; *********
df71            Basic_SQR
              ; *********

df71 20 0c dc    JSR FAC1_Round_And_Copy_To_FAC2
                 LAYI(Float_0_5)
df74 a9 11       LDA #<Float_0_5
df76 a0 df       LDY #>Float_0_5

df78 20 a2 db    JSR Load_FAC1_AY

              ; ***********
df7b            Basic_POWER
              ; ***********

df7b f0 70       BEQ Basic_EXP     ; perform EXP()
df7d a5 69       LDA FAC2EX        ; get FAC2 exponent
df7f d0 03       BNE POW_10        ; branch if FAC2<>0
df81 4c f9 d8    JMP PLUS_40       ; clear FAC1 exponent and sign and return

df84          POW_10
df84 a2 4e       LDX #<FUNCPT      ; set destination pointer low byte
df86 a0 00       LDY #>FUNCPT      ; set destination pointer high byte
df88 20 d4 db    JSR Assign_FAC1_To_Var
df8b a5 6e       LDA FAC2SI        ; get FAC2 sign (b7)
df8d 10 0f       BPL POW_20        ; branch if FAC2>0
df8f 20 cc dc    JSR Basic_INT     ; perform INT()
                 LAYI(FUNCPT)      ; set source pointer
df92 a9 4e       LDA #<FUNCPT
df94 a0 00       LDY #>FUNCPT

df96 20 5b dc    JSR Compare_FAC1_AY
df99 d0 03       BNE POW_20        ; branch if FAC1 <> (AY) to allow Function Call error
df9b 98          TYA               ; clear sign b7
df9c a4 07       LDY CHARAC        ; get FAC1 mantissa 4 from INT() function as sign in
                                   ; Y for possible later negation, b0 only needed
df9e          POW_20
df9e 20 fe db    JSR Copy_ABS_FAC2_To_FAC1
dfa1 98          TYA               ; copy sign back ..
dfa2 48          PHA               ; .. and save it
dfa3 20 ea d9    JSR Basic_LOG     ; perform LOG()
                 LAYI(FUNCPT)
dfa6 a9 4e       LDA #<FUNCPT
dfa8 a0 00       LDY #>FUNCPT

dfaa 20 28 da    JSR Multiply_FAC1_With_AY
dfad 20 ed df    JSR Basic_EXP     ; perform EXP()
dfb0 68          PLA               ; pull sign from stack
dfb1 4a          LSR A             ; b0 is to be tested
dfb2 90 0a       BCC GREA_Ret      ; if no bit then exit

              ; *************
dfb4            Basic_GREATER
              ; *************

dfb4 a5 61       LDA FAC1EX        ; get FAC1 exponent
dfb6 f0 06       BEQ GREA_Ret      ; exit if FAC1_e = $00
dfb8 a5 66       LDA FAC1SI        ; get FAC1 sign (b7)
dfba 49 ff       EOR #$FF          ; complement it
dfbc 85 66       STA FAC1SI        ; save FAC1 sign (b7)

dfbe          GREA_Ret
dfbe 60          RTS ;Size   11 [Basic_GREATER]

dfbf 81 38 aa REV_LOG_2 .real 1.4426950408

dfc4          VAR_EXP
dfc4 07          .byte   7         ; series count

dfc5 71 34 58    .real  2.1498763705E-5
dfca 74 16 7e    .real  1.4352314041E-4
dfcf 77 2f ee    .real  1.3422634825E-3
dfd4 7a 1d 84    .real  9.6140170140E-3
dfd9 7c 63 59    .real  5.5505126870E-2
dfde 7e 75 fd    .real  2.4022638465E-1
dfe3 80 31 72    .real  6.9314718640E-1
dfe8 81 00 00    .real  1.0

              ; *********
dfed            Basic_EXP
              ; *********

                 LAYI(REV_LOG_2)   ; point to 1.0/ln(2.0) = 1.443
dfed a9 bf       LDA #<REV_LOG_2
dfef a0 df       LDY #>REV_LOG_2

dff1 20 28 da    JSR Multiply_FAC1_With_AY
dff4 a5 70       LDA FAC1M5        ; get FAC1 rounding byte
dff6 69 50       ADC #$50          ; +$50/$100
dff8 90 03       BCC EXP_10        ; skip rounding if no carry
dffa 20 23 dc    JSR Round_FAC1

dffd          EXP_10

0001 FALSE    #if C64
SKIP             JMP C64_Kernal_ROM
SKIP             .org  $E000
SKIP          C64_Kernal_ROM
              #endif

0001 FALSE    #if C64
SKIP             .store  *,$2000,"kernal_64.rom"
              #endif
0000 TRUE     #if VIC
                 .store  $e000,$2000,"kernal_20.rom"
              #endif

dffd 85 56       STA FAC2M5        ; save FAC2 rounding byte
dfff 20 0f dc    JSR FAC1_To_FAC2
e002 a5 61       LDA FAC1EX        ; get FAC1 exponent
e004 c9 88       CMP #$88          ; compare with EXP limit (256d)
e006 90 03       BCC EXP_30        ; branch if less

e008          EXP_20
e008 20 d4 da    JSR Check_Overflow

e00b          EXP_30
e00b 20 cc dc    JSR Basic_INT     ; perform INT()
e00e a5 07       LDA CHARAC        ; get mantissa 4 from INT()
e010 18          CLC
e011 69 81       ADC #$81          ; normalise +1
e013 f0 f3       BEQ EXP_20        ; if $00 result has overflowed so go handle it
e015 38          SEC
e016 e9 01       SBC #$01          ; exponent now correct
e018 48          PHA               ; save FAC2 exponent
e019 a2 05       LDX #$05          ; 4 bytes to do

e01b          EXP_40
e01b b5 69       LDA FAC2EX,X      ; get FAC2,X
e01d b4 61       LDY FAC1EX,X      ; get FAC1,X
e01f 95 61       STA FAC1EX,X      ; save FAC1,X
e021 94 69       STY FAC2EX,X      ; save FAC2,X
e023 ca          DEX               ; decrement count/index
e024 10 f5       BPL EXP_40        ; loop if not all done
e026 a5 56       LDA FAC2M5        ; get FAC2 rounding byte
e028 85 70       STA FAC1M5        ; save as FAC1 rounding byte
e02a 20 53 d8    JSR Basic_MINUS   ; perform subtraction, FAC2 from FAC1
e02d 20 b4 df    JSR Basic_GREATER ; do - FAC1
                 LAYI(VAR_EXP)     ; set counter pointer
e030 a9 c4       LDA #<VAR_EXP
e032 a0 df       LDY #>VAR_EXP

e034 20 56 e0    JSR Eval_Series_AY
e037 a9 00       LDA #0
e039 85 6f       STA STRPTR        ; clear sign compare (FAC1 EOR FAC2)
e03b 68          PLA               ; pull the saved FAC2 exponent
e03c 20 b9 da    JSR Check_FACs_A
e03f 60          RTS ;Size   83 [Basic_EXP]

              ; **********************
e040            Square_And_Series_Eval
              ; **********************

                 STAY(TMPPTD)
e040 85 71       STA TMPPTD
e042 84 72       STY TMPPTD+1

e044 20 ca db    JSR FAC1_To_FACTPA
e047 a9 57       LDA #<FACTPA      ; set pointer low byte (Y already $00)
e049 20 28 da    JSR Multiply_FAC1_With_AY
e04c 20 5a e0    JSR Eval_Series
                 LAYI(FACTPA)      ; pointer to original
e04f a9 57       LDA #<FACTPA
e051 a0 00       LDY #>FACTPA

e053 4c 28 da    JMP Multiply_FAC1_With_AY

              ; **************
e056            Eval_Series_AY
              ; **************

                 STAY(TMPPTD)
e056 85 71       STA TMPPTD
e058 84 72       STY TMPPTD+1


              ; -----------
e05a            Eval_Series
              ; -----------

e05a 20 c7 db    JSR FAC1_To_FACTPB
e05d b1 71       LDA (TMPPTD),Y    ; get constants count
e05f 85 67       STA SGNFLG        ; save constants count
e061 a4 71       LDY TMPPTD        ; get count pointer low byte
e063 c8          INY               ; increment it (now constants pointer)
e064 98          TYA               ; copy it
e065 d0 02       BNE EvSe_10       ; skip next if no overflow
e067 e6 72       INC TMPPTD+1      ; else increment high byte

e069          EvSe_10
e069 85 71       STA TMPPTD        ; save low byte
e06b a4 72       LDY TMPPTD+1      ; get high byte

e06d          EvSe_20
e06d 20 28 da    JSR Multiply_FAC1_With_AY
                 LDAY(TMPPTD)
e070 a5 71       LDA TMPPTD
e072 a4 72       LDY TMPPTD+1

e074 18          CLC
e075 69 05       ADC #$05          ; +5 to low pointer (5 bytes per constant)
e077 90 01       BCC EvSe_30       ; skip next if no overflow
e079 c8          INY               ; increment high byte

e07a          EvSe_30
                 STAY(TMPPTD)
e07a 85 71       STA TMPPTD
e07c 84 72       STY TMPPTD+1

e07e 20 67 d8    JSR Add_Var_AY_To_FAC1
                 LAYI(FACTPB)      ; set pointer to partial
e081 a9 5c       LDA #<FACTPB
e083 a0 00       LDY #>FACTPB

e085 c6 67       DEC SGNFLG        ; decrement constants count
e087 d0 e4       BNE EvSe_20       ; loop until all done
e089 60          RTS ;Size   52 [Eval_Series_AY]

e08a 98 35 44 RND_VA .real 11879546 
e08f 68 28 b1 RND_VB .real 3.927677739E-8

              ; *********
e094            Basic_RND
              ; *********

e094 20 2b dc    JSR Get_FAC1_Sign
e097 30 37       BMI RND_20        ; if      n<0 copy byte swapped FAC1 into RND() seed
e099 d0 20       BNE RND_10        ; else if n>0 get next number in RND() sequence
e09b 20 f3 ff    JSR IOBASE        ; else    n=0 so get the RND() from VIA 1 timers
                 STXY(INDEXA)      ; save pointer low byte
e09e 86 22       STX INDEXA
e0a0 84 23       STY INDEXA+1

e0a2 a0 04       LDY #$04          ; set index to T1 low byte
e0a4 b1 22       LDA (INDEXA),Y    ; get T1 low byte
e0a6 85 62       STA FAC1M1        ; save FAC1 mantissa 1
e0a8 c8          INY
e0a9 b1 22       LDA (INDEXA),Y    ; get T1 high byte
e0ab 85 64       STA FAC1M3        ; save FAC1 mantissa 3
e0ad a0 08       LDY #$08          ; set index to T2 low byte
e0af b1 22       LDA (INDEXA),Y    ; get T2 low byte
e0b1 85 63       STA FAC1M2        ; save FAC1 mantissa 2
e0b3 c8          INY
e0b4 b1 22       LDA (INDEXA),Y    ; get T2 high byte
e0b6 85 65       STA FAC1M4        ; save FAC1 mantissa 4
e0b8 4c e0 e0    JMP RND_30        ; set exponent and exit

e0bb          RND_10
                 LAYI(RNDX)        ; set seed pointer
e0bb a9 8b       LDA #<RNDX
e0bd a0 00       LDY #>RNDX

e0bf 20 a2 db    JSR Load_FAC1_AY
                 LAYI(RND_VA)      ; set 11879546 pointer
e0c2 a9 8a       LDA #<RND_VA
e0c4 a0 e0       LDY #>RND_VA

e0c6 20 28 da    JSR Multiply_FAC1_With_AY
                 LAYI(RND_VB)      ; set 3.927677739E-8 pointer
e0c9 a9 8f       LDA #<RND_VB
e0cb a0 e0       LDY #>RND_VB

e0cd 20 67 d8    JSR Add_Var_AY_To_FAC1

e0d0          RND_20
e0d0 a6 65       LDX FAC1M4        ; get FAC1 mantissa 4
e0d2 a5 62       LDA FAC1M1        ; get FAC1 mantissa 1
e0d4 85 65       STA FAC1M4        ; save FAC1 mantissa 4
e0d6 86 62       STX FAC1M1        ; save FAC1 mantissa 1
e0d8 a6 63       LDX FAC1M2        ; get FAC1 mantissa 2
e0da a5 64       LDA FAC1M3        ; get FAC1 mantissa 3
e0dc 85 63       STA FAC1M2        ; save FAC1 mantissa 2
e0de 86 64       STX FAC1M3        ; save FAC1 mantissa 3

e0e0          RND_30
e0e0 a9 00       LDA #0
e0e2 85 66       STA FAC1SI        ; clear FAC1 sign (always positive)
e0e4 a5 61       LDA FAC1EX        ; get FAC1 exponent
e0e6 85 70       STA FAC1M5        ; save FAC1 rounding byte
e0e8 a9 80       LDA #$80          ; set exponent = $80
e0ea 85 61       STA FAC1EX        ; save FAC1 exponent
e0ec 20 d7 d8    JSR Normalise_FAC1
e0ef a2 8b       LDX #<RNDX        ; set seed pointer low address
e0f1 a0 00       LDY #>RNDX        ; set seed pointer high address

              ; --------------------
e0f3            Go_Assign_FAC1_To_Var
              ; --------------------

e0f3 4c d4 db    JMP Assign_FAC1_To_Var

              ; =============
e0f6            Error_Handler
              ; =============

e0f6 c9 f0       CMP #$F0          ; compare error with $F0
e0f8 d0 07       BNE ErHa_10       ; branch if not $F0
e0fa 84 38       STY MEMSIZ+1      ; set end of memory high byte
e0fc 86 37       STX MEMSIZ        ; set end of memory low byte
e0fe 4c 63 c6    JMP Reset_Variable_Pointer

e101          ErHa_10
e101 aa          TAX               ; copy error #
e102 d0 02       BNE ErHa_20       ; branch if not $00
e104 a2 1e       LDX #$1E          ; else error $1E, break error

e106          ErHa_20
e106 4c 37 c4    JMP Basic_Error

              ; **************
e109            CHROUT_Checked
              ; **************

e109 20 d2 ff    JSR CHROUT        ; Output a character
e10c b0 e8       BCS Error_Handler
e10e 60          RTS ;Size    6 [CHROUT_Checked]

              ; *********
e10f            Read_Char
              ; *********

e10f 20 cf ff    JSR CHRIN
e112 b0 e2       BCS Error_Handler
e114 60          RTS ;Size    6 [Read_Char]

              ; *********************
e115            Select_Output_Channel
              ; *********************

0001 FALSE    #if C64
SKIP             JSR CHKOUT_Checked
              #endif

0000 TRUE     #if VIC
e115 20 c9 ff    JSR CHKOUT        ; open channel for output
              #endif

e118 b0 dc       BCS Error_Handler
e11a 60          RTS ;Size    6 [Select_Output_Channel]

              ; *************
e11b            CHKIN_Checked
              ; *************

e11b 20 c6 ff    JSR CHKIN         ; open channel for input
e11e b0 d6       BCS Error_Handler
e120 60          RTS ;Size    6 [CHKIN_Checked]

              ; *************
e121            GETIN_Checked
              ; *************

e121 20 e4 ff    JSR GETIN         ; get character from input device
e124 b0 d0       BCS Error_Handler
e126 60          RTS ;Size    6 [GETIN_Checked]

              ; *********
e127            Basic_SYS
              ; *********

e127 20 8a cd    JSR Eval_Numeric
e12a 20 f7 d7    JSR FAC1_To_LINNUM
e12d a9 e1       LDA #>[SYS_Ret-1] ; get return address high byte
e12f 48          PHA               ; push as return address
e130 a9 43       LDA #<[SYS_Ret-1] ; get return address low byte
e132 48          PHA               ; push as return address
e133 ad 0f 03    LDA SPREG         ; get saved status register
e136 48          PHA               ; put on stack
e137 ad 0c 03    LDA SAREG         ; get saved A
e13a ae 0d 03    LDX SXREG         ; get saved X
e13d ac 0e 03    LDY SYREG         ; get saved Y
e140 28          PLP               ; pull processor status
e141 6c 14 00    JMP (LINNUM)      ; call SYS address

              ; -------
e144            SYS_Ret
              ; -------

              ; the SYS_Ret is needed because the following code is to be executed once the user code
              ; returns. this is done by pushing the target return address - 1 onto the stack

e144 08          PHP               ; save status
e145 8d 0c 03    STA SAREG         ; save returned A
e148 8e 0d 03    STX SXREG         ; save returned X
e14b 8c 0e 03    STY SYREG         ; save returned Y
e14e 68          PLA               ; restore saved status
e14f 8d 0f 03    STA SPREG         ; save status
e152 60          RTS ;Size   44 [Basic_SYS]

              ; **********
e153            Basic_SAVE
              ; **********

e153 20 d1 e1    JSR Get_Load_Save_Params

e156          Jiffy_SAVE
                 LDXY(VARTAB)      ; get start of variables
e156 a6 2d       LDX VARTAB
e158 a4 2e       LDY VARTAB+1

e15a a9 2b       LDA #TXTTAB       ; index to start of program memory
e15c 20 d8 ff    JSR SAVE          ; save RAM to device, A = index to start address, XY = end
e15f b0 95       BCS Error_Handler
e161 60          RTS ;Size   15 [Basic_SAVE]

              ; ************
e162            Basic_VERIFY
              ; ************

e162 a9 01       LDA #1            ; flag verify
e164 2c          .byte   $2C       ; skip next statement

              ; **********
e165            Basic_LOAD
              ; **********

e165 a9 00       LDA #0            ; flag load
e167 85 0a       STA VERCK         ; set load/verify flag
e169 20 d1 e1    JSR Get_Load_Save_Params
e16c a5 0a       LDA VERCK         ; get load/verify flag
                 LDXY(TXTTAB)      ; get start of memory
e16e a6 2b       LDX TXTTAB
e170 a4 2c       LDY TXTTAB+1

e172 20 d5 ff    JSR LOAD          ; load RAM from a device
e175 b0 57       BCS Jump_Error_Handler
e177 a5 0a       LDA VERCK         ; get load/verify flag
e179 f0 1a       BEQ LOAD_30       ; branch if load

e17b          LOAD_05
e17b a2 1c       LDX #$1C          ; error $1C, verify error
e17d 20 b7 ff    JSR READST        ; read I/O status word
e180 29 10       AND #$10          ; mask for tape read error

0001 FALSE    #if C64
SKIP             BNE LOAD_40       ; branch if read error
              #endif
0000 TRUE     #if VIC
e182 f0 03       BEQ LOAD_10       ; branch if no read error
e184 4c 37 c4    JMP Basic_Error
              #endif

e187          LOAD_10
e187 a5 7a       LDA TXTPTR        ; get BASIC execute pointer low byte
e189 c9 02       CMP #2            ; BUG! should be LDA TXTPTR+1:CMP #>BUF:BNE LOAD20
e18b f0 07       BEQ LOAD_20
                 LAYI(Msg_OK)
e18d a9 64       LDA #<Msg_OK
e18f a0 c3       LDY #>Msg_OK

e191 4c 1e cb    JMP Print_String

e194          LOAD_20
e194 60          RTS ;Size   48 [Basic_LOAD]

e195          LOAD_30
e195 20 b7 ff    JSR READST        ; read I/O status word
e198 29 bf       AND #$BF          ; mask x0xx xxxx, clear read error
e19a f0 05       BEQ LOAD_50       ; branch if no errors
e19c a2 1d       LDX #$1D          ; error $1D, load error

e19e          LOAD_40
e19e 4c 37 c4    JMP Basic_Error

e1a1          LOAD_50
e1a1 a5 7b       LDA TXTPTR+1      ; get BASIC execute pointer high byte
e1a3 c9 02       CMP #>BUF
e1a5 d0 0e       BNE LOAD_60       ; branch if not direct mode

e1a7          LOAD_55
                 STXY(VARTAB)
e1a7 86 2d       STX VARTAB
e1a9 84 2e       STY VARTAB+1

                 Print_Msg(Msg_Ready)
e1ab a9 76       LDA #<Msg_Ready
e1ad a0 c3       LDY #>Msg_Ready
e1af 20 1e cb    JSR Print_String

e1b2 4c 2a c5    JMP Reset_And_Rechain

e1b5          LOAD_60
e1b5 20 8e c6    JSR Reset_BASIC_Exec_Pointer

0001 FALSE    #if C64
SKIP             JSR Rechain
SKIP             JMP Restore_And_Flush_Stack      ; do RESTORE, clear stack and return
              #endif
0000 TRUE     #if VIC
e1b8 4c 76 e4    JMP Rebuild_andRestore      ; rebuild BASIC line chaining, do RESTORE and return
              #endif

              ; **********
e1bb            Basic_OPEN
              ; **********

e1bb 20 16 e2    JSR Get_Open_Close_Params
e1be 20 c0 ff    JSR OPEN          ; open a logical file
e1c1 b0 0b       BCS Jump_Error_Handler      ; branch if error

e1c3 60          RTS ;Size    9 [Basic_OPEN]

              ; ***********
e1c4            Basic_CLOSE
              ; ***********

e1c4 20 16 e2    JSR Get_Open_Close_Params
e1c7 a5 49       LDA FORPNT        ; get logical file number
e1c9 20 c3 ff    JSR CLOSE         ; close a specified logical file
e1cc 90 c6       BCC LOAD_20      ; exit if no error

e1ce          Jump_Error_Handler
e1ce 4c f6 e0    JMP Error_Handler

              ; ********************
e1d1            Get_Load_Save_Params
              ; ********************

e1d1 a9 00       LDA #$00          ; clear file name length
e1d3 20 bd ff    JSR SETNAM        ; clear filename
e1d6 a2 01       LDX #$01          ; set default device number, cassette
e1d8 a0 00       LDY #$00          ; set default command
0001 FALSE    #if JIFFY
SKIP             JSR Jiffy_SETLFS
              #else
e1da 20 ba ff    JSR SETLFS        ; set logical, first and second addresses
              #endif
e1dd 20 03 e2    JSR Exit_On_EOS
e1e0 20 54 e2    JSR Set_Filename
e1e3 20 03 e2    JSR Exit_On_EOS
e1e6 20 fd e1    JSR Get_Byte_Param
e1e9 a0 00       LDY #$00          ; clear command
e1eb 86 49       STX FORPNT        ; save device number
e1ed 20 ba ff    JSR SETLFS        ; set logical, first and second addresses
e1f0 20 03 e2    JSR Exit_On_EOS
e1f3 20 fd e1    JSR Get_Byte_Param
e1f6 8a          TXA               ; copy command to A
e1f7 a8          TAY               ; copy command to Y
e1f8 a6 49       LDX FORPNT        ; get device number back
e1fa 4c ba ff    JMP SETLFS        ; set logical, first and second addresses and return

              ; **************
e1fd            Get_Byte_Param
              ; **************

e1fd 20 0b e2    JSR Read_Comma_And_Byte
e200 4c 9e d7    JMP Get_Byte_Value

              ; ***********
e203            Exit_On_EOS
              ; ***********

e203 20 79 00    JSR CHRGOT
e206 d0 02       BNE EOE_Ret       ; branch if not [EOL] or ":"
e208 68          PLA               ; dump return address low byte
e209 68          PLA               ; dump return address high byte
e20a          EOE_Ret
e20a 60          RTS ;Size    8 [Exit_On_EOS]

              ; *******************
e20b            Read_Comma_And_Byte
              ; *******************

e20b 20 fd ce    JSR Need_Comma

              ; *********
e20e            Need_Byte
              ; *********

e20e 20 79 00    JSR CHRGOT
e211 d0 f7       BNE EOE_Ret      ; exit if following byte
e213 4c 08 cf    JMP Syntax_Error

              ; *********************
e216            Get_Open_Close_Params
              ; *********************

e216 a9 00       LDA #$00          ; clear file name length
e218 20 bd ff    JSR SETNAM        ; clear filename
e21b 20 0e e2    JSR Need_Byte
e21e 20 9e d7    JSR Get_Byte_Value
e221 86 49       STX FORPNT        ; save logical file number
e223 8a          TXA               ; copy logical file number to A
e224 a2 01       LDX #$01          ; set default device number, cassette

e226          GOCP_05
e226 a0 00       LDY #$00          ; set default command
e228 20 ba ff    JSR SETLFS        ; set logical, first and second addresses
e22b 20 03 e2    JSR Exit_On_EOS
e22e 20 fd e1    JSR Get_Byte_Param
e231 86 4a       STX FORPNT+1      ; save device number
e233 a0 00       LDY #$00          ; clear command
e235 a5 49       LDA FORPNT        ; get logical file number
e237 e0 03       CPX #$03          ; compare device number with screen
e239 90 01       BCC GOCP_10       ; branch if less than screen
e23b 88          DEY               ; else decrement command

e23c          GOCP_10
e23c 20 ba ff    JSR SETLFS        ; set logical, first and second addresses
e23f 20 03 e2    JSR Exit_On_EOS
e242 20 fd e1    JSR Get_Byte_Param
e245 8a          TXA               ; copy command to A
e246 a8          TAY               ; copy command to Y
e247 a6 4a       LDX FORPNT+1      ; get device number
e249 a5 49       LDA FORPNT        ; get logical file number
e24b 20 ba ff    JSR SETLFS        ; set logical, first and second addresses
e24e 20 03 e2    JSR Exit_On_EOS
e251 20 0b e2    JSR Read_Comma_And_Byte

              ; ************
e254            Set_Filename
              ; ************

e254 20 9e cd    JSR Eval_Expression

e257          Set_Filename_From_String
e257 20 a3 d6    JSR Eval_String
e25a a6 22       LDX INDEXA        ; get string pointer low byte
e25c a4 23       LDY INDEXA+1      ; get string pointer high byte
e25e 4c bd ff    JMP SETNAM        ; set filename and return

              ; *********
e261            Basic_COS
              ; *********

                 LAYI(PI_Half)    ; set pi/2 pointer
e261 a9 dd       LDA #<PI_Half
e263 a0 e2       LDY #>PI_Half

e265 20 67 d8    JSR Add_Var_AY_To_FAC1

              ; *********
e268            Basic_SIN
              ; *********

e268 20 0c dc    JSR FAC1_Round_And_Copy_To_FAC2
                 LAYI(Two_PI)
e26b a9 e2       LDA #<Two_PI
e26d a0 e2       LDY #>Two_PI

e26f a6 6e       LDX FAC2SI        ; get FAC2 sign (b7)
e271 20 07 db    JSR Divide_FAC2_By_AY
e274 20 0c dc    JSR FAC1_Round_And_Copy_To_FAC2
e277 20 cc dc    JSR Basic_INT
e27a a9 00       LDA #0
e27c 85 6f       STA STRPTR        ; clear sign compare (FAC1 EOR FAC2)
e27e 20 53 d8    JSR Basic_MINUS   ; perform subtraction, FAC2 from FAC1
                 LAYI(Float_0_25)
e281 a9 e7       LDA #<Float_0_25
e283 a0 e2       LDY #>Float_0_25

e285 20 50 d8    JSR AY_Minus_FAC1
e288 a5 66       LDA FAC1SI        ; get FAC1 sign (b7)
e28a 48          PHA               ; save FAC1 sign
e28b 10 0d       BPL SIN_10        ; branch if positive
e28d 20 49 d8    JSR Add_0_5_To_FAC1
e290 a5 66       LDA FAC1SI        ; get FAC1 sign (b7)
e292 30 09       BMI SIN_20        ; branch if negative
e294 a5 12       LDA TANSGN        ; get the comparison evaluation flag
e296 49 ff       EOR #$FF          ; toggle flag
e298 85 12       STA TANSGN        ; save the comparison evaluation flag

e29a          SIN_10
e29a 20 b4 df    JSR Basic_GREATER ; do - FAC1

e29d          SIN_20
                 LAYI(Float_0_25)  ; set 0.25 pointer
e29d a9 e7       LDA #<Float_0_25
e29f a0 e2       LDY #>Float_0_25

e2a1 20 67 d8    JSR Add_Var_AY_To_FAC1
e2a4 68          PLA               ; restore FAC1 sign
e2a5 10 03       BPL SIN_30        ; branch if was positive
e2a7 20 b4 df    JSR Basic_GREATER ; do - FAC1

e2aa          SIN_30
                 LAYI(VAR_SIN)     ; set pointer to counter
e2aa a9 ec       LDA #<VAR_SIN
e2ac a0 e2       LDY #>VAR_SIN

e2ae 4c 40 e0    JMP Square_And_Series_Eval

              ; *********
e2b1            Basic_TAN
              ; *********

e2b1 20 ca db    JSR FAC1_To_FACTPA
e2b4 a9 00       LDA #0
e2b6 85 12       STA TANSGN        ; clear the comparison evaluation flag
e2b8 20 68 e2    JSR Basic_SIN     ; perform SIN()
e2bb a2 4e       LDX #<FUNCPT      ; set sin(n) pointer low byte
e2bd a0 00       LDY #>FUNCPT      ; set sin(n) pointer high byte
e2bf 20 f3 e0    JSR Go_Assign_FAC1_To_Var
                 LAYI(FACTPA)      ; set n pointer
e2c2 a9 57       LDA #<FACTPA
e2c4 a0 00       LDY #>FACTPA

e2c6 20 a2 db    JSR Load_FAC1_AY
e2c9 a9 00       LDA #0
e2cb 85 66       STA FAC1SI        ; clear FAC1 sign (b7)
e2cd a5 12       LDA TANSGN        ; get the comparison evaluation flag
e2cf 20 d9 e2    JSR TAN_10
                 LAYI(FUNCPT)      ; set sin(n) pointer
e2d2 a9 4e       LDA #<FUNCPT
e2d4 a0 00       LDY #>FUNCPT

e2d6 4c 0f db    JMP AY_Divided_By_FAC1

              ; ======
e2d9            TAN_10
              ; ======

e2d9 48          PHA               ; save comparison flag
e2da 4c 9a e2    JMP SIN_10      ; add 0.25, ^2 then series evaluation

e2dd 81 49 0f PI_Half    .real 1.5707963271
e2e2 83 49 0f Two_PI     .real 6.283185307
e2e7 7f 00 00 Float_0_25 .real 0.25

e2ec          VAR_SIN
e2ec 05          .byte   $05       ; series counter
e2ed 84 e6 1a    .real -14.381390673
e2f2 86 28 07    .real  42.00779713
e2f7 87 99 68    .real -76.70417028
e2fc 87 23 35    .real  81.60522370
e301 86 a5 5d    .real -41.34170211
e306 83 49 0f    .real   6.283185308

              ; *********
e30b            Basic_ATN
              ; *********

e30b a5 66       LDA FAC1SI        ; get FAC1 sign (b7)
e30d 48          PHA               ; save sign
e30e 10 03       BPL ATN_10        ; branch if positive
e310 20 b4 df    JSR Basic_GREATER ; else do - FAC1

e313          ATN_10
e313 a5 61       LDA FAC1EX        ; get FAC1 exponent
e315 48          PHA               ; push exponent
e316 c9 81       CMP #$81          ; compare with 1
e318 90 07       BCC ATN_20        ; branch if FAC1 < 1
                 LAYI(REAL_1)
e31a a9 bc       LDA #<REAL_1
e31c a0 d9       LDY #>REAL_1

e31e 20 0f db    JSR AY_Divided_By_FAC1

e321          ATN_20
                 LAYI(VAR_ATN)     ; pointer to series
e321 a9 3b       LDA #<VAR_ATN
e323 a0 e3       LDY #>VAR_ATN

e325 20 40 e0    JSR Square_And_Series_Eval
e328 68          PLA               ; restore old FAC1 exponent
e329 c9 81       CMP #$81          ; compare with 1
e32b 90 07       BCC ATN_30        ; branch if FAC1 < 1
                 LAYI(PI_Half)     ; pointer to (pi/2)
e32d a9 dd       LDA #<PI_Half
e32f a0 e2       LDY #>PI_Half

e331 20 50 d8    JSR AY_Minus_FAC1

e334          ATN_30
e334 68          PLA               ; restore FAC1 sign
e335 10 03       BPL ATN_Ret       ; exit if was positive
e337 4c b4 df    JMP Basic_GREATER ; else do - FAC1 and return

e33a          ATN_Ret
e33a 60          RTS ;Size   48 [Basic_ATN]

e33b          VAR_ATN
e33b 0b          .byte 11        ; series counter

e33c 76 b3 83    .real -6.8479391200E-4
e341 79 1e f4    .real  4.8509421570E-3
e346 7b 83 fc    .real -1.6111701850E-2
e34b 7c 0c 1f    .real  3.4209638050E-2
e350 7c de 53    .real -5.4279132770E-2
e355 7d 14 64    .real  7.2457196550E-2
e35a 7d b7 ea    .real -8.9802395400E-2
e35f 7d 63 30    .real  1.1093241345E-1
e364 7e 92 44    .real -0.1428398077
e369 7e 4c cc    .real  0.1999991205
e36e 7f aa aa    .real -0.3333333157
e373 81 00 00    .real  1.0

0001 FALSE    #if C64
SKIP          Basic_Warm_Start
SKIP             JSR CLRCHN        ; Clear I/O channels
SKIP             LDA #0
SKIP             STA IOPMPT        ; set current I/O channel, flag default
SKIP             JSR Flush_BASIC_Stack
SKIP             CLI               ; enable interrupts
SKIP          Vectored_Basic_Ready
SKIP             LDX #$80
SKIP             JMP (IERROR)      ; normally next statement
SKIP          Back_To_Prompt
SKIP             TXA
SKIP             BMI Jump_READY
SKIP             JMP Default_Error      ; print error message
SKIP          
SKIP          Jump_READY
SKIP             JMP Basic_Ready
              #endif

e378          Basic_Cold_Start 
0001 FALSE    #if JIFFY
SKIP             JSR Jiffy_Jump_Vectors
              #else
e378 20 5b e4    JSR Init_BASIC_Jump_Vectors
              #endif
e37b 20 a4 e3    JSR Init_BASIC_RAM_Vectors
e37e 20 04 e4    JSR Print_Startup_Message
e381 a2 fb       LDX #$FB          ; value for start stack
e383 9a          TXS               ; set stack pointer
0001 FALSE    #if C64
SKIP             BNE Vectored_Basic_Ready        ; branch always
              #endif

0000 TRUE     #if VIC
e384 4c 74 c4    JMP Basic_Ready
              #endif

              ; **********
e387            CHRGET_ROM
              ; **********

e387 e6 7a       INC TXTPTR        ; increment BASIC execute pointer low byte
e389 d0 02       BNE CHRO_10       ; branch if no carry
e38b e6 7b       INC TXTPTR+1      ; increment BASIC execute pointer high byte

e38d          CHRO_10
e38d ad 60 ea    LDA $EA60         ; get byte to scan, address set by call routine
e390 c9 3a       CMP #':'          ; compare with ":"
e392 b0 0a       BCS CHRO_Ret      ; exit if>=
e394 c9 20       CMP #' '          ; compare with " "
e396 f0 ef       BEQ CHRGET_ROM    ; if " " go do next
e398 38          SEC               ; set carry for SBC
e399 e9 30       SBC #'0'          ; subtract "0"
e39b 38          SEC               ; set carry for SBC
e39c e9 d0       SBC #$D0          ; subtract -"0"
                                   ; clear carry if byte = "0"-"9"
e39e          CHRO_Ret
e39e 60          RTS ;Size   24 [CHRGET_ROM]

e39f 80 4f c7    .byte   $80,$4F,$C7,$52,$58 ; 0.811635157

              ; **********************
e3a4            Init_BASIC_RAM_Vectors
              ; **********************

e3a4 a9 4c       LDA #$4C          ; opcode for JMP
e3a6 85 54       STA JUMPER        ; save for functions vector jump
e3a8 85 00       STA Basic_USR
                 LAYI(Illegal_Quantity)
e3aa a9 48       LDA #<Illegal_Quantity
e3ac a0 d2       LDY #>Illegal_Quantity

                 STAY(USRVEC)
e3ae 85 01       STA USRVEC
e3b0 84 02       STY USRVEC+1

                 LAYI(Integer_To_Float)
e3b2 a9 91       LDA #<Integer_To_Float
e3b4 a0 d3       LDY #>Integer_To_Float

                 STAY(ADRAY2)      ; save fixed to float vector low byte
e3b6 85 05       STA ADRAY2
e3b8 84 06       STY ADRAY2+1

                 LAYI(Float_To_Integer)    ; set float to fixed vector
e3ba a9 aa       LDA #<Float_To_Integer
e3bc a0 d1       LDY #>Float_To_Integer

                 STAY(ADRAY1)       ; save float to fixed vector low byte
e3be 85 03       STA ADRAY1
e3c0 84 04       STY ADRAY1+1

e3c2 a2 1c       LDX #$1C          ; set byte count

e3c4          IBRV_10
e3c4 bd 87 e3    LDA CHRGET_ROM,X  ; get byte from table
e3c7 95 73       STA CHRGET,X      ; save byte in page zero
e3c9 ca          DEX               ; decrement count
e3ca 10 f8       BPL IBRV_10       ; loop if not all done
e3cc a9 03       LDA #$03          ; set step size, collecting descriptors
e3ce 85 53       STA GARBSS        ; save garbage collection step size
e3d0 a9 00       LDA #0
e3d2 85 68       STA FAC1OV        ; clear FAC1 overflow byte
e3d4 85 13       STA IOPMPT        ; clear current I/O channel, flag default
e3d6 85 18       STA LASTPT+1      ; clear current descriptor stack item pointer high byte
e3d8 a2 01       LDX #$01          ; set X
e3da 8e fd 01    STX BUF-3         ; set chain link pointer low byte
e3dd 8e fc 01    STX BUF-4         ; set chain link pointer high byte
e3e0 a2 19       LDX #TEMPST       ; initial value for descriptor stack
e3e2 86 16       STX TEMPPT        ; set descriptor stack pointer
e3e4 38          SEC               ; set Cb = 1 to read the bottom of memory
e3e5 20 9c ff    JSR MEMBOT        ; read/set the bottom of memory
                 STXY(TXTTAB)      ; save start of memory
e3e8 86 2b       STX TXTTAB
e3ea 84 2c       STY TXTTAB+1

e3ec 38          SEC               ; set Cb = 1 to read the top of memory
e3ed 20 99 ff    JSR MEMTOP        ; read/set the top of memory
                 STXY(MEMSIZ)      ; save end of memory
e3f0 86 37       STX MEMSIZ
e3f2 84 38       STY MEMSIZ+1

                 STXY(FRESPC)      ; set bottom of string space
e3f4 86 33       STX FRESPC
e3f6 84 34       STY FRESPC+1

e3f8 a0 00       LDY #0
e3fa 98          TYA               ; clear A
e3fb 91 2b       STA (TXTTAB),Y    ; clear first byte of memory
e3fd e6 2b       INC TXTTAB        ; increment start of memory low byte
e3ff d0 02       BNE IBRV_Ret      ; branch if no rollover
e401 e6 2c       INC TXTTAB+1      ; increment start of memory high byte

e403          IBRV_Ret
e403 60          RTS ;Size   96 [Init_BASIC_RAM_Vectors]

              ; *********************
e404            Print_Startup_Message
              ; *********************

                 LDAY(TXTTAB)      ; get start of memory
e404 a5 2b       LDA TXTTAB
e406 a4 2c       LDY TXTTAB+1

e408 20 08 c4    JSR Check_Mem_Avail
                 Print_Msg(Start_Message)
e40b a9 36       LDA #<Start_Message
e40d a0 e4       LDY #>Start_Message
e40f 20 1e cb    JSR Print_String

e412 a5 37       LDA MEMSIZ        ; get end of memory low byte
e414 38          SEC
e415 e5 2b       SBC TXTTAB        ; subtract start of memory low byte
e417 aa          TAX               ; copy result to X
e418 a5 38       LDA MEMSIZ+1      ; get end of memory high byte
e41a e5 2c       SBC TXTTAB+1      ; subtract start of memory high byte
e41c 20 cd dd    JSR Print_Integer_XA
                 Print_Msg(Bytes_Free_Message)
e41f a9 29       LDA #<Bytes_Free_Message
e421 a0 e4       LDY #>Bytes_Free_Message
e423 20 1e cb    JSR Print_String

e426 4c 44 c6    JMP Perform_NEW

0000 TRUE     #if VIC
e429          Bytes_Free_Message
e429 20 42 59    .byte   " BYTES FREE",$0D,$00

e436          Start_Message
0001 FALSE    #if JIFFY
SKIP             .byte   $93," JIFFYDOS (C)1989 CMD ",$0D,$00
              #else
e436 93 2a 2a    .byte   $93,"**** CBM BASIC V2 ****",$0D,$00
              #endif
              #endif

              ; BASIC vectors, these are copied to RAM from IERROR   onwards

e44f          Basic_Vectors

0001 FALSE    #if C64
0001 FALSE    #if JIFFY
SKIP             .word   Jiffy_Dispatch     ; error message            IERROR  
              #else
SKIP             .word   Back_To_Prompt     ; error message            IERROR  
              #endif
              #endif

0000 TRUE     #if VIC
0001 FALSE    #if JIFFY
SKIP             .word   Jiffy_Dispatch     ; error message            IERROR  
              #else
e44f 3a c4       .word   Default_Error      ; error message            IERROR  
              #endif
              #endif

e451 83 c4       .word   Default_Warmstart  ; BASIC warm start         IMAIN
0001 FALSE    #if JIFFY
SKIP             .word   Jiffy_Tokenize     ; crunch BASIC tokens      ICRNCH
              #else
e453 7c c5       .word   Default_Tokenize   ; crunch BASIC tokens      ICRNCH
              #endif
e455 1a c7       .word   Default_Detokenize ; uncrunch BASIC tokens    IQPLOP
e457 e4 c7       .word   Default_Start      ; start new BASIC code     IGONE
e459 86 ce       .word   Default_EVAL       ; get arithmetic element   IEVAL

              ; ***********************
e45b            Init_BASIC_Jump_Vectors
              ; ***********************

e45b a2 0b       LDX #$0B          ; set byte count

e45d          IBJV_10
e45d bd 4f e4    LDA Basic_Vectors,X
e460 9d 00 03    STA IERROR,X      ; save byte to RAM
e463 ca          DEX               ; decrement index
e464 10 f7       BPL IBJV_10       ; loop if more to do
e466 60          RTS ;Size   12 [Init_BASIC_Jump_Vectors]

0001 FALSE    #if C64
SKIP          
SKIP             .BYTE 0
SKIP          
SKIP          Bytes_Free_Message
SKIP             .BYTE " BASIC BYTES FREE\r",0
SKIP          
SKIP          Start_Message
SKIP             .BYTE $93
0001 FALSE    #if JIFFY
SKIP             .BYTE "\r       JIFFYDOS V6.01 (C)1989 CMD  \r"
SKIP             .BYTE "\r C-64 BASIC V2   ",0
              #else
SKIP             .BYTE "\r    **** COMMODORE 64 BASIC V2 ****\r"
SKIP             .BYTE "\r 64K RAM SYSTEM  ",0
              #endif
SKIP             .BYTE $81
SKIP          
SKIP          ; **************
SKIP            CHKOUT_Checked
SKIP          ; **************
SKIP          
SKIP             PHA
SKIP             JSR CHKOUT
SKIP             TAX
SKIP             PLA
SKIP             BCC CHCh_Ret
SKIP             TXA
SKIP          
SKIP          CHCh_Ret
SKIP             RTS
SKIP          
              #endif

0000 TRUE     #if VIC
              ; ****************
e467            Basic_Warm_Start
              ; ****************

e467 20 cc ff    JSR CLRCHN        ; Clear I/O channels
e46a a9 00       LDA #0
e46c 85 13       STA IOPMPT        ; set current I/O channel, flag default
e46e 20 7a c6    JSR Flush_BASIC_Stack
e471 58          CLI               ; enable interrupts
e472 4c 74 c4    JMP Basic_Ready

              ; checksum byte, not referenced

0001 FALSE    #if PAL
SKIP             .byte   $e8       ; [PAL]
              #else
e475 41          .byte   $41       ; [NTSC]
              #endif

              ; rebuild BASIC line chaining and do RESTORE

e476          Rebuild_andRestore
e476 20 33 c5    JSR Rechain
e479 4c 77 c6    JMP Restore_And_Flush_Stack
              #endif

0001 FALSE    #if C64
0001 FALSE    #if JIFFY
SKIP          ; ******************
SKIP            Jiffy_Jump_Vectors
SKIP          ; ******************
SKIP          
SKIP             JSR Init_BASIC_Jump_Vectors
SKIP             LDA #<Jiffy_F1
SKIP             STA CMPO
SKIP             LDA #>Jiffy_F1
SKIP             STA CMPO+1
SKIP          
SKIP          Jiffy_Inx_PRTY
SKIP             INX   
SKIP             STX PRTY
SKIP             RTS   
SKIP          
SKIP          ; ***********
SKIP            Jiffy_CHRIN 
SKIP          ; ***********
SKIP          
SKIP             LDA #$6f
SKIP             JSR Jiffy_CHKIN
SKIP             JSR CHRIN 
SKIP             CMP #'5' 
SKIP             RTS   
SKIP          
SKIP             TAX   
SKIP             TAX   
SKIP          
              #else
SKIP             .fill 28 ($aa)
              #endif
SKIP          
SKIP          Je4d3
SKIP             STA RINONE
SKIP             LDA #1
SKIP             STA RIPRTY
SKIP             RTS
SKIP          
SKIP          STA_COLOR
SKIP             LDA COLOR
SKIP             STA (USER),Y
SKIP             RTS
SKIP          
SKIP          ; *************
SKIP            Delay_2JiffyM
SKIP          ; *************
SKIP          
SKIP             ADC #2
SKIP          Be4e2
SKIP             LDY STKEY
SKIP             INY
SKIP             BNE Be4eb
SKIP             CMP JIFFYM
SKIP             BNE Be4e2
SKIP          Be4eb
SKIP             RTS
SKIP          
SKIP          ; ********
SKIP            BaudNTSC
SKIP          ; ********
SKIP          
SKIP             .WORD $2619       ;       9753
SKIP             .WORD $1944       ;       6468
SKIP             .WORD $111a       ;       4378
SKIP             .WORD $0de8       ;       3560
SKIP             .WORD $0c70       ;       3184
SKIP             .WORD $0606       ;       1542
SKIP             .WORD $02d1       ;        721
SKIP             .WORD $0137       ;        311
SKIP             .WORD $00ae       ;        174
SKIP             .WORD $0069       ;        105
SKIP          
              #endif

0000 TRUE     #if VIC
0001 FALSE    #if JIFFY
SKIP          ; ******************
SKIP            Jiffy_Jump_Vectors
SKIP          ; ******************
SKIP          
SKIP             JSR Init_BASIC_Jump_Vectors
SKIP             LDA #<Jiffy_F1
SKIP             STA CMPO
SKIP             LDA #>Jiffy_F1
SKIP             STA CMPO+1
SKIP          
SKIP          Jiffy_Inx_PRTY
SKIP             INX   
SKIP             STX PRTY
SKIP             RTS   
SKIP          
SKIP          ; ***********
SKIP            Jiffy_CHRIN 
SKIP          ; ***********
SKIP          
SKIP             LDA #$6f
SKIP             JSR Jiffy_CHKIN
SKIP             JSR CHRIN 
SKIP             CMP #'5' 
SKIP             RTS   
SKIP          
SKIP            Jiffy_e496
SKIP          
SKIP             PLA
SKIP             PLA
SKIP             PLA
SKIP             PLA
SKIP             PLA
SKIP             RTS
SKIP          
SKIP            CIA2_PRA
SKIP            VIC_SPR_ENA
SKIP            VIC_CONTROL_1
SKIP            VIC_RASTER
SKIP             .fill 4 (-1)
              #else
e47c ff ff ff    .fill 36 (-1) ; 36 bytes
              #endif

              ; set serial data out high

              ; ***********
e4a0            CLR_IEC_DAT        ; set serial data high (clear bit)
              ; ***********

e4a0 ad 2c 91    LDA IEC_PCR
e4a3 29 df       AND #~IEC_DAT_BIT
e4a5 8d 2c 91    STA IEC_PCR
e4a8 60          RTS ;Size    9 [CLR_IEC_DAT]

              ; set serial data out low

e4a9          SET_IEC_DAT
e4a9 ad 2c 91    LDA IEC_PCR       ; get VIA 2 PCR
e4ac 09 20       ORA #$20          ; set CB2 high, serial data out low
e4ae 8d 2c 91    STA IEC_PCR       ; set VIA 2 PCR
e4b1 60          RTS ;Size   18 [CLR_IEC_DAT]

              ; ***********
e4b2            GET_IEC_CLK        ; get serial clock status
              ; ***********

e4b2 ad 1f 91    LDA IEC_DRAN      ; get VIA 1 DRA, no handshake
e4b5 cd 1f 91    CMP IEC_DRAN      ; compare with self
e4b8 d0 f8       BNE GET_IEC_CLK   ; loop if changing
e4ba 4a          LSR A             ; shift serial clock to Cb
e4bb 60          RTS ;Size   10 [GET_IEC_CLK]

              ; **********************
e4bc            Get_SA_Print_Searching
              ; **********************

e4bc a6 b9       LDX SA
e4be 4c 47 f6    JMP Print_Searching

              ; ****************
e4c1            Set_Load_Address
              ; ****************

e4c1 8a          TXA               ; copy secondary address
e4c2 d0 08       BNE SLA_10        ; load location not set in LOAD call, so
e4c4 a5 c3       LDA MEMUSS        ; get load address low byte
e4c6 85 ae       STA EAL           ; save program start address low byte
e4c8 a5 c4       LDA MEMUSS+1      ; get load address high byte
e4ca 85 af       STA EAL+1         ; save program start address high byte

e4cc          SLA_10
e4cc 4c 6a f6    JMP Display_LOADING_Or_VERIFYING

              ; ***********
e4cf            Close_Patch
              ; ***********

0001 FALSE    #if JIFFY
SKIP          ; *****************
SKIP            Jiffy_Test_Device
SKIP          ; *****************
SKIP          
SKIP             STX FA
SKIP          
SKIP          ; *************
SKIP            Jiffy_Test_FA
SKIP          ; *************
SKIP          
SKIP             TYA
SKIP             PHA
SKIP             JSR Jiffy_Open_Command_Channel    ; open 15,x,15
SKIP             JSR JiDi_60    ; set command channel (15) as output
SKIP             PHP
SKIP             JSR Jiffy_Close_15
SKIP             PLP
SKIP             PLA
SKIP             TAY
SKIP             LDX FA
SKIP             RTS
SKIP          
SKIP          ; **********
SKIP            Jiffy_STOP
SKIP          ; **********
SKIP          
SKIP             TXA
SKIP             PHA
SKIP             TSX
SKIP             LDA STACK+7,X
SKIP             CMP #$f6
SKIP             BNE JTD_09
SKIP             LDA STACK+6,X
SKIP             CMP #$35
SKIP             BEQ JTD_11
SKIP             CMP #$2f
SKIP             BEQ JTD_11
SKIP          
SKIP          JTD_09
SKIP             PLA
SKIP             TAX
SKIP             JMP (ISTOP)
SKIP          
SKIP          JTD_11
SKIP             JMP Jiffy_e496
SKIP          
              #else
e4cf 20 e3 f8    JSR Init_Tape_Write
e4d2 90 03       BCC ClPa_10       ; branch if no error
e4d4 68          PLA               ; else dump stacked exit code
e4d5 a9 00       LDA #$00          ; clear exit code

e4d7          ClPa_10
e4d7 4c 9e f3    JMP KeCL_50      ; go do I/O close

e4da ff ff ff    .FILL 38 (-1)     ; spare bytes, not referenced ; 38 bytes
              #endif
              #endif

              ; *************
e500            Kernal_IOBASE      ; return base address of I/O devices
              ; *************

e500 a2 10       LDX #<IO_Base_Address
e502 a0 91       LDY #>IO_Base_Address
e504 60          RTS ;Size    5 [Kernal_IOBASE]

              ; *************
e505            Kernal_SCREEN      ; Return screen format
              ; *************

e505 a2 16       LDX #COLS
e507 a0 17       LDY #ROWS
e509 60          RTS ;Size    5 [Kernal_SCREEN]

              ; ***********
e50a            Kernal_PLOT        ; read (C=1) or set (C=0) X,Y cursor position
              ; ***********

e50a b0 07       BCS PLOT_10       ; if read cursor skip the set cursor

e50c          PLOT_05
e50c 86 d6       STX TBLX          ; save cursor row
e50e 84 d3       STY CSRIDX        ; save cursor column
e510 20 87 e5    JSR Adjust_Line   ; set screen pointers for cursor row, column

e513          PLOT_10
e513 a6 d6       LDX TBLX          ; get cursor row
e515 a4 d3       LDY CSRIDX        ; get cursor column
e517 60          RTS ;Size   14 [Kernal_PLOT]

              ; *******************
e518            Initialise_Hardware
              ; *******************

e518 20 bb e5    JSR Set_Default_Devices
0000 TRUE     #if VIC
e51b ad 88 02    LDA SCNMPG        ; get screen memory page
e51e 29 fd       AND #$FD          ; mask xxxx xx0x, all but va9
e520 0a          ASL A             ; << 1 xxxx x0x0
e521 0a          ASL A             ; << 2 xxxx 0x00
e522 09 80       ORA #$80          ; set  1xxx 0x00
e524 8d 05 90    STA VIC_R5        ; set screen and character memory location
e527 ad 88 02    LDA SCNMPG        ; get screen memory page
e52a 29 02       AND #$02          ; mask bit 9
e52c f0 08       BEQ InHa_10       ; if zero just go normalise screen
e52e a9 80       LDA #$80          ; set b7
e530 0d 02 90    ORA VIC_R2        ; OR in as video address 9
e533 8d 02 90    STA VIC_R2        ; save new va9
              #endif

e536          InHa_10
e536 a9 00       LDA #0
e538 8d 91 02    STA MODE          ; clear shift mode switch
e53b 85 cf       STA BLNON         ; clear cursor blink phase
e53d a9 dc       LDA #<Keyboard_Decoder
e53f 8d 8f 02    STA KEYLOG
e542 a9 eb       LDA #>Keyboard_Decoder
e544 8d 90 02    STA KEYLOG+1
e547 a9 0a       LDA #$0A          ; 10d
e549 8d 89 02    STA KBMAXL        ; set maximum size of keyboard buffer
e54c 8d 8c 02    STA KRPTDL        ; set repeat delay counter
e54f a9 06       LDA #Default_Color
e551 8d 86 02    STA COLOR         ; set current colour code
e554 a9 04       LDA #$04          ; speed 4
e556 8d 8b 02    STA KRPTSP        ; set repeat speed counter
e559 a9 0c       LDA #$0C          ; cursor flash timing
e55b 85 cd       STA BLNCT         ; set cursor timing countdown
e55d 85 cc       STA BLNSW         ; set cursor enable, $00 = flash cursor

              ; ************
e55f            Clear_Screen
              ; ************

e55f ad 88 02    LDA SCNMPG        ; get screen memory page
e562 09 80       ORA #$80          ; set high bit, flag every line is logical line start
e564 a8          TAY               ; copy to Y
e565 a9 00       LDA #$00          ; clear line start low byte
e567 aa          TAX               ; clear index

e568          ClSc_10
e568 94 d9       STY SLLTBL,X      ; save start of line X pointer high byte
e56a 18          CLC
e56b 69 16       ADC #COLS         ; add line length to low byte
e56d 90 01       BCC ClSc_20       ; if no rollover skip the high byte increment
e56f c8          INY               ; else increment high byte

e570          ClSc_20
e570 e8          INX               ; increment line index
e571 e0 18       CPX #ROWS+1       ; compare with number of lines + 1
e573 d0 f3       BNE ClSc_10       ; loop if not all done
e575 a9 ff       LDA #$FF          ; end of table marker ??
e577 95 d9       STA SLLTBL,X      ; mark end of table
e579 a2 16       LDX #ROWS-1       ; set line count

e57b          ClSc_30
e57b 20 8d ea    JSR Clear_Screen_Row_X
e57e ca          DEX               ; decrement count
e57f 10 fa       BPL ClSc_30       ; loop if more to do

              ; *******
e581            Do_Home
              ; *******

e581 a0 00       LDY #0
e583 84 d3       STY CSRIDX        ; clear cursor column
e585 84 d6       STY TBLX          ; clear cursor row

e587          Adjust_Line
e587 a6 d6       LDX TBLX          ; get cursor row
e589 a5 d3       LDA CSRIDX        ; get cursor column

e58b          Home_10
e58b b4 d9       LDY SLLTBL,X      ; get start of line X pointer high byte
e58d 30 08       BMI Home_20       ; continue if logical line start
e58f 18          CLC               ; else clear carry for add
e590 69 16       ADC #COLS         ; add one line length
e592 85 d3       STA CSRIDX        ; save cursor column
e594 ca          DEX               ; decrement cursor row
e595 10 f4       BPL Home_10       ; loop, branch always

e597          Home_20
0001 FALSE    #if C64
SKIP             JSR Start_Of_Line
              #endif
0000 TRUE     #if VIC
e597 b5 d9       LDA SLLTBL,X      ; get start of line X pointer high byte
e599 29 03       AND #$03          ; mask 0000 00xx, line memory page
e59b 0d 88 02    ORA SCNMPG        ; OR with screen memory page
e59e 85 d2       STA LINPTR+1      ; set current screen line pointer high byte
e5a0 bd fd ed    LDA Line_Adress_Low,X    ; get start of line low byte from ROM table
e5a3 85 d1       STA LINPTR        ; set current screen line pointer low byte
              #endif
e5a5 a9 15       LDA #COLS-1       ; set line length
e5a7 e8          INX               ; increment cursor row

e5a8          Home_30
e5a8 b4 d9       LDY SLLTBL,X      ; get start of line X pointer high byte
e5aa 30 06       BMI Home_40       ; exit if logical line start
e5ac 18          CLC               ; else clear carry for add
e5ad 69 16       ADC #COLS         ; add one line length to current line length
e5af e8          INX               ; increment cursor row
e5b0 10 f6       BPL Home_30       ; loop, branch always

e5b2          Home_40
e5b2 85 d5       STA LINLEN        ; save current screen line length
0000 TRUE     #if VIC
e5b4 60          RTS ;Size   52 [Do_Home]
              #endif

0001 FALSE    #if C64
SKIP             JMP Set_COLRAM_Pointer
SKIP          
SKIP          Home_50
SKIP             CPX ICRROW
SKIP             BEQ Home_Ret
SKIP             JMP Set_Pointer_To_Start_Of_Logical_Row_X
SKIP          
SKIP          Home_Ret
SKIP             RTS
SKIP          
SKIP             NOP
              #endif

e5b5 20 bb e5    JSR Set_Default_Devices
e5b8 4c 81 e5    JMP Do_Home

              ; *******************
e5bb            Set_Default_Devices
              ; *******************

e5bb a9 03       LDA #3            ; set screen
e5bd 85 9a       STA DFLTO         ; set output device number
e5bf a9 00       LDA #0            ; set keyboard
e5c1 85 99       STA DFLTN         ; set input device number

              ; *************
e5c3            Init_VIC_Chip
              ; *************

e5c3 a2 10       LDX #VIC_REGS

e5c5          IVC_Loop
e5c5 bd e3 ed    LDA VIC_INIT-1,X  ; get byte from setup table
e5c8 9d ff 8f    STA VIC_BASE-1,X  ; save byte to Vic chip
e5cb ca          DEX               ; decrement count/index
e5cc d0 f7       BNE IVC_Loop      ; loop if more to do
e5ce 60          RTS ;Size   12 [Init_VIC_Chip]

              ; *****************************
e5cf            Get_Char_From_Keyboard_Buffer
              ; *****************************

e5cf ac 77 02    LDY KBUFFR        ; get current character from buffer
e5d2 a2 00       LDX #0

e5d4          GCFK_Loop
e5d4 bd 78 02    LDA KBUFFR+1,X    ; get next character,X from buffer
e5d7 9d 77 02    STA KBUFFR,X      ; save as current character,X in buffer
e5da e8          INX               ; increment index
e5db e4 c6       CPX NDX           ; compare with keyboard buffer index
e5dd d0 f5       BNE GCFK_Loop     ; loop if more to do
e5df c6 c6       DEC NDX           ; decrement keyboard buffer index
e5e1 98          TYA               ; copy key to A
e5e2 58          CLI               ; enable interrupts
e5e3 18          CLC               ; flag got byte
e5e4 60          RTS ;Size   22 [Get_Char_From_Keyboard_Buffer]

              ; ===================
e5e5            Display_And_Get_Key
              ; ===================

e5e5 20 42 e7    JSR Screen_CHROUT ; output character

              ; =======
e5e8            Get_Key
              ; =======

e5e8 a5 c6       LDA NDX           ; get keyboard buffer index
e5ea 85 cc       STA BLNSW         ; cursor enable, $00 = flash cursor, $xx = no flash
e5ec 8d 92 02    STA AUTODN        ; screen scrolling flag, $00 = scroll, $xx = no scroll
e5ef f0 f7       BEQ Get_Key       ; loop if buffer empty
e5f1 78          SEI               ; disable interrupts
e5f2 a5 cf       LDA BLNON         ; get cursor blink phase
e5f4 f0 0c       BEQ GETK_10       ; branch if cursor phase
e5f6 a5 ce       LDA GDBLN         ; get character under cursor
e5f8 ae 87 02    LDX CSRCLR        ; get colour under cursor
e5fb a0 00       LDY #$00          ; clear Y
e5fd 84 cf       STY BLNON         ; clear cursor blink phase
e5ff 20 a1 ea    JSR Display_Char_A_And_Color_X

e602          GETK_10
0001 FALSE    #if JIFFY
SKIP             JSR Jiffy_f9e5
              #else
e602 20 cf e5    JSR Get_Char_From_Keyboard_Buffer
              #endif
e605 c9 83       CMP #$83          ; compare with [SHIFT][RUN]
e607 d0 10       BNE GETK_30       ; branch if not [SHIFT][RUN]
e609 a2 09       LDX #9            ; set byte count
e60b 78          SEI               ; disable interrupts
e60c 86 c6       STX NDX           ; set keyboard buffer index

e60e          GETK_20
e60e bd f3 ed    LDA RUNKEY-1,X    ; get byte from auto load/run table
e611 9d 76 02    STA KBUFFR-1,X    ; save to keyboard buffer
e614 ca          DEX               ; decrement count/index
e615 d0 f7       BNE GETK_20       ; loop while more to do
e617 f0 cf       BEQ Get_Key       ; loop for next key, branch always

e619          GETK_30
e619 c9 0d       CMP #CR
e61b d0 c8       BNE Display_And_Get_Key
e61d a4 d5       LDY LINLEN        ; get current screen line length
e61f 84 d0       STY INSRC         ; input from keyboard or screen, $xx = screen,

e621          GETK_40
e621 b1 d1       LDA (LINPTR),Y    ; get character from current screen line
e623 c9 20       CMP #' '          ; compare with [SPACE]
e625 d0 03       BNE GETK_50       ; branch if not [SPACE]
e627 88          DEY               ; else eliminate the space, decrement end of input line
e628 d0 f7       BNE GETK_40       ; loop, branch always

e62a          GETK_50
e62a c8          INY               ; increment past last non space character on line
e62b 84 c8       STY INDX          ; save input [EOL] pointer
e62d a0 00       LDY #0
e62f 8c 92 02    STY AUTODN        ; clear screen scrolling flag, $00 = scroll, $xx = no scroll
e632 84 d3       STY CSRIDX        ; clear cursor column
e634 84 d4       STY CSRMOD        ; clear cursor quote flag, $xx = quote, $00 = no quote
e636 a5 c9       LDA ICRROW        ; get input cursor row
e638 30 1d       BMI Get_Screen
e63a a6 d6       LDX TBLX          ; get cursor row
0001 FALSE    #if C64
SKIP             JSR Home_50
              #endif
0000 TRUE     #if VIC
e63c 20 19 e7    JSR Set_Pointer_To_Start_Of_Logical_Row_X
              #endif
e63f e4 c9       CPX ICRROW        ; compare with input cursor row
e641 d0 14       BNE Get_Screen
0000 TRUE     #if VIC
e643 d0 12       BNE Get_Screen    ; obsolete
              #endif
e645 a5 ca       LDA ICRCOL        ; get input cursor column
e647 85 d3       STA CSRIDX        ; save cursor column
e649 c5 c8       CMP INDX          ; compare with input [EOL] pointer
e64b 90 0a       BCC Get_Screen    ; branch if less, cursor is in line
e64d b0 42       BCS GetS_20      ; else cursor is beyond the line end, branch always

              ; ========================
e64f            CHRIN_Keyboard_Or_Screen
              ; ========================

e64f 98          TYA               ; copy Y
e650 48          PHA               ; save Y
e651 8a          TXA               ; copy X
e652 48          PHA               ; save X
e653 a5 d0       LDA INSRC         ; input from keyboard or screen, $xx = screen,
e655 f0 91       BEQ Get_Key       ; if keyboard go wait for key

              ; ==========
e657            Get_Screen
              ; ==========

e657 a4 d3       LDY CSRIDX        ; get cursor column
e659 b1 d1       LDA (LINPTR),Y    ; get character from the current screen line
0000 TRUE     #if VIC
e65b ea ea ea    .fill 23 ($EA)    ; NOP's ; 23 bytes
              #endif
e672 85 d7       STA LASTKY        ; save temporary last character
e674 29 3f       AND #$3F          ; mask key bits
e676 06 d7       ASL LASTKY        ; << temporary last character
e678 24 d7       BIT LASTKY        ; test it
e67a 10 02       BPL GetS_05       ; branch if not [NO KEY]
e67c 09 80       ORA #$80

e67e          GetS_05
e67e 90 04       BCC GetS_10
e680 a6 d4       LDX CSRMOD        ; get cursor quote flag, $xx = quote, $00 = no quote
e682 d0 04       BNE GetS_15       ; branch if in quote mode

e684          GetS_10
e684 70 02       BVS GetS_15
e686 09 40       ORA #$40

e688          GetS_15
e688 e6 d3       INC CSRIDX        ; increment cursor column
e68a 20 b8 e6    JSR If_Quote_Toggle_Flag
e68d c4 c8       CPY INDX          ; compare with input [EOL] pointer
e68f d0 17       BNE GetS_35       ; branch if not at line end

e691          GetS_20
e691 a9 00       LDA #$00
e693 85 d0       STA INSRC         ; clear input from keyboard or screen, $xx = screen,
e695 a9 0d       LDA #$0D          ; set character [CR]
e697 a6 99       LDX DFLTN         ; get input device number
e699 e0 03       CPX #$03          ; compare with screen
e69b f0 06       BEQ GetS_25       ; branch if screen
e69d a6 9a       LDX DFLTO         ; get output device number
e69f e0 03       CPX #$03          ; compare with screen
e6a1 f0 03       BEQ GetS_30       ; branch if screen

e6a3          GetS_25
e6a3 20 42 e7    JSR Screen_CHROUT ; output character

e6a6          GetS_30
e6a6 a9 0d       LDA #$0D          ; set character [CR]

e6a8          GetS_35
e6a8 85 d7       STA LASTKY        ; save character
e6aa 68          PLA               ; pull X
e6ab aa          TAX               ; restore X
e6ac 68          PLA               ; pull Y
e6ad a8          TAY               ; restore Y
e6ae a5 d7       LDA LASTKY        ; restore character
e6b0 c9 de       CMP #$DE
e6b2 d0 02       BNE GetS_40
e6b4 a9 ff       LDA #$FF

e6b6          GetS_40
e6b6 18          CLC
e6b7 60          RTS ;Size  233 [Get_Char_From_Keyboard_Buffer]

              ; ********************
e6b8            If_Quote_Toggle_Flag
              ; ********************

e6b8 c9 22       CMP #QUOTE
e6ba d0 08       BNE IQTF_Ret      ; exit if not "
e6bc a5 d4       LDA CSRMOD        ; get cursor quote flag, $xx = quote, $00 = no quote
e6be 49 01       EOR #1            ; toggle it
e6c0 85 d4       STA CSRMOD        ; save cursor quote flag
e6c2 a9 22       LDA #QUOTE

e6c4          IQTF_Ret
e6c4 60          RTS ;Size   13 [If_Quote_Toggle_Flag]

              ; ===========
e6c5            Insert_Char
              ; ===========

e6c5 09 40       ORA #$40          ; change to uppercase/graphic

e6c7          InsC_10
e6c7 a6 c7       LDX RVS           ; get reverse flag
e6c9 f0 02       BEQ InsC_30       ; branch if not reverse

e6cb          InsC_20
e6cb 09 80       ORA #$80          ; reverse character

e6cd          InsC_30
e6cd a6 d8       LDX INSRTO        ; get insert count
e6cf f0 02       BEQ InsC_40       ; branch if none
e6d1 c6 d8       DEC INSRTO        ; else decrement insert count

e6d3          InsC_40
e6d3 ae 86 02    LDX COLOR         ; get current colour code
e6d6 20 a1 ea    JSR Display_Char_A_And_Color_X
e6d9 20 ea e6    JSR Advance_Cursor

e6dc          InsC_50
e6dc 68          PLA               ; pull Y
e6dd a8          TAY               ; restore Y
e6de a5 d8       LDA INSRTO        ; get insert count
e6e0 f0 02       BEQ InsC_60       ; skip quote flag clear if inserts to do
e6e2 46 d4       LSR CSRMOD        ; clear cursor quote flag, $xx = quote, $00 = no quote

e6e4          InsC_60
e6e4 68          PLA               ; pull X
e6e5 aa          TAX               ; restore X
e6e6 68          PLA               ; restore A
e6e7 18          CLC
e6e8 58          CLI               ; enable interrupts
e6e9 60          RTS ;Size   50 [If_Quote_Toggle_Flag]

              ; **************
e6ea            Advance_Cursor
              ; **************

e6ea 20 fa e8    JSR Test_Line_Inc
e6ed e6 d3       INC CSRIDX        ; increment cursor column
e6ef a5 d5       LDA LINLEN        ; get current screen line length
e6f1 c5 d3       CMP CSRIDX        ; compare with cursor column
e6f3 b0 37       BCS SPTS_Ret      ; exit if line length >= cursor column
e6f5 c9 57       CMP #COLMAX-1     ; compare with max length
e6f7 f0 2a       BEQ SPTS_20       ; if at max clear column, back cursor up and do newline
e6f9 ad 92 02    LDA AUTODN        ; get autoscroll flag
e6fc f0 03       BEQ AdCu_10       ; branch if autoscroll on
e6fe 4c f0 e9    JMP InsL_10      ; else open space on screen

e701          AdCu_10
e701 a6 d6       LDX TBLX          ; get cursor row
e703 e0 17       CPX #ROWS         ; compare with max + 1
e705 90 07       BCC Expand_Logical_Line
e707 20 75 e9    JSR Scroll_Screen
e70a c6 d6       DEC TBLX          ; decrement cursor row
e70c a6 d6       LDX TBLX          ; get cursor row

              ; *******************
e70e            Expand_Logical_Line
              ; *******************

e70e 16 d9       ASL SLLTBL,X      ; shift start of line X pointer high byte
e710 56 d9       LSR SLLTBL,X      ; clears bit 7
0001 FALSE    #if C64
SKIP             INX               ; increment screen row
SKIP             LDA SLLTBL,X      ; get start of line X pointer high byte
SKIP             ORA #$80          ; mark as start of logical line
SKIP             STA SLLTBL,X      ; set start of line X pointer high byte
SKIP             DEX               ; restore screen row
SKIP             LDA LINLEN        ; get current screen line length
SKIP             CLC
              #endif
0000 TRUE     #if VIC
e712 4c 5b ed    JMP ELL_10        ; make next screen line start of logical line, increment
              #endif

              ; add one line length and set pointers for start of line

e715          ELL_20
e715 69 16       ADC #COLS         ; add one line length
e717 85 d5       STA LINLEN        ; save current screen line length

              ; *************************************
e719            Set_Pointer_To_Start_Of_Logical_Row_X
              ; *************************************

e719 b5 d9       LDA SLLTBL,X      ; get start of line X pointer high byte
e71b 30 03       BMI SPTS_10       ; exit loop if start of logical line
e71d ca          DEX               ; else back up one line
e71e d0 f9       BNE Set_Pointer_To_Start_Of_Logical_Row_X

e720          SPTS_10
e720 4c 7e ea    JMP Start_Of_Line

e723          SPTS_20
e723 c6 d6       DEC TBLX          ; decrement cursor row. if the cursor was incremented past
e725 20 c3 e8    JSR Do_Newline
e728 a9 00       LDA #0
e72a 85 d3       STA CSRIDX        ; clear cursor column

e72c          SPTS_Ret
e72c 60          RTS ;Size   20 [Set_Pointer_To_Start_Of_Logical_Row_X]

              ; *************
e72d            Previous_Line
              ; *************

e72d a6 d6       LDX TBLX          ; get cursor row
e72f d0 06       BNE PreL_10       ; branch if not top row
e731 86 d3       STX CSRIDX        ; clear cursor column
e733 68          PLA               ; dump return address low byte
e734 68          PLA               ; dump return address high byte
e735 d0 a5       BNE InsC_50       ; restore registers, set quote flag and exit, branch always

e737          PreL_10
e737 ca          DEX               ; decrement cursor row
e738 86 d6       STX TBLX          ; save cursor row
e73a 20 87 e5    JSR Adjust_Line   ; set screen pointers for cursor row, column
e73d a4 d5       LDY LINLEN        ; get current screen line length
e73f 84 d3       STY CSRIDX        ; save as cursor column
e741 60          RTS ;Size   21 [Previous_Line]

              ; *************
e742            Screen_CHROUT
              ; *************

e742 48          PHA               ; save character
e743 85 d7       STA LASTKY        ; save temporary last character
e745 8a          TXA               ; copy X
e746 48          PHA               ; save X
e747 98          TYA               ; copy Y
e748 48          PHA               ; save Y
e749 a9 00       LDA #0
e74b 85 d0       STA INSRC         ; clear input from keyboard or screen, $xx = screen,
e74d a4 d3       LDY CSRIDX        ; get cursor column
e74f a5 d7       LDA LASTKY        ; restore last character
e751 10 03       BPL ScrO_02       ; branch if unshifted
e753 4c 00 e8    JMP ScrO_42       ; do shifted characters and return

e756          ScrO_02
e756 c9 0d       CMP #$0D          ; compare with [CR]
e758 d0 03       BNE ScrO_04       ; branch if not [CR]
e75a 4c d8 e8    JMP Screen_Return

e75d          ScrO_04
e75d c9 20       CMP #' '          ; compare with [SPACE]
e75f 90 10       BCC ScrO_10       ; branch if < [SPACE]
e761 c9 60       CMP #$60
e763 90 04       BCC ScrO_06       ; branch if $20 to $5F
e765 29 df       AND #$DF
e767 d0 02       BNE ScrO_08

e769          ScrO_06
e769 29 3f       AND #$3F

e76b          ScrO_08
e76b 20 b8 e6    JSR If_Quote_Toggle_Flag
e76e 4c c7 e6    JMP InsC_10

e771          ScrO_10
e771 a6 d8       LDX INSRTO        ; get insert count
e773 f0 03       BEQ ScrO_12       ; branch if no characters to insert
e775 4c cb e6    JMP InsC_20       ; insert reversed character

e778          ScrO_12
e778 c9 14       CMP #$14          ; compare with [INSERT]/[DELETE]
e77a d0 2e       BNE ScrO_20       ; branch if not [INSERT]/[DELETE]
e77c 98          TYA
e77d d0 06       BNE ScrO_14
e77f 20 2d e7    JSR Previous_Line
e782 4c 9f e7    JMP ScrO_18

e785          ScrO_14
e785 20 e8 e8    JSR Test_Line_Dec
e788 88          DEY               ; decrement index to previous character
e789 84 d3       STY CSRIDX        ; save cursor column
e78b 20 b2 ea    JSR Set_COLRAM_Pointer

e78e          ScrO_16
e78e c8          INY
e78f b1 d1       LDA (LINPTR),Y    ; get character from current screen line
e791 88          DEY               ; decrement index to previous character
e792 91 d1       STA (LINPTR),Y    ; save character to current screen line
e794 c8          INY
e795 b1 f3       LDA (USER),Y      ; get colour RAM byte
e797 88          DEY               ; decrement index to previous character
e798 91 f3       STA (USER),Y      ; save colour RAM byte
e79a c8          INY
e79b c4 d5       CPY LINLEN        ; compare with current screen line length
e79d d0 ef       BNE ScrO_16       ; loop if not there yet

e79f          ScrO_18
e79f a9 20       LDA #' '          ; set [SPACE]
e7a1 91 d1       STA (LINPTR),Y    ; clear last character on current screen line
e7a3 ad 86 02    LDA COLOR         ; get current colour code
e7a6 91 f3       STA (USER),Y      ; save to colour RAM
e7a8 10 4d       BPL ScrO_38       ; branch always

e7aa          ScrO_20
e7aa a6 d4       LDX CSRMOD        ; get cursor quote flag, $xx = quote, $00 = no quote
e7ac f0 03       BEQ ScrO_22       ; branch if not quote mode
e7ae 4c cb e6    JMP InsC_20       ; insert reversed character

e7b1          ScrO_22
e7b1 c9 12       CMP #$12          ; compare with [RVS ON]
e7b3 d0 02       BNE ScrO_24       ; branch if not [RVS ON]
e7b5 85 c7       STA RVS           ; set reverse flag

e7b7          ScrO_24
e7b7 c9 13       CMP #$13          ; compare with [CLR HOME]
e7b9 d0 03       BNE ScrO_26       ; branch if not [CLR HOME]
e7bb 20 81 e5    JSR Do_Home

e7be          ScrO_26
e7be c9 1d       CMP #$1D          ; compare with [CURSOR RIGHT]
e7c0 d0 17       BNE ScrO_32       ; branch if not [CURSOR RIGHT]
e7c2 c8          INY               ; increment cursor column
e7c3 20 fa e8    JSR Test_Line_Inc
e7c6 84 d3       STY CSRIDX        ; save cursor column
e7c8 88          DEY               ; decrement cursor column
e7c9 c4 d5       CPY LINLEN        ; compare cursor column with current screen line length
e7cb 90 09       BCC ScrO_30       ; exit if less
e7cd c6 d6       DEC TBLX          ; decrement cursor row
e7cf 20 c3 e8    JSR Do_Newline
e7d2 a0 00       LDY #$00          ; clear cursor column

e7d4          ScrO_28
e7d4 84 d3       STY CSRIDX        ; save cursor column

e7d6          ScrO_30
e7d6 4c dc e6    JMP InsC_50       ; restore registers, set quote flag and exit

e7d9          ScrO_32
e7d9 c9 11       CMP #$11          ; compare with [CURSOR DOWN]
e7db d0 1d       BNE ScrO_40       ; branch if not [CURSOR DOWN]
e7dd 18          CLC
e7de 98          TYA               ; copy cursor column
e7df 69 16       ADC #COLS         ; add one line
e7e1 a8          TAY               ; copy back to A
e7e2 e6 d6       INC TBLX          ; increment cursor row
e7e4 c5 d5       CMP LINLEN        ; compare cursor column with current screen line length
e7e6 90 ec       BCC ScrO_28       ; save cursor column and exit if less
e7e8 f0 ea       BEQ ScrO_28       ; save cursor column and exit if equal
e7ea c6 d6       DEC TBLX          ; decrement cursor row

e7ec          ScrO_34
e7ec e9 16       SBC #COLS         ; subtract one line
e7ee 90 04       BCC ScrO_36       ; exit loop if on previous line
e7f0 85 d3       STA CSRIDX        ; else save cursor column
e7f2 d0 f8       BNE ScrO_34       ; loop if not at start of line

e7f4          ScrO_36
e7f4 20 c3 e8    JSR Do_Newline

e7f7          ScrO_38
e7f7 4c dc e6    JMP InsC_50       ; restore registers, set quote flag and exit

e7fa          ScrO_40
e7fa 20 12 e9    JSR Set_Color
e7fd 4c 21 ed    JMP Switch_Text_Graphics

e800          ScrO_42
0000 TRUE     #if VIC
e800 ea ea ea    .fill 21 ($EA)    ; NOP's ; 21 bytes
              #endif
e815 29 7f       AND #$7F          ; mask 0xxx xxxx, clear b7
e817 c9 7f       CMP #$7F          ; was it $FF before the mask
e819 d0 02       BNE ScrO_44       ; branch if not
e81b a9 5e       LDA #$5E          ; else make it $5E
e81d          ScrO_44
0000 TRUE     #if VIC
e81d ea          NOP
e81e ea          NOP
e81f ea          NOP
e820 ea          NOP
e821 ea          NOP
e822 ea          NOP
              #endif
e823 c9 20       CMP #' '          ; compare with [SPACE]
e825 90 03       BCC ScrO_46       ; branch if < [SPACE]
e827 4c c5 e6    JMP Insert_Char

e82a          ScrO_46
e82a c9 0d       CMP #$0D          ; compare with [CR]
e82c d0 03       BNE ScrO_48       ; branch if not [CR]
e82e 4c d8 e8    JMP Screen_Return      ; else output [CR] and return
                                   ; was not [CR]
e831          ScrO_48
e831 a6 d4       LDX CSRMOD        ; get cursor quote flag, $xx = quote, $00 = no quote
e833 d0 3f       BNE ScrO_60       ; branch if quote mode
e835 c9 14       CMP #$14          ; compare with [INSERT DELETE]
e837 d0 37       BNE ScrO_58       ; branch if not [INSERT DELETE]
e839 a4 d5       LDY LINLEN        ; get current screen line length
e83b b1 d1       LDA (LINPTR),Y    ; get character from current screen line
e83d c9 20       CMP #' '          ; compare with [SPACE]
e83f d0 04       BNE ScrO_50       ; branch if not [SPACE]
e841 c4 d3       CPY CSRIDX        ; compare current column with cursor column
e843 d0 07       BNE ScrO_52       ; if not cursor column go open up space on line

e845          ScrO_50
e845 c0 57       CPY #COLMAX-1     ; compare current column with max line length
e847 f0 24       BEQ ScrO_56       ; exit if at line end
e849 20 ee e9    JSR Insert_Line

e84c          ScrO_52
e84c a4 d5       LDY LINLEN        ; get current screen line length
e84e 20 b2 ea    JSR Set_COLRAM_Pointer

e851          ScrO_54
e851 88          DEY               ; decrement index to previous character
e852 b1 d1       LDA (LINPTR),Y    ; get character from current screen line
e854 c8          INY
e855 91 d1       STA (LINPTR),Y    ; save character to current screen line
e857 88          DEY               ; decrement index to previous character
e858 b1 f3       LDA (USER),Y      ; get current screen line colour RAM byte
e85a c8          INY
e85b 91 f3       STA (USER),Y      ; save current screen line colour RAM byte
e85d 88          DEY               ; decrement index to previous character
e85e c4 d3       CPY CSRIDX        ; compare with cursor column
e860 d0 ef       BNE ScrO_54       ; loop if not there yet
e862 a9 20       LDA #' '          ; set [SPACE]
e864 91 d1       STA (LINPTR),Y    ; clear character at cursor position on current screen line
e866 ad 86 02    LDA COLOR         ; get current colour code
e869 91 f3       STA (USER),Y      ; save to cursor position on current screen line colour RAM
e86b e6 d8       INC INSRTO        ; increment insert count

e86d          ScrO_56
e86d 4c dc e6    JMP InsC_50       ; restore registers, set quote flag and exit

e870          ScrO_58
e870 a6 d8       LDX INSRTO        ; get insert count
e872 f0 05       BEQ ScrO_62       ; branch if no insert space

e874          ScrO_60
e874 09 40       ORA #$40          ; change to uppercase/graphic
e876 4c cb e6    JMP InsC_20       ; insert reversed character

e879          ScrO_62
e879 c9 11       CMP #$11          ; compare with [CURSOR UP]
e87b d0 16       BNE ScrO_66       ; branch if not [CURSOR UP]
e87d a6 d6       LDX TBLX          ; get cursor row
e87f f0 37       BEQ ScrO_74       ; branch if on top line
e881 c6 d6       DEC TBLX          ; decrement cursor row
e883 a5 d3       LDA CSRIDX        ; get cursor column
e885 38          SEC
e886 e9 16       SBC #COLS         ; subtract one line length
e888 90 04       BCC ScrO_64       ; branch if stepped back to previous line
e88a 85 d3       STA CSRIDX        ; else save cursor column ..
e88c 10 2a       BPL ScrO_74       ; .. and exit, branch always

e88e          ScrO_64
e88e 20 87 e5    JSR Adjust_Line   ; set screen pointers for cursor row, column ..
e891 d0 25       BNE ScrO_74       ; .. and exit, branch always

e893          ScrO_66
e893 c9 12       CMP #$12          ; compare with [RVS OFF]
e895 d0 04       BNE ScrO_68       ; branch if not [RVS OFF]
e897 a9 00       LDA #0
e899 85 c7       STA RVS           ; clear reverse flag

e89b          ScrO_68
e89b c9 1d       CMP #$1D          ; compare with [CURSOR LEFT]
e89d d0 12       BNE ScrO_72       ; branch if not [CURSOR LEFT]
e89f 98          TYA               ; copy cursor column
e8a0 f0 09       BEQ ScrO_70       ; branch if at start of line
e8a2 20 e8 e8    JSR Test_Line_Dec
e8a5 88          DEY               ; decrement cursor column
e8a6 84 d3       STY CSRIDX        ; save cursor column
e8a8 4c dc e6    JMP InsC_50       ; restore registers, set quote flag and exit

e8ab          ScrO_70
e8ab 20 2d e7    JSR Previous_Line
e8ae 4c dc e6    JMP InsC_50       ; restore registers, set quote flag and exit

e8b1          ScrO_72
e8b1 c9 13       CMP #$13          ; compare with [CLR]
e8b3 d0 06       BNE ScrO_76       ; branch if not [CLR]
e8b5 20 5f e5    JSR Clear_Screen

e8b8          ScrO_74
e8b8 4c dc e6    JMP InsC_50       ; restore registers, set quote flag and exit

e8bb          ScrO_76
e8bb 09 80       ORA #$80          ; restore b7, colour can only be black, cyan, magenta
e8bd 20 12 e9    JSR Set_Color
e8c0 4c 30 ed    JMP STG_10

              ; **********
e8c3            Do_Newline
              ; **********

e8c3 46 c9       LSR ICRROW        ; shift >> input cursor row
e8c5 a6 d6       LDX TBLX          ; get cursor row

e8c7          NewL_10
e8c7 e8          INX               ; increment row
e8c8 e0 17       CPX #ROWS         ; compare with last row + 1
e8ca d0 03       BNE NewL_20       ; branch if not last row + 1
e8cc 20 75 e9    JSR Scroll_Screen

e8cf          NewL_20
e8cf b5 d9       LDA SLLTBL,X      ; get start of line X pointer high byte
e8d1 10 f4       BPL NewL_10       ; loop if not start of logical line
e8d3 86 d6       STX TBLX          ; else save cursor row
e8d5 4c 87 e5    JMP Adjust_Line   ; set screen pointers for cursor row, column and return

              ; =============
e8d8            Screen_Return
              ; =============

e8d8 a2 00       LDX #0
e8da 86 d8       STX INSRTO        ; clear insert count
e8dc 86 c7       STX RVS           ; clear reverse flag
e8de 86 d4       STX CSRMOD        ; clear cursor quote flag, $xx = quote, $00 = no quote
e8e0 86 d3       STX CSRIDX        ; clear cursor column
e8e2 20 c3 e8    JSR Do_Newline
e8e5 4c dc e6    JMP InsC_50      ; restore registers, set quote flag and exit

              ; *************
e8e8            Test_Line_Dec
              ; *************

e8e8 a2 04       LDX #COLINK       ; set count
e8ea a9 00       LDA #$00          ; set column

e8ec          TLD_10
e8ec c5 d3       CMP CSRIDX        ; compare with cursor column
e8ee f0 07       BEQ TLD_20        ; branch if at start of line
e8f0 18          CLC               ; else clear carry for add
e8f1 69 16       ADC #COLS         ; increment to next line
e8f3 ca          DEX               ; decrement loop count
e8f4 d0 f6       BNE TLD_10        ; loop if more to test
e8f6 60          RTS ;Size   15 [Test_Line_Dec]

e8f7          TLD_20
e8f7 c6 d6       DEC TBLX          ; else decrement cursor row
e8f9 60          RTS ;Size   18 [Test_Line_Dec]

              ; *************
e8fa            Test_Line_Inc
              ; *************

e8fa a2 04       LDX #COLINK       ; set count
e8fc a9 15       LDA #COLS-1       ; set column

e8fe          TLI_10
e8fe c5 d3       CMP CSRIDX        ; compare with cursor column
e900 f0 07       BEQ TLI_20        ; if at end of line test and possibly increment cursor row
e902 18          CLC               ; else clear carry for add
e903 69 16       ADC #COLS         ; increment to next line
e905 ca          DEX               ; decrement loop count
e906 d0 f6       BNE TLI_10        ; loop if more to test
e908 60          RTS ;Size   15 [Test_Line_Inc]

                                   ; cursor is at end of line
e909          TLI_20
e909 a6 d6       LDX TBLX          ; get cursor row
e90b e0 17       CPX #ROWS
e90d f0 02       BEQ TLI_30        ; exit if end of screen
e90f e6 d6       INC TBLX          ; else increment cursor row

e911          TLI_30
e911 60          RTS ;Size   24 [Test_Line_Inc]

              ; *********
e912            Set_Color
              ; *********

e912 a2 07       LDX #Color_Codes_End-Color_Codes-1

e914          SeCo_Loop
e914 dd 21 e9    CMP Color_Codes,X ; compare the character with the table code
e917 f0 04       BEQ SeCo_10       ; if a match go save the colour and exit
e919 ca          DEX               ; else decrement the index
e91a 10 f8       BPL SeCo_Loop     ; loop if more to do
e91c 60          RTS ;Size   11 [Set_Color]

e91d          SeCo_10
e91d 8e 86 02    STX COLOR         ; set current colour code
e920 60          RTS ;Size   15 [Set_Color]

e921          Color_Codes

e921 90          .byte $90         ; black
e922 05          .byte $05         ; white
e923 1c          .byte $1C         ; red
e924 9f          .byte $9F         ; cyan
e925 9c          .byte $9C         ; magenta
e926 1e          .byte $1E         ; green
e927 1f          .byte $1F         ; blue
e928 9e          .byte $9E         ; yellow

0001 FALSE    #if C64
SKIP             .byte $81         ; orange
SKIP             .byte $95         ; brown
SKIP             .byte $96         ; light red
SKIP             .byte $97         ; grey 1
SKIP             .byte $98         ; grey 2
SKIP             .byte $99         ; light green
SKIP             .byte $9a         ; light blue
SKIP             .byte $9b         ; grey 3
              #endif

e929          Color_Codes_End

              ; 76 bytes of unused VIC data

0000 TRUE     #if VIC
e929 ef a1 df    .byte   $EF,$A1,$DF,$A6,$E1,$B1,$E2,$B2,$E3,$B3,$E4,$B4,$E5,$B5,$E6,$B6
e939 e7 b7 e8    .byte   $E7,$B7,$E8,$B8,$E9,$B9,$FA,$BA,$FB,$BB,$FC,$BC,$EC,$BD,$FE,$BE
e949 84 bf f7    .byte   $84,$BF,$F7,$C0,$F8,$DB,$F9,$DD,$EA,$DE,$5E,$E0,$5B,$E1,$5D,$E2
e959 40 b0 61    .byte   $40,$B0,$61,$B1,$78,$DB,$79,$DD,$66,$B6,$77,$C0,$70,$F0,$71,$F1
e969 72 f2 73    .byte   $72,$F2,$73,$F3,$74,$F4,$75,$F5,$76,$F6,$7D,$FD
              #endif

              ; *************
e975            Scroll_Screen
              ; *************

e975 a5 ac       LDA SAL           ; save SAL & EAL
e977 48          PHA
e978 a5 ad       LDA SAL+1
e97a 48          PHA
e97b a5 ae       LDA EAL
e97d 48          PHA
e97e a5 af       LDA EAL+1
e980 48          PHA

e981          ScSc_05
e981 a2 ff       LDX #-1           ; set for pre increment loop
e983 c6 d6       DEC TBLX          ; decrement cursor row
e985 c6 c9       DEC ICRROW        ; decrement input cursor row
e987 c6 f2       DEC SCROWM        ; decrement screen row marker

e989          ScSc_10
e989 e8          INX               ; increment line number
e98a 20 7e ea    JSR Start_Of_Line
e98d e0 16       CPX #ROWS-1       ; compare with last line
e98f b0 0c       BCS ScSc_15       ; branch if on last line
e991 bd fe ed    LDA Line_Adress_Low+1,X
e994 85 ac       STA SAL           ; save next line pointer low byte
e996 b5 da       LDA SLLTBL+1,X    ; get start of next line pointer high byte
e998 20 56 ea    JSR Shift_Row
e99b 30 ec       BMI ScSc_10       ; loop, branch always

e99d          ScSc_15
e99d 20 8d ea    JSR Clear_Screen_Row_X
e9a0 a2 00       LDX #0

e9a2          ScSc_20
e9a2 b5 d9       LDA SLLTBL,X      ; get start of line X pointer high byte
e9a4 29 7f       AND #$7F          ; clear line X start of logical line bit
e9a6 b4 da       LDY SLLTBL+1,X    ; get start of next line pointer high byte
e9a8 10 02       BPL ScSc_25       ; branch if next line not start of line
e9aa 09 80       ORA #$80          ; set line X start of logical line bit

e9ac          ScSc_25
e9ac 95 d9       STA SLLTBL,X      ; set start of line X pointer high byte
e9ae e8          INX               ; increment line number
e9af e0 16       CPX #ROWS-1       ; compare with last line
e9b1 d0 ef       BNE ScSc_20       ; loop if not last line
e9b3 a5 ef       LDA SLLTBL+ROWS-1 ; get start of last line pointer high byte
e9b5 09 80       ORA #$80          ; mark as start of logical line
e9b7 85 ef       STA SLLTBL+ROWS-1 ; set start of last line pointer high byte
e9b9 a5 d9       LDA SLLTBL        ; get start of first line pointer high byte
e9bb 10 c4       BPL ScSc_05       ; if not start of logical line loop back and
e9bd e6 d6       INC TBLX          ; increment cursor row
e9bf e6 f2       INC SCROWM        ; increment screen row marker
e9c1          ScSc_27
0001 FALSE    #if JIFFY
0001 FALSE    #if C64
SKIP             JSR KeSc_70       ; scan standard column
SKIP             LDA KEYB_ROW      ; get VIA/CIA keyboard row
SKIP             CMP #CTRL_ROW     ; compare with row of [CTRL] key
              #endif
0000 TRUE     #if VIC
SKIP             PHP
SKIP             SEI
SKIP             JMP TASB_20
SKIP          
SKIP          Jiffy_e9c6
SKIP             PLP
SKIP             CPX #$fe
              #endif
              #else
e9c1 a9 fb       LDA #CTRL_COL     ; set keyboard column for [CTRL] key
e9c3 8d 20 91    STA KEYB_COL      ; set VIA/CIA keyboard column
e9c6 ad 21 91    LDA KEYB_ROW      ; get VIA/CIA keyboard row
e9c9 c9 fe       CMP #CTRL_ROW     ; compare with row of [CTRL] key
              #endif
0001 FALSE    #if JIFFY
SKIP             BNE ScSc_40       ; no [CTRL]
SKIP             LDX NDX           ; chars in keyboard buffer
SKIP             BEQ ScSc_27       ; none
SKIP             LDA KBUFFR-1,X    ; last key
SKIP             SBC #$13          ; [CTRL] S
SKIP             BNE ScSc_40
SKIP             STA NDX           ; clear keyboard buffer
SKIP          
SKIP          ScSc_28
SKIP             CLI
SKIP             CMP NDX
SKIP             BEQ ScSc_28       ; wait until key pressed
SKIP             STA NDX
              #else
e9cb 08          PHP               ; save status
e9cc a9 f7       LDA #STND_COL     ; set standard keyboard col
e9ce 8d 20 91    STA KEYB_COL      ; set VIA/CIA keyboard column
e9d1 28          PLP               ; restore status
e9d2 d0 0b       BNE ScSc_40       ; skip if no [CTRL] key down
e9d4 a0 00       LDY #0            ; delay scrolling if [CTRL] key down

e9d6          ScSc_30
e9d6 ea          NOP               ; waste cycles
e9d7 ca          DEX               ; decrement inner loop count
e9d8 d0 fc       BNE ScSc_30       ; loop if not all done
e9da 88          DEY               ; decrement outer loop count
e9db d0 f9       BNE ScSc_30       ; loop if not all done
e9dd 84 c6       STY NDX           ; clear keyboard buffer index
              #endif

e9df          ScSc_40
e9df a6 d6       LDX TBLX          ; get cursor row

e9e1          ScSc_45
e9e1 68          PLA               ; restore EAL & SAL
e9e2 85 af       STA EAL+1
e9e4 68          PLA
e9e5 85 ae       STA EAL
e9e7 68          PLA
e9e8 85 ad       STA SAL+1
e9ea 68          PLA
e9eb 85 ac       STA SAL
e9ed 60          RTS ;Size  121 [Scroll_Screen]

              ; ***********
e9ee            Insert_Line
              ; ***********

e9ee a6 d6       LDX TBLX          ; get cursor row

e9f0          InsL_10
e9f0 e8          INX               ; increment row
e9f1 b5 d9       LDA SLLTBL,X      ; get start of line X pointer high byte
e9f3 10 fb       BPL InsL_10       ; branch if not start of logical line
e9f5 86 f2       STX SCROWM        ; set screen row marker
e9f7 e0 16       CPX #ROWS-1       ; compare with last line
e9f9 f0 0d       BEQ InsL_20       ; branch if = last line
e9fb 90 0b       BCC InsL_20       ; branch if < last line
e9fd 20 75 e9    JSR Scroll_Screen 
ea00 a6 f2       LDX SCROWM        ; get screen row marker
ea02 ca          DEX               ; decrement screen row marker
ea03 c6 d6       DEC TBLX          ; decrement cursor row
ea05 4c 0e e7    JMP Expand_Logical_Line

ea08          InsL_20
ea08 a5 ac       LDA SAL           ; copy tape buffer pointer
ea0a 48          PHA               ; save it
ea0b a5 ad       LDA SAL+1         ; copy tape buffer pointer
ea0d 48          PHA               ; save it
ea0e a5 ae       LDA EAL           ; copy tape buffer end pointer
ea10 48          PHA               ; save it
ea11 a5 af       LDA EAL+1         ; copy tape buffer end pointer
ea13 48          PHA               ; save it
ea14 a2 17       LDX #ROWS         ; set to end line + 1 for predecrement loop

ea16          InsL_30
ea16 ca          DEX               ; decrement line number
ea17 20 7e ea    JSR Start_Of_Line
ea1a e4 f2       CPX SCROWM        ; compare with screen row marker
ea1c 90 0e       BCC InsL_40       ; branch if < screen row marker
ea1e f0 0c       BEQ InsL_40       ; branch if = screen row marker
ea20 bd fc ed    LDA Line_Adress_Low-1,X  ; else get start of previous line low byte from ROM table
ea23 85 ac       STA SAL           ; save previous line pointer low byte
ea25 b5 d8       LDA SLLTBL-1,X    ; get start of previous line pointer high byte
ea27 20 56 ea    JSR Shift_Row
ea2a 30 ea       BMI InsL_30       ; loop, branch always

ea2c          InsL_40
ea2c 20 8d ea    JSR Clear_Screen_Row_X
ea2f a2 15       LDX #ROWS-2

ea31          InsL_50
ea31 e4 f2       CPX SCROWM        ;.compare with screen row marker
ea33 90 0f       BCC InsL_70
ea35 b5 da       LDA SLLTBL+1,X
ea37 29 7f       AND #$7F
ea39 b4 d9       LDY SLLTBL,X
ea3b 10 02       BPL InsL_60
ea3d 09 80       ORA #$80

ea3f          InsL_60
ea3f 95 da       STA SLLTBL+1,X
ea41 ca          DEX
ea42 d0 ed       BNE InsL_50

ea44          InsL_70
ea44 a6 f2       LDX SCROWM        ;.get screen row marker
ea46 20 0e e7    JSR Expand_Logical_Line

0001 FALSE    #if C64
SKIP             JMP ScSc_45
              #endif
0000 TRUE     #if VIC
ea49 68          PLA               ; pull tape buffer end pointer
ea4a 85 af       STA EAL+1         ; restore it
ea4c 68          PLA               ; pull tape buffer end pointer
ea4d 85 ae       STA EAL           ; restore it
ea4f 68          PLA               ; pull tape buffer pointer
ea50 85 ad       STA SAL+1         ; restore it
ea52 68          PLA               ; pull tape buffer pointer
ea53 85 ac       STA SAL           ; restore it
ea55 60          RTS ;Size  104 [Insert_Line]
              #endif

              ; *********
ea56            Shift_Row
              ; *********

ea56 29 03       AND #$03          ; mask 0000 00xx, line memory page
ea58 0d 88 02    ORA SCNMPG        ; OR with screen memory page
ea5b 85 ad       STA SAL+1         ; save next/previous line pointer high byte
ea5d 20 6e ea    JSR Update_Color_RAM_Pointer

ea60          ShRo_10
ea60 a0 15       LDY #COLS-1       ; set column count

ea62          ShRo_20
ea62 b1 ac       LDA (SAL),Y       ; get character from next/previous screen line
ea64 91 d1       STA (LINPTR),Y    ; save character to current screen line
ea66 b1 ae       LDA (EAL),Y       ; get colour from next/previous screen line colour RAM
ea68 91 f3       STA (USER),Y      ; save colour to current screen line colour RAM
ea6a 88          DEY               ; decrement column index/count
ea6b 10 f5       BPL ShRo_20
ea6d 60          RTS ;Size   24 [Shift_Row]

              ; ************************
ea6e            Update_Color_RAM_Pointer
              ; ************************

ea6e 20 b2 ea    JSR Set_COLRAM_Pointer
ea71 a5 ac       LDA SAL
ea73 85 ae       STA EAL
ea75 a5 ad       LDA SAL+1
ea77 29 03       AND #$03
0001 FALSE    #if C64
SKIP             ORA #$D8          ; C64 color RAM = $D800
              #endif
0000 TRUE     #if VIC
ea79 09 94       ORA #$94          ; VIC color RAM = $9400
              #endif
ea7b 85 af       STA EAL+1
ea7d 60          RTS ;Size   16 [Update_Color_RAM_Pointer]

              ; *************
ea7e            Start_Of_Line
              ; *************

ea7e bd fd ed    LDA Line_Adress_Low,X
ea81 85 d1       STA LINPTR        ; set current screen line pointer low byte
ea83 b5 d9       LDA SLLTBL,X      ; get start of line high byte from RAM table
ea85 29 03       AND #$03          ; mask 0000 00xx, line memory page
ea87 0d 88 02    ORA SCNMPG        ; OR with screen memory page
ea8a 85 d2       STA LINPTR+1      ; set current screen line pointer high byte
ea8c 60          RTS ;Size   15 [Start_Of_Line]

              ; ******************
ea8d            Clear_Screen_Row_X
              ; ******************

ea8d a0 15       LDY #COLS-1       ; set number of columns to clear
ea8f 20 7e ea    JSR Start_Of_Line
ea92 20 b2 ea    JSR Set_COLRAM_Pointer

ea95          CSRX_Loop
0001 FALSE    #if C64
SKIP             JSR STA_COLOR
              #endif
ea95 a9 20       LDA #' '          ; set [SPACE]
ea97 91 d1       STA (LINPTR),Y    ; clear character in current screen line
0000 TRUE     #if VIC
ea99 a9 01       LDA #1            ; set colour, blue on white
ea9b 91 f3       STA (USER),Y      ; set colour RAM in current screen line
              #endif
ea9d 88          DEY
ea9e 10 f5       BPL CSRX_Loop
eaa0 60          RTS ;Size   20 [Clear_Screen_Row_X]


0001 FALSE    #if C64
SKIP             NOP
              #endif

              ; **************************
eaa1            Display_Char_A_And_Color_X
              ; **************************

eaa1 a8          TAY               ; copy character
eaa2 a9 02       LDA #$02          ; set count to $02, usually $14 ??
eaa4 85 cd       STA BLNCT         ; set cursor countdown
eaa6 20 b2 ea    JSR Set_COLRAM_Pointer
eaa9 98          TYA               ; get character back

              ; **********************
eaaa            Display_Char_And_Color
              ; **********************

eaaa a4 d3       LDY CSRIDX        ; get cursor column
eaac 91 d1       STA (LINPTR),Y    ; save character from current screen line
eaae 8a          TXA               ; copy colour to A
eaaf 91 f3       STA (USER),Y      ; save to colour RAM
eab1 60          RTS ;Size    8 [Display_Char_And_Color]

              ; ******************
eab2            Set_COLRAM_Pointer
              ; ******************

eab2 a5 d1       LDA LINPTR        ; get current screen line pointer low byte
eab4 85 f3       STA USER          ; save pointer to colour RAM low byte
eab6 a5 d2       LDA LINPTR+1      ; get current screen line pointer high byte
eab8 29 03       AND #$03          ; mask 0000 00xx, line memory page
eaba 09 94       ORA #COLRAM_PAGE  ; set  1001 01xx, colour memory page
eabc 85 f4       STA USER+1        ; save pointer to colour RAM high byte
eabe 60          RTS ;Size   13 [Set_COLRAM_Pointer]

              ; ***********
eabf            Default_IRQ
              ; ***********

eabf 20 ea ff    JSR UDTIM         ; Update the system clock
eac2 a5 cc       LDA BLNSW         ; get cursor enable
eac4 d0 29       BNE DIRQ_20       ; branch if not flash cursor
eac6 c6 cd       DEC BLNCT         ; else decrement cursor timing countdown
eac8 d0 25       BNE DIRQ_20       ; branch if not done
eaca a9 14       LDA #$14          ; set count
eacc 85 cd       STA BLNCT         ; save cursor timing countdown
eace a4 d3       LDY CSRIDX        ; get cursor column
ead0 46 cf       LSR BLNON         ; shift b0 cursor blink phase into carry
ead2 ae 87 02    LDX CSRCLR        ; get colour under cursor
ead5 b1 d1       LDA (LINPTR),Y    ; get character from current screen line
ead7 b0 11       BCS DIRQ_10       ; branch if cursor phase b0 was 1
ead9 e6 cf       INC BLNON         ; set cursor blink phase to 1
eadb 85 ce       STA GDBLN         ; save character under cursor
eadd 20 b2 ea    JSR Set_COLRAM_Pointer
eae0 b1 f3       LDA (USER),Y      ; get colour RAM byte
eae2 8d 87 02    STA CSRCLR        ; save colour under cursor
eae5 ae 86 02    LDX COLOR         ; get current colour code
eae8 a5 ce       LDA GDBLN         ; get character under cursor

eaea          DIRQ_10
eaea 49 80       EOR #$80          ; toggle b7 of character under cursor
eaec 20 aa ea    JSR Display_Char_And_Color

eaef          DIRQ_20
0001 FALSE    #if JIFFY
SKIP             JMP DIRQ_50
SKIP          
SKIP          ; **************
SKIP            Jiffy_Tokenize
SKIP          ; **************
SKIP          
SKIP             PLA   
SKIP             PHA   
SKIP             CMP #<[Direct_Call+2]  ; called from direct mode
SKIP             BEQ JiTo_20 
SKIP          
SKIP          JiTo_10
SKIP             JMP Default_Tokenize
SKIP          
SKIP          JiTo_20
SKIP             JSR Jiffy_Test_Command 
SKIP             BNE JiTo_10 
SKIP             LDX TXTPTR
SKIP             LDY #4
SKIP             TYA   
SKIP             JMP Toke_REM
0001 FALSE    #if C64
SKIP             .byte 1
              #endif
SKIP          
0000 TRUE     #if VIC
SKIP          Jiffy_eb08
SKIP             JSR JiDi_60
SKIP             JMP PrSe_10
SKIP             .byte $03  
SKIP             STA VIA1_PCR
              #endif
SKIP          
SKIP          
              #else

0001 FALSE    #if C64
SKIP             LDA R6510
SKIP             AND #$10          ; mask cassette switch sense
              #endif
0000 TRUE     #if VIC
eaef ad 1f 91    LDA IEC_DRAN      ; get VIA 1 DRA, no handshake
eaf2 29 40       AND #$40          ; mask cassette switch sense
              #endif

eaf4 f0 0b       BEQ DIRQ_30      ; branch if cassette sense low
eaf6 a0 00       LDY #0
eaf8 84 c0       STY CAS1          ; clear the tape motor interlock

0001 FALSE    #if C64
SKIP             LDA R6510
SKIP             ORA #$20          ; set CA2 high, turn off motor
              #endif
0000 TRUE     #if VIC
eafa ad 1c 91    LDA VIA1_PCR      ; get VIA 1 PCR
eafd 09 02       ORA #$02          ; set CA2 high, turn off motor
              #endif

eaff d0 09       BNE DIRQ_40      ; branch always

eb01          DIRQ_30
eb01 a5 c0       LDA CAS1          ; get tape motor interlock
eb03 d0 0d       BNE DIRQ_50      ; if cassette interlock <> 0 don't turn on motor

0001 FALSE    #if C64
SKIP             LDA $01           ; R6510
SKIP             AND #$1F          ; turn on motor
              #endif
0000 TRUE     #if VIC
eb05 ad 1c 91    LDA VIA1_PCR      ; get VIA 1 PCR
eb08 29 fd       AND #$FD          ; set CA2 low, turn on motor
              #endif

eb0a          DIRQ_40

0001 FALSE    #if C64
SKIP             STA R6510
              #endif
0000 TRUE     #if VIC
eb0a 2c 1e 91    BIT VIA1_IER      ; test VIA 1 IER
eb0d 70 03       BVS DIRQ_50       ; if T1 interrupt enabled don't change motor state
eb0f 8d 1c 91    STA VIA1_PCR      ; set VIA 1 PCR, set CA2 high/low
              #endif

              #endif               ; JIFFY

eb12          DIRQ_50
eb12 20 1e eb    JSR Kernal_SCNKEY ; scan keyboard

0001 FALSE    #if C64
SKIP             LDA CIA1_ICR      ; CIA1 Interrupt Control Register
              #endif
0000 TRUE     #if VIC
eb15 2c 24 91    BIT VIA2_T1CL     ; clear the timer interrupt flag
              #endif

eb18 68          PLA
eb19 a8          TAY
eb1a 68          PLA
eb1b aa          TAX
eb1c 68          PLA
eb1d 40          RTI

              ; *************
eb1e            Kernal_SCNKEY
              ; *************

              ; 1) check if key pressed, if not then exit the routine
              ; 2) init I/O ports of VIA 2 for keyboard scan and set pointers to
              ;    decode table 1. clear the character counter
              ; 3) set one line of port B low and test for a closed key on port A by
              ;    shifting the byte read from the port. if the carry is clear then a
              ;    key is closed so save the count which is incremented on each shift.
              ;    check for shift/stop/cbm keys and flag if closed
              ; 4) repeat step 3 for the whole matrix
              ; 5) evaluate the SHIFT/CTRL/C= keys, this may change the decode table
              ;    selected
              ; 6) use the key count saved in step 3 as an index into the table
              ;    selected in step 5
              ; 7) check for key repeat operation
              ; 8) save the decoded key to the buffer if first press or repeat

eb1e a9 00       LDA #0
eb20 8d 8d 02    STA SHFLAG        ; clear keyboard shift/control/c= flag
eb23 a0 40       LDY #$40          ; set no key
eb25 84 cb       STY SFDX          ; save which key
eb27 8d 20 91    STA KEYB_COL      ; clear keyboard column
eb2a ae 21 91    LDX KEYB_ROW      ; get keyboard row
eb2d e0 ff       CPX #$FF          ; compare with all bits set
eb2f f0 5e       BEQ KeSc_50       ; if no key pressed clear current key and exit

0001 FALSE    #if C64
SKIP             TAY               ; clear key count
              #endif
0000 TRUE     #if VIC
eb31 a9 fe       LDA #$FE
eb33 8d 20 91    STA KEYB_COL      ; select keyboard col 0
eb36 a0 00       LDY #0            ; clear key count
              #endif

eb38 a9 5e       LDA #<KBD_NORMAL  ; get decode table low byte
eb3a 85 f5       STA KBDPTR        ; set keyboard pointer low byte
eb3c a9 ec       LDA #>KBD_NORMAL  ; get decode table high byte
eb3e 85 f6       STA KBDPTR+1      ; set keyboard pointer high byte

0001 FALSE    #if C64
SKIP             LDA #$FE
SKIP             STA KEYB_COL      ; select keyboard col 0
              #endif

eb40          KeSc_05
eb40 a2 08       LDX #8            ; set row count

0001 FALSE    #if C64
SKIP             PHA
SKIP          KeSc_10
              #endif

eb42 ad 21 91    LDA KEYB_ROW      ; get VIA/CIA keyboard row
eb45 cd 21 91    CMP KEYB_ROW      ; compare with itself

0001 FALSE    #if C64
SKIP             BNE KeSc_10       ; loop if changing
              #endif
0000 TRUE     #if VIC
eb48 d0 f6       BNE KeSc_05      ; loop if changing
              #endif

eb4a          KeSc_15
eb4a 4a          LSR A             ; shift row to Cb
eb4b b0 16       BCS KeSc_30       ; if no key closed on this row go do next row
eb4d 48          PHA               ; save row
eb4e b1 f5       LDA (KBDPTR),Y    ; get character from decode table
eb50 c9 05       CMP #$05          ; compare with $05, there is no $05 key but the control
eb52 b0 0c       BCS KeSc_20       ; if not shift/control/c=/stop go save key count
eb54 c9 03       CMP #$03          ; compare with $03, stop
eb56 f0 08       BEQ KeSc_20       ; if stop go save key count and continue
eb58 0d 8d 02    ORA SHFLAG        ; OR keyboard shift/control/c= flag
eb5b 8d 8d 02    STA SHFLAG        ; save keyboard shift/control/c= flag
eb5e 10 02       BPL KeSc_25       ; skip save key, branch always

eb60          KeSc_20
eb60 84 cb       STY SFDX          ; save key count

eb62          KeSc_25
eb62 68          PLA               ; restore row

eb63          KeSc_30
eb63 c8          INY               ; increment key count
eb64 c0 41       CPY #$41          ; compare with max+1
eb66 b0 09       BCS KeSc_35       ; exit loop if >= max+1
eb68 ca          DEX               ; decrement row count
eb69 d0 df       BNE KeSc_15       ; loop if more rows to do
eb6b 38          SEC               ; set carry for keyboard column shift

0001 FALSE    #if C64
SKIP             PLA
SKIP             ROL A
SKIP             STA KEYB_COL   
              #endif
0000 TRUE     #if VIC
eb6c 2e 20 91    ROL KEYB_COL      ; shift VIA 2 DRB, keyboard column
              #endif

eb6f d0 cf       BNE KeSc_05      ; loop for next column, branch always

eb71          KeSc_35
0001 FALSE    #if C64
SKIP             PLA
              #endif

eb71 6c 8f 02    JMP (KEYLOG)      ; normally Keyboard_Decoder

              ; key decoding continues here after the SHIFT/CTRL/C= keys are evaluated

eb74          KeSc_40
eb74 a4 cb       LDY SFDX          ; get saved key count
eb76 b1 f5       LDA (KBDPTR),Y    ; get character from decode table
eb78 aa          TAX               ; copy character to X
eb79 c4 c5       CPY LSTX          ; compare key count with last key count
eb7b f0 07       BEQ KeSc_45       ; if this key = current key, key held, go test repeat
eb7d a0 10       LDY #$10          ; set repeat delay count
eb7f 8c 8c 02    STY KRPTDL        ; save repeat delay count
eb82 d0 36       BNE KeSc_65       ; go save key to buffer and exit, branch always

eb84          KeSc_45
eb84 29 7f       AND #$7F          ; clear b7
eb86 2c 8a 02    BIT KEYRPT        ; test key repeat
eb89 30 16       BMI KeSc_55       ; branch if repeat all
eb8b 70 49       BVS KeSc_70       ; branch if repeat none
eb8d c9 7f       CMP #$7F          ; compare with end marker

eb8f          KeSc_50
eb8f f0 29       BEQ KeSc_65       ; if $00/end marker go save key to buffer and exit
eb91 c9 14       CMP #$14          ; compare with [INSERT]/[DELETE]
eb93 f0 0c       BEQ KeSc_55       ; if [INSERT]/[DELETE] go test for repeat
eb95 c9 20       CMP #' '          ; compare with [SPACE]
eb97 f0 08       BEQ KeSc_55       ; if [SPACE] go test for repeat
eb99 c9 1d       CMP #$1D          ; compare with [CURSOR RIGHT]
eb9b f0 04       BEQ KeSc_55       ; if [CURSOR RIGHT] go test for repeat
eb9d c9 11       CMP #$11          ; compare with [CURSOR DOWN]
eb9f d0 35       BNE KeSc_70       ; if not [CURSOR DOWN] just exit

eba1          KeSc_55
eba1 ac 8c 02    LDY KRPTDL        ; get repeat delay counter
eba4 f0 05       BEQ KeSc_60       ; branch if delay expired
eba6 ce 8c 02    DEC KRPTDL        ; else decrement repeat delay counter
eba9 d0 2b       BNE KeSc_70       ; branch if delay not expired

ebab          KeSc_60
ebab ce 8b 02    DEC KRPTSP        ; decrement repeat speed counter
ebae d0 26       BNE KeSc_70       ; branch if repeat speed count not expired
ebb0 a0 04       LDY #$04          ; set for 4/60ths of a second
ebb2 8c 8b 02    STY KRPTSP        ; set repeat speed counter
ebb5 a4 c6       LDY NDX           ; get keyboard buffer index
ebb7 88          DEY               ; decrement it
ebb8 10 1c       BPL KeSc_70       ; if the buffer isn't empty just exit

ebba          KeSc_65
ebba a4 cb       LDY SFDX          ; get the key count
ebbc 84 c5       STY LSTX          ; save as the current key count
ebbe ac 8d 02    LDY SHFLAG        ; get keyboard shift/control/c= flag
ebc1 8c 8e 02    STY LSTSHF        ; save as last keyboard shift pattern
ebc4 e0 ff       CPX #$FF          ; compare character with table end marker or no key
ebc6 f0 0e       BEQ KeSc_70       ; if table end marker or no key just exit
ebc8 8a          TXA               ; copy character to A
ebc9 a6 c6       LDX NDX           ; get keyboard buffer index
ebcb ec 89 02    CPX KBMAXL        ; compare with keyboard buffer size
ebce b0 06       BCS KeSc_70       ; if buffer full just exit
ebd0 9d 77 02    STA KBUFFR,X      ; save character to keyboard buffer
ebd3 e8          INX               ; increment index
ebd4 86 c6       STX NDX           ; save keyboard buffer index

ebd6          KeSc_70
ebd6 a9 f7       LDA #STND_COL     ; col 3 on VIC / col 7 on C64
ebd8 8d 20 91    STA KEYB_COL      ; set VIA/CIA keyboard column
ebdb 60          RTS ;Size  190 [Kernal_SCNKEY]

              ; ****************
ebdc            Keyboard_Decoder
              ; ****************

ebdc ad 8d 02    LDA SHFLAG        ; get keyboard shift/control/c= flag
ebdf c9 03       CMP #$03          ; compare with [SHIFT][C=]
ebe1 d0 2c       BNE KeDe_10       ; branch if not
ebe3 cd 8e 02    CMP LSTSHF        ; compare with last
ebe6 f0 ee       BEQ KeSc_70       ; exit if still the same
ebe8 ad 91 02    LDA MODE          ; get shift mode switch $00 = enabled, $80 = locked
ebeb 30 56       BMI KeDe_30       ; if locked continue keyboard decode

0000 TRUE     #if VIC
0000 TRUE     #if !JIFFY
ebed ea ea ea    .fill 19 ($EA)    ; NOP's ; 19 bytes
              #endif
              #endif
                                   ; switch character ROM
0001 FALSE    #if C64
SKIP             LDA MEM_CONTROL   ; get start of character memory, ROM
SKIP             EOR #$02          ; toggle $8000,$8800
SKIP             STA MEM_CONTROL   ; set start of character memory, ROM
              #endif
0000 TRUE     #if VIC
ec00 ad 05 90    LDA VIC_R5        ; get start of character memory, ROM
ec03 49 02       EOR #$02          ; toggle $8000,$8800
ec05 8d 05 90    STA VIC_R5        ; set start of character memory, ROM
0000 TRUE     #if !JIFFY
ec08 ea ea ea    .fill  4 ($EA)    ; NOP's ; 4 bytes
              #endif
              #endif

0001 FALSE    #if VIC & JIFFY
SKIP             JMP KeSc_40       ; continue keyboard decode
              #else
ec0c 4c 43 ec    JMP KeDe_30       ; continue keyboard decode
              #endif

ec0f          KeDe_10
ec0f 0a          ASL A             ; convert flag to index 
ec10 c9 08       CMP #8            ; compare with [CTRL]
ec12 90 04       BCC KeDe_20       ; branch if not [CTRL] pressed
ec14 a9 06       LDA #6            ; [CTRL] : table 3 : index 6
0000 TRUE     #if VIC
0000 TRUE     #if !JIFFY
ec16 ea ea       .fill 2 ($EA)     ; NOP's ; 2 bytes
              #endif
              #endif

ec18          KeDe_20
0000 TRUE     #if VIC
0000 TRUE     #if !JIFFY
ec18 ea ea ea    .fill 32 ($EA)    ; NOP's ; 32 bytes
              #endif
              #endif
ec38 aa          TAX               ; copy index to X
ec39 bd 46 ec    LDA KBD_Decode_Pointer,X
ec3c 85 f5       STA KBDPTR
ec3e bd 47 ec    LDA KBD_Decode_Pointer+1,X
ec41 85 f6       STA KBDPTR+1
ec43          KeDe_30
ec43 4c 74 eb    JMP KeSc_40       ; continue keyboard decode

0001 FALSE    #if VIC & JIFFY
SKIP          KeDe_60
SKIP             LDA #4
SKIP             JSR LISTEN
SKIP             LDA MEM_CONTROL
SKIP             AND #2
SKIP             BEQ KeDe_62
SKIP             LDA #7
SKIP          
SKIP          KeDe_62
SKIP             ORA #$60
SKIP             JSR SECOND
SKIP             LDA CSRIDX
SKIP             PHA
SKIP             LDA TBLX
SKIP             PHA
SKIP             JMP $edaa
SKIP          
SKIP             .fill 15 ($ea)
SKIP          
SKIP             TAX               ; copy index to X
SKIP             LDA KBD_Decode_Pointer,X
SKIP             STA KBDPTR
SKIP             LDA KBD_Decode_Pointer+1,X
SKIP             STA KBDPTR+1
SKIP             JMP KeSc_40       ; continue keyboard decode
SKIP             
              #endif

              ; ==================
ec46            KBD_Decode_Pointer
              ; ==================

ec46 5e ec       .word   KBD_NORMAL  ; 0   normal
ec48 9f ec       .word   KBD_SHIFTED ; 1   shifted
ec4a e0 ec       .word   KBD_CBMKEY  ; 2   commodore
0001 FALSE    #if VIC & JIFFY
SKIP             .word   KBD_COMMCON ; 6   commodore control
              #else
ec4c a3 ed       .word   KBD_CONTROL ; 3   control
              #endif

0000 TRUE     #if VIC
0001 FALSE    #if JIFFY
SKIP          Jiffy_Combine_Nibbles
SKIP             LDA TAPE1+1
SKIP             AND #15
SKIP             STA TAPE1+1
SKIP             LDA CAS1
SKIP             ASL A
SKIP             ASL A
SKIP             ASL A
SKIP             ASL A
SKIP             ORA TAPE1+1
SKIP             RTS
SKIP             .byte $ed
              #else
ec4e 5e ec       .word   KBD_NORMAL  ; 4   control
ec50 9f ec       .word   KBD_SHIFTED ; 5   shift - control
ec52 69 ed       .word   KBD_COMMCON ; 6   commodore control
ec54 a3 ed       .word   KBD_CONTROL ; 7   shift - commdore - control
ec56 21 ed       .word   Switch_Text_Graphics    ; 8   unused
ec58 69 ed       .word   KBD_COMMCON ; 9   unused
ec5a 69 ed       .word   KBD_COMMCON ; a   unused
ec5c a3 ed       .word   KBD_CONTROL ; b   unused
              #endif
              #endif


ec5e          KBD_NORMAL           ; keyboard decode table - unshifted

0001 FALSE    #if C64
SKIP             .BYTE $14,$0d,$1d,$88,$85,$86,$87,$11
SKIP             .BYTE $33,$57,$41,$34,$5a,$53,$45,$01
SKIP             .BYTE $35,$52,$44,$36,$43,$46,$54,$58
SKIP             .BYTE $37,$59,$47,$38,$42,$48,$55,$56
SKIP             .BYTE $39,$49,$4a,$30,$4d,$4b,$4f,$4e
SKIP             .BYTE $2b,$50,$4c,$2d,$2e,$3a,$40,$2c
SKIP             .BYTE $5c,$2a,$3b,$13,$01,$3d,$5e,$2f
SKIP             .BYTE $31,$5f,$04,$32,$20,$02,$51,$03
SKIP             .BYTE $ff
              #endif

0000 TRUE     #if VIC
ec5e 31 33 35    .byte $31,$33,$35,$37,$39,$2B,$5C,$14
ec66 5f 57 52    .byte $5F,$57,$52,$59,$49,$50,$2A,$0D
ec6e 04 41 44    .byte $04,$41,$44,$47,$4A,$4C,$3B,$1D
ec76 03 01 58    .byte $03,$01,$58,$56,$4E,$2C,$2F,$11
ec7e 20 5a 43    .byte $20,$5A,$43,$42,$4D,$2E,$01,$85
ec86 02 53 46    .byte $02,$53,$46,$48,$4B,$3A,$3D,$86
ec8e 51 45 54    .byte $51,$45,$54,$55,$4F,$40,$5E,$87
ec96 32 34 36    .byte $32,$34,$36,$38,$30,$2D,$13,$88
ec9e ff          .byte $FF
              #endif

ec9f          KBD_SHIFTED          ; keyboard decode table - shifted

0001 FALSE    #if C64
SKIP             .BYTE $94,$8d,$9d,$8c,$89,$8a,$8b,$91
SKIP             .BYTE $23,$d7,$c1,$24,$da,$d3,$c5,$01
SKIP             .BYTE $25,$d2,$c4,$26,$c3,$c6,$d4,$d8
SKIP             .BYTE $27,$d9,$c7,$28,$c2,$c8,$d5,$d6
SKIP             .BYTE $29,$c9,$ca,$30,$cd,$cb,$cf,$ce
SKIP             .BYTE $db,$d0,$cc,$dd,$3e,$5b,$ba,$3c
SKIP             .BYTE $a9,$c0,$5d,$93,$01,$3d,$de,$3f
SKIP             .BYTE $21,$5f,$04,$22,$a0,$02,$d1,$83
SKIP             .BYTE $ff
              #endif

0000 TRUE     #if VIC
ec9f 21 23 25    .byte $21,$23,$25,$27,$29,$DB,$A9,$94
eca7 5f d7 d2    .byte $5F,$D7,$D2,$D9,$C9,$D0,$C0,$8D
ecaf 04 c1 c4    .byte $04,$C1,$C4,$C7,$CA,$CC,$5D,$9D
ecb7 83 01 d8    .byte $83,$01,$D8,$D6,$CE,$3C,$3F,$91
ecbf a0 da c3    .byte $A0,$DA,$C3,$C2,$CD,$3E,$01,$89
ecc7 02 d3 c6    .byte $02,$D3,$C6,$C8,$CB,$5B,$3D,$8A
eccf d1 c5 d4    .byte $D1,$C5,$D4,$D5,$CF,$BA,$DE,$8B
ecd7 22 24 26    .byte $22,$24,$26,$28,$30,$DD,$93,$8C
ecdf ff          .byte $FF
              #endif

ece0          KBD_CBMKEY           ; keyboard decode table - commodore

0001 FALSE    #if C64
SKIP             .BYTE $94,$8d,$9d,$8c,$89,$8a,$8b,$91
SKIP             .BYTE $96,$b3,$b0,$97,$ad,$ae,$b1,$01
SKIP             .BYTE $98,$b2,$ac,$99,$bc,$bb,$a3,$bd
SKIP             .BYTE $9a,$b7,$a5,$9b,$bf,$b4,$b8,$be
SKIP             .BYTE $29,$a2,$b5,$30,$a7,$a1,$b9,$aa
SKIP             .BYTE $a6,$af,$b6,$dc,$3e,$5b,$a4,$3c
SKIP             .BYTE $a8,$df,$5d,$93,$01,$3d,$de,$3f
SKIP             .BYTE $81,$5f,$04,$95,$a0,$02,$ab,$83
SKIP             .BYTE $ff
              #endif

0000 TRUE     #if VIC
ece0 21 23 25    .byte $21,$23,$25,$27,$29,$A6,$A8,$94
ece8 5f b3 b2    .byte $5F,$B3,$B2,$B7,$A2,$AF,$DF,$8D
ecf0 04 b0 ac    .byte $04,$B0,$AC,$A5,$B5,$B6,$5D,$9D
ecf8 83 01 bd    .byte $83,$01,$BD,$BE,$AA,$3C,$3F,$91
ed00 a0 ad bc    .byte $A0,$AD,$BC,$BF,$A7,$3E,$01,$89
ed08 02 ae bb    .byte $02,$AE,$BB,$B4,$A1,$5B,$3D,$8A
ed10 ab b1 a3    .byte $AB,$B1,$A3,$B8,$B9,$A4,$DE,$8B
ed18 22 24 26    .byte $22,$24,$26,$28,$30,$DC,$93,$8C
ed20 ff          .byte $FF
              #endif

              ; ====================
ed21            Switch_Text_Graphics
              ; ====================

ed21 c9 0e       CMP #$0E          ; compare with [SWITCH TO LOWER CASE]
ed23 d0 0b       BNE STG_10        ; branch if not [SWITCH TO LOWER CASE]

0001 FALSE    #if C64
SKIP             LDA MEM_CONTROL
SKIP             ORA #2
SKIP             BNE STG_20
              #endif
0000 TRUE     #if VIC
ed25 a9 02       LDA #$02          ; set for $8800, lower case characters
ed27 0d 05 90    ORA MEM_CONTROL   ; OR with start of character memory, ROM
ed2a 8d 05 90    STA MEM_CONTROL   ; save start of character memory, ROM
ed2d 4c dc e6    JMP InsC_50       ; restore registers, set quote flag and exit
              #endif

ed30          STG_10
ed30 c9 8e       CMP #$8E          ; compare with [SWITCH TO UPPER CASE]
ed32 d0 0b       BNE STG_40        ; branch if not [SWITCH TO UPPER CASE]

0001 FALSE    #if C64
SKIP             LDA MEM_CONTROL
SKIP             AND #$FD
              #endif
0000 TRUE     #if VIC
ed34 a9 fd       LDA #$FD          ; set for $8000, upper case characters
ed36 2d 05 90    AND MEM_CONTROL   ; AND with start of character memory, ROM
              #endif

ed39          STG_20
ed39 8d 05 90    STA MEM_CONTROL   ; save start of character memory, ROM

ed3c          STG_30
ed3c 4c dc e6    JMP InsC_50       ; restore registers, set quote flag and exit

ed3f          STG_40
ed3f c9 08       CMP #$08          ; compare with disable [SHIFT][C=]
ed41 d0 0a       BNE STG_50        ; branch if not disable [SHIFT][C=]
ed43 a9 80       LDA #$80          ; set to lock shift mode switch
ed45 0d 91 02    ORA MODE          ; OR with shift mode switch, $00 = enabled, $80 = locked

0001 FALSE    #if C64
SKIP             BMI STG_60
              #endif
0000 TRUE     #if VIC
ed48 8d 91 02    STA MODE          ; save shift mode switch
ed4b 30 ef       BMI STG_30        ; branch always
              #endif

ed4d          STG_50
ed4d c9 09       CMP #$09          ; compare with enable [SHIFT][C=]
ed4f d0 eb       BNE STG_30        ; exit if not enable [SHIFT][C=]    ##### start ####
ed51 a9 7f       LDA #$7F          ; set to unlock shift mode switch
ed53 2d 91 02    AND MODE          ; AND with shift mode switch, $00 = enabled, $80 = locked

ed56          STG_60
ed56 8d 91 02    STA MODE          ; save shift mode switch

0001 FALSE    #if C64
SKIP             JMP InsC_50
              #endif
0000 TRUE     #if VIC

ed59 10 e1       BPL STG_30        ; branch always

              ; VC-20 patch for "Expand Logical Line": make next screen line start of
              ; logical line, increment line length and set pointers

ed5b          ELL_10
ed5b e8          INX               ; increment screen row
ed5c b5 d9       LDA SLLTBL,X      ; get start of line X pointer high byte
ed5e 09 80       ORA #$80          ; mark as start of logical line
ed60 95 d9       STA SLLTBL,X      ; set start of line X pointer high byte
ed62 ca          DEX               ; restore screen row
ed63 a5 d5       LDA LINLEN        ; get current screen line length
ed65 18          CLC
ed66 4c 15 e7    JMP ELL_20      ; add one line length, set pointers for start of line and
                                   ; return
              #endif

0001 FALSE    #if C64
SKIP          
SKIP          KBD_CONTROL          ; keyboard decode table - control
SKIP          
SKIP            .BYTE $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff
SKIP            .BYTE $1c,$17,$01,$9f,$1a,$13,$05,$ff
SKIP            .BYTE $9c,$12,$04,$1e,$03,$06,$14,$18
SKIP            .BYTE $1f,$19,$07,$9e,$02,$08,$15,$16
SKIP            .BYTE $12,$09,$0a,$92,$0d,$0b,$0f,$0e
SKIP            .BYTE $ff,$10,$0c,$ff,$ff,$1b,$00,$ff
SKIP            .BYTE $1c,$ff,$1d,$ff,$ff,$1f,$1e,$ff
SKIP            .BYTE $90,$06,$ff,$05,$ff,$ff,$11,$ff
SKIP            .BYTE $ff
SKIP          
SKIP          VIC_INIT             ; initialise VIC registers
SKIP          
SKIP             .BYTE $00,$00,$00,$00,$00,$00,$00,$00
SKIP             .BYTE $00,$00,$00,$00,$00,$00,$00,$00
SKIP             .BYTE $00,$9b,$37,$00,$00,$00,$08,$00
SKIP             .BYTE $14,$0f,$00,$00,$00,$00,$00,$00
SKIP             .BYTE $0e,$06,$01,$02,$03,$04,$00,$01
SKIP             .BYTE $02,$03,$04,$05,$06,$07
              #endif

0000 TRUE     #if VIC
ed69          KBD_COMMCON         ; keyboard decode table - cbm - control
0001 FALSE    #if JIFFY
SKIP          
SKIP             .byte $90,$1c,$9c,$1f,$12,$ff,$1c,$ff
SKIP             .byte $06,$17,$12,$19,$09,$10,$ff,$ff
SKIP             .byte $ff,$01,$04,$07,$0a,$0c,$1d,$ff
SKIP             .byte $ff,$ff,$18,$16,$0e,$ff,$ff,$ff
SKIP             .byte $ff,$1a,$03,$02,$0d,$ff,$ff,$ff
SKIP             .byte $ff,$13,$06,$08,$0b,$1b,$1f,$ff
SKIP             .byte $11,$05,$14,$15,$0f,$00,$1e,$ff
SKIP             .byte $05,$9f,$1e,$9e,$92,$ff,$ff,$ff
SKIP             .byte $ff
SKIP          
SKIP          JAAA
SKIP             LDY #0
SKIP             STY CSRMOD
SKIP             JSR PLOT_05
SKIP             INC LINLEN
SKIP          
SKIP          JAAA_10
SKIP             JSR CHRI_07
SKIP             JSR Kernal_CIOUT
SKIP             CMP #13
SKIP             BNE JAAA_10
SKIP             INX
SKIP             CPX #$17
SKIP             BCS JAAA_20
SKIP             ASL LINLEN
SKIP             BPL JAAA
SKIP             INX
SKIP             BNE JAAA
SKIP          
SKIP          JAAA_20
SKIP             JSR UNLSN
SKIP             PLA
SKIP             TAX
SKIP             PLA
SKIP             TAY
SKIP             JSR PLOT_05
SKIP          
SKIP          JAAA_30
SKIP             PLA
SKIP          
SKIP          JAAA_40
SKIP             RTS
              #else
ed69 ff ff ff    .byte   $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
ed71 ff 04 ff    .byte   $FF,$04,$FF,$FF,$FF,$FF,$FF,$E2
ed79 9d 83 01    .byte   $9D,$83,$01,$FF,$FF,$FF,$FF,$FF
ed81 91 a0 ff    .byte   $91,$A0,$FF,$FF,$FF,$FF,$EE,$01
ed89 89 02 ff    .byte   $89,$02,$FF,$FF,$FF,$FF,$E1,$FD
ed91 8a ff ff    .byte   $8A,$FF,$FF,$FF,$FF,$FF,$B0,$E0
ed99 8b f2 f4    .byte   $8B,$F2,$F4,$F6,$FF,$F0,$ED,$93
eda1 8c ff       .byte   $8C,$FF

eda3          KBD_CONTROL          ; keyboard decode table - control

eda3 90 1c 9c    .byte   $90,$1C,$9C,$1F,$12,$FF,$FF,$FF
edab 06 ff 12    .byte   $06,$FF,$12,$FF,$FF,$FF,$FF,$FF
edb3 ff ff ff    .byte   $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
edbb ff ff ff    .byte   $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
edc3 ff ff ff    .byte   $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
edcb ff ff ff    .byte   $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
edd3 ff ff       .byte   $FF,$FF
              #endif

edd5 ff ff ff    .byte $FF,$FF,$FF,$FF,$FF,$FF,$05
eddc 9f 1e 9e    .byte $9F,$1E,$9E,$92,$FF,$FF,$FF,$FF

ede4          VIC_INIT             ; initial values for VIC registers

0001 FALSE    #if PAL
SKIP             .byte   $0C       ; horizontal offset [PAL]
SKIP             .byte   $26       ; vertical origin [PAL]
              #else
ede4 05          .byte   $05       ; horizontal offset [NTSC]
ede5 19          .byte   $19       ; vertical origin [NTSC]
              #endif

ede6 16          .byte   $16       ; video address and colums, $9400 for colour RAM
                                   ; bit   function
                                   ; ---   --------
                                   ;  7   video address va9
                                   ; 6-0   number of columns
ede7 2e          .byte   $2E       ; rows and character size
                                   ; bit   function
                                   ; ---   --------
                                   ;  7   b9 raster line
                                   ; 6-1   number of rows
                                   ;  0   8x16 / 8x8 characters
ede8 00          .byte   $00       ; raster line
ede9 c0          .byte   $C0       ; video memory addresses, RAM $1000, ROM $8000
                                   ; bit   function
                                   ; ---   --------
                                   ;  7   must be 1
                                   ; 6-4   video memory address va12-va10
                                   ; 3-0   character memory start address

                                   ; 0000 ROM   $8000   set 1 - we use this
                                   ; 0001  "   $8400
                                   ; 0010  "   $8800 set 2
                                   ; 0011  "   $8C00
                                   ; 1100 RAM   $1000
                                   ; 1101  "   $1400
                                   ; 1110  "   $1800
                                   ; 1111  "   $1C00

edea 00          .byte   $00       ; light pen horizontal position
edeb 00          .byte   $00       ; light pen vertical position

edec 00          .byte   $00       ; paddle X
eded 00          .byte   $00       ; paddle Y
edee 00          .byte   $00       ; oscillator 1 frequency
edef 00          .byte   $00       ; oscillator 2 frequency
edf0 00          .byte   $00       ; oscillator 3 frequency
edf1 00          .byte   $00       ; noise source frequency
edf2 00          .byte   $00       ; aux colour and volume
                                   ; bit   function
                                   ; ---   --------
                                   ; 7-4   auxiliary colour information
                                   ; 3-0   volume
edf3 1b          .byte   $1B       ; screen and border colour
                                   ; bit   function
                                   ; ---   --------
                                   ; 7-4   background colour
                                   ;  3   inverted or normal mode
                                   ; 2-0   border colour
              #endif

edf4 4c 4f 41 RUNKEY .byte "LOAD",$0D,"RUN",$0D

              ; ***************
edfd            Line_Adress_Low
              ; ***************

0001 FALSE    #if C64
SKIP             .byte $00,$28,$50,$78,$a0,$c8,$f0,$18
SKIP             .byte $40,$68,$90,$b8,$e0,$08,$30,$58
SKIP             .byte $80,$a8,$d0,$f8,$20,$48,$70,$98
SKIP             .byte $c0
              #endif
0000 TRUE     #if VIC
edfd 00 16 2c    .byte $00,$16,$2C,$42,$58,$6E,$84,$9A
ee05 b0 c6 dc    .byte $B0,$C6,$DC,$F2,$08,$1E,$34,$4A
ee0d 60 76 8c    .byte $60,$76,$8C,$A2,$B8,$CE,$E4
              #endif

              ; ***********
ee14            Kernal_TALK
              ; ***********

ee14 09 40       ORA #$40          ; OR with the TALK command
ee16 2c          .byte   $2C       ; skip next 2 bytes

              ; *************
ee17            Kernal_LISTEN
              ; *************

ee17 09 20       ORA #$20          ; OR with the LISTEN command
ee19 20 60 f1    JSR RS232_Stop

              ; *********************
ee1c            IEC_Send_Control_Byte
              ; *********************

ee1c 48          PHA               ; save device address
ee1d 24 94       BIT C3PO          ; test deferred character flag
ee1f 10 0a       BPL ISCB_10       ; branch if no defered character
ee21 38          SEC               ; flag EOI
ee22 66 a3       ROR TSFCNT        ; rotate into EOI flag byte
0001 FALSE    #if JIFFY
SKIP             JSR Jiffy_Send_Byte
              #else
ee24 20 49 ee    JSR IEC_Send_Byte
              #endif
ee27 46 94       LSR C3PO          ; clear deferred character flag
ee29 46 a3       LSR TSFCNT        ; clear EOI flag

ee2b          ISCB_10
ee2b 68          PLA               ; device address OR'ed with command
ee2c 85 95       STA BSOUR         ; save as serial defered character
0001 FALSE    #if C64
SKIP             SEI
              #endif
0001 FALSE    #if JIFFY
SKIP             JSR Jiffy_CLR_DAT
              #else
ee2e 20 a0 e4    JSR CLR_IEC_DAT   ; set IEC data out high (0)
              #endif
ee31 c9 3f       CMP #$3F          ; compare read byte with $3F
ee33 d0 03       BNE ISCB_20       ; branch if not $3F, this branch will always be taken
ee35 20 84 ef    JSR CLR_IEC_CLK   ; set IEC clock out high (0)

ee38          ISCB_20
ee38 ad 1f 91    LDA IEC_DRAN      ; get VIA 1 DRA, no handshake
ee3b 09 80       ORA #IEC_ATN_BIT  ; set IEC ATN low (1)
ee3d 8d 1f 91    STA IEC_DRAN      ; set VIA 1 DRA, no handshake

              ; ***********************
ee40            IEC_Delay_And_Send_Byte
              ; ***********************

0001 FALSE    #if C64
SKIP             SEI
              #endif
ee40 20 8d ef    JSR SET_IEC_CLK   ; set IEC clock out low
ee43 20 a0 e4    JSR CLR_IEC_DAT   ; set IEC data  out high
ee46 20 96 ef    JSR WAIT_1MS      ; 1ms delay

              ; *************
ee49            IEC_Send_Byte
              ; *************

ee49 78          SEI               ; disable interrupts
ee4a 20 a0 e4    JSR CLR_IEC_DAT   ; set serial data out high
ee4d 20 b2 e4    JSR GET_IEC_CLK   ; get serial clock status
0000 TRUE     #if VIC
ee50 4a          LSR A             ; shift serial data to Cb
              #endif
ee51 b0 61       BCS Device_Not_Present
ee53 20 84 ef    JSR CLR_IEC_CLK   ; set serial clock high
ee56 24 a3       BIT TSFCNT        ; test EOI flag
ee58 10 0c       BPL ISCB_50       ; branch if not EOI

              ; I think this is the EOI sequence so the serial clock has been released
              ; and the serial data is being held low by the peripherals. first up
              ; wait for the serial data to rise

ee5a          ISCB_30
ee5a 20 b2 e4    JSR GET_IEC_CLK   ; get serial clock status
0000 TRUE     #if VIC
ee5d 4a          LSR A             ; shift serial data to Cb
              #endif
ee5e 90 fa       BCC ISCB_30       ; loop if data low

              ; now the data is high, EOI is signalled by waiting for at least 200us
              ; without pulling the serial clock line low again. the listener should
              ; respond by pulling the serial data line low

ee60          ISCB_40
ee60 20 b2 e4    JSR GET_IEC_CLK   ; get serial clock status
0000 TRUE     #if VIC
ee63 4a          LSR A             ; shift serial data to Cb
              #endif
ee64 b0 fa       BCS ISCB_40       ; loop if data high

              ; the serial data has gone low ending the EOI sequence, now just wait
              ; for the serial data line to go high again or, if this isn't an EOI
              ; sequence, just wait for the serial data to go high the first time

ee66          ISCB_50
ee66 20 b2 e4    JSR GET_IEC_CLK   ; get serial clock status
0000 TRUE     #if VIC
ee69 4a          LSR A             ; shift serial data to Cb
              #endif
ee6a 90 fa       BCC ISCB_50       ; loop if data low

              ; serial data is high now pull the clock low, preferably within 60us

ee6c 20 8d ef    JSR SET_IEC_CLK   ; set serial clock low

              ; now the Vic has to send the eight bits, LSB first. first it sets the
              ; serial data line to reflect the bit in the byte, then it sets the
              ; serial clock to high. The serial clock is left high for 26 cycles,
              ; 23us on a PAL Vic, before it is again pulled low and the serial data
              ; is allowed high again

              ; The jiffy routine detecs Jiffy devices within the routine
              ; Jiffy_Detect_Device and X=2 

0001 FALSE    #if JIFFY
SKIP             TXA
SKIP             PHA               ; save X
SKIP             LDX #8            ; eight bits to do
SKIP          
SKIP          ISCB_51
0001 FALSE    #if C64
SKIP             PHA               ; waste 7 cycles
SKIP             PLA
SKIP             BIT IEC_DRAN
SKIP             BMI ISCB_52       ; IEC clock low (1) ?
              #endif
0000 TRUE     #if VIC
SKIP             LDA VIA1_DATN
SKIP             AND #2
SKIP             BNE ISCB_52       ; IEC clock low (1) ?
              #endif
SKIP             PLA               ; no
SKIP             TAX               ; restore X
SKIP             JMP IEC_Timeout
SKIP          
SKIP          ISCB_52
SKIP             JSR CLR_IEC_DAT   ; set IEC data high (0)
SKIP             ROR BSOUR         ; rotate bit to send into carry
SKIP             BCS ISCB_54       ; branch if bit = 1
SKIP             JSR SET_IEC_DAT   ; set IEC data low (1)
SKIP          
SKIP          ISCB_54
SKIP             JSR CLR_IEC_CLK   ; set IEC clock high (0)
SKIP             LDA IEC_PCR
0001 FALSE    #if C64
SKIP             AND #$df          ; set data high (0)
SKIP             ORA #$10          ; set clock low (1)
              #endif
0000 TRUE     #if VIC
SKIP             AND #$dd          ; set data high (0)
SKIP             ORA #$02          ; set clock low (1)
              #endif
SKIP             PHP               ; 
SKIP             PHA 
SKIP             JSR Jiffy_Detect_Device
SKIP             PLA
SKIP             PLP
SKIP             DEX 
SKIP             BNE ISCB_51       ; next bit
SKIP             PLA               ; restore X
SKIP             TAX
0000 TRUE     #if VIC
SKIP             NOP
              #endif
              #else
ee6f a9 08       LDA #$08          ; eight bits to do
ee71 85 a5       STA CNTDN         ; set serial bus bit count

ee73          ISCB_60
ee73 ad 1f 91    LDA IEC_DRAN      ; get VIA 1 DRA, no handshake
ee76 cd 1f 91    CMP IEC_DRAN      ; compare with self
ee79 d0 f8       BNE ISCB_60       ; loop if changing

0001 FALSE    #if C64
SKIP             ASL A             ; serial clock to carry
              #endif
0000 TRUE     #if VIC
ee7b 4a          LSR A             ; serial clock to carry
ee7c 4a          LSR A             ; serial data to carry
              #endif
ee7d 90 38       BCC IEC_Timeout
ee7f 66 95       ROR BSOUR         ; rotate transmit byte
ee81 b0 05       BCS ISCB_70       ; branch if bit = 1
ee83 20 a9 e4    JSR SET_IEC_DAT   ; else set serial data out low
ee86 d0 03       BNE ISCB_80       ; branch always

ee88          ISCB_70
ee88 20 a0 e4    JSR CLR_IEC_DAT   ; set serial data out high

ee8b          ISCB_80
ee8b 20 84 ef    JSR CLR_IEC_CLK   ; set serial clock high
ee8e ea          NOP
ee8f ea          NOP
ee90 ea          NOP
ee91 ea          NOP
ee92 ad 2c 91    LDA IEC_PCR       ; get VIA/CIA PCR
ee95 29 df       AND #$DF          ; set CB2 low, serial data out high
ee97 09 02       ORA #IEC_CLK_BIT  ; set CA2 high, serial clock out low
ee99 8d 2c 91    STA IEC_PCR
ee9c c6 a5       DEC CNTDN         ; decrement serial bus bit count
ee9e d0 d3       BNE ISCB_60       ; loop if not all done

              ; now all eight bits have been sent it's up to the peripheral to signal the byte was
              ; received by pulling the serial data low. this should be done within one milisecond

              #endif
eea0 a9 04       LDA #4            ; wait for up to about 1ms
eea2 8d 29 91    STA IEC_TIM_H     ; set VIA/CIA timer high

eea5          ISCB_90
0001 FALSE    #if C64
SKIP             LDA #$19
SKIP             STA CIA1_CRB      ; CIA1 Control Register B
SKIP             LDA CIA1_ICR      ; CIA1 Interrupt Control Register
SKIP          
SKIP          ISCB_95
SKIP             LDA CIA1_ICR      ; CIA1 Interrupt Control Register
SKIP             AND #2
SKIP             BNE IEC_Timeout
SKIP             JSR GET_IEC_CLK   ; get serial clock status
SKIP             BCS ISCB_95
              #endif
0000 TRUE     #if VIC
eea5 ad 2d 91    LDA IEC_IFR       ; get VIA 2 IFR
eea8 29 20       AND #$20          ; mask T2 interrupt
eeaa d0 0b       BNE IEC_Timeout      ; if T2 interrupt do timeout on serial bus
eeac 20 b2 e4    JSR GET_IEC_CLK   ; get serial clock status
eeaf 4a          LSR A             ; shift serial data to Cb
eeb0 b0 f3       BCS ISCB_90       ; if data high go wait some more
              #endif
eeb2 58          CLI
eeb3 60          RTS ;Size  107 [IEC_Send_Byte]

              ; ==================
eeb4            Device_Not_Present
              ; ==================

eeb4 a9 80       LDA #$80          ; error $80, device not present
eeb6 2c          .byte   $2C       ; skip next statement

              ; ===========
eeb7            IEC_Timeout
              ; ===========

eeb7 a9 03       LDA #$03          ; error $03, write timeout

              ; ==============
eeb9            Set_IEC_Status
              ; ==============

eeb9 20 6a fe    JSR Ora_Status
eebc 58          CLI               ; enable interrupts
eebd 18          CLC               ; clear for branch
eebe 90 49       BCC KeUN_10      ; ATN high, delay, clock high then data high, branch always

              ; *************
eec0            Kernal_SECOND
              ; *************

eec0 85 95       STA BSOUR         ; save defered byte
eec2 20 40 ee    JSR IEC_Delay_And_Send_Byte

              ; ************
eec5            IEC_ATN_High
              ; ************

eec5 ad 1f 91    LDA IEC_DRAN      ; get VIA 1 DRA, no handshake
0001 FALSE    #if C64
SKIP             AND #$F7          ; set serial ATN high
              #endif
0000 TRUE     #if VIC
eec8 29 7f       AND #$7F          ; set serial ATN high
              #endif
eeca 8d 1f 91    STA IEC_DRAN      ; set VIA 1 DRA, no handshake
eecd 60          RTS ;Size    9 [IEC_ATN_High]

              ; ***********
eece            Kernal_TKSA
              ; ***********

eece 85 95       STA BSOUR         ; save the secondary address byte to transmit
eed0 20 40 ee    JSR IEC_Delay_And_Send_Byte

              ; ***************
eed3            IEC_Finish_Send
              ; ***************

eed3 78          SEI               ; disable interrupts
eed4 20 a9 e4    JSR SET_IEC_DAT   ; set serial data out low
eed7 20 c5 ee    JSR IEC_ATN_High  ; set serial ATN high
eeda 20 84 ef    JSR CLR_IEC_CLK   ; set serial clock high

eedd          IFS_10
0001 FALSE    #if JIFFY
0001 FALSE    #if C64
SKIP             BIT IEC_DRAN
SKIP             BVS IFS_10
              #else
SKIP             JSR GET_IEC_CLK
SKIP             BCS IFS_10
              #endif
              #else
eedd 20 b2 e4    JSR GET_IEC_CLK   ; get serial clock status
0001 FALSE    #if C64
SKIP             BMI IFS_10        ; branch if clock high
              #endif
0000 TRUE     #if VIC
eee0 b0 fb       BCS IFS_10        ; branch if clock high
              #endif
              #endif               ; JIFFY
eee2 58          CLI               ; enable interrupts
eee3 60          RTS ;Size   17 [IEC_Finish_Send]

              ; ************
eee4            Kernal_CIOUT
              ; ************

eee4 24 94       BIT C3PO          ; test deferred character flag
eee6 30 05       BMI KeCI_10       ; branch if defered character
eee8 38          SEC               ; set carry
eee9 66 94       ROR C3PO          ; shift into deferred character flag
eeeb d0 05       BNE KeCI_20       ; save byte and exit, branch always

eeed          KeCI_10
eeed 48          PHA               ; save byte
0001 FALSE    #if JIFFY
SKIP             JSR Jiffy_Send_Byte
              #else
eeee 20 49 ee    JSR IEC_Send_Byte
              #endif
eef1 68          PLA               ; restore byte

eef2          KeCI_20
eef2 85 95       STA BSOUR         ; save defered byte
eef4 18          CLC               ; flag ok
eef5 60          RTS ;Size   18 [Kernal_CIOUT]

              ; ************
eef6            Kernal_UNTLK
              ; ************

0001 FALSE    #if C64
SKIP             SEI
              #endif
0000 TRUE     #if !JIFFY
eef6 20 8d ef    JSR SET_IEC_CLK
              #endif
eef9 ad 1f 91    LDA IEC_DRAN      ; get VIA 1 DRA, no handshake
eefc 09 80       ORA #IEC_ATN_BIT  ; set serial ATN low
eefe 8d 1f 91    STA IEC_DRAN      ; set VIA 1 DRA, no handshake
0001 FALSE    #if JIFFY
SKIP             JSR SET_IEC_CLK
              #endif
ef01 a9 5f       LDA #$5F          ; set the UNTALK command
ef03 2c          .byte   $2C       ; skip next two bytes

              ; ************
ef04            Kernal_UNLSN
              ; ************

ef04 a9 3f       LDA #$3F          ; set the UNLISTEN command
ef06 20 1c ee    JSR IEC_Send_Control_Byte

ef09          KeUN_10
ef09 20 c5 ee    JSR IEC_ATN_High  ; set serial ATN high

              ; ****************************
ef0c            IEC_Delay_CLK_High_DATA_High
              ; ****************************

ef0c 8a          TXA               ; save device number
0001 FALSE    #if C64
SKIP             LDX #10           ; short delay
              #endif
0000 TRUE     #if VIC
ef0d a2 0b       LDX #11           ; short delay
              #endif
ef0f          IDel_10
ef0f ca          DEX               ; decrement count
ef10 d0 fd       BNE IDel_10       ; loop if not all done
ef12 aa          TAX               ; restore device number
ef13 20 84 ef    JSR CLR_IEC_CLK   ; set serial clock high
ef16 4c a0 e4    JMP CLR_IEC_DAT   ; set serial data out high and return

              ; ************
ef19            Kernal_ACPTR
              ; ************

0001 FALSE    #if JIFFY
SKIP             JMP Jiffy_ACPTR
              #else
ef19 78          SEI               ; disable interrupts
ef1a a9 00       LDA #0
              #endif

ef1c          KeAC_03
ef1c 85 a5       STA CNTDN         ; clear serial bus bit count
ef1e 20 84 ef    JSR CLR_IEC_CLK   ; set serial clock high

ef21          KeAC_05
ef21 20 b2 e4    JSR GET_IEC_CLK   ; get serial clock status
0001 FALSE    #if C64
SKIP             BPL KeAC_05       ; loop while clock low
              #endif
0000 TRUE     #if VIC
ef24 90 fb       BCC KeAC_05       ; loop while clock low
ef26 20 a0 e4    JSR CLR_IEC_DAT   ; set serial data out high
              #endif

ef29          KeAC_10
ef29 a9 01       LDA #$01          ; set timeout count high byte
ef2b 8d 29 91    STA IEC_TIM_H

ef2e          KeAC_15
0001 FALSE    #if C64
SKIP             LDA #$19
SKIP             STA CIA1_CRB      ; CIA1 Control Register B
SKIP             JSR CLR_IEC_DAT   ; set serial data out high
SKIP             LDA CIA1_ICR      ; CIA1 Interrupt Control Register
SKIP          KeAC_20
              #endif

ef2e ad 2d 91    LDA IEC_IFR       ; get VIA 2 IFR
ef31 29 20       AND #IEC_IFR_BIT  ; mask T2 interrupt
ef33 d0 07       BNE KeAC_25       ; branch if T2 interrupt
ef35 20 b2 e4    JSR GET_IEC_CLK   ; get serial clock status

0001 FALSE    #if C64
SKIP             BMI KeAC_20       ; loop if clock high
SKIP             BPL KeAC_35       ; else go se 8 bits to do, branch always
              #endif
0000 TRUE     #if VIC
ef38 b0 f4       BCS KeAC_15       ; loop if clock high
ef3a 90 18       BCC KeAC_35       ; else go se 8 bits to do, branch always
              #endif

ef3c          KeAC_25
ef3c a5 a5       LDA CNTDN         ; get serial bus bit count
ef3e f0 05       BEQ KeAC_30       ; if not already EOI then go flag EOI
ef40 a9 02       LDA #$02          ; error $02, read timeour
ef42 4c b9 ee    JMP Set_IEC_Status

ef45          KeAC_30
ef45 20 a9 e4    JSR SET_IEC_DAT    ; set serial data out low

0001 FALSE    #if C64
SKIP             JSR CLR_IEC_CLK
              #endif
0000 TRUE     #if VIC
ef48 20 0c ef    JSR IEC_Delay_CLK_High_DATA_High      ; 1ms delay, clock high then data high
              #endif
ef4b a9 40       LDA #$40          ; set EOI
ef4d 20 6a fe    JSR Ora_Status
ef50 e6 a5       INC CNTDN         ; increment serial bus bit count, do error on next timeout
ef52 d0 d5       BNE KeAC_10       ; go try again

ef54          KeAC_35
ef54 a9 08       LDA #$08          ; 8 bits to do
ef56 85 a5       STA CNTDN         ; set serial bus bit count

ef58          KeAC_40
ef58 ad 1f 91    LDA IEC_DRAN      ; get VIA 1 DRA, no handshake
ef5b cd 1f 91    CMP IEC_DRAN      ; compare with self
ef5e d0 f8       BNE KeAC_40       ; loop if changing

0001 FALSE    #if C64
SKIP             ASL A             ; serial clock into carry
SKIP             BPL KeAC_40       ; loop while serial clock low
              #endif
0000 TRUE     #if VIC
ef60 4a          LSR A             ; serial clock into carry
ef61 90 f5       BCC KeAC_40       ; loop while serial clock low
ef63 4a          LSR A             ; serial data into carry
              #endif

ef64 66 a4       ROR TBTCNT        ; shift data bit into receive byte
ef66          KeAC_45
ef66 ad 1f 91    LDA IEC_DRAN      ; get VIA 1 DRA, no handshake
ef69 cd 1f 91    CMP IEC_DRAN      ; compare with self
ef6c d0 f8       BNE KeAC_45       ; loop if changing

0001 FALSE    #if C64
SKIP             ASL A             ; serial clock into carry
SKIP             BMI KeAC_45       ; loop while serial clock high
              #endif
0000 TRUE     #if VIC
ef6e 4a          LSR A             ; serial clock into carry
ef6f b0 f5       BCS KeAC_45       ; loop while serial clock high
              #endif

ef71 c6 a5       DEC CNTDN         ; decrement serial bus bit count
ef73 d0 e3       BNE KeAC_40       ; loop if not all done
ef75 20 a9 e4    JSR SET_IEC_DAT   ; set serial data out low

0001 FALSE    #if C64
SKIP             BIT STATUS        ; get serial status byte
SKIP             BVC KeAC_50       ; branch if no error
              #endif
0000 TRUE     #if VIC
ef78 a5 90       LDA STATUS        ; get serial status byte
ef7a f0 03       BEQ KeAC_50       ; branch if no error
              #endif

ef7c 20 0c ef    JSR IEC_Delay_CLK_High_DATA_High

ef7f          KeAC_50
ef7f a5 a4       LDA TBTCNT        ; get receive byte
ef81 58          CLI               ; enable interrupts
ef82 18          CLC
ef83 60          RTS ;Size  107 [Kernal_ACPTR]

              ; ***********
ef84            CLR_IEC_CLK        ; set serial clock high (clear bit)
              ; ***********

ef84 ad 2c 91    LDA IEC_PCR
ef87 29 fd       AND #~IEC_CLK_BIT
ef89 8d 2c 91    STA IEC_PCR
ef8c 60          RTS ;Size    9 [CLR_IEC_CLK]

              ; ***********
ef8d            SET_IEC_CLK        ; set serial clock low (set bit)
              ; ***********

ef8d ad 2c 91    LDA IEC_PCR
ef90 09 02       ORA #IEC_CLK_BIT
ef92 8d 2c 91    STA IEC_PCR
ef95 60          RTS ;Size    9 [SET_IEC_CLK]

0001 FALSE    #if C64
SKIP          
SKIP          ; ***********
SKIP            CLR_IEC_DAT        ; set serial data high (clear bit)
SKIP          ; ***********
SKIP          
SKIP             LDA IEC_PCR
SKIP             AND #~IEC_DAT_BIT
SKIP             STA IEC_PCR
SKIP             RTS
SKIP          
SKIP          ; ***********
SKIP            SET_IEC_DAT        ; set serial data low (set bit)
SKIP          ; ***********
SKIP          
SKIP             LDA IEC_PCR
SKIP             ORA #IEC_DAT_BIT
SKIP             STA IEC_PCR
SKIP             RTS
SKIP          
SKIP          ; ***********
SKIP            GET_IEC_CLK        ; set serial clock
SKIP          ; ***********
SKIP          
SKIP             LDA IEC_PCR
SKIP             CMP IEC_PCR
SKIP             BNE GET_IEC_CLK
SKIP             ASL A             ; C = data   bit 7 = clock
SKIP             RTS
SKIP          
              #endif

              ; ********
ef96            WAIT_1MS           ; wait one millesecond
              ; ********

0001 FALSE    #if C64
SKIP             TXA
SKIP             LDX #$B8
SKIP          
SKIP          W1MS_10
SKIP             DEX
SKIP             BNE W1MS_10
SKIP             TAX
SKIP             RTS
              #endif

0000 TRUE     #if VIC
ef96 a9 04       LDA #$04          ; set for 1024 cycles
ef98 8d 29 91    STA VIA2_T2CH     ; set VIA 2 T2C_h

ef9b          W1MS_20
ef9b ad 2d 91    LDA IEC_IFR       ; get VIA 2 IFR
ef9e 29 20       AND #$20          ; mask T2 interrupt
efa0 f0 f9       BEQ W1MS_20      ; loop until T2 interrupt
efa2 60          RTS ;Size   13 [WAIT_1MS]
              #endif

              ; ******************
efa3            RS232_NMI_Transmit
              ; ******************

efa3 a5 b4       LDA BITTS         ; get RS232 bit count
efa5 f0 47       BEQ RS232_Setup_Next_Byte_To_Send
efa7 30 3f       BMI RTra_40       ; if negative go do stop bit(s)
efa9 46 b6       LSR RODATA        ; shift RS232 output byte buffer
efab a2 00       LDX #$00          ; set $00 for bit = 0
efad 90 01       BCC RTra_05       ; branch if bit was 0
efaf ca          DEX               ; set $FF for bit = 1

efb0          RTra_05
efb0 8a          TXA               ; copy bit to A
efb1 45 bd       EOR ROPRTY        ; EOR with RS232 parity byte
efb3 85 bd       STA ROPRTY        ; save RS232 parity byte
efb5 c6 b4       DEC BITTS         ; decrement RS232 bit count
efb7 f0 06       BEQ RTra_15       ; if RS232 bit count now zero go do parity bit

efb9          RTra_10
efb9 8a          TXA               ; copy bit to A
efba 29 20       AND #RS232_C_BIT  ; mask for CB2 control bit
efbc 85 b5       STA NXTBIT        ; save RS232 next bit to send
efbe 60          RTS ;Size   28 [RS232_NMI_Transmit]

efbf          RTra_15
efbf a9 20       LDA #$20          ; mask 00x0 0000, parity enable bit
efc1 2c 94 02    BIT M51CDR        ; test pseudo 6551 command register
efc4 f0 14       BEQ RTra_30       ; branch if parity disabled
efc6 30 1c       BMI RTra_35       ; branch if fixed mark or space parity
efc8 70 14       BVS RTra_32       ; branch if even parity
efca a5 bd       LDA ROPRTY        ; get RS232 parity byte
efcc d0 01       BNE RTra_25       ; if parity not zero leave parity bit = 0

efce          RTra_20
efce ca          DEX               ; make parity bit = 1

efcf          RTra_25
efcf c6 b4       DEC BITTS         ; decrement RS232 bit count, 1 stop bit
efd1 ad 93 02    LDA M51CTR        ; get pseudo 6551 control register
efd4 10 e3       BPL RTra_10       ; if 1 stop bit save parity bit and exit
efd6 c6 b4       DEC BITTS         ; decrement RS232 bit count, 2 stop bits
efd8 d0 df       BNE RTra_10       ; save bit and exit, branch always

efda          RTra_30
efda e6 b4       INC BITTS         ; increment RS232 bit count, = -1 stop bit
efdc d0 f0       BNE RTra_20       ; set stop bit = 1 and exit

efde          RTra_32
efde a5 bd       LDA ROPRTY        ; get RS232 parity byte
efe0 f0 ed       BEQ RTra_25       ; if parity zero leave parity bit = 0
efe2 d0 ea       BNE RTra_20       ; else make parity bit = 1, branch always

efe4          RTra_35
efe4 70 e9       BVS RTra_25       ; if fixed space parity leave parity bit = 0
efe6 50 e6       BVC RTra_20       ; else fixed mark parity make parity bit = 1, branch always

              ; decrement stop bit count, set stop bit = 1 and exit. $FF is one stop
              ; bit, $FE is two stop bits

efe8          RTra_40
efe8 e6 b4       INC BITTS         ; decrement RS232 bit count
efea a2 ff       LDX #$FF          ; set stop bit = 1
efec d0 cb       BNE RTra_10       ; save stop bit and exit, branch always

              ; *****************************
efee            RS232_Setup_Next_Byte_To_Send
              ; *****************************

efee ad 94 02    LDA M51CDR        ; get 6551 pseudo command register
eff1 4a          LSR A             ; handshake bit inot Cb
eff2 90 07       BCC RSNB_10       ; branch if 3 line interface

0001 FALSE    #if C64
SKIP             BIT RS2_DSR_CTS
              #endif
0000 TRUE     #if VIC
eff4 2c 20 91    BIT $9120         ; test VIA 2 DRB, this is wrong
              #endif

eff7 10 1d       BPL RS232_No_DSR_Signal
eff9 50 1e       BVC RNDS_10      ; if CTS = 0 set CTS signal not present and exit

effb          RSNB_10
effb a9 00       LDA #0
effd 85 bd       STA ROPRTY        ; clear RS232 parity byte
efff 85 b5       STA NXTBIT        ; clear RS232 next bit to send
f001 ae 98 02    LDX BITNUM        ; get number of bits to be sent/received
f004 86 b4       STX BITTS         ; set RS232 bit count
f006 ac 9d 02    LDY RODBS         ; get index to Tx buffer start
f009 cc 9e 02    CPY RODBE         ; compare with index to Tx buffer end
f00c f0 13       BEQ RNDS_20      ; if all done go disable T1 interrupt and return
f00e b1 f9       LDA (TXPTR),Y     ; else get byte from buffer
f010 85 b6       STA RODATA        ; save to RS232 output byte buffer
f012 ee 9d 02    INC RODBS         ; increment index to Tx buffer start
f015 60          RTS ;Size   40 [RS232_Setup_Next_Byte_To_Send]

              ; *******************
f016            RS232_No_DSR_Signal
              ; *******************

f016 a9 40       LDA #$40          ; set DSR signal not present
f018 2c          .byte   $2C

f019          RNDS_10
f019 a9 10       LDA #$10          ; set CTS signal not present
f01b 0d 97 02    ORA RSSTAT        ; OR with RS232 status register
f01e 8d 97 02    STA RSSTAT        ; save RS232 status register

              ; disable T1 interrupt

f021          RNDS_20

0001 FALSE    #if C64
SKIP             LDA #1
SKIP          
SKIP          RNDS_30
SKIP             STA CIA2_ICR
SKIP             EOR ENABL
SKIP             ORA #$80
SKIP             STA ENABL
SKIP             STA CIA2_ICR
              #endif
0000 TRUE     #if VIC
f021 a9 40       LDA #$40          ; disable T1 interrupt
f023 8d 1e 91    STA VIA1_IER      ; set VIA 1 IER
              #endif

f026 60          RTS ;Size   17 [RS232_No_DSR_Signal]

              ; *******************
f027            RS232_Set_Data_Bits
              ; *******************

f027 a2 09       LDX #$09          ; set bit count to 9, 8 data + 1 stop bit
f029 a9 20       LDA #$20          ; mask for 8/7 data bits
f02b 2c 93 02    BIT M51CTR        ; test pseudo 6551 control register
f02e f0 01       BEQ RSDB_10       ; branch if 8 bits
f030 ca          DEX               ; else decrement count for 7 data bits

f031          RSDB_10
f031 50 02       BVC RSDB_20       ; branch if 7 bits
f033 ca          DEX               ; else decrement count ..
f034 ca          DEX               ; .. for 5 data bits

f035          RSDB_20
f035 60          RTS ;Size   15 [RS232_Set_Data_Bits]

              ; *****************
f036            RS232_NMI_Receive
              ; *****************

f036 a6 a9       LDX RINONE        ; get start bit check flag
f038 d0 2e       BNE RRec_25       ; branch if no start bit received
f03a c6 a8       DEC BITCI         ; decrement receiver bit count in
f03c f0 31       BEQ RRec_30
f03e 30 0d       BMI RRec_15
f040 a5 a7       LDA INBIT
f042 45 ab       EOR RIPRTY
f044 85 ab       STA RIPRTY
f046 46 a7       LSR INBIT         ; shift receiver input bit temporary storage
f048 66 aa       ROR RIDATA

f04a          RRec_05
f04a 60          RTS ;Size   21 [RS232_NMI_Receive]

f04b          RRec_10
f04b c6 a8       DEC BITCI         ; decrement receiver bit count in

f04d          RRec_15
f04d a5 a7       LDA INBIT         ; get receiver input bit temporary storage
f04f f0 62       BEQ RRec_65
f051 ad 93 02    LDA M51CTR        ; get pseudo 6551 control register
f054 0a          ASL A
f055 a9 01       LDA #$01
f057 65 a8       ADC BITCI         ; add receiver bit count in
f059 d0 ef       BNE RRec_05

f05b          RRec_20
f05b a9 90       LDA #$90          ; enable CB1 interrupt
f05d 8d 1e 91    STA RS2_IRQ_REG   ; set VIA 1 IER
0001 FALSE    #if C64
SKIP             ORA ENABL
SKIP             STA ENABL
SKIP             STA RINONE
SKIP             LDA #2
SKIP             JMP RNDS_30
              #endif
0000 TRUE     #if VIC
f060 85 a9       STA RINONE        ; set start bit check flag, set no start bit received
f062 a9 20       LDA #$20          ; disable T2 interrupt
f064 8d 1e 91    STA RS2_IRQ_REG   ; set VIA 1 IER
f067 60          RTS ;Size   50 [RS232_NMI_Receive]
              #endif

f068          RRec_25
f068 a5 a7       LDA INBIT         ; get receiver input bit temporary storage
f06a d0 ef       BNE RRec_20

0001 FALSE    #if C64
SKIP             JMP Je4d3
              #endif
0000 TRUE     #if VIC
f06c 85 a9       STA RINONE        ; set start bit check flag, set start bit received
f06e 60          RTS ;Size   57 [RS232_NMI_Receive]
              #endif

f06f          RRec_30
f06f ac 9b 02    LDY RIDBE         ; get index to Rx buffer end
f072 c8          INY
f073 cc 9c 02    CPY RIDBS         ; compare with index to Rx buffer start
f076 f0 2a       BEQ RRec_50       ; if buffer full go do Rx overrun error
f078 8c 9b 02    STY RIDBE         ; save index to Rx buffer end
f07b 88          DEY               ; decrement index
f07c a5 aa       LDA RIDATA        ; get assembled byte
f07e ae 98 02    LDX BITNUM        ; get bit count

f081          RRec_35
f081 e0 09       CPX #$09          ; compare with byte + stop
f083 f0 04       BEQ RRec_40       ; branch if all nine bits received
f085 4a          LSR A             ; else shift byte
f086 e8          INX               ; increment bit count
f087 d0 f8       BNE RRec_35       ; loop, branch always

f089          RRec_40
f089 91 f7       STA (RXPTR),Y     ; save received byte to Rx buffer
f08b a9 20       LDA #$20          ; mask 00x0 0000, parity enable bit
f08d 2c 94 02    BIT M51CDR        ; test pseudo 6551 command register
f090 f0 b9       BEQ RRec_10       ; branch if parity disabled
f092 30 b6       BMI RRec_05       ; branch if mark or space parity
f094 a5 a7       LDA INBIT         ; get receiver input bit temporary storage
f096 45 ab       EOR RIPRTY
f098 f0 03       BEQ RRec_45
f09a 70 ae       BVS RRec_05
f09c 2c          .byte   $2C

f09d          RRec_45
f09d 50 ab       BVC RRec_05
f09f a9 01       LDA #$01          ; set Rx parity error
f0a1 2c          .byte   $2C

f0a2          RRec_50
f0a2 a9 04       LDA #$04          ; set Rx overrun error
f0a4 2c          .byte   $2C

f0a5          RRec_55
f0a5 a9 80       LDA #$80          ; Rx break error
f0a7 2c          .byte   $2C

f0a8          RRec_60
f0a8 a9 02       LDA #$02          ; Rx frame error
f0aa 0d 97 02    ORA RSSTAT        ; OR with RS232 status byte
f0ad 8d 97 02    STA RSSTAT        ; save RS232 status byte
f0b0 4c 5b f0    JMP RRec_20

f0b3          RRec_65
f0b3 a5 aa       LDA RIDATA
f0b5 d0 f1       BNE RRec_60      ; if ?? do frame error
f0b7 f0 ec       BEQ RRec_55      ; else do break error, branch always

f0b9          RRec_70
0000 TRUE     #if VIC
f0b9 4c 96 f7    JMP Illegal_Jiffy_Device
              #endif

              ; ============
f0bc            RS232_CHKOUT
              ; ============

f0bc 85 9a       STA DFLTO         ; save output device number
f0be ad 94 02    LDA M51CDR        ; get pseudo 6551 command register
f0c1 4a          LSR A             ; shift handshake bit to carry
f0c2 90 27       BCC RSSN_10       ; branch if 3 line interface
f0c4 a9 02       LDA #$02          ; mask for RTS out
f0c6 2c 10 91    BIT RS2_DSR_CTS   ; test VIA 1 DRB
f0c9 10 1d       BPL RS232_Set_Status_No_Signal
f0cb d0 1e       BNE RSSN_10       ; if RTS = 1 just exit

f0cd          RCHO_10
0001 FALSE    #if C64
SKIP             LDA ENABL
SKIP             AND #2
              #endif
0000 TRUE     #if VIC
f0cd ad 1e 91    LDA VIA1_IER      ; get VIA 1 IER
f0d0 29 30       AND #$30          ; mask 00xx 0000, T2 and CB1 interrupts
              #endif
f0d2 d0 f9       BNE RCHO_10       ; loop while either enabled

f0d4          RCHO_20
f0d4 2c 10 91    BIT RS2_DSR_CTS   ; test VIA 1 DRB
f0d7 70 fb       BVS RCHO_20       ; loop while CTS high
f0d9 ad 10 91    LDA RS2_DSR_CTS   ; get VIA 1 DRB
f0dc 09 02       ORA #$02          ; set RTS high
f0de 8d 10 91    STA RS2_DSR_CTS   ; save VIA 1 DRB

f0e1          RCHO_30
f0e1 2c 10 91    BIT RS2_DSR_CTS   ; test VIA 1 DRB
f0e4 70 05       BVS RSSN_10       ; exit if CTS high
f0e6 30 f9       BMI RCHO_30       ; loop while DSR high

              ; **************************
f0e8            RS232_Set_Status_No_Signal
              ; **************************

0001 FALSE    #if C64
SKIP             LDA #$40
SKIP             STA RSSTAT
              #endif
0000 TRUE     #if VIC
f0e8 20 16 f0    JSR RS232_No_DSR_Signal
              #endif
f0eb          RSSN_10
f0eb 18          CLC               ; flag ok
f0ec 60          RTS ;Size    5 [RS232_Set_Status_No_Signal]

              ; ************************
f0ed            RS232_Put_Byte_To_Buffer
              ; ************************

0001 FALSE    #if C64
SKIP             JSR RPBB_20
SKIP          
SKIP          RPBB_10
              #endif
f0ed ac 9e 02    LDY RODBE         ; get index to Tx buffer end
f0f0 c8          INY               ; + 1
f0f1 cc 9d 02    CPY RODBS         ; compare with index to Tx buffer start
f0f4 f0 f7       BEQ RS232_Put_Byte_To_Buffer
f0f6 8c 9e 02    STY RODBE         ; set index to Tx buffer end
f0f9 88          DEY               ; index to available buffer byte
0001 FALSE    #if C64
SKIP             LDA PTR1
              #endif
f0fa 91 f9       STA (TXPTR),Y     ; save byte to buffer

f0fc          RPBB_20
0001 FALSE    #if C64
SKIP             LDA ENABL
SKIP             LSR A
SKIP             BCS RPBB_40
SKIP             LDA #$10
SKIP             STA CIA2_CRA
              #endif
0000 TRUE     #if VIC
f0fc 2c 1e 91    BIT VIA1_IER      ; test VIA 1 IER
f0ff 50 01       BVC RPBB_30       ; branch if T1 not enabled
f101 60          RTS ;Size   21 [RS232_Put_Byte_To_Buffer]
              #endif

f102          RPBB_30
f102 ad 99 02    LDA BAUDOF        ; get baud rate bit time low byte
f105 8d 14 91    STA RS2_TIM_LOW   ; set VIA 1 T1C_l
f108 ad 9a 02    LDA BAUDOF+1      ; get baud rate bit time high byte
f10b 8d 15 91    STA RS2_TIM_HIG   ; set VIA 1 T1C_h
0001 FALSE    #if C64
SKIP             LDA #$81
SKIP             JSR RNDS_30
SKIP             JSR RS232_Setup_Next_Byte_To_Send
SKIP             LDA #$11
SKIP             STA CIA2_CRA
SKIP          
SKIP          RPBB_40
SKIP             RTS
              #endif
0000 TRUE     #if VIC
f10e a9 c0       LDA #$C0          ; enable T1 interrupt
f110 8d 1e 91    STA VIA1_IER      ; set VIA 1 IER
f113 4c ee ef    JMP RS232_Setup_Next_Byte_To_Send
              #endif

              ; ===========
f116            RS232_CHKIN
              ; ===========

f116 85 99       STA DFLTN         ; save input device number
f118 ad 94 02    LDA M51CDR        ; get pseudo 6551 command register
f11b 4a          LSR A
f11c 90 28       BCC RCHI_40       ; branch if 3 line interface
f11e 29 08       AND #$08          ; mask duplex bit, pseudo 6551 command is >> 1
f120 f0 24       BEQ RCHI_40       ; branch if full duplex
f122 a9 02       LDA #2
f124 2c 10 91    BIT RS2_DSR_CTS   ; test VIA 1 DRB
f127 10 bf       BPL RS232_Set_Status_No_Signal
f129 f0 19       BEQ RCHI_50

f12b          RCHI_10
0001 FALSE    #if C64
SKIP             LDA ENABL
SKIP             LSR A
SKIP             BCS RCHI_10
              #endif
0000 TRUE     #if VIC
f12b 2c 1e 91    BIT VIA1_IER      ; test VIA 1 IER
f12e 70 fb       BVS RCHI_10       ; loop while T1 interrupt enabled
              #endif
f130 ad 10 91    LDA RS2_DSR_CTS   ; get VIA 1 DRB
f133 29 fd       AND #$FD          ; mask xxxx xx0x, clear RTS out
f135 8d 10 91    STA RS2_DSR_CTS   ; save VIA 1 DRB

f138          RCHI_20
f138 ad 10 91    LDA RS2_DSR_CTS   ; get VIA 1 DRB
f13b 29 04       AND #$04          ; mask xxxx x1xx, DTR
f13d f0 f9       BEQ RCHI_20       ; loop while DTR low

f13f          RCHI_30
f13f a9 90       LDA #$90          ; enable CB1 interrupt
0001 FALSE    #if C64
SKIP             CLC
SKIP             JMP RNDS_30
SKIP          
SKIP          RCHI_40
SKIP             LDA ENABL
SKIP             AND #$12
SKIP             BEQ RCHI_30
              #endif
0000 TRUE     #if VIC
f141 8d 1e 91    STA VIA1_IER      ; set VIA 1 IER
              #endif

f144          RCHI_50
f144 18          CLC
f145 60          RTS ;Size   89 [RS232_Put_Byte_To_Buffer]

0000 TRUE     #if VIC
f146          RCHI_40
f146 ad 1e 91    LDA VIA1_IER      ; get VIA 1 IER
f149 29 30       AND #$30          ; mask 0xx0 0000, T1 and T2 interrupts
f14b f0 f2       BEQ RCHI_30       ; if both interrupts disabled go enable CB1
f14d 18          CLC
f14e 60          RTS ;Size   98 [RS232_Put_Byte_To_Buffer]
              #endif

              ; **************************
f14f            RS232_Get_Byte_From_Buffer
              ; **************************

0001 FALSE    #if C64
SKIP             LDA RSSTAT
              #endif
f14f ac 9c 02    LDY RIDBS         ; get index to Rx buffer start
f152 cc 9b 02    CPY RIDBE         ; compare with index to Rx buffer end
f155 f0 06       BEQ RGBB_10       ; return null if buffer empty
0001 FALSE    #if C64
SKIP             AND #$F7
SKIP             STA RSSTAT
              #endif
f157 b1 f7       LDA (RXPTR),Y     ; get byte from Rx buffer
f159 ee 9c 02    INC RIDBS         ; increment index to Rx buffer start
f15c 60          RTS ;Size   14 [RS232_Get_Byte_From_Buffer]

f15d          RGBB_10
0001 FALSE    #if C64
SKIP             ORA #8
SKIP             STA RSSTAT
              #endif
f15d a9 00       LDA #$00          ; return null
f15f 60          RTS ;Size   17 [RS232_Get_Byte_From_Buffer]

              ; **********
f160            RS232_Stop
              ; **********

f160 48          PHA
0001 FALSE    #if C64
SKIP             LDA ENABL
SKIP             BEQ RSTP_30
SKIP          
SKIP          RSTP_10
SKIP             LDA ENABL
SKIP             AND #3
SKIP             BNE RSTP_10
              #endif
0000 TRUE     #if VIC
f161 ad 1e 91    LDA RS2_IRQ_REG   ; get VIA 1 IER
f164 f0 0c       BEQ RSTP_30       ; branch if no interrupts enabled. this branch will

f166          RSTP_20
f166 ad 1e 91    LDA RS2_IRQ_REG   ; get VIA 1 IER
f169 29 60       AND #$60          ; mask 0xx0 0000, T1 and T2 interrupts
f16b d0 f9       BNE RSTP_20       ; loop if T1 or T2 active
              #endif
f16d a9 10       LDA #$10          ; disable CB1 interrupt
f16f 8d 1e 91    STA RS2_IRQ_REG   ; set VIA 1 IER
0001 FALSE    #if C64
SKIP             LDA #0
SKIP             STA ENABL
              #endif

f172          RSTP_30
f172 68          PLA
f173 60          RTS ;Size   20 [RS232_Stop]

f174 0d 49 2f Msg_Start     .byte "\rI/O ERROR #"^
f180 0d 53 45 Msg_Searching .byte "\rSEARCHING "^
f18b 46 4f 52 Msg_FOR       .byte "FOR "^

0001 FALSE    #if JIFFY
0001 FALSE    #if C64
SKIP          ; *******************
SKIP            Jiffy_Clear_Sprites
SKIP          ; *******************
SKIP          
SKIP             LDA #0
SKIP             STA VIC_SPR_ENA
SKIP          
SKIP          JCS_10
SKIP             ADC #1
SKIP             BNE JCS_10
SKIP             RTS
              #endif
SKIP          
SKIP          ; ****************
SKIP            Jiffy_CHKIN_PTR2
SKIP          ; ****************
SKIP          
SKIP             LDA PTR2
SKIP          
SKIP          ; ***********
SKIP            Jiffy_CHKIN
SKIP          ; ***********
SKIP          
SKIP             PHA
SKIP             JSR CLRCHN
SKIP             PLA
SKIP             TAX
SKIP             JMP CHKIN
SKIP          
SKIP          ; *************
SKIP            Jiffy_CLR_DAT
SKIP          ; *************
SKIP          
0000 TRUE     #if VIC
SKIP             SEI
              #endif
SKIP             LDA #0
SKIP             STA TSFCNT        ; clear jiffy flag
SKIP             JMP CLR_IEC_DAT   ; continue with IEC routine
SKIP          
SKIP          ; ************************
SKIP            Jiffy_Send_Drive_Command
SKIP          ; ************************
SKIP          
SKIP             TXA
SKIP             PHA
SKIP             JSR JiDi_60
SKIP             PLA
SKIP             TAX
SKIP          Bf0fb
SKIP             LDA Jiffy_Transfer_01,X
SKIP             JSR CHROUT
SKIP             INX
SKIP             DEY
SKIP             BNE Bf0fb
SKIP             RTS
SKIP          
0000 TRUE     #if VIC
SKIP          ; **************
SKIP            Back_To_Prompt
SKIP          ; **************
SKIP          
SKIP             TXA
SKIP             BMI JAAB_10
SKIP             JMP Default_Error
SKIP          
SKIP          JAAB_10
SKIP             JMP Basic_Ready
              #endif
SKIP          
              #else
f18f 0d 50 52 Msg_Play      .byte "\rPRESS PLAY ON TAPE"^
f1a2 50 52 45 Msg_Record    .byte "PRESS RECORD & PLAY ON TAPE"^
              #endif
f1bd 0d 4c 4f Msg_Loading   .byte "\rLOADING"^
f1c5 0d 53 41 Msg_Saving    .byte "\rSAVING "^
f1cd 0d 56 45 Msg_Verifying .byte "\rVERIFYING"^
f1d7 0d 46 4f Msg_Found     .byte "\rFOUND "^
f1de 0d 4f 4b Msg_ok        .byte "\rOK\r"^

              ; ==================
f1e2            Display_Direct_Msg
              ; ==================

f1e2 24 9d       BIT MSGFLG        ; test message mode flag
f1e4 10 0d       BPL DDM_10        ; exit if control messages off

              ; *************************
f1e6            Display_Kernal_IO_Message
              ; *************************

f1e6 b9 74 f1    LDA Msg_Start,Y    ; get byte from message table
f1e9 08          PHP               ; save status
f1ea 29 7f       AND #$7F          ; clear b7
f1ec 20 d2 ff    JSR CHROUT        ; Output a character
f1ef c8          INY
f1f0 28          PLP               ; restore status
f1f1 10 f3       BPL Display_Kernal_IO_Message

f1f3          DDM_10
f1f3 18          CLC
f1f4 60          RTS ;Size   15 [Display_Kernal_IO_Message]

              ; ************
f1f5            Kernal_GETIN
              ; ************

f1f5 a5 99       LDA DFLTN         ; get input device number
f1f7 d0 08       BNE KeGE_10       ; branch if not keyboard
f1f9 a5 c6       LDA NDX           ; get keyboard buffer length
0001 FALSE    #if C64
SKIP             BEQ KeGE_20
              #endif
0000 TRUE     #if VIC
f1fb f0 6d       BEQ IGB_20      ; if buffer empty go flag no byte and return
              #endif
f1fd 78          SEI               ; disable inter/rupts
f1fe 4c cf e5    JMP Get_Char_From_Keyboard_Buffer

f201          KeGE_10
f201 c9 02       CMP #$02          ; compare device with RS232 device
f203 d0 18       BNE CHRI_05      ; branch if not RS232 device

              ; **************
f205            RS232_Get_Byte
              ; **************

f205 84 97       STY TEMPX         ; save Y
f207 20 4f f1    JSR RS232_Get_Byte_From_Buffer
f20a a4 97       LDY TEMPX         ; restore Y

f20c          KeGE_20
f20c 18          CLC               ; flag no error
f20d 60          RTS ;Size    9 [RS232_Get_Byte]

              ; ************
f20e            Kernal_CHRIN       ; Get a character from the input channel
              ; ************

f20e a5 99       LDA DFLTN         ; get input device number
0001 FALSE    #if JIFFY
SKIP             BNE Jiffy_f1a9
              #else
f210 d0 0b       BNE CHRI_05       ; if it's not the keyboard continue
              #endif
f212 a5 d3       LDA CSRIDX        ; get cursor column
f214 85 ca       STA ICRCOL        ; set input cursor column
f216 a5 d6       LDA TBLX          ; get cursor row
f218 85 c9       STA ICRROW        ; set input cursor row
f21a 4c 4f e6    JMP CHRIN_Keyboard_Or_Screen

              ; the input device was not the keyboard

f21d          CHRI_05
f21d c9 03       CMP #$03          ; compare device number with screen
f21f d0 09       BNE CHRI_10       ; if it's not the screen continue

f221          CHRI_07
f221 85 d0       STA INSRC         ; input from keyboard or screen, $xx = screen,
f223 a5 d5       LDA LINLEN        ; get current screen line length
f225 85 c8       STA INDX          ; save input [EOL] pointer
f227 4c 4f e6    JMP CHRIN_Keyboard_Or_Screen

f22a          CHRI_10
f22a b0 38       BCS IEC_Get_Byte

              ; the input device is < the screen do must be the RS232 or tape device

f22c c9 02       CMP #$02          ; compare device with RS232 device
f22e f0 3f       BEQ RS232_Read_Byte

              ; else there's only the tape device left ..

0001 FALSE    #if JIFFY
SKIP          ; **********************
SKIP            Jiffy_ACPTR_Load_Check
SKIP          ; **********************
SKIP          
SKIP             JSR Jiffy_ACPTR   ; get byte from serial bus
SKIP             PHA               ; temp store on stack
SKIP             BIT TSFCNT        ; test bit6, if serial device is a JiffyDOS device
SKIP             BVC JALC_20       ; no JiffyDOS device
SKIP             CPX #0            
SKIP             BNE JALC_10
SKIP             LDA MEMUSS+1      ; load address high byte
SKIP          
SKIP          JALC_10
SKIP             CMP #4            ; load address < $0400 ?
SKIP             BCC JALC_20       ; don't load with Jiffy
SKIP             LDY #0
SKIP             LDA (FNADR),Y     ; get first character of filename
SKIP             CMP #'$'          ; is it a directory load ?
SKIP             BEQ JALC_20       ; yes, don't load with Jiffy
SKIP             INC SA
SKIP             JSR Jiffy_Talk_TkSA
SKIP             DEC SA
SKIP             ASL TSFCNT        ; continue with Jiffy load
SKIP          
SKIP          JALC_20
SKIP             PLA               ; recover read byte
SKIP             RTS
SKIP          
SKIP          ; ***************
SKIP            Flag_Read_Error
SKIP          ; ***************
SKIP          
SKIP            LDA #16
SKIP            JMP Ora_Status
SKIP          
SKIP          ; *****
SKIP            Vf1a3
SKIP          ; *****
SKIP          
SKIP            .WORD Back_To_Prompt
SKIP            .WORD Default_Warmstart
SKIP            .WORD Default_Tokenize
SKIP          
SKIP          ; **********
SKIP            Jiffy_f1a9
SKIP          ; **********
SKIP          
SKIP             CMP #4
SKIP             BCC CHRI_05
SKIP          
              #else
f230 86 97       STX TEMPX         ; save X
f232 20 50 f2    JSR TAPE_Get_Byte
f235 b0 16       BCS CHRI_25       ; exit if error
f237 48          PHA               ; save byte
f238 20 50 f2    JSR TAPE_Get_Byte
f23b b0 0d       BCS CHRI_20       ; exit if error
f23d d0 05       BNE CHRI_15       ; branch if end reached
f23f a9 40       LDA #$40          ; set [EOF] bit
f241 20 6a fe    JSR Ora_Status

f244          CHRI_15
f244 c6 a6       DEC BUFPNT        ; decrement tape buffer index
f246 a6 97       LDX TEMPX         ; restore X
f248 68          PLA               ; restore saved byte
f249 60          RTS ;Size   60 [Kernal_CHRIN]

              ; error exit from input character

f24a          CHRI_20
f24a aa          TAX               ; copy error byte ??
f24b 68          PLA               ; dump saved byte
f24c 8a          TXA               ; restore error byte ??
f24d          CHRI_25
f24d a6 97       LDX TEMPX         ; restore X
f24f 60          RTS ;Size   66 [Kernal_CHRIN]

              ; *************
f250            TAPE_Get_Byte
              ; *************

f250 20 8a f8    JSR TAPE_Advance_Buffer_Pointer
f253 d0 0b       BNE TGB_05        ; if not end get next byte and exit
f255 20 c0 f8    JSR TAPE_Init_Read
f258 b0 11       BCS IGB_30      ; exit if error flagged
f25a a9 00       LDA #0
f25c 85 a6       STA BUFPNT        ; clear tape buffer index
f25e f0 f0       BEQ TAPE_Get_Byte ; branch always

f260          TGB_05
f260 b1 b2       LDA (TAPE1),Y     ; get next byte from buffer
f262 18          CLC               ; flag no error
f263 60          RTS ;Size   20 [TAPE_Get_Byte]

              #endif               ; JIFFY

              ; * = $f1ad

              ; ============
f264            IEC_Get_Byte
              ; ============

f264 a5 90       LDA STATUS        ; get serial status byte
f266 f0 04       BEQ IGB_40        ; if no errors flagged go input byte and return

f268          IGB_10
f268 a9 0d       LDA #$0D          ; else return [EOL]

f26a          IGB_20
f26a 18          CLC               ; flag no error

f26b          IGB_30
f26b 60          RTS ;Size   28 [TAPE_Get_Byte]

f26c          IGB_40
0001 FALSE    #if JIFFY
SKIP             JMP Jiffy_ACPTR   ; input a byte from the serial bus and return
              #else
f26c 4c 19 ef    JMP Kernal_ACPTR
              #endif

              ; ===============
f26f            RS232_Read_Byte
              ; ===============

f26f 20 05 f2    JSR RS232_Get_Byte
0001 FALSE    #if C64
SKIP             BCS IGB_30
              #endif
0000 TRUE     #if VIC
f272 b0 05       BCS RRB_Ret       ; branch if error, this doesn't get taken as the last
              #endif
f274 c9 00       CMP #$00          ; compare with null
0001 FALSE    #if C64
SKIP             BNE IGB_20
SKIP             LDA RSSTAT
SKIP             AND #$60
SKIP             BNE IGB_10
              #endif
f276 f0 f7       BEQ RS232_Read_Byte      ; loop if null
0000 TRUE     #if VIC
f278 18          CLC               ; flag no error
f279          RRB_Ret
f279 60          RTS ;Size   42 [TAPE_Get_Byte]
              #endif

              ; *************
f27a            Kernal_CHROUT      ; Output a character
              ; *************

f27a 48          PHA               ; save the character to send
f27b a5 9a       LDA DFLTO         ; get output device number
f27d c9 03       CMP #$03          ; compare device number with screen
f27f d0 04       BNE KeCO_10       ; if output device not screen continue

              ; the output device is the screen

f281 68          PLA               ; restore character to send
f282 4c 42 e7    JMP Screen_CHROUT ; output character and return

              ; the output device was not the screen

f285          KeCO_10
f285 90 04       BCC KeCO_20       ; if output device < screen continue

              ; the output device was > screen so it is a serial bus device

f287 68          PLA               ; restore character to send
f288 4c e4 ee    JMP Kernal_CIOUT  ; output a byte to the serial bus and return

              ; the output device is < screen

f28b          KeCO_20
0001 FALSE    #if C64
SKIP             LSR A
              #endif
0000 TRUE     #if VIC
f28b c9 02       CMP #$02          ; compare the device with RS232 device
f28d f0 2a       BEQ RS232_Send_Byte
              #endif

              ; else the output device is the cassette

f28f 68          PLA               ; restore the character to send

              ; **************
f290            TAPE_Send_Byte
              ; **************

0000 TRUE     #if ![VIC & JIFFY]
f290 85 9e       STA PTR1          ; save character to character buffer
0000 TRUE     #if VIC
f292 48          PHA               ; save A
              #endif
f293 8a          TXA               ; copy X
f294 48          PHA               ; save X
f295 98          TYA               ; copy Y
f296 48          PHA               ; save Y
              #endif
0001 FALSE    #if C64
SKIP             BCC RS232_Send_Byte
              #endif
0001 FALSE    #if JIFFY
0001 FALSE    #if C64
SKIP             JMP Pop_Dev_Not_Present
              #else
SKIP             JMP Dev_Not_Present
              #endif
SKIP          
SKIP          ; *****************
SKIP            Jiffy_Disk_Status 
SKIP          ; *****************
SKIP          
SKIP             JSR Jiffy_Open_Command_10 
SKIP             JSR Jiffy_CHRIN 
SKIP             CMP #'0'          ; first char of disk status
SKIP             RTS   
SKIP          
SKIP          ; ************************
SKIP            Jiffy_Set_Default_Device 
SKIP          ; ************************
SKIP          
SKIP             JSR Get_Next_Byte_Value
SKIP             STX FA
SKIP             JSR Jiffy_Validate_FA 
SKIP             STX Jiffy_Device
SKIP             RTS   
              #else
f297 20 8a f8    JSR TAPE_Advance_Buffer_Pointer
f29a d0 0e       BNE TASB_10       ; if not end save next byte and exit
f29c 20 e3 f8    JSR Init_Tape_Write
f29f b0 0e       BCS TASB_30       ; exit if error
f2a1 a9 02       LDA #$02          ; set data block type ??
f2a3 a0 00       LDY #0
f2a5 91 b2       STA (TAPE1),Y     ; save type to buffer ??
f2a7 c8          INY
f2a8 84 a6       STY BUFPNT        ; save tape buffer index

f2aa          TASB_10
f2aa a5 9e       LDA PTR1          ; restore character from character buffer
f2ac 91 b2       STA (TAPE1),Y     ; save to buffer

              #endif
f2ae          TASB_20
0001 FALSE    #if JIFFY & VIC
SKIP             LDA #$fb
SKIP             STA KEYB_COL
SKIP             LDX KEYB_ROW
SKIP             LDA #$f7
SKIP             STA KEYB_COL
SKIP             JMP Jiffy_e9c6
SKIP             .byte 0
              #else
f2ae 18          CLC               ; flag no error

f2af          TASB_30
f2af 68          PLA               ; pull Y
f2b0 a8          TAY               ; restore Y
f2b1 68          PLA               ; pull X
f2b2 aa          TAX               ; restore X
0001 FALSE    #if C64
SKIP             LDA PTR1
              #endif
0000 TRUE     #if VIC
f2b3 68          PLA               ; restore A
              #endif
f2b4 90 02       BCC TASB_40       ; exit if no error
f2b6 a9 00       LDA #$00          ; else clear A
              #endif

f2b8          TASB_40
f2b8 60          RTS ;Size   41 [TAPE_Send_Byte]

              ; ===============
f2b9            RS232_Send_Byte
              ; ===============

0001 FALSE    #if C64
SKIP             JSR RPBB_10
SKIP             JMP TASB_20
              #endif
0000 TRUE     #if VIC
f2b9 68          PLA               ; restore character to send
f2ba 86 97       STX TEMPX         ; save X
f2bc 84 9e       STY PTR1          ; save Y
f2be 20 ed f0    JSR RS232_Put_Byte_To_Buffer
f2c1 a6 97       LDX TEMPX         ; restore Y
f2c3 a4 9e       LDY PTR1          ; restore X
f2c5 18          CLC               ; flag ok
f2c6 60          RTS ;Size   55 [TAPE_Send_Byte]
              #endif

              ; *************
f2c7            Kernal_ICHKIN
              ; *************

f2c7 20 cf f3    JSR Find_File_X
f2ca f0 03       BEQ KICH_10       ; branch if file opened
f2cc 4c 84 f7    JMP File_Not_Open

f2cf          KICH_10
f2cf 20 df f3    JSR Get_LFS
f2d2 a5 ba       LDA FA            ; get device number
f2d4 f0 16       BEQ KICH_30       ; if device was keyboard save device #, flag ok and exit
f2d6 c9 03       CMP #$03          ; compare device number with screen
f2d8 f0 12       BEQ KICH_30       ; if device was screen save device #, flag ok and exit
f2da b0 14       BCS KICH_40       ; branch if serial bus device
f2dc c9 02       CMP #$02          ; compare device with RS232 device
f2de d0 03       BNE KICH_20       ; branch if not RS 232 device
f2e0 4c 16 f1    JMP RS232_CHKIN

f2e3          KICH_20
f2e3 a6 b9       LDX SA            ; get secondary address
f2e5 e0 60       CPX #$60
f2e7 f0 03       BEQ KICH_30
f2e9 4c 8d f7    JMP Not_Input_File

f2ec          KICH_30
f2ec 85 99       STA DFLTN         ; save input device number
f2ee 18          CLC               ; flag ok
f2ef 60          RTS ;Size   41 [Kernal_ICHKIN]

f2f0          KICH_40              ; CHKIN for IEC device
f2f0 aa          TAX               ; copy device number to X
f2f1 20 14 ee    JSR Kernal_TALK   ; command a serial bus device to TALK
f2f4 a5 b9       LDA SA            ; get secondary address
f2f6 10 06       BPL KICH_50
f2f8 20 d3 ee    JSR IEC_Finish_Send
f2fb 4c 01 f3    JMP KICH_60

f2fe          KICH_50
f2fe 20 ce ee    JSR Kernal_TKSA   ; send secondary address after TALK

f301          KICH_60
f301 8a          TXA               ; copy device back to A
f302 24 90       BIT STATUS        ; test serial status byte
f304 10 e6       BPL KICH_30       ; if device present save device number and exit
f306 4c 8a f7    JMP Dev_Not_Present      ; do device not present error and return

              ; *************
f309            Kernal_CHKOUT      ; Open a channel for output
              ; *************

f309 20 cf f3    JSR Find_File_X
f30c f0 03       BEQ KCHO_10       ; branch if file found
f30e 4c 84 f7    JMP File_Not_Open

f311          KCHO_10
f311 20 df f3    JSR Get_LFS
f314 a5 ba       LDA FA            ; get device number
f316 d0 03       BNE KCHO_30       ; branch if device is not keyboard

f318          KCHO_20
f318 4c 90 f7    JMP Not_Output_File

f31b          KCHO_30
f31b c9 03       CMP #$03          ; compare device number with screen
f31d f0 0f       BEQ KCHO_50       ; if screen save output device number and exit
f31f b0 11       BCS KCHO_60       ; branch if > screen, serial bus device
f321 c9 02       CMP #$02          ; compare device with RS232 device
f323 d0 03       BNE KCHO_40       ; branch if not RS232 device, must be tape
f325 4c bc f0    JMP RS232_CHKOUT

f328          KCHO_40
f328 a6 b9       LDX SA            ; get secondary address
f32a e0 60       CPX #$60
f32c f0 ea       BEQ KCHO_20       ; if ?? do not output file error and return

f32e          KCHO_50
f32e 85 9a       STA DFLTO         ; save output device number
f330 18          CLC               ; flag ok
f331 60          RTS ;Size   41 [Kernal_CHKOUT]

f332          KCHO_60
f332 aa          TAX               ; copy device number
f333 20 17 ee    JSR Kernal_LISTEN ; command devices on the serial bus to LISTEN
f336 a5 b9       LDA SA            ; get secondary address
f338 10 05       BPL KCHO_70       ; branch if address to send
f33a 20 c5 ee    JSR IEC_ATN_High
f33d d0 03       BNE KCHO_80       ; branch always

f33f          KCHO_70
f33f 20 c0 ee    JSR Kernal_SECOND ; send secondary address after LISTEN

f342          KCHO_80
f342 8a          TXA               ; copy device number back to A
f343 24 90       BIT STATUS        ; test serial status byte
f345 10 e7       BPL KCHO_50       ; if device present save output device number and exit
f347 4c 8a f7    JMP Dev_Not_Present      ; else do device not present error and return

              ; ************
f34a            Kernal_CLOSE
              ; ************

f34a 20 d4 f3    JSR Find_File_A
f34d f0 02       BEQ KeCL_10       ; if the file is found go close it
f34f 18          CLC               ; else the file was closed so just flag ok
f350 60          RTS ;Size    7 [Kernal_CLOSE]

f351          KeCL_10
f351 20 df f3    JSR Get_LFS
f354 8a          TXA               ; copy file index to A
f355 48          PHA               ; save file index
f356 a5 ba       LDA FA            ; get device number
f358 f0 57       BEQ KeCL_80       ; if $00, keyboard, restore index and close file
f35a c9 03       CMP #3            ; compare device number with screen
f35c f0 53       BEQ KeCL_80       ; if screen restore index and close file
f35e b0 4e       BCS KeCL_70       ; if > screen go do serial bus device close
f360 c9 02       CMP #2            ; compare device with RS232 device
f362 d0 29       BNE KeCL_40       ; branch if not RS232 device
f364 68          PLA               ; restore file index
f365 20 b2 f3    JSR Close_File
0001 FALSE    #if C64
SKIP             JSR ROPN_50
              #endif
0000 TRUE     #if VIC
f368 a9 7d       LDA #$7D          ; disable T1, T2, CB1, CB2, SR and CA2
f36a 8d 1e 91    STA RS2_IRQ_REG   ; set VIA 1 IER
f36d a9 06       LDA #$06          ; set DTR and RTS high
f36f 8d 10 91    STA RS2_DSR_CTS   ; set VIA 1 DRB
f372 a9 ee       LDA #$EE          ; CB2 high, CB1 negative edge, CA2 high, CA1 negative edge
f374 8d 1c 91    STA VIA1_PCR      ; set VIA 1 PCR
              #endif
f377 20 75 fe    JSR Read_Memtop
f37a a5 f8       LDA RXPTR+1       ; get RS232 input buffer pointer high byte
f37c f0 01       BEQ KeCL_20       ; branch if no RS232 input buffer
f37e c8          INY               ; else reclaim RS232 input buffer memory

f37f          KeCL_20
f37f a5 fa       LDA TXPTR+1       ; get RS232 output buffer pointer high byte
f381 f0 01       BEQ KeCL_30       ; branch if no RS232 output buffer
f383 c8          INY               ; else reclaim RS232 output buffer memory

f384          KeCL_30
f384 a9 00       LDA #0
f386 85 f8       STA RXPTR+1       ; clear RS232 input buffer pointer high byte
f388 85 fa       STA TXPTR+1       ; clear RS232 output buffer pointer high byte
f38a 4c 3c f5    JMP ROPN_45       ; go set top of memory and exit

f38d          KeCL_40
0001 FALSE    #if JIFFY
SKIP             PLA
SKIP             JMP Illegal_Jiffy_Device
SKIP          
SKIP          ; **************
SKIP            Jiffy_Close_15
SKIP          ; **************
SKIP          
SKIP             JSR CLRCHN
SKIP          
SKIP          Jiffy_Close_6f
SKIP             LDA #$6f
SKIP             JSR Find_File_A
SKIP             BNE ClFi_Ret
SKIP             JMP ClFi_05
SKIP          
0001 FALSE    #if C64
SKIP          ; *****************
SKIP            Jiffy_Test_Device 
SKIP          ; ***************** 
SKIP          
SKIP             STX FA
SKIP          
SKIP          ; *************
SKIP            Jiffy_Test_FA 
SKIP          ; *************
SKIP          
SKIP             TYA   
SKIP             PHA   
SKIP             JSR Jiffy_Open_Command_Channel    ; open 15,x,15
SKIP             JSR JiDi_60    ; set command channel (15) as output
SKIP             PHP   
SKIP             JSR Jiffy_Close_15
SKIP             PLP   
SKIP             PLA   
              #else
SKIP          JTABC
SKIP             .byte $00,$20,$00,$20,$02,$22,$02,$22
SKIP             .byte $00,$20,$00,$20,$02,$22,$02,$22
              #endif
0001 FALSE    #if C64
SKIP             TAY   
SKIP             LDX FA
SKIP             RTS   
SKIP             .byte $f2
              #endif
              #else
f38d a5 b9       LDA SA            ; get secondary address
f38f 29 0f       AND #$0F
f391 f0 1e       BEQ KeCL_80
f393 20 4d f8    JSR TAPE_Get_Buffer_Address
f396 a9 00       LDA #0
0001 FALSE    #if C64
SKIP             SEC
              #endif
f398 20 90 f2    JSR TAPE_Send_Byte
0001 FALSE    #if C64
SKIP             JSR Init_Tape_Write
SKIP             BCC KeCL_60
SKIP             PLA
SKIP             LDA #0
SKIP             RTS
              #endif
0000 TRUE     #if VIC
f39b 4c cf e4    JMP Close_Patch   ; go do CLOSE tail
f39e          KeCL_50
f39e b0 2e       BCS ClFi_Ret      ; just exit if error
              #endif

f3a0          KeCL_60
f3a0 a5 b9       LDA SA            ; get secondary address
f3a2 c9 62       CMP #$62
f3a4 d0 0b       BNE KeCL_80
f3a6 a9 05       LDA #$05          ; set logical end of the tape
f3a8 20 e7 f7    JSR TAPE_Write_Header
f3ab 4c b1 f3    JMP KeCL_80       ; restore index and close file
              #endif               ; JIFFY

f3ae          KeCL_70
f3ae 20 da f6    JSR IEC_Close

f3b1          KeCL_80
f3b1 68          PLA               ; restore file index

              ; **********
f3b2            Close_File
              ; **********

f3b2 aa          TAX               ; copy index to file to close

f3b3          ClFi_05
f3b3 c6 98       DEC LDTND         ; decrement open file count
f3b5 e4 98       CPX LDTND         ; compare index with open file count
f3b7 f0 14       BEQ ClFi_10       ; exit if equal, last entry was closing file
f3b9 a4 98       LDY LDTND         ; get open file count as index
f3bb b9 59 02    LDA FILTBL,Y      ; get last+1 logical file number from logical file table
f3be 9d 59 02    STA FILTBL,X      ; save logical file number over closed file
f3c1 b9 63 02    LDA DEVTBL,Y      ; get last+1 device number from device number table
f3c4 9d 63 02    STA DEVTBL,X      ; save device number over closed file
f3c7 b9 6d 02    LDA SECATB,Y      ; get last+1 secondary address from secondary address table
f3ca 9d 6d 02    STA SECATB,X      ; save secondary address over closed file

f3cd          ClFi_10
f3cd 18          CLC

f3ce          ClFi_Ret
f3ce 60          RTS ;Size   29 [Close_File]

              ; ***********
f3cf            Find_File_X
              ; ***********

f3cf a9 00       LDA #0
f3d1 85 90       STA STATUS        ; clear serial status byte
f3d3 8a          TXA               ; copy logical file number to A

              ; ***********
f3d4            Find_File_A
              ; ***********

f3d4 a6 98       LDX LDTND         ; get open file count

f3d6          FiFi_10
f3d6 ca          DEX               ; decrememnt count to give index
f3d7 30 15       BMI GLFS_Ret      ; exit if no files
f3d9 dd 59 02    CMP FILTBL,X      ; compare logical file number with table logical file number
f3dc d0 f8       BNE FiFi_10       ; loop if no match
f3de 60          RTS ;Size   11 [Find_File_A]

              ; *******
f3df            Get_LFS
              ; *******

f3df bd 59 02    LDA FILTBL,X      ; get logical file from logical file table
f3e2 85 b8       STA LA            ; set logical file
f3e4 bd 63 02    LDA DEVTBL,X      ; get device number from device number table
f3e7 85 ba       STA FA            ; set device number
f3e9 bd 6d 02    LDA SECATB,X      ; get secondary address from secondary address table
f3ec 85 b9       STA SA            ; set secondary address

f3ee          GLFS_Ret
f3ee 60          RTS ;Size   16 [Get_LFS]

              ; ************
f3ef            Kernal_CLALL
              ; ************

f3ef a9 00       LDA #0
f3f1 85 98       STA LDTND         ; clear open file count

              ; *************
f3f3            Kernal_CLRCHN
              ; *************

f3f3 a2 03       LDX #$03          ; set X to screen
f3f5 e4 9a       CPX DFLTO         ; compare output device number with screen
f3f7 b0 03       BCS KeCC_10       ; branch if >= screen
f3f9 20 04 ef    JSR Kernal_UNLSN  ; command the serial bus to UNLISTEN

f3fc          KeCC_10
f3fc e4 99       CPX DFLTN         ; compare input device number with screen
f3fe b0 03       BCS KeCC_20       ; branch if >= screen
f400 20 f6 ee    JSR Kernal_UNTLK  ; command the serial bus to UNTALK

f403          KeCC_20
f403 86 9a       STX DFLTO         ; set output device number to screen
f405 a9 00       LDA #$00          ; set for keyboard
f407 85 99       STA DFLTN         ; set input device number to keyboard
f409 60          RTS ;Size   23 [Kernal_CLRCHN]

              ; ***********
f40a            Kernal_OPEN
              ; ***********

f40a a6 b8       LDX LA            ; get logical file number
f40c d0 03       BNE OPEN_05       ; branch if there is a file
f40e 4c 8d f7    JMP Not_Input_File      ; else do not input file error and return

f411          OPEN_05
f411 20 cf f3    JSR Find_File_X
f414 d0 03       BNE OPEN_10       ; branch if file not found
f416 4c 81 f7    JMP File_Already_Open      ; else do file already open error and return

f419          OPEN_10
f419 a6 98       LDX LDTND         ; get open file count
f41b e0 0a       CPX #$0A          ; compare with max
f41d 90 03       BCC OPEN_15       ; branch if less
f41f 4c 7e f7    JMP Too_Many_Files      ; else do too many files error and return

f422          OPEN_15
f422 e6 98       INC LDTND         ; increment open file count
f424 a5 b8       LDA LA            ; get logical file number
f426 9d 59 02    STA FILTBL,X      ; save to logical file table
f429 a5 b9       LDA SA            ; get secondary address
f42b 09 60       ORA #$60          ; OR with the OPEN CHANNEL command
f42d 85 b9       STA SA            ; set secondary address
f42f 9d 6d 02    STA SECATB,X      ; save to secondary address table
f432 a5 ba       LDA FA            ; get device number
f434 9d 63 02    STA DEVTBL,X      ; save to device number table
f437 f0 5a       BEQ OPEN_60       ; do ok exit if keyboard
f439 c9 03       CMP #$03          ; compare device number with screen
f43b f0 56       BEQ OPEN_60       ; do ok exit if screen
f43d 90 05       BCC OPEN_20       ; branch if < screen, tape or RS232
f43f 20 95 f4    JSR IEC_Send_SA_And_Filename
f442 90 4f       BCC OPEN_60       ; do ok exit

f444          OPEN_20
0001 FALSE    #if JIFFY
SKIP             CMP #1            ; tape ?
SKIP             BEQ Jmp_Dev_Not_Present
              #else
f444 c9 02       CMP #2            ; RS232 ?
f446 d0 03       BNE OPEN_25
              #endif
f448 4c c7 f4    JMP RS232_Open

0001 FALSE    #if JIFFY
SKIP          Jiffy_Talk_TkSA
SKIP             JSR UNTLK
SKIP             LDA FA
SKIP             JSR TALK
              #else
f44b          OPEN_25
f44b 20 4d f8    JSR TAPE_Get_Buffer_Address
f44e b0 03       BCS OPEN_30       ; branch if >= $0200
f450 4c 96 f7    JMP Illegal_Jiffy_Device
              #endif

f453          OPEN_30
f453 a5 b9       LDA SA            ; get secondary address
0001 FALSE    #if JIFFY
SKIP             JMP TKSA
SKIP          
SKIP          Jiffy_Transfer_01
SKIP             .BYTE "M-W",$00,$06,$1c ; memory write $0600 - $061b
SKIP          
SKIP          Jiffy_Disk_Code_01   ; $1c bytes drive code
SKIP             LDA $0261
SKIP             STA $07
SKIP             LDA #$12
SKIP             STA $06
SKIP             LDX #0
SKIP             STX $f9
SKIP             JSR $d586 
SKIP             LDY $0267 
SKIP             LDA ($30),Y
SKIP             EOR #$40
SKIP             STA ($30),Y
SKIP             JMP $d58a 
SKIP          
SKIP             .BYTE "M-E",$00,$06            ; memory execute at $0600
SKIP             .BYTE "M-W",$6a,$00,$01        ; memory write   at $006a
SKIP             .BYTE "M-W",$69,$00,$01        ; memory write   at $0069
SKIP             .BYTE $50,$6e,$01,$00,$53,$3a
              #else
f455 29 0f       AND #$0F
f457 d0 1f       BNE OPEN_45
f459 20 94 f8    JSR Wait_For_Play
f45c b0 36       BCS OPEN_Ret      ; exit if STOP was pressed
f45e 20 47 f6    JSR Print_Searching
f461 a5 b7       LDA FNLEN         ; get file name length
f463 f0 0a       BEQ OPEN_40       ; if null file name just go find header
f465 20 67 f8    JSR TAPE_Find_Fileheader
f468 90 18       BCC OPEN_50       ; branch if no error
f46a f0 28       BEQ OPEN_Ret      ; exit if ??

f46c          OPEN_35
f46c 4c 87 f7    JMP File_Not_Found      ; do file not found error and return

f46f          OPEN_40
f46f 20 af f7    JSR TAPE_Find_Any_Header
f472 f0 20       BEQ OPEN_Ret      ; exit if end of tape found
f474 90 0c       BCC OPEN_50
f476 b0 f4       BCS OPEN_35

f478          OPEN_45
f478 20 b7 f8    JSR TAPE_Wait_For_Record
f47b b0 17       BCS OPEN_Ret      ; exit if STOP was pressed
f47d a9 04       LDA #$04          ; set data file header
f47f 20 e7 f7    JSR TAPE_Write_Header

f482          OPEN_50
f482 a9 bf       LDA #$BF
f484 a4 b9       LDY SA            ; get secondary address
f486 c0 60       CPY #$60
f488 f0 07       BEQ OPEN_55
f48a a0 00       LDY #0
f48c a9 02       LDA #$02
f48e 91 b2       STA (TAPE1),Y     ; save to tape buffer
f490 98          TYA               ; clear A
              #endif

f491          OPEN_55
f491 85 a6       STA BUFPNT        ; save tape buffer index

f493          OPEN_60
f493 18          CLC               ; flag ok

f494          OPEN_Ret
f494 60          RTS ;Size  139 [Kernal_OPEN]

              ; ************************
f495            IEC_Send_SA_And_Filename
              ; ************************

f495 a5 b9       LDA SA            ; get secondary address
0001 FALSE    #if C64
SKIP             BMI OPEN_60       ; ok exit if negative
              #endif
0000 TRUE     #if VIC
f497 30 2c       BMI ISSF_40       ; ok exit if negative
              #endif
f499 a4 b7       LDY FNLEN         ; get file name length
0001 FALSE    #if C64
SKIP             BEQ OPEN_60       ; ok exit if null
              #endif
0000 TRUE     #if VIC
f49b f0 28       BEQ ISSF_40       ; ok exit if null
              #endif
0001 FALSE    #if C64
SKIP             LDA #0
SKIP             STA STATUS
              #endif
f49d a5 ba       LDA FA            ; get device number
f49f 20 17 ee    JSR Kernal_LISTEN ; command devices on the serial bus to LISTEN
f4a2 a5 b9       LDA SA            ; get the secondary address
f4a4 09 f0       ORA #$F0          ; OR with the OPEN command
f4a6 20 c0 ee    JSR Kernal_SECOND ; send secondary address after LISTEN
f4a9 a5 90       LDA STATUS        ; get serial status byte
f4ab 10 05       BPL ISSF_10       ; branch if device present

f4ad          Pop_Dev_Not_Present
f4ad 68          PLA               ; else dump calling address low byte
f4ae 68          PLA               ; dump calling address high byte

f4af          Jmp_Dev_Not_Present
f4af 4c 8a f7    JMP Dev_Not_Present      ; do device not present error and return

f4b2          ISSF_10
f4b2 a5 b7       LDA FNLEN         ; get file name length
f4b4 f0 0c       BEQ ISSF_30       ; branch if null name

f4b6 a0 00       LDY #0
f4b8          ISSF_20
f4b8 b1 bb       LDA (FNADR ),Y    ; get file name byte
f4ba 20 e4 ee    JSR Kernal_CIOUT  ; output a byte to the serial bus
f4bd c8          INY
f4be c4 b7       CPY FNLEN         ; compare with file name length
f4c0 d0 f6       BNE ISSF_20       ; loop if not all done

f4c2          ISSF_30
0001 FALSE    #if C64
SKIP             JMP IClo_10
              #endif
0000 TRUE     #if VIC
f4c2 20 04 ef    JSR Kernal_UNLSN
f4c5          ISSF_40
f4c5 18          CLC               ; flag ok
f4c6 60          RTS ;Size   50 [IEC_Send_SA_And_Filename]
              #endif

              ; ==========
f4c7            RS232_Open
              ; ==========

0001 FALSE    #if C64
SKIP             JSR ROPN_50
              #endif
0000 TRUE     #if VIC
f4c7 a9 06       LDA #$06          ; IIII IOOI, DTR and RTS only as outputs
f4c9 8d 12 91    STA VIA1_DDRB     ; set VIA 1 DDRB
f4cc 8d 10 91    STA RS2_DSR_CTS   ; set VIA 1 DRB, DTR and RTS high
f4cf a9 ee       LDA #$EE          ; CB2 high, CB1 negative edge, CA2 high, CA1 negative edge
f4d1 8d 1c 91    STA VIA1_PCR      ; set VIA 1 PCR
f4d4 a0 00       LDY #0
              #endif
f4d6 8c 97 02    STY RSSTAT        ; clear RS232 status byte

f4d9          ROPN_05
f4d9 c4 b7       CPY FNLEN         ; compare with file name length
f4db f0 0a       BEQ ROPN_10       ; exit loop if done
f4dd b1 bb       LDA (FNADR ),Y    ; get file name byte
f4df 99 93 02    STA M51CTR  ,Y    ; copy to 6551 register set
f4e2 c8          INY
f4e3 c0 04       CPY #$04          ; compare with $04
f4e5 d0 f2       BNE ROPN_05       ; loop if not to 4 yet

f4e7          ROPN_10
f4e7 20 27 f0    JSR RS232_Set_Data_Bits
f4ea 8e 98 02    STX BITNUM        ; save bit count
f4ed ad 93 02    LDA M51CTR        ; get pseudo 6551 control register
f4f0 29 0f       AND #$0F          ; mask 0000 xxxx, baud rate
0001 FALSE    #if C64
SKIP             BEQ ROPN_30
              #endif
0000 TRUE     #if VIC
f4f2 d0 00       BNE ROPN_15       ; quirk
              #endif

f4f4          ROPN_15
f4f4 0a          ASL A             ; * 2
f4f5 aa          TAX               ; copy to index
0001 FALSE    #if C64
SKIP             LDA TVSFLG        ; TV flag
SKIP             BNE ROPN_20       ; 0 = PAL
SKIP             LDY Baudrate-1,X
SKIP             LDA Baudrate-2,X
SKIP             JMP ROPN_25
SKIP          
SKIP          ROPN_20
SKIP             LDY BaudNTSC-1,X
SKIP             LDA BaudNTSC-2,X
SKIP          
SKIP          ROPN_25
SKIP             STY M51AJB+1
SKIP             STA M51AJB
SKIP          
SKIP          ROPN_30
SKIP             LDA M51AJB
SKIP             ASL A
SKIP             JSR Set_Baud_Rate
              #endif
0000 TRUE     #if VIC
f4f6 bd 5a ff    LDA Baudrate-2,X  ; get timer constant low byte
f4f9 0a          ASL A             ; * 2
f4fa a8          TAY               ; copy to Y
f4fb bd 5b ff    LDA Baudrate-1,X  ; get timer constant high byte
f4fe 2a          ROL A             ; * 2
f4ff 48          PHA               ; save it
f500 98          TYA               ; get timer constant low byte back
f501 69 c8       ADC #$C8          ; + $C8, carry cleared by previous ROL
f503 8d 99 02    STA BAUDOF        ; save bit cell time low byte
f506 68          PLA               ; restore high  byte
f507 69 00       ADC #$00          ; add carry
f509 8d 9a 02    STA BAUDOF+1      ; save bit cell time high byte
              #endif
f50c ad 94 02    LDA M51CDR        ; get pseudo 6551 command register
f50f 4a          LSR A             ; shift b0 into Cb
f510 90 09       BCC ROPN_35       ; branch if 3 line interface
0001 FALSE    #if C64
SKIP             LDA  CIA2_PRB
              #endif
0000 TRUE     #if VIC
f512 ad 20 91    LDA VIA2_DATB     ; get VIA 2 DRB, this is wrong, the adress should be
              #endif
f515 0a          ASL A             ; shift DSR into Cb
f516 b0 03       BCS ROPN_35       ; branch if DSR = 1
0001 FALSE    #if C64
SKIP             JSR RS232_Set_Status_No_Signal
              #endif
0000 TRUE     #if VIC
f518 4c 16 f0    JMP RS232_No_DSR_Signal
              #endif

f51b          ROPN_35
f51b ad 9b 02    LDA RIDBE         ; get index to Rx buffer end
f51e 8d 9c 02    STA RIDBS         ; set index to Rx buffer start, clear Rx buffer
f521 ad 9e 02    LDA RODBE         ; get index to Tx buffer end
f524 8d 9d 02    STA RODBS         ; set index to Tx buffer start, clear Tx buffer
f527 20 75 fe    JSR Read_Memtop
f52a a5 f8       LDA RXPTR+1       ; get Rx buffer pointer high byte
f52c d0 05       BNE ROPN_40       ; branch if buffer already set
f52e 88          DEY               ; decrement top of memory high byte, 256 byte buffer
f52f 84 f8       STY RXPTR+1       ; set Rx buffer pointer high byte
f531 86 f7       STX RXPTR         ; set Rx buffer pointer low byte

f533          ROPN_40
f533 a5 fa       LDA TXPTR+1       ; get Tx buffer pointer high byte
f535 d0 05       BNE ROPN_45       ; branch if buffer already set
f537 88          DEY               ; decrement Rx buffer pointer high byte, 256 byte buffer
f538 84 fa       STY TXPTR+1       ; set Tx buffer pointer high byte
f53a 86 f9       STX TXPTR         ; set Tx buffer pointer low byte

f53c          ROPN_45
f53c 38          SEC
f53d a9 f0       LDA #$F0
f53f 4c 7b fe    JMP Set_memtop

0001 FALSE    #if C64
SKIP          ROPN_50
SKIP             LDA #$7F
SKIP             STA CIA2_ICR
SKIP             LDA #6
SKIP             STA CIA2_DDRB
SKIP             STA CIA2_PRB
SKIP             LDA #4
SKIP             ORA CIA2_PRA
SKIP             STA CIA2_PRA
SKIP             LDY #0
SKIP             STY ENABL
SKIP             RTS
              #endif

              ; ***********
f542            Kernal_LOAD
              ; ***********

                 STXY(MEMUSS)      ; set kernal setup pointer
f542 86 c3       STX MEMUSS
f544 84 c4       STY MEMUSS+1

f546 6c 30 03    JMP (ILOAD)       ; do LOAD vector, usually points to Default_LOAD

              ; ************
f549            Default_LOAD
              ; ************

f549 85 93       STA VERCKK        ; save load/verify flag
f54b a9 00       LDA #0
f54d 85 90       STA STATUS        ; clear serial status byte
f54f a5 ba       LDA FA            ; get device number
f551 d0 03       BNE DLOA_10       ; branch if not keyboard

f553          DLOA_05
f553 4c 96 f7    JMP Illegal_Jiffy_Device

f556          DLOA_10
f556 c9 03       CMP #$03          ; compare device number with screen
f558 f0 f9       BEQ DLOA_05       ; if screen go do illegal device number and return
0001 FALSE    #if JIFFY
SKIP             BCC DLOA_05       ; no tape with jiffy dos
              #else
f55a 90 6e       BCC DLOA_55       ; branch if less than screen
              #endif
f55c a4 b7       LDY FNLEN         ; get file name length
f55e d0 03       BNE DLOA_15       ; branch if not null name
0001 FALSE    #if JIFFY
SKIP             JMP Jiffy_Default_Filename
              #else
f560 4c 93 f7    JMP Missing_File_Name
              #endif

f563          DLOA_15
0001 FALSE    #if C64
SKIP             LDX SA
SKIP             JSR Print_Searching
              #endif
0000 TRUE     #if VIC
f563 20 bc e4    JSR Get_SA_Print_Searching
              #endif
f566 a9 60       LDA #$60
f568 85 b9       STA SA            ; save the secondary address
f56a 20 95 f4    JSR IEC_Send_SA_And_Filename
f56d a5 ba       LDA FA            ; get device number
f56f 20 14 ee    JSR Kernal_TALK   ; command a serial bus device to TALK
f572 a5 b9       LDA SA            ; get secondary address
f574 20 ce ee    JSR Kernal_TKSA   ; send secondary address after TALK
f577 20 19 ef    JSR Kernal_ACPTR  ; input a byte from the serial bus
f57a 85 ae       STA EAL           ; save program start address low byte
f57c a5 90       LDA STATUS        ; get serial status byte
f57e 4a          LSR A             ; shift time out read ..
f57f 4a          LSR A             ; .. into carry bit
f580 b0 45       BCS DLOA_50       ; if timed out go do file not found error and return
0001 FALSE    #if JIFFY
SKIP             JSR Jiffy_ACPTR_Load_Check
              #else
f582 20 19 ef    JSR Kernal_ACPTR  ; input a byte from the serial bus
              #endif
f585 85 af       STA EAL+1         ; save program start address high byte
0001 FALSE    #if C64
SKIP             TXA
SKIP             BNE DLOA_20
SKIP             LDA MEMUSS
SKIP             STA EAL
SKIP             LDA MEMUSS+1
SKIP             STA EAL+1
SKIP          
SKIP          DLOA_20
0001 FALSE    #if JIFFY
SKIP             JMP Jiffy_fac4
              #else
SKIP             JSR Display_LOADING_Or_VERIFYING
              #endif
              #endif
0000 TRUE     #if VIC
0001 FALSE    #if JIFFY
SKIP             JMP Jiffy_fb05
              #else
f587 20 c1 e4    JSR Set_Load_Address; set LOAD address if secondary address = 0
              #endif
              #endif

f58a          DLOA_25
0001 FALSE    #if JIFFY
SKIP             JSR STOP
SKIP             BNE DLOA_26 
SKIP             JMP SAVE_50
SKIP          
SKIP          DLOA_26
SKIP             JSR Jiffy_ACPTR
SKIP             LDA STATUS
SKIP             AND #$fd
SKIP             CMP STATUS
SKIP             STA STATUS
SKIP             BNE DLOA_25
SKIP             LDY #0
SKIP             LDX TSFCNT
SKIP             LDA TBTCNT
SKIP             CPY VERCKK
SKIP             BEQ DLOA_31
              #else
f58a a9 fd       LDA #$FD          ; mask xxxx xx0x, clear time out read bit
f58c 25 90       AND STATUS        ; mask serial status byte
f58e 85 90       STA STATUS        ; set serial status byte
f590 20 e1 ff    JSR STOP          ; Check if stop key is pressed
f593 d0 03       BNE DLOA_30       ; branch if not [STOP]
f595 4c cb f6    JMP SAVE_50       ; else close the serial bus device and flag stop

f598          DLOA_30
f598 20 19 ef    JSR Kernal_ACPTR  ; input a byte from the serial bus
f59b aa          TAX               ; copy byte
f59c a5 90       LDA STATUS        ; get serial status byte
f59e 4a          LSR A             ; shift time out read ..
f59f 4a          LSR A             ; .. into carry bit
f5a0 b0 e8       BCS DLOA_25       ; if timed out go ??
f5a2 8a          TXA               ; copy received byte back
f5a3 a4 93       LDY VERCKK        ; get load/verify flag
f5a5 f0 0c       BEQ DLOA_35       ; branch if load
f5a7 a0 00       LDY #0
              #endif
f5a9 d1 ae       CMP (EAL),Y       ; compare byte with previously loaded byte
0001 FALSE    #if JIFFY
SKIP             BEQ DLOA_32 
SKIP             JSR Flag_Read_Error 
SKIP            .BYTE $2c
SKIP          
SKIP          DLOA_31
SKIP             STA (EAL),Y
SKIP          
SKIP          DLOA_32
SKIP             STX TSFCNT
              #else
f5ab f0 08       BEQ DLOA_40       ; branch if match
f5ad a9 10       LDA #$10          ; flag read error
f5af 20 6a fe    JSR Ora_Status
f5b2 2c          .byte   $2C

f5b3          DLOA_35
f5b3 91 ae       STA (EAL),Y       ; save byte to memory
              #endif

f5b5          DLOA_40
f5b5 e6 ae       INC EAL           ; increment save pointer low byte
f5b7 d0 02       BNE DLOA_45       ; if no rollover skip the high byte increment
f5b9 e6 af       INC EAL+1         ; else increment save pointer high byte

f5bb          DLOA_45
f5bb 24 90       BIT STATUS        ; test serial status byte
f5bd 50 cb       BVC DLOA_25       ; loop if not end of file

f5bf          DLOA_47
f5bf 20 f6 ee    JSR Kernal_UNTLK  ; command the serial bus to UNTALK
f5c2 20 da f6    JSR IEC_Close
0001 FALSE    #if JIFFY & VIC
SKIP             BCC DLOA_95
              #else
f5c5 90 7a       BCC DLOA_94       ; if OK exit
              #endif

f5c7          DLOA_50
f5c7 4c 87 f7    JMP File_Not_Found

f5ca          DLOA_55
0001 FALSE    #if JIFFY
SKIP          
SKIP          ; *************
SKIP            Jiffy_Exec_At
SKIP          ; *************
SKIP          
SKIP             LDA FNLEN         
SKIP             BEQ JLTF_10       ; no filename
SKIP             LDA (FNADR),Y
SKIP             CMP #'$'          ; display directory ?
SKIP             BEQ JLBF_10 
0000 TRUE     #if VIC
SKIP             JMP Jiffy_eb08
              #else
SKIP             JMP Jiffy_fc9a 
              #endif
SKIP          
SKIP          ; ********************
SKIP            Jiffy_List_Text_File ; Jiffy_List_Text_File
SKIP          ; ********************
SKIP          
SKIP             TYA               ; (Y) contains the command number
SKIP          
SKIP          JLTF_05
SKIP             PHA               ; save command
SKIP             JSR Jiffy_Open_Command_10
SKIP             PLA               ; retrieve
SKIP          
SKIP          JLTF_10
SKIP             STA BUFPNT        ; store
SKIP          
SKIP          JLTF_20
SKIP             JSR Jiffy_Read_Text_Line    ; input charaters to buffer (filename area)
SKIP             BNE JLTF_Ret      ; exit if errors occured
SKIP             LDA BUFPNT        ; get command number, should be $0f
SKIP             PHP   
SKIP             BEQ JLTF_30
SKIP             JSR Jiffy_CHRIN
SKIP             BEQ JLTF_40       ; exit if zero
SKIP          
SKIP          JLTF_30
SKIP             JSR JiDi_50 
SKIP             JSR PrSe_10       ; print filename, ie. the input buffer
0000 TRUE     #if VIC
SKIP             LDA STKEY         ; STKEY FLAG, test if <STOP> is pressed
SKIP             LSR A
SKIP             BCC JLTF_40       ; exit
              #else
SKIP             BIT STKEY         ; STKEY FLAG, test if <STOP> is pressed
SKIP             BPL JLTF_40       ; exit
              #endif
SKIP             PLP   
SKIP             BNE JLTF_20 
SKIP             BVC JLTF_20 
SKIP             .BYTE $24         ; skip PLP statement
SKIP          
SKIP          JLTF_40
SKIP             PLP   
SKIP          
SKIP          JLTF_Ret
SKIP             RTS   
SKIP          
SKIP          ; *********************
SKIP            Jiffy_List_Basic_File 
SKIP          ; *********************
SKIP          
SKIP             LDX #$6c          ; get byte for SA, list basic program
SKIP             .BYTE $2c         ; skip next statement
SKIP          
SKIP          JLBF_10
SKIP             LDX #$60          ; get byte for SA, list directory
SKIP             JSR Jiffy_Open_Command_20    ; open file with current parameters
0001 FALSE    #if C64
SKIP             LDA #$39          ; setup IERROR vector to point to $f739 (RTS)
              #endif
0000 TRUE     #if VIC
SKIP             LDA #$bc          ; setup IERROR vector to point to $f739 (RTS)
              #endif
SKIP             STA IERROR
SKIP             LDY #$fc          ; set up (Y) pointer to 252
SKIP             JSR Jiffy_fca6    ; skip load adddress
SKIP          
SKIP          JLBF_20
SKIP             LDY #0
SKIP          
SKIP          JLBF_30
SKIP             JSR Jiffy_fca6    ; read 254 bytes, store in input buffer
SKIP             BVS JLBF_40       ; exit on EOF
SKIP             CPY #2            ; exit if nothing read
SKIP             BEQ JLBF_40
SKIP             CPY #6
SKIP             BCC JLBF_30
0001 FALSE    #if C64
SKIP             LDX FNADR         ; Fr_Bot = FNADR
SKIP             STX TMPPTC
SKIP             LDX FNADR+1
SKIP             STX TMPPTC+1
SKIP             LDY #1
SKIP             STA (TMPPTC),Y
              #endif
0000 TRUE     #if VIC
SKIP             LDX FNADR+1       ; Fr_Bot = FNADR
SKIP             STX TMPPTC+1
SKIP             LDA FNADR  
SKIP             STA TMPPTC  
SKIP             JSR Jiffy_fbc8
              #endif
SKIP             JSR LIST_12       ; part of Basic LIST routine
SKIP             JSR JiDi_50
SKIP             JSR LIST_17
0001 FALSE    #if C64
SKIP             BIT STKEY
SKIP             BMI JLBF_20       ; continue if no STOP key pressed
              #endif
0000 TRUE     #if VIC
SKIP             LDA STKEY
SKIP             LSR A
SKIP             BCS JLBF_20
              #endif
SKIP          
SKIP          JLBF_40
0001 FALSE    #if C64
SKIP             LDA #$63          ; restore IERROR vector to $f763
              #endif
0000 TRUE     #if VIC
SKIP             LDA #$e6          ; restore IERROR vector to 
              #endif
SKIP             STA IERROR
SKIP             RTS
0000 TRUE     #if VIC & !JIFFY
SKIP             NOP
              #endif
              #else
0001 FALSE    #if C64
SKIP             LSR A
SKIP             BCS DLOA_60
SKIP             JMP Illegal_Jiffy_Device
              #endif
0000 TRUE     #if VIC
f5ca c9 02       CMP #$02          ; compare device with RS232 device
f5cc d0 03       BNE DLOA_60       ; if not RS232 device continue
f5ce 4c b9 f0    JMP RRec_70       ; else do illegal device number and return
              #endif

f5d1          DLOA_60
f5d1 20 4d f8    JSR TAPE_Get_Buffer_Address
f5d4 b0 03       BCS DLOA_65       ; branch if >= $0200
f5d6 4c 96 f7    JMP Illegal_Jiffy_Device

f5d9          DLOA_65
f5d9 20 94 f8    JSR Wait_For_Play
f5dc b0 68       BCS DLOA_Ret      ; exit if STOP was pressed
f5de 20 47 f6    JSR Print_Searching

f5e1          DLOA_70
f5e1 a5 b7       LDA FNLEN         ; get file name length
f5e3 f0 09       BEQ DLOA_75
f5e5 20 67 f8    JSR TAPE_Find_Fileheader
f5e8 90 0b       BCC DLOA_80       ; if no error continue
f5ea f0 5a       BEQ DLOA_Ret      ; exit if ??
f5ec b0 d9       BCS DLOA_50       ; branch always

f5ee          DLOA_75
f5ee 20 af f7    JSR TAPE_Find_Any_Header
f5f1 f0 53       BEQ DLOA_Ret      ; exit if ??
f5f3 b0 d2       BCS DLOA_50

f5f5          DLOA_80
f5f5 a5 90       LDA STATUS        ; get serial status byte
f5f7 29 10       AND #$10          ; mask 000x 0000, read error
f5f9 38          SEC               ; flag fail
f5fa d0 4a       BNE DLOA_Ret      ; if read error just exit
f5fc e0 01       CPX #$01
f5fe f0 11       BEQ DLOA_90
f600 e0 03       CPX #$03
f602 d0 dd       BNE DLOA_70

f604          DLOA_85
f604 a0 01       LDY #$01
f606 b1 b2       LDA (TAPE1),Y
f608 85 c3       STA MEMUSS
f60a c8          INY
f60b b1 b2       LDA (TAPE1),Y
f60d 85 c4       STA MEMUSS+1
f60f b0 04       BCS DLOA_92

f611          DLOA_90
f611 a5 b9       LDA SA
f613 d0 ef       BNE DLOA_85

f615          DLOA_92
f615 a0 03       LDY #$03
f617 b1 b2       LDA (TAPE1),Y
f619 a0 01       LDY #$01
f61b f1 b2       SBC (TAPE1),Y
f61d aa          TAX
f61e a0 04       LDY #$04
f620 b1 b2       LDA (TAPE1),Y
f622 a0 02       LDY #$02
f624 f1 b2       SBC (TAPE1),Y
f626 a8          TAY
f627 18          CLC
f628 8a          TXA
f629 65 c3       ADC MEMUSS
f62b 85 ae       STA EAL
f62d 98          TYA
f62e 65 c4       ADC MEMUSS+1
f630 85 af       STA EAL+1
f632 a5 c3       LDA MEMUSS
f634 85 c1       STA STAL
f636 a5 c4       LDA MEMUSS+1
f638 85 c2       STA STAL+1
f63a 20 6a f6    JSR Display_LOADING_Or_VERIFYING
f63d 20 c9 f8    JSR TAPE_Read
f640 24          .byte   $24       ; skip CLC statement
              #endif

f641          DLOA_94
f641 18          CLC               ; flag ok

f642          DLOA_95
f642 a6 ae       LDX EAL           ; get the LOAD end pointer low byte
f644 a4 af       LDY EAL+1         ; get the LOAD end pointer high byte

f646          DLOA_Ret
f646 60          RTS ;Size  254 [Default_LOAD]

              ; ***************
f647            Print_Searching
              ; ***************

f647 a5 9d       LDA MSGFLG
f649 10 1e       BPL PrSe_Ret
f64b a0 0c       LDY #Msg_Searching-Msg_Start
f64d 20 e6 f1    JSR Display_Kernal_IO_Message
f650 a5 b7       LDA FNLEN
f652 f0 15       BEQ PrSe_Ret
f654 a0 17       LDY #Msg_FOR-Msg_Start
f656 20 e6 f1    JSR Display_Kernal_IO_Message

f659          PrSe_10
f659 a4 b7       LDY FNLEN
f65b f0 0c       BEQ PrSe_Ret

f65d a0 00       LDY #0
f65f          PrSe_20
f65f b1 bb       LDA (FNADR ),Y
f661 20 d2 ff    JSR CHROUT
f664 c8          INY
f665 c4 b7       CPY FNLEN
f667 d0 f6       BNE PrSe_20

f669          PrSe_Ret
f669 60          RTS ;Size   35 [Print_Searching]

              ; ****************************
f66a            Display_LOADING_Or_VERIFYING
              ; ****************************

f66a a0 49       LDY #Msg_Loading-Msg_Start
f66c a5 93       LDA VERCKK        ; get load/verify flag
f66e f0 02       BEQ DLV_10        ; branch if load
f670 a0 59       LDY #Msg_Verifying-Msg_Start

f672          DLV_10
f672 4c e2 f1    JMP Display_Direct_Msg

              ; ***********
f675            Kernal_SAVE
              ; ***********

f675 86 ae       STX EAL           ; save end address low byte
f677 84 af       STY EAL+1         ; save end address high byte
f679 aa          TAX               ; copy index to start pointer
f67a b5 00       LDA 0,X           ; get start address low byte
f67c 85 c1       STA STAL          ; set I/O start addresses low byte
f67e b5 01       LDA 1,X           ; get start address high byte
f680 85 c2       STA STAL+1        ; set I/O start addresses high byte
f682 6c 32 03    JMP (ISAVE)       ; go save, usually points to Default_SAVE

              ; ************
f685            Default_SAVE
              ; ************

f685 a5 ba       LDA FA            ; get device number
f687 d0 03       BNE SAVE_20       ; branch if not keyboard

f689          SAVE_10
f689 4c 96 f7    JMP Illegal_Jiffy_Device

f68c          SAVE_20
f68c c9 03       CMP #$03          ; compare device number with screen
f68e f0 f9       BEQ SAVE_10       ; if screen do illegal device number and return
0001 FALSE    #if JIFFY
SKIP             BCC SAVE_10
              #else
f690 90 5f       BCC IClo_30      ; branch if < screen
              #endif
f692 a9 61       LDA #$61          ; set secondary address to $01
f694 85 b9       STA SA            ; save secondary address
f696 a4 b7       LDY FNLEN         ; get file name length
f698 d0 03       BNE SAVE_30       ; branch if filename not null

f69a          Jmp_Missing_Filename
f69a 4c 93 f7    JMP Missing_File_Name      ; else do missing file name error and return

f69d          SAVE_30
f69d 20 95 f4    JSR IEC_Send_SA_And_Filename
f6a0 20 28 f7    JSR Display_SAVING_Filename
f6a3 a5 ba       LDA FA            ; get device number
f6a5 20 17 ee    JSR Kernal_LISTEN ; command devices on the serial bus to LISTEN
f6a8 a5 b9       LDA SA            ; get secondary address
f6aa 20 c0 ee    JSR Kernal_SECOND ; send secondary address after LISTEN
f6ad a0 00       LDY #0
f6af 20 d2 fb    JSR Set_IO_Start
f6b2 a5 ac       LDA SAL           ; get buffer address low byte
f6b4 20 e4 ee    JSR Kernal_CIOUT  ; output a byte to the serial bus
f6b7 a5 ad       LDA SAL+1         ; get buffer address high byte
f6b9 20 e4 ee    JSR Kernal_CIOUT  ; output a byte to the serial bus

f6bc          SAVE_40
f6bc 20 11 fd    JSR Check_IO_End
f6bf b0 16       BCS SAVE_70       ; go do UNLISTEN if at end
f6c1 b1 ac       LDA (SAL),Y       ; get byte from buffer
f6c3 20 e4 ee    JSR Kernal_CIOUT  ; output a byte to the serial bus
f6c6 20 e1 ff    JSR STOP          ; Check if stop key is pressed
f6c9 d0 07       BNE SAVE_60       ; if stop not pressed go increment pointer and loop for next

f6cb          SAVE_50
f6cb 20 da f6    JSR IEC_Close
f6ce a9 00       LDA #0
f6d0 38          SEC               ; flag stop
f6d1 60          RTS ;Size   77 [Default_SAVE]

f6d2          SAVE_60
f6d2 20 1b fd    JSR Inc_SAL_Word
f6d5 d0 e5       BNE SAVE_40       ; loop, branch always

f6d7          SAVE_70
f6d7 20 04 ef    JSR Kernal_UNLSN  ; command the serial bus to UNLISTEN

              ; *********
f6da            IEC_Close
              ; *********

f6da 24 b9       BIT SA            ; test the secondary address
f6dc 30 11       BMI IClo_20       ; if already closed just exit
f6de a5 ba       LDA FA            ; get the device number
f6e0 20 17 ee    JSR Kernal_LISTEN ; command devices on the serial bus to LISTEN
f6e3 a5 b9       LDA SA            ; get secondary address
f6e5 29 ef       AND #$EF          ; mask the channel number
f6e7 09 e0       ORA #$E0          ; OR with the CLOSE command
f6e9 20 c0 ee    JSR Kernal_SECOND ; send secondary address after LISTEN

f6ec          IClo_10
f6ec 20 04 ef    JSR Kernal_UNLSN  ; command the serial bus to UNLISTEN

f6ef          IClo_20
f6ef 18          CLC               ; flag ok
f6f0 60          RTS ;Size   23 [IEC_Close]

0001 FALSE    #if JIFFY
SKIP          ; **********************
SKIP            Jiffy_Default_Filename
SKIP          ; **********************
SKIP          
SKIP             LDA NDX
SKIP             BEQ Jmp_Missing_Filename
SKIP             LDA #2
SKIP             STA SA
SKIP             LDX #<[Jiffy_F1+2]
SKIP             LDY #>[Jiffy_F1+2]
SKIP             JSR SETNAM
SKIP             JMP DLOA_15
SKIP          
SKIP          ; *****
SKIP            Jf66b
SKIP          ; *****
SKIP          
SKIP             LDX #$33
SKIP             LDY #4
SKIP             JMP Jiffy_Char_Command
SKIP          
SKIP          ; Function key assignment
SKIP          
SKIP          Jiffy_F1  .BYTE "@$:*\r",0           ; directory
SKIP          Jiffy_F3  .BYTE "/",0                ; load
SKIP          Jiffy_F5  .BYTE "^",0                ; save
SKIP          Jiffy_F7  .BYTE "%",0                ; load ML
SKIP          Jiffy_F2  .BYTE "@D",0
SKIP          Jiffy_F4  .BYTE "@T",0
SKIP          Jiffy_F6  .BYTE "_",0
SKIP          Jiffy_F8  .BYTE "@  ",QUOTE,"S:",0
0000 TRUE     #if VIC
SKIP             .byte $24
              #endif
              #else
f6f1          IClo_30
0001 FALSE    #if C64
SKIP             LSR A
SKIP             BCS IClo_40
SKIP             JMP Illegal_Jiffy_Device
              #endif
0000 TRUE     #if VIC
f6f1 c9 02       CMP #$02          ; compare device with RS232 device
f6f3 d0 03       BNE IClo_40       ; branch if not RS232 device
f6f5 4c b9 f0    JMP RRec_70       ; else do illegal device number and return
              #endif

f6f8          IClo_40
f6f8 20 4d f8    JSR TAPE_Get_Buffer_Address
f6fb 90 8c       BCC SAVE_10
f6fd 20 b7 f8    JSR TAPE_Wait_For_Record
f700 b0 25       BCS IClo_Ret      ; exit if STOP was pressed
f702 20 28 f7    JSR Display_SAVING_Filename
f705 a2 03       LDX #$03          ; set header for a non relocatable program file
f707 a5 b9       LDA SA            ; get secondary address
f709 29 01       AND #$01          ; mask non relocatable bit
f70b d0 02       BNE IClo_50       ; branch if non relocatable program
f70d a2 01       LDX #$01          ; else set header for a relocatable program file

f70f          IClo_50
f70f 8a          TXA               ; copy header type to A
f710 20 e7 f7    JSR TAPE_Write_Header
f713 b0 12       BCS IClo_Ret      ; exit if error
f715 20 e6 f8    JSR TAPE_Write_With_Lead
f718 b0 0d       BCS IClo_Ret      ; exit if error
f71a a5 b9       LDA SA            ; get secondary address
f71c 29 02       AND #$02          ; mask end of tape flag
f71e f0 06       BEQ IClo_60       ; branch if not end of tape
f720 a9 05       LDA #$05          ; else set logical end of the tape
f722 20 e7 f7    JSR TAPE_Write_Header
f725 24          .byte   $24       ; skip next command
              #endif

f726          IClo_60
f726 18          CLC               ; flag ok

f727          IClo_Ret
f727 60          RTS ;Size   78 [IEC_Close]

              ; ***********************
f728            Display_SAVING_Filename
              ; ***********************

f728 a5 9d       LDA MSGFLG        ; get message mode flag
f72a 10 fb       BPL IClo_Ret      ; exit if control messages off
f72c a0 51       LDY #Msg_Saving-Msg_Start
f72e 20 e6 f1    JSR Display_Kernal_IO_Message
f731 4c 59 f6    JMP PrSe_10      ; print file name and return

              ; ************
f734            Kernal_UDTIM       ; Update the system clock
              ; ************

f734 a2 00       LDX #$00          ; clear X
f736 e6 a2       INC JIFFYL        ; increment jiffy low byte
f738 d0 06       BNE UDTI_10       ; if no rollover skip the mid byte increment
f73a e6 a1       INC JIFFYM        ; increment jiffy mid byte
f73c d0 02       BNE UDTI_10       ; if no rollover skip the high byte increment
f73e e6 a0       INC JIFFYH        ; increment jiffy high byte

f740          UDTI_10
f740 38          SEC
f741 a5 a2       LDA JIFFYL        ; get jiffy clock low byte
f743 e9 01       SBC #$01          ; subtract $4F1A01 low byte
f745 a5 a1       LDA JIFFYM        ; get jiffy clock mid byte
f747 e9 1a       SBC #$1A          ; subtract $4F1A01 mid byte
f749 a5 a0       LDA JIFFYH        ; get jiffy clock high byte
f74b e9 4f       SBC #$4F          ; subtract $4F1A01 high byte
f74d 90 06       BCC Look_For_Special_Keys
f74f 86 a0       STX JIFFYH        ; clear jiffies high byte
f751 86 a1       STX JIFFYM        ; clear jiffies mid byte
f753 86 a2       STX JIFFYL        ; clear jiffies low byte

              ; *********************
f755            Look_For_Special_Keys
              ; *********************

f755 ad 2f 91    LDA KEYB_ROWN     ; get VIA 2 DRA, keyboard row, no handshake
f758 cd 2f 91    CMP KEYB_ROWN     ; compare with self
f75b d0 f8       BNE Look_For_Special_Keys
0001 FALSE    #if C64
SKIP             TAX
SKIP             BMI LFSK_20
SKIP             LDX #$bd
SKIP             STX KEYB_COL
SKIP          
SKIP          LFSK_10
SKIP             LDX KEYB_ROW
SKIP             CPX KEYB_ROW
SKIP             BNE LFSK_10
SKIP             STA KEYB_COL
SKIP             INX
SKIP             BNE LFSK_Ret
              #endif

f75d          LFSK_20
f75d 85 91       STA STKEY         ; save VIA 2 DRA, keyboard row

f75f          LFSK_Ret
f75f 60          RTS ;Size   11 [Look_For_Special_Keys]

              ; ************
f760            Kernal_RDTIM       ; Read system clock
              ; ************

f760 78          SEI               ; disable interrupts
f761 a5 a2       LDA JIFFYL        ; get jiffy clock low byte
f763 a6 a1       LDX JIFFYM        ; get jiffy clock mid byte
f765 a4 a0       LDY JIFFYH        ; get jiffy clock high byte

              ; *************
f767            Kernal_SETTIM      ; Set the system clock
              ; *************

f767 78          SEI               ; disable interrupts
f768 85 a2       STA JIFFYL        ; save jiffy clock low byte
f76a 86 a1       STX JIFFYM        ; save jiffy clock mid byte
f76c 84 a0       STY JIFFYH        ; save jiffy clock high byte
f76e 58          CLI               ; enable interrupts
f76f 60          RTS ;Size    9 [Kernal_SETTIM]

              ; ***********
f770            Kernal_STOP        ; Check if stop key is pressed
              ; ***********

f770 a5 91       LDA STKEY         ; get keyboard row
0001 FALSE    #if C64
SKIP             CMP #$7f
              #endif
0000 TRUE     #if VIC
f772 c9 fe       CMP #$FE          ; compare with r0 down
              #endif
f774 d0 07       BNE STOP_Ret      ; branch if not just r0
f776 08          PHP               ; save status
f777 20 cc ff    JSR CLRCHN        ; Clear I/O channels
f77a 85 c6       STA NDX           ; save keyboard buffer length
f77c 28          PLP               ; restore status

f77d          STOP_Ret
f77d 60          RTS ;Size   14 [Kernal_STOP]

f77e          Too_Many_Files
f77e a9 01       LDA #$01
f780 2c          .byte   $2C

f781          File_Already_Open
f781 a9 02       LDA #$02
f783 2c          .byte   $2C

f784          File_Not_Open
f784 a9 03       LDA #$03
f786 2c          .byte   $2C

f787          File_Not_Found
f787 a9 04       LDA #$04
f789 2c          .byte   $2C

f78a          Dev_Not_Present
f78a a9 05       LDA #$05
f78c 2c          .byte   $2C

f78d          Not_Input_File
f78d a9 06       LDA #$06
f78f 2c          .byte   $2C

f790          Not_Output_File
f790 a9 07       LDA #$07
f792 2c          .byte   $2C

f793          Missing_File_Name
f793 a9 08       LDA #$08
f795 2c          .byte   $2C

f796          Illegal_Jiffy_Device
f796 a9 09       LDA #$09          ; illegal device number
f798 48          PHA               ; save error #
f799 20 cc ff    JSR CLRCHN        ; Clear I/O channels
f79c a0 00       LDY #0            ; index to "I/O ERROR #"
f79e 24 9d       BIT MSGFLG        ; test message mode flag
f7a0 50 0a       BVC DIOR_10       ; exit if kernal messages off
f7a2 20 e6 f1    JSR Display_Kernal_IO_Message
f7a5 68          PLA               ; restore error #
f7a6 48          PHA               ; copy error #
f7a7 09 30       ORA #'0'          ; convert to ASCII
f7a9 20 d2 ff    JSR CHROUT        ; Output a character

f7ac          DIOR_10
f7ac 68          PLA               ; pull error number
f7ad 38          SEC               ; flag error

f7ae          Jiffy_RTS
f7ae 60          RTS ;Size   63 [Kernal_STOP]

0001 FALSE    #if JIFFY
SKIP          
SKIP          ; ******************
SKIP            Jiffy_Test_Command
SKIP          ; ******************
SKIP          
SKIP             LDY #12
SKIP             JSR CHRGOT
SKIP          
SKIP          ; *******************
SKIP            Jiffy_Test_Commands
SKIP          ; *******************
SKIP          
SKIP             CMP Jiffy_Command_List,Y
SKIP             BEQ JTC_Ret
SKIP             DEY
SKIP             BPL Jiffy_Test_Commands
SKIP          
SKIP          JTC_Ret
SKIP             RTS
SKIP          
SKIP          ; ************
SKIP            Jiffy_SETLFS
SKIP          ; ************
SKIP          
SKIP             JSR SETLFS
SKIP          
SKIP          ; *********************
SKIP            Jiffy_Test_IEC_Device
SKIP          ; *********************
SKIP          
SKIP             CLC
SKIP             PHP
SKIP             LDX Jiffy_Device
SKIP             CPX #8
SKIP             BCC JTID_20       ; device <  8
SKIP          
SKIP          JTID_10
SKIP             CPX #$1f
SKIP             BCC JTID_30       ; device < 31
SKIP          
SKIP          JTID_20
SKIP             PLP
SKIP             BCS Jiffy_Device_Not_Present
SKIP             SEC
SKIP             PHP
SKIP             LDX #8            ; try device 8
SKIP          
SKIP          JTID_30
SKIP             STX Jiffy_Device
SKIP             JSR Jiffy_Test_Device
SKIP             BCC JTID_40
SKIP             INX               ; try next device
SKIP             BNE JTID_10
SKIP          
SKIP          JTID_40
SKIP             PLA
SKIP          
SKIP          JTID_Ret
SKIP             RTS
SKIP          
SKIP          ; *****************
SKIP            Jiffy_Validate_FA
SKIP          ; *****************
SKIP          
SKIP             JSR Jiffy_Test_FA
SKIP             BCC JTID_Ret
SKIP          
SKIP          ; ************************
SKIP            Jiffy_Device_Not_Present
SKIP          ; ************************
SKIP          
SKIP             LDX #5
SKIP          
SKIP          ; **************
SKIP            Jiffy_Dispatch
SKIP          ; **************
SKIP          
SKIP             CPX #11           ; SYNTAX ERROR
SKIP             BEQ JiDi_20
SKIP          
SKIP          JiDi_10
SKIP             JMP Back_To_Prompt
SKIP          
SKIP          JiDi_20
SKIP             JSR Jiffy_Test_Command  ; (Y) = command
SKIP             BNE JiDi_10             ; not a Jiffy command
SKIP             STY COMSAV
SKIP             TAX
SKIP             BMI JiDi_30
SKIP             PLA
SKIP             PLA
SKIP          
SKIP          JiDi_30
SKIP             JSR Jiffy_Test_IEC_Device
SKIP             JSR Jiffy_At_Command
SKIP             LDA COMSAV
SKIP             LDY #0
SKIP             ASL A
SKIP             TAX
SKIP             LDA JTAB,X
SKIP             STA FUNJMP
SKIP             LDA JTAB+1,X
SKIP             STA FUNJMP+1
SKIP          
SKIP          JiDi_40
SKIP             JSR JUMPER        ; execute JiffyDOS command
SKIP             JSR Basic_DATA    ; ignore next statement
SKIP             JSR Jiffy_Close_15
SKIP             LDA PTR2
SKIP             JSR CLOSE
SKIP          
SKIP          ; *******
SKIP            JiDi_50
SKIP          ; *******
SKIP          
SKIP             JSR CLRCHN
SKIP             LDX IOPMPT
SKIP             BEQ JTID_Ret
SKIP             .BYTE $2c         ; ignore next statement
SKIP          
SKIP          ; *******
SKIP            JiDi_60
SKIP          ; *******
SKIP          
SKIP             LDX #$6f
SKIP             JMP CHKOUT
SKIP          
SKIP          ; *************
SKIP            Jiffy_Load_ML
SKIP          ; *************
SKIP          
SKIP             TYA
SKIP             INY
SKIP             .BYTE $2c         ; skip INY and TYA
SKIP          
SKIP          ; ************
SKIP            Jiffy_Verify
SKIP          ; ************
SKIP          
SKIP             INY
SKIP          
SKIP          ; ****************
SKIP            Jiffy_Load_Basic
SKIP          ; ****************
SKIP          
SKIP             TYA
SKIP             STY SA
SKIP             LDX TXTTAB
SKIP             LDY TXTTAB+1
SKIP             JSR LOAD
SKIP             BCC JiLo_30
SKIP             JMP Error_Handler
SKIP          
SKIP          JiLo_10
SKIP             JMP LOAD_30
SKIP          
SKIP          JiLo_20
SKIP             JMP LOAD_05
SKIP          
SKIP          JiLo_30
SKIP             LDA COMSAV
SKIP             CMP #11           ; verify command (´)
SKIP             BEQ JiLo_20       ; output verify OK
SKIP             BCS JiDi_40
SKIP             CMP #8            ; load ml (%)
0001 FALSE    #if C64
SKIP             BEQ JTID_Ret
SKIP             BCC JiLo_10
              #endif
0000 TRUE     #if VIC
SKIP             BNE JAAC_10
SKIP             RTS
SKIP          
SKIP          JAAC_10
SKIP             BCC JiLo_10
              #endif
SKIP             STX VARTAB
SKIP             STY VARTAB+1
SKIP             PLA
SKIP             PLA
SKIP             JSR Print_CR
SKIP             JSR Rechain
SKIP             JMP Basic_RUN
SKIP          
SKIP          ; ******************
SKIP            Jiffy_Command_List
SKIP          ; ******************
SKIP          
SKIP             .byte "@"         ;  0 : disk status and command
SKIP             .byte "_"         ;  1 : <- save file
SKIP             .byte "*"         ;  2 : *  copy file
SKIP             .byte $ac         ;  3 :    copy file
SKIP             .byte QUOTE       ;  4 : nothing
SKIP             .byte $12         ;  5 : nothing
SKIP             .byte "/"         ;  6 : load Basic program
SKIP             .byte $ad         ;  7
SKIP             .byte "%"         ;  8
SKIP             .byte "^"         ;  9
SKIP             .byte $ae         ; 10
SKIP             .byte $27         ; 11 
SKIP             .byte $5c         ; 12 : load file ML
SKIP             .byte "D"         ; 13 : display basic program
SKIP             .byte "L"
SKIP             .byte "T"
SKIP             .byte "#"
SKIP             .byte "B"
SKIP             .byte "F"
SKIP             .byte "O"
SKIP             .byte "P"
SKIP             .byte "Q"
SKIP             .byte "X"
SKIP             .byte "G"
SKIP          
SKIP          ; ****
SKIP            JTAB
SKIP          ; ****
SKIP          
SKIP             .WORD Jiffy_Exec_At            ;  @    0
SKIP             .WORD Jiffy_SAVE               ;  <-   1
SKIP             .WORD Jiffy_Copy               ;  *    2
SKIP             .WORD Jiffy_Copy               ;  $ac  3
SKIP             .WORD Jiffy_RTS                ;  Quo  4
SKIP             .WORD Jiffy_RTS                ;  RVS  5
SKIP             .WORD Jiffy_Load_Basic         ;  /    6
SKIP             .WORD Jiffy_Load_Basic         ;  $ad  7
SKIP             .WORD Jiffy_Load_ML            ;  %    8
SKIP             .WORD Jiffy_Load_Basic         ;  ^    9
SKIP             .WORD Jiffy_Load_Basic         ;  $ae 10
SKIP             .WORD Jiffy_Verify             ;  '   11
SKIP             .WORD Jiffy_Load_ML            ;  \   12  
SKIP             .WORD Jiffy_List_Basic_File    ;  Disp   13
SKIP             .WORD Jiffy_Lock_File          ;  Lock   14
SKIP             .WORD Jiffy_List_Text_File     ;  Text   15
SKIP             .WORD Jiffy_Set_Default_Device ;  #      16
SKIP             .WORD Jiffy_No_Bump            ;  Bump   17
SKIP             .WORD Jiffy_Inx_PRTY           ;  F      18
SKIP             .WORD Jiffy_OLD                ;  Old    19
SKIP             .WORD Jiffy_Toggle_Printer     ;  Print  20
SKIP             .WORD Jiffy_Disable            ;  Quit   21
SKIP             .WORD Jiffy_Destination        ;  Xfer   22
SKIP             .WORD Jiffy_Gap                ;  Gap    23
SKIP          
SKIP          ; *********
SKIP            Jiffy_OLD
SKIP          ; *********
SKIP          
SKIP             INY               ; Y = 1
SKIP             TYA               ; A = 1
SKIP             STA (TXTTAB),Y    ; Create dummy link <> zero
SKIP             JSR Rechain
SKIP             TXA               ; X/A = end of program + 2
SKIP             ADC #2
SKIP             TAX
SKIP             LDA INDEXA+1
SKIP             ADC #0
SKIP             TAY
SKIP             JMP LOAD_55
SKIP          
SKIP          ; This routine is called from the JiffyDOS COMMAND routine and make a
SKIP          ; test for additional command characters after the '@' character. Only
SKIP          ; the command number $0d-$17 is tested. If text after '@' is not a
SKIP          ; JiffyDOS command (ie. a normal DOS command', or JiffyDOS command
SKIP          ; number less than $10, a filename is expected. Tests are made for colon
SKIP          ; and quotes, the filname is evaluated, and parts of the OPEN/CLOSE
SKIP          ; routine is used to SETNAM. A test is made for additional device number
SKIP          ; after a comma. A free line on the screen is found, and some
SKIP          ; string-house keeping is done. Finally, the routine continues through
SKIP          ; to the next routine to open the command channel.
SKIP          
SKIP          ; ****************
SKIP            Jiffy_At_Command
SKIP          ; ****************
SKIP          
SKIP             TYA
SKIP             BNE JAC_05
SKIP             STA FNLEN
SKIP             JSR CHRGET
SKIP             BEQ JAC_45        ; terminator found, exit
SKIP             LDY #$17          ; test 23 commands
SKIP             JSR Jiffy_Test_Commands
SKIP             BNE JAC_10        ; not a Jiffy command
SKIP             CPY #13           ; ignore commands 0 - 12
SKIP             BCC JAC_10
SKIP             STY COMSAV
SKIP             CPY #16
SKIP             BCS JAC_45        ; no filename for commands >= 16
SKIP          
SKIP          JAC_05
SKIP             LDA #1
SKIP             JSR Add_To_TXTPTR
SKIP          
SKIP          JAC_10
SKIP             LDY #$ff
SKIP          
SKIP          JAC_15               ; scan filename
SKIP             INY
SKIP             LDA (TXTPTR),Y
SKIP             BEQ JAC_20
SKIP             CMP #QUOTE
SKIP             BEQ JAC_25
SKIP             CMP #':'
SKIP             BNE JAC_15
SKIP          
SKIP          JAC_20
SKIP             BIT MSGFLG
SKIP             BPL JAC_30
SKIP             CLC
SKIP             JSR Make_String_Descriptor_From_Code
SKIP             JMP JAC_35
SKIP          
SKIP          JAC_25
SKIP             JSR Add_Y_To_Execution_Pointer
SKIP          
SKIP          JAC_30
SKIP             JSR Eval_Expression
SKIP          
SKIP          JAC_35
SKIP             JSR Set_Filename_From_String
SKIP             JSR CHRGOT
SKIP             CMP #','
SKIP             BNE JAC_45
SKIP             JSR Get_Next_Byte_Value
SKIP          
SKIP          JAC_40
SKIP             STX FA
SKIP          
SKIP          JAC_45
SKIP             LDY #0
SKIP             BIT MSGFLG
SKIP             BPL JAC_55
SKIP          
SKIP          JAC_50
SKIP             LDA (LINPTR),Y
SKIP             CMP #' '
SKIP             BEQ JAC_55
SKIP             LDA #13
SKIP             JSR Screen_CHROUT
SKIP             BNE JAC_50
SKIP          
SKIP          JAC_55
SKIP             JSR Jiffy_Validate_FA
SKIP             LDA #$ff
SKIP             JSR Allocate_String_FAC1
SKIP             LDA FNLEN
SKIP             LDX FNADR
SKIP             LDY FNADR+1
SKIP             JSR Store_And_Push_String
SKIP             JSR Eval_String
SKIP             STX FNADR
SKIP             STY FNADR+1
SKIP          
SKIP          ; **************************
SKIP            Jiffy_Open_Command_Channel
SKIP          ; **************************
SKIP          
SKIP             JSR Jiffy_Close_6f; close command channel if open
SKIP             LDA FNLEN         
SKIP             LDX #0
SKIP             STX FNLEN         ; FNLEN = 0
SKIP             LDX #$6f
SKIP             BNE JOC_30        ; branch always
SKIP          
SKIP          ; *********************
SKIP            Jiffy_Open_Command_10
SKIP          ; *********************
SKIP          
SKIP             LDX #$6e
SKIP          
SKIP          ; *********************
SKIP            Jiffy_Open_Command_20
SKIP          ; *********************
SKIP          
SKIP             LDA FNLEN
SKIP          
SKIP          JOC_30
SKIP             STX SA
SKIP             STX PTR2
SKIP          
SKIP          JOC_40
SKIP             PHA
SKIP             STX LA
SKIP             JSR CLRCHN
SKIP             JSR OPEN
SKIP             PLA
SKIP             STA FNLEN         ; restore FNLEN
SKIP          
SKIP          JOC_Ret
SKIP          ;#if C64
SKIP             RTS
SKIP          ;#endif
SKIP          
SKIP          ; ***************
SKIP            Jiffy_Lock_File
SKIP          ; ***************
SKIP          
SKIP             JSR Jiffy_Disk_Status
SKIP             BNE JOC_Ret
SKIP             LDX #0   ; start data at "M-W...."
SKIP             LDY #$22 ; send 34 bytes 
SKIP             JSR Jiffy_Drive_Command
SKIP             LDY #5   ; start data after "M-W" sequence
SKIP             LDX #$22 ; send 34 bytes
SKIP          
SKIP          ; *******************
SKIP            Jiffy_Drive_Command
SKIP          ; *******************
SKIP          
SKIP             JSR Jiffy_Send_Drive_Command
SKIP             JMP CLRCHN
SKIP          
SKIP          ; *******************
SKIP            Jiffy_Detect_Device
SKIP          ; *******************
SKIP          
0001 FALSE    #if C64
SKIP             STA CIA2_PRA
SKIP             AND #8            ; Test ATN out
SKIP             BEQ JIS_Ret
SKIP             LDA BSOUR
SKIP             ROR A
SKIP             ROR A
              #endif
0000 TRUE     #if VIC
SKIP             STA VIA2_PCR
SKIP             BIT VIA1_DATN
SKIP             BPL JIS_Ret
              #endif
SKIP          
SKIP             CPX #2
0001 FALSE    #if C64
SKIP             BNE JIS_Ret
              #endif
0000 TRUE     #if VIC
SKIP             BNE JIS_Ret
SKIP             LDA #2
              #endif
SKIP             LDX #$1e          ; wait for jiffy protocol
SKIP          
SKIP          JIS_10
0001 FALSE    #if C64
SKIP             BIT CIA2_PRA
SKIP             BPL JIS_20        ; data high (0) -> Jiffy signal
              #endif
0000 TRUE     #if VIC
SKIP             BIT VIA1_DATN
SKIP             BEQ JIS_20        ; data high (0) -> Jiffy signal
              #endif
SKIP             DEX
SKIP             BNE JIS_10
0001 FALSE    #if C64
SKIP             BEQ JIS_30        ; no Jiffy device
              #endif
0000 TRUE     #if VIC
SKIP             BEQ JIS_30
              #endif
SKIP          
SKIP          JIS_20
0001 FALSE    #if C64
SKIP             BIT CIA2_PRA
SKIP             BPL JIS_20        ; wait for end of Jiffy signal
              #endif
0000 TRUE     #if VIC
SKIP             BIT IEC_DRAN
SKIP             BEQ JIS_20        ; wait for end of Jiffy signal
SKIP             LDA BSOUR
SKIP             ROR A
SKIP             ROR A
              #endif
SKIP          
SKIP             ORA #$40          ; BSOUR >>2 | $40
SKIP             STA TSFCNT        ; Flag as Jiffy device
SKIP          
SKIP          JIS_30
SKIP             LDX #2
SKIP          
SKIP          JIS_Ret
SKIP             RTS
SKIP          
SKIP          ; ********************
SKIP            Jiffy_Read_Text_Line
SKIP          ; ********************
SKIP          
SKIP             LDY #0
SKIP             JSR Jiffy_CHKIN_PTR2
SKIP          
SKIP          JRTL_10
SKIP             JSR Jfca9
SKIP             BVS JRTL_20
SKIP             BCC JRTL_10
SKIP          
SKIP          JRTL_20
SKIP             STY FNLEN
SKIP             LDA STATUS
SKIP             AND #$82
SKIP             RTS
SKIP          
SKIP          ; *********
SKIP            Jiffy_Gap
SKIP          ; *********
SKIP          
SKIP             JSR Get_Next_Byte_Value
SKIP             TXA
SKIP             LDX #$2d          ; "M-W" 69 00 01
SKIP             BNE Jiffy_6_Char_Command
SKIP          
SKIP          ; *************
SKIP            Jiffy_No_Bump
SKIP          ; *************
SKIP          
SKIP             LDA #$85
SKIP             LDX #$27          ; "M-W" 6a 00 01
SKIP          
SKIP          ; ********************
SKIP            Jiffy_6_Char_Command
SKIP          ; ********************
SKIP          
SKIP             LDY #6
SKIP          
SKIP          ; ******************
SKIP            Jiffy_Char_Command
SKIP          ; ******************
SKIP          
SKIP             PHA
SKIP             JSR Jiffy_Send_Drive_Command
SKIP             PLA
SKIP             JMP CHROUT
SKIP          
SKIP          ; **********************
SKIP            Jiffy_Toggle_Copy_Flag
SKIP          ; **********************
SKIP          
SKIP             LDX #0
SKIP             .BYTE $2c
SKIP          
SKIP          ; *****************************
SKIP            Jiffy_Toggle_Copy_Flag_Single
SKIP          ; *****************************
SKIP          
SKIP             LDX #6
SKIP             JSR Reset_BASIC_Exec_Pointer
SKIP             LDY #5
SKIP             LDA (TXTPTR),Y    ; test 5th. character
SKIP             CMP #$12          ; <RVS ON>?
SKIP             BNE JTD_10         ; if not, directory isn't loaded
SKIP             PLA
SKIP             TXA               ; store (X), the toggle flag, on stack
SKIP             PHA
SKIP             LDY #$23          ; skip diskheader
SKIP          
SKIP          JTCF_10
SKIP             LDX #'"'
SKIP             JSR NeLi_15       ; use part of Next_Line, to search for character
SKIP             DEY
SKIP             JSR Add_Y_To_Execution_Pointer
SKIP             PLA               ; recover flag
SKIP             PHA
SKIP             BEQ JTCF_30       ; toggle all files
SKIP             STA CSRIDX
SKIP             LDY #1
SKIP          
SKIP          JTCF_20
SKIP             INY
SKIP             JSR CHRI_07       ; use part of CHRIN
SKIP             CMP (TXTPTR),Y
SKIP             BNE JTCF_40
SKIP             SBC #'"'
SKIP             BNE JTCF_20
SKIP          
SKIP          JTCF_30
SKIP             TAY
SKIP             LDA (TXTPTR),Y    ; get character
SKIP             EOR #10           ; toggle between ' ' ($20) and '*' ($2a)
SKIP             STA (TXTPTR),Y
SKIP             LDY #4
SKIP             STA (LINPTR),Y
SKIP          
SKIP          JTCF_40
SKIP             JSR Basic_DATA    ; skip rest of line
SKIP             LDY #5
SKIP             SEC
SKIP             LDA (TXTPTR),Y
SKIP             SBC #$42 ; 'B'
SKIP             BNE JTCF_10       ; next file
SKIP             LDY #2
SKIP             STA (TXTPTR),Y
SKIP             PLA
SKIP             BEQ JTCF_50
SKIP             LDA #$8d
SKIP             RTS
SKIP          
SKIP          JTCF_50
SKIP             JMP LIST_05
SKIP          
SKIP          ; ******************
SKIP            Jiffy_Toggle_Drive
SKIP          ; ******************
SKIP          
SKIP             BIT MSGFLG
SKIP             BPL JTD_10
SKIP             TSX
SKIP             LDY STACK+7,X
SKIP             CPY #$e1
SKIP             BNE JTD_10
SKIP             CMP #4
SKIP             BNE Bf9b2
SKIP             INC Jiffy_Device
SKIP             JSR Jiffy_Test_IEC_Device
SKIP             LDA #0
SKIP             JSR Print_Integer_XA
SKIP             JSR Print_CR
SKIP             JSR JiDi_50
SKIP          
SKIP          JTD_10
SKIP             PLA
SKIP             RTS
SKIP          
SKIP          ; *****
SKIP            Bf9b2
SKIP          ; *****
SKIP          
SKIP             CMP #1
SKIP             BEQ Jiffy_Toggle_Copy_Flag
SKIP             CMP #$17
SKIP             BEQ Jiffy_Toggle_Copy_Flag_Single
SKIP             LDY PRTY
SKIP             BNE JTD_10
SKIP             CMP #$8d
SKIP             BCS JTD_10
SKIP             CMP #$85
SKIP             BCC JTD_10
SKIP             PLA
SKIP             SBC #$85
SKIP             TAX
SKIP             BEQ Bf9d5
SKIP          Bf9cc     INY
SKIP             LDA (CMPO),Y
SKIP             BNE Bf9cc
SKIP             DEX
SKIP             BNE Bf9cc
SKIP          Bf9d4     INY
SKIP          Bf9d5     LDA (CMPO),Y
SKIP             BEQ Bf9e2
SKIP             CMP #13
SKIP             BEQ Bf9e4
SKIP             JSR Screen_CHROUT
SKIP             BNE Bf9d4
SKIP          Bf9e2     STA CSRMOD
SKIP          Bf9e4     RTS
SKIP          
SKIP          ; **********
SKIP            Jiffy_f9e5
SKIP          ; **********
SKIP          
SKIP             JSR Get_Char_From_Keyboard_Buffer
SKIP             PHA
SKIP             LDX CSRMOD
0001 FALSE    #if C64
SKIP             BNE Bfa37
              #endif
0000 TRUE     #if VIC
SKIP             BNE JAAD_10
              #endif
SKIP             LDX INSRTO
0001 FALSE    #if C64
SKIP             BNE Bfa37
              #endif
0000 TRUE     #if VIC
SKIP             BNE JAAD_10
              #endif
SKIP             CMP #16
SKIP             BNE Jiffy_Toggle_Drive
0001 FALSE    #if C64
SKIP             LDA #4
              #endif
0000 TRUE     #if VIC
SKIP             JMP KeDe_60
              #endif
SKIP          
SKIP          JAAD_10
0001 FALSE    #if C64
SKIP             JSR LISTEN
SKIP             LDA MEM_CONTROL
SKIP             AND #2
SKIP             BEQ Bfa03
SKIP             LDA #7
SKIP          Bfa03     ORA #$60
SKIP             JSR SECOND
SKIP             LDA CSRIDX
SKIP             PHA
SKIP             LDA TBLX
SKIP             PHA
SKIP          Bfa0e     LDY #0
SKIP             STY CSRMOD
SKIP             JSR PLOT_05
SKIP             INC LINLEN
SKIP          Bfa17     JSR CHRI_07
SKIP             JSR Kernal_CIOUT
SKIP             CMP #13
SKIP             BNE Bfa17
SKIP             INX
SKIP             CPX #$19
SKIP             BCS Bfa2d
SKIP             ASL LINLEN
SKIP             BPL Bfa0e
SKIP             INX
SKIP             BNE Bfa0e
SKIP          Bfa2d     JSR UNLSN
SKIP             PLA
SKIP             TAX
SKIP             PLA
SKIP             TAY
SKIP             JSR PLOT_05
              #endif
SKIP          Bfa37     PLA
SKIP          Bfa38     RTS
SKIP          
SKIP          ; **********
SKIP            Jiffy_Copy
SKIP          ; **********
SKIP          
SKIP             STY FAC3+1
SKIP             JSR Jiffy_Disk_Status
SKIP             BNE Bfa38
SKIP             JSR CHRGOT
SKIP             CMP #$52 ; 'R'
SKIP             BNE Bfa5a
SKIP          
SKIP          Bfa47
SKIP             DEC FAC3+1
SKIP             LDA FAC3+1
SKIP             JSR Jf66b
SKIP             JSR Jiffy_CHRIN
SKIP             BEQ Bfa47
SKIP             LDA #0
SKIP             JSR Jf66b
SKIP             LDA #$4c ; 'L'
SKIP          
SKIP          Bfa5a
SKIP             PHA
SKIP             LDX MYCH
SKIP             CPX FA
SKIP             BEQ Bfa37
SKIP             JSR JAC_40
SKIP             LDX #$37 ; '7'
SKIP             LDY #2
SKIP             JSR Jiffy_Send_Drive_Command
SKIP             JSR PrSe_10
SKIP             LDA #$2c ; ','
SKIP             STA (FNADR),Y
SKIP             INY
SKIP             PLA
SKIP             STA (FNADR),Y
SKIP             INY
SKIP             LDA #$2c ; ','
SKIP             STA (FNADR),Y
SKIP             INY
SKIP             LDA FAC3+1
SKIP             PHA
SKIP             BNE Bfa83
SKIP             LDA #$57 ; 'W'
SKIP          
SKIP          Bfa83
SKIP             STA (FNADR),Y
SKIP             INY
SKIP             STY FNLEN
SKIP             LDY #12
SKIP          Bfa8a
SKIP             JSR Jfab2
SKIP             JSR Jiffy_Test_IEC_Device
SKIP             JSR Jiffy_Open_Command_Channel
SKIP             PLA
SKIP             JSR JLTF_05
SKIP          
SKIP          ; ********************
SKIP            Jiffy_Toggle_Printer
SKIP          ; ********************
SKIP          
SKIP             LDA IOPMPT
SKIP             BEQ Bfaa7
SKIP             CMP #$7f
SKIP             BNE Bfa38
SKIP             JSR BaIN_10
SKIP             LDA #$7f
SKIP             JMP CLOSE
SKIP          
SKIP          Bfaa7
SKIP             LDX #4
SKIP             JSR CHRGET
SKIP             JSR GOCP_05
SKIP             JSR Jiffy_Validate_FA
SKIP          
SKIP          ; *****
SKIP            Jfab2
SKIP          ; *****
SKIP          
SKIP             STY SA
SKIP             LDX #$7f
SKIP             STX IOPMPT
SKIP             LDA FNLEN
SKIP             JMP JOC_40
0001 FALSE    #if C64
SKIP             TAX               ; dead code
SKIP             BNE Bfa8a
SKIP             LDA NXTBIT
SKIP             BEQ JAAE_05+1
SKIP          
SKIP          Jiffy_fac4
SKIP             JSR Display_LOADING_Or_VERIFYING
              #endif
0000 TRUE     #if VIC
SKIP          Jiffy_fb05
SKIP             JSR Set_Load_Address
              #endif
SKIP             TSX
SKIP             LDA STACK+2,X
0001 FALSE    #if C64
SKIP             CMP #$f7          ; high byte of return address
              #endif
0000 TRUE     #if VIC
SKIP             CMP #$f8
              #endif
SKIP          
SKIP          JAAE_05
SKIP             BNE JAAE_10
SKIP             LDA EAL
SKIP             STA FUNJMP
SKIP             LDA EAL+1
SKIP             STA FUNJMP+1
SKIP          
SKIP          JAAE_10
SKIP             BIT TSFCNT
SKIP             BMI Bfade
SKIP             JMP DLOA_25
SKIP          
SKIP          Bfade
SKIP             SEI
0001 FALSE    #if C64
SKIP             LDY #3
SKIP          
SKIP          Bfae1
SKIP             LDA EAL+1,Y
SKIP             PHA
SKIP             DEY
SKIP             BNE Bfae1
SKIP             LDA VIC_SPR_ENA
SKIP             STA CMPO
SKIP             JSR Jiffy_Clear_Sprites
SKIP          
SKIP          Bfaf0
SKIP             JSR Look_For_Special_Keys
SKIP             BPL Bfb27
SKIP             LDA VIC_CONTROL_1
SKIP             AND #7
SKIP             CLC
SKIP             ADC #$2f
SKIP             STA CMPO+1
SKIP             LDA CIA2_PRA
SKIP             AND #7
SKIP             STA TAPE1
SKIP             STA CIA2_PRA
SKIP             ORA #$20
SKIP             TAX
SKIP          
SKIP          Bfb0c
SKIP             BIT CIA2_PRA
SKIP             BVC Bfb0c
SKIP             BPL Jiffy_LOAD
SKIP             LDX #$64
SKIP          Bfb15     BIT CIA2_PRA
SKIP             BVC Bfb20
              #endif
0000 TRUE     #if VIC
SKIP             LDA TAPE1
SKIP             PHA
SKIP             LDY #0
SKIP          
SKIP          JAAH_10
SKIP             JSR Look_For_Special_Keys
SKIP             CMP #$fe
SKIP             BEQ Bfb27
SKIP             LDA IEC_PCR
SKIP             AND #$dd
SKIP             TAX
SKIP             ORA #$20
SKIP             STA TAPE1
SKIP             STX IEC_PCR
SKIP             LDA #$80
SKIP             STA DPSW
SKIP          
SKIP          JAAF_10
SKIP             LDA IEC_DRAN
SKIP             LSR A
SKIP             BCC JAAF_10
SKIP             AND #1
SKIP             BEQ Jiffy_LOAD
SKIP             LDX #$64
SKIP          
SKIP          Bfb15
SKIP             BIT IEC_DRAN
SKIP             BEQ Bfb20
SKIP          Bfaf0
              #endif
SKIP             DEX
SKIP             BNE Bfb15
SKIP             LDA #$42
SKIP             .BYTE $2c
SKIP          
SKIP          Bfb20
SKIP             LDA #$40
SKIP             JSR Ora_Status
SKIP             CLC
SKIP             .BYTE $24
SKIP          
SKIP          Bfb27
SKIP             SEC
0001 FALSE    #if C64
SKIP             LDA CMPO
SKIP             STA VIC_SPR_ENA
SKIP             PLA
SKIP             STA CMPO
SKIP             PLA
SKIP             STA CMPO+1
              #endif
SKIP             PLA
SKIP             STA TAPE1
SKIP             BCS Bfb3b
SKIP             JMP DLOA_47
SKIP          
SKIP          Bfb3b
SKIP             JMP SAVE_50
SKIP          
SKIP          ; **********
SKIP            Jiffy_LOAD
SKIP          ; **********
SKIP          
0001 FALSE    #if C64
SKIP             BIT CIA2_PRA
SKIP             BPL Jiffy_LOAD    ; wait until data (7) = 1
SKIP             SEC               ; [2: 2]
SKIP          
SKIP          JiLO_10
SKIP             LDA VIC_RASTER    ; [4: 4] current raster line
SKIP             SBC CMPO+1        ; [4: 8]  minus fine scroll register 
SKIP             BCC JiLO_20       ; [3:11]  no bad line
SKIP             AND #7
SKIP             BEQ JiLO_10
SKIP          
SKIP          JiLO_20
SKIP             LDA TAPE1         ; [3:14]
SKIP             STX CIA2_PRA      ; [4:18] data (5) and clock (4) output = 0
SKIP             BIT CIA2_PRA      ; [4:22] 
SKIP             BVC Bfaf0         ; [2:24]
SKIP             NOP               ; [2:26] wait
SKIP             STA CIA2_PRA      ; [4:30]
SKIP             ORA CIA2_PRA      ; [4:34] get bit 0 & 1 of byte      <--
SKIP             LSR A             ; [2:36] A = .XX.....
SKIP             LSR A             ; [2:38] A = ..XX....
SKIP             NOP               ; [2:40] wait 2 cycles
SKIP             ORA CIA2_PRA      ; [4:44] get bit 2 & 3 of byte      <--
SKIP             LSR A             ; [2:46] A = .XXXX...
SKIP             LSR A             ; [2:48] A = ..XXXX..
SKIP             EOR TAPE1         ; [3:51] leave bits 2-0 unchanged
SKIP             EOR CIA2_PRA      ; [4:55] get bit 4 & 5 of byte      <--
SKIP             LSR A             ; [2:57] A = .XXXXXX.
SKIP             LSR A             ; [2:59] A = ..XXXXXX
SKIP             EOR TAPE1         ; [3:62] leave bits 2-0 unchanged
SKIP             EOR CIA2_PRA      ; [4:66] get bit 6 & 7 of byte      <--
              #endif
SKIP          
0000 TRUE     #if VIC
SKIP             LDA #2
SKIP          
SKIP          JiLO_05
SKIP             BIT IEC_DRAN
SKIP             BEQ JiLO_05
SKIP          
SKIP          JiLO_10
SKIP             PHA
SKIP             PLA
SKIP             NOP
SKIP             LDA TAPE1
SKIP             STA IEC_PCR
SKIP             LDA #1
SKIP             BIT IEC_DRAN
SKIP             BEQ JAAH_10
SKIP             STX IEC_PCR
SKIP             LDA IEC_DRAN
SKIP             ROR A
SKIP             ROR A
SKIP             AND #$80
SKIP             ORA IEC_DRAN
SKIP             ROL A
SKIP             ROL A
SKIP             STA TAPE1+1
SKIP             LDA IEC_DRAN
SKIP             ROR A
SKIP             ROR A
SKIP             AND DPSW
SKIP             ORA IEC_DRAN
SKIP             ROL A
SKIP             ROL A
SKIP             STA CAS1
SKIP             JSR Jiffy_Combine_Nibbles
              #endif
SKIP          
SKIP             CPY VERCKK
SKIP             BNE JiLO_40
SKIP             STA (EAL),Y
SKIP          
SKIP          JiLO_30
SKIP             INC EAL
SKIP             BNE JiLO_10
SKIP             INC EAL+1
SKIP             JMP JiLO_10
SKIP          
SKIP          JiLO_40
SKIP             CMP (EAL),Y
SKIP             BEQ JiLO_30
0001 FALSE    #if C64
SKIP             SEC
              #endif
SKIP             LDA #16
SKIP             STA STATUS
SKIP             BNE JiLO_30       ; branch always
SKIP          
0000 TRUE     #if VIC
SKIP          JTABB
SKIP             .byte $00,$00,$20,$20,$00,$00,$20,$20
SKIP             .byte $02,$02,$22,$22,$02,$02,$22,$22
SKIP          
SKIP          Jiffy_fbc8
SKIP             LDY #0
SKIP             STA (TMPPTC),Y
SKIP             INY
SKIP             TXA
SKIP             STA (TMPPTC),Y
SKIP             RTS
SKIP          
SKIP             .byte $ff
              #endif
SKIP          
SKIP          ; ************
SKIP            Set_IO_Start
SKIP          ; ************
SKIP          
SKIP             LDA STAL+1
SKIP             STA SAL+1
SKIP             LDA STAL
SKIP             STA SAL
SKIP             RTS
SKIP          
SKIP          ; **************************
SKIP            Jiffy_Disable_Sprite_ACPTR
SKIP          ; **************************
SKIP          
0001 FALSE    #if C64
SKIP             PHA                ; save sprite enable register
SKIP             JSR Jiffy_Clear_Sprites
SKIP             JSR Jiffy_ACPTR_10 ; call Jiffy_ACPTR
SKIP             PLA
SKIP             STA VIC_SPR_ENA    ; restore sprite enable register
SKIP             LDA TBTCNT         ; recover received byte
SKIP             RTS
              #endif
SKIP          
SKIP          ; ***************
SKIP            Jiffy_Jmp_ACPTR
SKIP          ; ***************
SKIP          
SKIP             LDA #0
SKIP             JMP KeAC_03
SKIP          
SKIP          ; This is the JiffyDOS ACPTR routine which fetches a byte from the
SKIP          ; serial bus. Entry point is $fbaa where a test is done by checking $a3
SKIP          ; to see if the current device is a JiffyDOS device. Visible sprites are
SKIP          ; disabled, and raster-timing is done so that no serial access is done
SKIP          ; when there is a "bad rasterline"
SKIP          
SKIP          ; video timing by Marko Makela
SKIP          ; ---------------------------------------------------------------
SKIP          ;  NTSC-M systems:
SKIP          ;
SKIP          ;            Chip      Crystal  Dot      Processor Cycles/ Lines/
SKIP          ;    Host    ID        freq/Hz  clock/Hz clock/Hz  line    frame
SKIP          ;    ------  --------  -------- -------- --------- ------- ------
SKIP          ;    VIC-20  6560-101  14318181  4090909   1022727      65    261
SKIP          ;    C64     6567R56A  14318181  8181818   1022727      64    262
SKIP          ;    C64     6567R8    14318181  8181818   1022727      65    263
SKIP          ;
SKIP          ;  Later NTSC-M video chips were most probably like the 6567R8.  Note
SKIP          ;  that the processor clock is a 14th of the crystal frequency on all
SKIP          ;  NTSC-M systems.
SKIP          ;
SKIP          ;  PAL-B systems:
SKIP          ;
SKIP          ;            Chip      Crystal  Dot      Processor Cycles/ Lines/
SKIP          ;    Host    ID        freq/Hz  clock/Hz clock/Hz  line    frame
SKIP          ;    ------  --------  -------- -------- --------- ------- ------
SKIP          ;    VIC-20  6561-101   4433618  4433618   1108405      71    312
SKIP          ;    C64     6569      17734472  7881988    985248      63    312
SKIP          ;
SKIP          ; ---------------------------------------------------------------
SKIP          ; So the Jiffy routine needs more time than one raster line, to
SKIP          ; receive 1 byte. Therefore we have to make sure, that the bad line
SKIP          ; is not nearer than 2 lines ahead!
SKIP          
SKIP          
SKIP          ; ***********
SKIP            Jiffy_ACPTR
SKIP          ; ***********
SKIP          
SKIP             SEI
SKIP             BIT TSFCNT          ; test to see if the device is a JiffyDOS drive
SKIP             BVC Jiffy_Jmp_ACPTR ; nope, back to normal ACPTR routine
0001 FALSE    #if C64
SKIP             LDA VIC_SPR_ENA     ; are sprites active ?
SKIP             BNE Jiffy_Disable_Sprite_ACPTR
              #endif
SKIP          
SKIP          ; **************
SKIP            Jiffy_ACPTR_10
SKIP          ; **************
SKIP          
0001 FALSE    #if C64
SKIP             LDA CIA2_PRA        ; IEC bus register
SKIP             CMP #%01000000
SKIP             BCC Jiffy_ACPTR_10  ; wait until data (7) or clock (6) = 1
SKIP             AND #7              ; mask bits 2-0
SKIP             PHA                 ; save (carry is set)
SKIP          
SKIP          JiAC_10
SKIP             LDA VIC_RASTER      ; [4: 4] current raster line
SKIP             SBC VIC_CONTROL_1   ; [4: 8]  minus fine scroll register
SKIP             AND #7              ; [2:10] modulo 7
SKIP             CMP #7              ; [2:12] compare with 7
SKIP             BCS JiAC_10         ; [2:14] we're one line before a bad line
SKIP             PLA                 ; [4:18] restore bits 2-0
SKIP             STA CIA2_PRA        ; [4:22] data (5) and clock (4) output = 0
SKIP             STA TBTCNT          ; [3:25] save bits 2-0
SKIP             ORA #%00100000      ; [2:27] data (5) output = 1
SKIP             PHA                 ; [3:30] save
SKIP             NOP                 ; [2:32] wait 2 cycles
SKIP             NOP                 ; [2:34] wait 2 cycles
SKIP             ORA CIA2_PRA        ; [4:38] get bit 0 & 1 of byte      <--
SKIP             LSR A               ; [2:40] A = .XX.....
SKIP             LSR A               ; [2:42] A = ..XX....
SKIP             NOP                 ; [2:44] wait 2 cycles
SKIP             ORA CIA2_PRA        ; [4:48] get bit 2 & 3 of byte      <--
SKIP             LSR A               ; [2:50] A = .XXXX...
SKIP             LSR A               ; [2:52] A = ..XXXX..
SKIP             EOR TBTCNT          ; [3:55] leave bits 2-0 unchanged
SKIP             EOR CIA2_PRA        ; [4:59] get bit 4 & 5 of byte      <--
SKIP             LSR A               ; [2:61] A = .XXXXXX.
SKIP             LSR A               ; [2:63] A = ..XXXXXX
SKIP             EOR TBTCNT          ; [3:66] leave bits 2-0 unchanged
SKIP             EOR CIA2_PRA        ; [4:70] get bit 6 & 7 of byte      <--
SKIP             STA TBTCNT          ; [3:73] byte completed
SKIP             PLA                 ; [4:77] recover %00100000 OR bit 2-0
SKIP             BIT CIA2_PRA        ; [4:81] test data in (7) and clock in (6)
SKIP             STA CIA2_PRA        ; [4:85] data out (5) = 1
SKIP             BVC Jiffy_Set_OK    ; branch on clock in = 0
SKIP             BPL Jiffy_Set_EOI   ; branch on data  in = 0
SKIP             LDA #%01000010      ; EOI (6) and time out (1)
SKIP             JMP Set_IEC_Status
              #endif
SKIP          
SKIP          ; §§
SKIP          
0000 TRUE     #if VIC
SKIP          ; read one byte from IEC bus
SKIP          ; ------------------------------------
SKIP          ; cycle 34: clock = bit1   data = bit0
SKIP          ; cycle 44: clock = bit3   data = bit2
SKIP          ; cycle 55: clock = bit5   data = bit4
SKIP          ; cycle 66: clock = bit7   data = bit6
SKIP          ; ------------------------------------
SKIP          ; cycle 77: status
SKIP          ; cycle 81: finish transmission
SKIP          
SKIP             LDA IEC_DRAN        ; IEC bus register
SKIP             AND #3
SKIP             BEQ Jiffy_ACPTR_10  ; wait until data (1) or clock (0) = 1
SKIP             LDA #$80
SKIP             STA DPSW
SKIP             TXA                 ; [2: 2]
SKIP             PHA                 ; [3: 4] save X
SKIP             PHA                 ; [3: 7] wait 3 cycles
SKIP             PLA                 ; [4:11] wait 4 cycles
SKIP             LDA IEC_PCR         ; [4:15] 
SKIP             AND #%11011101      ; [2:17]
SKIP             STA IEC_PCR         ; [4:21] data (5) and clock (1) = 0
SKIP             ORA #%00100000      ; [2:23]
SKIP             TAX                 ; [2:25] save mask in X
SKIP             BIT DPSW            ; [3:28] wait
SKIP             BIT DPSW            ; [3:31] wait
SKIP             BIT DPSW            ; [3:34] wait
SKIP             LDA IEC_DRAN        ; [4:38] get bit 0 & 1            <--
SKIP             ROR A               ; [2:40] bit 0 (clock) -> bit 7
SKIP             ROR A               ; [2:42] bit 1 (data ) -> carry
SKIP             AND #$80            ; [2:44] mask received bit 0
SKIP             ORA IEC_DRAN        ; [4:48] get bit 2 & 3            <--
SKIP             ROL A               ; [2:50] A = .....XXX
SKIP             ROL A               ; [2:52] A = ....XXXX
SKIP             STA TAPE1+1         ; [3:55] store lower nibble
SKIP             LDA IEC_DRAN        ; [4:59] get bit 4 & 5            <--
SKIP             ROR A               ; [2:61] bit 4 (clock) -> bit 7
SKIP             ROR A               ; [2:63] bit 5 (data ) -> carry
SKIP             AND DPSW            ; [3:66] mask received bit 4
SKIP             ORA IEC_DRAN        ; [4:70] get bit 6 & 7            <--
SKIP             ROL A               ; [2:72] A = .....XXX
SKIP             ROL A               ; [2:74] A = ....XXXX
SKIP             STA CAS1            ; [3:77] store upper nibble
SKIP             LDA IEC_DRAN        ; [4:81] get status bits
SKIP             STX IEC_PCR         ; [4:85] data out (5) = 1
SKIP             STA DPSW            ; save status bits
SKIP             JSR Jiffy_Combine_Nibbles
SKIP             STA TBTCNT          ; received byte
SKIP             PLA
SKIP             TAX                 ; restore X
SKIP             LDA DPSW            ; restore status bits
SKIP             ROR A               ; (clock) -> bit 7
SKIP             ROR A               ; (data ) -> carry
SKIP             BPL Jiffy_Set_OK    ; clock = 0 -> OK
SKIP             BCC Jiffy_Set_EOI   ; data  = 0 -> EOI
SKIP             LDA #%01000010      ; EOI (6) and time out (1) ($42)
SKIP             JMP Set_IEC_Status
              #endif
SKIP          
SKIP          ; ***************
SKIP            Jiffy_Send_Byte
SKIP          ; ***************
SKIP          
SKIP             SEI
SKIP             BIT TSFCNT        ; test to see if the device is a JiffyDOS drive
0001 FALSE    #if C64
SKIP             BVC Jiffy_Send_Byte_20
SKIP          
SKIP          JSB_10
SKIP             LDA VIC_SPR_ENA
SKIP             BEQ Jiffy_Send_Byte_30
SKIP             PHA
SKIP             JSR Jiffy_Clear_Sprites
SKIP             JSR Jiffy_Send_Byte_30
SKIP             PLA
SKIP             STA VIC_SPR_ENA
SKIP             RTS
              #endif
SKIP          
0000 TRUE     #if VIC
SKIP             BVS JSB_10
              #endif
SKIP          
SKIP          ; ******************
SKIP            Jiffy_Send_Byte_20
SKIP          ; ******************
SKIP          
SKIP             LDA TSFCNT
SKIP             CMP #$a0
SKIP             BCS JSB_10
SKIP             JMP IEC_Send_Byte
SKIP          
SKIP          ; *************
SKIP            Jiffy_Set_EOI
SKIP          ; *************
SKIP          
SKIP             LDA #%01000000    ; bit 6 = EOI
SKIP             JSR Ora_Status
SKIP          
SKIP          ; ************
SKIP            Jiffy_Set_OK
SKIP          ; ************
SKIP          
SKIP             LDA TBTCNT
SKIP          
SKIP          Bfc24
SKIP             CLI
SKIP             CLC
SKIP             RTS
0000 TRUE     #if VIC
SKIP          JSB_10
              #endif
SKIP          
SKIP          ; ******************
SKIP            Jiffy_Send_Byte_30
SKIP          ; ******************
SKIP          
0001 FALSE    #if C64
SKIP             TXA
SKIP             PHA
SKIP             LDA BSOUR
SKIP             AND #$f0
SKIP             PHA
SKIP             LDA BSOUR
SKIP             AND #15
SKIP             TAX
SKIP          Bfc33     LDA CIA2_PRA
SKIP             BPL Bfc33
SKIP             AND #7
SKIP             STA BSOUR
SKIP             SEC
SKIP          Bfc3d     LDA VIC_RASTER
SKIP             SBC VIC_CONTROL_1
SKIP             AND #7
SKIP             CMP #6
SKIP             BCS Bfc3d
SKIP             LDA BSOUR
SKIP             STA CIA2_PRA
SKIP             PLA
SKIP             ORA BSOUR
SKIP             STA CIA2_PRA
SKIP             LSR A
SKIP             LSR A
SKIP             AND #$f0
SKIP             ORA BSOUR
SKIP             STA CIA2_PRA
SKIP             LDA Vfc8a,X
SKIP             ORA BSOUR
SKIP             STA CIA2_PRA
SKIP             LSR A
SKIP             LSR A
SKIP             AND #$f0
SKIP             ORA BSOUR
SKIP             STA CIA2_PRA
SKIP             AND #15
SKIP             BIT TSFCNT
SKIP             BMI Bfc76
SKIP             ORA #16
SKIP          
SKIP          Bfc76
SKIP             STA CIA2_PRA
SKIP             PLA
SKIP             TAX
SKIP             LDA BSOUR
SKIP             ORA #16
SKIP             STA CIA2_PRA
SKIP             BIT CIA2_PRA
SKIP             BPL Bfc24
SKIP             JMP IEC_Timeout
SKIP          
SKIP          Vfc8a
SKIP             .BYTE $00,$80,$20,$a0,$40,$c0,$60,$e0
SKIP             .BYTE $10,$90,$30,$b0,$50,$d0,$70,$f0
SKIP          
SKIP          Jiffy_fc9a
SKIP             JSR JiDi_60
SKIP             JMP PrSe_10
SKIP          
              #endif
SKIP          
0000 TRUE     #if VIC
SKIP             TXA
SKIP             PHA
SKIP             LDA BSOUR
SKIP             LSR A
SKIP             LSR A
SKIP             LSR A
SKIP             LSR A
SKIP             TAX
SKIP             LDA JTABA,X
SKIP             PHA
SKIP             TXA
SKIP             LSR A
SKIP             LSR A
SKIP             TAX
SKIP             LDA JTABA,X
SKIP             STA TAPE1+1
SKIP             LDA BSOUR
SKIP             AND #15
SKIP             TAX
SKIP             LDA #2
SKIP          
SKIP          JAAI_10
SKIP             BIT VIA1_DATN
SKIP             BEQ JAAI_10
SKIP             LDA IEC_PCR
SKIP             AND #$dd
SKIP             STA DPSW
SKIP             PHA
SKIP             PLA
SKIP             PHA
SKIP             PLA
SKIP             STA IEC_PCR
SKIP             PLA
SKIP             ORA DPSW
SKIP             STA IEC_PCR
SKIP             LDA TAPE1+1
SKIP             ORA DPSW
SKIP             ORA DPSW
SKIP             STA IEC_PCR
SKIP             LDA JTABB,X
SKIP             ORA DPSW
SKIP             STA IEC_PCR
SKIP             LDA JTABC,X
SKIP             ORA DPSW
SKIP             NOP
SKIP             STA IEC_PCR
SKIP             AND #$dd
SKIP             BIT TSFCNT
SKIP             BMI JAAI_20
SKIP             ORA #2
SKIP          
SKIP          JAAI_20
SKIP             STA IEC_PCR 
SKIP             PLA
SKIP             TAX
SKIP             LDA DPSW
SKIP             ORA #2
SKIP             STA IEC_PCR
SKIP             LDA IEC_DRAN
SKIP             AND #2
SKIP             BEQ Bfc24
SKIP             JMP IEC_Timeout
SKIP          
SKIP          JTABA
SKIP             .byte $00,$02,$20,$22,$00,$02,$20,$22
SKIP             .byte $00,$02,$20,$22,$00,$02,$20,$22
SKIP          
              #endif
SKIP          
SKIP          
SKIP          ; *****************
SKIP            Jiffy_Destination
SKIP          ; *****************
SKIP          
SKIP             JSR Get_Next_Byte_Value
SKIP             STX MYCH
SKIP             RTS
SKIP          
SKIP          ; **********
SKIP            Jiffy_fca6
SKIP          ; **********
SKIP          
SKIP             JSR Jiffy_CHKIN_PTR2
SKIP          
SKIP          ; *****
SKIP            Jfca9
SKIP          ; *****
SKIP          
SKIP             JSR CHRIN
SKIP             STA (FNADR),Y
SKIP             INY
SKIP             BIT STATUS
SKIP             BVS Bfcbb
SKIP             CPY #$fe
SKIP             BCS Bfcbb
SKIP             CMP #1
SKIP             BCS Jfca9
SKIP          Bfcbb     RTS
SKIP          
SKIP          ; *************
SKIP            Jiffy_Disable
SKIP          ; *************
SKIP          
SKIP             LDX #5
SKIP          
SKIP          Bfcbe
SKIP             LDA Vf1a3,X
SKIP             STA IERROR,X
SKIP             DEX
SKIP             BPL Bfcbe
SKIP             STX PRTY
SKIP             RTS
SKIP          
0001 FALSE    #if C64
SKIP             .byte $a5,$a5,$01,$29,$fd,$85,$01
              #endif
SKIP          
0000 TRUE     #if VIC
SKIP             .byte $fd
SKIP          
SKIP             STA CINV
SKIP             LDA $fdea,X
SKIP             STA CINV+1
SKIP             RTS
SKIP          
SKIP             LDA VIA1_PCR
SKIP             ORA #$0e
SKIP             STA VIA1_PCR
SKIP             RTS
SKIP          
              #endif
SKIP          
              #else                ; JIFFY
              ; ********************
f7af            TAPE_Find_Any_Header
              ; ********************

f7af a5 93       LDA VERCKK        ; get load/verify flag
f7b1 48          PHA               ; save load/verify flag
f7b2 20 c0 f8    JSR TAPE_Init_Read
f7b5 68          PLA               ; restore load/verify flag
f7b6 85 93       STA VERCKK        ; save load/verify flag
f7b8 b0 2c       BCS TFAH_Ret      ; exit if error
f7ba a0 00       LDY #0
f7bc b1 b2       LDA (TAPE1),Y     ; read first byte from tape buffer
f7be c9 05       CMP #$05          ; compare with logical end of the tape
f7c0 f0 24       BEQ TFAH_Ret      ; exit if end of the tape
f7c2 c9 01       CMP #$01          ; compare with header for a relocatable program file
f7c4 f0 08       BEQ TFAH_10      ; branch if program file header
f7c6 c9 03       CMP #$03          ; compare with header for a non relocatable program file
f7c8 f0 04       BEQ TFAH_10      ; branch if program file header
f7ca c9 04       CMP #$04          ; compare with data file header
f7cc d0 e1       BNE TAPE_Find_Any_Header

f7ce          TFAH_10
f7ce aa          TAX               ; copy header type
f7cf 24 9d       BIT MSGFLG        ; get message mode flag
f7d1 10 11       BPL TFAH_30      ; exit if control messages off
f7d3 a0 63       LDY #Msg_Found-Msg_Start
f7d5 20 e6 f1    JSR Display_Kernal_IO_Message
f7d8 a0 05       LDY #$05          ; index to tape filename

f7da          TFAH_20
f7da b1 b2       LDA (TAPE1),Y     ; get byte from tape buffer
f7dc 20 d2 ff    JSR CHROUT        ; Output a character
f7df c8          INY
f7e0 c0 15       CPY #$15          ; compare with end+1
f7e2 d0 f6       BNE TFAH_20      ; loop if more to do
0001 FALSE    #if C64
SKIP             LDA JIFFYM
SKIP             JSR Delay_2JiffyM
SKIP             NOP
              #endif

f7e4          TFAH_30
f7e4 18          CLC               ; flag no error
f7e5 88          DEY               ; decrement index

f7e6          TFAH_Ret
f7e6 60          RTS ;Size   56 [TAPE_Find_Any_Header]

              ; *****************
f7e7            TAPE_Write_Header
              ; *****************

f7e7 85 9e       STA PTR1          ; save header type
f7e9 20 4d f8    JSR TAPE_Get_Buffer_Address
f7ec 90 5e       BCC TWH_Ret       ; exit if < $0200
                 PUSHW(STAL)       ; push I/O start address
f7ee a5 c2       LDA STAL+1
f7f0 48          PHA
f7f1 a5 c1       LDA STAL
f7f3 48          PHA

                 PUSHW(EAL)        ; push tape end address
f7f4 a5 af       LDA EAL+1
f7f6 48          PHA
f7f7 a5 ae       LDA EAL
f7f9 48          PHA

f7fa a0 bf       LDY #$BF          ; index to header end
f7fc a9 20       LDA #' '          ; clear byte, [SPACE]

f7fe          TWH_10
f7fe 91 b2       STA (TAPE1),Y     ; clear header byte
f800 88          DEY               ; decrement index
f801 d0 fb       BNE TWH_10        ; loop if more to do
f803 a5 9e       LDA PTR1          ; get header type back
f805 91 b2       STA (TAPE1),Y     ; write to header
f807 c8          INY
f808 a5 c1       LDA STAL          ; get I/O start address low byte
f80a 91 b2       STA (TAPE1),Y     ; write to header
f80c c8          INY
f80d a5 c2       LDA STAL+1        ; get I/O start address high byte
f80f 91 b2       STA (TAPE1),Y     ; write to header
f811 c8          INY
f812 a5 ae       LDA EAL           ; get tape end address low byte
f814 91 b2       STA (TAPE1),Y     ; write to header
f816 c8          INY
f817 a5 af       LDA EAL+1         ; get tape end address high byte
f819 91 b2       STA (TAPE1),Y     ; write to header
f81b c8          INY
f81c 84 9f       STY PTR2          ; save index
f81e a0 00       LDY #$00          ; clear Y
f820 84 9e       STY PTR1          ; clear name index

f822          TWH_20
f822 a4 9e       LDY PTR1          ; get name index
f824 c4 b7       CPY FNLEN         ; compare with file name length
f826 f0 0c       BEQ TWH_30        ; exit loop if all done
f828 b1 bb       LDA (FNADR ),Y    ; get file name byte
f82a a4 9f       LDY PTR2          ; get buffer index
f82c 91 b2       STA (TAPE1),Y     ; save file name byte to buffer
f82e e6 9e       INC PTR1          ; increment file name index
f830 e6 9f       INC PTR2          ; increment tape buffer index
f832 d0 ee       BNE TWH_20        ; loop, branch always

f834          TWH_30
f834 20 54 f8    JSR TAPE_Set_Buffer_Pointer
f837 a9 69       LDA #$69          ; set write lead cycle count
f839 85 ab       STA RIPRTY        ; save write lead cycle count
f83b 20 ea f8    JSR TAPE_Write
f83e a8          TAY
                 PULLW(EAL)
f83f 68          PLA
f840 85 ae       STA EAL
f842 68          PLA
f843 85 af       STA EAL+1

                 PULLW(STAL)
f845 68          PLA
f846 85 c1       STA STAL
f848 68          PLA
f849 85 c2       STA STAL+1

f84b 98          TYA

f84c          TWH_Ret
f84c 60          RTS ;Size  102 [TAPE_Write_Header]

              ; ***********************
f84d            TAPE_Get_Buffer_Address
              ; ***********************

                 LDXY(TAPE1)       ; get tape buffer start pointer low byte
f84d a6 b2       LDX TAPE1
f84f a4 b3       LDY TAPE1+1

f851 c0 02       CPY #2            ; compare high byte with $02xx
f853 60          RTS ;Size    7 [TAPE_Get_Buffer_Address]

              ; ***********************
f854            TAPE_Set_Buffer_Pointer
              ; ***********************

f854 20 4d f8    JSR TAPE_Get_Buffer_Address
f857 8a          TXA               ; copy tape buffer start pointer low byte
f858 85 c1       STA STAL          ; save as I/O address pointer low byte
f85a 18          CLC
f85b 69 c0       ADC #$C0          ; add buffer length low byte
f85d 85 ae       STA EAL           ; save tape buffer end pointer low byte
f85f 98          TYA               ; copy tape buffer start pointer high byte
f860 85 c2       STA STAL+1        ; save as I/O address pointer high byte
f862 69 00       ADC #$00          ; add buffer length high byte
f864 85 af       STA EAL+1         ; save tape buffer end pointer high byte
f866 60          RTS ;Size   19 [TAPE_Set_Buffer_Pointer]

              ; ********************
f867            TAPE_Find_Fileheader
              ; ********************

f867 20 af f7    JSR TAPE_Find_Any_Header
f86a b0 1d       BCS TFF_Ret       ; just exit if error
f86c a0 05       LDY #$05          ; index to name
f86e 84 9f       STY PTR2          ; save as tape buffer index
f870 a0 00       LDY #$00          ; clear Y
f872 84 9e       STY PTR1          ; save as name buffer index

f874          TFF_10
f874 c4 b7       CPY FNLEN         ; compare with file name length
f876 f0 10       BEQ TFF_20        ; ok exit if match
f878 b1 bb       LDA (FNADR ),Y    ; get file name byte
f87a a4 9f       LDY PTR2          ; get index to tape buffer
f87c d1 b2       CMP (TAPE1),Y     ; compare with tape header name byte
f87e d0 e7       BNE TAPE_Find_Fileheader
f880 e6 9e       INC PTR1          ; else increment name buffer index
f882 e6 9f       INC PTR2          ; increment tape buffer index
f884 a4 9e       LDY PTR1          ; get name buffer index
f886 d0 ec       BNE TFF_10        ; loop, branch always

f888          TFF_20
f888 18          CLC               ; flag ok

f889          TFF_Ret
f889 60          RTS ;Size   35 [TAPE_Find_Fileheader]

              ; ***************************
f88a            TAPE_Advance_Buffer_Pointer
              ; ***************************

f88a 20 4d f8    JSR TAPE_Get_Buffer_Address
f88d e6 a6       INC BUFPNT        ; increment tape buffer index
f88f a4 a6       LDY BUFPNT        ; get tape buffer index
f891 c0 c0       CPY #$C0          ; compare with buffer length
f893 60          RTS ;Size   10 [TAPE_Advance_Buffer_Pointer]

              ; *************
f894            Wait_For_Play
              ; *************

f894 20 ab f8    JSR TAPE_Sense
f897 f0 1c       BEQ TASe_10      ; exit if switch closed
f899 a0 1b       LDY #Msg_Play-Msg_Start

f89b          WFP_10
f89b 20 e6 f1    JSR Display_Kernal_IO_Message

f89e          WFP_20
f89e 20 4b f9    JSR TAPE_Abort_On_STOP
f8a1 20 ab f8    JSR TAPE_Sense
f8a4 d0 f8       BNE WFP_20        ; loop if cassette switch open
f8a6 a0 6a       LDY #Msg_ok-Msg_Start
f8a8 4c e6 f1    JMP Display_Kernal_IO_Message

              ; **********
f8ab            TAPE_Sense
              ; **********

0001 FALSE    #if C64
SKIP             LDA #$10
SKIP             BIT R6510
SKIP             BNE TASe_10
SKIP             BIT R6510
              #endif
0000 TRUE     #if VIC
f8ab a9 40       LDA #$40          ; mask for cassette switch
f8ad 2c 1f 91    BIT IEC_DRAN      ; test VIA 1 DRA, no handshake
f8b0 d0 03       BNE TASe_10       ; branch if cassette sense high
f8b2 2c 1f 91    BIT IEC_DRAN      ; test VIA 1 DRA again
              #endif

f8b5          TASe_10
f8b5 18          CLC
f8b6 60          RTS ;Size   12 [TAPE_Sense]

              ; ********************
f8b7            TAPE_Wait_For_Record
              ; ********************

f8b7 20 ab f8    JSR TAPE_Sense
f8ba f0 f9       BEQ TASe_10       ; exit if switch closed
f8bc a0 2e       LDY #Msg_Record-Msg_Start
f8be d0 db       BNE WFP_10        ; display message and wait for switch, branch always

              ; **************
f8c0            TAPE_Init_Read
              ; **************

f8c0 a9 00       LDA #0
f8c2 85 90       STA STATUS        ; clear serial status byte
f8c4 85 93       STA VERCKK        ; clear the load/verify flag
f8c6 20 54 f8    JSR TAPE_Set_Buffer_Pointer

              ; *********
f8c9            TAPE_Read
              ; *********

f8c9 20 94 f8    JSR Wait_For_Play
f8cc b0 1f       BCS TAWR_10      ; exit if STOP was pressed, uses further BCS at target
f8ce 78          SEI               ; disable interrupts
f8cf a9 00       LDA #0
f8d1 85 aa       STA RIDATA        ;.
f8d3 85 b4       STA BITTS         ;.
f8d5 85 b0       STA CMPO          ; clear tape timing constant min byte
f8d7 85 9e       STA PTR1          ; clear tape pass 1 error log/char buffer
f8d9 85 9f       STA PTR2          ; clear tape pass 2 error log corrected
f8db 85 9c       STA DPSW          ; clear byte received flag
0001 FALSE    #if C64
SKIP             LDA #$90
              #endif
0000 TRUE     #if VIC
f8dd a9 82       LDA #$82          ; enable CA1 interrupt
              #endif
f8df a2 0e       LDX #$0E          ; set index for tape read vector
f8e1 d0 11       BNE TAWR_20      ; go do tape read/write, branch always

              ; ***************
f8e3            Init_Tape_Write
              ; ***************

f8e3 20 54 f8    JSR TAPE_Set_Buffer_Pointer

              ; ********************
f8e6            TAPE_Write_With_Lead
              ; ********************

f8e6 a9 14       LDA #20           ; set write lead cycle count
f8e8 85 ab       STA RIPRTY        ; save write lead cycle count

              ; **********
f8ea            TAPE_Write
              ; **********

f8ea 20 b7 f8    JSR TAPE_Wait_For_Record

f8ed          TAWR_10
f8ed b0 68       BCS Clear_Saved_IRQ_Address
f8ef 78          SEI               ; disable interrupts
0001 FALSE    #if C64
SKIP             LDA #$82
              #endif
0000 TRUE     #if VIC
f8f0 a9 a0       LDA #$A0          ; enable VIA 2 T2 interrupt
              #endif
f8f2 a2 08       LDX #$08          ; set index for tape write tape leader vector

f8f4          TAWR_20
f8f4 a0 7f       LDY #$7F          ; disable all interrupts
f8f6 8c 2e 91    STY VIA2_IER      ; set VIA 2 IER, disable interrupts
f8f9 8d 2e 91    STA VIA2_IER      ; set VIA 2 IER, enable interrupts according to A
0001 FALSE    #if C64
SKIP             LDA CIA1_CRA
SKIP             ORA #$19
SKIP             STA CIA1_CRB      ; CIA1 Control Register B
SKIP             AND #$91
SKIP             STA TODSNS
              #endif
f8fc 20 60 f1    JSR RS232_Stop
0001 FALSE    #if C64
SKIP             LDA VIC_CONTROL_1
SKIP             AND #$EF          ; clear bit 8 of raster value
SKIP             STA VIC_CONTROL_1
              #endif
f8ff ad 14 03    LDA CINV          ; get IRQ vector low byte
f902 8d 9f 02    STA IRQTMP        ; save IRQ vector low byte
f905 ad 15 03    LDA CINV+1        ; get IRQ vector high byte
f908 8d a0 02    STA IRQTMP+1      ; save IRQ vector high byte
f90b 20 fb fc    JSR TAPE_Set_IRQ_Vector
f90e a9 02       LDA #$02          ; set copies count. the first copy is the load copy, the
f910 85 be       STA FSBLK         ; save copies count
f912 20 db fb    JSR TAPE_New_Byte_Setup
0001 FALSE    #if C64
SKIP             LDA R6510
              #endif
0000 TRUE     #if VIC
f915 ad 1c 91    LDA VIA1_PCR      ; get VIA 1 PCR
              #endif
0001 FALSE    #if C64
SKIP             AND #$1f
SKIP             STA R6510
              #endif
0000 TRUE     #if VIC
f918 29 fd       AND #$FD          ; CA2 low, turn on tape motor
f91a 09 0c       ORA #$0C          ; manual output mode
f91c 8d 1c 91    STA VIA1_PCR      ; set VIA 1 PCR
              #endif
f91f 85 c0       STA CAS1          ; set tape motor interlock
f921 a2 ff       LDX #$FF          ; outer loop count

f923          TAWR_30
f923 a0 ff       LDY #$FF          ; inner loop count

f925          TAWR_40
f925 88          DEY               ; decrement inner loop count
f926 d0 fd       BNE TAWR_40      ; loop if more to do
f928 ca          DEX               ; decrement outer loop count
f929 d0 f8       BNE TAWR_30      ; loop if more to do
0000 TRUE     #if VIC
f92b 8d 29 91    STA VIA2_T2CH     ; set VIA 2 T2C_h
              #endif
f92e 58          CLI               ; enable tape interrupts

f92f          TAWR_50
f92f ad a0 02    LDA IRQTMP+1      ; get saved IRQ high byte
f932 cd 15 03    CMP CINV+1        ; compare with the current IRQ high byte
f935 18          CLC               ; flag ok
f936 f0 1f       BEQ Clear_Saved_IRQ_Address
f938 20 4b f9    JSR TAPE_Abort_On_STOP
0001 FALSE    #if C64
SKIP             JSR Look_For_Special_Keys
              #endif
0000 TRUE     #if VIC
f93b ad 2d 91    LDA IEC_IFR       ; get VIA 2 IFR
f93e 29 40       AND #$40          ; mask T1 interrupt
f940 f0 ed       BEQ TAWR_50      ; loop if not T1 interrupt
f942 ad 14 91    LDA RS2_TIM_LOW   ; get VIA 1 T1C_l, clear T1 flag
f945 20 34 f7    JSR Kernal_UDTIM  ; Update the system clock
              #endif
f948 4c 2f f9    JMP TAWR_50      ; loop

              ; ******************
f94b            TAPE_Abort_On_STOP
              ; ******************

f94b 20 e1 ff    JSR STOP          ; Check if stop key is pressed
f94e 18          CLC               ; flag no stop
f94f d0 0b       BNE CSIA_Ret      ; exit if no stop
f951 20 cf fc    JSR Restoring_After_STOP
f954 38          SEC               ; flag stopped
f955 68          PLA               ; dump return address low byte
f956 68          PLA               ; dump return address high byte

              ; =======================
f957            Clear_Saved_IRQ_Address
              ; =======================

f957 a9 00       LDA #0
f959 8d a0 02    STA IRQTMP+1      ; clear saved IRQ address high byte

f95c          CSIA_Ret
f95c 60          RTS ;Size   18 [TAPE_Abort_On_STOP]

              ; **************
f95d            TAPE_Set_Timer
              ; **************

f95d 86 b1       STX CMPO+1        ; save tape timing constant max byte
f95f a5 b0       LDA CMPO          ; get tape timing constant min byte
f961 0a          ASL A             ; *2
f962 0a          ASL A             ; *4
f963 18          CLC
f964 65 b0       ADC CMPO          ; add tape timing constant min byte *5
f966 18          CLC
f967 65 b1       ADC CMPO+1        ; add tape timing constant max byte
f969 85 b1       STA CMPO+1        ; save tape timing constant max byte
f96b a9 00       LDA #$00          ;.
f96d 24 b0       BIT CMPO          ; test tape timing constant min byte
f96f 30 01       BMI TST_10        ; branch if b7 set
f971 2a          ROL A             ; else shift carry into ??

f972          TST_10
f972 06 b1       ASL CMPO+1        ; shift tape timing constant max byte
f974 2a          ROL A
f975 06 b1       ASL CMPO+1        ; shift tape timing constant max byte
f977 2a          ROL A
f978 aa          TAX

f979          TST_20
f979 ad 28 91    LDA VIA2_T2CL     ; get VIA 2 T2C_l
0001 FALSE    #if C64
SKIP             CMP #$16
              #endif
0000 TRUE     #if VIC
f97c c9 15       CMP #$15
              #endif
f97e 90 f9       BCC TST_20        ; loop if less
f980 65 b1       ADC CMPO+1        ; add tape timing constant max byte
f982 8d 24 91    STA VIA2_T1CL     ; set VIA 2 T1C_l
f985 8a          TXA
f986 6d 29 91    ADC VIA2_T2CH     ; add VIA 2 T2C_h
f989 8d 25 91    STA VIA2_T1CH     ; set VIA 2 T1C_h
0001 FALSE    #if C64
SKIP             LDA TODSNS
SKIP             STA CIA1_CRA
SKIP             STA TD1IRQ
SKIP             LDA CIA1_ICR      ; CIA1 Interrupt Control Register
SKIP             AND #$10
SKIP             BEQ TST_30
SKIP             LDA #>TST_30
SKIP             PHA
SKIP             LDA #<TST_30
SKIP             PHA
SKIP             JMP Clear_BREAK_Flag
SKIP          
SKIP          TST_30
              #endif
f98c 58          CLI
f98d 60          RTS ;Size   49 [TAPE_Set_Timer]


              ;**********************************************************************;
              ;
              ;   On Commodore computers, the streams consist of four kinds of symbols
              ;   that denote different kinds of low-to-high-to-low transitions on the
              ;   read or write signals of the Commodore cassette interface.
              ;
              ;   A A break in the communications, or a pulse with very long cycle
              ;      time.
              ;
              ;   B A short pulse, whose cycle time typically ranges from 296 to 424
              ;      microseconds, depending on the computer model.
              ;
              ;   C A medium-length pulse, whose cycle time typically ranges from
              ;      440 to 576 microseconds, depending on the computer model.
              ;
              ;   D A long pulse, whose cycle time typically ranges from 600 to 744
              ;      microseconds, depending on the computer model.
              ;
              ;   The actual interpretation of the serial data takes a little more work to
              ; explain. The typical ROM tape loader (and the turbo loaders) will
              ; initialize a timer with a specified value and start it counting down. If
              ; either the tape data changes or the timer runs out, an IRQ will occur. The
              ; loader will determine which condition caused the IRQ. If the tape data
              ; changed before the timer ran out, we have a short pulse, or a "0" bit. If
              ; the timer ran out first, we have a long pulse, or a "1" bit. Doing this
              ; continuously and we decode the entire file.
              ; read tape bits, IRQ routine
              ; read T2C which has been counting down from $FFFF. subtract this from $FFFF

              ; *************
f98e            TAPE_Read_IRQ
              ; *************

f98e ae 29 91    LDX VIA2_T2CH     ; get VIA 2 T2C_h
f991 a0 ff       LDY #$FF
f993 98          TYA
f994 ed 28 91    SBC VIA2_T2CL     ; subtract VIA 2 T2C_l
f997 ec 29 91    CPX VIA2_T2CH     ; compare VIA 2 T2C_h with previous
f99a d0 f2       BNE TAPE_Read_IRQ ; loop if timer low byte rolled over
f99c 86 b1       STX CMPO+1        ; save tape timing constant max byte
f99e aa          TAX               ; copy $FF - T2C_l
f99f 8c 28 91    STY VIA2_T2CL     ; set VIA 2 T2C_l to $FF
f9a2 8c 29 91    STY VIA2_T2CH     ; set VIA 2 T2C_h to $FF
0001 FALSE    #if C64
SKIP             LDA #$19
SKIP             STA CIA1_CRB      ; CIA1 Control Register B
SKIP             LDA CIA1_ICR      ; CIA1 Interrupt Control Register
SKIP             STA TRDTMP
              #endif
f9a5 98          TYA
f9a6 e5 b1       SBC CMPO+1        ; subtract tape timing constant max byte
f9a8 86 b1       STX CMPO+1        ; save tape timing constant max byte
f9aa 4a          LSR A             ; A = $FF - T2C_h >> 1
f9ab 66 b1       ROR CMPO+1        ; shift tape timing constant max byte
f9ad 4a          LSR A             ; A = $FF - T2C_h >> 1
f9ae 66 b1       ROR CMPO+1        ; shift tape timing constant max byte
f9b0 a5 b0       LDA CMPO          ; get tape timing constant min byte
f9b2 18          CLC
f9b3 69 3c       ADC #$3C
0000 TRUE     #if VIC
f9b5 2c 21 91    BIT KEYB_ROW      ; test VIA 2 DRA, keyboard row
              #endif
f9b8 c5 b1       CMP CMPO+1        ; compare with tape timing constant max byte
f9ba b0 4a       BCS TARI_14       ; branch if min + $3C >= ($FFFF - T2C) >> 2
f9bc a6 9c       LDX DPSW          ; get byte received flag
f9be f0 03       BEQ TARI_02       ; branch if not byte received
f9c0 4c ad fa    JMP TAPE_Store_Char      ; store tape character

f9c3          TARI_02
f9c3 a6 a3       LDX TSFCNT        ; get EOI flag byte
f9c5 30 1b       BMI TARI_04
f9c7 a2 00       LDX #$00
f9c9 69 30       ADC #$30
f9cb 65 b0       ADC CMPO          ; add tape timing constant min byte
f9cd c5 b1       CMP CMPO+1        ; compare with tape timing constant max byte
f9cf b0 1c       BCS TARI_08
f9d1 e8          INX
f9d2 69 26       ADC #$26
f9d4 65 b0       ADC CMPO          ; add tape timing constant min byte
f9d6 c5 b1       CMP CMPO+1        ; compare with tape timing constant max byte
f9d8 b0 17       BCS TARI_10
f9da 69 2c       ADC #$2C
f9dc 65 b0       ADC CMPO          ; add tape timing constant min byte
f9de c5 b1       CMP CMPO+1        ; compare with tape timing constant max byte
f9e0 90 03       BCC TARI_06

f9e2          TARI_04
f9e2 4c 60 fa    JMP TARI_30

f9e5          TARI_06
f9e5 a5 b4       LDA BITTS         ; get bit count
f9e7 f0 1d       BEQ TARI_14       ; branch if zero
f9e9 85 a8       STA BITCI         ; save receiver bit count in
f9eb d0 19       BNE TARI_14       ; branch always

f9ed          TARI_08
f9ed e6 a9       INC RINONE        ; increment ?? start bit check flag
f9ef b0 02       BCS TARI_12

f9f1          TARI_10
f9f1 c6 a9       DEC RINONE        ; decrement ?? start bit check flag

f9f3          TARI_12
f9f3 38          SEC
f9f4 e9 13       SBC #$13
f9f6 e5 b1       SBC CMPO+1        ; subtract tape timing constant max byte
f9f8 65 92       ADC SVXT          ; add timing constant for tape
f9fa 85 92       STA SVXT          ; save timing constant for tape
f9fc a5 a4       LDA TBTCNT        ; get tape bit cycle phase
f9fe 49 01       EOR #$01
fa00 85 a4       STA TBTCNT        ; save tape bit cycle phase
fa02 f0 21       BEQ TARI_22
fa04 86 d7       STX LASTKY

fa06          TARI_14
fa06 a5 b4       LDA BITTS         ; get bit count
fa08 f0 18       BEQ TARI_20       ; exit if zero

0001 FALSE    #if C64
SKIP             LDA TRDTMP
SKIP             AND #1
SKIP             BNE TARI_16
SKIP             LDA TD1IRQ
SKIP             BNE TARI_20
SKIP          
SKIP          TARI_16
              #endif
0000 TRUE     #if VIC  
fa0a 2c 2d 91    BIT IEC_IFR       ; test get 2 IFR
fa0d 50 13       BVC TARI_20       ; exit if no T1 interrupt
              #endif
fa0f a9 00       LDA #$00
fa11 85 a4       STA TBTCNT        ; clear tape bit cycle phase
0001 FALSE    #if C64
SKIP             STA TD1IRQ
              #endif
fa13 a5 a3       LDA TSFCNT        ;.get EOI flag byte
fa15 10 30       BPL TARI_28
fa17 30 c9       BMI TARI_04

fa19          TARI_18
fa19 a2 a6       LDX #$A6          ; set timimg max byte
fa1b 20 5d f9    JSR TAPE_Set_Timer
fa1e a5 9b       LDA PRTY
fa20 d0 c3       BNE TARI_06

fa22          TARI_20
fa22 4c 56 ff    JMP Exit_IRQ      ; restore registers and exit interrupt

fa25          TARI_22
fa25 a5 92       LDA SVXT          ; get timing constant for tape
fa27 f0 07       BEQ TARI_26
fa29 30 03       BMI TARI_24
fa2b c6 b0       DEC CMPO          ; decrement tape timing constant min byte
fa2d 2c          .byte   $2C

fa2e          TARI_24
fa2e e6 b0       INC CMPO          ; increment tape timing constant min byte

fa30          TARI_26
fa30 a9 00       LDA #0
fa32 85 92       STA SVXT          ; clear timing constant for tape
fa34 e4 d7       CPX LASTKY
fa36 d0 0f       BNE TARI_28
fa38 8a          TXA
fa39 d0 aa       BNE TARI_06
fa3b a5 a9       LDA RINONE        ; get start bit check flag
fa3d 30 c7       BMI TARI_14
fa3f c9 10       CMP #$10
fa41 90 c3       BCC TARI_14
fa43 85 96       STA SYNO          ; save cassette block synchronization number
fa45 b0 bf       BCS TARI_14

fa47          TARI_28
fa47 8a          TXA
fa48 45 9b       EOR PRTY
fa4a 85 9b       STA PRTY
fa4c a5 b4       LDA BITTS
fa4e f0 d2       BEQ TARI_20
fa50 c6 a3       DEC TSFCNT        ; decrement EOI flag byte
fa52 30 c5       BMI TARI_18
fa54 46 d7       LSR LASTKY
fa56 66 bf       ROR MYCH          ; parity count
fa58 a2 da       LDX #$DA          ; set timimg max byte
fa5a 20 5d f9    JSR TAPE_Set_Timer
fa5d 4c 56 ff    JMP Exit_IRQ      ; restore registers and exit interrupt

fa60          TARI_30
fa60 a5 96       LDA SYNO          ; get cassette block synchronization number
fa62 f0 04       BEQ TARI_32
fa64 a5 b4       LDA BITTS
fa66 f0 04       BEQ TARI_34

fa68          TARI_32
fa68 a5 a3       LDA TSFCNT        ; get EOI flag byte
0001 FALSE    #if C64
SKIP             BMI TARI_34
SKIP             JMP TARI_10
              #endif
0000 TRUE     #if VIC
fa6a 10 85       BPL TARI_10
              #endif

fa6c          TARI_34
fa6c 46 b1       LSR CMPO+1        ; shift tape timing constant max byte
fa6e a9 93       LDA #$93
fa70 38          SEC
fa71 e5 b1       SBC CMPO+1        ; subtract tape timing constant max byte
fa73 65 b0       ADC CMPO          ; add tape timing constant min byte
fa75 0a          ASL A
fa76 aa          TAX               ; copy timimg high byte
fa77 20 5d f9    JSR TAPE_Set_Timer      ; set timing
fa7a e6 9c       INC DPSW
fa7c a5 b4       LDA BITTS
fa7e d0 11       BNE TARI_36
fa80 a5 96       LDA SYNO          ; get cassette block synchronization number
fa82 f0 26       BEQ TARI_40
fa84 85 a8       STA BITCI         ; save receiver bit count in
fa86 a9 00       LDA #$00
fa88 85 96       STA SYNO          ; clear cassette block synchronization number
0001 FALSE    #if C64
SKIP             LDA #$81
              #endif
0000 TRUE     #if VIC
fa8a a9 c0       LDA #$C0          ; enable T1 interrupt
              #endif
fa8c 8d 2e 91    STA VIA2_IER      ; set VIA 2 IER
fa8f 85 b4       STA BITTS

fa91          TARI_36
fa91 a5 96       LDA SYNO          ; get cassette block synchronization number
fa93 85 b5       STA NXTBIT
fa95 f0 09       BEQ TARI_38
fa97 a9 00       LDA #$00
fa99 85 b4       STA BITTS
0001 FALSE    #if C64
SKIP             LDA #1
              #endif
0000 TRUE     #if VIC
fa9b a9 40       LDA #$40          ; disable T1 interrupt
              #endif
fa9d 8d 2e 91    STA VIA2_IER      ; set VIA 2 IER

faa0          TARI_38
faa0 a5 bf       LDA MYCH          ; parity count
faa2 85 bd       STA ROPRTY        ; save RS232 parity byte
faa4 a5 a8       LDA BITCI         ; get receiver bit count in
faa6 05 a9       ORA RINONE        ; OR with start bit check flag
faa8 85 b6       STA RODATA

faaa          TARI_40
faaa 4c 56 ff    JMP Exit_IRQ      ; restore registers and exit interrupt

              ; ===============
faad            TAPE_Store_Char
              ; ===============

faad 20 db fb    JSR TAPE_New_Byte_Setup
fab0 85 9c       STA DPSW          ; clear byte received flag
fab2 a2 da       LDX #$DA          ; set timimg max byte
fab4 20 5d f9    JSR TAPE_Set_Timer
fab7 a5 be       LDA FSBLK         ; get copies count
fab9 f0 02       BEQ TASC_10
fabb 85 a7       STA INBIT         ; save receiver input bit temporary storage

fabd          TASC_10
fabd a9 0f       LDA #$0F
fabf 24 aa       BIT RIDATA
fac1 10 17       BPL TASC_40
fac3 a5 b5       LDA NXTBIT
fac5 d0 0c       BNE TASC_20
fac7 a6 be       LDX FSBLK         ; get copies count
fac9 ca          DEX
faca d0 0b       BNE TASC_30       ; if ?? restore registers and exit interrupt
facc a9 08       LDA #$08          ; set short block
face 20 6a fe    JSR Ora_Status
fad1 d0 04       BNE TASC_30       ; restore registers and exit interrupt, branch always

fad3          TASC_20
fad3 a9 00       LDA #$00
fad5 85 aa       STA RIDATA

fad7          TASC_30
fad7 4c 56 ff    JMP Exit_IRQ      ; restore registers and exit interrupt

fada          TASC_40
fada 70 31       BVS TASC_64
fadc d0 18       BNE TASC_60
fade a5 b5       LDA NXTBIT
fae0 d0 f5       BNE TASC_30
fae2 a5 b6       LDA RODATA
fae4 d0 f1       BNE TASC_30
fae6 a5 a7       LDA INBIT         ; get receiver input bit temporary storage
fae8 4a          LSR A
fae9 a5 bd       LDA ROPRTY        ; get RS232 parity byte
faeb 30 03       BMI TASC_50
faed 90 18       BCC TASC_62
faef 18          CLC

faf0          TASC_50
faf0 b0 15       BCS TASC_62
faf2 29 0f       AND #$0F
faf4 85 aa       STA RIDATA

faf6          TASC_60
faf6 c6 aa       DEC RIDATA
faf8 d0 dd       BNE TASC_30
fafa a9 40       LDA #$40
fafc 85 aa       STA RIDATA
fafe 20 d2 fb    JSR Set_IO_Start
fb01 a9 00       LDA #0
fb03 85 ab       STA RIPRTY
fb05 f0 d0       BEQ TASC_30      ; branch always

fb07          TASC_62
fb07 a9 80       LDA #$80
fb09 85 aa       STA RIDATA
fb0b d0 ca       BNE TASC_30      ; restore registers and exit interrupt, branch always

fb0d          TASC_64
fb0d a5 b5       LDA NXTBIT
fb0f f0 0a       BEQ TASC_66

fb11          TASC_65
fb11 a9 04       LDA #$04
fb13 20 6a fe    JSR Ora_Status
fb16 a9 00       LDA #$00
fb18 4c 97 fb    JMP TASC_84

fb1b          TASC_66
fb1b 20 11 fd    JSR Check_IO_End
fb1e 90 03       BCC TASC_68
fb20 4c 95 fb    JMP TASC_82

fb23          TASC_68
fb23 a6 a7       LDX INBIT         ; get receiver input bit temporary storage
fb25 ca          DEX
fb26 f0 2d       BEQ TASC_72
fb28 a5 93       LDA VERCKK
fb2a f0 0c       BEQ TASC_70
fb2c a0 00       LDY #0
fb2e a5 bd       LDA ROPRTY
fb30 d1 ac       CMP (SAL),Y
fb32 f0 04       BEQ TASC_70
fb34 a9 01       LDA #$01
fb36 85 b6       STA RODATA

fb38          TASC_70
fb38 a5 b6       LDA RODATA
fb3a f0 4b       BEQ TASC_78
fb3c a2 3d       LDX #$3D
fb3e e4 9e       CPX PTR1
fb40 90 3e       BCC TASC_76
fb42 a6 9e       LDX PTR1
fb44 a5 ad       LDA SAL+1
fb46 9d 01 01    STA STACK+1,X
fb49 a5 ac       LDA SAL
fb4b 9d 00 01    STA STACK,X
fb4e e8          INX
fb4f e8          INX
fb50 86 9e       STX PTR1
fb52 4c 87 fb    JMP TASC_78

fb55          TASC_72
fb55 a6 9f       LDX PTR2
fb57 e4 9e       CPX PTR1
fb59 f0 35       BEQ TASC_80
fb5b a5 ac       LDA SAL
fb5d dd 00 01    CMP STACK,X
fb60 d0 2e       BNE TASC_80
fb62 a5 ad       LDA SAL+1
fb64 dd 01 01    CMP STACK+1,X
fb67 d0 27       BNE TASC_80
fb69 e6 9f       INC PTR2
fb6b e6 9f       INC PTR2
fb6d a5 93       LDA VERCKK        ; get load/verify flag
fb6f f0 0b       BEQ TASC_74      ; branch if load
fb71 a5 bd       LDA ROPRTY        ; get RS232 parity byte
fb73 a0 00       LDY #$00
fb75 d1 ac       CMP (SAL),Y
fb77 f0 17       BEQ TASC_80
fb79 c8          INY
fb7a 84 b6       STY RODATA

fb7c          TASC_74
fb7c a5 b6       LDA RODATA
fb7e f0 07       BEQ TASC_78

fb80          TASC_76
fb80 a9 10       LDA #$10
fb82 20 6a fe    JSR Ora_Status
fb85 d0 09       BNE TASC_80

fb87          TASC_78
fb87 a5 93       LDA VERCKK        ; get load/verify flag
fb89 d0 05       BNE TASC_80       ; branch if verify
fb8b a8          TAY
fb8c a5 bd       LDA ROPRTY        ; get RS232 parity byte
fb8e 91 ac       STA (SAL),Y

fb90          TASC_80
fb90 20 1b fd    JSR Inc_SAL_Word
fb93 d0 3a       BNE TASC_92      ; restore registers and exit interrupt, branch always

fb95          TASC_82
fb95 a9 80       LDA #$80

fb97          TASC_84
fb97 85 aa       STA RIDATA
0001 FALSE    #if C64
SKIP             SEI
SKIP             LDX #1
SKIP             STX CIA1_ICR      ; CIA1 Interrupt Control Register
SKIP             LDX CIA1_ICR      ; CIA1 Interrupt Control Register
              #endif
fb99 a6 be       LDX FSBLK         ; get copies count
fb9b ca          DEX
fb9c 30 02       BMI TASC_86
fb9e 86 be       STX FSBLK         ; save copies count

fba0          TASC_86
fba0 c6 a7       DEC INBIT         ; decrement receiver input bit temporary storage
fba2 f0 08       BEQ TASC_88
fba4 a5 9e       LDA PTR1
fba6 d0 27       BNE TASC_92       ; if ?? restore registers and exit interrupt
fba8 85 be       STA FSBLK         ; save copies count
fbaa f0 23       BEQ TASC_92       ; restore registers and exit interrupt, branch always

fbac          TASC_88
fbac 20 cf fc    JSR Restoring_After_STOP
fbaf 20 d2 fb    JSR Set_IO_Start
fbb2 a0 00       LDY #0
fbb4 84 ab       STY RIPRTY        ; clear checksum

fbb6          TASC_90
fbb6 b1 ac       LDA (SAL),Y       ; get byte from buffer
fbb8 45 ab       EOR RIPRTY        ; XOR with checksum
fbba 85 ab       STA RIPRTY        ; save new checksum
fbbc 20 1b fd    JSR Inc_SAL_Word
fbbf 20 11 fd    JSR Check_IO_End
fbc2 90 f2       BCC TASC_90       ; loop if not at end
fbc4 a5 ab       LDA RIPRTY        ; get computed checksum
fbc6 45 bd       EOR ROPRTY        ; compare with stored checksum ??
fbc8 f0 05       BEQ TASC_92       ; if checksum ok restore registers and exit interrupt
fbca a9 20       LDA #$20          ; else set checksum error
fbcc 20 6a fe    JSR Ora_Status

fbcf          TASC_92
fbcf 4c 56 ff    JMP Exit_IRQ      ; restore registers and exit interrupt

              ; ************
fbd2            Set_IO_Start
              ; ************
fbd2 a5 c2       LDA STAL+1        ; get I/O start address high byte
fbd4 85 ad       STA SAL+1         ; set buffer address high byte
fbd6 a5 c1       LDA STAL          ; get I/O start address low byte
fbd8 85 ac       STA SAL           ; set buffer address low byte
fbda 60          RTS ;Size    9 [Set_IO_Start]

              ; *******************
fbdb            TAPE_New_Byte_Setup
              ; *******************

fbdb a9 08       LDA #$08          ; eight bits to do
fbdd 85 a3       STA TSFCNT        ; set bit count
fbdf a9 00       LDA #0
fbe1 85 a4       STA TBTCNT        ; clear tape bit cycle phase
fbe3 85 a8       STA BITCI         ; clear start bit first cycle done flag
fbe5 85 9b       STA PRTY          ; clear byte parity
fbe7 85 a9       STA RINONE        ; clear start bit check flag, set no start bit yet
fbe9 60          RTS ;Size   15 [TAPE_New_Byte_Setup]

              ; **************
fbea            TAPE_Write_Bit
              ; **************

              ; this routine tests the least significant bit in the tape write byte
              ; and sets VIA 2 T2 depending on the state of the bit. if the bit is a 1
              ; a time of $00B0 cycles is set, if the bot is a 0 a time of $0060
              ; cycles is set. note that this routine does not shift the bits of the
              ; tape write byte but uses a copy of that byte, the byte itself is
              ; shifted elsewhere

fbea a5 bd       LDA ROPRTY        ; get tape write byte
fbec 4a          LSR A             ; shift lsb into Cb
fbed a9 60       LDA #$60          ; set time constant low byte for bit = 0
fbef 90 02       BCC TAPE_Write_Timer

              ; *******************
fbf1            TAPE_Timer_Bit_Is_1
              ; *******************

fbf1 a9 b0       LDA #$B0          ; set time constant low byte for bit = 1

              ; ****************
fbf3            TAPE_Write_Timer
              ; ****************

fbf3 a2 00       LDX #$00          ; set time constant high byte

              ; ****************
fbf5            TAPE_Start_Timer
              ; ****************

fbf5 8d 28 91    STA VIA2_T2CL     ; set VIA 2 T2C_l
fbf8 8e 29 91    STX VIA2_T2CH     ; set VIA 2 T2C_h
0001 FALSE    #if C64
SKIP             LDA CIA1_ICR    ; CIA1 Interrupt Control Register
SKIP             LDA #$19
SKIP             STA CIA1_CRB    ; CIA1 Control Register B
SKIP             LDA R6510
              #endif
0000 TRUE     #if VIC
fbfb ad 20 91    LDA KEYB_COL      ; get VIA 2 DRB, keyboard column
              #endif
fbfe 49 08       EOR #$08          ; toggle tape out bit
0001 FALSE    #if C64
SKIP              STA R6510
              #endif
0000 TRUE     #if VIC
fc00 8d 20 91    STA KEYB_COL      ; set VIA 2 DRB
              #endif
fc03 29 08       AND #$08          ; mask tape out bit
fc05 60          RTS ;Size   17 [TAPE_Start_Timer]

fc06          TAST_10
fc06 38          SEC               ; set carry flag
0001 FALSE    #if C64
SKIP             ROR RODATA
              #endif
0000 TRUE     #if VIC
fc07 66 ad       ROR SAL+1         ; set buffer address high byte negative, flag all sync,
              #endif
fc09 30 3c       BMI TAWI_15      ; restore registers and exit interrupt, branch always

              ; **************
fc0b            TAPE_Write_IRQ
              ; **************

              ; this is the routine that writes the bits to the tape. it is called each time VIA 2 T2
              ; times out and checks if the start bit is done, if so checks if the data bits are done,
              ; if so it checks if the byte is done, if so it checks if the synchronisation bytes are
              ; done, if so it checks if the data bytes are done, if so it checks if the checksum byte
              ; is done, if so it checks if both the load and verify copies have been done, if so it
              ; stops the tape

fc0b a5 a8       LDA BITCI         ; get start bit first cycle done flag
fc0d d0 12       BNE TAWI_05       ; if first cycle done go do rest of byte

              ; each byte sent starts with two half cycles of $0110 ststem clocks and the whole block
              ; ends with two more such half cycles

fc0f a9 10       LDA #$10          ; set first start cycle time constant low byte
fc11 a2 01       LDX #$01          ; set first start cycle time constant high byte
fc13 20 f5 fb    JSR TAPE_Start_Timer
fc16 d0 2f       BNE TAWI_15      ; if first half cycle go restore registers and exit
fc18 e6 a8       INC BITCI         ; set start bit first start cycle done flag
0001 FALSE    #if C64
SKIP             LDA RODATA
              #endif
0000 TRUE     #if VIC
fc1a a5 ad       LDA SAL+1         ; get buffer address high byte
              #endif
fc1c 10 29       BPL TAWI_15      ; if block not complete go restore registers and exit
fc1e 4c 95 fc    JMP TAWI_55      ; else do tape routine, block complete exit

              ; continue tape byte write. the first start cycle, both half cycles of it, is complete
              ; so the routine drops straight through to here

fc21          TAWI_05
fc21 a5 a9       LDA RINONE        ; get start bit check flag
fc23 d0 09       BNE TAWI_10       ; if the start bit is complete go send the byte bits

              ; after the two half cycles of $0110 ststem clocks the start bit is completed with two
              ; half cycles of $00B0 system clocks. this is the same as the first part of a 1 bit

fc25 20 f1 fb    JSR TAPE_Timer_Bit_Is_1
fc28 d0 1d       BNE TAWI_15       ; if first half cycle go restore registers and exit
fc2a e6 a9       INC RINONE        ; set start bit check flag
fc2c d0 19       BNE TAWI_15       ; restore registers and exit interrupt, branch always

              ; continue tape byte write. the start bit, both cycles of it, is complete so the routine
              ; drops straight through to here. now the cycle pairs for each bit, and the parity bit,
              ; are sent

fc2e          TAWI_10
fc2e 20 ea fb    JSR TAPE_Write_Bit
fc31 d0 14       BNE TAWI_15       ; if first half cycle go restore registers and exit
fc33 a5 a4       LDA TBTCNT        ; get tape bit cycle phase
fc35 49 01       EOR #$01          ; toggle b0
fc37 85 a4       STA TBTCNT        ; save tape bit cycle phase
fc39 f0 0f       BEQ TAWI_20       ; if bit cycle phase complete go setup for next bit

              ; each bit is written as two full cycles. a 1 is sent as a full cycle of $0160 system
              ; clocks then a full cycle of $00C0 system clocks. a 0 is sent as a full cycle of $00C0
              ; system clocks then a full cycle of $0160 system clocks. to do this each bit from the
              ; write byte is inverted during the second bit cycle phase. as the bit is inverted it
              ; is also added to the, one bit, parity count for this byte

fc3b a5 bd       LDA ROPRTY        ; get tape write byte
fc3d 49 01       EOR #$01          ; invert bit being sent
fc3f 85 bd       STA ROPRTY        ; save tape write byte
fc41 29 01       AND #$01          ; mask b0
fc43 45 9b       EOR PRTY          ; EOR with tape write byte parity bit
fc45 85 9b       STA PRTY          ; save tape write byte parity bit

fc47          TAWI_15
fc47 4c 56 ff    JMP Exit_IRQ      ; restore registers and exit interrupt

              ; the bit cycle phase is complete so shift out the just written bit and test for byte
              ; end

fc4a          TAWI_20
fc4a 46 bd       LSR ROPRTY        ; shift bit out of tape write byte
fc4c c6 a3       DEC TSFCNT        ; decrement tape write bit count
fc4e a5 a3       LDA TSFCNT        ; get tape write bit count
fc50 f0 3a       BEQ TAWI_45       ; if all the data bits have been written go setup for
fc52 10 f3       BPL TAWI_15       ; if all the data bits are not yet sent just restore the

              ; do next tape byte
              ; the byte is complete. the start bit, data bits and parity bit have been written to
              ; the tape so setup for the next byte

fc54          TAWI_25
fc54 20 db fb    JSR TAPE_New_Byte_Setup
fc57 58          CLI               ; enable interrupts
fc58 a5 a5       LDA CNTDN         ; get cassette synchronization character count
fc5a f0 12       BEQ TAWI_35       ; if synchronisation characters done go do block data

              ; at the start of each block sent to tape there are a number of synchronisation bytes
              ; that count down to the actual data. the commodore tape system saves two copies of all
              ; the tape data, the first is loaded and is indicated by the synchronisation bytes
              ; having b7 set, and the second copy is indicated by the synchronisation bytes having b7
              ; clear. the sequence goes $09, $08, ..... $02, $01, data bytes

fc5c a2 00       LDX #$00          ; clear X
fc5e 86 d7       STX LASTKY        ; clear checksum byte
fc60 c6 a5       DEC CNTDN         ; decrement cassette synchronization byte count
fc62 a6 be       LDX FSBLK         ; get cassette copies count
fc64 e0 02       CPX #$02          ; compare with load block indicator
fc66 d0 02       BNE TAWI_30       ; branch if not the load block
fc68 09 80       ORA #$80          ; this is the load block so make the synchronisation count
                                   ; go $89, $88, ..... $82, $81
fc6a          TAWI_30
fc6a 85 bd       STA ROPRTY        ; save the synchronisation byte as the tape write byte
fc6c d0 d9       BNE TAWI_15       ; restore registers and exit interrupt, branch always

              ; the synchronization bytes have been done so now check and do the actual block data

fc6e          TAWI_35
fc6e 20 11 fd    JSR Check_IO_End
fc71 90 0a       BCC TAWI_40       ; if not all done yet go get the byte to send
fc73 d0 91       BNE TAST_10       ; if pointer > end go flag block done and exit interrupt
fc75 e6 ad       INC SAL+1         ; increment buffer pointer high byte, this means the block
fc77 a5 d7       LDA LASTKY        ; get checksum byte
fc79 85 bd       STA ROPRTY        ; save checksum as tape write byte
fc7b b0 ca       BCS TAWI_15       ; restore registers and exit interrupt, branch always

              ; the block isn't finished so get the next byte to write to tape

fc7d          TAWI_40
fc7d a0 00       LDY #0
fc7f b1 ac       LDA (SAL),Y       ; get byte from buffer
fc81 85 bd       STA ROPRTY        ; save as tape write byte
fc83 45 d7       EOR LASTKY        ; XOR with checksum byte
fc85 85 d7       STA LASTKY        ; save new checksum byte
fc87 20 1b fd    JSR Inc_SAL_Word
fc8a d0 bb       BNE TAWI_15       ; restore registers and exit interrupt, branch always

              ; set parity as next bit and exit interrupt

fc8c          TAWI_45
fc8c a5 9b       LDA PRTY          ; get parity bit
fc8e 49 01       EOR #$01          ; toggle it
fc90 85 bd       STA ROPRTY        ; save as tape write byte

fc92          TAWI_50
fc92 4c 56 ff    JMP Exit_IRQ      ; restore registers and exit interrupt

              ; tape routine, block complete exit

fc95          TAWI_55
fc95 c6 be       DEC FSBLK         ; decrement copies remaining to read/write
fc97 d0 03       BNE TAWI_60       ; branch if more to do
fc99 20 08 fd    JSR TAPE_Stop_Motor

fc9c          TAWI_60
fc9c a9 50       LDA #$50          ; set tape write leader count
fc9e 85 a7       STA INBIT         ; save tape write leader count
fca0 a2 08       LDX #$08          ; set index for write tape leader vector
fca2 78          SEI               ; disable interrupts
fca3 20 fb fc    JSR TAPE_Set_IRQ_Vector
fca6 d0 ea       BNE TAWI_50       ; restore registers and exit interrupt, branch always

fca8          TAPE_Write_Leader
fca8 a9 78       LDA #$78          ; set time constant low byte for bit = leader
fcaa 20 f3 fb    JSR TAPE_Write_Timer
fcad d0 e3       BNE TAWI_50       ; if tape bit high restore registers and exit interrupt
fcaf c6 a7       DEC INBIT         ; decrement cycle count
fcb1 d0 df       BNE TAWI_50       ; if not all done restore registers and exit interrupt
fcb3 20 db fb    JSR TAPE_New_Byte_Setup
fcb6 c6 ab       DEC RIPRTY        ; decrement cassette leader count
fcb8 10 d8       BPL TAWI_50       ; if not all done restore registers and exit interrupt
fcba a2 0a       LDX #$0A          ; set index for tape write vector
fcbc 20 fb fc    JSR TAPE_Set_IRQ_Vector
fcbf 58          CLI               ; enable interrupts
fcc0 e6 ab       INC RIPRTY        ; clear cassette leader counter, was $FF
fcc2 a5 be       LDA FSBLK         ; get cassette block count
fcc4 f0 30       BEQ Reset_TAPE_IRQ      ; if all done restore everything for STOP and exit interrupt
fcc6 20 d2 fb    JSR Set_IO_Start
fcc9 a2 09       LDX #$09          ; set nine synchronisation bytes
fccb 86 a5       STX CNTDN         ; save cassette synchronization byte count
0001 FALSE    #if C64
SKIP             STX RODATA
              #endif
fccd d0 85       BNE TAWI_25      ; go do next tape byte, branch always

              ; ********************
fccf            Restoring_After_STOP
              ; ********************

fccf 08          PHP               ; save status
fcd0 78          SEI               ; disable interrupts
0001 FALSE    #if C64
SKIP             LDA VIC_CONTROL_1
SKIP             ORA #$10          ; set DEN bit
SKIP             STA VIC_CONTROL_1
              #endif
fcd1 20 08 fd    JSR TAPE_Stop_Motor
fcd4 a9 7f       LDA #$7F          ; disable all interrupts
0001 FALSE    #if C64
SKIP             STA CIA1_ICR      ; CIA1 Interrupt Control Register
              #endif
0000 TRUE     #if VIC
fcd6 8d 2e 91    STA $912E
              #endif
0000 TRUE     #if VIC
fcd9 a9 f7       LDA #$F7          ; set keyboard column 3 active
fcdb 8d 20 91    STA KEYB_COL      ; set VIA 2 DRB, keyboard column
fcde a9 40       LDA #$40          ; set T1 free run, T2 clock Ø2,
fce0 8d 2b 91    STA VIA2_ACR      ; set VIA 2 ACR
              #endif
fce3 20 39 fe    JSR Program_Timer_A
fce6 ad a0 02    LDA IRQTMP+1      ; get saved IRQ vector high byte
fce9 f0 09       BEQ RAS_10        ; branch if null
fceb 8d 15 03    STA CINV+1        ; restore IRQ vector high byte
fcee ad 9f 02    LDA IRQTMP        ; get saved IRQ vector low byte
fcf1 8d 14 03    STA CINV          ; restore IRQ vector low byte

fcf4          RAS_10
fcf4 28          PLP               ; restore status
fcf5 60          RTS ;Size   39 [Restoring_After_STOP]

              ; **************
fcf6            Reset_TAPE_IRQ
              ; **************

fcf6 20 cf fc    JSR Restoring_After_STOP
fcf9 f0 97       BEQ TAWI_50      ; restore registers and exit interrupt, branch always

              ; *******************
fcfb            TAPE_Set_IRQ_Vector
              ; *******************

fcfb bd e9 fd    LDA TAPE_IRQ_Vectors-8,X  ; get tape IRQ vector low byte
fcfe 8d 14 03    STA CINV          ; set IRQ vector low byte
fd01 bd ea fd    LDA TAPE_IRQ_Vectors-7,X  ; get tape IRQ vector high byte
fd04 8d 15 03    STA CINV+1        ; set IRQ vector high byte
fd07 60          RTS ;Size   13 [TAPE_Set_IRQ_Vector]

              ; ***************
fd08            TAPE_Stop_Motor
              ; ***************

0001 FALSE    #if C64
SKIP             LDA R6510
SKIP             ORA #$20
SKIP             STA R6510
              #endif
0000 TRUE     #if VIC
fd08 ad 1c 91    LDA VIA1_PCR      ; get VIA 1 PCR
fd0b 09 0e       ORA #$0E          ; set CA2 high, cassette motor off
fd0d 8d 1c 91    STA VIA1_PCR      ; set VIA 1 PCR
              #endif
fd10 60          RTS ;Size    9 [TAPE_Stop_Motor]
              #endif               ; JIFFY

              ; ************
fd11            Check_IO_End
              ; ************

fd11 38          SEC
fd12 a5 ac       LDA SAL           ; get buffer address low byte
fd14 e5 ae       SBC EAL           ; subtract buffer end low byte
fd16 a5 ad       LDA SAL+1         ; get buffer address high byte
fd18 e5 af       SBC EAL+1         ; subtract buffer end high byte
fd1a 60          RTS ;Size   10 [Check_IO_End]

              ; ************
fd1b            Inc_SAL_Word
              ; ************

fd1b e6 ac       INC SAL
fd1d d0 02       BNE ISW_Ret
fd1f e6 ad       INC SAL+1
fd21          ISW_Ret
fd21 60          RTS ;Size    7 [Inc_SAL_Word]

              ; ***********
fd22            Entry_RESET        ; hardware reset
              ; ***********

fd22 a2 ff       LDX #$FF          ; set X for stack
fd24 78          SEI               ; disable interrupts
fd25 9a          TXS               ; clear stack
fd26 d8          CLD               ; clear decimal mode
fd27 20 3f fd    JSR Scan_Autostart_Signature
fd2a d0 03       BNE HARE_10       ; if not there continue Vic startup
fd2c 6c 00 a0    JMP (OPTION_ROM)

fd2f          HARE_10
0001 FALSE    #if C64
SKIP             STX VIC_CONTROL_2
SKIP             JSR Initialise_IO
SKIP             JSR Init_RAM
SKIP             JSR Kernal_RESTOR
SKIP             JSR Init_Editor
              #endif
0000 TRUE     #if VIC
fd2f 20 8d fd    JSR Init_RAM
fd32 20 52 fd    JSR Kernal_RESTOR
fd35 20 f9 fd    JSR Initialise_IO
fd38 20 18 e5    JSR Initialise_Hardware
              #endif
fd3b 58          CLI               ; enable interrupts
fd3c 6c 00 c0    JMP (BASIC_ROM)   ; start BASIC

              ; ************************
fd3f            Scan_Autostart_Signature
              ; ************************

fd3f a2 05       LDX #5            ; five characters to test

fd41          SAAS_Loop
fd41 bd 4c fd    LDA ROM_SIG-1,X   ; get test character
fd44 dd 03 a0    CMP OPTION_ROM+3,X; compare with byte in block A000
fd47 d0 03       BNE SAAS_Exit     ; exit if no match
fd49 ca          DEX               ; decrement index
fd4a d0 f5       BNE SAAS_Loop

fd4c          SAAS_Exit
fd4c 60          RTS ;Size   14 [Scan_Autostart_Signature]

0001 FALSE    #if C64
SKIP          ROM_SIG .byte $C3,$C2,$CD,"80" ; CBM80
              #endif
0000 TRUE     #if VIC
fd4d 41 30 c3 ROM_SIG .byte "A0",$C3,$C2,$CD ; A0CBM
              #endif

              ; *************
fd52            Kernal_RESTOR
              ; *************

fd52 a2 6d       LDX #<Kernal_Vectors    ; pointer to vector table low byte
fd54 a0 fd       LDY #>Kernal_Vectors    ; pointer to vector table high byte
fd56 18          CLC               ; flag set vectors

              ; *************
fd57            Kernal_VECTOR
              ; *************

                 STXY(MEMUSS)      ; save pointer
fd57 86 c3       STX MEMUSS
fd59 84 c4       STY MEMUSS+1

fd5b a0 1f       LDY #$1F          ; set byte count

fd5d          KeVE_10
0001 FALSE    #if JIFFY & VIC
SKIP             LDA (MEMUSS),Y    ; bugfix for the original code, that writes
SKIP             BCC KeVe_30       ; into the RAM bank at address of the
SKIP             LDA CINV,Y        ; Kernal vectors in ROM
              #else
fd5d b9 14 03    LDA CINV,Y        ; read vector byte from vectors
fd60 b0 02       BCS KeVE_20       ; if read vectors skip the read from XY
fd62 b1 c3       LDA (MEMUSS),Y    ; read vector byte from (XY)
              #endif

fd64          KeVE_20
fd64 91 c3       STA (MEMUSS),Y    ; save byte to (XY) [may be ROM address]

fd66          KeVe_30
fd66 99 14 03    STA CINV,Y        ; save byte to vector
fd69 88          DEY               ; decrement index
fd6a 10 f1       BPL KeVE_10       ; loop if more to do
fd6c 60          RTS ;Size   22 [Kernal_VECTOR]

              ; **************
fd6d            Kernal_Vectors
              ; **************

fd6d bf ea       .word   Default_IRQ   ; CINV   IRQ vector
fd6f d2 fe       .word   Default_BRK   ; CBINV  BRK vector
fd71 ad fe       .word   Default_NMI   ; NMINV  NMI vector
fd73 0a f4       .word   Kernal_OPEN   ; IOPEN  Open a logical file
fd75 4a f3       .word   Kernal_CLOSE  ; ICLOSE close a logical file
fd77 c7 f2       .word   Kernal_ICHKIN ; ICHKIN open channel for input
fd79 09 f3       .word   Kernal_CHKOUT ; ICKOUT open channel for output
fd7b f3 f3       .word   Kernal_CLRCHN ; ICLRCH clear I/O channels
fd7d 0e f2       .word   Kernal_CHRIN  ; IBASIN get a character from the input channel
fd7f 7a f2       .word   Kernal_CHROUT ; IBSOUT output a character
fd81 70 f7       .word   Kernal_STOP   ; ISTOP  check if stop key is pressed
fd83 f5 f1       .word   Kernal_GETIN  ; IGETIN get character from keyboard queue
fd85 ef f3       .word   Kernal_CLALL  ; ICLALL close all channels and files
fd87 d2 fe       .word   Default_BRK   ; USRCMD user function

              ; Vector to user defined command, currently points to BRK.

              ; This appears to be a holdover from PET days, when the built-in machine language monitor
              ; would jump through the USRCMD vector when it encountered a command that it did not
              ; understand, allowing the user to add new commands to the monitor.

              ; Although this vector is initialized to point to the routine called by STOP/RESTORE and
              ; the BRK interrupt, and is updated by the kernal vector routine at $FD57, it no longer
              ; has any function.

fd89 49 f5       .word   Default_LOAD; ILOAD      load
fd8b 85 f6       .word   Default_SAVE; ISAVE      save

              ; initialise and test RAM, the RAM from $000 to $03FF is never tested and is just assumed
              ; to work. first a search is done from $0401 for the start of memory and this is saved, if
              ; this start is at or beyond $1100 then the routine dead ends. once the start of memory is
              ; found the routine looks for the end of memory, if this end is before $2000 the routine
              ; again dead ends. lastly, if the end of memory is at $2000 then the screen is set to
              ; $1E00, but if the memory extends to or beyond $2100 then the screen is moved to $1000

fd8d          Init_RAM
fd8d a9 00       LDA #0
0001 FALSE    #if C64 
SKIP             TAY               ; clear index
SKIP          
SKIP          InRA_10
SKIP             STA $0002,Y       ; clear page 0
SKIP             STA $0200,Y       ; clear page 2
SKIP             STA $0300,Y       ; clear page 3
SKIP             INY
              #endif
0000 TRUE     #if VIC
fd8f aa          TAX               ; clear index

fd90          InRA_10
fd90 95 00       STA $0000,X       ; clear page 0
fd92 9d 00 02    STA $0200,X       ; clear page 2
fd95 9d 00 03    STA $0300,X       ; clear page 3
fd98 e8          INX               ; increment index
              #endif
fd99 d0 f5       BNE InRA_10       ; loop if more to do
fd9b a2 3c       LDX #<TBUFFR      ; set cassette buffer pointer low byte
fd9d a0 03       LDY #>TBUFFR      ; set cassette buffer pointer high byte
fd9f 86 b2       STX TAPE1         ; save tape buffer start pointer low byte
fda1 84 b3       STY TAPE1+1       ; save tape buffer start pointer high byte

0001 FALSE    #if C64
SKIP             TAY
SKIP             LDA #3
SKIP             STA STAL+1
SKIP          
SKIP          InRA_20
SKIP             INC STAL+1
SKIP          
SKIP          InRA_30
SKIP             LDA (STAL),Y
SKIP             TAX   
SKIP             LDA #$55 ; 'U' 
SKIP             STA (STAL),Y
SKIP             CMP (STAL),Y
SKIP             BNE InRA_40 
SKIP             ROL A 
SKIP             STA (STAL),Y
SKIP             CMP (STAL),Y
SKIP             BNE InRA_40 
SKIP             TXA   
SKIP             STA (STAL),Y
SKIP             INY   
SKIP             BNE InRA_30 
SKIP             BEQ InRA_20 
SKIP          
SKIP          InRA_40
SKIP             TYA   
SKIP             TAX   
SKIP             LDY STAL+1
SKIP             CLC   
SKIP             JSR Set_memtop
SKIP             LDA #>BASIC_RAM_START
SKIP             STA OSSTAR+1
SKIP             LDA #>BASIC_SCREEN
SKIP             STA SCNMPG
SKIP             RTS   
              #endif

0000 TRUE     #if VIC
fda3 85 c1       STA STAL          ; clear RAM test pointer low byte
fda5 85 97       STA TEMPX         ; clear looking for end flag
fda7 8d 81 02    STA OSSTAR        ; clear OS start of memory low byte
fdaa a8          TAY               ; clear Y
fdab a9 04       LDA #$04          ; set RAM test pointer high byte
fdad 85 c2       STA STAL+1        ; save RAM test pointer high byte

fdaf          InRA_50
fdaf e6 c1       INC STAL          ; increment RAM test pointer low byte
fdb1 d0 02       BNE InRA_55       ; if no rollover skip the high byte increment
fdb3 e6 c2       INC STAL+1        ; increment RAM test pointer high byte

fdb5          InRA_55
fdb5 20 91 fe    JSR Test_RAM_byte ; test RAM byte, return Cb=0 if failed
fdb8 a5 97       LDA TEMPX         ; test looking for end flag
fdba f0 22       BEQ InRA_70       ; branch if not looking for end
fdbc b0 f1       BCS InRA_50       ; loop if byte test passed
fdbe a4 c2       LDY STAL+1        ; get test address high byte
fdc0 a6 c1       LDX STAL          ; get test address low byte
fdc2 c0 20       CPY #$20          ; compare with $2000, RAM should always end at or after
fdc4 90 25       BCC InRA_75       ; if end address < $2000 go do dead end loop
fdc6 c0 21       CPY #$21          ; compare with $2100
fdc8 b0 08       BCS InRA_65       ; branch if >= $2100
fdca a0 1e       LDY #$1E          ; set screen memory page to $1E00
fdcc 8c 88 02    STY SCNMPG        ; save screen memory page

fdcf          InRA_60
fdcf 4c 7b fe    JMP Set_memtop      ; set the top of memory and return

fdd2          InRA_65
fdd2 a9 12       LDA #$12          ; set OS start of memory high byte
fdd4 8d 82 02    STA OSSTAR+1      ; save OS start of memory high byte
fdd7 a9 10       LDA #$10          ; set screen memory page to $1000
fdd9 8d 88 02    STA SCNMPG        ; save screen memory page
fddc d0 f1       BNE InRA_60       ; set the top of memory and return, branch always

fdde          InRA_70
fdde 90 cf       BCC InRA_50       ; loop if byte test failed, not found start yet
fde0 a5 c2       LDA STAL+1        ; get test address high byte
fde2 8d 82 02    STA OSSTAR+1      ; save OS start of memory high byte
fde5 85 97       STA TEMPX         ; set looking for end flag
fde7 c9 11       CMP #$11          ; compare start with $1100, RAM should always start before
fde9 90 c4       BCC InRA_50       ; go find end of RAM, branch always

fdeb          InRA_75
fdeb 20 c3 e5    JSR Init_VIC_Chip
fdee 4c eb fd    JMP InRA_75       ; loop forever
              #endif

fdf1          TAPE_IRQ_Vectors
0001 FALSE    #if JIFFY
0001 FALSE    #if C64
SKIP             .word   $fc6a             ; $08   write tape leader IRQ routine
SKIP             .word   $fbcd             ; $0A   tape write IRQ routine
SKIP             .word   $ea31             ; $0C   normal IRQ vector
SKIP             .word   $f92c             ; $0E   read tape bits IRQ routine
              #endif
0000 TRUE     #if VIC
SKIP             .word   $fca8             ; $08   write tape leader IRQ routine
SKIP             .word   $fc0b             ; $0A   tape write IRQ routine
SKIP             .word   Default_IRQ       ; $0C   normal IRQ vector
SKIP             .word   $f98e             ; $0E   read tape bits IRQ routine
              #endif
              #else
fdf1 a8 fc       .word   TAPE_Write_Leader ; $08   write tape leader IRQ routine
fdf3 0b fc       .word   TAPE_Write_IRQ    ; $0A   tape write IRQ routine
fdf5 bf ea       .word   Default_IRQ       ; $0C   normal IRQ vector
fdf7 8e f9       .word   TAPE_Read_IRQ     ; $0E   read tape bits IRQ routine
              #endif

              ; *************
fdf9            Initialise_IO
              ; *************

0001 FALSE    #if C64
SKIP             LDA #$7f
SKIP             STA CIA1_ICR    ; CIA1 Interrupt Control Register
SKIP             STA CIA2_ICR
SKIP             STA KEYB_COL
SKIP             LDA #8
SKIP             STA CIA1_CRA
SKIP             STA CIA2_CRA
SKIP             STA CIA1_CRB    ; CIA1 Control Register B
SKIP             STA CIA2_CRB
SKIP             LDX #0
SKIP             STX $DC03
SKIP             STX $DD03
SKIP             STX $D418
SKIP             DEX
SKIP             STX $DC02
SKIP             LDA #7
SKIP             STA $DD00
SKIP             LDA #$3f ; '?'
SKIP             STA $DD02
SKIP             LDA #$e7
SKIP             STA R6510
SKIP             LDA #$2f ; '/'
SKIP             STA D6510
              #endif
0000 TRUE     #if VIC
fdf9 a9 7f       LDA #$7F          ; disable all interrupts
fdfb 8d 1e 91    STA RS2_IRQ_REG   ; on VIA 1 IER ..
fdfe 8d 2e 91    STA VIA2_IER      ; .. and VIA 2 IER
fe01 a9 40       LDA #$40          ; set T1 free run, T2 clock Ø2,
                                   ; SR disabled, latches disabled
fe03 8d 2b 91    STA VIA2_ACR      ; set VIA 2 ACR
fe06 a9 40       LDA #$40          ; set T1 free run, T2 clock Ø2,
                                   ; SR disabled, latches disabled
fe08 8d 1b 91    STA VIA1_ACR      ; set VIA 1 ACR
fe0b a9 fe       LDA #$FE          ; CB2 high, RS232 Tx
                                   ; CB1 positive edge,
                                   ; CA2 high, tape motor off
                                   ; CA1 negative edge
fe0d 8d 1c 91    STA VIA1_PCR      ; set VIA 1 PCR
fe10 a9 de       LDA #$DE          ; CB2 low, serial data out high
                                   ; CB1 positive edge,
                                   ; CA2 high, serial clock out low
                                   ; CA1 negative edge
fe12 8d 2c 91    STA IEC_PCR       ; set VIA 2 PCR
fe15 a2 00       LDX #$00          ; all inputs, RS232 interface or parallel user port
fe17 8e 12 91    STX VIA1_DDRB     ; set VIA 1 DDRB
fe1a a2 ff       LDX #$FF          ; all outputs, keyboard column
fe1c 8e 22 91    STX VIA2_DDRB     ; set VIA 2 DDRB
fe1f a2 00       LDX #$00          ; all inputs, keyboard row
fe21 8e 23 91    STX VIA2_DDRA     ; set VIA 2 DDRA
fe24 a2 80       LDX #$80          ; OIII IIII, ATN out, light pen, joystick, serial data
                                   ; in, serial clk in
fe26 8e 13 91    STX VIA1_DDRA     ; set VIA 1 DDRA
fe29 a2 00       LDX #$00          ; ATN out low, set ATN high
fe2b 8e 1f 91    STX IEC_DRAN      ; set VIA 1 DRA, no handshake
fe2e 20 84 ef    JSR CLR_IEC_CLK   ; set serial clock high
fe31 a9 82       LDA #$82          ; enable CA1 interrupt, [RESTORE] key
fe33 8d 1e 91    STA RS2_IRQ_REG   ; set VIA 1 IER
fe36 20 8d ef    JSR SET_IEC_CLK   ; set serial clock low
              #endif

              ; ***************
fe39            Program_Timer_A
              ; ***************

0001 FALSE    #if C64
SKIP             LDA TVSFLG
SKIP             BEQ TASF_10
SKIP             LDA #<$4025       ; 16421
SKIP             STA CIA1_TALO
SKIP             LDA #>$4025
SKIP             JMP TASF_20
SKIP          TASF_10
SKIP             LDA #<$4295       ; 17045
SKIP             STA CIA1_TALO
SKIP             LDA #>$4295
SKIP          TASF_20
SKIP             STA CIA1_TAHI
SKIP             JMP PTA_10
              #endif
0000 TRUE     #if VIC
fe39 a9 c0       LDA #$C0          ; enable T1 interrupt
fe3b 8d 2e 91    STA VIA2_IER      ; set VIA 2 IER
0001 FALSE    #if PAL
SKIP             LDA #$26          ; set timer constant low byte [PAL]
              #else
fe3e a9 89       LDA #$89          ; set timer constant low byte [NTSC]
              #endif
fe40 8d 24 91    STA VIA2_T1CL     ; set VIA 2 T1C_l
0001 FALSE    #if PAL
SKIP             LDA #$48          ; set timer constant high byte [PAL]
              #else
fe43 a9 42       LDA #$42          ; set timer constant high byte [NTSC]
              #endif
fe45 8d 25 91    STA VIA2_T1CH     ; set VIA 2 T1C_h
fe48 60          RTS ;Size   16 [Program_Timer_A]
              #endif

              ; *************
fe49            Kernal_SETNAM
              ; *************

fe49 85 b7       STA FNLEN         ; set file name length
fe4b 86 bb       STX FNADR         ; set file name pointer low byte
fe4d 84 bc       STY FNADR+1       ; set file name pointer high byte
fe4f 60          RTS ;Size    7 [Kernal_SETNAM]

              ; *************
fe50            Kernal_SETLFS
              ; *************

fe50 85 b8       STA LA            ; set logical file
fe52 86 ba       STX FA            ; set device number
fe54 84 b9       STY SA            ; set secondary address or command
fe56 60          RTS ;Size    7 [Kernal_SETLFS]

              ; *************
fe57            Kernal_READST
              ; *************

fe57 a5 ba       LDA FA            ; get device number
fe59 c9 02       CMP #$02          ; compare device with RS232 device
fe5b d0 0b       BNE Get_Status    ; branch if not RS232 device
fe5d ad 97 02    LDA RSSTAT        ; read RS232 status word
0001 FALSE    #if C64
SKIP             PHA
              #endif
fe60 a9 00       LDA #0
fe62 8d 97 02    STA RSSTAT        ; clear RS232 status
0001 FALSE    #if C64
SKIP             PLA
              #endif

              ; the above code is wrong. the RS232 status is in A but A is cleared and that is used
              ; to clear the RS232 status byte. so whatever the status the result is always $00 and
              ; the status byte is always cleared. A solution is to use X to clear the status after
              ; it is read instead of the above like this ..
              ;
              ;   LDX   #$00         ; clear X
              ;   STX   RSSTAT       ; clear RS232 status ##
fe65 60          RTS ;Size   15 [Kernal_READST]

              ; *************
fe66            Kernal_SETMSG
              ; *************

fe66 85 9d       STA MSGFLG        ; set message mode flag

fe68          Get_Status
fe68 a5 90       LDA STATUS        ; read serial status byte

              ; **********
fe6a            Ora_Status
              ; **********

fe6a 05 90       ORA STATUS        ; OR with serial status byte
fe6c 85 90       STA STATUS        ; save serial status byte
fe6e 60          RTS ;Size    5 [Ora_Status]

              ; *************
fe6f            Kernal_SETTMO
              ; *************

fe6f 8d 85 02    STA STIMOT        ; save serial bus timeout flag
fe72 60          RTS ;Size    4 [Kernal_SETTMO]

              ; *************
fe73            Kernal_MEMTOP
              ; *************

fe73 90 06       BCC Set_memtop      ; if Cb clear go set the top of memory

              ; ***********
fe75            Read_Memtop
              ; ***********

fe75 ae 83 02    LDX OSTOP         ; get memory top low byte
fe78 ac 84 02    LDY OSTOP+1       ; get memory top high byte

              ; **********
fe7b            Set_memtop
              ; **********

fe7b 8e 83 02    STX OSTOP         ; set memory top low byte
fe7e 8c 84 02    STY OSTOP+1       ; set memory top high byte
fe81 60          RTS ;Size    7 [Set_memtop]

              ; *************
fe82            Kernal_MEMBOT
              ; *************

fe82 90 06       BCC MEM_10        ; if Cb clear go set the bottom of memory

              ; read the bottom of memory

fe84 ae 81 02    LDX OSSTAR        ; read OS start of memory low byte
fe87 ac 82 02    LDY OSSTAR+1      ; read OS start of memory high byte

              ; set the bottom of memory

fe8a          MEM_10
                 STXY(OSSTAR)      ; set OS start of memory
fe8a 8e 81 02    STX OSSTAR
fe8d 8c 82 02    STY OSSTAR+1

fe90 60          RTS ;Size   15 [Kernal_MEMBOT]

0000 TRUE     #if VIC
              ; *************
fe91            Test_RAM_byte      ; return (C=1) on failure
              ; *************

fe91 b1 c1       LDA (STAL),Y      ; get existing RAM byte
fe93 aa          TAX               ; copy to X
fe94 a9 55       LDA #$55          ; set first test byte
fe96 91 c1       STA (STAL),Y      ; save to RAM
fe98 d1 c1       CMP (STAL),Y      ; compare with saved
fe9a d0 08       BNE Exit_No_RAM
fe9c 6a          ROR A             ; make byte $AA, carry is set here
fe9d 91 c1       STA (STAL),Y      ; save to RAM
fe9f d1 c1       CMP (STAL),Y      ; compare with saved
fea1 d0 01       BNE Exit_No_RAM 
fea3 a9          .byte   $A9       ; makes next line LDA #$18

fea4          Exit_No_RAM
fea4 18          CLC               ; flag test failed
fea5 8a          TXA               ; get original byte back
fea6 91 c1       STA (STAL),Y      ; restore original byte
fea8 60          RTS ;Size   24 [Test_RAM_byte]
              #endif

              ; *********
fea9            Entry_NMI
              ; *********

fea9 78          SEI               ; disable interrupts
feaa 6c 18 03    JMP (NMINV)       ; next statement by default

              ; ***********
fead            Default_NMI
              ; ***********

fead 48          PHA               ; save A
feae 8a          TXA               ; copy X
feaf 48          PHA               ; save X
feb0 98          TYA               ; copy Y
feb1 48          PHA               ; save Y
0001 FALSE    #if C64
SKIP             LDA #$7F
SKIP             STA CIA2_ICR
SKIP             LDY CIA2_ICR
SKIP             BMI RS232_NMI
              #endif
0000 TRUE     #if VIC
feb2 ad 1d 91    LDA VIA1_IFR      ; get interrupt flag register
feb5 10 48       BPL JMP_Exit_IRQ  ; if no interrupt restore registers and exit
feb7 2d 1e 91    AND RS2_IRQ_REG   ; AND with interrupt enable register
feba aa          TAX               ; copy to X
febb 29 02       AND #2            ; mask [RESTORE] key
febd f0 1f       BEQ RS232_NMI     ; if not [RESTORE] key continue with RS232
              #endif
febf 20 3f fd    JSR Scan_Autostart_Signature
fec2 d0 03       BNE NMI_10        ; branch if no autostart ROM
fec4 6c 02 a0    JMP (OPTION_ROM+2); else do autostart ROM break entry

fec7          NMI_10
0000 TRUE     #if VIC
fec7 2c 11 91    BIT VIA1_DATA     ; test VIA 1 DRA
              #endif
0001 FALSE    #if C64
SKIP             JSR Look_For_Special_Keys
              #endif
0000 TRUE     #if VIC
feca 20 34 f7    JSR Kernal_UDTIM  ; Update the system clock
              #endif
fecd 20 e1 ff    JSR STOP          ; Check if stop key is pressed
0001 FALSE    #if C64
SKIP             BNE RS232_NMI
              #endif
0000 TRUE     #if VIC
fed0 d0 2d       BNE JMP_Exit_IRQ  ; if not [STOP] exit interrupt
              #endif

              ; ***********
fed2            Default_BRK
              ; ***********

fed2 20 52 fd    JSR Kernal_RESTOR
fed5 20 f9 fd    JSR Initialise_IO
fed8 20 18 e5    JSR Initialise_Hardware
fedb 6c 02 c0    JMP (BASIC_BRK)

              ; *********
fede            RS232_NMI
              ; *********

0001 FALSE    #if C64
SKIP          Bfe72
SKIP             TYA
SKIP             AND ENABL
SKIP             TAX
SKIP             AND #1
SKIP             BEQ NMI_20
SKIP             LDA $DD00
SKIP             AND #$fb
SKIP             ORA NXTBIT
SKIP             STA $DD00
SKIP             LDA ENABL
SKIP             STA CIA2_ICR
SKIP             TXA
SKIP             AND #$12
SKIP             BEQ Mfe9d
SKIP             AND #2
SKIP             BEQ Bfe9a
SKIP             JSR RS232_In
SKIP             JMP Mfe9d
SKIP          Bfe9a
SKIP             JSR RS232_Out
              #endif
0000 TRUE     #if VIC
fede ad 1e 91    LDA RS2_IRQ_REG   ; interrupt enable register
fee1 09 80       ORA #$80          ; set enable bit
fee3 48          PHA               ; save to re-enable interrupts
fee4 a9 7f       LDA #$7F          ; disable all interrupts
fee6 8d 1e 91    STA RS2_IRQ_REG   ; interrupt enable register
fee9 8a          TXA               ; get active interrupts back
feea 29 40       AND #$40          ; mask T1 interrupt
feec f0 14       BEQ NMI_20        ; branch if not T1 interrupt
feee a9 ce       LDA #$CE          ; CB2 low, CB1 negative edge, CA2 high, CA1 negative edge
fef0 05 b5       ORA NXTBIT        ; OR RS232 next bit to send, sets CB2 high if set
fef2 8d 1c 91    STA VIA1_PCR      ; set VIA 1 PCR
fef5 ad 14 91    LDA RS2_TIM_LOW   ; get VIA 1 T1C_l
fef8 68          PLA               ; restore interrupt enable mask
fef9 8d 1e 91    STA RS2_IRQ_REG   ; interrupt enable register
              #endif
fefc          Mfe9d
fefc 20 a3 ef    JSR RS232_NMI_Transmit

feff          JMP_Exit_IRQ
0001 FALSE    #if C64
SKIP             JMP Bfeb6
              #endif
0000 TRUE     #if VIC
feff 4c 56 ff    JMP Exit_IRQ      ; restore registers and exit interrupt
              #endif

ff02          NMI_20
ff02 8a          TXA               ; get active interrupts back
0001 FALSE    #if C64
SKIP             AND #2
              #endif
0000 TRUE     #if VIC
ff03 29 20       AND #$20          ; mask T2 interrupt
              #endif
ff05 f0 25       BEQ NMI_30        ; branch if not T2 interrupt
0001 FALSE    #if C64
SKIP             JSR RS232_In
              #endif
0000 TRUE     #if VIC
ff07 ad 10 91    LDA RS2_DSR_CTS   ; get VIA 1 DRB
ff0a 29 01       AND #$01          ; mask RS232 data in
ff0c 85 a7       STA INBIT         ; save receiver input bit temp storage
ff0e ad 18 91    LDA VIA1_T2CL     ; get VIA 1 T2C_l
ff11 e9 16       SBC #$16          ;.
ff13 6d 99 02    ADC BAUDOF        ; add baud rate bit time low byte
ff16 8d 18 91    STA VIA1_T2CL     ; set VIA 1 T2C_l
ff19 ad 19 91    LDA VIA1_T2CH     ; get VIA 1 T2C_h
ff1c 6d 9a 02    ADC BAUDOF+1      ; add baud rate bit time high byte
ff1f 8d 19 91    STA VIA1_T2CH     ; set VIA 1 T2C_h
ff22 68          PLA               ; restore interrupt enable mask
ff23 8d 1e 91    STA RS2_IRQ_REG   ; set VIA 1 IER, restore interrupts
ff26 20 36 f0    JSR RS232_NMI_Receive
              #endif
0001 FALSE    #if C64
SKIP             JMP Bfeb6
              #endif
0000 TRUE     #if VIC
ff29 4c 56 ff    JMP Exit_IRQ      ; restore registers and exit interrupt
              #endif

ff2c          NMI_30
ff2c 8a          TXA               ; get active interrupts back
ff2d 29 10       AND #$10          ; mask CB1 interrupt, Rx data bit transition
ff2f f0 25       BEQ Bfeb6         ; if no bit restore registers and exit interrupt
0001 FALSE    #if C64
SKIP             JSR RS232_Out
              #endif
0000 TRUE     #if VIC
ff31 ad 93 02    LDA M51CTR        ; get pseudo 6551 control register
ff34 29 0f       AND #$0F          ; clear non baud bits
ff36 d0 00       BNE NMI_40        ; quirk

ff38          NMI_40
ff38 0a          ASL A             ; 2 bytes per baud index
ff39 aa          TAX               ; copy to index
ff3a bd 5a ff    LDA Baudrate-2,X  ; get baud count low byte
ff3d 8d 18 91    STA VIA1_T2CL     ; set VIA 1 T2C_l
ff40 bd 5b ff    LDA Baudrate-1,X  ; get baud count high byte
ff43 8d 19 91    STA VIA1_T2CH     ; set VIA 1 T2C_h
ff46 ad 10 91    LDA RS2_DSR_CTS   ; read VIA 1 DRB, clear interrupt flag
ff49 68          PLA               ; restore interrupt enable mask
ff4a 09 20       ORA #$20          ; enable T2 interrupt
ff4c 29 ef       AND #$EF          ; disable CB1 interrupt
ff4e 8d 1e 91    STA RS2_IRQ_REG   ; set VIA 1 IER
ff51 ae 98 02    LDX BITNUM        ; get number of bits to be sent/received
ff54 86 a8       STX BITCI         ; save receiver bit count in
              #endif

ff56          Bfeb6

0001 FALSE    #if C64
SKIP             LDA ENABL
SKIP             STA CIA2_ICR
              #endif

              ; ********
ff56            Exit_IRQ
              ; ********

ff56 68          PLA               ; pull Y
ff57 a8          TAY               ; restore Y
ff58 68          PLA               ; pull X
ff59 aa          TAX               ; restore X
ff5a 68          PLA               ; restore A
ff5b 40          RTI

              ; ********
ff5c            Baudrate  
              ; ********

0001 FALSE    #if C64
SKIP          ; --------------------------------
SKIP             .word   $27c1     ;   50   baud
SKIP             .word   $1a3e     ;   75   baud
SKIP             .word   $11c5     ;  110   baud
SKIP             .word   $0e74     ;  134.5 baud
SKIP             .word   $0ced     ;  150   baud
SKIP             .word   $0645     ;  300   baud
SKIP             .word   $02f0     ;  600   baud
SKIP             .word   $0146     ; 1200   baud
SKIP             .word   $00b8     ; 1800   baud
SKIP             .word   $0071     ; 2400   baud
              #endif
0000 TRUE     #if VIC
0001 FALSE    #if PAL
SKIP          ; PAL Value = 1108404 Hz / baudrate
SKIP          ; --------------------------------
SKIP             .word   $2AE6     ;   50   baud
SKIP             .word   $1C78     ;   75   baud
SKIP             .word   $1349     ;  110   baud
SKIP             .word   $0FB1     ;  134.5 baud
SKIP             .word   $0E0A     ;  150   baud
SKIP             .word   $06D3     ;  300   baud
SKIP             .word   $0338     ;  600   baud
SKIP             .word   $016A     ; 1200   baud
SKIP             .word   $00D0     ; 1800   baud
SKIP             .word   $0083     ; 2400   baud
SKIP             .word   $0036     ; 3600   baud
              #else
              ; NTSC Value = 1022727 Hz / baudrate
              ; --------------------------------
ff5c 92 27       .word   $2792     ;   50   baud
ff5e 40 1a       .word   $1A40     ;   75   baud
ff60 c6 11       .word   $11C6     ;  110   baud
ff62 74 0e       .word   $0E74     ;  134.5 baud
ff64 ee 0c       .word   $0CEE     ;  150   baud
ff66 45 06       .word   $0645     ;  300   baud
ff68 f1 02       .word   $02F1     ;  600   baud
ff6a 46 01       .word   $0146     ; 1200   baud
ff6c b8 00       .word   $00B8     ; 1800   baud
ff6e 71 00       .word   $0071     ; 2400   baud
ff70 2a 00       .word   $002A     ; 3600   baud
              #endif
              #endif

0001 FALSE    #if C64
SKIP          ; ********
SKIP            RS232_In
SKIP          ; ********
SKIP          
SKIP             LDA CIA2_PRB
SKIP             AND #1
SKIP             STA INBIT
SKIP             LDA CIA2_TBLO
SKIP             SBC #$1c
SKIP             ADC BAUDOF
SKIP             STA CIA2_TBLO
SKIP             LDA CIA2_TBHI
SKIP             ADC BAUDOF+1
SKIP             STA CIA2_TBHI
SKIP             LDA #$11
SKIP             STA CIA2_CRB
SKIP             LDA ENABL
SKIP             STA CIA2_ICR
SKIP             LDA #$ff
SKIP             STA CIA2_TBLO
SKIP             STA CIA2_TBHI
SKIP             JMP RS232_NMI_Receive
SKIP          
SKIP          ; *********
SKIP            RS232_Out
SKIP          ; *********
SKIP          
SKIP             LDA M51AJB
SKIP             STA CIA2_TBLO
SKIP             LDA M51AJB+1
SKIP             STA CIA2_TBHI
SKIP             LDA #$11
SKIP             STA CIA2_CRB
SKIP             LDA #$12
SKIP             EOR ENABL
SKIP             STA ENABL
SKIP             LDA #$ff
SKIP             STA CIA2_TBLO
SKIP             STA CIA2_TBHI
SKIP             LDX BITNUM
SKIP             STX BITCI
SKIP             RTS
SKIP          
SKIP          ; *************
SKIP            Set_Baud_Rate
SKIP          ; *************
SKIP          
SKIP             TAX
SKIP             LDA M51AJB+1
SKIP             ROL A
SKIP             TAY
SKIP             TXA
SKIP             ADC #$c8
SKIP             STA BAUDOF
SKIP             TYA
SKIP             ADC #0
SKIP             STA BAUDOF+1
SKIP             RTS
SKIP          
SKIP             .BYTE $ea,$ea     ; 2 NOP's
SKIP          
SKIP          ; ****************
SKIP            Clear_BREAK_Flag
SKIP          ; ****************
SKIP          
SKIP             PHP
SKIP             PLA
SKIP             AND #$ef
SKIP             PHA
SKIP          
              #endif
              ; *********
ff72            Entry_IRQ
              ; *********

ff72 48          PHA               ; save A
ff73 8a          TXA               ; copy X
ff74 48          PHA               ; save X
ff75 98          TYA               ; copy Y
ff76 48          PHA               ; save Y
ff77 ba          TSX               ; copy stack pointer
ff78 bd 04 01    LDA STACK+4,X     ; get the stacked status register
ff7b 29 10       AND #$10          ; mask the BRK flag bit
ff7d f0 03       BEQ BFF82         ; if not BRK go do the hardware IRQ vector
ff7f 6c 16 03    JMP (CBINV)       ; else do the BRK vector
ff82          BFF82
ff82 6c 14 03    JMP (CINV)        ; do IRQ vector

0001 FALSE    #if C64
SKIP          ; ***********
SKIP            Init_Editor
SKIP          ; ***********
SKIP          
SKIP             JSR Initialise_Hardware
SKIP          
SKIP          InEd_10
SKIP             LDA $D012
SKIP             BNE InEd_10
SKIP             LDA $D019
SKIP             AND #1
SKIP             STA TVSFLG
SKIP             JMP Program_Timer_A
SKIP          
SKIP          ; ======
SKIP            PTA_10             ; continue Program_Timer_A
SKIP          ; ======
SKIP          
SKIP             LDA #$81          ; Enable timer A interrupt
SKIP             STA CIA1_ICR      ; Interrupt Control Register
SKIP             LDA CIA1_CRA      ; Read Conrol Register A
SKIP             AND #$80          ; Clear all values except frequency (50/60 Hz)
SKIP             ORA #$11          ; Start time A in single shot mode
SKIP             STA CIA1_CRA      ; run timer A
SKIP             JMP SET_IEC_CLK
SKIP          
SKIP          ; **************
SKIP            Kernal_Version
SKIP          ; **************
SKIP          
SKIP             .BYTE $03
SKIP          
SKIP              JMP Init_Editor
SKIP              JMP Initialise_IO
SKIP              JMP Init_RAM
SKIP          
              #endif

0000 TRUE     #if VIC
ff85 ff ff ff    .fill 5 (-1)      ; unused ; 5 bytes
              #endif

              ; ******
ff8a            RESTOR             ; Restore default system and interrupt vectors
              ; ******

              ; Call address: $FF8A
              ; Preparatory routines: None
              ; Error returns: None
              ; Stack requirements: 2
              ; Registers affected: A, X, Y

              ; This routine restores the default values of all system vectors used in
              ; KERNAL and BASIC routines and interrupts. (See appendix D for the
              ; default vector contents). The KERNAL VECTOR routine is used to read
              ; and alter individual system vectors.

              ; 1) Call this routine.

              ; JSR RESTOR

ff8a 4c 52 fd    JMP Kernal_RESTOR

              ; ******
ff8d            VECTOR             ; Manage RAM vectors
              ; ******

              ; Call address: $FF8D
              ; Communication registers: X, Y
              ; Preparatory routines: None
              ; Error returns: None
              ; Stack requirements: 2
              ; Registers affected: A, X, Y

              ; This routine manages all system vector jump addresses stored in RAM.
              ; Calling this routine with the accumulator carry ait set wili store the
              ; current contents of the RAM vectors in a list pointed to by the X and
              ; Y registers. When this routine is called with the carry clear, the
              ; user list pointed to by the X and Y registers is transferred to the
              ; system RAM vectors. NOTE: This routine requires caution in its use.
              ; The best way to use it is to first read the entire vector contents
              ; into the user area, alter the desired vectors, and then copy the
              ; contents back to the system vectors.

              ; READ THE SYSTEM RAM VECTORS
              ; 1) Set the carry.
              ; 2) Set the X and Y registers to the address to put the vectors.
              ; 3) Call this routine.

              ; LOAD THE SYSTEM RAM VECTORS
              ; 1) Clear the carry bit.
              ; 2) Set the X and Y registers to the address of the vector list in RAM
              ;    that must be loaded
              ; 3) Call this routine.

              ; CHANGE THE INPUT ROUTINES TO NEW SYSTEM
              ; LDX #<USER
              ; LDY #>USER
              ; SEC
              ; JSR VECTOR   ;read old vectors
              ; LDA #<MYINP  ;change input
              ; STA USER+10
              ; LDA #>MYINP
              ; STA USER+11
              ; LDX #<USER
              ; LDY #>USER
              ; CLC
              ; JSR VECTOR  ;alter system
              ; USER * = * + 26

ff8d 4c 57 fd    JMP Kernal_VECTOR

              ; ******
ff90            SETMSG             ; Control system message output
              ; ******

              ; Call address: $FF90
              ; Communication registers: A
              ; Preparatory routines: None
              ; Error returns: None
              ; Stack requirements: 2
              ; Registers affected: A

              ; This routine controls the printing of error and control messages by
              ; the KERNAL. Either print error messages or print control messages can
              ; be selected by setting the accumulator when the routine is called.
              ; FILE NOT FOUND is an example of an error message. PRESS PLAY ON
              ; CASSETTE is an example of a control message. Bits 6 and 7 of this
              ; value determine where the message will come from, ft bit 7 is 1, one
              ; of the error messages from the KERNAL will be printed. If bit 6 is
              ; set, a control message wifl be printed.

              ; 1) Set accumulator to desired value.
              ; 2) Call this routine.

              ; LDA #S40
              ; JSR SETMSG       ; TURN ON CONTROL MESSAGES
              ; LDA #SB0
              ; JSR SETMSG       ; TURN ON ERROR MESSAGES
              ; LDA #0
              ; JSR SETMSG       ; TURN OFF ALL KERNAL MESSAGES

ff90 4c 66 fe    JMP Kernal_SETMSG

              ; ******
ff93            SECOND             ; Send secondary address for LISTEN
              ; ******

              ; Call address: $FF93
              ; Communication registers: A
              ; Preparatory routines: LISTEN
              ; Error returns: See READST
              ; Stack requirements: one
              ; Registers affected: .A

              ; This routine is used to send a secondary address to an I/O device
              ; after a call to the LISTEN routine is made, and the device commanded
              ; to LISTEN. The routine cannot be used to send a secondary address
              ; after a call to the TALK routine. A secondary address is usually used
              ; to give set-up information to a device before I;O operations begin.
              ; When a secondary address is to be sent to a device on the serial bus,
              ; the address must first be ORed with $60.

              ; 1) Load the accumulator with the secondary address to be sent.
              ; 2) Call this routine.

              ; ADDRESS DEVICE #8 WITH COMMAND (SECONDARY ADDRESS) #15
              ; LDA #8
              ; JSR LISTEN
              ; LDA #15
              ; ORA #60
              ; JSR SECOND

ff93 4c c0 ee    JMP Kernal_SECOND

              ; ****
ff96            TKSA  ; Send a secondary address to a device commanded to TALK
              ; ****

              ; Call address: $FF96
              ; Communication registers: A
              ; Preparatory routines: TALK
              ; Error returns: See READST
              ; Slack requirements: None
              ; Registers affected: A

              ; This routine transmits a secondary address on the serial bus for a
              ; TALK device. This routine must be called with a number between 4 and
              ; 31 in the accumulator. The routine will send this number as a
              ; secondary address command over the serial bus. This routine can only
              ; be called after a call to the TALK routine, it will not work after a
              ; LISTEN.

              ; 0) Use the TALK routine.
              ; 1) Load the accumulator with the secondary address.
              ; 2) Call this routine.

              ; ;TELL DEVICE #4 TO TALK WITH COMMAND #7
              ; LDA #4
              ; JSR TALK
              ; LDA #7
              ; JSR TKSA

ff96 4c ce ee    JMP Kernal_TKSA

              ; ******
ff99            MEMTOP             ; Read or set the top of RAM
              ; ******

              ; Call address: $FF99
              ; Communication registers: X, Y
              ; Preparatory routines: None
              ; Error returns: None
              ; Stack requirements: 2
              ; Registers affected: X, Y

              ; This routine is used to set the top of RAM. When this routine is
              ; called with the carry bit of the accumulator set, the pointer to the
              ; top of RAM will be loaded into the .X and. Y registers. When this
              ; routine is called with the accumulator carry bit clear, the contents
              ; of the X and Y registers will be loaded in the top of memory pointer,
              ; changing the top of memory.

              ; DEALLOCATE THE RS-232 BUFFER
              ; SEC
              ; JSR MEMTOP ;READ TOP OF MEMORY
              ; DEX
              ; CLC
              ; JSR MEMTOP ;SET NEW TOP OF MEMORY

ff99 4c 73 fe    JMP Kernal_MEMTOP

              ; ******
ff9c            MEMBOT             ; Read or set bottom of memory
              ; ******

              ; Call address: $FF9C
              ; Communication registers: X, Y
              ; Preparatory routines: None
              ; Error returns: None
              ; Stack requirements: None
              ; Registers affected: X, Y

              ; This routine is used to set the bottom of the memory. If the
              ; accumulator carry bit is set when this routine is called, a pointer to
              ; the lowest byte of RAM will be returned in the X and Y registers. On
              ; the unexpancted VIC the initial value of this pointer is $1000. If the
              ; accumulator carry bit is clear (0) when this routine is called, the
              ; values of the X and Y registers will be transferred to the low and
              ; high bytes respectively of the pointer to the beginning of RAM.

              ; TO READ THE BOTTOM OF RAM
              ; 1) Set the carry.
              ; 2) Call this routine.

              ; TO SET THE BOTTOM OF MEMORY
              ; 1) Clear the carry.
              ; 2) Call this routine.

              ; MOVE BOTTOM OF MEMORY UP 1 PAGE
              ; SEC      ;READ MEMORY BOTTOM
              ; JSR MEMBOT
              ; INY
              ; CLC      ;SET MEMORY BOTTOM TO NEW VALUE
              ; JSR MEMBOT

ff9c 4c 82 fe    JMP Kernal_MEMBOT

              ; ******
ff9f            SCNKEY             ; Scan the keyboard
              ; ******

              ; Call address: $FF9F
              ; Com muni cation registers: None
              ; Preparatory routines: None
              ; Error returns: None
              ; Stack requirements: None
              ; Registers affected: A, X, Y

              ; This routine will scan the VIC keyboard and check for pressed keys. It
              ; is the same routine called by the interrupt handler. If a key is down,
              ; its ASCII value is placed in the keyboard queue.

              ; 1) Call this routine

              ; GET JSR SCNKEY ;SCAN KEYBOARD
              ;     JSR GETIN  ;GET CHARACTER
              ;     CMP #0     ;IS IT NULL?
              ;     BEQ GET    ;YES, SCAN AGAIN
              ;     JSR CHROUT ;PRINT IT

ff9f 4c 1e eb    JMP Kernal_SCNKEY

              ; ******
ffa2            SETTMO             ; Set serial bus timeout flag
              ; ******

              ; Call address: $FFA2
              ; Communication registers: A
              ; Preparatory routines: None
              ; Error returns: None
              ; Stack requirements: 2
              ; Registers affected: None

              ; This routine sets the timeout flag for the serial bus. When the
              ; timeout flag is set, the VIC will wait for a device on the serial port
              ; for 64 milliseconds. If the device does not respond to the VIC's DAV
              ; signal within that time the VIC will recognize an error condition and
              ; leave the handshake sequence. When this routine is called when the
              ; accumulator contains a 0 in bit 7, timeouts are enabled, A 1 in bit 7
              ; will disable the timeouts. NOTE: The VIC uses the timeout feature to
              ; communicate that adisk file is not found on an attempt to OPEN a file.

              ; TO SET THE TIMEOUT FLAG
              ; 1) Set bit 7 of the accumulator to 0,
              ; 2) Call this routine.

              ; TO RESET THE TIMEOUT FLAG
              ; 1) Set bit 7 of the accumulator to 1.
              ; 2) Call this routine,

              ; DISABLE TIMEOUT
              ; LDA #0
              ; JSR SETTMO

ffa2 4c 6f fe    JMP Kernal_SETTMO

              ; *****
ffa5            ACPTR              ; Get data from the serial bus
              ; *****

              ; Call address: $FFA5
              ; Communicaiion registers: A
              ; Preparatory routines: TALK, TKSA
              ; Error returns: See READST
              ; Stack requirements: 13
              ; Registers affected: A X

              ; This is the routine to use to get information from a device on the
              ; serial bus (like the disk). This routine gets a byte of data off the
              ; serial bus using full handshaking. The data is returned in the
              ; accumulator. To prepare for this routine the TALK routine must have
              ; been called first to command the device on the serial bus to send data
              ; on the bus. If the input device needs a secondary command, it must be
              ; sent by using the TKSA KERNAL routine before calling this routine.
              ; Errors are returned in the status word. The READST routine is used to
              ; read the status word.

              ; 0) Command a device on the serial bus to prepare to send data to the
              ;    VIC. (Use the TALK and TKSA kernal routines).
              ; 1) Call this routine (using JSR)
              ; 2) Store or otherwise use the data.

              ; Get a byte from the bus
              ; JSR ACPTR
              ; STA DATA

0001 FALSE    #if JIFFY
SKIP             JMP Jiffy_ACPTR
              #else
ffa5 4c 19 ef    JMP Kernal_ACPTR
              #endif

              ; *****
ffa8            CIOUT              ; Transmit a byte over the serial bus
              ; *****

              ; Call address: $FFA8
              ; Communication registers: A
              ; Preparatory routines: LISTEN, [SECOND]
              ; Error returns: See READST
              ; Stack requirements: None
              ; Registers affected: A

              ; This routine is used to send information to devices on the serial bus.
              ; A call to this routine wilt put a data byte onto the serial bus using
              ; full serial handshaking. Before this routine is called, the LISTEN
              ; KERNAL routine must be used to command a device on the serial bus to
              ; get ready to receive data. (If a device needs a secondary address, it
              ; must also be sent by using the SECOND KERNAL routine.) The accumulator
              ; is loaded with a byte to handshake as data on the serial bus. A device
              ; must be listening or the status word will return a timeout. This
              ; routine always buffers one character. (The routine holds the previous
              ; character to be sent back,) So when a call to the KERNAL UNLSN routine
              ; is made to end the data transmission, the buffered character is sent
              ; with EOl set. Then the UNLSN command is sent to the device.

              ; 0) Use the LISTEN KERNAL routine (and the SECOND routine if needed).
              ; 1) Load the accumulator with a byte of data.
              ; 2) Call this routine to send the data byte.

              ; Send an X to the serial bus
              ; LDA #'X'
              ; JSR CIOUT

ffa8 4c e4 ee    JMP Kernal_CIOUT

              ; *****
ffab            UNTLK              ; Send an UNTALK command
              ; *****

              ; Call address; $FFAB
              ; Communication registers: None
              ; Preparatory routines: None
              ; Error returns: See READST
              ; Stack requirements: None
              ; Registers affected: A

              ; This routine will transmit an UNTALK command on the serial bus. All
              ; devices previously set to TALK will stop sending data when this
              ; command is received.

              ; 1) Call this routine.

              ; JSR UNTALK

ffab 4c f6 ee    JMP Kernal_UNTLK

              ; *****
ffae            UNLSN              ; Send an UNLISTEN command
              ; *****

              ; Call address: $FFAE
              ; Communication registers: None
              ; Preparatory routines: None
              ; Error returns: See READST
              ; Stack requirements: None
              ; Registers affected: A

              ; This routine commands all devices on the serial bus to stop receiving
              ; data from the VIC. (i.e., UNLISTEN}. Calling this routine results in
              ; an UNLISTEN command being transmitted on the serial bus. Only devices
              ; previously commanded to listen wilt be affected. This routine is
              ; normally used after the VIC is finished sending data to external
              ; devices. Sending the UNLISTEN will command the listening devices to
              ; get off the serial bus so it can be used for other purposes.

              ; 1) Call this routine.

              ; JSR UNLSN

ffae 4c 04 ef    JMP Kernal_UNLSN

              ; ******
ffb1            LISTEN             ; Command a device to LISTEN
              ; ******

              ; Call Address: $FFB1
              ; Communication registers: A
              ; Preparatory routines: None
              ; Error returns: See READST
              ; Stack requirements: None
              ; Registers affected: A

              ; This routine will command a device on the serial bus to receive data.
              ; The accumulator must be loaded with a device number between 4 and 31
              ; before calling the routine. LISTEN will OR the number bit by bit to
              ; convert to a listen address, then transmit this data as a command on
              ; the serial bus. The specified device will then go into listen mode,
              ; and be ready to accept information.

              ; 1) Load the accumulator with the number of the device to command to
              ;    LISTEN.
              ; 2) Call this routine using the JSR instruction.

              ; COMMAND DEVICE #8 TO LISTEN
              ; LDA #8
              ; JSR LISTEN

ffb1 4c 17 ee    JMP Kernal_LISTEN

              ; ****
ffb4            TALK               ; Command a device on the serial bus to TALK
              ; ****

              ; Call address: $FFB4
              ; Communication registers: A
              ; Preparatory routines: None
              ; Error returns: See READST
              ; Stack requirements: None
              ; Registers affected: A

              ; To use this routine the accumulator must first be loaded with a device
              ; number between 4 and 30. When called, this routine then ORs bit by
              ; bits to convert this device number to a talk address. Then this data
              ; is transmitted as a command on the Serial bus.

              ; 1) Load the accumulator with the device number.
              ; 2) Call this routine.

              ; COMMAND DEVICE #4 TO TALK
              ; LDA #4
              ; JSR TALK

ffb4 4c 14 ee    JMP Kernal_TALK

              ; ******
ffb7            READST             ; Read status word
              ; ******

              ; Call address: $FFB7
              ; Communication registers: A
              ; Preparatory routines: None
              ; Error returns: None
              ; Stack requirements: 2
              ; Registers affected: A

              ; This routine returns the current status of the I/O devices in the
              ; accumulator. The routine is usually called after new communication to
              ; an I/O device. The routine will give information about device status,
              ; or errors that have occurred during the I/O operation. The bits
              ; returned in the accumulator contain the following information
              ; (see table befow):

              ; How to use:
              ; 1) Call this routine.
              ; 2) Decode the information in the .A register as it refers to your
              ;    program.

              ; CHECK FOR END OF FILE DURING READ
              ; JSR READST
              ; AND #64 ;check eof bit
              ; BNE EOF ;branch on eof

              ; Bit Val Comment
              ; 0    1  timeout writing to   IEC bus
              ; 1    2  timeout reading from IEC bus
              ; 2    4  short block    during tape I/O
              ; 3    8  long  block    during tape I/O
              ; 4   16  read error     during tape I/O
              ; 5   32  checksum error during tape I/O
              ; 6   64  EOF (End-Of-File) on IEC bus
              ; 7 -128  device not present

ffb7 4c 57 fe    JMP Kernal_READST

              ; ******
ffba            SETLFS             ; Set up a logical file
              ; ******

              ; Call address: $FFBA
              ; Communication registers: A, X, Y
              ; Preparatory routines: None
              ; Error returns: None
              ; Stack requirements: 2
              ; Registers affected: None

              ; This routine will set the logica! file number, device address, and
              ; secondary address (command number) for other KERNAL routines. The
              ; logical fife number is used by the system as a key to the file table
              ; created by the OPEN file routine. Device addresses can range from 0 to
              ; 30. The following codes are used for the following CBM devices.

              ; Addr. DEVICE
              ; ------------
              ;    0  Keyboard
              ;    1  Cassette #1
              ;    2  RS-232C device
              ;    3  CRT display
              ;  4-5  Serial Bus printer
              ;  6-7  Serial Bus plotter
              ;  8-x  Serial bus disk drive

              ; Device numbers 4 or greater automatically refer to devices on the
              ; serial bus. A command to the device is sent as a secondary address on
              ; the serial bus after the device number is sent during the serial
              ; attention handshaking sequence. It no secondary address is to be sent
              ; the Y index register should be set to 255.

              ; 1) Load the accumulator with the logical file number.
              ; 2) Load the X index register with the device number.
              ; 3) Load the Y index register with the command.

              ; For logical file 32, device #4, and no command:
              ; LDA #32
              ; LDX #4
              ; LDY #255
              ; JSR SETLFS

ffba 4c 50 fe    JMP Kernal_SETLFS

              ; ******
ffbd            SETNAM             ; Set up file name
              ; ******

              ; Call address: $FFBD
              ; Communication registers: A, X, Y
              ; Preparatory routines: None
              ; Stack requirements: None
              ; Registers affected: None

              ; This routine is used to set up the file name for the OPEN, SAVE, or
              ; LOAD routines. The accumulator must be loaded with the length of the
              ; file name. The X and Y registers must be loaded with the address of
              ; the file name, in standard 6502 low byte, high byte format.
              ; The address can be any valid memory address in the system where a
              ; string of characters for the file name is stored. If no file name is
              ; desired, the accumulator must be set to 0, representing a zero file
              ; length. The X and Y registers may be set to any memory address in that
              ; case.

              ; 1) Load the accumulator with the length of the file name.
              ; 2) Load the X index register with the low order address of the file
              ;     name.
              ; 3) Load the Y index register with the high order address.
              ; 4) Call this routine.

              ; LDA #NAME2-NAME ;LOAD LENGTH OF FILE NAME
              ; LDX #<NAME
              ; LDY #>NAME
              ; JSR SETNAM

ffbd 4c 49 fe    JMP Kernal_SETNAM

              ; ****
ffc0            OPEN               ; Open a logical file
              ; ****

              ; Call address: $FFC0
              ; Communication registers: None
              ; Preparatory routines: SETLFS, SETNAM
              ; Error returns: 1,2,4,5,6
              ; Stack requirements: None
              ; Registers affected: A, X, Y

              ; This routine is used to open a logical file. Once the logical file is
              ; set up, it can be used for input/output operations. Most of the I/O
              ; KERNAL routines call on this routine to create the logical files to
              ; operate on. No arguments need to be set up to use this routine, but
              ; both the SETLFS and SETNAM KERNAL routines must be called before using
              ; this routine.

              ; 0) Use the SETLFS routine.
              ; 1) Use the SETNAM routine.
              ; 2) Call this routine.

              ; This is an implementation of the BASIC statement: OPEN 15,8,15,"I0"
              ; LDA #NAME2-NAME ;LENGTH OF FILE NAME FOR SETLFS
              ; LDY #>NAME
              ; JSR SETNAW
              ; LDA #15
              ; LDX #8
              ; LDY #15
              ; JSR SETLFS
              ; JSR OPEN
              ; NAME  .BYTE "I0"
              ; NAME2

ffc0 6c 1a 03    JMP (IOPEN)

              ; *****
ffc3            CLOSE              ; Close a logical file
              ; *****

              ; Call address: $FFC3
              ; Communication registers: A
              ; Preparatory routines: None
              ; Error returns: None
              ; Stack requirements: None
              ; Registers affected: A, X

              ; This routine is used to close a logical file after all I/O operations
              ; have been completed on that file. This routine is called after the
              ; accumulator is loaded with the logical file number to be closed (the
              ; same number used when the file was opened using the OPEN routine).

              ; How to use:
              ; 1) Load the accumulator with the number of the logical file to be
              ;    closed.
              ; 2) Call this routine

              ; CLOSE 15
              ; LDA #15
              ; JSR CLOSE

ffc3 6c 1c 03    JMP (ICLOSE)

              ; *****
ffc6            CHKIN              ; Open a channel for input
              ; *****

              ; Call address: $FFC6
              ; Communication registers: X
              ; Preparatory routines: (OPEN)
              ; Error returns: 3,5,6
              ; Stack requirements: None
              ; Registers affected: A, X

              ; Any logical file that has already been opened by the KERNAL OPEN
              ; routine can be defined as an input channel by this routine. Naturally,
              ; the device on the channel must be an input device. Otherwise, an error
              ; will occur, and the routine will abort. If you are getting data from
              ; anywhere other than the keyboard, this routine must be called before
              ; using either the CHRIN or the GETIN KERNAL routines for data input. If
              ; input from the keyboard is desired, and no other input channels are
              ; opened, then the calls to this routine, and to the OPEN routine, are
              ; not needed. When this routine is used with a device on the serial bus,
              ; this routine automatically sends the talk address (and the secondary
              ; address if one was specified by the OPEN routine) over the bus.

              ; To use this routine:
              ; 0) OPEN the logical file (if necessary; see description above).
              ; 1) Load the .X register with number of the logical file to be used.
              ; 2) Call this routine (using a JSR command}.

              ; Possible errors are:
              ; #3: File not open
              ; #5: Device not present
              ; #6: File not an input file

              ; PREPARE FOR INPUT FROM LOGICAL FILE 2
              ; LDX #2
              ; JSR CHKIN

ffc6 6c 1e 03    JMP (ICHKIN)

              ; ******
ffc9            CHKOUT             ; Open a channel for output
              ; ******

              ; Call address: $FFC9
              ; Communication registers: X
              ; Preparatory routines: (OPEN)
              ; Error returns: 3,5,7
              ; Stack requirements: None
              ; Registers Affected: A, X

              ; Any logical file number which has been created by the KERNAL routine
              ; OPEN can be defined as an output channel. Of course, the device you
              ; intend opening a channel to must be an output device. Otherwise, an
              ; error will occur, and the routine will be aborted. This routine must
              ; be called before any data is sent to any output device unless you want
              ; to use the VIC screen as your output device, If screen output is
              ; desired, and there are no other output channels already defined, then
              ; the calls to this routine, and to the OPEN routine are not needed.
              ; When used to open a channel to a device on the serial bus, this
              ; routine will automatically send the LISTEN address specified by the
              ; OPEN routine (and a secondary address if there was one).

              ; How to use: (This routine is NOT NEEDED to send data to the screen)
              ; 0) Use the KERNAL OPEN routine to specify a logical file number, a
              ;    LISTEN address, and a secondary address (if needed).
              ; 1) Load the X register with the logical file number used in the open
              ;    statement,
              ; 2) Call this routine (by using the JSR instruction).

              ; Possible error returns:
              ; 3: File not open
              ; 5: Device not present
              ; 7: Not an output file

ffc9 6c 20 03    JMP (ICKOUT)      ; do open for output vector

              ; ******
ffcc            CLRCHN             ; Clear I/O channels
              ; ******

              ; Call address: $FFCC
              ; Communication registers: None
              ; Preparatory routines: None
              ; Error routines: None
              ; Stack requirements: 9
              ; Registers affected: A, X

              ; This routine is called to clear all open channels and restore the I/O
              ; channels to their original default values. It is usually called after
              ; opening other I/O channels (like to the disk or tape drive) and using
              ; them for input-output operations. The default input device is 0
              ; (keyboard). The default output device is 3 (the VIC screen). If one of
              ; the channels to be closed is to the serial port, an UNTALK signal is
              ; sent first to clear the input channel or an UNLISTEN is sent to clear
              ; the output channel. By not calling this routine (and leaving
              ; listeners active on the serial bus) several devices can receive the
              ; same data from the VIC at the same time. One way to take advantage of
              ; this would be to command the printer to LISTEN and the disk to TALK.
              ; This would allow direct printing of a disk file.

              ; JSR CLRCHN

ffcc 6c 22 03    JMP (ICLRCH)

              ; *****
ffcf            CHRIN              ; Get a character from the input channel
              ; *****

              ; Call address: $FFCF
              ; Communication registers: A
              ; Preparatory routines: (OPEN, CHKIN)
              ; Error returns: See READST
              ; Stack requirements: None
              ; Registers affected: A, X

              ; This routine wtll get a byte of data from the channel already set up
              ; as the input channel by the KERNAL routine CHKIN. If the CHKIN has
              ; not been used to define another input channel, data is expected from
              ; the keyboard. The data byte is returned in the accumulator. The
              ; channel remains open after the call. Input from the keyboard is
              ; handled in a special way. First, the cursor is turned on, and will
              ; blink until a carriage return is typed on the keyboard. All characters
              ; on the line (up to 88 characters) will be stored in the BASIC input
              ; buffer. Then the characters can be retrieved one at a time by calling
              ; this routine once for each character. When the carriage return is
              ; retrieved, the entire line has been processed. The next time this
              ; routine is called, the whole process begins again, i.e., by flashing
              ; the cursor.

              ; FROM THE KEYBOARD
              ; 1) Call this routine (using the JSR instruction).
              ; 2) Retrieve a byte of data by calling this routine,
              ; 3) Store the data byte.
              ; 4) Check if it is the last data byte (a CR ?). If not, goto step 2.

              ; RD          ; label
              ; LDX #0        ; store 0 in the X register
              ; JSR CHRIN
              ; STA DATA,X    ; store data byte in the Xth location in the data area.
              ; CMP #CR       ; is it a carriage return?
              ; BNE RD        ; no, get another data byte

              ; FROM KEYBOARD
              ; JSR CHRIN
              ; STA DATA

              ; FROM OTHER DEVICES
              ; 0) Use the KERNAL OPEN and CHKIN routines,
              ; 1) Call this routine (using a JSR instruction)-
              ; 2) Store the data.

              ; JSR CHRIN
              ; STA DATA

ffcf 6c 24 03    JMP (IBASIN)

              ; ******
ffd2            CHROUT             ; Output a character
              ; ******

              ; Call address: $FFD2
              ; Communication registers: A
              ; Preparatory routines: (CHKOUT, OPEN)
              ; Error returns: See READST
              ; Stack requirements: None
              ; Registers affected: None

              ; This routine will output a character to an already opened channel. Use
              ; the KERNAL OPEN and CHKOUT routines to set up the output channel
              ; before calling this routine. If this call is omitted, data will be
              ; sent to the default output device (number 3, on the screen). The data
              ; byte to be output is loaded into the accumulator, and this routine is
              ; called. The data is then sent to the specified output device. The
              ; channel is left open after the call.
              ; NOTE: Care must be taken when using this routine to send data to a
              ; serial device since data will be sent to all open output channels on
              ; the bus. Unless this Is desired, all open output channels on the
              ; serial bus other than the actually intended destination channel must
              ; be closed by a call to the KERNAL close channel routine.

              ; How to use:
              ; 0) Use the CHKOUT KERNAL routine if needed (see description above).
              ; 1) Load the data to be output into the accumulator.
              ; 2) Call this routine.

              ; Duplicale the BASIC instruction CMD 4,"A";
              ; LDX #4     ;LOGICAL FILE #4
              ; JSR CHKOUT ;OPEN CHANNEL OUT
              ; LDA #'A'
              ; JSR CHROUT ;SEND CHARACTER

ffd2 6c 26 03    JMP (IBSOUT)

              ; ****
ffd5            LOAD               ; Load RAM from device
              ; ****

              ; Call address: $FFD5
              ; Communication registers: A, X, Y
              ; Preparatory routines: SETLFS, SETNAM
              ; Error returns: 0,4,5,8,9
              ; Stack requirements: None
              ; Registers affected: A, X, Y

              ; This routine will load data bytes from any input device directly into
              ; the memory of the VIC. It can also be used for a verily operation,
              ; comparing data from a device with the data already in memory, leaving
              ; the data stored in RAM unchanged. The accumulator (A) must be set to 0
              ; for a load operation, or 1 for a verify. If the input device was
              ; OPENed with a secondary address (SA) of 0 the header information from
              ; device will be ignored. In this case, the X and Y registers must
              ; contain the starting address for the load. If the device was addressed
              ; with a secondary address of 0, 1, or 2 the data will load into memory
              ; starting at the location specified by the header, This routine returns
              ; the address of the highest RAM location which was loaded. Before this
              ; routine can be called, the KERNAL SETLFS, and SETNAM routines must be
              ; called.

              ; How to use
              ; 0) Call the SETLFS, and SETNAM routines. If a relocated load is
              ;    desired, use the SETLFS routine to send a secondary address of 3.
              ; 1) Set the A register to 0 for load, 1 for verify.
              ; 2) If a relocated load is desired, the X and Y registers must be set
              ;    to the start address for the load.
              ; 3) Call the routine using the JSR instruction.

ffd5 4c 42 f5    JMP Kernal_LOAD

              ; ****
ffd8            SAVE               ; Save memory to a device
              ; ****

              ; Call address: $FFD8
              ; Communication registers: A, X, Y
              ; Preparatory routines: SETLFS, SETNAM
              ; Error returns: 5,8,9
              ; Stack requirements: None
              ; Registers affected: A, X, Y

              ; This routine saves a section of memory. Memory is saved from an
              ; indirect address on page 0 specified by the accumulator to the address
              ; stored in the X and Y registers to a logical file (an input/output
              ; device). The SETLFS and SETNAM routines must be used before calling
              ; this routine. However, a file name is not required to SAVE to device 1
              ; (the cassette tape recorder). Any attempt to save to other devices
              ; without using a file name results in an error.
              ; NOTE: Device 0 (the keyboard) and device 3 (the screen) cannot be
              ; SAVEd to. If the attempt is made, an error will occur, and the SAVE
              ; stopped.

              ; How to use;
              ; 0) Use the SETLFS routine and the SETNAM routine (unless a SAVE with
              ;    no file name is desired on a save Jo the tape recorder).
              ; 1) Load two consecutive locations on page 0 with a pointer to the
              ;    start ol your save (in standard 6502 low byte first, high byte next
              ;    format).
              ; 2) Load the accumulator with the single byte page zero offset to the
              ;    pointer.
              ; 3) Load the X and Y registers with the low byte and high byte
              ;    respectively of the location of the end of the save.
              ; 4) Call this routine.

ffd8 4c 75 f6    JMP Kernal_SAVE

              ; ******
ffdb            SETTIM             ; Set the system clock
              ; ******

              ; Call address: $FFDB
              ; Communication registers: A, X, Y
              ; Preparatory routines: None
              ; Error returns: None
              ; Stack requirements: 2
              ; Registers affected: None

              ; A system clock is maintained by an interrupt routine that updates the
              ; clock every 1/60th of a second (one 'jiffy'). The clock is three bytes
              ; long, which gives it the capability to count up to 5,184,000 jiffies
              ; (24 hours). At that point the clock resets to zero. Before calling
              ; this routine to set the clock, the accumulator must contain the most
              ; significant byte, the X index registerthe next most significant byte,
              ; and the Y index register the least significant byte of the initial
              ; time setting (in jiffies).

              ; How to use:
              ; 1) Load the accumulator with the MSB of the 3 byte number.
              ; 2) Load the X register with the next byte.
              ; 3) Load the Y register with the LSB.
              ; 4) Call this routine.

ffdb 4c 67 f7    JMP Kernal_SETTIM

              ; *****
ffde            RDTIM              ; Read system clock
              ; *****

              ; Call address: $FFDE
              ; Communication registers: A, X, Y
              ; Preparatory routines: None
              ; Error returns: None
              ; Stack requirements: 2
              ; Registers affected: A, X, Y

              ; This routine is used to read the system clock. The clock's resolution
              ; is a 60th of a second. Three bytes are returned by the routine. The
              ; accumulator contains the most significant byte, the X index register
              ; contains the next most significant byter and the Y index register
              ; contains the least significant byte.

ffde 4c 60 f7    JMP Kernal_RDTIM

              ; ****
ffe1            STOP               ; Check if stop key is pressed
              ; ****

              ; Call address: $FFE1
              ; Communication registers: A
              ; Preparatory routines: None
              ; Error returns: None
              ; Stack requirements: None
              ; Registers affected: A, X

              ; If the STOP key on the keyboard is pressed when this routine is
              ; called, the Z flag will be set. All other flags remain unchanged. If
              ; the STOP key is not pressed then the accumulator will contain a byte
              ; representing the last row of the keyboard scan.
              ; The user can also check for certain other keys this way.

              ; How to use this routine:
              ; 1) Call this routine.
              ; 2) Test for the zero flag.

0001 FALSE    #if JIFFY & VIC
SKIP             JMP Jiffy_STOP
              #else
ffe1 6c 28 03    JMP (ISTOP)
              #endif

              ; *****
ffe4            GETIN              ; Get a character from the keyboard buffer
              ; *****

              ; Call address: $FFE4
              ; Communication registers: A
              ; Preparatory routines: None
              ; Error returns: None
              ; Stack requirements: None
              ; Registers affected: A, X

              ; This subroutine removes one character from the keyboard queue and
              ; returns it as an ASCII value in the accumulator. If the queue is
              ; empty, the value returned in the accumulator will be zero. Characters
              ; are put into the queue automatically by an interrupt driven keyboard
              ; scan routine which calls the SCNKEY routine. The keyboard buffer can
              ; hold up to ten characters. After the buffer is filled, additional
              ; characters are ignored until at least one character has been removed
              ; from the queue.

              ; How to use:
              ; 1) Call this routine using a JSR instruction
              ; 2) Check for a zero in the accumulator (empty buffer)
              ; 3) Process the data

ffe4 6c 2a 03    JMP (IGETIN)

              ; *****
ffe7            CLALL              ; Close all files
              ; *****

              ; Call address: SFFE7
              ; Communication registers: None
              ; Preparatory routines: None
              ; Error returns: None
              ; Stack requirements: 11
              ; Registers affected: A, X

              ; This routine closes all open files. When this routine is called, the
              ; pointers into the open file table are reset, closing all files. Also,
              ; the routine automatically resets the I/O channels.

ffe7 6c 2c 03    JMP (ICLALL)

              ; *****
ffea            UDTIM              ; Update the system clock
              ; *****

              ; Call address: $FFEA
              ; Communication registers: None
              ; Preparatory routines: None
              ; Error returns: None
              ; Stack requirements: 2
              ; Registers affected: A, X

              ; This routine updates the system clock. Normally this routine is called
              ; by the normal KERNAL interrupt routine every 1 /60th of a second. If
              ; the user program processes its own interrupts this routine must be
              ; called to update the time. Also, the STOP key routine must be called,
              ; if the stop key is to remain functional.

ffea 4c 34 f7    JMP Kernal_UDTIM

              ; ******
ffed            SCREEN             ; Return screen format
              ; ******

              ; Call address: $FFED
              ; Communication registers: X, Y
              ; Preparatory routines: None
              ; Stack requirements: 2
              ; Registers affected: X, Y

              ; This routine returns the format of the screen, e.g., 22 columns in X
              ; and 23 lines in Y. This routine can be used to determine what machine
              ; a program is running on, and has been implemented on the VIC to help
              ; upward compatibility in programs.

ffed 4c 05 e5    JMP Kernal_SCREEN

              ; ****
fff0            PLOT               ; Read or set cursor location
              ; ****

              ; Call address: $FFF0
              ; Communication registers: A, X, Y
              ; Preparatory routines: None
              ; Error returns: None
              ; Stack requirements: 2
              ; Registers affected: A, X, Y

              ; A call to this routine, with the accumulator carry flag set, loads the
              ; current position of the cursor on the screen (in X,Y coordinates) into
              ; the X and Y registers. X is the column number of the cursor location
              ; (0-21), and Y is the row number of the location of the cursor (0-22).
              ; A call with the carry bit clear moves the cursor to X,Y as determined
              ; by the X and Y registers.

              ; READING CURSOR LOCATION
              ; 1) Set the carry flag.
              ; 2) Call this routine.
              ; 3) Get the X and Y position from the X and Y registers respectively.

              ; SETTING CURSOR LOCATION
              ; 1) Clear carry flag.
              ; 2) Set the X and Y registers to the desired cursor location.
              ; 3) Call this routine.

fff0 4c 0a e5    JMP Kernal_PLOT

              ; ******
fff3            IOBASE             ; Define I/O memory page
              ; ******

              ; Call address: $FFF3
              ; Communication registers: X, Y
              ; Preparatory routines: None
              ; Error returns: None ,
              ; Stack requirements: 2
              ; Registers affected: X, Y

              ; This routine will set the X and Y registers to the address of the
              ; memory section where the memory mapped I/O devices are located. This
              ; address can then be used with an offset to access the memory mapped
              ; I/O devices in the VIC. The offset will be the number of locations
              ; from the beginning of the page that the desired I/O register is
              ; located. The X register will contain the low order address byte,
              ; while the Y register will contain the high order address byte.
              ; This routine exists to provide compatibility between the VIC 20 and
              ; future models of the VIC. IF the I/O locations for a machine language
              ; program are set by a call to this routine, they should still remain
              ; compatible with future versions of the VIC, the KERNAL and BASIC.

              ; How to use:
              ; 1) Call this routine by using the JSR instruction.
              ; 2) Store the X and the Y registers in consecutive locations.
              ; 3) Load the Y register with the offset.
              ; 4) Access that I/O location.

fff3 4c 00 e5    JMP Kernal_IOBASE

0001 FALSE    #if C64
SKIP             .byte "RRBY"
              #endif
0000 TRUE     #if VIC
fff6 ff ff ff    .FILL   4 (-1)    ; unused ; 4 bytes
              #endif

fffa a9 fe       .word   Entry_NMI ; Non Maskable Interrupt vector
fffc 22 fd       .word   Entry_RESET; Reset vector
fffe 72 ff       .word   Entry_IRQ ; Interrupt Request vector



 1835 Symbols
-------------
C64                            $0000     5D     6    418   1550   1582
                                      1609   1797   2050   2793   3038
                                      3569   7572   7663   7669   7865
                                      7964   8004   8277   8306   8419
                                      8458   8519   8877   8905   9028
                                      9200   9629   9707   9837   9882
                                      9912   9926  10013  10028  10041
                                     10056  10067  10081  10123  10137
                                     10145  10153  10187  10199  10288
                                     10404  10430  10456  10487  10503
                                     10524  10541  10563  10723  10769
                                     10790  10864  10888  10917  10954
                                     11011  11038  11047  11085  11115
                                     11145  11158  11171  11189  11209
                                     11225  11238  11273  11309  11404
                                     11444  11512  11530  11610  11636
                                     11651  11662  11668  11686  11718
                                     11738  11768  11774  11783  11795
                                     11815  11829  11940  12130  12137
                                     12177  12203  12207  12264  12281
                                     12416  12460  12484  12496  12500
                                     12750  12757  12763  12795  12809
                                     12836  12846  12883  12891  12922
                                     12974  13000  13176  13196  13214
                                     13225  13237  13502  13586  13632
                                     13865  14114  14129  14139  14149
                                     14157  14356  14363  14371  14379
                                     14500  14515  14536  14615  14635
                                     14718  14755  14814  14823  14934
                                     14986  15163  15218  15375  15424
                                     15455  15467  15475  15488  15494
                                     15525  15586  15598  15660  15735
                                     15750  15812  15837  15852  16026
                                     16123  16133  16144  16174  16329
                                     16340  16347  16391  16438  16470
                                     16553  16577  16667  16690  16756
                                     16815  16820  16935  16957  16964
                                     16984  17027  17036  17043  17061
                                     17072  17098  17118  17163  17252
                                     18410
Basic_USR                      $0000   693D  1854   8344
JIFFY                          $0000     8D   829   1144   8042   8297
                                      8408   8420   8428   8436   8467
                                      8520   8596   8694   8987   9706
                                      9727   9991  10283  10297  10302
                                     10314  10321  10333  10369  10376
                                     10589  10758  10772  10858  11037
                                     11069  11088  11094  11132  11828
                                     11970  12003  12119  12193  12206
                                     12248  12444  12651  12660  12674
                                     12960  12967  12994  13009  13016
                                     13024  13062  13094  13104  13233
                                     13397  13465  13699  16493  16666
                                     17610  18263
PAL                            $0000     9D  8506  10659  16774  16780
                                     17132
VIC                            $0001     6D    80    692   1360   1613
                                      1800   2053   2797   3041   3572
                                      7575   7672   7869   7967   8008
                                      8310   8403   8427   8492   8595
                                      8791   8880   8901   9031   9036
                                      9062   9209   9399   9407   9644
                                      9712   9840   9885   9917  10017
                                     10032  10045  10060  10070  10084
                                     10126  10156  10192  10282  10293
                                     10302  10313  10320  10333  10369
                                     10375  10416  10442  10468  10492
                                     10507  10527  10544  10587  10729
                                     10804  10818  10829  10840  10870
                                     10892  10905  10920  10966  11014
                                     11050  11118  11148  11175  11192
                                     11213  11229  11242  11320  11407
                                     11454  11519  11533  11592  11614
                                     11640  11675  11696  11723  11747
                                     11755  11804  11863  11887  11943
                                     12133  12144  12180  12193  12195
                                     12248  12267  12285  12419  12507
                                     12753  12760  12798  12812  12839
                                     12866  12886  12894  12978  13015
                                     13094  13115  13147  13179  13204
                                     13218  13228  13233  13242  13497
                                     13507  13635  13869  14122  14132
                                     14143  14152  14161  14359  14366
                                     14374  14509  14518  14571  14669
                                     14725  14868  14948  14978  15049
                                     15167  15381  15427  15458  15491
                                     15498  15514  15528  15589  15676
                                     15744  15816  15840  15855  16129
                                     16136  16147  16177  16350  16353
                                     16396  16445  16473  16493  16562
                                     16615  16673  16715  16771  16895
                                     16941  16954  16960  16967  17007
                                     17030  17039  17046  17064  17075
                                     17131  17291  18263  18413
USRVEC                         $0001   694D  8346   8346
IEC_CLK_BIT                    $0002   405D 10941  11260  11269
ADRAY1                         $0003   703D  8350   8350
COLINK                         $0004   394D  9559   9579
ADRAY2                         $0005   711D  8348   8348
Default_Color                  $0006   397D  8817
CHARAC                         $0007   720D  3195   3201   3202   3287
                                      3316   3847   3852   3856   4533
                                      4546   5406   5421   7129   7609
                                      7687
ENDCHR                         $0008   721D  2476   2537   2542   3197
                                      3200   3205   3210   3863   4536
                                      4541   5407   5423
TRMPOS                         $0009   722D  3585   3592
VERCK                          $000a   735D  7950   7952   7956
LF                             $000a   683D  3546
COUNT                          $000b   736D  2300   2358   2380   2495
                                      2511   2553   4529   4532   4535
                                      4540   4542   4545   4547   4846
                                      4934   4995   5022   5050   5100
                                      5144
DIMFLG                         $000c   743D  4646   4906   4941   4992
                                      5031   5089
VALTYP                         $000d   749D  3335   3519   3840   4040
                                      4102   4132   4242   4395   4567
                                      4665   4685   4909   4937   5223
                                      5241   5480   6007
CR                             $000d   682D  2439   3542   9006
INTFLG                         $000e   755D  3333   3878   4422   4666
                                      4694   4907   4939
GARBFL                         $000f   770D  2463   2479   2529   2740
                                      2773   2775   2814   5492   5519
                                      5523
SUBFLG                         $0010   776D  2688   2844   4691   4707
                                      4714   5286   5305
VIC_REGS                       $0010    83D  8935
INPFLG                         $0011   787D  3669   3806   3818   3842
                                      3926
TANSGN                         $0012   788D  4217   4615   8169   8171
                                      8193   8202
IOPMPT                         $0013   799D  2234   3490   3535   3544
                                      3643   3685   3707   3717   3728
                                      3736   3741   3765   3776   3785
                                      3828   3934   8362   8499
LINNUM                         $0014   807D  2375   2375   2587   2595
                                      2729   2730   2735   2736   2752
                                      2754   3104   3106   3281   3282
                                      3288   3303   3308   3309   3311
                                      3312   3313   3314   3315   3317
                                      3319   6118   6119   6126   6126
                                      6129y  6131   6131   6141y  6160y
                                      7908
TEMPPT                         $0016   812D  2677   5461   5485   5555
                                      5871   8368
COLS                           $0016   392D  8766   8838   8871   8888
                                      8895   9216   9374   9383   9482
                                      9566   9580   9586   9862   9907
ROWS                           $0017   393D  8767   8844   8848   9188
                                      9533   9594   9674   9696   9698
                                      9700   9783   9801   9817
LASTPT                         $0017   817D  5481   5867   5869   5873
                                      8363
TEMPST                         $0019   818D  2676   5550   8367
IEC_IFR_BIT                    $0020   404D 11167
RS232_C_BIT                    $0020   407D 11352
IEC_DAT_BIT                    $0020   406D  8647
QUOTE                          $0022   684D  2477   2771   3213   3748
                                      3853   4272   5405   5427   5462
                                      9123   9128
INDEXA                         $0022   824D  2115   2125   2133   2163
                                      2165   2229   2231   2240y  2308
                                      2310   2335   2337   2341y  2345
                                      2401   2401   2406y  2412y  2416
                                      2419y  2420   2423y  2424   2425
                                      2876   2876   3289   3305   3307
                                      3310   3410y  3631y  4108   4110
                                      4178   4179   4181   4194   5049
                                      5139   5178   5552   5552   5564
                                      5564   5592   5592   5594y  5597y
                                      5600y  5604y  5612y  5616   5617
                                      5619   5622   5638y  5641y  5662y
                                      5665y  5668y  5685   5685   5693
                                      5694   5696   5699   5783   5783
                                      5795y  5830   5830   5834y  5837y
                                      5840y  5860   5860   5924   5925
                                      5927   6018y  6061   6064   6066
                                      6602   6602   6604y  6607y  6610y
                                      6613y  6621y  6829   6829   6831y
                                      6834y  6837y  6840y  6845y  6876
                                      6876   6879y  6882y  6885y  6890y
                                      6893y  7777   7777   7779y  7782y
                                      7785y  7788y  8137   8138
INDEXB/FAC3                    $0024   825D  2312   2319   2331   2342y
                                      2346   3977   6065   6072   6074y
                                      6077y  6082y  7026   7036   7038y
                                      7042y  7047y  7052y  7056y  7062y
                                       827D  5159   5180   5188   5207
                                      5210   6422   6538   6539   6540
                                      6541   6572   6574   6575   6577
                                      6578   6580   6581   6583   6586
                                      6587   6588   6589   6754   6815
                                      6817   6819   6821
TXTTAB                         $002b   835D  2400   2400   2575   2575
                                      2626y  2628y  2629   2633   2698
                                      2701   2986   2988   3117   3117
                                      7933   7953   7953   8371   8371
                                      8378y  8379   8381   8390   8390
                                      8395   8398
VARTAB                         $002d   839D  2309   2317   2318   2320
                                      2322   2327   2356   2360   2379
                                      2379   2632   2635   2662   2662
                                      3437   3441   4715   4715   5563
                                      5563   7932   7932   7997   7997
ARYTAB                         $002f   843D  2663   2663   4722   4724
                                      4797   4797   4811   4811   4942
                                      4943   5567   5569
STREND                         $0031   847D  2106   2106   2378   2378
                                      2664   2664   4799   4799   4948
                                      4950   5064   5064   5081   5085
                                      5231   5234   5504   5507   5548
                                      5548   5585   5587
FRESPC                         $0033   851D  2173   2176   2200   2203
                                      2661   2661   3427   3432   5230
                                      5233   5498   5499   5511   5511
                                      5543   5544   5669   5672   5721
                                      5721   5845   5847   5851   5852
                                      5854   8375   8375
UTLSTP                         $0035   856D  5512   5512   5796y  5803
                                      5804   5806
MEMSIZ                         $0037   860D  2660   2660   5539   5540
                                      7833   7834   8374   8374   8393
                                      8397
CURLIN                         $0039   866D  2255   2287   2866   2866
                                      2919   2922   3019   3023   3023
                                      3059   3059   3086   3086   3103
                                      3105   3158   3158   3679   3679
                                      3995   3997   5265   7305   7306
OLDLIN                         $003b   871D  3024   3024   3058   3058
SEMIC                          $003b   685D  3516   3751
OLDTXT                         $003d   878D  2687   2904   2904   3022
                                      3022   3051   3056   3692   3692
DATLIN                         $003f   886D  3676   3676   3909   3913
DATPTR                         $0041   892D  2993   2993   3796   3796
INPPTR                         $0043   898D  3807   3807   3814   3814
                                      3890   3890   3924   3925   3932
VARNAM                         $0045   900D  4394   4394   4652   4695
                                      4696   4705   4728   4731   4779
                                      4779   4813   4816   4916   4916
                                      4918   4918   4957   4959   5007
                                      5014   5148   5153
VARPNT                         $0047   906D  4839   4839   5164   5167
                                      5169   5293   5293   5321   5326
                                      5330y  5334   5342   5342   7465
                                      7479
FORPNT                         $0049   911D  2077   2080   2082   2087
                                      2761   2766   2819   2891   2891
                                      3138   3330   3330   3353y  3356y
                                      3369   3463y  3466y  3469y  3811
                                      3811   3960   3960   3984   3985
                                      6149   6156   6161   6162   6869
                                      6869   8027   8052   8058   8101
                                      8110   8112   8123   8124
YSAVE                          $004b   917D  3813   3813   3891   3891
                                      4125   4212
ACCSYM                         $004d   919D  4075   4089   4090   4092
                                      4097   4142   4159   4568
FUNCPT                         $004e   925D  5307   5307   5315   5315
                                      5318   5318   5320y  5324y  5337y
                                      5340y  5344   5344   5355y  5358y
                                      5361y  5364y  5367y  5546   5547
                                      5686   5686   5707   5708   5715y
                                      5727y  5732y  7599   7600   7605
                                      7605   7616   7616   8195   8196
                                      8204   8204
DESCPT                         $0050   929D  3453   3453   3459   3459
                                      3462y  3465y  3468y  5389   5389
                                      5756   5756   5900y  5905y  5918
                                      5918   5940y  5964y  5985   5985
GARBSS                         $0053   931D  5562   5579   5687   5691
                                      8359
JUMPER                         $0054   936D  4514   8343
FUNJMP                         $0055   938D  4511   4513   5688   5710
                                      5714   5724   5980   5986
FAC2M5                         $0056   943D  6212   6232   6259   6315
                                      7676   7703
FACTPA                         $0057   948D  2186   6861   6862   7721
                                      7724   7724   8198   8198
TMPPTA                         $0058   949D  2132   2134   2136   2141y
                                      2147y  2151   2359   2365   4807
                                      4807   4809   4809   4855   4855
                                      5052   5054   5057   5072y  5076
                                      5079   5163   5166   5577   5577
                                      5582   5582   5601   5602   5605
                                      5606   5625   5627   5722   5722
                                      5726   5729   5730
COLMAX                         $0058   395D  9180   9437
TMPPTB                         $005a   950D  2113   2117   2123   2126
                                      2128   2140y  2146y  2150   2357
                                      2361   4800   4800   5717   5720
FACTPB                         $005c   955D  6854   7761   7761
TMPVA1                         $005d   956D  4410   5190   5215   7153
                                      7216   7244   7358   7374   7379
                                      7388   7404   7471
TMPVA2                         $005e   957D  4406   7203   7212   7217
                                      7223   7229   7271   7283   7292
                                      7403   7502   7507
TMPPTC                         $005f   958D  2114   2118   2307y  2311
                                      2313   2315y  2323   2326   2384y
                                      2582   2582   2583y  2588y  2597y
                                      2603y  2606y  2741y  2748y  2751y
                                      2780y  2783y  2786y  2787   2788
                                      3122   3125   4718   4721   4729y
                                      4733y  4739   4798   4798   4814y
                                      4817y  4820y  4822y  4824y  4826y
                                      4828y  4831   4834   4849   4850
                                      4946   4947   4955y  4960y  4965y
                                      4967   4970y  4971   4997y  5008y
                                      5015y  5026y  5042y  5045y  5082
                                      5084y  5087   5088y  5099y  5112y
                                      5117y  5179y  5182y  5549   5549
                                      5676   5679   5683   5684   5716
                                      5718   7190   7199   7207   7208
                                      7242   7275
FAC1EX                         $0061   962D  2194   3229   3376   3456
                                      3456   4192   4228   4570   4580
                                      4584   4890   5398   5434   5470
                                      6112   6190   6223   6226   6233
                                      6251   6308   6342   6346   6355
                                      6503   6507   6623   6638   6647
                                      6690   6728   6729   6731   6846
                                      6892   6912   6931   6944   6961
                                      7010   7045   7080   7093   7117
                                      7127   7265   7342   7627   7678
                                      7698   7699   7813   7816   8237
FAC1M1/FAC1M2                  $0062   963D  2873   2874   4191   4191
                                      4457   4571   4605y  5242   5396
                                      5414   5414   5472   5890y  6272
                                      6287   6290   6326   6328   6337
                                      6357   6378   6380   6406   6550
                                      6738   6784   6816   6843   6889
                                      6986   6995   7049   7106   7107
                                      7108   7136   7312   7442   7444
                                      7780   7802   7804    964D  3402
                                      4454   4572   5243   5397   5474
                                      6269   6289   6292   6323   6325
                                      6336   6358   6381   6383   6404
                                      6548   6741   6781   6818   6838
                                      6884   6988   7053   7137   7313
                                      7439   7441   7786   7805   7807
FAC1M3/FAC1M4                  $0064   965D  3352   3401   3426y  3431y
                                      3440   3445   3451y  4190   4190
                                      4302   4375   4381   4393   4393
                                      4425y  4428y  4453   4475   4475
                                      4494   4494   4531   4544   4865
                                      4926   5109   5136   5388   5388
                                      5477   5477   5741   5741   5748y
                                      5824   5824   6045   6116   6266
                                      6291   6294   6320   6322   6335
                                      6359   6384   6386   6402   6546
                                      6744   6778   6820   6835   6881
                                      7005   7057   7138   7436   7438
                                      7783   7806   7808    966D  3261
                                      3355   3403   3436   3446   4299
                                      4377   4383   4455   4534   4539
                                      4866   4928   5111   5142   5949
                                      5967   5969   6047   6117   6263
                                      6293   6296   6317   6319   6334
                                      6360   6387   6389   6400   6544
                                      6747   6775   6822   6832   6878
                                      7004   7063   7128   7139   7432
                                      7435   7789   7801   7803
FAC1SI                         $0066   967D  2871   3377   3983   4169
                                      4224   4588   4596   4881   6110
                                      6185   6187   6228   6311   6370
                                      6372   6615   6653   6660   6841
                                      6887   6907   6965   7012   7019
                                      7043   7069   7084   7104   7122
                                      7123   7263   7332   7338   7629
                                      7631   7812   8163   8167   8201
                                      8231
SGNFLG                         $0067   969D  7159   7233   7739   7762
FAC1OV                         $0068   970D  6436   7088   7097   7110
                                      8361
FAC2EX                         $0069   974D  4219   4560   4560   6213
                                      6214   6252   6254   6622   6630
                                      6911   6932   7594   7697   7700
FAC2M1                         $006a   975D  4220   4220   4558   4559
                                      6327   6582   6619   6737   6767
                                      6783   6785
FAC2M2                         $006b   976D  6324   6579   6611   6740
                                      6766   6780   6782
FAC2M3/FAC2M4                  $006c   977D  4221   4221   4573   4576
                                      4604y  6321   6576   6608   6743
                                      6765   6777   6779    978D  4574
                                      4577   6318   6573   6605   6746
                                      6764   6774   6776
FAC2SI                         $006e   979D  4223   4556   6188   6227
                                      6614   6617   6901   7262   7602
                                      8154
STRPTR/FAC1M5                  $006f   983D  3454   3454   4225   5413
                                      5413   5419y  5436   5438   5444
                                      5452   5452   5744   5744   5746y
                                      5759   5759   5769y  5772y  5775y
                                      6189   6249   6616   6652   6688
                                      6710   7264   7710   8159    988D
                                      4398   5478   6211   6238   6244
                                      6260   6295   6297   6316   6333
                                      6361   6390   6392   6393   6429
                                      6448   6542   6590   6800   6847
                                      6894   6915   6935   6946   7011
                                      7061   7121   7656   7704   7814
TMPPTD                         $0071   990D  2493   2514   3380   3383
                                      3384   3394   4408   5005   5021
                                      5047   5048   5066   5067   5077
                                      5102   5105   5130   5131   5143
                                      5146   5202   5203   5437   5443
                                      6060   6060   6088   6088   7339
                                      7410   7421   7466   7478   7490
                                      7719   7719   7731   7731   7738y
                                      7740   7744   7747   7748   7752
                                      7752   7759   7759
CHRGET                         $0073   994D  2280   2722   2885   2939
                                      2961   2976   3267   3322   3606
                                      3703   3839   4014   4093   4245
                                      4261   4350   4485   4667   4676
                                      4702   4873   6032   7167   7177
                                      7193   8355
CHRGOT                         $0079   995D  2718   2882   3092   3222
                                      3240   3499   3816   3882   3893
                                      3917   4011   4078   4631   4640
                                      4653   4931   5345   5950   6048
                                      6078   6151   8072   8089
TXTPTR                         $007a   996D  2279   2279   2461   2497
                                      2552   2566   2568   2700   2703
                                      2861   2863   2900   2900   2908y
                                      2911y  2918y  2921y  2924   2925
                                      2927   3018   3018   3057   3057
                                      3085   3085   3110   3111   3124
                                      3127   3159   3159   3175   3176
                                      3178   3208y  3693   3693   3812
                                      3812   3815   3815   3836   3836
                                      3845   3864   3864   3889   3889
                                      3892   3892   3905y  3908y  3911y
                                      3999   4001   4058   4060   4063
                                      4135   4137   4140   4279   4279
                                      4348y  5294   5294   5336   5336
                                      5338   5341   5350   5350   6059
                                      6059   6062   6067   6089   6089
                                      7287y  7973   7992   8318   8320
IEC_ATN_BIT                    $0080   403D 10783  11092
ISNUM                          $0080   997D  3411
TK_END                         $0080  1619
TK_FOR                         $0081  1620D  2075   2892
TK_NEXT                        $0082  1621
TK_DATA                        $0083  1622D  2525   3919
TK_INFL                        $0084  1623
TK_INPUT                       $0085  1624
TK_DIM                         $0086  1625
TK_READ                        $0087  1626
TK_LET                         $0088  1628
TK_GOTO                        $0089  1629D  3223   3257
TK_RUN                         $008a  1630
TK_IF                          $008b  1631
RNDX                           $008b   999D  7793   7793   7818   7819
TK_RESTORE                     $008c  1632
TK_GOSUB                       $008d  1633D  3087   3141   3253
TK_RETURN                      $008e  1634
TK_REM                         $008f  1635D  2533
STATUS                         $0090  1001D 11243  12106  12339  12390
                                     12557  12772  12950  12990  13043
                                     13044  13052  13088  13272  15406
                                     16840  16846  16847
TK_STOP                        $0090  1637
STKEY                          $0091  1014D 13602  13631
TK_ON                          $0091  1638
TK_WAIT                        $0092  1639
SVXT                           $0092  1026D 15723  15724  15767  15778
VERCKK                         $0093  1027D 12948  13057  13364  15187
                                     15191  15407  15955  15992  16011
TK_LOAD                        $0093  1640
C3PO                           $0094  1028D 10754  10763  11061  11064
COLRAM_PAGE                    $0094   396D  9958
TK_SAVE                        $0094  1641
TK_VERIFY                      $0095  1642
BSOUR                          $0095  1030D 10768  10925  11003  11024
                                     11077
TK_DEF                         $0096  1643
SYNO                           $0096  1032D 15787  15805  15832  15836
                                     15847
TEMPX                          $0097  1033D 11957  11959  12055  12067
                                     12078  12287  12290  16617  16630
                                     16656
TK_POKE                        $0097  1644
TK_PRINFL                      $0098  1646
LDTND                          $0098  1040D 12535  12536  12538  12564
                                     12592  12628  12634
TK_PRINT                       $0099  1647D  2483
DFLTN                          $0099  1044D  8929   9091  11706  11937
                                     11969  12322  12604  12611
TK_CONT                        $009a  1648
DFLTO                          $009a  1048D  8927   9094  11600  12155
                                     12373  12599  12609
TK_LIST                        $009b  1649
PRTY                           $009b  1058D 15760  15792  15793  16085
                                     16220  16221  16289
DPSW                           $009c  1059D 15423  15681  15829  15875
TK_CLR                         $009c  1650
MSGFLG                         $009d  1060D 11914  13335  13549  13684
                                     15206  16837
TK_CMD                         $009d  1651
PTR1                           $009e  1065D 12194  12243  12288  12291
                                     15235  15247  15264  15267  15273
                                     15323  15332  15334  15421  15968
                                     15970  15977  15982  16040
TK_SYS                         $009e  1652
PTR2                           $009f  1066D 15262  15271  15274  15321
                                     15329  15333  15422  15981  15990
                                     15991
TK_OPEN                        $009f  1653
TK_CLOSE                       $00a0  1655
JIFFYH                         $00a0  1073D 13564  13572  13575  13614
                                     13623
TK_GET                         $00a1  1656
JIFFYM                         $00a1  1074D 13562  13570  13576  13613
                                     13622
TK_NEW                         $00a2  1657
JIFFYL                         $00a2  1075D 13560  13568  13577  13612
                                     13621
TSFCNT                         $00a3  1076D 10757  10764  10809  15686
                                     15753  15796  15811  16081  16231
                                     16232
TK_TAB                         $00a3  1661D  2953   3509
TK_TO                          $00a4  1662D  2867   2977
TBTCNT                         $00a4  1077D 11219  11250  15725  15727
                                     15749  16083  16205  16207
TK_FN                          $00a5  1663D  4307   5302
CNTDN                          $00a5  1078D 10910  10943  11140  11181
                                     11197  11202  11234  16243  16254
                                     16328
BUFPNT                         $00a6  1079D 12066  12090  12240  12737
                                     15348  15349
TK_SPC                         $00a6  1664D  3511
INBIT                          $00a7  1080D 11488  11491  11501  11527
                                     11561  15880  15909  15952  16038
                                     16305  16315  17049
TK_THEN                        $00a7  1665D  3225
BITCI                          $00a8  1081D 11485  11498  11506  15709
                                     15834  15863  16084  16163  16173
                                     17093
TK_NOT                         $00a8  1667D  4289
RINONE                         $00a9  1082D 11483  11520  11534  15713
                                     15717  15783  15864  16086  16187
                                     16195
TK_STEP                        $00a9  1668D  2883
TK_PLUS                        $00aa  1672D  4270   7183
RIDATA                         $00aa  1083D 11492  11545  11587  15418
                                     15884  15897  15919  15922  15925
                                     15933  16025
RIPRTY                         $00ab  1084D 11489  11490  11562  15280
                                     15444  15928  16049  16053  16054
                                     16058  16318  16323
TK_MINUS                       $00ab  1673D  2712   2720   4268   7179
TK_MUL                         $00ac  1674
SAL                            $00ac  1085D  9656   9658   9677   9767
                                      9769   9793   9795   9810   9846
                                      9848   9858   9865y  9878   9880
                                     13419  13421  13427y 15959y 15971
                                     15973  15984  15987  15996y 16015y
                                     16052y 16071  16073  16148  16178
                                     16270  16279y 16409  16411  16419
                                     16421
TK_DIV                         $00ad  1675
TK_POWER                       $00ae  1676
EAL                            $00ae  1086D  8683   8685   9660   9662
                                      9763   9765   9797   9799   9842
                                      9844   9867y  9879   9888  12989
                                     12999  13061y 13079y 13083  13085
                                     13308  13311  13325  13326  13375
                                     13376  15239  15239  15256  15259
                                     15283  15283  15307  15311  16410
                                     16412
TK_AND                         $00af  1677
TK_OR                          $00b0  1679
CMPO                           $00b0  1087D 15420  15563  15564  15568
                                     15570  15571  15573  15578  15580
                                     15593  15656  15667  15668  15670
                                     15672  15673  15679  15690  15691
                                     15695  15696  15699  15700  15722
                                     15770  15774  15821  15824  15825
TK_GT                          $00b1  1680D  4082
TK_EQUAL                       $00b2  1681D  3331   5290
TAPE1                          $00b2  1094D 12094y 12238y 12244y 12732y
                                     13283y 13286y 13296y 13298y 13301y
                                     13303y 15194y 15213y 15244y 15248y
                                     15251y 15254y 15257y 15260y 15272y
                                     15294  15294  15330y 16574  16575
TK_LT                          $00b3  1682
BITTS                          $00b4  1100D 11335  11347  11369  11372
                                     11376  11392  11419  15419  15707
                                     15732  15794  15807  15830  15844
                                     15851
TK_SGN                         $00b4  1686D  4312   4510   4512
NXTBIT                         $00b5  1106D 11353  11417  15848  15886
                                     15905  15937  17017
TK_INT                         $00b5  1687
TK_ABS                         $00b6  1688
RODATA                         $00b6  1111D 11338  11424  15865  15907
                                     15962  15965  15999  16002
TK_USR                         $00b7  1689
FNLEN                          $00b7  1126D 12704  12756  12783  12791
                                     12823  12965  13259  13339  13345
                                     13353  13404  15268  15326  16793
TK_FRE                         $00b8  1691
LA                             $00b8  1128D 12578  12618  12635  16802
SA                             $00b9  1129D  8673  12316  12329  12368
                                     12380  12491  12514  12582  12637
                                     12639  12673  12727  12749  12769
                                     12982  12986  13291  13403  13415
                                     13449  13453  13520  13531  16804
TK_POS                         $00b9  1692
FA                             $00ba  1130D 12306  12353  12407  12580
                                     12641  12767  12951  12984  13388
                                     13413  13451  16803  16811
TK_SQR                         $00ba  1693
FNADR                          $00bb  1138D 12788y 12825y 13350y 15270y
                                     15328y 16794  16795
TK_RND                         $00bb  1694
TK_LOG                         $00bc  1695
ROPRTY                         $00bd  1139D 11345  11346  11362  11380
                                     11416  15862  15911  15958  15994
                                     16014  16059  16100  16216  16218
                                     16230  16261  16272  16280  16291
TK_EXP                         $00bd  1696
TK_COS                         $00be  1697
FSBLK                          $00be  1147D 15486  15878  15888  16032
                                     16035  16042  16255  16299  16324
TK_SIN                         $00bf  1698
MYCH                           $00bf  1148D 15799  15861
TK_TAN                         $00c0  1700
CAS1                           $00c0  1149D 10039  10053  15503
TK_ATN                         $00c1  1701
STAL                           $00c1  1150D 13313  13315  13379  13381
                                     15238  15238  15250  15253  15284
                                     15284  15304  15309  16070  16072
                                     16616  16621  16624  16626  16633
                                     16634  16654  16900y 16903y 16904y
                                     16907y 16908y 16915
TK_PEEK                        $00c2  1702
TK_LEN                         $00c3  1703
MEMUSS                         $00c3  1151D  8682   8684  12941  12941
                                     13284  13287  13307  13310  13312
                                     13314  16489  16489  16500y 16504
TK_STRS                        $00c4  1704
TK_VAL                         $00c5  1705
LSTX                           $00c5  1152D 10211  10252
TK_ASC                         $00c6  1706
NDX                            $00c6  1173D  8955   8957   8973   8996
                                      9755  10246  10258  10263  11939
                                     13641
RVS                            $00c7  1183D  9140   9343   9495   9549
TK_CHRS                        $00c7  1707D  4486
TK_LEFTS                       $00c8  1709
INDX                           $00c8  1189D  9020   9041   9084  11990
TK_RIGHTS                      $00c9  1710
ICRROW                         $00c9  1203D  9025   9034   9528   9668
                                     11978
ICRCOL                         $00ca  1204D  9039  11976
TK_MIDS                        $00ca  1711
SFDX                           $00cb  1231D 10117  10174  10208  10251
TK_GO                          $00cb  1712D  2974
BLNSW                          $00cc  1238D  8823   8974   9967
BLNCT                          $00cd  1245D  8822   9936   9969   9972
GDBLN                          $00ce  1254D  8980   9979   9984
BLNON                          $00cf  1261D  8809   8978   8983   9974
                                      9978
INSRC                          $00d0  1266D  9009   9053   9089   9270
                                     11988
LINPTR                         $00d1  1271D  8884   8886   9012y  9061y
                                      9317y  9319y  9330y  9430y  9447y
                                      9449y  9458y  9866y  9896   9900
                                      9916y  9945y  9954   9956   9976
CSRIDX                         $00d3  1277D  8778   8783   8860   8865
                                      8872   9023   9040   9060   9082
                                      9176   9178   9235   9246   9256
                                      9271   9312   9355   9364   9385
                                      9433   9455   9480   9484   9504
                                      9551   9563   9583   9944   9973
                                     11975
CSRMOD                         $00d4  1297D  9024   9074   9125   9127
                                      9161   9336   9425   9550
LINLEN                         $00d5  1303D  8900   9008   9177   9217
                                      9255   9325   9357   9377   9429
                                      9442  10557  11989
TBLX                           $00d6  1308D  8777   8782   8861   8864
                                      9027   9187   9191   9192   9232
                                      9244   9253   9359   9376   9380
                                      9477   9479   9529   9540   9572
                                      9593   9596   9667   9703   9759
                                      9776   9789  11977
LASTKY                         $00d7  1313D  9065   9067   9068   9105
                                      9110   9264   9272  15729  15779
                                     15798  16253  16271  16281  16282
INSRTO                         $00d8  1330D  9147   9149   9159   9297
                                      9461   9467   9548
SLLTBL                         $00d9  1353D  8836   8847   8868   8881
                                      8892   9198   9199   9223   9538
                                      9678   9687   9689   9694   9698
                                      9700   9701   9780   9811   9822
                                      9824   9829   9897  10553  10555
SCROWM                         $00f2  1361D  9669   9704   9782   9787
                                      9806   9820   9834
USER                           $00f3  1364D  9321y  9323y  9332y  9451y
                                      9453y  9460y  9868y  9919y  9947y
                                      9955   9959   9981
KBDPTR                         $00f5  1384D 10133  10135  10164y 10209y
                                     10327  10329
RXPTR                          $00f7  1390D 11556y 11778y 12428  12439
                                     12904  12907  12908
STND_COL                       $00f7   388D  9743  10266
TXPTR                          $00f9  1395D 11423y 11665y 12433  12440
                                     12911  12914  12915
CTRL_COL                       $00fb   385D  9722
CTRL_ROW                       $00fe   386D  9725
BASSTO                         $00ff  1397D  5381   5381   7337
TK_PI                          $00ff  1713D  2468   2812   4257
STACK                          $0100  1399D  2074   2079   2081   2085
                                      2088   3982   3992   3994   3996
                                      3998   4000   4922   4924   4927
                                      4929   7413   7418   7470   7475
                                      7492   7512   7514   7524   7526
                                      7528   7532   7536   7539   7539
                                     15972  15974  15985  15988  17245
BUF                            $0200  1401D  2353   2376   2377   2383
                                      2441   2466   2505   2519   2520
                                      2540   2547   2561   2565   2901
                                      3532   3533   3534   3711   3712
                                      3714   3761   3774   3821   3822
                                      3823   7993   8365   8366
FILTBL                         $0259  1405D 12539  12540  12569  12577
                                     12636
DEVTBL                         $0263  1406D 12541  12542  12579  12642
SECATB                         $026d  1407D 12543  12544  12581  12640
KBUFFR                         $0277  1408D  8948   8952   8953   9000
                                     10261
OSSTAR                         $0281  1409D 16618  16647  16655  16886
                                     16887  16892  16892
OSTOP                          $0283  1410D 16867  16868  16874  16875
STIMOT                         $0285  1411D 16854
COLOR                          $0286  1412D  8818   9152   9331   9459
                                      9615   9983
CSRCLR                         $0287  1413D  8981   9975   9982
SCNMPG                         $0288  1414D  8792   8798   8829   8883
                                      9857   9899  16640  16649
KBMAXL                         $0289  1415D  8815  10259
KEYRPT                         $028a  1416D 10219
KRPTSP                         $028b  1419D  8820  10242  10245
KRPTDL                         $028c  1420D  8816  10214  10236  10238
SHFLAG                         $028d  1439D 10115  10169  10170  10253
                                     10274
LSTSHF                         $028e  1452D 10254  10277
KEYLOG                         $028f  1462D  8811   8813  10203
MODE                           $0291  1468D  8808  10279  10522  10528
                                     10536  10539
AUTODN                         $0292  1481D  8975   9022   9182
M51CTR                         $0293  1483D 11370  11467  11503  12826
                                     12834  17076
M51CDR                         $0294  1513D 11358  11400  11558  11601
                                     11707  12880
M51AJB                         $0295  1529
RSSTAT                         $0297  1531D 11437  11438  11582  11583
                                     12820  16814  16819
BITNUM                         $0298  1542D 11418  11546  12833  17092
BAUDOF                         $0299  1543D 11682  11684  12875  12878
                                     17052  17055
RIDBE                          $029b  1544D 11539  11543  11772  12899
RIDBS                          $029c  1545D 11541  11771  11779  12900
RODBS                          $029d  1546D 11420  11425  11658  12902
RODBE                          $029e  1547D 11421  11656  11660  12901
IRQTMP                         $029f  1548D 15481  15483  15520  15554
                                     16360  16363
IERROR                         $0300  1559D  2219   8453
IMAIN                          $0302  1560D  2272
ICRNCH                         $0304  1561D  2455
IQPLOP                         $0306  1562D  2805
IGONE                          $0308  1563D  2933
IEVAL                          $030a  1564D  4235
SAREG                          $030c  1577D  7904   7918
SXREG                          $030d  1578D  7905   7919
SYREG                          $030e  1579D  7906   7920
SPREG                          $030f  1580D  7902   7922
CINV                           $0314  1587D 15480  15482  15521  16362
                                     16364  16382  16384  16498  16507
                                     17250
CBINV                          $0316  1588D 17248
NMINV                          $0318  1589D 16924
IOPEN                          $031a  1591D 17902
ICLOSE                         $031c  1592D 17929
ICHKIN                         $031e  1593D 17968
ICKOUT                         $0320  1594D 18005
ICLRCH                         $0322  1595D 18033
IBASIN                         $0324  1596D 18085
IBSOUT                         $0326  1597D 18122
ISTOP                          $0328  1598D 18266
IGETIN                         $032a  1599D 18294
ICLALL                         $032c  1600D 18311
USRCMD                         $032e  1601
ILOAD                          $0330  1602D 12942
ISAVE                          $0332  1603D 13382
TBUFFR                         $033c  1605D 16572  16573
VIC_BASE                       $9000    82D  8939
VIC_R0                         $9000   124
VIC_R1                         $9001   128
VIC_R2                         $9002   130D  8802   8803
VIC_R3                         $9003   134
VIC_R4                         $9004   139
MEM_CONTROL                    $9005   412D 10494  10495  10509  10513
VIC_R5                         $9005   142D  8797  10294  10296
VIC_R6                         $9006   156
VIC_R7                         $9007   158
VIC_R8                         $9008   160
VIC_R9                         $9009   162
VIC_RA                         $900a   164
VIC_RB                         $900b   167
VIC_RC                         $900c   170
VIC_RD                         $900d   173
VIC_RE                         $900e   176
VIC_RF                         $900f   180
IO_Base_Address                $9110  1614D  8758   8759
RS2_DSR_CTS                    $9110   409D 11605  11621  11623  11625
                                     11628  11713  11727  11729  11732
                                     12423  12815  17047  17087
VIA1_DATB                      $9110   189
VIA1_DATA                      $9111   200D 16955
VIA1_DDRB                      $9112   211D 12814  16736
VIA1_DDRA                      $9113   212D 16743
RS2_TIM_LOW                    $9114   410D 11683  15532  17019
VIA1_T1CL                      $9114   213
VIA1_T1CH                      $9115   214
RS2_TIM_HIG                    $9115   411D 11685
VIA1_T1LL                      $9116   215
VIA1_T1LH                      $9117   216
VIA1_T2CL                      $9118   217D 17050  17053  17084
VIA1_T2CH                      $9119   218D 17054  17056  17086
VIA1_SR                        $911a   219
VIA1_ACR                       $911b   221D 16724
VIA1_PCR                       $911c   239D 10046  10061  10073  12425
                                     12817  15492  15501  16397  16399
                                     16729  17018
VIA1_IFR                       $911d   270D 16942
VIA1_IER                       $911e   287D 10071  11456  11615  11676
                                     11698  11724  11748  11757
RS2_IRQ_REG                    $911e   408D 11511  11522  11805  11809
                                     11814  12421  16717  16748  16944
                                     17008  17012  17021  17058  17091
IEC_DRAN                       $911f   400D  8663   8664  10033  10782
                                     10784  10913  10914  11010  11017
                                     11091  11093  11205  11206  11221
                                     11222  15383  15385  16745
VIA1_DATN                      $911f   299
VIA2_DATB                      $9120   315D   379  12887
KEYB_COL                       $9120   379D  9723   9744  10118  10128
                                     10193  10267  16130  16137  16355
VIA2_DATA                      $9121   316D   380
KEYB_ROW                       $9121   380D  9724  10119  10150  10151
                                     15677
VIA2_DDRB                      $9122   329D 16738
VIA2_DDRA                      $9123   330D 16740
VIA2_T1CL                      $9124   331D 10085  15594  16779
VIA2_T1CH                      $9125   332D 15597  16785
VIA2_T1LL                      $9126   333
VIA2_T1LH                      $9127   334
VIA2_T2CL                      $9128   335D 15585  15653  15658  16121
IEC_TIM_H                      $9129   401D 10951  11155
VIA2_T2CH                      $9129   336D 11322  15515  15596  15650
                                     15654  15659  16122
VIA2_SR                        $912a   337
VIA2_ACR                       $912b   338D 16357  16721
VIA2_PCR                       $912c   339
IEC_PCR                        $912c   399D  8646   8648   8654   8656
                                     10939  10942  11259  11261  11268
                                     11270  16734
VIA2_IFR                       $912d   346
IEC_IFR                        $912d   402D 10967  11166  11325  15529
                                     15745
VIA2_IER                       $912e   363D 15465  15466  15843  15858
                                     16718  16773
KEYB_ROWN                      $912f   381D 13583  13584
VIA2_DATN                      $912f   375D   381
OPTION_ROM                     $a000   414D 16435  16462  16951
BASIC_ROM                      $c000   415D  1796   1801   4376   4378
                                     16452
BASIC_BRK                      $c002  1804D 16978
BASIC_ID                       $c004  1805
Basic_Statement_Table          $c00c  1808D  2957   2959
Basic_Function_Table           $c052  1848D  4510   4512
Basic_Operator_Table           $c080  1876D  4115   4146   4154   4156
                                      4170
Basic_Keyword_Table            $c09e  1891D  2507   2557   2559   2828
                                      2834
ERR_01                         $c19e  1983D  2016
ERR_02                         $c1ac  1984D  2017
ERR_03                         $c1b5  1985D  2018
ERR_04                         $c1c2  1986D  2019
ERR_05                         $c1d0  1987D  2020
ERR_06                         $c1e2  1988D  2021
ERR_07                         $c1f0  1989D  2022
ERR_08                         $c1ff  1990D  2023
ERR_09                         $c210  1991D  2024
ERR_0A                         $c225  1992D  2025
ERR_0B                         $c235  1993D  2026
ERR_0C                         $c23b  1994D  2027
ERR_0D                         $c24f  1995D  2028
ERR_0E                         $c25a  1996D  2029
ERR_0F                         $c26a  1997D  2030
ERR_10                         $c272  1998D  2031
ERR_11                         $c27f  1999D  2032
ERR_12                         $c290  2000D  2033
ERR_13                         $c29d  2001D  2034
ERR_14                         $c2aa  2002D  2035
ERR_15                         $c2ba  2003D  2036
ERR_16                         $c2c8  2004D  2037
ERR_17                         $c2d5  2005D  2038
ERR_18                         $c2e4  2006D  2039
ERR_19                         $c2ed  2007D  2040
ERR_1A                         $c300  2008D  2041
ERR_1B                         $c30e  2009D  2042
ERR_1C                         $c31e  2010D  2043
ERR_1D                         $c324  2011D  2044
Basic_Msg_Tab                  $c328  2015D  2228   2230
Msg_OK                         $c364  2049D  7976   7976
Msg_Err                        $c369  2054D  2248   2248
Msg_IN                         $c371  2056D  7303   7303
Msg_Ready                      $c376  2057D  2264   2264   7998   7998
Msg_CrLf                       $c381  2058D  3032   3032
Msg_Break                      $c383  2059D  2045
Find_Active_FOR                $c38a  2064D  2846   3139   3961
FAF_Loop                       $c38f  2073D  2096
FAF_10                         $c3a4  2084D  2078
FAF_20                         $c3b0  2091D  2086
FAF_Ret                        $c3b7  2098D  2076   2089
Open_Up_Space                  $c3b8  2102D  2366   4808
Move_Block                     $c3bf  2109D  5723
MoBl_10                        $c3dc  2131D  2127
MoBl_Loop_Y                    $c3e8  2139D  2145
MoBl_Loop_X                    $c3ec  2143D  2135   2137   2153
MoBl_20                        $c3f3  2149D  2122
Check_Stack_Avail              $c3fb  2157D  2857   3084   4072
Check_Mem_Avail                $c408  2170D  2105   5003   5063   8391
CMA_10                         $c412  2179D  2175
CMA_Loop_X                     $c416  2184D  2188
CMA_Loop_2                     $c421  2192D  2196
CMA_Ret                        $c434  2206D  2174   2177   2201
Error_Out_Of_Memory            $c435  2210D  2162   2166   2202   2204
                                      5124
Basic_Error                    $c437  2216D  2446   3053   3151   3688
                                      3966   4052   4357   4988   5276
                                      5467   5751   6416   6809   7843
                                      7969   7989
Default_Error                  $c43a  2222D  8431
DeEr_Loop                      $c456  2239D  2246
Display_Msg_Then_Ready         $c469  2251D  3034
Basic_Ready                    $c474  2261D  2257   2798   3042   8311
                                      8502
Vectored_Warmstart             $c480  2269D  2282   2354   2394
Default_Warmstart              $c483  2275D  8435
Direct_Call                    $c496  2290
New_Basic_Line                 $c49c  2295D  2288
NBL_10                         $c4d7  2333D  2329
NBL_Loop                       $c4df  2340D  2336   2344   2348
NBL_20                         $c4ed  2350D  2302
NBL_30                         $c508  2364D  2362
NBL_Copy                       $c522  2382D  2386
Reset_And_Rechain              $c52a  2389D  7999
Rechain                        $c533  2397D  2352   2393   8515
Rech_Loop                      $c53c  2404D  2426
Rech_Loop_2                    $c544  2410D  2413
Rech_Ret                       $c55f  2428D  2407
Read_String                    $c560  2432D  2278   3790
ReSt_Loop                      $c562  2437D  2444
ReSt_Finish                    $c576  2448D  2440
Tokenize_Line                  $c579  2452D  2291   2299
Default_Tokenize               $c57c  2458D  8439
Toke_Loop                      $c582  2465D  2471   2534
Toke_05                        $c58e  2473D  2467
Toke_10                        $c5a4  2486D  2482
Toke_15                        $c5ac  2492D  2488
Toke_20                        $c5b6  2500D  2508
Toke_25                        $c5b8  2504D  2560
Toke_30                        $c5c7  2513D  2562
Toke_35                        $c5c9  2516D  2469   2475   2480   2484
                                      2490   2541   2543
Toke_40                        $c5dc  2528D  2524
Toke_45                        $c5de  2531D  2526
Toke_REM                       $c5e3  2536
Toke_50                        $c5e5  2539D  2549
Toke_55                        $c5ee  2545D  2478
Toke_60                        $c5f5  2551D  2510
Toke_65                        $c5f9  2555D  2558
Toke_70                        $c609  2564D  2521
Find_BASIC_Line                $c613  2572D  2301   2717
Find_BASIC_Line_AX             $c617  2578D  2607   3120
FiBL_Check                     $c62e  2594D  2590
FiBL_Cont                      $c637  2601D  2592
FiBL_Not_Found                 $c640  2609D  2584
FiBL_Ret                       $c641  2611D  2589   2598   2599   2618
                                      2721   2724
Basic_NEW                      $c642  2615D  1845
Perform_NEW                    $c644  2621D  8401
Reset_BASIC_Execution          $c659  2638D  2351   2392   3073
Basic_CLR                      $c65e  2645D  1839
Clear_Variable_Space           $c660  2651D  3076
Reset_Variable_Pointer         $c663  2657D  7835
Restore_And_Flush_Stack        $c677  2667D  8516
Flush_BASIC_Stack              $c67a  2673D  2247   8500
Flush_Ret                      $c68d  2690D  2648   2713
Reset_BASIC_Exec_Pointer       $c68e  2694D  2641   8002
Basic_LIST                     $c69c  2707D  1838
LIST_05                        $c6a4  2715D  2710   2711
LIST_10                        $c6bb  2726D  2719
LIST_12                        $c6c3  2733
LIST_15                        $c6c9  2738D  2731   2789
LIST_17                        $c6d4  2745
LIST_20                        $c6e6  2757D  2753
LIST_25                        $c6e8  2760D  2755
LIST_30                        $c6ef  2765D  2835
LIST_35                        $c6f3  2769D  2811   2813   2815
LIST_40                        $c700  2777D  2772
LIST_45                        $c714  2791D  2742   2758   2779
Vectored_Detokenize            $c717  2802D  2781
Default_Detokenize             $c71a  2808D  8441
DeTo_10                        $c72c  2822D  2830
DeTo_20                        $c72f  2826D  2829
DeTo_30                        $c737  2832D  2824   2837
Basic_FOR                      $c742  2840D  1812
BaFO_10                        $c753  2853D  2847
BaFO_20                        $c78b  2879D  2875   2875
BaFO_30                        $c79f  2888D  2884
Interpreter_Loop               $c7ae  2896D  2941   3094   4004
InLo_10                        $c7be  2906D  2903
InLo_20                        $c7ce  2916D  2913
Start_Program                  $c7e1  2930D  2292   2926   2968
Default_Start                  $c7e4  2936D  8442
Interpret                      $c7ed  2944D  2940   3245
Interpret_10                   $c7ef  2949D  3264
Inte_10                        $c804  2963D  2952
Inte_20                        $c807  2966D  2909
Inte_30                        $c80b  2970D  2975
Inte_40                        $c80e  2973D  2954
Basic_RESTORE                  $c81d  2982D  1823   2670
Store_DATPTR                   $c827  2992D  2989   3928
BaRE_Ret                       $c82b  2995D  2947
Check_STOP                     $c82c  2999D  2743   2899
Basic_STOP                     $c82f  3005D  1827
Basic_END                      $c831  3011D  1811
BaEN_10                        $c832  3016D  3008
BaEN_20                        $c849  3026D  3021
End_Of_Exec                    $c84b  3030D  2914
BaEN_30                        $c854  3036D  3033
Basic_CONT                     $c857  3046D  1837
BaCO_10                        $c862  3055D  3052
BaCO_Ret                       $c870  3061D  3017   3049
Basic_RUN                      $c871  3065D  1821
BaRU_10                        $c87d  3075D  3072
Basic_GOSUB                    $c883  3080D  1824
Goto_Line                      $c897  3090D  3077
Basic_GOTO                     $c8a0  3097D  1820   2979   3093   3242
BaGO_10                        $c8bc  3116D  3107
BaGO_20                        $c8c0  3119D  3112   3114
BaGO_Ret                       $c8d1  3129D  3136
Basic_RETURN                   $c8d2  3133D  1825
Undefined_Statement            $c8e3  3147D  3121
BaRE_10                        $c8e8  3153D  3258
BaRE_20                        $c8eb  3156D  3142
Basic_DATA                     $c8f8  3162D  1814   3771   5295
Add_Y_To_Execution_Pointer     $c8fb  3168D  3237   3779   3916
Add_To_TXTPTR                  $c8fc  3173
AYTE_Ret                       $c905  3180D  3177   3209   3211
Next_Statement                 $c906  3184D  2858   3165   3778   3899
Next_Line                      $c909  3191D  3101   3236
NeLi_10                        $c911  3199D  3215
NeLi_15                        $c917  3204
NeLi_20                        $c919  3207D  3214
Basic_IF                       $c928  3218D  1822
BaIF_10                        $c937  3228D  3224
Basic_REM                      $c93b  3233D  1826
BaIF_20                        $c940  3239D  3230
BaIF_30                        $c948  3244D  3241
Basic_ON                       $c94b  3248D  1828
BaON_10                        $c953  3256D  3291
BaON_20                        $c957  3260D  3254   3270
BaON_30                        $c95f  3266D  3262
BaON_Ret                       $c96a  3273D  3285
Scan_Linenumber                $c96b  3277D  2298   2716   2723   3100
                                      3268
ScLi_Loop                      $c971  3284D  3323
ScLi_10                        $c99f  3321D  3318
Basic_LET                      $c9a5  3326D  1819   2845   2964
Assign_Numeric_variable        $c9c2  3345D  3879
LET_10                         $c9d6  3359D  3348
LET_20                         $c9d9  3362D  3341
Assign_String_Variable         $c9da  3366D  3872
LET_30                         $c9ed  3379D  3397
LET_40                         $ca07  3393D  3388
Eval_Digit                     $ca1d  3407D  3381   3385
Jump_Illegal_Quantity          $ca24  3414D  3374
EvDi_10                        $ca27  3417D  3412
Assign_String                  $ca2c  3422D  3371
AsSt_10                        $ca3d  3435D  3429
AsSt_20                        $ca4b  3444D  3428   3433   3438
AsSt_30                        $ca52  3449D  3439   3442
AsSt_40                        $ca68  3458D  3447
Basic_PRINTN                   $ca80  3473D  1835
Basic_CMD                      $ca86  3480D  1840   3476
BCMD_10                        $ca90  3488D  3484
BaPR_00                        $ca9a  3495D  3520
BaPR_05                        $ca9d  3498D  3525
Basic_PRINT                    $caa0  3502D  1836   3493
BaPR_10                        $caa2  3507D  3607
Terminate_BUF                  $caca  3528D  2449
Print_CR                       $cad7  3539D  2235   2746   3505
Invert_A                       $cae5  3550D  3545   3636
Invert_Ret                     $cae7  3555D  3508   3536   3630
TAB_Jump                       $cae8  3559D  3515
TAB_10                         $caee  3567D  3576
TAB_20                         $caf8  3581D  3510   3513
TAB_30                         $cb0e  3595D  3579
TAB_40                         $cb0f  3598D  3590
TAB_50                         $cb10  3601D  3611
TAB_60                         $cb13  3605D  3517   3593
TAB_70                         $cb19  3609D  3603
Print_String                   $cb1e  3614D  2254   2264   3691   3937
                                      7320   7977   7998   8392   8400
Print_String_From_Descriptor   $cb21  3620D  3496   3523   3753
PSFD_Loop                      $cb28  3628D  3635   3637
Cursor_Right_Or_Space          $cb3b  3640D  3524   3610   3788
CROS_10                        $cb42  3647D  3644
Print_Question_Mark            $cb45  3652D  2236   3787   3830
Print_Char                     $cb47  3658D  2243   2770   2836   3543
                                      3547   3632
Bad_Input                      $cb4d  3666D  3886
BaIn_10                        $cb57  3675D  3671
BaIn_20                        $cb5b  3678D  3673
BaIn_30                        $cb5f  3681D  3588
BaIn_40                        $cb62  3684D  3670
BaIn_50                        $cb6b  3690D  3686
Basic_GET                      $cb7b  3697D  1844
BaGE_10                        $cb92  3710D  3702
Basic_INPUTN                   $cba5  3722D  1815
Set_Default_Channels           $cbb5  3733D  3477   3770
BaIN_10                        $cbb7  3738D  3718
Basic_INPUT                    $cbbf  3745D  1816
Input_String                   $cbce  3756D  3730   3749
BaIN_20                        $cbd6  3763D  3777
BaIN_30                        $cbea  3773D  3766   3769
Prompt_And_Input               $cbf9  3782D  3764   3833
BaIN_40                        $cc03  3789D  3786
Basic_READ                     $cc06  3793D  1818
BaIN_50                        $cc0d  3799D  3775
Read_Get                       $cc0f  3803D  3716
READ_Loop_Var                  $cc15  3809D  3896
READ_05                        $cc41  3826D  3819
READ_10                        $cc4a  3832D  3829
READ_15                        $cc4d  3835D  3824
READ_20                        $cc51  3838D  3817   3921
READ_25                        $cc65  3851D  3843
READ_30                        $cc71  3859D  3848
READ_35                        $cc72  3862D  3854
READ_40                        $cc7d  3869D  3866
READ_45                        $cc89  3876D  3841
READ_50                        $cc91  3881D  3873
READ_55                        $cc9d  3888D  3883   3885
READ_60                        $ccb8  3898D  3827   3920
READ_65                        $ccd1  3915D  3902
READ_70                        $ccdf  3923D  3894
READ_75                        $ccea  3930D  3927
READ_Ret                       $ccfb  3939D  3933   3935
Msg_Extra_Ignored              $ccfc  3942D  3936   3936
Msg_Redo_From_Start            $cd0c  3943D  3691   3691
Basic_NEXT                     $cd1e  3946D  1813
Find_NEXT_Variable             $cd24  3954D  3949   4015
NEXT_10                        $cd27  3959D  3951
NEXT_20                        $cd32  3965D  3906
NEXT_30                        $cd35  3970D  3962
NEXT_40                        $cd75  4003D  4013
NEXT_50                        $cd78  4006D  3993
Eval_Numeric                   $cd8a  4018D  2870   2886   5343   6038
                                      6096   7896
Is_Numeric                     $cd8d  4024D  2869   4117   4209   4515
                                      4880   5288   5308   5317   5374
Assert_String_Type             $cd8f  4031D  4491   5743   5815
Check_Var_Type                 $cd90  4037D  3340   4554
CVT_10                         $cd96  4044D  4048
CVT_20                         $cd97  4047D  4041
Type_Missmatch                 $cd99  4050D  4042
Eval_Expression                $cd9e  4055D  3221   3337   3518   4021
                                      4321   4489   4874   8133
EvEx_05                        $cda4  4062D  4059
EvEx_10                        $cda9  4067D  4160
EvEx_15                        $cdb8  4077D  5762
EvEx_20                        $cdbb  4080D  4094
EvEx_25                        $cdd7  4096D  4083   4085
EvEx_30                        $cde8  4106D  4103
EvEx_35                        $cdf0  4113D  4143
EvEx_40                        $cdf9  4119D  4148
EvEx_45                        $cdfa  4122D  4368
EvEx_50                        $ce07  4131D  4098
EvEx_55                        $ce11  4139D  4136
EvEx_60                        $ce19  4145D  4126
Call_Operator_Function         $ce20  4151D  4123
Jump_Syntax_Error              $ce30  4162D  4091
Apply_Operator                 $ce33  4166D  4158
Push_FAC1                      $ce38  4173D  2890
Round_And_Push_FAC1            $ce43  4186D  2877
Right_Operand                  $ce58  4197D  4099   4101
RiOp_10                        $ce5b  4203D  4128
RiOp_20                        $ce5d  4206D  4116
RiOp_30                        $ce64  4211D  4208
RiOp_40                        $ce66  4214D  4129   4147
RiOp_50                        $ce80  4227D  4204
Evaluate                       $ce83  4232D  4073   5742
Default_EVAL                   $ce86  4238D  8443
EVA_10                         $ce8a  4244D  4271
EVA_20                         $ce8f  4248D  4267
EVA_30                         $ce92  4251D  4246
EVA_40                         $ce9a  4256D  4253
Float_PI                       $cea8  4263D  4259   4259
EVA_50                         $cead  4265D  4258
Make_String_Descriptor_From_Co $cebd  4276D  3750
EVA_60                         $cec6  4284D  4281
EVA_70                         $cecc  4288D  4273
Basic_EQUAL                    $ced4  4295D  1887
EVA_80                         $cee3  4306D  4290
EVA_90                         $ceea  4311D  4308
Eval_In_Parenthesis            $cef1  4317D  4313   4505   5316
Need_Right_Parenthesis         $cef7  4324D  4935   5289   5976
Need_Left_Parenthesis          $cefa  4331D  4320   4488   5284
Need_Comma                     $cefd  4338D  3895   4490   4623   5953
                                      6103   8083
Need_A                         $ceff  4344D  2868   2978   3226   3332
                                      3486   3706   3727   3752   5291
                                      5303
Syntax_Error                   $cf08  4353D  2971   3154   3682   4163
                                      4349   4658   4788   5347   8091
Prep_Minus_Operation           $cf0d  4360D  4269
Prep_Operation                 $cf0f  4365D  4292
Is_Inside_BASIC_ROM            $cf14  4371D  4399   4437
IIBR_Ret                       $cf27  4385D  4379
Get_Var                        $cf28  4389D  4254   4764
GeVa_Ret                       $cf5c  4415D  4400   4402   4404
Load_Value                     $cf5d  4419D  4396
Load_Float                     $cf6e  4434D  4423
Load_Jiffyclock                $cf84  4449D  4405   4443
Check_ST_Var                   $cf92  4461D  4440
Load_Float_Var                 $cfa0  4472D  4438   4442   4465   4467
Function_Call                  $cfa7  4479D  4314
FuCa_10                        $cfd1  4504D  4487
FuCa_20                        $cfd6  4509D  4502
Basic_OR                       $cfe6  4518D  1885
Basic_AND                      $cfe9  4525D  1884
Basic_LESS                     $d016  4551D  1888
BaLE_10                        $d02e  4565D  4555
BaLE_20                        $d056  4587D  4581   4583
BaLE_30                        $d05b  4592D  4606
BaLE_40                        $d061  4598D  4563
BaLE_50                        $d066  4603D  4595
BaLE_60                        $d072  4611D  4599   4601   4608
BaLE_70                        $d07b  4619D  4616
DIM_00                         $d07e  4622D  4632
Basic_DIM                      $d081  4626D  1817
Get_Scalar_Address             $d08b  4636D  3329   3810   3957   4392
                                      5287
Get_Array_Address              $d090  4643D  4630
Get_FN_Address                 $d092  4649D  5306
Var_Syntax_Error               $d09c  4657D  4692
Get_Address                    $d09f  4661D  4655
GAdd_05                        $d0af  4672D  4668
GAdd_10                        $d0b0  4675D  4677   4679
GAdd_15                        $d0ba  4681D  4670
GAdd_20                        $d0c4  4688D  4683
GAdd_25                        $d0d4  4698D  4686
GAdd_30                        $d0db  4704D  4690
GAdd_35                        $d0e7  4712D  4709
GAdd_40                        $d0ef  4717D  4743
GAdd_45                        $d0f1  4720D  4741
GAdd_50                        $d0fb  4727D  4723
GAdd_55                        $d109  4737D  4730
Is_Alpha                       $d113  4746D  4252   4654   4669   4678
IA_RET                         $d11c  4755D  4750
Create_Var                     $d11d  4759D  4725
CrVa_10                        $d123  4774D  4783
CrVa_20                        $d128  4778D  4765
CrVa_30                        $d138  4787D  4794
CrVa_40                        $d13b  4790D  4781   4785
CrVa_50                        $d143  4796D  4792
CrVa_60                        $d159  4806D  4803
CrVa_70                        $d185  4830D  4734
CrVa_80                        $d18f  4838D  4835
Array_Pointer_To_First         $d194  4843D  4994   5002
APTF_10                        $d1a0  4854D  4851
Float_M32768                   $d1a5  4858D  4893   4893
Float_To_Integer               $d1aa  4861D  8349   8349
Eval_Positive_Integer          $d1b2  4870D  4917
Eval_Positive_Integer_Check    $d1b8  4877D  6044
Eval_Integer                   $d1bf  4887D  3350   4298   4530   4538
                                      4864
EvIn_10                        $d1cc  4896D  4882
EvIn_20                        $d1ce  4899D  4892
Find_Array                     $d1d1  4903D  4710
FiAr_05                        $d1db  4913D  4933
FiAr_10                        $d21c  4945D  4972
FiAr_15                        $d228  4953D  4949
FiAr_20                        $d237  4963D  4958
Bad_Subscript                  $d245  4975D  4998   5121
Illegal_Quantity               $d248  4982D  3415   4897   6026   6500
                                      8345   8345
Jump_Basic_Error               $d24a  4987D  4993
FiAr_25                        $d24d  4990D  4961
FiAr_30                        $d261  5001D  4951
FiAr_35                        $d274  5012D  5009
FiAr_40                        $d27d  5020D  5016
FiAr_45                        $d286  5028D  5051
FiAr_50                        $d296  5040D  5032
FiAr_55                        $d2b9  5062D  5058
FiAr_60                        $d2c8  5070D  5073   5078
FiAr_65                        $d2cd  5075D  5068
Find_Array_Element             $d2ea  5096D  4999
FiAE_10                        $d2f2  5104D  5145
FiAE_20                        $d308  5120D  5114
FiAE_30                        $d30b  5123D  5053   5060   5201   5212
FiAE_40                        $d30e  5126D  5113
FiAE_50                        $d30f  5129D  5118
FiAE_60                        $d320  5141D  5133
FiAE_70                        $d331  5152D  5149
FiAE_80                        $d337  5158D  5154
FiAE_Ret                       $d34b  5171D  5090   5267
Compute_Array_Size             $d34c  5175D  5046   5134
Compute_Array_Size_A           $d355  5185D  5161
CAS_10                         $d35f  5194D  5216
CAS_20                         $d378  5214D  5204
Basic_FRE                      $d37d  5220D  1855
FRE_10                         $d384  5227D  5224
Integer_To_Float               $d391  5237D  4304   4431   4548   5259
                                      8347   8347
Basic_POS                      $d39e  5248D  1856
Y_To_Float                     $d3a2  5255D  5999   6020   6132
Assert_Non_Direct              $d3a6  5262D  3700   3759   5283
Undefined_Function             $d3ae  5272D  5325
Basic_DEF                      $d3b3  5279D  1833
Get_FN                         $d3e1  5299D  5282   5314
Eval_FNX                       $d3f4  5311D  4309
EvFN_10                        $d418  5329D  5333
EvFN_20                        $d449  5349D  5346
EvFN_30                        $d44f  5352D  5296
Basic_STR                      $d465  5371D  1867
BaST_10                        $d46f  5380D  4413
Allocate_String_FAC1           $d475  5385D  3452   5451   5754
Allocate_String_A              $d47d  5392D  5887   5917
Create_String_Descriptor       $d487  5402D  3522   3617   4285   5382
Create_String_Descriptor_AY    $d48d  5410D  3870
CSD_10                         $d497  5417D  5424
CSD_20                         $d4a4  5426D  5422
CSD_30                         $d4a8  5430D  5420
CSD_40                         $d4a9  5433D  5428
CSD_50                         $d4b5  5442D  5439
CSD_60                         $d4bf  5449D  5445
Store_And_Push_String          $d4c7  5454
Push_String_Descriptor         $d4ca  5458D  5447   5761   5893   5932
PSD_10                         $d4d2  5466D  5520
PSD_20                         $d4d5  5469D  5463
Allocate_String_Space          $d4f4  5489D  5395
ASS_10                         $d4f6  5494D  5525
ASS_20                         $d501  5503D  5500
ASS_30                         $d50b  5510D  5506
ASS_40                         $d516  5517D  5505   5508
Garbage_Collection             $d526  5528D  2189   5228   5521
GaCo_Iter                      $d52a  5542D  5733
GaCo_Loop_1                    $d544  5554D  5558
GaCo_10                        $d54d  5560D  5556
GaCo_20                        $d559  5566D  5574
GaCo_30                        $d561  5572D  5568
GaCo_40                        $d566  5576D  5570
GaCo_50                        $d56e  5581D  5608   5610
GaCo_60                        $d572  5584D  5628
GaCo_70                        $d57d  5591D  5586   5588
GaCo_80                        $d5ae  5621D  5618
GaCo_90                        $d5b0  5624D  5632
GaCo_95                        $d5b8  5630D  5626
Check_Variable                 $d5bd  5635D  5573
Check_String                   $d5c7  5646D  5557   5631
ChSt_10                        $d5dc  5675D  5670
ChSt_20                        $d5e6  5682D  5678
ChSt_30                        $d5f6  5690D  5639   5642   5663   5671
                                      5673   5677   5680
ChSt_40                        $d601  5698D  5695   5709
Collect_String                 $d606  5704D  5589
Concatenate                    $d63d  5736D  4104
Conc_10                        $d65d  5753D  5749
Store_String_STRPTR            $d67a  5765D  3455   5755
Store_String_XY                $d688  5780D  5455
Store_String_INDEXA            $d68c  5786D  5758   5931
SSIN_10                        $d690  5793D  5798
SSIN_20                        $d699  5801D  5790
SSIN_30                        $d6a2  5808D  5805
Eval_String                    $d6a3  5812D  6005   8136
Get_String_Descriptor          $d6a6  5818D  3372   3623   4569   5225
Get_String_Descriptor_AY       $d6aa  5827D  4575   5757   5760   5919
GSD_10                         $d6d5  5856D  5853
GSD_20                         $d6d6  5859D  5844   5846   5848
Pop_Descriptor_Stack           $d6db  5864D  3460   5831
PDS_Ret                        $d6eb  5876D  5868   5870
Basic_CHR                      $d6ec  5880D  1870
Basic_LEFT                     $d700  5896D  1871
LEFT_10                        $d706  5903D  5942
LEFT_20                        $d70c  5909D  5904
LEFT_30                        $d70d  5912D  5965
LEFT_40                        $d70e  5915D  5968   5970
LEFT_50                        $d725  5929D  5926
Basic_RIGHT                    $d72c  5935D  1872
Basic_MID                      $d737  5945D  1873
MID_10                         $d748  5956D  5952
Pop_String_Descriptor_And_Byte $d761  5973D  5899   5938   5957
Basic_LEN                      $d77c  5995D  1866
Eval_String_And_Len            $d782  6002D  5998   6015   6054
Basic_ASC                      $d78b  6012D  1869
Jump_To_Illegal_Quantity       $d798  6023D  5958   6016   6046   6111
                                      6114
Get_Next_Byte_Value            $d79b  6029D  3586
Get_Byte_Value                 $d79e  6035D  3251   3483   3704   3725
                                      4497   5954   6104   8066   8100
Eval_Byte                      $d7a1  6041D  5883
Basic_VAL                      $d7ad  6051D  1868
VAL_10                         $d7b5  6058D  6055
VAL_20                         $d7cd  6071D  6068
Restore_Execution_Pointer      $d7e2  6085D  3871   4286
Get_Word_And_Byte              $d7eb  6093D  6138   6148
Need_Comma_Get_Byte            $d7f1  6100D  6153
FAC1_To_LINNUM                 $d7f7  6107D  6097   6127   7897
Basic_PEEK                     $d80d  6123D  1865
Basic_POKE                     $d824  6135D  1834
Basic_WAIT                     $d82d  6145D  1829
WAIT_10                        $d83c  6155D  6152
WAIT_20                        $d840  6159D  6163
WAIT_Ret                       $d848  6165D  6221
Add_0_5_To_FAC1                $d849  6169D  7383   8166
AY_Minus_FAC1                  $d850  6176D  6513   8162   8251
Basic_MINUS                    $d853  6182D  1880   7705   8160
PLUS_00                        $d862  6193D  6242
Add_Var_AY_To_FAC1             $d867  6198D  3986   6173   6509   6517
                                      7760   7798   8146   8178
Basic_PLUS                     $d86a  6204D  1879   6191   7266
PLUS_05                        $d86f  6210D  6207
Add_FAC2_To_FAC1               $d877  6217D  6689
PLUS_10                        $d893  6236D  6225
PLUS_15                        $d897  6240D  6234
PLUS_20                        $d8a3  6248D  6195   6224
PLUS_25                        $d8af  6256D  6253
PLUS_30                        $d8d2  6274D  7013   7130
Normalise_FAC1                 $d8d7  6279D  6275   6823   7817
PLUS_35                        $d8db  6286D  6300
Clear_FAC1_Exp_And_Sign        $d8f7  6303D  6056   6343   6667
PLUS_40                        $d8f9  6307D  7596
PLUS_45                        $d8fb  6310D  6649
PLUS_50                        $d8fe  6314D  6250
PLUS_55                        $d91d  6331D  6340
PLUS_60                        $d929  6339D  6288
Test_And_Normalize_FAC1        $d936  6349D  6329
TANF_10                        $d938  6354D  6955
TANF_Ret                       $d946  6363D  6352
Negate_FAC1                    $d947  6367D  6276
Negate_FAC1_Mantissa           $d94d  6375D  7089
Inc_FAC1_Mantissa              $d96f  6397D  6953
IFM_Ret                        $d97d  6408D  6394   6401   6403   6405
Overflow_Error                 $d97e  6412D  6356   6670   7277
Shift_FAC3                     $d983  6419D  6559
Shift_FACX                     $d985  6425D  6444   6445
Shift_FACX_A                   $d999  6440D  6194   7096
ShFA_10                        $d9a6  6451D  6469
ShFA_20                        $d9ac  6456D  6453
Shift_FACX_Right_Y             $d9b0  6461D  6246   7109
ShFA_30                        $d9ba  6471D  6449
REAL_1                         $d9bc  6477D  2880   2880   6512   6512
                                      8241   8241
VLOG_A                         $d9c1  6479D  6514   6514
HALF_SQRT_2                    $d9d6  6486D  6508   6508
SQRT_2                         $d9db  6487D  6510   6510
MINUS_0_5                      $d9e0  6488D  6516   6516
LN_2                           $d9e5  6489D  6520   6520
Basic_LOG                      $d9ea  6492D  1859   7615
LOG_10                         $d9f1  6499D  6496
LOG_20                         $d9f4  6502D  6497
Multiply_FAC1_With_AY          $da28  6523D  7354   7617   7655   7722
                                      7725   7751   7796
Basic_MULTIPLY                 $da2b  6529D  1881
MULT_10                        $da30  6535D  6532
Mult_SubA                      $da59  6555D  6543   6545   6547   6549
Mult_SubB                      $da5e  6562D  6551   6558
MULT_20                        $da61  6568D  6593
MULT_30                        $da7d  6585D  6570
Mult_Sub_Ret                   $da8b  6595D  6533
Load_FAC2_From_AY              $da8c  6599D  6179   6201   6526   6718
Check_FACs                     $dab7  6627D  6536   6730
Check_FACs_A                   $dab9  6633D  7712
ChFA_10                        $dac4  6644D  6639
ChFA_20                        $dacf  6651D  6648
Check_Overflow                 $dad4  6657D  7683
ChFA_30                        $dada  6664D  6636   6645
ChFA_40                        $dadf  6669D  6640   6662   6681   6691
                                      6732
Multiply_FAC1_BY_10            $dae2  6673D  3382   3399   7228   7247
                                      7373
Multiply_FAC1_By_4             $daed  6684D  3391
Mu10_Ret                       $daf8  6693D  6678
Float_10                       $daf9  6696D  6703   6703
Divide_FAC1_By_10              $dafe  6699D  7222   7378
Divide_FAC2_By_AY              $db07  6707D  8155
AY_Divided_By_FAC1             $db0f  6715D  6511   8205   8242
Basic_DIVIDE                   $db12  6721D  1882   6712
DIVI_10                        $db29  6736D  6769
DIVI_20                        $db3f  6749D  6739   6742   6745   6768
                                      6770
DIVI_30                        $db4c  6759D  6752   6791
DIVI_40                        $db4f  6763D  6787
DIVI_50                        $db5d  6772D  6761
DIVI_60                        $db7a  6789D  6755
DIVI_70                        $db7e  6793D  6756
Divide_By_Zero                 $db8a  6805D  6724
FAC3_To_FAC1                   $db8f  6812D  6552   6802
Load_FAC1_AY                   $dba2  6826D  2881   3980   4260   4476
                                      6711   7587   7794   8199
FAC1_To_FACTPB                 $dbc7  6851D  7737
FAC1_To_FACTPA                 $dbca  6858D  7720   8191
Assign_FAC1_To_FOR_Index       $dbd0  6866D  3360   3987
Assign_FAC1_To_Var             $dbd4  6872D  5335   6863   7601   7825
FAC2_To_FAC1                   $dbfc  6898D  4537   6208
Copy_ABS_FAC2_To_FAC1          $dbfe  6904D  7612
F2F1_Loop                      $dc02  6910D  6914
FAC1_Round_And_Copy_To_FAC2    $dc0c  6919D  3386   6676   6702   7259
                                      7585   8152   8156
FAC1_To_FAC2                   $dc0f  6925D  7677
F1F2_Loop                      $dc11  6930D  6934
F1F2_Ret                       $dc1a  6937D  6945   6947   6954
Round_FAC1_Checked             $dc1b  6941D  3349   4189   6725   6875
                                      6922
Round_FAC1                     $dc23  6950D  7659
Get_FAC1_Sign                  $dc2b  6958D  2889   6495   6980   7041
                                      7773
GFS_10                         $dc2f  6964D  7044
GFS_20                         $dc31  6967D  7074
GFS_Ret                        $dc38  6973D  6962   6970
Basic_SGN                      $dc39  6977D  1851
A_To_FAC1                      $dc3c  6983D  4469   4620   7261
Int_To_Float_Exp_X             $dc44  6992D  5245
Convert_Integer_To_Float       $dc49  7000D  7316
CITF_10                        $dc4f  7009D  4446
Basic_ABS                      $dc58  7016D  1853
Compare_FAC1_AY                $dc5b  7023D  4561   4894   7362   7368
                                      7606
Compare_FAC1_INDEXB_Y          $dc5d  7033D  3989
CPFA_10                        $dc92  7068D  7046   7050   7054   7058
CPFA_20                        $dc98  7073D  7070
FAC1_To_Integer                $dc9b  7077D  3400   4900   6115   7120
                                      7386
FATI_10                        $dcaf  7092D  7085
FATI_20                        $dcba  7099D  7064
FATI_30                        $dcbb  7102D  7095
Basic_INT                      $dccc  7114D  1852   7604   7686   8157
Clear_FAC1                     $dce9  7133D  7081
ClF1_Ret                       $dcf2  7142D  7119
Load_FAC1_From_String          $dcf3  7146D  3877   4249   6079
LFFS_05                        $dcf7  7152D  7155
LFFS_10                        $dd06  7162D  7158
LFFS_15                        $dd0a  7166D  7160   7209   7252
LFFS_20                        $dd0d  7169D  7156
LFFS_25                        $dd0f  7172D  7164
LFFS_30                        $dd2e  7189D  7180   7182
LFFS_35                        $dd30  7192D  7184   7186   7293
LFFS_37                        $dd33  7195D  7178
LFFS_38                        $dd35  7198D  7187
LFFS_40                        $dd41  7206D  7174
LFFS_45                        $dd47  7211D  7176   7200
LFFS_50                        $dd49  7214D  7204
LFFS_55                        $dd52  7221D  7224
LFFS_60                        $dd5b  7227D  7219   7230
LFFS_65                        $dd62  7232D  7218   7225
LFFS_70                        $dd67  7237D  7234
LFFS_75                        $dd6a  7240D  7170
LFFS_80                        $dd71  7246D  7243
Add_A_To_FAC1                  $dd7e  7255D  3419   6519   7251
LFFS_85                        $dd91  7270D  7196
LFFS_90                        $dda0  7279D  7273
LFFS_95                        $ddae  7291D  7276
MAXREAL_A                      $ddb3  7295D  7367   7367
MAXREAL_B                      $ddb8  7296D  7361   7361
MAXREAL_C                      $ddbd  7297D  7353   7353
Print_IN                       $ddc2  7300D  2258
Print_Integer_XA               $ddcd  7309D  2762   8399
To_Print_String                $ddda  7319D  7304
Format_FAC1                    $dddd  7323D  3521
Format_FAC1_Y                  $dddf  7328D  5376   7317
FoFA_02                        $dde7  7336D  7333
FoFA_04                        $ddf8  7346D  7343
FoFA_06                        $de00  7352D  7349
FoFA_08                        $de09  7357D  7350
FoFA_10                        $de0b  7360D  7380
FoFA_12                        $de16  7366D  7375
FoFA_14                        $de21  7372D  7369
FoFA_16                        $de28  7377D  7364
FoFA_18                        $de2f  7382D  7370
FoFA_20                        $de32  7385D  7363
FoFA_22                        $de47  7398D  7391
FoFA_24                        $de48  7401D  7393
FoFA_26                        $de53  7409D  7406
FoFA_28                        $de64  7420D  7415
FoFA_30                        $de66  7423D  7407
Format_Jiffyclock              $de68  7427D  4412
FoFA_32                        $de6a  7431D  7447   7451   7487
FoFA_34                        $de8e  7450D  7446
FoFA_36                        $de90  7453D  7448
FoFA_38                        $de97  7459D  7455
FoFA_40                        $deb2  7477D  7472
FoFA_42                        $dec4  7489D  7485
FoFA_44                        $dec6  7491D  7495
FoFA_46                        $ded3  7500D  7497
FoFA_48                        $dee3  7511D  7504
FoFA_50                        $deef  7519D  7522
FoFA_52                        $df04  7531D  7344
FoFA_54                        $df07  7534D  7503
FoFA_56                        $df0c  7538D  7529
Float_0_5                      $df11  7542D  6172   6172   7586   7586
NULL_Descriptor                $df13  7543D  3370   4775   4775
Decimal_Conversion_Table       $df16  7546D  4411   7434   7437   7440
                                      7443   7484   7486
Jiffy_Conversion_Table         $df3a  7560D  4411   7484
End_Of_Conversion              $df52  7570D  7486
Basic_SQR                      $df71  7582D  1857
Basic_POWER                    $df7b  7590D  1883
POW_10                         $df84  7598D  7595
POW_20                         $df9e  7611D  7603   7607
Basic_GREATER                  $dfb4  7624D  1886   7238   7706   8174
                                      8181   8234   8256
GREA_Ret                       $dfbe  7633D  7621   7628
REV_LOG_2                      $dfbf  7636D  7654   7654
VAR_EXP                        $dfc4  7638D  7707   7707
Basic_EXP                      $dfed  7651D  1860   7593   7618
EXP_10                         $dffd  7661D  7658
EXP_20                         $e008  7682D  7690
EXP_30                         $e00b  7685D  7680
EXP_40                         $e01b  7696D  7702
Square_And_Series_Eval         $e040  7716D  6515   8185   8246
Eval_Series_AY                 $e056  7728D  7708
Eval_Series                    $e05a  7734D  7723
EvSe_10                        $e069  7746D  7743
EvSe_20                        $e06d  7750D  7763
EvSe_30                        $e07a  7758D  7755
RND_VA                         $e08a  7766D  7795   7795
RND_VB                         $e08f  7767D  7797   7797
Basic_RND                      $e094  7770D  1858
RND_10                         $e0bb  7792D  7775
RND_20                         $e0d0  7800D  7774
RND_30                         $e0e0  7810D  7790
Go_Assign_FAC1_To_Var          $e0f3  7822D  8197
Error_Handler                  $e0f6  7828D  7850   7858   7873   7881
                                      7889   7935   8032
ErHa_10                        $e101  7837D  7832
ErHa_20                        $e106  7842D  7839
CHROUT_Checked                 $e109  7846D  3661
Read_Char                      $e10f  7854D  2438
Select_Output_Channel          $e115  7862D  3491
CHKIN_Checked                  $e11b  7877D  3708   3729
GETIN_Checked                  $e121  7885D  3820
Basic_SYS                      $e127  7893D  1841
SYS_Ret                        $e144  7911D  7898   7900
Basic_SAVE                     $e153  7926D  1831
Jiffy_SAVE                     $e156  7931
Basic_VERIFY                   $e162  7939D  1832
Basic_LOAD                     $e165  7946D  1830
LOAD_05                        $e17b  7959
LOAD_10                        $e187  7972D  7968
LOAD_20                        $e194  7979D  7975   8029
LOAD_30                        $e195  7982D  7957
LOAD_40                        $e19e  7988
LOAD_50                        $e1a1  7991D  7985
LOAD_55                        $e1a7  7996
LOAD_60                        $e1b5  8001D  7994
Basic_OPEN                     $e1bb  8013D  1842
Basic_CLOSE                    $e1c4  8023D  1843
Jump_Error_Handler             $e1ce  8031D  7955   8018
Get_Load_Save_Params           $e1d1  8035D  7929   7951
Get_Byte_Param                 $e1fd  8062D  8050   8055   8109   8120
Exit_On_EOS                    $e203  8069D  8047   8049   8054   8108
                                      8119   8126
EOE_Ret                        $e20a  8076D  8073   8090
Read_Comma_And_Byte            $e20b  8080D  8065   8127
Need_Byte                      $e20e  8086D  8099
Get_Open_Close_Params          $e216  8094D  8016   8026
GOCP_05                        $e226  8105
GOCP_10                        $e23c  8117D  8114
Set_Filename                   $e254  8130D  8048
Set_Filename_From_String       $e257  8135
Basic_COS                      $e261  8142D  1861
Basic_SIN                      $e268  8149D  1862   8194
SIN_10                         $e29a  8173D  8165   8212
SIN_20                         $e29d  8176D  8168
SIN_30                         $e2aa  8183D  8180
Basic_TAN                      $e2b1  8188D  1863
TAN_10                         $e2d9  8208D  8203
PI_Half                        $e2dd  8214D  8145   8145   8250   8250
Two_PI                         $e2e2  8215D  8153   8153
Float_0_25                     $e2e7  8216D  8161   8161   8177   8177
VAR_SIN                        $e2ec  8218D  8184   8184
Basic_ATN                      $e30b  8228D  1864
ATN_10                         $e313  8236D  8233
ATN_20                         $e321  8244D  8240
ATN_30                         $e334  8253D  8249
ATN_Ret                        $e33a  8258D  8255
VAR_ATN                        $e33b  8261D  8245   8245
Basic_Cold_Start               $e378  8296D  1803
CHRGET_ROM                     $e387  8315D  4380   4382   8327   8354
CHRO_10                        $e38d  8322D  8319
CHRO_Ret                       $e39e  8333D  8325
Init_BASIC_RAM_Vectors         $e3a4  8339D  8302
IBRV_10                        $e3c4  8353D  8357
IBRV_Ret                       $e403  8383D  8380
Print_Startup_Message          $e404  8387D  8303
Bytes_Free_Message             $e429  8404D  8400   8400
Start_Message                  $e436  8407D  8392   8392
Basic_Vectors                  $e44f  8417D  8452
Init_BASIC_Jump_Vectors        $e45b  8446D  8300
IBJV_10                        $e45d  8451D  8455
Basic_Warm_Start               $e467  8494D  1804
Rebuild_andRestore             $e476  8514D  8009
CLR_IEC_DAT                    $e4a0  8643D 10775  10794  10802  10931
                                     11126  11150
SET_IEC_DAT                    $e4a9  8653D 10927  11032  11187  11236
GET_IEC_CLK                    $e4b2  8660D  8665  10803  10817  10828
                                     10839  10970  11046  11144  11169
Get_SA_Print_Searching         $e4bc  8670D 12979
Set_Load_Address               $e4c1  8677D 13019
SLA_10                         $e4cc  8687D  8681
Close_Patch                    $e4cf  8691D 12508
ClPa_10                        $e4d7  8747D  8743
Kernal_IOBASE                  $e500  8755D 18408
Kernal_SCREEN                  $e505  8763D 18347
Kernal_PLOT                    $e50a  8771D 18377
PLOT_05                        $e50c  8776
PLOT_10                        $e513  8781D  8774
Initialise_Hardware            $e518  8787D 16449  16977
InHa_10                        $e536  8806D  8800
Clear_Screen                   $e55f  8826D  9514
ClSc_10                        $e568  8835D  8845
ClSc_20                        $e570  8842D  8839
ClSc_30                        $e57b  8850D  8853
Do_Home                        $e581  8856D  8920   9348
Adjust_Line                    $e587  8863D  8779   9254   9488   9541
Home_10                        $e58b  8867D  8874
Home_20                        $e597  8876D  8869
Home_30                        $e5a8  8891D  8897
Home_40                        $e5b2  8899D  8893
Set_Default_Devices            $e5bb  8923D  8790   8919
Init_VIC_Chip                  $e5c3  8932D 16661
IVC_Loop                       $e5c5  8937D  8941
Get_Char_From_Keyboard_Buffer  $e5cf  8945D  8990  11947
GCFK_Loop                      $e5d4  8951D  8956
Display_And_Get_Key            $e5e5  8964D  9007
Get_Key                        $e5e8  8970D  8976   9003   9054
GETK_10                        $e602  8986D  8979
GETK_20                        $e60e  8998D  9002
GETK_30                        $e619  9005D  8993
GETK_40                        $e621  9011D  9016
GETK_50                        $e62a  9018D  9014
CHRIN_Keyboard_Or_Screen       $e64f  9046D 11979  11991
Get_Screen                     $e657  9057D  9026   9035   9037   9042
GetS_05                        $e67e  9072D  9069
GetS_10                        $e684  9077D  9073
GetS_15                        $e688  9081D  9075   9078
GetS_20                        $e691  9087D  9043
GetS_25                        $e6a3  9098D  9093
GetS_30                        $e6a6  9101D  9096
GetS_35                        $e6a8  9104D  9085
GetS_40                        $e6b6  9115D  9112
If_Quote_Toggle_Flag           $e6b8  9120D  9083   9293
IQTF_Ret                       $e6c4  9130D  9124
Insert_Char                    $e6c5  9134D  9417
InsC_10                        $e6c7  9139D  9294
InsC_20                        $e6cb  9143D  9299   9338   9472
InsC_30                        $e6cd  9146D  9141
InsC_40                        $e6d3  9151D  9148
InsC_50                        $e6dc  9156D  9249   9367   9392   9464
                                      9505   9509   9517   9553  10496
                                     10516
InsC_60                        $e6e4  9163D  9160
Advance_Cursor                 $e6ea  9172D  9154
AdCu_10                        $e701  9186D  9183
Expand_Logical_Line            $e70e  9195D  9189   9790   9835
ELL_20                         $e715  9215D 10559
Set_Pointer_To_Start_Of_Logica $e719  9220D  9032   9226
SPTS_10                        $e720  9228D  9224
SPTS_20                        $e723  9231D  9181
SPTS_Ret                       $e72c  9237D  9179
Previous_Line                  $e72d  9241D  9306   9508
PreL_10                        $e737  9251D  9245
Screen_CHROUT                  $e742  9260D  8967   9099  12162
ScrO_02                        $e756  9276D  9273
ScrO_04                        $e75d  9281D  9278
ScrO_06                        $e769  9289D  9285
ScrO_08                        $e76b  9292D  9287
ScrO_10                        $e771  9296D  9283
ScrO_12                        $e778  9301D  9298
ScrO_14                        $e785  9309D  9305
ScrO_16                        $e78e  9315D  9326
ScrO_18                        $e79f  9328D  9307
ScrO_20                        $e7aa  9335D  9303
ScrO_22                        $e7b1  9340D  9337
ScrO_24                        $e7b7  9345D  9342
ScrO_26                        $e7be  9350D  9347
ScrO_28                        $e7d4  9363D  9378   9379
ScrO_30                        $e7d6  9366D  9358
ScrO_32                        $e7d9  9369D  9352
ScrO_34                        $e7ec  9382D  9386
ScrO_36                        $e7f4  9388D  9384
ScrO_38                        $e7f7  9391D  9333
ScrO_40                        $e7fa  9394D  9371
ScrO_42                        $e800  9398D  9274
ScrO_44                        $e81d  9406D  9404
ScrO_46                        $e82a  9419D  9416
ScrO_48                        $e831  9424D  9421
ScrO_50                        $e845  9436D  9432
ScrO_52                        $e84c  9441D  9434
ScrO_54                        $e851  9445D  9456
ScrO_56                        $e86d  9463D  9438
ScrO_58                        $e870  9466D  9428
ScrO_60                        $e874  9470D  9426
ScrO_62                        $e879  9474D  9468
ScrO_64                        $e88e  9487D  9483
ScrO_66                        $e893  9491D  9476
ScrO_68                        $e89b  9497D  9493
ScrO_70                        $e8ab  9507D  9501
ScrO_72                        $e8b1  9511D  9499
ScrO_74                        $e8b8  9516D  9478   9485   9489
ScrO_76                        $e8bb  9519D  9513
Do_Newline                     $e8c3  9525D  9233   9360   9389   9552
NewL_10                        $e8c7  9531D  9539
NewL_20                        $e8cf  9537D  9534
Screen_Return                  $e8d8  9544D  9279   9422
Test_Line_Dec                  $e8e8  9556D  9310   9502
TLD_10                         $e8ec  9562D  9568
TLD_20                         $e8f7  9571D  9564
Test_Line_Inc                  $e8fa  9576D  9175   9354
TLI_10                         $e8fe  9582D  9588
TLI_20                         $e909  9592D  9584
TLI_30                         $e911  9598D  9595
Set_Color                      $e912  9602D  9395   9521
SeCo_Loop                      $e914  9607D  9611
SeCo_10                        $e91d  9614D  9609
Color_Codes                    $e921  9618D  9605   9608
Color_Codes_End                $e929  9640D  9605
Scroll_Screen                  $e975  9653D  9190   9535   9786
ScSc_05                        $e981  9665D  9702
ScSc_10                        $e989  9671D  9680
ScSc_15                        $e99d  9682D  9675
ScSc_20                        $e9a2  9686D  9697
ScSc_25                        $e9ac  9693D  9690
ScSc_27                        $e9c1  9705
ScSc_30                        $e9d6  9749D  9752   9754
ScSc_40                        $e9df  9758D  9746
ScSc_45                        $e9e1  9761
Insert_Line                    $e9ee  9773D  9439
InsL_10                        $e9f0  9778D  9184   9781
InsL_20                        $ea08  9792D  9784   9785
InsL_30                        $ea16  9803D  9813
InsL_40                        $ea2c  9815D  9807   9808
InsL_50                        $ea31  9819D  9831
InsL_60                        $ea3f  9828D  9825
InsL_70                        $ea44  9833D  9821
Shift_Row                      $ea56  9853D  9679   9812
ShRo_10                        $ea60  9861
ShRo_20                        $ea62  9864D  9870
Update_Color_RAM_Pointer       $ea6e  9874D  9859
Start_Of_Line                  $ea7e  9892D  9229   9673   9805   9908
Clear_Screen_Row_X             $ea8d  9904D  8851   9683   9816
CSRX_Loop                      $ea95  9911D  9922
Display_Char_A_And_Color_X     $eaa1  9931D  8984   9153
Display_Char_And_Color         $eaaa  9941D  9988
Set_COLRAM_Pointer             $eab2  9951D  9313   9443   9877   9909
                                      9937   9980
Default_IRQ                    $eabf  9963D 16516  16682
DIRQ_10                        $eaea  9986D  9977
DIRQ_20                        $eaef  9990D  9968   9970
DIRQ_30                        $eb01 10052D 10037
DIRQ_40                        $eb0a 10065D 10050
DIRQ_50                        $eb12 10078D 10054  10072
Kernal_SCNKEY                  $eb1e 10096D 10079  17544
KeSc_05                        $eb40 10142D 10157  10196
KeSc_15                        $eb4a 10160D 10184
KeSc_20                        $eb60 10173D 10166  10168
KeSc_25                        $eb62 10176D 10171
KeSc_30                        $eb63 10179D 10162
KeSc_35                        $eb71 10198D 10182
KeSc_40                        $eb74 10207D 10331
KeSc_45                        $eb84 10217D 10212
KeSc_50                        $eb8f 10224D 10121
KeSc_55                        $eba1 10235D 10220  10227  10229  10231
KeSc_60                        $ebab 10241D 10237
KeSc_65                        $ebba 10250D 10215  10225
KeSc_70                        $ebd6 10265D 10221  10233  10239  10243
                                     10248  10256  10260  10278
Keyboard_Decoder               $ebdc 10271D  8810   8812
KeDe_10                        $ec0f 10308D 10276
KeDe_20                        $ec18 10319D 10311
KeDe_30                        $ec43 10330D 10280  10305
KBD_Decode_Pointer             $ec46 10363D 10326  10328
KBD_NORMAL                     $ec5e 10402D 10132  10134  10366  10390
KBD_SHIFTED                    $ec9f 10428D 10367  10391
KBD_CBMKEY                     $ece0 10454D 10368
Switch_Text_Graphics           $ed21 10481D  9396  10394
STG_10                         $ed30 10499D  9522  10485
STG_20                         $ed39 10512
STG_30                         $ed3c 10515D 10529  10534  10546
STG_40                         $ed3f 10518D 10501
STG_50                         $ed4d 10532D 10520
STG_60                         $ed56 10538
ELL_10                         $ed5b 10551D  9210
KBD_COMMCON                    $ed69 10588D 10392  10395  10396
KBD_CONTROL                    $eda3 10643D 10372  10393  10397
VIC_INIT                       $ede4 10657D  8938
RUNKEY                         $edf4 10717D  8999
Line_Adress_Low                $edfd 10720D  8885   9676   9809   9895
Kernal_TALK                    $ee14 10736D 12328  12985  17747
Kernal_LISTEN                  $ee17 10743D 12379  12768  13414  13452
                                     17722
IEC_Send_Control_Byte          $ee1c 10750D 11105
ISCB_10                        $ee2b 10766D 10755
ISCB_20                        $ee38 10781D 10778
IEC_Delay_And_Send_Byte        $ee40 10787D 11004  11025
IEC_Send_Byte                  $ee49 10798D 10761  11072
ISCB_30                        $ee5a 10816D 10821
ISCB_40                        $ee60 10827D 10832
ISCB_50                        $ee66 10838D 10810  10843
ISCB_60                        $ee73 10912D 10915  10944
ISCB_70                        $ee88 10930D 10926
ISCB_80                        $ee8b 10933D 10928
ISCB_90                        $eea5 10953D 10972
Device_Not_Present             $eeb4 10978D 10807
IEC_Timeout                    $eeb7 10985D 10924  10969
Set_IEC_Status                 $eeb9 10991D 11184
Kernal_SECOND                  $eec0 11000D 12386  12771  13416  13456
                                     17426
IEC_ATN_High                   $eec5 11007D 11033  11108  12382
Kernal_TKSA                    $eece 11021D 12335  12987  17456
IEC_Finish_Send                $eed3 11028D 12331
IFS_10                         $eedd 11036D 11051
Kernal_CIOUT                   $eee4 11058D 12172  12789  13420  13422
                                     13428  17648
KeCI_10                        $eeed 11067D 11062
KeCI_20                        $eef2 11076D 11065
Kernal_UNTLK                   $eef6 11082D 12606  13092  17669
Kernal_UNLSN                   $ef04 11101D 12601  12799  13443  13459
                                     17694
KeUN_10                        $ef09 11107D 10997
IEC_Delay_CLK_High_DATA_High   $ef0c 11111D 11193  11247
IDel_10                        $ef0f 11121D 11123
Kernal_ACPTR                   $ef19 11129D 12122  12988  12997  13050
                                     17613
KeAC_03                        $ef1c 11139
KeAC_05                        $ef21 11143D 11149
KeAC_10                        $ef29 11153D 11198
KeAC_15                        $ef2e 11157D 11176
KeAC_25                        $ef3c 11180D 11168
KeAC_30                        $ef45 11186D 11182
KeAC_35                        $ef54 11200D 11177
KeAC_40                        $ef58 11204D 11207  11215  11235
KeAC_45                        $ef66 11220D 11223  11231
KeAC_50                        $ef7f 11249D 11244
CLR_IEC_CLK                    $ef84 11256D 10779  10808  10934  11034
                                     11125  11141  16746
SET_IEC_CLK                    $ef8d 11265D 10793  10847  11089  16749
WAIT_1MS                       $ef96 11306D 10795
W1MS_20                        $ef9b 11324D 11327
RS232_NMI_Transmit             $efa3 11332D 17024
RTra_05                        $efb0 11343D 11340
RTra_10                        $efb9 11350D 11371  11373  11394
RTra_15                        $efbf 11356D 11348
RTra_20                        $efce 11365D 11377  11382  11386
RTra_25                        $efcf 11368D 11363  11381  11385
RTra_30                        $efda 11375D 11359
RTra_32                        $efde 11379D 11361
RTra_35                        $efe4 11384D 11360
RTra_40                        $efe8 11391D 11337
RS232_Setup_Next_Byte_To_Send  $efee 11397D 11336  11699
RSNB_10                        $effb 11414D 11402
RS232_No_DSR_Signal            $f016 11429D 11411  11641  12895
RNDS_10                        $f019 11435D 11412
RNDS_20                        $f021 11442D 11422
RS232_Set_Data_Bits            $f027 11462D 12832
RSDB_10                        $f031 11471D 11468
RSDB_20                        $f035 11476D 11472
RS232_NMI_Receive              $f036 11480D 17059
RRec_05                        $f04a 11494D 11507  11560  11564  11568
RRec_10                        $f04b 11497D 11559
RRec_15                        $f04d 11500D 11487
RRec_20                        $f05b 11509D 11528  11584
RRec_25                        $f068 11526D 11484
RRec_30                        $f06f 11538D 11486
RRec_35                        $f081 11548D 11553
RRec_40                        $f089 11555D 11550
RRec_45                        $f09d 11567D 11563
RRec_50                        $f0a2 11572D 11542
RRec_55                        $f0a5 11576D 11589
RRec_60                        $f0a8 11580D 11588
RRec_65                        $f0b3 11586D 11502
RRec_70                        $f0b9 11591D 13245  13510
RS232_CHKOUT                   $f0bc 11597D 12365
RCHO_10                        $f0cd 11609D 11618
RCHO_20                        $f0d4 11620D 11622
RCHO_30                        $f0e1 11627D 11630
RS232_Set_Status_No_Signal     $f0e8 11633D 11606  11714
RSSN_10                        $f0eb 11643D 11603  11607  11629
RS232_Put_Byte_To_Buffer       $f0ed 11648D 11659  12289
RPBB_20                        $f0fc 11667
RPBB_30                        $f102 11681D 11677
RS232_CHKIN                    $f116 11703D 12313
RCHI_10                        $f12b 11717D 11725
RCHI_20                        $f138 11731D 11734
RCHI_30                        $f13f 11736D 11759
RCHI_50                        $f144 11751D 11715
RCHI_40                        $f146 11756D 11709  11711
RS232_Get_Byte_From_Buffer     $f14f 11765D 11958
RGBB_10                        $f15d 11782D 11773
RS232_Stop                     $f160 11791D 10747  15474
RSTP_20                        $f166 11808D 11811
RSTP_30                        $f172 11820D 11806
Msg_Start                      $f174 11824D 11921  13337  13341  13363
                                     13366  13551  15208  15359  15368
                                     15398
Msg_Searching                  $f180 11825D 13337
Msg_FOR                        $f18b 11826D 13341
Msg_Play                       $f18f 11901D 15359
Msg_Record                     $f1a2 11902D 15398
Msg_Loading                    $f1bd 11904D 13363
Msg_Saving                     $f1c5 11905D 13551
Msg_Verifying                  $f1cd 11906D 13366
Msg_Found                      $f1d7 11907D 15208
Msg_ok                         $f1de 11908D 15368
Display_Direct_Msg             $f1e2 11911D 13369
Display_Kernal_IO_Message      $f1e6 11918D 11927  13338  13342  13552
                                     13686  15209  15362  15369
DDM_10                         $f1f3 11929D 11915
Kernal_GETIN                   $f1f5 11934D 16527
KeGE_10                        $f201 11949D 11938
RS232_Get_Byte                 $f205 11954D 12129
KeGE_20                        $f20c 11961
Kernal_CHRIN                   $f20e 11966D 16524
CHRI_05                        $f21d 11983D 11951  11973
CHRI_07                        $f221 11987
CHRI_10                        $f22a 11993D 11985
CHRI_15                        $f244 12065D 12061
CHRI_20                        $f24a 12073D 12060
CHRI_25                        $f24d 12077D 12057
TAPE_Get_Byte                  $f250 12082D 12056  12059  12091
TGB_05                         $f260 12093D 12086
IEC_Get_Byte                   $f264 12103D 11994
IGB_10                         $f268 12109
IGB_20                         $f26a 12112D 11944
IGB_30                         $f26b 12115D 12088
IGB_40                         $f26c 12118D 12107
RS232_Read_Byte                $f26f 12126D 11999  12143
RRB_Ret                        $f279 12146D 12134
Kernal_CHROUT                  $f27a 12151D 16525
KeCO_10                        $f285 12166D 12157
KeCO_20                        $f28b 12176D 12167
TAPE_Send_Byte                 $f290 12190D 12499
TASB_10                        $f2aa 12242D 12233
TASB_20                        $f2ae 12247
TASB_30                        $f2af 12259D 12235
TASB_40                        $f2b8 12274D 12270
RS232_Send_Byte                $f2b9 12278D 12182
Kernal_ICHKIN                  $f2c7 12297D 16521
KICH_10                        $f2cf 12304D 12301
KICH_20                        $f2e3 12315D 12312
KICH_30                        $f2ec 12321D 12307  12309  12318  12340
KICH_40                        $f2f0 12326D 12310
KICH_50                        $f2fe 12334D 12330
KICH_60                        $f301 12337D 12332
Kernal_CHKOUT                  $f309 12344D 16522
KCHO_10                        $f311 12351D 12348
KCHO_20                        $f318 12356D 12370
KCHO_30                        $f31b 12359D 12354
KCHO_40                        $f328 12367D 12364
KCHO_50                        $f32e 12372D 12361  12391
KCHO_60                        $f332 12377D 12362
KCHO_70                        $f33f 12385D 12381
KCHO_80                        $f342 12388D 12383
Kernal_CLOSE                   $f34a 12395D 16520
KeCL_10                        $f351 12403D 12399
KeCL_20                        $f37f 12432D 12429
KeCL_30                        $f384 12437D 12434
KeCL_40                        $f38d 12443D 12413
KeCL_50                        $f39e 12509D  8748
KeCL_60                        $f3a0 12513
KeCL_70                        $f3ae 12522D 12411
KeCL_80                        $f3b1 12525D 12408  12410  12493  12516
                                     12519
Close_File                     $f3b2 12529D 12415
ClFi_05                        $f3b3 12534
ClFi_10                        $f3cd 12546D 12537
ClFi_Ret                       $f3ce 12549D 12510
Find_File_X                    $f3cf 12553D 12300  12347  12623
Find_File_A                    $f3d4 12561D 12398
FiFi_10                        $f3d6 12566D 12570
Get_LFS                        $f3df 12574D 12305  12352  12404
GLFS_Ret                       $f3ee 12584D 12568
Kernal_CLALL                   $f3ef 12588D 16528
Kernal_CLRCHN                  $f3f3 12595D 16523
KeCC_10                        $f3fc 12603D 12600
KeCC_20                        $f403 12608D 12605
Kernal_OPEN                    $f40a 12615D 16519
OPEN_05                        $f411 12622D 12619
OPEN_10                        $f419 12627D 12624
OPEN_15                        $f422 12633D 12630
OPEN_20                        $f444 12650D 12646
OPEN_25                        $f44b 12666D 12656
OPEN_30                        $f453 12672D 12668
OPEN_35                        $f46c 12710D 12717
OPEN_40                        $f46f 12713D 12705
OPEN_45                        $f478 12719D 12700
OPEN_50                        $f482 12725D 12707  12716
OPEN_55                        $f491 12736D 12729
OPEN_60                        $f493 12739D 12643  12645  12648
OPEN_Ret                       $f494 12742D 12702  12708  12715  12721
IEC_Send_SA_And_Filename       $f495 12746D 12647  12983  13411
Pop_Dev_Not_Present            $f4ad 12775
Jmp_Dev_Not_Present            $f4af 12779
ISSF_10                        $f4b2 12782D 12773
ISSF_20                        $f4b8 12787D 12792
ISSF_30                        $f4c2 12794D 12784
ISSF_40                        $f4c5 12800D 12754  12761
RS232_Open                     $f4c7 12806D 12658
ROPN_05                        $f4d9 12822D 12829
ROPN_10                        $f4e7 12831D 12824
ROPN_15                        $f4f4 12843D 12840
ROPN_35                        $f51b 12898D 12882  12890
ROPN_40                        $f533 12910D 12905
ROPN_45                        $f53c 12917D 12441  12912
Kernal_LOAD                    $f542 12938D 18157
Default_LOAD                   $f549 12945D 16541
DLOA_05                        $f553 12954D 12959
DLOA_10                        $f556 12957D 12952
DLOA_15                        $f563 12973D 12966
DLOA_25                        $f58a 13023D 13055  13089
DLOA_30                        $f598 13049D 13046
DLOA_35                        $f5b3 13078D 13058
DLOA_40                        $f5b5 13082D 13073
DLOA_45                        $f5bb 13087D 13084
DLOA_47                        $f5bf 13091
DLOA_50                        $f5c7 13100D 12993  13264  13269
DLOA_55                        $f5ca 13103D 12963
DLOA_60                        $f5d1 13248D 13244
DLOA_65                        $f5d9 13253D 13250
DLOA_70                        $f5e1 13258D 13279
DLOA_75                        $f5ee 13266D 13260
DLOA_80                        $f5f5 13271D 13262
DLOA_85                        $f604 13281D 13292
DLOA_90                        $f611 13290D 13277
DLOA_92                        $f615 13294D 13288
DLOA_94                        $f641 13321D 13097
DLOA_95                        $f642 13324
DLOA_Ret                       $f646 13328D 13255  13263  13268  13275
Print_Searching                $f647 13332D  8674  12703  13256
PrSe_10                        $f659 13344D 13553
PrSe_20                        $f65f 13349D 13354
PrSe_Ret                       $f669 13356D 13336  13340  13346
Display_LOADING_Or_VERIFYING   $f66a 13360D  8688  13316
DLV_10                         $f672 13368D 13365
Kernal_SAVE                    $f675 13372D 18193
Default_SAVE                   $f685 13385D 16542
SAVE_10                        $f689 13391D 13396  13515
SAVE_20                        $f68c 13394D 13389
Jmp_Missing_Filename           $f69a 13407
SAVE_30                        $f69d 13410D 13405
SAVE_40                        $f6bc 13424D 13440
SAVE_50                        $f6cb 13432D 13047
SAVE_60                        $f6d2 13438D 13430
SAVE_70                        $f6d7 13442D 13426
IEC_Close                      $f6da 13446D 12523  13093  13433
IClo_10                        $f6ec 13458
IClo_20                        $f6ef 13461D 13450
IClo_30                        $f6f1 13501D 13400
IClo_40                        $f6f8 13513D 13509
IClo_50                        $f70f 13525D 13522
IClo_60                        $f726 13539D 13533
IClo_Ret                       $f727 13542D 13517  13528  13530  13550
Display_SAVING_Filename        $f728 13546D 13412  13518
Kernal_UDTIM                   $f734 13556D 15533  16961  18330
UDTI_10                        $f740 13566D 13561  13563
Look_For_Special_Keys          $f755 13580D 13574  13585
LFSK_20                        $f75d 13601
LFSK_Ret                       $f75f 13604
Kernal_RDTIM                   $f760 13608D 18240
Kernal_SETTIM                  $f767 13617D 18221
Kernal_STOP                    $f770 13628D 16526
STOP_Ret                       $f77d 13644D 13638
Too_Many_Files                 $f77e 13647D 12631
File_Already_Open              $f781 13651D 12625
File_Not_Open                  $f784 13655D 12302  12349
File_Not_Found                 $f787 13659D 12711  13101
Dev_Not_Present                $f78a 13663D 12341  12392  12780
Not_Input_File                 $f78d 13667D 12319  12620
Not_Output_File                $f790 13671D 12357
Missing_File_Name              $f793 13675D 12970  13408
Illegal_Jiffy_Device           $f796 13679D 11593  12669  12955  13251
                                     13392
DIOR_10                        $f7ac 13692D 13685
Jiffy_RTS                      $f7ae 13696
TAPE_Find_Any_Header           $f7af 15184D 12714  13267  15202  15318
TFAH_10                        $f7ce 15204D 15198  15200
TFAH_20                        $f7da 15212D 15217
TFAH_30                        $f7e4 15224D 15207
TFAH_Ret                       $f7e6 15228D 15192  15196
TAPE_Write_Header              $f7e7 15232D 12518  12723  13527  13535
TWH_10                         $f7fe 15243D 15246
TWH_20                         $f822 15266D 15275
TWH_30                         $f834 15277D 15269
TWH_Ret                        $f84c 15287D 15237
TAPE_Get_Buffer_Address        $f84d 15291D 12494  12667  13249  13514
                                     15236  15302  15347
TAPE_Set_Buffer_Pointer        $f854 15299D 15278  15408  15437
TAPE_Find_Fileheader           $f867 15315D 12706  13261  15331
TFF_10                         $f874 15325D 15335
TFF_20                         $f888 15337D 15327
TFF_Ret                        $f889 15340D 15319
TAPE_Advance_Buffer_Pointer    $f88a 15344D 12085  12232
Wait_For_Play                  $f894 15354D 12701  13254  15414
WFP_10                         $f89b 15361D 15399
WFP_20                         $f89e 15364D 15367
TAPE_Sense                     $f8ab 15372D 15357  15366  15396
TASe_10                        $f8b5 15388D 15358  15384  15397
TAPE_Wait_For_Record           $f8b7 15393D 12720  13516  15450
TAPE_Init_Read                 $f8c0 15402D 12087  15189
TAPE_Read                      $f8c9 15411D 13317
Init_Tape_Write                $f8e3 15434D  8742  12234
TAPE_Write_With_Lead           $f8e6 15440D 13529
TAPE_Write                     $f8ea 15447D 15281
TAWR_10                        $f8ed 15452D 15415
TAWR_20                        $f8f4 15463D 15431
TAWR_30                        $f923 15506D 15513
TAWR_40                        $f925 15509D 15511
TAWR_50                        $f92f 15519D 15531  15535
TAPE_Abort_On_STOP             $f94b 15538D 15365  15524
Clear_Saved_IRQ_Address        $f957 15550D 15453  15523
CSIA_Ret                       $f95c 15556D 15543
TAPE_Set_Timer                 $f95d 15560D 15759  15801  15828  15877
TST_10                         $f972 15577D 15574
TST_20                         $f979 15584D 15592
TAPE_Read_IRQ                  $f98e 15647D 15655  16683
TARI_02                        $f9c3 15685D 15682
TARI_04                        $f9e2 15703D 15687  15755
TARI_06                        $f9e5 15706D 15701  15761  15782
TARI_08                        $f9ed 15712D 15692
TARI_10                        $f9f1 15716D 15697  15817
TARI_12                        $f9f3 15719D 15714
TARI_14                        $fa06 15731D 15680  15708  15710  15784
                                     15786  15788
TARI_18                        $fa19 15757D 15797
TARI_20                        $fa22 15763D 15733  15746  15795
TARI_22                        $fa25 15766D 15728
TARI_24                        $fa2e 15773D 15769
TARI_26                        $fa30 15776D 15768
TARI_28                        $fa47 15790D 15754  15780
TARI_30                        $fa60 15804D 15704
TARI_32                        $fa68 15810D 15806
TARI_34                        $fa6c 15820D 15808
TARI_36                        $fa91 15846D 15831
TARI_38                        $faa0 15860D 15849
TARI_40                        $faaa 15867D 15833
TAPE_Store_Char                $faad 15871D 15683
TASC_10                        $fabd 15882D 15879
TASC_20                        $fad3 15895D 15887
TASC_30                        $fad7 15899D 15890  15893  15906  15908
                                     15923  15929  15934
TASC_40                        $fada 15902D 15885
TASC_50                        $faf0 15916D 15912
TASC_60                        $faf6 15921D 15904
TASC_62                        $fb07 15931D 15913  15917
TASC_64                        $fb0d 15936D 15903
TASC_65                        $fb11 15940
TASC_66                        $fb1b 15946D 15938
TASC_68                        $fb23 15951D 15948
TASC_70                        $fb38 15964D 15956  15960
TASC_72                        $fb55 15980D 15954
TASC_74                        $fb7c 16001D 15993
TASC_76                        $fb80 16005D 15969
TASC_78                        $fb87 16010D 15966  15978  16003
TASC_80                        $fb90 16017D 15983  15986  15989  15997
                                     16008  16012
TASC_82                        $fb95 16021D 15949
TASC_84                        $fb97 16024D 15944
TASC_86                        $fba0 16037D 16034
TASC_88                        $fbac 16045D 16039
TASC_90                        $fbb6 16051D 16057
TASC_92                        $fbcf 16064D 16019  16041  16043  16060
Set_IO_Start                   $fbd2 16068D 13418  15926  16047  16326
TAPE_New_Byte_Setup            $fbdb 16077D 15487  15874  16241  16317
TAPE_Write_Bit                 $fbea 16090D 16203
TAPE_Timer_Bit_Is_1            $fbf1 16106D 16193
TAPE_Write_Timer               $fbf3 16112D 16103  16313
TAPE_Start_Timer               $fbf5 16118D 16171
TAST_10                        $fc06 16142D 16269
TAPE_Write_IRQ                 $fc0b 16153D 16681
TAWI_05                        $fc21 16186D 16164
TAWI_10                        $fc2e 16202D 16188
TAWI_15                        $fc47 16223D 16150  16172  16180  16194
                                     16196  16204  16234  16262  16273
                                     16284
TAWI_20                        $fc4a 16229D 16208
TAWI_25                        $fc54 16240D 16332
TAWI_30                        $fc6a 16260D 16257
TAWI_35                        $fc6e 16266D 16244
TAWI_40                        $fc7d 16277D 16268
TAWI_45                        $fc8c 16288D 16233
TAWI_50                        $fc92 16293D 16309  16314  16316  16319
                                     16375
TAWI_55                        $fc95 16298D 16181
TAWI_60                        $fc9c 16303D 16300
TAPE_Write_Leader              $fca8 16311D 16680
Restoring_After_STOP           $fccf 16335D 15544  16046  16374
RAS_10                         $fcf4 16366D 16361
Reset_TAPE_IRQ                 $fcf6 16371D 16325
TAPE_Set_IRQ_Vector            $fcfb 16378D 15484  16308  16321
TAPE_Stop_Motor                $fd08 16388D 16301  16345
Check_IO_End                   $fd11 16405D 13425  15947  16056  16267
Inc_SAL_Word                   $fd1b 16416D 13439  16018  16055  16283
ISW_Ret                        $fd21 16422D 16420
Entry_RESET                    $fd22 16426D 18418
HARE_10                        $fd2f 16437D 16434
Scan_Autostart_Signature       $fd3f 16455D 16433  16949
SAAS_Loop                      $fd41 16460D 16465
SAAS_Exit                      $fd4c 16467D 16463
ROM_SIG                        $fd4d 16474D 16461
Kernal_RESTOR                  $fd52 16478D 16447  16975  17314
Kernal_VECTOR                  $fd57 16486D 17363
KeVE_10                        $fd5d 16492D 16509
KeVE_20                        $fd64 16503D 16499
KeVe_30                        $fd66 16506
Kernal_Vectors                 $fd6d 16513D 16481  16482
Init_RAM                       $fd8d 16551D 16446
InRA_10                        $fd90 16565D 16571
InRA_50                        $fdaf 16623D 16632  16653  16658
InRA_55                        $fdb5 16628D 16625
InRA_60                        $fdcf 16642D 16650
InRA_65                        $fdd2 16645D 16638
InRA_70                        $fdde 16652D 16631
InRA_75                        $fdeb 16660D 16636  16662
TAPE_IRQ_Vectors               $fdf1 16665D 16381  16383
Initialise_IO                  $fdf9 16687D 16448  16976
Program_Timer_A                $fe39 16753D 16359
Kernal_SETNAM                  $fe49 16790D 17866
Kernal_SETLFS                  $fe50 16799D 17833
Kernal_READST                  $fe57 16808D 17788
Kernal_SETMSG                  $fe66 16834D 17395
Get_Status                     $fe68 16839D 16813
Ora_Status                     $fe6a 16843D 10994  11196  12063  13075
                                     15892  15942  16007  16062
Kernal_SETTMO                  $fe6f 16851D 17578
Kernal_MEMTOP                  $fe73 16858D 17483
Read_Memtop                    $fe75 16864D 12427  12903
Set_memtop                     $fe7b 16871D 12920  16643  16861
Kernal_MEMBOT                  $fe82 16879D 17519
MEM_10                         $fe8a 16891D 16882
Test_RAM_byte                  $fe91 16897D 16629
Exit_No_RAM                    $fea4 16912D 16905  16909
Entry_NMI                      $fea9 16920D 18417
Default_NMI                    $fead 16927D 16518
NMI_10                         $fec7 16953D 16950
Default_BRK                    $fed2 16972D 16517  16529
RS232_NMI                      $fede 16981D 16947
Mfe9d                          $fefc 17023
JMP_Exit_IRQ                   $feff 17026D 16943  16968
NMI_20                         $ff02 17034D 17015
NMI_30                         $ff2c 17068D 17042
NMI_40                         $ff38 17080D 17078
Bfeb6                          $ff56 17096D 17071
Exit_IRQ                       $ff56 17104D 15764  15802  15868  15900
                                     16065  16224  16294  17031  17065
Baudrate                       $ff5c 17115D 12867  12870  17083  17085
Entry_IRQ                      $ff72 17236D 18419
BFF82                          $ff82 17249D 17247
RESTOR                         $ff8a 17296
VECTOR                         $ff8d 17317
SETMSG                         $ff90 17366D  2266   3070
SECOND                         $ff93 17398
TKSA                           $ff96 17429
MEMTOP                         $ff99 17459D  8373
MEMBOT                         $ff9c 17486D  8370
SCNKEY                         $ff9f 17522
SETTMO                         $ffa2 17547
ACPTR                          $ffa5 17581
CIOUT                          $ffa8 17617
UNTLK                          $ffab 17651
UNLSN                          $ffae 17672
LISTEN                         $ffb1 17697
TALK                           $ffb4 17725
READST                         $ffb7 17750D  3767   4468   7961   7983
SETLFS                         $ffba 17791D  8045   8053   8059   8107
                                      8118   8125
SETNAM                         $ffbd 17836D  8039   8098   8139
OPEN                           $ffc0 17869D  8017
CLOSE                          $ffc3 17905D  8028
CHKIN                          $ffc6 17932D  7880
CHKOUT                         $ffc9 17971D  7870
CLRCHN                         $ffcc 18008D  2232   3739   8497  13640
                                     13682
CHRIN                          $ffcf 18036D  7857
CHROUT                         $ffd2 18088D  7849  11924  13351  13690
                                     15214
LOAD                           $ffd5 18125D  7954
SAVE                           $ffd8 18160D  7934
SETTIM                         $ffdb 18196D  3404
RDTIM                          $ffde 18224D  4452
STOP                           $ffe1 18243D  3002  13045  13429  15541
                                     16963
GETIN                          $ffe4 18270D  7888
CLALL                          $ffe7 18297D  2654
UDTIM                          $ffea 18314D  9966
SCREEN                         $ffed 18333
PLOT                           $fff0 18350D  3563   3584   5252
IOBASE                         $fff3 18380D  7776
C64                            $0000     5D     6    418   1550   1582
                                      1609   1797   2050   2793   3038
                                      3569   7572   7663   7669   7865
                                      7964   8004   8277   8306   8419
                                      8458   8519   8877   8905   9028
                                      9200   9629   9707   9837   9882
                                      9912   9926  10013  10028  10041
                                     10056  10067  10081  10123  10137
                                     10145  10153  10187  10199  10288
                                     10404  10430  10456  10487  10503
                                     10524  10541  10563  10723  10769
                                     10790  10864  10888  10917  10954
                                     11011  11038  11047  11085  11115
                                     11145  11158  11171  11189  11209
                                     11225  11238  11273  11309  11404
                                     11444  11512  11530  11610  11636
                                     11651  11662  11668  11686  11718
                                     11738  11768  11774  11783  11795
                                     11815  11829  11940  12130  12137
                                     12177  12203  12207  12264  12281
                                     12416  12460  12484  12496  12500
                                     12750  12757  12763  12795  12809
                                     12836  12846  12883  12891  12922
                                     12974  13000  13176  13196  13214
                                     13225  13237  13502  13586  13632
                                     13865  14114  14129  14139  14149
                                     14157  14356  14363  14371  14379
                                     14500  14515  14536  14615  14635
                                     14718  14755  14814  14823  14934
                                     14986  15163  15218  15375  15424
                                     15455  15467  15475  15488  15494
                                     15525  15586  15598  15660  15735
                                     15750  15812  15837  15852  16026
                                     16123  16133  16144  16174  16329
                                     16340  16347  16391  16438  16470
                                     16553  16577  16667  16690  16756
                                     16815  16820  16935  16957  16964
                                     16984  17027  17036  17043  17061
                                     17072  17098  17118  17163  17252
                                     18410
VIC                            $0001     6D    80    692   1360   1613
                                      1800   2053   2797   3041   3572
                                      7575   7672   7869   7967   8008
                                      8310   8403   8427   8492   8595
                                      8791   8880   8901   9031   9036
                                      9062   9209   9399   9407   9644
                                      9712   9840   9885   9917  10017
                                     10032  10045  10060  10070  10084
                                     10126  10156  10192  10282  10293
                                     10302  10313  10320  10333  10369
                                     10375  10416  10442  10468  10492
                                     10507  10527  10544  10587  10729
                                     10804  10818  10829  10840  10870
                                     10892  10905  10920  10966  11014
                                     11050  11118  11148  11175  11192
                                     11213  11229  11242  11320  11407
                                     11454  11519  11533  11592  11614
                                     11640  11675  11696  11723  11747
                                     11755  11804  11863  11887  11943
                                     12133  12144  12180  12193  12195
                                     12248  12267  12285  12419  12507
                                     12753  12760  12798  12812  12839
                                     12866  12886  12894  12978  13015
                                     13094  13115  13147  13179  13204
                                     13218  13228  13233  13242  13497
                                     13507  13635  13869  14122  14132
                                     14143  14152  14161  14359  14366
                                     14374  14509  14518  14571  14669
                                     14725  14868  14948  14978  15049
                                     15167  15381  15427  15458  15491
                                     15498  15514  15528  15589  15676
                                     15744  15816  15840  15855  16129
                                     16136  16147  16177  16350  16353
                                     16396  16445  16473  16493  16562
                                     16615  16673  16715  16771  16895
                                     16941  16954  16960  16967  17007
                                     17030  17039  17046  17064  17075
                                     17131  17291  18263  18413
INDEXA                         $0022   824D  2115   2125   2133   2163
                                      2165   2229   2231   2240y  2308
                                      2310   2335   2337   2341y  2345
                                      2401   2401   2406y  2412y  2416
                                      2419y  2420   2423y  2424   2425
                                      2876   2876   3289   3305   3307
                                      3310   3410y  3631y  4108   4110
                                      4178   4179   4181   4194   5049
                                      5139   5178   5552   5552   5564
                                      5564   5592   5592   5594y  5597y
                                      5600y  5604y  5612y  5616   5617
                                      5619   5622   5638y  5641y  5662y
                                      5665y  5668y  5685   5685   5693
                                      5694   5696   5699   5783   5783
                                      5795y  5830   5830   5834y  5837y
                                      5840y  5860   5860   5924   5925
                                      5927   6018y  6061   6064   6066
                                      6602   6602   6604y  6607y  6610y
                                      6613y  6621y  6829   6829   6831y
                                      6834y  6837y  6840y  6845y  6876
                                      6876   6879y  6882y  6885y  6890y
                                      6893y  7777   7777   7779y  7782y
                                      7785y  7788y  8137   8138
FAC1M3/FAC1M4                  $0064   965D  3352   3401   3426y  3431y
                                      3440   3445   3451y  4190   4190
                                      4302   4375   4381   4393   4393
                                      4425y  4428y  4453   4475   4475
                                      4494   4494   4531   4544   4865
                                      4926   5109   5136   5388   5388
                                      5477   5477   5741   5741   5748y
                                      5824   5824   6045   6116   6266
                                      6291   6294   6320   6322   6335
                                      6359   6384   6386   6402   6546
                                      6744   6778   6820   6835   6881
                                      7005   7057   7138   7436   7438
                                      7783   7806   7808    966D  3261
                                      3355   3403   3436   3446   4299
                                      4377   4383   4455   4534   4539
                                      4866   4928   5111   5142   5949
                                      5967   5969   6047   6117   6263
                                      6293   6296   6317   6319   6334
                                      6360   6387   6389   6400   6544
                                      6747   6775   6822   6832   6878
                                      7004   7063   7128   7139   7432
                                      7435   7789   7801   7803
TXTPTR                         $007a   996D  2279   2279   2461   2497
                                      2552   2566   2568   2700   2703
                                      2861   2863   2900   2900   2908y
                                      2911y  2918y  2921y  2924   2925
                                      2927   3018   3018   3057   3057
                                      3085   3085   3110   3111   3124
                                      3127   3159   3159   3175   3176
                                      3178   3208y  3693   3693   3812
                                      3812   3815   3815   3836   3836
                                      3845   3864   3864   3889   3889
                                      3892   3892   3905y  3908y  3911y
                                      3999   4001   4058   4060   4063
                                      4135   4137   4140   4279   4279
                                      4348y  5294   5294   5336   5336
                                      5338   5341   5350   5350   6059
                                      6059   6062   6067   6089   6089
                                      7287y  7973   7992   8318   8320
TMPPTC                         $005f   958D  2114   2118   2307y  2311
                                      2313   2315y  2323   2326   2384y
                                      2582   2582   2583y  2588y  2597y
                                      2603y  2606y  2741y  2748y  2751y
                                      2780y  2783y  2786y  2787   2788
                                      3122   3125   4718   4721   4729y
                                      4733y  4739   4798   4798   4814y
                                      4817y  4820y  4822y  4824y  4826y
                                      4828y  4831   4834   4849   4850
                                      4946   4947   4955y  4960y  4965y
                                      4967   4970y  4971   4997y  5008y
                                      5015y  5026y  5042y  5045y  5082
                                      5084y  5087   5088y  5099y  5112y
                                      5117y  5179y  5182y  5549   5549
                                      5676   5679   5683   5684   5716
                                      5718   7190   7199   7207   7208
                                      7242   7275
FAC1M1/FAC1M2                  $0062   963D  2873   2874   4191   4191
                                      4457   4571   4605y  5242   5396
                                      5414   5414   5472   5890y  6272
                                      6287   6290   6326   6328   6337
                                      6357   6378   6380   6406   6550
                                      6738   6784   6816   6843   6889
                                      6986   6995   7049   7106   7107
                                      7108   7136   7312   7442   7444
                                      7780   7802   7804    964D  3402
                                      4454   4572   5243   5397   5474
                                      6269   6289   6292   6323   6325
                                      6336   6358   6381   6383   6404
                                      6548   6741   6781   6818   6838
                                      6884   6988   7053   7137   7313
                                      7439   7441   7786   7805   7807
JIFFY                          $0000     8D   829   1144   8042   8297
                                      8408   8420   8428   8436   8467
                                      8520   8596   8694   8987   9706
                                      9727   9991  10283  10297  10302
                                     10314  10321  10333  10369  10376
                                     10589  10758  10772  10858  11037
                                     11069  11088  11094  11132  11828
                                     11970  12003  12119  12193  12206
                                     12248  12444  12651  12660  12674
                                     12960  12967  12994  13009  13016
                                     13024  13062  13094  13104  13233
                                     13397  13465  13699  16493  16666
                                     17610  18263
STRPTR/FAC1M5                  $006f   983D  3454   3454   4225   5413
                                      5413   5419y  5436   5438   5444
                                      5452   5452   5744   5744   5746y
                                      5759   5759   5769y  5772y  5775y
                                      6189   6249   6616   6652   6688
                                      6710   7264   7710   8159    988D
                                      4398   5478   6211   6238   6244
                                      6260   6295   6297   6316   6333
                                      6361   6390   6392   6393   6429
                                      6448   6542   6590   6800   6847
                                      6894   6915   6935   6946   7011
                                      7061   7121   7656   7704   7814
FAC1EX                         $0061   962D  2194   3229   3376   3456
                                      3456   4192   4228   4570   4580
                                      4584   4890   5398   5434   5470
                                      6112   6190   6223   6226   6233
                                      6251   6308   6342   6346   6355
                                      6503   6507   6623   6638   6647
                                      6690   6728   6729   6731   6846
                                      6892   6912   6931   6944   6961
                                      7010   7045   7080   7093   7117
                                      7127   7265   7342   7627   7678
                                      7698   7699   7813   7816   8237
TMPPTD                         $0071   990D  2493   2514   3380   3383
                                      3384   3394   4408   5005   5021
                                      5047   5048   5066   5067   5077
                                      5102   5105   5130   5131   5143
                                      5146   5202   5203   5437   5443
                                      6060   6060   6088   6088   7339
                                      7410   7421   7466   7478   7490
                                      7719   7719   7731   7731   7738y
                                      7740   7744   7747   7748   7752
                                      7752   7759   7759
INDEXB/FAC3                    $0024   825D  2312   2319   2331   2342y
                                      2346   3977   6065   6072   6074y
                                      6077y  6082y  7026   7036   7038y
                                      7042y  7047y  7052y  7056y  7062y
                                       827D  5159   5180   5188   5207
                                      5210   6422   6538   6539   6540
                                      6541   6572   6574   6575   6577
                                      6578   6580   6581   6583   6586
                                      6587   6588   6589   6754   6815
                                      6817   6819   6821
FAC1SI                         $0066   967D  2871   3377   3983   4169
                                      4224   4588   4596   4881   6110
                                      6185   6187   6228   6311   6370
                                      6372   6615   6653   6660   6841
                                      6887   6907   6965   7012   7019
                                      7043   7069   7084   7104   7122
                                      7123   7263   7332   7338   7629
                                      7631   7812   8163   8167   8201
                                      8231
FORPNT                         $0049   911D  2077   2080   2082   2087
                                      2761   2766   2819   2891   2891
                                      3138   3330   3330   3353y  3356y
                                      3369   3463y  3466y  3469y  3811
                                      3811   3960   3960   3984   3985
                                      6149   6156   6161   6162   6869
                                      6869   8027   8052   8058   8101
                                      8110   8112   8123   8124
TMPPTA                         $0058   949D  2132   2134   2136   2141y
                                      2147y  2151   2359   2365   4807
                                      4807   4809   4809   4855   4855
                                      5052   5054   5057   5072y  5076
                                      5079   5163   5166   5577   5577
                                      5582   5582   5601   5602   5605
                                      5606   5625   5627   5722   5722
                                      5726   5729   5730
FUNCPT                         $004e   925D  5307   5307   5315   5315
                                      5318   5318   5320y  5324y  5337y
                                      5340y  5344   5344   5355y  5358y
                                      5361y  5364y  5367y  5546   5547
                                      5686   5686   5707   5708   5715y
                                      5727y  5732y  7599   7600   7605
                                      7605   7616   7616   8195   8196
                                      8204   8204
EAL                            $00ae  1086D  8683   8685   9660   9662
                                      9763   9765   9797   9799   9842
                                      9844   9867y  9879   9888  12989
                                     12999  13061y 13079y 13083  13085
                                     13308  13311  13325  13326  13375
                                     13376  15239  15239  15256  15259
                                     15283  15283  15307  15311  16410
                                     16412
SAL                            $00ac  1085D  9656   9658   9677   9767
                                      9769   9793   9795   9810   9846
                                      9848   9858   9865y  9878   9880
                                     13419  13421  13427y 15959y 15971
                                     15973  15984  15987  15996y 16015y
                                     16052y 16071  16073  16148  16178
                                     16270  16279y 16409  16411  16419
                                     16421
LINNUM                         $0014   807D  2375   2375   2587   2595
                                      2729   2730   2735   2736   2752
                                      2754   3104   3106   3281   3282
                                      3288   3303   3308   3309   3311
                                      3312   3313   3314   3315   3317
                                      3319   6118   6119   6126   6126
                                      6129y  6131   6131   6141y  6160y
                                      7908
CSRIDX                         $00d3  1277D  8778   8783   8860   8865
                                      8872   9023   9040   9060   9082
                                      9176   9178   9235   9246   9256
                                      9271   9312   9355   9364   9385
                                      9433   9455   9480   9484   9504
                                      9551   9563   9583   9944   9973
                                     11975
CMPO                           $00b0  1087D 15420  15563  15564  15568
                                     15570  15571  15573  15578  15580
                                     15593  15656  15667  15668  15670
                                     15672  15673  15679  15690  15691
                                     15695  15696  15699  15700  15722
                                     15770  15774  15821  15824  15825
TBLX                           $00d6  1308D  8777   8782   8861   8864
                                      9027   9187   9191   9192   9232
                                      9244   9253   9359   9376   9380
                                      9477   9479   9529   9540   9572
                                      9593   9596   9667   9703   9759
                                      9776   9789  11977
STAL                           $00c1  1150D 13313  13315  13379  13381
                                     15238  15238  15250  15253  15284
                                     15284  15304  15309  16070  16072
                                     16616  16621  16624  16626  16633
                                     16634  16654  16900y 16903y 16904y
                                     16907y 16908y 16915
FRESPC                         $0033   851D  2173   2176   2200   2203
                                      2661   2661   3427   3432   5230
                                      5233   5498   5499   5511   5511
                                      5543   5544   5669   5672   5721
                                      5721   5845   5847   5851   5852
                                      5854   8375   8375
CHRGET                         $0073   994D  2280   2722   2885   2939
                                      2961   2976   3267   3322   3606
                                      3703   3839   4014   4093   4245
                                      4261   4350   4485   4667   4676
                                      4702   4873   6032   7167   7177
                                      7193   8355
TXTTAB                         $002b   835D  2400   2400   2575   2575
                                      2626y  2628y  2629   2633   2698
                                      2701   2986   2988   3117   3117
                                      7933   7953   7953   8371   8371
                                      8378y  8379   8381   8390   8390
                                      8395   8398
SLLTBL                         $00d9  1353D  8836   8847   8868   8881
                                      8892   9198   9199   9223   9538
                                      9678   9687   9689   9694   9698
                                      9700   9701   9780   9811   9822
                                      9824   9829   9897  10553  10555
SA                             $00b9  1129D  8673  12316  12329  12368
                                     12380  12491  12514  12582  12637
                                     12639  12673  12727  12749  12769
                                     12982  12986  13291  13403  13415
                                     13449  13453  13520  13531  16804
TAPE1                          $00b2  1094D 12094y 12238y 12244y 12732y
                                     13283y 13286y 13296y 13298y 13301y
                                     13303y 15194y 15213y 15244y 15248y
                                     15251y 15254y 15257y 15260y 15272y
                                     15294  15294  15330y 16574  16575
CURLIN                         $0039   866D  2255   2287   2866   2866
                                      2919   2922   3019   3023   3023
                                      3059   3059   3086   3086   3103
                                      3105   3158   3158   3679   3679
                                      3995   3997   5265   7305   7306
VARTAB                         $002d   839D  2309   2317   2318   2320
                                      2322   2327   2356   2360   2379
                                      2379   2632   2635   2662   2662
                                      3437   3441   4715   4715   5563
                                      5563   7932   7932   7997   7997
CHRGOT                         $0079   995D  2718   2882   3092   3222
                                      3240   3499   3816   3882   3893
                                      3917   4011   4078   4631   4640
                                      4653   4931   5345   5950   6048
                                      6078   6151   8072   8089
FAC2M3/FAC2M4                  $006c   977D  4221   4221   4573   4576
                                      4604y  6321   6576   6608   6743
                                      6765   6777   6779    978D  4574
                                      4577   6318   6573   6605   6746
                                      6764   6774   6776
VARNAM                         $0045   900D  4394   4394   4652   4695
                                      4696   4705   4728   4731   4779
                                      4779   4813   4816   4916   4916
                                      4918   4918   4957   4959   5007
                                      5014   5148   5153
STREND                         $0031   847D  2106   2106   2378   2378
                                      2664   2664   4799   4799   4948
                                      4950   5064   5064   5081   5085
                                      5231   5234   5504   5507   5548
                                      5548   5585   5587
COUNT                          $000b   736D  2300   2358   2380   2495
                                      2511   2553   4529   4532   4535
                                      4540   4542   4545   4547   4846
                                      4934   4995   5022   5050   5100
                                      5144
LINPTR                         $00d1  1271D  8884   8886   9012y  9061y
                                      9317y  9319y  9330y  9430y  9447y
                                      9449y  9458y  9866y  9896   9900
                                      9916y  9945y  9954   9956   9976
ROPRTY                         $00bd  1139D 11345  11346  11362  11380
                                     11416  15862  15911  15958  15994
                                     16014  16059  16100  16216  16218
                                     16230  16261  16272  16280  16291
DESCPT                         $0050   929D  3453   3453   3459   3459
                                      3462y  3465y  3468y  5389   5389
                                      5756   5756   5900y  5905y  5918
                                      5918   5940y  5964y  5985   5985
PTR1                           $009e  1065D 12194  12243  12288  12291
                                     15235  15247  15264  15267  15273
                                     15323  15332  15334  15421  15968
                                     15970  15977  15982  16040
IOPMPT                         $0013   799D  2234   3490   3535   3544
                                      3643   3685   3707   3717   3728
                                      3736   3741   3765   3776   3785
                                      3828   3934   8362   8499
STATUS                         $0090  1001D 11243  12106  12339  12390
                                     12557  12772  12950  12990  13043
                                     13044  13052  13088  13272  15406
                                     16840  16846  16847
VALTYP                         $000d   749D  3335   3519   3840   4040
                                      4102   4132   4242   4395   4567
                                      4665   4685   4909   4937   5223
                                      5241   5480   6007
BITTS                          $00b4  1100D 11335  11347  11369  11372
                                     11376  11392  11419  15419  15707
                                     15732  15794  15807  15830  15844
                                     15851
VARPNT                         $0047   906D  4839   4839   5164   5167
                                      5169   5293   5293   5321   5326
                                      5330y  5334   5342   5342   7465
                                      7479
CHARAC                         $0007   720D  3195   3201   3202   3287
                                      3316   3847   3852   3856   4533
                                      4546   5406   5421   7129   7609
                                      7687
LASTKY                         $00d7  1313D  9065   9067   9068   9105
                                      9110   9264   9272  15729  15779
                                     15798  16253  16271  16281  16282
MEMUSS                         $00c3  1151D  8682   8684  12941  12941
                                     13284  13287  13307  13310  13312
                                     13314  16489  16489  16500y 16504
FNLEN                          $00b7  1126D 12704  12756  12783  12791
                                     12823  12965  13259  13339  13345
                                     13353  13404  15268  15326  16793
FAC2EX                         $0069   974D  4219   4560   4560   6213
                                      6214   6252   6254   6622   6630
                                      6911   6932   7594   7697   7700
TMPPTB                         $005a   950D  2113   2117   2123   2126
                                      2128   2140y  2146y  2150   2357
                                      2361   4800   4800   5717   5720
COLS                           $0016   392D  8766   8838   8871   8888
                                      8895   9216   9374   9383   9482
                                      9566   9580   9586   9862   9907
FA                             $00ba  1130D 12306  12353  12407  12580
                                     12641  12767  12951  12984  13388
                                     13413  13451  16803  16811
ROWS                           $0017   393D  8767   8844   8848   9188
                                      9533   9594   9674   9696   9698
                                      9700   9783   9801   9817
USER                           $00f3  1364D  9321y  9323y  9332y  9451y
                                      9453y  9460y  9868y  9919y  9947y
                                      9955   9959   9981
LINLEN                         $00d5  1303D  8900   9008   9177   9217
                                      9255   9325   9357   9377   9429
                                      9442  10557  11989
RIPRTY                         $00ab  1084D 11489  11490  11562  15280
                                     15444  15928  16049  16053  16054
                                     16058  16318  16323
INBIT                          $00a7  1080D 11488  11491  11501  11527
                                     11561  15880  15909  15952  16038
                                     16305  16315  17049
TMPVA2                         $005e   957D  4406   7203   7212   7217
                                      7223   7229   7271   7283   7292
                                      7403   7502   7507
TMPVA1                         $005d   956D  4410   5190   5215   7153
                                      7216   7244   7358   7374   7379
                                      7388   7404   7471
ARYTAB                         $002f   843D  2663   2663   4722   4724
                                      4797   4797   4811   4811   4942
                                      4943   5567   5569
ENDCHR                         $0008   721D  2476   2537   2542   3197
                                      3200   3205   3210   3863   4536
                                      4541   5407   5423
RIDATA                         $00aa  1083D 11492  11545  11587  15418
                                     15884  15897  15919  15922  15925
                                     15933  16025
FAC2M1                         $006a   975D  4220   4220   4558   4559
                                      6327   6582   6619   6737   6767
                                      6783   6785
QUOTE                          $0022   684D  2477   2771   3213   3748
                                      3853   4272   5405   5427   5462
                                      9123   9128
NDX                            $00c6  1173D  8955   8957   8973   8996
                                      9755  10246  10258  10263  11939
                                     13641
RINONE                         $00a9  1082D 11483  11520  11534  15713
                                     15717  15783  15864  16086  16187
                                     16195
BITCI                          $00a8  1081D 11485  11498  11506  15709
                                     15834  15863  16084  16163  16173
                                     17093
CNTDN                          $00a5  1078D 10910  10943  11140  11181
                                     11197  11202  11234  16243  16254
                                     16328
TSFCNT                         $00a3  1076D 10757  10764  10809  15686
                                     15753  15796  15811  16081  16231
                                     16232
PTR2                           $009f  1066D 15262  15271  15274  15321
                                     15329  15333  15422  15981  15990
                                     15991
TEMPX                          $0097  1033D 11957  11959  12055  12067
                                     12078  12287  12290  16617  16630
                                     16656
FAC2SI                         $006e   979D  4223   4556   6188   6227
                                      6614   6617   6901   7262   7602
                                      8154
MEMSIZ                         $0037   860D  2660   2660   5539   5540
                                      7833   7834   8374   8374   8393
                                      8397
GARBFL                         $000f   770D  2463   2479   2529   2740
                                      2773   2775   2814   5492   5519
                                      5523
FSBLK                          $00be  1147D 15486  15878  15888  16032
                                     16035  16042  16255  16299  16324
VERCKK                         $0093  1027D 12948  13057  13364  15187
                                     15191  15407  15955  15992  16011
INPPTR                         $0043   898D  3807   3807   3814   3814
                                      3890   3890   3924   3925   3932
OLDTXT                         $003d   878D  2687   2904   2904   3022
                                      3022   3051   3056   3692   3692
CSRMOD                         $00d4  1297D  9024   9074   9125   9127
                                      9161   9336   9425   9550
RODATA                         $00b6  1111D 11338  11424  15865  15907
                                     15962  15965  15999  16002
TBTCNT                         $00a4  1077D 11219  11250  15725  15727
                                     15749  16083  16205  16207
DFLTN                          $0099  1044D  8929   9091  11706  11937
                                     11969  12322  12604  12611
FACTPA                         $0057   948D  2186   6861   6862   7721
                                      7724   7724   8198   8198
FUNJMP                         $0055   938D  4511   4513   5688   5710
                                      5714   5724   5980   5986
ACCSYM                         $004d   919D  4075   4089   4090   4092
                                      4097   4142   4159   4568
TXPTR                          $00f9  1395D 11423y 11665y 12433  12440
                                     12911  12914  12915
RXPTR                          $00f7  1390D 11556y 11778y 12428  12439
                                     12904  12907  12908
SCROWM                         $00f2  1361D  9669   9704   9782   9787
                                      9806   9820   9834
INSRTO                         $00d8  1330D  9147   9149   9159   9297
                                      9461   9467   9548
FNADR                          $00bb  1138D 12788y 12825y 13350y 15270y
                                     15328y 16794  16795
NXTBIT                         $00b5  1106D 11353  11417  15848  15886
                                     15905  15937  17017
PRTY                           $009b  1058D 15760  15792  15793  16085
                                     16220  16221  16289
DFLTO                          $009a  1048D  8927   9094  11600  12155
                                     12373  12599  12609
LDTND                          $0098  1040D 12535  12536  12538  12564
                                     12592  12628  12634
FAC2M2                         $006b   976D  6324   6579   6611   6740
                                      6766   6780   6782
SUBFLG                         $0010   776D  2688   2844   4691   4707
                                      4714   5286   5305
INTFLG                         $000e   755D  3333   3878   4422   4666
                                      4694   4907   4939
KBDPTR                         $00f5  1384D 10133  10135  10164y 10209y
                                     10327  10329
BUFPNT                         $00a6  1079D 12066  12090  12240  12737
                                     15348  15349
MSGFLG                         $009d  1060D 11914  13335  13549  13684
                                     15206  16837
FAC2M5                         $0056   943D  6212   6232   6259   6315
                                      7676   7703
YSAVE                          $004b   917D  3813   3813   3891   3891
                                      4125   4212
UTLSTP                         $0035   856D  5512   5512   5796y  5803
                                      5804   5806
TEMPPT                         $0016   812D  2677   5461   5485   5555
                                      5871   8368
TANSGN                         $0012   788D  4217   4615   8169   8171
                                      8193   8202
DIMFLG                         $000c   743D  4646   4906   4941   4992
                                      5031   5089
INSRC                          $00d0  1266D  9009   9053   9089   9270
                                     11988
BLNON                          $00cf  1261D  8809   8978   8983   9974
                                      9978
ICRROW                         $00c9  1203D  9025   9034   9528   9668
                                     11978
JIFFYL                         $00a2  1075D 13560  13568  13577  13612
                                     13621
JIFFYM                         $00a1  1074D 13562  13570  13576  13613
                                     13622
JIFFYH                         $00a0  1073D 13564  13572  13575  13614
                                     13623
SYNO                           $0096  1032D 15787  15805  15832  15836
                                     15847
BSOUR                          $0095  1030D 10768  10925  11003  11024
                                     11077
FAC1OV                         $0068   970D  6436   7088   7097   7110
                                      8361
GARBSS                         $0053   931D  5562   5579   5687   5691
                                      8359
LASTPT                         $0017   817D  5481   5867   5869   5873
                                      8363
INPFLG                         $0011   787D  3669   3806   3818   3842
                                      3926
PAL                            $0000     9D  8506  10659  16774  16780
                                     17132
BLNCT                          $00cd  1245D  8822   9936   9969   9972
SFDX                           $00cb  1231D 10117  10174  10208  10251
INDX                           $00c8  1189D  9020   9041   9084  11990
RVS                            $00c7  1183D  9140   9343   9495   9549
LA                             $00b8  1128D 12578  12618  12635  16802
TK_MINUS                       $00ab  1673D  2712   2720   4268   7179
DPSW                           $009c  1059D 15423  15681  15829  15875
C3PO                           $0094  1028D 10754  10763  11061  11064
SVXT                           $0092  1026D 15723  15724  15767  15778
RNDX                           $008b   999D  7793   7793   7818   7819
SGNFLG                         $0067   969D  7159   7233   7739   7762
DATPTR                         $0041   892D  2993   2993   3796   3796
DATLIN                         $003f   886D  3676   3676   3909   3913
OLDLIN                         $003b   871D  3024   3024   3058   3058
BASSTO                         $00ff  1397D  5381   5381   7337
TK_PI                          $00ff  1713D  2468   2812   4257
GDBLN                          $00ce  1254D  8980   9979   9984
BLNSW                          $00cc  1238D  8823   8974   9967
CAS1                           $00c0  1149D 10039  10053  15503
TK_SGN                         $00b4  1686D  4312   4510   4512
TK_GOSUB                       $008d  1633D  3087   3141   3253
FACTPB                         $005c   955D  6854   7761   7761
TEMPST                         $0019   818D  2676   5550   8367
CR                             $000d   682D  2439   3542   9006
VERCK                          $000a   735D  7950   7952   7956
IEC_CLK_BIT                    $0002   405D 10941  11260  11269
STND_COL                       $00f7   388D  9743  10266
ICRCOL                         $00ca  1204D  9039  11976
LSTX                           $00c5  1152D 10211  10252
MYCH                           $00bf  1148D 15799  15861
TK_EQUAL                       $00b2  1681D  3331   5290
TK_PLUS                        $00aa  1672D  4270   7183
TK_FN                          $00a5  1663D  4307   5302
TK_TO                          $00a4  1662D  2867   2977
TK_TAB                         $00a3  1661D  2953   3509
STKEY                          $0091  1014D 13602  13631
TK_GOTO                        $0089  1629D  3223   3257
TK_DATA                        $0083  1622D  2525   3919
TK_FOR                         $0081  1620D  2075   2892
IEC_ATN_BIT                    $0080   403D 10783  11092
COLMAX                         $0058   395D  9180   9437
JUMPER                         $0054   936D  4514   8343
SEMIC                          $003b   685D  3516   3751
TRMPOS                         $0009   722D  3585   3592
ADRAY2                         $0005   711D  8348   8348
COLINK                         $0004   394D  9559   9579
ADRAY1                         $0003   703D  8350   8350
USRVEC                         $0001   694D  8346   8346
Basic_USR                      $0000   693D  1854   8344
CTRL_ROW                       $00fe   386D  9725
CTRL_COL                       $00fb   385D  9722
TK_GO                          $00cb  1712D  2974
TK_CHRS                        $00c7  1707D  4486
TK_GT                          $00b1  1680D  4082
TK_STEP                        $00a9  1668D  2883
TK_NOT                         $00a8  1667D  4289
TK_THEN                        $00a7  1665D  3225
TK_SPC                         $00a6  1664D  3511
TK_PRINT                       $0099  1647D  2483
COLRAM_PAGE                    $0094   396D  9958
TK_REM                         $008f  1635D  2533
ISNUM                          $0080   997D  3411
RS232_C_BIT                    $0020   407D 11352
IEC_DAT_BIT                    $0020   406D  8647
IEC_IFR_BIT                    $0020   404D 11167
VIC_REGS                       $0010    83D  8935
LF                             $000a   683D  3546
Default_Color                  $0006   397D  8817
TK_MIDS                        $00ca  1711
TK_RIGHTS                      $00c9  1710
TK_LEFTS                       $00c8  1709
TK_ASC                         $00c6  1706
TK_VAL                         $00c5  1705
TK_STRS                        $00c4  1704
TK_LEN                         $00c3  1703
TK_PEEK                        $00c2  1702
TK_ATN                         $00c1  1701
TK_TAN                         $00c0  1700
TK_SIN                         $00bf  1698
TK_COS                         $00be  1697
TK_EXP                         $00bd  1696
TK_LOG                         $00bc  1695
TK_RND                         $00bb  1694
TK_SQR                         $00ba  1693
TK_POS                         $00b9  1692
TK_FRE                         $00b8  1691
TK_USR                         $00b7  1689
TK_ABS                         $00b6  1688
TK_INT                         $00b5  1687
TK_LT                          $00b3  1682
TK_OR                          $00b0  1679
TK_AND                         $00af  1677
TK_POWER                       $00ae  1676
TK_DIV                         $00ad  1675
TK_MUL                         $00ac  1674
TK_NEW                         $00a2  1657
TK_GET                         $00a1  1656
TK_CLOSE                       $00a0  1655
TK_OPEN                        $009f  1653
TK_SYS                         $009e  1652
TK_CMD                         $009d  1651
TK_CLR                         $009c  1650
TK_LIST                        $009b  1649
TK_CONT                        $009a  1648
TK_PRINFL                      $0098  1646
TK_POKE                        $0097  1644
TK_DEF                         $0096  1643
TK_VERIFY                      $0095  1642
TK_SAVE                        $0094  1641
TK_LOAD                        $0093  1640
TK_WAIT                        $0092  1639
TK_ON                          $0091  1638
TK_STOP                        $0090  1637
TK_RETURN                      $008e  1634
TK_RESTORE                     $008c  1632
TK_IF                          $008b  1631
TK_RUN                         $008a  1630
TK_LET                         $0088  1628
TK_READ                        $0087  1626
TK_DIM                         $0086  1625
TK_INPUT                       $0085  1624
TK_INFL                        $0084  1623
TK_NEXT                        $0082  1621
TK_END                         $0080  1619
C64                            $0000     5D     6    418   1550   1582
                                      1609   1797   2050   2793   3038
                                      3569   7572   7663   7669   7865
                                      7964   8004   8277   8306   8419
                                      8458   8519   8877   8905   9028
                                      9200   9629   9707   9837   9882
                                      9912   9926  10013  10028  10041
                                     10056  10067  10081  10123  10137
                                     10145  10153  10187  10199  10288
                                     10404  10430  10456  10487  10503
                                     10524  10541  10563  10723  10769
                                     10790  10864  10888  10917  10954
                                     11011  11038  11047  11085  11115
                                     11145  11158  11171  11189  11209
                                     11225  11238  11273  11309  11404
                                     11444  11512  11530  11610  11636
                                     11651  11662  11668  11686  11718
                                     11738  11768  11774  11783  11795
                                     11815  11829  11940  12130  12137
                                     12177  12203  12207  12264  12281
                                     12416  12460  12484  12496  12500
                                     12750  12757  12763  12795  12809
                                     12836  12846  12883  12891  12922
                                     12974  13000  13176  13196  13214
                                     13225  13237  13502  13586  13632
                                     13865  14114  14129  14139  14149
                                     14157  14356  14363  14371  14379
                                     14500  14515  14536  14615  14635
                                     14718  14755  14814  14823  14934
                                     14986  15163  15218  15375  15424
                                     15455  15467  15475  15488  15494
                                     15525  15586  15598  15660  15735
                                     15750  15812  15837  15852  16026
                                     16123  16133  16144  16174  16329
                                     16340  16347  16391  16438  16470
                                     16553  16577  16667  16690  16756
                                     16815  16820  16935  16957  16964
                                     16984  17027  17036  17043  17061
                                     17072  17098  17118  17163  17252
                                     18410
VIC                            $0001     6D    80    692   1360   1613
                                      1800   2053   2797   3041   3572
                                      7575   7672   7869   7967   8008
                                      8310   8403   8427   8492   8595
                                      8791   8880   8901   9031   9036
                                      9062   9209   9399   9407   9644
                                      9712   9840   9885   9917  10017
                                     10032  10045  10060  10070  10084
                                     10126  10156  10192  10282  10293
                                     10302  10313  10320  10333  10369
                                     10375  10416  10442  10468  10492
                                     10507  10527  10544  10587  10729
                                     10804  10818  10829  10840  10870
                                     10892  10905  10920  10966  11014
                                     11050  11118  11148  11175  11192
                                     11213  11229  11242  11320  11407
                                     11454  11519  11533  11592  11614
                                     11640  11675  11696  11723  11747
                                     11755  11804  11863  11887  11943
                                     12133  12144  12180  12193  12195
                                     12248  12267  12285  12419  12507
                                     12753  12760  12798  12812  12839
                                     12866  12886  12894  12978  13015
                                     13094  13115  13147  13179  13204
                                     13218  13228  13233  13242  13497
                                     13507  13635  13869  14122  14132
                                     14143  14152  14161  14359  14366
                                     14374  14509  14518  14571  14669
                                     14725  14868  14948  14978  15049
                                     15167  15381  15427  15458  15491
                                     15498  15514  15528  15589  15676
                                     15744  15816  15840  15855  16129
                                     16136  16147  16177  16350  16353
                                     16396  16445  16473  16493  16562
                                     16615  16673  16715  16771  16895
                                     16941  16954  16960  16967  17007
                                     17030  17039  17046  17064  17075
                                     17131  17291  18263  18413
INDEXA                         $0022   824D  2115   2125   2133   2163
                                      2165   2229   2231   2240y  2308
                                      2310   2335   2337   2341y  2345
                                      2401   2401   2406y  2412y  2416
                                      2419y  2420   2423y  2424   2425
                                      2876   2876   3289   3305   3307
                                      3310   3410y  3631y  4108   4110
                                      4178   4179   4181   4194   5049
                                      5139   5178   5552   5552   5564
                                      5564   5592   5592   5594y  5597y
                                      5600y  5604y  5612y  5616   5617
                                      5619   5622   5638y  5641y  5662y
                                      5665y  5668y  5685   5685   5693
                                      5694   5696   5699   5783   5783
                                      5795y  5830   5830   5834y  5837y
                                      5840y  5860   5860   5924   5925
                                      5927   6018y  6061   6064   6066
                                      6602   6602   6604y  6607y  6610y
                                      6613y  6621y  6829   6829   6831y
                                      6834y  6837y  6840y  6845y  6876
                                      6876   6879y  6882y  6885y  6890y
                                      6893y  7777   7777   7779y  7782y
                                      7785y  7788y  8137   8138
FAC1M3/FAC1M4                  $0064   965D  3352   3401   3426y  3431y
                                      3440   3445   3451y  4190   4190
                                      4302   4375   4381   4393   4393
                                      4425y  4428y  4453   4475   4475
                                      4494   4494   4531   4544   4865
                                      4926   5109   5136   5388   5388
                                      5477   5477   5741   5741   5748y
                                      5824   5824   6045   6116   6266
                                      6291   6294   6320   6322   6335
                                      6359   6384   6386   6402   6546
                                      6744   6778   6820   6835   6881
                                      7005   7057   7138   7436   7438
                                      7783   7806   7808    966D  3261
                                      3355   3403   3436   3446   4299
                                      4377   4383   4455   4534   4539
                                      4866   4928   5111   5142   5949
                                      5967   5969   6047   6117   6263
                                      6293   6296   6317   6319   6334
                                      6360   6387   6389   6400   6544
                                      6747   6775   6822   6832   6878
                                      7004   7063   7128   7139   7432
                                      7435   7789   7801   7803
TXTPTR                         $007a   996D  2279   2279   2461   2497
                                      2552   2566   2568   2700   2703
                                      2861   2863   2900   2900   2908y
                                      2911y  2918y  2921y  2924   2925
                                      2927   3018   3018   3057   3057
                                      3085   3085   3110   3111   3124
                                      3127   3159   3159   3175   3176
                                      3178   3208y  3693   3693   3812
                                      3812   3815   3815   3836   3836
                                      3845   3864   3864   3889   3889
                                      3892   3892   3905y  3908y  3911y
                                      3999   4001   4058   4060   4063
                                      4135   4137   4140   4279   4279
                                      4348y  5294   5294   5336   5336
                                      5338   5341   5350   5350   6059
                                      6059   6062   6067   6089   6089
                                      7287y  7973   7992   8318   8320
TMPPTC                         $005f   958D  2114   2118   2307y  2311
                                      2313   2315y  2323   2326   2384y
                                      2582   2582   2583y  2588y  2597y
                                      2603y  2606y  2741y  2748y  2751y
                                      2780y  2783y  2786y  2787   2788
                                      3122   3125   4718   4721   4729y
                                      4733y  4739   4798   4798   4814y
                                      4817y  4820y  4822y  4824y  4826y
                                      4828y  4831   4834   4849   4850
                                      4946   4947   4955y  4960y  4965y
                                      4967   4970y  4971   4997y  5008y
                                      5015y  5026y  5042y  5045y  5082
                                      5084y  5087   5088y  5099y  5112y
                                      5117y  5179y  5182y  5549   5549
                                      5676   5679   5683   5684   5716
                                      5718   7190   7199   7207   7208
                                      7242   7275
FAC1M1/FAC1M2                  $0062   963D  2873   2874   4191   4191
                                      4457   4571   4605y  5242   5396
                                      5414   5414   5472   5890y  6272
                                      6287   6290   6326   6328   6337
                                      6357   6378   6380   6406   6550
                                      6738   6784   6816   6843   6889
                                      6986   6995   7049   7106   7107
                                      7108   7136   7312   7442   7444
                                      7780   7802   7804    964D  3402
                                      4454   4572   5243   5397   5474
                                      6269   6289   6292   6323   6325
                                      6336   6358   6381   6383   6404
                                      6548   6741   6781   6818   6838
                                      6884   6988   7053   7137   7313
                                      7439   7441   7786   7805   7807
JIFFY                          $0000     8D   829   1144   8042   8297
                                      8408   8420   8428   8436   8467
                                      8520   8596   8694   8987   9706
                                      9727   9991  10283  10297  10302
                                     10314  10321  10333  10369  10376
                                     10589  10758  10772  10858  11037
                                     11069  11088  11094  11132  11828
                                     11970  12003  12119  12193  12206
                                     12248  12444  12651  12660  12674
                                     12960  12967  12994  13009  13016
                                     13024  13062  13094  13104  13233
                                     13397  13465  13699  16493  16666
                                     17610  18263
STRPTR/FAC1M5                  $006f   983D  3454   3454   4225   5413
                                      5413   5419y  5436   5438   5444
                                      5452   5452   5744   5744   5746y
                                      5759   5759   5769y  5772y  5775y
                                      6189   6249   6616   6652   6688
                                      6710   7264   7710   8159    988D
                                      4398   5478   6211   6238   6244
                                      6260   6295   6297   6316   6333
                                      6361   6390   6392   6393   6429
                                      6448   6542   6590   6800   6847
                                      6894   6915   6935   6946   7011
                                      7061   7121   7656   7704   7814
FAC1EX                         $0061   962D  2194   3229   3376   3456
                                      3456   4192   4228   4570   4580
                                      4584   4890   5398   5434   5470
                                      6112   6190   6223   6226   6233
                                      6251   6308   6342   6346   6355
                                      6503   6507   6623   6638   6647
                                      6690   6728   6729   6731   6846
                                      6892   6912   6931   6944   6961
                                      7010   7045   7080   7093   7117
                                      7127   7265   7342   7627   7678
                                      7698   7699   7813   7816   8237
TMPPTD                         $0071   990D  2493   2514   3380   3383
                                      3384   3394   4408   5005   5021
                                      5047   5048   5066   5067   5077
                                      5102   5105   5130   5131   5143
                                      5146   5202   5203   5437   5443
                                      6060   6060   6088   6088   7339
                                      7410   7421   7466   7478   7490
                                      7719   7719   7731   7731   7738y
                                      7740   7744   7747   7748   7752
                                      7752   7759   7759
INDEXB/FAC3                    $0024   825D  2312   2319   2331   2342y
                                      2346   3977   6065   6072   6074y
                                      6077y  6082y  7026   7036   7038y
                                      7042y  7047y  7052y  7056y  7062y
                                       827D  5159   5180   5188   5207
                                      5210   6422   6538   6539   6540
                                      6541   6572   6574   6575   6577
                                      6578   6580   6581   6583   6586
                                      6587   6588   6589   6754   6815
                                      6817   6819   6821
FAC1SI                         $0066   967D  2871   3377   3983   4169
                                      4224   4588   4596   4881   6110
                                      6185   6187   6228   6311   6370
                                      6372   6615   6653   6660   6841
                                      6887   6907   6965   7012   7019
                                      7043   7069   7084   7104   7122
                                      7123   7263   7332   7338   7629
                                      7631   7812   8163   8167   8201
                                      8231
FORPNT                         $0049   911D  2077   2080   2082   2087
                                      2761   2766   2819   2891   2891
                                      3138   3330   3330   3353y  3356y
                                      3369   3463y  3466y  3469y  3811
                                      3811   3960   3960   3984   3985
                                      6149   6156   6161   6162   6869
                                      6869   8027   8052   8058   8101
                                      8110   8112   8123   8124
TMPPTA                         $0058   949D  2132   2134   2136   2141y
                                      2147y  2151   2359   2365   4807
                                      4807   4809   4809   4855   4855
                                      5052   5054   5057   5072y  5076
                                      5079   5163   5166   5577   5577
                                      5582   5582   5601   5602   5605
                                      5606   5625   5627   5722   5722
                                      5726   5729   5730
FUNCPT                         $004e   925D  5307   5307   5315   5315
                                      5318   5318   5320y  5324y  5337y
                                      5340y  5344   5344   5355y  5358y
                                      5361y  5364y  5367y  5546   5547
                                      5686   5686   5707   5708   5715y
                                      5727y  5732y  7599   7600   7605
                                      7605   7616   7616   8195   8196
                                      8204   8204
EAL                            $00ae  1086D  8683   8685   9660   9662
                                      9763   9765   9797   9799   9842
                                      9844   9867y  9879   9888  12989
                                     12999  13061y 13079y 13083  13085
                                     13308  13311  13325  13326  13375
                                     13376  15239  15239  15256  15259
                                     15283  15283  15307  15311  16410
                                     16412
SAL                            $00ac  1085D  9656   9658   9677   9767
                                      9769   9793   9795   9810   9846
                                      9848   9858   9865y  9878   9880
                                     13419  13421  13427y 15959y 15971
                                     15973  15984  15987  15996y 16015y
                                     16052y 16071  16073  16148  16178
                                     16270  16279y 16409  16411  16419
                                     16421
LINNUM                         $0014   807D  2375   2375   2587   2595
                                      2729   2730   2735   2736   2752
                                      2754   3104   3106   3281   3282
                                      3288   3303   3308   3309   3311
                                      3312   3313   3314   3315   3317
                                      3319   6118   6119   6126   6126
                                      6129y  6131   6131   6141y  6160y
                                      7908
STACK                          $0100  1399D  2074   2079   2081   2085
                                      2088   3982   3992   3994   3996
                                      3998   4000   4922   4924   4927
                                      4929   7413   7418   7470   7475
                                      7492   7512   7514   7524   7526
                                      7528   7532   7536   7539   7539
                                     15972  15974  15985  15988  17245
CSRIDX                         $00d3  1277D  8778   8783   8860   8865
                                      8872   9023   9040   9060   9082
                                      9176   9178   9235   9246   9256
                                      9271   9312   9355   9364   9385
                                      9433   9455   9480   9484   9504
                                      9551   9563   9583   9944   9973
                                     11975
CMPO                           $00b0  1087D 15420  15563  15564  15568
                                     15570  15571  15573  15578  15580
                                     15593  15656  15667  15668  15670
                                     15672  15673  15679  15690  15691
                                     15695  15696  15699  15700  15722
                                     15770  15774  15821  15824  15825
BUF                            $0200  1401D  2353   2376   2377   2383
                                      2441   2466   2505   2519   2520
                                      2540   2547   2561   2565   2901
                                      3532   3533   3534   3711   3712
                                      3714   3761   3774   3821   3822
                                      3823   7993   8365   8366
TBLX                           $00d6  1308D  8777   8782   8861   8864
                                      9027   9187   9191   9192   9232
                                      9244   9253   9359   9376   9380
                                      9477   9479   9529   9540   9572
                                      9593   9596   9667   9703   9759
                                      9776   9789  11977
STAL                           $00c1  1150D 13313  13315  13379  13381
                                     15238  15238  15250  15253  15284
                                     15284  15304  15309  16070  16072
                                     16616  16621  16624  16626  16633
                                     16634  16654  16900y 16903y 16904y
                                     16907y 16908y 16915
FRESPC                         $0033   851D  2173   2176   2200   2203
                                      2661   2661   3427   3432   5230
                                      5233   5498   5499   5511   5511
                                      5543   5544   5669   5672   5721
                                      5721   5845   5847   5851   5852
                                      5854   8375   8375
CHRGET                         $0073   994D  2280   2722   2885   2939
                                      2961   2976   3267   3322   3606
                                      3703   3839   4014   4093   4245
                                      4261   4350   4485   4667   4676
                                      4702   4873   6032   7167   7177
                                      7193   8355
TXTTAB                         $002b   835D  2400   2400   2575   2575
                                      2626y  2628y  2629   2633   2698
                                      2701   2986   2988   3117   3117
                                      7933   7953   7953   8371   8371
                                      8378y  8379   8381   8390   8390
                                      8395   8398
SLLTBL                         $00d9  1353D  8836   8847   8868   8881
                                      8892   9198   9199   9223   9538
                                      9678   9687   9689   9694   9698
                                      9700   9701   9780   9811   9822
                                      9824   9829   9897  10553  10555
SA                             $00b9  1129D  8673  12316  12329  12368
                                     12380  12491  12514  12582  12637
                                     12639  12673  12727  12749  12769
                                     12982  12986  13291  13403  13415
                                     13449  13453  13520  13531  16804
TAPE1                          $00b2  1094D 12094y 12238y 12244y 12732y
                                     13283y 13286y 13296y 13298y 13301y
                                     13303y 15194y 15213y 15244y 15248y
                                     15251y 15254y 15257y 15260y 15272y
                                     15294  15294  15330y 16574  16575
CURLIN                         $0039   866D  2255   2287   2866   2866
                                      2919   2922   3019   3023   3023
                                      3059   3059   3086   3086   3103
                                      3105   3158   3158   3679   3679
                                      3995   3997   5265   7305   7306
VARTAB                         $002d   839D  2309   2317   2318   2320
                                      2322   2327   2356   2360   2379
                                      2379   2632   2635   2662   2662
                                      3437   3441   4715   4715   5563
                                      5563   7932   7932   7997   7997
CHRGOT                         $0079   995D  2718   2882   3092   3222
                                      3240   3499   3816   3882   3893
                                      3917   4011   4078   4631   4640
                                      4653   4931   5345   5950   6048
                                      6078   6151   8072   8089
FAC2M3/FAC2M4                  $006c   977D  4221   4221   4573   4576
                                      4604y  6321   6576   6608   6743
                                      6765   6777   6779    978D  4574
                                      4577   6318   6573   6605   6746
                                      6764   6774   6776
VARNAM                         $0045   900D  4394   4394   4652   4695
                                      4696   4705   4728   4731   4779
                                      4779   4813   4816   4916   4916
                                      4918   4918   4957   4959   5007
                                      5014   5148   5153
STREND                         $0031   847D  2106   2106   2378   2378
                                      2664   2664   4799   4799   4948
                                      4950   5064   5064   5081   5085
                                      5231   5234   5504   5507   5548
                                      5548   5585   5587
COUNT                          $000b   736D  2300   2358   2380   2495
                                      2511   2553   4529   4532   4535
                                      4540   4542   4545   4547   4846
                                      4934   4995   5022   5050   5100
                                      5144
LINPTR                         $00d1  1271D  8884   8886   9012y  9061y
                                      9317y  9319y  9330y  9430y  9447y
                                      9449y  9458y  9866y  9896   9900
                                      9916y  9945y  9954   9956   9976
ROPRTY                         $00bd  1139D 11345  11346  11362  11380
                                     11416  15862  15911  15958  15994
                                     16014  16059  16100  16216  16218
                                     16230  16261  16272  16280  16291
DESCPT                         $0050   929D  3453   3453   3459   3459
                                      3462y  3465y  3468y  5389   5389
                                      5756   5756   5900y  5905y  5918
                                      5918   5940y  5964y  5985   5985
PTR1                           $009e  1065D 12194  12243  12288  12291
                                     15235  15247  15264  15267  15273
                                     15323  15332  15334  15421  15968
                                     15970  15977  15982  16040
IOPMPT                         $0013   799D  2234   3490   3535   3544
                                      3643   3685   3707   3717   3728
                                      3736   3741   3765   3776   3785
                                      3828   3934   8362   8499
STATUS                         $0090  1001D 11243  12106  12339  12390
                                     12557  12772  12950  12990  13043
                                     13044  13052  13088  13272  15406
                                     16840  16846  16847
VALTYP                         $000d   749D  3335   3519   3840   4040
                                      4102   4132   4242   4395   4567
                                      4665   4685   4909   4937   5223
                                      5241   5480   6007
BITTS                          $00b4  1100D 11335  11347  11369  11372
                                     11376  11392  11419  15419  15707
                                     15732  15794  15807  15830  15844
                                     15851
VARPNT                         $0047   906D  4839   4839   5164   5167
                                      5169   5293   5293   5321   5326
                                      5330y  5334   5342   5342   7465
                                      7479
CHARAC                         $0007   720D  3195   3201   3202   3287
                                      3316   3847   3852   3856   4533
                                      4546   5406   5421   7129   7609
                                      7687
LASTKY                         $00d7  1313D  9065   9067   9068   9105
                                      9110   9264   9272  15729  15779
                                     15798  16253  16271  16281  16282
MEMUSS                         $00c3  1151D  8682   8684  12941  12941
                                     13284  13287  13307  13310  13312
                                     13314  16489  16489  16500y 16504
FNLEN                          $00b7  1126D 12704  12756  12783  12791
                                     12823  12965  13259  13339  13345
                                     13353  13404  15268  15326  16793
FAC2EX                         $0069   974D  4219   4560   4560   6213
                                      6214   6252   6254   6622   6630
                                      6911   6932   7594   7697   7700
TMPPTB                         $005a   950D  2113   2117   2123   2126
                                      2128   2140y  2146y  2150   2357
                                      2361   4800   4800   5717   5720
COLS                           $0016   392D  8766   8838   8871   8888
                                      8895   9216   9374   9383   9482
                                      9566   9580   9586   9862   9907
FA                             $00ba  1130D 12306  12353  12407  12580
                                     12641  12767  12951  12984  13388
                                     13413  13451  16803  16811
ROWS                           $0017   393D  8767   8844   8848   9188
                                      9533   9594   9674   9696   9698
                                      9700   9783   9801   9817
USER                           $00f3  1364D  9321y  9323y  9332y  9451y
                                      9453y  9460y  9868y  9919y  9947y
                                      9955   9959   9981
LINLEN                         $00d5  1303D  8900   9008   9177   9217
                                      9255   9325   9357   9377   9429
                                      9442  10557  11989
RIPRTY                         $00ab  1084D 11489  11490  11562  15280
                                     15444  15928  16049  16053  16054
                                     16058  16318  16323
INBIT                          $00a7  1080D 11488  11491  11501  11527
                                     11561  15880  15909  15952  16038
                                     16305  16315  17049
TMPVA2                         $005e   957D  4406   7203   7212   7217
                                      7223   7229   7271   7283   7292
                                      7403   7502   7507
TMPVA1                         $005d   956D  4410   5190   5215   7153
                                      7216   7244   7358   7374   7379
                                      7388   7404   7471
ARYTAB                         $002f   843D  2663   2663   4722   4724
                                      4797   4797   4811   4811   4942
                                      4943   5567   5569
ENDCHR                         $0008   721D  2476   2537   2542   3197
                                      3200   3205   3210   3863   4536
                                      4541   5407   5423
RIDATA                         $00aa  1083D 11492  11545  11587  15418
                                     15884  15897  15919  15922  15925
                                     15933  16025
FAC2M1                         $006a   975D  4220   4220   4558   4559
                                      6327   6582   6619   6737   6767
                                      6783   6785
QUOTE                          $0022   684D  2477   2771   3213   3748
                                      3853   4272   5405   5427   5462
                                      9123   9128
CINV                           $0314  1587D 15480  15482  15521  16362
                                     16364  16382  16384  16498  16507
                                     17250
NDX                            $00c6  1173D  8955   8957   8973   8996
                                      9755  10246  10258  10263  11939
                                     13641
RINONE                         $00a9  1082D 11483  11520  11534  15713
                                     15717  15783  15864  16086  16187
                                     16195
BITCI                          $00a8  1081D 11485  11498  11506  15709
                                     15834  15863  16084  16163  16173
                                     17093
CNTDN                          $00a5  1078D 10910  10943  11140  11181
                                     11197  11202  11234  16243  16254
                                     16328
TSFCNT                         $00a3  1076D 10757  10764  10809  15686
                                     15753  15796  15811  16081  16231
                                     16232
PTR2                           $009f  1066D 15262  15271  15274  15321
                                     15329  15333  15422  15981  15990
                                     15991
TEMPX                          $0097  1033D 11957  11959  12055  12067
                                     12078  12287  12290  16617  16630
                                     16656
FAC2SI                         $006e   979D  4223   4556   6188   6227
                                      6614   6617   6901   7262   7602
                                      8154
MEMSIZ                         $0037   860D  2660   2660   5539   5540
                                      7833   7834   8374   8374   8393
                                      8397
GARBFL                         $000f   770D  2463   2479   2529   2740
                                      2773   2775   2814   5492   5519
                                      5523
FSBLK                          $00be  1147D 15486  15878  15888  16032
                                     16035  16042  16255  16299  16324
VERCKK                         $0093  1027D 12948  13057  13364  15187
                                     15191  15407  15955  15992  16011
INPPTR                         $0043   898D  3807   3807   3814   3814
                                      3890   3890   3924   3925   3932
OLDTXT                         $003d   878D  2687   2904   2904   3022
                                      3022   3051   3056   3692   3692
SCNMPG                         $0288  1414D  8792   8798   8829   8883
                                      9857   9899  16640  16649
CSRMOD                         $00d4  1297D  9024   9074   9125   9127
                                      9161   9336   9425   9550
RODATA                         $00b6  1111D 11338  11424  15865  15907
                                     15962  15965  15999  16002
TBTCNT                         $00a4  1077D 11219  11250  15725  15727
                                     15749  16083  16205  16207
DFLTN                          $0099  1044D  8929   9091  11706  11937
                                     11969  12322  12604  12611
FACTPA                         $0057   948D  2186   6861   6862   7721
                                      7724   7724   8198   8198
FUNJMP                         $0055   938D  4511   4513   5688   5710
                                      5714   5724   5980   5986
ACCSYM                         $004d   919D  4075   4089   4090   4092
                                      4097   4142   4159   4568
RSSTAT                         $0297  1531D 11437  11438  11582  11583
                                     12820  16814  16819
OSSTAR                         $0281  1409D 16618  16647  16655  16886
                                     16887  16892  16892
TXPTR                          $00f9  1395D 11423y 11665y 12433  12440
                                     12911  12914  12915
RXPTR                          $00f7  1390D 11556y 11778y 12428  12439
                                     12904  12907  12908
SCROWM                         $00f2  1361D  9669   9704   9782   9787
                                      9806   9820   9834
INSRTO                         $00d8  1330D  9147   9149   9159   9297
                                      9461   9467   9548
FNADR                          $00bb  1138D 12788y 12825y 13350y 15270y
                                     15328y 16794  16795
NXTBIT                         $00b5  1106D 11353  11417  15848  15886
                                     15905  15937  17017
PRTY                           $009b  1058D 15760  15792  15793  16085
                                     16220  16221  16289
DFLTO                          $009a  1048D  8927   9094  11600  12155
                                     12373  12599  12609
LDTND                          $0098  1040D 12535  12536  12538  12564
                                     12592  12628  12634
FAC2M2                         $006b   976D  6324   6579   6611   6740
                                      6766   6780   6782
SUBFLG                         $0010   776D  2688   2844   4691   4707
                                      4714   5286   5305
INTFLG                         $000e   755D  3333   3878   4422   4666
                                      4694   4907   4939
IRQTMP                         $029f  1548D 15481  15483  15520  15554
                                     16360  16363
BAUDOF                         $0299  1543D 11682  11684  12875  12878
                                     17052  17055
M51CDR                         $0294  1513D 11358  11400  11558  11601
                                     11707  12880
M51CTR                         $0293  1483D 11370  11467  11503  12826
                                     12834  17076
MODE                           $0291  1468D  8808  10279  10522  10528
                                     10536  10539
COLOR                          $0286  1412D  8818   9152   9331   9459
                                      9615   9983
KBDPTR                         $00f5  1384D 10133  10135  10164y 10209y
                                     10327  10329
BUFPNT                         $00a6  1079D 12066  12090  12240  12737
                                     15348  15349
MSGFLG                         $009d  1060D 11914  13335  13549  13684
                                     15206  16837
FAC2M5                         $0056   943D  6212   6232   6259   6315
                                      7676   7703
YSAVE                          $004b   917D  3813   3813   3891   3891
                                      4125   4212
UTLSTP                         $0035   856D  5512   5512   5796y  5803
                                      5804   5806
TEMPPT                         $0016   812D  2677   5461   5485   5555
                                      5871   8368
TANSGN                         $0012   788D  4217   4615   8169   8171
                                      8193   8202
DIMFLG                         $000c   743D  4646   4906   4941   4992
                                      5031   5089
SHFLAG                         $028d  1439D 10115  10169  10170  10253
                                     10274
KBUFFR                         $0277  1408D  8948   8952   8953   9000
                                     10261
FILTBL                         $0259  1405D 12539  12540  12569  12577
                                     12636
INSRC                          $00d0  1266D  9009   9053   9089   9270
                                     11988
BLNON                          $00cf  1261D  8809   8978   8983   9974
                                      9978
ICRROW                         $00c9  1203D  9025   9034   9528   9668
                                     11978
JIFFYL                         $00a2  1075D 13560  13568  13577  13612
                                     13621
JIFFYM                         $00a1  1074D 13562  13570  13576  13613
                                     13622
JIFFYH                         $00a0  1073D 13564  13572  13575  13614
                                     13623
SYNO                           $0096  1032D 15787  15805  15832  15836
                                     15847
BSOUR                          $0095  1030D 10768  10925  11003  11024
                                     11077
FAC1OV                         $0068   970D  6436   7088   7097   7110
                                      8361
GARBSS                         $0053   931D  5562   5579   5687   5691
                                      8359
LASTPT                         $0017   817D  5481   5867   5869   5873
                                      8363
INPFLG                         $0011   787D  3669   3806   3818   3842
                                      3926
PAL                            $0000     9D  8506  10659  16774  16780
                                     17132
RODBE                          $029e  1547D 11421  11656  11660  12901
RODBS                          $029d  1546D 11420  11425  11658  12902
RIDBS                          $029c  1545D 11541  11771  11779  12900
RIDBE                          $029b  1544D 11539  11543  11772  12899
BITNUM                         $0298  1542D 11418  11546  12833  17092
KRPTDL                         $028c  1420D  8816  10214  10236  10238
OSTOP                          $0283  1410D 16867  16868  16874  16875
SECATB                         $026d  1407D 12543  12544  12581  12640
DEVTBL                         $0263  1406D 12541  12542  12579  12642
BLNCT                          $00cd  1245D  8822   9936   9969   9972
SFDX                           $00cb  1231D 10117  10174  10208  10251
INDX                           $00c8  1189D  9020   9041   9084  11990
RVS                            $00c7  1183D  9140   9343   9495   9549
LA                             $00b8  1128D 12578  12618  12635  16802
TK_MINUS                       $00ab  1673D  2712   2720   4268   7179
DPSW                           $009c  1059D 15423  15681  15829  15875
C3PO                           $0094  1028D 10754  10763  11061  11064
SVXT                           $0092  1026D 15723  15724  15767  15778
RNDX                           $008b   999D  7793   7793   7818   7819
SGNFLG                         $0067   969D  7159   7233   7739   7762
DATPTR                         $0041   892D  2993   2993   3796   3796
DATLIN                         $003f   886D  3676   3676   3909   3913
OLDLIN                         $003b   871D  3024   3024   3058   3058
AUTODN                         $0292  1481D  8975   9022   9182
KEYLOG                         $028f  1462D  8811   8813  10203
KRPTSP                         $028b  1419D  8820  10242  10245
CSRCLR                         $0287  1413D  8981   9975   9982
BASSTO                         $00ff  1397D  5381   5381   7337
TK_PI                          $00ff  1713D  2468   2812   4257
GDBLN                          $00ce  1254D  8980   9979   9984
BLNSW                          $00cc  1238D  8823   8974   9967
CAS1                           $00c0  1149D 10039  10053  15503
TK_SGN                         $00b4  1686D  4312   4510   4512
TK_GOSUB                       $008d  1633D  3087   3141   3253
FACTPB                         $005c   955D  6854   7761   7761
TEMPST                         $0019   818D  2676   5550   8367
CR                             $000d   682D  2439   3542   9006
VERCK                          $000a   735D  7950   7952   7956
IEC_CLK_BIT                    $0002   405D 10941  11260  11269
TBUFFR                         $033c  1605D 16572  16573
SPREG                          $030f  1580D  7902   7922
SYREG                          $030e  1579D  7906   7920
SXREG                          $030d  1578D  7905   7919
SAREG                          $030c  1577D  7904   7918
IERROR                         $0300  1559D  2219   8453
LSTSHF                         $028e  1452D 10254  10277
KBMAXL                         $0289  1415D  8815  10259
STND_COL                       $00f7   388D  9743  10266
ICRCOL                         $00ca  1204D  9039  11976
LSTX                           $00c5  1152D 10211  10252
MYCH                           $00bf  1148D 15799  15861
TK_EQUAL                       $00b2  1681D  3331   5290
TK_PLUS                        $00aa  1672D  4270   7183
TK_FN                          $00a5  1663D  4307   5302
TK_TO                          $00a4  1662D  2867   2977
TK_TAB                         $00a3  1661D  2953   3509
STKEY                          $0091  1014D 13602  13631
TK_GOTO                        $0089  1629D  3223   3257
TK_DATA                        $0083  1622D  2525   3919
TK_FOR                         $0081  1620D  2075   2892
IEC_ATN_BIT                    $0080   403D 10783  11092
COLMAX                         $0058   395D  9180   9437
JUMPER                         $0054   936D  4514   8343
SEMIC                          $003b   685D  3516   3751
TRMPOS                         $0009   722D  3585   3592
ADRAY2                         $0005   711D  8348   8348
COLINK                         $0004   394D  9559   9579
ADRAY1                         $0003   703D  8350   8350
USRVEC                         $0001   694D  8346   8346
Basic_USR                      $0000   693D  1854   8344
ISAVE                          $0332  1603D 13382
ILOAD                          $0330  1602D 12942
ICLALL                         $032c  1600D 18311
IGETIN                         $032a  1599D 18294
ISTOP                          $0328  1598D 18266
IBSOUT                         $0326  1597D 18122
IBASIN                         $0324  1596D 18085
ICLRCH                         $0322  1595D 18033
ICKOUT                         $0320  1594D 18005
ICHKIN                         $031e  1593D 17968
ICLOSE                         $031c  1592D 17929
IOPEN                          $031a  1591D 17902
NMINV                          $0318  1589D 16924
CBINV                          $0316  1588D 17248
IEVAL                          $030a  1564D  4235
IGONE                          $0308  1563D  2933
IQPLOP                         $0306  1562D  2805
ICRNCH                         $0304  1561D  2455
IMAIN                          $0302  1560D  2272
KEYRPT                         $028a  1416D 10219
STIMOT                         $0285  1411D 16854
CTRL_ROW                       $00fe   386D  9725
CTRL_COL                       $00fb   385D  9722
TK_GO                          $00cb  1712D  2974
TK_CHRS                        $00c7  1707D  4486
TK_GT                          $00b1  1680D  4082
TK_STEP                        $00a9  1668D  2883
TK_NOT                         $00a8  1667D  4289
TK_THEN                        $00a7  1665D  3225
TK_SPC                         $00a6  1664D  3511
TK_PRINT                       $0099  1647D  2483
COLRAM_PAGE                    $0094   396D  9958
TK_REM                         $008f  1635D  2533
ISNUM                          $0080   997D  3411
RS232_C_BIT                    $0020   407D 11352
IEC_DAT_BIT                    $0020   406D  8647
IEC_IFR_BIT                    $0020   404D 11167
VIC_REGS                       $0010    83D  8935
LF                             $000a   683D  3546
Default_Color                  $0006   397D  8817
USRCMD                         $032e  1601
M51AJB                         $0295  1529
TK_MIDS                        $00ca  1711
TK_RIGHTS                      $00c9  1710
TK_LEFTS                       $00c8  1709
TK_ASC                         $00c6  1706
TK_VAL                         $00c5  1705
TK_STRS                        $00c4  1704
TK_LEN                         $00c3  1703
TK_PEEK                        $00c2  1702
TK_ATN                         $00c1  1701
TK_TAN                         $00c0  1700
TK_SIN                         $00bf  1698
TK_COS                         $00be  1697
TK_EXP                         $00bd  1696
TK_LOG                         $00bc  1695
TK_RND                         $00bb  1694
TK_SQR                         $00ba  1693
TK_POS                         $00b9  1692
TK_FRE                         $00b8  1691
TK_USR                         $00b7  1689
TK_ABS                         $00b6  1688
TK_INT                         $00b5  1687
TK_LT                          $00b3  1682
TK_OR                          $00b0  1679
TK_AND                         $00af  1677
TK_POWER                       $00ae  1676
TK_DIV                         $00ad  1675
TK_MUL                         $00ac  1674
TK_NEW                         $00a2  1657
TK_GET                         $00a1  1656
TK_CLOSE                       $00a0  1655
TK_OPEN                        $009f  1653
TK_SYS                         $009e  1652
TK_CMD                         $009d  1651
TK_CLR                         $009c  1650
TK_LIST                        $009b  1649
TK_CONT                        $009a  1648
TK_PRINFL                      $0098  1646
TK_POKE                        $0097  1644
TK_DEF                         $0096  1643
TK_VERIFY                      $0095  1642
TK_SAVE                        $0094  1641
TK_LOAD                        $0093  1640
TK_WAIT                        $0092  1639
TK_ON                          $0091  1638
TK_STOP                        $0090  1637
TK_RETURN                      $008e  1634
TK_RESTORE                     $008c  1632
TK_IF                          $008b  1631
TK_RUN                         $008a  1630
TK_LET                         $0088  1628
TK_READ                        $0087  1626
TK_DIM                         $0086  1625
TK_INPUT                       $0085  1624
TK_INFL                        $0084  1623
TK_NEXT                        $0082  1621
TK_END                         $0080  1619
