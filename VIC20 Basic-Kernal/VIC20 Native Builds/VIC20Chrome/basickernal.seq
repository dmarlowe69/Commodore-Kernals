;***********************************************************************************;;***********************************************************************************;;; THE ALMOST COMPLETELY COMMENTED VIC 20 ROM DISASSEMBLY. V1.01 LEE DAVISON 2005-2012.; THIS IS A BIT CORRECT ASSEMBLY LISTING FOR THE VIC 20 BASIC AND KERNAL ROMS AS ONE 16K; ROM. YOU SHOULD BE ABLE TO ASSEMBLE THE VIC ROMS FROM THIS WITH MOST 6502 ASSEMBLERS,; AS NO MACROS OR 'SPECIAL' FEATURES WERE USED. THIS HAS BEEN TESTED USING MICHAL; KOWALSKI'S 6502 SIMULATOR ASSEMBLE FUNCTION. SEE HTTP://EXIFPRO.COM/UTILS.HTML FOR; THIS PROGRAM.; MANY REFERENCES WERE USED TO COMPLETE THIS DISASSEMBLY INCLUDING, BUT NOT LIMITED TO,; 'MAPPING THE VIC 20', 'MAPPING THE C64', 'VIC 20 PROGRAMMERS REFERENCE', 'VIC 20 USER; GUIDE', 'THE COMPLETE COMMODORE INNER SPACE ANTHOLOGY', 'VIC REVEALED' AND VARIOUS; TEXT FILES, PICTURES AND OTHER DOCUMENTS.;***********************************************************************************;;***********************************************************************************;;; FIRST A WHOLE LOAD OF EQUATES; THESE LOCATIONS CONTAIN THE JMP INSTRUCTION TARGET ADDRESS OF THE USR COMMAND. THEY; ARE INITIALISED SO THAT IF YOU TRY TO EXECUTE A USR CALL WITHOUT CHANGING THEM YOU; WIL RECEIVE AN ILLEGAL QUANTITY ERROR MESSAGE.XX00 = $00   ; USR() JMP INSTRUCTIONXX01 = $01   ; USR() VECTOR LOW BYTEXX02 = $02   ; USR() VECTOR HIGH BYTE; THIS VECTOR POINTS TO THE ADDRESS OF THE BASIC ROUTINE WHICH CONVERTS A FLOATING POINT; NUMBER TO AN INTEGER, HOWEVER BASIC DOES NOT USE THIS VECTOR. IT MAY BE OF ASSISTANCE; TO THE PROGRAMMER WHO WISHES TO USE DATA THAT IS STORED IN FLOATING POINT FORMAT. THE; PARAMETER PASSED BY THE USR COMMAND IS AVAILABLE ONLY IN THAT FORMAT FOR EXAMPLE.XX03 = $03   ; FLOAT TO FIXED VECTOR LOW BYTEXX04 = $04   ; FLOAT TO FIXED VECTOR HIGH BYTE; THIS VECTOR POINTS TO THE ADDRESS OF THE BASIC ROUTINE WHICH CONVERTS AN INTEGER TO A; FLOATING POINT NUMBER, HOWEVER BASIC DOES NOT USE THIS VECTOR. IT MAY BE USED BY THE; PROGRAMMER WHO NEEDS TO MAKE SUCH A CONVERSION FOR A MACHINE LANGUAGE PROGRAM THAT; INTERACTS WITH BASIC.  TO RETURN AN INTEGER VALUE WITH THE USR COMMAND FOR EXAMPLE.XX05 = $05   ; FIXED TO FLOAT VECTOR LOW BYTEXX06 = $06   ; FIXED TO FLOAT VECTOR HIGH BYTE; THE CURSOR COLUMN POSITION PRIOR TO THE TAB OR SPC IS MOVED HERE FROM $D3, AND IS USED; TO CALCULATE WHERE THE CURSOR ENDS UP AFTER ONE OF THESE FUNCTIONS IS INVOKED.; NOTE THAT THE VALUE CONTAINED HERE SHOWS THE POSITION OF THE CURSOR ON A LOGICAL LINE.; SINCE ONE LOGICAL LINE CAN BE UP TO FOUR PHYSICAL LINES LONG, THE VALUE STORED HERE; CAN RANGE FROM 0 TO 87.XX07 = $07   ; SEARCH CHARACTERXX08 = $08   ; SCAN QUOTES FLAGXX09 = $09   ; TAB COLUMN SAVE; THE ROUTINE THAT CONVERTS THE TEXT IN THE INPUT BUFFER INTO LINES OF EXECUTABLE PROGRAM; TOKES, AND THE ROUTINES THAT LINK THESE PROGRAM LINES TOGETHER, USE THIS LOCATION AS AN; INDEX INTO THE INPUT BUFFER AREA. AFTER THE JOB OF CONVERTING TEXT TO TOKENS IS DONE,; THE VALUE IN THIS LOCATION IS EQUAL TO THE LENGTH OF THE TOKENIZED LINE.; THE ROUTINES WHICH BUILD AN ARRAY OR LOCATE AN ELEMENT IN AN ARRAY USE THIS LOCATION TO; CALCULATE THE NUMBER OF DIMENSIONS CALLED FOR AND THE AMOUNT OF STORAGE REQUIRED FOR A; NEWLY CREATED ARRAY, OR THE NUMBER OF SUBSCRIPTS WHEN REFERENCING AN ARRAY ELEMENT.XX0A = $0A   ; LOAD/VERIFY FLAG, 0 = LOAD, 1 = VERIFYXX0B = $0B   ; TEMPORARY BYTE, LINE CRUNCH/ARRAY ACCESS/LOGIC OPERATORS; THIS IS USED AS A FLAG BY THE ROUTINES THAT BUILD AN ARRAY OR REFERENCE AN EXISTING; ARRAY. IT IS USED TO DETERMINE WHETHER A VARIABLE IS IN AN ARRAY, WHETHER THE ARRAY; HAS ALREADY BEEN DIMENSIONED, AND WHETHER A NEW ARRAY SHOULD ASSUME THE DEFAULT SIZE.XX0C = $0C   ; DIM FLAG; THIS FLAG IS USED TO INDICATE WHETHER DATA BEING OPERATED UPON IS STRING OR NUMERIC. A; VALUE OF $FF IN THIS LOCATION INDICATES STRING DATA WHILE A $00 INDICATES NUMERIC DATA.XX0D = $0D   ; DATA TYPE FLAG, $FF = STRING, $00 = NUMERIC; IF THE ABOVE FLAG INDICATES NUMERIC THEN A $80 IN THIS LOCATION IDENTIFIES THE NUMBER; AS AN INTEGER, AND A $00 INDICATES A FLOATING POINT NUMBER.XX0E = $0E   ; DATA TYPE FLAG, $80 = INTEGER, $00 = FLOATING POINT; THE GARBAGE COLLECTION ROUTINE USES THIS LOCATION AS A FLAG TO INDICATE THAT GARBAGE; COLLECTION HAS ALREADY BEEN TRIED BEFORE ADDING A NEW STRING. IF THERE IS STILL NOT; ENOUGH MEMORY, AN OUT OF MEMORY ERROR MESSAGE WILL RESULT.; LIST USES THIS BYTE AS A FLAG TO LET IT KNOW WHEN IT HAS COME TO A CHARACTER STRING IN; QUOTES. IT WILL THEN PRINT THE STRING,RATHER THAN SEARCH IT FOR BASIC KEYWORD TOKENS.; THIS LOCATION IS ALSO USED DURING THE PROCESS OF CONVERTING A LINE OF TEXT IN THE BASIC; INPUT BUFFER INTO A LINKED PROGRAM LINE OF BASIC KEYWORD TOKENS TO FLAG A DATA LINE IS; BEING PROCESSED.XX0F = $0F   ; GARBAGE COLLECTED/OPEN QUOTE/DATA FLAG; IF AN OPENING PARENTHESIS IS FOUND, THIS FLAG IS SET TO INDICATE THAT THE VARIABLE IN; QUESTION IS EITHER AN ARRAY VARIABLE OR A USER-DEFINED FUNCTION.XX10 = $10   ; SUBSCRIPT/FNX FLAG; THIS LOCATION IS USED TO DETERMINE WHETHER THE SIGN OF THE VALUE RETURNED BY THE; FUNCTIONS SIN, COS, ATN OR TAN IS POSITIVE OR NEGATIVE.; ALSO THE COMPARISON ROUTINES USE THIS LOCATION TO INDICATE THE OUTCOME OF THE COMPARE.; FOR A <=> B THE VALUE HERE WILL BE $01 IF A > B, $02 IF A = B, AND $04 IF A < B. IF; MORE THAN ONE COMPARISON OPERATOR WAS USED TO COMPARE THE TWO VARIABLES THEN THE VALUE; HERE WILL BE A COMBINATION OF THE ABOVE VALUES.XX11 = $11   ; INPUT MODE FLAG, $00 = INPUT, $40 = GET, $98 = READXX12 = $12   ; ATN SIGN/COMPARISON EVALUATION FLAG; WHEN THE DEFAULT INPUT OR OUTPUT DEVICE IS USED THE VALUE HERE WILL BE A ZERO, AND THE; FORMAT OF PROMPTING AND OUTPUT WILL BE THE STANDARD SCREEN OUTPUT FORMAT. THE LOCATION; $B8 IS USED TO DECIDE WHAT DEVICE ACTUALLY TO PUT INPUT FROM OR OUTPUT TO.; THE PRINT CR/LF CODE AT XXCAD7 SUGGESTS THAT B7 OF THIS BYTE IS AN AUTOLF FLAG BIT; BUT IF IT IS USED AS SUCH IT WOULD BREAK LOTS OF OTHER PARTS OF THE CODEXX13 = $13   ; CURRENT I/O CHANNEL; USED WHENEVER A 16 BIT INTEGER IS USED E.G. THE TARGET LINE NUMBER FOR GOTO, LIST, ON,; AND GOSUB ALSO THE NUMBER OF A BASIC LINE THAT IS TO BE ADDED OR REPLACED. ADDITIONALLY; PEEK, POKE, WAIT, AND SYS USE THIS LOCATION AS A POINTER TO THE ADDRESS WHICH IS THE; SUBJECT OF THE COMMAND.XX14 = $14   ; TEMPORARY INTEGER LOW BYTEXX15 = $15   ; TEMPORARY INTEGER HIGH BYTE; THIS LOCATION POINTS TO THE NEXT AVAILABLE SLOT IN THE TEMPORARY STRING DESCRIPTOR; STACK LOCATED AT $19-$21.XX16 = $16   ; DESCRIPTOR STACK POINTER, NEXT FREE; THIS CONTAINS INFORMATION ABOUT TEMPORARY STRINGS WHICH HVE NOT YET BEEN ASSIGNED TO; A STRING VARIABLE.XX17 = $17   ; CURRENT DESCRIPTOR STACK ITEM POINTER LOW BYTEXX18 = $18   ; CURRENT DESCRIPTOR STACK ITEM POINTER HIGH BYTEXX19 = $19   ; TO $21, DESCRIPTOR STACK; THESE LOCATIONS ARE USED BY BASIC MULTIPLICATION AND DIVISION ROUTINES. THEY ARE ALSO; USED BY THE ROUTINES WHICH COMPUTE THE SIZE OF THE AREA REQUIRED TO STORE AN ARRAY; WHICH IS BEING CREATED.XX22 = $22   ; MISC TEMP BYTEXX23 = $23   ; MISC TEMP BYTEXX24 = $24   ; MISC TEMP BYTEXX25 = $25   ; MISC TEMP BYTEXX26 = $26   ; TEMP MANTISSA 1XX27 = $27   ; TEMP MANTISSA 2XX28 = $28   ; TEMP MANTISSA 3XX29 = $29   ; TEMP MANTISSA 4; TWO BYTE POINTER TO WHERE THE BASIC PROGRAM TEXT IS STORED.XX2B = $2B   ; START OF MEMORY LOW BYTEXX2C = $2C   ; START OF MEMORY HIGH BYTE; TWO BYTE POINTER TO THE START OF THE BASIC VARIABLE STORAGE AREA.XX2D = $2D   ; START OF VARIABLES LOW BYTEXX2E = $2E   ; START OF VARIABLES HIGH BYTE; TWO BYTE POINTER TO THE START OF THE BASIC ARRAY STORAGE AREA.XX2F = $2F   ; END OF VARIABLES LOW BYTEXX30 = $30   ; END OF VARIABLES HIGH BYTE; TWO BYTE POINTER TO END OF THE START OF FREE RAM.XX31 = $31   ; END OF ARRAYS LOW BYTEXX32 = $32   ; END OF ARRAYS HIGH BYTE; TWO BYTE POINTER TO THE BOTTOM OF THE STRING TEXT STORAGE AREA.XX33 = $33   ; BOTTOM OF STRING SPACE LOW BYTEXX34 = $34   ; BOTTOM OF STRING SPACE HIGH BYTE; USED AS A TEMPORARY POINTER TO THE MOST CURRENT STRING ADDED BY THE ROUTINES WHICH; BUILD STRINGS OR MOVE THEM IN MEMORY.XX35 = $35   ; STRING UTILITY PTR LOW BYTEXX36 = $36   ; STRING UTILITY PTR HIGH BYTE; TWO BYTE POINTER TO THE HIGHEST ADDRESS USED BY BASIC +1.XX37 = $37   ; END OF MEMORY LOW BYTEXX38 = $38   ; END OF MEMORY HIGH BYTE; THESE LOCATIONS CONTAIN THE LINE NUMBER OF THE BASIC STATEMENT WHICH IS CURRENTLY BEING; EXECUTED. A VALUE OF $FF IN LOCATION $3A MEANS THAT BASIC IS IN IMMEDIATE MODE.XX39 = $39   ; CURRENT LINE NUMBER LOW BYTEXX3A = $3A   ; CURRENT LINE NUMBER HIGH BYTE; WHEN PROGRAM EXECUTION ENDS OR STOPS THE LAST LINE NUMBER EXECUTED IS STORED HERE.XX3B = $3B   ; BREAK LINE NUMBER LOW BYTEXX3C = $3C   ; BREAK LINE NUMBER HIGH BYTE; THESE LOCATIONS CONTAIN THE ADDRESS OF THE START OF THE TEXT OF THE BASIC STATEMENT; THAT IS BEING EXECUTED.  THE VALUE OF THE POINTER TO THE ADDRESS OF THE BASIC TEXT; CHARACTER CURRENTLY BEING SCANNED IS STORED HERE EACH TIME A NEW BASIC STATEMENT BEGINS; EXECUTION.XX3D = $3D   ; CONTINUE POINTER LOW BYTEXX3E = $3E   ; CONTINUE POINTER HIGH BYTE; THESE LOCATIONS HOLD THE LINE NUMBER OF THE CURRENT DATA STATEMENT BEING READ. IF AN; ERROR CONCERNING THE DATA OCCURS THIS NUMBER WILL BE MOVED TO $39/$3A SO THAT THE ERROR; MESSAGE WILL SHOW THE LINE THAT CONTAINS THE DATA STATEMENT RATHER THAN IN THE LINE THAT; CONTAINS THE READ STATEMENT.XX3F = $3F   ; CURRENT DATA LINE NUMBER LOW BYTEXX40 = $40   ; CURRENT DATA LINE NUMBER HIGH BYTE; THESE LOCATIONS POINT TO THE ADDRESS WHERE THE NEXT DATA WILL BE READ FROM. RESTORE; SETS THIS POINTER BACK TO THE ADDRESS INDICATED BY THE START OF BASIC POINTER.XX41 = $41   ; DATA POINTER LOW BYTEXX42 = $42   ; DATA POINTER HIGH BYTE; READ, INPUT AND GET ALL USE THIS AS A POINTER TO THE ADDRESS OF THE SOURCE OF INCOMING; DATA, SUCH AS DATA STATEMENTS, OR THE TEXT INPUT BUFFER.XX43 = $43   ; READ POINTER LOW BYTEXX44 = $44   ; READ POINTER HIGH BYTEXX45 = $45   ; CURRENT VARIABLE NAME FIRST BYTEXX46 = $46   ; CURRENT VARIABLE NAME SECOND BYTE; THESE LOCATIONS POINT TO THE VALUE OF THE CURRENT BASIC VARIABLE SPECIFICALLY THEY; POINT TO THE BYTE JUST AFTER THE TWO-CHARACTER VARIABLE NAME.XX47 = $47   ; CURRENT VARIABLE ADDRESS LOW BYTEXX48 = $48   ; CURRENT VARIABLE ADDRESS HIGH BYTE; THE ADDRESS OF THE BASIC VARIABLE WHICH IS THE SUBJECT OF A FOR/NEXT LOOP IS FIRST; STORED HERE BEFORE BEING PUSHED ONTO THE STACK.XX49 = $49   ; FOR/NEXT VARIABLE POINTER LOW BYTEXX4A = $4A   ; FOR/NEXT VARIABLE POINTER HIGH BYTE; THE EXPRESSION EVALUATION ROUTINE CREATES THIS TO LET IT KNOW WHETHER THE CURRENT; COMPARISON OPERATION IS A < $01, = $02 OR > $04 COMPARISON OR COMBINATION.XX4B = $4B   ; BASIC EXECUTE POINTER TEMPORARY LOW BYTE/PRECEDENCE FLAGXX4C = $4C   ; BASIC EXECUTE POINTER TEMPORARY HIGH BYTEXX4D = $4D   ; COMPARRISON EVALUATION FLAG; THESE LOCATIONS ARE USED AS A POINTER TO THE FUNCTION THAT IS CREATED DURING FUNCTION; DEFINITION . DURING FUNCTION EXECUTION IT POINTS TO WHERE THE EVALUATION RESULTS SHOULD; BE SAVED.XX4E = $4E   ; FAC TEMP STORE/FUNCTION/VARIABLE/GARBAGE POINTER LOW BYTEXX4F = $4F   ; FAC TEMP STORE/FUNCTION/VARIABLE/GARBAGE POINTER HIGH BYTE; TEMPORARY POINTER TO THE CURRENT STRING DESCRIPTOR.XX50 = $50   ; FAC TEMP STORE/DESCRIPTOR POINTER LOW BYTEXX51 = $51   ; FAC TEMP STORE/DESCRIPTOR POINTER HIGH BYTEXX53 = $53   ; GARBAGE COLLECTION STEP SIZE; THE FIRST BYTE IS THE 6502 JMP INSTRUCTION $4C, FOLLOWED BY THE ADDRESS OF THE REQUIRED; FUNCTION TAKEN FROM THE TABLE AT $C052.XX54 = $54   ; JMP OPCODE FOR FUNCTIONSXX55 = $55   ; FUNCTIONS JUMP VECTOR LOW BYTEXX56 = $56   ; FUNCTIONS JUMP VECTOR HIGH BYTEXX57 = $57   ; FAC TEMP STOREXX58 = $58   ; FAC TEMP STOREXX59 = $59   ; FAC TEMP STOREXX5A = $5A   ; FAC TEMP STOREXX5B = $5B   ; BLOCK END HIGH BYTEXX5C = $5C   ; FAC TEMP STOREXX5D = $5D   ; FAC TEMP STOREXX5E = $5E   ; FAC TEMP STOREXX5F = $5F   ; FAC TEMP STOREXX60 = $60   ; BLOCK START HIGH BYTEXX61 = $61   ; FAC1 EXPONENTXX62 = $62   ; FAC1 MANTISSA 1XX63 = $63   ; FAC1 MANTISSA 2XX64 = $64   ; FAC1 MANTISSA 3XX65 = $65   ; FAC1 MANTISSA 4XX66 = $66   ; FAC1 SIGNXX67 = $67   ; CONSTANT COUNT/-VE FLAGXX68 = $68   ; FAC1 OVERFLOWXX69 = $69   ; FAC2 EXPONENTXX6A = $6A   ; FAC2 MANTISSA 1XX6B = $6B   ; FAC2 MANTISSA 2XX6C = $6C   ; FAC2 MANTISSA 3XX6D = $6D   ; FAC2 MANTISSA 4XX6E = $6E   ; FAC2 SIGNXX6F = $6F   ; FAC SIGN COMPARRISONXX70 = $70   ; FAC1 ROUNDINGXX71 = $71   ; TEMP BASIC EXECUTE/ARRAY POINTER LOW BYTE/INDEXXX72 = $72   ; TEMP BASIC EXECUTE/ARRAY POINTER HIGH BYTEXX0073 = $73   ; INCREMENT AND SCAN MEMORY, BASIC BYTE GETXX0079 = $79   ; SCAN MEMORY, BASIC BYTE GETXX7A = $7A   ; BASIC EXECUTE POINTER LOW BYTEXX7B = $7B   ; BASIC EXECUTE POINTER HIGH BYTEXX80 = $80   ; NUMERIC TEST ENTRYXX008B = $8B   ; RND() SEED, FIVE BYTESXX90 = $90   ; SERIAL STATUS BYTE     ; FUNCTION     ; BIT CASETTE  SERIAL BUS     ; --- --------  ----------     ;  7 END OF TAPE  DEVICE NOT PRESENT     ;  6 END OF FILE  EOI     ;  5 CHECKSUM ERROR     ;  4 READ ERROR     ;  3 LONG BLOCK     ;  2 SHORT BLOCK     ;  1    TIME OUT READ     ;  0    TIME OUT WRITEXX91 = $91   ; KEYBOARD ROW, BX = 0 = KEY DOWN     ; BIT KEY     ; --- ------     ;  7 [DOWN]     ;  6 /     ;  5 ,     ;  4 N     ;  3 V     ;  2 X     ;  1 [L SHIFT]     ;  0 [STOP]XX92 = $92   ; TIMING CONSTANT FOR TAPE READXX93 = $93   ; LOAD/VERIFY FLAG, LOAD = $00, VERIFY = $01XX94 = $94   ; SERIAL OUTPUT: DEFERRED CHARACTER FLAG     ; $00 = NO CHARACTER WAITING, $XX = CHARACTER WAITINGXX95 = $95   ; SERIAL OUTPUT: DEFERRED CHARACTER     ; $FF = NO CHARACTER WAITING, $XX = WAITING CHARACTERXX96 = $96   ; CASSETTE BLOCK SYNCHRONIZATION NUMBERXX97 = $97   ; REGISTER SAVE; THE NUMBER OF CURRENTLY OPEN I/O FILES IS STORED HERE. THE MAXIMUM NUMBER THAT CAN BE; OPEN AT ONE TIME IS TEN. THE NUMBER STORED HERE IS USED AS THE INDEX TO THE END OF THE; TABLES THAT HOLD THE FILE NUMBERS, DEVICE NUMBERS, AND SECONDARY ADDRESSES.XX98 = $98   ; OPEN FILE COUNT; THE DEFAULT VALUE OF THIS LOCATION IS 0.XX99 = $99   ; INPUT DEVICE NUMBER; THE DEFAULT VALUE OF THIS LOCATION IS 3.XX9A = $9A   ; OUTPUT DEVICE NUMBER;; NUMBER DEVICE; ------ ------;  0  KEYBOARD;  1  CASSETTE;  2  RS-232C;  3  SCREEN;  4-31 SERIAL BUSXX9B = $9B   ; TAPE CHARACTER PARITYXX9C = $9C   ; BYTE RECEIVED FLAGXX9D = $9D   ; MESSAGE MODE FLAG,; $C0 = BOTH CONTROL AND KERNAL MESSAGES,; $80 = CONTROL MESSAGES ONLY,; $40 = KERNAL MESSAGES ONLY,; $00 = NEITHER CONTROL OR KERNAL MESSAGESXX9E = $9E   ; TAPE PASS 1 ERROR LOG/CHARACTER BUFFERXX9F = $9F   ; TAPE PASS 2 ERROR LOG CORRECTED; THESE THREE LOCATIONS FORM A COUNTER WHICH IS UPDATED 60 TIMES A SECOND, AND SERVES AS; A SOFTWARE CLOCK WHICH COUNTS THE NUMBER OF JIFFIES THAT HAVE ELAPSED SINCE THE COMPUTER; WAS TURNED ON. AFTER 24 HOURS AND ONE JIFFY THESE LOCATIONS ARE SET BACK TO $000000.XXA0 = $A0   ; JIFFY CLOCK HIGH BYTEXXA1 = $A1   ; JIFFY CLOCK MID BYTEXXA2 = $A2   ; JIFFY CLOCK LOW BYTEXXA3 = $A3   ; EOI FLAG BYTE/TAPE BIT COUNT; B0 OF THIS LOCATION REFLECTS THE CURRENT PHASE OF THE TAPE OUTPUT CYCLE.XXA4 = $A4   ; TAPE BIT CYCLE PHASEXXA5 = $A5   ; CASSETTE SYNCHRONIZATION BYTE COUNT/SERIAL BUS BIT COUNTXXA6 = $A6   ; TAPE BUFFER INDEXXXA7 = $A7   ; RECEIVER INPUT BIT TEMP STORAGEXXA8 = $A8   ; RECEIVER BIT COUNT INXXA9 = $A9   ; RECEIVER START BIT CHECK FLAG, $90 = NO START BIT; RECEIVED, $00 = START BIT RECEIVEDXXAA = $AA   ; RECEIVER BYTE BUFFER/ASSEMBLY LOCATIONXXAB = $AB   ; RECEIVER PARITY BIT STORAGEXXAC = $AC   ; TAPE BUFFER START POINTER LOW BYTE; SCROLL SCREEN ?? BYTEXXAD = $AD   ; TAPE BUFFER START POINTER HIGH BYTE; SCROLL SCREEN ?? BYTEXXAE = $AE   ; TAPE BUFFER END POINTER LOW BYTE; SCROLL SCREEN ?? BYTEXXAF = $AF   ; TAPE BUFFER END POINTER HIGH BYTE; SCROLL SCREEN ?? BYTEXXB0 = $B0   ; TAPE TIMING CONSTANT MIN BYTEXXB1 = $B1   ; TAPE TIMING CONSTANT MAX BYTE; THESS TWO LOCATIONS POINT TO THE ADDRESS OF THE CASSETTE BUFFER. THIS POINTER MUST; BE GREATER THAN OR EQUAL TO $0200 OR AN ILLEGAL DEVICE NUMBER ERROR WILL BE SENT; WHEN TAPE I/O IS TRIED. THIS POINTER MUST ALSO BE LESS THAT $8000 OR THE ROUTINE; WILL TERMINATE EARLY.XXB2 = $B2   ; TAPE BUFFER START POINTER LOW BYTEXXB3 = $B3   ; TAPE BUFFER START POINTER HIGH BYTE; RS232 ROUTINES USE THIS TO COUNT THE NUMBER OF BITS TRANSMITTED AND FOR PARITY AND; STOP BIT MANIPULATION. TAPE LOAD ROUTINES USE THIS LOCATION TO FLAG WHEN THEY ARE; READY TO RECEIVE DATA BYTES.XXB4 = $B4   ; TRANSMITTER BIT COUNT OUT; THIS LOCATION IS USED BY THE RS232 ROUTINES TO HOLD THE NEXT BIT TO BE SENT AND BY THE; TAPE ROUTINES TO INDICATE WHAT PART OF A BLOCK THE READ ROUTINE IS CURRENTLY READING.XXB5 = $B5   ; TRANSMITTER NEXT BIT TO BE SENT; RS232 ROUTINES USE THIS AREA TO DISASSEMBLE EACH BYTE TO BE SENT FROM THE TRANSMISSION; BUFFER POINTED TO BY $F9.XXB6 = $B6   ; TRANSMITTER BYTE BUFFER/DISASSEMBLY LOCATION; DISK FILENAMES MAY BE UP TO 16 CHARACTERS IN LENGTH WHILE TAPE FILENAMES BE UP TO 187; CHARACTERS IN LENGTH.; IF A TAPE NAME IS LONGER THAN 16 CHARACTERS THE EXCESS WILL BE TRUNCATED BY THE; SEARCHING AND FOUND MESSAGES, BUT WILL STILL BE PRESENT ON THE TAPE.; A DISK FILE IS ALWAYS REFERRED TO BY A NAME. THIS LOCATION WILL ALWAYS BE GREATER THAN; ZERO IF THE CURRENT FILE IS A DISK FILE.; AN RS232 OPEN COMMAND MAY SPECIFY A FILENAME OF UP TO FOUR CHARACTERS. THESE CHARACTERS; ARE COPIED TO LOCATIONS $293 TO $296 AND DETERMINE BAUD RATE, WORD LENGTH, AND PARITY,; OR THEY WOULD DO IF THE FEATURE WAS FULLY IMPLEMENTED.XXB7 = $B7   ; FILE NAME LENGTHXXB8 = $B8   ; LOGICAL FILEXXB9 = $B9   ; SECONDARY ADDRESSXXBA = $BA   ; CURRENT DEVICE NUMBER; NUMBER DEVICE; ------ ------;  0  KEYBOARD;  1  CASSETTE;  2  RS-232C;  3  SCREEN;  4-31 SERIAL BUSXXBB = $BB   ; FILE NAME POINTER LOW BYTEXXBC = $BC   ; FILE NAME POINTER HIGH BYTEXXBD = $BD   ; TAPE WRITE BYTE/RS232 PARITY BYTE; USED BY THE TAPE ROUTINES TO COUNT THE NUMBER OF COPIES OF A DATA BLOCK REMAINING TO; BE READ OR WRITTEN.XXBE = $BE   ; TAPE COPIES COUNTXXBF = $BF   ; PARITY COUNT ??XXC0 = $C0   ; TAPE MOTOR INTERLOCKXXC1 = $C1   ; I/O START ADDRESSES LOW BYTEXXC2 = $C2   ; I/O START ADDRESSES HIGH BYTEXXC3 = $C3   ; KERNAL SETUP POINTER LOW BYTEXXC4 = $C4   ; KERNAL SETUP POINTER HIGH BYTEXXC5 = $C5   ; CURRENT KEY PRESSED;;  # KEY  # KEY  # KEY  # KEY; -- --- -- --- -- --- -- ---; 00 1 10 NONE 20 [SPACE] 30 Q; 01 3 11 A  21 Z  31 E; 02 5 12 D  22 C  32 T; 03 7 13 G  23 B  33 U; 04 9 14 J  24 M  34 O; 05 + 15 L  25 .  35 @; 06 [UKP] 16 ;  26 NONE 36 ^; 07 [DEL] 17 [CSR R] 27 [F1] 37 [F5]; 08 [<-] 18 [STOP] 28 NONE 38 2; 09 W 19 NONE 29 S  39 4; 0A R 1A X  2A F  3A 6; 0B Y 1B V  2B H  3B 8; 0C I 1C N  2C K  3C 0; 0D P 1D ,  2D :  3D -; 0E * 1E /  2E =  3E [HOME]; 0F [RET] 1F [CSR D] 2F [F3] 3F [F7]XXC6 = $C6   ; KEYBOARD BUFFER LENGTH/INDEX; WHEN THE [CTRL][RVS-ON] CHARACTERS ARE PRINTED THIS FLAG IS SET TO $12, AND THE PRINT; ROUTINES WILL ADD $80 TO THE SCREEN CODE OF EACH CHARACTER WHICH IS PRINTED, SO THAT; THE CARACTER WILL APPEAR ON THE SCREEN WITH ITS COLOURS REVERSED.; NOTE THAT THE CONTENTS OF THIS LOCATION ARE CLEARED NOT ONLY UPON ENTRY OF A; [CTRL][RVS-OFF] CHARACTER BUT ALSO AT EVERY CARRIAGE RETURN.XXC7 = $C7   ; REVERSE FLAG $12 = REVERSE, $00 = NORMAL; THIS POINTER INDICATES THE COLUMN NUMBER OF THE LAST NONBLANK CHARACTER ON THE LOGICAL; LINE THAT IS TO BE INPUT. SINCE A LOGICAL LINE CAN BE UP TO 88 CHARACTERS LONG THIS; NUMBER CAN RANGE FROM 0-87.XXC8 = $C8   ; INPUT [EOL] POINTER; THESE LOCATIONS KEEP TRACK OF THE LOGICAL LINE THAT THE CURSOR IS ON AND ITS COLUMN; POSITION ON THAT LOGICAL LINE.; EACH LOGICAL LINE MAY CONTAIN UP TO FOUR 22 COLUMN PHYSICAL LINES. SO THERE MAY BE AS; MANY AS 23 LOGICAL LINES, OR AS FEW AS 6 AT ANY ONE TIME. THEREFORE, THE LOGICAL LINE; NUMBER MIGHT BE ANYWHERE FROM 1-23. DEPENDING ON THE LENGTH OF THE LOGICAL LINE, THE; CURSOR COLUMN MAY BE FROM 1-22, 1-44, 1-66 OR 1-88.; FOR A MORE ON LOGICAL LINES, SEE THE DESCRIPTION OF THE SCREEN LINE LINK TABLE, $D9.XXC9 = $C9   ; INPUT CURSOR ROWXXCA = $CA   ; INPUT CURSOR COLUMN; THE KEYSCAN INTERRUPT ROUTINE USES THIS LOCATION TO INDICATE WHICH KEY IS CURRENTLY; BEING PRESSED. THE VALUE HERE IS THEN USED AS AN INDEX INTO THE APPROPRIATE KEYBOARD; TABLE TO DETERMINE WHICH CHARACTER TO PRINT WHEN A KEY IS STRUCK.; THE CORRESPONDENCE BETWEEN THE KEY PRESSED AND THE NUMBER STORED HERE IS AS FOLLOWS:; $00 1  $10 NOT USED $20 [SPACE] $30 Q  $40 [NO KEY]; $01 3  $11 A  $21 Z  $31 E  $XX INVALID; $02 5  $12 D  $22 C  $32 T; $03 7  $13 G  $23 B  $33 U; $04 9  $14 J  $24 M  $34 O; $05 +  $15 L  $25 .  $35 @; $06 [POUND] $16 ;  $26 NOT USED $36 [U ARROW]; $07 [DEL]  $17 [RIGHT] $27 [F1]  $37 [F5] ; $08 [L ARROW] $18 [STOP] $28 NOT USED $38 2; $09 W  $19 NOT USED $29 S  $39 4; $0A R  $1A X  $2A F  $3A 6; $0B Y  $1B V  $2B H  $3B 8; $0C I  $1C N  $2C K  $3C 0; $0D P  $1D ,  $2D :  $3D -; $0E *  $1E /  $2E =  $3E [HOME]; $0F [RETURN] $1F [DOWN] $2F [F3]  $3F [F7]XXCB = $CB   ; WHICH KEY; WHEN THIS FLAG IS SET TO A NONZERO VALUE, IT INDICATES TO THE ROUTINE THAT NORMALLY; FLASHES THE CURSOR NOT TO DO SO. THE CURSOR BLINK IS TURNED OFF WHEN THERE ARE; CHARACTERS IN THE KEYBOARD BUFFER, OR WHEN THE PROGRAM IS RUNNING.XXCC = $CC   ; CURSOR ENABLE, $00 = FLASH CURSOR; THE ROUTINE THAT BLINKS THE CURSOR USES THIS LOCATION TO TELL WHEN IT'S TIME FOR A; BLINK. THE NUMBER 20 IS PUT HERE AND DECREMENTED EVERY JIFFY UNTIL IT REACHES ZERO.; THEN THE CURSOR STATE IS CHANGED, THE NUMBER 20 IS PUT BACK HERE, AND THE CYCLE STARTS; ALL OVER AGAIN.XXCD = $CD   ; CURSOR TIMING COUNTDOWN; THE CURSOR IS FORMED BY PRINTING THE INVERSE OF THE CHARACTER THAT OCCUPIES THE CURSOR; POSITION. IF THAT CHARACTERS IS THE LETTER A, FOR EXAMPLE, THE FLASHING CURSOR MERELY; ALTERNATES BETWEEN PRINTING AN A AND A REVERSE-A. THIS LOCATION KEEPS TRACK OF THE; NORMAL SCREEN CODE OF THE CHARACTER THAT IS LOCATED AT THE CURSOR POSITION, SO THAT IT; MAY BE RESTORED WHEN THE CURSOR MOVES ON.XXCE = $CE   ; CHARACTER UNDER CURSOR; THIS LOCATION KEEPS TRACK OF WHETHER, DURING THE CURRENT CURSOR BLINK, THE CHARACTER; UNDER THE CURSOR WAS REVERSED, OR WAS RESTORED TO NORMAL. THIS LOCATION WILL CONTAIN; $00 IF THE CHARACTER IS REVERSED, AND $01 IF THE CHARACTER IS NOT REVERSED.XXCF = $CF   ; CURSOR BLINK PHASEXXD0 = $D0   ; INPUT FROM KEYBOARD OR SCREEN, $XX = INPUT IS AVAILABLE; FROM THE SCREEN, $00 = INPUT SHOULD BE OBTAINED FROM THE; KEYBOARD; THESE LOCATIONS POINT TO THE ADDRESS IN SCREEN RAM OF THE FIRST COLUMN OF THE LOGICAL; LINE UPON WHICH THE CURSOR IS CURRENTLY POSITIONED.XXD1 = $D1   ; CURRENT SCREEN LINE POINTER LOW BYTEXXD2 = $D2   ; CURRENT SCREEN LINE POINTER HIGH BYTE; THIS HOLDS THE CURSOR COLUMN POSITION WITHIN THE LOGICAL LINE POINTED TO BY XXD1.; SINCE A LOGICAL LINE CAN COMPRISE UP TO FOUR PHYSICAL LINES, THIS VALUE MAY BE FROM; $00 TO $57.XXD3 = $D3   ; CURSOR COLUMN; A NONZERO VALUE IN THIS LOCATION INDICATES THAT THE EDITOR IS IN QUOTE MODE. QUOTE; MODE IS TOGGLED EVERY TIME THAT YOU TYPE IN A QUOTATION MARK ON A GIVEN LINE, THE; FIRST QUOTE MARK TURNS IT ON, THE SECOND TURNS IT OFF, THE THIRD TURNS IT ON, ETC.; IF THE EDITOR IS IN THIS MODE WHEN A CURSOR CONTROL CHARACTER OR OTHER NONPRINTING; CHARACTER IS ENTERED, A PRINTED EQUIVALENT WILL APPEAR ON THE SCREEN INSTEAD OF THE; CURSOR MOVEMENT OR OTHER CONTROL OPERATION TAKING PLACE. INSTEAD, THAT ACTION IS; DEFERRED UNTIL THE STRING IS SENT TO THE STRING BY A PRINT STATEMENT, AT WHICH TIME; THE CURSOR MOVEMENT OR OTHER CONTROL OPERATION WILL TAKE PLACE.; THE EXCEPTION TO THIS RULE IS THE DELETE KEY, WHICH WILL FUNCTION NORMALLY WITHIN; QUOTE MODE. THE ONLY WAY TO PRINT A CHARACTER WHICH IS EQUIVALENT TO THE DELETE KEY; IS BY ENTERING INSERT MODE. QUOTE MODE MAY BE EXITED BY PRINTING A CLOSING QUOTE OR; BY HITTING THE RETURN OR SHIFT-RETURN KEYS.XXD4 = $D4   ; CURSOR QUOTE FLAG; THE LINE EDITOR USES THIS LOCATION WHEN THE END OF A LINE HAS BEEN REACHED TO DETERMINE; WHETHER ANOTHER PHYSICAL LINE CAN BE ADDED TO THE CURRENT LOGICAL LINE OR IF A NEW; LOGICAL LINE MUST BE STARTED.XXD5 = $D5   ; CURRENT SCREEN LINE LENGTH; THIS LOCATION CONTAINS THE CURRENT PHYSICAL SCREEN LINE POSITION OF THE CURSOR, 0 TO 22.XXD6 = $D6   ; CURSOR ROW; THE ASCII VALUE OF THE LAST CHARACTER PRINTED TO THE SCREEN IS HELD HERE TEMPORARILY.XXD7 = $D7   ; CHECKSUM BYTE/TEMPORARY LAST CHARACTER; WHEN THE INST KEY IS PRESSED, THE SCREEN EDITOR SHIFTS THE LINE TO THE RIGHT, ALLOCATES; ANOTHER PHYSICAL LINE TO THE LOGICAL LINE IF NECESSARY (AND POSSIBLE), UPDATES THE; SCREEN LINE LENGTH IN $D5, AND ADJUSTS THE SCREEN LINE LINK TABLE AT $D9. THIS LOCATION; IS USED TO KEEP TRACK OF THE NUMBER OF SPACES THAT HAS BEEN OPENED UP IN THIS WAY.; UNTIL THE SPACES THAT HAVE BEEN OPENED UP ARE FILLED, THE EDITOR ACTS AS IF IN QUOTE; MODE. SEE LOCATION $D4, THE QUOTE MODE FLAG. THIS MEANS THAT CURSOR CONTROL CHARACTERS; THAT ARE NORMALLY NONPRINTING WILL LEAVE A PRINTED EQUIVALENT ON THE SCREEN WHEN; ENTERED, INSTEAD OF HAVING THEIR NORMAL EFFECT ON CURSOR MOVEMENT, ETC. THE ONLY; DIFFERENCE BETWEEN INSERT AND QUOTE MODE IS THAT THE DELETE KEY WILL LEAVE A PRINTED; EQUIVALENT IN INSERT MODE, WHILE THE INSERT KEY WILL INSERT SPACES AS NORMAL.XXD8 = $D8   ; INSERT COUNT; THIS TABLE CONTAINS 23 ENTRIES, ONE FOR EACH ROW OF THE SCREEN DISPLAY. EACH ENTRY HAS; TWO FUNCTIONS. BITS 0-3 INDICATE ON WHICH OF THE FOUR PAGES OF SCREEN MEMORY THE FIRST; BYTE OF MEMORY FOR THAT ROW IS LOCATED. THIS IS USED IN CALCULATING THE POINTER TO THE; STARTING ADDRESS OF A SCREEN LINE AT $D1.;; THE HIGH BYTE IS CALCULATED BY ADDING THE VALUE OF THE STARTING PAGE OF SCREEN MEMORY; HELD IN $288 TO THE DISPLACEMENT PAGE HELD HERE.;; THE OTHER FUNCTION OF THIS TABLE IS TO ESTABLISH THE MAKEUP OF LOGICAL LINES ON THE; SCREEN. WHILE EACH SCREEN LINE IS ONLY 22 CHARACTERS LONG, BASIC ALLOWS THE ENTRY OF; PROGRAM LINES THAT CONTAIN UP TO 88 CHARACTERS. THEREFORE, SOME METHOD MUST BE USED; TO DETERMINE WHICH PHYSICAL LINES ARE LINKED INTO A LONGER LOGICAL LINE, SO THAT THIS; LONGER LOGICAL LINE MAY BE EDITED AS A UNIT.;; THE HIGH BIT OF EACH BYTE HERE IS USED AS A FLAG BY THE SCREEN EDITOR. THAT BIT IS SET; WHEN A LINE IS THE FIRST OR ONLY PHYSICAL LINE IN A LOGICAL LINE. THE HIGH BIT IS RESET; TO 0 ONLY WHEN A LINE IS AN EXTENSION TO THIS LOGICAL LINE.XXD9 = $D9   ; TO XXD9 + $18 INCLUSIVE, SCREEN LINE LINK TABLE; THIS POINTER IS SYNCHRONIZED WITH THE POINTER TO THE ADDRESS OF THE FIRST BYTE OF; SCREEN RAM FOR THE CURRENT LINE KEPT IN LOCATION $D1. IT HOLDS THE ADDRESS OF THE; FIRST BYTE OF COLOUR RAM FOR THE CORRESPONDING SCREEN LINE.XXF2 = $F2   ; SCREEN ROW MARKERXXF3 = $F3   ; COLOUR RAM POINTER LOW BYTEXXF4 = $F4   ; COLOUR RAM POINTER HIGH BYTE; THIS POINTER POINTS TO THE ADDRESS OF THE KEYBOARD MATRIX LOOKUP TABLE CURRENTLY BEING; USED. ALTHOUGH THERE ARE ONLY 64 KEYS ON THE KEYBOARD MATRIX, EACH KEY CAN BE USED TO; PRINT UP TO FOUR DIFFERENT CHARACTERS, DEPENDING ON WHETHER IT IS STRUCK BY ITSELF OR; IN COMBINATION WITH THE SHIFT, CTRL, OR C= KEYS.; THESE TABLES HOLD THE ASCII VALUE OF EACH OF THE 64 KEYS FOR ONE OF THESE POSSIBLE; COMBINATIONS OF KEYPRESSES. WHEN IT COMES TIME TO PRINT THE CHARACTER, THE TABLE THAT; IS USED DETERMINES WHICH CHARACTER IS PRINTED.; THE ADDRESSES OF THE TABLES ARE:; XXEC5E   ; UNSHIFTED; XXEC9F   ; SHIFTED; XXECE0   ; COMMODORE; XXEDA3   ; CONTROLXXF5 = $F5   ; KEYBOARD POINTER LOW BYTEXXF6 = $F6   ; KEYBOARD POINTER HIGH BYTE; WHEN DEVICE THE RS232 CHANNEL IS OPENED TWO BUFFERS OF 256 BYTES EACH ARE CREATED AT; THE TOP OF MEMORY. THESE LOCATIONS POINT TO THE ADDRESS OF THE ONE WHICH IS USED TO; STORE CHARACTERS AS THEY ARE RECEIVED.XXF7 = $F7   ; RS232 RX POINTER LOW BYTEXXF8 = $F8   ; RS232 RX POINTER HIGH BYTE; THESE LOCATIONS POINT TO THE ADDRESS OF THE 256 BYTE OUTPUT BUFFER THAT IS USED FOR; TRANSMITTING DATA TO RS232 DEVICES.XXF9 = $F9   ; RS232 TX POINTER LOW BYTEXXFA = $FA   ; RS232 TX POINTER HIGH BYTEXX00FF = $FF   ; FAC1 TO STRING OUTPUT BASEXX0100 = $0100  ; BOTTOM OF THE STACK PAGEXX01FC = $01FC  ; CHAIN LINK POINTER HIGH BYTEXX01FD = $01FD  ; CHAIN LINK POINTER LOW BYTEXX01FE = $01FE  ; LINE NUMBER LOW BYTE BEFORE CRUNCHED LINEXX01FF = $01FF  ; LINE NUMBER HIGH BYTE BEFORE CRUNCHED LINEXX0200 = $0200  ; INPUT BUFFER. FOR SOME ROUTINES THE BYTE BEFORE THE INPUT; BUFFER NEEDS TO BE SET TO A SPECIFIC VALUE FOR THE ROUTINE; TO WORK CORRECTLYXX0201 = $0201  ; INPUT BUFFER + 1XX0259 = $0259  ; .. TO XX0262 LOGICAL FILE TABLEXX0263 = $0263  ; .. TO XX026C DEVICE NUMBER TABLEXX026D = $026D  ; .. TO XX0276 SECONDARY ADDRESS TABLEXX0277 = $0277  ; .. TO XX0280 KEYBOARD BUFFERXX0281 = $0281  ; OS START OF MEMORY LOW BYTEXX0282 = $0282  ; OS START OF MEMORY HIGH BYTEXX0283 = $0283  ; OS TOP OF MEMORY LOW BYTEXX0284 = $0284  ; OS TOP OF MEMORY HIGH BYTEXX0285 = $0285  ; SERIAL BUS TIMEOUT FLAGXX0286 = $0286  ; CURRENT COLOUR CODEXX0287 = $0287  ; COLOUR UNDER CURSORXX0288 = $0288  ; SCREEN MEMORY PAGEXX0289 = $0289  ; MAXIMUM KEYBOARD BUFFER SIZEXX028A = $028A  ; KEY REPEAT. $80 = REPEAT ALL, $40 = REPEAT NONE,                ; $00 = REPEAT CURSOR MOVEMENT KEYS, INSERT/DELETE                ; KEY AND THE SPACE BARXX028B = $028B  ; REPEAT SPEED COUNTERXX028C = $028C  ; REPEAT DELAY COUNTER; THIS FLAG SIGNALS WHICH OF THE SHIFT, CTRL, OR C= KEYS ARE CURRENTLY BEING PRESSED.; A VALUE OF $01 SIGNIFIES THAT ONE OF THE SHIFT KEYS IS BEING PRESSED, A $02 SHOWS THAT; THE C= KEY IS DOWN, AND $04 MEANS THAT THE CTRL KEY IS BEING PRESSED. IF MORE THAN ONE; KEY IS HELD DOWN, THESE VALUES WILL BE ADDED E.G $03 INDICATES THAT SHIFT AND C= ARE; BOTH HELD DOWN.; PRESSING THE SHIFT AND C= KEYS AT THE SAME TIME WILL TOGGLE THE CHARACTER SET THAT IS; PRESENTLY BEING USED BETWEEN THE UPPERCASE/GRAPHICS SET, AND THE LOWERCASE/UPPERCASE; SET.; WHILE THIS CHANGES THE APPEARANCE OF ALL OF THE CHARACTERS ON THE SCREEN AT ONCE IT; HAS NOTHING WHATEVER TO DO WITH THE KEYBOARD SHIFT TABLES AND SHOULD NOT BE CONFUSED; WITH THE PRINTING OF SHIFTED CHARACTERS, WHICH AFFECTS ONLY ONE CHARACTER AT A TIME.XX028D = $028D  ; KEYBOARD SHIFT/CONTROL FLAG; BIT KEY(S) 1 = DOWN; --- ---------------; 7-3 UNUSED;  2 CTRL;  1 C=;  0 SHIFT; THIS LOCATION, IN COMBINATION WITH THE ONE ABOVE, IS USED TO DEBOUNCE THE SPECIAL; SHIFT KEYS. THIS WILL KEEP THE SHIFT/C= COMBINATION FROM CHANGING CHARACTER SETS; BACK AND FORTH DURING A SINGLE PRESSING OF BOTH KEYS.XX028E = $028E  ; SHIFT/CTRL/C= KEYPRESS LAST PATTERN; THIS LOCATION POINTS TO THE ADDRESS OF THE OPERATING SYSTEM ROUTINE WHICH ACTUALLY; DETERMINES WHICH KEYBOARD MATRIX LOOKUP TABLE WILL BE USED.; THE ROUTINE LOOKS AT THE VALUE OF THE SHIFT FLAG AT $28D, AND BASED ON WHAT VALUE; IT FINDS THERE, STORES THE ADDRESS OF THE CORRECT TABLE TO USE AT LOCATION $F5.XX028F = $028F  ; KEYBOARD DECODE LOGIC POINTER LOW BYTEXX0290 = $0290  ; KEYBOARD DECODE LOGIC POINTER HIGH BYTE; THIS FLAG IS USED TO ENABLE OR DISABLE THE FEATURE WHICH LETS YOU SWITCH BETWEEN THE; UPPERCASE/GRAPHICS AND UPPER/LOWERCASE CHARACTER SETS BY PRESSING THE SHIFT AND; COMMODORE LOGO KEYS SIMULTANEOUSLY.XX0291 = $0291  ; SHIFT MODE SWITCH, $00 = ENABLED, $80 = LOCKED; THIS LOCATION IS USED TO DETERMINE WHETHER MOVING THE CURSOR PAST THE ??XX  COLUMN OF; A LOGICAL LINE WILL CAUSE ANOTHER PHYSICAL LINE TO BE ADDED TO THE LOGICAL LINE.; A VALUE OF 0 ENABLES THE SCREEN TO SCROLL THE FOLLOWING LINES DOWN IN ORDER TO ADD; THAT LINE; ANY NONZERO VALUE WILL DISABLE THE SCROLL.; THIS FLAG IS SET TO DISABLE THE SCROLL TEMPORARILY WHEN THERE ARE CHARACTERS WAITING; IN THE KEYBOARD BUFFER, THESE MAY INCLUDE CURSOR MOVEMENT CHARACTERS THAT WOULD; ELIMINATE THE NEED FOR A SCROLL.XX0292 = $0292  ; SCREEN SCROLLING FLAG, $00 = ENABLEDXX0293 = $0293  ; PSEUDO 6551 CONTROL REGISTER. THE FIRST CHARACTER OF; THE OPEN RS232 FILENAME WILL BE STORED HERE; BIT FUNCTION; --- --------;  7 2 STOP BITS/1 STOP BIT; 65 WORD LENGTH; --- -----------; 00 8 BITS; 01 7 BITS; 10 6 BITS; 11 5 BITS;  4 UNUSED; 3210 BAUD RATE; ---- ---------; 0000 USER RATE *; 0001    50; 0010    75; 0011   110; 0100   134.5; 0101   150; 0110   300; 0111   600; 1000  1200; 1001  1800; 1010  2400; 1011  3600; 1100  4800 *; 1101  7200 *; 1110  9600 *; 1111 19200 * * = NOT IMPLEMENTEDXX0294 = $0294  ; PSEUDO 6551 COMMAND REGISTER. THE SECOND CHARACTER OF; THE OPEN RS232 FILENAME WILL BE STORED HERE; BIT FUNCTION; --- --------; 765 PARITY; --- ------; XX0 DISABLED; 001 ODD; 011 EVEN; 101 MARK; 111 SPACE;  4 DUPLEX HALF/FULL;  3 UNUSED;  2 UNUSED;  1 UNUSED;  0 HANDSHAKE - X LINE/3 LINE;XX0295 = $0295  ; NONSTANDARD BIT TIMING LOW BYTE. THE THIRD CHARACTER; OF THE OPEN RS232 FILENAME WILL BE STORED HERE;XX0296 = $0296  ; NONSTANDARD BIT TIMING HIGH BYTE. THE FOURTH CHARACTER; OF THE OPEN RS232 FILENAME WILL BE STORED HEREXX0297 = $0297  ; RS-232 STATUS REGISTER; BIT FUNCTION; --- --------;  7 BREAK;  6 NO DSR DETECTED;  5 UNUSED;  4 NO CTS DETECTED;  3 UNUSED;  2 RX BUFFER OVERRUN;  1 FRAMING ERROR;  0 PARITY ERRORXX0298 = $0298  ; NUMBER OF BITS TO BE SENT/RECEIVEDXX0299 = $0299  ; TIME OF ONE BIT CELL LOW BYTEXX029A = $029A  ; TIME OF ONE BIT CELL HIGH BYTEXX029B = $029B  ; INDEX TO RX BUFFER ENDXX029C = $029C  ; INDEX TO RX BUFFER STARTXX029D = $029D  ; INDEX TO TX BUFFER STARTXX029E = $029E  ; INDEX TO TX BUFFER ENDXX029F = $029F  ; SAVED IRQ LOW BYTEXX02A0 = $02A0  ; SAVED IRQ HIGH BYTE; $02A1 TO $02FF - UNUSEDXX0300 = $0300  ; VECTOR TO THE PRINT BASIC ERROR MESSAGE ROUTINEXX0302 = $0302  ; VECTOR TO THE MAIN BASIC PROGRAM LOOPXX0304 = $0304  ; VECTOR TO THE THE ASCII TEXT TO KEYWORDS ROUTINEXX0306 = $0306  ; VECTOR TO THE LIST BASIC PROGRAM AS ASCII ROUTINEXX0308 = $0308  ; VECTOR TO THE EXECUTE NEXT BASIC COMMAND ROUTINEXX030A = $030A  ; VECTOR TO THE GET VALUE FROM BASIC LINE ROUTINE; BEFORE EVERY SYS COMMAND EACH OF THE REGISTERS IS LOADED WITH THE VALUE FOUND IN THE; CORRESPONDING STORAGE ADDRESS. UPON RETURNING TO BASIC WITH AN RTS INSTRUCTION, THE NEW; VALUE OF EACH REGISTER IS STORED IN THE APPROPRIATE STORAGE ADDRESS.; THIS FEATURE ALLOWS YOU TO PLACE THE NECESSARY VALUES INTO THE REGISTERS FROM BASIC; BEFORE YOU SYS TO A KERNAL OR BASIC ML ROUTINE. IT ALSO ENABLES YOU TO EXAMINE THE; RESULTING EFFECT OF THE ROUTINE ON THE REGISTERS, AND TO PRESERVE THE CONDITION OF THE; REGISTERS ON EXIT FOR SUBSEQUENT SYS CALLS.XX030C = $030C  ; A FOR SYS COMMANDXX030D = $030D  ; X FOR SYS COMMANDXX030E = $030E  ; Y FOR SYS COMMANDXX030F = $030F  ; P FOR SYS COMMANDXX0314 = $0314  ; IRQ VECTOR LOW BYTEXX0315 = $0315  ; IRQ VECTOR HIGH BYTEXX0316 = $0316  ; BRK VECTORXX0318 = $0318  ; NMI VECTORXX031A = $031A  ; KERNAL VECTOR - OPEN A LOGICAL FILEXX031C = $031C  ; KERNAL VECTOR - CLOSE A SPECIFIED LOGICAL FILEXX031E = $031E  ; KERNAL VECTOR - OPEN CHANNEL FOR INPUTXX0320 = $0320  ; KERNAL VECTOR - OPEN CHANNEL FOR OUTPUTXX0322 = $0322  ; KERNAL VECTOR - CLOSE INPUT AND OUTPUT CHANNELSXX0324 = $0324  ; KERNAL VECTOR - INPUT CHARACTER FROM CHANNELXX0326 = $0326  ; KERNAL VECTOR - OUTPUT CHARACTER TO CHANNELXX0328 = $0328  ; KERNAL VECTOR - SCAN STOP KEYXX032A = $032A  ; KERNAL VECTOR - GET CHARACTER FROM KEYBOARD QUEUEXX032C = $032C  ; KERNAL VECTOR - CLOSE ALL CHANNELS AND FILESXX0330 = $0330  ; KERNAL VECTOR - LOADXX0332 = $0332  ; KERNAL VECTOR - SAVEXX033C = $033C  ; TO $03FB - CASSETTE BUFFER;***********************************************************************************;;***********************************************************************************;;; HARDWARE EQUATESXX9000     = $9000          ; VIC CHIP BASE ADDRESSXX9002     = $9002          ; VIDEO ADDRESS AND COLUMS                         ; BIT     FUNCTION                         ; ---     --------                         ;  7     VIDEO ADDRESS VA9                         ; 6-0     NUMBER OF COLUMNSXX9005     = $9005          ; VIDEO MEMORY ADDRESSES ($1E00)                         ; BIT     FUNCTION                         ; ---     --------                         ;  7     MUST BE 1                         ; 6-4     VIDEO MEMORY ADDRESS VA12-VA10                         ; 3-0     CHARACTER MEMORY START ADDRESS                         ; 0000 ROM     $8000     SET 1                         ; 0001  '     $8400                         ; 0010  '     $8800 SET 2                         ; 0011  '     $8C00                         ; 1100 RAM     $1000                         ; 1101  '     $1400                         ; 1110  '     $1800                         ; 1111  '     $1C00XX9110     = $9110          ; VIA 1 DRB                         ; BIT     FUNCTION                         ; ---     --------                         ;  7     DSR IN                         ;  6     CTS IN                         ;  5                              ;  4     DCD IN                         ;  3     RI IN                         ;  2     DTR OUT                         ;  1     RTS OUT                         ;  0     DATA INXX9111     = $9111          ; VIA 1 DRA                         ; BIT     FUNCTION                         ; ---     --------                         ;  7     SERIAL ATN OUT                         ;  6     CASSETTE SWITCH                         ;  5     LIGHT PEN                         ;  4     JOY 2                         ;  3     JOY 1                         ;  2     JOY 0                         ;  1     SERIAL DATA IN                         ;  0     SERIAL CLK INXX9112     = $9112          ; VIA 1 DDRBXX9113     = $9113          ; VIA 1 DDRAXX9114     = $9114          ; VIA 1 T1C_LXX9115     = $9115          ; VIA 1 T1C_HXX9118     = $9118          ; VIA 1 T2C_LXX9119     = $9119          ; VIA 1 T2C_HXX911B     = $911B          ; VIA 1 ACR                         ; BIT     FUNCTION                         ; ---     --------                         ;  7     T1 PB7 ENABLED/DISABLED                         ;  6     T1 FREE RUN/ONE SHOT                         ;  5     T2 CLOCK PB6/Ø2                         ; 432     FUNCTION                         ; ---     --------                         ; 000     SHIFT REGISTER DISABLED                         ; 001     SHIFT IN, RATE CONTROLLED BY T2                         ; 010     SHIFT IN, RATE CONTROLLED BY Ø2                         ; 011     SHIFT IN, RATE CONTROLLED BY EXTERNAK CLOCK                         ; 100     SHIFT OUT, RATE CONTROLLED BY T2, FREE RUN MODE                         ; 101     SHIFT OUT, RATE CONTROLLED BY T2                         ; 110     SHIFT OUT, RATE CONTROLLED BY Ø2                         ; 111     SHIFT OUT, RATE CONTROLLED BY EXTERNAK CLOCK                         ;  1     PB LATCH ENABLED/DISABLED                         ;  0     PA LATCH ENABLED/DISABLEDXX911C     = $911C          ; VIA 1 PCR                         ; BIT     FUNCTION                         ; ---     --------                         ; 765     CB2 CONTROL                         ; ---     -----------                         ; 000     INTERRUPT INPUT MODE                         ; 001     INDEPENDENT INTERRUPT INPUT MODE                         ; 010     INPUT MODE                         ; 011     INDEPENDENT INPUT MODE                         ; 100     HANDSHAKE OUTPUT MODE                         ; 101     PULSE OUTPUT MODE                         ; 110     MANUAL OUTPUT MODE, CB2 LOW                         ; 111     MANUAL OUTPUT MODE, CB2 HIGH                         ;  4     CB1 EDGE POSITIVE/NEGATIVE                         ; 321     CA2 CONTROL                         ; ---     -----------                         ; 000     INTERRUPT INPUT MODE                         ; 001     INDEPENDENT INTERRUPT INPUT MODE                         ; 010     INPUT MODE                          ; 011     INDEPENDENT INPUT MODE                         ; 100     HANDSHAKE OUTPUT MODE                         ; 101     PULSE OUTPUT MODE                         ; 110     MANUAL OUTPUT MODE, CA2 LOW                         ; 111     MANUAL OUTPUT MODE, CA2 HIGH                         ;  0     CA1 EDGE POSITIVE/NEGATIVE; THE STATUS BIT IS A NOT NORMAL FLAG. IT GOES HIGH IF BOTH AN INTERRUPT FLAG IN THE IFR; AND THE CORRESPONDING ENABLE BIT IN THE IER ARE SET. IT CAN BE CLEARED ONLY BY CLEARING; ALL THE ACTIVE FLAGS IN THE IFR OR DISABLING ALL ACTIVE INTERRUPTS IN THE IERXX911D     = $911D          ; VIA 1 IFR                         ; BIT     FUNCTION          CLEARED BY                         ; ---     --------          ----------                         ;  7     INTERRUPT STATUS     CLEARING ALL ENABLED INTERRUPTS                         ;  6     T1 INTERRUPT     READ T1C_L, WRITE T1C_H                         ;  5     T2 INTERRUPT     READ T2C_L, WRITE T2C_H                         ;  4     CB1 TRANSITION     READ OR WRITE PORT B                         ;  3     CB2 TRANSITION     READ OR WRITE PORT B                         ;  2     8 SHIFTS DONE     READ OR WRITE THE SHIFT REGISTER                         ;  1     CA1 TRANSITION     READ OR WRITE PORT A                         ;  0     CA2 TRANSITION     READ OR WRITE PORT A; IF ENABLE/DISABLE BIT IS A ZERO DURING A WRITE TO THIS REGISTER, EACH 1 IN BITS 0-6; CLEARS THE CORRESPONDING BIT IN THE IER. IF THIS BIT IS A ONE DURING A WRITE TO THIS; REGISTER, EACH 1 IN BITS 0-6 WILL SET THE CORRESPONDING IER BITXX911E     = $911E          ; VIA 1 IER                         ; BIT     FUNCTION                         ; ---     --------                         ;  7     ENABLE/DISABLE                         ;  6     T1 INTERRUPT                         ;  5     T2 INTERRUPT                         ;  4     CB1 TRANSITION                         ;  3     CB2 TRANSITION                         ;  2     8 SHIFTS DONE                         ;  1     CA1 TRANSITION                         ;  0     CA2 TRANSITIONXX911F     = $911F          ; VIA 1 DRA, NO HANDSHAKE                         ; BIT     FUNCTION                         ; ---     --------                         ;  7     ATN OUT                         ;  6     CASSETTE SWITCH                         ;  5     JOYSTICK FIRE, LIGHT PEN                         ;  4     JOYSTICK LEFT                         ;  3     JOYSTICK DOWN                         ;  2     JOYSTICK UP                         ;  1     SERIAL DAT IN                         ;  0     SERIAL CLK INXX9120     = $9120          ; VIA 2 DRB, KEYBOARD COLUMN DRIVEXX9121     = $9121          ; VIA 2 DRA, KEYBOARD ROW PORT                         ; VIC 20 KEYBOARD MATRIX LAYOUT                         ;     C7     C6     C5     C4     C3     C2     C1     C0                         ;   +------------------------------------------------                         ; R7|     [F7]     [F5]     [F3]     [F1]     [DN]     [RGT]     [RET]     [DEL]                         ; R6|     [HOME][UP]  =     [RSH]     /     ;     *     £                         ; R5|     -     @     :     .     ,     L     P     +                         ; R4|     0     O     K     M     N     J     I     9                         ; R3|     8     U     H     B     V     G     Y     7                         ; R2|     6     T     F     C     X     D     R     5                         ; R1|     4     E     S     Z     [LSH]     A     W     3                         ; R0|     2     Q     [CBM]     [SP]     [RUN]     [CTL]     [LFT]     1XX9122     = $9122          ; VIA 2 DDRBXX9123     = $9123          ; VIA 2 DDRAXX9124     = $9124          ; VIA 2 T1C_LXX9125     = $9125          ; VIA 2 T1C_HXX9128     = $9128          ; VIA 2 T2C_LXX9129     = $9129          ; VIA 2 T2C_HXX912B     = $912B          ; VIA 2 ACRXX912C     = $912C          ; VIA 2 PCR; THE STATUS BIT IS A NOT NORMAL FLAG. IT GOES HIGH IF BOTH AN INTERRUPT FLAG IN THE IFR; AND THE CORRESPONDING ENABLE BIT IN THE IER ARE SET. IT CAN BE CLEARED ONLY BY CLEARING; ALL THE ACTIVE FLAGS IN THE IFR OR DISABLING ALL ACTIVE INTERRUPTS IN THE IERXX912D     = $912D          ; VIA 1 IFR                         ; BIT     FUNCTION          CLEARED BY                         ; ---     --------          ----------                         ;  7     INTERRUPT STATUS     CLEARING ALL ENABLED INTERRUPTS                         ;  6     T1 INTERRUPT     READ T1C_L, WRITE T1C_H                         ;  5     T2 INTERRUPT     READ T2C_L, WRITE T2C_H                         ;  4     CB1 TRANSITION     READ OR WRITE PORT B                         ;  3     CB2 TRANSITION     READ OR WRITE PORT B                         ;  2     8 SHIFTS DONE     READ OR WRITE THE SHIFT REGISTER                         ;  1     CA1 TRANSITION     READ OR WRITE PORT A                         ;  0     CA2 TRANSITION     READ OR WRITE PORT A; IF ENABLE/DISABLE BIT IS A ZERO DURING A WRITE TO THIS REGISTER, EACH 1 IN BITS 0-6; CLEARS THE CORRESPONDING BIT IN THE IER. IF THIS BIT IS A ONE DURING A WRITE TO THIS; REGISTER, EACH 1 IN BITS 0-6 WILL SET THE CORRESPONDING IER BITXX912E     = $912E          ; VIA 1 IER                         ; BIT     FUNCTION                         ; ---     --------                         ;  7     ENABLE/DISABLE                         ;  6     T1 INTERRUPT                         ;  5     T2 INTERRUPT                         ;  4     CB1 TRANSITION                         ;  3     CB2 TRANSITION                         ;  2     8 SHIFTS DONE                         ;  1     CA1 TRANSITION                         ;  0     CA2 TRANSITIONXX912F     = $912F          ; VIA 2 DRA, KEYBOARD ROW, NO HANDSHAKEXXA000     = $A000          ; AUTOSTART ROM INITIAL ENTRY VECTORXXA002     = $A002          ; AUTOSTART ROM BREAK ENTRYXXA004     = $A004          ; AUTOSTART ROM IDENTIFIER STRING START;***********************************************************************************;;; BASIC KEYWORD TOKEN VALUES. TOKENS NOT USED IN THE SOURCE ARE INCLUDED FOR; COMPLETENESS BUT COMMENTED OUT; COMMAND TOKENS;TEND     = $80               ; END TOKENTFOR     = $81               ; FOR TOKEN;TNEXT     = $82               ; NEXT TOKENTDATA     = $83               ; DATA TOKEN;TINFL     = $84               ; INPUT# TOKEN;TINPUT     = $85               ; INPUT TOKEN;TDIM     = $86               ; DIM TOKEN;TREAD     = $87               ; READ TOKEN;TLET     = $88               ; LET TOKENTGOTO     = $89               ; GOTO TOKEN;TRUN     = $8A               ; RUN TOKEN;TIF     = $8B               ; IF TOKEN;TRESTORE     = $8C               ; RESTORE TOKENTGOSUB     = $8D               ; GOSUB TOKEN;TRETURN     = $8E               ; RETURN TOKENTREM     = $8F               ; REM TOKEN;TSTOP     = $90               ; STOP TOKEN;TON     = $91               ; ON TOKEN;TWAIT     = $92               ; WAIT TOKEN;TLOAD     = $93               ; LOAD TOKEN;TSAVE     = $94               ; SAVE TOKEN;TVERIFY     = $95               ; VERIFY TOKEN;TDEF     = $96               ; DEF TOKEN;TPOKE     = $97               ; POKE TOKEN;TPRINFL     = $98               ; PRINT# TOKENTPRINT     = $99               ; PRINT TOKEN;TCONT     = $9A               ; CONT TOKEN;TLIST     = $9B               ; LIST TOKEN;TCLR     = $9C               ; CLR TOKEN;TCMD     = $9D               ; CMD TOKEN;TSYS     = $9E               ; SYS TOKEN;TOPEN     = $9F               ; OPEN TOKEN;TCLOSE     = $A0               ; CLOSE TOKEN;TGET     = $A1               ; GET TOKEN;TNEW     = $A2               ; NEW TOKEN; SECONDARY KEYWORD TOKENSTTAB     = $A3               ; TAB( TOKENTTO          = $A4               ; TO TOKENTFN          = $A5               ; FN TOKENTSPC     = $A6               ; SPC( TOKENTTHEN     = $A7               ; THEN TOKENTNOT     = $A8               ; NOT TOKENTSTEP     = $A9               ; STEP TOKEN; OPERATOR TOKENSTPLUS     = $AA               ; + TOKENTMINUS     = $AB               ; - TOKEN;TMUL     = $AC               ; * TOKEN;TDIV     = $AD               ; / TOKEN;TPOWER     = $AE               ; ^ TOKEN;TAND     = $AF               ; AND TOKEN;TOR     = $B0               ; OR TOKENTGT          = $B1               ; > TOKENTEQUAL     = $B2               ; = TOKEN;TLT     = $B3               ; < TOKEN; FUNCTION TOKENSTSGN     = $B4               ; SGN TOKEN;TINT     = $B5               ; INT TOKEN;TABS     = $B6               ; ABS TOKEN;TUSR     = $B7               ; USR TOKEN;TFRE     = $B8               ; FRE TOKEN;TPOS     = $B9               ; POS TOKEN;TSQR     = $BA               ; SQR TOKEN;TRND     = $BB               ; RND TOKEN;TLOG     = $BC               ; LOG TOKEN;TEXP     = $BD               ; EXP TOKEN;TCOS     = $BE               ; COS TOKEN;TSIN     = $BF               ; SIN TOKEN;TTAN     = $C0               ; TAN TOKEN;TATN     = $C1               ; ATN TOKEN;TPEEK     = $C2               ; PEEK TOKEN;TLEN     = $C3               ; LEN TOKEN;TSTRS     = $C4               ; STR$ TOKEN;TVAL     = $C5               ; VAL TOKEN;TASC     = $C6               ; ASC TOKEN;TCHRS     = $C7               ; CHR$ TOKEN;TLEFTS     = $C8               ; LEFT$ TOKEN;TRIGHTS     = $C9               ; RIGHT$ TOKEN;TMIDS     = $CA               ; MID$ TOKENTGO          = $CB               ; GO TOKENTPI          = $FF               ; PI TOKEN;***********************************************************************************;;***********************************************************************************;;; ROM START* = $C000 ;     .ORG     $C000XXC000 = *     .WORD     XXE378          ; BASIC COLD START ENTRY POINTXXC002 = *     .WORD     XXE467          ; BASIC WARM START ENTRY POINTXXC004 = *     .BYTE     'CBMBASIC'          ; ROM NAME, UNREFERENCED;***********************************************************************************;;; ACTION ADDRESSES FOR PRIMARY COMMANDS. THESE ARE CALLED BY PUSHING THE ADDRESS; ONTO THE STACK AND DOING AN RTS SO THE ACTUAL ADDRESS -1 NEEDS TO BE PUSHEDXXC00C = *     .WORD     XXC831-1          ; PERFORM END     .WORD     XXC742-1          ; PERFORM FOR     .WORD     XXCD1E-1          ; PERFORM NEXT     .WORD     XXC8F8-1          ; PERFORM DATA     .WORD     XXCBA5-1          ; PERFORM INPUT#     .WORD     XXCBBF-1          ; PERFORM INPUT     .WORD     XXD081-1          ; PERFORM DIM     .WORD     XXCC06-1          ; PERFORM READ     .WORD     XXC9A5-1          ; PERFORM LET     .WORD     XXC8A0-1          ; PERFORM GOTO     .WORD     XXC871-1          ; PERFORM RUN     .WORD     XXC928-1          ; PERFORM IF     .WORD     XXC81D-1          ; PERFORM RESTORE     .WORD     XXC883-1          ; PERFORM GOSUB     .WORD     XXC8D2-1          ; PERFORM RETURN     .WORD     XXC93B-1          ; PERFORM REM     .WORD     XXC82F-1          ; PERFORM STOP     .WORD     XXC94B-1          ; PERFORM ON     .WORD     XXD82D-1          ; PERFORM WAIT     .WORD     XXE165-1          ; PERFORM LOAD     .WORD     XXE153-1          ; PERFORM SAVE     .WORD     XXE162-1          ; PERFORM VERIFY     .WORD     XXD3B3-1          ; PERFORM DEF     .WORD     XXD824-1          ; PERFORM POKE     .WORD     XXCA80-1          ; PERFORM PRINT#     .WORD     XXCAA0-1          ; PERFORM PRINT     .WORD     XXC857-1          ; PERFORM CONT     .WORD     XXC69C-1          ; PERFORM LIST     .WORD     XXC65E-1          ; PERFORM CLR     .WORD     XXCA86-1          ; PERFORM CMD     .WORD     XXE127-1          ; PERFORM SYS     .WORD     XXE1BB-1          ; PERFORM OPEN     .WORD     XXE1C4-1          ; PERFORM CLOSE     .WORD     XXCB7B-1          ; PERFORM GET     .WORD     XXC642-1          ; PERFORM NEW;***********************************************************************************;;; ACTION ADDRESSES FOR FUNCTIONSXXC052 = *     .WORD     XXDC39          ; PERFORM SGN()     .WORD     XXDCCC          ; PERFORM INT()     .WORD     XXDC58          ; PERFORM ABS()     .WORD     XX00          ; PERFORM USR()     .WORD     XXD37D          ; PERFORM FRE()     .WORD     XXD39E          ; PERFORM POS()     .WORD     XXDF71          ; PERFORM SQR()     .WORD     XXE094          ; PERFORM RND()     .WORD     XXD9EA          ; PERFORM LOG()     .WORD     XXDFED          ; PERFORM EXP()     .WORD     XXE261          ; PERFORM COS()     .WORD     XXE268          ; PERFORM SIN()     .WORD     XXE2B1          ; PERFORM TAN()     .WORD     XXE30B          ; PERFORM ATN()     .WORD     XXD80D          ; PERFORM PEEK()     .WORD     XXD77C          ; PERFORM LEN()     .WORD     XXD465          ; PERFORM STR$()     .WORD     XXD7AD          ; PERFORM VAL()     .WORD     XXD78B          ; PERFORM ASC()     .WORD     XXD6EC          ; PERFORM CHR$()     .WORD     XXD700          ; PERFORM LEFT$()     .WORD     XXD72C          ; PERFORM RIGHT$()     .WORD     XXD737          ; PERFORM MID$();***********************************************************************************;;; PRECEDENCE BYTE AND ACTION ADDRESSES FOR OPERATORS. LIKE THE PRIMARRY COMMANDS THESE; ARE CALLED BY PUSHING THE ADDRESS ONTO THE STACK AND DOING AN RTS, SO AGAIN THE ACTUAL; ADDRESS -1 NEEDS TO BE PUSHEDXXC080 = *     .BYTE     $79     .WORD     XXD86A-1          ; +     .BYTE     $79     .WORD     XXD853-1          ; -     .BYTE     $7B     .WORD     XXDA2B-1          ; *     .BYTE     $7B     .WORD     XXDB12-1          ; /     .BYTE     $7F     .WORD     XXDF7B-1          ; ^     .BYTE     $50     .WORD     XXCFE9-1          ; AND     .BYTE     $46     .WORD     XXCFE6-1          ; OR     .BYTE     $7D     .WORD     XXDFB4-1          ; >     .BYTE     $5A     .WORD     XXCED4-1          ; =XXC09B = *     .BYTE     $64     .WORD     XXD016-1          ; <;***********************************************************************************;;; BASIC KEYWORDS. EACH WORD HAS B7 SET IN IT'S LAST CHARACTER AS AN END MARKER,; EVEN THE ONE CHARACTER KEYWORDS SUCH AS '<' OR '='; FIRST ARE THE PRIMARY COMMAND KEYWORDS, ONLY THESE CAN START A STATEMENTXXC09E = *     .BYTE     'EN',$C4     ;'D'+$80     ; END     .BYTE     'FO',$D2     ;'R'+$80     ; FOR     .BYTE     'NEX',$D4    ;'T'+$80     ; NEXT     .BYTE     'DAT',$C1    ;'A'+$80     ; DATA     .BYTE     'INPUT',$A3  ;'#'+$80     ; INPUT#     .BYTE     'INPU',$D4   ;'T'+$80     ; INPUT     .BYTE     'DI',$CD     ;'M'+$80     ; DIM     .BYTE     'REA',$C4    ;'D'+$80     ; READ     .BYTE     'LE',$D4     ;'T'+$80     ; LET     .BYTE     'GOT',$CF    ;'O'+$80     ; GOTO     .BYTE     'RU',$CE     ;'N'+$80     ; RUN     .BYTE     'I',$C6      ;'F'+$80     ; IF     .BYTE     'RESTOR',$C5 ;'E'+$80     ; RESTORE     .BYTE     'GOSU',$C2   ;'B'+$80     ; GOSUB     .BYTE     'RETUR',$CE  ;'N'+$80     ; RETURN     .BYTE     'RE',$CD     ;'M'+$80     ; REM     .BYTE     'STO',$D0    ;'P'+$80     ; STOP     .BYTE     'O',$CE      ;'N'+$80     ; ON     .BYTE     'WAI',$D4    ;'T'+$80     ; WAIT     .BYTE     'LOA',$C4    ;'D'+$80     ; LOAD     .BYTE     'SAV',$C5    ;'E'+$80     ; SAVE     .BYTE     'VERIF',$D9  ;'Y'+$80     ; VERIFY     .BYTE     'DE',$C6     ;'F'+$80     ; DEF     .BYTE     'POK',$C5    ;'E'+$80     ; POKE     .BYTE     'PRINT',$A3  ;'#'+$80     ; PRINT#     .BYTE     'PRIN',$D4   ;'T'+$80     ; PRINT     .BYTE     'CON',$D4    ;'T'+$80     ; CONT     .BYTE     'LIS',$D4    ;'T'+$80     ; LIST     .BYTE     'CL',$D2     ;'R'+$80     ; CLR     .BYTE     'CM',$C4     ;'D'+$80     ; CMD     .BYTE     'SY',$D3     ;'S'+$80     ; SYS     .BYTE     'OPE',$CE    ;'N'+$80     ; OPEN     .BYTE     'CLOS',$C5   ;'E'+$80     ; CLOSE     .BYTE     'GE',$D4     ;'T'+$80     ; GET     .BYTE     'NE',$D7     ;'W'+$80     ; NEW; NEXT ARE THE SECONDARY COMMAND KEYWORDS, THESE CAN NOT START A STATEMENT     .BYTE     'TAB',$A8    ;'('+$80     ; TAB(     .BYTE     'T',$CF      ;'O'+$80     ; TO     .BYTE     'F',$CE      ;'N'+$80     ; FN     .BYTE     'SPC',$A8    ;'('+$80     ; SPC(     .BYTE     'THE',$CE    ;'N'+$80     ; THEN     .BYTE     'NO',$D4     ;'T'+$80     ; NOT     .BYTE     'STE',$D0    ;'P'+$80     ; STEP; THE OPERATORS     .BYTE     $AB          ;'+'+$80     ; +     .BYTE     $AD          ;'-'+$80     ; -     .BYTE     $AA          ;'*'+$80     ; *     .BYTE     $AF          ;'/'+$80     ; /     .BYTE     $DE          ;'^'+$80     ; ^     .BYTE     'AN',$C4     ;'D'+$80     ; AND     .BYTE     'O',$D2      ;'R'+$80     ; OR     .BYTE     $BE          ;'>'+$80     ; >     .BYTE     $BD          ;'='+$80     ; =     .BYTE     $BC          ;'<'+$80     ; <; THE FUNCTIONS     .BYTE     'SG',$CE     ;'N'+$80     ; SGN     .BYTE     'IN',$D4     ;'T'+$80     ; INT     .BYTE     'AB',$D3     ;'S'+$80     ; ABS     .BYTE     'US',$D2     ;'R'+$80     ; USR     .BYTE     'FR',$C5     ;'E'+$80     ; FRE     .BYTE     'PO',$D3     ;'S'+$80     ; POS     .BYTE     'SQ',$D2     ;'R'+$80     ; SQR     .BYTE     'RN',$C4     ;'D'+$80     ; RND     .BYTE     'LO',$C7     ;'G'+$80     ; LOG     .BYTE     'EX',$D0     ;'P'+$80     ; EXP     .BYTE     'CO',$D3     ;'S'+$80     ; COS     .BYTE     'SI',$CE     ;'N'+$80     ; SIN     .BYTE     'TA',$CE     ;'N'+$80     ; TAN     .BYTE     'AT',$CE     ;'N'+$80     ; ATN     .BYTE     'PEE',$CB    ;'K'+$80   ; PEEK     .BYTE     'LE',$CE     ;'N'+$80     ; LEN     .BYTE     'STR',$A4    ;'$'+$80     ; STR$     .BYTE     'VA',$CC     ;'L'+$80     ; VAL     .BYTE     'AS',$C3     ;'C'+$80     ; ASC     .BYTE     'CHR',$A4    ;'$'+$80     ; CHR$     .BYTE     'LEFT',$A4   ;'$'+$80     ; LEFT$     .BYTE     'RIGHT',$A4  ;'$'+$80     ; RIGHT$     .BYTE     'MID',$A4    ;'$'+$80     ; MID$; LASTLY IS GO, THIS IS AN ADD ON SO THAT GO TO, AS WELL AS GOTO, WILL WORK     .BYTE     'G',$CF      ;'O'+$80     ; GO     .BYTE     $00                       ; END MARKER;***********************************************************************************;;; ERROR MESSAGESXXC19E = *     .BYTE     'TOO MANY FILE',$D3        ;'S'+$80XXC1AC = *     .BYTE     'FILE OPE',$CE             ;'N'+$80XXC1B5 = *     .BYTE     'FILE NOT OPE',$CE         ;'N'+$80XXC1C2 = *     .BYTE     'FILE NOT FOUN',$C4        ;'D'+$80XXC1D0 = *     .BYTE     'DEVICE NOT PRESEN',$D4    ;'T'+$80XXC1E2 = *     .BYTE     'NOT INPUT FIL',$C5        ;'E'+$80XXC1F0 = *     .BYTE     'NOT OUTPUT FIL',$C5       ;'E'+$80XXC1FF = *     .BYTE     'MISSING FILE NAM',$C5     ;'E'+$80XXC210 = *     .BYTE     'ILLEGAL DEVICE NUMBE',$D2 ;'R'+$80XXC225 = *     .BYTE     'NEXT WITHOUT FO',$D2      ;'R'+$80XXC235 = *     .BYTE     'SYNTA',$D8                ;'X'+$80XXC23B = *     .BYTE     'RETURN WITHOUT GOSU',$C2  ;'B'+$80XXC24F = *     .BYTE     'OUT OF DAT',$C1           ;'A'+$80XXC25A = *     .BYTE     'ILLEGAL QUANTIT',$D9      ;'Y'+$80XXC26A = *     .BYTE     'OVERFLO',$D7              ;'W'+$80XXC272 = *     .BYTE     'OUT OF MEMOR',$D9         ;'Y'+$80XXC27F = *     .BYTE     'UNDEF''D STATEMEN',$D4    ;'T'+$80XXC290 = *     .BYTE     'BAD SUBSCRIP',$D4         ;'T'+$80XXC29D = *     .BYTE     'REDIM''D ARRA',$D9        ;'Y'+$80XXC2AA = *     .BYTE     'DIVISION BY ZER',$CF      ;'O'+$80XXC2BA = *     .BYTE     'ILLEGAL DIREC',$D4        ;'T'+$80XXC2C8 = *     .BYTE     'TYPE MISMATC',$C8         ;'H'+$80XXC2D5 = *     .BYTE     'STRING TOO LON',$C7       ;'G'+$80XXC2E4 = *     .BYTE     'FILE DAT',$C1             ;'A'+$80XXC2ED = *     .BYTE     'FORMULA TOO COMPLE',$D8   ;'X'+$80XXC300 = *     .BYTE     'CAN''T CONTINU',$C5       ;'E'+$80XXC30E = *     .BYTE     'UNDEF''D FUNCTIO',$CE     ;'N'+$80XXC31E = *     .BYTE     'VERIF',$D9                ;'Y'+$80XXC324 = *     .BYTE     'LOA',$C4                  ;'D'+$80; ERROR MESSAGE POINTER TABLEXXC328 = *     .WORD     XXC19E          ; $01     TOO MANY FILES     .WORD     XXC1AC          ; $02     FILE OPEN     .WORD     XXC1B5          ; $03     FILE NOT OPEN     .WORD     XXC1C2          ; $04     FILE NOT FOUND     .WORD     XXC1D0          ; $05     DEVICE NOT PRESENT     .WORD     XXC1E2          ; $06     NOT INPUT FILE     .WORD     XXC1F0          ; $07     NOT OUTPUT FILE     .WORD     XXC1FF          ; $08     MISSING FILE NAME     .WORD     XXC210          ; $09     ILLEGAL DEVICE NUMBER     .WORD     XXC225          ; $0A     NEXT WITHOUT FOR     .WORD     XXC235          ; $0B     SYNTAX     .WORD     XXC23B          ; $0C     RETURN WITHOUT GOSUB     .WORD     XXC24F          ; $0D     OUT OF DATA     .WORD     XXC25A          ; $0E     ILLEGAL QUANTITY     .WORD     XXC26A          ; $0F     OVERFLOW     .WORD     XXC272          ; $10     OUT OF MEMORY     .WORD     XXC27F          ; $11     UNDEF'D STATEMENT     .WORD     XXC290          ; $12     BAD SUBSCRIPT     .WORD     XXC29D          ; $13     REDIM'D ARRAY     .WORD     XXC2AA          ; $14     DIVISION BY ZERO     .WORD     XXC2BA          ; $15     ILLEGAL DIRECT     .WORD     XXC2C8          ; $16     TYPE MISMATCH     .WORD     XXC2D5          ; $17     STRING TOO LONG     .WORD     XXC2E4          ; $18     FILE DATA     .WORD     XXC2ED          ; $19     FORMULA TOO COMPLEX     .WORD     XXC300          ; $1A     CAN'T CONTINUE     .WORD     XXC30E          ; $1B     UNDEF'D FUNCTION     .WORD     XXC31E          ; $1C     VERIFY     .WORD     XXC324          ; $1D     LOAD     .WORD     XXC383          ; $1E     BREAK;***********************************************************************************;;; BASIC MESSAGESXXC364 = *     .BYTE     $0D,'OK',$0D,$00XXC369 = *     .BYTE     $0D,' ERROR',$00XXC371 = *     .BYTE     ' IN ',$00XXC376 = *     .BYTE     $0D,$0A,'READY.',$0D,$0A,$00XXC381 = *     .BYTE     $0D,$0AXXC383 = *     .BYTE     'BREAK',$00;***********************************************************************************;;; SPARE BYTE, NOT REFERENCED;XXC389     .BYTE     $A0;***********************************************************************************;;; SEARCH THE STACK FOR FOR OR GOSUB ACTIVITY; RETURN ZB=1 IF FOR VARIABLE FOUNDXXC38A = *     TSX                    ; COPY STACK POINTER     INX                    ; +1 PASS RETURN ADDRESS     INX                    ; +2 PASS RETURN ADDRESS     INX                    ; +3 PASS CALLING ROUTINE RETURN ADDRESS     INX                    ; +4 PASS CALLING ROUTINE RETURN ADDRESSXXC38F = *     LDA     XX0100+1,X     ; GET TOKEN BYTE FROM STACK     CMP     #TFOR          ; IS IT FOR TOKEN     BNE     XXC3B7          ; EXIT IF NOT FOR TOKEN                         ; WAS FOR TOKEN     LDA     XX4A          ; GET FOR/NEXT VARIABLE POINTER HIGH BYTE     BNE     XXC3A4          ; BRANCH IF NOT NULL     LDA     XX0100+2,X     ; GET FOR VARIABLE POINTER LOW BYTE     STA     XX49          ; SAVE FOR/NEXT VARIABLE POINTER LOW BYTE     LDA     XX0100+3,X     ; GET FOR VARIABLE POINTER HIGH BYTE     STA     XX4A          ; SAVE FOR/NEXT VARIABLE POINTER HIGH BYTEXXC3A4 = *     CMP     XX0100+3,X     ; COMPARE VARIABLE POINTER WITH STACKED VARIABLE POINTER                         ; HIGH BYTE     BNE     XXC3B0          ; BRANCH IF NO MATCH     LDA     XX49          ; GET FOR/NEXT VARIABLE POINTER LOW BYTE     CMP     XX0100+2,X     ; COMPARE VARIABLE POINTER WITH STACKED VARIABLE POINTER                         ; LOW BYTE     BEQ     XXC3B7          ; EXIT IF MATCH FOUNDXXC3B0 = *     TXA                    ; COPY INDEX     CLC                    ; CLEAR CARRY FOR ADD     ADC     #$12               ; ADD FOR STACK USE SIZE     TAX                    ; COPY BACK TO INDEX     BNE     XXC38F          ; LOOP IF NOT AT START OF STACKXXC3B7 = *     RTS;***********************************************************************************;;; OPEN UP SPACE IN MEMORY, SET END OF ARRAYSXXC3B8 = *     JSR     XXC408          ; CHECK AVAILABLE MEMORY, DO OUT OF MEMORY ERROR IF NO ROOM     STA     XX31          ; SET END OF ARRAYS LOW BYTE     STY     XX32          ; SET END OF ARRAYS HIGH BYTE; OPEN UP SPACE IN MEMORY, DON'T SET ARRAY ENDXXC3BF = *     SEC                    ; SET CARRY FOR SUBTRACT     LDA     XX5A          ; GET BLOCK END LOW BYTE     SBC     XX5F          ; SUBTRACT BLOCK START LOW BYTE     STA     XX22          ; SAVE MOD(BLOCK LENGTH/$100) BYTE     TAY                    ; COPY MOD(BLOCK LENGTH/$100) BYTE TO Y     LDA     XX5B          ; GET BLOCK END HIGH BYTE     SBC     XX60          ; SUBTRACT BLOCK START HIGH BYTE     TAX                    ; COPY BLOCK LENGTH HIGH BYTE TO X     INX                    ; +1 TO ALLOW FOR COUNT=0 EXIT     TYA                    ; COPY BLOCK LENGTH LOW BYTE TO A     BEQ     XXC3F3          ; BRANCH IF LENGTH LOW BYTE=0                         ; BLOCK IS (X-1)*256+Y BYTES, DO THE Y BYTES FIRST     LDA     XX5A          ; GET BLOCK END LOW BYTE     SEC                    ; SET CARRY FOR SUBTRACT     SBC     XX22          ; SUBTRACT MOD(BLOCK LENGTH/$100) BYTE     STA     XX5A          ; SAVE CORRECTED OLD BLOCK END LOW BYTE     BCS     XXC3DC          ; IF NO UNDERFLOW SKIP THE HIGH BYTE DECREMENT     DEC     XX5B          ; ELSE DECREMENT BLOCK END HIGH BYTE     SEC                    ; SET CARRY FOR SUBTRACTXXC3DC = *     LDA     XX58          ; GET DESTINATION END LOW BYTE     SBC     XX22          ; SUBTRACT MOD(BLOCK LENGTH/$100) BYTE     STA     XX58          ; SAVE MODIFIED NEW BLOCK END LOW BYTE     BCS     XXC3EC          ; IF NO UNDERFLOW SKIP THE HIGH BYTE DECREMENT     DEC     XX59          ; ELSE DECREMENT BLOCK END HIGH BYTE     BCC     XXC3EC          ; BRANCH ALWAYSXXC3E8 = *     LDA     (XX5A),Y          ; GET BYTE FROM SOURCE     STA     (XX58),Y          ; COPY BYTE TO DESTINATIONXXC3EC = *     DEY                    ; DECREMENT INDEX     BNE     XXC3E8          ; LOOP UNTIL Y=0                         ; NOW DO Y=0 INDEXED BYTE     LDA     (XX5A),Y          ; GET BYTE FROM SOURCE     STA     (XX58),Y          ; SAVE BYTE TO DESTINATIONXXC3F3 = *     DEC     XX5B          ; DECREMENT SOURCE POINTER HIGH BYTE     DEC     XX59          ; DECREMENT DESTINATION POINTER HIGH BYTE     DEX                    ; DECREMENT BLOCK COUNT     BNE     XXC3EC          ; LOOP UNTIL COUNT = $0     RTS;***********************************************************************************;;; CHECK THERE IS ROOM ON THE STACK FOR A BYTES; IF THE STACK IS TOO DEEP DO AN OUT OF MEMORY ERRORXXC3FB = *     ASL A                  ; *2     ADC     #$3E               ; NEED AT LEAST $3E BYTES FREE     BCS     XXC435          ; IF OVERFLOW GO DO OUT OF MEMORY ERROR THEN WARM START     STA     XX22          ; SAVE RESULT IN TEMP BYTE     TSX                    ; COPY STACK     CPX     XX22          ; COMPARE NEW LIMIT WITH STACK     BCC     XXC435          ; IF STACK < LIMIT DO OUT OF MEMORY ERROR THEN WARM START     RTS;***********************************************************************************;;; CHECK AVAILABLE MEMORY, DO OUT OF MEMORY ERROR IF NO ROOMXXC408 = *     CPY     XX34          ; COMPARE WITH BOTTOM OF STRING SPACE HIGH BYTE     BCC     XXC434          ; IF LESS THEN EXIT (IS OK)     BNE     XXC412          ; SKIP NEXT TEST IF GREATER (TESTED <)                         ; HIGH BYTE WAS =, NOW DO LOW BYTE     CMP     XX33          ; COMPARE WITH BOTTOM OF STRING SPACE LOW BYTE     BCC     XXC434          ; IF LESS THEN EXIT (IS OK)                         ; ADDRESS IS > STRING STORAGE PTR (OOPS!)XXC412 = *     PHA                    ; PUSH ADDRESS LOW BYTE     LDX     #$09               ; SET INDEX TO SAVE XX57 TO XX60 INCLUSIVE     TYA                    ; COPY ADDRESS HIGH BYTE (TO PUSH ON STACK)                         ; SAVE MISC NUMERIC WORK AREAXXC416 = *     PHA                    ; PUSH BYTE     LDA     XX57,X          ; GET BYTE FROM XX57 TO XX60     DEX                    ; DECREMENT INDEX     BPL     XXC416          ; LOOP UNTIL ALL DONE     JSR     XXD526          ; DO GARBAGE COLLECTION ROUTINE                         ; RESTORE MISC NUMERIC WORK AREA     LDX     #$F7               ; SET INDEX TO RESTORE BYTESXXC421 = *     PLA                    ; POP BYTE     STA     XX60+1,X          ; SAVE BYTE TO XX57 TO XX60     INX                    ; INCREMENT INDEX     BMI     XXC421          ; LOOP WHILE -VE     PLA                    ; POP ADDRESS HIGH BYTE     TAY                    ; COPY BACK TO Y     PLA                    ; POP ADDRESS LOW BYTE     CPY     XX34          ; COMPARE WITH BOTTOM OF STRING SPACE HIGH BYTE     BCC     XXC434          ; IF LESS THEN EXIT (IS OK)     BNE     XXC435          ; IF GREATER DO OUT OF MEMORY ERROR THEN WARM START                         ; HIGH BYTE WAS =, NOW DO LOW BYTE     CMP     XX33          ; COMPARE WITH BOTTOM OF STRING SPACE LOW BYTE     BCS     XXC435          ; IF >= DO OUT OF MEMORY ERROR THEN WARM START                         ; OK EXIT, CARRY CLEARXXC434 = *     RTS;***********************************************************************************;;; DO OUT OF MEMORY ERROR THEN WARM STARTXXC435 = *     LDX     #$10               ; ERROR CODE $10, OUT OF MEMORY ERROR; DO ERROR #X THEN WARM STARTXXC437 = *     JMP     (XX0300)          ; DO ERROR MESSAGE; DO ERROR #X THEN WARM START, THE ERROR MESSAGE VECTOR IS INITIALISED TO POINT HEREXXC43A = *     TXA                    ; COPY ERROR NUMBER     ASL A                  ; *2     TAX                    ; COPY TO INDEX     LDA     XXC328-2,X     ; GET ERROR MESSAGE POINTER LOW BYTE     STA     XX22          ; SAVE IT     LDA     XXC328-1,X     ; GET ERROR MESSAGE POINTER HIGH BYTE     STA     XX23          ; SAVE IT     JSR     XXFFCC          ; CLOSE INPUT AND OUTPUT CHANNELS     LDA     #$00               ; CLEAR A     STA     XX13          ; CLEAR CURRENT I/O CHANNEL, FLAG DEFAULT     JSR     XXCAD7          ; PRINT CR/LF     JSR     XXCB45          ; PRINT '?'     LDY     #$00               ; CLEAR INDEXXXC456 = *     LDA     (XX22),Y          ; GET BYTE FROM MESSAGE     PHA                    ; SAVE STATUS     AND     #$7F               ; MASK 0XXX XXXX, CLEAR B7     JSR     XXCB47          ; OUTPUT CHARACTER     INY                    ; INCREMENT INDEX     PLA                    ; RESTORE STATUS     BPL     XXC456          ; LOOP IF CHARACTER WAS NOT END MARKER     JSR     XXC67A          ; FLUSH BASIC STACK AND CLEAR CONTINUE POINTER     LDA     #<XXC369          ; SET ' ERROR' POINTER LOW BYTE     LDY     #>XXC369          ; SET ' ERROR' POINTER HIGH BYTE;***********************************************************************************;;; PRINT STRING AND DO WARM START, BREAK ENTRYXXC469 = *     JSR     XXCB1E          ; PRINT NULL TERMINATED STRING     LDY     XX3A          ; GET CURRENT LINE NUMBER HIGH BYTE     INY                    ; INCREMENT IT     BEQ     XXC474          ; BRANCH IF WAS IN IMMEDIATE MODE     JSR     XXDDC2          ; DO ' IN ' LINE NUMBER MESSAGE;***********************************************************************************;;; DO WARM STARTXXC474 = *     LDA     #<XXC376          ; SET 'READY.' POINTER LOW BYTE     LDY     #>XXC376          ; SET 'READY.' POINTER HIGH BYTE     JSR     XXCB1E          ; PRINT NULL TERMINATED STRING     LDA     #$80               ; SET FOR CONTROL MESSAGES ONLY     JSR     XXFF90          ; CONTROL KERNAL MESSAGESXXC480 = *     JMP     (XX0302)          ; DO BASIC WARM START;***********************************************************************************;;; BASIC WARM START, THE WARM START VECTOR IS INITIALISED TO POINT HEREXXC483 = *     JSR     XXC560          ; CALL FOR BASIC INPUT     STX     XX7A          ; SAVE BASIC EXECUTE POINTER LOW BYTE     STY     XX7B          ; SAVE BASIC EXECUTE POINTER HIGH BYTE     JSR     XX0073          ; INCREMENT AND SCAN MEMORY     TAX                    ; COPY BYTE TO SET FLAGS     BEQ     XXC480          ; LOOP IF NO INPUT; GOT TO INTERPRET INPUT LINE NOW ....     LDX     #$FF               ; CURRENT LINE HIGH BYTE TO -1, INDICATES IMMEDIATE MODE     STX     XX3A          ; SET CURRENT LINE NUMBER HIGH BYTE     BCC     XXC49C          ; IF NUMERIC CHARACTER GO HANDLE NEW BASIC LINE                         ; NO LINE NUMBER .. IMMEDIATE MODE     JSR     XXC579          ; CRUNCH KEYWORDS INTO BASIC TOKENS     JMP     XXC7E1          ; GO SCAN AND INTERPRET CODE; HANDLE NEW BASIC LINEXXC49C = *     JSR     XXC96B          ; GET FIXED-POINT NUMBER INTO TEMPORARY INTEGER     JSR     XXC579          ; CRUNCH KEYWORDS INTO BASIC TOKENS     STY     XX0B          ; SAVE INDEX POINTER TO END OF CRUNCHED LINE     JSR     XXC613          ; SEARCH BASIC FOR TEMPORARY INTEGER LINE NUMBER     BCC     XXC4ED          ; IF NOT FOUND SKIP THE LINE DELETE                         ; LINE # ALREADY EXISTS SO DELETE IT     LDY     #$01               ; SET INDEX TO NEXT LINE POINTER HIGH BYTE     LDA     (XX5F),Y          ; GET NEXT LINE POINTER HIGH BYTE     STA     XX23          ; SAVE IT     LDA     XX2D          ; GET START OF VARIABLES LOW BYTE     STA     XX22          ; SAVE IT     LDA     XX60          ; GET FOUND LINE POINTER HIGH BYTE     STA     XX25          ; SAVE IT     LDA     XX5F          ; GET FOUND LINE POINTER LOW BYTE     DEY                    ; DECREMENT INDEX     SBC     (XX5F),Y          ; SUBTRACT NEXT LINE POINTER LOW BYTE     CLC                    ; CLEAR CARRY FOR ADD     ADC     XX2D          ; ADD START OF VARIABLES LOW BYTE     STA     XX2D          ; SET START OF VARIABLES LOW BYTE     STA     XX24          ; SAVE DESTINATION POINTER LOW BYTE     LDA     XX2E          ; GET START OF VARIABLES HIGH BYTE     ADC     #$FF               ; -1 + CARRY     STA     XX2E          ; SET START OF VARIABLES HIGH BYTE     SBC     XX60          ; SUBTRACT FOUND LINE POINTER HIGH BYTE     TAX                    ; COPY TO BLOCK COUNT     SEC                    ; SET CARRY FOR SUBTRACT     LDA     XX5F          ; GET FOUND LINE POINTER LOW BYTE     SBC     XX2D          ; SUBTRACT START OF VARIABLES LOW BYTE     TAY                    ; COPY TO BYTES IN FIRST BLOCK COUNT     BCS     XXC4D7          ; IF NO UNDERFLOW SKIP THE HIGH BYTE DECREMENT     INX                    ; INCREMENT BLOCK COUNT, CORRECT FOR = 0 LOOP EXIT     DEC     XX25          ; DECREMENT DESTINATION HIGH BYTEXXC4D7 = *     CLC                    ; CLEAR CARRY FOR ADD     ADC     XX22          ; ADD SOURCE POINTER LOW BYTE     BCC     XXC4DF          ; IF NO UNDERFLOW SKIP THE HIGH BYTE DECREMENT     DEC     XX23          ; ELSE DECREMENT SOURCE POINTER HIGH BYTE     CLC                    ; CLEAR CARRY                         ; CLOSE UP MEMORY TO DELETE OLD LINEXXC4DF = *     LDA     (XX22),Y          ; GET BYTE FROM SOURCE     STA     (XX24),Y          ; COPY TO DESTINATION     INY                    ; INCREMENT INDEX     BNE     XXC4DF          ; WHILE <> 0 DO THIS BLOCK     INC     XX23          ; INCREMENT SOURCE POINTER HIGH BYTE     INC     XX25          ; INCREMENT DESTINATION POINTER HIGH BYTE     DEX                    ; DECREMENT BLOCK COUNT     BNE     XXC4DF          ; LOOP UNTIL ALL DONE                         ; GOT NEW LINE IN BUFFER AND NO EXISTING SAME #XXC4ED = *     JSR     XXC659          ; RESET EXECUTION TO START, CLEAR VARIABLES, FLUSH STACK                         ; AND RETURN     JSR     XXC533          ; REBUILD BASIC LINE CHAINING     LDA     XX0200          ; GET FIRST BYTE FROM BUFFER     BEQ     XXC480          ; IF NO LINE GO DO BASIC WARM START                         ; ELSE INSERT LINE INTO MEMORY     CLC                    ; CLEAR CARRY FOR ADD     LDA     XX2D          ; GET START OF VARIABLES LOW BYTE     STA     XX5A          ; SAVE AS SOURCE END POINTER LOW BYTE     ADC     XX0B          ; ADD INDEX POINTER TO END OF CRUNCHED LINE     STA     XX58          ; SAVE AS DESTINATION END POINTER LOW BYTE     LDY     XX2E          ; GET START OF VARIABLES HIGH BYTE     STY     XX5B          ; SAVE AS SOURCE END POINTER HIGH BYTE     BCC     XXC508          ; IF NO CARRY SKIP THE HIGH BYTE INCREMENT     INY                    ; ELSE INCREMENT THE HIGH BYTEXXC508 = *     STY     XX59          ; SAVE AS DESTINATION END POINTER HIGH BYTE     JSR     XXC3B8          ; OPEN UP SPACE IN MEMORY; MOST OF WHAT REMAINS TO DO IS COPY THE CRUNCHED LINE INTO THE SPACE OPENED UP IN MEMORY,; HOWEVER, BEFORE THE CRUNCHED LINE COMES THE NEXT LINE POINTER AND THE LINE NUMBER. THE; LINE NUMBER IS RETRIEVED FROM THE TEMPORARY INTEGER AND STORED IN MEMORY, THIS; OVERWRITES THE BOTTOM TWO BYTES ON THE STACK. NEXT THE LINE IS COPIED AND THE NEXT LINE; POINTER IS FILLED WITH WHATEVER WAS IN TWO BYTES ABOVE THE LINE NUMBER IN THE STACK.; THIS IS OK BECAUSE THE LINE POINTER GETS FIXED IN THE LINE CHAIN RE-BUILD.     LDA     XX14          ; GET LINE NUMBER LOW BYTE     LDY     XX15          ; GET LINE NUMBER HIGH BYTE     STA     XX01FE          ; SAVE LINE NUMBER LOW BYTE BEFORE CRUNCHED LINE     STY     XX01FF          ; SAVE LINE NUMBER HIGH BYTE BEFORE CRUNCHED LINE     LDA     XX31          ; GET END OF ARRAYS LOW BYTE     LDY     XX32          ; GET END OF ARRAYS HIGH BYTE     STA     XX2D          ; SET START OF VARIABLES LOW BYTE     STY     XX2E          ; SET START OF VARIABLES HIGH BYTE     LDY     XX0B          ; GET INDEX TO END OF CRUNCHED LINE     DEY                    ; -1XXC522 = *     LDA     XX01FC,Y          ; GET BYTE FROM CRUNCHED LINE     STA     (XX5F),Y          ; SAVE BYTE TO MEMORY     DEY                    ; DECREMENT INDEX     BPL     XXC522          ; LOOP WHILE MORE TO DO; RESET EXECUTION, CLEAR VARIABLES, FLUSH STACK, REBUILD BASIC CHAIN AND DO WARM STARTXXC52A = *     JSR     XXC659          ; RESET EXECUTION TO START, CLEAR VARIABLES AND FLUSH STACK     JSR     XXC533          ; REBUILD BASIC LINE CHAINING     JMP     XXC480          ; GO DO BASIC WARM START;***********************************************************************************;;; REBUILD BASIC LINE CHAININGXXC533 = *     LDA     XX2B          ; GET START OF MEMORY LOW BYTE     LDY     XX2C          ; GET START OF MEMORY HIGH BYTE     STA     XX22          ; SET LINE START POINTER LOW BYTE     STY     XX23          ; SET LINE START POINTER HIGH BYTE     CLC                    ; CLEAR CARRY FOR ADDXXC53C = *     LDY     #$01               ; SET INDEX TO POINTER TO NEXT LINE HIGH BYTE     LDA     (XX22),Y          ; GET POINTER TO NEXT LINE HIGH BYTE     BEQ     XXC55F          ; EXIT IF NULL, [EOT]     LDY     #$04               ; POINT TO FIRST CODE BYTE OF LINE                         ; THERE IS ALWAYS 1 BYTE + [EOL] AS NULL ENTRIES ARE DELETEDXXC544 = *     INY                    ; NEXT CODE BYTE     LDA     (XX22),Y          ; GET BYTE     BNE     XXC544          ; LOOP IF NOT [EOL]     INY                    ; POINT TO BYTE PAST [EOL], START OF NEXT LINE     TYA                    ; COPY IT     ADC     XX22          ; ADD LINE START POINTER LOW BYTE     TAX                    ; COPY TO X     LDY     #$00               ; CLEAR INDEX, POINT TO THIS LINE'S NEXT LINE POINTER     STA     (XX22),Y          ; SET NEXT LINE POINTER LOW BYTE     LDA     XX23          ; GET LINE START POINTER HIGH BYTE     ADC     #$00               ; ADD ANY OVERFLOW     INY                    ; INCREMENT INDEX TO HIGH BYTE     STA     (XX22),Y          ; SET NEXT LINE POINTER HIGH BYTE     STX     XX22          ; SET LINE START POINTER LOW BYTE     STA     XX23          ; SET LINE START POINTER HIGH BYTE     BCC     XXC53C          ; GO DO NEXT LINE, BRANCH ALWAYSXXC55F = *     RTS;***********************************************************************************;;; CALL FOR BASIC INPUTXXC560 = *     LDX     #$00               ; SET CHANNEL $00, KEYBOARDXXC562 = *     JSR     XXE10F          ; INPUT CHARACTER FROM CHANNEL WITH ERROR CHECK     CMP     #$0D               ; COMPARE WITH [CR]     BEQ     XXC576          ; IF [CR] SET XY TO XX200 - 1, PRINT [CR] AND EXIT                         ; CHARACTER WAS NOT [CR]     STA     XX0200,X          ; SAVE CHARACTER TO BUFFER     INX                    ; INCREMENT BUFFER INDEX     CPX     #$59               ; COMPARE WITH MAX+1     BCC     XXC562          ; BRANCH IF < MAX+1     LDX     #$17               ; ERROR $17, STRING TOO LONG ERROR     JMP     XXC437          ; DO ERROR #X THEN WARM STARTXXC576 = *     JMP     XXCACA          ; SET XY TO XX200 - 1 AND PRINT [CR];***********************************************************************************;;; CRUNCH BASIC TOKENS VECTORXXC579 = *     JMP     (XX0304)          ; DO CRUNCH BASIC TOKENS;***********************************************************************************;;; CRUNCH BASIC TOKENS, THE CRUNCH BASIC TOKENS VECTOR IS INITIALISED TO POINT HEREXXC57C = *     LDX     XX7A          ; GET BASIC EXECUTE POINTER LOW BYTE     LDY     #$04               ; SET SAVE INDEX     STY     XX0F          ; CLEAR OPEN QUOTE/DATA FLAGXXC582 = *     LDA     XX0200,X          ; GET A BYTE FROM THE INPUT BUFFER     BPL     XXC58E          ; IF B7 CLEAR GO DO CRUNCHING     CMP     #TPI          ; COMPARE WITH THE TOKEN FOR PI, THIS TOKE IS INPUT                         ; DIRECTLY FROM THE KEYBOARD AS THE PI CHARACTER.     BEQ     XXC5C9          ; IF PI SAVE BYTE THEN CONTINUE CRUNCHING                         ; THIS IS THE BIT OF CODE THAT STOPS YOU BEING ABLE TO ENTER                         ; SOME KEYWORDS AS JUST SINGLE SHIFTED CHARACTERS. IF THIS                         ; DROPPED THROUGH YOU WOULD BE ABLE TO ENTER GOTO AS JUST                         ; [SHIFT]G     INX                    ; INCREMENT READ INDEX     BNE     XXC582          ; LOOP IF MORE TO DO, BRANCH ALWAYSXXC58E = *     CMP     #' '               ; COMPARE WITH [SPACE]     BEQ     XXC5C9          ; IF [SPACE] SAVE BYTE THEN CONTINUE CRUNCHING     STA     XX08          ; SAVE BUFFER BYTE AS SEARCH CHARACTER     CMP     #$22               ; COMPARE WITH QUOTE CHARACTER      BEQ     XXC5EE          ; IF QUOTE GO COPY QUOTED STRING     BIT     XX0F          ; GET OPEN QUOTE/DATA TOKEN FLAG     BVS     XXC5C9          ; BRANCH IF B6 OF OQUOTE SET, WAS DATA                         ; GO SAVE BYTE THEN CONTINUE CRUNCHING     CMP     #'?'               ; COMPARE WITH '?' CHARACTER     BNE     XXC5A4          ; IF NOT '?' CONTINUE CRUNCHING     LDA     #TPRINT          ; ELSE SET THE TOKEN FOR PRINT     BNE     XXC5C9          ; GO SAVE BYTE THEN CONTINUE CRUNCHING ,BRANCH ALWAYSXXC5A4 = *     CMP     #'0'               ; COMPARE WITH '0'     BCC     XXC5AC          ; IF < '0' CONTINUE CRUNCHING     CMP     #'<'               ; COMPARE WITH '<'     BCC     XXC5C9          ; IF <, 0123456789:; GO SAVE BYTE THEN CONTINUE CRUNCHING                         ; GETS HERE WITH NEXT CHARACTER NOT NUMERIC, ';' OR ':'XXC5AC = *     STY     XX71          ; COPY SAVE INDEX     LDY     #$00               ; CLEAR TABLE POINTER     STY     XX0B          ; CLEAR WORD INDEX     DEY                    ; ADJUST FOR PRE INCREMENT LOOP     STX     XX7A          ; SAVE BASIC EXECUTE POINTER LOW BYTE, BUFFER INDEX     DEX                    ; ADJUST FOR PRE INCREMENT LOOPXXC5B6 = *     INY                    ; NEXT TABLE BYTE     INX                    ; NEXT BUFFER BYTEXXC5B8 = *     LDA     XX0200,X          ; GET BYTE FROM INPUT BUFFER     SEC                    ; SET CARRY FOR SUBTRACT     SBC     XXC09E,Y          ; SUBTRACT TABLE BYTE     BEQ     XXC5B6          ; GO COMPARE NEXT IF MATCH     CMP     #$80               ; WAS IT END MARKER MATCH ?     BNE     XXC5F5          ; IF NOT GO TRY THE NEXT KEYWORD                         ; ACTUALLY THIS WORKS EVEN IF THE INPUT BUFFER BYTE IS THE                         ; END MARKER, I.E. A SHIFTED CHARACTER. AS YOU CAN'T ENTER                         ; ANY KEYWORDS AS A SINGLE SHIFTED CHARACTER, SEE ABOVE,                         ; YOU CAN ENTER KEYWORDS IN SHORTHAND BY SHIFTING ANY                         ; CHARACTER AFTER THE FIRST. SO RETURN CAN BE ENTERED AS                         ; R[SHIFT]E, RE[SHIFT]T, RET[SHIFT]U OR RETU[SHIFT]R.                         ; RETUR[SHIFT]N HOWEVER WILL NOT WORK BECAUSE THE [SHIFT]N                         ; WILL MATCH THE RETURN END MARKER SO THE ROUTINE WILL TRY                         ; TO MATCH THE NEXT CHARACTER.                         ; ELSE FOUND KEYWORD     ORA     XX0B          ; OR WITH WORD INDEX, +$80 IN A MAKES TOKENXXC5C7 = *     LDY     XX71          ; RESTORE SAVE INDEX; SAVE BYTE THEN CONTINUE CRUNCHINGXXC5C9 = *     INX                    ; INCREMENT BUFFER READ INDEX     INY                    ; INCREMENT SAVE INDEX     STA     XX0200-5,Y     ; SAVE BYTE TO OUTPUT     LDA     XX0200-5,Y     ; GET BYTE FROM OUTPUT, SET FLAGS     BEQ     XXC609          ; BRANCH IF WAS NULL [EOL]                         ; A HOLDS THE TOKEN HERE     SEC                    ; SET CARRY FOR SUBTRACT     SBC     #':'               ; SUBTRACT ':'     BEQ     XXC5DC          ; BRANCH IF IT WAS (IS NOW $00)                         ; A NOW HOLDS TOKEN-':'     CMP     #$49 ;#TDATA-':'     ; COMPARE WITH THE TOKEN FOR DATA-':'     BNE     XXC5DE          ; IF NOT DATA GO TRY REM                         ; TOKEN WAS : OR DATAXXC5DC = *     STA     XX0F          ; SAVE TOKEN-':'XXC5DE = *     SEC                    ; SET CARRY FOR SUBTRACT     SBC     #$55 ;#TREM-':'          ; SUBTRACT THE TOKEN FOR REM-':'     BNE     XXC582          ; IF WASN'T REM GO CRUNCH NEXT BIT OF LINE     STA     XX08          ; ELSE WAS REM SO SET SEARCH FOR [EOL]                         ; LOOP FOR '...' ETC.XXC5E5 = *     LDA     XX0200,X          ; GET BYTE FROM INPUT BUFFER     BEQ     XXC5C9          ; IF NULL [EOL] SAVE BYTE THEN CONTINUE CRUNCHING     CMP     XX08          ; COMPARE WITH STORED CHARACTER     BEQ     XXC5C9          ; IF MATCH SAVE BYTE THEN CONTINUE CRUNCHINGXXC5EE = *     INY                    ; INCREMENT SAVE INDEX     STA     XX0200-5,Y     ; SAVE BYTE TO OUTPUT     INX                    ; INCREMENT BUFFER INDEX     BNE     XXC5E5          ; LOOP WHILE <> 0, SHOULD NEVER REACH 0                         ; NOT FOUND KEYWORD THIS GOXXC5F5 = *     LDX     XX7A          ; RESTORE BASIC EXECUTE POINTER LOW BYTE     INC     XX0B          ; INCREMENT WORD INDEX (NEXT WORD)                         ; NOW FIND END OF THIS WORD IN THE TABLEXXC5F9 = *     INY                    ; INCREMENT TABLE INDEX     LDA     XXC09E-1,Y     ; GET TABLE BYTE     BPL     XXC5F9          ; LOOP IF NOT END OF WORD YET     LDA     XXC09E,Y          ; GET BYTE FROM KEYWORD TABLE     BNE     XXC5B8          ; GO TEST NEXT WORD IF NOT ZERO BYTE, END OF TABLE                         ; REACHED END OF TABLE WITH NO MATCH     LDA     XX0200,X          ; RESTORE BYTE FROM INPUT BUFFER     BPL     XXC5C7          ; BRANCH ALWAYS, ALL UNMATCHED BYTES IN THE BUFFER ARE                         ; $00 TO $7F, GO SAVE BYTE IN OUTPUT AND CONTINUE CRUNCHING                         ; REACHED [EOL]XXC609 = *     STA     XX0200-3,Y     ; SAVE [EOL]     DEC     XX7B          ; DECREMENT BASIC EXECUTE POINTER HIGH BYTE     LDA     #$FF               ; POINT TO START OF BUFFER-1     STA     XX7A          ; SET BASIC EXECUTE POINTER LOW BYTE     RTS;***********************************************************************************;;; SEARCH BASIC FOR TEMPORARY INTEGER LINE NUMBERXXC613 = *     LDA     XX2B          ; GET START OF MEMORY LOW BYTE     LDX     XX2C          ; GET START OF MEMORY HIGH BYTE; SEARCH BASIC FOR TEMP INTEGER LINE NUMBER FROM AX; RETURNS CARRY SET IF FOUNDXXC617 = *     LDY     #$01               ; SET INDEX TO NEXT LINE POINTER HIGH BYTE     STA     XX5F          ; SAVE LOW BYTE AS CURRENT     STX     XX60          ; SAVE HIGH BYTE AS CURRENT     LDA     (XX5F),Y          ; GET NEXT LINE POINTER HIGH BYTE FROM ADDRESS     BEQ     XXC640          ; POINTER WAS ZERO SO DONE, EXIT     INY                    ; INCREMENT INDEX ...     INY                    ; ... TO LINE # HIGH BYTE     LDA     XX15          ; GET TEMPORARY INTEGER HIGH BYTE     CMP     (XX5F),Y          ; COMPARE WITH LINE # HIGH BYTE     BCC     XXC641          ; EXIT IF TEMP < THIS LINE, TARGET LINE PASSED     BEQ     XXC62E          ; GO CHECK LOW BYTE IF =     DEY                    ; ELSE DECREMENT INDEX     BNE     XXC637          ; BRANCH ALWAYSXXC62E = *     LDA     XX14          ; GET TEMPORARY INTEGER LOW BYTE     DEY                    ; DECREMENT INDEX TO LINE # LOW BYTE     CMP     (XX5F),Y          ; COMPARE WITH LINE # LOW BYTE     BCC     XXC641          ; EXIT IF TEMP < THIS LINE, TARGET LINE PASSED     BEQ     XXC641          ; EXIT IF TEMP = (FOUND LINE#)                         ; NOT QUITE THERE YETXXC637 = *     DEY                    ; DECREMENT INDEX TO NEXT LINE POINTER HIGH BYTE     LDA     (XX5F),Y          ; GET NEXT LINE POINTER HIGH BYTE     TAX                    ; COPY TO X     DEY                    ; DECREMENT INDEX TO NEXT LINE POINTER LOW BYTE     LDA     (XX5F),Y          ; GET NEXT LINE POINTER LOW BYTE     BCS     XXC617          ; GO SEARCH FOR LINE # IN TEMPORARY INTEGER                         ; FROM AX, CARRY ALWAYS SETXXC640 = *     CLC                    ; CLEAR FOUND FLAGXXC641 = *     RTS;***********************************************************************************;;; PERFORM NEWXXC642 = *     BNE     XXC641          ; EXIT IF FOLLOWING BYTE TO ALLOW SYNTAX ERRORXXC644 = *     LDA     #$00               ; CLEAR A     TAY                    ; CLEAR INDEX     STA     (XX2B),Y          ; CLEAR POINTER TO NEXT LINE LOW BYTE     INY                    ; INCREMENT INDEX     STA     (XX2B),Y          ; CLEAR POINTER TO NEXT LINE HIGH BYTE, ERASE PROGRAM     LDA     XX2B          ; GET START OF MEMORY LOW BYTE     CLC                    ; CLEAR CARRY FOR ADD     ADC     #$02               ; ADD NULL PROGRAM LENGTH     STA     XX2D          ; SET START OF VARIABLES LOW BYTE     LDA     XX2C          ; GET START OF MEMORY HIGH BYTE     ADC     #$00               ; ADD CARRY     STA     XX2E          ; SET START OF VARIABLES HIGH BYTE; RESET EXECUTE POINTER AND DO CLRXXC659 = *     JSR     XXC68E          ; SET BASIC EXECUTE POINTER TO START OF MEMORY - 1     LDA     #$00               ; SET ZB FOR CLR ENTRY;***********************************************************************************;;; PERFORM CLRXXC65E = *     BNE     XXC68D          ; EXIT IF FOLLOWING BYTE TO ALLOW SYNTAX ERRORXXC660 = *     JSR     XXFFE7          ; CLOSE ALL CHANNELS AND FILESXXC663 = *     LDA     XX37          ; GET END OF MEMORY LOW BYTE     LDY     XX38          ; GET END OF MEMORY HIGH BYTE     STA     XX33          ; SET BOTTOM OF STRING SPACE LOW BYTE, CLEAR STRINGS     STY     XX34          ; SET BOTTOM OF STRING SPACE HIGH BYTE     LDA     XX2D          ; GET START OF VARIABLES LOW BYTE     LDY     XX2E          ; GET START OF VARIABLES HIGH BYTE     STA     XX2F          ; SET END OF VARIABLES LOW BYTE, CLEAR VARIABLES     STY     XX30          ; SET END OF VARIABLES HIGH BYTE     STA     XX31          ; SET END OF ARRAYS LOW BYTE, CLEAR ARRAYS     STY     XX32          ; SET END OF ARRAYS HIGH BYTE;***********************************************************************************;;; DO RESTORE AND CLEAR THE STACKXXC677 = *     JSR     XXC81D          ; PERFORM RESTORE; FLUSH BASIC STACK AND CLEAR THE CONTINUE POINTERXXC67A = *     LDX     #XX19          ; GET DESCRIPTOR STACK START     STX     XX16          ; SET DESCRIPTOR STACK POINTER     PLA                    ; PULL RETURN ADDRESS LOW BYTE     TAY                    ; COPY IT     PLA                    ; PULL RETURN ADDRESS HIGH BYTE     LDX     #$FA               ; SET CLEARED STACK POINTER     TXS                    ; SET STACK     PHA                    ; PUSH RETURN ADDRESS HIGH BYTE     TYA                    ; RESTORE RETURN ADDRESS LOW BYTE     PHA                    ; PUSH RETURN ADDRESS LOW BYTE     LDA     #$00               ; CLEAR A     STA     XX3E          ; CLEAR CONTINUE POINTER HIGH BYTE     STA     XX10          ; CLEAR SUBSCRIPT/FNX FLAGXXC68D = *     RTS;***********************************************************************************;;; SET BASIC EXECUTE POINTER TO START OF MEMORY - 1XXC68E = *     CLC                    ; CLEAR CARRY FOR ADD     LDA     XX2B          ; GET START OF MEMORY LOW BYTE     ADC     #$FF               ; ADD -1 LOW BYTE     STA     XX7A          ; SET BASIC EXECUTE POINTER LOW BYTE     LDA     XX2C          ; GET START OF MEMORY HIGH BYTE     ADC     #$FF               ; ADD -1 HIGH BYTE     STA     XX7B          ; SAVE BASIC EXECUTE POINTER HIGH BYTE     RTS;***********************************************************************************;;; PERFORM LISTXXC69C = *     BCC     XXC6A4          ; BRANCH IF NEXT CHARACTER NOT TOKEN (LIST N...)     BEQ     XXC6A4          ; BRANCH IF NEXT CHARACTER [NULL] (LIST)     CMP     #TMINUS          ; COMPARE WITH TOKEN FOR -     BNE     XXC68D          ; EXIT IF NOT - (LIST -M)                         ; LIST [[N][-M]]                         ; THIS BIT SETS THE N , IF PRESENT, AS THE START AND ENDXXC6A4 = *     JSR     XXC96B          ; GET FIXED-POINT NUMBER INTO TEMPORARY INTEGER     JSR     XXC613          ; SEARCH BASIC FOR TEMPORARY INTEGER LINE NUMBER     JSR     XX0079          ; SCAN MEMORY     BEQ     XXC6BB          ; BRANCH IF NO MORE CHRS                         ; THIS BIT CHECKS THE - IS PRESENT     CMP     #TMINUS          ; COMPARE WITH '-'     BNE     XXC641          ; RETURN IF NOT '-' (WILL BE SN ERROR)                         ; LIST [N]-M                         ; THE - WAS THERE SO SET M AS THE END VALUE     JSR     XX0073          ; INCREMENT AND SCAN MEMORY     JSR     XXC96B          ; GET FIXED-POINT NUMBER INTO TEMPORARY INTEGER     BNE     XXC641          ; EXIT IF NOT OKXXC6BB = *     PLA                    ; DUMP RETURN ADDRESS LOW BYTE, EXIT VIA WARM START     PLA                    ; DUMP RETURN ADDRESS HIGH BYTE     LDA     XX14          ; GET TEMPORARY INTEGER LOW BYTE     ORA     XX15          ; OR TEMPORARY INTEGER HIGH BYTE     BNE     XXC6C9          ; BRANCH IF START SET     LDA     #$FF               ; SET FOR -1     STA     XX14          ; SET TEMPORARY INTEGER LOW BYTE     STA     XX15          ; SET TEMPORARY INTEGER HIGH BYTEXXC6C9 = *     LDY     #$01               ; SET INDEX FOR LINE     STY     XX0F          ; CLEAR OPEN QUOTE FLAG     LDA     (XX5F),Y          ; GET NEXT LINE POINTER HIGH BYTE     BEQ     XXC714          ; IF NULL ALL DONE SO EXIT     JSR     XXC82C          ; DO CRTL-C CHECK VECTOR     JSR     XXCAD7          ; PRINT CR/LF     INY                    ; INCREMENT INDEX FOR LINE     LDA     (XX5F),Y          ; GET LINE NUMBER LOW BYTE     TAX                    ; COPY TO X     INY                    ; INCREMENT INDEX     LDA     (XX5F),Y          ; GET LINE NUMBER HIGH BYTE     CMP     XX15          ; COMPARE WITH TEMPORARY INTEGER HIGH BYTE     BNE     XXC6E6          ; BRANCH IF NO HIGH BYTE MATCH     CPX     XX14          ; COMPARE WITH TEMPORARY INTEGER LOW BYTE     BEQ     XXC6E8          ; BRANCH IF = LAST LINE TO DO, < WILL PASS NEXT BRANCHXXC6E6 = *                    ; ELSE ...     BCS     XXC714          ; IF GREATER ALL DONE SO EXITXXC6E8 = *     STY     XX49          ; SAVE INDEX FOR LINE     JSR     XXDDCD          ; PRINT XA AS UNSIGNED INTEGER     LDA     #' '               ; SPACE IS THE NEXT CHARACTERXXC6EF = *     LDY     XX49          ; GET INDEX FOR LINE     AND     #$7F               ; MASK TOP OUT BIT OF CHARACTERXXC6F3 = *     JSR     XXCB47          ; GO PRINT THE CHARACTER     CMP     #$22               ; WAS IT ' CHARACTER     BNE     XXC700          ; IF NOT SKIP THE QUOTE HANDLE                         ; WE ARE EITHER ENTERING OR LEAVING A PAIR OF QUOTES     LDA     XX0F          ; GET OPEN QUOTE FLAG     EOR     #$FF               ; TOGGLE IT     STA     XX0F          ; SAVE IT BACKXXC700 = *     INY                    ; INCREMENT INDEX     BEQ     XXC714          ; LINE TOO LONG SO JUST BAIL OUT AND DO A WARM START     LDA     (XX5F),Y          ; GET NEXT BYTE     BNE     XXC717          ; IF NOT [EOL] (GO PRINT CHARACTER)                         ; WAS [EOL]     TAY                    ; ELSE CLEAR INDEX     LDA     (XX5F),Y          ; GET NEXT LINE POINTER LOW BYTE     TAX                    ; COPY TO X     INY                    ; INCREMENT INDEX     LDA     (XX5F),Y          ; GET NEXT LINE POINTER HIGH BYTE     STX     XX5F          ; SET POINTER TO LINE LOW BYTE     STA     XX60          ; SET POINTER TO LINE HIGH BYTE     BNE     XXC6C9          ; GO DO NEXT LINE IF NOT [EOT]                         ; ELSE ...XXC714 = *     JMP     XXC474          ; DO WARM START;***********************************************************************************;;XXC717 = *     JMP     (XX0306)          ; DO UNCRUNCH BASIC TOKENS;***********************************************************************************;;; UNCRUNCH BASIC TOKENS, THE UNCRUNCH BASIC TOKENS VECTOR IS INITIALISED TO POINT HEREXXC71A = *     BPL     XXC6F3          ; JUST GO PRINT IT IF NOT TOKEN BYTE                         ; ELSE WAS TOKEN BYTE SO UNCRUNCH IT     CMP     #TPI          ; COMPARE WITH THE TOKEN FOR PI. IN THIS CASE THE TOKEN                         ; IS THE SAME AS THE PI CHARACTER SO IT JUST NEEDS PRINTING     BEQ     XXC6F3          ; JUST PRINT IT IF SO     BIT     XX0F          ; TEST THE OPEN QUOTE FLAG     BMI     XXC6F3          ; JUST GO PRINT CHARACTER IF OPEN QUOTE SET     SEC                    ; ELSE SET CARRY FOR SUBTRACT     SBC     #$7F               ; REDUCE TOKEN RANGE TO 1 TO WHATEVER     TAX                    ; COPY TOKEN # TO X     STY     XX49          ; SAVE INDEX FOR LINE     LDY     #$FF               ; START FROM -1, ADJUST FOR PRE INCREMENTXXC72C = *     DEX                    ; DECREMENT TOKEN #     BEQ     XXC737          ; IF NOW FOUND GO DO PRINTINGXXC72F = *     INY                    ; ELSE INCREMENT INDEX     LDA     XXC09E,Y          ; GET BYTE FROM KEYWORD TABLE     BPL     XXC72F          ; LOOP UNTIL KEYWORD END MARKER     BMI     XXC72C          ; GO TEST IF THIS IS REQUIRED KEYWORD, BRANCH ALWAYS                         ; FOUND KEYWORD, IT'S THE NEXT ONEXXC737 = *     INY                    ; INCREMENT KEYWORD TABLE INDEX     LDA     XXC09E,Y          ; GET BYTE FROM TABLE     BMI     XXC6EF          ; GO RESTORE INDEX, MASK BYTE AND PRINT IF                         ; BYTE WAS END MARKER     JSR     XXCB47          ; ELSE GO PRINT THE CHARACTER     BNE     XXC737          ; GO GET NEXT CHARACTER, BRANCH ALWAYS;***********************************************************************************;;; PERFORM FORXXC742 = *     LDA     #$80               ; SET FNX     STA     XX10          ; SET SUBSCRIPT/FNX FLAG     JSR     XXC9A5          ; PERFORM LET     JSR     XXC38A          ; SEARCH THE STACK FOR FOR OR GOSUB ACTIVITY     BNE     XXC753          ; BRANCH IF FOR, THIS VARIABLE, NOT FOUND                         ; FOR, THIS VARIABLE, WAS FOUND SO FIRST WE DUMP THE OLD ONE     TXA                    ; COPY INDEX     ADC     #$0F               ; ADD FOR STRUCTURE SIZE-2     TAX                    ; COPY TO INDEX     TXS                    ; SET STACK (DUMP FOR STRUCTURE (-2 BYTES))XXC753 = *     PLA                    ; PULL RETURN ADDRESS     PLA                    ; PULL RETURN ADDRESS     LDA     #$09               ; WE NEED 18D BYTES !     JSR     XXC3FB          ; CHECK ROOM ON STACK FOR 2*A BYTES     JSR     XXC906          ; SCAN FOR NEXT BASIC STATEMENT ([:] OR [EOL])     CLC                    ; CLEAR CARRY FOR ADD     TYA                    ; COPY INDEX TO A     ADC     XX7A          ; ADD BASIC EXECUTE POINTER LOW BYTE     PHA                    ; PUSH ONTO STACK     LDA     XX7B          ; GET BASIC EXECUTE POINTER HIGH BYTE     ADC     #$00               ; ADD CARRY     PHA                    ; PUSH ONTO STACK     LDA     XX3A          ; GET CURRENT LINE NUMBER HIGH BYTE     PHA                    ; PUSH ONTO STACK     LDA     XX39          ; GET CURRENT LINE NUMBER LOW BYTE     PHA                    ; PUSH ONTO STACK     LDA     #TTO          ; SET 'TO' TOKEN     JSR     XXCEFF          ; SCAN FOR CHR$(A), ELSE DO SYNTAX ERROR THEN WARM START     JSR     XXCD8D          ; CHECK IF SOURCE IS NUMERIC, ELSE DO TYPE MISMATCH     JSR     XXCD8A          ; EVALUATE EXPRESSION AND CHECK IS NUMERIC, ELSE DO                         ; TYPE MISMATCH     LDA     XX66          ; GET FAC1 SIGN (B7)     ORA     #$7F               ; SET ALL NON SIGN BITS     AND     XX62          ; AND FAC1 MANTISSA 1     STA     XX62          ; SAVE FAC1 MANTISSA 1     LDA     #<XXC78B          ; SET RETURN ADDRESS LOW BYTE     LDY     #>XXC78B          ; SET RETURN ADDRESS HIGH BYTE     STA     XX22          ; SAVE RETURN ADDRESS LOW BYTE     STY     XX23          ; SAVE RETURN ADDRESS HIGH BYTE     JMP     XXCE43          ; ROUND FAC1 AND PUT ON STACK, RETURNS TO NEXT INSTRUCTIONXXC78B = *     LDA     #<XXD9BC          ; SET 1 POINTER LOW ADDRESS, DEFAULT STEP SIZE     LDY     #>XXD9BC          ; SET 1 POINTER HIGH ADDRESS     JSR     XXDBA2          ; UNPACK MEMORY (AY) INTO FAC1     JSR     XX0079          ; SCAN MEMORY     CMP     #TSTEP          ; COMPARE WITH STEP TOKEN     BNE     XXC79F          ; BRANCH IF NOT 'STEP'                         ; WAS STEP SO ....     JSR     XX0073          ; INCREMENT AND SCAN MEMORY     JSR     XXCD8A          ; EVALUATE EXPRESSION AND CHECK IS NUMERIC, ELSE DO                         ; TYPE MISMATCHXXC79F = *     JSR     XXDC2B          ; GET FAC1 SIGN, RETURN A = $FF -VE, A = $01 +VE     JSR     XXCE38          ; PUSH SIGN, ROUND FAC1 AND PUT ON STACK     LDA     XX4A          ; GET FOR/NEXT VARIABLE POINTER HIGH BYTE     PHA                    ; PUSH ON STACK     LDA     XX49          ; GET FOR/NEXT VARIABLE POINTER LOW BYTE     PHA                    ; PUSH ON STACK     LDA     #TFOR          ; GET FOR TOKEN     PHA                    ; PUSH ON STACK;***********************************************************************************;;; INTERPRETER INNER LOOPXXC7AE = *     JSR     XXC82C          ; DO CRTL-C CHECK VECTOR     LDA     XX7A          ; GET BASIC EXECUTE POINTER LOW BYTE     LDY     XX7B          ; GET BASIC EXECUTE POINTER HIGH BYTE     CPY     #$02               ; COMPARE WITH $02XX     NOP                    ; UNUSED BYTE                                   ##     BEQ     XXC7BE          ; IF IMMEDIATE MODE SKIP THE CONTINUE POINTER SAVE     STA     XX3D          ; SAVE THE CONTINUE POINTER LOW BYTE     STY     XX3E          ; SAVE THE CONTINUE POINTER HIGH BYTEXXC7BE = *     LDY     #$00               ; CLEAR THE INDEX     LDA     (XX7A),Y          ; GET BASIC BYTE     BNE     XXC807          ; IF NOT [EOL] GO TEST FOR ':'     LDY     #$02               ; ELSE SET THE INDEX     LDA     (XX7A),Y          ; GET NEXT LINE POINTER HIGH BYTE     CLC                    ; CLEAR CARRY FOR NO 'BREAK' MESSAGE     BNE     XXC7CE          ; BRANCH IF NOT END OF PROGRAM     JMP     XXC84B          ; ELSE GO TO IMMEDIATE MODE,WAS IMMEDIATE OR [EOT] MARKERXXC7CE = *     INY                    ; INCREMENT INDEX     LDA     (XX7A),Y          ; GET LINE NUMBER LOW BYTE     STA     XX39          ; SAVE CURRENT LINE NUMBER LOW BYTE     INY                    ; INCREMENT INDEX     LDA     (XX7A),Y          ; GET LINE # HIGH BYTE     STA     XX3A          ; SAVE CURRENT LINE NUMBER HIGH BYTE     TYA                    ; A NOW = 4     ADC     XX7A          ; ADD BASIC EXECUTE POINTER LOW BYTE, NOW POINTS TO CODE     STA     XX7A          ; SAVE BASIC EXECUTE POINTER LOW BYTE     BCC     XXC7E1          ; IF NO OVERFLOW SKIP THE HIGH BYTE INCREMENT     INC     XX7B          ; ELSE INCREMENT BASIC EXECUTE POINTER HIGH BYTEXXC7E1 = *     JMP     (XX0308)          ; DO START NEW BASIC CODE;***********************************************************************************;;; START NEW BASIC CODE, THE START NEW BASIC CODE VECTOR IS INITIALISED TO POINT HEREXXC7E4 = *     JSR     XX0073          ; INCREMENT AND SCAN MEMORY     JSR     XXC7ED          ; GO INTERPRET BASIC CODE FROM BASIC EXECUTE POINTER     JMP     XXC7AE          ; LOOP;***********************************************************************************;;; GO INTERPRET BASIC CODE FROM BASIC EXECUTE POINTERXXC7ED = *     BEQ     XXC82B          ; IF THE FIRST BYTE IS NULL JUST EXITXXC7EF = *     SBC     #$80               ; NORMALISE THE TOKEN     BCC     XXC804          ; IF WASN'T TOKEN GO DO LET     CMP     #TTAB-$80          ; COMPARE WITH TOKEN FOR TAB(-$80     BCS     XXC80E          ; BRANCH IF >= TAB(     ASL A                  ; *2 BYTES PER VECTOR     TAY                    ; COPY TO INDEX     LDA     XXC00C+1,Y     ; GET VECTOR HIGH BYTE     PHA                    ; PUSH ON STACK     LDA     XXC00C,Y          ; GET VECTOR LOW BYTE     PHA                    ; PUSH ON STACK     JMP     XX0073          ; INCREMENT AND SCAN MEMORY AND RETURN. THE RETURN IN                         ; THIS CASE CALLS THE COMMAND CODE, THE RETURN FROM                         ; THAT WILL EVENTUALLY RETURN TO THE INTERPRETER INNER                         ; LOOP ABOVEXXC804 = *     JMP     XXC9A5          ; PERFORM LET                         ; WAS NOT [EOL]XXC807 = *     CMP     #':'               ; COMAPRE WITH ':'     BEQ     XXC7E1          ; IF ':' GO EXECUTE NEW CODE                         ; ELSE ...XXC80B = *     JMP     XXCF08          ; DO SYNTAX ERROR THEN WARM START                         ; TOKEN WAS >= TAB(XXC80E = *     CMP     #TGO-$80          ; COMPARE WITH TOKEN FOR GO     BNE     XXC80B          ; IF NOT 'GO' DO SYNTAX ERROR THEN WARM START                         ; ELSE WAS 'GO'     JSR     XX0073          ; INCREMENT AND SCAN MEMORY     LDA     #TTO          ; SET 'TO' TOKEN     JSR     XXCEFF          ; SCAN FOR CHR$(A), ELSE DO SYNTAX ERROR THEN WARM START     JMP     XXC8A0          ; PERFORM GOTO;***********************************************************************************;;; PERFORM RESTOREXXC81D = *     SEC                    ; SET CARRY FOR SUBTRACT     LDA     XX2B          ; GET START OF MEMORY LOW BYTE     SBC     #$01               ; -1     LDY     XX2C          ; GET START OF MEMORY HIGH BYTE     BCS     XXC827          ; IF NO ROLLUNDER SKIP THE HIGH BYTE DECREMENT     DEY                    ; ELSE DECREMENT HIGH BYTEXXC827 = *     STA     XX41          ; SET DATA POINTER LOW BYTE     STY     XX42          ; SET DATA POINTER HIGH BYTEXXC82B = *     RTS;***********************************************************************************;;; DO CRTL-C CHECK VECTORXXC82C = *     JSR     XXFFE1          ; SCAN STOP KEY;***********************************************************************************;;; PERFORM STOPXXC82F = *     BCS     XXC832          ; IF CARRY SET DO BREAK INSTEAD OF JUST END;***********************************************************************************;;; PERFORM ENDXXC831 = *     CLC                    ; CLEAR CARRYXXC832 = *     BNE     XXC870          ; RETURN IF WASN'T CTRL-C     LDA     XX7A          ; GET BASIC EXECUTE POINTER LOW BYTE     LDY     XX7B          ; GET BASIC EXECUTE POINTER HIGH BYTE     LDX     XX3A          ; GET CURRENT LINE NUMBER HIGH BYTE     INX                    ; INCREMENT IT     BEQ     XXC849          ; BRANCH IF WAS IMMEDIATE MODE     STA     XX3D          ; SAVE CONTINUE POINTER LOW BYTE     STY     XX3E          ; SAVE CONTINUE POINTER HIGH BYTE     LDA     XX39          ; GET CURRENT LINE NUMBER LOW BYTE     LDY     XX3A          ; GET CURRENT LINE NUMBER HIGH BYTE     STA     XX3B          ; SAVE BREAK LINE NUMBER LOW BYTE     STY     XX3C          ; SAVE BREAK LINE NUMBER HIGH BYTEXXC849 = *     PLA                    ; DUMP RETURN ADDRESS LOW BYTE     PLA                    ; DUMP RETURN ADDRESS HIGH BYTEXXC84B = *     LDA     #<XXC381          ; SET [CR][LF]'BREAK' POINTER LOW BYTE     LDY     #>XXC381          ; SET [CR][LF]'BREAK' POINTER HIGH BYTE     BCC     XXC854          ; BRANCH IF WAS PROGRAM END     JMP     XXC469          ; PRINT STRING AND DO WARM STARTXXC854 = *     JMP     XXC474          ; DO WARM START;***********************************************************************************;;; PERFORM CONTXXC857 = *     BNE     XXC870          ; EXIT IF FOLLOWING BYTE TO ALLOW SYNTAX ERROR     LDX     #$1A               ; ERROR CODE $1A, CAN'T CONTINUE ERROR     LDY     XX3E          ; GET CONTINUE POINTER HIGH BYTE     BNE     XXC862          ; GO DO CONTINUE IF WE CAN     JMP     XXC437          ; ELSE DO ERROR #X THEN WARM START                         ; WE CAN CONTINUE SO ...XXC862 = *     LDA     XX3D          ; GET CONTINUE POINTER LOW BYTE     STA     XX7A          ; SAVE BASIC EXECUTE POINTER LOW BYTE     STY     XX7B          ; SAVE BASIC EXECUTE POINTER HIGH BYTE     LDA     XX3B          ; GET BREAK LINE LOW BYTE     LDY     XX3C          ; GET BREAK LINE HIGH BYTE     STA     XX39          ; SET CURRENT LINE NUMBER LOW BYTE     STY     XX3A          ; SET CURRENT LINE NUMBER HIGH BYTEXXC870 = *     RTS;***********************************************************************************;;; PERFORM RUNXXC871 = *     PHP                    ; SAVE STATUS     LDA     #$00               ; NO CONTROL OR KERNAL MESSAGES     JSR     XXFF90          ; CONTROL KERNAL MESSAGES     PLP                    ; RESTORE STATUS     BNE     XXC87D          ; BRANCH IF RUN N     JMP     XXC659          ; RESET EXECUTION TO START, CLEAR VARIABLES, FLUSH STACK                         ; AND RETURNXXC87D = *     JSR     XXC660          ; GO DO 'CLEAR'     JMP     XXC897          ; GET N AND DO GOTO N;***********************************************************************************;;; PERFORM GOSUBXXC883 = *     LDA     #$03               ; NEED 6 BYTES FOR GOSUB     JSR     XXC3FB          ; CHECK ROOM ON STACK FOR 2*A BYTES     LDA     XX7B          ; GET BASIC EXECUTE POINTER HIGH BYTE     PHA                    ; SAVE IT     LDA     XX7A          ; GET BASIC EXECUTE POINTER LOW BYTE     PHA                    ; SAVE IT     LDA     XX3A          ; GET CURRENT LINE NUMBER HIGH BYTE     PHA                    ; SAVE IT     LDA     XX39          ; GET CURRENT LINE NUMBER LOW BYTE     PHA                    ; SAVE IT     LDA     #TGOSUB          ; TOKEN FOR GOSUB     PHA                    ; SAVE ITXXC897 = *     JSR     XX0079          ; SCAN MEMORY     JSR     XXC8A0          ; PERFORM GOTO     JMP     XXC7AE          ; GO DO INTERPRETER INNER LOOP;***********************************************************************************;;; PERFORM GOTOXXC8A0 = *     JSR     XXC96B          ; GET FIXED-POINT NUMBER INTO TEMPORARY INTEGER     JSR     XXC909          ; SCAN FOR NEXT BASIC LINE     SEC                    ; SET CARRY FOR SUBTRACT     LDA     XX39          ; GET CURRENT LINE NUMBER LOW BYTE     SBC     XX14          ; SUBTRACT TEMPORARY INTEGER LOW BYTE     LDA     XX3A          ; GET CURRENT LINE NUMBER HIGH BYTE     SBC     XX15          ; SUBTRACT TEMPORARY INTEGER HIGH BYTE     BCS     XXC8BC          ; IF CURRENT LINE NUMBER >= TEMPORARY INTEGER, GO SEARCH                         ; FROM THE START OF MEMORY     TYA                    ; ELSE COPY LINE INDEX TO A     SEC                    ; SET CARRY (+1)     ADC     XX7A          ; ADD BASIC EXECUTE POINTER LOW BYTE     LDX     XX7B          ; GET BASIC EXECUTE POINTER HIGH BYTE     BCC     XXC8C0          ; IF NO OVERFLOW SKIP THE HIGH BYTE INCREMENT     INX                    ; INCREMENT HIGH BYTE     BCS     XXC8C0          ; GO FIND THE LINE, BRANCH ALWAYS;***********************************************************************************;;; SEARCH FOR LINE NUMBER IN TEMPORARY INTEGER FROM START OF MEMORY POINTERXXC8BC = *     LDA     XX2B          ; GET START OF MEMORY LOW BYTE     LDX     XX2C          ; GET START OF MEMORY HIGH BYTE; SEARCH FOR LINE # IN TEMPORARY INTEGER FROM (AX)XXC8C0 = *     JSR     XXC617          ; SEARCH BASIC FOR TEMP INTEGER LINE NUMBER FROM AX     BCC     XXC8E3          ; IF CARRY CLEAR GO DO UNSDEFINED STATEMENT ERROR                         ; CARRY ALL READY SET FOR SUBTRACT     LDA     XX5F          ; GET POINTER LOW BYTE     SBC     #$01               ; -1     STA     XX7A          ; SAVE BASIC EXECUTE POINTER LOW BYTE     LDA     XX60          ; GET POINTER HIGH BYTE     SBC     #$00               ; SUBTRACT CARRY     STA     XX7B          ; SAVE BASIC EXECUTE POINTER HIGH BYTEXXC8D1 = *     RTS;***********************************************************************************;;; PERFORM RETURNXXC8D2 = *     BNE     XXC8D1          ; EXIT IF FOLLOWING TOKEN TO ALLOW SYNTAX ERROR     LDA     #$FF               ; SET BYTE SO NO MATCH POSSIBLE     STA     XX4A          ; SAVE FOR/NEXT VARIABLE POINTER HIGH BYTE     JSR     XXC38A          ; SEARCH THE STACK FOR FOR OR GOSUB ACTIVITY,                         ; GET TOKEN OFF STACK     TXS                    ; CORRECT THE STACK     CMP     #TGOSUB          ; COMPARE WITH GOSUB TOKEN     BEQ     XXC8EB          ; IF MATCHING GOSUB GO CONTINUE RETURN     LDX     #$0C               ; ELSE ERROR CODE $04, RETURN WITHOUT GOSUB ERROR     .BYTE     $2C               ; MAKES NEXT LINE BIT XX11A2XXC8E3 = *     LDX     #$11               ; ERROR CODE $11, UNDEFINED STATEMENT ERROR     JMP     XXC437          ; DO ERROR #X THEN WARM STARTXXC8E8 = *     JMP     XXCF08          ; DO SYNTAX ERROR THEN WARM START                         ; WAS MATCHING GOSUB TOKENXXC8EB = *     PLA                    ; DUMP TOKEN BYTE     PLA                    ; PULL RETURN LINE LOW BYTE     STA     XX39          ; SAVE CURRENT LINE NUMBER LOW BYTE     PLA                    ; PULL RETURN LINE HIGH BYTE     STA     XX3A          ; SAVE CURRENT LINE NUMBER HIGH BYTE     PLA                    ; PULL RETURN ADDRESS LOW BYTE     STA     XX7A          ; SAVE BASIC EXECUTE POINTER LOW BYTE     PLA                    ; PULL RETURN ADDRESS HIGH BYTE     STA     XX7B          ; SAVE BASIC EXECUTE POINTER HIGH BYTE;***********************************************************************************;;; PERFORM DATAXXC8F8 = *     JSR     XXC906          ; SCAN FOR NEXT BASIC STATEMENT ([:] OR [EOL]); ADD Y TO THE BASIC EXECUTE POINTERXXC8FB = *     TYA                    ; COPY INDEX TO A     CLC                    ; CLEAR CARRY FOR ADD     ADC     XX7A          ; ADD BASIC EXECUTE POINTER LOW BYTE     STA     XX7A          ; SAVE BASIC EXECUTE POINTER LOW BYTE     BCC     XXC905          ; SKIP INCREMENT IF NO CARRY     INC     XX7B          ; ELSE INCREMENT BASIC EXECUTE POINTER HIGH BYTEXXC905 = *     RTS;***********************************************************************************;;; SCAN FOR NEXT BASIC STATEMENT ([:] OR [EOL]); RETURNS Y AS INDEX TO [:] OR [EOL]XXC906 = *     LDX     #':'               ; SET LOOK FOR CHARACTER = ':'     .BYTE     $2C               ; MAKES NEXT LINE BIT XX00A2; SCAN FOR NEXT BASIC LINE; RETURNS Y AS INDEX TO [EOL]XXC909 = *     LDX     #$00               ; SET ALTERNATE SEARCH CHARACTER = [EOL]     STX     XX07          ; STORE ALTERNATE SEARCH CHARACTER     LDY     #$00               ; SET SEARCH CHARACTER = [EOL]     STY     XX08          ; SAVE THE SEARCH CHARACTERXXC911 = *     LDA     XX08          ; GET SEARCH CHARACTER     LDX     XX07          ; GET ALTERNATE SEARCH CHARACTER     STA     XX07          ; MAKE SEARCH CHARACTER = ALTERNATE SEARCH CHARACTER     STX     XX08          ; MAKE ALTERNATE SEARCH CHARACTER = SEARCH CHARACTERXXC919 = *     LDA     (XX7A),Y          ; GET BASIC BYTE     BEQ     XXC905          ; EXIT IF NULL [EOL]     CMP     XX08          ; COMPARE WITH SEARCH CHARACTER     BEQ     XXC905          ; EXIT IF FOUND     INY                    ; ELSE INCREMENT INDEX     CMP     #$22               ; COMPARE CURRENT CHARACTER WITH OPEN QUOTE     BNE     XXC919          ; IF FOUND GO SWAP SEARCH CHARACTER FOR ALTERNATE SEARCH                         ; CHARACTER     BEQ     XXC911          ; LOOP FOR NEXT CHARACTER, BRANCH ALWAYS;***********************************************************************************;;; PERFORM IFXXC928 = *     JSR     XXCD9E          ; EVALUATE EXPRESSION     JSR     XX0079          ; SCAN MEMORY     CMP     #TGOTO          ; COMPARE WITH 'GOTO' TOKEN     BEQ     XXC937          ; IF IT WAS  THE TOKEN FOR GOTO GO DO IF ... GOTO                         ; WASN'T IF ... GOTO SO MUST BE IF ... THEN     LDA     #TTHEN          ; $A7 = 'THEN' TOKEN     JSR     XXCEFF          ; SCAN FOR CHR$(A), ELSE DO SYNTAX ERROR THEN WARM STARTXXC937 = *     LDA     XX61          ; GET FAC1 EXPONENT     BNE     XXC940          ; IF RESULT WAS NON ZERO CONTINUE EXECUTION                         ; ELSE REM THE REST OF THE LINE;***********************************************************************************;;; PERFORM REMXXC93B = *     JSR     XXC909          ; SCAN FOR NEXT BASIC LINE     BEQ     XXC8FB          ; ADD Y TO THE BASIC EXECUTE POINTER AND RETURN, BRANCH                         ; ALWAYS;***********************************************************************************;;; IF CONTINUED .. RESULT WAS NON ZERO SO DO REST OF LINEXXC940 = *     JSR     XX0079          ; SCAN MEMORY     BCS     XXC948          ; IF NOT NUMERIC CHARACTER, IS VARIABLE OR KEYWORD     JMP     XXC8A0          ; ELSE PERFORM GOTO N                         ; IS VARIABLE OR KEYWORDXXC948 = *     JMP     XXC7ED          ; INTERPRET BASIC CODE FROM BASIC EXECUTE POINTER;***********************************************************************************;;; PERFORM ONXXC94B = *     JSR     XXD79E          ; GET BYTE PARAMETER     PHA                    ; PUSH NEXT CHARACTER     CMP     #TGOSUB          ; COMPARE WITH GOSUB TOKEN     BEQ     XXC957          ; IF GOSUB GO SEE IF IT SHOULD BE EXECUTEDXXC953 = *     CMP     #TGOTO          ; COMPARE WITH GOTO TOKEN     BNE     XXC8E8          ; IF NOT GOTO DO SYNTAX ERROR THEN WARM START; NEXT CHARACTER WAS GOTO OR GOSUB, SEE IF IT SHOULD BE EXECUTEDXXC957 = *     DEC     XX65          ; DECREMENT THE BYTE VALUE     BNE     XXC95F          ; IF NOT ZERO GO SEE IF ANOTHER LINE NUMBER EXISTS     PLA                    ; PULL KEYWORD TOKEN     JMP     XXC7EF          ; GO EXECUTE ITXXC95F = *     JSR     XX0073          ; INCREMENT AND SCAN MEMORY     JSR     XXC96B          ; GET FIXED-POINT NUMBER INTO TEMPORARY INTEGER                         ; SKIP THIS N     CMP     #','               ; COMPARE NEXT CHARACTER WITH ','     BEQ     XXC957          ; LOOP IF ','     PLA                    ; ELSE PULL KEYWORD TOKEN, RAN OUT OF OPTIONSXXC96A = *     RTS;***********************************************************************************;;; GET FIXED-POINT NUMBER INTO TEMPORARY INTEGERXXC96B = *     LDX     #$00               ; CLEAR X     STX     XX14          ; CLEAR TEMPORARY INTEGER LOW BYTE     STX     XX15          ; CLEAR TEMPORARY INTEGER HIGH BYTEXXC971 = *     BCS     XXC96A          ; RETURN IF CARRY SET, END OF SCAN, CHARACTER WAS NOT 0-9     SBC     #$2F               ; SUBTRACT $30, $2F+CARRY, FROM BYTE     STA     XX07          ; STORE #     LDA     XX15          ; GET TEMPORARY INTEGER HIGH BYTE     STA     XX22          ; SAVE IT FOR NOW     CMP     #$19               ; COMPARE WITH $19     BCS     XXC953          ; BRANCH IF >= THIS MAKES THE MAXIMUM LINE NUMBER 63999                         ; BECAUSE THE NEXT BIT DOES $1900 * $0A = $FA00 = 64000                         ; DECIMAL. THE BRANCH TARGET IS REALLY THE SYNTAX ERROR                         ; AT XXC8E8 BUT THAT IS TOO FAR SO AN INTERMEDIATE                         ; COMPARE AND BRANCH TO THAT LOCATION IS USED. THE PROBLEM                         ; WITH THIS IS THAT LINE NUMBER THAT GIVES A PARTIAL RESULT                         ; FROM $8900 TO $89FF, 35072X TO 35327X, WILL PASS THE NEW                         ; TARGET COMPARE AND WILL TRY TO EXECUTE THE REMAINDER OF                         ; THE ON N GOTO/GOSUB. A SOLUTION TO THIS IS TO COPY THE                         ; BYTE IN A BEFORE THE BRANCH TO X AND THEN BRANCH TO                         ; XXC955 SKIPPING THE SECOND COMPARE     LDA     XX14          ; GET TEMPORARY INTEGER LOW BYTE     ASL A                  ; *2 LOW BYTE     ROL     XX22          ; *2 HIGH BYTE     ASL A                  ; *2 LOW BYTE     ROL     XX22          ; *2 HIGH BYTE (*4)     ADC     XX14          ; + LOW BYTE (*5)     STA     XX14          ; SAVE IT     LDA     XX22          ; GET HIGH BYTE TEMP     ADC     XX15          ; + HIGH BYTE (*5)     STA     XX15          ; SAVE IT     ASL     XX14          ; *2 LOW BYTE (*10D)     ROL     XX15          ; *2 HIGH BYTE (*10D)     LDA     XX14          ; GET LOW BYTE     ADC     XX07          ; ADD #     STA     XX14          ; SAVE LOW BYTE     BCC     XXC99F          ; IF NO OVERFLOW SKIP HIGH BYTE INCREMENT     INC     XX15          ; ELSE INCREMENT HIGH BYTEXXC99F = *     JSR     XX0073          ; INCREMENT AND SCAN MEMORY     JMP     XXC971          ; LOOP FOR NEXT CHARACTER;***********************************************************************************;;; PERFORM LETXXC9A5 = *     JSR     XXD08B          ; GET VARIABLE ADDRESS     STA     XX49          ; SAVE VARIABLE ADDRESS LOW BYTE     STY     XX4A          ; SAVE VARIABLE ADDRESS HIGH BYTE     LDA     #TEQUAL          ; $B2 IS '=' TOKEN     JSR     XXCEFF          ; SCAN FOR CHR$(A), ELSE DO SYNTAX ERROR THEN WARM START     LDA     XX0E          ; GET DATA TYPE FLAG, $80 = INTEGER, $00 = FLOAT     PHA                    ; PUSH DATA TYPE FLAG     LDA     XX0D          ; GET DATA TYPE FLAG, $FF = STRING, $00 = NUMERIC     PHA                    ; PUSH DATA TYPE FLAG     JSR     XXCD9E          ; EVALUATE EXPRESSION     PLA                    ; POP DATA TYPE FLAG     ROL A                  ; STRING BIT INTO CARRY     JSR     XXCD90          ; DO TYPE MATCH CHECK     BNE     XXC9D9          ; IF STRING GO ASSIGN A STRING VALUE     PLA                    ; POP INTEGER/FLOAT DATA TYPE FLAG; ASSIGN VALUE TO NUMERIC VARIABLEXXC9C2 = *     BPL     XXC9D6          ; IF FLOAT GO ASSIGN A FLOATING VALUE                         ; EXPRESSION IS NUMERIC INTEGER     JSR     XXDC1B          ; ROUND FAC1     JSR     XXD1BF          ; EVALUATE INTEGER EXPRESSION, NO SIGN CHECK     LDY     #$00               ; CLEAR INDEX     LDA     XX64          ; GET FAC1 MANTISSA 3     STA     (XX49),Y          ; SAVE AS INTEGER VARIABLE LOW BYTE     INY                    ; INCREMENT INDEX     LDA     XX65          ; GET FAC1 MANTISSA 4     STA     (XX49),Y          ; SAVE AS INTEGER VARIABLE HIGH BYTE     RTSXXC9D6 = *     JMP     XXDBD0          ; PACK FAC1 INTO VARIABLE POINTER AND RETURN; ASSIGN VALUE TO STRING VARIABLEXXC9D9 = *     PLA                    ; DUMP INTEGER/FLOAT DATA TYPE FLAGXXC9DA = *     LDY     XX4A          ; GET VARIABLE POINTER HIGH BYTE     CPY     #>XXDF13          ; WAS IT TI$ POINTER     BNE     XXCA2C          ; BRANCH IF NOT                         ; ELSE IT'S TI$ = <EXPR$>     JSR     XXD6A6          ; POP STRING OFF DESCRIPTOR STACK, OR FROM TOP OF STRING                         ; SPACE RETURNS WITH A = LENGTH, X = POINTER LOW BYTE,                         ; Y = POINTER HIGH BYTE     CMP     #$06               ; COMPARE LENGTH WITH 6     BNE     XXCA24          ; IF LENGTH NOT 6 DO ILLEGAL QUANTITY ERROR THEN WARM START     LDY     #$00               ; CLEAR INDEX     STY     XX61          ; CLEAR FAC1 EXPONENT     STY     XX66          ; CLEAR FAC1 SIGN (B7)XXC9ED = *     STY     XX71          ; SAVE INDEX     JSR     XXCA1D          ; CHECK AND EVALUATE NUMERIC DIGIT     JSR     XXDAE2          ; MULTIPLY FAC1 BY 10     INC     XX71          ; INCREMENT INDEX     LDY     XX71          ; RESTORE INDEX     JSR     XXCA1D          ; CHECK AND EVALUATE NUMERIC DIGIT     JSR     XXDC0C          ; ROUND AND COPY FAC1 TO FAC2     TAX                    ; COPY FAC1 EXPONENT     BEQ     XXCA07          ; BRANCH IF FAC1 ZERO     INX                    ; INCREMENT INDEX, * 2     TXA                    ; COPY BACK TO A     JSR     XXDAED          ; FAC1 = (FAC1 + (FAC2 * 2)) * 2 = FAC1 * 6XXCA07 = *     LDY     XX71          ; GET INDEX     INY                    ; INCREMENT INDEX     CPY     #$06               ; COMPARE INDEX WITH 6     BNE     XXC9ED          ; LOOP IF NOT 6     JSR     XXDAE2          ; MULTIPLY FAC1 BY 10     JSR     XXDC9B          ; CONVERT FAC1 FLOATING TO FIXED     LDX     XX64          ; GET FAC1 MANTISSA 3     LDY     XX63          ; GET FAC1 MANTISSA 2     LDA     XX65          ; GET FAC1 MANTISSA 4     JMP     XXFFDB          ; SET REAL TIME CLOCK AND RETURN; CHECK AND EVALUATE NUMERIC DIGITXXCA1D = *     LDA     (XX22),Y          ; GET BYTE FROM STRING     JSR     XX80          ; CLEAR CB IF NUMERIC. THIS CALL SHOULD BE TO XX84                         ; AS THE CODE FROM XX80 FIRST COMAPRES THE BYTE WITH                         ; [SPACE] AND DOES A BASIC INCREMENT AND GET IF IT IS     BCC     XXCA27          ; BRANCH IF NUMERICXXCA24 = *     JMP     XXD248          ; DO ILLEGAL QUANTITY ERROR THEN WARM STARTXXCA27 = *     SBC     #$2F               ; SUBTRACT $2F + CARRY TO CONVERT ASCII TO BINARY     JMP     XXDD7E          ; EVALUATE NEW ASCII DIGIT AND RETURN; ASSIGN VALUE TO STRING VARIABLE, BUT NOT TI$XXCA2C = *     LDY     #$02               ; INDEX TO STRING POINTER HIGH BYTE     LDA     (XX64),Y          ; GET STRING POINTER HIGH BYTE     CMP     XX34          ; COMPARE WITH BOTTOM OF STRING SPACE HIGH BYTE     BCC     XXCA4B          ; BRANCH IF STRING POINTER HIGH BYTE IS LESS THAN BOTTOM                         ; OF STRING SPACE HIGH BYTE     BNE     XXCA3D          ; BRANCH IF STRING POINTER HIGH BYTE IS GREATER THAN                         ; BOTTOM OF STRING SPACE HIGH BYTE                         ; ELSE HIGH BYTES WERE EQUAL     DEY                    ; DECREMENT INDEX TO STRING POINTER LOW BYTE     LDA     (XX64),Y          ; GET STRING POINTER LOW BYTE     CMP     XX33          ; COMPARE WITH BOTTOM OF STRING SPACE LOW BYTE     BCC     XXCA4B          ; BRANCH IF STRING POINTER LOW BYTE IS LESS THAN BOTTOM                         ; OF STRING SPACE LOW BYTEXXCA3D = *     LDY     XX65          ; GET DESCRIPTOR POINTER HIGH BYTE     CPY     XX2E          ; COMPARE WITH START OF VARIABLES HIGH BYTE     BCC     XXCA4B          ; BRANCH IF LESS, IS ON STRING STACK     BNE     XXCA52          ; IF GREATER MAKE SPACE AND COPY STRING                         ; ELSE HIGH BYTES WERE EQUAL     LDA     XX64          ; GET DESCRIPTOR POINTER LOW BYTE     CMP     XX2D          ; COMPARE WITH START OF VARIABLES LOW BYTE     BCS     XXCA52          ; IF GREATER OR EQUAL MAKE SPACE AND COPY STRINGXXCA4B = *     LDA     XX64          ; GET DESCRIPTOR POINTER LOW BYTE     LDY     XX65          ; GET DESCRIPTOR POINTER HIGH BYTE     JMP     XXCA68          ; GO COPY DESCRIPTOR TO VARIABLEXXCA52 = *     LDY     #$00               ; CLEAR INDEX     LDA     (XX64),Y          ; GET STRING LENGTH     JSR     XXD475          ; COPY DESCRIPTOR POINTER AND MAKE STRING SPACE A BYTES LONG     LDA     XX50          ; COPY OLD DESCRIPTOR POINTER LOW BYTE     LDY     XX51          ; COPY OLD DESCRIPTOR POINTER HIGH BYTE     STA     XX6F          ; SAVE OLD DESCRIPTOR POINTER LOW BYTE     STY     XX70          ; SAVE OLD DESCRIPTOR POINTER HIGH BYTE     JSR     XXD67A          ; COPY STRING FROM DESCRIPTOR TO UTILITY POINTER     LDA     #<XX61          ; GET DESCRIPTOR POINTER LOW BYTE     LDY     #>XX61          ; GET DESCRIPTOR POINTER HIGH BYTEXXCA68 = *     STA     XX50          ; SAVE DESCRIPTOR POINTER LOW BYTE     STY     XX51          ; SAVE DESCRIPTOR POINTER HIGH BYTE     JSR     XXD6DB          ; CLEAN DESCRIPTOR STACK, YA = POINTER     LDY     #$00               ; CLEAR INDEX     LDA     (XX50),Y          ; GET STRING LENGTH FROM NEW DESCRIPTOR     STA     (XX49),Y          ; COPY STRING LENGTH TO VARIABLE     INY                    ; INCREMENT INDEX     LDA     (XX50),Y          ; GET STRING POINTER LOW BYTE FROM NEW DESCRIPTOR     STA     (XX49),Y          ; COPY STRING POINTER LOW BYTE TO VARIABLE     INY                    ; INCREMENT INDEX     LDA     (XX50),Y          ; GET STRING POINTER HIGH BYTE FROM NEW DESCRIPTOR     STA     (XX49),Y          ; COPY STRING POINTER HIGH BYTE TO VARIABLE     RTS;***********************************************************************************;;; PERFORM PRINT#XXCA80 = *     JSR     XXCA86          ; PERFORM CMD     JMP     XXCBB5          ; CLOSE INPUT AND OUTPUT CHANNELS AND RETURN;***********************************************************************************;;; PERFORM CMDXXCA86 = *     JSR     XXD79E          ; GET BYTE PARAMETER     BEQ     XXCA90          ; BRANCH IF FOLLOWING BYTE IS ':' OR [EOT]     LDA     #','               ; SET ','     JSR     XXCEFF          ; SCAN FOR CHR$(A), ELSE DO SYNTAX ERROR THEN WARM STARTXXCA90 = *     PHP                    ; SAVE STATUS     STX     XX13          ; SET CURRENT I/O CHANNEL     JSR     XXE115          ; OPEN CHANNEL FOR OUTPUT WITH ERROR CHECK     PLP                    ; RESTORE STATUS     JMP     XXCAA0          ; PERFORM PRINT;***********************************************************************************;;; PRINT STRING, SCAN MEMORY AND CONTINUE PRINTXXCA9A = *     JSR     XXCB21          ; PRINT STRING FROM UTILITY POINTER; SCAN MEMORY AND CONTINUE PRINTXXCA9D = *     JSR     XX0079          ; SCAN MEMORY;***********************************************************************************;;; PERFORM PRINTXXCAA0 = *     BEQ     XXCAD7          ; IF NOTHING FOLLOWING JUST PRINT CR/LFXXCAA2 = *     BEQ     XXCAE7          ; IF NOTHING FOLLOWING EXIT, END OF PRINT BRANCH     CMP     #TTAB          ; COMPARE WITH TOKEN FOR TAB(     BEQ     XXCAF8          ; IF TAB( GO HANDLE IT     CMP     #TSPC          ; COMPARE WITH TOKEN FOR SPC(     CLC                    ; FLAG SPC(     BEQ     XXCAF8          ; IF SPC( GO HANDLE IT     CMP     #','               ; COMPARE WITH ','     BEQ     XXCAE8          ; IF ',' GO SKIP TO THE NEXT TAB POSITION     CMP     #$3B               ; COMPARE WITH ';'     BEQ     XXCB13          ; IF ';' GO CONTINUE THE PRINT LOOP     JSR     XXCD9E          ; EVALUATE EXPRESSION     BIT     XX0D          ; TEST DATA TYPE FLAG, $FF = STRING, $00 = NUMERIC     BMI     XXCA9A          ; IF STRING GO PRINT STRING, SCAN MEMORY AND CONTINUE PRINT     JSR     XXDDDD          ; CONVERT FAC1 TO ASCII STRING RESULT IN (AY)     JSR     XXD487          ; PRINT ' TERMINATED STRING TO UTILITY POINTER     JSR     XXCB21          ; PRINT STRING FROM UTILITY POINTER     JSR     XXCB3B          ; PRINT [SPACE] OR [CURSOR RIGHT]     BNE     XXCA9D          ; GO SCAN MEMORY AND CONTINUE PRINT, BRANCH ALWAYS;***********************************************************************************;;; SET XY TO XX0200 - 1 AND PRINT [CR]XXCACA = *     LDA     #$00               ; CLEAR A     STA     XX0200,X          ; CLEAR FIRST BYTE OF INPUT BUFFER     LDX     #<XX01FF          ; XX0200 - 1 LOW BYTE     LDY     #>XX01FF          ; XX0200 - 1 HIGH BYTE     LDA     XX13          ; GET CURRENT I/O CHANNEL     BNE     XXCAE7          ; EXIT IF NOT DEFAULT CHANNEL;***********************************************************************************;;; PRINT CR/LFXXCAD7 = *     LDA     #$0D               ; SET [CR]     JSR     XXCB47          ; PRINT THE CHARACTER     BIT     XX13          ; TEST CURRENT I/O CHANNEL     BPL     XXCAE5          ; IF THE AUTOLF BIT IS NOT SET SKIP THE LF; IT WOULD SEEM FROM OTHER PARTS OF THE CODE THAT USING B7 AS AN AUTOLF FLAG BIT IS; NO LONGER SUPPORTED AND SETTING THIS BIT WOULD BREAK THINGS IN A LOT OF PLACES     LDA     #$0A               ; SET [LF]     JSR     XXCB47          ; PRINT THE CHARACTER;***********************************************************************************;;; TOGGLE AXXCAE5 = *     EOR     #$FF               ; INVERT AXXCAE7 = *     RTS;***********************************************************************************;;; CONTINUING PRINT, THE CHARACTER WAS ','XXCAE8 = *     SEC                    ; SET CB FOR READ CURSOR POSITION     JSR     XXFFF0          ; READ/SET X,Y CURSOR POSITION     TYA                    ; COPY CURSOR Y     SEC                    ; SET CARRY FOR SUBTRACTXXCAEE = *     SBC     #$0B               ; SUBTRACT ONE TAB LENGTH     BCS     XXCAEE          ; LOOP IF RESULT WAS +VE     EOR     #$FF               ; COMPLEMENT IT     ADC     #$01               ; +1, TWOS COMPLEMENT     BNE     XXCB0E          ; PRINT A SPACES, BRANCH ALWAYS, RESULT IS NEVER $00;***********************************************************************************;;; HANDLE TAB( OR SPC(XXCAF8 = *     PHP                    ; SAVE TAB( OR SPC( STATUS     SEC                    ; SET CB FOR READ CURSOR POSITION     JSR     XXFFF0          ; READ/SET X,Y CURSOR POSITION     STY     XX09          ; SAVE CURRENT CURSOR POSITION     JSR     XXD79B          ; SCAN AND GET BYTE PARAMETER     CMP     #$29               ; COMPARE WITH ')'     BNE     XXCB5F          ; IF NOT ')' DO SYNTAX ERROR     PLP                    ; RESTORE TAB( OR SPC( STATUS     BCC     XXCB0F          ; BRANCH IF WAS SPC(                         ; ELSE WAS TAB(     TXA                    ; COPY TAB() BYTE TO A     SBC     XX09          ; SUBTRACT CURRENT CURSOR POSITION     BCC     XXCB13          ; GO LOOP FOR NEXT IF ALREADY PAST REQUITED POSITIONXXCB0E = *     TAX                    ; COPY [SPACE] COUNT TO XXXCB0F = *     INX                    ; INCREMENT COUNTXXCB10 = *     DEX                    ; DECREMENT COUNT     BNE     XXCB19          ; BRANCH IF COUNT WAS NOT ZERO                         ; WAS ';' OR [SPACES] PRINTEDXXCB13 = *     JSR     XX0073          ; INCREMENT AND SCAN MEMORY     JMP     XXCAA2          ; CONTINUE PRINT LOOPXXCB19 = *     JSR     XXCB3B          ; PRINT [SPACE] OR [CURSOR RIGHT]     BNE     XXCB10          ; LOOP, BRANCH ALWAYS;***********************************************************************************;;; PRINT NULL TERMINATED STRINGXXCB1E = *     JSR     XXD487          ; PRINT ' TERMINATED STRING TO UTILITY POINTER; PRINT STRING FROM UTILITY POINTERXXCB21 = *     JSR     XXD6A6          ; POP STRING OFF DESCRIPTOR STACK, OR FROM TOP OF STRING                         ; SPACE RETURNS WITH A = LENGTH, X = POINTER LOW BYTE,                         ; Y = POINTER HIGH BYTE     TAX                    ; COPY LENGTH     LDY     #$00               ; CLEAR INDEX     INX                    ; INCREMENT LENGTH, FOR PRE DECREMENT LOOPXXCB28 = *     DEX                    ; DECREMENT LENGTH     BEQ     XXCAE7          ; EXIT IF DONE     LDA     (XX22),Y          ; GET BYTE FROM STRING     JSR     XXCB47          ; PRINT THE CHARACTER     INY                    ; INCREMENT INDEX     CMP     #$0D               ; COMPARE BYTE WITH [CR]     BNE     XXCB28          ; LOOP IF NOT [CR]     JSR     XXCAE5          ; TOGGLE A, EOR #$FF. WHAT IS THE POINT OF THIS ??     JMP     XXCB28          ; LOOP;***********************************************************************************;;; PRINT [SPACE] OR [CURSOR RIGHT]XXCB3B = *     LDA     XX13          ; GET CURRENT I/O CHANNEL     BEQ     XXCB42          ; IF DEFAULT CHANNEL GO OUTPUT [CURSOR RIGHT]     LDA     #' '               ; ELSE OUTPUT [SPACE]     .BYTE     $2C               ; MAKES NEXT LINE BIT XX1DA9XXCB42 = *     LDA     #$1D               ; SET [CURSOR RIGHT]     .BYTE     $2C               ; MAKES NEXT LINE BIT XX3FA9;***********************************************************************************;;; PRINT '?'XXCB45 = *     LDA     #'?'               ; SET '?';***********************************************************************************;;; PRINT A CHARACTERXXCB47 = *     JSR     XXE109          ; OUTPUT CHARACTER TO CHANNEL WITH ERROR CHECK     AND     #$FF               ; SET THE FLAGS ON A     RTS;***********************************************************************************;;; BAD INPUT ROUTINEXXCB4D = *     LDA     XX11          ; GET INPUT MODE FLAG, $00 = INPUT, $40 = GET, $98 = READ     BEQ     XXCB62          ; BRANCH IF INPUT     BMI     XXCB57          ; BRANCH IF READ                         ; ELSE WAS GET     LDY     #$FF               ; SET CURRENT LINE HIGH BYTE TO -1, INDICATE IMMEDIATE MODE     BNE     XXCB5B          ; BRANCH ALWAYSXXCB57 = *     LDA     XX3F          ; GET CURRENT DATA LINE NUMBER LOW BYTE     LDY     XX40          ; GET CURRENT DATA LINE NUMBER HIGH BYTEXXCB5B = *     STA     XX39          ; SET CURRENT LINE NUMBER LOW BYTE     STY     XX3A          ; SET CURRENT LINE NUMBER HIGH BYTEXXCB5F = *     JMP     XXCF08          ; DO SYNTAX ERROR THEN WARM START                         ; WAS INPUTXXCB62 = *     LDA     XX13          ; GET CURRENT I/O CHANNEL     BEQ     XXCB6B          ; IF DEFAULT CHANNEL GO DO '?REDO FROM START' MESSAGE     LDX     #$18               ; ELSE ERROR $18, FILE DATA ERROR     JMP     XXC437          ; DO ERROR #X THEN WARM STARTXXCB6B = *     LDA     #<XXCD0C          ; SET '?REDO FROM START' POINTER LOW BYTE     LDY     #>XXCD0C          ; SET '?REDO FROM START' POINTER HIGH BYTE     JSR     XXCB1E          ; PRINT NULL TERMINATED STRING     LDA     XX3D          ; GET CONTINUE POINTER LOW BYTE     LDY     XX3E          ; GET CONTINUE POINTER HIGH BYTE     STA     XX7A          ; SAVE BASIC EXECUTE POINTER LOW BYTE     STY     XX7B          ; SAVE BASIC EXECUTE POINTER HIGH BYTE     RTS;***********************************************************************************;;; PERFORM GETXXCB7B = *     JSR     XXD3A6          ; CHECK NOT DIRECT, BACK HERE IF OK     CMP     #'#'               ; COMPARE WITH '#'     BNE     XXCB92          ; BRANCH IF NOT GET#     JSR     XX0073          ; INCREMENT AND SCAN MEMORY     JSR     XXD79E          ; GET BYTE PARAMETER     LDA     #','               ; SET ','     JSR     XXCEFF          ; SCAN FOR CHR$(A), ELSE DO SYNTAX ERROR THEN WARM START     STX     XX13          ; SET CURRENT I/O CHANNEL     JSR     XXE11B          ; OPEN CHANNEL FOR INPUT WITH ERROR CHECKXXCB92 = *     LDX     #<XX0201          ; SET XX0200+1 POINTER LOW BYTE     LDY     #>XX0201          ; SET XX0200+1 POINTER HIGH BYTE     LDA     #$00               ; CLEAR A     STA     XX0200+1          ; ENSURE NULL TERMINATOR     LDA     #$40               ; INPUT MODE = GET     JSR     XXCC0F          ; PERFORM GET PART OF READ     LDX     XX13          ; GET CURRENT I/O CHANNEL     BNE     XXCBB7          ; IF NOT DEFAULT CHANNEL GO DO CHANNEL CLOSE AND RETURN     RTS;***********************************************************************************;;; PERFORM INPUT#XXCBA5 = *     JSR     XXD79E          ; GET BYTE PARAMETER     LDA     #','               ; SET ','     JSR     XXCEFF          ; SCAN FOR CHR$(A), ELSE DO SYNTAX ERROR THEN WARM START     STX     XX13          ; SET CURRENT I/O CHANNEL     JSR     XXE11B          ; OPEN CHANNEL FOR INPUT WITH ERROR CHECK     JSR     XXCBCE          ; PERFORM INPUT WITH NO PROMPT STRING; CLOSE INPUT AND OUTPUT CHANNELSXXCBB5 = *     LDA     XX13          ; GET CURRENT I/O CHANNELXXCBB7 = *     JSR     XXFFCC          ; CLOSE INPUT AND OUTPUT CHANNELS     LDX     #$00               ; CLEAR X     STX     XX13          ; CLEAR CURRENT I/O CHANNEL, FLAG DEFAULT     RTS;***********************************************************************************;;; PERFORM INPUTXXCBBF = *     CMP     #$22               ; COMPARE NEXT BYTE WITH OPEN QUOTE     BNE     XXCBCE          ; IF NO PROMPT STRING JUST DO INPUT     JSR     XXCEBD          ; PRINT '...' STRING     LDA     #$3B               ; LOAD A WITH ';'     JSR     XXCEFF          ; SCAN FOR CHR$(A), ELSE DO SYNTAX ERROR THEN WARM START     JSR     XXCB21          ; PRINT STRING FROM UTILITY POINTER                         ; DONE WITH PROMPT, NOW GET DATAXXCBCE = *     JSR     XXD3A6          ; CHECK NOT DIRECT, BACK HERE IF OK     LDA     #','               ; SET ','     STA     XX0200-1          ; SAVE TO START OF BUFFER - 1XXCBD6 = *     JSR     XXCBF9          ; PRINT '? ' AND GET BASIC INPUT     LDA     XX13          ; GET CURRENT I/O CHANNEL     BEQ     XXCBEA          ; BRANCH IF DEFAULT I/O CHANNEL     JSR     XXFFB7          ; READ I/O STATUS WORD     AND     #$02               ; MASK NO DSR/TIMEOUT     BEQ     XXCBEA          ; BRANCH IF NOT ERROR     JSR     XXCBB5          ; CLOSE INPUT AND OUTPUT CHANNELS     JMP     XXC8F8          ; PERFORM DATAXXCBEA = *     LDA     XX0200          ; GET FIRST BYTE IN INPUT BUFFER     BNE     XXCC0D          ; BRANCH IF NOT NULL                         ; ELSE ..     LDA     XX13          ; GET CURRENT I/O CHANNEL     BNE     XXCBD6          ; IF NOT DEFAULT CHANNEL GO GET BASIC INPUT     JSR     XXC906          ; SCAN FOR NEXT BASIC STATEMENT ([:] OR [EOL])     JMP     XXC8FB          ; ADD Y TO THE BASIC EXECUTE POINTER AND RETURN;***********************************************************************************;;; PRINT '? ' AND GET BASIC INPUTXXCBF9 = *     LDA     XX13          ; GET CURRENT I/O CHANNEL     BNE     XXCC03          ; SKIP '?' PROMPT IF NOT DEFAULT CHANNEL     JSR     XXCB45          ; PRINT '?'     JSR     XXCB3B          ; PRINT [SPACE] OR [CURSOR RIGHT]XXCC03 = *     JMP     XXC560          ; CALL FOR BASIC INPUT AND RETURN;***********************************************************************************;;; PERFORM READXXCC06 = *     LDX     XX41          ; GET DATA POINTER LOW BYTE     LDY     XX42          ; GET DATA POINTER HIGH BYTE     LDA     #$98               ; SET INPUT MODE = READ     .BYTE     $2C               ; MAKES NEXT LINE BIT XX00A9XXCC0D = *     LDA     #$00               ; SET INPUT MODE = INPUT;***********************************************************************************;;; PERFORM GETXXCC0F = *     STA     XX11          ; SET INPUT MODE FLAG, $00 = INPUT, $40 = GET, $98 = READ     STX     XX43          ; SAVE READ POINTER LOW BYTE     STY     XX44          ; SAVE READ POINTER HIGH BYTE                         ; READ, GET OR INPUT NEXT VARIABLE FROM LISTXXCC15 = *     JSR     XXD08B          ; GET VARIABLE ADDRESS     STA     XX49          ; SAVE ADDRESS LOW BYTE     STY     XX4A          ; SAVE ADDRESS HIGH BYTE     LDA     XX7A          ; GET BASIC EXECUTE POINTER LOW BYTE     LDY     XX7B          ; GET BASIC EXECUTE POINTER HIGH BYTE     STA     XX4B          ; SAVE BASIC EXECUTE POINTER LOW BYTE     STY     XX4C          ; SAVE BASIC EXECUTE POINTER HIGH BYTE     LDX     XX43          ; GET READ POINTER LOW BYTE     LDY     XX44          ; GET READ POINTER HIGH BYTE     STX     XX7A          ; SAVE AS BASIC EXECUTE POINTER LOW BYTE     STY     XX7B          ; SAVE AS BASIC EXECUTE POINTER HIGH BYTE     JSR     XX0079          ; SCAN MEMORY     BNE     XXCC51          ; BRANCH IF NOT NULL                         ; POINTER WAS TO NULL ENTRY     BIT     XX11          ; TEST INPUT MODE FLAG, $00 = INPUT, $40 = GET, $98 = READ     BVC     XXCC41          ; BRANCH IF NOT GET                         ; ELSE WAS GET     JSR     XXE121          ; GET CHARACTER FROM INPUT DEVICE WITH ERROR CHECK     STA     XX0200          ; SAVE TO BUFFER     LDX     #<XX01FF          ; SET XX0200-1 POINTER LOW BYTE     LDY     #>XX01FF          ; SET XX0200-1 POINTER HIGH BYTE     BNE     XXCC4D          ; GO INTERPRET SINGLE CHARACTERXXCC41 = *     BMI     XXCCB8          ; IF READ GO GET SOME DATA; ELSE IT WAS INPUT     LDA     XX13          ; GET CURRENT I/O CHANNEL     BNE     XXCC4A          ; SKIP '?' PROMPT IF NOT DEFAULT CHANNEL     JSR     XXCB45          ; PRINT '?'XXCC4A = *     JSR     XXCBF9          ; PRINT '? ' AND GET BASIC INPUTXXCC4D = *     STX     XX7A          ; SAVE BASIC EXECUTE POINTER LOW BYTE     STY     XX7B          ; SAVE BASIC EXECUTE POINTER HIGH BYTEXXCC51 = *     JSR     XX0073          ; INCREMENT AND SCAN MEMORY, EXECUTE POINTER NOW POINTS TO                         ; START OF NEXT DATA OR NULL TERMINATOR     BIT     XX0D          ; TEST DATA TYPE FLAG, $FF = STRING, $00 = NUMERIC     BPL     XXCC89          ; BRANCH IF NUMERIC                         ; TYPE IS STRING     BIT     XX11          ; TEST INPUT MODE FLAG, $00 = INPUT, $40 = GET, $98 = READ     BVC     XXCC65          ; BRANCH IF NOT GET                         ; ELSE DO STRING GET     INX                    ; CLEAR X ??     STX     XX7A          ; SAVE BASIC EXECUTE POINTER LOW BYTE     LDA     #$00               ; CLEAR A     STA     XX07          ; CLEAR SEARCH CHARACTER     BEQ     XXCC71          ; BRANCH ALWAYS                         ; IS STRING INPUT OR STRING READXXCC65 = *     STA     XX07          ; SAVE SEARCH CHARACTER     CMP     #$22               ; COMPARE WITH '     BEQ     XXCC72          ; IF QUOTE ONLY SEARCH FOR '...' STRING                         ; ELSE THE STRING IS NOT IN QUOTES SO ':', ',' OR $00 ARE                         ; THE TERMINATION CHARACTERS     LDA     #':'               ; SET ':'     STA     XX07          ; SET SEARCH CHARACTER     LDA     #','               ; SET ','XXCC71 = *     CLC                    ; CLEAR CARRY FOR ADDXXCC72 = *     STA     XX08          ; SET SCAN QUOTES FLAG     LDA     XX7A          ; GET BASIC EXECUTE POINTER LOW BYTE     LDY     XX7B          ; GET BASIC EXECUTE POINTER HIGH BYTE     ADC     #$00               ; ADD TO POINTER LOW BYTE. THIS ADD INCREMENTS THE POINTER                         ; IF THE MODE IS INPUT OR READ AND THE DATA IS A '...'                         ; STRING     BCC     XXCC7D          ; IF NO ROLLOVER SKIP THE HIGH BYTE INCREMENT     INY                    ; ELSE INCREMENT POINTER HIGH BYTEXXCC7D = *     JSR     XXD48D          ; PRINT STRING TO UTILITY POINTER     JSR     XXD7E2          ; RESTORE BASIC EXECUTE POINTER FROM TEMP     JSR     XXC9DA          ; PERFORM STRING LET     JMP     XXCC91          ; CONTINUE PROCESSING COMMAND                         ; GET, INPUT OR READ IS NUMERICXXCC89 = *     JSR     XXDCF3          ; GET FAC1 FROM STRING     LDA     XX0E          ; GET DATA TYPE FLAG, $80 = INTEGER, $00 = FLOAT     JSR     XXC9C2          ; ASSIGN VALUE TO NUMERIC VARIABLEXXCC91 = *     JSR     XX0079          ; SCAN MEMORY     BEQ     XXCC9D          ; IF ':' OR [EOL] GO HANDLE THE STRING END     CMP     #','               ; COMPARTE WITH ','     BEQ     XXCC9D          ; IF ',' GO HANDLE THE STRING END     JMP     XXCB4D          ; ELSE GO DO BAD INPUT ROUTINE                         ; STRING TERMINATED WITH ':', ',' OR $00XXCC9D = *     LDA     XX7A          ; GET BASIC EXECUTE POINTER LOW BYTE     LDY     XX7B          ; GET BASIC EXECUTE POINTER HIGH BYTE     STA     XX43          ; SAVE READ POINTER LOW BYTE     STY     XX44          ; SAVE READ POINTER HIGH BYTE     LDA     XX4B          ; GET SAVED BASIC EXECUTE POINTER LOW BYTE     LDY     XX4C          ; GET SAVED BASIC EXECUTE POINTER HIGH BYTE     STA     XX7A          ; RESTORE BASIC EXECUTE POINTER LOW BYTE     STY     XX7B          ; RESTORE BASIC EXECUTE POINTER HIGH BYTE     JSR     XX0079          ; SCAN MEMORY     BEQ     XXCCDF          ; BRANCH IF ':' OR [EOL]     JSR     XXCEFD          ; SCAN FOR ',', ELSE DO SYNTAX ERROR THEN WARM START     JMP     XXCC15          ; GO READ OR INPUT NEXT VARIABLE FROM LIST                         ; WAS READXXCCB8 = *     JSR     XXC906          ; SCAN FOR NEXT BASIC STATEMENT ([:] OR [EOL])     INY                    ; INCREMENT INDEX TO NEXT BYTE     TAX                    ; COPY BYTE TO X     BNE     XXCCD1          ; IF ':' GO LOOK FOR THE NEXT DATA     LDX     #$0D               ; ELSE SET ERROR $0D, OUT OF DATA ERROR     INY                    ; INCREMENT INDEX TO NEXT LINE POINTER HIGH BYTE     LDA     (XX7A),Y          ; GET NEXT LINE POINTER HIGH BYTE     BEQ     XXCD32          ; IF PROGRAM END GO DO ERROR, EVENTUALLY DOES ERROR X     INY                    ; INCREMENT INDEX     LDA     (XX7A),Y          ; GET NEXT LINE # LOW BYTE     STA     XX3F          ; SAVE CURRENT DATA LINE LOW BYTE     INY                    ; INCREMENT INDEX     LDA     (XX7A),Y          ; GET NEXT LINE # HIGH BYTE     INY                    ; INCREMENT INDEX     STA     XX40          ; SAVE CURRENT DATA LINE HIGH BYTEXXCCD1 = *     JSR     XXC8FB          ; ADD Y TO THE BASIC EXECUTE POINTER     JSR     XX0079          ; SCAN MEMORY     TAX                    ; COPY BYTE     CPX     #TDATA          ; COMPARE WITH TOKEN FOR DATA     BNE     XXCCB8          ; LOOP IF NOT DATA     JMP     XXCC51          ; CONTINUE EVALUATING READXXCCDF = *     LDA     XX43          ; GET READ POINTER LOW BYTE     LDY     XX44          ; GET READ POINTER HIGH BYTE     LDX     XX11          ; GET INPUT MODE FLAG, $00 = INPUT, $40 = GET, $98 = READ     BPL     XXCCEA          ; IF INPUT OR GET GO EXIT OR IGNORE EXTRA INPUT     JMP     XXC827          ; ELSE SET DATA POINTER AND EXITXXCCEA = *     LDY     #$00               ; CLEAR INDEX     LDA     (XX43),Y          ; GET READ BYTE     BEQ     XXCCFB          ; EXIT IF [EOL]     LDA     XX13          ; GET CURRENT I/O CHANNEL     BNE     XXCCFB          ; EXIT IF NOT DEFAULT CHANNEL     LDA     #<XXCCFC          ; SET '?EXTRA IGNORED' POINTER LOW BYTE     LDY     #>XXCCFC          ; SET '?EXTRA IGNORED' POINTER HIGH BYTE     JMP     XXCB1E          ; PRINT NULL TERMINATED STRINGXXCCFB = *     RTS;***********************************************************************************;;; INPUT ERROR MESSAGESXXCCFC = *     .BYTE     '?EXTRA IGNORED',$0D,$00XXCD0C = *     .BYTE     '?REDO FROM START',$0D,$00;***********************************************************************************;;; PERFORM NEXTXXCD1E = *     BNE     XXCD24          ; IF NEXT VARIABLE GO FIND THE VARIABLE     LDY     #$00               ; ELSE CLEAR Y     BEQ     XXCD27          ; USE ANY VARIABLE, BRANCH ALWAYS; NEXT VARIABLEXXCD24 = *     JSR     XXD08B          ; GET VARIABLE ADDRESSXXCD27 = *     STA     XX49          ; SAVE FOR/NEXT VARIABLE POINTER LOW BYTE     STY     XX4A          ; SAVE FOR/NEXT VARIABLE POINTER HIGH BYTE                         ; (HIGH BYTE CLEARED IF NO VARIABLE DEFINED)     JSR     XXC38A          ; SEARCH THE STACK FOR FOR OR GOSUB ACTIVITY     BEQ     XXCD35          ; IF FOR FOUND CONTINUE     LDX     #$0A               ; ELSE SET ERROR $0A, NEXT WITHOUT FOR ERRORXXCD32 = *     JMP     XXC437          ; DO ERROR #X THEN WARM START; FOUND THIS FOR VARIABLEXXCD35 = *     TXS                    ; UPDATE STACK POINTER     TXA                    ; COPY STACK POINTER     CLC                    ; CLEAR CARRY FOR ADD     ADC     #$04               ; POINT TO STEP VALUE     PHA                    ; SAVE IT     ADC     #$06               ; POINT TO TO VALUE     STA     XX24          ; SAVE POINTER TO TO VARIABLE FOR COMPARE     PLA                    ; RESTORE POINTER TO STEP VALUE     LDY     #$01               ; POINT TO STACK PAGE     JSR     XXDBA2          ; UNPACK MEMORY (AY) INTO FAC1     TSX                    ; GET STACK POINTER BACK     LDA     XX0100+9,X     ; GET STEP SIGN     STA     XX66          ; SAVE FAC1 SIGN (B7)     LDA     XX49          ; GET FOR/NEXT VARIABLE POINTER LOW BYTE     LDY     XX4A          ; GET FOR/NEXT VARIABLE POINTER HIGH BYTE     JSR     XXD867          ; ADD FOR VARIABLE TO FAC1     JSR     XXDBD0          ; PACK FAC1 INTO FOR VARIABLE     LDY     #$01               ; POINT TO STACK PAGE     JSR     XXDC5D          ; COMPARE FAC1 WITH TO VALUE     TSX                    ; GET STACK POINTER BACK     SEC                    ; SET CARRY FOR SUBTRACT     SBC     XX0100+9,X     ; SUBTRACT STEP SIGN     BEQ     XXCD78          ; IF = LOOP COMPLETE, GO UNSTACK THE FOR                         ; LOOP BACK AND DO IT ALL AGAIN     LDA     XX0100+$0F,X     ; GET FOR LINE LOW BYTE     STA     XX39          ; SAVE CURRENT LINE NUMBER LOW BYTE     LDA     XX0100+$10,X     ; GET FOR LINE HIGH BYTE     STA     XX3A          ; SAVE CURRENT LINE NUMBER HIGH BYTE     LDA     XX0100+$12,X     ; GET BASIC EXECUTE POINTER LOW BYTE     STA     XX7A          ; SAVE BASIC EXECUTE POINTER LOW BYTE     LDA     XX0100+$11,X     ; GET BASIC EXECUTE POINTER HIGH BYTE     STA     XX7B          ; SAVE BASIC EXECUTE POINTER HIGH BYTEXXCD75 = *     JMP     XXC7AE          ; GO DO INTERPRETER INNER LOOP; NEXT LOOP COMLETEXXCD78 = *     TXA                    ; STACK COPY TO A     ADC     #$11               ; ADD $12, $11 + CARRY, TO DUMP FOR STRUCTURE     TAX                    ; COPY BACK TO INDEX     TXS                    ; COPY TO STACK POINTER     JSR     XX0079          ; SCAN MEMORY     CMP     #','               ; COMPARE WITH ','     BNE     XXCD75          ; IF NOT ',' GO DO INTERPRETER INNER LOOP                         ; WAS ',' SO ANOTHER NEXT VARIABLE TO DO     JSR     XX0073          ; INCREMENT AND SCAN MEMORY     JSR     XXCD24          ; DO NEXT VARIABLE;***********************************************************************************;;; EVALUATE EXPRESSION AND CHECK TYPE MISMATCHXXCD8A = *     JSR     XXCD9E          ; EVALUATE EXPRESSION; CHECK IF SOURCE AND DESTINATION ARE NUMERICXXCD8D = *     CLC     .BYTE     $24               ; MAKES NEXT LINE BIT XX38; CHECK IF SOURCE AND DESTINATION ARE STRINGXXCD8F = *     SEC                    ; DESTINATION IS STRING; TYPE MATCH CHECK, SET C FOR STRING, CLEAR C FOR NUMERICXXCD90 = *     BIT     XX0D          ; TEST DATA TYPE FLAG, $FF = STRING, $00 = NUMERIC     BMI     XXCD97          ; IF STRING GO CHECK STRING IS REQUIRED; TYPE FOUND IS NUMERIC, CHECK REQUIRED     BCS     XXCD99          ; IF STRING IS REQUIRED GO DO TYPE MISSMATCH ERRORXXCD96 = *     RTS; TYPE FOUND IS STRING, CHECK REQUIREDXXCD97 = *     BCS     XXCD96          ; EXIT IF STRING IS REQUIRED; DO TYPE MISSMATCH ERRORXXCD99 = *     LDX     #$16               ; ERROR CODE $16, TYPE MISSMATCH ERROR     JMP     XXC437          ; DO ERROR #X THEN WARM START;***********************************************************************************;;; EVALUATE EXPRESSIONXXCD9E = *     LDX     XX7A          ; GET BASIC EXECUTE POINTER LOW BYTE     BNE     XXCDA4          ; SKIP NEXT IF NOT ZERO     DEC     XX7B          ; ELSE DECREMENT BASIC EXECUTE POINTER HIGH BYTEXXCDA4 = *     DEC     XX7A          ; DECREMENT BASIC EXECUTE POINTER LOW BYTE     LDX     #$00               ; SET NULL PRECEDENCE, FLAG DONE     .BYTE     $24               ; MAKES NEXT LINE BIT XX48XXCDA9 = *     PHA                    ; PUSH COMPARE EVALUATION BYTE IF BRANCH TO HERE     TXA                    ; COPY PRECEDENCE BYTE     PHA                    ; PUSH PRECEDENCE BYTE     LDA     #$01               ; 2 BYTES     JSR     XXC3FB          ; CHECK ROOM ON STACK FOR A*2 BYTES     JSR     XXCE83          ; GET VALUE FROM LINE     LDA     #$00               ; CLEAR A     STA     XX4D          ; CLEAR COMPARRISON EVALUATION FLAGXXCDB8 = *     JSR     XX0079          ; SCAN MEMORYXXCDBB = *     SEC                    ; SET CARRY FOR SUBTRACT     SBC     #TGT          ; SUBTRACT TOKEN FOR '>'     BCC     XXCDD7          ; IF < '>' SKIP COMPARRISON TEST CHECK     CMP     #$03               ; COMPARE WITH '>' TO +3     BCS     XXCDD7          ; IF >= 3 SKIP COMPARRISON TEST CHECK                         ; WAS TOKEN FOR '>' '=' OR '<'     CMP     #$01               ; COMPARE WITH TOKEN FOR =     ROL A                  ; *2, B0 = CARRY (=1 IF TOKEN WAS = OR <)     EOR     #$01               ; TOGGLE B0     EOR     XX4D          ; EOR WITH COMPARRISON EVALUATION FLAG     CMP     XX4D          ; COMPARE WITH COMPARRISON EVALUATION FLAG     BCC     XXCE30          ; IF < SAVED FLAG DO SYNTAX ERROR THEN WARM START     STA     XX4D          ; SAVE NEW COMPARRISON EVALUATION FLAG     JSR     XX0073          ; INCREMENT AND SCAN MEMORY     JMP     XXCDBB          ; GO DO NEXT CHARACTERXXCDD7 = *     LDX     XX4D          ; GET COMPARRISON EVALUATION FLAG     BNE     XXCE07          ; IF COMPARE FUNCTION FLAGGED GO EVALUATE RIGHT HAND SIDE     BCS     XXCE58          ; GO DO FUNCTIONS                         ; ELSE WAS < TGT SO IS OPERATOR OR LOWER     ADC     #$07               ; ADD # OF OPERATORS (+, -, *, /, ^, AND OR OR)     BCC     XXCE58          ; IF < + OPERATOR GO DO THE FUNCTION                         ; CARRY WAS SET SO TOKEN WAS +, -, *, /, ^, AND OR OR     ADC     XX0D          ; ADD DATA TYPE FLAG, $FF = STRING, $00 = NUMERIC     BNE     XXCDE8          ; IF NOT STRING OR NOT + TOKEN SKIP CONCATENATE                         ; WILL ONLY BE $00 IF TYPE IS STRING AND TOKEN WAS +     JMP     XXD63D          ; ADD STRINGS, STRING 1 IS IN THE DESCRIPTOR, STRING 2                         ; IS IN LINE, AND RETURNXXCDE8 = *     ADC     #$FF               ; -1 (CORRECTS FOR CARRY ADD)     STA     XX22          ; SAVE IT     ASL A                  ; *2     ADC     XX22          ; *3     TAY                    ; COPY TO INDEXXXCDF0 = *     PLA                    ; PULL PREVIOUS PRECEDENCE     CMP     XXC080,Y          ; COMPARE WITH PRECEDENCE BYTE     BCS     XXCE5D          ; IF A >= GO DO THE FUNCTION     JSR     XXCD8D          ; CHECK IF SOURCE IS NUMERIC, ELSE DO TYPE MISMATCHXXCDF9 = *     PHA                    ; SAVE PRECEDENCEXXCDFA = *     JSR     XXCE20          ; GET VECTOR, EXECUTE FUNCTION THEN CONTINUE EVALUATION     PLA                    ; RESTORE PRECEDENCE     LDY     XX4B          ; GET PRECEDENCE STACKED FLAG     BPL     XXCE19          ; IF STACKED VALUES GO CHECK THE PRECEDENCE     TAX                    ; COPY PRECEDENCE, SET FLAGS     BEQ     XXCE5B          ; EXIT IF DONE     BNE     XXCE66          ; ELSE POP FAC2 AND RETURN, BRANCH ALWAYSXXCE07 = *     LSR     XX0D          ; CLEAR DATA TYPE FLAG, $FF = STRING, $00 = NUMERIC     TXA                    ; COPY COMPARE FUNCTION FLAG     ROL A                  ; <<1, SHIFT DATA TYPE FLAG INTO B0, 1 = STRING, 0 = NUM     LDX     XX7A          ; GET BASIC EXECUTE POINTER LOW BYTE     BNE     XXCE11          ; IF NO UNDERFLOW SKIP THE HIGH BYTE DECREMENT     DEC     XX7B          ; ELSE DECREMENT BASIC EXECUTE POINTER HIGH BYTEXXCE11 = *     DEC     XX7A          ; DECREMENT BASIC EXECUTE POINTER LOW BYTE     LDY     #XXC09B-XXC080                         ; SET OFFSET TO = OPERATOR PRECEDENCE ENTRY     STA     XX4D          ; SAVE NEW COMPARRISON EVALUATION FLAG     BNE     XXCDF0          ; BRANCH ALWAYSXXCE19 = *     CMP     XXC080,Y          ; COMPARE WITH STACKED FUNCTION PRECEDENCE     BCS     XXCE66          ; IF A >=, POP FAC2 AND RETURN     BCC     XXCDF9          ; ELSE GO STACK THIS ONE AND CONTINUE, BRANCH ALWAYS;***********************************************************************************;;; GET VECTOR, EXECUTE FUNCTION THEN CONTINUE EVALUATIONXXCE20 = *     LDA     XXC080+2,Y     ; GET FUNCTION VECTOR HIGH BYTE     PHA                    ; ONTO STACK     LDA     XXC080+1,Y     ; GET FUNCTION VECTOR LOW BYTE     PHA                    ; ONTO STACK                         ; NOW PUSH SIGN, ROUND FAC1 AND PUT ON STACK     JSR     XXCE33          ; FUNCTION WILL RETURN HERE, THEN THE NEXT RTS WILL CALL                         ; THE FUNCTION     LDA     XX4D          ; GET COMPARRISON EVALUATION FLAG     JMP     XXCDA9          ; CONTINUE EVALUATING EXPRESSIONXXCE30 = *     JMP     XXCF08          ; DO SYNTAX ERROR THEN WARM STARTXXCE33 = *     LDA     XX66          ; GET FAC1 SIGN (B7)     LDX     XXC080,Y          ; GET PRECEDENCE BYTE;***********************************************************************************;;; PUSH SIGN, ROUND FAC1 AND PUT ON STACKXXCE38 = *     TAY                    ; COPY SIGN     PLA                    ; GET RETURN ADDRESS LOW BYTE     STA     XX22          ; SAVE IT     INC     XX22          ; INCREMENT IT AS RETURN-1 IS PUSHED                         ; NOTE, NO CHECK IS MADE ON THE HIGH BYTE SO IF THE CALLING                         ; ROUTINE EVER ASSEMBLES TO A PAGE EDGE THEN THIS ALL GOES                         ; HORRIBLY WRONG!     PLA                    ; GET RETURN ADDRESS HIGH BYTE     STA     XX23          ; SAVE IT     TYA                    ; RESTORE SIGN     PHA                    ; PUSH SIGN;***********************************************************************************;;; ROUND FAC1 AND PUT ON STACKXXCE43 = *     JSR     XXDC1B          ; ROUND FAC1     LDA     XX65          ; GET FAC1 MANTISSA 4     PHA                    ; SAVE IT     LDA     XX64          ; GET FAC1 MANTISSA 3     PHA                    ; SAVE IT     LDA     XX63          ; GET FAC1 MANTISSA 2     PHA                    ; SAVE IT     LDA     XX62          ; GET FAC1 MANTISSA 1     PHA                    ; SAVE IT     LDA     XX61          ; GET FAC1 EXPONENT     PHA                    ; SAVE IT     JMP     (XX22)          ; RETURN, SORT OF;***********************************************************************************;;; DO FUNCTIONSXXCE58 = *     LDY     #$FF               ; FLAG FUNCTION     PLA                    ; PULL PRECEDENCE BYTEXXCE5B = *     BEQ     XXCE80          ; EXIT IF DONEXXCE5D = *     CMP     #$64               ; COMPARE PREVIOUS PRECEDENCE WITH $64     BEQ     XXCE64          ; IF WAS $64 (< FUNCTION) SKIP THE TYPE CHECK     JSR     XXCD8D          ; CHECK IF SOURCE IS NUMERIC, ELSE DO TYPE MISMATCHXXCE64 = *     STY     XX4B          ; SAVE PRECEDENCE STACKED FLAG                         ; POP FAC2 AND RETURNXXCE66 = *     PLA                    ; POP BYTE     LSR A                  ; SHIFT OUT COMPARISON EVALUATION LOWEST BIT     STA     XX12          ; SAVE THE COMPARISON EVALUATION FLAG     PLA                    ; POP EXPONENT     STA     XX69          ; SAVE FAC2 EXPONENT     PLA                    ; POP MANTISSA 1     STA     XX6A          ; SAVE FAC2 MANTISSA 1     PLA                    ; POP MANTISSA 2     STA     XX6B          ; SAVE FAC2 MANTISSA 2     PLA                    ; POP MANTISSA 3     STA     XX6C          ; SAVE FAC2 MANTISSA 3     PLA                    ; POP MANTISSA 4     STA     XX6D          ; SAVE FAC2 MANTISSA 4     PLA                    ; POP SIGN     STA     XX6E          ; SAVE FAC2 SIGN (B7)     EOR     XX66          ; EOR FAC1 SIGN (B7)     STA     XX6F          ; SAVE SIGN COMPARE (FAC1 EOR FAC2)XXCE80 = *     LDA     XX61          ; GET FAC1 EXPONENT     RTS;***********************************************************************************;;; GET VALUE FROM LINEXXCE83 = *     JMP     (XX030A)          ; GET ARITHMETIC ELEMENT;***********************************************************************************;;; GET ARITHMETIC ELEMENT, THE GET ARITHMETIC ELEMENT VECTOR IS INITIALISED TO POINT HEREXXCE86 = *     LDA     #$00               ; CLEAR BYTE     STA     XX0D          ; CLEAR DATA TYPE FLAG, $FF = STRING, $00 = NUMERICXXCE8A = *     JSR     XX0073          ; INCREMENT AND SCAN MEMORY     BCS     XXCE92          ; IF NOT NUMERIC CHARACTER CONTINUE; ELSE NUMERIC STRING FOUND (E.G. 123)XXCE8F = *     JMP     XXDCF3          ; GET FAC1 FROM STRING AND RETURN; GET VALUE FROM LINE .. CONTINUED, WASN'T A NUMBER SO ...XXCE92 = *     JSR     XXD113          ; CHECK BYTE, RETURN CB = 0 IF<'A' OR >'Z'     BCC     XXCE9A          ; IF NOT VARIABLE NAME CONTINUE     JMP     XXCF28          ; VARIABLE NAME SET-UP AND RETURN; GET VALUE FROM LINE .. CONTINUED, WASN'T A VARIABLE NAME SO ...XXCE9A = *     CMP     #TPI          ; COMPARE WITH TOKEN FOR PI     BNE     XXCEAD          ; IF NOT PI CONTINUE; ELSE RETURN PI IN FAC1     LDA     #<XXCEA8          ; GET PI POINTER LOW BYTE     LDY     #>XXCEA8          ; GET PI POINTER HIGH BYTE     JSR     XXDBA2          ; UNPACK MEMORY (AY) INTO FAC1     JMP     XX0073          ; INCREMENT AND SCAN MEMORY AND RETURN;***********************************************************************************;;; PI AS FLOATING NUMBERXXCEA8 = *     .BYTE     $82,$49,$0F,$DA,$A1                         ; 3.141592653;***********************************************************************************;;; GET VALUE FROM LINE .. CONTINUED, WASN'T PI SO ...XXCEAD = *     CMP     #'.'               ; COMPARE WITH '.'     BEQ     XXCE8F          ; IF SO GET FAC1 FROM STRING AND RETURN, E.G. WAS .123                         ; WASN'T .123 SO ...     CMP     #TMINUS          ; COMPARE WITH TOKEN FOR -     BEQ     XXCF0D          ; IF - TOKEN, DO SET-UP FOR FUNCTIONS                         ; WASN'T -123 SO ...     CMP     #TPLUS          ; COMPARE WITH TOKEN FOR +     BEQ     XXCE8A          ; IF + TOKEN IGNORE THE LEADING +, +1 = 1                         ; IT WASN'T ANY SORT OF NUMBER SO ...     CMP     #$22               ; COMPARE WITH '     BNE     XXCECC          ; IF NOT OPEN QUOTE CONTINUE                         ; WAS OPEN QUOTE SO GET THE ENCLOSED STRING; PRINT '...' STRING TO STRING UTILITY AREAXXCEBD = *     LDA     XX7A          ; GET BASIC EXECUTE POINTER LOW BYTE     LDY     XX7B          ; GET BASIC EXECUTE POINTER HIGH BYTE     ADC     #$00               ; ADD CARRY TO LOW BYTE     BCC     XXCEC6          ; BRANCH IF NO OVERFLOW     INY                    ; INCREMENT HIGH BYTEXXCEC6 = *     JSR     XXD487          ; PRINT ' TERMINATED STRING TO UTILITY POINTER     JMP     XXD7E2          ; RESTORE BASIC EXECUTE POINTER FROM TEMP AND RETURN; GET VALUE FROM LINE .. CONTINUED, WASN'T A STRING SO ...XXCECC = *     CMP     #TNOT          ; COMPARE WITH TOKEN FOR NOT     BNE     XXCEE3          ; IF NOT TOKEN FOR NOT CONTINUE; WAS NOT TOKEN     LDY     #$18               ; OFFSET TO NOT FUNCTION     BNE     XXCF0F          ; DO SET-UP FOR FUNCTION THEN EXECUTE, BRANCH ALWAYS; DO = COMPAREXXCED4 = *     JSR     XXD1BF          ; EVALUATE INTEGER EXPRESSION, NO SIGN CHECK     LDA     XX65          ; GET FAC1 MANTISSA 4     EOR     #$FF               ; INVERT IT     TAY                    ; COPY IT     LDA     XX64          ; GET FAC1 MANTISSA 3     EOR     #$FF               ; INVERT IT     JMP     XXD391          ; CONVERT FIXED INTEGER AY TO FLOAT FAC1 AND RETURN; GET VALUE FROM LINE .. CONTINUED, WASN'T NOT SO ...XXCEE3 = *     CMP     #TFN          ; COMPARE WITH TOKEN FOR FN     BNE     XXCEEA          ; IF NOT TOKEN FOR FN CONTINUE     JMP     XXD3F4          ; ELSE GO EVALUATE FNX; GET VALUE FROM LINE .. CONTINUED, WASN'T FN SO ...XXCEEA = *     CMP     #TSGN          ; COMPARE WITH TOKEN FOR SGN     BCC     XXCEF1          ; IF LESS THAN SGN TOKEN GO EVALUATE EXPRESSION IN ()                         ; ELSE WAS A FUNCTION TOKEN     JMP     XXCFA7          ; GO SET UP FUNCTION REFERENCES, BRANCH ALWAYS;***********************************************************************************;;; GET VALUE FROM LINE .. CONTINUED; IF HERE IT CAN ONLY BE SOMETHING IN BRACKETS SO ....; EVALUATE EXPRESSION WITHIN PARENTHESESXXCEF1 = *     JSR     XXCEFA          ; SCAN FOR '(', ELSE DO SYNTAX ERROR THEN WARM START     JSR     XXCD9E          ; EVALUATE EXPRESSION;***********************************************************************************;;; ALL THE 'SCAN FOR' ROUTINES RETURN THE CHARACTER AFTER THE SOUGHT CHARACTER; SCAN FOR ')', ELSE DO SYNTAX ERROR THEN WARM STARTXXCEF7 = *     LDA     #$29               ; LOAD A WITH ')'     .BYTE     $2C               ; MAKES NEXT LINE BIT XX28A9; SCAN FOR '(', ELSE DO SYNTAX ERROR THEN WARM STARTXXCEFA = *     LDA     #$28               ; LOAD A WITH '('     .BYTE     $2C               ; MAKES NEXT LINE BIT XX2CA9; SCAN FOR ',', ELSE DO SYNTAX ERROR THEN WARM STARTXXCEFD = *     LDA     #','               ; LOAD A WITH ','; SCAN FOR CHR$(A), ELSE DO SYNTAX ERROR THEN WARM STARTXXCEFF = *     LDY     #$00               ; CLEAR INDEX     CMP     (XX7A),Y          ; COMPARE WITH BASIC BYTE     BNE     XXCF08          ; IF NOT EXPECTED BYTE DO SYNTAX ERROR THEN WARM START     JMP     XX0073          ; ELSE INCREMENT AND SCAN MEMORY AND RETURN;***********************************************************************************;;; SYNTAX ERROR THEN WARM STARTXXCF08 = *     LDX     #$0B               ; ERROR CODE $0B, SYNTAX ERROR     JMP     XXC437          ; DO ERROR #X THEN WARM STARTXXCF0D = *     LDY     #$15               ; SET OFFSET FROM BASE TO > OPERATORXXCF0F = *     PLA                    ; DUMP RETURN ADDRESS LOW BYTE     PLA                    ; DUMP RETURN ADDRESS HIGH BYTE     JMP     XXCDFA          ; EXECUTE FUNCTION THEN CONTINUE EVALUATION;***********************************************************************************;;; CHECK ADDRESS RANGE, RETURN CB = 1 IF ADDRESS IN BASIC ROMXXCF14 = *     SEC                    ; SET CARRY FOR SUBTRACT     LDA     XX64          ; GET VARIABLE ADDRESS LOW BYTE     SBC     #$00               ; SUBTRACT $C000 LOW BYTE     LDA     XX65          ; GET VARIABLE ADDRESS HIGH BYTE     SBC     #$C0               ; SUBTRACT $C000 HIGH BYTE     BCC     XXCF27          ; EXIT IF ADDRESS < $C000     LDA     #<XXE387          ; GET END OF BASIC MARKER LOW BYTE     SBC     XX64          ; SUBTRACT VARIABLE ADDRESS LOW BYTE     LDA     #>XXE387          ; GET END OF BASIC MARKER HIGH BYTE     SBC     XX65          ; SUBTRACT VARIABLE ADDRESS HIGH BYTEXXCF27 = *     RTS;***********************************************************************************;;; VARIABLE NAME SET-UPXXCF28 = *     JSR     XXD08B          ; GET VARIABLE ADDRESS     STA     XX64          ; SAVE VARIABLE POINTER LOW BYTE     STY     XX65          ; SAVE VARIABLE POINTER HIGH BYTE     LDX     XX45          ; GET CURRENT VARIABLE NAME FIRST CHARACTER     LDY     XX46          ; GET CURRENT VARIABLE NAME SECOND CHARACTER     LDA     XX0D          ; GET DATA TYPE FLAG, $FF = STRING, $00 = NUMERIC     BEQ     XXCF5D          ; IF NUMERIC GO HANDLE A NUMERIC VARIABLE; VARIABLE IS STRING     LDA     #$00               ; ELSE CLEAR A     STA     XX70          ; CLEAR FAC1 ROUNDING BYTE     JSR     XXCF14          ; CHECK ADDRESS RANGE     BCC     XXCF5C          ; EXIT IF NOT IN BASIC ROM     CPX     #'T'               ; COMPARE VARIABLE NAME FIRST CHARACTER WITH 'T'     BNE     XXCF5C          ; EXIT IF NOT 'T'     CPY     #$C9 ;#'I'+$80          ; COMPARE VARIABLE NAME SECOND CHARACTER WITH 'I$'     BNE     XXCF5C          ; EXIT IF NOT 'I$'                         ; VARIABLE NAME WAS 'TI$'     JSR     XXCF84          ; READ REAL TIME CLOCK INTO FAC1 MANTISSA, 0HML     STY     XX5E          ; CLEAR EXPONENT COUNT ADJUST     DEY                    ; Y = $FF     STY     XX71          ; SET OUTPUT STRING INDEX, -1 TO ALLOW FOR PRE INCREMENT     LDY     #$06               ; HH:MM:SS IS SIX DIGITS     STY     XX5D          ; SET NUMBER OF CHARACTERS BEFORE THE DECIMAL POINT     LDY     #XXDF3A-XXDF16                         ; INDEX TO JIFFY CONVERSION TABLE     JSR     XXDE68          ; CONVERT JIFFY COUNT TO STRING     JMP     XXD46F          ; EXIT VIA STR$() CODE TAILXXCF5C = *     RTS; VARIABLE NAME SET-UP, VARIABLE IS NUMERICXXCF5D = *     BIT     XX0E          ; TEST DATA TYPE FLAG, $80 = INTEGER, $00 = FLOAT     BPL     XXCF6E          ; IF FLOAT GO HANDLE FLOAT; ELSE HANDLE INTEGER VARIABLE     LDY     #$00               ; CLEAR INDEX     LDA     (XX64),Y          ; GET INTEGER VARIABLE LOW BYTE     TAX                    ; COPY TO X     INY                    ; INCREMENT INDEX     LDA     (XX64),Y          ; GET INTEGER VARIABLE HIGH BYTE     TAY                    ; COPY TO Y     TXA                    ; COPY LOA BYTE TO A     JMP     XXD391          ; CONVERT FIXED INTEGER AY TO FLOAT FAC1 AND RETURN; VARIABLE NAME SET-UP, VARIABLE IS FLOATXXCF6E = *     JSR     XXCF14          ; CHECK ADDRESS RANGE     BCC     XXCFA0          ; IF NOT IN BASIC ROM GET POINTER AND UNPACK INTO FAC1     CPX     #'T'               ; COMPARE VARIABLE NAME FIRST CHARACTER WITH 'T'     BNE     XXCF92          ; IF NOT 'T' SKIP TX VARIABLES     CPY     #'I'               ; COMPARE VARIABLE NAME SECOND CHARACTER WITH 'I'     BNE     XXCFA0          ; IF NOT 'I' GO DO PLAIN FLOAT                         ; VARIABLE NAME WAS 'TI'     JSR     XXCF84          ; READ REAL TIME CLOCK INTO FAC1 MANTISSA, 0HML     TYA                    ; CLEAR A     LDX     #$A0               ; SET EXPONENT TO 32 BIT VALUE     JMP     XXDC4F          ; SET EXPONENT = X AND NORMALISE FAC1;***********************************************************************************;;; READ REAL TIME CLOCK INTO FAC1 MANTISSA, 0HMLXXCF84 = *     JSR     XXFFDE          ; READ REAL TIME CLOCK     STX     XX64          ; SAVE JIFFY CLOCK MID BYTE AS  FAC1 MANTISSA 3     STY     XX63          ; SAVE JIFFY CLOCK HIGH BYTE AS  FAC1 MANTISSA 2     STA     XX65          ; SAVE JIFFY CLOCK LOW BYTE AS  FAC1 MANTISSA 4     LDY     #$00               ; CLEAR Y     STY     XX62          ; CLEAR FAC1 MANTISSA 1     RTS;***********************************************************************************;;; VARIABLE NAME SET-UP, VARIABLE IS FLOAT AND NOT 'TX'XXCF92 = *     CPX     #'S'               ; COMPARE VARIABLE NAME FIRST CHARACTER WITH 'S'     BNE     XXCFA0          ; IF NOT 'S' GO DO NORMAL FLOATING VARIABLE     CPY     #'T'               ; COMPARE VARIABLE NAME SECOND CHARACTER WITH '     BNE     XXCFA0          ; IF NOT 'T' GO DO NORMAL FLOATING VARIABLE                         ; VARIABLE NAME WAS 'ST'     JSR     XXFFB7          ; READ I/O STATUS WORD     JMP     XXDC3C          ; SAVE A AS INTEGER BYTE AND RETURN; VARIABLE IS PLAIN FLOATXXCFA0 = *     LDA     XX64          ; GET VARIABLE POINTER LOW BYTE     LDY     XX65          ; GET VARIABLE POINTER HIGH BYTE     JMP     XXDBA2          ; UNPACK MEMORY (AY) INTO FAC1;***********************************************************************************;;; GET VALUE FROM LINE CONTINUED; ONLY FUNCTIONS LEFT SO ..; SET UP FUNCTION REFERENCESXXCFA7 = *     ASL A                  ; *2 (2 BYTES PER FUNCTION ADDRESS)     PHA                    ; SAVE FUNCTION OFFSET     TAX                    ; COPY FUNCTION OFFSET     JSR     XX0073          ; INCREMENT AND SCAN MEMORY     CPX     #$8F               ; COMPARE FUNCTION OFFSET TO CHR$ TOKEN OFFSET+1     BCC     XXCFD1          ; IF < LEFT$ (CAN NOT BE =) GO DO FUNCTION SETUP; GET VALUE FROM LINE .. CONTINUED; WAS LEFT$, RIGHT$ OR MID$ SO..     JSR     XXCEFA          ; SCAN FOR '(', ELSE DO SYNTAX ERROR THEN WARM START     JSR     XXCD9E          ; EVALUATE, SHOULD BE STRING, EXPRESSION     JSR     XXCEFD          ; SCAN FOR ',', ELSE DO SYNTAX ERROR THEN WARM START     JSR     XXCD8F          ; CHECK IF SOURCE IS STRING, ELSE DO TYPE MISMATCH     PLA                    ; RESTORE FUNCTION OFFSET     TAX                    ; COPY IT     LDA     XX65          ; GET DESCRIPTOR POINTER HIGH BYTE     PHA                    ; PUSH STRING POINTER HIGH BYTE     LDA     XX64          ; GET DESCRIPTOR POINTER LOW BYTE     PHA                    ; PUSH STRING POINTER LOW BYTE     TXA                    ; RESTORE FUNCTION OFFSET     PHA                    ; SAVE FUNCTION OFFSET     JSR     XXD79E          ; GET BYTE PARAMETER     PLA                    ; RESTORE FUNCTION OFFSET     TAY                    ; COPY FUNCTION OFFSET     TXA                    ; COPY BYTE PARAMETER TO A     PHA                    ; PUSH BYTE PARAMETER     JMP     XXCFD6          ; GO CALL FUNCTION; GET VALUE FROM LINE .. CONTINUED; WAS SGN() TO CHR$() SO..XXCFD1 = *     JSR     XXCEF1          ; EVALUATE EXPRESSION WITHIN PARENTHESES     PLA                    ; RESTORE FUNCTION OFFSET     TAY                    ; COPY TO INDEXXXCFD6 = *     LDA     XXC052-$68,Y     ; GET FUNCTION JUMP VECTOR LOW BYTE     STA     XX55          ; SAVE FUNCTIONS JUMP VECTOR LOW BYTE     LDA     XXC052-$67,Y     ; GET FUNCTION JUMP VECTOR HIGH BYTE     STA     XX56          ; SAVE FUNCTIONS JUMP VECTOR HIGH BYTE     JSR     XX54          ; DO FUNCTION CALL     JMP     XXCD8D          ; CHECK IF SOURCE IS NUMERIC AND RTS, ELSE DO TYPE MISMATCH                         ; STRING FUNCTIONS AVOID THIS BY DUMPING THE RETURN ADDRESS;***********************************************************************************;;; PERFORM OR; THIS WORKS BECAUSE NOT(NOT(X) AND NOT(Y)) = X OR YXXCFE6 = *     LDY     #$FF               ; SET Y FOR OR     .BYTE     $2C               ; MAKES NEXT LINE BIT XX00A0;***********************************************************************************;;; PERFORM ANDXXCFE9 = *     LDY     #$00               ; CLEAR Y FOR AND     STY     XX0B          ; SET AND/OR INVERT VALUE     JSR     XXD1BF          ; EVALUATE INTEGER EXPRESSION, NO SIGN CHECK     LDA     XX64          ; GET FAC1 MANTISSA 3     EOR     XX0B          ; EOR LOW BYTE     STA     XX07          ; SAVE IT     LDA     XX65          ; GET FAC1 MANTISSA 4     EOR     XX0B          ; EOR HIGH BYTE     STA     XX08          ; SAVE IT     JSR     XXDBFC          ; COPY FAC2 TO FAC1, GET 2ND VALUE IN EXPRESSION     JSR     XXD1BF          ; EVALUATE INTEGER EXPRESSION, NO SIGN CHECK     LDA     XX65          ; GET FAC1 MANTISSA 4     EOR     XX0B          ; EOR HIGH BYTE     AND     XX08          ; AND WITH EXPRESSION 1 HIGH BYTE     EOR     XX0B          ; EOR RESULT HIGH BYTE     TAY                    ; SAVE IN Y     LDA     XX64          ; GET FAC1 MANTISSA 3     EOR     XX0B          ; EOR LOW BYTE     AND     XX07          ; AND WITH EXPRESSION 1 LOW BYTE     EOR     XX0B          ; EOR RESULT LOW BYTE     JMP     XXD391          ; CONVERT FIXED INTEGER AY TO FLOAT FAC1 AND RETURN;***********************************************************************************;;; PERFORM COMPARISONS; DO < COMPAREXXD016 = *     JSR     XXCD90          ; TYPE MATCH CHECK, SET C FOR STRING     BCS     XXD02E          ; IF STRING GO DO STRING COMPARE                         ; DO NUMERIC < COMPARE     LDA     XX6E          ; GET FAC2 SIGN (B7)     ORA     #$7F               ; SET ALL NON SIGN BITS     AND     XX6A          ; AND FAC2 MANTISSA 1 (AND IN SIGN BIT)     STA     XX6A          ; SAVE FAC2 MANTISSA 1     LDA     #<XX69          ; SET POINTER LOW BYTE TO FAC2     LDY     #>XX69          ; SET POINTER HIGH BYTE TO FAC2     JSR     XXDC5B          ; COMPARE FAC1 WITH (AY)     TAX                    ; COPY THE RESULT     JMP     XXD061          ; GO EVALUATE RESULT; DO STRING < COMPAREXXD02E = *     LDA     #$00               ; CLEAR BYTE     STA     XX0D          ; CLEAR DATA TYPE FLAG, $FF = STRING, $00 = NUMERIC     DEC     XX4D          ; CLEAR < BIT IN COMPARRISON EVALUATION FLAG     JSR     XXD6A6          ; POP STRING OFF DESCRIPTOR STACK, OR FROM TOP OF STRING                         ; SPACE RETURNS WITH A = LENGTH, X = POINTER LOW BYTE,                         ; Y = POINTER HIGH BYTE     STA     XX61          ; SAVE LENGTH     STX     XX62          ; SAVE STRING POINTER LOW BYTE     STY     XX63          ; SAVE STRING POINTER HIGH BYTE     LDA     XX6C          ; GET DESCRIPTOR POINTER LOW BYTE     LDY     XX6D          ; GET DESCRIPTOR POINTER HIGH BYTE     JSR     XXD6AA          ; POP (YA) DESCRIPTOR OFF STACK OR FROM TOP OF STRING SPACE                         ; RETURNS WITH A = LENGTH, X = POINTER LOW BYTE,                         ; Y = POINTER HIGH BYTE     STX     XX6C          ; SAVE STRING POINTER LOW BYTE     STY     XX6D          ; SAVE STRING POINTER HIGH BYTE     TAX                    ; COPY LENGTH     SEC                    ; SET CARRY FOR SUBTRACT     SBC     XX61          ; SUBTRACT STRING 1 LENGTH     BEQ     XXD056          ; IF STR 1 LENGTH = STRING 2 LENGTH GO COMPARE THE STRINGS     LDA     #$01               ; SET STR 1 LENGTH > STRING 2 LENGTH     BCC     XXD056          ; IF SO RETURN + 1 IF OTHERWISE EQUAL     LDX     XX61          ; GET STRING 1 LENGTH     LDA     #$FF               ; SET STR 1 LENGTH < STRING 2 LENGTHXXD056 = *     STA     XX66          ; SAVE LENGTH COMPARE     LDY     #$FF               ; SET INDEX     INX                    ; ADJUST FOR LOOPXXD05B = *     INY                    ; INCREMENT INDEX     DEX                    ; DECREMENT COUNT     BNE     XXD066          ; IF STILL BYTES TO DO GO COMPARE THEM     LDX     XX66          ; GET LENGTH COMPARE BACKXXD061 = *     BMI     XXD072          ; BRANCH IF STR 1 < STR 2     CLC                    ; FLAG STR 1 <= STR 2     BCC     XXD072          ; GO EVALUATE RESULT, BRANCH ALWAYSXXD066 = *     LDA     (XX6C),Y          ; GET STRING 2 BYTE     CMP     (XX62),Y          ; COMPARE WITH STRING 1 BYTE     BEQ     XXD05B          ; LOOP IF BYTES =     LDX     #$FF               ; SET STR 1 < STRING 2     BCS     XXD072          ; BRANCH IF SO     LDX     #$01               ; SET STR 1 > STRING 2XXD072 = *     INX                    ; X = 0, 1 OR 2     TXA                    ; COPY TO A     ROL A                  ; * 2 (1, 2 OR 4)     AND     XX12          ; AND WITH THE COMPARISON EVALUATION FLAG     BEQ     XXD07B          ; BRANCH IF 0 (COMPARE IS FALSE)     LDA     #$FF               ; ELSE SET RESULT TRUEXXD07B = *     JMP     XXDC3C          ; SAVE A AS INTEGER BYTE AND RETURNXXD07E = *     JSR     XXCEFD          ; SCAN FOR ',', ELSE DO SYNTAX ERROR THEN WARM START;***********************************************************************************;;; PERFORM DIMXXD081 = *     TAX                    ; COPY 'DIM' FLAG TO X     JSR     XXD090          ; SEARCH FOR VARIABLE     JSR     XX0079          ; SCAN MEMORY     BNE     XXD07E          ; SCAN FOR ',' AND LOOP IF NOT NULL     RTS;***********************************************************************************;;; SEARCH FOR VARIABLEXXD08B = *     LDX     #$00               ; SET DIM FLAG = $00     JSR     XX0079          ; SCAN MEMORY, 1ST CHARACTERXXD090 = *     STX     XX0C          ; SAVE DIM FLAGXXD092 = *     STA     XX45          ; SAVE 1ST CHARACTER     JSR     XX0079          ; SCAN MEMORY     JSR     XXD113          ; CHECK BYTE, RETURN CB = 0 IF<'A' OR >'Z'     BCS     XXD09F          ; IF OK CONTINUEXXD09C = *     JMP     XXCF08          ; ELSE SYNTAX ERROR THEN WARM START; WAS VARIABLE NAME SO ...XXD09F = *     LDX     #$00               ; CLEAR 2ND CHARACTER TEMP     STX     XX0D          ; CLEAR DATA TYPE FLAG, $FF = STRING, $00 = NUMERIC     STX     XX0E          ; CLEAR DATA TYPE FLAG, $80 = INTEGER, $00 = FLOAT     JSR     XX0073          ; INCREMENT AND SCAN MEMORY, 2ND CHARACTER     BCC     XXD0AF          ; IF CHARACTER = '0'-'9' (OK) GO SAVE 2ND CHARACTER                         ; 2ND CHARACTER WASN'T '0' TO '9' SO ...     JSR     XXD113          ; CHECK BYTE, RETURN CB = 0 IF<'A' OR >'Z'     BCC     XXD0BA          ; IF <'A' OR >'Z' GO CHECK IF STRINGXXD0AF = *     TAX                    ; COPY 2ND CHARACTER                         ; IGNORE FURTHER (VALID) CHARACTERS IN THE VARIABLE NAMEXXD0B0 = *     JSR     XX0073          ; INCREMENT AND SCAN MEMORY, 3RD CHARACTER     BCC     XXD0B0          ; LOOP IF CHARACTER = '0'-'9' (IGNORE)     JSR     XXD113          ; CHECK BYTE, RETURN CB = 0 IF<'A' OR >'Z'     BCS     XXD0B0          ; LOOP IF CHARACTER = 'A'-'Z' (IGNORE)                         ; CHECK IF STRING VARIABLEXXD0BA = *     CMP     #'$'               ; COMPARE WITH '$'     BNE     XXD0C4          ; IF NOT STRING GO CHECK INTEGER                         ; TYPE IS STRING     LDA     #$FF               ; SET DATA TYPE = STRING     STA     XX0D          ; SET DATA TYPE FLAG, $FF = STRING, $00 = NUMERIC     BNE     XXD0D4          ; BRANCH ALWAYSXXD0C4 = *     CMP     #$25               ; COMPARE WITH '%'     BNE     XXD0DB          ; IF NOT INTEGER GO CHECK FOR AN ARRAY     LDA     XX10          ; GET SUBSCRIPT/FNX FLAG     BNE     XXD09C          ; IF ?? DO SYNTAX ERROR THEN WARM START     LDA     #$80               ; SET INTEGER TYPE     STA     XX0E          ; SET DATA TYPE = INTEGER     ORA     XX45          ; OR CURRENT VARIABLE NAME FIRST BYTE     STA     XX45          ; SAVE CURRENT VARIABLE NAME FIRST BYTEXXD0D4 = *     TXA                    ; GET 2ND CHARACTER BACK     ORA     #$80               ; SET TOP BIT, INDICATE STRING OR INTEGER VARIABLE     TAX                    ; COPY BACK TO 2ND CHARACTER TEMP     JSR     XX0073          ; INCREMENT AND SCAN MEMORYXXD0DB = *     STX     XX46          ; SAVE 2ND CHARACTER     SEC                    ; SET CARRY FOR SUBTRACT     ORA     XX10          ; OR WITH SUBSCRIPT/FNX FLAG - OR FN NAME     SBC     #$28               ; SUBTRACT '('     BNE     XXD0E7          ; IF NOT '(' GO FIND A PLAIN NUMERIC VARIABLE     JMP     XXD1D1          ; ELSE GO FIND, OR MAKE, ARRAY; EITHER FIND OR CREATE VARIABLE                         ; VARIABLE NAME WASN'T XX(.... SO LOOK FOR PLAIN VARIABLEXXD0E7 = *     LDY     #$00               ; CLEAR A     STY     XX10          ; CLEAR SUBSCRIPT/FNX FLAG     LDA     XX2D          ; GET START OF VARIABLES LOW BYTE     LDX     XX2E          ; GET START OF VARIABLES HIGH BYTEXXD0EF = *     STX     XX60          ; SAVE SEARCH ADDRESS HIGH BYTEXXD0F1 = *     STA     XX5F          ; SAVE SEARCH ADDRESS LOW BYTE     CPX     XX30          ; COMPARE WITH END OF VARIABLES HIGH BYTE     BNE     XXD0FB          ; SKIP NEXT COMPARE IF <>                         ; HIGH ADDRESSES WERE = SO COMPARE LOW ADDRESSES     CMP     XX2F          ; COMPARE LOW ADDRESS WITH END OF VARIABLES LOW BYTE     BEQ     XXD11D          ; IF NOT FOUND GO MAKE NEW VARIABLEXXD0FB = *     LDA     XX45          ; GET 1ST CHARACTER OF VARIABLE TO FIND     CMP     (XX5F),Y          ; COMPARE WITH VARIABLE NAME 1ST CHARACTER     BNE     XXD109          ; IF NO MATCH GO TRY THE NEXT VARIABLE                         ; 1ST CHARACTERS MATCH SO COMPARE 2ND CHARACTER     LDA     XX46          ; GET 2ND CHARACTER OF VARIABLE TO FIND     INY                    ; INDEX TO POINT TO VARIABLE NAME 2ND CHARACTER     CMP     (XX5F),Y          ; COMPARE WITH VARIABLE NAME 2ND CHARACTER     BEQ     XXD185          ; IF MATCH GO RETURN THE VARIABLE     DEY                    ; ELSE DECREMENT INDEX (NOW = $00)XXD109 = *     CLC                    ; CLEAR CARRY FOR ADD     LDA     XX5F          ; GET SEARCH ADDRESS LOW BYTE     ADC     #$07               ; +7, OFFSET TO NEXT VARIABLE NAME     BCC     XXD0F1          ; LOOP IF NO OVERFLOW TO HIGH BYTE     INX                    ; ELSE INCREMENT HIGH BYTE     BNE     XXD0EF          ; LOOP ALWAYS, RAM DOESN'T EXTEND TO $FFFF;***********************************************************************************;;; CHECK BYTE, RETURN CB = 0 IF<'A' OR >'Z'XXD113 = *     CMP     #$41               ; COMPARE WITH 'A'     BCC     XXD11C          ; EXIT IF LESS                         ; CARRY IS SET     SBC     #$5B               ; SUBTRACT 'Z'+1     SEC                    ; SET CARRY     SBC     #$A5               ; SUBTRACT $A5 (RESTORE BYTE)                         ; CARRY CLEAR IF BYTE > $5AXXD11C = *     RTS;***********************************************************************************;;                         ; REACHED END OF VARIABLE MEMORY WITHOUT MATCH                         ; ... SO CREATE NEW VARIABLEXXD11D = *     PLA                    ; POP RETURN ADDRESS LOW BYTE     PHA                    ; PUSH RETURN ADDRESS LOW BYTE     CMP     #$2A               ; COMPARE WITH EXPECTED CALLING ROUTINE RETURN LOW BYTE     BNE     XXD128          ; IF NOT GET VARIABLE GO CREATE NEW VARIABLE; THIS WILL ONLY DROP THROUGH IF THE CALL WAS FROM XXXXXX AND IS ONLY CALLED; FROM THERE IF IT IS SEARCHING FOR A VARIABLE FROM THE RIGHT HAND SIDE OF A LET A=B; STATEMENT, IT PREVENTS THE CREATION OF VARIABLES NOT ASSIGNED A VALUE.; VALUE RETURNED BY THIS IS EITHER NUMERIC ZERO, EXPONENT BYTE IS $00, OR NULL STRING,; DESCRIPTOR LENGTH BYTE IS $00. IN FACT A POINTER TO ANY $00 BYTE WOULD HAVE DONE.                         ; ELSE RETURN DUMMY NULL VALUEXXD123 = *     LDA     #<XXDF13          ; SET RESULT POINTER LOW BYTE     LDY     #>XXDF13          ; SET RESULT POINTER HIGH BYTE     RTS                         ; CREATE NEW NUMERIC VARIABLEXXD128 = *     LDA     XX45          ; GET VARIABLE NAME FIRST CHARACTER     LDY     XX46          ; GET VARIABLE NAME SECOND CHARACTER     CMP     #'T'               ; COMPARE FIRST CHARACTER WITH 'T'     BNE     XXD13B          ; IF NOT 'T' CONTINUE     CPY     #$C9 ;#'I'+$80          ; COMPARE SECOND CHARACTER WITH 'I$'     BEQ     XXD123          ; IF 'I$' RETURN NULL VALUE     CPY     #'I'               ; COMPARE SECOND CHARACTER WITH 'I'     BNE     XXD13B          ; IF NOT 'I' CONTINUE                         ; IF NAME IS 'TI' DO SYNTAX ERRORXXD138 = *     JMP     XXCF08          ; DO SYNTAX ERROR THEN WARM STARTXXD13B = *     CMP     #'S'               ; COMPARE FIRST CHARACTER WITH 'S'     BNE     XXD143          ; IF NOT 'S' CONTINUE     CPY     #'T'               ; COMPARE SECOND CHARACTER WITH 'T'     BEQ     XXD138          ; IF NAME IS 'ST' DO SYNTAX ERRORXXD143 = *     LDA     XX2F          ; GET END OF VARIABLES LOW BYTE     LDY     XX30          ; GET END OF VARIABLES HIGH BYTE     STA     XX5F          ; SAVE OLD BLOCK START LOW BYTE     STY     XX60          ; SAVE OLD BLOCK START HIGH BYTE     LDA     XX31          ; GET END OF ARRAYS LOW BYTE     LDY     XX32          ; GET END OF ARRAYS HIGH BYTE     STA     XX5A          ; SAVE OLD BLOCK END LOW BYTE     STY     XX5B          ; SAVE OLD BLOCK END HIGH BYTE     CLC                    ; CLEAR CARRY FOR ADD     ADC     #$07               ; +7, SPACE FOR ONE VARIABLE     BCC     XXD159          ; IF NO OVERFLOW SKIP THE HIGH BYTE INCREMENT     INY                    ; ELSE INCREMENT HIGH BYTEXXD159 = *     STA     XX58          ; SET NEW BLOCK END LOW BYTE     STY     XX59          ; SET NEW BLOCK END HIGH BYTE     JSR     XXC3B8          ; OPEN UP SPACE IN MEMORY     LDA     XX58          ; GET NEW START LOW BYTE     LDY     XX59          ; GET NEW START HIGH BYTE (-$100)     INY                    ; CORRECT HIGH BYTE     STA     XX2F          ; SET END OF VARIABLES LOW BYTE     STY     XX30          ; SET END OF VARIABLES HIGH BYTE     LDY     #$00               ; CLEAR INDEX     LDA     XX45          ; GET VARIABLE NAME 1ST CHARACTER     STA     (XX5F),Y          ; SAVE VARIABLE NAME 1ST CHARACTER     INY                    ; INCREMENT INDEX     LDA     XX46          ; GET VARIABLE NAME 2ND CHARACTER     STA     (XX5F),Y          ; SAVE VARIABLE NAME 2ND CHARACTER     LDA     #$00               ; CLEAR A     INY                    ; INCREMENT INDEX     STA     (XX5F),Y          ; INITIALISE VARIABLE BYTE     INY                    ; INCREMENT INDEX     STA     (XX5F),Y          ; INITIALISE VARIABLE BYTE     INY                    ; INCREMENT INDEX     STA     (XX5F),Y          ; INITIALISE VARIABLE BYTE     INY                    ; INCREMENT INDEX     STA     (XX5F),Y          ; INITIALISE VARIABLE BYTE     INY                    ; INCREMENT INDEX     STA     (XX5F),Y          ; INITIALISE VARIABLE BYTE                         ; FOUND A MATCH FOR VARIABLEXXD185 = *     LDA     XX5F          ; GET VARIABLE ADDRESS LOW BYTE     CLC                    ; CLEAR CARRY FOR ADD     ADC     #$02               ; +2, OFFSET PAST VARIABLE NAME BYTES     LDY     XX60          ; GET VARIABLE ADDRESS HIGH BYTE     BCC     XXD18F          ; IF NO OVERFLOW SKIP THE HIGH BYTE INCREMENT     INY                    ; ELSE INCREMENT HIGH BYTEXXD18F = *     STA     XX47          ; SAVE CURRENT VARIABLE POINTER LOW BYTE     STY     XX48          ; SAVE CURRENT VARIABLE POINTER HIGH BYTE     RTS;***********************************************************************************;;; SET-UP ARRAY POINTER TO FIRST ELEMENT IN ARRAYXXD194 = *     LDA     XX0B          ; GET # OF DIMENSIONS (1, 2 OR 3)     ASL A                  ; *2 (ALSO CLEARS THE CARRY !)     ADC     #$05               ; +5 (RESULT IS 7, 9 OR 11 HERE)     ADC     XX5F          ; ADD ARRAY START POINTER LOW BYTE     LDY     XX60          ; GET ARRAY POINTER HIGH BYTE     BCC     XXD1A0          ; IF NO OVERFLOW SKIP THE HIGH BYTE INCREMENT     INY                    ; ELSE INCREMENT HIGH BYTEXXD1A0 = *     STA     XX58          ; SAVE ARRAY DATA POINTER LOW BYTE     STY     XX59          ; SAVE ARRAY DATA POINTER HIGH BYTE     RTS;***********************************************************************************;;; -32768 AS FLOATING VALUEXXD1A5 = *     .BYTE     $90,$80,$00,$00,$00     ; -32768;***********************************************************************************;;; CONVERT FLOAT TO FIXEDXXD1AA = *     JSR     XXD1BF          ; EVALUATE INTEGER EXPRESSION, NO SIGN CHECK     LDA     XX64          ; GET RESULT LOW BYTE     LDY     XX65          ; GET RESULT HIGH BYTE     RTS;***********************************************************************************;;; EVALUATE INTEGER EXPRESSIONXXD1B2 = *     JSR     XX0073          ; INCREMENT AND SCAN MEMORY     JSR     XXCD9E          ; EVALUATE EXPRESSION; EVALUATE INTEGER EXPRESSION, SIGN CHECKXXD1B8 = *     JSR     XXCD8D          ; CHECK IF SOURCE IS NUMERIC, ELSE DO TYPE MISMATCH     LDA     XX66          ; GET FAC1 SIGN (B7)     BMI     XXD1CC          ; DO ILLEGAL QUANTITY ERROR IF -VE; EVALUATE INTEGER EXPRESSION, NO SIGN CHECKXXD1BF = *     LDA     XX61          ; GET FAC1 EXPONENT     CMP     #$90               ; COMPARE WITH EXPONENT = 2^16 (N>2^15)     BCC     XXD1CE          ; IF N<2^16 GO CONVERT FAC1 FLOATING TO FIXED AND RETURN     LDA     #<XXD1A5          ; SET POINTER LOW BYTE TO -32768     LDY     #>XXD1A5          ; SET POINTER HIGH BYTE TO -32768     JSR     XXDC5B          ; COMPARE FAC1 WITH (AY)XXD1CC = *     BNE     XXD248          ; IF <> DO ILLEGAL QUANTITY ERROR THEN WARM STARTXXD1CE = *     JMP     XXDC9B          ; CONVERT FAC1 FLOATING TO FIXED AND RETURN;***********************************************************************************;;; AN ARRAY IS STORED AS FOLLOWS;; ARRAY NAME               ; TWO BYTES WITH THE FOLLOWING PATTERNS FOR DIFFERENT TYPES;                         ; 1ST CHAR     2ND CHAR;                         ;   B7       B7          TYPE               ELEMENT SIZE;                         ; --------     --------     -----               ------------;                         ;   0            0          FLOATING POINT      5;                         ;   0            1          STRING           3;                         ;   1            1          INTEGER           2; OFFSET TO NEXT ARRAY          ; WORD; DIMENSION COUNT               ; BYTE; 1ST DIMENSION SIZE          ; WORD, THIS IS THE NUMBER OF ELEMENTS INCLUDING 0; 2ND DIMENSION SIZE          ; WORD, ONLY HERE IF THE ARRAY HAS A SECOND DIMENSION; 2ND DIMENSION SIZE          ; WORD, ONLY HERE IF THE ARRAY HAS A THIRD DIMENSION;                         ; NOTE: THE DIMENSION SIZE WORD IS IN HIGH BYTE LOW BYTE;                         ; FORMAT, NOT LIKE MOST 6502 WORDS; THEN FOR EACH ELEMENT THE REQUIRED NUMBER OF BYTES GIVEN AS THE ELEMENT SIZE ABOVE; FIND OR MAKE ARRAYXXD1D1 = *     LDA     XX0C          ; GET DIM FLAG     ORA     XX0E          ; OR WITH DATA TYPE FLAG     PHA                    ; PUSH IT     LDA     XX0D          ; GET DATA TYPE FLAG, $FF = STRING, $00 = NUMERIC     PHA                    ; PUSH IT     LDY     #$00               ; CLEAR DIMENSIONS COUNT; NOW GET THE ARRAY DIMENSION(S) AND STACK IT (THEM) BEFORE THE DATA TYPE AND DIM FLAGXXD1DB = *     TYA                    ; COPY DIMENSIONS COUNT     PHA                    ; SAVE IT     LDA     XX46          ; GET ARRAY NAME 2ND BYTE     PHA                    ; SAVE IT     LDA     XX45          ; GET ARRAY NAME 1ST BYTE     PHA                    ; SAVE IT     JSR     XXD1B2          ; EVALUATE INTEGER EXPRESSION     PLA                    ; PULL ARRAY NAME 1ST BYTE     STA     XX45          ; RESTORE ARRAY NAME 1ST BYTE     PLA                    ; PULL ARRAY NAME 2ND BYTE     STA     XX46          ; RESTORE ARRAY NAME 2ND BYTE     PLA                    ; PULL DIMENSIONS COUNT     TAY                    ; RESTORE IT     TSX                    ; COPY STACK POINTER     LDA     XX0100+2,X     ; GET DIM FLAG     PHA                    ; PUSH IT     LDA     XX0100+1,X     ; GET DATA TYPE FLAG     PHA                    ; PUSH IT     LDA     XX64          ; GET THIS DIMENSION SIZE HIGH BYTE     STA     XX0100+2,X     ; STACK BEFORE FLAG BYTES     LDA     XX65          ; GET THIS DIMENSION SIZE LOW BYTE     STA     XX0100+1,X     ; STACK BEFORE FLAG BYTES     INY                    ; INCREMENT DIMENSIONS COUNT     JSR     XX0079          ; SCAN MEMORY     CMP     #','               ; COMPARE WITH ','     BEQ     XXD1DB          ; IF FOUND GO DO NEXT DIMENSION     STY     XX0B          ; STORE DIMENSIONS COUNT     JSR     XXCEF7          ; SCAN FOR ')', ELSE DO SYNTAX ERROR THEN WARM START     PLA                    ; PULL DATA TYPE FLAG     STA     XX0D          ; RESTORE DATA TYPE FLAG, $FF = STRING, $00 = NUMERIC     PLA                    ; PULL DATA TYPE FLAG     STA     XX0E          ; RESTORE DATA TYPE FLAG, $80 = INTEGER, $00 = FLOAT     AND     #$7F               ; MASK DIM FLAG     STA     XX0C          ; RESTORE DIM FLAG     LDX     XX2F          ; SET END OF VARIABLES LOW BYTE                         ; (ARRAY MEMORY START LOW BYTE)     LDA     XX30          ; SET END OF VARIABLES HIGH BYTE                         ; (ARRAY MEMORY START HIGH BYTE); NOW CHECK TO SEE IF WE ARE AT THE END OF ARRAY MEMORY, WE WOULD BE IF THERE WERE; NO ARRAYS.XXD21C = *     STX     XX5F          ; SAVE AS ARRAY START POINTER LOW BYTE     STA     XX60          ; SAVE AS ARRAY START POINTER HIGH BYTE     CMP     XX32          ; COMPARE WITH END OF ARRAYS HIGH BYTE     BNE     XXD228          ; IF NOT REACHED ARRAY MEMORY END CONTINUE SEARCHING     CPX     XX31          ; ELSE COMPARE WITH END OF ARRAYS LOW BYTE     BEQ     XXD261          ; GO BUILD ARRAY IF NOT FOUND                         ; SEARCH FOR ARRAYXXD228 = *     LDY     #$00               ; CLEAR INDEX     LDA     (XX5F),Y          ; GET ARRAY NAME FIRST BYTE     INY                    ; INCREMENT INDEX TO SECOND NAME BYTE     CMP     XX45          ; COMPARE WITH THIS ARRAY NAME FIRST BYTE     BNE     XXD237          ; IF NO MATCH GO TRY THE NEXT ARRAY     LDA     XX46          ; ELSE GET THIS ARRAY NAME SECOND BYTE     CMP     (XX5F),Y          ; COMPARE WITH ARRAY NAME SECOND BYTE     BEQ     XXD24D          ; ARRAY FOUND SO BRANCH                         ; NO MATCHXXD237 = *     INY                    ; INCREMENT INDEX     LDA     (XX5F),Y          ; GET ARRAY SIZE LOW BYTE     CLC                    ; CLEAR CARRY FOR ADD     ADC     XX5F          ; ADD ARRAY START POINTER LOW BYTE     TAX                    ; COPY LOW BYTE TO X     INY                    ; INCREMENT INDEX     LDA     (XX5F),Y          ; GET ARRAY SIZE HIGH BYTE     ADC     XX60          ; ADD ARRAY MEMORY POINTER HIGH BYTE     BCC     XXD21C          ; IF NO OVERFLOW GO CHECK NEXT ARRAY; DO BAD SUBSCRIPT ERRORXXD245 = *     LDX     #$12               ; ERROR $12, BAD SUBSCRIPT ERROR     .BYTE     $2C               ; MAKES NEXT LINE BIT XX0EA2;***********************************************************************************;;; DO ILLEGAL QUANTITY ERRORXXD248 = *     LDX     #$0E               ; ERROR $0E, ILLEGAL QUANTITY ERRORXXD24A = *     JMP     XXC437          ; DO ERROR #X THEN WARM START;***********************************************************************************;;; ARRAY FOUNDXXD24D = *     LDX     #$13               ; SET ERROR $13, DOUBLE DIMENSION ERROR     LDA     XX0C          ; GET DIM FLAG     BNE     XXD24A          ; IF WE ARE TRYING TO DIMENSION IT DO ERROR #X THEN WARM                         ; START; FOUND THE ARRAY AND WE'RE NOT DIMENSIONING IT SO WE MUST FIND AN ELEMENT IN IT     JSR     XXD194          ; SET-UP ARRAY POINTER TO FIRST ELEMENT IN ARRAY     LDA     XX0B          ; GET DIMENSIONS COUNT     LDY     #$04               ; SET INDEX TO ARRAY'S # OF DIMENSIONS     CMP     (XX5F),Y          ; COMPARE WITH NO OF DIMENSIONS     BNE     XXD245          ; IF WRONG DO BAD SUBSCRIPT ERROR     JMP     XXD2EA          ; FOUND ARRAY SO GO GET ELEMENT                         ; ARRAY NOT FOUND, SO BUILD ITXXD261 = *     JSR     XXD194          ; SET-UP ARRAY POINTER TO FIRST ELEMENT IN ARRAY     JSR     XXC408          ; CHECK AVAILABLE MEMORY, DO OUT OF MEMORY ERROR IF NO ROOM     LDY     #$00               ; CLEAR Y     STY     XX72          ; CLEAR ARRAY DATA SIZE HIGH BYTE     LDX     #$05               ; SET DEFAULT ELEMENT SIZE     LDA     XX45          ; GET VARIABLE NAME 1ST BYTE     STA     (XX5F),Y          ; SAVE ARRAY NAME 1ST BYTE     BPL     XXD274          ; BRANCH IF NOT STRING OR FLOATING POINT ARRAY     DEX                    ; DECREMENT ELEMENT SIZE, $04XXD274 = *     INY                    ; INCREMENT INDEX     LDA     XX46          ; GET VARIABLE NAME 2ND BYTE     STA     (XX5F),Y          ; SAVE ARRAY NAME 2ND BYTE     BPL     XXD27D          ; BRANCH IF NOT INTEGER OR STRING     DEX                    ; DECREMENT ELEMENT SIZE, $03     DEX                    ; DECREMENT ELEMENT SIZE, $02XXD27D = *     STX     XX71          ; SAVE ELEMENT SIZE     LDA     XX0B          ; GET DIMENSIONS COUNT     INY                    ; INCREMENT INDEX ..     INY                    ; .. TO ARRAY  ..     INY                    ; .. DIMENSION COUNT     STA     (XX5F),Y          ; SAVE ARRAY DIMENSION COUNTXXD286 = *     LDX     #$0B               ; SET DEFAULT DIMENSION SIZE LOW BYTE     LDA     #$00               ; SET DEFAULT DIMENSION SIZE HIGH BYTE     BIT     XX0C          ; TEST DIM FLAG     BVC     XXD296          ; IF DEFAULT TO BE USED DON'T PULL A DIMENSION     PLA                    ; PULL DIMENSION SIZE LOW BYTE     CLC                    ; CLEAR CARRY FOR ADD     ADC     #$01               ; ADD 1, ALLOW FOR ZEROETH ELEMENT     TAX                    ; COPY LOW BYTE TO X     PLA                    ; PULL DIMENSION SIZE HIGH BYTE     ADC     #$00               ; ADD CARRY TO HIGH BYTEXXD296 = *     INY                    ; INCEMENT INDEX TO DIMENSION SIZE HIGH BYTE     STA     (XX5F),Y          ; SAVE DIMENSION SIZE HIGH BYTE     INY                    ; INCEMENT INDEX TO DIMENSION SIZE LOW BYTE     TXA                    ; COPY DIMENSION SIZE LOW BYTE     STA     (XX5F),Y          ; SAVE DIMENSION SIZE LOW BYTE     JSR     XXD34C          ; COMPUTE ARRAY SIZE     STX     XX71          ; SAVE RESULT LOW BYTE     STA     XX72          ; SAVE RESULT HIGH BYTE     LDY     XX22          ; RESTORE INDEX     DEC     XX0B          ; DECREMENT DIMENSIONS COUNT     BNE     XXD286          ; LOOP IF NOT ALL DONE     ADC     XX59          ; ADD ARRAY DATA POINTER HIGH BYTE     BCS     XXD30B          ; IF OVERFLOW DO OUT OF MEMORY ERROR THEN WARM START     STA     XX59          ; SAVE ARRAY DATA POINTER HIGH BYTE     TAY                    ; COPY ARRAY DATA POINTER HIGH BYTE     TXA                    ; COPY ARRAY SIZE LOW BYTE     ADC     XX58          ; ADD ARRAY DATA POINTER LOW BYTE     BCC     XXD2B9          ; IF NO ROLLOVER SKIP THE HIGH BYTE INCREMENT     INY                    ; ELSE INCREMENT NEXT ARRAY POINTER HIGH BYTE     BEQ     XXD30B          ; IF ROLLED OVER DO OUT OF MEMORY ERROR THEN WARM STARTXXD2B9 = *     JSR     XXC408          ; CHECK AVAILABLE MEMORY, DO OUT OF MEMORY ERROR IF NO ROOM     STA     XX31          ; SET END OF ARRAYS LOW BYTE     STY     XX32          ; SET END OF ARRAYS HIGH BYTE; NOW THE ARAY IS CREATED WE NEED TO ZERO ALL THE ELEMENTS IN IT     LDA     #$00               ; CLEAR A FOR ARRAY CLEAR     INC     XX72          ; INCREMENT ARRAY SIZE HIGH BYTE, NOW BLOCK COUNT     LDY     XX71          ; GET ARRAY SIZE LOW BYTE, NOW INDEX TO BLOCK     BEQ     XXD2CD          ; IF $00 GO DO THE HIGH BYTE DECREMENTXXD2C8 = *     DEY                    ; DECREMENT INDEX, DO 0 TO N-1     STA     (XX58),Y          ; CLEAR ARRAY ELEMENT BYTE     BNE     XXD2C8          ; LOOP UNTIL THIS BLOCK DONEXXD2CD = *     DEC     XX59          ; DECREMENT ARRAY POINTER HIGH BYTE     DEC     XX72          ; DECREMENT BLOCK COUNT HIGH BYTE     BNE     XXD2C8          ; LOOP UNTIL ALL BLOCKS DONE     INC     XX59          ; CORRECT FOR LAST LOOP     SEC                    ; SET CARRY FOR SUBTRACT     LDA     XX31          ; GET END OF ARRAYS LOW BYTE     SBC     XX5F          ; SUBTRACT ARRAY START LOW BYTE     LDY     #$02               ; INDEX TO ARRAY SIZE LOW BYTE     STA     (XX5F),Y          ; SAVE ARRAY SIZE LOW BYTE     LDA     XX32          ; GET END OF ARRAYS HIGH BYTE     INY                    ; INDEX TO ARRAY SIZE HIGH BYTE     SBC     XX60          ; SUBTRACT ARRAY START HIGH BYTE     STA     (XX5F),Y          ; SAVE ARRAY SIZE HIGH BYTE     LDA     XX0C          ; GET DEFAULT DIM FLAG     BNE     XXD34B          ; EXIT IF THIS WAS A DIM COMMAND                         ; ELSE, FIND ELEMENT     INY                    ; SET INDEX TO # OF DIMENSIONS, THE DIMENSION INDECES                         ; ARE ON THE STACK AND WILL BE REMOVED AS THE POSITION                         ; OF THE ARRAY ELEMENT IS CALCULATEDXXD2EA = *     LDA     (XX5F),Y          ; GET ARRAY'S DIMENSION COUNT     STA     XX0B          ; SAVE IT     LDA     #$00               ; CLEAR BYTE     STA     XX71          ; CLEAR ARRAY DATA POINTER LOW BYTEXXD2F2 = *     STA     XX72          ; SAVE ARRAY DATA POINTER HIGH BYTE     INY                    ; INCREMENT INDEX, POINT TO ARRAY BOUND HIGH BYTE     PLA                    ; PULL ARRAY INDEX LOW BYTE     TAX                    ; COPY TO X     STA     XX64          ; SAVE INDEX LOW BYTE TO FAC1 MANTISSA 3     PLA                    ; PULL ARRAY INDEX HIGH BYTE     STA     XX65          ; SAVE INDEX HIGH BYTE TO FAC1 MANTISSA 4     CMP     (XX5F),Y          ; COMPARE WITH ARRAY BOUND HIGH BYTE     BCC     XXD30E          ; IF WITHIN BOUNDS CONTINUE     BNE     XXD308          ; IF OUTSIDE BOUNDS DO BAD SUBSCRIPT ERROR                         ; ELSE HIGH BYTE WAS = SO TEST LOW BYTES     INY                    ; INDEX TO ARRAY BOUND LOW BYTE     TXA                    ; GET ARRAY INDEX LOW BYTE     CMP     (XX5F),Y          ; COMPARE WITH ARRAY BOUND LOW BYTE     BCC     XXD30F          ; IF WITHIN BOUNDS CONTINUEXXD308 = *     JMP     XXD245          ; DO BAD SUBSCRIPT ERRORXXD30B = *     JMP     XXC435          ; DO OUT OF MEMORY ERROR THEN WARM STARTXXD30E = *     INY                    ; INDEX TO ARRAY BOUND LOW BYTEXXD30F = *     LDA     XX72          ; GET ARRAY DATA POINTER HIGH BYTE     ORA     XX71          ; OR WITH ARRAY DATA POINTER LOW BYTE     CLC                    ; CLEAR CARRY FOR EITHER ADD, CARRY ALWAYS CLEAR HERE ??     BEQ     XXD320          ; IF ARRAY DATA POINTER = NULL SKIP THE MULTIPLY     JSR     XXD34C          ; COMPUTE ARRAY SIZE     TXA                    ; GET RESULT LOW BYTE     ADC     XX64          ; ADD INDEX LOW BYTE FROM FAC1 MANTISSA 3     TAX                    ; SAVE RESULT LOW BYTE     TYA                    ; GET RESULT HIGH BYTE     LDY     XX22          ; RESTORE INDEXXXD320 = *     ADC     XX65          ; ADD INDEX HIGH BYTE FROM FAC1 MANTISSA 4     STX     XX71          ; SAVE ARRAY DATA POINTER LOW BYTE     DEC     XX0B          ; DECREMENT DIMENSIONS COUNT     BNE     XXD2F2          ; LOOP IF DIMENSIONS STILL TO DO     STA     XX72          ; SAVE ARRAY DATA POINTER HIGH BYTE     LDX     #$05               ; SET DEFAULT ELEMENT SIZE     LDA     XX45          ; GET VARIABLE NAME 1ST BYTE     BPL     XXD331          ; BRANCH IF NOT STRING OR FLOATING POINT ARRAY     DEX                    ; DECREMENT ELEMENT SIZE, $04XXD331 = *     LDA     XX46          ; GET VARIABLE NAME 2ND BYTE     BPL     XXD337          ; BRANCH IF NOT INTEGER OR STRING     DEX                    ; DECREMENT ELEMENT SIZE, $03     DEX                    ; DECREMENT ELEMENT SIZE, $02XXD337 = *     STX     XX28          ; SAVE DIMENSION SIZE LOW BYTE     LDA     #$00               ; CLEAR DIMENSION SIZE HIGH BYTE     JSR     XXD355          ; COMPUTE ARRAY SIZE     TXA                    ; COPY ARRAY SIZE LOW BYTE     ADC     XX58          ; ADD ARRAY DATA START POINTER LOW BYTE     STA     XX47          ; SAVE AS CURRENT VARIABLE POINTER LOW BYTE     TYA                    ; COPY ARRAY SIZE HIGH BYTE     ADC     XX59          ; ADD ARRAY DATA START POINTER HIGH BYTE     STA     XX48          ; SAVE AS CURRENT VARIABLE POINTER HIGH BYTE     TAY                    ; COPY HIGH BYTE TO Y     LDA     XX47          ; GET CURRENT VARIABLE POINTER LOW BYTE                         ; POINTER TO ELEMENT IS NOW IN AYXXD34B = *     RTS;***********************************************************************************;;; COMPUTE ARRAY SIZE, RESULT IN XYXXD34C = *     STY     XX22          ; SAVE INDEX     LDA     (XX5F),Y          ; GET DIMENSION SIZE LOW BYTE     STA     XX28          ; SAVE DIMENSION SIZE LOW BYTE     DEY                    ; DECREMENT INDEX     LDA     (XX5F),Y          ; GET DIMENSION SIZE HIGH BYTEXXD355 = *     STA     XX29          ; SAVE DIMENSION SIZE HIGH BYTE     LDA     #$10               ; COUNT = $10 (16 BIT MULTIPLY)     STA     XX5D          ; SAVE BIT COUNT     LDX     #$00               ; CLEAR RESULT LOW BYTE     LDY     #$00               ; CLEAR RESULT HIGH BYTEXXD35F = *     TXA                    ; GET RESULT LOW BYTE     ASL A                  ; *2     TAX                    ; SAVE RESULT LOW BYTE     TYA                    ; GET RESULT HIGH BYTE     ROL A                  ; *2     TAY                    ; SAVE RESULT HIGH BYTE     BCS     XXD30B          ; IF OVERFLOW GO DO 'OUT OF MEMORY' ERROR     ASL     XX71          ; SHIFT ELEMENT SIZE LOW BYTE     ROL     XX72          ; SHIFT ELEMENT SIZE HIGH BYTE     BCC     XXD378          ; SKIP ADD IF NO CARRY     CLC                    ; ELSE CLEAR CARRY FOR ADD     TXA                    ; GET RESULT LOW BYTE     ADC     XX28          ; ADD DIMENSION SIZE LOW BYTE     TAX                    ; SAVE RESULT LOW BYTE     TYA                    ; GET RESULT HIGH BYTE     ADC     XX29          ; ADD DIMENSION SIZE HIGH BYTE     TAY                    ; SAVE RESULT HIGH BYTE     BCS     XXD30B          ; IF OVERFLOW GO DO 'OUT OF MEMORY' ERRORXXD378 = *     DEC     XX5D          ; DECREMENT BIT COUNT     BNE     XXD35F          ; LOOP UNTIL ALL DONE     RTS;***********************************************************************************;;; PERFORM FRE()XXD37D = *     LDA     XX0D          ; GET DATA TYPE FLAG, $FF = STRING, $00 = NUMERIC     BEQ     XXD384          ; IF NUMERIC DON'T POP THE STRING     JSR     XXD6A6          ; POP STRING OFF DESCRIPTOR STACK, OR FROM TOP OF STRING                         ; SPACE RETURNS WITH A = LENGTH, X=$71=POINTER LOW BYTE,                         ; Y=$72=POINTER HIGH BYTE                         ; FRE(N) WAS NUMERIC SO DO THISXXD384 = *     JSR     XXD526          ; GO DO GARBAGE COLLECTION     SEC                    ; SET CARRY FOR SUBTRACT     LDA     XX33          ; GET BOTTOM OF STRING SPACE LOW BYTE     SBC     XX31          ; SUBTRACT END OF ARRAYS LOW BYTE     TAY                    ; COPY RESULT TO Y     LDA     XX34          ; GET BOTTOM OF STRING SPACE HIGH BYTE     SBC     XX32          ; SUBTRACT END OF ARRAYS HIGH BYTE;***********************************************************************************;;; CONVERT FIXED INTEGER AY TO FLOAT FAC1XXD391 = *     LDX     #$00               ; SET TYPE = NUMERIC     STX     XX0D          ; CLEAR DATA TYPE FLAG, $FF = STRING, $00 = NUMERIC     STA     XX62          ; SAVE FAC1 MANTISSA 1     STY     XX63          ; SAVE FAC1 MANTISSA 2     LDX     #$90               ; SET EXPONENT=2^16 (INTEGER)     JMP     XXDC44          ; SET EXP = X, CLEAR FAC1 3 AND 4, NORMALISE AND RETURN;***********************************************************************************;;; PERFORM POS()XXD39E = *     SEC                    ; SET CB FOR READ CURSOR POSITION     JSR     XXFFF0          ; READ/SET X,Y CURSOR POSITIONXXD3A2 = *     LDA     #$00               ; CLEAR HIGH BYTE     BEQ     XXD391          ; CONVERT FIXED INTEGER AY TO FLOAT FAC1, BRANCH ALWAYS;***********************************************************************************;;; CHECK NOT DIRECT, USED BY DEF AND INPUTXXD3A6 = *     LDX     XX3A          ; GET CURRENT LINE NUMBER HIGH BYTE     INX                    ; INCREMENT IT     BNE     XXD34B          ; RETURN IF NOT DIRECT MODE                         ; ELSE DO ILLEGAL DIRECT ERROR     LDX     #$15               ; ERROR $15, ILLEGAL DIRECT ERROR     .BYTE     $2C               ; MAKES NEXT LINE BIT XX1BA2XXD3AE = *     LDX     #$1B               ; ERROR $1B, UNDEFINED FUNCTION ERROR     JMP     XXC437          ; DO ERROR #X THEN WARM START;***********************************************************************************;;; PERFORM DEFXXD3B3 = *     JSR     XXD3E1          ; CHECK FNX SYNTAX     JSR     XXD3A6          ; CHECK NOT DIRECT, BACK HERE IF OK     JSR     XXCEFA          ; SCAN FOR '(', ELSE DO SYNTAX ERROR THEN WARM START     LDA     #$80               ; SET FLAG FOR FNX     STA     XX10          ; SAVE SUBSCRIPT/FNX FLAG     JSR     XXD08B          ; GET VARIABLE ADDRESS     JSR     XXCD8D          ; CHECK IF SOURCE IS NUMERIC, ELSE DO TYPE MISMATCH     JSR     XXCEF7          ; SCAN FOR ')', ELSE DO SYNTAX ERROR THEN WARM START     LDA     #TEQUAL          ; GET = TOKEN     JSR     XXCEFF          ; SCAN FOR CHR$(A), ELSE DO SYNTAX ERROR THEN WARM START     PHA                    ; PUSH NEXT CHARACTER     LDA     XX48          ; GET CURRENT VARIABLE POINTER HIGH BYTE     PHA                    ; PUSH IT     LDA     XX47          ; GET CURRENT VARIABLE POINTER LOW BYTE     PHA                    ; PUSH IT     LDA     XX7B          ; GET BASIC EXECUTE POINTER HIGH BYTE     PHA                    ; PUSH IT     LDA     XX7A          ; GET BASIC EXECUTE POINTER LOW BYTE     PHA                    ; PUSH IT     JSR     XXC8F8          ; PERFORM DATA     JMP     XXD44F          ; PUT EXECUTE POINTER AND VARIABLE POINTER INTO FUNCTION                         ; AND RETURN;***********************************************************************************;;; CHECK FNX SYNTAXXXD3E1 = *     LDA     #TFN          ; SET FN TOKEN     JSR     XXCEFF          ; SCAN FOR CHR$(A), ELSE DO SYNTAX ERROR THEN WARM START     ORA     #$80               ; SET FN FLAG BIT     STA     XX10          ; SAVE FN NAME     JSR     XXD092          ; SEARCH FOR FN VARIABLE     STA     XX4E          ; SAVE FUNCTION POINTER LOW BYTE     STY     XX4F          ; SAVE FUNCTION POINTER HIGH BYTE     JMP     XXCD8D          ; CHECK IF SOURCE IS NUMERIC AND RETURN, ELSE DO TYPE                         ; MISMATCH;***********************************************************************************;;; EVALUATE FNXXXD3F4 = *     JSR     XXD3E1          ; CHECK FNX SYNTAX     LDA     XX4F          ; GET FUNCTION POINTER HIGH BYTE     PHA                    ; PUSH IT     LDA     XX4E          ; GET FUNCTION POINTER LOW BYTE     PHA                    ; PUSH IT     JSR     XXCEF1          ; EVALUATE EXPRESSION WITHIN PARENTHESES     JSR     XXCD8D          ; CHECK IF SOURCE IS NUMERIC, ELSE DO TYPE MISMATCH     PLA                    ; POP FUNCTION POINTER LOW BYTE     STA     XX4E          ; RESTORE IT     PLA                    ; POP FUNCTION POINTER HIGH BYTE     STA     XX4F          ; RESTORE IT     LDY     #$02               ; INDEX TO VARIABLE POINTER HIGH BYTE     LDA     (XX4E),Y          ; GET VARIABLE ADDRESS LOW BYTE     STA     XX47          ; SAVE CURRENT VARIABLE POINTER LOW BYTE     TAX                    ; COPY ADDRESS LOW BYTE     INY                    ; INDEX TO VARIABLE ADDRESS HIGH BYTE     LDA     (XX4E),Y          ; GET VARIABLE POINTER HIGH BYTE     BEQ     XXD3AE          ; IF HIGH BYTE ZERO GO DO UNDEFINED FUNCTION ERROR     STA     XX48          ; SAVE CURRENT VARIABLE POINTER HIGH BYTE     INY                    ; INDEX TO MANTISSA 3                         ; NOW STACK THE FUNCTION VARIABLE VALUE BEFORE USEXXD418 = *     LDA     (XX47),Y          ; GET BYTE FROM VARIABLE     PHA                    ; STACK IT     DEY                    ; DECREMENT INDEX     BPL     XXD418          ; LOOP UNTIL VARIABLE STACKED     LDY     XX48          ; GET CURRENT VARIABLE POINTER HIGH BYTE     JSR     XXDBD4          ; PACK FAC1 INTO (XY)     LDA     XX7B          ; GET BASIC EXECUTE POINTER HIGH BYTE     PHA                    ; PUSH IT     LDA     XX7A          ; GET BASIC EXECUTE POINTER LOW BYTE     PHA                    ; PUSH IT     LDA     (XX4E),Y          ; GET FUNCTION EXECUTE POINTER LOW BYTE     STA     XX7A          ; SAVE BASIC EXECUTE POINTER LOW BYTE     INY                    ; INDEX TO HIGH BYTE     LDA     (XX4E),Y          ; GET FUNCTION EXECUTE POINTER HIGH BYTE     STA     XX7B          ; SAVE BASIC EXECUTE POINTER HIGH BYTE     LDA     XX48          ; GET CURRENT VARIABLE POINTER HIGH BYTE     PHA                    ; PUSH IT     LDA     XX47          ; GET CURRENT VARIABLE POINTER LOW BYTE     PHA                    ; PUSH IT     JSR     XXCD8A          ; EVALUATE EXPRESSION AND CHECK IS NUMERIC, ELSE DO                         ; TYPE MISMATCH     PLA                    ; PULL VARIABLE ADDRESS LOW BYTE     STA     XX4E          ; SAVE VARIABLE ADDRESS LOW BYTE     PLA                    ; PULL VARIABLE ADDRESS HIGH BYTE     STA     XX4F          ; SAVE VARIABLE ADDRESS HIGH BYTE     JSR     XX0079          ; SCAN MEMORY     BEQ     XXD449          ; IF NULL (SHOULD BE [EOL] MARKER) CONTINUE     JMP     XXCF08          ; ELSE SYNTAX ERROR THEN WARM START; RESTORE BASIC EXECUTE POINTER AND FUNCTION VARIABLE FROM STACKXXD449 = *     PLA                    ; PULL BASIC EXECUTE POINTER LOW BYTE     STA     XX7A          ; SAVE BASIC EXECUTE POINTER LOW BYTE     PLA                    ; PULL BASIC EXECUTE POINTER HIGH BYTE     STA     XX7B          ; SAVE BASIC EXECUTE POINTER HIGH BYTE; PUT EXECUTE POINTER AND VARIABLE POINTER INTO FUNCTIONXXD44F = *     LDY     #$00               ; CLEAR INDEX     PLA                    ; PULL BASIC EXECUTE POINTER LOW BYTE     STA     (XX4E),Y          ; SAVE TO FUNCTION     PLA                    ; PULL BASIC EXECUTE POINTER HIGH BYTE     INY                    ; INCREMENT INDEX     STA     (XX4E),Y          ; SAVE TO FUNCTION     PLA                    ; PULL CURRENT VARIABLE ADDRESS LOW BYTE     INY                    ; INCREMENT INDEX     STA     (XX4E),Y          ; SAVE TO FUNCTION     PLA                    ; PULL CURRENT VARIABLE ADDRESS HIGH BYTE     INY                    ; INCREMENT INDEX     STA     (XX4E),Y          ; SAVE TO FUNCTION     PLA                    ; PULL ??     INY                    ; INCREMENT INDEX     STA     (XX4E),Y          ; SAVE TO FUNCTION     RTS;***********************************************************************************;;; PERFORM STR$()XXD465 = *     JSR     XXCD8D          ; CHECK IF SOURCE IS NUMERIC, ELSE DO TYPE MISMATCH     LDY     #$00               ; SET STRING INDEX     JSR     XXDDDF          ; CONVERT FAC1 TO STRING     PLA                    ; DUMP RETURN ADDRESS (SKIP TYPE CHECK)     PLA                    ; DUMP RETURN ADDRESS (SKIP TYPE CHECK)XXD46F = *     LDA     #<XX00FF          ; SET RESULT STRING LOW POINTER     LDY     #>XX00FF          ; SET RESULT STRING HIGH POINTER     BEQ     XXD487          ; PRINT NULL TERMINATED STRING TO UTILITY POINTER;***********************************************************************************;;; DO STRING VECTOR; COPY DESCRIPTOR POINTER AND MAKE STRING SPACE A BYTES LONGXXD475 = *     LDX     XX64          ; GET DESCRIPTOR POINTER LOW BYTE     LDY     XX65          ; GET DESCRIPTOR POINTER HIGH BYTE     STX     XX50          ; SAVE DESCRIPTOR POINTER LOW BYTE     STY     XX51          ; SAVE DESCRIPTOR POINTER HIGH BYTE;***********************************************************************************;;; MAKE STRING SPACE A BYTES LONGXXD47D = *     JSR     XXD4F4          ; MAKE SPACE IN STRING MEMORY FOR STRING A LONG     STX     XX62          ; SAVE STRING POINTER LOW BYTE     STY     XX63          ; SAVE STRING POINTER HIGH BYTE     STA     XX61          ; SAVE LENGTH     RTS;***********************************************************************************;;; SCAN, SET UP STRING; PRINT ' TERMINATED STRING TO UTILITY POINTERXXD487 = *     LDX     #$22               ; SET TERMINATOR TO '     STX     XX07          ; SET SEARCH CHARACTER, TERMINATOR 1     STX     XX08          ; SET TERMINATOR 2; PRINT SEARCH OR ALTERNATE TERMINATED STRING TO UTILITY POINTER; SOURCE IS AYXXD48D = *     STA     XX6F          ; STORE STRING START LOW BYTE     STY     XX70          ; STORE STRING START HIGH BYTE     STA     XX62          ; SAVE STRING POINTER LOW BYTE     STY     XX63          ; SAVE STRING POINTER HIGH BYTE     LDY     #$FF               ; SET LENGTH TO -1XXD497 = *     INY                    ; INCREMENT LENGTH     LDA     (XX6F),Y          ; GET BYTE FROM STRING     BEQ     XXD4A8          ; EXIT LOOP IF NULL BYTE [EOS]     CMP     XX07          ; COMPARE WITH SEARCH CHARACTER, TERMINATOR 1     BEQ     XXD4A4          ; BRANCH IF TERMINATOR     CMP     XX08          ; COMPARE WITH TERMINATOR 2     BNE     XXD497          ; LOOP IF NOT TERMINATOR 2XXD4A4 = *     CMP     #$22               ; COMPARE WITH '     BEQ     XXD4A9          ; BRANCH IF ' (CARRY SET IF = !)XXD4A8 = *     CLC                    ; CLEAR CARRY FOR ADD (ONLY IF [EOL] TERMINATED STRING)XXD4A9 = *     STY     XX61          ; SAVE LENGTH IN FAC1 EXPONENT     TYA                    ; COPY LENGTH TO A     ADC     XX6F          ; ADD STRING START LOW BYTE     STA     XX71          ; SAVE STRING END LOW BYTE     LDX     XX70          ; GET STRING START HIGH BYTE     BCC     XXD4B5          ; IF NO LOW BYTE OVERFLOW SKIP THE HIGH BYTE INCREMENT     INX                    ; ELSE INCREMENT HIGH BYTEXXD4B5 = *     STX     XX72          ; SAVE STRING END HIGH BYTE     LDA     XX70          ; GET STRING START HIGH BYTE     BEQ     XXD4BF          ; BRANCH IF IN UTILITY AREA     CMP     #$02               ; COMPARE WITH INPUT BUFFER MEMORY HIGH BYTE     BNE     XXD4CA          ; BRANCH IF NOT IN INPUT BUFFER MEMORY                         ; STRING IN INPUT BUFFER OR UTILITY AREA, MOVE TO STRING                         ; MEMORYXXD4BF = *     TYA                    ; COPY LENGTH TO A     JSR     XXD475          ; COPY DESCRIPTOR POINTER AND MAKE STRING SPACE A BYTES LONG     LDX     XX6F          ; GET STRING START LOW BYTE     LDY     XX70          ; GET STRING START HIGH BYTE     JSR     XXD688          ; STORE STRING A BYTES LONG FROM XY TO UTILITY POINTER; CHECK FOR SPACE ON DESCRIPTOR STACK THEN ...; PUT STRING ADDRESS AND LENGTH ON DESCRIPTOR STACK AND UPDATE STACK POINTERSXXD4CA = *     LDX     XX16          ; GET DESCRIPTOR STACK POINTER     CPX     #$22               ; COMPARE WITH MAX+1     BNE     XXD4D5          ; BRANCH IF SPACE ON STRING STACK                         ; ELSE DO STRING TOO COMPLEX ERROR     LDX     #$19               ; ERROR $19, STRING TOO COMPLEX ERRORXXD4D2 = *     JMP     XXC437          ; DO ERROR #X THEN WARM START; PUT STRING ADDRESS AND LENGTH ON DESCRIPTOR STACK AND UPDATE STACK POINTERSXXD4D5 = *     LDA     XX61          ; GET STRING LENGTH     STA     XX00,X          ; PUT ON STRING STACK     LDA     XX62          ; GET STRING POINTER LOW BYTE     STA     XX01,X          ; PUT ON STRING STACK     LDA     XX63          ; GET STRING POINTER HIGH BYTE     STA     XX02,X          ; PUT ON STRING STACK     LDY     #$00               ; CLEAR Y     STX     XX64          ; SAVE STRING DESCRIPTOR POINTER LOW BYTE     STY     XX65          ; SAVE STRING DESCRIPTOR POINTER HIGH BYTE, ALWAYS $00     STY     XX70          ; CLEAR FAC1 ROUNDING BYTE     DEY                    ; Y = $FF     STY     XX0D          ; SAVE DATA TYPE FLAG, $FF = STRING     STX     XX17          ; SAVE CURRENT DESCRIPTOR STACK ITEM POINTER LOW BYTE     INX                    ; UPDATE STACK POINTER     INX                    ; UPDATE STACK POINTER     INX                    ; UPDATE STACK POINTER     STX     XX16          ; SET NEW DESCRIPTOR STACK POINTER     RTS; MAKE SPACE IN STRING MEMORY FOR STRING A LONG; RETURN X = POINTER LOW BYTE, Y = POINTER HIGH BYTEXXD4F4 = *     LSR     XX0F          ; CLEAR GARBAGE COLLECTED FLAG (B7)                         ; MAKE SPACE FOR STRING A LONGXXD4F6 = *     PHA                    ; SAVE STRING LENGTH     EOR     #$FF               ; COMPLEMENT IT     SEC                    ; SET CARRY FOR SUBTRACT, TWO'S COMPLEMENT ADD     ADC     XX33          ; ADD BOTTOM OF STRING SPACE LOW BYTE, SUBTRACT LENGTH     LDY     XX34          ; GET BOTTOM OF STRING SPACE HIGH BYTE     BCS     XXD501          ; SKIP DECREMENT IF NO UNDERFLOW     DEY                    ; DECREMENT BOTTOM OF STRING SPACE HIGH BYTEXXD501 = *     CPY     XX32          ; COMPARE WITH END OF ARRAYS HIGH BYTE     BCC     XXD516          ; DO OUT OF MEMORY ERROR IF LESS     BNE     XXD50B          ; IF NOT = SKIP NEXT TEST     CMP     XX31          ; COMPARE WITH END OF ARRAYS LOW BYTE     BCC     XXD516          ; DO OUT OF MEMORY ERROR IF LESSXXD50B = *     STA     XX33          ; SAVE BOTTOM OF STRING SPACE LOW BYTE     STY     XX34          ; SAVE BOTTOM OF STRING SPACE HIGH BYTE     STA     XX35          ; SAVE STRING UTILITY PTR LOW BYTE     STY     XX36          ; SAVE STRING UTILITY PTR HIGH BYTE     TAX                    ; COPY LOW BYTE TO X     PLA                    ; GET STRING LENGTH BACK     RTSXXD516 = *     LDX     #$10               ; ERROR CODE $10, OUT OF MEMORY ERROR     LDA     XX0F          ; GET GARBAGE COLLECTED FLAG     BMI     XXD4D2          ; IF SET THEN DO ERROR CODE X     JSR     XXD526          ; ELSE GO DO GARBAGE COLLECTION     LDA     #$80               ; FLAG FOR GARBAGE COLLECTED     STA     XX0F          ; SET GARBAGE COLLECTED FLAG     PLA                    ; PULL LENGTH     BNE     XXD4F6          ; GO TRY AGAIN (LOOP ALWAYS, LENGTH SHOULD NEVER BE = $00);***********************************************************************************;;; GARBAGE COLLECTION ROUTINEXXD526 = *     LDX     XX37          ; GET END OF MEMORY LOW BYTE     LDA     XX38          ; GET END OF MEMORY HIGH BYTE; RE-RUN ROUTINE FROM LAST ENDINGXXD52A = *     STX     XX33          ; SET BOTTOM OF STRING SPACE LOW BYTE     STA     XX34          ; SET BOTTOM OF STRING SPACE HIGH BYTE     LDY     #$00               ; CLEAR INDEX     STY     XX4F          ; CLEAR WORKING POINTER HIGH BYTE     STY     XX4E          ; CLEAR WORKING POINTER LOW BYTE     LDA     XX31          ; GET END OF ARRAYS LOW BYTE     LDX     XX32          ; GET END OF ARRAYS HIGH BYTE     STA     XX5F          ; SAVE AS HIGHEST UNCOLLECTED STRING POINTER LOW BYTE     STX     XX60          ; SAVE AS HIGHEST UNCOLLECTED STRING POINTER HIGH BYTE     LDA     #XX19          ; SET DESCRIPTOR STACK POINTER     LDX     #$00               ; CLEAR X     STA     XX22          ; SAVE DESCRIPTOR STACK POINTER LOW BYTE     STX     XX23          ; SAVE DESCRIPTOR STACK POINTER HIGH BYTE ($00)XXD544 = *     CMP     XX16          ; COMPARE WITH DESCRIPTOR STACK POINTER     BEQ     XXD54D          ; BRANCH IF =     JSR     XXD5C7          ; CHECK STRING SALVAGEABILITY     BEQ     XXD544          ; LOOP ALWAYS                         ; DONE STACKED STRINGS, NOW DO STRING VARIABLESXXD54D = *     LDA     #$07               ; SET STEP SIZE = $07, COLLECTING VARIABLES     STA     XX53          ; SAVE GARBAGE COLLECTION STEP SIZE     LDA     XX2D          ; GET START OF VARIABLES LOW BYTE     LDX     XX2E          ; GET START OF VARIABLES HIGH BYTE     STA     XX22          ; SAVE AS POINTER LOW BYTE     STX     XX23          ; SAVE AS POINTER HIGH BYTEXXD559 = *     CPX     XX30          ; COMPARE END OF VARIABLES HIGH BYTE,                         ; START OF ARRAYS HIGH BYTE     BNE     XXD561          ; BRANCH IF NO HIGH BYTE MATCH     CMP     XX2F          ; ELSE COMPARE END OF VARIABLES LOW BYTE,                         ; START OF ARRAYS LOW BYTE     BEQ     XXD566          ; BRANCH IF = VARIABLE MEMORY ENDXXD561 = *     JSR     XXD5BD          ; CHECK VARIABLE SALVAGEABILITY     BEQ     XXD559          ; LOOP ALWAYS                         ; DONE STRING VARIABLES, NOW DO STRING ARRAYSXXD566 = *     STA     XX58          ; SAVE START OF ARRAYS LOW BYTE AS WORKING POINTER     STX     XX59          ; SAVE START OF ARRAYS HIGH BYTE AS WORKING POINTER     LDA     #$03               ; SET STEP SIZE, COLLECTING DESCRIPTORS     STA     XX53          ; SAVE STEP SIZEXXD56E = *     LDA     XX58          ; GET POINTER LOW BYTE     LDX     XX59          ; GET POINTER HIGH BYTEXXD572 = *     CPX     XX32          ; COMPARE WITH END OF ARRAYS HIGH BYTE     BNE     XXD57D          ; BRANCH IF NOT AT END     CMP     XX31          ; ELSE COMPARE WITH END OF ARRAYS LOW BYTE     BNE     XXD57D          ; BRANCH IF NOT AT END     JMP     XXD606          ; COLLECT STRING, TIDY UP AND EXIT IF AT END ??XXD57D = *     STA     XX22          ; SAVE POINTER LOW BYTE     STX     XX23          ; SAVE POINTER HIGH BYTE     LDY     #$00               ; SET INDEX     LDA     (XX22),Y          ; GET ARRAY NAME FIRST BYTE     TAX                    ; COPY IT     INY                    ; INCREMENT INDEX     LDA     (XX22),Y          ; GET ARRAY NAME SECOND BYTE     PHP                    ; PUSH THE FLAGS     INY                    ; INCREMENT INDEX     LDA     (XX22),Y          ; GET ARRAY SIZE LOW BYTE     ADC     XX58          ; ADD START OF THIS ARRAY LOW BYTE     STA     XX58          ; SAVE START OF NEXT ARRAY LOW BYTE     INY                    ; INCREMENT INDEX     LDA     (XX22),Y          ; GET ARRAY SIZE HIGH BYTE     ADC     XX59          ; ADD START OF THIS ARRAY HIGH BYTE     STA     XX59          ; SAVE START OF NEXT ARRAY HIGH BYTE     PLP                    ; RESTORE THE FLAGS     BPL     XXD56E          ; SKIP IF NOT STRING ARRAY; WAS POSSIBLY STRING ARRAY SO ...     TXA                    ; GET NAME FIRST BYTE BACK     BMI     XXD56E          ; SKIP IF NOT STRING ARRAY     INY                    ; INCREMENT INDEX     LDA     (XX22),Y          ; GET # OF DIMENSIONS     LDY     #$00               ; CLEAR INDEX     ASL A                  ; *2     ADC     #$05               ; +5 (ARRAY HEADER SIZE)     ADC     XX22          ; ADD POINTER LOW BYTE     STA     XX22          ; SAVE POINTER LOW BYTE     BCC     XXD5AE          ; IF NO ROLLOVER SKIP THE HIGH BYTE INCREMENT     INC     XX23          ; ELSE INCREMENT POINTER HGIH BYTEXXD5AE = *     LDX     XX23          ; GET POINTER HIGH BYTEXXD5B0 = *     CPX     XX59          ; COMPARE POINTER HIGH BYTE WITH END OF THIS ARRAY HIGH BYTE     BNE     XXD5B8          ; BRANCH IF NOT THERE YET     CMP     XX58          ; COMPARE POINTER LOW BYTE WITH END OF THIS ARRAY LOW BYTE     BEQ     XXD572          ; IF AT END OF THIS ARRAY GO CHECK NEXT ARRAYXXD5B8 = *     JSR     XXD5C7          ; CHECK STRING SALVAGEABILITY     BEQ     XXD5B0          ; LOOP; CHECK VARIABLE SALVAGEABILITYXXD5BD = *     LDA     (XX22),Y          ; GET VARIABLE NAME FIRST BYTE     BMI     XXD5F6          ; ADD STEP AND EXIT IF NOT STRING     INY                    ; INCREMENT INDEX     LDA     (XX22),Y          ; GET VARIABLE NAME SECOND BYTE     BPL     XXD5F6          ; ADD STEP AND EXIT IF NOT STRING     INY                    ; INCREMENT INDEX; CHECK STRING SALVAGEABILITYXXD5C7 = *     LDA     (XX22),Y          ; GET STRING LENGTH     BEQ     XXD5F6          ; ADD STEP AND EXIT IF NULL STRING     INY                    ; INCREMENT INDEX     LDA     (XX22),Y          ; GET STRING POINTER LOW BYTE     TAX                    ; COPY TO X     INY                    ; INCREMENT INDEX     LDA     (XX22),Y          ; GET STRING POINTER HIGH BYTE     CMP     XX34          ; COMPARE STRING POINTER HIGH BYTE WITH BOTTOM OF STRING                         ; SPACE HIGH BYTE     BCC     XXD5DC          ; IF BOTTOM OF STRING SPACE GREATER GO TEST AGAINST HIGHEST                         ; UNCOLLECTED STRING     BNE     XXD5F6          ; IF BOTTOM OF STRING SPACE LESS STRING HAS BEEN COLLECTED                         ; SO GO UPDATE POINTERS, STEP TO NEXT AND RETURN                         ; HIGH BYTES WERE EQUAL SO TEST LOW BYTES     CPX     XX33          ; COMPARE STRING POINTER LOW BYTE WITH BOTTOM OF STRING                         ; SPACE LOW BYTE     BCS     XXD5F6          ; IF BOTTOM OF STRING SPACE LESS STRING HAS BEEN COLLECTED                         ; SO GO UPDATE POINTERS, STEP TO NEXT AND RETURN                         ; ELSE TEST STRING AGAINST HIGHEST UNCOLLECTED STRING SO FARXXD5DC = *     CMP     XX60          ; COMPARE STRING POINTER HIGH BYTE WITH HIGHEST UNCOLLECTED                         ; STRING HIGH BYTE     BCC     XXD5F6          ; IF HIGHEST UNCOLLECTED STRING IS GREATER THEN GO UPDATE                         ; POINTERS, STEP TO NEXT AND RETURN     BNE     XXD5E6          ; IF HIGHEST UNCOLLECTED STRING IS LESS THEN GO SET THIS                         ; STRING AS HIGHEST UNCOLLECTED SO FAR                         ; HIGH BYTES WERE EQUAL SO TEST LOW BYTES     CPX     XX5F          ; COMPARE STRING POINTER LOW BYTE WITH HIGHEST UNCOLLECTED                         ; STRING LOW BYTE     BCC     XXD5F6          ; IF HIGHEST UNCOLLECTED STRING IS GREATER THEN GO UPDATE                         ; POINTERS, STEP TO NEXT AND RETURN                         ; ELSE SET CURRENT STRING AS HIGHEST UNCOLLECTED STRINGXXD5E6 = *     STX     XX5F          ; SAVE STRING POINTER LOW BYTE AS HIGHEST UNCOLLECTED STRING                         ; LOW BYTE     STA     XX60          ; SAVE STRING POINTER HIGH BYTE AS HIGHEST UNCOLLECTED                         ; STRING HIGH BYTE     LDA     XX22          ; GET DESCRIPTOR POINTER LOW BYTE     LDX     XX23          ; GET DESCRIPTOR POINTER HIGH BYTE     STA     XX4E          ; SAVE WORKING POINTER HIGH BYTE     STX     XX4F          ; SAVE WORKING POINTER LOW BYTE     LDA     XX53          ; GET STEP SIZE     STA     XX55          ; COPY STEP SIZEXXD5F6 = *     LDA     XX53          ; GET STEP SIZE     CLC                    ; CLEAR CARRY FOR ADD     ADC     XX22          ; ADD POINTER LOW BYTE     STA     XX22          ; SAVE POINTER LOW BYTE     BCC     XXD601          ; IF NO ROLLOVER SKIP THE HIGH BYTE INCREMENT     INC     XX23          ; ELSE INCREMENT POINTER HIGH BYTEXXD601 = *     LDX     XX23          ; GET POINTER HIGH BYTE     LDY     #$00               ; FLAG NOT MOVED     RTS;***********************************************************************************;;; COLLECT STRINGXXD606 = *     LDA     XX4F          ; GET WORKING POINTER LOW BYTE     ORA     XX4E          ; OR WORKING POINTER HIGH BYTE     BEQ     XXD601          ; EXIT IF NOTHING TO COLLECT     LDA     XX55          ; GET COPIED STEP SIZE     AND     #$04               ; MASK STEP SIZE, $04 FOR VARIABLES, $00 FOR ARRAY OR STACK     LSR A                  ; >> 1     TAY                    ; COPY TO INDEX     STA     XX55          ; SAVE OFFSET TO DESCRIPTOR START     LDA     (XX4E),Y          ; GET STRING LENGTH LOW BYTE     ADC     XX5F          ; ADD STRING START LOW BYTE     STA     XX5A          ; SET BLOCK END LOW BYTE     LDA     XX60          ; GET STRING START HIGH BYTE     ADC     #$00               ; ADD CARRY     STA     XX5B          ; SET BLOCK END HIGH BYTE     LDA     XX33          ; GET BOTTOM OF STRING SPACE LOW BYTE     LDX     XX34          ; GET BOTTOM OF STRING SPACE HIGH BYTE     STA     XX58          ; SAVE DESTINATION END LOW BYTE     STX     XX59          ; SAVE DESTINATION END HIGH BYTE     JSR     XXC3BF          ; OPEN UP SPACE IN MEMORY, DON'T SET ARRAY END. THIS                         ; COPIES THE STRING FROM WHERE IT IS TO THE END OF THE                         ; UNCOLLECTED STRING MEMORY     LDY     XX55          ; RESTORE OFFSET TO DESCRIPTOR START     INY                    ; INCREMENT INDEX TO STRING POINTER LOW BYTE     LDA     XX58          ; GET NEW STRING POINTER LOW BYTE     STA     (XX4E),Y          ; SAVE NEW STRING POINTER LOW BYTE     TAX                    ; COPY STRING POINTER LOW BYTE     INC     XX59          ; INCREMENT NEW STRING POINTER HIGH BYTE     LDA     XX59          ; GET NEW STRING POINTER HIGH BYTE     INY                    ; INCREMENT INDEX TO STRING POINTER HIGH BYTE     STA     (XX4E),Y          ; SAVE NEW STRING POINTER HIGH BYTE     JMP     XXD52A          ; RE-RUN ROUTINE FROM LAST ENDING, XA HOLDS NEW BOTTOM                         ; OF STRING MEMORY POINTER;***********************************************************************************;;; CONCATENATE; ADD STRINGS, THE FIRST STRING IS IN THE DESCRIPTOR, THE SECOND STRING IS IN LINEXXD63D = *     LDA     XX65          ; GET DESCRIPTOR POINTER HIGH BYTE     PHA                    ; PUT ON STACK     LDA     XX64          ; GET DESCRIPTOR POINTER LOW BYTE     PHA                    ; PUT ON STACK     JSR     XXCE83          ; GET VALUE FROM LINE     JSR     XXCD8F          ; CHECK IF SOURCE IS STRING, ELSE DO TYPE MISMATCH     PLA                    ; GET DESCRIPTOR POINTER LOW BYTE BACK     STA     XX6F          ; SET POINTER LOW BYTE     PLA                    ; GET DESCRIPTOR POINTER HIGH BYTE BACK     STA     XX70          ; SET POINTER HIGH BYTE     LDY     #$00               ; CLEAR INDEX     LDA     (XX6F),Y          ; GET LENGTH OF FIRST STRING FROM DESCRIPTOR     CLC                    ; CLEAR CARRY FOR ADD     ADC     (XX64),Y          ; ADD LENGTH OF SECOND STRING     BCC     XXD65D          ; IF NO OVERFLOW CONTINUE     LDX     #$17               ; ELSE ERROR $17, STRING TOO LONG ERROR     JMP     XXC437          ; DO ERROR #X THEN WARM STARTXXD65D = *     JSR     XXD475          ; COPY DESCRIPTOR POINTER AND MAKE STRING SPACE A BYTES LONG     JSR     XXD67A          ; COPY STRING FROM DESCRIPTOR TO UTILITY POINTER     LDA     XX50          ; GET DESCRIPTOR POINTER LOW BYTE     LDY     XX51          ; GET DESCRIPTOR POINTER HIGH BYTE     JSR     XXD6AA          ; POP (YA) DESCRIPTOR OFF STACK OR FROM TOP OF STRING SPACE                         ; RETURNS WITH A = LENGTH, X = POINTER LOW BYTE,                         ; Y = POINTER HIGH BYTE     JSR     XXD68C          ; STORE STRING FROM POINTER TO UTILITY POINTER     LDA     XX6F          ; GET DESCRIPTOR POINTER LOW BYTE     LDY     XX70          ; GET DESCRIPTOR POINTER HIGH BYTE     JSR     XXD6AA          ; POP (YA) DESCRIPTOR OFF STACK OR FROM TOP OF STRING SPACE                         ; RETURNS WITH A = LENGTH, X = POINTER LOW BYTE,                         ; Y = POINTER HIGH BYTE     JSR     XXD4CA          ; CHECK SPACE ON DESCRIPTOR STACK THEN PUT STRING ADDRESS                         ; AND LENGTH ON DESCRIPTOR STACK AND UPDATE STACK POINTERS     JMP     XXCDB8          ; CONTINUE EVALUATION;***********************************************************************************;;; COPY STRING FROM DESCRIPTOR TO UTILITY POINTERXXD67A = *     LDY     #$00               ; CLEAR INDEX     LDA     (XX6F),Y          ; GET STRING LENGTH     PHA                    ; SAVE IT     INY                    ; INCREMENT INDEX     LDA     (XX6F),Y          ; GET STRING POINTER LOW BYTE     TAX                    ; COPY TO X     INY                    ; INCREMENT INDEX     LDA     (XX6F),Y          ; GET STRING POINTER HIGH BYTE     TAY                    ; COPY TO Y     PLA                    ; GET LENGTH BACKXXD688 = *     STX     XX22          ; SAVE STRING POINTER LOW BYTE     STY     XX23          ; SAVE STRING POINTER HIGH BYTE;***********************************************************************************;;; STORE STRING FROM POINTER TO UTILITY POINTERXXD68C = *     TAY                    ; COPY LENGTH AS INDEX     BEQ     XXD699          ; BRANCH IF NULL STRING     PHA                    ; SAVE LENGTHXXD690 = *     DEY                    ; DECREMENT LENGTH/INDEX     LDA     (XX22),Y          ; GET BYTE FROM STRING     STA     (XX35),Y          ; SAVE BYTE TO DESTINATION     TYA                    ; COPY LENGTH/INDEX     BNE     XXD690          ; LOOP IF NOT ALL DONE YET     PLA                    ; RESTORE LENGTHXXD699 = *     CLC                    ; CLEAR CARRY FOR ADD     ADC     XX35          ; ADD STRING UTILITY PTR LOW BYTE     STA     XX35          ; SAVE STRING UTILITY PTR LOW BYTE     BCC     XXD6A2          ; IF NO ROLLOVER SKIP THE HIGH BYTE INCREMENT     INC     XX36          ; INCREMENT STRING UTILITY PTR HIGH BYTEXXD6A2 = *     RTS;***********************************************************************************;;; EVALUATE STRINGXXD6A3 = *     JSR     XXCD8F          ; CHECK IF SOURCE IS STRING, ELSE DO TYPE MISMATCH; POP STRING OFF DESCRIPTOR STACK, OR FROM TOP OF STRING SPACE; RETURNS WITH A = LENGTH, X = POINTER LOW BYTE, Y = POINTER HIGH BYTEXXD6A6 = *     LDA     XX64          ; GET DESCRIPTOR POINTER LOW BYTE     LDY     XX65          ; GET DESCRIPTOR POINTER HIGH BYTE; POP (YA) DESCRIPTOR OFF STACK OR FROM TOP OF STRING SPACE; RETURNS WITH A = LENGTH, X = POINTER LOW BYTE, Y = POINTER HIGH BYTEXXD6AA = *     STA     XX22          ; SAVE STRING POINTER LOW BYTE     STY     XX23          ; SAVE STRING POINTER HIGH BYTE     JSR     XXD6DB          ; CLEAN DESCRIPTOR STACK, YA = POINTER     PHP                    ; SAVE STATUS FLAGS     LDY     #$00               ; CLEAR INDEX     LDA     (XX22),Y          ; GET LENGTH FROM STRING DESCRIPTOR     PHA                    ; PUT ON STACK     INY                    ; INCREMENT INDEX     LDA     (XX22),Y          ; GET STRING POINTER LOW BYTE FROM DESCRIPTOR     TAX                    ; COPY TO X     INY                    ; INCREMENT INDEX     LDA     (XX22),Y          ; GET STRING POINTER HIGH BYTE FROM DESCRIPTOR     TAY                    ; COPY TO Y     PLA                    ; GET STRING LENGTH BACK     PLP                    ; RESTORE STATUS     BNE     XXD6D6          ; BRANCH IF POINTER <> LAST_SL,LAST_SH     CPY     XX34          ; COMPARE WITH BOTTOM OF STRING SPACE HIGH BYTE     BNE     XXD6D6          ; BRANCH IF <>     CPX     XX33          ; ELSE COMPARE WITH BOTTOM OF STRING SPACE LOW BYTE     BNE     XXD6D6          ; BRANCH IF <>     PHA                    ; SAVE STRING LENGTH     CLC                    ; CLEAR CARRY FOR ADD     ADC     XX33          ; ADD BOTTOM OF STRING SPACE LOW BYTE     STA     XX33          ; SET BOTTOM OF STRING SPACE LOW BYTE     BCC     XXD6D5          ; SKIP INCREMENT IF NO OVERFLOW     INC     XX34          ; INCREMENT BOTTOM OF STRING SPACE HIGH BYTEXXD6D5 = *     PLA                    ; RESTORE STRING LENGTHXXD6D6 = *     STX     XX22          ; SAVE STRING POINTER LOW BYTE     STY     XX23          ; SAVE STRING POINTER HIGH BYTE     RTS;***********************************************************************************;;; CLEAN DESCRIPTOR STACK, YA = POINTER; CHECKS IF AY IS ON THE DESCRIPTOR STACK, IF SO DOES A STACK DISCARDXXD6DB = *     CPY     XX18          ; COMPARE HIGH BYTE WITH CURRENT DESCRIPTOR STACK ITEM                         ; POINTER HIGH BYTE     BNE     XXD6EB          ; EXIT IF <>     CMP     XX17          ; COMPARE LOW BYTE WITH CURRENT DESCRIPTOR STACK ITEM                         ; POINTER LOW BYTE     BNE     XXD6EB          ; EXIT IF <>     STA     XX16          ; SET DESCRIPTOR STACK POINTER     SBC     #$03               ; UPDATE LAST STRING POINTER LOW BYTE     STA     XX17          ; SAVE CURRENT DESCRIPTOR STACK ITEM POINTER LOW BYTE     LDY     #$00               ; CLEAR HIGH BYTEXXD6EB = *     RTS;***********************************************************************************;;; PERFORM CHR$()XXD6EC = *     JSR     XXD7A1          ; EVALUATE BYTE EXPRESSION, RESULT IN X     TXA                    ; COPY TO A     PHA                    ; SAVE CHARACTER     LDA     #$01               ; STRING IS SINGLE BYTE     JSR     XXD47D          ; MAKE STRING SPACE A BYTES LONG     PLA                    ; GET CHARACTER BACK     LDY     #$00               ; CLEAR INDEX     STA     (XX62),Y          ; SAVE BYTE IN STRING - BYTE IS STRING!     PLA                    ; DUMP RETURN ADDRESS (SKIP TYPE CHECK)     PLA                    ; DUMP RETURN ADDRESS (SKIP TYPE CHECK)     JMP     XXD4CA          ; CHECK SPACE ON DESCRIPTOR STACK THEN PUT STRING ADDRESS                         ; AND LENGTH ON DESCRIPTOR STACK AND UPDATE STACK POINTERS;***********************************************************************************;;; PERFORM LEFT$()XXD700 = *     JSR     XXD761          ; PULL STRING DATA AND BYTE PARAMETER FROM STACK                         ; RETURN POINTER IN DESCRIPTOR, BYTE IN A (AND X), Y=0     CMP     (XX50),Y          ; COMPARE BYTE PARAMETER WITH STRING LENGTH     TYA                    ; CLEAR AXXD706 = *     BCC     XXD70C          ; BRANCH IF STRING LENGTH > BYTE PARAMETER     LDA     (XX50),Y          ; ELSE MAKE PARAMETER = LENGTH     TAX                    ; COPY TO BYTE PARAMETER COPY     TYA                    ; CLEAR STRING START OFFSETXXD70C = *     PHA                    ; SAVE STRING START OFFSETXXD70D = *     TXA                    ; COPY BYTE PARAMETER (OR STRING LENGTH IF <)XXD70E = *     PHA                    ; SAVE STRING LENGTH     JSR     XXD47D          ; MAKE STRING SPACE A BYTES LONG     LDA     XX50          ; GET DESCRIPTOR POINTER LOW BYTE     LDY     XX51          ; GET DESCRIPTOR POINTER HIGH BYTE     JSR     XXD6AA          ; POP (YA) DESCRIPTOR OFF STACK OR FROM TOP OF STRING SPACE                         ; RETURNS WITH A = LENGTH, X = POINTER LOW BYTE,                         ; Y = POINTER HIGH BYTE     PLA                    ; GET STRING LENGTH BACK     TAY                    ; COPY LENGTH TO Y     PLA                    ; GET STRING START OFFSET BACK     CLC                    ; CLEAR CARRY FOR ADD     ADC     XX22          ; ADD START OFFSET TO STRING START POINTER LOW BYTE     STA     XX22          ; SAVE STRING START POINTER LOW BYTE     BCC     XXD725          ; IF NO OVERFLOW SKIP THE HIGH BYTE INCREMENT     INC     XX23          ; ELSE INCREMENT STRING START POINTER HIGH BYTEXXD725 = *     TYA                    ; COPY LENGTH TO A     JSR     XXD68C          ; STORE STRING FROM POINTER TO UTILITY POINTER     JMP     XXD4CA          ; CHECK SPACE ON DESCRIPTOR STACK THEN PUT STRING ADDRESS                         ; AND LENGTH ON DESCRIPTOR STACK AND UPDATE STACK POINTERS;***********************************************************************************;;; PERFORM RIGHT$()XXD72C = *     JSR     XXD761          ; PULL STRING DATA AND BYTE PARAMETER FROM STACK                         ; RETURN POINTER IN DESCRIPTOR, BYTE IN A (AND X), Y=0     CLC                    ; CLEAR CARRY FOR ADD-1     SBC     (XX50),Y          ; SUBTRACT STRING LENGTH     EOR     #$FF               ; INVERT IT (A=LEN(EXPRESSION$)-L)     JMP     XXD706          ; GO DO REST OF LEFT$();***********************************************************************************;;; PERFORM MID$()XXD737 = *     LDA     #$FF               ; SET DEFAULT LENGTH = 255     STA     XX65          ; SAVE DEFAULT LENGTH     JSR     XX0079          ; SCAN MEMORY     CMP     #$29               ; COMPARE WITH ')'     BEQ     XXD748          ; BRANCH IF = ')' (SKIP SECOND BYTE GET)     JSR     XXCEFD          ; SCAN FOR ',', ELSE DO SYNTAX ERROR THEN WARM START     JSR     XXD79E          ; GET BYTE PARAMETER XXD748 = *     JSR     XXD761          ; PULL STRING DATA AND BYTE PARAMETER FROM STACK                         ; RETURN POINTER IN DESCRIPTOR, BYTE IN A (AND X), Y=0     BEQ     XXD798          ; IF NULL DO ILLEGAL QUANTITY ERROR THEN WARM START     DEX                    ; DECREMENT START INDEX     TXA                    ; COPY TO A     PHA                    ; SAVE STRING START OFFSET     CLC                    ; CLEAR CARRY FOR SUB-1     LDX     #$00               ; CLEAR OUTPUT STRING LENGTH     SBC     (XX50),Y          ; SUBTRACT STRING LENGTH     BCS     XXD70D          ; IF START>STRING LENGTH GO DO NULL STRING     EOR     #$FF               ; COMPLEMENT -LENGTH     CMP     XX65          ; COMPARE BYTE PARAMETER     BCC     XXD70E          ; IF LENGTH>REMAINING STRING GO DO RIGHT$     LDA     XX65          ; GET LENGTH BYTE     BCS     XXD70E          ; GO DO STRING COPY, BRANCH ALWAYS;***********************************************************************************;;; PULL STRING DATA AND BYTE PARAMETER FROM STACK; RETURN POINTER IN DESCRIPTOR, BYTE IN A (AND X), Y=0XXD761 = *     JSR     XXCEF7          ; SCAN FOR ')', ELSE DO SYNTAX ERROR THEN WARM START     PLA                    ; PULL RETURN ADDRESS LOW BYTE     TAY                    ; SAVE RETURN ADDRESS LOW BYTE     PLA                    ; PULL RETURN ADDRESS HIGH BYTE     STA     XX55          ; SAVE RETURN ADDRESS HIGH BYTE     PLA                    ; DUMP CALL TO FUNCTION VECTOR LOW BYTE     PLA                    ; DUMP CALL TO FUNCTION VECTOR HIGH BYTE     PLA                    ; PULL BYTE PARAMETER     TAX                    ; COPY BYTE PARAMETER TO X     PLA                    ; PULL STRING POINTER LOW BYTE     STA     XX50          ; SAVE IT     PLA                    ; PULL STRING POINTER HIGH BYTE     STA     XX51          ; SAVE IT     LDA     XX55          ; GET RETURN ADDRESS HIGH BYTE     PHA                    ; BACK ON STACK     TYA                    ; GET RETURN ADDRESS LOW BYTE     PHA                    ; BACK ON STACK     LDY     #$00               ; CLEAR INDEX     TXA                    ; COPY BYTE PARAMETER     RTS;***********************************************************************************;;; PERFORM LEN()XXD77C = *     JSR     XXD782          ; EVALUATE STRING, GET LENGTH IN A (AND Y)     JMP     XXD3A2          ; CONVERT Y TO BYTE IN FAC1 AND RETURN;***********************************************************************************;;; EVALUATE STRING, GET LENGTH IN YXXD782 = *     JSR     XXD6A3          ; EVALUATE STRING     LDX     #$00               ; SET DATA TYPE = NUMERIC     STX     XX0D          ; CLEAR DATA TYPE FLAG, $FF = STRING, $00 = NUMERIC     TAY                    ; COPY LENGTH TO Y     RTS;***********************************************************************************;;; PERFORM ASC()XXD78B = *     JSR     XXD782          ; EVALUATE STRING, GET LENGTH IN A (AND Y)     BEQ     XXD798          ; IF NULL DO ILLEGAL QUANTITY ERROR THEN WARM START     LDY     #$00               ; SET INDEX TO FIRST CHARACTER     LDA     (XX22),Y          ; GET BYTE     TAY                    ; COPY TO Y     JMP     XXD3A2          ; CONVERT Y TO BYTE IN FAC1 AND RETURN;***********************************************************************************;;; DO ILLEGAL QUANTITY ERROR THEN WARM STARTXXD798 = *     JMP     XXD248          ; DO ILLEGAL QUANTITY ERROR THEN WARM START;***********************************************************************************;;; SCAN AND GET BYTE PARAMETERXXD79B = *     JSR     XX0073          ; INCREMENT AND SCAN MEMORY; GET BYTE PARAMETERXXD79E = *     JSR     XXCD8A          ; EVALUATE EXPRESSION AND CHECK IS NUMERIC, ELSE DO                         ; TYPE MISMATCH; EVALUATE BYTE EXPRESSION, RESULT IN XXXD7A1 = *     JSR     XXD1B8          ; EVALUATE INTEGER EXPRESSION, SIGN CHECK     LDX     XX64          ; GET FAC1 MANTISSA 3     BNE     XXD798          ; IF NOT NULL DO ILLEGAL QUANTITY ERROR THEN WARM START     LDX     XX65          ; GET FAC1 MANTISSA 4     JMP     XX0079          ; SCAN MEMORY AND RETURN;***********************************************************************************;;; PERFORM VAL()XXD7AD = *     JSR     XXD782          ; EVALUATE STRING, GET LENGTH IN A (AND Y)     BNE     XXD7B5          ; IF NOT A NULL STRING GO EVALUATE IT                         ; STRING WAS NULL SO SET RESULT = $00     JMP     XXD8F7          ; CLEAR FAC1 EXPONENT AND SIGN AND RETURNXXD7B5 = *     LDX     XX7A          ; GET BASIC EXECUTE POINTER LOW BYTE     LDY     XX7B          ; GET BASIC EXECUTE POINTER HIGH BYTE     STX     XX71          ; SAVE BASIC EXECUTE POINTER LOW BYTE     STY     XX72          ; SAVE BASIC EXECUTE POINTER HIGH BYTE     LDX     XX22          ; GET STRING POINTER LOW BYTE     STX     XX7A          ; SAVE BASIC EXECUTE POINTER LOW BYTE     CLC                    ; CLEAR CARRY FOR ADD     ADC     XX22          ; ADD STRING LENGTH     STA     XX24          ; SAVE STRING END LOW BYTE     LDX     XX23          ; GET STRING POINTER HIGH BYTE     STX     XX7B          ; SAVE BASIC EXECUTE POINTER HIGH BYTE     BCC     XXD7CD          ; IF NO ROLLOVER SKIP THE HIGH BYTE INCREMENT     INX                    ; INCREMENT STRING END HIGH BYTEXXD7CD = *     STX     XX25          ; SAVE STRING END HIGH BYTE     LDY     #$00               ; SET INDEX TO $00     LDA     (XX24),Y          ; GET STRING END BYTE     PHA                    ; PUSH IT     TYA                    ; CLEAR A     STA     (XX24),Y          ; TERMINATE STRING WITH $00     JSR     XX0079          ; SCAN MEMORY     JSR     XXDCF3          ; GET FAC1 FROM STRING     PLA                    ; RESTORE STRING END BYTE     LDY     #$00               ; CLEAR INDEX     STA     (XX24),Y          ; PUT STRING END BYTE BACK; RESTORE BASIC EXECUTE POINTER FROM TEMPXXD7E2 = *     LDX     XX71          ; GET BASIC EXECUTE POINTER LOW BYTE BACK     LDY     XX72          ; GET BASIC EXECUTE POINTER HIGH BYTE BACK     STX     XX7A          ; SAVE BASIC EXECUTE POINTER LOW BYTE     STY     XX7B          ; SAVE BASIC EXECUTE POINTER HIGH BYTE     RTS;***********************************************************************************;;; GET PARAMETERS FOR POKE/WAITXXD7EB = *     JSR     XXCD8A          ; EVALUATE EXPRESSION AND CHECK IS NUMERIC, ELSE DO                         ; TYPE MISMATCH     JSR     XXD7F7          ; CONVERT FAC_1 TO INTEGER IN TEMPORARY INTEGERXXD7F1 = *     JSR     XXCEFD          ; SCAN FOR ',', ELSE DO SYNTAX ERROR THEN WARM START     JMP     XXD79E          ; GET BYTE PARAMETER AND RETURN;***********************************************************************************;;; CONVERT FAC_1 TO INTEGER IN TEMPORARY INTEGERXXD7F7 = *     LDA     XX66          ; GET FAC1 SIGN     BMI     XXD798          ; IF -VE DO ILLEGAL QUANTITY ERROR THEN WARM START     LDA     XX61          ; GET FAC1 EXPONENT     CMP     #$91               ; COMPARE WITH EXPONENT = 2^16     BCS     XXD798          ; IF >= DO ILLEGAL QUANTITY ERROR THEN WARM START     JSR     XXDC9B          ; CONVERT FAC1 FLOATING TO FIXED     LDA     XX64          ; GET FAC1 MANTISSA 3     LDY     XX65          ; GET FAC1 MANTISSA 4     STY     XX14          ; SAVE TEMPORARY INTEGER LOW BYTE     STA     XX15          ; SAVE TEMPORARY INTEGER HIGH BYTE     RTS;***********************************************************************************;;; PERFORM PEEK()XXD80D = *     LDA     XX15          ; GET LINE NUMBER HIGH BYTE     PHA                    ; SAVE LINE NUMBER HIGH BYTE     LDA     XX14          ; GET LINE NUMBER LOW BYTE     PHA                    ; SAVE LINE NUMBER LOW BYTE     JSR     XXD7F7          ; CONVERT FAC_1 TO INTEGER IN TEMPORARY INTEGER     LDY     #$00               ; CLEAR INDEX     LDA     (XX14),Y          ; READ BYTE     TAY                    ; COPY BYTE TO A     PLA                    ; PULL BYTE     STA     XX14          ; RESTORE LINE NUMBER LOW BYTE     PLA                    ; PULL BYTE     STA     XX15          ; RESTORE LINE NUMBER HIGH BYTE     JMP     XXD3A2          ; CONVERT Y TO BYTE IN FAC_1 AND RETURN;***********************************************************************************;;; PERFORM POKEXXD824 = *     JSR     XXD7EB          ; GET PARAMETERS FOR POKE/WAIT     TXA                    ; COPY BYTE TO A     LDY     #$00               ; CLEAR INDEX     STA     (XX14),Y          ; WRITE BYTE     RTS;***********************************************************************************;;; PERFORM WAITXXD82D = *     JSR     XXD7EB          ; GET PARAMETERS FOR POKE/WAIT     STX     XX49          ; SAVE BYTE     LDX     #$00               ; CLEAR MASK     JSR     XX0079          ; SCAN MEMORY     BEQ     XXD83C          ; SKIP IF NO THIRD ARGUMENT     JSR     XXD7F1          ; SCAN FOR ',' AND GET BYTE, ELSE SYNTAX ERROR THEN                         ; WARM STARTXXD83C = *     STX     XX4A          ; SAVE EOR ARGUMENT     LDY     #$00               ; CLEAR INDEXXXD840 = *     LDA     (XX14),Y          ; GET BYTE VIA TEMPORARY INTEGER     (ADDRESS)     EOR     XX4A          ; EOR WITH SECOND ARGUMENT          (MASK)     AND     XX49          ; AND WITH FIRST ARGUMENT          (BYTE)     BEQ     XXD840          ; LOOP IF RESULT IS ZEROXXD848 = *     RTS;***********************************************************************************;;; ADD 0.5 TO FAC1 (ROUND FAC1)XXD849 = *     LDA     #<XXDF11          ; SET 0.5 POINTER LOW BYTE     LDY     #>XXDF11          ; SET 0.5 POINTER HIGH BYTE     JMP     XXD867          ; ADD (AY) TO FAC1;***********************************************************************************;;; PERFORM SUBTRACTION, FAC1 FROM (AY)XXD850 = *     JSR     XXDA8C          ; UNPACK MEMORY (AY) INTO FAC2; PERFORM SUBTRACTION, FAC1 FROM FAC2XXD853 = *     LDA     XX66          ; GET FAC1 SIGN (B7)     EOR     #$FF               ; COMPLEMENT IT     STA     XX66          ; SAVE FAC1 SIGN (B7)     EOR     XX6E          ; EOR WITH FAC2 SIGN (B7)     STA     XX6F          ; SAVE SIGN COMPARE (FAC1 EOR FAC2)     LDA     XX61          ; GET FAC1 EXPONENT     JMP     XXD86A          ; ADD FAC2 TO FAC1 AND RETURNXXD862 = *     JSR     XXD999          ; SHIFT FACX A TIMES RIGHT (>8 SHIFTS)     BCC     XXD8A3          ; GO SUBTRACT THE MANTISSAS, BRANCH ALWAYS;***********************************************************************************;;; ADD (AY) TO FAC1XXD867 = *     JSR     XXDA8C          ; UNPACK MEMORY (AY) INTO FAC2; ADD FAC2 TO FAC1XXD86A = *     BNE     XXD86F          ; IF FAC1 IS NOT ZERO GO DO THE ADD     JMP     XXDBFC          ; FAC1 WAS ZERO SO COPY FAC2 TO FAC1 AND RETURN                         ; FAC1 IS NON ZEROXXD86F = *     LDX     XX70          ; GET FAC1 ROUNDING BYTE     STX     XX56          ; SAVE AS FAC2 ROUNDING BYTE     LDX     #XX69          ; SET INDEX TO FAC2 EXPONENT ADDRESS     LDA     XX69          ; GET FAC2 EXPONENTXXD877 = *     TAY                    ; COPY EXPONENT     BEQ     XXD848          ; EXIT IF ZERO     SEC                    ; SET CARRY FOR SUBTRACT     SBC     XX61          ; SUBTRACT FAC1 EXPONENT     BEQ     XXD8A3          ; IF EQUAL GO ADD MANTISSAS     BCC     XXD893          ; IF FAC2 < FAC1 THEN GO SHIFT FAC2 RIGHT                         ; ELSE FAC2 > FAC1     STY     XX61          ; SAVE FAC1 EXPONENT     LDY     XX6E          ; GET FAC2 SIGN (B7)     STY     XX66          ; SAVE FAC1 SIGN (B7)     EOR     #$FF               ; COMPLEMENT A     ADC     #$00               ; +1, TWOS COMPLEMENT, CARRY IS SET     LDY     #$00               ; CLEAR Y     STY     XX56          ; CLEAR FAC2 ROUNDING BYTE     LDX     #XX61          ; SET INDEX TO FAC1 EXPONENT ADDRESS     BNE     XXD897          ; BRANCH ALWAYS                         ; FAC2 < FAC1XXD893 = *     LDY     #$00               ; CLEAR Y     STY     XX70          ; CLEAR FAC1 ROUNDING BYTEXXD897 = *     CMP     #$F9               ; COMPARE EXPONENT DIFF WITH $F9     BMI     XXD862          ; BRANCH IF RANGE $79-$F8     TAY                    ; COPY EXPONENT DIFFERENCE TO Y     LDA     XX70          ; GET FAC1 ROUNDING BYTE     LSR     XX01,X          ; SHIFT FAC? MANTISSA 1     JSR     XXD9B0          ; SHIFT FACX Y TIMES RIGHT                         ; EXPONENTS ARE EQUAL NOW DO MANTISSA SUBTRACTXXD8A3 = *     BIT     XX6F          ; TEST SIGN COMPARE (FAC1 EOR FAC2)     BPL     XXD8FE          ; IF = ADD FAC2 MANTISSA TO FAC1 MANTISSA AND RETURN     LDY     #XX61          ; SET INDEX TO FAC1 EXPONENT ADDRESS     CPX     #XX69          ; COMPARE X TO FAC2 EXPONENT ADDRESS     BEQ     XXD8AF          ; BRANCH IF =     LDY     #XX69          ; ELSE SET INDEX TO FAC2 EXPONENT ADDRESS                         ; SUBTRACT SMALLER FROM BIGGER (TAKE SIGN OF BIGGER)XXD8AF = *     SEC                    ; SET CARRY FOR SUBTRACT     EOR     #$FF               ; ONES COMPLEMENT A     ADC     XX56          ; ADD FAC2 ROUNDING BYTE     STA     XX70          ; SAVE FAC1 ROUNDING BYTE     LDA     XX04,Y          ; GET FACY MANTISSA 4     SBC     XX04,X          ; SUBTRACT FACX MANTISSA 4     STA     XX65          ; SAVE FAC1 MANTISSA 4     LDA     XX03,Y          ; GET FACY MANTISSA 3     SBC     XX03,X          ; SUBTRACT FACX MANTISSA 3     STA     XX64          ; SAVE FAC1 MANTISSA 3     LDA     XX02,Y          ; GET FACY MANTISSA 2     SBC     XX02,X          ; SUBTRACT FACX MANTISSA 2     STA     XX63          ; SAVE FAC1 MANTISSA 2     LDA     XX01,Y          ; GET FACY MANTISSA 1     SBC     XX01,X          ; SUBTRACT FACX MANTISSA 1     STA     XX62          ; SAVE FAC1 MANTISSA 1;***********************************************************************************;;; DO ABS AND NORMALISE FAC1XXD8D2 = *     BCS     XXD8D7          ; BRANCH IF NUMBER IS +VE     JSR     XXD947          ; NEGATE FAC1; NORMALISE FAC1XXD8D7 = *     LDY     #$00               ; CLEAR Y     TYA                    ; CLEAR A     CLC                    ; CLEAR CARRY FOR ADDXXD8DB = *     LDX     XX62          ; GET FAC1 MANTISSA 1     BNE     XXD929          ; IF NOT ZERO NORMALISE FAC1     LDX     XX63          ; GET FAC1 MANTISSA 2     STX     XX62          ; SAVE FAC1 MANTISSA 1     LDX     XX64          ; GET FAC1 MANTISSA 3     STX     XX63          ; SAVE FAC1 MANTISSA 2     LDX     XX65          ; GET FAC1 MANTISSA 4     STX     XX64          ; SAVE FAC1 MANTISSA 3     LDX     XX70          ; GET FAC1 ROUNDING BYTE     STX     XX65          ; SAVE FAC1 MANTISSA 4     STY     XX70          ; CLEAR FAC1 ROUNDING BYTE     ADC     #$08               ; ADD X TO EXPONENT OFFSET     CMP     #$20               ; COMPARE WITH $20, MAX OFFSET, ALL BITS WOULD BE = 0     BNE     XXD8DB          ; LOOP IF NOT MAX;***********************************************************************************;;; CLEAR FAC1 EXPONENT AND SIGNXXD8F7 = *     LDA     #$00               ; CLEAR AXXD8F9 = *     STA     XX61          ; SET FAC1 EXPONENT; SAVE FAC1 SIGNXXD8FB = *     STA     XX66          ; SAVE FAC1 SIGN (B7)     RTS;***********************************************************************************;;; ADD FAC2 MANTISSA TO FAC1 MANTISSAXXD8FE = *     ADC     XX56          ; ADD FAC2 ROUNDING BYTE     STA     XX70          ; SAVE FAC1 ROUNDING BYTE     LDA     XX65          ; GET FAC1 MANTISSA 4     ADC     XX6D          ; ADD FAC2 MANTISSA 4     STA     XX65          ; SAVE FAC1 MANTISSA 4     LDA     XX64          ; GET FAC1 MANTISSA 3     ADC     XX6C          ; ADD FAC2 MANTISSA 3     STA     XX64          ; SAVE FAC1 MANTISSA 3     LDA     XX63          ; GET FAC1 MANTISSA 2     ADC     XX6B          ; ADD FAC2 MANTISSA 2     STA     XX63          ; SAVE FAC1 MANTISSA 2     LDA     XX62          ; GET FAC1 MANTISSA 1     ADC     XX6A          ; ADD FAC2 MANTISSA 1     STA     XX62          ; SAVE FAC1 MANTISSA 1     JMP     XXD936          ; TEST AND NORMALISE FAC1 FOR C=0/1XXD91D = *     ADC     #$01               ; ADD 1 TO EXPONENT OFFSET     ASL     XX70          ; SHIFT FAC1 ROUNDING BYTE     ROL     XX65          ; SHIFT FAC1 MANTISSA 4     ROL     XX64          ; SHIFT FAC1 MANTISSA 3     ROL     XX63          ; SHIFT FAC1 MANTISSA 2     ROL     XX62          ; SHIFT FAC1 MANTISSA 1;***********************************************************************************;;; NORMALISE FAC1XXD929 = *     BPL     XXD91D          ; LOOP IF NOT NORMALISED     SEC                    ; SET CARRY FOR SUBTRACT     SBC     XX61          ; SUBTRACT FAC1 EXPONENT     BCS     XXD8F7          ; BRANCH IF UNDERFLOW (SET RESULT = $0)     EOR     #$FF               ; COMPLEMENT EXPONENT     ADC     #$01               ; +1 (TWOS COMPLEMENT)     STA     XX61          ; SAVE FAC1 EXPONENT; TEST AND NORMALISE FAC1 FOR C=0/1XXD936 = *     BCC     XXD946          ; EXIT IF NO OVERFLOW; NORMALISE FAC1 FOR C=1XXD938 = *     INC     XX61          ; INCREMENT FAC1 EXPONENT     BEQ     XXD97E          ; IF ZERO DO OVERFLOW ERROR THEN WARM START     ROR     XX62          ; SHIFT FAC1 MANTISSA 1     ROR     XX63          ; SHIFT FAC1 MANTISSA 2     ROR     XX64          ; SHIFT FAC1 MANTISSA 3     ROR     XX65          ; SHIFT FAC1 MANTISSA 4     ROR     XX70          ; SHIFT FAC1 ROUNDING BYTEXXD946 = *     RTS;***********************************************************************************;;; NEGATE FAC1XXD947 = *     LDA     XX66          ; GET FAC1 SIGN (B7)     EOR     #$FF               ; COMPLEMENT IT     STA     XX66          ; SAVE FAC1 SIGN (B7); TWOS COMPLEMENT FAC1 MANTISSAXXD94D = *     LDA     XX62          ; GET FAC1 MANTISSA 1     EOR     #$FF               ; COMPLEMENT IT     STA     XX62          ; SAVE FAC1 MANTISSA 1     LDA     XX63          ; GET FAC1 MANTISSA 2     EOR     #$FF               ; COMPLEMENT IT     STA     XX63          ; SAVE FAC1 MANTISSA 2     LDA     XX64          ; GET FAC1 MANTISSA 3     EOR     #$FF               ; COMPLEMENT IT     STA     XX64          ; SAVE FAC1 MANTISSA 3     LDA     XX65          ; GET FAC1 MANTISSA 4     EOR     #$FF               ; COMPLEMENT IT     STA     XX65          ; SAVE FAC1 MANTISSA 4     LDA     XX70          ; GET FAC1 ROUNDING BYTE     EOR     #$FF               ; COMPLEMENT IT     STA     XX70          ; SAVE FAC1 ROUNDING BYTE     INC     XX70          ; INCREMENT FAC1 ROUNDING BYTE     BNE     XXD97D          ; EXIT IF NO OVERFLOW; INCREMENT FAC1 MANTISSAXXD96F = *     INC     XX65          ; INCREMENT FAC1 MANTISSA 4     BNE     XXD97D          ; FINISHED IF NO ROLLOVER     INC     XX64          ; INCREMENT FAC1 MANTISSA 3     BNE     XXD97D          ; FINISHED IF NO ROLLOVER     INC     XX63          ; INCREMENT FAC1 MANTISSA 2     BNE     XXD97D          ; FINISHED IF NO ROLLOVER     INC     XX62          ; INCREMENT FAC1 MANTISSA 1XXD97D = *     RTS;***********************************************************************************;;; DO OVERFLOW ERROR THEN WARM STARTXXD97E = *     LDX     #$0F               ; ERROR $0F, OVERFLOW ERROR     JMP     XXC437          ; DO ERROR #X THEN WARM START;***********************************************************************************;;; SHIFT FCATEMP << A+8 TIMESXXD983 = *     LDX     #$25               ; SET OFFSET TO FACTEMPXXD985 = *     LDY     XX04,X          ; GET FACX MANTISSA 4     STY     XX70          ; SAVE AS FAC1 ROUNDING BYTE     LDY     XX03,X          ; GET FACX MANTISSA 3     STY     XX04,X          ; SAVE FACX MANTISSA 4     LDY     XX02,X          ; GET FACX MANTISSA 2     STY     XX03,X          ; SAVE FACX MANTISSA 3     LDY     XX01,X          ; GET FACX MANTISSA 1     STY     XX02,X          ; SAVE FACX MANTISSA 2     LDY     XX68          ; GET FAC1 OVERFLOW BYTE     STY     XX01,X          ; SAVE FACX MANTISSA 1; SHIFT FACX -A TIMES RIGHT (> 8 SHIFTS)XXD999 = *     ADC     #$08               ; ADD 8 TO SHIFT COUNT     BMI     XXD985          ; GO DO 8 SHIFT IF STILL -VE     BEQ     XXD985          ; GO DO 8 SHIFT IF ZERO     SBC     #$08               ; ELSE SUBTRACT 8 AGAIN     TAY                    ; SAVE COUNT TO Y     LDA     XX70          ; GET FAC1 ROUNDING BYTE     BCS     XXD9BA          ;.XXD9A6 = *     ASL     XX01,X          ; SHIFT FACX MANTISSA 1     BCC     XXD9AC          ; BRANCH IF +VE     INC     XX01,X          ; THIS SETS B7 EVENTUALLYXXD9AC = *     ROR     XX01,X          ; SHIFT FACX MANTISSA 1 (CORRECT FOR ASL)     ROR     XX01,X          ; SHIFT FACX MANTISSA 1 (PUT CARRY IN B7); SHIFT FACX Y TIMES RIGHTXXD9B0 = *     ROR     XX02,X          ; SHIFT FACX MANTISSA 2     ROR     XX03,X          ; SHIFT FACX MANTISSA 3     ROR     XX04,X          ; SHIFT FACX MANTISSA 4     ROR A                  ; SHIFT FACX ROUNDING BYTE     INY                    ; INCREMENT EXPONENT DIFF     BNE     XXD9A6          ; BRANCH IF RANGE ADJUST NOT COMPLETEXXD9BA = *     CLC                    ; JUST CLEAR IT     RTS;***********************************************************************************;;; CONSTANTS AND SERIES FOR LOG(N)XXD9BC = *     .BYTE     $81,$00,$00,$00,$00     ; 1XXD9C1 = *     .BYTE     $03                    ; SERIES COUNTER     .BYTE     $7F,$5E,$56,$CB,$79     .BYTE     $80,$13,$9B,$0B,$64     .BYTE     $80,$76,$38,$93,$16     .BYTE     $82,$38,$AA,$3B,$20XXD9D6 = *     .BYTE     $80,$35,$04,$F3,$34     ; 0.70711     1/ROOT 2XXD9DB = *     .BYTE     $81,$35,$04,$F3,$34     ; 1.41421     ROOT 2XXD9E0 = *     .BYTE     $80,$80,$00,$00,$00     ; -0.5     1/2XXD9E5 = *     .BYTE     $80,$31,$72,$17,$F8     ; 0.69315     LOG(2);***********************************************************************************;;; PERFORM LOG()XXD9EA = *     JSR     XXDC2B          ; TEST SIGN AND ZERO     BEQ     XXD9F1          ; IF ZERO DO ILLEGAL QUANTITY ERROR THEN WARM START     BPL     XXD9F4          ; SKIP ERROR IF +VEXXD9F1 = *     JMP     XXD248          ; DO ILLEGAL QUANTITY ERROR THEN WARM STARTXXD9F4 = *     LDA     XX61          ; GET FAC1 EXPONENT     SBC     #$7F               ; NORMALISE IT     PHA                    ; SAVE IT     LDA     #$80               ; SET EXPONENT TO ZERO     STA     XX61          ; SAVE FAC1 EXPONENT     LDA     #<XXD9D6          ; POINTER TO 1/ROOT 2 LOW BYTE     LDY     #>XXD9D6          ; POINTER TO 1/ROOT 2 HIGH BYTE     JSR     XXD867          ; ADD (AY) TO FAC1 (1/ROOT2)     LDA     #<XXD9DB          ; POINTER TO ROOT 2 LOW BYTE     LDY     #>XXD9DB          ; POINTER TO ROOT 2 HIGH BYTE     JSR     XXDB0F          ; CONVERT AY AND DO (AY)/FAC1 (ROOT2/(X+(1/ROOT2)))     LDA     #<XXD9BC          ; POINTER TO 1 LOW BYTE     LDY     #>XXD9BC          ; POINTER TO 1 HIGH BYTE     JSR     XXD850          ; SUBTRACT FAC1 ((ROOT2/(X+(1/ROOT2)))-1) FROM (AY)     LDA     #<XXD9C1          ; POINTER TO SERIES FOR LOG(N) LOW BYTE     LDY     #>XXD9C1          ; POINTER TO SERIES FOR LOG(N) HIGH BYTE     JSR     XXE040          ; ^2 THEN SERIES EVALUATION     LDA     #<XXD9E0          ; POINTER TO -0.5 LOW BYTE     LDY     #>XXD9E0          ; POINTER TO -0.5 HIGH BYTE     JSR     XXD867          ; ADD (AY) TO FAC1     PLA                    ; RESTORE FAC1 EXPONENT     JSR     XXDD7E          ; EVALUATE NEW ASCII DIGIT     LDA     #<XXD9E5          ; POINTER TO LOG(2) LOW BYTE     LDY     #>XXD9E5          ; POINTER TO LOG(2) HIGH BYTE; DO CONVERT AY, FCA1*(AY)XXDA28 = *     JSR     XXDA8C          ; UNPACK MEMORY (AY) INTO FAC2XXDA2B = *     BNE     XXDA30          ; MULTIPLY FAC1 BY FAC2 ??     JMP     XXDA8B          ; EXIT IF ZEROXXDA30 = *     JSR     XXDAB7          ; TEST AND ADJUST ACCUMULATORS     LDA     #$00               ; CLEAR A     STA     XX26          ; CLEAR TEMP MANTISSA 1     STA     XX27          ; CLEAR TEMP MANTISSA 2     STA     XX28          ; CLEAR TEMP MANTISSA 3     STA     XX29          ; CLEAR TEMP MANTISSA 4     LDA     XX70          ; GET FAC1 ROUNDING BYTE     JSR     XXDA59          ; GO DO SHIFT/ADD FAC2     LDA     XX65          ; GET FAC1 MANTISSA 4     JSR     XXDA59          ; GO DO SHIFT/ADD FAC2     LDA     XX64          ; GET FAC1 MANTISSA 3     JSR     XXDA59          ; GO DO SHIFT/ADD FAC2     LDA     XX63          ; GET FAC1 MANTISSA 2     JSR     XXDA59          ; GO DO SHIFT/ADD FAC2     LDA     XX62          ; GET FAC1 MANTISSA 1     JSR     XXDA5E          ; GO DO SHIFT/ADD FAC2     JMP     XXDB8F          ; COPY TEMP TO FAC1, NORMALISE AND RETURNXXDA59 = *     BNE     XXDA5E          ; BRANCH IF BYTE <> ZERO     JMP     XXD983          ; SHIFT FCATEMP << A+8 TIMES                         ; ELSE DO SHIFT AND ADDXXDA5E = *     LSR A                  ; SHIFT BYTE     ORA     #$80               ; SET TOP BIT (MARK FOR 8 TIMES)XXDA61 = *     TAY                    ; COPY RESULT     BCC     XXDA7D          ; SKIP NEXT IF BIT WAS ZERO     CLC                    ; CLEAR CARRY FOR ADD     LDA     XX29          ; GET TEMP MANTISSA 4     ADC     XX6D          ; ADD FAC2 MANTISSA 4     STA     XX29          ; SAVE TEMP MANTISSA 4     LDA     XX28          ; GET TEMP MANTISSA 3     ADC     XX6C          ; ADD FAC2 MANTISSA 3     STA     XX28          ; SAVE TEMP MANTISSA 3     LDA     XX27          ; GET TEMP MANTISSA 2     ADC     XX6B          ; ADD FAC2 MANTISSA 2     STA     XX27          ; SAVE TEMP MANTISSA 2     LDA     XX26          ; GET TEMP MANTISSA 1     ADC     XX6A          ; ADD FAC2 MANTISSA 1     STA     XX26          ; SAVE TEMP MANTISSA 1XXDA7D = *     ROR     XX26          ; SHIFT TEMP MANTISSA 1     ROR     XX27          ; SHIFT TEMP MANTISSA 2     ROR     XX28          ; SHIFT TEMP MANTISSA 3     ROR     XX29          ; SHIFT TEMP MANTISSA 4     ROR     XX70          ; SHIFT TEMP ROUNDING BYTE     TYA                    ; GET BYTE BACK     LSR A                  ; SHIFT BYTE     BNE     XXDA61          ; LOOP IF ALL BITS NOT DONEXXDA8B = *     RTS;***********************************************************************************;;; UNPACK MEMORY (AY) INTO FAC2XXDA8C = *     STA     XX22          ; SAVE POINTER LOW BYTE     STY     XX23          ; SAVE POINTER HIGH BYTE     LDY     #$04               ; 5 BYTES TO GET (0-4)     LDA     (XX22),Y          ; GET MANTISSA 4     STA     XX6D          ; SAVE FAC2 MANTISSA 4     DEY                    ; DECREMENT INDEX     LDA     (XX22),Y          ; GET MANTISSA 3     STA     XX6C          ; SAVE FAC2 MANTISSA 3     DEY                    ; DECREMENT INDEX     LDA     (XX22),Y          ; GET MANTISSA 2     STA     XX6B          ; SAVE FAC2 MANTISSA 2     DEY                    ; DECREMENT INDEX     LDA     (XX22),Y          ; GET MANTISSA 1 + SIGN     STA     XX6E          ; SAVE FAC2 SIGN (B7)     EOR     XX66          ; EOR WITH FAC1 SIGN (B7)     STA     XX6F          ; SAVE SIGN COMPARE (FAC1 EOR FAC2)     LDA     XX6E          ; RECOVER FAC2 SIGN (B7)     ORA     #$80               ; SET 1XXX XXX (SET NORMAL BIT)     STA     XX6A          ; SAVE FAC2 MANTISSA 1     DEY                    ; DECREMENT INDEX     LDA     (XX22),Y          ; GET EXPONENT BYTE     STA     XX69          ; SAVE FAC2 EXPONENT     LDA     XX61          ; GET FAC1 EXPONENT     RTS;***********************************************************************************;;; TEST AND ADJUST ACCUMULATORSXXDAB7 = *     LDA     XX69          ; GET FAC2 EXPONENTXXDAB9 = *     BEQ     XXDADA          ; BRANCH IF FAC2 = $00 (HANDLE UNDERFLOW)     CLC                    ; CLEAR CARRY FOR ADD     ADC     XX61          ; ADD FAC1 EXPONENT     BCC     XXDAC4          ; BRANCH IF SUM OF EXPONENTS < $0100     BMI     XXDADF          ; DO OVERFLOW ERROR     CLC                    ; CLEAR CARRY FOR THE ADD     .BYTE     $2C               ; MAKES NEXT LINE BIT XX1410XXDAC4 = *     BPL     XXDADA          ; IF +VE GO HANDLE UNDERFLOW     ADC     #$80               ; ADJUST EXPONENT     STA     XX61          ; SAVE FAC1 EXPONENT     BNE     XXDACF          ; BRANCH IF NOT ZERO     JMP     XXD8FB          ; SAVE FAC1 SIGN AND RETURNXXDACF = *     LDA     XX6F          ; GET SIGN COMPARE (FAC1 EOR FAC2)     STA     XX66          ; SAVE FAC1 SIGN (B7)     RTS;***********************************************************************************;;; HANDLE OVERFLOW AND UNDERFLOWXXDAD4 = *     LDA     XX66          ; GET FAC1 SIGN (B7)     EOR     #$FF               ; COMPLEMENT IT     BMI     XXDADF          ; DO OVERFLOW ERROR                         ; HANDLE UNDERFLOWXXDADA = *     PLA                    ; POP RETURN ADDRESS LOW BYTE     PLA                    ; POP RETURN ADDRESS HIGH BYTE     JMP     XXD8F7          ; CLEAR FAC1 EXPONENT AND SIGN AND RETURNXXDADF = *     JMP     XXD97E          ; DO OVERFLOW ERROR THEN WARM START;***********************************************************************************;;; MULTIPLY FAC1 BY 10XXDAE2 = *     JSR     XXDC0C          ; ROUND AND COPY FAC1 TO FAC2     TAX                    ; COPY EXPONENT (SET THE FLAGS)     BEQ     XXDAF8          ; EXIT IF ZERO     CLC                    ; CLEAR CARRY FOR ADD     ADC     #$02               ; ADD TWO TO EXPONENT (*4)     BCS     XXDADF          ; DO OVERFLOW ERROR IF > $FF; FAC1 = (FAC1 + FAC2) * 2XXDAED = *     LDX     #$00               ; CLEAR BYTE     STX     XX6F          ; CLEAR SIGN COMPARE (FAC1 EOR FAC2)     JSR     XXD877          ; ADD FAC2 TO FAC1 (*5)     INC     XX61          ; INCREMENT FAC1 EXPONENT (*10)     BEQ     XXDADF          ; IF EXPONENT NOW ZERO GO DO OVERFLOW ERRORXXDAF8 = *     RTS;***********************************************************************************;;; 10 AS A FLOATING VALUEXXDAF9 = *     .BYTE     $84,$20,$00,$00,$00     ; 10;***********************************************************************************;;; DIVIDE FAC1 BY 10XXDAFE = *     JSR     XXDC0C          ; ROUND AND COPY FAC1 TO FAC2     LDA     #<XXDAF9          ; SET 10 POINTER LOW BYTE     LDY     #>XXDAF9          ; SET 10 POINTER HIGH BYTE     LDX     #$00               ; CLEAR SIGN; DIVIDE BY (AY) (X=SIGN)XXDB07 = *     STX     XX6F          ; SAVE SIGN COMPARE (FAC1 EOR FAC2)     JSR     XXDBA2          ; UNPACK MEMORY (AY) INTO FAC1     JMP     XXDB12          ; DO FAC2/FAC1                         ; PERFORM DIVIDE-BY; CONVERT AY AND DO (AY)/FAC1XXDB0F = *     JSR     XXDA8C          ; UNPACK MEMORY (AY) INTO FAC2XXDB12 = *     BEQ     XXDB8A          ; IF ZERO GO DO /0 ERROR     JSR     XXDC1B          ; ROUND FAC1     LDA     #$00               ; CLEAR A     SEC                    ; SET CARRY FOR SUBTRACT     SBC     XX61          ; SUBTRACT FAC1 EXPONENT (2S COMPLEMENT)     STA     XX61          ; SAVE FAC1 EXPONENT     JSR     XXDAB7          ; TEST AND ADJUST ACCUMULATORS     INC     XX61          ; INCREMENT FAC1 EXPONENT     BEQ     XXDADF          ; IF ZERO DO OVERFLOW ERROR     LDX     #$FC               ; SET INDEX TO FAC TEMP     LDA     #$01               ;.SET BYTEXXDB29 = *     LDY     XX6A          ; GET FAC2 MANTISSA 1     CPY     XX62          ; COMPARE FAC1 MANTISSA 1     BNE     XXDB3F          ; IF <> GO USE THE RESULT     LDY     XX6B          ; GET FAC2 MANTISSA 2     CPY     XX63          ; COMPARE FAC1 MANTISSA 2     BNE     XXDB3F          ; IF <> GO USE THE RESULT     LDY     XX6C          ; GET FAC2 MANTISSA 3     CPY     XX64          ; COMPARE FAC1 MANTISSA 3     BNE     XXDB3F          ; IF <> GO USE THE RESULT     LDY     XX6D          ; GET FAC2 MANTISSA 4     CPY     XX65          ; COMPARE FAC1 MANTISSA 4XXDB3F = *     PHP                    ; SAVE THE FAC2-FAC1 COMPARE STATUS     ROL A                  ;.SHIFT BYTE     BCC     XXDB4C          ; SKIP NEXT IF NO CARRY     INX                    ; INCREMENT INDEX TO FAC TEMP     STA     XX29,X          ;.     BEQ     XXDB7A          ;.     BPL     XXDB7E          ;.     LDA     #$01               ;.XXDB4C = *     PLP                    ; RESTORE FAC2-FAC1 COMPARE STATUS     BCS     XXDB5D          ; IF FAC2 >= FAC1 THEN DO SUBTRACT                         ; FAC2 = FAC2*2XXDB4F = *     ASL     XX6D          ; SHIFT FAC2 MANTISSA 4     ROL     XX6C          ; SHIFT FAC2 MANTISSA 3     ROL     XX6B          ; SHIFT FAC2 MANTISSA 2     ROL     XX6A          ; SHIFT FAC2 MANTISSA 1     BCS     XXDB3F          ; LOOP WITH NO COMPARE     BMI     XXDB29          ; LOOP WITH COMPARE     BPL     XXDB3F          ; LOOP ALWAYS WITH NO COMPAREXXDB5D = *     TAY                    ; SAVE FAC2-FAC1 COMPARE STATUS     LDA     XX6D          ; GET FAC2 MANTISSA 4     SBC     XX65          ; SUBTRACT FAC1 MANTISSA 4     STA     XX6D          ; SAVE FAC2 MANTISSA 4     LDA     XX6C          ; GET FAC2 MANTISSA 3     SBC     XX64          ; SUBTRACT FAC1 MANTISSA 3     STA     XX6C          ; SAVE FAC2 MANTISSA 3     LDA     XX6B          ; GET FAC2 MANTISSA 2     SBC     XX63          ; SUBTRACT FAC1 MANTISSA 2     STA     XX6B          ; SAVE FAC2 MANTISSA 2     LDA     XX6A          ; GET FAC2 MANTISSA 1     SBC     XX62          ; SUBTRACT FAC1 MANTISSA 1     STA     XX6A          ; SAVE FAC2 MANTISSA 1     TYA                    ; RESTORE FAC2-FAC1 COMPARE STATUS     JMP     XXDB4F          ; GO SHIFT FAC2XXDB7A = *     LDA     #$40               ;.     BNE     XXDB4C          ; BRANCH ALWAYS; DO A<<6, SAVE AS FAC1 ROUNDING BYTE, NORMALISE AND RETURNXXDB7E = *     ASL A                  ;      ASL A                  ;      ASL A                  ;      ASL A                  ;      ASL A                  ;      ASL A                  ;      STA     XX70          ; SAVE FAC1 ROUNDING BYTE     PLP                    ; DUMP FAC2-FAC1 COMPARE STATUS     JMP     XXDB8F          ; COPY TEMP TO FAC1, NORMALISE AND RETURN; DO 'DIVIDE BY ZERO' ERRORXXDB8A = *     LDX     #$14               ; ERROR $14, DIVIDE BY ZERO ERROR     JMP     XXC437          ; DO ERROR #X THEN WARM STARTXXDB8F = *     LDA     XX26          ; GET TEMP MANTISSA 1     STA     XX62          ; SAVE FAC1 MANTISSA 1     LDA     XX27          ; GET TEMP MANTISSA 2     STA     XX63          ; SAVE FAC1 MANTISSA 2     LDA     XX28          ; GET TEMP MANTISSA 3     STA     XX64          ; SAVE FAC1 MANTISSA 3     LDA     XX29          ; GET TEMP MANTISSA 4     STA     XX65          ; SAVE FAC1 MANTISSA 4     JMP     XXD8D7          ; NORMALISE FAC1 AND RETURN;***********************************************************************************;;; UNPACK MEMORY (AY) INTO FAC1XXDBA2 = *     STA     XX22          ; SAVE POINTER LOW BYTE     STY     XX23          ; SAVE POINTER HIGH BYTE     LDY     #$04               ; 5 BYTES TO DO     LDA     (XX22),Y          ; GET FIFTH BYTE     STA     XX65          ; SAVE FAC1 MANTISSA 4     DEY                    ; DECREMENT INDEX     LDA     (XX22),Y          ; GET FOURTH BYTE     STA     XX64          ; SAVE FAC1 MANTISSA 3     DEY                    ; DECREMENT INDEX     LDA     (XX22),Y          ; GET THIRD BYTE     STA     XX63          ; SAVE FAC1 MANTISSA 2     DEY                    ; DECREMENT INDEX     LDA     (XX22),Y          ; GET SECOND BYTE     STA     XX66          ; SAVE FAC1 SIGN (B7)     ORA     #$80               ; SET 1XXX XXXX (ADD NORMAL BIT)     STA     XX62          ; SAVE FAC1 MANTISSA 1     DEY                    ; DECREMENT INDEX     LDA     (XX22),Y          ; GET FIRST BYTE (EXPONENT)     STA     XX61          ; SAVE FAC1 EXPONENT     STY     XX70          ; CLEAR FAC1 ROUNDING BYTE     RTS;***********************************************************************************;;; PACK FAC1 INTO XX5CXXDBC7 = *     LDX     #<XX5C          ; SET POINTER LOW BYTE     .BYTE     $2C               ; MAKES NEXT LINE BIT XX57A2; PACK FAC1 INTO XX57XXDBCA = *     LDX     #<XX57          ; SET POINTER LOW BYTE     LDY     #>XX57          ; SET POINTER HIGH BYTE     BEQ     XXDBD4          ; PACK FAC1 INTO (XY) AND RETURN, BRANCH ALWAYS; PACK FAC1 INTO VARIABLE POINTERXXDBD0 = *     LDX     XX49          ; GET DESTINATION POINTER LOW BYTE     LDY     XX4A          ; GET DESTINATION POINTER HIGH BYTE; PACK FAC1 INTO (XY)XXDBD4 = *     JSR     XXDC1B          ; ROUND FAC1     STX     XX22          ; SAVE POINTER LOW BYTE     STY     XX23          ; SAVE POINTER HIGH BYTE     LDY     #$04               ; SET INDEX     LDA     XX65          ; GET FAC1 MANTISSA 4     STA     (XX22),Y          ; STORE IN DESTINATION     DEY                    ; DECREMENT INDEX     LDA     XX64          ; GET FAC1 MANTISSA 3     STA     (XX22),Y          ; STORE IN DESTINATION     DEY                    ; DECREMENT INDEX     LDA     XX63          ; GET FAC1 MANTISSA 2     STA     (XX22),Y          ; STORE IN DESTINATION     DEY                    ; DECREMENT INDEX     LDA     XX66          ; GET FAC1 SIGN (B7)     ORA     #$7F               ; SET BITS X111 1111     AND     XX62          ; AND IN FAC1 MANTISSA 1     STA     (XX22),Y          ; STORE IN DESTINATION     DEY                    ; DECREMENT INDEX     LDA     XX61          ; GET FAC1 EXPONENT     STA     (XX22),Y          ; STORE IN DESTINATION     STY     XX70          ; CLEAR FAC1 ROUNDING BYTE     RTS;***********************************************************************************;;; COPY FAC2 TO FAC1XXDBFC = *     LDA     XX6E          ; GET FAC2 SIGN (B7); SAVE FAC1 SIGN AND COPY ABS(FAC2) TO FAC1XXDBFE = *     STA     XX66          ; SAVE FAC1 SIGN (B7)     LDX     #$05               ; 5 BYTES TO COPYXXDC02 = *     LDA     XX68,X          ; GET BYTE FROM FAC2,X     STA     XX60,X          ; SAVE BYTE AT FAC1,X     DEX                    ; DECREMENT COUNT     BNE     XXDC02          ; LOOP IF NOT ALL DONE     STX     XX70          ; CLEAR FAC1 ROUNDING BYTE     RTS;***********************************************************************************;;; ROUND AND COPY FAC1 TO FAC2XXDC0C = *     JSR     XXDC1B          ; ROUND FAC1; COPY FAC1 TO FAC2XXDC0F = *     LDX     #$06               ; 6 BYTES TO COPYXXDC11 = *     LDA     XX60,X          ; GET BYTE FROM FAC1,X     STA     XX68,X          ; SAVE BYTE AT FAC2,X     DEX                    ; DECREMENT COUNT     BNE     XXDC11          ; LOOP IF NOT ALL DONE     STX     XX70          ; CLEAR FAC1 ROUNDING BYTEXXDC1A = *     RTS;***********************************************************************************;;; ROUND FAC1XXDC1B = *     LDA     XX61          ; GET FAC1 EXPONENT     BEQ     XXDC1A          ; EXIT IF ZERO     ASL     XX70          ; SHIFT FAC1 ROUNDING BYTE     BCC     XXDC1A          ; EXIT IF NO OVERFLOW; ROUND FAC1 (NO CHECK)XXDC23 = *     JSR     XXD96F          ; INCREMENT FAC1 MANTISSA     BNE     XXDC1A          ; BRANCH IF NO OVERFLOW     JMP     XXD938          ; NORNALISE FAC1 FOR C=1 AND RETURN; GET FAC1 SIGN; RETURN A = $FF, CB = 1/-VE A = $01, CB = 0/+VE, A = $00, CB = ?/0XXDC2B = *     LDA     XX61          ; GET FAC1 EXPONENT     BEQ     XXDC38          ; EXIT IF ZERO (ALLREADY CORRECT SGN(0)=0); RETURN A = $FF, CB = 1/-VE A = $01, CB = 0/+VE; NO = 0 CHECKXXDC2F = *     LDA     XX66          ; ELSE GET FAC1 SIGN (B7); RETURN A = $FF, CB = 1/-VE A = $01, CB = 0/+VE; NO = 0 CHECK, SIGN IN AXXDC31 = *     ROL A                  ; MOVE SIGN BIT TO CARRY     LDA     #$FF               ; SET BYTE FOR -VE RESULT     BCS     XXDC38          ; RETURN IF SIGN WAS SET (-VE)     LDA     #$01               ; ELSE SET BYTE FOR +VE RESULTXXDC38 = *     RTS;***********************************************************************************;;; PERFORM SGN()XXDC39 = *     JSR     XXDC2B          ; GET FAC1 SIGN, RETURN A = $FF -VE, A = $01 +VE; SAVE A AS INTEGER BYTEXXDC3C = *     STA     XX62          ; SAVE FAC1 MANTISSA 1     LDA     #$00               ; CLEAR A     STA     XX63          ; CLEAR FAC1 MANTISSA 2     LDX     #$88               ; SET EXPONENT; SET EXPONENT = X, CLEAR FAC1 3 AND 4 AND NORMALISEXXDC44 = *     LDA     XX62          ; GET FAC1 MANTISSA 1     EOR     #$FF               ; COMPLEMENT IT     ROL A                  ; SIGN BIT INTO CARRY; SET EXPONENT = X, CLEAR MANTISSA 4 AND 3 AND NORMALISE FAC1XXDC49 = *     LDA     #$00               ; CLEAR A     STA     XX65          ; CLEAR FAC1 MANTISSA 4     STA     XX64          ; CLEAR FAC1 MANTISSA 3; SET EXPONENT = X AND NORMALISE FAC1XXDC4F = *     STX     XX61          ; SET FAC1 EXPONENT     STA     XX70          ; CLEAR FAC1 ROUNDING BYTE     STA     XX66          ; CLEAR FAC1 SIGN (B7)     JMP     XXD8D2          ; DO ABS AND NORMALISE FAC1; PERFORM ABS()XXDC58 = *     LSR     XX66          ; CLEAR FAC1 SIGN, PUT ZERO IN B7     RTS;***********************************************************************************;;; COMPARE FAC1 WITH (AY); RETURNS A=$00 IF FAC1 = (AY); RETURNS A=$01 IF FAC1 > (AY); RETURNS A=$FF IF FAC1 < (AY)XXDC5B = *     STA     XX24          ; SAVE POINTER LOW BYTEXXDC5D = *     STY     XX25          ; SAVE POINTER HIGH BYTE     LDY     #$00               ; CLEAR INDEX     LDA     (XX24),Y          ; GET EXPONENT     INY                    ; INCREMENT INDEX     TAX                    ; COPY (AY) EXPONENT TO X     BEQ     XXDC2B          ; BRANCH IF (AY) EXPONENT=0 AND GET FAC1 SIGN                         ; A = $FF, CB = 1/-VE A = $01, CB = 0/+VE     LDA     (XX24),Y          ; GET (AY) MANTISSA 1, WITH SIGN     EOR     XX66          ; EOR FAC1 SIGN (B7)     BMI     XXDC2F          ; IF SIGNS <> DO RETURN A = $FF, CB = 1/-VE                         ; A = $01, CB = 0/+VE AND RETURN     CPX     XX61          ; COMPARE (AY) EXPONENT WITH FAC1 EXPONENT     BNE     XXDC92          ; BRANCH IF DIFFERENT     LDA     (XX24),Y          ; GET (AY) MANTISSA 1, WITH SIGN     ORA     #$80               ; NORMALISE TOP BIT     CMP     XX62          ; COMPARE WITH FAC1 MANTISSA 1     BNE     XXDC92          ; BRANCH IF DIFFERENT     INY                    ; INCREMENT INDEX     LDA     (XX24),Y          ; GET MANTISSA 2     CMP     XX63          ; COMPARE WITH FAC1 MANTISSA 2     BNE     XXDC92          ; BRANCH IF DIFFERENT     INY                    ; INCREMENT INDEX     LDA     (XX24),Y          ; GET MANTISSA 3     CMP     XX64          ; COMPARE WITH FAC1 MANTISSA 3     BNE     XXDC92          ; BRANCH IF DIFFERENT     INY                    ; INCREMENT INDEX     LDA     #$7F               ; SET FOR 1/2 VALUE ROUNDING BYTE     CMP     XX70          ; COMPARE WITH FAC1 ROUNDING BYTE (SET CARRY)     LDA     (XX24),Y          ; GET MANTISSA 4     SBC     XX65          ; SUBTRACT FAC1 MANTISSA 4     BEQ     XXDCBA          ; EXIT IF MANTISSA 4 EQUAL; GETS HERE IF NUMBER <> FAC1XXDC92 = *     LDA     XX66          ; GET FAC1 SIGN (B7)     BCC     XXDC98          ; BRANCH IF FAC1 > (AY)     EOR     #$FF               ; ELSE TOGGLE FAC1 SIGNXXDC98 = *     JMP     XXDC31          ; RETURN A = $FF, CB = 1/-VE A = $01, CB = 0/+VE;***********************************************************************************;;; CONVERT FAC1 FLOATING TO FIXEDXXDC9B = *     LDA     XX61          ; GET FAC1 EXPONENT     BEQ     XXDCE9          ; IF ZERO GO CLEAR FAC1 AND RETURN     SEC                    ; SET CARRY FOR SUBTRACT     SBC     #$A0               ; SUBTRACT MAXIMUM INTEGER RANGE EXPONENT     BIT     XX66          ; TEST FAC1 SIGN (B7)     BPL     XXDCAF          ; BRANCH IF FAC1 +VE                         ; FAC1 WAS -VE     TAX                    ; COPY SUBTRACTED EXPONENT     LDA     #$FF               ; OVERFLOW FOR -VE NUMBER     STA     XX68          ; SET FAC1 OVERFLOW BYTE     JSR     XXD94D          ; TWOS COMPLEMENT FAC1 MANTISSA     TXA                    ; RESTORE SUBTRACTED EXPONENTXXDCAF = *     LDX     #$61               ; SET INDEX TO FAC1     CMP     #$F9               ; COMPARE EXPONENT RESULT     BPL     XXDCBB          ; IF < 8 SHIFTS SHIFT FAC1 A TIMES RIGHT AND RETURN     JSR     XXD999          ; SHIFT FAC1 A TIMES RIGHT (> 8 SHIFTS)     STY     XX68          ; CLEAR FAC1 OVERFLOW BYTEXXDCBA = *     RTS;***********************************************************************************;;; SHIFT FAC1 A TIMES RIGHTXXDCBB = *     TAY                    ; COPY SHIFT COUNT     LDA     XX66          ; GET FAC1 SIGN (B7)     AND     #$80               ; MASK SIGN BIT ONLY (X000 0000)     LSR     XX62          ; SHIFT FAC1 MANTISSA 1     ORA     XX62          ; OR SIGN IN B7 FAC1 MANTISSA 1     STA     XX62          ; SAVE FAC1 MANTISSA 1     JSR     XXD9B0          ; SHIFT FAC1 Y TIMES RIGHT     STY     XX68          ; CLEAR FAC1 OVERFLOW BYTE     RTS;***********************************************************************************;;; PERFORM INT()XXDCCC = *     LDA     XX61          ; GET FAC1 EXPONENT     CMP     #$A0               ; COMPARE WITH MAX INT     BCS     XXDCF2          ; EXIT IF >= (ALLREADY INT, TOO BIG FOR FRACTIONAL PART!)     JSR     XXDC9B          ; CONVERT FAC1 FLOATING TO FIXED     STY     XX70          ; SAVE FAC1 ROUNDING BYTE     LDA     XX66          ; GET FAC1 SIGN (B7)     STY     XX66          ; SAVE FAC1 SIGN (B7)     EOR     #$80               ; TOGGLE FAC1 SIGN     ROL A                  ; SHIFT INTO CARRY     LDA     #$A0               ; SET NEW EXPONENT     STA     XX61          ; SAVE FAC1 EXPONENT     LDA     XX65          ; GET FAC1 MANTISSA 4     STA     XX07          ; SAVE FAC1 MANTISSA 4 FOR POWER FUNCTION     JMP     XXD8D2          ; DO ABS AND NORMALISE FAC1;***********************************************************************************;;; CLEAR FAC1 AND RETURNXXDCE9 = *     STA     XX62          ; CLEAR FAC1 MANTISSA 1     STA     XX63          ; CLEAR FAC1 MANTISSA 2     STA     XX64          ; CLEAR FAC1 MANTISSA 3     STA     XX65          ; CLEAR FAC1 MANTISSA 4     TAY                    ; CLEAR YXXDCF2 = *     RTS;***********************************************************************************;;; GET FAC1 FROM STRINGXXDCF3 = *     LDY     #$00               ; CLEAR Y     LDX     #$0A               ; SET INDEXXXDCF7 = *     STY     XX5D,X          ; CLEAR BYTE     DEX                    ; DECREMENT INDEX     BPL     XXDCF7          ; LOOP UNTIL NUMEXP TO NEGNUM (AND FAC1) = $00     BCC     XXDD0D          ; BRANCH IF FIRST CHARACTER IS NUMERIC     CMP     #'-'               ; ELSE COMPARE WITH '-'     BNE     XXDD06          ; BRANCH IF NOT '-'     STX     XX67          ; SET FLAG FOR -VE N (NEGNUM = $FF)     BEQ     XXDD0A          ; BRANCH ALWAYSXXDD06 = *     CMP     #'+'               ; ELSE COMPARE WITH '+'     BNE     XXDD0F          ; BRANCH IF NOT '+'XXDD0A = *     JSR     XX0073          ; INCREMENT AND SCAN MEMORYXXDD0D = *     BCC     XXDD6A          ; BRANCH IF NUMERIC CHARACTERXXDD0F = *     CMP     #'.'               ; ELSE COMPARE WITH '.'     BEQ     XXDD41          ; BRANCH IF '.'     CMP     #'E'               ; ELSE COMPARE WITH 'E'     BNE     XXDD47          ; BRANCH IF NOT 'E'                         ; WAS 'E' SO EVALUATE EXPONENTIAL PART     JSR     XX0073          ; INCREMENT AND SCAN MEMORY     BCC     XXDD33          ; BRANCH IF NUMERIC CHARACTER     CMP     #TMINUS          ; ELSE COMPARE WITH TOKEN FOR -     BEQ     XXDD2E          ; BRANCH IF TOKEN FOR -     CMP     #'-'               ; ELSE COMPARE WITH '-'     BEQ     XXDD2E          ; BRANCH IF '-'     CMP     #TPLUS          ; ELSE COMPARE WITH TOKEN FOR +     BEQ     XXDD30          ; BRANCH IF TOKEN FOR +     CMP     #'+'               ; ELSE COMPARE WITH '+'     BEQ     XXDD30          ; BRANCH IF '+'     BNE     XXDD35          ; BRANCH ALWAYSXXDD2E = *     ROR     XX60          ; SET EXPONENT -VE FLAG (C, WHICH=1, INTO B7)XXDD30 = *     JSR     XX0073          ; INCREMENT AND SCAN MEMORYXXDD33 = *     BCC     XXDD91          ; BRANCH IF NUMERIC CHARACTERXXDD35 = *     BIT     XX60          ; TEST EXPONENT -VE FLAG     BPL     XXDD47          ; IF +VE GO EVALUATE EXPONENT                         ; ELSE DO EXPONENT = -EXPONENT     LDA     #$00               ; CLEAR RESULT     SEC                    ; SET CARRY FOR SUBTRACT     SBC     XX5E          ; SUBTRACT EXPONENT BYTE     JMP     XXDD49          ; GO EVALUATE EXPONENTXXDD41 = *     ROR     XX5F          ; SET DECIMAL POINT FLAG     BIT     XX5F          ; TEST DECIMAL POINT FLAG     BVC     XXDD0A          ; BRANCH IF ONLY ONE DECIMAL POINT SO FAR                         ; EVALUATE EXPONENTXXDD47 = *     LDA     XX5E          ; GET EXPONENT COUNT BYTEXXDD49 = *     SEC                    ; SET CARRY FOR SUBTRACT     SBC     XX5D          ; SUBTRACT NUMERATOR EXPONENT     STA     XX5E          ; SAVE EXPONENT COUNT BYTE     BEQ     XXDD62          ; BRANCH IF NO ADJUSTMENT     BPL     XXDD5B          ; ELSE IF +VE GO DO FAC1*10^EXPCNT                         ; ELSE GO DO FAC1/10^(0-EXPCNT)XXDD52 = *     JSR     XXDAFE          ; DIVIDE FAC1 BY 10     INC     XX5E          ; INCREMENT EXPONENT COUNT BYTE     BNE     XXDD52          ; LOOP UNTIL ALL DONE     BEQ     XXDD62          ; BRANCH ALWAYSXXDD5B = *     JSR     XXDAE2          ; MULTIPLY FAC1 BY 10     DEC     XX5E          ; DECREMENT EXPONENT COUNT BYTE     BNE     XXDD5B          ; LOOP UNTIL ALL DONEXXDD62 = *     LDA     XX67          ; GET -VE FLAG     BMI     XXDD67          ; IF -VE DO - FAC1 AND RETURN     RTS; DO - FAC1 AND RETURNXXDD67 = *     JMP     XXDFB4          ; DO - FAC1; DO UNSIGNED FAC1*10+NUMBERXXDD6A = *     PHA                    ; SAVE CHARACTER     BIT     XX5F          ; TEST DECIMAL POINT FLAG     BPL     XXDD71          ; SKIP EXPONENT INCREMENT IF NOT SET     INC     XX5D          ; ELSE INCREMENT NUMBER EXPONENTXXDD71 = *     JSR     XXDAE2          ; MULTIPLY FAC1 BY 10     PLA                    ; RESTORE CHARACTER     SEC                    ; SET CARRY FOR SUBTRACT     SBC     #'0'               ; CONVERT TO BINARY     JSR     XXDD7E          ; EVALUATE NEW ASCII DIGIT     JMP     XXDD0A          ; GO DO NEXT CHARACTER; EVALUATE NEW ASCII DIGIT; MULTIPLY FAC1 BY 10 THEN (ABS) ADD IN NEW DIGITXXDD7E = *     PHA                    ; SAVE DIGIT     JSR     XXDC0C          ; ROUND AND COPY FAC1 TO FAC2     PLA                    ; RESTORE DIGIT     JSR     XXDC3C          ; SAVE A AS INTEGER BYTE     LDA     XX6E          ; GET FAC2 SIGN (B7)     EOR     XX66          ; TOGGLE WITH FAC1 SIGN (B7)     STA     XX6F          ; SAVE SIGN COMPARE (FAC1 EOR FAC2)     LDX     XX61          ; GET FAC1 EXPONENT     JMP     XXD86A          ; ADD FAC2 TO FAC1 AND RETURN; EVALUATE NEXT CHARACTER OF EXPONENTIAL PART OF NUMBERXXDD91 = *     LDA     XX5E          ; GET EXPONENT COUNT BYTE     CMP     #$0A               ; COMPARE WITH 10 DECIMAL     BCC     XXDDA0          ; BRANCH IF LESS     LDA     #$64               ; MAKE ALL -VE EXPONENTS = -100 DECIMAL (CAUSES UNDERFLOW)     BIT     XX60          ; TEST EXPONENT -VE FLAG     BMI     XXDDAE          ; BRANCH IF -VE     JMP     XXD97E          ; ELSE DO OVERFLOW ERROR THEN WARM STARTXXDDA0 = *     ASL A                  ; *2     ASL A                  ; *4     CLC                    ; CLEAR CARRY FOR ADD     ADC     XX5E          ; *5     ASL A                  ; *10     CLC                    ; CLEAR CARRY FOR ADD     LDY     #$00               ; SET INDEX     ADC     (XX7A),Y          ; ADD CHARACTER (WILL BE $30 TOO MUCH!)     SEC                    ; SET CARRY FOR SUBTRACT     SBC     #'0'               ; CONVERT CHARACTER TO BINARYXXDDAE = *     STA     XX5E          ; SAVE EXPONENT COUNT BYTE     JMP     XXDD30          ; GO GET NEXT CHARACTER;***********************************************************************************;;XXDDB3 = *     .BYTE     $9B,$3E,$BC,$1F,$FD                         ; 99999999.90625, MAXIMUM VALUE WITH AT LEAST ONE DECIMALXXDDB8 = *     .BYTE     $9E,$6E,$6B,$27,$FD                         ; 999999999.25, MAXIMUM VALUE BEFORE SCIENTIFIC NOTATIONXXDDBD = *     .BYTE     $9E,$6E,$6B,$28,$00                         ; 1000000000;***********************************************************************************;;; DO ' IN ' LINE NUMBER MESSAGEXXDDC2 = *     LDA     #<XXC371          ; SET ' IN ' POINTER LOW BYTE     LDY     #>XXC371          ; SET ' IN ' POINTER HIGH BYTE     JSR     XXDDDA          ; PRINT NULL TERMINATED STRING     LDA     XX3A          ; GET THE CURRENT LINE NUMBER HIGH BYTE     LDX     XX39          ; GET THE CURRENT LINE NUMBER LOW BYTE;***********************************************************************************;;; PRINT XA AS UNSIGNED INTEGERXXDDCD = *     STA     XX62          ; SAVE HIGH BYTE AS FAC1 MANTISSA1     STX     XX63          ; SAVE LOW BYTE AS FAC1 MANTISSA2     LDX     #$90               ; SET EXPONENT TO 16D BITS     SEC                    ; SET INTEGER IS +VE FLAG     JSR     XXDC49          ; SET EXPONENT = X, CLEAR MANTISSA 4 AND 3 AND NORMALISE                         ; FAC1     JSR     XXDDDF          ; CONVERT FAC1 TO STRINGXXDDDA = *     JMP     XXCB1E          ; PRINT NULL TERMINATED STRING;***********************************************************************************;;; CONVERT FAC1 TO ASCII STRING RESULT IN (AY)XXDDDD = *     LDY     #$01               ; SET INDEX = 1XXDDDF = *     LDA     #' '               ; CHARACTER = ' ' (ASSUME +VE)     BIT     XX66          ; TEST FAC1 SIGN (B7)     BPL     XXDDE7          ; IF +VE SKIP THE - SIGN SET     LDA     #'-'               ; ELSE CHARACTER = '-'XXDDE7 = *     STA     XX00FF,Y          ; SAVE LEADING CHARACTER (' ' OR '-')     STA     XX66          ; SAVE FAC1 SIGN (B7)     STY     XX71          ; SAVE THE INDEX     INY                    ; INCREMENT INDEX     LDA     #'0'               ; SET CHARACTER = '0'     LDX     XX61          ; GET FAC1 EXPONENT     BNE     XXDDF8          ; IF FAC1<>0 GO CONVERT IT                         ; EXPONENT WAS $00 SO FAC1 IS 0     JMP     XXDF04          ; SAVE LAST CHARACTER, [EOT] AND EXIT; FAC1 IS SOME NON ZERO VALUEXXDDF8 = *     LDA     #$00               ; CLEAR (NUMBER EXPONENT COUNT)     CPX     #$80               ; COMPARE FAC1 EXPONENT WITH $80 (<1.00000)     BEQ     XXDE00          ; BRANCH IF 0.5 <= FAC1 < 1.0     BCS     XXDE09          ; BRANCH IF FAC1=>1XXDE00 = *     LDA     #<XXDDBD          ; SET 1000000000 POINTER LOW BYTE     LDY     #>XXDDBD          ; SET 1000000000 POINTER HIGH BYTE     JSR     XXDA28          ; DO CONVERT AY, FCA1*(AY)     LDA     #$F7               ; SET NUMBER EXPONENT COUNTXXDE09 = *     STA     XX5D          ; SAVE NUMBER EXPONENT COUNTXXDE0B = *     LDA     #<XXDDB8          ; SET 999999999.25 POINTER LOW BYTE (MAX BEFORE SCI NOTE)     LDY     #>XXDDB8          ; SET 999999999.25 POINTER HIGH BYTE     JSR     XXDC5B          ; COMPARE FAC1 WITH (AY)     BEQ     XXDE32          ; EXIT IF FAC1 = (AY)     BPL     XXDE28          ; GO DO /10 IF FAC1 > (AY)                         ; FAC1 < (AY)XXDE16 = *     LDA     #<XXDDB3          ; SET 99999999.90625 POINTER LOW BYTE     LDY     #>XXDDB3          ; SET 99999999.90625 POINTER HIGH BYTE     JSR     XXDC5B          ; COMPARE FAC1 WITH (AY)     BEQ     XXDE21          ; BRANCH IF FAC1 = (AY) (ALLOW DECIMAL PLACES)     BPL     XXDE2F          ; BRANCH IF FAC1 > (AY) (NO DECIMAL PLACES)                         ; FAC1 <= (AY)XXDE21 = *     JSR     XXDAE2          ; MULTIPLY FAC1 BY 10     DEC     XX5D          ; DECREMENT NUMBER EXPONENT COUNT     BNE     XXDE16          ; GO TEST AGAIN, BRANCH ALWAYSXXDE28 = *     JSR     XXDAFE          ; DIVIDE FAC1 BY 10     INC     XX5D          ; INCREMENT NUMBER EXPONENT COUNT     BNE     XXDE0B          ; GO TEST AGAIN, BRANCH ALWAYS; NOW WE HAVE JUST THE DIGITS TO DOXXDE2F = *     JSR     XXD849          ; ADD 0.5 TO FAC1 (ROUND FAC1)XXDE32 = *     JSR     XXDC9B          ; CONVERT FAC1 FLOATING TO FIXED     LDX     #$01               ; SET DEFAULT DIGITS BEFORE DP = 1     LDA     XX5D          ; GET NUMBER EXPONENT COUNT     CLC                    ; CLEAR CARRY FOR ADD     ADC     #$0A               ; UP TO 9 DIGITS BEFORE POINT     BMI     XXDE47          ; IF -VE THEN 1 DIGIT BEFORE DP     CMP     #$0B               ; A>=$0B IF N>=1E9     BCS     XXDE48          ; BRANCH IF >= $0B                         ; CARRY IS CLEAR     ADC     #$FF               ; TAKE 1 FROM DIGIT COUNT     TAX                    ; COPY TO X     LDA     #$02               ; SET THE EXPONENT ADJUSTXXDE47 = *     SEC                    ; SET CARRY FOR SUBTRACTXXDE48 = *     SBC     #$02               ; -2     STA     XX5E          ; SAVE THE EXPONENT ADJUST     STX     XX5D          ; SAVE DIGITS BEFORE DP COUNT     TXA                    ; COPY DIGITS BEFORE DP COUNT TO A     BEQ     XXDE53          ; IF NO DIGITS BEFORE THE DP GO DO THE '.'     BPL     XXDE66          ; IF THERE ARE DIGITS BEFORE THE DP GO DO THEMXXDE53 = *     LDY     XX71          ; GET THE OUTPUT STRING INDEX     LDA     #'.'               ; CHARACTER '.'     INY                    ; INCREMENT THE INDEX     STA     XX0100-1,Y     ; SAVE THE '.' TO THE OUTPUT STRING     TXA                    ; COPY DIGITS BEFORE DP COUNT TO A     BEQ     XXDE64          ; IF NO DIGITS BEFORE THE DP SKIP THE '0'     LDA     #'0'               ; CHARACTER '0'     INY                    ; INCREMENT INDEX     STA     XX0100-1,Y     ; SAVE THE '0' TO THE OUTPUT STRINGXXDE64 = *     STY     XX71          ; SAVE THE OUTPUT STRING INDEXXXDE66 = *     LDY     #$00               ; CLEAR THE POWERS OF 10 INDEX (POINT TO -100,000,000)XXDE68 = *     LDX     #$80               ; CLEAR THE DIGIT, SET THE TEST SENSEXXDE6A = *     LDA     XX65          ; GET FAC1 MANTISSA 4     CLC                    ; CLEAR CARRY FOR ADD     ADC     XXDF16+3,Y     ; ADD BYTE 4, LEAST SIGNIFICANT     STA     XX65          ; SAVE FAC1 MANTISSA4     LDA     XX64          ; GET FAC1 MANTISSA 3     ADC     XXDF16+2,Y     ; ADD BYTE 3     STA     XX64          ; SAVE FAC1 MANTISSA3     LDA     XX63          ; GET FAC1 MANTISSA 2     ADC     XXDF16+1,Y     ; ADD BYTE 2     STA     XX63          ; SAVE FAC1 MANTISSA2     LDA     XX62          ; GET FAC1 MANTISSA 1     ADC     XXDF16+0,Y     ; ADD BYTE 1, MOST SIGNIFICANT     STA     XX62          ; SAVE FAC1 MANTISSA1     INX                    ; INCREMENT THE DIGIT, SET THE SIGN ON THE TEST SENSE BIT     BCS     XXDE8E          ; IF THE CARRY IS SET GO TEST IF THE RESULT WAS POSITIVE                         ; ELSE THE RESULT NEEDS TO BE NEGATIVE     BPL     XXDE6A          ; NOT -VE SO TRY AGAIN     BMI     XXDE90          ; ELSE DONE SO RETURN THE DIGITXXDE8E = *     BMI     XXDE6A          ; NOT +VE SO TRY AGAIN; ELSE DONE SO RETURN THE DIGITXXDE90 = *     TXA                    ; COPY THE DIGIT     BCC     XXDE97          ; IF CB=0 JUST USE IT     EOR     #$FF               ; ELSE MAKE THE 2'S COMPLEMENT ..     ADC     #$0A               ; .. AND SUBTRACT IT FROM 10XXDE97 = *     ADC     #$2F ;#'0'-1          ; ADD '0'-1 TO RESULT     INY                    ; INCREMENT ..     INY                    ; .. INDEX TO..     INY                    ; .. NEXT LESS ..     INY                    ; .. POWER OF TEN     STY     XX47          ; SAVE THE POWERS OF TEN TABLE INDEX     LDY     XX71          ; GET OUTPUT STRING INDEX     INY                    ; INCREMENT OUTPUT STRING INDEX     TAX                    ; COPY CHARACTER TO X     AND     #$7F               ; MASK OUT TOP BIT     STA     XX0100-1,Y     ; SAVE TO OUTPUT STRING     DEC     XX5D          ; DECREMENT # OF CHARACTERS BEFORE THE DP     BNE     XXDEB2          ; IF STILL CHARACTERS TO DO SKIP THE DECIMAL POINT                         ; ELSE OUTPUT THE POINT     LDA     #'.'               ; CHARACTER '.'     INY                    ; INCREMENT OUTPUT STRING INDEX     STA     XX0100-1,Y     ; SAVE TO OUTPUT STRINGXXDEB2 = *     STY     XX71          ; SAVE THE OUTPUT STRING INDEX     LDY     XX47          ; GET THE POWERS OF TEN TABLE INDEX     TXA                    ; GET THE CHARACTER BACK     EOR     #$FF               ; TOGGLE THE TEST SENSE BIT     AND     #$80               ; CLEAR THE DIGIT     TAX                    ; COPY IT TO THE NEW DIGIT     CPY     #XXDF3A-XXDF16                                        ; COMPARE THE TABLE INDEX WITH THE MAX FOR DECIMAL NUMBERS     BEQ     XXDEC4          ; IF AT THE MAX EXIT THE DIGIT LOOP     CPY     #XXDF52-XXDF16                         ; COMPARE THE TABLE INDEX WITH THE MAX FOR TIME     BNE     XXDE6A          ; LOOP IF NOT AT THE MAX; NOW REMOVE TRAILING ZEROESXXDEC4 = *     LDY     XX71          ; RESTORE THE OUTPUT STRING INDEXXXDEC6 = *     LDA     XX0100-1,Y     ; GET CHARACTER FROM OUTPUT STRING     DEY                    ; DECREMENT OUTPUT STRING INDEX     CMP     #'0'               ; COMPARE WITH '0'     BEQ     XXDEC6          ; LOOP UNTIL NON '0' CHARACTER FOUND     CMP     #'.'               ; COMPARE WITH '.'     BEQ     XXDED3          ; BRANCH IF WAS DP                         ; RESTORE LAST CHARACTER     INY                    ; INCREMENT OUTPUT STRING INDEXXXDED3 = *     LDA     #'+'               ; CHARACTER '+'     LDX     XX5E          ; GET EXPONENT COUNT     BEQ     XXDF07          ; IF ZERO GO SET NULL TERMINATOR AND EXIT                         ; EXPONENT ISN'T ZERO SO WRITE EXPONENT     BPL     XXDEE3          ; BRANCH IF EXPONENT COUNT +VE     LDA     #$00               ; CLEAR A     SEC                    ; SET CARRY FOR SUBTRACT     SBC     XX5E          ; SUBTRACT EXPONENT COUNT ADJUST (CONVERT -VE TO +VE)     TAX                    ; COPY EXPONENT COUNT TO X     LDA     #'-'               ; CHARACTER '-'XXDEE3 = *     STA     XX0100+1,Y     ; SAVE TO OUTPUT STRING     LDA     #'E'               ; CHARACTER 'E'     STA     XX0100,Y          ; SAVE EXPONENT SIGN TO OUTPUT STRING     TXA                    ; GET EXPONENT COUNT BACK     LDX     #$2F               ; ONE LESS THAN '0' CHARACTER     SEC                    ; SET CARRY FOR SUBTRACTXXDEEF = *     INX                    ; INCREMENT 10'S CHARACTER     SBC     #$0A               ; SUBTRACT 10 FROM EXPONENT COUNT     BCS     XXDEEF          ; LOOP WHILE STILL >= 0     ADC     #':'               ; ADD CHARACTER ':' ($30+$0A, RESULT IS 10 LESS THAT VALUE)     STA     XX0100+3,Y     ; SAVE TO OUTPUT STRING     TXA                    ; COPY 10'S CHARACTER     STA     XX0100+2,Y     ; SAVE TO OUTPUT STRING     LDA     #$00               ; SET NULL TERMINATOR     STA     XX0100+4,Y     ; SAVE TO OUTPUT STRING     BEQ     XXDF0C          ; GO SET STRING POINTER (AY) AND EXIT, BRANCH ALWAYS                         ; SAVE LAST CHARACTER, [EOT] AND EXITXXDF04 = *     STA     XX0100-1,Y     ; SAVE LAST CHARACTER TO OUTPUT STRING                         ; SET NULL TERMINATOR AND EXITXXDF07 = *     LDA     #$00               ; SET NULL TERMINATOR     STA     XX0100,Y          ; SAVE AFTER LAST CHARACTER                         ; SET STRING POINTER (AY) AND EXITXXDF0C = *     LDA     #<XX0100          ; SET RESULT STRING POINTER LOW BYTE     LDY     #>XX0100          ; SET RESULT STRING POINTER HIGH BYTE     RTS;***********************************************************************************;;XXDF11 = *     .BYTE     $80,$00          ; 0.5, FIRST TWO BYTESXXDF13 = *     .BYTE     $00,$00,$00          ; NULL RETURN FOR UNDEFINED VARIABLES; DECIMAL CONVERSION TABLSXXDF16 = *     .BYTE     $FA,$0A,$1F,$00     ; -100000000     .BYTE     $00,$98,$96,$80     ;  +10000000     .BYTE     $FF,$F0,$BD,$C0     ;   -1000000     .BYTE     $00,$01,$86,$A0     ;    +100000     .BYTE     $FF,$FF,$D8,$F0     ;     -10000     .BYTE     $00,$00,$03,$E8     ;      +1000     .BYTE     $FF,$FF,$FF,$9C     ;       -100     .BYTE     $00,$00,$00,$0A     ;        +10     .BYTE     $FF,$FF,$FF,$FF     ;         -1; JIFFY COUNT CONVERSION TABLEXXDF3A = *     .BYTE     $FF,$DF,$0A,$80     ; -2160000     10S HOURS     .BYTE     $00,$03,$4B,$C0     ;  +216000         HOURS     .BYTE     $FF,$FF,$73,$60     ;   -36000     10S MINS     .BYTE     $00,$00,$0E,$10     ;    +3600         MINS     .BYTE     $FF,$FF,$FD,$A8     ;     -600     10S SECS     .BYTE     $00,$00,$00,$3C     ;      +60         SECSXXDF52 = *;***********************************************************************************;;; SPARE BYTES, NOT REFERENCED     .BYTE     $BF,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA     .BYTE     $AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA;***********************************************************************************;;; PERFORM SQR()XXDF71 = *     JSR     XXDC0C          ; ROUND AND COPY FAC1 TO FAC2     LDA     #<XXDF11          ; SET 0.5 POINTER LOW ADDRESS     LDY     #>XXDF11          ; SET 0.5 POINTER HIGH ADDRESS     JSR     XXDBA2          ; UNPACK MEMORY (AY) INTO FAC1;***********************************************************************************;;; PERFORM POWER FUNCTIONXXDF7B = *     BEQ     XXDFED          ; PERFORM EXP()     LDA     XX69          ; GET FAC2 EXPONENT     BNE     XXDF84          ; BRANCH IF FAC2<>0     JMP     XXD8F9          ; CLEAR FAC1 EXPONENT AND SIGN AND RETURNXXDF84 = *     LDX     #<XX4E          ; SET DESTINATION POINTER LOW BYTE     LDY     #>XX4E          ; SET DESTINATION POINTER HIGH BYTE     JSR     XXDBD4          ; PACK FAC1 INTO (XY)     LDA     XX6E          ; GET FAC2 SIGN (B7)     BPL     XXDF9E          ; BRANCH IF FAC2>0                         ; ELSE FAC2 IS -VE AND CAN ONLY BE RAISED TO AN                         ; INTEGER POWER WHICH GIVES AN X + J0 RESULT     JSR     XXDCCC          ; PERFORM INT()     LDA     #<XX4E          ; SET SOURCE POINTER LOW BYTE     LDY     #>XX4E          ; SET SOURCE POINTER HIGH BYTE     JSR     XXDC5B          ; COMPARE FAC1 WITH (AY)     BNE     XXDF9E          ; BRANCH IF FAC1 <> (AY) TO ALLOW FUNCTION CALL ERROR                         ; THIS WILL LEAVE FAC1 -VE AND CAUSE A FUNCTION CALL                         ; ERROR WHEN LOG() IS CALLED     TYA                    ; CLEAR SIGN B7     LDY     XX07          ; GET FAC1 MANTISSA 4 FROM INT() FUNCTION AS SIGN IN                         ; Y FOR POSSIBLE LATER NEGATION, B0 ONLY NEEDEDXXDF9E = *     JSR     XXDBFE          ; SAVE FAC1 SIGN AND COPY ABS(FAC2) TO FAC1     TYA                    ; COPY SIGN BACK ..     PHA                    ; .. AND SAVE IT     JSR     XXD9EA          ; PERFORM LOG()     LDA     #<XX4E          ; SET POINTER LOW BYTE     LDY     #>XX4E          ; SET POINTER HIGH BYTE     JSR     XXDA28          ; DO CONVERT AY, FCA1*(AY)     JSR     XXDFED          ; PERFORM EXP()     PLA                    ; PULL SIGN FROM STACK     LSR A                  ; B0 IS TO BE TESTED     BCC     XXDFBE          ; IF NO BIT THEN EXIT; DO - FAC1XXDFB4 = *     LDA     XX61          ; GET FAC1 EXPONENT     BEQ     XXDFBE          ; EXIT IF FAC1_E = $00     LDA     XX66          ; GET FAC1 SIGN (B7)     EOR     #$FF               ; COMPLEMENT IT     STA     XX66          ; SAVE FAC1 SIGN (B7)XXDFBE = *     RTS;***********************************************************************************;;; EXP(N) CONSTANT AND SERIESXXDFBF = *     .BYTE     $81,$38,$AA,$3B,$29     ; 1.443XXDFC4 = *     .BYTE     $07                    ; SERIES COUNT     .BYTE     $71,$34,$58,$3E,$56     ; 2.14987637E-5     .BYTE     $74,$16,$7E,$B3,$1B     ; 1.43523140E-4     .BYTE     $77,$2F,$EE,$E3,$85     ; 1.34226348E-3     .BYTE     $7A,$1D,$84,$1C,$2A     ; 9.61401701E-3     .BYTE     $7C,$63,$59,$58,$0A     ; 5.55051269E-2     .BYTE     $7E,$75,$FD,$E7,$C6     ; 2.40226385E-1     .BYTE     $80,$31,$72,$18,$10     ; 6.93147186E-1     .BYTE     $81,$00,$00,$00,$00     ; 1.00000000;***********************************************************************************;;; PERFORM EXP()XXDFED = *     LDA     #<XXDFBF          ; SET 1.443 POINTER LOW BYTE     LDY     #>XXDFBF          ; SET 1.443 POINTER HIGH BYTE     JSR     XXDA28          ; DO CONVERT AY, FCA1*(AY)     LDA     XX70          ; GET FAC1 ROUNDING BYTE     ADC     #$50               ; +$50/$100     BCC     XXDFFD          ; SKIP ROUNDING IF NO CARRY     JSR     XXDC23          ; ROUND FAC1 (NO CHECK)XXDFFD = *     STA     XX56          ; SAVE FAC2 ROUNDING BYTE     JSR     XXDC0F          ; COPY FAC1 TO FAC2     LDA     XX61          ; GET FAC1 EXPONENT     CMP     #$88               ; COMPARE WITH EXP LIMIT (256D)     BCC     XXE00B          ; BRANCH IF LESSXXE008 = *     JSR     XXDAD4          ; HANDLE OVERFLOW AND UNDERFLOWXXE00B = *     JSR     XXDCCC          ; PERFORM INT()     LDA     XX07          ; GET MANTISSA 4 FROM INT()     CLC                    ; CLEAR CARRY FOR ADD     ADC     #$81               ; NORMALISE +1     BEQ     XXE008          ; IF $00 RESULT HAS OVERFLOWED SO GO HANDLE IT     SEC                    ; SET CARRY FOR SUBTRACT     SBC     #$01               ; EXPONENT NOW CORRECT     PHA                    ; SAVE FAC2 EXPONENT                         ; SWAP FAC1 AND FAC2     LDX     #$05               ; 4 BYTES TO DOXXE01B = *     LDA     XX69,X          ; GET FAC2,X     LDY     XX61,X          ; GET FAC1,X     STA     XX61,X          ; SAVE FAC1,X     STY     XX69,X          ; SAVE FAC2,X     DEX                    ; DECREMENT COUNT/INDEX     BPL     XXE01B          ; LOOP IF NOT ALL DONE     LDA     XX56          ; GET FAC2 ROUNDING BYTE     STA     XX70          ; SAVE AS FAC1 ROUNDING BYTE     JSR     XXD853          ; PERFORM SUBTRACTION, FAC2 FROM FAC1     JSR     XXDFB4          ; DO - FAC1     LDA     #<XXDFC4          ; SET COUNTER POINTER LOW BYTE     LDY     #>XXDFC4          ; SET COUNTER POINTER HIGH BYTE     JSR     XXE056          ; GO DO SERIES EVALUATION     LDA     #$00               ; CLEAR A     STA     XX6F          ; CLEAR SIGN COMPARE (FAC1 EOR FAC2)     PLA                    ; PULL THE SAVED FAC2 EXPONENT     JSR     XXDAB9          ; TEST AND ADJUST ACCUMULATORS     RTS;***********************************************************************************;;; ^2 THEN SERIES EVALUATIONXXE040 = *     STA     XX71          ; SAVE COUNT POINTER LOW BYTE     STY     XX72          ; SAVE COUNT POINTER HIGH BYTE     JSR     XXDBCA          ; PACK FAC1 INTO XX57     LDA     #<XX57          ; SET POINTER LOW BYTE (Y ALREADY $00)     JSR     XXDA28          ; DO CONVERT AY, FCA1*(AY)     JSR     XXE05A          ; GO DO SERIES EVALUATION     LDA     #<XX57          ; POINTER TO ORIGINAL # LOW BYTE     LDY     #>XX57          ; POINTER TO ORIGINAL # HIGH BYTE     JMP     XXDA28          ; DO CONVERT AY, FCA1*(AY);***********************************************************************************;;; DO SERIES EVALUATIONXXE056 = *     STA     XX71          ; SAVE COUNT POINTER LOW BYTE     STY     XX72          ; SAVE COUNT POINTER HIGH BYTE; DO SERIES EVALUATIONXXE05A = *     JSR     XXDBC7          ; PACK FAC1 INTO XX5C     LDA     (XX71),Y          ; GET CONSTANTS COUNT     STA     XX67          ; SAVE CONSTANTS COUNT     LDY     XX71          ; GET COUNT POINTER LOW BYTE     INY                    ; INCREMENT IT (NOW CONSTANTS POINTER)     TYA                    ; COPY IT     BNE     XXE069          ; SKIP NEXT IF NO OVERFLOW     INC     XX72          ; ELSE INCREMENT HIGH BYTEXXE069 = *     STA     XX71          ; SAVE LOW BYTE     LDY     XX72          ; GET HIGH BYTEXXE06D = *     JSR     XXDA28          ; DO CONVERT AY, FCA1*(AY)     LDA     XX71          ; GET CONSTANTS POINTER LOW BYTE     LDY     XX72          ; GET CONSTANTS POINTER HIGH BYTE     CLC                    ; CLEAR CARRY FOR ADD     ADC     #$05               ; +5 TO LOW POINTER (5 BYTES PER CONSTANT)     BCC     XXE07A          ; SKIP NEXT IF NO OVERFLOW     INY                    ; INCREMENT HIGH BYTEXXE07A = *     STA     XX71          ; SAVE POINTER LOW BYTE     STY     XX72          ; SAVE POINTER HIGH BYTE     JSR     XXD867          ; ADD (AY) TO FAC1     LDA     #<XX5C          ; SET POINTER LOW BYTE TO PARTIAL     LDY     #>XX5C          ; SET POINTER HIGH BYTE TO PARTIAL     DEC     XX67          ; DECREMENT CONSTANTS COUNT     BNE     XXE06D          ; LOOP UNTIL ALL DONE     RTS;***********************************************************************************;;; RND VALUESXXE08A = *     .BYTE     $98,$35,$44,$7A,$00                         ; 11879546               MULTIPLIERXXE08F = *     .BYTE     $68,$28,$B1,$46,$00                         ; 3.927677739E-8          OFFSET;***********************************************************************************;;; PERFORM RND()XXE094 = *     JSR     XXDC2B          ; GET FAC1 SIGN                         ; RETURN A = $FF -VE, A = $01 +VE     BMI     XXE0D0          ; IF N<0 COPY BYTE SWAPPED FAC1 INTO RND() SEED     BNE     XXE0BB          ; IF N>0 GET NEXT NUMBER IN RND() SEQUENCE                         ; ELSE N=0 SO GET THE RND() NUMBER FROM VIA 1 TIMERS     JSR     XXFFF3          ; RETURN BASE ADDRESS OF I/O DEVICES     STX     XX22          ; SAVE POINTER LOW BYTE     STY     XX23          ; SAVE POINTER HIGH BYTE     LDY     #$04               ; SET INDEX TO T1 LOW BYTE     LDA     (XX22),Y          ; GET T1 LOW BYTE     STA     XX62          ; SAVE FAC1 MANTISSA 1     INY                    ; INCREMENT INDEX     LDA     (XX22),Y          ; GET T1 HIGH BYTE     STA     XX64          ; SAVE FAC1 MANTISSA 3     LDY     #$08               ; SET INDEX TO T2 LOW BYTE     LDA     (XX22),Y          ; GET T2 LOW BYTE     STA     XX63          ; SAVE FAC1 MANTISSA 2     INY                    ; INCREMENT INDEX     LDA     (XX22),Y          ; GET T2 HIGH BYTE     STA     XX65          ; SAVE FAC1 MANTISSA 4     JMP     XXE0E0          ; SET EXPONENT AND EXITXXE0BB = *     LDA     #<XX008B          ; SET SEED POINTER LOW ADDRESS     LDY     #>XX008B          ; SET SEED POINTER HIGH ADDRESS     JSR     XXDBA2          ; UNPACK MEMORY (AY) INTO FAC1     LDA     #<XXE08A          ; SET 11879546 POINTER LOW BYTE     LDY     #>XXE08A          ; SET 11879546 POINTER HIGH BYTE     JSR     XXDA28          ; DO CONVERT AY, FCA1*(AY)     LDA     #<XXE08F          ; SET 3.927677739E-8 POINTER LOW BYTE     LDY     #>XXE08F          ; SET 3.927677739E-8 POINTER HIGH BYTE     JSR     XXD867          ; ADD (AY) TO FAC1XXE0D0 = *     LDX     XX65          ; GET FAC1 MANTISSA 4     LDA     XX62          ; GET FAC1 MANTISSA 1     STA     XX65          ; SAVE FAC1 MANTISSA 4     STX     XX62          ; SAVE FAC1 MANTISSA 1     LDX     XX63          ; GET FAC1 MANTISSA 2     LDA     XX64          ; GET FAC1 MANTISSA 3     STA     XX63          ; SAVE FAC1 MANTISSA 2     STX     XX64          ; SAVE FAC1 MANTISSA 3XXE0E0 = *     LDA     #$00               ; CLEAR BYTE     STA     XX66          ; CLEAR FAC1 SIGN (ALWAYS +VE)     LDA     XX61          ; GET FAC1 EXPONENT     STA     XX70          ; SAVE FAC1 ROUNDING BYTE     LDA     #$80               ; SET EXPONENT = $80     STA     XX61          ; SAVE FAC1 EXPONENT     JSR     XXD8D7          ; NORMALISE FAC1     LDX     #<XX008B          ; SET SEED POINTER LOW ADDRESS     LDY     #>XX008B          ; SET SEED POINTER HIGH ADDRESS;***********************************************************************************;;; PACK FAC1 INTO (XY)XXE0F3 = *     JMP     XXDBD4          ; PACK FAC1 INTO (XY);***********************************************************************************;;; HANDLE BASIC I/O ERRORXXE0F6 = *     CMP     #$F0               ; COMPARE ERROR WITH $F0     BNE     XXE101          ; BRANCH IF NOT $F0     STY     XX38          ; SET END OF MEMORY HIGH BYTE     STX     XX37          ; SET END OF MEMORY LOW BYTE     JMP     XXC663          ; CLEAR FROM START TO END AND RETURN                         ; ERROR WAS NOT $F0XXE101 = *     TAX                    ; COPY ERROR #     BNE     XXE106          ; BRANCH IF NOT $00     LDX     #$1E               ; ELSE ERROR $1E, BREAK ERRORXXE106 = *     JMP     XXC437          ; DO ERROR #X THEN WARM START;***********************************************************************************;;; OUTPUT CHARACTER TO CHANNEL WITH ERROR CHECKXXE109 = *     JSR     XXFFD2          ; OUTPUT CHARACTER TO CHANNEL     BCS     XXE0F6          ; IF ERROR GO HANDLE BASIC I/O ERROR     RTS;***********************************************************************************;;; INPUT CHARACTER FROM CHANNEL WITH ERROR CHECKXXE10F = *     JSR     XXFFCF          ; INPUT CHARACTER FROM CHANNEL     BCS     XXE0F6          ; IF ERROR GO HANDLE BASIC I/O ERROR     RTS;***********************************************************************************;;; OPEN CHANNEL FOR OUTPUT WITH ERROR CHECKXXE115 = *     JSR     XXFFC9          ; OPEN CHANNEL FOR OUTPUT     BCS     XXE0F6          ; IF ERROR GO HANDLE BASIC I/O ERROR     RTS;***********************************************************************************;;; OPEN CHANNEL FOR INPUT WITH ERROR CHECKXXE11B = *     JSR     XXFFC6          ; OPEN CHANNEL FOR INPUT     BCS     XXE0F6          ; IF ERROR GO HANDLE BASIC I/O ERROR     RTS;***********************************************************************************;;; GET CHARACTER FROM INPUT DEVICE WITH ERROR CHECKXXE121 = *     JSR     XXFFE4          ; GET CHARACTER FROM INPUT DEVICE     BCS     XXE0F6          ; IF ERROR GO HANDLE BASIC I/O ERROR     RTS;***********************************************************************************;;; PERFORM SYSXXE127 = *     JSR     XXCD8A          ; EVALUATE EXPRESSION AND CHECK IS NUMERIC, ELSE DO                         ; TYPE MISMATCH     JSR     XXD7F7          ; CONVERT FAC_1 TO INTEGER IN TEMPORARY INTEGER     LDA     #>XXE143          ; GET RETURN ADDRESS HIGH BYTE     PHA                    ; PUSH AS RETURN ADDRESS     LDA     #<XXE143          ; GET RETURN ADDRESS LOW BYTE     PHA                    ; PUSH AS RETURN ADDRESS     LDA     XX030F          ; GET SAVED STATUS REGISTER     PHA                    ; PUT ON STACK     LDA     XX030C          ; GET SAVED A     LDX     XX030D          ; GET SAVED X     LDY     XX030E          ; GET SAVED Y     PLP                    ; PULL PROCESSOR STATUS     JMP     (XX14)          ; CALL SYS ADDRESS; TAIL END OF THE SYS CODE;; THE XXE143 IS NEEDED BECAUSE THE FOLLOWING CODE IS TO BE EXECUTED ONCE THE USER CODE; RETURNS. THIS IS DONE BY PUSHING THE TARGET RETURN ADDRESS - 1 ONTO THE STACKXXE143     = *-1;XXE144     PHP                    ; SAVE STATUS     STA     XX030C          ; SAVE RETURNED A     STX     XX030D          ; SAVE RETURNED X     STY     XX030E          ; SAVE RETURNED Y     PLA                    ; RESTORE SAVED STATUS     STA     XX030F          ; SAVE STATUS     RTS;***********************************************************************************;;; PERFORM SAVEXXE153 = *     JSR     XXE1D1          ; GET PARAMETERS FOR LOAD/SAVE     LDX     XX2D          ; GET START OF VARIABLES LOW BYTE     LDY     XX2E          ; GET START OF VARIABLES HIGH BYTE     LDA     #XX2B          ; INDEX TO START OF PROGRAM MEMORY     JSR     XXFFD8          ; SAVE RAM TO DEVICE, A = INDEX TO START ADDRESS, XY = END                         ; ADDRESS LOW/HIGH     BCS     XXE0F6          ; IF ERROR GO HANDLE BASIC I/O ERROR     RTS;***********************************************************************************;;; PERFORM VERIFYXXE162 = *     LDA     #$01               ; FLAG VERIFY     .BYTE     $2C               ; MAKES NEXT LINE BIT XX00A9;***********************************************************************************;;; PERFORM LOADXXE165 = *     LDA     #$00               ; FLAG LOAD     STA     XX0A          ; SET LOAD/VERIFY FLAG     JSR     XXE1D1          ; GET PARAMETERS FOR LOAD/SAVE     LDA     XX0A          ; GET LOAD/VERIFY FLAG     LDX     XX2B          ; GET START OF MEMORY LOW BYTE     LDY     XX2C          ; GET START OF MEMORY HIGH BYTE     JSR     XXFFD5          ; LOAD RAM FROM A DEVICE     BCS     XXE1CE          ; IF ERROR GO HANDLE BASIC I/O ERROR     LDA     XX0A          ; GET LOAD/VERIFY FLAG     BEQ     XXE195          ; BRANCH IF LOAD     LDX     #$1C               ; ERROR $1C, VERIFY ERROR     JSR     XXFFB7          ; READ I/O STATUS WORD     AND     #$10               ; MASK FOR TAPE READ ERROR     BEQ     XXE187          ; BRANCH IF NO READ ERROR     JMP     XXC437          ; DO ERROR #X THEN WARM STARTXXE187 = *     LDA     XX7A          ; GET BASIC EXECUTE POINTER LOW BYTE                         ; IS THIS CORRECT ?? WON'T THIS MEAN THE 'OK' PROMPT                         ; WHEN DOING A LOAD FROM WITHIN A PROGRAM ?     CMP     #$02               ;.     BEQ     XXE194          ; IF ?? SKIP 'OK' PROMPT     LDA     #<XXC364          ; SET 'OK' POINTER LOW BYTE     LDY     #>XXC364          ; SET 'OK' POINTER HIGH BYTE     JMP     XXCB1E          ; PRINT NULL TERMINATED STRINGXXE194 = *     RTS;***********************************************************************************;;; DO READY RETURN TO BASIC ??XXE195 = *     JSR     XXFFB7          ; READ I/O STATUS WORD     AND     #$BF               ; MASK X0XX XXXX, CLEAR READ ERROR     BEQ     XXE1A1          ; BRANCH IF NO ERRORS     LDX     #$1D               ; ERROR $1D, LOAD ERROR     JMP     XXC437          ; DO ERROR #X THEN WARM STARTXXE1A1 = *     LDA     XX7B          ; GET BASIC EXECUTE POINTER HIGH BYTE     CMP     #$02               ; COMPARE WITH $02XX     BNE     XXE1B5          ; BRANCH IF NOT IMMEDIATE MODE     STX     XX2D          ; SET START OF VARIABLES LOW BYTE     STY     XX2E          ; SET START OF VARIABLES HIGH BYTE     LDA     #<XXC376          ; SET 'READY.' POINTER LOW BYTE     LDY     #>XXC376          ; SET 'READY.' POINTER HIGH BYTE     JSR     XXCB1E          ; PRINT NULL TERMINATED STRING     JMP     XXC52A          ; RESET EXECUTION, CLEAR VARIABLES, FLUSH STACK,                         ; REBUILD BASIC CHAIN AND DO WARM STARTXXE1B5 = *     JSR     XXC68E          ; SET BASIC EXECUTE POINTER TO START OF MEMORY - 1     JMP     XXE476          ; REBUILD BASIC LINE CHAINING, DO RESTORE AND RETURN;***********************************************************************************;;; PERFORM OPENXXE1BB = *     JSR     XXE216          ; GET PARAMETERS FOR OPEN/CLOSE     JSR     XXFFC0          ; OPEN A LOGICAL FILE     BCS     XXE1CE          ; BRANCH IF ERROR     RTS;***********************************************************************************;;; PERFORM CLOSEXXE1C4 = *     JSR     XXE216          ; GET PARAMETERS FOR OPEN/CLOSE     LDA     XX49          ; GET LOGICAL FILE NUMBER     JSR     XXFFC3          ; CLOSE A SPECIFIED LOGICAL FILE     BCC     XXE194          ; EXIT IF NO ERRORXXE1CE = *     JMP     XXE0F6          ; GO HANDLE BASIC I/O ERROR;***********************************************************************************;;; GET PARAMETERS FOR LOAD/SAVEXXE1D1 = *     LDA     #$00               ; CLEAR FILE NAME LENGTH     JSR     XXFFBD          ; CLEAR FILENAME     LDX     #$01               ; SET DEFAULT DEVICE NUMBER, CASSETTE     LDY     #$00               ; SET DEFAULT COMMAND     JSR     XXFFBA          ; SET LOGICAL, FIRST AND SECOND ADDRESSES     JSR     XXE203          ; EXIT FUNCTION IF [EOT] OR ':'     JSR     XXE254          ; SET FILENAME     JSR     XXE203          ; EXIT FUNCTION IF [EOT] OR ':'     JSR     XXE1FD          ; SCAN AND GET BYTE, ELSE DO SYNTAX ERROR THEN WARM START     LDY     #$00               ; CLEAR COMMAND     STX     XX49          ; SAVE DEVICE NUMBER     JSR     XXFFBA          ; SET LOGICAL, FIRST AND SECOND ADDRESSES     JSR     XXE203          ; EXIT FUNCTION IF [EOT] OR ':'     JSR     XXE1FD          ; SCAN AND GET BYTE, ELSE DO SYNTAX ERROR THEN WARM START     TXA                    ; COPY COMMAND TO A     TAY                    ; COPY COMMAND TO Y     LDX     XX49          ; GET DEVICE NUMBER BACK     JMP     XXFFBA          ; SET LOGICAL, FIRST AND SECOND ADDRESSES AND RETURN;***********************************************************************************;;; SCAN AND GET BYTE, ELSE DO SYNTAX ERROR THEN WARM STARTXXE1FD = *     JSR     XXE20B          ; SCAN FOR ',BYTE', ELSE DO SYNTAX ERROR THEN WARM START     JMP     XXD79E          ; GET BYTE PARAMETER AND RETURN;***********************************************************************************;;; EXIT FUNCTION IF [EOT] OR ':'XXE203 = *     JSR     XX0079          ; SCAN MEMORY     BNE     XXE20A          ; BRANCH IF NOT [EOL] OR ':'     PLA                    ; DUMP RETURN ADDRESS LOW BYTE     PLA                    ; DUMP RETURN ADDRESS HIGH BYTEXXE20A = *     RTS;***********************************************************************************;;; SCAN FOR ',VALID BYTE', ELSE DO SYNTAX ERROR THEN WARM STARTXXE20B = *     JSR     XXCEFD          ; SCAN FOR ',', ELSE DO SYNTAX ERROR THEN WARM START; SCAN FOR VALID BYTE, NOT [EOL] OR ':', ELSE DO SYNTAX ERROR THEN WARM STARTXXE20E = *     JSR     XX0079          ; SCAN MEMORY     BNE     XXE20A          ; EXIT IF FOLLOWING BYTE     JMP     XXCF08          ; ELSE DO SYNTAX ERROR THEN WARM START;***********************************************************************************;;; GET PARAMETERS FOR OPEN/CLOSEXXE216 = *     LDA     #$00               ; CLEAR FILE NAME LENGTH     JSR     XXFFBD          ; CLEAR FILENAME     JSR     XXE20E          ; SCAN FOR VALID BYTE, ELSE DO SYNTAX ERROR THEN WARM START     JSR     XXD79E          ; GET BYTE PARAMETER, LOGICAL FILE NUMBER     STX     XX49          ; SAVE LOGICAL FILE NUMBER     TXA                    ; COPY LOGICAL FILE NUMBER TO A     LDX     #$01               ; SET DEFAULT DEVICE NUMBER, CASSETTE     LDY     #$00               ; SET DEFAULT COMMAND     JSR     XXFFBA          ; SET LOGICAL, FIRST AND SECOND ADDRESSES     JSR     XXE203          ; EXIT FUNCTION IF [EOT] OR ':'     JSR     XXE1FD          ; SCAN AND GET BYTE, ELSE DO SYNTAX ERROR THEN WARM START     STX     XX4A          ; SAVE DEVICE NUMBER     LDY     #$00               ; CLEAR COMMAND     LDA     XX49          ; GET LOGICAL FILE NUMBER     CPX     #$03               ; COMPARE DEVICE NUMBER WITH SCREEN     BCC     XXE23C          ; BRANCH IF LESS THAN SCREEN     DEY                    ; ELSE DECREMENT COMMANDXXE23C = *     JSR     XXFFBA          ; SET LOGICAL, FIRST AND SECOND ADDRESSES     JSR     XXE203          ; EXIT FUNCTION IF [EOT] OR ':'     JSR     XXE1FD          ; SCAN AND GET BYTE, ELSE DO SYNTAX ERROR THEN WARM START     TXA                    ; COPY COMMAND TO A     TAY                    ; COPY COMMAND TO Y     LDX     XX4A          ; GET DEVICE NUMBER     LDA     XX49          ; GET LOGICAL FILE NUMBER     JSR     XXFFBA          ; SET LOGICAL, FIRST AND SECOND ADDRESSES     JSR     XXE203          ; EXIT FUNCTION IF [EOT] OR ':'     JSR     XXE20B          ; SCAN FOR ',BYTE', ELSE DO SYNTAX ERROR THEN WARM START;***********************************************************************************;;; SET FILENAMEXXE254 = *     JSR     XXCD9E          ; EVALUATE EXPRESSION     JSR     XXD6A3          ; EVALUATE STRING     LDX     XX22          ; GET STRING POINTER LOW BYTE     LDY     XX23          ; GET STRING POINTER HIGH BYTE     JMP     XXFFBD          ; SET FILENAME AND RETURN;***********************************************************************************;;; PERFORM COS()XXE261 = *     LDA     #<XXE2DD          ; SET PI/2 POINTER LOW BYTE     LDY     #>XXE2DD          ; SET PI/2 POINTER HIGH BYTE     JSR     XXD867          ; ADD (AY) TO FAC1;***********************************************************************************;;; PERFORM SIN()XXE268 = *     JSR     XXDC0C          ; ROUND AND COPY FAC1 TO FAC2     LDA     #<XXE2E2          ; SET 2*PI POINTER LOW BYTE     LDY     #>XXE2E2          ; SET 2*PI POINTER HIGH BYTE     LDX     XX6E          ; GET FAC2 SIGN (B7)     JSR     XXDB07          ; DIVIDE BY (AY) (X=SIGN)     JSR     XXDC0C          ; ROUND AND COPY FAC1 TO FAC2     JSR     XXDCCC          ; PERFORM INT()     LDA     #$00               ; CLEAR BYTE     STA     XX6F          ; CLEAR SIGN COMPARE (FAC1 EOR FAC2)     JSR     XXD853          ; PERFORM SUBTRACTION, FAC2 FROM FAC1     LDA     #<XXE2E7          ; SET 0.25 POINTER LOW BYTE     LDY     #>XXE2E7          ; SET 0.25 POINTER HIGH BYTE     JSR     XXD850          ; PERFORM SUBTRACTION, FAC1 FROM (AY)     LDA     XX66          ; GET FAC1 SIGN (B7)     PHA                    ; SAVE FAC1 SIGN     BPL     XXE29A          ; BRANCH IF +VE                         ; FAC1 SIGN WAS -VE     JSR     XXD849          ; ADD 0.5 TO FAC1 (ROUND FAC1)     LDA     XX66          ; GET FAC1 SIGN (B7)     BMI     XXE29D          ; BRANCH IF -VE     LDA     XX12          ; GET THE COMPARISON EVALUATION FLAG     EOR     #$FF               ; TOGGLE FLAG     STA     XX12          ; SAVE THE COMPARISON EVALUATION FLAGXXE29A = *     JSR     XXDFB4          ; DO - FAC1XXE29D = *     LDA     #<XXE2E7          ; SET 0.25 POINTER LOW BYTE     LDY     #>XXE2E7          ; SET 0.25 POINTER HIGH BYTE     JSR     XXD867          ; ADD (AY) TO FAC1     PLA                    ; RESTORE FAC1 SIGN     BPL     XXE2AA          ; BRANCH IF WAS +VE                         ; ELSE CORRECT FAC1     JSR     XXDFB4          ; DO - FAC1XXE2AA = *     LDA     #<XXE2EC          ; SET POINTER LOW BYTE TO COUNTER     LDY     #>XXE2EC          ; SET POINTER HIGH BYTE TO COUNTER     JMP     XXE040          ; ^2 THEN SERIES EVALUATION AND RETURN;***********************************************************************************;;; PERFORM TAN()XXE2B1 = *     JSR     XXDBCA          ; PACK FAC1 INTO XX57     LDA     #$00               ; CLEAR A     STA     XX12          ; CLEAR THE COMPARISON EVALUATION FLAG     JSR     XXE268          ; PERFORM SIN()     LDX     #<XX4E          ; SET SIN(N) POINTER LOW BYTE     LDY     #>XX4E          ; SET SIN(N) POINTER HIGH BYTE     JSR     XXE0F3          ; PACK FAC1 INTO (XY)     LDA     #<XX57          ; SET N POINTER LOW BYTE     LDY     #>XX57          ; SET N POINTER HIGH BYTE     JSR     XXDBA2          ; UNPACK MEMORY (AY) INTO FAC1     LDA     #$00               ; CLEAR BYTE     STA     XX66          ; CLEAR FAC1 SIGN (B7)     LDA     XX12          ; GET THE COMPARISON EVALUATION FLAG     JSR     XXE2D9          ; SAVE FLAG AND GO DO SERIES EVALUATION     LDA     #<XX4E          ; SET SIN(N) POINTER LOW BYTE     LDY     #>XX4E          ; SET SIN(N) POINTER HIGH BYTE     JMP     XXDB0F          ; CONVERT AY AND DO (AY)/FAC1;***********************************************************************************;;; SAVE COMPARISON FLAG AND DO SERIES EVALUATIONXXE2D9 = *     PHA                    ; SAVE COMPARISON FLAG     JMP     XXE29A          ; ADD 0.25, ^2 THEN SERIES EVALUATION;***********************************************************************************;;; CONSTANTS AND SERIES FOR SIN/COS(N)XXE2DD = *     .BYTE     $81,$49,$0F,$DA,$A2     ; 1.570796371, PI/2, AS FLOATING NUMBERXXE2E2 = *     .BYTE     $83,$49,$0F,$DA,$A2     ; 6.28319, 2*PI, AS FLOATING NUMBERXXE2E7 = *     .BYTE     $7F,$00,$00,$00,$00     ; 0.25XXE2EC = *     .BYTE     $05                    ; SERIES COUNTER     .BYTE     $84,$E6,$1A,$2D,$1B     ; -14.3813907     .BYTE     $86,$28,$07,$FB,$F8     ;  42.0077971     .BYTE     $87,$99,$68,$89,$01     ; -76.7041703     .BYTE     $87,$23,$35,$DF,$E1     ;  81.6052237     .BYTE     $86,$A5,$5D,$E7,$28     ; -41.3417021     .BYTE     $83,$49,$0F,$DA,$A2     ;  6.28318531;***********************************************************************************;;; PERFORM ATN()XXE30B = *     LDA     XX66          ; GET FAC1 SIGN (B7)     PHA                    ; SAVE SIGN     BPL     XXE313          ; BRANCH IF +VE     JSR     XXDFB4          ; ELSE DO - FAC1XXE313 = *     LDA     XX61          ; GET FAC1 EXPONENT     PHA                    ; PUSH EXPONENT     CMP     #$81               ; COMPARE WITH 1     BCC     XXE321          ; BRANCH IF FAC1 < 1     LDA     #<XXD9BC          ; POINTER TO 1 LOW BYTE     LDY     #>XXD9BC          ; POINTER TO 1 HIGH BYTE     JSR     XXDB0F          ; CONVERT AY AND DO (AY)/FAC1XXE321 = *     LDA     #<XXE33B          ; POINTER TO SERIES LOW BYTE     LDY     #>XXE33B          ; POINTER TO SERIES HIGH BYTE     JSR     XXE040          ; ^2 THEN SERIES EVALUATION     PLA                    ; RESTORE OLD FAC1 EXPONENT     CMP     #$81               ; COMPARE WITH 1     BCC     XXE334          ; BRANCH IF FAC1 < 1     LDA     #<XXE2DD          ; POINTER TO (PI/2) LOW BYTE     LDY     #>XXE2DD          ; POINTER TO (PI/2) LOW BYTE     JSR     XXD850          ; PERFORM SUBTRACTION, FAC1 FROM (AY)XXE334 = *     PLA                    ; RESTORE FAC1 SIGN     BPL     XXE33A          ; EXIT IF WAS +VE     JMP     XXDFB4          ; ELSE DO - FAC1 AND RETURNXXE33A = *     RTS;***********************************************************************************;;; SERIES FOR ATN(N)XXE33B = *     .BYTE     $0B                    ; SERIES COUNTER     .BYTE     $76,$B3,$83,$BD,$D3     ;-6.84793912E-04     .BYTE     $79,$1E,$F4,$A6,$F5     ; 4.85094216E-03     .BYTE     $7B,$83,$FC,$B0,$10     ;-0.0161117015     .BYTE     $7C,$0C,$1F,$67,$CA     ; 0.034209638     .BYTE     $7C,$DE,$53,$CB,$C1     ;-0.054279133     .BYTE     $7D,$14,$64,$70,$4C     ; 0.0724571965     .BYTE     $7D,$B7,$EA,$51,$7A     ;-0.0898019185     .BYTE     $7D,$63,$30,$88,$7E     ; 0.110932413     .BYTE     $7E,$92,$44,$99,$3A     ;-0.142839808     .BYTE     $7E,$4C,$CC,$91,$C7     ; 0.19999912     .BYTE     $7F,$AA,$AA,$AA,$13     ;-0.333333316     .BYTE     $81,$00,$00,$00,$00     ; 1.000000000;***********************************************************************************;;; BASIC COLD START ENTRY POINTXXE378 = *     JSR     XXE45B          ; INITIALISE BASIC VECTOR TABLE     JSR     XXE3A4          ; INITIALISE BASIC RAM LOCATIONS     JSR     XXE404          ; PRINT START UP MESSAGE AND INITIALISE MEMORY POINTERS     LDX     #$FB               ; VALUE FOR START STACK     TXS                    ; SET STACK POINTER     JMP     XXC474          ; DO 'READY.' WARM START;***********************************************************************************;;; CHARACTER GET SUBROUTINE FOR ZERO PAGE; THE TARGET ADDRESS FOR THE LDA XXEA60 BECOMES THE BASIC EXECUTE POINTER ONCE THE; BLOCK IS COPIED TO IT'S DESTINATION, ANY NON ZERO PAGE ADDRESS WILL DO AT ASSEMBLY; TIME, TO ASSEMBLE A THREE BYTE INSTRUCTION.; PAGE 0 INITIALISATION TABLE FROM XX0073; INCREMENT AND SCAN MEMORYXXE387 = *     INC     XX7A          ; INCREMENT BASIC EXECUTE POINTER LOW BYTE     BNE     XXE38D          ; BRANCH IF NO CARRY                         ; ELSE     INC     XX7B          ; INCREMENT BASIC EXECUTE POINTER HIGH BYTE; PAGE 0 INITIALISATION TABLE FROM XX0079; SCAN MEMORYXXE38D = *     LDA     XXEA60          ; GET BYTE TO SCAN, ADDRESS SET BY CALL ROUTINE     CMP     #':'               ; COMPARE WITH ':'     BCS     XXE39E          ; EXIT IF>=; PAGE 0 INITIALISATION TABLE FROM XX0080; CLEAR CB IF NUMERIC     CMP     #' '               ; COMPARE WITH ' '     BEQ     XXE387          ; IF ' ' GO DO NEXT     SEC                    ; SET CARRY FOR SBC     SBC     #'0'               ; SUBTRACT '0'     SEC                    ; SET CARRY FOR SBC     SBC     #$D0               ; SUBTRACT -'0'                         ; CLEAR CARRY IF BYTE = '0'-'9'XXE39E = *     RTS;***********************************************************************************;;; SPARE BYTES, NOT REFERENCED;XXE39F     .BYTE     $80,$4F,$C7,$52,$58                         ; 0.811635157;***********************************************************************************;;; INITIALISE BASIC RAM LOCATIONSXXE3A4 = *     LDA     #$4C               ; OPCODE FOR JMP     STA     XX54          ; SAVE FOR FUNCTIONS VECTOR JUMP     STA     XX00          ; SAVE FOR USR() VECTOR JUMP                         ; SET USR() VECTOR TO ILLEGAL QUANTITY ERROR     LDA     #<XXD248          ; SET USR() VECTOR LOW BYTE     LDY     #>XXD248          ; SET USR() VECTOR HIGH BYTE     STA     XX01          ; SAVE USR() VECTOR LOW BYTE     STY     XX02          ; SAVE USR() VECTOR HIGH BYTE     LDA     #<XXD391          ; SET FIXED TO FLOAT VECTOR LOW BYTE     LDY     #>XXD391          ; SET FIXED TO FLOAT VECTOR HIGH BYTE     STA     XX05          ; SAVE FIXED TO FLOAT VECTOR LOW BYTE     STY     XX06          ; SAVE FIXED TO FLOAT VECTOR HIGH BYTE     LDA     #<XXD1AA          ; SET FLOAT TO FIXED VECTOR LOW BYTE     LDY     #>XXD1AA          ; SET FLOAT TO FIXED VECTOR HIGH BYTE     STA     XX03          ; SAVE FLOAT TO FIXED VECTOR LOW BYTE     STY     XX04          ; SAVE FLOAT TO FIXED VECTOR HIGH BYTE; COPY BLOCK FROM XXE387 TO XX0074     LDX     #$1C               ; SET BYTE COUNTXXE3C4 = *     LDA     XXE387,X          ; GET BYTE FROM TABLE     STA     XX0073,X          ; SAVE BYTE IN PAGE ZERO     DEX                    ; DECREMENT COUNT     BPL     XXE3C4          ; LOOP IF NOT ALL DONE     LDA     #$03               ; SET STEP SIZE, COLLECTING DESCRIPTORS     STA     XX53          ; SAVE GARBAGE COLLECTION STEP SIZE     LDA     #$00               ; CLEAR A     STA     XX68          ; CLEAR FAC1 OVERFLOW BYTE     STA     XX13          ; CLEAR CURRENT I/O CHANNEL, FLAG DEFAULT     STA     XX18          ; CLEAR CURRENT DESCRIPTOR STACK ITEM POINTER HIGH BYTE     LDX     #$01               ; SET X     STX     XX01FD          ; SET CHAIN LINK POINTER LOW BYTE     STX     XX01FC          ; SET CHAIN LINK POINTER HIGH BYTE     LDX     #XX19          ; INITIAL VALUE FOR DESCRIPTOR STACK     STX     XX16          ; SET DESCRIPTOR STACK POINTER     SEC                    ; SET CB = 1 TO READ THE BOTTOM OF MEMORY     JSR     XXFF9C          ; READ/SET THE BOTTOM OF MEMORY     STX     XX2B          ; SAVE START OF MEMORY LOW BYTE     STY     XX2C          ; SAVE START OF MEMORY HIGH BYTE     SEC                    ; SET CB = 1 TO READ THE TOP OF MEMORY     JSR     XXFF99          ; READ/SET THE TOP OF MEMORY     STX     XX37          ; SAVE END OF MEMORY LOW BYTE     STY     XX38          ; SAVE END OF MEMORY HIGH BYTE     STX     XX33          ; SET BOTTOM OF STRING SPACE LOW BYTE     STY     XX34          ; SET BOTTOM OF STRING SPACE HIGH BYTE     LDY     #$00               ; CLEAR INDEX     TYA                    ; CLEAR A     STA     (XX2B),Y          ; CLEAR FIRST BYTE OF MEMORY     INC     XX2B          ; INCREMENT START OF MEMORY LOW BYTE     BNE     XXE403          ; BRANCH IF NO ROLLOVER     INC     XX2C          ; INCREMENT START OF MEMORY HIGH BYTEXXE403 = *     RTS;***********************************************************************************;;; PRINT START UP MESSAGE AND INITIALISE MEMORY POINTERSXXE404 = *     LDA     XX2B          ; GET START OF MEMORY LOW BYTE     LDY     XX2C          ; GET START OF MEMORY HIGH BYTE     JSR     XXC408          ; CHECK AVAILABLE MEMORY, DO OUT OF MEMORY ERROR IF NO ROOM     LDA     #<XXE436          ; SET '**** CBM BASIC V2 ****' POINTER LOW BYTE     LDY     #>XXE436          ; SET '**** CBM BASIC V2 ****' POINTER HIGH BYTE     JSR     XXCB1E          ; PRINT NULL TERMINATED STRING     LDA     XX37          ; GET END OF MEMORY LOW BYTE     SEC                    ; SET CARRY FOR SUBTRACT     SBC     XX2B          ; SUBTRACT START OF MEMORY LOW BYTE     TAX                    ; COPY RESULT TO X     LDA     XX38          ; GET END OF MEMORY HIGH BYTE     SBC     XX2C          ; SUBTRACT START OF MEMORY HIGH BYTE     JSR     XXDDCD          ; PRINT XA AS UNSIGNED INTEGER     LDA     #<XXE429          ; SET ' BYTES FREE' POINTER LOW BYTE     LDY     #>XXE429          ; SET ' BYTES FREE' POINTER HIGH BYTE     JSR     XXCB1E          ; PRINT NULL TERMINATED STRING     JMP     XXC644          ; DO NEW, CLEAR, RESTORE AND RETURN;***********************************************************************************;;XXE429 = *     .BYTE     ' BYTES FREE',$0D,$00XXE436 = *     .BYTE     $93,'**** CBM BASIC V2 ****',$0D,$00;***********************************************************************************;;; BASIC VECTORS, THESE ARE COPIED TO RAM FROM XX0300 ONWARDSXXE44F = *     .WORD     XXC43A          ; ERROR MESSAGE                    XX0300     .WORD     XXC483          ; BASIC WARM START               XX0302     .WORD     XXC57C          ; CRUNCH BASIC TOKENS               XX0304     .WORD     XXC71A          ; UNCRUNCH BASIC TOKENS               XX0306     .WORD     XXC7E4          ; START NEW BASIC CODE               XX0308     .WORD     XXCE86          ; GET ARITHMETIC ELEMENT          XX030A;***********************************************************************************;;; INITIALISE BASIC VECTORSXXE45B = *     LDX     #$0B               ; SET BYTE COUNTXXE45D = *     LDA     XXE44F,X          ; GET BYTE FROM TABLE     STA     XX0300,X          ; SAVE BYTE TO RAM     DEX                    ; DECREMENT INDEX     BPL     XXE45D          ; LOOP IF MORE TO DO     RTS;***********************************************************************************;;; BASIC WARM START ENTRY POINTXXE467 = *     JSR     XXFFCC          ; CLOSE INPUT AND OUTPUT CHANNELS     LDA     #$00               ; CLEAR A     STA     XX13          ; SET CURRENT I/O CHANNEL, FLAG DEFAULT     JSR     XXC67A          ; FLUSH BASIC STACK AND CLEAR CONTINUE POINTER     CLI                    ; ENABLE INTERRUPTS     JMP     XXC474          ; DO WARM START;***********************************************************************************;;; CHECKSUM BYTE, NOT REFERENCED;XXE475     .BYTE     $E8               ; [PAL];     .BYTE     $41               ; [NTSC];***********************************************************************************;;; REBUILD BASIC LINE CHAINING AND DO RESTOREXXE476 = *     JSR     XXC533          ; REBUILD BASIC LINE CHAINING     JMP     XXC677          ; DO RESTORE, CLEAR STACK AND RETURN;***********************************************************************************;;; SPARE BYTES, NOT REFERENCED;XXE47C     .BYTE     $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF     .BYTE     $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF     .BYTE     $FF,$FF,$FF,$FF;***********************************************************************************;;; SET SERIAL DATA OUT HIGHXXE4A0 = *     LDA     XX912C          ; GET VIA 2 PCR     AND     #$DF               ; SET CB2 LOW, SERIAL DATA OUT HIGH     STA     XX912C          ; SET VIA 2 PCR     RTS;***********************************************************************************;;; SET SERIAL DATA OUT LOWXXE4A9 = *     LDA     XX912C          ; GET VIA 2 PCR     ORA     #$20               ; SET CB2 HIGH, SERIAL DATA OUT LOW     STA     XX912C          ; SET VIA 2 PCR     RTS;***********************************************************************************;;; GET SERIAL CLOCK STATUSXXE4B2 = *     LDA     XX911F          ; GET VIA 1 DRA, NO HANDSHAKE     CMP     XX911F          ; COMPARE WITH SELF     BNE     XXE4B2          ; LOOP IF CHANGING     LSR A                  ; SHIFT SERIAL CLOCK TO CB     RTS;***********************************************************************************;;; GET SECONDAY ADDRESS AND PRINT 'SEARCHING...'XXE4BC = *     LDX     XXB9          ; GET SECONDARY ADDRESS     JMP     XXF647          ; PRINT 'SEARCHING...' AND RETURN;***********************************************************************************;;; SET LOAD ADDRESS IF SECONDARY ADDRESS = 0XXE4C1 = *     TXA                    ; COPY SECONDARY ADDRESS     BNE     XXE4CC          ; LOAD LOCATION NOT SET IN LOAD CALL, SO                         ; CONTINUE WITH LOAD     LDA     XXC3          ; GET LOAD ADDRESS LOW BYTE     STA     XXAE          ; SAVE PROGRAM START ADDRESS LOW BYTE     LDA     XXC4          ; GET LOAD ADDRESS HIGH BYTE     STA     XXAF          ; SAVE PROGRAM START ADDRESS HIGH BYTEXXE4CC = *     JMP     XXF66A          ; DISPLAY 'LOADING' OR 'VERIFYING' AND RETURN;***********************************************************************************;;; PATCH FOR CLOSEXXE4CF = *     JSR     XXF8E3          ; INITIATE TAPE WRITE     BCC     XXE4D7          ; BRANCH IF NO ERROR     PLA                    ; ELSE DUMP STACKED EXIT CODE     LDA     #$00               ; CLEAR EXIT CODEXXE4D7 = *     JMP     XXF39E          ; GO DO I/O CLOSE;***********************************************************************************;;; SPARE BYTES, NOT REFERENCED;XXE4DA     .BYTE     $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF     .BYTE     $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF     .BYTE     $FF,$FF,$FF,$FF,$FF,$FF;***********************************************************************************;;; RETURN BASE ADDRESS OF I/O DEVICES; THIS ROUTINE WILL SET XY TO THE ADDRESS OF THE MEMORY SECTION WHERE THE MEMORY; MAPPED I/O DEVICES ARE LOCATED. THIS ADDRESS CAN THEN BE USED WITH AN OFFSET TO; ACCESS THE MEMORY MAPPED I/O DEVICES IN THE COMPUTER.XXE500 = *     LDX     #<XX9110          ; GET I/O BASE ADDRESS LOW BYTE     LDY     #>XX9110          ; GET I/O BASE ADDRESS HIGH BYTE     RTS;***********************************************************************************;;; RETURN X,Y ORGANIZATION OF SCREEN; THIS ROUTINE RETURNS THE X,Y ORGANISATION OF THE SCREEN IN X,YXXE505 = *     LDX     #$16               ; GET SCREEN X, 22 COLUMNS     LDY     #$17               ; GET SCREEN Y, 23 ROWS     RTS;***********************************************************************************;;; READ/SET X,Y CURSOR POSITION, CB = 1 TO READ, CB = 0 TO SET; THIS ROUTINE, WHEN CALLED WITH THE CARRY FLAG SET, LOADS THE CURRENT POSITION OF; THE CURSOR ON THE SCREEN INTO THE X AND Y REGISTERS. X IS THE COLUMN NUMBER OF; THE CURSOR LOCATION AND Y IS THE ROW NUMBER OF THE CURSOR. A CALL WITH THE CARRY; BIT CLEAR MOVES THE CURSOR TO THE POSITION DETERMINED BY THE X AND Y REGISTERS.XXE50A = *     BCS     XXE513          ; IF READ CURSOR SKIP THE SET CURSOR     STX     XXD6          ; SAVE CURSOR ROW     STY     XXD3          ; SAVE CURSOR COLUMN     JSR     XXE587          ; SET SCREEN POINTERS FOR CURSOR ROW, COLUMNXXE513 = *     LDX     XXD6          ; GET CURSOR ROW     LDY     XXD3          ; GET CURSOR COLUMN     RTS;***********************************************************************************;;; INITIALISE HARDWAREXXE518 = *     JSR     XXE5BB          ; SET DEFAULT DEVICES AND INITIALISE VIC CHIP     LDA     XX0288          ; GET SCREEN MEMORY PAGE     AND     #$FD               ; MASK XXXX XX0X, ALL BUT VA9     ASL A                  ; << 1 XXXX X0X0     ASL A                  ; << 2 XXXX 0X00     ORA     #$80               ; SET  1XXX 0X00     STA     XX9005          ; SET SCREEN AND CHARACTER MEMORY LOCATION     LDA     XX0288          ; GET SCREEN MEMORY PAGE     AND     #$02               ; MASK BIT 9     BEQ     XXE536          ; IF ZERO JUST GO NORMALISE SCREEN                         ; ELSE SET VA9 IN VIC CHIP     LDA     #$80               ; SET B7     ORA     XX9002          ; OR IN AS VIDEO ADDRESS 9     STA     XX9002          ; SAVE NEW VA9                         ; NOW NORMALISE SCREENXXE536 = *     LDA     #$00               ; CLEAR A     STA     XX0291          ; CLEAR SHIFT MODE SWITCH     STA     XXCF          ; CLEAR CURSOR BLINK PHASE     LDA     #<XXEBDC          ; GET KEYBOARD DECODE LOGIC POINTER LOW BYTE     STA     XX028F          ; SET KEYBOARD DECODE LOGIC POINTER LOW BYTE     LDA     #>XXEBDC          ; GET KEYBOARD DECODE LOGIC POINTER HIGH BYTE     STA     XX0290          ; SET KEYBOARD DECODE LOGIC POINTER HIGH BYTE     LDA     #$0A               ; 10D     STA     XX0289          ; SET MAXIMUM SIZE OF KEYBOARD BUFFER     STA     XX028C          ; SET REPEAT DELAY COUNTER     LDA     #$06               ; COLOUR BLUE     STA     XX0286          ; SET CURRENT COLOUR CODE     LDA     #$04               ; SPEED 4     STA     XX028B          ; SET REPEAT SPEED COUNTER     LDA     #$0C               ; CURSOR FLASH TIMING     STA     XXCD          ; SET CURSOR TIMING COUNTDOWN     STA     XXCC          ; SET CURSOR ENABLE, $00 = FLASH CURSOR; CLEAR SCREENXXE55F = *     LDA     XX0288          ; GET SCREEN MEMORY PAGE     ORA     #$80               ; SET HIGH BIT, FLAG EVERY LINE IS LOGICAL LINE START     TAY                    ; COPY TO Y     LDA     #$00               ; CLEAR LINE START LOW BYTE     TAX                    ; CLEAR INDEXXXE568 = *     STY     XXD9,X          ; SAVE START OF LINE X POINTER HIGH BYTE     CLC                    ; CLEAR CARRY FOR ADD     ADC     #$16               ; ADD LINE LENGTH TO LOW BYTE     BCC     XXE570          ; IF NO ROLLOVER SKIP THE HIGH BYTE INCREMENT     INY                    ; ELSE INCREMENT HIGH BYTEXXE570 = *     INX                    ; INCREMENT LINE INDEX     CPX     #$18               ; COMPARE WITH NUMBER OF LINES + 1     BNE     XXE568          ; LOOP IF NOT ALL DONE     LDA     #$FF               ; END OF TABLE MARKER ??     STA     XXD9,X          ; MARK END OF TABLE     LDX     #$16               ; SET LINE COUNT, 23 LINES TO DO, 0 TO 22XXE57B = *     JSR     XXEA8D          ; CLEAR SCREEN LINE X     DEX                    ; DECREMENT COUNT     BPL     XXE57B          ; LOOP IF MORE TO DO; HOME CURSORXXE581 = *     LDY     #$00               ; CLEAR Y     STY     XXD3          ; CLEAR CURSOR COLUMN     STY     XXD6          ; CLEAR CURSOR ROW; SET SCREEN POINTERS FOR CURSOR ROW, COLUMNXXE587 = *     LDX     XXD6          ; GET CURSOR ROW     LDA     XXD3          ; GET CURSOR COLUMNXXE58B = *     LDY     XXD9,X          ; GET START OF LINE X POINTER HIGH BYTE     BMI     XXE597          ; CONTINUE IF LOGICAL LINE START     CLC                    ; ELSE CLEAR CARRY FOR ADD     ADC     #$16               ; ADD ONE LINE LENGTH     STA     XXD3          ; SAVE CURSOR COLUMN     DEX                    ; DECREMENT CURSOR ROW     BPL     XXE58B          ; LOOP, BRANCH ALWAYSXXE597 = *     LDA     XXD9,X          ; GET START OF LINE X POINTER HIGH BYTE     AND     #$03               ; MASK 0000 00XX, LINE MEMORY PAGE     ORA     XX0288          ; OR WITH SCREEN MEMORY PAGE     STA     XXD2          ; SET CURRENT SCREEN LINE POINTER HIGH BYTE     LDA     XXEDFD,X          ; GET START OF LINE LOW BYTE FROM ROM TABLE     STA     XXD1          ; SET CURRENT SCREEN LINE POINTER LOW BYTE     LDA     #$15               ; SET LINE LENGTH     INX                    ; INCREMENT CURSOR ROWXXE5A8 = *     LDY     XXD9,X          ; GET START OF LINE X POINTER HIGH BYTE     BMI     XXE5B2          ; EXIT IF LOGICAL LINE START     CLC                    ; ELSE CLEAR CARRY FOR ADD     ADC     #$16               ; ADD ONE LINE LENGTH TO CURRENT LINE LENGTH     INX                    ; INCREMENT CURSOR ROW     BPL     XXE5A8          ; LOOP, BRANCH ALWAYSXXE5B2 = *     STA     XXD5          ; SAVE CURRENT SCREEN LINE LENGTH     RTS;***********************************************************************************;;; SET DEFAULT DEVICES, INITIALISE VIC CHIP AND HOME CURSOR;; UNREFERENCED CODE;XXE5B5     JSR     XXE5BB          ; SET DEFAULT DEVICES AND INITIALISE VIC CHIP     JMP     XXE581          ; HOME CURSOR AND RETURN;***********************************************************************************;;; SET DEFAULT DEVICES AND INITIALISE VIC CHIPXXE5BB = *     LDA     #$03               ; SET SCREEN     STA     XX9A          ; SET OUTPUT DEVICE NUMBER     LDA     #$00               ; SET KEYBOARD     STA     XX99          ; SET INPUT DEVICE NUMBER; INITIALISE VIC CHIPXXE5C3 = *     LDX     #$10               ; SET BYTE COUNTXXE5C5 = *     LDA     XXEDE4-1,X     ; GET BYTE FROM SETUP TABLE     STA     XX9000-1,X     ; SAVE BYTE TO VIC CHIP     DEX                    ; DECREMENT COUNT/INDEX     BNE     XXE5C5          ; LOOP IF MORE TO DO     RTS;***********************************************************************************;;; INPUT FROM KEYBOARD BUFFERXXE5CF = *     LDY     XX0277          ; GET CURRENT CHARACTER FROM BUFFER     LDX     #$00               ; CLEAR INDEXXXE5D4 = *     LDA     XX0277+1,X     ; GET NEXT CHARACTER,X FROM BUFFER     STA     XX0277,X          ; SAVE AS CURRENT CHARACTER,X IN BUFFER     INX                    ; INCREMENT INDEX     CPX     XXC6          ; COMPARE WITH KEYBOARD BUFFER INDEX     BNE     XXE5D4          ; LOOP IF MORE TO DO     DEC     XXC6          ; DECREMENT KEYBOARD BUFFER INDEX     TYA                    ; COPY KEY TO A     CLI                    ; ENABLE INTERRUPTS     CLC                    ; FLAG GOT BYTE     RTS;***********************************************************************************;;; WRITE CHARACTER AND WAIT FOR KEYXXE5E5 = *     JSR     XXE742          ; OUTPUT CHARACTER; WAIT FOR KEY FROM KEYBOARDXXE5E8 = *     LDA     XXC6          ; GET KEYBOARD BUFFER INDEX     STA     XXCC          ; CURSOR ENABLE, $00 = FLASH CURSOR, $XX = NO FLASH     STA     XX0292          ; SCREEN SCROLLING FLAG, $00 = SCROLL, $XX = NO SCROLL                         ; THIS DISABLES BOTH THE CURSOR FLASH AND THE SCREEN SCROLL                         ; WHILE THERE ARE CHARACTERS IN THE KEYBOARD BUFFER     BEQ     XXE5E8          ; LOOP IF BUFFER EMPTY     SEI                    ; DISABLE INTERRUPTS     LDA     XXCF          ; GET CURSOR BLINK PHASE     BEQ     XXE602          ; BRANCH IF CURSOR PHASE                         ; ELSE CHARACTER PHASE     LDA     XXCE          ; GET CHARACTER UNDER CURSOR     LDX     XX0287          ; GET COLOUR UNDER CURSOR     LDY     #$00               ; CLEAR Y     STY     XXCF          ; CLEAR CURSOR BLINK PHASE     JSR     XXEAA1          ; PRINT CHARACTER A AND COLOUR XXXE602 = *     JSR     XXE5CF          ; INPUT FROM KEYBOARD BUFFER     CMP     #$83               ; COMPARE WITH [SHIFT][RUN]     BNE     XXE619          ; BRANCH IF NOT [SHIFT][RUN]                         ; KEYS ARE [SHIFT][RUN] SO PUT 'LOAD',$0D,'RUN',$0D INTO                         ; THE BUFFER     LDX     #$09               ; SET BYTE COUNT     SEI                    ; DISABLE INTERRUPTS     STX     XXC6          ; SET KEYBOARD BUFFER INDEXXXE60E = *     LDA     XXEDF4-1,X     ; GET BYTE FROM AUTO LOAD/RUN TABLE     STA     XX0277-1,X     ; SAVE TO KEYBOARD BUFFER     DEX                    ; DECREMENT COUNT/INDEX     BNE     XXE60E          ; LOOP WHILE MORE TO DO     BEQ     XXE5E8          ; LOOP FOR NEXT KEY, BRANCH ALWAYS                         ; WAS NOT [SHIFT][RUN]XXE619 = *     CMP     #$0D               ; COMPARE WITH [CR]     BNE     XXE5E5          ; IF NOT [CR] PRINT CHARACTER AND GET NEXT KEY                         ; WAS [CR]     LDY     XXD5          ; GET CURRENT SCREEN LINE LENGTH     STY     XXD0          ; INPUT FROM KEYBOARD OR SCREEN, $XX = SCREEN,                         ; $00 = KEYBOARDXXE621 = *     LDA     (XXD1),Y          ; GET CHARACTER FROM CURRENT SCREEN LINE     CMP     #' '               ; COMPARE WITH [SPACE]     BNE     XXE62A          ; BRANCH IF NOT [SPACE]     DEY                    ; ELSE ELIMINATE THE SPACE, DECREMENT END OF INPUT LINE     BNE     XXE621          ; LOOP, BRANCH ALWAYSXXE62A = *     INY                    ; INCREMENT PAST LAST NON SPACE CHARACTER ON LINE     STY     XXC8          ; SAVE INPUT [EOL] POINTER     LDY     #$00               ; CLEAR A     STY     XX0292          ; CLEAR SCREEN SCROLLING FLAG, $00 = SCROLL, $XX = NO SCROLL     STY     XXD3          ; CLEAR CURSOR COLUMN     STY     XXD4          ; CLEAR CURSOR QUOTE FLAG, $XX = QUOTE, $00 = NO QUOTE     LDA     XXC9          ; GET INPUT CURSOR ROW     BMI     XXE657          ;.     LDX     XXD6          ; GET CURSOR ROW     JSR     XXE719          ; FIND AND SET POINTERS FOR START OF LOGICAL LINE     CPX     XXC9          ; COMPARE WITH INPUT CURSOR ROW     BNE     XXE657          ;.     BNE     XXE657          ;.?? WHAT'S THIS? JUST TO MAKE SURE OR SOMETHING     LDA     XXCA          ; GET INPUT CURSOR COLUMN     STA     XXD3          ; SAVE CURSOR COLUMN     CMP     XXC8          ; COMPARE WITH INPUT [EOL] POINTER     BCC     XXE657          ; BRANCH IF LESS, CURSOR IS IN LINE     BCS     XXE691          ; ELSE CURSOR IS BEYOND THE LINE END, BRANCH ALWAYS;***********************************************************************************;;; INPUT FROM SCREEN OR KEYBOARDXXE64F = *     TYA                    ; COPY Y     PHA                    ; SAVE Y     TXA                    ; COPY X     PHA                    ; SAVE X     LDA     XXD0          ; INPUT FROM KEYBOARD OR SCREEN, $XX = SCREEN,                         ; $00 = KEYBOARD     BEQ     XXE5E8          ; IF KEYBOARD GO WAIT FOR KEYXXE657 = *     LDY     XXD3          ; GET CURSOR COLUMN     LDA     (XXD1),Y          ; GET CHARACTER FROM THE CURRENT SCREEN LINE     NOP                    ;     NOP                    ;     NOP                    ;     NOP                    ;     NOP                    ;     NOP                    ;     NOP                    ;     NOP                    ;     NOP                    ; JUST A FEW WASTED CYCLES.     NOP                    ;     NOP                    ;     NOP                    ;     NOP                    ;     NOP                    ;     NOP                    ;     NOP                    ;     NOP                    ;     NOP                    ;     NOP                    ;     NOP                    ;     NOP                    ;     NOP                    ;     NOP                    ;     STA     XXD7          ; SAVE TEMPORARY LAST CHARACTER     AND     #$3F               ; MASK KEY BITS     ASL     XXD7          ; << TEMPORARY LAST CHARACTER     BIT     XXD7          ; TEST IT     BPL     XXE67E          ; BRANCH IF NOT [NO KEY]     ORA     #$80               ;.XXE67E = *     BCC     XXE684          ;.     LDX     XXD4          ; GET CURSOR QUOTE FLAG, $XX = QUOTE, $00 = NO QUOTE     BNE     XXE688          ; BRANCH IF IN QUOTE MODEXXE684 = *     BVS     XXE688          ;.     ORA     #$40               ;.XXE688 = *     INC     XXD3          ; INCREMENT CURSOR COLUMN     JSR     XXE6B8          ; IF OPEN QUOTE TOGGLE CURSOR QUOTE FLAG     CPY     XXC8          ; COMPARE WITH INPUT [EOL] POINTER     BNE     XXE6A8          ; BRANCH IF NOT AT LINE ENDXXE691 = *     LDA     #$00               ;.     STA     XXD0          ; CLEAR INPUT FROM KEYBOARD OR SCREEN, $XX = SCREEN,                         ; $00 = KEYBOARD     LDA     #$0D               ; SET CHARACTER [CR]     LDX     XX99          ; GET INPUT DEVICE NUMBER     CPX     #$03               ; COMPARE WITH SCREEN     BEQ     XXE6A3          ; BRANCH IF SCREEN     LDX     XX9A          ; GET OUTPUT DEVICE NUMBER     CPX     #$03               ; COMPARE WITH SCREEN     BEQ     XXE6A6          ; BRANCH IF SCREENXXE6A3 = *     JSR     XXE742          ; OUTPUT CHARACTERXXE6A6 = *     LDA     #$0D               ; SET CHARACTER [CR]XXE6A8 = *     STA     XXD7          ; SAVE CHARACTER     PLA                    ; PULL X     TAX                    ; RESTORE X     PLA                    ; PULL Y     TAY                    ; RESTORE Y     LDA     XXD7          ; RESTORE CHARACTER     CMP     #$DE               ;.     BNE     XXE6B6          ;.     LDA     #$FF               ;.XXE6B6 = *     CLC                    ; FLAG OK     RTS;***********************************************************************************;;; IF OPEN QUOTE TOGGLE CURSOR QUOTE FLAGXXE6B8 = *     CMP     #$22               ; COMAPRE BYTE WITH '     BNE     XXE6C4          ; EXIT IF NOT '     LDA     XXD4          ; GET CURSOR QUOTE FLAG, $XX = QUOTE, $00 = NO QUOTE     EOR     #$01               ; TOGGLE IT     STA     XXD4          ; SAVE CURSOR QUOTE FLAG     LDA     #$22               ; RESTORE THE 'XXE6C4 = *     RTS;***********************************************************************************;;; INSERT UPPERCASE/GRAPHIC CHARACTERXXE6C5 = *     ORA     #$40               ; CHANGE TO UPPERCASE/GRAPHICXXE6C7 = *     LDX     XXC7          ; GET REVERSE FLAG     BEQ     XXE6CD          ; BRANCH IF NOT REVERSE                         ; ELSE ..; INSERT REVERSED CHARACTERXXE6CB = *     ORA     #$80               ; REVERSE CHARACTERXXE6CD = *     LDX     XXD8          ; GET INSERT COUNT     BEQ     XXE6D3          ; BRANCH IF NONE     DEC     XXD8          ; ELSE DECREMENT INSERT COUNTXXE6D3 = *     LDX     XX0286          ; GET CURRENT COLOUR CODE     JSR     XXEAA1          ; PRINT CHARACTER A AND COLOUR X     JSR     XXE6EA          ; ADVANCE CURSOR; RESTORE REGISTERS, SET QUOTE FLAG AND EXITXXE6DC = *     PLA                    ; PULL Y     TAY                    ; RESTORE Y     LDA     XXD8          ; GET INSERT COUNT     BEQ     XXE6E4          ; SKIP QUOTE FLAG CLEAR IF INSERTS TO DO     LSR     XXD4          ; CLEAR CURSOR QUOTE FLAG, $XX = QUOTE, $00 = NO QUOTEXXE6E4 = *     PLA                    ; PULL X     TAX                    ; RESTORE X     PLA                    ; RESTORE A     CLC                    ;.     CLI                    ; ENABLE INTERRUPTS     RTS;***********************************************************************************;;; ADVANCE CURSORXXE6EA = *     JSR     XXE8FA          ; TEST FOR LINE INCREMENT     INC     XXD3          ; INCREMENT CURSOR COLUMN     LDA     XXD5          ; GET CURRENT SCREEN LINE LENGTH     CMP     XXD3          ; COMPARE WITH CURSOR COLUMN     BCS     XXE72C          ; EXIT IF LINE LENGTH >= CURSOR COLUMN     CMP     #$57               ; COMPARE WITH MAX LENGTH     BEQ     XXE723          ; IF AT MAX CLEAR COLUMN, BACK CURSOR UP AND DO NEWLINE     LDA     XX0292          ; GET AUTOSCROLL FLAG     BEQ     XXE701          ; BRANCH IF AUTOSCROLL ON     JMP     XXE9F0          ;.ELSE OPEN SPACE ON SCREENXXE701 = *     LDX     XXD6          ; GET CURSOR ROW     CPX     #$17               ; COMPARE WITH MAX + 1     BCC     XXE70E          ; IF LESS THAN MAX + 1 GO ADD THIS ROW TO THE CURRENT                         ; LOGICAL LINE     JSR     XXE975          ; ELSE SCROLL SCREEN     DEC     XXD6          ; DECREMENT CURSOR ROW     LDX     XXD6          ; GET CURSOR ROW; ADD THIS ROW TO THE CURRENT LOGICAL LINEXXE70E = *     ASL     XXD9,X          ; SHIFT START OF LINE X POINTER HIGH BYTE     LSR     XXD9,X          ; SHIFT START OF LINE X POINTER HIGH BYTE BACK,                         ; CLEAR B7, START OF LOGICAL LINE     JMP     XXED5B          ; MAKE NEXT SCREEN LINE START OF LOGICAL LINE, INCREMENT                         ; LINE LENGTH AND SET POINTERS; ADD ONE LINE LENGTH AND SET POINTERS FOR START OF LINEXXE715 = *     ADC     #$16               ; ADD ONE LINE LENGTH     STA     XXD5          ; SAVE CURRENT SCREEN LINE LENGTH; FIND AND SET POINTERS FOR START OF LOGICAL LINEXXE719 = *     LDA     XXD9,X          ; GET START OF LINE X POINTER HIGH BYTE     BMI     XXE720          ; EXIT LOOP IF START OF LOGICAL LINE     DEX                    ; ELSE BACK UP ONE LINE     BNE     XXE719          ; LOOP IF NOT ON FIRST LINEXXE720 = *     JMP     XXEA7E          ; SET START OF LINE X AND RETURN; CLEAR CURSOR COLUMN, BACK CURSOR UP ONE LINE AND DO NEWLINEXXE723 = *     DEC     XXD6          ; DECREMENT CURSOR ROW. IF THE CURSOR WAS INCREMENTED PAST                         ; THE LAST LINE THEN THIS DECREMENT AND THE SCROLL WILL                         ; LEAVE THE CURSOR ONE LINE ABOVE THE BOTOM OF THE SCREEN     JSR     XXE8C3          ; DO NEWLINE     LDA     #$00               ; CLEAR A     STA     XXD3          ; CLEAR CURSOR COLUMNXXE72C = *     RTS; BACK ONTO PREVIOUS LINE IF POSSIBLEXXE72D = *     LDX     XXD6          ; GET CURSOR ROW     BNE     XXE737          ; BRANCH IF NOT TOP ROW     STX     XXD3          ; CLEAR CURSOR COLUMN     PLA                    ; DUMP RETURN ADDRESS LOW BYTE     PLA                    ; DUMP RETURN ADDRESS HIGH BYTE     BNE     XXE6DC          ; RESTORE REGISTERS, SET QUOTE FLAG AND EXIT, BRANCH ALWAYSXXE737 = *     DEX                    ; DECREMENT CURSOR ROW     STX     XXD6          ; SAVE CURSOR ROW     JSR     XXE587          ; SET SCREEN POINTERS FOR CURSOR ROW, COLUMN     LDY     XXD5          ; GET CURRENT SCREEN LINE LENGTH     STY     XXD3          ; SAVE AS CURSOR COLUMN     RTS;***********************************************************************************;;;## OUTPUT CHARACTER TO SCREENXXE742 = *     PHA                    ; SAVE CHARACTER     STA     XXD7          ; SAVE TEMPORARY LAST CHARACTER     TXA                    ; COPY X     PHA                    ; SAVE X     TYA                    ; COPY Y     PHA                    ; SAVE Y     LDA     #$00               ; CLEAR A     STA     XXD0          ; CLEAR INPUT FROM KEYBOARD OR SCREEN, $XX = SCREEN,                         ; $00 = KEYBOARD     LDY     XXD3          ; GET CURSOR COLUMN     LDA     XXD7          ; RESTORE LAST CHARACTER     BPL     XXE756          ; BRANCH IF UNSHIFTED     JMP     XXE800          ; DO SHIFTED CHARACTERS AND RETURNXXE756 = *     CMP     #$0D               ; COMPARE WITH [CR]     BNE     XXE75D          ; BRANCH IF NOT [CR]     JMP     XXE8D8          ; ELSE OUTPUT [CR] AND RETURNXXE75D = *     CMP     #' '               ; COMPARE WITH [SPACE]     BCC     XXE771          ; BRANCH IF < [SPACE]     CMP     #$60               ;.     BCC     XXE769          ; BRANCH IF $20 TO $5F                         ; CHARACTER IS $60 OR GREATER     AND     #$DF               ;.     BNE     XXE76B          ;.XXE769 = *     AND     #$3F               ;.XXE76B = *     JSR     XXE6B8          ; IF OPEN QUOTE TOGGLE CURSOR DIRECT/PROGRAMMED FLAG     JMP     XXE6C7          ;.                         ; CHARACTER WAS < [SPACE] SO IS A CONTROL CHARACTER                         ; OF SOME SORTXXE771 = *     LDX     XXD8          ; GET INSERT COUNT     BEQ     XXE778          ; BRANCH IF NO CHARACTERS TO INSERT     JMP     XXE6CB          ; INSERT REVERSED CHARACTERXXE778 = *     CMP     #$14               ; COMPARE WITH [INSERT]/[DELETE]     BNE     XXE7AA          ; BRANCH IF NOT [INSERT]/[DELETE]     TYA                    ;.     BNE     XXE785          ;.     JSR     XXE72D          ; BACK ONTO PREVIOUS LINE IF POSSIBLE     JMP     XXE79F          ;.XXE785 = *     JSR     XXE8E8          ; TEST FOR LINE DECREMENT                         ; NOW CLOSE UP THE LINE     DEY                    ; DECREMENT INDEX TO PREVIOUS CHARACTER     STY     XXD3          ; SAVE CURSOR COLUMN     JSR     XXEAB2          ; CALCULATE POINTER TO COLOUR RAMXXE78E = *     INY                    ; INCREMENT INDEX TO NEXT CHARACTER     LDA     (XXD1),Y          ; GET CHARACTER FROM CURRENT SCREEN LINE     DEY                    ; DECREMENT INDEX TO PREVIOUS CHARACTER     STA     (XXD1),Y          ; SAVE CHARACTER TO CURRENT SCREEN LINE     INY                    ; INCREMENT INDEX TO NEXT CHARACTER     LDA     (XXF3),Y          ; GET COLOUR RAM BYTE     DEY                    ; DECREMENT INDEX TO PREVIOUS CHARACTER     STA     (XXF3),Y          ; SAVE COLOUR RAM BYTE     INY                    ; INCREMENT INDEX TO NEXT CHARACTER     CPY     XXD5          ; COMPARE WITH CURRENT SCREEN LINE LENGTH     BNE     XXE78E          ; LOOP IF NOT THERE YETXXE79F = *     LDA     #' '               ; SET [SPACE]     STA     (XXD1),Y          ; CLEAR LAST CHARACTER ON CURRENT SCREEN LINE     LDA     XX0286          ; GET CURRENT COLOUR CODE     STA     (XXF3),Y          ; SAVE TO COLOUR RAM     BPL     XXE7F7          ; BRANCH ALWAYSXXE7AA = *     LDX     XXD4          ; GET CURSOR QUOTE FLAG, $XX = QUOTE, $00 = NO QUOTE     BEQ     XXE7B1          ; BRANCH IF NOT QUOTE MODE     JMP     XXE6CB          ; INSERT REVERSED CHARACTERXXE7B1 = *     CMP     #$12               ; COMPARE WITH [RVS ON]     BNE     XXE7B7          ; BRANCH IF NOT [RVS ON]     STA     XXC7          ; SET REVERSE FLAGXXE7B7 = *     CMP     #$13               ; COMPARE WITH [CLR HOME]     BNE     XXE7BE          ; BRANCH IF NOT [CLR HOME]     JSR     XXE581          ; HOME CURSORXXE7BE = *     CMP     #$1D               ; COMPARE WITH [CURSOR RIGHT]     BNE     XXE7D9          ; BRANCH IF NOT [CURSOR RIGHT]     INY                    ; INCREMENT CURSOR COLUMN     JSR     XXE8FA          ; TEST FOR LINE INCREMENT     STY     XXD3          ; SAVE CURSOR COLUMN     DEY                    ; DECREMENT CURSOR COLUMN     CPY     XXD5          ; COMPARE CURSOR COLUMN WITH CURRENT SCREEN LINE LENGTH     BCC     XXE7D6          ; EXIT IF LESS                         ; ELSE THE CURSOR COLUMN IS >= THE CURRENT SCREEN LINE                         ; LENGTH SO BACK ONTO THE CURRENT LINE AND DO A NEWLINE     DEC     XXD6          ; DECREMENT CURSOR ROW     JSR     XXE8C3          ; DO NEWLINE     LDY     #$00               ; CLEAR CURSOR COLUMNXXE7D4 = *     STY     XXD3          ; SAVE CURSOR COLUMNXXE7D6 = *     JMP     XXE6DC          ; RESTORE REGISTERS, SET QUOTE FLAG AND EXITXXE7D9 = *     CMP     #$11               ; COMPARE WITH [CURSOR DOWN]     BNE     XXE7FA          ; BRANCH IF NOT [CURSOR DOWN]     CLC                    ; CLEAR CARRY FOR ADD     TYA                    ; COPY CURSOR COLUMN     ADC     #$16               ; ADD ONE LINE     TAY                    ; COPY BACK TO A     INC     XXD6          ; INCREMENT CURSOR ROW     CMP     XXD5          ; COMPARE CURSOR COLUMN WITH CURRENT SCREEN LINE LENGTH     BCC     XXE7D4          ; SAVE CURSOR COLUMN AND EXIT IF LESS     BEQ     XXE7D4          ; SAVE CURSOR COLUMN AND EXIT IF EQUAL                         ; ELSE THE CURSOR HAS MOVED BEYOND THE END OF THIS LINE                         ; SO BACK IT UP UNTIL IT'S ON THE START OF THE LOGICAL LINE     DEC     XXD6          ; DECREMENT CURSOR ROWXXE7EC = *     SBC     #$16               ; SUBTRACT ONE LINE     BCC     XXE7F4          ; EXIT LOOP IF ON PREVIOUS LINE     STA     XXD3          ; ELSE SAVE CURSOR COLUMN     BNE     XXE7EC          ; LOOP IF NOT AT START OF LINEXXE7F4 = *     JSR     XXE8C3          ; DO NEWLINEXXE7F7 = *     JMP     XXE6DC          ; RESTORE REGISTERS, SET QUOTE FLAG AND EXITXXE7FA = *     JSR     XXE912          ; SET THE COLOUR FROM THE CHARACTER IN A     JMP     XXED21          ;.XXE800 = *     NOP                    ; JUST A FEW WASTED CYCLES     NOP                    ;     NOP                    ;     NOP                    ;     NOP                    ;     NOP                    ;     NOP                    ;     NOP                    ;     NOP                    ;     NOP                    ;     NOP                    ;     NOP                    ;     NOP                    ;     NOP                    ;     NOP                    ;     NOP                    ;     NOP                    ;     NOP                    ;     NOP                    ;     NOP                    ;     NOP                    ;     AND     #$7F               ; MASK 0XXX XXXX, CLEAR B7     CMP     #$7F               ; WAS IT $FF BEFORE THE MASK     BNE     XXE81D          ; BRANCH IF NOT     LDA     #$5E               ; ELSE MAKE IT $5EXXE81D = *     NOP                    ; JUST A FEW WASTED CYCLES     NOP                    ;     NOP                    ;     NOP                    ;     NOP                    ;     NOP                    ;     CMP     #' '               ; COMPARE WITH [SPACE]     BCC     XXE82A          ; BRANCH IF < [SPACE]     JMP     XXE6C5          ; INSERT UPPERCASE/GRAPHIC CHARACTER AND RETURN                         ; CHARACTER WAS $80 TO $9F AND IS NOW $00 TO $1FXXE82A = *     CMP     #$0D               ; COMPARE WITH [CR]     BNE     XXE831          ; BRANCH IF NOT [CR]     JMP     XXE8D8          ; ELSE OUTPUT [CR] AND RETURN                         ; WAS NOT [CR]XXE831 = *     LDX     XXD4          ; GET CURSOR QUOTE FLAG, $XX = QUOTE, $00 = NO QUOTE     BNE     XXE874          ; BRANCH IF QUOTE MODE     CMP     #$14               ; COMPARE WITH [INSERT DELETE]     BNE     XXE870          ; BRANCH IF NOT [INSERT DELETE]     LDY     XXD5          ; GET CURRENT SCREEN LINE LENGTH     LDA     (XXD1),Y          ; GET CHARACTER FROM CURRENT SCREEN LINE     CMP     #' '               ; COMPARE WITH [SPACE]     BNE     XXE845          ; BRANCH IF NOT [SPACE]     CPY     XXD3          ; COMPARE CURRENT COLUMN WITH CURSOR COLUMN     BNE     XXE84C          ; IF NOT CURSOR COLUMN GO OPEN UP SPACE ON LINEXXE845 = *     CPY     #$57               ; COMPARE CURRENT COLUMN WITH MAX LINE LENGTH     BEQ     XXE86D          ; EXIT IF AT LINE END     JSR     XXE9EE          ; ELSE OPEN SPACE ON SCREEN                         ; NOW OPEN UP SPACE ON THE LINE TO INSERT A CHARACTERXXE84C = *     LDY     XXD5          ; GET CURRENT SCREEN LINE LENGTH     JSR     XXEAB2          ; CALCULATE POINTER TO COLOUR RAMXXE851 = *     DEY                    ; DECREMENT INDEX TO PREVIOUS CHARACTER     LDA     (XXD1),Y          ; GET CHARACTER FROM CURRENT SCREEN LINE     INY                    ; INCREMENT INDEX TO NEXT CHARACTER     STA     (XXD1),Y          ; SAVE CHARACTER TO CURRENT SCREEN LINE     DEY                    ; DECREMENT INDEX TO PREVIOUS CHARACTER     LDA     (XXF3),Y          ; GET CURRENT SCREEN LINE COLOUR RAM BYTE     INY                    ; INCREMENT INDEX TO NEXT CHARACTER     STA     (XXF3),Y          ; SAVE CURRENT SCREEN LINE COLOUR RAM BYTE     DEY                    ; DECREMENT INDEX TO PREVIOUS CHARACTER     CPY     XXD3          ; COMPARE WITH CURSOR COLUMN     BNE     XXE851          ; LOOP IF NOT THERE YET     LDA     #' '               ; SET [SPACE]     STA     (XXD1),Y          ; CLEAR CHARACTER AT CURSOR POSITION ON CURRENT SCREEN LINE     LDA     XX0286          ; GET CURRENT COLOUR CODE     STA     (XXF3),Y          ; SAVE TO CURSOR POSITION ON CURRENT SCREEN LINE COLOUR RAM     INC     XXD8          ; INCREMENT INSERT COUNTXXE86D = *     JMP     XXE6DC          ; RESTORE REGISTERS, SET QUOTE FLAG AND EXITXXE870 = *     LDX     XXD8          ; GET INSERT COUNT     BEQ     XXE879          ; BRANCH IF NO INSERT SPACEXXE874 = *     ORA     #$40               ; CHANGE TO UPPERCASE/GRAPHIC     JMP     XXE6CB          ; INSERT REVERSED CHARACTERXXE879 = *     CMP     #$11               ; COMPARE WITH [CURSOR UP]     BNE     XXE893          ; BRANCH IF NOT [CURSOR UP]     LDX     XXD6          ; GET CURSOR ROW     BEQ     XXE8B8          ; BRANCH IF ON TOP LINE     DEC     XXD6          ; DECREMENT CURSOR ROW     LDA     XXD3          ; GET CURSOR COLUMN     SEC                    ; SET CARRY FOR SUBTRACT     SBC     #$16               ; SUBTRACT ONE LINE LENGTH     BCC     XXE88E          ; BRANCH IF STEPPED BACK TO PREVIOUS LINE     STA     XXD3          ; ELSE SAVE CURSOR COLUMN ..     BPL     XXE8B8          ; .. AND EXIT, BRANCH ALWAYSXXE88E = *     JSR     XXE587          ; SET SCREEN POINTERS FOR CURSOR ROW, COLUMN ..     BNE     XXE8B8          ; .. AND EXIT, BRANCH ALWAYSXXE893 = *     CMP     #$12               ; COMPARE WITH [RVS OFF]     BNE     XXE89B          ; BRANCH IF NOT [RVS OFF]     LDA     #$00               ; CLEAR A     STA     XXC7          ; CLEAR REVERSE FLAGXXE89B = *     CMP     #$1D               ; COMPARE WITH [CURSOR LEFT]     BNE     XXE8B1          ; BRANCH IF NOT [CURSOR LEFT]     TYA                    ; COPY CURSOR COLUMN     BEQ     XXE8AB          ; BRANCH IF AT START OF LINE     JSR     XXE8E8          ; TEST FOR LINE DECREMENT     DEY                    ; DECREMENT CURSOR COLUMN     STY     XXD3          ; SAVE CURSOR COLUMN     JMP     XXE6DC          ; RESTORE REGISTERS, SET QUOTE FLAG AND EXITXXE8AB = *     JSR     XXE72D          ; BACK ONTO PREVIOUS LINE IF POSSIBLE     JMP     XXE6DC          ; RESTORE REGISTERS, SET QUOTE FLAG AND EXITXXE8B1 = *     CMP     #$13               ; COMPARE WITH [CLR]     BNE     XXE8BB          ; BRANCH IF NOT [CLR]     JSR     XXE55F          ; CLEAR SCREENXXE8B8 = *     JMP     XXE6DC          ; RESTORE REGISTERS, SET QUOTE FLAG AND EXITXXE8BB = *     ORA     #$80               ; RESTORE B7, COLOUR CAN ONLY BE BLACK, CYAN, MAGENTA                         ; OR YELLOW     JSR     XXE912          ; SET THE COLOUR FROM THE CHARACTER IN A     JMP     XXED30          ;.;***********************************************************************************;;; DO NEWLINEXXE8C3 = *     LSR     XXC9          ; SHIFT >> INPUT CURSOR ROW     LDX     XXD6          ; GET CURSOR ROWXXE8C7 = *     INX                    ; INCREMENT ROW     CPX     #$17               ; COMPARE WITH LAST ROW + 1     BNE     XXE8CF          ; BRANCH IF NOT LAST ROW + 1     JSR     XXE975          ; ELSE SCROLL SCREENXXE8CF = *     LDA     XXD9,X          ; GET START OF LINE X POINTER HIGH BYTE     BPL     XXE8C7          ; LOOP IF NOT START OF LOGICAL LINE     STX     XXD6          ; ELSE SAVE CURSOR ROW     JMP     XXE587          ; SET SCREEN POINTERS FOR CURSOR ROW, COLUMN AND RETURN;***********************************************************************************;;; OUTPUT [CR]XXE8D8 = *     LDX     #$00               ; CLEAR X     STX     XXD8          ; CLEAR INSERT COUNT     STX     XXC7          ; CLEAR REVERSE FLAG     STX     XXD4          ; CLEAR CURSOR QUOTE FLAG, $XX = QUOTE, $00 = NO QUOTE     STX     XXD3          ; CLEAR CURSOR COLUMN     JSR     XXE8C3          ; DO NEWLINE     JMP     XXE6DC          ; RESTORE REGISTERS, SET QUOTE FLAG AND EXIT;***********************************************************************************;;; TEST FOR LINE DECREMENTXXE8E8 = *     LDX     #$04               ; SET COUNT     LDA     #$00               ; SET COLUMNXXE8EC = *     CMP     XXD3          ; COMPARE WITH CURSOR COLUMN     BEQ     XXE8F7          ; BRANCH IF AT START OF LINE     CLC                    ; ELSE CLEAR CARRY FOR ADD     ADC     #$16               ; INCREMENT TO NEXT LINE     DEX                    ; DECREMENT LOOP COUNT     BNE     XXE8EC          ; LOOP IF MORE TO TEST     RTSXXE8F7 = *     DEC     XXD6          ; ELSE DECREMENT CURSOR ROW     RTS;***********************************************************************************;;; TEST FOR LINE INCREMENT. IF AT END OF LINE, BUT NOT AT END OF LAST LINE, INCREMENT THE; CURSOR ROWXXE8FA = *     LDX     #$04               ; SET COUNT     LDA     #$15               ; SET COLUMNXXE8FE = *     CMP     XXD3          ; COMPARE WITH CURSOR COLUMN     BEQ     XXE909          ; IF AT END OF LINE TEST AND POSSIBLY INCREMENT CURSOR ROW     CLC                    ; ELSE CLEAR CARRY FOR ADD     ADC     #$16               ; INCREMENT TO NEXT LINE     DEX                    ; DECREMENT LOOP COUNT     BNE     XXE8FE          ; LOOP IF MORE TO TEST     RTS                         ; CURSOR IS AT END OF LINEXXE909 = *     LDX     XXD6          ; GET CURSOR ROW     CPX     #$17               ; COMPARE WITH END OF SCREEN     BEQ     XXE911          ; EXIT IF END OF SCREEN     INC     XXD6          ; ELSE INCREMENT CURSOR ROWXXE911 = *     RTS;***********************************************************************************;;; SET COLOUR CODE. ENTER WITH THE COLOUR CHARACTER IN A. IF A DOES NOT CONTAIN A; COLOUR CHARACTER THIS ROUTINE EXITS WITHOUT CHANGING THE COLOURXXE912 = *     LDX     #XXE928-XXE921                         ; SET COLOUR CODE COUNTXXE914 = *     CMP     XXE921,X          ; COMPARE THE CHARACTER WITH THE TABLE CODE     BEQ     XXE91D          ; IF A MATCH GO SAVE THE COLOUR AND EXIT     DEX                    ; ELSE DECREMENT THE INDEX     BPL     XXE914          ; LOOP IF MORE TO DO     RTSXXE91D = *     STX     XX0286          ; SET CURRENT COLOUR CODE     RTS;***********************************************************************************;;; ASCII COLOUR CODE TABLE                         ; CHR$()     COLOURXXE921                    ; ------     ------     .BYTE     $90               ;  144     BLACK     .BYTE     $05               ;    5     WHITE     .BYTE     $1C               ;   28     RED     .BYTE     $9F               ;  159     CYAN     .BYTE     $9C               ;  156     MAGENTA     .BYTE     $1E               ;   30     GREEN     .BYTE     $1F               ;   31     BLUEXXE928 = *     .BYTE     $9E               ;  158     YELLOW;***********************************************************************************;;; CODE CONVERSION, THESE DON'T SEEM TO BE USED ANYWHERE;XXE929     .BYTE     $EF,$A1,$DF,$A6,$E1,$B1,$E2,$B2,$E3,$B3,$E4,$B4,$E5,$B5,$E6,$B6     .BYTE     $E7,$B7,$E8,$B8,$E9,$B9,$FA,$BA,$FB,$BB,$FC,$BC,$EC,$BD,$FE,$BE     .BYTE     $84,$BF,$F7,$C0,$F8,$DB,$F9,$DD,$EA,$DE,$5E,$E0,$5B,$E1,$5D,$E2     .BYTE     $40,$B0,$61,$B1,$78,$DB,$79,$DD,$66,$B6,$77,$C0,$70,$F0,$71,$F1     .BYTE     $72,$F2,$73,$F3,$74,$F4,$75,$F5,$76,$F6,$7D,$FD;***********************************************************************************;;; SCROLL SCREENXXE975 = *     LDA     XXAC          ; COPY TAPE BUFFER START POINTER     PHA                    ; SAVE IT     LDA     XXAD          ; COPY TAPE BUFFER START POINTER     PHA                    ; SAVE IT     LDA     XXAE          ; COPY TAPE BUFFER END POINTER     PHA                    ; SAVE IT     LDA     XXAF          ; COPY TAPE BUFFER END POINTER     PHA                    ; SAVE ITXXE981 = *     LDX     #$FF               ; SET TO -1 FOR PRE INCREMENT LOOP     DEC     XXD6          ; DECREMENT CURSOR ROW     DEC     XXC9          ; DECREMENT INPUT CURSOR ROW     DEC     XXF2          ; DECREMENT SCREEN ROW MARKERXXE989 = *     INX                    ; INCREMENT LINE NUMBER     JSR     XXEA7E          ; SET START OF LINE X     CPX     #$16               ; COMPARE WITH LAST LINE     BCS     XXE99D          ; BRANCH IF >= $16     LDA     XXEDFD+1,X     ; GET START OF NEXT LINE POINTER LOW BYTE     STA     XXAC          ; SAVE NEXT LINE POINTER LOW BYTE     LDA     XXD9+1,X          ; GET START OF NEXT LINE POINTER HIGH BYTE     JSR     XXEA56          ; SHIFT SCREEN LINE UP     BMI     XXE989          ; LOOP, BRANCH ALWAYSXXE99D = *     JSR     XXEA8D          ; CLEAR SCREEN LINE X                         ; NOW SHIFT UP THE START OF LOGICAL LINE BITS     LDX     #$00               ; CLEAR INDEXXXE9A2 = *     LDA     XXD9,X          ; GET START OF LINE X POINTER HIGH BYTE     AND     #$7F               ; CLEAR LINE X START OF LOGICAL LINE BIT     LDY     XXD9+1,X          ; GET START OF NEXT LINE POINTER HIGH BYTE     BPL     XXE9AC          ; BRANCH IF NEXT LINE NOT START OF LINE     ORA     #$80               ; SET LINE X START OF LOGICAL LINE BITXXE9AC = *     STA     XXD9,X          ; SET START OF LINE X POINTER HIGH BYTE     INX                    ; INCREMENT LINE NUMBER     CPX     #$16               ; COMPARE WITH LAST LINE     BNE     XXE9A2          ; LOOP IF NOT LAST LINE     LDA     XXD9+$16          ; GET START OF LAST LINE POINTER HIGH BYTE     ORA     #$80               ; MARK AS START OF LOGICAL LINE     STA     XXD9+$16          ; SET START OF LAST LINE POINTER HIGH BYTE     LDA     XXD9          ; GET START OF FIRST LINE POINTER HIGH BYTE     BPL     XXE981          ; IF NOT START OF LOGICAL LINE LOOP BACK AND                         ; SCROLL THE SCREEN UP ANOTHER LINE     INC     XXD6          ; INCREMENT CURSOR ROW     INC     XXF2          ; INCREMENT SCREEN ROW MARKER     LDA     #$FB               ; SET KEYBOARD COLUMN C2     STA     XX9120          ; SET VIA 2 DRB, KEYBOARD COLUMN     LDA     XX9121          ; GET VIA 2 DRA, KEYBOARD ROW     CMP     #$FE               ; COMPARE WITH ROW R0 ACTIVE, [CTL]     PHP                    ; SAVE STATUS     LDA     #$F7               ; SET KEYBOARD COLUMN C3     STA     XX9120          ; SET VIA 2 DRB, KEYBOARD COLUMN     PLP                    ; RESTORE STATUS     BNE     XXE9DF          ; SKIP DELAY IF ??                         ; FIRST TIME ROUND THE INNER LOOP X WILL BE $16     LDY     #$00               ; CLEAR DELAY OUTER LOOP COUNT, DO THIS 256 TIMESXXE9D6 = *     NOP                    ; WASTE CYCLES     DEX                    ; DECREMENT INNER LOOP COUNT     BNE     XXE9D6          ; LOOP IF NOT ALL DONE     DEY                    ; DECREMENT OUTER LOOP COUNT     BNE     XXE9D6          ; LOOP IF NOT ALL DONE     STY     XXC6          ; CLEAR KEYBOARD BUFFER INDEXXXE9DF = *     LDX     XXD6          ; GET CURSOR ROW     PLA                    ; PULL TAPE BUFFER END POINTER     STA     XXAF          ; RESTORE IT     PLA                    ; PULL TAPE BUFFER END POINTER     STA     XXAE          ; RESTORE IT     PLA                    ; PULL TAPE BUFFER POINTER     STA     XXAD          ; RESTORE IT     PLA                    ; PULL TAPE BUFFER POINTER     STA     XXAC          ; RESTORE IT     RTS;***********************************************************************************;;; OPEN SPACE ON SCREENXXE9EE = *     LDX     XXD6          ; GET CURSOR ROWXXE9F0 = *     INX                    ; INCREMENT ROW     LDA     XXD9,X          ; GET START OF LINE X POINTER HIGH BYTE     BPL     XXE9F0          ; BRANCH IF NOT START OF LOGICAL LINE     STX     XXF2          ; SET SCREEN ROW MARKER     CPX     #$16               ; COMPARE WITH LAST LINE     BEQ     XXEA08          ; BRANCH IF = LAST LINE     BCC     XXEA08          ; BRANCH IF < LAST LINE                         ; ELSE WAS > LAST LINE     JSR     XXE975          ; ELSE SCROLL SCREEN     LDX     XXF2          ; GET SCREEN ROW MARKER     DEX                    ; DECREMENT SCREEN ROW MARKER     DEC     XXD6          ; DECREMENT CURSOR ROW     JMP     XXE70E          ; ADD THIS ROW TO THE CURRENT LOGICAL LINE AND RETURNXXEA08 = *     LDA     XXAC          ; COPY TAPE BUFFER POINTER     PHA                    ; SAVE IT     LDA     XXAD          ; COPY TAPE BUFFER POINTER     PHA                    ; SAVE IT     LDA     XXAE          ; COPY TAPE BUFFER END POINTER     PHA                    ; SAVE IT     LDA     XXAF          ; COPY TAPE BUFFER END POINTER     PHA                    ; SAVE IT     LDX     #$17               ; SET TO END LINE + 1 FOR PREDECREMENT LOOPXXEA16 = *     DEX                    ; DECREMENT LINE NUMBER     JSR     XXEA7E          ; SET START OF LINE X     CPX     XXF2          ; COMPARE WITH SCREEN ROW MARKER     BCC     XXEA2C          ; BRANCH IF < SCREEN ROW MARKER     BEQ     XXEA2C          ; BRANCH IF = SCREEN ROW MARKER     LDA     XXEDFD-1,X     ; ELSE GET START OF PREVIOUS LINE LOW BYTE FROM ROM TABLE     STA     XXAC          ; SAVE PREVIOUS LINE POINTER LOW BYTE     LDA     XXD9-1,X          ; GET START OF PREVIOUS LINE POINTER HIGH BYTE     JSR     XXEA56          ; SHIFT SCREEN LINE DOWN     BMI     XXEA16          ; LOOP, BRANCH ALWAYSXXEA2C = *     JSR     XXEA8D          ; CLEAR SCREEN LINE X     LDX     #$15               ;.XXEA31 = *     CPX     XXF2          ;.COMPARE WITH SCREEN ROW MARKER     BCC     XXEA44          ;.     LDA     XXD9+1,X          ;.     AND     #$7F               ;.     LDY     XXD9,X          ; GET START OF LINE X POINTER HIGH BYTE     BPL     XXEA3F          ;.     ORA     #$80               ;.XXEA3F = *     STA     XXD9+1,X          ;.     DEX                    ;.     BNE     XXEA31          ;.XXEA44 = *     LDX     XXF2          ;.GET SCREEN ROW MARKER     JSR     XXE70E          ; ADD THIS ROW TO THE CURRENT LOGICAL LINE     PLA                    ; PULL TAPE BUFFER END POINTER     STA     XXAF          ; RESTORE IT     PLA                    ; PULL TAPE BUFFER END POINTER     STA     XXAE          ; RESTORE IT     PLA                    ; PULL TAPE BUFFER POINTER     STA     XXAD          ; RESTORE IT     PLA                    ; PULL TAPE BUFFER POINTER     STA     XXAC          ; RESTORE IT     RTS;***********************************************************************************;;; SHIFT SCREEN LINE UP/DOWNXXEA56 = *     AND     #$03               ; MASK 0000 00XX, LINE MEMORY PAGE     ORA     XX0288          ; OR WITH SCREEN MEMORY PAGE     STA     XXAD          ; SAVE NEXT/PREVIOUS LINE POINTER HIGH BYTE     JSR     XXEA6E          ; CALCULATE POINTERS TO SCREEN LINES COLOUR RAMXXEA60 = *     LDY     #$15               ; SET COLUMN COUNTXXEA62 = *     LDA     (XXAC),Y          ; GET CHARACTER FROM NEXT/PREVIOUS SCREEN LINE     STA     (XXD1),Y          ; SAVE CHARACTER TO CURRENT SCREEN LINE     LDA     (XXAE),Y          ; GET COLOUR FROM NEXT/PREVIOUS SCREEN LINE COLOUR RAM     STA     (XXF3),Y          ; SAVE COLOUR TO CURRENT SCREEN LINE COLOUR RAM     DEY                    ; DECREMENT COLUMN INDEX/COUNT     BPL     XXEA62          ; LOOP IF MORE TO DO     RTS;***********************************************************************************;;; CALCULATE POINTERS TO SCREEN LINES COLOUR RAMXXEA6E = *     JSR     XXEAB2          ; CALCULATE POINTER TO CURRENT SCREEN LINE COLOUR RAM     LDA     XXAC          ; GET NEXT SCREEN LINE POINTER LOW BYTE     STA     XXAE          ; SAVE NEXT SCREEN LINE COLOUR RAM POINTER LOW BYTE     LDA     XXAD          ; GET NEXT SCREEN LINE POINTER HIGH BYTE     AND     #$03               ; MASK 0000 00XX, LINE MEMORY PAGE     ORA     #$94               ; SET  1001 01XX, COLOUR MEMORY PAGE     STA     XXAF          ; SAVE NEXT SCREEN LINE COLOUR RAM POINTER HIGH BYTE     RTS;***********************************************************************************;;; SET START OF LINE XXXEA7E = *     LDA     XXEDFD,X          ; GET START OF LINE LOW BYTE FROM ROM TABLE     STA     XXD1          ; SET CURRENT SCREEN LINE POINTER LOW BYTE     LDA     XXD9,X          ; GET START OF LINE HIGH BYTE FROM RAM TABLE     AND     #$03               ; MASK 0000 00XX, LINE MEMORY PAGE     ORA     XX0288          ; OR WITH SCREEN MEMORY PAGE     STA     XXD2          ; SET CURRENT SCREEN LINE POINTER HIGH BYTE     RTS;***********************************************************************************;;; CLEAR SCREEN LINE XXXEA8D = *     LDY     #$15               ; SET NUMBER OF COLUMNS TO CLEAR     JSR     XXEA7E          ; SET START OF LINE X     JSR     XXEAB2          ; CALCULATE POINTER TO COLOUR RAMXXEA95 = *     LDA     #' '               ; SET [SPACE]     STA     (XXD1),Y          ; CLEAR CHARACTER IN CURRENT SCREEN LINE     LDA     #$01               ; SET COLOUR, BLUE ON WHITE     STA     (XXF3),Y          ; SET COLOUR RAM IN CURRENT SCREEN LINE     DEY                    ; DECREMENT INDEX     BPL     XXEA95          ; LOOP IF MORE TO DO     RTS;***********************************************************************************;;; PRINT CHARACTER A AND COLOUR X TO SCREENXXEAA1 = *     TAY                    ; COPY CHARACTER     LDA     #$02               ; SET COUNT TO $02, USUALLY $14 ??     STA     XXCD          ; SET CURSOR COUNTDOWN     JSR     XXEAB2          ; CALCULATE POINTER TO COLOUR RAM     TYA                    ; GET CHARACTER BACK; SAVE CHARACTER AND COLOUR TO SCREEN @ CURSORXXEAAA = *     LDY     XXD3          ; GET CURSOR COLUMN     STA     (XXD1),Y          ; SAVE CHARACTER FROM CURRENT SCREEN LINE     TXA                    ; COPY COLOUR TO A     STA     (XXF3),Y          ; SAVE TO COLOUR RAM     RTS;***********************************************************************************;;; CALCULATE POINTER TO COLOUR RAMXXEAB2 = *     LDA     XXD1          ; GET CURRENT SCREEN LINE POINTER LOW BYTE     STA     XXF3          ; SAVE POINTER TO COLOUR RAM LOW BYTE     LDA     XXD2          ; GET CURRENT SCREEN LINE POINTER HIGH BYTE     AND     #$03               ; MASK 0000 00XX, LINE MEMORY PAGE     ORA     #$94               ; SET  1001 01XX, COLOUR MEMORY PAGE     STA     XXF4          ; SAVE POINTER TO COLOUR RAM HIGH BYTE     RTS;***********************************************************************************;;; UPDATE THE CLOCK, FLASH THE CURSOR, CONTROL THE CASSETTE AND SCAN THE KEYBOARD; IRQ HANDLERXXEABF = *     JSR     XXFFEA          ; INCREMENT REAL TIME CLOCK     LDA     XXCC          ; GET CURSOR ENABLE     BNE     XXEAEF          ; BRANCH IF NOT FLASH CURSOR     DEC     XXCD          ; ELSE DECREMENT CURSOR TIMING COUNTDOWN     BNE     XXEAEF          ; BRANCH IF NOT DONE     LDA     #$14               ; SET COUNT     STA     XXCD          ; SAVE CURSOR TIMING COUNTDOWN     LDY     XXD3          ; GET CURSOR COLUMN     LSR     XXCF          ; SHIFT B0 CURSOR BLINK PHASE INTO CARRY     LDX     XX0287          ; GET COLOUR UNDER CURSOR     LDA     (XXD1),Y          ; GET CHARACTER FROM CURRENT SCREEN LINE     BCS     XXEAEA          ; BRANCH IF CURSOR PHASE B0 WAS 1     INC     XXCF          ; SET CURSOR BLINK PHASE TO 1     STA     XXCE          ; SAVE CHARACTER UNDER CURSOR     JSR     XXEAB2          ; CALCULATE POINTER TO COLOUR RAM     LDA     (XXF3),Y          ; GET COLOUR RAM BYTE     STA     XX0287          ; SAVE COLOUR UNDER CURSOR     LDX     XX0286          ; GET CURRENT COLOUR CODE     LDA     XXCE          ; GET CHARACTER UNDER CURSORXXEAEA = *     EOR     #$80               ; TOGGLE B7 OF CHARACTER UNDER CURSOR     JSR     XXEAAA          ; SAVE CHARACTER AND COLOUR TO SCREEN @ CURSORXXEAEF = *     LDA     XX911F          ; GET VIA 1 DRA, NO HANDSHAKE     AND     #$40               ; MASK CASSETTE SWITCH SENSE     BEQ     XXEB01          ; BRANCH IF CASSETTE SENSE LOW                         ; CASSETTE SENSE WAS HIGH SO TURN OFF MOTOR AND CLEAR                         ; THE INTERLOCK     LDY     #$00               ; CLEAR Y     STY     XXC0          ; CLEAR THE TAPE MOTOR INTERLOCK     LDA     XX911C          ; GET VIA 1 PCR     ORA     #$02               ; SET CA2 HIGH, TURN OFF MOTOR     BNE     XXEB0A          ; BRANCH ALWAYS                         ; CASSETTE SENSE WAS LOW SO TURN ON MOTOR, PERHAPSXXEB01 = *     LDA     XXC0          ; GET TAPE MOTOR INTERLOCK     BNE     XXEB12          ; IF CASSETTE INTERLOCK <> 0 DON'T TURN ON MOTOR     LDA     XX911C          ; GET VIA 1 PCR     AND     #$FD               ; SET CA2 LOW, TURN ON MOTORXXEB0A = *     BIT     XX911E          ; TEST VIA 1 IER     BVS     XXEB12          ; IF T1 INTERRUPT ENABLED DON'T CHANGE MOTOR STATE     STA     XX911C          ; SET VIA 1 PCR, SET CA2 HIGH/LOWXXEB12 = *     JSR     XXEB1E          ; SCAN KEYBOARD     BIT     XX9124          ; TEST VIA 2 T1C_L, CLEAR THE TIMER INTERRUPT FLAG     PLA                    ; PULL Y     TAY                    ; RESTORE Y     PLA                    ; PULL X     TAX                    ; RESTORE X     PLA                    ; RESTORE A     RTI;***********************************************************************************;;; SCAN KEYBOARD PERFORMS THE FOLLOWING ..;; 1)     CHECK IF KEY PRESSED, IF NOT THEN EXIT THE ROUTINE;; 2)     INIT I/O PORTS OF VIA 2 FOR KEYBOARD SCAN AND SET POINTERS TO DECODE TABLE 1.;     CLEAR THE CHARACTER COUNTER;; 3)     SET ONE LINE OF PORT B LOW AND TEST FOR A CLOSED KEY ON PORT A BY SHIFTING THE;     BYTE READ FROM THE PORT. IF THE CARRY IS CLEAR THEN A KEY IS CLOSED SO SAVE THE;     COUNT WHICH IS INCREMENTED ON EACH SHIFT. CHECK FOR SHIFT/STOP/CBM KEYS AND;     FLAG IF CLOSED;; 4)     REPEAT STEP 3 FOR THE WHOLE MATRIX;; 5)     EVALUATE THE SHIFT/CTRL/C= KEYS, THIS MAY CHANGE THE DECODE TABLE SELECTED;; 6)     USE THE KEY COUNT SAVED IN STEP 3 AS AN INDEX INTO THE TABLE SELECTED IN STEP 5;; 7)     CHECK FOR KEY REPEAT OPERATION;; 8)     SAVE THE DECODED KEY TO THE BUFFER IF FIRST PRESS OR REPEAT; SCAN KEYBOARD; THIS ROUTINE WILL SCAN THE KEYBOARD AND CHECK FOR PRESSED KEYS. IT IS THE SAME; ROUTINE CALLED BY THE INTERRUPT HANDLER. IF A KEY IS DOWN, ITS ASCII VALUE IS; PLACED IN THE KEYBOARD QUEUE.XXEB1E = *     LDA     #$00               ; CLEAR A     STA     XX028D          ; CLEAR KEYBOARD SHIFT/CONTROL/C= FLAG     LDY     #$40               ; SET NO KEY     STY     XXCB          ; SAVE WHICH KEY     STA     XX9120          ; CLEAR VIA 2 DRB, KEYBOARD COLUMN     LDX     XX9121          ; GET VIA 2 DRA, KEYBOARD ROW     CPX     #$FF               ; COMPARE WITH ALL BITS SET     BEQ     XXEB8F          ; IF NO KEY PRESSED CLEAR CURRENT KEY AND EXIT (DOES                         ; FURTHER BEQ TO XXEBBA)     LDA     #$FE               ; SET COLUMN 0 LOW     STA     XX9120          ; SET VIA 2 DRB, KEYBOARD COLUMN     LDY     #$00               ; CLEAR KEY COUNT     LDA     #<XXEC5E          ; GET DECODE TABLE LOW BYTE     STA     XXF5          ; SET KEYBOARD POINTER LOW BYTE     LDA     #>XXEC5E          ; GET DECODE TABLE HIGH BYTE     STA     XXF6          ; SET KEYBOARD POINTER HIGH BYTEXXEB40 = *     LDX     #$08               ; SET ROW COUNT     LDA     XX9121          ; GET VIA 2 DRA, KEYBOARD ROW     CMP     XX9121          ; COMPARE WITH ITSELF     BNE     XXEB40          ; LOOP IF CHANGINGXXEB4A = *     LSR A                  ; SHIFT ROW TO CB     BCS     XXEB63          ; IF NO KEY CLOSED ON THIS ROW GO DO NEXT ROW     PHA                    ; SAVE ROW     LDA     (XXF5),Y          ; GET CHARACTER FROM DECODE TABLE     CMP     #$05               ; COMPARE WITH $05, THERE IS NO $05 KEY BUT THE CONTROL                         ; KEYS ARE ALL LESS THAN $05     BCS     XXEB60          ; IF NOT SHIFT/CONTROL/C=/STOP GO SAVE KEY COUNT                         ; ELSE WAS SHIFT/CONTROL/C=/STOP KEY     CMP     #$03               ; COMPARE WITH $03, STOP     BEQ     XXEB60          ; IF STOP GO SAVE KEY COUNT AND CONTINUE                         ; CHARACTER IS $01 - SHIFT, $02 - C= OR $04 - CONTROL     ORA     XX028D          ; OR KEYBOARD SHIFT/CONTROL/C= FLAG     STA     XX028D          ; SAVE KEYBOARD SHIFT/CONTROL/C= FLAG     BPL     XXEB62          ; SKIP SAVE KEY, BRANCH ALWAYSXXEB60 = *     STY     XXCB          ; SAVE KEY COUNTXXEB62 = *     PLA                    ; RESTORE ROWXXEB63 = *     INY                    ; INCREMENT KEY COUNT     CPY     #$41               ; COMPARE WITH MAX+1     BCS     XXEB71          ; EXIT LOOP IF >= MAX+1                         ; ELSE STILL IN MATRIX     DEX                    ; DECREMENT ROW COUNT     BNE     XXEB4A          ; LOOP IF MORE ROWS TO DO     SEC                    ; SET CARRY FOR KEYBOARD COLUMN SHIFT     ROL     XX9120          ; SHIFT VIA 2 DRB, KEYBOARD COLUMN     BNE     XXEB40          ; LOOP FOR NEXT COLUMN, BRANCH ALWAYSXXEB71 = *     JMP     (XX028F)          ; EVALUATE THE SHIFT/CTRL/C= KEYS, XXEBDC; KEY DECODING CONTINUES HERE AFTER THE SHIFT/CTRL/C= KEYS ARE EVALUATEDXXEB74 = *     LDY     XXCB          ; GET SAVED KEY COUNT     LDA     (XXF5),Y          ; GET CHARACTER FROM DECODE TABLE     TAX                    ; COPY CHARACTER TO X     CPY     XXC5          ; COMPARE KEY COUNT WITH LAST KEY COUNT     BEQ     XXEB84          ; IF THIS KEY = CURRENT KEY, KEY HELD, GO TEST REPEAT     LDY     #$10               ; SET REPEAT DELAY COUNT     STY     XX028C          ; SAVE REPEAT DELAY COUNT     BNE     XXEBBA          ; GO SAVE KEY TO BUFFER AND EXIT, BRANCH ALWAYSXXEB84 = *     AND     #$7F               ; CLEAR B7     BIT     XX028A          ; TEST KEY REPEAT     BMI     XXEBA1          ; BRANCH IF REPEAT ALL     BVS     XXEBD6          ; BRANCH IF REPEAT NONE     CMP     #$7F               ; COMPARE WITH END MARKERXXEB8F = *     BEQ     XXEBBA          ; IF $00/END MARKER GO SAVE KEY TO BUFFER AND EXIT     CMP     #$14               ; COMPARE WITH [INSERT]/[DELETE]     BEQ     XXEBA1          ; IF [INSERT]/[DELETE] GO TEST FOR REPEAT     CMP     #' '               ; COMPARE WITH [SPACE]     BEQ     XXEBA1          ; IF [SPACE] GO TEST FOR REPEAT     CMP     #$1D               ; COMPARE WITH [CURSOR RIGHT]     BEQ     XXEBA1          ; IF [CURSOR RIGHT] GO TEST FOR REPEAT     CMP     #$11               ; COMPARE WITH [CURSOR DOWN]     BNE     XXEBD6          ; IF NOT [CURSOR DOWN] JUST EXIT                         ; WAS ONE OF THE CURSOR MOVEMENT KEYS, INSERT/DELETE                         ; KEY OR THE SPACE BAR SO ALWAYS DO REPEAT TESTSXXEBA1 = *     LDY     XX028C          ; GET REPEAT DELAY COUNTER     BEQ     XXEBAB          ; BRANCH IF DELAY EXPIRED     DEC     XX028C          ; ELSE DECREMENT REPEAT DELAY COUNTER     BNE     XXEBD6          ; BRANCH IF DELAY NOT EXPIRED                         ; REPEAT DELAY COUNTER HAS EXPIREDXXEBAB = *     DEC     XX028B          ; DECREMENT REPEAT SPEED COUNTER     BNE     XXEBD6          ; BRANCH IF REPEAT SPEED COUNT NOT EXPIRED     LDY     #$04               ; SET FOR 4/60THS OF A SECOND     STY     XX028B          ; SET REPEAT SPEED COUNTER     LDY     XXC6          ; GET KEYBOARD BUFFER INDEX     DEY                    ; DECREMENT IT     BPL     XXEBD6          ; IF THE BUFFER ISN'T EMPTY JUST EXIT                         ; ELSE REPEAT THE KEY IMMEDIATELY; POSSIBLY SAVE THE KEY TO THE KEYBOARD BUFFER. IF THERE WAS NO KEY PRESSED OR THE KEY; WAS NOT FOUND DURING THE SCAN (POSSIBLY DUE TO KEY BOUNCE) THEN X WILL BE $FF HEREXXEBBA = *     LDY     XXCB          ; GET THE KEY COUNT     STY     XXC5          ; SAVE AS THE CURRENT KEY COUNT     LDY     XX028D          ; GET KEYBOARD SHIFT/CONTROL/C= FLAG     STY     XX028E          ; SAVE AS LAST KEYBOARD SHIFT PATTERN     CPX     #$FF               ; COMPARE CHARACTER WITH TABLE END MARKER OR NO KEY     BEQ     XXEBD6          ; IF TABLE END MARKER OR NO KEY JUST EXIT     TXA                    ; COPY CHARACTER TO A     LDX     XXC6          ; GET KEYBOARD BUFFER INDEX     CPX     XX0289          ; COMPARE WITH KEYBOARD BUFFER SIZE     BCS     XXEBD6          ; IF BUFFER FULL JUST EXIT     STA     XX0277,X          ; SAVE CHARACTER TO KEYBOARD BUFFER     INX                    ; INCREMENT INDEX     STX     XXC6          ; SAVE KEYBOARD BUFFER INDEXXXEBD6 = *     LDA     #$F7               ; ENABLE COLUMN 3 FOR STOP KEY     STA     XX9120          ; SET VIA 2 DRB, KEYBOARD COLUMN     RTS; EVALUATE SHIFT/CTRL/C= KEYS;; 0     $00     EC5E; 1     $02     EC9F; 2     $04     ECE0; 3     ..     ....; 4     $06     EDA3; 5     $06     EDA3; 6     $06     EDA3; 7     $06     EDA3XXEBDC = *     LDA     XX028D          ; GET KEYBOARD SHIFT/CONTROL/C= FLAG     CMP     #$03               ; COMPARE WITH [SHIFT][C=]     BNE     XXEC0F          ; BRANCH IF NOT [SHIFT][C=]     CMP     XX028E          ; COMPARE WITH LAST     BEQ     XXEBD6          ; EXIT IF STILL THE SAME     LDA     XX0291          ; GET SHIFT MODE SWITCH $00 = ENABLED, $80 = LOCKED     BMI     XXEC43          ; IF LOCKED CONTINUE KEYBOARD DECODE     NOP                    ; JUST A FEW WASTED CYCLES     NOP                    ;     NOP                    ;     NOP                    ;     NOP                    ;     NOP                    ;     NOP                    ;     NOP                    ;     NOP                    ;     NOP                    ;     NOP                    ;     NOP                    ;     NOP                    ;     NOP                    ;     NOP                    ;     NOP                    ;     NOP                    ;     NOP                    ;     NOP                    ;                         ; TOGGLE TEXT MODE     LDA     XX9005          ; GET START OF CHARACTER MEMORY, ROM     EOR     #$02               ; TOGGLE $8000,$8800     STA     XX9005          ; SET START OF CHARACTER MEMORY, ROM     NOP                    ;     NOP                    ;     NOP                    ;     NOP                    ;     JMP     XXEC43          ; CONTINUE KEYBOARD DECODE                         ; WAS NOT [SHIFT][C=] BUT COULD BE ANY OTHER COMBINATIONXXEC0F = *     ASL A                  ; << 1     CMP     #$08               ; COMPARE WITH [CTRL]     BCC     XXEC18          ; BRANCH IF NOT [CTRL] PRESSED     LDA     #$06               ; ELSE [CTRL] WAS PRESSED SO MAKE INDEX = $06     NOP                    ;     NOP                    ;XXEC18 = *     NOP                    ; JUST A FEW WASTED CYCLES     NOP                    ;     NOP                    ;     NOP                    ;     NOP                    ;     NOP                    ;     NOP                    ;     NOP                    ;     NOP                    ;     NOP                    ;     NOP                    ;     NOP                    ;     NOP                    ;     NOP                    ;     NOP                    ;     NOP                    ;     NOP                    ;     NOP                    ;     NOP                    ;     NOP                    ;     NOP                    ;     NOP                    ;     NOP                    ;     NOP                    ;     NOP                    ;     NOP                    ;     NOP                    ;     NOP                    ;     NOP                    ;     NOP                    ;     NOP                    ;     NOP                    ;     TAX                    ; COPY INDEX TO X     LDA     XXEC46,X          ; GET DECODE TABLE POINTER LOW BYTE     STA     XXF5          ; SAVE DECODE TABLE POINTER LOW BYTE     LDA     XXEC46+1,X     ; GET DECODE TABLE POINTER HIGH BYTE     STA     XXF6          ; SAVE DECODE TABLE POINTER HIGH BYTEXXEC43 = *     JMP     XXEB74          ; CONTINUE KEYBOARD DECODE;***********************************************************************************;;; KEYBOARD DECODE TABLE POINTERSXXEC46 = *     .WORD     XXEC5E          ; UNSHIFTED     .WORD     XXEC9F          ; SHIFTED     .WORD     XXECE0          ; COMMODORE     .WORD     XXEDA3          ; CONTROL     .WORD     XXEC5E          ; UNSHIFTED     .WORD     XXEC9F          ; SHIFTED     .WORD     XXED69          ; SHFITED     .WORD     XXEDA3          ; CONTROL     .WORD     XXED21          ; GRAPHICS/TEXT CONTROL     .WORD     XXED69          ; SHIFTED     .WORD     XXED69          ; SHIFTED     .WORD     XXEDA3          ; CONTROL; KEYBOARD DECODE TABLE - UNSHIFTEDXXEC5E = *     .BYTE     $31,$33,$35,$37,$39,$2B,$5C,$14     .BYTE     $5F,$57,$52,$59,$49,$50,$2A,$0D     .BYTE     $04,$41,$44,$47,$4A,$4C,$3B,$1D     .BYTE     $03,$01,$58,$56,$4E,$2C,$2F,$11     .BYTE     $20,$5A,$43,$42,$4D,$2E,$01,$85     .BYTE     $02,$53,$46,$48,$4B,$3A,$3D,$86     .BYTE     $51,$45,$54,$55,$4F,$40,$5E,$87     .BYTE     $32,$34,$36,$38,$30,$2D,$13,$88     .BYTE     $FF; KEYBOARD DECODE TABLE - SHIFTEDXXEC9F = *     .BYTE     $21,$23,$25,$27,$29,$DB,$A9,$94     .BYTE     $5F,$D7,$D2,$D9,$C9,$D0,$C0,$8D     .BYTE     $04,$C1,$C4,$C7,$CA,$CC,$5D,$9D     .BYTE     $83,$01,$D8,$D6,$CE,$3C,$3F,$91     .BYTE     $A0,$DA,$C3,$C2,$CD,$3E,$01,$89     .BYTE     $02,$D3,$C6,$C8,$CB,$5B,$3D,$8A     .BYTE     $D1,$C5,$D4,$D5,$CF,$BA,$DE,$8B     .BYTE     $22,$24,$26,$28,$30,$DD,$93,$8C     .BYTE     $FF; KEYBOARD DECODE TABLE - COMMODOREXXECE0 = *     .BYTE     $21,$23,$25,$27,$29,$A6,$A8,$94     .BYTE     $5F,$B3,$B2,$B7,$A2,$AF,$DF,$8D     .BYTE     $04,$B0,$AC,$A5,$B5,$B6,$5D,$9D     .BYTE     $83,$01,$BD,$BE,$AA,$3C,$3F,$91     .BYTE     $A0,$AD,$BC,$BF,$A7,$3E,$01,$89     .BYTE     $02,$AE,$BB,$B4,$A1,$5B,$3D,$8A     .BYTE     $AB,$B1,$A3,$B8,$B9,$A4,$DE,$8B     .BYTE     $22,$24,$26,$28,$30,$DC,$93,$8C     .BYTE     $FF;***********************************************************************************;;;## GRAPHICS/TEXT CONTROLXXED21 = *     CMP     #$0E               ; COMPARE WITH [SWITCH TO LOWER CASE]     BNE     XXED30          ; BRANCH IF NOT [SWITCH TO LOWER CASE]     LDA     #$02               ; SET FOR $8800, LOWER CASE CHARACTERS     ORA     XX9005          ; OR WITH START OF CHARACTER MEMORY, ROM     STA     XX9005          ; SAVE START OF CHARACTER MEMORY, ROM     JMP     XXE6DC          ; RESTORE REGISTERS, SET QUOTE FLAG AND EXITXXED30 = *     CMP     #$8E               ; COMPARE WITH [SWITCH TO UPPER CASE]     BNE     XXED3F          ; BRANCH IF NOT [SWITCH TO UPPER CASE]     LDA     #$FD               ; SET FOR $8000, UPPER CASE CHARACTERS     AND     XX9005          ; AND WITH START OF CHARACTER MEMORY, ROM     STA     XX9005          ; SAVE START OF CHARACTER MEMORY, ROMXXED3C = *     JMP     XXE6DC          ; RESTORE REGISTERS, SET QUOTE FLAG AND EXITXXED3F = *     CMP     #$08               ; COMPARE WITH DISABLE [SHIFT][C=]     BNE     XXED4D          ; BRANCH IF NOT DISABLE [SHIFT][C=]     LDA     #$80               ; SET TO LOCK SHIFT MODE SWITCH     ORA     XX0291          ; OR WITH SHIFT MODE SWITCH, $00 = ENABLED, $80 = LOCKED     STA     XX0291          ; SAVE SHIFT MODE SWITCH     BMI     XXED3C          ; BRANCH ALWAYSXXED4D = *     CMP     #$09               ; COMPARE WITH ENABLE [SHIFT][C=]     BNE     XXED3C          ; EXIT IF NOT ENABLE [SHIFT][C=]     LDA     #$7F               ; SET TO UNLOCK SHIFT MODE SWITCH     AND     XX0291          ; AND WITH SHIFT MODE SWITCH, $00 = ENABLED, $80 = LOCKED     STA     XX0291          ; SAVE SHIFT MODE SWITCH     BPL     XXED3C          ; BRANCH ALWAYS; MAKE NEXT SCREEN LINE START OF LOGICAL LINE, INCREMENT LINE LENGTH AND SET POINTERSXXED5B = *     INX                    ; INCREMENT SCREEN ROW     LDA     XXD9,X          ; GET START OF LINE X POINTER HIGH BYTE     ORA     #$80               ; MARK AS START OF LOGICAL LINE     STA     XXD9,X          ; SET START OF LINE X POINTER HIGH BYTE     DEX                    ; RESTORE SCREEN ROW     LDA     XXD5          ; GET CURRENT SCREEN LINE LENGTH     CLC                    ; CLEAR CARRY FOR ADD     JMP     XXE715          ; ADD ONE LINE LENGTH, SET POINTERS FOR START OF LINE AND                         ; RETURN;***********************************************************************************;;; KEYBOARD DECODE TABLE - SHIFTEDXXED69 = *     .BYTE     $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF     .BYTE     $FF,$04,$FF,$FF,$FF,$FF,$FF,$E2     .BYTE     $9D,$83,$01,$FF,$FF,$FF,$FF,$FF     .BYTE     $91,$A0,$FF,$FF,$FF,$FF,$EE,$01     .BYTE     $89,$02,$FF,$FF,$FF,$FF,$E1,$FD     .BYTE     $8A,$FF,$FF,$FF,$FF,$FF,$B0,$E0     .BYTE     $8B,$F2,$F4,$F6,$FF,$F0,$ED,$93     .BYTE     $8C,$FF; KEYBOARD DECODE TABLE - CONTROLXXEDA3 = *     .BYTE     $90,$1C,$9C,$1F,$12,$FF,$FF,$FF     .BYTE     $06,$FF,$12,$FF,$FF,$FF,$FF,$FF     .BYTE     $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF     .BYTE     $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF     .BYTE     $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF     .BYTE     $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF     .BYTE     $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF     .BYTE     $05,$9F,$1E,$9E,$92,$FF,$FF,$FF     .BYTE     $FF;***********************************************************************************;;; INITIAL VALUES FOR VIC REGISTERSXXEDE4 = *     .BYTE     $0C               ; INTERLACE AND HORIZONTAL CENTER [PAL];     .BYTE     $05               ; INTERLACE AND HORIZONTAL CENTER [NTSC]                         ; BIT     FUNCTION                         ; ---     --------                         ;  7     INTERLACE / NON INTERLACE                         ; 6-0     HORIZONTAL ORIGIN     .BYTE     $26               ; VERTICAL ORIGIN [PAL];     .BYTE     $19               ; VERTICAL ORIGIN [NTSC]     .BYTE     $16               ; VIDEO ADDRESS AND COLUMS, $9400 FOR COLOUR RAM                         ; BIT     FUNCTION                         ; ---     --------                         ;  7     VIDEO ADDRESS VA9                         ; 6-0     NUMBER OF COLUMNS     .BYTE     $2E               ; ROWS AND CHARACTER SIZE                         ; BIT     FUNCTION                         ; ---     --------                         ;  7     B9 RASTER LINE                         ; 6-1     NUMBER OF ROWS                         ;  0     8X16 / 8X8 CHARACTERS     .BYTE     $00               ; RASTER LINE     .BYTE     $C0               ; VIDEO MEMORY ADDRESSES, RAM $1000, ROM $8000                         ; BIT     FUNCTION                         ; ---     --------                         ;  7     MUST BE 1                         ; 6-4     VIDEO MEMORY ADDRESS VA12-VA10                         ; 3-0     CHARACTER MEMORY START ADDRESS                         ; 0000 ROM     $8000     SET 1 - WE USE THIS                         ; 0001  '     $8400                         ; 0010  '     $8800 SET 2                         ; 0011  '     $8C00                         ; 1100 RAM     $1000                         ; 1101  '     $1400                         ; 1110  '     $1800                         ; 1111  '     $1C00     .BYTE     $00               ; LIGHT PEN HORIZONTAL POSITION     .BYTE     $00               ; LIGHT PEN VERTICAL POSITION     .BYTE     $00               ; PADDLE X     .BYTE     $00               ; PADDLE Y     .BYTE     $00               ; OSCILLATOR 1 FREQUENCY     .BYTE     $00               ; OSCILLATOR 2 FREQUENCY     .BYTE     $00               ; OSCILLATOR 3 FREQUENCY     .BYTE     $00               ; NOISE SOURCE FREQUENCY     .BYTE     $00               ; AUX COLOUR AND VOLUME                         ; BIT     FUNCTION                         ; ---     --------                         ; 7-4     AUXILIARY COLOUR INFORMATION                         ; 3-0     VOLUME     .BYTE     $1B               ; SCREEN AND BORDER COLOUR                         ; BIT     FUNCTION                         ; ---     --------                         ; 7-4     BACKGROUND COLOUR                         ;  3     INVERTED OR NORMAL MODE                         ; 2-0     BORDER COLOUR;***********************************************************************************;;; KEYBOARD BUFFER FOR AUTO LOAD/RUNXXEDF4 = *     .BYTE     'LOAD',$0D,'RUN',$0D;***********************************************************************************;;; LOW BYTE SCREEN LINE ADDRESSESXXEDFD = *     .BYTE     $00,$16,$2C,$42     .BYTE     $58,$6E,$84,$9A     .BYTE     $B0,$C6,$DC,$F2     .BYTE     $08,$1E,$34,$4A     .BYTE     $60,$76,$8C,$A2     .BYTE     $B8,$CE,$E4;***********************************************************************************;;; COMMAND A SERIAL BUS DEVICE TO TALK; TO USE THIS ROUTINE THE ACCUMULATOR MUST FIRST BE LOADED WITH A DEVICE NUMBER; BETWEEN 4 AND 30. WHEN CALLED THIS ROUTINE CONVERTS THIS DEVICE NUMBER TO A TALK; ADDRESS. THEN THIS DATA IS TRANSMITTED AS A COMMAND ON THE SERIAL BUS.XXEE14 = *     ORA     #$40               ; OR WITH THE TALK COMMAND     .BYTE     $2C               ; MAKES NEXT LINE BIT XX2009;***********************************************************************************;;; COMMAND DEVICES ON THE SERIAL BUS TO LISTEN; THIS ROUTINE WILL COMMAND A DEVICE ON THE SERIAL BUS TO RECEIVE DATA. THE; ACCUMULATOR MUST BE LOADED WITH A DEVICE NUMBER BETWEEN 4 AND 31 BEFORE CALLING; THIS ROUTINE. LISTEN CONVERT THIS TO A LISTEN ADDRESS THEN TRANSMIT THIS DATA AS; A COMMAND ON THE SERIAL BUS. THE SPECIFIED DEVICE WILL THEN GO INTO LISTEN MODE; AND BE READY TO ACCEPT INFORMATION.XXEE17 = *     ORA     #$20               ; OR WITH THE LISTEN COMMAND     JSR     XXF160          ; CHECK RS232 BUS IDLE;***********************************************************************************;;; SEND CONTROL CHARACTERXXEE1C = *     PHA                    ; SAVE DEVICE ADDRESS     BIT     XX94          ; TEST DEFERRED CHARACTER FLAG     BPL     XXEE2B          ; BRANCH IF NO DEFERED CHARACTER     SEC                    ; FLAG EOI     ROR     XXA3          ; ROTATE INTO EOI FLAG BYTE     JSR     XXEE49          ; TX BYTE ON SERIAL BUS     LSR     XX94          ; CLEAR DEFERRED CHARACTER FLAG     LSR     XXA3          ; CLEAR EOI FLAGXXEE2B = *     PLA                    ; RESTORE DEVICE ADDRESS     STA     XX95          ; SAVE AS SERIAL DEFERED CHARACTER     JSR     XXE4A0          ; SET SERIAL DATA OUT HIGH     CMP     #$3F               ; COMPARE READ BYTE WITH $3F     BNE     XXEE38          ; BRANCH IF NOT $3F, THIS BRANCH WILL ALWAYS BE TAKEN AS                         ; AFTER VIA 2'S PCR IS READ IT IS ANDED WITH $DF, SO THE                         ; RESULT CAN NEVER BE $3F     JSR     XXEF84          ; SET SERIAL CLOCK HIGHXXEE38 = *     LDA     XX911F          ; GET VIA 1 DRA, NO HANDSHAKE     ORA     #$80               ; SET SERIAL ATN LOW     STA     XX911F          ; SET VIA 1 DRA, NO HANDSHAKE;***********************************************************************************;;; IF THE CODE DROPS THROUGH TO HERE THE SERIAL CLOCK IS LOW AND THE SERIAL DATA HAS BEEN; RELEASED SO THE FOLLOWING CODE WILL HAVE NO EFFECT APART FROM DELAYING THE FIRST BYTE; BY 1MS;## SET CLK/DATA, WAIT AND TX BYTE ON SERIAL BUSXXEE40 = *     JSR     XXEF8D          ; SET SERIAL CLOCK LOW     JSR     XXE4A0          ; SET SERIAL DATA OUT HIGH     JSR     XXEF96          ; 1MS DELAY;***********************************************************************************;;; TX BYTE ON SERIAL BUSXXEE49 = *     SEI                    ; DISABLE INTERRUPTS     JSR     XXE4A0          ; SET SERIAL DATA OUT HIGH     JSR     XXE4B2          ; GET SERIAL CLOCK STATUS     LSR A                  ; SHIFT SERIAL DATA TO CB     BCS     XXEEB4          ; IF DATA HIGH DO DEVICE NOT PRESENT     JSR     XXEF84          ; SET SERIAL CLOCK HIGH     BIT     XXA3          ; TEST EOI FLAG     BPL     XXEE66          ; BRANCH IF NOT EOI; I THINK THIS IS THE EOI SEQUENCE SO THE SERIAL CLOCK HAS BEEN RELEASED AND THE SERIAL; DATA IS BEING HELD LOW BY THE PERIPHERALS. FIRST UP WAIT FOR THE SERIAL DATA TO RISEXXEE5A = *     JSR     XXE4B2          ; GET SERIAL CLOCK STATUS     LSR A                  ; SHIFT SERIAL DATA TO CB     BCC     XXEE5A          ; LOOP IF DATA LOW; NOW THE DATA IS HIGH, EOI IS SIGNALLED BY WAITING FOR AT LEAST 200US WITHOUT PULLING; THE SERIAL CLOCK LINE LOW AGAIN. THE LISTENER SHOULD RESPOND BY PULLING THE SERIAL; DATA LINE LOWXXEE60 = *     JSR     XXE4B2          ; GET SERIAL CLOCK STATUS     LSR A                  ; SHIFT SERIAL DATA TO CB     BCS     XXEE60          ; LOOP IF DATA HIGH; THE SERIAL DATA HAS GONE LOW ENDING THE EOI SEQUENCE, NOW JUST WAIT FOR THE SERIAL; DATA LINE TO GO HIGH AGAIN OR, IF THIS ISN'T AN EOI SEQUENCE, JUST WAIT FOR THE SERIAL; DATA TO GO HIGH THE FIRST TIMEXXEE66 = *     JSR     XXE4B2          ; GET SERIAL CLOCK STATUS     LSR A                  ; SHIFT SERIAL DATA TO CB     BCC     XXEE66          ; LOOP IF DATA LOW; SERIAL DATA IS HIGH NOW PULL THE CLOCK LOW, PREFERABLY WITHIN 60US     JSR     XXEF8D          ; SET SERIAL CLOCK LOW; NOW THE VIC HAS TO SEND THE EIGHT BITS, LSB FIRST. FIRST IT SETS THE SERIAL DATA LINE; TO REFLECT THE BIT IN THE BYTE, THEN IT SETS THE SERIAL CLOCK TO HIGH. THE SERIAL; CLOCK IS LEFT HIGH FOR 26 CYCLES, 23US ON A PAL VIC, BEFORE IT IS AGAIN PULLED LOW; AND THE SERIAL DATA IS ALLOWED HIGH AGAIN     LDA     #$08               ; EIGHT BITS TO DO     STA     XXA5          ; SET SERIAL BUS BIT COUNTXXEE73 = *     LDA     XX911F          ; GET VIA 1 DRA, NO HANDSHAKE     CMP     XX911F          ; COMPARE WITH SELF     BNE     XXEE73          ; LOOP IF CHANGING     LSR A                  ; SERIAL CLOCK TO CARRY     LSR A                  ; SERIAL DATA TO CARRY     BCC     XXEEB7          ; IF DATA LOW DO TIMEOUT ON SERIAL BUS     ROR     XX95          ; ROTATE TRANSMIT BYTE     BCS     XXEE88          ; BRANCH IF BIT = 1     JSR     XXE4A9          ; ELSE SET SERIAL DATA OUT LOW     BNE     XXEE8B          ; BRANCH ALWAYSXXEE88 = *     JSR     XXE4A0          ; SET SERIAL DATA OUT HIGHXXEE8B = *     JSR     XXEF84          ; SET SERIAL CLOCK HIGH     NOP                    ; WASTE ..     NOP                    ; .. A ..     NOP                    ; .. CYCLE ..     NOP                    ; .. OR TWO     LDA     XX912C          ; GET VIA 2 PCR     AND     #$DF               ; SET CB2 LOW, SERIAL DATA OUT HIGH     ORA     #$02               ; SET CA2 HIGH, SERIAL CLOCK OUT LOW     STA     XX912C          ; SAVE VIA 2 PCR     DEC     XXA5          ; DECREMENT SERIAL BUS BIT COUNT     BNE     XXEE73          ; LOOP IF NOT ALL DONE; NOW ALL EIGHT BITS HAVE BEEN SENT IT'S UP TO THE PERIPHERAL TO SIGNAL THE BYTE WAS; RECEIVED BY PULLING THE SERIAL DATA LOW. THIS SHOULD BE DONE WITHIN ONE MILISECOND     LDA     #$04               ; WAIT FOR UP TO ABOUT 1MS     STA     XX9129          ; SET VIA 2 T2C_HXXEEA5 = *     LDA     XX912D          ; GET VIA 2 IFR     AND     #$20               ; MASK T2 INTERRUPT     BNE     XXEEB7          ; IF T2 INTERRUPT DO TIMEOUT ON SERIAL BUS     JSR     XXE4B2          ; GET SERIAL CLOCK STATUS     LSR A                  ; SHIFT SERIAL DATA TO CB     BCS     XXEEA5          ; IF DATA HIGH GO WAIT SOME MORE     CLI                    ; ENABLE INTERRUPTS     RTS;***********************************************************************************;;; DEVICE NOT PRESENTXXEEB4 = *     LDA     #$80               ; ERROR $80, DEVICE NOT PRESENT     .BYTE     $2C               ; MAKES NEXT LINE BIT XX03A9;***********************************************************************************;;; TIMEOUT ON SERIAL BUSXXEEB7 = *     LDA     #$03               ; ERROR $03, WRITE TIMEOUTXXEEB9 = *     JSR     XXFE6A          ; OR INTO SERIAL STATUS BYTE     CLI                    ; ENABLE INTERRUPTS     CLC                    ; CLEAR FOR BRANCH     BCC     XXEF09          ; ATN HIGH, DELAY, CLOCK HIGH THEN DATA HIGH, BRANCH ALWAYS;***********************************************************************************;;; SEND SECONDARY ADDRESS AFTER LISTEN; THIS ROUTINE IS USED TO SEND A SECONDARY ADDRESS TO AN I/O DEVICE AFTER A CALL TO; THE LISTEN ROUTINE IS MADE AND THE DEVICE COMMANDED TO LISTEN. THE ROUTINE CANNOT; BE USED TO SEND A SECONDARY ADDRESS AFTER A CALL TO THE TALK ROUTINE.; A SECONDARY ADDRESS IS USUALLY USED TO GIVE SET-UP INFORMATION TO A DEVICE BEFORE; I/O OPERATIONS BEGIN.; WHEN A SECONDARY ADDRESS IS TO BE SENT TO A DEVICE ON THE SERIAL BUS THE ADDRESS; MUST FIRST BE ORED WITH $60.XXEEC0 = *     STA     XX95          ; SAVE DEFERED BYTE     JSR     XXEE40          ; SET CLK/DATA, WAIT AND TX BYTE ON SERIAL BUS; SET SERIAL ATN HIGHXXEEC5 = *     LDA     XX911F          ; GET VIA 1 DRA, NO HANDSHAKE     AND     #$7F               ; SET SERIAL ATN HIGH     STA     XX911F          ; SET VIA 1 DRA, NO HANDSHAKE     RTS;***********************************************************************************;;; SEND SECONDARY ADDRESS AFTER TALK; THIS ROUTINE TRANSMITS A SECONDARY ADDRESS ON THE SERIAL BUS FOR A TALK DEVICE.; THIS ROUTINE MUST BE CALLED WITH A NUMBER BETWEEN 4 AND 31 IN THE ACCUMULATOR.; THE ROUTINE WILL SEND THIS NUMBER AS A SECONDARY ADDRESS COMMAND OVER THE SERIAL; BUS. THIS ROUTINE CAN ONLY BE CALLED AFTER A CALL TO THE TALK ROUTINE. IT WILL; NOT WORK AFTER A LISTEN.XXEECE = *     STA     XX95          ; SAVE THE SECONDARY ADDRESS BYTE TO TRANSMIT     JSR     XXEE40          ; SET CLK/DATA, WAIT AND TX BYTE ON SERIAL BUS;***********************************************************************************;;; WAIT FOR BUS END AFTER SENDXXEED3 = *     SEI                    ; DISABLE INTERRUPTS     JSR     XXE4A9          ; SET SERIAL DATA OUT LOW     JSR     XXEEC5          ; SET SERIAL ATN HIGH     JSR     XXEF84          ; SET SERIAL CLOCK HIGHXXEEDD = *     JSR     XXE4B2          ; GET SERIAL CLOCK STATUS     BCS     XXEEDD          ; BRANCH IF CLOCK HIGH     CLI                    ; ENABLE INTERRUPTS     RTS;***********************************************************************************;;; OUTPUT A BYTE TO THE SERIAL BUS; THIS ROUTINE IS USED TO SEND INFORMATION TO DEVICES ON THE SERIAL BUS. A CALL TO; THIS ROUTINE WILL PUT A DATA BYTE ONTO THE SERIAL BUS USING FULL HANDSHAKING.; BEFORE THIS ROUTINE IS CALLED THE LISTEN ROUTINE, XXFFB1, MUST BE USED TO; COMMAND A DEVICE ON THE SERIAL BUS TO GET READY TO RECEIVE DATA.; THE ACCUMULATOR IS LOADED WITH A BYTE TO OUTPUT AS DATA ON THE SERIAL BUS. A; DEVICE MUST BE LISTENING OR THE STATUS WORD WILL RETURN A TIMEOUT. THIS ROUTINE; ALWAYS BUFFERS ONE CHARACTER. SO WHEN A CALL TO THE UNLISTEN ROUTINE, XXFFAE,; IS MADE TO END THE DATA TRANSMISSION, THE BUFFERED CHARACTER IS SENT WITH EOI; SET. THEN THE UNLISTEN COMMAND IS SENT TO THE DEVICE.XXEEE4 = *     BIT     XX94          ; TEST DEFERRED CHARACTER FLAG     BMI     XXEEED          ; BRANCH IF DEFERED CHARACTER     SEC                    ; SET CARRY     ROR     XX94          ; SHIFT INTO DEFERRED CHARACTER FLAG     BNE     XXEEF2          ; SAVE BYTE AND EXIT, BRANCH ALWAYSXXEEED = *     PHA                    ; SAVE BYTE     JSR     XXEE49          ; TX BYTE ON SERIAL BUS     PLA                    ; RESTORE BYTEXXEEF2 = *     STA     XX95          ; SAVE DEFERED BYTE     CLC                    ; FLAG OK     RTS;***********************************************************************************;;; COMMAND THE SERIAL BUS TO UNTALK; THIS ROUTINE WILL TRANSMIT AN UNTALK COMMAND ON THE SERIAL BUS. ALL DEVICES; PREVIOUSLY SET TO TALK WILL STOP SENDING DATA WHEN THIS COMMAND IS RECEIVED.XXEEF6 = *     JSR     XXEF8D          ; SET SERIAL CLOCK LOW     LDA     XX911F          ; GET VIA 1 DRA, NO HANDSHAKE     ORA     #$80               ; SET SERIAL ATN LOW     STA     XX911F          ; SET VIA 1 DRA, NO HANDSHAKE     LDA     #$5F               ; SET THE UNTALK COMMAND     .BYTE     $2C               ; MAKES NEXT LINE BIT XX3FA9;***********************************************************************************;;; COMMAND THE SERIAL BUS TO UNLISTEN; THIS ROUTINE COMMANDS ALL DEVICES ON THE SERIAL BUS TO STOP RECEIVING DATA FROM; THE COMPUTER. CALLING THIS ROUTINE RESULTS IN AN UNLISTEN COMMAND BEING TRANSMITTED; ON THE SERIAL BUS. ONLY DEVICES PREVIOUSLY COMMANDED TO LISTEN WILL BE AFFECTED.; THIS ROUTINE IS NORMALLY USED AFTER THE COMPUTER IS FINISHED SENDING DATA TO; EXTERNAL DEVICES. SENDING THE UNLISTEN WILL COMMAND THE LISTENING DEVICES TO GET; OFF THE SERIAL BUS SO IT CAN BE USED FOR OTHER PURPOSES.XXEF04 = *     LDA     #$3F               ; SET THE UNLISTEN COMMAND     JSR     XXEE1C          ; SEND CONTROL CHARACTER; ATN HIGH, DELAY, CLOCK HIGH THEN DATA HIGHXXEF09 = *     JSR     XXEEC5          ; SET SERIAL ATN HIGH; 1MS DELAY, CLOCK HIGH THEN DATA HIGHXXEF0C = *     TXA                    ; SAVE DEVICE NUMBER     LDX     #$0B               ; SHORT DELAYXXEF0F = *     DEX                    ; DECREMENT COUNT     BNE     XXEF0F          ; LOOP IF NOT ALL DONE     TAX                    ; RESTORE DEVICE NUMBER     JSR     XXEF84          ; SET SERIAL CLOCK HIGH     JMP     XXE4A0          ; SET SERIAL DATA OUT HIGH AND RETURN;***********************************************************************************;;; INPUT A BYTE FROM THE SERIAL BUS; THIS ROUTINE READS A BYTE OF DATA FROM THE SERIAL BUS USING FULL HANDSHAKING. THE; DATA IS RETURNED IN THE ACCUMULATOR. BEFORE USING THIS ROUTINE THE TALK ROUTINE,; XXFFB4, MUST HAVE BEEN CALLED FIRST TO COMMAND THE DEVICE ON THE SERIAL BUS TO; SEND DATA ON THE BUS. IF THE INPUT DEVICE NEEDS A SECONDARY COMMAND IT MUST BE SENT; BY USING THE TKSA ROUTINE, XXFF96, BEFORE CALLING THIS ROUTINE.; ERRORS ARE RETURNED IN THE STATUS WORD WHICH CAN BE READ BY CALLING THE READST; ROUTINE, XXFFB7.XXEF19 = *     SEI                    ; DISABLE INTERRUPTS     LDA     #$00               ; CLEAR A     STA     XXA5          ; CLEAR SERIAL BUS BIT COUNT     JSR     XXEF84          ; SET SERIAL CLOCK HIGHXXEF21 = *     JSR     XXE4B2          ; GET SERIAL CLOCK STATUS     BCC     XXEF21          ; LOOP WHILE CLOCK LOW     JSR     XXE4A0          ; SET SERIAL DATA OUT HIGHXXEF29 = *     LDA     #$01               ; SET TIMEOUT COUNT HIGH BYTE     STA     XX9129          ; SET VIA 2 T2C_HXXEF2E = *     LDA     XX912D          ; GET VIA 2 IFR     AND     #$20               ; MASK T2 INTERRUPT     BNE     XXEF3C          ; BRANCH IF T2 INTERRUPT     JSR     XXE4B2          ; GET SERIAL CLOCK STATUS     BCS     XXEF2E          ; LOOP IF CLOCK HIGH     BCC     XXEF54          ; ELSE GO SE 8 BITS TO DO, BRANCH ALWAYS                         ; T2 TIMED OUTXXEF3C = *     LDA     XXA5          ; GET SERIAL BUS BIT COUNT     BEQ     XXEF45          ; IF NOT ALREADY EOI THEN GO FLAG EOI     LDA     #$02               ; ERROR $02, READ TIMEOUR     JMP     XXEEB9          ; SET SERIAL STATUS AND EXITXXEF45 = *     JSR     XXE4A9          ; SET SERIAL DATA OUT LOW     JSR     XXEF0C          ; 1MS DELAY, CLOCK HIGH THEN DATA HIGH     LDA     #$40               ; SET EOI     JSR     XXFE6A          ; OR INTO SERIAL STATUS BYTE     INC     XXA5          ; INCREMENT SERIAL BUS BIT COUNT, DO ERROR ON NEXT TIMEOUT     BNE     XXEF29          ; GO TRY AGAINXXEF54 = *     LDA     #$08               ; 8 BITS TO DO     STA     XXA5          ; SET SERIAL BUS BIT COUNTXXEF58 = *     LDA     XX911F          ; GET VIA 1 DRA, NO HANDSHAKE     CMP     XX911F          ; COMPARE WITH SELF     BNE     XXEF58          ; LOOP IF CHANGING     LSR A                  ; SERIAL CLOCK INTO CARRY     BCC     XXEF58          ; LOOP WHILE SERIAL CLOCK LOW     LSR A                  ; SERIAL DATA INTO CARRY     ROR     XXA4          ; SHIFT DATA BIT INTO RECEIVE BYTEXXEF66 = *     LDA     XX911F          ; GET VIA 1 DRA, NO HANDSHAKE     CMP     XX911F          ; COMPARE WITH SELF     BNE     XXEF66          ; LOOP IF CHANGING     LSR A                  ; SERIAL CLOCK INTO CARRY     BCS     XXEF66          ; LOOP WHILE SERIAL CLOCK HIGH     DEC     XXA5          ; DECREMENT SERIAL BUS BIT COUNT     BNE     XXEF58          ; LOOP IF NOT ALL DONE     JSR     XXE4A9          ; SET SERIAL DATA OUT LOW     LDA     XX90          ; GET SERIAL STATUS BYTE     BEQ     XXEF7F          ; BRANCH IF NO ERROR     JSR     XXEF0C          ; 1MS DELAY, CLOCK HIGH THEN DATA HIGHXXEF7F = *     LDA     XXA4          ; GET RECEIVE BYTE     CLI                    ; ENABLE INTERRUPTS     CLC     RTS;***********************************************************************************;;; SET SERIAL CLOCK HIGHXXEF84 = *     LDA     XX912C          ; GET VIA 2 PCR     AND     #$FD               ; SET CA2 LOW, SERIAL CLOCK OUT HIGH     STA     XX912C          ; SET VIA 2 PCR     RTS;***********************************************************************************;;; SET SERIAL CLOCK LOWXXEF8D = *     LDA     XX912C          ; GET VIA 2 PCR     ORA     #$02               ; SET CA2 HIGH, SERIAL CLOCK OUT LOW     STA     XX912C          ; SET VIA 2 PCR     RTS;***********************************************************************************;;; 1MS DELAYXXEF96 = *     LDA     #$04               ; SET FOR 1024 CYCLES     STA     XX9129          ; SET VIA 2 T2C_HXXEF9B = *     LDA     XX912D          ; GET VIA 2 IFR     AND     #$20               ; MASK T2 INTERRUPT     BEQ     XXEF9B          ; LOOP UNTIL T2 INTERRUPT     RTS;***********************************************************************************;;; RS232 TX NMI ROUTINEXXEFA3 = *     LDA     XXB4          ; GET RS232 BIT COUNT     BEQ     XXEFEE          ; IF ZERO GO SETUP NEXT RS232 TX BYTE AND RETURN     BMI     XXEFE8          ; IF -VE GO DO STOP BIT(S)                         ; ELSE BIT COUNT IS NON ZERO AND +VE     LSR     XXB6          ; SHIFT RS232 OUTPUT BYTE BUFFER     LDX     #$00               ; SET $00 FOR BIT = 0     BCC     XXEFB0          ; BRANCH IF BIT WAS 0     DEX                    ; SET $FF FOR BIT = 1XXEFB0 = *     TXA                    ; COPY BIT TO A     EOR     XXBD          ; EOR WITH RS232 PARITY BYTE     STA     XXBD          ; SAVE RS232 PARITY BYTE     DEC     XXB4          ; DECREMENT RS232 BIT COUNT     BEQ     XXEFBF          ; IF RS232 BIT COUNT NOW ZERO GO DO PARITY BIT; SAVE BIT AND EXITXXEFB9 = *     TXA                    ; COPY BIT TO A     AND     #$20               ; MASK FOR CB2 CONTROL BIT     STA     XXB5          ; SAVE RS232 NEXT BIT TO SEND     RTS; DO RS232 PARITY BIT, ENTERS WITH RS232 BIT COUNT = 0XXEFBF = *     LDA     #$20               ; MASK 00X0 0000, PARITY ENABLE BIT     BIT     XX0294          ; TEST PSEUDO 6551 COMMAND REGISTER     BEQ     XXEFDA          ; BRANCH IF PARITY DISABLED     BMI     XXEFE4          ; BRANCH IF FIXED MARK OR SPACE PARITY     BVS     XXEFDE          ; BRANCH IF EVEN PARITY                         ; ELSE ODD PARITY     LDA     XXBD          ; GET RS232 PARITY BYTE     BNE     XXEFCF          ; IF PARITY NOT ZERO LEAVE PARITY BIT = 0XXEFCE = *     DEX                    ; MAKE PARITY BIT = 1XXEFCF = *     DEC     XXB4          ; DECREMENT RS232 BIT COUNT, 1 STOP BIT     LDA     XX0293          ; GET PSEUDO 6551 CONTROL REGISTER     BPL     XXEFB9          ; IF 1 STOP BIT SAVE PARITY BIT AND EXIT                         ; ELSE TWO STOP BITS ..     DEC     XXB4          ; DECREMENT RS232 BIT COUNT, 2 STOP BITS     BNE     XXEFB9          ; SAVE BIT AND EXIT, BRANCH ALWAYS                         ; PARITY IS DISABLED SO THE PARITY BIT BECOMES THE FIRST,                         ; AND POSSIBLY ONLY, STOP BIT. TO DO THIS INCREMENT THE BIT                         ; COUNT WHICH EFFECTIVELY DECREMENTS THE STOP BIT COUNT.XXEFDA = *     INC     XXB4          ; INCREMENT RS232 BIT COUNT, = -1 STOP BIT     BNE     XXEFCE          ; SET STOP BIT = 1 AND EXIT                         ; DO EVEN PARITYXXEFDE = *     LDA     XXBD          ; GET RS232 PARITY BYTE     BEQ     XXEFCF          ; IF PARITY ZERO LEAVE PARITY BIT = 0     BNE     XXEFCE          ; ELSE MAKE PARITY BIT = 1, BRANCH ALWAYS                         ; FIXED MARK OR SPACE PARITYXXEFE4 = *     BVS     XXEFCF          ; IF FIXED SPACE PARITY LEAVE PARITY BIT = 0     BVC     XXEFCE          ; ELSE FIXED MARK PARITY MAKE PARITY BIT = 1, BRANCH ALWAYS; DECREMENT STOP BIT COUNT, SET STOP BIT = 1 AND EXIT. $FF IS ONE STOP BIT, $FE IS TWO; STOP BITSXXEFE8 = *     INC     XXB4          ; DECREMENT RS232 BIT COUNT     LDX     #$FF               ; SET STOP BIT = 1     BNE     XXEFB9          ; SAVE STOP BIT AND EXIT, BRANCH ALWAYS; SETUP NEXT RS232 TX BYTEXXEFEE = *     LDA     XX0294          ; GET 6551 PSEUDO COMMAND REGISTER     LSR A                  ; HANDSHAKE BIT INOT CB     BCC     XXEFFB          ; BRANCH IF 3 LINE INTERFACE     BIT     XX9120          ; TEST VIA 2 DRB, THIS IS WRONG, THE ADRESS SHOULD BE                         ; XX9110 WHICH IS VIA 1 WHICH IS WHERE THE DSR AND                         ; CTS INPUTS REALLY ARE ##     BPL     XXF016          ; IF DSR = 0 SET DSR SIGNAL NOT PRESENT AND EXIT     BVC     XXF019          ; IF CTS = 0 SET CTS SIGNAL NOT PRESENT AND EXIT                         ; WAS 3 LINE INTERFACEXXEFFB = *     LDA     #$00               ; CLEAR A     STA     XXBD          ; CLEAR RS232 PARITY BYTE     STA     XXB5          ; CLEAR RS232 NEXT BIT TO SEND     LDX     XX0298          ; GET NUMBER OF BITS TO BE SENT/RECEIVED     STX     XXB4          ; SET RS232 BIT COUNT     LDY     XX029D          ; GET INDEX TO TX BUFFER START     CPY     XX029E          ; COMPARE WITH INDEX TO TX BUFFER END     BEQ     XXF021          ; IF ALL DONE GO DISABLE T1 INTERRUPT AND RETURN     LDA     (XXF9),Y          ; ELSE GET BYTE FROM BUFFER     STA     XXB6          ; SAVE TO RS232 OUTPUT BYTE BUFFER     INC     XX029D          ; INCREMENT INDEX TO TX BUFFER START     RTS;***********************************************************************************;;;## EXIT OR QUIT; SET DSR SIGNAL NOT PRESENTXXF016 = *     LDA     #$40               ; SET DSR SIGNAL NOT PRESENT     .BYTE     $2C               ; MAKES NEXT LINE BIT XX10A9; SET CTS SIGNAL NOT PRESENTXXF019 = *     LDA     #$10               ; SET CTS SIGNAL NOT PRESENT     ORA     XX0297          ; OR WITH RS232 STATUS REGISTER     STA     XX0297          ; SAVE RS232 STATUS REGISTER; DISABLE T1 INTERRUPTXXF021 = *     LDA     #$40               ; DISABLE T1 INTERRUPT     STA     XX911E          ; SET VIA 1 IER     RTS;***********************************************************************************;;; COMPUTE BIT COUNTXXF027 = *     LDX     #$09               ; SET BIT COUNT TO 9, 8 DATA + 1 STOP BIT     LDA     #$20               ; MASK FOR 8/7 DATA BITS     BIT     XX0293          ; TEST PSEUDO 6551 CONTROL REGISTER     BEQ     XXF031          ; BRANCH IF 8 BITS     DEX                    ; ELSE DECREMENT COUNT FOR 7 DATA BITSXXF031 = *     BVC     XXF035          ; BRANCH IF 7 BITS     DEX                    ; ELSE DECREMENT COUNT ..     DEX                    ; .. FOR 5 DATA BITSXXF035 = *     RTS;***********************************************************************************;;; RS232 RX NMIXXF036 = *     LDX     XXA9          ; GET START BIT CHECK FLAG     BNE     XXF068          ; BRANCH IF NO START BIT RECEIVED     DEC     XXA8          ; DECREMENT RECEIVER BIT COUNT IN     BEQ     XXF06F          ;.     BMI     XXF04D          ;.     LDA     XXA7          ; GET RECEIVER INPUT BIT TEMPORARY STORAGE     EOR     XXAB          ;.     STA     XXAB          ;.     LSR     XXA7          ; SHIFT RECEIVER INPUT BIT TEMPORARY STORAGE     ROR     XXAA          ;.XXF04A = *     RTSXXF04B = *     DEC     XXA8          ; DECREMENT RECEIVER BIT COUNT INXXF04D = *     LDA     XXA7          ; GET RECEIVER INPUT BIT TEMPORARY STORAGE     BEQ     XXF0B3          ;.     LDA     XX0293          ; GET PSEUDO 6551 CONTROL REGISTER     ASL A                  ;.     LDA     #$01               ;.     ADC     XXA8          ; ADD RECEIVER BIT COUNT IN     BNE     XXF04A          ;.;***********************************************************************************;;;## SETUP TO RXXXF05B = *     LDA     #$90               ; ENABLE CB1 INTERRUPT     STA     XX911E          ; SET VIA 1 IER     STA     XXA9          ; SET START BIT CHECK FLAG, SET NO START BIT RECEIVED     LDA     #$20               ; DISABLE T2 INTERRUPT     STA     XX911E          ; SET VIA 1 IER     RTS;***********************************************************************************;;; NO RS232 START BIT RECEIVEDXXF068 = *     LDA     XXA7          ; GET RECEIVER INPUT BIT TEMPORARY STORAGE     BNE     XXF05B          ;.     STA     XXA9          ; SET START BIT CHECK FLAG, SET START BIT RECEIVED     RTS;***********************************************************************************;;; ??XXF06F = *     LDY     XX029B          ; GET INDEX TO RX BUFFER END     INY                    ; INCREMENT INDEX     CPY     XX029C          ; COMPARE WITH INDEX TO RX BUFFER START     BEQ     XXF0A2          ; IF BUFFER FULL GO DO RX OVERRUN ERROR     STY     XX029B          ; SAVE INDEX TO RX BUFFER END     DEY                    ; DECREMENT INDEX     LDA     XXAA          ; GET ASSEMBLED BYTE     LDX     XX0298          ; GET BIT COUNTXXF081 = *     CPX     #$09               ; COMPARE WITH BYTE + STOP     BEQ     XXF089          ; BRANCH IF ALL NINE BITS RECEIVED     LSR A                  ; ELSE SHIFT BYTE     INX                    ; INCREMENT BIT COUNT     BNE     XXF081          ; LOOP, BRANCH ALWAYSXXF089 = *     STA     (XXF7),Y          ; SAVE RECEIVED BYTE TO RX BUFFER     LDA     #$20               ; MASK 00X0 0000, PARITY ENABLE BIT     BIT     XX0294          ; TEST PSEUDO 6551 COMMAND REGISTER     BEQ     XXF04B          ; BRANCH IF PARITY DISABLED     BMI     XXF04A          ; BRANCH IF MARK OR SPACE PARITY     LDA     XXA7          ; GET RECEIVER INPUT BIT TEMPORARY STORAGE     EOR     XXAB          ;.     BEQ     XXF09D          ;.     BVS     XXF04A          ;.     .BYTE     $2C               ; MAKES NEXT LINE BIT XXAB50XXF09D = *     BVC     XXF04A          ;.     LDA     #$01               ; SET RX PARITY ERROR     .BYTE     $2C               ; MAKES NEXT LINE BIT XX04A9XXF0A2 = *     LDA     #$04               ; SET RX OVERRUN ERROR     .BYTE     $2C               ; MAKES NEXT LINE BIT XX80A9XXF0A5 = *     LDA     #$80               ; RX BREAK ERROR     .BYTE     $2C               ; MAKES NEXT LINE BIT XX02A9XXF0A8 = *     LDA     #$02               ; RX FRAME ERROR     ORA     XX0297          ; OR WITH RS232 STATUS BYTE     STA     XX0297          ; SAVE RS232 STATUS BYTE     JMP     XXF05B          ;.XXF0B3 = *     LDA     XXAA          ;.     BNE     XXF0A8          ; IF ?? DO FRAME ERROR     BEQ     XXF0A5          ; ELSE DO BREAK ERROR, BRANCH ALWAYS;***********************************************************************************;;; DO ILLEGAL DEVICE NUMBERXXF0B9 = *     JMP     XXF796          ; DO ILLEGAL DEVICE NUMBER AND RETURN;***********************************************************************************;;; OPEN RS232 CHANNEL FOR OUTPUTXXF0BC = *     STA     XX9A          ; SAVE OUTPUT DEVICE NUMBER     LDA     XX0294          ; GET PSEUDO 6551 COMMAND REGISTER     LSR A                  ; SHIFT HANDSHAKE BIT TO CARRY     BCC     XXF0EB          ; BRANCH IF 3 LINE INTERFACE     LDA     #$02               ; MASK FOR RTS OUT     BIT     XX9110          ; TEST VIA 1 DRB     BPL     XXF0E8          ; IF DSR = 0 SET DSR NOT PRESENT AND EXIT     BNE     XXF0EB          ; IF RTS = 1 JUST EXITXXF0CD = *     LDA     XX911E          ; GET VIA 1 IER     AND     #$30               ; MASK 00XX 0000, T2 AND CB1 INTERRUPTS     BNE     XXF0CD          ; LOOP WHILE EITHER ENABLEDXXF0D4 = *     BIT     XX9110          ; TEST VIA 1 DRB     BVS     XXF0D4          ; LOOP WHILE CTS HIGH     LDA     XX9110          ; GET VIA 1 DRB     ORA     #$02               ; SET RTS HIGH     STA     XX9110          ; SAVE VIA 1 DRBXXF0E1 = *     BIT     XX9110          ; TEST VIA 1 DRB     BVS     XXF0EB          ; EXIT IF CTS HIGH     BMI     XXF0E1          ; LOOP WHILE DSR HIGHXXF0E8 = *     JSR     XXF016          ; SET DSR SIGNAL NOT PRESENTXXF0EB = *     CLC                    ; FLAG OK     RTS;***********************************************************************************;;; SEND BYTE TO RS232 BUFFERXXF0ED = *     LDY     XX029E          ; GET INDEX TO TX BUFFER END     INY                    ; + 1     CPY     XX029D          ; COMPARE WITH INDEX TO TX BUFFER START     BEQ     XXF0ED          ; LOOP WHILE BUFFER FULL     STY     XX029E          ; SET INDEX TO TX BUFFER END     DEY                    ; INDEX TO AVAILABLE BUFFER BYTE     STA     (XXF9),Y          ; SAVE BYTE TO BUFFER     BIT     XX911E          ; TEST VIA 1 IER     BVC     XXF102          ; BRANCH IF T1 NOT ENABLED     RTSXXF102 = *     LDA     XX0299          ; GET BAUD RATE BIT TIME LOW BYTE     STA     XX9114          ; SET VIA 1 T1C_L     LDA     XX029A          ; GET BAUD RATE BIT TIME HIGH BYTE     STA     XX9115          ; SET VIA 1 T1C_H     LDA     #$C0               ; ENABLE T1 INTERRUPT     STA     XX911E          ; SET VIA 1 IER     JMP     XXEFEE          ; SETUP NEXT RS232 TX BYTE AND RETURN;***********************************************************************************;;; INPUT FROM RS232 BUFFERXXF116 = *     STA     XX99          ; SAVE INPUT DEVICE NUMBER     LDA     XX0294          ; GET PSEUDO 6551 COMMAND REGISTER     LSR A                  ;.     BCC     XXF146          ; BRANCH IF 3 LINE INTERFACE     AND     #$08               ; MASK DUPLEX BIT, PSEUDO 6551 COMMAND IS >> 1     BEQ     XXF146          ; BRANCH IF FULL DUPLEX     LDA     #$02               ;.     BIT     XX9110          ; TEST VIA 1 DRB     BPL     XXF0E8          ;.     BEQ     XXF144          ;.XXF12B = *     BIT     XX911E          ; TEST VIA 1 IER     BVS     XXF12B          ; LOOP WHILE T1 INTERRUPT ENABLED     LDA     XX9110          ; GET VIA 1 DRB     AND     #$FD               ; MASK XXXX XX0X, CLEAR RTS OUT     STA     XX9110          ; SAVE VIA 1 DRBXXF138 = *     LDA     XX9110          ; GET VIA 1 DRB     AND     #$04               ; MASK XXXX X1XX, DTR     BEQ     XXF138          ; LOOP WHILE DTR LOWXXF13F = *     LDA     #$90               ; ENABLE CB1 INTERRUPT     STA     XX911E          ; SET VIA 1 IERXXF144 = *     CLC                    ;.     RTSXXF146 = *     LDA     XX911E          ; GET VIA 1 IER     AND     #$30               ; MASK 0XX0 0000, T1 AND T2 INTERRUPTS     BEQ     XXF13F          ; IF BOTH INTERRUPTS DISABLED GO ENABLE CB1                         ; INTERRUPT AND EXIT     CLC                    ;.     RTS;***********************************************************************************;;; GET BYTE FROM RS232 BUFFERXXF14F = *     LDY     XX029C          ; GET INDEX TO RX BUFFER START     CPY     XX029B          ; COMPARE WITH INDEX TO RX BUFFER END     BEQ     XXF15D          ; RETURN NULL IF BUFFER EMPTY     LDA     (XXF7),Y          ; GET BYTE FROM RX BUFFER     INC     XX029C          ; INCREMENT INDEX TO RX BUFFER START     RTSXXF15D = *     LDA     #$00               ; RETURN NULL     RTS;***********************************************************************************;;; CHECK RS232 BUS IDLEXXF160 = *     PHA                    ; SAVE A     LDA     XX911E          ; GET VIA 1 IER     BEQ     XXF172          ; BRANCH IF NO INTERRUPTS ENABLED. THIS BRANCH WILL                         ; NEVER BE TAKEN AS B7 OF IER ALWAYS READS AS 1                         ; ACCORDING TO THE 6522 DATA SHEETXXF166 = *     LDA     XX911E          ; GET VIA 1 IER     AND     #$60               ; MASK 0XX0 0000, T1 AND T2 INTERRUPTS     BNE     XXF166          ; LOOP IF T1 OR T2 ACTIVE     LDA     #$10               ; DISABLE CB1 INTERRUPT     STA     XX911E          ; SET VIA 1 IERXXF172 = *     PLA                    ; RESTORE A     RTS;***********************************************************************************;;; KERNEL I/O MESSAGESXXF174 = *     .BYTE     $0D,'I/O ERROR ',$A3             ;'#'+$80XXF180 = *     .BYTE     $0D,'SEARCHING',$A0              ;' '+$80XXF18B = *     .BYTE     'FOR',$A0                        ;' '+$80XXF18F = *     .BYTE     $0D,'PRESS PLAY ON TAP',$C5      ;'E'+$80XXF1A2 = *     .BYTE     'PRESS RECORD & PLAY ON TAP',$C5 ;'E'+$80XXF1BD = *     .BYTE     $0D,'LOADIN',$C7                 ;'G'+$80XXF1C5 = *     .BYTE     $0D,'SAVING',$A0                 ;' '+$80XXF1CD = *     .BYTE     $0D,'VERIFYIN',$C7               ;'G'+$80XXF1D7 = *     .BYTE     $0D,'FOUND',$A0                  ;' '+$80XXF1DE = *     .BYTE     $0D,'OK',$0D+$80;***********************************************************************************;;; DISPLAY CONTROL I/O MESSAGE IF IN DIRECT MODEXXF1E2 = *     BIT     XX9D          ; TEST MESSAGE MODE FLAG     BPL     XXF1F3          ; EXIT IF CONTROL MESSAGES OFF; DISPLAY KERNEL I/O MESSAGEXXF1E6 = *     LDA     XXF174,Y          ; GET BYTE FROM MESSAGE TABLE     PHP                    ; SAVE STATUS     AND     #$7F               ; CLEAR B7     JSR     XXFFD2          ; OUTPUT CHARACTER TO CHANNEL     INY                    ; INCREMENT INDEX     PLP                    ; RESTORE STATUS     BPL     XXF1E6          ; LOOP IF NOT END OF MESSAGEXXF1F3 = *     CLC                    ;.     RTS;***********************************************************************************;;; GET A CHARACTER FROM THE INPUT DEVICE; IN PRACTICE THIS ROUTINE OPERATES IDENTICALLY TO THE CHRIN ROUTINE, XXFFCF,; FOR ALL DEVICES EXCEPT FOR THE KEYBOARD. IF THE KEYBOARD IS THE CURRENT INPUT; DEVICE THIS ROUTINE WILL GET ONE CHARACTER FROM THE KEYBOARD BUFFER. IT DEPENDS; ON THE IRQ ROUTINE TO READ THE KEYBOARD AND PUT CHARACTERS INTO THE BUFFER.; IF THE KEYBOARD BUFFER IS EMPTY THE VALUE RETURNED IN THE ACCUMULATOR WILL BE ZEROXXF1F5 = *     LDA     XX99          ; GET INPUT DEVICE NUMBER     BNE     XXF201          ; BRANCH IF NOT KEYBOARD                         ; INPUT DEVICE WAS KEYBOARD     LDA     XXC6          ; GET KEYBOARD BUFFER LENGTH     BEQ     XXF26A          ; IF BUFFER EMPTY GO FLAG NO BYTE AND RETURN     SEI                    ; DISABLE INTERRUPTS     JMP     XXE5CF          ; INPUT FROM KEYBOARD BUFFER AND RETURN                         ; INPUT DEVICE WAS NOT KEYBOARDXXF201 = *     CMP     #$02               ; COMPARE DEVICE WITH RS232 DEVICE     BNE     XXF21D          ; BRANCH IF NOT RS232 DEVICE                         ; INPUT DEVICE IS RS232 DEVICEXXF205 = *     STY     XX97          ; SAVE Y     JSR     XXF14F          ; GET BYTE FROM RS232 BUFFER     LDY     XX97          ; RESTORE Y     CLC                    ; FLAG NO ERROR     RTS;***********************************************************************************;;; INPUT CHARACTER FROM CHANNEL; THIS ROUTINE WILL GET A BYTE OF DATA FROM THE CHANNEL ALREADY SET UP AS THE INPUT; CHANNEL BY THE CHKIN ROUTINE, XXFFC6.; IF CHKIN, XXFFC6, HAS NOT BEEN USED TO DEFINE ANOTHER INPUT CHANNEL THE DATA IS; EXPECTED TO BE FROM THE KEYBOARD. THE DATA BYTE IS RETURNED IN THE ACCUMULATOR. THE; CHANNEL REMAINS OPEN AFTER THE CALL.; INPUT FROM THE KEYBOARD IS HANDLED IN A SPECIAL WAY. FIRST, THE CURSOR IS TURNED ON; AND IT WILL BLINK UNTIL A CARRIAGE RETURN IS TYPED ON THE KEYBOARD. ALL CHARACTERS; ON THE LOGICAL LINE, UP TO 88 CHARACTERS, WILL BE STORED IN THE BASIC INPUT BUFFER.; THEN THE CHARACTERS CAN BE RETURNED ONE AT A TIME BY CALLING THIS ROUTINE ONCE FOR; EACH CHARACTER. WHEN THE CARRIAGE RETURN IS RETURNED THE ENTIRE LINE HAS BEEN; PROCESSED. THE NEXT TIME THIS ROUTINE IS CALLED THE WHOLE PROCESS BEGINS AGAIN.XXF20E = *     LDA     XX99          ; GET INPUT DEVICE NUMBER     BNE     XXF21D          ; IF IT'S NOT THE KEYBOARD CONTINUE                         ; THE INPUT DEVICE IS THE KEYBOARD     LDA     XXD3          ; GET CURSOR COLUMN     STA     XXCA          ; SET INPUT CURSOR COLUMN     LDA     XXD6          ; GET CURSOR ROW     STA     XXC9          ; SET INPUT CURSOR ROW     JMP     XXE64F          ; GO GET INPUT FROM THE KEYBOARD; THE INPUT DEVICE WAS NOT THE KEYBOARDXXF21D = *     CMP     #$03               ; COMPARE DEVICE NUMBER WITH SCREEN     BNE     XXF22A          ; IF IT'S NOT THE SCREEN CONTINUE                         ; THE INPUT DEVICE IS THE SCREEN     STA     XXD0          ; INPUT FROM KEYBOARD OR SCREEN, $XX = SCREEN,                         ; $00 = KEYBOARD     LDA     XXD5          ; GET CURRENT SCREEN LINE LENGTH     STA     XXC8          ; SAVE INPUT [EOL] POINTER     JMP     XXE64F          ; GO GET INPUT FROM THE SCREEN; THE INPUT DEVICE WAS NOT THE SCREENXXF22A = *     BCS     XXF264          ; IF INPUT DEVICE IS THE SERIAL BUS GO HANDLE IT; THE INPUT DEVICE IS < THE SCREEN DO MUST BE THE RS232 OR TAPE DEVICE     CMP     #$02               ; COMPARE DEVICE WITH RS232 DEVICE     BEQ     XXF26F          ; IF IT'S THE RS232 DEVICE GO HANDLE IT; ELSE THERE'S ONLY THE TAPE DEVICE LEFT ..     STX     XX97          ; SAVE X     JSR     XXF250          ; GET BYTE FROM TAPE     BCS     XXF24D          ; EXIT IF ERROR     PHA                    ; SAVE BYTE     JSR     XXF250          ; GET NEXT BYTE FROM TAPE     BCS     XXF24A          ; EXIT IF ERROR     BNE     XXF244          ; BRANCH IF END REACHED     LDA     #$40               ; SET [EOF] BIT     JSR     XXFE6A          ; OR INTO SERIAL STATUS BYTEXXF244 = *     DEC     XXA6          ; DECREMENT TAPE BUFFER INDEX     LDX     XX97          ; RESTORE X     PLA                    ; RESTORE SAVED BYTE     RTS; ERROR EXIT FROM INPUT CHARACTERXXF24A = *     TAX                    ; COPY ERROR BYTE ??     PLA                    ; DUMP SAVED BYTE     TXA                    ; RESTORE ERROR BYTE ??XXF24D = *     LDX     XX97          ; RESTORE X     RTS;***********************************************************************************;;; GET BYTE FROM TAPEXXF250 = *     JSR     XXF88A          ; BUMP TAPE POINTER     BNE     XXF260          ; IF NOT END GET NEXT BYTE AND EXIT     JSR     XXF8C0          ; INITIATE TAPE READ     BCS     XXF26B          ; EXIT IF ERROR FLAGGED     LDA     #$00               ; CLEAR A     STA     XXA6          ; CLEAR TAPE BUFFER INDEX     BEQ     XXF250          ; LOOP, BRANCH ALWAYSXXF260 = *     LDA     (XXB2),Y          ; GET NEXT BYTE FROM BUFFER     CLC                    ; FLAG NO ERROR     RTS;***********************************************************************************;;; THE INPUT DEVICE WAS THE SERIAL BUSXXF264 = *     LDA     XX90          ; GET SERIAL STATUS BYTE     BEQ     XXF26C          ; IF NO ERRORS FLAGGED GO INPUT BYTE AND RETURN     LDA     #$0D               ; ELSE RETURN [EOL]XXF26A = *     CLC                    ; FLAG NO ERRORXXF26B = *     RTSXXF26C = *     JMP     XXEF19          ; INPUT A BYTE FROM THE SERIAL BUS AND RETURN                         ; INPUT DEVICE WAS RS232 DEVICEXXF26F = *     JSR     XXF205          ; GET BYTE FROM RS232 DEVICE     BCS     XXF279          ; BRANCH IF ERROR, THIS DOESN'T GET TAKEN AS THE LAST                         ; INSTRUCTION IN THE GET BYTE FROM RS232 DEVICE ROUTINE                         ; IS CLC     CMP     #$00               ; COMPARE WITH NULL     BEQ     XXF26F          ; LOOP IF NULL     CLC                    ; FLAG NO ERRORXXF279 = *     RTS;***********************************************************************************;;; OUTPUT A CHARACTER TO CHANNEL; THIS ROUTINE WILL OUTPUT A CHARACTER TO AN ALREADY OPENED CHANNEL. USE THE OPEN; ROUTINE, XXFFC0, AND THE CHKOUT ROUTINE, XXFFC9, TO SET UP THE OUTPUT CHANNEL; BEFORE CALLING THIS ROUTINE. IF THESE CALLS ARE OMITTED, DATA WILL BE SENT TO THE; DEFAULT OUTPUT DEVICE, DEVICE 3, THE SCREEN. THE DATA BYTE TO BE OUTPUT IS LOADED; INTO THE ACCUMULATOR, AND THIS ROUTINE IS CALLED. THE DATA IS THEN SENT TO THE; SPECIFIED OUTPUT DEVICE. THE CHANNEL IS LEFT OPEN AFTER THE CALL.; NOTE: CARE MUST BE TAKEN WHEN USING ROUTINE TO SEND DATA TO A SERIAL DEVICE SINCE; DATA WILL BE SENT TO ALL OPEN OUTPUT CHANNELS ON THE BUS. UNLESS THIS IS DESIRED,; ALL OPEN OUTPUT CHANNELS ON THE SERIAL BUS OTHER THAN THE ACTUALLY INTENDED; DESTINATION CHANNEL MUST BE CLOSED BY A CALL TO THE KERNAL CLOSE CHANNEL ROUTINE.XXF27A = *     PHA                    ; SAVE THE CHARACTER TO SEND     LDA     XX9A          ; GET OUTPUT DEVICE NUMBER     CMP     #$03               ; COMPARE DEVICE NUMBER WITH SCREEN     BNE     XXF285          ; IF OUTPUT DEVICE NOT SCREEN CONTINUE; THE OUTPUT DEVICE IS THE SCREEN     PLA                    ; RESTORE CHARACTER TO SEND     JMP     XXE742          ; OUTPUT CHARACTER AND RETURN; THE OUTPUT DEVICE WAS NOT THE SCREENXXF285 = *     BCC     XXF28B          ; IF OUTPUT DEVICE < SCREEN CONTINUE; THE OUTPUT DEVICE WAS > SCREEN SO IT IS A SERIAL BUS DEVICE     PLA                    ; RESTORE CHARACTER TO SEND     JMP     XXEEE4          ; OUTPUT A BYTE TO THE SERIAL BUS AND RETURN; THE OUTPUT DEVICE IS < SCREENXXF28B = *     CMP     #$02               ; COMPARE THE DEVICE WITH RS232 DEVICE     BEQ     XXF2B9          ; IF OUTPUT DEVICE IS RS232 DEVICE GO HANDLE IT; ELSE THE OUTPUT DEVICE IS THE CASSETTE     PLA                    ; RESTORE THE CHARACTER TO SEND;***********************************************************************************;;; OUTPUT A CHARACTER TO THE CASSETTEXXF290 = *     STA     XX9E          ; SAVE CHARACTER TO CHARACTER BUFFER     PHA                    ; SAVE A     TXA                    ; COPY X     PHA                    ; SAVE X     TYA                    ; COPY Y     PHA                    ; SAVE Y     JSR     XXF88A          ; BUMP TAPE POINTER     BNE     XXF2AA          ; IF NOT END SAVE NEXT BYTE AND EXIT     JSR     XXF8E3          ; INITIATE TAPE WRITE     BCS     XXF2AF          ; EXIT IF ERROR     LDA     #$02               ; SET DATA BLOCK TYPE ??     LDY     #$00               ; CLEAR INDEX     STA     (XXB2),Y          ; SAVE TYPE TO BUFFER ??     INY                    ; INCREMENT INDEX     STY     XXA6          ; SAVE TAPE BUFFER INDEXXXF2AA = *     LDA     XX9E          ; RESTORE CHARACTER FROM CHARACTER BUFFER     STA     (XXB2),Y          ; SAVE TO BUFFER     CLC                    ; FLAG NO ERRORXXF2AF = *     PLA                    ; PULL Y     TAY                    ; RESTORE Y     PLA                    ; PULL X     TAX                    ; RESTORE X     PLA                    ; RESTORE A     BCC     XXF2B8          ; EXIT IF NO ERROR     LDA     #$00               ; ELSE CLEAR AXXF2B8 = *     RTS;***********************************************************************************;;; THE OUTPUT DEVICE IS RS232 DEVICEXXF2B9 = *     PLA                    ; RESTORE CHARACTER TO SEND     STX     XX97          ; SAVE X     STY     XX9E          ; SAVE Y     JSR     XXF0ED          ; SEND BYTE TO RS232 BUFFER     LDX     XX97          ; RESTORE Y     LDY     XX9E          ; RESTORE X     CLC                    ; FLAG OK     RTS;***********************************************************************************;;; OPEN A CHANNEL FOR INPUT; ANY LOGICAL FILE THAT HAS ALREADY BEEN OPENED BY THE OPEN ROUTINE, XXFFC0, CAN BE; DEFINED AS AN INPUT CHANNEL BY THIS ROUTINE. THE DEVICE ON THE CHANNEL MUST BE AN; INPUT DEVICE OR AN ERROR WILL OCCUR AND THE ROUTINE WILL ABORT.; IF YOU ARE GETTING DATA FROM ANYWHERE OTHER THAN THE KEYBOARD, THIS ROUTINE MUST BE; CALLED BEFORE USING EITHER THE CHRIN ROUTINE, XXFFCF, OR THE GETIN ROUTINE,; XXFFE4. IF YOU ARE GETTING DATA FROM THE KEYBOARD AND NO OTHER INPUT CHANNELS ARE; OPEN THEN THE CALLS TO THIS ROUTINE AND TO THE OPEN ROUTINE, XXFFC0, ARE NOT NEEDED.; WHEN USED WITH A DEVICE ON THE SERIAL BUS THIS ROUTINE WILL AUTOMATICALLY SEND THE; LISTEN ADDRESS SPECIFIED BY THE OPEN ROUTINE, XXFFC0, AND ANY SECONDARY ADDRESS.; POSSIBLE ERRORS ARE:;;     3 : FILE NOT OPEN;     5 : DEVICE NOT PRESENT;     6 : FILE IS NOT AN INPUT FILEXXF2C7 = *     JSR     XXF3CF          ; FIND FILE     BEQ     XXF2CF          ; BRANCH IF FILE OPENED     JMP     XXF784          ; DO FILE NOT OPEN ERROR AND RETURNXXF2CF = *     JSR     XXF3DF          ; SET FILE DETAILS FROM TABLE,X     LDA     XXBA          ; GET DEVICE NUMBER     BEQ     XXF2EC          ; IF DEVICE WAS KEYBOARD SAVE DEVICE #, FLAG OK AND EXIT     CMP     #$03               ; COMPARE DEVICE NUMBER WITH SCREEN     BEQ     XXF2EC          ; IF DEVICE WAS SCREEN SAVE DEVICE #, FLAG OK AND EXIT     BCS     XXF2F0          ; BRANCH IF SERIAL BUS DEVICE     CMP     #$02               ; COMPARE DEVICE WITH RS232 DEVICE     BNE     XXF2E3          ; BRANCH IF NOT RS 232 DEVICE     JMP     XXF116          ; ELSE GET INPUT FROM RS232 BUFFER AND RETURNXXF2E3 = *     LDX     XXB9          ; GET SECONDARY ADDRESS     CPX     #$60               ;.     BEQ     XXF2EC          ;.     JMP     XXF78D          ; DO NOT INPUT FILE ERROR AND RETURNXXF2EC = *     STA     XX99          ; SAVE INPUT DEVICE NUMBER     CLC                    ; FLAG OK     RTS                         ; DEVICE WAS SERIAL BUS DEVICEXXF2F0 = *     TAX                    ; COPY DEVICE NUMBER TO X     JSR     XXEE14          ; COMMAND A SERIAL BUS DEVICE TO TALK     LDA     XXB9          ; GET SECONDARY ADDRESS     BPL     XXF2FE          ;.     JSR     XXEED3          ; WAIT FOR BUS END AFTER SEND     JMP     XXF301          ;.XXF2FE = *     JSR     XXEECE          ; SEND SECONDARY ADDRESS AFTER TALKXXF301 = *     TXA                    ; COPY DEVICE BACK TO A     BIT     XX90          ; TEST SERIAL STATUS BYTE     BPL     XXF2EC          ; IF DEVICE PRESENT SAVE DEVICE NUMBER AND EXIT     JMP     XXF78A          ; DO DEVICE NOT PRESENT ERROR AND RETURN;***********************************************************************************;;; OPEN A CHANNEL FOR OUTPUT; ANY LOGICAL FILE THAT HAS ALREADY BEEN OPENED BY THE OPEN ROUTINE, XXFFC0, CAN BE; DEFINED AS AN OUTPUT CHANNEL BY THIS ROUTINE THE DEVICE ON THE CHANNEL MUST BE AN; OUTPUT DEVICE OR AN ERROR WILL OCCUR AND THE ROUTINE WILL ABORT.; IF YOU ARE SENDING DATA TO ANYWHERE OTHER THAN THE SCREEN THIS ROUTINE MUST BE; CALLED BEFORE USING THE CHROUT ROUTINE, XXFFD2. IF YOU ARE SENDING DATA TO THE; SCREEN AND NO OTHER OUTPUT CHANNELS ARE OPEN THEN THE CALLS TO THIS ROUTINE AND TO; THE OPEN ROUTINE, XXFFC0, ARE NOT NEEDED.; WHEN USED WITH A DEVICE ON THE SERIAL BUS THIS ROUTINE WILL AUTOMATICALLY SEND THE; LISTEN ADDRESS SPECIFIED BY THE OPEN ROUTINE, XXFFC0, AND ANY SECONDARY ADDRESS.; POSSIBLE ERRORS ARE:;;     3 : FILE NOT OPEN;     5 : DEVICE NOT PRESENT;     7 : FILE IS NOT AN OUTPUT FILEXXF309 = *     JSR     XXF3CF          ; FIND FILE     BEQ     XXF311          ; BRANCH IF FILE FOUND     JMP     XXF784          ; DO FILE NOT OPEN ERROR AND RETURNXXF311 = *     JSR     XXF3DF          ; SET FILE DETAILS FROM TABLE,X     LDA     XXBA          ; GET DEVICE NUMBER     BNE     XXF31B          ; BRANCH IF DEVICE IS NOT KEYBOARDXXF318 = *     JMP     XXF790          ; DO NOT OUTPUT FILE ERROR AND RETURNXXF31B = *     CMP     #$03               ; COMPARE DEVICE NUMBER WITH SCREEN     BEQ     XXF32E          ; IF SCREEN SAVE OUTPUT DEVICE NUMBER AND EXIT     BCS     XXF332          ; BRANCH IF > SCREEN, SERIAL BUS DEVICE     CMP     #$02               ; COMPARE DEVICE WITH RS232 DEVICE     BNE     XXF328          ; BRANCH IF NOT RS232 DEVICE, MUST BE TAPE     JMP     XXF0BC          ; OPEN RS232 CHANNEL FOR OUTPUT                         ; OPEN TAPE CHANNEL FOR OUTPUTXXF328 = *     LDX     XXB9          ; GET SECONDARY ADDRESS     CPX     #$60               ;.     BEQ     XXF318          ; IF ?? DO NOT OUTPUT FILE ERROR AND RETURNXXF32E = *     STA     XX9A          ; SAVE OUTPUT DEVICE NUMBER     CLC                    ; FLAG OK     RTSXXF332 = *     TAX                    ; COPY DEVICE NUMBER     JSR     XXEE17          ; COMMAND DEVICES ON THE SERIAL BUS TO LISTEN     LDA     XXB9          ; GET SECONDARY ADDRESS     BPL     XXF33F          ; BRANCH IF ADDRESS TO SEND     JSR     XXEEC5          ; ELSE SET SERIAL ATN HIGH     BNE     XXF342          ; BRANCH ALWAYSXXF33F = *     JSR     XXEEC0          ; SEND SECONDARY ADDRESS AFTER LISTENXXF342 = *     TXA                    ; COPY DEVICE NUMBER BACK TO A     BIT     XX90          ; TEST SERIAL STATUS BYTE     BPL     XXF32E          ; IF DEVICE PRESENT SAVE OUTPUT DEVICE NUMBER AND EXIT     JMP     XXF78A          ; ELSE DO DEVICE NOT PRESENT ERROR AND RETURN;***********************************************************************************;;; CLOSE A SPECIFIED LOGICAL FILE; THIS ROUTINE IS USED TO CLOSE A LOGICAL FILE AFTER ALL I/O OPERATIONS HAVE BEEN; COMPLETED ON THAT FILE. THIS ROUTINE IS CALLED AFTER THE ACCUMULATOR IS LOADED; WITH THE LOGICAL FILE NUMBER TO BE CLOSED, THE SAME NUMBER USED WHEN THE FILE WAS; OPENED USING THE OPEN ROUTINE.XXF34A = *     JSR     XXF3D4          ; FIND FILE A     BEQ     XXF351          ; IF THE FILE IS FOUND GO CLOSE IT     CLC                    ; ELSE THR FILE WAS CLOSED SO JUST FLAG OK     RTS; FOUND THE FILE SO CLOSE ITXXF351 = *     JSR     XXF3DF          ; SET FILE DETAILS FROM TABLE,X     TXA                    ; COPY FILE INDEX TO A     PHA                    ; SAVE FILE INDEX     LDA     XXBA          ; GET DEVICE NUMBER     BEQ     XXF3B1          ; IF $00, KEYBOARD, RESTORE INDEX AND CLOSE FILE     CMP     #$03               ; COMPARE DEVICE NUMBER WITH SCREEN     BEQ     XXF3B1          ; IF SCREEN RESTORE INDEX AND CLOSE FILE     BCS     XXF3AE          ; IF > SCREEN GO DO SERIAL BUS DEVICE CLOSE     CMP     #$02               ; COMPARE DEVICE WITH RS232 DEVICE     BNE     XXF38D          ; BRANCH IF NOT RS232 DEVICE                         ; ELSE CLOSE RS232 DEVICE     PLA                    ; RESTORE FILE INDEX     JSR     XXF3B2          ; CLOSE FILE INDEX X     LDA     #$7D               ; DISABLE T1, T2, CB1, CB2, SR AND CA2     STA     XX911E          ; SET VIA 1 IER     LDA     #$06               ; SET DTR AND RTS HIGH     STA     XX9110          ; SET VIA 1 DRB     LDA     #$EE               ; CB2 HIGH, CB1 -VE EDGE, CA2 HIGH, CA1 -VE EDGE     STA     XX911C          ; SET VIA 1 PCR     JSR     XXFE75          ; READ THE TOP OF MEMORY     LDA     XXF8          ; GET RS232 INPUT BUFFER POINTER HIGH BYTE     BEQ     XXF37F          ; BRANCH IF NO RS232 INPUT BUFFER     INY                    ; ELSE RECLAIM RS232 INPUT BUFFER MEMORYXXF37F = *     LDA     XXFA          ; GET RS232 OUTPUT BUFFER POINTER HIGH BYTE     BEQ     XXF384          ; BRANCH IF NO RS232 OUTPUT BUFFER     INY                    ; ELSE RECLAIM RS232 OUTPUT BUFFER MEMORYXXF384 = *     LDA     #$00               ; CLEAR A     STA     XXF8          ; CLEAR RS232 INPUT BUFFER POINTER HIGH BYTE     STA     XXFA          ; CLEAR RS232 OUTPUT BUFFER POINTER HIGH BYTE     JMP     XXF53C          ; GO SET TOP OF MEMORY AND EXITXXF38D = *     LDA     XXB9          ; GET SECONDARY ADDRESS     AND     #$0F               ;.     BEQ     XXF3B1          ; IF ?? RESTORE INDEX AND CLOSE FILE     JSR     XXF84D          ; GET TAPE BUFFER START POINTER IN XY     LDA     #$00               ; CHARACTER $00     JSR     XXF290          ; OUTPUT CHARACTER TO CASSETTE     JMP     XXE4CF          ; GO DO CLOSE TAILXXF39E = *     BCS     XXF3CE          ; JUST EXIT IF ERROR     LDA     XXB9          ; GET SECONDARY ADDRESS     CMP     #$62               ;.     BNE     XXF3B1          ; IF NOT ?? RESTORE INDEX AND CLOSE FILE     LDA     #$05               ; SET LOGICAL END OF THE TAPE     JSR     XXF7E7          ; WRITE TAPE HEADER     JMP     XXF3B1          ; RESTORE INDEX AND CLOSE FILE;***********************************************************************************;;; DO SERIAL BUS DEVICE FILE CLOSEXXF3AE = *     JSR     XXF6DA          ; CLOSE SERIAL BUS DEVICEXXF3B1 = *     PLA                    ; RESTORE FILE INDEX;***********************************************************************************;;; CLOSE FILE INDEX XXXF3B2 = *     TAX                    ; COPY INDEX TO FILE TO CLOSE     DEC     XX98          ; DECREMENT OPEN FILE COUNT     CPX     XX98          ; COMPARE INDEX WITH OPEN FILE COUNT     BEQ     XXF3CD          ; EXIT IF EQUAL, LAST ENTRY WAS CLOSING FILE                         ; ELSE ENTRY WAS NOT LAST IN LIST SO COPY LAST TABLE ENTRY                         ; FILE DETAILS OVER THE DETAILS OF THE CLOSING ONE     LDY     XX98          ; GET OPEN FILE COUNT AS INDEX     LDA     XX0259,Y          ; GET LAST+1 LOGICAL FILE NUMBER FROM LOGICAL FILE TABLE     STA     XX0259,X          ; SAVE LOGICAL FILE NUMBER OVER CLOSED FILE     LDA     XX0263,Y          ; GET LAST+1 DEVICE NUMBER FROM DEVICE NUMBER TABLE     STA     XX0263,X          ; SAVE DEVICE NUMBER OVER CLOSED FILE     LDA     XX026D,Y          ; GET LAST+1 SECONDARY ADDRESS FROM SECONDARY ADDRESS TABLE     STA     XX026D,X          ; SAVE SECONDARY ADDRESS OVER CLOSED FILEXXF3CD = *     CLC                    ;.XXF3CE = *     RTS;***********************************************************************************;;; FIND FILEXXF3CF = *     LDA     #$00               ; CLEAR A     STA     XX90          ; CLEAR SERIAL STATUS BYTE     TXA                    ; COPY LOGICAL FILE NUMBER TO A; FIND FILE AXXF3D4 = *     LDX     XX98          ; GET OPEN FILE COUNTXXF3D6 = *     DEX                    ; DECREMEMNT COUNT TO GIVE INDEX     BMI     XXF3EE          ; EXIT IF NO FILES     CMP     XX0259,X          ; COMPARE LOGICAL FILE NUMBER WITH TABLE LOGICAL FILE NUMBER     BNE     XXF3D6          ; LOOP IF NO MATCH     RTS;***********************************************************************************;;; SET FILE DETAILS FROM TABLE,XXXF3DF = *     LDA     XX0259,X          ; GET LOGICAL FILE FROM LOGICAL FILE TABLE     STA     XXB8          ; SET LOGICAL FILE     LDA     XX0263,X          ; GET DEVICE NUMBER FROM DEVICE NUMBER TABLE     STA     XXBA          ; SET DEVICE NUMBER     LDA     XX026D,X          ; GET SECONDARY ADDRESS FROM SECONDARY ADDRESS TABLE     STA     XXB9          ; SET SECONDARY ADDRESSXXF3EE = *     RTS;***********************************************************************************;;; CLOSE ALL CHANNELS AND FILES; THIS ROUTINE CLOSES ALL OPEN FILES. WHEN THIS ROUTINE IS CALLED, THE POINTERS INTO; THE OPEN FILE TABLE ARE RESET, CLOSING ALL FILES. ALSO THE ROUTINE AUTOMATICALLY; RESETS THE I/O CHANNELS.XXF3EF = *     LDA     #$00               ; CLEAR A     STA     XX98          ; CLEAR OPEN FILE COUNT;***********************************************************************************;;; CLOSE INPUT AND OUTPUT CHANNELS; THIS ROUTINE IS CALLED TO CLEAR ALL OPEN CHANNELS AND RESTORE THE I/O CHANNELS TO; THEIR ORIGINAL DEFAULT VALUES. IT IS USUALLY CALLED AFTER OPENING OTHER I/O; CHANNELS AND USING THEM FOR INPUT/OUTPUT OPERATIONS. THE DEFAULT INPUT DEVICE IS; 0, THE KEYBOARD. THE DEFAULT OUTPUT DEVICE IS 3, THE SCREEN.; IF ONE OF THE CHANNELS TO BE CLOSED IS TO THE SERIAL PORT, AN UNTALK SIGNAL IS SENT; FIRST TO CLEAR THE INPUT CHANNEL OR AN UNLISTEN IS SENT TO CLEAR THE OUTPUT CHANNEL.; BY NOT CALLING THIS ROUTINE AND LEAVING LISTENER(S) ACTIVE ON THE SERIAL BUS,; SEVERAL DEVICES CAN RECEIVE THE SAME DATA FROM THE VIC AT THE SAME TIME. ONE WAY TO; TAKE ADVANTAGE OF THIS WOULD BE TO COMMAND THE PRINTER TO TALK AND THE DISK TO; LISTEN. THIS WOULD ALLOW DIRECT PRINTING OF A DISK FILE.XXF3F3 = *     LDX     #$03               ; SET X TO SCREEN     CPX     XX9A          ; COMPARE OUTPUT DEVICE NUMBER WITH SCREEN     BCS     XXF3FC          ; BRANCH IF >= SCREEN                         ; ELSE WAS SERIAL BUS     JSR     XXEF04          ; COMMAND THE SERIAL BUS TO UNLISTENXXF3FC = *     CPX     XX99          ; COMPARE INPUT DEVICE NUMBER WITH SCREEN     BCS     XXF403          ; BRANCH IF >= SCREEN                         ; ELSE WAS SERIAL BUS     JSR     XXEEF6          ; COMMAND THE SERIAL BUS TO UNTALKXXF403 = *     STX     XX9A          ; SET OUTPUT DEVICE NUMBER TO SCREEN     LDA     #$00               ; SET FOR KEYBOARD     STA     XX99          ; SET INPUT DEVICE NUMBER TO KEYBOARD     RTS;***********************************************************************************;;; OPEN A LOGICAL FILE; THIS ROUTINE IS USED TO OPEN A LOGICAL FILE. ONCE THE LOGICAL FILE IS SET UP IT; CAN BE USED FOR INPUT/OUTPUT OPERATIONS. MOST OF THE I/O KERNAL ROUTINES CALL ON; THIS ROUTINE TO CREATE THE LOGICAL FILES TO OPERATE ON. NO ARGUMENTS NEED TO BE; SET UP TO USE THIS ROUTINE, BUT BOTH THE SETLFS, XXFFBA, AND SETNAM, XXFFBD,; KERNAL ROUTINES MUST BE CALLED BEFORE USING THIS ROUTINE.XXF40A = *     LDX     XXB8          ; GET LOGICAL FILE NUMBER     BNE     XXF411          ; BRANCH IF THERE IS A FILE     JMP     XXF78D          ; ELSE DO NOT INPUT FILE ERROR AND RETURNXXF411 = *     JSR     XXF3CF          ; FIND FILE     BNE     XXF419          ; BRANCH IF FILE NOT FOUND     JMP     XXF781          ; ELSE DO FILE ALREADY OPEN ERROR AND RETURNXXF419 = *     LDX     XX98          ; GET OPEN FILE COUNT     CPX     #$0A               ; COMPARE WITH MAX     BCC     XXF422          ; BRANCH IF LESS     JMP     XXF77E          ; ELSE DO TOO MANY FILES ERROR AND RETURNXXF422 = *     INC     XX98          ; INCREMENT OPEN FILE COUNT     LDA     XXB8          ; GET LOGICAL FILE NUMBER     STA     XX0259,X          ; SAVE TO LOGICAL FILE TABLE     LDA     XXB9          ; GET SECONDARY ADDRESS     ORA     #$60               ; OR WITH THE OPEN CHANNEL COMMAND     STA     XXB9          ; SET SECONDARY ADDRESS     STA     XX026D,X          ; SAVE TO SECONDARY ADDRESS TABLE     LDA     XXBA          ; GET DEVICE NUMBER     STA     XX0263,X          ; SAVE TO DEVICE NUMBER TABLE     BEQ     XXF493          ; DO OK EXIT IF KEYBOARD     CMP     #$03               ; COMPARE DEVICE NUMBER WITH SCREEN     BEQ     XXF493          ; DO OK EXIT IF SCREEN     BCC     XXF444          ; BRANCH IF < SCREEN, TAPE OR RS232                         ; ELSE IS SERIAL BUS DEVICE     JSR     XXF495          ; SEND SECONDARY ADDRESS AND FILENAME     BCC     XXF493          ; DO OK EXITXXF444 = *     CMP     #$02               ; COMPARE DEVICE WITH RS232 DEVICE     BNE     XXF44B          ; BRANCH IF NOT RS232 DEVICE, MUST BE TAPE     JMP     XXF4C7          ; GO OPEN RS232 DEVICE AND RETURNXXF44B = *     JSR     XXF84D          ; GET TAPE BUFFER START POINTER IN XY     BCS     XXF453          ; BRANCH IF >= $0200     JMP     XXF796          ; DO ILLEGAL DEVICE NUMBER AND RETURNXXF453 = *     LDA     XXB9          ; GET SECONDARY ADDRESS     AND     #$0F               ;.     BNE     XXF478          ;.     JSR     XXF894          ; WAIT FOR PLAY     BCS     XXF494          ; EXIT IF STOP WAS PRESSED     JSR     XXF647          ; PRINT 'SEARCHING...'     LDA     XXB7          ; GET FILE NAME LENGTH     BEQ     XXF46F          ; IF NULL FILE NAME JUST GO FIND HEADER     JSR     XXF867          ; FIND SPECIFIC TAPE HEADER     BCC     XXF482          ; BRANCH IF NO ERROR     BEQ     XXF494          ; EXIT IF ??XXF46C = *     JMP     XXF787          ; DO FILE NOT FOUND ERROR AND RETURNXXF46F = *     JSR     XXF7AF          ; FIND TAPE HEADER, EXIT WITH HEADER IN BUFFER     BEQ     XXF494          ; EXIT IF END OF TAPE FOUND     BCC     XXF482          ;.     BCS     XXF46C          ;.XXF478 = *     JSR     XXF8B7          ; WAIT FOR PLAY/RECORD     BCS     XXF494          ; EXIT IF STOP WAS PRESSED     LDA     #$04               ; SET DATA FILE HEADER     JSR     XXF7E7          ; WRITE TAPE HEADERXXF482 = *     LDA     #$BF               ;.     LDY     XXB9          ; GET SECONDARY ADDRESS     CPY     #$60               ;.     BEQ     XXF491          ;.     LDY     #$00               ; CLEAR INDEX     LDA     #$02               ;.     STA     (XXB2),Y          ;.SAVE TO TAPE BUFFER     TYA                    ;.CLEAR AXXF491 = *     STA     XXA6          ;.SAVE TAPE BUFFER INDEXXXF493 = *     CLC                    ; FLAG OKXXF494 = *     RTS;***********************************************************************************;;; SEND SECONDARY ADDRESS AND FILENAMEXXF495 = *     LDA     XXB9          ; GET SECONDARY ADDRESS     BMI     XXF4C5          ; OK EXIT IF -VE     LDY     XXB7          ; GET FILE NAME LENGTH     BEQ     XXF4C5          ; OK EXIT IF NULL     LDA     XXBA          ; GET DEVICE NUMBER     JSR     XXEE17          ; COMMAND DEVICES ON THE SERIAL BUS TO LISTEN     LDA     XXB9          ; GET THE SECONDARY ADDRESS     ORA     #$F0               ; OR WITH THE OPEN COMMAND     JSR     XXEEC0          ; SEND SECONDARY ADDRESS AFTER LISTEN     LDA     XX90          ; GET SERIAL STATUS BYTE     BPL     XXF4B2          ; BRANCH IF DEVICE PRESENT     PLA                    ; ELSE DUMP CALLING ADDRESS LOW BYTE     PLA                    ; DUMP CALLING ADDRESS HIGH BYTE     JMP     XXF78A          ; DO DEVICE NOT PRESENT ERROR AND RETURNXXF4B2 = *     LDA     XXB7          ; GET FILE NAME LENGTH     BEQ     XXF4C2          ; BRANCH IF NULL NAME     LDY     #$00               ; CLEAR INDEXXXF4B8 = *     LDA     (XXBB),Y          ; GET FILE NAME BYTE     JSR     XXEEE4          ; OUTPUT A BYTE TO THE SERIAL BUS     INY                    ; INCREMENT INDEX     CPY     XXB7          ; COMPARE WITH FILE NAME LENGTH     BNE     XXF4B8          ; LOOP IF NOT ALL DONEXXF4C2 = *     JSR     XXEF04          ; COMMAND THE SERIAL BUS TO UNLISTENXXF4C5 = *     CLC                    ; FLAG OK     RTS;***********************************************************************************;;; OPEN RS232XXF4C7 = *     LDA     #$06               ; IIII IOOI, DTR AND RTS ONLY AS OUTPUTS     STA     XX9112          ; SET VIA 1 DDRB     STA     XX9110          ; SET VIA 1 DRB, DTR AND RTS HIGH     LDA     #$EE               ; CB2 HIGH, CB1 -VE EDGE, CA2 HIGH, CA1 -VE EDGE     STA     XX911C          ; SET VIA 1 PCR     LDY     #$00               ; CLEAR INDEX     STY     XX0297          ; CLEAR RS232 STATUS BYTEXXF4D9 = *     CPY     XXB7          ; COMPARE WITH FILE NAME LENGTH     BEQ     XXF4E7          ; EXIT LOOP IF DONE     LDA     (XXBB),Y          ; GET FILE NAME BYTE     STA     XX0293,Y          ; COPY TO 6551 REGISTER SET     INY                    ; INCREMENT INDEX     CPY     #$04               ; COMPARE WITH $04     BNE     XXF4D9          ; LOOP IF NOT TO 4 YETXXF4E7 = *     JSR     XXF027          ; COMPUTE BIT COUNT     STX     XX0298          ; SAVE BIT COUNT     LDA     XX0293          ; GET PSEUDO 6551 CONTROL REGISTER     AND     #$0F               ; MASK 0000 XXXX, BAUD RATE     BNE     XXF4F4          ; BRANCH NOWHERE. PERHAPS THERE WAS GOING TO BE SOME                         ; ERROR TRAPPING FOR UNIMPLEMENTED BAUD RATES BUT                         ; THIS WAS EVER DONEXXF4F4 = *     ASL A                  ; * 2     TAX                    ; COPY TO INDEX     LDA     XXFF5C-2,X     ; GET TIMER CONSTANT LOW BYTE     ASL A                  ; * 2     TAY                    ; COPY TO Y     LDA     XXFF5C-1,X     ; GET TIMER CONSTANT HIGH BYTE     ROL A                  ; * 2     PHA                    ; SAVE IT     TYA                    ; GET TIMER CONSTANT LOW BYTE BACK     ADC     #$C8               ; + $C8, CARRY CLEARED BY PREVIOUS ROL     STA     XX0299          ; SAVE BIT CELL TIME LOW BYTE     PLA                    ; RESTORE HIGH  BYTE     ADC     #$00               ; ADD CARRY     STA     XX029A          ; SAVE BIT CELL TIME HIGH BYTE     LDA     XX0294          ; GET PSEUDO 6551 COMMAND REGISTER     LSR A                  ; SHIFT B0 INTO CB     BCC     XXF51B          ; BRANCH IF 3 LINE INTERFACE     LDA     XX9120          ; GET VIA 2 DRB, THIS IS WRONG, THE ADRESS SHOULD BE                         ; XX9110 WHICH IS VIA 1 WHICH IS WHERE THE DSR INPUT                         ; REALLY IS     ASL A                  ; SHIFT DSR INTO CB     BCS     XXF51B          ; BRANCH IF DSR = 1     JMP     XXF016          ; SET DSR SIGNAL NOT PRESENT AND RETURNXXF51B = *     LDA     XX029B          ; GET INDEX TO RX BUFFER END     STA     XX029C          ; SET INDEX TO RX BUFFER START, CLEAR RX BUFFER     LDA     XX029E          ; GET INDEX TO TX BUFFER END     STA     XX029D          ; SET INDEX TO TX BUFFER START, CLEAR TX BUFFER     JSR     XXFE75          ; READ THE TOP OF MEMORY     LDA     XXF8          ; GET RX BUFFER POINTER HIGH BYTE     BNE     XXF533          ; BRANCH IF BUFFER ALREADY SET     DEY                    ; DECREMENT TOP OF MEMORY HIGH BYTE, 256 BYTE BUFFER     STY     XXF8          ; SET RX BUFFER POINTER HIGH BYTE     STX     XXF7          ; SET RX BUFFER POINTER LOW BYTEXXF533 = *     LDA     XXFA          ; GET TX BUFFER POINTER HIGH BYTE     BNE     XXF53C          ; BRANCH IF BUFFER ALREADY SET     DEY                    ; DECREMENT RX BUFFER POINTER HIGH BYTE, 256 BYTE BUFFER     STY     XXFA          ; SET TX BUFFER POINTER HIGH BYTE     STX     XXF9          ; SET TX BUFFER POINTER LOW BYTEXXF53C = *     SEC                    ;.     LDA     #$F0               ;.     JMP     XXFE7B          ; SET THE TOP OF MEMORY AND RETURN;***********************************************************************************;;; LOAD RAM FROM A DEVICE; THIS ROUTINE WILL LOAD DATA BYTES FROM ANY INPUT DEVICE DIRECTLY INTO THE MEMORY; OF THE COMPUTER. IT CAN ALSO BE USED FOR A VERIFY OPERATION COMPARING DATA FROM A; DEVICE WITH THE DATA ALREADY IN MEMORY, LEAVING THE DATA STORED IN RAM UNCHANGED.; THE ACCUMULATOR MUST BE SET TO 0 FOR A LOAD OPERATION OR 1 FOR A VERIFY. IF THE; INPUT DEVICE WAS OPENED WITH A SECONDARY ADDRESS OF 0 THE HEADER INFORMATION FROM; DEVICE WILL BE IGNORED. IN THIS CASE XY MUST CONTAIN THE STARTING ADDRESS FOR THE; LOAD. IF THE DEVICE WAS ADDRESSED WITH A SECONDARY ADDRESS OF 1 OR 2 THE DATA WILL; LOAD INTO MEMORY STARTING AT THE LOCATION SPECIFIED BY THE HEADER. THIS ROUTINE; RETURNS THE ADDRESS OF THE HIGHEST RAM LOCATION WHICH WAS LOADED.; BEFORE THIS ROUTINE CAN BE CALLED, THE SETLFS, XXFFBA, AND SETNAM, XXFFBD,; ROUTINES MUST BE CALLED.XXF542 = *     STX     XXC3          ; SET KERNAL SETUP POINTER LOW BYTE     STY     XXC4          ; SET KERNAL SETUP POINTER HIGH BYTE     JMP     (XX0330)          ; DO LOAD VECTOR, USUALLY POINTS TO XXF549;***********************************************************************************;;; LOADXXF549 = *     STA     XX93          ; SAVE LOAD/VERIFY FLAG     LDA     #$00               ; CLEAR A     STA     XX90          ; CLEAR SERIAL STATUS BYTE     LDA     XXBA          ; GET DEVICE NUMBER     BNE     XXF556          ; BRANCH IF NOT KEYBOARD                         ; CAN'T LOAD FORM KEYBOARD SO ..XXF553 = *     JMP     XXF796          ; DO ILLEGAL DEVICE NUMBER AND RETURNXXF556 = *     CMP     #$03               ; COMPARE DEVICE NUMBER WITH SCREEN     BEQ     XXF553          ; IF SCREEN GO DO ILLEGAL DEVICE NUMBER AND RETURN     BCC     XXF5CA          ; BRANCH IF LESS THAN SCREEN                         ; ELSE IS SERIAL BUS DEVICE     LDY     XXB7          ; GET FILE NAME LENGTH     BNE     XXF563          ; BRANCH IF NOT NULL NAME     JMP     XXF793          ; ELSE DO MISSING FILE NAME ERROR AND RETURNXXF563 = *     JSR     XXE4BC          ; GET SECONDAY ADDRESS AND PRINT 'SEARCHING...'     LDA     #$60               ;.     STA     XXB9          ; SAVE THE SECONDARY ADDRESS     JSR     XXF495          ; SEND SECONDARY ADDRESS AND FILENAME     LDA     XXBA          ; GET DEVICE NUMBER     JSR     XXEE14          ; COMMAND A SERIAL BUS DEVICE TO TALK     LDA     XXB9          ; GET SECONDARY ADDRESS     JSR     XXEECE          ; SEND SECONDARY ADDRESS AFTER TALK     JSR     XXEF19          ; INPUT A BYTE FROM THE SERIAL BUS     STA     XXAE          ; SAVE PROGRAM START ADDRESS LOW BYTE     LDA     XX90          ; GET SERIAL STATUS BYTE     LSR A                  ; SHIFT TIME OUT READ ..     LSR A                  ; .. INTO CARRY BIT     BCS     XXF5C7          ; IF TIMED OUT GO DO FILE NOT FOUND ERROR AND RETURN     JSR     XXEF19          ; INPUT A BYTE FROM THE SERIAL BUS     STA     XXAF          ; SAVE PROGRAM START ADDRESS HIGH BYTE     JSR     XXE4C1          ; SET LOAD ADDRESS IF SECONDARY ADDRESS = 0XXF58A = *     LDA     #$FD               ; MASK XXXX XX0X, CLEAR TIME OUT READ BIT     AND     XX90          ; MASK SERIAL STATUS BYTE     STA     XX90          ; SET SERIAL STATUS BYTE     JSR     XXFFE1          ; SCAN STOP KEY, RETURN ZB = 1 = [STOP]     BNE     XXF598          ; BRANCH IF NOT [STOP]     JMP     XXF6CB          ; ELSE CLOSE THE SERIAL BUS DEVICE AND FLAG STOPXXF598 = *     JSR     XXEF19          ; INPUT A BYTE FROM THE SERIAL BUS     TAX                    ; COPY BYTE     LDA     XX90          ; GET SERIAL STATUS BYTE     LSR A                  ; SHIFT TIME OUT READ ..     LSR A                  ; .. INTO CARRY BIT     BCS     XXF58A          ; IF TIMED OUT GO ??     TXA                    ; COPY RECEIVED BYTE BACK     LDY     XX93          ; GET LOAD/VERIFY FLAG     BEQ     XXF5B3          ; BRANCH IF LOAD                         ; ELSE IS VERIFY     LDY     #$00               ; CLEAR INDEX     CMP     (XXAE),Y          ; COMPARE BYTE WITH PREVIOUSLY LOADED BYTE     BEQ     XXF5B5          ; BRANCH IF MATCH     LDA     #$10               ; FLAG READ ERROR     JSR     XXFE6A          ; OR INTO SERIAL STATUS BYTE     .BYTE     $2C               ; MAKES NEXT LINE BIT XXAE91XXF5B3 = *     STA     (XXAE),Y          ; SAVE BYTE TO MEMORYXXF5B5 = *     INC     XXAE          ; INCREMENT SAVE POINTER LOW BYTE     BNE     XXF5BB          ; IF NO ROLLOVER SKIP THE HIGH BYTE INCREMENT     INC     XXAF          ; ELSE INCREMENT SAVE POINTER HIGH BYTEXXF5BB = *     BIT     XX90          ; TEST SERIAL STATUS BYTE     BVC     XXF58A          ; LOOP IF NOT END OF FILE     JSR     XXEEF6          ; COMMAND THE SERIAL BUS TO UNTALK     JSR     XXF6DA          ; CLOSE SERIAL BUS DEVICE     BCC     XXF641          ; IF ?? GO FLAG OK AND EXITXXF5C7 = *     JMP     XXF787          ; DO FILE NOT FOUND ERROR AND RETURNXXF5CA = *     CMP     #$02               ; COMPARE DEVICE WITH RS232 DEVICE     BNE     XXF5D1          ; IF NOT RS232 DEVICE CONTINUE     JMP     XXF0B9          ; ELSE DO ILLEGAL DEVICE NUMBER AND RETURNXXF5D1 = *     JSR     XXF84D          ; GET TAPE BUFFER START POINTER IN XY     BCS     XXF5D9          ; BRANCH IF >= $0200     JMP     XXF796          ; DO ILLEGAL DEVICE NUMBER AND RETURNXXF5D9 = *     JSR     XXF894          ; WAIT FOR PLAY     BCS     XXF646          ; EXIT IF STOP WAS PRESSED     JSR     XXF647          ; PRINT 'SEARCHING...'XXF5E1 = *     LDA     XXB7          ; GET FILE NAME LENGTH     BEQ     XXF5EE     JSR     XXF867          ; FIND SPECIFIC TAPE HEADER     BCC     XXF5F5          ; IF NO ERROR CONTINUE     BEQ     XXF646          ; EXIT IF ??     BCS     XXF5C7          ;., BRANCH ALWAYSXXF5EE = *     JSR     XXF7AF          ; FIND TAPE HEADER, EXIT WITH HEADER IN BUFFER     BEQ     XXF646          ; EXIT IF ??     BCS     XXF5C7          ;.XXF5F5 = *     LDA     XX90          ; GET SERIAL STATUS BYTE     AND     #$10               ; MASK 000X 0000, READ ERROR     SEC                    ; FLAG FAIL     BNE     XXF646          ; IF READ ERROR JUST EXIT     CPX     #$01               ;.     BEQ     XXF611          ;.     CPX     #$03               ;.     BNE     XXF5E1          ;.XXF604 = *     LDY     #$01               ;.     LDA     (XXB2),Y          ;.     STA     XXC3          ;.     INY                    ;.     LDA     (XXB2),Y          ;.     STA     XXC4          ;.     BCS     XXF615          ;.XXF611 = *     LDA     XXB9          ; GET SECONDARY ADDRESS     BNE     XXF604          ;.XXF615 = *     LDY     #$03               ;.     LDA     (XXB2),Y          ;.     LDY     #$01               ;.     SBC     (XXB2),Y          ;.     TAX                    ;.     LDY     #$04               ;.     LDA     (XXB2),Y          ;.     LDY     #$02               ;.     SBC     (XXB2),Y          ;.     TAY                    ;.     CLC                    ;.     TXA                    ;.     ADC     XXC3          ;.     STA     XXAE          ;.     TYA                    ;.     ADC     XXC4          ;.     STA     XXAF          ;.     LDA     XXC3          ;.     STA     XXC1          ; SET I/O START ADDRESSES LOW BYTE     LDA     XXC4          ;.     STA     XXC2          ; SET I/O START ADDRESSES HIGH BYTE     JSR     XXF66A          ; DISPLAY 'LOADING' OR 'VERIFYING'     JSR     XXF8C9          ; DO THE TAPE READ     .BYTE     $24               ; MAKES NEXT LINE BIT XX18, KEEP THE ERROR FLAG IN CBXXF641 = *     CLC                    ; FLAG OK     LDX     XXAE          ; GET THE LOAD END POINTER LOW BYTE     LDY     XXAF          ; GET THE LOAD END POINTER HIGH BYTEXXF646 = *     RTS;***********************************************************************************;;; PRINT 'SEARCHING'XXF647 = *     LDA     XX9D          ; GET MESSAGE MODE FLAG     BPL     XXF669          ; EXIT IF CONTROL MESSAGES OFF     LDY     #XXF180-XXF174                         ; INDEX TO 'SEARCHING '     JSR     XXF1E6          ; DISPLAY KERNEL I/O MESSAGE     LDA     XXB7          ; GET FILE NAME LENGTH     BEQ     XXF669          ; EXIT IF NULL NAME     LDY     #XXF18B-XXF174                         ; ELSE INDEX TO 'FOR '     JSR     XXF1E6          ; DISPLAY KERNEL I/O MESSAGE; PRINT FILE NAMEXXF659 = *     LDY     XXB7          ; GET FILE NAME LENGTH     BEQ     XXF669          ; EXIT IF NULL FILE NAME     LDY     #$00               ; CLEAR INDEXXXF65F = *     LDA     (XXBB),Y          ; GET FILE NAME BYTE     JSR     XXFFD2          ; OUTPUT CHARACTER TO CHANNEL     INY                    ; INCREMENT INDEX     CPY     XXB7          ; COMPARE WITH FILE NAME LENGTH     BNE     XXF65F          ; LOOP IF MORE TO DOXXF669 = *     RTS; DISPLAY 'LOADING' OR 'VERIFYING'XXF66A = *     LDY     #XXF1BD-XXF174                         ; POINT TO 'LOADING'     LDA     XX93          ; GET LOAD/VERIFY FLAG     BEQ     XXF672          ; BRANCH IF LOAD     LDY     #XXF1CD-XXF174                         ; POINT TO 'VERIFYING'XXF672 = *     JMP     XXF1E2          ; DISPLAY KERNEL I/O MESSAGE IF IN DIRECT MODE AND RETURN;***********************************************************************************;;; SAVE RAM TO DEVICE, A = INDEX TO START ADDRESS, XY = END ADDRESS LOW/HIGH; THIS ROUTINE SAVES A SECTION OF MEMORY. MEMORY IS SAVED FROM AN INDIRECT ADDRESS; ON PAGE 0 SPECIFIED BY A, TO THE ADDRESS STORED IN XY, TO A LOGICAL FILE. THE; SETLFS, XXFFBA, AND SETNAM, XXFFBD, ROUTINES MUST BE USED BEFORE CALLING THIS; ROUTINE. HOWEVER, A FILE NAME IS NOT REQUIRED TO SAVE TO DEVICE 1, THE CASSETTE.; ANY ATTEMPT TO SAVE TO OTHER DEVICES WITHOUT USING A FILE NAME RESULTS IN AN ERROR.; NOTE: DEVICE 0, THE KEYBOARD, AND DEVICE 3, THE SCREEN, CANNOT BE SAVED TO. IF; THE ATTEMPT IS MADE, AN ERROR WILL OCCUR, AND THE SAVE STOPPED.XXF675 = *     STX     XXAE          ; SAVE END ADDRESS LOW BYTE     STY     XXAF          ; SAVE END ADDRESS HIGH BYTE     TAX                    ; COPY INDEX TO START POINTER     LDA     XX00,X          ; GET START ADDRESS LOW BYTE     STA     XXC1          ; SET I/O START ADDRESSES LOW BYTE     LDA     XX01,X          ; GET START ADDRESS HIGH BYTE     STA     XXC2          ; SET I/O START ADDRESSES HIGH BYTE     JMP     (XX0332)          ; GO SAVE, USUALLY POINTS TO XXF685;***********************************************************************************;;; SAVEXXF685 = *     LDA     XXBA          ; GET DEVICE NUMBER     BNE     XXF68C          ; BRANCH IF NOT KEYBOARD                         ; ELSE ..XXF689 = *     JMP     XXF796          ; DO ILLEGAL DEVICE NUMBER AND RETURNXXF68C = *     CMP     #$03               ; COMPARE DEVICE NUMBER WITH SCREEN     BEQ     XXF689          ; IF SCREEN DO ILLEGAL DEVICE NUMBER AND RETURN     BCC     XXF6F1          ; BRANCH IF < SCREEN                         ; IS GREATER THAN SCREEN SO IS SERIAL BUS     LDA     #$61               ; SET SECONDARY ADDRESS TO $01                         ; WHEN A SECONDARY ADDRESS IS TO BE SENT TO A DEVICE ON                         ; THE SERIAL BUS THE ADDRESS MUST FIRST BE ORED WITH $60     STA     XXB9          ; SAVE SECONDARY ADDRESS     LDY     XXB7          ; GET FILE NAME LENGTH     BNE     XXF69D          ; BRANCH IF FILENAME NOT NULL     JMP     XXF793          ; ELSE DO MISSING FILE NAME ERROR AND RETURNXXF69D = *     JSR     XXF495          ; SEND SECONDARY ADDRESS AND FILENAME     JSR     XXF728          ; PRINT SAVING [FILE NAME]     LDA     XXBA          ; GET DEVICE NUMBER     JSR     XXEE17          ; COMMAND DEVICES ON THE SERIAL BUS TO LISTEN     LDA     XXB9          ; GET SECONDARY ADDRESS     JSR     XXEEC0          ; SEND SECONDARY ADDRESS AFTER LISTEN     LDY     #$00               ; CLEAR INDEX     JSR     XXFBD2          ; COPY I/O START ADDRESS TO BUFFER ADDRESS     LDA     XXAC          ; GET BUFFER ADDRESS LOW BYTE     JSR     XXEEE4          ; OUTPUT A BYTE TO THE SERIAL BUS     LDA     XXAD          ; GET BUFFER ADDRESS HIGH BYTE     JSR     XXEEE4          ; OUTPUT A BYTE TO THE SERIAL BUSXXF6BC = *     JSR     XXFD11          ; CHECK READ/WRITE POINTER, RETURN CB = 1 IF POINTER >= END     BCS     XXF6D7          ; GO DO UNLISTEN IF AT END     LDA     (XXAC),Y          ; GET BYTE FROM BUFFER     JSR     XXEEE4          ; OUTPUT A BYTE TO THE SERIAL BUS     JSR     XXFFE1          ; SCAN STOP KEY     BNE     XXF6D2          ; IF STOP NOT PRESSED GO INCREMENT POINTER AND LOOP FOR NEXT                         ; ELSE ..; CLOSE THE SERIAL BUS DEVICE AND FLAG STOPXXF6CB = *     JSR     XXF6DA          ; CLOSE SERIAL BUS DEVICE     LDA     #$00               ;.     SEC                    ; FLAG STOP     RTSXXF6D2 = *     JSR     XXFD1B          ; INCREMENT READ/WRITE POINTER     BNE     XXF6BC          ; LOOP, BRANCH ALWAYS;***********************************************************************************;;; ??XXF6D7 = *     JSR     XXEF04          ; COMMAND THE SERIAL BUS TO UNLISTEN; CLOSE THE SERIAL BUS DEVICEXXF6DA = *     BIT     XXB9          ; TEST THE SECONDARY ADDRESS     BMI     XXF6EF          ; IF ALREADY CLOSED JUST EXIT     LDA     XXBA          ; GET THE DEVICE NUMBER     JSR     XXEE17          ; COMMAND DEVICES ON THE SERIAL BUS TO LISTEN     LDA     XXB9          ; GET SECONDARY ADDRESS     AND     #$EF               ; MASK THE CHANNEL NUMBER     ORA     #$E0               ; OR WITH THE CLOSE COMMAND     JSR     XXEEC0          ; SEND SECONDARY ADDRESS AFTER LISTEN     JSR     XXEF04          ; COMMAND THE SERIAL BUS TO UNLISTENXXF6EF = *     CLC                    ; FLAG OK     RTSXXF6F1 = *     CMP     #$02               ; COMPARE DEVICE WITH RS232 DEVICE     BNE     XXF6F8          ; BRANCH IF NOT RS232 DEVICE     JMP     XXF0B9          ; ELSE DO ILLEGAL DEVICE NUMBER AND RETURNXXF6F8 = *     JSR     XXF84D          ; GET TAPE BUFFER START POINTER IN XY     BCC     XXF689          ; IF < $0200 DO ILLEGAL DEVICE NUMBER AND RETURN     JSR     XXF8B7          ; WAIT FOR PLAY/RECORD     BCS     XXF727          ; EXIT IF STOP WAS PRESSED     JSR     XXF728          ; PRINT SAVING [FILE NAME]     LDX     #$03               ; SET HEADER FOR A NON RELOCATABLE PROGRAM FILE     LDA     XXB9          ; GET SECONDARY ADDRESS     AND     #$01               ; MASK NON RELOCATABLE BIT     BNE     XXF70F          ; BRANCH IF NON RELOCATABLE PROGRAM     LDX     #$01               ; ELSE SET HEADER FOR A RELOCATABLE PROGRAM FILEXXF70F = *     TXA                    ; COPY HEADER TYPE TO A     JSR     XXF7E7          ; WRITE TAPE HEADER     BCS     XXF727          ; EXIT IF ERROR     JSR     XXF8E6          ; DO TAPE WRITE, 20 CYCLE COUNT     BCS     XXF727          ; EXIT IF ERROR     LDA     XXB9          ; GET SECONDARY ADDRESS     AND     #$02               ; MASK END OF TAPE FLAG     BEQ     XXF726          ; BRANCH IF NOT END OF TAPE     LDA     #$05               ; ELSE SET LOGICAL END OF THE TAPE     JSR     XXF7E7          ; WRITE TAPE HEADER     .BYTE     $24               ; MAKES NEXT LINE BIT XX18 SO CB IS NOT CHANGEDXXF726 = *     CLC                    ; FLAG OKXXF727 = *     RTS;***********************************************************************************;;; PRINT SAVING [FILE NAME]XXF728 = *     LDA     XX9D          ; GET MESSAGE MODE FLAG     BPL     XXF727          ; EXIT IF CONTROL MESSAGES OFF     LDY     #XXF1C5-XXF174                         ; INDEX TO 'SAVING '     JSR     XXF1E6          ; DISPLAY KERNEL I/O MESSAGE     JMP     XXF659          ; PRINT FILE NAME AND RETURN;***********************************************************************************;;; INCREMENT REAL TIME CLOCK; THIS ROUTINE UPDATES THE SYSTEM CLOCK. NORMALLY THIS ROUTINE IS CALLED BY THE; NORMAL KERNAL INTERRUPT ROUTINE EVERY 1/60TH OF A SECOND. IF THE USER PROGRAM; PROCESSES ITS OWN INTERRUPTS THIS ROUTINE MUST BE CALLED TO UPDATE THE TIME. ALSO,; THE STOP KEY ROUTINE MUST BE CALLED IF THE STOP KEY IS TO REMAIN FUNCTIONAL.XXF734 = *     LDX     #$00               ; CLEAR X     INC     XXA2          ; INCREMENT JIFFY LOW BYTE     BNE     XXF740          ; IF NO ROLLOVER SKIP THE MID BYTE INCREMENT     INC     XXA1          ; INCREMENT JIFFY MID BYTE     BNE     XXF740          ; IF NO ROLLOVER SKIP THE HIGH BYTE INCREMENT     INC     XXA0          ; INCREMENT JIFFY HIGH BYTE                         ; NOW SUBTRACT A DAYS WORTH OF JIFFIES FROM CURRENT COUNT                         ; AND REMEMBER ONLY THE CB RESULTXXF740 = *     SEC                    ; SET CARRY FOR SUBTRACT     LDA     XXA2          ; GET JIFFY CLOCK LOW BYTE     SBC     #$01               ; SUBTRACT $4F1A01 LOW BYTE     LDA     XXA1          ; GET JIFFY CLOCK MID BYTE     SBC     #$1A               ; SUBTRACT $4F1A01 MID BYTE     LDA     XXA0          ; GET JIFFY CLOCK HIGH BYTE     SBC     #$4F               ; SUBTRACT $4F1A01 HIGH BYTE     BCC     XXF755          ; BRANCH IF LESS THAN $4F1A01 JIFFIES                         ; ELSE ..     STX     XXA0          ; CLEAR JIFFIES HIGH BYTE     STX     XXA1          ; CLEAR JIFFIES MID BYTE     STX     XXA2          ; CLEAR JIFFIES LOW BYTE                         ; THIS IS WRONG, THERE ARE $4F1A00 JIFFIES IN A DAY SO                         ; THE RESET TO ZERO SHOULD OCCUR WHEN THE VALUE REACHES                         ; $4F1A00 AND NOT $4F1A01. THIS WOULD GIVE AN EXTRA JIFFY                         ; EVERY DAY AND A POSSIBLE TI VALUE OF 24:00:00XXF755 = *     LDA     XX912F          ; GET VIA 2 DRA, KEYBOARD ROW, NO HANDSHAKE     CMP     XX912F          ; COMPARE WITH SELF     BNE     XXF755          ; LOOP IF CHANGING     STA     XX91          ; SAVE VIA 2 DRA, KEYBOARD ROW     RTS;***********************************************************************************;;; READ THE REAL TIME CLOCK; THIS ROUTINE RETURNS THE TIME, IN JIFFIES, IN AXY. THE ACCUMULATOR CONTAINS THE; MOST SIGNIFICANT BYTE.XXF760 = *     SEI                    ; DISABLE INTERRUPTS     LDA     XXA2          ; GET JIFFY CLOCK LOW BYTE     LDX     XXA1          ; GET JIFFY CLOCK MID BYTE     LDY     XXA0          ; GET JIFFY CLOCK HIGH BYTE;***********************************************************************************;;; SET THE REAL TIME CLOCK; THE SYSTEM CLOCK IS MAINTAINED BY AN INTERRUPT ROUTINE THAT UPDATES THE CLOCK; EVERY 1/60TH OF A SECOND. THE CLOCK IS THREE BYTES LONG WHICH GIVES THE CAPABILITY; TO COUNT FROM ZERO UP TO 5,184,000 JIFFIES - 24 HOURS PLUS ONE JIFFY. AT THAT POINT; THE CLOCK RESETS TO ZERO. BEFORE CALLING THIS ROUTINE TO SET THE CLOCK THE NEW TIME,; IN JIFFIES, SHOULD BE IN YXA, THE ACCUMULATOR CONTAINING THE MOST SIGNIFICANT BYTE.XXF767 = *     SEI                    ; DISABLE INTERRUPTS     STA     XXA2          ; SAVE JIFFY CLOCK LOW BYTE     STX     XXA1          ; SAVE JIFFY CLOCK MID BYTE     STY     XXA0          ; SAVE JIFFY CLOCK HIGH BYTE     CLI                    ; ENABLE INTERRUPTS     RTS;***********************************************************************************;;; SCAN STOP KEY, RETURN ZB = 1 = [STOP]; IF THE STOP KEY ON THE KEYBOARD IS PRESSED WHEN THIS ROUTINE IS CALLED THE Z FLAG; WILL BE SET. ALL OTHER FLAGS REMAIN UNCHANGED. IF THE STOP KEY IS NOT PRESSED THEN; THE ACCUMULATOR WILL CONTAIN A BYTE REPRESENTING THE LAST ROW OF THE KEYBOARD SCAN.; THE USER CAN ALSO CHECK FOR CERTAIN OTHER KEYS THIS WAY.XXF770 = *     LDA     XX91          ; GET KEYBOARD ROW     CMP     #$FE               ; COMPARE WITH R0 DOWN     BNE     XXF77D          ; BRANCH IF NOT JUST R0     PHP                    ; SAVE STATUS     JSR     XXFFCC          ; CLOSE INPUT AND OUTPUT CHANNELS     STA     XXC6          ; SAVE KEYBOARD BUFFER LENGTH     PLP                    ; RESTORE STATUSXXF77D = *     RTS;***********************************************************************************;;; FILE ERROR MESSAGESXXF77E = *     LDA     #$01               ; TOO MANY FILES     .BYTE     $2C               ; MAKES NEXT LINE BIT XX02A9XXF781 = *     LDA     #$02               ; FILE ALREADY OPEN     .BYTE     $2C               ; MAKES NEXT LINE BIT XX03A9XXF784 = *     LDA     #$03               ; FILE NOT OPEN     .BYTE     $2C               ; MAKES NEXT LINE BIT XX04A9XXF787 = *     LDA     #$04               ; FILE NOT FOUND     .BYTE     $2C               ; MAKES NEXT LINE BIT XX05A9XXF78A = *     LDA     #$05               ; DEVICE NOT PRESENT     .BYTE     $2C               ; MAKES NEXT LINE BIT XX06A9XXF78D = *     LDA     #$06               ; NOT INPUT FILE     .BYTE     $2C               ; MAKES NEXT LINE BIT XX07A9XXF790 = *     LDA     #$07               ; NOT OUTPUT FILE     .BYTE     $2C               ; MAKES NEXT LINE BIT XX08A9XXF793 = *     LDA     #$08               ; MISSING FILE NAME     .BYTE     $2C               ; MAKES NEXT LINE BIT XX09A9XXF796 = *     LDA     #$09               ; ILLEGAL DEVICE NUMBER     PHA                    ; SAVE ERROR #     JSR     XXFFCC          ; CLOSE INPUT AND OUTPUT CHANNELS     LDY     #XXF174-XXF174                         ; INDEX TO 'I/O ERROR #'     BIT     XX9D          ; TEST MESSAGE MODE FLAG     BVC     XXF7AC          ; EXIT IF KERNAL MESSAGES OFF     JSR     XXF1E6          ; DISPLAY KERNEL I/O MESSAGE     PLA                    ; RESTORE ERROR #     PHA                    ; COPY ERROR #     ORA     #'0'               ; CONVERT TO ASCII     JSR     XXFFD2          ; OUTPUT CHARACTER TO CHANNELXXF7AC = *     PLA                    ; PULL ERROR NUMBER     SEC                    ; FLAG ERROR     RTS;***********************************************************************************;;; FIND TAPE HEADER, EXIT WITH HEADER IN BUFFERXXF7AF = *     LDA     XX93          ; GET LOAD/VERIFY FLAG     PHA                    ; SAVE LOAD/VERIFY FLAG     JSR     XXF8C0          ; INITIATE TAPE READ     PLA                    ; RESTORE LOAD/VERIFY FLAG     STA     XX93          ; SAVE LOAD/VERIFY FLAG     BCS     XXF7E6          ; EXIT IF ERROR     LDY     #$00               ; CLEAR INDEX     LDA     (XXB2),Y          ; READ FIRST BYTE FROM TAPE BUFFER     CMP     #$05               ; COMPARE WITH LOGICAL END OF THE TAPE     BEQ     XXF7E6          ; EXIT IF END OF THE TAPE     CMP     #$01               ; COMPARE WITH HEADER FOR A RELOCATABLE PROGRAM FILE     BEQ     XXF7CE          ; BRANCH IF PROGRAM FILE HEADER     CMP     #$03               ; COMPARE WITH HEADER FOR A NON RELOCATABLE PROGRAM FILE     BEQ     XXF7CE          ; BRANCH IF PROGRAM FILE HEADER     CMP     #$04               ; COMPARE WITH DATA FILE HEADER     BNE     XXF7AF          ; IF DATA FILE LOOP TO FIND TAPE HEADER                         ; WAS PROGRAM FILE HEADERXXF7CE = *     TAX                    ; COPY HEADER TYPE     BIT     XX9D          ; GET MESSAGE MODE FLAG     BPL     XXF7E4          ; EXIT IF CONTROL MESSAGES OFF     LDY     #XXF1D7-XXF174                         ; INDEX TO 'FOUND '     JSR     XXF1E6          ; DISPLAY KERNEL I/O MESSAGE     LDY     #$05               ; INDEX TO TAPE FILENAMEXXF7DA = *     LDA     (XXB2),Y          ; GET BYTE FROM TAPE BUFFER     JSR     XXFFD2          ; OUTPUT CHARACTER TO CHANNEL     INY                    ; INCREMENT INDEX     CPY     #$15               ; COMPARE WITH END+1     BNE     XXF7DA          ; LOOP IF MORE TO DOXXF7E4 = *     CLC                    ; FLAG NO ERROR     DEY                    ; DECREMENT INDEXXXF7E6 = *     RTS;***********************************************************************************;;; WRITE TAPE HEADERXXF7E7 = *     STA     XX9E          ; SAVE HEADER TYPE     JSR     XXF84D          ; GET TAPE BUFFER START POINTER IN XY     BCC     XXF84C          ; EXIT IF < $0200     LDA     XXC2          ; GET I/O START ADDRESS HIGH BYTE     PHA                    ; SAVE IT     LDA     XXC1          ; GET I/O START ADDRESS LOW BYTE     PHA                    ; SAVE IT     LDA     XXAF          ; GET TAPE END ADDRESS HIGH BYTE     PHA                    ; SAVE IT     LDA     XXAE          ; GET TAPE END ADDRESS LOW BYTE     PHA                    ; SAVE IT     LDY     #$BF               ; INDEX TO HEADER END     LDA     #' '               ; CLEAR BYTE, [SPACE]XXF7FE = *     STA     (XXB2),Y          ; CLEAR HEADER BYTE     DEY                    ; DECREMENT INDEX     BNE     XXF7FE          ; LOOP IF MORE TO DO     LDA     XX9E          ; GET HEADER TYPE BACK     STA     (XXB2),Y          ; WRITE TO HEADER     INY                    ; INCREMENT INDEX     LDA     XXC1          ; GET I/O START ADDRESS LOW BYTE     STA     (XXB2),Y          ; WRITE TO HEADER     INY                    ; INCREMENT INDEX     LDA     XXC2          ; GET I/O START ADDRESS HIGH BYTE     STA     (XXB2),Y          ; WRITE TO HEADER     INY                    ; INCREMENT INDEX     LDA     XXAE          ; GET TAPE END ADDRESS LOW BYTE     STA     (XXB2),Y          ; WRITE TO HEADER     INY                    ; INCREMENT INDEX     LDA     XXAF          ; GET TAPE END ADDRESS HIGH BYTE     STA     (XXB2),Y          ; WRITE TO HEADER     INY                    ; INCREMENT INDEX     STY     XX9F          ; SAVE INDEX     LDY     #$00               ; CLEAR Y     STY     XX9E          ; CLEAR NAME INDEXXXF822 = *     LDY     XX9E          ; GET NAME INDEX     CPY     XXB7          ; COMPARE WITH FILE NAME LENGTH     BEQ     XXF834          ; EXIT LOOP IF ALL DONE     LDA     (XXBB),Y          ; GET FILE NAME BYTE     LDY     XX9F          ; GET BUFFER INDEX     STA     (XXB2),Y          ; SAVE FILE NAME BYTE TO BUFFER     INC     XX9E          ; INCREMENT FILE NAME INDEX     INC     XX9F          ; INCREMENT TAPE BUFFER INDEX     BNE     XXF822          ; LOOP, BRANCH ALWAYSXXF834 = *     JSR     XXF854          ; SET TAPE BUFFER START AND END POINTERS     LDA     #$69               ; SET WRITE LEAD CYCLE COUNT     STA     XXAB          ; SAVE WRITE LEAD CYCLE COUNT     JSR     XXF8EA          ; DO TAPE WRITE, NO CYCLE COUNT SET     TAY                    ;.     PLA                    ; PULL TAPE END ADDRESS LOW BYTE     STA     XXAE          ; RESTORE IT     PLA                    ; PULL TAPE END ADDRESS HIGH BYTE     STA     XXAF          ; RESTORE IT     PLA                    ; PULL I/O START ADDRESSES LOW BYTE     STA     XXC1          ; RESTORE IT     PLA                    ; PULL I/O START ADDRESSES HIGH BYTE     STA     XXC2          ; RESTORE IT     TYA                    ;.XXF84C = *     RTS;***********************************************************************************;;; GET TAPE BUFFER START POINTERXXF84D = *     LDX     XXB2          ; GET TAPE BUFFER START POINTER LOW BYTE     LDY     XXB3          ; GET TAPE BUFFER START POINTER HIGH BYTE     CPY     #$02               ; COMPARE HIGH BYTE WITH $02XX     RTS;***********************************************************************************;;; SET TAPE BUFFER START AND END POINTERSXXF854 = *     JSR     XXF84D          ; GET TAPE BUFFER START POINTER IN XY     TXA                    ; COPY TAPE BUFFER START POINTER LOW BYTE     STA     XXC1          ; SAVE AS I/O ADDRESS POINTER LOW BYTE     CLC                    ; CLEAR CARRY FOR ADD     ADC     #$C0               ; ADD BUFFER LENGTH LOW BYTE     STA     XXAE          ; SAVE TAPE BUFFER END POINTER LOW BYTE     TYA                    ; COPY TAPE BUFFER START POINTER HIGH BYTE     STA     XXC2          ; SAVE AS I/O ADDRESS POINTER HIGH BYTE     ADC     #$00               ; ADD BUFFER LENGTH HIGH BYTE     STA     XXAF          ; SAVE TAPE BUFFER END POINTER HIGH BYTE     RTS;***********************************************************************************;;; FIND SPECIFIC TAPE HEADERXXF867 = *     JSR     XXF7AF          ; FIND TAPE HEADER, EXIT WITH HEADER IN BUFFER     BCS     XXF889          ; JUST EXIT IF ERROR     LDY     #$05               ; INDEX TO NAME     STY     XX9F          ; SAVE AS TAPE BUFFER INDEX     LDY     #$00               ; CLEAR Y     STY     XX9E          ; SAVE AS NAME BUFFER INDEXXXF874 = *     CPY     XXB7          ; COMPARE WITH FILE NAME LENGTH     BEQ     XXF888          ; OK EXIT IF MATCH     LDA     (XXBB),Y          ; GET FILE NAME BYTE     LDY     XX9F          ; GET INDEX TO TAPE BUFFER     CMP     (XXB2),Y          ; COMPARE WITH TAPE HEADER NAME BYTE     BNE     XXF867          ; IF NO MATCH GO GET NEXT HEADER     INC     XX9E          ; ELSE INCREMENT NAME BUFFER INDEX     INC     XX9F          ; INCREMENT TAPE BUFFER INDEX     LDY     XX9E          ; GET NAME BUFFER INDEX     BNE     XXF874          ; LOOP, BRANCH ALWAYSXXF888 = *     CLC                    ; FLAG OKXXF889 = *     RTS;***********************************************************************************;;; BUMP TAPE POINTERXXF88A = *     JSR     XXF84D          ; GET TAPE BUFFER START POINTER IN XY     INC     XXA6          ; INCREMENT TAPE BUFFER INDEX     LDY     XXA6          ; GET TAPE BUFFER INDEX     CPY     #$C0               ; COMPARE WITH BUFFER LENGTH     RTS;***********************************************************************************;;; WAIT FOR PLAYXXF894 = *     JSR     XXF8AB          ; RETURN CASSETTE SENSE IN ZB     BEQ     XXF8B5          ; EXIT IF SWITCH CLOSED                         ; CASSETTE SWITCH WAS OPEN     LDY     #XXF18F-XXF174                         ; INDEX TO 'PRESS PLAY ON TAPE'XXF89B = *     JSR     XXF1E6          ; DISPLAY KERNEL I/O MESSAGEXXF89E = *     JSR     XXF94B          ; SCAN STOP KEY AND FLAG ABORT IF PRESSED                         ; NOTE IF STOP WAS PRESSED THE RETURN IS TO THE                         ; ROUTINE THAT CALLED THIS ONE AND NOT HERE     JSR     XXF8AB          ; RETURN CASSETTE SENSE IN ZB     BNE     XXF89E          ; LOOP IF CASSETTE SWITCH OPEN     LDY     #XXF1DE-XXF174                         ; INDEX TO 'OK'     JMP     XXF1E6          ; DISPLAY KERNEL I/O MESSAGE AND RETURN;***********************************************************************************;;; RETURN CASSETTE SENSE IN ZBXXF8AB = *     LDA     #$40               ; MASK FOR CASSETTE SWITCH     BIT     XX911F          ; TEST VIA 1 DRA, NO HANDSHAKE     BNE     XXF8B5          ; BRANCH IF CASSETTE SENSE HIGH     BIT     XX911F          ; TEST VIA 1 DRA AGAINXXF8B5 = *     CLC     RTS;***********************************************************************************;;; WAIT FOR PLAY/RECORDXXF8B7 = *     JSR     XXF8AB          ; RETURN CASSETTE SENSE IN ZB     BEQ     XXF8B5          ; EXIT IF SWITCH CLOSED                         ; CASSETTE SWITCH WAS OPEN     LDY     #XXF1A2-XXF174                         ; INDEX TO 'PRESS RECORD & PLAY ON TAPE'     BNE     XXF89B          ; DISPLAY MESSAGE AND WAIT FOR SWITCH, BRANCH ALWAYS;***********************************************************************************;;; INITIATE TAPE READXXF8C0 = *     LDA     #$00               ; CLEAR A     STA     XX90          ; CLEAR SERIAL STATUS BYTE     STA     XX93          ; CLEAR THE LOAD/VERIFY FLAG     JSR     XXF854          ; SET TAPE BUFFER START AND END POINTERSXXF8C9 = *     JSR     XXF894          ; WAIT FOR PLAY     BCS     XXF8ED          ; EXIT IF STOP WAS PRESSED, USES FURTHER BCS AT TARGET                         ; ADDRESS TO REACH FINAL TARGET AT XXF957     SEI                    ; DISABLE INTERRUPTS     LDA     #$00               ; CLEAR A     STA     XXAA          ;.     STA     XXB4          ;.     STA     XXB0          ; CLEAR TAPE TIMING CONSTANT MIN BYTE     STA     XX9E          ; CLEAR TAPE PASS 1 ERROR LOG/CHAR BUFFER     STA     XX9F          ; CLEAR TAPE PASS 2 ERROR LOG CORRECTED     STA     XX9C          ; CLEAR BYTE RECEIVED FLAG     LDA     #$82               ; ENABLE CA1 INTERRUPT     LDX     #$0E               ; SET INDEX FOR TAPE READ VECTOR     BNE     XXF8F4          ; GO DO TAPE READ/WRITE, BRANCH ALWAYS;***********************************************************************************;;; INITIATE TAPE WRITEXXF8E3 = *     JSR     XXF854          ; SET TAPE BUFFER START AND END POINTERS; DO TAPE WRITE, 20 CYCLE COUNTXXF8E6 = *     LDA     #$14               ; SET WRITE LEAD CYCLE COUNT     STA     XXAB          ; SAVE WRITE LEAD CYCLE COUNT; DO TAPE WRITE, NO CYCLE COUNT SETXXF8EA = *     JSR     XXF8B7          ; WAIT FOR PLAY/RECORDXXF8ED = *     BCS     XXF957          ; IF STOPPED CLEAR SAVE IRQ ADDRESS AND EXIT     SEI                    ; DISABLE INTERRUPTS     LDA     #$A0               ; ENABLE VIA 2 T2 INTERRUPT     LDX     #$08               ; SET INDEX FOR TAPE WRITE TAPE LEADER VECTOR;***********************************************************************************;;; TAPE READ/WRITEXXF8F4 = *     LDY     #$7F               ; DISABLE ALL INTERRUPTS     STY     XX912E          ; SET VIA 2 IER, DISABLE INTERRUPTS     STA     XX912E          ; SET VIA 2 IER, ENABLE INTERRUPTS ACCORDING TO A     JSR     XXF160          ; CHECK RS232 BUS IDLE     LDA     XX0314          ; GET IRQ VECTOR LOW BYTE     STA     XX029F          ; SAVE IRQ VECTOR LOW BYTE     LDA     XX0315          ; GET IRQ VECTOR HIGH BYTE     STA     XX02A0          ; SAVE IRQ VECTOR HIGH BYTE     JSR     XXFCFB          ; SET TAPE VECTOR     LDA     #$02               ; SET COPIES COUNT. THE FIRST COPY IS THE LOAD COPY, THE                         ; SECOND COPY IS THE VERIFY COPY     STA     XXBE          ; SAVE COPIES COUNT     JSR     XXFBDB          ; NEW TAPE BYTE SETUP     LDA     XX911C          ; GET VIA 1 PCR     AND     #$FD               ; CA2 LOW, TURN ON TAPE MOTOR     ORA     #$0C               ; MANUAL OUTPUT MODE     STA     XX911C          ; SET VIA 1 PCR     STA     XXC0          ; SET TAPE MOTOR INTERLOCK                         ; 326656 CYCLE DELAY, ALLOW TAPE MOTOR SPEED TO STABILISE     LDX     #$FF               ; OUTER LOOP COUNTXXF923 = *     LDY     #$FF               ; INNER LOOP COUNTXXF925 = *     DEY                    ; DECREMENT INNER LOOP COUNT     BNE     XXF925          ; LOOP IF MORE TO DO     DEX                    ; DECREMENT OUTER LOOP COUNT     BNE     XXF923          ; LOOP IF MORE TO DO     STA     XX9129          ; SET VIA 2 T2C_H     CLI                    ; ENABLE TAPE INTERRUPTSXXF92F = *     LDA     XX02A0          ; GET SAVED IRQ HIGH BYTE     CMP     XX0315          ; COMPARE WITH THE CURRENT IRQ HIGH BYTE     CLC                    ; FLAG OK     BEQ     XXF957          ; IF TAPE WRITE DONE GO CLEAR SAVED IRQ ADDRESS AND EXIT     JSR     XXF94B          ; SCAN STOP KEY AND FLAG ABORT IF PRESSED                         ; NOTE IF STOP WAS PRESSED THE RETURN IS TO THE                         ; ROUTINE THAT CALLED THIS ONE AND NOT HERE     LDA     XX912D          ; GET VIA 2 IFR     AND     #$40               ; MASK T1 INTERRUPT     BEQ     XXF92F          ; LOOP IF NOT T1 INTERRUPT                         ; ELSE INCREMENT JIFFY CLOCK     LDA     XX9114          ; GET VIA 1 T1C_L, CLEAR T1 FLAG     JSR     XXF734          ; INCREMENT THE REAL TIME CLOCK     JMP     XXF92F          ; LOOP;***********************************************************************************;;; SCAN STOP KEY AND FLAG ABORT IF PRESSEDXXF94B = *     JSR     XXFFE1          ; SCAN STOP KEY     CLC                    ; FLAG NO STOP     BNE     XXF95C          ; EXIT IF NO STOP     JSR     XXFCCF          ; RESTORE EVERYTHING FOR STOP     SEC                    ; FLAG STOPPED     PLA                    ; DUMP RETURN ADDRESS LOW BYTE     PLA                    ; DUMP RETURN ADDRESS HIGH BYTE;***********************************************************************************;;; CLEAR SAVED IRQ ADDRESSXXF957 = *     LDA     #$00               ; CLEAR A     STA     XX02A0          ; CLEAR SAVED IRQ ADDRESS HIGH BYTEXXF95C = *     RTS;***********************************************************************************;;;## SET TIMINGXXF95D = *     STX     XXB1          ; SAVE TAPE TIMING CONSTANT MAX BYTE     LDA     XXB0          ; GET TAPE TIMING CONSTANT MIN BYTE     ASL A                  ; *2     ASL A                  ; *4     CLC                    ; CLEAR CARRY FOR ADD     ADC     XXB0          ; ADD TAPE TIMING CONSTANT MIN BYTE *5     CLC                    ; CLEAR CARRY FOR ADD     ADC     XXB1          ; ADD TAPE TIMING CONSTANT MAX BYTE     STA     XXB1          ; SAVE TAPE TIMING CONSTANT MAX BYTE     LDA     #$00               ;.     BIT     XXB0          ; TEST TAPE TIMING CONSTANT MIN BYTE     BMI     XXF972          ; BRANCH IF B7 SET     ROL A                  ; ELSE SHIFT CARRY INTO ??XXF972 = *     ASL     XXB1          ; SHIFT TAPE TIMING CONSTANT MAX BYTE     ROL A                  ;.     ASL     XXB1          ; SHIFT TAPE TIMING CONSTANT MAX BYTE     ROL A                  ;.     TAX                    ;.XXF979 = *     LDA     XX9128          ; GET VIA 2 T2C_L     CMP     #$15               ;.COMPARE WITH ??     BCC     XXF979          ; LOOP IF LESS     ADC     XXB1          ; ADD TAPE TIMING CONSTANT MAX BYTE     STA     XX9124          ; SET VIA 2 T1C_L     TXA                    ;.     ADC     XX9129          ; ADD VIA 2 T2C_H     STA     XX9125          ; SET VIA 2 T1C_H     CLI                    ; ENABLE INTERRUPTS     RTS;***********************************************************************************;;;;     ON COMMODORE COMPUTERS, THE STREAMS CONSIST OF FOUR KINDS OF SYMBOLS;;     THAT DENOTE DIFFERENT KINDS OF LOW-TO-HIGH-TO-LOW TRANSITIONS ON THE;;     READ OR WRITE SIGNALS OF THE COMMODORE CASSETTE INTERFACE.;;;;     A     A BREAK IN THE COMMUNICATIONS, OR A PULSE WITH VERY LONG CYCLE;;          TIME.;;;;     B     A SHORT PULSE, WHOSE CYCLE TIME TYPICALLY RANGES FROM 296 TO 424;;          MICROSECONDS, DEPENDING ON THE COMPUTER MODEL.;;;;     C     A MEDIUM-LENGTH PULSE, WHOSE CYCLE TIME TYPICALLY RANGES FROM;;          440 TO 576 MICROSECONDS, DEPENDING ON THE COMPUTER MODEL.;;;;     D     A LONG PULSE, WHOSE CYCLE TIME TYPICALLY RANGES FROM 600 TO 744;;          MICROSECONDS, DEPENDING ON THE COMPUTER MODEL.;;;;   THE ACTUAL INTERPRETATION OF THE SERIAL DATA TAKES A LITTLE MORE WORK TO;; EXPLAIN. THE TYPICAL ROM TAPE LOADER (AND THE TURBO LOADERS) WILL;; INITIALIZE A TIMER WITH A SPECIFIED VALUE AND START IT COUNTING DOWN. IF;; EITHER THE TAPE DATA CHANGES OR THE TIMER RUNS OUT, AN IRQ WILL OCCUR. THE;; LOADER WILL DETERMINE WHICH CONDITION CAUSED THE IRQ. IF THE TAPE DATA;; CHANGED BEFORE THE TIMER RAN OUT, WE HAVE A SHORT PULSE, OR A '0' BIT. IF;; THE TIMER RAN OUT FIRST, WE HAVE A LONG PULSE, OR A '1' BIT. DOING THIS;; CONTINUOUSLY AND WE DECODE THE ENTIRE FILE.; READ TAPE BITS, IRQ ROUTINE; READ T2C WHICH HAS BEEN COUNTING DOWN FROM $FFFF. SUBTRACT THIS FROM $FFFFXXF98E = *     LDX     XX9129          ; GET VIA 2 T2C_H     LDY     #$FF               ;.SET $FF     TYA                    ;.A = $FF     SBC     XX9128          ; SUBTRACT VIA 2 T2C_L     CPX     XX9129          ; COMPARE VIA 2 T2C_H WITH PREVIOUS     BNE     XXF98E          ; LOOP IF TIMER LOW BYTE ROLLED OVER     STX     XXB1          ; SAVE TAPE TIMING CONSTANT MAX BYTE     TAX                    ;.COPY $FF - T2C_L     STY     XX9128          ; SET VIA 2 T2C_L TO $FF     STY     XX9129          ; SET VIA 2 T2C_H TO $FF     TYA                    ;.$FF     SBC     XXB1          ; SUBTRACT TAPE TIMING CONSTANT MAX BYTE                         ; A = $FF - T2C_H     STX     XXB1          ; SAVE TAPE TIMING CONSTANT MAX BYTE                         ; XXB1 = $FF - T2C_L     LSR A                  ;.A = $FF - T2C_H >> 1     ROR     XXB1          ; SHIFT TAPE TIMING CONSTANT MAX BYTE                         ; XXB1 = $FF - T2C_L >> 1     LSR A                  ;.A = $FF - T2C_H >> 1     ROR     XXB1          ; SHIFT TAPE TIMING CONSTANT MAX BYTE                         ; XXB1 = $FF - T2C_L >> 1     LDA     XXB0          ; GET TAPE TIMING CONSTANT MIN BYTE     CLC                    ; CLEAR CARRY FOR ADD     ADC     #$3C               ;.     BIT     XX9121          ; TEST VIA 2 DRA, KEYBOARD ROW     CMP     XXB1          ; COMPARE WITH TAPE TIMING CONSTANT MAX BYTE                         ; COMPARE WITH ($FFFF - T2C) >> 2     BCS     XXFA06          ;.BRANCH IF MIN + $3C >= ($FFFF - T2C) >> 2                         ;.MIN + $3C < ($FFFF - T2C) >> 2     LDX     XX9C          ;.GET BYTE RECEIVED FLAG     BEQ     XXF9C3          ;.BRANCH IF NOT BYTE RECEIVED     JMP     XXFAAD          ;.STORE TAPE CHARACTERXXF9C3 = *     LDX     XXA3          ;.GET EOI FLAG BYTE     BMI     XXF9E2          ;.     LDX     #$00               ;.     ADC     #$30               ;.     ADC     XXB0          ; ADD TAPE TIMING CONSTANT MIN BYTE     CMP     XXB1          ; COMPARE WITH TAPE TIMING CONSTANT MAX BYTE     BCS     XXF9ED          ;.     INX                    ;.     ADC     #$26               ;.     ADC     XXB0          ; ADD TAPE TIMING CONSTANT MIN BYTE     CMP     XXB1          ; COMPARE WITH TAPE TIMING CONSTANT MAX BYTE     BCS     XXF9F1          ;.     ADC     #$2C               ;.     ADC     XXB0          ; ADD TAPE TIMING CONSTANT MIN BYTE     CMP     XXB1          ; COMPARE WITH TAPE TIMING CONSTANT MAX BYTE     BCC     XXF9E5          ;.XXF9E2 = *     JMP     XXFA60          ;.XXF9E5 = *     LDA     XXB4          ; GET BIT COUNT     BEQ     XXFA06          ; BRANCH IF ZERO     STA     XXA8          ; SAVE RECEIVER BIT COUNT IN     BNE     XXFA06          ; BRANCH ALWAYSXXF9ED = *     INC     XXA9          ; INCREMENT ?? START BIT CHECK FLAG     BCS     XXF9F3          ;.XXF9F1 = *     DEC     XXA9          ; DECREMENT ?? START BIT CHECK FLAGXXF9F3 = *     SEC                    ;.     SBC     #$13               ;.     SBC     XXB1          ; SUBTRACT TAPE TIMING CONSTANT MAX BYTE     ADC     XX92          ; ADD TIMING CONSTANT FOR TAPE     STA     XX92          ; SAVE TIMING CONSTANT FOR TAPE     LDA     XXA4          ;.GET TAPE BIT CYCLE PHASE     EOR     #$01               ;.     STA     XXA4          ;.SAVE TAPE BIT CYCLE PHASE     BEQ     XXFA25          ;.     STX     XXD7          ;.XXFA06 = *     LDA     XXB4          ; GET BIT COUNT     BEQ     XXFA22          ; EXIT IF ZERO     BIT     XX912D          ; TEST GET 2 IFR     BVC     XXFA22          ; EXIT IF NO T1 INTERRUPT     LDA     #$00               ;.     STA     XXA4          ; CLEAR TAPE BIT CYCLE PHASE     LDA     XXA3          ;.GET EOI FLAG BYTE     BPL     XXFA47          ;.     BMI     XXF9E2          ;.XXFA19 = *     LDX     #$A6               ; SET TIMIMG MAX BYTE     JSR     XXF95D          ; SET TIMING     LDA     XX9B          ;.     BNE     XXF9E5          ;.XXFA22 = *     JMP     XXFF56          ; RESTORE REGISTERS AND EXIT INTERRUPTXXFA25 = *     LDA     XX92          ; GET TIMING CONSTANT FOR TAPE     BEQ     XXFA30          ;.     BMI     XXFA2E          ;.     DEC     XXB0          ; DECREMENT TAPE TIMING CONSTANT MIN BYTE     .BYTE     $2C               ; MAKES NEXT LINE BIT XXB0E6XXFA2E = *     INC     XXB0          ; INCREMENT TAPE TIMING CONSTANT MIN BYTEXXFA30 = *     LDA     #$00               ;.     STA     XX92          ; CLEAR TIMING CONSTANT FOR TAPE     CPX     XXD7          ;.     BNE     XXFA47          ;.     TXA                    ;.     BNE     XXF9E5          ;.     LDA     XXA9          ; GET START BIT CHECK FLAG     BMI     XXFA06          ;.     CMP     #$10               ;.     BCC     XXFA06          ;.     STA     XX96          ;.SAVE CASSETTE BLOCK SYNCHRONIZATION NUMBER     BCS     XXFA06          ;.XXFA47 = *     TXA     EOR     XX9B          ;.     STA     XX9B          ;.     LDA     XXB4          ;.     BEQ     XXFA22          ;.     DEC     XXA3          ;.DECREMENT EOI FLAG BYTE     BMI     XXFA19          ;.     LSR     XXD7          ;.     ROR     XXBF          ;.PARITY COUNT     LDX     #$DA               ; SET TIMIMG MAX BYTE     JSR     XXF95D          ; SET TIMING     JMP     XXFF56          ; RESTORE REGISTERS AND EXIT INTERRUPTXXFA60 = *     LDA     XX96          ;.GET CASSETTE BLOCK SYNCHRONIZATION NUMBER     BEQ     XXFA68          ;.     LDA     XXB4          ;.     BEQ     XXFA6C          ;.XXFA68 = *     LDA     XXA3          ;.GET EOI FLAG BYTE     BPL     XXF9F1          ;.XXFA6C = *     LSR     XXB1          ; SHIFT TAPE TIMING CONSTANT MAX BYTE     LDA     #$93               ;.     SEC                    ;.     SBC     XXB1          ; SUBTRACT TAPE TIMING CONSTANT MAX BYTE     ADC     XXB0          ; ADD TAPE TIMING CONSTANT MIN BYTE     ASL A                  ;.     TAX                    ; COPY TIMIMG HIGH BYTE     JSR     XXF95D          ; SET TIMING     INC     XX9C          ;.     LDA     XXB4          ;.     BNE     XXFA91          ;.     LDA     XX96          ;.GET CASSETTE BLOCK SYNCHRONIZATION NUMBER     BEQ     XXFAAA          ;.     STA     XXA8          ; SAVE RECEIVER BIT COUNT IN     LDA     #$00               ;.     STA     XX96          ;.CLEAR CASSETTE BLOCK SYNCHRONIZATION NUMBER     LDA     #$C0               ; ENABLE T1 INTERRUPT     STA     XX912E          ; SET VIA 2 IER     STA     XXB4          ;.XXFA91 = *     LDA     XX96          ;.GET CASSETTE BLOCK SYNCHRONIZATION NUMBER     STA     XXB5          ;.     BEQ     XXFAA0          ;.     LDA     #$00               ;.     STA     XXB4          ;.     LDA     #$40               ; DISABLE T1 INTERRUPT     STA     XX912E          ; SET VIA 2 IERXXFAA0 = *     LDA     XXBF          ;.PARITY COUNT     STA     XXBD          ;.SAVE RS232 PARITY BYTE     LDA     XXA8          ; GET RECEIVER BIT COUNT IN     ORA     XXA9          ; OR WITH START BIT CHECK FLAG     STA     XXB6          ;.XXFAAA = *     JMP     XXFF56          ; RESTORE REGISTERS AND EXIT INTERRUPT;***********************************************************************************;;;## STORE CHARACTERXXFAAD = *     JSR     XXFBDB          ; NEW TAPE BYTE SETUP     STA     XX9C          ; CLEAR BYTE RECEIVED FLAG     LDX     #$DA               ; SET TIMIMG MAX BYTE     JSR     XXF95D          ; SET TIMING     LDA     XXBE          ;.GET COPIES COUNT     BEQ     XXFABD          ;.     STA     XXA7          ; SAVE RECEIVER INPUT BIT TEMPORARY STORAGEXXFABD = *     LDA     #$0F               ;.     BIT     XXAA          ;.     BPL     XXFADA          ;.     LDA     XXB5          ;.     BNE     XXFAD3          ;.     LDX     XXBE          ;.GET COPIES COUNT     DEX                    ;.     BNE     XXFAD7          ; IF ?? RESTORE REGISTERS AND EXIT INTERRUPT     LDA     #$08               ; SET SHORT BLOCK     JSR     XXFE6A          ; OR INTO SERIAL STATUS BYTE     BNE     XXFAD7          ; RESTORE REGISTERS AND EXIT INTERRUPT, BRANCH ALWAYSXXFAD3 = *     LDA     #$00               ;.     STA     XXAA          ;.XXFAD7 = *     JMP     XXFF56          ; RESTORE REGISTERS AND EXIT INTERRUPTXXFADA = *     BVS     XXFB0D          ;.     BNE     XXFAF6          ;.     LDA     XXB5          ;.     BNE     XXFAD7          ;.     LDA     XXB6          ;.     BNE     XXFAD7          ;.     LDA     XXA7          ; GET RECEIVER INPUT BIT TEMPORARY STORAGE     LSR A                  ;.     LDA     XXBD          ;.GET RS232 PARITY BYTE     BMI     XXFAF0          ;.     BCC     XXFB07          ;.     CLC                    ;.XXFAF0 = *     BCS     XXFB07          ;.     AND     #$0F               ;.     STA     XXAA          ;.XXFAF6 = *     DEC     XXAA          ;.     BNE     XXFAD7          ;.     LDA     #$40               ;.     STA     XXAA          ;.     JSR     XXFBD2          ; COPY I/O START ADDRESS TO BUFFER ADDRESS     LDA     #$00               ;.     STA     XXAB          ;.     BEQ     XXFAD7          ;., BRANCH ALWAYS;***********************************************************************************;;;## RESET POINTERXXFB07 = *     LDA     #$80               ;.     STA     XXAA          ;.     BNE     XXFAD7          ; RESTORE REGISTERS AND EXIT INTERRUPT, BRANCH ALWAYSXXFB0D = *     LDA     XXB5          ;.     BEQ     XXFB1B          ;.     LDA     #$04               ;.     JSR     XXFE6A          ; OR INTO SERIAL STATUS BYTE     LDA     #$00               ;.     JMP     XXFB97          ;.XXFB1B = *     JSR     XXFD11          ; CHECK READ/WRITE POINTER, RETURN CB = 1 IF POINTER >= END     BCC     XXFB23          ;.     JMP     XXFB95          ;.XXFB23 = *     LDX     XXA7          ; GET RECEIVER INPUT BIT TEMPORARY STORAGE     DEX                    ;.     BEQ     XXFB55          ;.     LDA     XX93          ; GET LOAD/VERIFY FLAG     BEQ     XXFB38          ; BRANCH IF LOAD     LDY     #$00               ; CLEAR INDEX     LDA     XXBD          ;.GET RS232 PARITY BYTE     CMP     (XXAC),Y          ;.     BEQ     XXFB38          ;.     LDA     #$01               ;.     STA     XXB6          ;.XXFB38 = *     LDA     XXB6          ;.     BEQ     XXFB87          ;.     LDX     #$3D               ;.     CPX     XX9E          ;.     BCC     XXFB80          ;.     LDX     XX9E          ;.     LDA     XXAD          ;.     STA     XX0100+1,X     ;.     LDA     XXAC          ;.     STA     XX0100,X          ;.     INX                    ;.     INX                    ;.     STX     XX9E          ;.     JMP     XXFB87          ;.XXFB55 = *     LDX     XX9F          ;.     CPX     XX9E          ;.     BEQ     XXFB90          ;.     LDA     XXAC          ;.     CMP     XX0100,X          ;.     BNE     XXFB90          ;.     LDA     XXAD          ;.     CMP     XX0100+1,X     ;.     BNE     XXFB90          ;.     INC     XX9F          ;.     INC     XX9F          ;.     LDA     XX93          ; GET LOAD/VERIFY FLAG     BEQ     XXFB7C          ; BRANCH IF LOAD     LDA     XXBD          ;.GET RS232 PARITY BYTE     LDY     #$00               ;.     CMP     (XXAC),Y          ;.     BEQ     XXFB90          ;.     INY                    ;.     STY     XXB6          ;.XXFB7C = *     LDA     XXB6          ;.     BEQ     XXFB87          ;.XXFB80 = *     LDA     #$10               ;.     JSR     XXFE6A          ; OR INTO SERIAL STATUS BYTE     BNE     XXFB90          ;.XXFB87 = *     LDA     XX93          ; GET LOAD/VERIFY FLAG     BNE     XXFB90          ; BRANCH IF VERIFY     TAY                    ;.     LDA     XXBD          ;.GET RS232 PARITY BYTE     STA     (XXAC),Y          ;.XXFB90 = *     JSR     XXFD1B          ; INCREMENT READ/WRITE POINTER     BNE     XXFBCF          ; RESTORE REGISTERS AND EXIT INTERRUPT, BRANCH ALWAYSXXFB95 = *     LDA     #$80               ;.XXFB97 = *     STA     XXAA          ;.     LDX     XXBE          ;.GET COPIES COUNT     DEX                    ;.     BMI     XXFBA0          ;.     STX     XXBE          ;.SAVE COPIES COUNTXXFBA0 = *     DEC     XXA7          ; DECREMENT RECEIVER INPUT BIT TEMPORARY STORAGE     BEQ     XXFBAC          ;.     LDA     XX9E          ;.     BNE     XXFBCF          ; IF ?? RESTORE REGISTERS AND EXIT INTERRUPT     STA     XXBE          ;.SAVE COPIES COUNT     BEQ     XXFBCF          ; RESTORE REGISTERS AND EXIT INTERRUPT, BRANCH ALWAYSXXFBAC = *     JSR     XXFCCF          ; RESTORE EVERYTHING FOR STOP     JSR     XXFBD2          ; COPY I/O START ADDRESS TO BUFFER ADDRESS     LDY     #$00               ; CLEAR INDEX     STY     XXAB          ; CLEAR CHECKSUMXXFBB6 = *     LDA     (XXAC),Y          ; GET BYTE FROM BUFFER     EOR     XXAB          ; XOR WITH CHECKSUM     STA     XXAB          ; SAVE NEW CHECKSUM     JSR     XXFD1B          ; INCREMENT READ/WRITE POINTER     JSR     XXFD11          ; CHECK READ/WRITE POINTER, RETURN CB = 1 IF POINTER >= END     BCC     XXFBB6          ; LOOP IF NOT AT END     LDA     XXAB          ; GET COMPUTED CHECKSUM     EOR     XXBD          ; COMPARE WITH STORED CHECKSUM ??     BEQ     XXFBCF          ; IF CHECKSUM OK RESTORE REGISTERS AND EXIT INTERRUPT     LDA     #$20               ; ELSE SET CHECKSUM ERROR     JSR     XXFE6A          ; OR INTO SERIAL STATUS BYTEXXFBCF = *     JMP     XXFF56          ; RESTORE REGISTERS AND EXIT INTERRUPT;***********************************************************************************;;; COPY I/O START ADDRESS TO BUFFER ADDRESSXXFBD2 = *     LDA     XXC2          ; GET I/O START ADDRESS HIGH BYTE     STA     XXAD          ; SET BUFFER ADDRESS HIGH BYTE     LDA     XXC1          ; GET I/O START ADDRESS LOW BYTE     STA     XXAC          ; SET BUFFER ADDRESS LOW BYTE     RTS;***********************************************************************************;;; NEW TAPE BYTE SETUPXXFBDB = *     LDA     #$08               ; EIGHT BITS TO DO     STA     XXA3          ; SET BIT COUNT     LDA     #$00               ; CLEAR A     STA     XXA4          ; CLEAR TAPE BIT CYCLE PHASE     STA     XXA8          ; CLEAR START BIT FIRST CYCLE DONE FLAG     STA     XX9B          ; CLEAR BYTE PARITY     STA     XXA9          ; CLEAR START BIT CHECK FLAG, SET NO START BIT YET     RTS;***********************************************************************************;;; SEND LSB FROM TAPE WRITE BYTE TO TAPE; THIS ROUTINE TESTS THE LEAST SIGNIFICANT BIT IN THE TAPE WRITE BYTE AND SETS VIA 2 T2; DEPENDING ON THE STATE OF THE BIT. IF THE BIT IS A 1 A TIME OF $00B0 CYCLES IS SET, IF; THE BOT IS A 0 A TIME OF $0060 CYCLES IS SET. NOTE THAT THIS ROUTINE DOES NOT SHIFT THE; BITS OF THE TAPE WRITE BYTE BUT USES A COPY OF THAT BYTE, THE BYTE ITSELF IS SHIFTED; ELSEWHEREXXFBEA = *     LDA     XXBD          ; GET TAPE WRITE BYTE     LSR A                  ; SHIFT LSB INTO CB     LDA     #$60               ; SET TIME CONSTANT LOW BYTE FOR BIT = 0     BCC     XXFBF3          ; BRANCH IF BIT WAS 0; SET TIME CONSTANT FOR BIT = 1 AND TOGGLE TAPEXXFBF1 = *     LDA     #$B0               ; SET TIME CONSTANT LOW BYTE FOR BIT = 1; WRITE TIME CONSTANT AND TOGGLE TAPEXXFBF3 = *     LDX     #$00               ; SET TIME CONSTANT HIGH BYTE; WRITE TIME CONSTANT AND TOGGLE TAPEXXFBF5 = *     STA     XX9128          ; SET VIA 2 T2C_L     STX     XX9129          ; SET VIA 2 T2C_H     LDA     XX9120          ; GET VIA 2 DRB, KEYBOARD COLUMN     EOR     #$08               ; TOGGLE TAPE OUT BIT     STA     XX9120          ; SET VIA 2 DRB     AND     #$08               ; MASK TAPE OUT BIT     RTS;***********************************************************************************;;; FLAG BLOCK DONE AND EXIT INTERRUPTXXFC06 = *     SEC                    ; SET CARRY FLAG     ROR     XXAD          ; SET BUFFER ADDRESS HIGH BYTE NEGATIVE, FLAG ALL SYNC,                         ; DATA AND CHECKSUM BYTES WRITTEN     BMI     XXFC47          ; RESTORE REGISTERS AND EXIT INTERRUPT, BRANCH ALWAYS;***********************************************************************************;;; TAPE WRITE, IRQ ROUTINE.; THIS IS THE ROUTINE THAT WRITES THE BITS TO THE TAPE. IT IS CALLED EACH TIME VIA 2 T2; TIMES OUT AND CHECKS IF THE START BIT IS DONE, IF SO CHECKS IF THE DATA BITS ARE DONE,; IF SO IT CHECKS IF THE BYTE IS DONE, IF SO IT CHECKS IF THE SYNCHRONISATION BYTES ARE; DONE, IF SO IT CHECKS IF THE DATA BYTES ARE DONE, IF SO IT CHECKS IF THE CHECKSUM BYTE; IS DONE, IF SO IT CHECKS IF BOTH THE LOAD AND VERIFY COPIES HAVE BEEN DONE, IF SO IT; STOPS THE TAPEXXFC0B = *     LDA     XXA8          ; GET START BIT FIRST CYCLE DONE FLAG     BNE     XXFC21          ; IF FIRST CYCLE DONE GO DO REST OF BYTE; EACH BYTE SENT STARTS WITH TWO HALF CYCLES OF $0110 STSTEM CLOCKS AND THE WHOLE BLOCK; ENDS WITH TWO MORE SUCH HALF CYCLES     LDA     #$10               ; SET FIRST START CYCLE TIME CONSTANT LOW BYTE     LDX     #$01               ; SET FIRST START CYCLE TIME CONSTANT HIGH BYTE     JSR     XXFBF5          ; WRITE TIME CONSTANT AND TOGGLE TAPE     BNE     XXFC47          ; IF FIRST HALF CYCLE GO RESTORE REGISTERS AND EXIT                         ; INTERRUPT     INC     XXA8          ; SET START BIT FIRST START CYCLE DONE FLAG     LDA     XXAD          ; GET BUFFER ADDRESS HIGH BYTE     BPL     XXFC47          ; IF BLOCK NOT COMPLETE GO RESTORE REGISTERS AND EXIT                         ; INTERRUPT. THE END OF A BLOCK IS INDICATED BY THE TAPE                         ; BUFFER HIGH BYTE B7 BEING SET TO 1     JMP     XXFC95          ; ELSE DO TAPE ROUTINE, BLOCK COMPLETE EXIT; CONTINUE TAPE BYTE WRITE. THE FIRST START CYCLE, BOTH HALF CYCLES OF IT, IS COMPLETE; SO THE ROUTINE DROPS STRAIGHT THROUGH TO HEREXXFC21 = *     LDA     XXA9          ; GET START BIT CHECK FLAG     BNE     XXFC2E          ; IF THE START BIT IS COMPLETE GO SEND THE BYTE BITS; AFTER THE TWO HALF CYCLES OF $0110 STSTEM CLOCKS THE START BIT IS COMPLETED WITH TWO; HALF CYCLES OF $00B0 SYSTEM CLOCKS. THIS IS THE SAME AS THE FIRST PART OF A 1 BIT     JSR     XXFBF1          ; SET TIME CONSTANT FOR BIT = 1 AND TOGGLE TAPE     BNE     XXFC47          ; IF FIRST HALF CYCLE GO RESTORE REGISTERS AND EXIT                         ; INTERRUPT     INC     XXA9          ; SET START BIT CHECK FLAG     BNE     XXFC47          ; RESTORE REGISTERS AND EXIT INTERRUPT, BRANCH ALWAYS; CONTINUE TAPE BYTE WRITE. THE START BIT, BOTH CYCLES OF IT, IS COMPLETE SO THE ROUTINE; DROPS STRAIGHT THROUGH TO HERE. NOW THE CYCLE PAIRS FOR EACH BIT, AND THE PARITY BIT,; ARE SENTXXFC2E = *     JSR     XXFBEA          ; SEND LSB FROM TAPE WRITE BYTE TO TAPE     BNE     XXFC47          ; IF FIRST HALF CYCLE GO RESTORE REGISTERS AND EXIT                         ; INTERRUPT                         ; ELSE TWO HALF CYCLES HAVE BEEN DONE     LDA     XXA4          ; GET TAPE BIT CYCLE PHASE     EOR     #$01               ; TOGGLE B0     STA     XXA4          ; SAVE TAPE BIT CYCLE PHASE     BEQ     XXFC4A          ; IF BIT CYCLE PHASE COMPLETE GO SETUP FOR NEXT BIT; EACH BIT IS WRITTEN AS TWO FULL CYCLES. A 1 IS SENT AS A FULL CYCLE OF $0160 SYSTEM; CLOCKS THEN A FULL CYCLE OF $00C0 SYSTEM CLOCKS. A 0 IS SENT AS A FULL CYCLE OF $00C0; SYSTEM CLOCKS THEN A FULL CYCLE OF $0160 SYSTEM CLOCKS. TO DO THIS EACH BIT FROM THE; WRITE BYTE IS INVERTED DURING THE SECOND BIT CYCLE PHASE. AS THE BIT IS INVERTED IT; IS ALSO ADDED TO THE, ONE BIT, PARITY COUNT FOR THIS BYTE     LDA     XXBD          ; GET TAPE WRITE BYTE     EOR     #$01               ; INVERT BIT BEING SENT     STA     XXBD          ; SAVE TAPE WRITE BYTE     AND     #$01               ; MASK B0     EOR     XX9B          ; EOR WITH TAPE WRITE BYTE PARITY BIT     STA     XX9B          ; SAVE TAPE WRITE BYTE PARITY BITXXFC47 = *     JMP     XXFF56          ; RESTORE REGISTERS AND EXIT INTERRUPT; THE BIT CYCLE PHASE IS COMPLETE SO SHIFT OUT THE JUST WRITTEN BIT AND TEST FOR BYTE; ENDXXFC4A = *     LSR     XXBD          ; SHIFT BIT OUT OF TAPE WRITE BYTE     DEC     XXA3          ; DECREMENT TAPE WRITE BIT COUNT     LDA     XXA3          ; GET TAPE WRITE BIT COUNT     BEQ     XXFC8C          ; IF ALL THE DATA BITS HAVE BEEN WRITTEN GO SETUP FOR                         ; SENDING THE PARITY BIT NEXT AND EXIT THE INTERRUPT     BPL     XXFC47          ; IF ALL THE DATA BITS ARE NOT YET SENT JUST RESTORE THE                         ; REGISTERS AND EXIT THE INTERRUPT; DO NEXT TAPE BYTE; THE BYTE IS COMPLETE. THE START BIT, DATA BITS AND PARITY BIT HAVE BEEN WRITTEN TO; THE TAPE SO SETUP FOR THE NEXT BYTEXXFC54 = *     JSR     XXFBDB          ; NEW TAPE BYTE SETUP     CLI                    ; ENABLE INTERRUPTS     LDA     XXA5          ; GET CASSETTE SYNCHRONIZATION CHARACTER COUNT     BEQ     XXFC6E          ; IF SYNCHRONISATION CHARACTERS DONE GO DO BLOCK DATA; AT THE START OF EACH BLOCK SENT TO TAPE THERE ARE A NUMBER OF SYNCHRONISATION BYTES; THAT COUNT DOWN TO THE ACTUAL DATA. THE COMMODORE TAPE SYSTEM SAVES TWO COPIES OF ALL; THE TAPE DATA, THE FIRST IS LOADED AND IS INDICATED BY THE SYNCHRONISATION BYTES; HAVING B7 SET, AND THE SECOND COPY IS INDICATED BY THE SYNCHRONISATION BYTES HAVING B7; CLEAR. THE SEQUENCE GOES $09, $08, ..... $02, $01, DATA BYTES     LDX     #$00               ; CLEAR X     STX     XXD7          ; CLEAR CHECKSUM BYTE     DEC     XXA5          ; DECREMENT CASSETTE SYNCHRONIZATION BYTE COUNT     LDX     XXBE          ; GET CASSETTE COPIES COUNT     CPX     #$02               ; COMPARE WITH LOAD BLOCK INDICATOR     BNE     XXFC6A          ; BRANCH IF NOT THE LOAD BLOCK     ORA     #$80               ; THIS IS THE LOAD BLOCK SO MAKE THE SYNCHRONISATION COUNT                         ; GO $89, $88, ..... $82, $81XXFC6A = *     STA     XXBD          ; SAVE THE SYNCHRONISATION BYTE AS THE TAPE WRITE BYTE     BNE     XXFC47          ; RESTORE REGISTERS AND EXIT INTERRUPT, BRANCH ALWAYS; THE SYNCHRONIZATION BYTES HAVE BEEN DONE SO NOW CHECK AND DO THE ACTUAL BLOCK DATAXXFC6E = *     JSR     XXFD11          ; CHECK READ/WRITE POINTER, RETURN CB = 1 IF POINTER >= END     BCC     XXFC7D          ; IF NOT ALL DONE YET GO GET THE BYTE TO SEND     BNE     XXFC06          ; IF POINTER > END GO FLAG BLOCK DONE AND EXIT INTERRUPT                         ; ELSE THE BLOCK IS COMPLETE, IT ONLY REMAINS TO WRITE THE                         ; CHECKSUM BYTE TO THE TAPE SO SETUP FOR THAT     INC     XXAD          ; INCREMENT BUFFER POINTER HIGH BYTE, THIS MEANS THE BLOCK                         ; DONE BRANCH WILL ALWAYS BE TAKEN NEXT TIME WITHOUT HAVING                         ; TO WORRY ABOUT THE LOW BYTE WRAPPING TO ZERO     LDA     XXD7          ; GET CHECKSUM BYTE     STA     XXBD          ; SAVE CHECKSUM AS TAPE WRITE BYTE     BCS     XXFC47          ; RESTORE REGISTERS AND EXIT INTERRUPT, BRANCH ALWAYS; THE BLOCK ISN'T FINISHED SO GET THE NEXT BYTE TO WRITE TO TAPEXXFC7D = *     LDY     #$00               ; CLEAR INDEX     LDA     (XXAC),Y          ; GET BYTE FROM BUFFER     STA     XXBD          ; SAVE AS TAPE WRITE BYTE     EOR     XXD7          ; XOR WITH CHECKSUM BYTE     STA     XXD7          ; SAVE NEW CHECKSUM BYTE     JSR     XXFD1B          ; INCREMENT READ/WRITE POINTER     BNE     XXFC47          ; RESTORE REGISTERS AND EXIT INTERRUPT, BRANCH ALWAYS; SET PARITY AS NEXT BIT AND EXIT INTERRUPTXXFC8C = *     LDA     XX9B          ; GET PARITY BIT     EOR     #$01               ; TOGGLE IT     STA     XXBD          ; SAVE AS TAPE WRITE BYTEXXFC92 = *     JMP     XXFF56          ; RESTORE REGISTERS AND EXIT INTERRUPT; TAPE ROUTINE, BLOCK COMPLETE EXITXXFC95 = *     DEC     XXBE          ; DECREMENT COPIES REMAINING TO READ/WRITE     BNE     XXFC9C          ; BRANCH IF MORE TO DO     JSR     XXFD08          ; ELSE STOP CASSETTE MOTORXXFC9C = *     LDA     #$50               ; SET TAPE WRITE LEADER COUNT     STA     XXA7          ; SAVE TAPE WRITE LEADER COUNT     LDX     #$08               ; SET INDEX FOR WRITE TAPE LEADER VECTOR     SEI                    ; DISABLE INTERRUPTS     JSR     XXFCFB          ; SET TAPE VECTOR     BNE     XXFC92          ; RESTORE REGISTERS AND EXIT INTERRUPT, BRANCH ALWAYS;***********************************************************************************;;; WRITE TAPE LEADER IRQ ROUTINEXXFCA8 = *     LDA     #$78               ; SET TIME CONSTANT LOW BYTE FOR BIT = LEADER     JSR     XXFBF3          ; WRITE TIME CONSTANT AND TOGGLE TAPE     BNE     XXFC92          ; IF TAPE BIT HIGH RESTORE REGISTERS AND EXIT INTERRUPT     DEC     XXA7          ; DECREMENT CYCLE COUNT     BNE     XXFC92          ; IF NOT ALL DONE RESTORE REGISTERS AND EXIT INTERRUPT     JSR     XXFBDB          ; NEW TAPE BYTE SETUP     DEC     XXAB          ; DECREMENT CASSETTE LEADER COUNT     BPL     XXFC92          ; IF NOT ALL DONE RESTORE REGISTERS AND EXIT INTERRUPT     LDX     #$0A               ; SET INDEX FOR TAPE WRITE VECTOR     JSR     XXFCFB          ; SET TAPE VECTOR     CLI                    ; ENABLE INTERRUPTS     INC     XXAB          ; CLEAR CASSETTE LEADER COUNTER, WAS $FF     LDA     XXBE          ; GET CASSETTE BLOCK COUNT     BEQ     XXFCF6          ; IF ALL DONE RESTORE EVERYTHING FOR STOP AND EXIT INTERRUPT     JSR     XXFBD2          ; COPY I/O START ADDRESS TO BUFFER ADDRESS     LDX     #$09               ; SET NINE SYNCHRONISATION BYTES     STX     XXA5          ; SAVE CASSETTE SYNCHRONIZATION BYTE COUNT     BNE     XXFC54          ; GO DO NEXT TAPE BYTE, BRANCH ALWAYS;***********************************************************************************;;; RESTORE EVERYTHING FOR STOPXXFCCF = *     PHP                    ; SAVE STATUS     SEI                    ; DISABLE INTERRUPTS     JSR     XXFD08          ; STOP CASSETTE MOTOR     LDA     #$7F               ; DISABLE ALL INTERRUPTS     STA     XX912E          ; SET VIA 2 IER     LDA     #$F7               ; SET KEYBOARD COLUMN 3 ACTIVE     STA     XX9120          ; SET VIA 2 DRB, KEYBOARD COLUMN     LDA     #$40               ; SET T1 FREE RUN, T2 CLOCK Ø2,                         ; SR DISABLED, LATCHES DISABLED     STA     XX912B          ; SET VIA 2 ACR     JSR     XXFE39          ; SET 60HZ AND ENABLE TIMER     LDA     XX02A0          ; GET SAVED IRQ VECTOR HIGH BYTE     BEQ     XXFCF4          ; BRANCH IF NULL     STA     XX0315          ; RESTORE IRQ VECTOR HIGH BYTE     LDA     XX029F          ; GET SAVED IRQ VECTOR LOW BYTE     STA     XX0314          ; RESTORE IRQ VECTOR LOW BYTEXXFCF4 = *     PLP                    ; RESTORE STATUS     RTS;***********************************************************************************;;; RESET VECTORXXFCF6 = *     JSR     XXFCCF          ; RESTORE EVERYTHING FOR STOP     BEQ     XXFC92          ; RESTORE REGISTERS AND EXIT INTERRUPT, BRANCH ALWAYS;***********************************************************************************;;; SET TAPE VECTORXXFCFB = *     LDA     XXFDF1-8,X     ; GET TAPE IRQ VECTOR LOW BYTE     STA     XX0314          ; SET IRQ VECTOR LOW BYTE     LDA     XXFDF1-7,X     ; GET TAPE IRQ VECTOR HIGH BYTE     STA     XX0315          ; SET IRQ VECTOR HIGH BYTE     RTS;***********************************************************************************;;; STOP CASSETTE MOTORXXFD08 = *     LDA     XX911C          ; GET VIA 1 PCR     ORA     #$0E               ; SET CA2 HIGH, CASSETTE MOTOR OFF     STA     XX911C          ; SET VIA 1 PCR     RTS;***********************************************************************************;;; CHECK READ/WRITE POINTER; RETURN CB = 1 IF POINTER >= ENDXXFD11 = *     SEC                    ; SET CARRY FOR SUBTRACT     LDA     XXAC          ; GET BUFFER ADDRESS LOW BYTE     SBC     XXAE          ; SUBTRACT BUFFER END LOW BYTE     LDA     XXAD          ; GET BUFFER ADDRESS HIGH BYTE     SBC     XXAF          ; SUBTRACT BUFFER END HIGH BYTE     RTS;***********************************************************************************;;; INCREMENT READ/WRITE POINTERXXFD1B = *     INC     XXAC          ; INCREMENT BUFFER ADDRESS LOW BYTE     BNE     XXFD21          ; IF NO OVERFLOW SKIP THE HIGH BYTE INCREMENT     INC     XXAD          ; INCREMENT BUFFER ADDRESS HIGH BYTEXXFD21 = *     RTS;***********************************************************************************;;; RESET, HARDWARE RESET STARTS HEREXXFD22 = *     LDX     #$FF               ; SET X FOR STACK     SEI                    ; DISABLE INTERRUPTS     TXS                    ; CLEAR STACK     CLD                    ; CLEAR DECIMAL MODE     JSR     XXFD3F          ; SCAN FOR AUTOSTART ROM AT $A000     BNE     XXFD2F          ; IF NOT THERE CONTINUE VIC STARTUP     JMP     (XXA000)          ; CALL ROM START CODEXXFD2F = *     JSR     XXFD8D          ; INITIALISE AND TEST RAM     JSR     XXFD52          ; RESTORE DEFAULT I/O VECTORS     JSR     XXFDF9          ; INITIALIZE I/O REGISTERS     JSR     XXE518          ; INITIALISE HARDWARE     CLI                    ; ENABLE INTERRUPTS     JMP     (XXC000)          ; EXECUTE BASIC;***********************************************************************************;;; SCAN FOR AUTOSTART ROM AT $A000, RETURNS ZB=1 IF ROM FOUNDXXFD3F = *     LDX     #$05               ; FIVE CHARACTERS TO TESTXXFD41 = *     LDA     XXFD4D-1,X     ; GET TEST CHARACTER     CMP     XXA004-1,X     ; COMPARE WIITH BYTE IN ROM SPACE     BNE     XXFD4C          ; EXIT IF NO MATCH     DEX                    ; DECREMENT INDEX     BNE     XXFD41          ; LOOP IF NOT ALL DONEXXFD4C = *     RTS;***********************************************************************************;;; AUTOSTART ROM SIGNATUREXXFD4D = *     .BYTE     'A0',$C3,$C2,$CD     ; A0CBM;***********************************************************************************;;; RESTORE DEFAULT I/O VECTORS; THIS ROUTINE RESTORES THE DEFAULT VALUES OF ALL SYSTEM VECTORS USED IN KERNAL AND; BASIC ROUTINES AND INTERRUPTS. THE KERNAL VECTOR ROUTINE IS USED TO READ AND ALTER; INDIVIDUAL SYSTEM VECTORS.XXFD52 = *     LDX     #<XXFD6D          ; POINTER TO VECTOR TABLE LOW BYTE     LDY     #>XXFD6D          ; POINTER TO VECTOR TABLE HIGH BYTE     CLC                    ; FLAG SET VECTORS;***********************************************************************************;;; SET/READ VECTORED I/O FROM (XY), CB = 1 TO READ, CB = 0 TO SET; THIS ROUTINE MANAGES ALL SYSTEM VECTOR JUMP ADDRESSES STORED IN RAM. CALLING THIS; ROUTINE WITH THE ACCUMULATOR CARRY BIT SET WILL STORE THE CURRENT CONTENTS OF THE; RAM VECTORS IN A LIST POINTED TO BY THE X AND Y REGISTERS.; WHEN THIS ROUTINE IS CALLED WITH THE CARRY BIT CLEAR, THE USER LIST POINTED TO BY; THE X AND Y REGISTERS IS TRANSFERRED TO THE SYSTEM RAM VECTORS.; NOTE: THIS ROUTINE REQUIRES CAUTION IN ITS USE. THE BEST WAY TO USE IT IS TO FIRST; READ THE ENTIRE VECTOR CONTENTS INTO THE USER AREA, ALTER THE DESIRED VECTORS, AND; THEN COPY THE CONTENTS BACK TO THE SYSTEM VECTORS.XXFD57 = *     STX     XXC3          ; SAVE POINTER LOW BYTE     STY     XXC4          ; SAVE POINTER HIGH BYTE     LDY     #$1F               ; SET BYTE COUNTXXFD5D = *     LDA     XX0314,Y          ; READ VECTOR BYTE FROM VECTORS     BCS     XXFD64          ; IF READ VECTORS SKIP THE READ FROM XY     LDA     (XXC3),Y          ; READ VECTOR BYTE FROM (XY)XXFD64 = *     STA     (XXC3),Y          ; SAVE BYTE TO (XY)     STA     XX0314,Y          ; SAVE BYTE TO VECTOR     DEY                    ; DECREMENT INDEX     BPL     XXFD5D          ; LOOP IF MORE TO DO     RTS;; THE ABOVE CODE WORKS BUT IT TRIES TO WRITE TO THE ROM. WHILE THIS IS USUALLY HARMLESS;; SYSTEMS THAT USE FLASH ROM MAY SUFFER. HERE IS A VERSION THAT MAKES THE EXTRA WRITE;; TO RAM INSTEAD BUT IS OTHERWISE IDENTICAL IN FUNCTION. ##;;; SET/READ VECTORED I/O FROM (XY), CB = 1 TO READ, CB = 0 TO SET;;XXFD57;     STX     XXC3          ; SAVE POINTER LOW BYTE;     STY     XXC4          ; SAVE POINTER HIGH BYTE;     LDY     #$1F               ; SET BYTE COUNT;XXFD5D;     LDA     (XXC3),Y          ; READ VECTOR BYTE FROM (XY);     BCC     XXFD66          ; IF SET VECTORS SKIP THE READ FROM XY;;     LDA     XX0314,Y          ; ELSE READ VECTOR BYTE FROM VECTORS;     STA     (XXC3),Y          ; SAVE BYTE TO (XY);XXFD66;     STA     XX0314,Y          ; SAVE BYTE TO VECTOR;     DEY                    ; DECREMENT INDEX;     BPL     XXFD5D          ; LOOP IF MORE TO DO;;     RTS;***********************************************************************************;;; KERNAL VECTORSXXFD6D = *     .WORD     XXEABF          ; XX0314     IRQ VECTOR     .WORD     XXFED2          ; XX0316     BRK VECTOR     .WORD     XXFEAD          ; XX0318     NMI VECTOR     .WORD     XXF40A          ; XX031A     OPEN A LOGICAL FILE     .WORD     XXF34A          ; XX031C     CLOSE A SPECIFIED LOGICAL FILE     .WORD     XXF2C7          ; XX031E     OPEN CHANNEL FOR INPUT     .WORD     XXF309          ; XX0320     OPEN CHANNEL FOR OUTPUT     .WORD     XXF3F3          ; XX0322     CLOSE INPUT AND OUTPUT CHANNELS     .WORD     XXF20E          ; XX0324     INPUT CHARACTER FROM CHANNEL     .WORD     XXF27A          ; XX0326     OUTPUT CHARACTER TO CHANNEL     .WORD     XXF770          ; XX0328     SCAN STOP KEY     .WORD     XXF1F5          ; XX032A     GET CHARACTER FROM KEYBOARD QUEUE     .WORD     XXF3EF          ; XX032C     CLOSE ALL CHANNELS AND FILES     .WORD     XXFED2          ; XX032E     USER FUNCTION; VECTOR TO USER DEFINED COMMAND, CURRENTLY POINTS TO BRK.; THIS APPEARS TO BE A HOLDOVER FROM PET DAYS, WHEN THE BUILT-IN MACHINE LANGUAGE MONITOR; WOULD JUMP THROUGH THE XX032E VECTOR WHEN IT ENCOUNTERED A COMMAND THAT IT DID NOT; UNDERSTAND, ALLOWING THE USER TO ADD NEW COMMANDS TO THE MONITOR.; ALTHOUGH THIS VECTOR IS INITIALIZED TO POINT TO THE ROUTINE CALLED BY STOP/RESTORE AND; THE BRK INTERRUPT, AND IS UPDATED BY THE KERNAL VECTOR ROUTINE AT $FD57, IT NO LONGER; HAS ANY FUNCTION.     .WORD     XXF549          ; XX0330     LOAD     .WORD     XXF685          ; XX0332     SAVE;***********************************************************************************;;; INITIALISE AND TEST RAM, THE RAM FROM $000 TO $03FF IS NEVER TESTED AND IS JUST ASSUMED; TO WORK. FIRST A SEARCH IS DONE FROM $0401 FOR THE START OF MEMORY AND THIS IS SAVED, IF; THIS START IS AT OR BEYOND $1100 THEN THE ROUTINE DEAD ENDS. ONCE THE START OF MEMORY IS; FOUND THE ROUTINE LOOKS FOR THE END OF MEMORY, IF THIS END IS BEFORE $2000 THE ROUTINE; AGAIN DEAD ENDS. LASTLY, IF THE END OF MEMORY IS AT $2000 THEN THE SCREEN IS SET TO; $1E00, BUT IF THE MEMORY EXTENDS TO OR BEYOND $2100 THEN THE SCREEN IS MOVED TO $1000XXFD8D = *     LDA     #$00               ; CLEAR A     TAX                    ; CLEAR INDEXXXFD90 = *     STA     XX00,X          ; CLEAR PAGE 0     STA     XX0200,X          ; CLEAR PAGE 2     STA     XX0300,X          ; CLEAR PAGE 3     INX                    ; INCREMENT INDEX     BNE     XXFD90          ; LOOP IF MORE TO DO     LDX     #<XX033C          ; SET CASSETTE BUFFER POINTER LOW BYTE     LDY     #>XX033C          ; SET CASSETTE BUFFER POINTER HIGH BYTE     STX     XXB2          ; SAVE TAPE BUFFER START POINTER LOW BYTE     STY     XXB3          ; SAVE TAPE BUFFER START POINTER HIGH BYTE     STA     XXC1          ; CLEAR RAM TEST POINTER LOW BYTE     STA     XX97          ; CLEAR LOOKING FOR END FLAG     STA     XX0281          ; CLEAR OS START OF MEMORY LOW BYTE     TAY                    ; CLEAR Y     LDA     #$04               ; SET RAM TEST POINTER HIGH BYTE     STA     XXC2          ; SAVE RAM TEST POINTER HIGH BYTEXXFDAF = *     INC     XXC1          ; INCREMENT RAM TEST POINTER LOW BYTE     BNE     XXFDB5          ; IF NO ROLLOVER SKIP THE HIGH BYTE INCREMENT     INC     XXC2          ; INCREMENT RAM TEST POINTER HIGH BYTEXXFDB5 = *     JSR     XXFE91          ; TEST RAM BYTE, RETURN CB=0 IF FAILED     LDA     XX97          ; TEST LOOKING FOR END FLAG     BEQ     XXFDDE          ; BRANCH IF NOT LOOKING FOR END                         ; ELSE NOW LOOKING FOR THE END OF MEMORY     BCS     XXFDAF          ; LOOP IF BYTE TEST PASSED     LDY     XXC2          ; GET TEST ADDRESS HIGH BYTE     LDX     XXC1          ; GET TEST ADDRESS LOW BYTE     CPY     #$20               ; COMPARE WITH $2000, RAM SHOULD ALWAYS END AT OR AFTER                         ; $2000 EVEN WITH NO EXPANSION MEMORY AS THE BUILT IN RAM                         ; ENDS AT $1FFF. THEREFORE THE FOLLOWING TEST SHOULD                         ; NEVER BRANCH     BCC     XXFDEB          ; IF END ADDRESS < $2000 GO DO DEAD END LOOP     CPY     #$21               ; COMPARE WITH $2100     BCS     XXFDD2          ; BRANCH IF >= $2100                         ; ELSE MEMORY ENDED BEFORE $2100     LDY     #$1E               ; SET SCREEN MEMORY PAGE TO $1E00     STY     XX0288          ; SAVE SCREEN MEMORY PAGEXXFDCF = *     JMP     XXFE7B          ; SET THE TOP OF MEMORY AND RETURN                         ; MEMORY ENDS BEYOND $2100XXFDD2 = *     LDA     #$12               ; SET OS START OF MEMORY HIGH BYTE     STA     XX0282          ; SAVE OS START OF MEMORY HIGH BYTE     LDA     #$10               ; SET SCREEN MEMORY PAGE TO $1000     STA     XX0288          ; SAVE SCREEN MEMORY PAGE     BNE     XXFDCF          ; SET THE TOP OF MEMORY AND RETURN, BRANCH ALWAYSXXFDDE = *     BCC     XXFDAF          ; LOOP IF BYTE TEST FAILED, NOT FOUND START YET                         ; ELSE FOUND START OF RAM     LDA     XXC2          ; GET TEST ADDRESS HIGH BYTE     STA     XX0282          ; SAVE OS START OF MEMORY HIGH BYTE     STA     XX97          ; SET LOOKING FOR END FLAG     CMP     #$11               ; COMPARE START WITH $1100, RAM SHOULD ALWAYS START BEFORE                         ; $1100 EVEN WITH NO EXPANSION MEMORY AS THE BUILT IN RAM                         ; STARTS AT $1000. THEREFORE THE FOLLOWING TEST SHOULD                         ; ALWAYS BRANCH     BCC     XXFDAF          ; GO FIND END OF RAM, BRANCH ALWAYS                         ; IF THE CODE DROPS THROUGH HERE THEN THE RAM HAS FAILED                         ; AND THERE IS NOT MUCH ELSE TO BE DONEXXFDEB = *     JSR     XXE5C3          ; INITIALISE VIC CHIP     JMP     XXFDEB          ; LOOP FOREVER;***********************************************************************************;;; TAPE IRQ VECTORSXXFDF1 = *     .WORD     XXFCA8          ; $08     WRITE TAPE LEADER IRQ ROUTINE     .WORD     XXFC0B          ; $0A     TAPE WRITE IRQ ROUTINE     .WORD     XXEABF          ; $0C     NORMAL IRQ VECTOR     .WORD     XXF98E          ; $0E     READ TAPE BITS IRQ ROUTINE;***********************************************************************************;;; INITIALIZE I/O REGISTERSXXFDF9 = *     LDA     #$7F               ; DISABLE ALL INTERRUPTS     STA     XX911E          ; ON VIA 1 IER ..     STA     XX912E          ; .. AND VIA 2 IER     LDA     #$40               ; SET T1 FREE RUN, T2 CLOCK Ø2,                         ; SR DISABLED, LATCHES DISABLED     STA     XX912B          ; SET VIA 2 ACR     LDA     #$40               ; SET T1 FREE RUN, T2 CLOCK Ø2,                         ; SR DISABLED, LATCHES DISABLED     STA     XX911B          ; SET VIA 1 ACR     LDA     #$FE               ; CB2 HIGH, RS232 TX                         ; CB1 +VE EDGE,                         ; CA2 HIGH, TAPE MOTOR OFF                         ; CA1 -VE EDGE     STA     XX911C          ; SET VIA 1 PCR     LDA     #$DE               ; CB2 LOW, SERIAL DATA OUT HIGH                         ; CB1 +VE EDGE,                         ; CA2 HIGH, SERIAL CLOCK OUT LOW                         ; CA1 -VE EDGE     STA     XX912C          ; SET VIA 2 PCR     LDX     #$00               ; ALL INPUTS, RS232 INTERFACE OR PARALLEL USER PORT     STX     XX9112          ; SET VIA 1 DDRB     LDX     #$FF               ; ALL OUTPUTS, KEYBOARD COLUMN     STX     XX9122          ; SET VIA 2 DDRB     LDX     #$00               ; ALL INPUTS, KEYBOARD ROW     STX     XX9123          ; SET VIA 2 DDRA     LDX     #$80               ; OIII IIII, ATN OUT, LIGHT PEN, JOYSTICK, SERIAL DATA                         ; IN, SERIAL CLK IN     STX     XX9113          ; SET VIA 1 DDRA     LDX     #$00               ; ATN OUT LOW, SET ATN HIGH     STX     XX911F          ; SET VIA 1 DRA, NO HANDSHAKE     JSR     XXEF84          ; SET SERIAL CLOCK HIGH     LDA     #$82               ; ENABLE CA1 INTERRUPT, [RESTORE] KEY     STA     XX911E          ; SET VIA 1 IER     JSR     XXEF8D          ; SET SERIAL CLOCK LOW;***********************************************************************************;;; SET 60HZ AND ENABLE TIMERXXFE39 = *     LDA     #$C0               ; ENABLE T1 INTERRUPT     STA     XX912E          ; SET VIA 2 IER     LDA     #$26               ; SET TIMER CONSTANT LOW BYTE [PAL];     LDA     #$89               ; SET TIMER CONSTANT LOW BYTE [NTSC]     STA     XX9124          ; SET VIA 2 T1C_L     LDA     #$48               ; SET TIMER CONSTANT HIGH BYTE [PAL];     LDA     #$42               ; SET TIMER CONSTANT HIGH BYTE [NTSC]     STA     XX9125          ; SET VIA 2 T1C_H     RTS;***********************************************************************************;;; SET FILENAME; THIS ROUTINE IS USED TO SET UP THE FILE NAME FOR THE OPEN, SAVE, OR LOAD ROUTINES.; THE ACCUMULATOR MUST BE LOADED WITH THE LENGTH OF THE FILE AND XY WITH THE POINTER; TO FILE NAME, X BEING THE LOW BYTE. THE ADDRESS CAN BE ANY VALID MEMORY ADDRESS IN; THE SYSTEM WHERE A STRING OF CHARACTERS FOR THE FILE NAME IS STORED. IF NO FILE; NAME DESIRED THE ACCUMULATOR MUST BE SET TO 0, REPRESENTING A ZERO FILE LENGTH,; IN THAT CASE  XY MAY BE SET TO ANY MEMORY ADDRESS.XXFE49 = *     STA     XXB7          ; SET FILE NAME LENGTH     STX     XXBB          ; SET FILE NAME POINTER LOW BYTE     STY     XXBC          ; SET FILE NAME POINTER HIGH BYTE     RTS;***********************************************************************************;;; SET LOGICAL FILE, FIRST AND SECOND ADDRESSES; THIS ROUTINE WILL SET THE LOGICAL FILE NUMBER, DEVICE ADDRESS, AND SECONDARY; ADDRESS, COMMAND NUMBER, FOR OTHER KERNAL ROUTINES.; THE LOGICAL FILE NUMBER IS USED BY THE SYSTEM AS A KEY TO THE FILE TABLE CREATED; BY THE OPEN FILE ROUTINE. DEVICE ADDRESSES CAN RANGE FROM 0 TO 30. THE FOLLOWING; CODES ARE USED BY THE COMPUTER TO STAND FOR THE FOLLOWING CBM DEVICES:; ADDRESS     DEVICE; =======     ======;  0          KEYBOARD;  1          CASSETTE #1;  2          RS-232C DEVICE;  3          CRT DISPLAY;  4          SERIAL BUS PRINTER;  8          CBM SERIAL BUS DISK DRIVE; DEVICE NUMBERS OF FOUR OR GREATER AUTOMATICALLY REFER TO DEVICES ON THE SERIAL; BUS.; A COMMAND TO THE DEVICE IS SENT AS A SECONDARY ADDRESS ON THE SERIAL BUS AFTER; THE DEVICE NUMBER IS SENT DURING THE SERIAL ATTENTION HANDSHAKING SEQUENCE. IF; NO SECONDARY ADDRESS IS TO BE SENT Y SHOULD BE SET TO $FF.XXFE50 = *     STA     XXB8          ; SET LOGICAL FILE     STX     XXBA          ; SET DEVICE NUMBER     STY     XXB9          ; SET SECONDARY ADDRESS OR COMMAND     RTS;***********************************************************************************;;; READ I/O STATUS WORD; THIS ROUTINE RETURNS THE CURRENT STATUS OF THE I/O DEVICE IN THE ACCUMULATOR. THE; ROUTINE IS USUALLY CALLED AFTER NEW COMMUNICATION TO AN I/O DEVICE. THE ROUTINE; WILL GIVE INFORMATION ABOUT DEVICE STATUS, OR ERRORS THAT HAVE OCCURRED DURING THE; I/O OPERATION.XXFE57 = *     LDA     XXBA          ; GET DEVICE NUMBER     CMP     #$02               ; COMPARE DEVICE WITH RS232 DEVICE     BNE     XXFE68          ; BRANCH IF NOT RS232 DEVICE                         ; GET RS232 DEVICE STATUS     LDA     XX0297          ; READ RS232 STATUS WORD     LDA     #$00               ; CLEAR A     STA     XX0297          ; CLEAR RS232 STATUS; THE ABOVE CODE IS WRONG. THE RS232 STATUS IS IN A BUT A IS CLEARED AND THAT IS USED; TO CLEAR THE RS232 STATUS BYTE. SO WHATEVER THE STATUS THE RESULT IS ALWAYS $00 AND; THE STATUS BYTE IS ALWAYS CLEARED. A SOLUTION IS TO USE X TO CLEAR THE STATUS AFTER; IT IS READ INSTEAD OF THE ABOVE LIKE THIS ..;;     LDX     #$00               ; CLEAR X;     STX     XX0297          ; CLEAR RS232 STATUS ##     RTS;***********************************************************************************;;; CONTROL KERNAL MESSAGES; THIS ROUTINE CONTROLS THE PRINTING OF ERROR AND CONTROL MESSAGES BY THE KERNAL.; EITHER PRINT ERROR MESSAGES OR PRINT CONTROL MESSAGES CAN BE SELECTED BY SETTING; THE ACCUMULATOR WHEN THE ROUTINE IS CALLED.; FILE NOT FOUND IS AN EXAMPLE OF AN ERROR MESSAGE. PRESS PLAY ON CASSETTE IS AN; EXAMPLE OF A CONTROL MESSAGE.; BITS 6 AND 7 OF THIS VALUE DETERMINE WHERE THE MESSAGE WILL COME FROM. IF BIT 7; IS SET ONE OF THE ERROR MESSAGES FROM THE KERNAL WILL BE PRINTED. IF BIT 6 IS SET; A CONTROL MESSAGE WILL BE PRINTED.XXFE66 = *     STA     XX9D          ; SET MESSAGE MODE FLAGXXFE68 = *     LDA     XX90          ; READ SERIAL STATUS BYTE; OR INTO SERIAL STATUS BYTEXXFE6A = *     ORA     XX90          ; OR WITH SERIAL STATUS BYTE     STA     XX90          ; SAVE SERIAL STATUS BYTE     RTS;***********************************************************************************;;; SET TIMEOUT ON SERIAL BUS; THIS ROUTINE SETS THE TIMEOUT FLAG FOR THE SERIAL BUS. WHEN THE TIMEOUT FLAG IS; SET, THE COMPUTER WILL WAIT FOR A DEVICE ON THE SERIAL PORT FOR 64 MILLISECONDS.; IF THE DEVICE DOES NOT RESPOND TO THE COMPUTER'S DAV SIGNAL WITHIN THAT TIME THE; COMPUTER WILL RECOGNIZE AN ERROR CONDITION AND LEAVE THE HANDSHAKE SEQUENCE. WHEN; THIS ROUTINE IS CALLED AND THE ACCUMULATOR CONTAINS A 0 IN BIT 7, TIMEOUTS ARE; ENABLED. A 1 IN BIT 7 WILL DISABLE THE TIMEOUTS.; NOTE: THE THE TIMEOUT FEATURE IS USED TO COMMUNICATE THAT A DISK FILE IS NOT FOUND; ON AN ATTEMPT TO OPEN A FILE.XXFE6F = *     STA     XX0285          ; SAVE SERIAL BUS TIMEOUT FLAG     RTS;***********************************************************************************;;; READ/SET THE TOP OF MEMORY, CB = 1 TO READ, CB = 0 TO SET; THIS ROUTINE IS USED TO READ AND SET THE TOP OF RAM. WHEN THIS ROUTINE IS CALLED; WITH THE CARRY BIT SET THE POINTER TO THE TOP OF RAM WILL BE LOADED INTO XY. WHEN; THIS ROUTINE IS CALLED WITH THE CARRY BIT CLEAR XY WILL BE SAVED AS THE TOP OF; MEMORY POINTER CHANGING THE TOP OF MEMORY.XXFE73 = *     BCC     XXFE7B          ; IF CB CLEAR GO SET THE TOP OF MEMORY; READ THE TOP OF MEMORYXXFE75 = *     LDX     XX0283          ; GET MEMORY TOP LOW BYTE     LDY     XX0284          ; GET MEMORY TOP HIGH BYTE; SET THE TOP OF MEMORYXXFE7B = *     STX     XX0283          ; SET MEMORY TOP LOW BYTE     STY     XX0284          ; SET MEMORY TOP HIGH BYTE     RTS;***********************************************************************************;;; READ/SET THE BOTTOM OF MEMORY, CB = 1 TO READ, CB = 0 TO SET; THIS ROUTINE IS USED TO READ AND SET THE BOTTOM OF RAM. WHEN THIS ROUTINE IS; CALLED WITH THE CARRY BIT SET THE POINTER TO THE BOTTOM OF RAM WILL BE LOADED; INTO XY. WHEN THIS ROUTINE IS CALLED WITH THE CARRY BIT CLEAR XY WILL BE SAVED AS; THE BOTTOM OF MEMORY POINTER CHANGING THE BOTTOM OF MEMORY.XXFE82 = *     BCC     XXFE8A          ; IF CB CLEAR GO SET THE BOTTOM OF MEMORY; READ THE BOTTOM OF MEMORY     LDX     XX0281          ; READ OS START OF MEMORY LOW BYTE     LDY     XX0282          ; READ OS START OF MEMORY HIGH BYTE; SET THE BOTTOM OF MEMORYXXFE8A = *     STX     XX0281          ; SET OS START OF MEMORY LOW BYTE     STY     XX0282          ; SET OS START OF MEMORY HIGH BYTE     RTS;***********************************************************************************;;; NON-DESTRUCTIVE TEST RAM BYTE, RETURN CB=0 IF FAILEDXXFE91 = *     LDA     (XXC1),Y          ; GET EXISTING RAM BYTE     TAX                    ; COPY TO X     LDA     #$55               ; SET FIRST TEST BYTE     STA     (XXC1),Y          ; SAVE TO RAM     CMP     (XXC1),Y          ; COMPARE WITH SAVED     BNE     XXFEA4          ; BRANCH IF FAIL     ROR A                  ; MAKE BYTE $AA, CARRY IS SET HERE     STA     (XXC1),Y          ; SAVE TO RAM     CMP     (XXC1),Y          ; COMPARE WITH SAVED     BNE     XXFEA4          ; BRANCH IF FAIL     .BYTE     $A9               ; MAKES NEXT LINE LDA #$18XXFEA4 = *     CLC                    ; FLAG TEST FAILED     TXA                    ; GET ORIGINAL BYTE BACK     STA     (XXC1),Y          ; RESTORE ORIGINAL BYTE     RTS;***********************************************************************************;;; NMI VECTORXXFEA9 = *     SEI                    ; DISABLE INTERRUPTS     JMP     (XX0318)          ; DO NMI VECTOR;***********************************************************************************;;; NMI HANDLERXXFEAD = *     PHA                    ; SAVE A     TXA                    ; COPY X     PHA                    ; SAVE X     TYA                    ; COPY Y     PHA                    ; SAVE Y     LDA     XX911D          ; GET VIA 1 IFR     BPL     XXFEFF          ; IF NO INTERRUPT RESTORE REGISTERS AND EXIT     AND     XX911E          ; AND WITH VIA 1 IER     TAX                    ; COPY TO X     AND     #$02               ; MASK [RESTORE] KEY     BEQ     XXFEDE          ; BRANCH IF NOT [RESTORE] KEY                         ; ELSE WAS [RESTORE] KEY ..     JSR     XXFD3F          ; SCAN FOR AUTOSTART ROM AT $A000     BNE     XXFEC7          ; BRANCH IF NO AUTOSTART ROM     JMP     (XXA002)          ; ELSE DO AUTOSTART ROM BREAK ENTRYXXFEC7 = *     BIT     XX9111          ; TEST VIA 1 DRA     JSR     XXF734          ; INCREMENT THE REAL TIME CLOCK     JSR     XXFFE1          ; SCAN STOP KEY     BNE     XXFEFF          ; IF NOT [STOP] RESTORE REGISTERS AND EXIT INTERRUPT;***********************************************************************************;;; BRK HANDLERXXFED2 = *     JSR     XXFD52          ; RESTORE DEFAULT I/O VECTORS     JSR     XXFDF9          ; INITIALIZE I/O REGISTERS     JSR     XXE518          ; INITIALISE HARDWARE     JMP     (XXC002)          ; DO BASIC BREAK ENTRY;***********************************************************************************;;; RS232 NMI ROUTINEXXFEDE = *     LDA     XX911E          ; GET VIA 1 IER     ORA     #$80               ; SET ENABLE BIT, THIS BIT SHOULD BE SET ACCORDING TO THE                         ; ROCKWELL 6522 DATASHEET BUT CLEAR ACORDING TO THE MOS                         ; DATASHEET. BEST TO ASSUME IT'S NOT IN THE STATE REQUIRED                         ; AND SET IT SO     PHA                    ; SAVE TO RE-ENABLE INTERRUPTS     LDA     #$7F               ; DISABLE ALL INTERRUPTS     STA     XX911E          ; SET VIA 1 IER     TXA                    ; GET ACTIVE INTERRUPTS BACK     AND     #$40               ; MASK T1 INTERRUPT     BEQ     XXFF02          ; BRANCH IF NOT T1 INTERRUPT                         ; WAS VIA 1 T1 INTERRUPT     LDA     #$CE               ; CB2 LOW, CB1 -VE EDGE, CA2 HIGH, CA1 -VE EDGE     ORA     XXB5          ; OR RS232 NEXT BIT TO SEND, SETS CB2 HIGH IF SET     STA     XX911C          ; SET VIA 1 PCR     LDA     XX9114          ; GET VIA 1 T1C_L     PLA                    ; RESTORE INTERRUPT ENABLE BYTE TO RSTORE PREVIOUSLY                         ; ENABLED INTERRUPTS     STA     XX911E          ; SET VIA 1 IER     JSR     XXEFA3          ; RS232 TX NMI ROUTINEXXFEFF = *     JMP     XXFF56          ; RESTORE REGISTERS AND EXIT INTERRUPT                         ; WAS NOT VIA 1 T1 INTERRUPTXXFF02 = *     TXA                    ; GET ACTIVE INTERRUPTS BACK     AND     #$20               ; MASK T2 INTERRUPT     BEQ     XXFF2C          ; BRANCH IF NOT T2 INTERRUPT                         ; WAS VIA 1 T2 INTERRUPT     LDA     XX9110          ; GET VIA 1 DRB     AND     #$01               ; MASK RS232 DATA IN     STA     XXA7          ; SAVE RECEIVER INPUT BIT TEMP STORAGE     LDA     XX9118          ; GET VIA 1 T2C_L     SBC     #$16               ;.     ADC     XX0299          ; ADD BAUD RATE BIT TIME LOW BYTE     STA     XX9118          ; SET VIA 1 T2C_L     LDA     XX9119          ; GET VIA 1 T2C_H     ADC     XX029A          ; ADD BAUD RATE BIT TIME HIGH BYTE     STA     XX9119          ; SET VIA 1 T2C_H     PLA                    ; RESTORE INTERRUPT ENABLE BYTE TO RESTORE PREVIOUSLY                         ; ENABLED INTERRUPTS     STA     XX911E          ; SET VIA 1 IER, RESTORE INTERRUPTS     JSR     XXF036          ; RS232 RX     JMP     XXFF56          ; RESTORE REGISTERS AND EXIT INTERRUPT                         ; WAS NOT VIA 1 T2 INTERRUPTXXFF2C = *     TXA                    ; GET ACTIVE INTERRUPTS BACK     AND     #$10               ; MASK CB1 INTERRUPT, RX DATA BIT TRANSITION     BEQ     XXFF56          ; IF NO BIT RESTORE REGISTERS AND EXIT INTERRUPT     LDA     XX0293          ; GET PSEUDO 6551 CONTROL REGISTER     AND     #$0F               ; CLEAR NON BAUD BITS     BNE     XXFF38          ; SHORT DELAY. WAS THIS TO BE A BRANCH TO CODE TO IMPLEMENT                         ; THE USER BAUD RATE ??XXFF38 = *     ASL A                  ; *2, 2 BYTES PER BAUD COUNT     TAX                    ; COPY TO INDEX     LDA     XXFF5C-2,X     ; GET BAUD COUNT LOW BYTE     STA     XX9118          ; SET VIA 1 T2C_L     LDA     XXFF5C-1,X     ; GET BAUD COUNT HIGH BYTE     STA     XX9119          ; SET VIA 1 T2C_H     LDA     XX9110          ; READ VIA 1 DRB, CLEAR INTERRUPT FLAG     PLA                    ; RESTORE INTERRUPT ENABLE BYTE TO RSTORE PREVIOUSLY                         ; ENABLED INTERRUPTS     ORA     #$20               ; ENABLE T2 INTERRUPT     AND     #$EF               ; DISABLE CB1 INTERRUPT     STA     XX911E          ; SET VIA 1 IER     LDX     XX0298          ; GET NUMBER OF BITS TO BE SENT/RECEIVED     STX     XXA8          ; SAVE RECEIVER BIT COUNT IN;***********************************************************************************;;; RESTORE THE REGISTERS AND EXIT THE INTERRUPT;; IF YOU WRITE YOUR OWN INTERRUPT CODE YOU SHOULD EITHER RETURN FROM THE INTERRUPT; USING CODE THAT ENDS UP HERE OT CODE THAT REPLICATES THIS CODE.XXFF56 = *     PLA                    ; PULL Y     TAY                    ; RESTORE Y     PLA                    ; PULL X     TAX                    ; RESTORE X     PLA                    ; RESTORE A     RTI;***********************************************************************************;;; BAUD RATE WORD IS CALCULATED FROM ..;; (SYSTEM CLOCK / BAUD RATE) / 2 - 100;;          SYSTEM CLOCK;          ------------; PAL          1108404 HZ; NTSC     1022727 HZ; BAUD RATE TABLES FOR PAL VIC 20XXFF5C = *     .WORD     $2AE6               ;   50   BAUD     .WORD     $1C78               ;   75   BAUD     .WORD     $1349               ;  110   BAUD     .WORD     $0FB1               ;  134.5 BAUD     .WORD     $0E0A               ;  150   BAUD     .WORD     $06D3               ;  300   BAUD     .WORD     $0338               ;  600   BAUD     .WORD     $016A               ; 1200   BAUD     .WORD     $00D0               ; 1800   BAUD     .WORD     $0083               ; 2400   BAUD     .WORD     $0036               ; 3600   BAUD; BAUD RATE TABLES FOR NTSC VIC 20;     .WORD     $2792               ;   50   BAUD;     .WORD     $1A40               ;   75   BAUD;     .WORD     $11C6               ;  110   BAUD;     .WORD     $0E74               ;  134.5 BAUD;     .WORD     $0CEE               ;  150   BAUD;     .WORD     $0645               ;  300   BAUD;     .WORD     $02F1               ;  600   BAUD;     .WORD     $0146               ; 1200   BAUD;     .WORD     $00B8               ; 1800   BAUD;     .WORD     $0071               ; 2400   BAUD;     .WORD     $002A               ; 3600   BAUD;***********************************************************************************;;; IRQ VECTORXXFF72 = *     PHA                    ; SAVE A     TXA                    ; COPY X     PHA                    ; SAVE X     TYA                    ; COPY Y     PHA                    ; SAVE Y     TSX                    ; COPY STACK POINTER     LDA     XX0100+4,X     ; GET THE STACKED STATUS REGISTER     AND     #$10               ; MASK THE BRK FLAG BIT     BEQ     XXFF82          ; IF NOT BRK GO DO THE HARDWARE IRQ VECTOR     JMP     (XX0316)          ; ELSE DO THE BRK VECTOR (IBRK)XXFF82 = *     JMP     (XX0314)          ; DO IRQ VECTOR (IIRQ);***********************************************************************************;;; SPARE BYTES, NOT REFERENCED;XXFF85     .BYTE     $FF,$FF,$FF,$FF,$FF;***********************************************************************************;;; RESTORE DEFAULT I/O VECTORS; THIS ROUTINE RESTORES THE DEFAULT VALUES OF ALL SYSTEM VECTORS USED IN KERNAL AND; BASIC ROUTINES AND INTERRUPTS. THE KERNAL VECTOR ROUTINE IS USED TO READ AND ALTER; INDIVIDUAL SYSTEM VECTORS.;XXFF8A     JMP     XXFD52          ; RESTORE DEFAULT I/O VECTORS;***********************************************************************************;;; READ/SET VECTORED I/O; THIS ROUTINE MANAGES ALL SYSTEM VECTOR JUMP ADDRESSES STORED IN RAM. CALLING THIS; ROUTINE WITH THE ACCUMULATOR CARRY BIT SET WILL STORE THE CURRENT CONTENTS OF THE; RAM VECTORS IN A LIST POINTED TO BY THE X AND Y REGISTERS.; WHEN THIS ROUTINE IS CALLED WITH THE CARRY BIT CLEAR, THE USER LIST POINTED TO BY; THE X AND Y REGISTERS IS TRANSFERRED TO THE SYSTEM RAM VECTORS.; NOTE: THIS ROUTINE REQUIRES CAUTION IN ITS USE. THE BEST WAY TO USE IT IS TO FIRST; READ THE ENTIRE VECTOR CONTENTS INTO THE USER AREA, ALTER THE DESIRED VECTORS, AND; THEN COPY THE CONTENTS BACK TO THE SYSTEM VECTORS.;XXFF8D     JMP     XXFD57          ; SET/READ VECTORED I/O FROM (XY);***********************************************************************************;;; CONTROL KERNAL MESSAGES; THIS ROUTINE CONTROLS THE PRINTING OF ERROR AND CONTROL MESSAGES BY THE KERNAL.; EITHER PRINT ERROR MESSAGES OR PRINT CONTROL MESSAGES CAN BE SELECTED BY SETTING; THE ACCUMULATOR WHEN THE ROUTINE IS CALLED.; FILE NOT FOUND IS AN EXAMPLE OF AN ERROR MESSAGE. PRESS PLAY ON CASSETTE IS AN; EXAMPLE OF A CONTROL MESSAGE.; BITS 6 AND 7 OF THIS VALUE DETERMINE WHERE THE MESSAGE WILL COME FROM. IF BIT 7; IS SET ONE OF THE ERROR MESSAGES FROM THE KERNAL WILL BE PRINTED. IF BIT 6 IS SET; A CONTROL MESSAGE WILL BE PRINTED.XXFF90 = *     JMP     XXFE66          ; CONTROL KERNAL MESSAGES;***********************************************************************************;;; SEND SECONDARY ADDRESS AFTER LISTEN; THIS ROUTINE IS USED TO SEND A SECONDARY ADDRESS TO AN I/O DEVICE AFTER A CALL TO; THE LISTEN ROUTINE IS MADE AND THE DEVICE COMMANDED TO LISTEN. THE ROUTINE CANNOT; BE USED TO SEND A SECONDARY ADDRESS AFTER A CALL TO THE TALK ROUTINE.; A SECONDARY ADDRESS IS USUALLY USED TO GIVE SET-UP INFORMATION TO A DEVICE BEFORE; I/O OPERATIONS BEGIN.; WHEN A SECONDARY ADDRESS IS TO BE SENT TO A DEVICE ON THE SERIAL BUS THE ADDRESS; MUST FIRST BE ORED WITH $60.;XXFF93     JMP     XXEEC0          ; SEND SECONDARY ADDRESS AFTER LISTEN;***********************************************************************************;;; SEND SECONDARY ADDRESS AFTER TALK; THIS ROUTINE TRANSMITS A SECONDARY ADDRESS ON THE SERIAL BUS FOR A TALK DEVICE.; THIS ROUTINE MUST BE CALLED WITH A NUMBER BETWEEN 4 AND 31 IN THE ACCUMULATOR.; THE ROUTINE WILL SEND THIS NUMBER AS A SECONDARY ADDRESS COMMAND OVER THE SERIAL; BUS. THIS ROUTINE CAN ONLY BE CALLED AFTER A CALL TO THE TALK ROUTINE. IT WILL; NOT WORK AFTER A LISTEN.;XXFF96     JMP     XXEECE          ; SEND SECONDARY ADDRESS AFTER TALK;***********************************************************************************;;; READ/SET THE TOP OF MEMORY; THIS ROUTINE IS USED TO READ AND SET THE TOP OF RAM. WHEN THIS ROUTINE IS CALLED; WITH THE CARRY BIT SET THE POINTER TO THE TOP OF RAM WILL BE LOADED INTO XY. WHEN; THIS ROUTINE IS CALLED WITH THE CARRY BIT CLEAR XY WILL BE SAVED AS THE TOP OF; MEMORY POINTER CHANGING THE TOP OF MEMORY.XXFF99 = *     JMP     XXFE73          ; READ/SET THE TOP OF MEMORY;***********************************************************************************;;; READ/SET THE BOTTOM OF MEMORY; THIS ROUTINE IS USED TO READ AND SET THE BOTTOM OF RAM. WHEN THIS ROUTINE IS; CALLED WITH THE CARRY BIT SET THE POINTER TO THE BOTTOM OF RAM WILL BE LOADED; INTO XY. WHEN THIS ROUTINE IS CALLED WITH THE CARRY BIT CLEAR XY WILL BE SAVED AS; THE BOTTOM OF MEMORY POINTER CHANGING THE BOTTOM OF MEMORY.XXFF9C = *     JMP     XXFE82          ; READ/SET THE BOTTOM OF MEMORY;***********************************************************************************;;; SCAN THE KEYBOARD; THIS ROUTINE WILL SCAN THE KEYBOARD AND CHECK FOR PRESSED KEYS. IT IS THE SAME; ROUTINE CALLED BY THE INTERRUPT HANDLER. IF A KEY IS DOWN, ITS ASCII VALUE IS; PLACED IN THE KEYBOARD QUEUE.;XXFF9F     JMP     XXEB1E          ; SCAN KEYBOARD;***********************************************************************************;;; SET TIMEOUT ON SERIAL BUS; THIS ROUTINE SETS THE TIMEOUT FLAG FOR THE SERIAL BUS. WHEN THE TIMEOUT FLAG IS; SET, THE COMPUTER WILL WAIT FOR A DEVICE ON THE SERIAL PORT FOR 64 MILLISECONDS.; IF THE DEVICE DOES NOT RESPOND TO THE COMPUTER'S DAV SIGNAL WITHIN THAT TIME THE; COMPUTER WILL RECOGNIZE AN ERROR CONDITION AND LEAVE THE HANDSHAKE SEQUENCE. WHEN; THIS ROUTINE IS CALLED AND THE ACCUMULATOR CONTAINS A 0 IN BIT 7, TIMEOUTS ARE; ENABLED. A 1 IN BIT 7 WILL DISABLE THE TIMEOUTS.; NOTE: THE THE TIMEOUT FEATURE IS USED TO COMMUNICATE THAT A DISK FILE IS NOT FOUND; ON AN ATTEMPT TO OPEN A FILE.;XXFFA2     JMP     XXFE6F          ; SET TIMEOUT ON SERIAL BUS;************************************************************************************;; INPUT A BYTE FROM THE SERIAL BUS; THIS ROUTINE READS A BYTE OF DATA FROM THE SERIAL BUS USING FULL HANDSHAKING. THE; DATA IS RETURNED IN THE ACCUMULATOR. BEFORE USING THIS ROUTINE THE TALK ROUTINE,; XXFFB4, MUST HAVE BEEN CALLED FIRST TO COMMAND THE DEVICE ON THE SERIAL BUS TO; SEND DATA ON THE BUS. IF THE INPUT DEVICE NEEDS A SECONDARY COMMAND IT MUST BE SENT; BY USING THE TKSA ROUTINE, XXFF96, BEFORE CALLING THIS ROUTINE.; ERRORS ARE RETURNED IN THE STATUS WORD WHICH CAN BE READ BY CALLING THE READST; ROUTINE, XXFFB7.;XXFFA5     JMP     XXEF19          ; INPUT BYTE FROM SERIAL BUS;************************************************************************************;; OUTPUT A BYTE TO THE SERIAL BUS; THIS ROUTINE IS USED TO SEND INFORMATION TO DEVICES ON THE SERIAL BUS. A CALL TO; THIS ROUTINE WILL PUT A DATA BYTE ONTO THE SERIAL BUS USING FULL HANDSHAKING.; BEFORE THIS ROUTINE IS CALLED THE LISTEN ROUTINE, XXFFB1, MUST BE USED TO; COMMAND A DEVICE ON THE SERIAL BUS TO GET READY TO RECEIVE DATA.; THE ACCUMULATOR IS LOADED WITH A BYTE TO OUTPUT AS DATA ON THE SERIAL BUS. A; DEVICE MUST BE LISTENING OR THE STATUS WORD WILL RETURN A TIMEOUT. THIS ROUTINE; ALWAYS BUFFERS ONE CHARACTER. SO WHEN A CALL TO THE UNLISTEN ROUTINE, XXFFAE,; IS MADE TO END THE DATA TRANSMISSION, THE BUFFERED CHARACTER IS SENT WITH EOI; SET. THEN THE UNLISTEN COMMAND IS SENT TO THE DEVICE.;XXFFA8     JMP     XXEEE4          ; OUTPUT A BYTE TO THE SERIAL BUS;***********************************************************************************;;; COMMAND THE SERIAL BUS TO UNTALK; THIS ROUTINE WILL TRANSMIT AN UNTALK COMMAND ON THE SERIAL BUS. ALL DEVICES; PREVIOUSLY SET TO TALK WILL STOP SENDING DATA WHEN THIS COMMAND IS RECEIVED.;XXFFAB     JMP     XXEEF6          ; COMMAND THE SERIAL BUS TO UNTALK;***********************************************************************************;;; COMMAND THE SERIAL BUS TO UNLISTEN; THIS ROUTINE COMMANDS ALL DEVICES ON THE SERIAL BUS TO STOP RECEIVING DATA FROM; THE COMPUTER. CALLING THIS ROUTINE RESULTS IN AN UNLISTEN COMMAND BEING TRANSMITTED; ON THE SERIAL BUS. ONLY DEVICES PREVIOUSLY COMMANDED TO LISTEN WILL BE AFFECTED.; THIS ROUTINE IS NORMALLY USED AFTER THE COMPUTER IS FINISHED SENDING DATA TO; EXTERNAL DEVICES. SENDING THE UNLISTEN WILL COMMAND THE LISTENING DEVICES TO GET; OFF THE SERIAL BUS SO IT CAN BE USED FOR OTHER PURPOSES.;XXFFAE     JMP     XXEF04          ; COMMAND THE SERIAL BUS TO UNLISTEN;***********************************************************************************;;; COMMAND DEVICES ON THE SERIAL BUS TO LISTEN; THIS ROUTINE WILL COMMAND A DEVICE ON THE SERIAL BUS TO RECEIVE DATA. THE; ACCUMULATOR MUST BE LOADED WITH A DEVICE NUMBER BETWEEN 4 AND 31 BEFORE CALLING; THIS ROUTINE. LISTEN CONVERT THIS TO A LISTEN ADDRESS THEN TRANSMIT THIS DATA AS; A COMMAND ON THE SERIAL BUS. THE SPECIFIED DEVICE WILL THEN GO INTO LISTEN MODE; AND BE READY TO ACCEPT INFORMATION.;XXFFB1     JMP     XXEE17          ; COMMAND DEVICES ON THE SERIAL BUS TO LISTEN;***********************************************************************************;;; COMMAND A SERIAL BUS DEVICE TO TALK; TO USE THIS ROUTINE THE ACCUMULATOR MUST FIRST BE LOADED WITH A DEVICE NUMBER; BETWEEN 4 AND 30. WHEN CALLED THIS ROUTINE CONVERTS THIS DEVICE NUMBER TO A TALK; ADDRESS. THEN THIS DATA IS TRANSMITTED AS A COMMAND ON THE SERIAL BUS.;XXFFB4     JMP     XXEE14          ; COMMAND SERIAL BUS DEVICE TO TALK;***********************************************************************************;;; READ I/O STATUS WORD; THIS ROUTINE RETURNS THE CURRENT STATUS OF THE I/O DEVICE IN THE ACCUMULATOR. THE; ROUTINE IS USUALLY CALLED AFTER NEW COMMUNICATION TO AN I/O DEVICE. THE ROUTINE; WILL GIVE INFORMATION ABOUT DEVICE STATUS, OR ERRORS THAT HAVE OCCURRED DURING THE; I/O OPERATION.XXFFB7 = *     JMP     XXFE57          ; READ I/O STATUS WORD;***********************************************************************************;;; SET LOGICAL, FIRST AND SECOND ADDRESSES; THIS ROUTINE WILL SET THE LOGICAL FILE NUMBER, DEVICE ADDRESS, AND SECONDARY; ADDRESS, COMMAND NUMBER, FOR OTHER KERNAL ROUTINES.; THE LOGICAL FILE NUMBER IS USED BY THE SYSTEM AS A KEY TO THE FILE TABLE CREATED; BY THE OPEN FILE ROUTINE. DEVICE ADDRESSES CAN RANGE FROM 0 TO 30. THE FOLLOWING; CODES ARE USED BY THE COMPUTER TO STAND FOR THE FOLLOWING CBM DEVICES:; ADDRESS     DEVICE; =======     ======;  0          KEYBOARD;  1          CASSETTE #1;  2          RS-232C DEVICE;  3          CRT DISPLAY;  4          SERIAL BUS PRINTER;  8          CBM SERIAL BUS DISK DRIVE; DEVICE NUMBERS OF FOUR OR GREATER AUTOMATICALLY REFER TO DEVICES ON THE SERIAL; BUS.; A COMMAND TO THE DEVICE IS SENT AS A SECONDARY ADDRESS ON THE SERIAL BUS AFTER; THE DEVICE NUMBER IS SENT DURING THE SERIAL ATTENTION HANDSHAKING SEQUENCE. IF; NO SECONDARY ADDRESS IS TO BE SENT Y SHOULD BE SET TO $FF.XXFFBA = *     JMP     XXFE50          ; SET LOGICAL, FIRST AND SECOND ADDRESSES;***********************************************************************************;;; SET THE FILENAME; THIS ROUTINE IS USED TO SET UP THE FILE NAME FOR THE OPEN, SAVE, OR LOAD ROUTINES.; THE ACCUMULATOR MUST BE LOADED WITH THE LENGTH OF THE FILE AND XY WITH THE POINTER; TO FILE NAME, X BEING TH LOW BYTE. THE ADDRESS CAN BE ANY VALID MEMORY ADDRESS IN; THE SYSTEM WHERE A STRING OF CHARACTERS FOR THE FILE NAME IS STORED. IF NO FILE; NAME DESIRED THE ACCUMULATOR MUST BE SET TO 0, REPRESENTING A ZERO FILE LENGTH,; IN THAT CASE  XY MAY BE SET TO ANY MEMORY ADDRESS.XXFFBD = *     JMP     XXFE49          ; SET FILENAME;***********************************************************************************;;; OPEN A LOGICAL FILE; THIS ROUTINE IS USED TO OPEN A LOGICAL FILE. ONCE THE LOGICAL FILE IS SET UP IT; CAN BE USED FOR INPUT/OUTPUT OPERATIONS. MOST OF THE I/O KERNAL ROUTINES CALL ON; THIS ROUTINE TO CREATE THE LOGICAL FILES TO OPERATE ON. NO ARGUMENTS NEED TO BE; SET UP TO USE THIS ROUTINE, BUT BOTH THE SETLFS, XXFFBA, AND SETNAM, XXFFBD,; KERNAL ROUTINES MUST BE CALLED BEFORE USING THIS ROUTINE.XXFFC0 = *     JMP     (XX031A)          ; DO OPEN FILE VECTOR;***********************************************************************************;;; CLOSE A SPECIFIED LOGICAL FILE; THIS ROUTINE IS USED TO CLOSE A LOGICAL FILE AFTER ALL I/O OPERATIONS HAVE BEEN; COMPLETED ON THAT FILE. THIS ROUTINE IS CALLED AFTER THE ACCUMULATOR IS LOADED; WITH THE LOGICAL FILE NUMBER TO BE CLOSED, THE SAME NUMBER USED WHEN THE FILE WAS; OPENED USING THE OPEN ROUTINE.XXFFC3 = *     JMP     (XX031C)          ; DO CLOSE FILE VECTOR;************************************************************************************;; OPEN A CHANNEL FOR INPUT; ANY LOGICAL FILE THAT HAS ALREADY BEEN OPENED BY THE OPEN ROUTINE, XXFFC0, CAN BE; DEFINED AS AN INPUT CHANNEL BY THIS ROUTINE. THE DEVICE ON THE CHANNEL MUST BE AN; INPUT DEVICE OR AN ERROR WILL OCCUR AND THE ROUTINE WILL ABORT.; IF YOU ARE GETTING DATA FROM ANYWHERE OTHER THAN THE KEYBOARD, THIS ROUTINE MUST BE; CALLED BEFORE USING EITHER THE CHRIN ROUTINE, XXFFCF, OR THE GETIN ROUTINE,; XXFFE4. IF YOU ARE GETTING DATA FROM THE KEYBOARD AND NO OTHER INPUT CHANNELS ARE; OPEN THEN THE CALLS TO THIS ROUTINE AND TO THE OPEN ROUTINE, XXFFC0, ARE NOT NEEDED.; WHEN USED WITH A DEVICE ON THE SERIAL BUS THIS ROUTINE WILL AUTOMATICALLY SEND THE; LISTEN ADDRESS SPECIFIED BY THE OPEN ROUTINE, XXFFC0, AND ANY SECONDARY ADDRESS.; POSSIBLE ERRORS ARE:;;     3 : FILE NOT OPEN;     5 : DEVICE NOT PRESENT;     6 : FILE IS NOT AN INPUT FILEXXFFC6 = *     JMP     (XX031E)          ; DO OPEN FOR INPUT VECTOR;************************************************************************************;; OPEN A CHANNEL FOR OUTPUT; ANY LOGICAL FILE THAT HAS ALREADY BEEN OPENED BY THE OPEN ROUTINE, XXFFC0, CAN BE; DEFINED AS AN OUTPUT CHANNEL BY THIS ROUTINE THE DEVICE ON THE CHANNEL MUST BE AN; OUTPUT DEVICE OR AN ERROR WILL OCCUR AND THE ROUTINE WILL ABORT.; IF YOU ARE SENDING DATA TO ANYWHERE OTHER THAN THE SCREEN THIS ROUTINE MUST BE; CALLED BEFORE USING THE CHROUT ROUTINE, XXFFD2. IF YOU ARE SENDING DATA TO THE; SCREEN AND NO OTHER OUTPUT CHANNELS ARE OPEN THEN THE CALLS TO THIS ROUTINE AND TO; THE OPEN ROUTINE, XXFFC0, ARE NOT NEEDED.; WHEN USED WITH A DEVICE ON THE SERIAL BUS THIS ROUTINE WILL AUTOMATICALLY SEND THE; LISTEN ADDRESS SPECIFIED BY THE OPEN ROUTINE, XXFFC0, AND ANY SECONDARY ADDRESS.; POSSIBLE ERRORS ARE:;;     3 : FILE NOT OPEN;     5 : DEVICE NOT PRESENT;     7 : FILE IS NOT AN OUTPUT FILEXXFFC9 = *     JMP     (XX0320)          ; DO OPEN FOR OUTPUT VECTOR;************************************************************************************;; CLOSE INPUT AND OUTPUT CHANNELS; THIS ROUTINE IS CALLED TO CLEAR ALL OPEN CHANNELS AND RESTORE THE I/O CHANNELS TO; THEIR ORIGINAL DEFAULT VALUES. IT IS USUALLY CALLED AFTER OPENING OTHER I/O; CHANNELS AND USING THEM FOR INPUT/OUTPUT OPERATIONS. THE DEFAULT INPUT DEVICE IS; 0, THE KEYBOARD. THE DEFAULT OUTPUT DEVICE IS 3, THE SCREEN.; IF ONE OF THE CHANNELS TO BE CLOSED IS TO THE SERIAL PORT, AN UNTALK SIGNAL IS SENT; FIRST TO CLEAR THE INPUT CHANNEL OR AN UNLISTEN IS SENT TO CLEAR THE OUTPUT CHANNEL.; BY NOT CALLING THIS ROUTINE AND LEAVING LISTENER(S) ACTIVE ON THE SERIAL BUS,; SEVERAL DEVICES CAN RECEIVE THE SAME DATA FROM THE VIC AT THE SAME TIME. ONE WAY TO; TAKE ADVANTAGE OF THIS WOULD BE TO COMMAND THE PRINTER TO TALK AND THE DISK TO; LISTEN. THIS WOULD ALLOW DIRECT PRINTING OF A DISK FILE.XXFFCC = *     JMP     (XX0322)          ; DO CLOSE VECTOR;************************************************************************************;; INPUT CHARACTER FROM CHANNEL; THIS ROUTINE WILL GET A BYTE OF DATA FROM THE CHANNEL ALREADY SET UP AS THE INPUT; CHANNEL BY THE CHKIN ROUTINE, XXFFC6.; IF CHKIN, XXFFC6, HAS NOT BEEN USED TO DEFINE ANOTHER INPUT CHANNEL THE DATA IS; EXPECTED TO BE FROM THE KEYBOARD. THE DATA BYTE IS RETURNED IN THE ACCUMULATOR. THE; CHANNEL REMAINS OPEN AFTER THE CALL.; INPUT FROM THE KEYBOARD IS HANDLED IN A SPECIAL WAY. FIRST, THE CURSOR IS TURNED ON; AND IT WILL BLINK UNTIL A CARRIAGE RETURN IS TYPED ON THE KEYBOARD. ALL CHARACTERS; ON THE LOGICAL LINE, UP TO 88 CHARACTERS, WILL BE STORED IN THE BASIC INPUT BUFFER.; THEN THE CHARACTERS CAN BE RETURNED ONE AT A TIME BY CALLING THIS ROUTINE ONCE FOR; EACH CHARACTER. WHEN THE CARRIAGE RETURN IS RETURNED THE ENTIRE LINE HAS BEEN; PROCESSED. THE NEXT TIME THIS ROUTINE IS CALLED THE WHOLE PROCESS BEGINS AGAIN.XXFFCF = *     JMP     (XX0324)          ; DO INPUT VECTOR;************************************************************************************;; OUTPUT A CHARACTER TO CHANNEL; THIS ROUTINE WILL OUTPUT A CHARACTER TO AN ALREADY OPENED CHANNEL. USE THE OPEN; ROUTINE, XXFFC0, AND THE CHKOUT ROUTINE, XXFFC9, TO SET UP THE OUTPUT CHANNEL; BEFORE CALLING THIS ROUTINE. IF THESE CALLS ARE OMITTED, DATA WILL BE SENT TO THE; DEFAULT OUTPUT DEVICE, DEVICE 3, THE SCREEN. THE DATA BYTE TO BE OUTPUT IS LOADED; INTO THE ACCUMULATOR, AND THIS ROUTINE IS CALLED. THE DATA IS THEN SENT TO THE; SPECIFIED OUTPUT DEVICE. THE CHANNEL IS LEFT OPEN AFTER THE CALL.; NOTE: CARE MUST BE TAKEN WHEN USING ROUTINE TO SEND DATA TO A SERIAL DEVICE SINCE; DATA WILL BE SENT TO ALL OPEN OUTPUT CHANNELS ON THE BUS. UNLESS THIS IS DESIRED,; ALL OPEN OUTPUT CHANNELS ON THE SERIAL BUS OTHER THAN THE ACTUALLY INTENDED; DESTINATION CHANNEL MUST BE CLOSED BY A CALL TO THE KERNAL CLOSE CHANNEL ROUTINE.XXFFD2 = *     JMP     (XX0326)          ; DO OUTPUT VECTOR;***********************************************************************************;;; LOAD RAM FROM A DEVICE; THIS ROUTINE WILL LOAD DATA BYTES FROM ANY INPUT DEVICE DIRECTLY INTO THE MEMORY; OF THE COMPUTER. IT CAN ALSO BE USED FOR A VERIFY OPERATION COMPARING DATA FROM A; DEVICE WITH THE DATA ALREADY IN MEMORY, LEAVING THE DATA STORED IN RAM UNCHANGED.; THE ACCUMULATOR MUST BE SET TO 0 FOR A LOAD OPERATION OR 1 FOR A VERIFY. IF THE; INPUT DEVICE WAS OPENED WITH A SECONDARY ADDRESS OF 0 THE HEADER INFORMATION FROM; DEVICE WILL BE IGNORED. IN THIS CASE XY MUST CONTAIN THE STARTING ADDRESS FOR THE; LOAD. IF THE DEVICE WAS ADDRESSED WITH A SECONDARY ADDRESS OF 1 OR 2 THE DATA WILL; LOAD INTO MEMORY STARTING AT THE LOCATION SPECIFIED BY THE HEADER. THIS ROUTINE; RETURNS THE ADDRESS OF THE HIGHEST RAM LOCATION WHICH WAS LOADED.; BEFORE THIS ROUTINE CAN BE CALLED, THE SETLFS, XXFFBA, AND SETNAM, XXFFBD,; ROUTINES MUST BE CALLED.XXFFD5 = *     JMP     XXF542          ; LOAD RAM FROM A DEVICE;***********************************************************************************;;; SAVE RAM TO A DEVICE; THIS ROUTINE SAVES A SECTION OF MEMORY. MEMORY IS SAVED FROM AN INDIRECT ADDRESS; ON PAGE 0 SPECIFIED BY A, TO THE ADDRESS STORED IN XY, TO A LOGICAL FILE. THE; SETLFS, XXFFBA, AND SETNAM, XXFFBD, ROUTINES MUST BE USED BEFORE CALLING THIS; ROUTINE. HOWEVER, A FILE NAME IS NOT REQUIRED TO SAVE TO DEVICE 1, THE CASSETTE.; ANY ATTEMPT TO SAVE TO OTHER DEVICES WITHOUT USING A FILE NAME RESULTS IN AN ERROR.; NOTE: DEVICE 0, THE KEYBOARD, AND DEVICE 3, THE SCREEN, CANNOT BE SAVED TO. IF; THE ATTEMPT IS MADE, AN ERROR WILL OCCUR, AND THE SAVE STOPPED.XXFFD8 = *     JMP     XXF675          ; SAVE RAM TO DEVICE;***********************************************************************************;;; SET THE REAL TIME CLOCK; THE SYSTEM CLOCK IS MAINTAINED BY AN INTERRUPT ROUTINE THAT UPDATES THE CLOCK; EVERY 1/60TH OF A SECOND. THE CLOCK IS THREE BYTES LONG WHICH GIVES THE CAPABILITY; TO COUNT FROM ZERO UP TO 5,184,000 JIFFIES - 24 HOURS PLUS ONE JIFFY. AT THAT POINT; THE CLOCK RESETS TO ZERO. BEFORE CALLING THIS ROUTINE TO SET THE CLOCK THE NEW TIME,; IN JIFFIES, SHOULD BE IN YXA, THE ACCUMULATOR CONTAINING THE MOST SIGNIFICANT BYTE.XXFFDB = *     JMP     XXF767          ; SET REAL TIME CLOCK;***********************************************************************************;;; READ THE REAL TIME CLOCK; THIS ROUTINE RETURNS THE TIME, IN JIFFIES, IN AXY. THE ACCUMULATOR CONTAINS THE; MOST SIGNIFICANT BYTE.XXFFDE = *     JMP     XXF760          ; READ REAL TIME CLOCK;***********************************************************************************;;; SCAN THE STOP KEY; IF THE STOP KEY ON THE KEYBOARD IS PRESSED WHEN THIS ROUTINE IS CALLED THE Z FLAG; WILL BE SET. ALL OTHER FLAGS REMAIN UNCHANGED. IF THE STOP KEY IS NOT PRESSED THEN; THE ACCUMULATOR WILL CONTAIN A BYTE REPRESENTING THE LAST ROW OF THE KEYBOARD SCAN.; THE USER CAN ALSO CHECK FOR CERTAIN OTHER KEYS THIS WAY.XXFFE1 = *     JMP     (XX0328)          ; DO STOP KEY VECTOR;***********************************************************************************;;; GET A CHARACTER FROM AN INPUT DEVICE; IN PRACTICE THIS ROUTINE OPERATES IDENTICALLY TO THE CHRIN ROUTINE, XXFFCF,; FOR ALL DEVICES EXCEPT FOR THE KEYBOARD. IF THE KEYBOARD IS THE CURRENT INPUT; DEVICE THIS ROUTINE WILL GET ONE CHARACTER FROM THE KEYBOARD BUFFER. IT DEPENDS; ON THE IRQ ROUTINE TO READ THE KEYBOARD AND PUT CHARACTERS INTO THE BUFFER.; IF THE KEYBOARD BUFFER IS EMPTY THE VALUE RETURNED IN THE ACCUMULATOR WILL BE ZEROXXFFE4 = *     JMP     (XX032A)          ; DO GET VECTOR;***********************************************************************************;;; CLOSE ALL CHANNELS AND FILES; THIS ROUTINE CLOSES ALL OPEN FILES. WHEN THIS ROUTINE IS CALLED, THE POINTERS INTO; THE OPEN FILE TABLE ARE RESET, CLOSING ALL FILES. ALSO THE ROUTINE AUTOMATICALLY; RESETS THE I/O CHANNELS.XXFFE7 = *     JMP     (XX032C)          ; DO CLOSE ALL VECTOR;***********************************************************************************;;; INCREMENT THE REAL TIME CLOCK; THIS ROUTINE UPDATES THE SYSTEM CLOCK. NORMALLY THIS ROUTINE IS CALLED BY THE; NORMAL KERNAL INTERRUPT ROUTINE EVERY 1/60TH OF A SECOND. IF THE USER PROGRAM; PROCESSES ITS OWN INTERRUPTS THIS ROUTINE MUST BE CALLED TO UPDATE THE TIME. ALSO,; THE STOP KEY ROUTINE MUST BE CALLED IF THE STOP KEY IS TO REMAIN FUNCTIONAL.XXFFEA = *     JMP     XXF734          ; INCREMENT REAL TIME CLOCK;***********************************************************************************;;; RETURN X,Y ORGANIZATION OF SCREEN; THIS ROUTINE RETURNS THE X,Y ORGANISATION OF THE SCREEN IN X,Y;XXFFED     JMP     XXE505          ; RETURN X,Y ORGANIZATION OF SCREEN;***********************************************************************************;;; READ/SET X,Y CURSOR POSITION; THIS ROUTINE, WHEN CALLED WITH THE CARRY FLAG SET, LOADS THE CURRENT POSITION OF; THE CURSOR ON THE SCREEN INTO THE X AND Y REGISTERS. X IS THE COLUMN NUMBER OF; THE CURSOR LOCATION AND Y IS THE ROW NUMBER OF THE CURSOR. A CALL WITH THE CARRY; BIT CLEAR MOVES THE CURSOR TO THE POSITION DETERMINED BY THE X AND Y REGISTERS.XXFFF0 = *     JMP     XXE50A          ; READ/SET X,Y CURSOR POSITION;***********************************************************************************;;; RETURN THE BASE ADDRESS OF THE I/O DEVICES; THIS ROUTINE WILL SET XY TO THE ADDRESS OF THE MEMORY SECTION WHERE THE MEMORY; MAPPED I/O DEVICES ARE LOCATED. THIS ADDRESS CAN THEN BE USED WITH AN OFFSET TO; ACCESS THE MEMORY MAPPED I/O DEVICES IN THE COMPUTER.XXFFF3 = *     JMP     XXE500          ; RETURN BASE ADDRESS OF I/O DEVICES;***********************************************************************************;;; SPARE BYTES, NOT REFERENCED     .BYTE     $FF,$FF,$FF,$FF;***********************************************************************************;;; HARDWARE VECTORS     .WORD     XXFEA9          ; NMI VECTOR     .WORD     XXFD22          ; RESET VECTOR     .WORD     XXFF72          ; IRQ VECTOR     .END;***********************************************************************************;;***********************************************************************************;