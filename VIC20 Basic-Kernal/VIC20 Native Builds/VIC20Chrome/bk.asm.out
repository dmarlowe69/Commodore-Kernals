
BK.ASM......PAGE 0001

LINE# LOC   CODE        LINE


00001  0000              ;************************************************
***********************************;
00002  0000              ;************************************************
***********************************;
00003  0000              ;
00004  0000              ; THE ALMOST COMPLETELY COMMENTED VIC 20 ROM DISA
SSEMBLY. V1.01 LEE DAVISON 2005-2012.
00005  0000              
00006  0000              ; THIS IS A BIT CORRECT ASSEMBLY LISTING FOR THE 
VIC 20 BASIC AND KERNAL ROMS AS ONE 16K
00007  0000              ; ROM. YOU SHOULD BE ABLE TO ASSEMBLE THE VIC ROM
S FROM THIS WITH MOST 6502 ASSEMBLERS,
00008  0000              ; AS NO MACROS OR 'SPECIAL' FEATURES WERE USED. T
HIS HAS BEEN TESTED USING MICHAL
00009  0000              ; KOWALSKI'S 6502 SIMULATOR ASSEMBLE FUNCTION. SE
E HTTP://EXIFPRO.COM/UTILS.HTML FOR
00010  0000              ; THIS PROGRAM.
00011  0000              
00012  0000              ; MANY REFERENCES WERE USED TO COMPLETE THIS DISA
SSEMBLY INCLUDING, BUT NOT LIMITED TO,
00013  0000              ; 'MAPPING THE VIC 20', 'MAPPING THE C64', 'VIC 2
0 PROGRAMMERS REFERENCE', 'VIC 20 USER
00014  0000              ; GUIDE', 'THE COMPLETE COMMODORE INNER SPACE ANT
HOLOGY', 'VIC REVEALED' AND VARIOUS
00015  0000              ; TEXT FILES, PICTURES AND OTHER DOCUMENTS.
00016  0000              
00017  0000              
00018  0000              ;************************************************
***********************************;
00019  0000              ;************************************************
***********************************;
00020  0000              ;
00021  0000              ; FIRST A WHOLE LOAD OF EQUATES
00022  0000              
00023  0000              ; THESE LOCATIONS CONTAIN THE JMP INSTRUCTION TAR
GET ADDRESS OF THE USR COMMAND. THEY
00024  0000              ; ARE INITIALISED SO THAT IF YOU TRY TO EXECUTE A
 USR CALL WITHOUT CHANGING THEM YOU
00025  0000              ; WIL RECEIVE AN ILLEGAL QUANTITY ERROR MESSAGE.
00026  0000              
00027  0000              XX00   = $00           ; USR() JMP INSTRUCTION
00028  0000              XX01   = $01           ; USR() VECTOR LOW BYTE
00029  0000              XX02   = $02           ; USR() VECTOR HIGH BYTE
00030  0000              X
00031  0000              ; THIS VECTOR POINTS TO THE ADDRESS OF THE BASIC 
ROUTINE WHICH CONVERTS A FLOATING POINT
00032  0000              ; NUMBER TO AN INTEGER, HOWEVER BASIC DOES NOT US
E THIS VECTOR. IT MAY BE OF ASSISTANCE
00033  0000              ; TO THE PROGRAMMER WHO WISHES TO USE DATA THAT I
S STORED IN FLOATING POINT FORMAT. THE
00034  0000              ; PARAMETER PASSED BY THE USR COMMAND IS AVAILABL
E ONLY IN THAT FORMAT FOR EXAMPLE.
00035  0000              
00036  0000              XX03   = $03           ; FLOAT TO FIXED VECTOR LO
W BYTE
00037  0000              XX04   = $04           ; FLOAT TO FIXED VECTOR HI
GH BYTE
00038  0000              X
00039  0000              ; THIS VECTOR POINTS TO THE ADDRESS OF THE BASIC 
ROUTINE WHICH CONVERTS AN INTEGER TO A
00040  0000              ; FLOATING POINT NUMBER, HOWEVER BASIC DOES NOT U
SE THIS VECTOR. IT MAY BE USED BY THE
00041  0000              ; PROGRAMMER WHO NEEDS TO MAKE SUCH A CONVERSION 
FOR A MACHINE LANGUAGE PROGRAM THAT
00042  0000              ; INTERACTS WITH BASIC.  TO RETURN AN INTEGER VAL
UE WITH THE USR COMMAND FOR EXAMPLE.
00043  0000              
00044  0000              XX05   = $05           ; FIXED TO FLOAT VECTOR LO
W BYTE
00045  0000              XX06   = $06           ; FIXED TO FLOAT VECTOR HI
GH BYTE
00046  0000              X
00047  0000              ; THE CURSOR COLUMN POSITION PRIOR TO THE TAB OR 
SPC IS MOVED HERE FROM $D3, AND IS USED
00048  0000              ; TO CALCULATE WHERE THE CURSOR ENDS UP AFTER ONE
 OF THESE FUNCTIONS IS INVOKED.
00049  0000              
00050  0000              ; NOTE THAT THE VALUE CONTAINED HERE SHOWS THE PO
SITION OF THE CURSOR ON A LOGICAL LINE.
00051  0000              ; SINCE ONE LOGICAL LINE CAN BE UP TO FOUR PHYSIC
AL LINES LONG, THE VALUE STORED HERE
00052  0000              ; CAN RANGE FROM 0 TO 87.
00053  0000              
00054  0000              XX07   = $07           ; SEARCH CHARACTER
00055  0000              XX08   = $08           ; SCAN QUOTES FLAG






 HEREN......PAGE 0002

LINE# LOC   CODE        LINE


00056  0000              XX09   = $09           ; TAB COLUMN SAVE
00057  0000              X
00058  0000              ; THE ROUTINE THAT CONVERTS THE TEXT IN THE INPUT
 BUFFER INTO LINES OF EXECUTABLE PROGRAM
00059  0000              ; TOKES, AND THE ROUTINES THAT LINK THESE PROGRAM
 LINES TOGETHER, USE THIS LOCATION AS AN
00060  0000              ; INDEX INTO THE INPUT BUFFER AREA. AFTER THE JOB
 OF CONVERTING TEXT TO TOKENS IS DONE,
00061  0000              ; THE VALUE IN THIS LOCATION IS EQUAL TO THE LENG
TH OF THE TOKENIZED LINE.
00062  0000              
00063  0000              ; THE ROUTINES WHICH BUILD AN ARRAY OR LOCATE AN 
ELEMENT IN AN ARRAY USE THIS LOCATION TO
00064  0000              ; CALCULATE THE NUMBER OF DIMENSIONS CALLED FOR A
ND THE AMOUNT OF STORAGE REQUIRED FOR A
00065  0000              ; NEWLY CREATED ARRAY, OR THE NUMBER OF SUBSCRIPT
S WHEN REFERENCING AN ARRAY ELEMENT.
00066  0000              
00067  0000              XX0A   = $0A           ; LOAD/VERIFY FLAG, 0 = LO
AD, 1 = VERIFY
00068  0000              XX0B   = $0B           ; TEMPORARY BYTE, LINE CRU
NCH/ARRAY ACCESS/LOGIC OPERATORS
00069  0000              X
00070  0000              ; THIS IS USED AS A FLAG BY THE ROUTINES THAT BUI
LD AN ARRAY OR REFERENCE AN EXISTING
00071  0000              ; ARRAY. IT IS USED TO DETERMINE WHETHER A VARIAB
LE IS IN AN ARRAY, WHETHER THE ARRAY
00072  0000              ; HAS ALREADY BEEN DIMENSIONED, AND WHETHER A NEW
 ARRAY SHOULD ASSUME THE DEFAULT SIZE.
00073  0000              
00074  0000              XX0C   = $0C           ; DIM FLAG
00075  0000              X
00076  0000              ; THIS FLAG IS USED TO INDICATE WHETHER DATA BEIN
G OPERATED UPON IS STRING OR NUMERIC. A
00077  0000              ; VALUE OF $FF IN THIS LOCATION INDICATES STRING 
DATA WHILE A $00 INDICATES NUMERIC DATA.
00078  0000              
00079  0000              XX0D   = $0D           ; DATA TYPE FLAG, $FF = ST
RING, $00 = NUMERIC
00080  0000              X
00081  0000              ; IF THE ABOVE FLAG INDICATES NUMERIC THEN A $80 
IN THIS LOCATION IDENTIFIES THE NUMBER
00082  0000              ; AS AN INTEGER, AND A $00 INDICATES A FLOATING P
OINT NUMBER.
00083  0000              
00084  0000              XX0E   = $0E           ; DATA TYPE FLAG, $80 = IN
TEGER, $00 = FLOATING POINT
00085  0000              X
00086  0000              ; THE GARBAGE COLLECTION ROUTINE USES THIS LOCATI
ON AS A FLAG TO INDICATE THAT GARBAGE
00087  0000              ; COLLECTION HAS ALREADY BEEN TRIED BEFORE ADDING
 A NEW STRING. IF THERE IS STILL NOT
00088  0000              ; ENOUGH MEMORY, AN OUT OF MEMORY ERROR MESSAGE W
ILL RESULT.
00089  0000              
00090  0000              ; LIST USES THIS BYTE AS A FLAG TO LET IT KNOW WH
EN IT HAS COME TO A CHARACTER STRING IN
00091  0000              ; QUOTES. IT WILL THEN PRINT THE STRING,RATHER TH
AN SEARCH IT FOR BASIC KEYWORD TOKENS.
00092  0000              
00093  0000              ; THIS LOCATION IS ALSO USED DURING THE PROCESS O
F CONVERTING A LINE OF TEXT IN THE BASIC
00094  0000              ; INPUT BUFFER INTO A LINKED PROGRAM LINE OF BASI
C KEYWORD TOKENS TO FLAG A DATA LINE IS
00095  0000              ; BEING PROCESSED.
00096  0000              
00097  0000              XX0F   = $0F           ; GARBAGE COLLECTED/OPEN Q
UOTE/DATA FLAG
00098  0000              X
00099  0000              ; IF AN OPENING PARENTHESIS IS FOUND, THIS FLAG I
S SET TO INDICATE THAT THE VARIABLE IN
00100  0000              ; QUESTION IS EITHER AN ARRAY VARIABLE OR A USER-
DEFINED FUNCTION.
00101  0000              
00102  0000              XX10   = $10           ; SUBSCRIPT/FNX FLAG
00103  0000              X
00104  0000              ; THIS LOCATION IS USED TO DETERMINE WHETHER THE 
SIGN OF THE VALUE RETURNED BY THE
00105  0000              ; FUNCTIONS SIN, COS, ATN OR TAN IS POSITIVE OR N
EGATIVE.
00106  0000              
00107  0000              ; ALSO THE COMPARISON ROUTINES USE THIS LOCATION 
TO INDICATE THE OUTCOME OF THE COMPARE.
00108  0000              ; FOR A <=> B THE VALUE HERE WILL BE $01 IF A > B
, $02 IF A = B, AND $04 IF A < B. IF
00109  0000              ; MORE THAN ONE COMPARISON OPERATOR WAS USED TO C
OMPARE THE TWO VARIABLES THEN THE VALUE
00110  0000              ; HERE WILL BE A COMBINATION OF THE ABOVE VALUES.







HE VAL......PAGE 0003

LINE# LOC   CODE        LINE


00111  0000              
00112  0000              XX11   = $11           ; INPUT MODE FLAG, $00 = I
NPUT, $40 = GET, $98 = READ
00113  0000              XX12   = $12           ; ATN SIGN/COMPARISON EVAL
UATION FLAG
00114  0000              X
00115  0000              ; WHEN THE DEFAULT INPUT OR OUTPUT DEVICE IS USED
 THE VALUE HERE WILL BE A ZERO, AND THE
00116  0000              ; FORMAT OF PROMPTING AND OUTPUT WILL BE THE STAN
DARD SCREEN OUTPUT FORMAT. THE LOCATION
00117  0000              ; $B8 IS USED TO DECIDE WHAT DEVICE ACTUALLY TO P
UT INPUT FROM OR OUTPUT TO.
00118  0000              
00119  0000              ; THE PRINT CR/LF CODE AT XXCAD7 SUGGESTS THAT B7
 OF THIS BYTE IS AN AUTOLF FLAG BIT
00120  0000              ; BUT IF IT IS USED AS SUCH IT WOULD BREAK LOTS O
F OTHER PARTS OF THE CODE
00121  0000              
00122  0000              XX13   = $13           ; CURRENT I/O CHANNEL
00123  0000              X
00124  0000              ; USED WHENEVER A 16 BIT INTEGER IS USED E.G. THE
 TARGET LINE NUMBER FOR GOTO, LIST, ON,
00125  0000              ; AND GOSUB ALSO THE NUMBER OF A BASIC LINE THAT 
IS TO BE ADDED OR REPLACED. ADDITIONALLY
00126  0000              ; PEEK, POKE, WAIT, AND SYS USE THIS LOCATION AS 
A POINTER TO THE ADDRESS WHICH IS THE
00127  0000              ; SUBJECT OF THE COMMAND.
00128  0000              
00129  0000              XX14   = $14           ; TEMPORARY INTEGER LOW BY
TE
00130  0000              XX15   = $15           ; TEMPORARY INTEGER HIGH B
YTE
00131  0000              X
00132  0000              ; THIS LOCATION POINTS TO THE NEXT AVAILABLE SLOT
 IN THE TEMPORARY STRING DESCRIPTOR
00133  0000              ; STACK LOCATED AT $19-$21.
00134  0000              
00135  0000              XX16   = $16           ; DESCRIPTOR STACK POINTER
, NEXT FREE
00136  0000              X
00137  0000              ; THIS CONTAINS INFORMATION ABOUT TEMPORARY STRIN
GS WHICH HVE NOT YET BEEN ASSIGNED TO
00138  0000              ; A STRING VARIABLE.
00139  0000              
00140  0000              XX17   = $17           ; CURRENT DESCRIPTOR STACK
 ITEM POINTER LOW BYTE
00141  0000              XX18   = $18           ; CURRENT DESCRIPTOR STACK
 ITEM POINTER HIGH BYTE
00142  0000              XX19   = $19           ; TO $21, DESCRIPTOR STACK

00143  0000              X
00144  0000              ; THESE LOCATIONS ARE USED BY BASIC MULTIPLICATIO
N AND DIVISION ROUTINES. THEY ARE ALSO
00145  0000              ; USED BY THE ROUTINES WHICH COMPUTE THE SIZE OF 
THE AREA REQUIRED TO STORE AN ARRAY
00146  0000              ; WHICH IS BEING CREATED.
00147  0000              
00148  0000              XX22   = $22           ; MISC TEMP BYTE
00149  0000              XX23   = $23           ; MISC TEMP BYTE
00150  0000              XX24   = $24           ; MISC TEMP BYTE
00151  0000              XX25   = $25           ; MISC TEMP BYTE
00152  0000              X
00153  0000              XX26   = $26           ; TEMP MANTISSA 1
00154  0000              XX27   = $27           ; TEMP MANTISSA 2
00155  0000              XX28   = $28           ; TEMP MANTISSA 3
00156  0000              XX29   = $29           ; TEMP MANTISSA 4
00157  0000              X
00158  0000              ; TWO BYTE POINTER TO WHERE THE BASIC PROGRAM TEX
T IS STORED.
00159  0000              
00160  0000              XX2B   = $2B           ; START OF MEMORY LOW BYTE

00161  0000              XX2C   = $2C           ; START OF MEMORY HIGH BYT
E
00162  0000              X
00163  0000              ; TWO BYTE POINTER TO THE START OF THE BASIC VARI
ABLE STORAGE AREA.
00164  0000              
00165  0000              XX2D   = $2D           ; START OF VARIABLES LOW B
YTE






RRAYLS......PAGE 0004

LINE# LOC   CODE        LINE


00166  0000              XX2E   = $2E           ; START OF VARIABLES HIGH 
BYTE
00167  0000              X
00168  0000              ; TWO BYTE POINTER TO THE START OF THE BASIC ARRA
Y STORAGE AREA.
00169  0000              
00170  0000              XX2F   = $2F           ; END OF VARIABLES LOW BYT
E
00171  0000              XX30   = $30           ; END OF VARIABLES HIGH BY
TE
00172  0000              X
00173  0000              ; TWO BYTE POINTER TO END OF THE START OF FREE RA
M.
00174  0000              
00175  0000              XX31   = $31           ; END OF ARRAYS LOW BYTE
00176  0000              XX32   = $32           ; END OF ARRAYS HIGH BYTE
00177  0000              X
00178  0000              ; TWO BYTE POINTER TO THE BOTTOM OF THE STRING TE
XT STORAGE AREA.
00179  0000              
00180  0000              XX33   = $33           ; BOTTOM OF STRING SPACE L
OW BYTE
00181  0000              XX34   = $34           ; BOTTOM OF STRING SPACE H
IGH BYTE
00182  0000              X
00183  0000              ; USED AS A TEMPORARY POINTER TO THE MOST CURRENT
 STRING ADDED BY THE ROUTINES WHICH
00184  0000              ; BUILD STRINGS OR MOVE THEM IN MEMORY.
00185  0000              
00186  0000              XX35   = $35           ; STRING UTILITY PTR LOW B
YTE
00187  0000              XX36   = $36           ; STRING UTILITY PTR HIGH 
BYTE
00188  0000              X
00189  0000              ; TWO BYTE POINTER TO THE HIGHEST ADDRESS USED BY
 BASIC +1.
00190  0000              
00191  0000              XX37   = $37           ; END OF MEMORY LOW BYTE
00192  0000              XX38   = $38           ; END OF MEMORY HIGH BYTE
00193  0000              X
00194  0000              ; THESE LOCATIONS CONTAIN THE LINE NUMBER OF THE 
BASIC STATEMENT WHICH IS CURRENTLY BEING
00195  0000              ; EXECUTED. A VALUE OF $FF IN LOCATION $3A MEANS 
THAT BASIC IS IN IMMEDIATE MODE.
00196  0000              
00197  0000              XX39   = $39           ; CURRENT LINE NUMBER LOW 
BYTE
00198  0000              XX3A   = $3A           ; CURRENT LINE NUMBER HIGH
 BYTE
00199  0000              X
00200  0000              ; WHEN PROGRAM EXECUTION ENDS OR STOPS THE LAST L
INE NUMBER EXECUTED IS STORED HERE.
00201  0000              
00202  0000              XX3B   = $3B           ; BREAK LINE NUMBER LOW BY
TE
00203  0000              XX3C   = $3C           ; BREAK LINE NUMBER HIGH B
YTE
00204  0000              X
00205  0000              ; THESE LOCATIONS CONTAIN THE ADDRESS OF THE STAR
T OF THE TEXT OF THE BASIC STATEMENT
00206  0000              ; THAT IS BEING EXECUTED.  THE VALUE OF THE POINT
ER TO THE ADDRESS OF THE BASIC TEXT
00207  0000              ; CHARACTER CURRENTLY BEING SCANNED IS STORED HER
E EACH TIME A NEW BASIC STATEMENT BEGINS
00208  0000              ; EXECUTION.
00209  0000              
00210  0000              XX3D   = $3D           ; CONTINUE POINTER LOW BYT
E
00211  0000              XX3E   = $3E           ; CONTINUE POINTER HIGH BY
TE
00212  0000              X
00213  0000              ; THESE LOCATIONS HOLD THE LINE NUMBER OF THE CUR
RENT DATA STATEMENT BEING READ. IF AN
00214  0000              ; ERROR CONCERNING THE DATA OCCURS THIS NUMBER WI
LL BE MOVED TO $39/$3A SO THAT THE ERROR
00215  0000              ; MESSAGE WILL SHOW THE LINE THAT CONTAINS THE DA
TA STATEMENT RATHER THAN IN THE LINE THAT
00216  0000              ; CONTAINS THE READ STATEMENT.
00217  0000              
00218  0000              XX3F   = $3F           ; CURRENT DATA LINE NUMBER
 LOW BYTE
00219  0000              XX40   = $40           ; CURRENT DATA LINE NUMBER
 HIGH BYTE
00220  0000              X






STORE ......PAGE 0005

LINE# LOC   CODE        LINE


00221  0000              ; THESE LOCATIONS POINT TO THE ADDRESS WHERE THE 
NEXT DATA WILL BE READ FROM. RESTORE
00222  0000              ; SETS THIS POINTER BACK TO THE ADDRESS INDICATED
 BY THE START OF BASIC POINTER.
00223  0000              
00224  0000              XX41   = $41           ; DATA POINTER LOW BYTE
00225  0000              XX42   = $42           ; DATA POINTER HIGH BYTE
00226  0000              X
00227  0000              ; READ, INPUT AND GET ALL USE THIS AS A POINTER T
O THE ADDRESS OF THE SOURCE OF INCOMING
00228  0000              ; DATA, SUCH AS DATA STATEMENTS, OR THE TEXT INPU
T BUFFER.
00229  0000              
00230  0000              XX43   = $43           ; READ POINTER LOW BYTE
00231  0000              XX44   = $44           ; READ POINTER HIGH BYTE
00232  0000              X
00233  0000              XX45   = $45           ; CURRENT VARIABLE NAME FI
RST BYTE
00234  0000              XX46   = $46           ; CURRENT VARIABLE NAME SE
COND BYTE
00235  0000              X
00236  0000              ; THESE LOCATIONS POINT TO THE VALUE OF THE CURRE
NT BASIC VARIABLE SPECIFICALLY THEY
00237  0000              ; POINT TO THE BYTE JUST AFTER THE TWO-CHARACTER 
VARIABLE NAME.
00238  0000              
00239  0000              XX47   = $47           ; CURRENT VARIABLE ADDRESS
 LOW BYTE
00240  0000              XX48   = $48           ; CURRENT VARIABLE ADDRESS
 HIGH BYTE
00241  0000              X
00242  0000              ; THE ADDRESS OF THE BASIC VARIABLE WHICH IS THE 
SUBJECT OF A FOR/NEXT LOOP IS FIRST
00243  0000              ; STORED HERE BEFORE BEING PUSHED ONTO THE STACK.

00244  0000              
00245  0000              XX49   = $49           ; FOR/NEXT VARIABLE POINTE
R LOW BYTE
00246  0000              XX4A   = $4A           ; FOR/NEXT VARIABLE POINTE
R HIGH BYTE
00247  0000              X
00248  0000              ; THE EXPRESSION EVALUATION ROUTINE CREATES THIS 
TO LET IT KNOW WHETHER THE CURRENT
00249  0000              ; COMPARISON OPERATION IS A < $01, = $02 OR > $04
 COMPARISON OR COMBINATION.
00250  0000              
00251  0000              XX4B   = $4B           ; BASIC EXECUTE POINTER TE
MPORARY LOW BYTE/PRECEDENCE FLAG
00252  0000              XX4C   = $4C           ; BASIC EXECUTE POINTER TE
MPORARY HIGH BYTE
00253  0000              XX4D   = $4D           ; COMPARRISON EVALUATION F
LAG
00254  0000              X
00255  0000              ; THESE LOCATIONS ARE USED AS A POINTER TO THE FU
NCTION THAT IS CREATED DURING FUNCTION
00256  0000              ; DEFINITION . DURING FUNCTION EXECUTION IT POINT
S TO WHERE THE EVALUATION RESULTS SHOULD
00257  0000              ; BE SAVED.
00258  0000              
00259  0000              XX4E   = $4E           ; FAC TEMP STORE/FUNCTION/
VARIABLE/GARBAGE POINTER LOW BYTE
00260  0000              XX4F   = $4F           ; FAC TEMP STORE/FUNCTION/
VARIABLE/GARBAGE POINTER HIGH BYTE
00261  0000              X
00262  0000              ; TEMPORARY POINTER TO THE CURRENT STRING DESCRIP
TOR.
00263  0000              
00264  0000              XX50   = $50           ; FAC TEMP STORE/DESCRIPTO
R POINTER LOW BYTE
00265  0000              XX51   = $51           ; FAC TEMP STORE/DESCRIPTO
R POINTER HIGH BYTE
00266  0000              X
00267  0000              XX53   = $53           ; GARBAGE COLLECTION STEP 
SIZE
00268  0000              X
00269  0000              ; THE FIRST BYTE IS THE 6502 JMP INSTRUCTION $4C,
 FOLLOWED BY THE ADDRESS OF THE REQUIRED
00270  0000              ; FUNCTION TAKEN FROM THE TABLE AT $C052.
00271  0000              
00272  0000              XX54   = $54           ; JMP OPCODE FOR FUNCTIONS

00273  0000              XX55   = $55           ; FUNCTIONS JUMP VECTOR LO
W BYTE
00274  0000              XX56   = $56           ; FUNCTIONS JUMP VECTOR HI
GH BYTE
00275  0000              X






 REQUI......PAGE 0006

LINE# LOC   CODE        LINE


00276  0000              XX57   = $57           ; FAC TEMP STORE
00277  0000              XX58   = $58           ; FAC TEMP STORE
00278  0000              XX59   = $59           ; FAC TEMP STORE
00279  0000              XX5A   = $5A           ; FAC TEMP STORE
00280  0000              XX5B   = $5B           ; BLOCK END HIGH BYTE
00281  0000              XX5C   = $5C           ; FAC TEMP STORE
00282  0000              XX5D   = $5D           ; FAC TEMP STORE
00283  0000              XX5E   = $5E           ; FAC TEMP STORE
00284  0000              XX5F   = $5F           ; FAC TEMP STORE
00285  0000              XX60   = $60           ; BLOCK START HIGH BYTE
00286  0000              XX61   = $61           ; FAC1 EXPONENT
00287  0000              XX62   = $62           ; FAC1 MANTISSA 1
00288  0000              XX63   = $63           ; FAC1 MANTISSA 2
00289  0000              XX64   = $64           ; FAC1 MANTISSA 3
00290  0000              XX65   = $65           ; FAC1 MANTISSA 4
00291  0000              XX66   = $66           ; FAC1 SIGN
00292  0000              XX67   = $67           ; CONSTANT COUNT/-VE FLAG
00293  0000              XX68   = $68           ; FAC1 OVERFLOW
00294  0000              XX69   = $69           ; FAC2 EXPONENT
00295  0000              XX6A   = $6A           ; FAC2 MANTISSA 1
00296  0000              XX6B   = $6B           ; FAC2 MANTISSA 2
00297  0000              XX6C   = $6C           ; FAC2 MANTISSA 3
00298  0000              XX6D   = $6D           ; FAC2 MANTISSA 4
00299  0000              XX6E   = $6E           ; FAC2 SIGN
00300  0000              XX6F   = $6F           ; FAC SIGN COMPARRISON
00301  0000              XX70   = $70           ; FAC1 ROUNDING
00302  0000              XX71   = $71           ; TEMP BASIC EXECUTE/ARRAY
 POINTER LOW BYTE/INDEX
00303  0000              XX72   = $72           ; TEMP BASIC EXECUTE/ARRAY
 POINTER HIGH BYTE
00304  0000              X
00305  0000              XX0073 = $73           ; INCREMENT AND SCAN MEMOR
Y, BASIC BYTE GET
00306  0000              XX0079 = $79           ; SCAN MEMORY, BASIC BYTE 
GET
00307  0000              XX7A   = $7A           ; BASIC EXECUTE POINTER LO
W BYTE
00308  0000              XX7B   = $7B           ; BASIC EXECUTE POINTER HI
GH BYTE
00309  0000              XX80   = $80           ; NUMERIC TEST ENTRY
00310  0000              X
00311  0000              XX008B = $8B           ; RND() SEED, FIVE BYTES
00312  0000              X
00313  0000              XX90   = $90           ; SERIAL STATUS BYTE
00314  0000                                     ; FUNCTION
00315  0000                                     ; BIT CASETTE  SERIAL BUS
00316  0000                                     ; --- --------  ----------

00317  0000                                     ;  7 END OF TAPE  DEVICE N
OT PRESENT
00318  0000                                     ;  6 END OF FILE  EOI
00319  0000                                     ;  5 CHECKSUM ERROR
00320  0000                                     ;  4 READ ERROR
00321  0000                                     ;  3 LONG BLOCK
00322  0000                                     ;  2 SHORT BLOCK
00323  0000                                     ;  1    TIME OUT READ
00324  0000                                     ;  0    TIME OUT WRITE
00325  0000              XX91   = $91           ; KEYBOARD ROW, BX = 0 = K
EY DOWN
00326  0000                                     ; BIT KEY
00327  0000                                     ; --- ------
00328  0000                                     ;  7 [DOWN]
00329  0000                                     ;  6 /
00330  0000                                     ;  5 ,






 REQUI......PAGE 0007

LINE# LOC   CODE        LINE


00331  0000                                     ;  4 N
00332  0000                                     ;  3 V
00333  0000                                     ;  2 X
00334  0000                                     ;  1 [L SHIFT]
00335  0000                                     ;  0 [STOP]
00336  0000              XX92   = $92           ; TIMING CONSTANT FOR TAPE
 READ
00337  0000              XX93   = $93           ; LOAD/VERIFY FLAG, LOAD =
 $00, VERIFY = $01
00338  0000              XX94   = $94           ; SERIAL OUTPUT: DEFERRED 
CHARACTER FLAG
00339  0000                                     ; $00 = NO CHARACTER WAITI
NG, $XX = CHARACTER WAITING
00340  0000              XX95   = $95           ; SERIAL OUTPUT: DEFERRED 
CHARACTER
00341  0000                                     ; $FF = NO CHARACTER WAITI
NG, $XX = WAITING CHARACTER
00342  0000              XX96   = $96           ; CASSETTE BLOCK SYNCHRONI
ZATION NUMBER
00343  0000              XX97   = $97           ; REGISTER SAVE
00344  0000              X
00345  0000              ; THE NUMBER OF CURRENTLY OPEN I/O FILES IS STORE
D HERE. THE MAXIMUM NUMBER THAT CAN BE
00346  0000              ; OPEN AT ONE TIME IS TEN. THE NUMBER STORED HERE
 IS USED AS THE INDEX TO THE END OF THE
00347  0000              ; TABLES THAT HOLD THE FILE NUMBERS, DEVICE NUMBE
RS, AND SECONDARY ADDRESSES.
00348  0000              
00349  0000              XX98   = $98           ; OPEN FILE COUNT
00350  0000              X
00351  0000              ; THE DEFAULT VALUE OF THIS LOCATION IS 0.
00352  0000              
00353  0000              XX99   = $99           ; INPUT DEVICE NUMBER
00354  0000              X
00355  0000              ; THE DEFAULT VALUE OF THIS LOCATION IS 3.
00356  0000              
00357  0000              XX9A   = $9A           ; OUTPUT DEVICE NUMBER
00358  0000              ;
00359  0000              ; NUMBER DEVICE
00360  0000              ; ------ ------
00361  0000              ;  0  KEYBOARD
00362  0000              ;  1  CASSETTE
00363  0000              ;  2  RS-232C
00364  0000              ;  3  SCREEN
00365  0000              ;  4-31 SERIAL BUS
00366  0000              
00367  0000              XX9B   = $9B           ; TAPE CHARACTER PARITY
00368  0000              XX9C   = $9C           ; BYTE RECEIVED FLAG
00369  0000              XX9D   = $9D           ; MESSAGE MODE FLAG,
00370  0000              ; $C0 = BOTH CONTROL AND KERNAL MESSAGES,
00371  0000              ; $80 = CONTROL MESSAGES ONLY,
00372  0000              ; $40 = KERNAL MESSAGES ONLY,
00373  0000              ; $00 = NEITHER CONTROL OR KERNAL MESSAGES
00374  0000              XX9E   = $9E           ; TAPE PASS 1 ERROR LOG/CH
ARACTER BUFFER
00375  0000              XX9F   = $9F           ; TAPE PASS 2 ERROR LOG CO
RRECTED
00376  0000              X
00377  0000              ; THESE THREE LOCATIONS FORM A COUNTER WHICH IS U
PDATED 60 TIMES A SECOND, AND SERVES AS
00378  0000              ; A SOFTWARE CLOCK WHICH COUNTS THE NUMBER OF JIF
FIES THAT HAVE ELAPSED SINCE THE COMPUTER
00379  0000              ; WAS TURNED ON. AFTER 24 HOURS AND ONE JIFFY THE
SE LOCATIONS ARE SET BACK TO $000000.
00380  0000              
00381  0000              XXA0   = $A0           ; JIFFY CLOCK HIGH BYTE
00382  0000              XXA1   = $A1           ; JIFFY CLOCK MID BYTE
00383  0000              XXA2   = $A2           ; JIFFY CLOCK LOW BYTE
00384  0000              X
00385  0000              XXA3   = $A3           ; EOI FLAG BYTE/TAPE BIT C
OUNT






00000.......PAGE 0008

LINE# LOC   CODE        LINE


00386  0000              X
00387  0000              ; B0 OF THIS LOCATION REFLECTS THE CURRENT PHASE 
OF THE TAPE OUTPUT CYCLE.
00388  0000              
00389  0000              XXA4   = $A4           ; TAPE BIT CYCLE PHASE
00390  0000              XXA5   = $A5           ; CASSETTE SYNCHRONIZATION
 BYTE COUNT/SERIAL BUS BIT COUNT
00391  0000              XXA6   = $A6           ; TAPE BUFFER INDEX
00392  0000              XXA7   = $A7           ; RECEIVER INPUT BIT TEMP 
STORAGE
00393  0000              XXA8   = $A8           ; RECEIVER BIT COUNT IN
00394  0000              XXA9   = $A9           ; RECEIVER START BIT CHECK
 FLAG, $90 = NO START BIT
00395  0000              ; RECEIVED, $00 = START BIT RECEIVED
00396  0000              XXAA   = $AA           ; RECEIVER BYTE BUFFER/ASS
EMBLY LOCATION
00397  0000              XXAB   = $AB           ; RECEIVER PARITY BIT STOR
AGE
00398  0000              XXAC   = $AC           ; TAPE BUFFER START POINTE
R LOW BYTE
00399  0000              ; SCROLL SCREEN ?? BYTE
00400  0000              XXAD   = $AD           ; TAPE BUFFER START POINTE
R HIGH BYTE
00401  0000              ; SCROLL SCREEN ?? BYTE
00402  0000              XXAE   = $AE           ; TAPE BUFFER END POINTER 
LOW BYTE
00403  0000              ; SCROLL SCREEN ?? BYTE
00404  0000              XXAF   = $AF           ; TAPE BUFFER END POINTER 
HIGH BYTE
00405  0000              ; SCROLL SCREEN ?? BYTE
00406  0000              XXB0   = $B0           ; TAPE TIMING CONSTANT MIN
 BYTE
00407  0000              XXB1   = $B1           ; TAPE TIMING CONSTANT MAX
 BYTE
00408  0000              X
00409  0000              ; THESS TWO LOCATIONS POINT TO THE ADDRESS OF THE
 CASSETTE BUFFER. THIS POINTER MUST
00410  0000              ; BE GREATER THAN OR EQUAL TO $0200 OR AN ILLEGAL
 DEVICE NUMBER ERROR WILL BE SENT
00411  0000              ; WHEN TAPE I/O IS TRIED. THIS POINTER MUST ALSO 
BE LESS THAT $8000 OR THE ROUTINE
00412  0000              ; WILL TERMINATE EARLY.
00413  0000              
00414  0000              XXB2   = $B2           ; TAPE BUFFER START POINTE
R LOW BYTE
00415  0000              XXB3   = $B3           ; TAPE BUFFER START POINTE
R HIGH BYTE
00416  0000              X
00417  0000              ; RS232 ROUTINES USE THIS TO COUNT THE NUMBER OF 
BITS TRANSMITTED AND FOR PARITY AND
00418  0000              ; STOP BIT MANIPULATION. TAPE LOAD ROUTINES USE T
HIS LOCATION TO FLAG WHEN THEY ARE
00419  0000              ; READY TO RECEIVE DATA BYTES.
00420  0000              
00421  0000              XXB4   = $B4           ; TRANSMITTER BIT COUNT OU
T
00422  0000              X
00423  0000              ; THIS LOCATION IS USED BY THE RS232 ROUTINES TO 
HOLD THE NEXT BIT TO BE SENT AND BY THE
00424  0000              ; TAPE ROUTINES TO INDICATE WHAT PART OF A BLOCK 
THE READ ROUTINE IS CURRENTLY READING.
00425  0000              
00426  0000              XXB5   = $B5           ; TRANSMITTER NEXT BIT TO 
BE SENT
00427  0000              X
00428  0000              ; RS232 ROUTINES USE THIS AREA TO DISASSEMBLE EAC
H BYTE TO BE SENT FROM THE TRANSMISSION
00429  0000              ; BUFFER POINTED TO BY $F9.
00430  0000              
00431  0000              XXB6   = $B6           ; TRANSMITTER BYTE BUFFER/
DISASSEMBLY LOCATION
00432  0000              X
00433  0000              ; DISK FILENAMES MAY BE UP TO 16 CHARACTERS IN LE
NGTH WHILE TAPE FILENAMES BE UP TO 187
00434  0000              ; CHARACTERS IN LENGTH.
00435  0000              
00436  0000              ; IF A TAPE NAME IS LONGER THAN 16 CHARACTERS THE
 EXCESS WILL BE TRUNCATED BY THE
00437  0000              ; SEARCHING AND FOUND MESSAGES, BUT WILL STILL BE
 PRESENT ON THE TAPE.
00438  0000              
00439  0000              ; A DISK FILE IS ALWAYS REFERRED TO BY A NAME. TH
IS LOCATION WILL ALWAYS BE GREATER THAN
00440  0000              ; ZERO IF THE CURRENT FILE IS A DISK FILE.






TER TH......PAGE 0009

LINE# LOC   CODE        LINE


00441  0000              
00442  0000              ; AN RS232 OPEN COMMAND MAY SPECIFY A FILENAME OF
 UP TO FOUR CHARACTERS. THESE CHARACTERS
00443  0000              ; ARE COPIED TO LOCATIONS $293 TO $296 AND DETERM
INE BAUD RATE, WORD LENGTH, AND PARITY,
00444  0000              ; OR THEY WOULD DO IF THE FEATURE WAS FULLY IMPLE
MENTED.
00445  0000              
00446  0000              XXB7   = $B7           ; FILE NAME LENGTH
00447  0000              X
00448  0000              XXB8   = $B8           ; LOGICAL FILE
00449  0000              XXB9   = $B9           ; SECONDARY ADDRESS
00450  0000              XXBA   = $BA           ; CURRENT DEVICE NUMBER
00451  0000              ; NUMBER DEVICE
00452  0000              ; ------ ------
00453  0000              ;  0  KEYBOARD
00454  0000              ;  1  CASSETTE
00455  0000              ;  2  RS-232C
00456  0000              ;  3  SCREEN
00457  0000              ;  4-31 SERIAL BUS
00458  0000              XXBB   = $BB           ; FILE NAME POINTER LOW BY
TE
00459  0000              XXBC   = $BC           ; FILE NAME POINTER HIGH B
YTE
00460  0000              XXBD   = $BD           ; TAPE WRITE BYTE/RS232 PA
RITY BYTE
00461  0000              X
00462  0000              ; USED BY THE TAPE ROUTINES TO COUNT THE NUMBER O
F COPIES OF A DATA BLOCK REMAINING TO
00463  0000              ; BE READ OR WRITTEN.
00464  0000              
00465  0000              XXBE   = $BE           ; TAPE COPIES COUNT
00466  0000              XXBF   = $BF           ; PARITY COUNT ??
00467  0000              XXC0   = $C0           ; TAPE MOTOR INTERLOCK
00468  0000              XXC1   = $C1           ; I/O START ADDRESSES LOW 
BYTE
00469  0000              XXC2   = $C2           ; I/O START ADDRESSES HIGH
 BYTE
00470  0000              XXC3   = $C3           ; KERNAL SETUP POINTER LOW
 BYTE
00471  0000              XXC4   = $C4           ; KERNAL SETUP POINTER HIG
H BYTE
00472  0000              XXC5   = $C5           ; CURRENT KEY PRESSED
00473  0000              ;
00474  0000              ;  # KEY  # KEY  # KEY  # KEY
00475  0000              ; -- --- -- --- -- --- -- ---
00476  0000              ; 00 1 10 NONE 20 [SPACE] 30 Q
00477  0000              ; 01 3 11 A  21 Z  31 E
00478  0000              ; 02 5 12 D  22 C  32 T
00479  0000              ; 03 7 13 G  23 B  33 U
00480  0000              ; 04 9 14 J  24 M  34 O
00481  0000              ; 05 + 15 L  25 .  35 @
00482  0000              ; 06 [UKP] 16 ;  26 NONE 36 ^
00483  0000              ; 07 [DEL] 17 [CSR R] 27 [F1] 37 [F5]
00484  0000              ; 08 [<-] 18 [STOP] 28 NONE 38 2
00485  0000              ; 09 W 19 NONE 29 S  39 4
00486  0000              ; 0A R 1A X  2A F  3A 6
00487  0000              ; 0B Y 1B V  2B H  3B 8
00488  0000              ; 0C I 1C N  2C K  3C 0
00489  0000              ; 0D P 1D ,  2D :  3D -
00490  0000              ; 0E * 1E /  2E =  3E [HOME]
00491  0000              ; 0F [RET] 1F [CSR D] 2F [F3] 3F [F7]
00492  0000              
00493  0000              XXC6   = $C6           ; KEYBOARD BUFFER LENGTH/I
NDEX
00494  0000              X
00495  0000              ; WHEN THE [CTRL][RVS-ON] CHARACTERS ARE PRINTED 
THIS FLAG IS SET TO $12, AND THE PRINT






O THAT......PAGE 0010

LINE# LOC   CODE        LINE


00496  0000              ; ROUTINES WILL ADD $80 TO THE SCREEN CODE OF EAC
H CHARACTER WHICH IS PRINTED, SO THAT
00497  0000              ; THE CARACTER WILL APPEAR ON THE SCREEN WITH ITS
 COLOURS REVERSED.
00498  0000              
00499  0000              ; NOTE THAT THE CONTENTS OF THIS LOCATION ARE CLE
ARED NOT ONLY UPON ENTRY OF A
00500  0000              ; [CTRL][RVS-OFF] CHARACTER BUT ALSO AT EVERY CAR
RIAGE RETURN.
00501  0000              
00502  0000              XXC7   = $C7           ; REVERSE FLAG $12 = REVER
SE, $00 = NORMAL
00503  0000              X
00504  0000              ; THIS POINTER INDICATES THE COLUMN NUMBER OF THE
 LAST NONBLANK CHARACTER ON THE LOGICAL
00505  0000              ; LINE THAT IS TO BE INPUT. SINCE A LOGICAL LINE 
CAN BE UP TO 88 CHARACTERS LONG THIS
00506  0000              ; NUMBER CAN RANGE FROM 0-87.
00507  0000              
00508  0000              XXC8   = $C8           ; INPUT [EOL] POINTER
00509  0000              X
00510  0000              ; THESE LOCATIONS KEEP TRACK OF THE LOGICAL LINE 
THAT THE CURSOR IS ON AND ITS COLUMN
00511  0000              ; POSITION ON THAT LOGICAL LINE.
00512  0000              
00513  0000              ; EACH LOGICAL LINE MAY CONTAIN UP TO FOUR 22 COL
UMN PHYSICAL LINES. SO THERE MAY BE AS
00514  0000              ; MANY AS 23 LOGICAL LINES, OR AS FEW AS 6 AT ANY
 ONE TIME. THEREFORE, THE LOGICAL LINE
00515  0000              ; NUMBER MIGHT BE ANYWHERE FROM 1-23. DEPENDING O
N THE LENGTH OF THE LOGICAL LINE, THE
00516  0000              ; CURSOR COLUMN MAY BE FROM 1-22, 1-44, 1-66 OR 1
-88.
00517  0000              
00518  0000              ; FOR A MORE ON LOGICAL LINES, SEE THE DESCRIPTIO
N OF THE SCREEN LINE LINK TABLE, $D9.
00519  0000              
00520  0000              XXC9   = $C9           ; INPUT CURSOR ROW
00521  0000              XXCA   = $CA           ; INPUT CURSOR COLUMN
00522  0000              X
00523  0000              ; THE KEYSCAN INTERRUPT ROUTINE USES THIS LOCATIO
N TO INDICATE WHICH KEY IS CURRENTLY
00524  0000              ; BEING PRESSED. THE VALUE HERE IS THEN USED AS A
N INDEX INTO THE APPROPRIATE KEYBOARD
00525  0000              ; TABLE TO DETERMINE WHICH CHARACTER TO PRINT WHE
N A KEY IS STRUCK.
00526  0000              
00527  0000              ; THE CORRESPONDENCE BETWEEN THE KEY PRESSED AND 
THE NUMBER STORED HERE IS AS FOLLOWS:
00528  0000              
00529  0000              ; $00 1  $10 NOT USED $20 [SPACE] $30 Q  $40 [NO 
KEY]
00530  0000              ; $01 3  $11 A  $21 Z  $31 E  $XX INVALID
00531  0000              ; $02 5  $12 D  $22 C  $32 T
00532  0000              ; $03 7  $13 G  $23 B  $33 U
00533  0000              ; $04 9  $14 J  $24 M  $34 O
00534  0000              ; $05 +  $15 L  $25 .  $35 @
00535  0000              ; $06 [POUND] $16 ;  $26 NOT USED $36 [U ARROW]
00536  0000              ; $07 [DEL]  $17 [RIGHT] $27 [F1]  $37 [F5] 
00537  0000              ; $08 [L ARROW] $18 [STOP] $28 NOT USED $38 2
00538  0000              ; $09 W  $19 NOT USED $29 S  $39 4
00539  0000              ; $0A R  $1A X  $2A F  $3A 6
00540  0000              ; $0B Y  $1B V  $2B H  $3B 8
00541  0000              ; $0C I  $1C N  $2C K  $3C 0
00542  0000              ; $0D P  $1D ,  $2D :  $3D -
00543  0000              ; $0E *  $1E /  $2E =  $3E [HOME]
00544  0000              ; $0F [RETURN] $1F [DOWN] $2F [F3]  $3F [F7]
00545  0000              
00546  0000              XXCB   = $CB           ; WHICH KEY
00547  0000              X
00548  0000              ; WHEN THIS FLAG IS SET TO A NONZERO VALUE, IT IN
DICATES TO THE ROUTINE THAT NORMALLY
00549  0000              ; FLASHES THE CURSOR NOT TO DO SO. THE CURSOR BLI
NK IS TURNED OFF WHEN THERE ARE
00550  0000              ; CHARACTERS IN THE KEYBOARD BUFFER, OR WHEN THE 
PROGRAM IS RUNNING.






MALLY:......PAGE 0011

LINE# LOC   CODE        LINE


00551  0000              
00552  0000              XXCC   = $CC           ; CURSOR ENABLE, $00 = FLA
SH CURSOR
00553  0000              X
00554  0000              ; THE ROUTINE THAT BLINKS THE CURSOR USES THIS LO
CATION TO TELL WHEN IT'S TIME FOR A
00555  0000              ; BLINK. THE NUMBER 20 IS PUT HERE AND DECREMENTE
D EVERY JIFFY UNTIL IT REACHES ZERO.
00556  0000              ; THEN THE CURSOR STATE IS CHANGED, THE NUMBER 20
 IS PUT BACK HERE, AND THE CYCLE STARTS
00557  0000              ; ALL OVER AGAIN.
00558  0000              
00559  0000              XXCD   = $CD           ; CURSOR TIMING COUNTDOWN
00560  0000              X
00561  0000              ; THE CURSOR IS FORMED BY PRINTING THE INVERSE OF
 THE CHARACTER THAT OCCUPIES THE CURSOR
00562  0000              ; POSITION. IF THAT CHARACTERS IS THE LETTER A, F
OR EXAMPLE, THE FLASHING CURSOR MERELY
00563  0000              ; ALTERNATES BETWEEN PRINTING AN A AND A REVERSE-
A. THIS LOCATION KEEPS TRACK OF THE
00564  0000              ; NORMAL SCREEN CODE OF THE CHARACTER THAT IS LOC
ATED AT THE CURSOR POSITION, SO THAT IT
00565  0000              ; MAY BE RESTORED WHEN THE CURSOR MOVES ON.
00566  0000              
00567  0000              XXCE   = $CE           ; CHARACTER UNDER CURSOR
00568  0000              X
00569  0000              ; THIS LOCATION KEEPS TRACK OF WHETHER, DURING TH
E CURRENT CURSOR BLINK, THE CHARACTER
00570  0000              ; UNDER THE CURSOR WAS REVERSED, OR WAS RESTORED 
TO NORMAL. THIS LOCATION WILL CONTAIN
00571  0000              ; $00 IF THE CHARACTER IS REVERSED, AND $01 IF TH
E CHARACTER IS NOT REVERSED.
00572  0000              
00573  0000              XXCF   = $CF           ; CURSOR BLINK PHASE
00574  0000              X
00575  0000              XXD0   = $D0           ; INPUT FROM KEYBOARD OR S
CREEN, $XX = INPUT IS AVAILABLE
00576  0000              ; FROM THE SCREEN, $00 = INPUT SHOULD BE OBTAINED
 FROM THE
00577  0000              ; KEYBOARD
00578  0000              
00579  0000              ; THESE LOCATIONS POINT TO THE ADDRESS IN SCREEN 
RAM OF THE FIRST COLUMN OF THE LOGICAL
00580  0000              ; LINE UPON WHICH THE CURSOR IS CURRENTLY POSITIO
NED.
00581  0000              
00582  0000              XXD1   = $D1           ; CURRENT SCREEN LINE POIN
TER LOW BYTE
00583  0000              XXD2   = $D2           ; CURRENT SCREEN LINE POIN
TER HIGH BYTE
00584  0000              X
00585  0000              ; THIS HOLDS THE CURSOR COLUMN POSITION WITHIN TH
E LOGICAL LINE POINTED TO BY XXD1.
00586  0000              ; SINCE A LOGICAL LINE CAN COMPRISE UP TO FOUR PH
YSICAL LINES, THIS VALUE MAY BE FROM
00587  0000              ; $00 TO $57.
00588  0000              
00589  0000              XXD3   = $D3           ; CURSOR COLUMN
00590  0000              X
00591  0000              ; A NONZERO VALUE IN THIS LOCATION INDICATES THAT
 THE EDITOR IS IN QUOTE MODE. QUOTE
00592  0000              ; MODE IS TOGGLED EVERY TIME THAT YOU TYPE IN A Q
UOTATION MARK ON A GIVEN LINE, THE
00593  0000              ; FIRST QUOTE MARK TURNS IT ON, THE SECOND TURNS 
IT OFF, THE THIRD TURNS IT ON, ETC.
00594  0000              
00595  0000              ; IF THE EDITOR IS IN THIS MODE WHEN A CURSOR CON
TROL CHARACTER OR OTHER NONPRINTING
00596  0000              ; CHARACTER IS ENTERED, A PRINTED EQUIVALENT WILL
 APPEAR ON THE SCREEN INSTEAD OF THE
00597  0000              ; CURSOR MOVEMENT OR OTHER CONTROL OPERATION TAKI
NG PLACE. INSTEAD, THAT ACTION IS
00598  0000              ; DEFERRED UNTIL THE STRING IS SENT TO THE STRING
 BY A PRINT STATEMENT, AT WHICH TIME
00599  0000              ; THE CURSOR MOVEMENT OR OTHER CONTROL OPERATION 
WILL TAKE PLACE.
00600  0000              
00601  0000              ; THE EXCEPTION TO THIS RULE IS THE DELETE KEY, W
HICH WILL FUNCTION NORMALLY WITHIN
00602  0000              ; QUOTE MODE. THE ONLY WAY TO PRINT A CHARACTER W
HICH IS EQUIVALENT TO THE DELETE KEY
00603  0000              ; IS BY ENTERING INSERT MODE. QUOTE MODE MAY BE E
XITED BY PRINTING A CLOSING QUOTE OR
00604  0000              ; BY HITTING THE RETURN OR SHIFT-RETURN KEYS.
00605  0000              






TE ORA......PAGE 0012

LINE# LOC   CODE        LINE


00606  0000              XXD4   = $D4           ; CURSOR QUOTE FLAG
00607  0000              X
00608  0000              ; THE LINE EDITOR USES THIS LOCATION WHEN THE END
 OF A LINE HAS BEEN REACHED TO DETERMINE
00609  0000              ; WHETHER ANOTHER PHYSICAL LINE CAN BE ADDED TO T
HE CURRENT LOGICAL LINE OR IF A NEW
00610  0000              ; LOGICAL LINE MUST BE STARTED.
00611  0000              
00612  0000              XXD5   = $D5           ; CURRENT SCREEN LINE LENG
TH
00613  0000              X
00614  0000              ; THIS LOCATION CONTAINS THE CURRENT PHYSICAL SCR
EEN LINE POSITION OF THE CURSOR, 0 TO 22.
00615  0000              
00616  0000              XXD6   = $D6           ; CURSOR ROW
00617  0000              X
00618  0000              ; THE ASCII VALUE OF THE LAST CHARACTER PRINTED T
O THE SCREEN IS HELD HERE TEMPORARILY.
00619  0000              
00620  0000              XXD7   = $D7           ; CHECKSUM BYTE/TEMPORARY 
LAST CHARACTER
00621  0000              X
00622  0000              ; WHEN THE INST KEY IS PRESSED, THE SCREEN EDITOR
 SHIFTS THE LINE TO THE RIGHT, ALLOCATES
00623  0000              ; ANOTHER PHYSICAL LINE TO THE LOGICAL LINE IF NE
CESSARY (AND POSSIBLE), UPDATES THE
00624  0000              ; SCREEN LINE LENGTH IN $D5, AND ADJUSTS THE SCRE
EN LINE LINK TABLE AT $D9. THIS LOCATION
00625  0000              ; IS USED TO KEEP TRACK OF THE NUMBER OF SPACES T
HAT HAS BEEN OPENED UP IN THIS WAY.
00626  0000              
00627  0000              ; UNTIL THE SPACES THAT HAVE BEEN OPENED UP ARE F
ILLED, THE EDITOR ACTS AS IF IN QUOTE
00628  0000              ; MODE. SEE LOCATION $D4, THE QUOTE MODE FLAG. TH
IS MEANS THAT CURSOR CONTROL CHARACTERS
00629  0000              ; THAT ARE NORMALLY NONPRINTING WILL LEAVE A PRIN
TED EQUIVALENT ON THE SCREEN WHEN
00630  0000              ; ENTERED, INSTEAD OF HAVING THEIR NORMAL EFFECT 
ON CURSOR MOVEMENT, ETC. THE ONLY
00631  0000              ; DIFFERENCE BETWEEN INSERT AND QUOTE MODE IS THA
T THE DELETE KEY WILL LEAVE A PRINTED
00632  0000              ; EQUIVALENT IN INSERT MODE, WHILE THE INSERT KEY
 WILL INSERT SPACES AS NORMAL.
00633  0000              
00634  0000              XXD8   = $D8           ; INSERT COUNT
00635  0000              X
00636  0000              ; THIS TABLE CONTAINS 23 ENTRIES, ONE FOR EACH RO
W OF THE SCREEN DISPLAY. EACH ENTRY HAS
00637  0000              ; TWO FUNCTIONS. BITS 0-3 INDICATE ON WHICH OF TH
E FOUR PAGES OF SCREEN MEMORY THE FIRST
00638  0000              ; BYTE OF MEMORY FOR THAT ROW IS LOCATED. THIS IS
 USED IN CALCULATING THE POINTER TO THE
00639  0000              ; STARTING ADDRESS OF A SCREEN LINE AT $D1.
00640  0000              ;
00641  0000              ; THE HIGH BYTE IS CALCULATED BY ADDING THE VALUE
 OF THE STARTING PAGE OF SCREEN MEMORY
00642  0000              ; HELD IN $288 TO THE DISPLACEMENT PAGE HELD HERE
.
00643  0000              ;
00644  0000              ; THE OTHER FUNCTION OF THIS TABLE IS TO ESTABLIS
H THE MAKEUP OF LOGICAL LINES ON THE
00645  0000              ; SCREEN. WHILE EACH SCREEN LINE IS ONLY 22 CHARA
CTERS LONG, BASIC ALLOWS THE ENTRY OF
00646  0000              ; PROGRAM LINES THAT CONTAIN UP TO 88 CHARACTERS.
 THEREFORE, SOME METHOD MUST BE USED
00647  0000              ; TO DETERMINE WHICH PHYSICAL LINES ARE LINKED IN
TO A LONGER LOGICAL LINE, SO THAT THIS
00648  0000              ; LONGER LOGICAL LINE MAY BE EDITED AS A UNIT.
00649  0000              ;
00650  0000              ; THE HIGH BIT OF EACH BYTE HERE IS USED AS A FLA
G BY THE SCREEN EDITOR. THAT BIT IS SET
00651  0000              ; WHEN A LINE IS THE FIRST OR ONLY PHYSICAL LINE 
IN A LOGICAL LINE. THE HIGH BIT IS RESET
00652  0000              ; TO 0 ONLY WHEN A LINE IS AN EXTENSION TO THIS L
OGICAL LINE.
00653  0000              
00654  0000              XXD9   = $D9           ; TO XXD9 + $18 INCLUSIVE,
 SCREEN LINE LINK TABLE
00655  0000              X
00656  0000              ; THIS POINTER IS SYNCHRONIZED WITH THE POINTER T
O THE ADDRESS OF THE FIRST BYTE OF
00657  0000              ; SCREEN RAM FOR THE CURRENT LINE KEPT IN LOCATIO
N $D1. IT HOLDS THE ADDRESS OF THE
00658  0000              ; FIRST BYTE OF COLOUR RAM FOR THE CORRESPONDING 
SCREEN LINE.
00659  0000              
00660  0000              XXF2   = $F2           ; SCREEN ROW MARKER






THE RE......PAGE 0013

LINE# LOC   CODE        LINE


00661  0000              XXF3   = $F3           ; COLOUR RAM POINTER LOW B
YTE
00662  0000              XXF4   = $F4           ; COLOUR RAM POINTER HIGH 
BYTE
00663  0000              X
00664  0000              ; THIS POINTER POINTS TO THE ADDRESS OF THE KEYBO
ARD MATRIX LOOKUP TABLE CURRENTLY BEING
00665  0000              ; USED. ALTHOUGH THERE ARE ONLY 64 KEYS ON THE KE
YBOARD MATRIX, EACH KEY CAN BE USED TO
00666  0000              ; PRINT UP TO FOUR DIFFERENT CHARACTERS, DEPENDIN
G ON WHETHER IT IS STRUCK BY ITSELF OR
00667  0000              ; IN COMBINATION WITH THE SHIFT, CTRL, OR C= KEYS
.
00668  0000              
00669  0000              ; THESE TABLES HOLD THE ASCII VALUE OF EACH OF TH
E 64 KEYS FOR ONE OF THESE POSSIBLE
00670  0000              ; COMBINATIONS OF KEYPRESSES. WHEN IT COMES TIME 
TO PRINT THE CHARACTER, THE TABLE THAT
00671  0000              ; IS USED DETERMINES WHICH CHARACTER IS PRINTED.
00672  0000              
00673  0000              ; THE ADDRESSES OF THE TABLES ARE:
00674  0000              
00675  0000              ; XXEC5E   ; UNSHIFTED
00676  0000              ; XXEC9F   ; SHIFTED
00677  0000              ; XXECE0   ; COMMODORE
00678  0000              ; XXEDA3   ; CONTROL
00679  0000              
00680  0000              XXF5   = $F5           ; KEYBOARD POINTER LOW BYT
E
00681  0000              XXF6   = $F6           ; KEYBOARD POINTER HIGH BY
TE
00682  0000              X
00683  0000              ; WHEN DEVICE THE RS232 CHANNEL IS OPENED TWO BUF
FERS OF 256 BYTES EACH ARE CREATED AT
00684  0000              ; THE TOP OF MEMORY. THESE LOCATIONS POINT TO THE
 ADDRESS OF THE ONE WHICH IS USED TO
00685  0000              ; STORE CHARACTERS AS THEY ARE RECEIVED.
00686  0000              
00687  0000              XXF7   = $F7           ; RS232 RX POINTER LOW BYT
E
00688  0000              XXF8   = $F8           ; RS232 RX POINTER HIGH BY
TE
00689  0000              X
00690  0000              ; THESE LOCATIONS POINT TO THE ADDRESS OF THE 256
 BYTE OUTPUT BUFFER THAT IS USED FOR
00691  0000              ; TRANSMITTING DATA TO RS232 DEVICES.
00692  0000              
00693  0000              XXF9   = $F9           ; RS232 TX POINTER LOW BYT
E
00694  0000              XXFA   = $FA           ; RS232 TX POINTER HIGH BY
TE
00695  0000              X
00696  0000              XX00FF = $FF           ; FAC1 TO STRING OUTPUT BA
SE
00697  0000              X
00698  0000              XX0100 = $0100         ; BOTTOM OF THE STACK PAGE

00699  0000              X
00700  0000              XX01FC = $01FC         ; CHAIN LINK POINTER HIGH 
BYTE
00701  0000              XX01FD = $01FD         ; CHAIN LINK POINTER LOW B
YTE
00702  0000              X
00703  0000              XX01FE = $01FE         ; LINE NUMBER LOW BYTE BEF
ORE CRUNCHED LINE
00704  0000              XX01FF = $01FF         ; LINE NUMBER HIGH BYTE BE
FORE CRUNCHED LINE
00705  0000              X
00706  0000              XX0200 = $0200         ; INPUT BUFFER. FOR SOME R
OUTINES THE BYTE BEFORE THE INPUT
00707  0000              ; BUFFER NEEDS TO BE SET TO A SPECIFIC VALUE FOR 
THE ROUTINE
00708  0000              ; TO WORK CORRECTLY
00709  0000              XX0201 = $0201         ; INPUT BUFFER + 1
00710  0000              X
00711  0000              XX0259 = $0259         ; .. TO XX0262 LOGICAL FIL
E TABLE
00712  0000              XX0263 = $0263         ; .. TO XX026C DEVICE NUMB
ER TABLE
00713  0000              XX026D = $026D         ; .. TO XX0276 SECONDARY A
DDRESS TABLE
00714  0000              XX0277 = $0277         ; .. TO XX0280 KEYBOARD BU
FFER
00715  0000              XX0281 = $0281         ; OS START OF MEMORY LOW B
YTE






D FORT......PAGE 0014

LINE# LOC   CODE        LINE


00716  0000              XX0282 = $0282         ; OS START OF MEMORY HIGH 
BYTE
00717  0000              XX0283 = $0283         ; OS TOP OF MEMORY LOW BYT
E
00718  0000              XX0284 = $0284         ; OS TOP OF MEMORY HIGH BY
TE
00719  0000              XX0285 = $0285         ; SERIAL BUS TIMEOUT FLAG
00720  0000              XX0286 = $0286         ; CURRENT COLOUR CODE
00721  0000              XX0287 = $0287         ; COLOUR UNDER CURSOR
00722  0000              XX0288 = $0288         ; SCREEN MEMORY PAGE
00723  0000              XX0289 = $0289         ; MAXIMUM KEYBOARD BUFFER 
SIZE
00724  0000              XX028A = $028A         ; KEY REPEAT. $80 = REPEAT
 ALL, $40 = REPEAT NONE,
00725  0000                                     ; $00 = REPEAT CURSOR MOVE
MENT KEYS, INSERT/DELETE
00726  0000                                     ; KEY AND THE SPACE BAR
00727  0000              XX028B = $028B         ; REPEAT SPEED COUNTER
00728  0000              XX028C = $028C         ; REPEAT DELAY COUNTER
00729  0000              X
00730  0000              ; THIS FLAG SIGNALS WHICH OF THE SHIFT, CTRL, OR 
C= KEYS ARE CURRENTLY BEING PRESSED.
00731  0000              
00732  0000              ; A VALUE OF $01 SIGNIFIES THAT ONE OF THE SHIFT 
KEYS IS BEING PRESSED, A $02 SHOWS THAT
00733  0000              ; THE C= KEY IS DOWN, AND $04 MEANS THAT THE CTRL
 KEY IS BEING PRESSED. IF MORE THAN ONE
00734  0000              ; KEY IS HELD DOWN, THESE VALUES WILL BE ADDED E.
G $03 INDICATES THAT SHIFT AND C= ARE
00735  0000              ; BOTH HELD DOWN.
00736  0000              
00737  0000              ; PRESSING THE SHIFT AND C= KEYS AT THE SAME TIME
 WILL TOGGLE THE CHARACTER SET THAT IS
00738  0000              ; PRESENTLY BEING USED BETWEEN THE UPPERCASE/GRAP
HICS SET, AND THE LOWERCASE/UPPERCASE
00739  0000              ; SET.
00740  0000              
00741  0000              ; WHILE THIS CHANGES THE APPEARANCE OF ALL OF THE
 CHARACTERS ON THE SCREEN AT ONCE IT
00742  0000              ; HAS NOTHING WHATEVER TO DO WITH THE KEYBOARD SH
IFT TABLES AND SHOULD NOT BE CONFUSED
00743  0000              ; WITH THE PRINTING OF SHIFTED CHARACTERS, WHICH 
AFFECTS ONLY ONE CHARACTER AT A TIME.
00744  0000              
00745  0000              XX028D = $028D         ; KEYBOARD SHIFT/CONTROL F
LAG
00746  0000              ; BIT KEY(S) 1 = DOWN
00747  0000              ; --- ---------------
00748  0000              ; 7-3 UNUSED
00749  0000              ;  2 CTRL
00750  0000              ;  1 C=
00751  0000              ;  0 SHIFT
00752  0000              
00753  0000              ; THIS LOCATION, IN COMBINATION WITH THE ONE ABOV
E, IS USED TO DEBOUNCE THE SPECIAL
00754  0000              ; SHIFT KEYS. THIS WILL KEEP THE SHIFT/C= COMBINA
TION FROM CHANGING CHARACTER SETS
00755  0000              ; BACK AND FORTH DURING A SINGLE PRESSING OF BOTH
 KEYS.
00756  0000              
00757  0000              XX028E = $028E         ; SHIFT/CTRL/C= KEYPRESS L
AST PATTERN
00758  0000              X
00759  0000              ; THIS LOCATION POINTS TO THE ADDRESS OF THE OPER
ATING SYSTEM ROUTINE WHICH ACTUALLY
00760  0000              ; DETERMINES WHICH KEYBOARD MATRIX LOOKUP TABLE W
ILL BE USED.
00761  0000              
00762  0000              ; THE ROUTINE LOOKS AT THE VALUE OF THE SHIFT FLA
G AT $28D, AND BASED ON WHAT VALUE
00763  0000              ; IT FINDS THERE, STORES THE ADDRESS OF THE CORRE
CT TABLE TO USE AT LOCATION $F5.
00764  0000              
00765  0000              XX028F = $028F         ; KEYBOARD DECODE LOGIC PO
INTER LOW BYTE
00766  0000              XX0290 = $0290         ; KEYBOARD DECODE LOGIC PO
INTER HIGH BYTE
00767  0000              X
00768  0000              ; THIS FLAG IS USED TO ENABLE OR DISABLE THE FEAT
URE WHICH LETS YOU SWITCH BETWEEN THE
00769  0000              ; UPPERCASE/GRAPHICS AND UPPER/LOWERCASE CHARACTE
R SETS BY PRESSING THE SHIFT AND
00770  0000              ; COMMODORE LOGO KEYS SIMULTANEOUSLY.






DN THE......PAGE 0015

LINE# LOC   CODE        LINE


00771  0000              
00772  0000              XX0291 = $0291         ; SHIFT MODE SWITCH, $00 =
 ENABLED, $80 = LOCKED
00773  0000              X
00774  0000              ; THIS LOCATION IS USED TO DETERMINE WHETHER MOVI
NG THE CURSOR PAST THE ??XX  COLUMN OF
00775  0000              ; A LOGICAL LINE WILL CAUSE ANOTHER PHYSICAL LINE
 TO BE ADDED TO THE LOGICAL LINE.
00776  0000              
00777  0000              ; A VALUE OF 0 ENABLES THE SCREEN TO SCROLL THE F
OLLOWING LINES DOWN IN ORDER TO ADD
00778  0000              ; THAT LINE; ANY NONZERO VALUE WILL DISABLE THE S
CROLL.
00779  0000              
00780  0000              ; THIS FLAG IS SET TO DISABLE THE SCROLL TEMPORAR
ILY WHEN THERE ARE CHARACTERS WAITING
00781  0000              ; IN THE KEYBOARD BUFFER, THESE MAY INCLUDE CURSO
R MOVEMENT CHARACTERS THAT WOULD
00782  0000              ; ELIMINATE THE NEED FOR A SCROLL.
00783  0000              
00784  0000              XX0292 = $0292         ; SCREEN SCROLLING FLAG, $
00 = ENABLED
00785  0000              X
00786  0000              XX0293 = $0293         ; PSEUDO 6551 CONTROL REGI
STER. THE FIRST CHARACTER OF
00787  0000              ; THE OPEN RS232 FILENAME WILL BE STORED HERE
00788  0000              ; BIT FUNCTION
00789  0000              ; --- --------
00790  0000              ;  7 2 STOP BITS/1 STOP BIT
00791  0000              ; 65 WORD LENGTH
00792  0000              ; --- -----------
00793  0000              ; 00 8 BITS
00794  0000              ; 01 7 BITS
00795  0000              ; 10 6 BITS
00796  0000              ; 11 5 BITS
00797  0000              ;  4 UNUSED
00798  0000              ; 3210 BAUD RATE
00799  0000              ; ---- ---------
00800  0000              ; 0000 USER RATE *
00801  0000              ; 0001    50
00802  0000              ; 0010    75
00803  0000              ; 0011   110
00804  0000              ; 0100   134.5
00805  0000              ; 0101   150
00806  0000              ; 0110   300
00807  0000              ; 0111   600
00808  0000              ; 1000  1200
00809  0000              ; 1001  1800
00810  0000              ; 1010  2400
00811  0000              ; 1011  3600
00812  0000              ; 1100  4800 *
00813  0000              ; 1101  7200 *
00814  0000              ; 1110  9600 *
00815  0000              ; 1111 19200 * * = NOT IMPLEMENTED
00816  0000              XX0294 = $0294         ; PSEUDO 6551 COMMAND REGI
STER. THE SECOND CHARACTER OF
00817  0000              ; THE OPEN RS232 FILENAME WILL BE STORED HERE
00818  0000              ; BIT FUNCTION
00819  0000              ; --- --------
00820  0000              ; 765 PARITY
00821  0000              ; --- ------
00822  0000              ; XX0 DISABLED
00823  0000              ; 001 ODD
00824  0000              ; 011 EVEN
00825  0000              ; 101 MARK






DITING......PAGE 0016

LINE# LOC   CODE        LINE


00826  0000              ; 111 SPACE
00827  0000              ;  4 DUPLEX HALF/FULL
00828  0000              ;  3 UNUSED
00829  0000              ;  2 UNUSED
00830  0000              ;  1 UNUSED
00831  0000              ;  0 HANDSHAKE - X LINE/3 LINE
00832  0000              ;XX0295 = $0295  ; NONSTANDARD BIT TIMING LOW BYT
E. THE THIRD CHARACTER
00833  0000              ; OF THE OPEN RS232 FILENAME WILL BE STORED HERE
00834  0000              ;XX0296 = $0296  ; NONSTANDARD BIT TIMING HIGH BY
TE. THE FOURTH CHARACTER
00835  0000              ; OF THE OPEN RS232 FILENAME WILL BE STORED HERE
00836  0000              XX0297 = $0297         ; RS-232 STATUS REGISTER
00837  0000              ; BIT FUNCTION
00838  0000              ; --- --------
00839  0000              ;  7 BREAK
00840  0000              ;  6 NO DSR DETECTED
00841  0000              ;  5 UNUSED
00842  0000              ;  4 NO CTS DETECTED
00843  0000              ;  3 UNUSED
00844  0000              ;  2 RX BUFFER OVERRUN
00845  0000              ;  1 FRAMING ERROR
00846  0000              ;  0 PARITY ERROR
00847  0000              XX0298 = $0298         ; NUMBER OF BITS TO BE SEN
T/RECEIVED
00848  0000              XX0299 = $0299         ; TIME OF ONE BIT CELL LOW
 BYTE
00849  0000              XX029A = $029A         ; TIME OF ONE BIT CELL HIG
H BYTE
00850  0000              XX029B = $029B         ; INDEX TO RX BUFFER END
00851  0000              XX029C = $029C         ; INDEX TO RX BUFFER START

00852  0000              XX029D = $029D         ; INDEX TO TX BUFFER START

00853  0000              XX029E = $029E         ; INDEX TO TX BUFFER END
00854  0000              XX029F = $029F         ; SAVED IRQ LOW BYTE
00855  0000              XX02A0 = $02A0         ; SAVED IRQ HIGH BYTE
00856  0000              X
00857  0000              ; $02A1 TO $02FF - UNUSED
00858  0000              
00859  0000              XX0300 = $0300         ; VECTOR TO THE PRINT BASI
C ERROR MESSAGE ROUTINE
00860  0000              XX0302 = $0302         ; VECTOR TO THE MAIN BASIC
 PROGRAM LOOP
00861  0000              XX0304 = $0304         ; VECTOR TO THE THE ASCII 
TEXT TO KEYWORDS ROUTINE
00862  0000              XX0306 = $0306         ; VECTOR TO THE LIST BASIC
 PROGRAM AS ASCII ROUTINE
00863  0000              XX0308 = $0308         ; VECTOR TO THE EXECUTE NE
XT BASIC COMMAND ROUTINE
00864  0000              XX030A = $030A         ; VECTOR TO THE GET VALUE 
FROM BASIC LINE ROUTINE
00865  0000              X
00866  0000              ; BEFORE EVERY SYS COMMAND EACH OF THE REGISTERS 
IS LOADED WITH THE VALUE FOUND IN THE
00867  0000              ; CORRESPONDING STORAGE ADDRESS. UPON RETURNING T
O BASIC WITH AN RTS INSTRUCTION, THE NEW
00868  0000              ; VALUE OF EACH REGISTER IS STORED IN THE APPROPR
IATE STORAGE ADDRESS.
00869  0000              
00870  0000              ; THIS FEATURE ALLOWS YOU TO PLACE THE NECESSARY 
VALUES INTO THE REGISTERS FROM BASIC
00871  0000              ; BEFORE YOU SYS TO A KERNAL OR BASIC ML ROUTINE.
 IT ALSO ENABLES YOU TO EXAMINE THE
00872  0000              ; RESULTING EFFECT OF THE ROUTINE ON THE REGISTER
S, AND TO PRESERVE THE CONDITION OF THE
00873  0000              ; REGISTERS ON EXIT FOR SUBSEQUENT SYS CALLS.
00874  0000              
00875  0000              XX030C = $030C         ; A FOR SYS COMMAND
00876  0000              XX030D = $030D         ; X FOR SYS COMMAND
00877  0000              XX030E = $030E         ; Y FOR SYS COMMAND
00878  0000              XX030F = $030F         ; P FOR SYS COMMAND
00879  0000              X
00880  0000              XX0314 = $0314         ; IRQ VECTOR LOW BYTE






N OF T......PAGE 0017

LINE# LOC   CODE        LINE


00881  0000              XX0315 = $0315         ; IRQ VECTOR HIGH BYTE
00882  0000              XX0316 = $0316         ; BRK VECTOR
00883  0000              XX0318 = $0318         ; NMI VECTOR
00884  0000              X
00885  0000              XX031A = $031A         ; KERNAL VECTOR - OPEN A L
OGICAL FILE
00886  0000              XX031C = $031C         ; KERNAL VECTOR - CLOSE A 
SPECIFIED LOGICAL FILE
00887  0000              XX031E = $031E         ; KERNAL VECTOR - OPEN CHA
NNEL FOR INPUT
00888  0000              XX0320 = $0320         ; KERNAL VECTOR - OPEN CHA
NNEL FOR OUTPUT
00889  0000              XX0322 = $0322         ; KERNAL VECTOR - CLOSE IN
PUT AND OUTPUT CHANNELS
00890  0000              XX0324 = $0324         ; KERNAL VECTOR - INPUT CH
ARACTER FROM CHANNEL
00891  0000              XX0326 = $0326         ; KERNAL VECTOR - OUTPUT C
HARACTER TO CHANNEL
00892  0000              XX0328 = $0328         ; KERNAL VECTOR - SCAN STO
P KEY
00893  0000              XX032A = $032A         ; KERNAL VECTOR - GET CHAR
ACTER FROM KEYBOARD QUEUE
00894  0000              XX032C = $032C         ; KERNAL VECTOR - CLOSE AL
L CHANNELS AND FILES
00895  0000              X
00896  0000              XX0330 = $0330         ; KERNAL VECTOR - LOAD
00897  0000              XX0332 = $0332         ; KERNAL VECTOR - SAVE
00898  0000              X
00899  0000              XX033C = $033C         ; TO $03FB - CASSETTE BUFF
ER
00900  0000              X
00901  0000              X
00902  0000              ;************************************************
***********************************;
00903  0000              ;************************************************
***********************************;
00904  0000              ;
00905  0000              ; HARDWARE EQUATES
00906  0000              
00907  0000              XX9000 = $9000          ; VIC CHIP BASE ADDRESS
00908  0000              XX9002 = $9002          ; VIDEO ADDRESS AND COLUM
S
00909  0000                                     ; BIT     FUNCTION
00910  0000                                     ; ---     --------
00911  0000                                     ;  7     VIDEO ADDRESS VA9

00912  0000                                     ; 6-0     NUMBER OF COLUMN
S
00913  0000              XX9005 = $9005          ; VIDEO MEMORY ADDRESSES 
($1E00)
00914  0000                                     ; BIT     FUNCTION
00915  0000                                     ; ---     --------
00916  0000                                     ;  7     MUST BE 1
00917  0000                                     ; 6-4     VIDEO MEMORY ADD
RESS VA12-VA10
00918  0000                                     ; 3-0     CHARACTER MEMORY
 START ADDRESS
00919  0000                     
00920  0000                                     ; 0000 ROM     $8000     S
ET 1
00921  0000                                     ; 0001  '     $8400
00922  0000                                     ; 0010  '     $8800 SET 2
00923  0000                                     ; 0011  '     $8C00
00924  0000                                     ; 1100 RAM     $1000
00925  0000                                     ; 1101  '     $1400
00926  0000                                     ; 1110  '     $1800
00927  0000                                     ; 1111  '     $1C00
00928  0000                     
00929  0000              XX9110 = $9110          ; VIA 1 DRB
00930  0000                                     ; BIT     FUNCTION
00931  0000                                     ; ---     --------
00932  0000                                     ;  7     DSR IN
00933  0000                                     ;  6     CTS IN
00934  0000                                     ;  5     
00935  0000                                     ;  4     DCD IN






****;T......PAGE 0018

LINE# LOC   CODE        LINE


00936  0000                                     ;  3     RI IN
00937  0000                                     ;  2     DTR OUT
00938  0000                                     ;  1     RTS OUT
00939  0000                                     ;  0     DATA IN
00940  0000              XX9111 = $9111          ; VIA 1 DRA
00941  0000                                     ; BIT     FUNCTION
00942  0000                                     ; ---     --------
00943  0000                                     ;  7     SERIAL ATN OUT
00944  0000                                     ;  6     CASSETTE SWITCH
00945  0000                                     ;  5     LIGHT PEN
00946  0000                                     ;  4     JOY 2
00947  0000                                     ;  3     JOY 1
00948  0000                                     ;  2     JOY 0
00949  0000                                     ;  1     SERIAL DATA IN
00950  0000                                     ;  0     SERIAL CLK IN
00951  0000              XX9112 = $9112          ; VIA 1 DDRB
00952  0000              XX9113 = $9113          ; VIA 1 DDRA
00953  0000              XX9114 = $9114          ; VIA 1 T1C_L
00954  0000              XX9115 = $9115          ; VIA 1 T1C_H
00955  0000              XX9118 = $9118          ; VIA 1 T2C_L
00956  0000              XX9119 = $9119          ; VIA 1 T2C_H
00957  0000              XX911B = $911B          ; VIA 1 ACR
00958  0000                                     ; BIT     FUNCTION
00959  0000                                     ; ---     --------
00960  0000                                     ;  7     T1 PB7 ENABLED/DI
SABLED
00961  0000                                     ;  6     T1 FREE RUN/ONE S
HOT
00962  0000                                     ;  5     T2 CLOCK PB6/.2
00963  0000                                     ; 432     FUNCTION
00964  0000                                     ; ---     --------
00965  0000                                     ; 000     SHIFT REGISTER D
ISABLED
00966  0000                                     ; 001     SHIFT IN, RATE C
ONTROLLED BY T2
00967  0000                                     ; 010     SHIFT IN, RATE C
ONTROLLED BY .2
00968  0000                                     ; 011     SHIFT IN, RATE C
ONTROLLED BY EXTERNAK CLOCK
00969  0000                                     ; 100     SHIFT OUT, RATE 
CONTROLLED BY T2, FREE RUN MODE
00970  0000                                     ; 101     SHIFT OUT, RATE 
CONTROLLED BY T2
00971  0000                                     ; 110     SHIFT OUT, RATE 
CONTROLLED BY .2
00972  0000                                     ; 111     SHIFT OUT, RATE 
CONTROLLED BY EXTERNAK CLOCK
00973  0000                                     ;  1     PB LATCH ENABLED/
DISABLED
00974  0000                                     ;  0     PA LATCH ENABLED/
DISABLED
00975  0000              XX911C = $911C          ; VIA 1 PCR
00976  0000                                     ; BIT     FUNCTION
00977  0000                                     ; ---     --------
00978  0000                                     ; 765     CB2 CONTROL
00979  0000                                     ; ---     -----------
00980  0000                                     ; 000     INTERRUPT INPUT 
MODE
00981  0000                                     ; 001     INDEPENDENT INTE
RRUPT INPUT MODE
00982  0000                                     ; 010     INPUT MODE
00983  0000                                     ; 011     INDEPENDENT INPU
T MODE
00984  0000                                     ; 100     HANDSHAKE OUTPUT
 MODE
00985  0000                                     ; 101     PULSE OUTPUT MOD
E
00986  0000                                     ; 110     MANUAL OUTPUT MO
DE, CB2 LOW
00987  0000                                     ; 111     MANUAL OUTPUT MO
DE, CB2 HIGH
00988  0000                                     ;  4     CB1 EDGE POSITIVE
/NEGATIVE
00989  0000                                     ; 321     CA2 CONTROL
00990  0000                                     ; ---     -----------






DE**;T......PAGE 0019

LINE# LOC   CODE        LINE


00991  0000                                     ; 000     INTERRUPT INPUT 
MODE
00992  0000                                     ; 001     INDEPENDENT INTE
RRUPT INPUT MODE
00993  0000                                     ; 010     INPUT MODE 
00994  0000                                     ; 011     INDEPENDENT INPU
T MODE
00995  0000                                     ; 100     HANDSHAKE OUTPUT
 MODE
00996  0000                                     ; 101     PULSE OUTPUT MOD
E
00997  0000                                     ; 110     MANUAL OUTPUT MO
DE, CA2 LOW
00998  0000                                     ; 111     MANUAL OUTPUT MO
DE, CA2 HIGH
00999  0000                                     ;  0     CA1 EDGE POSITIVE
/NEGATIVE
01000  0000                     
01001  0000              ; THE STATUS BIT IS A NOT NORMAL FLAG. IT GOES HI
GH IF BOTH AN INTERRUPT FLAG IN THE IFR
01002  0000              ; AND THE CORRESPONDING ENABLE BIT IN THE IER ARE
 SET. IT CAN BE CLEARED ONLY BY CLEARING
01003  0000              ; ALL THE ACTIVE FLAGS IN THE IFR OR DISABLING AL
L ACTIVE INTERRUPTS IN THE IER
01004  0000              
01005  0000              XX911D = $911D          ; VIA 1 IFR
01006  0000                                     ; BIT     FUNCTION        
  CLEARED BY
01007  0000                                     ; ---     --------        
  ----------
01008  0000                                     ;  7     INTERRUPT STATUS 
    CLEARING ALL ENABLED INTERRUPTS
01009  0000                                     ;  6     T1 INTERRUPT     
READ T1C_L, WRITE T1C_H
01010  0000                                     ;  5     T2 INTERRUPT     
READ T2C_L, WRITE T2C_H
01011  0000                                     ;  4     CB1 TRANSITION   
  READ OR WRITE PORT B
01012  0000                                     ;  3     CB2 TRANSITION   
  READ OR WRITE PORT B
01013  0000                                     ;  2     8 SHIFTS DONE    
 READ OR WRITE THE SHIFT REGISTER
01014  0000                                     ;  1     CA1 TRANSITION   
  READ OR WRITE PORT A
01015  0000                                     ;  0     CA2 TRANSITION   
  READ OR WRITE PORT A
01016  0000                     
01017  0000              ; IF ENABLE/DISABLE BIT IS A ZERO DURING A WRITE 
TO THIS REGISTER, EACH 1 IN BITS 0-6
01018  0000              ; CLEARS THE CORRESPONDING BIT IN THE IER. IF THI
S BIT IS A ONE DURING A WRITE TO THIS
01019  0000              ; REGISTER, EACH 1 IN BITS 0-6 WILL SET THE CORRE
SPONDING IER BIT
01020  0000              
01021  0000              XX911E = $911E          ; VIA 1 IER
01022  0000                                     ; BIT     FUNCTION
01023  0000                                     ; ---     --------
01024  0000                                     ;  7     ENABLE/DISABLE
01025  0000                                     ;  6     T1 INTERRUPT
01026  0000                                     ;  5     T2 INTERRUPT
01027  0000                                     ;  4     CB1 TRANSITION
01028  0000                                     ;  3     CB2 TRANSITION
01029  0000                                     ;  2     8 SHIFTS DONE
01030  0000                                     ;  1     CA1 TRANSITION
01031  0000                                     ;  0     CA2 TRANSITION
01032  0000                     
01033  0000              XX911F = $911F          ; VIA 1 DRA, NO HANDSHAKE

01034  0000                                     ; BIT     FUNCTION
01035  0000                                     ; ---     --------
01036  0000                                     ;  7     ATN OUT
01037  0000                                     ;  6     CASSETTE SWITCH
01038  0000                                     ;  5     JOYSTICK FIRE, LI
GHT PEN
01039  0000                                     ;  4     JOYSTICK LEFT
01040  0000                                     ;  3     JOYSTICK DOWN
01041  0000                                     ;  2     JOYSTICK UP
01042  0000                                     ;  1     SERIAL DAT IN
01043  0000                                     ;  0     SERIAL CLK IN
01044  0000                     
01045  0000              XX9120 = $9120          ; VIA 2 DRB, KEYBOARD COL
UMN DRIVE






O THIS......PAGE 0020

LINE# LOC   CODE        LINE


01046  0000              XX9121 = $9121          ; VIA 2 DRA, KEYBOARD ROW
 PORT
01047  0000                                     ; VIC 20 KEYBOARD MATRIX L
AYOUT
01048  0000                                     ;     C7     C6     C5    
 C4     C3     C2     C1     C0
01049  0000                                     ;   +---------------------
---------------------------
01050  0000                                     ; R7.     [F7]     [F5]   
  [F3]     [F1]     [DN]     [RGT]     [RET]     [DEL]
01051  0000                                     ; R6.     [HOME][UP]  =   
  [RSH]     /     ;     *     .
01052  0000                                     ; R5.     -     @     :   
  .     ,     L     P     +
01053  0000                                     ; R4.     0     O     K   
  M     N     J     I     9
01054  0000                                     ; R3.     8     U     H   
  B     V     G     Y     7
01055  0000                                     ; R2.     6     T     F   
  C     X     D     R     5
01056  0000                                     ; R1.     4     E     S   
  Z     [LSH]     A     W     3
01057  0000                                     ; R0.     2     Q     [CBM
]     [SP]     [RUN]     [CTL]     [LFT]     1
01058  0000                     
01059  0000              XX9122 = $9122          ; VIA 2 DDRB
01060  0000              XX9123 = $9123          ; VIA 2 DDRA
01061  0000              XX9124 = $9124          ; VIA 2 T1C_L
01062  0000              XX9125 = $9125          ; VIA 2 T1C_H
01063  0000              XX9128 = $9128          ; VIA 2 T2C_L
01064  0000              XX9129 = $9129          ; VIA 2 T2C_H
01065  0000              XX912B = $912B          ; VIA 2 ACR
01066  0000              XX912C = $912C          ; VIA 2 PCR
01067  0000              X
01068  0000              ; THE STATUS BIT IS A NOT NORMAL FLAG. IT GOES HI
GH IF BOTH AN INTERRUPT FLAG IN THE IFR
01069  0000              ; AND THE CORRESPONDING ENABLE BIT IN THE IER ARE
 SET. IT CAN BE CLEARED ONLY BY CLEARING
01070  0000              ; ALL THE ACTIVE FLAGS IN THE IFR OR DISABLING AL
L ACTIVE INTERRUPTS IN THE IER
01071  0000              
01072  0000              XX912D = $912D          ; VIA 1 IFR
01073  0000                                     ; BIT     FUNCTION        
  CLEARED BY
01074  0000                                     ; ---     --------        
  ----------
01075  0000                                     ;  7     INTERRUPT STATUS 
    CLEARING ALL ENABLED INTERRUPTS
01076  0000                                     ;  6     T1 INTERRUPT     
READ T1C_L, WRITE T1C_H
01077  0000                                     ;  5     T2 INTERRUPT     
READ T2C_L, WRITE T2C_H
01078  0000                                     ;  4     CB1 TRANSITION   
  READ OR WRITE PORT B
01079  0000                                     ;  3     CB2 TRANSITION   
  READ OR WRITE PORT B
01080  0000                                     ;  2     8 SHIFTS DONE    
 READ OR WRITE THE SHIFT REGISTER
01081  0000                                     ;  1     CA1 TRANSITION   
  READ OR WRITE PORT A
01082  0000                                     ;  0     CA2 TRANSITION   
  READ OR WRITE PORT A
01083  0000                     
01084  0000              ; IF ENABLE/DISABLE BIT IS A ZERO DURING A WRITE 
TO THIS REGISTER, EACH 1 IN BITS 0-6
01085  0000              ; CLEARS THE CORRESPONDING BIT IN THE IER. IF THI
S BIT IS A ONE DURING A WRITE TO THIS
01086  0000              ; REGISTER, EACH 1 IN BITS 0-6 WILL SET THE CORRE
SPONDING IER BIT
01087  0000              
01088  0000              XX912E = $912E          ; VIA 1 IER
01089  0000                                     ; BIT     FUNCTION
01090  0000                                     ; ---     --------
01091  0000                                     ;  7     ENABLE/DISABLE
01092  0000                                     ;  6     T1 INTERRUPT
01093  0000                                     ;  5     T2 INTERRUPT
01094  0000                                     ;  4     CB1 TRANSITION
01095  0000                                     ;  3     CB2 TRANSITION
01096  0000                                     ;  2     8 SHIFTS DONE
01097  0000                                     ;  1     CA1 TRANSITION
01098  0000                                     ;  0     CA2 TRANSITION
01099  0000                     
01100  0000              XX912F = $912F          ; VIA 2 DRA, KEYBOARD ROW
, NO HANDSHAKE






O THIS......PAGE 0021

LINE# LOC   CODE        LINE


01101  0000              X
01102  0000              XXA000 = $A000          ; AUTOSTART ROM INITIAL E
NTRY VECTOR
01103  0000              XXA002 = $A002          ; AUTOSTART ROM BREAK ENT
RY
01104  0000              XXA004 = $A004          ; AUTOSTART ROM IDENTIFIE
R STRING START
01105  0000              X
01106  0000              X
01107  0000              ;************************************************
***********************************;
01108  0000              ;
01109  0000              ; BASIC KEYWORD TOKEN VALUES. TOKENS NOT USED IN 
THE SOURCE ARE INCLUDED FOR
01110  0000              ; COMPLETENESS BUT COMMENTED OUT
01111  0000              
01112  0000              ; COMMAND TOKENS
01113  0000              
01114  0000              ;TEND     = $80               ; END TOKEN
01115  0000              TFOR   = $81               ; FOR TOKEN
01116  0000              ;TNEXT     = $82               ; NEXT TOKEN
01117  0000              TDATA  = $83               ; DATA TOKEN
01118  0000              ;TINFL     = $84               ; INPUT# TOKEN
01119  0000              ;TINPUT     = $85               ; INPUT TOKEN
01120  0000              ;TDIM     = $86               ; DIM TOKEN
01121  0000              ;TREAD     = $87               ; READ TOKEN
01122  0000              
01123  0000              ;TLET     = $88               ; LET TOKEN
01124  0000              TGOTO  = $89               ; GOTO TOKEN
01125  0000              ;TRUN     = $8A               ; RUN TOKEN
01126  0000              ;TIF     = $8B               ; IF TOKEN
01127  0000              ;TRESTORE     = $8C               ; RESTORE TOKEN

01128  0000              TGOSUB = $8D               ; GOSUB TOKEN
01129  0000              ;TRETURN     = $8E               ; RETURN TOKEN
01130  0000              TREM   = $8F               ; REM TOKEN
01131  0000              T
01132  0000              ;TSTOP     = $90               ; STOP TOKEN
01133  0000              ;TON     = $91               ; ON TOKEN
01134  0000              ;TWAIT     = $92               ; WAIT TOKEN
01135  0000              ;TLOAD     = $93               ; LOAD TOKEN
01136  0000              ;TSAVE     = $94               ; SAVE TOKEN
01137  0000              ;TVERIFY     = $95               ; VERIFY TOKEN
01138  0000              ;TDEF     = $96               ; DEF TOKEN
01139  0000              ;TPOKE     = $97               ; POKE TOKEN
01140  0000              
01141  0000              ;TPRINFL     = $98               ; PRINT# TOKEN
01142  0000              TPRINT = $99               ; PRINT TOKEN
01143  0000              ;TCONT     = $9A               ; CONT TOKEN
01144  0000              ;TLIST     = $9B               ; LIST TOKEN
01145  0000              ;TCLR     = $9C               ; CLR TOKEN
01146  0000              ;TCMD     = $9D               ; CMD TOKEN
01147  0000              ;TSYS     = $9E               ; SYS TOKEN
01148  0000              ;TOPEN     = $9F               ; OPEN TOKEN
01149  0000              
01150  0000              ;TCLOSE     = $A0               ; CLOSE TOKEN
01151  0000              ;TGET     = $A1               ; GET TOKEN
01152  0000              ;TNEW     = $A2               ; NEW TOKEN
01153  0000              
01154  0000              ; SECONDARY KEYWORD TOKENS
01155  0000              






****;S......PAGE 0022

LINE# LOC   CODE        LINE


01156  0000              TTAB   = $A3               ; TAB( TOKEN
01157  0000              TTO    = $A4               ; TO TOKEN
01158  0000              TFN    = $A5               ; FN TOKEN
01159  0000              TSPC   = $A6               ; SPC( TOKEN
01160  0000              TTHEN  = $A7               ; THEN TOKEN
01161  0000              T
01162  0000              TNOT   = $A8               ; NOT TOKEN
01163  0000              TSTEP  = $A9               ; STEP TOKEN
01164  0000              T
01165  0000              ; OPERATOR TOKENS
01166  0000              
01167  0000              TPLUS  = $AA               ; + TOKEN
01168  0000              TMINUS = $AB               ; - TOKEN
01169  0000              ;TMUL     = $AC               ; * TOKEN
01170  0000              ;TDIV     = $AD               ; / TOKEN
01171  0000              ;TPOWER     = $AE               ; ^ TOKEN
01172  0000              ;TAND     = $AF               ; AND TOKEN
01173  0000              
01174  0000              ;TOR     = $B0               ; OR TOKEN
01175  0000              TGT    = $B1               ; > TOKEN
01176  0000              TEQUAL = $B2               ; = TOKEN
01177  0000              ;TLT     = $B3               ; < TOKEN
01178  0000              
01179  0000              ; FUNCTION TOKENS
01180  0000              
01181  0000              TSGN   = $B4               ; SGN TOKEN
01182  0000              ;TINT     = $B5               ; INT TOKEN
01183  0000              ;TABS     = $B6               ; ABS TOKEN
01184  0000              ;TUSR     = $B7               ; USR TOKEN
01185  0000              
01186  0000              ;TFRE     = $B8               ; FRE TOKEN
01187  0000              ;TPOS     = $B9               ; POS TOKEN
01188  0000              ;TSQR     = $BA               ; SQR TOKEN
01189  0000              ;TRND     = $BB               ; RND TOKEN
01190  0000              ;TLOG     = $BC               ; LOG TOKEN
01191  0000              ;TEXP     = $BD               ; EXP TOKEN
01192  0000              ;TCOS     = $BE               ; COS TOKEN
01193  0000              ;TSIN     = $BF               ; SIN TOKEN
01194  0000              
01195  0000              ;TTAN     = $C0               ; TAN TOKEN
01196  0000              ;TATN     = $C1               ; ATN TOKEN
01197  0000              ;TPEEK     = $C2               ; PEEK TOKEN
01198  0000              ;TLEN     = $C3               ; LEN TOKEN
01199  0000              ;TSTRS     = $C4               ; STR$ TOKEN
01200  0000              ;TVAL     = $C5               ; VAL TOKEN
01201  0000              ;TASC     = $C6               ; ASC TOKEN
01202  0000              ;TCHRS     = $C7               ; CHR$ TOKEN
01203  0000              
01204  0000              ;TLEFTS     = $C8               ; LEFT$ TOKEN
01205  0000              ;TRIGHTS     = $C9               ; RIGHT$ TOKEN
01206  0000              ;TMIDS     = $CA               ; MID$ TOKEN
01207  0000              TGO    = $CB               ; GO TOKEN
01208  0000              T
01209  0000              TPI    = $FF               ; PI TOKEN
01210  0000              T






****;S......PAGE 0023

LINE# LOC   CODE        LINE


01211  0000              T
01212  0000              ;************************************************
***********************************;
01213  0000              ;************************************************
***********************************;
01214  0000              ;
01215  0000              ; ROM START
01216  0000              
01217  0000              *      = $C000         ;     .ORG     $C000
01218  C000              *
01219  C000              XXC000 = *
01220  C000  78 E3              .WORD     XXE378          ; BASIC COLD STA
RT ENTRY POINT
01221  C002                     
01222  C002              XXC002 = *
01223  C002  67 E4              .WORD     XXE467          ; BASIC WARM STA
RT ENTRY POINT
01224  C004                     
01225  C004              XXC004 = *
01226  C004  43 42              .BYTE     'CBMBASIC'          ; ROM NAME, 
UNREFERENCED
01227  C00C                     
01228  C00C                     
01229  C00C              ;************************************************
***********************************;
01230  C00C              ;
01231  C00C              ; ACTION ADDRESSES FOR PRIMARY COMMANDS. THESE AR
E CALLED BY PUSHING THE ADDRESS
01232  C00C              ; ONTO THE STACK AND DOING AN RTS SO THE ACTUAL A
DDRESS -1 NEEDS TO BE PUSHED
01233  C00C              
01234  C00C              XXC00C = *
01235  C00C  30 C8              .WORD     XXC831-1          ; PERFORM END
01236  C00E  41 C7              .WORD     XXC742-1          ; PERFORM FOR
01237  C010  1D CD              .WORD     XXCD1E-1          ; PERFORM NEXT

01238  C012  F7 C8              .WORD     XXC8F8-1          ; PERFORM DATA

01239  C014  A4 CB              .WORD     XXCBA5-1          ; PERFORM INPU
T#
01240  C016  BE CB              .WORD     XXCBBF-1          ; PERFORM INPU
T
01241  C018  80 D0              .WORD     XXD081-1          ; PERFORM DIM
01242  C01A  05 CC              .WORD     XXCC06-1          ; PERFORM READ

01243  C01C                     
01244  C01C  A4 C9              .WORD     XXC9A5-1          ; PERFORM LET
01245  C01E  9F C8              .WORD     XXC8A0-1          ; PERFORM GOTO

01246  C020  70 C8              .WORD     XXC871-1          ; PERFORM RUN
01247  C022  27 C9              .WORD     XXC928-1          ; PERFORM IF
01248  C024  1C C8              .WORD     XXC81D-1          ; PERFORM REST
ORE
01249  C026  82 C8              .WORD     XXC883-1          ; PERFORM GOSU
B
01250  C028  D1 C8              .WORD     XXC8D2-1          ; PERFORM RETU
RN
01251  C02A  3A C9              .WORD     XXC93B-1          ; PERFORM REM
01252  C02C                     
01253  C02C  2E C8              .WORD     XXC82F-1          ; PERFORM STOP

01254  C02E  4A C9              .WORD     XXC94B-1          ; PERFORM ON
01255  C030  2C D8              .WORD     XXD82D-1          ; PERFORM WAIT

01256  C032  64 E1              .WORD     XXE165-1          ; PERFORM LOAD

01257  C034  52 E1              .WORD     XXE153-1          ; PERFORM SAVE

01258  C036  61 E1              .WORD     XXE162-1          ; PERFORM VERI
FY
01259  C038  B2 D3              .WORD     XXD3B3-1          ; PERFORM DEF
01260  C03A  23 D8              .WORD     XXD824-1          ; PERFORM POKE

01261  C03C                     
01262  C03C  7F CA              .WORD     XXCA80-1          ; PERFORM PRIN
T#
01263  C03E  9F CA              .WORD     XXCAA0-1          ; PERFORM PRIN
T
01264  C040  56 C8              .WORD     XXC857-1          ; PERFORM CONT

01265  C042  9B C6              .WORD     XXC69C-1          ; PERFORM LIST







****;S......PAGE 0024

LINE# LOC   CODE        LINE


01266  C044  5D C6              .WORD     XXC65E-1          ; PERFORM CLR
01267  C046  85 CA              .WORD     XXCA86-1          ; PERFORM CMD
01268  C048  26 E1              .WORD     XXE127-1          ; PERFORM SYS
01269  C04A  BA E1              .WORD     XXE1BB-1          ; PERFORM OPEN

01270  C04C                     
01271  C04C  C3 E1              .WORD     XXE1C4-1          ; PERFORM CLOS
E
01272  C04E  7A CB              .WORD     XXCB7B-1          ; PERFORM GET
01273  C050  41 C6              .WORD     XXC642-1          ; PERFORM NEW
01274  C052                     
01275  C052                     
01276  C052              ;************************************************
***********************************;
01277  C052              ;
01278  C052              ; ACTION ADDRESSES FOR FUNCTIONS
01279  C052              
01280  C052              XXC052 = *
01281  C052  39 DC              .WORD     XXDC39          ; PERFORM SGN()
01282  C054  CC DC              .WORD     XXDCCC          ; PERFORM INT()
01283  C056  58 DC              .WORD     XXDC58          ; PERFORM ABS()
01284  C058  00 00              .WORD     XX00          ; PERFORM USR()
01285  C05A                     
01286  C05A  7D D3              .WORD     XXD37D          ; PERFORM FRE()
01287  C05C  9E D3              .WORD     XXD39E          ; PERFORM POS()
01288  C05E  71 DF              .WORD     XXDF71          ; PERFORM SQR()
01289  C060  94 E0              .WORD     XXE094          ; PERFORM RND()
01290  C062  EA D9              .WORD     XXD9EA          ; PERFORM LOG()
01291  C064  ED DF              .WORD     XXDFED          ; PERFORM EXP()
01292  C066  61 E2              .WORD     XXE261          ; PERFORM COS()
01293  C068  68 E2              .WORD     XXE268          ; PERFORM SIN()
01294  C06A                     
01295  C06A  B1 E2              .WORD     XXE2B1          ; PERFORM TAN()
01296  C06C  0B E3              .WORD     XXE30B          ; PERFORM ATN()
01297  C06E  0D D8              .WORD     XXD80D          ; PERFORM PEEK()

01298  C070  7C D7              .WORD     XXD77C          ; PERFORM LEN()
01299  C072  65 D4              .WORD     XXD465          ; PERFORM STR$()

01300  C074  AD D7              .WORD     XXD7AD          ; PERFORM VAL()
01301  C076  8B D7              .WORD     XXD78B          ; PERFORM ASC()
01302  C078  EC D6              .WORD     XXD6EC          ; PERFORM CHR$()

01303  C07A                     
01304  C07A  00 D7              .WORD     XXD700          ; PERFORM LEFT$(
)
01305  C07C  2C D7              .WORD     XXD72C          ; PERFORM RIGHT$
()
01306  C07E  37 D7              .WORD     XXD737          ; PERFORM MID$()

01307  C080                     
01308  C080                     
01309  C080              ;************************************************
***********************************;
01310  C080              ;
01311  C080              ; PRECEDENCE BYTE AND ACTION ADDRESSES FOR OPERAT
ORS. LIKE THE PRIMARRY COMMANDS THESE
01312  C080              ; ARE CALLED BY PUSHING THE ADDRESS ONTO THE STAC
K AND DOING AN RTS, SO AGAIN THE ACTUAL
01313  C080              ; ADDRESS -1 NEEDS TO BE PUSHED
01314  C080              
01315  C080              XXC080 = *
01316  C080  79                 .BYTE     $79
01317  C081  69 D8              .WORD     XXD86A-1          ; +
01318  C083  79                 .BYTE     $79
01319  C084  52 D8              .WORD     XXD853-1          ; -
01320  C086  7B                 .BYTE     $7B






E ACTU......PAGE 0025

LINE# LOC   CODE        LINE


01321  C087  2A DA              .WORD     XXDA2B-1          ; *
01322  C089  7B                 .BYTE     $7B
01323  C08A  11 DB              .WORD     XXDB12-1          ; /
01324  C08C  7F                 .BYTE     $7F
01325  C08D  7A DF              .WORD     XXDF7B-1          ; ^
01326  C08F  50                 .BYTE     $50
01327  C090  E8 CF              .WORD     XXCFE9-1          ; AND
01328  C092  46                 .BYTE     $46
01329  C093  E5 CF              .WORD     XXCFE6-1          ; OR
01330  C095  7D                 .BYTE     $7D
01331  C096  B3 DF              .WORD     XXDFB4-1          ; >
01332  C098  5A                 .BYTE     $5A
01333  C099  D3 CE              .WORD     XXCED4-1          ; =
01334  C09B              XXC09B = *
01335  C09B  64                 .BYTE     $64
01336  C09C  15 D0              .WORD     XXD016-1          ; <
01337  C09E                     
01338  C09E                     
01339  C09E              ;************************************************
***********************************;
01340  C09E              ;
01341  C09E              ; BASIC KEYWORDS. EACH WORD HAS B7 SET IN IT'S LA
ST CHARACTER AS AN END MARKER,
01342  C09E              ; EVEN THE ONE CHARACTER KEYWORDS SUCH AS '<' OR 
'='
01343  C09E              
01344  C09E              ; FIRST ARE THE PRIMARY COMMAND KEYWORDS, ONLY TH
ESE CAN START A STATEMENT
01345  C09E              
01346  C09E              XXC09E = *
01347  C09E  45 4E              .BYTE     'EN',$C4     ;'D'+$80     ; END
01347  C0A0  C4 
01348  C0A1  46 4F              .BYTE     'FO',$D2     ;'R'+$80     ; FOR
01348  C0A3  D2 
01349  C0A4  4E 45 58           .BYTE     'NEX',$D4    ;'T'+$80     ; NEXT

01349  C0A7  D4 
01350  C0A8  44 41 54           .BYTE     'DAT',$C1    ;'A'+$80     ; DATA

01350  C0AB  C1 
01351  C0AC  49 4E              .BYTE     'INPUT',$A3  ;'#'+$80     ; INPU
T#
01351  C0B1  A3 
01352  C0B2  49 4E              .BYTE     'INPU',$D4   ;'T'+$80     ; INPU
T
01352  C0B6  D4 
01353  C0B7  44 49              .BYTE     'DI',$CD     ;'M'+$80     ; DIM
01353  C0B9  CD 
01354  C0BA  52 45 41           .BYTE     'REA',$C4    ;'D'+$80     ; READ

01354  C0BD  C4 
01355  C0BE                     
01356  C0BE  4C 45              .BYTE     'LE',$D4     ;'T'+$80     ; LET
01356  C0C0  D4 
01357  C0C1  47 4F 54           .BYTE     'GOT',$CF    ;'O'+$80     ; GOTO

01357  C0C4  CF 
01358  C0C5  52 55              .BYTE     'RU',$CE     ;'N'+$80     ; RUN
01358  C0C7  CE 
01359  C0C8  49                 .BYTE     'I',$C6      ;'F'+$80     ; IF
01359  C0C9  C6 
01360  C0CA  52 45              .BYTE     'RESTOR',$C5 ;'E'+$80     ; REST
ORE
01360  C0D0  C5 
01361  C0D1  47 4F              .BYTE     'GOSU',$C2   ;'B'+$80     ; GOSU
B
01361  C0D5  C2 






****;U......PAGE 0026

LINE# LOC   CODE        LINE


01362  C0D6  52 45              .BYTE     'RETUR',$CE  ;'N'+$80     ; RETU
RN
01362  C0DB  CE 
01363  C0DC  52 45              .BYTE     'RE',$CD     ;'M'+$80     ; REM
01363  C0DE  CD 
01364  C0DF                     
01365  C0DF  53 54 4F           .BYTE     'STO',$D0    ;'P'+$80     ; STOP

01365  C0E2  D0 
01366  C0E3  4F                 .BYTE     'O',$CE      ;'N'+$80     ; ON
01366  C0E4  CE 
01367  C0E5  57 41 49           .BYTE     'WAI',$D4    ;'T'+$80     ; WAIT

01367  C0E8  D4 
01368  C0E9  4C 4F 41           .BYTE     'LOA',$C4    ;'D'+$80     ; LOAD

01368  C0EC  C4 
01369  C0ED  53 41 56           .BYTE     'SAV',$C5    ;'E'+$80     ; SAVE

01369  C0F0  C5 
01370  C0F1  56 45              .BYTE     'VERIF',$D9  ;'Y'+$80     ; VERI
FY
01370  C0F6  D9 
01371  C0F7  44 45              .BYTE     'DE',$C6     ;'F'+$80     ; DEF
01371  C0F9  C6 
01372  C0FA  50 4F 4B           .BYTE     'POK',$C5    ;'E'+$80     ; POKE

01372  C0FD  C5 
01373  C0FE                     
01374  C0FE  50 52              .BYTE     'PRINT',$A3  ;'#'+$80     ; PRIN
T#
01374  C103  A3 
01375  C104  50 52              .BYTE     'PRIN',$D4   ;'T'+$80     ; PRIN
T
01375  C108  D4 
01376  C109  43 4F 4E           .BYTE     'CON',$D4    ;'T'+$80     ; CONT

01376  C10C  D4 
01377  C10D  4C 49 53           .BYTE     'LIS',$D4    ;'T'+$80     ; LIST

01377  C110  D4 
01378  C111  43 4C              .BYTE     'CL',$D2     ;'R'+$80     ; CLR
01378  C113  D2 
01379  C114  43 4D              .BYTE     'CM',$C4     ;'D'+$80     ; CMD
01379  C116  C4 
01380  C117  53 59              .BYTE     'SY',$D3     ;'S'+$80     ; SYS
01380  C119  D3 
01381  C11A  4F 50 45           .BYTE     'OPE',$CE    ;'N'+$80     ; OPEN

01381  C11D  CE 
01382  C11E                     
01383  C11E  43 4C              .BYTE     'CLOS',$C5   ;'E'+$80     ; CLOS
E
01383  C122  C5 
01384  C123  47 45              .BYTE     'GE',$D4     ;'T'+$80     ; GET
01384  C125  D4 
01385  C126  4E 45              .BYTE     'NE',$D7     ;'W'+$80     ; NEW
01385  C128  D7 
01386  C129                     
01387  C129              ; NEXT ARE THE SECONDARY COMMAND KEYWORDS, THESE 
CAN NOT START A STATEMENT
01388  C129              
01389  C129  54 41 42           .BYTE     'TAB',$A8    ;'('+$80     ; TAB(

01389  C12C  A8 
01390  C12D  54                 .BYTE     'T',$CF      ;'O'+$80     ; TO
01390  C12E  CF 
01391  C12F  46                 .BYTE     'F',$CE      ;'N'+$80     ; FN
01391  C130  CE 
01392  C131  53 50 43           .BYTE     'SPC',$A8    ;'('+$80     ; SPC(







****;U......PAGE 0027

LINE# LOC   CODE        LINE


01392  C134  A8 
01393  C135  54 48 45           .BYTE     'THE',$CE    ;'N'+$80     ; THEN

01393  C138  CE 
01394  C139                     
01395  C139  4E 4F              .BYTE     'NO',$D4     ;'T'+$80     ; NOT
01395  C13B  D4 
01396  C13C  53 54 45           .BYTE     'STE',$D0    ;'P'+$80     ; STEP

01396  C13F  D0 
01397  C140                     
01398  C140              ; THE OPERATORS
01399  C140              
01400  C140  AB                 .BYTE     $AB          ;'+'+$80     ; +
01401  C141  AD                 .BYTE     $AD          ;'-'+$80     ; -
01402  C142  AA                 .BYTE     $AA          ;'*'+$80     ; *
01403  C143  AF                 .BYTE     $AF          ;'/'+$80     ; /
01404  C144  DE                 .BYTE     $DE          ;'^'+$80     ; ^
01405  C145  41 4E              .BYTE     'AN',$C4     ;'D'+$80     ; AND
01405  C147  C4 
01406  C148                     
01407  C148  4F                 .BYTE     'O',$D2      ;'R'+$80     ; OR
01407  C149  D2 
01408  C14A  BE                 .BYTE     $BE          ;'>'+$80     ; >
01409  C14B  BD                 .BYTE     $BD          ;'='+$80     ; =
01410  C14C  BC                 .BYTE     $BC          ;'<'+$80     ; <
01411  C14D                     
01412  C14D              ; THE FUNCTIONS
01413  C14D              
01414  C14D  53 47              .BYTE     'SG',$CE     ;'N'+$80     ; SGN
01414  C14F  CE 
01415  C150  49 4E              .BYTE     'IN',$D4     ;'T'+$80     ; INT
01415  C152  D4 
01416  C153  41 42              .BYTE     'AB',$D3     ;'S'+$80     ; ABS
01416  C155  D3 
01417  C156  55 53              .BYTE     'US',$D2     ;'R'+$80     ; USR
01417  C158  D2 
01418  C159                     
01419  C159  46 52              .BYTE     'FR',$C5     ;'E'+$80     ; FRE
01419  C15B  C5 
01420  C15C  50 4F              .BYTE     'PO',$D3     ;'S'+$80     ; POS
01420  C15E  D3 
01421  C15F  53 51              .BYTE     'SQ',$D2     ;'R'+$80     ; SQR
01421  C161  D2 
01422  C162  52 4E              .BYTE     'RN',$C4     ;'D'+$80     ; RND
01422  C164  C4 
01423  C165  4C 4F              .BYTE     'LO',$C7     ;'G'+$80     ; LOG
01423  C167  C7 
01424  C168  45 58              .BYTE     'EX',$D0     ;'P'+$80     ; EXP
01424  C16A  D0 
01425  C16B  43 4F              .BYTE     'CO',$D3     ;'S'+$80     ; COS
01425  C16D  D3 
01426  C16E  53 49              .BYTE     'SI',$CE     ;'N'+$80     ; SIN
01426  C170  CE 
01427  C171                     
01428  C171  54 41              .BYTE     'TA',$CE     ;'N'+$80     ; TAN
01428  C173  CE 






****;U......PAGE 0028

LINE# LOC   CODE        LINE


01429  C174  41 54              .BYTE     'AT',$CE     ;'N'+$80     ; ATN
01429  C176  CE 
01430  C177  50 45 45           .BYTE     'PEE',$CB    ;'K'+$80   ; PEEK
01430  C17A  CB 
01431  C17B  4C 45              .BYTE     'LE',$CE     ;'N'+$80     ; LEN
01431  C17D  CE 
01432  C17E  53 54 52           .BYTE     'STR',$A4    ;'$'+$80     ; STR$

01432  C181  A4 
01433  C182  56 41              .BYTE     'VA',$CC     ;'L'+$80     ; VAL
01433  C184  CC 
01434  C185  41 53              .BYTE     'AS',$C3     ;'C'+$80     ; ASC
01434  C187  C3 
01435  C188  43 48 52           .BYTE     'CHR',$A4    ;'$'+$80     ; CHR$

01435  C18B  A4 
01436  C18C                     
01437  C18C  4C 45              .BYTE     'LEFT',$A4   ;'$'+$80     ; LEFT
$
01437  C190  A4 
01438  C191  52 49              .BYTE     'RIGHT',$A4  ;'$'+$80     ; RIGH
T$
01438  C196  A4 
01439  C197  4D 49 44           .BYTE     'MID',$A4    ;'$'+$80     ; MID$

01439  C19A  A4 
01440  C19B                     
01441  C19B              ; LASTLY IS GO, THIS IS AN ADD ON SO THAT GO TO, 
AS WELL AS GOTO, WILL WORK
01442  C19B              
01443  C19B  47                 .BYTE     'G',$CF      ;'O'+$80     ; GO
01443  C19C  CF 
01444  C19D                     
01445  C19D  00                 .BYTE     $00                       ; END 
MARKER
01446  C19E                     
01447  C19E                     
01448  C19E              ;************************************************
***********************************;
01449  C19E              ;
01450  C19E              ; ERROR MESSAGES
01451  C19E              
01452  C19E              XXC19E = *
01453  C19E  54 4F              .BYTE     'TOO MANY FILE',$D3        ;'S'+
$80
01453  C1AB  D3 
01454  C1AC              XXC1AC = *
01455  C1AC  46 49              .BYTE     'FILE OPE',$CE             ;'N'+
$80
01455  C1B4  CE 
01456  C1B5              XXC1B5 = *
01457  C1B5  46 49              .BYTE     'FILE NOT OPE',$CE         ;'N'+
$80
01457  C1C1  CE 
01458  C1C2              XXC1C2 = *
01459  C1C2  46 49              .BYTE     'FILE NOT FOUN',$C4        ;'D'+
$80
01459  C1CF  C4 
01460  C1D0              XXC1D0 = *
01461  C1D0  44 45              .BYTE     'DEVICE NOT PRESEN',$D4    ;'T'+
$80
01461  C1E1  D4 
01462  C1E2              XXC1E2 = *
01463  C1E2  4E 4F              .BYTE     'NOT INPUT FIL',$C5        ;'E'+
$80
01463  C1EF  C5 
01464  C1F0              XXC1F0 = *
01465  C1F0  4E 4F              .BYTE     'NOT OUTPUT FIL',$C5       ;'E'+
$80
01465  C1FE  C5 






****;U......PAGE 0029

LINE# LOC   CODE        LINE


01466  C1FF              XXC1FF = *
01467  C1FF  4D 49              .BYTE     'MISSING FILE NAM',$C5     ;'E'+
$80
01467  C20F  C5 
01468  C210              XXC210 = *
01469  C210  49 4C              .BYTE     'ILLEGAL DEVICE NUMBE',$D2 ;'R'+
$80
01469  C224  D2 
01470  C225              XXC225 = *
01471  C225  4E 45              .BYTE     'NEXT WITHOUT FO',$D2      ;'R'+
$80
01471  C234  D2 
01472  C235              XXC235 = *
01473  C235  53 59              .BYTE     'SYNTA',$D8                ;'X'+
$80
01473  C23A  D8 
01474  C23B              XXC23B = *
01475  C23B  52 45              .BYTE     'RETURN WITHOUT GOSU',$C2  ;'B'+
$80
01475  C24E  C2 
01476  C24F              XXC24F = *
01477  C24F  4F 55              .BYTE     'OUT OF DAT',$C1           ;'A'+
$80
01477  C259  C1 
01478  C25A              XXC25A = *
01479  C25A  49 4C              .BYTE     'ILLEGAL QUANTIT',$D9      ;'Y'+
$80
01479  C269  D9 
01480  C26A              XXC26A = *
01481  C26A  4F 56              .BYTE     'OVERFLO',$D7              ;'W'+
$80
01481  C271  D7 
01482  C272              XXC272 = *
01483  C272  4F 55              .BYTE     'OUT OF MEMOR',$D9         ;'Y'+
$80
01483  C27E  D9 
01484  C27F              XXC27F = *
01485  C27F  55 4E              .BYTE     'UNDEF''D STATEMEN',$D4    ;'T'+
$80
01485  C28F  D4 
01486  C290              XXC290 = *
01487  C290  42 41              .BYTE     'BAD SUBSCRIP',$D4         ;'T'+
$80
01487  C29C  D4 
01488  C29D              XXC29D = *
01489  C29D  52 45              .BYTE     'REDIM''D ARRA',$D9        ;'Y'+
$80
01489  C2A9  D9 
01490  C2AA              XXC2AA = *
01491  C2AA  44 49              .BYTE     'DIVISION BY ZER',$CF      ;'O'+
$80
01491  C2B9  CF 
01492  C2BA              XXC2BA = *
01493  C2BA  49 4C              .BYTE     'ILLEGAL DIREC',$D4        ;'T'+
$80
01493  C2C7  D4 
01494  C2C8              XXC2C8 = *
01495  C2C8  54 59              .BYTE     'TYPE MISMATC',$C8         ;'H'+
$80
01495  C2D4  C8 
01496  C2D5              XXC2D5 = *
01497  C2D5  53 54              .BYTE     'STRING TOO LON',$C7       ;'G'+
$80
01497  C2E3  C7 
01498  C2E4              XXC2E4 = *
01499  C2E4  46 49              .BYTE     'FILE DAT',$C1             ;'A'+
$80
01499  C2EC  C1 
01500  C2ED              XXC2ED = *
01501  C2ED  46 4F              .BYTE     'FORMULA TOO COMPLE',$D8   ;'X'+
$80
01501  C2FF  D8 
01502  C300              XXC300 = *






****;U......PAGE 0030

LINE# LOC   CODE        LINE


01503  C300  43 41              .BYTE     'CAN''T CONTINU',$C5       ;'E'+
$80
01503  C30D  C5 
01504  C30E              XXC30E = *
01505  C30E  55 4E              .BYTE     'UNDEF''D FUNCTIO',$CE     ;'N'+
$80
01505  C31D  CE 
01506  C31E              XXC31E = *
01507  C31E  56 45              .BYTE     'VERIF',$D9                ;'Y'+
$80
01507  C323  D9 
01508  C324              XXC324 = *
01509  C324  4C 4F 41           .BYTE     'LOA',$C4                  ;'D'+
$80
01509  C327  C4 
01510  C328                     
01511  C328              ; ERROR MESSAGE POINTER TABLE
01512  C328              
01513  C328              XXC328 = *
01514  C328  9E C1              .WORD     XXC19E          ; $01     TOO MA
NY FILES
01515  C32A  AC C1              .WORD     XXC1AC          ; $02     FILE O
PEN
01516  C32C  B5 C1              .WORD     XXC1B5          ; $03     FILE N
OT OPEN
01517  C32E  C2 C1              .WORD     XXC1C2          ; $04     FILE N
OT FOUND
01518  C330  D0 C1              .WORD     XXC1D0          ; $05     DEVICE
 NOT PRESENT
01519  C332  E2 C1              .WORD     XXC1E2          ; $06     NOT IN
PUT FILE
01520  C334  F0 C1              .WORD     XXC1F0          ; $07     NOT OU
TPUT FILE
01521  C336  FF C1              .WORD     XXC1FF          ; $08     MISSIN
G FILE NAME
01522  C338  10 C2              .WORD     XXC210          ; $09     ILLEGA
L DEVICE NUMBER
01523  C33A  25 C2              .WORD     XXC225          ; $0A     NEXT W
ITHOUT FOR
01524  C33C  35 C2              .WORD     XXC235          ; $0B     SYNTAX

01525  C33E  3B C2              .WORD     XXC23B          ; $0C     RETURN
 WITHOUT GOSUB
01526  C340  4F C2              .WORD     XXC24F          ; $0D     OUT OF
 DATA
01527  C342  5A C2              .WORD     XXC25A          ; $0E     ILLEGA
L QUANTITY
01528  C344  6A C2              .WORD     XXC26A          ; $0F     OVERFL
OW
01529  C346  72 C2              .WORD     XXC272          ; $10     OUT OF
 MEMORY
01530  C348  7F C2              .WORD     XXC27F          ; $11     UNDEF'
D STATEMENT
01531  C34A  90 C2              .WORD     XXC290          ; $12     BAD SU
BSCRIPT
01532  C34C  9D C2              .WORD     XXC29D          ; $13     REDIM'
D ARRAY
01533  C34E  AA C2              .WORD     XXC2AA          ; $14     DIVISI
ON BY ZERO
01534  C350  BA C2              .WORD     XXC2BA          ; $15     ILLEGA
L DIRECT
01535  C352  C8 C2              .WORD     XXC2C8          ; $16     TYPE M
ISMATCH
01536  C354  D5 C2              .WORD     XXC2D5          ; $17     STRING
 TOO LONG
01537  C356  E4 C2              .WORD     XXC2E4          ; $18     FILE D
ATA
01538  C358  ED C2              .WORD     XXC2ED          ; $19     FORMUL
A TOO COMPLEX
01539  C35A  00 C3              .WORD     XXC300          ; $1A     CAN'T 
CONTINUE
01540  C35C  0E C3              .WORD     XXC30E          ; $1B     UNDEF'
D FUNCTION
01541  C35E  1E C3              .WORD     XXC31E          ; $1C     VERIFY

01542  C360  24 C3              .WORD     XXC324          ; $1D     LOAD
01543  C362  83 C3              .WORD     XXC383          ; $1E     BREAK
01544  C364                     
01545  C364                     
01546  C364              ;************************************************
***********************************;
01547  C364              ;
01548  C364              ; BASIC MESSAGES
01549  C364              
01550  C364              XXC364 = *
01551  C364  0D                 .BYTE     $0D,'OK',$0D,$00
01551  C365  4F 4B 
01551  C367  0D 






****;U......PAGE 0031

LINE# LOC   CODE        LINE


01551  C368  00 
01552  C369              XXC369 = *
01553  C369  0D                 .BYTE     $0D,' ERROR',$00
01553  C36A  20 45 
01553  C370  00 
01554  C371              XXC371 = *
01555  C371  20 49              .BYTE     ' IN ',$00
01555  C375  00 
01556  C376              XXC376 = *
01557  C376  0D                 .BYTE     $0D,$0A,'READY.',$0D,$0A,$00
01557  C377  0A 
01557  C378  52 45 
01557  C37E  0D 
01557  C37F  0A 
01557  C380  00 
01558  C381              XXC381 = *
01559  C381  0D                 .BYTE     $0D,$0A
01559  C382  0A 
01560  C383              XXC383 = *
01561  C383  42 52              .BYTE     'BREAK',$00
01561  C388  00 
01562  C389                     
01563  C389                     
01564  C389              ;************************************************
***********************************;
01565  C389              ;
01566  C389              ; SPARE BYTE, NOT REFERENCED
01567  C389              
01568  C389              ;XXC389
01569  C389  A0                 .BYTE     $A0
01570  C38A                     
01571  C38A                     
01572  C38A              ;************************************************
***********************************;
01573  C38A              ;
01574  C38A              ; SEARCH THE STACK FOR FOR OR GOSUB ACTIVITY
01575  C38A              ; RETURN ZB=1 IF FOR VARIABLE FOUND
01576  C38A              
01577  C38A              XXC38A = *
01578  C38A  BA                 TSX                    ; COPY STACK POINTE
R
01579  C38B  E8                 INX                    ; +1 PASS RETURN AD
DRESS
01580  C38C  E8                 INX                    ; +2 PASS RETURN AD
DRESS
01581  C38D  E8                 INX                    ; +3 PASS CALLING R
OUTINE RETURN ADDRESS
01582  C38E  E8                 INX                    ; +4 PASS CALLING R
OUTINE RETURN ADDRESS
01583  C38F              XXC38F = *
01584  C38F  BD 01 01           LDA     XX0100+1,X     ; GET TOKEN BYTE FR
OM STACK
01585  C392  C9 81              CMP     #TFOR          ; IS IT FOR TOKEN
01586  C394  D0 21              BNE     XXC3B7          ; EXIT IF NOT FOR 
TOKEN
01587  C396                     
01588  C396                                     ; WAS FOR TOKEN
01589  C396  A5 4A              LDA     XX4A          ; GET FOR/NEXT VARIA
BLE POINTER HIGH BYTE
01590  C398  D0 0A              BNE     XXC3A4          ; BRANCH IF NOT NU
LL
01591  C39A                     
01592  C39A  BD 02 01           LDA     XX0100+2,X     ; GET FOR VARIABLE 
POINTER LOW BYTE
01593  C39D  85 49              STA     XX49          ; SAVE FOR/NEXT VARI
ABLE POINTER LOW BYTE
01594  C39F  BD 03 01           LDA     XX0100+3,X     ; GET FOR VARIABLE 
POINTER HIGH BYTE
01595  C3A2  85 4A              STA     XX4A          ; SAVE FOR/NEXT VARI
ABLE POINTER HIGH BYTE






****;U......PAGE 0032

LINE# LOC   CODE        LINE


01596  C3A4              XXC3A4 = *
01597  C3A4  DD 03 01           CMP     XX0100+3,X     ; COMPARE VARIABLE 
POINTER WITH STACKED VARIABLE POINTER
01598  C3A7                                     ; HIGH BYTE
01599  C3A7  D0 07              BNE     XXC3B0          ; BRANCH IF NO MAT
CH
01600  C3A9                     
01601  C3A9  A5 49              LDA     XX49          ; GET FOR/NEXT VARIA
BLE POINTER LOW BYTE
01602  C3AB  DD 02 01           CMP     XX0100+2,X     ; COMPARE VARIABLE 
POINTER WITH STACKED VARIABLE POINTER
01603  C3AE                                     ; LOW BYTE
01604  C3AE  F0 07              BEQ     XXC3B7          ; EXIT IF MATCH FO
UND
01605  C3B0                     
01606  C3B0              XXC3B0 = *
01607  C3B0  8A                 TXA                    ; COPY INDEX
01608  C3B1  18                 CLC                    ; CLEAR CARRY FOR A
DD
01609  C3B2  69 12              ADC     #$12               ; ADD FOR STACK
 USE SIZE
01610  C3B4  AA                 TAX                    ; COPY BACK TO INDE
X
01611  C3B5  D0 D8              BNE     XXC38F          ; LOOP IF NOT AT S
TART OF STACK
01612  C3B7                     
01613  C3B7              XXC3B7 = *
01614  C3B7  60                 RTS
01615  C3B8                     
01616  C3B8                     
01617  C3B8              ;************************************************
***********************************;
01618  C3B8              ;
01619  C3B8              ; OPEN UP SPACE IN MEMORY, SET END OF ARRAYS
01620  C3B8              
01621  C3B8              XXC3B8 = *
01622  C3B8  20 08 C4           JSR     XXC408          ; CHECK AVAILABLE 
MEMORY, DO OUT OF MEMORY ERROR IF NO ROOM
01623  C3BB  85 31              STA     XX31          ; SET END OF ARRAYS 
LOW BYTE
01624  C3BD  84 32              STY     XX32          ; SET END OF ARRAYS 
HIGH BYTE
01625  C3BF                     
01626  C3BF              ; OPEN UP SPACE IN MEMORY, DON'T SET ARRAY END
01627  C3BF              
01628  C3BF              XXC3BF = *
01629  C3BF  38                 SEC                    ; SET CARRY FOR SUB
TRACT
01630  C3C0  A5 5A              LDA     XX5A          ; GET BLOCK END LOW 
BYTE
01631  C3C2  E5 5F              SBC     XX5F          ; SUBTRACT BLOCK STA
RT LOW BYTE
01632  C3C4  85 22              STA     XX22          ; SAVE MOD(BLOCK LEN
GTH/$100) BYTE
01633  C3C6  A8                 TAY                    ; COPY MOD(BLOCK LE
NGTH/$100) BYTE TO Y
01634  C3C7  A5 5B              LDA     XX5B          ; GET BLOCK END HIGH
 BYTE
01635  C3C9  E5 60              SBC     XX60          ; SUBTRACT BLOCK STA
RT HIGH BYTE
01636  C3CB  AA                 TAX                    ; COPY BLOCK LENGTH
 HIGH BYTE TO X
01637  C3CC  E8                 INX                    ; +1 TO ALLOW FOR C
OUNT=0 EXIT
01638  C3CD  98                 TYA                    ; COPY BLOCK LENGTH
 LOW BYTE TO A
01639  C3CE  F0 23              BEQ     XXC3F3          ; BRANCH IF LENGTH
 LOW BYTE=0
01640  C3D0                     
01641  C3D0                                     ; BLOCK IS (X-1)*256+Y BYT
ES, DO THE Y BYTES FIRST
01642  C3D0  A5 5A              LDA     XX5A          ; GET BLOCK END LOW 
BYTE
01643  C3D2  38                 SEC                    ; SET CARRY FOR SUB
TRACT
01644  C3D3  E5 22              SBC     XX22          ; SUBTRACT MOD(BLOCK
 LENGTH/$100) BYTE
01645  C3D5  85 5A              STA     XX5A          ; SAVE CORRECTED OLD
 BLOCK END LOW BYTE
01646  C3D7  B0 03              BCS     XXC3DC          ; IF NO UNDERFLOW 
SKIP THE HIGH BYTE DECREMENT
01647  C3D9                     
01648  C3D9  C6 5B              DEC     XX5B          ; ELSE DECREMENT BLO
CK END HIGH BYTE
01649  C3DB  38                 SEC                    ; SET CARRY FOR SUB
TRACT
01650  C3DC              XXC3DC = *






 NO RO......PAGE 0033

LINE# LOC   CODE        LINE


01651  C3DC  A5 58              LDA     XX58          ; GET DESTINATION EN
D LOW BYTE
01652  C3DE  E5 22              SBC     XX22          ; SUBTRACT MOD(BLOCK
 LENGTH/$100) BYTE
01653  C3E0  85 58              STA     XX58          ; SAVE MODIFIED NEW 
BLOCK END LOW BYTE
01654  C3E2  B0 08              BCS     XXC3EC          ; IF NO UNDERFLOW 
SKIP THE HIGH BYTE DECREMENT
01655  C3E4                     
01656  C3E4  C6 59              DEC     XX59          ; ELSE DECREMENT BLO
CK END HIGH BYTE
01657  C3E6  90 04              BCC     XXC3EC          ; BRANCH ALWAYS
01658  C3E8                     
01659  C3E8              XXC3E8 = *
01660  C3E8  B1 5A              LDA     (XX5A),Y          ; GET BYTE FROM 
SOURCE
01661  C3EA  91 58              STA     (XX58),Y          ; COPY BYTE TO D
ESTINATION
01662  C3EC              XXC3EC = *
01663  C3EC  88                 DEY                    ; DECREMENT INDEX
01664  C3ED  D0 F9              BNE     XXC3E8          ; LOOP UNTIL Y=0
01665  C3EF                     
01666  C3EF                                     ; NOW DO Y=0 INDEXED BYTE
01667  C3EF  B1 5A              LDA     (XX5A),Y          ; GET BYTE FROM 
SOURCE
01668  C3F1  91 58              STA     (XX58),Y          ; SAVE BYTE TO D
ESTINATION
01669  C3F3              XXC3F3 = *
01670  C3F3  C6 5B              DEC     XX5B          ; DECREMENT SOURCE P
OINTER HIGH BYTE
01671  C3F5  C6 59              DEC     XX59          ; DECREMENT DESTINAT
ION POINTER HIGH BYTE
01672  C3F7  CA                 DEX                    ; DECREMENT BLOCK C
OUNT
01673  C3F8  D0 F2              BNE     XXC3EC          ; LOOP UNTIL COUNT
 = $0
01674  C3FA                     
01675  C3FA  60                 RTS
01676  C3FB                     
01677  C3FB                     
01678  C3FB              ;************************************************
***********************************;
01679  C3FB              ;
01680  C3FB              ; CHECK THERE IS ROOM ON THE STACK FOR A BYTES
01681  C3FB              ; IF THE STACK IS TOO DEEP DO AN OUT OF MEMORY ER
ROR
01682  C3FB              
01683  C3FB              XXC3FB = *
01684  C3FB  0A                 ASL A                  ; *2
01685  C3FC  69 3E              ADC     #$3E               ; NEED AT LEAST
 $3E BYTES FREE
01686  C3FE  B0 35              BCS     XXC435          ; IF OVERFLOW GO D
O OUT OF MEMORY ERROR THEN WARM START
01687  C400                     
01688  C400  85 22              STA     XX22          ; SAVE RESULT IN TEM
P BYTE
01689  C402  BA                 TSX                    ; COPY STACK
01690  C403  E4 22              CPX     XX22          ; COMPARE NEW LIMIT 
WITH STACK
01691  C405  90 2E              BCC     XXC435          ; IF STACK < LIMIT
 DO OUT OF MEMORY ERROR THEN WARM START
01692  C407                     
01693  C407  60                 RTS
01694  C408                     
01695  C408                     
01696  C408              ;************************************************
***********************************;
01697  C408              ;
01698  C408              ; CHECK AVAILABLE MEMORY, DO OUT OF MEMORY ERROR 
IF NO ROOM
01699  C408              
01700  C408              XXC408 = *
01701  C408  C4 34              CPY     XX34          ; COMPARE WITH BOTTO
M OF STRING SPACE HIGH BYTE
01702  C40A  90 28              BCC     XXC434          ; IF LESS THEN EXI
T (IS OK)
01703  C40C                     
01704  C40C  D0 04              BNE     XXC412          ; SKIP NEXT TEST I
F GREATER (TESTED <)
01705  C40E                     






****;T......PAGE 0034

LINE# LOC   CODE        LINE


01706  C40E                                     ; HIGH BYTE WAS =, NOW DO 
LOW BYTE
01707  C40E  C5 33              CMP     XX33          ; COMPARE WITH BOTTO
M OF STRING SPACE LOW BYTE
01708  C410  90 22              BCC     XXC434          ; IF LESS THEN EXI
T (IS OK)
01709  C412                     
01710  C412                                     ; ADDRESS IS > STRING STOR
AGE PTR (OOPS!)
01711  C412              XXC412 = *
01712  C412  48                 PHA                    ; PUSH ADDRESS LOW 
BYTE
01713  C413  A2 09              LDX     #$09               ; SET INDEX TO 
SAVE XX57 TO XX60 INCLUSIVE
01714  C415  98                 TYA                    ; COPY ADDRESS HIGH
 BYTE (TO PUSH ON STACK)
01715  C416                     
01716  C416                                     ; SAVE MISC NUMERIC WORK A
REA
01717  C416              XXC416 = *
01718  C416  48                 PHA                    ; PUSH BYTE
01719  C417  B5 57              LDA     XX57,X          ; GET BYTE FROM XX
57 TO XX60
01720  C419  CA                 DEX                    ; DECREMENT INDEX
01721  C41A  10 FA              BPL     XXC416          ; LOOP UNTIL ALL D
ONE
01722  C41C                     
01723  C41C  20 26 D5           JSR     XXD526          ; DO GARBAGE COLLE
CTION ROUTINE
01724  C41F                     
01725  C41F                                     ; RESTORE MISC NUMERIC WOR
K AREA
01726  C41F  A2 F7              LDX     #$F7               ; SET INDEX TO 
RESTORE BYTES
01727  C421              XXC421 = *
01728  C421  68                 PLA                    ; POP BYTE
01729  C422  95 61              STA     XX60+1,X          ; SAVE BYTE TO X
X57 TO XX60
01730  C424  E8                 INX                    ; INCREMENT INDEX
01731  C425  30 FA              BMI     XXC421          ; LOOP WHILE -VE
01732  C427                     
01733  C427  68                 PLA                    ; POP ADDRESS HIGH 
BYTE
01734  C428  A8                 TAY                    ; COPY BACK TO Y
01735  C429  68                 PLA                    ; POP ADDRESS LOW B
YTE
01736  C42A  C4 34              CPY     XX34          ; COMPARE WITH BOTTO
M OF STRING SPACE HIGH BYTE
01737  C42C  90 06              BCC     XXC434          ; IF LESS THEN EXI
T (IS OK)
01738  C42E                     
01739  C42E  D0 05              BNE     XXC435          ; IF GREATER DO OU
T OF MEMORY ERROR THEN WARM START
01740  C430                     
01741  C430                                     ; HIGH BYTE WAS =, NOW DO 
LOW BYTE
01742  C430  C5 33              CMP     XX33          ; COMPARE WITH BOTTO
M OF STRING SPACE LOW BYTE
01743  C432  B0 01              BCS     XXC435          ; IF >= DO OUT OF 
MEMORY ERROR THEN WARM START
01744  C434                     
01745  C434                                     ; OK EXIT, CARRY CLEAR
01746  C434              XXC434 = *
01747  C434  60                 RTS
01748  C435                     
01749  C435                     
01750  C435              ;************************************************
***********************************;
01751  C435              ;
01752  C435              ; DO OUT OF MEMORY ERROR THEN WARM START
01753  C435              
01754  C435              XXC435 = *
01755  C435  A2 10              LDX     #$10               ; ERROR CODE $1
0, OUT OF MEMORY ERROR
01756  C437                     
01757  C437              ; DO ERROR #X THEN WARM START
01758  C437              
01759  C437              XXC437 = *
01760  C437  6C 00 03           JMP     (XX0300)          ; DO ERROR MESSA
GE






****;T......PAGE 0035

LINE# LOC   CODE        LINE


01761  C43A                     
01762  C43A              ; DO ERROR #X THEN WARM START, THE ERROR MESSAGE 
VECTOR IS INITIALISED TO POINT HERE
01763  C43A              
01764  C43A              XXC43A = *
01765  C43A  8A                 TXA                    ; COPY ERROR NUMBER

01766  C43B  0A                 ASL A                  ; *2
01767  C43C  AA                 TAX                    ; COPY TO INDEX
01768  C43D  BD 26 C3           LDA     XXC328-2,X     ; GET ERROR MESSAGE
 POINTER LOW BYTE
01769  C440  85 22              STA     XX22          ; SAVE IT
01770  C442  BD 27 C3           LDA     XXC328-1,X     ; GET ERROR MESSAGE
 POINTER HIGH BYTE
01771  C445  85 23              STA     XX23          ; SAVE IT
01772  C447  20 CC FF           JSR     XXFFCC          ; CLOSE INPUT AND 
OUTPUT CHANNELS
01773  C44A  A9 00              LDA     #$00               ; CLEAR A
01774  C44C  85 13              STA     XX13          ; CLEAR CURRENT I/O 
CHANNEL, FLAG DEFAULT
01775  C44E  20 D7 CA           JSR     XXCAD7          ; PRINT CR/LF
01776  C451  20 45 CB           JSR     XXCB45          ; PRINT '?'
01777  C454  A0 00              LDY     #$00               ; CLEAR INDEX
01778  C456              XXC456 = *
01779  C456  B1 22              LDA     (XX22),Y          ; GET BYTE FROM 
MESSAGE
01780  C458  48                 PHA                    ; SAVE STATUS
01781  C459  29 7F              AND     #$7F               ; MASK 0XXX XXX
X, CLEAR B7
01782  C45B  20 47 CB           JSR     XXCB47          ; OUTPUT CHARACTER

01783  C45E  C8                 INY                    ; INCREMENT INDEX
01784  C45F  68                 PLA                    ; RESTORE STATUS
01785  C460  10 F4              BPL     XXC456          ; LOOP IF CHARACTE
R WAS NOT END MARKER
01786  C462                     
01787  C462  20 7A C6           JSR     XXC67A          ; FLUSH BASIC STAC
K AND CLEAR CONTINUE POINTER
01788  C465  A9 69              LDA     #<XXC369          ; SET ' ERROR' P
OINTER LOW BYTE
01789  C467  A0 C3              LDY     #>XXC369          ; SET ' ERROR' P
OINTER HIGH BYTE
01790  C469                     
01791  C469                     
01792  C469              ;************************************************
***********************************;
01793  C469              ;
01794  C469              ; PRINT STRING AND DO WARM START, BREAK ENTRY
01795  C469              
01796  C469              XXC469 = *
01797  C469  20 1E CB           JSR     XXCB1E          ; PRINT NULL TERMI
NATED STRING
01798  C46C  A4 3A              LDY     XX3A          ; GET CURRENT LINE N
UMBER HIGH BYTE
01799  C46E  C8                 INY                    ; INCREMENT IT
01800  C46F  F0 03              BEQ     XXC474          ; BRANCH IF WAS IN
 IMMEDIATE MODE
01801  C471                     
01802  C471  20 C2 DD           JSR     XXDDC2          ; DO ' IN ' LINE N
UMBER MESSAGE
01803  C474                     
01804  C474                     
01805  C474              ;************************************************
***********************************;
01806  C474              ;
01807  C474              ; DO WARM START
01808  C474              
01809  C474              XXC474 = *
01810  C474  A9 76              LDA     #<XXC376          ; SET 'READY.' P
OINTER LOW BYTE
01811  C476  A0 C3              LDY     #>XXC376          ; SET 'READY.' P
OINTER HIGH BYTE
01812  C478  20 1E CB           JSR     XXCB1E          ; PRINT NULL TERMI
NATED STRING
01813  C47B  A9 80              LDA     #$80               ; SET FOR CONTR
OL MESSAGES ONLY
01814  C47D  20 90 FF           JSR     XXFF90          ; CONTROL KERNAL M
ESSAGES
01815  C480              XXC480 = *






****;T......PAGE 0036

LINE# LOC   CODE        LINE


01816  C480  6C 02 03           JMP     (XX0302)          ; DO BASIC WARM 
START
01817  C483                     
01818  C483                     
01819  C483              ;************************************************
***********************************;
01820  C483              ;
01821  C483              ; BASIC WARM START, THE WARM START VECTOR IS INIT
IALISED TO POINT HERE
01822  C483              
01823  C483              XXC483 = *
01824  C483  20 60 C5           JSR     XXC560          ; CALL FOR BASIC I
NPUT
01825  C486  86 7A              STX     XX7A          ; SAVE BASIC EXECUTE
 POINTER LOW BYTE
01826  C488  84 7B              STY     XX7B          ; SAVE BASIC EXECUTE
 POINTER HIGH BYTE
01827  C48A  20 73 00           JSR     XX0073          ; INCREMENT AND SC
AN MEMORY
01828  C48D  AA                 TAX                    ; COPY BYTE TO SET 
FLAGS
01829  C48E  F0 F0              BEQ     XXC480          ; LOOP IF NO INPUT

01830  C490                     
01831  C490              ; GOT TO INTERPRET INPUT LINE NOW ....
01832  C490              
01833  C490  A2 FF              LDX     #$FF               ; CURRENT LINE 
HIGH BYTE TO -1, INDICATES IMMEDIATE MODE
01834  C492  86 3A              STX     XX3A          ; SET CURRENT LINE N
UMBER HIGH BYTE
01835  C494  90 06              BCC     XXC49C          ; IF NUMERIC CHARA
CTER GO HANDLE NEW BASIC LINE
01836  C496                     
01837  C496                                     ; NO LINE NUMBER .. IMMEDI
ATE MODE
01838  C496  20 79 C5           JSR     XXC579          ; CRUNCH KEYWORDS 
INTO BASIC TOKENS
01839  C499  4C E1 C7           JMP     XXC7E1          ; GO SCAN AND INTE
RPRET CODE
01840  C49C                     
01841  C49C              ; HANDLE NEW BASIC LINE
01842  C49C              
01843  C49C              XXC49C = *
01844  C49C  20 6B C9           JSR     XXC96B          ; GET FIXED-POINT 
NUMBER INTO TEMPORARY INTEGER
01845  C49F  20 79 C5           JSR     XXC579          ; CRUNCH KEYWORDS 
INTO BASIC TOKENS
01846  C4A2  84 0B              STY     XX0B          ; SAVE INDEX POINTER
 TO END OF CRUNCHED LINE
01847  C4A4  20 13 C6           JSR     XXC613          ; SEARCH BASIC FOR
 TEMPORARY INTEGER LINE NUMBER
01848  C4A7  90 44              BCC     XXC4ED          ; IF NOT FOUND SKI
P THE LINE DELETE
01849  C4A9                     
01850  C4A9                                     ; LINE # ALREADY EXISTS SO
 DELETE IT
01851  C4A9  A0 01              LDY     #$01               ; SET INDEX TO 
NEXT LINE POINTER HIGH BYTE
01852  C4AB  B1 5F              LDA     (XX5F),Y          ; GET NEXT LINE 
POINTER HIGH BYTE
01853  C4AD  85 23              STA     XX23          ; SAVE IT
01854  C4AF  A5 2D              LDA     XX2D          ; GET START OF VARIA
BLES LOW BYTE
01855  C4B1  85 22              STA     XX22          ; SAVE IT
01856  C4B3  A5 60              LDA     XX60          ; GET FOUND LINE POI
NTER HIGH BYTE
01857  C4B5  85 25              STA     XX25          ; SAVE IT
01858  C4B7  A5 5F              LDA     XX5F          ; GET FOUND LINE POI
NTER LOW BYTE
01859  C4B9  88                 DEY                    ; DECREMENT INDEX
01860  C4BA  F1 5F              SBC     (XX5F),Y          ; SUBTRACT NEXT 
LINE POINTER LOW BYTE
01861  C4BC  18                 CLC                    ; CLEAR CARRY FOR A
DD
01862  C4BD  65 2D              ADC     XX2D          ; ADD START OF VARIA
BLES LOW BYTE
01863  C4BF  85 2D              STA     XX2D          ; SET START OF VARIA
BLES LOW BYTE
01864  C4C1  85 24              STA     XX24          ; SAVE DESTINATION P
OINTER LOW BYTE
01865  C4C3  A5 2E              LDA     XX2E          ; GET START OF VARIA
BLES HIGH BYTE
01866  C4C5  69 FF              ADC     #$FF               ; -1 + CARRY
01867  C4C7  85 2E              STA     XX2E          ; SET START OF VARIA
BLES HIGH BYTE
01868  C4C9  E5 60              SBC     XX60          ; SUBTRACT FOUND LIN
E POINTER HIGH BYTE
01869  C4CB  AA                 TAX                    ; COPY TO BLOCK COU
NT
01870  C4CC  38                 SEC                    ; SET CARRY FOR SUB
TRACT






ATE MO......PAGE 0037

LINE# LOC   CODE        LINE


01871  C4CD  A5 5F              LDA     XX5F          ; GET FOUND LINE POI
NTER LOW BYTE
01872  C4CF  E5 2D              SBC     XX2D          ; SUBTRACT START OF 
VARIABLES LOW BYTE
01873  C4D1  A8                 TAY                    ; COPY TO BYTES IN 
FIRST BLOCK COUNT
01874  C4D2  B0 03              BCS     XXC4D7          ; IF NO UNDERFLOW 
SKIP THE HIGH BYTE DECREMENT
01875  C4D4                     
01876  C4D4  E8                 INX                    ; INCREMENT BLOCK C
OUNT, CORRECT FOR = 0 LOOP EXIT
01877  C4D5  C6 25              DEC     XX25          ; DECREMENT DESTINAT
ION HIGH BYTE
01878  C4D7              XXC4D7 = *
01879  C4D7  18                 CLC                    ; CLEAR CARRY FOR A
DD
01880  C4D8  65 22              ADC     XX22          ; ADD SOURCE POINTER
 LOW BYTE
01881  C4DA  90 03              BCC     XXC4DF          ; IF NO UNDERFLOW 
SKIP THE HIGH BYTE DECREMENT
01882  C4DC                     
01883  C4DC  C6 23              DEC     XX23          ; ELSE DECREMENT SOU
RCE POINTER HIGH BYTE
01884  C4DE  18                 CLC                    ; CLEAR CARRY
01885  C4DF                     
01886  C4DF                                     ; CLOSE UP MEMORY TO DELET
E OLD LINE
01887  C4DF              XXC4DF = *
01888  C4DF  B1 22              LDA     (XX22),Y          ; GET BYTE FROM 
SOURCE
01889  C4E1  91 24              STA     (XX24),Y          ; COPY TO DESTIN
ATION
01890  C4E3  C8                 INY                    ; INCREMENT INDEX
01891  C4E4  D0 F9              BNE     XXC4DF          ; WHILE <> 0 DO TH
IS BLOCK
01892  C4E6                     
01893  C4E6  E6 23              INC     XX23          ; INCREMENT SOURCE P
OINTER HIGH BYTE
01894  C4E8  E6 25              INC     XX25          ; INCREMENT DESTINAT
ION POINTER HIGH BYTE
01895  C4EA  CA                 DEX                    ; DECREMENT BLOCK C
OUNT
01896  C4EB  D0 F2              BNE     XXC4DF          ; LOOP UNTIL ALL D
ONE
01897  C4ED                     
01898  C4ED                                     ; GOT NEW LINE IN BUFFER A
ND NO EXISTING SAME #
01899  C4ED              XXC4ED = *
01900  C4ED  20 59 C6           JSR     XXC659          ; RESET EXECUTION 
TO START, CLEAR VARIABLES, FLUSH STACK
01901  C4F0                                     ; AND RETURN
01902  C4F0  20 33 C5           JSR     XXC533          ; REBUILD BASIC LI
NE CHAINING
01903  C4F3  AD 00 02           LDA     XX0200          ; GET FIRST BYTE F
ROM BUFFER
01904  C4F6  F0 88              BEQ     XXC480          ; IF NO LINE GO DO
 BASIC WARM START
01905  C4F8                     
01906  C4F8                                     ; ELSE INSERT LINE INTO ME
MORY
01907  C4F8  18                 CLC                    ; CLEAR CARRY FOR A
DD
01908  C4F9  A5 2D              LDA     XX2D          ; GET START OF VARIA
BLES LOW BYTE
01909  C4FB  85 5A              STA     XX5A          ; SAVE AS SOURCE END
 POINTER LOW BYTE
01910  C4FD  65 0B              ADC     XX0B          ; ADD INDEX POINTER 
TO END OF CRUNCHED LINE
01911  C4FF  85 58              STA     XX58          ; SAVE AS DESTINATIO
N END POINTER LOW BYTE
01912  C501  A4 2E              LDY     XX2E          ; GET START OF VARIA
BLES HIGH BYTE
01913  C503  84 5B              STY     XX5B          ; SAVE AS SOURCE END
 POINTER HIGH BYTE
01914  C505  90 01              BCC     XXC508          ; IF NO CARRY SKIP
 THE HIGH BYTE INCREMENT
01915  C507                     
01916  C507  C8                 INY                    ; ELSE INCREMENT TH
E HIGH BYTE
01917  C508              XXC508 = *
01918  C508  84 59              STY     XX59          ; SAVE AS DESTINATIO
N END POINTER HIGH BYTE
01919  C50A  20 B8 C3           JSR     XXC3B8          ; OPEN UP SPACE IN
 MEMORY
01920  C50D                     
01921  C50D              ; MOST OF WHAT REMAINS TO DO IS COPY THE CRUNCHED
 LINE INTO THE SPACE OPENED UP IN MEMORY,
01922  C50D              ; HOWEVER, BEFORE THE CRUNCHED LINE COMES THE NEX
T LINE POINTER AND THE LINE NUMBER. THE
01923  C50D              ; LINE NUMBER IS RETRIEVED FROM THE TEMPORARY INT
EGER AND STORED IN MEMORY, THIS
01924  C50D              ; OVERWRITES THE BOTTOM TWO BYTES ON THE STACK. N
EXT THE LINE IS COPIED AND THE NEXT LINE
01925  C50D              ; POINTER IS FILLED WITH WHATEVER WAS IN TWO BYTE
S ABOVE THE LINE NUMBER IN THE STACK.






STACK.......PAGE 0038

LINE# LOC   CODE        LINE


01926  C50D              ; THIS IS OK BECAUSE THE LINE POINTER GETS FIXED 
IN THE LINE CHAIN RE-BUILD.
01927  C50D              
01928  C50D  A5 14              LDA     XX14          ; GET LINE NUMBER LO
W BYTE
01929  C50F  A4 15              LDY     XX15          ; GET LINE NUMBER HI
GH BYTE
01930  C511  8D FE 01           STA     XX01FE          ; SAVE LINE NUMBER
 LOW BYTE BEFORE CRUNCHED LINE
01931  C514  8C FF 01           STY     XX01FF          ; SAVE LINE NUMBER
 HIGH BYTE BEFORE CRUNCHED LINE
01932  C517  A5 31              LDA     XX31          ; GET END OF ARRAYS 
LOW BYTE
01933  C519  A4 32              LDY     XX32          ; GET END OF ARRAYS 
HIGH BYTE
01934  C51B  85 2D              STA     XX2D          ; SET START OF VARIA
BLES LOW BYTE
01935  C51D  84 2E              STY     XX2E          ; SET START OF VARIA
BLES HIGH BYTE
01936  C51F  A4 0B              LDY     XX0B          ; GET INDEX TO END O
F CRUNCHED LINE
01937  C521  88                 DEY                    ; -1
01938  C522              XXC522 = *
01939  C522  B9 FC 01           LDA     XX01FC,Y          ; GET BYTE FROM 
CRUNCHED LINE
01940  C525  91 5F              STA     (XX5F),Y          ; SAVE BYTE TO M
EMORY
01941  C527  88                 DEY                    ; DECREMENT INDEX
01942  C528  10 F8              BPL     XXC522          ; LOOP WHILE MORE 
TO DO
01943  C52A                     
01944  C52A              ; RESET EXECUTION, CLEAR VARIABLES, FLUSH STACK, 
REBUILD BASIC CHAIN AND DO WARM START
01945  C52A              
01946  C52A              XXC52A = *
01947  C52A  20 59 C6           JSR     XXC659          ; RESET EXECUTION 
TO START, CLEAR VARIABLES AND FLUSH STACK
01948  C52D  20 33 C5           JSR     XXC533          ; REBUILD BASIC LI
NE CHAINING
01949  C530  4C 80 C4           JMP     XXC480          ; GO DO BASIC WARM
 START
01950  C533                     
01951  C533                     
01952  C533              ;************************************************
***********************************;
01953  C533              ;
01954  C533              ; REBUILD BASIC LINE CHAINING
01955  C533              
01956  C533              XXC533 = *
01957  C533  A5 2B              LDA     XX2B          ; GET START OF MEMOR
Y LOW BYTE
01958  C535  A4 2C              LDY     XX2C          ; GET START OF MEMOR
Y HIGH BYTE
01959  C537  85 22              STA     XX22          ; SET LINE START POI
NTER LOW BYTE
01960  C539  84 23              STY     XX23          ; SET LINE START POI
NTER HIGH BYTE
01961  C53B  18                 CLC                    ; CLEAR CARRY FOR A
DD
01962  C53C              XXC53C = *
01963  C53C  A0 01              LDY     #$01               ; SET INDEX TO 
POINTER TO NEXT LINE HIGH BYTE
01964  C53E  B1 22              LDA     (XX22),Y          ; GET POINTER TO
 NEXT LINE HIGH BYTE
01965  C540  F0 1D              BEQ     XXC55F          ; EXIT IF NULL, [E
OT]
01966  C542                     
01967  C542  A0 04              LDY     #$04               ; POINT TO FIRS
T CODE BYTE OF LINE
01968  C544                                     ; THERE IS ALWAYS 1 BYTE +
 [EOL] AS NULL ENTRIES ARE DELETED
01969  C544              XXC544 = *
01970  C544  C8                 INY                    ; NEXT CODE BYTE
01971  C545  B1 22              LDA     (XX22),Y          ; GET BYTE
01972  C547  D0 FB              BNE     XXC544          ; LOOP IF NOT [EOL
]
01973  C549                     
01974  C549  C8                 INY                    ; POINT TO BYTE PAS
T [EOL], START OF NEXT LINE
01975  C54A  98                 TYA                    ; COPY IT
01976  C54B  65 22              ADC     XX22          ; ADD LINE START POI
NTER LOW BYTE
01977  C54D  AA                 TAX                    ; COPY TO X
01978  C54E  A0 00              LDY     #$00               ; CLEAR INDEX, 
POINT TO THIS LINE'S NEXT LINE POINTER
01979  C550  91 22              STA     (XX22),Y          ; SET NEXT LINE 
POINTER LOW BYTE
01980  C552  A5 23              LDA     XX23          ; GET LINE START POI
NTER HIGH BYTE






INTERA......PAGE 0039

LINE# LOC   CODE        LINE


01981  C554  69 00              ADC     #$00               ; ADD ANY OVERF
LOW
01982  C556  C8                 INY                    ; INCREMENT INDEX T
O HIGH BYTE
01983  C557  91 22              STA     (XX22),Y          ; SET NEXT LINE 
POINTER HIGH BYTE
01984  C559  86 22              STX     XX22          ; SET LINE START POI
NTER LOW BYTE
01985  C55B  85 23              STA     XX23          ; SET LINE START POI
NTER HIGH BYTE
01986  C55D  90 DD              BCC     XXC53C          ; GO DO NEXT LINE,
 BRANCH ALWAYS
01987  C55F                     
01988  C55F              XXC55F = *
01989  C55F  60                 RTS
01990  C560                     
01991  C560                     
01992  C560              ;************************************************
***********************************;
01993  C560              ;
01994  C560              ; CALL FOR BASIC INPUT
01995  C560              
01996  C560              XXC560 = *
01997  C560  A2 00              LDX     #$00               ; SET CHANNEL $
00, KEYBOARD
01998  C562              XXC562 = *
01999  C562  20 0F E1           JSR     XXE10F          ; INPUT CHARACTER 
FROM CHANNEL WITH ERROR CHECK
02000  C565  C9 0D              CMP     #$0D               ; COMPARE WITH 
[CR]
02001  C567  F0 0D              BEQ     XXC576          ; IF [CR] SET XY T
O XX200 - 1, PRINT [CR] AND EXIT
02002  C569                     
02003  C569                                     ; CHARACTER WAS NOT [CR]
02004  C569  9D 00 02           STA     XX0200,X          ; SAVE CHARACTER
 TO BUFFER
02005  C56C  E8                 INX                    ; INCREMENT BUFFER 
INDEX
02006  C56D  E0 59              CPX     #$59               ; COMPARE WITH 
MAX+1
02007  C56F  90 F1              BCC     XXC562          ; BRANCH IF < MAX+
1
02008  C571                     
02009  C571  A2 17              LDX     #$17               ; ERROR $17, ST
RING TOO LONG ERROR
02010  C573  4C 37 C4           JMP     XXC437          ; DO ERROR #X THEN
 WARM START
02011  C576                     
02012  C576              XXC576 = *
02013  C576  4C CA CA           JMP     XXCACA          ; SET XY TO XX200 
- 1 AND PRINT [CR]
02014  C579                     
02015  C579                     
02016  C579              ;************************************************
***********************************;
02017  C579              ;
02018  C579              ; CRUNCH BASIC TOKENS VECTOR
02019  C579              
02020  C579              XXC579 = *
02021  C579  6C 04 03           JMP     (XX0304)          ; DO CRUNCH BASI
C TOKENS
02022  C57C                     
02023  C57C                     
02024  C57C              ;************************************************
***********************************;
02025  C57C              ;
02026  C57C              ; CRUNCH BASIC TOKENS, THE CRUNCH BASIC TOKENS VE
CTOR IS INITIALISED TO POINT HERE
02027  C57C              
02028  C57C              XXC57C = *
02029  C57C  A6 7A              LDX     XX7A          ; GET BASIC EXECUTE 
POINTER LOW BYTE
02030  C57E  A0 04              LDY     #$04               ; SET SAVE INDE
X
02031  C580  84 0F              STY     XX0F          ; CLEAR OPEN QUOTE/D
ATA FLAG
02032  C582              XXC582 = *
02033  C582  BD 00 02           LDA     XX0200,X          ; GET A BYTE FRO
M THE INPUT BUFFER
02034  C585  10 07              BPL     XXC58E          ; IF B7 CLEAR GO D
O CRUNCHING
02035  C587                     






RE**;A......PAGE 0040

LINE# LOC   CODE        LINE


02036  C587  C9 FF              CMP     #TPI          ; COMPARE WITH THE T
OKEN FOR PI, THIS TOKE IS INPUT
02037  C589                                     ; DIRECTLY FROM THE KEYBOA
RD AS THE PI CHARACTER.
02038  C589  F0 3E              BEQ     XXC5C9          ; IF PI SAVE BYTE 
THEN CONTINUE CRUNCHING
02039  C58B                     
02040  C58B                                     ; THIS IS THE BIT OF CODE 
THAT STOPS YOU BEING ABLE TO ENTER
02041  C58B                                     ; SOME KEYWORDS AS JUST SI
NGLE SHIFTED CHARACTERS. IF THIS
02042  C58B                                     ; DROPPED THROUGH YOU WOUL
D BE ABLE TO ENTER GOTO AS JUST
02043  C58B                                     ; [SHIFT]G
02044  C58B                     
02045  C58B  E8                 INX                    ; INCREMENT READ IN
DEX
02046  C58C  D0 F4              BNE     XXC582          ; LOOP IF MORE TO 
DO, BRANCH ALWAYS
02047  C58E                     
02048  C58E              XXC58E = *
02049  C58E  C9 20              CMP     #' '               ; COMPARE WITH 
[SPACE]
02050  C590  F0 37              BEQ     XXC5C9          ; IF [SPACE] SAVE 
BYTE THEN CONTINUE CRUNCHING
02051  C592                     
02052  C592  85 08              STA     XX08          ; SAVE BUFFER BYTE A
S SEARCH CHARACTER
02053  C594  C9 22              CMP     #$22               ; COMPARE WITH 
QUOTE CHARACTER 
02054  C596  F0 56              BEQ     XXC5EE          ; IF QUOTE GO COPY
 QUOTED STRING
02055  C598                     
02056  C598  24 0F              BIT     XX0F          ; GET OPEN QUOTE/DAT
A TOKEN FLAG
02057  C59A  70 2D              BVS     XXC5C9          ; BRANCH IF B6 OF 
OQUOTE SET, WAS DATA
02058  C59C                                     ; GO SAVE BYTE THEN CONTIN
UE CRUNCHING
02059  C59C                     
02060  C59C  C9 3F              CMP     #'?'               ; COMPARE WITH 
'?' CHARACTER
02061  C59E  D0 04              BNE     XXC5A4          ; IF NOT '?' CONTI
NUE CRUNCHING
02062  C5A0                     
02063  C5A0  A9 99              LDA     #TPRINT          ; ELSE SET THE TO
KEN FOR PRINT
02064  C5A2  D0 25              BNE     XXC5C9          ; GO SAVE BYTE THE
N CONTINUE CRUNCHING ,BRANCH ALWAYS
02065  C5A4                     
02066  C5A4              XXC5A4 = *
02067  C5A4  C9 30              CMP     #'0'               ; COMPARE WITH 
'0'
02068  C5A6  90 04              BCC     XXC5AC          ; IF < '0' CONTINU
E CRUNCHING
02069  C5A8                     
02070  C5A8  C9 3C              CMP     #'<'               ; COMPARE WITH 
'<'
02071  C5AA  90 1D              BCC     XXC5C9          ; IF <, 0123456789
:; GO SAVE BYTE THEN CONTINUE CRUNCHING
02072  C5AC                     
02073  C5AC                                     ; GETS HERE WITH NEXT CHAR
ACTER NOT NUMERIC, ';' OR ':'
02074  C5AC              XXC5AC = *
02075  C5AC  84 71              STY     XX71          ; COPY SAVE INDEX
02076  C5AE  A0 00              LDY     #$00               ; CLEAR TABLE P
OINTER
02077  C5B0  84 0B              STY     XX0B          ; CLEAR WORD INDEX
02078  C5B2  88                 DEY                    ; ADJUST FOR PRE IN
CREMENT LOOP
02079  C5B3  86 7A              STX     XX7A          ; SAVE BASIC EXECUTE
 POINTER LOW BYTE, BUFFER INDEX
02080  C5B5  CA                 DEX                    ; ADJUST FOR PRE IN
CREMENT LOOP
02081  C5B6              XXC5B6 = *
02082  C5B6  C8                 INY                    ; NEXT TABLE BYTE
02083  C5B7  E8                 INX                    ; NEXT BUFFER BYTE
02084  C5B8              XXC5B8 = *
02085  C5B8  BD 00 02           LDA     XX0200,X          ; GET BYTE FROM 
INPUT BUFFER
02086  C5BB  38                 SEC                    ; SET CARRY FOR SUB
TRACT
02087  C5BC  F9 9E C0           SBC     XXC09E,Y          ; SUBTRACT TABLE
 BYTE
02088  C5BF  F0 F5              BEQ     XXC5B6          ; GO COMPARE NEXT 
IF MATCH
02089  C5C1                     
02090  C5C1  C9 80              CMP     #$80               ; WAS IT END MA
RKER MATCH ?






NCHING......PAGE 0041

LINE# LOC   CODE        LINE


02091  C5C3  D0 30              BNE     XXC5F5          ; IF NOT GO TRY TH
E NEXT KEYWORD
02092  C5C5                     
02093  C5C5                                     ; ACTUALLY THIS WORKS EVEN
 IF THE INPUT BUFFER BYTE IS THE
02094  C5C5                                     ; END MARKER, I.E. A SHIFT
ED CHARACTER. AS YOU CAN'T ENTER
02095  C5C5                                     ; ANY KEYWORDS AS A SINGLE
 SHIFTED CHARACTER, SEE ABOVE,
02096  C5C5                                     ; YOU CAN ENTER KEYWORDS I
N SHORTHAND BY SHIFTING ANY
02097  C5C5                                     ; CHARACTER AFTER THE FIRS
T. SO RETURN CAN BE ENTERED AS
02098  C5C5                                     ; R[SHIFT]E, RE[SHIFT]T, R
ET[SHIFT]U OR RETU[SHIFT]R.
02099  C5C5                                     ; RETUR[SHIFT]N HOWEVER WI
LL NOT WORK BECAUSE THE [SHIFT]N
02100  C5C5                                     ; WILL MATCH THE RETURN EN
D MARKER SO THE ROUTINE WILL TRY
02101  C5C5                                     ; TO MATCH THE NEXT CHARAC
TER.
02102  C5C5                     
02103  C5C5                                     ; ELSE FOUND KEYWORD
02104  C5C5  05 0B              ORA     XX0B          ; OR WITH WORD INDEX
, +$80 IN A MAKES TOKEN
02105  C5C7              XXC5C7 = *
02106  C5C7  A4 71              LDY     XX71          ; RESTORE SAVE INDEX

02107  C5C9                     
02108  C5C9              ; SAVE BYTE THEN CONTINUE CRUNCHING
02109  C5C9              
02110  C5C9              XXC5C9 = *
02111  C5C9  E8                 INX                    ; INCREMENT BUFFER 
READ INDEX
02112  C5CA  C8                 INY                    ; INCREMENT SAVE IN
DEX
02113  C5CB  99 FB 01           STA     XX0200-5,Y     ; SAVE BYTE TO OUTP
UT
02114  C5CE  B9 FB 01           LDA     XX0200-5,Y     ; GET BYTE FROM OUT
PUT, SET FLAGS
02115  C5D1  F0 36              BEQ     XXC609          ; BRANCH IF WAS NU
LL [EOL]
02116  C5D3                     
02117  C5D3                                     ; A HOLDS THE TOKEN HERE
02118  C5D3  38                 SEC                    ; SET CARRY FOR SUB
TRACT
02119  C5D4  E9 3A              SBC     #':'               ; SUBTRACT ':'
02120  C5D6  F0 04              BEQ     XXC5DC          ; BRANCH IF IT WAS
 (IS NOW $00)
02121  C5D8                     
02122  C5D8                                     ; A NOW HOLDS TOKEN-':'
02123  C5D8  C9 49              CMP     #$49    ;#TDATA-':'     ; COMPARE 
WITH THE TOKEN FOR DATA-':'
02124  C5DA  D0 02              BNE     XXC5DE          ; IF NOT DATA GO T
RY REM
02125  C5DC                     
02126  C5DC                                     ; TOKEN WAS : OR DATA
02127  C5DC              XXC5DC = *
02128  C5DC  85 0F              STA     XX0F          ; SAVE TOKEN-':'
02129  C5DE              XXC5DE = *
02130  C5DE  38                 SEC                    ; SET CARRY FOR SUB
TRACT
02131  C5DF  E9 55              SBC     #$55    ;#TREM-':'          ; SUBT
RACT THE TOKEN FOR REM-':'
02132  C5E1  D0 9F              BNE     XXC582          ; IF WASN'T REM GO
 CRUNCH NEXT BIT OF LINE
02133  C5E3                     
02134  C5E3  85 08              STA     XX08          ; ELSE WAS REM SO SE
T SEARCH FOR [EOL]
02135  C5E5                     
02136  C5E5                                     ; LOOP FOR '...' ETC.
02137  C5E5              XXC5E5 = *
02138  C5E5  BD 00 02           LDA     XX0200,X          ; GET BYTE FROM 
INPUT BUFFER
02139  C5E8  F0 DF              BEQ     XXC5C9          ; IF NULL [EOL] SA
VE BYTE THEN CONTINUE CRUNCHING
02140  C5EA                     
02141  C5EA  C5 08              CMP     XX08          ; COMPARE WITH STORE
D CHARACTER
02142  C5EC  F0 DB              BEQ     XXC5C9          ; IF MATCH SAVE BY
TE THEN CONTINUE CRUNCHING
02143  C5EE                     
02144  C5EE              XXC5EE = *
02145  C5EE  C8                 INY                    ; INCREMENT SAVE IN
DEX






TRYING......PAGE 0042

LINE# LOC   CODE        LINE


02146  C5EF  99 FB 01           STA     XX0200-5,Y     ; SAVE BYTE TO OUTP
UT
02147  C5F2  E8                 INX                    ; INCREMENT BUFFER 
INDEX
02148  C5F3  D0 F0              BNE     XXC5E5          ; LOOP WHILE <> 0,
 SHOULD NEVER REACH 0
02149  C5F5                     
02150  C5F5                                     ; NOT FOUND KEYWORD THIS G
O
02151  C5F5              XXC5F5 = *
02152  C5F5  A6 7A              LDX     XX7A          ; RESTORE BASIC EXEC
UTE POINTER LOW BYTE
02153  C5F7  E6 0B              INC     XX0B          ; INCREMENT WORD IND
EX (NEXT WORD)
02154  C5F9                     
02155  C5F9                                     ; NOW FIND END OF THIS WOR
D IN THE TABLE
02156  C5F9              XXC5F9 = *
02157  C5F9  C8                 INY                    ; INCREMENT TABLE I
NDEX
02158  C5FA  B9 9D C0           LDA     XXC09E-1,Y     ; GET TABLE BYTE
02159  C5FD  10 FA              BPL     XXC5F9          ; LOOP IF NOT END 
OF WORD YET
02160  C5FF                     
02161  C5FF  B9 9E C0           LDA     XXC09E,Y          ; GET BYTE FROM 
KEYWORD TABLE
02162  C602  D0 B4              BNE     XXC5B8          ; GO TEST NEXT WOR
D IF NOT ZERO BYTE, END OF TABLE
02163  C604                     
02164  C604                                     ; REACHED END OF TABLE WIT
H NO MATCH
02165  C604  BD 00 02           LDA     XX0200,X          ; RESTORE BYTE F
ROM INPUT BUFFER
02166  C607  10 BE              BPL     XXC5C7          ; BRANCH ALWAYS, A
LL UNMATCHED BYTES IN THE BUFFER ARE
02167  C609                                     ; $00 TO $7F, GO SAVE BYTE
 IN OUTPUT AND CONTINUE CRUNCHING
02168  C609                     
02169  C609                                     ; REACHED [EOL]
02170  C609              XXC609 = *
02171  C609  99 FD 01           STA     XX0200-3,Y     ; SAVE [EOL]
02172  C60C  C6 7B              DEC     XX7B          ; DECREMENT BASIC EX
ECUTE POINTER HIGH BYTE
02173  C60E  A9 FF              LDA     #$FF               ; POINT TO STAR
T OF BUFFER-1
02174  C610  85 7A              STA     XX7A          ; SET BASIC EXECUTE 
POINTER LOW BYTE
02175  C612  60                 RTS
02176  C613                     
02177  C613                     
02178  C613              ;************************************************
***********************************;
02179  C613              ;
02180  C613              ; SEARCH BASIC FOR TEMPORARY INTEGER LINE NUMBER
02181  C613              
02182  C613              XXC613 = *
02183  C613  A5 2B              LDA     XX2B          ; GET START OF MEMOR
Y LOW BYTE
02184  C615  A6 2C              LDX     XX2C          ; GET START OF MEMOR
Y HIGH BYTE
02185  C617                     
02186  C617              ; SEARCH BASIC FOR TEMP INTEGER LINE NUMBER FROM 
AX
02187  C617              ; RETURNS CARRY SET IF FOUND
02188  C617              
02189  C617              XXC617 = *
02190  C617  A0 01              LDY     #$01               ; SET INDEX TO 
NEXT LINE POINTER HIGH BYTE
02191  C619  85 5F              STA     XX5F          ; SAVE LOW BYTE AS C
URRENT
02192  C61B  86 60              STX     XX60          ; SAVE HIGH BYTE AS 
CURRENT
02193  C61D  B1 5F              LDA     (XX5F),Y          ; GET NEXT LINE 
POINTER HIGH BYTE FROM ADDRESS
02194  C61F  F0 1F              BEQ     XXC640          ; POINTER WAS ZERO
 SO DONE, EXIT
02195  C621                     
02196  C621  C8                 INY                    ; INCREMENT INDEX .
..
02197  C622  C8                 INY                    ; ... TO LINE # HIG
H BYTE
02198  C623  A5 15              LDA     XX15          ; GET TEMPORARY INTE
GER HIGH BYTE
02199  C625  D1 5F              CMP     (XX5F),Y          ; COMPARE WITH L
INE # HIGH BYTE
02200  C627  90 18              BCC     XXC641          ; EXIT IF TEMP < T
HIS LINE, TARGET LINE PASSED






****;G......PAGE 0043

LINE# LOC   CODE        LINE


02201  C629                     
02202  C629  F0 03              BEQ     XXC62E          ; GO CHECK LOW BYT
E IF =
02203  C62B                     
02204  C62B  88                 DEY                    ; ELSE DECREMENT IN
DEX
02205  C62C  D0 09              BNE     XXC637          ; BRANCH ALWAYS
02206  C62E                     
02207  C62E              XXC62E = *
02208  C62E  A5 14              LDA     XX14          ; GET TEMPORARY INTE
GER LOW BYTE
02209  C630  88                 DEY                    ; DECREMENT INDEX T
O LINE # LOW BYTE
02210  C631  D1 5F              CMP     (XX5F),Y          ; COMPARE WITH L
INE # LOW BYTE
02211  C633  90 0C              BCC     XXC641          ; EXIT IF TEMP < T
HIS LINE, TARGET LINE PASSED
02212  C635                     
02213  C635  F0 0A              BEQ     XXC641          ; EXIT IF TEMP = (
FOUND LINE#)
02214  C637                     
02215  C637                                     ; NOT QUITE THERE YET
02216  C637              XXC637 = *
02217  C637  88                 DEY                    ; DECREMENT INDEX T
O NEXT LINE POINTER HIGH BYTE
02218  C638  B1 5F              LDA     (XX5F),Y          ; GET NEXT LINE 
POINTER HIGH BYTE
02219  C63A  AA                 TAX                    ; COPY TO X
02220  C63B  88                 DEY                    ; DECREMENT INDEX T
O NEXT LINE POINTER LOW BYTE
02221  C63C  B1 5F              LDA     (XX5F),Y          ; GET NEXT LINE 
POINTER LOW BYTE
02222  C63E  B0 D7              BCS     XXC617          ; GO SEARCH FOR LI
NE # IN TEMPORARY INTEGER
02223  C640                                     ; FROM AX, CARRY ALWAYS SE
T
02224  C640                     
02225  C640              XXC640 = *
02226  C640  18                 CLC                    ; CLEAR FOUND FLAG
02227  C641              XXC641 = *
02228  C641  60                 RTS
02229  C642                     
02230  C642                     
02231  C642              ;************************************************
***********************************;
02232  C642              ;
02233  C642              ; PERFORM NEW
02234  C642              
02235  C642              XXC642 = *
02236  C642  D0 FD              BNE     XXC641          ; EXIT IF FOLLOWIN
G BYTE TO ALLOW SYNTAX ERROR
02237  C644                     
02238  C644              XXC644 = *
02239  C644  A9 00              LDA     #$00               ; CLEAR A
02240  C646  A8                 TAY                    ; CLEAR INDEX
02241  C647  91 2B              STA     (XX2B),Y          ; CLEAR POINTER 
TO NEXT LINE LOW BYTE
02242  C649  C8                 INY                    ; INCREMENT INDEX
02243  C64A  91 2B              STA     (XX2B),Y          ; CLEAR POINTER 
TO NEXT LINE HIGH BYTE, ERASE PROGRAM
02244  C64C                     
02245  C64C  A5 2B              LDA     XX2B          ; GET START OF MEMOR
Y LOW BYTE
02246  C64E  18                 CLC                    ; CLEAR CARRY FOR A
DD
02247  C64F  69 02              ADC     #$02               ; ADD NULL PROG
RAM LENGTH
02248  C651  85 2D              STA     XX2D          ; SET START OF VARIA
BLES LOW BYTE
02249  C653  A5 2C              LDA     XX2C          ; GET START OF MEMOR
Y HIGH BYTE
02250  C655  69 00              ADC     #$00               ; ADD CARRY
02251  C657  85 2E              STA     XX2E          ; SET START OF VARIA
BLES HIGH BYTE
02252  C659                     
02253  C659              ; RESET EXECUTE POINTER AND DO CLR
02254  C659              
02255  C659              XXC659 = *






GRAM;G......PAGE 0044

LINE# LOC   CODE        LINE


02256  C659  20 8E C6           JSR     XXC68E          ; SET BASIC EXECUT
E POINTER TO START OF MEMORY - 1
02257  C65C  A9 00              LDA     #$00               ; SET ZB FOR CL
R ENTRY
02258  C65E                     
02259  C65E                     
02260  C65E              ;************************************************
***********************************;
02261  C65E              ;
02262  C65E              ; PERFORM CLR
02263  C65E              
02264  C65E              XXC65E = *
02265  C65E  D0 2D              BNE     XXC68D          ; EXIT IF FOLLOWIN
G BYTE TO ALLOW SYNTAX ERROR
02266  C660                     
02267  C660              XXC660 = *
02268  C660  20 E7 FF           JSR     XXFFE7          ; CLOSE ALL CHANNE
LS AND FILES
02269  C663              XXC663 = *
02270  C663  A5 37              LDA     XX37          ; GET END OF MEMORY 
LOW BYTE
02271  C665  A4 38              LDY     XX38          ; GET END OF MEMORY 
HIGH BYTE
02272  C667  85 33              STA     XX33          ; SET BOTTOM OF STRI
NG SPACE LOW BYTE, CLEAR STRINGS
02273  C669  84 34              STY     XX34          ; SET BOTTOM OF STRI
NG SPACE HIGH BYTE
02274  C66B  A5 2D              LDA     XX2D          ; GET START OF VARIA
BLES LOW BYTE
02275  C66D  A4 2E              LDY     XX2E          ; GET START OF VARIA
BLES HIGH BYTE
02276  C66F  85 2F              STA     XX2F          ; SET END OF VARIABL
ES LOW BYTE, CLEAR VARIABLES
02277  C671  84 30              STY     XX30          ; SET END OF VARIABL
ES HIGH BYTE
02278  C673  85 31              STA     XX31          ; SET END OF ARRAYS 
LOW BYTE, CLEAR ARRAYS
02279  C675  84 32              STY     XX32          ; SET END OF ARRAYS 
HIGH BYTE
02280  C677                     
02281  C677                     
02282  C677              ;************************************************
***********************************;
02283  C677              ;
02284  C677              ; DO RESTORE AND CLEAR THE STACK
02285  C677              
02286  C677              XXC677 = *
02287  C677  20 1D C8           JSR     XXC81D          ; PERFORM RESTORE
02288  C67A                     
02289  C67A              ; FLUSH BASIC STACK AND CLEAR THE CONTINUE POINTE
R
02290  C67A              
02291  C67A              XXC67A = *
02292  C67A  A2 19              LDX     #XX19          ; GET DESCRIPTOR ST
ACK START
02293  C67C  86 16              STX     XX16          ; SET DESCRIPTOR STA
CK POINTER
02294  C67E  68                 PLA                    ; PULL RETURN ADDRE
SS LOW BYTE
02295  C67F  A8                 TAY                    ; COPY IT
02296  C680  68                 PLA                    ; PULL RETURN ADDRE
SS HIGH BYTE
02297  C681  A2 FA              LDX     #$FA               ; SET CLEARED S
TACK POINTER
02298  C683  9A                 TXS                    ; SET STACK
02299  C684  48                 PHA                    ; PUSH RETURN ADDRE
SS HIGH BYTE
02300  C685  98                 TYA                    ; RESTORE RETURN AD
DRESS LOW BYTE
02301  C686  48                 PHA                    ; PUSH RETURN ADDRE
SS LOW BYTE
02302  C687  A9 00              LDA     #$00               ; CLEAR A
02303  C689  85 3E              STA     XX3E          ; CLEAR CONTINUE POI
NTER HIGH BYTE
02304  C68B  85 10              STA     XX10          ; CLEAR SUBSCRIPT/FN
X FLAG
02305  C68D              XXC68D = *
02306  C68D  60                 RTS
02307  C68E                     
02308  C68E                     
02309  C68E              ;************************************************
***********************************;
02310  C68E              ;






****;G......PAGE 0045

LINE# LOC   CODE        LINE


02311  C68E              ; SET BASIC EXECUTE POINTER TO START OF MEMORY - 
1
02312  C68E              
02313  C68E              XXC68E = *
02314  C68E  18                 CLC                    ; CLEAR CARRY FOR A
DD
02315  C68F  A5 2B              LDA     XX2B          ; GET START OF MEMOR
Y LOW BYTE
02316  C691  69 FF              ADC     #$FF               ; ADD -1 LOW BY
TE
02317  C693  85 7A              STA     XX7A          ; SET BASIC EXECUTE 
POINTER LOW BYTE
02318  C695  A5 2C              LDA     XX2C          ; GET START OF MEMOR
Y HIGH BYTE
02319  C697  69 FF              ADC     #$FF               ; ADD -1 HIGH B
YTE
02320  C699  85 7B              STA     XX7B          ; SAVE BASIC EXECUTE
 POINTER HIGH BYTE
02321  C69B  60                 RTS
02322  C69C                     
02323  C69C                     
02324  C69C              ;************************************************
***********************************;
02325  C69C              ;
02326  C69C              ; PERFORM LIST
02327  C69C              
02328  C69C              XXC69C = *
02329  C69C  90 06              BCC     XXC6A4          ; BRANCH IF NEXT C
HARACTER NOT TOKEN (LIST N...)
02330  C69E                     
02331  C69E  F0 04              BEQ     XXC6A4          ; BRANCH IF NEXT C
HARACTER [NULL] (LIST)
02332  C6A0                     
02333  C6A0  C9 AB              CMP     #TMINUS          ; COMPARE WITH TO
KEN FOR -
02334  C6A2  D0 E9              BNE     XXC68D          ; EXIT IF NOT - (L
IST -M)
02335  C6A4                     
02336  C6A4                                     ; LIST [[N][-M]]
02337  C6A4                                     ; THIS BIT SETS THE N , IF
 PRESENT, AS THE START AND END
02338  C6A4              XXC6A4 = *
02339  C6A4  20 6B C9           JSR     XXC96B          ; GET FIXED-POINT 
NUMBER INTO TEMPORARY INTEGER
02340  C6A7  20 13 C6           JSR     XXC613          ; SEARCH BASIC FOR
 TEMPORARY INTEGER LINE NUMBER
02341  C6AA  20 79 00           JSR     XX0079          ; SCAN MEMORY
02342  C6AD  F0 0C              BEQ     XXC6BB          ; BRANCH IF NO MOR
E CHRS
02343  C6AF                     
02344  C6AF                                     ; THIS BIT CHECKS THE - IS
 PRESENT
02345  C6AF  C9 AB              CMP     #TMINUS          ; COMPARE WITH '-
'
02346  C6B1  D0 8E              BNE     XXC641          ; RETURN IF NOT '-
' (WILL BE SN ERROR)
02347  C6B3                     
02348  C6B3                                     ; LIST [N]-M
02349  C6B3                                     ; THE - WAS THERE SO SET M
 AS THE END VALUE
02350  C6B3  20 73 00           JSR     XX0073          ; INCREMENT AND SC
AN MEMORY
02351  C6B6  20 6B C9           JSR     XXC96B          ; GET FIXED-POINT 
NUMBER INTO TEMPORARY INTEGER
02352  C6B9  D0 86              BNE     XXC641          ; EXIT IF NOT OK
02353  C6BB                     
02354  C6BB              XXC6BB = *
02355  C6BB  68                 PLA                    ; DUMP RETURN ADDRE
SS LOW BYTE, EXIT VIA WARM START
02356  C6BC  68                 PLA                    ; DUMP RETURN ADDRE
SS HIGH BYTE
02357  C6BD  A5 14              LDA     XX14          ; GET TEMPORARY INTE
GER LOW BYTE
02358  C6BF  05 15              ORA     XX15          ; OR TEMPORARY INTEG
ER HIGH BYTE
02359  C6C1  D0 06              BNE     XXC6C9          ; BRANCH IF START 
SET
02360  C6C3                     
02361  C6C3  A9 FF              LDA     #$FF               ; SET FOR -1
02362  C6C5  85 14              STA     XX14          ; SET TEMPORARY INTE
GER LOW BYTE
02363  C6C7  85 15              STA     XX15          ; SET TEMPORARY INTE
GER HIGH BYTE
02364  C6C9              XXC6C9 = *
02365  C6C9  A0 01              LDY     #$01               ; SET INDEX FOR
 LINE






D***;G......PAGE 0046

LINE# LOC   CODE        LINE


02366  C6CB  84 0F              STY     XX0F          ; CLEAR OPEN QUOTE F
LAG
02367  C6CD  B1 5F              LDA     (XX5F),Y          ; GET NEXT LINE 
POINTER HIGH BYTE
02368  C6CF  F0 43              BEQ     XXC714          ; IF NULL ALL DONE
 SO EXIT
02369  C6D1                     
02370  C6D1  20 2C C8           JSR     XXC82C          ; DO CRTL-C CHECK 
VECTOR
02371  C6D4  20 D7 CA           JSR     XXCAD7          ; PRINT CR/LF
02372  C6D7  C8                 INY                    ; INCREMENT INDEX F
OR LINE
02373  C6D8  B1 5F              LDA     (XX5F),Y          ; GET LINE NUMBE
R LOW BYTE
02374  C6DA  AA                 TAX                    ; COPY TO X
02375  C6DB  C8                 INY                    ; INCREMENT INDEX
02376  C6DC  B1 5F              LDA     (XX5F),Y          ; GET LINE NUMBE
R HIGH BYTE
02377  C6DE  C5 15              CMP     XX15          ; COMPARE WITH TEMPO
RARY INTEGER HIGH BYTE
02378  C6E0  D0 04              BNE     XXC6E6          ; BRANCH IF NO HIG
H BYTE MATCH
02379  C6E2                     
02380  C6E2  E4 14              CPX     XX14          ; COMPARE WITH TEMPO
RARY INTEGER LOW BYTE
02381  C6E4  F0 02              BEQ     XXC6E8          ; BRANCH IF = LAST
 LINE TO DO, < WILL PASS NEXT BRANCH
02382  C6E6                     
02383  C6E6              XXC6E6 = *                    ; ELSE ...
02384  C6E6  B0 2C              BCS     XXC714          ; IF GREATER ALL D
ONE SO EXIT
02385  C6E8                     
02386  C6E8              XXC6E8 = *
02387  C6E8  84 49              STY     XX49          ; SAVE INDEX FOR LIN
E
02388  C6EA  20 CD DD           JSR     XXDDCD          ; PRINT XA AS UNSI
GNED INTEGER
02389  C6ED  A9 20              LDA     #' '               ; SPACE IS THE 
NEXT CHARACTER
02390  C6EF              XXC6EF = *
02391  C6EF  A4 49              LDY     XX49          ; GET INDEX FOR LINE

02392  C6F1  29 7F              AND     #$7F               ; MASK TOP OUT 
BIT OF CHARACTER
02393  C6F3              XXC6F3 = *
02394  C6F3  20 47 CB           JSR     XXCB47          ; GO PRINT THE CHA
RACTER
02395  C6F6  C9 22              CMP     #$22               ; WAS IT ' CHAR
ACTER
02396  C6F8  D0 06              BNE     XXC700          ; IF NOT SKIP THE 
QUOTE HANDLE
02397  C6FA                     
02398  C6FA                                     ; WE ARE EITHER ENTERING O
R LEAVING A PAIR OF QUOTES
02399  C6FA  A5 0F              LDA     XX0F          ; GET OPEN QUOTE FLA
G
02400  C6FC  49 FF              EOR     #$FF               ; TOGGLE IT
02401  C6FE  85 0F              STA     XX0F          ; SAVE IT BACK
02402  C700              XXC700 = *
02403  C700  C8                 INY                    ; INCREMENT INDEX
02404  C701  F0 11              BEQ     XXC714          ; LINE TOO LONG SO
 JUST BAIL OUT AND DO A WARM START
02405  C703                     
02406  C703  B1 5F              LDA     (XX5F),Y          ; GET NEXT BYTE
02407  C705  D0 10              BNE     XXC717          ; IF NOT [EOL] (GO
 PRINT CHARACTER)
02408  C707                     
02409  C707                                     ; WAS [EOL]
02410  C707  A8                 TAY                    ; ELSE CLEAR INDEX
02411  C708  B1 5F              LDA     (XX5F),Y          ; GET NEXT LINE 
POINTER LOW BYTE
02412  C70A  AA                 TAX                    ; COPY TO X
02413  C70B  C8                 INY                    ; INCREMENT INDEX
02414  C70C  B1 5F              LDA     (XX5F),Y          ; GET NEXT LINE 
POINTER HIGH BYTE
02415  C70E  86 5F              STX     XX5F          ; SET POINTER TO LIN
E LOW BYTE
02416  C710  85 60              STA     XX60          ; SET POINTER TO LIN
E HIGH BYTE
02417  C712  D0 B5              BNE     XXC6C9          ; GO DO NEXT LINE 
IF NOT [EOT]
02418  C714                                     ; ELSE ...
02419  C714              XXC714 = *
02420  C714  4C 74 C4           JMP     XXC474          ; DO WARM START






TCH*;G......PAGE 0047

LINE# LOC   CODE        LINE


02421  C717                     
02422  C717                     
02423  C717              ;************************************************
***********************************;
02424  C717              ;
02425  C717              XXC717 = *
02426  C717  6C 06 03           JMP     (XX0306)          ; DO UNCRUNCH BA
SIC TOKENS
02427  C71A                     
02428  C71A                     
02429  C71A              ;************************************************
***********************************;
02430  C71A              ;
02431  C71A              ; UNCRUNCH BASIC TOKENS, THE UNCRUNCH BASIC TOKEN
S VECTOR IS INITIALISED TO POINT HERE
02432  C71A              
02433  C71A              XXC71A = *
02434  C71A  10 D7              BPL     XXC6F3          ; JUST GO PRINT IT
 IF NOT TOKEN BYTE
02435  C71C                                     ; ELSE WAS TOKEN BYTE SO U
NCRUNCH IT
02436  C71C                     
02437  C71C  C9 FF              CMP     #TPI          ; COMPARE WITH THE T
OKEN FOR PI. IN THIS CASE THE TOKEN
02438  C71E                                     ; IS THE SAME AS THE PI CH
ARACTER SO IT JUST NEEDS PRINTING
02439  C71E  F0 D3              BEQ     XXC6F3          ; JUST PRINT IT IF
 SO
02440  C720                     
02441  C720  24 0F              BIT     XX0F          ; TEST THE OPEN QUOT
E FLAG
02442  C722  30 CF              BMI     XXC6F3          ; JUST GO PRINT CH
ARACTER IF OPEN QUOTE SET
02443  C724                     
02444  C724  38                 SEC                    ; ELSE SET CARRY FO
R SUBTRACT
02445  C725  E9 7F              SBC     #$7F               ; REDUCE TOKEN 
RANGE TO 1 TO WHATEVER
02446  C727  AA                 TAX                    ; COPY TOKEN # TO X

02447  C728  84 49              STY     XX49          ; SAVE INDEX FOR LIN
E
02448  C72A  A0 FF              LDY     #$FF               ; START FROM -1
, ADJUST FOR PRE INCREMENT
02449  C72C              XXC72C = *
02450  C72C  CA                 DEX                    ; DECREMENT TOKEN #

02451  C72D  F0 08              BEQ     XXC737          ; IF NOW FOUND GO 
DO PRINTING
02452  C72F                     
02453  C72F              XXC72F = *
02454  C72F  C8                 INY                    ; ELSE INCREMENT IN
DEX
02455  C730  B9 9E C0           LDA     XXC09E,Y          ; GET BYTE FROM 
KEYWORD TABLE
02456  C733  10 FA              BPL     XXC72F          ; LOOP UNTIL KEYWO
RD END MARKER
02457  C735                     
02458  C735  30 F5              BMI     XXC72C          ; GO TEST IF THIS 
IS REQUIRED KEYWORD, BRANCH ALWAYS
02459  C737                     
02460  C737                                     ; FOUND KEYWORD, IT'S THE 
NEXT ONE
02461  C737              XXC737 = *
02462  C737  C8                 INY                    ; INCREMENT KEYWORD
 TABLE INDEX
02463  C738  B9 9E C0           LDA     XXC09E,Y          ; GET BYTE FROM 
TABLE
02464  C73B  30 B2              BMI     XXC6EF          ; GO RESTORE INDEX
, MASK BYTE AND PRINT IF
02465  C73D                                     ; BYTE WAS END MARKER
02466  C73D                     
02467  C73D  20 47 CB           JSR     XXCB47          ; ELSE GO PRINT TH
E CHARACTER
02468  C740  D0 F5              BNE     XXC737          ; GO GET NEXT CHAR
ACTER, BRANCH ALWAYS
02469  C742                     
02470  C742                     
02471  C742              ;************************************************
***********************************;
02472  C742              ;
02473  C742              ; PERFORM FOR
02474  C742              
02475  C742              XXC742 = *






****;E......PAGE 0048

LINE# LOC   CODE        LINE


02476  C742  A9 80              LDA     #$80               ; SET FNX
02477  C744  85 10              STA     XX10          ; SET SUBSCRIPT/FNX 
FLAG
02478  C746  20 A5 C9           JSR     XXC9A5          ; PERFORM LET
02479  C749  20 8A C3           JSR     XXC38A          ; SEARCH THE STACK
 FOR FOR OR GOSUB ACTIVITY
02480  C74C  D0 05              BNE     XXC753          ; BRANCH IF FOR, T
HIS VARIABLE, NOT FOUND
02481  C74E                     
02482  C74E                                     ; FOR, THIS VARIABLE, WAS 
FOUND SO FIRST WE DUMP THE OLD ONE
02483  C74E  8A                 TXA                    ; COPY INDEX
02484  C74F  69 0F              ADC     #$0F               ; ADD FOR STRUC
TURE SIZE-2
02485  C751  AA                 TAX                    ; COPY TO INDEX
02486  C752  9A                 TXS                    ; SET STACK (DUMP F
OR STRUCTURE (-2 BYTES))
02487  C753              XXC753 = *
02488  C753  68                 PLA                    ; PULL RETURN ADDRE
SS
02489  C754  68                 PLA                    ; PULL RETURN ADDRE
SS
02490  C755  A9 09              LDA     #$09               ; WE NEED 18D B
YTES !
02491  C757  20 FB C3           JSR     XXC3FB          ; CHECK ROOM ON ST
ACK FOR 2*A BYTES
02492  C75A  20 06 C9           JSR     XXC906          ; SCAN FOR NEXT BA
SIC STATEMENT ([:] OR [EOL])
02493  C75D  18                 CLC                    ; CLEAR CARRY FOR A
DD
02494  C75E  98                 TYA                    ; COPY INDEX TO A
02495  C75F  65 7A              ADC     XX7A          ; ADD BASIC EXECUTE 
POINTER LOW BYTE
02496  C761  48                 PHA                    ; PUSH ONTO STACK
02497  C762  A5 7B              LDA     XX7B          ; GET BASIC EXECUTE 
POINTER HIGH BYTE
02498  C764  69 00              ADC     #$00               ; ADD CARRY
02499  C766  48                 PHA                    ; PUSH ONTO STACK
02500  C767  A5 3A              LDA     XX3A          ; GET CURRENT LINE N
UMBER HIGH BYTE
02501  C769  48                 PHA                    ; PUSH ONTO STACK
02502  C76A  A5 39              LDA     XX39          ; GET CURRENT LINE N
UMBER LOW BYTE
02503  C76C  48                 PHA                    ; PUSH ONTO STACK
02504  C76D  A9 A4              LDA     #TTO          ; SET 'TO' TOKEN
02505  C76F  20 FF CE           JSR     XXCEFF          ; SCAN FOR CHR$(A)
, ELSE DO SYNTAX ERROR THEN WARM START
02506  C772  20 8D CD           JSR     XXCD8D          ; CHECK IF SOURCE 
IS NUMERIC, ELSE DO TYPE MISMATCH
02507  C775  20 8A CD           JSR     XXCD8A          ; EVALUATE EXPRESS
ION AND CHECK IS NUMERIC, ELSE DO
02508  C778                                     ; TYPE MISMATCH
02509  C778  A5 66              LDA     XX66          ; GET FAC1 SIGN (B7)

02510  C77A  09 7F              ORA     #$7F               ; SET ALL NON S
IGN BITS
02511  C77C  25 62              AND     XX62          ; AND FAC1 MANTISSA 
1
02512  C77E  85 62              STA     XX62          ; SAVE FAC1 MANTISSA
 1
02513  C780  A9 8B              LDA     #<XXC78B          ; SET RETURN ADD
RESS LOW BYTE
02514  C782  A0 C7              LDY     #>XXC78B          ; SET RETURN ADD
RESS HIGH BYTE
02515  C784  85 22              STA     XX22          ; SAVE RETURN ADDRES
S LOW BYTE
02516  C786  84 23              STY     XX23          ; SAVE RETURN ADDRES
S HIGH BYTE
02517  C788  4C 43 CE           JMP     XXCE43          ; ROUND FAC1 AND P
UT ON STACK, RETURNS TO NEXT INSTRUCTION
02518  C78B                     
02519  C78B              XXC78B = *
02520  C78B  A9 BC              LDA     #<XXD9BC          ; SET 1 POINTER 
LOW ADDRESS, DEFAULT STEP SIZE
02521  C78D  A0 D9              LDY     #>XXD9BC          ; SET 1 POINTER 
HIGH ADDRESS
02522  C78F  20 A2 DB           JSR     XXDBA2          ; UNPACK MEMORY (A
Y) INTO FAC1
02523  C792  20 79 00           JSR     XX0079          ; SCAN MEMORY
02524  C795  C9 A9              CMP     #TSTEP          ; COMPARE WITH STE
P TOKEN
02525  C797  D0 06              BNE     XXC79F          ; BRANCH IF NOT 'S
TEP'
02526  C799                     
02527  C799                                     ; WAS STEP SO ....
02528  C799  20 73 00           JSR     XX0073          ; INCREMENT AND SC
AN MEMORY
02529  C79C  20 8A CD           JSR     XXCD8A          ; EVALUATE EXPRESS
ION AND CHECK IS NUMERIC, ELSE DO
02530  C79F                                     ; TYPE MISMATCH






RUCTIO......PAGE 0049

LINE# LOC   CODE        LINE


02531  C79F              XXC79F = *
02532  C79F  20 2B DC           JSR     XXDC2B          ; GET FAC1 SIGN, R
ETURN A = $FF -VE, A = $01 +VE
02533  C7A2  20 38 CE           JSR     XXCE38          ; PUSH SIGN, ROUND
 FAC1 AND PUT ON STACK
02534  C7A5  A5 4A              LDA     XX4A          ; GET FOR/NEXT VARIA
BLE POINTER HIGH BYTE
02535  C7A7  48                 PHA                    ; PUSH ON STACK
02536  C7A8  A5 49              LDA     XX49          ; GET FOR/NEXT VARIA
BLE POINTER LOW BYTE
02537  C7AA  48                 PHA                    ; PUSH ON STACK
02538  C7AB  A9 81              LDA     #TFOR          ; GET FOR TOKEN
02539  C7AD  48                 PHA                    ; PUSH ON STACK
02540  C7AE                     
02541  C7AE                     
02542  C7AE              ;************************************************
***********************************;
02543  C7AE              ;
02544  C7AE              ; INTERPRETER INNER LOOP
02545  C7AE              
02546  C7AE              XXC7AE = *
02547  C7AE  20 2C C8           JSR     XXC82C          ; DO CRTL-C CHECK 
VECTOR
02548  C7B1  A5 7A              LDA     XX7A          ; GET BASIC EXECUTE 
POINTER LOW BYTE
02549  C7B3  A4 7B              LDY     XX7B          ; GET BASIC EXECUTE 
POINTER HIGH BYTE
02550  C7B5  C0 02              CPY     #$02               ; COMPARE WITH 
$02XX
02551  C7B7  EA                 NOP                    ; UNUSED BYTE      
                             ##
02552  C7B8  F0 04              BEQ     XXC7BE          ; IF IMMEDIATE MOD
E SKIP THE CONTINUE POINTER SAVE
02553  C7BA                     
02554  C7BA  85 3D              STA     XX3D          ; SAVE THE CONTINUE 
POINTER LOW BYTE
02555  C7BC  84 3E              STY     XX3E          ; SAVE THE CONTINUE 
POINTER HIGH BYTE
02556  C7BE              XXC7BE = *
02557  C7BE  A0 00              LDY     #$00               ; CLEAR THE IND
EX
02558  C7C0  B1 7A              LDA     (XX7A),Y          ; GET BASIC BYTE

02559  C7C2  D0 43              BNE     XXC807          ; IF NOT [EOL] GO 
TEST FOR ':'
02560  C7C4                     
02561  C7C4  A0 02              LDY     #$02               ; ELSE SET THE 
INDEX
02562  C7C6  B1 7A              LDA     (XX7A),Y          ; GET NEXT LINE 
POINTER HIGH BYTE
02563  C7C8  18                 CLC                    ; CLEAR CARRY FOR N
O 'BREAK' MESSAGE
02564  C7C9  D0 03              BNE     XXC7CE          ; BRANCH IF NOT EN
D OF PROGRAM
02565  C7CB                     
02566  C7CB  4C 4B C8           JMP     XXC84B          ; ELSE GO TO IMMED
IATE MODE,WAS IMMEDIATE OR [EOT] MARKER
02567  C7CE                     
02568  C7CE              XXC7CE = *
02569  C7CE  C8                 INY                    ; INCREMENT INDEX
02570  C7CF  B1 7A              LDA     (XX7A),Y          ; GET LINE NUMBE
R LOW BYTE
02571  C7D1  85 39              STA     XX39          ; SAVE CURRENT LINE 
NUMBER LOW BYTE
02572  C7D3  C8                 INY                    ; INCREMENT INDEX
02573  C7D4  B1 7A              LDA     (XX7A),Y          ; GET LINE # HIG
H BYTE
02574  C7D6  85 3A              STA     XX3A          ; SAVE CURRENT LINE 
NUMBER HIGH BYTE
02575  C7D8  98                 TYA                    ; A NOW = 4
02576  C7D9  65 7A              ADC     XX7A          ; ADD BASIC EXECUTE 
POINTER LOW BYTE, NOW POINTS TO CODE
02577  C7DB  85 7A              STA     XX7A          ; SAVE BASIC EXECUTE
 POINTER LOW BYTE
02578  C7DD  90 02              BCC     XXC7E1          ; IF NO OVERFLOW S
KIP THE HIGH BYTE INCREMENT
02579  C7DF                     
02580  C7DF  E6 7B              INC     XX7B          ; ELSE INCREMENT BAS
IC EXECUTE POINTER HIGH BYTE
02581  C7E1              XXC7E1 = *
02582  C7E1  6C 08 03           JMP     (XX0308)          ; DO START NEW B
ASIC CODE
02583  C7E4                     
02584  C7E4                     
02585  C7E4              ;************************************************
***********************************;






****;R......PAGE 0050

LINE# LOC   CODE        LINE


02586  C7E4              ;
02587  C7E4              ; START NEW BASIC CODE, THE START NEW BASIC CODE 
VECTOR IS INITIALISED TO POINT HERE
02588  C7E4              
02589  C7E4              XXC7E4 = *
02590  C7E4  20 73 00           JSR     XX0073          ; INCREMENT AND SC
AN MEMORY
02591  C7E7  20 ED C7           JSR     XXC7ED          ; GO INTERPRET BAS
IC CODE FROM BASIC EXECUTE POINTER
02592  C7EA  4C AE C7           JMP     XXC7AE          ; LOOP
02593  C7ED                     
02594  C7ED                     
02595  C7ED              ;************************************************
***********************************;
02596  C7ED              ;
02597  C7ED              ; GO INTERPRET BASIC CODE FROM BASIC EXECUTE POIN
TER
02598  C7ED              
02599  C7ED              XXC7ED = *
02600  C7ED  F0 3C              BEQ     XXC82B          ; IF THE FIRST BYT
E IS NULL JUST EXIT
02601  C7EF                     
02602  C7EF              XXC7EF = *
02603  C7EF  E9 80              SBC     #$80               ; NORMALISE THE
 TOKEN
02604  C7F1  90 11              BCC     XXC804          ; IF WASN'T TOKEN 
GO DO LET
02605  C7F3                     
02606  C7F3  C9 23              CMP     #TTAB-$80          ; COMPARE WITH 
TOKEN FOR TAB(-$80
02607  C7F5  B0 17              BCS     XXC80E          ; BRANCH IF >= TAB
(
02608  C7F7                     
02609  C7F7  0A                 ASL A                  ; *2 BYTES PER VECT
OR
02610  C7F8  A8                 TAY                    ; COPY TO INDEX
02611  C7F9  B9 0D C0           LDA     XXC00C+1,Y     ; GET VECTOR HIGH B
YTE
02612  C7FC  48                 PHA                    ; PUSH ON STACK
02613  C7FD  B9 0C C0           LDA     XXC00C,Y          ; GET VECTOR LOW
 BYTE
02614  C800  48                 PHA                    ; PUSH ON STACK
02615  C801  4C 73 00           JMP     XX0073          ; INCREMENT AND SC
AN MEMORY AND RETURN. THE RETURN IN
02616  C804                                     ; THIS CASE CALLS THE COMM
AND CODE, THE RETURN FROM
02617  C804                                     ; THAT WILL EVENTUALLY RET
URN TO THE INTERPRETER INNER
02618  C804                                     ; LOOP ABOVE
02619  C804                     
02620  C804              XXC804 = *
02621  C804  4C A5 C9           JMP     XXC9A5          ; PERFORM LET
02622  C807                     
02623  C807                                     ; WAS NOT [EOL]
02624  C807              XXC807 = *
02625  C807  C9 3A              CMP     #':'               ; COMAPRE WITH 
':'
02626  C809  F0 D6              BEQ     XXC7E1          ; IF ':' GO EXECUT
E NEW CODE
02627  C80B                     
02628  C80B                                     ; ELSE ...
02629  C80B              XXC80B = *
02630  C80B  4C 08 CF           JMP     XXCF08          ; DO SYNTAX ERROR 
THEN WARM START
02631  C80E                     
02632  C80E                                     ; TOKEN WAS >= TAB(
02633  C80E              XXC80E = *
02634  C80E  C9 4B              CMP     #TGO-$80          ; COMPARE WITH T
OKEN FOR GO
02635  C810  D0 F9              BNE     XXC80B          ; IF NOT 'GO' DO S
YNTAX ERROR THEN WARM START
02636  C812                     
02637  C812                                     ; ELSE WAS 'GO'
02638  C812  20 73 00           JSR     XX0073          ; INCREMENT AND SC
AN MEMORY
02639  C815  A9 A4              LDA     #TTO          ; SET 'TO' TOKEN
02640  C817  20 FF CE           JSR     XXCEFF          ; SCAN FOR CHR$(A)
, ELSE DO SYNTAX ERROR THEN WARM START






STARTR......PAGE 0051

LINE# LOC   CODE        LINE


02641  C81A  4C A0 C8           JMP     XXC8A0          ; PERFORM GOTO
02642  C81D                     
02643  C81D                     
02644  C81D              ;************************************************
***********************************;
02645  C81D              ;
02646  C81D              ; PERFORM RESTORE
02647  C81D              
02648  C81D              XXC81D = *
02649  C81D  38                 SEC                    ; SET CARRY FOR SUB
TRACT
02650  C81E  A5 2B              LDA     XX2B          ; GET START OF MEMOR
Y LOW BYTE
02651  C820  E9 01              SBC     #$01               ; -1
02652  C822  A4 2C              LDY     XX2C          ; GET START OF MEMOR
Y HIGH BYTE
02653  C824  B0 01              BCS     XXC827          ; IF NO ROLLUNDER 
SKIP THE HIGH BYTE DECREMENT
02654  C826                     
02655  C826  88                 DEY                    ; ELSE DECREMENT HI
GH BYTE
02656  C827              XXC827 = *
02657  C827  85 41              STA     XX41          ; SET DATA POINTER L
OW BYTE
02658  C829  84 42              STY     XX42          ; SET DATA POINTER H
IGH BYTE
02659  C82B              XXC82B = *
02660  C82B  60                 RTS
02661  C82C                     
02662  C82C                     
02663  C82C              ;************************************************
***********************************;
02664  C82C              ;
02665  C82C              ; DO CRTL-C CHECK VECTOR
02666  C82C              
02667  C82C              XXC82C = *
02668  C82C  20 E1 FF           JSR     XXFFE1          ; SCAN STOP KEY
02669  C82F                     
02670  C82F                     
02671  C82F              ;************************************************
***********************************;
02672  C82F              ;
02673  C82F              ; PERFORM STOP
02674  C82F              
02675  C82F              XXC82F = *
02676  C82F  B0 01              BCS     XXC832          ; IF CARRY SET DO 
BREAK INSTEAD OF JUST END
02677  C831                     
02678  C831                     
02679  C831              ;************************************************
***********************************;
02680  C831              ;
02681  C831              ; PERFORM END
02682  C831              
02683  C831              XXC831 = *
02684  C831  18                 CLC                    ; CLEAR CARRY
02685  C832              XXC832 = *
02686  C832  D0 3C              BNE     XXC870          ; RETURN IF WASN'T
 CTRL-C
02687  C834                     
02688  C834  A5 7A              LDA     XX7A          ; GET BASIC EXECUTE 
POINTER LOW BYTE
02689  C836  A4 7B              LDY     XX7B          ; GET BASIC EXECUTE 
POINTER HIGH BYTE
02690  C838  A6 3A              LDX     XX3A          ; GET CURRENT LINE N
UMBER HIGH BYTE
02691  C83A  E8                 INX                    ; INCREMENT IT
02692  C83B  F0 0C              BEQ     XXC849          ; BRANCH IF WAS IM
MEDIATE MODE
02693  C83D                     
02694  C83D  85 3D              STA     XX3D          ; SAVE CONTINUE POIN
TER LOW BYTE
02695  C83F  84 3E              STY     XX3E          ; SAVE CONTINUE POIN
TER HIGH BYTE






****;R......PAGE 0052

LINE# LOC   CODE        LINE


02696  C841  A5 39              LDA     XX39          ; GET CURRENT LINE N
UMBER LOW BYTE
02697  C843  A4 3A              LDY     XX3A          ; GET CURRENT LINE N
UMBER HIGH BYTE
02698  C845  85 3B              STA     XX3B          ; SAVE BREAK LINE NU
MBER LOW BYTE
02699  C847  84 3C              STY     XX3C          ; SAVE BREAK LINE NU
MBER HIGH BYTE
02700  C849              XXC849 = *
02701  C849  68                 PLA                    ; DUMP RETURN ADDRE
SS LOW BYTE
02702  C84A  68                 PLA                    ; DUMP RETURN ADDRE
SS HIGH BYTE
02703  C84B              XXC84B = *
02704  C84B  A9 81              LDA     #<XXC381          ; SET [CR][LF]'B
REAK' POINTER LOW BYTE
02705  C84D  A0 C3              LDY     #>XXC381          ; SET [CR][LF]'B
REAK' POINTER HIGH BYTE
02706  C84F  90 03              BCC     XXC854          ; BRANCH IF WAS PR
OGRAM END
02707  C851                     
02708  C851  4C 69 C4           JMP     XXC469          ; PRINT STRING AND
 DO WARM START
02709  C854                     
02710  C854              XXC854 = *
02711  C854  4C 74 C4           JMP     XXC474          ; DO WARM START
02712  C857                     
02713  C857                     
02714  C857              ;************************************************
***********************************;
02715  C857              ;
02716  C857              ; PERFORM CONT
02717  C857              
02718  C857              XXC857 = *
02719  C857  D0 17              BNE     XXC870          ; EXIT IF FOLLOWIN
G BYTE TO ALLOW SYNTAX ERROR
02720  C859                     
02721  C859  A2 1A              LDX     #$1A               ; ERROR CODE $1
A, CAN'T CONTINUE ERROR
02722  C85B  A4 3E              LDY     XX3E          ; GET CONTINUE POINT
ER HIGH BYTE
02723  C85D  D0 03              BNE     XXC862          ; GO DO CONTINUE I
F WE CAN
02724  C85F                     
02725  C85F  4C 37 C4           JMP     XXC437          ; ELSE DO ERROR #X
 THEN WARM START
02726  C862                     
02727  C862                                     ; WE CAN CONTINUE SO ...
02728  C862              XXC862 = *
02729  C862  A5 3D              LDA     XX3D          ; GET CONTINUE POINT
ER LOW BYTE
02730  C864  85 7A              STA     XX7A          ; SAVE BASIC EXECUTE
 POINTER LOW BYTE
02731  C866  84 7B              STY     XX7B          ; SAVE BASIC EXECUTE
 POINTER HIGH BYTE
02732  C868  A5 3B              LDA     XX3B          ; GET BREAK LINE LOW
 BYTE
02733  C86A  A4 3C              LDY     XX3C          ; GET BREAK LINE HIG
H BYTE
02734  C86C  85 39              STA     XX39          ; SET CURRENT LINE N
UMBER LOW BYTE
02735  C86E  84 3A              STY     XX3A          ; SET CURRENT LINE N
UMBER HIGH BYTE
02736  C870              XXC870 = *
02737  C870  60                 RTS
02738  C871                     
02739  C871                     
02740  C871              ;************************************************
***********************************;
02741  C871              ;
02742  C871              ; PERFORM RUN
02743  C871              
02744  C871              XXC871 = *
02745  C871  08                 PHP                    ; SAVE STATUS
02746  C872  A9 00              LDA     #$00               ; NO CONTROL OR
 KERNAL MESSAGES
02747  C874  20 90 FF           JSR     XXFF90          ; CONTROL KERNAL M
ESSAGES
02748  C877  28                 PLP                    ; RESTORE STATUS
02749  C878  D0 03              BNE     XXC87D          ; BRANCH IF RUN N
02750  C87A                     






STACKR......PAGE 0053

LINE# LOC   CODE        LINE


02751  C87A  4C 59 C6           JMP     XXC659          ; RESET EXECUTION 
TO START, CLEAR VARIABLES, FLUSH STACK
02752  C87D                                     ; AND RETURN
02753  C87D              XXC87D = *
02754  C87D  20 60 C6           JSR     XXC660          ; GO DO 'CLEAR'
02755  C880  4C 97 C8           JMP     XXC897          ; GET N AND DO GOT
O N
02756  C883                     
02757  C883                     
02758  C883              ;************************************************
***********************************;
02759  C883              ;
02760  C883              ; PERFORM GOSUB
02761  C883              
02762  C883              XXC883 = *
02763  C883  A9 03              LDA     #$03               ; NEED 6 BYTES 
FOR GOSUB
02764  C885  20 FB C3           JSR     XXC3FB          ; CHECK ROOM ON ST
ACK FOR 2*A BYTES
02765  C888  A5 7B              LDA     XX7B          ; GET BASIC EXECUTE 
POINTER HIGH BYTE
02766  C88A  48                 PHA                    ; SAVE IT
02767  C88B  A5 7A              LDA     XX7A          ; GET BASIC EXECUTE 
POINTER LOW BYTE
02768  C88D  48                 PHA                    ; SAVE IT
02769  C88E  A5 3A              LDA     XX3A          ; GET CURRENT LINE N
UMBER HIGH BYTE
02770  C890  48                 PHA                    ; SAVE IT
02771  C891  A5 39              LDA     XX39          ; GET CURRENT LINE N
UMBER LOW BYTE
02772  C893  48                 PHA                    ; SAVE IT
02773  C894  A9 8D              LDA     #TGOSUB          ; TOKEN FOR GOSUB

02774  C896  48                 PHA                    ; SAVE IT
02775  C897              XXC897 = *
02776  C897  20 79 00           JSR     XX0079          ; SCAN MEMORY
02777  C89A  20 A0 C8           JSR     XXC8A0          ; PERFORM GOTO
02778  C89D  4C AE C7           JMP     XXC7AE          ; GO DO INTERPRETE
R INNER LOOP
02779  C8A0                     
02780  C8A0                     
02781  C8A0              ;************************************************
***********************************;
02782  C8A0              ;
02783  C8A0              ; PERFORM GOTO
02784  C8A0              
02785  C8A0              XXC8A0 = *
02786  C8A0  20 6B C9           JSR     XXC96B          ; GET FIXED-POINT 
NUMBER INTO TEMPORARY INTEGER
02787  C8A3  20 09 C9           JSR     XXC909          ; SCAN FOR NEXT BA
SIC LINE
02788  C8A6  38                 SEC                    ; SET CARRY FOR SUB
TRACT
02789  C8A7  A5 39              LDA     XX39          ; GET CURRENT LINE N
UMBER LOW BYTE
02790  C8A9  E5 14              SBC     XX14          ; SUBTRACT TEMPORARY
 INTEGER LOW BYTE
02791  C8AB  A5 3A              LDA     XX3A          ; GET CURRENT LINE N
UMBER HIGH BYTE
02792  C8AD  E5 15              SBC     XX15          ; SUBTRACT TEMPORARY
 INTEGER HIGH BYTE
02793  C8AF  B0 0B              BCS     XXC8BC          ; IF CURRENT LINE 
NUMBER >= TEMPORARY INTEGER, GO SEARCH
02794  C8B1                                     ; FROM THE START OF MEMORY

02795  C8B1                     
02796  C8B1  98                 TYA                    ; ELSE COPY LINE IN
DEX TO A
02797  C8B2  38                 SEC                    ; SET CARRY (+1)
02798  C8B3  65 7A              ADC     XX7A          ; ADD BASIC EXECUTE 
POINTER LOW BYTE
02799  C8B5  A6 7B              LDX     XX7B          ; GET BASIC EXECUTE 
POINTER HIGH BYTE
02800  C8B7  90 07              BCC     XXC8C0          ; IF NO OVERFLOW S
KIP THE HIGH BYTE INCREMENT
02801  C8B9                     
02802  C8B9  E8                 INX                    ; INCREMENT HIGH BY
TE
02803  C8BA  B0 04              BCS     XXC8C0          ; GO FIND THE LINE
, BRANCH ALWAYS
02804  C8BC                     
02805  C8BC                     






****;R......PAGE 0054

LINE# LOC   CODE        LINE


02806  C8BC              ;************************************************
***********************************;
02807  C8BC              ;
02808  C8BC              ; SEARCH FOR LINE NUMBER IN TEMPORARY INTEGER FRO
M START OF MEMORY POINTER
02809  C8BC              
02810  C8BC              XXC8BC = *
02811  C8BC  A5 2B              LDA     XX2B          ; GET START OF MEMOR
Y LOW BYTE
02812  C8BE  A6 2C              LDX     XX2C          ; GET START OF MEMOR
Y HIGH BYTE
02813  C8C0                     
02814  C8C0              ; SEARCH FOR LINE # IN TEMPORARY INTEGER FROM (AX
)
02815  C8C0              
02816  C8C0              XXC8C0 = *
02817  C8C0  20 17 C6           JSR     XXC617          ; SEARCH BASIC FOR
 TEMP INTEGER LINE NUMBER FROM AX
02818  C8C3  90 1E              BCC     XXC8E3          ; IF CARRY CLEAR G
O DO UNSDEFINED STATEMENT ERROR
02819  C8C5                     
02820  C8C5                                     ; CARRY ALL READY SET FOR 
SUBTRACT
02821  C8C5  A5 5F              LDA     XX5F          ; GET POINTER LOW BY
TE
02822  C8C7  E9 01              SBC     #$01               ; -1
02823  C8C9  85 7A              STA     XX7A          ; SAVE BASIC EXECUTE
 POINTER LOW BYTE
02824  C8CB  A5 60              LDA     XX60          ; GET POINTER HIGH B
YTE
02825  C8CD  E9 00              SBC     #$00               ; SUBTRACT CARR
Y
02826  C8CF  85 7B              STA     XX7B          ; SAVE BASIC EXECUTE
 POINTER HIGH BYTE
02827  C8D1              XXC8D1 = *
02828  C8D1  60                 RTS
02829  C8D2                     
02830  C8D2                     
02831  C8D2              ;************************************************
***********************************;
02832  C8D2              ;
02833  C8D2              ; PERFORM RETURN
02834  C8D2              
02835  C8D2              XXC8D2 = *
02836  C8D2  D0 FD              BNE     XXC8D1          ; EXIT IF FOLLOWIN
G TOKEN TO ALLOW SYNTAX ERROR
02837  C8D4                     
02838  C8D4  A9 FF              LDA     #$FF               ; SET BYTE SO N
O MATCH POSSIBLE
02839  C8D6  85 4A              STA     XX4A          ; SAVE FOR/NEXT VARI
ABLE POINTER HIGH BYTE
02840  C8D8  20 8A C3           JSR     XXC38A          ; SEARCH THE STACK
 FOR FOR OR GOSUB ACTIVITY,
02841  C8DB                                     ; GET TOKEN OFF STACK
02842  C8DB  9A                 TXS                    ; CORRECT THE STACK

02843  C8DC  C9 8D              CMP     #TGOSUB          ; COMPARE WITH GO
SUB TOKEN
02844  C8DE  F0 0B              BEQ     XXC8EB          ; IF MATCHING GOSU
B GO CONTINUE RETURN
02845  C8E0                     
02846  C8E0  A2 0C              LDX     #$0C               ; ELSE ERROR CO
DE $04, RETURN WITHOUT GOSUB ERROR
02847  C8E2  2C                 .BYTE     $2C               ; MAKES NEXT L
INE BIT XX11A2
02848  C8E3              XXC8E3 = *
02849  C8E3  A2 11              LDX     #$11               ; ERROR CODE $1
1, UNDEFINED STATEMENT ERROR
02850  C8E5  4C 37 C4           JMP     XXC437          ; DO ERROR #X THEN
 WARM START
02851  C8E8                     
02852  C8E8              XXC8E8 = *
02853  C8E8  4C 08 CF           JMP     XXCF08          ; DO SYNTAX ERROR 
THEN WARM START
02854  C8EB                     
02855  C8EB                                     ; WAS MATCHING GOSUB TOKEN

02856  C8EB              XXC8EB = *
02857  C8EB  68                 PLA                    ; DUMP TOKEN BYTE
02858  C8EC  68                 PLA                    ; PULL RETURN LINE 
LOW BYTE
02859  C8ED  85 39              STA     XX39          ; SAVE CURRENT LINE 
NUMBER LOW BYTE
02860  C8EF  68                 PLA                    ; PULL RETURN LINE 
HIGH BYTE






R***;R......PAGE 0055

LINE# LOC   CODE        LINE


02861  C8F0  85 3A              STA     XX3A          ; SAVE CURRENT LINE 
NUMBER HIGH BYTE
02862  C8F2  68                 PLA                    ; PULL RETURN ADDRE
SS LOW BYTE
02863  C8F3  85 7A              STA     XX7A          ; SAVE BASIC EXECUTE
 POINTER LOW BYTE
02864  C8F5  68                 PLA                    ; PULL RETURN ADDRE
SS HIGH BYTE
02865  C8F6  85 7B              STA     XX7B          ; SAVE BASIC EXECUTE
 POINTER HIGH BYTE
02866  C8F8                     
02867  C8F8                     
02868  C8F8              ;************************************************
***********************************;
02869  C8F8              ;
02870  C8F8              ; PERFORM DATA
02871  C8F8              
02872  C8F8              XXC8F8 = *
02873  C8F8  20 06 C9           JSR     XXC906          ; SCAN FOR NEXT BA
SIC STATEMENT ([:] OR [EOL])
02874  C8FB                     
02875  C8FB              ; ADD Y TO THE BASIC EXECUTE POINTER
02876  C8FB              
02877  C8FB              XXC8FB = *
02878  C8FB  98                 TYA                    ; COPY INDEX TO A
02879  C8FC  18                 CLC                    ; CLEAR CARRY FOR A
DD
02880  C8FD  65 7A              ADC     XX7A          ; ADD BASIC EXECUTE 
POINTER LOW BYTE
02881  C8FF  85 7A              STA     XX7A          ; SAVE BASIC EXECUTE
 POINTER LOW BYTE
02882  C901  90 02              BCC     XXC905          ; SKIP INCREMENT I
F NO CARRY
02883  C903                     
02884  C903  E6 7B              INC     XX7B          ; ELSE INCREMENT BAS
IC EXECUTE POINTER HIGH BYTE
02885  C905              XXC905 = *
02886  C905  60                 RTS
02887  C906                     
02888  C906                     
02889  C906              ;************************************************
***********************************;
02890  C906              ;
02891  C906              ; SCAN FOR NEXT BASIC STATEMENT ([:] OR [EOL])
02892  C906              ; RETURNS Y AS INDEX TO [:] OR [EOL]
02893  C906              
02894  C906              XXC906 = *
02895  C906  A2 3A              LDX     #':'               ; SET LOOK FOR 
CHARACTER = ':'
02896  C908  2C                 .BYTE     $2C               ; MAKES NEXT L
INE BIT XX00A2
02897  C909                     
02898  C909              ; SCAN FOR NEXT BASIC LINE
02899  C909              ; RETURNS Y AS INDEX TO [EOL]
02900  C909              
02901  C909              XXC909 = *
02902  C909  A2 00              LDX     #$00               ; SET ALTERNATE
 SEARCH CHARACTER = [EOL]
02903  C90B  86 07              STX     XX07          ; STORE ALTERNATE SE
ARCH CHARACTER
02904  C90D  A0 00              LDY     #$00               ; SET SEARCH CH
ARACTER = [EOL]
02905  C90F  84 08              STY     XX08          ; SAVE THE SEARCH CH
ARACTER
02906  C911              XXC911 = *
02907  C911  A5 08              LDA     XX08          ; GET SEARCH CHARACT
ER
02908  C913  A6 07              LDX     XX07          ; GET ALTERNATE SEAR
CH CHARACTER
02909  C915  85 07              STA     XX07          ; MAKE SEARCH CHARAC
TER = ALTERNATE SEARCH CHARACTER
02910  C917  86 08              STX     XX08          ; MAKE ALTERNATE SEA
RCH CHARACTER = SEARCH CHARACTER
02911  C919              XXC919 = *
02912  C919  B1 7A              LDA     (XX7A),Y          ; GET BASIC BYTE

02913  C91B  F0 E8              BEQ     XXC905          ; EXIT IF NULL [EO
L]
02914  C91D                     
02915  C91D  C5 08              CMP     XX08          ; COMPARE WITH SEARC
H CHARACTER






****;R......PAGE 0056

LINE# LOC   CODE        LINE


02916  C91F  F0 E4              BEQ     XXC905          ; EXIT IF FOUND
02917  C921                     
02918  C921  C8                 INY                    ; ELSE INCREMENT IN
DEX
02919  C922  C9 22              CMP     #$22               ; COMPARE CURRE
NT CHARACTER WITH OPEN QUOTE
02920  C924  D0 F3              BNE     XXC919          ; IF FOUND GO SWAP
 SEARCH CHARACTER FOR ALTERNATE SEARCH
02921  C926                                     ; CHARACTER
02922  C926                     
02923  C926  F0 E9              BEQ     XXC911          ; LOOP FOR NEXT CH
ARACTER, BRANCH ALWAYS
02924  C928                     
02925  C928                     
02926  C928              ;************************************************
***********************************;
02927  C928              ;
02928  C928              ; PERFORM IF
02929  C928              
02930  C928              XXC928 = *
02931  C928  20 9E CD           JSR     XXCD9E          ; EVALUATE EXPRESS
ION
02932  C92B  20 79 00           JSR     XX0079          ; SCAN MEMORY
02933  C92E  C9 89              CMP     #TGOTO          ; COMPARE WITH 'GO
TO' TOKEN
02934  C930  F0 05              BEQ     XXC937          ; IF IT WAS  THE T
OKEN FOR GOTO GO DO IF ... GOTO
02935  C932                     
02936  C932                                     ; WASN'T IF ... GOTO SO MU
ST BE IF ... THEN
02937  C932  A9 A7              LDA     #TTHEN          ; $A7 = 'THEN' TOK
EN
02938  C934  20 FF CE           JSR     XXCEFF          ; SCAN FOR CHR$(A)
, ELSE DO SYNTAX ERROR THEN WARM START
02939  C937              XXC937 = *
02940  C937  A5 61              LDA     XX61          ; GET FAC1 EXPONENT
02941  C939  D0 05              BNE     XXC940          ; IF RESULT WAS NO
N ZERO CONTINUE EXECUTION
02942  C93B                                     ; ELSE REM THE REST OF THE
 LINE
02943  C93B                     
02944  C93B                     
02945  C93B              ;************************************************
***********************************;
02946  C93B              ;
02947  C93B              ; PERFORM REM
02948  C93B              
02949  C93B              XXC93B = *
02950  C93B  20 09 C9           JSR     XXC909          ; SCAN FOR NEXT BA
SIC LINE
02951  C93E  F0 BB              BEQ     XXC8FB          ; ADD Y TO THE BAS
IC EXECUTE POINTER AND RETURN, BRANCH
02952  C940                                     ; ALWAYS
02953  C940                     
02954  C940                     
02955  C940              ;************************************************
***********************************;
02956  C940              ;
02957  C940              ; IF CONTINUED .. RESULT WAS NON ZERO SO DO REST 
OF LINE
02958  C940              
02959  C940              XXC940 = *
02960  C940  20 79 00           JSR     XX0079          ; SCAN MEMORY
02961  C943  B0 03              BCS     XXC948          ; IF NOT NUMERIC C
HARACTER, IS VARIABLE OR KEYWORD
02962  C945                     
02963  C945  4C A0 C8           JMP     XXC8A0          ; ELSE PERFORM GOT
O N
02964  C948                     
02965  C948                                     ; IS VARIABLE OR KEYWORD
02966  C948              XXC948 = *
02967  C948  4C ED C7           JMP     XXC7ED          ; INTERPRET BASIC 
CODE FROM BASIC EXECUTE POINTER
02968  C94B                     
02969  C94B                     
02970  C94B              ;************************************************
***********************************;






****;R......PAGE 0057

LINE# LOC   CODE        LINE


02971  C94B              ;
02972  C94B              ; PERFORM ON
02973  C94B              
02974  C94B              XXC94B = *
02975  C94B  20 9E D7           JSR     XXD79E          ; GET BYTE PARAMET
ER
02976  C94E  48                 PHA                    ; PUSH NEXT CHARACT
ER
02977  C94F  C9 8D              CMP     #TGOSUB          ; COMPARE WITH GO
SUB TOKEN
02978  C951  F0 04              BEQ     XXC957          ; IF GOSUB GO SEE 
IF IT SHOULD BE EXECUTED
02979  C953                     
02980  C953              XXC953 = *
02981  C953  C9 89              CMP     #TGOTO          ; COMPARE WITH GOT
O TOKEN
02982  C955  D0 91              BNE     XXC8E8          ; IF NOT GOTO DO S
YNTAX ERROR THEN WARM START
02983  C957                     
02984  C957              ; NEXT CHARACTER WAS GOTO OR GOSUB, SEE IF IT SHO
ULD BE EXECUTED
02985  C957              
02986  C957              XXC957 = *
02987  C957  C6 65              DEC     XX65          ; DECREMENT THE BYTE
 VALUE
02988  C959  D0 04              BNE     XXC95F          ; IF NOT ZERO GO S
EE IF ANOTHER LINE NUMBER EXISTS
02989  C95B                     
02990  C95B  68                 PLA                    ; PULL KEYWORD TOKE
N
02991  C95C  4C EF C7           JMP     XXC7EF          ; GO EXECUTE IT
02992  C95F                     
02993  C95F              XXC95F = *
02994  C95F  20 73 00           JSR     XX0073          ; INCREMENT AND SC
AN MEMORY
02995  C962  20 6B C9           JSR     XXC96B          ; GET FIXED-POINT 
NUMBER INTO TEMPORARY INTEGER
02996  C965                                     ; SKIP THIS N
02997  C965  C9 2C              CMP     #','               ; COMPARE NEXT 
CHARACTER WITH ','
02998  C967  F0 EE              BEQ     XXC957          ; LOOP IF ','
02999  C969                     
03000  C969  68                 PLA                    ; ELSE PULL KEYWORD
 TOKEN, RAN OUT OF OPTIONS
03001  C96A              XXC96A = *
03002  C96A  60                 RTS
03003  C96B                     
03004  C96B                     
03005  C96B              ;************************************************
***********************************;
03006  C96B              ;
03007  C96B              ; GET FIXED-POINT NUMBER INTO TEMPORARY INTEGER
03008  C96B              
03009  C96B              XXC96B = *
03010  C96B  A2 00              LDX     #$00               ; CLEAR X
03011  C96D  86 14              STX     XX14          ; CLEAR TEMPORARY IN
TEGER LOW BYTE
03012  C96F  86 15              STX     XX15          ; CLEAR TEMPORARY IN
TEGER HIGH BYTE
03013  C971              XXC971 = *
03014  C971  B0 F7              BCS     XXC96A          ; RETURN IF CARRY 
SET, END OF SCAN, CHARACTER WAS NOT 0-9
03015  C973                     
03016  C973  E9 2F              SBC     #$2F               ; SUBTRACT $30,
 $2F+CARRY, FROM BYTE
03017  C975  85 07              STA     XX07          ; STORE #
03018  C977  A5 15              LDA     XX15          ; GET TEMPORARY INTE
GER HIGH BYTE
03019  C979  85 22              STA     XX22          ; SAVE IT FOR NOW
03020  C97B  C9 19              CMP     #$19               ; COMPARE WITH 
$19
03021  C97D  B0 D4              BCS     XXC953          ; BRANCH IF >= THI
S MAKES THE MAXIMUM LINE NUMBER 63999
03022  C97F                                     ; BECAUSE THE NEXT BIT DOE
S $1900 * $0A = $FA00 = 64000
03023  C97F                                     ; DECIMAL. THE BRANCH TARG
ET IS REALLY THE SYNTAX ERROR
03024  C97F                                     ; AT XXC8E8 BUT THAT IS TO
O FAR SO AN INTERMEDIATE
03025  C97F                                     ; COMPARE AND BRANCH TO TH
AT LOCATION IS USED. THE PROBLEM






SULT-9......PAGE 0058

LINE# LOC   CODE        LINE


03026  C97F                                     ; WITH THIS IS THAT LINE N
UMBER THAT GIVES A PARTIAL RESULT
03027  C97F                                     ; FROM $8900 TO $89FF, 350
72X TO 35327X, WILL PASS THE NEW
03028  C97F                                     ; TARGET COMPARE AND WILL 
TRY TO EXECUTE THE REMAINDER OF
03029  C97F                                     ; THE ON N GOTO/GOSUB. A S
OLUTION TO THIS IS TO COPY THE
03030  C97F                                     ; BYTE IN A BEFORE THE BRA
NCH TO X AND THEN BRANCH TO
03031  C97F                                     ; XXC955 SKIPPING THE SECO
ND COMPARE
03032  C97F                     
03033  C97F  A5 14              LDA     XX14          ; GET TEMPORARY INTE
GER LOW BYTE
03034  C981  0A                 ASL A                  ; *2 LOW BYTE
03035  C982  26 22              ROL     XX22          ; *2 HIGH BYTE
03036  C984  0A                 ASL A                  ; *2 LOW BYTE
03037  C985  26 22              ROL     XX22          ; *2 HIGH BYTE (*4)
03038  C987  65 14              ADC     XX14          ; + LOW BYTE (*5)
03039  C989  85 14              STA     XX14          ; SAVE IT
03040  C98B  A5 22              LDA     XX22          ; GET HIGH BYTE TEMP

03041  C98D  65 15              ADC     XX15          ; + HIGH BYTE (*5)
03042  C98F  85 15              STA     XX15          ; SAVE IT
03043  C991  06 14              ASL     XX14          ; *2 LOW BYTE (*10D)

03044  C993  26 15              ROL     XX15          ; *2 HIGH BYTE (*10D
)
03045  C995  A5 14              LDA     XX14          ; GET LOW BYTE
03046  C997  65 07              ADC     XX07          ; ADD #
03047  C999  85 14              STA     XX14          ; SAVE LOW BYTE
03048  C99B  90 02              BCC     XXC99F          ; IF NO OVERFLOW S
KIP HIGH BYTE INCREMENT
03049  C99D                     
03050  C99D  E6 15              INC     XX15          ; ELSE INCREMENT HIG
H BYTE
03051  C99F              XXC99F = *
03052  C99F  20 73 00           JSR     XX0073          ; INCREMENT AND SC
AN MEMORY
03053  C9A2  4C 71 C9           JMP     XXC971          ; LOOP FOR NEXT CH
ARACTER
03054  C9A5                     
03055  C9A5                     
03056  C9A5              ;************************************************
***********************************;
03057  C9A5              ;
03058  C9A5              ; PERFORM LET
03059  C9A5              
03060  C9A5              XXC9A5 = *
03061  C9A5  20 8B D0           JSR     XXD08B          ; GET VARIABLE ADD
RESS
03062  C9A8  85 49              STA     XX49          ; SAVE VARIABLE ADDR
ESS LOW BYTE
03063  C9AA  84 4A              STY     XX4A          ; SAVE VARIABLE ADDR
ESS HIGH BYTE
03064  C9AC  A9 B2              LDA     #TEQUAL          ; $B2 IS '=' TOKE
N
03065  C9AE  20 FF CE           JSR     XXCEFF          ; SCAN FOR CHR$(A)
, ELSE DO SYNTAX ERROR THEN WARM START
03066  C9B1  A5 0E              LDA     XX0E          ; GET DATA TYPE FLAG
, $80 = INTEGER, $00 = FLOAT
03067  C9B3  48                 PHA                    ; PUSH DATA TYPE FL
AG
03068  C9B4  A5 0D              LDA     XX0D          ; GET DATA TYPE FLAG
, $FF = STRING, $00 = NUMERIC
03069  C9B6  48                 PHA                    ; PUSH DATA TYPE FL
AG
03070  C9B7  20 9E CD           JSR     XXCD9E          ; EVALUATE EXPRESS
ION
03071  C9BA  68                 PLA                    ; POP DATA TYPE FLA
G
03072  C9BB  2A                 ROL A                  ; STRING BIT INTO C
ARRY
03073  C9BC  20 90 CD           JSR     XXCD90          ; DO TYPE MATCH CH
ECK
03074  C9BF  D0 18              BNE     XXC9D9          ; IF STRING GO ASS
IGN A STRING VALUE
03075  C9C1                     
03076  C9C1  68                 PLA                    ; POP INTEGER/FLOAT
 DATA TYPE FLAG
03077  C9C2                     
03078  C9C2              ; ASSIGN VALUE TO NUMERIC VARIABLE
03079  C9C2              
03080  C9C2              XXC9C2 = *






START9......PAGE 0059

LINE# LOC   CODE        LINE


03081  C9C2  10 12              BPL     XXC9D6          ; IF FLOAT GO ASSI
GN A FLOATING VALUE
03082  C9C4                     
03083  C9C4                                     ; EXPRESSION IS NUMERIC IN
TEGER
03084  C9C4  20 1B DC           JSR     XXDC1B          ; ROUND FAC1
03085  C9C7  20 BF D1           JSR     XXD1BF          ; EVALUATE INTEGER
 EXPRESSION, NO SIGN CHECK
03086  C9CA  A0 00              LDY     #$00               ; CLEAR INDEX
03087  C9CC  A5 64              LDA     XX64          ; GET FAC1 MANTISSA 
3
03088  C9CE  91 49              STA     (XX49),Y          ; SAVE AS INTEGE
R VARIABLE LOW BYTE
03089  C9D0  C8                 INY                    ; INCREMENT INDEX
03090  C9D1  A5 65              LDA     XX65          ; GET FAC1 MANTISSA 
4
03091  C9D3  91 49              STA     (XX49),Y          ; SAVE AS INTEGE
R VARIABLE HIGH BYTE
03092  C9D5  60                 RTS
03093  C9D6                     
03094  C9D6              XXC9D6 = *
03095  C9D6  4C D0 DB           JMP     XXDBD0          ; PACK FAC1 INTO V
ARIABLE POINTER AND RETURN
03096  C9D9                     
03097  C9D9              ; ASSIGN VALUE TO STRING VARIABLE
03098  C9D9              
03099  C9D9              XXC9D9 = *
03100  C9D9  68                 PLA                    ; DUMP INTEGER/FLOA
T DATA TYPE FLAG
03101  C9DA              XXC9DA = *
03102  C9DA  A4 4A              LDY     XX4A          ; GET VARIABLE POINT
ER HIGH BYTE
03103  C9DC  C0 DF              CPY     #>XXDF13          ; WAS IT TI$ POI
NTER
03104  C9DE  D0 4C              BNE     XXCA2C          ; BRANCH IF NOT
03105  C9E0                     
03106  C9E0                                     ; ELSE IT'S TI$ = <EXPR$>
03107  C9E0  20 A6 D6           JSR     XXD6A6          ; POP STRING OFF D
ESCRIPTOR STACK, OR FROM TOP OF STRING
03108  C9E3                                     ; SPACE RETURNS WITH A = L
ENGTH, X = POINTER LOW BYTE,
03109  C9E3                                     ; Y = POINTER HIGH BYTE
03110  C9E3  C9 06              CMP     #$06               ; COMPARE LENGT
H WITH 6
03111  C9E5  D0 3D              BNE     XXCA24          ; IF LENGTH NOT 6 
DO ILLEGAL QUANTITY ERROR THEN WARM START
03112  C9E7                     
03113  C9E7  A0 00              LDY     #$00               ; CLEAR INDEX
03114  C9E9  84 61              STY     XX61          ; CLEAR FAC1 EXPONEN
T
03115  C9EB  84 66              STY     XX66          ; CLEAR FAC1 SIGN (B
7)
03116  C9ED              XXC9ED = *
03117  C9ED  84 71              STY     XX71          ; SAVE INDEX
03118  C9EF  20 1D CA           JSR     XXCA1D          ; CHECK AND EVALUA
TE NUMERIC DIGIT
03119  C9F2  20 E2 DA           JSR     XXDAE2          ; MULTIPLY FAC1 BY
 10
03120  C9F5  E6 71              INC     XX71          ; INCREMENT INDEX
03121  C9F7  A4 71              LDY     XX71          ; RESTORE INDEX
03122  C9F9  20 1D CA           JSR     XXCA1D          ; CHECK AND EVALUA
TE NUMERIC DIGIT
03123  C9FC  20 0C DC           JSR     XXDC0C          ; ROUND AND COPY F
AC1 TO FAC2
03124  C9FF  AA                 TAX                    ; COPY FAC1 EXPONEN
T
03125  CA00  F0 05              BEQ     XXCA07          ; BRANCH IF FAC1 Z
ERO
03126  CA02                     
03127  CA02  E8                 INX                    ; INCREMENT INDEX, 
* 2
03128  CA03  8A                 TXA                    ; COPY BACK TO A
03129  CA04  20 ED DA           JSR     XXDAED          ; FAC1 = (FAC1 + (
FAC2 * 2)) * 2 = FAC1 * 6
03130  CA07              XXCA07 = *
03131  CA07  A4 71              LDY     XX71          ; GET INDEX
03132  CA09  C8                 INY                    ; INCREMENT INDEX
03133  CA0A  C0 06              CPY     #$06               ; COMPARE INDEX
 WITH 6
03134  CA0C  D0 DF              BNE     XXC9ED          ; LOOP IF NOT 6
03135  CA0E                     






RM STA......PAGE 0060

LINE# LOC   CODE        LINE


03136  CA0E  20 E2 DA           JSR     XXDAE2          ; MULTIPLY FAC1 BY
 10
03137  CA11  20 9B DC           JSR     XXDC9B          ; CONVERT FAC1 FLO
ATING TO FIXED
03138  CA14  A6 64              LDX     XX64          ; GET FAC1 MANTISSA 
3
03139  CA16  A4 63              LDY     XX63          ; GET FAC1 MANTISSA 
2
03140  CA18  A5 65              LDA     XX65          ; GET FAC1 MANTISSA 
4
03141  CA1A  4C DB FF           JMP     XXFFDB          ; SET REAL TIME CL
OCK AND RETURN
03142  CA1D                     
03143  CA1D              ; CHECK AND EVALUATE NUMERIC DIGIT
03144  CA1D              
03145  CA1D              XXCA1D = *
03146  CA1D  B1 22              LDA     (XX22),Y          ; GET BYTE FROM 
STRING
03147  CA1F  20 80 00           JSR     XX80          ; CLEAR CB IF NUMERI
C. THIS CALL SHOULD BE TO XX84
03148  CA22                                     ; AS THE CODE FROM XX80 FI
RST COMAPRES THE BYTE WITH
03149  CA22                                     ; [SPACE] AND DOES A BASIC
 INCREMENT AND GET IF IT IS
03150  CA22  90 03              BCC     XXCA27          ; BRANCH IF NUMERI
C
03151  CA24                     
03152  CA24              XXCA24 = *
03153  CA24  4C 48 D2           JMP     XXD248          ; DO ILLEGAL QUANT
ITY ERROR THEN WARM START
03154  CA27                     
03155  CA27              XXCA27 = *
03156  CA27  E9 2F              SBC     #$2F               ; SUBTRACT $2F 
+ CARRY TO CONVERT ASCII TO BINARY
03157  CA29  4C 7E DD           JMP     XXDD7E          ; EVALUATE NEW ASC
II DIGIT AND RETURN
03158  CA2C                     
03159  CA2C              ; ASSIGN VALUE TO STRING VARIABLE, BUT NOT TI$
03160  CA2C              
03161  CA2C              XXCA2C = *
03162  CA2C  A0 02              LDY     #$02               ; INDEX TO STRI
NG POINTER HIGH BYTE
03163  CA2E  B1 64              LDA     (XX64),Y          ; GET STRING POI
NTER HIGH BYTE
03164  CA30  C5 34              CMP     XX34          ; COMPARE WITH BOTTO
M OF STRING SPACE HIGH BYTE
03165  CA32  90 17              BCC     XXCA4B          ; BRANCH IF STRING
 POINTER HIGH BYTE IS LESS THAN BOTTOM
03166  CA34                                     ; OF STRING SPACE HIGH BYT
E
03167  CA34                     
03168  CA34  D0 07              BNE     XXCA3D          ; BRANCH IF STRING
 POINTER HIGH BYTE IS GREATER THAN
03169  CA36                                     ; BOTTOM OF STRING SPACE H
IGH BYTE
03170  CA36                     
03171  CA36                                     ; ELSE HIGH BYTES WERE EQU
AL
03172  CA36  88                 DEY                    ; DECREMENT INDEX T
O STRING POINTER LOW BYTE
03173  CA37  B1 64              LDA     (XX64),Y          ; GET STRING POI
NTER LOW BYTE
03174  CA39  C5 33              CMP     XX33          ; COMPARE WITH BOTTO
M OF STRING SPACE LOW BYTE
03175  CA3B  90 0E              BCC     XXCA4B          ; BRANCH IF STRING
 POINTER LOW BYTE IS LESS THAN BOTTOM
03176  CA3D                                     ; OF STRING SPACE LOW BYTE

03177  CA3D                     
03178  CA3D              XXCA3D = *
03179  CA3D  A4 65              LDY     XX65          ; GET DESCRIPTOR POI
NTER HIGH BYTE
03180  CA3F  C4 2E              CPY     XX2E          ; COMPARE WITH START
 OF VARIABLES HIGH BYTE
03181  CA41  90 08              BCC     XXCA4B          ; BRANCH IF LESS, 
IS ON STRING STACK
03182  CA43                     
03183  CA43  D0 0D              BNE     XXCA52          ; IF GREATER MAKE 
SPACE AND COPY STRING
03184  CA45                     
03185  CA45                                     ; ELSE HIGH BYTES WERE EQU
AL
03186  CA45  A5 64              LDA     XX64          ; GET DESCRIPTOR POI
NTER LOW BYTE
03187  CA47  C5 2D              CMP     XX2D          ; COMPARE WITH START
 OF VARIABLES LOW BYTE
03188  CA49  B0 07              BCS     XXCA52          ; IF GREATER OR EQ
UAL MAKE SPACE AND COPY STRING
03189  CA4B                     
03190  CA4B              XXCA4B = *






TTOMMA......PAGE 0061

LINE# LOC   CODE        LINE


03191  CA4B  A5 64              LDA     XX64          ; GET DESCRIPTOR POI
NTER LOW BYTE
03192  CA4D  A4 65              LDY     XX65          ; GET DESCRIPTOR POI
NTER HIGH BYTE
03193  CA4F  4C 68 CA           JMP     XXCA68          ; GO COPY DESCRIPT
OR TO VARIABLE
03194  CA52                     
03195  CA52              XXCA52 = *
03196  CA52  A0 00              LDY     #$00               ; CLEAR INDEX
03197  CA54  B1 64              LDA     (XX64),Y          ; GET STRING LEN
GTH
03198  CA56  20 75 D4           JSR     XXD475          ; COPY DESCRIPTOR 
POINTER AND MAKE STRING SPACE A BYTES LONG
03199  CA59  A5 50              LDA     XX50          ; COPY OLD DESCRIPTO
R POINTER LOW BYTE
03200  CA5B  A4 51              LDY     XX51          ; COPY OLD DESCRIPTO
R POINTER HIGH BYTE
03201  CA5D  85 6F              STA     XX6F          ; SAVE OLD DESCRIPTO
R POINTER LOW BYTE
03202  CA5F  84 70              STY     XX70          ; SAVE OLD DESCRIPTO
R POINTER HIGH BYTE
03203  CA61  20 7A D6           JSR     XXD67A          ; COPY STRING FROM
 DESCRIPTOR TO UTILITY POINTER
03204  CA64  A9 61              LDA     #<XX61          ; GET DESCRIPTOR P
OINTER LOW BYTE
03205  CA66  A0 00              LDY     #>XX61          ; GET DESCRIPTOR P
OINTER HIGH BYTE
03206  CA68              XXCA68 = *
03207  CA68  85 50              STA     XX50          ; SAVE DESCRIPTOR PO
INTER LOW BYTE
03208  CA6A  84 51              STY     XX51          ; SAVE DESCRIPTOR PO
INTER HIGH BYTE
03209  CA6C  20 DB D6           JSR     XXD6DB          ; CLEAN DESCRIPTOR
 STACK, YA = POINTER
03210  CA6F  A0 00              LDY     #$00               ; CLEAR INDEX
03211  CA71  B1 50              LDA     (XX50),Y          ; GET STRING LEN
GTH FROM NEW DESCRIPTOR
03212  CA73  91 49              STA     (XX49),Y          ; COPY STRING LE
NGTH TO VARIABLE
03213  CA75  C8                 INY                    ; INCREMENT INDEX
03214  CA76  B1 50              LDA     (XX50),Y          ; GET STRING POI
NTER LOW BYTE FROM NEW DESCRIPTOR
03215  CA78  91 49              STA     (XX49),Y          ; COPY STRING PO
INTER LOW BYTE TO VARIABLE
03216  CA7A  C8                 INY                    ; INCREMENT INDEX
03217  CA7B  B1 50              LDA     (XX50),Y          ; GET STRING POI
NTER HIGH BYTE FROM NEW DESCRIPTOR
03218  CA7D  91 49              STA     (XX49),Y          ; COPY STRING PO
INTER HIGH BYTE TO VARIABLE
03219  CA7F  60                 RTS
03220  CA80                     
03221  CA80                     
03222  CA80              ;************************************************
***********************************;
03223  CA80              ;
03224  CA80              ; PERFORM PRINT#
03225  CA80              
03226  CA80              XXCA80 = *
03227  CA80  20 86 CA           JSR     XXCA86          ; PERFORM CMD
03228  CA83  4C B5 CB           JMP     XXCBB5          ; CLOSE INPUT AND 
OUTPUT CHANNELS AND RETURN
03229  CA86                     
03230  CA86                     
03231  CA86              ;************************************************
***********************************;
03232  CA86              ;
03233  CA86              ; PERFORM CMD
03234  CA86              
03235  CA86              XXCA86 = *
03236  CA86  20 9E D7           JSR     XXD79E          ; GET BYTE PARAMET
ER
03237  CA89  F0 05              BEQ     XXCA90          ; BRANCH IF FOLLOW
ING BYTE IS ':' OR [EOT]
03238  CA8B                     
03239  CA8B  A9 2C              LDA     #','               ; SET ','
03240  CA8D  20 FF CE           JSR     XXCEFF          ; SCAN FOR CHR$(A)
, ELSE DO SYNTAX ERROR THEN WARM START
03241  CA90              XXCA90 = *
03242  CA90  08                 PHP                    ; SAVE STATUS
03243  CA91  86 13              STX     XX13          ; SET CURRENT I/O CH
ANNEL
03244  CA93  20 15 E1           JSR     XXE115          ; OPEN CHANNEL FOR
 OUTPUT WITH ERROR CHECK
03245  CA96  28                 PLP                    ; RESTORE STATUS






STARTL......PAGE 0062

LINE# LOC   CODE        LINE


03246  CA97  4C A0 CA           JMP     XXCAA0          ; PERFORM PRINT
03247  CA9A                     
03248  CA9A                     
03249  CA9A              ;************************************************
***********************************;
03250  CA9A              ;
03251  CA9A              ; PRINT STRING, SCAN MEMORY AND CONTINUE PRINT
03252  CA9A              
03253  CA9A              XXCA9A = *
03254  CA9A  20 21 CB           JSR     XXCB21          ; PRINT STRING FRO
M UTILITY POINTER
03255  CA9D                     
03256  CA9D              ; SCAN MEMORY AND CONTINUE PRINT
03257  CA9D              
03258  CA9D              XXCA9D = *
03259  CA9D  20 79 00           JSR     XX0079          ; SCAN MEMORY
03260  CAA0                     
03261  CAA0                     
03262  CAA0              ;************************************************
***********************************;
03263  CAA0              ;
03264  CAA0              ; PERFORM PRINT
03265  CAA0              
03266  CAA0              XXCAA0 = *
03267  CAA0  F0 35              BEQ     XXCAD7          ; IF NOTHING FOLLO
WING JUST PRINT CR/LF
03268  CAA2                     
03269  CAA2              XXCAA2 = *
03270  CAA2  F0 43              BEQ     XXCAE7          ; IF NOTHING FOLLO
WING EXIT, END OF PRINT BRANCH
03271  CAA4                     
03272  CAA4  C9 A3              CMP     #TTAB          ; COMPARE WITH TOKE
N FOR TAB(
03273  CAA6  F0 50              BEQ     XXCAF8          ; IF TAB( GO HANDL
E IT
03274  CAA8                     
03275  CAA8  C9 A6              CMP     #TSPC          ; COMPARE WITH TOKE
N FOR SPC(
03276  CAAA  18                 CLC                    ; FLAG SPC(
03277  CAAB  F0 4B              BEQ     XXCAF8          ; IF SPC( GO HANDL
E IT
03278  CAAD                     
03279  CAAD  C9 2C              CMP     #','               ; COMPARE WITH 
','
03280  CAAF  F0 37              BEQ     XXCAE8          ; IF ',' GO SKIP T
O THE NEXT TAB POSITION
03281  CAB1                     
03282  CAB1  C9 3B              CMP     #$3B               ; COMPARE WITH 
';'
03283  CAB3  F0 5E              BEQ     XXCB13          ; IF ';' GO CONTIN
UE THE PRINT LOOP
03284  CAB5                     
03285  CAB5  20 9E CD           JSR     XXCD9E          ; EVALUATE EXPRESS
ION
03286  CAB8  24 0D              BIT     XX0D          ; TEST DATA TYPE FLA
G, $FF = STRING, $00 = NUMERIC
03287  CABA  30 DE              BMI     XXCA9A          ; IF STRING GO PRI
NT STRING, SCAN MEMORY AND CONTINUE PRINT
03288  CABC                     
03289  CABC  20 DD DD           JSR     XXDDDD          ; CONVERT FAC1 TO 
ASCII STRING RESULT IN (AY)
03290  CABF  20 87 D4           JSR     XXD487          ; PRINT ' TERMINAT
ED STRING TO UTILITY POINTER
03291  CAC2  20 21 CB           JSR     XXCB21          ; PRINT STRING FRO
M UTILITY POINTER
03292  CAC5  20 3B CB           JSR     XXCB3B          ; PRINT [SPACE] OR
 [CURSOR RIGHT]
03293  CAC8  D0 D3              BNE     XXCA9D          ; GO SCAN MEMORY A
ND CONTINUE PRINT, BRANCH ALWAYS
03294  CACA                     
03295  CACA                     
03296  CACA              ;************************************************
***********************************;
03297  CACA              ;
03298  CACA              ; SET XY TO XX0200 - 1 AND PRINT [CR]
03299  CACA              
03300  CACA              XXCACA = *






****;I......PAGE 0063

LINE# LOC   CODE        LINE


03301  CACA  A9 00              LDA     #$00               ; CLEAR A
03302  CACC  9D 00 02           STA     XX0200,X          ; CLEAR FIRST BY
TE OF INPUT BUFFER
03303  CACF  A2 FF              LDX     #<XX01FF          ; XX0200 - 1 LOW
 BYTE
03304  CAD1  A0 01              LDY     #>XX01FF          ; XX0200 - 1 HIG
H BYTE
03305  CAD3  A5 13              LDA     XX13          ; GET CURRENT I/O CH
ANNEL
03306  CAD5  D0 10              BNE     XXCAE7          ; EXIT IF NOT DEFA
ULT CHANNEL
03307  CAD7                     
03308  CAD7                     
03309  CAD7              ;************************************************
***********************************;
03310  CAD7              ;
03311  CAD7              ; PRINT CR/LF
03312  CAD7              
03313  CAD7              XXCAD7 = *
03314  CAD7  A9 0D              LDA     #$0D               ; SET [CR]
03315  CAD9  20 47 CB           JSR     XXCB47          ; PRINT THE CHARAC
TER
03316  CADC  24 13              BIT     XX13          ; TEST CURRENT I/O C
HANNEL
03317  CADE  10 05              BPL     XXCAE5          ; IF THE AUTOLF BI
T IS NOT SET SKIP THE LF
03318  CAE0                     
03319  CAE0              ; IT WOULD SEEM FROM OTHER PARTS OF THE CODE THAT
 USING B7 AS AN AUTOLF FLAG BIT IS
03320  CAE0              ; NO LONGER SUPPORTED AND SETTING THIS BIT WOULD 
BREAK THINGS IN A LOT OF PLACES
03321  CAE0              
03322  CAE0  A9 0A              LDA     #$0A               ; SET [LF]
03323  CAE2  20 47 CB           JSR     XXCB47          ; PRINT THE CHARAC
TER
03324  CAE5                     
03325  CAE5                     
03326  CAE5              ;************************************************
***********************************;
03327  CAE5              ;
03328  CAE5              ; TOGGLE A
03329  CAE5              
03330  CAE5              XXCAE5 = *
03331  CAE5  49 FF              EOR     #$FF               ; INVERT A
03332  CAE7              XXCAE7 = *
03333  CAE7  60                 RTS
03334  CAE8                     
03335  CAE8                     
03336  CAE8              ;************************************************
***********************************;
03337  CAE8              ;
03338  CAE8              ; CONTINUING PRINT, THE CHARACTER WAS ','
03339  CAE8              
03340  CAE8              XXCAE8 = *
03341  CAE8  38                 SEC                    ; SET CB FOR READ C
URSOR POSITION
03342  CAE9  20 F0 FF           JSR     XXFFF0          ; READ/SET X,Y CUR
SOR POSITION
03343  CAEC  98                 TYA                    ; COPY CURSOR Y
03344  CAED  38                 SEC                    ; SET CARRY FOR SUB
TRACT
03345  CAEE              XXCAEE = *
03346  CAEE  E9 0B              SBC     #$0B               ; SUBTRACT ONE 
TAB LENGTH
03347  CAF0  B0 FC              BCS     XXCAEE          ; LOOP IF RESULT W
AS +VE
03348  CAF2                     
03349  CAF2  49 FF              EOR     #$FF               ; COMPLEMENT IT

03350  CAF4  69 01              ADC     #$01               ; +1, TWOS COMP
LEMENT
03351  CAF6  D0 16              BNE     XXCB0E          ; PRINT A SPACES, 
BRANCH ALWAYS, RESULT IS NEVER $00
03352  CAF8                     
03353  CAF8                     
03354  CAF8              ;************************************************
***********************************;
03355  CAF8              ;






****;I......PAGE 0064

LINE# LOC   CODE        LINE


03356  CAF8              ; HANDLE TAB( OR SPC(
03357  CAF8              
03358  CAF8              XXCAF8 = *
03359  CAF8  08                 PHP                    ; SAVE TAB( OR SPC(
 STATUS
03360  CAF9  38                 SEC                    ; SET CB FOR READ C
URSOR POSITION
03361  CAFA  20 F0 FF           JSR     XXFFF0          ; READ/SET X,Y CUR
SOR POSITION
03362  CAFD  84 09              STY     XX09          ; SAVE CURRENT CURSO
R POSITION
03363  CAFF  20 9B D7           JSR     XXD79B          ; SCAN AND GET BYT
E PARAMETER
03364  CB02  C9 29              CMP     #$29               ; COMPARE WITH 
')'
03365  CB04  D0 59              BNE     XXCB5F          ; IF NOT ')' DO SY
NTAX ERROR
03366  CB06                     
03367  CB06  28                 PLP                    ; RESTORE TAB( OR S
PC( STATUS
03368  CB07  90 06              BCC     XXCB0F          ; BRANCH IF WAS SP
C(
03369  CB09                     
03370  CB09                                     ; ELSE WAS TAB(
03371  CB09  8A                 TXA                    ; COPY TAB() BYTE T
O A
03372  CB0A  E5 09              SBC     XX09          ; SUBTRACT CURRENT C
URSOR POSITION
03373  CB0C  90 05              BCC     XXCB13          ; GO LOOP FOR NEXT
 IF ALREADY PAST REQUITED POSITION
03374  CB0E                     
03375  CB0E              XXCB0E = *
03376  CB0E  AA                 TAX                    ; COPY [SPACE] COUN
T TO X
03377  CB0F              XXCB0F = *
03378  CB0F  E8                 INX                    ; INCREMENT COUNT
03379  CB10              XXCB10 = *
03380  CB10  CA                 DEX                    ; DECREMENT COUNT
03381  CB11  D0 06              BNE     XXCB19          ; BRANCH IF COUNT 
WAS NOT ZERO
03382  CB13                     
03383  CB13                                     ; WAS ';' OR [SPACES] PRIN
TED
03384  CB13              XXCB13 = *
03385  CB13  20 73 00           JSR     XX0073          ; INCREMENT AND SC
AN MEMORY
03386  CB16  4C A2 CA           JMP     XXCAA2          ; CONTINUE PRINT L
OOP
03387  CB19                     
03388  CB19              XXCB19 = *
03389  CB19  20 3B CB           JSR     XXCB3B          ; PRINT [SPACE] OR
 [CURSOR RIGHT]
03390  CB1C  D0 F2              BNE     XXCB10          ; LOOP, BRANCH ALW
AYS
03391  CB1E                     
03392  CB1E                     
03393  CB1E              ;************************************************
***********************************;
03394  CB1E              ;
03395  CB1E              ; PRINT NULL TERMINATED STRING
03396  CB1E              
03397  CB1E              XXCB1E = *
03398  CB1E  20 87 D4           JSR     XXD487          ; PRINT ' TERMINAT
ED STRING TO UTILITY POINTER
03399  CB21                     
03400  CB21              ; PRINT STRING FROM UTILITY POINTER
03401  CB21              
03402  CB21              XXCB21 = *
03403  CB21  20 A6 D6           JSR     XXD6A6          ; POP STRING OFF D
ESCRIPTOR STACK, OR FROM TOP OF STRING
03404  CB24                                     ; SPACE RETURNS WITH A = L
ENGTH, X = POINTER LOW BYTE,
03405  CB24                                     ; Y = POINTER HIGH BYTE
03406  CB24  AA                 TAX                    ; COPY LENGTH
03407  CB25  A0 00              LDY     #$00               ; CLEAR INDEX
03408  CB27  E8                 INX                    ; INCREMENT LENGTH,
 FOR PRE DECREMENT LOOP
03409  CB28              XXCB28 = *
03410  CB28  CA                 DEX                    ; DECREMENT LENGTH






TRINGI......PAGE 0065

LINE# LOC   CODE        LINE


03411  CB29  F0 BC              BEQ     XXCAE7          ; EXIT IF DONE
03412  CB2B                     
03413  CB2B  B1 22              LDA     (XX22),Y          ; GET BYTE FROM 
STRING
03414  CB2D  20 47 CB           JSR     XXCB47          ; PRINT THE CHARAC
TER
03415  CB30  C8                 INY                    ; INCREMENT INDEX
03416  CB31  C9 0D              CMP     #$0D               ; COMPARE BYTE 
WITH [CR]
03417  CB33  D0 F3              BNE     XXCB28          ; LOOP IF NOT [CR]

03418  CB35                     
03419  CB35  20 E5 CA           JSR     XXCAE5          ; TOGGLE A, EOR #$
FF. WHAT IS THE POINT OF THIS ??
03420  CB38  4C 28 CB           JMP     XXCB28          ; LOOP
03421  CB3B                     
03422  CB3B                     
03423  CB3B              ;************************************************
***********************************;
03424  CB3B              ;
03425  CB3B              ; PRINT [SPACE] OR [CURSOR RIGHT]
03426  CB3B              
03427  CB3B              XXCB3B = *
03428  CB3B  A5 13              LDA     XX13          ; GET CURRENT I/O CH
ANNEL
03429  CB3D  F0 03              BEQ     XXCB42          ; IF DEFAULT CHANN
EL GO OUTPUT [CURSOR RIGHT]
03430  CB3F                     
03431  CB3F  A9 20              LDA     #' '               ; ELSE OUTPUT [
SPACE]
03432  CB41  2C                 .BYTE     $2C               ; MAKES NEXT L
INE BIT XX1DA9
03433  CB42              XXCB42 = *
03434  CB42  A9 1D              LDA     #$1D               ; SET [CURSOR R
IGHT]
03435  CB44  2C                 .BYTE     $2C               ; MAKES NEXT L
INE BIT XX3FA9
03436  CB45                     
03437  CB45                     
03438  CB45              ;************************************************
***********************************;
03439  CB45              ;
03440  CB45              ; PRINT '?'
03441  CB45              
03442  CB45              XXCB45 = *
03443  CB45  A9 3F              LDA     #'?'               ; SET '?'
03444  CB47                     
03445  CB47                     
03446  CB47              ;************************************************
***********************************;
03447  CB47              ;
03448  CB47              ; PRINT A CHARACTER
03449  CB47              
03450  CB47              XXCB47 = *
03451  CB47  20 09 E1           JSR     XXE109          ; OUTPUT CHARACTER
 TO CHANNEL WITH ERROR CHECK
03452  CB4A  29 FF              AND     #$FF               ; SET THE FLAGS
 ON A
03453  CB4C  60                 RTS
03454  CB4D                     
03455  CB4D                     
03456  CB4D              ;************************************************
***********************************;
03457  CB4D              ;
03458  CB4D              ; BAD INPUT ROUTINE
03459  CB4D              
03460  CB4D              XXCB4D = *
03461  CB4D  A5 11              LDA     XX11          ; GET INPUT MODE FLA
G, $00 = INPUT, $40 = GET, $98 = READ
03462  CB4F  F0 11              BEQ     XXCB62          ; BRANCH IF INPUT
03463  CB51                     
03464  CB51  30 04              BMI     XXCB57          ; BRANCH IF READ
03465  CB53                     






READ;I......PAGE 0066

LINE# LOC   CODE        LINE


03466  CB53                                     ; ELSE WAS GET
03467  CB53  A0 FF              LDY     #$FF               ; SET CURRENT L
INE HIGH BYTE TO -1, INDICATE IMMEDIATE MODE
03468  CB55  D0 04              BNE     XXCB5B          ; BRANCH ALWAYS
03469  CB57                     
03470  CB57              XXCB57 = *
03471  CB57  A5 3F              LDA     XX3F          ; GET CURRENT DATA L
INE NUMBER LOW BYTE
03472  CB59  A4 40              LDY     XX40          ; GET CURRENT DATA L
INE NUMBER HIGH BYTE
03473  CB5B              XXCB5B = *
03474  CB5B  85 39              STA     XX39          ; SET CURRENT LINE N
UMBER LOW BYTE
03475  CB5D  84 3A              STY     XX3A          ; SET CURRENT LINE N
UMBER HIGH BYTE
03476  CB5F              XXCB5F = *
03477  CB5F  4C 08 CF           JMP     XXCF08          ; DO SYNTAX ERROR 
THEN WARM START
03478  CB62                     
03479  CB62                                     ; WAS INPUT
03480  CB62              XXCB62 = *
03481  CB62  A5 13              LDA     XX13          ; GET CURRENT I/O CH
ANNEL
03482  CB64  F0 05              BEQ     XXCB6B          ; IF DEFAULT CHANN
EL GO DO '?REDO FROM START' MESSAGE
03483  CB66                     
03484  CB66  A2 18              LDX     #$18               ; ELSE ERROR $1
8, FILE DATA ERROR
03485  CB68  4C 37 C4           JMP     XXC437          ; DO ERROR #X THEN
 WARM START
03486  CB6B                     
03487  CB6B              XXCB6B = *
03488  CB6B  A9 0C              LDA     #<XXCD0C          ; SET '?REDO FRO
M START' POINTER LOW BYTE
03489  CB6D  A0 CD              LDY     #>XXCD0C          ; SET '?REDO FRO
M START' POINTER HIGH BYTE
03490  CB6F  20 1E CB           JSR     XXCB1E          ; PRINT NULL TERMI
NATED STRING
03491  CB72  A5 3D              LDA     XX3D          ; GET CONTINUE POINT
ER LOW BYTE
03492  CB74  A4 3E              LDY     XX3E          ; GET CONTINUE POINT
ER HIGH BYTE
03493  CB76  85 7A              STA     XX7A          ; SAVE BASIC EXECUTE
 POINTER LOW BYTE
03494  CB78  84 7B              STY     XX7B          ; SAVE BASIC EXECUTE
 POINTER HIGH BYTE
03495  CB7A  60                 RTS
03496  CB7B                     
03497  CB7B                     
03498  CB7B              ;************************************************
***********************************;
03499  CB7B              ;
03500  CB7B              ; PERFORM GET
03501  CB7B              
03502  CB7B              XXCB7B = *
03503  CB7B  20 A6 D3           JSR     XXD3A6          ; CHECK NOT DIRECT
, BACK HERE IF OK
03504  CB7E  C9 23              CMP     #'#'               ; COMPARE WITH 
'#'
03505  CB80  D0 10              BNE     XXCB92          ; BRANCH IF NOT GE
T#
03506  CB82                     
03507  CB82  20 73 00           JSR     XX0073          ; INCREMENT AND SC
AN MEMORY
03508  CB85  20 9E D7           JSR     XXD79E          ; GET BYTE PARAMET
ER
03509  CB88  A9 2C              LDA     #','               ; SET ','
03510  CB8A  20 FF CE           JSR     XXCEFF          ; SCAN FOR CHR$(A)
, ELSE DO SYNTAX ERROR THEN WARM START
03511  CB8D  86 13              STX     XX13          ; SET CURRENT I/O CH
ANNEL
03512  CB8F  20 1B E1           JSR     XXE11B          ; OPEN CHANNEL FOR
 INPUT WITH ERROR CHECK
03513  CB92              XXCB92 = *
03514  CB92  A2 01              LDX     #<XX0201          ; SET XX0200+1 P
OINTER LOW BYTE
03515  CB94  A0 02              LDY     #>XX0201          ; SET XX0200+1 P
OINTER HIGH BYTE
03516  CB96  A9 00              LDA     #$00               ; CLEAR A
03517  CB98  8D 01 02           STA     XX0200+1          ; ENSURE NULL TE
RMINATOR
03518  CB9B  A9 40              LDA     #$40               ; INPUT MODE = 
GET
03519  CB9D  20 0F CC           JSR     XXCC0F          ; PERFORM GET PART
 OF READ
03520  CBA0  A6 13              LDX     XX13          ; GET CURRENT I/O CH
ANNEL






TURNTE......PAGE 0067

LINE# LOC   CODE        LINE


03521  CBA2  D0 13              BNE     XXCBB7          ; IF NOT DEFAULT C
HANNEL GO DO CHANNEL CLOSE AND RETURN
03522  CBA4                     
03523  CBA4  60                 RTS
03524  CBA5                     
03525  CBA5                     
03526  CBA5              ;************************************************
***********************************;
03527  CBA5              ;
03528  CBA5              ; PERFORM INPUT#
03529  CBA5              
03530  CBA5              XXCBA5 = *
03531  CBA5  20 9E D7           JSR     XXD79E          ; GET BYTE PARAMET
ER
03532  CBA8  A9 2C              LDA     #','               ; SET ','
03533  CBAA  20 FF CE           JSR     XXCEFF          ; SCAN FOR CHR$(A)
, ELSE DO SYNTAX ERROR THEN WARM START
03534  CBAD  86 13              STX     XX13          ; SET CURRENT I/O CH
ANNEL
03535  CBAF  20 1B E1           JSR     XXE11B          ; OPEN CHANNEL FOR
 INPUT WITH ERROR CHECK
03536  CBB2  20 CE CB           JSR     XXCBCE          ; PERFORM INPUT WI
TH NO PROMPT STRING
03537  CBB5                     
03538  CBB5              ; CLOSE INPUT AND OUTPUT CHANNELS
03539  CBB5              
03540  CBB5              XXCBB5 = *
03541  CBB5  A5 13              LDA     XX13          ; GET CURRENT I/O CH
ANNEL
03542  CBB7              XXCBB7 = *
03543  CBB7  20 CC FF           JSR     XXFFCC          ; CLOSE INPUT AND 
OUTPUT CHANNELS
03544  CBBA  A2 00              LDX     #$00               ; CLEAR X
03545  CBBC  86 13              STX     XX13          ; CLEAR CURRENT I/O 
CHANNEL, FLAG DEFAULT
03546  CBBE  60                 RTS
03547  CBBF                     
03548  CBBF                     
03549  CBBF              ;************************************************
***********************************;
03550  CBBF              ;
03551  CBBF              ; PERFORM INPUT
03552  CBBF              
03553  CBBF              XXCBBF = *
03554  CBBF  C9 22              CMP     #$22               ; COMPARE NEXT 
BYTE WITH OPEN QUOTE
03555  CBC1  D0 0B              BNE     XXCBCE          ; IF NO PROMPT STR
ING JUST DO INPUT
03556  CBC3                     
03557  CBC3  20 BD CE           JSR     XXCEBD          ; PRINT '...' STRI
NG
03558  CBC6  A9 3B              LDA     #$3B               ; LOAD A WITH '
;'
03559  CBC8  20 FF CE           JSR     XXCEFF          ; SCAN FOR CHR$(A)
, ELSE DO SYNTAX ERROR THEN WARM START
03560  CBCB  20 21 CB           JSR     XXCB21          ; PRINT STRING FRO
M UTILITY POINTER
03561  CBCE                     
03562  CBCE                                     ; DONE WITH PROMPT, NOW GE
T DATA
03563  CBCE              XXCBCE = *
03564  CBCE  20 A6 D3           JSR     XXD3A6          ; CHECK NOT DIRECT
, BACK HERE IF OK
03565  CBD1  A9 2C              LDA     #','               ; SET ','
03566  CBD3  8D FF 01           STA     XX0200-1          ; SAVE TO START 
OF BUFFER - 1
03567  CBD6              XXCBD6 = *
03568  CBD6  20 F9 CB           JSR     XXCBF9          ; PRINT '? ' AND G
ET BASIC INPUT
03569  CBD9  A5 13              LDA     XX13          ; GET CURRENT I/O CH
ANNEL
03570  CBDB  F0 0D              BEQ     XXCBEA          ; BRANCH IF DEFAUL
T I/O CHANNEL
03571  CBDD                     
03572  CBDD  20 B7 FF           JSR     XXFFB7          ; READ I/O STATUS 
WORD
03573  CBE0  29 02              AND     #$02               ; MASK NO DSR/T
IMEOUT
03574  CBE2  F0 06              BEQ     XXCBEA          ; BRANCH IF NOT ER
ROR
03575  CBE4                     






STARTE......PAGE 0068

LINE# LOC   CODE        LINE


03576  CBE4  20 B5 CB           JSR     XXCBB5          ; CLOSE INPUT AND 
OUTPUT CHANNELS
03577  CBE7  4C F8 C8           JMP     XXC8F8          ; PERFORM DATA
03578  CBEA                     
03579  CBEA              XXCBEA = *
03580  CBEA  AD 00 02           LDA     XX0200          ; GET FIRST BYTE I
N INPUT BUFFER
03581  CBED  D0 1E              BNE     XXCC0D          ; BRANCH IF NOT NU
LL
03582  CBEF                     
03583  CBEF                                     ; ELSE ..
03584  CBEF  A5 13              LDA     XX13          ; GET CURRENT I/O CH
ANNEL
03585  CBF1  D0 E3              BNE     XXCBD6          ; IF NOT DEFAULT C
HANNEL GO GET BASIC INPUT
03586  CBF3                     
03587  CBF3  20 06 C9           JSR     XXC906          ; SCAN FOR NEXT BA
SIC STATEMENT ([:] OR [EOL])
03588  CBF6  4C FB C8           JMP     XXC8FB          ; ADD Y TO THE BAS
IC EXECUTE POINTER AND RETURN
03589  CBF9                     
03590  CBF9                     
03591  CBF9              ;************************************************
***********************************;
03592  CBF9              ;
03593  CBF9              ; PRINT '? ' AND GET BASIC INPUT
03594  CBF9              
03595  CBF9              XXCBF9 = *
03596  CBF9  A5 13              LDA     XX13          ; GET CURRENT I/O CH
ANNEL
03597  CBFB  D0 06              BNE     XXCC03          ; SKIP '?' PROMPT 
IF NOT DEFAULT CHANNEL
03598  CBFD                     
03599  CBFD  20 45 CB           JSR     XXCB45          ; PRINT '?'
03600  CC00  20 3B CB           JSR     XXCB3B          ; PRINT [SPACE] OR
 [CURSOR RIGHT]
03601  CC03              XXCC03 = *
03602  CC03  4C 60 C5           JMP     XXC560          ; CALL FOR BASIC I
NPUT AND RETURN
03603  CC06                     
03604  CC06                     
03605  CC06              ;************************************************
***********************************;
03606  CC06              ;
03607  CC06              ; PERFORM READ
03608  CC06              
03609  CC06              XXCC06 = *
03610  CC06  A6 41              LDX     XX41          ; GET DATA POINTER L
OW BYTE
03611  CC08  A4 42              LDY     XX42          ; GET DATA POINTER H
IGH BYTE
03612  CC0A  A9 98              LDA     #$98               ; SET INPUT MOD
E = READ
03613  CC0C  2C                 .BYTE     $2C               ; MAKES NEXT L
INE BIT XX00A9
03614  CC0D              XXCC0D = *
03615  CC0D  A9 00              LDA     #$00               ; SET INPUT MOD
E = INPUT
03616  CC0F                     
03617  CC0F                     
03618  CC0F              ;************************************************
***********************************;
03619  CC0F              ;
03620  CC0F              ; PERFORM GET
03621  CC0F              
03622  CC0F              XXCC0F = *
03623  CC0F  85 11              STA     XX11          ; SET INPUT MODE FLA
G, $00 = INPUT, $40 = GET, $98 = READ
03624  CC11  86 43              STX     XX43          ; SAVE READ POINTER 
LOW BYTE
03625  CC13  84 44              STY     XX44          ; SAVE READ POINTER 
HIGH BYTE
03626  CC15                     
03627  CC15                                     ; READ, GET OR INPUT NEXT 
VARIABLE FROM LIST
03628  CC15              XXCC15 = *
03629  CC15  20 8B D0           JSR     XXD08B          ; GET VARIABLE ADD
RESS
03630  CC18  85 49              STA     XX49          ; SAVE ADDRESS LOW B
YTE






READ;E......PAGE 0069

LINE# LOC   CODE        LINE


03631  CC1A  84 4A              STY     XX4A          ; SAVE ADDRESS HIGH 
BYTE
03632  CC1C  A5 7A              LDA     XX7A          ; GET BASIC EXECUTE 
POINTER LOW BYTE
03633  CC1E  A4 7B              LDY     XX7B          ; GET BASIC EXECUTE 
POINTER HIGH BYTE
03634  CC20  85 4B              STA     XX4B          ; SAVE BASIC EXECUTE
 POINTER LOW BYTE
03635  CC22  84 4C              STY     XX4C          ; SAVE BASIC EXECUTE
 POINTER HIGH BYTE
03636  CC24  A6 43              LDX     XX43          ; GET READ POINTER L
OW BYTE
03637  CC26  A4 44              LDY     XX44          ; GET READ POINTER H
IGH BYTE
03638  CC28  86 7A              STX     XX7A          ; SAVE AS BASIC EXEC
UTE POINTER LOW BYTE
03639  CC2A  84 7B              STY     XX7B          ; SAVE AS BASIC EXEC
UTE POINTER HIGH BYTE
03640  CC2C  20 79 00           JSR     XX0079          ; SCAN MEMORY
03641  CC2F  D0 20              BNE     XXCC51          ; BRANCH IF NOT NU
LL
03642  CC31                     
03643  CC31                                     ; POINTER WAS TO NULL ENTR
Y
03644  CC31  24 11              BIT     XX11          ; TEST INPUT MODE FL
AG, $00 = INPUT, $40 = GET, $98 = READ
03645  CC33  50 0C              BVC     XXCC41          ; BRANCH IF NOT GE
T
03646  CC35                     
03647  CC35                                     ; ELSE WAS GET
03648  CC35  20 21 E1           JSR     XXE121          ; GET CHARACTER FR
OM INPUT DEVICE WITH ERROR CHECK
03649  CC38  8D 00 02           STA     XX0200          ; SAVE TO BUFFER
03650  CC3B  A2 FF              LDX     #<XX01FF          ; SET XX0200-1 P
OINTER LOW BYTE
03651  CC3D  A0 01              LDY     #>XX01FF          ; SET XX0200-1 P
OINTER HIGH BYTE
03652  CC3F  D0 0C              BNE     XXCC4D          ; GO INTERPRET SIN
GLE CHARACTER
03653  CC41                     
03654  CC41              XXCC41 = *
03655  CC41  30 75              BMI     XXCCB8          ; IF READ GO GET S
OME DATA
03656  CC43                     
03657  CC43              ; ELSE IT WAS INPUT
03658  CC43              
03659  CC43  A5 13              LDA     XX13          ; GET CURRENT I/O CH
ANNEL
03660  CC45  D0 03              BNE     XXCC4A          ; SKIP '?' PROMPT 
IF NOT DEFAULT CHANNEL
03661  CC47                     
03662  CC47  20 45 CB           JSR     XXCB45          ; PRINT '?'
03663  CC4A              XXCC4A = *
03664  CC4A  20 F9 CB           JSR     XXCBF9          ; PRINT '? ' AND G
ET BASIC INPUT
03665  CC4D              XXCC4D = *
03666  CC4D  86 7A              STX     XX7A          ; SAVE BASIC EXECUTE
 POINTER LOW BYTE
03667  CC4F  84 7B              STY     XX7B          ; SAVE BASIC EXECUTE
 POINTER HIGH BYTE
03668  CC51              XXCC51 = *
03669  CC51  20 73 00           JSR     XX0073          ; INCREMENT AND SC
AN MEMORY, EXECUTE POINTER NOW POINTS TO
03670  CC54                                     ; START OF NEXT DATA OR NU
LL TERMINATOR
03671  CC54  24 0D              BIT     XX0D          ; TEST DATA TYPE FLA
G, $FF = STRING, $00 = NUMERIC
03672  CC56  10 31              BPL     XXCC89          ; BRANCH IF NUMERI
C
03673  CC58                     
03674  CC58                                     ; TYPE IS STRING
03675  CC58  24 11              BIT     XX11          ; TEST INPUT MODE FL
AG, $00 = INPUT, $40 = GET, $98 = READ
03676  CC5A  50 09              BVC     XXCC65          ; BRANCH IF NOT GE
T
03677  CC5C                     
03678  CC5C                                     ; ELSE DO STRING GET
03679  CC5C  E8                 INX                    ; CLEAR X ??
03680  CC5D  86 7A              STX     XX7A          ; SAVE BASIC EXECUTE
 POINTER LOW BYTE
03681  CC5F  A9 00              LDA     #$00               ; CLEAR A
03682  CC61  85 07              STA     XX07          ; CLEAR SEARCH CHARA
CTER
03683  CC63  F0 0C              BEQ     XXCC71          ; BRANCH ALWAYS
03684  CC65                     
03685  CC65                                     ; IS STRING INPUT OR STRIN
G READ






 READT......PAGE 0070

LINE# LOC   CODE        LINE


03686  CC65              XXCC65 = *
03687  CC65  85 07              STA     XX07          ; SAVE SEARCH CHARAC
TER
03688  CC67  C9 22              CMP     #$22               ; COMPARE WITH 
'
03689  CC69  F0 07              BEQ     XXCC72          ; IF QUOTE ONLY SE
ARCH FOR '...' STRING
03690  CC6B                     
03691  CC6B                                     ; ELSE THE STRING IS NOT I
N QUOTES SO ':', ',' OR $00 ARE
03692  CC6B                                     ; THE TERMINATION CHARACTE
RS
03693  CC6B  A9 3A              LDA     #':'               ; SET ':'
03694  CC6D  85 07              STA     XX07          ; SET SEARCH CHARACT
ER
03695  CC6F  A9 2C              LDA     #','               ; SET ','
03696  CC71              XXCC71 = *
03697  CC71  18                 CLC                    ; CLEAR CARRY FOR A
DD
03698  CC72              XXCC72 = *
03699  CC72  85 08              STA     XX08          ; SET SCAN QUOTES FL
AG
03700  CC74  A5 7A              LDA     XX7A          ; GET BASIC EXECUTE 
POINTER LOW BYTE
03701  CC76  A4 7B              LDY     XX7B          ; GET BASIC EXECUTE 
POINTER HIGH BYTE
03702  CC78  69 00              ADC     #$00               ; ADD TO POINTE
R LOW BYTE. THIS ADD INCREMENTS THE POINTER
03703  CC7A                                     ; IF THE MODE IS INPUT OR 
READ AND THE DATA IS A '...'
03704  CC7A                                     ; STRING
03705  CC7A  90 01              BCC     XXCC7D          ; IF NO ROLLOVER S
KIP THE HIGH BYTE INCREMENT
03706  CC7C                     
03707  CC7C  C8                 INY                    ; ELSE INCREMENT PO
INTER HIGH BYTE
03708  CC7D              XXCC7D = *
03709  CC7D  20 8D D4           JSR     XXD48D          ; PRINT STRING TO 
UTILITY POINTER
03710  CC80  20 E2 D7           JSR     XXD7E2          ; RESTORE BASIC EX
ECUTE POINTER FROM TEMP
03711  CC83  20 DA C9           JSR     XXC9DA          ; PERFORM STRING L
ET
03712  CC86  4C 91 CC           JMP     XXCC91          ; CONTINUE PROCESS
ING COMMAND
03713  CC89                     
03714  CC89                                     ; GET, INPUT OR READ IS NU
MERIC
03715  CC89              XXCC89 = *
03716  CC89  20 F3 DC           JSR     XXDCF3          ; GET FAC1 FROM ST
RING
03717  CC8C  A5 0E              LDA     XX0E          ; GET DATA TYPE FLAG
, $80 = INTEGER, $00 = FLOAT
03718  CC8E  20 C2 C9           JSR     XXC9C2          ; ASSIGN VALUE TO 
NUMERIC VARIABLE
03719  CC91              XXCC91 = *
03720  CC91  20 79 00           JSR     XX0079          ; SCAN MEMORY
03721  CC94  F0 07              BEQ     XXCC9D          ; IF ':' OR [EOL] 
GO HANDLE THE STRING END
03722  CC96                     
03723  CC96  C9 2C              CMP     #','               ; COMPARTE WITH
 ','
03724  CC98  F0 03              BEQ     XXCC9D          ; IF ',' GO HANDLE
 THE STRING END
03725  CC9A                     
03726  CC9A  4C 4D CB           JMP     XXCB4D          ; ELSE GO DO BAD I
NPUT ROUTINE
03727  CC9D                     
03728  CC9D                                     ; STRING TERMINATED WITH '
:', ',' OR $00
03729  CC9D              XXCC9D = *
03730  CC9D  A5 7A              LDA     XX7A          ; GET BASIC EXECUTE 
POINTER LOW BYTE
03731  CC9F  A4 7B              LDY     XX7B          ; GET BASIC EXECUTE 
POINTER HIGH BYTE
03732  CCA1  85 43              STA     XX43          ; SAVE READ POINTER 
LOW BYTE
03733  CCA3  84 44              STY     XX44          ; SAVE READ POINTER 
HIGH BYTE
03734  CCA5  A5 4B              LDA     XX4B          ; GET SAVED BASIC EX
ECUTE POINTER LOW BYTE
03735  CCA7  A4 4C              LDY     XX4C          ; GET SAVED BASIC EX
ECUTE POINTER HIGH BYTE
03736  CCA9  85 7A              STA     XX7A          ; RESTORE BASIC EXEC
UTE POINTER LOW BYTE
03737  CCAB  84 7B              STY     XX7B          ; RESTORE BASIC EXEC
UTE POINTER HIGH BYTE
03738  CCAD  20 79 00           JSR     XX0079          ; SCAN MEMORY
03739  CCB0  F0 2D              BEQ     XXCCDF          ; BRANCH IF ':' OR
 [EOL]
03740  CCB2                     






TE POI......PAGE 0071

LINE# LOC   CODE        LINE


03741  CCB2  20 FD CE           JSR     XXCEFD          ; SCAN FOR ',', EL
SE DO SYNTAX ERROR THEN WARM START
03742  CCB5  4C 15 CC           JMP     XXCC15          ; GO READ OR INPUT
 NEXT VARIABLE FROM LIST
03743  CCB8                     
03744  CCB8                                     ; WAS READ
03745  CCB8              XXCCB8 = *
03746  CCB8  20 06 C9           JSR     XXC906          ; SCAN FOR NEXT BA
SIC STATEMENT ([:] OR [EOL])
03747  CCBB  C8                 INY                    ; INCREMENT INDEX T
O NEXT BYTE
03748  CCBC  AA                 TAX                    ; COPY BYTE TO X
03749  CCBD  D0 12              BNE     XXCCD1          ; IF ':' GO LOOK F
OR THE NEXT DATA
03750  CCBF                     
03751  CCBF  A2 0D              LDX     #$0D               ; ELSE SET ERRO
R $0D, OUT OF DATA ERROR
03752  CCC1  C8                 INY                    ; INCREMENT INDEX T
O NEXT LINE POINTER HIGH BYTE
03753  CCC2  B1 7A              LDA     (XX7A),Y          ; GET NEXT LINE 
POINTER HIGH BYTE
03754  CCC4  F0 6C              BEQ     XXCD32          ; IF PROGRAM END G
O DO ERROR, EVENTUALLY DOES ERROR X
03755  CCC6                     
03756  CCC6  C8                 INY                    ; INCREMENT INDEX
03757  CCC7  B1 7A              LDA     (XX7A),Y          ; GET NEXT LINE 
# LOW BYTE
03758  CCC9  85 3F              STA     XX3F          ; SAVE CURRENT DATA 
LINE LOW BYTE
03759  CCCB  C8                 INY                    ; INCREMENT INDEX
03760  CCCC  B1 7A              LDA     (XX7A),Y          ; GET NEXT LINE 
# HIGH BYTE
03761  CCCE  C8                 INY                    ; INCREMENT INDEX
03762  CCCF  85 40              STA     XX40          ; SAVE CURRENT DATA 
LINE HIGH BYTE
03763  CCD1              XXCCD1 = *
03764  CCD1  20 FB C8           JSR     XXC8FB          ; ADD Y TO THE BAS
IC EXECUTE POINTER
03765  CCD4  20 79 00           JSR     XX0079          ; SCAN MEMORY
03766  CCD7  AA                 TAX                    ; COPY BYTE
03767  CCD8  E0 83              CPX     #TDATA          ; COMPARE WITH TOK
EN FOR DATA
03768  CCDA  D0 DC              BNE     XXCCB8          ; LOOP IF NOT DATA

03769  CCDC                     
03770  CCDC  4C 51 CC           JMP     XXCC51          ; CONTINUE EVALUAT
ING READ
03771  CCDF                     
03772  CCDF              XXCCDF = *
03773  CCDF  A5 43              LDA     XX43          ; GET READ POINTER L
OW BYTE
03774  CCE1  A4 44              LDY     XX44          ; GET READ POINTER H
IGH BYTE
03775  CCE3  A6 11              LDX     XX11          ; GET INPUT MODE FLA
G, $00 = INPUT, $40 = GET, $98 = READ
03776  CCE5  10 03              BPL     XXCCEA          ; IF INPUT OR GET 
GO EXIT OR IGNORE EXTRA INPUT
03777  CCE7                     
03778  CCE7  4C 27 C8           JMP     XXC827          ; ELSE SET DATA PO
INTER AND EXIT
03779  CCEA                     
03780  CCEA              XXCCEA = *
03781  CCEA  A0 00              LDY     #$00               ; CLEAR INDEX
03782  CCEC  B1 43              LDA     (XX43),Y          ; GET READ BYTE
03783  CCEE  F0 0B              BEQ     XXCCFB          ; EXIT IF [EOL]
03784  CCF0                     
03785  CCF0  A5 13              LDA     XX13          ; GET CURRENT I/O CH
ANNEL
03786  CCF2  D0 07              BNE     XXCCFB          ; EXIT IF NOT DEFA
ULT CHANNEL
03787  CCF4                     
03788  CCF4  A9 FC              LDA     #<XXCCFC          ; SET '?EXTRA IG
NORED' POINTER LOW BYTE
03789  CCF6  A0 CC              LDY     #>XXCCFC          ; SET '?EXTRA IG
NORED' POINTER HIGH BYTE
03790  CCF8  4C 1E CB           JMP     XXCB1E          ; PRINT NULL TERMI
NATED STRING
03791  CCFB                     
03792  CCFB              XXCCFB = *
03793  CCFB  60                 RTS
03794  CCFC                     
03795  CCFC                     






****;I......PAGE 0072

LINE# LOC   CODE        LINE


03796  CCFC              ;************************************************
***********************************;
03797  CCFC              ;
03798  CCFC              ; INPUT ERROR MESSAGES
03799  CCFC              
03800  CCFC              XXCCFC = *
03801  CCFC  3F 45              .BYTE     '?EXTRA IGNORED',$0D,$00
03801  CD0A  0D 
03801  CD0B  00 
03802  CD0C                     
03803  CD0C              XXCD0C = *
03804  CD0C  3F 52              .BYTE     '?REDO FROM START',$0D,$00
03804  CD1C  0D 
03804  CD1D  00 
03805  CD1E                     
03806  CD1E                     
03807  CD1E              ;************************************************
***********************************;
03808  CD1E              ;
03809  CD1E              ; PERFORM NEXT
03810  CD1E              
03811  CD1E              XXCD1E = *
03812  CD1E  D0 04              BNE     XXCD24          ; IF NEXT VARIABLE
 GO FIND THE VARIABLE
03813  CD20                     
03814  CD20  A0 00              LDY     #$00               ; ELSE CLEAR Y
03815  CD22  F0 03              BEQ     XXCD27          ; USE ANY VARIABLE
, BRANCH ALWAYS
03816  CD24                     
03817  CD24              ; NEXT VARIABLE
03818  CD24              
03819  CD24              XXCD24 = *
03820  CD24  20 8B D0           JSR     XXD08B          ; GET VARIABLE ADD
RESS
03821  CD27              XXCD27 = *
03822  CD27  85 49              STA     XX49          ; SAVE FOR/NEXT VARI
ABLE POINTER LOW BYTE
03823  CD29  84 4A              STY     XX4A          ; SAVE FOR/NEXT VARI
ABLE POINTER HIGH BYTE
03824  CD2B                                     ; (HIGH BYTE CLEARED IF NO
 VARIABLE DEFINED)
03825  CD2B  20 8A C3           JSR     XXC38A          ; SEARCH THE STACK
 FOR FOR OR GOSUB ACTIVITY
03826  CD2E  F0 05              BEQ     XXCD35          ; IF FOR FOUND CON
TINUE
03827  CD30                     
03828  CD30  A2 0A              LDX     #$0A               ; ELSE SET ERRO
R $0A, NEXT WITHOUT FOR ERROR
03829  CD32              XXCD32 = *
03830  CD32  4C 37 C4           JMP     XXC437          ; DO ERROR #X THEN
 WARM START
03831  CD35                     
03832  CD35              ; FOUND THIS FOR VARIABLE
03833  CD35              
03834  CD35              XXCD35 = *
03835  CD35  9A                 TXS                    ; UPDATE STACK POIN
TER
03836  CD36  8A                 TXA                    ; COPY STACK POINTE
R
03837  CD37  18                 CLC                    ; CLEAR CARRY FOR A
DD
03838  CD38  69 04              ADC     #$04               ; POINT TO STEP
 VALUE
03839  CD3A  48                 PHA                    ; SAVE IT
03840  CD3B  69 06              ADC     #$06               ; POINT TO TO V
ALUE
03841  CD3D  85 24              STA     XX24          ; SAVE POINTER TO TO
 VARIABLE FOR COMPARE
03842  CD3F  68                 PLA                    ; RESTORE POINTER T
O STEP VALUE
03843  CD40  A0 01              LDY     #$01               ; POINT TO STAC
K PAGE
03844  CD42  20 A2 DB           JSR     XXDBA2          ; UNPACK MEMORY (A
Y) INTO FAC1
03845  CD45  BA                 TSX                    ; GET STACK POINTER
 BACK
03846  CD46  BD 09 01           LDA     XX0100+9,X     ; GET STEP SIGN






****;I......PAGE 0073

LINE# LOC   CODE        LINE


03847  CD49  85 66              STA     XX66          ; SAVE FAC1 SIGN (B7
)
03848  CD4B  A5 49              LDA     XX49          ; GET FOR/NEXT VARIA
BLE POINTER LOW BYTE
03849  CD4D  A4 4A              LDY     XX4A          ; GET FOR/NEXT VARIA
BLE POINTER HIGH BYTE
03850  CD4F  20 67 D8           JSR     XXD867          ; ADD FOR VARIABLE
 TO FAC1
03851  CD52  20 D0 DB           JSR     XXDBD0          ; PACK FAC1 INTO F
OR VARIABLE
03852  CD55  A0 01              LDY     #$01               ; POINT TO STAC
K PAGE
03853  CD57  20 5D DC           JSR     XXDC5D          ; COMPARE FAC1 WIT
H TO VALUE
03854  CD5A  BA                 TSX                    ; GET STACK POINTER
 BACK
03855  CD5B  38                 SEC                    ; SET CARRY FOR SUB
TRACT
03856  CD5C  FD 09 01           SBC     XX0100+9,X     ; SUBTRACT STEP SIG
N
03857  CD5F  F0 17              BEQ     XXCD78          ; IF = LOOP COMPLE
TE, GO UNSTACK THE FOR
03858  CD61                     
03859  CD61                                     ; LOOP BACK AND DO IT ALL 
AGAIN
03860  CD61  BD 0F 01           LDA     XX0100+$0F,X     ; GET FOR LINE LO
W BYTE
03861  CD64  85 39              STA     XX39          ; SAVE CURRENT LINE 
NUMBER LOW BYTE
03862  CD66  BD 10 01           LDA     XX0100+$10,X     ; GET FOR LINE HI
GH BYTE
03863  CD69  85 3A              STA     XX3A          ; SAVE CURRENT LINE 
NUMBER HIGH BYTE
03864  CD6B  BD 12 01           LDA     XX0100+$12,X     ; GET BASIC EXECU
TE POINTER LOW BYTE
03865  CD6E  85 7A              STA     XX7A          ; SAVE BASIC EXECUTE
 POINTER LOW BYTE
03866  CD70  BD 11 01           LDA     XX0100+$11,X     ; GET BASIC EXECU
TE POINTER HIGH BYTE
03867  CD73  85 7B              STA     XX7B          ; SAVE BASIC EXECUTE
 POINTER HIGH BYTE
03868  CD75              XXCD75 = *
03869  CD75  4C AE C7           JMP     XXC7AE          ; GO DO INTERPRETE
R INNER LOOP
03870  CD78                     
03871  CD78              ; NEXT LOOP COMLETE
03872  CD78              
03873  CD78              XXCD78 = *
03874  CD78  8A                 TXA                    ; STACK COPY TO A
03875  CD79  69 11              ADC     #$11               ; ADD $12, $11 
+ CARRY, TO DUMP FOR STRUCTURE
03876  CD7B  AA                 TAX                    ; COPY BACK TO INDE
X
03877  CD7C  9A                 TXS                    ; COPY TO STACK POI
NTER
03878  CD7D  20 79 00           JSR     XX0079          ; SCAN MEMORY
03879  CD80  C9 2C              CMP     #','               ; COMPARE WITH 
','
03880  CD82  D0 F1              BNE     XXCD75          ; IF NOT ',' GO DO
 INTERPRETER INNER LOOP
03881  CD84                     
03882  CD84                                     ; WAS ',' SO ANOTHER NEXT 
VARIABLE TO DO
03883  CD84  20 73 00           JSR     XX0073          ; INCREMENT AND SC
AN MEMORY
03884  CD87  20 24 CD           JSR     XXCD24          ; DO NEXT VARIABLE

03885  CD8A                     
03886  CD8A                     
03887  CD8A              ;************************************************
***********************************;
03888  CD8A              ;
03889  CD8A              ; EVALUATE EXPRESSION AND CHECK TYPE MISMATCH
03890  CD8A              
03891  CD8A              XXCD8A = *
03892  CD8A  20 9E CD           JSR     XXCD9E          ; EVALUATE EXPRESS
ION
03893  CD8D                     
03894  CD8D              ; CHECK IF SOURCE AND DESTINATION ARE NUMERIC
03895  CD8D              
03896  CD8D              XXCD8D = *
03897  CD8D  18                 CLC
03898  CD8E  24                 .BYTE     $24               ; MAKES NEXT L
INE BIT XX38
03899  CD8F                     
03900  CD8F              ; CHECK IF SOURCE AND DESTINATION ARE STRING
03901  CD8F              






****;I......PAGE 0074

LINE# LOC   CODE        LINE


03902  CD8F              XXCD8F = *
03903  CD8F  38                 SEC                    ; DESTINATION IS ST
RING
03904  CD90                     
03905  CD90              ; TYPE MATCH CHECK, SET C FOR STRING, CLEAR C FOR
 NUMERIC
03906  CD90              
03907  CD90              XXCD90 = *
03908  CD90  24 0D              BIT     XX0D          ; TEST DATA TYPE FLA
G, $FF = STRING, $00 = NUMERIC
03909  CD92  30 03              BMI     XXCD97          ; IF STRING GO CHE
CK STRING IS REQUIRED
03910  CD94                     
03911  CD94              ; TYPE FOUND IS NUMERIC, CHECK REQUIRED
03912  CD94              
03913  CD94  B0 03              BCS     XXCD99          ; IF STRING IS REQ
UIRED GO DO TYPE MISSMATCH ERROR
03914  CD96              XXCD96 = *
03915  CD96  60                 RTS
03916  CD97                     
03917  CD97              ; TYPE FOUND IS STRING, CHECK REQUIRED
03918  CD97              
03919  CD97              XXCD97 = *
03920  CD97  B0 FD              BCS     XXCD96          ; EXIT IF STRING I
S REQUIRED
03921  CD99                     
03922  CD99              ; DO TYPE MISSMATCH ERROR
03923  CD99              
03924  CD99              XXCD99 = *
03925  CD99  A2 16              LDX     #$16               ; ERROR CODE $1
6, TYPE MISSMATCH ERROR
03926  CD9B  4C 37 C4           JMP     XXC437          ; DO ERROR #X THEN
 WARM START
03927  CD9E                     
03928  CD9E                     
03929  CD9E              ;************************************************
***********************************;
03930  CD9E              ;
03931  CD9E              ; EVALUATE EXPRESSION
03932  CD9E              
03933  CD9E              XXCD9E = *
03934  CD9E  A6 7A              LDX     XX7A          ; GET BASIC EXECUTE 
POINTER LOW BYTE
03935  CDA0  D0 02              BNE     XXCDA4          ; SKIP NEXT IF NOT
 ZERO
03936  CDA2                     
03937  CDA2  C6 7B              DEC     XX7B          ; ELSE DECREMENT BAS
IC EXECUTE POINTER HIGH BYTE
03938  CDA4              XXCDA4 = *
03939  CDA4  C6 7A              DEC     XX7A          ; DECREMENT BASIC EX
ECUTE POINTER LOW BYTE
03940  CDA6  A2 00              LDX     #$00               ; SET NULL PREC
EDENCE, FLAG DONE
03941  CDA8  24                 .BYTE     $24               ; MAKES NEXT L
INE BIT XX48
03942  CDA9              XXCDA9 = *
03943  CDA9  48                 PHA                    ; PUSH COMPARE EVAL
UATION BYTE IF BRANCH TO HERE
03944  CDAA  8A                 TXA                    ; COPY PRECEDENCE B
YTE
03945  CDAB  48                 PHA                    ; PUSH PRECEDENCE B
YTE
03946  CDAC  A9 01              LDA     #$01               ; 2 BYTES
03947  CDAE  20 FB C3           JSR     XXC3FB          ; CHECK ROOM ON ST
ACK FOR A*2 BYTES
03948  CDB1  20 83 CE           JSR     XXCE83          ; GET VALUE FROM L
INE
03949  CDB4  A9 00              LDA     #$00               ; CLEAR A
03950  CDB6  85 4D              STA     XX4D          ; CLEAR COMPARRISON 
EVALUATION FLAG
03951  CDB8              XXCDB8 = *
03952  CDB8  20 79 00           JSR     XX0079          ; SCAN MEMORY
03953  CDBB              XXCDBB = *
03954  CDBB  38                 SEC                    ; SET CARRY FOR SUB
TRACT
03955  CDBC  E9 B1              SBC     #TGT          ; SUBTRACT TOKEN FOR
 '>'
03956  CDBE  90 17              BCC     XXCDD7          ; IF < '>' SKIP CO
MPARRISON TEST CHECK






****;I......PAGE 0075

LINE# LOC   CODE        LINE


03957  CDC0                     
03958  CDC0  C9 03              CMP     #$03               ; COMPARE WITH 
'>' TO +3
03959  CDC2  B0 13              BCS     XXCDD7          ; IF >= 3 SKIP COM
PARRISON TEST CHECK
03960  CDC4                     
03961  CDC4                                     ; WAS TOKEN FOR '>' '=' OR
 '<'
03962  CDC4  C9 01              CMP     #$01               ; COMPARE WITH 
TOKEN FOR =
03963  CDC6  2A                 ROL A                  ; *2, B0 = CARRY (=
1 IF TOKEN WAS = OR <)
03964  CDC7  49 01              EOR     #$01               ; TOGGLE B0
03965  CDC9  45 4D              EOR     XX4D          ; EOR WITH COMPARRIS
ON EVALUATION FLAG
03966  CDCB  C5 4D              CMP     XX4D          ; COMPARE WITH COMPA
RRISON EVALUATION FLAG
03967  CDCD  90 61              BCC     XXCE30          ; IF < SAVED FLAG 
DO SYNTAX ERROR THEN WARM START
03968  CDCF                     
03969  CDCF  85 4D              STA     XX4D          ; SAVE NEW COMPARRIS
ON EVALUATION FLAG
03970  CDD1  20 73 00           JSR     XX0073          ; INCREMENT AND SC
AN MEMORY
03971  CDD4  4C BB CD           JMP     XXCDBB          ; GO DO NEXT CHARA
CTER
03972  CDD7                     
03973  CDD7              XXCDD7 = *
03974  CDD7  A6 4D              LDX     XX4D          ; GET COMPARRISON EV
ALUATION FLAG
03975  CDD9  D0 2C              BNE     XXCE07          ; IF COMPARE FUNCT
ION FLAGGED GO EVALUATE RIGHT HAND SIDE
03976  CDDB                     
03977  CDDB  B0 7B              BCS     XXCE58          ; GO DO FUNCTIONS
03978  CDDD                     
03979  CDDD                                     ; ELSE WAS < TGT SO IS OPE
RATOR OR LOWER
03980  CDDD  69 07              ADC     #$07               ; ADD # OF OPER
ATORS (+, -, *, /, ^, AND OR OR)
03981  CDDF  90 77              BCC     XXCE58          ; IF < + OPERATOR 
GO DO THE FUNCTION
03982  CDE1                     
03983  CDE1                                     ; CARRY WAS SET SO TOKEN W
AS +, -, *, /, ^, AND OR OR
03984  CDE1  65 0D              ADC     XX0D          ; ADD DATA TYPE FLAG
, $FF = STRING, $00 = NUMERIC
03985  CDE3  D0 03              BNE     XXCDE8          ; IF NOT STRING OR
 NOT + TOKEN SKIP CONCATENATE
03986  CDE5                     
03987  CDE5                                     ; WILL ONLY BE $00 IF TYPE
 IS STRING AND TOKEN WAS +
03988  CDE5  4C 3D D6           JMP     XXD63D          ; ADD STRINGS, STR
ING 1 IS IN THE DESCRIPTOR, STRING 2
03989  CDE8                                     ; IS IN LINE, AND RETURN
03990  CDE8                     
03991  CDE8              XXCDE8 = *
03992  CDE8  69 FF              ADC     #$FF               ; -1 (CORRECTS 
FOR CARRY ADD)
03993  CDEA  85 22              STA     XX22          ; SAVE IT
03994  CDEC  0A                 ASL A                  ; *2
03995  CDED  65 22              ADC     XX22          ; *3
03996  CDEF  A8                 TAY                    ; COPY TO INDEX
03997  CDF0              XXCDF0 = *
03998  CDF0  68                 PLA                    ; PULL PREVIOUS PRE
CEDENCE
03999  CDF1  D9 80 C0           CMP     XXC080,Y          ; COMPARE WITH P
RECEDENCE BYTE
04000  CDF4  B0 67              BCS     XXCE5D          ; IF A >= GO DO TH
E FUNCTION
04001  CDF6                     
04002  CDF6  20 8D CD           JSR     XXCD8D          ; CHECK IF SOURCE 
IS NUMERIC, ELSE DO TYPE MISMATCH
04003  CDF9              XXCDF9 = *
04004  CDF9  48                 PHA                    ; SAVE PRECEDENCE
04005  CDFA              XXCDFA = *
04006  CDFA  20 20 CE           JSR     XXCE20          ; GET VECTOR, EXEC
UTE FUNCTION THEN CONTINUE EVALUATION
04007  CDFD  68                 PLA                    ; RESTORE PRECEDENC
E
04008  CDFE  A4 4B              LDY     XX4B          ; GET PRECEDENCE STA
CKED FLAG
04009  CE00  10 17              BPL     XXCE19          ; IF STACKED VALUE
S GO CHECK THE PRECEDENCE
04010  CE02                     
04011  CE02  AA                 TAX                    ; COPY PRECEDENCE, 
SET FLAGS






TIONDE......PAGE 0076

LINE# LOC   CODE        LINE


04012  CE03  F0 56              BEQ     XXCE5B          ; EXIT IF DONE
04013  CE05                     
04014  CE05  D0 5F              BNE     XXCE66          ; ELSE POP FAC2 AN
D RETURN, BRANCH ALWAYS
04015  CE07                     
04016  CE07              XXCE07 = *
04017  CE07  46 0D              LSR     XX0D          ; CLEAR DATA TYPE FL
AG, $FF = STRING, $00 = NUMERIC
04018  CE09  8A                 TXA                    ; COPY COMPARE FUNC
TION FLAG
04019  CE0A  2A                 ROL A                  ; <<1, SHIFT DATA T
YPE FLAG INTO B0, 1 = STRING, 0 = NUM
04020  CE0B  A6 7A              LDX     XX7A          ; GET BASIC EXECUTE 
POINTER LOW BYTE
04021  CE0D  D0 02              BNE     XXCE11          ; IF NO UNDERFLOW 
SKIP THE HIGH BYTE DECREMENT
04022  CE0F                     
04023  CE0F  C6 7B              DEC     XX7B          ; ELSE DECREMENT BAS
IC EXECUTE POINTER HIGH BYTE
04024  CE11              XXCE11 = *
04025  CE11  C6 7A              DEC     XX7A          ; DECREMENT BASIC EX
ECUTE POINTER LOW BYTE
04026  CE13  A0 1B              LDY     #XXC09B-XXC080
04027  CE15                                     ; SET OFFSET TO = OPERATOR
 PRECEDENCE ENTRY
04028  CE15  85 4D              STA     XX4D          ; SAVE NEW COMPARRIS
ON EVALUATION FLAG
04029  CE17  D0 D7              BNE     XXCDF0          ; BRANCH ALWAYS
04030  CE19                     
04031  CE19              XXCE19 = *
04032  CE19  D9 80 C0           CMP     XXC080,Y          ; COMPARE WITH S
TACKED FUNCTION PRECEDENCE
04033  CE1C  B0 48              BCS     XXCE66          ; IF A >=, POP FAC
2 AND RETURN
04034  CE1E                     
04035  CE1E  90 D9              BCC     XXCDF9          ; ELSE GO STACK TH
IS ONE AND CONTINUE, BRANCH ALWAYS
04036  CE20                     
04037  CE20                     
04038  CE20              ;************************************************
***********************************;
04039  CE20              ;
04040  CE20              ; GET VECTOR, EXECUTE FUNCTION THEN CONTINUE EVAL
UATION
04041  CE20              
04042  CE20              XXCE20 = *
04043  CE20  B9 82 C0           LDA     XXC080+2,Y     ; GET FUNCTION VECT
OR HIGH BYTE
04044  CE23  48                 PHA                    ; ONTO STACK
04045  CE24  B9 81 C0           LDA     XXC080+1,Y     ; GET FUNCTION VECT
OR LOW BYTE
04046  CE27  48                 PHA                    ; ONTO STACK
04047  CE28                                     ; NOW PUSH SIGN, ROUND FAC
1 AND PUT ON STACK
04048  CE28  20 33 CE           JSR     XXCE33          ; FUNCTION WILL RE
TURN HERE, THEN THE NEXT RTS WILL CALL
04049  CE2B                                     ; THE FUNCTION
04050  CE2B  A5 4D              LDA     XX4D          ; GET COMPARRISON EV
ALUATION FLAG
04051  CE2D  4C A9 CD           JMP     XXCDA9          ; CONTINUE EVALUAT
ING EXPRESSION
04052  CE30                     
04053  CE30              XXCE30 = *
04054  CE30  4C 08 CF           JMP     XXCF08          ; DO SYNTAX ERROR 
THEN WARM START
04055  CE33                     
04056  CE33              XXCE33 = *
04057  CE33  A5 66              LDA     XX66          ; GET FAC1 SIGN (B7)

04058  CE35  BE 80 C0           LDX     XXC080,Y          ; GET PRECEDENCE
 BYTE
04059  CE38                     
04060  CE38                     
04061  CE38              ;************************************************
***********************************;
04062  CE38              ;
04063  CE38              ; PUSH SIGN, ROUND FAC1 AND PUT ON STACK
04064  CE38              
04065  CE38              XXCE38 = *
04066  CE38  A8                 TAY                    ; COPY SIGN






****;E......PAGE 0077

LINE# LOC   CODE        LINE


04067  CE39  68                 PLA                    ; GET RETURN ADDRES
S LOW BYTE
04068  CE3A  85 22              STA     XX22          ; SAVE IT
04069  CE3C  E6 22              INC     XX22          ; INCREMENT IT AS RE
TURN-1 IS PUSHED
04070  CE3E                                     ; NOTE, NO CHECK IS MADE O
N THE HIGH BYTE SO IF THE CALLING
04071  CE3E                                     ; ROUTINE EVER ASSEMBLES T
O A PAGE EDGE THEN THIS ALL GOES
04072  CE3E                                     ; HORRIBLY WRONG!
04073  CE3E  68                 PLA                    ; GET RETURN ADDRES
S HIGH BYTE
04074  CE3F  85 23              STA     XX23          ; SAVE IT
04075  CE41  98                 TYA                    ; RESTORE SIGN
04076  CE42  48                 PHA                    ; PUSH SIGN
04077  CE43                     
04078  CE43                     
04079  CE43              ;************************************************
***********************************;
04080  CE43              ;
04081  CE43              ; ROUND FAC1 AND PUT ON STACK
04082  CE43              
04083  CE43              XXCE43 = *
04084  CE43  20 1B DC           JSR     XXDC1B          ; ROUND FAC1
04085  CE46  A5 65              LDA     XX65          ; GET FAC1 MANTISSA 
4
04086  CE48  48                 PHA                    ; SAVE IT
04087  CE49  A5 64              LDA     XX64          ; GET FAC1 MANTISSA 
3
04088  CE4B  48                 PHA                    ; SAVE IT
04089  CE4C  A5 63              LDA     XX63          ; GET FAC1 MANTISSA 
2
04090  CE4E  48                 PHA                    ; SAVE IT
04091  CE4F  A5 62              LDA     XX62          ; GET FAC1 MANTISSA 
1
04092  CE51  48                 PHA                    ; SAVE IT
04093  CE52  A5 61              LDA     XX61          ; GET FAC1 EXPONENT
04094  CE54  48                 PHA                    ; SAVE IT
04095  CE55  6C 22 00           JMP     (XX22)          ; RETURN, SORT OF
04096  CE58                     
04097  CE58                     
04098  CE58              ;************************************************
***********************************;
04099  CE58              ;
04100  CE58              ; DO FUNCTIONS
04101  CE58              
04102  CE58              XXCE58 = *
04103  CE58  A0 FF              LDY     #$FF               ; FLAG FUNCTION

04104  CE5A  68                 PLA                    ; PULL PRECEDENCE B
YTE
04105  CE5B              XXCE5B = *
04106  CE5B  F0 23              BEQ     XXCE80          ; EXIT IF DONE
04107  CE5D                     
04108  CE5D              XXCE5D = *
04109  CE5D  C9 64              CMP     #$64               ; COMPARE PREVI
OUS PRECEDENCE WITH $64
04110  CE5F  F0 03              BEQ     XXCE64          ; IF WAS $64 (< FU
NCTION) SKIP THE TYPE CHECK
04111  CE61                     
04112  CE61  20 8D CD           JSR     XXCD8D          ; CHECK IF SOURCE 
IS NUMERIC, ELSE DO TYPE MISMATCH
04113  CE64              XXCE64 = *
04114  CE64  84 4B              STY     XX4B          ; SAVE PRECEDENCE ST
ACKED FLAG
04115  CE66                     
04116  CE66                                     ; POP FAC2 AND RETURN
04117  CE66              XXCE66 = *
04118  CE66  68                 PLA                    ; POP BYTE
04119  CE67  4A                 LSR A                  ; SHIFT OUT COMPARI
SON EVALUATION LOWEST BIT
04120  CE68  85 12              STA     XX12          ; SAVE THE COMPARISO
N EVALUATION FLAG
04121  CE6A  68                 PLA                    ; POP EXPONENT






****;E......PAGE 0078

LINE# LOC   CODE        LINE


04122  CE6B  85 69              STA     XX69          ; SAVE FAC2 EXPONENT

04123  CE6D  68                 PLA                    ; POP MANTISSA 1
04124  CE6E  85 6A              STA     XX6A          ; SAVE FAC2 MANTISSA
 1
04125  CE70  68                 PLA                    ; POP MANTISSA 2
04126  CE71  85 6B              STA     XX6B          ; SAVE FAC2 MANTISSA
 2
04127  CE73  68                 PLA                    ; POP MANTISSA 3
04128  CE74  85 6C              STA     XX6C          ; SAVE FAC2 MANTISSA
 3
04129  CE76  68                 PLA                    ; POP MANTISSA 4
04130  CE77  85 6D              STA     XX6D          ; SAVE FAC2 MANTISSA
 4
04131  CE79  68                 PLA                    ; POP SIGN
04132  CE7A  85 6E              STA     XX6E          ; SAVE FAC2 SIGN (B7
)
04133  CE7C  45 66              EOR     XX66          ; EOR FAC1 SIGN (B7)

04134  CE7E  85 6F              STA     XX6F          ; SAVE SIGN COMPARE 
(FAC1 EOR FAC2)
04135  CE80              XXCE80 = *
04136  CE80  A5 61              LDA     XX61          ; GET FAC1 EXPONENT
04137  CE82  60                 RTS
04138  CE83                     
04139  CE83                     
04140  CE83              ;************************************************
***********************************;
04141  CE83              ;
04142  CE83              ; GET VALUE FROM LINE
04143  CE83              
04144  CE83              XXCE83 = *
04145  CE83  6C 0A 03           JMP     (XX030A)          ; GET ARITHMETIC
 ELEMENT
04146  CE86                     
04147  CE86                     
04148  CE86              ;************************************************
***********************************;
04149  CE86              ;
04150  CE86              ; GET ARITHMETIC ELEMENT, THE GET ARITHMETIC ELEM
ENT VECTOR IS INITIALISED TO POINT HERE
04151  CE86              
04152  CE86              XXCE86 = *
04153  CE86  A9 00              LDA     #$00               ; CLEAR BYTE
04154  CE88  85 0D              STA     XX0D          ; CLEAR DATA TYPE FL
AG, $FF = STRING, $00 = NUMERIC
04155  CE8A              XXCE8A = *
04156  CE8A  20 73 00           JSR     XX0073          ; INCREMENT AND SC
AN MEMORY
04157  CE8D  B0 03              BCS     XXCE92          ; IF NOT NUMERIC C
HARACTER CONTINUE
04158  CE8F                     
04159  CE8F              ; ELSE NUMERIC STRING FOUND (E.G. 123)
04160  CE8F              
04161  CE8F              XXCE8F = *
04162  CE8F  4C F3 DC           JMP     XXDCF3          ; GET FAC1 FROM ST
RING AND RETURN
04163  CE92                     
04164  CE92              ; GET VALUE FROM LINE .. CONTINUED, WASN'T A NUMB
ER SO ...
04165  CE92              
04166  CE92              XXCE92 = *
04167  CE92  20 13 D1           JSR     XXD113          ; CHECK BYTE, RETU
RN CB = 0 IF<'A' OR >'Z'
04168  CE95  90 03              BCC     XXCE9A          ; IF NOT VARIABLE 
NAME CONTINUE
04169  CE97                     
04170  CE97  4C 28 CF           JMP     XXCF28          ; VARIABLE NAME SE
T-UP AND RETURN
04171  CE9A                     
04172  CE9A              ; GET VALUE FROM LINE .. CONTINUED, WASN'T A VARI
ABLE NAME SO ...
04173  CE9A              
04174  CE9A              XXCE9A = *
04175  CE9A  C9 FF              CMP     #TPI          ; COMPARE WITH TOKEN
 FOR PI
04176  CE9C  D0 0F              BNE     XXCEAD          ; IF NOT PI CONTIN
UE






INT HE......PAGE 0079

LINE# LOC   CODE        LINE


04177  CE9E                     
04178  CE9E              ; ELSE RETURN PI IN FAC1
04179  CE9E              
04180  CE9E  A9 A8              LDA     #<XXCEA8          ; GET PI POINTER
 LOW BYTE
04181  CEA0  A0 CE              LDY     #>XXCEA8          ; GET PI POINTER
 HIGH BYTE
04182  CEA2  20 A2 DB           JSR     XXDBA2          ; UNPACK MEMORY (A
Y) INTO FAC1
04183  CEA5  4C 73 00           JMP     XX0073          ; INCREMENT AND SC
AN MEMORY AND RETURN
04184  CEA8                     
04185  CEA8                     
04186  CEA8              ;************************************************
***********************************;
04187  CEA8              ;
04188  CEA8              ; PI AS FLOATING NUMBER
04189  CEA8              
04190  CEA8              XXCEA8 = *
04191  CEA8  82                 .BYTE     $82,$49,$0F,$DA,$A1
04191  CEA9  49 
04191  CEAA  0F 
04191  CEAB  DA 
04191  CEAC  A1 
04192  CEAD                                     ; 3.141592653
04193  CEAD                     
04194  CEAD                     
04195  CEAD              ;************************************************
***********************************;
04196  CEAD              ;
04197  CEAD              ; GET VALUE FROM LINE .. CONTINUED, WASN'T PI SO 
...
04198  CEAD              
04199  CEAD              XXCEAD = *
04200  CEAD  C9 2E              CMP     #'.'               ; COMPARE WITH 
'.'
04201  CEAF  F0 DE              BEQ     XXCE8F          ; IF SO GET FAC1 F
ROM STRING AND RETURN, E.G. WAS .123
04202  CEB1                     
04203  CEB1                                     ; WASN'T .123 SO ...
04204  CEB1  C9 AB              CMP     #TMINUS          ; COMPARE WITH TO
KEN FOR -
04205  CEB3  F0 58              BEQ     XXCF0D          ; IF - TOKEN, DO S
ET-UP FOR FUNCTIONS
04206  CEB5                     
04207  CEB5                                     ; WASN'T -123 SO ...
04208  CEB5  C9 AA              CMP     #TPLUS          ; COMPARE WITH TOK
EN FOR +
04209  CEB7  F0 D1              BEQ     XXCE8A          ; IF + TOKEN IGNOR
E THE LEADING +, +1 = 1
04210  CEB9                     
04211  CEB9                                     ; IT WASN'T ANY SORT OF NU
MBER SO ...
04212  CEB9  C9 22              CMP     #$22               ; COMPARE WITH 
'
04213  CEBB  D0 0F              BNE     XXCECC          ; IF NOT OPEN QUOT
E CONTINUE
04214  CEBD                     
04215  CEBD                                     ; WAS OPEN QUOTE SO GET TH
E ENCLOSED STRING
04216  CEBD                     
04217  CEBD              ; PRINT '...' STRING TO STRING UTILITY AREA
04218  CEBD              
04219  CEBD              XXCEBD = *
04220  CEBD  A5 7A              LDA     XX7A          ; GET BASIC EXECUTE 
POINTER LOW BYTE
04221  CEBF  A4 7B              LDY     XX7B          ; GET BASIC EXECUTE 
POINTER HIGH BYTE
04222  CEC1  69 00              ADC     #$00               ; ADD CARRY TO 
LOW BYTE
04223  CEC3  90 01              BCC     XXCEC6          ; BRANCH IF NO OVE
RFLOW
04224  CEC5                     
04225  CEC5  C8                 INY                    ; INCREMENT HIGH BY
TE
04226  CEC6              XXCEC6 = *
04227  CEC6  20 87 D4           JSR     XXD487          ; PRINT ' TERMINAT
ED STRING TO UTILITY POINTER






N23*;E......PAGE 0080

LINE# LOC   CODE        LINE


04228  CEC9  4C E2 D7           JMP     XXD7E2          ; RESTORE BASIC EX
ECUTE POINTER FROM TEMP AND RETURN
04229  CECC                     
04230  CECC              ; GET VALUE FROM LINE .. CONTINUED, WASN'T A STRI
NG SO ...
04231  CECC              
04232  CECC              XXCECC = *
04233  CECC  C9 A8              CMP     #TNOT          ; COMPARE WITH TOKE
N FOR NOT
04234  CECE  D0 13              BNE     XXCEE3          ; IF NOT TOKEN FOR
 NOT CONTINUE
04235  CED0                     
04236  CED0              ; WAS NOT TOKEN
04237  CED0              
04238  CED0  A0 18              LDY     #$18               ; OFFSET TO NOT
 FUNCTION
04239  CED2  D0 3B              BNE     XXCF0F          ; DO SET-UP FOR FU
NCTION THEN EXECUTE, BRANCH ALWAYS
04240  CED4                     
04241  CED4              ; DO = COMPARE
04242  CED4              
04243  CED4              XXCED4 = *
04244  CED4  20 BF D1           JSR     XXD1BF          ; EVALUATE INTEGER
 EXPRESSION, NO SIGN CHECK
04245  CED7  A5 65              LDA     XX65          ; GET FAC1 MANTISSA 
4
04246  CED9  49 FF              EOR     #$FF               ; INVERT IT
04247  CEDB  A8                 TAY                    ; COPY IT
04248  CEDC  A5 64              LDA     XX64          ; GET FAC1 MANTISSA 
3
04249  CEDE  49 FF              EOR     #$FF               ; INVERT IT
04250  CEE0  4C 91 D3           JMP     XXD391          ; CONVERT FIXED IN
TEGER AY TO FLOAT FAC1 AND RETURN
04251  CEE3                     
04252  CEE3              ; GET VALUE FROM LINE .. CONTINUED, WASN'T NOT SO
 ...
04253  CEE3              
04254  CEE3              XXCEE3 = *
04255  CEE3  C9 A5              CMP     #TFN          ; COMPARE WITH TOKEN
 FOR FN
04256  CEE5  D0 03              BNE     XXCEEA          ; IF NOT TOKEN FOR
 FN CONTINUE
04257  CEE7                     
04258  CEE7  4C F4 D3           JMP     XXD3F4          ; ELSE GO EVALUATE
 FNX
04259  CEEA                     
04260  CEEA              ; GET VALUE FROM LINE .. CONTINUED, WASN'T FN SO 
...
04261  CEEA              
04262  CEEA              XXCEEA = *
04263  CEEA  C9 B4              CMP     #TSGN          ; COMPARE WITH TOKE
N FOR SGN
04264  CEEC  90 03              BCC     XXCEF1          ; IF LESS THAN SGN
 TOKEN GO EVALUATE EXPRESSION IN ()
04265  CEEE                     
04266  CEEE                                     ; ELSE WAS A FUNCTION TOKE
N
04267  CEEE  4C A7 CF           JMP     XXCFA7          ; GO SET UP FUNCTI
ON REFERENCES, BRANCH ALWAYS
04268  CEF1                     
04269  CEF1                     
04270  CEF1              ;************************************************
***********************************;
04271  CEF1              ;
04272  CEF1              ; GET VALUE FROM LINE .. CONTINUED
04273  CEF1              ; IF HERE IT CAN ONLY BE SOMETHING IN BRACKETS SO
 ....
04274  CEF1              
04275  CEF1              ; EVALUATE EXPRESSION WITHIN PARENTHESES
04276  CEF1              
04277  CEF1              XXCEF1 = *
04278  CEF1  20 FA CE           JSR     XXCEFA          ; SCAN FOR '(', EL
SE DO SYNTAX ERROR THEN WARM START
04279  CEF4  20 9E CD           JSR     XXCD9E          ; EVALUATE EXPRESS
ION
04280  CEF7                     
04281  CEF7                     
04282  CEF7              ;************************************************
***********************************;






****;E......PAGE 0081

LINE# LOC   CODE        LINE


04283  CEF7              ;
04284  CEF7              ; ALL THE 'SCAN FOR' ROUTINES RETURN THE CHARACTE
R AFTER THE SOUGHT CHARACTER
04285  CEF7              
04286  CEF7              ; SCAN FOR ')', ELSE DO SYNTAX ERROR THEN WARM ST
ART
04287  CEF7              
04288  CEF7              XXCEF7 = *
04289  CEF7  A9 29              LDA     #$29               ; LOAD A WITH '
)'
04290  CEF9  2C                 .BYTE     $2C               ; MAKES NEXT L
INE BIT XX28A9
04291  CEFA                     
04292  CEFA              ; SCAN FOR '(', ELSE DO SYNTAX ERROR THEN WARM ST
ART
04293  CEFA              
04294  CEFA              XXCEFA = *
04295  CEFA  A9 28              LDA     #$28               ; LOAD A WITH '
('
04296  CEFC  2C                 .BYTE     $2C               ; MAKES NEXT L
INE BIT XX2CA9
04297  CEFD                     
04298  CEFD              ; SCAN FOR ',', ELSE DO SYNTAX ERROR THEN WARM ST
ART
04299  CEFD              
04300  CEFD              XXCEFD = *
04301  CEFD  A9 2C              LDA     #','               ; LOAD A WITH '
,'
04302  CEFF                     
04303  CEFF              ; SCAN FOR CHR$(A), ELSE DO SYNTAX ERROR THEN WAR
M START
04304  CEFF              
04305  CEFF              XXCEFF = *
04306  CEFF  A0 00              LDY     #$00               ; CLEAR INDEX
04307  CF01  D1 7A              CMP     (XX7A),Y          ; COMPARE WITH B
ASIC BYTE
04308  CF03  D0 03              BNE     XXCF08          ; IF NOT EXPECTED 
BYTE DO SYNTAX ERROR THEN WARM START
04309  CF05                     
04310  CF05  4C 73 00           JMP     XX0073          ; ELSE INCREMENT A
ND SCAN MEMORY AND RETURN
04311  CF08                     
04312  CF08                     
04313  CF08              ;************************************************
***********************************;
04314  CF08              ;
04315  CF08              ; SYNTAX ERROR THEN WARM START
04316  CF08              
04317  CF08              XXCF08 = *
04318  CF08  A2 0B              LDX     #$0B               ; ERROR CODE $0
B, SYNTAX ERROR
04319  CF0A  4C 37 C4           JMP     XXC437          ; DO ERROR #X THEN
 WARM START
04320  CF0D                     
04321  CF0D              XXCF0D = *
04322  CF0D  A0 15              LDY     #$15               ; SET OFFSET FR
OM BASE TO > OPERATOR
04323  CF0F              XXCF0F = *
04324  CF0F  68                 PLA                    ; DUMP RETURN ADDRE
SS LOW BYTE
04325  CF10  68                 PLA                    ; DUMP RETURN ADDRE
SS HIGH BYTE
04326  CF11  4C FA CD           JMP     XXCDFA          ; EXECUTE FUNCTION
 THEN CONTINUE EVALUATION
04327  CF14                     
04328  CF14                     
04329  CF14              ;************************************************
***********************************;
04330  CF14              ;
04331  CF14              ; CHECK ADDRESS RANGE, RETURN CB = 1 IF ADDRESS I
N BASIC ROM
04332  CF14              
04333  CF14              XXCF14 = *
04334  CF14  38                 SEC                    ; SET CARRY FOR SUB
TRACT
04335  CF15  A5 64              LDA     XX64          ; GET VARIABLE ADDRE
SS LOW BYTE
04336  CF17  E9 00              SBC     #$00               ; SUBTRACT $C00
0 LOW BYTE
04337  CF19  A5 65              LDA     XX65          ; GET VARIABLE ADDRE
SS HIGH BYTE






****;E......PAGE 0082

LINE# LOC   CODE        LINE


04338  CF1B  E9 C0              SBC     #$C0               ; SUBTRACT $C00
0 HIGH BYTE
04339  CF1D  90 08              BCC     XXCF27          ; EXIT IF ADDRESS 
< $C000
04340  CF1F                     
04341  CF1F  A9 87              LDA     #<XXE387          ; GET END OF BAS
IC MARKER LOW BYTE
04342  CF21  E5 64              SBC     XX64          ; SUBTRACT VARIABLE 
ADDRESS LOW BYTE
04343  CF23  A9 E3              LDA     #>XXE387          ; GET END OF BAS
IC MARKER HIGH BYTE
04344  CF25  E5 65              SBC     XX65          ; SUBTRACT VARIABLE 
ADDRESS HIGH BYTE
04345  CF27              XXCF27 = *
04346  CF27  60                 RTS
04347  CF28                     
04348  CF28                     
04349  CF28              ;************************************************
***********************************;
04350  CF28              ;
04351  CF28              ; VARIABLE NAME SET-UP
04352  CF28              
04353  CF28              XXCF28 = *
04354  CF28  20 8B D0           JSR     XXD08B          ; GET VARIABLE ADD
RESS
04355  CF2B  85 64              STA     XX64          ; SAVE VARIABLE POIN
TER LOW BYTE
04356  CF2D  84 65              STY     XX65          ; SAVE VARIABLE POIN
TER HIGH BYTE
04357  CF2F  A6 45              LDX     XX45          ; GET CURRENT VARIAB
LE NAME FIRST CHARACTER
04358  CF31  A4 46              LDY     XX46          ; GET CURRENT VARIAB
LE NAME SECOND CHARACTER
04359  CF33  A5 0D              LDA     XX0D          ; GET DATA TYPE FLAG
, $FF = STRING, $00 = NUMERIC
04360  CF35  F0 26              BEQ     XXCF5D          ; IF NUMERIC GO HA
NDLE A NUMERIC VARIABLE
04361  CF37                     
04362  CF37              ; VARIABLE IS STRING
04363  CF37              
04364  CF37  A9 00              LDA     #$00               ; ELSE CLEAR A
04365  CF39  85 70              STA     XX70          ; CLEAR FAC1 ROUNDIN
G BYTE
04366  CF3B  20 14 CF           JSR     XXCF14          ; CHECK ADDRESS RA
NGE
04367  CF3E  90 1C              BCC     XXCF5C          ; EXIT IF NOT IN B
ASIC ROM
04368  CF40                     
04369  CF40  E0 54              CPX     #'T'               ; COMPARE VARIA
BLE NAME FIRST CHARACTER WITH 'T'
04370  CF42  D0 18              BNE     XXCF5C          ; EXIT IF NOT 'T'
04371  CF44                     
04372  CF44  C0 C9              CPY     #$C9    ;#'I'+$80          ; COMPA
RE VARIABLE NAME SECOND CHARACTER WITH 'I$'
04373  CF46  D0 14              BNE     XXCF5C          ; EXIT IF NOT 'I$'

04374  CF48                     
04375  CF48                                     ; VARIABLE NAME WAS 'TI$'
04376  CF48  20 84 CF           JSR     XXCF84          ; READ REAL TIME C
LOCK INTO FAC1 MANTISSA, 0HML
04377  CF4B  84 5E              STY     XX5E          ; CLEAR EXPONENT COU
NT ADJUST
04378  CF4D  88                 DEY                    ; Y = $FF
04379  CF4E  84 71              STY     XX71          ; SET OUTPUT STRING 
INDEX, -1 TO ALLOW FOR PRE INCREMENT
04380  CF50  A0 06              LDY     #$06               ; HH:MM:SS IS S
IX DIGITS
04381  CF52  84 5D              STY     XX5D          ; SET NUMBER OF CHAR
ACTERS BEFORE THE DECIMAL POINT
04382  CF54  A0 24              LDY     #XXDF3A-XXDF16
04383  CF56                                     ; INDEX TO JIFFY CONVERSIO
N TABLE
04384  CF56  20 68 DE           JSR     XXDE68          ; CONVERT JIFFY CO
UNT TO STRING
04385  CF59  4C 6F D4           JMP     XXD46F          ; EXIT VIA STR$() 
CODE TAIL
04386  CF5C                     
04387  CF5C              XXCF5C = *
04388  CF5C  60                 RTS
04389  CF5D                     
04390  CF5D              ; VARIABLE NAME SET-UP, VARIABLE IS NUMERIC
04391  CF5D              
04392  CF5D              XXCF5D = *






ENT'I$......PAGE 0083

LINE# LOC   CODE        LINE


04393  CF5D  24 0E              BIT     XX0E          ; TEST DATA TYPE FLA
G, $80 = INTEGER, $00 = FLOAT
04394  CF5F  10 0D              BPL     XXCF6E          ; IF FLOAT GO HAND
LE FLOAT
04395  CF61                     
04396  CF61              ; ELSE HANDLE INTEGER VARIABLE
04397  CF61              
04398  CF61  A0 00              LDY     #$00               ; CLEAR INDEX
04399  CF63  B1 64              LDA     (XX64),Y          ; GET INTEGER VA
RIABLE LOW BYTE
04400  CF65  AA                 TAX                    ; COPY TO X
04401  CF66  C8                 INY                    ; INCREMENT INDEX
04402  CF67  B1 64              LDA     (XX64),Y          ; GET INTEGER VA
RIABLE HIGH BYTE
04403  CF69  A8                 TAY                    ; COPY TO Y
04404  CF6A  8A                 TXA                    ; COPY LOA BYTE TO 
A
04405  CF6B  4C 91 D3           JMP     XXD391          ; CONVERT FIXED IN
TEGER AY TO FLOAT FAC1 AND RETURN
04406  CF6E                     
04407  CF6E              ; VARIABLE NAME SET-UP, VARIABLE IS FLOAT
04408  CF6E              
04409  CF6E              XXCF6E = *
04410  CF6E  20 14 CF           JSR     XXCF14          ; CHECK ADDRESS RA
NGE
04411  CF71  90 2D              BCC     XXCFA0          ; IF NOT IN BASIC 
ROM GET POINTER AND UNPACK INTO FAC1
04412  CF73                     
04413  CF73  E0 54              CPX     #'T'               ; COMPARE VARIA
BLE NAME FIRST CHARACTER WITH 'T'
04414  CF75  D0 1B              BNE     XXCF92          ; IF NOT 'T' SKIP 
TX VARIABLES
04415  CF77                     
04416  CF77  C0 49              CPY     #'I'               ; COMPARE VARIA
BLE NAME SECOND CHARACTER WITH 'I'
04417  CF79  D0 25              BNE     XXCFA0          ; IF NOT 'I' GO DO
 PLAIN FLOAT
04418  CF7B                     
04419  CF7B                                     ; VARIABLE NAME WAS 'TI'
04420  CF7B  20 84 CF           JSR     XXCF84          ; READ REAL TIME C
LOCK INTO FAC1 MANTISSA, 0HML
04421  CF7E  98                 TYA                    ; CLEAR A
04422  CF7F  A2 A0              LDX     #$A0               ; SET EXPONENT 
TO 32 BIT VALUE
04423  CF81  4C 4F DC           JMP     XXDC4F          ; SET EXPONENT = X
 AND NORMALISE FAC1
04424  CF84                     
04425  CF84                     
04426  CF84              ;************************************************
***********************************;
04427  CF84              ;
04428  CF84              ; READ REAL TIME CLOCK INTO FAC1 MANTISSA, 0HML
04429  CF84              
04430  CF84              XXCF84 = *
04431  CF84  20 DE FF           JSR     XXFFDE          ; READ REAL TIME C
LOCK
04432  CF87  86 64              STX     XX64          ; SAVE JIFFY CLOCK M
ID BYTE AS  FAC1 MANTISSA 3
04433  CF89  84 63              STY     XX63          ; SAVE JIFFY CLOCK H
IGH BYTE AS  FAC1 MANTISSA 2
04434  CF8B  85 65              STA     XX65          ; SAVE JIFFY CLOCK L
OW BYTE AS  FAC1 MANTISSA 4
04435  CF8D  A0 00              LDY     #$00               ; CLEAR Y
04436  CF8F  84 62              STY     XX62          ; CLEAR FAC1 MANTISS
A 1
04437  CF91  60                 RTS
04438  CF92                     
04439  CF92                     
04440  CF92              ;************************************************
***********************************;
04441  CF92              ;
04442  CF92              ; VARIABLE NAME SET-UP, VARIABLE IS FLOAT AND NOT
 'TX'
04443  CF92              
04444  CF92              XXCF92 = *
04445  CF92  E0 53              CPX     #'S'               ; COMPARE VARIA
BLE NAME FIRST CHARACTER WITH 'S'
04446  CF94  D0 0A              BNE     XXCFA0          ; IF NOT 'S' GO DO
 NORMAL FLOATING VARIABLE
04447  CF96                     






****;$......PAGE 0084

LINE# LOC   CODE        LINE


04448  CF96  C0 54              CPY     #'T'               ; COMPARE VARIA
BLE NAME SECOND CHARACTER WITH '
04449  CF98  D0 06              BNE     XXCFA0          ; IF NOT 'T' GO DO
 NORMAL FLOATING VARIABLE
04450  CF9A                     
04451  CF9A                                     ; VARIABLE NAME WAS 'ST'
04452  CF9A  20 B7 FF           JSR     XXFFB7          ; READ I/O STATUS 
WORD
04453  CF9D  4C 3C DC           JMP     XXDC3C          ; SAVE A AS INTEGE
R BYTE AND RETURN
04454  CFA0                     
04455  CFA0              ; VARIABLE IS PLAIN FLOAT
04456  CFA0              
04457  CFA0              XXCFA0 = *
04458  CFA0  A5 64              LDA     XX64          ; GET VARIABLE POINT
ER LOW BYTE
04459  CFA2  A4 65              LDY     XX65          ; GET VARIABLE POINT
ER HIGH BYTE
04460  CFA4  4C A2 DB           JMP     XXDBA2          ; UNPACK MEMORY (A
Y) INTO FAC1
04461  CFA7                     
04462  CFA7                     
04463  CFA7              ;************************************************
***********************************;
04464  CFA7              ;
04465  CFA7              ; GET VALUE FROM LINE CONTINUED
04466  CFA7              ; ONLY FUNCTIONS LEFT SO ..
04467  CFA7              
04468  CFA7              ; SET UP FUNCTION REFERENCES
04469  CFA7              
04470  CFA7              XXCFA7 = *
04471  CFA7  0A                 ASL A                  ; *2 (2 BYTES PER F
UNCTION ADDRESS)
04472  CFA8  48                 PHA                    ; SAVE FUNCTION OFF
SET
04473  CFA9  AA                 TAX                    ; COPY FUNCTION OFF
SET
04474  CFAA  20 73 00           JSR     XX0073          ; INCREMENT AND SC
AN MEMORY
04475  CFAD  E0 8F              CPX     #$8F               ; COMPARE FUNCT
ION OFFSET TO CHR$ TOKEN OFFSET+1
04476  CFAF  90 20              BCC     XXCFD1          ; IF < LEFT$ (CAN 
NOT BE =) GO DO FUNCTION SETUP
04477  CFB1                     
04478  CFB1              ; GET VALUE FROM LINE .. CONTINUED
04479  CFB1              ; WAS LEFT$, RIGHT$ OR MID$ SO..
04480  CFB1              
04481  CFB1  20 FA CE           JSR     XXCEFA          ; SCAN FOR '(', EL
SE DO SYNTAX ERROR THEN WARM START
04482  CFB4  20 9E CD           JSR     XXCD9E          ; EVALUATE, SHOULD
 BE STRING, EXPRESSION
04483  CFB7  20 FD CE           JSR     XXCEFD          ; SCAN FOR ',', EL
SE DO SYNTAX ERROR THEN WARM START
04484  CFBA  20 8F CD           JSR     XXCD8F          ; CHECK IF SOURCE 
IS STRING, ELSE DO TYPE MISMATCH
04485  CFBD  68                 PLA                    ; RESTORE FUNCTION 
OFFSET
04486  CFBE  AA                 TAX                    ; COPY IT
04487  CFBF  A5 65              LDA     XX65          ; GET DESCRIPTOR POI
NTER HIGH BYTE
04488  CFC1  48                 PHA                    ; PUSH STRING POINT
ER HIGH BYTE
04489  CFC2  A5 64              LDA     XX64          ; GET DESCRIPTOR POI
NTER LOW BYTE
04490  CFC4  48                 PHA                    ; PUSH STRING POINT
ER LOW BYTE
04491  CFC5  8A                 TXA                    ; RESTORE FUNCTION 
OFFSET
04492  CFC6  48                 PHA                    ; SAVE FUNCTION OFF
SET
04493  CFC7  20 9E D7           JSR     XXD79E          ; GET BYTE PARAMET
ER
04494  CFCA  68                 PLA                    ; RESTORE FUNCTION 
OFFSET
04495  CFCB  A8                 TAY                    ; COPY FUNCTION OFF
SET
04496  CFCC  8A                 TXA                    ; COPY BYTE PARAMET
ER TO A
04497  CFCD  48                 PHA                    ; PUSH BYTE PARAMET
ER
04498  CFCE  4C D6 CF           JMP     XXCFD6          ; GO CALL FUNCTION

04499  CFD1                     
04500  CFD1              ; GET VALUE FROM LINE .. CONTINUED
04501  CFD1              ; WAS SGN() TO CHR$() SO..
04502  CFD1              






T***;$......PAGE 0085

LINE# LOC   CODE        LINE


04503  CFD1              XXCFD1 = *
04504  CFD1  20 F1 CE           JSR     XXCEF1          ; EVALUATE EXPRESS
ION WITHIN PARENTHESES
04505  CFD4  68                 PLA                    ; RESTORE FUNCTION 
OFFSET
04506  CFD5  A8                 TAY                    ; COPY TO INDEX
04507  CFD6              XXCFD6 = *
04508  CFD6  B9 EA BF           LDA     XXC052-$68,Y     ; GET FUNCTION JU
MP VECTOR LOW BYTE
04509  CFD9  85 55              STA     XX55          ; SAVE FUNCTIONS JUM
P VECTOR LOW BYTE
04510  CFDB  B9 EB BF           LDA     XXC052-$67,Y     ; GET FUNCTION JU
MP VECTOR HIGH BYTE
04511  CFDE  85 56              STA     XX56          ; SAVE FUNCTIONS JUM
P VECTOR HIGH BYTE
04512  CFE0  20 54 00           JSR     XX54          ; DO FUNCTION CALL
04513  CFE3  4C 8D CD           JMP     XXCD8D          ; CHECK IF SOURCE 
IS NUMERIC AND RTS, ELSE DO TYPE MISMATCH
04514  CFE6                                     ; STRING FUNCTIONS AVOID T
HIS BY DUMPING THE RETURN ADDRESS
04515  CFE6                     
04516  CFE6                     
04517  CFE6              ;************************************************
***********************************;
04518  CFE6              ;
04519  CFE6              ; PERFORM OR
04520  CFE6              ; THIS WORKS BECAUSE NOT(NOT(X) AND NOT(Y)) = X O
R Y
04521  CFE6              
04522  CFE6              XXCFE6 = *
04523  CFE6  A0 FF              LDY     #$FF               ; SET Y FOR OR
04524  CFE8  2C                 .BYTE     $2C               ; MAKES NEXT L
INE BIT XX00A0
04525  CFE9                     
04526  CFE9                     
04527  CFE9              ;************************************************
***********************************;
04528  CFE9              ;
04529  CFE9              ; PERFORM AND
04530  CFE9              
04531  CFE9              XXCFE9 = *
04532  CFE9  A0 00              LDY     #$00               ; CLEAR Y FOR A
ND
04533  CFEB  84 0B              STY     XX0B          ; SET AND/OR INVERT 
VALUE
04534  CFED  20 BF D1           JSR     XXD1BF          ; EVALUATE INTEGER
 EXPRESSION, NO SIGN CHECK
04535  CFF0  A5 64              LDA     XX64          ; GET FAC1 MANTISSA 
3
04536  CFF2  45 0B              EOR     XX0B          ; EOR LOW BYTE
04537  CFF4  85 07              STA     XX07          ; SAVE IT
04538  CFF6  A5 65              LDA     XX65          ; GET FAC1 MANTISSA 
4
04539  CFF8  45 0B              EOR     XX0B          ; EOR HIGH BYTE
04540  CFFA  85 08              STA     XX08          ; SAVE IT
04541  CFFC  20 FC DB           JSR     XXDBFC          ; COPY FAC2 TO FAC
1, GET 2ND VALUE IN EXPRESSION
04542  CFFF  20 BF D1           JSR     XXD1BF          ; EVALUATE INTEGER
 EXPRESSION, NO SIGN CHECK
04543  D002  A5 65              LDA     XX65          ; GET FAC1 MANTISSA 
4
04544  D004  45 0B              EOR     XX0B          ; EOR HIGH BYTE
04545  D006  25 08              AND     XX08          ; AND WITH EXPRESSIO
N 1 HIGH BYTE
04546  D008  45 0B              EOR     XX0B          ; EOR RESULT HIGH BY
TE
04547  D00A  A8                 TAY                    ; SAVE IN Y
04548  D00B  A5 64              LDA     XX64          ; GET FAC1 MANTISSA 
3
04549  D00D  45 0B              EOR     XX0B          ; EOR LOW BYTE
04550  D00F  25 07              AND     XX07          ; AND WITH EXPRESSIO
N 1 LOW BYTE
04551  D011  45 0B              EOR     XX0B          ; EOR RESULT LOW BYT
E
04552  D013  4C 91 D3           JMP     XXD391          ; CONVERT FIXED IN
TEGER AY TO FLOAT FAC1 AND RETURN
04553  D016                     
04554  D016                     
04555  D016              ;************************************************
***********************************;
04556  D016              ;
04557  D016              ; PERFORM COMPARISONS






****;T......PAGE 0086

LINE# LOC   CODE        LINE


04558  D016              
04559  D016              ; DO < COMPARE
04560  D016              
04561  D016              XXD016 = *
04562  D016  20 90 CD           JSR     XXCD90          ; TYPE MATCH CHECK
, SET C FOR STRING
04563  D019  B0 13              BCS     XXD02E          ; IF STRING GO DO 
STRING COMPARE
04564  D01B                     
04565  D01B                                     ; DO NUMERIC < COMPARE
04566  D01B  A5 6E              LDA     XX6E          ; GET FAC2 SIGN (B7)

04567  D01D  09 7F              ORA     #$7F               ; SET ALL NON S
IGN BITS
04568  D01F  25 6A              AND     XX6A          ; AND FAC2 MANTISSA 
1 (AND IN SIGN BIT)
04569  D021  85 6A              STA     XX6A          ; SAVE FAC2 MANTISSA
 1
04570  D023  A9 69              LDA     #<XX69          ; SET POINTER LOW 
BYTE TO FAC2
04571  D025  A0 00              LDY     #>XX69          ; SET POINTER HIGH
 BYTE TO FAC2
04572  D027  20 5B DC           JSR     XXDC5B          ; COMPARE FAC1 WIT
H (AY)
04573  D02A  AA                 TAX                    ; COPY THE RESULT
04574  D02B  4C 61 D0           JMP     XXD061          ; GO EVALUATE RESU
LT
04575  D02E                     
04576  D02E              ; DO STRING < COMPARE
04577  D02E              
04578  D02E              XXD02E = *
04579  D02E  A9 00              LDA     #$00               ; CLEAR BYTE
04580  D030  85 0D              STA     XX0D          ; CLEAR DATA TYPE FL
AG, $FF = STRING, $00 = NUMERIC
04581  D032  C6 4D              DEC     XX4D          ; CLEAR < BIT IN COM
PARRISON EVALUATION FLAG
04582  D034  20 A6 D6           JSR     XXD6A6          ; POP STRING OFF D
ESCRIPTOR STACK, OR FROM TOP OF STRING
04583  D037                                     ; SPACE RETURNS WITH A = L
ENGTH, X = POINTER LOW BYTE,
04584  D037                                     ; Y = POINTER HIGH BYTE
04585  D037  85 61              STA     XX61          ; SAVE LENGTH
04586  D039  86 62              STX     XX62          ; SAVE STRING POINTE
R LOW BYTE
04587  D03B  84 63              STY     XX63          ; SAVE STRING POINTE
R HIGH BYTE
04588  D03D  A5 6C              LDA     XX6C          ; GET DESCRIPTOR POI
NTER LOW BYTE
04589  D03F  A4 6D              LDY     XX6D          ; GET DESCRIPTOR POI
NTER HIGH BYTE
04590  D041  20 AA D6           JSR     XXD6AA          ; POP (YA) DESCRIP
TOR OFF STACK OR FROM TOP OF STRING SPACE
04591  D044                                     ; RETURNS WITH A = LENGTH,
 X = POINTER LOW BYTE,
04592  D044                                     ; Y = POINTER HIGH BYTE
04593  D044  86 6C              STX     XX6C          ; SAVE STRING POINTE
R LOW BYTE
04594  D046  84 6D              STY     XX6D          ; SAVE STRING POINTE
R HIGH BYTE
04595  D048  AA                 TAX                    ; COPY LENGTH
04596  D049  38                 SEC                    ; SET CARRY FOR SUB
TRACT
04597  D04A  E5 61              SBC     XX61          ; SUBTRACT STRING 1 
LENGTH
04598  D04C  F0 08              BEQ     XXD056          ; IF STR 1 LENGTH 
= STRING 2 LENGTH GO COMPARE THE STRINGS
04599  D04E                     
04600  D04E  A9 01              LDA     #$01               ; SET STR 1 LEN
GTH > STRING 2 LENGTH
04601  D050  90 04              BCC     XXD056          ; IF SO RETURN + 1
 IF OTHERWISE EQUAL
04602  D052                     
04603  D052  A6 61              LDX     XX61          ; GET STRING 1 LENGT
H
04604  D054  A9 FF              LDA     #$FF               ; SET STR 1 LEN
GTH < STRING 2 LENGTH
04605  D056              XXD056 = *
04606  D056  85 66              STA     XX66          ; SAVE LENGTH COMPAR
E
04607  D058  A0 FF              LDY     #$FF               ; SET INDEX
04608  D05A  E8                 INX                    ; ADJUST FOR LOOP
04609  D05B              XXD05B = *
04610  D05B  C8                 INY                    ; INCREMENT INDEX
04611  D05C  CA                 DEX                    ; DECREMENT COUNT
04612  D05D  D0 07              BNE     XXD066          ; IF STILL BYTES T
O DO GO COMPARE THEM






STRING......PAGE 0087

LINE# LOC   CODE        LINE


04613  D05F                     
04614  D05F  A6 66              LDX     XX66          ; GET LENGTH COMPARE
 BACK
04615  D061              XXD061 = *
04616  D061  30 0F              BMI     XXD072          ; BRANCH IF STR 1 
< STR 2
04617  D063                     
04618  D063  18                 CLC                    ; FLAG STR 1 <= STR
 2
04619  D064  90 0C              BCC     XXD072          ; GO EVALUATE RESU
LT, BRANCH ALWAYS
04620  D066                     
04621  D066              XXD066 = *
04622  D066  B1 6C              LDA     (XX6C),Y          ; GET STRING 2 B
YTE
04623  D068  D1 62              CMP     (XX62),Y          ; COMPARE WITH S
TRING 1 BYTE
04624  D06A  F0 EF              BEQ     XXD05B          ; LOOP IF BYTES =
04625  D06C                     
04626  D06C  A2 FF              LDX     #$FF               ; SET STR 1 < S
TRING 2
04627  D06E  B0 02              BCS     XXD072          ; BRANCH IF SO
04628  D070                     
04629  D070  A2 01              LDX     #$01               ; SET STR 1 > S
TRING 2
04630  D072              XXD072 = *
04631  D072  E8                 INX                    ; X = 0, 1 OR 2
04632  D073  8A                 TXA                    ; COPY TO A
04633  D074  2A                 ROL A                  ; * 2 (1, 2 OR 4)
04634  D075  25 12              AND     XX12          ; AND WITH THE COMPA
RISON EVALUATION FLAG
04635  D077  F0 02              BEQ     XXD07B          ; BRANCH IF 0 (COM
PARE IS FALSE)
04636  D079                     
04637  D079  A9 FF              LDA     #$FF               ; ELSE SET RESU
LT TRUE
04638  D07B              XXD07B = *
04639  D07B  4C 3C DC           JMP     XXDC3C          ; SAVE A AS INTEGE
R BYTE AND RETURN
04640  D07E                     
04641  D07E              XXD07E = *
04642  D07E  20 FD CE           JSR     XXCEFD          ; SCAN FOR ',', EL
SE DO SYNTAX ERROR THEN WARM START
04643  D081                     
04644  D081                     
04645  D081              ;************************************************
***********************************;
04646  D081              ;
04647  D081              ; PERFORM DIM
04648  D081              
04649  D081              XXD081 = *
04650  D081  AA                 TAX                    ; COPY 'DIM' FLAG T
O X
04651  D082  20 90 D0           JSR     XXD090          ; SEARCH FOR VARIA
BLE
04652  D085  20 79 00           JSR     XX0079          ; SCAN MEMORY
04653  D088  D0 F4              BNE     XXD07E          ; SCAN FOR ',' AND
 LOOP IF NOT NULL
04654  D08A                     
04655  D08A  60                 RTS
04656  D08B                     
04657  D08B                     
04658  D08B              ;************************************************
***********************************;
04659  D08B              ;
04660  D08B              ; SEARCH FOR VARIABLE
04661  D08B              
04662  D08B              XXD08B = *
04663  D08B  A2 00              LDX     #$00               ; SET DIM FLAG 
= $00
04664  D08D  20 79 00           JSR     XX0079          ; SCAN MEMORY, 1ST
 CHARACTER
04665  D090              XXD090 = *
04666  D090  86 0C              STX     XX0C          ; SAVE DIM FLAG
04667  D092              XXD092 = *






****;G......PAGE 0088

LINE# LOC   CODE        LINE


04668  D092  85 45              STA     XX45          ; SAVE 1ST CHARACTER

04669  D094  20 79 00           JSR     XX0079          ; SCAN MEMORY
04670  D097  20 13 D1           JSR     XXD113          ; CHECK BYTE, RETU
RN CB = 0 IF<'A' OR >'Z'
04671  D09A  B0 03              BCS     XXD09F          ; IF OK CONTINUE
04672  D09C                     
04673  D09C              XXD09C = *
04674  D09C  4C 08 CF           JMP     XXCF08          ; ELSE SYNTAX ERRO
R THEN WARM START
04675  D09F                     
04676  D09F              ; WAS VARIABLE NAME SO ...
04677  D09F              
04678  D09F              XXD09F = *
04679  D09F  A2 00              LDX     #$00               ; CLEAR 2ND CHA
RACTER TEMP
04680  D0A1  86 0D              STX     XX0D          ; CLEAR DATA TYPE FL
AG, $FF = STRING, $00 = NUMERIC
04681  D0A3  86 0E              STX     XX0E          ; CLEAR DATA TYPE FL
AG, $80 = INTEGER, $00 = FLOAT
04682  D0A5  20 73 00           JSR     XX0073          ; INCREMENT AND SC
AN MEMORY, 2ND CHARACTER
04683  D0A8  90 05              BCC     XXD0AF          ; IF CHARACTER = '
0'-'9' (OK) GO SAVE 2ND CHARACTER
04684  D0AA                     
04685  D0AA                                     ; 2ND CHARACTER WASN'T '0'
 TO '9' SO ...
04686  D0AA  20 13 D1           JSR     XXD113          ; CHECK BYTE, RETU
RN CB = 0 IF<'A' OR >'Z'
04687  D0AD  90 0B              BCC     XXD0BA          ; IF <'A' OR >'Z' 
GO CHECK IF STRING
04688  D0AF                     
04689  D0AF              XXD0AF = *
04690  D0AF  AA                 TAX                    ; COPY 2ND CHARACTE
R
04691  D0B0                     
04692  D0B0                                     ; IGNORE FURTHER (VALID) C
HARACTERS IN THE VARIABLE NAME
04693  D0B0              XXD0B0 = *
04694  D0B0  20 73 00           JSR     XX0073          ; INCREMENT AND SC
AN MEMORY, 3RD CHARACTER
04695  D0B3  90 FB              BCC     XXD0B0          ; LOOP IF CHARACTE
R = '0'-'9' (IGNORE)
04696  D0B5                     
04697  D0B5  20 13 D1           JSR     XXD113          ; CHECK BYTE, RETU
RN CB = 0 IF<'A' OR >'Z'
04698  D0B8  B0 F6              BCS     XXD0B0          ; LOOP IF CHARACTE
R = 'A'-'Z' (IGNORE)
04699  D0BA                     
04700  D0BA                                     ; CHECK IF STRING VARIABLE

04701  D0BA              XXD0BA = *
04702  D0BA  C9 24              CMP     #'$'               ; COMPARE WITH 
'$'
04703  D0BC  D0 06              BNE     XXD0C4          ; IF NOT STRING GO
 CHECK INTEGER
04704  D0BE                     
04705  D0BE                                     ; TYPE IS STRING
04706  D0BE  A9 FF              LDA     #$FF               ; SET DATA TYPE
 = STRING
04707  D0C0  85 0D              STA     XX0D          ; SET DATA TYPE FLAG
, $FF = STRING, $00 = NUMERIC
04708  D0C2  D0 10              BNE     XXD0D4          ; BRANCH ALWAYS
04709  D0C4                     
04710  D0C4              XXD0C4 = *
04711  D0C4  C9 25              CMP     #$25               ; COMPARE WITH 
'%'
04712  D0C6  D0 13              BNE     XXD0DB          ; IF NOT INTEGER G
O CHECK FOR AN ARRAY
04713  D0C8                     
04714  D0C8  A5 10              LDA     XX10          ; GET SUBSCRIPT/FNX 
FLAG
04715  D0CA  D0 D0              BNE     XXD09C          ; IF ?? DO SYNTAX 
ERROR THEN WARM START
04716  D0CC                     
04717  D0CC  A9 80              LDA     #$80               ; SET INTEGER T
YPE
04718  D0CE  85 0E              STA     XX0E          ; SET DATA TYPE = IN
TEGER
04719  D0D0  05 45              ORA     XX45          ; OR CURRENT VARIABL
E NAME FIRST BYTE
04720  D0D2  85 45              STA     XX45          ; SAVE CURRENT VARIA
BLE NAME FIRST BYTE
04721  D0D4              XXD0D4 = *
04722  D0D4  8A                 TXA                    ; GET 2ND CHARACTER
 BACK






LE**;G......PAGE 0089

LINE# LOC   CODE        LINE


04723  D0D5  09 80              ORA     #$80               ; SET TOP BIT, 
INDICATE STRING OR INTEGER VARIABLE
04724  D0D7  AA                 TAX                    ; COPY BACK TO 2ND 
CHARACTER TEMP
04725  D0D8  20 73 00           JSR     XX0073          ; INCREMENT AND SC
AN MEMORY
04726  D0DB              XXD0DB = *
04727  D0DB  86 46              STX     XX46          ; SAVE 2ND CHARACTER

04728  D0DD  38                 SEC                    ; SET CARRY FOR SUB
TRACT
04729  D0DE  05 10              ORA     XX10          ; OR WITH SUBSCRIPT/
FNX FLAG - OR FN NAME
04730  D0E0  E9 28              SBC     #$28               ; SUBTRACT '('
04731  D0E2  D0 03              BNE     XXD0E7          ; IF NOT '(' GO FI
ND A PLAIN NUMERIC VARIABLE
04732  D0E4                     
04733  D0E4  4C D1 D1           JMP     XXD1D1          ; ELSE GO FIND, OR
 MAKE, ARRAY
04734  D0E7                     
04735  D0E7              ; EITHER FIND OR CREATE VARIABLE
04736  D0E7              
04737  D0E7                                     ; VARIABLE NAME WASN'T XX(
.... SO LOOK FOR PLAIN VARIABLE
04738  D0E7              XXD0E7 = *
04739  D0E7  A0 00              LDY     #$00               ; CLEAR A
04740  D0E9  84 10              STY     XX10          ; CLEAR SUBSCRIPT/FN
X FLAG
04741  D0EB  A5 2D              LDA     XX2D          ; GET START OF VARIA
BLES LOW BYTE
04742  D0ED  A6 2E              LDX     XX2E          ; GET START OF VARIA
BLES HIGH BYTE
04743  D0EF              XXD0EF = *
04744  D0EF  86 60              STX     XX60          ; SAVE SEARCH ADDRES
S HIGH BYTE
04745  D0F1              XXD0F1 = *
04746  D0F1  85 5F              STA     XX5F          ; SAVE SEARCH ADDRES
S LOW BYTE
04747  D0F3  E4 30              CPX     XX30          ; COMPARE WITH END O
F VARIABLES HIGH BYTE
04748  D0F5  D0 04              BNE     XXD0FB          ; SKIP NEXT COMPAR
E IF <>
04749  D0F7                     
04750  D0F7                                     ; HIGH ADDRESSES WERE = SO
 COMPARE LOW ADDRESSES
04751  D0F7  C5 2F              CMP     XX2F          ; COMPARE LOW ADDRES
S WITH END OF VARIABLES LOW BYTE
04752  D0F9  F0 22              BEQ     XXD11D          ; IF NOT FOUND GO 
MAKE NEW VARIABLE
04753  D0FB                     
04754  D0FB              XXD0FB = *
04755  D0FB  A5 45              LDA     XX45          ; GET 1ST CHARACTER 
OF VARIABLE TO FIND
04756  D0FD  D1 5F              CMP     (XX5F),Y          ; COMPARE WITH V
ARIABLE NAME 1ST CHARACTER
04757  D0FF  D0 08              BNE     XXD109          ; IF NO MATCH GO T
RY THE NEXT VARIABLE
04758  D101                     
04759  D101                                     ; 1ST CHARACTERS MATCH SO 
COMPARE 2ND CHARACTER
04760  D101  A5 46              LDA     XX46          ; GET 2ND CHARACTER 
OF VARIABLE TO FIND
04761  D103  C8                 INY                    ; INDEX TO POINT TO
 VARIABLE NAME 2ND CHARACTER
04762  D104  D1 5F              CMP     (XX5F),Y          ; COMPARE WITH V
ARIABLE NAME 2ND CHARACTER
04763  D106  F0 7D              BEQ     XXD185          ; IF MATCH GO RETU
RN THE VARIABLE
04764  D108                     
04765  D108  88                 DEY                    ; ELSE DECREMENT IN
DEX (NOW = $00)
04766  D109              XXD109 = *
04767  D109  18                 CLC                    ; CLEAR CARRY FOR A
DD
04768  D10A  A5 5F              LDA     XX5F          ; GET SEARCH ADDRESS
 LOW BYTE
04769  D10C  69 07              ADC     #$07               ; +7, OFFSET TO
 NEXT VARIABLE NAME
04770  D10E  90 E1              BCC     XXD0F1          ; LOOP IF NO OVERF
LOW TO HIGH BYTE
04771  D110                     
04772  D110  E8                 INX                    ; ELSE INCREMENT HI
GH BYTE
04773  D111  D0 DC              BNE     XXD0EF          ; LOOP ALWAYS, RAM
 DOESN'T EXTEND TO $FFFF
04774  D113                     
04775  D113                     
04776  D113              ;************************************************
***********************************;
04777  D113              ;






****;G......PAGE 0090

LINE# LOC   CODE        LINE


04778  D113              ; CHECK BYTE, RETURN CB = 0 IF<'A' OR >'Z'
04779  D113              
04780  D113              XXD113 = *
04781  D113  C9 41              CMP     #$41               ; COMPARE WITH 
'A'
04782  D115  90 05              BCC     XXD11C          ; EXIT IF LESS
04783  D117                     
04784  D117                                     ; CARRY IS SET
04785  D117  E9 5B              SBC     #$5B               ; SUBTRACT 'Z'+
1
04786  D119  38                 SEC                    ; SET CARRY
04787  D11A  E9 A5              SBC     #$A5               ; SUBTRACT $A5 
(RESTORE BYTE)
04788  D11C                                     ; CARRY CLEAR IF BYTE > $5
A
04789  D11C              XXD11C = *
04790  D11C  60                 RTS
04791  D11D                     
04792  D11D                     
04793  D11D              ;************************************************
***********************************;
04794  D11D              ;
04795  D11D                                     ; REACHED END OF VARIABLE 
MEMORY WITHOUT MATCH
04796  D11D                                     ; ... SO CREATE NEW VARIAB
LE
04797  D11D              XXD11D = *
04798  D11D  68                 PLA                    ; POP RETURN ADDRES
S LOW BYTE
04799  D11E  48                 PHA                    ; PUSH RETURN ADDRE
SS LOW BYTE
04800  D11F  C9 2A              CMP     #$2A               ; COMPARE WITH 
EXPECTED CALLING ROUTINE RETURN LOW BYTE
04801  D121  D0 05              BNE     XXD128          ; IF NOT GET VARIA
BLE GO CREATE NEW VARIABLE
04802  D123                     
04803  D123              ; THIS WILL ONLY DROP THROUGH IF THE CALL WAS FRO
M XXXXXX AND IS ONLY CALLED
04804  D123              ; FROM THERE IF IT IS SEARCHING FOR A VARIABLE FR
OM THE RIGHT HAND SIDE OF A LET A=B
04805  D123              ; STATEMENT, IT PREVENTS THE CREATION OF VARIABLE
S NOT ASSIGNED A VALUE.
04806  D123              
04807  D123              ; VALUE RETURNED BY THIS IS EITHER NUMERIC ZERO, 
EXPONENT BYTE IS $00, OR NULL STRING,
04808  D123              ; DESCRIPTOR LENGTH BYTE IS $00. IN FACT A POINTE
R TO ANY $00 BYTE WOULD HAVE DONE.
04809  D123              
04810  D123                                     ; ELSE RETURN DUMMY NULL V
ALUE
04811  D123              XXD123 = *
04812  D123  A9 13              LDA     #<XXDF13          ; SET RESULT POI
NTER LOW BYTE
04813  D125  A0 DF              LDY     #>XXDF13          ; SET RESULT POI
NTER HIGH BYTE
04814  D127  60                 RTS
04815  D128                     
04816  D128                                     ; CREATE NEW NUMERIC VARIA
BLE
04817  D128              XXD128 = *
04818  D128  A5 45              LDA     XX45          ; GET VARIABLE NAME 
FIRST CHARACTER
04819  D12A  A4 46              LDY     XX46          ; GET VARIABLE NAME 
SECOND CHARACTER
04820  D12C  C9 54              CMP     #'T'               ; COMPARE FIRST
 CHARACTER WITH 'T'
04821  D12E  D0 0B              BNE     XXD13B          ; IF NOT 'T' CONTI
NUE
04822  D130                     
04823  D130  C0 C9              CPY     #$C9    ;#'I'+$80          ; COMPA
RE SECOND CHARACTER WITH 'I$'
04824  D132  F0 EF              BEQ     XXD123          ; IF 'I$' RETURN N
ULL VALUE
04825  D134                     
04826  D134  C0 49              CPY     #'I'               ; COMPARE SECON
D CHARACTER WITH 'I'
04827  D136  D0 03              BNE     XXD13B          ; IF NOT 'I' CONTI
NUE
04828  D138                     
04829  D138                                     ; IF NAME IS 'TI' DO SYNTA
X ERROR
04830  D138              XXD138 = *
04831  D138  4C 08 CF           JMP     XXCF08          ; DO SYNTAX ERROR 
THEN WARM START
04832  D13B                     






NE.NG,......PAGE 0091

LINE# LOC   CODE        LINE


04833  D13B              XXD13B = *
04834  D13B  C9 53              CMP     #'S'               ; COMPARE FIRST
 CHARACTER WITH 'S'
04835  D13D  D0 04              BNE     XXD143          ; IF NOT 'S' CONTI
NUE
04836  D13F                     
04837  D13F  C0 54              CPY     #'T'               ; COMPARE SECON
D CHARACTER WITH 'T'
04838  D141  F0 F5              BEQ     XXD138          ; IF NAME IS 'ST' 
DO SYNTAX ERROR
04839  D143                     
04840  D143              XXD143 = *
04841  D143  A5 2F              LDA     XX2F          ; GET END OF VARIABL
ES LOW BYTE
04842  D145  A4 30              LDY     XX30          ; GET END OF VARIABL
ES HIGH BYTE
04843  D147  85 5F              STA     XX5F          ; SAVE OLD BLOCK STA
RT LOW BYTE
04844  D149  84 60              STY     XX60          ; SAVE OLD BLOCK STA
RT HIGH BYTE
04845  D14B  A5 31              LDA     XX31          ; GET END OF ARRAYS 
LOW BYTE
04846  D14D  A4 32              LDY     XX32          ; GET END OF ARRAYS 
HIGH BYTE
04847  D14F  85 5A              STA     XX5A          ; SAVE OLD BLOCK END
 LOW BYTE
04848  D151  84 5B              STY     XX5B          ; SAVE OLD BLOCK END
 HIGH BYTE
04849  D153  18                 CLC                    ; CLEAR CARRY FOR A
DD
04850  D154  69 07              ADC     #$07               ; +7, SPACE FOR
 ONE VARIABLE
04851  D156  90 01              BCC     XXD159          ; IF NO OVERFLOW S
KIP THE HIGH BYTE INCREMENT
04852  D158                     
04853  D158  C8                 INY                    ; ELSE INCREMENT HI
GH BYTE
04854  D159              XXD159 = *
04855  D159  85 58              STA     XX58          ; SET NEW BLOCK END 
LOW BYTE
04856  D15B  84 59              STY     XX59          ; SET NEW BLOCK END 
HIGH BYTE
04857  D15D  20 B8 C3           JSR     XXC3B8          ; OPEN UP SPACE IN
 MEMORY
04858  D160  A5 58              LDA     XX58          ; GET NEW START LOW 
BYTE
04859  D162  A4 59              LDY     XX59          ; GET NEW START HIGH
 BYTE (-$100)
04860  D164  C8                 INY                    ; CORRECT HIGH BYTE

04861  D165  85 2F              STA     XX2F          ; SET END OF VARIABL
ES LOW BYTE
04862  D167  84 30              STY     XX30          ; SET END OF VARIABL
ES HIGH BYTE
04863  D169  A0 00              LDY     #$00               ; CLEAR INDEX
04864  D16B  A5 45              LDA     XX45          ; GET VARIABLE NAME 
1ST CHARACTER
04865  D16D  91 5F              STA     (XX5F),Y          ; SAVE VARIABLE 
NAME 1ST CHARACTER
04866  D16F  C8                 INY                    ; INCREMENT INDEX
04867  D170  A5 46              LDA     XX46          ; GET VARIABLE NAME 
2ND CHARACTER
04868  D172  91 5F              STA     (XX5F),Y          ; SAVE VARIABLE 
NAME 2ND CHARACTER
04869  D174  A9 00              LDA     #$00               ; CLEAR A
04870  D176  C8                 INY                    ; INCREMENT INDEX
04871  D177  91 5F              STA     (XX5F),Y          ; INITIALISE VAR
IABLE BYTE
04872  D179  C8                 INY                    ; INCREMENT INDEX
04873  D17A  91 5F              STA     (XX5F),Y          ; INITIALISE VAR
IABLE BYTE
04874  D17C  C8                 INY                    ; INCREMENT INDEX
04875  D17D  91 5F              STA     (XX5F),Y          ; INITIALISE VAR
IABLE BYTE
04876  D17F  C8                 INY                    ; INCREMENT INDEX
04877  D180  91 5F              STA     (XX5F),Y          ; INITIALISE VAR
IABLE BYTE
04878  D182  C8                 INY                    ; INCREMENT INDEX
04879  D183  91 5F              STA     (XX5F),Y          ; INITIALISE VAR
IABLE BYTE
04880  D185                     
04881  D185                                     ; FOUND A MATCH FOR VARIAB
LE
04882  D185              XXD185 = *
04883  D185  A5 5F              LDA     XX5F          ; GET VARIABLE ADDRE
SS LOW BYTE
04884  D187  18                 CLC                    ; CLEAR CARRY FOR A
DD
04885  D188  69 02              ADC     #$02               ; +2, OFFSET PA
ST VARIABLE NAME BYTES
04886  D18A  A4 60              LDY     XX60          ; GET VARIABLE ADDRE
SS HIGH BYTE
04887  D18C  90 01              BCC     XXD18F          ; IF NO OVERFLOW S
KIP THE HIGH BYTE INCREMENT






NE.NG,......PAGE 0092

LINE# LOC   CODE        LINE


04888  D18E                     
04889  D18E  C8                 INY                    ; ELSE INCREMENT HI
GH BYTE
04890  D18F              XXD18F = *
04891  D18F  85 47              STA     XX47          ; SAVE CURRENT VARIA
BLE POINTER LOW BYTE
04892  D191  84 48              STY     XX48          ; SAVE CURRENT VARIA
BLE POINTER HIGH BYTE
04893  D193  60                 RTS
04894  D194                     
04895  D194                     
04896  D194              ;************************************************
***********************************;
04897  D194              ;
04898  D194              ; SET-UP ARRAY POINTER TO FIRST ELEMENT IN ARRAY
04899  D194              
04900  D194              XXD194 = *
04901  D194  A5 0B              LDA     XX0B          ; GET # OF DIMENSION
S (1, 2 OR 3)
04902  D196  0A                 ASL A                  ; *2 (ALSO CLEARS T
HE CARRY !)
04903  D197  69 05              ADC     #$05               ; +5 (RESULT IS
 7, 9 OR 11 HERE)
04904  D199  65 5F              ADC     XX5F          ; ADD ARRAY START PO
INTER LOW BYTE
04905  D19B  A4 60              LDY     XX60          ; GET ARRAY POINTER 
HIGH BYTE
04906  D19D  90 01              BCC     XXD1A0          ; IF NO OVERFLOW S
KIP THE HIGH BYTE INCREMENT
04907  D19F                     
04908  D19F  C8                 INY                    ; ELSE INCREMENT HI
GH BYTE
04909  D1A0              XXD1A0 = *
04910  D1A0  85 58              STA     XX58          ; SAVE ARRAY DATA PO
INTER LOW BYTE
04911  D1A2  84 59              STY     XX59          ; SAVE ARRAY DATA PO
INTER HIGH BYTE
04912  D1A4  60                 RTS
04913  D1A5                     
04914  D1A5                     
04915  D1A5              ;************************************************
***********************************;
04916  D1A5              ;
04917  D1A5              ; -32768 AS FLOATING VALUE
04918  D1A5              
04919  D1A5              XXD1A5 = *
04920  D1A5  90                 .BYTE     $90,$80,$00,$00,$00     ; -32768

04920  D1A6  80 
04920  D1A7  00 
04920  D1A8  00 
04920  D1A9  00 
04921  D1AA                     
04922  D1AA                     
04923  D1AA              ;************************************************
***********************************;
04924  D1AA              ;
04925  D1AA              ; CONVERT FLOAT TO FIXED
04926  D1AA              
04927  D1AA              XXD1AA = *
04928  D1AA  20 BF D1           JSR     XXD1BF          ; EVALUATE INTEGER
 EXPRESSION, NO SIGN CHECK
04929  D1AD  A5 64              LDA     XX64          ; GET RESULT LOW BYT
E
04930  D1AF  A4 65              LDY     XX65          ; GET RESULT HIGH BY
TE
04931  D1B1  60                 RTS
04932  D1B2                     
04933  D1B2                     
04934  D1B2              ;************************************************
***********************************;
04935  D1B2              ;
04936  D1B2              ; EVALUATE INTEGER EXPRESSION
04937  D1B2              
04938  D1B2              XXD1B2 = *






****;,......PAGE 0093

LINE# LOC   CODE        LINE


04939  D1B2  20 73 00           JSR     XX0073          ; INCREMENT AND SC
AN MEMORY
04940  D1B5  20 9E CD           JSR     XXCD9E          ; EVALUATE EXPRESS
ION
04941  D1B8                     
04942  D1B8              ; EVALUATE INTEGER EXPRESSION, SIGN CHECK
04943  D1B8              
04944  D1B8              XXD1B8 = *
04945  D1B8  20 8D CD           JSR     XXCD8D          ; CHECK IF SOURCE 
IS NUMERIC, ELSE DO TYPE MISMATCH
04946  D1BB  A5 66              LDA     XX66          ; GET FAC1 SIGN (B7)

04947  D1BD  30 0D              BMI     XXD1CC          ; DO ILLEGAL QUANT
ITY ERROR IF -VE
04948  D1BF                     
04949  D1BF              ; EVALUATE INTEGER EXPRESSION, NO SIGN CHECK
04950  D1BF              
04951  D1BF              XXD1BF = *
04952  D1BF  A5 61              LDA     XX61          ; GET FAC1 EXPONENT
04953  D1C1  C9 90              CMP     #$90               ; COMPARE WITH 
EXPONENT = 2^16 (N>2^15)
04954  D1C3  90 09              BCC     XXD1CE          ; IF N<2^16 GO CON
VERT FAC1 FLOATING TO FIXED AND RETURN
04955  D1C5                     
04956  D1C5  A9 A5              LDA     #<XXD1A5          ; SET POINTER LO
W BYTE TO -32768
04957  D1C7  A0 D1              LDY     #>XXD1A5          ; SET POINTER HI
GH BYTE TO -32768
04958  D1C9  20 5B DC           JSR     XXDC5B          ; COMPARE FAC1 WIT
H (AY)
04959  D1CC              XXD1CC = *
04960  D1CC  D0 7A              BNE     XXD248          ; IF <> DO ILLEGAL
 QUANTITY ERROR THEN WARM START
04961  D1CE                     
04962  D1CE              XXD1CE = *
04963  D1CE  4C 9B DC           JMP     XXDC9B          ; CONVERT FAC1 FLO
ATING TO FIXED AND RETURN
04964  D1D1                     
04965  D1D1                     
04966  D1D1              ;************************************************
***********************************;
04967  D1D1              ;
04968  D1D1              ; AN ARRAY IS STORED AS FOLLOWS
04969  D1D1              ;
04970  D1D1              ; ARRAY NAME               ; TWO BYTES WITH THE F
OLLOWING PATTERNS FOR DIFFERENT TYPES
04971  D1D1              ;                         ; 1ST CHAR     2ND CHAR

04972  D1D1              ;                         ;   B7       B7        
  TYPE               ELEMENT SIZE
04973  D1D1              ;                         ; --------     --------
     -----               ------------
04974  D1D1              ;                         ;   0            0     
     FLOATING POINT      5
04975  D1D1              ;                         ;   0            1     
     STRING           3
04976  D1D1              ;                         ;   1            1     
     INTEGER           2
04977  D1D1              ; OFFSET TO NEXT ARRAY          ; WORD
04978  D1D1              ; DIMENSION COUNT               ; BYTE
04979  D1D1              ; 1ST DIMENSION SIZE          ; WORD, THIS IS THE
 NUMBER OF ELEMENTS INCLUDING 0
04980  D1D1              ; 2ND DIMENSION SIZE          ; WORD, ONLY HERE I
F THE ARRAY HAS A SECOND DIMENSION
04981  D1D1              ; 2ND DIMENSION SIZE          ; WORD, ONLY HERE I
F THE ARRAY HAS A THIRD DIMENSION
04982  D1D1              ;                         ; NOTE: THE DIMENSION S
IZE WORD IS IN HIGH BYTE LOW BYTE
04983  D1D1              ;                         ; FORMAT, NOT LIKE MOST
 6502 WORDS
04984  D1D1              ; THEN FOR EACH ELEMENT THE REQUIRED NUMBER OF BY
TES GIVEN AS THE ELEMENT SIZE ABOVE
04985  D1D1              
04986  D1D1              ; FIND OR MAKE ARRAY
04987  D1D1              
04988  D1D1              XXD1D1 = *
04989  D1D1  A5 0C              LDA     XX0C          ; GET DIM FLAG
04990  D1D3  05 0E              ORA     XX0E          ; OR WITH DATA TYPE 
FLAG
04991  D1D5  48                 PHA                    ; PUSH IT
04992  D1D6  A5 0D              LDA     XX0D          ; GET DATA TYPE FLAG
, $FF = STRING, $00 = NUMERIC
04993  D1D8  48                 PHA                    ; PUSH IT






BOVE--......PAGE 0094

LINE# LOC   CODE        LINE


04994  D1D9  A0 00              LDY     #$00               ; CLEAR DIMENSI
ONS COUNT
04995  D1DB                     
04996  D1DB              ; NOW GET THE ARRAY DIMENSION(S) AND STACK IT (TH
EM) BEFORE THE DATA TYPE AND DIM FLAG
04997  D1DB              
04998  D1DB              XXD1DB = *
04999  D1DB  98                 TYA                    ; COPY DIMENSIONS C
OUNT
05000  D1DC  48                 PHA                    ; SAVE IT
05001  D1DD  A5 46              LDA     XX46          ; GET ARRAY NAME 2ND
 BYTE
05002  D1DF  48                 PHA                    ; SAVE IT
05003  D1E0  A5 45              LDA     XX45          ; GET ARRAY NAME 1ST
 BYTE
05004  D1E2  48                 PHA                    ; SAVE IT
05005  D1E3  20 B2 D1           JSR     XXD1B2          ; EVALUATE INTEGER
 EXPRESSION
05006  D1E6  68                 PLA                    ; PULL ARRAY NAME 1
ST BYTE
05007  D1E7  85 45              STA     XX45          ; RESTORE ARRAY NAME
 1ST BYTE
05008  D1E9  68                 PLA                    ; PULL ARRAY NAME 2
ND BYTE
05009  D1EA  85 46              STA     XX46          ; RESTORE ARRAY NAME
 2ND BYTE
05010  D1EC  68                 PLA                    ; PULL DIMENSIONS C
OUNT
05011  D1ED  A8                 TAY                    ; RESTORE IT
05012  D1EE  BA                 TSX                    ; COPY STACK POINTE
R
05013  D1EF  BD 02 01           LDA     XX0100+2,X     ; GET DIM FLAG
05014  D1F2  48                 PHA                    ; PUSH IT
05015  D1F3  BD 01 01           LDA     XX0100+1,X     ; GET DATA TYPE FLA
G
05016  D1F6  48                 PHA                    ; PUSH IT
05017  D1F7  A5 64              LDA     XX64          ; GET THIS DIMENSION
 SIZE HIGH BYTE
05018  D1F9  9D 02 01           STA     XX0100+2,X     ; STACK BEFORE FLAG
 BYTES
05019  D1FC  A5 65              LDA     XX65          ; GET THIS DIMENSION
 SIZE LOW BYTE
05020  D1FE  9D 01 01           STA     XX0100+1,X     ; STACK BEFORE FLAG
 BYTES
05021  D201  C8                 INY                    ; INCREMENT DIMENSI
ONS COUNT
05022  D202  20 79 00           JSR     XX0079          ; SCAN MEMORY
05023  D205  C9 2C              CMP     #','               ; COMPARE WITH 
','
05024  D207  F0 D2              BEQ     XXD1DB          ; IF FOUND GO DO N
EXT DIMENSION
05025  D209                     
05026  D209  84 0B              STY     XX0B          ; STORE DIMENSIONS C
OUNT
05027  D20B  20 F7 CE           JSR     XXCEF7          ; SCAN FOR ')', EL
SE DO SYNTAX ERROR THEN WARM START
05028  D20E  68                 PLA                    ; PULL DATA TYPE FL
AG
05029  D20F  85 0D              STA     XX0D          ; RESTORE DATA TYPE 
FLAG, $FF = STRING, $00 = NUMERIC
05030  D211  68                 PLA                    ; PULL DATA TYPE FL
AG
05031  D212  85 0E              STA     XX0E          ; RESTORE DATA TYPE 
FLAG, $80 = INTEGER, $00 = FLOAT
05032  D214  29 7F              AND     #$7F               ; MASK DIM FLAG

05033  D216  85 0C              STA     XX0C          ; RESTORE DIM FLAG
05034  D218  A6 2F              LDX     XX2F          ; SET END OF VARIABL
ES LOW BYTE
05035  D21A                                     ; (ARRAY MEMORY START LOW 
BYTE)
05036  D21A  A5 30              LDA     XX30          ; SET END OF VARIABL
ES HIGH BYTE
05037  D21C                                     ; (ARRAY MEMORY START HIGH
 BYTE)
05038  D21C                     
05039  D21C              ; NOW CHECK TO SEE IF WE ARE AT THE END OF ARRAY 
MEMORY, WE WOULD BE IF THERE WERE
05040  D21C              ; NO ARRAYS.
05041  D21C              
05042  D21C              XXD21C = *
05043  D21C  86 5F              STX     XX5F          ; SAVE AS ARRAY STAR
T POINTER LOW BYTE
05044  D21E  85 60              STA     XX60          ; SAVE AS ARRAY STAR
T POINTER HIGH BYTE
05045  D220  C5 32              CMP     XX32          ; COMPARE WITH END O
F ARRAYS HIGH BYTE
05046  D222  D0 04              BNE     XXD228          ; IF NOT REACHED A
RRAY MEMORY END CONTINUE SEARCHING
05047  D224                     
05048  D224  E4 31              CPX     XX31          ; ELSE COMPARE WITH 
END OF ARRAYS LOW BYTE






GEFLAG......PAGE 0095

LINE# LOC   CODE        LINE


05049  D226  F0 39              BEQ     XXD261          ; GO BUILD ARRAY I
F NOT FOUND
05050  D228                     
05051  D228                                     ; SEARCH FOR ARRAY
05052  D228              XXD228 = *
05053  D228  A0 00              LDY     #$00               ; CLEAR INDEX
05054  D22A  B1 5F              LDA     (XX5F),Y          ; GET ARRAY NAME
 FIRST BYTE
05055  D22C  C8                 INY                    ; INCREMENT INDEX T
O SECOND NAME BYTE
05056  D22D  C5 45              CMP     XX45          ; COMPARE WITH THIS 
ARRAY NAME FIRST BYTE
05057  D22F  D0 06              BNE     XXD237          ; IF NO MATCH GO T
RY THE NEXT ARRAY
05058  D231                     
05059  D231  A5 46              LDA     XX46          ; ELSE GET THIS ARRA
Y NAME SECOND BYTE
05060  D233  D1 5F              CMP     (XX5F),Y          ; COMPARE WITH A
RRAY NAME SECOND BYTE
05061  D235  F0 16              BEQ     XXD24D          ; ARRAY FOUND SO B
RANCH
05062  D237                     
05063  D237                                     ; NO MATCH
05064  D237              XXD237 = *
05065  D237  C8                 INY                    ; INCREMENT INDEX
05066  D238  B1 5F              LDA     (XX5F),Y          ; GET ARRAY SIZE
 LOW BYTE
05067  D23A  18                 CLC                    ; CLEAR CARRY FOR A
DD
05068  D23B  65 5F              ADC     XX5F          ; ADD ARRAY START PO
INTER LOW BYTE
05069  D23D  AA                 TAX                    ; COPY LOW BYTE TO 
X
05070  D23E  C8                 INY                    ; INCREMENT INDEX
05071  D23F  B1 5F              LDA     (XX5F),Y          ; GET ARRAY SIZE
 HIGH BYTE
05072  D241  65 60              ADC     XX60          ; ADD ARRAY MEMORY P
OINTER HIGH BYTE
05073  D243  90 D7              BCC     XXD21C          ; IF NO OVERFLOW G
O CHECK NEXT ARRAY
05074  D245                     
05075  D245              ; DO BAD SUBSCRIPT ERROR
05076  D245              
05077  D245              XXD245 = *
05078  D245  A2 12              LDX     #$12               ; ERROR $12, BA
D SUBSCRIPT ERROR
05079  D247  2C                 .BYTE     $2C               ; MAKES NEXT L
INE BIT XX0EA2
05080  D248                     
05081  D248                     
05082  D248              ;************************************************
***********************************;
05083  D248              ;
05084  D248              ; DO ILLEGAL QUANTITY ERROR
05085  D248              
05086  D248              XXD248 = *
05087  D248  A2 0E              LDX     #$0E               ; ERROR $0E, IL
LEGAL QUANTITY ERROR
05088  D24A              XXD24A = *
05089  D24A  4C 37 C4           JMP     XXC437          ; DO ERROR #X THEN
 WARM START
05090  D24D                     
05091  D24D                     
05092  D24D              ;************************************************
***********************************;
05093  D24D              ;
05094  D24D              ; ARRAY FOUND
05095  D24D              
05096  D24D              XXD24D = *
05097  D24D  A2 13              LDX     #$13               ; SET ERROR $13
, DOUBLE DIMENSION ERROR
05098  D24F  A5 0C              LDA     XX0C          ; GET DIM FLAG
05099  D251  D0 F7              BNE     XXD24A          ; IF WE ARE TRYING
 TO DIMENSION IT DO ERROR #X THEN WARM
05100  D253                                     ; START
05101  D253                     
05102  D253              ; FOUND THE ARRAY AND WE'RE NOT DIMENSIONING IT S
O WE MUST FIND AN ELEMENT IN IT
05103  D253              






 WARMG......PAGE 0096

LINE# LOC   CODE        LINE


05104  D253  20 94 D1           JSR     XXD194          ; SET-UP ARRAY POI
NTER TO FIRST ELEMENT IN ARRAY
05105  D256  A5 0B              LDA     XX0B          ; GET DIMENSIONS COU
NT
05106  D258  A0 04              LDY     #$04               ; SET INDEX TO 
ARRAY'S # OF DIMENSIONS
05107  D25A  D1 5F              CMP     (XX5F),Y          ; COMPARE WITH N
O OF DIMENSIONS
05108  D25C  D0 E7              BNE     XXD245          ; IF WRONG DO BAD 
SUBSCRIPT ERROR
05109  D25E                     
05110  D25E  4C EA D2           JMP     XXD2EA          ; FOUND ARRAY SO G
O GET ELEMENT
05111  D261                     
05112  D261                                     ; ARRAY NOT FOUND, SO BUIL
D IT
05113  D261              XXD261 = *
05114  D261  20 94 D1           JSR     XXD194          ; SET-UP ARRAY POI
NTER TO FIRST ELEMENT IN ARRAY
05115  D264  20 08 C4           JSR     XXC408          ; CHECK AVAILABLE 
MEMORY, DO OUT OF MEMORY ERROR IF NO ROOM
05116  D267  A0 00              LDY     #$00               ; CLEAR Y
05117  D269  84 72              STY     XX72          ; CLEAR ARRAY DATA S
IZE HIGH BYTE
05118  D26B  A2 05              LDX     #$05               ; SET DEFAULT E
LEMENT SIZE
05119  D26D  A5 45              LDA     XX45          ; GET VARIABLE NAME 
1ST BYTE
05120  D26F  91 5F              STA     (XX5F),Y          ; SAVE ARRAY NAM
E 1ST BYTE
05121  D271  10 01              BPL     XXD274          ; BRANCH IF NOT ST
RING OR FLOATING POINT ARRAY
05122  D273                     
05123  D273  CA                 DEX                    ; DECREMENT ELEMENT
 SIZE, $04
05124  D274              XXD274 = *
05125  D274  C8                 INY                    ; INCREMENT INDEX
05126  D275  A5 46              LDA     XX46          ; GET VARIABLE NAME 
2ND BYTE
05127  D277  91 5F              STA     (XX5F),Y          ; SAVE ARRAY NAM
E 2ND BYTE
05128  D279  10 02              BPL     XXD27D          ; BRANCH IF NOT IN
TEGER OR STRING
05129  D27B                     
05130  D27B  CA                 DEX                    ; DECREMENT ELEMENT
 SIZE, $03
05131  D27C  CA                 DEX                    ; DECREMENT ELEMENT
 SIZE, $02
05132  D27D              XXD27D = *
05133  D27D  86 71              STX     XX71          ; SAVE ELEMENT SIZE
05134  D27F  A5 0B              LDA     XX0B          ; GET DIMENSIONS COU
NT
05135  D281  C8                 INY                    ; INCREMENT INDEX .
.
05136  D282  C8                 INY                    ; .. TO ARRAY  ..
05137  D283  C8                 INY                    ; .. DIMENSION COUN
T
05138  D284  91 5F              STA     (XX5F),Y          ; SAVE ARRAY DIM
ENSION COUNT
05139  D286              XXD286 = *
05140  D286  A2 0B              LDX     #$0B               ; SET DEFAULT D
IMENSION SIZE LOW BYTE
05141  D288  A9 00              LDA     #$00               ; SET DEFAULT D
IMENSION SIZE HIGH BYTE
05142  D28A  24 0C              BIT     XX0C          ; TEST DIM FLAG
05143  D28C  50 08              BVC     XXD296          ; IF DEFAULT TO BE
 USED DON'T PULL A DIMENSION
05144  D28E                     
05145  D28E  68                 PLA                    ; PULL DIMENSION SI
ZE LOW BYTE
05146  D28F  18                 CLC                    ; CLEAR CARRY FOR A
DD
05147  D290  69 01              ADC     #$01               ; ADD 1, ALLOW 
FOR ZEROETH ELEMENT
05148  D292  AA                 TAX                    ; COPY LOW BYTE TO 
X
05149  D293  68                 PLA                    ; PULL DIMENSION SI
ZE HIGH BYTE
05150  D294  69 00              ADC     #$00               ; ADD CARRY TO 
HIGH BYTE
05151  D296              XXD296 = *
05152  D296  C8                 INY                    ; INCEMENT INDEX TO
 DIMENSION SIZE HIGH BYTE
05153  D297  91 5F              STA     (XX5F),Y          ; SAVE DIMENSION
 SIZE HIGH BYTE
05154  D299  C8                 INY                    ; INCEMENT INDEX TO
 DIMENSION SIZE LOW BYTE
05155  D29A  8A                 TXA                    ; COPY DIMENSION SI
ZE LOW BYTE
05156  D29B  91 5F              STA     (XX5F),Y          ; SAVE DIMENSION
 SIZE LOW BYTE
05157  D29D  20 4C D3           JSR     XXD34C          ; COMPUTE ARRAY SI
ZE
05158  D2A0  86 71              STX     XX71          ; SAVE RESULT LOW BY
TE






 NO RO......PAGE 0097

LINE# LOC   CODE        LINE


05159  D2A2  85 72              STA     XX72          ; SAVE RESULT HIGH B
YTE
05160  D2A4  A4 22              LDY     XX22          ; RESTORE INDEX
05161  D2A6  C6 0B              DEC     XX0B          ; DECREMENT DIMENSIO
NS COUNT
05162  D2A8  D0 DC              BNE     XXD286          ; LOOP IF NOT ALL 
DONE
05163  D2AA                     
05164  D2AA  65 59              ADC     XX59          ; ADD ARRAY DATA POI
NTER HIGH BYTE
05165  D2AC  B0 5D              BCS     XXD30B          ; IF OVERFLOW DO O
UT OF MEMORY ERROR THEN WARM START
05166  D2AE                     
05167  D2AE  85 59              STA     XX59          ; SAVE ARRAY DATA PO
INTER HIGH BYTE
05168  D2B0  A8                 TAY                    ; COPY ARRAY DATA P
OINTER HIGH BYTE
05169  D2B1  8A                 TXA                    ; COPY ARRAY SIZE L
OW BYTE
05170  D2B2  65 58              ADC     XX58          ; ADD ARRAY DATA POI
NTER LOW BYTE
05171  D2B4  90 03              BCC     XXD2B9          ; IF NO ROLLOVER S
KIP THE HIGH BYTE INCREMENT
05172  D2B6                     
05173  D2B6  C8                 INY                    ; ELSE INCREMENT NE
XT ARRAY POINTER HIGH BYTE
05174  D2B7  F0 52              BEQ     XXD30B          ; IF ROLLED OVER D
O OUT OF MEMORY ERROR THEN WARM START
05175  D2B9                     
05176  D2B9              XXD2B9 = *
05177  D2B9  20 08 C4           JSR     XXC408          ; CHECK AVAILABLE 
MEMORY, DO OUT OF MEMORY ERROR IF NO ROOM
05178  D2BC  85 31              STA     XX31          ; SET END OF ARRAYS 
LOW BYTE
05179  D2BE  84 32              STY     XX32          ; SET END OF ARRAYS 
HIGH BYTE
05180  D2C0                     
05181  D2C0              ; NOW THE ARAY IS CREATED WE NEED TO ZERO ALL THE
 ELEMENTS IN IT
05182  D2C0              
05183  D2C0  A9 00              LDA     #$00               ; CLEAR A FOR A
RRAY CLEAR
05184  D2C2  E6 72              INC     XX72          ; INCREMENT ARRAY SI
ZE HIGH BYTE, NOW BLOCK COUNT
05185  D2C4  A4 71              LDY     XX71          ; GET ARRAY SIZE LOW
 BYTE, NOW INDEX TO BLOCK
05186  D2C6  F0 05              BEQ     XXD2CD          ; IF $00 GO DO THE
 HIGH BYTE DECREMENT
05187  D2C8              XXD2C8 = *
05188  D2C8  88                 DEY                    ; DECREMENT INDEX, 
DO 0 TO N-1
05189  D2C9  91 58              STA     (XX58),Y          ; CLEAR ARRAY EL
EMENT BYTE
05190  D2CB  D0 FB              BNE     XXD2C8          ; LOOP UNTIL THIS 
BLOCK DONE
05191  D2CD                     
05192  D2CD              XXD2CD = *
05193  D2CD  C6 59              DEC     XX59          ; DECREMENT ARRAY PO
INTER HIGH BYTE
05194  D2CF  C6 72              DEC     XX72          ; DECREMENT BLOCK CO
UNT HIGH BYTE
05195  D2D1  D0 F5              BNE     XXD2C8          ; LOOP UNTIL ALL B
LOCKS DONE
05196  D2D3                     
05197  D2D3  E6 59              INC     XX59          ; CORRECT FOR LAST L
OOP
05198  D2D5  38                 SEC                    ; SET CARRY FOR SUB
TRACT
05199  D2D6  A5 31              LDA     XX31          ; GET END OF ARRAYS 
LOW BYTE
05200  D2D8  E5 5F              SBC     XX5F          ; SUBTRACT ARRAY STA
RT LOW BYTE
05201  D2DA  A0 02              LDY     #$02               ; INDEX TO ARRA
Y SIZE LOW BYTE
05202  D2DC  91 5F              STA     (XX5F),Y          ; SAVE ARRAY SIZ
E LOW BYTE
05203  D2DE  A5 32              LDA     XX32          ; GET END OF ARRAYS 
HIGH BYTE
05204  D2E0  C8                 INY                    ; INDEX TO ARRAY SI
ZE HIGH BYTE
05205  D2E1  E5 60              SBC     XX60          ; SUBTRACT ARRAY STA
RT HIGH BYTE
05206  D2E3  91 5F              STA     (XX5F),Y          ; SAVE ARRAY SIZ
E HIGH BYTE
05207  D2E5  A5 0C              LDA     XX0C          ; GET DEFAULT DIM FL
AG
05208  D2E7  D0 62              BNE     XXD34B          ; EXIT IF THIS WAS
 A DIM COMMAND
05209  D2E9                     
05210  D2E9                                     ; ELSE, FIND ELEMENT
05211  D2E9  C8                 INY                    ; SET INDEX TO # OF
 DIMENSIONS, THE DIMENSION INDECES
05212  D2EA                                     ; ARE ON THE STACK AND WIL
L BE REMOVED AS THE POSITION
05213  D2EA                                     ; OF THE ARRAY ELEMENT IS 
CALCULATED






SNO RO......PAGE 0098

LINE# LOC   CODE        LINE


05214  D2EA                     
05215  D2EA              XXD2EA = *
05216  D2EA  B1 5F              LDA     (XX5F),Y          ; GET ARRAY'S DI
MENSION COUNT
05217  D2EC  85 0B              STA     XX0B          ; SAVE IT
05218  D2EE  A9 00              LDA     #$00               ; CLEAR BYTE
05219  D2F0  85 71              STA     XX71          ; CLEAR ARRAY DATA P
OINTER LOW BYTE
05220  D2F2              XXD2F2 = *
05221  D2F2  85 72              STA     XX72          ; SAVE ARRAY DATA PO
INTER HIGH BYTE
05222  D2F4  C8                 INY                    ; INCREMENT INDEX, 
POINT TO ARRAY BOUND HIGH BYTE
05223  D2F5  68                 PLA                    ; PULL ARRAY INDEX 
LOW BYTE
05224  D2F6  AA                 TAX                    ; COPY TO X
05225  D2F7  85 64              STA     XX64          ; SAVE INDEX LOW BYT
E TO FAC1 MANTISSA 3
05226  D2F9  68                 PLA                    ; PULL ARRAY INDEX 
HIGH BYTE
05227  D2FA  85 65              STA     XX65          ; SAVE INDEX HIGH BY
TE TO FAC1 MANTISSA 4
05228  D2FC  D1 5F              CMP     (XX5F),Y          ; COMPARE WITH A
RRAY BOUND HIGH BYTE
05229  D2FE  90 0E              BCC     XXD30E          ; IF WITHIN BOUNDS
 CONTINUE
05230  D300                     
05231  D300  D0 06              BNE     XXD308          ; IF OUTSIDE BOUND
S DO BAD SUBSCRIPT ERROR
05232  D302                     
05233  D302                                     ; ELSE HIGH BYTE WAS = SO 
TEST LOW BYTES
05234  D302  C8                 INY                    ; INDEX TO ARRAY BO
UND LOW BYTE
05235  D303  8A                 TXA                    ; GET ARRAY INDEX L
OW BYTE
05236  D304  D1 5F              CMP     (XX5F),Y          ; COMPARE WITH A
RRAY BOUND LOW BYTE
05237  D306  90 07              BCC     XXD30F          ; IF WITHIN BOUNDS
 CONTINUE
05238  D308                     
05239  D308              XXD308 = *
05240  D308  4C 45 D2           JMP     XXD245          ; DO BAD SUBSCRIPT
 ERROR
05241  D30B                     
05242  D30B              XXD30B = *
05243  D30B  4C 35 C4           JMP     XXC435          ; DO OUT OF MEMORY
 ERROR THEN WARM START
05244  D30E                     
05245  D30E              XXD30E = *
05246  D30E  C8                 INY                    ; INDEX TO ARRAY BO
UND LOW BYTE
05247  D30F              XXD30F = *
05248  D30F  A5 72              LDA     XX72          ; GET ARRAY DATA POI
NTER HIGH BYTE
05249  D311  05 71              ORA     XX71          ; OR WITH ARRAY DATA
 POINTER LOW BYTE
05250  D313  18                 CLC                    ; CLEAR CARRY FOR E
ITHER ADD, CARRY ALWAYS CLEAR HERE ??
05251  D314  F0 0A              BEQ     XXD320          ; IF ARRAY DATA PO
INTER = NULL SKIP THE MULTIPLY
05252  D316                     
05253  D316  20 4C D3           JSR     XXD34C          ; COMPUTE ARRAY SI
ZE
05254  D319  8A                 TXA                    ; GET RESULT LOW BY
TE
05255  D31A  65 64              ADC     XX64          ; ADD INDEX LOW BYTE
 FROM FAC1 MANTISSA 3
05256  D31C  AA                 TAX                    ; SAVE RESULT LOW B
YTE
05257  D31D  98                 TYA                    ; GET RESULT HIGH B
YTE
05258  D31E  A4 22              LDY     XX22          ; RESTORE INDEX
05259  D320              XXD320 = *
05260  D320  65 65              ADC     XX65          ; ADD INDEX HIGH BYT
E FROM FAC1 MANTISSA 4
05261  D322  86 71              STX     XX71          ; SAVE ARRAY DATA PO
INTER LOW BYTE
05262  D324  C6 0B              DEC     XX0B          ; DECREMENT DIMENSIO
NS COUNT
05263  D326  D0 CA              BNE     XXD2F2          ; LOOP IF DIMENSIO
NS STILL TO DO
05264  D328                     
05265  D328  85 72              STA     XX72          ; SAVE ARRAY DATA PO
INTER HIGH BYTE
05266  D32A  A2 05              LDX     #$05               ; SET DEFAULT E
LEMENT SIZE
05267  D32C  A5 45              LDA     XX45          ; GET VARIABLE NAME 
1ST BYTE
05268  D32E  10 01              BPL     XXD331          ; BRANCH IF NOT ST
RING OR FLOATING POINT ARRAY






E ??RO......PAGE 0099

LINE# LOC   CODE        LINE


05269  D330                     
05270  D330  CA                 DEX                    ; DECREMENT ELEMENT
 SIZE, $04
05271  D331              XXD331 = *
05272  D331  A5 46              LDA     XX46          ; GET VARIABLE NAME 
2ND BYTE
05273  D333  10 02              BPL     XXD337          ; BRANCH IF NOT IN
TEGER OR STRING
05274  D335                     
05275  D335  CA                 DEX                    ; DECREMENT ELEMENT
 SIZE, $03
05276  D336  CA                 DEX                    ; DECREMENT ELEMENT
 SIZE, $02
05277  D337              XXD337 = *
05278  D337  86 28              STX     XX28          ; SAVE DIMENSION SIZ
E LOW BYTE
05279  D339  A9 00              LDA     #$00               ; CLEAR DIMENSI
ON SIZE HIGH BYTE
05280  D33B  20 55 D3           JSR     XXD355          ; COMPUTE ARRAY SI
ZE
05281  D33E  8A                 TXA                    ; COPY ARRAY SIZE L
OW BYTE
05282  D33F  65 58              ADC     XX58          ; ADD ARRAY DATA STA
RT POINTER LOW BYTE
05283  D341  85 47              STA     XX47          ; SAVE AS CURRENT VA
RIABLE POINTER LOW BYTE
05284  D343  98                 TYA                    ; COPY ARRAY SIZE H
IGH BYTE
05285  D344  65 59              ADC     XX59          ; ADD ARRAY DATA STA
RT POINTER HIGH BYTE
05286  D346  85 48              STA     XX48          ; SAVE AS CURRENT VA
RIABLE POINTER HIGH BYTE
05287  D348  A8                 TAY                    ; COPY HIGH BYTE TO
 Y
05288  D349  A5 47              LDA     XX47          ; GET CURRENT VARIAB
LE POINTER LOW BYTE
05289  D34B                                     ; POINTER TO ELEMENT IS NO
W IN AY
05290  D34B              XXD34B = *
05291  D34B  60                 RTS
05292  D34C                     
05293  D34C                     
05294  D34C              ;************************************************
***********************************;
05295  D34C              ;
05296  D34C              ; COMPUTE ARRAY SIZE, RESULT IN XY
05297  D34C              
05298  D34C              XXD34C = *
05299  D34C  84 22              STY     XX22          ; SAVE INDEX
05300  D34E  B1 5F              LDA     (XX5F),Y          ; GET DIMENSION 
SIZE LOW BYTE
05301  D350  85 28              STA     XX28          ; SAVE DIMENSION SIZ
E LOW BYTE
05302  D352  88                 DEY                    ; DECREMENT INDEX
05303  D353  B1 5F              LDA     (XX5F),Y          ; GET DIMENSION 
SIZE HIGH BYTE
05304  D355              XXD355 = *
05305  D355  85 29              STA     XX29          ; SAVE DIMENSION SIZ
E HIGH BYTE
05306  D357  A9 10              LDA     #$10               ; COUNT = $10 (
16 BIT MULTIPLY)
05307  D359  85 5D              STA     XX5D          ; SAVE BIT COUNT
05308  D35B  A2 00              LDX     #$00               ; CLEAR RESULT 
LOW BYTE
05309  D35D  A0 00              LDY     #$00               ; CLEAR RESULT 
HIGH BYTE
05310  D35F              XXD35F = *
05311  D35F  8A                 TXA                    ; GET RESULT LOW BY
TE
05312  D360  0A                 ASL A                  ; *2
05313  D361  AA                 TAX                    ; SAVE RESULT LOW B
YTE
05314  D362  98                 TYA                    ; GET RESULT HIGH B
YTE
05315  D363  2A                 ROL A                  ; *2
05316  D364  A8                 TAY                    ; SAVE RESULT HIGH 
BYTE
05317  D365  B0 A4              BCS     XXD30B          ; IF OVERFLOW GO D
O 'OUT OF MEMORY' ERROR
05318  D367                     
05319  D367  06 71              ASL     XX71          ; SHIFT ELEMENT SIZE
 LOW BYTE
05320  D369  26 72              ROL     XX72          ; SHIFT ELEMENT SIZE
 HIGH BYTE
05321  D36B  90 0B              BCC     XXD378          ; SKIP ADD IF NO C
ARRY
05322  D36D                     
05323  D36D  18                 CLC                    ; ELSE CLEAR CARRY 
FOR ADD






****;O......PAGE 0100

LINE# LOC   CODE        LINE


05324  D36E  8A                 TXA                    ; GET RESULT LOW BY
TE
05325  D36F  65 28              ADC     XX28          ; ADD DIMENSION SIZE
 LOW BYTE
05326  D371  AA                 TAX                    ; SAVE RESULT LOW B
YTE
05327  D372  98                 TYA                    ; GET RESULT HIGH B
YTE
05328  D373  65 29              ADC     XX29          ; ADD DIMENSION SIZE
 HIGH BYTE
05329  D375  A8                 TAY                    ; SAVE RESULT HIGH 
BYTE
05330  D376  B0 93              BCS     XXD30B          ; IF OVERFLOW GO D
O 'OUT OF MEMORY' ERROR
05331  D378                     
05332  D378              XXD378 = *
05333  D378  C6 5D              DEC     XX5D          ; DECREMENT BIT COUN
T
05334  D37A  D0 E3              BNE     XXD35F          ; LOOP UNTIL ALL D
ONE
05335  D37C                     
05336  D37C  60                 RTS
05337  D37D                     
05338  D37D                     
05339  D37D              ;************************************************
***********************************;
05340  D37D              ;
05341  D37D              ; PERFORM FRE()
05342  D37D              
05343  D37D              XXD37D = *
05344  D37D  A5 0D              LDA     XX0D          ; GET DATA TYPE FLAG
, $FF = STRING, $00 = NUMERIC
05345  D37F  F0 03              BEQ     XXD384          ; IF NUMERIC DON'T
 POP THE STRING
05346  D381                     
05347  D381  20 A6 D6           JSR     XXD6A6          ; POP STRING OFF D
ESCRIPTOR STACK, OR FROM TOP OF STRING
05348  D384                                     ; SPACE RETURNS WITH A = L
ENGTH, X=$71=POINTER LOW BYTE,
05349  D384                                     ; Y=$72=POINTER HIGH BYTE
05350  D384                     
05351  D384                                     ; FRE(N) WAS NUMERIC SO DO
 THIS
05352  D384              XXD384 = *
05353  D384  20 26 D5           JSR     XXD526          ; GO DO GARBAGE CO
LLECTION
05354  D387  38                 SEC                    ; SET CARRY FOR SUB
TRACT
05355  D388  A5 33              LDA     XX33          ; GET BOTTOM OF STRI
NG SPACE LOW BYTE
05356  D38A  E5 31              SBC     XX31          ; SUBTRACT END OF AR
RAYS LOW BYTE
05357  D38C  A8                 TAY                    ; COPY RESULT TO Y
05358  D38D  A5 34              LDA     XX34          ; GET BOTTOM OF STRI
NG SPACE HIGH BYTE
05359  D38F  E5 32              SBC     XX32          ; SUBTRACT END OF AR
RAYS HIGH BYTE
05360  D391                     
05361  D391                     
05362  D391              ;************************************************
***********************************;
05363  D391              ;
05364  D391              ; CONVERT FIXED INTEGER AY TO FLOAT FAC1
05365  D391              
05366  D391              XXD391 = *
05367  D391  A2 00              LDX     #$00               ; SET TYPE = NU
MERIC
05368  D393  86 0D              STX     XX0D          ; CLEAR DATA TYPE FL
AG, $FF = STRING, $00 = NUMERIC
05369  D395  85 62              STA     XX62          ; SAVE FAC1 MANTISSA
 1
05370  D397  84 63              STY     XX63          ; SAVE FAC1 MANTISSA
 2
05371  D399  A2 90              LDX     #$90               ; SET EXPONENT=
2^16 (INTEGER)
05372  D39B  4C 44 DC           JMP     XXDC44          ; SET EXP = X, CLE
AR FAC1 3 AND 4, NORMALISE AND RETURN
05373  D39E                     
05374  D39E                     
05375  D39E              ;************************************************
***********************************;
05376  D39E              ;
05377  D39E              ; PERFORM POS()
05378  D39E              






****;O......PAGE 0101

LINE# LOC   CODE        LINE


05379  D39E              XXD39E = *
05380  D39E  38                 SEC                    ; SET CB FOR READ C
URSOR POSITION
05381  D39F  20 F0 FF           JSR     XXFFF0          ; READ/SET X,Y CUR
SOR POSITION
05382  D3A2              XXD3A2 = *
05383  D3A2  A9 00              LDA     #$00               ; CLEAR HIGH BY
TE
05384  D3A4  F0 EB              BEQ     XXD391          ; CONVERT FIXED IN
TEGER AY TO FLOAT FAC1, BRANCH ALWAYS
05385  D3A6                     
05386  D3A6                     
05387  D3A6              ;************************************************
***********************************;
05388  D3A6              ;
05389  D3A6              ; CHECK NOT DIRECT, USED BY DEF AND INPUT
05390  D3A6              
05391  D3A6              XXD3A6 = *
05392  D3A6  A6 3A              LDX     XX3A          ; GET CURRENT LINE N
UMBER HIGH BYTE
05393  D3A8  E8                 INX                    ; INCREMENT IT
05394  D3A9  D0 A0              BNE     XXD34B          ; RETURN IF NOT DI
RECT MODE
05395  D3AB                     
05396  D3AB                                     ; ELSE DO ILLEGAL DIRECT E
RROR
05397  D3AB  A2 15              LDX     #$15               ; ERROR $15, IL
LEGAL DIRECT ERROR
05398  D3AD  2C                 .BYTE     $2C               ; MAKES NEXT L
INE BIT XX1BA2
05399  D3AE              XXD3AE = *
05400  D3AE  A2 1B              LDX     #$1B               ; ERROR $1B, UN
DEFINED FUNCTION ERROR
05401  D3B0  4C 37 C4           JMP     XXC437          ; DO ERROR #X THEN
 WARM START
05402  D3B3                     
05403  D3B3                     
05404  D3B3              ;************************************************
***********************************;
05405  D3B3              ;
05406  D3B3              ; PERFORM DEF
05407  D3B3              
05408  D3B3              XXD3B3 = *
05409  D3B3  20 E1 D3           JSR     XXD3E1          ; CHECK FNX SYNTAX

05410  D3B6  20 A6 D3           JSR     XXD3A6          ; CHECK NOT DIRECT
, BACK HERE IF OK
05411  D3B9  20 FA CE           JSR     XXCEFA          ; SCAN FOR '(', EL
SE DO SYNTAX ERROR THEN WARM START
05412  D3BC  A9 80              LDA     #$80               ; SET FLAG FOR 
FNX
05413  D3BE  85 10              STA     XX10          ; SAVE SUBSCRIPT/FNX
 FLAG
05414  D3C0  20 8B D0           JSR     XXD08B          ; GET VARIABLE ADD
RESS
05415  D3C3  20 8D CD           JSR     XXCD8D          ; CHECK IF SOURCE 
IS NUMERIC, ELSE DO TYPE MISMATCH
05416  D3C6  20 F7 CE           JSR     XXCEF7          ; SCAN FOR ')', EL
SE DO SYNTAX ERROR THEN WARM START
05417  D3C9  A9 B2              LDA     #TEQUAL          ; GET = TOKEN
05418  D3CB  20 FF CE           JSR     XXCEFF          ; SCAN FOR CHR$(A)
, ELSE DO SYNTAX ERROR THEN WARM START
05419  D3CE  48                 PHA                    ; PUSH NEXT CHARACT
ER
05420  D3CF  A5 48              LDA     XX48          ; GET CURRENT VARIAB
LE POINTER HIGH BYTE
05421  D3D1  48                 PHA                    ; PUSH IT
05422  D3D2  A5 47              LDA     XX47          ; GET CURRENT VARIAB
LE POINTER LOW BYTE
05423  D3D4  48                 PHA                    ; PUSH IT
05424  D3D5  A5 7B              LDA     XX7B          ; GET BASIC EXECUTE 
POINTER HIGH BYTE
05425  D3D7  48                 PHA                    ; PUSH IT
05426  D3D8  A5 7A              LDA     XX7A          ; GET BASIC EXECUTE 
POINTER LOW BYTE
05427  D3DA  48                 PHA                    ; PUSH IT
05428  D3DB  20 F8 C8           JSR     XXC8F8          ; PERFORM DATA
05429  D3DE  4C 4F D4           JMP     XXD44F          ; PUT EXECUTE POIN
TER AND VARIABLE POINTER INTO FUNCTION
05430  D3E1                                     ; AND RETURN
05431  D3E1                     
05432  D3E1                     
05433  D3E1              ;************************************************
***********************************;






****;O......PAGE 0102

LINE# LOC   CODE        LINE


05434  D3E1              ;
05435  D3E1              ; CHECK FNX SYNTAX
05436  D3E1              
05437  D3E1              XXD3E1 = *
05438  D3E1  A9 A5              LDA     #TFN          ; SET FN TOKEN
05439  D3E3  20 FF CE           JSR     XXCEFF          ; SCAN FOR CHR$(A)
, ELSE DO SYNTAX ERROR THEN WARM START
05440  D3E6  09 80              ORA     #$80               ; SET FN FLAG B
IT
05441  D3E8  85 10              STA     XX10          ; SAVE FN NAME
05442  D3EA  20 92 D0           JSR     XXD092          ; SEARCH FOR FN VA
RIABLE
05443  D3ED  85 4E              STA     XX4E          ; SAVE FUNCTION POIN
TER LOW BYTE
05444  D3EF  84 4F              STY     XX4F          ; SAVE FUNCTION POIN
TER HIGH BYTE
05445  D3F1  4C 8D CD           JMP     XXCD8D          ; CHECK IF SOURCE 
IS NUMERIC AND RETURN, ELSE DO TYPE
05446  D3F4                                     ; MISMATCH
05447  D3F4                     
05448  D3F4                     
05449  D3F4              ;************************************************
***********************************;
05450  D3F4              ;
05451  D3F4              ; EVALUATE FNX
05452  D3F4              
05453  D3F4              XXD3F4 = *
05454  D3F4  20 E1 D3           JSR     XXD3E1          ; CHECK FNX SYNTAX

05455  D3F7  A5 4F              LDA     XX4F          ; GET FUNCTION POINT
ER HIGH BYTE
05456  D3F9  48                 PHA                    ; PUSH IT
05457  D3FA  A5 4E              LDA     XX4E          ; GET FUNCTION POINT
ER LOW BYTE
05458  D3FC  48                 PHA                    ; PUSH IT
05459  D3FD  20 F1 CE           JSR     XXCEF1          ; EVALUATE EXPRESS
ION WITHIN PARENTHESES
05460  D400  20 8D CD           JSR     XXCD8D          ; CHECK IF SOURCE 
IS NUMERIC, ELSE DO TYPE MISMATCH
05461  D403  68                 PLA                    ; POP FUNCTION POIN
TER LOW BYTE
05462  D404  85 4E              STA     XX4E          ; RESTORE IT
05463  D406  68                 PLA                    ; POP FUNCTION POIN
TER HIGH BYTE
05464  D407  85 4F              STA     XX4F          ; RESTORE IT
05465  D409  A0 02              LDY     #$02               ; INDEX TO VARI
ABLE POINTER HIGH BYTE
05466  D40B  B1 4E              LDA     (XX4E),Y          ; GET VARIABLE A
DDRESS LOW BYTE
05467  D40D  85 47              STA     XX47          ; SAVE CURRENT VARIA
BLE POINTER LOW BYTE
05468  D40F  AA                 TAX                    ; COPY ADDRESS LOW 
BYTE
05469  D410  C8                 INY                    ; INDEX TO VARIABLE
 ADDRESS HIGH BYTE
05470  D411  B1 4E              LDA     (XX4E),Y          ; GET VARIABLE P
OINTER HIGH BYTE
05471  D413  F0 99              BEQ     XXD3AE          ; IF HIGH BYTE ZER
O GO DO UNDEFINED FUNCTION ERROR
05472  D415                     
05473  D415  85 48              STA     XX48          ; SAVE CURRENT VARIA
BLE POINTER HIGH BYTE
05474  D417  C8                 INY                    ; INDEX TO MANTISSA
 3
05475  D418                     
05476  D418                                     ; NOW STACK THE FUNCTION V
ARIABLE VALUE BEFORE USE
05477  D418              XXD418 = *
05478  D418  B1 47              LDA     (XX47),Y          ; GET BYTE FROM 
VARIABLE
05479  D41A  48                 PHA                    ; STACK IT
05480  D41B  88                 DEY                    ; DECREMENT INDEX
05481  D41C  10 FA              BPL     XXD418          ; LOOP UNTIL VARIA
BLE STACKED
05482  D41E                     
05483  D41E  A4 48              LDY     XX48          ; GET CURRENT VARIAB
LE POINTER HIGH BYTE
05484  D420  20 D4 DB           JSR     XXDBD4          ; PACK FAC1 INTO (
XY)
05485  D423  A5 7B              LDA     XX7B          ; GET BASIC EXECUTE 
POINTER HIGH BYTE
05486  D425  48                 PHA                    ; PUSH IT
05487  D426  A5 7A              LDA     XX7A          ; GET BASIC EXECUTE 
POINTER LOW BYTE
05488  D428  48                 PHA                    ; PUSH IT






****;O......PAGE 0103

LINE# LOC   CODE        LINE


05489  D429  B1 4E              LDA     (XX4E),Y          ; GET FUNCTION E
XECUTE POINTER LOW BYTE
05490  D42B  85 7A              STA     XX7A          ; SAVE BASIC EXECUTE
 POINTER LOW BYTE
05491  D42D  C8                 INY                    ; INDEX TO HIGH BYT
E
05492  D42E  B1 4E              LDA     (XX4E),Y          ; GET FUNCTION E
XECUTE POINTER HIGH BYTE
05493  D430  85 7B              STA     XX7B          ; SAVE BASIC EXECUTE
 POINTER HIGH BYTE
05494  D432  A5 48              LDA     XX48          ; GET CURRENT VARIAB
LE POINTER HIGH BYTE
05495  D434  48                 PHA                    ; PUSH IT
05496  D435  A5 47              LDA     XX47          ; GET CURRENT VARIAB
LE POINTER LOW BYTE
05497  D437  48                 PHA                    ; PUSH IT
05498  D438  20 8A CD           JSR     XXCD8A          ; EVALUATE EXPRESS
ION AND CHECK IS NUMERIC, ELSE DO
05499  D43B                                     ; TYPE MISMATCH
05500  D43B  68                 PLA                    ; PULL VARIABLE ADD
RESS LOW BYTE
05501  D43C  85 4E              STA     XX4E          ; SAVE VARIABLE ADDR
ESS LOW BYTE
05502  D43E  68                 PLA                    ; PULL VARIABLE ADD
RESS HIGH BYTE
05503  D43F  85 4F              STA     XX4F          ; SAVE VARIABLE ADDR
ESS HIGH BYTE
05504  D441  20 79 00           JSR     XX0079          ; SCAN MEMORY
05505  D444  F0 03              BEQ     XXD449          ; IF NULL (SHOULD 
BE [EOL] MARKER) CONTINUE
05506  D446                     
05507  D446  4C 08 CF           JMP     XXCF08          ; ELSE SYNTAX ERRO
R THEN WARM START
05508  D449                     
05509  D449              ; RESTORE BASIC EXECUTE POINTER AND FUNCTION VARI
ABLE FROM STACK
05510  D449              
05511  D449              XXD449 = *
05512  D449  68                 PLA                    ; PULL BASIC EXECUT
E POINTER LOW BYTE
05513  D44A  85 7A              STA     XX7A          ; SAVE BASIC EXECUTE
 POINTER LOW BYTE
05514  D44C  68                 PLA                    ; PULL BASIC EXECUT
E POINTER HIGH BYTE
05515  D44D  85 7B              STA     XX7B          ; SAVE BASIC EXECUTE
 POINTER HIGH BYTE
05516  D44F                     
05517  D44F              ; PUT EXECUTE POINTER AND VARIABLE POINTER INTO F
UNCTION
05518  D44F              
05519  D44F              XXD44F = *
05520  D44F  A0 00              LDY     #$00               ; CLEAR INDEX
05521  D451  68                 PLA                    ; PULL BASIC EXECUT
E POINTER LOW BYTE
05522  D452  91 4E              STA     (XX4E),Y          ; SAVE TO FUNCTI
ON
05523  D454  68                 PLA                    ; PULL BASIC EXECUT
E POINTER HIGH BYTE
05524  D455  C8                 INY                    ; INCREMENT INDEX
05525  D456  91 4E              STA     (XX4E),Y          ; SAVE TO FUNCTI
ON
05526  D458  68                 PLA                    ; PULL CURRENT VARI
ABLE ADDRESS LOW BYTE
05527  D459  C8                 INY                    ; INCREMENT INDEX
05528  D45A  91 4E              STA     (XX4E),Y          ; SAVE TO FUNCTI
ON
05529  D45C  68                 PLA                    ; PULL CURRENT VARI
ABLE ADDRESS HIGH BYTE
05530  D45D  C8                 INY                    ; INCREMENT INDEX
05531  D45E  91 4E              STA     (XX4E),Y          ; SAVE TO FUNCTI
ON
05532  D460  68                 PLA                    ; PULL ??
05533  D461  C8                 INY                    ; INCREMENT INDEX
05534  D462  91 4E              STA     (XX4E),Y          ; SAVE TO FUNCTI
ON
05535  D464  60                 RTS
05536  D465                     
05537  D465                     
05538  D465              ;************************************************
***********************************;
05539  D465              ;
05540  D465              ; PERFORM STR$()
05541  D465              
05542  D465              XXD465 = *
05543  D465  20 8D CD           JSR     XXCD8D          ; CHECK IF SOURCE 
IS NUMERIC, ELSE DO TYPE MISMATCH






****;O......PAGE 0104

LINE# LOC   CODE        LINE


05544  D468  A0 00              LDY     #$00               ; SET STRING IN
DEX
05545  D46A  20 DF DD           JSR     XXDDDF          ; CONVERT FAC1 TO 
STRING
05546  D46D  68                 PLA                    ; DUMP RETURN ADDRE
SS (SKIP TYPE CHECK)
05547  D46E  68                 PLA                    ; DUMP RETURN ADDRE
SS (SKIP TYPE CHECK)
05548  D46F              XXD46F = *
05549  D46F  A9 FF              LDA     #<XX00FF          ; SET RESULT STR
ING LOW POINTER
05550  D471  A0 00              LDY     #>XX00FF          ; SET RESULT STR
ING HIGH POINTER
05551  D473  F0 12              BEQ     XXD487          ; PRINT NULL TERMI
NATED STRING TO UTILITY POINTER
05552  D475                     
05553  D475                     
05554  D475              ;************************************************
***********************************;
05555  D475              ;
05556  D475              ; DO STRING VECTOR
05557  D475              ; COPY DESCRIPTOR POINTER AND MAKE STRING SPACE A
 BYTES LONG
05558  D475              
05559  D475              XXD475 = *
05560  D475  A6 64              LDX     XX64          ; GET DESCRIPTOR POI
NTER LOW BYTE
05561  D477  A4 65              LDY     XX65          ; GET DESCRIPTOR POI
NTER HIGH BYTE
05562  D479  86 50              STX     XX50          ; SAVE DESCRIPTOR PO
INTER LOW BYTE
05563  D47B  84 51              STY     XX51          ; SAVE DESCRIPTOR PO
INTER HIGH BYTE
05564  D47D                     
05565  D47D                     
05566  D47D              ;************************************************
***********************************;
05567  D47D              ;
05568  D47D              ; MAKE STRING SPACE A BYTES LONG
05569  D47D              
05570  D47D              XXD47D = *
05571  D47D  20 F4 D4           JSR     XXD4F4          ; MAKE SPACE IN ST
RING MEMORY FOR STRING A LONG
05572  D480  86 62              STX     XX62          ; SAVE STRING POINTE
R LOW BYTE
05573  D482  84 63              STY     XX63          ; SAVE STRING POINTE
R HIGH BYTE
05574  D484  85 61              STA     XX61          ; SAVE LENGTH
05575  D486  60                 RTS
05576  D487                     
05577  D487                     
05578  D487              ;************************************************
***********************************;
05579  D487              ;
05580  D487              ; SCAN, SET UP STRING
05581  D487              ; PRINT ' TERMINATED STRING TO UTILITY POINTER
05582  D487              
05583  D487              XXD487 = *
05584  D487  A2 22              LDX     #$22               ; SET TERMINATO
R TO '
05585  D489  86 07              STX     XX07          ; SET SEARCH CHARACT
ER, TERMINATOR 1
05586  D48B  86 08              STX     XX08          ; SET TERMINATOR 2
05587  D48D                     
05588  D48D              ; PRINT SEARCH OR ALTERNATE TERMINATED STRING TO 
UTILITY POINTER
05589  D48D              ; SOURCE IS AY
05590  D48D              
05591  D48D              XXD48D = *
05592  D48D  85 6F              STA     XX6F          ; STORE STRING START
 LOW BYTE
05593  D48F  84 70              STY     XX70          ; STORE STRING START
 HIGH BYTE
05594  D491  85 62              STA     XX62          ; SAVE STRING POINTE
R LOW BYTE
05595  D493  84 63              STY     XX63          ; SAVE STRING POINTE
R HIGH BYTE
05596  D495  A0 FF              LDY     #$FF               ; SET LENGTH TO
 -1
05597  D497              XXD497 = *
05598  D497  C8                 INY                    ; INCREMENT LENGTH






****;O......PAGE 0105

LINE# LOC   CODE        LINE


05599  D498  B1 6F              LDA     (XX6F),Y          ; GET BYTE FROM 
STRING
05600  D49A  F0 0C              BEQ     XXD4A8          ; EXIT LOOP IF NUL
L BYTE [EOS]
05601  D49C                     
05602  D49C  C5 07              CMP     XX07          ; COMPARE WITH SEARC
H CHARACTER, TERMINATOR 1
05603  D49E  F0 04              BEQ     XXD4A4          ; BRANCH IF TERMIN
ATOR
05604  D4A0                     
05605  D4A0  C5 08              CMP     XX08          ; COMPARE WITH TERMI
NATOR 2
05606  D4A2  D0 F3              BNE     XXD497          ; LOOP IF NOT TERM
INATOR 2
05607  D4A4                     
05608  D4A4              XXD4A4 = *
05609  D4A4  C9 22              CMP     #$22               ; COMPARE WITH 
'
05610  D4A6  F0 01              BEQ     XXD4A9          ; BRANCH IF ' (CAR
RY SET IF = !)
05611  D4A8                     
05612  D4A8              XXD4A8 = *
05613  D4A8  18                 CLC                    ; CLEAR CARRY FOR A
DD (ONLY IF [EOL] TERMINATED STRING)
05614  D4A9              XXD4A9 = *
05615  D4A9  84 61              STY     XX61          ; SAVE LENGTH IN FAC
1 EXPONENT
05616  D4AB  98                 TYA                    ; COPY LENGTH TO A
05617  D4AC  65 6F              ADC     XX6F          ; ADD STRING START L
OW BYTE
05618  D4AE  85 71              STA     XX71          ; SAVE STRING END LO
W BYTE
05619  D4B0  A6 70              LDX     XX70          ; GET STRING START H
IGH BYTE
05620  D4B2  90 01              BCC     XXD4B5          ; IF NO LOW BYTE O
VERFLOW SKIP THE HIGH BYTE INCREMENT
05621  D4B4                     
05622  D4B4  E8                 INX                    ; ELSE INCREMENT HI
GH BYTE
05623  D4B5              XXD4B5 = *
05624  D4B5  86 72              STX     XX72          ; SAVE STRING END HI
GH BYTE
05625  D4B7  A5 70              LDA     XX70          ; GET STRING START H
IGH BYTE
05626  D4B9  F0 04              BEQ     XXD4BF          ; BRANCH IF IN UTI
LITY AREA
05627  D4BB                     
05628  D4BB  C9 02              CMP     #$02               ; COMPARE WITH 
INPUT BUFFER MEMORY HIGH BYTE
05629  D4BD  D0 0B              BNE     XXD4CA          ; BRANCH IF NOT IN
 INPUT BUFFER MEMORY
05630  D4BF                     
05631  D4BF                                     ; STRING IN INPUT BUFFER O
R UTILITY AREA, MOVE TO STRING
05632  D4BF                                     ; MEMORY
05633  D4BF              XXD4BF = *
05634  D4BF  98                 TYA                    ; COPY LENGTH TO A
05635  D4C0  20 75 D4           JSR     XXD475          ; COPY DESCRIPTOR 
POINTER AND MAKE STRING SPACE A BYTES LONG
05636  D4C3  A6 6F              LDX     XX6F          ; GET STRING START L
OW BYTE
05637  D4C5  A4 70              LDY     XX70          ; GET STRING START H
IGH BYTE
05638  D4C7  20 88 D6           JSR     XXD688          ; STORE STRING A B
YTES LONG FROM XY TO UTILITY POINTER
05639  D4CA                     
05640  D4CA              ; CHECK FOR SPACE ON DESCRIPTOR STACK THEN ...
05641  D4CA              ; PUT STRING ADDRESS AND LENGTH ON DESCRIPTOR STA
CK AND UPDATE STACK POINTERS
05642  D4CA              
05643  D4CA              XXD4CA = *
05644  D4CA  A6 16              LDX     XX16          ; GET DESCRIPTOR STA
CK POINTER
05645  D4CC  E0 22              CPX     #$22               ; COMPARE WITH 
MAX+1
05646  D4CE  D0 05              BNE     XXD4D5          ; BRANCH IF SPACE 
ON STRING STACK
05647  D4D0                     
05648  D4D0                                     ; ELSE DO STRING TOO COMPL
EX ERROR
05649  D4D0  A2 19              LDX     #$19               ; ERROR $19, ST
RING TOO COMPLEX ERROR
05650  D4D2              XXD4D2 = *
05651  D4D2  4C 37 C4           JMP     XXC437          ; DO ERROR #X THEN
 WARM START
05652  D4D5                     
05653  D4D5              ; PUT STRING ADDRESS AND LENGTH ON DESCRIPTOR STA
CK AND UPDATE STACK POINTERS






TERS L......PAGE 0106

LINE# LOC   CODE        LINE


05654  D4D5              
05655  D4D5              XXD4D5 = *
05656  D4D5  A5 61              LDA     XX61          ; GET STRING LENGTH
05657  D4D7  95 00              STA     XX00,X          ; PUT ON STRING ST
ACK
05658  D4D9  A5 62              LDA     XX62          ; GET STRING POINTER
 LOW BYTE
05659  D4DB  95 01              STA     XX01,X          ; PUT ON STRING ST
ACK
05660  D4DD  A5 63              LDA     XX63          ; GET STRING POINTER
 HIGH BYTE
05661  D4DF  95 02              STA     XX02,X          ; PUT ON STRING ST
ACK
05662  D4E1  A0 00              LDY     #$00               ; CLEAR Y
05663  D4E3  86 64              STX     XX64          ; SAVE STRING DESCRI
PTOR POINTER LOW BYTE
05664  D4E5  84 65              STY     XX65          ; SAVE STRING DESCRI
PTOR POINTER HIGH BYTE, ALWAYS $00
05665  D4E7  84 70              STY     XX70          ; CLEAR FAC1 ROUNDIN
G BYTE
05666  D4E9  88                 DEY                    ; Y = $FF
05667  D4EA  84 0D              STY     XX0D          ; SAVE DATA TYPE FLA
G, $FF = STRING
05668  D4EC  86 17              STX     XX17          ; SAVE CURRENT DESCR
IPTOR STACK ITEM POINTER LOW BYTE
05669  D4EE  E8                 INX                    ; UPDATE STACK POIN
TER
05670  D4EF  E8                 INX                    ; UPDATE STACK POIN
TER
05671  D4F0  E8                 INX                    ; UPDATE STACK POIN
TER
05672  D4F1  86 16              STX     XX16          ; SET NEW DESCRIPTOR
 STACK POINTER
05673  D4F3  60                 RTS
05674  D4F4                     
05675  D4F4              ; MAKE SPACE IN STRING MEMORY FOR STRING A LONG
05676  D4F4              ; RETURN X = POINTER LOW BYTE, Y = POINTER HIGH B
YTE
05677  D4F4              
05678  D4F4              XXD4F4 = *
05679  D4F4  46 0F              LSR     XX0F          ; CLEAR GARBAGE COLL
ECTED FLAG (B7)
05680  D4F6                     
05681  D4F6                                     ; MAKE SPACE FOR STRING A 
LONG
05682  D4F6              XXD4F6 = *
05683  D4F6  48                 PHA                    ; SAVE STRING LENGT
H
05684  D4F7  49 FF              EOR     #$FF               ; COMPLEMENT IT

05685  D4F9  38                 SEC                    ; SET CARRY FOR SUB
TRACT, TWO'S COMPLEMENT ADD
05686  D4FA  65 33              ADC     XX33          ; ADD BOTTOM OF STRI
NG SPACE LOW BYTE, SUBTRACT LENGTH
05687  D4FC  A4 34              LDY     XX34          ; GET BOTTOM OF STRI
NG SPACE HIGH BYTE
05688  D4FE  B0 01              BCS     XXD501          ; SKIP DECREMENT I
F NO UNDERFLOW
05689  D500                     
05690  D500  88                 DEY                    ; DECREMENT BOTTOM 
OF STRING SPACE HIGH BYTE
05691  D501              XXD501 = *
05692  D501  C4 32              CPY     XX32          ; COMPARE WITH END O
F ARRAYS HIGH BYTE
05693  D503  90 11              BCC     XXD516          ; DO OUT OF MEMORY
 ERROR IF LESS
05694  D505                     
05695  D505  D0 04              BNE     XXD50B          ; IF NOT = SKIP NE
XT TEST
05696  D507                     
05697  D507  C5 31              CMP     XX31          ; COMPARE WITH END O
F ARRAYS LOW BYTE
05698  D509  90 0B              BCC     XXD516          ; DO OUT OF MEMORY
 ERROR IF LESS
05699  D50B                     
05700  D50B              XXD50B = *
05701  D50B  85 33              STA     XX33          ; SAVE BOTTOM OF STR
ING SPACE LOW BYTE
05702  D50D  84 34              STY     XX34          ; SAVE BOTTOM OF STR
ING SPACE HIGH BYTE
05703  D50F  85 35              STA     XX35          ; SAVE STRING UTILIT
Y PTR LOW BYTE
05704  D511  84 36              STY     XX36          ; SAVE STRING UTILIT
Y PTR HIGH BYTE
05705  D513  AA                 TAX                    ; COPY LOW BYTE TO 
X
05706  D514  68                 PLA                    ; GET STRING LENGTH
 BACK
05707  D515  60                 RTS
05708  D516                     






HERS L......PAGE 0107

LINE# LOC   CODE        LINE


05709  D516              XXD516 = *
05710  D516  A2 10              LDX     #$10               ; ERROR CODE $1
0, OUT OF MEMORY ERROR
05711  D518  A5 0F              LDA     XX0F          ; GET GARBAGE COLLEC
TED FLAG
05712  D51A  30 B6              BMI     XXD4D2          ; IF SET THEN DO E
RROR CODE X
05713  D51C                     
05714  D51C  20 26 D5           JSR     XXD526          ; ELSE GO DO GARBA
GE COLLECTION
05715  D51F  A9 80              LDA     #$80               ; FLAG FOR GARB
AGE COLLECTED
05716  D521  85 0F              STA     XX0F          ; SET GARBAGE COLLEC
TED FLAG
05717  D523  68                 PLA                    ; PULL LENGTH
05718  D524  D0 D0              BNE     XXD4F6          ; GO TRY AGAIN (LO
OP ALWAYS, LENGTH SHOULD NEVER BE = $00)
05719  D526                     
05720  D526                     
05721  D526              ;************************************************
***********************************;
05722  D526              ;
05723  D526              ; GARBAGE COLLECTION ROUTINE
05724  D526              
05725  D526              XXD526 = *
05726  D526  A6 37              LDX     XX37          ; GET END OF MEMORY 
LOW BYTE
05727  D528  A5 38              LDA     XX38          ; GET END OF MEMORY 
HIGH BYTE
05728  D52A                     
05729  D52A              ; RE-RUN ROUTINE FROM LAST ENDING
05730  D52A              
05731  D52A              XXD52A = *
05732  D52A  86 33              STX     XX33          ; SET BOTTOM OF STRI
NG SPACE LOW BYTE
05733  D52C  85 34              STA     XX34          ; SET BOTTOM OF STRI
NG SPACE HIGH BYTE
05734  D52E  A0 00              LDY     #$00               ; CLEAR INDEX
05735  D530  84 4F              STY     XX4F          ; CLEAR WORKING POIN
TER HIGH BYTE
05736  D532  84 4E              STY     XX4E          ; CLEAR WORKING POIN
TER LOW BYTE
05737  D534  A5 31              LDA     XX31          ; GET END OF ARRAYS 
LOW BYTE
05738  D536  A6 32              LDX     XX32          ; GET END OF ARRAYS 
HIGH BYTE
05739  D538  85 5F              STA     XX5F          ; SAVE AS HIGHEST UN
COLLECTED STRING POINTER LOW BYTE
05740  D53A  86 60              STX     XX60          ; SAVE AS HIGHEST UN
COLLECTED STRING POINTER HIGH BYTE
05741  D53C  A9 19              LDA     #XX19          ; SET DESCRIPTOR ST
ACK POINTER
05742  D53E  A2 00              LDX     #$00               ; CLEAR X
05743  D540  85 22              STA     XX22          ; SAVE DESCRIPTOR ST
ACK POINTER LOW BYTE
05744  D542  86 23              STX     XX23          ; SAVE DESCRIPTOR ST
ACK POINTER HIGH BYTE ($00)
05745  D544              XXD544 = *
05746  D544  C5 16              CMP     XX16          ; COMPARE WITH DESCR
IPTOR STACK POINTER
05747  D546  F0 05              BEQ     XXD54D          ; BRANCH IF =
05748  D548                     
05749  D548  20 C7 D5           JSR     XXD5C7          ; CHECK STRING SAL
VAGEABILITY
05750  D54B  F0 F7              BEQ     XXD544          ; LOOP ALWAYS
05751  D54D                     
05752  D54D                                     ; DONE STACKED STRINGS, NO
W DO STRING VARIABLES
05753  D54D              XXD54D = *
05754  D54D  A9 07              LDA     #$07               ; SET STEP SIZE
 = $07, COLLECTING VARIABLES
05755  D54F  85 53              STA     XX53          ; SAVE GARBAGE COLLE
CTION STEP SIZE
05756  D551  A5 2D              LDA     XX2D          ; GET START OF VARIA
BLES LOW BYTE
05757  D553  A6 2E              LDX     XX2E          ; GET START OF VARIA
BLES HIGH BYTE
05758  D555  85 22              STA     XX22          ; SAVE AS POINTER LO
W BYTE
05759  D557  86 23              STX     XX23          ; SAVE AS POINTER HI
GH BYTE
05760  D559              XXD559 = *
05761  D559  E4 30              CPX     XX30          ; COMPARE END OF VAR
IABLES HIGH BYTE,
05762  D55B                                     ; START OF ARRAYS HIGH BYT
E
05763  D55B  D0 04              BNE     XXD561          ; BRANCH IF NO HIG
H BYTE MATCH






E***;0......PAGE 0108

LINE# LOC   CODE        LINE


05764  D55D                     
05765  D55D  C5 2F              CMP     XX2F          ; ELSE COMPARE END O
F VARIABLES LOW BYTE,
05766  D55F                                     ; START OF ARRAYS LOW BYTE

05767  D55F  F0 05              BEQ     XXD566          ; BRANCH IF = VARI
ABLE MEMORY END
05768  D561                     
05769  D561              XXD561 = *
05770  D561  20 BD D5           JSR     XXD5BD          ; CHECK VARIABLE S
ALVAGEABILITY
05771  D564  F0 F3              BEQ     XXD559          ; LOOP ALWAYS
05772  D566                     
05773  D566                                     ; DONE STRING VARIABLES, N
OW DO STRING ARRAYS
05774  D566              XXD566 = *
05775  D566  85 58              STA     XX58          ; SAVE START OF ARRA
YS LOW BYTE AS WORKING POINTER
05776  D568  86 59              STX     XX59          ; SAVE START OF ARRA
YS HIGH BYTE AS WORKING POINTER
05777  D56A  A9 03              LDA     #$03               ; SET STEP SIZE
, COLLECTING DESCRIPTORS
05778  D56C  85 53              STA     XX53          ; SAVE STEP SIZE
05779  D56E              XXD56E = *
05780  D56E  A5 58              LDA     XX58          ; GET POINTER LOW BY
TE
05781  D570  A6 59              LDX     XX59          ; GET POINTER HIGH B
YTE
05782  D572              XXD572 = *
05783  D572  E4 32              CPX     XX32          ; COMPARE WITH END O
F ARRAYS HIGH BYTE
05784  D574  D0 07              BNE     XXD57D          ; BRANCH IF NOT AT
 END
05785  D576                     
05786  D576  C5 31              CMP     XX31          ; ELSE COMPARE WITH 
END OF ARRAYS LOW BYTE
05787  D578  D0 03              BNE     XXD57D          ; BRANCH IF NOT AT
 END
05788  D57A                     
05789  D57A  4C 06 D6           JMP     XXD606          ; COLLECT STRING, 
TIDY UP AND EXIT IF AT END ??
05790  D57D                     
05791  D57D              XXD57D = *
05792  D57D  85 22              STA     XX22          ; SAVE POINTER LOW B
YTE
05793  D57F  86 23              STX     XX23          ; SAVE POINTER HIGH 
BYTE
05794  D581  A0 00              LDY     #$00               ; SET INDEX
05795  D583  B1 22              LDA     (XX22),Y          ; GET ARRAY NAME
 FIRST BYTE
05796  D585  AA                 TAX                    ; COPY IT
05797  D586  C8                 INY                    ; INCREMENT INDEX
05798  D587  B1 22              LDA     (XX22),Y          ; GET ARRAY NAME
 SECOND BYTE
05799  D589  08                 PHP                    ; PUSH THE FLAGS
05800  D58A  C8                 INY                    ; INCREMENT INDEX
05801  D58B  B1 22              LDA     (XX22),Y          ; GET ARRAY SIZE
 LOW BYTE
05802  D58D  65 58              ADC     XX58          ; ADD START OF THIS 
ARRAY LOW BYTE
05803  D58F  85 58              STA     XX58          ; SAVE START OF NEXT
 ARRAY LOW BYTE
05804  D591  C8                 INY                    ; INCREMENT INDEX
05805  D592  B1 22              LDA     (XX22),Y          ; GET ARRAY SIZE
 HIGH BYTE
05806  D594  65 59              ADC     XX59          ; ADD START OF THIS 
ARRAY HIGH BYTE
05807  D596  85 59              STA     XX59          ; SAVE START OF NEXT
 ARRAY HIGH BYTE
05808  D598  28                 PLP                    ; RESTORE THE FLAGS

05809  D599  10 D3              BPL     XXD56E          ; SKIP IF NOT STRI
NG ARRAY
05810  D59B                     
05811  D59B              ; WAS POSSIBLY STRING ARRAY SO ...
05812  D59B              
05813  D59B  8A                 TXA                    ; GET NAME FIRST BY
TE BACK
05814  D59C  30 D0              BMI     XXD56E          ; SKIP IF NOT STRI
NG ARRAY
05815  D59E                     
05816  D59E  C8                 INY                    ; INCREMENT INDEX
05817  D59F  B1 22              LDA     (XX22),Y          ; GET # OF DIMEN
SIONS
05818  D5A1  A0 00              LDY     #$00               ; CLEAR INDEX






E***;0......PAGE 0109

LINE# LOC   CODE        LINE


05819  D5A3  0A                 ASL A                  ; *2
05820  D5A4  69 05              ADC     #$05               ; +5 (ARRAY HEA
DER SIZE)
05821  D5A6  65 22              ADC     XX22          ; ADD POINTER LOW BY
TE
05822  D5A8  85 22              STA     XX22          ; SAVE POINTER LOW B
YTE
05823  D5AA  90 02              BCC     XXD5AE          ; IF NO ROLLOVER S
KIP THE HIGH BYTE INCREMENT
05824  D5AC                     
05825  D5AC  E6 23              INC     XX23          ; ELSE INCREMENT POI
NTER HGIH BYTE
05826  D5AE              XXD5AE = *
05827  D5AE  A6 23              LDX     XX23          ; GET POINTER HIGH B
YTE
05828  D5B0              XXD5B0 = *
05829  D5B0  E4 59              CPX     XX59          ; COMPARE POINTER HI
GH BYTE WITH END OF THIS ARRAY HIGH BYTE
05830  D5B2  D0 04              BNE     XXD5B8          ; BRANCH IF NOT TH
ERE YET
05831  D5B4                     
05832  D5B4  C5 58              CMP     XX58          ; COMPARE POINTER LO
W BYTE WITH END OF THIS ARRAY LOW BYTE
05833  D5B6  F0 BA              BEQ     XXD572          ; IF AT END OF THI
S ARRAY GO CHECK NEXT ARRAY
05834  D5B8                     
05835  D5B8              XXD5B8 = *
05836  D5B8  20 C7 D5           JSR     XXD5C7          ; CHECK STRING SAL
VAGEABILITY
05837  D5BB  F0 F3              BEQ     XXD5B0          ; LOOP
05838  D5BD                     
05839  D5BD              ; CHECK VARIABLE SALVAGEABILITY
05840  D5BD              
05841  D5BD              XXD5BD = *
05842  D5BD  B1 22              LDA     (XX22),Y          ; GET VARIABLE N
AME FIRST BYTE
05843  D5BF  30 35              BMI     XXD5F6          ; ADD STEP AND EXI
T IF NOT STRING
05844  D5C1                     
05845  D5C1  C8                 INY                    ; INCREMENT INDEX
05846  D5C2  B1 22              LDA     (XX22),Y          ; GET VARIABLE N
AME SECOND BYTE
05847  D5C4  10 30              BPL     XXD5F6          ; ADD STEP AND EXI
T IF NOT STRING
05848  D5C6                     
05849  D5C6  C8                 INY                    ; INCREMENT INDEX
05850  D5C7                     
05851  D5C7              ; CHECK STRING SALVAGEABILITY
05852  D5C7              
05853  D5C7              XXD5C7 = *
05854  D5C7  B1 22              LDA     (XX22),Y          ; GET STRING LEN
GTH
05855  D5C9  F0 2B              BEQ     XXD5F6          ; ADD STEP AND EXI
T IF NULL STRING
05856  D5CB                     
05857  D5CB  C8                 INY                    ; INCREMENT INDEX
05858  D5CC  B1 22              LDA     (XX22),Y          ; GET STRING POI
NTER LOW BYTE
05859  D5CE  AA                 TAX                    ; COPY TO X
05860  D5CF  C8                 INY                    ; INCREMENT INDEX
05861  D5D0  B1 22              LDA     (XX22),Y          ; GET STRING POI
NTER HIGH BYTE
05862  D5D2  C5 34              CMP     XX34          ; COMPARE STRING POI
NTER HIGH BYTE WITH BOTTOM OF STRING
05863  D5D4                                     ; SPACE HIGH BYTE
05864  D5D4  90 06              BCC     XXD5DC          ; IF BOTTOM OF STR
ING SPACE GREATER GO TEST AGAINST HIGHEST
05865  D5D6                                     ; UNCOLLECTED STRING
05866  D5D6                     
05867  D5D6  D0 1E              BNE     XXD5F6          ; IF BOTTOM OF STR
ING SPACE LESS STRING HAS BEEN COLLECTED
05868  D5D8                                     ; SO GO UPDATE POINTERS, S
TEP TO NEXT AND RETURN
05869  D5D8                     
05870  D5D8                                     ; HIGH BYTES WERE EQUAL SO
 TEST LOW BYTES
05871  D5D8  E4 33              CPX     XX33          ; COMPARE STRING POI
NTER LOW BYTE WITH BOTTOM OF STRING
05872  D5DA                                     ; SPACE LOW BYTE
05873  D5DA  B0 1A              BCS     XXD5F6          ; IF BOTTOM OF STR
ING SPACE LESS STRING HAS BEEN COLLECTED






LLECTE......PAGE 0110

LINE# LOC   CODE        LINE


05874  D5DC                                     ; SO GO UPDATE POINTERS, S
TEP TO NEXT AND RETURN
05875  D5DC                     
05876  D5DC                                     ; ELSE TEST STRING AGAINST
 HIGHEST UNCOLLECTED STRING SO FAR
05877  D5DC              XXD5DC = *
05878  D5DC  C5 60              CMP     XX60          ; COMPARE STRING POI
NTER HIGH BYTE WITH HIGHEST UNCOLLECTED
05879  D5DE                                     ; STRING HIGH BYTE
05880  D5DE  90 16              BCC     XXD5F6          ; IF HIGHEST UNCOL
LECTED STRING IS GREATER THEN GO UPDATE
05881  D5E0                                     ; POINTERS, STEP TO NEXT A
ND RETURN
05882  D5E0                     
05883  D5E0  D0 04              BNE     XXD5E6          ; IF HIGHEST UNCOL
LECTED STRING IS LESS THEN GO SET THIS
05884  D5E2                                     ; STRING AS HIGHEST UNCOLL
ECTED SO FAR
05885  D5E2                     
05886  D5E2                                     ; HIGH BYTES WERE EQUAL SO
 TEST LOW BYTES
05887  D5E2  E4 5F              CPX     XX5F          ; COMPARE STRING POI
NTER LOW BYTE WITH HIGHEST UNCOLLECTED
05888  D5E4                                     ; STRING LOW BYTE
05889  D5E4  90 10              BCC     XXD5F6          ; IF HIGHEST UNCOL
LECTED STRING IS GREATER THEN GO UPDATE
05890  D5E6                                     ; POINTERS, STEP TO NEXT A
ND RETURN
05891  D5E6                     
05892  D5E6                                     ; ELSE SET CURRENT STRING 
AS HIGHEST UNCOLLECTED STRING
05893  D5E6              XXD5E6 = *
05894  D5E6  86 5F              STX     XX5F          ; SAVE STRING POINTE
R LOW BYTE AS HIGHEST UNCOLLECTED STRING
05895  D5E8                                     ; LOW BYTE
05896  D5E8  85 60              STA     XX60          ; SAVE STRING POINTE
R HIGH BYTE AS HIGHEST UNCOLLECTED
05897  D5EA                                     ; STRING HIGH BYTE
05898  D5EA  A5 22              LDA     XX22          ; GET DESCRIPTOR POI
NTER LOW BYTE
05899  D5EC  A6 23              LDX     XX23          ; GET DESCRIPTOR POI
NTER HIGH BYTE
05900  D5EE  85 4E              STA     XX4E          ; SAVE WORKING POINT
ER HIGH BYTE
05901  D5F0  86 4F              STX     XX4F          ; SAVE WORKING POINT
ER LOW BYTE
05902  D5F2  A5 53              LDA     XX53          ; GET STEP SIZE
05903  D5F4  85 55              STA     XX55          ; COPY STEP SIZE
05904  D5F6              XXD5F6 = *
05905  D5F6  A5 53              LDA     XX53          ; GET STEP SIZE
05906  D5F8  18                 CLC                    ; CLEAR CARRY FOR A
DD
05907  D5F9  65 22              ADC     XX22          ; ADD POINTER LOW BY
TE
05908  D5FB  85 22              STA     XX22          ; SAVE POINTER LOW B
YTE
05909  D5FD  90 02              BCC     XXD601          ; IF NO ROLLOVER S
KIP THE HIGH BYTE INCREMENT
05910  D5FF                     
05911  D5FF  E6 23              INC     XX23          ; ELSE INCREMENT POI
NTER HIGH BYTE
05912  D601              XXD601 = *
05913  D601  A6 23              LDX     XX23          ; GET POINTER HIGH B
YTE
05914  D603  A0 00              LDY     #$00               ; FLAG NOT MOVE
D
05915  D605  60                 RTS
05916  D606                     
05917  D606                     
05918  D606              ;************************************************
***********************************;
05919  D606              ;
05920  D606              ; COLLECT STRING
05921  D606              
05922  D606              XXD606 = *
05923  D606  A5 4F              LDA     XX4F          ; GET WORKING POINTE
R LOW BYTE
05924  D608  05 4E              ORA     XX4E          ; OR WORKING POINTER
 HIGH BYTE
05925  D60A  F0 F5              BEQ     XXD601          ; EXIT IF NOTHING 
TO COLLECT
05926  D60C                     
05927  D60C  A5 55              LDA     XX55          ; GET COPIED STEP SI
ZE
05928  D60E  29 04              AND     #$04               ; MASK STEP SIZ
E, $04 FOR VARIABLES, $00 FOR ARRAY OR STACK






AY OR ......PAGE 0111

LINE# LOC   CODE        LINE


05929  D610  4A                 LSR A                  ; >> 1
05930  D611  A8                 TAY                    ; COPY TO INDEX
05931  D612  85 55              STA     XX55          ; SAVE OFFSET TO DES
CRIPTOR START
05932  D614  B1 4E              LDA     (XX4E),Y          ; GET STRING LEN
GTH LOW BYTE
05933  D616  65 5F              ADC     XX5F          ; ADD STRING START L
OW BYTE
05934  D618  85 5A              STA     XX5A          ; SET BLOCK END LOW 
BYTE
05935  D61A  A5 60              LDA     XX60          ; GET STRING START H
IGH BYTE
05936  D61C  69 00              ADC     #$00               ; ADD CARRY
05937  D61E  85 5B              STA     XX5B          ; SET BLOCK END HIGH
 BYTE
05938  D620  A5 33              LDA     XX33          ; GET BOTTOM OF STRI
NG SPACE LOW BYTE
05939  D622  A6 34              LDX     XX34          ; GET BOTTOM OF STRI
NG SPACE HIGH BYTE
05940  D624  85 58              STA     XX58          ; SAVE DESTINATION E
ND LOW BYTE
05941  D626  86 59              STX     XX59          ; SAVE DESTINATION E
ND HIGH BYTE
05942  D628  20 BF C3           JSR     XXC3BF          ; OPEN UP SPACE IN
 MEMORY, DON'T SET ARRAY END. THIS
05943  D62B                                     ; COPIES THE STRING FROM W
HERE IT IS TO THE END OF THE
05944  D62B                                     ; UNCOLLECTED STRING MEMOR
Y
05945  D62B  A4 55              LDY     XX55          ; RESTORE OFFSET TO 
DESCRIPTOR START
05946  D62D  C8                 INY                    ; INCREMENT INDEX T
O STRING POINTER LOW BYTE
05947  D62E  A5 58              LDA     XX58          ; GET NEW STRING POI
NTER LOW BYTE
05948  D630  91 4E              STA     (XX4E),Y          ; SAVE NEW STRIN
G POINTER LOW BYTE
05949  D632  AA                 TAX                    ; COPY STRING POINT
ER LOW BYTE
05950  D633  E6 59              INC     XX59          ; INCREMENT NEW STRI
NG POINTER HIGH BYTE
05951  D635  A5 59              LDA     XX59          ; GET NEW STRING POI
NTER HIGH BYTE
05952  D637  C8                 INY                    ; INCREMENT INDEX T
O STRING POINTER HIGH BYTE
05953  D638  91 4E              STA     (XX4E),Y          ; SAVE NEW STRIN
G POINTER HIGH BYTE
05954  D63A  4C 2A D5           JMP     XXD52A          ; RE-RUN ROUTINE F
ROM LAST ENDING, XA HOLDS NEW BOTTOM
05955  D63D                                     ; OF STRING MEMORY POINTER

05956  D63D                     
05957  D63D                     
05958  D63D              ;************************************************
***********************************;
05959  D63D              ;
05960  D63D              ; CONCATENATE
05961  D63D              ; ADD STRINGS, THE FIRST STRING IS IN THE DESCRIP
TOR, THE SECOND STRING IS IN LINE
05962  D63D              
05963  D63D              XXD63D = *
05964  D63D  A5 65              LDA     XX65          ; GET DESCRIPTOR POI
NTER HIGH BYTE
05965  D63F  48                 PHA                    ; PUT ON STACK
05966  D640  A5 64              LDA     XX64          ; GET DESCRIPTOR POI
NTER LOW BYTE
05967  D642  48                 PHA                    ; PUT ON STACK
05968  D643  20 83 CE           JSR     XXCE83          ; GET VALUE FROM L
INE
05969  D646  20 8F CD           JSR     XXCD8F          ; CHECK IF SOURCE 
IS STRING, ELSE DO TYPE MISMATCH
05970  D649  68                 PLA                    ; GET DESCRIPTOR PO
INTER LOW BYTE BACK
05971  D64A  85 6F              STA     XX6F          ; SET POINTER LOW BY
TE
05972  D64C  68                 PLA                    ; GET DESCRIPTOR PO
INTER HIGH BYTE BACK
05973  D64D  85 70              STA     XX70          ; SET POINTER HIGH B
YTE
05974  D64F  A0 00              LDY     #$00               ; CLEAR INDEX
05975  D651  B1 6F              LDA     (XX6F),Y          ; GET LENGTH OF 
FIRST STRING FROM DESCRIPTOR
05976  D653  18                 CLC                    ; CLEAR CARRY FOR A
DD
05977  D654  71 64              ADC     (XX64),Y          ; ADD LENGTH OF 
SECOND STRING
05978  D656  90 05              BCC     XXD65D          ; IF NO OVERFLOW C
ONTINUE
05979  D658                     
05980  D658  A2 17              LDX     #$17               ; ELSE ERROR $1
7, STRING TOO LONG ERROR
05981  D65A  4C 37 C4           JMP     XXC437          ; DO ERROR #X THEN
 WARM START
05982  D65D                     
05983  D65D              XXD65D = *






YTES L......PAGE 0112

LINE# LOC   CODE        LINE


05984  D65D  20 75 D4           JSR     XXD475          ; COPY DESCRIPTOR 
POINTER AND MAKE STRING SPACE A BYTES LONG
05985  D660  20 7A D6           JSR     XXD67A          ; COPY STRING FROM
 DESCRIPTOR TO UTILITY POINTER
05986  D663  A5 50              LDA     XX50          ; GET DESCRIPTOR POI
NTER LOW BYTE
05987  D665  A4 51              LDY     XX51          ; GET DESCRIPTOR POI
NTER HIGH BYTE
05988  D667  20 AA D6           JSR     XXD6AA          ; POP (YA) DESCRIP
TOR OFF STACK OR FROM TOP OF STRING SPACE
05989  D66A                                     ; RETURNS WITH A = LENGTH,
 X = POINTER LOW BYTE,
05990  D66A                                     ; Y = POINTER HIGH BYTE
05991  D66A  20 8C D6           JSR     XXD68C          ; STORE STRING FRO
M POINTER TO UTILITY POINTER
05992  D66D  A5 6F              LDA     XX6F          ; GET DESCRIPTOR POI
NTER LOW BYTE
05993  D66F  A4 70              LDY     XX70          ; GET DESCRIPTOR POI
NTER HIGH BYTE
05994  D671  20 AA D6           JSR     XXD6AA          ; POP (YA) DESCRIP
TOR OFF STACK OR FROM TOP OF STRING SPACE
05995  D674                                     ; RETURNS WITH A = LENGTH,
 X = POINTER LOW BYTE,
05996  D674                                     ; Y = POINTER HIGH BYTE
05997  D674  20 CA D4           JSR     XXD4CA          ; CHECK SPACE ON D
ESCRIPTOR STACK THEN PUT STRING ADDRESS
05998  D677                                     ; AND LENGTH ON DESCRIPTOR
 STACK AND UPDATE STACK POINTERS
05999  D677  4C B8 CD           JMP     XXCDB8          ; CONTINUE EVALUAT
ION
06000  D67A                     
06001  D67A                     
06002  D67A              ;************************************************
***********************************;
06003  D67A              ;
06004  D67A              ; COPY STRING FROM DESCRIPTOR TO UTILITY POINTER
06005  D67A              
06006  D67A              XXD67A = *
06007  D67A  A0 00              LDY     #$00               ; CLEAR INDEX
06008  D67C  B1 6F              LDA     (XX6F),Y          ; GET STRING LEN
GTH
06009  D67E  48                 PHA                    ; SAVE IT
06010  D67F  C8                 INY                    ; INCREMENT INDEX
06011  D680  B1 6F              LDA     (XX6F),Y          ; GET STRING POI
NTER LOW BYTE
06012  D682  AA                 TAX                    ; COPY TO X
06013  D683  C8                 INY                    ; INCREMENT INDEX
06014  D684  B1 6F              LDA     (XX6F),Y          ; GET STRING POI
NTER HIGH BYTE
06015  D686  A8                 TAY                    ; COPY TO Y
06016  D687  68                 PLA                    ; GET LENGTH BACK
06017  D688              XXD688 = *
06018  D688  86 22              STX     XX22          ; SAVE STRING POINTE
R LOW BYTE
06019  D68A  84 23              STY     XX23          ; SAVE STRING POINTE
R HIGH BYTE
06020  D68C                     
06021  D68C                     
06022  D68C              ;************************************************
***********************************;
06023  D68C              ;
06024  D68C              ; STORE STRING FROM POINTER TO UTILITY POINTER
06025  D68C              
06026  D68C              XXD68C = *
06027  D68C  A8                 TAY                    ; COPY LENGTH AS IN
DEX
06028  D68D  F0 0A              BEQ     XXD699          ; BRANCH IF NULL S
TRING
06029  D68F                     
06030  D68F  48                 PHA                    ; SAVE LENGTH
06031  D690              XXD690 = *
06032  D690  88                 DEY                    ; DECREMENT LENGTH/
INDEX
06033  D691  B1 22              LDA     (XX22),Y          ; GET BYTE FROM 
STRING
06034  D693  91 35              STA     (XX35),Y          ; SAVE BYTE TO D
ESTINATION
06035  D695  98                 TYA                    ; COPY LENGTH/INDEX

06036  D696  D0 F8              BNE     XXD690          ; LOOP IF NOT ALL 
DONE YET
06037  D698                     
06038  D698  68                 PLA                    ; RESTORE LENGTH






****;S......PAGE 0113

LINE# LOC   CODE        LINE


06039  D699              XXD699 = *
06040  D699  18                 CLC                    ; CLEAR CARRY FOR A
DD
06041  D69A  65 35              ADC     XX35          ; ADD STRING UTILITY
 PTR LOW BYTE
06042  D69C  85 35              STA     XX35          ; SAVE STRING UTILIT
Y PTR LOW BYTE
06043  D69E  90 02              BCC     XXD6A2          ; IF NO ROLLOVER S
KIP THE HIGH BYTE INCREMENT
06044  D6A0                     
06045  D6A0  E6 36              INC     XX36          ; INCREMENT STRING U
TILITY PTR HIGH BYTE
06046  D6A2              XXD6A2 = *
06047  D6A2  60                 RTS
06048  D6A3                     
06049  D6A3                     
06050  D6A3              ;************************************************
***********************************;
06051  D6A3              ;
06052  D6A3              ; EVALUATE STRING
06053  D6A3              
06054  D6A3              XXD6A3 = *
06055  D6A3  20 8F CD           JSR     XXCD8F          ; CHECK IF SOURCE 
IS STRING, ELSE DO TYPE MISMATCH
06056  D6A6                     
06057  D6A6              ; POP STRING OFF DESCRIPTOR STACK, OR FROM TOP OF
 STRING SPACE
06058  D6A6              ; RETURNS WITH A = LENGTH, X = POINTER LOW BYTE, 
Y = POINTER HIGH BYTE
06059  D6A6              
06060  D6A6              XXD6A6 = *
06061  D6A6  A5 64              LDA     XX64          ; GET DESCRIPTOR POI
NTER LOW BYTE
06062  D6A8  A4 65              LDY     XX65          ; GET DESCRIPTOR POI
NTER HIGH BYTE
06063  D6AA                     
06064  D6AA              ; POP (YA) DESCRIPTOR OFF STACK OR FROM TOP OF ST
RING SPACE
06065  D6AA              ; RETURNS WITH A = LENGTH, X = POINTER LOW BYTE, 
Y = POINTER HIGH BYTE
06066  D6AA              
06067  D6AA              XXD6AA = *
06068  D6AA  85 22              STA     XX22          ; SAVE STRING POINTE
R LOW BYTE
06069  D6AC  84 23              STY     XX23          ; SAVE STRING POINTE
R HIGH BYTE
06070  D6AE  20 DB D6           JSR     XXD6DB          ; CLEAN DESCRIPTOR
 STACK, YA = POINTER
06071  D6B1  08                 PHP                    ; SAVE STATUS FLAGS

06072  D6B2  A0 00              LDY     #$00               ; CLEAR INDEX
06073  D6B4  B1 22              LDA     (XX22),Y          ; GET LENGTH FRO
M STRING DESCRIPTOR
06074  D6B6  48                 PHA                    ; PUT ON STACK
06075  D6B7  C8                 INY                    ; INCREMENT INDEX
06076  D6B8  B1 22              LDA     (XX22),Y          ; GET STRING POI
NTER LOW BYTE FROM DESCRIPTOR
06077  D6BA  AA                 TAX                    ; COPY TO X
06078  D6BB  C8                 INY                    ; INCREMENT INDEX
06079  D6BC  B1 22              LDA     (XX22),Y          ; GET STRING POI
NTER HIGH BYTE FROM DESCRIPTOR
06080  D6BE  A8                 TAY                    ; COPY TO Y
06081  D6BF  68                 PLA                    ; GET STRING LENGTH
 BACK
06082  D6C0  28                 PLP                    ; RESTORE STATUS
06083  D6C1  D0 13              BNE     XXD6D6          ; BRANCH IF POINTE
R <> LAST_SL,LAST_SH
06084  D6C3                     
06085  D6C3  C4 34              CPY     XX34          ; COMPARE WITH BOTTO
M OF STRING SPACE HIGH BYTE
06086  D6C5  D0 0F              BNE     XXD6D6          ; BRANCH IF <>
06087  D6C7                     
06088  D6C7  E4 33              CPX     XX33          ; ELSE COMPARE WITH 
BOTTOM OF STRING SPACE LOW BYTE
06089  D6C9  D0 0B              BNE     XXD6D6          ; BRANCH IF <>
06090  D6CB                     
06091  D6CB  48                 PHA                    ; SAVE STRING LENGT
H
06092  D6CC  18                 CLC                    ; CLEAR CARRY FOR A
DD
06093  D6CD  65 33              ADC     XX33          ; ADD BOTTOM OF STRI
NG SPACE LOW BYTE






****;S......PAGE 0114

LINE# LOC   CODE        LINE


06094  D6CF  85 33              STA     XX33          ; SET BOTTOM OF STRI
NG SPACE LOW BYTE
06095  D6D1  90 02              BCC     XXD6D5          ; SKIP INCREMENT I
F NO OVERFLOW
06096  D6D3                     
06097  D6D3  E6 34              INC     XX34          ; INCREMENT BOTTOM O
F STRING SPACE HIGH BYTE
06098  D6D5              XXD6D5 = *
06099  D6D5  68                 PLA                    ; RESTORE STRING LE
NGTH
06100  D6D6              XXD6D6 = *
06101  D6D6  86 22              STX     XX22          ; SAVE STRING POINTE
R LOW BYTE
06102  D6D8  84 23              STY     XX23          ; SAVE STRING POINTE
R HIGH BYTE
06103  D6DA  60                 RTS
06104  D6DB                     
06105  D6DB                     
06106  D6DB              ;************************************************
***********************************;
06107  D6DB              ;
06108  D6DB              ; CLEAN DESCRIPTOR STACK, YA = POINTER
06109  D6DB              ; CHECKS IF AY IS ON THE DESCRIPTOR STACK, IF SO 
DOES A STACK DISCARD
06110  D6DB              
06111  D6DB              XXD6DB = *
06112  D6DB  C4 18              CPY     XX18          ; COMPARE HIGH BYTE 
WITH CURRENT DESCRIPTOR STACK ITEM
06113  D6DD                                     ; POINTER HIGH BYTE
06114  D6DD  D0 0C              BNE     XXD6EB          ; EXIT IF <>
06115  D6DF                     
06116  D6DF  C5 17              CMP     XX17          ; COMPARE LOW BYTE W
ITH CURRENT DESCRIPTOR STACK ITEM
06117  D6E1                                     ; POINTER LOW BYTE
06118  D6E1  D0 08              BNE     XXD6EB          ; EXIT IF <>
06119  D6E3                     
06120  D6E3  85 16              STA     XX16          ; SET DESCRIPTOR STA
CK POINTER
06121  D6E5  E9 03              SBC     #$03               ; UPDATE LAST S
TRING POINTER LOW BYTE
06122  D6E7  85 17              STA     XX17          ; SAVE CURRENT DESCR
IPTOR STACK ITEM POINTER LOW BYTE
06123  D6E9  A0 00              LDY     #$00               ; CLEAR HIGH BY
TE
06124  D6EB              XXD6EB = *
06125  D6EB  60                 RTS
06126  D6EC                     
06127  D6EC                     
06128  D6EC              ;************************************************
***********************************;
06129  D6EC              ;
06130  D6EC              ; PERFORM CHR$()
06131  D6EC              
06132  D6EC              XXD6EC = *
06133  D6EC  20 A1 D7           JSR     XXD7A1          ; EVALUATE BYTE EX
PRESSION, RESULT IN X
06134  D6EF  8A                 TXA                    ; COPY TO A
06135  D6F0  48                 PHA                    ; SAVE CHARACTER
06136  D6F1  A9 01              LDA     #$01               ; STRING IS SIN
GLE BYTE
06137  D6F3  20 7D D4           JSR     XXD47D          ; MAKE STRING SPAC
E A BYTES LONG
06138  D6F6  68                 PLA                    ; GET CHARACTER BAC
K
06139  D6F7  A0 00              LDY     #$00               ; CLEAR INDEX
06140  D6F9  91 62              STA     (XX62),Y          ; SAVE BYTE IN S
TRING - BYTE IS STRING!
06141  D6FB  68                 PLA                    ; DUMP RETURN ADDRE
SS (SKIP TYPE CHECK)
06142  D6FC  68                 PLA                    ; DUMP RETURN ADDRE
SS (SKIP TYPE CHECK)
06143  D6FD  4C CA D4           JMP     XXD4CA          ; CHECK SPACE ON D
ESCRIPTOR STACK THEN PUT STRING ADDRESS
06144  D700                                     ; AND LENGTH ON DESCRIPTOR
 STACK AND UPDATE STACK POINTERS
06145  D700                     
06146  D700                     
06147  D700              ;************************************************
***********************************;
06148  D700              ;






****;S......PAGE 0115

LINE# LOC   CODE        LINE


06149  D700              ; PERFORM LEFT$()
06150  D700              
06151  D700              XXD700 = *
06152  D700  20 61 D7           JSR     XXD761          ; PULL STRING DATA
 AND BYTE PARAMETER FROM STACK
06153  D703                                     ; RETURN POINTER IN DESCRI
PTOR, BYTE IN A (AND X), Y=0
06154  D703  D1 50              CMP     (XX50),Y          ; COMPARE BYTE P
ARAMETER WITH STRING LENGTH
06155  D705  98                 TYA                    ; CLEAR A
06156  D706              XXD706 = *
06157  D706  90 04              BCC     XXD70C          ; BRANCH IF STRING
 LENGTH > BYTE PARAMETER
06158  D708                     
06159  D708  B1 50              LDA     (XX50),Y          ; ELSE MAKE PARA
METER = LENGTH
06160  D70A  AA                 TAX                    ; COPY TO BYTE PARA
METER COPY
06161  D70B  98                 TYA                    ; CLEAR STRING STAR
T OFFSET
06162  D70C              XXD70C = *
06163  D70C  48                 PHA                    ; SAVE STRING START
 OFFSET
06164  D70D              XXD70D = *
06165  D70D  8A                 TXA                    ; COPY BYTE PARAMET
ER (OR STRING LENGTH IF <)
06166  D70E              XXD70E = *
06167  D70E  48                 PHA                    ; SAVE STRING LENGT
H
06168  D70F  20 7D D4           JSR     XXD47D          ; MAKE STRING SPAC
E A BYTES LONG
06169  D712  A5 50              LDA     XX50          ; GET DESCRIPTOR POI
NTER LOW BYTE
06170  D714  A4 51              LDY     XX51          ; GET DESCRIPTOR POI
NTER HIGH BYTE
06171  D716  20 AA D6           JSR     XXD6AA          ; POP (YA) DESCRIP
TOR OFF STACK OR FROM TOP OF STRING SPACE
06172  D719                                     ; RETURNS WITH A = LENGTH,
 X = POINTER LOW BYTE,
06173  D719                                     ; Y = POINTER HIGH BYTE
06174  D719  68                 PLA                    ; GET STRING LENGTH
 BACK
06175  D71A  A8                 TAY                    ; COPY LENGTH TO Y
06176  D71B  68                 PLA                    ; GET STRING START 
OFFSET BACK
06177  D71C  18                 CLC                    ; CLEAR CARRY FOR A
DD
06178  D71D  65 22              ADC     XX22          ; ADD START OFFSET T
O STRING START POINTER LOW BYTE
06179  D71F  85 22              STA     XX22          ; SAVE STRING START 
POINTER LOW BYTE
06180  D721  90 02              BCC     XXD725          ; IF NO OVERFLOW S
KIP THE HIGH BYTE INCREMENT
06181  D723                     
06182  D723  E6 23              INC     XX23          ; ELSE INCREMENT STR
ING START POINTER HIGH BYTE
06183  D725              XXD725 = *
06184  D725  98                 TYA                    ; COPY LENGTH TO A
06185  D726  20 8C D6           JSR     XXD68C          ; STORE STRING FRO
M POINTER TO UTILITY POINTER
06186  D729  4C CA D4           JMP     XXD4CA          ; CHECK SPACE ON D
ESCRIPTOR STACK THEN PUT STRING ADDRESS
06187  D72C                                     ; AND LENGTH ON DESCRIPTOR
 STACK AND UPDATE STACK POINTERS
06188  D72C                     
06189  D72C                     
06190  D72C              ;************************************************
***********************************;
06191  D72C              ;
06192  D72C              ; PERFORM RIGHT$()
06193  D72C              
06194  D72C              XXD72C = *
06195  D72C  20 61 D7           JSR     XXD761          ; PULL STRING DATA
 AND BYTE PARAMETER FROM STACK
06196  D72F                                     ; RETURN POINTER IN DESCRI
PTOR, BYTE IN A (AND X), Y=0
06197  D72F  18                 CLC                    ; CLEAR CARRY FOR A
DD-1
06198  D730  F1 50              SBC     (XX50),Y          ; SUBTRACT STRIN
G LENGTH
06199  D732  49 FF              EOR     #$FF               ; INVERT IT (A=
LEN(EXPRESSION$)-L)
06200  D734  4C 06 D7           JMP     XXD706          ; GO DO REST OF LE
FT$()
06201  D737                     
06202  D737                     
06203  D737              ;************************************************
***********************************;






****;S......PAGE 0116

LINE# LOC   CODE        LINE


06204  D737              ;
06205  D737              ; PERFORM MID$()
06206  D737              
06207  D737              XXD737 = *
06208  D737  A9 FF              LDA     #$FF               ; SET DEFAULT L
ENGTH = 255
06209  D739  85 65              STA     XX65          ; SAVE DEFAULT LENGT
H
06210  D73B  20 79 00           JSR     XX0079          ; SCAN MEMORY
06211  D73E  C9 29              CMP     #$29               ; COMPARE WITH 
')'
06212  D740  F0 06              BEQ     XXD748          ; BRANCH IF = ')' 
(SKIP SECOND BYTE GET)
06213  D742                     
06214  D742  20 FD CE           JSR     XXCEFD          ; SCAN FOR ',', EL
SE DO SYNTAX ERROR THEN WARM START
06215  D745  20 9E D7           JSR     XXD79E          ; GET BYTE PARAMET
ER 
06216  D748              XXD748 = *
06217  D748  20 61 D7           JSR     XXD761          ; PULL STRING DATA
 AND BYTE PARAMETER FROM STACK
06218  D74B                                     ; RETURN POINTER IN DESCRI
PTOR, BYTE IN A (AND X), Y=0
06219  D74B  F0 4B              BEQ     XXD798          ; IF NULL DO ILLEG
AL QUANTITY ERROR THEN WARM START
06220  D74D                     
06221  D74D  CA                 DEX                    ; DECREMENT START I
NDEX
06222  D74E  8A                 TXA                    ; COPY TO A
06223  D74F  48                 PHA                    ; SAVE STRING START
 OFFSET
06224  D750  18                 CLC                    ; CLEAR CARRY FOR S
UB-1
06225  D751  A2 00              LDX     #$00               ; CLEAR OUTPUT 
STRING LENGTH
06226  D753  F1 50              SBC     (XX50),Y          ; SUBTRACT STRIN
G LENGTH
06227  D755  B0 B6              BCS     XXD70D          ; IF START>STRING 
LENGTH GO DO NULL STRING
06228  D757                     
06229  D757  49 FF              EOR     #$FF               ; COMPLEMENT -L
ENGTH
06230  D759  C5 65              CMP     XX65          ; COMPARE BYTE PARAM
ETER
06231  D75B  90 B1              BCC     XXD70E          ; IF LENGTH>REMAIN
ING STRING GO DO RIGHT$
06232  D75D                     
06233  D75D  A5 65              LDA     XX65          ; GET LENGTH BYTE
06234  D75F  B0 AD              BCS     XXD70E          ; GO DO STRING COP
Y, BRANCH ALWAYS
06235  D761                     
06236  D761                     
06237  D761              ;************************************************
***********************************;
06238  D761              ;
06239  D761              ; PULL STRING DATA AND BYTE PARAMETER FROM STACK
06240  D761              ; RETURN POINTER IN DESCRIPTOR, BYTE IN A (AND X)
, Y=0
06241  D761              
06242  D761              XXD761 = *
06243  D761  20 F7 CE           JSR     XXCEF7          ; SCAN FOR ')', EL
SE DO SYNTAX ERROR THEN WARM START
06244  D764  68                 PLA                    ; PULL RETURN ADDRE
SS LOW BYTE
06245  D765  A8                 TAY                    ; SAVE RETURN ADDRE
SS LOW BYTE
06246  D766  68                 PLA                    ; PULL RETURN ADDRE
SS HIGH BYTE
06247  D767  85 55              STA     XX55          ; SAVE RETURN ADDRES
S HIGH BYTE
06248  D769  68                 PLA                    ; DUMP CALL TO FUNC
TION VECTOR LOW BYTE
06249  D76A  68                 PLA                    ; DUMP CALL TO FUNC
TION VECTOR HIGH BYTE
06250  D76B  68                 PLA                    ; PULL BYTE PARAMET
ER
06251  D76C  AA                 TAX                    ; COPY BYTE PARAMET
ER TO X
06252  D76D  68                 PLA                    ; PULL STRING POINT
ER LOW BYTE
06253  D76E  85 50              STA     XX50          ; SAVE IT
06254  D770  68                 PLA                    ; PULL STRING POINT
ER HIGH BYTE
06255  D771  85 51              STA     XX51          ; SAVE IT
06256  D773  A5 55              LDA     XX55          ; GET RETURN ADDRESS
 HIGH BYTE
06257  D775  48                 PHA                    ; BACK ON STACK
06258  D776  98                 TYA                    ; GET RETURN ADDRES
S LOW BYTE






T***;S......PAGE 0117

LINE# LOC   CODE        LINE


06259  D777  48                 PHA                    ; BACK ON STACK
06260  D778  A0 00              LDY     #$00               ; CLEAR INDEX
06261  D77A  8A                 TXA                    ; COPY BYTE PARAMET
ER
06262  D77B  60                 RTS
06263  D77C                     
06264  D77C                     
06265  D77C              ;************************************************
***********************************;
06266  D77C              ;
06267  D77C              ; PERFORM LEN()
06268  D77C              
06269  D77C              XXD77C = *
06270  D77C  20 82 D7           JSR     XXD782          ; EVALUATE STRING,
 GET LENGTH IN A (AND Y)
06271  D77F  4C A2 D3           JMP     XXD3A2          ; CONVERT Y TO BYT
E IN FAC1 AND RETURN
06272  D782                     
06273  D782                     
06274  D782              ;************************************************
***********************************;
06275  D782              ;
06276  D782              ; EVALUATE STRING, GET LENGTH IN Y
06277  D782              
06278  D782              XXD782 = *
06279  D782  20 A3 D6           JSR     XXD6A3          ; EVALUATE STRING
06280  D785  A2 00              LDX     #$00               ; SET DATA TYPE
 = NUMERIC
06281  D787  86 0D              STX     XX0D          ; CLEAR DATA TYPE FL
AG, $FF = STRING, $00 = NUMERIC
06282  D789  A8                 TAY                    ; COPY LENGTH TO Y
06283  D78A  60                 RTS
06284  D78B                     
06285  D78B                     
06286  D78B              ;************************************************
***********************************;
06287  D78B              ;
06288  D78B              ; PERFORM ASC()
06289  D78B              
06290  D78B              XXD78B = *
06291  D78B  20 82 D7           JSR     XXD782          ; EVALUATE STRING,
 GET LENGTH IN A (AND Y)
06292  D78E  F0 08              BEQ     XXD798          ; IF NULL DO ILLEG
AL QUANTITY ERROR THEN WARM START
06293  D790                     
06294  D790  A0 00              LDY     #$00               ; SET INDEX TO 
FIRST CHARACTER
06295  D792  B1 22              LDA     (XX22),Y          ; GET BYTE
06296  D794  A8                 TAY                    ; COPY TO Y
06297  D795  4C A2 D3           JMP     XXD3A2          ; CONVERT Y TO BYT
E IN FAC1 AND RETURN
06298  D798                     
06299  D798                     
06300  D798              ;************************************************
***********************************;
06301  D798              ;
06302  D798              ; DO ILLEGAL QUANTITY ERROR THEN WARM START
06303  D798              
06304  D798              XXD798 = *
06305  D798  4C 48 D2           JMP     XXD248          ; DO ILLEGAL QUANT
ITY ERROR THEN WARM START
06306  D79B                     
06307  D79B                     
06308  D79B              ;************************************************
***********************************;
06309  D79B              ;
06310  D79B              ; SCAN AND GET BYTE PARAMETER
06311  D79B              
06312  D79B              XXD79B = *
06313  D79B  20 73 00           JSR     XX0073          ; INCREMENT AND SC
AN MEMORY






****;S......PAGE 0118

LINE# LOC   CODE        LINE


06314  D79E                     
06315  D79E              ; GET BYTE PARAMETER
06316  D79E              
06317  D79E              XXD79E = *
06318  D79E  20 8A CD           JSR     XXCD8A          ; EVALUATE EXPRESS
ION AND CHECK IS NUMERIC, ELSE DO
06319  D7A1                                     ; TYPE MISMATCH
06320  D7A1                     
06321  D7A1              ; EVALUATE BYTE EXPRESSION, RESULT IN X
06322  D7A1              
06323  D7A1              XXD7A1 = *
06324  D7A1  20 B8 D1           JSR     XXD1B8          ; EVALUATE INTEGER
 EXPRESSION, SIGN CHECK
06325  D7A4                     
06326  D7A4  A6 64              LDX     XX64          ; GET FAC1 MANTISSA 
3
06327  D7A6  D0 F0              BNE     XXD798          ; IF NOT NULL DO I
LLEGAL QUANTITY ERROR THEN WARM START
06328  D7A8                     
06329  D7A8  A6 65              LDX     XX65          ; GET FAC1 MANTISSA 
4
06330  D7AA  4C 79 00           JMP     XX0079          ; SCAN MEMORY AND 
RETURN
06331  D7AD                     
06332  D7AD                     
06333  D7AD              ;************************************************
***********************************;
06334  D7AD              ;
06335  D7AD              ; PERFORM VAL()
06336  D7AD              
06337  D7AD              XXD7AD = *
06338  D7AD  20 82 D7           JSR     XXD782          ; EVALUATE STRING,
 GET LENGTH IN A (AND Y)
06339  D7B0  D0 03              BNE     XXD7B5          ; IF NOT A NULL ST
RING GO EVALUATE IT
06340  D7B2                     
06341  D7B2                                     ; STRING WAS NULL SO SET R
ESULT = $00
06342  D7B2  4C F7 D8           JMP     XXD8F7          ; CLEAR FAC1 EXPON
ENT AND SIGN AND RETURN
06343  D7B5                     
06344  D7B5              XXD7B5 = *
06345  D7B5  A6 7A              LDX     XX7A          ; GET BASIC EXECUTE 
POINTER LOW BYTE
06346  D7B7  A4 7B              LDY     XX7B          ; GET BASIC EXECUTE 
POINTER HIGH BYTE
06347  D7B9  86 71              STX     XX71          ; SAVE BASIC EXECUTE
 POINTER LOW BYTE
06348  D7BB  84 72              STY     XX72          ; SAVE BASIC EXECUTE
 POINTER HIGH BYTE
06349  D7BD  A6 22              LDX     XX22          ; GET STRING POINTER
 LOW BYTE
06350  D7BF  86 7A              STX     XX7A          ; SAVE BASIC EXECUTE
 POINTER LOW BYTE
06351  D7C1  18                 CLC                    ; CLEAR CARRY FOR A
DD
06352  D7C2  65 22              ADC     XX22          ; ADD STRING LENGTH
06353  D7C4  85 24              STA     XX24          ; SAVE STRING END LO
W BYTE
06354  D7C6  A6 23              LDX     XX23          ; GET STRING POINTER
 HIGH BYTE
06355  D7C8  86 7B              STX     XX7B          ; SAVE BASIC EXECUTE
 POINTER HIGH BYTE
06356  D7CA  90 01              BCC     XXD7CD          ; IF NO ROLLOVER S
KIP THE HIGH BYTE INCREMENT
06357  D7CC                     
06358  D7CC  E8                 INX                    ; INCREMENT STRING 
END HIGH BYTE
06359  D7CD              XXD7CD = *
06360  D7CD  86 25              STX     XX25          ; SAVE STRING END HI
GH BYTE
06361  D7CF  A0 00              LDY     #$00               ; SET INDEX TO 
$00
06362  D7D1  B1 24              LDA     (XX24),Y          ; GET STRING END
 BYTE
06363  D7D3  48                 PHA                    ; PUSH IT
06364  D7D4  98                 TYA                    ; CLEAR A
06365  D7D5  91 24              STA     (XX24),Y          ; TERMINATE STRI
NG WITH $00
06366  D7D7  20 79 00           JSR     XX0079          ; SCAN MEMORY
06367  D7DA  20 F3 DC           JSR     XXDCF3          ; GET FAC1 FROM ST
RING
06368  D7DD  68                 PLA                    ; RESTORE STRING EN
D BYTE






****;S......PAGE 0119

LINE# LOC   CODE        LINE


06369  D7DE  A0 00              LDY     #$00               ; CLEAR INDEX
06370  D7E0  91 24              STA     (XX24),Y          ; PUT STRING END
 BYTE BACK
06371  D7E2                     
06372  D7E2              ; RESTORE BASIC EXECUTE POINTER FROM TEMP
06373  D7E2              
06374  D7E2              XXD7E2 = *
06375  D7E2  A6 71              LDX     XX71          ; GET BASIC EXECUTE 
POINTER LOW BYTE BACK
06376  D7E4  A4 72              LDY     XX72          ; GET BASIC EXECUTE 
POINTER HIGH BYTE BACK
06377  D7E6  86 7A              STX     XX7A          ; SAVE BASIC EXECUTE
 POINTER LOW BYTE
06378  D7E8  84 7B              STY     XX7B          ; SAVE BASIC EXECUTE
 POINTER HIGH BYTE
06379  D7EA  60                 RTS
06380  D7EB                     
06381  D7EB                     
06382  D7EB              ;************************************************
***********************************;
06383  D7EB              ;
06384  D7EB              ; GET PARAMETERS FOR POKE/WAIT
06385  D7EB              
06386  D7EB              XXD7EB = *
06387  D7EB  20 8A CD           JSR     XXCD8A          ; EVALUATE EXPRESS
ION AND CHECK IS NUMERIC, ELSE DO
06388  D7EE                                     ; TYPE MISMATCH
06389  D7EE  20 F7 D7           JSR     XXD7F7          ; CONVERT FAC_1 TO
 INTEGER IN TEMPORARY INTEGER
06390  D7F1              XXD7F1 = *
06391  D7F1  20 FD CE           JSR     XXCEFD          ; SCAN FOR ',', EL
SE DO SYNTAX ERROR THEN WARM START
06392  D7F4  4C 9E D7           JMP     XXD79E          ; GET BYTE PARAMET
ER AND RETURN
06393  D7F7                     
06394  D7F7                     
06395  D7F7              ;************************************************
***********************************;
06396  D7F7              ;
06397  D7F7              ; CONVERT FAC_1 TO INTEGER IN TEMPORARY INTEGER
06398  D7F7              
06399  D7F7              XXD7F7 = *
06400  D7F7  A5 66              LDA     XX66          ; GET FAC1 SIGN
06401  D7F9  30 9D              BMI     XXD798          ; IF -VE DO ILLEGA
L QUANTITY ERROR THEN WARM START
06402  D7FB                     
06403  D7FB  A5 61              LDA     XX61          ; GET FAC1 EXPONENT
06404  D7FD  C9 91              CMP     #$91               ; COMPARE WITH 
EXPONENT = 2^16
06405  D7FF  B0 97              BCS     XXD798          ; IF >= DO ILLEGAL
 QUANTITY ERROR THEN WARM START
06406  D801                     
06407  D801  20 9B DC           JSR     XXDC9B          ; CONVERT FAC1 FLO
ATING TO FIXED
06408  D804  A5 64              LDA     XX64          ; GET FAC1 MANTISSA 
3
06409  D806  A4 65              LDY     XX65          ; GET FAC1 MANTISSA 
4
06410  D808  84 14              STY     XX14          ; SAVE TEMPORARY INT
EGER LOW BYTE
06411  D80A  85 15              STA     XX15          ; SAVE TEMPORARY INT
EGER HIGH BYTE
06412  D80C  60                 RTS
06413  D80D                     
06414  D80D                     
06415  D80D              ;************************************************
***********************************;
06416  D80D              ;
06417  D80D              ; PERFORM PEEK()
06418  D80D              
06419  D80D              XXD80D = *
06420  D80D  A5 15              LDA     XX15          ; GET LINE NUMBER HI
GH BYTE
06421  D80F  48                 PHA                    ; SAVE LINE NUMBER 
HIGH BYTE
06422  D810  A5 14              LDA     XX14          ; GET LINE NUMBER LO
W BYTE
06423  D812  48                 PHA                    ; SAVE LINE NUMBER 
LOW BYTE






****;S......PAGE 0120

LINE# LOC   CODE        LINE


06424  D813  20 F7 D7           JSR     XXD7F7          ; CONVERT FAC_1 TO
 INTEGER IN TEMPORARY INTEGER
06425  D816  A0 00              LDY     #$00               ; CLEAR INDEX
06426  D818  B1 14              LDA     (XX14),Y          ; READ BYTE
06427  D81A  A8                 TAY                    ; COPY BYTE TO A
06428  D81B  68                 PLA                    ; PULL BYTE
06429  D81C  85 14              STA     XX14          ; RESTORE LINE NUMBE
R LOW BYTE
06430  D81E  68                 PLA                    ; PULL BYTE
06431  D81F  85 15              STA     XX15          ; RESTORE LINE NUMBE
R HIGH BYTE
06432  D821  4C A2 D3           JMP     XXD3A2          ; CONVERT Y TO BYT
E IN FAC_1 AND RETURN
06433  D824                     
06434  D824                     
06435  D824              ;************************************************
***********************************;
06436  D824              ;
06437  D824              ; PERFORM POKE
06438  D824              
06439  D824              XXD824 = *
06440  D824  20 EB D7           JSR     XXD7EB          ; GET PARAMETERS F
OR POKE/WAIT
06441  D827  8A                 TXA                    ; COPY BYTE TO A
06442  D828  A0 00              LDY     #$00               ; CLEAR INDEX
06443  D82A  91 14              STA     (XX14),Y          ; WRITE BYTE
06444  D82C  60                 RTS
06445  D82D                     
06446  D82D                     
06447  D82D              ;************************************************
***********************************;
06448  D82D              ;
06449  D82D              ; PERFORM WAIT
06450  D82D              
06451  D82D              XXD82D = *
06452  D82D  20 EB D7           JSR     XXD7EB          ; GET PARAMETERS F
OR POKE/WAIT
06453  D830  86 49              STX     XX49          ; SAVE BYTE
06454  D832  A2 00              LDX     #$00               ; CLEAR MASK
06455  D834  20 79 00           JSR     XX0079          ; SCAN MEMORY
06456  D837  F0 03              BEQ     XXD83C          ; SKIP IF NO THIRD
 ARGUMENT
06457  D839                     
06458  D839  20 F1 D7           JSR     XXD7F1          ; SCAN FOR ',' AND
 GET BYTE, ELSE SYNTAX ERROR THEN
06459  D83C                                     ; WARM START
06460  D83C              XXD83C = *
06461  D83C  86 4A              STX     XX4A          ; SAVE EOR ARGUMENT
06462  D83E  A0 00              LDY     #$00               ; CLEAR INDEX
06463  D840              XXD840 = *
06464  D840  B1 14              LDA     (XX14),Y          ; GET BYTE VIA T
EMPORARY INTEGER     (ADDRESS)
06465  D842  45 4A              EOR     XX4A          ; EOR WITH SECOND AR
GUMENT          (MASK)
06466  D844  25 49              AND     XX49          ; AND WITH FIRST ARG
UMENT          (BYTE)
06467  D846  F0 F8              BEQ     XXD840          ; LOOP IF RESULT I
S ZERO
06468  D848                     
06469  D848              XXD848 = *
06470  D848  60                 RTS
06471  D849                     
06472  D849                     
06473  D849              ;************************************************
***********************************;
06474  D849              ;
06475  D849              ; ADD 0.5 TO FAC1 (ROUND FAC1)
06476  D849              
06477  D849              XXD849 = *
06478  D849  A9 11              LDA     #<XXDF11          ; SET 0.5 POINTE
R LOW BYTE






****;S......PAGE 0121

LINE# LOC   CODE        LINE


06479  D84B  A0 DF              LDY     #>XXDF11          ; SET 0.5 POINTE
R HIGH BYTE
06480  D84D  4C 67 D8           JMP     XXD867          ; ADD (AY) TO FAC1

06481  D850                     
06482  D850                     
06483  D850              ;************************************************
***********************************;
06484  D850              ;
06485  D850              ; PERFORM SUBTRACTION, FAC1 FROM (AY)
06486  D850              
06487  D850              XXD850 = *
06488  D850  20 8C DA           JSR     XXDA8C          ; UNPACK MEMORY (A
Y) INTO FAC2
06489  D853                     
06490  D853              ; PERFORM SUBTRACTION, FAC1 FROM FAC2
06491  D853              
06492  D853              XXD853 = *
06493  D853  A5 66              LDA     XX66          ; GET FAC1 SIGN (B7)

06494  D855  49 FF              EOR     #$FF               ; COMPLEMENT IT

06495  D857  85 66              STA     XX66          ; SAVE FAC1 SIGN (B7
)
06496  D859  45 6E              EOR     XX6E          ; EOR WITH FAC2 SIGN
 (B7)
06497  D85B  85 6F              STA     XX6F          ; SAVE SIGN COMPARE 
(FAC1 EOR FAC2)
06498  D85D  A5 61              LDA     XX61          ; GET FAC1 EXPONENT
06499  D85F  4C 6A D8           JMP     XXD86A          ; ADD FAC2 TO FAC1
 AND RETURN
06500  D862                     
06501  D862              XXD862 = *
06502  D862  20 99 D9           JSR     XXD999          ; SHIFT FACX A TIM
ES RIGHT (>8 SHIFTS)
06503  D865  90 3C              BCC     XXD8A3          ; GO SUBTRACT THE 
MANTISSAS, BRANCH ALWAYS
06504  D867                     
06505  D867                     
06506  D867              ;************************************************
***********************************;
06507  D867              ;
06508  D867              ; ADD (AY) TO FAC1
06509  D867              
06510  D867              XXD867 = *
06511  D867  20 8C DA           JSR     XXDA8C          ; UNPACK MEMORY (A
Y) INTO FAC2
06512  D86A                     
06513  D86A              ; ADD FAC2 TO FAC1
06514  D86A              
06515  D86A              XXD86A = *
06516  D86A  D0 03              BNE     XXD86F          ; IF FAC1 IS NOT Z
ERO GO DO THE ADD
06517  D86C                     
06518  D86C  4C FC DB           JMP     XXDBFC          ; FAC1 WAS ZERO SO
 COPY FAC2 TO FAC1 AND RETURN
06519  D86F                     
06520  D86F                                     ; FAC1 IS NON ZERO
06521  D86F              XXD86F = *
06522  D86F  A6 70              LDX     XX70          ; GET FAC1 ROUNDING 
BYTE
06523  D871  86 56              STX     XX56          ; SAVE AS FAC2 ROUND
ING BYTE
06524  D873  A2 69              LDX     #XX69          ; SET INDEX TO FAC2
 EXPONENT ADDRESS
06525  D875  A5 69              LDA     XX69          ; GET FAC2 EXPONENT
06526  D877              XXD877 = *
06527  D877  A8                 TAY                    ; COPY EXPONENT
06528  D878  F0 CE              BEQ     XXD848          ; EXIT IF ZERO
06529  D87A                     
06530  D87A  38                 SEC                    ; SET CARRY FOR SUB
TRACT
06531  D87B  E5 61              SBC     XX61          ; SUBTRACT FAC1 EXPO
NENT
06532  D87D  F0 24              BEQ     XXD8A3          ; IF EQUAL GO ADD 
MANTISSAS
06533  D87F                     






****;S......PAGE 0122

LINE# LOC   CODE        LINE


06534  D87F  90 12              BCC     XXD893          ; IF FAC2 < FAC1 T
HEN GO SHIFT FAC2 RIGHT
06535  D881                     
06536  D881                                     ; ELSE FAC2 > FAC1
06537  D881  84 61              STY     XX61          ; SAVE FAC1 EXPONENT

06538  D883  A4 6E              LDY     XX6E          ; GET FAC2 SIGN (B7)

06539  D885  84 66              STY     XX66          ; SAVE FAC1 SIGN (B7
)
06540  D887  49 FF              EOR     #$FF               ; COMPLEMENT A
06541  D889  69 00              ADC     #$00               ; +1, TWOS COMP
LEMENT, CARRY IS SET
06542  D88B  A0 00              LDY     #$00               ; CLEAR Y
06543  D88D  84 56              STY     XX56          ; CLEAR FAC2 ROUNDIN
G BYTE
06544  D88F  A2 61              LDX     #XX61          ; SET INDEX TO FAC1
 EXPONENT ADDRESS
06545  D891  D0 04              BNE     XXD897          ; BRANCH ALWAYS
06546  D893                     
06547  D893                                     ; FAC2 < FAC1
06548  D893              XXD893 = *
06549  D893  A0 00              LDY     #$00               ; CLEAR Y
06550  D895  84 70              STY     XX70          ; CLEAR FAC1 ROUNDIN
G BYTE
06551  D897              XXD897 = *
06552  D897  C9 F9              CMP     #$F9               ; COMPARE EXPON
ENT DIFF WITH $F9
06553  D899  30 C7              BMI     XXD862          ; BRANCH IF RANGE 
$79-$F8
06554  D89B                     
06555  D89B  A8                 TAY                    ; COPY EXPONENT DIF
FERENCE TO Y
06556  D89C  A5 70              LDA     XX70          ; GET FAC1 ROUNDING 
BYTE
06557  D89E  56 01              LSR     XX01,X          ; SHIFT FAC? MANTI
SSA 1
06558  D8A0  20 B0 D9           JSR     XXD9B0          ; SHIFT FACX Y TIM
ES RIGHT
06559  D8A3                     
06560  D8A3                                     ; EXPONENTS ARE EQUAL NOW 
DO MANTISSA SUBTRACT
06561  D8A3              XXD8A3 = *
06562  D8A3  24 6F              BIT     XX6F          ; TEST SIGN COMPARE 
(FAC1 EOR FAC2)
06563  D8A5  10 57              BPL     XXD8FE          ; IF = ADD FAC2 MA
NTISSA TO FAC1 MANTISSA AND RETURN
06564  D8A7                     
06565  D8A7  A0 61              LDY     #XX61          ; SET INDEX TO FAC1
 EXPONENT ADDRESS
06566  D8A9  E0 69              CPX     #XX69          ; COMPARE X TO FAC2
 EXPONENT ADDRESS
06567  D8AB  F0 02              BEQ     XXD8AF          ; BRANCH IF =
06568  D8AD                     
06569  D8AD  A0 69              LDY     #XX69          ; ELSE SET INDEX TO
 FAC2 EXPONENT ADDRESS
06570  D8AF                     
06571  D8AF                                     ; SUBTRACT SMALLER FROM BI
GGER (TAKE SIGN OF BIGGER)
06572  D8AF              XXD8AF = *
06573  D8AF  38                 SEC                    ; SET CARRY FOR SUB
TRACT
06574  D8B0  49 FF              EOR     #$FF               ; ONES COMPLEME
NT A
06575  D8B2  65 56              ADC     XX56          ; ADD FAC2 ROUNDING 
BYTE
06576  D8B4  85 70              STA     XX70          ; SAVE FAC1 ROUNDING
 BYTE
06577  D8B6  B9 04 00           LDA     XX04,Y          ; GET FACY MANTISS
A 4
06578  D8B9  F5 04              SBC     XX04,X          ; SUBTRACT FACX MA
NTISSA 4
06579  D8BB  85 65              STA     XX65          ; SAVE FAC1 MANTISSA
 4
06580  D8BD  B9 03 00           LDA     XX03,Y          ; GET FACY MANTISS
A 3
06581  D8C0  F5 03              SBC     XX03,X          ; SUBTRACT FACX MA
NTISSA 3
06582  D8C2  85 64              STA     XX64          ; SAVE FAC1 MANTISSA
 3
06583  D8C4  B9 02 00           LDA     XX02,Y          ; GET FACY MANTISS
A 2
06584  D8C7  F5 02              SBC     XX02,X          ; SUBTRACT FACX MA
NTISSA 2
06585  D8C9  85 63              STA     XX63          ; SAVE FAC1 MANTISSA
 2
06586  D8CB  B9 01 00           LDA     XX01,Y          ; GET FACY MANTISS
A 1
06587  D8CE  F5 01              SBC     XX01,X          ; SUBTRACT FACX MA
NTISSA 1
06588  D8D0  85 62              STA     XX62          ; SAVE FAC1 MANTISSA
 1






N***;S......PAGE 0123

LINE# LOC   CODE        LINE


06589  D8D2                     
06590  D8D2                     
06591  D8D2              ;************************************************
***********************************;
06592  D8D2              ;
06593  D8D2              ; DO ABS AND NORMALISE FAC1
06594  D8D2              
06595  D8D2              XXD8D2 = *
06596  D8D2  B0 03              BCS     XXD8D7          ; BRANCH IF NUMBER
 IS +VE
06597  D8D4                     
06598  D8D4  20 47 D9           JSR     XXD947          ; NEGATE FAC1
06599  D8D7                     
06600  D8D7              ; NORMALISE FAC1
06601  D8D7              
06602  D8D7              XXD8D7 = *
06603  D8D7  A0 00              LDY     #$00               ; CLEAR Y
06604  D8D9  98                 TYA                    ; CLEAR A
06605  D8DA  18                 CLC                    ; CLEAR CARRY FOR A
DD
06606  D8DB              XXD8DB = *
06607  D8DB  A6 62              LDX     XX62          ; GET FAC1 MANTISSA 
1
06608  D8DD  D0 4A              BNE     XXD929          ; IF NOT ZERO NORM
ALISE FAC1
06609  D8DF                     
06610  D8DF  A6 63              LDX     XX63          ; GET FAC1 MANTISSA 
2
06611  D8E1  86 62              STX     XX62          ; SAVE FAC1 MANTISSA
 1
06612  D8E3  A6 64              LDX     XX64          ; GET FAC1 MANTISSA 
3
06613  D8E5  86 63              STX     XX63          ; SAVE FAC1 MANTISSA
 2
06614  D8E7  A6 65              LDX     XX65          ; GET FAC1 MANTISSA 
4
06615  D8E9  86 64              STX     XX64          ; SAVE FAC1 MANTISSA
 3
06616  D8EB  A6 70              LDX     XX70          ; GET FAC1 ROUNDING 
BYTE
06617  D8ED  86 65              STX     XX65          ; SAVE FAC1 MANTISSA
 4
06618  D8EF  84 70              STY     XX70          ; CLEAR FAC1 ROUNDIN
G BYTE
06619  D8F1  69 08              ADC     #$08               ; ADD X TO EXPO
NENT OFFSET
06620  D8F3  C9 20              CMP     #$20               ; COMPARE WITH 
$20, MAX OFFSET, ALL BITS WOULD BE = 0
06621  D8F5  D0 E4              BNE     XXD8DB          ; LOOP IF NOT MAX
06622  D8F7                     
06623  D8F7                     
06624  D8F7              ;************************************************
***********************************;
06625  D8F7              ;
06626  D8F7              ; CLEAR FAC1 EXPONENT AND SIGN
06627  D8F7              
06628  D8F7              XXD8F7 = *
06629  D8F7  A9 00              LDA     #$00               ; CLEAR A
06630  D8F9              XXD8F9 = *
06631  D8F9  85 61              STA     XX61          ; SET FAC1 EXPONENT
06632  D8FB                     
06633  D8FB              ; SAVE FAC1 SIGN
06634  D8FB              
06635  D8FB              XXD8FB = *
06636  D8FB  85 66              STA     XX66          ; SAVE FAC1 SIGN (B7
)
06637  D8FD  60                 RTS
06638  D8FE                     
06639  D8FE                     
06640  D8FE              ;************************************************
***********************************;
06641  D8FE              ;
06642  D8FE              ; ADD FAC2 MANTISSA TO FAC1 MANTISSA
06643  D8FE              






****;S......PAGE 0124

LINE# LOC   CODE        LINE


06644  D8FE              XXD8FE = *
06645  D8FE  65 56              ADC     XX56          ; ADD FAC2 ROUNDING 
BYTE
06646  D900  85 70              STA     XX70          ; SAVE FAC1 ROUNDING
 BYTE
06647  D902  A5 65              LDA     XX65          ; GET FAC1 MANTISSA 
4
06648  D904  65 6D              ADC     XX6D          ; ADD FAC2 MANTISSA 
4
06649  D906  85 65              STA     XX65          ; SAVE FAC1 MANTISSA
 4
06650  D908  A5 64              LDA     XX64          ; GET FAC1 MANTISSA 
3
06651  D90A  65 6C              ADC     XX6C          ; ADD FAC2 MANTISSA 
3
06652  D90C  85 64              STA     XX64          ; SAVE FAC1 MANTISSA
 3
06653  D90E  A5 63              LDA     XX63          ; GET FAC1 MANTISSA 
2
06654  D910  65 6B              ADC     XX6B          ; ADD FAC2 MANTISSA 
2
06655  D912  85 63              STA     XX63          ; SAVE FAC1 MANTISSA
 2
06656  D914  A5 62              LDA     XX62          ; GET FAC1 MANTISSA 
1
06657  D916  65 6A              ADC     XX6A          ; ADD FAC2 MANTISSA 
1
06658  D918  85 62              STA     XX62          ; SAVE FAC1 MANTISSA
 1
06659  D91A  4C 36 D9           JMP     XXD936          ; TEST AND NORMALI
SE FAC1 FOR C=0/1
06660  D91D                     
06661  D91D              XXD91D = *
06662  D91D  69 01              ADC     #$01               ; ADD 1 TO EXPO
NENT OFFSET
06663  D91F  06 70              ASL     XX70          ; SHIFT FAC1 ROUNDIN
G BYTE
06664  D921  26 65              ROL     XX65          ; SHIFT FAC1 MANTISS
A 4
06665  D923  26 64              ROL     XX64          ; SHIFT FAC1 MANTISS
A 3
06666  D925  26 63              ROL     XX63          ; SHIFT FAC1 MANTISS
A 2
06667  D927  26 62              ROL     XX62          ; SHIFT FAC1 MANTISS
A 1
06668  D929                     
06669  D929                     
06670  D929              ;************************************************
***********************************;
06671  D929              ;
06672  D929              ; NORMALISE FAC1
06673  D929              
06674  D929              XXD929 = *
06675  D929  10 F2              BPL     XXD91D          ; LOOP IF NOT NORM
ALISED
06676  D92B                     
06677  D92B  38                 SEC                    ; SET CARRY FOR SUB
TRACT
06678  D92C  E5 61              SBC     XX61          ; SUBTRACT FAC1 EXPO
NENT
06679  D92E  B0 C7              BCS     XXD8F7          ; BRANCH IF UNDERF
LOW (SET RESULT = $0)
06680  D930                     
06681  D930  49 FF              EOR     #$FF               ; COMPLEMENT EX
PONENT
06682  D932  69 01              ADC     #$01               ; +1 (TWOS COMP
LEMENT)
06683  D934  85 61              STA     XX61          ; SAVE FAC1 EXPONENT

06684  D936                     
06685  D936              ; TEST AND NORMALISE FAC1 FOR C=0/1
06686  D936              
06687  D936              XXD936 = *
06688  D936  90 0E              BCC     XXD946          ; EXIT IF NO OVERF
LOW
06689  D938                     
06690  D938              ; NORMALISE FAC1 FOR C=1
06691  D938              
06692  D938              XXD938 = *
06693  D938  E6 61              INC     XX61          ; INCREMENT FAC1 EXP
ONENT
06694  D93A  F0 42              BEQ     XXD97E          ; IF ZERO DO OVERF
LOW ERROR THEN WARM START
06695  D93C                     
06696  D93C  66 62              ROR     XX62          ; SHIFT FAC1 MANTISS
A 1
06697  D93E  66 63              ROR     XX63          ; SHIFT FAC1 MANTISS
A 2
06698  D940  66 64              ROR     XX64          ; SHIFT FAC1 MANTISS
A 3






****;S......PAGE 0125

LINE# LOC   CODE        LINE


06699  D942  66 65              ROR     XX65          ; SHIFT FAC1 MANTISS
A 4
06700  D944  66 70              ROR     XX70          ; SHIFT FAC1 ROUNDIN
G BYTE
06701  D946              XXD946 = *
06702  D946  60                 RTS
06703  D947                     
06704  D947                     
06705  D947              ;************************************************
***********************************;
06706  D947              ;
06707  D947              ; NEGATE FAC1
06708  D947              
06709  D947              XXD947 = *
06710  D947  A5 66              LDA     XX66          ; GET FAC1 SIGN (B7)

06711  D949  49 FF              EOR     #$FF               ; COMPLEMENT IT

06712  D94B  85 66              STA     XX66          ; SAVE FAC1 SIGN (B7
)
06713  D94D                     
06714  D94D              ; TWOS COMPLEMENT FAC1 MANTISSA
06715  D94D              
06716  D94D              XXD94D = *
06717  D94D  A5 62              LDA     XX62          ; GET FAC1 MANTISSA 
1
06718  D94F  49 FF              EOR     #$FF               ; COMPLEMENT IT

06719  D951  85 62              STA     XX62          ; SAVE FAC1 MANTISSA
 1
06720  D953  A5 63              LDA     XX63          ; GET FAC1 MANTISSA 
2
06721  D955  49 FF              EOR     #$FF               ; COMPLEMENT IT

06722  D957  85 63              STA     XX63          ; SAVE FAC1 MANTISSA
 2
06723  D959  A5 64              LDA     XX64          ; GET FAC1 MANTISSA 
3
06724  D95B  49 FF              EOR     #$FF               ; COMPLEMENT IT

06725  D95D  85 64              STA     XX64          ; SAVE FAC1 MANTISSA
 3
06726  D95F  A5 65              LDA     XX65          ; GET FAC1 MANTISSA 
4
06727  D961  49 FF              EOR     #$FF               ; COMPLEMENT IT

06728  D963  85 65              STA     XX65          ; SAVE FAC1 MANTISSA
 4
06729  D965  A5 70              LDA     XX70          ; GET FAC1 ROUNDING 
BYTE
06730  D967  49 FF              EOR     #$FF               ; COMPLEMENT IT

06731  D969  85 70              STA     XX70          ; SAVE FAC1 ROUNDING
 BYTE
06732  D96B  E6 70              INC     XX70          ; INCREMENT FAC1 ROU
NDING BYTE
06733  D96D  D0 0E              BNE     XXD97D          ; EXIT IF NO OVERF
LOW
06734  D96F                     
06735  D96F              ; INCREMENT FAC1 MANTISSA
06736  D96F              
06737  D96F              XXD96F = *
06738  D96F  E6 65              INC     XX65          ; INCREMENT FAC1 MAN
TISSA 4
06739  D971  D0 0A              BNE     XXD97D          ; FINISHED IF NO R
OLLOVER
06740  D973                     
06741  D973  E6 64              INC     XX64          ; INCREMENT FAC1 MAN
TISSA 3
06742  D975  D0 06              BNE     XXD97D          ; FINISHED IF NO R
OLLOVER
06743  D977                     
06744  D977  E6 63              INC     XX63          ; INCREMENT FAC1 MAN
TISSA 2
06745  D979  D0 02              BNE     XXD97D          ; FINISHED IF NO R
OLLOVER
06746  D97B                     
06747  D97B  E6 62              INC     XX62          ; INCREMENT FAC1 MAN
TISSA 1
06748  D97D              XXD97D = *
06749  D97D  60                 RTS
06750  D97E                     
06751  D97E                     
06752  D97E              ;************************************************
***********************************;
06753  D97E              ;






****;S......PAGE 0126

LINE# LOC   CODE        LINE


06754  D97E              ; DO OVERFLOW ERROR THEN WARM START
06755  D97E              
06756  D97E              XXD97E = *
06757  D97E  A2 0F              LDX     #$0F               ; ERROR $0F, OV
ERFLOW ERROR
06758  D980  4C 37 C4           JMP     XXC437          ; DO ERROR #X THEN
 WARM START
06759  D983                     
06760  D983                     
06761  D983              ;************************************************
***********************************;
06762  D983              ;
06763  D983              ; SHIFT FCATEMP << A+8 TIMES
06764  D983              
06765  D983              XXD983 = *
06766  D983  A2 25              LDX     #$25               ; SET OFFSET TO
 FACTEMP
06767  D985              XXD985 = *
06768  D985  B4 04              LDY     XX04,X          ; GET FACX MANTISS
A 4
06769  D987  84 70              STY     XX70          ; SAVE AS FAC1 ROUND
ING BYTE
06770  D989  B4 03              LDY     XX03,X          ; GET FACX MANTISS
A 3
06771  D98B  94 04              STY     XX04,X          ; SAVE FACX MANTIS
SA 4
06772  D98D  B4 02              LDY     XX02,X          ; GET FACX MANTISS
A 2
06773  D98F  94 03              STY     XX03,X          ; SAVE FACX MANTIS
SA 3
06774  D991  B4 01              LDY     XX01,X          ; GET FACX MANTISS
A 1
06775  D993  94 02              STY     XX02,X          ; SAVE FACX MANTIS
SA 2
06776  D995  A4 68              LDY     XX68          ; GET FAC1 OVERFLOW 
BYTE
06777  D997  94 01              STY     XX01,X          ; SAVE FACX MANTIS
SA 1
06778  D999                     
06779  D999              ; SHIFT FACX -A TIMES RIGHT (> 8 SHIFTS)
06780  D999              
06781  D999              XXD999 = *
06782  D999  69 08              ADC     #$08               ; ADD 8 TO SHIF
T COUNT
06783  D99B  30 E8              BMI     XXD985          ; GO DO 8 SHIFT IF
 STILL -VE
06784  D99D                     
06785  D99D  F0 E6              BEQ     XXD985          ; GO DO 8 SHIFT IF
 ZERO
06786  D99F                     
06787  D99F  E9 08              SBC     #$08               ; ELSE SUBTRACT
 8 AGAIN
06788  D9A1  A8                 TAY                    ; SAVE COUNT TO Y
06789  D9A2  A5 70              LDA     XX70          ; GET FAC1 ROUNDING 
BYTE
06790  D9A4  B0 14              BCS     XXD9BA          ;.
06791  D9A6                     
06792  D9A6              XXD9A6 = *
06793  D9A6  16 01              ASL     XX01,X          ; SHIFT FACX MANTI
SSA 1
06794  D9A8  90 02              BCC     XXD9AC          ; BRANCH IF +VE
06795  D9AA                     
06796  D9AA  F6 01              INC     XX01,X          ; THIS SETS B7 EVE
NTUALLY
06797  D9AC              XXD9AC = *
06798  D9AC  76 01              ROR     XX01,X          ; SHIFT FACX MANTI
SSA 1 (CORRECT FOR ASL)
06799  D9AE  76 01              ROR     XX01,X          ; SHIFT FACX MANTI
SSA 1 (PUT CARRY IN B7)
06800  D9B0                     
06801  D9B0              ; SHIFT FACX Y TIMES RIGHT
06802  D9B0              
06803  D9B0              XXD9B0 = *
06804  D9B0  76 02              ROR     XX02,X          ; SHIFT FACX MANTI
SSA 2
06805  D9B2  76 03              ROR     XX03,X          ; SHIFT FACX MANTI
SSA 3
06806  D9B4  76 04              ROR     XX04,X          ; SHIFT FACX MANTI
SSA 4
06807  D9B6  6A                 ROR A                  ; SHIFT FACX ROUNDI
NG BYTE
06808  D9B7  C8                 INY                    ; INCREMENT EXPONEN
T DIFF






****;S......PAGE 0127

LINE# LOC   CODE        LINE


06809  D9B8  D0 EC              BNE     XXD9A6          ; BRANCH IF RANGE 
ADJUST NOT COMPLETE
06810  D9BA                     
06811  D9BA              XXD9BA = *
06812  D9BA  18                 CLC                    ; JUST CLEAR IT
06813  D9BB  60                 RTS
06814  D9BC                     
06815  D9BC                     
06816  D9BC              ;************************************************
***********************************;
06817  D9BC              ;
06818  D9BC              ; CONSTANTS AND SERIES FOR LOG(N)
06819  D9BC              
06820  D9BC              XXD9BC = *
06821  D9BC  81                 .BYTE     $81,$00,$00,$00,$00     ; 1
06821  D9BD  00 
06821  D9BE  00 
06821  D9BF  00 
06821  D9C0  00 
06822  D9C1                     
06823  D9C1              XXD9C1 = *
06824  D9C1  03                 .BYTE     $03                    ; SERIES 
COUNTER
06825  D9C2  7F                 .BYTE     $7F,$5E,$56,$CB,$79
06825  D9C3  5E 
06825  D9C4  56 
06825  D9C5  CB 
06825  D9C6  79 
06826  D9C7  80                 .BYTE     $80,$13,$9B,$0B,$64
06826  D9C8  13 
06826  D9C9  9B 
06826  D9CA  0B 
06826  D9CB  64 
06827  D9CC  80                 .BYTE     $80,$76,$38,$93,$16
06827  D9CD  76 
06827  D9CE  38 
06827  D9CF  93 
06827  D9D0  16 
06828  D9D1  82                 .BYTE     $82,$38,$AA,$3B,$20
06828  D9D2  38 
06828  D9D3  AA 
06828  D9D4  3B 
06828  D9D5  20 
06829  D9D6                     
06830  D9D6              XXD9D6 = *
06831  D9D6  80                 .BYTE     $80,$35,$04,$F3,$34     ; 0.7071
1     1/ROOT 2
06831  D9D7  35 
06831  D9D8  04 
06831  D9D9  F3 
06831  D9DA  34 
06832  D9DB              XXD9DB = *
06833  D9DB  81                 .BYTE     $81,$35,$04,$F3,$34     ; 1.4142
1     ROOT 2
06833  D9DC  35 
06833  D9DD  04 
06833  D9DE  F3 
06833  D9DF  34 
06834  D9E0              XXD9E0 = *
06835  D9E0  80                 .BYTE     $80,$80,$00,$00,$00     ; -0.5  
   1/2






****;S......PAGE 0128

LINE# LOC   CODE        LINE


06835  D9E1  80 
06835  D9E2  00 
06835  D9E3  00 
06835  D9E4  00 
06836  D9E5              XXD9E5 = *
06837  D9E5  80                 .BYTE     $80,$31,$72,$17,$F8     ; 0.6931
5     LOG(2)
06837  D9E6  31 
06837  D9E7  72 
06837  D9E8  17 
06837  D9E9  F8 
06838  D9EA                     
06839  D9EA                     
06840  D9EA              ;************************************************
***********************************;
06841  D9EA              ;
06842  D9EA              ; PERFORM LOG()
06843  D9EA              
06844  D9EA              XXD9EA = *
06845  D9EA  20 2B DC           JSR     XXDC2B          ; TEST SIGN AND ZE
RO
06846  D9ED  F0 02              BEQ     XXD9F1          ; IF ZERO DO ILLEG
AL QUANTITY ERROR THEN WARM START
06847  D9EF                     
06848  D9EF  10 03              BPL     XXD9F4          ; SKIP ERROR IF +V
E
06849  D9F1                     
06850  D9F1              XXD9F1 = *
06851  D9F1  4C 48 D2           JMP     XXD248          ; DO ILLEGAL QUANT
ITY ERROR THEN WARM START
06852  D9F4                     
06853  D9F4              XXD9F4 = *
06854  D9F4  A5 61              LDA     XX61          ; GET FAC1 EXPONENT
06855  D9F6  E9 7F              SBC     #$7F               ; NORMALISE IT
06856  D9F8  48                 PHA                    ; SAVE IT
06857  D9F9  A9 80              LDA     #$80               ; SET EXPONENT 
TO ZERO
06858  D9FB  85 61              STA     XX61          ; SAVE FAC1 EXPONENT

06859  D9FD  A9 D6              LDA     #<XXD9D6          ; POINTER TO 1/R
OOT 2 LOW BYTE
06860  D9FF  A0 D9              LDY     #>XXD9D6          ; POINTER TO 1/R
OOT 2 HIGH BYTE
06861  DA01  20 67 D8           JSR     XXD867          ; ADD (AY) TO FAC1
 (1/ROOT2)
06862  DA04  A9 DB              LDA     #<XXD9DB          ; POINTER TO ROO
T 2 LOW BYTE
06863  DA06  A0 D9              LDY     #>XXD9DB          ; POINTER TO ROO
T 2 HIGH BYTE
06864  DA08  20 0F DB           JSR     XXDB0F          ; CONVERT AY AND D
O (AY)/FAC1 (ROOT2/(X+(1/ROOT2)))
06865  DA0B  A9 BC              LDA     #<XXD9BC          ; POINTER TO 1 L
OW BYTE
06866  DA0D  A0 D9              LDY     #>XXD9BC          ; POINTER TO 1 H
IGH BYTE
06867  DA0F  20 50 D8           JSR     XXD850          ; SUBTRACT FAC1 ((
ROOT2/(X+(1/ROOT2)))-1) FROM (AY)
06868  DA12  A9 C1              LDA     #<XXD9C1          ; POINTER TO SER
IES FOR LOG(N) LOW BYTE
06869  DA14  A0 D9              LDY     #>XXD9C1          ; POINTER TO SER
IES FOR LOG(N) HIGH BYTE
06870  DA16  20 40 E0           JSR     XXE040          ; ^2 THEN SERIES E
VALUATION
06871  DA19  A9 E0              LDA     #<XXD9E0          ; POINTER TO -0.
5 LOW BYTE
06872  DA1B  A0 D9              LDY     #>XXD9E0          ; POINTER TO -0.
5 HIGH BYTE
06873  DA1D  20 67 D8           JSR     XXD867          ; ADD (AY) TO FAC1

06874  DA20  68                 PLA                    ; RESTORE FAC1 EXPO
NENT
06875  DA21  20 7E DD           JSR     XXDD7E          ; EVALUATE NEW ASC
II DIGIT
06876  DA24  A9 E5              LDA     #<XXD9E5          ; POINTER TO LOG
(2) LOW BYTE
06877  DA26  A0 D9              LDY     #>XXD9E5          ; POINTER TO LOG
(2) HIGH BYTE
06878  DA28                     
06879  DA28              ; DO CONVERT AY, FCA1*(AY)
06880  DA28              
06881  DA28              XXDA28 = *
06882  DA28  20 8C DA           JSR     XXDA8C          ; UNPACK MEMORY (A
Y) INTO FAC2






****;S......PAGE 0129

LINE# LOC   CODE        LINE


06883  DA2B              XXDA2B = *
06884  DA2B  D0 03              BNE     XXDA30          ; MULTIPLY FAC1 BY
 FAC2 ??
06885  DA2D                     
06886  DA2D  4C 8B DA           JMP     XXDA8B          ; EXIT IF ZERO
06887  DA30                     
06888  DA30              XXDA30 = *
06889  DA30  20 B7 DA           JSR     XXDAB7          ; TEST AND ADJUST 
ACCUMULATORS
06890  DA33  A9 00              LDA     #$00               ; CLEAR A
06891  DA35  85 26              STA     XX26          ; CLEAR TEMP MANTISS
A 1
06892  DA37  85 27              STA     XX27          ; CLEAR TEMP MANTISS
A 2
06893  DA39  85 28              STA     XX28          ; CLEAR TEMP MANTISS
A 3
06894  DA3B  85 29              STA     XX29          ; CLEAR TEMP MANTISS
A 4
06895  DA3D  A5 70              LDA     XX70          ; GET FAC1 ROUNDING 
BYTE
06896  DA3F  20 59 DA           JSR     XXDA59          ; GO DO SHIFT/ADD 
FAC2
06897  DA42  A5 65              LDA     XX65          ; GET FAC1 MANTISSA 
4
06898  DA44  20 59 DA           JSR     XXDA59          ; GO DO SHIFT/ADD 
FAC2
06899  DA47  A5 64              LDA     XX64          ; GET FAC1 MANTISSA 
3
06900  DA49  20 59 DA           JSR     XXDA59          ; GO DO SHIFT/ADD 
FAC2
06901  DA4C  A5 63              LDA     XX63          ; GET FAC1 MANTISSA 
2
06902  DA4E  20 59 DA           JSR     XXDA59          ; GO DO SHIFT/ADD 
FAC2
06903  DA51  A5 62              LDA     XX62          ; GET FAC1 MANTISSA 
1
06904  DA53  20 5E DA           JSR     XXDA5E          ; GO DO SHIFT/ADD 
FAC2
06905  DA56  4C 8F DB           JMP     XXDB8F          ; COPY TEMP TO FAC
1, NORMALISE AND RETURN
06906  DA59                     
06907  DA59              XXDA59 = *
06908  DA59  D0 03              BNE     XXDA5E          ; BRANCH IF BYTE <
> ZERO
06909  DA5B                     
06910  DA5B  4C 83 D9           JMP     XXD983          ; SHIFT FCATEMP <<
 A+8 TIMES
06911  DA5E                     
06912  DA5E                                     ; ELSE DO SHIFT AND ADD
06913  DA5E              XXDA5E = *
06914  DA5E  4A                 LSR A                  ; SHIFT BYTE
06915  DA5F  09 80              ORA     #$80               ; SET TOP BIT (
MARK FOR 8 TIMES)
06916  DA61              XXDA61 = *
06917  DA61  A8                 TAY                    ; COPY RESULT
06918  DA62  90 19              BCC     XXDA7D          ; SKIP NEXT IF BIT
 WAS ZERO
06919  DA64                     
06920  DA64  18                 CLC                    ; CLEAR CARRY FOR A
DD
06921  DA65  A5 29              LDA     XX29          ; GET TEMP MANTISSA 
4
06922  DA67  65 6D              ADC     XX6D          ; ADD FAC2 MANTISSA 
4
06923  DA69  85 29              STA     XX29          ; SAVE TEMP MANTISSA
 4
06924  DA6B  A5 28              LDA     XX28          ; GET TEMP MANTISSA 
3
06925  DA6D  65 6C              ADC     XX6C          ; ADD FAC2 MANTISSA 
3
06926  DA6F  85 28              STA     XX28          ; SAVE TEMP MANTISSA
 3
06927  DA71  A5 27              LDA     XX27          ; GET TEMP MANTISSA 
2
06928  DA73  65 6B              ADC     XX6B          ; ADD FAC2 MANTISSA 
2
06929  DA75  85 27              STA     XX27          ; SAVE TEMP MANTISSA
 2
06930  DA77  A5 26              LDA     XX26          ; GET TEMP MANTISSA 
1
06931  DA79  65 6A              ADC     XX6A          ; ADD FAC2 MANTISSA 
1
06932  DA7B  85 26              STA     XX26          ; SAVE TEMP MANTISSA
 1
06933  DA7D              XXDA7D = *
06934  DA7D  66 26              ROR     XX26          ; SHIFT TEMP MANTISS
A 1
06935  DA7F  66 27              ROR     XX27          ; SHIFT TEMP MANTISS
A 2
06936  DA81  66 28              ROR     XX28          ; SHIFT TEMP MANTISS
A 3
06937  DA83  66 29              ROR     XX29          ; SHIFT TEMP MANTISS
A 4






****;S......PAGE 0130

LINE# LOC   CODE        LINE


06938  DA85  66 70              ROR     XX70          ; SHIFT TEMP ROUNDIN
G BYTE
06939  DA87  98                 TYA                    ; GET BYTE BACK
06940  DA88  4A                 LSR A                  ; SHIFT BYTE
06941  DA89  D0 D6              BNE     XXDA61          ; LOOP IF ALL BITS
 NOT DONE
06942  DA8B                     
06943  DA8B              XXDA8B = *
06944  DA8B  60                 RTS
06945  DA8C                     
06946  DA8C                     
06947  DA8C              ;************************************************
***********************************;
06948  DA8C              ;
06949  DA8C              ; UNPACK MEMORY (AY) INTO FAC2
06950  DA8C              
06951  DA8C              XXDA8C = *
06952  DA8C  85 22              STA     XX22          ; SAVE POINTER LOW B
YTE
06953  DA8E  84 23              STY     XX23          ; SAVE POINTER HIGH 
BYTE
06954  DA90  A0 04              LDY     #$04               ; 5 BYTES TO GE
T (0-4)
06955  DA92  B1 22              LDA     (XX22),Y          ; GET MANTISSA 4

06956  DA94  85 6D              STA     XX6D          ; SAVE FAC2 MANTISSA
 4
06957  DA96  88                 DEY                    ; DECREMENT INDEX
06958  DA97  B1 22              LDA     (XX22),Y          ; GET MANTISSA 3

06959  DA99  85 6C              STA     XX6C          ; SAVE FAC2 MANTISSA
 3
06960  DA9B  88                 DEY                    ; DECREMENT INDEX
06961  DA9C  B1 22              LDA     (XX22),Y          ; GET MANTISSA 2

06962  DA9E  85 6B              STA     XX6B          ; SAVE FAC2 MANTISSA
 2
06963  DAA0  88                 DEY                    ; DECREMENT INDEX
06964  DAA1  B1 22              LDA     (XX22),Y          ; GET MANTISSA 1
 + SIGN
06965  DAA3  85 6E              STA     XX6E          ; SAVE FAC2 SIGN (B7
)
06966  DAA5  45 66              EOR     XX66          ; EOR WITH FAC1 SIGN
 (B7)
06967  DAA7  85 6F              STA     XX6F          ; SAVE SIGN COMPARE 
(FAC1 EOR FAC2)
06968  DAA9  A5 6E              LDA     XX6E          ; RECOVER FAC2 SIGN 
(B7)
06969  DAAB  09 80              ORA     #$80               ; SET 1XXX XXX 
(SET NORMAL BIT)
06970  DAAD  85 6A              STA     XX6A          ; SAVE FAC2 MANTISSA
 1
06971  DAAF  88                 DEY                    ; DECREMENT INDEX
06972  DAB0  B1 22              LDA     (XX22),Y          ; GET EXPONENT B
YTE
06973  DAB2  85 69              STA     XX69          ; SAVE FAC2 EXPONENT

06974  DAB4  A5 61              LDA     XX61          ; GET FAC1 EXPONENT
06975  DAB6  60                 RTS
06976  DAB7                     
06977  DAB7                     
06978  DAB7              ;************************************************
***********************************;
06979  DAB7              ;
06980  DAB7              ; TEST AND ADJUST ACCUMULATORS
06981  DAB7              
06982  DAB7              XXDAB7 = *
06983  DAB7  A5 69              LDA     XX69          ; GET FAC2 EXPONENT
06984  DAB9                     
06985  DAB9              XXDAB9 = *
06986  DAB9  F0 1F              BEQ     XXDADA          ; BRANCH IF FAC2 =
 $00 (HANDLE UNDERFLOW)
06987  DABB                     
06988  DABB  18                 CLC                    ; CLEAR CARRY FOR A
DD
06989  DABC  65 61              ADC     XX61          ; ADD FAC1 EXPONENT
06990  DABE  90 04              BCC     XXDAC4          ; BRANCH IF SUM OF
 EXPONENTS < $0100
06991  DAC0                     
06992  DAC0  30 1D              BMI     XXDADF          ; DO OVERFLOW ERRO
R






****;S......PAGE 0131

LINE# LOC   CODE        LINE


06993  DAC2                     
06994  DAC2  18                 CLC                    ; CLEAR CARRY FOR T
HE ADD
06995  DAC3  2C                 .BYTE     $2C               ; MAKES NEXT L
INE BIT XX1410
06996  DAC4              XXDAC4 = *
06997  DAC4  10 14              BPL     XXDADA          ; IF +VE GO HANDLE
 UNDERFLOW
06998  DAC6                     
06999  DAC6  69 80              ADC     #$80               ; ADJUST EXPONE
NT
07000  DAC8  85 61              STA     XX61          ; SAVE FAC1 EXPONENT

07001  DACA  D0 03              BNE     XXDACF          ; BRANCH IF NOT ZE
RO
07002  DACC                     
07003  DACC  4C FB D8           JMP     XXD8FB          ; SAVE FAC1 SIGN A
ND RETURN
07004  DACF                     
07005  DACF                     
07006  DACF              XXDACF = *
07007  DACF  A5 6F              LDA     XX6F          ; GET SIGN COMPARE (
FAC1 EOR FAC2)
07008  DAD1  85 66              STA     XX66          ; SAVE FAC1 SIGN (B7
)
07009  DAD3  60                 RTS
07010  DAD4                     
07011  DAD4                     
07012  DAD4              ;************************************************
***********************************;
07013  DAD4              ;
07014  DAD4              ; HANDLE OVERFLOW AND UNDERFLOW
07015  DAD4              
07016  DAD4              XXDAD4 = *
07017  DAD4  A5 66              LDA     XX66          ; GET FAC1 SIGN (B7)

07018  DAD6  49 FF              EOR     #$FF               ; COMPLEMENT IT

07019  DAD8  30 05              BMI     XXDADF          ; DO OVERFLOW ERRO
R
07020  DADA                     
07021  DADA                                     ; HANDLE UNDERFLOW
07022  DADA              XXDADA = *
07023  DADA  68                 PLA                    ; POP RETURN ADDRES
S LOW BYTE
07024  DADB  68                 PLA                    ; POP RETURN ADDRES
S HIGH BYTE
07025  DADC  4C F7 D8           JMP     XXD8F7          ; CLEAR FAC1 EXPON
ENT AND SIGN AND RETURN
07026  DADF                     
07027  DADF              XXDADF = *
07028  DADF  4C 7E D9           JMP     XXD97E          ; DO OVERFLOW ERRO
R THEN WARM START
07029  DAE2                     
07030  DAE2                     
07031  DAE2              ;************************************************
***********************************;
07032  DAE2              ;
07033  DAE2              ; MULTIPLY FAC1 BY 10
07034  DAE2              
07035  DAE2              XXDAE2 = *
07036  DAE2  20 0C DC           JSR     XXDC0C          ; ROUND AND COPY F
AC1 TO FAC2
07037  DAE5  AA                 TAX                    ; COPY EXPONENT (SE
T THE FLAGS)
07038  DAE6  F0 10              BEQ     XXDAF8          ; EXIT IF ZERO
07039  DAE8                     
07040  DAE8  18                 CLC                    ; CLEAR CARRY FOR A
DD
07041  DAE9  69 02              ADC     #$02               ; ADD TWO TO EX
PONENT (*4)
07042  DAEB  B0 F2              BCS     XXDADF          ; DO OVERFLOW ERRO
R IF > $FF
07043  DAED                     
07044  DAED              ; FAC1 = (FAC1 + FAC2) * 2
07045  DAED              
07046  DAED              XXDAED = *
07047  DAED  A2 00              LDX     #$00               ; CLEAR BYTE






****;S......PAGE 0132

LINE# LOC   CODE        LINE


07048  DAEF  86 6F              STX     XX6F          ; CLEAR SIGN COMPARE
 (FAC1 EOR FAC2)
07049  DAF1  20 77 D8           JSR     XXD877          ; ADD FAC2 TO FAC1
 (*5)
07050  DAF4  E6 61              INC     XX61          ; INCREMENT FAC1 EXP
ONENT (*10)
07051  DAF6  F0 E7              BEQ     XXDADF          ; IF EXPONENT NOW 
ZERO GO DO OVERFLOW ERROR
07052  DAF8                     
07053  DAF8              XXDAF8 = *
07054  DAF8  60                 RTS
07055  DAF9                     
07056  DAF9                     
07057  DAF9              ;************************************************
***********************************;
07058  DAF9              ;
07059  DAF9              ; 10 AS A FLOATING VALUE
07060  DAF9              
07061  DAF9              XXDAF9 = *
07062  DAF9  84                 .BYTE     $84,$20,$00,$00,$00     ; 10
07062  DAFA  20 
07062  DAFB  00 
07062  DAFC  00 
07062  DAFD  00 
07063  DAFE                     
07064  DAFE                     
07065  DAFE              ;************************************************
***********************************;
07066  DAFE              ;
07067  DAFE              ; DIVIDE FAC1 BY 10
07068  DAFE              
07069  DAFE              XXDAFE = *
07070  DAFE  20 0C DC           JSR     XXDC0C          ; ROUND AND COPY F
AC1 TO FAC2
07071  DB01  A9 F9              LDA     #<XXDAF9          ; SET 10 POINTER
 LOW BYTE
07072  DB03  A0 DA              LDY     #>XXDAF9          ; SET 10 POINTER
 HIGH BYTE
07073  DB05  A2 00              LDX     #$00               ; CLEAR SIGN
07074  DB07                     
07075  DB07              ; DIVIDE BY (AY) (X=SIGN)
07076  DB07              
07077  DB07              XXDB07 = *
07078  DB07  86 6F              STX     XX6F          ; SAVE SIGN COMPARE 
(FAC1 EOR FAC2)
07079  DB09  20 A2 DB           JSR     XXDBA2          ; UNPACK MEMORY (A
Y) INTO FAC1
07080  DB0C  4C 12 DB           JMP     XXDB12          ; DO FAC2/FAC1
07081  DB0F                     
07082  DB0F                                     ; PERFORM DIVIDE-BY
07083  DB0F                     
07084  DB0F              ; CONVERT AY AND DO (AY)/FAC1
07085  DB0F              
07086  DB0F              XXDB0F = *
07087  DB0F  20 8C DA           JSR     XXDA8C          ; UNPACK MEMORY (A
Y) INTO FAC2
07088  DB12              XXDB12 = *
07089  DB12  F0 76              BEQ     XXDB8A          ; IF ZERO GO DO /0
 ERROR
07090  DB14                     
07091  DB14  20 1B DC           JSR     XXDC1B          ; ROUND FAC1
07092  DB17  A9 00              LDA     #$00               ; CLEAR A
07093  DB19  38                 SEC                    ; SET CARRY FOR SUB
TRACT
07094  DB1A  E5 61              SBC     XX61          ; SUBTRACT FAC1 EXPO
NENT (2S COMPLEMENT)
07095  DB1C  85 61              STA     XX61          ; SAVE FAC1 EXPONENT

07096  DB1E  20 B7 DA           JSR     XXDAB7          ; TEST AND ADJUST 
ACCUMULATORS
07097  DB21  E6 61              INC     XX61          ; INCREMENT FAC1 EXP
ONENT
07098  DB23  F0 BA              BEQ     XXDADF          ; IF ZERO DO OVERF
LOW ERROR






****;S......PAGE 0133

LINE# LOC   CODE        LINE


07099  DB25                     
07100  DB25  A2 FC              LDX     #$FC               ; SET INDEX TO 
FAC TEMP
07101  DB27  A9 01              LDA     #$01               ;.SET BYTE
07102  DB29              XXDB29 = *
07103  DB29  A4 6A              LDY     XX6A          ; GET FAC2 MANTISSA 
1
07104  DB2B  C4 62              CPY     XX62          ; COMPARE FAC1 MANTI
SSA 1
07105  DB2D  D0 10              BNE     XXDB3F          ; IF <> GO USE THE
 RESULT
07106  DB2F                     
07107  DB2F  A4 6B              LDY     XX6B          ; GET FAC2 MANTISSA 
2
07108  DB31  C4 63              CPY     XX63          ; COMPARE FAC1 MANTI
SSA 2
07109  DB33  D0 0A              BNE     XXDB3F          ; IF <> GO USE THE
 RESULT
07110  DB35                     
07111  DB35  A4 6C              LDY     XX6C          ; GET FAC2 MANTISSA 
3
07112  DB37  C4 64              CPY     XX64          ; COMPARE FAC1 MANTI
SSA 3
07113  DB39  D0 04              BNE     XXDB3F          ; IF <> GO USE THE
 RESULT
07114  DB3B                     
07115  DB3B  A4 6D              LDY     XX6D          ; GET FAC2 MANTISSA 
4
07116  DB3D  C4 65              CPY     XX65          ; COMPARE FAC1 MANTI
SSA 4
07117  DB3F              XXDB3F = *
07118  DB3F  08                 PHP                    ; SAVE THE FAC2-FAC
1 COMPARE STATUS
07119  DB40  2A                 ROL A                  ;.SHIFT BYTE
07120  DB41  90 09              BCC     XXDB4C          ; SKIP NEXT IF NO 
CARRY
07121  DB43                     
07122  DB43  E8                 INX                    ; INCREMENT INDEX T
O FAC TEMP
07123  DB44  95 29              STA     XX29,X          ;.
07124  DB46  F0 32              BEQ     XXDB7A          ;.
07125  DB48                     
07126  DB48  10 34              BPL     XXDB7E          ;.
07127  DB4A                     
07128  DB4A  A9 01              LDA     #$01               ;.
07129  DB4C              XXDB4C = *
07130  DB4C  28                 PLP                    ; RESTORE FAC2-FAC1
 COMPARE STATUS
07131  DB4D  B0 0E              BCS     XXDB5D          ; IF FAC2 >= FAC1 
THEN DO SUBTRACT
07132  DB4F                     
07133  DB4F                                     ; FAC2 = FAC2*2
07134  DB4F              XXDB4F = *
07135  DB4F  06 6D              ASL     XX6D          ; SHIFT FAC2 MANTISS
A 4
07136  DB51  26 6C              ROL     XX6C          ; SHIFT FAC2 MANTISS
A 3
07137  DB53  26 6B              ROL     XX6B          ; SHIFT FAC2 MANTISS
A 2
07138  DB55  26 6A              ROL     XX6A          ; SHIFT FAC2 MANTISS
A 1
07139  DB57  B0 E6              BCS     XXDB3F          ; LOOP WITH NO COM
PARE
07140  DB59                     
07141  DB59  30 CE              BMI     XXDB29          ; LOOP WITH COMPAR
E
07142  DB5B                     
07143  DB5B  10 E2              BPL     XXDB3F          ; LOOP ALWAYS WITH
 NO COMPARE
07144  DB5D                     
07145  DB5D              XXDB5D = *
07146  DB5D  A8                 TAY                    ; SAVE FAC2-FAC1 CO
MPARE STATUS
07147  DB5E  A5 6D              LDA     XX6D          ; GET FAC2 MANTISSA 
4
07148  DB60  E5 65              SBC     XX65          ; SUBTRACT FAC1 MANT
ISSA 4
07149  DB62  85 6D              STA     XX6D          ; SAVE FAC2 MANTISSA
 4
07150  DB64  A5 6C              LDA     XX6C          ; GET FAC2 MANTISSA 
3
07151  DB66  E5 64              SBC     XX64          ; SUBTRACT FAC1 MANT
ISSA 3
07152  DB68  85 6C              STA     XX6C          ; SAVE FAC2 MANTISSA
 3
07153  DB6A  A5 6B              LDA     XX6B          ; GET FAC2 MANTISSA 
2






****;S......PAGE 0134

LINE# LOC   CODE        LINE


07154  DB6C  E5 63              SBC     XX63          ; SUBTRACT FAC1 MANT
ISSA 2
07155  DB6E  85 6B              STA     XX6B          ; SAVE FAC2 MANTISSA
 2
07156  DB70  A5 6A              LDA     XX6A          ; GET FAC2 MANTISSA 
1
07157  DB72  E5 62              SBC     XX62          ; SUBTRACT FAC1 MANT
ISSA 1
07158  DB74  85 6A              STA     XX6A          ; SAVE FAC2 MANTISSA
 1
07159  DB76  98                 TYA                    ; RESTORE FAC2-FAC1
 COMPARE STATUS
07160  DB77  4C 4F DB           JMP     XXDB4F          ; GO SHIFT FAC2
07161  DB7A                     
07162  DB7A              XXDB7A = *
07163  DB7A  A9 40              LDA     #$40               ;.
07164  DB7C  D0 CE              BNE     XXDB4C          ; BRANCH ALWAYS
07165  DB7E                     
07166  DB7E              ; DO A<<6, SAVE AS FAC1 ROUNDING BYTE, NORMALISE 
AND RETURN
07167  DB7E              
07168  DB7E              XXDB7E = *
07169  DB7E  0A                 ASL A                  ; 
07170  DB7F  0A                 ASL A                  ; 
07171  DB80  0A                 ASL A                  ; 
07172  DB81  0A                 ASL A                  ; 
07173  DB82  0A                 ASL A                  ; 
07174  DB83  0A                 ASL A                  ; 
07175  DB84  85 70              STA     XX70          ; SAVE FAC1 ROUNDING
 BYTE
07176  DB86  28                 PLP                    ; DUMP FAC2-FAC1 CO
MPARE STATUS
07177  DB87  4C 8F DB           JMP     XXDB8F          ; COPY TEMP TO FAC
1, NORMALISE AND RETURN
07178  DB8A                     
07179  DB8A              ; DO 'DIVIDE BY ZERO' ERROR
07180  DB8A              
07181  DB8A              XXDB8A = *
07182  DB8A  A2 14              LDX     #$14               ; ERROR $14, DI
VIDE BY ZERO ERROR
07183  DB8C  4C 37 C4           JMP     XXC437          ; DO ERROR #X THEN
 WARM START
07184  DB8F                     
07185  DB8F              XXDB8F = *
07186  DB8F  A5 26              LDA     XX26          ; GET TEMP MANTISSA 
1
07187  DB91  85 62              STA     XX62          ; SAVE FAC1 MANTISSA
 1
07188  DB93  A5 27              LDA     XX27          ; GET TEMP MANTISSA 
2
07189  DB95  85 63              STA     XX63          ; SAVE FAC1 MANTISSA
 2
07190  DB97  A5 28              LDA     XX28          ; GET TEMP MANTISSA 
3
07191  DB99  85 64              STA     XX64          ; SAVE FAC1 MANTISSA
 3
07192  DB9B  A5 29              LDA     XX29          ; GET TEMP MANTISSA 
4
07193  DB9D  85 65              STA     XX65          ; SAVE FAC1 MANTISSA
 4
07194  DB9F  4C D7 D8           JMP     XXD8D7          ; NORMALISE FAC1 A
ND RETURN
07195  DBA2                     
07196  DBA2                     
07197  DBA2              ;************************************************
***********************************;
07198  DBA2              ;
07199  DBA2              ; UNPACK MEMORY (AY) INTO FAC1
07200  DBA2              
07201  DBA2              XXDBA2 = *
07202  DBA2  85 22              STA     XX22          ; SAVE POINTER LOW B
YTE
07203  DBA4  84 23              STY     XX23          ; SAVE POINTER HIGH 
BYTE
07204  DBA6  A0 04              LDY     #$04               ; 5 BYTES TO DO

07205  DBA8  B1 22              LDA     (XX22),Y          ; GET FIFTH BYTE

07206  DBAA  85 65              STA     XX65          ; SAVE FAC1 MANTISSA
 4
07207  DBAC  88                 DEY                    ; DECREMENT INDEX
07208  DBAD  B1 22              LDA     (XX22),Y          ; GET FOURTH BYT
E






****;S......PAGE 0135

LINE# LOC   CODE        LINE


07209  DBAF  85 64              STA     XX64          ; SAVE FAC1 MANTISSA
 3
07210  DBB1  88                 DEY                    ; DECREMENT INDEX
07211  DBB2  B1 22              LDA     (XX22),Y          ; GET THIRD BYTE

07212  DBB4  85 63              STA     XX63          ; SAVE FAC1 MANTISSA
 2
07213  DBB6  88                 DEY                    ; DECREMENT INDEX
07214  DBB7  B1 22              LDA     (XX22),Y          ; GET SECOND BYT
E
07215  DBB9  85 66              STA     XX66          ; SAVE FAC1 SIGN (B7
)
07216  DBBB  09 80              ORA     #$80               ; SET 1XXX XXXX
 (ADD NORMAL BIT)
07217  DBBD  85 62              STA     XX62          ; SAVE FAC1 MANTISSA
 1
07218  DBBF  88                 DEY                    ; DECREMENT INDEX
07219  DBC0  B1 22              LDA     (XX22),Y          ; GET FIRST BYTE
 (EXPONENT)
07220  DBC2  85 61              STA     XX61          ; SAVE FAC1 EXPONENT

07221  DBC4  84 70              STY     XX70          ; CLEAR FAC1 ROUNDIN
G BYTE
07222  DBC6  60                 RTS
07223  DBC7                     
07224  DBC7                     
07225  DBC7              ;************************************************
***********************************;
07226  DBC7              ;
07227  DBC7              ; PACK FAC1 INTO XX5C
07228  DBC7              
07229  DBC7              XXDBC7 = *
07230  DBC7  A2 5C              LDX     #<XX5C          ; SET POINTER LOW 
BYTE
07231  DBC9  2C                 .BYTE     $2C               ; MAKES NEXT L
INE BIT XX57A2
07232  DBCA                     
07233  DBCA              ; PACK FAC1 INTO XX57
07234  DBCA              
07235  DBCA              XXDBCA = *
07236  DBCA  A2 57              LDX     #<XX57          ; SET POINTER LOW 
BYTE
07237  DBCC  A0 00              LDY     #>XX57          ; SET POINTER HIGH
 BYTE
07238  DBCE  F0 04              BEQ     XXDBD4          ; PACK FAC1 INTO (
XY) AND RETURN, BRANCH ALWAYS
07239  DBD0                     
07240  DBD0              ; PACK FAC1 INTO VARIABLE POINTER
07241  DBD0              
07242  DBD0              XXDBD0 = *
07243  DBD0  A6 49              LDX     XX49          ; GET DESTINATION PO
INTER LOW BYTE
07244  DBD2  A4 4A              LDY     XX4A          ; GET DESTINATION PO
INTER HIGH BYTE
07245  DBD4                     
07246  DBD4              ; PACK FAC1 INTO (XY)
07247  DBD4              
07248  DBD4              XXDBD4 = *
07249  DBD4  20 1B DC           JSR     XXDC1B          ; ROUND FAC1
07250  DBD7  86 22              STX     XX22          ; SAVE POINTER LOW B
YTE
07251  DBD9  84 23              STY     XX23          ; SAVE POINTER HIGH 
BYTE
07252  DBDB  A0 04              LDY     #$04               ; SET INDEX
07253  DBDD  A5 65              LDA     XX65          ; GET FAC1 MANTISSA 
4
07254  DBDF  91 22              STA     (XX22),Y          ; STORE IN DESTI
NATION
07255  DBE1  88                 DEY                    ; DECREMENT INDEX
07256  DBE2  A5 64              LDA     XX64          ; GET FAC1 MANTISSA 
3
07257  DBE4  91 22              STA     (XX22),Y          ; STORE IN DESTI
NATION
07258  DBE6  88                 DEY                    ; DECREMENT INDEX
07259  DBE7  A5 63              LDA     XX63          ; GET FAC1 MANTISSA 
2
07260  DBE9  91 22              STA     (XX22),Y          ; STORE IN DESTI
NATION
07261  DBEB  88                 DEY                    ; DECREMENT INDEX
07262  DBEC  A5 66              LDA     XX66          ; GET FAC1 SIGN (B7)

07263  DBEE  09 7F              ORA     #$7F               ; SET BITS X111
 1111






****;S......PAGE 0136

LINE# LOC   CODE        LINE


07264  DBF0  25 62              AND     XX62          ; AND IN FAC1 MANTIS
SA 1
07265  DBF2  91 22              STA     (XX22),Y          ; STORE IN DESTI
NATION
07266  DBF4  88                 DEY                    ; DECREMENT INDEX
07267  DBF5  A5 61              LDA     XX61          ; GET FAC1 EXPONENT
07268  DBF7  91 22              STA     (XX22),Y          ; STORE IN DESTI
NATION
07269  DBF9  84 70              STY     XX70          ; CLEAR FAC1 ROUNDIN
G BYTE
07270  DBFB  60                 RTS
07271  DBFC                     
07272  DBFC                     
07273  DBFC              ;************************************************
***********************************;
07274  DBFC              ;
07275  DBFC              ; COPY FAC2 TO FAC1
07276  DBFC              
07277  DBFC              XXDBFC = *
07278  DBFC  A5 6E              LDA     XX6E          ; GET FAC2 SIGN (B7)

07279  DBFE                     
07280  DBFE              ; SAVE FAC1 SIGN AND COPY ABS(FAC2) TO FAC1
07281  DBFE              
07282  DBFE              XXDBFE = *
07283  DBFE  85 66              STA     XX66          ; SAVE FAC1 SIGN (B7
)
07284  DC00  A2 05              LDX     #$05               ; 5 BYTES TO CO
PY
07285  DC02              XXDC02 = *
07286  DC02  B5 68              LDA     XX68,X          ; GET BYTE FROM FA
C2,X
07287  DC04  95 60              STA     XX60,X          ; SAVE BYTE AT FAC
1,X
07288  DC06  CA                 DEX                    ; DECREMENT COUNT
07289  DC07  D0 F9              BNE     XXDC02          ; LOOP IF NOT ALL 
DONE
07290  DC09                     
07291  DC09  86 70              STX     XX70          ; CLEAR FAC1 ROUNDIN
G BYTE
07292  DC0B  60                 RTS
07293  DC0C                     
07294  DC0C                     
07295  DC0C              ;************************************************
***********************************;
07296  DC0C              ;
07297  DC0C              ; ROUND AND COPY FAC1 TO FAC2
07298  DC0C              
07299  DC0C              XXDC0C = *
07300  DC0C  20 1B DC           JSR     XXDC1B          ; ROUND FAC1
07301  DC0F                     
07302  DC0F              ; COPY FAC1 TO FAC2
07303  DC0F              
07304  DC0F              XXDC0F = *
07305  DC0F  A2 06              LDX     #$06               ; 6 BYTES TO CO
PY
07306  DC11              XXDC11 = *
07307  DC11  B5 60              LDA     XX60,X          ; GET BYTE FROM FA
C1,X
07308  DC13  95 68              STA     XX68,X          ; SAVE BYTE AT FAC
2,X
07309  DC15  CA                 DEX                    ; DECREMENT COUNT
07310  DC16  D0 F9              BNE     XXDC11          ; LOOP IF NOT ALL 
DONE
07311  DC18                     
07312  DC18  86 70              STX     XX70          ; CLEAR FAC1 ROUNDIN
G BYTE
07313  DC1A              XXDC1A = *
07314  DC1A  60                 RTS
07315  DC1B                     
07316  DC1B                     
07317  DC1B              ;************************************************
***********************************;
07318  DC1B              ;






****;S......PAGE 0137

LINE# LOC   CODE        LINE


07319  DC1B              ; ROUND FAC1
07320  DC1B              
07321  DC1B              XXDC1B = *
07322  DC1B  A5 61              LDA     XX61          ; GET FAC1 EXPONENT
07323  DC1D  F0 FB              BEQ     XXDC1A          ; EXIT IF ZERO
07324  DC1F                     
07325  DC1F  06 70              ASL     XX70          ; SHIFT FAC1 ROUNDIN
G BYTE
07326  DC21  90 F7              BCC     XXDC1A          ; EXIT IF NO OVERF
LOW
07327  DC23                     
07328  DC23              ; ROUND FAC1 (NO CHECK)
07329  DC23              
07330  DC23              XXDC23 = *
07331  DC23  20 6F D9           JSR     XXD96F          ; INCREMENT FAC1 M
ANTISSA
07332  DC26  D0 F2              BNE     XXDC1A          ; BRANCH IF NO OVE
RFLOW
07333  DC28                     
07334  DC28  4C 38 D9           JMP     XXD938          ; NORNALISE FAC1 F
OR C=1 AND RETURN
07335  DC2B                     
07336  DC2B              ; GET FAC1 SIGN
07337  DC2B              ; RETURN A = $FF, CB = 1/-VE A = $01, CB = 0/+VE,
 A = $00, CB = ?/0
07338  DC2B              
07339  DC2B              XXDC2B = *
07340  DC2B  A5 61              LDA     XX61          ; GET FAC1 EXPONENT
07341  DC2D  F0 09              BEQ     XXDC38          ; EXIT IF ZERO (AL
LREADY CORRECT SGN(0)=0)
07342  DC2F                     
07343  DC2F              ; RETURN A = $FF, CB = 1/-VE A = $01, CB = 0/+VE
07344  DC2F              ; NO = 0 CHECK
07345  DC2F              
07346  DC2F              XXDC2F = *
07347  DC2F  A5 66              LDA     XX66          ; ELSE GET FAC1 SIGN
 (B7)
07348  DC31                     
07349  DC31              ; RETURN A = $FF, CB = 1/-VE A = $01, CB = 0/+VE
07350  DC31              ; NO = 0 CHECK, SIGN IN A
07351  DC31              
07352  DC31              XXDC31 = *
07353  DC31  2A                 ROL A                  ; MOVE SIGN BIT TO 
CARRY
07354  DC32  A9 FF              LDA     #$FF               ; SET BYTE FOR 
-VE RESULT
07355  DC34  B0 02              BCS     XXDC38          ; RETURN IF SIGN W
AS SET (-VE)
07356  DC36                     
07357  DC36  A9 01              LDA     #$01               ; ELSE SET BYTE
 FOR +VE RESULT
07358  DC38              XXDC38 = *
07359  DC38  60                 RTS
07360  DC39                     
07361  DC39                     
07362  DC39              ;************************************************
***********************************;
07363  DC39              ;
07364  DC39              ; PERFORM SGN()
07365  DC39              
07366  DC39              XXDC39 = *
07367  DC39  20 2B DC           JSR     XXDC2B          ; GET FAC1 SIGN, R
ETURN A = $FF -VE, A = $01 +VE
07368  DC3C                     
07369  DC3C              ; SAVE A AS INTEGER BYTE
07370  DC3C              
07371  DC3C              XXDC3C = *
07372  DC3C  85 62              STA     XX62          ; SAVE FAC1 MANTISSA
 1
07373  DC3E  A9 00              LDA     #$00               ; CLEAR A






****;S......PAGE 0138

LINE# LOC   CODE        LINE


07374  DC40  85 63              STA     XX63          ; CLEAR FAC1 MANTISS
A 2
07375  DC42  A2 88              LDX     #$88               ; SET EXPONENT
07376  DC44                     
07377  DC44              ; SET EXPONENT = X, CLEAR FAC1 3 AND 4 AND NORMAL
ISE
07378  DC44              
07379  DC44              XXDC44 = *
07380  DC44  A5 62              LDA     XX62          ; GET FAC1 MANTISSA 
1
07381  DC46  49 FF              EOR     #$FF               ; COMPLEMENT IT

07382  DC48  2A                 ROL A                  ; SIGN BIT INTO CAR
RY
07383  DC49                     
07384  DC49              ; SET EXPONENT = X, CLEAR MANTISSA 4 AND 3 AND NO
RMALISE FAC1
07385  DC49              
07386  DC49              XXDC49 = *
07387  DC49  A9 00              LDA     #$00               ; CLEAR A
07388  DC4B  85 65              STA     XX65          ; CLEAR FAC1 MANTISS
A 4
07389  DC4D  85 64              STA     XX64          ; CLEAR FAC1 MANTISS
A 3
07390  DC4F                     
07391  DC4F              ; SET EXPONENT = X AND NORMALISE FAC1
07392  DC4F              
07393  DC4F              XXDC4F = *
07394  DC4F  86 61              STX     XX61          ; SET FAC1 EXPONENT
07395  DC51  85 70              STA     XX70          ; CLEAR FAC1 ROUNDIN
G BYTE
07396  DC53  85 66              STA     XX66          ; CLEAR FAC1 SIGN (B
7)
07397  DC55  4C D2 D8           JMP     XXD8D2          ; DO ABS AND NORMA
LISE FAC1
07398  DC58                     
07399  DC58              ; PERFORM ABS()
07400  DC58              
07401  DC58              XXDC58 = *
07402  DC58  46 66              LSR     XX66          ; CLEAR FAC1 SIGN, P
UT ZERO IN B7
07403  DC5A  60                 RTS
07404  DC5B                     
07405  DC5B                     
07406  DC5B              ;************************************************
***********************************;
07407  DC5B              ;
07408  DC5B              ; COMPARE FAC1 WITH (AY)
07409  DC5B              ; RETURNS A=$00 IF FAC1 = (AY)
07410  DC5B              ; RETURNS A=$01 IF FAC1 > (AY)
07411  DC5B              ; RETURNS A=$FF IF FAC1 < (AY)
07412  DC5B              
07413  DC5B              XXDC5B = *
07414  DC5B  85 24              STA     XX24          ; SAVE POINTER LOW B
YTE
07415  DC5D              XXDC5D = *
07416  DC5D  84 25              STY     XX25          ; SAVE POINTER HIGH 
BYTE
07417  DC5F  A0 00              LDY     #$00               ; CLEAR INDEX
07418  DC61  B1 24              LDA     (XX24),Y          ; GET EXPONENT
07419  DC63  C8                 INY                    ; INCREMENT INDEX
07420  DC64  AA                 TAX                    ; COPY (AY) EXPONEN
T TO X
07421  DC65  F0 C4              BEQ     XXDC2B          ; BRANCH IF (AY) E
XPONENT=0 AND GET FAC1 SIGN
07422  DC67                                     ; A = $FF, CB = 1/-VE A = 
$01, CB = 0/+VE
07423  DC67                     
07424  DC67  B1 24              LDA     (XX24),Y          ; GET (AY) MANTI
SSA 1, WITH SIGN
07425  DC69  45 66              EOR     XX66          ; EOR FAC1 SIGN (B7)

07426  DC6B  30 C2              BMI     XXDC2F          ; IF SIGNS <> DO R
ETURN A = $FF, CB = 1/-VE
07427  DC6D                                     ; A = $01, CB = 0/+VE AND 
RETURN
07428  DC6D                     






****;S......PAGE 0139

LINE# LOC   CODE        LINE


07429  DC6D  E4 61              CPX     XX61          ; COMPARE (AY) EXPON
ENT WITH FAC1 EXPONENT
07430  DC6F  D0 21              BNE     XXDC92          ; BRANCH IF DIFFER
ENT
07431  DC71                     
07432  DC71  B1 24              LDA     (XX24),Y          ; GET (AY) MANTI
SSA 1, WITH SIGN
07433  DC73  09 80              ORA     #$80               ; NORMALISE TOP
 BIT
07434  DC75  C5 62              CMP     XX62          ; COMPARE WITH FAC1 
MANTISSA 1
07435  DC77  D0 19              BNE     XXDC92          ; BRANCH IF DIFFER
ENT
07436  DC79                     
07437  DC79  C8                 INY                    ; INCREMENT INDEX
07438  DC7A  B1 24              LDA     (XX24),Y          ; GET MANTISSA 2

07439  DC7C  C5 63              CMP     XX63          ; COMPARE WITH FAC1 
MANTISSA 2
07440  DC7E  D0 12              BNE     XXDC92          ; BRANCH IF DIFFER
ENT
07441  DC80                     
07442  DC80  C8                 INY                    ; INCREMENT INDEX
07443  DC81  B1 24              LDA     (XX24),Y          ; GET MANTISSA 3

07444  DC83  C5 64              CMP     XX64          ; COMPARE WITH FAC1 
MANTISSA 3
07445  DC85  D0 0B              BNE     XXDC92          ; BRANCH IF DIFFER
ENT
07446  DC87                     
07447  DC87  C8                 INY                    ; INCREMENT INDEX
07448  DC88  A9 7F              LDA     #$7F               ; SET FOR 1/2 V
ALUE ROUNDING BYTE
07449  DC8A  C5 70              CMP     XX70          ; COMPARE WITH FAC1 
ROUNDING BYTE (SET CARRY)
07450  DC8C  B1 24              LDA     (XX24),Y          ; GET MANTISSA 4

07451  DC8E  E5 65              SBC     XX65          ; SUBTRACT FAC1 MANT
ISSA 4
07452  DC90  F0 28              BEQ     XXDCBA          ; EXIT IF MANTISSA
 4 EQUAL
07453  DC92                     
07454  DC92              ; GETS HERE IF NUMBER <> FAC1
07455  DC92              
07456  DC92              XXDC92 = *
07457  DC92  A5 66              LDA     XX66          ; GET FAC1 SIGN (B7)

07458  DC94  90 02              BCC     XXDC98          ; BRANCH IF FAC1 >
 (AY)
07459  DC96                     
07460  DC96  49 FF              EOR     #$FF               ; ELSE TOGGLE F
AC1 SIGN
07461  DC98              XXDC98 = *
07462  DC98  4C 31 DC           JMP     XXDC31          ; RETURN A = $FF, 
CB = 1/-VE A = $01, CB = 0/+VE
07463  DC9B                     
07464  DC9B                     
07465  DC9B              ;************************************************
***********************************;
07466  DC9B              ;
07467  DC9B              ; CONVERT FAC1 FLOATING TO FIXED
07468  DC9B              
07469  DC9B              XXDC9B = *
07470  DC9B  A5 61              LDA     XX61          ; GET FAC1 EXPONENT
07471  DC9D  F0 4A              BEQ     XXDCE9          ; IF ZERO GO CLEAR
 FAC1 AND RETURN
07472  DC9F                     
07473  DC9F  38                 SEC                    ; SET CARRY FOR SUB
TRACT
07474  DCA0  E9 A0              SBC     #$A0               ; SUBTRACT MAXI
MUM INTEGER RANGE EXPONENT
07475  DCA2  24 66              BIT     XX66          ; TEST FAC1 SIGN (B7
)
07476  DCA4  10 09              BPL     XXDCAF          ; BRANCH IF FAC1 +
VE
07477  DCA6                     
07478  DCA6                                     ; FAC1 WAS -VE
07479  DCA6  AA                 TAX                    ; COPY SUBTRACTED E
XPONENT
07480  DCA7  A9 FF              LDA     #$FF               ; OVERFLOW FOR 
-VE NUMBER
07481  DCA9  85 68              STA     XX68          ; SET FAC1 OVERFLOW 
BYTE
07482  DCAB  20 4D D9           JSR     XXD94D          ; TWOS COMPLEMENT 
FAC1 MANTISSA
07483  DCAE  8A                 TXA                    ; RESTORE SUBTRACTE
D EXPONENT






****;S......PAGE 0140

LINE# LOC   CODE        LINE


07484  DCAF              XXDCAF = *
07485  DCAF  A2 61              LDX     #$61               ; SET INDEX TO 
FAC1
07486  DCB1  C9 F9              CMP     #$F9               ; COMPARE EXPON
ENT RESULT
07487  DCB3  10 06              BPL     XXDCBB          ; IF < 8 SHIFTS SH
IFT FAC1 A TIMES RIGHT AND RETURN
07488  DCB5                     
07489  DCB5  20 99 D9           JSR     XXD999          ; SHIFT FAC1 A TIM
ES RIGHT (> 8 SHIFTS)
07490  DCB8  84 68              STY     XX68          ; CLEAR FAC1 OVERFLO
W BYTE
07491  DCBA              XXDCBA = *
07492  DCBA  60                 RTS
07493  DCBB                     
07494  DCBB                     
07495  DCBB              ;************************************************
***********************************;
07496  DCBB              ;
07497  DCBB              ; SHIFT FAC1 A TIMES RIGHT
07498  DCBB              
07499  DCBB              XXDCBB = *
07500  DCBB  A8                 TAY                    ; COPY SHIFT COUNT
07501  DCBC  A5 66              LDA     XX66          ; GET FAC1 SIGN (B7)

07502  DCBE  29 80              AND     #$80               ; MASK SIGN BIT
 ONLY (X000 0000)
07503  DCC0  46 62              LSR     XX62          ; SHIFT FAC1 MANTISS
A 1
07504  DCC2  05 62              ORA     XX62          ; OR SIGN IN B7 FAC1
 MANTISSA 1
07505  DCC4  85 62              STA     XX62          ; SAVE FAC1 MANTISSA
 1
07506  DCC6  20 B0 D9           JSR     XXD9B0          ; SHIFT FAC1 Y TIM
ES RIGHT
07507  DCC9  84 68              STY     XX68          ; CLEAR FAC1 OVERFLO
W BYTE
07508  DCCB  60                 RTS
07509  DCCC                     
07510  DCCC                     
07511  DCCC              ;************************************************
***********************************;
07512  DCCC              ;
07513  DCCC              ; PERFORM INT()
07514  DCCC              
07515  DCCC              XXDCCC = *
07516  DCCC  A5 61              LDA     XX61          ; GET FAC1 EXPONENT
07517  DCCE  C9 A0              CMP     #$A0               ; COMPARE WITH 
MAX INT
07518  DCD0  B0 20              BCS     XXDCF2          ; EXIT IF >= (ALLR
EADY INT, TOO BIG FOR FRACTIONAL PART!)
07519  DCD2                     
07520  DCD2  20 9B DC           JSR     XXDC9B          ; CONVERT FAC1 FLO
ATING TO FIXED
07521  DCD5  84 70              STY     XX70          ; SAVE FAC1 ROUNDING
 BYTE
07522  DCD7  A5 66              LDA     XX66          ; GET FAC1 SIGN (B7)

07523  DCD9  84 66              STY     XX66          ; SAVE FAC1 SIGN (B7
)
07524  DCDB  49 80              EOR     #$80               ; TOGGLE FAC1 S
IGN
07525  DCDD  2A                 ROL A                  ; SHIFT INTO CARRY
07526  DCDE  A9 A0              LDA     #$A0               ; SET NEW EXPON
ENT
07527  DCE0  85 61              STA     XX61          ; SAVE FAC1 EXPONENT

07528  DCE2  A5 65              LDA     XX65          ; GET FAC1 MANTISSA 
4
07529  DCE4  85 07              STA     XX07          ; SAVE FAC1 MANTISSA
 4 FOR POWER FUNCTION
07530  DCE6  4C D2 D8           JMP     XXD8D2          ; DO ABS AND NORMA
LISE FAC1
07531  DCE9                     
07532  DCE9                     
07533  DCE9              ;************************************************
***********************************;
07534  DCE9              ;
07535  DCE9              ; CLEAR FAC1 AND RETURN
07536  DCE9              
07537  DCE9              XXDCE9 = *
07538  DCE9  85 62              STA     XX62          ; CLEAR FAC1 MANTISS
A 1






****;)......PAGE 0141

LINE# LOC   CODE        LINE


07539  DCEB  85 63              STA     XX63          ; CLEAR FAC1 MANTISS
A 2
07540  DCED  85 64              STA     XX64          ; CLEAR FAC1 MANTISS
A 3
07541  DCEF  85 65              STA     XX65          ; CLEAR FAC1 MANTISS
A 4
07542  DCF1  A8                 TAY                    ; CLEAR Y
07543  DCF2              XXDCF2 = *
07544  DCF2  60                 RTS
07545  DCF3                     
07546  DCF3                     
07547  DCF3              ;************************************************
***********************************;
07548  DCF3              ;
07549  DCF3              ; GET FAC1 FROM STRING
07550  DCF3              
07551  DCF3              XXDCF3 = *
07552  DCF3  A0 00              LDY     #$00               ; CLEAR Y
07553  DCF5  A2 0A              LDX     #$0A               ; SET INDEX
07554  DCF7              XXDCF7 = *
07555  DCF7  94 5D              STY     XX5D,X          ; CLEAR BYTE
07556  DCF9  CA                 DEX                    ; DECREMENT INDEX
07557  DCFA  10 FB              BPL     XXDCF7          ; LOOP UNTIL NUMEX
P TO NEGNUM (AND FAC1) = $00
07558  DCFC                     
07559  DCFC  90 0F              BCC     XXDD0D          ; BRANCH IF FIRST 
CHARACTER IS NUMERIC
07560  DCFE                     
07561  DCFE  C9 2D              CMP     #'-'               ; ELSE COMPARE 
WITH '-'
07562  DD00  D0 04              BNE     XXDD06          ; BRANCH IF NOT '-
'
07563  DD02                     
07564  DD02  86 67              STX     XX67          ; SET FLAG FOR -VE N
 (NEGNUM = $FF)
07565  DD04  F0 04              BEQ     XXDD0A          ; BRANCH ALWAYS
07566  DD06                     
07567  DD06              XXDD06 = *
07568  DD06  C9 2B              CMP     #'+'               ; ELSE COMPARE 
WITH '+'
07569  DD08  D0 05              BNE     XXDD0F          ; BRANCH IF NOT '+
'
07570  DD0A                     
07571  DD0A              XXDD0A = *
07572  DD0A  20 73 00           JSR     XX0073          ; INCREMENT AND SC
AN MEMORY
07573  DD0D              XXDD0D = *
07574  DD0D  90 5B              BCC     XXDD6A          ; BRANCH IF NUMERI
C CHARACTER
07575  DD0F                     
07576  DD0F              XXDD0F = *
07577  DD0F  C9 2E              CMP     #'.'               ; ELSE COMPARE 
WITH '.'
07578  DD11  F0 2E              BEQ     XXDD41          ; BRANCH IF '.'
07579  DD13                     
07580  DD13  C9 45              CMP     #'E'               ; ELSE COMPARE 
WITH 'E'
07581  DD15  D0 30              BNE     XXDD47          ; BRANCH IF NOT 'E
'
07582  DD17                     
07583  DD17                                     ; WAS 'E' SO EVALUATE EXPO
NENTIAL PART
07584  DD17  20 73 00           JSR     XX0073          ; INCREMENT AND SC
AN MEMORY
07585  DD1A  90 17              BCC     XXDD33          ; BRANCH IF NUMERI
C CHARACTER
07586  DD1C                     
07587  DD1C  C9 AB              CMP     #TMINUS          ; ELSE COMPARE WI
TH TOKEN FOR -
07588  DD1E  F0 0E              BEQ     XXDD2E          ; BRANCH IF TOKEN 
FOR -
07589  DD20                     
07590  DD20  C9 2D              CMP     #'-'               ; ELSE COMPARE 
WITH '-'
07591  DD22  F0 0A              BEQ     XXDD2E          ; BRANCH IF '-'
07592  DD24                     
07593  DD24  C9 AA              CMP     #TPLUS          ; ELSE COMPARE WIT
H TOKEN FOR +






****;)......PAGE 0142

LINE# LOC   CODE        LINE


07594  DD26  F0 08              BEQ     XXDD30          ; BRANCH IF TOKEN 
FOR +
07595  DD28                     
07596  DD28  C9 2B              CMP     #'+'               ; ELSE COMPARE 
WITH '+'
07597  DD2A  F0 04              BEQ     XXDD30          ; BRANCH IF '+'
07598  DD2C                     
07599  DD2C  D0 07              BNE     XXDD35          ; BRANCH ALWAYS
07600  DD2E                     
07601  DD2E              XXDD2E = *
07602  DD2E  66 60              ROR     XX60          ; SET EXPONENT -VE F
LAG (C, WHICH=1, INTO B7)
07603  DD30              XXDD30 = *
07604  DD30  20 73 00           JSR     XX0073          ; INCREMENT AND SC
AN MEMORY
07605  DD33              XXDD33 = *
07606  DD33  90 5C              BCC     XXDD91          ; BRANCH IF NUMERI
C CHARACTER
07607  DD35                     
07608  DD35              XXDD35 = *
07609  DD35  24 60              BIT     XX60          ; TEST EXPONENT -VE 
FLAG
07610  DD37  10 0E              BPL     XXDD47          ; IF +VE GO EVALUA
TE EXPONENT
07611  DD39                     
07612  DD39                                     ; ELSE DO EXPONENT = -EXPO
NENT
07613  DD39  A9 00              LDA     #$00               ; CLEAR RESULT
07614  DD3B  38                 SEC                    ; SET CARRY FOR SUB
TRACT
07615  DD3C  E5 5E              SBC     XX5E          ; SUBTRACT EXPONENT 
BYTE
07616  DD3E  4C 49 DD           JMP     XXDD49          ; GO EVALUATE EXPO
NENT
07617  DD41                     
07618  DD41              XXDD41 = *
07619  DD41  66 5F              ROR     XX5F          ; SET DECIMAL POINT 
FLAG
07620  DD43  24 5F              BIT     XX5F          ; TEST DECIMAL POINT
 FLAG
07621  DD45  50 C3              BVC     XXDD0A          ; BRANCH IF ONLY O
NE DECIMAL POINT SO FAR
07622  DD47                     
07623  DD47                                     ; EVALUATE EXPONENT
07624  DD47              XXDD47 = *
07625  DD47  A5 5E              LDA     XX5E          ; GET EXPONENT COUNT
 BYTE
07626  DD49              XXDD49 = *
07627  DD49  38                 SEC                    ; SET CARRY FOR SUB
TRACT
07628  DD4A  E5 5D              SBC     XX5D          ; SUBTRACT NUMERATOR
 EXPONENT
07629  DD4C  85 5E              STA     XX5E          ; SAVE EXPONENT COUN
T BYTE
07630  DD4E  F0 12              BEQ     XXDD62          ; BRANCH IF NO ADJ
USTMENT
07631  DD50                     
07632  DD50  10 09              BPL     XXDD5B          ; ELSE IF +VE GO D
O FAC1*10^EXPCNT
07633  DD52                     
07634  DD52                                     ; ELSE GO DO FAC1/10^(0-EX
PCNT)
07635  DD52              XXDD52 = *
07636  DD52  20 FE DA           JSR     XXDAFE          ; DIVIDE FAC1 BY 1
0
07637  DD55  E6 5E              INC     XX5E          ; INCREMENT EXPONENT
 COUNT BYTE
07638  DD57  D0 F9              BNE     XXDD52          ; LOOP UNTIL ALL D
ONE
07639  DD59                     
07640  DD59  F0 07              BEQ     XXDD62          ; BRANCH ALWAYS
07641  DD5B                     
07642  DD5B              XXDD5B = *
07643  DD5B  20 E2 DA           JSR     XXDAE2          ; MULTIPLY FAC1 BY
 10
07644  DD5E  C6 5E              DEC     XX5E          ; DECREMENT EXPONENT
 COUNT BYTE
07645  DD60  D0 F9              BNE     XXDD5B          ; LOOP UNTIL ALL D
ONE
07646  DD62                     
07647  DD62              XXDD62 = *
07648  DD62  A5 67              LDA     XX67          ; GET -VE FLAG






****;)......PAGE 0143

LINE# LOC   CODE        LINE


07649  DD64  30 01              BMI     XXDD67          ; IF -VE DO - FAC1
 AND RETURN
07650  DD66                     
07651  DD66  60                 RTS
07652  DD67                     
07653  DD67              ; DO - FAC1 AND RETURN
07654  DD67              
07655  DD67              XXDD67 = *
07656  DD67  4C B4 DF           JMP     XXDFB4          ; DO - FAC1
07657  DD6A                     
07658  DD6A              ; DO UNSIGNED FAC1*10+NUMBER
07659  DD6A              
07660  DD6A              XXDD6A = *
07661  DD6A  48                 PHA                    ; SAVE CHARACTER
07662  DD6B  24 5F              BIT     XX5F          ; TEST DECIMAL POINT
 FLAG
07663  DD6D  10 02              BPL     XXDD71          ; SKIP EXPONENT IN
CREMENT IF NOT SET
07664  DD6F                     
07665  DD6F  E6 5D              INC     XX5D          ; ELSE INCREMENT NUM
BER EXPONENT
07666  DD71              XXDD71 = *
07667  DD71  20 E2 DA           JSR     XXDAE2          ; MULTIPLY FAC1 BY
 10
07668  DD74  68                 PLA                    ; RESTORE CHARACTER

07669  DD75  38                 SEC                    ; SET CARRY FOR SUB
TRACT
07670  DD76  E9 30              SBC     #'0'               ; CONVERT TO BI
NARY
07671  DD78  20 7E DD           JSR     XXDD7E          ; EVALUATE NEW ASC
II DIGIT
07672  DD7B  4C 0A DD           JMP     XXDD0A          ; GO DO NEXT CHARA
CTER
07673  DD7E                     
07674  DD7E              ; EVALUATE NEW ASCII DIGIT
07675  DD7E              ; MULTIPLY FAC1 BY 10 THEN (ABS) ADD IN NEW DIGIT

07676  DD7E              
07677  DD7E              XXDD7E = *
07678  DD7E  48                 PHA                    ; SAVE DIGIT
07679  DD7F  20 0C DC           JSR     XXDC0C          ; ROUND AND COPY F
AC1 TO FAC2
07680  DD82  68                 PLA                    ; RESTORE DIGIT
07681  DD83  20 3C DC           JSR     XXDC3C          ; SAVE A AS INTEGE
R BYTE
07682  DD86  A5 6E              LDA     XX6E          ; GET FAC2 SIGN (B7)

07683  DD88  45 66              EOR     XX66          ; TOGGLE WITH FAC1 S
IGN (B7)
07684  DD8A  85 6F              STA     XX6F          ; SAVE SIGN COMPARE 
(FAC1 EOR FAC2)
07685  DD8C  A6 61              LDX     XX61          ; GET FAC1 EXPONENT
07686  DD8E  4C 6A D8           JMP     XXD86A          ; ADD FAC2 TO FAC1
 AND RETURN
07687  DD91                     
07688  DD91              ; EVALUATE NEXT CHARACTER OF EXPONENTIAL PART OF 
NUMBER
07689  DD91              
07690  DD91              XXDD91 = *
07691  DD91  A5 5E              LDA     XX5E          ; GET EXPONENT COUNT
 BYTE
07692  DD93  C9 0A              CMP     #$0A               ; COMPARE WITH 
10 DECIMAL
07693  DD95  90 09              BCC     XXDDA0          ; BRANCH IF LESS
07694  DD97                     
07695  DD97  A9 64              LDA     #$64               ; MAKE ALL -VE 
EXPONENTS = -100 DECIMAL (CAUSES UNDERFLOW)
07696  DD99  24 60              BIT     XX60          ; TEST EXPONENT -VE 
FLAG
07697  DD9B  30 11              BMI     XXDDAE          ; BRANCH IF -VE
07698  DD9D                     
07699  DD9D  4C 7E D9           JMP     XXD97E          ; ELSE DO OVERFLOW
 ERROR THEN WARM START
07700  DDA0                     
07701  DDA0              XXDDA0 = *
07702  DDA0  0A                 ASL A                  ; *2
07703  DDA1  0A                 ASL A                  ; *4






UNDERF......PAGE 0144

LINE# LOC   CODE        LINE


07704  DDA2  18                 CLC                    ; CLEAR CARRY FOR A
DD
07705  DDA3  65 5E              ADC     XX5E          ; *5
07706  DDA5  0A                 ASL A                  ; *10
07707  DDA6  18                 CLC                    ; CLEAR CARRY FOR A
DD
07708  DDA7  A0 00              LDY     #$00               ; SET INDEX
07709  DDA9  71 7A              ADC     (XX7A),Y          ; ADD CHARACTER 
(WILL BE $30 TOO MUCH!)
07710  DDAB  38                 SEC                    ; SET CARRY FOR SUB
TRACT
07711  DDAC  E9 30              SBC     #'0'               ; CONVERT CHARA
CTER TO BINARY
07712  DDAE              XXDDAE = *
07713  DDAE  85 5E              STA     XX5E          ; SAVE EXPONENT COUN
T BYTE
07714  DDB0  4C 30 DD           JMP     XXDD30          ; GO GET NEXT CHAR
ACTER
07715  DDB3                     
07716  DDB3                     
07717  DDB3              ;************************************************
***********************************;
07718  DDB3              ;
07719  DDB3              XXDDB3 = *
07720  DDB3  9B                 .BYTE     $9B,$3E,$BC,$1F,$FD
07720  DDB4  3E 
07720  DDB5  BC 
07720  DDB6  1F 
07720  DDB7  FD 
07721  DDB8                                     ; 99999999.90625, MAXIMUM 
VALUE WITH AT LEAST ONE DECIMAL
07722  DDB8              XXDDB8 = *
07723  DDB8  9E                 .BYTE     $9E,$6E,$6B,$27,$FD
07723  DDB9  6E 
07723  DDBA  6B 
07723  DDBB  27 
07723  DDBC  FD 
07724  DDBD                                     ; 999999999.25, MAXIMUM VA
LUE BEFORE SCIENTIFIC NOTATION
07725  DDBD              XXDDBD = *
07726  DDBD  9E                 .BYTE     $9E,$6E,$6B,$28,$00
07726  DDBE  6E 
07726  DDBF  6B 
07726  DDC0  28 
07726  DDC1  00 
07727  DDC2                                     ; 1000000000
07728  DDC2                     
07729  DDC2                     
07730  DDC2              ;************************************************
***********************************;
07731  DDC2              ;
07732  DDC2              ; DO ' IN ' LINE NUMBER MESSAGE
07733  DDC2              
07734  DDC2              XXDDC2 = *
07735  DDC2  A9 71              LDA     #<XXC371          ; SET ' IN ' POI
NTER LOW BYTE
07736  DDC4  A0 C3              LDY     #>XXC371          ; SET ' IN ' POI
NTER HIGH BYTE
07737  DDC6  20 DA DD           JSR     XXDDDA          ; PRINT NULL TERMI
NATED STRING
07738  DDC9  A5 3A              LDA     XX3A          ; GET THE CURRENT LI
NE NUMBER HIGH BYTE
07739  DDCB  A6 39              LDX     XX39          ; GET THE CURRENT LI
NE NUMBER LOW BYTE
07740  DDCD                     
07741  DDCD                     
07742  DDCD              ;************************************************
***********************************;
07743  DDCD              ;
07744  DDCD              ; PRINT XA AS UNSIGNED INTEGER
07745  DDCD              
07746  DDCD              XXDDCD = *






****;F......PAGE 0145

LINE# LOC   CODE        LINE


07747  DDCD  85 62              STA     XX62          ; SAVE HIGH BYTE AS 
FAC1 MANTISSA1
07748  DDCF  86 63              STX     XX63          ; SAVE LOW BYTE AS F
AC1 MANTISSA2
07749  DDD1  A2 90              LDX     #$90               ; SET EXPONENT 
TO 16D BITS
07750  DDD3  38                 SEC                    ; SET INTEGER IS +V
E FLAG
07751  DDD4  20 49 DC           JSR     XXDC49          ; SET EXPONENT = X
, CLEAR MANTISSA 4 AND 3 AND NORMALISE
07752  DDD7                                     ; FAC1
07753  DDD7  20 DF DD           JSR     XXDDDF          ; CONVERT FAC1 TO 
STRING
07754  DDDA              XXDDDA = *
07755  DDDA  4C 1E CB           JMP     XXCB1E          ; PRINT NULL TERMI
NATED STRING
07756  DDDD                     
07757  DDDD                     
07758  DDDD              ;************************************************
***********************************;
07759  DDDD              ;
07760  DDDD              ; CONVERT FAC1 TO ASCII STRING RESULT IN (AY)
07761  DDDD              
07762  DDDD              XXDDDD = *
07763  DDDD  A0 01              LDY     #$01               ; SET INDEX = 1

07764  DDDF              XXDDDF = *
07765  DDDF  A9 20              LDA     #' '               ; CHARACTER = '
 ' (ASSUME +VE)
07766  DDE1  24 66              BIT     XX66          ; TEST FAC1 SIGN (B7
)
07767  DDE3  10 02              BPL     XXDDE7          ; IF +VE SKIP THE 
- SIGN SET
07768  DDE5                     
07769  DDE5  A9 2D              LDA     #'-'               ; ELSE CHARACTE
R = '-'
07770  DDE7              XXDDE7 = *
07771  DDE7  99 FF 00           STA     XX00FF,Y          ; SAVE LEADING C
HARACTER (' ' OR '-')
07772  DDEA  85 66              STA     XX66          ; SAVE FAC1 SIGN (B7
)
07773  DDEC  84 71              STY     XX71          ; SAVE THE INDEX
07774  DDEE  C8                 INY                    ; INCREMENT INDEX
07775  DDEF  A9 30              LDA     #'0'               ; SET CHARACTER
 = '0'
07776  DDF1  A6 61              LDX     XX61          ; GET FAC1 EXPONENT
07777  DDF3  D0 03              BNE     XXDDF8          ; IF FAC1<>0 GO CO
NVERT IT
07778  DDF5                     
07779  DDF5                                     ; EXPONENT WAS $00 SO FAC1
 IS 0
07780  DDF5  4C 04 DF           JMP     XXDF04          ; SAVE LAST CHARAC
TER, [EOT] AND EXIT
07781  DDF8                     
07782  DDF8              ; FAC1 IS SOME NON ZERO VALUE
07783  DDF8              
07784  DDF8              XXDDF8 = *
07785  DDF8  A9 00              LDA     #$00               ; CLEAR (NUMBER
 EXPONENT COUNT)
07786  DDFA  E0 80              CPX     #$80               ; COMPARE FAC1 
EXPONENT WITH $80 (<1.00000)
07787  DDFC  F0 02              BEQ     XXDE00          ; BRANCH IF 0.5 <=
 FAC1 < 1.0
07788  DDFE                     
07789  DDFE  B0 09              BCS     XXDE09          ; BRANCH IF FAC1=>
1
07790  DE00                     
07791  DE00              XXDE00 = *
07792  DE00  A9 BD              LDA     #<XXDDBD          ; SET 1000000000
 POINTER LOW BYTE
07793  DE02  A0 DD              LDY     #>XXDDBD          ; SET 1000000000
 POINTER HIGH BYTE
07794  DE04  20 28 DA           JSR     XXDA28          ; DO CONVERT AY, F
CA1*(AY)
07795  DE07  A9 F7              LDA     #$F7               ; SET NUMBER EX
PONENT COUNT
07796  DE09              XXDE09 = *
07797  DE09  85 5D              STA     XX5D          ; SAVE NUMBER EXPONE
NT COUNT
07798  DE0B              XXDE0B = *
07799  DE0B  A9 B8              LDA     #<XXDDB8          ; SET 999999999.
25 POINTER LOW BYTE (MAX BEFORE SCI NOTE)
07800  DE0D  A0 DD              LDY     #>XXDDB8          ; SET 999999999.
25 POINTER HIGH BYTE
07801  DE0F  20 5B DC           JSR     XXDC5B          ; COMPARE FAC1 WIT
H (AY)






CI NOT......PAGE 0146

LINE# LOC   CODE        LINE


07802  DE12  F0 1E              BEQ     XXDE32          ; EXIT IF FAC1 = (
AY)
07803  DE14                     
07804  DE14  10 12              BPL     XXDE28          ; GO DO /10 IF FAC
1 > (AY)
07805  DE16                     
07806  DE16                                     ; FAC1 < (AY)
07807  DE16              XXDE16 = *
07808  DE16  A9 B3              LDA     #<XXDDB3          ; SET 99999999.9
0625 POINTER LOW BYTE
07809  DE18  A0 DD              LDY     #>XXDDB3          ; SET 99999999.9
0625 POINTER HIGH BYTE
07810  DE1A  20 5B DC           JSR     XXDC5B          ; COMPARE FAC1 WIT
H (AY)
07811  DE1D  F0 02              BEQ     XXDE21          ; BRANCH IF FAC1 =
 (AY) (ALLOW DECIMAL PLACES)
07812  DE1F                     
07813  DE1F  10 0E              BPL     XXDE2F          ; BRANCH IF FAC1 >
 (AY) (NO DECIMAL PLACES)
07814  DE21                     
07815  DE21                                     ; FAC1 <= (AY)
07816  DE21              XXDE21 = *
07817  DE21  20 E2 DA           JSR     XXDAE2          ; MULTIPLY FAC1 BY
 10
07818  DE24  C6 5D              DEC     XX5D          ; DECREMENT NUMBER E
XPONENT COUNT
07819  DE26  D0 EE              BNE     XXDE16          ; GO TEST AGAIN, B
RANCH ALWAYS
07820  DE28                     
07821  DE28              XXDE28 = *
07822  DE28  20 FE DA           JSR     XXDAFE          ; DIVIDE FAC1 BY 1
0
07823  DE2B  E6 5D              INC     XX5D          ; INCREMENT NUMBER E
XPONENT COUNT
07824  DE2D  D0 DC              BNE     XXDE0B          ; GO TEST AGAIN, B
RANCH ALWAYS
07825  DE2F                     
07826  DE2F              ; NOW WE HAVE JUST THE DIGITS TO DO
07827  DE2F              
07828  DE2F              XXDE2F = *
07829  DE2F  20 49 D8           JSR     XXD849          ; ADD 0.5 TO FAC1 
(ROUND FAC1)
07830  DE32              XXDE32 = *
07831  DE32  20 9B DC           JSR     XXDC9B          ; CONVERT FAC1 FLO
ATING TO FIXED
07832  DE35  A2 01              LDX     #$01               ; SET DEFAULT D
IGITS BEFORE DP = 1
07833  DE37  A5 5D              LDA     XX5D          ; GET NUMBER EXPONEN
T COUNT
07834  DE39  18                 CLC                    ; CLEAR CARRY FOR A
DD
07835  DE3A  69 0A              ADC     #$0A               ; UP TO 9 DIGIT
S BEFORE POINT
07836  DE3C  30 09              BMI     XXDE47          ; IF -VE THEN 1 DI
GIT BEFORE DP
07837  DE3E                     
07838  DE3E  C9 0B              CMP     #$0B               ; A>=$0B IF N>=
1E9
07839  DE40  B0 06              BCS     XXDE48          ; BRANCH IF >= $0B

07840  DE42                     
07841  DE42                                     ; CARRY IS CLEAR
07842  DE42  69 FF              ADC     #$FF               ; TAKE 1 FROM D
IGIT COUNT
07843  DE44  AA                 TAX                    ; COPY TO X
07844  DE45  A9 02              LDA     #$02               ; SET THE EXPON
ENT ADJUST
07845  DE47              XXDE47 = *
07846  DE47  38                 SEC                    ; SET CARRY FOR SUB
TRACT
07847  DE48              XXDE48 = *
07848  DE48  E9 02              SBC     #$02               ; -2
07849  DE4A  85 5E              STA     XX5E          ; SAVE THE EXPONENT 
ADJUST
07850  DE4C  86 5D              STX     XX5D          ; SAVE DIGITS BEFORE
 DP COUNT
07851  DE4E  8A                 TXA                    ; COPY DIGITS BEFOR
E DP COUNT TO A
07852  DE4F  F0 02              BEQ     XXDE53          ; IF NO DIGITS BEF
ORE THE DP GO DO THE '.'
07853  DE51                     
07854  DE51  10 13              BPL     XXDE66          ; IF THERE ARE DIG
ITS BEFORE THE DP GO DO THEM
07855  DE53                     
07856  DE53              XXDE53 = *






CI NOT......PAGE 0147

LINE# LOC   CODE        LINE


07857  DE53  A4 71              LDY     XX71          ; GET THE OUTPUT STR
ING INDEX
07858  DE55  A9 2E              LDA     #'.'               ; CHARACTER '.'

07859  DE57  C8                 INY                    ; INCREMENT THE IND
EX
07860  DE58  99 FF 00           STA     XX0100-1,Y     ; SAVE THE '.' TO T
HE OUTPUT STRING
07861  DE5B  8A                 TXA                    ; COPY DIGITS BEFOR
E DP COUNT TO A
07862  DE5C  F0 06              BEQ     XXDE64          ; IF NO DIGITS BEF
ORE THE DP SKIP THE '0'
07863  DE5E                     
07864  DE5E  A9 30              LDA     #'0'               ; CHARACTER '0'

07865  DE60  C8                 INY                    ; INCREMENT INDEX
07866  DE61  99 FF 00           STA     XX0100-1,Y     ; SAVE THE '0' TO T
HE OUTPUT STRING
07867  DE64              XXDE64 = *
07868  DE64  84 71              STY     XX71          ; SAVE THE OUTPUT ST
RING INDEX
07869  DE66              XXDE66 = *
07870  DE66  A0 00              LDY     #$00               ; CLEAR THE POW
ERS OF 10 INDEX (POINT TO -100,000,000)
07871  DE68              XXDE68 = *
07872  DE68  A2 80              LDX     #$80               ; CLEAR THE DIG
IT, SET THE TEST SENSE
07873  DE6A              XXDE6A = *
07874  DE6A  A5 65              LDA     XX65          ; GET FAC1 MANTISSA 
4
07875  DE6C  18                 CLC                    ; CLEAR CARRY FOR A
DD
07876  DE6D  79 19 DF           ADC     XXDF16+3,Y     ; ADD BYTE 4, LEAST
 SIGNIFICANT
07877  DE70  85 65              STA     XX65          ; SAVE FAC1 MANTISSA
4
07878  DE72  A5 64              LDA     XX64          ; GET FAC1 MANTISSA 
3
07879  DE74  79 18 DF           ADC     XXDF16+2,Y     ; ADD BYTE 3
07880  DE77  85 64              STA     XX64          ; SAVE FAC1 MANTISSA
3
07881  DE79  A5 63              LDA     XX63          ; GET FAC1 MANTISSA 
2
07882  DE7B  79 17 DF           ADC     XXDF16+1,Y     ; ADD BYTE 2
07883  DE7E  85 63              STA     XX63          ; SAVE FAC1 MANTISSA
2
07884  DE80  A5 62              LDA     XX62          ; GET FAC1 MANTISSA 
1
07885  DE82  79 16 DF           ADC     XXDF16+0,Y     ; ADD BYTE 1, MOST 
SIGNIFICANT
07886  DE85  85 62              STA     XX62          ; SAVE FAC1 MANTISSA
1
07887  DE87  E8                 INX                    ; INCREMENT THE DIG
IT, SET THE SIGN ON THE TEST SENSE BIT
07888  DE88  B0 04              BCS     XXDE8E          ; IF THE CARRY IS 
SET GO TEST IF THE RESULT WAS POSITIVE
07889  DE8A                     
07890  DE8A                                     ; ELSE THE RESULT NEEDS TO
 BE NEGATIVE
07891  DE8A  10 DE              BPL     XXDE6A          ; NOT -VE SO TRY A
GAIN
07892  DE8C                     
07893  DE8C  30 02              BMI     XXDE90          ; ELSE DONE SO RET
URN THE DIGIT
07894  DE8E                     
07895  DE8E              XXDE8E = *
07896  DE8E  30 DA              BMI     XXDE6A          ; NOT +VE SO TRY A
GAIN
07897  DE90                     
07898  DE90              ; ELSE DONE SO RETURN THE DIGIT
07899  DE90              
07900  DE90              XXDE90 = *
07901  DE90  8A                 TXA                    ; COPY THE DIGIT
07902  DE91  90 04              BCC     XXDE97          ; IF CB=0 JUST USE
 IT
07903  DE93                     
07904  DE93  49 FF              EOR     #$FF               ; ELSE MAKE THE
 2'S COMPLEMENT ..
07905  DE95  69 0A              ADC     #$0A               ; .. AND SUBTRA
CT IT FROM 10
07906  DE97              XXDE97 = *
07907  DE97  69 2F              ADC     #$2F    ;#'0'-1          ; ADD '0'
-1 TO RESULT
07908  DE99  C8                 INY                    ; INCREMENT ..
07909  DE9A  C8                 INY                    ; .. INDEX TO..
07910  DE9B  C8                 INY                    ; .. NEXT LESS ..
07911  DE9C  C8                 INY                    ; .. POWER OF TEN






ITIVE)......PAGE 0148

LINE# LOC   CODE        LINE


07912  DE9D  84 47              STY     XX47          ; SAVE THE POWERS OF
 TEN TABLE INDEX
07913  DE9F  A4 71              LDY     XX71          ; GET OUTPUT STRING 
INDEX
07914  DEA1  C8                 INY                    ; INCREMENT OUTPUT 
STRING INDEX
07915  DEA2  AA                 TAX                    ; COPY CHARACTER TO
 X
07916  DEA3  29 7F              AND     #$7F               ; MASK OUT TOP 
BIT
07917  DEA5  99 FF 00           STA     XX0100-1,Y     ; SAVE TO OUTPUT ST
RING
07918  DEA8  C6 5D              DEC     XX5D          ; DECREMENT # OF CHA
RACTERS BEFORE THE DP
07919  DEAA  D0 06              BNE     XXDEB2          ; IF STILL CHARACT
ERS TO DO SKIP THE DECIMAL POINT
07920  DEAC                     
07921  DEAC                                     ; ELSE OUTPUT THE POINT
07922  DEAC  A9 2E              LDA     #'.'               ; CHARACTER '.'

07923  DEAE  C8                 INY                    ; INCREMENT OUTPUT 
STRING INDEX
07924  DEAF  99 FF 00           STA     XX0100-1,Y     ; SAVE TO OUTPUT ST
RING
07925  DEB2              XXDEB2 = *
07926  DEB2  84 71              STY     XX71          ; SAVE THE OUTPUT ST
RING INDEX
07927  DEB4  A4 47              LDY     XX47          ; GET THE POWERS OF 
TEN TABLE INDEX
07928  DEB6  8A                 TXA                    ; GET THE CHARACTER
 BACK
07929  DEB7  49 FF              EOR     #$FF               ; TOGGLE THE TE
ST SENSE BIT
07930  DEB9  29 80              AND     #$80               ; CLEAR THE DIG
IT
07931  DEBB  AA                 TAX                    ; COPY IT TO THE NE
W DIGIT
07932  DEBC  C0 24              CPY     #XXDF3A-XXDF16               
07933  DEBE                                     ; COMPARE THE TABLE INDEX 
WITH THE MAX FOR DECIMAL NUMBERS
07934  DEBE  F0 04              BEQ     XXDEC4          ; IF AT THE MAX EX
IT THE DIGIT LOOP
07935  DEC0                     
07936  DEC0  C0 3C              CPY     #XXDF52-XXDF16
07937  DEC2                                     ; COMPARE THE TABLE INDEX 
WITH THE MAX FOR TIME
07938  DEC2  D0 A6              BNE     XXDE6A          ; LOOP IF NOT AT T
HE MAX
07939  DEC4                     
07940  DEC4              ; NOW REMOVE TRAILING ZEROES
07941  DEC4              
07942  DEC4              XXDEC4 = *
07943  DEC4  A4 71              LDY     XX71          ; RESTORE THE OUTPUT
 STRING INDEX
07944  DEC6              XXDEC6 = *
07945  DEC6  B9 FF 00           LDA     XX0100-1,Y     ; GET CHARACTER FRO
M OUTPUT STRING
07946  DEC9  88                 DEY                    ; DECREMENT OUTPUT 
STRING INDEX
07947  DECA  C9 30              CMP     #'0'               ; COMPARE WITH 
'0'
07948  DECC  F0 F8              BEQ     XXDEC6          ; LOOP UNTIL NON '
0' CHARACTER FOUND
07949  DECE                     
07950  DECE  C9 2E              CMP     #'.'               ; COMPARE WITH 
'.'
07951  DED0  F0 01              BEQ     XXDED3          ; BRANCH IF WAS DP

07952  DED2                     
07953  DED2                                     ; RESTORE LAST CHARACTER
07954  DED2  C8                 INY                    ; INCREMENT OUTPUT 
STRING INDEX
07955  DED3              XXDED3 = *
07956  DED3  A9 2B              LDA     #'+'               ; CHARACTER '+'

07957  DED5  A6 5E              LDX     XX5E          ; GET EXPONENT COUNT

07958  DED7  F0 2E              BEQ     XXDF07          ; IF ZERO GO SET N
ULL TERMINATOR AND EXIT
07959  DED9                     
07960  DED9                                     ; EXPONENT ISN'T ZERO SO W
RITE EXPONENT
07961  DED9  10 08              BPL     XXDEE3          ; BRANCH IF EXPONE
NT COUNT +VE
07962  DEDB                     
07963  DEDB  A9 00              LDA     #$00               ; CLEAR A
07964  DEDD  38                 SEC                    ; SET CARRY FOR SUB
TRACT
07965  DEDE  E5 5E              SBC     XX5E          ; SUBTRACT EXPONENT 
COUNT ADJUST (CONVERT -VE TO +VE)
07966  DEE0  AA                 TAX                    ; COPY EXPONENT COU
NT TO X






ERSVE)......PAGE 0149

LINE# LOC   CODE        LINE


07967  DEE1  A9 2D              LDA     #'-'               ; CHARACTER '-'

07968  DEE3              XXDEE3 = *
07969  DEE3  99 01 01           STA     XX0100+1,Y     ; SAVE TO OUTPUT ST
RING
07970  DEE6  A9 45              LDA     #'E'               ; CHARACTER 'E'

07971  DEE8  99 00 01           STA     XX0100,Y          ; SAVE EXPONENT 
SIGN TO OUTPUT STRING
07972  DEEB  8A                 TXA                    ; GET EXPONENT COUN
T BACK
07973  DEEC  A2 2F              LDX     #$2F               ; ONE LESS THAN
 '0' CHARACTER
07974  DEEE  38                 SEC                    ; SET CARRY FOR SUB
TRACT
07975  DEEF              XXDEEF = *
07976  DEEF  E8                 INX                    ; INCREMENT 10'S CH
ARACTER
07977  DEF0  E9 0A              SBC     #$0A               ; SUBTRACT 10 F
ROM EXPONENT COUNT
07978  DEF2  B0 FB              BCS     XXDEEF          ; LOOP WHILE STILL
 >= 0
07979  DEF4                     
07980  DEF4  69 3A              ADC     #':'               ; ADD CHARACTER
 ':' ($30+$0A, RESULT IS 10 LESS THAT VALUE)
07981  DEF6  99 03 01           STA     XX0100+3,Y     ; SAVE TO OUTPUT ST
RING
07982  DEF9  8A                 TXA                    ; COPY 10'S CHARACT
ER
07983  DEFA  99 02 01           STA     XX0100+2,Y     ; SAVE TO OUTPUT ST
RING
07984  DEFD  A9 00              LDA     #$00               ; SET NULL TERM
INATOR
07985  DEFF  99 04 01           STA     XX0100+4,Y     ; SAVE TO OUTPUT ST
RING
07986  DF02  F0 08              BEQ     XXDF0C          ; GO SET STRING PO
INTER (AY) AND EXIT, BRANCH ALWAYS
07987  DF04                     
07988  DF04                                     ; SAVE LAST CHARACTER, [EO
T] AND EXIT
07989  DF04              XXDF04 = *
07990  DF04  99 FF 00           STA     XX0100-1,Y     ; SAVE LAST CHARACT
ER TO OUTPUT STRING
07991  DF07                     
07992  DF07                                     ; SET NULL TERMINATOR AND 
EXIT
07993  DF07              XXDF07 = *
07994  DF07  A9 00              LDA     #$00               ; SET NULL TERM
INATOR
07995  DF09  99 00 01           STA     XX0100,Y          ; SAVE AFTER LAS
T CHARACTER
07996  DF0C                     
07997  DF0C                                     ; SET STRING POINTER (AY) 
AND EXIT
07998  DF0C              XXDF0C = *
07999  DF0C  A9 00              LDA     #<XX0100          ; SET RESULT STR
ING POINTER LOW BYTE
08000  DF0E  A0 01              LDY     #>XX0100          ; SET RESULT STR
ING POINTER HIGH BYTE
08001  DF10  60                 RTS
08002  DF11                     
08003  DF11                     
08004  DF11              ;************************************************
***********************************;
08005  DF11              ;
08006  DF11              
08007  DF11              XXDF11 = *
08008  DF11  80                 .BYTE     $80,$00          ; 0.5, FIRST TW
O BYTES
08008  DF12  00 
08009  DF13              XXDF13 = *
08010  DF13  00                 .BYTE     $00,$00,$00          ; NULL RETU
RN FOR UNDEFINED VARIABLES
08010  DF14  00 
08010  DF15  00 
08011  DF16                     
08012  DF16              ; DECIMAL CONVERSION TABLS
08013  DF16              
08014  DF16              XXDF16 = *
08015  DF16  FA                 .BYTE     $FA,$0A,$1F,$00     ; -100000000

08015  DF17  0A 
08015  DF18  1F 
08015  DF19  00 






****;V......PAGE 0150

LINE# LOC   CODE        LINE


08016  DF1A  00                 .BYTE     $00,$98,$96,$80     ;  +10000000

08016  DF1B  98 
08016  DF1C  96 
08016  DF1D  80 
08017  DF1E  FF                 .BYTE     $FF,$F0,$BD,$C0     ;   -1000000

08017  DF1F  F0 
08017  DF20  BD 
08017  DF21  C0 
08018  DF22  00                 .BYTE     $00,$01,$86,$A0     ;    +100000

08018  DF23  01 
08018  DF24  86 
08018  DF25  A0 
08019  DF26  FF                 .BYTE     $FF,$FF,$D8,$F0     ;     -10000

08019  DF27  FF 
08019  DF28  D8 
08019  DF29  F0 
08020  DF2A  00                 .BYTE     $00,$00,$03,$E8     ;      +1000

08020  DF2B  00 
08020  DF2C  03 
08020  DF2D  E8 
08021  DF2E  FF                 .BYTE     $FF,$FF,$FF,$9C     ;       -100

08021  DF2F  FF 
08021  DF30  FF 
08021  DF31  9C 
08022  DF32  00                 .BYTE     $00,$00,$00,$0A     ;        +10

08022  DF33  00 
08022  DF34  00 
08022  DF35  0A 
08023  DF36  FF                 .BYTE     $FF,$FF,$FF,$FF     ;         -1

08023  DF37  FF 
08023  DF38  FF 
08023  DF39  FF 
08024  DF3A                     
08025  DF3A              ; JIFFY COUNT CONVERSION TABLE
08026  DF3A              
08027  DF3A              XXDF3A = *
08028  DF3A  FF                 .BYTE     $FF,$DF,$0A,$80     ; -2160000  
   10S HOURS
08028  DF3B  DF 
08028  DF3C  0A 
08028  DF3D  80 
08029  DF3E  00                 .BYTE     $00,$03,$4B,$C0     ;  +216000  
       HOURS
08029  DF3F  03 
08029  DF40  4B 
08029  DF41  C0 
08030  DF42  FF                 .BYTE     $FF,$FF,$73,$60     ;   -36000  
   10S MINS
08030  DF43  FF 
08030  DF44  73 
08030  DF45  60 
08031  DF46  00                 .BYTE     $00,$00,$0E,$10     ;    +3600  
       MINS
08031  DF47  00 
08031  DF48  0E 
08031  DF49  10 
08032  DF4A  FF                 .BYTE     $FF,$FF,$FD,$A8     ;     -600  
   10S SECS
08032  DF4B  FF 
08032  DF4C  FD 






****;V......PAGE 0151

LINE# LOC   CODE        LINE


08032  DF4D  A8 
08033  DF4E  00                 .BYTE     $00,$00,$00,$3C     ;      +60  
       SECS
08033  DF4F  00 
08033  DF50  00 
08033  DF51  3C 
08034  DF52              XXDF52 = *
08035  DF52              X
08036  DF52              X
08037  DF52              ;************************************************
***********************************;
08038  DF52              ;
08039  DF52              ; SPARE BYTES, NOT REFERENCED
08040  DF52              
08041  DF52  BF                 .BYTE     $BF,$AA,$AA,$AA,$AA,$AA,$AA,$AA,
$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA
08041  DF53  AA 
08041  DF54  AA 
08041  DF55  AA 
08041  DF56  AA 
08041  DF57  AA 
08041  DF58  AA 
08041  DF59  AA 
08041  DF5A  AA 
08041  DF5B  AA 
08041  DF5C  AA 
08041  DF5D  AA 
08041  DF5E  AA 
08041  DF5F  AA 
08041  DF60  AA 
08041  DF61  AA 
08042  DF62  AA                 .BYTE     $AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,
$AA,$AA,$AA,$AA,$AA,$AA,$AA
08042  DF63  AA 
08042  DF64  AA 
08042  DF65  AA 
08042  DF66  AA 
08042  DF67  AA 
08042  DF68  AA 
08042  DF69  AA 
08042  DF6A  AA 
08042  DF6B  AA 
08042  DF6C  AA 
08042  DF6D  AA 
08042  DF6E  AA 
08042  DF6F  AA 
08042  DF70  AA 
08043  DF71                     
08044  DF71                     
08045  DF71              ;************************************************
***********************************;
08046  DF71              ;
08047  DF71              ; PERFORM SQR()
08048  DF71              
08049  DF71              XXDF71 = *
08050  DF71  20 0C DC           JSR     XXDC0C          ; ROUND AND COPY F
AC1 TO FAC2
08051  DF74  A9 11              LDA     #<XXDF11          ; SET 0.5 POINTE
R LOW ADDRESS
08052  DF76  A0 DF              LDY     #>XXDF11          ; SET 0.5 POINTE
R HIGH ADDRESS
08053  DF78  20 A2 DB           JSR     XXDBA2          ; UNPACK MEMORY (A
Y) INTO FAC1
08054  DF7B                     






****;V......PAGE 0152

LINE# LOC   CODE        LINE


08055  DF7B                     
08056  DF7B              ;************************************************
***********************************;
08057  DF7B              ;
08058  DF7B              ; PERFORM POWER FUNCTION
08059  DF7B              
08060  DF7B              XXDF7B = *
08061  DF7B  F0 70              BEQ     XXDFED          ; PERFORM EXP()
08062  DF7D                     
08063  DF7D  A5 69              LDA     XX69          ; GET FAC2 EXPONENT
08064  DF7F  D0 03              BNE     XXDF84          ; BRANCH IF FAC2<>
0
08065  DF81                     
08066  DF81  4C F9 D8           JMP     XXD8F9          ; CLEAR FAC1 EXPON
ENT AND SIGN AND RETURN
08067  DF84                     
08068  DF84              XXDF84 = *
08069  DF84  A2 4E              LDX     #<XX4E          ; SET DESTINATION 
POINTER LOW BYTE
08070  DF86  A0 00              LDY     #>XX4E          ; SET DESTINATION 
POINTER HIGH BYTE
08071  DF88  20 D4 DB           JSR     XXDBD4          ; PACK FAC1 INTO (
XY)
08072  DF8B  A5 6E              LDA     XX6E          ; GET FAC2 SIGN (B7)

08073  DF8D  10 0F              BPL     XXDF9E          ; BRANCH IF FAC2>0

08074  DF8F                     
08075  DF8F                                     ; ELSE FAC2 IS -VE AND CAN
 ONLY BE RAISED TO AN
08076  DF8F                                     ; INTEGER POWER WHICH GIVE
S AN X + J0 RESULT
08077  DF8F  20 CC DC           JSR     XXDCCC          ; PERFORM INT()
08078  DF92  A9 4E              LDA     #<XX4E          ; SET SOURCE POINT
ER LOW BYTE
08079  DF94  A0 00              LDY     #>XX4E          ; SET SOURCE POINT
ER HIGH BYTE
08080  DF96  20 5B DC           JSR     XXDC5B          ; COMPARE FAC1 WIT
H (AY)
08081  DF99  D0 03              BNE     XXDF9E          ; BRANCH IF FAC1 <
> (AY) TO ALLOW FUNCTION CALL ERROR
08082  DF9B                                     ; THIS WILL LEAVE FAC1 -VE
 AND CAUSE A FUNCTION CALL
08083  DF9B                                     ; ERROR WHEN LOG() IS CALL
ED
08084  DF9B                     
08085  DF9B  98                 TYA                    ; CLEAR SIGN B7
08086  DF9C  A4 07              LDY     XX07          ; GET FAC1 MANTISSA 
4 FROM INT() FUNCTION AS SIGN IN
08087  DF9E                                     ; Y FOR POSSIBLE LATER NEG
ATION, B0 ONLY NEEDED
08088  DF9E              XXDF9E = *
08089  DF9E  20 FE DB           JSR     XXDBFE          ; SAVE FAC1 SIGN A
ND COPY ABS(FAC2) TO FAC1
08090  DFA1  98                 TYA                    ; COPY SIGN BACK ..

08091  DFA2  48                 PHA                    ; .. AND SAVE IT
08092  DFA3  20 EA D9           JSR     XXD9EA          ; PERFORM LOG()
08093  DFA6  A9 4E              LDA     #<XX4E          ; SET POINTER LOW 
BYTE
08094  DFA8  A0 00              LDY     #>XX4E          ; SET POINTER HIGH
 BYTE
08095  DFAA  20 28 DA           JSR     XXDA28          ; DO CONVERT AY, F
CA1*(AY)
08096  DFAD  20 ED DF           JSR     XXDFED          ; PERFORM EXP()
08097  DFB0  68                 PLA                    ; PULL SIGN FROM ST
ACK
08098  DFB1  4A                 LSR A                  ; B0 IS TO BE TESTE
D
08099  DFB2  90 0A              BCC     XXDFBE          ; IF NO BIT THEN E
XIT
08100  DFB4                     
08101  DFB4              ; DO - FAC1
08102  DFB4              
08103  DFB4              XXDFB4 = *
08104  DFB4  A5 61              LDA     XX61          ; GET FAC1 EXPONENT
08105  DFB6  F0 06              BEQ     XXDFBE          ; EXIT IF FAC1_E =
 $00
08106  DFB8                     
08107  DFB8  A5 66              LDA     XX66          ; GET FAC1 SIGN (B7)

08108  DFBA  49 FF              EOR     #$FF               ; COMPLEMENT IT

08109  DFBC  85 66              STA     XX66          ; SAVE FAC1 SIGN (B7
)






OR**;V......PAGE 0153

LINE# LOC   CODE        LINE


08110  DFBE              XXDFBE = *
08111  DFBE  60                 RTS
08112  DFBF                     
08113  DFBF                     
08114  DFBF              ;************************************************
***********************************;
08115  DFBF              ;
08116  DFBF              ; EXP(N) CONSTANT AND SERIES
08117  DFBF              
08118  DFBF              XXDFBF = *
08119  DFBF  81                 .BYTE     $81,$38,$AA,$3B,$29     ; 1.443
08119  DFC0  38 
08119  DFC1  AA 
08119  DFC2  3B 
08119  DFC3  29 
08120  DFC4                     
08121  DFC4              XXDFC4 = *
08122  DFC4  07                 .BYTE     $07                    ; SERIES 
COUNT
08123  DFC5  71                 .BYTE     $71,$34,$58,$3E,$56     ; 2.1498
7637E-5
08123  DFC6  34 
08123  DFC7  58 
08123  DFC8  3E 
08123  DFC9  56 
08124  DFCA  74                 .BYTE     $74,$16,$7E,$B3,$1B     ; 1.4352
3140E-4
08124  DFCB  16 
08124  DFCC  7E 
08124  DFCD  B3 
08124  DFCE  1B 
08125  DFCF  77                 .BYTE     $77,$2F,$EE,$E3,$85     ; 1.3422
6348E-3
08125  DFD0  2F 
08125  DFD1  EE 
08125  DFD2  E3 
08125  DFD3  85 
08126  DFD4  7A                 .BYTE     $7A,$1D,$84,$1C,$2A     ; 9.6140
1701E-3
08126  DFD5  1D 
08126  DFD6  84 
08126  DFD7  1C 
08126  DFD8  2A 
08127  DFD9  7C                 .BYTE     $7C,$63,$59,$58,$0A     ; 5.5505
1269E-2
08127  DFDA  63 
08127  DFDB  59 
08127  DFDC  58 
08127  DFDD  0A 
08128  DFDE  7E                 .BYTE     $7E,$75,$FD,$E7,$C6     ; 2.4022
6385E-1
08128  DFDF  75 
08128  DFE0  FD 
08128  DFE1  E7 
08128  DFE2  C6 
08129  DFE3  80                 .BYTE     $80,$31,$72,$18,$10     ; 6.9314
7186E-1
08129  DFE4  31 
08129  DFE5  72 
08129  DFE6  18 
08129  DFE7  10 
08130  DFE8  81                 .BYTE     $81,$00,$00,$00,$00     ; 1.0000
0000
08130  DFE9  00 
08130  DFEA  00 






****;V......PAGE 0154

LINE# LOC   CODE        LINE


08130  DFEB  00 
08130  DFEC  00 
08131  DFED                     
08132  DFED                     
08133  DFED              ;************************************************
***********************************;
08134  DFED              ;
08135  DFED              ; PERFORM EXP()
08136  DFED              
08137  DFED              XXDFED = *
08138  DFED  A9 BF              LDA     #<XXDFBF          ; SET 1.443 POIN
TER LOW BYTE
08139  DFEF  A0 DF              LDY     #>XXDFBF          ; SET 1.443 POIN
TER HIGH BYTE
08140  DFF1  20 28 DA           JSR     XXDA28          ; DO CONVERT AY, F
CA1*(AY)
08141  DFF4  A5 70              LDA     XX70          ; GET FAC1 ROUNDING 
BYTE
08142  DFF6  69 50              ADC     #$50               ; +$50/$100
08143  DFF8  90 03              BCC     XXDFFD          ; SKIP ROUNDING IF
 NO CARRY
08144  DFFA                     
08145  DFFA  20 23 DC           JSR     XXDC23          ; ROUND FAC1 (NO C
HECK)
08146  DFFD              XXDFFD = *
08147  DFFD  85 56              STA     XX56          ; SAVE FAC2 ROUNDING
 BYTE
08148  DFFF  20 0F DC           JSR     XXDC0F          ; COPY FAC1 TO FAC
2
08149  E002  A5 61              LDA     XX61          ; GET FAC1 EXPONENT
08150  E004  C9 88              CMP     #$88               ; COMPARE WITH 
EXP LIMIT (256D)
08151  E006  90 03              BCC     XXE00B          ; BRANCH IF LESS
08152  E008                     
08153  E008              XXE008 = *
08154  E008  20 D4 DA           JSR     XXDAD4          ; HANDLE OVERFLOW 
AND UNDERFLOW
08155  E00B              XXE00B = *
08156  E00B  20 CC DC           JSR     XXDCCC          ; PERFORM INT()
08157  E00E  A5 07              LDA     XX07          ; GET MANTISSA 4 FRO
M INT()
08158  E010  18                 CLC                    ; CLEAR CARRY FOR A
DD
08159  E011  69 81              ADC     #$81               ; NORMALISE +1
08160  E013  F0 F3              BEQ     XXE008          ; IF $00 RESULT HA
S OVERFLOWED SO GO HANDLE IT
08161  E015                     
08162  E015  38                 SEC                    ; SET CARRY FOR SUB
TRACT
08163  E016  E9 01              SBC     #$01               ; EXPONENT NOW 
CORRECT
08164  E018  48                 PHA                    ; SAVE FAC2 EXPONEN
T
08165  E019                                     ; SWAP FAC1 AND FAC2
08166  E019  A2 05              LDX     #$05               ; 4 BYTES TO DO

08167  E01B              XXE01B = *
08168  E01B  B5 69              LDA     XX69,X          ; GET FAC2,X
08169  E01D  B4 61              LDY     XX61,X          ; GET FAC1,X
08170  E01F  95 61              STA     XX61,X          ; SAVE FAC1,X
08171  E021  94 69              STY     XX69,X          ; SAVE FAC2,X
08172  E023  CA                 DEX                    ; DECREMENT COUNT/I
NDEX
08173  E024  10 F5              BPL     XXE01B          ; LOOP IF NOT ALL 
DONE
08174  E026                     
08175  E026  A5 56              LDA     XX56          ; GET FAC2 ROUNDING 
BYTE
08176  E028  85 70              STA     XX70          ; SAVE AS FAC1 ROUND
ING BYTE
08177  E02A  20 53 D8           JSR     XXD853          ; PERFORM SUBTRACT
ION, FAC2 FROM FAC1
08178  E02D  20 B4 DF           JSR     XXDFB4          ; DO - FAC1
08179  E030  A9 C4              LDA     #<XXDFC4          ; SET COUNTER PO
INTER LOW BYTE
08180  E032  A0 DF              LDY     #>XXDFC4          ; SET COUNTER PO
INTER HIGH BYTE
08181  E034  20 56 E0           JSR     XXE056          ; GO DO SERIES EVA
LUATION
08182  E037  A9 00              LDA     #$00               ; CLEAR A
08183  E039  85 6F              STA     XX6F          ; CLEAR SIGN COMPARE
 (FAC1 EOR FAC2)






****;V......PAGE 0155

LINE# LOC   CODE        LINE


08184  E03B  68                 PLA                    ; PULL THE SAVED FA
C2 EXPONENT
08185  E03C  20 B9 DA           JSR     XXDAB9          ; TEST AND ADJUST 
ACCUMULATORS
08186  E03F  60                 RTS
08187  E040                     
08188  E040                     
08189  E040              ;************************************************
***********************************;
08190  E040              ;
08191  E040              ; ^2 THEN SERIES EVALUATION
08192  E040              
08193  E040              XXE040 = *
08194  E040  85 71              STA     XX71          ; SAVE COUNT POINTER
 LOW BYTE
08195  E042  84 72              STY     XX72          ; SAVE COUNT POINTER
 HIGH BYTE
08196  E044  20 CA DB           JSR     XXDBCA          ; PACK FAC1 INTO X
X57
08197  E047  A9 57              LDA     #<XX57          ; SET POINTER LOW 
BYTE (Y ALREADY $00)
08198  E049  20 28 DA           JSR     XXDA28          ; DO CONVERT AY, F
CA1*(AY)
08199  E04C  20 5A E0           JSR     XXE05A          ; GO DO SERIES EVA
LUATION
08200  E04F  A9 57              LDA     #<XX57          ; POINTER TO ORIGI
NAL # LOW BYTE
08201  E051  A0 00              LDY     #>XX57          ; POINTER TO ORIGI
NAL # HIGH BYTE
08202  E053  4C 28 DA           JMP     XXDA28          ; DO CONVERT AY, F
CA1*(AY)
08203  E056                     
08204  E056                     
08205  E056              ;************************************************
***********************************;
08206  E056              ;
08207  E056              ; DO SERIES EVALUATION
08208  E056              
08209  E056              XXE056 = *
08210  E056  85 71              STA     XX71          ; SAVE COUNT POINTER
 LOW BYTE
08211  E058  84 72              STY     XX72          ; SAVE COUNT POINTER
 HIGH BYTE
08212  E05A                     
08213  E05A              ; DO SERIES EVALUATION
08214  E05A              
08215  E05A              XXE05A = *
08216  E05A  20 C7 DB           JSR     XXDBC7          ; PACK FAC1 INTO X
X5C
08217  E05D  B1 71              LDA     (XX71),Y          ; GET CONSTANTS 
COUNT
08218  E05F  85 67              STA     XX67          ; SAVE CONSTANTS COU
NT
08219  E061  A4 71              LDY     XX71          ; GET COUNT POINTER 
LOW BYTE
08220  E063  C8                 INY                    ; INCREMENT IT (NOW
 CONSTANTS POINTER)
08221  E064  98                 TYA                    ; COPY IT
08222  E065  D0 02              BNE     XXE069          ; SKIP NEXT IF NO 
OVERFLOW
08223  E067                     
08224  E067  E6 72              INC     XX72          ; ELSE INCREMENT HIG
H BYTE
08225  E069              XXE069 = *
08226  E069  85 71              STA     XX71          ; SAVE LOW BYTE
08227  E06B  A4 72              LDY     XX72          ; GET HIGH BYTE
08228  E06D              XXE06D = *
08229  E06D  20 28 DA           JSR     XXDA28          ; DO CONVERT AY, F
CA1*(AY)
08230  E070  A5 71              LDA     XX71          ; GET CONSTANTS POIN
TER LOW BYTE
08231  E072  A4 72              LDY     XX72          ; GET CONSTANTS POIN
TER HIGH BYTE
08232  E074  18                 CLC                    ; CLEAR CARRY FOR A
DD
08233  E075  69 05              ADC     #$05               ; +5 TO LOW POI
NTER (5 BYTES PER CONSTANT)
08234  E077  90 01              BCC     XXE07A          ; SKIP NEXT IF NO 
OVERFLOW
08235  E079                     
08236  E079  C8                 INY                    ; INCREMENT HIGH BY
TE
08237  E07A              XXE07A = *
08238  E07A  85 71              STA     XX71          ; SAVE POINTER LOW B
YTE






****;V......PAGE 0156

LINE# LOC   CODE        LINE


08239  E07C  84 72              STY     XX72          ; SAVE POINTER HIGH 
BYTE
08240  E07E  20 67 D8           JSR     XXD867          ; ADD (AY) TO FAC1

08241  E081  A9 5C              LDA     #<XX5C          ; SET POINTER LOW 
BYTE TO PARTIAL
08242  E083  A0 00              LDY     #>XX5C          ; SET POINTER HIGH
 BYTE TO PARTIAL
08243  E085  C6 67              DEC     XX67          ; DECREMENT CONSTANT
S COUNT
08244  E087  D0 E4              BNE     XXE06D          ; LOOP UNTIL ALL D
ONE
08245  E089                     
08246  E089  60                 RTS
08247  E08A                     
08248  E08A                     
08249  E08A              ;************************************************
***********************************;
08250  E08A              ;
08251  E08A              ; RND VALUES
08252  E08A              
08253  E08A              XXE08A = *
08254  E08A  98                 .BYTE     $98,$35,$44,$7A,$00
08254  E08B  35 
08254  E08C  44 
08254  E08D  7A 
08254  E08E  00 
08255  E08F                                     ; 11879546               M
ULTIPLIER
08256  E08F              XXE08F = *
08257  E08F  68                 .BYTE     $68,$28,$B1,$46,$00
08257  E090  28 
08257  E091  B1 
08257  E092  46 
08257  E093  00 
08258  E094                                     ; 3.927677739E-8          
OFFSET
08259  E094                     
08260  E094                     
08261  E094              ;************************************************
***********************************;
08262  E094              ;
08263  E094              ; PERFORM RND()
08264  E094              
08265  E094              XXE094 = *
08266  E094  20 2B DC           JSR     XXDC2B          ; GET FAC1 SIGN
08267  E097                                     ; RETURN A = $FF -VE, A = 
$01 +VE
08268  E097  30 37              BMI     XXE0D0          ; IF N<0 COPY BYTE
 SWAPPED FAC1 INTO RND() SEED
08269  E099                     
08270  E099  D0 20              BNE     XXE0BB          ; IF N>0 GET NEXT 
NUMBER IN RND() SEQUENCE
08271  E09B                     
08272  E09B                                     ; ELSE N=0 SO GET THE RND(
) NUMBER FROM VIA 1 TIMERS
08273  E09B  20 F3 FF           JSR     XXFFF3          ; RETURN BASE ADDR
ESS OF I/O DEVICES
08274  E09E  86 22              STX     XX22          ; SAVE POINTER LOW B
YTE
08275  E0A0  84 23              STY     XX23          ; SAVE POINTER HIGH 
BYTE
08276  E0A2  A0 04              LDY     #$04               ; SET INDEX TO 
T1 LOW BYTE
08277  E0A4  B1 22              LDA     (XX22),Y          ; GET T1 LOW BYT
E
08278  E0A6  85 62              STA     XX62          ; SAVE FAC1 MANTISSA
 1
08279  E0A8  C8                 INY                    ; INCREMENT INDEX
08280  E0A9  B1 22              LDA     (XX22),Y          ; GET T1 HIGH BY
TE
08281  E0AB  85 64              STA     XX64          ; SAVE FAC1 MANTISSA
 3
08282  E0AD  A0 08              LDY     #$08               ; SET INDEX TO 
T2 LOW BYTE
08283  E0AF  B1 22              LDA     (XX22),Y          ; GET T2 LOW BYT
E
08284  E0B1  85 63              STA     XX63          ; SAVE FAC1 MANTISSA
 2
08285  E0B3  C8                 INY                    ; INCREMENT INDEX






****;V......PAGE 0157

LINE# LOC   CODE        LINE


08286  E0B4  B1 22              LDA     (XX22),Y          ; GET T2 HIGH BY
TE
08287  E0B6  85 65              STA     XX65          ; SAVE FAC1 MANTISSA
 4
08288  E0B8  4C E0 E0           JMP     XXE0E0          ; SET EXPONENT AND
 EXIT
08289  E0BB                     
08290  E0BB              XXE0BB = *
08291  E0BB  A9 8B              LDA     #<XX008B          ; SET SEED POINT
ER LOW ADDRESS
08292  E0BD  A0 00              LDY     #>XX008B          ; SET SEED POINT
ER HIGH ADDRESS
08293  E0BF  20 A2 DB           JSR     XXDBA2          ; UNPACK MEMORY (A
Y) INTO FAC1
08294  E0C2  A9 8A              LDA     #<XXE08A          ; SET 11879546 P
OINTER LOW BYTE
08295  E0C4  A0 E0              LDY     #>XXE08A          ; SET 11879546 P
OINTER HIGH BYTE
08296  E0C6  20 28 DA           JSR     XXDA28          ; DO CONVERT AY, F
CA1*(AY)
08297  E0C9  A9 8F              LDA     #<XXE08F          ; SET 3.92767773
9E-8 POINTER LOW BYTE
08298  E0CB  A0 E0              LDY     #>XXE08F          ; SET 3.92767773
9E-8 POINTER HIGH BYTE
08299  E0CD  20 67 D8           JSR     XXD867          ; ADD (AY) TO FAC1

08300  E0D0              XXE0D0 = *
08301  E0D0  A6 65              LDX     XX65          ; GET FAC1 MANTISSA 
4
08302  E0D2  A5 62              LDA     XX62          ; GET FAC1 MANTISSA 
1
08303  E0D4  85 65              STA     XX65          ; SAVE FAC1 MANTISSA
 4
08304  E0D6  86 62              STX     XX62          ; SAVE FAC1 MANTISSA
 1
08305  E0D8  A6 63              LDX     XX63          ; GET FAC1 MANTISSA 
2
08306  E0DA  A5 64              LDA     XX64          ; GET FAC1 MANTISSA 
3
08307  E0DC  85 63              STA     XX63          ; SAVE FAC1 MANTISSA
 2
08308  E0DE  86 64              STX     XX64          ; SAVE FAC1 MANTISSA
 3
08309  E0E0              XXE0E0 = *
08310  E0E0  A9 00              LDA     #$00               ; CLEAR BYTE
08311  E0E2  85 66              STA     XX66          ; CLEAR FAC1 SIGN (A
LWAYS +VE)
08312  E0E4  A5 61              LDA     XX61          ; GET FAC1 EXPONENT
08313  E0E6  85 70              STA     XX70          ; SAVE FAC1 ROUNDING
 BYTE
08314  E0E8  A9 80              LDA     #$80               ; SET EXPONENT 
= $80
08315  E0EA  85 61              STA     XX61          ; SAVE FAC1 EXPONENT

08316  E0EC  20 D7 D8           JSR     XXD8D7          ; NORMALISE FAC1
08317  E0EF  A2 8B              LDX     #<XX008B          ; SET SEED POINT
ER LOW ADDRESS
08318  E0F1  A0 00              LDY     #>XX008B          ; SET SEED POINT
ER HIGH ADDRESS
08319  E0F3                     
08320  E0F3                     
08321  E0F3              ;************************************************
***********************************;
08322  E0F3              ;
08323  E0F3              ; PACK FAC1 INTO (XY)
08324  E0F3              
08325  E0F3              XXE0F3 = *
08326  E0F3  4C D4 DB           JMP     XXDBD4          ; PACK FAC1 INTO (
XY)
08327  E0F6                     
08328  E0F6                     
08329  E0F6              ;************************************************
***********************************;
08330  E0F6              ;
08331  E0F6              ; HANDLE BASIC I/O ERROR
08332  E0F6              
08333  E0F6              XXE0F6 = *
08334  E0F6  C9 F0              CMP     #$F0               ; COMPARE ERROR
 WITH $F0
08335  E0F8  D0 07              BNE     XXE101          ; BRANCH IF NOT $F
0
08336  E0FA                     
08337  E0FA  84 38              STY     XX38          ; SET END OF MEMORY 
HIGH BYTE
08338  E0FC  86 37              STX     XX37          ; SET END OF MEMORY 
LOW BYTE
08339  E0FE  4C 63 C6           JMP     XXC663          ; CLEAR FROM START
 TO END AND RETURN
08340  E101                     






****;V......PAGE 0158

LINE# LOC   CODE        LINE


08341  E101                                     ; ERROR WAS NOT $F0
08342  E101              XXE101 = *
08343  E101  AA                 TAX                    ; COPY ERROR #
08344  E102  D0 02              BNE     XXE106          ; BRANCH IF NOT $0
0
08345  E104                     
08346  E104  A2 1E              LDX     #$1E               ; ELSE ERROR $1
E, BREAK ERROR
08347  E106              XXE106 = *
08348  E106  4C 37 C4           JMP     XXC437          ; DO ERROR #X THEN
 WARM START
08349  E109                     
08350  E109                     
08351  E109              ;************************************************
***********************************;
08352  E109              ;
08353  E109              ; OUTPUT CHARACTER TO CHANNEL WITH ERROR CHECK
08354  E109              
08355  E109              XXE109 = *
08356  E109  20 D2 FF           JSR     XXFFD2          ; OUTPUT CHARACTER
 TO CHANNEL
08357  E10C  B0 E8              BCS     XXE0F6          ; IF ERROR GO HAND
LE BASIC I/O ERROR
08358  E10E                     
08359  E10E  60                 RTS
08360  E10F                     
08361  E10F                     
08362  E10F              ;************************************************
***********************************;
08363  E10F              ;
08364  E10F              ; INPUT CHARACTER FROM CHANNEL WITH ERROR CHECK
08365  E10F              
08366  E10F              XXE10F = *
08367  E10F  20 CF FF           JSR     XXFFCF          ; INPUT CHARACTER 
FROM CHANNEL
08368  E112  B0 E2              BCS     XXE0F6          ; IF ERROR GO HAND
LE BASIC I/O ERROR
08369  E114                     
08370  E114  60                 RTS
08371  E115                     
08372  E115                     
08373  E115              ;************************************************
***********************************;
08374  E115              ;
08375  E115              ; OPEN CHANNEL FOR OUTPUT WITH ERROR CHECK
08376  E115              
08377  E115              XXE115 = *
08378  E115  20 C9 FF           JSR     XXFFC9          ; OPEN CHANNEL FOR
 OUTPUT
08379  E118  B0 DC              BCS     XXE0F6          ; IF ERROR GO HAND
LE BASIC I/O ERROR
08380  E11A                     
08381  E11A  60                 RTS
08382  E11B                     
08383  E11B                     
08384  E11B              ;************************************************
***********************************;
08385  E11B              ;
08386  E11B              ; OPEN CHANNEL FOR INPUT WITH ERROR CHECK
08387  E11B              
08388  E11B              XXE11B = *
08389  E11B  20 C6 FF           JSR     XXFFC6          ; OPEN CHANNEL FOR
 INPUT
08390  E11E  B0 D6              BCS     XXE0F6          ; IF ERROR GO HAND
LE BASIC I/O ERROR
08391  E120                     
08392  E120  60                 RTS
08393  E121                     
08394  E121                     
08395  E121              ;************************************************
***********************************;






****;V......PAGE 0159

LINE# LOC   CODE        LINE


08396  E121              ;
08397  E121              ; GET CHARACTER FROM INPUT DEVICE WITH ERROR CHEC
K
08398  E121              
08399  E121              XXE121 = *
08400  E121  20 E4 FF           JSR     XXFFE4          ; GET CHARACTER FR
OM INPUT DEVICE
08401  E124  B0 D0              BCS     XXE0F6          ; IF ERROR GO HAND
LE BASIC I/O ERROR
08402  E126                     
08403  E126  60                 RTS
08404  E127                     
08405  E127                     
08406  E127              ;************************************************
***********************************;
08407  E127              ;
08408  E127              ; PERFORM SYS
08409  E127              
08410  E127              XXE127 = *
08411  E127  20 8A CD           JSR     XXCD8A          ; EVALUATE EXPRESS
ION AND CHECK IS NUMERIC, ELSE DO
08412  E12A                                     ; TYPE MISMATCH
08413  E12A  20 F7 D7           JSR     XXD7F7          ; CONVERT FAC_1 TO
 INTEGER IN TEMPORARY INTEGER
08414  E12D  A9 E1              LDA     #>XXE143          ; GET RETURN ADD
RESS HIGH BYTE
08415  E12F  48                 PHA                    ; PUSH AS RETURN AD
DRESS
08416  E130  A9 43              LDA     #<XXE143          ; GET RETURN ADD
RESS LOW BYTE
08417  E132  48                 PHA                    ; PUSH AS RETURN AD
DRESS
08418  E133  AD 0F 03           LDA     XX030F          ; GET SAVED STATUS
 REGISTER
08419  E136  48                 PHA                    ; PUT ON STACK
08420  E137  AD 0C 03           LDA     XX030C          ; GET SAVED A
08421  E13A  AE 0D 03           LDX     XX030D          ; GET SAVED X
08422  E13D  AC 0E 03           LDY     XX030E          ; GET SAVED Y
08423  E140  28                 PLP                    ; PULL PROCESSOR ST
ATUS
08424  E141  6C 14 00           JMP     (XX14)          ; CALL SYS ADDRESS

08425  E144                     
08426  E144              ; TAIL END OF THE SYS CODE
08427  E144              ;
08428  E144              ; THE XXE143 IS NEEDED BECAUSE THE FOLLOWING CODE
 IS TO BE EXECUTED ONCE THE USER CODE
08429  E144              ; RETURNS. THIS IS DONE BY PUSHING THE TARGET RET
URN ADDRESS - 1 ONTO THE STACK
08430  E144              
08431  E144              XXE143 = *-1
08432  E144              ;XXE144
08433  E144  08                 PHP                    ; SAVE STATUS
08434  E145  8D 0C 03           STA     XX030C          ; SAVE RETURNED A
08435  E148  8E 0D 03           STX     XX030D          ; SAVE RETURNED X
08436  E14B  8C 0E 03           STY     XX030E          ; SAVE RETURNED Y
08437  E14E  68                 PLA                    ; RESTORE SAVED STA
TUS
08438  E14F  8D 0F 03           STA     XX030F          ; SAVE STATUS
08439  E152  60                 RTS
08440  E153                     
08441  E153                     
08442  E153              ;************************************************
***********************************;
08443  E153              ;
08444  E153              ; PERFORM SAVE
08445  E153              
08446  E153              XXE153 = *
08447  E153  20 D1 E1           JSR     XXE1D1          ; GET PARAMETERS F
OR LOAD/SAVE
08448  E156  A6 2D              LDX     XX2D          ; GET START OF VARIA
BLES LOW BYTE
08449  E158  A4 2E              LDY     XX2E          ; GET START OF VARIA
BLES HIGH BYTE
08450  E15A  A9 2B              LDA     #XX2B          ; INDEX TO START OF
 PROGRAM MEMORY






Y = EN......PAGE 0160

LINE# LOC   CODE        LINE


08451  E15C  20 D8 FF           JSR     XXFFD8          ; SAVE RAM TO DEVI
CE, A = INDEX TO START ADDRESS, XY = END
08452  E15F                                     ; ADDRESS LOW/HIGH
08453  E15F  B0 95              BCS     XXE0F6          ; IF ERROR GO HAND
LE BASIC I/O ERROR
08454  E161                     
08455  E161  60                 RTS
08456  E162                     
08457  E162                     
08458  E162              ;************************************************
***********************************;
08459  E162              ;
08460  E162              ; PERFORM VERIFY
08461  E162              
08462  E162              XXE162 = *
08463  E162  A9 01              LDA     #$01               ; FLAG VERIFY
08464  E164  2C                 .BYTE     $2C               ; MAKES NEXT L
INE BIT XX00A9
08465  E165                     
08466  E165                     
08467  E165              ;************************************************
***********************************;
08468  E165              ;
08469  E165              ; PERFORM LOAD
08470  E165              
08471  E165              XXE165 = *
08472  E165  A9 00              LDA     #$00               ; FLAG LOAD
08473  E167  85 0A              STA     XX0A          ; SET LOAD/VERIFY FL
AG
08474  E169  20 D1 E1           JSR     XXE1D1          ; GET PARAMETERS F
OR LOAD/SAVE
08475  E16C  A5 0A              LDA     XX0A          ; GET LOAD/VERIFY FL
AG
08476  E16E  A6 2B              LDX     XX2B          ; GET START OF MEMOR
Y LOW BYTE
08477  E170  A4 2C              LDY     XX2C          ; GET START OF MEMOR
Y HIGH BYTE
08478  E172  20 D5 FF           JSR     XXFFD5          ; LOAD RAM FROM A 
DEVICE
08479  E175  B0 57              BCS     XXE1CE          ; IF ERROR GO HAND
LE BASIC I/O ERROR
08480  E177                     
08481  E177  A5 0A              LDA     XX0A          ; GET LOAD/VERIFY FL
AG
08482  E179  F0 1A              BEQ     XXE195          ; BRANCH IF LOAD
08483  E17B                     
08484  E17B  A2 1C              LDX     #$1C               ; ERROR $1C, VE
RIFY ERROR
08485  E17D  20 B7 FF           JSR     XXFFB7          ; READ I/O STATUS 
WORD
08486  E180  29 10              AND     #$10               ; MASK FOR TAPE
 READ ERROR
08487  E182  F0 03              BEQ     XXE187          ; BRANCH IF NO REA
D ERROR
08488  E184                     
08489  E184  4C 37 C4           JMP     XXC437          ; DO ERROR #X THEN
 WARM START
08490  E187                     
08491  E187              XXE187 = *
08492  E187  A5 7A              LDA     XX7A          ; GET BASIC EXECUTE 
POINTER LOW BYTE
08493  E189                                     ; IS THIS CORRECT ?? WON'T
 THIS MEAN THE 'OK' PROMPT
08494  E189                                     ; WHEN DOING A LOAD FROM W
ITHIN A PROGRAM ?
08495  E189  C9 02              CMP     #$02               ;.
08496  E18B  F0 07              BEQ     XXE194          ; IF ?? SKIP 'OK' 
PROMPT
08497  E18D                     
08498  E18D  A9 64              LDA     #<XXC364          ; SET 'OK' POINT
ER LOW BYTE
08499  E18F  A0 C3              LDY     #>XXC364          ; SET 'OK' POINT
ER HIGH BYTE
08500  E191  4C 1E CB           JMP     XXCB1E          ; PRINT NULL TERMI
NATED STRING
08501  E194                     
08502  E194              XXE194 = *
08503  E194  60                 RTS
08504  E195                     
08505  E195                     






****;N......PAGE 0161

LINE# LOC   CODE        LINE


08506  E195              ;************************************************
***********************************;
08507  E195              ;
08508  E195              ; DO READY RETURN TO BASIC ??
08509  E195              
08510  E195              XXE195 = *
08511  E195  20 B7 FF           JSR     XXFFB7          ; READ I/O STATUS 
WORD
08512  E198  29 BF              AND     #$BF               ; MASK X0XX XXX
X, CLEAR READ ERROR
08513  E19A  F0 05              BEQ     XXE1A1          ; BRANCH IF NO ERR
ORS
08514  E19C                     
08515  E19C  A2 1D              LDX     #$1D               ; ERROR $1D, LO
AD ERROR
08516  E19E  4C 37 C4           JMP     XXC437          ; DO ERROR #X THEN
 WARM START
08517  E1A1                     
08518  E1A1              XXE1A1 = *
08519  E1A1  A5 7B              LDA     XX7B          ; GET BASIC EXECUTE 
POINTER HIGH BYTE
08520  E1A3  C9 02              CMP     #$02               ; COMPARE WITH 
$02XX
08521  E1A5  D0 0E              BNE     XXE1B5          ; BRANCH IF NOT IM
MEDIATE MODE
08522  E1A7                     
08523  E1A7  86 2D              STX     XX2D          ; SET START OF VARIA
BLES LOW BYTE
08524  E1A9  84 2E              STY     XX2E          ; SET START OF VARIA
BLES HIGH BYTE
08525  E1AB  A9 76              LDA     #<XXC376          ; SET 'READY.' P
OINTER LOW BYTE
08526  E1AD  A0 C3              LDY     #>XXC376          ; SET 'READY.' P
OINTER HIGH BYTE
08527  E1AF  20 1E CB           JSR     XXCB1E          ; PRINT NULL TERMI
NATED STRING
08528  E1B2  4C 2A C5           JMP     XXC52A          ; RESET EXECUTION,
 CLEAR VARIABLES, FLUSH STACK,
08529  E1B5                                     ; REBUILD BASIC CHAIN AND 
DO WARM START
08530  E1B5                     
08531  E1B5              XXE1B5 = *
08532  E1B5  20 8E C6           JSR     XXC68E          ; SET BASIC EXECUT
E POINTER TO START OF MEMORY - 1
08533  E1B8  4C 76 E4           JMP     XXE476          ; REBUILD BASIC LI
NE CHAINING, DO RESTORE AND RETURN
08534  E1BB                     
08535  E1BB                     
08536  E1BB              ;************************************************
***********************************;
08537  E1BB              ;
08538  E1BB              ; PERFORM OPEN
08539  E1BB              
08540  E1BB              XXE1BB = *
08541  E1BB  20 16 E2           JSR     XXE216          ; GET PARAMETERS F
OR OPEN/CLOSE
08542  E1BE  20 C0 FF           JSR     XXFFC0          ; OPEN A LOGICAL F
ILE
08543  E1C1  B0 0B              BCS     XXE1CE          ; BRANCH IF ERROR
08544  E1C3                     
08545  E1C3  60                 RTS
08546  E1C4                     
08547  E1C4                     
08548  E1C4              ;************************************************
***********************************;
08549  E1C4              ;
08550  E1C4              ; PERFORM CLOSE
08551  E1C4              
08552  E1C4              XXE1C4 = *
08553  E1C4  20 16 E2           JSR     XXE216          ; GET PARAMETERS F
OR OPEN/CLOSE
08554  E1C7  A5 49              LDA     XX49          ; GET LOGICAL FILE N
UMBER
08555  E1C9  20 C3 FF           JSR     XXFFC3          ; CLOSE A SPECIFIE
D LOGICAL FILE
08556  E1CC  90 C6              BCC     XXE194          ; EXIT IF NO ERROR

08557  E1CE                     
08558  E1CE              XXE1CE = *
08559  E1CE  4C F6 E0           JMP     XXE0F6          ; GO HANDLE BASIC 
I/O ERROR
08560  E1D1                     






****;N......PAGE 0162

LINE# LOC   CODE        LINE


08561  E1D1                     
08562  E1D1              ;************************************************
***********************************;
08563  E1D1              ;
08564  E1D1              ; GET PARAMETERS FOR LOAD/SAVE
08565  E1D1              
08566  E1D1              XXE1D1 = *
08567  E1D1  A9 00              LDA     #$00               ; CLEAR FILE NA
ME LENGTH
08568  E1D3  20 BD FF           JSR     XXFFBD          ; CLEAR FILENAME
08569  E1D6  A2 01              LDX     #$01               ; SET DEFAULT D
EVICE NUMBER, CASSETTE
08570  E1D8  A0 00              LDY     #$00               ; SET DEFAULT C
OMMAND
08571  E1DA  20 BA FF           JSR     XXFFBA          ; SET LOGICAL, FIR
ST AND SECOND ADDRESSES
08572  E1DD  20 03 E2           JSR     XXE203          ; EXIT FUNCTION IF
 [EOT] OR ':'
08573  E1E0  20 54 E2           JSR     XXE254          ; SET FILENAME
08574  E1E3  20 03 E2           JSR     XXE203          ; EXIT FUNCTION IF
 [EOT] OR ':'
08575  E1E6  20 FD E1           JSR     XXE1FD          ; SCAN AND GET BYT
E, ELSE DO SYNTAX ERROR THEN WARM START
08576  E1E9  A0 00              LDY     #$00               ; CLEAR COMMAND

08577  E1EB  86 49              STX     XX49          ; SAVE DEVICE NUMBER

08578  E1ED  20 BA FF           JSR     XXFFBA          ; SET LOGICAL, FIR
ST AND SECOND ADDRESSES
08579  E1F0  20 03 E2           JSR     XXE203          ; EXIT FUNCTION IF
 [EOT] OR ':'
08580  E1F3  20 FD E1           JSR     XXE1FD          ; SCAN AND GET BYT
E, ELSE DO SYNTAX ERROR THEN WARM START
08581  E1F6  8A                 TXA                    ; COPY COMMAND TO A

08582  E1F7  A8                 TAY                    ; COPY COMMAND TO Y

08583  E1F8  A6 49              LDX     XX49          ; GET DEVICE NUMBER 
BACK
08584  E1FA  4C BA FF           JMP     XXFFBA          ; SET LOGICAL, FIR
ST AND SECOND ADDRESSES AND RETURN
08585  E1FD                     
08586  E1FD                     
08587  E1FD              ;************************************************
***********************************;
08588  E1FD              ;
08589  E1FD              ; SCAN AND GET BYTE, ELSE DO SYNTAX ERROR THEN WA
RM START
08590  E1FD              
08591  E1FD              XXE1FD = *
08592  E1FD  20 0B E2           JSR     XXE20B          ; SCAN FOR ',BYTE'
, ELSE DO SYNTAX ERROR THEN WARM START
08593  E200  4C 9E D7           JMP     XXD79E          ; GET BYTE PARAMET
ER AND RETURN
08594  E203                     
08595  E203                     
08596  E203              ;************************************************
***********************************;
08597  E203              ;
08598  E203              ; EXIT FUNCTION IF [EOT] OR ':'
08599  E203              
08600  E203              XXE203 = *
08601  E203  20 79 00           JSR     XX0079          ; SCAN MEMORY
08602  E206  D0 02              BNE     XXE20A          ; BRANCH IF NOT [E
OL] OR ':'
08603  E208                     
08604  E208  68                 PLA                    ; DUMP RETURN ADDRE
SS LOW BYTE
08605  E209  68                 PLA                    ; DUMP RETURN ADDRE
SS HIGH BYTE
08606  E20A              XXE20A = *
08607  E20A  60                 RTS
08608  E20B                     
08609  E20B                     
08610  E20B              ;************************************************
***********************************;
08611  E20B              ;
08612  E20B              ; SCAN FOR ',VALID BYTE', ELSE DO SYNTAX ERROR TH
EN WARM START
08613  E20B              
08614  E20B              XXE20B = *
08615  E20B  20 FD CE           JSR     XXCEFD          ; SCAN FOR ',', EL
SE DO SYNTAX ERROR THEN WARM START






T***;T......PAGE 0163

LINE# LOC   CODE        LINE


08616  E20E                     
08617  E20E              ; SCAN FOR VALID BYTE, NOT [EOL] OR ':', ELSE DO 
SYNTAX ERROR THEN WARM START
08618  E20E              
08619  E20E              XXE20E = *
08620  E20E  20 79 00           JSR     XX0079          ; SCAN MEMORY
08621  E211  D0 F7              BNE     XXE20A          ; EXIT IF FOLLOWIN
G BYTE
08622  E213                     
08623  E213  4C 08 CF           JMP     XXCF08          ; ELSE DO SYNTAX E
RROR THEN WARM START
08624  E216                     
08625  E216                     
08626  E216              ;************************************************
***********************************;
08627  E216              ;
08628  E216              ; GET PARAMETERS FOR OPEN/CLOSE
08629  E216              
08630  E216              XXE216 = *
08631  E216  A9 00              LDA     #$00               ; CLEAR FILE NA
ME LENGTH
08632  E218  20 BD FF           JSR     XXFFBD          ; CLEAR FILENAME
08633  E21B  20 0E E2           JSR     XXE20E          ; SCAN FOR VALID B
YTE, ELSE DO SYNTAX ERROR THEN WARM START
08634  E21E  20 9E D7           JSR     XXD79E          ; GET BYTE PARAMET
ER, LOGICAL FILE NUMBER
08635  E221  86 49              STX     XX49          ; SAVE LOGICAL FILE 
NUMBER
08636  E223  8A                 TXA                    ; COPY LOGICAL FILE
 NUMBER TO A
08637  E224  A2 01              LDX     #$01               ; SET DEFAULT D
EVICE NUMBER, CASSETTE
08638  E226  A0 00              LDY     #$00               ; SET DEFAULT C
OMMAND
08639  E228  20 BA FF           JSR     XXFFBA          ; SET LOGICAL, FIR
ST AND SECOND ADDRESSES
08640  E22B  20 03 E2           JSR     XXE203          ; EXIT FUNCTION IF
 [EOT] OR ':'
08641  E22E  20 FD E1           JSR     XXE1FD          ; SCAN AND GET BYT
E, ELSE DO SYNTAX ERROR THEN WARM START
08642  E231  86 4A              STX     XX4A          ; SAVE DEVICE NUMBER

08643  E233  A0 00              LDY     #$00               ; CLEAR COMMAND

08644  E235  A5 49              LDA     XX49          ; GET LOGICAL FILE N
UMBER
08645  E237  E0 03              CPX     #$03               ; COMPARE DEVIC
E NUMBER WITH SCREEN
08646  E239  90 01              BCC     XXE23C          ; BRANCH IF LESS T
HAN SCREEN
08647  E23B                     
08648  E23B  88                 DEY                    ; ELSE DECREMENT CO
MMAND
08649  E23C              XXE23C = *
08650  E23C  20 BA FF           JSR     XXFFBA          ; SET LOGICAL, FIR
ST AND SECOND ADDRESSES
08651  E23F  20 03 E2           JSR     XXE203          ; EXIT FUNCTION IF
 [EOT] OR ':'
08652  E242  20 FD E1           JSR     XXE1FD          ; SCAN AND GET BYT
E, ELSE DO SYNTAX ERROR THEN WARM START
08653  E245  8A                 TXA                    ; COPY COMMAND TO A

08654  E246  A8                 TAY                    ; COPY COMMAND TO Y

08655  E247  A6 4A              LDX     XX4A          ; GET DEVICE NUMBER
08656  E249  A5 49              LDA     XX49          ; GET LOGICAL FILE N
UMBER
08657  E24B  20 BA FF           JSR     XXFFBA          ; SET LOGICAL, FIR
ST AND SECOND ADDRESSES
08658  E24E  20 03 E2           JSR     XXE203          ; EXIT FUNCTION IF
 [EOT] OR ':'
08659  E251  20 0B E2           JSR     XXE20B          ; SCAN FOR ',BYTE'
, ELSE DO SYNTAX ERROR THEN WARM START
08660  E254                     
08661  E254                     
08662  E254              ;************************************************
***********************************;
08663  E254              ;
08664  E254              ; SET FILENAME
08665  E254              
08666  E254              XXE254 = *
08667  E254  20 9E CD           JSR     XXCD9E          ; EVALUATE EXPRESS
ION
08668  E257  20 A3 D6           JSR     XXD6A3          ; EVALUATE STRING
08669  E25A  A6 22              LDX     XX22          ; GET STRING POINTER
 LOW BYTE
08670  E25C  A4 23              LDY     XX23          ; GET STRING POINTER
 HIGH BYTE






****;T......PAGE 0164

LINE# LOC   CODE        LINE


08671  E25E  4C BD FF           JMP     XXFFBD          ; SET FILENAME AND
 RETURN
08672  E261                     
08673  E261                     
08674  E261              ;************************************************
***********************************;
08675  E261              ;
08676  E261              ; PERFORM COS()
08677  E261              
08678  E261              XXE261 = *
08679  E261  A9 DD              LDA     #<XXE2DD          ; SET PI/2 POINT
ER LOW BYTE
08680  E263  A0 E2              LDY     #>XXE2DD          ; SET PI/2 POINT
ER HIGH BYTE
08681  E265  20 67 D8           JSR     XXD867          ; ADD (AY) TO FAC1

08682  E268                     
08683  E268                     
08684  E268              ;************************************************
***********************************;
08685  E268              ;
08686  E268              ; PERFORM SIN()
08687  E268              
08688  E268              XXE268 = *
08689  E268  20 0C DC           JSR     XXDC0C          ; ROUND AND COPY F
AC1 TO FAC2
08690  E26B  A9 E2              LDA     #<XXE2E2          ; SET 2*PI POINT
ER LOW BYTE
08691  E26D  A0 E2              LDY     #>XXE2E2          ; SET 2*PI POINT
ER HIGH BYTE
08692  E26F  A6 6E              LDX     XX6E          ; GET FAC2 SIGN (B7)

08693  E271  20 07 DB           JSR     XXDB07          ; DIVIDE BY (AY) (
X=SIGN)
08694  E274  20 0C DC           JSR     XXDC0C          ; ROUND AND COPY F
AC1 TO FAC2
08695  E277  20 CC DC           JSR     XXDCCC          ; PERFORM INT()
08696  E27A  A9 00              LDA     #$00               ; CLEAR BYTE
08697  E27C  85 6F              STA     XX6F          ; CLEAR SIGN COMPARE
 (FAC1 EOR FAC2)
08698  E27E  20 53 D8           JSR     XXD853          ; PERFORM SUBTRACT
ION, FAC2 FROM FAC1
08699  E281  A9 E7              LDA     #<XXE2E7          ; SET 0.25 POINT
ER LOW BYTE
08700  E283  A0 E2              LDY     #>XXE2E7          ; SET 0.25 POINT
ER HIGH BYTE
08701  E285  20 50 D8           JSR     XXD850          ; PERFORM SUBTRACT
ION, FAC1 FROM (AY)
08702  E288  A5 66              LDA     XX66          ; GET FAC1 SIGN (B7)

08703  E28A  48                 PHA                    ; SAVE FAC1 SIGN
08704  E28B  10 0D              BPL     XXE29A          ; BRANCH IF +VE
08705  E28D                     
08706  E28D                                     ; FAC1 SIGN WAS -VE
08707  E28D  20 49 D8           JSR     XXD849          ; ADD 0.5 TO FAC1 
(ROUND FAC1)
08708  E290  A5 66              LDA     XX66          ; GET FAC1 SIGN (B7)

08709  E292  30 09              BMI     XXE29D          ; BRANCH IF -VE
08710  E294                     
08711  E294  A5 12              LDA     XX12          ; GET THE COMPARISON
 EVALUATION FLAG
08712  E296  49 FF              EOR     #$FF               ; TOGGLE FLAG
08713  E298  85 12              STA     XX12          ; SAVE THE COMPARISO
N EVALUATION FLAG
08714  E29A              XXE29A = *
08715  E29A  20 B4 DF           JSR     XXDFB4          ; DO - FAC1
08716  E29D              XXE29D = *
08717  E29D  A9 E7              LDA     #<XXE2E7          ; SET 0.25 POINT
ER LOW BYTE
08718  E29F  A0 E2              LDY     #>XXE2E7          ; SET 0.25 POINT
ER HIGH BYTE
08719  E2A1  20 67 D8           JSR     XXD867          ; ADD (AY) TO FAC1

08720  E2A4  68                 PLA                    ; RESTORE FAC1 SIGN

08721  E2A5  10 03              BPL     XXE2AA          ; BRANCH IF WAS +V
E
08722  E2A7                     
08723  E2A7                                     ; ELSE CORRECT FAC1
08724  E2A7  20 B4 DF           JSR     XXDFB4          ; DO - FAC1
08725  E2AA              XXE2AA = *






****;T......PAGE 0165

LINE# LOC   CODE        LINE


08726  E2AA  A9 EC              LDA     #<XXE2EC          ; SET POINTER LO
W BYTE TO COUNTER
08727  E2AC  A0 E2              LDY     #>XXE2EC          ; SET POINTER HI
GH BYTE TO COUNTER
08728  E2AE  4C 40 E0           JMP     XXE040          ; ^2 THEN SERIES E
VALUATION AND RETURN
08729  E2B1                     
08730  E2B1                     
08731  E2B1              ;************************************************
***********************************;
08732  E2B1              ;
08733  E2B1              ; PERFORM TAN()
08734  E2B1              
08735  E2B1              XXE2B1 = *
08736  E2B1  20 CA DB           JSR     XXDBCA          ; PACK FAC1 INTO X
X57
08737  E2B4  A9 00              LDA     #$00               ; CLEAR A
08738  E2B6  85 12              STA     XX12          ; CLEAR THE COMPARIS
ON EVALUATION FLAG
08739  E2B8  20 68 E2           JSR     XXE268          ; PERFORM SIN()
08740  E2BB  A2 4E              LDX     #<XX4E          ; SET SIN(N) POINT
ER LOW BYTE
08741  E2BD  A0 00              LDY     #>XX4E          ; SET SIN(N) POINT
ER HIGH BYTE
08742  E2BF  20 F3 E0           JSR     XXE0F3          ; PACK FAC1 INTO (
XY)
08743  E2C2  A9 57              LDA     #<XX57          ; SET N POINTER LO
W BYTE
08744  E2C4  A0 00              LDY     #>XX57          ; SET N POINTER HI
GH BYTE
08745  E2C6  20 A2 DB           JSR     XXDBA2          ; UNPACK MEMORY (A
Y) INTO FAC1
08746  E2C9  A9 00              LDA     #$00               ; CLEAR BYTE
08747  E2CB  85 66              STA     XX66          ; CLEAR FAC1 SIGN (B
7)
08748  E2CD  A5 12              LDA     XX12          ; GET THE COMPARISON
 EVALUATION FLAG
08749  E2CF  20 D9 E2           JSR     XXE2D9          ; SAVE FLAG AND GO
 DO SERIES EVALUATION
08750  E2D2  A9 4E              LDA     #<XX4E          ; SET SIN(N) POINT
ER LOW BYTE
08751  E2D4  A0 00              LDY     #>XX4E          ; SET SIN(N) POINT
ER HIGH BYTE
08752  E2D6  4C 0F DB           JMP     XXDB0F          ; CONVERT AY AND D
O (AY)/FAC1
08753  E2D9                     
08754  E2D9                     
08755  E2D9              ;************************************************
***********************************;
08756  E2D9              ;
08757  E2D9              ; SAVE COMPARISON FLAG AND DO SERIES EVALUATION
08758  E2D9              
08759  E2D9              XXE2D9 = *
08760  E2D9  48                 PHA                    ; SAVE COMPARISON F
LAG
08761  E2DA  4C 9A E2           JMP     XXE29A          ; ADD 0.25, ^2 THE
N SERIES EVALUATION
08762  E2DD                     
08763  E2DD                     
08764  E2DD              ;************************************************
***********************************;
08765  E2DD              ;
08766  E2DD              ; CONSTANTS AND SERIES FOR SIN/COS(N)
08767  E2DD              
08768  E2DD              XXE2DD = *
08769  E2DD  81                 .BYTE     $81,$49,$0F,$DA,$A2     ; 1.5707
96371, PI/2, AS FLOATING NUMBER
08769  E2DE  49 
08769  E2DF  0F 
08769  E2E0  DA 
08769  E2E1  A2 
08770  E2E2              XXE2E2 = *
08771  E2E2  83                 .BYTE     $83,$49,$0F,$DA,$A2     ; 6.2831
9, 2*PI, AS FLOATING NUMBER
08771  E2E3  49 
08771  E2E4  0F 
08771  E2E5  DA 
08771  E2E6  A2 
08772  E2E7              XXE2E7 = *






****;T......PAGE 0166

LINE# LOC   CODE        LINE


08773  E2E7  7F                 .BYTE     $7F,$00,$00,$00,$00     ; 0.25
08773  E2E8  00 
08773  E2E9  00 
08773  E2EA  00 
08773  E2EB  00 
08774  E2EC                     
08775  E2EC              XXE2EC = *
08776  E2EC  05                 .BYTE     $05                    ; SERIES 
COUNTER
08777  E2ED  84                 .BYTE     $84,$E6,$1A,$2D,$1B     ; -14.38
13907
08777  E2EE  E6 
08777  E2EF  1A 
08777  E2F0  2D 
08777  E2F1  1B 
08778  E2F2  86                 .BYTE     $86,$28,$07,$FB,$F8     ;  42.00
77971
08778  E2F3  28 
08778  E2F4  07 
08778  E2F5  FB 
08778  E2F6  F8 
08779  E2F7  87                 .BYTE     $87,$99,$68,$89,$01     ; -76.70
41703
08779  E2F8  99 
08779  E2F9  68 
08779  E2FA  89 
08779  E2FB  01 
08780  E2FC  87                 .BYTE     $87,$23,$35,$DF,$E1     ;  81.60
52237
08780  E2FD  23 
08780  E2FE  35 
08780  E2FF  DF 
08780  E300  E1 
08781  E301  86                 .BYTE     $86,$A5,$5D,$E7,$28     ; -41.34
17021
08781  E302  A5 
08781  E303  5D 
08781  E304  E7 
08781  E305  28 
08782  E306  83                 .BYTE     $83,$49,$0F,$DA,$A2     ;  6.283
18531
08782  E307  49 
08782  E308  0F 
08782  E309  DA 
08782  E30A  A2 
08783  E30B                     
08784  E30B                     
08785  E30B              ;************************************************
***********************************;
08786  E30B              ;
08787  E30B              ; PERFORM ATN()
08788  E30B              
08789  E30B              XXE30B = *
08790  E30B  A5 66              LDA     XX66          ; GET FAC1 SIGN (B7)

08791  E30D  48                 PHA                    ; SAVE SIGN
08792  E30E  10 03              BPL     XXE313          ; BRANCH IF +VE
08793  E310                     
08794  E310  20 B4 DF           JSR     XXDFB4          ; ELSE DO - FAC1
08795  E313              XXE313 = *
08796  E313  A5 61              LDA     XX61          ; GET FAC1 EXPONENT
08797  E315  48                 PHA                    ; PUSH EXPONENT
08798  E316  C9 81              CMP     #$81               ; COMPARE WITH 
1
08799  E318  90 07              BCC     XXE321          ; BRANCH IF FAC1 <
 1






****;T......PAGE 0167

LINE# LOC   CODE        LINE


08800  E31A                     
08801  E31A  A9 BC              LDA     #<XXD9BC          ; POINTER TO 1 L
OW BYTE
08802  E31C  A0 D9              LDY     #>XXD9BC          ; POINTER TO 1 H
IGH BYTE
08803  E31E  20 0F DB           JSR     XXDB0F          ; CONVERT AY AND D
O (AY)/FAC1
08804  E321              XXE321 = *
08805  E321  A9 3B              LDA     #<XXE33B          ; POINTER TO SER
IES LOW BYTE
08806  E323  A0 E3              LDY     #>XXE33B          ; POINTER TO SER
IES HIGH BYTE
08807  E325  20 40 E0           JSR     XXE040          ; ^2 THEN SERIES E
VALUATION
08808  E328  68                 PLA                    ; RESTORE OLD FAC1 
EXPONENT
08809  E329  C9 81              CMP     #$81               ; COMPARE WITH 
1
08810  E32B  90 07              BCC     XXE334          ; BRANCH IF FAC1 <
 1
08811  E32D                     
08812  E32D  A9 DD              LDA     #<XXE2DD          ; POINTER TO (PI
/2) LOW BYTE
08813  E32F  A0 E2              LDY     #>XXE2DD          ; POINTER TO (PI
/2) LOW BYTE
08814  E331  20 50 D8           JSR     XXD850          ; PERFORM SUBTRACT
ION, FAC1 FROM (AY)
08815  E334              XXE334 = *
08816  E334  68                 PLA                    ; RESTORE FAC1 SIGN

08817  E335  10 03              BPL     XXE33A          ; EXIT IF WAS +VE
08818  E337                     
08819  E337  4C B4 DF           JMP     XXDFB4          ; ELSE DO - FAC1 A
ND RETURN
08820  E33A                     
08821  E33A              XXE33A = *
08822  E33A  60                 RTS
08823  E33B                     
08824  E33B                     
08825  E33B              ;************************************************
***********************************;
08826  E33B              ;
08827  E33B              ; SERIES FOR ATN(N)
08828  E33B              
08829  E33B              XXE33B = *
08830  E33B  0B                 .BYTE     $0B                    ; SERIES 
COUNTER
08831  E33C  76                 .BYTE     $76,$B3,$83,$BD,$D3     ;-6.8479
3912E-04
08831  E33D  B3 
08831  E33E  83 
08831  E33F  BD 
08831  E340  D3 
08832  E341  79                 .BYTE     $79,$1E,$F4,$A6,$F5     ; 4.8509
4216E-03
08832  E342  1E 
08832  E343  F4 
08832  E344  A6 
08832  E345  F5 
08833  E346  7B                 .BYTE     $7B,$83,$FC,$B0,$10     ;-0.0161
117015
08833  E347  83 
08833  E348  FC 
08833  E349  B0 
08833  E34A  10 
08834  E34B  7C                 .BYTE     $7C,$0C,$1F,$67,$CA     ; 0.0342
09638
08834  E34C  0C 
08834  E34D  1F 
08834  E34E  67 
08834  E34F  CA 
08835  E350  7C                 .BYTE     $7C,$DE,$53,$CB,$C1     ;-0.0542
79133
08835  E351  DE 
08835  E352  53 
08835  E353  CB 






****;T......PAGE 0168

LINE# LOC   CODE        LINE


08835  E354  C1 
08836  E355  7D                 .BYTE     $7D,$14,$64,$70,$4C     ; 0.0724
571965
08836  E356  14 
08836  E357  64 
08836  E358  70 
08836  E359  4C 
08837  E35A  7D                 .BYTE     $7D,$B7,$EA,$51,$7A     ;-0.0898
019185
08837  E35B  B7 
08837  E35C  EA 
08837  E35D  51 
08837  E35E  7A 
08838  E35F  7D                 .BYTE     $7D,$63,$30,$88,$7E     ; 0.1109
32413
08838  E360  63 
08838  E361  30 
08838  E362  88 
08838  E363  7E 
08839  E364  7E                 .BYTE     $7E,$92,$44,$99,$3A     ;-0.1428
39808
08839  E365  92 
08839  E366  44 
08839  E367  99 
08839  E368  3A 
08840  E369  7E                 .BYTE     $7E,$4C,$CC,$91,$C7     ; 0.1999
9912
08840  E36A  4C 
08840  E36B  CC 
08840  E36C  91 
08840  E36D  C7 
08841  E36E  7F                 .BYTE     $7F,$AA,$AA,$AA,$13     ;-0.3333
33316
08841  E36F  AA 
08841  E370  AA 
08841  E371  AA 
08841  E372  13 
08842  E373  81                 .BYTE     $81,$00,$00,$00,$00     ; 1.0000
00000
08842  E374  00 
08842  E375  00 
08842  E376  00 
08842  E377  00 
08843  E378                     
08844  E378                     
08845  E378              ;************************************************
***********************************;
08846  E378              ;
08847  E378              ; BASIC COLD START ENTRY POINT
08848  E378              
08849  E378              XXE378 = *
08850  E378  20 5B E4           JSR     XXE45B          ; INITIALISE BASIC
 VECTOR TABLE
08851  E37B  20 A4 E3           JSR     XXE3A4          ; INITIALISE BASIC
 RAM LOCATIONS
08852  E37E  20 04 E4           JSR     XXE404          ; PRINT START UP M
ESSAGE AND INITIALISE MEMORY POINTERS
08853  E381  A2 FB              LDX     #$FB               ; VALUE FOR STA
RT STACK
08854  E383  9A                 TXS                    ; SET STACK POINTER

08855  E384  4C 74 C4           JMP     XXC474          ; DO 'READY.' WARM
 START
08856  E387                     
08857  E387                     
08858  E387              ;************************************************
***********************************;
08859  E387              ;
08860  E387              ; CHARACTER GET SUBROUTINE FOR ZERO PAGE
08861  E387              






HE**;T......PAGE 0169

LINE# LOC   CODE        LINE


08862  E387              ; THE TARGET ADDRESS FOR THE LDA XXEA60 BECOMES T
HE BASIC EXECUTE POINTER ONCE THE
08863  E387              ; BLOCK IS COPIED TO IT'S DESTINATION, ANY NON ZE
RO PAGE ADDRESS WILL DO AT ASSEMBLY
08864  E387              ; TIME, TO ASSEMBLE A THREE BYTE INSTRUCTION.
08865  E387              
08866  E387              ; PAGE 0 INITIALISATION TABLE FROM XX0073
08867  E387              ; INCREMENT AND SCAN MEMORY
08868  E387              
08869  E387              XXE387 = *
08870  E387  E6 7A              INC     XX7A          ; INCREMENT BASIC EX
ECUTE POINTER LOW BYTE
08871  E389  D0 02              BNE     XXE38D          ; BRANCH IF NO CAR
RY
08872  E38B                                     ; ELSE
08873  E38B  E6 7B              INC     XX7B          ; INCREMENT BASIC EX
ECUTE POINTER HIGH BYTE
08874  E38D                     
08875  E38D              ; PAGE 0 INITIALISATION TABLE FROM XX0079
08876  E38D              ; SCAN MEMORY
08877  E38D              
08878  E38D              XXE38D = *
08879  E38D  AD 60 EA           LDA     XXEA60          ; GET BYTE TO SCAN
, ADDRESS SET BY CALL ROUTINE
08880  E390  C9 3A              CMP     #':'               ; COMPARE WITH 
':'
08881  E392  B0 0A              BCS     XXE39E          ; EXIT IF>=
08882  E394                     
08883  E394              ; PAGE 0 INITIALISATION TABLE FROM XX0080
08884  E394              ; CLEAR CB IF NUMERIC
08885  E394              
08886  E394  C9 20              CMP     #' '               ; COMPARE WITH 
' '
08887  E396  F0 EF              BEQ     XXE387          ; IF ' ' GO DO NEX
T
08888  E398                     
08889  E398  38                 SEC                    ; SET CARRY FOR SBC

08890  E399  E9 30              SBC     #'0'               ; SUBTRACT '0'
08891  E39B  38                 SEC                    ; SET CARRY FOR SBC

08892  E39C  E9 D0              SBC     #$D0               ; SUBTRACT -'0'

08893  E39E                                     ; CLEAR CARRY IF BYTE = '0
'-'9'
08894  E39E              XXE39E = *
08895  E39E  60                 RTS
08896  E39F                     
08897  E39F                     
08898  E39F              ;************************************************
***********************************;
08899  E39F              ;
08900  E39F              ; SPARE BYTES, NOT REFERENCED
08901  E39F              
08902  E39F              ;XXE39F
08903  E39F  80                 .BYTE     $80,$4F,$C7,$52,$58
08903  E3A0  4F 
08903  E3A1  C7 
08903  E3A2  52 
08903  E3A3  58 
08904  E3A4                                     ; 0.811635157
08905  E3A4                     
08906  E3A4                     
08907  E3A4              ;************************************************
***********************************;
08908  E3A4              ;
08909  E3A4              ; INITIALISE BASIC RAM LOCATIONS
08910  E3A4              
08911  E3A4              XXE3A4 = *
08912  E3A4  A9 4C              LDA     #$4C               ; OPCODE FOR JM
P






****;T......PAGE 0170

LINE# LOC   CODE        LINE


08913  E3A6  85 54              STA     XX54          ; SAVE FOR FUNCTIONS
 VECTOR JUMP
08914  E3A8  85 00              STA     XX00          ; SAVE FOR USR() VEC
TOR JUMP
08915  E3AA                                     ; SET USR() VECTOR TO ILLE
GAL QUANTITY ERROR
08916  E3AA  A9 48              LDA     #<XXD248          ; SET USR() VECT
OR LOW BYTE
08917  E3AC  A0 D2              LDY     #>XXD248          ; SET USR() VECT
OR HIGH BYTE
08918  E3AE  85 01              STA     XX01          ; SAVE USR() VECTOR 
LOW BYTE
08919  E3B0  84 02              STY     XX02          ; SAVE USR() VECTOR 
HIGH BYTE
08920  E3B2  A9 91              LDA     #<XXD391          ; SET FIXED TO F
LOAT VECTOR LOW BYTE
08921  E3B4  A0 D3              LDY     #>XXD391          ; SET FIXED TO F
LOAT VECTOR HIGH BYTE
08922  E3B6  85 05              STA     XX05          ; SAVE FIXED TO FLOA
T VECTOR LOW BYTE
08923  E3B8  84 06              STY     XX06          ; SAVE FIXED TO FLOA
T VECTOR HIGH BYTE
08924  E3BA  A9 AA              LDA     #<XXD1AA          ; SET FLOAT TO F
IXED VECTOR LOW BYTE
08925  E3BC  A0 D1              LDY     #>XXD1AA          ; SET FLOAT TO F
IXED VECTOR HIGH BYTE
08926  E3BE  85 03              STA     XX03          ; SAVE FLOAT TO FIXE
D VECTOR LOW BYTE
08927  E3C0  84 04              STY     XX04          ; SAVE FLOAT TO FIXE
D VECTOR HIGH BYTE
08928  E3C2                     
08929  E3C2              ; COPY BLOCK FROM XXE387 TO XX0074
08930  E3C2              
08931  E3C2  A2 1C              LDX     #$1C               ; SET BYTE COUN
T
08932  E3C4              XXE3C4 = *
08933  E3C4  BD 87 E3           LDA     XXE387,X          ; GET BYTE FROM 
TABLE
08934  E3C7  95 73              STA     XX0073,X          ; SAVE BYTE IN P
AGE ZERO
08935  E3C9  CA                 DEX                    ; DECREMENT COUNT
08936  E3CA  10 F8              BPL     XXE3C4          ; LOOP IF NOT ALL 
DONE
08937  E3CC                     
08938  E3CC  A9 03              LDA     #$03               ; SET STEP SIZE
, COLLECTING DESCRIPTORS
08939  E3CE  85 53              STA     XX53          ; SAVE GARBAGE COLLE
CTION STEP SIZE
08940  E3D0  A9 00              LDA     #$00               ; CLEAR A
08941  E3D2  85 68              STA     XX68          ; CLEAR FAC1 OVERFLO
W BYTE
08942  E3D4  85 13              STA     XX13          ; CLEAR CURRENT I/O 
CHANNEL, FLAG DEFAULT
08943  E3D6  85 18              STA     XX18          ; CLEAR CURRENT DESC
RIPTOR STACK ITEM POINTER HIGH BYTE
08944  E3D8  A2 01              LDX     #$01               ; SET X
08945  E3DA  8E FD 01           STX     XX01FD          ; SET CHAIN LINK P
OINTER LOW BYTE
08946  E3DD  8E FC 01           STX     XX01FC          ; SET CHAIN LINK P
OINTER HIGH BYTE
08947  E3E0  A2 19              LDX     #XX19          ; INITIAL VALUE FOR
 DESCRIPTOR STACK
08948  E3E2  86 16              STX     XX16          ; SET DESCRIPTOR STA
CK POINTER
08949  E3E4  38                 SEC                    ; SET CB = 1 TO REA
D THE BOTTOM OF MEMORY
08950  E3E5  20 9C FF           JSR     XXFF9C          ; READ/SET THE BOT
TOM OF MEMORY
08951  E3E8  86 2B              STX     XX2B          ; SAVE START OF MEMO
RY LOW BYTE
08952  E3EA  84 2C              STY     XX2C          ; SAVE START OF MEMO
RY HIGH BYTE
08953  E3EC  38                 SEC                    ; SET CB = 1 TO REA
D THE TOP OF MEMORY
08954  E3ED  20 99 FF           JSR     XXFF99          ; READ/SET THE TOP
 OF MEMORY
08955  E3F0  86 37              STX     XX37          ; SAVE END OF MEMORY
 LOW BYTE
08956  E3F2  84 38              STY     XX38          ; SAVE END OF MEMORY
 HIGH BYTE
08957  E3F4  86 33              STX     XX33          ; SET BOTTOM OF STRI
NG SPACE LOW BYTE
08958  E3F6  84 34              STY     XX34          ; SET BOTTOM OF STRI
NG SPACE HIGH BYTE
08959  E3F8  A0 00              LDY     #$00               ; CLEAR INDEX
08960  E3FA  98                 TYA                    ; CLEAR A
08961  E3FB  91 2B              STA     (XX2B),Y          ; CLEAR FIRST BY
TE OF MEMORY
08962  E3FD  E6 2B              INC     XX2B          ; INCREMENT START OF
 MEMORY LOW BYTE
08963  E3FF  D0 02              BNE     XXE403          ; BRANCH IF NO ROL
LOVER
08964  E401                     
08965  E401  E6 2C              INC     XX2C          ; INCREMENT START OF
 MEMORY HIGH BYTE
08966  E403              XXE403 = *
08967  E403  60                 RTS






TE**;T......PAGE 0171

LINE# LOC   CODE        LINE


08968  E404                     
08969  E404                     
08970  E404              ;************************************************
***********************************;
08971  E404              ;
08972  E404              ; PRINT START UP MESSAGE AND INITIALISE MEMORY PO
INTERS
08973  E404              
08974  E404              XXE404 = *
08975  E404  A5 2B              LDA     XX2B          ; GET START OF MEMOR
Y LOW BYTE
08976  E406  A4 2C              LDY     XX2C          ; GET START OF MEMOR
Y HIGH BYTE
08977  E408  20 08 C4           JSR     XXC408          ; CHECK AVAILABLE 
MEMORY, DO OUT OF MEMORY ERROR IF NO ROOM
08978  E40B  A9 36              LDA     #<XXE436          ; SET '**** CBM 
BASIC V2 ****' POINTER LOW BYTE
08979  E40D  A0 E4              LDY     #>XXE436          ; SET '**** CBM 
BASIC V2 ****' POINTER HIGH BYTE
08980  E40F  20 1E CB           JSR     XXCB1E          ; PRINT NULL TERMI
NATED STRING
08981  E412  A5 37              LDA     XX37          ; GET END OF MEMORY 
LOW BYTE
08982  E414  38                 SEC                    ; SET CARRY FOR SUB
TRACT
08983  E415  E5 2B              SBC     XX2B          ; SUBTRACT START OF 
MEMORY LOW BYTE
08984  E417  AA                 TAX                    ; COPY RESULT TO X
08985  E418  A5 38              LDA     XX38          ; GET END OF MEMORY 
HIGH BYTE
08986  E41A  E5 2C              SBC     XX2C          ; SUBTRACT START OF 
MEMORY HIGH BYTE
08987  E41C  20 CD DD           JSR     XXDDCD          ; PRINT XA AS UNSI
GNED INTEGER
08988  E41F  A9 29              LDA     #<XXE429          ; SET ' BYTES FR
EE' POINTER LOW BYTE
08989  E421  A0 E4              LDY     #>XXE429          ; SET ' BYTES FR
EE' POINTER HIGH BYTE
08990  E423  20 1E CB           JSR     XXCB1E          ; PRINT NULL TERMI
NATED STRING
08991  E426  4C 44 C6           JMP     XXC644          ; DO NEW, CLEAR, R
ESTORE AND RETURN
08992  E429                     
08993  E429                     
08994  E429              ;************************************************
***********************************;
08995  E429              ;
08996  E429              XXE429 = *
08997  E429  20 42              .BYTE     ' BYTES FREE',$0D,$00
08997  E434  0D 
08997  E435  00 
08998  E436              XXE436 = *
08999  E436  93                 .BYTE     $93,'**** CBM BASIC V2 ****',$0D
,$00
08999  E437  2A 2A 
08999  E44D  0D 
08999  E44E  00 
09000  E44F                     
09001  E44F                     
09002  E44F              ;************************************************
***********************************;
09003  E44F              ;
09004  E44F              ; BASIC VECTORS, THESE ARE COPIED TO RAM FROM XX0
300 ONWARDS
09005  E44F              
09006  E44F              XXE44F = *
09007  E44F  3A C4              .WORD     XXC43A          ; ERROR MESSAGE 
                   XX0300
09008  E451  83 C4              .WORD     XXC483          ; BASIC WARM STA
RT               XX0302
09009  E453  7C C5              .WORD     XXC57C          ; CRUNCH BASIC T
OKENS               XX0304
09010  E455  1A C7              .WORD     XXC71A          ; UNCRUNCH BASIC
 TOKENS               XX0306
09011  E457  E4 C7              .WORD     XXC7E4          ; START NEW BASI
C CODE               XX0308
09012  E459  86 CE              .WORD     XXCE86          ; GET ARITHMETIC
 ELEMENT          XX030A
09013  E45B                     
09014  E45B                     
09015  E45B              ;************************************************
***********************************;
09016  E45B              ;
09017  E45B              ; INITIALISE BASIC VECTORS






****;O......PAGE 0172

LINE# LOC   CODE        LINE


09018  E45B              
09019  E45B              XXE45B = *
09020  E45B  A2 0B              LDX     #$0B               ; SET BYTE COUN
T
09021  E45D              XXE45D = *
09022  E45D  BD 4F E4           LDA     XXE44F,X          ; GET BYTE FROM 
TABLE
09023  E460  9D 00 03           STA     XX0300,X          ; SAVE BYTE TO R
AM
09024  E463  CA                 DEX                    ; DECREMENT INDEX
09025  E464  10 F7              BPL     XXE45D          ; LOOP IF MORE TO 
DO
09026  E466                     
09027  E466  60                 RTS
09028  E467                     
09029  E467                     
09030  E467              ;************************************************
***********************************;
09031  E467              ;
09032  E467              ; BASIC WARM START ENTRY POINT
09033  E467              
09034  E467              XXE467 = *
09035  E467  20 CC FF           JSR     XXFFCC          ; CLOSE INPUT AND 
OUTPUT CHANNELS
09036  E46A  A9 00              LDA     #$00               ; CLEAR A
09037  E46C  85 13              STA     XX13          ; SET CURRENT I/O CH
ANNEL, FLAG DEFAULT
09038  E46E  20 7A C6           JSR     XXC67A          ; FLUSH BASIC STAC
K AND CLEAR CONTINUE POINTER
09039  E471  58                 CLI                    ; ENABLE INTERRUPTS

09040  E472  4C 74 C4           JMP     XXC474          ; DO WARM START
09041  E475                     
09042  E475                     
09043  E475              ;************************************************
***********************************;
09044  E475              ;
09045  E475              ; CHECKSUM BYTE, NOT REFERENCED
09046  E475              
09047  E475              ;XXE475
09048  E475  E8                 .BYTE     $E8               ; [PAL]
09049  E476              ;     .BYTE     $41               ; [NTSC]
09050  E476              
09051  E476              
09052  E476              ;************************************************
***********************************;
09053  E476              ;
09054  E476              ; REBUILD BASIC LINE CHAINING AND DO RESTORE
09055  E476              
09056  E476              XXE476 = *
09057  E476  20 33 C5           JSR     XXC533          ; REBUILD BASIC LI
NE CHAINING
09058  E479  4C 77 C6           JMP     XXC677          ; DO RESTORE, CLEA
R STACK AND RETURN
09059  E47C                     
09060  E47C                     
09061  E47C              ;************************************************
***********************************;
09062  E47C              ;
09063  E47C              ; SPARE BYTES, NOT REFERENCED
09064  E47C              
09065  E47C              ;XXE47C
09066  E47C  FF                 .BYTE     $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,
$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
09066  E47D  FF 
09066  E47E  FF 
09066  E47F  FF 
09066  E480  FF 
09066  E481  FF 
09066  E482  FF 






****;O......PAGE 0173

LINE# LOC   CODE        LINE


09066  E483  FF 
09066  E484  FF 
09066  E485  FF 
09066  E486  FF 
09066  E487  FF 
09066  E488  FF 
09066  E489  FF 
09066  E48A  FF 
09066  E48B  FF 
09067  E48C  FF                 .BYTE     $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,
$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
09067  E48D  FF 
09067  E48E  FF 
09067  E48F  FF 
09067  E490  FF 
09067  E491  FF 
09067  E492  FF 
09067  E493  FF 
09067  E494  FF 
09067  E495  FF 
09067  E496  FF 
09067  E497  FF 
09067  E498  FF 
09067  E499  FF 
09067  E49A  FF 
09067  E49B  FF 
09068  E49C  FF                 .BYTE     $FF,$FF,$FF,$FF
09068  E49D  FF 
09068  E49E  FF 
09068  E49F  FF 
09069  E4A0                     
09070  E4A0                     
09071  E4A0              ;************************************************
***********************************;
09072  E4A0              ;
09073  E4A0              ; SET SERIAL DATA OUT HIGH
09074  E4A0              
09075  E4A0              XXE4A0 = *
09076  E4A0  AD 2C 91           LDA     XX912C          ; GET VIA 2 PCR
09077  E4A3  29 DF              AND     #$DF               ; SET CB2 LOW, 
SERIAL DATA OUT HIGH
09078  E4A5  8D 2C 91           STA     XX912C          ; SET VIA 2 PCR
09079  E4A8  60                 RTS
09080  E4A9                     
09081  E4A9                     
09082  E4A9              ;************************************************
***********************************;
09083  E4A9              ;
09084  E4A9              ; SET SERIAL DATA OUT LOW
09085  E4A9              
09086  E4A9              XXE4A9 = *
09087  E4A9  AD 2C 91           LDA     XX912C          ; GET VIA 2 PCR
09088  E4AC  09 20              ORA     #$20               ; SET CB2 HIGH,
 SERIAL DATA OUT LOW
09089  E4AE  8D 2C 91           STA     XX912C          ; SET VIA 2 PCR
09090  E4B1  60                 RTS
09091  E4B2                     
09092  E4B2                     
09093  E4B2              ;************************************************
***********************************;
09094  E4B2              ;






****;O......PAGE 0174

LINE# LOC   CODE        LINE


09095  E4B2              ; GET SERIAL CLOCK STATUS
09096  E4B2              
09097  E4B2              XXE4B2 = *
09098  E4B2  AD 1F 91           LDA     XX911F          ; GET VIA 1 DRA, N
O HANDSHAKE
09099  E4B5  CD 1F 91           CMP     XX911F          ; COMPARE WITH SEL
F
09100  E4B8  D0 F8              BNE     XXE4B2          ; LOOP IF CHANGING

09101  E4BA                     
09102  E4BA  4A                 LSR A                  ; SHIFT SERIAL CLOC
K TO CB
09103  E4BB  60                 RTS
09104  E4BC                     
09105  E4BC                     
09106  E4BC              ;************************************************
***********************************;
09107  E4BC              ;
09108  E4BC              ; GET SECONDAY ADDRESS AND PRINT 'SEARCHING...'
09109  E4BC              
09110  E4BC              XXE4BC = *
09111  E4BC  A6 B9              LDX     XXB9          ; GET SECONDARY ADDR
ESS
09112  E4BE  4C 47 F6           JMP     XXF647          ; PRINT 'SEARCHING
...' AND RETURN
09113  E4C1                     
09114  E4C1                     
09115  E4C1              ;************************************************
***********************************;
09116  E4C1              ;
09117  E4C1              ; SET LOAD ADDRESS IF SECONDARY ADDRESS = 0
09118  E4C1              
09119  E4C1              XXE4C1 = *
09120  E4C1  8A                 TXA                    ; COPY SECONDARY AD
DRESS
09121  E4C2  D0 08              BNE     XXE4CC          ; LOAD LOCATION NO
T SET IN LOAD CALL, SO
09122  E4C4                                     ; CONTINUE WITH LOAD
09123  E4C4  A5 C3              LDA     XXC3          ; GET LOAD ADDRESS L
OW BYTE
09124  E4C6  85 AE              STA     XXAE          ; SAVE PROGRAM START
 ADDRESS LOW BYTE
09125  E4C8  A5 C4              LDA     XXC4          ; GET LOAD ADDRESS H
IGH BYTE
09126  E4CA  85 AF              STA     XXAF          ; SAVE PROGRAM START
 ADDRESS HIGH BYTE
09127  E4CC              XXE4CC = *
09128  E4CC  4C 6A F6           JMP     XXF66A          ; DISPLAY 'LOADING
' OR 'VERIFYING' AND RETURN
09129  E4CF                     
09130  E4CF                     
09131  E4CF              ;************************************************
***********************************;
09132  E4CF              ;
09133  E4CF              ; PATCH FOR CLOSE
09134  E4CF              
09135  E4CF              XXE4CF = *
09136  E4CF  20 E3 F8           JSR     XXF8E3          ; INITIATE TAPE WR
ITE
09137  E4D2  90 03              BCC     XXE4D7          ; BRANCH IF NO ERR
OR
09138  E4D4                     
09139  E4D4  68                 PLA                    ; ELSE DUMP STACKED
 EXIT CODE
09140  E4D5  A9 00              LDA     #$00               ; CLEAR EXIT CO
DE
09141  E4D7              XXE4D7 = *
09142  E4D7  4C 9E F3           JMP     XXF39E          ; GO DO I/O CLOSE
09143  E4DA                     
09144  E4DA                     
09145  E4DA              ;************************************************
***********************************;
09146  E4DA              ;
09147  E4DA              ; SPARE BYTES, NOT REFERENCED
09148  E4DA              
09149  E4DA              ;XXE4DA






****;O......PAGE 0175

LINE# LOC   CODE        LINE


09150  E4DA  FF                 .BYTE     $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,
$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
09150  E4DB  FF 
09150  E4DC  FF 
09150  E4DD  FF 
09150  E4DE  FF 
09150  E4DF  FF 
09150  E4E0  FF 
09150  E4E1  FF 
09150  E4E2  FF 
09150  E4E3  FF 
09150  E4E4  FF 
09150  E4E5  FF 
09150  E4E6  FF 
09150  E4E7  FF 
09150  E4E8  FF 
09150  E4E9  FF 
09151  E4EA  FF                 .BYTE     $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,
$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
09151  E4EB  FF 
09151  E4EC  FF 
09151  E4ED  FF 
09151  E4EE  FF 
09151  E4EF  FF 
09151  E4F0  FF 
09151  E4F1  FF 
09151  E4F2  FF 
09151  E4F3  FF 
09151  E4F4  FF 
09151  E4F5  FF 
09151  E4F6  FF 
09151  E4F7  FF 
09151  E4F8  FF 
09151  E4F9  FF 
09152  E4FA  FF                 .BYTE     $FF,$FF,$FF,$FF,$FF,$FF
09152  E4FB  FF 
09152  E4FC  FF 
09152  E4FD  FF 
09152  E4FE  FF 
09152  E4FF  FF 
09153  E500                     
09154  E500                     
09155  E500              ;************************************************
***********************************;
09156  E500              ;
09157  E500              ; RETURN BASE ADDRESS OF I/O DEVICES
09158  E500              
09159  E500              ; THIS ROUTINE WILL SET XY TO THE ADDRESS OF THE 
MEMORY SECTION WHERE THE MEMORY
09160  E500              ; MAPPED I/O DEVICES ARE LOCATED. THIS ADDRESS CA
N THEN BE USED WITH AN OFFSET TO
09161  E500              ; ACCESS THE MEMORY MAPPED I/O DEVICES IN THE COM
PUTER.
09162  E500              
09163  E500              XXE500 = *
09164  E500  A2 10              LDX     #<XX9110          ; GET I/O BASE A
DDRESS LOW BYTE
09165  E502  A0 91              LDY     #>XX9110          ; GET I/O BASE A
DDRESS HIGH BYTE
09166  E504  60                 RTS
09167  E505                     
09168  E505                     
09169  E505              ;************************************************
***********************************;






****;O......PAGE 0176

LINE# LOC   CODE        LINE


09170  E505              ;
09171  E505              ; RETURN X,Y ORGANIZATION OF SCREEN
09172  E505              
09173  E505              ; THIS ROUTINE RETURNS THE X,Y ORGANISATION OF TH
E SCREEN IN X,Y
09174  E505              
09175  E505              XXE505 = *
09176  E505  A2 16              LDX     #$16               ; GET SCREEN X,
 22 COLUMNS
09177  E507  A0 17              LDY     #$17               ; GET SCREEN Y,
 23 ROWS
09178  E509  60                 RTS
09179  E50A                     
09180  E50A                     
09181  E50A              ;************************************************
***********************************;
09182  E50A              ;
09183  E50A              ; READ/SET X,Y CURSOR POSITION, CB = 1 TO READ, C
B = 0 TO SET
09184  E50A              
09185  E50A              ; THIS ROUTINE, WHEN CALLED WITH THE CARRY FLAG S
ET, LOADS THE CURRENT POSITION OF
09186  E50A              ; THE CURSOR ON THE SCREEN INTO THE X AND Y REGIS
TERS. X IS THE COLUMN NUMBER OF
09187  E50A              ; THE CURSOR LOCATION AND Y IS THE ROW NUMBER OF 
THE CURSOR. A CALL WITH THE CARRY
09188  E50A              ; BIT CLEAR MOVES THE CURSOR TO THE POSITION DETE
RMINED BY THE X AND Y REGISTERS.
09189  E50A              
09190  E50A              XXE50A = *
09191  E50A  B0 07              BCS     XXE513          ; IF READ CURSOR S
KIP THE SET CURSOR
09192  E50C                     
09193  E50C  86 D6              STX     XXD6          ; SAVE CURSOR ROW
09194  E50E  84 D3              STY     XXD3          ; SAVE CURSOR COLUMN

09195  E510  20 87 E5           JSR     XXE587          ; SET SCREEN POINT
ERS FOR CURSOR ROW, COLUMN
09196  E513              XXE513 = *
09197  E513  A6 D6              LDX     XXD6          ; GET CURSOR ROW
09198  E515  A4 D3              LDY     XXD3          ; GET CURSOR COLUMN
09199  E517  60                 RTS
09200  E518                     
09201  E518                     
09202  E518              ;************************************************
***********************************;
09203  E518              ;
09204  E518              ; INITIALISE HARDWARE
09205  E518              
09206  E518              XXE518 = *
09207  E518  20 BB E5           JSR     XXE5BB          ; SET DEFAULT DEVI
CES AND INITIALISE VIC CHIP
09208  E51B  AD 88 02           LDA     XX0288          ; GET SCREEN MEMOR
Y PAGE
09209  E51E  29 FD              AND     #$FD               ; MASK XXXX XX0
X, ALL BUT VA9
09210  E520  0A                 ASL A                  ; << 1 XXXX X0X0
09211  E521  0A                 ASL A                  ; << 2 XXXX 0X00
09212  E522  09 80              ORA     #$80               ; SET  1XXX 0X0
0
09213  E524  8D 05 90           STA     XX9005          ; SET SCREEN AND C
HARACTER MEMORY LOCATION
09214  E527  AD 88 02           LDA     XX0288          ; GET SCREEN MEMOR
Y PAGE
09215  E52A  29 02              AND     #$02               ; MASK BIT 9
09216  E52C  F0 08              BEQ     XXE536          ; IF ZERO JUST GO 
NORMALISE SCREEN
09217  E52E                     
09218  E52E                                     ; ELSE SET VA9 IN VIC CHIP

09219  E52E  A9 80              LDA     #$80               ; SET B7
09220  E530  0D 02 90           ORA     XX9002          ; OR IN AS VIDEO A
DDRESS 9
09221  E533  8D 02 90           STA     XX9002          ; SAVE NEW VA9
09222  E536                     
09223  E536                                     ; NOW NORMALISE SCREEN
09224  E536              XXE536 = *






****;O......PAGE 0177

LINE# LOC   CODE        LINE


09225  E536  A9 00              LDA     #$00               ; CLEAR A
09226  E538  8D 91 02           STA     XX0291          ; CLEAR SHIFT MODE
 SWITCH
09227  E53B  85 CF              STA     XXCF          ; CLEAR CURSOR BLINK
 PHASE
09228  E53D  A9 DC              LDA     #<XXEBDC          ; GET KEYBOARD D
ECODE LOGIC POINTER LOW BYTE
09229  E53F  8D 8F 02           STA     XX028F          ; SET KEYBOARD DEC
ODE LOGIC POINTER LOW BYTE
09230  E542  A9 EB              LDA     #>XXEBDC          ; GET KEYBOARD D
ECODE LOGIC POINTER HIGH BYTE
09231  E544  8D 90 02           STA     XX0290          ; SET KEYBOARD DEC
ODE LOGIC POINTER HIGH BYTE
09232  E547  A9 0A              LDA     #$0A               ; 10D
09233  E549  8D 89 02           STA     XX0289          ; SET MAXIMUM SIZE
 OF KEYBOARD BUFFER
09234  E54C  8D 8C 02           STA     XX028C          ; SET REPEAT DELAY
 COUNTER
09235  E54F  A9 06              LDA     #$06               ; COLOUR BLUE
09236  E551  8D 86 02           STA     XX0286          ; SET CURRENT COLO
UR CODE
09237  E554  A9 04              LDA     #$04               ; SPEED 4
09238  E556  8D 8B 02           STA     XX028B          ; SET REPEAT SPEED
 COUNTER
09239  E559  A9 0C              LDA     #$0C               ; CURSOR FLASH 
TIMING
09240  E55B  85 CD              STA     XXCD          ; SET CURSOR TIMING 
COUNTDOWN
09241  E55D  85 CC              STA     XXCC          ; SET CURSOR ENABLE,
 $00 = FLASH CURSOR
09242  E55F                     
09243  E55F              ; CLEAR SCREEN
09244  E55F              
09245  E55F              XXE55F = *
09246  E55F  AD 88 02           LDA     XX0288          ; GET SCREEN MEMOR
Y PAGE
09247  E562  09 80              ORA     #$80               ; SET HIGH BIT,
 FLAG EVERY LINE IS LOGICAL LINE START
09248  E564  A8                 TAY                    ; COPY TO Y
09249  E565  A9 00              LDA     #$00               ; CLEAR LINE ST
ART LOW BYTE
09250  E567  AA                 TAX                    ; CLEAR INDEX
09251  E568              XXE568 = *
09252  E568  94 D9              STY     XXD9,X          ; SAVE START OF LI
NE X POINTER HIGH BYTE
09253  E56A  18                 CLC                    ; CLEAR CARRY FOR A
DD
09254  E56B  69 16              ADC     #$16               ; ADD LINE LENG
TH TO LOW BYTE
09255  E56D  90 01              BCC     XXE570          ; IF NO ROLLOVER S
KIP THE HIGH BYTE INCREMENT
09256  E56F                     
09257  E56F  C8                 INY                    ; ELSE INCREMENT HI
GH BYTE
09258  E570              XXE570 = *
09259  E570  E8                 INX                    ; INCREMENT LINE IN
DEX
09260  E571  E0 18              CPX     #$18               ; COMPARE WITH 
NUMBER OF LINES + 1
09261  E573  D0 F3              BNE     XXE568          ; LOOP IF NOT ALL 
DONE
09262  E575                     
09263  E575  A9 FF              LDA     #$FF               ; END OF TABLE 
MARKER ??
09264  E577  95 D9              STA     XXD9,X          ; MARK END OF TABL
E
09265  E579  A2 16              LDX     #$16               ; SET LINE COUN
T, 23 LINES TO DO, 0 TO 22
09266  E57B              XXE57B = *
09267  E57B  20 8D EA           JSR     XXEA8D          ; CLEAR SCREEN LIN
E X
09268  E57E  CA                 DEX                    ; DECREMENT COUNT
09269  E57F  10 FA              BPL     XXE57B          ; LOOP IF MORE TO 
DO
09270  E581                     
09271  E581              ; HOME CURSOR
09272  E581              
09273  E581              XXE581 = *
09274  E581  A0 00              LDY     #$00               ; CLEAR Y
09275  E583  84 D3              STY     XXD3          ; CLEAR CURSOR COLUM
N
09276  E585  84 D6              STY     XXD6          ; CLEAR CURSOR ROW
09277  E587                     
09278  E587              ; SET SCREEN POINTERS FOR CURSOR ROW, COLUMN
09279  E587              






STARTO......PAGE 0178

LINE# LOC   CODE        LINE


09280  E587              XXE587 = *
09281  E587  A6 D6              LDX     XXD6          ; GET CURSOR ROW
09282  E589  A5 D3              LDA     XXD3          ; GET CURSOR COLUMN
09283  E58B              XXE58B = *
09284  E58B  B4 D9              LDY     XXD9,X          ; GET START OF LIN
E X POINTER HIGH BYTE
09285  E58D  30 08              BMI     XXE597          ; CONTINUE IF LOGI
CAL LINE START
09286  E58F                     
09287  E58F  18                 CLC                    ; ELSE CLEAR CARRY 
FOR ADD
09288  E590  69 16              ADC     #$16               ; ADD ONE LINE 
LENGTH
09289  E592  85 D3              STA     XXD3          ; SAVE CURSOR COLUMN

09290  E594  CA                 DEX                    ; DECREMENT CURSOR 
ROW
09291  E595  10 F4              BPL     XXE58B          ; LOOP, BRANCH ALW
AYS
09292  E597                     
09293  E597              XXE597 = *
09294  E597  B5 D9              LDA     XXD9,X          ; GET START OF LIN
E X POINTER HIGH BYTE
09295  E599  29 03              AND     #$03               ; MASK 0000 00X
X, LINE MEMORY PAGE
09296  E59B  0D 88 02           ORA     XX0288          ; OR WITH SCREEN M
EMORY PAGE
09297  E59E  85 D2              STA     XXD2          ; SET CURRENT SCREEN
 LINE POINTER HIGH BYTE
09298  E5A0  BD FD ED           LDA     XXEDFD,X          ; GET START OF L
INE LOW BYTE FROM ROM TABLE
09299  E5A3  85 D1              STA     XXD1          ; SET CURRENT SCREEN
 LINE POINTER LOW BYTE
09300  E5A5  A9 15              LDA     #$15               ; SET LINE LENG
TH
09301  E5A7  E8                 INX                    ; INCREMENT CURSOR 
ROW
09302  E5A8              XXE5A8 = *
09303  E5A8  B4 D9              LDY     XXD9,X          ; GET START OF LIN
E X POINTER HIGH BYTE
09304  E5AA  30 06              BMI     XXE5B2          ; EXIT IF LOGICAL 
LINE START
09305  E5AC                     
09306  E5AC  18                 CLC                    ; ELSE CLEAR CARRY 
FOR ADD
09307  E5AD  69 16              ADC     #$16               ; ADD ONE LINE 
LENGTH TO CURRENT LINE LENGTH
09308  E5AF  E8                 INX                    ; INCREMENT CURSOR 
ROW
09309  E5B0  10 F6              BPL     XXE5A8          ; LOOP, BRANCH ALW
AYS
09310  E5B2                     
09311  E5B2              XXE5B2 = *
09312  E5B2  85 D5              STA     XXD5          ; SAVE CURRENT SCREE
N LINE LENGTH
09313  E5B4  60                 RTS
09314  E5B5                     
09315  E5B5                     
09316  E5B5              ;************************************************
***********************************;
09317  E5B5              ;
09318  E5B5              ; SET DEFAULT DEVICES, INITIALISE VIC CHIP AND HO
ME CURSOR
09319  E5B5              ;
09320  E5B5              ; UNREFERENCED CODE
09321  E5B5              
09322  E5B5              ;XXE5B5
09323  E5B5  20 BB E5           JSR     XXE5BB          ; SET DEFAULT DEVI
CES AND INITIALISE VIC CHIP
09324  E5B8  4C 81 E5           JMP     XXE581          ; HOME CURSOR AND 
RETURN
09325  E5BB                     
09326  E5BB                     
09327  E5BB              ;************************************************
***********************************;
09328  E5BB              ;
09329  E5BB              ; SET DEFAULT DEVICES AND INITIALISE VIC CHIP
09330  E5BB              
09331  E5BB              XXE5BB = *
09332  E5BB  A9 03              LDA     #$03               ; SET SCREEN
09333  E5BD  85 9A              STA     XX9A          ; SET OUTPUT DEVICE 
NUMBER
09334  E5BF  A9 00              LDA     #$00               ; SET KEYBOARD






****;O......PAGE 0179

LINE# LOC   CODE        LINE


09335  E5C1  85 99              STA     XX99          ; SET INPUT DEVICE N
UMBER
09336  E5C3                     
09337  E5C3              ; INITIALISE VIC CHIP
09338  E5C3              
09339  E5C3              XXE5C3 = *
09340  E5C3  A2 10              LDX     #$10               ; SET BYTE COUN
T
09341  E5C5              XXE5C5 = *
09342  E5C5  BD E3 ED           LDA     XXEDE4-1,X     ; GET BYTE FROM SET
UP TABLE
09343  E5C8  9D FF 8F           STA     XX9000-1,X     ; SAVE BYTE TO VIC 
CHIP
09344  E5CB  CA                 DEX                    ; DECREMENT COUNT/I
NDEX
09345  E5CC  D0 F7              BNE     XXE5C5          ; LOOP IF MORE TO 
DO
09346  E5CE                     
09347  E5CE  60                 RTS
09348  E5CF                     
09349  E5CF                     
09350  E5CF              ;************************************************
***********************************;
09351  E5CF              ;
09352  E5CF              ; INPUT FROM KEYBOARD BUFFER
09353  E5CF              
09354  E5CF              XXE5CF = *
09355  E5CF  AC 77 02           LDY     XX0277          ; GET CURRENT CHAR
ACTER FROM BUFFER
09356  E5D2  A2 00              LDX     #$00               ; CLEAR INDEX
09357  E5D4              XXE5D4 = *
09358  E5D4  BD 78 02           LDA     XX0277+1,X     ; GET NEXT CHARACTE
R,X FROM BUFFER
09359  E5D7  9D 77 02           STA     XX0277,X          ; SAVE AS CURREN
T CHARACTER,X IN BUFFER
09360  E5DA  E8                 INX                    ; INCREMENT INDEX
09361  E5DB  E4 C6              CPX     XXC6          ; COMPARE WITH KEYBO
ARD BUFFER INDEX
09362  E5DD  D0 F5              BNE     XXE5D4          ; LOOP IF MORE TO 
DO
09363  E5DF                     
09364  E5DF  C6 C6              DEC     XXC6          ; DECREMENT KEYBOARD
 BUFFER INDEX
09365  E5E1  98                 TYA                    ; COPY KEY TO A
09366  E5E2  58                 CLI                    ; ENABLE INTERRUPTS

09367  E5E3  18                 CLC                    ; FLAG GOT BYTE
09368  E5E4  60                 RTS
09369  E5E5                     
09370  E5E5                     
09371  E5E5              ;************************************************
***********************************;
09372  E5E5              ;
09373  E5E5              ; WRITE CHARACTER AND WAIT FOR KEY
09374  E5E5              
09375  E5E5              XXE5E5 = *
09376  E5E5  20 42 E7           JSR     XXE742          ; OUTPUT CHARACTER

09377  E5E8                     
09378  E5E8              ; WAIT FOR KEY FROM KEYBOARD
09379  E5E8              
09380  E5E8              XXE5E8 = *
09381  E5E8  A5 C6              LDA     XXC6          ; GET KEYBOARD BUFFE
R INDEX
09382  E5EA  85 CC              STA     XXCC          ; CURSOR ENABLE, $00
 = FLASH CURSOR, $XX = NO FLASH
09383  E5EC  8D 92 02           STA     XX0292          ; SCREEN SCROLLING
 FLAG, $00 = SCROLL, $XX = NO SCROLL
09384  E5EF                                     ; THIS DISABLES BOTH THE C
URSOR FLASH AND THE SCREEN SCROLL
09385  E5EF                                     ; WHILE THERE ARE CHARACTE
RS IN THE KEYBOARD BUFFER
09386  E5EF  F0 F7              BEQ     XXE5E8          ; LOOP IF BUFFER E
MPTY
09387  E5F1                     
09388  E5F1  78                 SEI                    ; DISABLE INTERRUPT
S
09389  E5F2  A5 CF              LDA     XXCF          ; GET CURSOR BLINK P
HASE






ROLL;O......PAGE 0180

LINE# LOC   CODE        LINE


09390  E5F4  F0 0C              BEQ     XXE602          ; BRANCH IF CURSOR
 PHASE
09391  E5F6                     
09392  E5F6                                     ; ELSE CHARACTER PHASE
09393  E5F6  A5 CE              LDA     XXCE          ; GET CHARACTER UNDE
R CURSOR
09394  E5F8  AE 87 02           LDX     XX0287          ; GET COLOUR UNDER
 CURSOR
09395  E5FB  A0 00              LDY     #$00               ; CLEAR Y
09396  E5FD  84 CF              STY     XXCF          ; CLEAR CURSOR BLINK
 PHASE
09397  E5FF  20 A1 EA           JSR     XXEAA1          ; PRINT CHARACTER 
A AND COLOUR X
09398  E602              XXE602 = *
09399  E602  20 CF E5           JSR     XXE5CF          ; INPUT FROM KEYBO
ARD BUFFER
09400  E605  C9 83              CMP     #$83               ; COMPARE WITH 
[SHIFT][RUN]
09401  E607  D0 10              BNE     XXE619          ; BRANCH IF NOT [S
HIFT][RUN]
09402  E609                     
09403  E609                                     ; KEYS ARE [SHIFT][RUN] SO
 PUT 'LOAD',$0D,'RUN',$0D INTO
09404  E609                                     ; THE BUFFER
09405  E609  A2 09              LDX     #$09               ; SET BYTE COUN
T
09406  E60B  78                 SEI                    ; DISABLE INTERRUPT
S
09407  E60C  86 C6              STX     XXC6          ; SET KEYBOARD BUFFE
R INDEX
09408  E60E              XXE60E = *
09409  E60E  BD F3 ED           LDA     XXEDF4-1,X     ; GET BYTE FROM AUT
O LOAD/RUN TABLE
09410  E611  9D 76 02           STA     XX0277-1,X     ; SAVE TO KEYBOARD 
BUFFER
09411  E614  CA                 DEX                    ; DECREMENT COUNT/I
NDEX
09412  E615  D0 F7              BNE     XXE60E          ; LOOP WHILE MORE 
TO DO
09413  E617                     
09414  E617  F0 CF              BEQ     XXE5E8          ; LOOP FOR NEXT KE
Y, BRANCH ALWAYS
09415  E619                     
09416  E619                                     ; WAS NOT [SHIFT][RUN]
09417  E619              XXE619 = *
09418  E619  C9 0D              CMP     #$0D               ; COMPARE WITH 
[CR]
09419  E61B  D0 C8              BNE     XXE5E5          ; IF NOT [CR] PRIN
T CHARACTER AND GET NEXT KEY
09420  E61D                     
09421  E61D                                     ; WAS [CR]
09422  E61D  A4 D5              LDY     XXD5          ; GET CURRENT SCREEN
 LINE LENGTH
09423  E61F  84 D0              STY     XXD0          ; INPUT FROM KEYBOAR
D OR SCREEN, $XX = SCREEN,
09424  E621                                     ; $00 = KEYBOARD
09425  E621              XXE621 = *
09426  E621  B1 D1              LDA     (XXD1),Y          ; GET CHARACTER 
FROM CURRENT SCREEN LINE
09427  E623  C9 20              CMP     #' '               ; COMPARE WITH 
[SPACE]
09428  E625  D0 03              BNE     XXE62A          ; BRANCH IF NOT [S
PACE]
09429  E627                     
09430  E627  88                 DEY                    ; ELSE ELIMINATE TH
E SPACE, DECREMENT END OF INPUT LINE
09431  E628  D0 F7              BNE     XXE621          ; LOOP, BRANCH ALW
AYS
09432  E62A                     
09433  E62A              XXE62A = *
09434  E62A  C8                 INY                    ; INCREMENT PAST LA
ST NON SPACE CHARACTER ON LINE
09435  E62B  84 C8              STY     XXC8          ; SAVE INPUT [EOL] P
OINTER
09436  E62D  A0 00              LDY     #$00               ; CLEAR A
09437  E62F  8C 92 02           STY     XX0292          ; CLEAR SCREEN SCR
OLLING FLAG, $00 = SCROLL, $XX = NO SCROLL
09438  E632  84 D3              STY     XXD3          ; CLEAR CURSOR COLUM
N
09439  E634  84 D4              STY     XXD4          ; CLEAR CURSOR QUOTE
 FLAG, $XX = QUOTE, $00 = NO QUOTE
09440  E636  A5 C9              LDA     XXC9          ; GET INPUT CURSOR R
OW
09441  E638  30 1D              BMI     XXE657          ;.
09442  E63A                     
09443  E63A  A6 D6              LDX     XXD6          ; GET CURSOR ROW
09444  E63C  20 19 E7           JSR     XXE719          ; FIND AND SET POI
NTERS FOR START OF LOGICAL LINE






EO SCR......PAGE 0181

LINE# LOC   CODE        LINE


09445  E63F  E4 C9              CPX     XXC9          ; COMPARE WITH INPUT
 CURSOR ROW
09446  E641  D0 14              BNE     XXE657          ;.
09447  E643                     
09448  E643  D0 12              BNE     XXE657          ;.?? WHAT'S THIS? 
JUST TO MAKE SURE OR SOMETHING
09449  E645                     
09450  E645  A5 CA              LDA     XXCA          ; GET INPUT CURSOR C
OLUMN
09451  E647  85 D3              STA     XXD3          ; SAVE CURSOR COLUMN

09452  E649  C5 C8              CMP     XXC8          ; COMPARE WITH INPUT
 [EOL] POINTER
09453  E64B  90 0A              BCC     XXE657          ; BRANCH IF LESS, 
CURSOR IS IN LINE
09454  E64D                     
09455  E64D  B0 42              BCS     XXE691          ; ELSE CURSOR IS B
EYOND THE LINE END, BRANCH ALWAYS
09456  E64F                     
09457  E64F                     
09458  E64F              ;************************************************
***********************************;
09459  E64F              ;
09460  E64F              ; INPUT FROM SCREEN OR KEYBOARD
09461  E64F              
09462  E64F              XXE64F = *
09463  E64F  98                 TYA                    ; COPY Y
09464  E650  48                 PHA                    ; SAVE Y
09465  E651  8A                 TXA                    ; COPY X
09466  E652  48                 PHA                    ; SAVE X
09467  E653  A5 D0              LDA     XXD0          ; INPUT FROM KEYBOAR
D OR SCREEN, $XX = SCREEN,
09468  E655                                     ; $00 = KEYBOARD
09469  E655  F0 91              BEQ     XXE5E8          ; IF KEYBOARD GO W
AIT FOR KEY
09470  E657                     
09471  E657              XXE657 = *
09472  E657  A4 D3              LDY     XXD3          ; GET CURSOR COLUMN
09473  E659  B1 D1              LDA     (XXD1),Y          ; GET CHARACTER 
FROM THE CURRENT SCREEN LINE
09474  E65B  EA                 NOP                    ;
09475  E65C  EA                 NOP                    ;
09476  E65D  EA                 NOP                    ;
09477  E65E  EA                 NOP                    ;
09478  E65F  EA                 NOP                    ;
09479  E660  EA                 NOP                    ;
09480  E661  EA                 NOP                    ;
09481  E662  EA                 NOP                    ;
09482  E663  EA                 NOP                    ; JUST A FEW WASTED
 CYCLES.
09483  E664  EA                 NOP                    ;
09484  E665  EA                 NOP                    ;
09485  E666  EA                 NOP                    ;
09486  E667  EA                 NOP                    ;
09487  E668  EA                 NOP                    ;
09488  E669  EA                 NOP                    ;
09489  E66A  EA                 NOP                    ;
09490  E66B  EA                 NOP                    ;
09491  E66C  EA                 NOP                    ;
09492  E66D  EA                 NOP                    ;
09493  E66E  EA                 NOP                    ;
09494  E66F  EA                 NOP                    ;
09495  E670  EA                 NOP                    ;
09496  E671  EA                 NOP                    ;
09497  E672  85 D7              STA     XXD7          ; SAVE TEMPORARY LAS
T CHARACTER
09498  E674  29 3F              AND     #$3F               ; MASK KEY BITS

09499  E676  06 D7              ASL     XXD7          ; << TEMPORARY LAST 
CHARACTER






****;R......PAGE 0182

LINE# LOC   CODE        LINE


09500  E678  24 D7              BIT     XXD7          ; TEST IT
09501  E67A  10 02              BPL     XXE67E          ; BRANCH IF NOT [N
O KEY]
09502  E67C                     
09503  E67C  09 80              ORA     #$80               ;.
09504  E67E              XXE67E = *
09505  E67E  90 04              BCC     XXE684          ;.
09506  E680                     
09507  E680  A6 D4              LDX     XXD4          ; GET CURSOR QUOTE F
LAG, $XX = QUOTE, $00 = NO QUOTE
09508  E682  D0 04              BNE     XXE688          ; BRANCH IF IN QUO
TE MODE
09509  E684                     
09510  E684              XXE684 = *
09511  E684  70 02              BVS     XXE688          ;.
09512  E686                     
09513  E686  09 40              ORA     #$40               ;.
09514  E688              XXE688 = *
09515  E688  E6 D3              INC     XXD3          ; INCREMENT CURSOR C
OLUMN
09516  E68A  20 B8 E6           JSR     XXE6B8          ; IF OPEN QUOTE TO
GGLE CURSOR QUOTE FLAG
09517  E68D  C4 C8              CPY     XXC8          ; COMPARE WITH INPUT
 [EOL] POINTER
09518  E68F  D0 17              BNE     XXE6A8          ; BRANCH IF NOT AT
 LINE END
09519  E691                     
09520  E691              XXE691 = *
09521  E691  A9 00              LDA     #$00               ;.
09522  E693  85 D0              STA     XXD0          ; CLEAR INPUT FROM K
EYBOARD OR SCREEN, $XX = SCREEN,
09523  E695                                     ; $00 = KEYBOARD
09524  E695  A9 0D              LDA     #$0D               ; SET CHARACTER
 [CR]
09525  E697  A6 99              LDX     XX99          ; GET INPUT DEVICE N
UMBER
09526  E699  E0 03              CPX     #$03               ; COMPARE WITH 
SCREEN
09527  E69B  F0 06              BEQ     XXE6A3          ; BRANCH IF SCREEN

09528  E69D                     
09529  E69D  A6 9A              LDX     XX9A          ; GET OUTPUT DEVICE 
NUMBER
09530  E69F  E0 03              CPX     #$03               ; COMPARE WITH 
SCREEN
09531  E6A1  F0 03              BEQ     XXE6A6          ; BRANCH IF SCREEN

09532  E6A3                     
09533  E6A3              XXE6A3 = *
09534  E6A3  20 42 E7           JSR     XXE742          ; OUTPUT CHARACTER

09535  E6A6              XXE6A6 = *
09536  E6A6  A9 0D              LDA     #$0D               ; SET CHARACTER
 [CR]
09537  E6A8              XXE6A8 = *
09538  E6A8  85 D7              STA     XXD7          ; SAVE CHARACTER
09539  E6AA  68                 PLA                    ; PULL X
09540  E6AB  AA                 TAX                    ; RESTORE X
09541  E6AC  68                 PLA                    ; PULL Y
09542  E6AD  A8                 TAY                    ; RESTORE Y
09543  E6AE  A5 D7              LDA     XXD7          ; RESTORE CHARACTER
09544  E6B0  C9 DE              CMP     #$DE               ;.
09545  E6B2  D0 02              BNE     XXE6B6          ;.
09546  E6B4                     
09547  E6B4  A9 FF              LDA     #$FF               ;.
09548  E6B6              XXE6B6 = *
09549  E6B6  18                 CLC                    ; FLAG OK
09550  E6B7  60                 RTS
09551  E6B8                     
09552  E6B8                     
09553  E6B8              ;************************************************
***********************************;
09554  E6B8              ;






****;R......PAGE 0183

LINE# LOC   CODE        LINE


09555  E6B8              ; IF OPEN QUOTE TOGGLE CURSOR QUOTE FLAG
09556  E6B8              
09557  E6B8              XXE6B8 = *
09558  E6B8  C9 22              CMP     #$22               ; COMAPRE BYTE 
WITH '
09559  E6BA  D0 08              BNE     XXE6C4          ; EXIT IF NOT '
09560  E6BC                     
09561  E6BC  A5 D4              LDA     XXD4          ; GET CURSOR QUOTE F
LAG, $XX = QUOTE, $00 = NO QUOTE
09562  E6BE  49 01              EOR     #$01               ; TOGGLE IT
09563  E6C0  85 D4              STA     XXD4          ; SAVE CURSOR QUOTE 
FLAG
09564  E6C2  A9 22              LDA     #$22               ; RESTORE THE '

09565  E6C4              XXE6C4 = *
09566  E6C4  60                 RTS
09567  E6C5                     
09568  E6C5                     
09569  E6C5              ;************************************************
***********************************;
09570  E6C5              ;
09571  E6C5              ; INSERT UPPERCASE/GRAPHIC CHARACTER
09572  E6C5              
09573  E6C5              XXE6C5 = *
09574  E6C5  09 40              ORA     #$40               ; CHANGE TO UPP
ERCASE/GRAPHIC
09575  E6C7              XXE6C7 = *
09576  E6C7  A6 C7              LDX     XXC7          ; GET REVERSE FLAG
09577  E6C9  F0 02              BEQ     XXE6CD          ; BRANCH IF NOT RE
VERSE
09578  E6CB                     
09579  E6CB                                     ; ELSE ..
09580  E6CB              ; INSERT REVERSED CHARACTER
09581  E6CB              
09582  E6CB              XXE6CB = *
09583  E6CB  09 80              ORA     #$80               ; REVERSE CHARA
CTER
09584  E6CD              XXE6CD = *
09585  E6CD  A6 D8              LDX     XXD8          ; GET INSERT COUNT
09586  E6CF  F0 02              BEQ     XXE6D3          ; BRANCH IF NONE
09587  E6D1                     
09588  E6D1  C6 D8              DEC     XXD8          ; ELSE DECREMENT INS
ERT COUNT
09589  E6D3              XXE6D3 = *
09590  E6D3  AE 86 02           LDX     XX0286          ; GET CURRENT COLO
UR CODE
09591  E6D6  20 A1 EA           JSR     XXEAA1          ; PRINT CHARACTER 
A AND COLOUR X
09592  E6D9  20 EA E6           JSR     XXE6EA          ; ADVANCE CURSOR
09593  E6DC                     
09594  E6DC              ; RESTORE REGISTERS, SET QUOTE FLAG AND EXIT
09595  E6DC              
09596  E6DC              XXE6DC = *
09597  E6DC  68                 PLA                    ; PULL Y
09598  E6DD  A8                 TAY                    ; RESTORE Y
09599  E6DE  A5 D8              LDA     XXD8          ; GET INSERT COUNT
09600  E6E0  F0 02              BEQ     XXE6E4          ; SKIP QUOTE FLAG 
CLEAR IF INSERTS TO DO
09601  E6E2                     
09602  E6E2  46 D4              LSR     XXD4          ; CLEAR CURSOR QUOTE
 FLAG, $XX = QUOTE, $00 = NO QUOTE
09603  E6E4              XXE6E4 = *
09604  E6E4  68                 PLA                    ; PULL X
09605  E6E5  AA                 TAX                    ; RESTORE X
09606  E6E6  68                 PLA                    ; RESTORE A
09607  E6E7  18                 CLC                    ;.
09608  E6E8  58                 CLI                    ; ENABLE INTERRUPTS

09609  E6E9  60                 RTS






E***;R......PAGE 0184

LINE# LOC   CODE        LINE


09610  E6EA                     
09611  E6EA                     
09612  E6EA              ;************************************************
***********************************;
09613  E6EA              ;
09614  E6EA              ; ADVANCE CURSOR
09615  E6EA              
09616  E6EA              XXE6EA = *
09617  E6EA  20 FA E8           JSR     XXE8FA          ; TEST FOR LINE IN
CREMENT
09618  E6ED  E6 D3              INC     XXD3          ; INCREMENT CURSOR C
OLUMN
09619  E6EF  A5 D5              LDA     XXD5          ; GET CURRENT SCREEN
 LINE LENGTH
09620  E6F1  C5 D3              CMP     XXD3          ; COMPARE WITH CURSO
R COLUMN
09621  E6F3  B0 37              BCS     XXE72C          ; EXIT IF LINE LEN
GTH >= CURSOR COLUMN
09622  E6F5                     
09623  E6F5  C9 57              CMP     #$57               ; COMPARE WITH 
MAX LENGTH
09624  E6F7  F0 2A              BEQ     XXE723          ; IF AT MAX CLEAR 
COLUMN, BACK CURSOR UP AND DO NEWLINE
09625  E6F9                     
09626  E6F9  AD 92 02           LDA     XX0292          ; GET AUTOSCROLL F
LAG
09627  E6FC  F0 03              BEQ     XXE701          ; BRANCH IF AUTOSC
ROLL ON
09628  E6FE                     
09629  E6FE  4C F0 E9           JMP     XXE9F0          ;.ELSE OPEN SPACE 
ON SCREEN
09630  E701                     
09631  E701              XXE701 = *
09632  E701  A6 D6              LDX     XXD6          ; GET CURSOR ROW
09633  E703  E0 17              CPX     #$17               ; COMPARE WITH 
MAX + 1
09634  E705  90 07              BCC     XXE70E          ; IF LESS THAN MAX
 + 1 GO ADD THIS ROW TO THE CURRENT
09635  E707                                     ; LOGICAL LINE
09636  E707                     
09637  E707  20 75 E9           JSR     XXE975          ; ELSE SCROLL SCRE
EN
09638  E70A  C6 D6              DEC     XXD6          ; DECREMENT CURSOR R
OW
09639  E70C  A6 D6              LDX     XXD6          ; GET CURSOR ROW
09640  E70E                     
09641  E70E              ; ADD THIS ROW TO THE CURRENT LOGICAL LINE
09642  E70E              
09643  E70E              XXE70E = *
09644  E70E  16 D9              ASL     XXD9,X          ; SHIFT START OF L
INE X POINTER HIGH BYTE
09645  E710  56 D9              LSR     XXD9,X          ; SHIFT START OF L
INE X POINTER HIGH BYTE BACK,
09646  E712                                     ; CLEAR B7, START OF LOGIC
AL LINE
09647  E712  4C 5B ED           JMP     XXED5B          ; MAKE NEXT SCREEN
 LINE START OF LOGICAL LINE, INCREMENT
09648  E715                                     ; LINE LENGTH AND SET POIN
TERS
09649  E715                     
09650  E715              ; ADD ONE LINE LENGTH AND SET POINTERS FOR START 
OF LINE
09651  E715              
09652  E715              XXE715 = *
09653  E715  69 16              ADC     #$16               ; ADD ONE LINE 
LENGTH
09654  E717  85 D5              STA     XXD5          ; SAVE CURRENT SCREE
N LINE LENGTH
09655  E719                     
09656  E719              ; FIND AND SET POINTERS FOR START OF LOGICAL LINE

09657  E719              
09658  E719              XXE719 = *
09659  E719  B5 D9              LDA     XXD9,X          ; GET START OF LIN
E X POINTER HIGH BYTE
09660  E71B  30 03              BMI     XXE720          ; EXIT LOOP IF STA
RT OF LOGICAL LINE
09661  E71D                     
09662  E71D  CA                 DEX                    ; ELSE BACK UP ONE 
LINE
09663  E71E  D0 F9              BNE     XXE719          ; LOOP IF NOT ON F
IRST LINE
09664  E720                     






EMENTR......PAGE 0185

LINE# LOC   CODE        LINE


09665  E720              XXE720 = *
09666  E720  4C 7E EA           JMP     XXEA7E          ; SET START OF LIN
E X AND RETURN
09667  E723                     
09668  E723              ; CLEAR CURSOR COLUMN, BACK CURSOR UP ONE LINE AN
D DO NEWLINE
09669  E723              
09670  E723              XXE723 = *
09671  E723  C6 D6              DEC     XXD6          ; DECREMENT CURSOR R
OW. IF THE CURSOR WAS INCREMENTED PAST
09672  E725                                     ; THE LAST LINE THEN THIS 
DECREMENT AND THE SCROLL WILL
09673  E725                                     ; LEAVE THE CURSOR ONE LIN
E ABOVE THE BOTOM OF THE SCREEN
09674  E725  20 C3 E8           JSR     XXE8C3          ; DO NEWLINE
09675  E728  A9 00              LDA     #$00               ; CLEAR A
09676  E72A  85 D3              STA     XXD3          ; CLEAR CURSOR COLUM
N
09677  E72C              XXE72C = *
09678  E72C  60                 RTS
09679  E72D                     
09680  E72D              ; BACK ONTO PREVIOUS LINE IF POSSIBLE
09681  E72D              
09682  E72D              XXE72D = *
09683  E72D  A6 D6              LDX     XXD6          ; GET CURSOR ROW
09684  E72F  D0 06              BNE     XXE737          ; BRANCH IF NOT TO
P ROW
09685  E731                     
09686  E731  86 D3              STX     XXD3          ; CLEAR CURSOR COLUM
N
09687  E733  68                 PLA                    ; DUMP RETURN ADDRE
SS LOW BYTE
09688  E734  68                 PLA                    ; DUMP RETURN ADDRE
SS HIGH BYTE
09689  E735  D0 A5              BNE     XXE6DC          ; RESTORE REGISTER
S, SET QUOTE FLAG AND EXIT, BRANCH ALWAYS
09690  E737                     
09691  E737              XXE737 = *
09692  E737  CA                 DEX                    ; DECREMENT CURSOR 
ROW
09693  E738  86 D6              STX     XXD6          ; SAVE CURSOR ROW
09694  E73A  20 87 E5           JSR     XXE587          ; SET SCREEN POINT
ERS FOR CURSOR ROW, COLUMN
09695  E73D  A4 D5              LDY     XXD5          ; GET CURRENT SCREEN
 LINE LENGTH
09696  E73F  84 D3              STY     XXD3          ; SAVE AS CURSOR COL
UMN
09697  E741  60                 RTS
09698  E742                     
09699  E742                     
09700  E742              ;************************************************
***********************************;
09701  E742              ;
09702  E742              ;## OUTPUT CHARACTER TO SCREEN
09703  E742              
09704  E742              XXE742 = *
09705  E742  48                 PHA                    ; SAVE CHARACTER
09706  E743  85 D7              STA     XXD7          ; SAVE TEMPORARY LAS
T CHARACTER
09707  E745  8A                 TXA                    ; COPY X
09708  E746  48                 PHA                    ; SAVE X
09709  E747  98                 TYA                    ; COPY Y
09710  E748  48                 PHA                    ; SAVE Y
09711  E749  A9 00              LDA     #$00               ; CLEAR A
09712  E74B  85 D0              STA     XXD0          ; CLEAR INPUT FROM K
EYBOARD OR SCREEN, $XX = SCREEN,
09713  E74D                                     ; $00 = KEYBOARD
09714  E74D  A4 D3              LDY     XXD3          ; GET CURSOR COLUMN
09715  E74F  A5 D7              LDA     XXD7          ; RESTORE LAST CHARA
CTER
09716  E751  10 03              BPL     XXE756          ; BRANCH IF UNSHIF
TED
09717  E753                     
09718  E753  4C 00 E8           JMP     XXE800          ; DO SHIFTED CHARA
CTERS AND RETURN
09719  E756                     






****;A......PAGE 0186

LINE# LOC   CODE        LINE


09720  E756              XXE756 = *
09721  E756  C9 0D              CMP     #$0D               ; COMPARE WITH 
[CR]
09722  E758  D0 03              BNE     XXE75D          ; BRANCH IF NOT [C
R]
09723  E75A                     
09724  E75A  4C D8 E8           JMP     XXE8D8          ; ELSE OUTPUT [CR]
 AND RETURN
09725  E75D                     
09726  E75D              XXE75D = *
09727  E75D  C9 20              CMP     #' '               ; COMPARE WITH 
[SPACE]
09728  E75F  90 10              BCC     XXE771          ; BRANCH IF < [SPA
CE]
09729  E761                     
09730  E761  C9 60              CMP     #$60               ;.
09731  E763  90 04              BCC     XXE769          ; BRANCH IF $20 TO
 $5F
09732  E765                     
09733  E765                                     ; CHARACTER IS $60 OR GREA
TER
09734  E765  29 DF              AND     #$DF               ;.
09735  E767  D0 02              BNE     XXE76B          ;.
09736  E769                     
09737  E769              XXE769 = *
09738  E769  29 3F              AND     #$3F               ;.
09739  E76B              XXE76B = *
09740  E76B  20 B8 E6           JSR     XXE6B8          ; IF OPEN QUOTE TO
GGLE CURSOR DIRECT/PROGRAMMED FLAG
09741  E76E  4C C7 E6           JMP     XXE6C7          ;.
09742  E771                     
09743  E771                                     ; CHARACTER WAS < [SPACE] 
SO IS A CONTROL CHARACTER
09744  E771                                     ; OF SOME SORT
09745  E771              XXE771 = *
09746  E771  A6 D8              LDX     XXD8          ; GET INSERT COUNT
09747  E773  F0 03              BEQ     XXE778          ; BRANCH IF NO CHA
RACTERS TO INSERT
09748  E775                     
09749  E775  4C CB E6           JMP     XXE6CB          ; INSERT REVERSED 
CHARACTER
09750  E778                     
09751  E778              XXE778 = *
09752  E778  C9 14              CMP     #$14               ; COMPARE WITH 
[INSERT]/[DELETE]
09753  E77A  D0 2E              BNE     XXE7AA          ; BRANCH IF NOT [I
NSERT]/[DELETE]
09754  E77C                     
09755  E77C  98                 TYA                    ;.
09756  E77D  D0 06              BNE     XXE785          ;.
09757  E77F                     
09758  E77F  20 2D E7           JSR     XXE72D          ; BACK ONTO PREVIO
US LINE IF POSSIBLE
09759  E782  4C 9F E7           JMP     XXE79F          ;.
09760  E785                     
09761  E785              XXE785 = *
09762  E785  20 E8 E8           JSR     XXE8E8          ; TEST FOR LINE DE
CREMENT
09763  E788                     
09764  E788                                     ; NOW CLOSE UP THE LINE
09765  E788  88                 DEY                    ; DECREMENT INDEX T
O PREVIOUS CHARACTER
09766  E789  84 D3              STY     XXD3          ; SAVE CURSOR COLUMN

09767  E78B  20 B2 EA           JSR     XXEAB2          ; CALCULATE POINTE
R TO COLOUR RAM
09768  E78E              XXE78E = *
09769  E78E  C8                 INY                    ; INCREMENT INDEX T
O NEXT CHARACTER
09770  E78F  B1 D1              LDA     (XXD1),Y          ; GET CHARACTER 
FROM CURRENT SCREEN LINE
09771  E791  88                 DEY                    ; DECREMENT INDEX T
O PREVIOUS CHARACTER
09772  E792  91 D1              STA     (XXD1),Y          ; SAVE CHARACTER
 TO CURRENT SCREEN LINE
09773  E794  C8                 INY                    ; INCREMENT INDEX T
O NEXT CHARACTER
09774  E795  B1 F3              LDA     (XXF3),Y          ; GET COLOUR RAM
 BYTE






G***;A......PAGE 0187

LINE# LOC   CODE        LINE


09775  E797  88                 DEY                    ; DECREMENT INDEX T
O PREVIOUS CHARACTER
09776  E798  91 F3              STA     (XXF3),Y          ; SAVE COLOUR RA
M BYTE
09777  E79A  C8                 INY                    ; INCREMENT INDEX T
O NEXT CHARACTER
09778  E79B  C4 D5              CPY     XXD5          ; COMPARE WITH CURRE
NT SCREEN LINE LENGTH
09779  E79D  D0 EF              BNE     XXE78E          ; LOOP IF NOT THER
E YET
09780  E79F                     
09781  E79F              XXE79F = *
09782  E79F  A9 20              LDA     #' '               ; SET [SPACE]
09783  E7A1  91 D1              STA     (XXD1),Y          ; CLEAR LAST CHA
RACTER ON CURRENT SCREEN LINE
09784  E7A3  AD 86 02           LDA     XX0286          ; GET CURRENT COLO
UR CODE
09785  E7A6  91 F3              STA     (XXF3),Y          ; SAVE TO COLOUR
 RAM
09786  E7A8  10 4D              BPL     XXE7F7          ; BRANCH ALWAYS
09787  E7AA                     
09788  E7AA              XXE7AA = *
09789  E7AA  A6 D4              LDX     XXD4          ; GET CURSOR QUOTE F
LAG, $XX = QUOTE, $00 = NO QUOTE
09790  E7AC  F0 03              BEQ     XXE7B1          ; BRANCH IF NOT QU
OTE MODE
09791  E7AE                     
09792  E7AE  4C CB E6           JMP     XXE6CB          ; INSERT REVERSED 
CHARACTER
09793  E7B1                     
09794  E7B1              XXE7B1 = *
09795  E7B1  C9 12              CMP     #$12               ; COMPARE WITH 
[RVS ON]
09796  E7B3  D0 02              BNE     XXE7B7          ; BRANCH IF NOT [R
VS ON]
09797  E7B5                     
09798  E7B5  85 C7              STA     XXC7          ; SET REVERSE FLAG
09799  E7B7              XXE7B7 = *
09800  E7B7  C9 13              CMP     #$13               ; COMPARE WITH 
[CLR HOME]
09801  E7B9  D0 03              BNE     XXE7BE          ; BRANCH IF NOT [C
LR HOME]
09802  E7BB                     
09803  E7BB  20 81 E5           JSR     XXE581          ; HOME CURSOR
09804  E7BE              XXE7BE = *
09805  E7BE  C9 1D              CMP     #$1D               ; COMPARE WITH 
[CURSOR RIGHT]
09806  E7C0  D0 17              BNE     XXE7D9          ; BRANCH IF NOT [C
URSOR RIGHT]
09807  E7C2                     
09808  E7C2  C8                 INY                    ; INCREMENT CURSOR 
COLUMN
09809  E7C3  20 FA E8           JSR     XXE8FA          ; TEST FOR LINE IN
CREMENT
09810  E7C6  84 D3              STY     XXD3          ; SAVE CURSOR COLUMN

09811  E7C8  88                 DEY                    ; DECREMENT CURSOR 
COLUMN
09812  E7C9  C4 D5              CPY     XXD5          ; COMPARE CURSOR COL
UMN WITH CURRENT SCREEN LINE LENGTH
09813  E7CB  90 09              BCC     XXE7D6          ; EXIT IF LESS
09814  E7CD                     
09815  E7CD                                     ; ELSE THE CURSOR COLUMN I
S >= THE CURRENT SCREEN LINE
09816  E7CD                                     ; LENGTH SO BACK ONTO THE 
CURRENT LINE AND DO A NEWLINE
09817  E7CD  C6 D6              DEC     XXD6          ; DECREMENT CURSOR R
OW
09818  E7CF  20 C3 E8           JSR     XXE8C3          ; DO NEWLINE
09819  E7D2  A0 00              LDY     #$00               ; CLEAR CURSOR 
COLUMN
09820  E7D4              XXE7D4 = *
09821  E7D4  84 D3              STY     XXD3          ; SAVE CURSOR COLUMN

09822  E7D6              XXE7D6 = *
09823  E7D6  4C DC E6           JMP     XXE6DC          ; RESTORE REGISTER
S, SET QUOTE FLAG AND EXIT
09824  E7D9                     
09825  E7D9              XXE7D9 = *
09826  E7D9  C9 11              CMP     #$11               ; COMPARE WITH 
[CURSOR DOWN]
09827  E7DB  D0 1D              BNE     XXE7FA          ; BRANCH IF NOT [C
URSOR DOWN]
09828  E7DD                     
09829  E7DD  18                 CLC                    ; CLEAR CARRY FOR A
DD






TH**;A......PAGE 0188

LINE# LOC   CODE        LINE


09830  E7DE  98                 TYA                    ; COPY CURSOR COLUM
N
09831  E7DF  69 16              ADC     #$16               ; ADD ONE LINE
09832  E7E1  A8                 TAY                    ; COPY BACK TO A
09833  E7E2  E6 D6              INC     XXD6          ; INCREMENT CURSOR R
OW
09834  E7E4  C5 D5              CMP     XXD5          ; COMPARE CURSOR COL
UMN WITH CURRENT SCREEN LINE LENGTH
09835  E7E6  90 EC              BCC     XXE7D4          ; SAVE CURSOR COLU
MN AND EXIT IF LESS
09836  E7E8                     
09837  E7E8  F0 EA              BEQ     XXE7D4          ; SAVE CURSOR COLU
MN AND EXIT IF EQUAL
09838  E7EA                     
09839  E7EA                                     ; ELSE THE CURSOR HAS MOVE
D BEYOND THE END OF THIS LINE
09840  E7EA                                     ; SO BACK IT UP UNTIL IT'S
 ON THE START OF THE LOGICAL LINE
09841  E7EA  C6 D6              DEC     XXD6          ; DECREMENT CURSOR R
OW
09842  E7EC              XXE7EC = *
09843  E7EC  E9 16              SBC     #$16               ; SUBTRACT ONE 
LINE
09844  E7EE  90 04              BCC     XXE7F4          ; EXIT LOOP IF ON 
PREVIOUS LINE
09845  E7F0                     
09846  E7F0  85 D3              STA     XXD3          ; ELSE SAVE CURSOR C
OLUMN
09847  E7F2  D0 F8              BNE     XXE7EC          ; LOOP IF NOT AT S
TART OF LINE
09848  E7F4                     
09849  E7F4              XXE7F4 = *
09850  E7F4  20 C3 E8           JSR     XXE8C3          ; DO NEWLINE
09851  E7F7              XXE7F7 = *
09852  E7F7  4C DC E6           JMP     XXE6DC          ; RESTORE REGISTER
S, SET QUOTE FLAG AND EXIT
09853  E7FA                     
09854  E7FA              XXE7FA = *
09855  E7FA  20 12 E9           JSR     XXE912          ; SET THE COLOUR F
ROM THE CHARACTER IN A
09856  E7FD  4C 21 ED           JMP     XXED21          ;.
09857  E800                     
09858  E800              XXE800 = *
09859  E800  EA                 NOP                    ; JUST A FEW WASTED
 CYCLES
09860  E801  EA                 NOP                    ;
09861  E802  EA                 NOP                    ;
09862  E803  EA                 NOP                    ;
09863  E804  EA                 NOP                    ;
09864  E805  EA                 NOP                    ;
09865  E806  EA                 NOP                    ;
09866  E807  EA                 NOP                    ;
09867  E808  EA                 NOP                    ;
09868  E809  EA                 NOP                    ;
09869  E80A  EA                 NOP                    ;
09870  E80B  EA                 NOP                    ;
09871  E80C  EA                 NOP                    ;
09872  E80D  EA                 NOP                    ;
09873  E80E  EA                 NOP                    ;
09874  E80F  EA                 NOP                    ;
09875  E810  EA                 NOP                    ;
09876  E811  EA                 NOP                    ;
09877  E812  EA                 NOP                    ;
09878  E813  EA                 NOP                    ;
09879  E814  EA                 NOP                    ;
09880  E815  29 7F              AND     #$7F               ; MASK 0XXX XXX
X, CLEAR B7
09881  E817  C9 7F              CMP     #$7F               ; WAS IT $FF BE
FORE THE MASK
09882  E819  D0 02              BNE     XXE81D          ; BRANCH IF NOT
09883  E81B                     
09884  E81B  A9 5E              LDA     #$5E               ; ELSE MAKE IT 
$5E






LINE;A......PAGE 0189

LINE# LOC   CODE        LINE


09885  E81D              XXE81D = *
09886  E81D  EA                 NOP                    ; JUST A FEW WASTED
 CYCLES
09887  E81E  EA                 NOP                    ;
09888  E81F  EA                 NOP                    ;
09889  E820  EA                 NOP                    ;
09890  E821  EA                 NOP                    ;
09891  E822  EA                 NOP                    ;
09892  E823  C9 20              CMP     #' '               ; COMPARE WITH 
[SPACE]
09893  E825  90 03              BCC     XXE82A          ; BRANCH IF < [SPA
CE]
09894  E827                     
09895  E827  4C C5 E6           JMP     XXE6C5          ; INSERT UPPERCASE
/GRAPHIC CHARACTER AND RETURN
09896  E82A                     
09897  E82A                                     ; CHARACTER WAS $80 TO $9F
 AND IS NOW $00 TO $1F
09898  E82A              XXE82A = *
09899  E82A  C9 0D              CMP     #$0D               ; COMPARE WITH 
[CR]
09900  E82C  D0 03              BNE     XXE831          ; BRANCH IF NOT [C
R]
09901  E82E                     
09902  E82E  4C D8 E8           JMP     XXE8D8          ; ELSE OUTPUT [CR]
 AND RETURN
09903  E831                     
09904  E831                                     ; WAS NOT [CR]
09905  E831              XXE831 = *
09906  E831  A6 D4              LDX     XXD4          ; GET CURSOR QUOTE F
LAG, $XX = QUOTE, $00 = NO QUOTE
09907  E833  D0 3F              BNE     XXE874          ; BRANCH IF QUOTE 
MODE
09908  E835                     
09909  E835  C9 14              CMP     #$14               ; COMPARE WITH 
[INSERT DELETE]
09910  E837  D0 37              BNE     XXE870          ; BRANCH IF NOT [I
NSERT DELETE]
09911  E839                     
09912  E839  A4 D5              LDY     XXD5          ; GET CURRENT SCREEN
 LINE LENGTH
09913  E83B  B1 D1              LDA     (XXD1),Y          ; GET CHARACTER 
FROM CURRENT SCREEN LINE
09914  E83D  C9 20              CMP     #' '               ; COMPARE WITH 
[SPACE]
09915  E83F  D0 04              BNE     XXE845          ; BRANCH IF NOT [S
PACE]
09916  E841                     
09917  E841  C4 D3              CPY     XXD3          ; COMPARE CURRENT CO
LUMN WITH CURSOR COLUMN
09918  E843  D0 07              BNE     XXE84C          ; IF NOT CURSOR CO
LUMN GO OPEN UP SPACE ON LINE
09919  E845                     
09920  E845              XXE845 = *
09921  E845  C0 57              CPY     #$57               ; COMPARE CURRE
NT COLUMN WITH MAX LINE LENGTH
09922  E847  F0 24              BEQ     XXE86D          ; EXIT IF AT LINE 
END
09923  E849                     
09924  E849  20 EE E9           JSR     XXE9EE          ; ELSE OPEN SPACE 
ON SCREEN
09925  E84C                                     ; NOW OPEN UP SPACE ON THE
 LINE TO INSERT A CHARACTER
09926  E84C              XXE84C = *
09927  E84C  A4 D5              LDY     XXD5          ; GET CURRENT SCREEN
 LINE LENGTH
09928  E84E  20 B2 EA           JSR     XXEAB2          ; CALCULATE POINTE
R TO COLOUR RAM
09929  E851              XXE851 = *
09930  E851  88                 DEY                    ; DECREMENT INDEX T
O PREVIOUS CHARACTER
09931  E852  B1 D1              LDA     (XXD1),Y          ; GET CHARACTER 
FROM CURRENT SCREEN LINE
09932  E854  C8                 INY                    ; INCREMENT INDEX T
O NEXT CHARACTER
09933  E855  91 D1              STA     (XXD1),Y          ; SAVE CHARACTER
 TO CURRENT SCREEN LINE
09934  E857  88                 DEY                    ; DECREMENT INDEX T
O PREVIOUS CHARACTER
09935  E858  B1 F3              LDA     (XXF3),Y          ; GET CURRENT SC
REEN LINE COLOUR RAM BYTE
09936  E85A  C8                 INY                    ; INCREMENT INDEX T
O NEXT CHARACTER
09937  E85B  91 F3              STA     (XXF3),Y          ; SAVE CURRENT S
CREEN LINE COLOUR RAM BYTE
09938  E85D  88                 DEY                    ; DECREMENT INDEX T
O PREVIOUS CHARACTER
09939  E85E  C4 D3              CPY     XXD3          ; COMPARE WITH CURSO
R COLUMN






LINE;A......PAGE 0190

LINE# LOC   CODE        LINE


09940  E860  D0 EF              BNE     XXE851          ; LOOP IF NOT THER
E YET
09941  E862                     
09942  E862  A9 20              LDA     #' '               ; SET [SPACE]
09943  E864  91 D1              STA     (XXD1),Y          ; CLEAR CHARACTE
R AT CURSOR POSITION ON CURRENT SCREEN LINE
09944  E866  AD 86 02           LDA     XX0286          ; GET CURRENT COLO
UR CODE
09945  E869  91 F3              STA     (XXF3),Y          ; SAVE TO CURSOR
 POSITION ON CURRENT SCREEN LINE COLOUR RAM
09946  E86B  E6 D8              INC     XXD8          ; INCREMENT INSERT C
OUNT
09947  E86D              XXE86D = *
09948  E86D  4C DC E6           JMP     XXE6DC          ; RESTORE REGISTER
S, SET QUOTE FLAG AND EXIT
09949  E870                     
09950  E870              XXE870 = *
09951  E870  A6 D8              LDX     XXD8          ; GET INSERT COUNT
09952  E872  F0 05              BEQ     XXE879          ; BRANCH IF NO INS
ERT SPACE
09953  E874                     
09954  E874              XXE874 = *
09955  E874  09 40              ORA     #$40               ; CHANGE TO UPP
ERCASE/GRAPHIC
09956  E876  4C CB E6           JMP     XXE6CB          ; INSERT REVERSED 
CHARACTER
09957  E879                     
09958  E879              XXE879 = *
09959  E879  C9 11              CMP     #$11               ; COMPARE WITH 
[CURSOR UP]
09960  E87B  D0 16              BNE     XXE893          ; BRANCH IF NOT [C
URSOR UP]
09961  E87D                     
09962  E87D  A6 D6              LDX     XXD6          ; GET CURSOR ROW
09963  E87F  F0 37              BEQ     XXE8B8          ; BRANCH IF ON TOP
 LINE
09964  E881                     
09965  E881  C6 D6              DEC     XXD6          ; DECREMENT CURSOR R
OW
09966  E883  A5 D3              LDA     XXD3          ; GET CURSOR COLUMN
09967  E885  38                 SEC                    ; SET CARRY FOR SUB
TRACT
09968  E886  E9 16              SBC     #$16               ; SUBTRACT ONE 
LINE LENGTH
09969  E888  90 04              BCC     XXE88E          ; BRANCH IF STEPPE
D BACK TO PREVIOUS LINE
09970  E88A                     
09971  E88A  85 D3              STA     XXD3          ; ELSE SAVE CURSOR C
OLUMN ..
09972  E88C  10 2A              BPL     XXE8B8          ; .. AND EXIT, BRA
NCH ALWAYS
09973  E88E                     
09974  E88E              XXE88E = *
09975  E88E  20 87 E5           JSR     XXE587          ; SET SCREEN POINT
ERS FOR CURSOR ROW, COLUMN ..
09976  E891  D0 25              BNE     XXE8B8          ; .. AND EXIT, BRA
NCH ALWAYS
09977  E893                     
09978  E893              XXE893 = *
09979  E893  C9 12              CMP     #$12               ; COMPARE WITH 
[RVS OFF]
09980  E895  D0 04              BNE     XXE89B          ; BRANCH IF NOT [R
VS OFF]
09981  E897                     
09982  E897  A9 00              LDA     #$00               ; CLEAR A
09983  E899  85 C7              STA     XXC7          ; CLEAR REVERSE FLAG

09984  E89B              XXE89B = *
09985  E89B  C9 1D              CMP     #$1D               ; COMPARE WITH 
[CURSOR LEFT]
09986  E89D  D0 12              BNE     XXE8B1          ; BRANCH IF NOT [C
URSOR LEFT]
09987  E89F                     
09988  E89F  98                 TYA                    ; COPY CURSOR COLUM
N
09989  E8A0  F0 09              BEQ     XXE8AB          ; BRANCH IF AT STA
RT OF LINE
09990  E8A2                     
09991  E8A2  20 E8 E8           JSR     XXE8E8          ; TEST FOR LINE DE
CREMENT
09992  E8A5  88                 DEY                    ; DECREMENT CURSOR 
COLUMN
09993  E8A6  84 D3              STY     XXD3          ; SAVE CURSOR COLUMN

09994  E8A8  4C DC E6           JMP     XXE6DC          ; RESTORE REGISTER
S, SET QUOTE FLAG AND EXIT






COLOUR......PAGE 0191

LINE# LOC   CODE        LINE


09995  E8AB                     
09996  E8AB              XXE8AB = *
09997  E8AB  20 2D E7           JSR     XXE72D          ; BACK ONTO PREVIO
US LINE IF POSSIBLE
09998  E8AE  4C DC E6           JMP     XXE6DC          ; RESTORE REGISTER
S, SET QUOTE FLAG AND EXIT
09999  E8B1                     
10000  E8B1              XXE8B1 = *
10001  E8B1  C9 13              CMP     #$13               ; COMPARE WITH 
[CLR]
10002  E8B3  D0 06              BNE     XXE8BB          ; BRANCH IF NOT [C
LR]
10003  E8B5                     
10004  E8B5  20 5F E5           JSR     XXE55F          ; CLEAR SCREEN
10005  E8B8              XXE8B8 = *
10006  E8B8  4C DC E6           JMP     XXE6DC          ; RESTORE REGISTER
S, SET QUOTE FLAG AND EXIT
10007  E8BB                     
10008  E8BB              XXE8BB = *
10009  E8BB  09 80              ORA     #$80               ; RESTORE B7, C
OLOUR CAN ONLY BE BLACK, CYAN, MAGENTA
10010  E8BD                                     ; OR YELLOW
10011  E8BD  20 12 E9           JSR     XXE912          ; SET THE COLOUR F
ROM THE CHARACTER IN A
10012  E8C0  4C 30 ED           JMP     XXED30          ;.
10013  E8C3                     
10014  E8C3                     
10015  E8C3              ;************************************************
***********************************;
10016  E8C3              ;
10017  E8C3              ; DO NEWLINE
10018  E8C3              
10019  E8C3              XXE8C3 = *
10020  E8C3  46 C9              LSR     XXC9          ; SHIFT >> INPUT CUR
SOR ROW
10021  E8C5  A6 D6              LDX     XXD6          ; GET CURSOR ROW
10022  E8C7              XXE8C7 = *
10023  E8C7  E8                 INX                    ; INCREMENT ROW
10024  E8C8  E0 17              CPX     #$17               ; COMPARE WITH 
LAST ROW + 1
10025  E8CA  D0 03              BNE     XXE8CF          ; BRANCH IF NOT LA
ST ROW + 1
10026  E8CC                     
10027  E8CC  20 75 E9           JSR     XXE975          ; ELSE SCROLL SCRE
EN
10028  E8CF              XXE8CF = *
10029  E8CF  B5 D9              LDA     XXD9,X          ; GET START OF LIN
E X POINTER HIGH BYTE
10030  E8D1  10 F4              BPL     XXE8C7          ; LOOP IF NOT STAR
T OF LOGICAL LINE
10031  E8D3                     
10032  E8D3  86 D6              STX     XXD6          ; ELSE SAVE CURSOR R
OW
10033  E8D5  4C 87 E5           JMP     XXE587          ; SET SCREEN POINT
ERS FOR CURSOR ROW, COLUMN AND RETURN
10034  E8D8                     
10035  E8D8                     
10036  E8D8              ;************************************************
***********************************;
10037  E8D8              ;
10038  E8D8              ; OUTPUT [CR]
10039  E8D8              
10040  E8D8              XXE8D8 = *
10041  E8D8  A2 00              LDX     #$00               ; CLEAR X
10042  E8DA  86 D8              STX     XXD8          ; CLEAR INSERT COUNT

10043  E8DC  86 C7              STX     XXC7          ; CLEAR REVERSE FLAG

10044  E8DE  86 D4              STX     XXD4          ; CLEAR CURSOR QUOTE
 FLAG, $XX = QUOTE, $00 = NO QUOTE
10045  E8E0  86 D3              STX     XXD3          ; CLEAR CURSOR COLUM
N
10046  E8E2  20 C3 E8           JSR     XXE8C3          ; DO NEWLINE
10047  E8E5  4C DC E6           JMP     XXE6DC          ; RESTORE REGISTER
S, SET QUOTE FLAG AND EXIT
10048  E8E8                     
10049  E8E8                     






****;R......PAGE 0192

LINE# LOC   CODE        LINE


10050  E8E8              ;************************************************
***********************************;
10051  E8E8              ;
10052  E8E8              ; TEST FOR LINE DECREMENT
10053  E8E8              
10054  E8E8              XXE8E8 = *
10055  E8E8  A2 04              LDX     #$04               ; SET COUNT
10056  E8EA  A9 00              LDA     #$00               ; SET COLUMN
10057  E8EC              XXE8EC = *
10058  E8EC  C5 D3              CMP     XXD3          ; COMPARE WITH CURSO
R COLUMN
10059  E8EE  F0 07              BEQ     XXE8F7          ; BRANCH IF AT STA
RT OF LINE
10060  E8F0                     
10061  E8F0  18                 CLC                    ; ELSE CLEAR CARRY 
FOR ADD
10062  E8F1  69 16              ADC     #$16               ; INCREMENT TO 
NEXT LINE
10063  E8F3  CA                 DEX                    ; DECREMENT LOOP CO
UNT
10064  E8F4  D0 F6              BNE     XXE8EC          ; LOOP IF MORE TO 
TEST
10065  E8F6                     
10066  E8F6  60                 RTS
10067  E8F7                     
10068  E8F7              XXE8F7 = *
10069  E8F7  C6 D6              DEC     XXD6          ; ELSE DECREMENT CUR
SOR ROW
10070  E8F9  60                 RTS
10071  E8FA                     
10072  E8FA                     
10073  E8FA              ;************************************************
***********************************;
10074  E8FA              ;
10075  E8FA              ; TEST FOR LINE INCREMENT. IF AT END OF LINE, BUT
 NOT AT END OF LAST LINE, INCREMENT THE
10076  E8FA              ; CURSOR ROW
10077  E8FA              
10078  E8FA              XXE8FA = *
10079  E8FA  A2 04              LDX     #$04               ; SET COUNT
10080  E8FC  A9 15              LDA     #$15               ; SET COLUMN
10081  E8FE              XXE8FE = *
10082  E8FE  C5 D3              CMP     XXD3          ; COMPARE WITH CURSO
R COLUMN
10083  E900  F0 07              BEQ     XXE909          ; IF AT END OF LIN
E TEST AND POSSIBLY INCREMENT CURSOR ROW
10084  E902                     
10085  E902  18                 CLC                    ; ELSE CLEAR CARRY 
FOR ADD
10086  E903  69 16              ADC     #$16               ; INCREMENT TO 
NEXT LINE
10087  E905  CA                 DEX                    ; DECREMENT LOOP CO
UNT
10088  E906  D0 F6              BNE     XXE8FE          ; LOOP IF MORE TO 
TEST
10089  E908                     
10090  E908  60                 RTS
10091  E909                     
10092  E909                                     ; CURSOR IS AT END OF LINE

10093  E909              XXE909 = *
10094  E909  A6 D6              LDX     XXD6          ; GET CURSOR ROW
10095  E90B  E0 17              CPX     #$17               ; COMPARE WITH 
END OF SCREEN
10096  E90D  F0 02              BEQ     XXE911          ; EXIT IF END OF S
CREEN
10097  E90F                     
10098  E90F  E6 D6              INC     XXD6          ; ELSE INCREMENT CUR
SOR ROW
10099  E911              XXE911 = *
10100  E911  60                 RTS
10101  E912                     
10102  E912                     
10103  E912              ;************************************************
***********************************;
10104  E912              ;






****;O......PAGE 0193

LINE# LOC   CODE        LINE


10105  E912              ; SET COLOUR CODE. ENTER WITH THE COLOUR CHARACTE
R IN A. IF A DOES NOT CONTAIN A
10106  E912              ; COLOUR CHARACTER THIS ROUTINE EXITS WITHOUT CHA
NGING THE COLOUR
10107  E912              
10108  E912              XXE912 = *
10109  E912  A2 07              LDX     #XXE928-XXE921
10110  E914                                     ; SET COLOUR CODE COUNT
10111  E914              XXE914 = *
10112  E914  DD 21 E9           CMP     XXE921,X          ; COMPARE THE CH
ARACTER WITH THE TABLE CODE
10113  E917  F0 04              BEQ     XXE91D          ; IF A MATCH GO SA
VE THE COLOUR AND EXIT
10114  E919                     
10115  E919  CA                 DEX                    ; ELSE DECREMENT TH
E INDEX
10116  E91A  10 F8              BPL     XXE914          ; LOOP IF MORE TO 
DO
10117  E91C                     
10118  E91C  60                 RTS
10119  E91D                     
10120  E91D              XXE91D = *
10121  E91D  8E 86 02           STX     XX0286          ; SET CURRENT COLO
UR CODE
10122  E920  60                 RTS
10123  E921                     
10124  E921                     
10125  E921              ;************************************************
***********************************;
10126  E921              ;
10127  E921              ; ASCII COLOUR CODE TABLE
10128  E921                                     ; CHR$()     COLOUR
10129  E921              XXE921                 ; ------     ------
10130  E921  90                 .BYTE     $90               ;  144     BLA
CK
10131  E922  05                 .BYTE     $05               ;    5     WHI
TE
10132  E923  1C                 .BYTE     $1C               ;   28     RED

10133  E924  9F                 .BYTE     $9F               ;  159     CYA
N
10134  E925  9C                 .BYTE     $9C               ;  156     MAG
ENTA
10135  E926  1E                 .BYTE     $1E               ;   30     GRE
EN
10136  E927  1F                 .BYTE     $1F               ;   31     BLU
E
10137  E928              XXE928 = *
10138  E928  9E                 .BYTE     $9E               ;  158     YEL
LOW
10139  E929                     
10140  E929                     
10141  E929              ;************************************************
***********************************;
10142  E929              ;
10143  E929              ; CODE CONVERSION, THESE DON'T SEEM TO BE USED AN
YWHERE
10144  E929              
10145  E929              ;XXE929
10146  E929  EF                 .BYTE     $EF,$A1,$DF,$A6,$E1,$B1,$E2,$B2,
$E3,$B3,$E4,$B4,$E5,$B5,$E6,$B6
10146  E92A  A1 
10146  E92B  DF 
10146  E92C  A6 
10146  E92D  E1 
10146  E92E  B1 
10146  E92F  E2 
10146  E930  B2 
10146  E931  E3 
10146  E932  B3 
10146  E933  E4 
10146  E934  B4 
10146  E935  E5 
10146  E936  B5 






****;O......PAGE 0194

LINE# LOC   CODE        LINE


10146  E937  E6 
10146  E938  B6 
10147  E939  E7                 .BYTE     $E7,$B7,$E8,$B8,$E9,$B9,$FA,$BA,
$FB,$BB,$FC,$BC,$EC,$BD,$FE,$BE
10147  E93A  B7 
10147  E93B  E8 
10147  E93C  B8 
10147  E93D  E9 
10147  E93E  B9 
10147  E93F  FA 
10147  E940  BA 
10147  E941  FB 
10147  E942  BB 
10147  E943  FC 
10147  E944  BC 
10147  E945  EC 
10147  E946  BD 
10147  E947  FE 
10147  E948  BE 
10148  E949  84                 .BYTE     $84,$BF,$F7,$C0,$F8,$DB,$F9,$DD,
$EA,$DE,$5E,$E0,$5B,$E1,$5D,$E2
10148  E94A  BF 
10148  E94B  F7 
10148  E94C  C0 
10148  E94D  F8 
10148  E94E  DB 
10148  E94F  F9 
10148  E950  DD 
10148  E951  EA 
10148  E952  DE 
10148  E953  5E 
10148  E954  E0 
10148  E955  5B 
10148  E956  E1 
10148  E957  5D 
10148  E958  E2 
10149  E959  40                 .BYTE     $40,$B0,$61,$B1,$78,$DB,$79,$DD,
$66,$B6,$77,$C0,$70,$F0,$71,$F1
10149  E95A  B0 
10149  E95B  61 
10149  E95C  B1 
10149  E95D  78 
10149  E95E  DB 
10149  E95F  79 
10149  E960  DD 
10149  E961  66 
10149  E962  B6 
10149  E963  77 
10149  E964  C0 
10149  E965  70 
10149  E966  F0 
10149  E967  71 
10149  E968  F1 
10150  E969  72                 .BYTE     $72,$F2,$73,$F3,$74,$F4,$75,$F5,
$76,$F6,$7D,$FD
10150  E96A  F2 
10150  E96B  73 
10150  E96C  F3 
10150  E96D  74 






****;O......PAGE 0195

LINE# LOC   CODE        LINE


10150  E96E  F4 
10150  E96F  75 
10150  E970  F5 
10150  E971  76 
10150  E972  F6 
10150  E973  7D 
10150  E974  FD 
10151  E975                     
10152  E975                     
10153  E975              ;************************************************
***********************************;
10154  E975              ;
10155  E975              ; SCROLL SCREEN
10156  E975              
10157  E975              XXE975 = *
10158  E975  A5 AC              LDA     XXAC          ; COPY TAPE BUFFER S
TART POINTER
10159  E977  48                 PHA                    ; SAVE IT
10160  E978  A5 AD              LDA     XXAD          ; COPY TAPE BUFFER S
TART POINTER
10161  E97A  48                 PHA                    ; SAVE IT
10162  E97B  A5 AE              LDA     XXAE          ; COPY TAPE BUFFER E
ND POINTER
10163  E97D  48                 PHA                    ; SAVE IT
10164  E97E  A5 AF              LDA     XXAF          ; COPY TAPE BUFFER E
ND POINTER
10165  E980  48                 PHA                    ; SAVE IT
10166  E981              XXE981 = *
10167  E981  A2 FF              LDX     #$FF               ; SET TO -1 FOR
 PRE INCREMENT LOOP
10168  E983  C6 D6              DEC     XXD6          ; DECREMENT CURSOR R
OW
10169  E985  C6 C9              DEC     XXC9          ; DECREMENT INPUT CU
RSOR ROW
10170  E987  C6 F2              DEC     XXF2          ; DECREMENT SCREEN R
OW MARKER
10171  E989              XXE989 = *
10172  E989  E8                 INX                    ; INCREMENT LINE NU
MBER
10173  E98A  20 7E EA           JSR     XXEA7E          ; SET START OF LIN
E X
10174  E98D  E0 16              CPX     #$16               ; COMPARE WITH 
LAST LINE
10175  E98F  B0 0C              BCS     XXE99D          ; BRANCH IF >= $16

10176  E991                     
10177  E991  BD FE ED           LDA     XXEDFD+1,X     ; GET START OF NEXT
 LINE POINTER LOW BYTE
10178  E994  85 AC              STA     XXAC          ; SAVE NEXT LINE POI
NTER LOW BYTE
10179  E996  B5 DA              LDA     XXD9+1,X          ; GET START OF N
EXT LINE POINTER HIGH BYTE
10180  E998  20 56 EA           JSR     XXEA56          ; SHIFT SCREEN LIN
E UP
10181  E99B  30 EC              BMI     XXE989          ; LOOP, BRANCH ALW
AYS
10182  E99D                     
10183  E99D              XXE99D = *
10184  E99D  20 8D EA           JSR     XXEA8D          ; CLEAR SCREEN LIN
E X
10185  E9A0                     
10186  E9A0                                     ; NOW SHIFT UP THE START O
F LOGICAL LINE BITS
10187  E9A0  A2 00              LDX     #$00               ; CLEAR INDEX
10188  E9A2              XXE9A2 = *
10189  E9A2  B5 D9              LDA     XXD9,X          ; GET START OF LIN
E X POINTER HIGH BYTE
10190  E9A4  29 7F              AND     #$7F               ; CLEAR LINE X 
START OF LOGICAL LINE BIT
10191  E9A6  B4 DA              LDY     XXD9+1,X          ; GET START OF N
EXT LINE POINTER HIGH BYTE
10192  E9A8  10 02              BPL     XXE9AC          ; BRANCH IF NEXT L
INE NOT START OF LINE
10193  E9AA                     
10194  E9AA  09 80              ORA     #$80               ; SET LINE X ST
ART OF LOGICAL LINE BIT
10195  E9AC              XXE9AC = *
10196  E9AC  95 D9              STA     XXD9,X          ; SET START OF LIN
E X POINTER HIGH BYTE
10197  E9AE  E8                 INX                    ; INCREMENT LINE NU
MBER
10198  E9AF  E0 16              CPX     #$16               ; COMPARE WITH 
LAST LINE






****;O......PAGE 0196

LINE# LOC   CODE        LINE


10199  E9B1  D0 EF              BNE     XXE9A2          ; LOOP IF NOT LAST
 LINE
10200  E9B3                     
10201  E9B3  A5 EF              LDA     XXD9+$16          ; GET START OF L
AST LINE POINTER HIGH BYTE
10202  E9B5  09 80              ORA     #$80               ; MARK AS START
 OF LOGICAL LINE
10203  E9B7  85 EF              STA     XXD9+$16          ; SET START OF L
AST LINE POINTER HIGH BYTE
10204  E9B9  A5 D9              LDA     XXD9          ; GET START OF FIRST
 LINE POINTER HIGH BYTE
10205  E9BB  10 C4              BPL     XXE981          ; IF NOT START OF 
LOGICAL LINE LOOP BACK AND
10206  E9BD                                     ; SCROLL THE SCREEN UP ANO
THER LINE
10207  E9BD                     
10208  E9BD  E6 D6              INC     XXD6          ; INCREMENT CURSOR R
OW
10209  E9BF  E6 F2              INC     XXF2          ; INCREMENT SCREEN R
OW MARKER
10210  E9C1  A9 FB              LDA     #$FB               ; SET KEYBOARD 
COLUMN C2
10211  E9C3  8D 20 91           STA     XX9120          ; SET VIA 2 DRB, K
EYBOARD COLUMN
10212  E9C6  AD 21 91           LDA     XX9121          ; GET VIA 2 DRA, K
EYBOARD ROW
10213  E9C9  C9 FE              CMP     #$FE               ; COMPARE WITH 
ROW R0 ACTIVE, [CTL]
10214  E9CB  08                 PHP                    ; SAVE STATUS
10215  E9CC  A9 F7              LDA     #$F7               ; SET KEYBOARD 
COLUMN C3
10216  E9CE  8D 20 91           STA     XX9120          ; SET VIA 2 DRB, K
EYBOARD COLUMN
10217  E9D1  28                 PLP                    ; RESTORE STATUS
10218  E9D2  D0 0B              BNE     XXE9DF          ; SKIP DELAY IF ??

10219  E9D4                     
10220  E9D4                                     ; FIRST TIME ROUND THE INN
ER LOOP X WILL BE $16
10221  E9D4  A0 00              LDY     #$00               ; CLEAR DELAY O
UTER LOOP COUNT, DO THIS 256 TIMES
10222  E9D6              XXE9D6 = *
10223  E9D6  EA                 NOP                    ; WASTE CYCLES
10224  E9D7  CA                 DEX                    ; DECREMENT INNER L
OOP COUNT
10225  E9D8  D0 FC              BNE     XXE9D6          ; LOOP IF NOT ALL 
DONE
10226  E9DA                     
10227  E9DA  88                 DEY                    ; DECREMENT OUTER L
OOP COUNT
10228  E9DB  D0 F9              BNE     XXE9D6          ; LOOP IF NOT ALL 
DONE
10229  E9DD                     
10230  E9DD  84 C6              STY     XXC6          ; CLEAR KEYBOARD BUF
FER INDEX
10231  E9DF              XXE9DF = *
10232  E9DF  A6 D6              LDX     XXD6          ; GET CURSOR ROW
10233  E9E1  68                 PLA                    ; PULL TAPE BUFFER 
END POINTER
10234  E9E2  85 AF              STA     XXAF          ; RESTORE IT
10235  E9E4  68                 PLA                    ; PULL TAPE BUFFER 
END POINTER
10236  E9E5  85 AE              STA     XXAE          ; RESTORE IT
10237  E9E7  68                 PLA                    ; PULL TAPE BUFFER 
POINTER
10238  E9E8  85 AD              STA     XXAD          ; RESTORE IT
10239  E9EA  68                 PLA                    ; PULL TAPE BUFFER 
POINTER
10240  E9EB  85 AC              STA     XXAC          ; RESTORE IT
10241  E9ED  60                 RTS
10242  E9EE                     
10243  E9EE                     
10244  E9EE              ;************************************************
***********************************;
10245  E9EE              ;
10246  E9EE              ; OPEN SPACE ON SCREEN
10247  E9EE              
10248  E9EE              XXE9EE = *
10249  E9EE  A6 D6              LDX     XXD6          ; GET CURSOR ROW
10250  E9F0              XXE9F0 = *
10251  E9F0  E8                 INX                    ; INCREMENT ROW
10252  E9F1  B5 D9              LDA     XXD9,X          ; GET START OF LIN
E X POINTER HIGH BYTE
10253  E9F3  10 FB              BPL     XXE9F0          ; BRANCH IF NOT ST
ART OF LOGICAL LINE






****;O......PAGE 0197

LINE# LOC   CODE        LINE


10254  E9F5                     
10255  E9F5  86 F2              STX     XXF2          ; SET SCREEN ROW MAR
KER
10256  E9F7  E0 16              CPX     #$16               ; COMPARE WITH 
LAST LINE
10257  E9F9  F0 0D              BEQ     XXEA08          ; BRANCH IF = LAST
 LINE
10258  E9FB                     
10259  E9FB  90 0B              BCC     XXEA08          ; BRANCH IF < LAST
 LINE
10260  E9FD                     
10261  E9FD                                     ; ELSE WAS > LAST LINE
10262  E9FD  20 75 E9           JSR     XXE975          ; ELSE SCROLL SCRE
EN
10263  EA00  A6 F2              LDX     XXF2          ; GET SCREEN ROW MAR
KER
10264  EA02  CA                 DEX                    ; DECREMENT SCREEN 
ROW MARKER
10265  EA03  C6 D6              DEC     XXD6          ; DECREMENT CURSOR R
OW
10266  EA05  4C 0E E7           JMP     XXE70E          ; ADD THIS ROW TO 
THE CURRENT LOGICAL LINE AND RETURN
10267  EA08                     
10268  EA08              XXEA08 = *
10269  EA08  A5 AC              LDA     XXAC          ; COPY TAPE BUFFER P
OINTER
10270  EA0A  48                 PHA                    ; SAVE IT
10271  EA0B  A5 AD              LDA     XXAD          ; COPY TAPE BUFFER P
OINTER
10272  EA0D  48                 PHA                    ; SAVE IT
10273  EA0E  A5 AE              LDA     XXAE          ; COPY TAPE BUFFER E
ND POINTER
10274  EA10  48                 PHA                    ; SAVE IT
10275  EA11  A5 AF              LDA     XXAF          ; COPY TAPE BUFFER E
ND POINTER
10276  EA13  48                 PHA                    ; SAVE IT
10277  EA14  A2 17              LDX     #$17               ; SET TO END LI
NE + 1 FOR PREDECREMENT LOOP
10278  EA16              XXEA16 = *
10279  EA16  CA                 DEX                    ; DECREMENT LINE NU
MBER
10280  EA17  20 7E EA           JSR     XXEA7E          ; SET START OF LIN
E X
10281  EA1A  E4 F2              CPX     XXF2          ; COMPARE WITH SCREE
N ROW MARKER
10282  EA1C  90 0E              BCC     XXEA2C          ; BRANCH IF < SCRE
EN ROW MARKER
10283  EA1E                     
10284  EA1E  F0 0C              BEQ     XXEA2C          ; BRANCH IF = SCRE
EN ROW MARKER
10285  EA20                     
10286  EA20  BD FC ED           LDA     XXEDFD-1,X     ; ELSE GET START OF
 PREVIOUS LINE LOW BYTE FROM ROM TABLE
10287  EA23  85 AC              STA     XXAC          ; SAVE PREVIOUS LINE
 POINTER LOW BYTE
10288  EA25  B5 D8              LDA     XXD9-1,X          ; GET START OF P
REVIOUS LINE POINTER HIGH BYTE
10289  EA27  20 56 EA           JSR     XXEA56          ; SHIFT SCREEN LIN
E DOWN
10290  EA2A  30 EA              BMI     XXEA16          ; LOOP, BRANCH ALW
AYS
10291  EA2C                     
10292  EA2C              XXEA2C = *
10293  EA2C  20 8D EA           JSR     XXEA8D          ; CLEAR SCREEN LIN
E X
10294  EA2F  A2 15              LDX     #$15               ;.
10295  EA31              XXEA31 = *
10296  EA31  E4 F2              CPX     XXF2          ;.COMPARE WITH SCREE
N ROW MARKER
10297  EA33  90 0F              BCC     XXEA44          ;.
10298  EA35                     
10299  EA35  B5 DA              LDA     XXD9+1,X          ;.
10300  EA37  29 7F              AND     #$7F               ;.
10301  EA39  B4 D9              LDY     XXD9,X          ; GET START OF LIN
E X POINTER HIGH BYTE
10302  EA3B  10 02              BPL     XXEA3F          ;.
10303  EA3D                     
10304  EA3D  09 80              ORA     #$80               ;.
10305  EA3F              XXEA3F = *
10306  EA3F  95 DA              STA     XXD9+1,X          ;.
10307  EA41  CA                 DEX                    ;.
10308  EA42  D0 ED              BNE     XXEA31          ;.






TABLEO......PAGE 0198

LINE# LOC   CODE        LINE


10309  EA44                     
10310  EA44              XXEA44 = *
10311  EA44  A6 F2              LDX     XXF2          ;.GET SCREEN ROW MAR
KER
10312  EA46  20 0E E7           JSR     XXE70E          ; ADD THIS ROW TO 
THE CURRENT LOGICAL LINE
10313  EA49  68                 PLA                    ; PULL TAPE BUFFER 
END POINTER
10314  EA4A  85 AF              STA     XXAF          ; RESTORE IT
10315  EA4C  68                 PLA                    ; PULL TAPE BUFFER 
END POINTER
10316  EA4D  85 AE              STA     XXAE          ; RESTORE IT
10317  EA4F  68                 PLA                    ; PULL TAPE BUFFER 
POINTER
10318  EA50  85 AD              STA     XXAD          ; RESTORE IT
10319  EA52  68                 PLA                    ; PULL TAPE BUFFER 
POINTER
10320  EA53  85 AC              STA     XXAC          ; RESTORE IT
10321  EA55  60                 RTS
10322  EA56                     
10323  EA56                     
10324  EA56              ;************************************************
***********************************;
10325  EA56              ;
10326  EA56              ; SHIFT SCREEN LINE UP/DOWN
10327  EA56              
10328  EA56              XXEA56 = *
10329  EA56  29 03              AND     #$03               ; MASK 0000 00X
X, LINE MEMORY PAGE
10330  EA58  0D 88 02           ORA     XX0288          ; OR WITH SCREEN M
EMORY PAGE
10331  EA5B  85 AD              STA     XXAD          ; SAVE NEXT/PREVIOUS
 LINE POINTER HIGH BYTE
10332  EA5D  20 6E EA           JSR     XXEA6E          ; CALCULATE POINTE
RS TO SCREEN LINES COLOUR RAM
10333  EA60              XXEA60 = *
10334  EA60  A0 15              LDY     #$15               ; SET COLUMN CO
UNT
10335  EA62              XXEA62 = *
10336  EA62  B1 AC              LDA     (XXAC),Y          ; GET CHARACTER 
FROM NEXT/PREVIOUS SCREEN LINE
10337  EA64  91 D1              STA     (XXD1),Y          ; SAVE CHARACTER
 TO CURRENT SCREEN LINE
10338  EA66  B1 AE              LDA     (XXAE),Y          ; GET COLOUR FRO
M NEXT/PREVIOUS SCREEN LINE COLOUR RAM
10339  EA68  91 F3              STA     (XXF3),Y          ; SAVE COLOUR TO
 CURRENT SCREEN LINE COLOUR RAM
10340  EA6A  88                 DEY                    ; DECREMENT COLUMN 
INDEX/COUNT
10341  EA6B  10 F5              BPL     XXEA62          ; LOOP IF MORE TO 
DO
10342  EA6D                     
10343  EA6D  60                 RTS
10344  EA6E                     
10345  EA6E                     
10346  EA6E              ;************************************************
***********************************;
10347  EA6E              ;
10348  EA6E              ; CALCULATE POINTERS TO SCREEN LINES COLOUR RAM
10349  EA6E              
10350  EA6E              XXEA6E = *
10351  EA6E  20 B2 EA           JSR     XXEAB2          ; CALCULATE POINTE
R TO CURRENT SCREEN LINE COLOUR RAM
10352  EA71  A5 AC              LDA     XXAC          ; GET NEXT SCREEN LI
NE POINTER LOW BYTE
10353  EA73  85 AE              STA     XXAE          ; SAVE NEXT SCREEN L
INE COLOUR RAM POINTER LOW BYTE
10354  EA75  A5 AD              LDA     XXAD          ; GET NEXT SCREEN LI
NE POINTER HIGH BYTE
10355  EA77  29 03              AND     #$03               ; MASK 0000 00X
X, LINE MEMORY PAGE
10356  EA79  09 94              ORA     #$94               ; SET  1001 01X
X, COLOUR MEMORY PAGE
10357  EA7B  85 AF              STA     XXAF          ; SAVE NEXT SCREEN L
INE COLOUR RAM POINTER HIGH BYTE
10358  EA7D  60                 RTS
10359  EA7E                     
10360  EA7E                     
10361  EA7E              ;************************************************
***********************************;
10362  EA7E              ;
10363  EA7E              ; SET START OF LINE X






****;O......PAGE 0199

LINE# LOC   CODE        LINE


10364  EA7E              
10365  EA7E              XXEA7E = *
10366  EA7E  BD FD ED           LDA     XXEDFD,X          ; GET START OF L
INE LOW BYTE FROM ROM TABLE
10367  EA81  85 D1              STA     XXD1          ; SET CURRENT SCREEN
 LINE POINTER LOW BYTE
10368  EA83  B5 D9              LDA     XXD9,X          ; GET START OF LIN
E HIGH BYTE FROM RAM TABLE
10369  EA85  29 03              AND     #$03               ; MASK 0000 00X
X, LINE MEMORY PAGE
10370  EA87  0D 88 02           ORA     XX0288          ; OR WITH SCREEN M
EMORY PAGE
10371  EA8A  85 D2              STA     XXD2          ; SET CURRENT SCREEN
 LINE POINTER HIGH BYTE
10372  EA8C  60                 RTS
10373  EA8D                     
10374  EA8D                     
10375  EA8D              ;************************************************
***********************************;
10376  EA8D              ;
10377  EA8D              ; CLEAR SCREEN LINE X
10378  EA8D              
10379  EA8D              XXEA8D = *
10380  EA8D  A0 15              LDY     #$15               ; SET NUMBER OF
 COLUMNS TO CLEAR
10381  EA8F  20 7E EA           JSR     XXEA7E          ; SET START OF LIN
E X
10382  EA92  20 B2 EA           JSR     XXEAB2          ; CALCULATE POINTE
R TO COLOUR RAM
10383  EA95              XXEA95 = *
10384  EA95  A9 20              LDA     #' '               ; SET [SPACE]
10385  EA97  91 D1              STA     (XXD1),Y          ; CLEAR CHARACTE
R IN CURRENT SCREEN LINE
10386  EA99  A9 01              LDA     #$01               ; SET COLOUR, B
LUE ON WHITE
10387  EA9B  91 F3              STA     (XXF3),Y          ; SET COLOUR RAM
 IN CURRENT SCREEN LINE
10388  EA9D  88                 DEY                    ; DECREMENT INDEX
10389  EA9E  10 F5              BPL     XXEA95          ; LOOP IF MORE TO 
DO
10390  EAA0                     
10391  EAA0  60                 RTS
10392  EAA1                     
10393  EAA1                     
10394  EAA1              ;************************************************
***********************************;
10395  EAA1              ;
10396  EAA1              ; PRINT CHARACTER A AND COLOUR X TO SCREEN
10397  EAA1              
10398  EAA1              XXEAA1 = *
10399  EAA1  A8                 TAY                    ; COPY CHARACTER
10400  EAA2  A9 02              LDA     #$02               ; SET COUNT TO 
$02, USUALLY $14 ??
10401  EAA4  85 CD              STA     XXCD          ; SET CURSOR COUNTDO
WN
10402  EAA6  20 B2 EA           JSR     XXEAB2          ; CALCULATE POINTE
R TO COLOUR RAM
10403  EAA9  98                 TYA                    ; GET CHARACTER BAC
K
10404  EAAA                     
10405  EAAA              ; SAVE CHARACTER AND COLOUR TO SCREEN @ CURSOR
10406  EAAA              
10407  EAAA              XXEAAA = *
10408  EAAA  A4 D3              LDY     XXD3          ; GET CURSOR COLUMN
10409  EAAC  91 D1              STA     (XXD1),Y          ; SAVE CHARACTER
 FROM CURRENT SCREEN LINE
10410  EAAE  8A                 TXA                    ; COPY COLOUR TO A
10411  EAAF  91 F3              STA     (XXF3),Y          ; SAVE TO COLOUR
 RAM
10412  EAB1  60                 RTS
10413  EAB2                     
10414  EAB2                     
10415  EAB2              ;************************************************
***********************************;
10416  EAB2              ;
10417  EAB2              ; CALCULATE POINTER TO COLOUR RAM
10418  EAB2              






****;O......PAGE 0200

LINE# LOC   CODE        LINE


10419  EAB2              XXEAB2 = *
10420  EAB2  A5 D1              LDA     XXD1          ; GET CURRENT SCREEN
 LINE POINTER LOW BYTE
10421  EAB4  85 F3              STA     XXF3          ; SAVE POINTER TO CO
LOUR RAM LOW BYTE
10422  EAB6  A5 D2              LDA     XXD2          ; GET CURRENT SCREEN
 LINE POINTER HIGH BYTE
10423  EAB8  29 03              AND     #$03               ; MASK 0000 00X
X, LINE MEMORY PAGE
10424  EABA  09 94              ORA     #$94               ; SET  1001 01X
X, COLOUR MEMORY PAGE
10425  EABC  85 F4              STA     XXF4          ; SAVE POINTER TO CO
LOUR RAM HIGH BYTE
10426  EABE  60                 RTS
10427  EABF                     
10428  EABF                     
10429  EABF              ;************************************************
***********************************;
10430  EABF              ;
10431  EABF              ; UPDATE THE CLOCK, FLASH THE CURSOR, CONTROL THE
 CASSETTE AND SCAN THE KEYBOARD
10432  EABF              
10433  EABF              ; IRQ HANDLER
10434  EABF              
10435  EABF              XXEABF = *
10436  EABF  20 EA FF           JSR     XXFFEA          ; INCREMENT REAL T
IME CLOCK
10437  EAC2  A5 CC              LDA     XXCC          ; GET CURSOR ENABLE
10438  EAC4  D0 29              BNE     XXEAEF          ; BRANCH IF NOT FL
ASH CURSOR
10439  EAC6                     
10440  EAC6  C6 CD              DEC     XXCD          ; ELSE DECREMENT CUR
SOR TIMING COUNTDOWN
10441  EAC8  D0 25              BNE     XXEAEF          ; BRANCH IF NOT DO
NE
10442  EACA                     
10443  EACA  A9 14              LDA     #$14               ; SET COUNT
10444  EACC  85 CD              STA     XXCD          ; SAVE CURSOR TIMING
 COUNTDOWN
10445  EACE  A4 D3              LDY     XXD3          ; GET CURSOR COLUMN
10446  EAD0  46 CF              LSR     XXCF          ; SHIFT B0 CURSOR BL
INK PHASE INTO CARRY
10447  EAD2  AE 87 02           LDX     XX0287          ; GET COLOUR UNDER
 CURSOR
10448  EAD5  B1 D1              LDA     (XXD1),Y          ; GET CHARACTER 
FROM CURRENT SCREEN LINE
10449  EAD7  B0 11              BCS     XXEAEA          ; BRANCH IF CURSOR
 PHASE B0 WAS 1
10450  EAD9                     
10451  EAD9  E6 CF              INC     XXCF          ; SET CURSOR BLINK P
HASE TO 1
10452  EADB  85 CE              STA     XXCE          ; SAVE CHARACTER UND
ER CURSOR
10453  EADD  20 B2 EA           JSR     XXEAB2          ; CALCULATE POINTE
R TO COLOUR RAM
10454  EAE0  B1 F3              LDA     (XXF3),Y          ; GET COLOUR RAM
 BYTE
10455  EAE2  8D 87 02           STA     XX0287          ; SAVE COLOUR UNDE
R CURSOR
10456  EAE5  AE 86 02           LDX     XX0286          ; GET CURRENT COLO
UR CODE
10457  EAE8  A5 CE              LDA     XXCE          ; GET CHARACTER UNDE
R CURSOR
10458  EAEA              XXEAEA = *
10459  EAEA  49 80              EOR     #$80               ; TOGGLE B7 OF 
CHARACTER UNDER CURSOR
10460  EAEC  20 AA EA           JSR     XXEAAA          ; SAVE CHARACTER A
ND COLOUR TO SCREEN @ CURSOR
10461  EAEF              XXEAEF = *
10462  EAEF  AD 1F 91           LDA     XX911F          ; GET VIA 1 DRA, N
O HANDSHAKE
10463  EAF2  29 40              AND     #$40               ; MASK CASSETTE
 SWITCH SENSE
10464  EAF4  F0 0B              BEQ     XXEB01          ; BRANCH IF CASSET
TE SENSE LOW
10465  EAF6                     
10466  EAF6                                     ; CASSETTE SENSE WAS HIGH 
SO TURN OFF MOTOR AND CLEAR
10467  EAF6                                     ; THE INTERLOCK
10468  EAF6  A0 00              LDY     #$00               ; CLEAR Y
10469  EAF8  84 C0              STY     XXC0          ; CLEAR THE TAPE MOT
OR INTERLOCK
10470  EAFA  AD 1C 91           LDA     XX911C          ; GET VIA 1 PCR
10471  EAFD  09 02              ORA     #$02               ; SET CA2 HIGH,
 TURN OFF MOTOR
10472  EAFF  D0 09              BNE     XXEB0A          ; BRANCH ALWAYS
10473  EB01                     






****;O......PAGE 0201

LINE# LOC   CODE        LINE


10474  EB01                                     ; CASSETTE SENSE WAS LOW S
O TURN ON MOTOR, PERHAPS
10475  EB01              XXEB01 = *
10476  EB01  A5 C0              LDA     XXC0          ; GET TAPE MOTOR INT
ERLOCK
10477  EB03  D0 0D              BNE     XXEB12          ; IF CASSETTE INTE
RLOCK <> 0 DON'T TURN ON MOTOR
10478  EB05                     
10479  EB05  AD 1C 91           LDA     XX911C          ; GET VIA 1 PCR
10480  EB08  29 FD              AND     #$FD               ; SET CA2 LOW, 
TURN ON MOTOR
10481  EB0A              XXEB0A = *
10482  EB0A  2C 1E 91           BIT     XX911E          ; TEST VIA 1 IER
10483  EB0D  70 03              BVS     XXEB12          ; IF T1 INTERRUPT 
ENABLED DON'T CHANGE MOTOR STATE
10484  EB0F                     
10485  EB0F  8D 1C 91           STA     XX911C          ; SET VIA 1 PCR, S
ET CA2 HIGH/LOW
10486  EB12              XXEB12 = *
10487  EB12  20 1E EB           JSR     XXEB1E          ; SCAN KEYBOARD
10488  EB15  2C 24 91           BIT     XX9124          ; TEST VIA 2 T1C_L
, CLEAR THE TIMER INTERRUPT FLAG
10489  EB18  68                 PLA                    ; PULL Y
10490  EB19  A8                 TAY                    ; RESTORE Y
10491  EB1A  68                 PLA                    ; PULL X
10492  EB1B  AA                 TAX                    ; RESTORE X
10493  EB1C  68                 PLA                    ; RESTORE A
10494  EB1D  40                 RTI
10495  EB1E                     
10496  EB1E                     
10497  EB1E              ;************************************************
***********************************;
10498  EB1E              ;
10499  EB1E              ; SCAN KEYBOARD PERFORMS THE FOLLOWING ..
10500  EB1E              ;
10501  EB1E              ; 1)     CHECK IF KEY PRESSED, IF NOT THEN EXIT T
HE ROUTINE
10502  EB1E              ;
10503  EB1E              ; 2)     INIT I/O PORTS OF VIA 2 FOR KEYBOARD SCA
N AND SET POINTERS TO DECODE TABLE 1.
10504  EB1E              ;     CLEAR THE CHARACTER COUNTER
10505  EB1E              ;
10506  EB1E              ; 3)     SET ONE LINE OF PORT B LOW AND TEST FOR 
A CLOSED KEY ON PORT A BY SHIFTING THE
10507  EB1E              ;     BYTE READ FROM THE PORT. IF THE CARRY IS CL
EAR THEN A KEY IS CLOSED SO SAVE THE
10508  EB1E              ;     COUNT WHICH IS INCREMENTED ON EACH SHIFT. C
HECK FOR SHIFT/STOP/CBM KEYS AND
10509  EB1E              ;     FLAG IF CLOSED
10510  EB1E              ;
10511  EB1E              ; 4)     REPEAT STEP 3 FOR THE WHOLE MATRIX
10512  EB1E              ;
10513  EB1E              ; 5)     EVALUATE THE SHIFT/CTRL/C= KEYS, THIS MA
Y CHANGE THE DECODE TABLE SELECTED
10514  EB1E              ;
10515  EB1E              ; 6)     USE THE KEY COUNT SAVED IN STEP 3 AS AN 
INDEX INTO THE TABLE SELECTED IN STEP 5
10516  EB1E              ;
10517  EB1E              ; 7)     CHECK FOR KEY REPEAT OPERATION
10518  EB1E              ;
10519  EB1E              ; 8)     SAVE THE DECODED KEY TO THE BUFFER IF FI
RST PRESS OR REPEAT
10520  EB1E              
10521  EB1E              ; SCAN KEYBOARD
10522  EB1E              
10523  EB1E              ; THIS ROUTINE WILL SCAN THE KEYBOARD AND CHECK F
OR PRESSED KEYS. IT IS THE SAME
10524  EB1E              ; ROUTINE CALLED BY THE INTERRUPT HANDLER. IF A K
EY IS DOWN, ITS ASCII VALUE IS
10525  EB1E              ; PLACED IN THE KEYBOARD QUEUE.
10526  EB1E              
10527  EB1E              XXEB1E = *
10528  EB1E  A9 00              LDA     #$00               ; CLEAR A






N STEP......PAGE 0202

LINE# LOC   CODE        LINE


10529  EB20  8D 8D 02           STA     XX028D          ; CLEAR KEYBOARD S
HIFT/CONTROL/C= FLAG
10530  EB23  A0 40              LDY     #$40               ; SET NO KEY
10531  EB25  84 CB              STY     XXCB          ; SAVE WHICH KEY
10532  EB27  8D 20 91           STA     XX9120          ; CLEAR VIA 2 DRB,
 KEYBOARD COLUMN
10533  EB2A  AE 21 91           LDX     XX9121          ; GET VIA 2 DRA, K
EYBOARD ROW
10534  EB2D  E0 FF              CPX     #$FF               ; COMPARE WITH 
ALL BITS SET
10535  EB2F  F0 5E              BEQ     XXEB8F          ; IF NO KEY PRESSE
D CLEAR CURRENT KEY AND EXIT (DOES
10536  EB31                                     ; FURTHER BEQ TO XXEBBA)
10537  EB31                     
10538  EB31  A9 FE              LDA     #$FE               ; SET COLUMN 0 
LOW
10539  EB33  8D 20 91           STA     XX9120          ; SET VIA 2 DRB, K
EYBOARD COLUMN
10540  EB36  A0 00              LDY     #$00               ; CLEAR KEY COU
NT
10541  EB38  A9 5E              LDA     #<XXEC5E          ; GET DECODE TAB
LE LOW BYTE
10542  EB3A  85 F5              STA     XXF5          ; SET KEYBOARD POINT
ER LOW BYTE
10543  EB3C  A9 EC              LDA     #>XXEC5E          ; GET DECODE TAB
LE HIGH BYTE
10544  EB3E  85 F6              STA     XXF6          ; SET KEYBOARD POINT
ER HIGH BYTE
10545  EB40              XXEB40 = *
10546  EB40  A2 08              LDX     #$08               ; SET ROW COUNT

10547  EB42  AD 21 91           LDA     XX9121          ; GET VIA 2 DRA, K
EYBOARD ROW
10548  EB45  CD 21 91           CMP     XX9121          ; COMPARE WITH ITS
ELF
10549  EB48  D0 F6              BNE     XXEB40          ; LOOP IF CHANGING

10550  EB4A                     
10551  EB4A              XXEB4A = *
10552  EB4A  4A                 LSR A                  ; SHIFT ROW TO CB
10553  EB4B  B0 16              BCS     XXEB63          ; IF NO KEY CLOSED
 ON THIS ROW GO DO NEXT ROW
10554  EB4D                     
10555  EB4D  48                 PHA                    ; SAVE ROW
10556  EB4E  B1 F5              LDA     (XXF5),Y          ; GET CHARACTER 
FROM DECODE TABLE
10557  EB50  C9 05              CMP     #$05               ; COMPARE WITH 
$05, THERE IS NO $05 KEY BUT THE CONTROL
10558  EB52                                     ; KEYS ARE ALL LESS THAN $
05
10559  EB52  B0 0C              BCS     XXEB60          ; IF NOT SHIFT/CON
TROL/C=/STOP GO SAVE KEY COUNT
10560  EB54                     
10561  EB54                                     ; ELSE WAS SHIFT/CONTROL/C
=/STOP KEY
10562  EB54  C9 03              CMP     #$03               ; COMPARE WITH 
$03, STOP
10563  EB56  F0 08              BEQ     XXEB60          ; IF STOP GO SAVE 
KEY COUNT AND CONTINUE
10564  EB58                     
10565  EB58                                     ; CHARACTER IS $01 - SHIFT
, $02 - C= OR $04 - CONTROL
10566  EB58  0D 8D 02           ORA     XX028D          ; OR KEYBOARD SHIF
T/CONTROL/C= FLAG
10567  EB5B  8D 8D 02           STA     XX028D          ; SAVE KEYBOARD SH
IFT/CONTROL/C= FLAG
10568  EB5E  10 02              BPL     XXEB62          ; SKIP SAVE KEY, B
RANCH ALWAYS
10569  EB60                     
10570  EB60              XXEB60 = *
10571  EB60  84 CB              STY     XXCB          ; SAVE KEY COUNT
10572  EB62              XXEB62 = *
10573  EB62  68                 PLA                    ; RESTORE ROW
10574  EB63              XXEB63 = *
10575  EB63  C8                 INY                    ; INCREMENT KEY COU
NT
10576  EB64  C0 41              CPY     #$41               ; COMPARE WITH 
MAX+1
10577  EB66  B0 09              BCS     XXEB71          ; EXIT LOOP IF >= 
MAX+1
10578  EB68                     
10579  EB68                                     ; ELSE STILL IN MATRIX
10580  EB68  CA                 DEX                    ; DECREMENT ROW COU
NT
10581  EB69  D0 DF              BNE     XXEB4A          ; LOOP IF MORE ROW
S TO DO
10582  EB6B                     
10583  EB6B  38                 SEC                    ; SET CARRY FOR KEY
BOARD COLUMN SHIFT






CONTRO......PAGE 0203

LINE# LOC   CODE        LINE


10584  EB6C  2E 20 91           ROL     XX9120          ; SHIFT VIA 2 DRB,
 KEYBOARD COLUMN
10585  EB6F  D0 CF              BNE     XXEB40          ; LOOP FOR NEXT CO
LUMN, BRANCH ALWAYS
10586  EB71                     
10587  EB71              XXEB71 = *
10588  EB71  6C 8F 02           JMP     (XX028F)          ; EVALUATE THE S
HIFT/CTRL/C= KEYS, XXEBDC
10589  EB74                     
10590  EB74              ; KEY DECODING CONTINUES HERE AFTER THE SHIFT/CTR
L/C= KEYS ARE EVALUATED
10591  EB74              
10592  EB74              XXEB74 = *
10593  EB74  A4 CB              LDY     XXCB          ; GET SAVED KEY COUN
T
10594  EB76  B1 F5              LDA     (XXF5),Y          ; GET CHARACTER 
FROM DECODE TABLE
10595  EB78  AA                 TAX                    ; COPY CHARACTER TO
 X
10596  EB79  C4 C5              CPY     XXC5          ; COMPARE KEY COUNT 
WITH LAST KEY COUNT
10597  EB7B  F0 07              BEQ     XXEB84          ; IF THIS KEY = CU
RRENT KEY, KEY HELD, GO TEST REPEAT
10598  EB7D                     
10599  EB7D  A0 10              LDY     #$10               ; SET REPEAT DE
LAY COUNT
10600  EB7F  8C 8C 02           STY     XX028C          ; SAVE REPEAT DELA
Y COUNT
10601  EB82  D0 36              BNE     XXEBBA          ; GO SAVE KEY TO B
UFFER AND EXIT, BRANCH ALWAYS
10602  EB84                     
10603  EB84              XXEB84 = *
10604  EB84  29 7F              AND     #$7F               ; CLEAR B7
10605  EB86  2C 8A 02           BIT     XX028A          ; TEST KEY REPEAT
10606  EB89  30 16              BMI     XXEBA1          ; BRANCH IF REPEAT
 ALL
10607  EB8B                     
10608  EB8B  70 49              BVS     XXEBD6          ; BRANCH IF REPEAT
 NONE
10609  EB8D                     
10610  EB8D  C9 7F              CMP     #$7F               ; COMPARE WITH 
END MARKER
10611  EB8F              XXEB8F = *
10612  EB8F  F0 29              BEQ     XXEBBA          ; IF $00/END MARKE
R GO SAVE KEY TO BUFFER AND EXIT
10613  EB91                     
10614  EB91  C9 14              CMP     #$14               ; COMPARE WITH 
[INSERT]/[DELETE]
10615  EB93  F0 0C              BEQ     XXEBA1          ; IF [INSERT]/[DEL
ETE] GO TEST FOR REPEAT
10616  EB95                     
10617  EB95  C9 20              CMP     #' '               ; COMPARE WITH 
[SPACE]
10618  EB97  F0 08              BEQ     XXEBA1          ; IF [SPACE] GO TE
ST FOR REPEAT
10619  EB99                     
10620  EB99  C9 1D              CMP     #$1D               ; COMPARE WITH 
[CURSOR RIGHT]
10621  EB9B  F0 04              BEQ     XXEBA1          ; IF [CURSOR RIGHT
] GO TEST FOR REPEAT
10622  EB9D                     
10623  EB9D  C9 11              CMP     #$11               ; COMPARE WITH 
[CURSOR DOWN]
10624  EB9F  D0 35              BNE     XXEBD6          ; IF NOT [CURSOR D
OWN] JUST EXIT
10625  EBA1                     
10626  EBA1                                     ; WAS ONE OF THE CURSOR MO
VEMENT KEYS, INSERT/DELETE
10627  EBA1                                     ; KEY OR THE SPACE BAR SO 
ALWAYS DO REPEAT TESTS
10628  EBA1              XXEBA1 = *
10629  EBA1  AC 8C 02           LDY     XX028C          ; GET REPEAT DELAY
 COUNTER
10630  EBA4  F0 05              BEQ     XXEBAB          ; BRANCH IF DELAY 
EXPIRED
10631  EBA6                     
10632  EBA6  CE 8C 02           DEC     XX028C          ; ELSE DECREMENT R
EPEAT DELAY COUNTER
10633  EBA9  D0 2B              BNE     XXEBD6          ; BRANCH IF DELAY 
NOT EXPIRED
10634  EBAB                     
10635  EBAB                                     ; REPEAT DELAY COUNTER HAS
 EXPIRED
10636  EBAB              XXEBAB = *
10637  EBAB  CE 8B 02           DEC     XX028B          ; DECREMENT REPEAT
 SPEED COUNTER
10638  EBAE  D0 26              BNE     XXEBD6          ; BRANCH IF REPEAT
 SPEED COUNT NOT EXPIRED






ATNTRO......PAGE 0204

LINE# LOC   CODE        LINE


10639  EBB0                     
10640  EBB0  A0 04              LDY     #$04               ; SET FOR 4/60T
HS OF A SECOND
10641  EBB2  8C 8B 02           STY     XX028B          ; SET REPEAT SPEED
 COUNTER
10642  EBB5  A4 C6              LDY     XXC6          ; GET KEYBOARD BUFFE
R INDEX
10643  EBB7  88                 DEY                    ; DECREMENT IT
10644  EBB8  10 1C              BPL     XXEBD6          ; IF THE BUFFER IS
N'T EMPTY JUST EXIT
10645  EBBA                     
10646  EBBA                                     ; ELSE REPEAT THE KEY IMME
DIATELY
10647  EBBA                     
10648  EBBA              ; POSSIBLY SAVE THE KEY TO THE KEYBOARD BUFFER. I
F THERE WAS NO KEY PRESSED OR THE KEY
10649  EBBA              ; WAS NOT FOUND DURING THE SCAN (POSSIBLY DUE TO 
KEY BOUNCE) THEN X WILL BE $FF HERE
10650  EBBA              
10651  EBBA              XXEBBA = *
10652  EBBA  A4 CB              LDY     XXCB          ; GET THE KEY COUNT
10653  EBBC  84 C5              STY     XXC5          ; SAVE AS THE CURREN
T KEY COUNT
10654  EBBE  AC 8D 02           LDY     XX028D          ; GET KEYBOARD SHI
FT/CONTROL/C= FLAG
10655  EBC1  8C 8E 02           STY     XX028E          ; SAVE AS LAST KEY
BOARD SHIFT PATTERN
10656  EBC4  E0 FF              CPX     #$FF               ; COMPARE CHARA
CTER WITH TABLE END MARKER OR NO KEY
10657  EBC6  F0 0E              BEQ     XXEBD6          ; IF TABLE END MAR
KER OR NO KEY JUST EXIT
10658  EBC8                     
10659  EBC8  8A                 TXA                    ; COPY CHARACTER TO
 A
10660  EBC9  A6 C6              LDX     XXC6          ; GET KEYBOARD BUFFE
R INDEX
10661  EBCB  EC 89 02           CPX     XX0289          ; COMPARE WITH KEY
BOARD BUFFER SIZE
10662  EBCE  B0 06              BCS     XXEBD6          ; IF BUFFER FULL J
UST EXIT
10663  EBD0                     
10664  EBD0  9D 77 02           STA     XX0277,X          ; SAVE CHARACTER
 TO KEYBOARD BUFFER
10665  EBD3  E8                 INX                    ; INCREMENT INDEX
10666  EBD4  86 C6              STX     XXC6          ; SAVE KEYBOARD BUFF
ER INDEX
10667  EBD6              XXEBD6 = *
10668  EBD6  A9 F7              LDA     #$F7               ; ENABLE COLUMN
 3 FOR STOP KEY
10669  EBD8  8D 20 91           STA     XX9120          ; SET VIA 2 DRB, K
EYBOARD COLUMN
10670  EBDB  60                 RTS
10671  EBDC                     
10672  EBDC              ; EVALUATE SHIFT/CTRL/C= KEYS
10673  EBDC              ;
10674  EBDC              ; 0     $00     EC5E
10675  EBDC              ; 1     $02     EC9F
10676  EBDC              ; 2     $04     ECE0
10677  EBDC              ; 3     ..     ....
10678  EBDC              ; 4     $06     EDA3
10679  EBDC              ; 5     $06     EDA3
10680  EBDC              ; 6     $06     EDA3
10681  EBDC              ; 7     $06     EDA3
10682  EBDC              
10683  EBDC              XXEBDC = *
10684  EBDC  AD 8D 02           LDA     XX028D          ; GET KEYBOARD SHI
FT/CONTROL/C= FLAG
10685  EBDF  C9 03              CMP     #$03               ; COMPARE WITH 
[SHIFT][C=]
10686  EBE1  D0 2C              BNE     XXEC0F          ; BRANCH IF NOT [S
HIFT][C=]
10687  EBE3                     
10688  EBE3  CD 8E 02           CMP     XX028E          ; COMPARE WITH LAS
T
10689  EBE6  F0 EE              BEQ     XXEBD6          ; EXIT IF STILL TH
E SAME
10690  EBE8                     
10691  EBE8  AD 91 02           LDA     XX0291          ; GET SHIFT MODE S
WITCH $00 = ENABLED, $80 = LOCKED
10692  EBEB  30 56              BMI     XXEC43          ; IF LOCKED CONTIN
UE KEYBOARD DECODE
10693  EBED                     






KEYEEY......PAGE 0205

LINE# LOC   CODE        LINE


10694  EBED  EA                 NOP                    ; JUST A FEW WASTED
 CYCLES
10695  EBEE  EA                 NOP                    ;
10696  EBEF  EA                 NOP                    ;
10697  EBF0  EA                 NOP                    ;
10698  EBF1  EA                 NOP                    ;
10699  EBF2  EA                 NOP                    ;
10700  EBF3  EA                 NOP                    ;
10701  EBF4  EA                 NOP                    ;
10702  EBF5  EA                 NOP                    ;
10703  EBF6  EA                 NOP                    ;
10704  EBF7  EA                 NOP                    ;
10705  EBF8  EA                 NOP                    ;
10706  EBF9  EA                 NOP                    ;
10707  EBFA  EA                 NOP                    ;
10708  EBFB  EA                 NOP                    ;
10709  EBFC  EA                 NOP                    ;
10710  EBFD  EA                 NOP                    ;
10711  EBFE  EA                 NOP                    ;
10712  EBFF  EA                 NOP                    ;
10713  EC00                     
10714  EC00                                     ; TOGGLE TEXT MODE
10715  EC00  AD 05 90           LDA     XX9005          ; GET START OF CHA
RACTER MEMORY, ROM
10716  EC03  49 02              EOR     #$02               ; TOGGLE $8000,
$8800
10717  EC05  8D 05 90           STA     XX9005          ; SET START OF CHA
RACTER MEMORY, ROM
10718  EC08  EA                 NOP                    ;
10719  EC09  EA                 NOP                    ;
10720  EC0A  EA                 NOP                    ;
10721  EC0B  EA                 NOP                    ;
10722  EC0C  4C 43 EC           JMP     XXEC43          ; CONTINUE KEYBOAR
D DECODE
10723  EC0F                     
10724  EC0F                                     ; WAS NOT [SHIFT][C=] BUT 
COULD BE ANY OTHER COMBINATION
10725  EC0F              XXEC0F = *
10726  EC0F  0A                 ASL A                  ; << 1
10727  EC10  C9 08              CMP     #$08               ; COMPARE WITH 
[CTRL]
10728  EC12  90 04              BCC     XXEC18          ; BRANCH IF NOT [C
TRL] PRESSED
10729  EC14                     
10730  EC14  A9 06              LDA     #$06               ; ELSE [CTRL] W
AS PRESSED SO MAKE INDEX = $06
10731  EC16  EA                 NOP                    ;
10732  EC17  EA                 NOP                    ;
10733  EC18              XXEC18 = *
10734  EC18  EA                 NOP                    ; JUST A FEW WASTED
 CYCLES
10735  EC19  EA                 NOP                    ;
10736  EC1A  EA                 NOP                    ;
10737  EC1B  EA                 NOP                    ;
10738  EC1C  EA                 NOP                    ;
10739  EC1D  EA                 NOP                    ;
10740  EC1E  EA                 NOP                    ;
10741  EC1F  EA                 NOP                    ;
10742  EC20  EA                 NOP                    ;
10743  EC21  EA                 NOP                    ;
10744  EC22  EA                 NOP                    ;
10745  EC23  EA                 NOP                    ;
10746  EC24  EA                 NOP                    ;
10747  EC25  EA                 NOP                    ;
10748  EC26  EA                 NOP                    ;






NEYEEY......PAGE 0206

LINE# LOC   CODE        LINE


10749  EC27  EA                 NOP                    ;
10750  EC28  EA                 NOP                    ;
10751  EC29  EA                 NOP                    ;
10752  EC2A  EA                 NOP                    ;
10753  EC2B  EA                 NOP                    ;
10754  EC2C  EA                 NOP                    ;
10755  EC2D  EA                 NOP                    ;
10756  EC2E  EA                 NOP                    ;
10757  EC2F  EA                 NOP                    ;
10758  EC30  EA                 NOP                    ;
10759  EC31  EA                 NOP                    ;
10760  EC32  EA                 NOP                    ;
10761  EC33  EA                 NOP                    ;
10762  EC34  EA                 NOP                    ;
10763  EC35  EA                 NOP                    ;
10764  EC36  EA                 NOP                    ;
10765  EC37  EA                 NOP                    ;
10766  EC38  AA                 TAX                    ; COPY INDEX TO X
10767  EC39  BD 46 EC           LDA     XXEC46,X          ; GET DECODE TAB
LE POINTER LOW BYTE
10768  EC3C  85 F5              STA     XXF5          ; SAVE DECODE TABLE 
POINTER LOW BYTE
10769  EC3E  BD 47 EC           LDA     XXEC46+1,X     ; GET DECODE TABLE 
POINTER HIGH BYTE
10770  EC41  85 F6              STA     XXF6          ; SAVE DECODE TABLE 
POINTER HIGH BYTE
10771  EC43              XXEC43 = *
10772  EC43  4C 74 EB           JMP     XXEB74          ; CONTINUE KEYBOAR
D DECODE
10773  EC46                     
10774  EC46                     
10775  EC46              ;************************************************
***********************************;
10776  EC46              ;
10777  EC46              ; KEYBOARD DECODE TABLE POINTERS
10778  EC46              
10779  EC46              XXEC46 = *
10780  EC46  5E EC              .WORD     XXEC5E          ; UNSHIFTED
10781  EC48  9F EC              .WORD     XXEC9F          ; SHIFTED
10782  EC4A  E0 EC              .WORD     XXECE0          ; COMMODORE
10783  EC4C  A3 ED              .WORD     XXEDA3          ; CONTROL
10784  EC4E  5E EC              .WORD     XXEC5E          ; UNSHIFTED
10785  EC50  9F EC              .WORD     XXEC9F          ; SHIFTED
10786  EC52  69 ED              .WORD     XXED69          ; SHFITED
10787  EC54  A3 ED              .WORD     XXEDA3          ; CONTROL
10788  EC56  21 ED              .WORD     XXED21          ; GRAPHICS/TEXT 
CONTROL
10789  EC58  69 ED              .WORD     XXED69          ; SHIFTED
10790  EC5A  69 ED              .WORD     XXED69          ; SHIFTED
10791  EC5C  A3 ED              .WORD     XXEDA3          ; CONTROL
10792  EC5E                     
10793  EC5E              ; KEYBOARD DECODE TABLE - UNSHIFTED
10794  EC5E              
10795  EC5E              XXEC5E = *
10796  EC5E  31                 .BYTE     $31,$33,$35,$37,$39,$2B,$5C,$14
10796  EC5F  33 
10796  EC60  35 
10796  EC61  37 
10796  EC62  39 
10796  EC63  2B 
10796  EC64  5C 
10796  EC65  14 






****;Y......PAGE 0207

LINE# LOC   CODE        LINE


10797  EC66  5F                 .BYTE     $5F,$57,$52,$59,$49,$50,$2A,$0D
10797  EC67  57 
10797  EC68  52 
10797  EC69  59 
10797  EC6A  49 
10797  EC6B  50 
10797  EC6C  2A 
10797  EC6D  0D 
10798  EC6E  04                 .BYTE     $04,$41,$44,$47,$4A,$4C,$3B,$1D
10798  EC6F  41 
10798  EC70  44 
10798  EC71  47 
10798  EC72  4A 
10798  EC73  4C 
10798  EC74  3B 
10798  EC75  1D 
10799  EC76  03                 .BYTE     $03,$01,$58,$56,$4E,$2C,$2F,$11
10799  EC77  01 
10799  EC78  58 
10799  EC79  56 
10799  EC7A  4E 
10799  EC7B  2C 
10799  EC7C  2F 
10799  EC7D  11 
10800  EC7E  20                 .BYTE     $20,$5A,$43,$42,$4D,$2E,$01,$85
10800  EC7F  5A 
10800  EC80  43 
10800  EC81  42 
10800  EC82  4D 
10800  EC83  2E 
10800  EC84  01 
10800  EC85  85 
10801  EC86  02                 .BYTE     $02,$53,$46,$48,$4B,$3A,$3D,$86
10801  EC87  53 
10801  EC88  46 
10801  EC89  48 
10801  EC8A  4B 
10801  EC8B  3A 
10801  EC8C  3D 
10801  EC8D  86 
10802  EC8E  51                 .BYTE     $51,$45,$54,$55,$4F,$40,$5E,$87
10802  EC8F  45 
10802  EC90  54 
10802  EC91  55 
10802  EC92  4F 
10802  EC93  40 
10802  EC94  5E 
10802  EC95  87 
10803  EC96  32                 .BYTE     $32,$34,$36,$38,$30,$2D,$13,$88
10803  EC97  34 
10803  EC98  36 
10803  EC99  38 
10803  EC9A  30 
10803  EC9B  2D 
10803  EC9C  13 






****;Y......PAGE 0208

LINE# LOC   CODE        LINE


10803  EC9D  88 
10804  EC9E  FF                 .BYTE     $FF
10805  EC9F                     
10806  EC9F              ; KEYBOARD DECODE TABLE - SHIFTED
10807  EC9F              
10808  EC9F              XXEC9F = *
10809  EC9F  21                 .BYTE     $21,$23,$25,$27,$29,$DB,$A9,$94
10809  ECA0  23 
10809  ECA1  25 
10809  ECA2  27 
10809  ECA3  29 
10809  ECA4  DB 
10809  ECA5  A9 
10809  ECA6  94 
10810  ECA7  5F                 .BYTE     $5F,$D7,$D2,$D9,$C9,$D0,$C0,$8D
10810  ECA8  D7 
10810  ECA9  D2 
10810  ECAA  D9 
10810  ECAB  C9 
10810  ECAC  D0 
10810  ECAD  C0 
10810  ECAE  8D 
10811  ECAF  04                 .BYTE     $04,$C1,$C4,$C7,$CA,$CC,$5D,$9D
10811  ECB0  C1 
10811  ECB1  C4 
10811  ECB2  C7 
10811  ECB3  CA 
10811  ECB4  CC 
10811  ECB5  5D 
10811  ECB6  9D 
10812  ECB7  83                 .BYTE     $83,$01,$D8,$D6,$CE,$3C,$3F,$91
10812  ECB8  01 
10812  ECB9  D8 
10812  ECBA  D6 
10812  ECBB  CE 
10812  ECBC  3C 
10812  ECBD  3F 
10812  ECBE  91 
10813  ECBF  A0                 .BYTE     $A0,$DA,$C3,$C2,$CD,$3E,$01,$89
10813  ECC0  DA 
10813  ECC1  C3 
10813  ECC2  C2 
10813  ECC3  CD 
10813  ECC4  3E 
10813  ECC5  01 
10813  ECC6  89 
10814  ECC7  02                 .BYTE     $02,$D3,$C6,$C8,$CB,$5B,$3D,$8A
10814  ECC8  D3 
10814  ECC9  C6 
10814  ECCA  C8 
10814  ECCB  CB 
10814  ECCC  5B 
10814  ECCD  3D 
10814  ECCE  8A 
10815  ECCF  D1                 .BYTE     $D1,$C5,$D4,$D5,$CF,$BA,$DE,$8B






****;Y......PAGE 0209

LINE# LOC   CODE        LINE


10815  ECD0  C5 
10815  ECD1  D4 
10815  ECD2  D5 
10815  ECD3  CF 
10815  ECD4  BA 
10815  ECD5  DE 
10815  ECD6  8B 
10816  ECD7  22                 .BYTE     $22,$24,$26,$28,$30,$DD,$93,$8C
10816  ECD8  24 
10816  ECD9  26 
10816  ECDA  28 
10816  ECDB  30 
10816  ECDC  DD 
10816  ECDD  93 
10816  ECDE  8C 
10817  ECDF  FF                 .BYTE     $FF
10818  ECE0                     
10819  ECE0              ; KEYBOARD DECODE TABLE - COMMODORE
10820  ECE0              
10821  ECE0              XXECE0 = *
10822  ECE0  21                 .BYTE     $21,$23,$25,$27,$29,$A6,$A8,$94
10822  ECE1  23 
10822  ECE2  25 
10822  ECE3  27 
10822  ECE4  29 
10822  ECE5  A6 
10822  ECE6  A8 
10822  ECE7  94 
10823  ECE8  5F                 .BYTE     $5F,$B3,$B2,$B7,$A2,$AF,$DF,$8D
10823  ECE9  B3 
10823  ECEA  B2 
10823  ECEB  B7 
10823  ECEC  A2 
10823  ECED  AF 
10823  ECEE  DF 
10823  ECEF  8D 
10824  ECF0  04                 .BYTE     $04,$B0,$AC,$A5,$B5,$B6,$5D,$9D
10824  ECF1  B0 
10824  ECF2  AC 
10824  ECF3  A5 
10824  ECF4  B5 
10824  ECF5  B6 
10824  ECF6  5D 
10824  ECF7  9D 
10825  ECF8  83                 .BYTE     $83,$01,$BD,$BE,$AA,$3C,$3F,$91
10825  ECF9  01 
10825  ECFA  BD 
10825  ECFB  BE 
10825  ECFC  AA 
10825  ECFD  3C 
10825  ECFE  3F 
10825  ECFF  91 
10826  ED00  A0                 .BYTE     $A0,$AD,$BC,$BF,$A7,$3E,$01,$89
10826  ED01  AD 
10826  ED02  BC 






****;Y......PAGE 0210

LINE# LOC   CODE        LINE


10826  ED03  BF 
10826  ED04  A7 
10826  ED05  3E 
10826  ED06  01 
10826  ED07  89 
10827  ED08  02                 .BYTE     $02,$AE,$BB,$B4,$A1,$5B,$3D,$8A
10827  ED09  AE 
10827  ED0A  BB 
10827  ED0B  B4 
10827  ED0C  A1 
10827  ED0D  5B 
10827  ED0E  3D 
10827  ED0F  8A 
10828  ED10  AB                 .BYTE     $AB,$B1,$A3,$B8,$B9,$A4,$DE,$8B
10828  ED11  B1 
10828  ED12  A3 
10828  ED13  B8 
10828  ED14  B9 
10828  ED15  A4 
10828  ED16  DE 
10828  ED17  8B 
10829  ED18  22                 .BYTE     $22,$24,$26,$28,$30,$DC,$93,$8C
10829  ED19  24 
10829  ED1A  26 
10829  ED1B  28 
10829  ED1C  30 
10829  ED1D  DC 
10829  ED1E  93 
10829  ED1F  8C 
10830  ED20  FF                 .BYTE     $FF
10831  ED21                     
10832  ED21                     
10833  ED21              ;************************************************
***********************************;
10834  ED21              ;
10835  ED21              ;## GRAPHICS/TEXT CONTROL
10836  ED21              
10837  ED21              XXED21 = *
10838  ED21  C9 0E              CMP     #$0E               ; COMPARE WITH 
[SWITCH TO LOWER CASE]
10839  ED23  D0 0B              BNE     XXED30          ; BRANCH IF NOT [S
WITCH TO LOWER CASE]
10840  ED25                     
10841  ED25  A9 02              LDA     #$02               ; SET FOR $8800
, LOWER CASE CHARACTERS
10842  ED27  0D 05 90           ORA     XX9005          ; OR WITH START OF
 CHARACTER MEMORY, ROM
10843  ED2A  8D 05 90           STA     XX9005          ; SAVE START OF CH
ARACTER MEMORY, ROM
10844  ED2D  4C DC E6           JMP     XXE6DC          ; RESTORE REGISTER
S, SET QUOTE FLAG AND EXIT
10845  ED30                     
10846  ED30              XXED30 = *
10847  ED30  C9 8E              CMP     #$8E               ; COMPARE WITH 
[SWITCH TO UPPER CASE]
10848  ED32  D0 0B              BNE     XXED3F          ; BRANCH IF NOT [S
WITCH TO UPPER CASE]
10849  ED34                     
10850  ED34  A9 FD              LDA     #$FD               ; SET FOR $8000
, UPPER CASE CHARACTERS
10851  ED36  2D 05 90           AND     XX9005          ; AND WITH START O
F CHARACTER MEMORY, ROM
10852  ED39  8D 05 90           STA     XX9005          ; SAVE START OF CH
ARACTER MEMORY, ROM
10853  ED3C                     
10854  ED3C              XXED3C = *
10855  ED3C  4C DC E6           JMP     XXE6DC          ; RESTORE REGISTER
S, SET QUOTE FLAG AND EXIT






****;Y......PAGE 0211

LINE# LOC   CODE        LINE


10856  ED3F                     
10857  ED3F              XXED3F = *
10858  ED3F  C9 08              CMP     #$08               ; COMPARE WITH 
DISABLE [SHIFT][C=]
10859  ED41  D0 0A              BNE     XXED4D          ; BRANCH IF NOT DI
SABLE [SHIFT][C=]
10860  ED43                     
10861  ED43  A9 80              LDA     #$80               ; SET TO LOCK S
HIFT MODE SWITCH
10862  ED45  0D 91 02           ORA     XX0291          ; OR WITH SHIFT MO
DE SWITCH, $00 = ENABLED, $80 = LOCKED
10863  ED48  8D 91 02           STA     XX0291          ; SAVE SHIFT MODE 
SWITCH
10864  ED4B  30 EF              BMI     XXED3C          ; BRANCH ALWAYS
10865  ED4D                     
10866  ED4D              XXED4D = *
10867  ED4D  C9 09              CMP     #$09               ; COMPARE WITH 
ENABLE [SHIFT][C=]
10868  ED4F  D0 EB              BNE     XXED3C          ; EXIT IF NOT ENAB
LE [SHIFT][C=]
10869  ED51                     
10870  ED51  A9 7F              LDA     #$7F               ; SET TO UNLOCK
 SHIFT MODE SWITCH
10871  ED53  2D 91 02           AND     XX0291          ; AND WITH SHIFT M
ODE SWITCH, $00 = ENABLED, $80 = LOCKED
10872  ED56  8D 91 02           STA     XX0291          ; SAVE SHIFT MODE 
SWITCH
10873  ED59  10 E1              BPL     XXED3C          ; BRANCH ALWAYS
10874  ED5B                     
10875  ED5B              ; MAKE NEXT SCREEN LINE START OF LOGICAL LINE, IN
CREMENT LINE LENGTH AND SET POINTERS
10876  ED5B              
10877  ED5B              XXED5B = *
10878  ED5B  E8                 INX                    ; INCREMENT SCREEN 
ROW
10879  ED5C  B5 D9              LDA     XXD9,X          ; GET START OF LIN
E X POINTER HIGH BYTE
10880  ED5E  09 80              ORA     #$80               ; MARK AS START
 OF LOGICAL LINE
10881  ED60  95 D9              STA     XXD9,X          ; SET START OF LIN
E X POINTER HIGH BYTE
10882  ED62  CA                 DEX                    ; RESTORE SCREEN RO
W
10883  ED63  A5 D5              LDA     XXD5          ; GET CURRENT SCREEN
 LINE LENGTH
10884  ED65  18                 CLC                    ; CLEAR CARRY FOR A
DD
10885  ED66  4C 15 E7           JMP     XXE715          ; ADD ONE LINE LEN
GTH, SET POINTERS FOR START OF LINE AND
10886  ED69                                     ; RETURN
10887  ED69                     
10888  ED69                     
10889  ED69              ;************************************************
***********************************;
10890  ED69              ;
10891  ED69              ; KEYBOARD DECODE TABLE - SHIFTED
10892  ED69              
10893  ED69              XXED69 = *
10894  ED69  FF                 .BYTE     $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
10894  ED6A  FF 
10894  ED6B  FF 
10894  ED6C  FF 
10894  ED6D  FF 
10894  ED6E  FF 
10894  ED6F  FF 
10894  ED70  FF 
10895  ED71  FF                 .BYTE     $FF,$04,$FF,$FF,$FF,$FF,$FF,$E2
10895  ED72  04 
10895  ED73  FF 
10895  ED74  FF 
10895  ED75  FF 
10895  ED76  FF 
10895  ED77  FF 
10895  ED78  E2 
10896  ED79  9D                 .BYTE     $9D,$83,$01,$FF,$FF,$FF,$FF,$FF






****;D......PAGE 0212

LINE# LOC   CODE        LINE


10896  ED7A  83 
10896  ED7B  01 
10896  ED7C  FF 
10896  ED7D  FF 
10896  ED7E  FF 
10896  ED7F  FF 
10896  ED80  FF 
10897  ED81  91                 .BYTE     $91,$A0,$FF,$FF,$FF,$FF,$EE,$01
10897  ED82  A0 
10897  ED83  FF 
10897  ED84  FF 
10897  ED85  FF 
10897  ED86  FF 
10897  ED87  EE 
10897  ED88  01 
10898  ED89  89                 .BYTE     $89,$02,$FF,$FF,$FF,$FF,$E1,$FD
10898  ED8A  02 
10898  ED8B  FF 
10898  ED8C  FF 
10898  ED8D  FF 
10898  ED8E  FF 
10898  ED8F  E1 
10898  ED90  FD 
10899  ED91  8A                 .BYTE     $8A,$FF,$FF,$FF,$FF,$FF,$B0,$E0
10899  ED92  FF 
10899  ED93  FF 
10899  ED94  FF 
10899  ED95  FF 
10899  ED96  FF 
10899  ED97  B0 
10899  ED98  E0 
10900  ED99  8B                 .BYTE     $8B,$F2,$F4,$F6,$FF,$F0,$ED,$93
10900  ED9A  F2 
10900  ED9B  F4 
10900  ED9C  F6 
10900  ED9D  FF 
10900  ED9E  F0 
10900  ED9F  ED 
10900  EDA0  93 
10901  EDA1  8C                 .BYTE     $8C,$FF
10901  EDA2  FF 
10902  EDA3                     
10903  EDA3              ; KEYBOARD DECODE TABLE - CONTROL
10904  EDA3              
10905  EDA3              XXEDA3 = *
10906  EDA3  90                 .BYTE     $90,$1C,$9C,$1F,$12,$FF,$FF,$FF
10906  EDA4  1C 
10906  EDA5  9C 
10906  EDA6  1F 
10906  EDA7  12 
10906  EDA8  FF 
10906  EDA9  FF 
10906  EDAA  FF 
10907  EDAB  06                 .BYTE     $06,$FF,$12,$FF,$FF,$FF,$FF,$FF
10907  EDAC  FF 






****;D......PAGE 0213

LINE# LOC   CODE        LINE


10907  EDAD  12 
10907  EDAE  FF 
10907  EDAF  FF 
10907  EDB0  FF 
10907  EDB1  FF 
10907  EDB2  FF 
10908  EDB3  FF                 .BYTE     $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
10908  EDB4  FF 
10908  EDB5  FF 
10908  EDB6  FF 
10908  EDB7  FF 
10908  EDB8  FF 
10908  EDB9  FF 
10908  EDBA  FF 
10909  EDBB  FF                 .BYTE     $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
10909  EDBC  FF 
10909  EDBD  FF 
10909  EDBE  FF 
10909  EDBF  FF 
10909  EDC0  FF 
10909  EDC1  FF 
10909  EDC2  FF 
10910  EDC3  FF                 .BYTE     $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
10910  EDC4  FF 
10910  EDC5  FF 
10910  EDC6  FF 
10910  EDC7  FF 
10910  EDC8  FF 
10910  EDC9  FF 
10910  EDCA  FF 
10911  EDCB  FF                 .BYTE     $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
10911  EDCC  FF 
10911  EDCD  FF 
10911  EDCE  FF 
10911  EDCF  FF 
10911  EDD0  FF 
10911  EDD1  FF 
10911  EDD2  FF 
10912  EDD3  FF                 .BYTE     $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
10912  EDD4  FF 
10912  EDD5  FF 
10912  EDD6  FF 
10912  EDD7  FF 
10912  EDD8  FF 
10912  EDD9  FF 
10912  EDDA  FF 
10913  EDDB  05                 .BYTE     $05,$9F,$1E,$9E,$92,$FF,$FF,$FF
10913  EDDC  9F 
10913  EDDD  1E 
10913  EDDE  9E 
10913  EDDF  92 
10913  EDE0  FF 
10913  EDE1  FF 
10913  EDE2  FF 
10914  EDE3  FF                 .BYTE     $FF






****;D......PAGE 0214

LINE# LOC   CODE        LINE


10915  EDE4                     
10916  EDE4                     
10917  EDE4              ;************************************************
***********************************;
10918  EDE4              ;
10919  EDE4              ; INITIAL VALUES FOR VIC REGISTERS
10920  EDE4              
10921  EDE4              XXEDE4 = *
10922  EDE4  0C                 .BYTE     $0C               ; INTERLACE AN
D HORIZONTAL CENTER [PAL]
10923  EDE5              ;     .BYTE     $05               ; INTERLACE AND
 HORIZONTAL CENTER [NTSC]
10924  EDE5                                     ; BIT     FUNCTION
10925  EDE5                                     ; ---     --------
10926  EDE5                                     ;  7     INTERLACE / NON I
NTERLACE
10927  EDE5                                     ; 6-0     HORIZONTAL ORIGI
N
10928  EDE5  26                 .BYTE     $26               ; VERTICAL ORI
GIN [PAL]
10929  EDE6              ;     .BYTE     $19               ; VERTICAL ORIG
IN [NTSC]
10930  EDE6  16                 .BYTE     $16               ; VIDEO ADDRES
S AND COLUMS, $9400 FOR COLOUR RAM
10931  EDE7                                     ; BIT     FUNCTION
10932  EDE7                                     ; ---     --------
10933  EDE7                                     ;  7     VIDEO ADDRESS VA9

10934  EDE7                                     ; 6-0     NUMBER OF COLUMN
S
10935  EDE7  2E                 .BYTE     $2E               ; ROWS AND CHA
RACTER SIZE
10936  EDE8                                     ; BIT     FUNCTION
10937  EDE8                                     ; ---     --------
10938  EDE8                                     ;  7     B9 RASTER LINE
10939  EDE8                                     ; 6-1     NUMBER OF ROWS
10940  EDE8                                     ;  0     8X16 / 8X8 CHARAC
TERS
10941  EDE8  00                 .BYTE     $00               ; RASTER LINE
10942  EDE9  C0                 .BYTE     $C0               ; VIDEO MEMORY
 ADDRESSES, RAM $1000, ROM $8000
10943  EDEA                                     ; BIT     FUNCTION
10944  EDEA                                     ; ---     --------
10945  EDEA                                     ;  7     MUST BE 1
10946  EDEA                                     ; 6-4     VIDEO MEMORY ADD
RESS VA12-VA10
10947  EDEA                                     ; 3-0     CHARACTER MEMORY
 START ADDRESS
10948  EDEA                     
10949  EDEA                                     ; 0000 ROM     $8000     S
ET 1 - WE USE THIS
10950  EDEA                                     ; 0001  '     $8400
10951  EDEA                                     ; 0010  '     $8800 SET 2
10952  EDEA                                     ; 0011  '     $8C00
10953  EDEA                                     ; 1100 RAM     $1000
10954  EDEA                                     ; 1101  '     $1400
10955  EDEA                                     ; 1110  '     $1800
10956  EDEA                                     ; 1111  '     $1C00
10957  EDEA                     
10958  EDEA  00                 .BYTE     $00               ; LIGHT PEN HO
RIZONTAL POSITION
10959  EDEB  00                 .BYTE     $00               ; LIGHT PEN VE
RTICAL POSITION
10960  EDEC                     
10961  EDEC  00                 .BYTE     $00               ; PADDLE X
10962  EDED  00                 .BYTE     $00               ; PADDLE Y
10963  EDEE  00                 .BYTE     $00               ; OSCILLATOR 1
 FREQUENCY
10964  EDEF  00                 .BYTE     $00               ; OSCILLATOR 2
 FREQUENCY
10965  EDF0  00                 .BYTE     $00               ; OSCILLATOR 3
 FREQUENCY
10966  EDF1  00                 .BYTE     $00               ; NOISE SOURCE
 FREQUENCY
10967  EDF2  00                 .BYTE     $00               ; AUX COLOUR A
ND VOLUME
10968  EDF3                                     ; BIT     FUNCTION
10969  EDF3                                     ; ---     --------






M***;D......PAGE 0215

LINE# LOC   CODE        LINE


10970  EDF3                                     ; 7-4     AUXILIARY COLOUR
 INFORMATION
10971  EDF3                                     ; 3-0     VOLUME
10972  EDF3  1B                 .BYTE     $1B               ; SCREEN AND B
ORDER COLOUR
10973  EDF4                                     ; BIT     FUNCTION
10974  EDF4                                     ; ---     --------
10975  EDF4                                     ; 7-4     BACKGROUND COLOU
R
10976  EDF4                                     ;  3     INVERTED OR NORMA
L MODE
10977  EDF4                                     ; 2-0     BORDER COLOUR
10978  EDF4                     
10979  EDF4                     
10980  EDF4              ;************************************************
***********************************;
10981  EDF4              ;
10982  EDF4              ; KEYBOARD BUFFER FOR AUTO LOAD/RUN
10983  EDF4              
10984  EDF4              XXEDF4 = *
10985  EDF4  4C 4F              .BYTE     'LOAD',$0D,'RUN',$0D
10985  EDF8  0D 
10985  EDF9  52 55 4E 
10985  EDFC  0D 
10986  EDFD                     
10987  EDFD                     
10988  EDFD              ;************************************************
***********************************;
10989  EDFD              ;
10990  EDFD              ; LOW BYTE SCREEN LINE ADDRESSES
10991  EDFD              
10992  EDFD              XXEDFD = *
10993  EDFD  00                 .BYTE     $00,$16,$2C,$42
10993  EDFE  16 
10993  EDFF  2C 
10993  EE00  42 
10994  EE01  58                 .BYTE     $58,$6E,$84,$9A
10994  EE02  6E 
10994  EE03  84 
10994  EE04  9A 
10995  EE05  B0                 .BYTE     $B0,$C6,$DC,$F2
10995  EE06  C6 
10995  EE07  DC 
10995  EE08  F2 
10996  EE09  08                 .BYTE     $08,$1E,$34,$4A
10996  EE0A  1E 
10996  EE0B  34 
10996  EE0C  4A 
10997  EE0D  60                 .BYTE     $60,$76,$8C,$A2
10997  EE0E  76 
10997  EE0F  8C 
10997  EE10  A2 
10998  EE11  B8                 .BYTE     $B8,$CE,$E4
10998  EE12  CE 
10998  EE13  E4 
10999  EE14                     
11000  EE14                     
11001  EE14              ;************************************************
***********************************;
11002  EE14              ;
11003  EE14              ; COMMAND A SERIAL BUS DEVICE TO TALK
11004  EE14              






****;D......PAGE 0216

LINE# LOC   CODE        LINE


11005  EE14              ; TO USE THIS ROUTINE THE ACCUMULATOR MUST FIRST 
BE LOADED WITH A DEVICE NUMBER
11006  EE14              ; BETWEEN 4 AND 30. WHEN CALLED THIS ROUTINE CONV
ERTS THIS DEVICE NUMBER TO A TALK
11007  EE14              ; ADDRESS. THEN THIS DATA IS TRANSMITTED AS A COM
MAND ON THE SERIAL BUS.
11008  EE14              
11009  EE14              XXEE14 = *
11010  EE14  09 40              ORA     #$40               ; OR WITH THE T
ALK COMMAND
11011  EE16  2C                 .BYTE     $2C               ; MAKES NEXT L
INE BIT XX2009
11012  EE17                     
11013  EE17                     
11014  EE17              ;************************************************
***********************************;
11015  EE17              ;
11016  EE17              ; COMMAND DEVICES ON THE SERIAL BUS TO LISTEN
11017  EE17              
11018  EE17              ; THIS ROUTINE WILL COMMAND A DEVICE ON THE SERIA
L BUS TO RECEIVE DATA. THE
11019  EE17              ; ACCUMULATOR MUST BE LOADED WITH A DEVICE NUMBER
 BETWEEN 4 AND 31 BEFORE CALLING
11020  EE17              ; THIS ROUTINE. LISTEN CONVERT THIS TO A LISTEN A
DDRESS THEN TRANSMIT THIS DATA AS
11021  EE17              ; A COMMAND ON THE SERIAL BUS. THE SPECIFIED DEVI
CE WILL THEN GO INTO LISTEN MODE
11022  EE17              ; AND BE READY TO ACCEPT INFORMATION.
11023  EE17              
11024  EE17              XXEE17 = *
11025  EE17  09 20              ORA     #$20               ; OR WITH THE L
ISTEN COMMAND
11026  EE19  20 60 F1           JSR     XXF160          ; CHECK RS232 BUS 
IDLE
11027  EE1C                     
11028  EE1C                     
11029  EE1C              ;************************************************
***********************************;
11030  EE1C              ;
11031  EE1C              ; SEND CONTROL CHARACTER
11032  EE1C              
11033  EE1C              XXEE1C = *
11034  EE1C  48                 PHA                    ; SAVE DEVICE ADDRE
SS
11035  EE1D  24 94              BIT     XX94          ; TEST DEFERRED CHAR
ACTER FLAG
11036  EE1F  10 0A              BPL     XXEE2B          ; BRANCH IF NO DEF
ERED CHARACTER
11037  EE21                     
11038  EE21  38                 SEC                    ; FLAG EOI
11039  EE22  66 A3              ROR     XXA3          ; ROTATE INTO EOI FL
AG BYTE
11040  EE24  20 49 EE           JSR     XXEE49          ; TX BYTE ON SERIA
L BUS
11041  EE27  46 94              LSR     XX94          ; CLEAR DEFERRED CHA
RACTER FLAG
11042  EE29  46 A3              LSR     XXA3          ; CLEAR EOI FLAG
11043  EE2B              XXEE2B = *
11044  EE2B  68                 PLA                    ; RESTORE DEVICE AD
DRESS
11045  EE2C  85 95              STA     XX95          ; SAVE AS SERIAL DEF
ERED CHARACTER
11046  EE2E  20 A0 E4           JSR     XXE4A0          ; SET SERIAL DATA 
OUT HIGH
11047  EE31  C9 3F              CMP     #$3F               ; COMPARE READ 
BYTE WITH $3F
11048  EE33  D0 03              BNE     XXEE38          ; BRANCH IF NOT $3
F, THIS BRANCH WILL ALWAYS BE TAKEN AS
11049  EE35                                     ; AFTER VIA 2'S PCR IS REA
D IT IS ANDED WITH $DF, SO THE
11050  EE35                                     ; RESULT CAN NEVER BE $3F
11051  EE35                     
11052  EE35  20 84 EF           JSR     XXEF84          ; SET SERIAL CLOCK
 HIGH
11053  EE38              XXEE38 = *
11054  EE38  AD 1F 91           LDA     XX911F          ; GET VIA 1 DRA, N
O HANDSHAKE
11055  EE3B  09 80              ORA     #$80               ; SET SERIAL AT
N LOW
11056  EE3D  8D 1F 91           STA     XX911F          ; SET VIA 1 DRA, N
O HANDSHAKE
11057  EE40                     
11058  EE40                     
11059  EE40              ;************************************************
***********************************;






****;D......PAGE 0217

LINE# LOC   CODE        LINE


11060  EE40              ;
11061  EE40              ; IF THE CODE DROPS THROUGH TO HERE THE SERIAL CL
OCK IS LOW AND THE SERIAL DATA HAS BEEN
11062  EE40              ; RELEASED SO THE FOLLOWING CODE WILL HAVE NO EFF
ECT APART FROM DELAYING THE FIRST BYTE
11063  EE40              ; BY 1MS
11064  EE40              
11065  EE40              ;## SET CLK/DATA, WAIT AND TX BYTE ON SERIAL BUS
11066  EE40              
11067  EE40              XXEE40 = *
11068  EE40  20 8D EF           JSR     XXEF8D          ; SET SERIAL CLOCK
 LOW
11069  EE43  20 A0 E4           JSR     XXE4A0          ; SET SERIAL DATA 
OUT HIGH
11070  EE46  20 96 EF           JSR     XXEF96          ; 1MS DELAY
11071  EE49                     
11072  EE49                     
11073  EE49              ;************************************************
***********************************;
11074  EE49              ;
11075  EE49              ; TX BYTE ON SERIAL BUS
11076  EE49              
11077  EE49              XXEE49 = *
11078  EE49  78                 SEI                    ; DISABLE INTERRUPT
S
11079  EE4A  20 A0 E4           JSR     XXE4A0          ; SET SERIAL DATA 
OUT HIGH
11080  EE4D  20 B2 E4           JSR     XXE4B2          ; GET SERIAL CLOCK
 STATUS
11081  EE50  4A                 LSR A                  ; SHIFT SERIAL DATA
 TO CB
11082  EE51  B0 61              BCS     XXEEB4          ; IF DATA HIGH DO 
DEVICE NOT PRESENT
11083  EE53                     
11084  EE53  20 84 EF           JSR     XXEF84          ; SET SERIAL CLOCK
 HIGH
11085  EE56  24 A3              BIT     XXA3          ; TEST EOI FLAG
11086  EE58  10 0C              BPL     XXEE66          ; BRANCH IF NOT EO
I
11087  EE5A                     
11088  EE5A              ; I THINK THIS IS THE EOI SEQUENCE SO THE SERIAL 
CLOCK HAS BEEN RELEASED AND THE SERIAL
11089  EE5A              ; DATA IS BEING HELD LOW BY THE PERIPHERALS. FIRS
T UP WAIT FOR THE SERIAL DATA TO RISE
11090  EE5A              
11091  EE5A              XXEE5A = *
11092  EE5A  20 B2 E4           JSR     XXE4B2          ; GET SERIAL CLOCK
 STATUS
11093  EE5D  4A                 LSR A                  ; SHIFT SERIAL DATA
 TO CB
11094  EE5E  90 FA              BCC     XXEE5A          ; LOOP IF DATA LOW

11095  EE60                     
11096  EE60              ; NOW THE DATA IS HIGH, EOI IS SIGNALLED BY WAITI
NG FOR AT LEAST 200US WITHOUT PULLING
11097  EE60              ; THE SERIAL CLOCK LINE LOW AGAIN. THE LISTENER S
HOULD RESPOND BY PULLING THE SERIAL
11098  EE60              ; DATA LINE LOW
11099  EE60              
11100  EE60              XXEE60 = *
11101  EE60  20 B2 E4           JSR     XXE4B2          ; GET SERIAL CLOCK
 STATUS
11102  EE63  4A                 LSR A                  ; SHIFT SERIAL DATA
 TO CB
11103  EE64  B0 FA              BCS     XXEE60          ; LOOP IF DATA HIG
H
11104  EE66                     
11105  EE66              ; THE SERIAL DATA HAS GONE LOW ENDING THE EOI SEQ
UENCE, NOW JUST WAIT FOR THE SERIAL
11106  EE66              ; DATA LINE TO GO HIGH AGAIN OR, IF THIS ISN'T AN
 EOI SEQUENCE, JUST WAIT FOR THE SERIAL
11107  EE66              ; DATA TO GO HIGH THE FIRST TIME
11108  EE66              
11109  EE66              XXEE66 = *
11110  EE66  20 B2 E4           JSR     XXE4B2          ; GET SERIAL CLOCK
 STATUS
11111  EE69  4A                 LSR A                  ; SHIFT SERIAL DATA
 TO CB
11112  EE6A  90 FA              BCC     XXEE66          ; LOOP IF DATA LOW

11113  EE6C                     
11114  EE6C              ; SERIAL DATA IS HIGH NOW PULL THE CLOCK LOW, PRE
FERABLY WITHIN 60US






E SERI......PAGE 0218

LINE# LOC   CODE        LINE


11115  EE6C              
11116  EE6C  20 8D EF           JSR     XXEF8D          ; SET SERIAL CLOCK
 LOW
11117  EE6F                     
11118  EE6F              ; NOW THE VIC HAS TO SEND THE EIGHT BITS, LSB FIR
ST. FIRST IT SETS THE SERIAL DATA LINE
11119  EE6F              ; TO REFLECT THE BIT IN THE BYTE, THEN IT SETS TH
E SERIAL CLOCK TO HIGH. THE SERIAL
11120  EE6F              ; CLOCK IS LEFT HIGH FOR 26 CYCLES, 23US ON A PAL
 VIC, BEFORE IT IS AGAIN PULLED LOW
11121  EE6F              ; AND THE SERIAL DATA IS ALLOWED HIGH AGAIN
11122  EE6F              
11123  EE6F  A9 08              LDA     #$08               ; EIGHT BITS TO
 DO
11124  EE71  85 A5              STA     XXA5          ; SET SERIAL BUS BIT
 COUNT
11125  EE73              XXEE73 = *
11126  EE73  AD 1F 91           LDA     XX911F          ; GET VIA 1 DRA, N
O HANDSHAKE
11127  EE76  CD 1F 91           CMP     XX911F          ; COMPARE WITH SEL
F
11128  EE79  D0 F8              BNE     XXEE73          ; LOOP IF CHANGING

11129  EE7B                     
11130  EE7B  4A                 LSR A                  ; SERIAL CLOCK TO C
ARRY
11131  EE7C  4A                 LSR A                  ; SERIAL DATA TO CA
RRY
11132  EE7D  90 38              BCC     XXEEB7          ; IF DATA LOW DO T
IMEOUT ON SERIAL BUS
11133  EE7F                     
11134  EE7F  66 95              ROR     XX95          ; ROTATE TRANSMIT BY
TE
11135  EE81  B0 05              BCS     XXEE88          ; BRANCH IF BIT = 
1
11136  EE83                     
11137  EE83  20 A9 E4           JSR     XXE4A9          ; ELSE SET SERIAL 
DATA OUT LOW
11138  EE86  D0 03              BNE     XXEE8B          ; BRANCH ALWAYS
11139  EE88                     
11140  EE88              XXEE88 = *
11141  EE88  20 A0 E4           JSR     XXE4A0          ; SET SERIAL DATA 
OUT HIGH
11142  EE8B              XXEE8B = *
11143  EE8B  20 84 EF           JSR     XXEF84          ; SET SERIAL CLOCK
 HIGH
11144  EE8E  EA                 NOP                    ; WASTE ..
11145  EE8F  EA                 NOP                    ; .. A ..
11146  EE90  EA                 NOP                    ; .. CYCLE ..
11147  EE91  EA                 NOP                    ; .. OR TWO
11148  EE92  AD 2C 91           LDA     XX912C          ; GET VIA 2 PCR
11149  EE95  29 DF              AND     #$DF               ; SET CB2 LOW, 
SERIAL DATA OUT HIGH
11150  EE97  09 02              ORA     #$02               ; SET CA2 HIGH,
 SERIAL CLOCK OUT LOW
11151  EE99  8D 2C 91           STA     XX912C          ; SAVE VIA 2 PCR
11152  EE9C  C6 A5              DEC     XXA5          ; DECREMENT SERIAL B
US BIT COUNT
11153  EE9E  D0 D3              BNE     XXEE73          ; LOOP IF NOT ALL 
DONE
11154  EEA0                     
11155  EEA0              ; NOW ALL EIGHT BITS HAVE BEEN SENT IT'S UP TO TH
E PERIPHERAL TO SIGNAL THE BYTE WAS
11156  EEA0              ; RECEIVED BY PULLING THE SERIAL DATA LOW. THIS S
HOULD BE DONE WITHIN ONE MILISECOND
11157  EEA0              
11158  EEA0  A9 04              LDA     #$04               ; WAIT FOR UP T
O ABOUT 1MS
11159  EEA2  8D 29 91           STA     XX9129          ; SET VIA 2 T2C_H
11160  EEA5              XXEEA5 = *
11161  EEA5  AD 2D 91           LDA     XX912D          ; GET VIA 2 IFR
11162  EEA8  29 20              AND     #$20               ; MASK T2 INTER
RUPT
11163  EEAA  D0 0B              BNE     XXEEB7          ; IF T2 INTERRUPT 
DO TIMEOUT ON SERIAL BUS
11164  EEAC                     
11165  EEAC  20 B2 E4           JSR     XXE4B2          ; GET SERIAL CLOCK
 STATUS
11166  EEAF  4A                 LSR A                  ; SHIFT SERIAL DATA
 TO CB
11167  EEB0  B0 F3              BCS     XXEEA5          ; IF DATA HIGH GO 
WAIT SOME MORE
11168  EEB2                     
11169  EEB2  58                 CLI                    ; ENABLE INTERRUPTS







CONDIN......PAGE 0219

LINE# LOC   CODE        LINE


11170  EEB3  60                 RTS
11171  EEB4                     
11172  EEB4                     
11173  EEB4              ;************************************************
***********************************;
11174  EEB4              ;
11175  EEB4              ; DEVICE NOT PRESENT
11176  EEB4              
11177  EEB4              XXEEB4 = *
11178  EEB4  A9 80              LDA     #$80               ; ERROR $80, DE
VICE NOT PRESENT
11179  EEB6  2C                 .BYTE     $2C               ; MAKES NEXT L
INE BIT XX03A9
11180  EEB7                     
11181  EEB7                     
11182  EEB7              ;************************************************
***********************************;
11183  EEB7              ;
11184  EEB7              ; TIMEOUT ON SERIAL BUS
11185  EEB7              
11186  EEB7              XXEEB7 = *
11187  EEB7  A9 03              LDA     #$03               ; ERROR $03, WR
ITE TIMEOUT
11188  EEB9              XXEEB9 = *
11189  EEB9  20 6A FE           JSR     XXFE6A          ; OR INTO SERIAL S
TATUS BYTE
11190  EEBC  58                 CLI                    ; ENABLE INTERRUPTS

11191  EEBD  18                 CLC                    ; CLEAR FOR BRANCH
11192  EEBE  90 49              BCC     XXEF09          ; ATN HIGH, DELAY,
 CLOCK HIGH THEN DATA HIGH, BRANCH ALWAYS
11193  EEC0                     
11194  EEC0                     
11195  EEC0              ;************************************************
***********************************;
11196  EEC0              ;
11197  EEC0              ; SEND SECONDARY ADDRESS AFTER LISTEN
11198  EEC0              
11199  EEC0              ; THIS ROUTINE IS USED TO SEND A SECONDARY ADDRES
S TO AN I/O DEVICE AFTER A CALL TO
11200  EEC0              ; THE LISTEN ROUTINE IS MADE AND THE DEVICE COMMA
NDED TO LISTEN. THE ROUTINE CANNOT
11201  EEC0              ; BE USED TO SEND A SECONDARY ADDRESS AFTER A CAL
L TO THE TALK ROUTINE.
11202  EEC0              
11203  EEC0              ; A SECONDARY ADDRESS IS USUALLY USED TO GIVE SET
-UP INFORMATION TO A DEVICE BEFORE
11204  EEC0              ; I/O OPERATIONS BEGIN.
11205  EEC0              
11206  EEC0              ; WHEN A SECONDARY ADDRESS IS TO BE SENT TO A DEV
ICE ON THE SERIAL BUS THE ADDRESS
11207  EEC0              ; MUST FIRST BE ORED WITH $60.
11208  EEC0              
11209  EEC0              XXEEC0 = *
11210  EEC0  85 95              STA     XX95          ; SAVE DEFERED BYTE
11211  EEC2  20 40 EE           JSR     XXEE40          ; SET CLK/DATA, WA
IT AND TX BYTE ON SERIAL BUS
11212  EEC5                     
11213  EEC5              ; SET SERIAL ATN HIGH
11214  EEC5              
11215  EEC5              XXEEC5 = *
11216  EEC5  AD 1F 91           LDA     XX911F          ; GET VIA 1 DRA, N
O HANDSHAKE
11217  EEC8  29 7F              AND     #$7F               ; SET SERIAL AT
N HIGH
11218  EECA  8D 1F 91           STA     XX911F          ; SET VIA 1 DRA, N
O HANDSHAKE
11219  EECD  60                 RTS
11220  EECE                     
11221  EECE                     
11222  EECE              ;************************************************
***********************************;
11223  EECE              ;
11224  EECE              ; SEND SECONDARY ADDRESS AFTER TALK






****;A......PAGE 0220

LINE# LOC   CODE        LINE


11225  EECE              
11226  EECE              ; THIS ROUTINE TRANSMITS A SECONDARY ADDRESS ON T
HE SERIAL BUS FOR A TALK DEVICE.
11227  EECE              ; THIS ROUTINE MUST BE CALLED WITH A NUMBER BETWE
EN 4 AND 31 IN THE ACCUMULATOR.
11228  EECE              ; THE ROUTINE WILL SEND THIS NUMBER AS A SECONDAR
Y ADDRESS COMMAND OVER THE SERIAL
11229  EECE              ; BUS. THIS ROUTINE CAN ONLY BE CALLED AFTER A CA
LL TO THE TALK ROUTINE. IT WILL
11230  EECE              ; NOT WORK AFTER A LISTEN.
11231  EECE              
11232  EECE              XXEECE = *
11233  EECE  85 95              STA     XX95          ; SAVE THE SECONDARY
 ADDRESS BYTE TO TRANSMIT
11234  EED0  20 40 EE           JSR     XXEE40          ; SET CLK/DATA, WA
IT AND TX BYTE ON SERIAL BUS
11235  EED3                     
11236  EED3                     
11237  EED3              ;************************************************
***********************************;
11238  EED3              ;
11239  EED3              ; WAIT FOR BUS END AFTER SEND
11240  EED3              
11241  EED3              XXEED3 = *
11242  EED3  78                 SEI                    ; DISABLE INTERRUPT
S
11243  EED4  20 A9 E4           JSR     XXE4A9          ; SET SERIAL DATA 
OUT LOW
11244  EED7  20 C5 EE           JSR     XXEEC5          ; SET SERIAL ATN H
IGH
11245  EEDA  20 84 EF           JSR     XXEF84          ; SET SERIAL CLOCK
 HIGH
11246  EEDD              XXEEDD = *
11247  EEDD  20 B2 E4           JSR     XXE4B2          ; GET SERIAL CLOCK
 STATUS
11248  EEE0  B0 FB              BCS     XXEEDD          ; BRANCH IF CLOCK 
HIGH
11249  EEE2                     
11250  EEE2  58                 CLI                    ; ENABLE INTERRUPTS

11251  EEE3  60                 RTS
11252  EEE4                     
11253  EEE4                     
11254  EEE4              ;************************************************
***********************************;
11255  EEE4              ;
11256  EEE4              ; OUTPUT A BYTE TO THE SERIAL BUS
11257  EEE4              
11258  EEE4              ; THIS ROUTINE IS USED TO SEND INFORMATION TO DEV
ICES ON THE SERIAL BUS. A CALL TO
11259  EEE4              ; THIS ROUTINE WILL PUT A DATA BYTE ONTO THE SERI
AL BUS USING FULL HANDSHAKING.
11260  EEE4              ; BEFORE THIS ROUTINE IS CALLED THE LISTEN ROUTIN
E, XXFFB1, MUST BE USED TO
11261  EEE4              ; COMMAND A DEVICE ON THE SERIAL BUS TO GET READY
 TO RECEIVE DATA.
11262  EEE4              
11263  EEE4              ; THE ACCUMULATOR IS LOADED WITH A BYTE TO OUTPUT
 AS DATA ON THE SERIAL BUS. A
11264  EEE4              ; DEVICE MUST BE LISTENING OR THE STATUS WORD WIL
L RETURN A TIMEOUT. THIS ROUTINE
11265  EEE4              ; ALWAYS BUFFERS ONE CHARACTER. SO WHEN A CALL TO
 THE UNLISTEN ROUTINE, XXFFAE,
11266  EEE4              ; IS MADE TO END THE DATA TRANSMISSION, THE BUFFE
RED CHARACTER IS SENT WITH EOI
11267  EEE4              ; SET. THEN THE UNLISTEN COMMAND IS SENT TO THE D
EVICE.
11268  EEE4              
11269  EEE4              XXEEE4 = *
11270  EEE4  24 94              BIT     XX94          ; TEST DEFERRED CHAR
ACTER FLAG
11271  EEE6  30 05              BMI     XXEEED          ; BRANCH IF DEFERE
D CHARACTER
11272  EEE8                     
11273  EEE8  38                 SEC                    ; SET CARRY
11274  EEE9  66 94              ROR     XX94          ; SHIFT INTO DEFERRE
D CHARACTER FLAG
11275  EEEB  D0 05              BNE     XXEEF2          ; SAVE BYTE AND EX
IT, BRANCH ALWAYS
11276  EEED                     
11277  EEED              XXEEED = *
11278  EEED  48                 PHA                    ; SAVE BYTE
11279  EEEE  20 49 EE           JSR     XXEE49          ; TX BYTE ON SERIA
L BUS






EO**;A......PAGE 0221

LINE# LOC   CODE        LINE


11280  EEF1  68                 PLA                    ; RESTORE BYTE
11281  EEF2              XXEEF2 = *
11282  EEF2  85 95              STA     XX95          ; SAVE DEFERED BYTE
11283  EEF4  18                 CLC                    ; FLAG OK
11284  EEF5  60                 RTS
11285  EEF6                     
11286  EEF6                     
11287  EEF6              ;************************************************
***********************************;
11288  EEF6              ;
11289  EEF6              ; COMMAND THE SERIAL BUS TO UNTALK
11290  EEF6              
11291  EEF6              ; THIS ROUTINE WILL TRANSMIT AN UNTALK COMMAND ON
 THE SERIAL BUS. ALL DEVICES
11292  EEF6              ; PREVIOUSLY SET TO TALK WILL STOP SENDING DATA W
HEN THIS COMMAND IS RECEIVED.
11293  EEF6              
11294  EEF6              XXEEF6 = *
11295  EEF6  20 8D EF           JSR     XXEF8D          ; SET SERIAL CLOCK
 LOW
11296  EEF9  AD 1F 91           LDA     XX911F          ; GET VIA 1 DRA, N
O HANDSHAKE
11297  EEFC  09 80              ORA     #$80               ; SET SERIAL AT
N LOW
11298  EEFE  8D 1F 91           STA     XX911F          ; SET VIA 1 DRA, N
O HANDSHAKE
11299  EF01                     
11300  EF01  A9 5F              LDA     #$5F               ; SET THE UNTAL
K COMMAND
11301  EF03  2C                 .BYTE     $2C               ; MAKES NEXT L
INE BIT XX3FA9
11302  EF04                     
11303  EF04                     
11304  EF04              ;************************************************
***********************************;
11305  EF04              ;
11306  EF04              ; COMMAND THE SERIAL BUS TO UNLISTEN
11307  EF04              
11308  EF04              ; THIS ROUTINE COMMANDS ALL DEVICES ON THE SERIAL
 BUS TO STOP RECEIVING DATA FROM
11309  EF04              ; THE COMPUTER. CALLING THIS ROUTINE RESULTS IN A
N UNLISTEN COMMAND BEING TRANSMITTED
11310  EF04              ; ON THE SERIAL BUS. ONLY DEVICES PREVIOUSLY COMM
ANDED TO LISTEN WILL BE AFFECTED.
11311  EF04              
11312  EF04              ; THIS ROUTINE IS NORMALLY USED AFTER THE COMPUTE
R IS FINISHED SENDING DATA TO
11313  EF04              ; EXTERNAL DEVICES. SENDING THE UNLISTEN WILL COM
MAND THE LISTENING DEVICES TO GET
11314  EF04              ; OFF THE SERIAL BUS SO IT CAN BE USED FOR OTHER 
PURPOSES.
11315  EF04              
11316  EF04              XXEF04 = *
11317  EF04  A9 3F              LDA     #$3F               ; SET THE UNLIS
TEN COMMAND
11318  EF06  20 1C EE           JSR     XXEE1C          ; SEND CONTROL CHA
RACTER
11319  EF09                     
11320  EF09              ; ATN HIGH, DELAY, CLOCK HIGH THEN DATA HIGH
11321  EF09              
11322  EF09              XXEF09 = *
11323  EF09  20 C5 EE           JSR     XXEEC5          ; SET SERIAL ATN H
IGH
11324  EF0C                     
11325  EF0C              ; 1MS DELAY, CLOCK HIGH THEN DATA HIGH
11326  EF0C              
11327  EF0C              XXEF0C = *
11328  EF0C  8A                 TXA                    ; SAVE DEVICE NUMBE
R
11329  EF0D  A2 0B              LDX     #$0B               ; SHORT DELAY
11330  EF0F              XXEF0F = *
11331  EF0F  CA                 DEX                    ; DECREMENT COUNT
11332  EF10  D0 FD              BNE     XXEF0F          ; LOOP IF NOT ALL 
DONE
11333  EF12                     
11334  EF12  AA                 TAX                    ; RESTORE DEVICE NU
MBER






ETTEDA......PAGE 0222

LINE# LOC   CODE        LINE


11335  EF13  20 84 EF           JSR     XXEF84          ; SET SERIAL CLOCK
 HIGH
11336  EF16  4C A0 E4           JMP     XXE4A0          ; SET SERIAL DATA 
OUT HIGH AND RETURN
11337  EF19                     
11338  EF19                     
11339  EF19              ;************************************************
***********************************;
11340  EF19              ;
11341  EF19              ; INPUT A BYTE FROM THE SERIAL BUS
11342  EF19              
11343  EF19              ; THIS ROUTINE READS A BYTE OF DATA FROM THE SERI
AL BUS USING FULL HANDSHAKING. THE
11344  EF19              ; DATA IS RETURNED IN THE ACCUMULATOR. BEFORE USI
NG THIS ROUTINE THE TALK ROUTINE,
11345  EF19              ; XXFFB4, MUST HAVE BEEN CALLED FIRST TO COMMAND 
THE DEVICE ON THE SERIAL BUS TO
11346  EF19              ; SEND DATA ON THE BUS. IF THE INPUT DEVICE NEEDS
 A SECONDARY COMMAND IT MUST BE SENT
11347  EF19              ; BY USING THE TKSA ROUTINE, XXFF96, BEFORE CALLI
NG THIS ROUTINE.
11348  EF19              
11349  EF19              ; ERRORS ARE RETURNED IN THE STATUS WORD WHICH CA
N BE READ BY CALLING THE READST
11350  EF19              ; ROUTINE, XXFFB7.
11351  EF19              
11352  EF19              XXEF19 = *
11353  EF19  78                 SEI                    ; DISABLE INTERRUPT
S
11354  EF1A  A9 00              LDA     #$00               ; CLEAR A
11355  EF1C  85 A5              STA     XXA5          ; CLEAR SERIAL BUS B
IT COUNT
11356  EF1E  20 84 EF           JSR     XXEF84          ; SET SERIAL CLOCK
 HIGH
11357  EF21              XXEF21 = *
11358  EF21  20 B2 E4           JSR     XXE4B2          ; GET SERIAL CLOCK
 STATUS
11359  EF24  90 FB              BCC     XXEF21          ; LOOP WHILE CLOCK
 LOW
11360  EF26                     
11361  EF26  20 A0 E4           JSR     XXE4A0          ; SET SERIAL DATA 
OUT HIGH
11362  EF29              XXEF29 = *
11363  EF29  A9 01              LDA     #$01               ; SET TIMEOUT C
OUNT HIGH BYTE
11364  EF2B  8D 29 91           STA     XX9129          ; SET VIA 2 T2C_H
11365  EF2E              XXEF2E = *
11366  EF2E  AD 2D 91           LDA     XX912D          ; GET VIA 2 IFR
11367  EF31  29 20              AND     #$20               ; MASK T2 INTER
RUPT
11368  EF33  D0 07              BNE     XXEF3C          ; BRANCH IF T2 INT
ERRUPT
11369  EF35                     
11370  EF35  20 B2 E4           JSR     XXE4B2          ; GET SERIAL CLOCK
 STATUS
11371  EF38  B0 F4              BCS     XXEF2E          ; LOOP IF CLOCK HI
GH
11372  EF3A                     
11373  EF3A  90 18              BCC     XXEF54          ; ELSE GO SE 8 BIT
S TO DO, BRANCH ALWAYS
11374  EF3C                     
11375  EF3C                                     ; T2 TIMED OUT
11376  EF3C              XXEF3C = *
11377  EF3C  A5 A5              LDA     XXA5          ; GET SERIAL BUS BIT
 COUNT
11378  EF3E  F0 05              BEQ     XXEF45          ; IF NOT ALREADY E
OI THEN GO FLAG EOI
11379  EF40                     
11380  EF40  A9 02              LDA     #$02               ; ERROR $02, RE
AD TIMEOUR
11381  EF42  4C B9 EE           JMP     XXEEB9          ; SET SERIAL STATU
S AND EXIT
11382  EF45                     
11383  EF45              XXEF45 = *
11384  EF45  20 A9 E4           JSR     XXE4A9          ; SET SERIAL DATA 
OUT LOW
11385  EF48  20 0C EF           JSR     XXEF0C          ; 1MS DELAY, CLOCK
 HIGH THEN DATA HIGH
11386  EF4B  A9 40              LDA     #$40               ; SET EOI
11387  EF4D  20 6A FE           JSR     XXFE6A          ; OR INTO SERIAL S
TATUS BYTE
11388  EF50  E6 A5              INC     XXA5          ; INCREMENT SERIAL B
US BIT COUNT, DO ERROR ON NEXT TIMEOUT
11389  EF52  D0 D5              BNE     XXEF29          ; GO TRY AGAIN






MEOUTA......PAGE 0223

LINE# LOC   CODE        LINE


11390  EF54                     
11391  EF54              XXEF54 = *
11392  EF54  A9 08              LDA     #$08               ; 8 BITS TO DO
11393  EF56  85 A5              STA     XXA5          ; SET SERIAL BUS BIT
 COUNT
11394  EF58              XXEF58 = *
11395  EF58  AD 1F 91           LDA     XX911F          ; GET VIA 1 DRA, N
O HANDSHAKE
11396  EF5B  CD 1F 91           CMP     XX911F          ; COMPARE WITH SEL
F
11397  EF5E  D0 F8              BNE     XXEF58          ; LOOP IF CHANGING

11398  EF60                     
11399  EF60  4A                 LSR A                  ; SERIAL CLOCK INTO
 CARRY
11400  EF61  90 F5              BCC     XXEF58          ; LOOP WHILE SERIA
L CLOCK LOW
11401  EF63                     
11402  EF63  4A                 LSR A                  ; SERIAL DATA INTO 
CARRY
11403  EF64  66 A4              ROR     XXA4          ; SHIFT DATA BIT INT
O RECEIVE BYTE
11404  EF66              XXEF66 = *
11405  EF66  AD 1F 91           LDA     XX911F          ; GET VIA 1 DRA, N
O HANDSHAKE
11406  EF69  CD 1F 91           CMP     XX911F          ; COMPARE WITH SEL
F
11407  EF6C  D0 F8              BNE     XXEF66          ; LOOP IF CHANGING

11408  EF6E                     
11409  EF6E  4A                 LSR A                  ; SERIAL CLOCK INTO
 CARRY
11410  EF6F  B0 F5              BCS     XXEF66          ; LOOP WHILE SERIA
L CLOCK HIGH
11411  EF71                     
11412  EF71  C6 A5              DEC     XXA5          ; DECREMENT SERIAL B
US BIT COUNT
11413  EF73  D0 E3              BNE     XXEF58          ; LOOP IF NOT ALL 
DONE
11414  EF75                     
11415  EF75  20 A9 E4           JSR     XXE4A9          ; SET SERIAL DATA 
OUT LOW
11416  EF78  A5 90              LDA     XX90          ; GET SERIAL STATUS 
BYTE
11417  EF7A  F0 03              BEQ     XXEF7F          ; BRANCH IF NO ERR
OR
11418  EF7C                     
11419  EF7C  20 0C EF           JSR     XXEF0C          ; 1MS DELAY, CLOCK
 HIGH THEN DATA HIGH
11420  EF7F              XXEF7F = *
11421  EF7F  A5 A4              LDA     XXA4          ; GET RECEIVE BYTE
11422  EF81  58                 CLI                    ; ENABLE INTERRUPTS

11423  EF82  18                 CLC
11424  EF83  60                 RTS
11425  EF84                     
11426  EF84                     
11427  EF84              ;************************************************
***********************************;
11428  EF84              ;
11429  EF84              ; SET SERIAL CLOCK HIGH
11430  EF84              
11431  EF84              XXEF84 = *
11432  EF84  AD 2C 91           LDA     XX912C          ; GET VIA 2 PCR
11433  EF87  29 FD              AND     #$FD               ; SET CA2 LOW, 
SERIAL CLOCK OUT HIGH
11434  EF89  8D 2C 91           STA     XX912C          ; SET VIA 2 PCR
11435  EF8C  60                 RTS
11436  EF8D                     
11437  EF8D                     
11438  EF8D              ;************************************************
***********************************;
11439  EF8D              ;
11440  EF8D              ; SET SERIAL CLOCK LOW
11441  EF8D              
11442  EF8D              XXEF8D = *
11443  EF8D  AD 2C 91           LDA     XX912C          ; GET VIA 2 PCR
11444  EF90  09 02              ORA     #$02               ; SET CA2 HIGH,
 SERIAL CLOCK OUT LOW






****;A......PAGE 0224

LINE# LOC   CODE        LINE


11445  EF92  8D 2C 91           STA     XX912C          ; SET VIA 2 PCR
11446  EF95  60                 RTS
11447  EF96                     
11448  EF96                     
11449  EF96              ;************************************************
***********************************;
11450  EF96              ;
11451  EF96              ; 1MS DELAY
11452  EF96              
11453  EF96              XXEF96 = *
11454  EF96  A9 04              LDA     #$04               ; SET FOR 1024 
CYCLES
11455  EF98  8D 29 91           STA     XX9129          ; SET VIA 2 T2C_H
11456  EF9B              XXEF9B = *
11457  EF9B  AD 2D 91           LDA     XX912D          ; GET VIA 2 IFR
11458  EF9E  29 20              AND     #$20               ; MASK T2 INTER
RUPT
11459  EFA0  F0 F9              BEQ     XXEF9B          ; LOOP UNTIL T2 IN
TERRUPT
11460  EFA2                     
11461  EFA2  60                 RTS
11462  EFA3                     
11463  EFA3                     
11464  EFA3              ;************************************************
***********************************;
11465  EFA3              ;
11466  EFA3              ; RS232 TX NMI ROUTINE
11467  EFA3              
11468  EFA3              XXEFA3 = *
11469  EFA3  A5 B4              LDA     XXB4          ; GET RS232 BIT COUN
T
11470  EFA5  F0 47              BEQ     XXEFEE          ; IF ZERO GO SETUP
 NEXT RS232 TX BYTE AND RETURN
11471  EFA7                     
11472  EFA7  30 3F              BMI     XXEFE8          ; IF -VE GO DO STO
P BIT(S)
11473  EFA9                     
11474  EFA9                                     ; ELSE BIT COUNT IS NON ZE
RO AND +VE
11475  EFA9  46 B6              LSR     XXB6          ; SHIFT RS232 OUTPUT
 BYTE BUFFER
11476  EFAB  A2 00              LDX     #$00               ; SET $00 FOR B
IT = 0
11477  EFAD  90 01              BCC     XXEFB0          ; BRANCH IF BIT WA
S 0
11478  EFAF                     
11479  EFAF  CA                 DEX                    ; SET $FF FOR BIT =
 1
11480  EFB0              XXEFB0 = *
11481  EFB0  8A                 TXA                    ; COPY BIT TO A
11482  EFB1  45 BD              EOR     XXBD          ; EOR WITH RS232 PAR
ITY BYTE
11483  EFB3  85 BD              STA     XXBD          ; SAVE RS232 PARITY 
BYTE
11484  EFB5  C6 B4              DEC     XXB4          ; DECREMENT RS232 BI
T COUNT
11485  EFB7  F0 06              BEQ     XXEFBF          ; IF RS232 BIT COU
NT NOW ZERO GO DO PARITY BIT
11486  EFB9                     
11487  EFB9              ; SAVE BIT AND EXIT
11488  EFB9              
11489  EFB9              XXEFB9 = *
11490  EFB9  8A                 TXA                    ; COPY BIT TO A
11491  EFBA  29 20              AND     #$20               ; MASK FOR CB2 
CONTROL BIT
11492  EFBC  85 B5              STA     XXB5          ; SAVE RS232 NEXT BI
T TO SEND
11493  EFBE  60                 RTS
11494  EFBF                     
11495  EFBF              ; DO RS232 PARITY BIT, ENTERS WITH RS232 BIT COUN
T = 0
11496  EFBF              
11497  EFBF              XXEFBF = *
11498  EFBF  A9 20              LDA     #$20               ; MASK 00X0 000
0, PARITY ENABLE BIT
11499  EFC1  2C 94 02           BIT     XX0294          ; TEST PSEUDO 6551
 COMMAND REGISTER






****;A......PAGE 0225

LINE# LOC   CODE        LINE


11500  EFC4  F0 14              BEQ     XXEFDA          ; BRANCH IF PARITY
 DISABLED
11501  EFC6                     
11502  EFC6  30 1C              BMI     XXEFE4          ; BRANCH IF FIXED 
MARK OR SPACE PARITY
11503  EFC8                     
11504  EFC8  70 14              BVS     XXEFDE          ; BRANCH IF EVEN P
ARITY
11505  EFCA                     
11506  EFCA                                     ; ELSE ODD PARITY
11507  EFCA  A5 BD              LDA     XXBD          ; GET RS232 PARITY B
YTE
11508  EFCC  D0 01              BNE     XXEFCF          ; IF PARITY NOT ZE
RO LEAVE PARITY BIT = 0
11509  EFCE                     
11510  EFCE              XXEFCE = *
11511  EFCE  CA                 DEX                    ; MAKE PARITY BIT =
 1
11512  EFCF              XXEFCF = *
11513  EFCF  C6 B4              DEC     XXB4          ; DECREMENT RS232 BI
T COUNT, 1 STOP BIT
11514  EFD1  AD 93 02           LDA     XX0293          ; GET PSEUDO 6551 
CONTROL REGISTER
11515  EFD4  10 E3              BPL     XXEFB9          ; IF 1 STOP BIT SA
VE PARITY BIT AND EXIT
11516  EFD6                     
11517  EFD6                                     ; ELSE TWO STOP BITS ..
11518  EFD6  C6 B4              DEC     XXB4          ; DECREMENT RS232 BI
T COUNT, 2 STOP BITS
11519  EFD8  D0 DF              BNE     XXEFB9          ; SAVE BIT AND EXI
T, BRANCH ALWAYS
11520  EFDA                     
11521  EFDA                                     ; PARITY IS DISABLED SO TH
E PARITY BIT BECOMES THE FIRST,
11522  EFDA                                     ; AND POSSIBLY ONLY, STOP 
BIT. TO DO THIS INCREMENT THE BIT
11523  EFDA                                     ; COUNT WHICH EFFECTIVELY 
DECREMENTS THE STOP BIT COUNT.
11524  EFDA              XXEFDA = *
11525  EFDA  E6 B4              INC     XXB4          ; INCREMENT RS232 BI
T COUNT, = -1 STOP BIT
11526  EFDC  D0 F0              BNE     XXEFCE          ; SET STOP BIT = 1
 AND EXIT
11527  EFDE                     
11528  EFDE                                     ; DO EVEN PARITY
11529  EFDE              XXEFDE = *
11530  EFDE  A5 BD              LDA     XXBD          ; GET RS232 PARITY B
YTE
11531  EFE0  F0 ED              BEQ     XXEFCF          ; IF PARITY ZERO L
EAVE PARITY BIT = 0
11532  EFE2                     
11533  EFE2  D0 EA              BNE     XXEFCE          ; ELSE MAKE PARITY
 BIT = 1, BRANCH ALWAYS
11534  EFE4                     
11535  EFE4                                     ; FIXED MARK OR SPACE PARI
TY
11536  EFE4              XXEFE4 = *
11537  EFE4  70 E9              BVS     XXEFCF          ; IF FIXED SPACE P
ARITY LEAVE PARITY BIT = 0
11538  EFE6                     
11539  EFE6  50 E6              BVC     XXEFCE          ; ELSE FIXED MARK 
PARITY MAKE PARITY BIT = 1, BRANCH ALWAYS
11540  EFE8                     
11541  EFE8              ; DECREMENT STOP BIT COUNT, SET STOP BIT = 1 AND 
EXIT. $FF IS ONE STOP BIT, $FE IS TWO
11542  EFE8              ; STOP BITS
11543  EFE8              
11544  EFE8              XXEFE8 = *
11545  EFE8  E6 B4              INC     XXB4          ; DECREMENT RS232 BI
T COUNT
11546  EFEA  A2 FF              LDX     #$FF               ; SET STOP BIT 
= 1
11547  EFEC  D0 CB              BNE     XXEFB9          ; SAVE STOP BIT AN
D EXIT, BRANCH ALWAYS
11548  EFEE                     
11549  EFEE              ; SETUP NEXT RS232 TX BYTE
11550  EFEE              
11551  EFEE              XXEFEE = *
11552  EFEE  AD 94 02           LDA     XX0294          ; GET 6551 PSEUDO 
COMMAND REGISTER
11553  EFF1  4A                 LSR A                  ; HANDSHAKE BIT INO
T CB
11554  EFF2  90 07              BCC     XXEFFB          ; BRANCH IF 3 LINE
 INTERFACE






IS TWO......PAGE 0226

LINE# LOC   CODE        LINE


11555  EFF4                     
11556  EFF4  2C 20 91           BIT     XX9120          ; TEST VIA 2 DRB, 
THIS IS WRONG, THE ADRESS SHOULD BE
11557  EFF7                                     ; XX9110 WHICH IS VIA 1 WH
ICH IS WHERE THE DSR AND
11558  EFF7                                     ; CTS INPUTS REALLY ARE ##

11559  EFF7                     
11560  EFF7  10 1D              BPL     XXF016          ; IF DSR = 0 SET D
SR SIGNAL NOT PRESENT AND EXIT
11561  EFF9                     
11562  EFF9  50 1E              BVC     XXF019          ; IF CTS = 0 SET C
TS SIGNAL NOT PRESENT AND EXIT
11563  EFFB                     
11564  EFFB                                     ; WAS 3 LINE INTERFACE
11565  EFFB              XXEFFB = *
11566  EFFB  A9 00              LDA     #$00               ; CLEAR A
11567  EFFD  85 BD              STA     XXBD          ; CLEAR RS232 PARITY
 BYTE
11568  EFFF  85 B5              STA     XXB5          ; CLEAR RS232 NEXT B
IT TO SEND
11569  F001  AE 98 02           LDX     XX0298          ; GET NUMBER OF BI
TS TO BE SENT/RECEIVED
11570  F004  86 B4              STX     XXB4          ; SET RS232 BIT COUN
T
11571  F006  AC 9D 02           LDY     XX029D          ; GET INDEX TO TX 
BUFFER START
11572  F009  CC 9E 02           CPY     XX029E          ; COMPARE WITH IND
EX TO TX BUFFER END
11573  F00C  F0 13              BEQ     XXF021          ; IF ALL DONE GO D
ISABLE T1 INTERRUPT AND RETURN
11574  F00E                     
11575  F00E  B1 F9              LDA     (XXF9),Y          ; ELSE GET BYTE 
FROM BUFFER
11576  F010  85 B6              STA     XXB6          ; SAVE TO RS232 OUTP
UT BYTE BUFFER
11577  F012  EE 9D 02           INC     XX029D          ; INCREMENT INDEX 
TO TX BUFFER START
11578  F015  60                 RTS
11579  F016                     
11580  F016                     
11581  F016              ;************************************************
***********************************;
11582  F016              ;
11583  F016              ;## EXIT OR QUIT
11584  F016              ; SET DSR SIGNAL NOT PRESENT
11585  F016              
11586  F016              XXF016 = *
11587  F016  A9 40              LDA     #$40               ; SET DSR SIGNA
L NOT PRESENT
11588  F018  2C                 .BYTE     $2C               ; MAKES NEXT L
INE BIT XX10A9
11589  F019                     
11590  F019              ; SET CTS SIGNAL NOT PRESENT
11591  F019              
11592  F019              XXF019 = *
11593  F019  A9 10              LDA     #$10               ; SET CTS SIGNA
L NOT PRESENT
11594  F01B  0D 97 02           ORA     XX0297          ; OR WITH RS232 ST
ATUS REGISTER
11595  F01E  8D 97 02           STA     XX0297          ; SAVE RS232 STATU
S REGISTER
11596  F021                     
11597  F021              ; DISABLE T1 INTERRUPT
11598  F021              
11599  F021              XXF021 = *
11600  F021  A9 40              LDA     #$40               ; DISABLE T1 IN
TERRUPT
11601  F023  8D 1E 91           STA     XX911E          ; SET VIA 1 IER
11602  F026  60                 RTS
11603  F027                     
11604  F027                     
11605  F027              ;************************************************
***********************************;
11606  F027              ;
11607  F027              ; COMPUTE BIT COUNT
11608  F027              
11609  F027              XXF027 = *






****;O......PAGE 0227

LINE# LOC   CODE        LINE


11610  F027  A2 09              LDX     #$09               ; SET BIT COUNT
 TO 9, 8 DATA + 1 STOP BIT
11611  F029  A9 20              LDA     #$20               ; MASK FOR 8/7 
DATA BITS
11612  F02B  2C 93 02           BIT     XX0293          ; TEST PSEUDO 6551
 CONTROL REGISTER
11613  F02E  F0 01              BEQ     XXF031          ; BRANCH IF 8 BITS

11614  F030                     
11615  F030  CA                 DEX                    ; ELSE DECREMENT CO
UNT FOR 7 DATA BITS
11616  F031              XXF031 = *
11617  F031  50 02              BVC     XXF035          ; BRANCH IF 7 BITS

11618  F033                     
11619  F033  CA                 DEX                    ; ELSE DECREMENT CO
UNT ..
11620  F034  CA                 DEX                    ; .. FOR 5 DATA BIT
S
11621  F035              XXF035 = *
11622  F035  60                 RTS
11623  F036                     
11624  F036                     
11625  F036              ;************************************************
***********************************;
11626  F036              ;
11627  F036              ; RS232 RX NMI
11628  F036              
11629  F036              XXF036 = *
11630  F036  A6 A9              LDX     XXA9          ; GET START BIT CHEC
K FLAG
11631  F038  D0 2E              BNE     XXF068          ; BRANCH IF NO STA
RT BIT RECEIVED
11632  F03A                     
11633  F03A  C6 A8              DEC     XXA8          ; DECREMENT RECEIVER
 BIT COUNT IN
11634  F03C  F0 31              BEQ     XXF06F          ;.
11635  F03E                     
11636  F03E  30 0D              BMI     XXF04D          ;.
11637  F040                     
11638  F040  A5 A7              LDA     XXA7          ; GET RECEIVER INPUT
 BIT TEMPORARY STORAGE
11639  F042  45 AB              EOR     XXAB          ;.
11640  F044  85 AB              STA     XXAB          ;.
11641  F046  46 A7              LSR     XXA7          ; SHIFT RECEIVER INP
UT BIT TEMPORARY STORAGE
11642  F048  66 AA              ROR     XXAA          ;.
11643  F04A              XXF04A = *
11644  F04A  60                 RTS
11645  F04B                     
11646  F04B              XXF04B = *
11647  F04B  C6 A8              DEC     XXA8          ; DECREMENT RECEIVER
 BIT COUNT IN
11648  F04D              XXF04D = *
11649  F04D  A5 A7              LDA     XXA7          ; GET RECEIVER INPUT
 BIT TEMPORARY STORAGE
11650  F04F  F0 62              BEQ     XXF0B3          ;.
11651  F051                     
11652  F051  AD 93 02           LDA     XX0293          ; GET PSEUDO 6551 
CONTROL REGISTER
11653  F054  0A                 ASL A                  ;.
11654  F055  A9 01              LDA     #$01               ;.
11655  F057  65 A8              ADC     XXA8          ; ADD RECEIVER BIT C
OUNT IN
11656  F059  D0 EF              BNE     XXF04A          ;.
11657  F05B                     
11658  F05B                     
11659  F05B              ;************************************************
***********************************;
11660  F05B              ;
11661  F05B              ;## SETUP TO RX
11662  F05B              
11663  F05B              XXF05B = *
11664  F05B  A9 90              LDA     #$90               ; ENABLE CB1 IN
TERRUPT






****;O......PAGE 0228

LINE# LOC   CODE        LINE


11665  F05D  8D 1E 91           STA     XX911E          ; SET VIA 1 IER
11666  F060  85 A9              STA     XXA9          ; SET START BIT CHEC
K FLAG, SET NO START BIT RECEIVED
11667  F062  A9 20              LDA     #$20               ; DISABLE T2 IN
TERRUPT
11668  F064  8D 1E 91           STA     XX911E          ; SET VIA 1 IER
11669  F067  60                 RTS
11670  F068                     
11671  F068                     
11672  F068              ;************************************************
***********************************;
11673  F068              ;
11674  F068              ; NO RS232 START BIT RECEIVED
11675  F068              
11676  F068              XXF068 = *
11677  F068  A5 A7              LDA     XXA7          ; GET RECEIVER INPUT
 BIT TEMPORARY STORAGE
11678  F06A  D0 EF              BNE     XXF05B          ;.
11679  F06C                     
11680  F06C  85 A9              STA     XXA9          ; SET START BIT CHEC
K FLAG, SET START BIT RECEIVED
11681  F06E  60                 RTS
11682  F06F                     
11683  F06F                     
11684  F06F              ;************************************************
***********************************;
11685  F06F              ;
11686  F06F              ; ??
11687  F06F              
11688  F06F              XXF06F = *
11689  F06F  AC 9B 02           LDY     XX029B          ; GET INDEX TO RX 
BUFFER END
11690  F072  C8                 INY                    ; INCREMENT INDEX
11691  F073  CC 9C 02           CPY     XX029C          ; COMPARE WITH IND
EX TO RX BUFFER START
11692  F076  F0 2A              BEQ     XXF0A2          ; IF BUFFER FULL G
O DO RX OVERRUN ERROR
11693  F078                     
11694  F078  8C 9B 02           STY     XX029B          ; SAVE INDEX TO RX
 BUFFER END
11695  F07B  88                 DEY                    ; DECREMENT INDEX
11696  F07C  A5 AA              LDA     XXAA          ; GET ASSEMBLED BYTE

11697  F07E  AE 98 02           LDX     XX0298          ; GET BIT COUNT
11698  F081              XXF081 = *
11699  F081  E0 09              CPX     #$09               ; COMPARE WITH 
BYTE + STOP
11700  F083  F0 04              BEQ     XXF089          ; BRANCH IF ALL NI
NE BITS RECEIVED
11701  F085                     
11702  F085  4A                 LSR A                  ; ELSE SHIFT BYTE
11703  F086  E8                 INX                    ; INCREMENT BIT COU
NT
11704  F087  D0 F8              BNE     XXF081          ; LOOP, BRANCH ALW
AYS
11705  F089                     
11706  F089              XXF089 = *
11707  F089  91 F7              STA     (XXF7),Y          ; SAVE RECEIVED 
BYTE TO RX BUFFER
11708  F08B  A9 20              LDA     #$20               ; MASK 00X0 000
0, PARITY ENABLE BIT
11709  F08D  2C 94 02           BIT     XX0294          ; TEST PSEUDO 6551
 COMMAND REGISTER
11710  F090  F0 B9              BEQ     XXF04B          ; BRANCH IF PARITY
 DISABLED
11711  F092                     
11712  F092  30 B6              BMI     XXF04A          ; BRANCH IF MARK O
R SPACE PARITY
11713  F094                     
11714  F094  A5 A7              LDA     XXA7          ; GET RECEIVER INPUT
 BIT TEMPORARY STORAGE
11715  F096  45 AB              EOR     XXAB          ;.
11716  F098  F0 03              BEQ     XXF09D          ;.
11717  F09A                     
11718  F09A  70 AE              BVS     XXF04A          ;.
11719  F09C                     






****;O......PAGE 0229

LINE# LOC   CODE        LINE


11720  F09C  2C                 .BYTE     $2C               ; MAKES NEXT L
INE BIT XXAB50
11721  F09D              XXF09D = *
11722  F09D  50 AB              BVC     XXF04A          ;.
11723  F09F                     
11724  F09F  A9 01              LDA     #$01               ; SET RX PARITY
 ERROR
11725  F0A1  2C                 .BYTE     $2C               ; MAKES NEXT L
INE BIT XX04A9
11726  F0A2                     
11727  F0A2              XXF0A2 = *
11728  F0A2  A9 04              LDA     #$04               ; SET RX OVERRU
N ERROR
11729  F0A4  2C                 .BYTE     $2C               ; MAKES NEXT L
INE BIT XX80A9
11730  F0A5                     
11731  F0A5              XXF0A5 = *
11732  F0A5  A9 80              LDA     #$80               ; RX BREAK ERRO
R
11733  F0A7  2C                 .BYTE     $2C               ; MAKES NEXT L
INE BIT XX02A9
11734  F0A8                     
11735  F0A8              XXF0A8 = *
11736  F0A8  A9 02              LDA     #$02               ; RX FRAME ERRO
R
11737  F0AA  0D 97 02           ORA     XX0297          ; OR WITH RS232 ST
ATUS BYTE
11738  F0AD  8D 97 02           STA     XX0297          ; SAVE RS232 STATU
S BYTE
11739  F0B0  4C 5B F0           JMP     XXF05B          ;.
11740  F0B3                     
11741  F0B3              XXF0B3 = *
11742  F0B3  A5 AA              LDA     XXAA          ;.
11743  F0B5  D0 F1              BNE     XXF0A8          ; IF ?? DO FRAME E
RROR
11744  F0B7                     
11745  F0B7  F0 EC              BEQ     XXF0A5          ; ELSE DO BREAK ER
ROR, BRANCH ALWAYS
11746  F0B9                     
11747  F0B9                     
11748  F0B9              ;************************************************
***********************************;
11749  F0B9              ;
11750  F0B9              ; DO ILLEGAL DEVICE NUMBER
11751  F0B9              
11752  F0B9              XXF0B9 = *
11753  F0B9  4C 96 F7           JMP     XXF796          ; DO ILLEGAL DEVIC
E NUMBER AND RETURN
11754  F0BC                     
11755  F0BC                     
11756  F0BC              ;************************************************
***********************************;
11757  F0BC              ;
11758  F0BC              ; OPEN RS232 CHANNEL FOR OUTPUT
11759  F0BC              
11760  F0BC              XXF0BC = *
11761  F0BC  85 9A              STA     XX9A          ; SAVE OUTPUT DEVICE
 NUMBER
11762  F0BE  AD 94 02           LDA     XX0294          ; GET PSEUDO 6551 
COMMAND REGISTER
11763  F0C1  4A                 LSR A                  ; SHIFT HANDSHAKE B
IT TO CARRY
11764  F0C2  90 27              BCC     XXF0EB          ; BRANCH IF 3 LINE
 INTERFACE
11765  F0C4                     
11766  F0C4  A9 02              LDA     #$02               ; MASK FOR RTS 
OUT
11767  F0C6  2C 10 91           BIT     XX9110          ; TEST VIA 1 DRB
11768  F0C9  10 1D              BPL     XXF0E8          ; IF DSR = 0 SET D
SR NOT PRESENT AND EXIT
11769  F0CB                     
11770  F0CB  D0 1E              BNE     XXF0EB          ; IF RTS = 1 JUST 
EXIT
11771  F0CD                     
11772  F0CD              XXF0CD = *
11773  F0CD  AD 1E 91           LDA     XX911E          ; GET VIA 1 IER
11774  F0D0  29 30              AND     #$30               ; MASK 00XX 000
0, T2 AND CB1 INTERRUPTS






****;O......PAGE 0230

LINE# LOC   CODE        LINE


11775  F0D2  D0 F9              BNE     XXF0CD          ; LOOP WHILE EITHE
R ENABLED
11776  F0D4                     
11777  F0D4              XXF0D4 = *
11778  F0D4  2C 10 91           BIT     XX9110          ; TEST VIA 1 DRB
11779  F0D7  70 FB              BVS     XXF0D4          ; LOOP WHILE CTS H
IGH
11780  F0D9                     
11781  F0D9  AD 10 91           LDA     XX9110          ; GET VIA 1 DRB
11782  F0DC  09 02              ORA     #$02               ; SET RTS HIGH
11783  F0DE  8D 10 91           STA     XX9110          ; SAVE VIA 1 DRB
11784  F0E1              XXF0E1 = *
11785  F0E1  2C 10 91           BIT     XX9110          ; TEST VIA 1 DRB
11786  F0E4  70 05              BVS     XXF0EB          ; EXIT IF CTS HIGH

11787  F0E6                     
11788  F0E6  30 F9              BMI     XXF0E1          ; LOOP WHILE DSR H
IGH
11789  F0E8                     
11790  F0E8              XXF0E8 = *
11791  F0E8  20 16 F0           JSR     XXF016          ; SET DSR SIGNAL N
OT PRESENT
11792  F0EB              XXF0EB = *
11793  F0EB  18                 CLC                    ; FLAG OK
11794  F0EC  60                 RTS
11795  F0ED                     
11796  F0ED                     
11797  F0ED              ;************************************************
***********************************;
11798  F0ED              ;
11799  F0ED              ; SEND BYTE TO RS232 BUFFER
11800  F0ED              
11801  F0ED              XXF0ED = *
11802  F0ED  AC 9E 02           LDY     XX029E          ; GET INDEX TO TX 
BUFFER END
11803  F0F0  C8                 INY                    ; + 1
11804  F0F1  CC 9D 02           CPY     XX029D          ; COMPARE WITH IND
EX TO TX BUFFER START
11805  F0F4  F0 F7              BEQ     XXF0ED          ; LOOP WHILE BUFFE
R FULL
11806  F0F6                     
11807  F0F6  8C 9E 02           STY     XX029E          ; SET INDEX TO TX 
BUFFER END
11808  F0F9  88                 DEY                    ; INDEX TO AVAILABL
E BUFFER BYTE
11809  F0FA  91 F9              STA     (XXF9),Y          ; SAVE BYTE TO B
UFFER
11810  F0FC  2C 1E 91           BIT     XX911E          ; TEST VIA 1 IER
11811  F0FF  50 01              BVC     XXF102          ; BRANCH IF T1 NOT
 ENABLED
11812  F101                     
11813  F101  60                 RTS
11814  F102                     
11815  F102              XXF102 = *
11816  F102  AD 99 02           LDA     XX0299          ; GET BAUD RATE BI
T TIME LOW BYTE
11817  F105  8D 14 91           STA     XX9114          ; SET VIA 1 T1C_L
11818  F108  AD 9A 02           LDA     XX029A          ; GET BAUD RATE BI
T TIME HIGH BYTE
11819  F10B  8D 15 91           STA     XX9115          ; SET VIA 1 T1C_H
11820  F10E  A9 C0              LDA     #$C0               ; ENABLE T1 INT
ERRUPT
11821  F110  8D 1E 91           STA     XX911E          ; SET VIA 1 IER
11822  F113  4C EE EF           JMP     XXEFEE          ; SETUP NEXT RS232
 TX BYTE AND RETURN
11823  F116                     
11824  F116                     
11825  F116              ;************************************************
***********************************;
11826  F116              ;
11827  F116              ; INPUT FROM RS232 BUFFER
11828  F116              
11829  F116              XXF116 = *






****;O......PAGE 0231

LINE# LOC   CODE        LINE


11830  F116  85 99              STA     XX99          ; SAVE INPUT DEVICE 
NUMBER
11831  F118  AD 94 02           LDA     XX0294          ; GET PSEUDO 6551 
COMMAND REGISTER
11832  F11B  4A                 LSR A                  ;.
11833  F11C  90 28              BCC     XXF146          ; BRANCH IF 3 LINE
 INTERFACE
11834  F11E                     
11835  F11E  29 08              AND     #$08               ; MASK DUPLEX B
IT, PSEUDO 6551 COMMAND IS >> 1
11836  F120  F0 24              BEQ     XXF146          ; BRANCH IF FULL D
UPLEX
11837  F122                     
11838  F122  A9 02              LDA     #$02               ;.
11839  F124  2C 10 91           BIT     XX9110          ; TEST VIA 1 DRB
11840  F127  10 BF              BPL     XXF0E8          ;.
11841  F129                     
11842  F129  F0 19              BEQ     XXF144          ;.
11843  F12B                     
11844  F12B              XXF12B = *
11845  F12B  2C 1E 91           BIT     XX911E          ; TEST VIA 1 IER
11846  F12E  70 FB              BVS     XXF12B          ; LOOP WHILE T1 IN
TERRUPT ENABLED
11847  F130                     
11848  F130  AD 10 91           LDA     XX9110          ; GET VIA 1 DRB
11849  F133  29 FD              AND     #$FD               ; MASK XXXX XX0
X, CLEAR RTS OUT
11850  F135  8D 10 91           STA     XX9110          ; SAVE VIA 1 DRB
11851  F138              XXF138 = *
11852  F138  AD 10 91           LDA     XX9110          ; GET VIA 1 DRB
11853  F13B  29 04              AND     #$04               ; MASK XXXX X1X
X, DTR
11854  F13D  F0 F9              BEQ     XXF138          ; LOOP WHILE DTR L
OW
11855  F13F                     
11856  F13F              XXF13F = *
11857  F13F  A9 90              LDA     #$90               ; ENABLE CB1 IN
TERRUPT
11858  F141  8D 1E 91           STA     XX911E          ; SET VIA 1 IER
11859  F144              XXF144 = *
11860  F144  18                 CLC                    ;.
11861  F145  60                 RTS
11862  F146                     
11863  F146              XXF146 = *
11864  F146  AD 1E 91           LDA     XX911E          ; GET VIA 1 IER
11865  F149  29 30              AND     #$30               ; MASK 0XX0 000
0, T1 AND T2 INTERRUPTS
11866  F14B  F0 F2              BEQ     XXF13F          ; IF BOTH INTERRUP
TS DISABLED GO ENABLE CB1
11867  F14D                                     ; INTERRUPT AND EXIT
11868  F14D                     
11869  F14D  18                 CLC                    ;.
11870  F14E  60                 RTS
11871  F14F                     
11872  F14F                     
11873  F14F              ;************************************************
***********************************;
11874  F14F              ;
11875  F14F              ; GET BYTE FROM RS232 BUFFER
11876  F14F              
11877  F14F              XXF14F = *
11878  F14F  AC 9C 02           LDY     XX029C          ; GET INDEX TO RX 
BUFFER START
11879  F152  CC 9B 02           CPY     XX029B          ; COMPARE WITH IND
EX TO RX BUFFER END
11880  F155  F0 06              BEQ     XXF15D          ; RETURN NULL IF B
UFFER EMPTY
11881  F157                     
11882  F157  B1 F7              LDA     (XXF7),Y          ; GET BYTE FROM 
RX BUFFER
11883  F159  EE 9C 02           INC     XX029C          ; INCREMENT INDEX 
TO RX BUFFER START
11884  F15C  60                 RTS






****;O......PAGE 0232

LINE# LOC   CODE        LINE


11885  F15D                     
11886  F15D              XXF15D = *
11887  F15D  A9 00              LDA     #$00               ; RETURN NULL
11888  F15F  60                 RTS
11889  F160                     
11890  F160                     
11891  F160              ;************************************************
***********************************;
11892  F160              ;
11893  F160              ; CHECK RS232 BUS IDLE
11894  F160              
11895  F160              XXF160 = *
11896  F160  48                 PHA                    ; SAVE A
11897  F161  AD 1E 91           LDA     XX911E          ; GET VIA 1 IER
11898  F164  F0 0C              BEQ     XXF172          ; BRANCH IF NO INT
ERRUPTS ENABLED. THIS BRANCH WILL
11899  F166                                     ; NEVER BE TAKEN AS B7 OF 
IER ALWAYS READS AS 1
11900  F166                                     ; ACCORDING TO THE 6522 DA
TA SHEET
11901  F166              XXF166 = *
11902  F166  AD 1E 91           LDA     XX911E          ; GET VIA 1 IER
11903  F169  29 60              AND     #$60               ; MASK 0XX0 000
0, T1 AND T2 INTERRUPTS
11904  F16B  D0 F9              BNE     XXF166          ; LOOP IF T1 OR T2
 ACTIVE
11905  F16D                     
11906  F16D  A9 10              LDA     #$10               ; DISABLE CB1 I
NTERRUPT
11907  F16F  8D 1E 91           STA     XX911E          ; SET VIA 1 IER
11908  F172              XXF172 = *
11909  F172  68                 PLA                    ; RESTORE A
11910  F173  60                 RTS
11911  F174                     
11912  F174                     
11913  F174              ;************************************************
***********************************;
11914  F174              ;
11915  F174              ; KERNEL I/O MESSAGES
11916  F174              
11917  F174              XXF174 = *
11918  F174  0D                 .BYTE     $0D,'I/O ERROR ',$A3            
 ;'#'+$80
11918  F175  49 2F 
11918  F17F  A3 
11919  F180              XXF180 = *
11920  F180  0D                 .BYTE     $0D,'SEARCHING',$A0             
 ;' '+$80
11920  F181  53 45 
11920  F18A  A0 
11921  F18B              XXF18B = *
11922  F18B  46 4F 52           .BYTE     'FOR',$A0                       
 ;' '+$80
11922  F18E  A0 
11923  F18F              XXF18F = *
11924  F18F  0D                 .BYTE     $0D,'PRESS PLAY ON TAP',$C5     
 ;'E'+$80
11924  F190  50 52 
11924  F1A1  C5 
11925  F1A2              XXF1A2 = *
11926  F1A2  50 52              .BYTE     'PRESS RECORD & PLAY ON TAP',$C5
 ;'E'+$80
11926  F1BC  C5 
11927  F1BD              XXF1BD = *
11928  F1BD  0D                 .BYTE     $0D,'LOADIN',$C7                
 ;'G'+$80
11928  F1BE  4C 4F 
11928  F1C4  C7 
11929  F1C5              XXF1C5 = *






****;O......PAGE 0233

LINE# LOC   CODE        LINE


11930  F1C5  0D                 .BYTE     $0D,'SAVING',$A0                
 ;' '+$80
11930  F1C6  53 41 
11930  F1CC  A0 
11931  F1CD              XXF1CD = *
11932  F1CD  0D                 .BYTE     $0D,'VERIFYIN',$C7              
 ;'G'+$80
11932  F1CE  56 45 
11932  F1D6  C7 
11933  F1D7              XXF1D7 = *
11934  F1D7  0D                 .BYTE     $0D,'FOUND',$A0                 
 ;' '+$80
11934  F1D8  46 4F 
11934  F1DD  A0 
11935  F1DE              XXF1DE = *
11936  F1DE  0D                 .BYTE     $0D,'OK',$0D+$80
11936  F1DF  4F 4B 
11936  F1E1  8D 
11937  F1E2                     
11938  F1E2                     
11939  F1E2              ;************************************************
***********************************;
11940  F1E2              ;
11941  F1E2              ; DISPLAY CONTROL I/O MESSAGE IF IN DIRECT MODE
11942  F1E2              
11943  F1E2              XXF1E2 = *
11944  F1E2  24 9D              BIT     XX9D          ; TEST MESSAGE MODE 
FLAG
11945  F1E4  10 0D              BPL     XXF1F3          ; EXIT IF CONTROL 
MESSAGES OFF
11946  F1E6                     
11947  F1E6              ; DISPLAY KERNEL I/O MESSAGE
11948  F1E6              
11949  F1E6              XXF1E6 = *
11950  F1E6  B9 74 F1           LDA     XXF174,Y          ; GET BYTE FROM 
MESSAGE TABLE
11951  F1E9  08                 PHP                    ; SAVE STATUS
11952  F1EA  29 7F              AND     #$7F               ; CLEAR B7
11953  F1EC  20 D2 FF           JSR     XXFFD2          ; OUTPUT CHARACTER
 TO CHANNEL
11954  F1EF  C8                 INY                    ; INCREMENT INDEX
11955  F1F0  28                 PLP                    ; RESTORE STATUS
11956  F1F1  10 F3              BPL     XXF1E6          ; LOOP IF NOT END 
OF MESSAGE
11957  F1F3                     
11958  F1F3              XXF1F3 = *
11959  F1F3  18                 CLC                    ;.
11960  F1F4  60                 RTS
11961  F1F5                     
11962  F1F5                     
11963  F1F5              ;************************************************
***********************************;
11964  F1F5              ;
11965  F1F5              ; GET A CHARACTER FROM THE INPUT DEVICE
11966  F1F5              
11967  F1F5              ; IN PRACTICE THIS ROUTINE OPERATES IDENTICALLY T
O THE CHRIN ROUTINE, XXFFCF,
11968  F1F5              ; FOR ALL DEVICES EXCEPT FOR THE KEYBOARD. IF THE
 KEYBOARD IS THE CURRENT INPUT
11969  F1F5              ; DEVICE THIS ROUTINE WILL GET ONE CHARACTER FROM
 THE KEYBOARD BUFFER. IT DEPENDS
11970  F1F5              ; ON THE IRQ ROUTINE TO READ THE KEYBOARD AND PUT
 CHARACTERS INTO THE BUFFER.
11971  F1F5              
11972  F1F5              ; IF THE KEYBOARD BUFFER IS EMPTY THE VALUE RETUR
NED IN THE ACCUMULATOR WILL BE ZERO
11973  F1F5              
11974  F1F5              XXF1F5 = *
11975  F1F5  A5 99              LDA     XX99          ; GET INPUT DEVICE N
UMBER
11976  F1F7  D0 08              BNE     XXF201          ; BRANCH IF NOT KE
YBOARD






ZERO;O......PAGE 0234

LINE# LOC   CODE        LINE


11977  F1F9                     
11978  F1F9                                     ; INPUT DEVICE WAS KEYBOAR
D
11979  F1F9  A5 C6              LDA     XXC6          ; GET KEYBOARD BUFFE
R LENGTH
11980  F1FB  F0 6D              BEQ     XXF26A          ; IF BUFFER EMPTY 
GO FLAG NO BYTE AND RETURN
11981  F1FD                     
11982  F1FD  78                 SEI                    ; DISABLE INTERRUPT
S
11983  F1FE  4C CF E5           JMP     XXE5CF          ; INPUT FROM KEYBO
ARD BUFFER AND RETURN
11984  F201                     
11985  F201                                     ; INPUT DEVICE WAS NOT KEY
BOARD
11986  F201              XXF201 = *
11987  F201  C9 02              CMP     #$02               ; COMPARE DEVIC
E WITH RS232 DEVICE
11988  F203  D0 18              BNE     XXF21D          ; BRANCH IF NOT RS
232 DEVICE
11989  F205                     
11990  F205                                     ; INPUT DEVICE IS RS232 DE
VICE
11991  F205              XXF205 = *
11992  F205  84 97              STY     XX97          ; SAVE Y
11993  F207  20 4F F1           JSR     XXF14F          ; GET BYTE FROM RS
232 BUFFER
11994  F20A  A4 97              LDY     XX97          ; RESTORE Y
11995  F20C  18                 CLC                    ; FLAG NO ERROR
11996  F20D  60                 RTS
11997  F20E                     
11998  F20E                     
11999  F20E              ;************************************************
***********************************;
12000  F20E              ;
12001  F20E              ; INPUT CHARACTER FROM CHANNEL
12002  F20E              
12003  F20E              ; THIS ROUTINE WILL GET A BYTE OF DATA FROM THE C
HANNEL ALREADY SET UP AS THE INPUT
12004  F20E              ; CHANNEL BY THE CHKIN ROUTINE, XXFFC6.
12005  F20E              
12006  F20E              ; IF CHKIN, XXFFC6, HAS NOT BEEN USED TO DEFINE A
NOTHER INPUT CHANNEL THE DATA IS
12007  F20E              ; EXPECTED TO BE FROM THE KEYBOARD. THE DATA BYTE
 IS RETURNED IN THE ACCUMULATOR. THE
12008  F20E              ; CHANNEL REMAINS OPEN AFTER THE CALL.
12009  F20E              
12010  F20E              ; INPUT FROM THE KEYBOARD IS HANDLED IN A SPECIAL
 WAY. FIRST, THE CURSOR IS TURNED ON
12011  F20E              ; AND IT WILL BLINK UNTIL A CARRIAGE RETURN IS TY
PED ON THE KEYBOARD. ALL CHARACTERS
12012  F20E              ; ON THE LOGICAL LINE, UP TO 88 CHARACTERS, WILL 
BE STORED IN THE BASIC INPUT BUFFER.
12013  F20E              ; THEN THE CHARACTERS CAN BE RETURNED ONE AT A TI
ME BY CALLING THIS ROUTINE ONCE FOR
12014  F20E              ; EACH CHARACTER. WHEN THE CARRIAGE RETURN IS RET
URNED THE ENTIRE LINE HAS BEEN
12015  F20E              ; PROCESSED. THE NEXT TIME THIS ROUTINE IS CALLED
 THE WHOLE PROCESS BEGINS AGAIN.
12016  F20E              
12017  F20E              XXF20E = *
12018  F20E  A5 99              LDA     XX99          ; GET INPUT DEVICE N
UMBER
12019  F210  D0 0B              BNE     XXF21D          ; IF IT'S NOT THE 
KEYBOARD CONTINUE
12020  F212                     
12021  F212                                     ; THE INPUT DEVICE IS THE 
KEYBOARD
12022  F212  A5 D3              LDA     XXD3          ; GET CURSOR COLUMN
12023  F214  85 CA              STA     XXCA          ; SET INPUT CURSOR C
OLUMN
12024  F216  A5 D6              LDA     XXD6          ; GET CURSOR ROW
12025  F218  85 C9              STA     XXC9          ; SET INPUT CURSOR R
OW
12026  F21A  4C 4F E6           JMP     XXE64F          ; GO GET INPUT FRO
M THE KEYBOARD
12027  F21D                     
12028  F21D              ; THE INPUT DEVICE WAS NOT THE KEYBOARD
12029  F21D              
12030  F21D              XXF21D = *
12031  F21D  C9 03              CMP     #$03               ; COMPARE DEVIC
E NUMBER WITH SCREEN






.FOR.O......PAGE 0235

LINE# LOC   CODE        LINE


12032  F21F  D0 09              BNE     XXF22A          ; IF IT'S NOT THE 
SCREEN CONTINUE
12033  F221                     
12034  F221                                     ; THE INPUT DEVICE IS THE 
SCREEN
12035  F221  85 D0              STA     XXD0          ; INPUT FROM KEYBOAR
D OR SCREEN, $XX = SCREEN,
12036  F223                                     ; $00 = KEYBOARD
12037  F223  A5 D5              LDA     XXD5          ; GET CURRENT SCREEN
 LINE LENGTH
12038  F225  85 C8              STA     XXC8          ; SAVE INPUT [EOL] P
OINTER
12039  F227  4C 4F E6           JMP     XXE64F          ; GO GET INPUT FRO
M THE SCREEN
12040  F22A                     
12041  F22A              ; THE INPUT DEVICE WAS NOT THE SCREEN
12042  F22A              
12043  F22A              XXF22A = *
12044  F22A  B0 38              BCS     XXF264          ; IF INPUT DEVICE 
IS THE SERIAL BUS GO HANDLE IT
12045  F22C                     
12046  F22C              ; THE INPUT DEVICE IS < THE SCREEN DO MUST BE THE
 RS232 OR TAPE DEVICE
12047  F22C              
12048  F22C  C9 02              CMP     #$02               ; COMPARE DEVIC
E WITH RS232 DEVICE
12049  F22E  F0 3F              BEQ     XXF26F          ; IF IT'S THE RS23
2 DEVICE GO HANDLE IT
12050  F230                     
12051  F230              ; ELSE THERE'S ONLY THE TAPE DEVICE LEFT ..
12052  F230              
12053  F230  86 97              STX     XX97          ; SAVE X
12054  F232  20 50 F2           JSR     XXF250          ; GET BYTE FROM TA
PE
12055  F235  B0 16              BCS     XXF24D          ; EXIT IF ERROR
12056  F237                     
12057  F237  48                 PHA                    ; SAVE BYTE
12058  F238  20 50 F2           JSR     XXF250          ; GET NEXT BYTE FR
OM TAPE
12059  F23B  B0 0D              BCS     XXF24A          ; EXIT IF ERROR
12060  F23D                     
12061  F23D  D0 05              BNE     XXF244          ; BRANCH IF END RE
ACHED
12062  F23F                     
12063  F23F  A9 40              LDA     #$40               ; SET [EOF] BIT

12064  F241  20 6A FE           JSR     XXFE6A          ; OR INTO SERIAL S
TATUS BYTE
12065  F244              XXF244 = *
12066  F244  C6 A6              DEC     XXA6          ; DECREMENT TAPE BUF
FER INDEX
12067  F246  A6 97              LDX     XX97          ; RESTORE X
12068  F248  68                 PLA                    ; RESTORE SAVED BYT
E
12069  F249  60                 RTS
12070  F24A                     
12071  F24A              ; ERROR EXIT FROM INPUT CHARACTER
12072  F24A              
12073  F24A              XXF24A = *
12074  F24A  AA                 TAX                    ; COPY ERROR BYTE ?
?
12075  F24B  68                 PLA                    ; DUMP SAVED BYTE
12076  F24C  8A                 TXA                    ; RESTORE ERROR BYT
E ??
12077  F24D              XXF24D = *
12078  F24D  A6 97              LDX     XX97          ; RESTORE X
12079  F24F  60                 RTS
12080  F250                     
12081  F250                     
12082  F250              ;************************************************
***********************************;
12083  F250              ;
12084  F250              ; GET BYTE FROM TAPE
12085  F250              
12086  F250              XXF250 = *






****;O......PAGE 0236

LINE# LOC   CODE        LINE


12087  F250  20 8A F8           JSR     XXF88A          ; BUMP TAPE POINTE
R
12088  F253  D0 0B              BNE     XXF260          ; IF NOT END GET N
EXT BYTE AND EXIT
12089  F255                     
12090  F255  20 C0 F8           JSR     XXF8C0          ; INITIATE TAPE RE
AD
12091  F258  B0 11              BCS     XXF26B          ; EXIT IF ERROR FL
AGGED
12092  F25A                     
12093  F25A  A9 00              LDA     #$00               ; CLEAR A
12094  F25C  85 A6              STA     XXA6          ; CLEAR TAPE BUFFER 
INDEX
12095  F25E  F0 F0              BEQ     XXF250          ; LOOP, BRANCH ALW
AYS
12096  F260                     
12097  F260              XXF260 = *
12098  F260  B1 B2              LDA     (XXB2),Y          ; GET NEXT BYTE 
FROM BUFFER
12099  F262  18                 CLC                    ; FLAG NO ERROR
12100  F263  60                 RTS
12101  F264                     
12102  F264                     
12103  F264              ;************************************************
***********************************;
12104  F264              ;
12105  F264              ; THE INPUT DEVICE WAS THE SERIAL BUS
12106  F264              
12107  F264              XXF264 = *
12108  F264  A5 90              LDA     XX90          ; GET SERIAL STATUS 
BYTE
12109  F266  F0 04              BEQ     XXF26C          ; IF NO ERRORS FLA
GGED GO INPUT BYTE AND RETURN
12110  F268                     
12111  F268  A9 0D              LDA     #$0D               ; ELSE RETURN [
EOL]
12112  F26A              XXF26A = *
12113  F26A  18                 CLC                    ; FLAG NO ERROR
12114  F26B              XXF26B = *
12115  F26B  60                 RTS
12116  F26C                     
12117  F26C              XXF26C = *
12118  F26C  4C 19 EF           JMP     XXEF19          ; INPUT A BYTE FRO
M THE SERIAL BUS AND RETURN
12119  F26F                     
12120  F26F                                     ; INPUT DEVICE WAS RS232 D
EVICE
12121  F26F              XXF26F = *
12122  F26F  20 05 F2           JSR     XXF205          ; GET BYTE FROM RS
232 DEVICE
12123  F272  B0 05              BCS     XXF279          ; BRANCH IF ERROR,
 THIS DOESN'T GET TAKEN AS THE LAST
12124  F274                                     ; INSTRUCTION IN THE GET B
YTE FROM RS232 DEVICE ROUTINE
12125  F274                                     ; IS CLC
12126  F274  C9 00              CMP     #$00               ; COMPARE WITH 
NULL
12127  F276  F0 F7              BEQ     XXF26F          ; LOOP IF NULL
12128  F278                     
12129  F278  18                 CLC                    ; FLAG NO ERROR
12130  F279              XXF279 = *
12131  F279  60                 RTS
12132  F27A                     
12133  F27A                     
12134  F27A              ;************************************************
***********************************;
12135  F27A              ;
12136  F27A              ; OUTPUT A CHARACTER TO CHANNEL
12137  F27A              
12138  F27A              ; THIS ROUTINE WILL OUTPUT A CHARACTER TO AN ALRE
ADY OPENED CHANNEL. USE THE OPEN
12139  F27A              ; ROUTINE, XXFFC0, AND THE CHKOUT ROUTINE, XXFFC9
, TO SET UP THE OUTPUT CHANNEL
12140  F27A              ; BEFORE CALLING THIS ROUTINE. IF THESE CALLS ARE
 OMITTED, DATA WILL BE SENT TO THE
12141  F27A              ; DEFAULT OUTPUT DEVICE, DEVICE 3, THE SCREEN. TH
E DATA BYTE TO BE OUTPUT IS LOADED






DED*;O......PAGE 0237

LINE# LOC   CODE        LINE


12142  F27A              ; INTO THE ACCUMULATOR, AND THIS ROUTINE IS CALLE
D. THE DATA IS THEN SENT TO THE
12143  F27A              ; SPECIFIED OUTPUT DEVICE. THE CHANNEL IS LEFT OP
EN AFTER THE CALL.
12144  F27A              
12145  F27A              ; NOTE: CARE MUST BE TAKEN WHEN USING ROUTINE TO 
SEND DATA TO A SERIAL DEVICE SINCE
12146  F27A              ; DATA WILL BE SENT TO ALL OPEN OUTPUT CHANNELS O
N THE BUS. UNLESS THIS IS DESIRED,
12147  F27A              ; ALL OPEN OUTPUT CHANNELS ON THE SERIAL BUS OTHE
R THAN THE ACTUALLY INTENDED
12148  F27A              ; DESTINATION CHANNEL MUST BE CLOSED BY A CALL TO
 THE KERNAL CLOSE CHANNEL ROUTINE.
12149  F27A              
12150  F27A              XXF27A = *
12151  F27A  48                 PHA                    ; SAVE THE CHARACTE
R TO SEND
12152  F27B  A5 9A              LDA     XX9A          ; GET OUTPUT DEVICE 
NUMBER
12153  F27D  C9 03              CMP     #$03               ; COMPARE DEVIC
E NUMBER WITH SCREEN
12154  F27F  D0 04              BNE     XXF285          ; IF OUTPUT DEVICE
 NOT SCREEN CONTINUE
12155  F281                     
12156  F281              ; THE OUTPUT DEVICE IS THE SCREEN
12157  F281              
12158  F281  68                 PLA                    ; RESTORE CHARACTER
 TO SEND
12159  F282  4C 42 E7           JMP     XXE742          ; OUTPUT CHARACTER
 AND RETURN
12160  F285                     
12161  F285              ; THE OUTPUT DEVICE WAS NOT THE SCREEN
12162  F285              
12163  F285              XXF285 = *
12164  F285  90 04              BCC     XXF28B          ; IF OUTPUT DEVICE
 < SCREEN CONTINUE
12165  F287                     
12166  F287              ; THE OUTPUT DEVICE WAS > SCREEN SO IT IS A SERIA
L BUS DEVICE
12167  F287              
12168  F287  68                 PLA                    ; RESTORE CHARACTER
 TO SEND
12169  F288  4C E4 EE           JMP     XXEEE4          ; OUTPUT A BYTE TO
 THE SERIAL BUS AND RETURN
12170  F28B                     
12171  F28B              ; THE OUTPUT DEVICE IS < SCREEN
12172  F28B              
12173  F28B              XXF28B = *
12174  F28B  C9 02              CMP     #$02               ; COMPARE THE D
EVICE WITH RS232 DEVICE
12175  F28D  F0 2A              BEQ     XXF2B9          ; IF OUTPUT DEVICE
 IS RS232 DEVICE GO HANDLE IT
12176  F28F                     
12177  F28F              ; ELSE THE OUTPUT DEVICE IS THE CASSETTE
12178  F28F              
12179  F28F  68                 PLA                    ; RESTORE THE CHARA
CTER TO SEND
12180  F290                     
12181  F290                     
12182  F290              ;************************************************
***********************************;
12183  F290              ;
12184  F290              ; OUTPUT A CHARACTER TO THE CASSETTE
12185  F290              
12186  F290              XXF290 = *
12187  F290  85 9E              STA     XX9E          ; SAVE CHARACTER TO 
CHARACTER BUFFER
12188  F292  48                 PHA                    ; SAVE A
12189  F293  8A                 TXA                    ; COPY X
12190  F294  48                 PHA                    ; SAVE X
12191  F295  98                 TYA                    ; COPY Y
12192  F296  48                 PHA                    ; SAVE Y
12193  F297  20 8A F8           JSR     XXF88A          ; BUMP TAPE POINTE
R
12194  F29A  D0 0E              BNE     XXF2AA          ; IF NOT END SAVE 
NEXT BYTE AND EXIT
12195  F29C                     
12196  F29C  20 E3 F8           JSR     XXF8E3          ; INITIATE TAPE WR
ITE






****;O......PAGE 0238

LINE# LOC   CODE        LINE


12197  F29F  B0 0E              BCS     XXF2AF          ; EXIT IF ERROR
12198  F2A1                     
12199  F2A1  A9 02              LDA     #$02               ; SET DATA BLOC
K TYPE ??
12200  F2A3  A0 00              LDY     #$00               ; CLEAR INDEX
12201  F2A5  91 B2              STA     (XXB2),Y          ; SAVE TYPE TO B
UFFER ??
12202  F2A7  C8                 INY                    ; INCREMENT INDEX
12203  F2A8  84 A6              STY     XXA6          ; SAVE TAPE BUFFER I
NDEX
12204  F2AA              XXF2AA = *
12205  F2AA  A5 9E              LDA     XX9E          ; RESTORE CHARACTER 
FROM CHARACTER BUFFER
12206  F2AC  91 B2              STA     (XXB2),Y          ; SAVE TO BUFFER

12207  F2AE  18                 CLC                    ; FLAG NO ERROR
12208  F2AF              XXF2AF = *
12209  F2AF  68                 PLA                    ; PULL Y
12210  F2B0  A8                 TAY                    ; RESTORE Y
12211  F2B1  68                 PLA                    ; PULL X
12212  F2B2  AA                 TAX                    ; RESTORE X
12213  F2B3  68                 PLA                    ; RESTORE A
12214  F2B4  90 02              BCC     XXF2B8          ; EXIT IF NO ERROR

12215  F2B6                     
12216  F2B6  A9 00              LDA     #$00               ; ELSE CLEAR A
12217  F2B8              XXF2B8 = *
12218  F2B8  60                 RTS
12219  F2B9                     
12220  F2B9                     
12221  F2B9              ;************************************************
***********************************;
12222  F2B9              ;
12223  F2B9              ; THE OUTPUT DEVICE IS RS232 DEVICE
12224  F2B9              
12225  F2B9              XXF2B9 = *
12226  F2B9  68                 PLA                    ; RESTORE CHARACTER
 TO SEND
12227  F2BA  86 97              STX     XX97          ; SAVE X
12228  F2BC  84 9E              STY     XX9E          ; SAVE Y
12229  F2BE  20 ED F0           JSR     XXF0ED          ; SEND BYTE TO RS2
32 BUFFER
12230  F2C1  A6 97              LDX     XX97          ; RESTORE Y
12231  F2C3  A4 9E              LDY     XX9E          ; RESTORE X
12232  F2C5  18                 CLC                    ; FLAG OK
12233  F2C6  60                 RTS
12234  F2C7                     
12235  F2C7                     
12236  F2C7              ;************************************************
***********************************;
12237  F2C7              ;
12238  F2C7              ; OPEN A CHANNEL FOR INPUT
12239  F2C7              
12240  F2C7              ; ANY LOGICAL FILE THAT HAS ALREADY BEEN OPENED B
Y THE OPEN ROUTINE, XXFFC0, CAN BE
12241  F2C7              ; DEFINED AS AN INPUT CHANNEL BY THIS ROUTINE. TH
E DEVICE ON THE CHANNEL MUST BE AN
12242  F2C7              ; INPUT DEVICE OR AN ERROR WILL OCCUR AND THE ROU
TINE WILL ABORT.
12243  F2C7              
12244  F2C7              ; IF YOU ARE GETTING DATA FROM ANYWHERE OTHER THA
N THE KEYBOARD, THIS ROUTINE MUST BE
12245  F2C7              ; CALLED BEFORE USING EITHER THE CHRIN ROUTINE, X
XFFCF, OR THE GETIN ROUTINE,
12246  F2C7              ; XXFFE4. IF YOU ARE GETTING DATA FROM THE KEYBOA
RD AND NO OTHER INPUT CHANNELS ARE
12247  F2C7              ; OPEN THEN THE CALLS TO THIS ROUTINE AND TO THE 
OPEN ROUTINE, XXFFC0, ARE NOT NEEDED.
12248  F2C7              
12249  F2C7              ; WHEN USED WITH A DEVICE ON THE SERIAL BUS THIS 
ROUTINE WILL AUTOMATICALLY SEND THE
12250  F2C7              ; LISTEN ADDRESS SPECIFIED BY THE OPEN ROUTINE, X
XFFC0, AND ANY SECONDARY ADDRESS.
12251  F2C7              






S.HED.......PAGE 0239

LINE# LOC   CODE        LINE


12252  F2C7              ; POSSIBLE ERRORS ARE:
12253  F2C7              ;
12254  F2C7              ;     3 : FILE NOT OPEN
12255  F2C7              ;     5 : DEVICE NOT PRESENT
12256  F2C7              ;     6 : FILE IS NOT AN INPUT FILE
12257  F2C7              
12258  F2C7              XXF2C7 = *
12259  F2C7  20 CF F3           JSR     XXF3CF          ; FIND FILE
12260  F2CA  F0 03              BEQ     XXF2CF          ; BRANCH IF FILE O
PENED
12261  F2CC                     
12262  F2CC  4C 84 F7           JMP     XXF784          ; DO FILE NOT OPEN
 ERROR AND RETURN
12263  F2CF                     
12264  F2CF              XXF2CF = *
12265  F2CF  20 DF F3           JSR     XXF3DF          ; SET FILE DETAILS
 FROM TABLE,X
12266  F2D2  A5 BA              LDA     XXBA          ; GET DEVICE NUMBER
12267  F2D4  F0 16              BEQ     XXF2EC          ; IF DEVICE WAS KE
YBOARD SAVE DEVICE #, FLAG OK AND EXIT
12268  F2D6                     
12269  F2D6  C9 03              CMP     #$03               ; COMPARE DEVIC
E NUMBER WITH SCREEN
12270  F2D8  F0 12              BEQ     XXF2EC          ; IF DEVICE WAS SC
REEN SAVE DEVICE #, FLAG OK AND EXIT
12271  F2DA                     
12272  F2DA  B0 14              BCS     XXF2F0          ; BRANCH IF SERIAL
 BUS DEVICE
12273  F2DC                     
12274  F2DC  C9 02              CMP     #$02               ; COMPARE DEVIC
E WITH RS232 DEVICE
12275  F2DE  D0 03              BNE     XXF2E3          ; BRANCH IF NOT RS
 232 DEVICE
12276  F2E0                     
12277  F2E0  4C 16 F1           JMP     XXF116          ; ELSE GET INPUT F
ROM RS232 BUFFER AND RETURN
12278  F2E3                     
12279  F2E3              XXF2E3 = *
12280  F2E3  A6 B9              LDX     XXB9          ; GET SECONDARY ADDR
ESS
12281  F2E5  E0 60              CPX     #$60               ;.
12282  F2E7  F0 03              BEQ     XXF2EC          ;.
12283  F2E9                     
12284  F2E9  4C 8D F7           JMP     XXF78D          ; DO NOT INPUT FIL
E ERROR AND RETURN
12285  F2EC                     
12286  F2EC              XXF2EC = *
12287  F2EC  85 99              STA     XX99          ; SAVE INPUT DEVICE 
NUMBER
12288  F2EE  18                 CLC                    ; FLAG OK
12289  F2EF  60                 RTS
12290  F2F0                     
12291  F2F0                                     ; DEVICE WAS SERIAL BUS DE
VICE
12292  F2F0              XXF2F0 = *
12293  F2F0  AA                 TAX                    ; COPY DEVICE NUMBE
R TO X
12294  F2F1  20 14 EE           JSR     XXEE14          ; COMMAND A SERIAL
 BUS DEVICE TO TALK
12295  F2F4  A5 B9              LDA     XXB9          ; GET SECONDARY ADDR
ESS
12296  F2F6  10 06              BPL     XXF2FE          ;.
12297  F2F8                     
12298  F2F8  20 D3 EE           JSR     XXEED3          ; WAIT FOR BUS END
 AFTER SEND
12299  F2FB  4C 01 F3           JMP     XXF301          ;.
12300  F2FE                     
12301  F2FE              XXF2FE = *
12302  F2FE  20 CE EE           JSR     XXEECE          ; SEND SECONDARY A
DDRESS AFTER TALK
12303  F301              XXF301 = *
12304  F301  8A                 TXA                    ; COPY DEVICE BACK 
TO A
12305  F302  24 90              BIT     XX90          ; TEST SERIAL STATUS
 BYTE
12306  F304  10 E6              BPL     XXF2EC          ; IF DEVICE PRESEN
T SAVE DEVICE NUMBER AND EXIT






XITIT.......PAGE 0240

LINE# LOC   CODE        LINE


12307  F306                     
12308  F306  4C 8A F7           JMP     XXF78A          ; DO DEVICE NOT PR
ESENT ERROR AND RETURN
12309  F309                     
12310  F309                     
12311  F309              ;************************************************
***********************************;
12312  F309              ;
12313  F309              ; OPEN A CHANNEL FOR OUTPUT
12314  F309              
12315  F309              ; ANY LOGICAL FILE THAT HAS ALREADY BEEN OPENED B
Y THE OPEN ROUTINE, XXFFC0, CAN BE
12316  F309              ; DEFINED AS AN OUTPUT CHANNEL BY THIS ROUTINE TH
E DEVICE ON THE CHANNEL MUST BE AN
12317  F309              ; OUTPUT DEVICE OR AN ERROR WILL OCCUR AND THE RO
UTINE WILL ABORT.
12318  F309              
12319  F309              ; IF YOU ARE SENDING DATA TO ANYWHERE OTHER THAN 
THE SCREEN THIS ROUTINE MUST BE
12320  F309              ; CALLED BEFORE USING THE CHROUT ROUTINE, XXFFD2.
 IF YOU ARE SENDING DATA TO THE
12321  F309              ; SCREEN AND NO OTHER OUTPUT CHANNELS ARE OPEN TH
EN THE CALLS TO THIS ROUTINE AND TO
12322  F309              ; THE OPEN ROUTINE, XXFFC0, ARE NOT NEEDED.
12323  F309              
12324  F309              ; WHEN USED WITH A DEVICE ON THE SERIAL BUS THIS 
ROUTINE WILL AUTOMATICALLY SEND THE
12325  F309              ; LISTEN ADDRESS SPECIFIED BY THE OPEN ROUTINE, X
XFFC0, AND ANY SECONDARY ADDRESS.
12326  F309              
12327  F309              ; POSSIBLE ERRORS ARE:
12328  F309              ;
12329  F309              ;     3 : FILE NOT OPEN
12330  F309              ;     5 : DEVICE NOT PRESENT
12331  F309              ;     7 : FILE IS NOT AN OUTPUT FILE
12332  F309              
12333  F309              XXF309 = *
12334  F309  20 CF F3           JSR     XXF3CF          ; FIND FILE
12335  F30C  F0 03              BEQ     XXF311          ; BRANCH IF FILE F
OUND
12336  F30E                     
12337  F30E  4C 84 F7           JMP     XXF784          ; DO FILE NOT OPEN
 ERROR AND RETURN
12338  F311                     
12339  F311              XXF311 = *
12340  F311  20 DF F3           JSR     XXF3DF          ; SET FILE DETAILS
 FROM TABLE,X
12341  F314  A5 BA              LDA     XXBA          ; GET DEVICE NUMBER
12342  F316  D0 03              BNE     XXF31B          ; BRANCH IF DEVICE
 IS NOT KEYBOARD
12343  F318                     
12344  F318              XXF318 = *
12345  F318  4C 90 F7           JMP     XXF790          ; DO NOT OUTPUT FI
LE ERROR AND RETURN
12346  F31B                     
12347  F31B              XXF31B = *
12348  F31B  C9 03              CMP     #$03               ; COMPARE DEVIC
E NUMBER WITH SCREEN
12349  F31D  F0 0F              BEQ     XXF32E          ; IF SCREEN SAVE O
UTPUT DEVICE NUMBER AND EXIT
12350  F31F                     
12351  F31F  B0 11              BCS     XXF332          ; BRANCH IF > SCRE
EN, SERIAL BUS DEVICE
12352  F321                     
12353  F321  C9 02              CMP     #$02               ; COMPARE DEVIC
E WITH RS232 DEVICE
12354  F323  D0 03              BNE     XXF328          ; BRANCH IF NOT RS
232 DEVICE, MUST BE TAPE
12355  F325                     
12356  F325  4C BC F0           JMP     XXF0BC          ; OPEN RS232 CHANN
EL FOR OUTPUT
12357  F328                     
12358  F328                                     ; OPEN TAPE CHANNEL FOR OU
TPUT
12359  F328              XXF328 = *
12360  F328  A6 B9              LDX     XXB9          ; GET SECONDARY ADDR
ESS
12361  F32A  E0 60              CPX     #$60               ;.






S.HE;.......PAGE 0241

LINE# LOC   CODE        LINE


12362  F32C  F0 EA              BEQ     XXF318          ; IF ?? DO NOT OUT
PUT FILE ERROR AND RETURN
12363  F32E                     
12364  F32E              XXF32E = *
12365  F32E  85 9A              STA     XX9A          ; SAVE OUTPUT DEVICE
 NUMBER
12366  F330  18                 CLC                    ; FLAG OK
12367  F331  60                 RTS
12368  F332                     
12369  F332              XXF332 = *
12370  F332  AA                 TAX                    ; COPY DEVICE NUMBE
R
12371  F333  20 17 EE           JSR     XXEE17          ; COMMAND DEVICES 
ON THE SERIAL BUS TO LISTEN
12372  F336  A5 B9              LDA     XXB9          ; GET SECONDARY ADDR
ESS
12373  F338  10 05              BPL     XXF33F          ; BRANCH IF ADDRES
S TO SEND
12374  F33A                     
12375  F33A  20 C5 EE           JSR     XXEEC5          ; ELSE SET SERIAL 
ATN HIGH
12376  F33D  D0 03              BNE     XXF342          ; BRANCH ALWAYS
12377  F33F                     
12378  F33F              XXF33F = *
12379  F33F  20 C0 EE           JSR     XXEEC0          ; SEND SECONDARY A
DDRESS AFTER LISTEN
12380  F342              XXF342 = *
12381  F342  8A                 TXA                    ; COPY DEVICE NUMBE
R BACK TO A
12382  F343  24 90              BIT     XX90          ; TEST SERIAL STATUS
 BYTE
12383  F345  10 E7              BPL     XXF32E          ; IF DEVICE PRESEN
T SAVE OUTPUT DEVICE NUMBER AND EXIT
12384  F347                     
12385  F347  4C 8A F7           JMP     XXF78A          ; ELSE DO DEVICE N
OT PRESENT ERROR AND RETURN
12386  F34A                     
12387  F34A                     
12388  F34A              ;************************************************
***********************************;
12389  F34A              ;
12390  F34A              ; CLOSE A SPECIFIED LOGICAL FILE
12391  F34A              
12392  F34A              ; THIS ROUTINE IS USED TO CLOSE A LOGICAL FILE AF
TER ALL I/O OPERATIONS HAVE BEEN
12393  F34A              ; COMPLETED ON THAT FILE. THIS ROUTINE IS CALLED 
AFTER THE ACCUMULATOR IS LOADED
12394  F34A              ; WITH THE LOGICAL FILE NUMBER TO BE CLOSED, THE 
SAME NUMBER USED WHEN THE FILE WAS
12395  F34A              ; OPENED USING THE OPEN ROUTINE.
12396  F34A              
12397  F34A              XXF34A = *
12398  F34A  20 D4 F3           JSR     XXF3D4          ; FIND FILE A
12399  F34D  F0 02              BEQ     XXF351          ; IF THE FILE IS F
OUND GO CLOSE IT
12400  F34F                     
12401  F34F  18                 CLC                    ; ELSE THR FILE WAS
 CLOSED SO JUST FLAG OK
12402  F350  60                 RTS
12403  F351                     
12404  F351              ; FOUND THE FILE SO CLOSE IT
12405  F351              
12406  F351              XXF351 = *
12407  F351  20 DF F3           JSR     XXF3DF          ; SET FILE DETAILS
 FROM TABLE,X
12408  F354  8A                 TXA                    ; COPY FILE INDEX T
O A
12409  F355  48                 PHA                    ; SAVE FILE INDEX
12410  F356  A5 BA              LDA     XXBA          ; GET DEVICE NUMBER
12411  F358  F0 57              BEQ     XXF3B1          ; IF $00, KEYBOARD
, RESTORE INDEX AND CLOSE FILE
12412  F35A                     
12413  F35A  C9 03              CMP     #$03               ; COMPARE DEVIC
E NUMBER WITH SCREEN
12414  F35C  F0 53              BEQ     XXF3B1          ; IF SCREEN RESTOR
E INDEX AND CLOSE FILE
12415  F35E                     
12416  F35E  B0 4E              BCS     XXF3AE          ; IF > SCREEN GO D
O SERIAL BUS DEVICE CLOSE






WAS*;.......PAGE 0242

LINE# LOC   CODE        LINE


12417  F360                     
12418  F360  C9 02              CMP     #$02               ; COMPARE DEVIC
E WITH RS232 DEVICE
12419  F362  D0 29              BNE     XXF38D          ; BRANCH IF NOT RS
232 DEVICE
12420  F364                     
12421  F364                                     ; ELSE CLOSE RS232 DEVICE
12422  F364  68                 PLA                    ; RESTORE FILE INDE
X
12423  F365  20 B2 F3           JSR     XXF3B2          ; CLOSE FILE INDEX
 X
12424  F368  A9 7D              LDA     #$7D               ; DISABLE T1, T
2, CB1, CB2, SR AND CA2
12425  F36A  8D 1E 91           STA     XX911E          ; SET VIA 1 IER
12426  F36D  A9 06              LDA     #$06               ; SET DTR AND R
TS HIGH
12427  F36F  8D 10 91           STA     XX9110          ; SET VIA 1 DRB
12428  F372  A9 EE              LDA     #$EE               ; CB2 HIGH, CB1
 -VE EDGE, CA2 HIGH, CA1 -VE EDGE
12429  F374  8D 1C 91           STA     XX911C          ; SET VIA 1 PCR
12430  F377  20 75 FE           JSR     XXFE75          ; READ THE TOP OF 
MEMORY
12431  F37A  A5 F8              LDA     XXF8          ; GET RS232 INPUT BU
FFER POINTER HIGH BYTE
12432  F37C  F0 01              BEQ     XXF37F          ; BRANCH IF NO RS2
32 INPUT BUFFER
12433  F37E                     
12434  F37E  C8                 INY                    ; ELSE RECLAIM RS23
2 INPUT BUFFER MEMORY
12435  F37F              XXF37F = *
12436  F37F  A5 FA              LDA     XXFA          ; GET RS232 OUTPUT B
UFFER POINTER HIGH BYTE
12437  F381  F0 01              BEQ     XXF384          ; BRANCH IF NO RS2
32 OUTPUT BUFFER
12438  F383                     
12439  F383  C8                 INY                    ; ELSE RECLAIM RS23
2 OUTPUT BUFFER MEMORY
12440  F384              XXF384 = *
12441  F384  A9 00              LDA     #$00               ; CLEAR A
12442  F386  85 F8              STA     XXF8          ; CLEAR RS232 INPUT 
BUFFER POINTER HIGH BYTE
12443  F388  85 FA              STA     XXFA          ; CLEAR RS232 OUTPUT
 BUFFER POINTER HIGH BYTE
12444  F38A  4C 3C F5           JMP     XXF53C          ; GO SET TOP OF ME
MORY AND EXIT
12445  F38D                     
12446  F38D              XXF38D = *
12447  F38D  A5 B9              LDA     XXB9          ; GET SECONDARY ADDR
ESS
12448  F38F  29 0F              AND     #$0F               ;.
12449  F391  F0 1E              BEQ     XXF3B1          ; IF ?? RESTORE IN
DEX AND CLOSE FILE
12450  F393                     
12451  F393  20 4D F8           JSR     XXF84D          ; GET TAPE BUFFER 
START POINTER IN XY
12452  F396  A9 00              LDA     #$00               ; CHARACTER $00

12453  F398  20 90 F2           JSR     XXF290          ; OUTPUT CHARACTER
 TO CASSETTE
12454  F39B  4C CF E4           JMP     XXE4CF          ; GO DO CLOSE TAIL

12455  F39E                     
12456  F39E              XXF39E = *
12457  F39E  B0 2E              BCS     XXF3CE          ; JUST EXIT IF ERR
OR
12458  F3A0                     
12459  F3A0  A5 B9              LDA     XXB9          ; GET SECONDARY ADDR
ESS
12460  F3A2  C9 62              CMP     #$62               ;.
12461  F3A4  D0 0B              BNE     XXF3B1          ; IF NOT ?? RESTOR
E INDEX AND CLOSE FILE
12462  F3A6                     
12463  F3A6  A9 05              LDA     #$05               ; SET LOGICAL E
ND OF THE TAPE
12464  F3A8  20 E7 F7           JSR     XXF7E7          ; WRITE TAPE HEADE
R
12465  F3AB  4C B1 F3           JMP     XXF3B1          ; RESTORE INDEX AN
D CLOSE FILE
12466  F3AE                     
12467  F3AE                     
12468  F3AE              ;************************************************
***********************************;
12469  F3AE              ;
12470  F3AE              ; DO SERIAL BUS DEVICE FILE CLOSE
12471  F3AE              






****;.......PAGE 0243

LINE# LOC   CODE        LINE


12472  F3AE              XXF3AE = *
12473  F3AE  20 DA F6           JSR     XXF6DA          ; CLOSE SERIAL BUS
 DEVICE
12474  F3B1              XXF3B1 = *
12475  F3B1  68                 PLA                    ; RESTORE FILE INDE
X
12476  F3B2                     
12477  F3B2                     
12478  F3B2              ;************************************************
***********************************;
12479  F3B2              ;
12480  F3B2              ; CLOSE FILE INDEX X
12481  F3B2              
12482  F3B2              XXF3B2 = *
12483  F3B2  AA                 TAX                    ; COPY INDEX TO FIL
E TO CLOSE
12484  F3B3  C6 98              DEC     XX98          ; DECREMENT OPEN FIL
E COUNT
12485  F3B5  E4 98              CPX     XX98          ; COMPARE INDEX WITH
 OPEN FILE COUNT
12486  F3B7  F0 14              BEQ     XXF3CD          ; EXIT IF EQUAL, L
AST ENTRY WAS CLOSING FILE
12487  F3B9                     
12488  F3B9                                     ; ELSE ENTRY WAS NOT LAST 
IN LIST SO COPY LAST TABLE ENTRY
12489  F3B9                                     ; FILE DETAILS OVER THE DE
TAILS OF THE CLOSING ONE
12490  F3B9  A4 98              LDY     XX98          ; GET OPEN FILE COUN
T AS INDEX
12491  F3BB  B9 59 02           LDA     XX0259,Y          ; GET LAST+1 LOG
ICAL FILE NUMBER FROM LOGICAL FILE TABLE
12492  F3BE  9D 59 02           STA     XX0259,X          ; SAVE LOGICAL F
ILE NUMBER OVER CLOSED FILE
12493  F3C1  B9 63 02           LDA     XX0263,Y          ; GET LAST+1 DEV
ICE NUMBER FROM DEVICE NUMBER TABLE
12494  F3C4  9D 63 02           STA     XX0263,X          ; SAVE DEVICE NU
MBER OVER CLOSED FILE
12495  F3C7  B9 6D 02           LDA     XX026D,Y          ; GET LAST+1 SEC
ONDARY ADDRESS FROM SECONDARY ADDRESS TABLE
12496  F3CA  9D 6D 02           STA     XX026D,X          ; SAVE SECONDARY
 ADDRESS OVER CLOSED FILE
12497  F3CD              XXF3CD = *
12498  F3CD  18                 CLC                    ;.
12499  F3CE              XXF3CE = *
12500  F3CE  60                 RTS
12501  F3CF                     
12502  F3CF                     
12503  F3CF              ;************************************************
***********************************;
12504  F3CF              ;
12505  F3CF              ; FIND FILE
12506  F3CF              
12507  F3CF              XXF3CF = *
12508  F3CF  A9 00              LDA     #$00               ; CLEAR A
12509  F3D1  85 90              STA     XX90          ; CLEAR SERIAL STATU
S BYTE
12510  F3D3  8A                 TXA                    ; COPY LOGICAL FILE
 NUMBER TO A
12511  F3D4                     
12512  F3D4              ; FIND FILE A
12513  F3D4              
12514  F3D4              XXF3D4 = *
12515  F3D4  A6 98              LDX     XX98          ; GET OPEN FILE COUN
T
12516  F3D6              XXF3D6 = *
12517  F3D6  CA                 DEX                    ; DECREMEMNT COUNT 
TO GIVE INDEX
12518  F3D7  30 15              BMI     XXF3EE          ; EXIT IF NO FILES

12519  F3D9                     
12520  F3D9  DD 59 02           CMP     XX0259,X          ; COMPARE LOGICA
L FILE NUMBER WITH TABLE LOGICAL FILE NUMBER
12521  F3DC  D0 F8              BNE     XXF3D6          ; LOOP IF NO MATCH

12522  F3DE                     
12523  F3DE  60                 RTS
12524  F3DF                     
12525  F3DF                     
12526  F3DF              ;************************************************
***********************************;






****;N......PAGE 0244

LINE# LOC   CODE        LINE


12527  F3DF              ;
12528  F3DF              ; SET FILE DETAILS FROM TABLE,X
12529  F3DF              
12530  F3DF              XXF3DF = *
12531  F3DF  BD 59 02           LDA     XX0259,X          ; GET LOGICAL FI
LE FROM LOGICAL FILE TABLE
12532  F3E2  85 B8              STA     XXB8          ; SET LOGICAL FILE
12533  F3E4  BD 63 02           LDA     XX0263,X          ; GET DEVICE NUM
BER FROM DEVICE NUMBER TABLE
12534  F3E7  85 BA              STA     XXBA          ; SET DEVICE NUMBER
12535  F3E9  BD 6D 02           LDA     XX026D,X          ; GET SECONDARY 
ADDRESS FROM SECONDARY ADDRESS TABLE
12536  F3EC  85 B9              STA     XXB9          ; SET SECONDARY ADDR
ESS
12537  F3EE              XXF3EE = *
12538  F3EE  60                 RTS
12539  F3EF                     
12540  F3EF                     
12541  F3EF              ;************************************************
***********************************;
12542  F3EF              ;
12543  F3EF              ; CLOSE ALL CHANNELS AND FILES
12544  F3EF              
12545  F3EF              ; THIS ROUTINE CLOSES ALL OPEN FILES. WHEN THIS R
OUTINE IS CALLED, THE POINTERS INTO
12546  F3EF              ; THE OPEN FILE TABLE ARE RESET, CLOSING ALL FILE
S. ALSO THE ROUTINE AUTOMATICALLY
12547  F3EF              ; RESETS THE I/O CHANNELS.
12548  F3EF              
12549  F3EF              XXF3EF = *
12550  F3EF  A9 00              LDA     #$00               ; CLEAR A
12551  F3F1  85 98              STA     XX98          ; CLEAR OPEN FILE CO
UNT
12552  F3F3                     
12553  F3F3                     
12554  F3F3              ;************************************************
***********************************;
12555  F3F3              ;
12556  F3F3              ; CLOSE INPUT AND OUTPUT CHANNELS
12557  F3F3              
12558  F3F3              ; THIS ROUTINE IS CALLED TO CLEAR ALL OPEN CHANNE
LS AND RESTORE THE I/O CHANNELS TO
12559  F3F3              ; THEIR ORIGINAL DEFAULT VALUES. IT IS USUALLY CA
LLED AFTER OPENING OTHER I/O
12560  F3F3              ; CHANNELS AND USING THEM FOR INPUT/OUTPUT OPERAT
IONS. THE DEFAULT INPUT DEVICE IS
12561  F3F3              ; 0, THE KEYBOARD. THE DEFAULT OUTPUT DEVICE IS 3
, THE SCREEN.
12562  F3F3              
12563  F3F3              ; IF ONE OF THE CHANNELS TO BE CLOSED IS TO THE S
ERIAL PORT, AN UNTALK SIGNAL IS SENT
12564  F3F3              ; FIRST TO CLEAR THE INPUT CHANNEL OR AN UNLISTEN
 IS SENT TO CLEAR THE OUTPUT CHANNEL.
12565  F3F3              ; BY NOT CALLING THIS ROUTINE AND LEAVING LISTENE
R(S) ACTIVE ON THE SERIAL BUS,
12566  F3F3              ; SEVERAL DEVICES CAN RECEIVE THE SAME DATA FROM 
THE VIC AT THE SAME TIME. ONE WAY TO
12567  F3F3              ; TAKE ADVANTAGE OF THIS WOULD BE TO COMMAND THE 
PRINTER TO TALK AND THE DISK TO
12568  F3F3              ; LISTEN. THIS WOULD ALLOW DIRECT PRINTING OF A D
ISK FILE.
12569  F3F3              
12570  F3F3              XXF3F3 = *
12571  F3F3  A2 03              LDX     #$03               ; SET X TO SCRE
EN
12572  F3F5  E4 9A              CPX     XX9A          ; COMPARE OUTPUT DEV
ICE NUMBER WITH SCREEN
12573  F3F7  B0 03              BCS     XXF3FC          ; BRANCH IF >= SCR
EEN
12574  F3F9                     
12575  F3F9                                     ; ELSE WAS SERIAL BUS
12576  F3F9  20 04 EF           JSR     XXEF04          ; COMMAND THE SERI
AL BUS TO UNLISTEN
12577  F3FC              XXF3FC = *
12578  F3FC  E4 99              CPX     XX99          ; COMPARE INPUT DEVI
CE NUMBER WITH SCREEN
12579  F3FE  B0 03              BCS     XXF403          ; BRANCH IF >= SCR
EEN
12580  F400                     
12581  F400                                     ; ELSE WAS SERIAL BUS






AY TO.......PAGE 0245

LINE# LOC   CODE        LINE


12582  F400  20 F6 EE           JSR     XXEEF6          ; COMMAND THE SERI
AL BUS TO UNTALK
12583  F403              XXF403 = *
12584  F403  86 9A              STX     XX9A          ; SET OUTPUT DEVICE 
NUMBER TO SCREEN
12585  F405  A9 00              LDA     #$00               ; SET FOR KEYBO
ARD
12586  F407  85 99              STA     XX99          ; SET INPUT DEVICE N
UMBER TO KEYBOARD
12587  F409  60                 RTS
12588  F40A                     
12589  F40A                     
12590  F40A              ;************************************************
***********************************;
12591  F40A              ;
12592  F40A              ; OPEN A LOGICAL FILE
12593  F40A              
12594  F40A              ; THIS ROUTINE IS USED TO OPEN A LOGICAL FILE. ON
CE THE LOGICAL FILE IS SET UP IT
12595  F40A              ; CAN BE USED FOR INPUT/OUTPUT OPERATIONS. MOST O
F THE I/O KERNAL ROUTINES CALL ON
12596  F40A              ; THIS ROUTINE TO CREATE THE LOGICAL FILES TO OPE
RATE ON. NO ARGUMENTS NEED TO BE
12597  F40A              ; SET UP TO USE THIS ROUTINE, BUT BOTH THE SETLFS
, XXFFBA, AND SETNAM, XXFFBD,
12598  F40A              ; KERNAL ROUTINES MUST BE CALLED BEFORE USING THI
S ROUTINE.
12599  F40A              
12600  F40A              XXF40A = *
12601  F40A  A6 B8              LDX     XXB8          ; GET LOGICAL FILE N
UMBER
12602  F40C  D0 03              BNE     XXF411          ; BRANCH IF THERE 
IS A FILE
12603  F40E                     
12604  F40E  4C 8D F7           JMP     XXF78D          ; ELSE DO NOT INPU
T FILE ERROR AND RETURN
12605  F411                     
12606  F411              XXF411 = *
12607  F411  20 CF F3           JSR     XXF3CF          ; FIND FILE
12608  F414  D0 03              BNE     XXF419          ; BRANCH IF FILE N
OT FOUND
12609  F416                     
12610  F416  4C 81 F7           JMP     XXF781          ; ELSE DO FILE ALR
EADY OPEN ERROR AND RETURN
12611  F419                     
12612  F419              XXF419 = *
12613  F419  A6 98              LDX     XX98          ; GET OPEN FILE COUN
T
12614  F41B  E0 0A              CPX     #$0A               ; COMPARE WITH 
MAX
12615  F41D  90 03              BCC     XXF422          ; BRANCH IF LESS
12616  F41F                     
12617  F41F  4C 7E F7           JMP     XXF77E          ; ELSE DO TOO MANY
 FILES ERROR AND RETURN
12618  F422                     
12619  F422              XXF422 = *
12620  F422  E6 98              INC     XX98          ; INCREMENT OPEN FIL
E COUNT
12621  F424  A5 B8              LDA     XXB8          ; GET LOGICAL FILE N
UMBER
12622  F426  9D 59 02           STA     XX0259,X          ; SAVE TO LOGICA
L FILE TABLE
12623  F429  A5 B9              LDA     XXB9          ; GET SECONDARY ADDR
ESS
12624  F42B  09 60              ORA     #$60               ; OR WITH THE O
PEN CHANNEL COMMAND
12625  F42D  85 B9              STA     XXB9          ; SET SECONDARY ADDR
ESS
12626  F42F  9D 6D 02           STA     XX026D,X          ; SAVE TO SECOND
ARY ADDRESS TABLE
12627  F432  A5 BA              LDA     XXBA          ; GET DEVICE NUMBER
12628  F434  9D 63 02           STA     XX0263,X          ; SAVE TO DEVICE
 NUMBER TABLE
12629  F437  F0 5A              BEQ     XXF493          ; DO OK EXIT IF KE
YBOARD
12630  F439                     
12631  F439  C9 03              CMP     #$03               ; COMPARE DEVIC
E NUMBER WITH SCREEN
12632  F43B  F0 56              BEQ     XXF493          ; DO OK EXIT IF SC
REEN
12633  F43D                     
12634  F43D  90 05              BCC     XXF444          ; BRANCH IF < SCRE
EN, TAPE OR RS232
12635  F43F                     
12636  F43F                                     ; ELSE IS SERIAL BUS DEVIC
E






EN**;.......PAGE 0246

LINE# LOC   CODE        LINE


12637  F43F  20 95 F4           JSR     XXF495          ; SEND SECONDARY A
DDRESS AND FILENAME
12638  F442  90 4F              BCC     XXF493          ; DO OK EXIT
12639  F444                     
12640  F444              XXF444 = *
12641  F444  C9 02              CMP     #$02               ; COMPARE DEVIC
E WITH RS232 DEVICE
12642  F446  D0 03              BNE     XXF44B          ; BRANCH IF NOT RS
232 DEVICE, MUST BE TAPE
12643  F448                     
12644  F448  4C C7 F4           JMP     XXF4C7          ; GO OPEN RS232 DE
VICE AND RETURN
12645  F44B                     
12646  F44B              XXF44B = *
12647  F44B  20 4D F8           JSR     XXF84D          ; GET TAPE BUFFER 
START POINTER IN XY
12648  F44E  B0 03              BCS     XXF453          ; BRANCH IF >= $02
00
12649  F450                     
12650  F450  4C 96 F7           JMP     XXF796          ; DO ILLEGAL DEVIC
E NUMBER AND RETURN
12651  F453                     
12652  F453              XXF453 = *
12653  F453  A5 B9              LDA     XXB9          ; GET SECONDARY ADDR
ESS
12654  F455  29 0F              AND     #$0F               ;.
12655  F457  D0 1F              BNE     XXF478          ;.
12656  F459                     
12657  F459  20 94 F8           JSR     XXF894          ; WAIT FOR PLAY
12658  F45C  B0 36              BCS     XXF494          ; EXIT IF STOP WAS
 PRESSED
12659  F45E                     
12660  F45E  20 47 F6           JSR     XXF647          ; PRINT 'SEARCHING
...'
12661  F461  A5 B7              LDA     XXB7          ; GET FILE NAME LENG
TH
12662  F463  F0 0A              BEQ     XXF46F          ; IF NULL FILE NAM
E JUST GO FIND HEADER
12663  F465                     
12664  F465  20 67 F8           JSR     XXF867          ; FIND SPECIFIC TA
PE HEADER
12665  F468  90 18              BCC     XXF482          ; BRANCH IF NO ERR
OR
12666  F46A                     
12667  F46A  F0 28              BEQ     XXF494          ; EXIT IF ??
12668  F46C                     
12669  F46C              XXF46C = *
12670  F46C  4C 87 F7           JMP     XXF787          ; DO FILE NOT FOUN
D ERROR AND RETURN
12671  F46F                     
12672  F46F              XXF46F = *
12673  F46F  20 AF F7           JSR     XXF7AF          ; FIND TAPE HEADER
, EXIT WITH HEADER IN BUFFER
12674  F472  F0 20              BEQ     XXF494          ; EXIT IF END OF T
APE FOUND
12675  F474                     
12676  F474  90 0C              BCC     XXF482          ;.
12677  F476                     
12678  F476  B0 F4              BCS     XXF46C          ;.
12679  F478                     
12680  F478              XXF478 = *
12681  F478  20 B7 F8           JSR     XXF8B7          ; WAIT FOR PLAY/RE
CORD
12682  F47B  B0 17              BCS     XXF494          ; EXIT IF STOP WAS
 PRESSED
12683  F47D                     
12684  F47D  A9 04              LDA     #$04               ; SET DATA FILE
 HEADER
12685  F47F  20 E7 F7           JSR     XXF7E7          ; WRITE TAPE HEADE
R
12686  F482              XXF482 = *
12687  F482  A9 BF              LDA     #$BF               ;.
12688  F484  A4 B9              LDY     XXB9          ; GET SECONDARY ADDR
ESS
12689  F486  C0 60              CPY     #$60               ;.
12690  F488  F0 07              BEQ     XXF491          ;.
12691  F48A                     






EN**;.......PAGE 0247

LINE# LOC   CODE        LINE


12692  F48A  A0 00              LDY     #$00               ; CLEAR INDEX
12693  F48C  A9 02              LDA     #$02               ;.
12694  F48E  91 B2              STA     (XXB2),Y          ;.SAVE TO TAPE B
UFFER
12695  F490  98                 TYA                    ;.CLEAR A
12696  F491              XXF491 = *
12697  F491  85 A6              STA     XXA6          ;.SAVE TAPE BUFFER I
NDEX
12698  F493              XXF493 = *
12699  F493  18                 CLC                    ; FLAG OK
12700  F494              XXF494 = *
12701  F494  60                 RTS
12702  F495                     
12703  F495                     
12704  F495              ;************************************************
***********************************;
12705  F495              ;
12706  F495              ; SEND SECONDARY ADDRESS AND FILENAME
12707  F495              
12708  F495              XXF495 = *
12709  F495  A5 B9              LDA     XXB9          ; GET SECONDARY ADDR
ESS
12710  F497  30 2C              BMI     XXF4C5          ; OK EXIT IF -VE
12711  F499                     
12712  F499  A4 B7              LDY     XXB7          ; GET FILE NAME LENG
TH
12713  F49B  F0 28              BEQ     XXF4C5          ; OK EXIT IF NULL
12714  F49D                     
12715  F49D  A5 BA              LDA     XXBA          ; GET DEVICE NUMBER
12716  F49F  20 17 EE           JSR     XXEE17          ; COMMAND DEVICES 
ON THE SERIAL BUS TO LISTEN
12717  F4A2  A5 B9              LDA     XXB9          ; GET THE SECONDARY 
ADDRESS
12718  F4A4  09 F0              ORA     #$F0               ; OR WITH THE O
PEN COMMAND
12719  F4A6  20 C0 EE           JSR     XXEEC0          ; SEND SECONDARY A
DDRESS AFTER LISTEN
12720  F4A9  A5 90              LDA     XX90          ; GET SERIAL STATUS 
BYTE
12721  F4AB  10 05              BPL     XXF4B2          ; BRANCH IF DEVICE
 PRESENT
12722  F4AD                     
12723  F4AD  68                 PLA                    ; ELSE DUMP CALLING
 ADDRESS LOW BYTE
12724  F4AE  68                 PLA                    ; DUMP CALLING ADDR
ESS HIGH BYTE
12725  F4AF  4C 8A F7           JMP     XXF78A          ; DO DEVICE NOT PR
ESENT ERROR AND RETURN
12726  F4B2                     
12727  F4B2              XXF4B2 = *
12728  F4B2  A5 B7              LDA     XXB7          ; GET FILE NAME LENG
TH
12729  F4B4  F0 0C              BEQ     XXF4C2          ; BRANCH IF NULL N
AME
12730  F4B6                     
12731  F4B6  A0 00              LDY     #$00               ; CLEAR INDEX
12732  F4B8              XXF4B8 = *
12733  F4B8  B1 BB              LDA     (XXBB),Y          ; GET FILE NAME 
BYTE
12734  F4BA  20 E4 EE           JSR     XXEEE4          ; OUTPUT A BYTE TO
 THE SERIAL BUS
12735  F4BD  C8                 INY                    ; INCREMENT INDEX
12736  F4BE  C4 B7              CPY     XXB7          ; COMPARE WITH FILE 
NAME LENGTH
12737  F4C0  D0 F6              BNE     XXF4B8          ; LOOP IF NOT ALL 
DONE
12738  F4C2                     
12739  F4C2              XXF4C2 = *
12740  F4C2  20 04 EF           JSR     XXEF04          ; COMMAND THE SERI
AL BUS TO UNLISTEN
12741  F4C5              XXF4C5 = *
12742  F4C5  18                 CLC                    ; FLAG OK
12743  F4C6  60                 RTS
12744  F4C7                     
12745  F4C7                     
12746  F4C7              ;************************************************
***********************************;






****;.......PAGE 0248

LINE# LOC   CODE        LINE


12747  F4C7              ;
12748  F4C7              ; OPEN RS232
12749  F4C7              
12750  F4C7              XXF4C7 = *
12751  F4C7  A9 06              LDA     #$06               ; IIII IOOI, DT
R AND RTS ONLY AS OUTPUTS
12752  F4C9  8D 12 91           STA     XX9112          ; SET VIA 1 DDRB
12753  F4CC  8D 10 91           STA     XX9110          ; SET VIA 1 DRB, D
TR AND RTS HIGH
12754  F4CF  A9 EE              LDA     #$EE               ; CB2 HIGH, CB1
 -VE EDGE, CA2 HIGH, CA1 -VE EDGE
12755  F4D1  8D 1C 91           STA     XX911C          ; SET VIA 1 PCR
12756  F4D4  A0 00              LDY     #$00               ; CLEAR INDEX
12757  F4D6  8C 97 02           STY     XX0297          ; CLEAR RS232 STAT
US BYTE
12758  F4D9              XXF4D9 = *
12759  F4D9  C4 B7              CPY     XXB7          ; COMPARE WITH FILE 
NAME LENGTH
12760  F4DB  F0 0A              BEQ     XXF4E7          ; EXIT LOOP IF DON
E
12761  F4DD                     
12762  F4DD  B1 BB              LDA     (XXBB),Y          ; GET FILE NAME 
BYTE
12763  F4DF  99 93 02           STA     XX0293,Y          ; COPY TO 6551 R
EGISTER SET
12764  F4E2  C8                 INY                    ; INCREMENT INDEX
12765  F4E3  C0 04              CPY     #$04               ; COMPARE WITH 
$04
12766  F4E5  D0 F2              BNE     XXF4D9          ; LOOP IF NOT TO 4
 YET
12767  F4E7                     
12768  F4E7              XXF4E7 = *
12769  F4E7  20 27 F0           JSR     XXF027          ; COMPUTE BIT COUN
T
12770  F4EA  8E 98 02           STX     XX0298          ; SAVE BIT COUNT
12771  F4ED  AD 93 02           LDA     XX0293          ; GET PSEUDO 6551 
CONTROL REGISTER
12772  F4F0  29 0F              AND     #$0F               ; MASK 0000 XXX
X, BAUD RATE
12773  F4F2  D0 00              BNE     XXF4F4          ; BRANCH NOWHERE. 
PERHAPS THERE WAS GOING TO BE SOME
12774  F4F4                                     ; ERROR TRAPPING FOR UNIMP
LEMENTED BAUD RATES BUT
12775  F4F4                                     ; THIS WAS EVER DONE
12776  F4F4              XXF4F4 = *
12777  F4F4  0A                 ASL A                  ; * 2
12778  F4F5  AA                 TAX                    ; COPY TO INDEX
12779  F4F6  BD 5A FF           LDA     XXFF5C-2,X     ; GET TIMER CONSTAN
T LOW BYTE
12780  F4F9  0A                 ASL A                  ; * 2
12781  F4FA  A8                 TAY                    ; COPY TO Y
12782  F4FB  BD 5B FF           LDA     XXFF5C-1,X     ; GET TIMER CONSTAN
T HIGH BYTE
12783  F4FE  2A                 ROL A                  ; * 2
12784  F4FF  48                 PHA                    ; SAVE IT
12785  F500  98                 TYA                    ; GET TIMER CONSTAN
T LOW BYTE BACK
12786  F501  69 C8              ADC     #$C8               ; + $C8, CARRY 
CLEARED BY PREVIOUS ROL
12787  F503  8D 99 02           STA     XX0299          ; SAVE BIT CELL TI
ME LOW BYTE
12788  F506  68                 PLA                    ; RESTORE HIGH  BYT
E
12789  F507  69 00              ADC     #$00               ; ADD CARRY
12790  F509  8D 9A 02           STA     XX029A          ; SAVE BIT CELL TI
ME HIGH BYTE
12791  F50C  AD 94 02           LDA     XX0294          ; GET PSEUDO 6551 
COMMAND REGISTER
12792  F50F  4A                 LSR A                  ; SHIFT B0 INTO CB
12793  F510  90 09              BCC     XXF51B          ; BRANCH IF 3 LINE
 INTERFACE
12794  F512                     
12795  F512  AD 20 91           LDA     XX9120          ; GET VIA 2 DRB, T
HIS IS WRONG, THE ADRESS SHOULD BE
12796  F515                                     ; XX9110 WHICH IS VIA 1 WH
ICH IS WHERE THE DSR INPUT
12797  F515                                     ; REALLY IS
12798  F515  0A                 ASL A                  ; SHIFT DSR INTO CB

12799  F516  B0 03              BCS     XXF51B          ; BRANCH IF DSR = 
1
12800  F518                     
12801  F518  4C 16 F0           JMP     XXF016          ; SET DSR SIGNAL N
OT PRESENT AND RETURN






E***;.......PAGE 0249

LINE# LOC   CODE        LINE


12802  F51B                     
12803  F51B              XXF51B = *
12804  F51B  AD 9B 02           LDA     XX029B          ; GET INDEX TO RX 
BUFFER END
12805  F51E  8D 9C 02           STA     XX029C          ; SET INDEX TO RX 
BUFFER START, CLEAR RX BUFFER
12806  F521  AD 9E 02           LDA     XX029E          ; GET INDEX TO TX 
BUFFER END
12807  F524  8D 9D 02           STA     XX029D          ; SET INDEX TO TX 
BUFFER START, CLEAR TX BUFFER
12808  F527  20 75 FE           JSR     XXFE75          ; READ THE TOP OF 
MEMORY
12809  F52A  A5 F8              LDA     XXF8          ; GET RX BUFFER POIN
TER HIGH BYTE
12810  F52C  D0 05              BNE     XXF533          ; BRANCH IF BUFFER
 ALREADY SET
12811  F52E                     
12812  F52E  88                 DEY                    ; DECREMENT TOP OF 
MEMORY HIGH BYTE, 256 BYTE BUFFER
12813  F52F  84 F8              STY     XXF8          ; SET RX BUFFER POIN
TER HIGH BYTE
12814  F531  86 F7              STX     XXF7          ; SET RX BUFFER POIN
TER LOW BYTE
12815  F533              XXF533 = *
12816  F533  A5 FA              LDA     XXFA          ; GET TX BUFFER POIN
TER HIGH BYTE
12817  F535  D0 05              BNE     XXF53C          ; BRANCH IF BUFFER
 ALREADY SET
12818  F537                     
12819  F537  88                 DEY                    ; DECREMENT RX BUFF
ER POINTER HIGH BYTE, 256 BYTE BUFFER
12820  F538  84 FA              STY     XXFA          ; SET TX BUFFER POIN
TER HIGH BYTE
12821  F53A  86 F9              STX     XXF9          ; SET TX BUFFER POIN
TER LOW BYTE
12822  F53C              XXF53C = *
12823  F53C  38                 SEC                    ;.
12824  F53D  A9 F0              LDA     #$F0               ;.
12825  F53F  4C 7B FE           JMP     XXFE7B          ; SET THE TOP OF M
EMORY AND RETURN
12826  F542                     
12827  F542                     
12828  F542              ;************************************************
***********************************;
12829  F542              ;
12830  F542              ; LOAD RAM FROM A DEVICE
12831  F542              
12832  F542              ; THIS ROUTINE WILL LOAD DATA BYTES FROM ANY INPU
T DEVICE DIRECTLY INTO THE MEMORY
12833  F542              ; OF THE COMPUTER. IT CAN ALSO BE USED FOR A VERI
FY OPERATION COMPARING DATA FROM A
12834  F542              ; DEVICE WITH THE DATA ALREADY IN MEMORY, LEAVING
 THE DATA STORED IN RAM UNCHANGED.
12835  F542              
12836  F542              ; THE ACCUMULATOR MUST BE SET TO 0 FOR A LOAD OPE
RATION OR 1 FOR A VERIFY. IF THE
12837  F542              ; INPUT DEVICE WAS OPENED WITH A SECONDARY ADDRES
S OF 0 THE HEADER INFORMATION FROM
12838  F542              ; DEVICE WILL BE IGNORED. IN THIS CASE XY MUST CO
NTAIN THE STARTING ADDRESS FOR THE
12839  F542              ; LOAD. IF THE DEVICE WAS ADDRESSED WITH A SECOND
ARY ADDRESS OF 1 OR 2 THE DATA WILL
12840  F542              ; LOAD INTO MEMORY STARTING AT THE LOCATION SPECI
FIED BY THE HEADER. THIS ROUTINE
12841  F542              ; RETURNS THE ADDRESS OF THE HIGHEST RAM LOCATION
 WHICH WAS LOADED.
12842  F542              
12843  F542              ; BEFORE THIS ROUTINE CAN BE CALLED, THE SETLFS, 
XXFFBA, AND SETNAM, XXFFBD,
12844  F542              ; ROUTINES MUST BE CALLED.
12845  F542              
12846  F542              XXF542 = *
12847  F542  86 C3              STX     XXC3          ; SET KERNAL SETUP P
OINTER LOW BYTE
12848  F544  84 C4              STY     XXC4          ; SET KERNAL SETUP P
OINTER HIGH BYTE
12849  F546  6C 30 03           JMP     (XX0330)          ; DO LOAD VECTOR
, USUALLY POINTS TO XXF549
12850  F549                     
12851  F549                     
12852  F549              ;************************************************
***********************************;
12853  F549              ;
12854  F549              ; LOAD
12855  F549              
12856  F549              XXF549 = *






****;.......PAGE 0250

LINE# LOC   CODE        LINE


12857  F549  85 93              STA     XX93          ; SAVE LOAD/VERIFY F
LAG
12858  F54B  A9 00              LDA     #$00               ; CLEAR A
12859  F54D  85 90              STA     XX90          ; CLEAR SERIAL STATU
S BYTE
12860  F54F  A5 BA              LDA     XXBA          ; GET DEVICE NUMBER
12861  F551  D0 03              BNE     XXF556          ; BRANCH IF NOT KE
YBOARD
12862  F553                     
12863  F553                                     ; CAN'T LOAD FORM KEYBOARD
 SO ..
12864  F553              XXF553 = *
12865  F553  4C 96 F7           JMP     XXF796          ; DO ILLEGAL DEVIC
E NUMBER AND RETURN
12866  F556                     
12867  F556              XXF556 = *
12868  F556  C9 03              CMP     #$03               ; COMPARE DEVIC
E NUMBER WITH SCREEN
12869  F558  F0 F9              BEQ     XXF553          ; IF SCREEN GO DO 
ILLEGAL DEVICE NUMBER AND RETURN
12870  F55A                     
12871  F55A  90 6E              BCC     XXF5CA          ; BRANCH IF LESS T
HAN SCREEN
12872  F55C                     
12873  F55C                                     ; ELSE IS SERIAL BUS DEVIC
E
12874  F55C  A4 B7              LDY     XXB7          ; GET FILE NAME LENG
TH
12875  F55E  D0 03              BNE     XXF563          ; BRANCH IF NOT NU
LL NAME
12876  F560                     
12877  F560  4C 93 F7           JMP     XXF793          ; ELSE DO MISSING 
FILE NAME ERROR AND RETURN
12878  F563                     
12879  F563              XXF563 = *
12880  F563  20 BC E4           JSR     XXE4BC          ; GET SECONDAY ADD
RESS AND PRINT 'SEARCHING...'
12881  F566  A9 60              LDA     #$60               ;.
12882  F568  85 B9              STA     XXB9          ; SAVE THE SECONDARY
 ADDRESS
12883  F56A  20 95 F4           JSR     XXF495          ; SEND SECONDARY A
DDRESS AND FILENAME
12884  F56D  A5 BA              LDA     XXBA          ; GET DEVICE NUMBER
12885  F56F  20 14 EE           JSR     XXEE14          ; COMMAND A SERIAL
 BUS DEVICE TO TALK
12886  F572  A5 B9              LDA     XXB9          ; GET SECONDARY ADDR
ESS
12887  F574  20 CE EE           JSR     XXEECE          ; SEND SECONDARY A
DDRESS AFTER TALK
12888  F577  20 19 EF           JSR     XXEF19          ; INPUT A BYTE FRO
M THE SERIAL BUS
12889  F57A  85 AE              STA     XXAE          ; SAVE PROGRAM START
 ADDRESS LOW BYTE
12890  F57C  A5 90              LDA     XX90          ; GET SERIAL STATUS 
BYTE
12891  F57E  4A                 LSR A                  ; SHIFT TIME OUT RE
AD ..
12892  F57F  4A                 LSR A                  ; .. INTO CARRY BIT

12893  F580  B0 45              BCS     XXF5C7          ; IF TIMED OUT GO 
DO FILE NOT FOUND ERROR AND RETURN
12894  F582                     
12895  F582  20 19 EF           JSR     XXEF19          ; INPUT A BYTE FRO
M THE SERIAL BUS
12896  F585  85 AF              STA     XXAF          ; SAVE PROGRAM START
 ADDRESS HIGH BYTE
12897  F587  20 C1 E4           JSR     XXE4C1          ; SET LOAD ADDRESS
 IF SECONDARY ADDRESS = 0
12898  F58A              XXF58A = *
12899  F58A  A9 FD              LDA     #$FD               ; MASK XXXX XX0
X, CLEAR TIME OUT READ BIT
12900  F58C  25 90              AND     XX90          ; MASK SERIAL STATUS
 BYTE
12901  F58E  85 90              STA     XX90          ; SET SERIAL STATUS 
BYTE
12902  F590  20 E1 FF           JSR     XXFFE1          ; SCAN STOP KEY, R
ETURN ZB = 1 = [STOP]
12903  F593  D0 03              BNE     XXF598          ; BRANCH IF NOT [S
TOP]
12904  F595                     
12905  F595  4C CB F6           JMP     XXF6CB          ; ELSE CLOSE THE S
ERIAL BUS DEVICE AND FLAG STOP
12906  F598                     
12907  F598              XXF598 = *
12908  F598  20 19 EF           JSR     XXEF19          ; INPUT A BYTE FRO
M THE SERIAL BUS
12909  F59B  AA                 TAX                    ; COPY BYTE
12910  F59C  A5 90              LDA     XX90          ; GET SERIAL STATUS 
BYTE
12911  F59E  4A                 LSR A                  ; SHIFT TIME OUT RE
AD ..






N***;.......PAGE 0251

LINE# LOC   CODE        LINE


12912  F59F  4A                 LSR A                  ; .. INTO CARRY BIT

12913  F5A0  B0 E8              BCS     XXF58A          ; IF TIMED OUT GO 
??
12914  F5A2                     
12915  F5A2  8A                 TXA                    ; COPY RECEIVED BYT
E BACK
12916  F5A3  A4 93              LDY     XX93          ; GET LOAD/VERIFY FL
AG
12917  F5A5  F0 0C              BEQ     XXF5B3          ; BRANCH IF LOAD
12918  F5A7                     
12919  F5A7                                     ; ELSE IS VERIFY
12920  F5A7  A0 00              LDY     #$00               ; CLEAR INDEX
12921  F5A9  D1 AE              CMP     (XXAE),Y          ; COMPARE BYTE W
ITH PREVIOUSLY LOADED BYTE
12922  F5AB  F0 08              BEQ     XXF5B5          ; BRANCH IF MATCH
12923  F5AD                     
12924  F5AD  A9 10              LDA     #$10               ; FLAG READ ERR
OR
12925  F5AF  20 6A FE           JSR     XXFE6A          ; OR INTO SERIAL S
TATUS BYTE
12926  F5B2  2C                 .BYTE     $2C               ; MAKES NEXT L
INE BIT XXAE91
12927  F5B3              XXF5B3 = *
12928  F5B3  91 AE              STA     (XXAE),Y          ; SAVE BYTE TO M
EMORY
12929  F5B5              XXF5B5 = *
12930  F5B5  E6 AE              INC     XXAE          ; INCREMENT SAVE POI
NTER LOW BYTE
12931  F5B7  D0 02              BNE     XXF5BB          ; IF NO ROLLOVER S
KIP THE HIGH BYTE INCREMENT
12932  F5B9                     
12933  F5B9  E6 AF              INC     XXAF          ; ELSE INCREMENT SAV
E POINTER HIGH BYTE
12934  F5BB              XXF5BB = *
12935  F5BB  24 90              BIT     XX90          ; TEST SERIAL STATUS
 BYTE
12936  F5BD  50 CB              BVC     XXF58A          ; LOOP IF NOT END 
OF FILE
12937  F5BF                     
12938  F5BF  20 F6 EE           JSR     XXEEF6          ; COMMAND THE SERI
AL BUS TO UNTALK
12939  F5C2  20 DA F6           JSR     XXF6DA          ; CLOSE SERIAL BUS
 DEVICE
12940  F5C5  90 7A              BCC     XXF641          ; IF ?? GO FLAG OK
 AND EXIT
12941  F5C7                     
12942  F5C7              XXF5C7 = *
12943  F5C7  4C 87 F7           JMP     XXF787          ; DO FILE NOT FOUN
D ERROR AND RETURN
12944  F5CA                     
12945  F5CA              XXF5CA = *
12946  F5CA  C9 02              CMP     #$02               ; COMPARE DEVIC
E WITH RS232 DEVICE
12947  F5CC  D0 03              BNE     XXF5D1          ; IF NOT RS232 DEV
ICE CONTINUE
12948  F5CE                     
12949  F5CE  4C B9 F0           JMP     XXF0B9          ; ELSE DO ILLEGAL 
DEVICE NUMBER AND RETURN
12950  F5D1                     
12951  F5D1              XXF5D1 = *
12952  F5D1  20 4D F8           JSR     XXF84D          ; GET TAPE BUFFER 
START POINTER IN XY
12953  F5D4  B0 03              BCS     XXF5D9          ; BRANCH IF >= $02
00
12954  F5D6                     
12955  F5D6  4C 96 F7           JMP     XXF796          ; DO ILLEGAL DEVIC
E NUMBER AND RETURN
12956  F5D9                     
12957  F5D9              XXF5D9 = *
12958  F5D9  20 94 F8           JSR     XXF894          ; WAIT FOR PLAY
12959  F5DC  B0 68              BCS     XXF646          ; EXIT IF STOP WAS
 PRESSED
12960  F5DE                     
12961  F5DE  20 47 F6           JSR     XXF647          ; PRINT 'SEARCHING
...'
12962  F5E1              XXF5E1 = *
12963  F5E1  A5 B7              LDA     XXB7          ; GET FILE NAME LENG
TH
12964  F5E3  F0 09              BEQ     XXF5EE
12965  F5E5  20 67 F8           JSR     XXF867          ; FIND SPECIFIC TA
PE HEADER
12966  F5E8  90 0B              BCC     XXF5F5          ; IF NO ERROR CONT
INUE






N***;.......PAGE 0252

LINE# LOC   CODE        LINE


12967  F5EA                     
12968  F5EA  F0 5A              BEQ     XXF646          ; EXIT IF ??
12969  F5EC                     
12970  F5EC  B0 D9              BCS     XXF5C7          ;., BRANCH ALWAYS
12971  F5EE                     
12972  F5EE              XXF5EE = *
12973  F5EE  20 AF F7           JSR     XXF7AF          ; FIND TAPE HEADER
, EXIT WITH HEADER IN BUFFER
12974  F5F1  F0 53              BEQ     XXF646          ; EXIT IF ??
12975  F5F3                     
12976  F5F3  B0 D2              BCS     XXF5C7          ;.
12977  F5F5                     
12978  F5F5              XXF5F5 = *
12979  F5F5  A5 90              LDA     XX90          ; GET SERIAL STATUS 
BYTE
12980  F5F7  29 10              AND     #$10               ; MASK 000X 000
0, READ ERROR
12981  F5F9  38                 SEC                    ; FLAG FAIL
12982  F5FA  D0 4A              BNE     XXF646          ; IF READ ERROR JU
ST EXIT
12983  F5FC                     
12984  F5FC  E0 01              CPX     #$01               ;.
12985  F5FE  F0 11              BEQ     XXF611          ;.
12986  F600                     
12987  F600  E0 03              CPX     #$03               ;.
12988  F602  D0 DD              BNE     XXF5E1          ;.
12989  F604                     
12990  F604              XXF604 = *
12991  F604  A0 01              LDY     #$01               ;.
12992  F606  B1 B2              LDA     (XXB2),Y          ;.
12993  F608  85 C3              STA     XXC3          ;.
12994  F60A  C8                 INY                    ;.
12995  F60B  B1 B2              LDA     (XXB2),Y          ;.
12996  F60D  85 C4              STA     XXC4          ;.
12997  F60F  B0 04              BCS     XXF615          ;.
12998  F611                     
12999  F611              XXF611 = *
13000  F611  A5 B9              LDA     XXB9          ; GET SECONDARY ADDR
ESS
13001  F613  D0 EF              BNE     XXF604          ;.
13002  F615                     
13003  F615              XXF615 = *
13004  F615  A0 03              LDY     #$03               ;.
13005  F617  B1 B2              LDA     (XXB2),Y          ;.
13006  F619  A0 01              LDY     #$01               ;.
13007  F61B  F1 B2              SBC     (XXB2),Y          ;.
13008  F61D  AA                 TAX                    ;.
13009  F61E  A0 04              LDY     #$04               ;.
13010  F620  B1 B2              LDA     (XXB2),Y          ;.
13011  F622  A0 02              LDY     #$02               ;.
13012  F624  F1 B2              SBC     (XXB2),Y          ;.
13013  F626  A8                 TAY                    ;.
13014  F627  18                 CLC                    ;.
13015  F628  8A                 TXA                    ;.
13016  F629  65 C3              ADC     XXC3          ;.
13017  F62B  85 AE              STA     XXAE          ;.
13018  F62D  98                 TYA                    ;.
13019  F62E  65 C4              ADC     XXC4          ;.
13020  F630  85 AF              STA     XXAF          ;.
13021  F632  A5 C3              LDA     XXC3          ;.






N***;.......PAGE 0253

LINE# LOC   CODE        LINE


13022  F634  85 C1              STA     XXC1          ; SET I/O START ADDR
ESSES LOW BYTE
13023  F636  A5 C4              LDA     XXC4          ;.
13024  F638  85 C2              STA     XXC2          ; SET I/O START ADDR
ESSES HIGH BYTE
13025  F63A  20 6A F6           JSR     XXF66A          ; DISPLAY 'LOADING
' OR 'VERIFYING'
13026  F63D  20 C9 F8           JSR     XXF8C9          ; DO THE TAPE READ

13027  F640  24                 .BYTE     $24               ; MAKES NEXT L
INE BIT XX18, KEEP THE ERROR FLAG IN CB
13028  F641              XXF641 = *
13029  F641  18                 CLC                    ; FLAG OK
13030  F642  A6 AE              LDX     XXAE          ; GET THE LOAD END P
OINTER LOW BYTE
13031  F644  A4 AF              LDY     XXAF          ; GET THE LOAD END P
OINTER HIGH BYTE
13032  F646              XXF646 = *
13033  F646  60                 RTS
13034  F647                     
13035  F647                     
13036  F647              ;************************************************
***********************************;
13037  F647              ;
13038  F647              ; PRINT 'SEARCHING'
13039  F647              
13040  F647              XXF647 = *
13041  F647  A5 9D              LDA     XX9D          ; GET MESSAGE MODE F
LAG
13042  F649  10 1E              BPL     XXF669          ; EXIT IF CONTROL 
MESSAGES OFF
13043  F64B                     
13044  F64B  A0 0C              LDY     #XXF180-XXF174
13045  F64D                                     ; INDEX TO 'SEARCHING '
13046  F64D  20 E6 F1           JSR     XXF1E6          ; DISPLAY KERNEL I
/O MESSAGE
13047  F650  A5 B7              LDA     XXB7          ; GET FILE NAME LENG
TH
13048  F652  F0 15              BEQ     XXF669          ; EXIT IF NULL NAM
E
13049  F654                     
13050  F654  A0 17              LDY     #XXF18B-XXF174
13051  F656                                     ; ELSE INDEX TO 'FOR '
13052  F656  20 E6 F1           JSR     XXF1E6          ; DISPLAY KERNEL I
/O MESSAGE
13053  F659                     
13054  F659              ; PRINT FILE NAME
13055  F659              
13056  F659              XXF659 = *
13057  F659  A4 B7              LDY     XXB7          ; GET FILE NAME LENG
TH
13058  F65B  F0 0C              BEQ     XXF669          ; EXIT IF NULL FIL
E NAME
13059  F65D                     
13060  F65D  A0 00              LDY     #$00               ; CLEAR INDEX
13061  F65F              XXF65F = *
13062  F65F  B1 BB              LDA     (XXBB),Y          ; GET FILE NAME 
BYTE
13063  F661  20 D2 FF           JSR     XXFFD2          ; OUTPUT CHARACTER
 TO CHANNEL
13064  F664  C8                 INY                    ; INCREMENT INDEX
13065  F665  C4 B7              CPY     XXB7          ; COMPARE WITH FILE 
NAME LENGTH
13066  F667  D0 F6              BNE     XXF65F          ; LOOP IF MORE TO 
DO
13067  F669                     
13068  F669              XXF669 = *
13069  F669  60                 RTS
13070  F66A                     
13071  F66A              ; DISPLAY 'LOADING' OR 'VERIFYING'
13072  F66A              
13073  F66A              XXF66A = *
13074  F66A  A0 49              LDY     #XXF1BD-XXF174
13075  F66C                                     ; POINT TO 'LOADING'
13076  F66C  A5 93              LDA     XX93          ; GET LOAD/VERIFY FL
AG






****;B......PAGE 0254

LINE# LOC   CODE        LINE


13077  F66E  F0 02              BEQ     XXF672          ; BRANCH IF LOAD
13078  F670                     
13079  F670  A0 59              LDY     #XXF1CD-XXF174
13080  F672                                     ; POINT TO 'VERIFYING'
13081  F672              XXF672 = *
13082  F672  4C E2 F1           JMP     XXF1E2          ; DISPLAY KERNEL I
/O MESSAGE IF IN DIRECT MODE AND RETURN
13083  F675                     
13084  F675                     
13085  F675              ;************************************************
***********************************;
13086  F675              ;
13087  F675              ; SAVE RAM TO DEVICE, A = INDEX TO START ADDRESS,
 XY = END ADDRESS LOW/HIGH
13088  F675              
13089  F675              ; THIS ROUTINE SAVES A SECTION OF MEMORY. MEMORY 
IS SAVED FROM AN INDIRECT ADDRESS
13090  F675              ; ON PAGE 0 SPECIFIED BY A, TO THE ADDRESS STORED
 IN XY, TO A LOGICAL FILE. THE
13091  F675              ; SETLFS, XXFFBA, AND SETNAM, XXFFBD, ROUTINES MU
ST BE USED BEFORE CALLING THIS
13092  F675              ; ROUTINE. HOWEVER, A FILE NAME IS NOT REQUIRED T
O SAVE TO DEVICE 1, THE CASSETTE.
13093  F675              ; ANY ATTEMPT TO SAVE TO OTHER DEVICES WITHOUT US
ING A FILE NAME RESULTS IN AN ERROR.
13094  F675              
13095  F675              ; NOTE: DEVICE 0, THE KEYBOARD, AND DEVICE 3, THE
 SCREEN, CANNOT BE SAVED TO. IF
13096  F675              ; THE ATTEMPT IS MADE, AN ERROR WILL OCCUR, AND T
HE SAVE STOPPED.
13097  F675              
13098  F675              XXF675 = *
13099  F675  86 AE              STX     XXAE          ; SAVE END ADDRESS L
OW BYTE
13100  F677  84 AF              STY     XXAF          ; SAVE END ADDRESS H
IGH BYTE
13101  F679  AA                 TAX                    ; COPY INDEX TO STA
RT POINTER
13102  F67A  B5 00              LDA     XX00,X          ; GET START ADDRES
S LOW BYTE
13103  F67C  85 C1              STA     XXC1          ; SET I/O START ADDR
ESSES LOW BYTE
13104  F67E  B5 01              LDA     XX01,X          ; GET START ADDRES
S HIGH BYTE
13105  F680  85 C2              STA     XXC2          ; SET I/O START ADDR
ESSES HIGH BYTE
13106  F682  6C 32 03           JMP     (XX0332)          ; GO SAVE, USUAL
LY POINTS TO XXF685
13107  F685                     
13108  F685                     
13109  F685              ;************************************************
***********************************;
13110  F685              ;
13111  F685              ; SAVE
13112  F685              
13113  F685              XXF685 = *
13114  F685  A5 BA              LDA     XXBA          ; GET DEVICE NUMBER
13115  F687  D0 03              BNE     XXF68C          ; BRANCH IF NOT KE
YBOARD
13116  F689                     
13117  F689                                     ; ELSE ..
13118  F689              XXF689 = *
13119  F689  4C 96 F7           JMP     XXF796          ; DO ILLEGAL DEVIC
E NUMBER AND RETURN
13120  F68C                     
13121  F68C              XXF68C = *
13122  F68C  C9 03              CMP     #$03               ; COMPARE DEVIC
E NUMBER WITH SCREEN
13123  F68E  F0 F9              BEQ     XXF689          ; IF SCREEN DO ILL
EGAL DEVICE NUMBER AND RETURN
13124  F690                     
13125  F690  90 5F              BCC     XXF6F1          ; BRANCH IF < SCRE
EN
13126  F692                     
13127  F692                                     ; IS GREATER THAN SCREEN S
O IS SERIAL BUS
13128  F692  A9 61              LDA     #$61               ; SET SECONDARY
 ADDRESS TO $01
13129  F694                                     ; WHEN A SECONDARY ADDRESS
 IS TO BE SENT TO A DEVICE ON
13130  F694                                     ; THE SERIAL BUS THE ADDRE
SS MUST FIRST BE ORED WITH $60
13131  F694  85 B9              STA     XXB9          ; SAVE SECONDARY ADD
RESS






0***;N......PAGE 0255

LINE# LOC   CODE        LINE


13132  F696  A4 B7              LDY     XXB7          ; GET FILE NAME LENG
TH
13133  F698  D0 03              BNE     XXF69D          ; BRANCH IF FILENA
ME NOT NULL
13134  F69A                     
13135  F69A  4C 93 F7           JMP     XXF793          ; ELSE DO MISSING 
FILE NAME ERROR AND RETURN
13136  F69D                     
13137  F69D              XXF69D = *
13138  F69D  20 95 F4           JSR     XXF495          ; SEND SECONDARY A
DDRESS AND FILENAME
13139  F6A0  20 28 F7           JSR     XXF728          ; PRINT SAVING [FI
LE NAME]
13140  F6A3  A5 BA              LDA     XXBA          ; GET DEVICE NUMBER
13141  F6A5  20 17 EE           JSR     XXEE17          ; COMMAND DEVICES 
ON THE SERIAL BUS TO LISTEN
13142  F6A8  A5 B9              LDA     XXB9          ; GET SECONDARY ADDR
ESS
13143  F6AA  20 C0 EE           JSR     XXEEC0          ; SEND SECONDARY A
DDRESS AFTER LISTEN
13144  F6AD  A0 00              LDY     #$00               ; CLEAR INDEX
13145  F6AF  20 D2 FB           JSR     XXFBD2          ; COPY I/O START A
DDRESS TO BUFFER ADDRESS
13146  F6B2  A5 AC              LDA     XXAC          ; GET BUFFER ADDRESS
 LOW BYTE
13147  F6B4  20 E4 EE           JSR     XXEEE4          ; OUTPUT A BYTE TO
 THE SERIAL BUS
13148  F6B7  A5 AD              LDA     XXAD          ; GET BUFFER ADDRESS
 HIGH BYTE
13149  F6B9  20 E4 EE           JSR     XXEEE4          ; OUTPUT A BYTE TO
 THE SERIAL BUS
13150  F6BC              XXF6BC = *
13151  F6BC  20 11 FD           JSR     XXFD11          ; CHECK READ/WRITE
 POINTER, RETURN CB = 1 IF POINTER >= END
13152  F6BF  B0 16              BCS     XXF6D7          ; GO DO UNLISTEN I
F AT END
13153  F6C1                     
13154  F6C1  B1 AC              LDA     (XXAC),Y          ; GET BYTE FROM 
BUFFER
13155  F6C3  20 E4 EE           JSR     XXEEE4          ; OUTPUT A BYTE TO
 THE SERIAL BUS
13156  F6C6  20 E1 FF           JSR     XXFFE1          ; SCAN STOP KEY
13157  F6C9  D0 07              BNE     XXF6D2          ; IF STOP NOT PRES
SED GO INCREMENT POINTER AND LOOP FOR NEXT
13158  F6CB                     
13159  F6CB                                     ; ELSE ..
13160  F6CB                     
13161  F6CB              ; CLOSE THE SERIAL BUS DEVICE AND FLAG STOP
13162  F6CB              
13163  F6CB              XXF6CB = *
13164  F6CB  20 DA F6           JSR     XXF6DA          ; CLOSE SERIAL BUS
 DEVICE
13165  F6CE  A9 00              LDA     #$00               ;.
13166  F6D0  38                 SEC                    ; FLAG STOP
13167  F6D1  60                 RTS
13168  F6D2                     
13169  F6D2              XXF6D2 = *
13170  F6D2  20 1B FD           JSR     XXFD1B          ; INCREMENT READ/W
RITE POINTER
13171  F6D5  D0 E5              BNE     XXF6BC          ; LOOP, BRANCH ALW
AYS
13172  F6D7                     
13173  F6D7                     
13174  F6D7              ;************************************************
***********************************;
13175  F6D7              ;
13176  F6D7              ; ??
13177  F6D7              
13178  F6D7              XXF6D7 = *
13179  F6D7  20 04 EF           JSR     XXEF04          ; COMMAND THE SERI
AL BUS TO UNLISTEN
13180  F6DA                     
13181  F6DA              ; CLOSE THE SERIAL BUS DEVICE
13182  F6DA              
13183  F6DA              XXF6DA = *
13184  F6DA  24 B9              BIT     XXB9          ; TEST THE SECONDARY
 ADDRESS
13185  F6DC  30 11              BMI     XXF6EF          ; IF ALREADY CLOSE
D JUST EXIT
13186  F6DE                     






****;N......PAGE 0256

LINE# LOC   CODE        LINE


13187  F6DE  A5 BA              LDA     XXBA          ; GET THE DEVICE NUM
BER
13188  F6E0  20 17 EE           JSR     XXEE17          ; COMMAND DEVICES 
ON THE SERIAL BUS TO LISTEN
13189  F6E3  A5 B9              LDA     XXB9          ; GET SECONDARY ADDR
ESS
13190  F6E5  29 EF              AND     #$EF               ; MASK THE CHAN
NEL NUMBER
13191  F6E7  09 E0              ORA     #$E0               ; OR WITH THE C
LOSE COMMAND
13192  F6E9  20 C0 EE           JSR     XXEEC0          ; SEND SECONDARY A
DDRESS AFTER LISTEN
13193  F6EC  20 04 EF           JSR     XXEF04          ; COMMAND THE SERI
AL BUS TO UNLISTEN
13194  F6EF              XXF6EF = *
13195  F6EF  18                 CLC                    ; FLAG OK
13196  F6F0  60                 RTS
13197  F6F1                     
13198  F6F1              XXF6F1 = *
13199  F6F1  C9 02              CMP     #$02               ; COMPARE DEVIC
E WITH RS232 DEVICE
13200  F6F3  D0 03              BNE     XXF6F8          ; BRANCH IF NOT RS
232 DEVICE
13201  F6F5                     
13202  F6F5  4C B9 F0           JMP     XXF0B9          ; ELSE DO ILLEGAL 
DEVICE NUMBER AND RETURN
13203  F6F8                     
13204  F6F8              XXF6F8 = *
13205  F6F8  20 4D F8           JSR     XXF84D          ; GET TAPE BUFFER 
START POINTER IN XY
13206  F6FB  90 8C              BCC     XXF689          ; IF < $0200 DO IL
LEGAL DEVICE NUMBER AND RETURN
13207  F6FD                     
13208  F6FD  20 B7 F8           JSR     XXF8B7          ; WAIT FOR PLAY/RE
CORD
13209  F700  B0 25              BCS     XXF727          ; EXIT IF STOP WAS
 PRESSED
13210  F702                     
13211  F702  20 28 F7           JSR     XXF728          ; PRINT SAVING [FI
LE NAME]
13212  F705  A2 03              LDX     #$03               ; SET HEADER FO
R A NON RELOCATABLE PROGRAM FILE
13213  F707  A5 B9              LDA     XXB9          ; GET SECONDARY ADDR
ESS
13214  F709  29 01              AND     #$01               ; MASK NON RELO
CATABLE BIT
13215  F70B  D0 02              BNE     XXF70F          ; BRANCH IF NON RE
LOCATABLE PROGRAM
13216  F70D                     
13217  F70D  A2 01              LDX     #$01               ; ELSE SET HEAD
ER FOR A RELOCATABLE PROGRAM FILE
13218  F70F              XXF70F = *
13219  F70F  8A                 TXA                    ; COPY HEADER TYPE 
TO A
13220  F710  20 E7 F7           JSR     XXF7E7          ; WRITE TAPE HEADE
R
13221  F713  B0 12              BCS     XXF727          ; EXIT IF ERROR
13222  F715                     
13223  F715  20 E6 F8           JSR     XXF8E6          ; DO TAPE WRITE, 2
0 CYCLE COUNT
13224  F718  B0 0D              BCS     XXF727          ; EXIT IF ERROR
13225  F71A                     
13226  F71A  A5 B9              LDA     XXB9          ; GET SECONDARY ADDR
ESS
13227  F71C  29 02              AND     #$02               ; MASK END OF T
APE FLAG
13228  F71E  F0 06              BEQ     XXF726          ; BRANCH IF NOT EN
D OF TAPE
13229  F720                     
13230  F720  A9 05              LDA     #$05               ; ELSE SET LOGI
CAL END OF THE TAPE
13231  F722  20 E7 F7           JSR     XXF7E7          ; WRITE TAPE HEADE
R
13232  F725  24                 .BYTE     $24               ; MAKES NEXT L
INE BIT XX18 SO CB IS NOT CHANGED
13233  F726              XXF726 = *
13234  F726  18                 CLC                    ; FLAG OK
13235  F727              XXF727 = *
13236  F727  60                 RTS
13237  F728                     
13238  F728                     
13239  F728              ;************************************************
***********************************;
13240  F728              ;
13241  F728              ; PRINT SAVING [FILE NAME]






****;N......PAGE 0257

LINE# LOC   CODE        LINE


13242  F728              
13243  F728              XXF728 = *
13244  F728  A5 9D              LDA     XX9D          ; GET MESSAGE MODE F
LAG
13245  F72A  10 FB              BPL     XXF727          ; EXIT IF CONTROL 
MESSAGES OFF
13246  F72C                     
13247  F72C  A0 51              LDY     #XXF1C5-XXF174
13248  F72E                                     ; INDEX TO 'SAVING '
13249  F72E  20 E6 F1           JSR     XXF1E6          ; DISPLAY KERNEL I
/O MESSAGE
13250  F731  4C 59 F6           JMP     XXF659          ; PRINT FILE NAME 
AND RETURN
13251  F734                     
13252  F734                     
13253  F734              ;************************************************
***********************************;
13254  F734              ;
13255  F734              ; INCREMENT REAL TIME CLOCK
13256  F734              
13257  F734              ; THIS ROUTINE UPDATES THE SYSTEM CLOCK. NORMALLY
 THIS ROUTINE IS CALLED BY THE
13258  F734              ; NORMAL KERNAL INTERRUPT ROUTINE EVERY 1/60TH OF
 A SECOND. IF THE USER PROGRAM
13259  F734              ; PROCESSES ITS OWN INTERRUPTS THIS ROUTINE MUST 
BE CALLED TO UPDATE THE TIME. ALSO,
13260  F734              ; THE STOP KEY ROUTINE MUST BE CALLED IF THE STOP
 KEY IS TO REMAIN FUNCTIONAL.
13261  F734              
13262  F734              XXF734 = *
13263  F734  A2 00              LDX     #$00               ; CLEAR X
13264  F736  E6 A2              INC     XXA2          ; INCREMENT JIFFY LO
W BYTE
13265  F738  D0 06              BNE     XXF740          ; IF NO ROLLOVER S
KIP THE MID BYTE INCREMENT
13266  F73A                     
13267  F73A  E6 A1              INC     XXA1          ; INCREMENT JIFFY MI
D BYTE
13268  F73C  D0 02              BNE     XXF740          ; IF NO ROLLOVER S
KIP THE HIGH BYTE INCREMENT
13269  F73E                     
13270  F73E  E6 A0              INC     XXA0          ; INCREMENT JIFFY HI
GH BYTE
13271  F740                     
13272  F740                                     ; NOW SUBTRACT A DAYS WORT
H OF JIFFIES FROM CURRENT COUNT
13273  F740                                     ; AND REMEMBER ONLY THE CB
 RESULT
13274  F740              XXF740 = *
13275  F740  38                 SEC                    ; SET CARRY FOR SUB
TRACT
13276  F741  A5 A2              LDA     XXA2          ; GET JIFFY CLOCK LO
W BYTE
13277  F743  E9 01              SBC     #$01               ; SUBTRACT $4F1
A01 LOW BYTE
13278  F745  A5 A1              LDA     XXA1          ; GET JIFFY CLOCK MI
D BYTE
13279  F747  E9 1A              SBC     #$1A               ; SUBTRACT $4F1
A01 MID BYTE
13280  F749  A5 A0              LDA     XXA0          ; GET JIFFY CLOCK HI
GH BYTE
13281  F74B  E9 4F              SBC     #$4F               ; SUBTRACT $4F1
A01 HIGH BYTE
13282  F74D  90 06              BCC     XXF755          ; BRANCH IF LESS T
HAN $4F1A01 JIFFIES
13283  F74F                     
13284  F74F                                     ; ELSE ..
13285  F74F  86 A0              STX     XXA0          ; CLEAR JIFFIES HIGH
 BYTE
13286  F751  86 A1              STX     XXA1          ; CLEAR JIFFIES MID 
BYTE
13287  F753  86 A2              STX     XXA2          ; CLEAR JIFFIES LOW 
BYTE
13288  F755                                     ; THIS IS WRONG, THERE ARE
 $4F1A00 JIFFIES IN A DAY SO
13289  F755                                     ; THE RESET TO ZERO SHOULD
 OCCUR WHEN THE VALUE REACHES
13290  F755                                     ; $4F1A00 AND NOT $4F1A01.
 THIS WOULD GIVE AN EXTRA JIFFY
13291  F755                                     ; EVERY DAY AND A POSSIBLE
 TI VALUE OF 24:00:00
13292  F755              XXF755 = *
13293  F755  AD 2F 91           LDA     XX912F          ; GET VIA 2 DRA, K
EYBOARD ROW, NO HANDSHAKE
13294  F758  CD 2F 91           CMP     XX912F          ; COMPARE WITH SEL
F
13295  F75B  D0 F8              BNE     XXF755          ; LOOP IF CHANGING

13296  F75D                     






FYO,;N......PAGE 0258

LINE# LOC   CODE        LINE


13297  F75D  85 91              STA     XX91          ; SAVE VIA 2 DRA, KE
YBOARD ROW
13298  F75F  60                 RTS
13299  F760                     
13300  F760                     
13301  F760              ;************************************************
***********************************;
13302  F760              ;
13303  F760              ; READ THE REAL TIME CLOCK
13304  F760              
13305  F760              ; THIS ROUTINE RETURNS THE TIME, IN JIFFIES, IN A
XY. THE ACCUMULATOR CONTAINS THE
13306  F760              ; MOST SIGNIFICANT BYTE.
13307  F760              
13308  F760              XXF760 = *
13309  F760  78                 SEI                    ; DISABLE INTERRUPT
S
13310  F761  A5 A2              LDA     XXA2          ; GET JIFFY CLOCK LO
W BYTE
13311  F763  A6 A1              LDX     XXA1          ; GET JIFFY CLOCK MI
D BYTE
13312  F765  A4 A0              LDY     XXA0          ; GET JIFFY CLOCK HI
GH BYTE
13313  F767                     
13314  F767                     
13315  F767              ;************************************************
***********************************;
13316  F767              ;
13317  F767              ; SET THE REAL TIME CLOCK
13318  F767              
13319  F767              ; THE SYSTEM CLOCK IS MAINTAINED BY AN INTERRUPT 
ROUTINE THAT UPDATES THE CLOCK
13320  F767              ; EVERY 1/60TH OF A SECOND. THE CLOCK IS THREE BY
TES LONG WHICH GIVES THE CAPABILITY
13321  F767              ; TO COUNT FROM ZERO UP TO 5,184,000 JIFFIES - 24
 HOURS PLUS ONE JIFFY. AT THAT POINT
13322  F767              ; THE CLOCK RESETS TO ZERO. BEFORE CALLING THIS R
OUTINE TO SET THE CLOCK THE NEW TIME,
13323  F767              ; IN JIFFIES, SHOULD BE IN YXA, THE ACCUMULATOR C
ONTAINING THE MOST SIGNIFICANT BYTE.
13324  F767              
13325  F767              XXF767 = *
13326  F767  78                 SEI                    ; DISABLE INTERRUPT
S
13327  F768  85 A2              STA     XXA2          ; SAVE JIFFY CLOCK L
OW BYTE
13328  F76A  86 A1              STX     XXA1          ; SAVE JIFFY CLOCK M
ID BYTE
13329  F76C  84 A0              STY     XXA0          ; SAVE JIFFY CLOCK H
IGH BYTE
13330  F76E  58                 CLI                    ; ENABLE INTERRUPTS

13331  F76F  60                 RTS
13332  F770                     
13333  F770                     
13334  F770              ;************************************************
***********************************;
13335  F770              ;
13336  F770              ; SCAN STOP KEY, RETURN ZB = 1 = [STOP]
13337  F770              
13338  F770              ; IF THE STOP KEY ON THE KEYBOARD IS PRESSED WHEN
 THIS ROUTINE IS CALLED THE Z FLAG
13339  F770              ; WILL BE SET. ALL OTHER FLAGS REMAIN UNCHANGED. 
IF THE STOP KEY IS NOT PRESSED THEN
13340  F770              ; THE ACCUMULATOR WILL CONTAIN A BYTE REPRESENTIN
G THE LAST ROW OF THE KEYBOARD SCAN.
13341  F770              
13342  F770              ; THE USER CAN ALSO CHECK FOR CERTAIN OTHER KEYS 
THIS WAY.
13343  F770              
13344  F770              XXF770 = *
13345  F770  A5 91              LDA     XX91          ; GET KEYBOARD ROW
13346  F772  C9 FE              CMP     #$FE               ; COMPARE WITH 
R0 DOWN
13347  F774  D0 07              BNE     XXF77D          ; BRANCH IF NOT JU
ST R0
13348  F776                     
13349  F776  08                 PHP                    ; SAVE STATUS
13350  F777  20 CC FF           JSR     XXFFCC          ; CLOSE INPUT AND 
OUTPUT CHANNELS
13351  F77A  85 C6              STA     XXC6          ; SAVE KEYBOARD BUFF
ER LENGTH






SCAN.,......PAGE 0259

LINE# LOC   CODE        LINE


13352  F77C  28                 PLP                    ; RESTORE STATUS
13353  F77D              XXF77D = *
13354  F77D  60                 RTS
13355  F77E                     
13356  F77E                     
13357  F77E              ;************************************************
***********************************;
13358  F77E              ;
13359  F77E              ; FILE ERROR MESSAGES
13360  F77E              
13361  F77E              XXF77E = *
13362  F77E  A9 01              LDA     #$01               ; TOO MANY FILE
S
13363  F780  2C                 .BYTE     $2C               ; MAKES NEXT L
INE BIT XX02A9
13364  F781              XXF781 = *
13365  F781  A9 02              LDA     #$02               ; FILE ALREADY 
OPEN
13366  F783  2C                 .BYTE     $2C               ; MAKES NEXT L
INE BIT XX03A9
13367  F784              XXF784 = *
13368  F784  A9 03              LDA     #$03               ; FILE NOT OPEN

13369  F786  2C                 .BYTE     $2C               ; MAKES NEXT L
INE BIT XX04A9
13370  F787              XXF787 = *
13371  F787  A9 04              LDA     #$04               ; FILE NOT FOUN
D
13372  F789  2C                 .BYTE     $2C               ; MAKES NEXT L
INE BIT XX05A9
13373  F78A              XXF78A = *
13374  F78A  A9 05              LDA     #$05               ; DEVICE NOT PR
ESENT
13375  F78C  2C                 .BYTE     $2C               ; MAKES NEXT L
INE BIT XX06A9
13376  F78D              XXF78D = *
13377  F78D  A9 06              LDA     #$06               ; NOT INPUT FIL
E
13378  F78F  2C                 .BYTE     $2C               ; MAKES NEXT L
INE BIT XX07A9
13379  F790              XXF790 = *
13380  F790  A9 07              LDA     #$07               ; NOT OUTPUT FI
LE
13381  F792  2C                 .BYTE     $2C               ; MAKES NEXT L
INE BIT XX08A9
13382  F793              XXF793 = *
13383  F793  A9 08              LDA     #$08               ; MISSING FILE 
NAME
13384  F795  2C                 .BYTE     $2C               ; MAKES NEXT L
INE BIT XX09A9
13385  F796              XXF796 = *
13386  F796  A9 09              LDA     #$09               ; ILLEGAL DEVIC
E NUMBER
13387  F798                     
13388  F798  48                 PHA                    ; SAVE ERROR #
13389  F799  20 CC FF           JSR     XXFFCC          ; CLOSE INPUT AND 
OUTPUT CHANNELS
13390  F79C  A0 00              LDY     #XXF174-XXF174
13391  F79E                                     ; INDEX TO 'I/O ERROR #'
13392  F79E  24 9D              BIT     XX9D          ; TEST MESSAGE MODE 
FLAG
13393  F7A0  50 0A              BVC     XXF7AC          ; EXIT IF KERNAL M
ESSAGES OFF
13394  F7A2                     
13395  F7A2  20 E6 F1           JSR     XXF1E6          ; DISPLAY KERNEL I
/O MESSAGE
13396  F7A5  68                 PLA                    ; RESTORE ERROR #
13397  F7A6  48                 PHA                    ; COPY ERROR #
13398  F7A7  09 30              ORA     #'0'               ; CONVERT TO AS
CII
13399  F7A9  20 D2 FF           JSR     XXFFD2          ; OUTPUT CHARACTER
 TO CHANNEL
13400  F7AC              XXF7AC = *
13401  F7AC  68                 PLA                    ; PULL ERROR NUMBER

13402  F7AD  38                 SEC                    ; FLAG ERROR
13403  F7AE  60                 RTS
13404  F7AF                     
13405  F7AF                     
13406  F7AF              ;************************************************
***********************************;






****;,......PAGE 0260

LINE# LOC   CODE        LINE


13407  F7AF              ;
13408  F7AF              ; FIND TAPE HEADER, EXIT WITH HEADER IN BUFFER
13409  F7AF              
13410  F7AF              XXF7AF = *
13411  F7AF  A5 93              LDA     XX93          ; GET LOAD/VERIFY FL
AG
13412  F7B1  48                 PHA                    ; SAVE LOAD/VERIFY 
FLAG
13413  F7B2  20 C0 F8           JSR     XXF8C0          ; INITIATE TAPE RE
AD
13414  F7B5  68                 PLA                    ; RESTORE LOAD/VERI
FY FLAG
13415  F7B6  85 93              STA     XX93          ; SAVE LOAD/VERIFY F
LAG
13416  F7B8  B0 2C              BCS     XXF7E6          ; EXIT IF ERROR
13417  F7BA                     
13418  F7BA  A0 00              LDY     #$00               ; CLEAR INDEX
13419  F7BC  B1 B2              LDA     (XXB2),Y          ; READ FIRST BYT
E FROM TAPE BUFFER
13420  F7BE  C9 05              CMP     #$05               ; COMPARE WITH 
LOGICAL END OF THE TAPE
13421  F7C0  F0 24              BEQ     XXF7E6          ; EXIT IF END OF T
HE TAPE
13422  F7C2                     
13423  F7C2  C9 01              CMP     #$01               ; COMPARE WITH 
HEADER FOR A RELOCATABLE PROGRAM FILE
13424  F7C4  F0 08              BEQ     XXF7CE          ; BRANCH IF PROGRA
M FILE HEADER
13425  F7C6                     
13426  F7C6  C9 03              CMP     #$03               ; COMPARE WITH 
HEADER FOR A NON RELOCATABLE PROGRAM FILE
13427  F7C8  F0 04              BEQ     XXF7CE          ; BRANCH IF PROGRA
M FILE HEADER
13428  F7CA                     
13429  F7CA  C9 04              CMP     #$04               ; COMPARE WITH 
DATA FILE HEADER
13430  F7CC  D0 E1              BNE     XXF7AF          ; IF DATA FILE LOO
P TO FIND TAPE HEADER
13431  F7CE                     
13432  F7CE                                     ; WAS PROGRAM FILE HEADER
13433  F7CE              XXF7CE = *
13434  F7CE  AA                 TAX                    ; COPY HEADER TYPE
13435  F7CF  24 9D              BIT     XX9D          ; GET MESSAGE MODE F
LAG
13436  F7D1  10 11              BPL     XXF7E4          ; EXIT IF CONTROL 
MESSAGES OFF
13437  F7D3                     
13438  F7D3  A0 63              LDY     #XXF1D7-XXF174
13439  F7D5                                     ; INDEX TO 'FOUND '
13440  F7D5  20 E6 F1           JSR     XXF1E6          ; DISPLAY KERNEL I
/O MESSAGE
13441  F7D8  A0 05              LDY     #$05               ; INDEX TO TAPE
 FILENAME
13442  F7DA              XXF7DA = *
13443  F7DA  B1 B2              LDA     (XXB2),Y          ; GET BYTE FROM 
TAPE BUFFER
13444  F7DC  20 D2 FF           JSR     XXFFD2          ; OUTPUT CHARACTER
 TO CHANNEL
13445  F7DF  C8                 INY                    ; INCREMENT INDEX
13446  F7E0  C0 15              CPY     #$15               ; COMPARE WITH 
END+1
13447  F7E2  D0 F6              BNE     XXF7DA          ; LOOP IF MORE TO 
DO
13448  F7E4                     
13449  F7E4              XXF7E4 = *
13450  F7E4  18                 CLC                    ; FLAG NO ERROR
13451  F7E5  88                 DEY                    ; DECREMENT INDEX
13452  F7E6              XXF7E6 = *
13453  F7E6  60                 RTS
13454  F7E7                     
13455  F7E7                     
13456  F7E7              ;************************************************
***********************************;
13457  F7E7              ;
13458  F7E7              ; WRITE TAPE HEADER
13459  F7E7              
13460  F7E7              XXF7E7 = *
13461  F7E7  85 9E              STA     XX9E          ; SAVE HEADER TYPE






****;I......PAGE 0261

LINE# LOC   CODE        LINE


13462  F7E9  20 4D F8           JSR     XXF84D          ; GET TAPE BUFFER 
START POINTER IN XY
13463  F7EC  90 5E              BCC     XXF84C          ; EXIT IF < $0200
13464  F7EE                     
13465  F7EE  A5 C2              LDA     XXC2          ; GET I/O START ADDR
ESS HIGH BYTE
13466  F7F0  48                 PHA                    ; SAVE IT
13467  F7F1  A5 C1              LDA     XXC1          ; GET I/O START ADDR
ESS LOW BYTE
13468  F7F3  48                 PHA                    ; SAVE IT
13469  F7F4  A5 AF              LDA     XXAF          ; GET TAPE END ADDRE
SS HIGH BYTE
13470  F7F6  48                 PHA                    ; SAVE IT
13471  F7F7  A5 AE              LDA     XXAE          ; GET TAPE END ADDRE
SS LOW BYTE
13472  F7F9  48                 PHA                    ; SAVE IT
13473  F7FA                     
13474  F7FA  A0 BF              LDY     #$BF               ; INDEX TO HEAD
ER END
13475  F7FC  A9 20              LDA     #' '               ; CLEAR BYTE, [
SPACE]
13476  F7FE              XXF7FE = *
13477  F7FE  91 B2              STA     (XXB2),Y          ; CLEAR HEADER B
YTE
13478  F800  88                 DEY                    ; DECREMENT INDEX
13479  F801  D0 FB              BNE     XXF7FE          ; LOOP IF MORE TO 
DO
13480  F803                     
13481  F803  A5 9E              LDA     XX9E          ; GET HEADER TYPE BA
CK
13482  F805  91 B2              STA     (XXB2),Y          ; WRITE TO HEADE
R
13483  F807  C8                 INY                    ; INCREMENT INDEX
13484  F808  A5 C1              LDA     XXC1          ; GET I/O START ADDR
ESS LOW BYTE
13485  F80A  91 B2              STA     (XXB2),Y          ; WRITE TO HEADE
R
13486  F80C  C8                 INY                    ; INCREMENT INDEX
13487  F80D  A5 C2              LDA     XXC2          ; GET I/O START ADDR
ESS HIGH BYTE
13488  F80F  91 B2              STA     (XXB2),Y          ; WRITE TO HEADE
R
13489  F811  C8                 INY                    ; INCREMENT INDEX
13490  F812  A5 AE              LDA     XXAE          ; GET TAPE END ADDRE
SS LOW BYTE
13491  F814  91 B2              STA     (XXB2),Y          ; WRITE TO HEADE
R
13492  F816  C8                 INY                    ; INCREMENT INDEX
13493  F817  A5 AF              LDA     XXAF          ; GET TAPE END ADDRE
SS HIGH BYTE
13494  F819  91 B2              STA     (XXB2),Y          ; WRITE TO HEADE
R
13495  F81B  C8                 INY                    ; INCREMENT INDEX
13496  F81C  84 9F              STY     XX9F          ; SAVE INDEX
13497  F81E  A0 00              LDY     #$00               ; CLEAR Y
13498  F820  84 9E              STY     XX9E          ; CLEAR NAME INDEX
13499  F822              XXF822 = *
13500  F822  A4 9E              LDY     XX9E          ; GET NAME INDEX
13501  F824  C4 B7              CPY     XXB7          ; COMPARE WITH FILE 
NAME LENGTH
13502  F826  F0 0C              BEQ     XXF834          ; EXIT LOOP IF ALL
 DONE
13503  F828                     
13504  F828  B1 BB              LDA     (XXBB),Y          ; GET FILE NAME 
BYTE
13505  F82A  A4 9F              LDY     XX9F          ; GET BUFFER INDEX
13506  F82C  91 B2              STA     (XXB2),Y          ; SAVE FILE NAME
 BYTE TO BUFFER
13507  F82E  E6 9E              INC     XX9E          ; INCREMENT FILE NAM
E INDEX
13508  F830  E6 9F              INC     XX9F          ; INCREMENT TAPE BUF
FER INDEX
13509  F832  D0 EE              BNE     XXF822          ; LOOP, BRANCH ALW
AYS
13510  F834                     
13511  F834              XXF834 = *
13512  F834  20 54 F8           JSR     XXF854          ; SET TAPE BUFFER 
START AND END POINTERS
13513  F837  A9 69              LDA     #$69               ; SET WRITE LEA
D CYCLE COUNT
13514  F839  85 AB              STA     XXAB          ; SAVE WRITE LEAD CY
CLE COUNT
13515  F83B  20 EA F8           JSR     XXF8EA          ; DO TAPE WRITE, N
O CYCLE COUNT SET
13516  F83E  A8                 TAY                    ;.






****;I......PAGE 0262

LINE# LOC   CODE        LINE


13517  F83F  68                 PLA                    ; PULL TAPE END ADD
RESS LOW BYTE
13518  F840  85 AE              STA     XXAE          ; RESTORE IT
13519  F842  68                 PLA                    ; PULL TAPE END ADD
RESS HIGH BYTE
13520  F843  85 AF              STA     XXAF          ; RESTORE IT
13521  F845  68                 PLA                    ; PULL I/O START AD
DRESSES LOW BYTE
13522  F846  85 C1              STA     XXC1          ; RESTORE IT
13523  F848  68                 PLA                    ; PULL I/O START AD
DRESSES HIGH BYTE
13524  F849  85 C2              STA     XXC2          ; RESTORE IT
13525  F84B  98                 TYA                    ;.
13526  F84C              XXF84C = *
13527  F84C  60                 RTS
13528  F84D                     
13529  F84D                     
13530  F84D              ;************************************************
***********************************;
13531  F84D              ;
13532  F84D              ; GET TAPE BUFFER START POINTER
13533  F84D              
13534  F84D              XXF84D = *
13535  F84D  A6 B2              LDX     XXB2          ; GET TAPE BUFFER ST
ART POINTER LOW BYTE
13536  F84F  A4 B3              LDY     XXB3          ; GET TAPE BUFFER ST
ART POINTER HIGH BYTE
13537  F851  C0 02              CPY     #$02               ; COMPARE HIGH 
BYTE WITH $02XX
13538  F853  60                 RTS
13539  F854                     
13540  F854                     
13541  F854              ;************************************************
***********************************;
13542  F854              ;
13543  F854              ; SET TAPE BUFFER START AND END POINTERS
13544  F854              
13545  F854              XXF854 = *
13546  F854  20 4D F8           JSR     XXF84D          ; GET TAPE BUFFER 
START POINTER IN XY
13547  F857  8A                 TXA                    ; COPY TAPE BUFFER 
START POINTER LOW BYTE
13548  F858  85 C1              STA     XXC1          ; SAVE AS I/O ADDRES
S POINTER LOW BYTE
13549  F85A  18                 CLC                    ; CLEAR CARRY FOR A
DD
13550  F85B  69 C0              ADC     #$C0               ; ADD BUFFER LE
NGTH LOW BYTE
13551  F85D  85 AE              STA     XXAE          ; SAVE TAPE BUFFER E
ND POINTER LOW BYTE
13552  F85F  98                 TYA                    ; COPY TAPE BUFFER 
START POINTER HIGH BYTE
13553  F860  85 C2              STA     XXC2          ; SAVE AS I/O ADDRES
S POINTER HIGH BYTE
13554  F862  69 00              ADC     #$00               ; ADD BUFFER LE
NGTH HIGH BYTE
13555  F864  85 AF              STA     XXAF          ; SAVE TAPE BUFFER E
ND POINTER HIGH BYTE
13556  F866  60                 RTS
13557  F867                     
13558  F867                     
13559  F867              ;************************************************
***********************************;
13560  F867              ;
13561  F867              ; FIND SPECIFIC TAPE HEADER
13562  F867              
13563  F867              XXF867 = *
13564  F867  20 AF F7           JSR     XXF7AF          ; FIND TAPE HEADER
, EXIT WITH HEADER IN BUFFER
13565  F86A  B0 1D              BCS     XXF889          ; JUST EXIT IF ERR
OR
13566  F86C                     
13567  F86C  A0 05              LDY     #$05               ; INDEX TO NAME

13568  F86E  84 9F              STY     XX9F          ; SAVE AS TAPE BUFFE
R INDEX
13569  F870  A0 00              LDY     #$00               ; CLEAR Y
13570  F872  84 9E              STY     XX9E          ; SAVE AS NAME BUFFE
R INDEX
13571  F874              XXF874 = *






****;I......PAGE 0263

LINE# LOC   CODE        LINE


13572  F874  C4 B7              CPY     XXB7          ; COMPARE WITH FILE 
NAME LENGTH
13573  F876  F0 10              BEQ     XXF888          ; OK EXIT IF MATCH

13574  F878                     
13575  F878  B1 BB              LDA     (XXBB),Y          ; GET FILE NAME 
BYTE
13576  F87A  A4 9F              LDY     XX9F          ; GET INDEX TO TAPE 
BUFFER
13577  F87C  D1 B2              CMP     (XXB2),Y          ; COMPARE WITH T
APE HEADER NAME BYTE
13578  F87E  D0 E7              BNE     XXF867          ; IF NO MATCH GO G
ET NEXT HEADER
13579  F880                     
13580  F880  E6 9E              INC     XX9E          ; ELSE INCREMENT NAM
E BUFFER INDEX
13581  F882  E6 9F              INC     XX9F          ; INCREMENT TAPE BUF
FER INDEX
13582  F884  A4 9E              LDY     XX9E          ; GET NAME BUFFER IN
DEX
13583  F886  D0 EC              BNE     XXF874          ; LOOP, BRANCH ALW
AYS
13584  F888                     
13585  F888              XXF888 = *
13586  F888  18                 CLC                    ; FLAG OK
13587  F889              XXF889 = *
13588  F889  60                 RTS
13589  F88A                     
13590  F88A                     
13591  F88A              ;************************************************
***********************************;
13592  F88A              ;
13593  F88A              ; BUMP TAPE POINTER
13594  F88A              
13595  F88A              XXF88A = *
13596  F88A  20 4D F8           JSR     XXF84D          ; GET TAPE BUFFER 
START POINTER IN XY
13597  F88D  E6 A6              INC     XXA6          ; INCREMENT TAPE BUF
FER INDEX
13598  F88F  A4 A6              LDY     XXA6          ; GET TAPE BUFFER IN
DEX
13599  F891  C0 C0              CPY     #$C0               ; COMPARE WITH 
BUFFER LENGTH
13600  F893  60                 RTS
13601  F894                     
13602  F894                     
13603  F894              ;************************************************
***********************************;
13604  F894              ;
13605  F894              ; WAIT FOR PLAY
13606  F894              
13607  F894              XXF894 = *
13608  F894  20 AB F8           JSR     XXF8AB          ; RETURN CASSETTE 
SENSE IN ZB
13609  F897  F0 1C              BEQ     XXF8B5          ; EXIT IF SWITCH C
LOSED
13610  F899                     
13611  F899                                     ; CASSETTE SWITCH WAS OPEN

13612  F899  A0 1B              LDY     #XXF18F-XXF174
13613  F89B                                     ; INDEX TO 'PRESS PLAY ON 
TAPE'
13614  F89B              XXF89B = *
13615  F89B  20 E6 F1           JSR     XXF1E6          ; DISPLAY KERNEL I
/O MESSAGE
13616  F89E              XXF89E = *
13617  F89E  20 4B F9           JSR     XXF94B          ; SCAN STOP KEY AN
D FLAG ABORT IF PRESSED
13618  F8A1                                     ; NOTE IF STOP WAS PRESSED
 THE RETURN IS TO THE
13619  F8A1                                     ; ROUTINE THAT CALLED THIS
 ONE AND NOT HERE
13620  F8A1  20 AB F8           JSR     XXF8AB          ; RETURN CASSETTE 
SENSE IN ZB
13621  F8A4  D0 F8              BNE     XXF89E          ; LOOP IF CASSETTE
 SWITCH OPEN
13622  F8A6                     
13623  F8A6  A0 6A              LDY     #XXF1DE-XXF174
13624  F8A8                                     ; INDEX TO 'OK'
13625  F8A8  4C E6 F1           JMP     XXF1E6          ; DISPLAY KERNEL I
/O MESSAGE AND RETURN
13626  F8AB                     






****;I......PAGE 0264

LINE# LOC   CODE        LINE


13627  F8AB                     
13628  F8AB              ;************************************************
***********************************;
13629  F8AB              ;
13630  F8AB              ; RETURN CASSETTE SENSE IN ZB
13631  F8AB              
13632  F8AB              XXF8AB = *
13633  F8AB  A9 40              LDA     #$40               ; MASK FOR CASS
ETTE SWITCH
13634  F8AD  2C 1F 91           BIT     XX911F          ; TEST VIA 1 DRA, 
NO HANDSHAKE
13635  F8B0  D0 03              BNE     XXF8B5          ; BRANCH IF CASSET
TE SENSE HIGH
13636  F8B2                     
13637  F8B2  2C 1F 91           BIT     XX911F          ; TEST VIA 1 DRA A
GAIN
13638  F8B5              XXF8B5 = *
13639  F8B5  18                 CLC
13640  F8B6  60                 RTS
13641  F8B7                     
13642  F8B7                     
13643  F8B7              ;************************************************
***********************************;
13644  F8B7              ;
13645  F8B7              ; WAIT FOR PLAY/RECORD
13646  F8B7              
13647  F8B7              XXF8B7 = *
13648  F8B7  20 AB F8           JSR     XXF8AB          ; RETURN CASSETTE 
SENSE IN ZB
13649  F8BA  F0 F9              BEQ     XXF8B5          ; EXIT IF SWITCH C
LOSED
13650  F8BC                     
13651  F8BC                                     ; CASSETTE SWITCH WAS OPEN

13652  F8BC  A0 2E              LDY     #XXF1A2-XXF174
13653  F8BE                                     ; INDEX TO 'PRESS RECORD &
 PLAY ON TAPE'
13654  F8BE  D0 DB              BNE     XXF89B          ; DISPLAY MESSAGE 
AND WAIT FOR SWITCH, BRANCH ALWAYS
13655  F8C0                     
13656  F8C0                     
13657  F8C0              ;************************************************
***********************************;
13658  F8C0              ;
13659  F8C0              ; INITIATE TAPE READ
13660  F8C0              
13661  F8C0              XXF8C0 = *
13662  F8C0  A9 00              LDA     #$00               ; CLEAR A
13663  F8C2  85 90              STA     XX90          ; CLEAR SERIAL STATU
S BYTE
13664  F8C4  85 93              STA     XX93          ; CLEAR THE LOAD/VER
IFY FLAG
13665  F8C6  20 54 F8           JSR     XXF854          ; SET TAPE BUFFER 
START AND END POINTERS
13666  F8C9              XXF8C9 = *
13667  F8C9  20 94 F8           JSR     XXF894          ; WAIT FOR PLAY
13668  F8CC  B0 1F              BCS     XXF8ED          ; EXIT IF STOP WAS
 PRESSED, USES FURTHER BCS AT TARGET
13669  F8CE                                     ; ADDRESS TO REACH FINAL T
ARGET AT XXF957
13670  F8CE                     
13671  F8CE  78                 SEI                    ; DISABLE INTERRUPT
S
13672  F8CF  A9 00              LDA     #$00               ; CLEAR A
13673  F8D1  85 AA              STA     XXAA          ;.
13674  F8D3  85 B4              STA     XXB4          ;.
13675  F8D5  85 B0              STA     XXB0          ; CLEAR TAPE TIMING 
CONSTANT MIN BYTE
13676  F8D7  85 9E              STA     XX9E          ; CLEAR TAPE PASS 1 
ERROR LOG/CHAR BUFFER
13677  F8D9  85 9F              STA     XX9F          ; CLEAR TAPE PASS 2 
ERROR LOG CORRECTED
13678  F8DB  85 9C              STA     XX9C          ; CLEAR BYTE RECEIVE
D FLAG
13679  F8DD  A9 82              LDA     #$82               ; ENABLE CA1 IN
TERRUPT
13680  F8DF  A2 0E              LDX     #$0E               ; SET INDEX FOR
 TAPE READ VECTOR
13681  F8E1  D0 11              BNE     XXF8F4          ; GO DO TAPE READ/
WRITE, BRANCH ALWAYS






GET*;I......PAGE 0265

LINE# LOC   CODE        LINE


13682  F8E3                     
13683  F8E3                     
13684  F8E3              ;************************************************
***********************************;
13685  F8E3              ;
13686  F8E3              ; INITIATE TAPE WRITE
13687  F8E3              
13688  F8E3              XXF8E3 = *
13689  F8E3  20 54 F8           JSR     XXF854          ; SET TAPE BUFFER 
START AND END POINTERS
13690  F8E6                     
13691  F8E6              ; DO TAPE WRITE, 20 CYCLE COUNT
13692  F8E6              
13693  F8E6              XXF8E6 = *
13694  F8E6  A9 14              LDA     #$14               ; SET WRITE LEA
D CYCLE COUNT
13695  F8E8  85 AB              STA     XXAB          ; SAVE WRITE LEAD CY
CLE COUNT
13696  F8EA                     
13697  F8EA              ; DO TAPE WRITE, NO CYCLE COUNT SET
13698  F8EA              
13699  F8EA              XXF8EA = *
13700  F8EA  20 B7 F8           JSR     XXF8B7          ; WAIT FOR PLAY/RE
CORD
13701  F8ED              XXF8ED = *
13702  F8ED  B0 68              BCS     XXF957          ; IF STOPPED CLEAR
 SAVE IRQ ADDRESS AND EXIT
13703  F8EF                     
13704  F8EF  78                 SEI                    ; DISABLE INTERRUPT
S
13705  F8F0  A9 A0              LDA     #$A0               ; ENABLE VIA 2 
T2 INTERRUPT
13706  F8F2  A2 08              LDX     #$08               ; SET INDEX FOR
 TAPE WRITE TAPE LEADER VECTOR
13707  F8F4                     
13708  F8F4                     
13709  F8F4              ;************************************************
***********************************;
13710  F8F4              ;
13711  F8F4              ; TAPE READ/WRITE
13712  F8F4              
13713  F8F4              XXF8F4 = *
13714  F8F4  A0 7F              LDY     #$7F               ; DISABLE ALL I
NTERRUPTS
13715  F8F6  8C 2E 91           STY     XX912E          ; SET VIA 2 IER, D
ISABLE INTERRUPTS
13716  F8F9  8D 2E 91           STA     XX912E          ; SET VIA 2 IER, E
NABLE INTERRUPTS ACCORDING TO A
13717  F8FC  20 60 F1           JSR     XXF160          ; CHECK RS232 BUS 
IDLE
13718  F8FF  AD 14 03           LDA     XX0314          ; GET IRQ VECTOR L
OW BYTE
13719  F902  8D 9F 02           STA     XX029F          ; SAVE IRQ VECTOR 
LOW BYTE
13720  F905  AD 15 03           LDA     XX0315          ; GET IRQ VECTOR H
IGH BYTE
13721  F908  8D A0 02           STA     XX02A0          ; SAVE IRQ VECTOR 
HIGH BYTE
13722  F90B  20 FB FC           JSR     XXFCFB          ; SET TAPE VECTOR
13723  F90E  A9 02              LDA     #$02               ; SET COPIES CO
UNT. THE FIRST COPY IS THE LOAD COPY, THE
13724  F910                                     ; SECOND COPY IS THE VERIF
Y COPY
13725  F910  85 BE              STA     XXBE          ; SAVE COPIES COUNT
13726  F912  20 DB FB           JSR     XXFBDB          ; NEW TAPE BYTE SE
TUP
13727  F915  AD 1C 91           LDA     XX911C          ; GET VIA 1 PCR
13728  F918  29 FD              AND     #$FD               ; CA2 LOW, TURN
 ON TAPE MOTOR
13729  F91A  09 0C              ORA     #$0C               ; MANUAL OUTPUT
 MODE
13730  F91C  8D 1C 91           STA     XX911C          ; SET VIA 1 PCR
13731  F91F  85 C0              STA     XXC0          ; SET TAPE MOTOR INT
ERLOCK
13732  F921                     
13733  F921                                     ; 326656 CYCLE DELAY, ALLO
W TAPE MOTOR SPEED TO STABILISE
13734  F921  A2 FF              LDX     #$FF               ; OUTER LOOP CO
UNT
13735  F923              XXF923 = *
13736  F923  A0 FF              LDY     #$FF               ; INNER LOOP CO
UNT






SEY, T......PAGE 0266

LINE# LOC   CODE        LINE


13737  F925              XXF925 = *
13738  F925  88                 DEY                    ; DECREMENT INNER L
OOP COUNT
13739  F926  D0 FD              BNE     XXF925          ; LOOP IF MORE TO 
DO
13740  F928                     
13741  F928  CA                 DEX                    ; DECREMENT OUTER L
OOP COUNT
13742  F929  D0 F8              BNE     XXF923          ; LOOP IF MORE TO 
DO
13743  F92B                     
13744  F92B  8D 29 91           STA     XX9129          ; SET VIA 2 T2C_H
13745  F92E  58                 CLI                    ; ENABLE TAPE INTER
RUPTS
13746  F92F              XXF92F = *
13747  F92F  AD A0 02           LDA     XX02A0          ; GET SAVED IRQ HI
GH BYTE
13748  F932  CD 15 03           CMP     XX0315          ; COMPARE WITH THE
 CURRENT IRQ HIGH BYTE
13749  F935  18                 CLC                    ; FLAG OK
13750  F936  F0 1F              BEQ     XXF957          ; IF TAPE WRITE DO
NE GO CLEAR SAVED IRQ ADDRESS AND EXIT
13751  F938                     
13752  F938  20 4B F9           JSR     XXF94B          ; SCAN STOP KEY AN
D FLAG ABORT IF PRESSED
13753  F93B                                     ; NOTE IF STOP WAS PRESSED
 THE RETURN IS TO THE
13754  F93B                                     ; ROUTINE THAT CALLED THIS
 ONE AND NOT HERE
13755  F93B  AD 2D 91           LDA     XX912D          ; GET VIA 2 IFR
13756  F93E  29 40              AND     #$40               ; MASK T1 INTER
RUPT
13757  F940  F0 ED              BEQ     XXF92F          ; LOOP IF NOT T1 I
NTERRUPT
13758  F942                     
13759  F942                                     ; ELSE INCREMENT JIFFY CLO
CK
13760  F942  AD 14 91           LDA     XX9114          ; GET VIA 1 T1C_L,
 CLEAR T1 FLAG
13761  F945  20 34 F7           JSR     XXF734          ; INCREMENT THE RE
AL TIME CLOCK
13762  F948  4C 2F F9           JMP     XXF92F          ; LOOP
13763  F94B                     
13764  F94B                     
13765  F94B              ;************************************************
***********************************;
13766  F94B              ;
13767  F94B              ; SCAN STOP KEY AND FLAG ABORT IF PRESSED
13768  F94B              
13769  F94B              XXF94B = *
13770  F94B  20 E1 FF           JSR     XXFFE1          ; SCAN STOP KEY
13771  F94E  18                 CLC                    ; FLAG NO STOP
13772  F94F  D0 0B              BNE     XXF95C          ; EXIT IF NO STOP
13773  F951                     
13774  F951  20 CF FC           JSR     XXFCCF          ; RESTORE EVERYTHI
NG FOR STOP
13775  F954  38                 SEC                    ; FLAG STOPPED
13776  F955  68                 PLA                    ; DUMP RETURN ADDRE
SS LOW BYTE
13777  F956  68                 PLA                    ; DUMP RETURN ADDRE
SS HIGH BYTE
13778  F957                     
13779  F957                     
13780  F957              ;************************************************
***********************************;
13781  F957              ;
13782  F957              ; CLEAR SAVED IRQ ADDRESS
13783  F957              
13784  F957              XXF957 = *
13785  F957  A9 00              LDA     #$00               ; CLEAR A
13786  F959  8D A0 02           STA     XX02A0          ; CLEAR SAVED IRQ 
ADDRESS HIGH BYTE
13787  F95C              XXF95C = *
13788  F95C  60                 RTS
13789  F95D                     
13790  F95D                     
13791  F95D              ;************************************************
***********************************;






****;T......PAGE 0267

LINE# LOC   CODE        LINE


13792  F95D              ;
13793  F95D              ;## SET TIMING
13794  F95D              
13795  F95D              XXF95D = *
13796  F95D  86 B1              STX     XXB1          ; SAVE TAPE TIMING C
ONSTANT MAX BYTE
13797  F95F  A5 B0              LDA     XXB0          ; GET TAPE TIMING CO
NSTANT MIN BYTE
13798  F961  0A                 ASL A                  ; *2
13799  F962  0A                 ASL A                  ; *4
13800  F963  18                 CLC                    ; CLEAR CARRY FOR A
DD
13801  F964  65 B0              ADC     XXB0          ; ADD TAPE TIMING CO
NSTANT MIN BYTE *5
13802  F966  18                 CLC                    ; CLEAR CARRY FOR A
DD
13803  F967  65 B1              ADC     XXB1          ; ADD TAPE TIMING CO
NSTANT MAX BYTE
13804  F969  85 B1              STA     XXB1          ; SAVE TAPE TIMING C
ONSTANT MAX BYTE
13805  F96B  A9 00              LDA     #$00               ;.
13806  F96D  24 B0              BIT     XXB0          ; TEST TAPE TIMING C
ONSTANT MIN BYTE
13807  F96F  30 01              BMI     XXF972          ; BRANCH IF B7 SET

13808  F971                     
13809  F971  2A                 ROL A                  ; ELSE SHIFT CARRY 
INTO ??
13810  F972              XXF972 = *
13811  F972  06 B1              ASL     XXB1          ; SHIFT TAPE TIMING 
CONSTANT MAX BYTE
13812  F974  2A                 ROL A                  ;.
13813  F975  06 B1              ASL     XXB1          ; SHIFT TAPE TIMING 
CONSTANT MAX BYTE
13814  F977  2A                 ROL A                  ;.
13815  F978  AA                 TAX                    ;.
13816  F979              XXF979 = *
13817  F979  AD 28 91           LDA     XX9128          ; GET VIA 2 T2C_L
13818  F97C  C9 15              CMP     #$15               ;.COMPARE WITH 
??
13819  F97E  90 F9              BCC     XXF979          ; LOOP IF LESS
13820  F980                     
13821  F980  65 B1              ADC     XXB1          ; ADD TAPE TIMING CO
NSTANT MAX BYTE
13822  F982  8D 24 91           STA     XX9124          ; SET VIA 2 T1C_L
13823  F985  8A                 TXA                    ;.
13824  F986  6D 29 91           ADC     XX9129          ; ADD VIA 2 T2C_H
13825  F989  8D 25 91           STA     XX9125          ; SET VIA 2 T1C_H
13826  F98C  58                 CLI                    ; ENABLE INTERRUPTS

13827  F98D  60                 RTS
13828  F98E                     
13829  F98E                     
13830  F98E              ;************************************************
***********************************;
13831  F98E              ;
13832  F98E              ;;     ON COMMODORE COMPUTERS, THE STREAMS CONSIS
T OF FOUR KINDS OF SYMBOLS
13833  F98E              ;;     THAT DENOTE DIFFERENT KINDS OF LOW-TO-HIGH
-TO-LOW TRANSITIONS ON THE
13834  F98E              ;;     READ OR WRITE SIGNALS OF THE COMMODORE CAS
SETTE INTERFACE.
13835  F98E              ;;
13836  F98E              ;;     A     A BREAK IN THE COMMUNICATIONS, OR A 
PULSE WITH VERY LONG CYCLE
13837  F98E              ;;          TIME.
13838  F98E              ;;
13839  F98E              ;;     B     A SHORT PULSE, WHOSE CYCLE TIME TYPI
CALLY RANGES FROM 296 TO 424
13840  F98E              ;;          MICROSECONDS, DEPENDING ON THE COMPUT
ER MODEL.
13841  F98E              ;;
13842  F98E              ;;     C     A MEDIUM-LENGTH PULSE, WHOSE CYCLE T
IME TYPICALLY RANGES FROM
13843  F98E              ;;          440 TO 576 MICROSECONDS, DEPENDING ON
 THE COMPUTER MODEL.
13844  F98E              ;;
13845  F98E              ;;     D     A LONG PULSE, WHOSE CYCLE TIME TYPIC
ALLY RANGES FROM 600 TO 744
13846  F98E              ;;          MICROSECONDS, DEPENDING ON THE COMPUT
ER MODEL.






****;T......PAGE 0268

LINE# LOC   CODE        LINE


13847  F98E              ;;
13848  F98E              ;;   THE ACTUAL INTERPRETATION OF THE SERIAL DATA
 TAKES A LITTLE MORE WORK TO
13849  F98E              ;; EXPLAIN. THE TYPICAL ROM TAPE LOADER (AND THE 
TURBO LOADERS) WILL
13850  F98E              ;; INITIALIZE A TIMER WITH A SPECIFIED VALUE AND 
START IT COUNTING DOWN. IF
13851  F98E              ;; EITHER THE TAPE DATA CHANGES OR THE TIMER RUNS
 OUT, AN IRQ WILL OCCUR. THE
13852  F98E              ;; LOADER WILL DETERMINE WHICH CONDITION CAUSED T
HE IRQ. IF THE TAPE DATA
13853  F98E              ;; CHANGED BEFORE THE TIMER RAN OUT, WE HAVE A SH
ORT PULSE, OR A '0' BIT. IF
13854  F98E              ;; THE TIMER RAN OUT FIRST, WE HAVE A LONG PULSE,
 OR A '1' BIT. DOING THIS
13855  F98E              ;; CONTINUOUSLY AND WE DECODE THE ENTIRE FILE.
13856  F98E              
13857  F98E              ; READ TAPE BITS, IRQ ROUTINE
13858  F98E              
13859  F98E              ; READ T2C WHICH HAS BEEN COUNTING DOWN FROM $FFF
F. SUBTRACT THIS FROM $FFFF
13860  F98E              
13861  F98E              XXF98E = *
13862  F98E  AE 29 91           LDX     XX9129          ; GET VIA 2 T2C_H
13863  F991  A0 FF              LDY     #$FF               ;.SET $FF
13864  F993  98                 TYA                    ;.A = $FF
13865  F994  ED 28 91           SBC     XX9128          ; SUBTRACT VIA 2 T
2C_L
13866  F997  EC 29 91           CPX     XX9129          ; COMPARE VIA 2 T2
C_H WITH PREVIOUS
13867  F99A  D0 F2              BNE     XXF98E          ; LOOP IF TIMER LO
W BYTE ROLLED OVER
13868  F99C                     
13869  F99C  86 B1              STX     XXB1          ; SAVE TAPE TIMING C
ONSTANT MAX BYTE
13870  F99E  AA                 TAX                    ;.COPY $FF - T2C_L
13871  F99F  8C 28 91           STY     XX9128          ; SET VIA 2 T2C_L 
TO $FF
13872  F9A2  8C 29 91           STY     XX9129          ; SET VIA 2 T2C_H 
TO $FF
13873  F9A5  98                 TYA                    ;.$FF
13874  F9A6  E5 B1              SBC     XXB1          ; SUBTRACT TAPE TIMI
NG CONSTANT MAX BYTE
13875  F9A8                                     ; A = $FF - T2C_H
13876  F9A8  86 B1              STX     XXB1          ; SAVE TAPE TIMING C
ONSTANT MAX BYTE
13877  F9AA                                     ; XXB1 = $FF - T2C_L
13878  F9AA  4A                 LSR A                  ;.A = $FF - T2C_H >
> 1
13879  F9AB  66 B1              ROR     XXB1          ; SHIFT TAPE TIMING 
CONSTANT MAX BYTE
13880  F9AD                                     ; XXB1 = $FF - T2C_L >> 1
13881  F9AD  4A                 LSR A                  ;.A = $FF - T2C_H >
> 1
13882  F9AE  66 B1              ROR     XXB1          ; SHIFT TAPE TIMING 
CONSTANT MAX BYTE
13883  F9B0                                     ; XXB1 = $FF - T2C_L >> 1
13884  F9B0  A5 B0              LDA     XXB0          ; GET TAPE TIMING CO
NSTANT MIN BYTE
13885  F9B2  18                 CLC                    ; CLEAR CARRY FOR A
DD
13886  F9B3  69 3C              ADC     #$3C               ;.
13887  F9B5  2C 21 91           BIT     XX9121          ; TEST VIA 2 DRA, 
KEYBOARD ROW
13888  F9B8  C5 B1              CMP     XXB1          ; COMPARE WITH TAPE 
TIMING CONSTANT MAX BYTE
13889  F9BA                                     ; COMPARE WITH ($FFFF - T2
C) >> 2
13890  F9BA  B0 4A              BCS     XXFA06          ;.BRANCH IF MIN + 
$3C >= ($FFFF - T2C) >> 2
13891  F9BC                     
13892  F9BC                                     ;.MIN + $3C < ($FFFF - T2C
) >> 2
13893  F9BC  A6 9C              LDX     XX9C          ;.GET BYTE RECEIVED 
FLAG
13894  F9BE  F0 03              BEQ     XXF9C3          ;.BRANCH IF NOT BY
TE RECEIVED
13895  F9C0                     
13896  F9C0  4C AD FA           JMP     XXFAAD          ;.STORE TAPE CHARA
CTER
13897  F9C3                     
13898  F9C3              XXF9C3 = *
13899  F9C3  A6 A3              LDX     XXA3          ;.GET EOI FLAG BYTE
13900  F9C5  30 1B              BMI     XXF9E2          ;.
13901  F9C7                     






****;T......PAGE 0269

LINE# LOC   CODE        LINE


13902  F9C7  A2 00              LDX     #$00               ;.
13903  F9C9  69 30              ADC     #$30               ;.
13904  F9CB  65 B0              ADC     XXB0          ; ADD TAPE TIMING CO
NSTANT MIN BYTE
13905  F9CD  C5 B1              CMP     XXB1          ; COMPARE WITH TAPE 
TIMING CONSTANT MAX BYTE
13906  F9CF  B0 1C              BCS     XXF9ED          ;.
13907  F9D1                     
13908  F9D1  E8                 INX                    ;.
13909  F9D2  69 26              ADC     #$26               ;.
13910  F9D4  65 B0              ADC     XXB0          ; ADD TAPE TIMING CO
NSTANT MIN BYTE
13911  F9D6  C5 B1              CMP     XXB1          ; COMPARE WITH TAPE 
TIMING CONSTANT MAX BYTE
13912  F9D8  B0 17              BCS     XXF9F1          ;.
13913  F9DA                     
13914  F9DA  69 2C              ADC     #$2C               ;.
13915  F9DC  65 B0              ADC     XXB0          ; ADD TAPE TIMING CO
NSTANT MIN BYTE
13916  F9DE  C5 B1              CMP     XXB1          ; COMPARE WITH TAPE 
TIMING CONSTANT MAX BYTE
13917  F9E0  90 03              BCC     XXF9E5          ;.
13918  F9E2                     
13919  F9E2              XXF9E2 = *
13920  F9E2  4C 60 FA           JMP     XXFA60          ;.
13921  F9E5                     
13922  F9E5              XXF9E5 = *
13923  F9E5  A5 B4              LDA     XXB4          ; GET BIT COUNT
13924  F9E7  F0 1D              BEQ     XXFA06          ; BRANCH IF ZERO
13925  F9E9                     
13926  F9E9  85 A8              STA     XXA8          ; SAVE RECEIVER BIT 
COUNT IN
13927  F9EB  D0 19              BNE     XXFA06          ; BRANCH ALWAYS
13928  F9ED                     
13929  F9ED              XXF9ED = *
13930  F9ED  E6 A9              INC     XXA9          ; INCREMENT ?? START
 BIT CHECK FLAG
13931  F9EF  B0 02              BCS     XXF9F3          ;.
13932  F9F1                     
13933  F9F1              XXF9F1 = *
13934  F9F1  C6 A9              DEC     XXA9          ; DECREMENT ?? START
 BIT CHECK FLAG
13935  F9F3              XXF9F3 = *
13936  F9F3  38                 SEC                    ;.
13937  F9F4  E9 13              SBC     #$13               ;.
13938  F9F6  E5 B1              SBC     XXB1          ; SUBTRACT TAPE TIMI
NG CONSTANT MAX BYTE
13939  F9F8  65 92              ADC     XX92          ; ADD TIMING CONSTAN
T FOR TAPE
13940  F9FA  85 92              STA     XX92          ; SAVE TIMING CONSTA
NT FOR TAPE
13941  F9FC  A5 A4              LDA     XXA4          ;.GET TAPE BIT CYCLE
 PHASE
13942  F9FE  49 01              EOR     #$01               ;.
13943  FA00  85 A4              STA     XXA4          ;.SAVE TAPE BIT CYCL
E PHASE
13944  FA02  F0 21              BEQ     XXFA25          ;.
13945  FA04                     
13946  FA04  86 D7              STX     XXD7          ;.
13947  FA06              XXFA06 = *
13948  FA06  A5 B4              LDA     XXB4          ; GET BIT COUNT
13949  FA08  F0 18              BEQ     XXFA22          ; EXIT IF ZERO
13950  FA0A                     
13951  FA0A  2C 2D 91           BIT     XX912D          ; TEST GET 2 IFR
13952  FA0D  50 13              BVC     XXFA22          ; EXIT IF NO T1 IN
TERRUPT
13953  FA0F                     
13954  FA0F  A9 00              LDA     #$00               ;.
13955  FA11  85 A4              STA     XXA4          ; CLEAR TAPE BIT CYC
LE PHASE
13956  FA13  A5 A3              LDA     XXA3          ;.GET EOI FLAG BYTE






****;T......PAGE 0270

LINE# LOC   CODE        LINE


13957  FA15  10 30              BPL     XXFA47          ;.
13958  FA17                     
13959  FA17  30 C9              BMI     XXF9E2          ;.
13960  FA19                     
13961  FA19              XXFA19 = *
13962  FA19  A2 A6              LDX     #$A6               ; SET TIMIMG MA
X BYTE
13963  FA1B  20 5D F9           JSR     XXF95D          ; SET TIMING
13964  FA1E  A5 9B              LDA     XX9B          ;.
13965  FA20  D0 C3              BNE     XXF9E5          ;.
13966  FA22              XXFA22 = *
13967  FA22  4C 56 FF           JMP     XXFF56          ; RESTORE REGISTER
S AND EXIT INTERRUPT
13968  FA25                     
13969  FA25              XXFA25 = *
13970  FA25  A5 92              LDA     XX92          ; GET TIMING CONSTAN
T FOR TAPE
13971  FA27  F0 07              BEQ     XXFA30          ;.
13972  FA29                     
13973  FA29  30 03              BMI     XXFA2E          ;.
13974  FA2B                     
13975  FA2B  C6 B0              DEC     XXB0          ; DECREMENT TAPE TIM
ING CONSTANT MIN BYTE
13976  FA2D  2C                 .BYTE     $2C               ; MAKES NEXT L
INE BIT XXB0E6
13977  FA2E              XXFA2E = *
13978  FA2E  E6 B0              INC     XXB0          ; INCREMENT TAPE TIM
ING CONSTANT MIN BYTE
13979  FA30              XXFA30 = *
13980  FA30  A9 00              LDA     #$00               ;.
13981  FA32  85 92              STA     XX92          ; CLEAR TIMING CONST
ANT FOR TAPE
13982  FA34  E4 D7              CPX     XXD7          ;.
13983  FA36  D0 0F              BNE     XXFA47          ;.
13984  FA38                     
13985  FA38  8A                 TXA                    ;.
13986  FA39  D0 AA              BNE     XXF9E5          ;.
13987  FA3B                     
13988  FA3B  A5 A9              LDA     XXA9          ; GET START BIT CHEC
K FLAG
13989  FA3D  30 C7              BMI     XXFA06          ;.
13990  FA3F                     
13991  FA3F  C9 10              CMP     #$10               ;.
13992  FA41  90 C3              BCC     XXFA06          ;.
13993  FA43                     
13994  FA43  85 96              STA     XX96          ;.SAVE CASSETTE BLOC
K SYNCHRONIZATION NUMBER
13995  FA45  B0 BF              BCS     XXFA06          ;.
13996  FA47                     
13997  FA47              XXFA47 = *
13998  FA47  8A                 TXA
13999  FA48  45 9B              EOR     XX9B          ;.
14000  FA4A  85 9B              STA     XX9B          ;.
14001  FA4C  A5 B4              LDA     XXB4          ;.
14002  FA4E  F0 D2              BEQ     XXFA22          ;.
14003  FA50                     
14004  FA50  C6 A3              DEC     XXA3          ;.DECREMENT EOI FLAG
 BYTE
14005  FA52  30 C5              BMI     XXFA19          ;.
14006  FA54                     
14007  FA54  46 D7              LSR     XXD7          ;.
14008  FA56  66 BF              ROR     XXBF          ;.PARITY COUNT
14009  FA58  A2 DA              LDX     #$DA               ; SET TIMIMG MA
X BYTE
14010  FA5A  20 5D F9           JSR     XXF95D          ; SET TIMING
14011  FA5D  4C 56 FF           JMP     XXFF56          ; RESTORE REGISTER
S AND EXIT INTERRUPT






****;T......PAGE 0271

LINE# LOC   CODE        LINE


14012  FA60                     
14013  FA60              XXFA60 = *
14014  FA60  A5 96              LDA     XX96          ;.GET CASSETTE BLOCK
 SYNCHRONIZATION NUMBER
14015  FA62  F0 04              BEQ     XXFA68          ;.
14016  FA64                     
14017  FA64  A5 B4              LDA     XXB4          ;.
14018  FA66  F0 04              BEQ     XXFA6C          ;.
14019  FA68                     
14020  FA68              XXFA68 = *
14021  FA68  A5 A3              LDA     XXA3          ;.GET EOI FLAG BYTE
14022  FA6A  10 85              BPL     XXF9F1          ;.
14023  FA6C                     
14024  FA6C              XXFA6C = *
14025  FA6C  46 B1              LSR     XXB1          ; SHIFT TAPE TIMING 
CONSTANT MAX BYTE
14026  FA6E  A9 93              LDA     #$93               ;.
14027  FA70  38                 SEC                    ;.
14028  FA71  E5 B1              SBC     XXB1          ; SUBTRACT TAPE TIMI
NG CONSTANT MAX BYTE
14029  FA73  65 B0              ADC     XXB0          ; ADD TAPE TIMING CO
NSTANT MIN BYTE
14030  FA75  0A                 ASL A                  ;.
14031  FA76  AA                 TAX                    ; COPY TIMIMG HIGH 
BYTE
14032  FA77  20 5D F9           JSR     XXF95D          ; SET TIMING
14033  FA7A  E6 9C              INC     XX9C          ;.
14034  FA7C  A5 B4              LDA     XXB4          ;.
14035  FA7E  D0 11              BNE     XXFA91          ;.
14036  FA80                     
14037  FA80  A5 96              LDA     XX96          ;.GET CASSETTE BLOCK
 SYNCHRONIZATION NUMBER
14038  FA82  F0 26              BEQ     XXFAAA          ;.
14039  FA84                     
14040  FA84  85 A8              STA     XXA8          ; SAVE RECEIVER BIT 
COUNT IN
14041  FA86  A9 00              LDA     #$00               ;.
14042  FA88  85 96              STA     XX96          ;.CLEAR CASSETTE BLO
CK SYNCHRONIZATION NUMBER
14043  FA8A  A9 C0              LDA     #$C0               ; ENABLE T1 INT
ERRUPT
14044  FA8C  8D 2E 91           STA     XX912E          ; SET VIA 2 IER
14045  FA8F  85 B4              STA     XXB4          ;.
14046  FA91              XXFA91 = *
14047  FA91  A5 96              LDA     XX96          ;.GET CASSETTE BLOCK
 SYNCHRONIZATION NUMBER
14048  FA93  85 B5              STA     XXB5          ;.
14049  FA95  F0 09              BEQ     XXFAA0          ;.
14050  FA97                     
14051  FA97  A9 00              LDA     #$00               ;.
14052  FA99  85 B4              STA     XXB4          ;.
14053  FA9B  A9 40              LDA     #$40               ; DISABLE T1 IN
TERRUPT
14054  FA9D  8D 2E 91           STA     XX912E          ; SET VIA 2 IER
14055  FAA0              XXFAA0 = *
14056  FAA0  A5 BF              LDA     XXBF          ;.PARITY COUNT
14057  FAA2  85 BD              STA     XXBD          ;.SAVE RS232 PARITY 
BYTE
14058  FAA4  A5 A8              LDA     XXA8          ; GET RECEIVER BIT C
OUNT IN
14059  FAA6  05 A9              ORA     XXA9          ; OR WITH START BIT 
CHECK FLAG
14060  FAA8  85 B6              STA     XXB6          ;.
14061  FAAA              XXFAAA = *
14062  FAAA  4C 56 FF           JMP     XXFF56          ; RESTORE REGISTER
S AND EXIT INTERRUPT
14063  FAAD                     
14064  FAAD                     
14065  FAAD              ;************************************************
***********************************;
14066  FAAD              ;






****;T......PAGE 0272

LINE# LOC   CODE        LINE


14067  FAAD              ;## STORE CHARACTER
14068  FAAD              
14069  FAAD              XXFAAD = *
14070  FAAD  20 DB FB           JSR     XXFBDB          ; NEW TAPE BYTE SE
TUP
14071  FAB0  85 9C              STA     XX9C          ; CLEAR BYTE RECEIVE
D FLAG
14072  FAB2  A2 DA              LDX     #$DA               ; SET TIMIMG MA
X BYTE
14073  FAB4  20 5D F9           JSR     XXF95D          ; SET TIMING
14074  FAB7  A5 BE              LDA     XXBE          ;.GET COPIES COUNT
14075  FAB9  F0 02              BEQ     XXFABD          ;.
14076  FABB                     
14077  FABB  85 A7              STA     XXA7          ; SAVE RECEIVER INPU
T BIT TEMPORARY STORAGE
14078  FABD              XXFABD = *
14079  FABD  A9 0F              LDA     #$0F               ;.
14080  FABF  24 AA              BIT     XXAA          ;.
14081  FAC1  10 17              BPL     XXFADA          ;.
14082  FAC3                     
14083  FAC3  A5 B5              LDA     XXB5          ;.
14084  FAC5  D0 0C              BNE     XXFAD3          ;.
14085  FAC7                     
14086  FAC7  A6 BE              LDX     XXBE          ;.GET COPIES COUNT
14087  FAC9  CA                 DEX                    ;.
14088  FACA  D0 0B              BNE     XXFAD7          ; IF ?? RESTORE RE
GISTERS AND EXIT INTERRUPT
14089  FACC                     
14090  FACC  A9 08              LDA     #$08               ; SET SHORT BLO
CK
14091  FACE  20 6A FE           JSR     XXFE6A          ; OR INTO SERIAL S
TATUS BYTE
14092  FAD1  D0 04              BNE     XXFAD7          ; RESTORE REGISTER
S AND EXIT INTERRUPT, BRANCH ALWAYS
14093  FAD3                     
14094  FAD3              XXFAD3 = *
14095  FAD3  A9 00              LDA     #$00               ;.
14096  FAD5  85 AA              STA     XXAA          ;.
14097  FAD7              XXFAD7 = *
14098  FAD7  4C 56 FF           JMP     XXFF56          ; RESTORE REGISTER
S AND EXIT INTERRUPT
14099  FADA                     
14100  FADA              XXFADA = *
14101  FADA  70 31              BVS     XXFB0D          ;.
14102  FADC                     
14103  FADC  D0 18              BNE     XXFAF6          ;.
14104  FADE                     
14105  FADE  A5 B5              LDA     XXB5          ;.
14106  FAE0  D0 F5              BNE     XXFAD7          ;.
14107  FAE2                     
14108  FAE2  A5 B6              LDA     XXB6          ;.
14109  FAE4  D0 F1              BNE     XXFAD7          ;.
14110  FAE6                     
14111  FAE6  A5 A7              LDA     XXA7          ; GET RECEIVER INPUT
 BIT TEMPORARY STORAGE
14112  FAE8  4A                 LSR A                  ;.
14113  FAE9  A5 BD              LDA     XXBD          ;.GET RS232 PARITY B
YTE
14114  FAEB  30 03              BMI     XXFAF0          ;.
14115  FAED                     
14116  FAED  90 18              BCC     XXFB07          ;.
14117  FAEF                     
14118  FAEF  18                 CLC                    ;.
14119  FAF0              XXFAF0 = *
14120  FAF0  B0 15              BCS     XXFB07          ;.
14121  FAF2                     






YS**;T......PAGE 0273

LINE# LOC   CODE        LINE


14122  FAF2  29 0F              AND     #$0F               ;.
14123  FAF4  85 AA              STA     XXAA          ;.
14124  FAF6              XXFAF6 = *
14125  FAF6  C6 AA              DEC     XXAA          ;.
14126  FAF8  D0 DD              BNE     XXFAD7          ;.
14127  FAFA                     
14128  FAFA  A9 40              LDA     #$40               ;.
14129  FAFC  85 AA              STA     XXAA          ;.
14130  FAFE  20 D2 FB           JSR     XXFBD2          ; COPY I/O START A
DDRESS TO BUFFER ADDRESS
14131  FB01  A9 00              LDA     #$00               ;.
14132  FB03  85 AB              STA     XXAB          ;.
14133  FB05  F0 D0              BEQ     XXFAD7          ;., BRANCH ALWAYS
14134  FB07                     
14135  FB07                     
14136  FB07              ;************************************************
***********************************;
14137  FB07              ;
14138  FB07              ;## RESET POINTER
14139  FB07              
14140  FB07              XXFB07 = *
14141  FB07  A9 80              LDA     #$80               ;.
14142  FB09  85 AA              STA     XXAA          ;.
14143  FB0B  D0 CA              BNE     XXFAD7          ; RESTORE REGISTER
S AND EXIT INTERRUPT, BRANCH ALWAYS
14144  FB0D                     
14145  FB0D              XXFB0D = *
14146  FB0D  A5 B5              LDA     XXB5          ;.
14147  FB0F  F0 0A              BEQ     XXFB1B          ;.
14148  FB11                     
14149  FB11  A9 04              LDA     #$04               ;.
14150  FB13  20 6A FE           JSR     XXFE6A          ; OR INTO SERIAL S
TATUS BYTE
14151  FB16  A9 00              LDA     #$00               ;.
14152  FB18  4C 97 FB           JMP     XXFB97          ;.
14153  FB1B                     
14154  FB1B              XXFB1B = *
14155  FB1B  20 11 FD           JSR     XXFD11          ; CHECK READ/WRITE
 POINTER, RETURN CB = 1 IF POINTER >= END
14156  FB1E  90 03              BCC     XXFB23          ;.
14157  FB20                     
14158  FB20  4C 95 FB           JMP     XXFB95          ;.
14159  FB23                     
14160  FB23              XXFB23 = *
14161  FB23  A6 A7              LDX     XXA7          ; GET RECEIVER INPUT
 BIT TEMPORARY STORAGE
14162  FB25  CA                 DEX                    ;.
14163  FB26  F0 2D              BEQ     XXFB55          ;.
14164  FB28                     
14165  FB28  A5 93              LDA     XX93          ; GET LOAD/VERIFY FL
AG
14166  FB2A  F0 0C              BEQ     XXFB38          ; BRANCH IF LOAD
14167  FB2C                     
14168  FB2C  A0 00              LDY     #$00               ; CLEAR INDEX
14169  FB2E  A5 BD              LDA     XXBD          ;.GET RS232 PARITY B
YTE
14170  FB30  D1 AC              CMP     (XXAC),Y          ;.
14171  FB32  F0 04              BEQ     XXFB38          ;.
14172  FB34                     
14173  FB34  A9 01              LDA     #$01               ;.
14174  FB36  85 B6              STA     XXB6          ;.
14175  FB38              XXFB38 = *
14176  FB38  A5 B6              LDA     XXB6          ;.






R >= E......PAGE 0274

LINE# LOC   CODE        LINE


14177  FB3A  F0 4B              BEQ     XXFB87          ;.
14178  FB3C                     
14179  FB3C  A2 3D              LDX     #$3D               ;.
14180  FB3E  E4 9E              CPX     XX9E          ;.
14181  FB40  90 3E              BCC     XXFB80          ;.
14182  FB42                     
14183  FB42  A6 9E              LDX     XX9E          ;.
14184  FB44  A5 AD              LDA     XXAD          ;.
14185  FB46  9D 01 01           STA     XX0100+1,X     ;.
14186  FB49  A5 AC              LDA     XXAC          ;.
14187  FB4B  9D 00 01           STA     XX0100,X          ;.
14188  FB4E  E8                 INX                    ;.
14189  FB4F  E8                 INX                    ;.
14190  FB50  86 9E              STX     XX9E          ;.
14191  FB52  4C 87 FB           JMP     XXFB87          ;.
14192  FB55                     
14193  FB55              XXFB55 = *
14194  FB55  A6 9F              LDX     XX9F          ;.
14195  FB57  E4 9E              CPX     XX9E          ;.
14196  FB59  F0 35              BEQ     XXFB90          ;.
14197  FB5B                     
14198  FB5B  A5 AC              LDA     XXAC          ;.
14199  FB5D  DD 00 01           CMP     XX0100,X          ;.
14200  FB60  D0 2E              BNE     XXFB90          ;.
14201  FB62                     
14202  FB62  A5 AD              LDA     XXAD          ;.
14203  FB64  DD 01 01           CMP     XX0100+1,X     ;.
14204  FB67  D0 27              BNE     XXFB90          ;.
14205  FB69                     
14206  FB69  E6 9F              INC     XX9F          ;.
14207  FB6B  E6 9F              INC     XX9F          ;.
14208  FB6D  A5 93              LDA     XX93          ; GET LOAD/VERIFY FL
AG
14209  FB6F  F0 0B              BEQ     XXFB7C          ; BRANCH IF LOAD
14210  FB71                     
14211  FB71  A5 BD              LDA     XXBD          ;.GET RS232 PARITY B
YTE
14212  FB73  A0 00              LDY     #$00               ;.
14213  FB75  D1 AC              CMP     (XXAC),Y          ;.
14214  FB77  F0 17              BEQ     XXFB90          ;.
14215  FB79                     
14216  FB79  C8                 INY                    ;.
14217  FB7A  84 B6              STY     XXB6          ;.
14218  FB7C              XXFB7C = *
14219  FB7C  A5 B6              LDA     XXB6          ;.
14220  FB7E  F0 07              BEQ     XXFB87          ;.
14221  FB80                     
14222  FB80              XXFB80 = *
14223  FB80  A9 10              LDA     #$10               ;.
14224  FB82  20 6A FE           JSR     XXFE6A          ; OR INTO SERIAL S
TATUS BYTE
14225  FB85  D0 09              BNE     XXFB90          ;.
14226  FB87                     
14227  FB87              XXFB87 = *
14228  FB87  A5 93              LDA     XX93          ; GET LOAD/VERIFY FL
AG
14229  FB89  D0 05              BNE     XXFB90          ; BRANCH IF VERIFY

14230  FB8B                     
14231  FB8B  A8                 TAY                    ;.






R >= E......PAGE 0275

LINE# LOC   CODE        LINE


14232  FB8C  A5 BD              LDA     XXBD          ;.GET RS232 PARITY B
YTE
14233  FB8E  91 AC              STA     (XXAC),Y          ;.
14234  FB90              XXFB90 = *
14235  FB90  20 1B FD           JSR     XXFD1B          ; INCREMENT READ/W
RITE POINTER
14236  FB93  D0 3A              BNE     XXFBCF          ; RESTORE REGISTER
S AND EXIT INTERRUPT, BRANCH ALWAYS
14237  FB95                     
14238  FB95              XXFB95 = *
14239  FB95  A9 80              LDA     #$80               ;.
14240  FB97              XXFB97 = *
14241  FB97  85 AA              STA     XXAA          ;.
14242  FB99  A6 BE              LDX     XXBE          ;.GET COPIES COUNT
14243  FB9B  CA                 DEX                    ;.
14244  FB9C  30 02              BMI     XXFBA0          ;.
14245  FB9E                     
14246  FB9E  86 BE              STX     XXBE          ;.SAVE COPIES COUNT
14247  FBA0              XXFBA0 = *
14248  FBA0  C6 A7              DEC     XXA7          ; DECREMENT RECEIVER
 INPUT BIT TEMPORARY STORAGE
14249  FBA2  F0 08              BEQ     XXFBAC          ;.
14250  FBA4                     
14251  FBA4  A5 9E              LDA     XX9E          ;.
14252  FBA6  D0 27              BNE     XXFBCF          ; IF ?? RESTORE RE
GISTERS AND EXIT INTERRUPT
14253  FBA8                     
14254  FBA8  85 BE              STA     XXBE          ;.SAVE COPIES COUNT
14255  FBAA  F0 23              BEQ     XXFBCF          ; RESTORE REGISTER
S AND EXIT INTERRUPT, BRANCH ALWAYS
14256  FBAC                     
14257  FBAC              XXFBAC = *
14258  FBAC  20 CF FC           JSR     XXFCCF          ; RESTORE EVERYTHI
NG FOR STOP
14259  FBAF  20 D2 FB           JSR     XXFBD2          ; COPY I/O START A
DDRESS TO BUFFER ADDRESS
14260  FBB2  A0 00              LDY     #$00               ; CLEAR INDEX
14261  FBB4  84 AB              STY     XXAB          ; CLEAR CHECKSUM
14262  FBB6              XXFBB6 = *
14263  FBB6  B1 AC              LDA     (XXAC),Y          ; GET BYTE FROM 
BUFFER
14264  FBB8  45 AB              EOR     XXAB          ; XOR WITH CHECKSUM
14265  FBBA  85 AB              STA     XXAB          ; SAVE NEW CHECKSUM
14266  FBBC  20 1B FD           JSR     XXFD1B          ; INCREMENT READ/W
RITE POINTER
14267  FBBF  20 11 FD           JSR     XXFD11          ; CHECK READ/WRITE
 POINTER, RETURN CB = 1 IF POINTER >= END
14268  FBC2  90 F2              BCC     XXFBB6          ; LOOP IF NOT AT E
ND
14269  FBC4                     
14270  FBC4  A5 AB              LDA     XXAB          ; GET COMPUTED CHECK
SUM
14271  FBC6  45 BD              EOR     XXBD          ; COMPARE WITH STORE
D CHECKSUM ??
14272  FBC8  F0 05              BEQ     XXFBCF          ; IF CHECKSUM OK R
ESTORE REGISTERS AND EXIT INTERRUPT
14273  FBCA                     
14274  FBCA  A9 20              LDA     #$20               ; ELSE SET CHEC
KSUM ERROR
14275  FBCC  20 6A FE           JSR     XXFE6A          ; OR INTO SERIAL S
TATUS BYTE
14276  FBCF              XXFBCF = *
14277  FBCF  4C 56 FF           JMP     XXFF56          ; RESTORE REGISTER
S AND EXIT INTERRUPT
14278  FBD2                     
14279  FBD2                     
14280  FBD2              ;************************************************
***********************************;
14281  FBD2              ;
14282  FBD2              ; COPY I/O START ADDRESS TO BUFFER ADDRESS
14283  FBD2              
14284  FBD2              XXFBD2 = *
14285  FBD2  A5 C2              LDA     XXC2          ; GET I/O START ADDR
ESS HIGH BYTE
14286  FBD4  85 AD              STA     XXAD          ; SET BUFFER ADDRESS
 HIGH BYTE






****;E......PAGE 0276

LINE# LOC   CODE        LINE


14287  FBD6  A5 C1              LDA     XXC1          ; GET I/O START ADDR
ESS LOW BYTE
14288  FBD8  85 AC              STA     XXAC          ; SET BUFFER ADDRESS
 LOW BYTE
14289  FBDA  60                 RTS
14290  FBDB                     
14291  FBDB                     
14292  FBDB              ;************************************************
***********************************;
14293  FBDB              ;
14294  FBDB              ; NEW TAPE BYTE SETUP
14295  FBDB              
14296  FBDB              XXFBDB = *
14297  FBDB  A9 08              LDA     #$08               ; EIGHT BITS TO
 DO
14298  FBDD  85 A3              STA     XXA3          ; SET BIT COUNT
14299  FBDF  A9 00              LDA     #$00               ; CLEAR A
14300  FBE1  85 A4              STA     XXA4          ; CLEAR TAPE BIT CYC
LE PHASE
14301  FBE3  85 A8              STA     XXA8          ; CLEAR START BIT FI
RST CYCLE DONE FLAG
14302  FBE5  85 9B              STA     XX9B          ; CLEAR BYTE PARITY
14303  FBE7  85 A9              STA     XXA9          ; CLEAR START BIT CH
ECK FLAG, SET NO START BIT YET
14304  FBE9  60                 RTS
14305  FBEA                     
14306  FBEA                     
14307  FBEA              ;************************************************
***********************************;
14308  FBEA              ;
14309  FBEA              ; SEND LSB FROM TAPE WRITE BYTE TO TAPE
14310  FBEA              
14311  FBEA              ; THIS ROUTINE TESTS THE LEAST SIGNIFICANT BIT IN
 THE TAPE WRITE BYTE AND SETS VIA 2 T2
14312  FBEA              ; DEPENDING ON THE STATE OF THE BIT. IF THE BIT I
S A 1 A TIME OF $00B0 CYCLES IS SET, IF
14313  FBEA              ; THE BOT IS A 0 A TIME OF $0060 CYCLES IS SET. N
OTE THAT THIS ROUTINE DOES NOT SHIFT THE
14314  FBEA              ; BITS OF THE TAPE WRITE BYTE BUT USES A COPY OF 
THAT BYTE, THE BYTE ITSELF IS SHIFTED
14315  FBEA              ; ELSEWHERE
14316  FBEA              
14317  FBEA              XXFBEA = *
14318  FBEA  A5 BD              LDA     XXBD          ; GET TAPE WRITE BYT
E
14319  FBEC  4A                 LSR A                  ; SHIFT LSB INTO CB

14320  FBED  A9 60              LDA     #$60               ; SET TIME CONS
TANT LOW BYTE FOR BIT = 0
14321  FBEF  90 02              BCC     XXFBF3          ; BRANCH IF BIT WA
S 0
14322  FBF1                     
14323  FBF1              ; SET TIME CONSTANT FOR BIT = 1 AND TOGGLE TAPE
14324  FBF1              
14325  FBF1              XXFBF1 = *
14326  FBF1  A9 B0              LDA     #$B0               ; SET TIME CONS
TANT LOW BYTE FOR BIT = 1
14327  FBF3                     
14328  FBF3              ; WRITE TIME CONSTANT AND TOGGLE TAPE
14329  FBF3              
14330  FBF3              XXFBF3 = *
14331  FBF3  A2 00              LDX     #$00               ; SET TIME CONS
TANT HIGH BYTE
14332  FBF5                     
14333  FBF5              ; WRITE TIME CONSTANT AND TOGGLE TAPE
14334  FBF5              
14335  FBF5              XXFBF5 = *
14336  FBF5  8D 28 91           STA     XX9128          ; SET VIA 2 T2C_L
14337  FBF8  8E 29 91           STX     XX9129          ; SET VIA 2 T2C_H
14338  FBFB  AD 20 91           LDA     XX9120          ; GET VIA 2 DRB, K
EYBOARD COLUMN
14339  FBFE  49 08              EOR     #$08               ; TOGGLE TAPE O
UT BIT
14340  FC00  8D 20 91           STA     XX9120          ; SET VIA 2 DRB
14341  FC03  29 08              AND     #$08               ; MASK TAPE OUT
 BIT






HIFTED......PAGE 0277

LINE# LOC   CODE        LINE


14342  FC05  60                 RTS
14343  FC06                     
14344  FC06                     
14345  FC06              ;************************************************
***********************************;
14346  FC06              ;
14347  FC06              ; FLAG BLOCK DONE AND EXIT INTERRUPT
14348  FC06              
14349  FC06              XXFC06 = *
14350  FC06  38                 SEC                    ; SET CARRY FLAG
14351  FC07  66 AD              ROR     XXAD          ; SET BUFFER ADDRESS
 HIGH BYTE NEGATIVE, FLAG ALL SYNC,
14352  FC09                                     ; DATA AND CHECKSUM BYTES 
WRITTEN
14353  FC09  30 3C              BMI     XXFC47          ; RESTORE REGISTER
S AND EXIT INTERRUPT, BRANCH ALWAYS
14354  FC0B                     
14355  FC0B                     
14356  FC0B              ;************************************************
***********************************;
14357  FC0B              ;
14358  FC0B              ; TAPE WRITE, IRQ ROUTINE.
14359  FC0B              
14360  FC0B              ; THIS IS THE ROUTINE THAT WRITES THE BITS TO THE
 TAPE. IT IS CALLED EACH TIME VIA 2 T2
14361  FC0B              ; TIMES OUT AND CHECKS IF THE START BIT IS DONE, 
IF SO CHECKS IF THE DATA BITS ARE DONE,
14362  FC0B              ; IF SO IT CHECKS IF THE BYTE IS DONE, IF SO IT C
HECKS IF THE SYNCHRONISATION BYTES ARE
14363  FC0B              ; DONE, IF SO IT CHECKS IF THE DATA BYTES ARE DON
E, IF SO IT CHECKS IF THE CHECKSUM BYTE
14364  FC0B              ; IS DONE, IF SO IT CHECKS IF BOTH THE LOAD AND V
ERIFY COPIES HAVE BEEN DONE, IF SO IT
14365  FC0B              ; STOPS THE TAPE
14366  FC0B              
14367  FC0B              XXFC0B = *
14368  FC0B  A5 A8              LDA     XXA8          ; GET START BIT FIRS
T CYCLE DONE FLAG
14369  FC0D  D0 12              BNE     XXFC21          ; IF FIRST CYCLE D
ONE GO DO REST OF BYTE
14370  FC0F                     
14371  FC0F              ; EACH BYTE SENT STARTS WITH TWO HALF CYCLES OF $
0110 STSTEM CLOCKS AND THE WHOLE BLOCK
14372  FC0F              ; ENDS WITH TWO MORE SUCH HALF CYCLES
14373  FC0F              
14374  FC0F  A9 10              LDA     #$10               ; SET FIRST STA
RT CYCLE TIME CONSTANT LOW BYTE
14375  FC11  A2 01              LDX     #$01               ; SET FIRST STA
RT CYCLE TIME CONSTANT HIGH BYTE
14376  FC13  20 F5 FB           JSR     XXFBF5          ; WRITE TIME CONST
ANT AND TOGGLE TAPE
14377  FC16  D0 2F              BNE     XXFC47          ; IF FIRST HALF CY
CLE GO RESTORE REGISTERS AND EXIT
14378  FC18                                     ; INTERRUPT
14379  FC18                     
14380  FC18  E6 A8              INC     XXA8          ; SET START BIT FIRS
T START CYCLE DONE FLAG
14381  FC1A  A5 AD              LDA     XXAD          ; GET BUFFER ADDRESS
 HIGH BYTE
14382  FC1C  10 29              BPL     XXFC47          ; IF BLOCK NOT COM
PLETE GO RESTORE REGISTERS AND EXIT
14383  FC1E                                     ; INTERRUPT. THE END OF A 
BLOCK IS INDICATED BY THE TAPE
14384  FC1E                                     ; BUFFER HIGH BYTE B7 BEIN
G SET TO 1
14385  FC1E                     
14386  FC1E  4C 95 FC           JMP     XXFC95          ; ELSE DO TAPE ROU
TINE, BLOCK COMPLETE EXIT
14387  FC21                     
14388  FC21              ; CONTINUE TAPE BYTE WRITE. THE FIRST START CYCLE
, BOTH HALF CYCLES OF IT, IS COMPLETE
14389  FC21              ; SO THE ROUTINE DROPS STRAIGHT THROUGH TO HERE
14390  FC21              
14391  FC21              XXFC21 = *
14392  FC21  A5 A9              LDA     XXA9          ; GET START BIT CHEC
K FLAG
14393  FC23  D0 09              BNE     XXFC2E          ; IF THE START BIT
 IS COMPLETE GO SEND THE BYTE BITS
14394  FC25                     
14395  FC25              ; AFTER THE TWO HALF CYCLES OF $0110 STSTEM CLOCK
S THE START BIT IS COMPLETED WITH TWO
14396  FC25              ; HALF CYCLES OF $00B0 SYSTEM CLOCKS. THIS IS THE
 SAME AS THE FIRST PART OF A 1 BIT






BITTWO......PAGE 0278

LINE# LOC   CODE        LINE


14397  FC25              
14398  FC25  20 F1 FB           JSR     XXFBF1          ; SET TIME CONSTAN
T FOR BIT = 1 AND TOGGLE TAPE
14399  FC28  D0 1D              BNE     XXFC47          ; IF FIRST HALF CY
CLE GO RESTORE REGISTERS AND EXIT
14400  FC2A                                     ; INTERRUPT
14401  FC2A                     
14402  FC2A  E6 A9              INC     XXA9          ; SET START BIT CHEC
K FLAG
14403  FC2C  D0 19              BNE     XXFC47          ; RESTORE REGISTER
S AND EXIT INTERRUPT, BRANCH ALWAYS
14404  FC2E                     
14405  FC2E              ; CONTINUE TAPE BYTE WRITE. THE START BIT, BOTH C
YCLES OF IT, IS COMPLETE SO THE ROUTINE
14406  FC2E              ; DROPS STRAIGHT THROUGH TO HERE. NOW THE CYCLE P
AIRS FOR EACH BIT, AND THE PARITY BIT,
14407  FC2E              ; ARE SENT
14408  FC2E              
14409  FC2E              XXFC2E = *
14410  FC2E  20 EA FB           JSR     XXFBEA          ; SEND LSB FROM TA
PE WRITE BYTE TO TAPE
14411  FC31  D0 14              BNE     XXFC47          ; IF FIRST HALF CY
CLE GO RESTORE REGISTERS AND EXIT
14412  FC33                                     ; INTERRUPT
14413  FC33                     
14414  FC33                                     ; ELSE TWO HALF CYCLES HAV
E BEEN DONE
14415  FC33  A5 A4              LDA     XXA4          ; GET TAPE BIT CYCLE
 PHASE
14416  FC35  49 01              EOR     #$01               ; TOGGLE B0
14417  FC37  85 A4              STA     XXA4          ; SAVE TAPE BIT CYCL
E PHASE
14418  FC39  F0 0F              BEQ     XXFC4A          ; IF BIT CYCLE PHA
SE COMPLETE GO SETUP FOR NEXT BIT
14419  FC3B                     
14420  FC3B              ; EACH BIT IS WRITTEN AS TWO FULL CYCLES. A 1 IS 
SENT AS A FULL CYCLE OF $0160 SYSTEM
14421  FC3B              ; CLOCKS THEN A FULL CYCLE OF $00C0 SYSTEM CLOCKS
. A 0 IS SENT AS A FULL CYCLE OF $00C0
14422  FC3B              ; SYSTEM CLOCKS THEN A FULL CYCLE OF $0160 SYSTEM
 CLOCKS. TO DO THIS EACH BIT FROM THE
14423  FC3B              ; WRITE BYTE IS INVERTED DURING THE SECOND BIT CY
CLE PHASE. AS THE BIT IS INVERTED IT
14424  FC3B              ; IS ALSO ADDED TO THE, ONE BIT, PARITY COUNT FOR
 THIS BYTE
14425  FC3B              
14426  FC3B  A5 BD              LDA     XXBD          ; GET TAPE WRITE BYT
E
14427  FC3D  49 01              EOR     #$01               ; INVERT BIT BE
ING SENT
14428  FC3F  85 BD              STA     XXBD          ; SAVE TAPE WRITE BY
TE
14429  FC41  29 01              AND     #$01               ; MASK B0
14430  FC43  45 9B              EOR     XX9B          ; EOR WITH TAPE WRIT
E BYTE PARITY BIT
14431  FC45  85 9B              STA     XX9B          ; SAVE TAPE WRITE BY
TE PARITY BIT
14432  FC47              XXFC47 = *
14433  FC47  4C 56 FF           JMP     XXFF56          ; RESTORE REGISTER
S AND EXIT INTERRUPT
14434  FC4A                     
14435  FC4A              ; THE BIT CYCLE PHASE IS COMPLETE SO SHIFT OUT TH
E JUST WRITTEN BIT AND TEST FOR BYTE
14436  FC4A              ; END
14437  FC4A              
14438  FC4A              XXFC4A = *
14439  FC4A  46 BD              LSR     XXBD          ; SHIFT BIT OUT OF T
APE WRITE BYTE
14440  FC4C  C6 A3              DEC     XXA3          ; DECREMENT TAPE WRI
TE BIT COUNT
14441  FC4E  A5 A3              LDA     XXA3          ; GET TAPE WRITE BIT
 COUNT
14442  FC50  F0 3A              BEQ     XXFC8C          ; IF ALL THE DATA 
BITS HAVE BEEN WRITTEN GO SETUP FOR
14443  FC52                                     ; SENDING THE PARITY BIT N
EXT AND EXIT THE INTERRUPT
14444  FC52                     
14445  FC52  10 F3              BPL     XXFC47          ; IF ALL THE DATA 
BITS ARE NOT YET SENT JUST RESTORE THE
14446  FC54                                     ; REGISTERS AND EXIT THE I
NTERRUPT
14447  FC54                     
14448  FC54              ; DO NEXT TAPE BYTE
14449  FC54              
14450  FC54              ; THE BYTE IS COMPLETE. THE START BIT, DATA BITS 
AND PARITY BIT HAVE BEEN WRITTEN TO
14451  FC54              ; THE TAPE SO SETUP FOR THE NEXT BYTE






N TOEE......PAGE 0279

LINE# LOC   CODE        LINE


14452  FC54              
14453  FC54              XXFC54 = *
14454  FC54  20 DB FB           JSR     XXFBDB          ; NEW TAPE BYTE SE
TUP
14455  FC57  58                 CLI                    ; ENABLE INTERRUPTS

14456  FC58  A5 A5              LDA     XXA5          ; GET CASSETTE SYNCH
RONIZATION CHARACTER COUNT
14457  FC5A  F0 12              BEQ     XXFC6E          ; IF SYNCHRONISATI
ON CHARACTERS DONE GO DO BLOCK DATA
14458  FC5C                     
14459  FC5C              ; AT THE START OF EACH BLOCK SENT TO TAPE THERE A
RE A NUMBER OF SYNCHRONISATION BYTES
14460  FC5C              ; THAT COUNT DOWN TO THE ACTUAL DATA. THE COMMODO
RE TAPE SYSTEM SAVES TWO COPIES OF ALL
14461  FC5C              ; THE TAPE DATA, THE FIRST IS LOADED AND IS INDIC
ATED BY THE SYNCHRONISATION BYTES
14462  FC5C              ; HAVING B7 SET, AND THE SECOND COPY IS INDICATED
 BY THE SYNCHRONISATION BYTES HAVING B7
14463  FC5C              ; CLEAR. THE SEQUENCE GOES $09, $08, ..... $02, $
01, DATA BYTES
14464  FC5C              
14465  FC5C  A2 00              LDX     #$00               ; CLEAR X
14466  FC5E  86 D7              STX     XXD7          ; CLEAR CHECKSUM BYT
E
14467  FC60  C6 A5              DEC     XXA5          ; DECREMENT CASSETTE
 SYNCHRONIZATION BYTE COUNT
14468  FC62  A6 BE              LDX     XXBE          ; GET CASSETTE COPIE
S COUNT
14469  FC64  E0 02              CPX     #$02               ; COMPARE WITH 
LOAD BLOCK INDICATOR
14470  FC66  D0 02              BNE     XXFC6A          ; BRANCH IF NOT TH
E LOAD BLOCK
14471  FC68                     
14472  FC68  09 80              ORA     #$80               ; THIS IS THE L
OAD BLOCK SO MAKE THE SYNCHRONISATION COUNT
14473  FC6A                                     ; GO $89, $88, ..... $82, 
$81
14474  FC6A              XXFC6A = *
14475  FC6A  85 BD              STA     XXBD          ; SAVE THE SYNCHRONI
SATION BYTE AS THE TAPE WRITE BYTE
14476  FC6C  D0 D9              BNE     XXFC47          ; RESTORE REGISTER
S AND EXIT INTERRUPT, BRANCH ALWAYS
14477  FC6E                     
14478  FC6E              ; THE SYNCHRONIZATION BYTES HAVE BEEN DONE SO NOW
 CHECK AND DO THE ACTUAL BLOCK DATA
14479  FC6E              
14480  FC6E              XXFC6E = *
14481  FC6E  20 11 FD           JSR     XXFD11          ; CHECK READ/WRITE
 POINTER, RETURN CB = 1 IF POINTER >= END
14482  FC71  90 0A              BCC     XXFC7D          ; IF NOT ALL DONE 
YET GO GET THE BYTE TO SEND
14483  FC73                     
14484  FC73  D0 91              BNE     XXFC06          ; IF POINTER > END
 GO FLAG BLOCK DONE AND EXIT INTERRUPT
14485  FC75                     
14486  FC75                                     ; ELSE THE BLOCK IS COMPLE
TE, IT ONLY REMAINS TO WRITE THE
14487  FC75                                     ; CHECKSUM BYTE TO THE TAP
E SO SETUP FOR THAT
14488  FC75  E6 AD              INC     XXAD          ; INCREMENT BUFFER P
OINTER HIGH BYTE, THIS MEANS THE BLOCK
14489  FC77                                     ; DONE BRANCH WILL ALWAYS 
BE TAKEN NEXT TIME WITHOUT HAVING
14490  FC77                                     ; TO WORRY ABOUT THE LOW B
YTE WRAPPING TO ZERO
14491  FC77  A5 D7              LDA     XXD7          ; GET CHECKSUM BYTE
14492  FC79  85 BD              STA     XXBD          ; SAVE CHECKSUM AS T
APE WRITE BYTE
14493  FC7B  B0 CA              BCS     XXFC47          ; RESTORE REGISTER
S AND EXIT INTERRUPT, BRANCH ALWAYS
14494  FC7D                     
14495  FC7D              ; THE BLOCK ISN'T FINISHED SO GET THE NEXT BYTE T
O WRITE TO TAPE
14496  FC7D              
14497  FC7D              XXFC7D = *
14498  FC7D  A0 00              LDY     #$00               ; CLEAR INDEX
14499  FC7F  B1 AC              LDA     (XXAC),Y          ; GET BYTE FROM 
BUFFER
14500  FC81  85 BD              STA     XXBD          ; SAVE AS TAPE WRITE
 BYTE
14501  FC83  45 D7              EOR     XXD7          ; XOR WITH CHECKSUM 
BYTE
14502  FC85  85 D7              STA     XXD7          ; SAVE NEW CHECKSUM 
BYTE
14503  FC87  20 1B FD           JSR     XXFD1B          ; INCREMENT READ/W
RITE POINTER
14504  FC8A  D0 BB              BNE     XXFC47          ; RESTORE REGISTER
S AND EXIT INTERRUPT, BRANCH ALWAYS
14505  FC8C                     
14506  FC8C              ; SET PARITY AS NEXT BIT AND EXIT INTERRUPT






YSNGKE......PAGE 0280

LINE# LOC   CODE        LINE


14507  FC8C              
14508  FC8C              XXFC8C = *
14509  FC8C  A5 9B              LDA     XX9B          ; GET PARITY BIT
14510  FC8E  49 01              EOR     #$01               ; TOGGLE IT
14511  FC90  85 BD              STA     XXBD          ; SAVE AS TAPE WRITE
 BYTE
14512  FC92              XXFC92 = *
14513  FC92  4C 56 FF           JMP     XXFF56          ; RESTORE REGISTER
S AND EXIT INTERRUPT
14514  FC95                     
14515  FC95              ; TAPE ROUTINE, BLOCK COMPLETE EXIT
14516  FC95              
14517  FC95              XXFC95 = *
14518  FC95  C6 BE              DEC     XXBE          ; DECREMENT COPIES R
EMAINING TO READ/WRITE
14519  FC97  D0 03              BNE     XXFC9C          ; BRANCH IF MORE T
O DO
14520  FC99                     
14521  FC99  20 08 FD           JSR     XXFD08          ; ELSE STOP CASSET
TE MOTOR
14522  FC9C              XXFC9C = *
14523  FC9C  A9 50              LDA     #$50               ; SET TAPE WRIT
E LEADER COUNT
14524  FC9E  85 A7              STA     XXA7          ; SAVE TAPE WRITE LE
ADER COUNT
14525  FCA0  A2 08              LDX     #$08               ; SET INDEX FOR
 WRITE TAPE LEADER VECTOR
14526  FCA2  78                 SEI                    ; DISABLE INTERRUPT
S
14527  FCA3  20 FB FC           JSR     XXFCFB          ; SET TAPE VECTOR
14528  FCA6  D0 EA              BNE     XXFC92          ; RESTORE REGISTER
S AND EXIT INTERRUPT, BRANCH ALWAYS
14529  FCA8                     
14530  FCA8                     
14531  FCA8              ;************************************************
***********************************;
14532  FCA8              ;
14533  FCA8              ; WRITE TAPE LEADER IRQ ROUTINE
14534  FCA8              
14535  FCA8              XXFCA8 = *
14536  FCA8  A9 78              LDA     #$78               ; SET TIME CONS
TANT LOW BYTE FOR BIT = LEADER
14537  FCAA  20 F3 FB           JSR     XXFBF3          ; WRITE TIME CONST
ANT AND TOGGLE TAPE
14538  FCAD  D0 E3              BNE     XXFC92          ; IF TAPE BIT HIGH
 RESTORE REGISTERS AND EXIT INTERRUPT
14539  FCAF                     
14540  FCAF  C6 A7              DEC     XXA7          ; DECREMENT CYCLE CO
UNT
14541  FCB1  D0 DF              BNE     XXFC92          ; IF NOT ALL DONE 
RESTORE REGISTERS AND EXIT INTERRUPT
14542  FCB3                     
14543  FCB3  20 DB FB           JSR     XXFBDB          ; NEW TAPE BYTE SE
TUP
14544  FCB6  C6 AB              DEC     XXAB          ; DECREMENT CASSETTE
 LEADER COUNT
14545  FCB8  10 D8              BPL     XXFC92          ; IF NOT ALL DONE 
RESTORE REGISTERS AND EXIT INTERRUPT
14546  FCBA                     
14547  FCBA  A2 0A              LDX     #$0A               ; SET INDEX FOR
 TAPE WRITE VECTOR
14548  FCBC  20 FB FC           JSR     XXFCFB          ; SET TAPE VECTOR
14549  FCBF  58                 CLI                    ; ENABLE INTERRUPTS

14550  FCC0  E6 AB              INC     XXAB          ; CLEAR CASSETTE LEA
DER COUNTER, WAS $FF
14551  FCC2  A5 BE              LDA     XXBE          ; GET CASSETTE BLOCK
 COUNT
14552  FCC4  F0 30              BEQ     XXFCF6          ; IF ALL DONE REST
ORE EVERYTHING FOR STOP AND EXIT INTERRUPT
14553  FCC6                     
14554  FCC6  20 D2 FB           JSR     XXFBD2          ; COPY I/O START A
DDRESS TO BUFFER ADDRESS
14555  FCC9  A2 09              LDX     #$09               ; SET NINE SYNC
HRONISATION BYTES
14556  FCCB  86 A5              STX     XXA5          ; SAVE CASSETTE SYNC
HRONIZATION BYTE COUNT
14557  FCCD  D0 85              BNE     XXFC54          ; GO DO NEXT TAPE 
BYTE, BRANCH ALWAYS
14558  FCCF                     
14559  FCCF                     
14560  FCCF              ;************************************************
***********************************;
14561  FCCF              ;






****;R......PAGE 0281

LINE# LOC   CODE        LINE


14562  FCCF              ; RESTORE EVERYTHING FOR STOP
14563  FCCF              
14564  FCCF              XXFCCF = *
14565  FCCF  08                 PHP                    ; SAVE STATUS
14566  FCD0  78                 SEI                    ; DISABLE INTERRUPT
S
14567  FCD1  20 08 FD           JSR     XXFD08          ; STOP CASSETTE MO
TOR
14568  FCD4  A9 7F              LDA     #$7F               ; DISABLE ALL I
NTERRUPTS
14569  FCD6  8D 2E 91           STA     XX912E          ; SET VIA 2 IER
14570  FCD9  A9 F7              LDA     #$F7               ; SET KEYBOARD 
COLUMN 3 ACTIVE
14571  FCDB  8D 20 91           STA     XX9120          ; SET VIA 2 DRB, K
EYBOARD COLUMN
14572  FCDE  A9 40              LDA     #$40               ; SET T1 FREE R
UN, T2 CLOCK .2,
14573  FCE0                                     ; SR DISABLED, LATCHES DIS
ABLED
14574  FCE0  8D 2B 91           STA     XX912B          ; SET VIA 2 ACR
14575  FCE3  20 39 FE           JSR     XXFE39          ; SET 60HZ AND ENA
BLE TIMER
14576  FCE6  AD A0 02           LDA     XX02A0          ; GET SAVED IRQ VE
CTOR HIGH BYTE
14577  FCE9  F0 09              BEQ     XXFCF4          ; BRANCH IF NULL
14578  FCEB                     
14579  FCEB  8D 15 03           STA     XX0315          ; RESTORE IRQ VECT
OR HIGH BYTE
14580  FCEE  AD 9F 02           LDA     XX029F          ; GET SAVED IRQ VE
CTOR LOW BYTE
14581  FCF1  8D 14 03           STA     XX0314          ; RESTORE IRQ VECT
OR LOW BYTE
14582  FCF4              XXFCF4 = *
14583  FCF4  28                 PLP                    ; RESTORE STATUS
14584  FCF5  60                 RTS
14585  FCF6                     
14586  FCF6                     
14587  FCF6              ;************************************************
***********************************;
14588  FCF6              ;
14589  FCF6              ; RESET VECTOR
14590  FCF6              
14591  FCF6              XXFCF6 = *
14592  FCF6  20 CF FC           JSR     XXFCCF          ; RESTORE EVERYTHI
NG FOR STOP
14593  FCF9  F0 97              BEQ     XXFC92          ; RESTORE REGISTER
S AND EXIT INTERRUPT, BRANCH ALWAYS
14594  FCFB                     
14595  FCFB                     
14596  FCFB              ;************************************************
***********************************;
14597  FCFB              ;
14598  FCFB              ; SET TAPE VECTOR
14599  FCFB              
14600  FCFB              XXFCFB = *
14601  FCFB  BD E9 FD           LDA     XXFDF1-8,X     ; GET TAPE IRQ VECT
OR LOW BYTE
14602  FCFE  8D 14 03           STA     XX0314          ; SET IRQ VECTOR L
OW BYTE
14603  FD01  BD EA FD           LDA     XXFDF1-7,X     ; GET TAPE IRQ VECT
OR HIGH BYTE
14604  FD04  8D 15 03           STA     XX0315          ; SET IRQ VECTOR H
IGH BYTE
14605  FD07  60                 RTS
14606  FD08                     
14607  FD08                     
14608  FD08              ;************************************************
***********************************;
14609  FD08              ;
14610  FD08              ; STOP CASSETTE MOTOR
14611  FD08              
14612  FD08              XXFD08 = *
14613  FD08  AD 1C 91           LDA     XX911C          ; GET VIA 1 PCR
14614  FD0B  09 0E              ORA     #$0E               ; SET CA2 HIGH,
 CASSETTE MOTOR OFF
14615  FD0D  8D 1C 91           STA     XX911C          ; SET VIA 1 PCR
14616  FD10  60                 RTS






****;R......PAGE 0282

LINE# LOC   CODE        LINE


14617  FD11                     
14618  FD11                     
14619  FD11              ;************************************************
***********************************;
14620  FD11              ;
14621  FD11              ; CHECK READ/WRITE POINTER
14622  FD11              ; RETURN CB = 1 IF POINTER >= END
14623  FD11              
14624  FD11              XXFD11 = *
14625  FD11  38                 SEC                    ; SET CARRY FOR SUB
TRACT
14626  FD12  A5 AC              LDA     XXAC          ; GET BUFFER ADDRESS
 LOW BYTE
14627  FD14  E5 AE              SBC     XXAE          ; SUBTRACT BUFFER EN
D LOW BYTE
14628  FD16  A5 AD              LDA     XXAD          ; GET BUFFER ADDRESS
 HIGH BYTE
14629  FD18  E5 AF              SBC     XXAF          ; SUBTRACT BUFFER EN
D HIGH BYTE
14630  FD1A  60                 RTS
14631  FD1B                     
14632  FD1B                     
14633  FD1B              ;************************************************
***********************************;
14634  FD1B              ;
14635  FD1B              ; INCREMENT READ/WRITE POINTER
14636  FD1B              
14637  FD1B              XXFD1B = *
14638  FD1B  E6 AC              INC     XXAC          ; INCREMENT BUFFER A
DDRESS LOW BYTE
14639  FD1D  D0 02              BNE     XXFD21          ; IF NO OVERFLOW S
KIP THE HIGH BYTE INCREMENT
14640  FD1F                     
14641  FD1F  E6 AD              INC     XXAD          ; INCREMENT BUFFER A
DDRESS HIGH BYTE
14642  FD21              XXFD21 = *
14643  FD21  60                 RTS
14644  FD22                     
14645  FD22                     
14646  FD22              ;************************************************
***********************************;
14647  FD22              ;
14648  FD22              ; RESET, HARDWARE RESET STARTS HERE
14649  FD22              
14650  FD22              XXFD22 = *
14651  FD22  A2 FF              LDX     #$FF               ; SET X FOR STA
CK
14652  FD24  78                 SEI                    ; DISABLE INTERRUPT
S
14653  FD25  9A                 TXS                    ; CLEAR STACK
14654  FD26  D8                 CLD                    ; CLEAR DECIMAL MOD
E
14655  FD27  20 3F FD           JSR     XXFD3F          ; SCAN FOR AUTOSTA
RT ROM AT $A000
14656  FD2A  D0 03              BNE     XXFD2F          ; IF NOT THERE CON
TINUE VIC STARTUP
14657  FD2C                     
14658  FD2C  6C 00 A0           JMP     (XXA000)          ; CALL ROM START
 CODE
14659  FD2F                     
14660  FD2F              XXFD2F = *
14661  FD2F  20 8D FD           JSR     XXFD8D          ; INITIALISE AND T
EST RAM
14662  FD32  20 52 FD           JSR     XXFD52          ; RESTORE DEFAULT 
I/O VECTORS
14663  FD35  20 F9 FD           JSR     XXFDF9          ; INITIALIZE I/O R
EGISTERS
14664  FD38  20 18 E5           JSR     XXE518          ; INITIALISE HARDW
ARE
14665  FD3B  58                 CLI                    ; ENABLE INTERRUPTS

14666  FD3C  6C 00 C0           JMP     (XXC000)          ; EXECUTE BASIC
14667  FD3F                     
14668  FD3F                     
14669  FD3F              ;************************************************
***********************************;
14670  FD3F              ;
14671  FD3F              ; SCAN FOR AUTOSTART ROM AT $A000, RETURNS ZB=1 I
F ROM FOUND






****;R......PAGE 0283

LINE# LOC   CODE        LINE


14672  FD3F              
14673  FD3F              XXFD3F = *
14674  FD3F  A2 05              LDX     #$05               ; FIVE CHARACTE
RS TO TEST
14675  FD41              XXFD41 = *
14676  FD41  BD 4C FD           LDA     XXFD4D-1,X     ; GET TEST CHARACTE
R
14677  FD44  DD 03 A0           CMP     XXA004-1,X     ; COMPARE WIITH BYT
E IN ROM SPACE
14678  FD47  D0 03              BNE     XXFD4C          ; EXIT IF NO MATCH

14679  FD49                     
14680  FD49  CA                 DEX                    ; DECREMENT INDEX
14681  FD4A  D0 F5              BNE     XXFD41          ; LOOP IF NOT ALL 
DONE
14682  FD4C                     
14683  FD4C              XXFD4C = *
14684  FD4C  60                 RTS
14685  FD4D                     
14686  FD4D                     
14687  FD4D              ;************************************************
***********************************;
14688  FD4D              ;
14689  FD4D              ; AUTOSTART ROM SIGNATURE
14690  FD4D              
14691  FD4D              XXFD4D = *
14692  FD4D  41 30              .BYTE     'A0',$C3,$C2,$CD     ; A0CBM
14692  FD4F  C3 
14692  FD50  C2 
14692  FD51  CD 
14693  FD52                     
14694  FD52                     
14695  FD52              ;************************************************
***********************************;
14696  FD52              ;
14697  FD52              ; RESTORE DEFAULT I/O VECTORS
14698  FD52              
14699  FD52              ; THIS ROUTINE RESTORES THE DEFAULT VALUES OF ALL
 SYSTEM VECTORS USED IN KERNAL AND
14700  FD52              ; BASIC ROUTINES AND INTERRUPTS. THE KERNAL VECTO
R ROUTINE IS USED TO READ AND ALTER
14701  FD52              ; INDIVIDUAL SYSTEM VECTORS.
14702  FD52              
14703  FD52              XXFD52 = *
14704  FD52  A2 6D              LDX     #<XXFD6D          ; POINTER TO VEC
TOR TABLE LOW BYTE
14705  FD54  A0 FD              LDY     #>XXFD6D          ; POINTER TO VEC
TOR TABLE HIGH BYTE
14706  FD56  18                 CLC                    ; FLAG SET VECTORS
14707  FD57                     
14708  FD57                     
14709  FD57              ;************************************************
***********************************;
14710  FD57              ;
14711  FD57              ; SET/READ VECTORED I/O FROM (XY), CB = 1 TO READ
, CB = 0 TO SET
14712  FD57              
14713  FD57              ; THIS ROUTINE MANAGES ALL SYSTEM VECTOR JUMP ADD
RESSES STORED IN RAM. CALLING THIS
14714  FD57              ; ROUTINE WITH THE ACCUMULATOR CARRY BIT SET WILL
 STORE THE CURRENT CONTENTS OF THE
14715  FD57              ; RAM VECTORS IN A LIST POINTED TO BY THE X AND Y
 REGISTERS.
14716  FD57              
14717  FD57              ; WHEN THIS ROUTINE IS CALLED WITH THE CARRY BIT 
CLEAR, THE USER LIST POINTED TO BY
14718  FD57              ; THE X AND Y REGISTERS IS TRANSFERRED TO THE SYS
TEM RAM VECTORS.
14719  FD57              
14720  FD57              ; NOTE: THIS ROUTINE REQUIRES CAUTION IN ITS USE.
 THE BEST WAY TO USE IT IS TO FIRST
14721  FD57              ; READ THE ENTIRE VECTOR CONTENTS INTO THE USER A
REA, ALTER THE DESIRED VECTORS, AND
14722  FD57              ; THEN COPY THE CONTENTS BACK TO THE SYSTEM VECTO
RS.
14723  FD57              






 AND;R......PAGE 0284

LINE# LOC   CODE        LINE


14724  FD57              XXFD57 = *
14725  FD57  86 C3              STX     XXC3          ; SAVE POINTER LOW B
YTE
14726  FD59  84 C4              STY     XXC4          ; SAVE POINTER HIGH 
BYTE
14727  FD5B  A0 1F              LDY     #$1F               ; SET BYTE COUN
T
14728  FD5D              XXFD5D = *
14729  FD5D  B9 14 03           LDA     XX0314,Y          ; READ VECTOR BY
TE FROM VECTORS
14730  FD60  B0 02              BCS     XXFD64          ; IF READ VECTORS 
SKIP THE READ FROM XY
14731  FD62                     
14732  FD62  B1 C3              LDA     (XXC3),Y          ; READ VECTOR BY
TE FROM (XY)
14733  FD64              XXFD64 = *
14734  FD64  91 C3              STA     (XXC3),Y          ; SAVE BYTE TO (
XY)
14735  FD66  99 14 03           STA     XX0314,Y          ; SAVE BYTE TO V
ECTOR
14736  FD69  88                 DEY                    ; DECREMENT INDEX
14737  FD6A  10 F1              BPL     XXFD5D          ; LOOP IF MORE TO 
DO
14738  FD6C                     
14739  FD6C  60                 RTS
14740  FD6D                     
14741  FD6D              ;; THE ABOVE CODE WORKS BUT IT TRIES TO WRITE TO 
THE ROM. WHILE THIS IS USUALLY HARMLESS
14742  FD6D              ;; SYSTEMS THAT USE FLASH ROM MAY SUFFER. HERE IS
 A VERSION THAT MAKES THE EXTRA WRITE
14743  FD6D              ;; TO RAM INSTEAD BUT IS OTHERWISE IDENTICAL IN F
UNCTION. ##
14744  FD6D              ;
14745  FD6D              ;; SET/READ VECTORED I/O FROM (XY), CB = 1 TO REA
D, CB = 0 TO SET
14746  FD6D              ;
14747  FD6D              ;XXFD57
14748  FD6D              ;     STX     XXC3          ; SAVE POINTER LOW BY
TE
14749  FD6D              ;     STY     XXC4          ; SAVE POINTER HIGH B
YTE
14750  FD6D              ;     LDY     #$1F               ; SET BYTE COUNT

14751  FD6D              ;XXFD5D
14752  FD6D              ;     LDA     (XXC3),Y          ; READ VECTOR BYT
E FROM (XY)
14753  FD6D              ;     BCC     XXFD66          ; IF SET VECTORS SK
IP THE READ FROM XY
14754  FD6D              ;
14755  FD6D              ;     LDA     XX0314,Y          ; ELSE READ VECTO
R BYTE FROM VECTORS
14756  FD6D              ;     STA     (XXC3),Y          ; SAVE BYTE TO (X
Y)
14757  FD6D              ;XXFD66
14758  FD6D              ;     STA     XX0314,Y          ; SAVE BYTE TO VE
CTOR
14759  FD6D              ;     DEY                    ; DECREMENT INDEX
14760  FD6D              ;     BPL     XXFD5D          ; LOOP IF MORE TO D
O
14761  FD6D              ;
14762  FD6D              ;     RTS
14763  FD6D              
14764  FD6D              
14765  FD6D              ;************************************************
***********************************;
14766  FD6D              ;
14767  FD6D              ; KERNAL VECTORS
14768  FD6D              
14769  FD6D              XXFD6D = *
14770  FD6D  BF EA              .WORD     XXEABF          ; XX0314     IRQ
 VECTOR
14771  FD6F  D2 FE              .WORD     XXFED2          ; XX0316     BRK
 VECTOR
14772  FD71  AD FE              .WORD     XXFEAD          ; XX0318     NMI
 VECTOR
14773  FD73  0A F4              .WORD     XXF40A          ; XX031A     OPE
N A LOGICAL FILE
14774  FD75  4A F3              .WORD     XXF34A          ; XX031C     CLO
SE A SPECIFIED LOGICAL FILE
14775  FD77  C7 F2              .WORD     XXF2C7          ; XX031E     OPE
N CHANNEL FOR INPUT
14776  FD79  09 F3              .WORD     XXF309          ; XX0320     OPE
N CHANNEL FOR OUTPUT
14777  FD7B  F3 F3              .WORD     XXF3F3          ; XX0322     CLO
SE INPUT AND OUTPUT CHANNELS
14778  FD7D  0E F2              .WORD     XXF20E          ; XX0324     INP
UT CHARACTER FROM CHANNEL






****;E......PAGE 0285

LINE# LOC   CODE        LINE


14779  FD7F  7A F2              .WORD     XXF27A          ; XX0326     OUT
PUT CHARACTER TO CHANNEL
14780  FD81  70 F7              .WORD     XXF770          ; XX0328     SCA
N STOP KEY
14781  FD83  F5 F1              .WORD     XXF1F5          ; XX032A     GET
 CHARACTER FROM KEYBOARD QUEUE
14782  FD85  EF F3              .WORD     XXF3EF          ; XX032C     CLO
SE ALL CHANNELS AND FILES
14783  FD87  D2 FE              .WORD     XXFED2          ; XX032E     USE
R FUNCTION
14784  FD89                     
14785  FD89              ; VECTOR TO USER DEFINED COMMAND, CURRENTLY POINT
S TO BRK.
14786  FD89              
14787  FD89              ; THIS APPEARS TO BE A HOLDOVER FROM PET DAYS, WH
EN THE BUILT-IN MACHINE LANGUAGE MONITOR
14788  FD89              ; WOULD JUMP THROUGH THE XX032E VECTOR WHEN IT EN
COUNTERED A COMMAND THAT IT DID NOT
14789  FD89              ; UNDERSTAND, ALLOWING THE USER TO ADD NEW COMMAN
DS TO THE MONITOR.
14790  FD89              
14791  FD89              ; ALTHOUGH THIS VECTOR IS INITIALIZED TO POINT TO
 THE ROUTINE CALLED BY STOP/RESTORE AND
14792  FD89              ; THE BRK INTERRUPT, AND IS UPDATED BY THE KERNAL
 VECTOR ROUTINE AT $FD57, IT NO LONGER
14793  FD89              ; HAS ANY FUNCTION.
14794  FD89              
14795  FD89  49 F5              .WORD     XXF549          ; XX0330     LOA
D
14796  FD8B  85 F6              .WORD     XXF685          ; XX0332     SAV
E
14797  FD8D                     
14798  FD8D                     
14799  FD8D              ;************************************************
***********************************;
14800  FD8D              ;
14801  FD8D              ; INITIALISE AND TEST RAM, THE RAM FROM $000 TO $
03FF IS NEVER TESTED AND IS JUST ASSUMED
14802  FD8D              ; TO WORK. FIRST A SEARCH IS DONE FROM $0401 FOR 
THE START OF MEMORY AND THIS IS SAVED, IF
14803  FD8D              ; THIS START IS AT OR BEYOND $1100 THEN THE ROUTI
NE DEAD ENDS. ONCE THE START OF MEMORY IS
14804  FD8D              ; FOUND THE ROUTINE LOOKS FOR THE END OF MEMORY, 
IF THIS END IS BEFORE $2000 THE ROUTINE
14805  FD8D              ; AGAIN DEAD ENDS. LASTLY, IF THE END OF MEMORY I
S AT $2000 THEN THE SCREEN IS SET TO
14806  FD8D              ; $1E00, BUT IF THE MEMORY EXTENDS TO OR BEYOND $
2100 THEN THE SCREEN IS MOVED TO $1000
14807  FD8D              
14808  FD8D              XXFD8D = *
14809  FD8D  A9 00              LDA     #$00               ; CLEAR A
14810  FD8F  AA                 TAX                    ; CLEAR INDEX
14811  FD90              XXFD90 = *
14812  FD90  95 00              STA     XX00,X          ; CLEAR PAGE 0
14813  FD92  9D 00 02           STA     XX0200,X          ; CLEAR PAGE 2
14814  FD95  9D 00 03           STA     XX0300,X          ; CLEAR PAGE 3
14815  FD98  E8                 INX                    ; INCREMENT INDEX
14816  FD99  D0 F5              BNE     XXFD90          ; LOOP IF MORE TO 
DO
14817  FD9B                     
14818  FD9B  A2 3C              LDX     #<XX033C          ; SET CASSETTE B
UFFER POINTER LOW BYTE
14819  FD9D  A0 03              LDY     #>XX033C          ; SET CASSETTE B
UFFER POINTER HIGH BYTE
14820  FD9F  86 B2              STX     XXB2          ; SAVE TAPE BUFFER S
TART POINTER LOW BYTE
14821  FDA1  84 B3              STY     XXB3          ; SAVE TAPE BUFFER S
TART POINTER HIGH BYTE
14822  FDA3                     
14823  FDA3  85 C1              STA     XXC1          ; CLEAR RAM TEST POI
NTER LOW BYTE
14824  FDA5  85 97              STA     XX97          ; CLEAR LOOKING FOR 
END FLAG
14825  FDA7  8D 81 02           STA     XX0281          ; CLEAR OS START O
F MEMORY LOW BYTE
14826  FDAA                     
14827  FDAA  A8                 TAY                    ; CLEAR Y
14828  FDAB  A9 04              LDA     #$04               ; SET RAM TEST 
POINTER HIGH BYTE
14829  FDAD  85 C2              STA     XXC2          ; SAVE RAM TEST POIN
TER HIGH BYTE
14830  FDAF              XXFDAF = *
14831  FDAF  E6 C1              INC     XXC1          ; INCREMENT RAM TEST
 POINTER LOW BYTE
14832  FDB1  D0 02              BNE     XXFDB5          ; IF NO ROLLOVER S
KIP THE HIGH BYTE INCREMENT
14833  FDB3                     






O $100......PAGE 0286

LINE# LOC   CODE        LINE


14834  FDB3  E6 C2              INC     XXC2          ; INCREMENT RAM TEST
 POINTER HIGH BYTE
14835  FDB5              XXFDB5 = *
14836  FDB5  20 91 FE           JSR     XXFE91          ; TEST RAM BYTE, R
ETURN CB=0 IF FAILED
14837  FDB8  A5 97              LDA     XX97          ; TEST LOOKING FOR E
ND FLAG
14838  FDBA  F0 22              BEQ     XXFDDE          ; BRANCH IF NOT LO
OKING FOR END
14839  FDBC                     
14840  FDBC                                     ; ELSE NOW LOOKING FOR THE
 END OF MEMORY
14841  FDBC  B0 F1              BCS     XXFDAF          ; LOOP IF BYTE TES
T PASSED
14842  FDBE                     
14843  FDBE  A4 C2              LDY     XXC2          ; GET TEST ADDRESS H
IGH BYTE
14844  FDC0  A6 C1              LDX     XXC1          ; GET TEST ADDRESS L
OW BYTE
14845  FDC2  C0 20              CPY     #$20               ; COMPARE WITH 
$2000, RAM SHOULD ALWAYS END AT OR AFTER
14846  FDC4                                     ; $2000 EVEN WITH NO EXPAN
SION MEMORY AS THE BUILT IN RAM
14847  FDC4                                     ; ENDS AT $1FFF. THEREFORE
 THE FOLLOWING TEST SHOULD
14848  FDC4                                     ; NEVER BRANCH
14849  FDC4  90 25              BCC     XXFDEB          ; IF END ADDRESS <
 $2000 GO DO DEAD END LOOP
14850  FDC6                     
14851  FDC6  C0 21              CPY     #$21               ; COMPARE WITH 
$2100
14852  FDC8  B0 08              BCS     XXFDD2          ; BRANCH IF >= $21
00
14853  FDCA                     
14854  FDCA                                     ; ELSE MEMORY ENDED BEFORE
 $2100
14855  FDCA  A0 1E              LDY     #$1E               ; SET SCREEN ME
MORY PAGE TO $1E00
14856  FDCC  8C 88 02           STY     XX0288          ; SAVE SCREEN MEMO
RY PAGE
14857  FDCF              XXFDCF = *
14858  FDCF  4C 7B FE           JMP     XXFE7B          ; SET THE TOP OF M
EMORY AND RETURN
14859  FDD2                     
14860  FDD2                                     ; MEMORY ENDS BEYOND $2100

14861  FDD2              XXFDD2 = *
14862  FDD2  A9 12              LDA     #$12               ; SET OS START 
OF MEMORY HIGH BYTE
14863  FDD4  8D 82 02           STA     XX0282          ; SAVE OS START OF
 MEMORY HIGH BYTE
14864  FDD7  A9 10              LDA     #$10               ; SET SCREEN ME
MORY PAGE TO $1000
14865  FDD9  8D 88 02           STA     XX0288          ; SAVE SCREEN MEMO
RY PAGE
14866  FDDC  D0 F1              BNE     XXFDCF          ; SET THE TOP OF M
EMORY AND RETURN, BRANCH ALWAYS
14867  FDDE                     
14868  FDDE              XXFDDE = *
14869  FDDE  90 CF              BCC     XXFDAF          ; LOOP IF BYTE TES
T FAILED, NOT FOUND START YET
14870  FDE0                     
14871  FDE0                                     ; ELSE FOUND START OF RAM
14872  FDE0  A5 C2              LDA     XXC2          ; GET TEST ADDRESS H
IGH BYTE
14873  FDE2  8D 82 02           STA     XX0282          ; SAVE OS START OF
 MEMORY HIGH BYTE
14874  FDE5  85 97              STA     XX97          ; SET LOOKING FOR EN
D FLAG
14875  FDE7  C9 11              CMP     #$11               ; COMPARE START
 WITH $1100, RAM SHOULD ALWAYS START BEFORE
14876  FDE9                                     ; $1100 EVEN WITH NO EXPAN
SION MEMORY AS THE BUILT IN RAM
14877  FDE9                                     ; STARTS AT $1000. THEREFO
RE THE FOLLOWING TEST SHOULD
14878  FDE9                                     ; ALWAYS BRANCH
14879  FDE9  90 C4              BCC     XXFDAF          ; GO FIND END OF R
AM, BRANCH ALWAYS
14880  FDEB                     
14881  FDEB                                     ; IF THE CODE DROPS THROUG
H HERE THEN THE RAM HAS FAILED
14882  FDEB                                     ; AND THERE IS NOT MUCH EL
SE TO BE DONE
14883  FDEB              XXFDEB = *
14884  FDEB  20 C3 E5           JSR     XXE5C3          ; INITIALISE VIC C
HIP
14885  FDEE  4C EB FD           JMP     XXFDEB          ; LOOP FOREVER
14886  FDF1                     
14887  FDF1                     
14888  FDF1              ;************************************************
***********************************;






****;E......PAGE 0287

LINE# LOC   CODE        LINE


14889  FDF1              ;
14890  FDF1              ; TAPE IRQ VECTORS
14891  FDF1              
14892  FDF1              XXFDF1 = *
14893  FDF1  A8 FC              .WORD     XXFCA8          ; $08     WRITE 
TAPE LEADER IRQ ROUTINE
14894  FDF3  0B FC              .WORD     XXFC0B          ; $0A     TAPE W
RITE IRQ ROUTINE
14895  FDF5  BF EA              .WORD     XXEABF          ; $0C     NORMAL
 IRQ VECTOR
14896  FDF7  8E F9              .WORD     XXF98E          ; $0E     READ T
APE BITS IRQ ROUTINE
14897  FDF9                     
14898  FDF9                     
14899  FDF9              ;************************************************
***********************************;
14900  FDF9              ;
14901  FDF9              ; INITIALIZE I/O REGISTERS
14902  FDF9              
14903  FDF9              XXFDF9 = *
14904  FDF9  A9 7F              LDA     #$7F               ; DISABLE ALL I
NTERRUPTS
14905  FDFB  8D 1E 91           STA     XX911E          ; ON VIA 1 IER ..
14906  FDFE  8D 2E 91           STA     XX912E          ; .. AND VIA 2 IER

14907  FE01                     
14908  FE01  A9 40              LDA     #$40               ; SET T1 FREE R
UN, T2 CLOCK .2,
14909  FE03                                     ; SR DISABLED, LATCHES DIS
ABLED
14910  FE03  8D 2B 91           STA     XX912B          ; SET VIA 2 ACR
14911  FE06                     
14912  FE06  A9 40              LDA     #$40               ; SET T1 FREE R
UN, T2 CLOCK .2,
14913  FE08                                     ; SR DISABLED, LATCHES DIS
ABLED
14914  FE08  8D 1B 91           STA     XX911B          ; SET VIA 1 ACR
14915  FE0B                     
14916  FE0B  A9 FE              LDA     #$FE               ; CB2 HIGH, RS2
32 TX
14917  FE0D                                     ; CB1 +VE EDGE,
14918  FE0D                                     ; CA2 HIGH, TAPE MOTOR OFF

14919  FE0D                                     ; CA1 -VE EDGE
14920  FE0D  8D 1C 91           STA     XX911C          ; SET VIA 1 PCR
14921  FE10                     
14922  FE10  A9 DE              LDA     #$DE               ; CB2 LOW, SERI
AL DATA OUT HIGH
14923  FE12                                     ; CB1 +VE EDGE,
14924  FE12                                     ; CA2 HIGH, SERIAL CLOCK O
UT LOW
14925  FE12                                     ; CA1 -VE EDGE
14926  FE12  8D 2C 91           STA     XX912C          ; SET VIA 2 PCR
14927  FE15                     
14928  FE15  A2 00              LDX     #$00               ; ALL INPUTS, R
S232 INTERFACE OR PARALLEL USER PORT
14929  FE17  8E 12 91           STX     XX9112          ; SET VIA 1 DDRB
14930  FE1A                     
14931  FE1A  A2 FF              LDX     #$FF               ; ALL OUTPUTS, 
KEYBOARD COLUMN
14932  FE1C  8E 22 91           STX     XX9122          ; SET VIA 2 DDRB
14933  FE1F                     
14934  FE1F  A2 00              LDX     #$00               ; ALL INPUTS, K
EYBOARD ROW
14935  FE21  8E 23 91           STX     XX9123          ; SET VIA 2 DDRA
14936  FE24                     
14937  FE24  A2 80              LDX     #$80               ; OIII IIII, AT
N OUT, LIGHT PEN, JOYSTICK, SERIAL DATA
14938  FE26                                     ; IN, SERIAL CLK IN
14939  FE26  8E 13 91           STX     XX9113          ; SET VIA 1 DDRA
14940  FE29                     
14941  FE29  A2 00              LDX     #$00               ; ATN OUT LOW, 
SET ATN HIGH
14942  FE2B  8E 1F 91           STX     XX911F          ; SET VIA 1 DRA, N
O HANDSHAKE
14943  FE2E                     






L DATA......PAGE 0288

LINE# LOC   CODE        LINE


14944  FE2E  20 84 EF           JSR     XXEF84          ; SET SERIAL CLOCK
 HIGH
14945  FE31  A9 82              LDA     #$82               ; ENABLE CA1 IN
TERRUPT, [RESTORE] KEY
14946  FE33  8D 1E 91           STA     XX911E          ; SET VIA 1 IER
14947  FE36  20 8D EF           JSR     XXEF8D          ; SET SERIAL CLOCK
 LOW
14948  FE39                     
14949  FE39                     
14950  FE39              ;************************************************
***********************************;
14951  FE39              ;
14952  FE39              ; SET 60HZ AND ENABLE TIMER
14953  FE39              
14954  FE39              XXFE39 = *
14955  FE39  A9 C0              LDA     #$C0               ; ENABLE T1 INT
ERRUPT
14956  FE3B  8D 2E 91           STA     XX912E          ; SET VIA 2 IER
14957  FE3E  A9 26              LDA     #$26               ; SET TIMER CON
STANT LOW BYTE [PAL]
14958  FE40              ;     LDA     #$89               ; SET TIMER CONS
TANT LOW BYTE [NTSC]
14959  FE40  8D 24 91           STA     XX9124          ; SET VIA 2 T1C_L
14960  FE43  A9 48              LDA     #$48               ; SET TIMER CON
STANT HIGH BYTE [PAL]
14961  FE45              ;     LDA     #$42               ; SET TIMER CONS
TANT HIGH BYTE [NTSC]
14962  FE45  8D 25 91           STA     XX9125          ; SET VIA 2 T1C_H
14963  FE48  60                 RTS
14964  FE49                     
14965  FE49                     
14966  FE49              ;************************************************
***********************************;
14967  FE49              ;
14968  FE49              ; SET FILENAME
14969  FE49              
14970  FE49              ; THIS ROUTINE IS USED TO SET UP THE FILE NAME FO
R THE OPEN, SAVE, OR LOAD ROUTINES.
14971  FE49              ; THE ACCUMULATOR MUST BE LOADED WITH THE LENGTH 
OF THE FILE AND XY WITH THE POINTER
14972  FE49              ; TO FILE NAME, X BEING THE LOW BYTE. THE ADDRESS
 CAN BE ANY VALID MEMORY ADDRESS IN
14973  FE49              ; THE SYSTEM WHERE A STRING OF CHARACTERS FOR THE
 FILE NAME IS STORED. IF NO FILE
14974  FE49              ; NAME DESIRED THE ACCUMULATOR MUST BE SET TO 0, 
REPRESENTING A ZERO FILE LENGTH,
14975  FE49              ; IN THAT CASE  XY MAY BE SET TO ANY MEMORY ADDRE
SS.
14976  FE49              
14977  FE49              XXFE49 = *
14978  FE49  85 B7              STA     XXB7          ; SET FILE NAME LENG
TH
14979  FE4B  86 BB              STX     XXBB          ; SET FILE NAME POIN
TER LOW BYTE
14980  FE4D  84 BC              STY     XXBC          ; SET FILE NAME POIN
TER HIGH BYTE
14981  FE4F  60                 RTS
14982  FE50                     
14983  FE50                     
14984  FE50              ;************************************************
***********************************;
14985  FE50              ;
14986  FE50              ; SET LOGICAL FILE, FIRST AND SECOND ADDRESSES
14987  FE50              
14988  FE50              ; THIS ROUTINE WILL SET THE LOGICAL FILE NUMBER, 
DEVICE ADDRESS, AND SECONDARY
14989  FE50              ; ADDRESS, COMMAND NUMBER, FOR OTHER KERNAL ROUTI
NES.
14990  FE50              
14991  FE50              ; THE LOGICAL FILE NUMBER IS USED BY THE SYSTEM A
S A KEY TO THE FILE TABLE CREATED
14992  FE50              ; BY THE OPEN FILE ROUTINE. DEVICE ADDRESSES CAN 
RANGE FROM 0 TO 30. THE FOLLOWING
14993  FE50              ; CODES ARE USED BY THE COMPUTER TO STAND FOR THE
 FOLLOWING CBM DEVICES:
14994  FE50              
14995  FE50              ; ADDRESS     DEVICE
14996  FE50              ; =======     ======
14997  FE50              ;  0          KEYBOARD
14998  FE50              ;  1          CASSETTE #1






NG**;A......PAGE 0289

LINE# LOC   CODE        LINE


14999  FE50              ;  2          RS-232C DEVICE
15000  FE50              ;  3          CRT DISPLAY
15001  FE50              ;  4          SERIAL BUS PRINTER
15002  FE50              ;  8          CBM SERIAL BUS DISK DRIVE
15003  FE50              
15004  FE50              ; DEVICE NUMBERS OF FOUR OR GREATER AUTOMATICALLY
 REFER TO DEVICES ON THE SERIAL
15005  FE50              ; BUS.
15006  FE50              
15007  FE50              ; A COMMAND TO THE DEVICE IS SENT AS A SECONDARY 
ADDRESS ON THE SERIAL BUS AFTER
15008  FE50              ; THE DEVICE NUMBER IS SENT DURING THE SERIAL ATT
ENTION HANDSHAKING SEQUENCE. IF
15009  FE50              ; NO SECONDARY ADDRESS IS TO BE SENT Y SHOULD BE 
SET TO $FF.
15010  FE50              
15011  FE50              XXFE50 = *
15012  FE50  85 B8              STA     XXB8          ; SET LOGICAL FILE
15013  FE52  86 BA              STX     XXBA          ; SET DEVICE NUMBER
15014  FE54  84 B9              STY     XXB9          ; SET SECONDARY ADDR
ESS OR COMMAND
15015  FE56  60                 RTS
15016  FE57                     
15017  FE57                     
15018  FE57              ;************************************************
***********************************;
15019  FE57              ;
15020  FE57              ; READ I/O STATUS WORD
15021  FE57              
15022  FE57              ; THIS ROUTINE RETURNS THE CURRENT STATUS OF THE 
I/O DEVICE IN THE ACCUMULATOR. THE
15023  FE57              ; ROUTINE IS USUALLY CALLED AFTER NEW COMMUNICATI
ON TO AN I/O DEVICE. THE ROUTINE
15024  FE57              ; WILL GIVE INFORMATION ABOUT DEVICE STATUS, OR E
RRORS THAT HAVE OCCURRED DURING THE
15025  FE57              ; I/O OPERATION.
15026  FE57              
15027  FE57              XXFE57 = *
15028  FE57  A5 BA              LDA     XXBA          ; GET DEVICE NUMBER
15029  FE59  C9 02              CMP     #$02               ; COMPARE DEVIC
E WITH RS232 DEVICE
15030  FE5B  D0 0B              BNE     XXFE68          ; BRANCH IF NOT RS
232 DEVICE
15031  FE5D                     
15032  FE5D                                     ; GET RS232 DEVICE STATUS
15033  FE5D  AD 97 02           LDA     XX0297          ; READ RS232 STATU
S WORD
15034  FE60                     
15035  FE60  A9 00              LDA     #$00               ; CLEAR A
15036  FE62  8D 97 02           STA     XX0297          ; CLEAR RS232 STAT
US
15037  FE65                     
15038  FE65              ; THE ABOVE CODE IS WRONG. THE RS232 STATUS IS IN
 A BUT A IS CLEARED AND THAT IS USED
15039  FE65              ; TO CLEAR THE RS232 STATUS BYTE. SO WHATEVER THE
 STATUS THE RESULT IS ALWAYS $00 AND
15040  FE65              ; THE STATUS BYTE IS ALWAYS CLEARED. A SOLUTION I
S TO USE X TO CLEAR THE STATUS AFTER
15041  FE65              ; IT IS READ INSTEAD OF THE ABOVE LIKE THIS ..
15042  FE65              ;
15043  FE65              ;     LDX     #$00               ; CLEAR X
15044  FE65              ;     STX     XX0297          ; CLEAR RS232 STATU
S ##
15045  FE65  60                 RTS
15046  FE66                     
15047  FE66                     
15048  FE66              ;************************************************
***********************************;
15049  FE66              ;
15050  FE66              ; CONTROL KERNAL MESSAGES
15051  FE66              
15052  FE66              ; THIS ROUTINE CONTROLS THE PRINTING OF ERROR AND
 CONTROL MESSAGES BY THE KERNAL.
15053  FE66              ; EITHER PRINT ERROR MESSAGES OR PRINT CONTROL ME
SSAGES CAN BE SELECTED BY SETTING






NG**;A......PAGE 0290

LINE# LOC   CODE        LINE


15054  FE66              ; THE ACCUMULATOR WHEN THE ROUTINE IS CALLED.
15055  FE66              
15056  FE66              ; FILE NOT FOUND IS AN EXAMPLE OF AN ERROR MESSAG
E. PRESS PLAY ON CASSETTE IS AN
15057  FE66              ; EXAMPLE OF A CONTROL MESSAGE.
15058  FE66              
15059  FE66              ; BITS 6 AND 7 OF THIS VALUE DETERMINE WHERE THE 
MESSAGE WILL COME FROM. IF BIT 7
15060  FE66              ; IS SET ONE OF THE ERROR MESSAGES FROM THE KERNA
L WILL BE PRINTED. IF BIT 6 IS SET
15061  FE66              ; A CONTROL MESSAGE WILL BE PRINTED.
15062  FE66              
15063  FE66              XXFE66 = *
15064  FE66  85 9D              STA     XX9D          ; SET MESSAGE MODE F
LAG
15065  FE68              XXFE68 = *
15066  FE68  A5 90              LDA     XX90          ; READ SERIAL STATUS
 BYTE
15067  FE6A                     
15068  FE6A              ; OR INTO SERIAL STATUS BYTE
15069  FE6A              
15070  FE6A              XXFE6A = *
15071  FE6A  05 90              ORA     XX90          ; OR WITH SERIAL STA
TUS BYTE
15072  FE6C  85 90              STA     XX90          ; SAVE SERIAL STATUS
 BYTE
15073  FE6E  60                 RTS
15074  FE6F                     
15075  FE6F                     
15076  FE6F              ;************************************************
***********************************;
15077  FE6F              ;
15078  FE6F              ; SET TIMEOUT ON SERIAL BUS
15079  FE6F              
15080  FE6F              ; THIS ROUTINE SETS THE TIMEOUT FLAG FOR THE SERI
AL BUS. WHEN THE TIMEOUT FLAG IS
15081  FE6F              ; SET, THE COMPUTER WILL WAIT FOR A DEVICE ON THE
 SERIAL PORT FOR 64 MILLISECONDS.
15082  FE6F              ; IF THE DEVICE DOES NOT RESPOND TO THE COMPUTER'
S DAV SIGNAL WITHIN THAT TIME THE
15083  FE6F              ; COMPUTER WILL RECOGNIZE AN ERROR CONDITION AND 
LEAVE THE HANDSHAKE SEQUENCE. WHEN
15084  FE6F              ; THIS ROUTINE IS CALLED AND THE ACCUMULATOR CONT
AINS A 0 IN BIT 7, TIMEOUTS ARE
15085  FE6F              ; ENABLED. A 1 IN BIT 7 WILL DISABLE THE TIMEOUTS
.
15086  FE6F              
15087  FE6F              ; NOTE: THE THE TIMEOUT FEATURE IS USED TO COMMUN
ICATE THAT A DISK FILE IS NOT FOUND
15088  FE6F              ; ON AN ATTEMPT TO OPEN A FILE.
15089  FE6F              
15090  FE6F              XXFE6F = *
15091  FE6F  8D 85 02           STA     XX0285          ; SAVE SERIAL BUS 
TIMEOUT FLAG
15092  FE72  60                 RTS
15093  FE73                     
15094  FE73                     
15095  FE73              ;************************************************
***********************************;
15096  FE73              ;
15097  FE73              ; READ/SET THE TOP OF MEMORY, CB = 1 TO READ, CB 
= 0 TO SET
15098  FE73              
15099  FE73              ; THIS ROUTINE IS USED TO READ AND SET THE TOP OF
 RAM. WHEN THIS ROUTINE IS CALLED
15100  FE73              ; WITH THE CARRY BIT SET THE POINTER TO THE TOP O
F RAM WILL BE LOADED INTO XY. WHEN
15101  FE73              ; THIS ROUTINE IS CALLED WITH THE CARRY BIT CLEAR
 XY WILL BE SAVED AS THE TOP OF
15102  FE73              ; MEMORY POINTER CHANGING THE TOP OF MEMORY.
15103  FE73              
15104  FE73              XXFE73 = *
15105  FE73  90 06              BCC     XXFE7B          ; IF CB CLEAR GO S
ET THE TOP OF MEMORY
15106  FE75                     
15107  FE75              ; READ THE TOP OF MEMORY
15108  FE75              






HEN*;A......PAGE 0291

LINE# LOC   CODE        LINE


15109  FE75              XXFE75 = *
15110  FE75  AE 83 02           LDX     XX0283          ; GET MEMORY TOP L
OW BYTE
15111  FE78  AC 84 02           LDY     XX0284          ; GET MEMORY TOP H
IGH BYTE
15112  FE7B                     
15113  FE7B              ; SET THE TOP OF MEMORY
15114  FE7B              
15115  FE7B              XXFE7B = *
15116  FE7B  8E 83 02           STX     XX0283          ; SET MEMORY TOP L
OW BYTE
15117  FE7E  8C 84 02           STY     XX0284          ; SET MEMORY TOP H
IGH BYTE
15118  FE81  60                 RTS
15119  FE82                     
15120  FE82                     
15121  FE82              ;************************************************
***********************************;
15122  FE82              ;
15123  FE82              ; READ/SET THE BOTTOM OF MEMORY, CB = 1 TO READ, 
CB = 0 TO SET
15124  FE82              
15125  FE82              ; THIS ROUTINE IS USED TO READ AND SET THE BOTTOM
 OF RAM. WHEN THIS ROUTINE IS
15126  FE82              ; CALLED WITH THE CARRY BIT SET THE POINTER TO TH
E BOTTOM OF RAM WILL BE LOADED
15127  FE82              ; INTO XY. WHEN THIS ROUTINE IS CALLED WITH THE C
ARRY BIT CLEAR XY WILL BE SAVED AS
15128  FE82              ; THE BOTTOM OF MEMORY POINTER CHANGING THE BOTTO
M OF MEMORY.
15129  FE82              
15130  FE82              XXFE82 = *
15131  FE82  90 06              BCC     XXFE8A          ; IF CB CLEAR GO S
ET THE BOTTOM OF MEMORY
15132  FE84                     
15133  FE84              ; READ THE BOTTOM OF MEMORY
15134  FE84              
15135  FE84  AE 81 02           LDX     XX0281          ; READ OS START OF
 MEMORY LOW BYTE
15136  FE87  AC 82 02           LDY     XX0282          ; READ OS START OF
 MEMORY HIGH BYTE
15137  FE8A                     
15138  FE8A              ; SET THE BOTTOM OF MEMORY
15139  FE8A              
15140  FE8A              XXFE8A = *
15141  FE8A  8E 81 02           STX     XX0281          ; SET OS START OF 
MEMORY LOW BYTE
15142  FE8D  8C 82 02           STY     XX0282          ; SET OS START OF 
MEMORY HIGH BYTE
15143  FE90  60                 RTS
15144  FE91                     
15145  FE91                     
15146  FE91              ;************************************************
***********************************;
15147  FE91              ;
15148  FE91              ; NON-DESTRUCTIVE TEST RAM BYTE, RETURN CB=0 IF F
AILED
15149  FE91              
15150  FE91              XXFE91 = *
15151  FE91  B1 C1              LDA     (XXC1),Y          ; GET EXISTING R
AM BYTE
15152  FE93  AA                 TAX                    ; COPY TO X
15153  FE94  A9 55              LDA     #$55               ; SET FIRST TES
T BYTE
15154  FE96  91 C1              STA     (XXC1),Y          ; SAVE TO RAM
15155  FE98  D1 C1              CMP     (XXC1),Y          ; COMPARE WITH S
AVED
15156  FE9A  D0 08              BNE     XXFEA4          ; BRANCH IF FAIL
15157  FE9C                     
15158  FE9C  6A                 ROR A                  ; MAKE BYTE $AA, CA
RRY IS SET HERE
15159  FE9D  91 C1              STA     (XXC1),Y          ; SAVE TO RAM
15160  FE9F  D1 C1              CMP     (XXC1),Y          ; COMPARE WITH S
AVED
15161  FEA1  D0 01              BNE     XXFEA4          ; BRANCH IF FAIL
15162  FEA3  A9                 .BYTE     $A9               ; MAKES NEXT L
INE LDA #$18
15163  FEA4                     






****;A......PAGE 0292

LINE# LOC   CODE        LINE


15164  FEA4              XXFEA4 = *
15165  FEA4  18                 CLC                    ; FLAG TEST FAILED
15166  FEA5  8A                 TXA                    ; GET ORIGINAL BYTE
 BACK
15167  FEA6  91 C1              STA     (XXC1),Y          ; RESTORE ORIGIN
AL BYTE
15168  FEA8  60                 RTS
15169  FEA9                     
15170  FEA9                     
15171  FEA9              ;************************************************
***********************************;
15172  FEA9              ;
15173  FEA9              ; NMI VECTOR
15174  FEA9              
15175  FEA9              XXFEA9 = *
15176  FEA9  78                 SEI                    ; DISABLE INTERRUPT
S
15177  FEAA  6C 18 03           JMP     (XX0318)          ; DO NMI VECTOR
15178  FEAD                     
15179  FEAD                     
15180  FEAD              ;************************************************
***********************************;
15181  FEAD              ;
15182  FEAD              ; NMI HANDLER
15183  FEAD              
15184  FEAD              XXFEAD = *
15185  FEAD  48                 PHA                    ; SAVE A
15186  FEAE  8A                 TXA                    ; COPY X
15187  FEAF  48                 PHA                    ; SAVE X
15188  FEB0  98                 TYA                    ; COPY Y
15189  FEB1  48                 PHA                    ; SAVE Y
15190  FEB2  AD 1D 91           LDA     XX911D          ; GET VIA 1 IFR
15191  FEB5  10 48              BPL     XXFEFF          ; IF NO INTERRUPT 
RESTORE REGISTERS AND EXIT
15192  FEB7                     
15193  FEB7  2D 1E 91           AND     XX911E          ; AND WITH VIA 1 I
ER
15194  FEBA  AA                 TAX                    ; COPY TO X
15195  FEBB  29 02              AND     #$02               ; MASK [RESTORE
] KEY
15196  FEBD  F0 1F              BEQ     XXFEDE          ; BRANCH IF NOT [R
ESTORE] KEY
15197  FEBF                     
15198  FEBF                                     ; ELSE WAS [RESTORE] KEY .
.
15199  FEBF  20 3F FD           JSR     XXFD3F          ; SCAN FOR AUTOSTA
RT ROM AT $A000
15200  FEC2  D0 03              BNE     XXFEC7          ; BRANCH IF NO AUT
OSTART ROM
15201  FEC4                     
15202  FEC4  6C 02 A0           JMP     (XXA002)          ; ELSE DO AUTOST
ART ROM BREAK ENTRY
15203  FEC7                     
15204  FEC7              XXFEC7 = *
15205  FEC7  2C 11 91           BIT     XX9111          ; TEST VIA 1 DRA
15206  FECA  20 34 F7           JSR     XXF734          ; INCREMENT THE RE
AL TIME CLOCK
15207  FECD  20 E1 FF           JSR     XXFFE1          ; SCAN STOP KEY
15208  FED0  D0 2D              BNE     XXFEFF          ; IF NOT [STOP] RE
STORE REGISTERS AND EXIT INTERRUPT
15209  FED2                     
15210  FED2                     
15211  FED2              ;************************************************
***********************************;
15212  FED2              ;
15213  FED2              ; BRK HANDLER
15214  FED2              
15215  FED2              XXFED2 = *
15216  FED2  20 52 FD           JSR     XXFD52          ; RESTORE DEFAULT 
I/O VECTORS
15217  FED5  20 F9 FD           JSR     XXFDF9          ; INITIALIZE I/O R
EGISTERS
15218  FED8  20 18 E5           JSR     XXE518          ; INITIALISE HARDW
ARE






****;A......PAGE 0293

LINE# LOC   CODE        LINE


15219  FEDB  6C 02 C0           JMP     (XXC002)          ; DO BASIC BREAK
 ENTRY
15220  FEDE                     
15221  FEDE                     
15222  FEDE              ;************************************************
***********************************;
15223  FEDE              ;
15224  FEDE              ; RS232 NMI ROUTINE
15225  FEDE              
15226  FEDE              XXFEDE = *
15227  FEDE  AD 1E 91           LDA     XX911E          ; GET VIA 1 IER
15228  FEE1  09 80              ORA     #$80               ; SET ENABLE BI
T, THIS BIT SHOULD BE SET ACCORDING TO THE
15229  FEE3                                     ; ROCKWELL 6522 DATASHEET 
BUT CLEAR ACORDING TO THE MOS
15230  FEE3                                     ; DATASHEET. BEST TO ASSUM
E IT'S NOT IN THE STATE REQUIRED
15231  FEE3                                     ; AND SET IT SO
15232  FEE3  48                 PHA                    ; SAVE TO RE-ENABLE
 INTERRUPTS
15233  FEE4  A9 7F              LDA     #$7F               ; DISABLE ALL I
NTERRUPTS
15234  FEE6  8D 1E 91           STA     XX911E          ; SET VIA 1 IER
15235  FEE9  8A                 TXA                    ; GET ACTIVE INTERR
UPTS BACK
15236  FEEA  29 40              AND     #$40               ; MASK T1 INTER
RUPT
15237  FEEC  F0 14              BEQ     XXFF02          ; BRANCH IF NOT T1
 INTERRUPT
15238  FEEE                     
15239  FEEE                                     ; WAS VIA 1 T1 INTERRUPT
15240  FEEE  A9 CE              LDA     #$CE               ; CB2 LOW, CB1 
-VE EDGE, CA2 HIGH, CA1 -VE EDGE
15241  FEF0  05 B5              ORA     XXB5          ; OR RS232 NEXT BIT 
TO SEND, SETS CB2 HIGH IF SET
15242  FEF2  8D 1C 91           STA     XX911C          ; SET VIA 1 PCR
15243  FEF5  AD 14 91           LDA     XX9114          ; GET VIA 1 T1C_L
15244  FEF8  68                 PLA                    ; RESTORE INTERRUPT
 ENABLE BYTE TO RSTORE PREVIOUSLY
15245  FEF9                                     ; ENABLED INTERRUPTS
15246  FEF9  8D 1E 91           STA     XX911E          ; SET VIA 1 IER
15247  FEFC  20 A3 EF           JSR     XXEFA3          ; RS232 TX NMI ROU
TINE
15248  FEFF              XXFEFF = *
15249  FEFF  4C 56 FF           JMP     XXFF56          ; RESTORE REGISTER
S AND EXIT INTERRUPT
15250  FF02                     
15251  FF02                                     ; WAS NOT VIA 1 T1 INTERRU
PT
15252  FF02              XXFF02 = *
15253  FF02  8A                 TXA                    ; GET ACTIVE INTERR
UPTS BACK
15254  FF03  29 20              AND     #$20               ; MASK T2 INTER
RUPT
15255  FF05  F0 25              BEQ     XXFF2C          ; BRANCH IF NOT T2
 INTERRUPT
15256  FF07                     
15257  FF07                                     ; WAS VIA 1 T2 INTERRUPT
15258  FF07  AD 10 91           LDA     XX9110          ; GET VIA 1 DRB
15259  FF0A  29 01              AND     #$01               ; MASK RS232 DA
TA IN
15260  FF0C  85 A7              STA     XXA7          ; SAVE RECEIVER INPU
T BIT TEMP STORAGE
15261  FF0E  AD 18 91           LDA     XX9118          ; GET VIA 1 T2C_L
15262  FF11  E9 16              SBC     #$16               ;.
15263  FF13  6D 99 02           ADC     XX0299          ; ADD BAUD RATE BI
T TIME LOW BYTE
15264  FF16  8D 18 91           STA     XX9118          ; SET VIA 1 T2C_L
15265  FF19  AD 19 91           LDA     XX9119          ; GET VIA 1 T2C_H
15266  FF1C  6D 9A 02           ADC     XX029A          ; ADD BAUD RATE BI
T TIME HIGH BYTE
15267  FF1F  8D 19 91           STA     XX9119          ; SET VIA 1 T2C_H
15268  FF22  68                 PLA                    ; RESTORE INTERRUPT
 ENABLE BYTE TO RESTORE PREVIOUSLY
15269  FF23                                     ; ENABLED INTERRUPTS
15270  FF23  8D 1E 91           STA     XX911E          ; SET VIA 1 IER, R
ESTORE INTERRUPTS
15271  FF26  20 36 F0           JSR     XXF036          ; RS232 RX
15272  FF29  4C 56 FF           JMP     XXFF56          ; RESTORE REGISTER
S AND EXIT INTERRUPT
15273  FF2C                     






YEDTO ......PAGE 0294

LINE# LOC   CODE        LINE


15274  FF2C                                     ; WAS NOT VIA 1 T2 INTERRU
PT
15275  FF2C              XXFF2C = *
15276  FF2C  8A                 TXA                    ; GET ACTIVE INTERR
UPTS BACK
15277  FF2D  29 10              AND     #$10               ; MASK CB1 INTE
RRUPT, RX DATA BIT TRANSITION
15278  FF2F  F0 25              BEQ     XXFF56          ; IF NO BIT RESTOR
E REGISTERS AND EXIT INTERRUPT
15279  FF31                     
15280  FF31  AD 93 02           LDA     XX0293          ; GET PSEUDO 6551 
CONTROL REGISTER
15281  FF34  29 0F              AND     #$0F               ; CLEAR NON BAU
D BITS
15282  FF36  D0 00              BNE     XXFF38          ; SHORT DELAY. WAS
 THIS TO BE A BRANCH TO CODE TO IMPLEMENT
15283  FF38                                     ; THE USER BAUD RATE ??
15284  FF38              XXFF38 = *
15285  FF38  0A                 ASL A                  ; *2, 2 BYTES PER B
AUD COUNT
15286  FF39  AA                 TAX                    ; COPY TO INDEX
15287  FF3A  BD 5A FF           LDA     XXFF5C-2,X     ; GET BAUD COUNT LO
W BYTE
15288  FF3D  8D 18 91           STA     XX9118          ; SET VIA 1 T2C_L
15289  FF40  BD 5B FF           LDA     XXFF5C-1,X     ; GET BAUD COUNT HI
GH BYTE
15290  FF43  8D 19 91           STA     XX9119          ; SET VIA 1 T2C_H
15291  FF46  AD 10 91           LDA     XX9110          ; READ VIA 1 DRB, 
CLEAR INTERRUPT FLAG
15292  FF49  68                 PLA                    ; RESTORE INTERRUPT
 ENABLE BYTE TO RSTORE PREVIOUSLY
15293  FF4A                                     ; ENABLED INTERRUPTS
15294  FF4A  09 20              ORA     #$20               ; ENABLE T2 INT
ERRUPT
15295  FF4C  29 EF              AND     #$EF               ; DISABLE CB1 I
NTERRUPT
15296  FF4E  8D 1E 91           STA     XX911E          ; SET VIA 1 IER
15297  FF51  AE 98 02           LDX     XX0298          ; GET NUMBER OF BI
TS TO BE SENT/RECEIVED
15298  FF54  86 A8              STX     XXA8          ; SAVE RECEIVER BIT 
COUNT IN
15299  FF56                     
15300  FF56                     
15301  FF56              ;************************************************
***********************************;
15302  FF56              ;
15303  FF56              ; RESTORE THE REGISTERS AND EXIT THE INTERRUPT
15304  FF56              ;
15305  FF56              ; IF YOU WRITE YOUR OWN INTERRUPT CODE YOU SHOULD
 EITHER RETURN FROM THE INTERRUPT
15306  FF56              ; USING CODE THAT ENDS UP HERE OT CODE THAT REPLI
CATES THIS CODE.
15307  FF56              
15308  FF56              XXFF56 = *
15309  FF56  68                 PLA                    ; PULL Y
15310  FF57  A8                 TAY                    ; RESTORE Y
15311  FF58  68                 PLA                    ; PULL X
15312  FF59  AA                 TAX                    ; RESTORE X
15313  FF5A  68                 PLA                    ; RESTORE A
15314  FF5B  40                 RTI
15315  FF5C                     
15316  FF5C                     
15317  FF5C              ;************************************************
***********************************;
15318  FF5C              ;
15319  FF5C              ; BAUD RATE WORD IS CALCULATED FROM ..
15320  FF5C              ;
15321  FF5C              ; (SYSTEM CLOCK / BAUD RATE) / 2 - 100
15322  FF5C              ;
15323  FF5C              ;          SYSTEM CLOCK
15324  FF5C              ;          ------------
15325  FF5C              ; PAL          1108404 HZ
15326  FF5C              ; NTSC     1022727 HZ
15327  FF5C              
15328  FF5C              ; BAUD RATE TABLES FOR PAL VIC 20






****;E......PAGE 0295

LINE# LOC   CODE        LINE


15329  FF5C              
15330  FF5C              XXFF5C = *
15331  FF5C  E6 2A              .WORD     $2AE6               ;   50   BAU
D
15332  FF5E  78 1C              .WORD     $1C78               ;   75   BAU
D
15333  FF60  49 13              .WORD     $1349               ;  110   BAU
D
15334  FF62  B1 0F              .WORD     $0FB1               ;  134.5 BAU
D
15335  FF64  0A 0E              .WORD     $0E0A               ;  150   BAU
D
15336  FF66  D3 06              .WORD     $06D3               ;  300   BAU
D
15337  FF68  38 03              .WORD     $0338               ;  600   BAU
D
15338  FF6A  6A 01              .WORD     $016A               ; 1200   BAU
D
15339  FF6C  D0 00              .WORD     $00D0               ; 1800   BAU
D
15340  FF6E  83 00              .WORD     $0083               ; 2400   BAU
D
15341  FF70  36 00              .WORD     $0036               ; 3600   BAU
D
15342  FF72                     
15343  FF72              ; BAUD RATE TABLES FOR NTSC VIC 20
15344  FF72              
15345  FF72              ;     .WORD     $2792               ;   50   BAUD

15346  FF72              ;     .WORD     $1A40               ;   75   BAUD

15347  FF72              ;     .WORD     $11C6               ;  110   BAUD

15348  FF72              ;     .WORD     $0E74               ;  134.5 BAUD

15349  FF72              ;     .WORD     $0CEE               ;  150   BAUD

15350  FF72              ;     .WORD     $0645               ;  300   BAUD

15351  FF72              ;     .WORD     $02F1               ;  600   BAUD

15352  FF72              ;     .WORD     $0146               ; 1200   BAUD

15353  FF72              ;     .WORD     $00B8               ; 1800   BAUD

15354  FF72              ;     .WORD     $0071               ; 2400   BAUD

15355  FF72              ;     .WORD     $002A               ; 3600   BAUD

15356  FF72              
15357  FF72              
15358  FF72              ;************************************************
***********************************;
15359  FF72              ;
15360  FF72              ; IRQ VECTOR
15361  FF72              
15362  FF72              XXFF72 = *
15363  FF72  48                 PHA                    ; SAVE A
15364  FF73  8A                 TXA                    ; COPY X
15365  FF74  48                 PHA                    ; SAVE X
15366  FF75  98                 TYA                    ; COPY Y
15367  FF76  48                 PHA                    ; SAVE Y
15368  FF77  BA                 TSX                    ; COPY STACK POINTE
R
15369  FF78  BD 04 01           LDA     XX0100+4,X     ; GET THE STACKED S
TATUS REGISTER
15370  FF7B  29 10              AND     #$10               ; MASK THE BRK 
FLAG BIT
15371  FF7D  F0 03              BEQ     XXFF82          ; IF NOT BRK GO DO
 THE HARDWARE IRQ VECTOR
15372  FF7F                     
15373  FF7F  6C 16 03           JMP     (XX0316)          ; ELSE DO THE BR
K VECTOR (IBRK)
15374  FF82                     
15375  FF82              XXFF82 = *
15376  FF82  6C 14 03           JMP     (XX0314)          ; DO IRQ VECTOR 
(IIRQ)
15377  FF85                     
15378  FF85                     
15379  FF85              ;************************************************
***********************************;
15380  FF85              ;
15381  FF85              ; SPARE BYTES, NOT REFERENCED
15382  FF85              
15383  FF85              ;XXFF85






****;E......PAGE 0296

LINE# LOC   CODE        LINE


15384  FF85  FF                 .BYTE     $FF,$FF,$FF,$FF,$FF
15384  FF86  FF 
15384  FF87  FF 
15384  FF88  FF 
15384  FF89  FF 
15385  FF8A                     
15386  FF8A                     
15387  FF8A              ;************************************************
***********************************;
15388  FF8A              ;
15389  FF8A              ; RESTORE DEFAULT I/O VECTORS
15390  FF8A              
15391  FF8A              ; THIS ROUTINE RESTORES THE DEFAULT VALUES OF ALL
 SYSTEM VECTORS USED IN KERNAL AND
15392  FF8A              ; BASIC ROUTINES AND INTERRUPTS. THE KERNAL VECTO
R ROUTINE IS USED TO READ AND ALTER
15393  FF8A              ; INDIVIDUAL SYSTEM VECTORS.
15394  FF8A              
15395  FF8A              
15396  FF8A              ;XXFF8A
15397  FF8A  4C 52 FD           JMP     XXFD52          ; RESTORE DEFAULT 
I/O VECTORS
15398  FF8D                     
15399  FF8D                     
15400  FF8D              ;************************************************
***********************************;
15401  FF8D              ;
15402  FF8D              ; READ/SET VECTORED I/O
15403  FF8D              
15404  FF8D              ; THIS ROUTINE MANAGES ALL SYSTEM VECTOR JUMP ADD
RESSES STORED IN RAM. CALLING THIS
15405  FF8D              ; ROUTINE WITH THE ACCUMULATOR CARRY BIT SET WILL
 STORE THE CURRENT CONTENTS OF THE
15406  FF8D              ; RAM VECTORS IN A LIST POINTED TO BY THE X AND Y
 REGISTERS.
15407  FF8D              
15408  FF8D              ; WHEN THIS ROUTINE IS CALLED WITH THE CARRY BIT 
CLEAR, THE USER LIST POINTED TO BY
15409  FF8D              ; THE X AND Y REGISTERS IS TRANSFERRED TO THE SYS
TEM RAM VECTORS.
15410  FF8D              
15411  FF8D              ; NOTE: THIS ROUTINE REQUIRES CAUTION IN ITS USE.
 THE BEST WAY TO USE IT IS TO FIRST
15412  FF8D              ; READ THE ENTIRE VECTOR CONTENTS INTO THE USER A
REA, ALTER THE DESIRED VECTORS, AND
15413  FF8D              ; THEN COPY THE CONTENTS BACK TO THE SYSTEM VECTO
RS.
15414  FF8D              
15415  FF8D              ;XXFF8D
15416  FF8D  4C 57 FD           JMP     XXFD57          ; SET/READ VECTORE
D I/O FROM (XY)
15417  FF90                     
15418  FF90                     
15419  FF90              ;************************************************
***********************************;
15420  FF90              ;
15421  FF90              ; CONTROL KERNAL MESSAGES
15422  FF90              
15423  FF90              ; THIS ROUTINE CONTROLS THE PRINTING OF ERROR AND
 CONTROL MESSAGES BY THE KERNAL.
15424  FF90              ; EITHER PRINT ERROR MESSAGES OR PRINT CONTROL ME
SSAGES CAN BE SELECTED BY SETTING
15425  FF90              ; THE ACCUMULATOR WHEN THE ROUTINE IS CALLED.
15426  FF90              
15427  FF90              ; FILE NOT FOUND IS AN EXAMPLE OF AN ERROR MESSAG
E. PRESS PLAY ON CASSETTE IS AN
15428  FF90              ; EXAMPLE OF A CONTROL MESSAGE.
15429  FF90              
15430  FF90              ; BITS 6 AND 7 OF THIS VALUE DETERMINE WHERE THE 
MESSAGE WILL COME FROM. IF BIT 7
15431  FF90              ; IS SET ONE OF THE ERROR MESSAGES FROM THE KERNA
L WILL BE PRINTED. IF BIT 6 IS SET
15432  FF90              ; A CONTROL MESSAGE WILL BE PRINTED.
15433  FF90              
15434  FF90              XXFF90 = *






SET*;E......PAGE 0297

LINE# LOC   CODE        LINE


15435  FF90  4C 66 FE           JMP     XXFE66          ; CONTROL KERNAL M
ESSAGES
15436  FF93                     
15437  FF93                     
15438  FF93              ;************************************************
***********************************;
15439  FF93              ;
15440  FF93              ; SEND SECONDARY ADDRESS AFTER LISTEN
15441  FF93              
15442  FF93              ; THIS ROUTINE IS USED TO SEND A SECONDARY ADDRES
S TO AN I/O DEVICE AFTER A CALL TO
15443  FF93              ; THE LISTEN ROUTINE IS MADE AND THE DEVICE COMMA
NDED TO LISTEN. THE ROUTINE CANNOT
15444  FF93              ; BE USED TO SEND A SECONDARY ADDRESS AFTER A CAL
L TO THE TALK ROUTINE.
15445  FF93              
15446  FF93              ; A SECONDARY ADDRESS IS USUALLY USED TO GIVE SET
-UP INFORMATION TO A DEVICE BEFORE
15447  FF93              ; I/O OPERATIONS BEGIN.
15448  FF93              
15449  FF93              ; WHEN A SECONDARY ADDRESS IS TO BE SENT TO A DEV
ICE ON THE SERIAL BUS THE ADDRESS
15450  FF93              ; MUST FIRST BE ORED WITH $60.
15451  FF93              
15452  FF93              ;XXFF93
15453  FF93  4C C0 EE           JMP     XXEEC0          ; SEND SECONDARY A
DDRESS AFTER LISTEN
15454  FF96                     
15455  FF96                     
15456  FF96              ;************************************************
***********************************;
15457  FF96              ;
15458  FF96              ; SEND SECONDARY ADDRESS AFTER TALK
15459  FF96              
15460  FF96              ; THIS ROUTINE TRANSMITS A SECONDARY ADDRESS ON T
HE SERIAL BUS FOR A TALK DEVICE.
15461  FF96              ; THIS ROUTINE MUST BE CALLED WITH A NUMBER BETWE
EN 4 AND 31 IN THE ACCUMULATOR.
15462  FF96              ; THE ROUTINE WILL SEND THIS NUMBER AS A SECONDAR
Y ADDRESS COMMAND OVER THE SERIAL
15463  FF96              ; BUS. THIS ROUTINE CAN ONLY BE CALLED AFTER A CA
LL TO THE TALK ROUTINE. IT WILL
15464  FF96              ; NOT WORK AFTER A LISTEN.
15465  FF96              
15466  FF96              ;XXFF96
15467  FF96  4C CE EE           JMP     XXEECE          ; SEND SECONDARY A
DDRESS AFTER TALK
15468  FF99                     
15469  FF99                     
15470  FF99              ;************************************************
***********************************;
15471  FF99              ;
15472  FF99              ; READ/SET THE TOP OF MEMORY
15473  FF99              
15474  FF99              ; THIS ROUTINE IS USED TO READ AND SET THE TOP OF
 RAM. WHEN THIS ROUTINE IS CALLED
15475  FF99              ; WITH THE CARRY BIT SET THE POINTER TO THE TOP O
F RAM WILL BE LOADED INTO XY. WHEN
15476  FF99              ; THIS ROUTINE IS CALLED WITH THE CARRY BIT CLEAR
 XY WILL BE SAVED AS THE TOP OF
15477  FF99              ; MEMORY POINTER CHANGING THE TOP OF MEMORY.
15478  FF99              
15479  FF99              XXFF99 = *
15480  FF99  4C 73 FE           JMP     XXFE73          ; READ/SET THE TOP
 OF MEMORY
15481  FF9C                     
15482  FF9C                     
15483  FF9C              ;************************************************
***********************************;
15484  FF9C              ;
15485  FF9C              ; READ/SET THE BOTTOM OF MEMORY
15486  FF9C              
15487  FF9C              ; THIS ROUTINE IS USED TO READ AND SET THE BOTTOM
 OF RAM. WHEN THIS ROUTINE IS
15488  FF9C              ; CALLED WITH THE CARRY BIT SET THE POINTER TO TH
E BOTTOM OF RAM WILL BE LOADED
15489  FF9C              ; INTO XY. WHEN THIS ROUTINE IS CALLED WITH THE C
ARRY BIT CLEAR XY WILL BE SAVED AS






 AS*;E......PAGE 0298

LINE# LOC   CODE        LINE


15490  FF9C              ; THE BOTTOM OF MEMORY POINTER CHANGING THE BOTTO
M OF MEMORY.
15491  FF9C              
15492  FF9C              XXFF9C = *
15493  FF9C  4C 82 FE           JMP     XXFE82          ; READ/SET THE BOT
TOM OF MEMORY
15494  FF9F                     
15495  FF9F                     
15496  FF9F              ;************************************************
***********************************;
15497  FF9F              ;
15498  FF9F              ; SCAN THE KEYBOARD
15499  FF9F              
15500  FF9F              ; THIS ROUTINE WILL SCAN THE KEYBOARD AND CHECK F
OR PRESSED KEYS. IT IS THE SAME
15501  FF9F              ; ROUTINE CALLED BY THE INTERRUPT HANDLER. IF A K
EY IS DOWN, ITS ASCII VALUE IS
15502  FF9F              ; PLACED IN THE KEYBOARD QUEUE.
15503  FF9F              
15504  FF9F              ;XXFF9F
15505  FF9F  4C 1E EB           JMP     XXEB1E          ; SCAN KEYBOARD
15506  FFA2                     
15507  FFA2                     
15508  FFA2              ;************************************************
***********************************;
15509  FFA2              ;
15510  FFA2              ; SET TIMEOUT ON SERIAL BUS
15511  FFA2              
15512  FFA2              ; THIS ROUTINE SETS THE TIMEOUT FLAG FOR THE SERI
AL BUS. WHEN THE TIMEOUT FLAG IS
15513  FFA2              ; SET, THE COMPUTER WILL WAIT FOR A DEVICE ON THE
 SERIAL PORT FOR 64 MILLISECONDS.
15514  FFA2              ; IF THE DEVICE DOES NOT RESPOND TO THE COMPUTER'
S DAV SIGNAL WITHIN THAT TIME THE
15515  FFA2              ; COMPUTER WILL RECOGNIZE AN ERROR CONDITION AND 
LEAVE THE HANDSHAKE SEQUENCE. WHEN
15516  FFA2              ; THIS ROUTINE IS CALLED AND THE ACCUMULATOR CONT
AINS A 0 IN BIT 7, TIMEOUTS ARE
15517  FFA2              ; ENABLED. A 1 IN BIT 7 WILL DISABLE THE TIMEOUTS
.
15518  FFA2              
15519  FFA2              ; NOTE: THE THE TIMEOUT FEATURE IS USED TO COMMUN
ICATE THAT A DISK FILE IS NOT FOUND
15520  FFA2              ; ON AN ATTEMPT TO OPEN A FILE.
15521  FFA2              
15522  FFA2              ;XXFFA2
15523  FFA2  4C 6F FE           JMP     XXFE6F          ; SET TIMEOUT ON S
ERIAL BUS
15524  FFA5                     
15525  FFA5                     
15526  FFA5              ;************************************************
************************************
15527  FFA5              ;
15528  FFA5              ; INPUT A BYTE FROM THE SERIAL BUS
15529  FFA5              
15530  FFA5              ; THIS ROUTINE READS A BYTE OF DATA FROM THE SERI
AL BUS USING FULL HANDSHAKING. THE
15531  FFA5              ; DATA IS RETURNED IN THE ACCUMULATOR. BEFORE USI
NG THIS ROUTINE THE TALK ROUTINE,
15532  FFA5              ; XXFFB4, MUST HAVE BEEN CALLED FIRST TO COMMAND 
THE DEVICE ON THE SERIAL BUS TO
15533  FFA5              ; SEND DATA ON THE BUS. IF THE INPUT DEVICE NEEDS
 A SECONDARY COMMAND IT MUST BE SENT
15534  FFA5              ; BY USING THE TKSA ROUTINE, XXFF96, BEFORE CALLI
NG THIS ROUTINE.
15535  FFA5              
15536  FFA5              ; ERRORS ARE RETURNED IN THE STATUS WORD WHICH CA
N BE READ BY CALLING THE READST
15537  FFA5              ; ROUTINE, XXFFB7.
15538  FFA5              
15539  FFA5              ;XXFFA5
15540  FFA5  4C 19 EF           JMP     XXEF19          ; INPUT BYTE FROM 
SERIAL BUS
15541  FFA8                     
15542  FFA8                     
15543  FFA8              ;************************************************
************************************
15544  FFA8              ;






*****E......PAGE 0299

LINE# LOC   CODE        LINE


15545  FFA8              ; OUTPUT A BYTE TO THE SERIAL BUS
15546  FFA8              
15547  FFA8              ; THIS ROUTINE IS USED TO SEND INFORMATION TO DEV
ICES ON THE SERIAL BUS. A CALL TO
15548  FFA8              ; THIS ROUTINE WILL PUT A DATA BYTE ONTO THE SERI
AL BUS USING FULL HANDSHAKING.
15549  FFA8              ; BEFORE THIS ROUTINE IS CALLED THE LISTEN ROUTIN
E, XXFFB1, MUST BE USED TO
15550  FFA8              ; COMMAND A DEVICE ON THE SERIAL BUS TO GET READY
 TO RECEIVE DATA.
15551  FFA8              
15552  FFA8              ; THE ACCUMULATOR IS LOADED WITH A BYTE TO OUTPUT
 AS DATA ON THE SERIAL BUS. A
15553  FFA8              ; DEVICE MUST BE LISTENING OR THE STATUS WORD WIL
L RETURN A TIMEOUT. THIS ROUTINE
15554  FFA8              ; ALWAYS BUFFERS ONE CHARACTER. SO WHEN A CALL TO
 THE UNLISTEN ROUTINE, XXFFAE,
15555  FFA8              ; IS MADE TO END THE DATA TRANSMISSION, THE BUFFE
RED CHARACTER IS SENT WITH EOI
15556  FFA8              ; SET. THEN THE UNLISTEN COMMAND IS SENT TO THE D
EVICE.
15557  FFA8              
15558  FFA8              ;XXFFA8
15559  FFA8  4C E4 EE           JMP     XXEEE4          ; OUTPUT A BYTE TO
 THE SERIAL BUS
15560  FFAB                     
15561  FFAB                     
15562  FFAB              ;************************************************
***********************************;
15563  FFAB              ;
15564  FFAB              ; COMMAND THE SERIAL BUS TO UNTALK
15565  FFAB              
15566  FFAB              ; THIS ROUTINE WILL TRANSMIT AN UNTALK COMMAND ON
 THE SERIAL BUS. ALL DEVICES
15567  FFAB              ; PREVIOUSLY SET TO TALK WILL STOP SENDING DATA W
HEN THIS COMMAND IS RECEIVED.
15568  FFAB              
15569  FFAB              ;XXFFAB
15570  FFAB  4C F6 EE           JMP     XXEEF6          ; COMMAND THE SERI
AL BUS TO UNTALK
15571  FFAE                     
15572  FFAE                     
15573  FFAE              ;************************************************
***********************************;
15574  FFAE              ;
15575  FFAE              ; COMMAND THE SERIAL BUS TO UNLISTEN
15576  FFAE              
15577  FFAE              ; THIS ROUTINE COMMANDS ALL DEVICES ON THE SERIAL
 BUS TO STOP RECEIVING DATA FROM
15578  FFAE              ; THE COMPUTER. CALLING THIS ROUTINE RESULTS IN A
N UNLISTEN COMMAND BEING TRANSMITTED
15579  FFAE              ; ON THE SERIAL BUS. ONLY DEVICES PREVIOUSLY COMM
ANDED TO LISTEN WILL BE AFFECTED.
15580  FFAE              
15581  FFAE              ; THIS ROUTINE IS NORMALLY USED AFTER THE COMPUTE
R IS FINISHED SENDING DATA TO
15582  FFAE              ; EXTERNAL DEVICES. SENDING THE UNLISTEN WILL COM
MAND THE LISTENING DEVICES TO GET
15583  FFAE              ; OFF THE SERIAL BUS SO IT CAN BE USED FOR OTHER 
PURPOSES.
15584  FFAE              
15585  FFAE              ;XXFFAE
15586  FFAE  4C 04 EF           JMP     XXEF04          ; COMMAND THE SERI
AL BUS TO UNLISTEN
15587  FFB1                     
15588  FFB1                     
15589  FFB1              ;************************************************
***********************************;
15590  FFB1              ;
15591  FFB1              ; COMMAND DEVICES ON THE SERIAL BUS TO LISTEN
15592  FFB1              
15593  FFB1              ; THIS ROUTINE WILL COMMAND A DEVICE ON THE SERIA
L BUS TO RECEIVE DATA. THE
15594  FFB1              ; ACCUMULATOR MUST BE LOADED WITH A DEVICE NUMBER
 BETWEEN 4 AND 31 BEFORE CALLING
15595  FFB1              ; THIS ROUTINE. LISTEN CONVERT THIS TO A LISTEN A
DDRESS THEN TRANSMIT THIS DATA AS
15596  FFB1              ; A COMMAND ON THE SERIAL BUS. THE SPECIFIED DEVI
CE WILL THEN GO INTO LISTEN MODE
15597  FFB1              ; AND BE READY TO ACCEPT INFORMATION.
15598  FFB1              
15599  FFB1              ;XXFFB1






ES**;E......PAGE 0300

LINE# LOC   CODE        LINE


15600  FFB1  4C 17 EE           JMP     XXEE17          ; COMMAND DEVICES 
ON THE SERIAL BUS TO LISTEN
15601  FFB4                     
15602  FFB4                     
15603  FFB4              ;************************************************
***********************************;
15604  FFB4              ;
15605  FFB4              ; COMMAND A SERIAL BUS DEVICE TO TALK
15606  FFB4              
15607  FFB4              ; TO USE THIS ROUTINE THE ACCUMULATOR MUST FIRST 
BE LOADED WITH A DEVICE NUMBER
15608  FFB4              ; BETWEEN 4 AND 30. WHEN CALLED THIS ROUTINE CONV
ERTS THIS DEVICE NUMBER TO A TALK
15609  FFB4              ; ADDRESS. THEN THIS DATA IS TRANSMITTED AS A COM
MAND ON THE SERIAL BUS.
15610  FFB4              
15611  FFB4              ;XXFFB4
15612  FFB4  4C 14 EE           JMP     XXEE14          ; COMMAND SERIAL B
US DEVICE TO TALK
15613  FFB7                     
15614  FFB7                     
15615  FFB7              ;************************************************
***********************************;
15616  FFB7              ;
15617  FFB7              ; READ I/O STATUS WORD
15618  FFB7              
15619  FFB7              ; THIS ROUTINE RETURNS THE CURRENT STATUS OF THE 
I/O DEVICE IN THE ACCUMULATOR. THE
15620  FFB7              ; ROUTINE IS USUALLY CALLED AFTER NEW COMMUNICATI
ON TO AN I/O DEVICE. THE ROUTINE
15621  FFB7              ; WILL GIVE INFORMATION ABOUT DEVICE STATUS, OR E
RRORS THAT HAVE OCCURRED DURING THE
15622  FFB7              ; I/O OPERATION.
15623  FFB7              
15624  FFB7              XXFFB7 = *
15625  FFB7  4C 57 FE           JMP     XXFE57          ; READ I/O STATUS 
WORD
15626  FFBA                     
15627  FFBA                     
15628  FFBA              ;************************************************
***********************************;
15629  FFBA              ;
15630  FFBA              ; SET LOGICAL, FIRST AND SECOND ADDRESSES
15631  FFBA              
15632  FFBA              ; THIS ROUTINE WILL SET THE LOGICAL FILE NUMBER, 
DEVICE ADDRESS, AND SECONDARY
15633  FFBA              ; ADDRESS, COMMAND NUMBER, FOR OTHER KERNAL ROUTI
NES.
15634  FFBA              
15635  FFBA              ; THE LOGICAL FILE NUMBER IS USED BY THE SYSTEM A
S A KEY TO THE FILE TABLE CREATED
15636  FFBA              ; BY THE OPEN FILE ROUTINE. DEVICE ADDRESSES CAN 
RANGE FROM 0 TO 30. THE FOLLOWING
15637  FFBA              ; CODES ARE USED BY THE COMPUTER TO STAND FOR THE
 FOLLOWING CBM DEVICES:
15638  FFBA              
15639  FFBA              ; ADDRESS     DEVICE
15640  FFBA              ; =======     ======
15641  FFBA              ;  0          KEYBOARD
15642  FFBA              ;  1          CASSETTE #1
15643  FFBA              ;  2          RS-232C DEVICE
15644  FFBA              ;  3          CRT DISPLAY
15645  FFBA              ;  4          SERIAL BUS PRINTER
15646  FFBA              ;  8          CBM SERIAL BUS DISK DRIVE
15647  FFBA              
15648  FFBA              ; DEVICE NUMBERS OF FOUR OR GREATER AUTOMATICALLY
 REFER TO DEVICES ON THE SERIAL
15649  FFBA              ; BUS.
15650  FFBA              
15651  FFBA              ; A COMMAND TO THE DEVICE IS SENT AS A SECONDARY 
ADDRESS ON THE SERIAL BUS AFTER
15652  FFBA              ; THE DEVICE NUMBER IS SENT DURING THE SERIAL ATT
ENTION HANDSHAKING SEQUENCE. IF
15653  FFBA              ; NO SECONDARY ADDRESS IS TO BE SENT Y SHOULD BE 
SET TO $FF.
15654  FFBA              






NG**;E......PAGE 0301

LINE# LOC   CODE        LINE


15655  FFBA              XXFFBA = *
15656  FFBA  4C 50 FE           JMP     XXFE50          ; SET LOGICAL, FIR
ST AND SECOND ADDRESSES
15657  FFBD                     
15658  FFBD                     
15659  FFBD              ;************************************************
***********************************;
15660  FFBD              ;
15661  FFBD              ; SET THE FILENAME
15662  FFBD              
15663  FFBD              ; THIS ROUTINE IS USED TO SET UP THE FILE NAME FO
R THE OPEN, SAVE, OR LOAD ROUTINES.
15664  FFBD              ; THE ACCUMULATOR MUST BE LOADED WITH THE LENGTH 
OF THE FILE AND XY WITH THE POINTER
15665  FFBD              ; TO FILE NAME, X BEING TH LOW BYTE. THE ADDRESS 
CAN BE ANY VALID MEMORY ADDRESS IN
15666  FFBD              ; THE SYSTEM WHERE A STRING OF CHARACTERS FOR THE
 FILE NAME IS STORED. IF NO FILE
15667  FFBD              ; NAME DESIRED THE ACCUMULATOR MUST BE SET TO 0, 
REPRESENTING A ZERO FILE LENGTH,
15668  FFBD              ; IN THAT CASE  XY MAY BE SET TO ANY MEMORY ADDRE
SS.
15669  FFBD              
15670  FFBD              XXFFBD = *
15671  FFBD  4C 49 FE           JMP     XXFE49          ; SET FILENAME
15672  FFC0                     
15673  FFC0                     
15674  FFC0              ;************************************************
***********************************;
15675  FFC0              ;
15676  FFC0              ; OPEN A LOGICAL FILE
15677  FFC0              
15678  FFC0              ; THIS ROUTINE IS USED TO OPEN A LOGICAL FILE. ON
CE THE LOGICAL FILE IS SET UP IT
15679  FFC0              ; CAN BE USED FOR INPUT/OUTPUT OPERATIONS. MOST O
F THE I/O KERNAL ROUTINES CALL ON
15680  FFC0              ; THIS ROUTINE TO CREATE THE LOGICAL FILES TO OPE
RATE ON. NO ARGUMENTS NEED TO BE
15681  FFC0              ; SET UP TO USE THIS ROUTINE, BUT BOTH THE SETLFS
, XXFFBA, AND SETNAM, XXFFBD,
15682  FFC0              ; KERNAL ROUTINES MUST BE CALLED BEFORE USING THI
S ROUTINE.
15683  FFC0              
15684  FFC0              XXFFC0 = *
15685  FFC0  6C 1A 03           JMP     (XX031A)          ; DO OPEN FILE V
ECTOR
15686  FFC3                     
15687  FFC3                     
15688  FFC3              ;************************************************
***********************************;
15689  FFC3              ;
15690  FFC3              ; CLOSE A SPECIFIED LOGICAL FILE
15691  FFC3              
15692  FFC3              ; THIS ROUTINE IS USED TO CLOSE A LOGICAL FILE AF
TER ALL I/O OPERATIONS HAVE BEEN
15693  FFC3              ; COMPLETED ON THAT FILE. THIS ROUTINE IS CALLED 
AFTER THE ACCUMULATOR IS LOADED
15694  FFC3              ; WITH THE LOGICAL FILE NUMBER TO BE CLOSED, THE 
SAME NUMBER USED WHEN THE FILE WAS
15695  FFC3              ; OPENED USING THE OPEN ROUTINE.
15696  FFC3              
15697  FFC3              XXFFC3 = *
15698  FFC3  6C 1C 03           JMP     (XX031C)          ; DO CLOSE FILE 
VECTOR
15699  FFC6                     
15700  FFC6                     
15701  FFC6              ;************************************************
************************************
15702  FFC6              ;
15703  FFC6              ; OPEN A CHANNEL FOR INPUT
15704  FFC6              
15705  FFC6              ; ANY LOGICAL FILE THAT HAS ALREADY BEEN OPENED B
Y THE OPEN ROUTINE, XXFFC0, CAN BE
15706  FFC6              ; DEFINED AS AN INPUT CHANNEL BY THIS ROUTINE. TH
E DEVICE ON THE CHANNEL MUST BE AN
15707  FFC6              ; INPUT DEVICE OR AN ERROR WILL OCCUR AND THE ROU
TINE WILL ABORT.
15708  FFC6              
15709  FFC6              ; IF YOU ARE GETTING DATA FROM ANYWHERE OTHER THA
N THE KEYBOARD, THIS ROUTINE MUST BE






ST BEE......PAGE 0302

LINE# LOC   CODE        LINE


15710  FFC6              ; CALLED BEFORE USING EITHER THE CHRIN ROUTINE, X
XFFCF, OR THE GETIN ROUTINE,
15711  FFC6              ; XXFFE4. IF YOU ARE GETTING DATA FROM THE KEYBOA
RD AND NO OTHER INPUT CHANNELS ARE
15712  FFC6              ; OPEN THEN THE CALLS TO THIS ROUTINE AND TO THE 
OPEN ROUTINE, XXFFC0, ARE NOT NEEDED.
15713  FFC6              
15714  FFC6              ; WHEN USED WITH A DEVICE ON THE SERIAL BUS THIS 
ROUTINE WILL AUTOMATICALLY SEND THE
15715  FFC6              ; LISTEN ADDRESS SPECIFIED BY THE OPEN ROUTINE, X
XFFC0, AND ANY SECONDARY ADDRESS.
15716  FFC6              
15717  FFC6              ; POSSIBLE ERRORS ARE:
15718  FFC6              ;
15719  FFC6              ;     3 : FILE NOT OPEN
15720  FFC6              ;     5 : DEVICE NOT PRESENT
15721  FFC6              ;     6 : FILE IS NOT AN INPUT FILE
15722  FFC6              
15723  FFC6              XXFFC6 = *
15724  FFC6  6C 1E 03           JMP     (XX031E)          ; DO OPEN FOR IN
PUT VECTOR
15725  FFC9                     
15726  FFC9                     
15727  FFC9              ;************************************************
************************************
15728  FFC9              ;
15729  FFC9              ; OPEN A CHANNEL FOR OUTPUT
15730  FFC9              
15731  FFC9              ; ANY LOGICAL FILE THAT HAS ALREADY BEEN OPENED B
Y THE OPEN ROUTINE, XXFFC0, CAN BE
15732  FFC9              ; DEFINED AS AN OUTPUT CHANNEL BY THIS ROUTINE TH
E DEVICE ON THE CHANNEL MUST BE AN
15733  FFC9              ; OUTPUT DEVICE OR AN ERROR WILL OCCUR AND THE RO
UTINE WILL ABORT.
15734  FFC9              
15735  FFC9              ; IF YOU ARE SENDING DATA TO ANYWHERE OTHER THAN 
THE SCREEN THIS ROUTINE MUST BE
15736  FFC9              ; CALLED BEFORE USING THE CHROUT ROUTINE, XXFFD2.
 IF YOU ARE SENDING DATA TO THE
15737  FFC9              ; SCREEN AND NO OTHER OUTPUT CHANNELS ARE OPEN TH
EN THE CALLS TO THIS ROUTINE AND TO
15738  FFC9              ; THE OPEN ROUTINE, XXFFC0, ARE NOT NEEDED.
15739  FFC9              
15740  FFC9              ; WHEN USED WITH A DEVICE ON THE SERIAL BUS THIS 
ROUTINE WILL AUTOMATICALLY SEND THE
15741  FFC9              ; LISTEN ADDRESS SPECIFIED BY THE OPEN ROUTINE, X
XFFC0, AND ANY SECONDARY ADDRESS.
15742  FFC9              
15743  FFC9              ; POSSIBLE ERRORS ARE:
15744  FFC9              ;
15745  FFC9              ;     3 : FILE NOT OPEN
15746  FFC9              ;     5 : DEVICE NOT PRESENT
15747  FFC9              ;     7 : FILE IS NOT AN OUTPUT FILE
15748  FFC9              
15749  FFC9              XXFFC9 = *
15750  FFC9  6C 20 03           JMP     (XX0320)          ; DO OPEN FOR OU
TPUT VECTOR
15751  FFCC                     
15752  FFCC                     
15753  FFCC              ;************************************************
************************************
15754  FFCC              ;
15755  FFCC              ; CLOSE INPUT AND OUTPUT CHANNELS
15756  FFCC              
15757  FFCC              ; THIS ROUTINE IS CALLED TO CLEAR ALL OPEN CHANNE
LS AND RESTORE THE I/O CHANNELS TO
15758  FFCC              ; THEIR ORIGINAL DEFAULT VALUES. IT IS USUALLY CA
LLED AFTER OPENING OTHER I/O
15759  FFCC              ; CHANNELS AND USING THEM FOR INPUT/OUTPUT OPERAT
IONS. THE DEFAULT INPUT DEVICE IS
15760  FFCC              ; 0, THE KEYBOARD. THE DEFAULT OUTPUT DEVICE IS 3
, THE SCREEN.
15761  FFCC              
15762  FFCC              ; IF ONE OF THE CHANNELS TO BE CLOSED IS TO THE S
ERIAL PORT, AN UNTALK SIGNAL IS SENT
15763  FFCC              ; FIRST TO CLEAR THE INPUT CHANNEL OR AN UNLISTEN
 IS SENT TO CLEAR THE OUTPUT CHANNEL.
15764  FFCC              ; BY NOT CALLING THIS ROUTINE AND LEAVING LISTENE
R(S) ACTIVE ON THE SERIAL BUS,






AY TO.......PAGE 0303

LINE# LOC   CODE        LINE


15765  FFCC              ; SEVERAL DEVICES CAN RECEIVE THE SAME DATA FROM 
THE VIC AT THE SAME TIME. ONE WAY TO
15766  FFCC              ; TAKE ADVANTAGE OF THIS WOULD BE TO COMMAND THE 
PRINTER TO TALK AND THE DISK TO
15767  FFCC              ; LISTEN. THIS WOULD ALLOW DIRECT PRINTING OF A D
ISK FILE.
15768  FFCC              
15769  FFCC              XXFFCC = *
15770  FFCC  6C 22 03           JMP     (XX0322)          ; DO CLOSE VECTO
R
15771  FFCF                     
15772  FFCF                     
15773  FFCF              ;************************************************
************************************
15774  FFCF              ;
15775  FFCF              ; INPUT CHARACTER FROM CHANNEL
15776  FFCF              
15777  FFCF              ; THIS ROUTINE WILL GET A BYTE OF DATA FROM THE C
HANNEL ALREADY SET UP AS THE INPUT
15778  FFCF              ; CHANNEL BY THE CHKIN ROUTINE, XXFFC6.
15779  FFCF              
15780  FFCF              ; IF CHKIN, XXFFC6, HAS NOT BEEN USED TO DEFINE A
NOTHER INPUT CHANNEL THE DATA IS
15781  FFCF              ; EXPECTED TO BE FROM THE KEYBOARD. THE DATA BYTE
 IS RETURNED IN THE ACCUMULATOR. THE
15782  FFCF              ; CHANNEL REMAINS OPEN AFTER THE CALL.
15783  FFCF              
15784  FFCF              ; INPUT FROM THE KEYBOARD IS HANDLED IN A SPECIAL
 WAY. FIRST, THE CURSOR IS TURNED ON
15785  FFCF              ; AND IT WILL BLINK UNTIL A CARRIAGE RETURN IS TY
PED ON THE KEYBOARD. ALL CHARACTERS
15786  FFCF              ; ON THE LOGICAL LINE, UP TO 88 CHARACTERS, WILL 
BE STORED IN THE BASIC INPUT BUFFER.
15787  FFCF              ; THEN THE CHARACTERS CAN BE RETURNED ONE AT A TI
ME BY CALLING THIS ROUTINE ONCE FOR
15788  FFCF              ; EACH CHARACTER. WHEN THE CARRIAGE RETURN IS RET
URNED THE ENTIRE LINE HAS BEEN
15789  FFCF              ; PROCESSED. THE NEXT TIME THIS ROUTINE IS CALLED
 THE WHOLE PROCESS BEGINS AGAIN.
15790  FFCF              
15791  FFCF              XXFFCF = *
15792  FFCF  6C 24 03           JMP     (XX0324)          ; DO INPUT VECTO
R
15793  FFD2                     
15794  FFD2                     
15795  FFD2              ;************************************************
************************************
15796  FFD2              ;
15797  FFD2              ; OUTPUT A CHARACTER TO CHANNEL
15798  FFD2              
15799  FFD2              ; THIS ROUTINE WILL OUTPUT A CHARACTER TO AN ALRE
ADY OPENED CHANNEL. USE THE OPEN
15800  FFD2              ; ROUTINE, XXFFC0, AND THE CHKOUT ROUTINE, XXFFC9
, TO SET UP THE OUTPUT CHANNEL
15801  FFD2              ; BEFORE CALLING THIS ROUTINE. IF THESE CALLS ARE
 OMITTED, DATA WILL BE SENT TO THE
15802  FFD2              ; DEFAULT OUTPUT DEVICE, DEVICE 3, THE SCREEN. TH
E DATA BYTE TO BE OUTPUT IS LOADED
15803  FFD2              ; INTO THE ACCUMULATOR, AND THIS ROUTINE IS CALLE
D. THE DATA IS THEN SENT TO THE
15804  FFD2              ; SPECIFIED OUTPUT DEVICE. THE CHANNEL IS LEFT OP
EN AFTER THE CALL.
15805  FFD2              
15806  FFD2              ; NOTE: CARE MUST BE TAKEN WHEN USING ROUTINE TO 
SEND DATA TO A SERIAL DEVICE SINCE
15807  FFD2              ; DATA WILL BE SENT TO ALL OPEN OUTPUT CHANNELS O
N THE BUS. UNLESS THIS IS DESIRED,
15808  FFD2              ; ALL OPEN OUTPUT CHANNELS ON THE SERIAL BUS OTHE
R THAN THE ACTUALLY INTENDED
15809  FFD2              ; DESTINATION CHANNEL MUST BE CLOSED BY A CALL TO
 THE KERNAL CLOSE CHANNEL ROUTINE.
15810  FFD2              
15811  FFD2              XXFFD2 = *
15812  FFD2  6C 26 03           JMP     (XX0326)          ; DO OUTPUT VECT
OR
15813  FFD5                     
15814  FFD5                     
15815  FFD5              ;************************************************
***********************************;
15816  FFD5              ;
15817  FFD5              ; LOAD RAM FROM A DEVICE
15818  FFD5              
15819  FFD5              ; THIS ROUTINE WILL LOAD DATA BYTES FROM ANY INPU
T DEVICE DIRECTLY INTO THE MEMORY






M A*;.......PAGE 0304

LINE# LOC   CODE        LINE


15820  FFD5              ; OF THE COMPUTER. IT CAN ALSO BE USED FOR A VERI
FY OPERATION COMPARING DATA FROM A
15821  FFD5              ; DEVICE WITH THE DATA ALREADY IN MEMORY, LEAVING
 THE DATA STORED IN RAM UNCHANGED.
15822  FFD5              
15823  FFD5              ; THE ACCUMULATOR MUST BE SET TO 0 FOR A LOAD OPE
RATION OR 1 FOR A VERIFY. IF THE
15824  FFD5              ; INPUT DEVICE WAS OPENED WITH A SECONDARY ADDRES
S OF 0 THE HEADER INFORMATION FROM
15825  FFD5              ; DEVICE WILL BE IGNORED. IN THIS CASE XY MUST CO
NTAIN THE STARTING ADDRESS FOR THE
15826  FFD5              ; LOAD. IF THE DEVICE WAS ADDRESSED WITH A SECOND
ARY ADDRESS OF 1 OR 2 THE DATA WILL
15827  FFD5              ; LOAD INTO MEMORY STARTING AT THE LOCATION SPECI
FIED BY THE HEADER. THIS ROUTINE
15828  FFD5              ; RETURNS THE ADDRESS OF THE HIGHEST RAM LOCATION
 WHICH WAS LOADED.
15829  FFD5              
15830  FFD5              ; BEFORE THIS ROUTINE CAN BE CALLED, THE SETLFS, 
XXFFBA, AND SETNAM, XXFFBD,
15831  FFD5              ; ROUTINES MUST BE CALLED.
15832  FFD5              
15833  FFD5              XXFFD5 = *
15834  FFD5  4C 42 F5           JMP     XXF542          ; LOAD RAM FROM A 
DEVICE
15835  FFD8                     
15836  FFD8                     
15837  FFD8              ;************************************************
***********************************;
15838  FFD8              ;
15839  FFD8              ; SAVE RAM TO A DEVICE
15840  FFD8              
15841  FFD8              ; THIS ROUTINE SAVES A SECTION OF MEMORY. MEMORY 
IS SAVED FROM AN INDIRECT ADDRESS
15842  FFD8              ; ON PAGE 0 SPECIFIED BY A, TO THE ADDRESS STORED
 IN XY, TO A LOGICAL FILE. THE
15843  FFD8              ; SETLFS, XXFFBA, AND SETNAM, XXFFBD, ROUTINES MU
ST BE USED BEFORE CALLING THIS
15844  FFD8              ; ROUTINE. HOWEVER, A FILE NAME IS NOT REQUIRED T
O SAVE TO DEVICE 1, THE CASSETTE.
15845  FFD8              ; ANY ATTEMPT TO SAVE TO OTHER DEVICES WITHOUT US
ING A FILE NAME RESULTS IN AN ERROR.
15846  FFD8              
15847  FFD8              ; NOTE: DEVICE 0, THE KEYBOARD, AND DEVICE 3, THE
 SCREEN, CANNOT BE SAVED TO. IF
15848  FFD8              ; THE ATTEMPT IS MADE, AN ERROR WILL OCCUR, AND T
HE SAVE STOPPED.
15849  FFD8              
15850  FFD8              XXFFD8 = *
15851  FFD8  4C 75 F6           JMP     XXF675          ; SAVE RAM TO DEVI
CE
15852  FFDB                     
15853  FFDB                     
15854  FFDB              ;************************************************
***********************************;
15855  FFDB              ;
15856  FFDB              ; SET THE REAL TIME CLOCK
15857  FFDB              
15858  FFDB              ; THE SYSTEM CLOCK IS MAINTAINED BY AN INTERRUPT 
ROUTINE THAT UPDATES THE CLOCK
15859  FFDB              ; EVERY 1/60TH OF A SECOND. THE CLOCK IS THREE BY
TES LONG WHICH GIVES THE CAPABILITY
15860  FFDB              ; TO COUNT FROM ZERO UP TO 5,184,000 JIFFIES - 24
 HOURS PLUS ONE JIFFY. AT THAT POINT
15861  FFDB              ; THE CLOCK RESETS TO ZERO. BEFORE CALLING THIS R
OUTINE TO SET THE CLOCK THE NEW TIME,
15862  FFDB              ; IN JIFFIES, SHOULD BE IN YXA, THE ACCUMULATOR C
ONTAINING THE MOST SIGNIFICANT BYTE.
15863  FFDB              
15864  FFDB              XXFFDB = *
15865  FFDB  4C 67 F7           JMP     XXF767          ; SET REAL TIME CL
OCK
15866  FFDE                     
15867  FFDE                     
15868  FFDE              ;************************************************
***********************************;
15869  FFDE              ;
15870  FFDE              ; READ THE REAL TIME CLOCK
15871  FFDE              
15872  FFDE              ; THIS ROUTINE RETURNS THE TIME, IN JIFFIES, IN A
XY. THE ACCUMULATOR CONTAINS THE
15873  FFDE              ; MOST SIGNIFICANT BYTE.
15874  FFDE              






E***;,......PAGE 0305

LINE# LOC   CODE        LINE


15875  FFDE              XXFFDE = *
15876  FFDE  4C 60 F7           JMP     XXF760          ; READ REAL TIME C
LOCK
15877  FFE1                     
15878  FFE1                     
15879  FFE1              ;************************************************
***********************************;
15880  FFE1              ;
15881  FFE1              ; SCAN THE STOP KEY
15882  FFE1              
15883  FFE1              ; IF THE STOP KEY ON THE KEYBOARD IS PRESSED WHEN
 THIS ROUTINE IS CALLED THE Z FLAG
15884  FFE1              ; WILL BE SET. ALL OTHER FLAGS REMAIN UNCHANGED. 
IF THE STOP KEY IS NOT PRESSED THEN
15885  FFE1              ; THE ACCUMULATOR WILL CONTAIN A BYTE REPRESENTIN
G THE LAST ROW OF THE KEYBOARD SCAN.
15886  FFE1              
15887  FFE1              ; THE USER CAN ALSO CHECK FOR CERTAIN OTHER KEYS 
THIS WAY.
15888  FFE1              
15889  FFE1              XXFFE1 = *
15890  FFE1  6C 28 03           JMP     (XX0328)          ; DO STOP KEY VE
CTOR
15891  FFE4                     
15892  FFE4                     
15893  FFE4              ;************************************************
***********************************;
15894  FFE4              ;
15895  FFE4              ; GET A CHARACTER FROM AN INPUT DEVICE
15896  FFE4              
15897  FFE4              ; IN PRACTICE THIS ROUTINE OPERATES IDENTICALLY T
O THE CHRIN ROUTINE, XXFFCF,
15898  FFE4              ; FOR ALL DEVICES EXCEPT FOR THE KEYBOARD. IF THE
 KEYBOARD IS THE CURRENT INPUT
15899  FFE4              ; DEVICE THIS ROUTINE WILL GET ONE CHARACTER FROM
 THE KEYBOARD BUFFER. IT DEPENDS
15900  FFE4              ; ON THE IRQ ROUTINE TO READ THE KEYBOARD AND PUT
 CHARACTERS INTO THE BUFFER.
15901  FFE4              
15902  FFE4              ; IF THE KEYBOARD BUFFER IS EMPTY THE VALUE RETUR
NED IN THE ACCUMULATOR WILL BE ZERO
15903  FFE4              
15904  FFE4              XXFFE4 = *
15905  FFE4  6C 2A 03           JMP     (XX032A)          ; DO GET VECTOR
15906  FFE7                     
15907  FFE7                     
15908  FFE7              ;************************************************
***********************************;
15909  FFE7              ;
15910  FFE7              ; CLOSE ALL CHANNELS AND FILES
15911  FFE7              
15912  FFE7              ; THIS ROUTINE CLOSES ALL OPEN FILES. WHEN THIS R
OUTINE IS CALLED, THE POINTERS INTO
15913  FFE7              ; THE OPEN FILE TABLE ARE RESET, CLOSING ALL FILE
S. ALSO THE ROUTINE AUTOMATICALLY
15914  FFE7              ; RESETS THE I/O CHANNELS.
15915  FFE7              
15916  FFE7              XXFFE7 = *
15917  FFE7  6C 2C 03           JMP     (XX032C)          ; DO CLOSE ALL V
ECTOR
15918  FFEA                     
15919  FFEA                     
15920  FFEA              ;************************************************
***********************************;
15921  FFEA              ;
15922  FFEA              ; INCREMENT THE REAL TIME CLOCK
15923  FFEA              
15924  FFEA              ; THIS ROUTINE UPDATES THE SYSTEM CLOCK. NORMALLY
 THIS ROUTINE IS CALLED BY THE
15925  FFEA              ; NORMAL KERNAL INTERRUPT ROUTINE EVERY 1/60TH OF
 A SECOND. IF THE USER PROGRAM
15926  FFEA              ; PROCESSES ITS OWN INTERRUPTS THIS ROUTINE MUST 
BE CALLED TO UPDATE THE TIME. ALSO,
15927  FFEA              ; THE STOP KEY ROUTINE MUST BE CALLED IF THE STOP
 KEY IS TO REMAIN FUNCTIONAL.
15928  FFEA              
15929  FFEA              XXFFEA = *






LSO,;,......PAGE 0306

LINE# LOC   CODE        LINE


15930  FFEA  4C 34 F7           JMP     XXF734          ; INCREMENT REAL T
IME CLOCK
15931  FFED                     
15932  FFED                     
15933  FFED              ;************************************************
***********************************;
15934  FFED              ;
15935  FFED              ; RETURN X,Y ORGANIZATION OF SCREEN
15936  FFED              
15937  FFED              ; THIS ROUTINE RETURNS THE X,Y ORGANISATION OF TH
E SCREEN IN X,Y
15938  FFED              
15939  FFED              ;XXFFED
15940  FFED  4C 05 E5           JMP     XXE505          ; RETURN X,Y ORGAN
IZATION OF SCREEN
15941  FFF0                     
15942  FFF0                     
15943  FFF0              ;************************************************
***********************************;
15944  FFF0              ;
15945  FFF0              ; READ/SET X,Y CURSOR POSITION
15946  FFF0              
15947  FFF0              ; THIS ROUTINE, WHEN CALLED WITH THE CARRY FLAG S
ET, LOADS THE CURRENT POSITION OF
15948  FFF0              ; THE CURSOR ON THE SCREEN INTO THE X AND Y REGIS
TERS. X IS THE COLUMN NUMBER OF
15949  FFF0              ; THE CURSOR LOCATION AND Y IS THE ROW NUMBER OF 
THE CURSOR. A CALL WITH THE CARRY
15950  FFF0              ; BIT CLEAR MOVES THE CURSOR TO THE POSITION DETE
RMINED BY THE X AND Y REGISTERS.
15951  FFF0              
15952  FFF0              XXFFF0 = *
15953  FFF0  4C 0A E5           JMP     XXE50A          ; READ/SET X,Y CUR
SOR POSITION
15954  FFF3                     
15955  FFF3                     
15956  FFF3              ;************************************************
***********************************;
15957  FFF3              ;
15958  FFF3              ; RETURN THE BASE ADDRESS OF THE I/O DEVICES
15959  FFF3              
15960  FFF3              ; THIS ROUTINE WILL SET XY TO THE ADDRESS OF THE 
MEMORY SECTION WHERE THE MEMORY
15961  FFF3              ; MAPPED I/O DEVICES ARE LOCATED. THIS ADDRESS CA
N THEN BE USED WITH AN OFFSET TO
15962  FFF3              ; ACCESS THE MEMORY MAPPED I/O DEVICES IN THE COM
PUTER.
15963  FFF3              
15964  FFF3              XXFFF3 = *
15965  FFF3  4C 00 E5           JMP     XXE500          ; RETURN BASE ADDR
ESS OF I/O DEVICES
15966  FFF6                     
15967  FFF6                     
15968  FFF6              ;************************************************
***********************************;
15969  FFF6              ;
15970  FFF6              ; SPARE BYTES, NOT REFERENCED
15971  FFF6              
15972  FFF6  FF                 .BYTE     $FF,$FF,$FF,$FF
15972  FFF7  FF 
15972  FFF8  FF 
15972  FFF9  FF 
15973  FFFA                     
15974  FFFA                     
15975  FFFA              ;************************************************
***********************************;
15976  FFFA              ;
15977  FFFA              ; HARDWARE VECTORS
15978  FFFA              
15979  FFFA  A9 FE              .WORD     XXFEA9          ; NMI VECTOR
15980  FFFC  22 FD              .WORD     XXFD22          ; RESET VECTOR
15981  FFFE  72 FF              .WORD     XXFF72          ; IRQ VECTOR






****;,......PAGE 0307

LINE# LOC   CODE        LINE


15982  0000                     
15983  0000                     .END


ERRORS = 00000


SYMBOL TABLE

SYMBOL VALUE
 TDATA    0083    TEQUAL   00B2    TFN      00A5    TFOR     0081
 TGO      00CB    TGOSUB   008D    TGOTO    0089    TGT      00B1
 TMINUS   00AB    TNOT     00A8    TPI      00FF    TPLUS    00AA
 TPRINT   0099    TREM     008F    TSGN     00B4    TSPC     00A6
 TSTEP    00A9    TTAB     00A3    TTHEN    00A7    TTO      00A4
 XX00     0000    XX0073   0073    XX0079   0079    XX008B   008B
 XX00FF   00FF    XX01     0001    XX0100   0100    XX01FC   01FC
 XX01FD   01FD    XX01FE   01FE    XX01FF   01FF    XX02     0002
 XX0200   0200    XX0201   0201    XX0259   0259    XX0263   0263
 XX026D   026D    XX0277   0277    XX0281   0281    XX0282   0282
 XX0283   0283    XX0284   0284    XX0285   0285    XX0286   0286
 XX0287   0287    XX0288   0288    XX0289   0289    XX028A   028A
 XX028B   028B    XX028C   028C    XX028D   028D    XX028E   028E
 XX028F   028F    XX0290   0290    XX0291   0291    XX0292   0292
 XX0293   0293    XX0294   0294    XX0297   0297    XX0298   0298
 XX0299   0299    XX029A   029A    XX029B   029B    XX029C   029C
 XX029D   029D    XX029E   029E    XX029F   029F    XX02A0   02A0
 XX03     0003    XX0300   0300    XX0302   0302    XX0304   0304
 XX0306   0306    XX0308   0308    XX030A   030A    XX030C   030C
 XX030D   030D    XX030E   030E    XX030F   030F    XX0314   0314
 XX0315   0315    XX0316   0316    XX0318   0318    XX031A   031A
 XX031C   031C    XX031E   031E    XX0320   0320    XX0322   0322
 XX0324   0324    XX0326   0326    XX0328   0328    XX032A   032A
 XX032C   032C    XX0330   0330    XX0332   0332    XX033C   033C
 XX04     0004    XX05     0005    XX06     0006    XX07     0007
 XX08     0008    XX09     0009    XX0A     000A    XX0B     000B
 XX0C     000C    XX0D     000D    XX0E     000E    XX0F     000F
 XX10     0010    XX11     0011    XX12     0012    XX13     0013
 XX14     0014    XX15     0015    XX16     0016    XX17     0017
 XX18     0018    XX19     0019    XX22     0022    XX23     0023
 XX24     0024    XX25     0025    XX26     0026    XX27     0027
 XX28     0028    XX29     0029    XX2B     002B    XX2C     002C
 XX2D     002D    XX2E     002E    XX2F     002F    XX30     0030
 XX31     0031    XX32     0032    XX33     0033    XX34     0034
 XX35     0035    XX36     0036    XX37     0037    XX38     0038
 XX39     0039    XX3A     003A    XX3B     003B    XX3C     003C
 XX3D     003D    XX3E     003E    XX3F     003F    XX40     0040
 XX41     0041    XX42     0042    XX43     0043    XX44     0044
 XX45     0045    XX46     0046    XX47     0047    XX48     0048
 XX49     0049    XX4A     004A    XX4B     004B    XX4C     004C
 XX4D     004D    XX4E     004E    XX4F     004F    XX50     0050
 XX51     0051    XX53     0053    XX54     0054    XX55     0055
 XX56     0056    XX57     0057    XX58     0058    XX59     0059
 XX5A     005A    XX5B     005B    XX5C     005C    XX5D     005D








SYMBOL TABLE

SYMBOL VALUE
 XX5E     005E    XX5F     005F    XX60     0060    XX61     0061
 XX62     0062    XX63     0063    XX64     0064    XX65     0065
 XX66     0066    XX67     0067    XX68     0068    XX69     0069
 XX6A     006A    XX6B     006B    XX6C     006C    XX6D     006D
 XX6E     006E    XX6F     006F    XX70     0070    XX71     0071
 XX72     0072    XX7A     007A    XX7B     007B    XX80     0080
 XX90     0090    XX9000   9000    XX9002   9002    XX9005   9005
 XX91     0091    XX9110   9110    XX9111   9111    XX9112   9112
 XX9113   9113    XX9114   9114    XX9115   9115    XX9118   9118
 XX9119   9119    XX911B   911B    XX911C   911C    XX911D   911D
 XX911E   911E    XX911F   911F    XX9120   9120    XX9121   9121
 XX9122   9122    XX9123   9123    XX9124   9124    XX9125   9125
 XX9128   9128    XX9129   9129    XX912B   912B    XX912C   912C
 XX912D   912D    XX912E   912E    XX912F   912F    XX92     0092
 XX93     0093    XX94     0094    XX95     0095    XX96     0096
 XX97     0097    XX98     0098    XX99     0099    XX9A     009A
 XX9B     009B    XX9C     009C    XX9D     009D    XX9E     009E
 XX9F     009F    XXA0     00A0    XXA000   A000    XXA002   A002
 XXA004   A004    XXA1     00A1    XXA2     00A2    XXA3     00A3
 XXA4     00A4    XXA5     00A5    XXA6     00A6    XXA7     00A7
 XXA8     00A8    XXA9     00A9    XXAA     00AA    XXAB     00AB
 XXAC     00AC    XXAD     00AD    XXAE     00AE    XXAF     00AF
 XXB0     00B0    XXB1     00B1    XXB2     00B2    XXB3     00B3
 XXB4     00B4    XXB5     00B5    XXB6     00B6    XXB7     00B7
 XXB8     00B8    XXB9     00B9    XXBA     00BA    XXBB     00BB
 XXBC     00BC    XXBD     00BD    XXBE     00BE    XXBF     00BF
 XXC0     00C0    XXC000   C000    XXC002   C002    XXC004   C004
 XXC00C   C00C    XXC052   C052    XXC080   C080    XXC09B   C09B
 XXC09E   C09E    XXC1     00C1    XXC19E   C19E    XXC1AC   C1AC
 XXC1B5   C1B5    XXC1C2   C1C2    XXC1D0   C1D0    XXC1E2   C1E2
 XXC1F0   C1F0    XXC1FF   C1FF    XXC2     00C2    XXC210   C210
 XXC225   C225    XXC235   C235    XXC23B   C23B    XXC24F   C24F
 XXC25A   C25A    XXC26A   C26A    XXC272   C272    XXC27F   C27F
 XXC290   C290    XXC29D   C29D    XXC2AA   C2AA    XXC2BA   C2BA
 XXC2C8   C2C8    XXC2D5   C2D5    XXC2E4   C2E4    XXC2ED   C2ED
 XXC3     00C3    XXC300   C300    XXC30E   C30E    XXC31E   C31E
 XXC324   C324    XXC328   C328    XXC364   C364    XXC369   C369
 XXC371   C371    XXC376   C376    XXC381   C381    XXC383   C383
 XXC38A   C38A    XXC38F   C38F    XXC3A4   C3A4    XXC3B0   C3B0
 XXC3B7   C3B7    XXC3B8   C3B8    XXC3BF   C3BF    XXC3DC   C3DC
 XXC3E8   C3E8    XXC3EC   C3EC    XXC3F3   C3F3    XXC3FB   C3FB
 XXC4     00C4    XXC408   C408    XXC412   C412    XXC416   C416
 XXC421   C421    XXC434   C434    XXC435   C435    XXC437   C437
 XXC43A   C43A    XXC456   C456    XXC469   C469    XXC474   C474
 XXC480   C480    XXC483   C483    XXC49C   C49C    XXC4D7   C4D7
 XXC4DF   C4DF    XXC4ED   C4ED    XXC5     00C5    XXC508   C508
 XXC522   C522    XXC52A   C52A    XXC533   C533    XXC53C   C53C
 XXC544   C544    XXC55F   C55F    XXC560   C560    XXC562   C562
 XXC576   C576    XXC579   C579    XXC57C   C57C    XXC582   C582
 XXC58E   C58E    XXC5A4   C5A4    XXC5AC   C5AC    XXC5B6   C5B6
 XXC5B8   C5B8    XXC5C7   C5C7    XXC5C9   C5C9    XXC5DC   C5DC
 XXC5DE   C5DE    XXC5E5   C5E5    XXC5EE   C5EE    XXC5F5   C5F5
 XXC5F9   C5F9    XXC6     00C6    XXC609   C609    XXC613   C613
 XXC617   C617    XXC62E   C62E    XXC637   C637    XXC640   C640
 XXC641   C641    XXC642   C642    XXC644   C644    XXC659   C659








SYMBOL TABLE

SYMBOL VALUE
 XXC65E   C65E    XXC660   C660    XXC663   C663    XXC677   C677
 XXC67A   C67A    XXC68D   C68D    XXC68E   C68E    XXC69C   C69C
 XXC6A4   C6A4    XXC6BB   C6BB    XXC6C9   C6C9    XXC6E6   C6E6
 XXC6E8   C6E8    XXC6EF   C6EF    XXC6F3   C6F3    XXC7     00C7
 XXC700   C700    XXC714   C714    XXC717   C717    XXC71A   C71A
 XXC72C   C72C    XXC72F   C72F    XXC737   C737    XXC742   C742
 XXC753   C753    XXC78B   C78B    XXC79F   C79F    XXC7AE   C7AE
 XXC7BE   C7BE    XXC7CE   C7CE    XXC7E1   C7E1    XXC7E4   C7E4
 XXC7ED   C7ED    XXC7EF   C7EF    XXC8     00C8    XXC804   C804
 XXC807   C807    XXC80B   C80B    XXC80E   C80E    XXC81D   C81D
 XXC827   C827    XXC82B   C82B    XXC82C   C82C    XXC82F   C82F
 XXC831   C831    XXC832   C832    XXC849   C849    XXC84B   C84B
 XXC854   C854    XXC857   C857    XXC862   C862    XXC870   C870
 XXC871   C871    XXC87D   C87D    XXC883   C883    XXC897   C897
 XXC8A0   C8A0    XXC8BC   C8BC    XXC8C0   C8C0    XXC8D1   C8D1
 XXC8D2   C8D2    XXC8E3   C8E3    XXC8E8   C8E8    XXC8EB   C8EB
 XXC8F8   C8F8    XXC8FB   C8FB    XXC9     00C9    XXC905   C905
 XXC906   C906    XXC909   C909    XXC911   C911    XXC919   C919
 XXC928   C928    XXC937   C937    XXC93B   C93B    XXC940   C940
 XXC948   C948    XXC94B   C94B    XXC953   C953    XXC957   C957
 XXC95F   C95F    XXC96A   C96A    XXC96B   C96B    XXC971   C971
 XXC99F   C99F    XXC9A5   C9A5    XXC9C2   C9C2    XXC9D6   C9D6
 XXC9D9   C9D9    XXC9DA   C9DA    XXC9ED   C9ED    XXCA     00CA
 XXCA07   CA07    XXCA1D   CA1D    XXCA24   CA24    XXCA27   CA27
 XXCA2C   CA2C    XXCA3D   CA3D    XXCA4B   CA4B    XXCA52   CA52
 XXCA68   CA68    XXCA80   CA80    XXCA86   CA86    XXCA90   CA90
 XXCA9A   CA9A    XXCA9D   CA9D    XXCAA0   CAA0    XXCAA2   CAA2
 XXCACA   CACA    XXCAD7   CAD7    XXCAE5   CAE5    XXCAE7   CAE7
 XXCAE8   CAE8    XXCAEE   CAEE    XXCAF8   CAF8    XXCB     00CB
 XXCB0E   CB0E    XXCB0F   CB0F    XXCB10   CB10    XXCB13   CB13
 XXCB19   CB19    XXCB1E   CB1E    XXCB21   CB21    XXCB28   CB28
 XXCB3B   CB3B    XXCB42   CB42    XXCB45   CB45    XXCB47   CB47
 XXCB4D   CB4D    XXCB57   CB57    XXCB5B   CB5B    XXCB5F   CB5F
 XXCB62   CB62    XXCB6B   CB6B    XXCB7B   CB7B    XXCB92   CB92
 XXCBA5   CBA5    XXCBB5   CBB5    XXCBB7   CBB7    XXCBBF   CBBF
 XXCBCE   CBCE    XXCBD6   CBD6    XXCBEA   CBEA    XXCBF9   CBF9
 XXCC     00CC    XXCC03   CC03    XXCC06   CC06    XXCC0D   CC0D
 XXCC0F   CC0F    XXCC15   CC15    XXCC41   CC41    XXCC4A   CC4A
 XXCC4D   CC4D    XXCC51   CC51    XXCC65   CC65    XXCC71   CC71
 XXCC72   CC72    XXCC7D   CC7D    XXCC89   CC89    XXCC91   CC91
 XXCC9D   CC9D    XXCCB8   CCB8    XXCCD1   CCD1    XXCCDF   CCDF
 XXCCEA   CCEA    XXCCFB   CCFB    XXCCFC   CCFC    XXCD     00CD
 XXCD0C   CD0C    XXCD1E   CD1E    XXCD24   CD24    XXCD27   CD27
 XXCD32   CD32    XXCD35   CD35    XXCD75   CD75    XXCD78   CD78
 XXCD8A   CD8A    XXCD8D   CD8D    XXCD8F   CD8F    XXCD90   CD90
 XXCD96   CD96    XXCD97   CD97    XXCD99   CD99    XXCD9E   CD9E
 XXCDA4   CDA4    XXCDA9   CDA9    XXCDB8   CDB8    XXCDBB   CDBB
 XXCDD7   CDD7    XXCDE8   CDE8    XXCDF0   CDF0    XXCDF9   CDF9
 XXCDFA   CDFA    XXCE     00CE    XXCE07   CE07    XXCE11   CE11
 XXCE19   CE19    XXCE20   CE20    XXCE30   CE30    XXCE33   CE33
 XXCE38   CE38    XXCE43   CE43    XXCE58   CE58    XXCE5B   CE5B
 XXCE5D   CE5D    XXCE64   CE64    XXCE66   CE66    XXCE80   CE80
 XXCE83   CE83    XXCE86   CE86    XXCE8A   CE8A    XXCE8F   CE8F
 XXCE92   CE92    XXCE9A   CE9A    XXCEA8   CEA8    XXCEAD   CEAD
 XXCEBD   CEBD    XXCEC6   CEC6    XXCECC   CECC    XXCED4   CED4








SYMBOL TABLE

SYMBOL VALUE
 XXCEE3   CEE3    XXCEEA   CEEA    XXCEF1   CEF1    XXCEF7   CEF7
 XXCEFA   CEFA    XXCEFD   CEFD    XXCEFF   CEFF    XXCF     00CF
 XXCF08   CF08    XXCF0D   CF0D    XXCF0F   CF0F    XXCF14   CF14
 XXCF27   CF27    XXCF28   CF28    XXCF5C   CF5C    XXCF5D   CF5D
 XXCF6E   CF6E    XXCF84   CF84    XXCF92   CF92    XXCFA0   CFA0
 XXCFA7   CFA7    XXCFD1   CFD1    XXCFD6   CFD6    XXCFE6   CFE6
 XXCFE9   CFE9    XXD0     00D0    XXD016   D016    XXD02E   D02E
 XXD056   D056    XXD05B   D05B    XXD061   D061    XXD066   D066
 XXD072   D072    XXD07B   D07B    XXD07E   D07E    XXD081   D081
 XXD08B   D08B    XXD090   D090    XXD092   D092    XXD09C   D09C
 XXD09F   D09F    XXD0AF   D0AF    XXD0B0   D0B0    XXD0BA   D0BA
 XXD0C4   D0C4    XXD0D4   D0D4    XXD0DB   D0DB    XXD0E7   D0E7
 XXD0EF   D0EF    XXD0F1   D0F1    XXD0FB   D0FB    XXD1     00D1
 XXD109   D109    XXD113   D113    XXD11C   D11C    XXD11D   D11D
 XXD123   D123    XXD128   D128    XXD138   D138    XXD13B   D13B
 XXD143   D143    XXD159   D159    XXD185   D185    XXD18F   D18F
 XXD194   D194    XXD1A0   D1A0    XXD1A5   D1A5    XXD1AA   D1AA
 XXD1B2   D1B2    XXD1B8   D1B8    XXD1BF   D1BF    XXD1CC   D1CC
 XXD1CE   D1CE    XXD1D1   D1D1    XXD1DB   D1DB    XXD2     00D2
 XXD21C   D21C    XXD228   D228    XXD237   D237    XXD245   D245
 XXD248   D248    XXD24A   D24A    XXD24D   D24D    XXD261   D261
 XXD274   D274    XXD27D   D27D    XXD286   D286    XXD296   D296
 XXD2B9   D2B9    XXD2C8   D2C8    XXD2CD   D2CD    XXD2EA   D2EA
 XXD2F2   D2F2    XXD3     00D3    XXD308   D308    XXD30B   D30B
 XXD30E   D30E    XXD30F   D30F    XXD320   D320    XXD331   D331
 XXD337   D337    XXD34B   D34B    XXD34C   D34C    XXD355   D355
 XXD35F   D35F    XXD378   D378    XXD37D   D37D    XXD384   D384
 XXD391   D391    XXD39E   D39E    XXD3A2   D3A2    XXD3A6   D3A6
 XXD3AE   D3AE    XXD3B3   D3B3    XXD3E1   D3E1    XXD3F4   D3F4
 XXD4     00D4    XXD418   D418    XXD449   D449    XXD44F   D44F
 XXD465   D465    XXD46F   D46F    XXD475   D475    XXD47D   D47D
 XXD487   D487    XXD48D   D48D    XXD497   D497    XXD4A4   D4A4
 XXD4A8   D4A8    XXD4A9   D4A9    XXD4B5   D4B5    XXD4BF   D4BF
 XXD4CA   D4CA    XXD4D2   D4D2    XXD4D5   D4D5    XXD4F4   D4F4
 XXD4F6   D4F6    XXD5     00D5    XXD501   D501    XXD50B   D50B
 XXD516   D516    XXD526   D526    XXD52A   D52A    XXD544   D544
 XXD54D   D54D    XXD559   D559    XXD561   D561    XXD566   D566
 XXD56E   D56E    XXD572   D572    XXD57D   D57D    XXD5AE   D5AE
 XXD5B0   D5B0    XXD5B8   D5B8    XXD5BD   D5BD    XXD5C7   D5C7
 XXD5DC   D5DC    XXD5E6   D5E6    XXD5F6   D5F6    XXD6     00D6
 XXD601   D601    XXD606   D606    XXD63D   D63D    XXD65D   D65D
 XXD67A   D67A    XXD688   D688    XXD68C   D68C    XXD690   D690
 XXD699   D699    XXD6A2   D6A2    XXD6A3   D6A3    XXD6A6   D6A6
 XXD6AA   D6AA    XXD6D5   D6D5    XXD6D6   D6D6    XXD6DB   D6DB
 XXD6EB   D6EB    XXD6EC   D6EC    XXD7     00D7    XXD700   D700
 XXD706   D706    XXD70C   D70C    XXD70D   D70D    XXD70E   D70E
 XXD725   D725    XXD72C   D72C    XXD737   D737    XXD748   D748
 XXD761   D761    XXD77C   D77C    XXD782   D782    XXD78B   D78B
 XXD798   D798    XXD79B   D79B    XXD79E   D79E    XXD7A1   D7A1
 XXD7AD   D7AD    XXD7B5   D7B5    XXD7CD   D7CD    XXD7E2   D7E2
 XXD7EB   D7EB    XXD7F1   D7F1    XXD7F7   D7F7    XXD8     00D8
 XXD80D   D80D    XXD824   D824    XXD82D   D82D    XXD83C   D83C
 XXD840   D840    XXD848   D848    XXD849   D849    XXD850   D850
 XXD853   D853    XXD862   D862    XXD867   D867    XXD86A   D86A
 XXD86F   D86F    XXD877   D877    XXD893   D893    XXD897   D897








SYMBOL TABLE

SYMBOL VALUE
 XXD8A3   D8A3    XXD8AF   D8AF    XXD8D2   D8D2    XXD8D7   D8D7
 XXD8DB   D8DB    XXD8F7   D8F7    XXD8F9   D8F9    XXD8FB   D8FB
 XXD8FE   D8FE    XXD9     00D9    XXD91D   D91D    XXD929   D929
 XXD936   D936    XXD938   D938    XXD946   D946    XXD947   D947
 XXD94D   D94D    XXD96F   D96F    XXD97D   D97D    XXD97E   D97E
 XXD983   D983    XXD985   D985    XXD999   D999    XXD9A6   D9A6
 XXD9AC   D9AC    XXD9B0   D9B0    XXD9BA   D9BA    XXD9BC   D9BC
 XXD9C1   D9C1    XXD9D6   D9D6    XXD9DB   D9DB    XXD9E0   D9E0
 XXD9E5   D9E5    XXD9EA   D9EA    XXD9F1   D9F1    XXD9F4   D9F4
 XXDA28   DA28    XXDA2B   DA2B    XXDA30   DA30    XXDA59   DA59
 XXDA5E   DA5E    XXDA61   DA61    XXDA7D   DA7D    XXDA8B   DA8B
 XXDA8C   DA8C    XXDAB7   DAB7    XXDAB9   DAB9    XXDAC4   DAC4
 XXDACF   DACF    XXDAD4   DAD4    XXDADA   DADA    XXDADF   DADF
 XXDAE2   DAE2    XXDAED   DAED    XXDAF8   DAF8    XXDAF9   DAF9
 XXDAFE   DAFE    XXDB07   DB07    XXDB0F   DB0F    XXDB12   DB12
 XXDB29   DB29    XXDB3F   DB3F    XXDB4C   DB4C    XXDB4F   DB4F
 XXDB5D   DB5D    XXDB7A   DB7A    XXDB7E   DB7E    XXDB8A   DB8A
 XXDB8F   DB8F    XXDBA2   DBA2    XXDBC7   DBC7    XXDBCA   DBCA
 XXDBD0   DBD0    XXDBD4   DBD4    XXDBFC   DBFC    XXDBFE   DBFE
 XXDC02   DC02    XXDC0C   DC0C    XXDC0F   DC0F    XXDC11   DC11
 XXDC1A   DC1A    XXDC1B   DC1B    XXDC23   DC23    XXDC2B   DC2B
 XXDC2F   DC2F    XXDC31   DC31    XXDC38   DC38    XXDC39   DC39
 XXDC3C   DC3C    XXDC44   DC44    XXDC49   DC49    XXDC4F   DC4F
 XXDC58   DC58    XXDC5B   DC5B    XXDC5D   DC5D    XXDC92   DC92
 XXDC98   DC98    XXDC9B   DC9B    XXDCAF   DCAF    XXDCBA   DCBA
 XXDCBB   DCBB    XXDCCC   DCCC    XXDCE9   DCE9    XXDCF2   DCF2
 XXDCF3   DCF3    XXDCF7   DCF7    XXDD06   DD06    XXDD0A   DD0A
 XXDD0D   DD0D    XXDD0F   DD0F    XXDD2E   DD2E    XXDD30   DD30
 XXDD33   DD33    XXDD35   DD35    XXDD41   DD41    XXDD47   DD47
 XXDD49   DD49    XXDD52   DD52    XXDD5B   DD5B    XXDD62   DD62
 XXDD67   DD67    XXDD6A   DD6A    XXDD71   DD71    XXDD7E   DD7E
 XXDD91   DD91    XXDDA0   DDA0    XXDDAE   DDAE    XXDDB3   DDB3
 XXDDB8   DDB8    XXDDBD   DDBD    XXDDC2   DDC2    XXDDCD   DDCD
 XXDDDA   DDDA    XXDDDD   DDDD    XXDDDF   DDDF    XXDDE7   DDE7
 XXDDF8   DDF8    XXDE00   DE00    XXDE09   DE09    XXDE0B   DE0B
 XXDE16   DE16    XXDE21   DE21    XXDE28   DE28    XXDE2F   DE2F
 XXDE32   DE32    XXDE47   DE47    XXDE48   DE48    XXDE53   DE53
 XXDE64   DE64    XXDE66   DE66    XXDE68   DE68    XXDE6A   DE6A
 XXDE8E   DE8E    XXDE90   DE90    XXDE97   DE97    XXDEB2   DEB2
 XXDEC4   DEC4    XXDEC6   DEC6    XXDED3   DED3    XXDEE3   DEE3
 XXDEEF   DEEF    XXDF04   DF04    XXDF07   DF07    XXDF0C   DF0C
 XXDF11   DF11    XXDF13   DF13    XXDF16   DF16    XXDF3A   DF3A
 XXDF52   DF52    XXDF71   DF71    XXDF7B   DF7B    XXDF84   DF84
 XXDF9E   DF9E    XXDFB4   DFB4    XXDFBE   DFBE    XXDFBF   DFBF
 XXDFC4   DFC4    XXDFED   DFED    XXDFFD   DFFD    XXE008   E008
 XXE00B   E00B    XXE01B   E01B    XXE040   E040    XXE056   E056
 XXE05A   E05A    XXE069   E069    XXE06D   E06D    XXE07A   E07A
 XXE08A   E08A    XXE08F   E08F    XXE094   E094    XXE0BB   E0BB
 XXE0D0   E0D0    XXE0E0   E0E0    XXE0F3   E0F3    XXE0F6   E0F6
 XXE101   E101    XXE106   E106    XXE109   E109    XXE10F   E10F
 XXE115   E115    XXE11B   E11B    XXE121   E121    XXE127   E127
 XXE143   E143    XXE153   E153    XXE162   E162    XXE165   E165
 XXE187   E187    XXE194   E194    XXE195   E195    XXE1A1   E1A1
 XXE1B5   E1B5    XXE1BB   E1BB    XXE1C4   E1C4    XXE1CE   E1CE
 XXE1D1   E1D1    XXE1FD   E1FD    XXE203   E203    XXE20A   E20A








SYMBOL TABLE

SYMBOL VALUE
 XXE20B   E20B    XXE20E   E20E    XXE216   E216    XXE23C   E23C
 XXE254   E254    XXE261   E261    XXE268   E268    XXE29A   E29A
 XXE29D   E29D    XXE2AA   E2AA    XXE2B1   E2B1    XXE2D9   E2D9
 XXE2DD   E2DD    XXE2E2   E2E2    XXE2E7   E2E7    XXE2EC   E2EC
 XXE30B   E30B    XXE313   E313    XXE321   E321    XXE334   E334
 XXE33A   E33A    XXE33B   E33B    XXE378   E378    XXE387   E387
 XXE38D   E38D    XXE39E   E39E    XXE3A4   E3A4    XXE3C4   E3C4
 XXE403   E403    XXE404   E404    XXE429   E429    XXE436   E436
 XXE44F   E44F    XXE45B   E45B    XXE45D   E45D    XXE467   E467
 XXE476   E476    XXE4A0   E4A0    XXE4A9   E4A9    XXE4B2   E4B2
 XXE4BC   E4BC    XXE4C1   E4C1    XXE4CC   E4CC    XXE4CF   E4CF
 XXE4D7   E4D7    XXE500   E500    XXE505   E505    XXE50A   E50A
 XXE513   E513    XXE518   E518    XXE536   E536    XXE55F   E55F
 XXE568   E568    XXE570   E570    XXE57B   E57B    XXE581   E581
 XXE587   E587    XXE58B   E58B    XXE597   E597    XXE5A8   E5A8
 XXE5B2   E5B2    XXE5BB   E5BB    XXE5C3   E5C3    XXE5C5   E5C5
 XXE5CF   E5CF    XXE5D4   E5D4    XXE5E5   E5E5    XXE5E8   E5E8
 XXE602   E602    XXE60E   E60E    XXE619   E619    XXE621   E621
 XXE62A   E62A    XXE64F   E64F    XXE657   E657    XXE67E   E67E
 XXE684   E684    XXE688   E688    XXE691   E691    XXE6A3   E6A3
 XXE6A6   E6A6    XXE6A8   E6A8    XXE6B6   E6B6    XXE6B8   E6B8
 XXE6C4   E6C4    XXE6C5   E6C5    XXE6C7   E6C7    XXE6CB   E6CB
 XXE6CD   E6CD    XXE6D3   E6D3    XXE6DC   E6DC    XXE6E4   E6E4
 XXE6EA   E6EA    XXE701   E701    XXE70E   E70E    XXE715   E715
 XXE719   E719    XXE720   E720    XXE723   E723    XXE72C   E72C
 XXE72D   E72D    XXE737   E737    XXE742   E742    XXE756   E756
 XXE75D   E75D    XXE769   E769    XXE76B   E76B    XXE771   E771
 XXE778   E778    XXE785   E785    XXE78E   E78E    XXE79F   E79F
 XXE7AA   E7AA    XXE7B1   E7B1    XXE7B7   E7B7    XXE7BE   E7BE
 XXE7D4   E7D4    XXE7D6   E7D6    XXE7D9   E7D9    XXE7EC   E7EC
 XXE7F4   E7F4    XXE7F7   E7F7    XXE7FA   E7FA    XXE800   E800
 XXE81D   E81D    XXE82A   E82A    XXE831   E831    XXE845   E845
 XXE84C   E84C    XXE851   E851    XXE86D   E86D    XXE870   E870
 XXE874   E874    XXE879   E879    XXE88E   E88E    XXE893   E893
 XXE89B   E89B    XXE8AB   E8AB    XXE8B1   E8B1    XXE8B8   E8B8
 XXE8BB   E8BB    XXE8C3   E8C3    XXE8C7   E8C7    XXE8CF   E8CF
 XXE8D8   E8D8    XXE8E8   E8E8    XXE8EC   E8EC    XXE8F7   E8F7
 XXE8FA   E8FA    XXE8FE   E8FE    XXE909   E909    XXE911   E911
 XXE912   E912    XXE914   E914    XXE91D   E91D    XXE921   E921
 XXE928   E928    XXE975   E975    XXE981   E981    XXE989   E989
 XXE99D   E99D    XXE9A2   E9A2    XXE9AC   E9AC    XXE9D6   E9D6
 XXE9DF   E9DF    XXE9EE   E9EE    XXE9F0   E9F0    XXEA08   EA08
 XXEA16   EA16    XXEA2C   EA2C    XXEA31   EA31    XXEA3F   EA3F
 XXEA44   EA44    XXEA56   EA56    XXEA60   EA60    XXEA62   EA62
 XXEA6E   EA6E    XXEA7E   EA7E    XXEA8D   EA8D    XXEA95   EA95
 XXEAA1   EAA1    XXEAAA   EAAA    XXEAB2   EAB2    XXEABF   EABF
 XXEAEA   EAEA    XXEAEF   EAEF    XXEB01   EB01    XXEB0A   EB0A
 XXEB12   EB12    XXEB1E   EB1E    XXEB40   EB40    XXEB4A   EB4A
 XXEB60   EB60    XXEB62   EB62    XXEB63   EB63    XXEB71   EB71
 XXEB74   EB74    XXEB84   EB84    XXEB8F   EB8F    XXEBA1   EBA1
 XXEBAB   EBAB    XXEBBA   EBBA    XXEBD6   EBD6    XXEBDC   EBDC
 XXEC0F   EC0F    XXEC18   EC18    XXEC43   EC43    XXEC46   EC46
 XXEC5E   EC5E    XXEC9F   EC9F    XXECE0   ECE0    XXED21   ED21
 XXED30   ED30    XXED3C   ED3C    XXED3F   ED3F    XXED4D   ED4D
 XXED5B   ED5B    XXED69   ED69    XXEDA3   EDA3    XXEDE4   EDE4








SYMBOL TABLE

SYMBOL VALUE
 XXEDF4   EDF4    XXEDFD   EDFD    XXEE14   EE14    XXEE17   EE17
 XXEE1C   EE1C    XXEE2B   EE2B    XXEE38   EE38    XXEE40   EE40
 XXEE49   EE49    XXEE5A   EE5A    XXEE60   EE60    XXEE66   EE66
 XXEE73   EE73    XXEE88   EE88    XXEE8B   EE8B    XXEEA5   EEA5
 XXEEB4   EEB4    XXEEB7   EEB7    XXEEB9   EEB9    XXEEC0   EEC0
 XXEEC5   EEC5    XXEECE   EECE    XXEED3   EED3    XXEEDD   EEDD
 XXEEE4   EEE4    XXEEED   EEED    XXEEF2   EEF2    XXEEF6   EEF6
 XXEF04   EF04    XXEF09   EF09    XXEF0C   EF0C    XXEF0F   EF0F
 XXEF19   EF19    XXEF21   EF21    XXEF29   EF29    XXEF2E   EF2E
 XXEF3C   EF3C    XXEF45   EF45    XXEF54   EF54    XXEF58   EF58
 XXEF66   EF66    XXEF7F   EF7F    XXEF84   EF84    XXEF8D   EF8D
 XXEF96   EF96    XXEF9B   EF9B    XXEFA3   EFA3    XXEFB0   EFB0
 XXEFB9   EFB9    XXEFBF   EFBF    XXEFCE   EFCE    XXEFCF   EFCF
 XXEFDA   EFDA    XXEFDE   EFDE    XXEFE4   EFE4    XXEFE8   EFE8
 XXEFEE   EFEE    XXEFFB   EFFB    XXF016   F016    XXF019   F019
 XXF021   F021    XXF027   F027    XXF031   F031    XXF035   F035
 XXF036   F036    XXF04A   F04A    XXF04B   F04B    XXF04D   F04D
 XXF05B   F05B    XXF068   F068    XXF06F   F06F    XXF081   F081
 XXF089   F089    XXF09D   F09D    XXF0A2   F0A2    XXF0A5   F0A5
 XXF0A8   F0A8    XXF0B3   F0B3    XXF0B9   F0B9    XXF0BC   F0BC
 XXF0CD   F0CD    XXF0D4   F0D4    XXF0E1   F0E1    XXF0E8   F0E8
 XXF0EB   F0EB    XXF0ED   F0ED    XXF102   F102    XXF116   F116
 XXF12B   F12B    XXF138   F138    XXF13F   F13F    XXF144   F144
 XXF146   F146    XXF14F   F14F    XXF15D   F15D    XXF160   F160
 XXF166   F166    XXF172   F172    XXF174   F174    XXF180   F180
 XXF18B   F18B    XXF18F   F18F    XXF1A2   F1A2    XXF1BD   F1BD
 XXF1C5   F1C5    XXF1CD   F1CD    XXF1D7   F1D7    XXF1DE   F1DE
 XXF1E2   F1E2    XXF1E6   F1E6    XXF1F3   F1F3    XXF1F5   F1F5
 XXF2     00F2    XXF201   F201    XXF205   F205    XXF20E   F20E
 XXF21D   F21D    XXF22A   F22A    XXF244   F244    XXF24A   F24A
 XXF24D   F24D    XXF250   F250    XXF260   F260    XXF264   F264
 XXF26A   F26A    XXF26B   F26B    XXF26C   F26C    XXF26F   F26F
 XXF279   F279    XXF27A   F27A    XXF285   F285    XXF28B   F28B
 XXF290   F290    XXF2AA   F2AA    XXF2AF   F2AF    XXF2B8   F2B8
 XXF2B9   F2B9    XXF2C7   F2C7    XXF2CF   F2CF    XXF2E3   F2E3
 XXF2EC   F2EC    XXF2F0   F2F0    XXF2FE   F2FE    XXF3     00F3
 XXF301   F301    XXF309   F309    XXF311   F311    XXF318   F318
 XXF31B   F31B    XXF328   F328    XXF32E   F32E    XXF332   F332
 XXF33F   F33F    XXF342   F342    XXF34A   F34A    XXF351   F351
 XXF37F   F37F    XXF384   F384    XXF38D   F38D    XXF39E   F39E
 XXF3AE   F3AE    XXF3B1   F3B1    XXF3B2   F3B2    XXF3CD   F3CD
 XXF3CE   F3CE    XXF3CF   F3CF    XXF3D4   F3D4    XXF3D6   F3D6
 XXF3DF   F3DF    XXF3EE   F3EE    XXF3EF   F3EF    XXF3F3   F3F3
 XXF3FC   F3FC    XXF4     00F4    XXF403   F403    XXF40A   F40A
 XXF411   F411    XXF419   F419    XXF422   F422    XXF444   F444
 XXF44B   F44B    XXF453   F453    XXF46C   F46C    XXF46F   F46F
 XXF478   F478    XXF482   F482    XXF491   F491    XXF493   F493
 XXF494   F494    XXF495   F495    XXF4B2   F4B2    XXF4B8   F4B8
 XXF4C2   F4C2    XXF4C5   F4C5    XXF4C7   F4C7    XXF4D9   F4D9
 XXF4E7   F4E7    XXF4F4   F4F4    XXF5     00F5    XXF51B   F51B
 XXF533   F533    XXF53C   F53C    XXF542   F542    XXF549   F549
 XXF553   F553    XXF556   F556    XXF563   F563    XXF58A   F58A
 XXF598   F598    XXF5B3   F5B3    XXF5B5   F5B5    XXF5BB   F5BB
 XXF5C7   F5C7    XXF5CA   F5CA    XXF5D1   F5D1    XXF5D9   F5D9
 XXF5E1   F5E1    XXF5EE   F5EE    XXF5F5   F5F5    XXF6     00F6








SYMBOL TABLE

SYMBOL VALUE
 XXF604   F604    XXF611   F611    XXF615   F615    XXF641   F641
 XXF646   F646    XXF647   F647    XXF659   F659    XXF65F   F65F
 XXF669   F669    XXF66A   F66A    XXF672   F672    XXF675   F675
 XXF685   F685    XXF689   F689    XXF68C   F68C    XXF69D   F69D
 XXF6BC   F6BC    XXF6CB   F6CB    XXF6D2   F6D2    XXF6D7   F6D7
 XXF6DA   F6DA    XXF6EF   F6EF    XXF6F1   F6F1    XXF6F8   F6F8
 XXF7     00F7    XXF70F   F70F    XXF726   F726    XXF727   F727
 XXF728   F728    XXF734   F734    XXF740   F740    XXF755   F755
 XXF760   F760    XXF767   F767    XXF770   F770    XXF77D   F77D
 XXF77E   F77E    XXF781   F781    XXF784   F784    XXF787   F787
 XXF78A   F78A    XXF78D   F78D    XXF790   F790    XXF793   F793
 XXF796   F796    XXF7AC   F7AC    XXF7AF   F7AF    XXF7CE   F7CE
 XXF7DA   F7DA    XXF7E4   F7E4    XXF7E6   F7E6    XXF7E7   F7E7
 XXF7FE   F7FE    XXF8     00F8    XXF822   F822    XXF834   F834
 XXF84C   F84C    XXF84D   F84D    XXF854   F854    XXF867   F867
 XXF874   F874    XXF888   F888    XXF889   F889    XXF88A   F88A
 XXF894   F894    XXF89B   F89B    XXF89E   F89E    XXF8AB   F8AB
 XXF8B5   F8B5    XXF8B7   F8B7    XXF8C0   F8C0    XXF8C9   F8C9
 XXF8E3   F8E3    XXF8E6   F8E6    XXF8EA   F8EA    XXF8ED   F8ED
 XXF8F4   F8F4    XXF9     00F9    XXF923   F923    XXF925   F925
 XXF92F   F92F    XXF94B   F94B    XXF957   F957    XXF95C   F95C
 XXF95D   F95D    XXF972   F972    XXF979   F979    XXF98E   F98E
 XXF9C3   F9C3    XXF9E2   F9E2    XXF9E5   F9E5    XXF9ED   F9ED
 XXF9F1   F9F1    XXF9F3   F9F3    XXFA     00FA    XXFA06   FA06
 XXFA19   FA19    XXFA22   FA22    XXFA25   FA25    XXFA2E   FA2E
 XXFA30   FA30    XXFA47   FA47    XXFA60   FA60    XXFA68   FA68
 XXFA6C   FA6C    XXFA91   FA91    XXFAA0   FAA0    XXFAAA   FAAA
 XXFAAD   FAAD    XXFABD   FABD    XXFAD3   FAD3    XXFAD7   FAD7
 XXFADA   FADA    XXFAF0   FAF0    XXFAF6   FAF6    XXFB07   FB07
 XXFB0D   FB0D    XXFB1B   FB1B    XXFB23   FB23    XXFB38   FB38
 XXFB55   FB55    XXFB7C   FB7C    XXFB80   FB80    XXFB87   FB87
 XXFB90   FB90    XXFB95   FB95    XXFB97   FB97    XXFBA0   FBA0
 XXFBAC   FBAC    XXFBB6   FBB6    XXFBCF   FBCF    XXFBD2   FBD2
 XXFBDB   FBDB    XXFBEA   FBEA    XXFBF1   FBF1    XXFBF3   FBF3
 XXFBF5   FBF5    XXFC06   FC06    XXFC0B   FC0B    XXFC21   FC21
 XXFC2E   FC2E    XXFC47   FC47    XXFC4A   FC4A    XXFC54   FC54
 XXFC6A   FC6A    XXFC6E   FC6E    XXFC7D   FC7D    XXFC8C   FC8C
 XXFC92   FC92    XXFC95   FC95    XXFC9C   FC9C    XXFCA8   FCA8
 XXFCCF   FCCF    XXFCF4   FCF4    XXFCF6   FCF6    XXFCFB   FCFB
 XXFD08   FD08    XXFD11   FD11    XXFD1B   FD1B    XXFD21   FD21
 XXFD22   FD22    XXFD2F   FD2F    XXFD3F   FD3F    XXFD41   FD41
 XXFD4C   FD4C    XXFD4D   FD4D    XXFD52   FD52    XXFD57   FD57
 XXFD5D   FD5D    XXFD64   FD64    XXFD6D   FD6D    XXFD8D   FD8D
 XXFD90   FD90    XXFDAF   FDAF    XXFDB5   FDB5    XXFDCF   FDCF
 XXFDD2   FDD2    XXFDDE   FDDE    XXFDEB   FDEB    XXFDF1   FDF1
 XXFDF9   FDF9    XXFE39   FE39    XXFE49   FE49    XXFE50   FE50
 XXFE57   FE57    XXFE66   FE66    XXFE68   FE68    XXFE6A   FE6A
 XXFE6F   FE6F    XXFE73   FE73    XXFE75   FE75    XXFE7B   FE7B
 XXFE82   FE82    XXFE8A   FE8A    XXFE91   FE91    XXFEA4   FEA4
 XXFEA9   FEA9    XXFEAD   FEAD    XXFEC7   FEC7    XXFED2   FED2
 XXFEDE   FEDE    XXFEFF   FEFF    XXFF02   FF02    XXFF2C   FF2C
 XXFF38   FF38    XXFF56   FF56    XXFF5C   FF5C    XXFF72   FF72
 XXFF82   FF82    XXFF90   FF90    XXFF99   FF99    XXFF9C   FF9C
 XXFFB7   FFB7    XXFFBA   FFBA    XXFFBD   FFBD    XXFFC0   FFC0
 XXFFC3   FFC3    XXFFC6   FFC6    XXFFC9   FFC9    XXFFCC   FFCC








SYMBOL TABLE

SYMBOL VALUE
 XXFFCF   FFCF    XXFFD2   FFD2    XXFFD5   FFD5    XXFFD8   FFD8
 XXFFDB   FFDB    XXFFDE   FFDE    XXFFE1   FFE1    XXFFE4   FFE4
 XXFFE7   FFE7    XXFFEA   FFEA    XXFFF0   FFF0    XXFFF3   FFF3


END OF ASSEMBLY

