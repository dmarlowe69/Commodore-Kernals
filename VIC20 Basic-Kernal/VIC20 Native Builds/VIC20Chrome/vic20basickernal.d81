XXD6          ; DECREMENT CURSOR ROW     JSR     XXE8C3          ; DO NEWLINE     LDY     #$00               ; CLEAR CURSOR COLUMNXXE7D4 = *     STY     XXD3          ; SAVE CURSOR COLUMNXXE7D6 = *     JMP     XXE6DC          ; RESTORE REGISTERS, SET QUOTE FLAG AND EXITXXE7D9 = *     CMP     #$11               ; COMPARE WITH [CURSOR DOWN]     BNE     XXE7FA          ; BRANCH IF NOT [CURSOR DOWN]     CLC                    ; CLEAR CARRY FOR ADD     TYA                    ; COPY CURSOR COLUMN     ADC     #$16               ; ADD ONE LINE     TAY                    ; COPY BACK TO A     INC     XXD6          ; INCREMENT CURSOR ROW     CMP     XXD5          ; COMPARE CURSOR COLUMN WITH CURRENT SCREEN LINE LENGTH     BCC     XXE7D4          ; SAVE CURSOR COLUMN AND EXIT IF LESS     BEQ     XXE7D4          ; SAVE CURSOR COLUMN AND EXIT IF EQUAL                         ; ELSE THE CURSOR HAS MOVED BEYOND THE END OF THIS LINE                         ; SO BACK IT UP UNTIL IT'S ON THE START OF THE LOGICAL LINE     DEC     XXD6          ; DECREMENT CURSOR ROWXXE7EC = *     SBC     #$16               ; SUBTRACT ONE LINE     BCC     XXE7F4          ; EXIT LOOP IF ON PREVIOUS LINE     STA     XXD3          ; ELSE SAVE CURSOR COLUMN     BNE     XXE7EC          ; LOOP IF NOT AT START OF LINEXXE7F4 = *     JSR     XXE8C3          ; DO NEWLINEXXE7F7 = *     JMP     XXE6DC          ; RESTORE REGISTERS, SET QUOTE FLAG AND EXITXXE7FA = *     JSR     XXE912          ; SET THE COLOUR FROM THE CHARACTER IN A     JMP     XXED21          ;.XXE800 = *     NOP                    ; JUST A FEW WASTED CYCLES     NOP                    ;     NOP                    ;     NOP                    ;     NOP                    ;     NOP                    ;     NOP                    ;     NOP                    ;     NOP                    ;     NOP                    ;     NOP                    ;     NOP                    ;     NOP                    ;     NOP                   	 ;     NOP                    ;     NOP                    ;     NOP                    ;     NOP                    ;     NOP                    ;     NOP                    ;     NOP                    ;     AND     #$7F               ; MASK 0X
XX XXXX, CLEAR B7     CMP     #$7F               ; WAS IT $FF BEFORE THE MASK     BNE     XXE81D          ; BRANCH IF NOT     LDA     #$5E               ; ELSE MAKE IT $5EXXE81D = *     NOP                    ; JUST A FEW WASTED CYCLES     NOP                    ;     NOP                    ;     NOP                    ;     NOP                    ;     NOP                    ;     CMP     #' '               ; COMPARE WITH [SPACE]     BCC     XXE82A          ; BRANCH IF < [SPACE]     JMP     XXE6C5          ; INSERT UPPERCASE/GRAPHIC CHARACTER AND RETURN                         ; CHARACTER WAS $80 TO $9F AND IS NOW $00 TO $1FXXE82A = *     CMP     #$0D               ; COMPARE WITH [CR]     BNE     XXE831          ; BRANCH IF NOT [CR]     JMP     XXE8D8          ; ELSE OUTPUT [CR] AND RETURN                         ; WAS NOT [CR]XXE831 = *     LDX     XXD4          ; GET CURSOR QUOTE FLAG, $XX = QUOTE, $00 = NO QUOTE     BNE     XXE874          ; BRANCH IF QUOTE MODE     CMP     #$14               ; COMPARE WITH [INSERT DELETE]     BNE     XXE870          ; BRANCH IF NOT [INSERT DELETE]     LDY     XXD5          ; GET CURRENT SCREEN LINE LENGTH     LDA     (XXD1),Y          ; GET CHARACTER FROM CURRENT SCREEN LINE     CMP     #' '               ; COMPARE WITH [SPACE]     BNE     XXE845          ; BRANCH IF NOT [SPACE]     CPY     XXD3          ; COMPARE CURRENT COLUMN WITH CURSOR COLUMN     BNE     XXE84C          ; IF NOT CURSOR COLUMN GO OPEN UP SPACE ON LINEXXE845 = *     CPY     #$57               ; COMPARE CURRENT COLUMN WITH MAX LINE LENGTH     BEQ     XXE86D          ; EXIT IF AT LINE END     JSR     XXE9EE          ; ELSE OPEN SPACE ON SCREEN                         ; NOW OPEN UP SPACE ON THE LINE TO INSERT A CHARACTERXXE84C = *     LDY     XXD5          ; GET CURRENT SCREEN LINE LENGTH     JSR     XXEAB2          ; CALCULATE POINTER TO COLOUR RAMXXE851 = *     DEY                    ; DECREMENT INDEX TO PREVIOUS CHARACTER     LDA     (XXD1),Y          ; GET CHARACTER FROM CURRENT SCREEN LINE     INY                    ; INCREMENT INDEX TO NEXT CHARACTER     STA     (XXD1),Y          ; SAVE CHARACTER TO CURRENT SCREEN LINE     DEY                    ; DECREMENT INDEX TO PREVIOUS CHARACTER     LDA     (XXF3),Y          ; GET CURRENT SCREEN LINE COLOUR RAM BYTE     INY                    ; INCREMENT INDEX TO NEXT CHARACTER     STA     (XXF3),Y          ; SAVE CURRENT SCREEN LINE COLOUR RAM BYTE     DEY                    ; DECREMENT INDEX TO PREVIOUS CHARACTER     CPY     XXD3          ; COMPARE WITH CURSOR COLUMN     BNE     XXE851          ; LOOP IF NOT THERE YET     LDA     #' '               ; SET [SPACE]     STA     (XXD1),Y          ; CLEAR CHARACTER AT CURSOR POSITION ON CURRENT SCREEN LINE     LDA     XX0286          ; GET CURRENT COLOUR CODE     STA     (XXF3),Y          ; SAVE TO CURSOR POSITION ON CURRENT SCREEN LINE COLOUR RAM     INC     XXD8          ; INCREMENT INSERT COUNTXXE86D = *     JMP     XXE6DC          ; RESTORE REGISTERS, SET QUOTE FLAG AND EXITXXE870 = *     LDX     XXD8          ; GET INSERT COUNT     BEQ     XXE879          ; BRANCH IF NO INSERT SPACEXXE874 = *     ORA     #$40               ; CHANGE TO UPPERCASE/GRAPHIC     JMP     XXE6CB          ; INSERT REVERSED CHARACTERXXE879 = *     CMP     #$11               ; COMPARE WITH [CURSOR UP]     BNE     XXE893          ; BRANCH IF NOT [CURSOR UP]     LDX     XXD6          ; GET CURSOR ROW     BEQ     XXE8B8          ; BRANCH IF ON TOP LINE     DEC     XXD6          ; DECREMENT CURSOR ROW     LDA     XXD3          ; GET CURSOR COLUMN     SEC                    ; SET CARRY FOR SUBTRACT     SBC     #$16               ; SUBTRACT ONE LINE LENGTH     BCC     XXE88E          ; BRANCH IF STEPPED BACK TO PREVIOUS LINE     STA     XXD3          ; ELSE SAVE CURSOR COLUMN ..     BPL     XXE8B8          ; .. AND EXIT, BRANCH ALWAYSXXE88E = *     JSR     XXE587          ; SET SCREEN POINTERS FOR CURSOR ROW, COLUMN ..     BNE     XXE8B8          ; .. AND EXIT, BRANCH ALWAYSXXE893 = *     CMP     #$12               ; COMPARE WITH [RVS OFF]     BNE     XXE89B          ; BRANCH IF NOT [RVS OFF]     LDA     #$00               ; CLEAR A     STA     XXC7          ; CLEAR REVERSE FLAGXXE89B = *     CMP     #$1D               ; COMPARE WITH [CURSOR LEFT]     BNE     XXE8B1          ; BRANCH IF NOT [CURSOR LEFT]     TYA                    ; COPY CURSOR COLUMN     BEQ     XXE8AB          ; BRANCH IF AT START OF LINE     JSR     XXE8E8          ; TEST FOR LINE DECREMENT     DEY                    ; DECREMENT CURSOR COLUMN     STY     XXD3          ; SAVE CURSOR COLUMN     JMP     XXE6DC          ; RESTORE REGISTERS, SET QUOTE FLAG AND EXITXXE8AB = *     JSR     XXE72D          ; BACK ONTO PREVIOUS LINE IF POSSIBLE     JMP     XXE6DC          ; RESTORE REGISTERS, SET QUOTE FLAG AND EXITXXE8B1 = *     CMP     #$13               ; COMPARE WITH [CLR]     BNE     XXE8BB          ; BRANCH IF NOT [CLR]     JSR     XXE55F          ; CLEAR SCREENXXE8B8 = *     JMP     XXE6DC          ; RESTORE REGISTERS, SET QUOTE FLAG AND EXITXXE8BB = *     ORA     #$80               ; RESTORE B7, COLOUR CAN ONLY BE BLACK, CYAN, MAGENTA                         ; OR YELLOW     JSR     XXE912          ; SET THE COLOUR FROM THE CHARACTER IN A     JMP     XXED30          ;.;***********************************************************************************;;; DO NEWLINEXXE8C3 = *     LSR     XXC9          ; SHIFT >>  INPUT CURSOR ROW     LDX     XXD6          ; GET CURSOR ROWXXE8C7 = *     INX                    ; INCREMENT ROW     CPX     #$17               ; COMPARE WITH LAST ROW + 1     BNE     XXE8CF          ; BRANCH IF NOT LAST ROW + 1     JSR     XXE975!          ; ELSE SCROLL SCREENXXE8CF = *     LDA     XXD9,X          ; GET START OF LINE X POINTER HIGH BYTE     BPL     XXE8C7          ; LOOP IF NOT START OF LOGICAL LINE     STX     XXD6          ; ELSE SAVE CURSOR ROW     JMP     XXE587        "  ; SET SCREEN POINTERS FOR CURSOR ROW, COLUMN AND RETURN;***********************************************************************************;;; OUTPUT [CR]XXE8D8 = *     LDX     #$00               ; CLEAR X     STX     XXD8          ; CLEAR INS#ERT COUNT     STX     XXC7          ; CLEAR REVERSE FLAG     STX     XXD4          ; CLEAR CURSOR QUOTE FLAG, $XX = QUOTE, $00 = NO QUOTE     STX     XXD3          ; CLEAR CURSOR COLUMN     JSR     XXE8C3          ; DO NEWLINE     JMP     XXE6DC    $      ; RESTORE REGISTERS, SET QUOTE FLAG AND EXIT;***********************************************************************************;;; TEST FOR LINE DECREMENTXXE8E8 = *     LDX     #$04               ; SET COUNT     LDA     #$00              % ; SET COLUMNXXE8EC = *     CMP     XXD3          ; COMPARE WITH CURSOR COLUMN     BEQ     XXE8F7          ; BRANCH IF AT START OF LINE     CLC                    ; ELSE CLEAR CARRY FOR ADD     ADC     #$16               ; INCREMENT TO NEXT LINE  &   DEX                    ; DECREMENT LOOP COUNT     BNE     XXE8EC          ; LOOP IF MORE TO TEST     RTSXXE8F7 = *     DEC     XXD6          ; ELSE DECREMENT CURSOR ROW     RTS;****************************************************************'*******************;;; TEST FOR LINE INCREMENT. IF AT END OF LINE, BUT NOT AT END OF LAST LINE, INCREMENT THE; CURSOR ROWXXE8FA = *     LDX     #$04               ; SET COUNT     LDA     #$15               ; SET COLUMNXXE8FE = *     CMP     XXD3)           ; COMPARE WITH CURSOR COLUMN     BEQ     XXE909          ; IF AT END OF LINE TEST AND POSSIBLY INCREMENT CURSOR ROW     CLC                    ; ELSE CLEAR CARRY FOR ADD     ADC     #$16               ; INCREMENT TO NEXT LINE     DEX            ; BRANCH IF SCREENXXE6A3 = *     JSR     XXE742          ; OUTPUT CHARACTERXXE6A6 = *     LDA     #$0D               ; SET CHARACTER [CR]XXE6A8 = *     STA     XXD7          ; SAVE CHARACTER     PLA                    ; PULL X     TAX                    ; RESTORE X     PLA                    ; PULL Y     TAY                    ; RESTORE Y     LDA     XXD7          ; RESTORE CHARACTER     CMP     #$DE               ;.     BNE     XXE6B6          ;.     LDA     #$FF               ;.XXE6B6 = *     CLC                    ; FLAG OK     RTS;***********************************************************************************;;; IF OPEN QUOTE TOGGLE CURSOR QUOTE FLAGXXE6B8 = *     CMP     #$22               ; COMAPRE BYTE WITH '     BNE     XXE6C4          ; EXIT IF NOT '     LDA     XXD4          ; GET CURSOR QUOTE FLAG, $XX = QUOTE, $00 = NO QUOTE     EOR     #$01               ; TOGGLE IT     STA     XXD4          ; SAVE CURSOR QUOTE FLAG     LDA     #$22               ; RESTORE THE 'XXE6C4 = *     RTS;***********************************************************************************;;; INSERT UPPERCASE/GRAPHIC CHARACTERXXE6C5 = *     ORA     #$40               ; CHANGE TO UPPERCASE/GRAPHICXXE6C7 = *     LDX     XXC7          ; GET REVERSE FLAG     BEQ     XXE6CD          ; BRANCH IF NOT REVERSE                         ; ELSE ..; INSERT REVERSED CHARACTERXXE6CB = *     ORA     #$80               ; REVERSE CHARACTERXXE6CD = *     LDX     XXD8          ; GET INSERT COUNT     BEQ     XXE6D3          ; BRANCH IF NONE     DEC     XXD8          ; ELSE DECREMENT INSERT COUNTXXE6D3 = *     LDX     XX0286          ; GET CURRENT COLOUR CODE     JSR     XXEAA1          ; PRINT CHARACTER A AND COLOUR X     JSR     XXE6EA          ; ADVANCE CURSOR; RESTORE REGISTERS, SET QUOTE FLAG AND EXITXXE6DC = *     PLA                    ; PULL Y     TAY                    ; RESTORE Y     LDA     XXD8          ; GET INSERT COUNT     BEQ     XXE6E4     	     ; SKIP QUOTE FLAG CLEAR IF INSERTS TO DO     LSR     XXD4          ; CLEAR CURSOR QUOTE FLAG, $XX = QUOTE, $00 = NO QUOTEXXE6E4 = *     PLA                    ; PULL X     TAX                    ; RESTORE X     PLA                    ; RESTORE
 A     CLC                    ;.     CLI                    ; ENABLE INTERRUPTS     RTS;***********************************************************************************;;; ADVANCE CURSORXXE6EA = *     JSR     XXE8FA          ; TEST FOR LINE INCREMENT     INC     XXD3          ; INCREMENT CURSOR COLUMN     LDA     XXD5          ; GET CURRENT SCREEN LINE LENGTH     CMP     XXD3          ; COMPARE WITH CURSOR COLUMN     BCS     XXE72C          ; EXIT IF LINE LENGTH >= CURSOR COLUMN     CMP     #$57               ; COMPARE WITH MAX LENGTH     BEQ     XXE723          ; IF AT MAX CLEAR COLUMN, BACK CURSOR UP AND DO NEWLINE     LDA     XX0292          ; GET AUTOSCROLL FLAG     BEQ     XXE701          ; BRANCH IF AUTOSCROLL ON     JMP     XXE9F0          ;.ELSE OPEN SPACE ON SCREENXXE701 = *     LDX     XXD6          ; GET CURSOR ROW     CPX     #$17               ; COMPARE WITH MAX + 1     BCC     XXE70E          ; IF LESS THAN MAX + 1 GO ADD THIS ROW TO THE CURRENT                         ; LOGICAL LINE     JSR     XXE975          ; ELSE SCROLL SCREEN     DEC     XXD6          ; DECREMENT CURSOR ROW     LDX     XXD6          ; GET CURSOR ROW; ADD THIS ROW TO THE CURRENT LOGICAL LINEXXE70E = *     ASL     XXD9,X          ; SHIFT START OF LINE X POINTER HIGH BYTE     LSR     XXD9,X          ; SHIFT START OF LINE X POINTER HIGH BYTE BACK,                         ; CLEAR B7, START OF LOGICAL LINE     JMP     XXED5B          ; MAKE NEXT SCREEN LINE START OF LOGICAL LINE, INCREMENT                         ; LINE LENGTH AND SET POINTERS; ADD ONE LINE LENGTH AND SET POINTERS FOR START OF LINEXXE715 = *     ADC     #$16               ; ADD ONE LINE LENGTH     STA     XXD5          ; SAVE CURRENT SCREEN LINE LENGTH; FIND AND SET POINTERS FOR START OF LOGICAL LINEXXE719 = *     LDA     XXD9,X          ; GET START OF LINE X POINTER HIGH BYTE     BMI     XXE720          ; EXIT LOOP IF START OF LOGICAL LINE     DEX                    ; ELSE BACK UP ONE LINE     BNE     XXE719          ; LOOP IF NOT ON FIRST LINEXXE720 = *     JMP     XXEA7E          ; SET START OF LINE X AND RETURN; CLEAR CURSOR COLUMN, BACK CURSOR UP ONE LINE AND DO NEWLINEXXE723 = *     DEC     XXD6          ; DECREMENT CURSOR ROW. IF THE CURSOR WAS INCREMENTED PAST                         ; THE LAST LINE THEN THIS DECREMENT AND THE SCROLL WILL                         ; LEAVE THE CURSOR ONE LINE ABOVE THE BOTOM OF THE SCREEN     JSR     XXE8C3          ; DO NEWLINE     LDA     #$00               ; CLEAR A     STA     XXD3          ; CLEAR CURSOR COLUMNXXE72C = *     RTS; BACK ONTO PREVIOUS LINE IF POSSIBLEXXE72D = *     LDX     XXD6          ; GET CURSOR ROW     BNE     XXE737          ; BRANCH IF NOT TOP ROW     STX     XXD3          ; CLEAR CURSOR COLUMN     PLA                    ; DUMP RETURN ADDRESS LOW BYTE     PLA                    ; DUMP RETURN ADDRESS HIGH BYTE     BNE     XXE6DC          ; RESTORE REGISTERS, SET QUOTE FLAG AND EXIT, BRANCH ALWAYSXXE737 = *     DEX                    ; DECREMENT CURSOR ROW     STX     XXD6          ; SAVE CURSOR ROW     JSR     XXE587          ; SET SCREEN POINTERS FOR CURSOR ROW, COLUMN     LDY     XXD5          ; GET CURRENT SCREEN LINE LENGTH     STY     XXD3          ; SAVE AS CURSOR COLUMN     RTS;***********************************************************************************;;;## OUTPUT CHARACTER TO SCREENXXE742 = *     PHA                    ; SAVE CHARACTER     STA     XXD7          ; SAVE TEMPORARY LAST CHARACTER     TXA                    ; COPY X     PHA                    ; SAVE X     TYA                    ; COPY Y     PHA                    ; SAVE Y     LDA     #$00               ; CLEAR A     STA     XXD0          ; CLEAR INPUT FROM KEYBOARD OR SCREEN, $XX = SCREEN,                         ; $00 = KEYBOARD     LDY     XXD3          ; GET CURSOR COLUMN     LDA     XXD7          ; RESTORE LAST CHARACTER     BPL     XXE756          ; BRANCH IF UNSHIFTED     JMP     XXE800          ; DO SHIFTED CHARACTERS AND RETURNXXE756 = *     CMP     #$0D               ; COMPARE WITH [CR]     BNE     XXE75D          ; BRANCH IF NOT [CR]     JMP     XXE8D8          ; ELSE OUTPUT [CR] AND RETURNXXE75D = *     CMP     #' '               ; COMPARE WITH [SPACE]     BCC     XXE771          ; BRANCH IF < [SPACE]     CMP     #$60               ;.     BCC     XXE769          ; BRANCH IF $20 TO $5F                         ; CHARACTER IS $60 OR GREATER     AND     #$DF               ;.     BNE     XXE76B          ;.XXE769 = *     AND     #$3F               ;.XXE76B = *     JSR     XXE6B8          ; IF OPEN QUOTE TOGGLE CURSOR DIRECT/PROGRAMMED FLAG     JMP     XXE6C7          ;.                         ; CHARACTER WAS < [SPACE] SO IS A CONTROL CHARACTER                         ; OF SOME SORTXXE771 = *     LDX     XXD8          ; GET INSERT COUNT     BEQ     XXE778          ; BRANCH IF NO CHARACTERS TO INSERT     JMP     XXE6CB          ; INSERT REVERSED CHARACTERXXE778 = *     CMP     #$14               ; COMPARE WITH [INSERT]/[DELETE]     BNE     XXE7AA          ; BRANCH IF NOT [INSERT]/[DELETE]     TYA                    ;.     BNE     XXE785          ;.     JSR     XXE72D          ; BACK ONTO PREVIOUS LINE IF POSSIBLE     JMP     XXE79F          ;.XXE785 = *     JSR     XXE8E8          ; TEST FOR LINE DECREMENT                         ; NOW CLOSE UP THE LINE     DEY                    ; DECREMENT INDEX TO PREVIOUS CHARACTER     STY     X XD3          ; SAVE CURSOR COLUMN     JSR     XXEAB2          ; CALCULATE POINTER TO COLOUR RAMXXE78E = *     INY                    ; INCREMENT INDEX TO NEXT CHARACTER     LDA     (XXD1),Y          ; GET CHARACTER FROM CURRENT SCREEN LINE     DEY  !                  ; DECREMENT INDEX TO PREVIOUS CHARACTER     STA     (XXD1),Y          ; SAVE CHARACTER TO CURRENT SCREEN LINE     INY                    ; INCREMENT INDEX TO NEXT CHARACTER     LDA     (XXF3),Y          ; GET COLOUR RAM BYTE     DEY"                    ; DECREMENT INDEX TO PREVIOUS CHARACTER     STA     (XXF3),Y          ; SAVE COLOUR RAM BYTE     INY                    ; INCREMENT INDEX TO NEXT CHARACTER     CPY     XXD5          ; COMPARE WITH CURRENT SCREEN LINE LENGTH     BN#E     XXE78E          ; LOOP IF NOT THERE YETXXE79F = *     LDA     #' '               ; SET [SPACE]     STA     (XXD1),Y          ; CLEAR LAST CHARACTER ON CURRENT SCREEN LINE     LDA     XX0286          ; GET CURRENT COLOUR CODE     STA     (XXF3$),Y          ; SAVE TO COLOUR RAM     BPL     XXE7F7          ; BRANCH ALWAYSXXE7AA = *     LDX     XXD4          ; GET CURSOR QUOTE FLAG, $XX = QUOTE, $00 = NO QUOTE     BEQ     XXE7B1          ; BRANCH IF NOT QUOTE MODE     JMP     XXE6CB       %   ; INSERT REVERSED CHARACTERXXE7B1 = *     CMP     #$12               ; COMPARE WITH [RVS ON]     BNE     XXE7B7          ; BRANCH IF NOT [RVS ON]     STA     XXC7          ; SET REVERSE FLAGXXE7B7 = *     CMP     #$13               ; COMPARE W&ITH [CLR HOME]     BNE     XXE7BE          ; BRANCH IF NOT [CLR HOME]     JSR     XXE581          ; HOME CURSORXXE7BE = *     CMP     #$1D               ; COMPARE WITH [CURSOR RIGHT]     BNE     XXE7D9          ; BRANCH IF NOT [CURSOR RIGHT]     'INY                    ; INCREMENT CURSOR COLUMN     JSR     XXE8FA          ; TEST FOR LINE INCREMENT     STY     XXD3          ; SAVE CURSOR COLUMN     DEY                    ; DECREMENT CURSOR COLUMN     CPY     XXD5          ; COMPARE CURSOR COLU MN WITH CURRENT SCREEN LINE LENGTH     BCC     XXE7D6          ; EXIT IF LESS                         ; ELSE THE CURSOR COLUMN IS >= THE CURRENT SCREEN LINE                         ; LENGTH SO BACK ONTO THE CURRENT LINE AND DO A NEWLINE     DEC     ER OF LINES + 1     BNE     XXE568          ; LOOP IF NOT ALL DONE     LDA     #$FF               ; END OF TABLE MARKER ??     STA     XXD9,X          ; MARK END OF TABLE     LDX     #$16               ; SET LINE COUNT, 23 LINES TO DO, 0 TO 22XXE57B = *     JSR     XXEA8D          ; CLEAR SCREEN LINE X     DEX                    ; DECREMENT COUNT     BPL     XXE57B          ; LOOP IF MORE TO DO; HOME CURSORXXE581 = *     LDY     #$00               ; CLEAR Y     STY     XXD3          ; CLEAR CURSOR COLUMN     STY     XXD6          ; CLEAR CURSOR ROW; SET SCREEN POINTERS FOR CURSOR ROW, COLUMNXXE587 = *     LDX     XXD6          ; GET CURSOR ROW     LDA     XXD3          ; GET CURSOR COLUMNXXE58B = *     LDY     XXD9,X          ; GET START OF LINE X POINTER HIGH BYTE     BMI     XXE597          ; CONTINUE IF LOGICAL LINE START     CLC                    ; ELSE CLEAR CARRY FOR ADD     ADC     #$16               ; ADD ONE LINE LENGTH     STA     XXD3          ; SAVE CURSOR COLUMN     DEX                    ; DECREMENT CURSOR ROW     BPL     XXE58B          ; LOOP, BRANCH ALWAYSXXE597 = *     LDA     XXD9,X          ; GET START OF LINE X POINTER HIGH BYTE     AND     #$03               ; MASK 0000 00XX, LINE MEMORY PAGE     ORA     XX0288          ; OR WITH SCREEN MEMORY PAGE     STA     XXD2          ; SET CURRENT SCREEN LINE POINTER HIGH BYTE     LDA     XXEDFD,X          ; GET START OF LINE LOW BYTE FROM ROM TABLE     STA     XXD1          ; SET CURRENT SCREEN LINE POINTER LOW BYTE     LDA     #$15               ; SET LINE LENGTH     INX                    ; INCREMENT CURSOR ROWXXE5A8 = *     LDY     XXD9,X          ; GET START OF LINE X POINTER HIGH BYTE     BMI     XXE5B2          ; EXIT IF LOGICAL LINE START     CLC                    ; ELSE CLEAR CARRY FOR ADD     ADC     #$16               ; ADD ONE LINE LENGTH TO CURRENT LINE LENGTH     INX                    ; INCREMENT CURSOR ROW     BPL     XXE5A8          ; LOOP, BRANCH ALWAYSXXE5B2 = *  	   STA     XXD5          ; SAVE CURRENT SCREEN LINE LENGTH     RTS;***********************************************************************************;;; SET DEFAULT DEVICES, INITIALISE VIC CHIP AND HOME CURSOR;; UNREFERENCED CODE;XXE5B5     J
SR     XXE5BB          ; SET DEFAULT DEVICES AND INITIALISE VIC CHIP     JMP     XXE581          ; HOME CURSOR AND RETURN;***********************************************************************************;;; SET DEFAULT DEVICES AND INITIALISE VIC CHIPXXE5BB = *     LDA     #$03               ; SET SCREEN     STA     XX9A          ; SET OUTPUT DEVICE NUMBER     LDA     #$00               ; SET KEYBOARD     STA     XX99          ; SET INPUT DEVICE NUMBER; INITIALISE VIC CHIPXXE5C3 = *     LDX     #$10               ; SET BYTE COUNTXXE5C5 = *     LDA     XXEDE4-1,X     ; GET BYTE FROM SETUP TABLE     STA     XX9000-1,X     ; SAVE BYTE TO VIC CHIP     DEX                    ; DECREMENT COUNT/INDEX     BNE     XXE5C5          ; LOOP IF MORE TO DO     RTS;***********************************************************************************;;; INPUT FROM KEYBOARD BUFFERXXE5CF = *     LDY     XX0277          ; GET CURRENT CHARACTER FROM BUFFER     LDX     #$00               ; CLEAR INDEXXXE5D4 = *     LDA     XX0277+1,X     ; GET NEXT CHARACTER,X FROM BUFFER     STA     XX0277,X          ; SAVE AS CURRENT CHARACTER,X IN BUFFER     INX                    ; INCREMENT INDEX     CPX     XXC6          ; COMPARE WITH KEYBOARD BUFFER INDEX     BNE     XXE5D4          ; LOOP IF MORE TO DO     DEC     XXC6          ; DECREMENT KEYBOARD BUFFER INDEX     TYA                    ; COPY KEY TO A     CLI                    ; ENABLE INTERRUPTS     CLC                    ; FLAG GOT BYTE     RTS;***********************************************************************************;;; WRITE CHARACTER AND WAIT FOR KEYXXE5E5 = *     JSR     XXE742          ; OUTPUT CHARACTER; WAIT FOR KEY FROM KEYBOARDXXE5E8 = *     LDA     XXC6          ; GET KEYBOARD BUFFER INDEX     STA     XXCC          ; CURSOR ENABLE, $00 = FLASH CURSOR, $XX = NO FLASH     STA     XX0292          ; SCREEN SCROLLING FLAG, $00 = SCROLL, $XX = NO SCROLL                         ; THIS DISABLES BOTH THE CURSOR FLASH AND THE SCREEN SCROLL                         ; WHILE THERE ARE CHARACTERS IN THE KEYBOARD BUFFER     BEQ     XXE5E8          ; LOOP IF BUFFER EMPTY     SEI                    ; DISABLE INTERRUPTS     LDA     XXCF          ; GET CURSOR BLINK PHASE     BEQ     XXE602          ; BRANCH IF CURSOR PHASE                         ; ELSE CHARACTER PHASE     LDA     XXCE          ; GET CHARACTER UNDER CURSOR     LDX     XX0287          ; GET COLOUR UNDER CURSOR     LDY     #$00               ; CLEAR Y     STY     XXCF          ; CLEAR CURSOR BLINK PHASE     JSR     XXEAA1          ; PRINT CHARACTER A AND COLOUR XXXE602 = *     JSR     XXE5CF          ; INPUT FROM KEYBOARD BUFFER     CMP     #$83               ; COMPARE WITH [SHIFT][RUN]     BNE     XXE619          ; BRANCH IF NOT [SHIFT][RUN]                         ; KEYS ARE [SHIFT][RUN] SO PUT 'LOAD',$0D,'RUN',$0D INTO                         ; THE BUFFER     LDX     #$09               ; SET BYTE COUNT     SEI                    ; DISABLE INTERRUPTS     STX     XXC6          ; SET KEYBOARD BUFFER INDEXXXE60E = *     LDA     XXEDF4-1,X     ; GET BYTE FROM AUTO LOAD/RUN TABLE     STA     XX0277-1,X     ; SAVE TO KEYBOARD BUFFER     DEX                    ; DECREMENT COUNT/INDEX     BNE     XXE60E          ; LOOP WHILE MORE TO DO     BEQ     XXE5E8          ; LOOP FOR NEXT KEY, BRANCH ALWAYS                         ; WAS NOT [SHIFT][RUN]XXE619 = *     CMP     #$0D               ; COMPARE WITH [CR]     BNE     XXE5E5          ; IF NOT [CR] PRINT CHARACTER AND GET NEXT KEY                         ; WAS [CR]     LDY     XXD5          ; GET CURRENT SCREEN LINE LENGTH     STY     XXD0          ; INPUT FROM KEYBOARD OR SCREEN, $XX = SCREEN,                         ; $00 = KEYBOARDXXE621 = *     LDA     (XXD1),Y          ; GET CHARACTER FROM CURRENT SCREEN LINE     CMP     #' '               ; COMPARE WITH [SPACE]     BNE     XXE62A          ; BRANCH IF NOT [SPACE]     DEY                    ; ELSE ELIMINATE THE SPACE, DECREMENT END OF INPUT LINE     BNE     XXE621          ; LOOP, BRANCH ALWAYSXXE62A = *     INY                    ; INCREMENT PAST LAST NON SPACE CHARACTER ON LINE     STY     XXC8          ; SAVE INPUT [EOL] POINTER     LDY     #$00               ; CLEAR A     STY     XX0292          ; CLEAR SCREEN SCROLLING FLAG, $00 = SCROLL, $XX = NO SCROLL     STY     XXD3          ; CLEAR CURSOR COLUMN     STY     XXD4          ; CLEAR CURSOR QUOTE FLAG, $XX = QUOTE, $00 = NO QUOTE     LDA     XXC9          ; GET INPUT CURSOR ROW     BMI     XXE657          ;.     LDX     XXD6          ; GET CURSOR ROW     JSR     XXE719          ; FIND AND SET POINTERS FOR START OF LOGICAL LINE     CPX     XXC9          ; COMPARE WITH INPUT CURSOR ROW     BNE     XXE657          ;.     BNE     XXE657          ;.?? WHAT'S THIS? JUST TO MAKE SURE OR SOMETHING     LDA     XXCA          ; GET INPUT CURSOR COLUMN     STA     XXD3          ; SAVE CURSOR COLUMN     CMP     XXC8          ; COMPARE WITH INPUT [EOL] POINTER     BCC     XXE657          ; BRANCH IF LESS, CURSOR IS IN LINE     BCS     XXE691          ; ELSE CURSOR IS BEYOND THE LINE END, BRANCH ALWAYS;***********************************************************************************;;; INPUT FROM SCREEN OR KEYBOARDXXE64F = *     TYA                    ; COPY Y     PHA                    ; SAVE Y     TXA                    ; COPY X     PHA                    ; SAVE X     LDA     XXD0          ; INPUT FROM KEYBOARD OR  SCREEN, $XX = SCREEN,                         ; $00 = KEYBOARD     BEQ     XXE5E8          ; IF KEYBOARD GO WAIT FOR KEYXXE657 = *     LDY     XXD3          ; GET CURSOR COLUMN     LDA     (XXD1),Y          ; GET CHARACTER FROM THE CURRENT SCREEN L!INE     NOP                    ;     NOP                    ;     NOP                    ;     NOP                    ;     NOP                    ;     NOP                    ;     NOP                    ;     NOP                    ;     NOP  "                  ; JUST A FEW WASTED CYCLES.     NOP                    ;     NOP                    ;     NOP                    ;     NOP                    ;     NOP                    ;     NOP                    ;     NOP                    #;     NOP                    ;     NOP                    ;     NOP                    ;     NOP                    ;     NOP                    ;     NOP                    ;     NOP                    ;     STA     XXD7          ; SAVE TEMPORAR$Y LAST CHARACTER     AND     #$3F               ; MASK KEY BITS     ASL     XXD7          ; << TEMPORARY LAST CHARACTER     BIT     XXD7          ; TEST IT     BPL     XXE67E          ; BRANCH IF NOT [NO KEY]     ORA     #$80               ;.XXE67%E = *     BCC     XXE684          ;.     LDX     XXD4          ; GET CURSOR QUOTE FLAG, $XX = QUOTE, $00 = NO QUOTE     BNE     XXE688          ; BRANCH IF IN QUOTE MODEXXE684 = *     BVS     XXE688          ;.     ORA     #$40               ;.&XXE688 = *     INC     XXD3          ; INCREMENT CURSOR COLUMN     JSR     XXE6B8          ; IF OPEN QUOTE TOGGLE CURSOR QUOTE FLAG     CPY     XXC8          ; COMPARE WITH INPUT [EOL] POINTER     BNE     XXE6A8          ; BRANCH IF NOT AT LINE END'XXE691 = *     LDA     #$00               ;.     STA     XXD0          ; CLEAR INPUT FROM KEYBOARD OR SCREEN, $XX = SCREEN,                         ; $00 = KEYBOARD     LDA     #$0D               ; SET CHARACTER [CR]     LDX     XX99          ; GET  INPUT DEVICE NUMBER     CPX     #$03               ; COMPARE WITH SCREEN     BEQ     XXE6A3          ; BRANCH IF SCREEN     LDX     XX9A          ; GET OUTPUT DEVICE NUMBER     CPX     #$03               ; COMPARE WITH SCREEN     BEQ     XXE6A6       ; SET '**** CBM BASIC V2 ****' POINTER HIGH BYTE     JSR     XXCB1E          ; PRINT NULL TERMINATED STRING     LDA     XX37          ; GET END OF MEMORY LOW BYTE     SEC                    ; SET CARRY FOR SUBTRACT     SBC     XX2B          ; SUBTRACT START OF MEMORY LOW BYTE     TAX                    ; COPY RESULT TO X     LDA     XX38          ; GET END OF MEMORY HIGH BYTE     SBC     XX2C          ; SUBTRACT START OF MEMORY HIGH BYTE     JSR     XXDDCD          ; PRINT XA AS UNSIGNED INTEGER     LDA     #<XXE429          ; SET ' BYTES FREE' POINTER LOW BYTE     LDY     #>XXE429          ; SET ' BYTES FREE' POINTER HIGH BYTE     JSR     XXCB1E          ; PRINT NULL TERMINATED STRING     JMP     XXC644          ; DO NEW, CLEAR, RESTORE AND RETURN;***********************************************************************************;;XXE429 = *     .BYTE     ' BYTES FREE',$0D,$00XXE436 = *     .BYTE     $93,'**** CBM BASIC V2 ****',$0D,$00;***********************************************************************************;;; BASIC VECTORS, THESE ARE COPIED TO RAM FROM XX0300 ONWARDSXXE44F = *     .WORD     XXC43A          ; ERROR MESSAGE                    XX0300     .WORD     XXC483          ; BASIC WARM START               XX0302     .WORD     XXC57C          ; CRUNCH BASIC TOKENS               XX0304     .WORD     XXC71A          ; UNCRUNCH BASIC TOKENS               XX0306     .WORD     XXC7E4          ; START NEW BASIC CODE               XX0308     .WORD     XXCE86          ; GET ARITHMETIC ELEMENT          XX030A;***********************************************************************************;;; INITIALISE BASIC VECTORSXXE45B = *     LDX     #$0B               ; SET BYTE COUNTXXE45D = *     LDA     XXE44F,X          ; GET BYTE FROM TABLE     STA     XX0300,X          ; SAVE BYTE TO RAM     DEX                    ; DECREMENT INDEX     BPL     XXE45D          ; LOOP IF MORE TO DO     RTS;****************************************************	*******************************;;; BASIC WARM START ENTRY POINTXXE467 = *     JSR     XXFFCC          ; CLOSE INPUT AND OUTPUT CHANNELS     LDA     #$00               ; CLEAR A     STA     XX13          ; SET CURRENT I/O CHANNEL, FLAG DEFAULT    
 JSR     XXC67A          ; FLUSH BASIC STACK AND CLEAR CONTINUE POINTER     CLI                    ; ENABLE INTERRUPTS     JMP     XXC474          ; DO WARM START;***********************************************************************************;;; CHECKSUM BYTE, NOT REFERENCED;XXE475     .BYTE     $E8               ; [PAL];     .BYTE     $41               ; [NTSC];***********************************************************************************;;; REBUILD BASIC LINE CHAINING AND DO RESTOREXXE476 = *     JSR     XXC533          ; REBUILD BASIC LINE CHAINING     JMP     XXC677          ; DO RESTORE, CLEAR STACK AND RETURN;***********************************************************************************;;; SPARE BYTES, NOT REFERENCED;XXE47C     .BYTE     $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF     .BYTE     $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF     .BYTE     $FF,$FF,$FF,$FF;***********************************************************************************;;; SET SERIAL DATA OUT HIGHXXE4A0 = *     LDA     XX912C          ; GET VIA 2 PCR     AND     #$DF               ; SET CB2 LOW, SERIAL DATA OUT HIGH     STA     XX912C          ; SET VIA 2 PCR     RTS;***********************************************************************************;;; SET SERIAL DATA OUT LOWXXE4A9 = *     LDA     XX912C          ; GET VIA 2 PCR     ORA     #$20               ; SET CB2 HIGH, SERIAL DATA OUT LOW     STA     XX912C          ; SET VIA 2 PCR     RTS;***********************************************************************************;;; GET SERIAL CLOCK STATUSXXE4B2 = *     LDA     XX911F          ; GET VIA 1 DRA, NO HANDSHAKE     CMP     XX911F          ; COMPARE WITH SELF     BNE     XXE4B2          ; LOOP IF CHANGING     LSR A                  ; SHIFT SERIAL CLOCK TO CB     RTS;***********************************************************************************;;; GET SECONDAY ADDRESS AND PRINT 'SEARCHING...'XXE4BC = *     LDX     XXB9          ; GET SECONDARY ADDRESS     JMP     XXF647          ; PRINT 'SEARCHING...' AND RETURN;***********************************************************************************;;; SET LOAD ADDRESS IF SECONDARY ADDRESS = 0XXE4C1 = *     TXA                    ; COPY SECONDARY ADDRESS     BNE     XXE4CC          ; LOAD LOCATION NOT SET IN LOAD CALL, SO                         ; CONTINUE WITH LOAD     LDA     XXC3          ; GET LOAD ADDRESS LOW BYTE     STA     XXAE          ; SAVE PROGRAM START ADDRESS LOW BYTE     LDA     XXC4          ; GET LOAD ADDRESS HIGH BYTE     STA     XXAF          ; SAVE PROGRAM START ADDRESS HIGH BYTEXXE4CC = *     JMP     XXF66A          ; DISPLAY 'LOADING' OR 'VERIFYING' AND RETURN;***********************************************************************************;;; PATCH FOR CLOSEXXE4CF = *     JSR     XXF8E3          ; INITIATE TAPE WRITE     BCC     XXE4D7          ; BRANCH IF NO ERROR     PLA                    ; ELSE DUMP STACKED EXIT CODE     LDA     #$00               ; CLEAR EXIT CODEXXE4D7 = *     JMP     XXF39E          ; GO DO I/O CLOSE;***********************************************************************************;;; SPARE BYTES, NOT REFERENCED;XXE4DA     .BYTE     $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF     .BYTE     $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF     .BYTE     $FF,$FF,$FF,$FF,$FF,$FF;***********************************************************************************;;; RETURN BASE ADDRESS OF I/O DEVICES; THIS ROUTINE WILL SET XY TO THE ADDRESS OF THE MEMORY SECTION WHERE THE MEMORY; MAPPED I/O DEVICES ARE LOCATED. THIS ADDRESS CAN THEN BE USED WITH AN OFFSET TO; ACCESS THE MEMORY MAPPED I/O DEVICES IN THE COMPUTER.XXE500 = *     LDX     #<XX9110          ; GET I/O BASE ADDRESS LOW BYTE     LDY     #>XX9110          ; GET I/O BASE ADDRESS HIGH BYTE     RTS;***********************************************************************************;;; RETURN X,Y ORGANIZATION OF SCREEN; THIS ROUTINE RETURNS THE X,Y ORGANISATION OF THE SCREEN IN X,YXXE505 = *     LDX     #$16               ; GET SCREEN X, 22 COLUMNS     LDY     #$17               ; GET SCREEN Y, 23 ROWS     RTS;***********************************************************************************;;; READ/SET X,Y CURSOR POSITION, CB = 1 TO READ, CB = 0 TO SET; THIS ROUTINE, WHEN CALLED WITH THE CARRY FLAG SET, LOADS THE CURRENT POSITION OF; THE CURSOR ON THE SCREEN INTO THE X AND Y REGISTERS. X IS THE COLUMN NUMBER OF; THE CURSOR LOCATION AND Y IS THE ROW NUMBER OF THE CURSOR. A CALL WITH THE CARRY; BIT CLEAR MOVES THE CURSOR TO THE POSITION DETERMINED BY THE X AND Y REGISTERS.XXE50A = *     BCS     XXE513          ; IF READ CURSOR SKIP THE SET CURSOR     STX     XXD6          ; SAVE CURSOR ROW     STY     XXD3          ; SAVE CURSOR COLUMN     JSR     XXE587          ; SET SCREEN POINTERS FOR CURSOR ROW, COLUMNXXE513 = *     LDX     XXD6          ; GET CURSOR ROW     LDY     XXD3          ; GET CURSOR COLUMN     RTS;***********************************************************************************;;; INITIALISE HARDWAREXXE518 = *     JSR     XXE5BB          ; SET DEFAULT DEVICES AND INITIALISE VIC CHIP     LDA     XX0288          ; GET SCREEN MEMORY PAGE     AND     #$FD               ; MASK XXXX XX0X, ALL BUT VA9     ASL A                  ; << 1 XXXX X0X0     ASL A                  ; << 2  XXXX 0X00     ORA     #$80               ; SET  1XXX 0X00     STA     XX9005          ; SET SCREEN AND CHARACTER MEMORY LOCATION     LDA     XX0288          ; GET SCREEN MEMORY PAGE     AND     #$02               ; MASK BIT 9     BEQ     XXE536     !     ; IF ZERO JUST GO NORMALISE SCREEN                         ; ELSE SET VA9 IN VIC CHIP     LDA     #$80               ; SET B7     ORA     XX9002          ; OR IN AS VIDEO ADDRESS 9     STA     XX9002          ; SAVE NEW VA9                   "      ; NOW NORMALISE SCREENXXE536 = *     LDA     #$00               ; CLEAR A     STA     XX0291          ; CLEAR SHIFT MODE SWITCH     STA     XXCF          ; CLEAR CURSOR BLINK PHASE     LDA     #<XXEBDC          ; GET KEYBOARD DECODE LOGIC POIN#TER LOW BYTE     STA     XX028F          ; SET KEYBOARD DECODE LOGIC POINTER LOW BYTE     LDA     #>XXEBDC          ; GET KEYBOARD DECODE LOGIC POINTER HIGH BYTE     STA     XX0290          ; SET KEYBOARD DECODE LOGIC POINTER HIGH BYTE     LDA     #$$0A               ; 10D     STA     XX0289          ; SET MAXIMUM SIZE OF KEYBOARD BUFFER     STA     XX028C          ; SET REPEAT DELAY COUNTER     LDA     #$06               ; COLOUR BLUE     STA     XX0286          ; SET CURRENT COLOUR CODE     LD%A     #$04               ; SPEED 4     STA     XX028B          ; SET REPEAT SPEED COUNTER     LDA     #$0C               ; CURSOR FLASH TIMING     STA     XXCD          ; SET CURSOR TIMING COUNTDOWN     STA     XXCC          ; SET CURSOR ENABLE, $00 &= FLASH CURSOR; CLEAR SCREENXXE55F = *     LDA     XX0288          ; GET SCREEN MEMORY PAGE     ORA     #$80               ; SET HIGH BIT, FLAG EVERY LINE IS LOGICAL LINE START     TAY                    ; COPY TO Y     LDA     #$00              ' ; CLEAR LINE START LOW BYTE     TAX                    ; CLEAR INDEXXXE568 = *     STY     XXD9,X          ; SAVE START OF LINE X POINTER HIGH BYTE     CLC                    ; CLEAR CARRY FOR ADD     ADC     #$16               ; ADD LINE LENGTH TO  LOW BYTE     BCC     XXE570          ; IF NO ROLLOVER SKIP THE HIGH BYTE INCREMENT     INY                    ; ELSE INCREMENT HIGH BYTEXXE570 = *     INX                    ; INCREMENT LINE INDEX     CPX     #$18               ; COMPARE WITH NUMB                 ; ELSE CORRECT FAC1     JSR     XXDFB4          ; DO - FAC1XXE2AA = *     LDA     #<XXE2EC          ; SET POINTER LOW BYTE TO COUNTER     LDY     #>XXE2EC          ; SET POINTER HIGH BYTE TO COUNTER     JMP     XXE040          ; ^2 THEN SERIES EVALUATION AND RETURN;***********************************************************************************;;; PERFORM TAN()XXE2B1 = *     JSR     XXDBCA          ; PACK FAC1 INTO XX57     LDA     #$00               ; CLEAR A     STA     XX12          ; CLEAR THE COMPARISON EVALUATION FLAG     JSR     XXE268          ; PERFORM SIN()     LDX     #<XX4E          ; SET SIN(N) POINTER LOW BYTE     LDY     #>XX4E          ; SET SIN(N) POINTER HIGH BYTE     JSR     XXE0F3          ; PACK FAC1 INTO (XY)     LDA     #<XX57          ; SET N POINTER LOW BYTE     LDY     #>XX57          ; SET N POINTER HIGH BYTE     JSR     XXDBA2          ; UNPACK MEMORY (AY) INTO FAC1     LDA     #$00               ; CLEAR BYTE     STA     XX66          ; CLEAR FAC1 SIGN (B7)     LDA     XX12          ; GET THE COMPARISON EVALUATION FLAG     JSR     XXE2D9          ; SAVE FLAG AND GO DO SERIES EVALUATION     LDA     #<XX4E          ; SET SIN(N) POINTER LOW BYTE     LDY     #>XX4E          ; SET SIN(N) POINTER HIGH BYTE     JMP     XXDB0F          ; CONVERT AY AND DO (AY)/FAC1;***********************************************************************************;;; SAVE COMPARISON FLAG AND DO SERIES EVALUATIONXXE2D9 = *     PHA                    ; SAVE COMPARISON FLAG     JMP     XXE29A          ; ADD 0.25, ^2 THEN SERIES EVALUATION;***********************************************************************************;;; CONSTANTS AND SERIES FOR SIN/COS(N)XXE2DD = *     .BYTE     $81,$49,$0F,$DA,$A2     ; 1.570796371, PI/2, AS FLOATING NUMBERXXE2E2 = *     .BYTE     $83,$49,$0F,$DA,$A2     ; 6.28319, 2*PI, AS FLOATING NUMBERXXE2E7 = *     .BYTE     $7F,$00,$00,$00,$00     ; 0.25XXE2EC = *     .BYTE     $05                 	   ; SERIES COUNTER     .BYTE     $84,$E6,$1A,$2D,$1B     ; -14.3813907     .BYTE     $86,$28,$07,$FB,$F8     ;  42.0077971     .BYTE     $87,$99,$68,$89,$01     ; -76.7041703     .BYTE     $87,$23,$35,$DF,$E1     ;  81.6052237     .BYTE     $86,$A5
,$5D,$E7,$28     ; -41.3417021     .BYTE     $83,$49,$0F,$DA,$A2     ;  6.28318531;***********************************************************************************;;; PERFORM ATN()XXE30B = *     LDA     XX66          ; GET FAC1 SIGN (B7)     PHA                    ; SAVE SIGN     BPL     XXE313          ; BRANCH IF +VE     JSR     XXDFB4          ; ELSE DO - FAC1XXE313 = *     LDA     XX61          ; GET FAC1 EXPONENT     PHA                    ; PUSH EXPONENT     CMP     #$81               ; COMPARE WITH 1     BCC     XXE321          ; BRANCH IF FAC1 < 1     LDA     #<XXD9BC          ; POINTER TO 1 LOW BYTE     LDY     #>XXD9BC          ; POINTER TO 1 HIGH BYTE     JSR     XXDB0F          ; CONVERT AY AND DO (AY)/FAC1XXE321 = *     LDA     #<XXE33B          ; POINTER TO SERIES LOW BYTE     LDY     #>XXE33B          ; POINTER TO SERIES HIGH BYTE     JSR     XXE040          ; ^2 THEN SERIES EVALUATION     PLA                    ; RESTORE OLD FAC1 EXPONENT     CMP     #$81               ; COMPARE WITH 1     BCC     XXE334          ; BRANCH IF FAC1 < 1     LDA     #<XXE2DD          ; POINTER TO (PI/2) LOW BYTE     LDY     #>XXE2DD          ; POINTER TO (PI/2) LOW BYTE     JSR     XXD850          ; PERFORM SUBTRACTION, FAC1 FROM (AY)XXE334 = *     PLA                    ; RESTORE FAC1 SIGN     BPL     XXE33A          ; EXIT IF WAS +VE     JMP     XXDFB4          ; ELSE DO - FAC1 AND RETURNXXE33A = *     RTS;***********************************************************************************;;; SERIES FOR ATN(N)XXE33B = *     .BYTE     $0B                    ; SERIES COUNTER     .BYTE     $76,$B3,$83,$BD,$D3     ;-6.84793912E-04     .BYTE     $79,$1E,$F4,$A6,$F5     ; 4.85094216E-03     .BYTE     $7B,$83,$FC,$B0,$10     ;-0.0161117015     .BYTE     $7C,$0C,$1F,$67,$CA     ; 0.034209638     .BYTE     $7C,$DE,$53,$CB,$C1     ;-0.054279133     .BYTE     $7D,$14,$64,$70,$4C     ; 0.0724571965     .BYTE     $7D,$B7,$EA,$51,$7A     ;-0.0898019185     .BYTE     $7D,$63,$30,$88,$7E     ; 0.110932413     .BYTE     $7E,$92,$44,$99,$3A     ;-0.142839808     .BYTE     $7E,$4C,$CC,$91,$C7     ; 0.19999912     .BYTE     $7F,$AA,$AA,$AA,$13     ;-0.333333316     .BYTE     $81,$00,$00,$00,$00     ; 1.000000000;***********************************************************************************;;; BASIC COLD START ENTRY POINTXXE378 = *     JSR     XXE45B          ; INITIALISE BASIC VECTOR TABLE     JSR     XXE3A4          ; INITIALISE BASIC RAM LOCATIONS     JSR     XXE404          ; PRINT START UP MESSAGE AND INITIALISE MEMORY POINTERS     LDX     #$FB               ; VALUE FOR START STACK     TXS                    ; SET STACK POINTER     JMP     XXC474          ; DO 'READY.' WARM START;***********************************************************************************;;; CHARACTER GET SUBROUTINE FOR ZERO PAGE; THE TARGET ADDRESS FOR THE LDA XXEA60 BECOMES THE BASIC EXECUTE POINTER ONCE THE; BLOCK IS COPIED TO IT'S DESTINATION, ANY NON ZERO PAGE ADDRESS WILL DO AT ASSEMBLY; TIME, TO ASSEMBLE A THREE BYTE INSTRUCTION.; PAGE 0 INITIALISATION TABLE FROM XX0073; INCREMENT AND SCAN MEMORYXXE387 = *     INC     XX7A          ; INCREMENT BASIC EXECUTE POINTER LOW BYTE     BNE     XXE38D          ; BRANCH IF NO CARRY                         ; ELSE     INC     XX7B          ; INCREMENT BASIC EXECUTE POINTER HIGH BYTE; PAGE 0 INITIALISATION TABLE FROM XX0079; SCAN MEMORYXXE38D = *     LDA     XXEA60          ; GET BYTE TO SCAN, ADDRESS SET BY CALL ROUTINE     CMP     #':'               ; COMPARE WITH ':'     BCS     XXE39E          ; EXIT IF>=; PAGE 0 INITIALISATION TABLE FROM XX0080; CLEAR CB IF NUMERIC     CMP     #' '               ; COMPARE WITH ' '     BEQ     XXE387          ; IF ' ' GO DO NEXT     SEC                    ; SET CARRY FOR SBC     SBC     #'0'               ; SUBTRACT '0'     SEC                    ; SET CARRY FOR SBC     SBC     #$D0               ; SUBTRACT -'0'                         ; CLEAR CARRY IF BYTE = '0'-'9'XXE39E = *     RTS;***********************************************************************************;;; SPARE BYTES, NOT REFERENCED;XXE39F     .BYTE     $80,$4F,$C7,$52,$58                         ; 0.811635157;***********************************************************************************;;; INITIALISE BASIC RAM LOCATIONSXXE3A4 = *     LDA     #$4C               ; OPCODE FOR JMP     STA     XX54          ; SAVE FOR FUNCTIONS VECTOR JUMP     STA     XX00          ; SAVE FOR USR() VECTOR JUMP                         ; SET USR() VECTOR TO ILLEGAL QUANTITY ERROR     LDA     #<XXD248          ; SET USR() VECTOR LOW BYTE     LDY     #>XXD248          ; SET USR() VECTOR HIGH BYTE     STA     XX01          ; SAVE USR() VECTOR LOW BYTE     STY     XX02          ; SAVE USR() VECTOR HIGH BYTE     LDA     #<XXD391          ; SET FIXED TO FLOAT VECTOR LOW BYTE     LDY     #>XXD391          ; SET FIXED TO FLOAT VECTOR HIGH BYTE     STA     XX05          ; SAVE FIXED TO FLOAT VECTOR LOW BYTE     STY     XX06          ; SAVE FIXED TO FLOAT VECTOR HIGH BYTE     LDA     #<XXD1AA          ; SET FLOAT TO FIXED VECTOR LOW BYTE     LDY     #>XXD1AA          ; SET FLOAT TO FIXED VECTOR HIGH BYTE     STA     XX03          ; SAVE FLOAT TO FIXED VECTOR LOW BYTE     STY     XX04          ; SAVE FLOAT TO FIXED VECTOR HIGH BYTE; COPY BLOCK FROM XXE387 TO XX0074     LDX     #$1C               ; SET BYTE COUNTXXE3C4 = *     LDA     XXE387,X          ; G ET BYTE FROM TABLE     STA     XX0073,X          ; SAVE BYTE IN PAGE ZERO     DEX                    ; DECREMENT COUNT     BPL     XXE3C4          ; LOOP IF NOT ALL DONE     LDA     #$03               ; SET STEP SIZE, COLLECTING DESCRIPTORS     STA!     XX53          ; SAVE GARBAGE COLLECTION STEP SIZE     LDA     #$00               ; CLEAR A     STA     XX68          ; CLEAR FAC1 OVERFLOW BYTE     STA     XX13          ; CLEAR CURRENT I/O CHANNEL, FLAG DEFAULT     STA     XX18          ; CLEAR" CURRENT DESCRIPTOR STACK ITEM POINTER HIGH BYTE     LDX     #$01               ; SET X     STX     XX01FD          ; SET CHAIN LINK POINTER LOW BYTE     STX     XX01FC          ; SET CHAIN LINK POINTER HIGH BYTE     LDX     #XX19          ; INITIAL #VALUE FOR DESCRIPTOR STACK     STX     XX16          ; SET DESCRIPTOR STACK POINTER     SEC                    ; SET CB = 1 TO READ THE BOTTOM OF MEMORY     JSR     XXFF9C          ; READ/SET THE BOTTOM OF MEMORY     STX     XX2B          ; SAVE STAR$T OF MEMORY LOW BYTE     STY     XX2C          ; SAVE START OF MEMORY HIGH BYTE     SEC                    ; SET CB = 1 TO READ THE TOP OF MEMORY     JSR     XXFF99          ; READ/SET THE TOP OF MEMORY     STX     XX37          ; SAVE END OF MEMORY %LOW BYTE     STY     XX38          ; SAVE END OF MEMORY HIGH BYTE     STX     XX33          ; SET BOTTOM OF STRING SPACE LOW BYTE     STY     XX34          ; SET BOTTOM OF STRING SPACE HIGH BYTE     LDY     #$00               ; CLEAR INDEX     TYA  &                  ; CLEAR A     STA     (XX2B),Y          ; CLEAR FIRST BYTE OF MEMORY     INC     XX2B          ; INCREMENT START OF MEMORY LOW BYTE     BNE     XXE403          ; BRANCH IF NO ROLLOVER     INC     XX2C          ; INCREMENT START OF 'MEMORY HIGH BYTEXXE403 = *     RTS;***********************************************************************************;;; PRINT START UP MESSAGE AND INITIALISE MEMORY POINTERSXXE404 = *     LDA     XX2B          ; GET START OF MEMORY LOW BYTE      LDY     XX2C          ; GET START OF MEMORY HIGH BYTE     JSR     XXC408          ; CHECK AVAILABLE MEMORY, DO OUT OF MEMORY ERROR IF NO ROOM     LDA     #<XXE436          ; SET '**** CBM BASIC V2 ****' POINTER LOW BYTE     LDY     #>XXE436       *******;;; PERFORM VERIFYXXE162 = *     LDA     #$01               ; FLAG VERIFY     .BYTE     $2C               ; MAKES NEXT LINE BIT XX00A9;***********************************************************************************;;; PERFORM LOADXXE165 = *     LDA     #$00               ; FLAG LOAD     STA     XX0A          ; SET LOAD/VERIFY FLAG     JSR     XXE1D1          ; GET PARAMETERS FOR LOAD/SAVE     LDA     XX0A          ; GET LOAD/VERIFY FLAG     LDX     XX2B          ; GET START OF MEMORY LOW BYTE     LDY     XX2C          ; GET START OF MEMORY HIGH BYTE     JSR     XXFFD5          ; LOAD RAM FROM A DEVICE     BCS     XXE1CE          ; IF ERROR GO HANDLE BASIC I/O ERROR     LDA     XX0A          ; GET LOAD/VERIFY FLAG     BEQ     XXE195          ; BRANCH IF LOAD     LDX     #$1C               ; ERROR $1C, VERIFY ERROR     JSR     XXFFB7          ; READ I/O STATUS WORD     AND     #$10               ; MASK FOR TAPE READ ERROR     BEQ     XXE187          ; BRANCH IF NO READ ERROR     JMP     XXC437          ; DO ERROR #X THEN WARM STARTXXE187 = *     LDA     XX7A          ; GET BASIC EXECUTE POINTER LOW BYTE                         ; IS THIS CORRECT ?? WON'T THIS MEAN THE 'OK' PROMPT                         ; WHEN DOING A LOAD FROM WITHIN A PROGRAM ?     CMP     #$02               ;.     BEQ     XXE194          ; IF ?? SKIP 'OK' PROMPT     LDA     #<XXC364          ; SET 'OK' POINTER LOW BYTE     LDY     #>XXC364          ; SET 'OK' POINTER HIGH BYTE     JMP     XXCB1E          ; PRINT NULL TERMINATED STRINGXXE194 = *     RTS;***********************************************************************************;;; DO READY RETURN TO BASIC ??XXE195 = *     JSR     XXFFB7          ; READ I/O STATUS WORD     AND     #$BF               ; MASK X0XX XXXX, CLEAR READ ERROR     BEQ     XXE1A1          ; BRANCH IF NO ERRORS     LDX     #$1D               ; ERROR $1D, LOAD ERROR     JMP     XXC437          ; DO ERROR #X THEN WARM STARTXXE1A1 = * 	    LDA     XX7B          ; GET BASIC EXECUTE POINTER HIGH BYTE     CMP     #$02               ; COMPARE WITH $02XX     BNE     XXE1B5          ; BRANCH IF NOT IMMEDIATE MODE     STX     XX2D          ; SET START OF VARIABLES LOW BYTE     STY     XX
2E          ; SET START OF VARIABLES HIGH BYTE     LDA     #<XXC376          ; SET 'READY.' POINTER LOW BYTE     LDY     #>XXC376          ; SET 'READY.' POINTER HIGH BYTE     JSR     XXCB1E          ; PRINT NULL TERMINATED STRING     JMP     XXC52A          ; RESET EXECUTION, CLEAR VARIABLES, FLUSH STACK,                         ; REBUILD BASIC CHAIN AND DO WARM STARTXXE1B5 = *     JSR     XXC68E          ; SET BASIC EXECUTE POINTER TO START OF MEMORY - 1     JMP     XXE476          ; REBUILD BASIC LINE CHAINING, DO RESTORE AND RETURN;***********************************************************************************;;; PERFORM OPENXXE1BB = *     JSR     XXE216          ; GET PARAMETERS FOR OPEN/CLOSE     JSR     XXFFC0          ; OPEN A LOGICAL FILE     BCS     XXE1CE          ; BRANCH IF ERROR     RTS;***********************************************************************************;;; PERFORM CLOSEXXE1C4 = *     JSR     XXE216          ; GET PARAMETERS FOR OPEN/CLOSE     LDA     XX49          ; GET LOGICAL FILE NUMBER     JSR     XXFFC3          ; CLOSE A SPECIFIED LOGICAL FILE     BCC     XXE194          ; EXIT IF NO ERRORXXE1CE = *     JMP     XXE0F6          ; GO HANDLE BASIC I/O ERROR;***********************************************************************************;;; GET PARAMETERS FOR LOAD/SAVEXXE1D1 = *     LDA     #$00               ; CLEAR FILE NAME LENGTH     JSR     XXFFBD          ; CLEAR FILENAME     LDX     #$01               ; SET DEFAULT DEVICE NUMBER, CASSETTE     LDY     #$00               ; SET DEFAULT COMMAND     JSR     XXFFBA          ; SET LOGICAL, FIRST AND SECOND ADDRESSES     JSR     XXE203          ; EXIT FUNCTION IF [EOT] OR ':'     JSR     XXE254          ; SET FILENAME     JSR     XXE203          ; EXIT FUNCTION IF [EOT] OR ':'     JSR     XXE1FD          ; SCAN AND GET BYTE, ELSE DO SYNTAX ERROR THEN WARM START     LDY     #$00               ; CLEAR COMMAND     STX     XX49          ; SAVE DEVICE NUMBER     JSR     XXFFBA          ; SET LOGICAL, FIRST AND SECOND ADDRESSES     JSR     XXE203          ; EXIT FUNCTION IF [EOT] OR ':'     JSR     XXE1FD          ; SCAN AND GET BYTE, ELSE DO SYNTAX ERROR THEN WARM START     TXA                    ; COPY COMMAND TO A     TAY                    ; COPY COMMAND TO Y     LDX     XX49          ; GET DEVICE NUMBER BACK     JMP     XXFFBA          ; SET LOGICAL, FIRST AND SECOND ADDRESSES AND RETURN;***********************************************************************************;;; SCAN AND GET BYTE, ELSE DO SYNTAX ERROR THEN WARM STARTXXE1FD = *     JSR     XXE20B          ; SCAN FOR ',BYTE', ELSE DO SYNTAX ERROR THEN WARM START     JMP     XXD79E          ; GET BYTE PARAMETER AND RETURN;***********************************************************************************;;; EXIT FUNCTION IF [EOT] OR ':'XXE203 = *     JSR     XX0079          ; SCAN MEMORY     BNE     XXE20A          ; BRANCH IF NOT [EOL] OR ':'     PLA                    ; DUMP RETURN ADDRESS LOW BYTE     PLA                    ; DUMP RETURN ADDRESS HIGH BYTEXXE20A = *     RTS;***********************************************************************************;;; SCAN FOR ',VALID BYTE', ELSE DO SYNTAX ERROR THEN WARM STARTXXE20B = *     JSR     XXCEFD          ; SCAN FOR ',', ELSE DO SYNTAX ERROR THEN WARM START; SCAN FOR VALID BYTE, NOT [EOL] OR ':', ELSE DO SYNTAX ERROR THEN WARM STARTXXE20E = *     JSR     XX0079          ; SCAN MEMORY     BNE     XXE20A          ; EXIT IF FOLLOWING BYTE     JMP     XXCF08          ; ELSE DO SYNTAX ERROR THEN WARM START;***********************************************************************************;;; GET PARAMETERS FOR OPEN/CLOSEXXE216 = *     LDA     #$00               ; CLEAR FILE NAME LENGTH     JSR     XXFFBD          ; CLEAR FILENAME     JSR     XXE20E          ; SCAN FOR VALID BYTE, ELSE DO SYNTAX ERROR THEN WARM START     JSR     XXD79E          ; GET BYTE PARAMETER, LOGICAL FILE NUMBER     STX     XX49          ; SAVE LOGICAL FILE NUMBER     TXA                    ; COPY LOGICAL FILE NUMBER TO A     LDX     #$01               ; SET DEFAULT DEVICE NUMBER, CASSETTE     LDY     #$00               ; SET DEFAULT COMMAND     JSR     XXFFBA          ; SET LOGICAL, FIRST AND SECOND ADDRESSES     JSR     XXE203          ; EXIT FUNCTION IF [EOT] OR ':'     JSR     XXE1FD          ; SCAN AND GET BYTE, ELSE DO SYNTAX ERROR THEN WARM START     STX     XX4A          ; SAVE DEVICE NUMBER     LDY     #$00               ; CLEAR COMMAND     LDA     XX49          ; GET LOGICAL FILE NUMBER     CPX     #$03               ; COMPARE DEVICE NUMBER WITH SCREEN     BCC     XXE23C          ; BRANCH IF LESS THAN SCREEN     DEY                    ; ELSE DECREMENT COMMANDXXE23C = *     JSR     XXFFBA          ; SET LOGICAL, FIRST AND SECOND ADDRESSES     JSR     XXE203          ; EXIT FUNCTION IF [EOT] OR ':'     JSR     XXE1FD          ; SCAN AND GET BYTE, ELSE DO SYNTAX ERROR THEN WARM START     TXA                    ; COPY COMMAND TO A     TAY                    ; COPY COMMAND TO Y     LDX     XX4A          ; GET DEVICE NUMBER     LDA     XX49          ; GET LOGICAL FILE NUMBER     JSR     XXFFBA          ; SET LOGICAL, FIRST AND SECOND ADDRESSES     JSR     XXE203          ; EXIT FUNCTION IF [EOT] OR ':'     JSR     XXE20B          ; SCAN FOR ',BYTE', ELSE DO SYNTAX ERROR THEN WARM START;***********************************************************************************;;; SET FI LENAMEXXE254 = *     JSR     XXCD9E          ; EVALUATE EXPRESSION     JSR     XXD6A3          ; EVALUATE STRING     LDX     XX22          ; GET STRING POINTER LOW BYTE     LDY     XX23          ; GET STRING POINTER HIGH BYTE     JMP     XXFFBD   !       ; SET FILENAME AND RETURN;***********************************************************************************;;; PERFORM COS()XXE261 = *     LDA     #<XXE2DD          ; SET PI/2 POINTER LOW BYTE     LDY     #>XXE2DD          ; SET PI/2 PO"INTER HIGH BYTE     JSR     XXD867          ; ADD (AY) TO FAC1;***********************************************************************************;;; PERFORM SIN()XXE268 = *     JSR     XXDC0C          ; ROUND AND COPY FAC1 TO FAC2     LDA     ##<XXE2E2          ; SET 2*PI POINTER LOW BYTE     LDY     #>XXE2E2          ; SET 2*PI POINTER HIGH BYTE     LDX     XX6E          ; GET FAC2 SIGN (B7)     JSR     XXDB07          ; DIVIDE BY (AY) (X=SIGN)     JSR     XXDC0C          ; ROUND AND COPY$ FAC1 TO FAC2     JSR     XXDCCC          ; PERFORM INT()     LDA     #$00               ; CLEAR BYTE     STA     XX6F          ; CLEAR SIGN COMPARE (FAC1 EOR FAC2)     JSR     XXD853          ; PERFORM SUBTRACTION, FAC2 FROM FAC1     LDA     #<XXE2%E7          ; SET 0.25 POINTER LOW BYTE     LDY     #>XXE2E7          ; SET 0.25 POINTER HIGH BYTE     JSR     XXD850          ; PERFORM SUBTRACTION, FAC1 FROM (AY)     LDA     XX66          ; GET FAC1 SIGN (B7)     PHA                    ; SAVE FAC1& SIGN     BPL     XXE29A          ; BRANCH IF +VE                         ; FAC1 SIGN WAS -VE     JSR     XXD849          ; ADD 0.5 TO FAC1 (ROUND FAC1)     LDA     XX66          ; GET FAC1 SIGN (B7)     BMI     XXE29D          ; BRANCH IF -VE   '  LDA     XX12          ; GET THE COMPARISON EVALUATION FLAG     EOR     #$FF               ; TOGGLE FLAG     STA     XX12          ; SAVE THE COMPARISON EVALUATION FLAGXXE29A = *     JSR     XXDFB4          ; DO - FAC1XXE29D = *     LDA     #<XXE2 E7          ; SET 0.25 POINTER LOW BYTE     LDY     #>XXE2E7          ; SET 0.25 POINTER HIGH BYTE     JSR     XXD867          ; ADD (AY) TO FAC1     PLA                    ; RESTORE FAC1 SIGN     BPL     XXE2AA          ; BRANCH IF WAS +VE         XXD853          ; PERFORM SUBTRACTION, FAC2 FROM FAC1     JSR     XXDFB4          ; DO - FAC1     LDA     #<XXDFC4          ; SET COUNTER POINTER LOW BYTE     LDY     #>XXDFC4          ; SET COUNTER POINTER HIGH BYTE     JSR     XXE056          ; GO DO SERIES EVALUATION     LDA     #$00               ; CLEAR A     STA     XX6F          ; CLEAR SIGN COMPARE (FAC1 EOR FAC2)     PLA                    ; PULL THE SAVED FAC2 EXPONENT     JSR     XXDAB9          ; TEST AND ADJUST ACCUMULATORS     RTS;***********************************************************************************;;; ^2 THEN SERIES EVALUATIONXXE040 = *     STA     XX71          ; SAVE COUNT POINTER LOW BYTE     STY     XX72          ; SAVE COUNT POINTER HIGH BYTE     JSR     XXDBCA          ; PACK FAC1 INTO XX57     LDA     #<XX57          ; SET POINTER LOW BYTE (Y ALREADY $00)     JSR     XXDA28          ; DO CONVERT AY, FCA1*(AY)     JSR     XXE05A          ; GO DO SERIES EVALUATION     LDA     #<XX57          ; POINTER TO ORIGINAL # LOW BYTE     LDY     #>XX57          ; POINTER TO ORIGINAL # HIGH BYTE     JMP     XXDA28          ; DO CONVERT AY, FCA1*(AY);***********************************************************************************;;; DO SERIES EVALUATIONXXE056 = *     STA     XX71          ; SAVE COUNT POINTER LOW BYTE     STY     XX72          ; SAVE COUNT POINTER HIGH BYTE; DO SERIES EVALUATIONXXE05A = *     JSR     XXDBC7          ; PACK FAC1 INTO XX5C     LDA     (XX71),Y          ; GET CONSTANTS COUNT     STA     XX67          ; SAVE CONSTANTS COUNT     LDY     XX71          ; GET COUNT POINTER LOW BYTE     INY                    ; INCREMENT IT (NOW CONSTANTS POINTER)     TYA                    ; COPY IT     BNE     XXE069          ; SKIP NEXT IF NO OVERFLOW     INC     XX72          ; ELSE INCREMENT HIGH BYTEXXE069 = *     STA     XX71          ; SAVE LOW BYTE     LDY     XX72          ; GET HIGH BYTEXXE06D = *     JSR     XXDA28          ; DO CONVERT AY, FCA1*(AY)	     LDA     XX71          ; GET CONSTANTS POINTER LOW BYTE     LDY     XX72          ; GET CONSTANTS POINTER HIGH BYTE     CLC                    ; CLEAR CARRY FOR ADD     ADC     #$05               ; +5 TO LOW POINTER (5 BYTES PER CONSTANT)     BCC
     XXE07A          ; SKIP NEXT IF NO OVERFLOW     INY                    ; INCREMENT HIGH BYTEXXE07A = *     STA     XX71          ; SAVE POINTER LOW BYTE     STY     XX72          ; SAVE POINTER HIGH BYTE     JSR     XXD867          ; ADD (AY) TO FAC1     LDA     #<XX5C          ; SET POINTER LOW BYTE TO PARTIAL     LDY     #>XX5C          ; SET POINTER HIGH BYTE TO PARTIAL     DEC     XX67          ; DECREMENT CONSTANTS COUNT     BNE     XXE06D          ; LOOP UNTIL ALL DONE     RTS;***********************************************************************************;;; RND VALUESXXE08A = *     .BYTE     $98,$35,$44,$7A,$00                         ; 11879546               MULTIPLIERXXE08F = *     .BYTE     $68,$28,$B1,$46,$00                         ; 3.927677739E-8          OFFSET;***********************************************************************************;;; PERFORM RND()XXE094 = *     JSR     XXDC2B          ; GET FAC1 SIGN                         ; RETURN A = $FF -VE, A = $01 +VE     BMI     XXE0D0          ; IF N<0 COPY BYTE SWAPPED FAC1 INTO RND() SEED     BNE     XXE0BB          ; IF N>0 GET NEXT NUMBER IN RND() SEQUENCE                         ; ELSE N=0 SO GET THE RND() NUMBER FROM VIA 1 TIMERS     JSR     XXFFF3          ; RETURN BASE ADDRESS OF I/O DEVICES     STX     XX22          ; SAVE POINTER LOW BYTE     STY     XX23          ; SAVE POINTER HIGH BYTE     LDY     #$04               ; SET INDEX TO T1 LOW BYTE     LDA     (XX22),Y          ; GET T1 LOW BYTE     STA     XX62          ; SAVE FAC1 MANTISSA 1     INY                    ; INCREMENT INDEX     LDA     (XX22),Y          ; GET T1 HIGH BYTE     STA     XX64          ; SAVE FAC1 MANTISSA 3     LDY     #$08               ; SET INDEX TO T2 LOW BYTE     LDA     (XX22),Y          ; GET T2 LOW BYTE     STA     XX63          ; SAVE FAC1 MANTISSA 2     INY                    ; INCREMENT INDEX     LDA     (XX22),Y          ; GET T2 HIGH BYTE     STA     XX65          ; SAVE FAC1 MANTISSA 4     JMP     XXE0E0          ; SET EXPONENT AND EXITXXE0BB = *     LDA     #<XX008B          ; SET SEED POINTER LOW ADDRESS     LDY     #>XX008B          ; SET SEED POINTER HIGH ADDRESS     JSR     XXDBA2          ; UNPACK MEMORY (AY) INTO FAC1     LDA     #<XXE08A          ; SET 11879546 POINTER LOW BYTE     LDY     #>XXE08A          ; SET 11879546 POINTER HIGH BYTE     JSR     XXDA28          ; DO CONVERT AY, FCA1*(AY)     LDA     #<XXE08F          ; SET 3.927677739E-8 POINTER LOW BYTE     LDY     #>XXE08F          ; SET 3.927677739E-8 POINTER HIGH BYTE     JSR     XXD867          ; ADD (AY) TO FAC1XXE0D0 = *     LDX     XX65          ; GET FAC1 MANTISSA 4     LDA     XX62          ; GET FAC1 MANTISSA 1     STA     XX65          ; SAVE FAC1 MANTISSA 4     STX     XX62          ; SAVE FAC1 MANTISSA 1     LDX     XX63          ; GET FAC1 MANTISSA 2     LDA     XX64          ; GET FAC1 MANTISSA 3     STA     XX63          ; SAVE FAC1 MANTISSA 2     STX     XX64          ; SAVE FAC1 MANTISSA 3XXE0E0 = *     LDA     #$00               ; CLEAR BYTE     STA     XX66          ; CLEAR FAC1 SIGN (ALWAYS +VE)     LDA     XX61          ; GET FAC1 EXPONENT     STA     XX70          ; SAVE FAC1 ROUNDING BYTE     LDA     #$80               ; SET EXPONENT = $80     STA     XX61          ; SAVE FAC1 EXPONENT     JSR     XXD8D7          ; NORMALISE FAC1     LDX     #<XX008B          ; SET SEED POINTER LOW ADDRESS     LDY     #>XX008B          ; SET SEED POINTER HIGH ADDRESS;***********************************************************************************;;; PACK FAC1 INTO (XY)XXE0F3 = *     JMP     XXDBD4          ; PACK FAC1 INTO (XY);***********************************************************************************;;; HANDLE BASIC I/O ERRORXXE0F6 = *     CMP     #$F0               ; COMPARE ERROR WITH $F0     BNE     XXE101          ; BRANCH IF NOT $F0     STY     XX38          ; SET END OF MEMORY HIGH BYTE     STX     XX37          ; SET END OF MEMORY LOW BYTE     JMP     XXC663          ; CLEAR FROM START TO END AND RETURN                         ; ERROR WAS NOT $F0XXE101 = *     TAX                    ; COPY ERROR #     BNE     XXE106          ; BRANCH IF NOT $00     LDX     #$1E               ; ELSE ERROR $1E, BREAK ERRORXXE106 = *     JMP     XXC437          ; DO ERROR #X THEN WARM START;***********************************************************************************;;; OUTPUT CHARACTER TO CHANNEL WITH ERROR CHECKXXE109 = *     JSR     XXFFD2          ; OUTPUT CHARACTER TO CHANNEL     BCS     XXE0F6          ; IF ERROR GO HANDLE BASIC I/O ERROR     RTS;***********************************************************************************;;; INPUT CHARACTER FROM CHANNEL WITH ERROR CHECKXXE10F = *     JSR     XXFFCF          ; INPUT CHARACTER FROM CHANNEL     BCS     XXE0F6          ; IF ERROR GO HANDLE BASIC I/O ERROR     RTS;***********************************************************************************;;; OPEN CHANNEL FOR OUTPUT WITH ERROR CHECKXXE115 = *     JSR     XXFFC9          ; OPEN CHANNEL FOR OUTPUT     BCS     XXE0F6          ; IF ERROR GO HANDLE BASIC I/O ERROR     RTS;***********************************************************************************;;; OPEN CHANNEL FOR INPUT WITH ERROR CHECKXXE11B = *     JSR     XXFFC6          ; OPEN CHANNEL FOR INPUT     BCS     XXE0F6          ; IF ERROR GO HANDLE BASIC I/O ERROR     RTS;*********************************** ************************************************;;; GET CHARACTER FROM INPUT DEVICE WITH ERROR CHECKXXE121 = *     JSR     XXFFE4          ; GET CHARACTER FROM INPUT DEVICE     BCS     XXE0F6          ; IF ERROR GO HANDLE BASIC I/O ERROR     RTS!;***********************************************************************************;;; PERFORM SYSXXE127 = *     JSR     XXCD8A          ; EVALUATE EXPRESSION AND CHECK IS NUMERIC, ELSE DO                         ; TYPE MISMATCH     JSR     XXD"7F7          ; CONVERT FAC_1 TO INTEGER IN TEMPORARY INTEGER     LDA     #>XXE143          ; GET RETURN ADDRESS HIGH BYTE     PHA                    ; PUSH AS RETURN ADDRESS     LDA     #<XXE143          ; GET RETURN ADDRESS LOW BYTE     PHA         #           ; PUSH AS RETURN ADDRESS     LDA     XX030F          ; GET SAVED STATUS REGISTER     PHA                    ; PUT ON STACK     LDA     XX030C          ; GET SAVED A     LDX     XX030D          ; GET SAVED X     LDY     XX030E          ; G$ET SAVED Y     PLP                    ; PULL PROCESSOR STATUS     JMP     (XX14)          ; CALL SYS ADDRESS; TAIL END OF THE SYS CODE;; THE XXE143 IS NEEDED BECAUSE THE FOLLOWING CODE IS TO BE EXECUTED ONCE THE USER CODE; RETURNS. THIS IS DONE BY% PUSHING THE TARGET RETURN ADDRESS - 1 ONTO THE STACKXXE143     = *-1;XXE144     PHP                    ; SAVE STATUS     STA     XX030C          ; SAVE RETURNED A     STX     XX030D          ; SAVE RETURNED X     STY     XX030E          ; SAVE RE&TURNED Y     PLA                    ; RESTORE SAVED STATUS     STA     XX030F          ; SAVE STATUS     RTS;***********************************************************************************;;; PERFORM SAVEXXE153 = *     JSR     XXE1D1      '    ; GET PARAMETERS FOR LOAD/SAVE     LDX     XX2D          ; GET START OF VARIABLES LOW BYTE     LDY     XX2E          ; GET START OF VARIABLES HIGH BYTE     LDA     #XX2B          ; INDEX TO START OF PROGRAM MEMORY     JSR     XXFFD8          ; SA VE RAM TO DEVICE, A = INDEX TO START ADDRESS, XY = END                         ; ADDRESS LOW/HIGH     BCS     XXE0F6          ; IF ERROR GO HANDLE BASIC I/O ERROR     RTS;****************************************************************************EFORE THE DP     BNE     XXDEB2          ; IF STILL CHARACTERS TO DO SKIP THE DECIMAL POINT                         ; ELSE OUTPUT THE POINT     LDA     #'.'               ; CHARACTER '.'     INY                    ; INCREMENT OUTPUT STRING INDEX     STA     XX0100-1,Y     ; SAVE TO OUTPUT STRINGXXDEB2 = *     STY     XX71          ; SAVE THE OUTPUT STRING INDEX     LDY     XX47          ; GET THE POWERS OF TEN TABLE INDEX     TXA                    ; GET THE CHARACTER BACK     EOR     #$FF               ; TOGGLE THE TEST SENSE BIT     AND     #$80               ; CLEAR THE DIGIT     TAX                    ; COPY IT TO THE NEW DIGIT     CPY     #XXDF3A-XXDF16                                        ; COMPARE THE TABLE INDEX WITH THE MAX FOR DECIMAL NUMBERS     BEQ     XXDEC4          ; IF AT THE MAX EXIT THE DIGIT LOOP     CPY     #XXDF52-XXDF16                         ; COMPARE THE TABLE INDEX WITH THE MAX FOR TIME     BNE     XXDE6A          ; LOOP IF NOT AT THE MAX; NOW REMOVE TRAILING ZEROESXXDEC4 = *     LDY     XX71          ; RESTORE THE OUTPUT STRING INDEXXXDEC6 = *     LDA     XX0100-1,Y     ; GET CHARACTER FROM OUTPUT STRING     DEY                    ; DECREMENT OUTPUT STRING INDEX     CMP     #'0'               ; COMPARE WITH '0'     BEQ     XXDEC6          ; LOOP UNTIL NON '0' CHARACTER FOUND     CMP     #'.'               ; COMPARE WITH '.'     BEQ     XXDED3          ; BRANCH IF WAS DP                         ; RESTORE LAST CHARACTER     INY                    ; INCREMENT OUTPUT STRING INDEXXXDED3 = *     LDA     #'+'               ; CHARACTER '+'     LDX     XX5E          ; GET EXPONENT COUNT     BEQ     XXDF07          ; IF ZERO GO SET NULL TERMINATOR AND EXIT                         ; EXPONENT ISN'T ZERO SO WRITE EXPONENT     BPL     XXDEE3          ; BRANCH IF EXPONENT COUNT +VE     LDA     #$00               ; CLEAR A     SEC                    ; SET CARRY FOR SUBTRACT     SBC     XX5E          ; SUBTRACT EXPONENT COUNT ADJUST (CONVE	RT -VE TO +VE)     TAX                    ; COPY EXPONENT COUNT TO X     LDA     #'-'               ; CHARACTER '-'XXDEE3 = *     STA     XX0100+1,Y     ; SAVE TO OUTPUT STRING     LDA     #'E'               ; CHARACTER 'E'     STA     XX0100,Y    
      ; SAVE EXPONENT SIGN TO OUTPUT STRING     TXA                    ; GET EXPONENT COUNT BACK     LDX     #$2F               ; ONE LESS THAN '0' CHARACTER     SEC                    ; SET CARRY FOR SUBTRACTXXDEEF = *     INX                    ; INCREMENT 10'S CHARACTER     SBC     #$0A               ; SUBTRACT 10 FROM EXPONENT COUNT     BCS     XXDEEF          ; LOOP WHILE STILL >= 0     ADC     #':'               ; ADD CHARACTER ':' ($30+$0A, RESULT IS 10 LESS THAT VALUE)     STA     XX0100+3,Y     ; SAVE TO OUTPUT STRING     TXA                    ; COPY 10'S CHARACTER     STA     XX0100+2,Y     ; SAVE TO OUTPUT STRING     LDA     #$00               ; SET NULL TERMINATOR     STA     XX0100+4,Y     ; SAVE TO OUTPUT STRING     BEQ     XXDF0C          ; GO SET STRING POINTER (AY) AND EXIT, BRANCH ALWAYS                         ; SAVE LAST CHARACTER, [EOT] AND EXITXXDF04 = *     STA     XX0100-1,Y     ; SAVE LAST CHARACTER TO OUTPUT STRING                         ; SET NULL TERMINATOR AND EXITXXDF07 = *     LDA     #$00               ; SET NULL TERMINATOR     STA     XX0100,Y          ; SAVE AFTER LAST CHARACTER                         ; SET STRING POINTER (AY) AND EXITXXDF0C = *     LDA     #<XX0100          ; SET RESULT STRING POINTER LOW BYTE     LDY     #>XX0100          ; SET RESULT STRING POINTER HIGH BYTE     RTS;***********************************************************************************;;XXDF11 = *     .BYTE     $80,$00          ; 0.5, FIRST TWO BYTESXXDF13 = *     .BYTE     $00,$00,$00          ; NULL RETURN FOR UNDEFINED VARIABLES; DECIMAL CONVERSION TABLSXXDF16 = *     .BYTE     $FA,$0A,$1F,$00     ; -100000000     .BYTE     $00,$98,$96,$80     ;  +10000000     .BYTE     $FF,$F0,$BD,$C0     ;   -1000000     .BYTE     $00,$01,$86,$A0     ;    +100000     .BYTE     $FF,$FF,$D8,$F0     ;     -10000     .BYTE     $00,$00,$03,$E8     ;      +1000     .BYTE     $FF,$FF,$FF,$9C     ;       -100     .BYTE     $00,$00,$00,$0A     ;        +10     .BYTE     $FF,$FF,$FF,$FF     ;         -1; JIFFY COUNT CONVERSION TABLEXXDF3A = *     .BYTE     $FF,$DF,$0A,$80     ; -2160000     10S HOURS     .BYTE     $00,$03,$4B,$C0     ;  +216000         HOURS     .BYTE     $FF,$FF,$73,$60     ;   -36000     10S MINS     .BYTE     $00,$00,$0E,$10     ;    +3600         MINS     .BYTE     $FF,$FF,$FD,$A8     ;     -600     10S SECS     .BYTE     $00,$00,$00,$3C     ;      +60         SECSXXDF52 = *;***********************************************************************************;;; SPARE BYTES, NOT REFERENCED     .BYTE     $BF,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA     .BYTE     $AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA;***********************************************************************************;;; PERFORM SQR()XXDF71 = *     JSR     XXDC0C          ; ROUND AND COPY FAC1 TO FAC2     LDA     #<XXDF11          ; SET 0.5 POINTER LOW ADDRESS     LDY     #>XXDF11          ; SET 0.5 POINTER HIGH ADDRESS     JSR     XXDBA2          ; UNPACK MEMORY (AY) INTO FAC1;***********************************************************************************;;; PERFORM POWER FUNCTIONXXDF7B = *     BEQ     XXDFED          ; PERFORM EXP()     LDA     XX69          ; GET FAC2 EXPONENT     BNE     XXDF84          ; BRANCH IF FAC2<>0     JMP     XXD8F9          ; CLEAR FAC1 EXPONENT AND SIGN AND RETURNXXDF84 = *     LDX     #<XX4E          ; SET DESTINATION POINTER LOW BYTE     LDY     #>XX4E          ; SET DESTINATION POINTER HIGH BYTE     JSR     XXDBD4          ; PACK FAC1 INTO (XY)     LDA     XX6E          ; GET FAC2 SIGN (B7)     BPL     XXDF9E          ; BRANCH IF FAC2>0                         ; ELSE FAC2 IS -VE AND CAN ONLY BE RAISED TO AN                         ; INTEGER POWER WHICH GIVES AN X + J0 RESULT     JSR     XXDCCC          ; PERFORM INT()     LDA     #<XX4E          ; SET SOURCE POINTER LOW BYTE     LDY     #>XX4E          ; SET SOURCE POINTER HIGH BYTE     JSR     XXDC5B          ; COMPARE FAC1 WITH (AY)     BNE     XXDF9E          ; BRANCH IF FAC1 <> (AY) TO ALLOW FUNCTION CALL ERROR                         ; THIS WILL LEAVE FAC1 -VE AND CAUSE A FUNCTION CALL                         ; ERROR WHEN LOG() IS CALLED     TYA                    ; CLEAR SIGN B7     LDY     XX07          ; GET FAC1 MANTISSA 4 FROM INT() FUNCTION AS SIGN IN                         ; Y FOR POSSIBLE LATER NEGATION, B0 ONLY NEEDEDXXDF9E = *     JSR     XXDBFE          ; SAVE FAC1 SIGN AND COPY ABS(FAC2) TO FAC1     TYA                    ; COPY SIGN BACK ..     PHA                    ; .. AND SAVE IT     JSR     XXD9EA          ; PERFORM LOG()     LDA     #<XX4E          ; SET POINTER LOW BYTE     LDY     #>XX4E          ; SET POINTER HIGH BYTE     JSR     XXDA28          ; DO CONVERT AY, FCA1*(AY)     JSR     XXDFED          ; PERFORM EXP()     PLA                    ; PULL SIGN FROM STACK     LSR A                  ; B0 IS TO BE TESTED     BCC     XXDFBE          ; IF NO BIT THEN EXIT; DO - FAC1XXDFB4 = *     LDA     XX61          ; GET FAC1 EXPONENT     BEQ     XXDFBE          ; EXIT IF FAC1_E = $00     LDA     XX66          ; GET FAC1 SIGN (B7)     EOR     #$FF               ; COMPLEMENT IT     STA     XX66          ; SAVE FAC1 SIGN (B7)XXDFBE = *     RTS;***********************************************************************************;;; EXP(N) CONSTANT AND SERIESXXDFBF = *     .BYTE     $81,$38,$AA,$3B,$29     ; 1.443XX DFC4 = *     .BYTE     $07                    ; SERIES COUNT     .BYTE     $71,$34,$58,$3E,$56     ; 2.14987637E-5     .BYTE     $74,$16,$7E,$B3,$1B     ; 1.43523140E-4     .BYTE     $77,$2F,$EE,$E3,$85     ; 1.34226348E-3     .BYTE     $7A,$1D,$84,!$1C,$2A     ; 9.61401701E-3     .BYTE     $7C,$63,$59,$58,$0A     ; 5.55051269E-2     .BYTE     $7E,$75,$FD,$E7,$C6     ; 2.40226385E-1     .BYTE     $80,$31,$72,$18,$10     ; 6.93147186E-1     .BYTE     $81,$00,$00,$00,$00     ; 1.00000000;******"*****************************************************************************;;; PERFORM EXP()XXDFED = *     LDA     #<XXDFBF          ; SET 1.443 POINTER LOW BYTE     LDY     #>XXDFBF          ; SET 1.443 POINTER HIGH BYTE     JSR     XXDA28     #     ; DO CONVERT AY, FCA1*(AY)     LDA     XX70          ; GET FAC1 ROUNDING BYTE     ADC     #$50               ; +$50/$100     BCC     XXDFFD          ; SKIP ROUNDING IF NO CARRY     JSR     XXDC23          ; ROUND FAC1 (NO CHECK)XXDFFD = *    $ STA     XX56          ; SAVE FAC2 ROUNDING BYTE     JSR     XXDC0F          ; COPY FAC1 TO FAC2     LDA     XX61          ; GET FAC1 EXPONENT     CMP     #$88               ; COMPARE WITH EXP LIMIT (256D)     BCC     XXE00B          ; BRANCH IF LESS%XXE008 = *     JSR     XXDAD4          ; HANDLE OVERFLOW AND UNDERFLOWXXE00B = *     JSR     XXDCCC          ; PERFORM INT()     LDA     XX07          ; GET MANTISSA 4 FROM INT()     CLC                    ; CLEAR CARRY FOR ADD     ADC     #$81  &             ; NORMALISE +1     BEQ     XXE008          ; IF $00 RESULT HAS OVERFLOWED SO GO HANDLE IT     SEC                    ; SET CARRY FOR SUBTRACT     SBC     #$01               ; EXPONENT NOW CORRECT     PHA                    ; SAVE FAC2 E'XPONENT                         ; SWAP FAC1 AND FAC2     LDX     #$05               ; 4 BYTES TO DOXXE01B = *     LDA     XX69,X          ; GET FAC2,X     LDY     XX61,X          ; GET FAC1,X     STA     XX61,X          ; SAVE FAC1,X     STY     X X69,X          ; SAVE FAC2,X     DEX                    ; DECREMENT COUNT/INDEX     BPL     XXE01B          ; LOOP IF NOT ALL DONE     LDA     XX56          ; GET FAC2 ROUNDING BYTE     STA     XX70          ; SAVE AS FAC1 ROUNDING BYTE     JSR    	NOT SET     INC     XX5D          ; ELSE INCREMENT NUMBER EXPONENTXXDD71 = *     JSR     XXDAE2          ; MULTIPLY FAC1 BY 10     PLA                    ; RESTORE CHARACTER     SEC                    ; SET CARRY FOR SUBTRACT     SBC     #'0'     	          ; CONVERT TO BINARY     JSR     XXDD7E          ; EVALUATE NEW ASCII DIGIT     JMP     XXDD0A          ; GO DO NEXT CHARACTER; EVALUATE NEW ASCII DIGIT; MULTIPLY FAC1 BY 10 THEN (ABS) ADD IN NEW DIGITXXDD7E = *     PHA                  	  ; SAVE DIGIT     JSR     XXDC0C          ; ROUND AND COPY FAC1 TO FAC2     PLA                    ; RESTORE DIGIT     JSR     XXDC3C          ; SAVE A AS INTEGER BYTE     LDA     XX6E          ; GET FAC2 SIGN (B7)     EOR     XX66          ; TOGGL	E WITH FAC1 SIGN (B7)     STA     XX6F          ; SAVE SIGN COMPARE (FAC1 EOR FAC2)     LDX     XX61          ; GET FAC1 EXPONENT     JMP     XXD86A          ; ADD FAC2 TO FAC1 AND RETURN; EVALUATE NEXT CHARACTER OF EXPONENTIAL PART OF NUMBERXXDD9	1 = *     LDA     XX5E          ; GET EXPONENT COUNT BYTE     CMP     #$0A               ; COMPARE WITH 10 DECIMAL     BCC     XXDDA0          ; BRANCH IF LESS     LDA     #$64               ; MAKE ALL -VE EXPONENTS = -100 DECIMAL (CAUSES UNDERFLOW)	     BIT     XX60          ; TEST EXPONENT -VE FLAG     BMI     XXDDAE          ; BRANCH IF -VE     JMP     XXD97E          ; ELSE DO OVERFLOW ERROR THEN WARM STARTXXDDA0 = *     ASL A                  ; *2     ASL A                  ; *4     CL	C                    ; CLEAR CARRY FOR ADD     ADC     XX5E          ; *5     ASL A                  ; *10     CLC                    ; CLEAR CARRY FOR ADD     LDY     #$00               ; SET INDEX     ADC     (XX7A),Y          ; ADD CHARACTER (WIL	L BE $30 TOO MUCH!)     SEC                    ; SET CARRY FOR SUBTRACT     SBC     #'0'               ; CONVERT CHARACTER TO BINARYXXDDAE = *     STA     XX5E          ; SAVE EXPONENT COUNT BYTE     JMP     XXDD30          ; GO GET NEXT CHARACTER		;***********************************************************************************;;XXDDB3 = *     .BYTE     $9B,$3E,$BC,$1F,$FD                         ; 99999999.90625, MAXIMUM VALUE WITH AT LEAST ONE DECIMALXXDDB8 = *     .BYTE     $9E,$6E,$6	
B,$27,$FD                         ; 999999999.25, MAXIMUM VALUE BEFORE SCIENTIFIC NOTATIONXXDDBD = *     .BYTE     $9E,$6E,$6B,$28,$00                         ; 1000000000;***************************************************************************	********;;; DO ' IN ' LINE NUMBER MESSAGEXXDDC2 = *     LDA     #<XXC371          ; SET ' IN ' POINTER LOW BYTE     LDY     #>XXC371          ; SET ' IN ' POINTER HIGH BYTE     JSR     XXDDDA          ; PRINT NULL TERMINATED STRING     LDA     XX	3A          ; GET THE CURRENT LINE NUMBER HIGH BYTE     LDX     XX39          ; GET THE CURRENT LINE NUMBER LOW BYTE;***********************************************************************************;;; PRINT XA AS UNSIGNED INTEGERXXDDCD = *   	  STA     XX62          ; SAVE HIGH BYTE AS FAC1 MANTISSA1     STX     XX63          ; SAVE LOW BYTE AS FAC1 MANTISSA2     LDX     #$90               ; SET EXPONENT TO 16D BITS     SEC                    ; SET INTEGER IS +VE FLAG     JSR     XXDC49  	        ; SET EXPONENT = X, CLEAR MANTISSA 4 AND 3 AND NORMALISE                         ; FAC1     JSR     XXDDDF          ; CONVERT FAC1 TO STRINGXXDDDA = *     JMP     XXCB1E          ; PRINT NULL TERMINATED STRING;*****************************	******************************************************;;; CONVERT FAC1 TO ASCII STRING RESULT IN (AY)XXDDDD = *     LDY     #$01               ; SET INDEX = 1XXDDDF = *     LDA     #' '               ; CHARACTER = ' ' (ASSUME +VE)     BIT     XX6	6          ; TEST FAC1 SIGN (B7)     BPL     XXDDE7          ; IF +VE SKIP THE - SIGN SET     LDA     #'-'               ; ELSE CHARACTER = '-'XXDDE7 = *     STA     XX00FF,Y          ; SAVE LEADING CHARACTER (' ' OR '-')     STA     XX66          	; SAVE FAC1 SIGN (B7)     STY     XX71          ; SAVE THE INDEX     INY                    ; INCREMENT INDEX     LDA     #'0'               ; SET CHARACTER = '0'     LDX     XX61          ; GET FAC1 EXPONENT     BNE     XXDDF8          ; IF FAC1<>0	 GO CONVERT IT                         ; EXPONENT WAS $00 SO FAC1 IS 0     JMP     XXDF04          ; SAVE LAST CHARACTER, [EOT] AND EXIT; FAC1 IS SOME NON ZERO VALUEXXDDF8 = *     LDA     #$00               ; CLEAR (NUMBER EXPONENT COUNT)     CP	X     #$80               ; COMPARE FAC1 EXPONENT WITH $80 (<1.00000)     BEQ     XXDE00          ; BRANCH IF 0.5 <= FAC1 < 1.0     BCS     XXDE09          ; BRANCH IF FAC1=>1XXDE00 = *     LDA     #<XXDDBD          ; SET 1000000000 POINTER LOW BYTE	     LDY     #>XXDDBD          ; SET 1000000000 POINTER HIGH BYTE     JSR     XXDA28          ; DO CONVERT AY, FCA1*(AY)     LDA     #$F7               ; SET NUMBER EXPONENT COUNTXXDE09 = *     STA     XX5D          ; SAVE NUMBER EXPONENT COUNTXXDE	0B = *     LDA     #<XXDDB8          ; SET 999999999.25 POINTER LOW BYTE (MAX BEFORE SCI NOTE)     LDY     #>XXDDB8          ; SET 999999999.25 POINTER HIGH BYTE     JSR     XXDC5B          ; COMPARE FAC1 WITH (AY)     BEQ     XXDE32          ; EXIT 	IF FAC1 = (AY)     BPL     XXDE28          ; GO DO /10 IF FAC1 > (AY)                         ; FAC1 < (AY)XXDE16 = *     LDA     #<XXDDB3          ; SET 99999999.90625 POINTER LOW BYTE     LDY     #>XXDDB3          ; SET 99999999.90625 POINTER HI	GH BYTE     JSR     XXDC5B          ; COMPARE FAC1 WITH (AY)     BEQ     XXDE21          ; BRANCH IF FAC1 = (AY) (ALLOW DECIMAL PLACES)     BPL     XXDE2F          ; BRANCH IF FAC1 > (AY) (NO DECIMAL PLACES)                         ; FAC1 <= (AY)X	XDE21 = *     JSR     XXDAE2          ; MULTIPLY FAC1 BY 10     DEC     XX5D          ; DECREMENT NUMBER EXPONENT COUNT     BNE     XXDE16          ; GO TEST AGAIN, BRANCH ALWAYSXXDE28 = *     JSR     XXDAFE          ; DIVIDE FAC1 BY 10     INC   	  XX5D          ; INCREMENT NUMBER EXPONENT COUNT     BNE     XXDE0B          ; GO TEST AGAIN, BRANCH ALWAYS; NOW WE HAVE JUST THE DIGITS TO DOXXDE2F = *     JSR     XXD849          ; ADD 0.5 TO FAC1 (ROUND FAC1)XXDE32 = *     JSR     XXDC9B     	     ; CONVERT FAC1 FLOATING TO FIXED     LDX     #$01               ; SET DEFAULT DIGITS BEFORE DP = 1     LDA     XX5D          ; GET NUMBER EXPONENT COUNT     CLC                    ; CLEAR CARRY FOR ADD     ADC     #$0A               ; UP TO 9 DI	GITS BEFORE POINT     BMI     XXDE47          ; IF -VE THEN 1 DIGIT BEFORE DP     CMP     #$0B               ; A>=$0B IF N>=1E9     BCS     XXDE48          ; BRANCH IF >= $0B                         ; CARRY IS CLEAR     ADC     #$FF               	; TAKE 1 FROM DIGIT COUNT     TAX                    ; COPY TO X     LDA     #$02               ; SET THE EXPONENT ADJUSTXXDE47 = *     SEC                    ; SET CARRY FOR SUBTRACTXXDE48 = *     SBC     #$02               ; -2     STA     XX5E 	         ; SAVE THE EXPONENT ADJUST     STX     XX5D          ; SAVE DIGITS BEFORE DP COUNT     TXA                    ; COPY DIGITS BEFORE DP COUNT TO A     BEQ     XXDE53          ; IF NO DIGITS BEFORE THE DP GO DO THE '.'     BPL     XXDE66      	    ; IF THERE ARE DIGITS BEFORE THE DP GO DO THEMXXDE53 = *     LDY     XX71          ; GET THE OUTPUT STRING INDEX     LDA     #'.'               ; CHARACTER '.'     INY                    ; INCREMENT THE INDEX     STA     XX0100-1,Y     ; SAVE T	HE '.' TO THE OUTPUT STRING     TXA                    ; COPY DIGITS BEFORE DP COUNT TO A     BEQ     XXDE64          ; IF NO DIGITS BEFORE THE DP SKIP THE '0'     LDA     #'0'               ; CHARACTER '0'     INY                    ; INCREMENT IND	 EX     STA     XX0100-1,Y     ; SAVE THE '0' TO THE OUTPUT STRINGXXDE64 = *     STY     XX71          ; SAVE THE OUTPUT STRING INDEXXXDE66 = *     LDY     #$00               ; CLEAR THE POWERS OF 10 INDEX (POINT TO -100,000,000)XXDE68 = *     LDX 	!    #$80               ; CLEAR THE DIGIT, SET THE TEST SENSEXXDE6A = *     LDA     XX65          ; GET FAC1 MANTISSA 4     CLC                    ; CLEAR CARRY FOR ADD     ADC     XXDF16+3,Y     ; ADD BYTE 4, LEAST SIGNIFICANT     STA     XX65      	"    ; SAVE FAC1 MANTISSA4     LDA     XX64          ; GET FAC1 MANTISSA 3     ADC     XXDF16+2,Y     ; ADD BYTE 3     STA     XX64          ; SAVE FAC1 MANTISSA3     LDA     XX63          ; GET FAC1 MANTISSA 2     ADC     XXDF16+1,Y     ; ADD BYTE 2	#     STA     XX63          ; SAVE FAC1 MANTISSA2     LDA     XX62          ; GET FAC1 MANTISSA 1     ADC     XXDF16+0,Y     ; ADD BYTE 1, MOST SIGNIFICANT     STA     XX62          ; SAVE FAC1 MANTISSA1     INX                    ; INCREMENT THE DIG	$IT, SET THE SIGN ON THE TEST SENSE BIT     BCS     XXDE8E          ; IF THE CARRY IS SET GO TEST IF THE RESULT WAS POSITIVE                         ; ELSE THE RESULT NEEDS TO BE NEGATIVE     BPL     XXDE6A          ; NOT -VE SO TRY AGAIN     BMI   	%  XXDE90          ; ELSE DONE SO RETURN THE DIGITXXDE8E = *     BMI     XXDE6A          ; NOT +VE SO TRY AGAIN; ELSE DONE SO RETURN THE DIGITXXDE90 = *     TXA                    ; COPY THE DIGIT     BCC     XXDE97          ; IF CB=0 JUST USE IT	&     EOR     #$FF               ; ELSE MAKE THE 2'S COMPLEMENT ..     ADC     #$0A               ; .. AND SUBTRACT IT FROM 10XXDE97 = *     ADC     #$2F ;#'0'-1          ; ADD '0'-1 TO RESULT     INY                    ; INCREMENT ..     INY      	'              ; .. INDEX TO..     INY                    ; .. NEXT LESS ..     INY                    ; .. POWER OF TEN     STY     XX47          ; SAVE THE POWERS OF TEN TABLE INDEX     LDY     XX71          ; GET OUTPUT STRING INDEX     INY                     ; INCREMENT OUTPUT STRING INDEX     TAX                    ; COPY CHARACTER TO X     AND     #$7F               ; MASK OUT TOP BIT     STA     XX0100-1,Y     ; SAVE TO OUTPUT STRING     DEC     XX5D          ; DECREMENT # OF CHARACTERS B
AVE A AS INTEGER BYTEXXDC3C = *     STA     XX62          ; SAVE FAC1 MANTISSA 1     LDA     #$00               ; CLEAR A     STA     XX63          ; CLEAR FAC1 MANTISSA 2     LDX     #$88               ; SET EXPONENT; SET EXPONENT = X, CLEAR FAC
1 3 AND 4 AND NORMALISEXXDC44 = *     LDA     XX62          ; GET FAC1 MANTISSA 1     EOR     #$FF               ; COMPLEMENT IT     ROL A                  ; SIGN BIT INTO CARRY; SET EXPONENT = X, CLEAR MANTISSA 4 AND 3 AND NORMALISE FAC1XXDC49 
= *     LDA     #$00               ; CLEAR A     STA     XX65          ; CLEAR FAC1 MANTISSA 4     STA     XX64          ; CLEAR FAC1 MANTISSA 3; SET EXPONENT = X AND NORMALISE FAC1XXDC4F = *     STX     XX61          ; SET FAC1 EXPONENT     STA
     XX70          ; CLEAR FAC1 ROUNDING BYTE     STA     XX66          ; CLEAR FAC1 SIGN (B7)     JMP     XXD8D2          ; DO ABS AND NORMALISE FAC1; PERFORM ABS()XXDC58 = *     LSR     XX66          ; CLEAR FAC1 SIGN, PUT ZERO IN B7     RTS
;***********************************************************************************;;; COMPARE FAC1 WITH (AY); RETURNS A=$00 IF FAC1 = (AY); RETURNS A=$01 IF FAC1 > (AY); RETURNS A=$FF IF FAC1 < (AY)XXDC5B = *     STA     XX24          ; SAVE PO
INTER LOW BYTEXXDC5D = *     STY     XX25          ; SAVE POINTER HIGH BYTE     LDY     #$00               ; CLEAR INDEX     LDA     (XX24),Y          ; GET EXPONENT     INY                    ; INCREMENT INDEX     TAX                    ; COPY (AY
) EXPONENT TO X     BEQ     XXDC2B          ; BRANCH IF (AY) EXPONENT=0 AND GET FAC1 SIGN                         ; A = $FF, CB = 1/-VE A = $01, CB = 0/+VE     LDA     (XX24),Y          ; GET (AY) MANTISSA 1, WITH SIGN     EOR     XX66          ; EO
R FAC1 SIGN (B7)     BMI     XXDC2F          ; IF SIGNS <> DO RETURN A = $FF, CB = 1/-VE                         ; A = $01, CB = 0/+VE AND RETURN     CPX     XX61          ; COMPARE (AY) EXPONENT WITH FAC1 EXPONENT     BNE     XXDC92          ; BRAN
	CH IF DIFFERENT     LDA     (XX24),Y          ; GET (AY) MANTISSA 1, WITH SIGN     ORA     #$80               ; NORMALISE TOP BIT     CMP     XX62          ; COMPARE WITH FAC1 MANTISSA 1     BNE     XXDC92          ; BRANCH IF DIFFERENT     INY   

                 ; INCREMENT INDEX     LDA     (XX24),Y          ; GET MANTISSA 2     CMP     XX63          ; COMPARE WITH FAC1 MANTISSA 2     BNE     XXDC92          ; BRANCH IF DIFFERENT     INY                    ; INCREMENT INDEX     LDA     (X
X24),Y          ; GET MANTISSA 3     CMP     XX64          ; COMPARE WITH FAC1 MANTISSA 3     BNE     XXDC92          ; BRANCH IF DIFFERENT     INY                    ; INCREMENT INDEX     LDA     #$7F               ; SET FOR 1/2 VALUE ROUNDING BYTE
     CMP     XX70          ; COMPARE WITH FAC1 ROUNDING BYTE (SET CARRY)     LDA     (XX24),Y          ; GET MANTISSA 4     SBC     XX65          ; SUBTRACT FAC1 MANTISSA 4     BEQ     XXDCBA          ; EXIT IF MANTISSA 4 EQUAL; GETS HERE IF NUMBER
 <> FAC1XXDC92 = *     LDA     XX66          ; GET FAC1 SIGN (B7)     BCC     XXDC98          ; BRANCH IF FAC1 > (AY)     EOR     #$FF               ; ELSE TOGGLE FAC1 SIGNXXDC98 = *     JMP     XXDC31          ; RETURN A = $FF, CB = 1/-VE A = $0
1, CB = 0/+VE;***********************************************************************************;;; CONVERT FAC1 FLOATING TO FIXEDXXDC9B = *     LDA     XX61          ; GET FAC1 EXPONENT     BEQ     XXDCE9          ; IF ZERO GO CLEAR FAC1 AND R
ETURN     SEC                    ; SET CARRY FOR SUBTRACT     SBC     #$A0               ; SUBTRACT MAXIMUM INTEGER RANGE EXPONENT     BIT     XX66          ; TEST FAC1 SIGN (B7)     BPL     XXDCAF          ; BRANCH IF FAC1 +VE                    
     ; FAC1 WAS -VE     TAX                    ; COPY SUBTRACTED EXPONENT     LDA     #$FF               ; OVERFLOW FOR -VE NUMBER     STA     XX68          ; SET FAC1 OVERFLOW BYTE     JSR     XXD94D          ; TWOS COMPLEMENT FAC1 MANTISSA     TXA
                    ; RESTORE SUBTRACTED EXPONENTXXDCAF = *     LDX     #$61               ; SET INDEX TO FAC1     CMP     #$F9               ; COMPARE EXPONENT RESULT     BPL     XXDCBB          ; IF < 8 SHIFTS SHIFT FAC1 A TIMES RIGHT AND RETURN 
    JSR     XXD999          ; SHIFT FAC1 A TIMES RIGHT (> 8 SHIFTS)     STY     XX68          ; CLEAR FAC1 OVERFLOW BYTEXXDCBA = *     RTS;***********************************************************************************;;; SHIFT FAC1 A TIMES R
IGHTXXDCBB = *     TAY                    ; COPY SHIFT COUNT     LDA     XX66          ; GET FAC1 SIGN (B7)     AND     #$80               ; MASK SIGN BIT ONLY (X000 0000)     LSR     XX62          ; SHIFT FAC1 MANTISSA 1     ORA     XX62         
 ; OR SIGN IN B7 FAC1 MANTISSA 1     STA     XX62          ; SAVE FAC1 MANTISSA 1     JSR     XXD9B0          ; SHIFT FAC1 Y TIMES RIGHT     STY     XX68          ; CLEAR FAC1 OVERFLOW BYTE     RTS;*************************************************
**********************************;;; PERFORM INT()XXDCCC = *     LDA     XX61          ; GET FAC1 EXPONENT     CMP     #$A0               ; COMPARE WITH MAX INT     BCS     XXDCF2          ; EXIT IF >= (ALLREADY INT, TOO BIG FOR FRACTIONAL PART!)
     JSR     XXDC9B          ; CONVERT FAC1 FLOATING TO FIXED     STY     XX70          ; SAVE FAC1 ROUNDING BYTE     LDA     XX66          ; GET FAC1 SIGN (B7)     STY     XX66          ; SAVE FAC1 SIGN (B7)     EOR     #$80               ; TOGGLE
 FAC1 SIGN     ROL A                  ; SHIFT INTO CARRY     LDA     #$A0               ; SET NEW EXPONENT     STA     XX61          ; SAVE FAC1 EXPONENT     LDA     XX65          ; GET FAC1 MANTISSA 4     STA     XX07          ; SAVE FAC1 MANTISSA 
4 FOR POWER FUNCTION     JMP     XXD8D2          ; DO ABS AND NORMALISE FAC1;***********************************************************************************;;; CLEAR FAC1 AND RETURNXXDCE9 = *     STA     XX62          ; CLEAR FAC1 MANTISSA 1
     STA     XX63          ; CLEAR FAC1 MANTISSA 2     STA     XX64          ; CLEAR FAC1 MANTISSA 3     STA     XX65          ; CLEAR FAC1 MANTISSA 4     TAY                    ; CLEAR YXXDCF2 = *     RTS;***************************************
********************************************;;; GET FAC1 FROM STRINGXXDCF3 = *     LDY     #$00               ; CLEAR Y     LDX     #$0A               ; SET INDEXXXDCF7 = *     STY     XX5D,X          ; CLEAR BYTE     DEX                    ; DE
CREMENT INDEX     BPL     XXDCF7          ; LOOP UNTIL NUMEXP TO NEGNUM (AND FAC1) = $00     BCC     XXDD0D          ; BRANCH IF FIRST CHARACTER IS NUMERIC     CMP     #'-'               ; ELSE COMPARE WITH '-'     BNE     XXDD06          ; BRANCH 
IF NOT '-'     STX     XX67          ; SET FLAG FOR -VE N (NEGNUM = $FF)     BEQ     XXDD0A          ; BRANCH ALWAYSXXDD06 = *     CMP     #'+'               ; ELSE COMPARE WITH '+'     BNE     XXDD0F          ; BRANCH IF NOT '+'XXDD0A = *     
JSR     XX0073          ; INCREMENT AND SCAN MEMORYXXDD0D = *     BCC     XXDD6A          ; BRANCH IF NUMERIC CHARACTERXXDD0F = *     CMP     #'.'               ; ELSE COMPARE WITH '.'     BEQ     XXDD41          ; BRANCH IF '.'     CMP     #'E' 
              ; ELSE COMPARE WITH 'E'     BNE     XXDD47          ; BRANCH IF NOT 'E'                         ; WAS 'E' SO EVALUATE EXPONENTIAL PART     JSR     XX0073          ; INCREMENT AND SCAN MEMORY     BCC     XXDD33          ; BRANCH IF NUME
RIC CHARACTER     CMP     #TMINUS          ; ELSE COMPARE WITH TOKEN FOR -     BEQ     XXDD2E          ; BRANCH IF TOKEN FOR -     CMP     #'-'               ; ELSE COMPARE WITH '-'     BEQ     XXDD2E          ; BRANCH IF '-'     CMP     #TPLUS  
         ; ELSE COMPARE WITH TOKEN FOR +     BEQ     XXDD30          ; BRANCH IF TOKEN FOR +     CMP     #'+'               ; ELSE COMPARE WITH '+'     BEQ     XXDD30          ; BRANCH IF '+'     BNE     XXDD35          ; BRANCH ALWAYSXXDD2E = * 
!    ROR     XX60          ; SET EXPONENT -VE FLAG (C, WHICH=1, INTO B7)XXDD30 = *     JSR     XX0073          ; INCREMENT AND SCAN MEMORYXXDD33 = *     BCC     XXDD91          ; BRANCH IF NUMERIC CHARACTERXXDD35 = *     BIT     XX60          ; TES
"T EXPONENT -VE FLAG     BPL     XXDD47          ; IF +VE GO EVALUATE EXPONENT                         ; ELSE DO EXPONENT = -EXPONENT     LDA     #$00               ; CLEAR RESULT     SEC                    ; SET CARRY FOR SUBTRACT     SBC     XX5E 
#         ; SUBTRACT EXPONENT BYTE     JMP     XXDD49          ; GO EVALUATE EXPONENTXXDD41 = *     ROR     XX5F          ; SET DECIMAL POINT FLAG     BIT     XX5F          ; TEST DECIMAL POINT FLAG     BVC     XXDD0A          ; BRANCH IF ONLY ONE D
$ECIMAL POINT SO FAR                         ; EVALUATE EXPONENTXXDD47 = *     LDA     XX5E          ; GET EXPONENT COUNT BYTEXXDD49 = *     SEC                    ; SET CARRY FOR SUBTRACT     SBC     XX5D          ; SUBTRACT NUMERATOR EXPONENT   
%  STA     XX5E          ; SAVE EXPONENT COUNT BYTE     BEQ     XXDD62          ; BRANCH IF NO ADJUSTMENT     BPL     XXDD5B          ; ELSE IF +VE GO DO FAC1*10^EXPCNT                         ; ELSE GO DO FAC1/10^(0-EXPCNT)XXDD52 = *     JSR     X
&XDAFE          ; DIVIDE FAC1 BY 10     INC     XX5E          ; INCREMENT EXPONENT COUNT BYTE     BNE     XXDD52          ; LOOP UNTIL ALL DONE     BEQ     XXDD62          ; BRANCH ALWAYSXXDD5B = *     JSR     XXDAE2          ; MULTIPLY FAC1 BY 10
'     DEC     XX5E          ; DECREMENT EXPONENT COUNT BYTE     BNE     XXDD5B          ; LOOP UNTIL ALL DONEXXDD62 = *     LDA     XX67          ; GET -VE FLAG     BMI     XXDD67          ; IF -VE DO - FAC1 AND RETURN     RTS; DO - FAC1 AND RETU	 RNXXDD67 = *     JMP     XXDFB4          ; DO - FAC1; DO UNSIGNED FAC1*10+NUMBERXXDD6A = *     PHA                    ; SAVE CHARACTER     BIT     XX5F          ; TEST DECIMAL POINT FLAG     BPL     XXDD71          ; SKIP EXPONENT INCREMENT IF *******************************************************************************;;; DIVIDE FAC1 BY 10XXDAFE = *     JSR     XXDC0C          ; ROUND AND COPY FAC1 TO FAC2     LDA     #<XXDAF9          ; SET 10 POINTER LOW BYTE     LDY     #>XXDAF9          ; SET 10 POINTER HIGH BYTE     LDX     #$00               ; CLEAR SIGN; DIVIDE BY (AY) (X=SIGN)XXDB07 = *     STX     XX6F          ; SAVE SIGN COMPARE (FAC1 EOR FAC2)     JSR     XXDBA2          ; UNPACK MEMORY (AY) INTO FAC1     JMP     XXDB12          ; DO FAC2/FAC1                         ; PERFORM DIVIDE-BY; CONVERT AY AND DO (AY)/FAC1XXDB0F = *     JSR     XXDA8C          ; UNPACK MEMORY (AY) INTO FAC2XXDB12 = *     BEQ     XXDB8A          ; IF ZERO GO DO /0 ERROR     JSR     XXDC1B          ; ROUND FAC1     LDA     #$00               ; CLEAR A     SEC                    ; SET CARRY FOR SUBTRACT     SBC     XX61          ; SUBTRACT FAC1 EXPONENT (2S COMPLEMENT)     STA     XX61          ; SAVE FAC1 EXPONENT     JSR     XXDAB7          ; TEST AND ADJUST ACCUMULATORS     INC     XX61          ; INCREMENT FAC1 EXPONENT     BEQ     XXDADF          ; IF ZERO DO OVERFLOW ERROR     LDX     #$FC               ; SET INDEX TO FAC TEMP     LDA     #$01               ;.SET BYTEXXDB29 = *     LDY     XX6A          ; GET FAC2 MANTISSA 1     CPY     XX62          ; COMPARE FAC1 MANTISSA 1     BNE     XXDB3F          ; IF <> GO USE THE RESULT     LDY     XX6B          ; GET FAC2 MANTISSA 2     CPY     XX63          ; COMPARE FAC1 MANTISSA 2     BNE     XXDB3F          ; IF <> GO USE THE RESULT     LDY     XX6C          ; GET FAC2 MANTISSA 3     CPY     XX64          ; COMPARE FAC1 MANTISSA 3     BNE     XXDB3F          ; IF <> GO USE THE RESULT     LDY     XX6D          ; GET FAC2 MANTISSA 4     CPY     XX65          ; COMPARE FAC1 MANTISSA 4XXDB3F = *     PHP                    ; SAVE THE FAC2-FAC1 COMPARE STATUS     ROL A                  ;.SHIFT BYTE     BCC     XXDB4C          ; SKIP NEXT IF NO CARR	Y     INX                    ; INCREMENT INDEX TO FAC TEMP     STA     XX29,X          ;.     BEQ     XXDB7A          ;.     BPL     XXDB7E          ;.     LDA     #$01               ;.XXDB4C = *     PLP                    ; RESTORE FAC2-FAC1 C
OMPARE STATUS     BCS     XXDB5D          ; IF FAC2 >= FAC1 THEN DO SUBTRACT                         ; FAC2 = FAC2*2XXDB4F = *     ASL     XX6D          ; SHIFT FAC2 MANTISSA 4     ROL     XX6C          ; SHIFT FAC2 MANTISSA 3     ROL     XX6B          ; SHIFT FAC2 MANTISSA 2     ROL     XX6A          ; SHIFT FAC2 MANTISSA 1     BCS     XXDB3F          ; LOOP WITH NO COMPARE     BMI     XXDB29          ; LOOP WITH COMPARE     BPL     XXDB3F          ; LOOP ALWAYS WITH NO COMPAREXXDB5D = *     TAY                    ; SAVE FAC2-FAC1 COMPARE STATUS     LDA     XX6D          ; GET FAC2 MANTISSA 4     SBC     XX65          ; SUBTRACT FAC1 MANTISSA 4     STA     XX6D          ; SAVE FAC2 MANTISSA 4     LDA     XX6C          ; GET FAC2 MANTISSA 3     SBC     XX64          ; SUBTRACT FAC1 MANTISSA 3     STA     XX6C          ; SAVE FAC2 MANTISSA 3     LDA     XX6B          ; GET FAC2 MANTISSA 2     SBC     XX63          ; SUBTRACT FAC1 MANTISSA 2     STA     XX6B          ; SAVE FAC2 MANTISSA 2     LDA     XX6A          ; GET FAC2 MANTISSA 1     SBC     XX62          ; SUBTRACT FAC1 MANTISSA 1     STA     XX6A          ; SAVE FAC2 MANTISSA 1     TYA                    ; RESTORE FAC2-FAC1 COMPARE STATUS     JMP     XXDB4F          ; GO SHIFT FAC2XXDB7A = *     LDA     #$40               ;.     BNE     XXDB4C          ; BRANCH ALWAYS; DO A<<6, SAVE AS FAC1 ROUNDING BYTE, NORMALISE AND RETURNXXDB7E = *     ASL A                  ;      ASL A                  ;      ASL A                  ;      ASL A                  ;      ASL A                  ;      ASL A                  ;      STA     XX70          ; SAVE FAC1 ROUNDING BYTE     PLP                    ; DUMP FAC2-FAC1 COMPARE STATUS     JMP     XXDB8F          ; COPY TEMP TO FAC1, NORMALISE AND RETURN; DO 'DIVIDE BY ZERO' ERRORXXDB8A = *     LDX     #$14               ; ERROR $14, DIVIDE BY ZERO ERROR     JMP     XXC437          ; DO ERROR #X THEN WARM STARTXXDB8F = *     LDA     XX26          ; GET TEMP MANTISSA 1     STA     XX62          ; SAVE FAC1 MANTISSA 1     LDA     XX27          ; GET TEMP MANTISSA 2     STA     XX63          ; SAVE FAC1 MANTISSA 2     LDA     XX28          ; GET TEMP MANTISSA 3     STA     XX64          ; SAVE FAC1 MANTISSA 3     LDA     XX29          ; GET TEMP MANTISSA 4     STA     XX65          ; SAVE FAC1 MANTISSA 4     JMP     XXD8D7          ; NORMALISE FAC1 AND RETURN;***********************************************************************************;;; UNPACK MEMORY (AY) INTO FAC1XXDBA2 = *     STA     XX22          ; SAVE POINTER LOW BYTE     STY     XX23          ; SAVE POINTER HIGH BYTE     LDY     #$04               ; 5 BYTES TO DO     LDA     (XX22),Y          ; GET FIFTH BYTE     STA     XX65          ; SAVE FAC1 MANTISSA 4     DEY                    ; DECREMENT INDEX     LDA     (XX22),Y          ; GET FOURTH BYTE     STA     XX64          ; SAVE FAC1 MANTISSA 3     DEY                    ; DECREMENT INDEX     LDA     (XX22),Y          ; GET THIRD BYTE     STA     XX63          ; SAVE FAC1 MANTISSA 2     DEY                    ; DECREMENT INDEX     LDA     (XX22),Y          ; GET SECOND BYTE     STA     XX66          ; SAVE FAC1 SIGN (B7)     ORA     #$80               ; SET 1XXX XXXX (ADD NORMAL BIT)     STA     XX62          ; SAVE FAC1 MANTISSA 1     DEY                    ; DECREMENT INDEX     LDA     (XX22),Y          ; GET FIRST BYTE (EXPONENT)     STA     XX61          ; SAVE FAC1 EXPONENT     STY     XX70          ; CLEAR FAC1 ROUNDING BYTE     RTS;***********************************************************************************;;; PACK FAC1 INTO XX5CXXDBC7 = *     LDX     #<XX5C          ; SET POINTER LOW BYTE     .BYTE     $2C               ; MAKES NEXT LINE BIT XX57A2; PACK FAC1 INTO XX57XXDBCA = *     LDX     #<XX57          ; SET POINTER LOW BYTE     LDY     #>XX57          ; SET POINTER HIGH BYTE     BEQ     XXDBD4          ; PACK FAC1 INTO (XY) AND RETURN, BRANCH ALWAYS; PACK FAC1 INTO VARIABLE POINTERXXDBD0 = *     LDX     XX49          ; GET DESTINATION POINTER LOW BYTE     LDY     XX4A          ; GET DESTINATION POINTER HIGH BYTE; PACK FAC1 INTO (XY)XXDBD4 = *     JSR     XXDC1B          ; ROUND FAC1     STX     XX22          ; SAVE POINTER LOW BYTE     STY     XX23          ; SAVE POINTER HIGH BYTE     LDY     #$04               ; SET INDEX     LDA     XX65          ; GET FAC1 MANTISSA 4     STA     (XX22),Y          ; STORE IN DESTINATION     DEY                    ; DECREMENT INDEX     LDA     XX64          ; GET FAC1 MANTISSA 3     STA     (XX22),Y          ; STORE IN DESTINATION     DEY                    ; DECREMENT INDEX     LDA     XX63          ; GET FAC1 MANTISSA 2     STA     (XX22),Y          ; STORE IN DESTINATION     DEY                    ; DECREMENT INDEX     LDA     XX66          ; GET FAC1 SIGN (B7)     ORA     #$7F               ; SET BITS X111 1111     AND     XX62          ; AND IN FAC1 MANTISSA 1     STA     (XX22),Y          ; STORE IN DESTINATION     DEY                    ; DECREMENT INDEX     LDA     XX61          ; GET FAC1 EXPONENT     STA     (XX22),Y          ; STORE IN DESTINATION     STY     XX70          ; CLEAR FAC1 ROUNDING BYTE     RTS;***********************************************************************************;;; COPY FAC2 TO FAC1XXDBFC = *     LDA     XX6E          ; GET FAC2 SIGN (B7); SAVE FAC1 SIGN AND COPY ABS(FAC2) TO FAC1XXDBFE = *     STA     XX66          ; SAVE FAC1 SIGN ( B7)     LDX     #$05               ; 5 BYTES TO COPYXXDC02 = *     LDA     XX68,X          ; GET BYTE FROM FAC2,X     STA     XX60,X          ; SAVE BYTE AT FAC1,X     DEX                    ; DECREMENT COUNT     BNE     XXDC02          ; LOOP IF N!OT ALL DONE     STX     XX70          ; CLEAR FAC1 ROUNDING BYTE     RTS;***********************************************************************************;;; ROUND AND COPY FAC1 TO FAC2XXDC0C = *     JSR     XXDC1B          ; ROUND FAC1; C"OPY FAC1 TO FAC2XXDC0F = *     LDX     #$06               ; 6 BYTES TO COPYXXDC11 = *     LDA     XX60,X          ; GET BYTE FROM FAC1,X     STA     XX68,X          ; SAVE BYTE AT FAC2,X     DEX                    ; DECREMENT COUNT     BNE     XX#DC11          ; LOOP IF NOT ALL DONE     STX     XX70          ; CLEAR FAC1 ROUNDING BYTEXXDC1A = *     RTS;***********************************************************************************;;; ROUND FAC1XXDC1B = *     LDA     XX61          $; GET FAC1 EXPONENT     BEQ     XXDC1A          ; EXIT IF ZERO     ASL     XX70          ; SHIFT FAC1 ROUNDING BYTE     BCC     XXDC1A          ; EXIT IF NO OVERFLOW; ROUND FAC1 (NO CHECK)XXDC23 = *     JSR     XXD96F          ; INCREMENT FAC1 M%ANTISSA     BNE     XXDC1A          ; BRANCH IF NO OVERFLOW     JMP     XXD938          ; NORNALISE FAC1 FOR C=1 AND RETURN; GET FAC1 SIGN; RETURN A = $FF, CB = 1/-VE A = $01, CB = 0/+VE, A = $00, CB = ?/0XXDC2B = *     LDA     XX61          ; G&ET FAC1 EXPONENT     BEQ     XXDC38          ; EXIT IF ZERO (ALLREADY CORRECT SGN(0)=0); RETURN A = $FF, CB = 1/-VE A = $01, CB = 0/+VE; NO = 0 CHECKXXDC2F = *     LDA     XX66          ; ELSE GET FAC1 SIGN (B7); RETURN A = $FF, CB = 1/-VE A = $'01, CB = 0/+VE; NO = 0 CHECK, SIGN IN AXXDC31 = *     ROL A                  ; MOVE SIGN BIT TO CARRY     LDA     #$FF               ; SET BYTE FOR -VE RESULT     BCS     XXDC38          ; RETURN IF SIGN WAS SET (-VE)     LDA     #$01            
    ; ELSE SET BYTE FOR +VE RESULTXXDC38 = *     RTS;***********************************************************************************;;; PERFORM SGN()XXDC39 = *     JSR     XXDC2B          ; GET FAC1 SIGN, RETURN A = $FF -VE, A = $01 +VE; S01,X          ; SAVE FACX MANTISSA 1; SHIFT FACX -A TIMES RIGHT (> 8 SHIFTS)XXD999 = *     ADC     #$08               ; ADD 8 TO SHIFT COUNT     BMI     XXD985          ; GO DO 8 SHIFT IF STILL -VE     BEQ     XXD985          ; GO DO 8 SHIFT IF ZERO     SBC     #$08               ; ELSE SUBTRACT 8 AGAIN     TAY                    ; SAVE COUNT TO Y     LDA     XX70          ; GET FAC1 ROUNDING BYTE     BCS     XXD9BA          ;.XXD9A6 = *     ASL     XX01,X          ; SHIFT FACX MANTISSA 1     BCC     XXD9AC          ; BRANCH IF +VE     INC     XX01,X          ; THIS SETS B7 EVENTUALLYXXD9AC = *     ROR     XX01,X          ; SHIFT FACX MANTISSA 1 (CORRECT FOR ASL)     ROR     XX01,X          ; SHIFT FACX MANTISSA 1 (PUT CARRY IN B7); SHIFT FACX Y TIMES RIGHTXXD9B0 = *     ROR     XX02,X          ; SHIFT FACX MANTISSA 2     ROR     XX03,X          ; SHIFT FACX MANTISSA 3     ROR     XX04,X          ; SHIFT FACX MANTISSA 4     ROR A                  ; SHIFT FACX ROUNDING BYTE     INY                    ; INCREMENT EXPONENT DIFF     BNE     XXD9A6          ; BRANCH IF RANGE ADJUST NOT COMPLETEXXD9BA = *     CLC                    ; JUST CLEAR IT     RTS;***********************************************************************************;;; CONSTANTS AND SERIES FOR LOG(N)XXD9BC = *     .BYTE     $81,$00,$00,$00,$00     ; 1XXD9C1 = *     .BYTE     $03                    ; SERIES COUNTER     .BYTE     $7F,$5E,$56,$CB,$79     .BYTE     $80,$13,$9B,$0B,$64     .BYTE     $80,$76,$38,$93,$16     .BYTE     $82,$38,$AA,$3B,$20XXD9D6 = *     .BYTE     $80,$35,$04,$F3,$34     ; 0.70711     1/ROOT 2XXD9DB = *     .BYTE     $81,$35,$04,$F3,$34     ; 1.41421     ROOT 2XXD9E0 = *     .BYTE     $80,$80,$00,$00,$00     ; -0.5     1/2XXD9E5 = *     .BYTE     $80,$31,$72,$17,$F8     ; 0.69315     LOG(2);***********************************************************************************;;; PERFORM LOG()XXD9EA = *     JSR     XXDC2B          ; TEST SIGN AN	D ZERO     BEQ     XXD9F1          ; IF ZERO DO ILLEGAL QUANTITY ERROR THEN WARM START     BPL     XXD9F4          ; SKIP ERROR IF +VEXXD9F1 = *     JMP     XXD248          ; DO ILLEGAL QUANTITY ERROR THEN WARM STARTXXD9F4 = *     LDA     XX61  
        ; GET FAC1 EXPONENT     SBC     #$7F               ; NORMALISE IT     PHA                    ; SAVE IT     LDA     #$80               ; SET EXPONENT TO ZERO     STA     XX61          ; SAVE FAC1 EXPONENT     LDA     #<XXD9D6          ; POINTER TO 1/ROOT 2 LOW BYTE     LDY     #>XXD9D6          ; POINTER TO 1/ROOT 2 HIGH BYTE     JSR     XXD867          ; ADD (AY) TO FAC1 (1/ROOT2)     LDA     #<XXD9DB          ; POINTER TO ROOT 2 LOW BYTE     LDY     #>XXD9DB          ; POINTER TO ROOT 2 HIGH BYTE     JSR     XXDB0F          ; CONVERT AY AND DO (AY)/FAC1 (ROOT2/(X+(1/ROOT2)))     LDA     #<XXD9BC          ; POINTER TO 1 LOW BYTE     LDY     #>XXD9BC          ; POINTER TO 1 HIGH BYTE     JSR     XXD850          ; SUBTRACT FAC1 ((ROOT2/(X+(1/ROOT2)))-1) FROM (AY)     LDA     #<XXD9C1          ; POINTER TO SERIES FOR LOG(N) LOW BYTE     LDY     #>XXD9C1          ; POINTER TO SERIES FOR LOG(N) HIGH BYTE     JSR     XXE040          ; ^2 THEN SERIES EVALUATION     LDA     #<XXD9E0          ; POINTER TO -0.5 LOW BYTE     LDY     #>XXD9E0          ; POINTER TO -0.5 HIGH BYTE     JSR     XXD867          ; ADD (AY) TO FAC1     PLA                    ; RESTORE FAC1 EXPONENT     JSR     XXDD7E          ; EVALUATE NEW ASCII DIGIT     LDA     #<XXD9E5          ; POINTER TO LOG(2) LOW BYTE     LDY     #>XXD9E5          ; POINTER TO LOG(2) HIGH BYTE; DO CONVERT AY, FCA1*(AY)XXDA28 = *     JSR     XXDA8C          ; UNPACK MEMORY (AY) INTO FAC2XXDA2B = *     BNE     XXDA30          ; MULTIPLY FAC1 BY FAC2 ??     JMP     XXDA8B          ; EXIT IF ZEROXXDA30 = *     JSR     XXDAB7          ; TEST AND ADJUST ACCUMULATORS     LDA     #$00               ; CLEAR A     STA     XX26          ; CLEAR TEMP MANTISSA 1     STA     XX27          ; CLEAR TEMP MANTISSA 2     STA     XX28          ; CLEAR TEMP MANTISSA 3     STA     XX29          ; CLEAR TEMP MANTISSA 4     LDA     XX70          ; GET FAC1 ROUNDING BYTE     JSR     XXDA59          ; GO DO SHIFT/ADD FAC2     LDA     XX65          ; GET FAC1 MANTISSA 4     JSR     XXDA59          ; GO DO SHIFT/ADD FAC2     LDA     XX64          ; GET FAC1 MANTISSA 3     JSR     XXDA59          ; GO DO SHIFT/ADD FAC2     LDA     XX63          ; GET FAC1 MANTISSA 2     JSR     XXDA59          ; GO DO SHIFT/ADD FAC2     LDA     XX62          ; GET FAC1 MANTISSA 1     JSR     XXDA5E          ; GO DO SHIFT/ADD FAC2     JMP     XXDB8F          ; COPY TEMP TO FAC1, NORMALISE AND RETURNXXDA59 = *     BNE     XXDA5E          ; BRANCH IF BYTE <> ZERO     JMP     XXD983          ; SHIFT FCATEMP << A+8 TIMES                         ; ELSE DO SHIFT AND ADDXXDA5E = *     LSR A                  ; SHIFT BYTE     ORA     #$80               ; SET TOP BIT (MARK FOR 8 TIMES)XXDA61 = *     TAY                    ; COPY RESULT     BCC     XXDA7D          ; SKIP NEXT IF BIT WAS ZERO     CLC                    ; CLEAR CARRY FOR ADD     LDA     XX29          ; GET TEMP MANTISSA 4     ADC     XX6D          ; ADD FAC2 MANTISSA 4     STA     XX29          ; SAVE TEMP MANTISSA 4     LDA     XX28          ; GET TEMP MANTISSA 3     ADC     XX6C          ; ADD FAC2 MANTISSA 3     STA     XX28          ; SAVE TEMP MANTISSA 3     LDA     XX27          ; GET TEMP MANTISSA 2     ADC     XX6B          ; ADD FAC2 MANTISSA 2     STA     XX27          ; SAVE TEMP MANTISSA 2     LDA     XX26          ; GET TEMP MANTISSA 1     ADC     XX6A          ; ADD FAC2 MANTISSA 1     STA     XX26          ; SAVE TEMP MANTISSA 1XXDA7D = *     ROR     XX26          ; SHIFT TEMP MANTISSA 1     ROR     XX27          ; SHIFT TEMP MANTISSA 2     ROR     XX28          ; SHIFT TEMP MANTISSA 3     ROR     XX29          ; SHIFT TEMP MANTISSA 4     ROR     XX70          ; SHIFT TEMP ROUNDING BYTE     TYA                    ; GET BYTE BACK     LSR A                  ; SHIFT BYTE     BNE     XXDA61          ; LOOP IF ALL BITS NOT DONEXXDA8B = *     RTS;***********************************************************************************;;; UNPACK MEMORY (AY) INTO FAC2XXDA8C = *     STA     XX22          ; SAVE POINTER LOW BYTE     STY     XX23          ; SAVE POINTER HIGH BYTE     LDY     #$04               ; 5 BYTES TO GET (0-4)     LDA     (XX22),Y          ; GET MANTISSA 4     STA     XX6D          ; SAVE FAC2 MANTISSA 4     DEY                    ; DECREMENT INDEX     LDA     (XX22),Y          ; GET MANTISSA 3     STA     XX6C          ; SAVE FAC2 MANTISSA 3     DEY                    ; DECREMENT INDEX     LDA     (XX22),Y          ; GET MANTISSA 2     STA     XX6B          ; SAVE FAC2 MANTISSA 2     DEY                    ; DECREMENT INDEX     LDA     (XX22),Y          ; GET MANTISSA 1 + SIGN     STA     XX6E          ; SAVE FAC2 SIGN (B7)     EOR     XX66          ; EOR WITH FAC1 SIGN (B7)     STA     XX6F          ; SAVE SIGN COMPARE (FAC1 EOR FAC2)     LDA     XX6E          ; RECOVER FAC2 SIGN (B7)     ORA     #$80               ; SET 1XXX XXX (SET NORMAL BIT)     STA     XX6A          ; SAVE FAC2 MANTISSA 1     DEY                    ; DECREMENT INDEX     LDA     (XX22),Y          ; GET EXPONENT BYTE     STA     XX69          ; SAVE FAC2 EXPONENT     LDA     XX61          ; GET FAC1 EXPONENT     RTS;***********************************************************************************;;; TEST AND ADJUST ACCUMULATORSXXDAB7 = *     LDA     XX69          ; GET FAC2 EXPONENTXXDAB9 = *     BEQ     XXDADA          ; BRANCH IF FAC2 = $00 (HANDLE UNDERFLOW)     CLC                    ; CLEAR CARRY  FOR ADD     ADC     XX61          ; ADD FAC1 EXPONENT     BCC     XXDAC4          ; BRANCH IF SUM OF EXPONENTS < $0100     BMI     XXDADF          ; DO OVERFLOW ERROR     CLC                    ; CLEAR CARRY FOR THE ADD     .BYTE     $2C         !      ; MAKES NEXT LINE BIT XX1410XXDAC4 = *     BPL     XXDADA          ; IF +VE GO HANDLE UNDERFLOW     ADC     #$80               ; ADJUST EXPONENT     STA     XX61          ; SAVE FAC1 EXPONENT     BNE     XXDACF          ; BRANCH IF NOT ZERO"     JMP     XXD8FB          ; SAVE FAC1 SIGN AND RETURNXXDACF = *     LDA     XX6F          ; GET SIGN COMPARE (FAC1 EOR FAC2)     STA     XX66          ; SAVE FAC1 SIGN (B7)     RTS;*************************************************************#**********************;;; HANDLE OVERFLOW AND UNDERFLOWXXDAD4 = *     LDA     XX66          ; GET FAC1 SIGN (B7)     EOR     #$FF               ; COMPLEMENT IT     BMI     XXDADF          ; DO OVERFLOW ERROR                         ; HANDLE UNDE$RFLOWXXDADA = *     PLA                    ; POP RETURN ADDRESS LOW BYTE     PLA                    ; POP RETURN ADDRESS HIGH BYTE     JMP     XXD8F7          ; CLEAR FAC1 EXPONENT AND SIGN AND RETURNXXDADF = *     JMP     XXD97E          ; DO OVE%RFLOW ERROR THEN WARM START;***********************************************************************************;;; MULTIPLY FAC1 BY 10XXDAE2 = *     JSR     XXDC0C          ; ROUND AND COPY FAC1 TO FAC2     TAX                    ; COPY EXPONENT& (SET THE FLAGS)     BEQ     XXDAF8          ; EXIT IF ZERO     CLC                    ; CLEAR CARRY FOR ADD     ADC     #$02               ; ADD TWO TO EXPONENT (*4)     BCS     XXDADF          ; DO OVERFLOW ERROR IF > $FF; FAC1 = (FAC1 + FAC2) *' 2XXDAED = *     LDX     #$00               ; CLEAR BYTE     STX     XX6F          ; CLEAR SIGN COMPARE (FAC1 EOR FAC2)     JSR     XXD877          ; ADD FAC2 TO FAC1 (*5)     INC     XX61          ; INCREMENT FAC1 EXPONENT (*10)     BEQ     XXDAD F          ; IF EXPONENT NOW ZERO GO DO OVERFLOW ERRORXXDAF8 = *     RTS;***********************************************************************************;;; 10 AS A FLOATING VALUEXXDAF9 = *     .BYTE     $84,$20,$00,$00,$00     ; 10;**** FAC1 SIGN (B7)     EOR     #$FF               ; COMPLEMENT IT     STA     XX66          ; SAVE FAC1 SIGN (B7)     EOR     XX6E          ; EOR WITH FAC2 SIGN (B7)     STA     XX6F          ; SAVE SIGN COMPARE (FAC1 EOR FAC2)     LDA     XX61          ; GET FAC1 EXPONENT     JMP     XXD86A          ; ADD FAC2 TO FAC1 AND RETURNXXD862 = *     JSR     XXD999          ; SHIFT FACX A TIMES RIGHT (>8 SHIFTS)     BCC     XXD8A3          ; GO SUBTRACT THE MANTISSAS, BRANCH ALWAYS;***********************************************************************************;;; ADD (AY) TO FAC1XXD867 = *     JSR     XXDA8C          ; UNPACK MEMORY (AY) INTO FAC2; ADD FAC2 TO FAC1XXD86A = *     BNE     XXD86F          ; IF FAC1 IS NOT ZERO GO DO THE ADD     JMP     XXDBFC          ; FAC1 WAS ZERO SO COPY FAC2 TO FAC1 AND RETURN                         ; FAC1 IS NON ZEROXXD86F = *     LDX     XX70          ; GET FAC1 ROUNDING BYTE     STX     XX56          ; SAVE AS FAC2 ROUNDING BYTE     LDX     #XX69          ; SET INDEX TO FAC2 EXPONENT ADDRESS     LDA     XX69          ; GET FAC2 EXPONENTXXD877 = *     TAY                    ; COPY EXPONENT     BEQ     XXD848          ; EXIT IF ZERO     SEC                    ; SET CARRY FOR SUBTRACT     SBC     XX61          ; SUBTRACT FAC1 EXPONENT     BEQ     XXD8A3          ; IF EQUAL GO ADD MANTISSAS     BCC     XXD893          ; IF FAC2 < FAC1 THEN GO SHIFT FAC2 RIGHT                         ; ELSE FAC2 > FAC1     STY     XX61          ; SAVE FAC1 EXPONENT     LDY     XX6E          ; GET FAC2 SIGN (B7)     STY     XX66          ; SAVE FAC1 SIGN (B7)     EOR     #$FF               ; COMPLEMENT A     ADC     #$00               ; +1, TWOS COMPLEMENT, CARRY IS SET     LDY     #$00               ; CLEAR Y     STY     XX56          ; CLEAR FAC2 ROUNDING BYTE     LDX     #XX61          ; SET INDEX TO FAC1 EXPONENT ADDRESS     BNE     XXD897          ; BRANCH ALWAYS                         ; FAC2 < FAC1XXD893 = *     LDY     #$00	               ; CLEAR Y     STY     XX70          ; CLEAR FAC1 ROUNDING BYTEXXD897 = *     CMP     #$F9               ; COMPARE EXPONENT DIFF WITH $F9     BMI     XXD862          ; BRANCH IF RANGE $79-$F8     TAY                    ; COPY EXPONENT
 DIFFERENCE TO Y     LDA     XX70          ; GET FAC1 ROUNDING BYTE     LSR     XX01,X          ; SHIFT FAC? MANTISSA 1     JSR     XXD9B0          ; SHIFT FACX Y TIMES RIGHT                         ; EXPONENTS ARE EQUAL NOW DO MANTISSA SUBTRACTXXD8A3 = *     BIT     XX6F          ; TEST SIGN COMPARE (FAC1 EOR FAC2)     BPL     XXD8FE          ; IF = ADD FAC2 MANTISSA TO FAC1 MANTISSA AND RETURN     LDY     #XX61          ; SET INDEX TO FAC1 EXPONENT ADDRESS     CPX     #XX69          ; COMPARE X TO FAC2 EXPONENT ADDRESS     BEQ     XXD8AF          ; BRANCH IF =     LDY     #XX69          ; ELSE SET INDEX TO FAC2 EXPONENT ADDRESS                         ; SUBTRACT SMALLER FROM BIGGER (TAKE SIGN OF BIGGER)XXD8AF = *     SEC                    ; SET CARRY FOR SUBTRACT     EOR     #$FF               ; ONES COMPLEMENT A     ADC     XX56          ; ADD FAC2 ROUNDING BYTE     STA     XX70          ; SAVE FAC1 ROUNDING BYTE     LDA     XX04,Y          ; GET FACY MANTISSA 4     SBC     XX04,X          ; SUBTRACT FACX MANTISSA 4     STA     XX65          ; SAVE FAC1 MANTISSA 4     LDA     XX03,Y          ; GET FACY MANTISSA 3     SBC     XX03,X          ; SUBTRACT FACX MANTISSA 3     STA     XX64          ; SAVE FAC1 MANTISSA 3     LDA     XX02,Y          ; GET FACY MANTISSA 2     SBC     XX02,X          ; SUBTRACT FACX MANTISSA 2     STA     XX63          ; SAVE FAC1 MANTISSA 2     LDA     XX01,Y          ; GET FACY MANTISSA 1     SBC     XX01,X          ; SUBTRACT FACX MANTISSA 1     STA     XX62          ; SAVE FAC1 MANTISSA 1;***********************************************************************************;;; DO ABS AND NORMALISE FAC1XXD8D2 = *     BCS     XXD8D7          ; BRANCH IF NUMBER IS +VE     JSR     XXD947          ; NEGATE FAC1; NORMALISE FAC1XXD8D7 = *     LDY     #$00               ; CLEAR Y     TYA                    ; CLEAR A     CLC                    ; CLEAR CARRY FOR ADDXXD8DB = *     LDX     XX62          ; GET FAC1 MANTISSA 1     BNE     XXD929          ; IF NOT ZERO NORMALISE FAC1     LDX     XX63          ; GET FAC1 MANTISSA 2     STX     XX62          ; SAVE FAC1 MANTISSA 1     LDX     XX64          ; GET FAC1 MANTISSA 3     STX     XX63          ; SAVE FAC1 MANTISSA 2     LDX     XX65          ; GET FAC1 MANTISSA 4     STX     XX64          ; SAVE FAC1 MANTISSA 3     LDX     XX70          ; GET FAC1 ROUNDING BYTE     STX     XX65          ; SAVE FAC1 MANTISSA 4     STY     XX70          ; CLEAR FAC1 ROUNDING BYTE     ADC     #$08               ; ADD X TO EXPONENT OFFSET     CMP     #$20               ; COMPARE WITH $20, MAX OFFSET, ALL BITS WOULD BE = 0     BNE     XXD8DB          ; LOOP IF NOT MAX;***********************************************************************************;;; CLEAR FAC1 EXPONENT AND SIGNXXD8F7 = *     LDA     #$00               ; CLEAR AXXD8F9 = *     STA     XX61          ; SET FAC1 EXPONENT; SAVE FAC1 SIGNXXD8FB = *     STA     XX66          ; SAVE FAC1 SIGN (B7)     RTS;***********************************************************************************;;; ADD FAC2 MANTISSA TO FAC1 MANTISSAXXD8FE = *     ADC     XX56          ; ADD FAC2 ROUNDING BYTE     STA     XX70          ; SAVE FAC1 ROUNDING BYTE     LDA     XX65          ; GET FAC1 MANTISSA 4     ADC     XX6D          ; ADD FAC2 MANTISSA 4     STA     XX65          ; SAVE FAC1 MANTISSA 4     LDA     XX64          ; GET FAC1 MANTISSA 3     ADC     XX6C          ; ADD FAC2 MANTISSA 3     STA     XX64          ; SAVE FAC1 MANTISSA 3     LDA     XX63          ; GET FAC1 MANTISSA 2     ADC     XX6B          ; ADD FAC2 MANTISSA 2     STA     XX63          ; SAVE FAC1 MANTISSA 2     LDA     XX62          ; GET FAC1 MANTISSA 1     ADC     XX6A          ; ADD FAC2 MANTISSA 1     STA     XX62          ; SAVE FAC1 MANTISSA 1     JMP     XXD936          ; TEST AND NORMALISE FAC1 FOR C=0/1XXD91D = *     ADC     #$01               ; ADD 1 TO EXPONENT OFFSET     ASL     XX70          ; SHIFT FAC1 ROUNDING BYTE     ROL     XX65          ; SHIFT FAC1 MANTISSA 4     ROL     XX64          ; SHIFT FAC1 MANTISSA 3     ROL     XX63          ; SHIFT FAC1 MANTISSA 2     ROL     XX62          ; SHIFT FAC1 MANTISSA 1;***********************************************************************************;;; NORMALISE FAC1XXD929 = *     BPL     XXD91D          ; LOOP IF NOT NORMALISED     SEC                    ; SET CARRY FOR SUBTRACT     SBC     XX61          ; SUBTRACT FAC1 EXPONENT     BCS     XXD8F7          ; BRANCH IF UNDERFLOW (SET RESULT = $0)     EOR     #$FF               ; COMPLEMENT EXPONENT     ADC     #$01               ; +1 (TWOS COMPLEMENT)     STA     XX61          ; SAVE FAC1 EXPONENT; TEST AND NORMALISE FAC1 FOR C=0/1XXD936 = *     BCC     XXD946          ; EXIT IF NO OVERFLOW; NORMALISE FAC1 FOR C=1XXD938 = *     INC     XX61          ; INCREMENT FAC1 EXPONENT     BEQ     XXD97E          ; IF ZERO DO OVERFLOW ERROR THEN WARM START     ROR     XX62          ; SHIFT FAC1 MANTISSA 1     ROR     XX63          ; SHIFT FAC1 MANTISSA 2     ROR     XX64          ; SHIFT FAC1 MANTISSA 3     ROR     XX65          ; SHIFT FAC1 MANTISSA 4     ROR     XX70          ; SHIFT FAC1 ROUNDING BYTEXXD946 = *     RTS;***********************************************************************************;;; NEGATE FAC1XXD947 = *     LDA     XX66          ; GET FAC1 SIGN (B7)     EOR     #$FF               ; COMPLEMENT IT     STA     XX66          ; SAVE FAC1 SIGN  (B7); TWOS COMPLEMENT FAC1 MANTISSAXXD94D = *     LDA     XX62          ; GET FAC1 MANTISSA 1     EOR     #$FF               ; COMPLEMENT IT     STA     XX62          ; SAVE FAC1 MANTISSA 1     LDA     XX63          ; GET FAC1 MANTISSA 2     EO!R     #$FF               ; COMPLEMENT IT     STA     XX63          ; SAVE FAC1 MANTISSA 2     LDA     XX64          ; GET FAC1 MANTISSA 3     EOR     #$FF               ; COMPLEMENT IT     STA     XX64          ; SAVE FAC1 MANTISSA 3     LDA     XX6"5          ; GET FAC1 MANTISSA 4     EOR     #$FF               ; COMPLEMENT IT     STA     XX65          ; SAVE FAC1 MANTISSA 4     LDA     XX70          ; GET FAC1 ROUNDING BYTE     EOR     #$FF               ; COMPLEMENT IT     STA     XX70      #    ; SAVE FAC1 ROUNDING BYTE     INC     XX70          ; INCREMENT FAC1 ROUNDING BYTE     BNE     XXD97D          ; EXIT IF NO OVERFLOW; INCREMENT FAC1 MANTISSAXXD96F = *     INC     XX65          ; INCREMENT FAC1 MANTISSA 4     BNE     XXD97D  $        ; FINISHED IF NO ROLLOVER     INC     XX64          ; INCREMENT FAC1 MANTISSA 3     BNE     XXD97D          ; FINISHED IF NO ROLLOVER     INC     XX63          ; INCREMENT FAC1 MANTISSA 2     BNE     XXD97D          ; FINISHED IF NO ROLLOVE%R     INC     XX62          ; INCREMENT FAC1 MANTISSA 1XXD97D = *     RTS;***********************************************************************************;;; DO OVERFLOW ERROR THEN WARM STARTXXD97E = *     LDX     #$0F               ; ERRO&R $0F, OVERFLOW ERROR     JMP     XXC437          ; DO ERROR #X THEN WARM START;***********************************************************************************;;; SHIFT FCATEMP << A+8 TIMESXXD983 = *     LDX     #$25               ; SET OFFS'ET TO FACTEMPXXD985 = *     LDY     XX04,X          ; GET FACX MANTISSA 4     STY     XX70          ; SAVE AS FAC1 ROUNDING BYTE     LDY     XX03,X          ; GET FACX MANTISSA 3     STY     XX04,X          ; SAVE FACX MANTISSA 4     LDY     XX02,X           ; GET FACX MANTISSA 2     STY     XX03,X          ; SAVE FACX MANTISSA 3     LDY     XX01,X          ; GET FACX MANTISSA 1     STY     XX02,X          ; SAVE FACX MANTISSA 2     LDY     XX68          ; GET FAC1 OVERFLOW BYTE     STY     XX  XXD761          ; PULL STRING DATA AND BYTE PARAMETER FROM STACK                         ; RETURN POINTER IN DESCRIPTOR, BYTE IN A (AND X), Y=0     BEQ     XXD798          ; IF NULL DO ILLEGAL QUANTITY ERROR THEN WARM START     DEX                    ; DECREMENT START INDEX     TXA                    ; COPY TO A     PHA                    ; SAVE STRING START OFFSET     CLC                    ; CLEAR CARRY FOR SUB-1     LDX     #$00               ; CLEAR OUTPUT STRING LENGTH     SBC     (XX50),Y          ; SUBTRACT STRING LENGTH     BCS     XXD70D          ; IF START>STRING LENGTH GO DO NULL STRING     EOR     #$FF               ; COMPLEMENT -LENGTH     CMP     XX65          ; COMPARE BYTE PARAMETER     BCC     XXD70E          ; IF LENGTH>REMAINING STRING GO DO RIGHT$     LDA     XX65          ; GET LENGTH BYTE     BCS     XXD70E          ; GO DO STRING COPY, BRANCH ALWAYS;***********************************************************************************;;; PULL STRING DATA AND BYTE PARAMETER FROM STACK; RETURN POINTER IN DESCRIPTOR, BYTE IN A (AND X), Y=0XXD761 = *     JSR     XXCEF7          ; SCAN FOR ')', ELSE DO SYNTAX ERROR THEN WARM START     PLA                    ; PULL RETURN ADDRESS LOW BYTE     TAY                    ; SAVE RETURN ADDRESS LOW BYTE     PLA                    ; PULL RETURN ADDRESS HIGH BYTE     STA     XX55          ; SAVE RETURN ADDRESS HIGH BYTE     PLA                    ; DUMP CALL TO FUNCTION VECTOR LOW BYTE     PLA                    ; DUMP CALL TO FUNCTION VECTOR HIGH BYTE     PLA                    ; PULL BYTE PARAMETER     TAX                    ; COPY BYTE PARAMETER TO X     PLA                    ; PULL STRING POINTER LOW BYTE     STA     XX50          ; SAVE IT     PLA                    ; PULL STRING POINTER HIGH BYTE     STA     XX51          ; SAVE IT     LDA     XX55          ; GET RETURN ADDRESS HIGH BYTE     PHA                    ; BACK ON STACK     TYA                    ; GET RETURN ADDRESS LOW BYTE     PHA	                    ; BACK ON STACK     LDY     #$00               ; CLEAR INDEX     TXA                    ; COPY BYTE PARAMETER     RTS;***********************************************************************************;;; PERFORM LEN()XXD77C
 = *     JSR     XXD782          ; EVALUATE STRING, GET LENGTH IN A (AND Y)     JMP     XXD3A2          ; CONVERT Y TO BYTE IN FAC1 AND RETURN;***********************************************************************************;;; EVALUATE STRING, GET LENGTH IN YXXD782 = *     JSR     XXD6A3          ; EVALUATE STRING     LDX     #$00               ; SET DATA TYPE = NUMERIC     STX     XX0D          ; CLEAR DATA TYPE FLAG, $FF = STRING, $00 = NUMERIC     TAY                    ; COPY LENGTH TO Y     RTS;***********************************************************************************;;; PERFORM ASC()XXD78B = *     JSR     XXD782          ; EVALUATE STRING, GET LENGTH IN A (AND Y)     BEQ     XXD798          ; IF NULL DO ILLEGAL QUANTITY ERROR THEN WARM START     LDY     #$00               ; SET INDEX TO FIRST CHARACTER     LDA     (XX22),Y          ; GET BYTE     TAY                    ; COPY TO Y     JMP     XXD3A2          ; CONVERT Y TO BYTE IN FAC1 AND RETURN;***********************************************************************************;;; DO ILLEGAL QUANTITY ERROR THEN WARM STARTXXD798 = *     JMP     XXD248          ; DO ILLEGAL QUANTITY ERROR THEN WARM START;***********************************************************************************;;; SCAN AND GET BYTE PARAMETERXXD79B = *     JSR     XX0073          ; INCREMENT AND SCAN MEMORY; GET BYTE PARAMETERXXD79E = *     JSR     XXCD8A          ; EVALUATE EXPRESSION AND CHECK IS NUMERIC, ELSE DO                         ; TYPE MISMATCH; EVALUATE BYTE EXPRESSION, RESULT IN XXXD7A1 = *     JSR     XXD1B8          ; EVALUATE INTEGER EXPRESSION, SIGN CHECK     LDX     XX64          ; GET FAC1 MANTISSA 3     BNE     XXD798          ; IF NOT NULL DO ILLEGAL QUANTITY ERROR THEN WARM START     LDX     XX65          ; GET FAC1 MANTISSA 4     JMP     XX0079          ; SCAN MEMORY AND RETURN;***********************************************************************************;;; PERFORM VAL()XXD7AD = *     JSR     XXD782          ; EVALUATE STRING, GET LENGTH IN A (AND Y)     BNE     XXD7B5          ; IF NOT A NULL STRING GO EVALUATE IT                         ; STRING WAS NULL SO SET RESULT = $00     JMP     XXD8F7          ; CLEAR FAC1 EXPONENT AND SIGN AND RETURNXXD7B5 = *     LDX     XX7A          ; GET BASIC EXECUTE POINTER LOW BYTE     LDY     XX7B          ; GET BASIC EXECUTE POINTER HIGH BYTE     STX     XX71          ; SAVE BASIC EXECUTE POINTER LOW BYTE     STY     XX72          ; SAVE BASIC EXECUTE POINTER HIGH BYTE     LDX     XX22          ; GET STRING POINTER LOW BYTE     STX     XX7A          ; SAVE BASIC EXECUTE POINTER LOW BYTE     CLC                    ; CLEAR CARRY FOR ADD     ADC     XX22          ; ADD STRING LENGTH     STA     XX24          ; SAVE STRING END LOW BYTE     LDX     XX23          ; GET STRING POINTER HIGH BYTE     STX     XX7B          ; SAVE BASIC EXECUTE POINTER HIGH BYTE     BCC     XXD7CD          ; IF NO ROLLOVER SKIP THE HIGH BYTE INCREMENT     INX                    ; INCREMENT STRING END HIGH BYTEXXD7CD = *     STX     XX25          ; SAVE STRING END HIGH BYTE     LDY     #$00               ; SET INDEX TO $00     LDA     (XX24),Y          ; GET STRING END BYTE     PHA                    ; PUSH IT     TYA                    ; CLEAR A     STA     (XX24),Y          ; TERMINATE STRING WITH $00     JSR     XX0079          ; SCAN MEMORY     JSR     XXDCF3          ; GET FAC1 FROM STRING     PLA                    ; RESTORE STRING END BYTE     LDY     #$00               ; CLEAR INDEX     STA     (XX24),Y          ; PUT STRING END BYTE BACK; RESTORE BASIC EXECUTE POINTER FROM TEMPXXD7E2 = *     LDX     XX71          ; GET BASIC EXECUTE POINTER LOW BYTE BACK     LDY     XX72          ; GET BASIC EXECUTE POINTER HIGH BYTE BACK     STX     XX7A          ; SAVE BASIC EXECUTE POINTER LOW BYTE     STY     XX7B          ; SAVE BASIC EXECUTE POINTER HIGH BYTE     RTS;***********************************************************************************;;; GET PARAMETERS FOR POKE/WAITXXD7EB = *     JSR     XXCD8A          ; EVALUATE EXPRESSION AND CHECK IS NUMERIC, ELSE DO                         ; TYPE MISMATCH     JSR     XXD7F7          ; CONVERT FAC_1 TO INTEGER IN TEMPORARY INTEGERXXD7F1 = *     JSR     XXCEFD          ; SCAN FOR ',', ELSE DO SYNTAX ERROR THEN WARM START     JMP     XXD79E          ; GET BYTE PARAMETER AND RETURN;***********************************************************************************;;; CONVERT FAC_1 TO INTEGER IN TEMPORARY INTEGERXXD7F7 = *     LDA     XX66          ; GET FAC1 SIGN     BMI     XXD798          ; IF -VE DO ILLEGAL QUANTITY ERROR THEN WARM START     LDA     XX61          ; GET FAC1 EXPONENT     CMP     #$91               ; COMPARE WITH EXPONENT = 2^16     BCS     XXD798          ; IF >= DO ILLEGAL QUANTITY ERROR THEN WARM START     JSR     XXDC9B          ; CONVERT FAC1 FLOATING TO FIXED     LDA     XX64          ; GET FAC1 MANTISSA 3     LDY     XX65          ; GET FAC1 MANTISSA 4     STY     XX14          ; SAVE TEMPORARY INTEGER LOW BYTE     STA     XX15          ; SAVE TEMPORARY INTEGER HIGH BYTE     RTS;***********************************************************************************;;; PERFORM PEEK()XXD80D = *     LDA     XX15          ; GET LINE NUMBER HIGH BYTE     PHA                    ; SAVE LINE NUMBER HIGH BYTE     LDA     XX14          ; GET LINE NUMBER LOW BYTE     PHA                    ; SAVE LI NE NUMBER LOW BYTE     JSR     XXD7F7          ; CONVERT FAC_1 TO INTEGER IN TEMPORARY INTEGER     LDY     #$00               ; CLEAR INDEX     LDA     (XX14),Y          ; READ BYTE     TAY                    ; COPY BYTE TO A     PLA                !    ; PULL BYTE     STA     XX14          ; RESTORE LINE NUMBER LOW BYTE     PLA                    ; PULL BYTE     STA     XX15          ; RESTORE LINE NUMBER HIGH BYTE     JMP     XXD3A2          ; CONVERT Y TO BYTE IN FAC_1 AND RETURN;*********"**************************************************************************;;; PERFORM POKEXXD824 = *     JSR     XXD7EB          ; GET PARAMETERS FOR POKE/WAIT     TXA                    ; COPY BYTE TO A     LDY     #$00               ; CLEAR INDE#X     STA     (XX14),Y          ; WRITE BYTE     RTS;***********************************************************************************;;; PERFORM WAITXXD82D = *     JSR     XXD7EB          ; GET PARAMETERS FOR POKE/WAIT     STX     XX49     $     ; SAVE BYTE     LDX     #$00               ; CLEAR MASK     JSR     XX0079          ; SCAN MEMORY     BEQ     XXD83C          ; SKIP IF NO THIRD ARGUMENT     JSR     XXD7F1          ; SCAN FOR ',' AND GET BYTE, ELSE SYNTAX ERROR THEN          %               ; WARM STARTXXD83C = *     STX     XX4A          ; SAVE EOR ARGUMENT     LDY     #$00               ; CLEAR INDEXXXD840 = *     LDA     (XX14),Y          ; GET BYTE VIA TEMPORARY INTEGER     (ADDRESS)     EOR     XX4A          ; EOR &WITH SECOND ARGUMENT          (MASK)     AND     XX49          ; AND WITH FIRST ARGUMENT          (BYTE)     BEQ     XXD840          ; LOOP IF RESULT IS ZEROXXD848 = *     RTS;**********************************************************************'*************;;; ADD 0.5 TO FAC1 (ROUND FAC1)XXD849 = *     LDA     #<XXDF11          ; SET 0.5 POINTER LOW BYTE     LDY     #>XXDF11          ; SET 0.5 POINTER HIGH BYTE     JMP     XXD867          ; ADD (AY) TO FAC1;************************** *********************************************************;;; PERFORM SUBTRACTION, FAC1 FROM (AY)XXD850 = *     JSR     XXDA8C          ; UNPACK MEMORY (AY) INTO FAC2; PERFORM SUBTRACTION, FAC1 FROM FAC2XXD853 = *     LDA     XX66          ; GET5D          ; IF NO OVERFLOW CONTINUE     LDX     #$17               ; ELSE ERROR $17, STRING TOO LONG ERROR     JMP     XXC437          ; DO ERROR #X THEN WARM STARTXXD65D = *     JSR     XXD475          ; COPY DESCRIPTOR POINTER AND MAKE STRING SPACE A BYTES LONG     JSR     XXD67A          ; COPY STRING FROM DESCRIPTOR TO UTILITY POINTER     LDA     XX50          ; GET DESCRIPTOR POINTER LOW BYTE     LDY     XX51          ; GET DESCRIPTOR POINTER HIGH BYTE     JSR     XXD6AA          ; POP (YA) DESCRIPTOR OFF STACK OR FROM TOP OF STRING SPACE                         ; RETURNS WITH A = LENGTH, X = POINTER LOW BYTE,                         ; Y = POINTER HIGH BYTE     JSR     XXD68C          ; STORE STRING FROM POINTER TO UTILITY POINTER     LDA     XX6F          ; GET DESCRIPTOR POINTER LOW BYTE     LDY     XX70          ; GET DESCRIPTOR POINTER HIGH BYTE     JSR     XXD6AA          ; POP (YA) DESCRIPTOR OFF STACK OR FROM TOP OF STRING SPACE                         ; RETURNS WITH A = LENGTH, X = POINTER LOW BYTE,                         ; Y = POINTER HIGH BYTE     JSR     XXD4CA          ; CHECK SPACE ON DESCRIPTOR STACK THEN PUT STRING ADDRESS                         ; AND LENGTH ON DESCRIPTOR STACK AND UPDATE STACK POINTERS     JMP     XXCDB8          ; CONTINUE EVALUATION;***********************************************************************************;;; COPY STRING FROM DESCRIPTOR TO UTILITY POINTERXXD67A = *     LDY     #$00               ; CLEAR INDEX     LDA     (XX6F),Y          ; GET STRING LENGTH     PHA                    ; SAVE IT     INY                    ; INCREMENT INDEX     LDA     (XX6F),Y          ; GET STRING POINTER LOW BYTE     TAX                    ; COPY TO X     INY                    ; INCREMENT INDEX     LDA     (XX6F),Y          ; GET STRING POINTER HIGH BYTE     TAY                    ; COPY TO Y     PLA                    ; GET LENGTH BACKXXD688 = *     STX     XX22          ; SAVE STRING POINTER LOW BYTE     STY     XX23 	         ; SAVE STRING POINTER HIGH BYTE;***********************************************************************************;;; STORE STRING FROM POINTER TO UTILITY POINTERXXD68C = *     TAY                    ; COPY LENGTH AS INDEX     BEQ     
XXD699          ; BRANCH IF NULL STRING     PHA                    ; SAVE LENGTHXXD690 = *     DEY                    ; DECREMENT LENGTH/INDEX     LDA     (XX22),Y          ; GET BYTE FROM STRING     STA     (XX35),Y          ; SAVE BYTE TO DESTINATION     TYA                    ; COPY LENGTH/INDEX     BNE     XXD690          ; LOOP IF NOT ALL DONE YET     PLA                    ; RESTORE LENGTHXXD699 = *     CLC                    ; CLEAR CARRY FOR ADD     ADC     XX35          ; ADD STRING UTILITY PTR LOW BYTE     STA     XX35          ; SAVE STRING UTILITY PTR LOW BYTE     BCC     XXD6A2          ; IF NO ROLLOVER SKIP THE HIGH BYTE INCREMENT     INC     XX36          ; INCREMENT STRING UTILITY PTR HIGH BYTEXXD6A2 = *     RTS;***********************************************************************************;;; EVALUATE STRINGXXD6A3 = *     JSR     XXCD8F          ; CHECK IF SOURCE IS STRING, ELSE DO TYPE MISMATCH; POP STRING OFF DESCRIPTOR STACK, OR FROM TOP OF STRING SPACE; RETURNS WITH A = LENGTH, X = POINTER LOW BYTE, Y = POINTER HIGH BYTEXXD6A6 = *     LDA     XX64          ; GET DESCRIPTOR POINTER LOW BYTE     LDY     XX65          ; GET DESCRIPTOR POINTER HIGH BYTE; POP (YA) DESCRIPTOR OFF STACK OR FROM TOP OF STRING SPACE; RETURNS WITH A = LENGTH, X = POINTER LOW BYTE, Y = POINTER HIGH BYTEXXD6AA = *     STA     XX22          ; SAVE STRING POINTER LOW BYTE     STY     XX23          ; SAVE STRING POINTER HIGH BYTE     JSR     XXD6DB          ; CLEAN DESCRIPTOR STACK, YA = POINTER     PHP                    ; SAVE STATUS FLAGS     LDY     #$00               ; CLEAR INDEX     LDA     (XX22),Y          ; GET LENGTH FROM STRING DESCRIPTOR     PHA                    ; PUT ON STACK     INY                    ; INCREMENT INDEX     LDA     (XX22),Y          ; GET STRING POINTER LOW BYTE FROM DESCRIPTOR     TAX                    ; COPY TO X     INY                    ; INCREMENT INDEX     LDA     (XX22),Y          ; GET STRING POINTER HIGH BYTE FROM DESCRIPTOR     TAY                    ; COPY TO Y     PLA                    ; GET STRING LENGTH BACK     PLP                    ; RESTORE STATUS     BNE     XXD6D6          ; BRANCH IF POINTER <> LAST_SL,LAST_SH     CPY     XX34          ; COMPARE WITH BOTTOM OF STRING SPACE HIGH BYTE     BNE     XXD6D6          ; BRANCH IF <>     CPX     XX33          ; ELSE COMPARE WITH BOTTOM OF STRING SPACE LOW BYTE     BNE     XXD6D6          ; BRANCH IF <>     PHA                    ; SAVE STRING LENGTH     CLC                    ; CLEAR CARRY FOR ADD     ADC     XX33          ; ADD BOTTOM OF STRING SPACE LOW BYTE     STA     XX33          ; SET BOTTOM OF STRING SPACE LOW BYTE     BCC     XXD6D5          ; SKIP INCREMENT IF NO OVERFLOW     INC     XX34          ; INCREMENT BOTTOM OF STRING SPACE HIGH BYTEXXD6D5 = *     PLA                    ; RESTORE STRING LENGTHXXD6D6 = *     STX     XX22          ; SAVE STRING POINTER LOW BYTE     STY     XX23          ; SAVE STRING POINTER HIGH BYTE     RTS;***********************************************************************************;;; CLEAN DESCRIPTOR STACK, YA = POINTER; CHECKS IF AY IS ON THE DESCRIPTOR STACK, IF SO DOES A STACK DISCARDXXD6DB = *     CPY     XX18          ; COMPARE HIGH BYTE WITH CURRENT DESCRIPTOR STACK ITEM                         ; POINTER HIGH BYTE     BNE     XXD6EB          ; EXIT IF <>     CMP     XX17          ; COMPARE LOW BYTE WITH CURRENT DESCRIPTOR STACK ITEM                         ; POINTER LOW BYTE     BNE     XXD6EB          ; EXIT IF <>     STA     XX16          ; SET DESCRIPTOR STACK POINTER     SBC     #$03               ; UPDATE LAST STRING POINTER LOW BYTE     STA     XX17          ; SAVE CURRENT DESCRIPTOR STACK ITEM POINTER LOW BYTE     LDY     #$00               ; CLEAR HIGH BYTEXXD6EB = *     RTS;***********************************************************************************;;; PERFORM CHR$()XXD6EC = *     JSR     XXD7A1          ; EVALUATE BYTE EXPRESSION, RESULT IN X     TXA                    ; COPY TO A     PHA                    ; SAVE CHARACTER     LDA     #$01               ; STRING IS SINGLE BYTE     JSR     XXD47D          ; MAKE STRING SPACE A BYTES LONG     PLA                    ; GET CHARACTER BACK     LDY     #$00               ; CLEAR INDEX     STA     (XX62),Y          ; SAVE BYTE IN STRING - BYTE IS STRING!     PLA                    ; DUMP RETURN ADDRESS (SKIP TYPE CHECK)     PLA                    ; DUMP RETURN ADDRESS (SKIP TYPE CHECK)     JMP     XXD4CA          ; CHECK SPACE ON DESCRIPTOR STACK THEN PUT STRING ADDRESS                         ; AND LENGTH ON DESCRIPTOR STACK AND UPDATE STACK POINTERS;***********************************************************************************;;; PERFORM LEFT$()XXD700 = *     JSR     XXD761          ; PULL STRING DATA AND BYTE PARAMETER FROM STACK                         ; RETURN POINTER IN DESCRIPTOR, BYTE IN A (AND X), Y=0     CMP     (XX50),Y          ; COMPARE BYTE PARAMETER WITH STRING LENGTH     TYA                    ; CLEAR AXXD706 = *     BCC     XXD70C          ; BRANCH IF STRING LENGTH > BYTE PARAMETER     LDA     (XX50),Y          ; ELSE MAKE PARAMETER = LENGTH     TAX                    ; COPY TO BYTE PARAMETER COPY     TYA                    ; CLEAR STRING START OFFSETXXD70C = *     PHA                    ; SAVE STRING START OFFSETXXD70D = *     TXA                    ; COPY BYTE PARAMETER (OR STRING LENGTH IF <)XXD70E = *     PHA                     ; SAVE STRING LENGTH     JSR     XXD47D          ; MAKE STRING SPACE A BYTES LONG     LDA     XX50          ; GET DESCRIPTOR POINTER LOW BYTE     LDY     XX51          ; GET DESCRIPTOR POINTER HIGH BYTE     JSR     XXD6AA          ; POP (YA) DE!SCRIPTOR OFF STACK OR FROM TOP OF STRING SPACE                         ; RETURNS WITH A = LENGTH, X = POINTER LOW BYTE,                         ; Y = POINTER HIGH BYTE     PLA                    ; GET STRING LENGTH BACK     TAY                    ; C"OPY LENGTH TO Y     PLA                    ; GET STRING START OFFSET BACK     CLC                    ; CLEAR CARRY FOR ADD     ADC     XX22          ; ADD START OFFSET TO STRING START POINTER LOW BYTE     STA     XX22          ; SAVE STRING START POI#NTER LOW BYTE     BCC     XXD725          ; IF NO OVERFLOW SKIP THE HIGH BYTE INCREMENT     INC     XX23          ; ELSE INCREMENT STRING START POINTER HIGH BYTEXXD725 = *     TYA                    ; COPY LENGTH TO A     JSR     XXD68C          ; $STORE STRING FROM POINTER TO UTILITY POINTER     JMP     XXD4CA          ; CHECK SPACE ON DESCRIPTOR STACK THEN PUT STRING ADDRESS                         ; AND LENGTH ON DESCRIPTOR STACK AND UPDATE STACK POINTERS;***********************************%************************************************;;; PERFORM RIGHT$()XXD72C = *     JSR     XXD761          ; PULL STRING DATA AND BYTE PARAMETER FROM STACK                         ; RETURN POINTER IN DESCRIPTOR, BYTE IN A (AND X), Y=0     CLC     &               ; CLEAR CARRY FOR ADD-1     SBC     (XX50),Y          ; SUBTRACT STRING LENGTH     EOR     #$FF               ; INVERT IT (A=LEN(EXPRESSION$)-L)     JMP     XXD706          ; GO DO REST OF LEFT$();************************************'***********************************************;;; PERFORM MID$()XXD737 = *     LDA     #$FF               ; SET DEFAULT LENGTH = 255     STA     XX65          ; SAVE DEFAULT LENGTH     JSR     XX0079          ; SCAN MEMORY     CMP     #$29                ; COMPARE WITH ')'     BEQ     XXD748          ; BRANCH IF = ')' (SKIP SECOND BYTE GET)     JSR     XXCEFD          ; SCAN FOR ',', ELSE DO SYNTAX ERROR THEN WARM START     JSR     XXD79E          ; GET BYTE PARAMETER XXD748 = *     JSR       ; SAVE AS POINTER LOW BYTE     STX     XX23          ; SAVE AS POINTER HIGH BYTEXXD559 = *     CPX     XX30          ; COMPARE END OF VARIABLES HIGH BYTE,                         ; START OF ARRAYS HIGH BYTE     BNE     XXD561          ; BRANCH IF NO HIGH BYTE MATCH     CMP     XX2F          ; ELSE COMPARE END OF VARIABLES LOW BYTE,                         ; START OF ARRAYS LOW BYTE     BEQ     XXD566          ; BRANCH IF = VARIABLE MEMORY ENDXXD561 = *     JSR     XXD5BD          ; CHECK VARIABLE SALVAGEABILITY     BEQ     XXD559          ; LOOP ALWAYS                         ; DONE STRING VARIABLES, NOW DO STRING ARRAYSXXD566 = *     STA     XX58          ; SAVE START OF ARRAYS LOW BYTE AS WORKING POINTER     STX     XX59          ; SAVE START OF ARRAYS HIGH BYTE AS WORKING POINTER     LDA     #$03               ; SET STEP SIZE, COLLECTING DESCRIPTORS     STA     XX53          ; SAVE STEP SIZEXXD56E = *     LDA     XX58          ; GET POINTER LOW BYTE     LDX     XX59          ; GET POINTER HIGH BYTEXXD572 = *     CPX     XX32          ; COMPARE WITH END OF ARRAYS HIGH BYTE     BNE     XXD57D          ; BRANCH IF NOT AT END     CMP     XX31          ; ELSE COMPARE WITH END OF ARRAYS LOW BYTE     BNE     XXD57D          ; BRANCH IF NOT AT END     JMP     XXD606          ; COLLECT STRING, TIDY UP AND EXIT IF AT END ??XXD57D = *     STA     XX22          ; SAVE POINTER LOW BYTE     STX     XX23          ; SAVE POINTER HIGH BYTE     LDY     #$00               ; SET INDEX     LDA     (XX22),Y          ; GET ARRAY NAME FIRST BYTE     TAX                    ; COPY IT     INY                    ; INCREMENT INDEX     LDA     (XX22),Y          ; GET ARRAY NAME SECOND BYTE     PHP                    ; PUSH THE FLAGS     INY                    ; INCREMENT INDEX     LDA     (XX22),Y          ; GET ARRAY SIZE LOW BYTE     ADC     XX58          ; ADD START OF THIS ARRAY LOW BYTE     STA     XX58          ; SAVE START OF NEXT ARRAY LOW BYTE     INY               	     ; INCREMENT INDEX     LDA     (XX22),Y          ; GET ARRAY SIZE HIGH BYTE     ADC     XX59          ; ADD START OF THIS ARRAY HIGH BYTE     STA     XX59          ; SAVE START OF NEXT ARRAY HIGH BYTE     PLP                    ; RESTORE THE FLAG
S     BPL     XXD56E          ; SKIP IF NOT STRING ARRAY; WAS POSSIBLY STRING ARRAY SO ...     TXA                    ; GET NAME FIRST BYTE BACK     BMI     XXD56E          ; SKIP IF NOT STRING ARRAY     INY                    ; INCREMENT INDEX     LDA     (XX22),Y          ; GET # OF DIMENSIONS     LDY     #$00               ; CLEAR INDEX     ASL A                  ; *2     ADC     #$05               ; +5 (ARRAY HEADER SIZE)     ADC     XX22          ; ADD POINTER LOW BYTE     STA     XX22          ; SAVE POINTER LOW BYTE     BCC     XXD5AE          ; IF NO ROLLOVER SKIP THE HIGH BYTE INCREMENT     INC     XX23          ; ELSE INCREMENT POINTER HGIH BYTEXXD5AE = *     LDX     XX23          ; GET POINTER HIGH BYTEXXD5B0 = *     CPX     XX59          ; COMPARE POINTER HIGH BYTE WITH END OF THIS ARRAY HIGH BYTE     BNE     XXD5B8          ; BRANCH IF NOT THERE YET     CMP     XX58          ; COMPARE POINTER LOW BYTE WITH END OF THIS ARRAY LOW BYTE     BEQ     XXD572          ; IF AT END OF THIS ARRAY GO CHECK NEXT ARRAYXXD5B8 = *     JSR     XXD5C7          ; CHECK STRING SALVAGEABILITY     BEQ     XXD5B0          ; LOOP; CHECK VARIABLE SALVAGEABILITYXXD5BD = *     LDA     (XX22),Y          ; GET VARIABLE NAME FIRST BYTE     BMI     XXD5F6          ; ADD STEP AND EXIT IF NOT STRING     INY                    ; INCREMENT INDEX     LDA     (XX22),Y          ; GET VARIABLE NAME SECOND BYTE     BPL     XXD5F6          ; ADD STEP AND EXIT IF NOT STRING     INY                    ; INCREMENT INDEX; CHECK STRING SALVAGEABILITYXXD5C7 = *     LDA     (XX22),Y          ; GET STRING LENGTH     BEQ     XXD5F6          ; ADD STEP AND EXIT IF NULL STRING     INY                    ; INCREMENT INDEX     LDA     (XX22),Y          ; GET STRING POINTER LOW BYTE     TAX                    ; COPY TO X     INY                    ; INCREMENT INDEX     LDA     (XX22),Y          ; GET STRING POINTER HIGH BYTE     CMP     XX34          ; COMPARE STRING POINTER HIGH BYTE WITH BOTTOM OF STRING                         ; SPACE HIGH BYTE     BCC     XXD5DC          ; IF BOTTOM OF STRING SPACE GREATER GO TEST AGAINST HIGHEST                         ; UNCOLLECTED STRING     BNE     XXD5F6          ; IF BOTTOM OF STRING SPACE LESS STRING HAS BEEN COLLECTED                         ; SO GO UPDATE POINTERS, STEP TO NEXT AND RETURN                         ; HIGH BYTES WERE EQUAL SO TEST LOW BYTES     CPX     XX33          ; COMPARE STRING POINTER LOW BYTE WITH BOTTOM OF STRING                         ; SPACE LOW BYTE     BCS     XXD5F6          ; IF BOTTOM OF STRING SPACE LESS STRING HAS BEEN COLLECTED                         ; SO GO UPDATE POINTERS, STEP TO NEXT AND RETURN                         ; ELSE TEST STRING AGAINST HIGHEST UNCOLLECTED STRING SO FARXXD5DC = *     CMP     XX60          ; COMPARE STRING POINTER HIGH BYTE WITH HIGHEST UNCOLLECTED                         ; STRING HIGH BYTE     BCC     XXD5F6          ; IF HIGHEST UNCOLLECTED STRING IS GREATER THEN GO UPDATE                         ; POINTERS, STEP TO NEXT AND RETURN     BNE     XXD5E6          ; IF HIGHEST UNCOLLECTED STRING IS LESS THEN GO SET THIS                         ; STRING AS HIGHEST UNCOLLECTED SO FAR                         ; HIGH BYTES WERE EQUAL SO TEST LOW BYTES     CPX     XX5F          ; COMPARE STRING POINTER LOW BYTE WITH HIGHEST UNCOLLECTED                         ; STRING LOW BYTE     BCC     XXD5F6          ; IF HIGHEST UNCOLLECTED STRING IS GREATER THEN GO UPDATE                         ; POINTERS, STEP TO NEXT AND RETURN                         ; ELSE SET CURRENT STRING AS HIGHEST UNCOLLECTED STRINGXXD5E6 = *     STX     XX5F          ; SAVE STRING POINTER LOW BYTE AS HIGHEST UNCOLLECTED STRING                         ; LOW BYTE     STA     XX60          ; SAVE STRING POINTER HIGH BYTE AS HIGHEST UNCOLLECTED                         ; STRING HIGH BYTE     LDA     XX22          ; GET DESCRIPTOR POINTER LOW BYTE     LDX     XX23          ; GET DESCRIPTOR POINTER HIGH BYTE     STA     XX4E          ; SAVE WORKING POINTER HIGH BYTE     STX     XX4F          ; SAVE WORKING POINTER LOW BYTE     LDA     XX53          ; GET STEP SIZE     STA     XX55          ; COPY STEP SIZEXXD5F6 = *     LDA     XX53          ; GET STEP SIZE     CLC                    ; CLEAR CARRY FOR ADD     ADC     XX22          ; ADD POINTER LOW BYTE     STA     XX22          ; SAVE POINTER LOW BYTE     BCC     XXD601          ; IF NO ROLLOVER SKIP THE HIGH BYTE INCREMENT     INC     XX23          ; ELSE INCREMENT POINTER HIGH BYTEXXD601 = *     LDX     XX23          ; GET POINTER HIGH BYTE     LDY     #$00               ; FLAG NOT MOVED     RTS;***********************************************************************************;;; COLLECT STRINGXXD606 = *     LDA     XX4F          ; GET WORKING POINTER LOW BYTE     ORA     XX4E          ; OR WORKING POINTER HIGH BYTE     BEQ     XXD601          ; EXIT IF NOTHING TO COLLECT     LDA     XX55          ; GET COPIED STEP SIZE     AND     #$04               ; MASK STEP SIZE, $04 FOR VARIABLES, $00 FOR ARRAY OR STACK     LSR A                  ; >> 1     TAY                    ; COPY TO INDEX     STA     XX55          ; SAVE OFFSET TO DESCRIPTOR START     LDA     (XX4E),Y          ; GET STRING LENGTH LOW BYTE     ADC     XX5F          ; ADD STRING START LOW BYTE     STA     XX5A          ; SET BLOCK END LOW BYTE     LDA     XX60          ; GET STRING START HIGH BYTE     ADC     #$00                ; ADD CARRY     STA     XX5B          ; SET BLOCK END HIGH BYTE     LDA     XX33          ; GET BOTTOM OF STRING SPACE LOW BYTE     LDX     XX34          ; GET BOTTOM OF STRING SPACE HIGH BYTE     STA     XX58          ; SAVE DESTINATION END LOW BYT!E     STX     XX59          ; SAVE DESTINATION END HIGH BYTE     JSR     XXC3BF          ; OPEN UP SPACE IN MEMORY, DON'T SET ARRAY END. THIS                         ; COPIES THE STRING FROM WHERE IT IS TO THE END OF THE                         ; UNC"OLLECTED STRING MEMORY     LDY     XX55          ; RESTORE OFFSET TO DESCRIPTOR START     INY                    ; INCREMENT INDEX TO STRING POINTER LOW BYTE     LDA     XX58          ; GET NEW STRING POINTER LOW BYTE     STA     (XX4E),Y          ; #SAVE NEW STRING POINTER LOW BYTE     TAX                    ; COPY STRING POINTER LOW BYTE     INC     XX59          ; INCREMENT NEW STRING POINTER HIGH BYTE     LDA     XX59          ; GET NEW STRING POINTER HIGH BYTE     INY                    ; IN$CREMENT INDEX TO STRING POINTER HIGH BYTE     STA     (XX4E),Y          ; SAVE NEW STRING POINTER HIGH BYTE     JMP     XXD52A          ; RE-RUN ROUTINE FROM LAST ENDING, XA HOLDS NEW BOTTOM                         ; OF STRING MEMORY POINTER;******%*****************************************************************************;;; CONCATENATE; ADD STRINGS, THE FIRST STRING IS IN THE DESCRIPTOR, THE SECOND STRING IS IN LINEXXD63D = *     LDA     XX65          ; GET DESCRIPTOR POINTER HIGH BYTE  &   PHA                    ; PUT ON STACK     LDA     XX64          ; GET DESCRIPTOR POINTER LOW BYTE     PHA                    ; PUT ON STACK     JSR     XXCE83          ; GET VALUE FROM LINE     JSR     XXCD8F          ; CHECK IF SOURCE IS STRING, 'ELSE DO TYPE MISMATCH     PLA                    ; GET DESCRIPTOR POINTER LOW BYTE BACK     STA     XX6F          ; SET POINTER LOW BYTE     PLA                    ; GET DESCRIPTOR POINTER HIGH BYTE BACK     STA     XX70          ; SET POINTER HIGH B YTE     LDY     #$00               ; CLEAR INDEX     LDA     (XX6F),Y          ; GET LENGTH OF FIRST STRING FROM DESCRIPTOR     CLC                    ; CLEAR CARRY FOR ADD     ADC     (XX64),Y          ; ADD LENGTH OF SECOND STRING     BCC     XXD6EXECUTE POINTER HIGH BYTE     STA     XX7B          ; SAVE BASIC EXECUTE POINTER HIGH BYTE; PUT EXECUTE POINTER AND VARIABLE POINTER INTO FUNCTIONXXD44F = *     LDY     #$00               ; CLEAR INDEX     PLA                    ; PULL BASIC EXECUTE POINTER LOW BYTE     STA     (XX4E),Y          ; SAVE TO FUNCTION     PLA                    ; PULL BASIC EXECUTE POINTER HIGH BYTE     INY                    ; INCREMENT INDEX     STA     (XX4E),Y          ; SAVE TO FUNCTION     PLA                    ; PULL CURRENT VARIABLE ADDRESS LOW BYTE     INY                    ; INCREMENT INDEX     STA     (XX4E),Y          ; SAVE TO FUNCTION     PLA                    ; PULL CURRENT VARIABLE ADDRESS HIGH BYTE     INY                    ; INCREMENT INDEX     STA     (XX4E),Y          ; SAVE TO FUNCTION     PLA                    ; PULL ??     INY                    ; INCREMENT INDEX     STA     (XX4E),Y          ; SAVE TO FUNCTION     RTS;***********************************************************************************;;; PERFORM STR$()XXD465 = *     JSR     XXCD8D          ; CHECK IF SOURCE IS NUMERIC, ELSE DO TYPE MISMATCH     LDY     #$00               ; SET STRING INDEX     JSR     XXDDDF          ; CONVERT FAC1 TO STRING     PLA                    ; DUMP RETURN ADDRESS (SKIP TYPE CHECK)     PLA                    ; DUMP RETURN ADDRESS (SKIP TYPE CHECK)XXD46F = *     LDA     #<XX00FF          ; SET RESULT STRING LOW POINTER     LDY     #>XX00FF          ; SET RESULT STRING HIGH POINTER     BEQ     XXD487          ; PRINT NULL TERMINATED STRING TO UTILITY POINTER;***********************************************************************************;;; DO STRING VECTOR; COPY DESCRIPTOR POINTER AND MAKE STRING SPACE A BYTES LONGXXD475 = *     LDX     XX64          ; GET DESCRIPTOR POINTER LOW BYTE     LDY     XX65          ; GET DESCRIPTOR POINTER HIGH BYTE     STX     XX50          ; SAVE DESCRIPTOR POINTER LOW BYTE     STY     XX51          ; SAVE DESCRIPTOR P	OINTER HIGH BYTE;***********************************************************************************;;; MAKE STRING SPACE A BYTES LONGXXD47D = *     JSR     XXD4F4          ; MAKE SPACE IN STRING MEMORY FOR STRING A LONG     STX     XX62        
  ; SAVE STRING POINTER LOW BYTE     STY     XX63          ; SAVE STRING POINTER HIGH BYTE     STA     XX61          ; SAVE LENGTH     RTS;***********************************************************************************;;; SCAN, SET UP STRING; PRINT ' TERMINATED STRING TO UTILITY POINTERXXD487 = *     LDX     #$22               ; SET TERMINATOR TO '     STX     XX07          ; SET SEARCH CHARACTER, TERMINATOR 1     STX     XX08          ; SET TERMINATOR 2; PRINT SEARCH OR ALTERNATE TERMINATED STRING TO UTILITY POINTER; SOURCE IS AYXXD48D = *     STA     XX6F          ; STORE STRING START LOW BYTE     STY     XX70          ; STORE STRING START HIGH BYTE     STA     XX62          ; SAVE STRING POINTER LOW BYTE     STY     XX63          ; SAVE STRING POINTER HIGH BYTE     LDY     #$FF               ; SET LENGTH TO -1XXD497 = *     INY                    ; INCREMENT LENGTH     LDA     (XX6F),Y          ; GET BYTE FROM STRING     BEQ     XXD4A8          ; EXIT LOOP IF NULL BYTE [EOS]     CMP     XX07          ; COMPARE WITH SEARCH CHARACTER, TERMINATOR 1     BEQ     XXD4A4          ; BRANCH IF TERMINATOR     CMP     XX08          ; COMPARE WITH TERMINATOR 2     BNE     XXD497          ; LOOP IF NOT TERMINATOR 2XXD4A4 = *     CMP     #$22               ; COMPARE WITH '     BEQ     XXD4A9          ; BRANCH IF ' (CARRY SET IF = !)XXD4A8 = *     CLC                    ; CLEAR CARRY FOR ADD (ONLY IF [EOL] TERMINATED STRING)XXD4A9 = *     STY     XX61          ; SAVE LENGTH IN FAC1 EXPONENT     TYA                    ; COPY LENGTH TO A     ADC     XX6F          ; ADD STRING START LOW BYTE     STA     XX71          ; SAVE STRING END LOW BYTE     LDX     XX70          ; GET STRING START HIGH BYTE     BCC     XXD4B5          ; IF NO LOW BYTE OVERFLOW SKIP THE HIGH BYTE INCREMENT     INX                    ; ELSE INCREMENT HIGH BYTEXXD4B5 = *     STX     XX72          ; SAVE STRING END HIGH BYTE     LDA     XX70          ; GET STRING START HIGH BYTE     BEQ     XXD4BF          ; BRANCH IF IN UTILITY AREA     CMP     #$02               ; COMPARE WITH INPUT BUFFER MEMORY HIGH BYTE     BNE     XXD4CA          ; BRANCH IF NOT IN INPUT BUFFER MEMORY                         ; STRING IN INPUT BUFFER OR UTILITY AREA, MOVE TO STRING                         ; MEMORYXXD4BF = *     TYA                    ; COPY LENGTH TO A     JSR     XXD475          ; COPY DESCRIPTOR POINTER AND MAKE STRING SPACE A BYTES LONG     LDX     XX6F          ; GET STRING START LOW BYTE     LDY     XX70          ; GET STRING START HIGH BYTE     JSR     XXD688          ; STORE STRING A BYTES LONG FROM XY TO UTILITY POINTER; CHECK FOR SPACE ON DESCRIPTOR STACK THEN ...; PUT STRING ADDRESS AND LENGTH ON DESCRIPTOR STACK AND UPDATE STACK POINTERSXXD4CA = *     LDX     XX16          ; GET DESCRIPTOR STACK POINTER     CPX     #$22               ; COMPARE WITH MAX+1     BNE     XXD4D5          ; BRANCH IF SPACE ON STRING STACK                         ; ELSE DO STRING TOO COMPLEX ERROR     LDX     #$19               ; ERROR $19, STRING TOO COMPLEX ERRORXXD4D2 = *     JMP     XXC437          ; DO ERROR #X THEN WARM START; PUT STRING ADDRESS AND LENGTH ON DESCRIPTOR STACK AND UPDATE STACK POINTERSXXD4D5 = *     LDA     XX61          ; GET STRING LENGTH     STA     XX00,X          ; PUT ON STRING STACK     LDA     XX62          ; GET STRING POINTER LOW BYTE     STA     XX01,X          ; PUT ON STRING STACK     LDA     XX63          ; GET STRING POINTER HIGH BYTE     STA     XX02,X          ; PUT ON STRING STACK     LDY     #$00               ; CLEAR Y     STX     XX64          ; SAVE STRING DESCRIPTOR POINTER LOW BYTE     STY     XX65          ; SAVE STRING DESCRIPTOR POINTER HIGH BYTE, ALWAYS $00     STY     XX70          ; CLEAR FAC1 ROUNDING BYTE     DEY                    ; Y = $FF     STY     XX0D          ; SAVE DATA TYPE FLAG, $FF = STRING     STX     XX17          ; SAVE CURRENT DESCRIPTOR STACK ITEM POINTER LOW BYTE     INX                    ; UPDATE STACK POINTER     INX                    ; UPDATE STACK POINTER     INX                    ; UPDATE STACK POINTER     STX     XX16          ; SET NEW DESCRIPTOR STACK POINTER     RTS; MAKE SPACE IN STRING MEMORY FOR STRING A LONG; RETURN X = POINTER LOW BYTE, Y = POINTER HIGH BYTEXXD4F4 = *     LSR     XX0F          ; CLEAR GARBAGE COLLECTED FLAG (B7)                         ; MAKE SPACE FOR STRING A LONGXXD4F6 = *     PHA                    ; SAVE STRING LENGTH     EOR     #$FF               ; COMPLEMENT IT     SEC                    ; SET CARRY FOR SUBTRACT, TWO'S COMPLEMENT ADD     ADC     XX33          ; ADD BOTTOM OF STRING SPACE LOW BYTE, SUBTRACT LENGTH     LDY     XX34          ; GET BOTTOM OF STRING SPACE HIGH BYTE     BCS     XXD501          ; SKIP DECREMENT IF NO UNDERFLOW     DEY                    ; DECREMENT BOTTOM OF STRING SPACE HIGH BYTEXXD501 = *     CPY     XX32          ; COMPARE WITH END OF ARRAYS HIGH BYTE     BCC     XXD516          ; DO OUT OF MEMORY ERROR IF LESS     BNE     XXD50B          ; IF NOT = SKIP NEXT TEST     CMP     XX31          ; COMPARE WITH END OF ARRAYS LOW BYTE     BCC     XXD516          ; DO OUT OF MEMORY ERROR IF LESSXXD50B = *     STA     XX33          ; SAVE BOTTOM OF STRING SPACE LOW BYTE     STY     XX34          ; SAVE BOTTOM OF STRING SPACE HIGH BYTE     STA     XX35          ; SAVE STRING UTILITY PTR LOW BYTE     STY     XX36          ; SAVE STRING UTILITY PTR HIGH BYTE     TAX                    ; COPY  LOW BYTE TO X     PLA                    ; GET STRING LENGTH BACK     RTSXXD516 = *     LDX     #$10               ; ERROR CODE $10, OUT OF MEMORY ERROR     LDA     XX0F          ; GET GARBAGE COLLECTED FLAG     BMI     XXD4D2          ; IF SET T!HEN DO ERROR CODE X     JSR     XXD526          ; ELSE GO DO GARBAGE COLLECTION     LDA     #$80               ; FLAG FOR GARBAGE COLLECTED     STA     XX0F          ; SET GARBAGE COLLECTED FLAG     PLA                    ; PULL LENGTH     BNE     "XXD4F6          ; GO TRY AGAIN (LOOP ALWAYS, LENGTH SHOULD NEVER BE = $00);***********************************************************************************;;; GARBAGE COLLECTION ROUTINEXXD526 = *     LDX     XX37          ; GET END OF MEMORY L#OW BYTE     LDA     XX38          ; GET END OF MEMORY HIGH BYTE; RE-RUN ROUTINE FROM LAST ENDINGXXD52A = *     STX     XX33          ; SET BOTTOM OF STRING SPACE LOW BYTE     STA     XX34          ; SET BOTTOM OF STRING SPACE HIGH BYTE     LDY   $  #$00               ; CLEAR INDEX     STY     XX4F          ; CLEAR WORKING POINTER HIGH BYTE     STY     XX4E          ; CLEAR WORKING POINTER LOW BYTE     LDA     XX31          ; GET END OF ARRAYS LOW BYTE     LDX     XX32          ; GET END OF AR%RAYS HIGH BYTE     STA     XX5F          ; SAVE AS HIGHEST UNCOLLECTED STRING POINTER LOW BYTE     STX     XX60          ; SAVE AS HIGHEST UNCOLLECTED STRING POINTER HIGH BYTE     LDA     #XX19          ; SET DESCRIPTOR STACK POINTER     LDX     #$00&               ; CLEAR X     STA     XX22          ; SAVE DESCRIPTOR STACK POINTER LOW BYTE     STX     XX23          ; SAVE DESCRIPTOR STACK POINTER HIGH BYTE ($00)XXD544 = *     CMP     XX16          ; COMPARE WITH DESCRIPTOR STACK POINTER     BEQ'     XXD54D          ; BRANCH IF =     JSR     XXD5C7          ; CHECK STRING SALVAGEABILITY     BEQ     XXD544          ; LOOP ALWAYS                         ; DONE STACKED STRINGS, NOW DO STRING VARIABLESXXD54D = *     LDA     #$07                ; SET STEP SIZE = $07, COLLECTING VARIABLES     STA     XX53          ; SAVE GARBAGE COLLECTION STEP SIZE     LDA     XX2D          ; GET START OF VARIABLES LOW BYTE     LDX     XX2E          ; GET START OF VARIABLES HIGH BYTE     STA     XX22           ; COMPUTE ARRAY SIZE     TXA                    ; COPY ARRAY SIZE LOW BYTE     ADC     XX58          ; ADD ARRAY DATA START POINTER LOW BYTE     STA     XX47          ; SAVE AS CURRENT VARIABLE POINTER LOW BYTE     TYA                    ; COPY ARRAY SIZE HIGH BYTE     ADC     XX59          ; ADD ARRAY DATA START POINTER HIGH BYTE     STA     XX48          ; SAVE AS CURRENT VARIABLE POINTER HIGH BYTE     TAY                    ; COPY HIGH BYTE TO Y     LDA     XX47          ; GET CURRENT VARIABLE POINTER LOW BYTE                         ; POINTER TO ELEMENT IS NOW IN AYXXD34B = *     RTS;***********************************************************************************;;; COMPUTE ARRAY SIZE, RESULT IN XYXXD34C = *     STY     XX22          ; SAVE INDEX     LDA     (XX5F),Y          ; GET DIMENSION SIZE LOW BYTE     STA     XX28          ; SAVE DIMENSION SIZE LOW BYTE     DEY                    ; DECREMENT INDEX     LDA     (XX5F),Y          ; GET DIMENSION SIZE HIGH BYTEXXD355 = *     STA     XX29          ; SAVE DIMENSION SIZE HIGH BYTE     LDA     #$10               ; COUNT = $10 (16 BIT MULTIPLY)     STA     XX5D          ; SAVE BIT COUNT     LDX     #$00               ; CLEAR RESULT LOW BYTE     LDY     #$00               ; CLEAR RESULT HIGH BYTEXXD35F = *     TXA                    ; GET RESULT LOW BYTE     ASL A                  ; *2     TAX                    ; SAVE RESULT LOW BYTE     TYA                    ; GET RESULT HIGH BYTE     ROL A                  ; *2     TAY                    ; SAVE RESULT HIGH BYTE     BCS     XXD30B          ; IF OVERFLOW GO DO 'OUT OF MEMORY' ERROR     ASL     XX71          ; SHIFT ELEMENT SIZE LOW BYTE     ROL     XX72          ; SHIFT ELEMENT SIZE HIGH BYTE     BCC     XXD378          ; SKIP ADD IF NO CARRY     CLC                    ; ELSE CLEAR CARRY FOR ADD     TXA                    ; GET RESULT LOW BYTE     ADC     XX28          ; ADD DIMENSION SIZE LOW BYTE     TAX                    ; SAVE RESULT L	OW BYTE     TYA                    ; GET RESULT HIGH BYTE     ADC     XX29          ; ADD DIMENSION SIZE HIGH BYTE     TAY                    ; SAVE RESULT HIGH BYTE     BCS     XXD30B          ; IF OVERFLOW GO DO 'OUT OF MEMORY' ERRORXXD378 = *  
   DEC     XX5D          ; DECREMENT BIT COUNT     BNE     XXD35F          ; LOOP UNTIL ALL DONE     RTS;***********************************************************************************;;; PERFORM FRE()XXD37D = *     LDA     XX0D          ; GET DATA TYPE FLAG, $FF = STRING, $00 = NUMERIC     BEQ     XXD384          ; IF NUMERIC DON'T POP THE STRING     JSR     XXD6A6          ; POP STRING OFF DESCRIPTOR STACK, OR FROM TOP OF STRING                         ; SPACE RETURNS WITH A = LENGTH, X=$71=POINTER LOW BYTE,                         ; Y=$72=POINTER HIGH BYTE                         ; FRE(N) WAS NUMERIC SO DO THISXXD384 = *     JSR     XXD526          ; GO DO GARBAGE COLLECTION     SEC                    ; SET CARRY FOR SUBTRACT     LDA     XX33          ; GET BOTTOM OF STRING SPACE LOW BYTE     SBC     XX31          ; SUBTRACT END OF ARRAYS LOW BYTE     TAY                    ; COPY RESULT TO Y     LDA     XX34          ; GET BOTTOM OF STRING SPACE HIGH BYTE     SBC     XX32          ; SUBTRACT END OF ARRAYS HIGH BYTE;***********************************************************************************;;; CONVERT FIXED INTEGER AY TO FLOAT FAC1XXD391 = *     LDX     #$00               ; SET TYPE = NUMERIC     STX     XX0D          ; CLEAR DATA TYPE FLAG, $FF = STRING, $00 = NUMERIC     STA     XX62          ; SAVE FAC1 MANTISSA 1     STY     XX63          ; SAVE FAC1 MANTISSA 2     LDX     #$90               ; SET EXPONENT=2^16 (INTEGER)     JMP     XXDC44          ; SET EXP = X, CLEAR FAC1 3 AND 4, NORMALISE AND RETURN;***********************************************************************************;;; PERFORM POS()XXD39E = *     SEC                    ; SET CB FOR READ CURSOR POSITION     JSR     XXFFF0          ; READ/SET X,Y CURSOR POSITIONXXD3A2 = *     LDA     #$00               ; CLEAR HIGH BYTE     BEQ     XXD391          ; CONVERT FIXED INTEGER AY TO FLOAT FAC1, BRANCH ALWAYS;***********************************************************************************;;; CHECK NOT DIRECT, USED BY DEF AND INPUTXXD3A6 = *     LDX     XX3A          ; GET CURRENT LINE NUMBER HIGH BYTE     INX                    ; INCREMENT IT     BNE     XXD34B          ; RETURN IF NOT DIRECT MODE                         ; ELSE DO ILLEGAL DIRECT ERROR     LDX     #$15               ; ERROR $15, ILLEGAL DIRECT ERROR     .BYTE     $2C               ; MAKES NEXT LINE BIT XX1BA2XXD3AE = *     LDX     #$1B               ; ERROR $1B, UNDEFINED FUNCTION ERROR     JMP     XXC437          ; DO ERROR #X THEN WARM START;***********************************************************************************;;; PERFORM DEFXXD3B3 = *     JSR     XXD3E1          ; CHECK FNX SYNTAX     JSR     XXD3A6          ; CHECK NOT DIRECT, BACK HERE IF OK     JSR     XXCEFA          ; SCAN FOR '(', ELSE DO SYNTAX ERROR THEN WARM START     LDA     #$80               ; SET FLAG FOR FNX     STA     XX10          ; SAVE SUBSCRIPT/FNX FLAG     JSR     XXD08B          ; GET VARIABLE ADDRESS     JSR     XXCD8D          ; CHECK IF SOURCE IS NUMERIC, ELSE DO TYPE MISMATCH     JSR     XXCEF7          ; SCAN FOR ')', ELSE DO SYNTAX ERROR THEN WARM START     LDA     #TEQUAL          ; GET = TOKEN     JSR     XXCEFF          ; SCAN FOR CHR$(A), ELSE DO SYNTAX ERROR THEN WARM START     PHA                    ; PUSH NEXT CHARACTER     LDA     XX48          ; GET CURRENT VARIABLE POINTER HIGH BYTE     PHA                    ; PUSH IT     LDA     XX47          ; GET CURRENT VARIABLE POINTER LOW BYTE     PHA                    ; PUSH IT     LDA     XX7B          ; GET BASIC EXECUTE POINTER HIGH BYTE     PHA                    ; PUSH IT     LDA     XX7A          ; GET BASIC EXECUTE POINTER LOW BYTE     PHA                    ; PUSH IT     JSR     XXC8F8          ; PERFORM DATA     JMP     XXD44F          ; PUT EXECUTE POINTER AND VARIABLE POINTER INTO FUNCTION                         ; AND RETURN;***********************************************************************************;;; CHECK FNX SYNTAXXXD3E1 = *     LDA     #TFN          ; SET FN TOKEN     JSR     XXCEFF          ; SCAN FOR CHR$(A), ELSE DO SYNTAX ERROR THEN WARM START     ORA     #$80               ; SET FN FLAG BIT     STA     XX10          ; SAVE FN NAME     JSR     XXD092          ; SEARCH FOR FN VARIABLE     STA     XX4E          ; SAVE FUNCTION POINTER LOW BYTE     STY     XX4F          ; SAVE FUNCTION POINTER HIGH BYTE     JMP     XXCD8D          ; CHECK IF SOURCE IS NUMERIC AND RETURN, ELSE DO TYPE                         ; MISMATCH;***********************************************************************************;;; EVALUATE FNXXXD3F4 = *     JSR     XXD3E1          ; CHECK FNX SYNTAX     LDA     XX4F          ; GET FUNCTION POINTER HIGH BYTE     PHA                    ; PUSH IT     LDA     XX4E          ; GET FUNCTION POINTER LOW BYTE     PHA                    ; PUSH IT     JSR     XXCEF1          ; EVALUATE EXPRESSION WITHIN PARENTHESES     JSR     XXCD8D          ; CHECK IF SOURCE IS NUMERIC, ELSE DO TYPE MISMATCH     PLA                    ; POP FUNCTION POINTER LOW BYTE     STA     XX4E          ; RESTORE IT     PLA                    ; POP FUNCTION POINTER HIGH BYTE     STA     XX4F          ; RESTORE IT     LDY     #$02               ; INDEX TO VARIABLE POINTER HIGH BYTE     LDA     (XX4E),Y          ; GET VARIABLE ADDRESS LOW BYTE     STA     XX47          ; SAVE CURRENT VARIABLE POINTER LOW BYTE     TAX                    ; COPY ADDRES S LOW BYTE     INY                    ; INDEX TO VARIABLE ADDRESS HIGH BYTE     LDA     (XX4E),Y          ; GET VARIABLE POINTER HIGH BYTE     BEQ     XXD3AE          ; IF HIGH BYTE ZERO GO DO UNDEFINED FUNCTION ERROR     STA     XX48          ; SAV!E CURRENT VARIABLE POINTER HIGH BYTE     INY                    ; INDEX TO MANTISSA 3                         ; NOW STACK THE FUNCTION VARIABLE VALUE BEFORE USEXXD418 = *     LDA     (XX47),Y          ; GET BYTE FROM VARIABLE     PHA               "     ; STACK IT     DEY                    ; DECREMENT INDEX     BPL     XXD418          ; LOOP UNTIL VARIABLE STACKED     LDY     XX48          ; GET CURRENT VARIABLE POINTER HIGH BYTE     JSR     XXDBD4          ; PACK FAC1 INTO (XY)     LDA     #XX7B          ; GET BASIC EXECUTE POINTER HIGH BYTE     PHA                    ; PUSH IT     LDA     XX7A          ; GET BASIC EXECUTE POINTER LOW BYTE     PHA                    ; PUSH IT     LDA     (XX4E),Y          ; GET FUNCTION EXECUTE POINTER $LOW BYTE     STA     XX7A          ; SAVE BASIC EXECUTE POINTER LOW BYTE     INY                    ; INDEX TO HIGH BYTE     LDA     (XX4E),Y          ; GET FUNCTION EXECUTE POINTER HIGH BYTE     STA     XX7B          ; SAVE BASIC EXECUTE POINTER HIG%H BYTE     LDA     XX48          ; GET CURRENT VARIABLE POINTER HIGH BYTE     PHA                    ; PUSH IT     LDA     XX47          ; GET CURRENT VARIABLE POINTER LOW BYTE     PHA                    ; PUSH IT     JSR     XXCD8A          ; EVALU&ATE EXPRESSION AND CHECK IS NUMERIC, ELSE DO                         ; TYPE MISMATCH     PLA                    ; PULL VARIABLE ADDRESS LOW BYTE     STA     XX4E          ; SAVE VARIABLE ADDRESS LOW BYTE     PLA                    ; PULL VARIABLE ADD'RESS HIGH BYTE     STA     XX4F          ; SAVE VARIABLE ADDRESS HIGH BYTE     JSR     XX0079          ; SCAN MEMORY     BEQ     XXD449          ; IF NULL (SHOULD BE [EOL] MARKER) CONTINUE     JMP     XXCF08          ; ELSE SYNTAX ERROR THEN WARM ST ART; RESTORE BASIC EXECUTE POINTER AND FUNCTION VARIABLE FROM STACKXXD449 = *     PLA                    ; PULL BASIC EXECUTE POINTER LOW BYTE     STA     XX7A          ; SAVE BASIC EXECUTE POINTER LOW BYTE     PLA                    ; PULL BASIC ; COMPARE WITH THIS ARRAY NAME FIRST BYTE     BNE     XXD237          ; IF NO MATCH GO TRY THE NEXT ARRAY     LDA     XX46          ; ELSE GET THIS ARRAY NAME SECOND BYTE     CMP     (XX5F),Y          ; COMPARE WITH ARRAY NAME SECOND BYTE     BEQ     XXD24D          ; ARRAY FOUND SO BRANCH                         ; NO MATCHXXD237 = *     INY                    ; INCREMENT INDEX     LDA     (XX5F),Y          ; GET ARRAY SIZE LOW BYTE     CLC                    ; CLEAR CARRY FOR ADD     ADC     XX5F          ; ADD ARRAY START POINTER LOW BYTE     TAX                    ; COPY LOW BYTE TO X     INY                    ; INCREMENT INDEX     LDA     (XX5F),Y          ; GET ARRAY SIZE HIGH BYTE     ADC     XX60          ; ADD ARRAY MEMORY POINTER HIGH BYTE     BCC     XXD21C          ; IF NO OVERFLOW GO CHECK NEXT ARRAY; DO BAD SUBSCRIPT ERRORXXD245 = *     LDX     #$12               ; ERROR $12, BAD SUBSCRIPT ERROR     .BYTE     $2C               ; MAKES NEXT LINE BIT XX0EA2;***********************************************************************************;;; DO ILLEGAL QUANTITY ERRORXXD248 = *     LDX     #$0E               ; ERROR $0E, ILLEGAL QUANTITY ERRORXXD24A = *     JMP     XXC437          ; DO ERROR #X THEN WARM START;***********************************************************************************;;; ARRAY FOUNDXXD24D = *     LDX     #$13               ; SET ERROR $13, DOUBLE DIMENSION ERROR     LDA     XX0C          ; GET DIM FLAG     BNE     XXD24A          ; IF WE ARE TRYING TO DIMENSION IT DO ERROR #X THEN WARM                         ; START; FOUND THE ARRAY AND WE'RE NOT DIMENSIONING IT SO WE MUST FIND AN ELEMENT IN IT     JSR     XXD194          ; SET-UP ARRAY POINTER TO FIRST ELEMENT IN ARRAY     LDA     XX0B          ; GET DIMENSIONS COUNT     LDY     #$04               ; SET INDEX TO ARRAY'S # OF DIMENSIONS     CMP     (XX5F),Y          ; COMPARE WITH NO OF DIMENSIONS     BNE     XXD245          ; IF WRONG DO BAD SUBSCRIPT ERROR	     JMP     XXD2EA          ; FOUND ARRAY SO GO GET ELEMENT                         ; ARRAY NOT FOUND, SO BUILD ITXXD261 = *     JSR     XXD194          ; SET-UP ARRAY POINTER TO FIRST ELEMENT IN ARRAY     JSR     XXC408          ; CHECK AVAILABLE
 MEMORY, DO OUT OF MEMORY ERROR IF NO ROOM     LDY     #$00               ; CLEAR Y     STY     XX72          ; CLEAR ARRAY DATA SIZE HIGH BYTE     LDX     #$05               ; SET DEFAULT ELEMENT SIZE     LDA     XX45          ; GET VARIABLE NAME 1ST BYTE     STA     (XX5F),Y          ; SAVE ARRAY NAME 1ST BYTE     BPL     XXD274          ; BRANCH IF NOT STRING OR FLOATING POINT ARRAY     DEX                    ; DECREMENT ELEMENT SIZE, $04XXD274 = *     INY                    ; INCREMENT INDEX     LDA     XX46          ; GET VARIABLE NAME 2ND BYTE     STA     (XX5F),Y          ; SAVE ARRAY NAME 2ND BYTE     BPL     XXD27D          ; BRANCH IF NOT INTEGER OR STRING     DEX                    ; DECREMENT ELEMENT SIZE, $03     DEX                    ; DECREMENT ELEMENT SIZE, $02XXD27D = *     STX     XX71          ; SAVE ELEMENT SIZE     LDA     XX0B          ; GET DIMENSIONS COUNT     INY                    ; INCREMENT INDEX ..     INY                    ; .. TO ARRAY  ..     INY                    ; .. DIMENSION COUNT     STA     (XX5F),Y          ; SAVE ARRAY DIMENSION COUNTXXD286 = *     LDX     #$0B               ; SET DEFAULT DIMENSION SIZE LOW BYTE     LDA     #$00               ; SET DEFAULT DIMENSION SIZE HIGH BYTE     BIT     XX0C          ; TEST DIM FLAG     BVC     XXD296          ; IF DEFAULT TO BE USED DON'T PULL A DIMENSION     PLA                    ; PULL DIMENSION SIZE LOW BYTE     CLC                    ; CLEAR CARRY FOR ADD     ADC     #$01               ; ADD 1, ALLOW FOR ZEROETH ELEMENT     TAX                    ; COPY LOW BYTE TO X     PLA                    ; PULL DIMENSION SIZE HIGH BYTE     ADC     #$00               ; ADD CARRY TO HIGH BYTEXXD296 = *     INY                    ; INCEMENT INDEX TO DIMENSION SIZE HIGH BYTE     STA     (XX5F),Y          ; SAVE DIMENSION SIZE HIGH BYTE     INY                    ; INCEMENT INDEX TO DIMENSION SIZE LOW BYTE     TXA                    ; COPY DIMENSION SIZE LOW BYTE     STA     (XX5F),Y          ; SAVE DIMENSION SIZE LOW BYTE     JSR     XXD34C          ; COMPUTE ARRAY SIZE     STX     XX71          ; SAVE RESULT LOW BYTE     STA     XX72          ; SAVE RESULT HIGH BYTE     LDY     XX22          ; RESTORE INDEX     DEC     XX0B          ; DECREMENT DIMENSIONS COUNT     BNE     XXD286          ; LOOP IF NOT ALL DONE     ADC     XX59          ; ADD ARRAY DATA POINTER HIGH BYTE     BCS     XXD30B          ; IF OVERFLOW DO OUT OF MEMORY ERROR THEN WARM START     STA     XX59          ; SAVE ARRAY DATA POINTER HIGH BYTE     TAY                    ; COPY ARRAY DATA POINTER HIGH BYTE     TXA                    ; COPY ARRAY SIZE LOW BYTE     ADC     XX58          ; ADD ARRAY DATA POINTER LOW BYTE     BCC     XXD2B9          ; IF NO ROLLOVER SKIP THE HIGH BYTE INCREMENT     INY                    ; ELSE INCREMENT NEXT ARRAY POINTER HIGH BYTE     BEQ     XXD30B          ; IF ROLLED OVER DO OUT OF MEMORY ERROR THEN WARM STARTXXD2B9 = *     JSR     XXC408          ; CHECK AVAILABLE MEMORY, DO OUT OF MEMORY ERROR IF NO ROOM     STA     XX31          ; SET END OF ARRAYS LOW BYTE     STY     XX32          ; SET END OF ARRAYS HIGH BYTE; NOW THE ARAY IS CREATED WE NEED TO ZERO ALL THE ELEMENTS IN IT     LDA     #$00               ; CLEAR A FOR ARRAY CLEAR     INC     XX72          ; INCREMENT ARRAY SIZE HIGH BYTE, NOW BLOCK COUNT     LDY     XX71          ; GET ARRAY SIZE LOW BYTE, NOW INDEX TO BLOCK     BEQ     XXD2CD          ; IF $00 GO DO THE HIGH BYTE DECREMENTXXD2C8 = *     DEY                    ; DECREMENT INDEX, DO 0 TO N-1     STA     (XX58),Y          ; CLEAR ARRAY ELEMENT BYTE     BNE     XXD2C8          ; LOOP UNTIL THIS BLOCK DONEXXD2CD = *     DEC     XX59          ; DECREMENT ARRAY POINTER HIGH BYTE     DEC     XX72          ; DECREMENT BLOCK COUNT HIGH BYTE     BNE     XXD2C8          ; LOOP UNTIL ALL BLOCKS DONE     INC     XX59          ; CORRECT FOR LAST LOOP     SEC                    ; SET CARRY FOR SUBTRACT     LDA     XX31          ; GET END OF ARRAYS LOW BYTE     SBC     XX5F          ; SUBTRACT ARRAY START LOW BYTE     LDY     #$02               ; INDEX TO ARRAY SIZE LOW BYTE     STA     (XX5F),Y          ; SAVE ARRAY SIZE LOW BYTE     LDA     XX32          ; GET END OF ARRAYS HIGH BYTE     INY                    ; INDEX TO ARRAY SIZE HIGH BYTE     SBC     XX60          ; SUBTRACT ARRAY START HIGH BYTE     STA     (XX5F),Y          ; SAVE ARRAY SIZE HIGH BYTE     LDA     XX0C          ; GET DEFAULT DIM FLAG     BNE     XXD34B          ; EXIT IF THIS WAS A DIM COMMAND                         ; ELSE, FIND ELEMENT     INY                    ; SET INDEX TO # OF DIMENSIONS, THE DIMENSION INDECES                         ; ARE ON THE STACK AND WILL BE REMOVED AS THE POSITION                         ; OF THE ARRAY ELEMENT IS CALCULATEDXXD2EA = *     LDA     (XX5F),Y          ; GET ARRAY'S DIMENSION COUNT     STA     XX0B          ; SAVE IT     LDA     #$00               ; CLEAR BYTE     STA     XX71          ; CLEAR ARRAY DATA POINTER LOW BYTEXXD2F2 = *     STA     XX72          ; SAVE ARRAY DATA POINTER HIGH BYTE     INY                    ; INCREMENT INDEX, POINT TO ARRAY BOUND HIGH BYTE     PLA                    ; PULL ARRAY INDEX LOW BYTE     TAX                    ; COPY TO X     STA     XX64          ; SAVE INDEX LOW BYTE TO FAC1 MANTISSA 3     PLA                    ; PULL ARRAY INDEX HIGH BYTE     STA     XX65          ; SAVE INDEX HIGH BYTE TO FAC1 MANTISSA 4     CMP     (XX5F),Y          ; C OMPARE WITH ARRAY BOUND HIGH BYTE     BCC     XXD30E          ; IF WITHIN BOUNDS CONTINUE     BNE     XXD308          ; IF OUTSIDE BOUNDS DO BAD SUBSCRIPT ERROR                         ; ELSE HIGH BYTE WAS = SO TEST LOW BYTES     INY               !     ; INDEX TO ARRAY BOUND LOW BYTE     TXA                    ; GET ARRAY INDEX LOW BYTE     CMP     (XX5F),Y          ; COMPARE WITH ARRAY BOUND LOW BYTE     BCC     XXD30F          ; IF WITHIN BOUNDS CONTINUEXXD308 = *     JMP     XXD245       "   ; DO BAD SUBSCRIPT ERRORXXD30B = *     JMP     XXC435          ; DO OUT OF MEMORY ERROR THEN WARM STARTXXD30E = *     INY                    ; INDEX TO ARRAY BOUND LOW BYTEXXD30F = *     LDA     XX72          ; GET ARRAY DATA POINTER HIGH BYTE#     ORA     XX71          ; OR WITH ARRAY DATA POINTER LOW BYTE     CLC                    ; CLEAR CARRY FOR EITHER ADD, CARRY ALWAYS CLEAR HERE ??     BEQ     XXD320          ; IF ARRAY DATA POINTER = NULL SKIP THE MULTIPLY     JSR     XXD34C     $     ; COMPUTE ARRAY SIZE     TXA                    ; GET RESULT LOW BYTE     ADC     XX64          ; ADD INDEX LOW BYTE FROM FAC1 MANTISSA 3     TAX                    ; SAVE RESULT LOW BYTE     TYA                    ; GET RESULT HIGH BYTE     LD%Y     XX22          ; RESTORE INDEXXXD320 = *     ADC     XX65          ; ADD INDEX HIGH BYTE FROM FAC1 MANTISSA 4     STX     XX71          ; SAVE ARRAY DATA POINTER LOW BYTE     DEC     XX0B          ; DECREMENT DIMENSIONS COUNT     BNE     XXD2F2&          ; LOOP IF DIMENSIONS STILL TO DO     STA     XX72          ; SAVE ARRAY DATA POINTER HIGH BYTE     LDX     #$05               ; SET DEFAULT ELEMENT SIZE     LDA     XX45          ; GET VARIABLE NAME 1ST BYTE     BPL     XXD331          ; B'RANCH IF NOT STRING OR FLOATING POINT ARRAY     DEX                    ; DECREMENT ELEMENT SIZE, $04XXD331 = *     LDA     XX46          ; GET VARIABLE NAME 2ND BYTE     BPL     XXD337          ; BRANCH IF NOT INTEGER OR STRING     DEX                     ; DECREMENT ELEMENT SIZE, $03     DEX                    ; DECREMENT ELEMENT SIZE, $02XXD337 = *     STX     XX28          ; SAVE DIMENSION SIZE LOW BYTE     LDA     #$00               ; CLEAR DIMENSION SIZE HIGH BYTE     JSR     XXD355         BNE     XXD13B          ; IF NOT 'T' CONTINUE     CPY     #$C9 ;#'I'+$80          ; COMPARE SECOND CHARACTER WITH 'I$'     BEQ     XXD123          ; IF 'I$' RETURN NULL VALUE     CPY     #'I'               ; COMPARE SECOND CHARACTER WITH 'I'     BNE     XXD13B          ; IF NOT 'I' CONTINUE                         ; IF NAME IS 'TI' DO SYNTAX ERRORXXD138 = *     JMP     XXCF08          ; DO SYNTAX ERROR THEN WARM STARTXXD13B = *     CMP     #'S'               ; COMPARE FIRST CHARACTER WITH 'S'     BNE     XXD143          ; IF NOT 'S' CONTINUE     CPY     #'T'               ; COMPARE SECOND CHARACTER WITH 'T'     BEQ     XXD138          ; IF NAME IS 'ST' DO SYNTAX ERRORXXD143 = *     LDA     XX2F          ; GET END OF VARIABLES LOW BYTE     LDY     XX30          ; GET END OF VARIABLES HIGH BYTE     STA     XX5F          ; SAVE OLD BLOCK START LOW BYTE     STY     XX60          ; SAVE OLD BLOCK START HIGH BYTE     LDA     XX31          ; GET END OF ARRAYS LOW BYTE     LDY     XX32          ; GET END OF ARRAYS HIGH BYTE     STA     XX5A          ; SAVE OLD BLOCK END LOW BYTE     STY     XX5B          ; SAVE OLD BLOCK END HIGH BYTE     CLC                    ; CLEAR CARRY FOR ADD     ADC     #$07               ; +7, SPACE FOR ONE VARIABLE     BCC     XXD159          ; IF NO OVERFLOW SKIP THE HIGH BYTE INCREMENT     INY                    ; ELSE INCREMENT HIGH BYTEXXD159 = *     STA     XX58          ; SET NEW BLOCK END LOW BYTE     STY     XX59          ; SET NEW BLOCK END HIGH BYTE     JSR     XXC3B8          ; OPEN UP SPACE IN MEMORY     LDA     XX58          ; GET NEW START LOW BYTE     LDY     XX59          ; GET NEW START HIGH BYTE (-$100)     INY                    ; CORRECT HIGH BYTE     STA     XX2F          ; SET END OF VARIABLES LOW BYTE     STY     XX30          ; SET END OF VARIABLES HIGH BYTE     LDY     #$00               ; CLEAR INDEX     LDA     XX45          ; GET VARIABLE NAME 1ST CHARACTER     STA     (XX5F),Y          ; SAVE VARIABLE N	AME 1ST CHARACTER     INY                    ; INCREMENT INDEX     LDA     XX46          ; GET VARIABLE NAME 2ND CHARACTER     STA     (XX5F),Y          ; SAVE VARIABLE NAME 2ND CHARACTER     LDA     #$00               ; CLEAR A     INY             
       ; INCREMENT INDEX     STA     (XX5F),Y          ; INITIALISE VARIABLE BYTE     INY                    ; INCREMENT INDEX     STA     (XX5F),Y          ; INITIALISE VARIABLE BYTE     INY                    ; INCREMENT INDEX     STA     (XX5F),Y          ; INITIALISE VARIABLE BYTE     INY                    ; INCREMENT INDEX     STA     (XX5F),Y          ; INITIALISE VARIABLE BYTE     INY                    ; INCREMENT INDEX     STA     (XX5F),Y          ; INITIALISE VARIABLE BYTE                         ; FOUND A MATCH FOR VARIABLEXXD185 = *     LDA     XX5F          ; GET VARIABLE ADDRESS LOW BYTE     CLC                    ; CLEAR CARRY FOR ADD     ADC     #$02               ; +2, OFFSET PAST VARIABLE NAME BYTES     LDY     XX60          ; GET VARIABLE ADDRESS HIGH BYTE     BCC     XXD18F          ; IF NO OVERFLOW SKIP THE HIGH BYTE INCREMENT     INY                    ; ELSE INCREMENT HIGH BYTEXXD18F = *     STA     XX47          ; SAVE CURRENT VARIABLE POINTER LOW BYTE     STY     XX48          ; SAVE CURRENT VARIABLE POINTER HIGH BYTE     RTS;***********************************************************************************;;; SET-UP ARRAY POINTER TO FIRST ELEMENT IN ARRAYXXD194 = *     LDA     XX0B          ; GET # OF DIMENSIONS (1, 2 OR 3)     ASL A                  ; *2 (ALSO CLEARS THE CARRY !)     ADC     #$05               ; +5 (RESULT IS 7, 9 OR 11 HERE)     ADC     XX5F          ; ADD ARRAY START POINTER LOW BYTE     LDY     XX60          ; GET ARRAY POINTER HIGH BYTE     BCC     XXD1A0          ; IF NO OVERFLOW SKIP THE HIGH BYTE INCREMENT     INY                    ; ELSE INCREMENT HIGH BYTEXXD1A0 = *     STA     XX58          ; SAVE ARRAY DATA POINTER LOW BYTE     STY     XX59          ; SAVE ARRAY DATA POINTER HIGH BYTE     RTS;***********************************************************************************;;; -32768 AS FLOATING VALUEXXD1A5 = *     .BYTE     $90,$80,$00,$00,$00     ; -32768;***********************************************************************************;;; CONVERT FLOAT TO FIXEDXXD1AA = *     JSR     XXD1BF          ; EVALUATE INTEGER EXPRESSION, NO SIGN CHECK     LDA     XX64          ; GET RESULT LOW BYTE     LDY     XX65          ; GET RESULT HIGH BYTE     RTS;***********************************************************************************;;; EVALUATE INTEGER EXPRESSIONXXD1B2 = *     JSR     XX0073          ; INCREMENT AND SCAN MEMORY     JSR     XXCD9E          ; EVALUATE EXPRESSION; EVALUATE INTEGER EXPRESSION, SIGN CHECKXXD1B8 = *     JSR     XXCD8D          ; CHECK IF SOURCE IS NUMERIC, ELSE DO TYPE MISMATCH     LDA     XX66          ; GET FAC1 SIGN (B7)     BMI     XXD1CC          ; DO ILLEGAL QUANTITY ERROR IF -VE; EVALUATE INTEGER EXPRESSION, NO SIGN CHECKXXD1BF = *     LDA     XX61          ; GET FAC1 EXPONENT     CMP     #$90               ; COMPARE WITH EXPONENT = 2^16 (N>2^15)     BCC     XXD1CE          ; IF N<2^16 GO CONVERT FAC1 FLOATING TO FIXED AND RETURN     LDA     #<XXD1A5          ; SET POINTER LOW BYTE TO -32768     LDY     #>XXD1A5          ; SET POINTER HIGH BYTE TO -32768     JSR     XXDC5B          ; COMPARE FAC1 WITH (AY)XXD1CC = *     BNE     XXD248          ; IF <> DO ILLEGAL QUANTITY ERROR THEN WARM STARTXXD1CE = *     JMP     XXDC9B          ; CONVERT FAC1 FLOATING TO FIXED AND RETURN;***********************************************************************************;;; AN ARRAY IS STORED AS FOLLOWS;; ARRAY NAME               ; TWO BYTES WITH THE FOLLOWING PATTERNS FOR DIFFERENT TYPES;                         ; 1ST CHAR     2ND CHAR;                         ;   B7       B7          TYPE               ELEMENT SIZE;                         ; --------     --------     -----               ------------;                         ;   0            0          FLOATING POINT      5;                         ;   0            1          STRING           3;                         ;   1            1          INTEGER           2; OFFSET TO NEXT ARRAY          ; WORD; DIMENSION COUNT               ; BYTE; 1ST DIMENSION SIZE          ; WORD, THIS IS THE NUMBER OF ELEMENTS INCLUDING 0; 2ND DIMENSION SIZE          ; WORD, ONLY HERE IF THE ARRAY HAS A SECOND DIMENSION; 2ND DIMENSION SIZE          ; WORD, ONLY HERE IF THE ARRAY HAS A THIRD DIMENSION;                         ; NOTE: THE DIMENSION SIZE WORD IS IN HIGH BYTE LOW BYTE;                         ; FORMAT, NOT LIKE MOST 6502 WORDS; THEN FOR EACH ELEMENT THE REQUIRED NUMBER OF BYTES GIVEN AS THE ELEMENT SIZE ABOVE; FIND OR MAKE ARRAYXXD1D1 = *     LDA     XX0C          ; GET DIM FLAG     ORA     XX0E          ; OR WITH DATA TYPE FLAG     PHA                    ; PUSH IT     LDA     XX0D          ; GET DATA TYPE FLAG, $FF = STRING, $00 = NUMERIC     PHA                    ; PUSH IT     LDY     #$00               ; CLEAR DIMENSIONS COUNT; NOW GET THE ARRAY DIMENSION(S) AND STACK IT (THEM) BEFORE THE DATA TYPE AND DIM FLAGXXD1DB = *     TYA                    ; COPY DIMENSIONS COUNT     PHA                    ; SAVE IT     LDA     XX46          ; GET ARRAY NAME 2ND BYTE     PHA                    ; SAVE IT     LDA     XX45          ; GET ARRAY NAME 1ST BYTE     PHA                    ; SAVE IT     JSR     XXD1B2          ; EVALUATE INTEGER EXPRESSION     PLA                    ; PULL ARRAY NAME 1ST BYTE     STA     XX45          ; RESTORE ARRAY NAME 1ST BYTE     PLA                    ; PULL ARRAY NAME 2ND BYTE     STA     XX46           ; RESTORE ARRAY NAME 2ND BYTE     PLA                    ; PULL DIMENSIONS COUNT     TAY                    ; RESTORE IT     TSX                    ; COPY STACK POINTER     LDA     XX0100+2,X     ; GET DIM FLAG     PHA                    ; PUSH I!T     LDA     XX0100+1,X     ; GET DATA TYPE FLAG     PHA                    ; PUSH IT     LDA     XX64          ; GET THIS DIMENSION SIZE HIGH BYTE     STA     XX0100+2,X     ; STACK BEFORE FLAG BYTES     LDA     XX65          ; GET THIS DIMENSION "SIZE LOW BYTE     STA     XX0100+1,X     ; STACK BEFORE FLAG BYTES     INY                    ; INCREMENT DIMENSIONS COUNT     JSR     XX0079          ; SCAN MEMORY     CMP     #','               ; COMPARE WITH ','     BEQ     XXD1DB          ; IF F#OUND GO DO NEXT DIMENSION     STY     XX0B          ; STORE DIMENSIONS COUNT     JSR     XXCEF7          ; SCAN FOR ')', ELSE DO SYNTAX ERROR THEN WARM START     PLA                    ; PULL DATA TYPE FLAG     STA     XX0D          ; RESTORE DATA T$YPE FLAG, $FF = STRING, $00 = NUMERIC     PLA                    ; PULL DATA TYPE FLAG     STA     XX0E          ; RESTORE DATA TYPE FLAG, $80 = INTEGER, $00 = FLOAT     AND     #$7F               ; MASK DIM FLAG     STA     XX0C          ; RESTORE D%IM FLAG     LDX     XX2F          ; SET END OF VARIABLES LOW BYTE                         ; (ARRAY MEMORY START LOW BYTE)     LDA     XX30          ; SET END OF VARIABLES HIGH BYTE                         ; (ARRAY MEMORY START HIGH BYTE); NOW CHECK& TO SEE IF WE ARE AT THE END OF ARRAY MEMORY, WE WOULD BE IF THERE WERE; NO ARRAYS.XXD21C = *     STX     XX5F          ; SAVE AS ARRAY START POINTER LOW BYTE     STA     XX60          ; SAVE AS ARRAY START POINTER HIGH BYTE     CMP     XX32       '   ; COMPARE WITH END OF ARRAYS HIGH BYTE     BNE     XXD228          ; IF NOT REACHED ARRAY MEMORY END CONTINUE SEARCHING     CPX     XX31          ; ELSE COMPARE WITH END OF ARRAYS LOW BYTE     BEQ     XXD261          ; GO BUILD ARRAY IF NOT FOUND                          ; SEARCH FOR ARRAYXXD228 = *     LDY     #$00               ; CLEAR INDEX     LDA     (XX5F),Y          ; GET ARRAY NAME FIRST BYTE     INY                    ; INCREMENT INDEX TO SECOND NAME BYTE     CMP     XX45          ATE RESULT; DO STRING < COMPAREXXD02E = *     LDA     #$00               ; CLEAR BYTE     STA     XX0D          ; CLEAR DATA TYPE FLAG, $FF = STRING, $00 = NUMERIC     DEC     XX4D          ; CLEAR < BIT IN COMPARRISON EVALUATION FLAG     JSR     XXD6A6          ; POP STRING OFF DESCRIPTOR STACK, OR FROM TOP OF STRING                         ; SPACE RETURNS WITH A = LENGTH, X = POINTER LOW BYTE,                         ; Y = POINTER HIGH BYTE     STA     XX61          ; SAVE LENGTH     STX     XX62          ; SAVE STRING POINTER LOW BYTE     STY     XX63          ; SAVE STRING POINTER HIGH BYTE     LDA     XX6C          ; GET DESCRIPTOR POINTER LOW BYTE     LDY     XX6D          ; GET DESCRIPTOR POINTER HIGH BYTE     JSR     XXD6AA          ; POP (YA) DESCRIPTOR OFF STACK OR FROM TOP OF STRING SPACE                         ; RETURNS WITH A = LENGTH, X = POINTER LOW BYTE,                         ; Y = POINTER HIGH BYTE     STX     XX6C          ; SAVE STRING POINTER LOW BYTE     STY     XX6D          ; SAVE STRING POINTER HIGH BYTE     TAX                    ; COPY LENGTH     SEC                    ; SET CARRY FOR SUBTRACT     SBC     XX61          ; SUBTRACT STRING 1 LENGTH     BEQ     XXD056          ; IF STR 1 LENGTH = STRING 2 LENGTH GO COMPARE THE STRINGS     LDA     #$01               ; SET STR 1 LENGTH > STRING 2 LENGTH     BCC     XXD056          ; IF SO RETURN + 1 IF OTHERWISE EQUAL     LDX     XX61          ; GET STRING 1 LENGTH     LDA     #$FF               ; SET STR 1 LENGTH < STRING 2 LENGTHXXD056 = *     STA     XX66          ; SAVE LENGTH COMPARE     LDY     #$FF               ; SET INDEX     INX                    ; ADJUST FOR LOOPXXD05B = *     INY                    ; INCREMENT INDEX     DEX                    ; DECREMENT COUNT     BNE     XXD066          ; IF STILL BYTES TO DO GO COMPARE THEM     LDX     XX66          ; GET LENGTH COMPARE BACKXXD061 = *     BMI     XXD072          ; BRANCH IF STR 1 < STR 2     CLC                    ; 	FLAG STR 1 <= STR 2     BCC     XXD072          ; GO EVALUATE RESULT, BRANCH ALWAYSXXD066 = *     LDA     (XX6C),Y          ; GET STRING 2 BYTE     CMP     (XX62),Y          ; COMPARE WITH STRING 1 BYTE     BEQ     XXD05B          ; LOOP IF BYTES =
     LDX     #$FF               ; SET STR 1 < STRING 2     BCS     XXD072          ; BRANCH IF SO     LDX     #$01               ; SET STR 1 > STRING 2XXD072 = *     INX                    ; X = 0, 1 OR 2     TXA                    ; COPY TO A     ROL A                  ; * 2 (1, 2 OR 4)     AND     XX12          ; AND WITH THE COMPARISON EVALUATION FLAG     BEQ     XXD07B          ; BRANCH IF 0 (COMPARE IS FALSE)     LDA     #$FF               ; ELSE SET RESULT TRUEXXD07B = *     JMP     XXDC3C          ; SAVE A AS INTEGER BYTE AND RETURNXXD07E = *     JSR     XXCEFD          ; SCAN FOR ',', ELSE DO SYNTAX ERROR THEN WARM START;***********************************************************************************;;; PERFORM DIMXXD081 = *     TAX                    ; COPY 'DIM' FLAG TO X     JSR     XXD090          ; SEARCH FOR VARIABLE     JSR     XX0079          ; SCAN MEMORY     BNE     XXD07E          ; SCAN FOR ',' AND LOOP IF NOT NULL     RTS;***********************************************************************************;;; SEARCH FOR VARIABLEXXD08B = *     LDX     #$00               ; SET DIM FLAG = $00     JSR     XX0079          ; SCAN MEMORY, 1ST CHARACTERXXD090 = *     STX     XX0C          ; SAVE DIM FLAGXXD092 = *     STA     XX45          ; SAVE 1ST CHARACTER     JSR     XX0079          ; SCAN MEMORY     JSR     XXD113          ; CHECK BYTE, RETURN CB = 0 IF<'A' OR >'Z'     BCS     XXD09F          ; IF OK CONTINUEXXD09C = *     JMP     XXCF08          ; ELSE SYNTAX ERROR THEN WARM START; WAS VARIABLE NAME SO ...XXD09F = *     LDX     #$00               ; CLEAR 2ND CHARACTER TEMP     STX     XX0D          ; CLEAR DATA TYPE FLAG, $FF = STRING, $00 = NUMERIC     STX     XX0E          ; CLEAR DATA TYPE FLAG, $80 = INTEGER, $00 = FLOAT     JSR     XX0073          ; INCREMENT AND SCAN MEMORY, 2ND CHARACTER     BCC     XXD0AF          ; IF CHARACTER = '0'-'9' (OK) GO SAVE 2ND CHARACTER                         ; 2ND CHARACTER WASN'T '0' TO '9' SO ...     JSR     XXD113          ; CHECK BYTE, RETURN CB = 0 IF<'A' OR >'Z'     BCC     XXD0BA          ; IF <'A' OR >'Z' GO CHECK IF STRINGXXD0AF = *     TAX                    ; COPY 2ND CHARACTER                         ; IGNORE FURTHER (VALID) CHARACTERS IN THE VARIABLE NAMEXXD0B0 = *     JSR     XX0073          ; INCREMENT AND SCAN MEMORY, 3RD CHARACTER     BCC     XXD0B0          ; LOOP IF CHARACTER = '0'-'9' (IGNORE)     JSR     XXD113          ; CHECK BYTE, RETURN CB = 0 IF<'A' OR >'Z'     BCS     XXD0B0          ; LOOP IF CHARACTER = 'A'-'Z' (IGNORE)                         ; CHECK IF STRING VARIABLEXXD0BA = *     CMP     #'$'               ; COMPARE WITH '$'     BNE     XXD0C4          ; IF NOT STRING GO CHECK INTEGER                         ; TYPE IS STRING     LDA     #$FF               ; SET DATA TYPE = STRING     STA     XX0D          ; SET DATA TYPE FLAG, $FF = STRING, $00 = NUMERIC     BNE     XXD0D4          ; BRANCH ALWAYSXXD0C4 = *     CMP     #$25               ; COMPARE WITH '%'     BNE     XXD0DB          ; IF NOT INTEGER GO CHECK FOR AN ARRAY     LDA     XX10          ; GET SUBSCRIPT/FNX FLAG     BNE     XXD09C          ; IF ?? DO SYNTAX ERROR THEN WARM START     LDA     #$80               ; SET INTEGER TYPE     STA     XX0E          ; SET DATA TYPE = INTEGER     ORA     XX45          ; OR CURRENT VARIABLE NAME FIRST BYTE     STA     XX45          ; SAVE CURRENT VARIABLE NAME FIRST BYTEXXD0D4 = *     TXA                    ; GET 2ND CHARACTER BACK     ORA     #$80               ; SET TOP BIT, INDICATE STRING OR INTEGER VARIABLE     TAX                    ; COPY BACK TO 2ND CHARACTER TEMP     JSR     XX0073          ; INCREMENT AND SCAN MEMORYXXD0DB = *     STX     XX46          ; SAVE 2ND CHARACTER     SEC                    ; SET CARRY FOR SUBTRACT     ORA     XX10          ; OR WITH SUBSCRIPT/FNX FLAG - OR FN NAME     SBC     #$28               ; SUBTRACT '('     BNE     XXD0E7          ; IF NOT '(' GO FIND A PLAIN NUMERIC VARIABLE     JMP     XXD1D1          ; ELSE GO FIND, OR MAKE, ARRAY; EITHER FIND OR CREATE VARIABLE                         ; VARIABLE NAME WASN'T XX(.... SO LOOK FOR PLAIN VARIABLEXXD0E7 = *     LDY     #$00               ; CLEAR A     STY     XX10          ; CLEAR SUBSCRIPT/FNX FLAG     LDA     XX2D          ; GET START OF VARIABLES LOW BYTE     LDX     XX2E          ; GET START OF VARIABLES HIGH BYTEXXD0EF = *     STX     XX60          ; SAVE SEARCH ADDRESS HIGH BYTEXXD0F1 = *     STA     XX5F          ; SAVE SEARCH ADDRESS LOW BYTE     CPX     XX30          ; COMPARE WITH END OF VARIABLES HIGH BYTE     BNE     XXD0FB          ; SKIP NEXT COMPARE IF <>                         ; HIGH ADDRESSES WERE = SO COMPARE LOW ADDRESSES     CMP     XX2F          ; COMPARE LOW ADDRESS WITH END OF VARIABLES LOW BYTE     BEQ     XXD11D          ; IF NOT FOUND GO MAKE NEW VARIABLEXXD0FB = *     LDA     XX45          ; GET 1ST CHARACTER OF VARIABLE TO FIND     CMP     (XX5F),Y          ; COMPARE WITH VARIABLE NAME 1ST CHARACTER     BNE     XXD109          ; IF NO MATCH GO TRY THE NEXT VARIABLE                         ; 1ST CHARACTERS MATCH SO COMPARE 2ND CHARACTER     LDA     XX46          ; GET 2ND CHARACTER OF VARIABLE TO FIND     INY                    ; INDEX TO POINT TO VARIABLE NAME 2ND CHARACTER     CMP     (XX5F),Y          ; COMPARE WITH VARIABLE NAME 2ND CHARACTER     BEQ     XXD185          ; IF MATCH GO RETURN THE VARIABLE     DEY                    ; ELSE  DECREMENT INDEX (NOW = $00)XXD109 = *     CLC                    ; CLEAR CARRY FOR ADD     LDA     XX5F          ; GET SEARCH ADDRESS LOW BYTE     ADC     #$07               ; +7, OFFSET TO NEXT VARIABLE NAME     BCC     XXD0F1          ; LOOP IF NO! OVERFLOW TO HIGH BYTE     INX                    ; ELSE INCREMENT HIGH BYTE     BNE     XXD0EF          ; LOOP ALWAYS, RAM DOESN'T EXTEND TO $FFFF;***********************************************************************************;;; CHECK BYTE," RETURN CB = 0 IF<'A' OR >'Z'XXD113 = *     CMP     #$41               ; COMPARE WITH 'A'     BCC     XXD11C          ; EXIT IF LESS                         ; CARRY IS SET     SBC     #$5B               ; SUBTRACT 'Z'+1     SEC                   # ; SET CARRY     SBC     #$A5               ; SUBTRACT $A5 (RESTORE BYTE)                         ; CARRY CLEAR IF BYTE > $5AXXD11C = *     RTS;***********************************************************************************;;                $         ; REACHED END OF VARIABLE MEMORY WITHOUT MATCH                         ; ... SO CREATE NEW VARIABLEXXD11D = *     PLA                    ; POP RETURN ADDRESS LOW BYTE     PHA                    ; PUSH RETURN ADDRESS LOW BYTE     CMP     #$2%A               ; COMPARE WITH EXPECTED CALLING ROUTINE RETURN LOW BYTE     BNE     XXD128          ; IF NOT GET VARIABLE GO CREATE NEW VARIABLE; THIS WILL ONLY DROP THROUGH IF THE CALL WAS FROM XXXXXX AND IS ONLY CALLED; FROM THERE IF IT IS SEARCHIN&G FOR A VARIABLE FROM THE RIGHT HAND SIDE OF A LET A=B; STATEMENT, IT PREVENTS THE CREATION OF VARIABLES NOT ASSIGNED A VALUE.; VALUE RETURNED BY THIS IS EITHER NUMERIC ZERO, EXPONENT BYTE IS $00, OR NULL STRING,; DESCRIPTOR LENGTH BYTE IS $00. IN FA'CT A POINTER TO ANY $00 BYTE WOULD HAVE DONE.                         ; ELSE RETURN DUMMY NULL VALUEXXD123 = *     LDA     #<XXDF13          ; SET RESULT POINTER LOW BYTE     LDY     #>XXDF13          ; SET RESULT POINTER HIGH BYTE     RTS                          ; CREATE NEW NUMERIC VARIABLEXXD128 = *     LDA     XX45          ; GET VARIABLE NAME FIRST CHARACTER     LDY     XX46          ; GET VARIABLE NAME SECOND CHARACTER     CMP     #'T'               ; COMPARE FIRST CHARACTER WITH 'T' P     XXCDFA          ; EXECUTE FUNCTION THEN CONTINUE EVALUATION;***********************************************************************************;;; CHECK ADDRESS RANGE, RETURN CB = 1 IF ADDRESS IN BASIC ROMXXCF14 = *     SEC                    ; SET CARRY FOR SUBTRACT     LDA     XX64          ; GET VARIABLE ADDRESS LOW BYTE     SBC     #$00               ; SUBTRACT $C000 LOW BYTE     LDA     XX65          ; GET VARIABLE ADDRESS HIGH BYTE     SBC     #$C0               ; SUBTRACT $C000 HIGH BYTE     BCC     XXCF27          ; EXIT IF ADDRESS < $C000     LDA     #<XXE387          ; GET END OF BASIC MARKER LOW BYTE     SBC     XX64          ; SUBTRACT VARIABLE ADDRESS LOW BYTE     LDA     #>XXE387          ; GET END OF BASIC MARKER HIGH BYTE     SBC     XX65          ; SUBTRACT VARIABLE ADDRESS HIGH BYTEXXCF27 = *     RTS;***********************************************************************************;;; VARIABLE NAME SET-UPXXCF28 = *     JSR     XXD08B          ; GET VARIABLE ADDRESS     STA     XX64          ; SAVE VARIABLE POINTER LOW BYTE     STY     XX65          ; SAVE VARIABLE POINTER HIGH BYTE     LDX     XX45          ; GET CURRENT VARIABLE NAME FIRST CHARACTER     LDY     XX46          ; GET CURRENT VARIABLE NAME SECOND CHARACTER     LDA     XX0D          ; GET DATA TYPE FLAG, $FF = STRING, $00 = NUMERIC     BEQ     XXCF5D          ; IF NUMERIC GO HANDLE A NUMERIC VARIABLE; VARIABLE IS STRING     LDA     #$00               ; ELSE CLEAR A     STA     XX70          ; CLEAR FAC1 ROUNDING BYTE     JSR     XXCF14          ; CHECK ADDRESS RANGE     BCC     XXCF5C          ; EXIT IF NOT IN BASIC ROM     CPX     #'T'               ; COMPARE VARIABLE NAME FIRST CHARACTER WITH 'T'     BNE     XXCF5C          ; EXIT IF NOT 'T'     CPY     #$C9 ;#'I'+$80          ; COMPARE VARIABLE NAME SECOND CHARACTER WITH 'I$'     BNE     XXCF5C          ; EXIT IF NOT 'I$'                         ; VARIABLE NAME WAS 'TI$'     JSR     XXCF84          ; READ RE	AL TIME CLOCK INTO FAC1 MANTISSA, 0HML     STY     XX5E          ; CLEAR EXPONENT COUNT ADJUST     DEY                    ; Y = $FF     STY     XX71          ; SET OUTPUT STRING INDEX, -1 TO ALLOW FOR PRE INCREMENT     LDY     #$06               ; HH
:MM:SS IS SIX DIGITS     STY     XX5D          ; SET NUMBER OF CHARACTERS BEFORE THE DECIMAL POINT     LDY     #XXDF3A-XXDF16                         ; INDEX TO JIFFY CONVERSION TABLE     JSR     XXDE68          ; CONVERT JIFFY COUNT TO STRING     JMP     XXD46F          ; EXIT VIA STR$() CODE TAILXXCF5C = *     RTS; VARIABLE NAME SET-UP, VARIABLE IS NUMERICXXCF5D = *     BIT     XX0E          ; TEST DATA TYPE FLAG, $80 = INTEGER, $00 = FLOAT     BPL     XXCF6E          ; IF FLOAT GO HANDLE FLOAT; ELSE HANDLE INTEGER VARIABLE     LDY     #$00               ; CLEAR INDEX     LDA     (XX64),Y          ; GET INTEGER VARIABLE LOW BYTE     TAX                    ; COPY TO X     INY                    ; INCREMENT INDEX     LDA     (XX64),Y          ; GET INTEGER VARIABLE HIGH BYTE     TAY                    ; COPY TO Y     TXA                    ; COPY LOA BYTE TO A     JMP     XXD391          ; CONVERT FIXED INTEGER AY TO FLOAT FAC1 AND RETURN; VARIABLE NAME SET-UP, VARIABLE IS FLOATXXCF6E = *     JSR     XXCF14          ; CHECK ADDRESS RANGE     BCC     XXCFA0          ; IF NOT IN BASIC ROM GET POINTER AND UNPACK INTO FAC1     CPX     #'T'               ; COMPARE VARIABLE NAME FIRST CHARACTER WITH 'T'     BNE     XXCF92          ; IF NOT 'T' SKIP TX VARIABLES     CPY     #'I'               ; COMPARE VARIABLE NAME SECOND CHARACTER WITH 'I'     BNE     XXCFA0          ; IF NOT 'I' GO DO PLAIN FLOAT                         ; VARIABLE NAME WAS 'TI'     JSR     XXCF84          ; READ REAL TIME CLOCK INTO FAC1 MANTISSA, 0HML     TYA                    ; CLEAR A     LDX     #$A0               ; SET EXPONENT TO 32 BIT VALUE     JMP     XXDC4F          ; SET EXPONENT = X AND NORMALISE FAC1;***********************************************************************************;;; READ REAL TIME CLOCK INTO FAC1 MANTISSA, 0HMLXXCF84 = *     JSR     XXFFDE          ; READ REAL TIME CLOCK     STX     XX64          ; SAVE JIFFY CLOCK MID BYTE AS  FAC1 MANTISSA 3     STY     XX63          ; SAVE JIFFY CLOCK HIGH BYTE AS  FAC1 MANTISSA 2     STA     XX65          ; SAVE JIFFY CLOCK LOW BYTE AS  FAC1 MANTISSA 4     LDY     #$00               ; CLEAR Y     STY     XX62          ; CLEAR FAC1 MANTISSA 1     RTS;***********************************************************************************;;; VARIABLE NAME SET-UP, VARIABLE IS FLOAT AND NOT 'TX'XXCF92 = *     CPX     #'S'               ; COMPARE VARIABLE NAME FIRST CHARACTER WITH 'S'     BNE     XXCFA0          ; IF NOT 'S' GO DO NORMAL FLOATING VARIABLE     CPY     #'T'               ; COMPARE VARIABLE NAME SECOND CHARACTER WITH '     BNE     XXCFA0          ; IF NOT 'T' GO DO NORMAL FLOATING VARIABLE                         ; VARIABLE NAME WAS 'ST'     JSR     XXFFB7          ; READ I/O STATUS WORD     JMP     XXDC3C          ; SAVE A AS INTEGER BYTE AND RETURN; VARIABLE IS PLAIN FLOATXXCFA0 = *     LDA     XX64          ; GET VARIABLE POINTER LOW BYTE     LDY     XX65          ; GET VARIABLE POINTER HIGH BYTE     JMP     XXDBA2          ; UNPACK MEMORY (AY) INTO FAC1;***********************************************************************************;;; GET VALUE FROM LINE CONTINUED; ONLY FUNCTIONS LEFT SO ..; SET UP FUNCTION REFERENCESXXCFA7 = *     ASL A                  ; *2 (2 BYTES PER FUNCTION ADDRESS)     PHA                    ; SAVE FUNCTION OFFSET     TAX                    ; COPY FUNCTION OFFSET     JSR     XX0073          ; INCREMENT AND SCAN MEMORY     CPX     #$8F               ; COMPARE FUNCTION OFFSET TO CHR$ TOKEN OFFSET+1     BCC     XXCFD1          ; IF < LEFT$ (CAN NOT BE =) GO DO FUNCTION SETUP; GET VALUE FROM LINE .. CONTINUED; WAS LEFT$, RIGHT$ OR MID$ SO..     JSR     XXCEFA          ; SCAN FOR '(', ELSE DO SYNTAX ERROR THEN WARM START     JSR     XXCD9E          ; EVALUATE, SHOULD BE STRING, EXPRESSION     JSR     XXCEFD          ; SCAN FOR ',', ELSE DO SYNTAX ERROR THEN WARM START     JSR     XXCD8F          ; CHECK IF SOURCE IS STRING, ELSE DO TYPE MISMATCH     PLA                    ; RESTORE FUNCTION OFFSET     TAX                    ; COPY IT     LDA     XX65          ; GET DESCRIPTOR POINTER HIGH BYTE     PHA                    ; PUSH STRING POINTER HIGH BYTE     LDA     XX64          ; GET DESCRIPTOR POINTER LOW BYTE     PHA                    ; PUSH STRING POINTER LOW BYTE     TXA                    ; RESTORE FUNCTION OFFSET     PHA                    ; SAVE FUNCTION OFFSET     JSR     XXD79E          ; GET BYTE PARAMETER     PLA                    ; RESTORE FUNCTION OFFSET     TAY                    ; COPY FUNCTION OFFSET     TXA                    ; COPY BYTE PARAMETER TO A     PHA                    ; PUSH BYTE PARAMETER     JMP     XXCFD6          ; GO CALL FUNCTION; GET VALUE FROM LINE .. CONTINUED; WAS SGN() TO CHR$() SO..XXCFD1 = *     JSR     XXCEF1          ; EVALUATE EXPRESSION WITHIN PARENTHESES     PLA                    ; RESTORE FUNCTION OFFSET     TAY                    ; COPY TO INDEXXXCFD6 = *     LDA     XXC052-$68,Y     ; GET FUNCTION JUMP VECTOR LOW BYTE     STA     XX55          ; SAVE FUNCTIONS JUMP VECTOR LOW BYTE     LDA     XXC052-$67,Y     ; GET FUNCTION JUMP VECTOR HIGH BYTE     STA     XX56          ; SAVE FUNCTIONS JUMP VECTOR HIGH BYTE     JSR     XX54          ; DO FUNCTION CALL     JMP     XXCD8D          ; CHECK IF SOURCE IS NUMERIC AND RTS, ELSE DO TYPE MISMATCH                         ; STRING FUNCTIONS AVOID THIS BY DUMPING THE RETURN ADDRESS;************ ***********************************************************************;;; PERFORM OR; THIS WORKS BECAUSE NOT(NOT(X) AND NOT(Y)) = X OR YXXCFE6 = *     LDY     #$FF               ; SET Y FOR OR     .BYTE     $2C               ; MAKES NEXT LINE BIT! XX00A0;***********************************************************************************;;; PERFORM ANDXXCFE9 = *     LDY     #$00               ; CLEAR Y FOR AND     STY     XX0B          ; SET AND/OR INVERT VALUE     JSR     XXD1BF        "  ; EVALUATE INTEGER EXPRESSION, NO SIGN CHECK     LDA     XX64          ; GET FAC1 MANTISSA 3     EOR     XX0B          ; EOR LOW BYTE     STA     XX07          ; SAVE IT     LDA     XX65          ; GET FAC1 MANTISSA 4     EOR     XX0B          ; E#OR HIGH BYTE     STA     XX08          ; SAVE IT     JSR     XXDBFC          ; COPY FAC2 TO FAC1, GET 2ND VALUE IN EXPRESSION     JSR     XXD1BF          ; EVALUATE INTEGER EXPRESSION, NO SIGN CHECK     LDA     XX65          ; GET FAC1 MANTISSA 4   $  EOR     XX0B          ; EOR HIGH BYTE     AND     XX08          ; AND WITH EXPRESSION 1 HIGH BYTE     EOR     XX0B          ; EOR RESULT HIGH BYTE     TAY                    ; SAVE IN Y     LDA     XX64          ; GET FAC1 MANTISSA 3     EOR     X%X0B          ; EOR LOW BYTE     AND     XX07          ; AND WITH EXPRESSION 1 LOW BYTE     EOR     XX0B          ; EOR RESULT LOW BYTE     JMP     XXD391          ; CONVERT FIXED INTEGER AY TO FLOAT FAC1 AND RETURN;*********************************&**************************************************;;; PERFORM COMPARISONS; DO < COMPAREXXD016 = *     JSR     XXCD90          ; TYPE MATCH CHECK, SET C FOR STRING     BCS     XXD02E          ; IF STRING GO DO STRING COMPARE                     '    ; DO NUMERIC < COMPARE     LDA     XX6E          ; GET FAC2 SIGN (B7)     ORA     #$7F               ; SET ALL NON SIGN BITS     AND     XX6A          ; AND FAC2 MANTISSA 1 (AND IN SIGN BIT)     STA     XX6A          ; SAVE FAC2 MANTISSA 1     L DA     #<XX69          ; SET POINTER LOW BYTE TO FAC2     LDY     #>XX69          ; SET POINTER HIGH BYTE TO FAC2     JSR     XXDC5B          ; COMPARE FAC1 WITH (AY)     TAX                    ; COPY THE RESULT     JMP     XXD061          ; GO EVALUNCTION PRECEDENCE     BCS     XXCE66          ; IF A >=, POP FAC2 AND RETURN     BCC     XXCDF9          ; ELSE GO STACK THIS ONE AND CONTINUE, BRANCH ALWAYS;***********************************************************************************;;; GET VECTOR, EXECUTE FUNCTION THEN CONTINUE EVALUATIONXXCE20 = *     LDA     XXC080+2,Y     ; GET FUNCTION VECTOR HIGH BYTE     PHA                    ; ONTO STACK     LDA     XXC080+1,Y     ; GET FUNCTION VECTOR LOW BYTE     PHA                    ; ONTO STACK                         ; NOW PUSH SIGN, ROUND FAC1 AND PUT ON STACK     JSR     XXCE33          ; FUNCTION WILL RETURN HERE, THEN THE NEXT RTS WILL CALL                         ; THE FUNCTION     LDA     XX4D          ; GET COMPARRISON EVALUATION FLAG     JMP     XXCDA9          ; CONTINUE EVALUATING EXPRESSIONXXCE30 = *     JMP     XXCF08          ; DO SYNTAX ERROR THEN WARM STARTXXCE33 = *     LDA     XX66          ; GET FAC1 SIGN (B7)     LDX     XXC080,Y          ; GET PRECEDENCE BYTE;***********************************************************************************;;; PUSH SIGN, ROUND FAC1 AND PUT ON STACKXXCE38 = *     TAY                    ; COPY SIGN     PLA                    ; GET RETURN ADDRESS LOW BYTE     STA     XX22          ; SAVE IT     INC     XX22          ; INCREMENT IT AS RETURN-1 IS PUSHED                         ; NOTE, NO CHECK IS MADE ON THE HIGH BYTE SO IF THE CALLING                         ; ROUTINE EVER ASSEMBLES TO A PAGE EDGE THEN THIS ALL GOES                         ; HORRIBLY WRONG!     PLA                    ; GET RETURN ADDRESS HIGH BYTE     STA     XX23          ; SAVE IT     TYA                    ; RESTORE SIGN     PHA                    ; PUSH SIGN;***********************************************************************************;;; ROUND FAC1 AND PUT ON STACKXXCE43 = *     JSR     XXDC1B          ; ROUND FAC1     LDA     XX65          ; GET FAC1 MANTISSA 4     PHA                    ; SAVE IT     LDA   	  XX64          ; GET FAC1 MANTISSA 3     PHA                    ; SAVE IT     LDA     XX63          ; GET FAC1 MANTISSA 2     PHA                    ; SAVE IT     LDA     XX62          ; GET FAC1 MANTISSA 1     PHA                    ; SAVE IT    
 LDA     XX61          ; GET FAC1 EXPONENT     PHA                    ; SAVE IT     JMP     (XX22)          ; RETURN, SORT OF;***********************************************************************************;;; DO FUNCTIONSXXCE58 = *     LDY     #$FF               ; FLAG FUNCTION     PLA                    ; PULL PRECEDENCE BYTEXXCE5B = *     BEQ     XXCE80          ; EXIT IF DONEXXCE5D = *     CMP     #$64               ; COMPARE PREVIOUS PRECEDENCE WITH $64     BEQ     XXCE64          ; IF WAS $64 (< FUNCTION) SKIP THE TYPE CHECK     JSR     XXCD8D          ; CHECK IF SOURCE IS NUMERIC, ELSE DO TYPE MISMATCHXXCE64 = *     STY     XX4B          ; SAVE PRECEDENCE STACKED FLAG                         ; POP FAC2 AND RETURNXXCE66 = *     PLA                    ; POP BYTE     LSR A                  ; SHIFT OUT COMPARISON EVALUATION LOWEST BIT     STA     XX12          ; SAVE THE COMPARISON EVALUATION FLAG     PLA                    ; POP EXPONENT     STA     XX69          ; SAVE FAC2 EXPONENT     PLA                    ; POP MANTISSA 1     STA     XX6A          ; SAVE FAC2 MANTISSA 1     PLA                    ; POP MANTISSA 2     STA     XX6B          ; SAVE FAC2 MANTISSA 2     PLA                    ; POP MANTISSA 3     STA     XX6C          ; SAVE FAC2 MANTISSA 3     PLA                    ; POP MANTISSA 4     STA     XX6D          ; SAVE FAC2 MANTISSA 4     PLA                    ; POP SIGN     STA     XX6E          ; SAVE FAC2 SIGN (B7)     EOR     XX66          ; EOR FAC1 SIGN (B7)     STA     XX6F          ; SAVE SIGN COMPARE (FAC1 EOR FAC2)XXCE80 = *     LDA     XX61          ; GET FAC1 EXPONENT     RTS;***********************************************************************************;;; GET VALUE FROM LINEXXCE83 = *     JMP     (XX030A)          ; GET ARITHMETIC ELEMENT;***********************************************************************************;;; GET ARITHMETIC ELEMENT, THE GET ARITHMETIC ELEMENT VECTOR IS INITIALISED TO POINT HEREXXCE86 = *     LDA     #$00               ; CLEAR BYTE     STA     XX0D          ; CLEAR DATA TYPE FLAG, $FF = STRING, $00 = NUMERICXXCE8A = *     JSR     XX0073          ; INCREMENT AND SCAN MEMORY     BCS     XXCE92          ; IF NOT NUMERIC CHARACTER CONTINUE; ELSE NUMERIC STRING FOUND (E.G. 123)XXCE8F = *     JMP     XXDCF3          ; GET FAC1 FROM STRING AND RETURN; GET VALUE FROM LINE .. CONTINUED, WASN'T A NUMBER SO ...XXCE92 = *     JSR     XXD113          ; CHECK BYTE, RETURN CB = 0 IF<'A' OR >'Z'     BCC     XXCE9A          ; IF NOT VARIABLE NAME CONTINUE     JMP     XXCF28          ; VARIABLE NAME SET-UP AND RETURN; GET VALUE FROM LINE .. CONTINUED, WASN'T A VARIABLE NAME SO ...XXCE9A = *     CMP     #TPI          ; COMPARE WITH TOKEN FOR PI     BNE     XXCEAD          ; IF NOT PI CONTINUE; ELSE RETURN PI IN FAC1     LDA     #<XXCEA8          ; GET PI POINTER LOW BYTE     LDY     #>XXCEA8          ; GET PI POINTER HIGH BYTE     JSR     XXDBA2          ; UNPACK MEMORY (AY) INTO FAC1     JMP     XX0073          ; INCREMENT AND SCAN MEMORY AND RETURN;***********************************************************************************;;; PI AS FLOATING NUMBERXXCEA8 = *     .BYTE     $82,$49,$0F,$DA,$A1                         ; 3.141592653;***********************************************************************************;;; GET VALUE FROM LINE .. CONTINUED, WASN'T PI SO ...XXCEAD = *     CMP     #'.'               ; COMPARE WITH '.'     BEQ     XXCE8F          ; IF SO GET FAC1 FROM STRING AND RETURN, E.G. WAS .123                         ; WASN'T .123 SO ...     CMP     #TMINUS          ; COMPARE WITH TOKEN FOR -     BEQ     XXCF0D          ; IF - TOKEN, DO SET-UP FOR FUNCTIONS                         ; WASN'T -123 SO ...     CMP     #TPLUS          ; COMPARE WITH TOKEN FOR +     BEQ     XXCE8A          ; IF + TOKEN IGNORE THE LEADING +, +1 = 1                         ; IT WASN'T ANY SORT OF NUMBER SO ...     CMP     #$22               ; COMPARE WITH '     BNE     XXCECC          ; IF NOT OPEN QUOTE CONTINUE                         ; WAS OPEN QUOTE SO GET THE ENCLOSED STRING; PRINT '...' STRING TO STRING UTILITY AREAXXCEBD = *     LDA     XX7A          ; GET BASIC EXECUTE POINTER LOW BYTE     LDY     XX7B          ; GET BASIC EXECUTE POINTER HIGH BYTE     ADC     #$00               ; ADD CARRY TO LOW BYTE     BCC     XXCEC6          ; BRANCH IF NO OVERFLOW     INY                    ; INCREMENT HIGH BYTEXXCEC6 = *     JSR     XXD487          ; PRINT ' TERMINATED STRING TO UTILITY POINTER     JMP     XXD7E2          ; RESTORE BASIC EXECUTE POINTER FROM TEMP AND RETURN; GET VALUE FROM LINE .. CONTINUED, WASN'T A STRING SO ...XXCECC = *     CMP     #TNOT          ; COMPARE WITH TOKEN FOR NOT     BNE     XXCEE3          ; IF NOT TOKEN FOR NOT CONTINUE; WAS NOT TOKEN     LDY     #$18               ; OFFSET TO NOT FUNCTION     BNE     XXCF0F          ; DO SET-UP FOR FUNCTION THEN EXECUTE, BRANCH ALWAYS; DO = COMPAREXXCED4 = *     JSR     XXD1BF          ; EVALUATE INTEGER EXPRESSION, NO SIGN CHECK     LDA     XX65          ; GET FAC1 MANTISSA 4     EOR     #$FF               ; INVERT IT     TAY                    ; COPY IT     LDA     XX64          ; GET FAC1 MANTISSA 3     EOR     #$FF               ; INVERT IT     JMP     XXD391          ; CONVERT FIXED INTEGER AY TO FLOAT FAC1 AND RETURN; GET VALUE FROM LINE .. CONTINUED, WASN'T NOT SO ...XXCEE3 = *     CMP     #TFN          ;  COMPARE WITH TOKEN FOR FN     BNE     XXCEEA          ; IF NOT TOKEN FOR FN CONTINUE     JMP     XXD3F4          ; ELSE GO EVALUATE FNX; GET VALUE FROM LINE .. CONTINUED, WASN'T FN SO ...XXCEEA = *     CMP     #TSGN          ; COMPARE WITH TOKEN !FOR SGN     BCC     XXCEF1          ; IF LESS THAN SGN TOKEN GO EVALUATE EXPRESSION IN ()                         ; ELSE WAS A FUNCTION TOKEN     JMP     XXCFA7          ; GO SET UP FUNCTION REFERENCES, BRANCH ALWAYS;******************************"*****************************************************;;; GET VALUE FROM LINE .. CONTINUED; IF HERE IT CAN ONLY BE SOMETHING IN BRACKETS SO ....; EVALUATE EXPRESSION WITHIN PARENTHESESXXCEF1 = *     JSR     XXCEFA          ; SCAN FOR '(', ELSE DO #SYNTAX ERROR THEN WARM START     JSR     XXCD9E          ; EVALUATE EXPRESSION;***********************************************************************************;;; ALL THE 'SCAN FOR' ROUTINES RETURN THE CHARACTER AFTER THE SOUGHT CHARACTER; SCA$N FOR ')', ELSE DO SYNTAX ERROR THEN WARM STARTXXCEF7 = *     LDA     #$29               ; LOAD A WITH ')'     .BYTE     $2C               ; MAKES NEXT LINE BIT XX28A9; SCAN FOR '(', ELSE DO SYNTAX ERROR THEN WARM STARTXXCEFA = *     LDA     #$2%8               ; LOAD A WITH '('     .BYTE     $2C               ; MAKES NEXT LINE BIT XX2CA9; SCAN FOR ',', ELSE DO SYNTAX ERROR THEN WARM STARTXXCEFD = *     LDA     #','               ; LOAD A WITH ','; SCAN FOR CHR$(A), ELSE DO SYNTAX ERROR &THEN WARM STARTXXCEFF = *     LDY     #$00               ; CLEAR INDEX     CMP     (XX7A),Y          ; COMPARE WITH BASIC BYTE     BNE     XXCF08          ; IF NOT EXPECTED BYTE DO SYNTAX ERROR THEN WARM START     JMP     XX0073          ; ELSE IN'CREMENT AND SCAN MEMORY AND RETURN;***********************************************************************************;;; SYNTAX ERROR THEN WARM STARTXXCF08 = *     LDX     #$0B               ; ERROR CODE $0B, SYNTAX ERROR     JMP     XXC437           ; DO ERROR #X THEN WARM STARTXXCF0D = *     LDY     #$15               ; SET OFFSET FROM BASE TO > OPERATORXXCF0F = *     PLA                    ; DUMP RETURN ADDRESS LOW BYTE     PLA                    ; DUMP RETURN ADDRESS HIGH BYTE     JM     LDA     XX43          ; GET READ POINTER LOW BYTE     LDY     XX44          ; GET READ POINTER HIGH BYTE     LDX     XX11          ; GET INPUT MODE FLAG, $00 = INPUT, $40 = GET, $98 = READ     BPL     XXCCEA          ; IF INPUT OR GET GO EXIT OR IGNORE EXTRA INPUT     JMP     XXC827          ; ELSE SET DATA POINTER AND EXITXXCCEA = *     LDY     #$00               ; CLEAR INDEX     LDA     (XX43),Y          ; GET READ BYTE     BEQ     XXCCFB          ; EXIT IF [EOL]     LDA     XX13          ; GET CURRENT I/O CHANNEL     BNE     XXCCFB          ; EXIT IF NOT DEFAULT CHANNEL     LDA     #<XXCCFC          ; SET '?EXTRA IGNORED' POINTER LOW BYTE     LDY     #>XXCCFC          ; SET '?EXTRA IGNORED' POINTER HIGH BYTE     JMP     XXCB1E          ; PRINT NULL TERMINATED STRINGXXCCFB = *     RTS;***********************************************************************************;;; INPUT ERROR MESSAGESXXCCFC = *     .BYTE     '?EXTRA IGNORED',$0D,$00XXCD0C = *     .BYTE     '?REDO FROM START',$0D,$00;***********************************************************************************;;; PERFORM NEXTXXCD1E = *     BNE     XXCD24          ; IF NEXT VARIABLE GO FIND THE VARIABLE     LDY     #$00               ; ELSE CLEAR Y     BEQ     XXCD27          ; USE ANY VARIABLE, BRANCH ALWAYS; NEXT VARIABLEXXCD24 = *     JSR     XXD08B          ; GET VARIABLE ADDRESSXXCD27 = *     STA     XX49          ; SAVE FOR/NEXT VARIABLE POINTER LOW BYTE     STY     XX4A          ; SAVE FOR/NEXT VARIABLE POINTER HIGH BYTE                         ; (HIGH BYTE CLEARED IF NO VARIABLE DEFINED)     JSR     XXC38A          ; SEARCH THE STACK FOR FOR OR GOSUB ACTIVITY     BEQ     XXCD35          ; IF FOR FOUND CONTINUE     LDX     #$0A               ; ELSE SET ERROR $0A, NEXT WITHOUT FOR ERRORXXCD32 = *     JMP     XXC437          ; DO ERROR #X THEN WARM START; FOUND THIS FOR VARIABLEXXCD35 = *     TXS                    ; UPDATE STACK POINTER     TXA                 	   ; COPY STACK POINTER     CLC                    ; CLEAR CARRY FOR ADD     ADC     #$04               ; POINT TO STEP VALUE     PHA                    ; SAVE IT     ADC     #$06               ; POINT TO TO VALUE     STA     XX24          ; SAVE PO
INTER TO TO VARIABLE FOR COMPARE     PLA                    ; RESTORE POINTER TO STEP VALUE     LDY     #$01               ; POINT TO STACK PAGE     JSR     XXDBA2          ; UNPACK MEMORY (AY) INTO FAC1     TSX                    ; GET STACK POINTER BACK     LDA     XX0100+9,X     ; GET STEP SIGN     STA     XX66          ; SAVE FAC1 SIGN (B7)     LDA     XX49          ; GET FOR/NEXT VARIABLE POINTER LOW BYTE     LDY     XX4A          ; GET FOR/NEXT VARIABLE POINTER HIGH BYTE     JSR     XXD867          ; ADD FOR VARIABLE TO FAC1     JSR     XXDBD0          ; PACK FAC1 INTO FOR VARIABLE     LDY     #$01               ; POINT TO STACK PAGE     JSR     XXDC5D          ; COMPARE FAC1 WITH TO VALUE     TSX                    ; GET STACK POINTER BACK     SEC                    ; SET CARRY FOR SUBTRACT     SBC     XX0100+9,X     ; SUBTRACT STEP SIGN     BEQ     XXCD78          ; IF = LOOP COMPLETE, GO UNSTACK THE FOR                         ; LOOP BACK AND DO IT ALL AGAIN     LDA     XX0100+$0F,X     ; GET FOR LINE LOW BYTE     STA     XX39          ; SAVE CURRENT LINE NUMBER LOW BYTE     LDA     XX0100+$10,X     ; GET FOR LINE HIGH BYTE     STA     XX3A          ; SAVE CURRENT LINE NUMBER HIGH BYTE     LDA     XX0100+$12,X     ; GET BASIC EXECUTE POINTER LOW BYTE     STA     XX7A          ; SAVE BASIC EXECUTE POINTER LOW BYTE     LDA     XX0100+$11,X     ; GET BASIC EXECUTE POINTER HIGH BYTE     STA     XX7B          ; SAVE BASIC EXECUTE POINTER HIGH BYTEXXCD75 = *     JMP     XXC7AE          ; GO DO INTERPRETER INNER LOOP; NEXT LOOP COMLETEXXCD78 = *     TXA                    ; STACK COPY TO A     ADC     #$11               ; ADD $12, $11 + CARRY, TO DUMP FOR STRUCTURE     TAX                    ; COPY BACK TO INDEX     TXS                    ; COPY TO STACK POINTER     JSR     XX0079          ; SCAN MEMORY     CMP     #','               ; COMPARE WITH ','     BNE     XXCD75          ; IF NOT ',' GO DO INTERPRETER INNER LOOP                         ; WAS ',' SO ANOTHER NEXT VARIABLE TO DO     JSR     XX0073          ; INCREMENT AND SCAN MEMORY     JSR     XXCD24          ; DO NEXT VARIABLE;***********************************************************************************;;; EVALUATE EXPRESSION AND CHECK TYPE MISMATCHXXCD8A = *     JSR     XXCD9E          ; EVALUATE EXPRESSION; CHECK IF SOURCE AND DESTINATION ARE NUMERICXXCD8D = *     CLC     .BYTE     $24               ; MAKES NEXT LINE BIT XX38; CHECK IF SOURCE AND DESTINATION ARE STRINGXXCD8F = *     SEC                    ; DESTINATION IS STRING; TYPE MATCH CHECK, SET C FOR STRING, CLEAR C FOR NUMERICXXCD90 = *     BIT     XX0D          ; TEST DATA TYPE FLAG, $FF = STRING, $00 = NUMERIC     BMI     XXCD97          ; IF STRING GO CHECK STRING IS REQUIRED; TYPE FOUND IS NUMERIC, CHECK REQUIRED     BCS     XXCD99          ; IF STRING IS REQUIRED GO DO TYPE MISSMATCH ERRORXXCD96 = *     RTS; TYPE FOUND IS STRING, CHECK REQUIREDXXCD97 = *     BCS     XXCD96          ; EXIT IF STRING IS REQUIRED; DO TYPE MISSMATCH ERRORXXCD99 = *     LDX     #$16               ; ERROR CODE $16, TYPE MISSMATCH ERROR     JMP     XXC437          ; DO ERROR #X THEN WARM START;***********************************************************************************;;; EVALUATE EXPRESSIONXXCD9E = *     LDX     XX7A          ; GET BASIC EXECUTE POINTER LOW BYTE     BNE     XXCDA4          ; SKIP NEXT IF NOT ZERO     DEC     XX7B          ; ELSE DECREMENT BASIC EXECUTE POINTER HIGH BYTEXXCDA4 = *     DEC     XX7A          ; DECREMENT BASIC EXECUTE POINTER LOW BYTE     LDX     #$00               ; SET NULL PRECEDENCE, FLAG DONE     .BYTE     $24               ; MAKES NEXT LINE BIT XX48XXCDA9 = *     PHA                    ; PUSH COMPARE EVALUATION BYTE IF BRANCH TO HERE     TXA                    ; COPY PRECEDENCE BYTE     PHA                    ; PUSH PRECEDENCE BYTE     LDA     #$01               ; 2 BYTES     JSR     XXC3FB          ; CHECK ROOM ON STACK FOR A*2 BYTES     JSR     XXCE83          ; GET VALUE FROM LINE     LDA     #$00               ; CLEAR A     STA     XX4D          ; CLEAR COMPARRISON EVALUATION FLAGXXCDB8 = *     JSR     XX0079          ; SCAN MEMORYXXCDBB = *     SEC                    ; SET CARRY FOR SUBTRACT     SBC     #TGT          ; SUBTRACT TOKEN FOR '>'     BCC     XXCDD7          ; IF < '>' SKIP COMPARRISON TEST CHECK     CMP     #$03               ; COMPARE WITH '>' TO +3     BCS     XXCDD7          ; IF >= 3 SKIP COMPARRISON TEST CHECK                         ; WAS TOKEN FOR '>' '=' OR '<'     CMP     #$01               ; COMPARE WITH TOKEN FOR =     ROL A                  ; *2, B0 = CARRY (=1 IF TOKEN WAS = OR <)     EOR     #$01               ; TOGGLE B0     EOR     XX4D          ; EOR WITH COMPARRISON EVALUATION FLAG     CMP     XX4D          ; COMPARE WITH COMPARRISON EVALUATION FLAG     BCC     XXCE30          ; IF < SAVED FLAG DO SYNTAX ERROR THEN WARM START     STA     XX4D          ; SAVE NEW COMPARRISON EVALUATION FLAG     JSR     XX0073          ; INCREMENT AND SCAN MEMORY     JMP     XXCDBB          ; GO DO NEXT CHARACTERXXCDD7 = *     LDX     XX4D          ; GET COMPARRISON EVALUATION FLAG     BNE     XXCE07          ; IF COMPARE FUNCTION FLAGGED GO EVALUATE RIGHT HAND SIDE     BCS     XXCE58          ; GO DO FUNCTIONS                         ; ELSE WAS < TGT SO IS OPERATOR OR LOWER     ADC     #$07               ; ADD # OF OPERATORS (+, -, *, /, ^, AND OR OR)     BCC     XXCE58           ; IF < + OPERATOR GO DO THE FUNCTION                         ; CARRY WAS SET SO TOKEN WAS +, -, *, /, ^, AND OR OR     ADC     XX0D          ; ADD DATA TYPE FLAG, $FF = STRING, $00 = NUMERIC     BNE     XXCDE8          ; IF NOT STRING OR NOT + TOKEN! SKIP CONCATENATE                         ; WILL ONLY BE $00 IF TYPE IS STRING AND TOKEN WAS +     JMP     XXD63D          ; ADD STRINGS, STRING 1 IS IN THE DESCRIPTOR, STRING 2                         ; IS IN LINE, AND RETURNXXCDE8 = *     ADC   "  #$FF               ; -1 (CORRECTS FOR CARRY ADD)     STA     XX22          ; SAVE IT     ASL A                  ; *2     ADC     XX22          ; *3     TAY                    ; COPY TO INDEXXXCDF0 = *     PLA                    ; PULL PREVIOUS PR#ECEDENCE     CMP     XXC080,Y          ; COMPARE WITH PRECEDENCE BYTE     BCS     XXCE5D          ; IF A >= GO DO THE FUNCTION     JSR     XXCD8D          ; CHECK IF SOURCE IS NUMERIC, ELSE DO TYPE MISMATCHXXCDF9 = *     PHA                    ; SA$VE PRECEDENCEXXCDFA = *     JSR     XXCE20          ; GET VECTOR, EXECUTE FUNCTION THEN CONTINUE EVALUATION     PLA                    ; RESTORE PRECEDENCE     LDY     XX4B          ; GET PRECEDENCE STACKED FLAG     BPL     XXCE19          ; IF STAC%KED VALUES GO CHECK THE PRECEDENCE     TAX                    ; COPY PRECEDENCE, SET FLAGS     BEQ     XXCE5B          ; EXIT IF DONE     BNE     XXCE66          ; ELSE POP FAC2 AND RETURN, BRANCH ALWAYSXXCE07 = *     LSR     XX0D          ; CLEA&R DATA TYPE FLAG, $FF = STRING, $00 = NUMERIC     TXA                    ; COPY COMPARE FUNCTION FLAG     ROL A                  ; <<1, SHIFT DATA TYPE FLAG INTO B0, 1 = STRING, 0 = NUM     LDX     XX7A          ; GET BASIC EXECUTE POINTER LOW BYTE  '   BNE     XXCE11          ; IF NO UNDERFLOW SKIP THE HIGH BYTE DECREMENT     DEC     XX7B          ; ELSE DECREMENT BASIC EXECUTE POINTER HIGH BYTEXXCE11 = *     DEC     XX7A          ; DECREMENT BASIC EXECUTE POINTER LOW BYTE     LDY     #XXC09B-X XC080                         ; SET OFFSET TO = OPERATOR PRECEDENCE ENTRY     STA     XX4D          ; SAVE NEW COMPARRISON EVALUATION FLAG     BNE     XXCDF0          ; BRANCH ALWAYSXXCE19 = *     CMP     XXC080,Y          ; COMPARE WITH STACKED FUA5 = *     JSR     XXD79E          ; GET BYTE PARAMETER     LDA     #','               ; SET ','     JSR     XXCEFF          ; SCAN FOR CHR$(A), ELSE DO SYNTAX ERROR THEN WARM START     STX     XX13          ; SET CURRENT I/O CHANNEL     JSR     XXE11B          ; OPEN CHANNEL FOR INPUT WITH ERROR CHECK     JSR     XXCBCE          ; PERFORM INPUT WITH NO PROMPT STRING; CLOSE INPUT AND OUTPUT CHANNELSXXCBB5 = *     LDA     XX13          ; GET CURRENT I/O CHANNELXXCBB7 = *     JSR     XXFFCC          ; CLOSE INPUT AND OUTPUT CHANNELS     LDX     #$00               ; CLEAR X     STX     XX13          ; CLEAR CURRENT I/O CHANNEL, FLAG DEFAULT     RTS;***********************************************************************************;;; PERFORM INPUTXXCBBF = *     CMP     #$22               ; COMPARE NEXT BYTE WITH OPEN QUOTE     BNE     XXCBCE          ; IF NO PROMPT STRING JUST DO INPUT     JSR     XXCEBD          ; PRINT '...' STRING     LDA     #$3B               ; LOAD A WITH ';'     JSR     XXCEFF          ; SCAN FOR CHR$(A), ELSE DO SYNTAX ERROR THEN WARM START     JSR     XXCB21          ; PRINT STRING FROM UTILITY POINTER                         ; DONE WITH PROMPT, NOW GET DATAXXCBCE = *     JSR     XXD3A6          ; CHECK NOT DIRECT, BACK HERE IF OK     LDA     #','               ; SET ','     STA     XX0200-1          ; SAVE TO START OF BUFFER - 1XXCBD6 = *     JSR     XXCBF9          ; PRINT '? ' AND GET BASIC INPUT     LDA     XX13          ; GET CURRENT I/O CHANNEL     BEQ     XXCBEA          ; BRANCH IF DEFAULT I/O CHANNEL     JSR     XXFFB7          ; READ I/O STATUS WORD     AND     #$02               ; MASK NO DSR/TIMEOUT     BEQ     XXCBEA          ; BRANCH IF NOT ERROR     JSR     XXCBB5          ; CLOSE INPUT AND OUTPUT CHANNELS     JMP     XXC8F8          ; PERFORM DATAXXCBEA = *     LDA     XX0200          ; GET FIRST BYTE IN INPUT BUFFER     BNE     XXCC0D          ; BRANCH IF NOT NULL                         ; ELSE ..     LDA	     XX13          ; GET CURRENT I/O CHANNEL     BNE     XXCBD6          ; IF NOT DEFAULT CHANNEL GO GET BASIC INPUT     JSR     XXC906          ; SCAN FOR NEXT BASIC STATEMENT ([:] OR [EOL])     JMP     XXC8FB          ; ADD Y TO THE BASIC EXECUTE P
OINTER AND RETURN;***********************************************************************************;;; PRINT '? ' AND GET BASIC INPUTXXCBF9 = *     LDA     XX13          ; GET CURRENT I/O CHANNEL     BNE     XXCC03          ; SKIP '?' PROMPT IF NOT DEFAULT CHANNEL     JSR     XXCB45          ; PRINT '?'     JSR     XXCB3B          ; PRINT [SPACE] OR [CURSOR RIGHT]XXCC03 = *     JMP     XXC560          ; CALL FOR BASIC INPUT AND RETURN;***********************************************************************************;;; PERFORM READXXCC06 = *     LDX     XX41          ; GET DATA POINTER LOW BYTE     LDY     XX42          ; GET DATA POINTER HIGH BYTE     LDA     #$98               ; SET INPUT MODE = READ     .BYTE     $2C               ; MAKES NEXT LINE BIT XX00A9XXCC0D = *     LDA     #$00               ; SET INPUT MODE = INPUT;***********************************************************************************;;; PERFORM GETXXCC0F = *     STA     XX11          ; SET INPUT MODE FLAG, $00 = INPUT, $40 = GET, $98 = READ     STX     XX43          ; SAVE READ POINTER LOW BYTE     STY     XX44          ; SAVE READ POINTER HIGH BYTE                         ; READ, GET OR INPUT NEXT VARIABLE FROM LISTXXCC15 = *     JSR     XXD08B          ; GET VARIABLE ADDRESS     STA     XX49          ; SAVE ADDRESS LOW BYTE     STY     XX4A          ; SAVE ADDRESS HIGH BYTE     LDA     XX7A          ; GET BASIC EXECUTE POINTER LOW BYTE     LDY     XX7B          ; GET BASIC EXECUTE POINTER HIGH BYTE     STA     XX4B          ; SAVE BASIC EXECUTE POINTER LOW BYTE     STY     XX4C          ; SAVE BASIC EXECUTE POINTER HIGH BYTE     LDX     XX43          ; GET READ POINTER LOW BYTE     LDY     XX44          ; GET READ POINTER HIGH BYTE     STX     XX7A          ; SAVE AS BASIC EXECUTE POINTER LOW BYTE     STY     XX7B          ; SAVE AS BASIC EXECUTE POINTER HIGH BYTE     JSR     XX0079          ; SCAN MEMORY     BNE     XXCC51          ; BRANCH IF NOT NULL                         ; POINTER WAS TO NULL ENTRY     BIT     XX11          ; TEST INPUT MODE FLAG, $00 = INPUT, $40 = GET, $98 = READ     BVC     XXCC41          ; BRANCH IF NOT GET                         ; ELSE WAS GET     JSR     XXE121          ; GET CHARACTER FROM INPUT DEVICE WITH ERROR CHECK     STA     XX0200          ; SAVE TO BUFFER     LDX     #<XX01FF          ; SET XX0200-1 POINTER LOW BYTE     LDY     #>XX01FF          ; SET XX0200-1 POINTER HIGH BYTE     BNE     XXCC4D          ; GO INTERPRET SINGLE CHARACTERXXCC41 = *     BMI     XXCCB8          ; IF READ GO GET SOME DATA; ELSE IT WAS INPUT     LDA     XX13          ; GET CURRENT I/O CHANNEL     BNE     XXCC4A          ; SKIP '?' PROMPT IF NOT DEFAULT CHANNEL     JSR     XXCB45          ; PRINT '?'XXCC4A = *     JSR     XXCBF9          ; PRINT '? ' AND GET BASIC INPUTXXCC4D = *     STX     XX7A          ; SAVE BASIC EXECUTE POINTER LOW BYTE     STY     XX7B          ; SAVE BASIC EXECUTE POINTER HIGH BYTEXXCC51 = *     JSR     XX0073          ; INCREMENT AND SCAN MEMORY, EXECUTE POINTER NOW POINTS TO                         ; START OF NEXT DATA OR NULL TERMINATOR     BIT     XX0D          ; TEST DATA TYPE FLAG, $FF = STRING, $00 = NUMERIC     BPL     XXCC89          ; BRANCH IF NUMERIC                         ; TYPE IS STRING     BIT     XX11          ; TEST INPUT MODE FLAG, $00 = INPUT, $40 = GET, $98 = READ     BVC     XXCC65          ; BRANCH IF NOT GET                         ; ELSE DO STRING GET     INX                    ; CLEAR X ??     STX     XX7A          ; SAVE BASIC EXECUTE POINTER LOW BYTE     LDA     #$00               ; CLEAR A     STA     XX07          ; CLEAR SEARCH CHARACTER     BEQ     XXCC71          ; BRANCH ALWAYS                         ; IS STRING INPUT OR STRING READXXCC65 = *     STA     XX07          ; SAVE SEARCH CHARACTER     CMP     #$22               ; COMPARE WITH '     BEQ     XXCC72          ; IF QUOTE ONLY SEARCH FOR '...' STRING                         ; ELSE THE STRING IS NOT IN QUOTES SO ':', ',' OR $00 ARE                         ; THE TERMINATION CHARACTERS     LDA     #':'               ; SET ':'     STA     XX07          ; SET SEARCH CHARACTER     LDA     #','               ; SET ','XXCC71 = *     CLC                    ; CLEAR CARRY FOR ADDXXCC72 = *     STA     XX08          ; SET SCAN QUOTES FLAG     LDA     XX7A          ; GET BASIC EXECUTE POINTER LOW BYTE     LDY     XX7B          ; GET BASIC EXECUTE POINTER HIGH BYTE     ADC     #$00               ; ADD TO POINTER LOW BYTE. THIS ADD INCREMENTS THE POINTER                         ; IF THE MODE IS INPUT OR READ AND THE DATA IS A '...'                         ; STRING     BCC     XXCC7D          ; IF NO ROLLOVER SKIP THE HIGH BYTE INCREMENT     INY                    ; ELSE INCREMENT POINTER HIGH BYTEXXCC7D = *     JSR     XXD48D          ; PRINT STRING TO UTILITY POINTER     JSR     XXD7E2          ; RESTORE BASIC EXECUTE POINTER FROM TEMP     JSR     XXC9DA          ; PERFORM STRING LET     JMP     XXCC91          ; CONTINUE PROCESSING COMMAND                         ; GET, INPUT OR READ IS NUMERICXXCC89 = *     JSR     XXDCF3          ; GET FAC1 FROM STRING     LDA     XX0E          ; GET DATA TYPE FLAG, $80 = INTEGER, $00 = FLOAT     JSR     XXC9C2          ; ASSIGN VALUE TO NUMERIC VARIABLEXXCC91 = *     JSR     XX0079          ; SCAN MEMORY     BEQ     XXCC9D          ; IF ':' OR [EOL] GO HANDLE THE STRING END     CMP     #','               ; COMPARTE W ITH ','     BEQ     XXCC9D          ; IF ',' GO HANDLE THE STRING END     JMP     XXCB4D          ; ELSE GO DO BAD INPUT ROUTINE                         ; STRING TERMINATED WITH ':', ',' OR $00XXCC9D = *     LDA     XX7A          ; GET BASIC EXECU!TE POINTER LOW BYTE     LDY     XX7B          ; GET BASIC EXECUTE POINTER HIGH BYTE     STA     XX43          ; SAVE READ POINTER LOW BYTE     STY     XX44          ; SAVE READ POINTER HIGH BYTE     LDA     XX4B          ; GET SAVED BASIC EXECUTE POI"NTER LOW BYTE     LDY     XX4C          ; GET SAVED BASIC EXECUTE POINTER HIGH BYTE     STA     XX7A          ; RESTORE BASIC EXECUTE POINTER LOW BYTE     STY     XX7B          ; RESTORE BASIC EXECUTE POINTER HIGH BYTE     JSR     XX0079          ; S#CAN MEMORY     BEQ     XXCCDF          ; BRANCH IF ':' OR [EOL]     JSR     XXCEFD          ; SCAN FOR ',', ELSE DO SYNTAX ERROR THEN WARM START     JMP     XXCC15          ; GO READ OR INPUT NEXT VARIABLE FROM LIST                         ; WAS RE$ADXXCCB8 = *     JSR     XXC906          ; SCAN FOR NEXT BASIC STATEMENT ([:] OR [EOL])     INY                    ; INCREMENT INDEX TO NEXT BYTE     TAX                    ; COPY BYTE TO X     BNE     XXCCD1          ; IF ':' GO LOOK FOR THE NEXT D%ATA     LDX     #$0D               ; ELSE SET ERROR $0D, OUT OF DATA ERROR     INY                    ; INCREMENT INDEX TO NEXT LINE POINTER HIGH BYTE     LDA     (XX7A),Y          ; GET NEXT LINE POINTER HIGH BYTE     BEQ     XXCD32          ; IF P&ROGRAM END GO DO ERROR, EVENTUALLY DOES ERROR X     INY                    ; INCREMENT INDEX     LDA     (XX7A),Y          ; GET NEXT LINE # LOW BYTE     STA     XX3F          ; SAVE CURRENT DATA LINE LOW BYTE     INY                    ; INCREMENT 'INDEX     LDA     (XX7A),Y          ; GET NEXT LINE # HIGH BYTE     INY                    ; INCREMENT INDEX     STA     XX40          ; SAVE CURRENT DATA LINE HIGH BYTEXXCCD1 = *     JSR     XXC8FB          ; ADD Y TO THE BASIC EXECUTE POINTER      JSR     XX0079          ; SCAN MEMORY     TAX                    ; COPY BYTE     CPX     #TDATA          ; COMPARE WITH TOKEN FOR DATA     BNE     XXCCB8          ; LOOP IF NOT DATA     JMP     XXCC51          ; CONTINUE EVALUATING READXXCCDF = *TARTXXCA90 = *     PHP                    ; SAVE STATUS     STX     XX13          ; SET CURRENT I/O CHANNEL     JSR     XXE115          ; OPEN CHANNEL FOR OUTPUT WITH ERROR CHECK     PLP                    ; RESTORE STATUS     JMP     XXCAA0          ; PERFORM PRINT;***********************************************************************************;;; PRINT STRING, SCAN MEMORY AND CONTINUE PRINTXXCA9A = *     JSR     XXCB21          ; PRINT STRING FROM UTILITY POINTER; SCAN MEMORY AND CONTINUE PRINTXXCA9D = *     JSR     XX0079          ; SCAN MEMORY;***********************************************************************************;;; PERFORM PRINTXXCAA0 = *     BEQ     XXCAD7          ; IF NOTHING FOLLOWING JUST PRINT CR/LFXXCAA2 = *     BEQ     XXCAE7          ; IF NOTHING FOLLOWING EXIT, END OF PRINT BRANCH     CMP     #TTAB          ; COMPARE WITH TOKEN FOR TAB(     BEQ     XXCAF8          ; IF TAB( GO HANDLE IT     CMP     #TSPC          ; COMPARE WITH TOKEN FOR SPC(     CLC                    ; FLAG SPC(     BEQ     XXCAF8          ; IF SPC( GO HANDLE IT     CMP     #','               ; COMPARE WITH ','     BEQ     XXCAE8          ; IF ',' GO SKIP TO THE NEXT TAB POSITION     CMP     #$3B               ; COMPARE WITH ';'     BEQ     XXCB13          ; IF ';' GO CONTINUE THE PRINT LOOP     JSR     XXCD9E          ; EVALUATE EXPRESSION     BIT     XX0D          ; TEST DATA TYPE FLAG, $FF = STRING, $00 = NUMERIC     BMI     XXCA9A          ; IF STRING GO PRINT STRING, SCAN MEMORY AND CONTINUE PRINT     JSR     XXDDDD          ; CONVERT FAC1 TO ASCII STRING RESULT IN (AY)     JSR     XXD487          ; PRINT ' TERMINATED STRING TO UTILITY POINTER     JSR     XXCB21          ; PRINT STRING FROM UTILITY POINTER     JSR     XXCB3B          ; PRINT [SPACE] OR [CURSOR RIGHT]     BNE     XXCA9D          ; GO SCAN MEMORY AND CONTINUE PRINT, BRANCH ALWAYS;***********************************************************************************;;; SET XY	 TO XX0200 - 1 AND PRINT [CR]XXCACA = *     LDA     #$00               ; CLEAR A     STA     XX0200,X          ; CLEAR FIRST BYTE OF INPUT BUFFER     LDX     #<XX01FF          ; XX0200 - 1 LOW BYTE     LDY     #>XX01FF          ; XX0200 - 1 HIGH BY
TE     LDA     XX13          ; GET CURRENT I/O CHANNEL     BNE     XXCAE7          ; EXIT IF NOT DEFAULT CHANNEL;***********************************************************************************;;; PRINT CR/LFXXCAD7 = *     LDA     #$0D               ; SET [CR]     JSR     XXCB47          ; PRINT THE CHARACTER     BIT     XX13          ; TEST CURRENT I/O CHANNEL     BPL     XXCAE5          ; IF THE AUTOLF BIT IS NOT SET SKIP THE LF; IT WOULD SEEM FROM OTHER PARTS OF THE CODE THAT USING B7 AS AN AUTOLF FLAG BIT IS; NO LONGER SUPPORTED AND SETTING THIS BIT WOULD BREAK THINGS IN A LOT OF PLACES     LDA     #$0A               ; SET [LF]     JSR     XXCB47          ; PRINT THE CHARACTER;***********************************************************************************;;; TOGGLE AXXCAE5 = *     EOR     #$FF               ; INVERT AXXCAE7 = *     RTS;***********************************************************************************;;; CONTINUING PRINT, THE CHARACTER WAS ','XXCAE8 = *     SEC                    ; SET CB FOR READ CURSOR POSITION     JSR     XXFFF0          ; READ/SET X,Y CURSOR POSITION     TYA                    ; COPY CURSOR Y     SEC                    ; SET CARRY FOR SUBTRACTXXCAEE = *     SBC     #$0B               ; SUBTRACT ONE TAB LENGTH     BCS     XXCAEE          ; LOOP IF RESULT WAS +VE     EOR     #$FF               ; COMPLEMENT IT     ADC     #$01               ; +1, TWOS COMPLEMENT     BNE     XXCB0E          ; PRINT A SPACES, BRANCH ALWAYS, RESULT IS NEVER $00;***********************************************************************************;;; HANDLE TAB( OR SPC(XXCAF8 = *     PHP                    ; SAVE TAB( OR SPC( STATUS     SEC                    ; SET CB FOR READ CURSOR POSITION     JSR     XXFFF0          ; READ/SET X,Y CURSOR POSITION     STY     XX09          ; SAVE CURRENT CURSOR POSITION     JSR     XXD79B          ; SCAN AND GET BYTE PARAMETER     CMP     #$29               ; COMPARE WITH ')'     BNE     XXCB5F          ; IF NOT ')' DO SYNTAX ERROR     PLP                    ; RESTORE TAB( OR SPC( STATUS     BCC     XXCB0F          ; BRANCH IF WAS SPC(                         ; ELSE WAS TAB(     TXA                    ; COPY TAB() BYTE TO A     SBC     XX09          ; SUBTRACT CURRENT CURSOR POSITION     BCC     XXCB13          ; GO LOOP FOR NEXT IF ALREADY PAST REQUITED POSITIONXXCB0E = *     TAX                    ; COPY [SPACE] COUNT TO XXXCB0F = *     INX                    ; INCREMENT COUNTXXCB10 = *     DEX                    ; DECREMENT COUNT     BNE     XXCB19          ; BRANCH IF COUNT WAS NOT ZERO                         ; WAS ';' OR [SPACES] PRINTEDXXCB13 = *     JSR     XX0073          ; INCREMENT AND SCAN MEMORY     JMP     XXCAA2          ; CONTINUE PRINT LOOPXXCB19 = *     JSR     XXCB3B          ; PRINT [SPACE] OR [CURSOR RIGHT]     BNE     XXCB10          ; LOOP, BRANCH ALWAYS;***********************************************************************************;;; PRINT NULL TERMINATED STRINGXXCB1E = *     JSR     XXD487          ; PRINT ' TERMINATED STRING TO UTILITY POINTER; PRINT STRING FROM UTILITY POINTERXXCB21 = *     JSR     XXD6A6          ; POP STRING OFF DESCRIPTOR STACK, OR FROM TOP OF STRING                         ; SPACE RETURNS WITH A = LENGTH, X = POINTER LOW BYTE,                         ; Y = POINTER HIGH BYTE     TAX                    ; COPY LENGTH     LDY     #$00               ; CLEAR INDEX     INX                    ; INCREMENT LENGTH, FOR PRE DECREMENT LOOPXXCB28 = *     DEX                    ; DECREMENT LENGTH     BEQ     XXCAE7          ; EXIT IF DONE     LDA     (XX22),Y          ; GET BYTE FROM STRING     JSR     XXCB47          ; PRINT THE CHARACTER     INY                    ; INCREMENT INDEX     CMP     #$0D               ; COMPARE BYTE WITH [CR]     BNE     XXCB28          ; LOOP IF NOT [CR]     JSR     XXCAE5          ; TOGGLE A, EOR #$FF. WHAT IS THE POINT OF THIS ??     JMP     XXCB28          ; LOOP;***********************************************************************************;;; PRINT [SPACE] OR [CURSOR RIGHT]XXCB3B = *     LDA     XX13          ; GET CURRENT I/O CHANNEL     BEQ     XXCB42          ; IF DEFAULT CHANNEL GO OUTPUT [CURSOR RIGHT]     LDA     #' '               ; ELSE OUTPUT [SPACE]     .BYTE     $2C               ; MAKES NEXT LINE BIT XX1DA9XXCB42 = *     LDA     #$1D               ; SET [CURSOR RIGHT]     .BYTE     $2C               ; MAKES NEXT LINE BIT XX3FA9;***********************************************************************************;;; PRINT '?'XXCB45 = *     LDA     #'?'               ; SET '?';***********************************************************************************;;; PRINT A CHARACTERXXCB47 = *     JSR     XXE109          ; OUTPUT CHARACTER TO CHANNEL WITH ERROR CHECK     AND     #$FF               ; SET THE FLAGS ON A     RTS;***********************************************************************************;;; BAD INPUT ROUTINEXXCB4D = *     LDA     XX11          ; GET INPUT MODE FLAG, $00 = INPUT, $40 = GET, $98 = READ     BEQ     XXCB62          ; BRANCH IF INPUT     BMI     XXCB57          ; BRANCH IF READ                         ; ELSE WAS GET     LDY     #$FF               ; SET CURRENT LINE HIGH BYTE TO -1, INDICATE IMMEDIATE MODE     BNE     XXCB5B          ; BRANCH ALWAYSXXCB57 = *     LDA     XX3F          ; GET CURRENT DATA LINE NUMBER LOW BYTE     LDY     XX40           ; GET CURRENT DATA LINE NUMBER HIGH BYTEXXCB5B = *     STA     XX39          ; SET CURRENT LINE NUMBER LOW BYTE     STY     XX3A          ; SET CURRENT LINE NUMBER HIGH BYTEXXCB5F = *     JMP     XXCF08          ; DO SYNTAX ERROR THEN WARM START !                        ; WAS INPUTXXCB62 = *     LDA     XX13          ; GET CURRENT I/O CHANNEL     BEQ     XXCB6B          ; IF DEFAULT CHANNEL GO DO '?REDO FROM START' MESSAGE     LDX     #$18               ; ELSE ERROR $18, FILE DATA ERROR    " JMP     XXC437          ; DO ERROR #X THEN WARM STARTXXCB6B = *     LDA     #<XXCD0C          ; SET '?REDO FROM START' POINTER LOW BYTE     LDY     #>XXCD0C          ; SET '?REDO FROM START' POINTER HIGH BYTE     JSR     XXCB1E          ; PRINT NUL#L TERMINATED STRING     LDA     XX3D          ; GET CONTINUE POINTER LOW BYTE     LDY     XX3E          ; GET CONTINUE POINTER HIGH BYTE     STA     XX7A          ; SAVE BASIC EXECUTE POINTER LOW BYTE     STY     XX7B          ; SAVE BASIC EXECUTE PO$INTER HIGH BYTE     RTS;***********************************************************************************;;; PERFORM GETXXCB7B = *     JSR     XXD3A6          ; CHECK NOT DIRECT, BACK HERE IF OK     CMP     #'#'               ; COMPARE WITH '%#'     BNE     XXCB92          ; BRANCH IF NOT GET#     JSR     XX0073          ; INCREMENT AND SCAN MEMORY     JSR     XXD79E          ; GET BYTE PARAMETER     LDA     #','               ; SET ','     JSR     XXCEFF          ; SCAN FOR CHR$(A), EL&SE DO SYNTAX ERROR THEN WARM START     STX     XX13          ; SET CURRENT I/O CHANNEL     JSR     XXE11B          ; OPEN CHANNEL FOR INPUT WITH ERROR CHECKXXCB92 = *     LDX     #<XX0201          ; SET XX0200+1 POINTER LOW BYTE     LDY     #>XX0201'          ; SET XX0200+1 POINTER HIGH BYTE     LDA     #$00               ; CLEAR A     STA     XX0200+1          ; ENSURE NULL TERMINATOR     LDA     #$40               ; INPUT MODE = GET     JSR     XXCC0F          ; PERFORM GET PART OF READ     L DX     XX13          ; GET CURRENT I/O CHANNEL     BNE     XXCBB7          ; IF NOT DEFAULT CHANNEL GO DO CHANNEL CLOSE AND RETURN     RTS;***********************************************************************************;;; PERFORM INPUT#XXCBC     #$2F               ; SUBTRACT $30, $2F+CARRY, FROM BYTE     STA     XX07          ; STORE #     LDA     XX15          ; GET TEMPORARY INTEGER HIGH BYTE     STA     XX22          ; SAVE IT FOR NOW     CMP     #$19               ; COMPARE WITH $19     BCS     XXC953          ; BRANCH IF >= THIS MAKES THE MAXIMUM LINE NUMBER 63999                         ; BECAUSE THE NEXT BIT DOES $1900 * $0A = $FA00 = 64000                         ; DECIMAL. THE BRANCH TARGET IS REALLY THE SYNTAX ERROR                         ; AT XXC8E8 BUT THAT IS TOO FAR SO AN INTERMEDIATE                         ; COMPARE AND BRANCH TO THAT LOCATION IS USED. THE PROBLEM                         ; WITH THIS IS THAT LINE NUMBER THAT GIVES A PARTIAL RESULT                         ; FROM $8900 TO $89FF, 35072X TO 35327X, WILL PASS THE NEW                         ; TARGET COMPARE AND WILL TRY TO EXECUTE THE REMAINDER OF                         ; THE ON N GOTO/GOSUB. A SOLUTION TO THIS IS TO COPY THE                         ; BYTE IN A BEFORE THE BRANCH TO X AND THEN BRANCH TO                         ; XXC955 SKIPPING THE SECOND COMPARE     LDA     XX14          ; GET TEMPORARY INTEGER LOW BYTE     ASL A                  ; *2 LOW BYTE     ROL     XX22          ; *2 HIGH BYTE     ASL A                  ; *2 LOW BYTE     ROL     XX22          ; *2 HIGH BYTE (*4)     ADC     XX14          ; + LOW BYTE (*5)     STA     XX14          ; SAVE IT     LDA     XX22          ; GET HIGH BYTE TEMP     ADC     XX15          ; + HIGH BYTE (*5)     STA     XX15          ; SAVE IT     ASL     XX14          ; *2 LOW BYTE (*10D)     ROL     XX15          ; *2 HIGH BYTE (*10D)     LDA     XX14          ; GET LOW BYTE     ADC     XX07          ; ADD #     STA     XX14          ; SAVE LOW BYTE     BCC     XXC99F          ; IF NO OVERFLOW SKIP HIGH BYTE INCREMENT     INC     XX15          ; ELSE INCREMENT HIGH BYTEXXC99F = *     JSR     XX0073          ; INCREMENT AND SCAN MEMORY     JMP     XXC971          ; LOOP 	FOR NEXT CHARACTER;***********************************************************************************;;; PERFORM LETXXC9A5 = *     JSR     XXD08B          ; GET VARIABLE ADDRESS     STA     XX49          ; SAVE VARIABLE ADDRESS LOW BYTE     ST
Y     XX4A          ; SAVE VARIABLE ADDRESS HIGH BYTE     LDA     #TEQUAL          ; $B2 IS '=' TOKEN     JSR     XXCEFF          ; SCAN FOR CHR$(A), ELSE DO SYNTAX ERROR THEN WARM START     LDA     XX0E          ; GET DATA TYPE FLAG, $80 = INTEGER, $00 = FLOAT     PHA                    ; PUSH DATA TYPE FLAG     LDA     XX0D          ; GET DATA TYPE FLAG, $FF = STRING, $00 = NUMERIC     PHA                    ; PUSH DATA TYPE FLAG     JSR     XXCD9E          ; EVALUATE EXPRESSION     PLA                    ; POP DATA TYPE FLAG     ROL A                  ; STRING BIT INTO CARRY     JSR     XXCD90          ; DO TYPE MATCH CHECK     BNE     XXC9D9          ; IF STRING GO ASSIGN A STRING VALUE     PLA                    ; POP INTEGER/FLOAT DATA TYPE FLAG; ASSIGN VALUE TO NUMERIC VARIABLEXXC9C2 = *     BPL     XXC9D6          ; IF FLOAT GO ASSIGN A FLOATING VALUE                         ; EXPRESSION IS NUMERIC INTEGER     JSR     XXDC1B          ; ROUND FAC1     JSR     XXD1BF          ; EVALUATE INTEGER EXPRESSION, NO SIGN CHECK     LDY     #$00               ; CLEAR INDEX     LDA     XX64          ; GET FAC1 MANTISSA 3     STA     (XX49),Y          ; SAVE AS INTEGER VARIABLE LOW BYTE     INY                    ; INCREMENT INDEX     LDA     XX65          ; GET FAC1 MANTISSA 4     STA     (XX49),Y          ; SAVE AS INTEGER VARIABLE HIGH BYTE     RTSXXC9D6 = *     JMP     XXDBD0          ; PACK FAC1 INTO VARIABLE POINTER AND RETURN; ASSIGN VALUE TO STRING VARIABLEXXC9D9 = *     PLA                    ; DUMP INTEGER/FLOAT DATA TYPE FLAGXXC9DA = *     LDY     XX4A          ; GET VARIABLE POINTER HIGH BYTE     CPY     #>XXDF13          ; WAS IT TI$ POINTER     BNE     XXCA2C          ; BRANCH IF NOT                         ; ELSE IT'S TI$ = <EXPR$>     JSR     XXD6A6          ; POP STRING OFF DESCRIPTOR STACK, OR FROM TOP OF STRING                         ; SPACE RETURNS WITH A = LENGTH, X = POINTER LOW BYTE,                         ; Y = POINTER HIGH BYTE     CMP     #$06               ; COMPARE LENGTH WITH 6     BNE     XXCA24          ; IF LENGTH NOT 6 DO ILLEGAL QUANTITY ERROR THEN WARM START     LDY     #$00               ; CLEAR INDEX     STY     XX61          ; CLEAR FAC1 EXPONENT     STY     XX66          ; CLEAR FAC1 SIGN (B7)XXC9ED = *     STY     XX71          ; SAVE INDEX     JSR     XXCA1D          ; CHECK AND EVALUATE NUMERIC DIGIT     JSR     XXDAE2          ; MULTIPLY FAC1 BY 10     INC     XX71          ; INCREMENT INDEX     LDY     XX71          ; RESTORE INDEX     JSR     XXCA1D          ; CHECK AND EVALUATE NUMERIC DIGIT     JSR     XXDC0C          ; ROUND AND COPY FAC1 TO FAC2     TAX                    ; COPY FAC1 EXPONENT     BEQ     XXCA07          ; BRANCH IF FAC1 ZERO     INX                    ; INCREMENT INDEX, * 2     TXA                    ; COPY BACK TO A     JSR     XXDAED          ; FAC1 = (FAC1 + (FAC2 * 2)) * 2 = FAC1 * 6XXCA07 = *     LDY     XX71          ; GET INDEX     INY                    ; INCREMENT INDEX     CPY     #$06               ; COMPARE INDEX WITH 6     BNE     XXC9ED          ; LOOP IF NOT 6     JSR     XXDAE2          ; MULTIPLY FAC1 BY 10     JSR     XXDC9B          ; CONVERT FAC1 FLOATING TO FIXED     LDX     XX64          ; GET FAC1 MANTISSA 3     LDY     XX63          ; GET FAC1 MANTISSA 2     LDA     XX65          ; GET FAC1 MANTISSA 4     JMP     XXFFDB          ; SET REAL TIME CLOCK AND RETURN; CHECK AND EVALUATE NUMERIC DIGITXXCA1D = *     LDA     (XX22),Y          ; GET BYTE FROM STRING     JSR     XX80          ; CLEAR CB IF NUMERIC. THIS CALL SHOULD BE TO XX84                         ; AS THE CODE FROM XX80 FIRST COMAPRES THE BYTE WITH                         ; [SPACE] AND DOES A BASIC INCREMENT AND GET IF IT IS     BCC     XXCA27          ; BRANCH IF NUMERICXXCA24 = *     JMP     XXD248          ; DO ILLEGAL QUANTITY ERROR THEN WARM STARTXXCA27 = *     SBC     #$2F               ; SUBTRACT $2F + CARRY TO CONVERT ASCII TO BINARY     JMP     XXDD7E          ; EVALUATE NEW ASCII DIGIT AND RETURN; ASSIGN VALUE TO STRING VARIABLE, BUT NOT TI$XXCA2C = *     LDY     #$02               ; INDEX TO STRING POINTER HIGH BYTE     LDA     (XX64),Y          ; GET STRING POINTER HIGH BYTE     CMP     XX34          ; COMPARE WITH BOTTOM OF STRING SPACE HIGH BYTE     BCC     XXCA4B          ; BRANCH IF STRING POINTER HIGH BYTE IS LESS THAN BOTTOM                         ; OF STRING SPACE HIGH BYTE     BNE     XXCA3D          ; BRANCH IF STRING POINTER HIGH BYTE IS GREATER THAN                         ; BOTTOM OF STRING SPACE HIGH BYTE                         ; ELSE HIGH BYTES WERE EQUAL     DEY                    ; DECREMENT INDEX TO STRING POINTER LOW BYTE     LDA     (XX64),Y          ; GET STRING POINTER LOW BYTE     CMP     XX33          ; COMPARE WITH BOTTOM OF STRING SPACE LOW BYTE     BCC     XXCA4B          ; BRANCH IF STRING POINTER LOW BYTE IS LESS THAN BOTTOM                         ; OF STRING SPACE LOW BYTEXXCA3D = *     LDY     XX65          ; GET DESCRIPTOR POINTER HIGH BYTE     CPY     XX2E          ; COMPARE WITH START OF VARIABLES HIGH BYTE     BCC     XXCA4B          ; BRANCH IF LESS, IS ON STRING STACK     BNE     XXCA52          ; IF GREATER MAKE SPACE AND COPY STRING                         ; ELSE HIGH BYTES WERE EQUAL     LDA     XX64          ; GET DESCRIPTOR POINTER LOW BYTE     CMP     XX2D          ; COMPARE WITH START OF VARIABLES LOW BYTE     BCS     XXCA52          ; IF GREATER OR EQUAL MAKE  SPACE AND COPY STRINGXXCA4B = *     LDA     XX64          ; GET DESCRIPTOR POINTER LOW BYTE     LDY     XX65          ; GET DESCRIPTOR POINTER HIGH BYTE     JMP     XXCA68          ; GO COPY DESCRIPTOR TO VARIABLEXXCA52 = *     LDY     #$00     !          ; CLEAR INDEX     LDA     (XX64),Y          ; GET STRING LENGTH     JSR     XXD475          ; COPY DESCRIPTOR POINTER AND MAKE STRING SPACE A BYTES LONG     LDA     XX50          ; COPY OLD DESCRIPTOR POINTER LOW BYTE     LDY     XX51      "    ; COPY OLD DESCRIPTOR POINTER HIGH BYTE     STA     XX6F          ; SAVE OLD DESCRIPTOR POINTER LOW BYTE     STY     XX70          ; SAVE OLD DESCRIPTOR POINTER HIGH BYTE     JSR     XXD67A          ; COPY STRING FROM DESCRIPTOR TO UTILITY POINTER#     LDA     #<XX61          ; GET DESCRIPTOR POINTER LOW BYTE     LDY     #>XX61          ; GET DESCRIPTOR POINTER HIGH BYTEXXCA68 = *     STA     XX50          ; SAVE DESCRIPTOR POINTER LOW BYTE     STY     XX51          ; SAVE DESCRIPTOR POINTER $HIGH BYTE     JSR     XXD6DB          ; CLEAN DESCRIPTOR STACK, YA = POINTER     LDY     #$00               ; CLEAR INDEX     LDA     (XX50),Y          ; GET STRING LENGTH FROM NEW DESCRIPTOR     STA     (XX49),Y          ; COPY STRING LENGTH TO VARI%ABLE     INY                    ; INCREMENT INDEX     LDA     (XX50),Y          ; GET STRING POINTER LOW BYTE FROM NEW DESCRIPTOR     STA     (XX49),Y          ; COPY STRING POINTER LOW BYTE TO VARIABLE     INY                    ; INCREMENT INDEX  &   LDA     (XX50),Y          ; GET STRING POINTER HIGH BYTE FROM NEW DESCRIPTOR     STA     (XX49),Y          ; COPY STRING POINTER HIGH BYTE TO VARIABLE     RTS;***********************************************************************************;;'; PERFORM PRINT#XXCA80 = *     JSR     XXCA86          ; PERFORM CMD     JMP     XXCBB5          ; CLOSE INPUT AND OUTPUT CHANNELS AND RETURN;***********************************************************************************;;; PERFORM CMDXXC A86 = *     JSR     XXD79E          ; GET BYTE PARAMETER     BEQ     XXCA90          ; BRANCH IF FOLLOWING BYTE IS ':' OR [EOT]     LDA     #','               ; SET ','     JSR     XXCEFF          ; SCAN FOR CHR$(A), ELSE DO SYNTAX ERROR THEN WARM S   ; SAVE STATUS     LDA     #$00               ; NO CONTROL OR KERNAL MESSAGES     JSR     XXFF90          ; CONTROL KERNAL MESSAGES     PLP                    ; RESTORE STATUS     BNE     XXC87D          ; BRANCH IF RUN N     JMP     XXC659          ; RESET EXECUTION TO START, CLEAR VARIABLES, FLUSH STACK                         ; AND RETURNXXC87D = *     JSR     XXC660          ; GO DO 'CLEAR'     JMP     XXC897          ; GET N AND DO GOTO N;***********************************************************************************;;; PERFORM GOSUBXXC883 = *     LDA     #$03               ; NEED 6 BYTES FOR GOSUB     JSR     XXC3FB          ; CHECK ROOM ON STACK FOR 2*A BYTES     LDA     XX7B          ; GET BASIC EXECUTE POINTER HIGH BYTE     PHA                    ; SAVE IT     LDA     XX7A          ; GET BASIC EXECUTE POINTER LOW BYTE     PHA                    ; SAVE IT     LDA     XX3A          ; GET CURRENT LINE NUMBER HIGH BYTE     PHA                    ; SAVE IT     LDA     XX39          ; GET CURRENT LINE NUMBER LOW BYTE     PHA                    ; SAVE IT     LDA     #TGOSUB          ; TOKEN FOR GOSUB     PHA                    ; SAVE ITXXC897 = *     JSR     XX0079          ; SCAN MEMORY     JSR     XXC8A0          ; PERFORM GOTO     JMP     XXC7AE          ; GO DO INTERPRETER INNER LOOP;***********************************************************************************;;; PERFORM GOTOXXC8A0 = *     JSR     XXC96B          ; GET FIXED-POINT NUMBER INTO TEMPORARY INTEGER     JSR     XXC909          ; SCAN FOR NEXT BASIC LINE     SEC                    ; SET CARRY FOR SUBTRACT     LDA     XX39          ; GET CURRENT LINE NUMBER LOW BYTE     SBC     XX14          ; SUBTRACT TEMPORARY INTEGER LOW BYTE     LDA     XX3A          ; GET CURRENT LINE NUMBER HIGH BYTE     SBC     XX15          ; SUBTRACT TEMPORARY INTEGER HIGH BYTE     BCS     XXC8BC          ; IF CURRENT LINE NUMBER >= TEMPORARY INTEGER, GO SEARCH                         ; FROM THE S	TART OF MEMORY     TYA                    ; ELSE COPY LINE INDEX TO A     SEC                    ; SET CARRY (+1)     ADC     XX7A          ; ADD BASIC EXECUTE POINTER LOW BYTE     LDX     XX7B          ; GET BASIC EXECUTE POINTER HIGH BYTE     BCC
     XXC8C0          ; IF NO OVERFLOW SKIP THE HIGH BYTE INCREMENT     INX                    ; INCREMENT HIGH BYTE     BCS     XXC8C0          ; GO FIND THE LINE, BRANCH ALWAYS;***********************************************************************************;;; SEARCH FOR LINE NUMBER IN TEMPORARY INTEGER FROM START OF MEMORY POINTERXXC8BC = *     LDA     XX2B          ; GET START OF MEMORY LOW BYTE     LDX     XX2C          ; GET START OF MEMORY HIGH BYTE; SEARCH FOR LINE # IN TEMPORARY INTEGER FROM (AX)XXC8C0 = *     JSR     XXC617          ; SEARCH BASIC FOR TEMP INTEGER LINE NUMBER FROM AX     BCC     XXC8E3          ; IF CARRY CLEAR GO DO UNSDEFINED STATEMENT ERROR                         ; CARRY ALL READY SET FOR SUBTRACT     LDA     XX5F          ; GET POINTER LOW BYTE     SBC     #$01               ; -1     STA     XX7A          ; SAVE BASIC EXECUTE POINTER LOW BYTE     LDA     XX60          ; GET POINTER HIGH BYTE     SBC     #$00               ; SUBTRACT CARRY     STA     XX7B          ; SAVE BASIC EXECUTE POINTER HIGH BYTEXXC8D1 = *     RTS;***********************************************************************************;;; PERFORM RETURNXXC8D2 = *     BNE     XXC8D1          ; EXIT IF FOLLOWING TOKEN TO ALLOW SYNTAX ERROR     LDA     #$FF               ; SET BYTE SO NO MATCH POSSIBLE     STA     XX4A          ; SAVE FOR/NEXT VARIABLE POINTER HIGH BYTE     JSR     XXC38A          ; SEARCH THE STACK FOR FOR OR GOSUB ACTIVITY,                         ; GET TOKEN OFF STACK     TXS                    ; CORRECT THE STACK     CMP     #TGOSUB          ; COMPARE WITH GOSUB TOKEN     BEQ     XXC8EB          ; IF MATCHING GOSUB GO CONTINUE RETURN     LDX     #$0C               ; ELSE ERROR CODE $04, RETURN WITHOUT GOSUB ERROR     .BYTE     $2C               ; MAKES NEXT LINE BIT XX11A2XXC8E3 = *     LDX     #$11               ; ERROR CODE $11, UNDEFINED STATEMENT ERROR     JMP     XXC437          ; DO ERROR #X THEN WARM STARTXXC8E8 = *     JMP     XXCF08          ; DO SYNTAX ERROR THEN WARM START                         ; WAS MATCHING GOSUB TOKENXXC8EB = *     PLA                    ; DUMP TOKEN BYTE     PLA                    ; PULL RETURN LINE LOW BYTE     STA     XX39          ; SAVE CURRENT LINE NUMBER LOW BYTE     PLA                    ; PULL RETURN LINE HIGH BYTE     STA     XX3A          ; SAVE CURRENT LINE NUMBER HIGH BYTE     PLA                    ; PULL RETURN ADDRESS LOW BYTE     STA     XX7A          ; SAVE BASIC EXECUTE POINTER LOW BYTE     PLA                    ; PULL RETURN ADDRESS HIGH BYTE     STA     XX7B          ; SAVE BASIC EXECUTE POINTER HIGH BYTE;***********************************************************************************;;; PERFORM DATAXXC8F8 = *     JSR     XXC906          ; SCAN FOR NEXT BASIC STATEMENT ([:] OR [EOL]); ADD Y TO THE BASIC EXECUTE POINTERXXC8FB = *     TYA                    ; COPY INDEX TO A     CLC                    ; CLEAR CARRY FOR ADD     ADC     XX7A          ; ADD BASIC EXECUTE POINTER LOW BYTE     STA     XX7A          ; SAVE BASIC EXECUTE POINTER LOW BYTE     BCC     XXC905          ; SKIP INCREMENT IF NO CARRY     INC     XX7B          ; ELSE INCREMENT BASIC EXECUTE POINTER HIGH BYTEXXC905 = *     RTS;***********************************************************************************;;; SCAN FOR NEXT BASIC STATEMENT ([:] OR [EOL]); RETURNS Y AS INDEX TO [:] OR [EOL]XXC906 = *     LDX     #':'               ; SET LOOK FOR CHARACTER = ':'     .BYTE     $2C               ; MAKES NEXT LINE BIT XX00A2; SCAN FOR NEXT BASIC LINE; RETURNS Y AS INDEX TO [EOL]XXC909 = *     LDX     #$00               ; SET ALTERNATE SEARCH CHARACTER = [EOL]     STX     XX07          ; STORE ALTERNATE SEARCH CHARACTER     LDY     #$00               ; SET SEARCH CHARACTER = [EOL]     STY     XX08          ; SAVE THE SEARCH CHARACTERXXC911 = *     LDA     XX08          ; GET SEARCH CHARACTER     LDX     XX07          ; GET ALTERNATE SEARCH CHARACTER     STA     XX07          ; MAKE SEARCH CHARACTER = ALTERNATE SEARCH CHARACTER     STX     XX08          ; MAKE ALTERNATE SEARCH CHARACTER = SEARCH CHARACTERXXC919 = *     LDA     (XX7A),Y          ; GET BASIC BYTE     BEQ     XXC905          ; EXIT IF NULL [EOL]     CMP     XX08          ; COMPARE WITH SEARCH CHARACTER     BEQ     XXC905          ; EXIT IF FOUND     INY                    ; ELSE INCREMENT INDEX     CMP     #$22               ; COMPARE CURRENT CHARACTER WITH OPEN QUOTE     BNE     XXC919          ; IF FOUND GO SWAP SEARCH CHARACTER FOR ALTERNATE SEARCH                         ; CHARACTER     BEQ     XXC911          ; LOOP FOR NEXT CHARACTER, BRANCH ALWAYS;***********************************************************************************;;; PERFORM IFXXC928 = *     JSR     XXCD9E          ; EVALUATE EXPRESSION     JSR     XX0079          ; SCAN MEMORY     CMP     #TGOTO          ; COMPARE WITH 'GOTO' TOKEN     BEQ     XXC937          ; IF IT WAS  THE TOKEN FOR GOTO GO DO IF ... GOTO                         ; WASN'T IF ... GOTO SO MUST BE IF ... THEN     LDA     #TTHEN          ; $A7 = 'THEN' TOKEN     JSR     XXCEFF          ; SCAN FOR CHR$(A), ELSE DO SYNTAX ERROR THEN WARM STARTXXC937 = *     LDA     XX61          ; GET FAC1 EXPONENT     BNE     XXC940          ; IF RESULT WAS NON ZERO CONTINUE EXECUTION                         ; ELSE REM THE REST OF THE LINE;********************************************************************************** *;;; PERFORM REMXXC93B = *     JSR     XXC909          ; SCAN FOR NEXT BASIC LINE     BEQ     XXC8FB          ; ADD Y TO THE BASIC EXECUTE POINTER AND RETURN, BRANCH                         ; ALWAYS;*********************************************!**************************************;;; IF CONTINUED .. RESULT WAS NON ZERO SO DO REST OF LINEXXC940 = *     JSR     XX0079          ; SCAN MEMORY     BCS     XXC948          ; IF NOT NUMERIC CHARACTER, IS VARIABLE OR KEYWORD     JMP     XXC8A0"          ; ELSE PERFORM GOTO N                         ; IS VARIABLE OR KEYWORDXXC948 = *     JMP     XXC7ED          ; INTERPRET BASIC CODE FROM BASIC EXECUTE POINTER;******************************************************************************#*****;;; PERFORM ONXXC94B = *     JSR     XXD79E          ; GET BYTE PARAMETER     PHA                    ; PUSH NEXT CHARACTER     CMP     #TGOSUB          ; COMPARE WITH GOSUB TOKEN     BEQ     XXC957          ; IF GOSUB GO SEE IF IT SHOULD BE $EXECUTEDXXC953 = *     CMP     #TGOTO          ; COMPARE WITH GOTO TOKEN     BNE     XXC8E8          ; IF NOT GOTO DO SYNTAX ERROR THEN WARM START; NEXT CHARACTER WAS GOTO OR GOSUB, SEE IF IT SHOULD BE EXECUTEDXXC957 = *     DEC     XX65        %  ; DECREMENT THE BYTE VALUE     BNE     XXC95F          ; IF NOT ZERO GO SEE IF ANOTHER LINE NUMBER EXISTS     PLA                    ; PULL KEYWORD TOKEN     JMP     XXC7EF          ; GO EXECUTE ITXXC95F = *     JSR     XX0073          ; INCREME&NT AND SCAN MEMORY     JSR     XXC96B          ; GET FIXED-POINT NUMBER INTO TEMPORARY INTEGER                         ; SKIP THIS N     CMP     #','               ; COMPARE NEXT CHARACTER WITH ','     BEQ     XXC957          ; LOOP IF ','     PLA '                   ; ELSE PULL KEYWORD TOKEN, RAN OUT OF OPTIONSXXC96A = *     RTS;***********************************************************************************;;; GET FIXED-POINT NUMBER INTO TEMPORARY INTEGERXXC96B = *     LDX     #$00                ; CLEAR X     STX     XX14          ; CLEAR TEMPORARY INTEGER LOW BYTE     STX     XX15          ; CLEAR TEMPORARY INTEGER HIGH BYTEXXC971 = *     BCS     XXC96A          ; RETURN IF CARRY SET, END OF SCAN, CHARACTER WAS NOT 0-9     SB           ; WE NEED 18D BYTES !     JSR     XXC3FB          ; CHECK ROOM ON STACK FOR 2*A BYTES     JSR     XXC906          ; SCAN FOR NEXT BASIC STATEMENT ([:] OR [EOL])     CLC                    ; CLEAR CARRY FOR ADD     TYA                    ; COPY INDEX TO A     ADC     XX7A          ; ADD BASIC EXECUTE POINTER LOW BYTE     PHA                    ; PUSH ONTO STACK     LDA     XX7B          ; GET BASIC EXECUTE POINTER HIGH BYTE     ADC     #$00               ; ADD CARRY     PHA                    ; PUSH ONTO STACK     LDA     XX3A          ; GET CURRENT LINE NUMBER HIGH BYTE     PHA                    ; PUSH ONTO STACK     LDA     XX39          ; GET CURRENT LINE NUMBER LOW BYTE     PHA                    ; PUSH ONTO STACK     LDA     #TTO          ; SET 'TO' TOKEN     JSR     XXCEFF          ; SCAN FOR CHR$(A), ELSE DO SYNTAX ERROR THEN WARM START     JSR     XXCD8D          ; CHECK IF SOURCE IS NUMERIC, ELSE DO TYPE MISMATCH     JSR     XXCD8A          ; EVALUATE EXPRESSION AND CHECK IS NUMERIC, ELSE DO                         ; TYPE MISMATCH     LDA     XX66          ; GET FAC1 SIGN (B7)     ORA     #$7F               ; SET ALL NON SIGN BITS     AND     XX62          ; AND FAC1 MANTISSA 1     STA     XX62          ; SAVE FAC1 MANTISSA 1     LDA     #<XXC78B          ; SET RETURN ADDRESS LOW BYTE     LDY     #>XXC78B          ; SET RETURN ADDRESS HIGH BYTE     STA     XX22          ; SAVE RETURN ADDRESS LOW BYTE     STY     XX23          ; SAVE RETURN ADDRESS HIGH BYTE     JMP     XXCE43          ; ROUND FAC1 AND PUT ON STACK, RETURNS TO NEXT INSTRUCTIONXXC78B = *     LDA     #<XXD9BC          ; SET 1 POINTER LOW ADDRESS, DEFAULT STEP SIZE     LDY     #>XXD9BC          ; SET 1 POINTER HIGH ADDRESS     JSR     XXDBA2          ; UNPACK MEMORY (AY) INTO FAC1     JSR     XX0079          ; SCAN MEMORY     CMP     #TSTEP          ; COMPARE WITH STEP TOKEN     BNE     XXC79F          ; BRANCH IF NOT 'STEP'                         ; WAS STEP SO ....     JSR   	  XX0073          ; INCREMENT AND SCAN MEMORY     JSR     XXCD8A          ; EVALUATE EXPRESSION AND CHECK IS NUMERIC, ELSE DO                         ; TYPE MISMATCHXXC79F = *     JSR     XXDC2B          ; GET FAC1 SIGN, RETURN A = $FF -VE, A = $01 +
VE     JSR     XXCE38          ; PUSH SIGN, ROUND FAC1 AND PUT ON STACK     LDA     XX4A          ; GET FOR/NEXT VARIABLE POINTER HIGH BYTE     PHA                    ; PUSH ON STACK     LDA     XX49          ; GET FOR/NEXT VARIABLE POINTER LOW BYTE     PHA                    ; PUSH ON STACK     LDA     #TFOR          ; GET FOR TOKEN     PHA                    ; PUSH ON STACK;***********************************************************************************;;; INTERPRETER INNER LOOPXXC7AE = *     JSR     XXC82C          ; DO CRTL-C CHECK VECTOR     LDA     XX7A          ; GET BASIC EXECUTE POINTER LOW BYTE     LDY     XX7B          ; GET BASIC EXECUTE POINTER HIGH BYTE     CPY     #$02               ; COMPARE WITH $02XX     NOP                    ; UNUSED BYTE                                   ##     BEQ     XXC7BE          ; IF IMMEDIATE MODE SKIP THE CONTINUE POINTER SAVE     STA     XX3D          ; SAVE THE CONTINUE POINTER LOW BYTE     STY     XX3E          ; SAVE THE CONTINUE POINTER HIGH BYTEXXC7BE = *     LDY     #$00               ; CLEAR THE INDEX     LDA     (XX7A),Y          ; GET BASIC BYTE     BNE     XXC807          ; IF NOT [EOL] GO TEST FOR ':'     LDY     #$02               ; ELSE SET THE INDEX     LDA     (XX7A),Y          ; GET NEXT LINE POINTER HIGH BYTE     CLC                    ; CLEAR CARRY FOR NO 'BREAK' MESSAGE     BNE     XXC7CE          ; BRANCH IF NOT END OF PROGRAM     JMP     XXC84B          ; ELSE GO TO IMMEDIATE MODE,WAS IMMEDIATE OR [EOT] MARKERXXC7CE = *     INY                    ; INCREMENT INDEX     LDA     (XX7A),Y          ; GET LINE NUMBER LOW BYTE     STA     XX39          ; SAVE CURRENT LINE NUMBER LOW BYTE     INY                    ; INCREMENT INDEX     LDA     (XX7A),Y          ; GET LINE # HIGH BYTE     STA     XX3A          ; SAVE CURRENT LINE NUMBER HIGH BYTE     TYA                    ; A NOW = 4     ADC     XX7A          ; ADD BASIC EXECUTE POINTER LOW BYTE, NOW POINTS TO CODE     STA     XX7A          ; SAVE BASIC EXECUTE POINTER LOW BYTE     BCC     XXC7E1          ; IF NO OVERFLOW SKIP THE HIGH BYTE INCREMENT     INC     XX7B          ; ELSE INCREMENT BASIC EXECUTE POINTER HIGH BYTEXXC7E1 = *     JMP     (XX0308)          ; DO START NEW BASIC CODE;***********************************************************************************;;; START NEW BASIC CODE, THE START NEW BASIC CODE VECTOR IS INITIALISED TO POINT HEREXXC7E4 = *     JSR     XX0073          ; INCREMENT AND SCAN MEMORY     JSR     XXC7ED          ; GO INTERPRET BASIC CODE FROM BASIC EXECUTE POINTER     JMP     XXC7AE          ; LOOP;***********************************************************************************;;; GO INTERPRET BASIC CODE FROM BASIC EXECUTE POINTERXXC7ED = *     BEQ     XXC82B          ; IF THE FIRST BYTE IS NULL JUST EXITXXC7EF = *     SBC     #$80               ; NORMALISE THE TOKEN     BCC     XXC804          ; IF WASN'T TOKEN GO DO LET     CMP     #TTAB-$80          ; COMPARE WITH TOKEN FOR TAB(-$80     BCS     XXC80E          ; BRANCH IF >= TAB(     ASL A                  ; *2 BYTES PER VECTOR     TAY                    ; COPY TO INDEX     LDA     XXC00C+1,Y     ; GET VECTOR HIGH BYTE     PHA                    ; PUSH ON STACK     LDA     XXC00C,Y          ; GET VECTOR LOW BYTE     PHA                    ; PUSH ON STACK     JMP     XX0073          ; INCREMENT AND SCAN MEMORY AND RETURN. THE RETURN IN                         ; THIS CASE CALLS THE COMMAND CODE, THE RETURN FROM                         ; THAT WILL EVENTUALLY RETURN TO THE INTERPRETER INNER                         ; LOOP ABOVEXXC804 = *     JMP     XXC9A5          ; PERFORM LET                         ; WAS NOT [EOL]XXC807 = *     CMP     #':'               ; COMAPRE WITH ':'     BEQ     XXC7E1          ; IF ':' GO EXECUTE NEW CODE                         ; ELSE ...XXC80B = *     JMP     XXCF08          ; DO SYNTAX ERROR THEN WARM START                         ; TOKEN WAS >= TAB(XXC80E = *     CMP     #TGO-$80          ; COMPARE WITH TOKEN FOR GO     BNE     XXC80B          ; IF NOT 'GO' DO SYNTAX ERROR THEN WARM START                         ; ELSE WAS 'GO'     JSR     XX0073          ; INCREMENT AND SCAN MEMORY     LDA     #TTO          ; SET 'TO' TOKEN     JSR     XXCEFF          ; SCAN FOR CHR$(A), ELSE DO SYNTAX ERROR THEN WARM START     JMP     XXC8A0          ; PERFORM GOTO;***********************************************************************************;;; PERFORM RESTOREXXC81D = *     SEC                    ; SET CARRY FOR SUBTRACT     LDA     XX2B          ; GET START OF MEMORY LOW BYTE     SBC     #$01               ; -1     LDY     XX2C          ; GET START OF MEMORY HIGH BYTE     BCS     XXC827          ; IF NO ROLLUNDER SKIP THE HIGH BYTE DECREMENT     DEY                    ; ELSE DECREMENT HIGH BYTEXXC827 = *     STA     XX41          ; SET DATA POINTER LOW BYTE     STY     XX42          ; SET DATA POINTER HIGH BYTEXXC82B = *     RTS;***********************************************************************************;;; DO CRTL-C CHECK VECTORXXC82C = *     JSR     XXFFE1          ; SCAN STOP KEY;***********************************************************************************;;; PERFORM STOPXXC82F = *     BCS     XXC832          ; IF CARRY SET DO BREAK INSTEAD OF JUST END;***********************************************************************************;;; PERFORM ENDXXC831 = *     CLC                    ; CLEAR CA RRYXXC832 = *     BNE     XXC870          ; RETURN IF WASN'T CTRL-C     LDA     XX7A          ; GET BASIC EXECUTE POINTER LOW BYTE     LDY     XX7B          ; GET BASIC EXECUTE POINTER HIGH BYTE     LDX     XX3A          ; GET CURRENT LINE NUMBER H!IGH BYTE     INX                    ; INCREMENT IT     BEQ     XXC849          ; BRANCH IF WAS IMMEDIATE MODE     STA     XX3D          ; SAVE CONTINUE POINTER LOW BYTE     STY     XX3E          ; SAVE CONTINUE POINTER HIGH BYTE     LDA     XX39   "       ; GET CURRENT LINE NUMBER LOW BYTE     LDY     XX3A          ; GET CURRENT LINE NUMBER HIGH BYTE     STA     XX3B          ; SAVE BREAK LINE NUMBER LOW BYTE     STY     XX3C          ; SAVE BREAK LINE NUMBER HIGH BYTEXXC849 = *     PLA       #             ; DUMP RETURN ADDRESS LOW BYTE     PLA                    ; DUMP RETURN ADDRESS HIGH BYTEXXC84B = *     LDA     #<XXC381          ; SET [CR][LF]'BREAK' POINTER LOW BYTE     LDY     #>XXC381          ; SET [CR][LF]'BREAK' POINTER HIGH BYT$E     BCC     XXC854          ; BRANCH IF WAS PROGRAM END     JMP     XXC469          ; PRINT STRING AND DO WARM STARTXXC854 = *     JMP     XXC474          ; DO WARM START;************************************************************************%***********;;; PERFORM CONTXXC857 = *     BNE     XXC870          ; EXIT IF FOLLOWING BYTE TO ALLOW SYNTAX ERROR     LDX     #$1A               ; ERROR CODE $1A, CAN'T CONTINUE ERROR     LDY     XX3E          ; GET CONTINUE POINTER HIGH BYTE    & BNE     XXC862          ; GO DO CONTINUE IF WE CAN     JMP     XXC437          ; ELSE DO ERROR #X THEN WARM START                         ; WE CAN CONTINUE SO ...XXC862 = *     LDA     XX3D          ; GET CONTINUE POINTER LOW BYTE     STA     XX7'A          ; SAVE BASIC EXECUTE POINTER LOW BYTE     STY     XX7B          ; SAVE BASIC EXECUTE POINTER HIGH BYTE     LDA     XX3B          ; GET BREAK LINE LOW BYTE     LDY     XX3C          ; GET BREAK LINE HIGH BYTE     STA     XX39          ; SET  CURRENT LINE NUMBER LOW BYTE     STY     XX3A          ; SET CURRENT LINE NUMBER HIGH BYTEXXC870 = *     RTS;***********************************************************************************;;; PERFORM RUNXXC871 = *     PHP                 E     INY                    ; INCREMENT INDEX     STA     (XX2B),Y          ; CLEAR POINTER TO NEXT LINE HIGH BYTE, ERASE PROGRAM     LDA     XX2B          ; GET START OF MEMORY LOW BYTE     CLC                    ; CLEAR CARRY FOR ADD     ADC     #$02               ; ADD NULL PROGRAM LENGTH     STA     XX2D          ; SET START OF VARIABLES LOW BYTE     LDA     XX2C          ; GET START OF MEMORY HIGH BYTE     ADC     #$00               ; ADD CARRY     STA     XX2E          ; SET START OF VARIABLES HIGH BYTE; RESET EXECUTE POINTER AND DO CLRXXC659 = *     JSR     XXC68E          ; SET BASIC EXECUTE POINTER TO START OF MEMORY - 1     LDA     #$00               ; SET ZB FOR CLR ENTRY;***********************************************************************************;;; PERFORM CLRXXC65E = *     BNE     XXC68D          ; EXIT IF FOLLOWING BYTE TO ALLOW SYNTAX ERRORXXC660 = *     JSR     XXFFE7          ; CLOSE ALL CHANNELS AND FILESXXC663 = *     LDA     XX37          ; GET END OF MEMORY LOW BYTE     LDY     XX38          ; GET END OF MEMORY HIGH BYTE     STA     XX33          ; SET BOTTOM OF STRING SPACE LOW BYTE, CLEAR STRINGS     STY     XX34          ; SET BOTTOM OF STRING SPACE HIGH BYTE     LDA     XX2D          ; GET START OF VARIABLES LOW BYTE     LDY     XX2E          ; GET START OF VARIABLES HIGH BYTE     STA     XX2F          ; SET END OF VARIABLES LOW BYTE, CLEAR VARIABLES     STY     XX30          ; SET END OF VARIABLES HIGH BYTE     STA     XX31          ; SET END OF ARRAYS LOW BYTE, CLEAR ARRAYS     STY     XX32          ; SET END OF ARRAYS HIGH BYTE;***********************************************************************************;;; DO RESTORE AND CLEAR THE STACKXXC677 = *     JSR     XXC81D          ; PERFORM RESTORE; FLUSH BASIC STACK AND CLEAR THE CONTINUE POINTERXXC67A = *     LDX     #XX19          ; GET DESCRIPTOR STACK START     STX     XX16          ; SET DESCRIPTOR STACK POINTER     PLA                    ; PULL RETURN 	ADDRESS LOW BYTE     TAY                    ; COPY IT     PLA                    ; PULL RETURN ADDRESS HIGH BYTE     LDX     #$FA               ; SET CLEARED STACK POINTER     TXS                    ; SET STACK     PHA                    ; PUSH RETU
RN ADDRESS HIGH BYTE     TYA                    ; RESTORE RETURN ADDRESS LOW BYTE     PHA                    ; PUSH RETURN ADDRESS LOW BYTE     LDA     #$00               ; CLEAR A     STA     XX3E          ; CLEAR CONTINUE POINTER HIGH BYTE     STA     XX10          ; CLEAR SUBSCRIPT/FNX FLAGXXC68D = *     RTS;***********************************************************************************;;; SET BASIC EXECUTE POINTER TO START OF MEMORY - 1XXC68E = *     CLC                    ; CLEAR CARRY FOR ADD     LDA     XX2B          ; GET START OF MEMORY LOW BYTE     ADC     #$FF               ; ADD -1 LOW BYTE     STA     XX7A          ; SET BASIC EXECUTE POINTER LOW BYTE     LDA     XX2C          ; GET START OF MEMORY HIGH BYTE     ADC     #$FF               ; ADD -1 HIGH BYTE     STA     XX7B          ; SAVE BASIC EXECUTE POINTER HIGH BYTE     RTS;***********************************************************************************;;; PERFORM LISTXXC69C = *     BCC     XXC6A4          ; BRANCH IF NEXT CHARACTER NOT TOKEN (LIST N...)     BEQ     XXC6A4          ; BRANCH IF NEXT CHARACTER [NULL] (LIST)     CMP     #TMINUS          ; COMPARE WITH TOKEN FOR -     BNE     XXC68D          ; EXIT IF NOT - (LIST -M)                         ; LIST [[N][-M]]                         ; THIS BIT SETS THE N , IF PRESENT, AS THE START AND ENDXXC6A4 = *     JSR     XXC96B          ; GET FIXED-POINT NUMBER INTO TEMPORARY INTEGER     JSR     XXC613          ; SEARCH BASIC FOR TEMPORARY INTEGER LINE NUMBER     JSR     XX0079          ; SCAN MEMORY     BEQ     XXC6BB          ; BRANCH IF NO MORE CHRS                         ; THIS BIT CHECKS THE - IS PRESENT     CMP     #TMINUS          ; COMPARE WITH '-'     BNE     XXC641          ; RETURN IF NOT '-' (WILL BE SN ERROR)                         ; LIST [N]-M                         ; THE - WAS THERE SO SET M AS THE END VALUE     JSR     XX0073          ; INCREMENT AND SCAN MEMORY     JSR     XXC96B          ; GET FIXED-POINT NUMBER INTO TEMPORARY INTEGER     BNE     XXC641          ; EXIT IF NOT OKXXC6BB = *     PLA                    ; DUMP RETURN ADDRESS LOW BYTE, EXIT VIA WARM START     PLA                    ; DUMP RETURN ADDRESS HIGH BYTE     LDA     XX14          ; GET TEMPORARY INTEGER LOW BYTE     ORA     XX15          ; OR TEMPORARY INTEGER HIGH BYTE     BNE     XXC6C9          ; BRANCH IF START SET     LDA     #$FF               ; SET FOR -1     STA     XX14          ; SET TEMPORARY INTEGER LOW BYTE     STA     XX15          ; SET TEMPORARY INTEGER HIGH BYTEXXC6C9 = *     LDY     #$01               ; SET INDEX FOR LINE     STY     XX0F          ; CLEAR OPEN QUOTE FLAG     LDA     (XX5F),Y          ; GET NEXT LINE POINTER HIGH BYTE     BEQ     XXC714          ; IF NULL ALL DONE SO EXIT     JSR     XXC82C          ; DO CRTL-C CHECK VECTOR     JSR     XXCAD7          ; PRINT CR/LF     INY                    ; INCREMENT INDEX FOR LINE     LDA     (XX5F),Y          ; GET LINE NUMBER LOW BYTE     TAX                    ; COPY TO X     INY                    ; INCREMENT INDEX     LDA     (XX5F),Y          ; GET LINE NUMBER HIGH BYTE     CMP     XX15          ; COMPARE WITH TEMPORARY INTEGER HIGH BYTE     BNE     XXC6E6          ; BRANCH IF NO HIGH BYTE MATCH     CPX     XX14          ; COMPARE WITH TEMPORARY INTEGER LOW BYTE     BEQ     XXC6E8          ; BRANCH IF = LAST LINE TO DO, < WILL PASS NEXT BRANCHXXC6E6 = *                    ; ELSE ...     BCS     XXC714          ; IF GREATER ALL DONE SO EXITXXC6E8 = *     STY     XX49          ; SAVE INDEX FOR LINE     JSR     XXDDCD          ; PRINT XA AS UNSIGNED INTEGER     LDA     #' '               ; SPACE IS THE NEXT CHARACTERXXC6EF = *     LDY     XX49          ; GET INDEX FOR LINE     AND     #$7F               ; MASK TOP OUT BIT OF CHARACTERXXC6F3 = *     JSR     XXCB47          ; GO PRINT THE CHARACTER     CMP     #$22               ; WAS IT ' CHARACTER     BNE     XXC700          ; IF NOT SKIP THE QUOTE HANDLE                         ; WE ARE EITHER ENTERING OR LEAVING A PAIR OF QUOTES     LDA     XX0F          ; GET OPEN QUOTE FLAG     EOR     #$FF               ; TOGGLE IT     STA     XX0F          ; SAVE IT BACKXXC700 = *     INY                    ; INCREMENT INDEX     BEQ     XXC714          ; LINE TOO LONG SO JUST BAIL OUT AND DO A WARM START     LDA     (XX5F),Y          ; GET NEXT BYTE     BNE     XXC717          ; IF NOT [EOL] (GO PRINT CHARACTER)                         ; WAS [EOL]     TAY                    ; ELSE CLEAR INDEX     LDA     (XX5F),Y          ; GET NEXT LINE POINTER LOW BYTE     TAX                    ; COPY TO X     INY                    ; INCREMENT INDEX     LDA     (XX5F),Y          ; GET NEXT LINE POINTER HIGH BYTE     STX     XX5F          ; SET POINTER TO LINE LOW BYTE     STA     XX60          ; SET POINTER TO LINE HIGH BYTE     BNE     XXC6C9          ; GO DO NEXT LINE IF NOT [EOT]                         ; ELSE ...XXC714 = *     JMP     XXC474          ; DO WARM START;***********************************************************************************;;XXC717 = *     JMP     (XX0306)          ; DO UNCRUNCH BASIC TOKENS;***********************************************************************************;;; UNCRUNCH BASIC TOKENS, THE UNCRUNCH BASIC TOKENS VECTOR IS INITIALISED TO POINT HEREXXC71A = *     BPL     XXC6F3          ; JUST GO PRINT IT IF NOT TOKEN BYTE                         ; ELSE WAS TOKEN BYTE SO UNCRUNCH IT     CMP      #TPI          ; COMPARE WITH THE TOKEN FOR PI. IN THIS CASE THE TOKEN                         ; IS THE SAME AS THE PI CHARACTER SO IT JUST NEEDS PRINTING     BEQ     XXC6F3          ; JUST PRINT IT IF SO     BIT     XX0F          ; TEST THE OPEN QUO!TE FLAG     BMI     XXC6F3          ; JUST GO PRINT CHARACTER IF OPEN QUOTE SET     SEC                    ; ELSE SET CARRY FOR SUBTRACT     SBC     #$7F               ; REDUCE TOKEN RANGE TO 1 TO WHATEVER     TAX                    ; COPY TOKEN # T"O X     STY     XX49          ; SAVE INDEX FOR LINE     LDY     #$FF               ; START FROM -1, ADJUST FOR PRE INCREMENTXXC72C = *     DEX                    ; DECREMENT TOKEN #     BEQ     XXC737          ; IF NOW FOUND GO DO PRINTINGXXC72F =# *     INY                    ; ELSE INCREMENT INDEX     LDA     XXC09E,Y          ; GET BYTE FROM KEYWORD TABLE     BPL     XXC72F          ; LOOP UNTIL KEYWORD END MARKER     BMI     XXC72C          ; GO TEST IF THIS IS REQUIRED KEYWORD, BRANCH AL$WAYS                         ; FOUND KEYWORD, IT'S THE NEXT ONEXXC737 = *     INY                    ; INCREMENT KEYWORD TABLE INDEX     LDA     XXC09E,Y          ; GET BYTE FROM TABLE     BMI     XXC6EF          ; GO RESTORE INDEX, MASK BYTE AND P%RINT IF                         ; BYTE WAS END MARKER     JSR     XXCB47          ; ELSE GO PRINT THE CHARACTER     BNE     XXC737          ; GO GET NEXT CHARACTER, BRANCH ALWAYS;********************************************************************&***************;;; PERFORM FORXXC742 = *     LDA     #$80               ; SET FNX     STA     XX10          ; SET SUBSCRIPT/FNX FLAG     JSR     XXC9A5          ; PERFORM LET     JSR     XXC38A          ; SEARCH THE STACK FOR FOR OR GOSUB ACTIVIT'Y     BNE     XXC753          ; BRANCH IF FOR, THIS VARIABLE, NOT FOUND                         ; FOR, THIS VARIABLE, WAS FOUND SO FIRST WE DUMP THE OLD ONE     TXA                    ; COPY INDEX     ADC     #$0F               ; ADD FOR STRUCTURE S IZE-2     TAX                    ; COPY TO INDEX     TXS                    ; SET STACK (DUMP FOR STRUCTURE (-2 BYTES))XXC753 = *     PLA                    ; PULL RETURN ADDRESS     PLA                    ; PULL RETURN ADDRESS     LDA     #$09    XC560 = *     LDX     #$00               ; SET CHANNEL $00, KEYBOARDXXC562 = *     JSR     XXE10F          ; INPUT CHARACTER FROM CHANNEL WITH ERROR CHECK     CMP     #$0D               ; COMPARE WITH [CR]     BEQ     XXC576          ; IF [CR] SET XY TO XX200 - 1, PRINT [CR] AND EXIT                         ; CHARACTER WAS NOT [CR]     STA     XX0200,X          ; SAVE CHARACTER TO BUFFER     INX                    ; INCREMENT BUFFER INDEX     CPX     #$59               ; COMPARE WITH MAX+1     BCC     XXC562          ; BRANCH IF < MAX+1     LDX     #$17               ; ERROR $17, STRING TOO LONG ERROR     JMP     XXC437          ; DO ERROR #X THEN WARM STARTXXC576 = *     JMP     XXCACA          ; SET XY TO XX200 - 1 AND PRINT [CR];***********************************************************************************;;; CRUNCH BASIC TOKENS VECTORXXC579 = *     JMP     (XX0304)          ; DO CRUNCH BASIC TOKENS;***********************************************************************************;;; CRUNCH BASIC TOKENS, THE CRUNCH BASIC TOKENS VECTOR IS INITIALISED TO POINT HEREXXC57C = *     LDX     XX7A          ; GET BASIC EXECUTE POINTER LOW BYTE     LDY     #$04               ; SET SAVE INDEX     STY     XX0F          ; CLEAR OPEN QUOTE/DATA FLAGXXC582 = *     LDA     XX0200,X          ; GET A BYTE FROM THE INPUT BUFFER     BPL     XXC58E          ; IF B7 CLEAR GO DO CRUNCHING     CMP     #TPI          ; COMPARE WITH THE TOKEN FOR PI, THIS TOKE IS INPUT                         ; DIRECTLY FROM THE KEYBOARD AS THE PI CHARACTER.     BEQ     XXC5C9          ; IF PI SAVE BYTE THEN CONTINUE CRUNCHING                         ; THIS IS THE BIT OF CODE THAT STOPS YOU BEING ABLE TO ENTER                         ; SOME KEYWORDS AS JUST SINGLE SHIFTED CHARACTERS. IF THIS                         ; DROPPED THROUGH YOU WOULD BE ABLE TO ENTER GOTO AS JUST                         ; [SHIFT]G     INX                    ; INCREMENT READ INDEX     BNE     XXC582         	 ; LOOP IF MORE TO DO, BRANCH ALWAYSXXC58E = *     CMP     #' '               ; COMPARE WITH [SPACE]     BEQ     XXC5C9          ; IF [SPACE] SAVE BYTE THEN CONTINUE CRUNCHING     STA     XX08          ; SAVE BUFFER BYTE AS SEARCH CHARACTER     CM
P     #$22               ; COMPARE WITH QUOTE CHARACTER      BEQ     XXC5EE          ; IF QUOTE GO COPY QUOTED STRING     BIT     XX0F          ; GET OPEN QUOTE/DATA TOKEN FLAG     BVS     XXC5C9          ; BRANCH IF B6 OF OQUOTE SET, WAS DATA                         ; GO SAVE BYTE THEN CONTINUE CRUNCHING     CMP     #'?'               ; COMPARE WITH '?' CHARACTER     BNE     XXC5A4          ; IF NOT '?' CONTINUE CRUNCHING     LDA     #TPRINT          ; ELSE SET THE TOKEN FOR PRINT     BNE     XXC5C9          ; GO SAVE BYTE THEN CONTINUE CRUNCHING ,BRANCH ALWAYSXXC5A4 = *     CMP     #'0'               ; COMPARE WITH '0'     BCC     XXC5AC          ; IF < '0' CONTINUE CRUNCHING     CMP     #'<'               ; COMPARE WITH '<'     BCC     XXC5C9          ; IF <, 0123456789:; GO SAVE BYTE THEN CONTINUE CRUNCHING                         ; GETS HERE WITH NEXT CHARACTER NOT NUMERIC, ';' OR ':'XXC5AC = *     STY     XX71          ; COPY SAVE INDEX     LDY     #$00               ; CLEAR TABLE POINTER     STY     XX0B          ; CLEAR WORD INDEX     DEY                    ; ADJUST FOR PRE INCREMENT LOOP     STX     XX7A          ; SAVE BASIC EXECUTE POINTER LOW BYTE, BUFFER INDEX     DEX                    ; ADJUST FOR PRE INCREMENT LOOPXXC5B6 = *     INY                    ; NEXT TABLE BYTE     INX                    ; NEXT BUFFER BYTEXXC5B8 = *     LDA     XX0200,X          ; GET BYTE FROM INPUT BUFFER     SEC                    ; SET CARRY FOR SUBTRACT     SBC     XXC09E,Y          ; SUBTRACT TABLE BYTE     BEQ     XXC5B6          ; GO COMPARE NEXT IF MATCH     CMP     #$80               ; WAS IT END MARKER MATCH ?     BNE     XXC5F5          ; IF NOT GO TRY THE NEXT KEYWORD                         ; ACTUALLY THIS WORKS EVEN IF THE INPUT BUFFER BYTE IS THE                         ; END MARKER, I.E. A SHIFTED CHARACTER. AS YOU CAN'T ENTER                         ; ANY KEYWORDS AS A SINGLE SHIFTED CHARACTER, SEE ABOVE,                         ; YOU CAN ENTER KEYWORDS IN SHORTHAND BY SHIFTING ANY                         ; CHARACTER AFTER THE FIRST. SO RETURN CAN BE ENTERED AS                         ; R[SHIFT]E, RE[SHIFT]T, RET[SHIFT]U OR RETU[SHIFT]R.                         ; RETUR[SHIFT]N HOWEVER WILL NOT WORK BECAUSE THE [SHIFT]N                         ; WILL MATCH THE RETURN END MARKER SO THE ROUTINE WILL TRY                         ; TO MATCH THE NEXT CHARACTER.                         ; ELSE FOUND KEYWORD     ORA     XX0B          ; OR WITH WORD INDEX, +$80 IN A MAKES TOKENXXC5C7 = *     LDY     XX71          ; RESTORE SAVE INDEX; SAVE BYTE THEN CONTINUE CRUNCHINGXXC5C9 = *     INX                    ; INCREMENT BUFFER READ INDEX     INY                    ; INCREMENT SAVE INDEX     STA     XX0200-5,Y     ; SAVE BYTE TO OUTPUT     LDA     XX0200-5,Y     ; GET BYTE FROM OUTPUT, SET FLAGS     BEQ     XXC609          ; BRANCH IF WAS NULL [EOL]                         ; A HOLDS THE TOKEN HERE     SEC                    ; SET CARRY FOR SUBTRACT     SBC     #':'               ; SUBTRACT ':'     BEQ     XXC5DC          ; BRANCH IF IT WAS (IS NOW $00)                         ; A NOW HOLDS TOKEN-':'     CMP     #$49 ;#TDATA-':'     ; COMPARE WITH THE TOKEN FOR DATA-':'     BNE     XXC5DE          ; IF NOT DATA GO TRY REM                         ; TOKEN WAS : OR DATAXXC5DC = *     STA     XX0F          ; SAVE TOKEN-':'XXC5DE = *     SEC                    ; SET CARRY FOR SUBTRACT     SBC     #$55 ;#TREM-':'          ; SUBTRACT THE TOKEN FOR REM-':'     BNE     XXC582          ; IF WASN'T REM GO CRUNCH NEXT BIT OF LINE     STA     XX08          ; ELSE WAS REM SO SET SEARCH FOR [EOL]                         ; LOOP FOR '...' ETC.XXC5E5 = *     LDA     XX0200,X          ; GET BYTE FROM INPUT BUFFER     BEQ     XXC5C9          ; IF NULL [EOL] SAVE BYTE THEN CONTINUE CRUNCHING     CMP     XX08          ; COMPARE WITH STORED CHARACTER     BEQ     XXC5C9          ; IF MATCH SAVE BYTE THEN CONTINUE CRUNCHINGXXC5EE = *     INY                    ; INCREMENT SAVE INDEX     STA     XX0200-5,Y     ; SAVE BYTE TO OUTPUT     INX                    ; INCREMENT BUFFER INDEX     BNE     XXC5E5          ; LOOP WHILE <> 0, SHOULD NEVER REACH 0                         ; NOT FOUND KEYWORD THIS GOXXC5F5 = *     LDX     XX7A          ; RESTORE BASIC EXECUTE POINTER LOW BYTE     INC     XX0B          ; INCREMENT WORD INDEX (NEXT WORD)                         ; NOW FIND END OF THIS WORD IN THE TABLEXXC5F9 = *     INY                    ; INCREMENT TABLE INDEX     LDA     XXC09E-1,Y     ; GET TABLE BYTE     BPL     XXC5F9          ; LOOP IF NOT END OF WORD YET     LDA     XXC09E,Y          ; GET BYTE FROM KEYWORD TABLE     BNE     XXC5B8          ; GO TEST NEXT WORD IF NOT ZERO BYTE, END OF TABLE                         ; REACHED END OF TABLE WITH NO MATCH     LDA     XX0200,X          ; RESTORE BYTE FROM INPUT BUFFER     BPL     XXC5C7          ; BRANCH ALWAYS, ALL UNMATCHED BYTES IN THE BUFFER ARE                         ; $00 TO $7F, GO SAVE BYTE IN OUTPUT AND CONTINUE CRUNCHING                         ; REACHED [EOL]XXC609 = *     STA     XX0200-3,Y     ; SAVE [EOL]     DEC     XX7B          ; DECREMENT BASIC EXECUTE POINTER HIGH BYTE     LDA     #$FF               ; POINT TO START OF BUFFER-1     STA     XX7A          ; SET BASIC EXECUTE POINTER LOW BYTE     RTS;***********************************************************************************;;; SEARCH BASIC FOR TEMPORARY INTEGER LINE NU MBERXXC613 = *     LDA     XX2B          ; GET START OF MEMORY LOW BYTE     LDX     XX2C          ; GET START OF MEMORY HIGH BYTE; SEARCH BASIC FOR TEMP INTEGER LINE NUMBER FROM AX; RETURNS CARRY SET IF FOUNDXXC617 = *     LDY     #$01         !      ; SET INDEX TO NEXT LINE POINTER HIGH BYTE     STA     XX5F          ; SAVE LOW BYTE AS CURRENT     STX     XX60          ; SAVE HIGH BYTE AS CURRENT     LDA     (XX5F),Y          ; GET NEXT LINE POINTER HIGH BYTE FROM ADDRESS     BEQ     XXC64"0          ; POINTER WAS ZERO SO DONE, EXIT     INY                    ; INCREMENT INDEX ...     INY                    ; ... TO LINE # HIGH BYTE     LDA     XX15          ; GET TEMPORARY INTEGER HIGH BYTE     CMP     (XX5F),Y          ; COMPARE WIT#H LINE # HIGH BYTE     BCC     XXC641          ; EXIT IF TEMP < THIS LINE, TARGET LINE PASSED     BEQ     XXC62E          ; GO CHECK LOW BYTE IF =     DEY                    ; ELSE DECREMENT INDEX     BNE     XXC637          ; BRANCH ALWAYSXXC62E$ = *     LDA     XX14          ; GET TEMPORARY INTEGER LOW BYTE     DEY                    ; DECREMENT INDEX TO LINE # LOW BYTE     CMP     (XX5F),Y          ; COMPARE WITH LINE # LOW BYTE     BCC     XXC641          ; EXIT IF TEMP < THIS LINE, TARGE%T LINE PASSED     BEQ     XXC641          ; EXIT IF TEMP = (FOUND LINE#)                         ; NOT QUITE THERE YETXXC637 = *     DEY                    ; DECREMENT INDEX TO NEXT LINE POINTER HIGH BYTE     LDA     (XX5F),Y          ; GET NEXT L&INE POINTER HIGH BYTE     TAX                    ; COPY TO X     DEY                    ; DECREMENT INDEX TO NEXT LINE POINTER LOW BYTE     LDA     (XX5F),Y          ; GET NEXT LINE POINTER LOW BYTE     BCS     XXC617          ; GO SEARCH FOR LINE # 'IN TEMPORARY INTEGER                         ; FROM AX, CARRY ALWAYS SETXXC640 = *     CLC                    ; CLEAR FOUND FLAGXXC641 = *     RTS;***********************************************************************************;;; PERFORM N EWXXC642 = *     BNE     XXC641          ; EXIT IF FOLLOWING BYTE TO ALLOW SYNTAX ERRORXXC644 = *     LDA     #$00               ; CLEAR A     TAY                    ; CLEAR INDEX     STA     (XX2B),Y          ; CLEAR POINTER TO NEXT LINE LOW BYT      ; CLEAR A     STA     XX13          ; CLEAR CURRENT I/O CHANNEL, FLAG DEFAULT     JSR     XXCAD7          ; PRINT CR/LF     JSR     XXCB45          ; PRINT '?'     LDY     #$00               ; CLEAR INDEXXXC456 = *     LDA     (XX22),Y           ; GET BYTE FROM MESSAGE     PHA                    ; SAVE STATUS     AND     #$7F               ; MASK 0XXX XXXX, CLEAR B7     JSR     XXCB47          ; OUTPUT CHARACTER     INY                    ; INCREMENT INDEX     PLA                    ; RES TORE STATUS     BPL     XXC456          ; LOOP IF CHARACTER WAS NOT END MARKER     JSR     XXC67A          ; FLUSH BASIC STACK AND CLEAR CONTINUE POINTER     LDA     #<XXC369          ; SET ' ERROR' POINTER LOW BYTE     LDY     #>XXC369          ; S ET ' ERROR' POINTER HIGH BYTE;***********************************************************************************;;; PRINT STRING AND DO WARM START, BREAK ENTRYXXC469 = *     JSR     XXCB1E          ; PRINT NULL TERMINATED STRING     LDY     XX3 A          ; GET CURRENT LINE NUMBER HIGH BYTE     INY                    ; INCREMENT IT     BEQ     XXC474          ; BRANCH IF WAS IN IMMEDIATE MODE     JSR     XXDDC2          ; DO ' IN ' LINE NUMBER MESSAGE;************************************ ***********************************************;;; DO WARM STARTXXC474 = *     LDA     #<XXC376          ; SET 'READY.' POINTER LOW BYTE     LDY     #>XXC376          ; SET 'READY.' POINTER HIGH BYTE     JSR     XXCB1E          ; PRINT NULL TERMIN ATED STRING     LDA     #$80               ; SET FOR CONTROL MESSAGES ONLY     JSR     XXFF90          ; CONTROL KERNAL MESSAGESXXC480 = *     JMP     (XX0302)          ; DO BASIC WARM START;******************************************************** ***************************;;; BASIC WARM START, THE WARM START VECTOR IS INITIALISED TO POINT HEREXXC483 = *     JSR     XXC560          ; CALL FOR BASIC INPUT     STX     XX7A          ; SAVE BASIC EXECUTE POINTER LOW BYTE     STY     XX7B       	    ; SAVE BASIC EXECUTE POINTER HIGH BYTE     JSR     XX0073          ; INCREMENT AND SCAN MEMORY     TAX                    ; COPY BYTE TO SET FLAGS     BEQ     XXC480          ; LOOP IF NO INPUT; GOT TO INTERPRET INPUT LINE NOW ....     LDX     
 #$FF               ; CURRENT LINE HIGH BYTE TO -1, INDICATES IMMEDIATE MODE     STX     XX3A          ; SET CURRENT LINE NUMBER HIGH BYTE     BCC     XXC49C          ; IF NUMERIC CHARACTER GO HANDLE NEW BASIC LINE                         ; NO LINE N UMBER .. IMMEDIATE MODE     JSR     XXC579          ; CRUNCH KEYWORDS INTO BASIC TOKENS     JMP     XXC7E1          ; GO SCAN AND INTERPRET CODE; HANDLE NEW BASIC LINEXXC49C = *     JSR     XXC96B          ; GET FIXED-POINT NUMBER INTO TEMPORARY I NTEGER     JSR     XXC579          ; CRUNCH KEYWORDS INTO BASIC TOKENS     STY     XX0B          ; SAVE INDEX POINTER TO END OF CRUNCHED LINE     JSR     XXC613          ; SEARCH BASIC FOR TEMPORARY INTEGER LINE NUMBER     BCC     XXC4ED          ; I F NOT FOUND SKIP THE LINE DELETE                         ; LINE # ALREADY EXISTS SO DELETE IT     LDY     #$01               ; SET INDEX TO NEXT LINE POINTER HIGH BYTE     LDA     (XX5F),Y          ; GET NEXT LINE POINTER HIGH BYTE     STA     XX23           ; SAVE IT     LDA     XX2D          ; GET START OF VARIABLES LOW BYTE     STA     XX22          ; SAVE IT     LDA     XX60          ; GET FOUND LINE POINTER HIGH BYTE     STA     XX25          ; SAVE IT     LDA     XX5F          ; GET FOUND  LINE POINTER LOW BYTE     DEY                    ; DECREMENT INDEX     SBC     (XX5F),Y          ; SUBTRACT NEXT LINE POINTER LOW BYTE     CLC                    ; CLEAR CARRY FOR ADD     ADC     XX2D          ; ADD START OF VARIABLES LOW BYTE      STA     XX2D          ; SET START OF VARIABLES LOW BYTE     STA     XX24          ; SAVE DESTINATION POINTER LOW BYTE     LDA     XX2E          ; GET START OF VARIABLES HIGH BYTE     ADC     #$FF               ; -1 + CARRY     STA     XX2E          ;  SET START OF VARIABLES HIGH BYTE     SBC     XX60          ; SUBTRACT FOUND LINE POINTER HIGH BYTE     TAX                    ; COPY TO BLOCK COUNT     SEC                    ; SET CARRY FOR SUBTRACT     LDA     XX5F          ; GET FOUND LINE POINTE R LOW BYTE     SBC     XX2D          ; SUBTRACT START OF VARIABLES LOW BYTE     TAY                    ; COPY TO BYTES IN FIRST BLOCK COUNT     BCS     XXC4D7          ; IF NO UNDERFLOW SKIP THE HIGH BYTE DECREMENT     INX                    ; INCRE MENT BLOCK COUNT, CORRECT FOR = 0 LOOP EXIT     DEC     XX25          ; DECREMENT DESTINATION HIGH BYTEXXC4D7 = *     CLC                    ; CLEAR CARRY FOR ADD     ADC     XX22          ; ADD SOURCE POINTER LOW BYTE     BCC     XXC4DF          ;  IF NO UNDERFLOW SKIP THE HIGH BYTE DECREMENT     DEC     XX23          ; ELSE DECREMENT SOURCE POINTER HIGH BYTE     CLC                    ; CLEAR CARRY                         ; CLOSE UP MEMORY TO DELETE OLD LINEXXC4DF = *     LDA     (XX22),Y           ; GET BYTE FROM SOURCE     STA     (XX24),Y          ; COPY TO DESTINATION     INY                    ; INCREMENT INDEX     BNE     XXC4DF          ; WHILE <> 0 DO THIS BLOCK     INC     XX23          ; INCREMENT SOURCE POINTER HIGH BYTE      INC     XX25          ; INCREMENT DESTINATION POINTER HIGH BYTE     DEX                    ; DECREMENT BLOCK COUNT     BNE     XXC4DF          ; LOOP UNTIL ALL DONE                         ; GOT NEW LINE IN BUFFER AND NO EXISTING SAME #XXC4ED = *      JSR     XXC659          ; RESET EXECUTION TO START, CLEAR VARIABLES, FLUSH STACK                         ; AND RETURN     JSR     XXC533          ; REBUILD BASIC LINE CHAINING     LDA     XX0200          ; GET FIRST BYTE FROM BUFFER     BEQ      XXC480          ; IF NO LINE GO DO BASIC WARM START                         ; ELSE INSERT LINE INTO MEMORY     CLC                    ; CLEAR CARRY FOR ADD     LDA     XX2D          ; GET START OF VARIABLES LOW BYTE     STA     XX5A          ; SAVE  AS SOURCE END POINTER LOW BYTE     ADC     XX0B          ; ADD INDEX POINTER TO END OF CRUNCHED LINE     STA     XX58          ; SAVE AS DESTINATION END POINTER LOW BYTE     LDY     XX2E          ; GET START OF VARIABLES HIGH BYTE     STY     XX5B           ; SAVE AS SOURCE END POINTER HIGH BYTE     BCC     XXC508          ; IF NO CARRY SKIP THE HIGH BYTE INCREMENT     INY                    ; ELSE INCREMENT THE HIGH BYTEXXC508 = *     STY     XX59          ; SAVE AS DESTINATION END POINTER HIGH  BYTE     JSR     XXC3B8          ; OPEN UP SPACE IN MEMORY; MOST OF WHAT REMAINS TO DO IS COPY THE CRUNCHED LINE INTO THE SPACE OPENED UP IN MEMORY,; HOWEVER, BEFORE THE CRUNCHED LINE COMES THE NEXT LINE POINTER AND THE LINE NUMBER. THE; LINE NUMBE R IS RETRIEVED FROM THE TEMPORARY INTEGER AND STORED IN MEMORY, THIS; OVERWRITES THE BOTTOM TWO BYTES ON THE STACK. NEXT THE LINE IS COPIED AND THE NEXT LINE; POINTER IS FILLED WITH WHATEVER WAS IN TWO BYTES ABOVE THE LINE NUMBER IN THE STACK.; THIS I S OK BECAUSE THE LINE POINTER GETS FIXED IN THE LINE CHAIN RE-BUILD.     LDA     XX14          ; GET LINE NUMBER LOW BYTE     LDY     XX15          ; GET LINE NUMBER HIGH BYTE     STA     XX01FE          ; SAVE LINE NUMBER LOW BYTE BEFORE CRUNCHED LI NE     STY     XX01FF          ; SAVE LINE NUMBER HIGH BYTE BEFORE CRUNCHED LINE     LDA     XX31          ; GET END OF ARRAYS LOW BYTE     LDY     XX32          ; GET END OF ARRAYS HIGH BYTE     STA     XX2D          ; SET START OF VARIABLES LOW BYT E     STY     XX2E          ; SET START OF VARIABLES HIGH BYTE     LDY     XX0B          ; GET INDEX TO END OF CRUNCHED LINE     DEY                    ; -1XXC522 = *     LDA     XX01FC,Y          ; GET BYTE FROM CRUNCHED LINE     STA     (XX5F),Y            ; SAVE BYTE TO MEMORY     DEY                    ; DECREMENT INDEX     BPL     XXC522          ; LOOP WHILE MORE TO DO; RESET EXECUTION, CLEAR VARIABLES, FLUSH STACK, REBUILD BASIC CHAIN AND DO WARM STARTXXC52A = *     JSR     XXC659      !     ; RESET EXECUTION TO START, CLEAR VARIABLES AND FLUSH STACK     JSR     XXC533          ; REBUILD BASIC LINE CHAINING     JMP     XXC480          ; GO DO BASIC WARM START;************************************************************************* "**********;;; REBUILD BASIC LINE CHAININGXXC533 = *     LDA     XX2B          ; GET START OF MEMORY LOW BYTE     LDY     XX2C          ; GET START OF MEMORY HIGH BYTE     STA     XX22          ; SET LINE START POINTER LOW BYTE     STY     XX23    #       ; SET LINE START POINTER HIGH BYTE     CLC                    ; CLEAR CARRY FOR ADDXXC53C = *     LDY     #$01               ; SET INDEX TO POINTER TO NEXT LINE HIGH BYTE     LDA     (XX22),Y          ; GET POINTER TO NEXT LINE HIGH BYTE      $BEQ     XXC55F          ; EXIT IF NULL, [EOT]     LDY     #$04               ; POINT TO FIRST CODE BYTE OF LINE                         ; THERE IS ALWAYS 1 BYTE + [EOL] AS NULL ENTRIES ARE DELETEDXXC544 = *     INY                    ; NEXT CODE BYT %E     LDA     (XX22),Y          ; GET BYTE     BNE     XXC544          ; LOOP IF NOT [EOL]     INY                    ; POINT TO BYTE PAST [EOL], START OF NEXT LINE     TYA                    ; COPY IT     ADC     XX22          ; ADD LINE START POI &NTER LOW BYTE     TAX                    ; COPY TO X     LDY     #$00               ; CLEAR INDEX, POINT TO THIS LINE'S NEXT LINE POINTER     STA     (XX22),Y          ; SET NEXT LINE POINTER LOW BYTE     LDA     XX23          ; GET LINE START POINTE 'R HIGH BYTE     ADC     #$00               ; ADD ANY OVERFLOW     INY                    ; INCREMENT INDEX TO HIGH BYTE     STA     (XX22),Y          ; SET NEXT LINE POINTER HIGH BYTE     STX     XX22          ; SET LINE START POINTER LOW BYTE     S TA     XX23          ; SET LINE START POINTER HIGH BYTE     BCC     XXC53C          ; GO DO NEXT LINE, BRANCH ALWAYSXXC55F = *     RTS;***********************************************************************************;;; CALL FOR BASIC INPUTX!OINTER TABLEXXC328 = *     .WORD     XXC19E          ; $01     TOO MANY FILES     .WORD     XXC1AC          ; $02     FILE OPEN     .WORD     XXC1B5          ; $03     FILE NOT OPEN     .WORD     XXC1C2          ; $04     FILE NOT FOUND     .WORD !    XXC1D0          ; $05     DEVICE NOT PRESENT     .WORD     XXC1E2          ; $06     NOT INPUT FILE     .WORD     XXC1F0          ; $07     NOT OUTPUT FILE     .WORD     XXC1FF          ; $08     MISSING FILE NAME     .WORD     XXC210          ; !$09     ILLEGAL DEVICE NUMBER     .WORD     XXC225          ; $0A     NEXT WITHOUT FOR     .WORD     XXC235          ; $0B     SYNTAX     .WORD     XXC23B          ; $0C     RETURN WITHOUT GOSUB     .WORD     XXC24F          ; $0D     OUT OF DATA   !  .WORD     XXC25A          ; $0E     ILLEGAL QUANTITY     .WORD     XXC26A          ; $0F     OVERFLOW     .WORD     XXC272          ; $10     OUT OF MEMORY     .WORD     XXC27F          ; $11     UNDEF'D STATEMENT     .WORD     XXC290          ; $1!2     BAD SUBSCRIPT     .WORD     XXC29D          ; $13     REDIM'D ARRAY     .WORD     XXC2AA          ; $14     DIVISION BY ZERO     .WORD     XXC2BA          ; $15     ILLEGAL DIRECT     .WORD     XXC2C8          ; $16     TYPE MISMATCH     .WORD!     XXC2D5          ; $17     STRING TOO LONG     .WORD     XXC2E4          ; $18     FILE DATA     .WORD     XXC2ED          ; $19     FORMULA TOO COMPLEX     .WORD     XXC300          ; $1A     CAN'T CONTINUE     .WORD     XXC30E          ; $1B   !  UNDEF'D FUNCTION     .WORD     XXC31E          ; $1C     VERIFY     .WORD     XXC324          ; $1D     LOAD     .WORD     XXC383          ; $1E     BREAK;***********************************************************************************;;; BA!SIC MESSAGESXXC364 = *     .BYTE     $0D,'OK',$0D,$00XXC369 = *     .BYTE     $0D,' ERROR',$00XXC371 = *     .BYTE     ' IN ',$00XXC376 = *     .BYTE     $0D,$0A,'READY.',$0D,$0A,$00XXC381 = *     .BYTE     $0D,$0AXXC383 = *     .BYTE     'B!	REAK',$00;***********************************************************************************;;; SPARE BYTE, NOT REFERENCED;XXC389     .BYTE     $A0;***********************************************************************************;;; SEARC!
H THE STACK FOR FOR OR GOSUB ACTIVITY; RETURN ZB=1 IF FOR VARIABLE FOUNDXXC38A = *     TSX                    ; COPY STACK POINTER     INX                    ; +1 PASS RETURN ADDRESS     INX                    ; +2 PASS RETURN ADDRESS     INX     !               ; +3 PASS CALLING ROUTINE RETURN ADDRESS     INX                    ; +4 PASS CALLING ROUTINE RETURN ADDRESSXXC38F = *     LDA     XX0100+1,X     ; GET TOKEN BYTE FROM STACK     CMP     #TFOR          ; IS IT FOR TOKEN     BNE     XXC!3B7          ; EXIT IF NOT FOR TOKEN                         ; WAS FOR TOKEN     LDA     XX4A          ; GET FOR/NEXT VARIABLE POINTER HIGH BYTE     BNE     XXC3A4          ; BRANCH IF NOT NULL     LDA     XX0100+2,X     ; GET FOR VARIABLE POINTER !LOW BYTE     STA     XX49          ; SAVE FOR/NEXT VARIABLE POINTER LOW BYTE     LDA     XX0100+3,X     ; GET FOR VARIABLE POINTER HIGH BYTE     STA     XX4A          ; SAVE FOR/NEXT VARIABLE POINTER HIGH BYTEXXC3A4 = *     CMP     XX0100+3,X     ; !COMPARE VARIABLE POINTER WITH STACKED VARIABLE POINTER                         ; HIGH BYTE     BNE     XXC3B0          ; BRANCH IF NO MATCH     LDA     XX49          ; GET FOR/NEXT VARIABLE POINTER LOW BYTE     CMP     XX0100+2,X     ; COMPARE VARIA!BLE POINTER WITH STACKED VARIABLE POINTER                         ; LOW BYTE     BEQ     XXC3B7          ; EXIT IF MATCH FOUNDXXC3B0 = *     TXA                    ; COPY INDEX     CLC                    ; CLEAR CARRY FOR ADD     ADC     #$12     !          ; ADD FOR STACK USE SIZE     TAX                    ; COPY BACK TO INDEX     BNE     XXC38F          ; LOOP IF NOT AT START OF STACKXXC3B7 = *     RTS;***********************************************************************************;!;; OPEN UP SPACE IN MEMORY, SET END OF ARRAYSXXC3B8 = *     JSR     XXC408          ; CHECK AVAILABLE MEMORY, DO OUT OF MEMORY ERROR IF NO ROOM     STA     XX31          ; SET END OF ARRAYS LOW BYTE     STY     XX32          ; SET END OF ARRAYS HIG!H BYTE; OPEN UP SPACE IN MEMORY, DON'T SET ARRAY ENDXXC3BF = *     SEC                    ; SET CARRY FOR SUBTRACT     LDA     XX5A          ; GET BLOCK END LOW BYTE     SBC     XX5F          ; SUBTRACT BLOCK START LOW BYTE     STA     XX22      !    ; SAVE MOD(BLOCK LENGTH/$100) BYTE     TAY                    ; COPY MOD(BLOCK LENGTH/$100) BYTE TO Y     LDA     XX5B          ; GET BLOCK END HIGH BYTE     SBC     XX60          ; SUBTRACT BLOCK START HIGH BYTE     TAX                    ; COPY! BLOCK LENGTH HIGH BYTE TO X     INX                    ; +1 TO ALLOW FOR COUNT=0 EXIT     TYA                    ; COPY BLOCK LENGTH LOW BYTE TO A     BEQ     XXC3F3          ; BRANCH IF LENGTH LOW BYTE=0                         ; BLOCK IS (X-1)*25!6+Y BYTES, DO THE Y BYTES FIRST     LDA     XX5A          ; GET BLOCK END LOW BYTE     SEC                    ; SET CARRY FOR SUBTRACT     SBC     XX22          ; SUBTRACT MOD(BLOCK LENGTH/$100) BYTE     STA     XX5A          ; SAVE CORRECTED OLD BLO!CK END LOW BYTE     BCS     XXC3DC          ; IF NO UNDERFLOW SKIP THE HIGH BYTE DECREMENT     DEC     XX5B          ; ELSE DECREMENT BLOCK END HIGH BYTE     SEC                    ; SET CARRY FOR SUBTRACTXXC3DC = *     LDA     XX58          ; GET !DESTINATION END LOW BYTE     SBC     XX22          ; SUBTRACT MOD(BLOCK LENGTH/$100) BYTE     STA     XX58          ; SAVE MODIFIED NEW BLOCK END LOW BYTE     BCS     XXC3EC          ; IF NO UNDERFLOW SKIP THE HIGH BYTE DECREMENT     DEC     XX59   !       ; ELSE DECREMENT BLOCK END HIGH BYTE     BCC     XXC3EC          ; BRANCH ALWAYSXXC3E8 = *     LDA     (XX5A),Y          ; GET BYTE FROM SOURCE     STA     (XX58),Y          ; COPY BYTE TO DESTINATIONXXC3EC = *     DEY                    ; !DECREMENT INDEX     BNE     XXC3E8          ; LOOP UNTIL Y=0                         ; NOW DO Y=0 INDEXED BYTE     LDA     (XX5A),Y          ; GET BYTE FROM SOURCE     STA     (XX58),Y          ; SAVE BYTE TO DESTINATIONXXC3F3 = *     DEC     XX5B!          ; DECREMENT SOURCE POINTER HIGH BYTE     DEC     XX59          ; DECREMENT DESTINATION POINTER HIGH BYTE     DEX                    ; DECREMENT BLOCK COUNT     BNE     XXC3EC          ; LOOP UNTIL COUNT = $0     RTS;********************!***************************************************************;;; CHECK THERE IS ROOM ON THE STACK FOR A BYTES; IF THE STACK IS TOO DEEP DO AN OUT OF MEMORY ERRORXXC3FB = *     ASL A                  ; *2     ADC     #$3E               ; NEED AT !LEAST $3E BYTES FREE     BCS     XXC435          ; IF OVERFLOW GO DO OUT OF MEMORY ERROR THEN WARM START     STA     XX22          ; SAVE RESULT IN TEMP BYTE     TSX                    ; COPY STACK     CPX     XX22          ; COMPARE NEW LIMIT WITH !STACK     BCC     XXC435          ; IF STACK < LIMIT DO OUT OF MEMORY ERROR THEN WARM START     RTS;***********************************************************************************;;; CHECK AVAILABLE MEMORY, DO OUT OF MEMORY ERROR IF NO ROOM!XXC408 = *     CPY     XX34          ; COMPARE WITH BOTTOM OF STRING SPACE HIGH BYTE     BCC     XXC434          ; IF LESS THEN EXIT (IS OK)     BNE     XXC412          ; SKIP NEXT TEST IF GREATER (TESTED <)                         ; HIGH BYTE WAS !=, NOW DO LOW BYTE     CMP     XX33          ; COMPARE WITH BOTTOM OF STRING SPACE LOW BYTE     BCC     XXC434          ; IF LESS THEN EXIT (IS OK)                         ; ADDRESS IS > STRING STORAGE PTR (OOPS!)XXC412 = *     PHA                 !    ; PUSH ADDRESS LOW BYTE     LDX     #$09               ; SET INDEX TO SAVE XX57 TO XX60 INCLUSIVE     TYA                    ; COPY ADDRESS HIGH BYTE (TO PUSH ON STACK)                         ; SAVE MISC NUMERIC WORK AREAXXC416 = *     PHA     !!               ; PUSH BYTE     LDA     XX57,X          ; GET BYTE FROM XX57 TO XX60     DEX                    ; DECREMENT INDEX     BPL     XXC416          ; LOOP UNTIL ALL DONE     JSR     XXD526          ; DO GARBAGE COLLECTION ROUTINE         !"                ; RESTORE MISC NUMERIC WORK AREA     LDX     #$F7               ; SET INDEX TO RESTORE BYTESXXC421 = *     PLA                    ; POP BYTE     STA     XX60+1,X          ; SAVE BYTE TO XX57 TO XX60     INX                    ; INCRE!#MENT INDEX     BMI     XXC421          ; LOOP WHILE -VE     PLA                    ; POP ADDRESS HIGH BYTE     TAY                    ; COPY BACK TO Y     PLA                    ; POP ADDRESS LOW BYTE     CPY     XX34          ; COMPARE WITH BOTTOM!$ OF STRING SPACE HIGH BYTE     BCC     XXC434          ; IF LESS THEN EXIT (IS OK)     BNE     XXC435          ; IF GREATER DO OUT OF MEMORY ERROR THEN WARM START                         ; HIGH BYTE WAS =, NOW DO LOW BYTE     CMP     XX33          !%; COMPARE WITH BOTTOM OF STRING SPACE LOW BYTE     BCS     XXC435          ; IF >= DO OUT OF MEMORY ERROR THEN WARM START                         ; OK EXIT, CARRY CLEARXXC434 = *     RTS;***********************************************************!&************************;;; DO OUT OF MEMORY ERROR THEN WARM STARTXXC435 = *     LDX     #$10               ; ERROR CODE $10, OUT OF MEMORY ERROR; DO ERROR #X THEN WARM STARTXXC437 = *     JMP     (XX0300)          ; DO ERROR MESSAGE; DO ERRO!'R #X THEN WARM START, THE ERROR MESSAGE VECTOR IS INITIALISED TO POINT HEREXXC43A = *     TXA                    ; COPY ERROR NUMBER     ASL A                  ; *2     TAX                    ; COPY TO INDEX     LDA     XXC328-2,X     ; GET ERROR M  ESSAGE POINTER LOW BYTE     STA     XX22          ; SAVE IT     LDA     XXC328-1,X     ; GET ERROR MESSAGE POINTER HIGH BYTE     STA     XX23          ; SAVE IT     JSR     XXFFCC          ; CLOSE INPUT AND OUTPUT CHANNELS     LDA     #$00          "NAME, UNREFERENCED;***********************************************************************************;;; ACTION ADDRESSES FOR PRIMARY COMMANDS. THESE ARE CALLED BY PUSHING THE ADDRESS; ONTO THE STACK AND DOING AN RTS SO THE ACTUAL ADDRESS -1 NEEDS" TO BE PUSHEDXXC00C = *     .WORD     XXC831-1          ; PERFORM END     .WORD     XXC742-1          ; PERFORM FOR     .WORD     XXCD1E-1          ; PERFORM NEXT     .WORD     XXC8F8-1          ; PERFORM DATA     .WORD     XXCBA5-1          ; PER"FORM INPUT#     .WORD     XXCBBF-1          ; PERFORM INPUT     .WORD     XXD081-1          ; PERFORM DIM     .WORD     XXCC06-1          ; PERFORM READ     .WORD     XXC9A5-1          ; PERFORM LET     .WORD     XXC8A0-1          ; PERFORM GOTO  "   .WORD     XXC871-1          ; PERFORM RUN     .WORD     XXC928-1          ; PERFORM IF     .WORD     XXC81D-1          ; PERFORM RESTORE     .WORD     XXC883-1          ; PERFORM GOSUB     .WORD     XXC8D2-1          ; PERFORM RETURN     .WORD   "  XXC93B-1          ; PERFORM REM     .WORD     XXC82F-1          ; PERFORM STOP     .WORD     XXC94B-1          ; PERFORM ON     .WORD     XXD82D-1          ; PERFORM WAIT     .WORD     XXE165-1          ; PERFORM LOAD     .WORD     XXE153-1      "    ; PERFORM SAVE     .WORD     XXE162-1          ; PERFORM VERIFY     .WORD     XXD3B3-1          ; PERFORM DEF     .WORD     XXD824-1          ; PERFORM POKE     .WORD     XXCA80-1          ; PERFORM PRINT#     .WORD     XXCAA0-1          ; PERF"ORM PRINT     .WORD     XXC857-1          ; PERFORM CONT     .WORD     XXC69C-1          ; PERFORM LIST     .WORD     XXC65E-1          ; PERFORM CLR     .WORD     XXCA86-1          ; PERFORM CMD     .WORD     XXE127-1          ; PERFORM SYS     .W"ORD     XXE1BB-1          ; PERFORM OPEN     .WORD     XXE1C4-1          ; PERFORM CLOSE     .WORD     XXCB7B-1          ; PERFORM GET     .WORD     XXC642-1          ; PERFORM NEW;******************************************************************"	*****************;;; ACTION ADDRESSES FOR FUNCTIONSXXC052 = *     .WORD     XXDC39          ; PERFORM SGN()     .WORD     XXDCCC          ; PERFORM INT()     .WORD     XXDC58          ; PERFORM ABS()     .WORD     XX00          ; PERFORM USR() "
    .WORD     XXD37D          ; PERFORM FRE()     .WORD     XXD39E          ; PERFORM POS()     .WORD     XXDF71          ; PERFORM SQR()     .WORD     XXE094          ; PERFORM RND()     .WORD     XXD9EA          ; PERFORM LOG()     .WORD     XXDFE"D          ; PERFORM EXP()     .WORD     XXE261          ; PERFORM COS()     .WORD     XXE268          ; PERFORM SIN()     .WORD     XXE2B1          ; PERFORM TAN()     .WORD     XXE30B          ; PERFORM ATN()     .WORD     XXD80D          ; PERFO"RM PEEK()     .WORD     XXD77C          ; PERFORM LEN()     .WORD     XXD465          ; PERFORM STR$()     .WORD     XXD7AD          ; PERFORM VAL()     .WORD     XXD78B          ; PERFORM ASC()     .WORD     XXD6EC          ; PERFORM CHR$()     ."WORD     XXD700          ; PERFORM LEFT$()     .WORD     XXD72C          ; PERFORM RIGHT$()     .WORD     XXD737          ; PERFORM MID$();***********************************************************************************;;; PRECEDENCE BYTE AND A"CTION ADDRESSES FOR OPERATORS. LIKE THE PRIMARRY COMMANDS THESE; ARE CALLED BY PUSHING THE ADDRESS ONTO THE STACK AND DOING AN RTS, SO AGAIN THE ACTUAL; ADDRESS -1 NEEDS TO BE PUSHEDXXC080 = *     .BYTE     $79     .WORD     XXD86A-1          ; + "    .BYTE     $79     .WORD     XXD853-1          ; -     .BYTE     $7B     .WORD     XXDA2B-1          ; *     .BYTE     $7B     .WORD     XXDB12-1          ; /     .BYTE     $7F     .WORD     XXDF7B-1          ; ^     .BYTE     $50     .WORD  "   XXCFE9-1          ; AND     .BYTE     $46     .WORD     XXCFE6-1          ; OR     .BYTE     $7D     .WORD     XXDFB4-1          ; >     .BYTE     $5A     .WORD     XXCED4-1          ; =XXC09B = *     .BYTE     $64     .WORD     XXD016-1     "     ; <;***********************************************************************************;;; BASIC KEYWORDS. EACH WORD HAS B7 SET IN IT'S LAST CHARACTER AS AN END MARKER,; EVEN THE ONE CHARACTER KEYWORDS SUCH AS '<' OR '='; FIRST ARE THE PRIMA"RY COMMAND KEYWORDS, ONLY THESE CAN START A STATEMENTXXC09E = *     .BYTE     'EN',$C4     ;'D'+$80     ; END     .BYTE     'FO',$D2     ;'R'+$80     ; FOR     .BYTE     'NEX',$D4    ;'T'+$80     ; NEXT     .BYTE     'DAT',$C1    ;'A'+$80     ; DAT"A     .BYTE     'INPUT',$A3  ;'#'+$80     ; INPUT#     .BYTE     'INPU',$D4   ;'T'+$80     ; INPUT     .BYTE     'DI',$CD     ;'M'+$80     ; DIM     .BYTE     'REA',$C4    ;'D'+$80     ; READ     .BYTE     'LE',$D4     ;'T'+$80     ; LET     .BYTE"     'GOT',$CF    ;'O'+$80     ; GOTO     .BYTE     'RU',$CE     ;'N'+$80     ; RUN     .BYTE     'I',$C6      ;'F'+$80     ; IF     .BYTE     'RESTOR',$C5 ;'E'+$80     ; RESTORE     .BYTE     'GOSU',$C2   ;'B'+$80     ; GOSUB     .BYTE     'RETUR',"$CE  ;'N'+$80     ; RETURN     .BYTE     'RE',$CD     ;'M'+$80     ; REM     .BYTE     'STO',$D0    ;'P'+$80     ; STOP     .BYTE     'O',$CE      ;'N'+$80     ; ON     .BYTE     'WAI',$D4    ;'T'+$80     ; WAIT     .BYTE     'LOA',$C4    ;'D'+$80 "    ; LOAD     .BYTE     'SAV',$C5    ;'E'+$80     ; SAVE     .BYTE     'VERIF',$D9  ;'Y'+$80     ; VERIFY     .BYTE     'DE',$C6     ;'F'+$80     ; DEF     .BYTE     'POK',$C5    ;'E'+$80     ; POKE     .BYTE     'PRINT',$A3  ;'#'+$80     ; PRINT#"     .BYTE     'PRIN',$D4   ;'T'+$80     ; PRINT     .BYTE     'CON',$D4    ;'T'+$80     ; CONT     .BYTE     'LIS',$D4    ;'T'+$80     ; LIST     .BYTE     'CL',$D2     ;'R'+$80     ; CLR     .BYTE     'CM',$C4     ;'D'+$80     ; CMD     .BYTE    " 'SY',$D3     ;'S'+$80     ; SYS     .BYTE     'OPE',$CE    ;'N'+$80     ; OPEN     .BYTE     'CLOS',$C5   ;'E'+$80     ; CLOSE     .BYTE     'GE',$D4     ;'T'+$80     ; GET     .BYTE     'NE',$D7     ;'W'+$80     ; NEW; NEXT ARE THE SECONDARY COM"MAND KEYWORDS, THESE CAN NOT START A STATEMENT     .BYTE     'TAB',$A8    ;'('+$80     ; TAB(     .BYTE     'T',$CF      ;'O'+$80     ; TO     .BYTE     'F',$CE      ;'N'+$80     ; FN     .BYTE     'SPC',$A8    ;'('+$80     ; SPC(     .BYTE     'TH"E',$CE    ;'N'+$80     ; THEN     .BYTE     'NO',$D4     ;'T'+$80     ; NOT     .BYTE     'STE',$D0    ;'P'+$80     ; STEP; THE OPERATORS     .BYTE     $AB          ;'+'+$80     ; +     .BYTE     $AD          ;'-'+$80     ; -     .BYTE     $AA  "        ;'*'+$80     ; *     .BYTE     $AF          ;'/'+$80     ; /     .BYTE     $DE          ;'^'+$80     ; ^     .BYTE     'AN',$C4     ;'D'+$80     ; AND     .BYTE     'O',$D2      ;'R'+$80     ; OR     .BYTE     $BE          ;'>'+$80     ; >"     .BYTE     $BD          ;'='+$80     ; =     .BYTE     $BC          ;'<'+$80     ; <; THE FUNCTIONS     .BYTE     'SG',$CE     ;'N'+$80     ; SGN     .BYTE     'IN',$D4     ;'T'+$80     ; INT     .BYTE     'AB',$D3     ;'S'+$80     ; ABS     ".BYTE     'US',$D2     ;'R'+$80     ; USR     .BYTE     'FR',$C5     ;'E'+$80     ; FRE     .BYTE     'PO',$D3     ;'S'+$80     ; POS     .BYTE     'SQ',$D2     ;'R'+$80     ; SQR     .BYTE     'RN',$C4     ;'D'+$80     ; RND     .BYTE     'LO',$C7"     ;'G'+$80     ; LOG     .BYTE     'EX',$D0     ;'P'+$80     ; EXP     .BYTE     'CO',$D3     ;'S'+$80     ; COS     .BYTE     'SI',$CE     ;'N'+$80     ; SIN     .BYTE     'TA',$CE     ;'N'+$80     ; TAN     .BYTE     'AT',$CE     ;'N'+$80     "; ATN     .BYTE     'PEE',$CB    ;'K'+$80   ; PEEK     .BYTE     'LE',$CE     ;'N'+$80     ; LEN     .BYTE     'STR',$A4    ;'$'+$80     ; STR$     .BYTE     'VA',$CC     ;'L'+$80     ; VAL     .BYTE     'AS',$C3     ;'C'+$80     ; ASC     .BYTE   "   'CHR',$A4    ;'$'+$80     ; CHR$     .BYTE     'LEFT',$A4   ;'$'+$80     ; LEFT$     .BYTE     'RIGHT',$A4  ;'$'+$80     ; RIGHT$     .BYTE     'MID',$A4    ;'$'+$80     ; MID$; LASTLY IS GO, THIS IS AN ADD ON SO THAT GO TO, AS WELL AS GOTO, WILL"! WORK     .BYTE     'G',$CF      ;'O'+$80     ; GO     .BYTE     $00                       ; END MARKER;***********************************************************************************;;; ERROR MESSAGESXXC19E = *     .BYTE     'TOO MANY FI""LE',$D3        ;'S'+$80XXC1AC = *     .BYTE     'FILE OPE',$CE             ;'N'+$80XXC1B5 = *     .BYTE     'FILE NOT OPE',$CE         ;'N'+$80XXC1C2 = *     .BYTE     'FILE NOT FOUN',$C4        ;'D'+$80XXC1D0 = *     .BYTE     'DEVICE NOT PRESEN"#',$D4    ;'T'+$80XXC1E2 = *     .BYTE     'NOT INPUT FIL',$C5        ;'E'+$80XXC1F0 = *     .BYTE     'NOT OUTPUT FIL',$C5       ;'E'+$80XXC1FF = *     .BYTE     'MISSING FILE NAM',$C5     ;'E'+$80XXC210 = *     .BYTE     'ILLEGAL DEVICE NUMBE',$"$D2 ;'R'+$80XXC225 = *     .BYTE     'NEXT WITHOUT FO',$D2      ;'R'+$80XXC235 = *     .BYTE     'SYNTA',$D8                ;'X'+$80XXC23B = *     .BYTE     'RETURN WITHOUT GOSU',$C2  ;'B'+$80XXC24F = *     .BYTE     'OUT OF DAT',$C1           ;'A"%'+$80XXC25A = *     .BYTE     'ILLEGAL QUANTIT',$D9      ;'Y'+$80XXC26A = *     .BYTE     'OVERFLO',$D7              ;'W'+$80XXC272 = *     .BYTE     'OUT OF MEMOR',$D9         ;'Y'+$80XXC27F = *     .BYTE     'UNDEF''D STATEMEN',$D4    ;'T'+$80"&XXC290 = *     .BYTE     'BAD SUBSCRIP',$D4         ;'T'+$80XXC29D = *     .BYTE     'REDIM''D ARRA',$D9        ;'Y'+$80XXC2AA = *     .BYTE     'DIVISION BY ZER',$CF      ;'O'+$80XXC2BA = *     .BYTE     'ILLEGAL DIREC',$D4        ;'T'+$80XXC2C8"' = *     .BYTE     'TYPE MISMATC',$C8         ;'H'+$80XXC2D5 = *     .BYTE     'STRING TOO LON',$C7       ;'G'+$80XXC2E4 = *     .BYTE     'FILE DAT',$C1             ;'A'+$80XXC2ED = *     .BYTE     'FORMULA TOO COMPLE',$D8   ;'X'+$80XXC300 = * !     .BYTE     'CAN''T CONTINU',$C5       ;'E'+$80XXC30E = *     .BYTE     'UNDEF''D FUNCTIO',$CE     ;'N'+$80XXC31E = *     .BYTE     'VERIF',$D9                ;'Y'+$80XXC324 = *     .BYTE     'LOA',$C4                  ;'D'+$80; ERROR MESSAGE P# 010     INPUT MODE                          ; 011     INDEPENDENT INPUT MODE                         ; 100     HANDSHAKE OUTPUT MODE                         ; 101     PULSE OUTPUT MODE                         ; 110     MANUAL OUTPUT MODE, CA2 LOW  #                       ; 111     MANUAL OUTPUT MODE, CA2 HIGH                         ;  0     CA1 EDGE POSITIVE/NEGATIVE; THE STATUS BIT IS A NOT NORMAL FLAG. IT GOES HIGH IF BOTH AN INTERRUPT FLAG IN THE IFR; AND THE CORRESPONDING ENABLE BIT IN THE# IER ARE SET. IT CAN BE CLEARED ONLY BY CLEARING; ALL THE ACTIVE FLAGS IN THE IFR OR DISABLING ALL ACTIVE INTERRUPTS IN THE IERXX911D     = $911D          ; VIA 1 IFR                         ; BIT     FUNCTION          CLEARED BY                    #     ; ---     --------          ----------                         ;  7     INTERRUPT STATUS     CLEARING ALL ENABLED INTERRUPTS                         ;  6     T1 INTERRUPT     READ T1C_L, WRITE T1C_H                         ;  5     T2 INTERRUPT  #   READ T2C_L, WRITE T2C_H                         ;  4     CB1 TRANSITION     READ OR WRITE PORT B                         ;  3     CB2 TRANSITION     READ OR WRITE PORT B                         ;  2     8 SHIFTS DONE     READ OR WRITE THE SHIFT REG#ISTER                         ;  1     CA1 TRANSITION     READ OR WRITE PORT A                         ;  0     CA2 TRANSITION     READ OR WRITE PORT A; IF ENABLE/DISABLE BIT IS A ZERO DURING A WRITE TO THIS REGISTER, EACH 1 IN BITS 0-6; CLEARS THE #CORRESPONDING BIT IN THE IER. IF THIS BIT IS A ONE DURING A WRITE TO THIS; REGISTER, EACH 1 IN BITS 0-6 WILL SET THE CORRESPONDING IER BITXX911E     = $911E          ; VIA 1 IER                         ; BIT     FUNCTION                         ; --#-     --------                         ;  7     ENABLE/DISABLE                         ;  6     T1 INTERRUPT                         ;  5     T2 INTERRUPT                         ;  4     CB1 TRANSITION                         ;  3     CB2 TRANSITIO#	N                         ;  2     8 SHIFTS DONE                         ;  1     CA1 TRANSITION                         ;  0     CA2 TRANSITIONXX911F     = $911F          ; VIA 1 DRA, NO HANDSHAKE                         ; BIT     FUNCTION       #
                  ; ---     --------                         ;  7     ATN OUT                         ;  6     CASSETTE SWITCH                         ;  5     JOYSTICK FIRE, LIGHT PEN                         ;  4     JOYSTICK LEFT                  #       ;  3     JOYSTICK DOWN                         ;  2     JOYSTICK UP                         ;  1     SERIAL DAT IN                         ;  0     SERIAL CLK INXX9120     = $9120          ; VIA 2 DRB, KEYBOARD COLUMN DRIVEXX9121     = $9121#          ; VIA 2 DRA, KEYBOARD ROW PORT                         ; VIC 20 KEYBOARD MATRIX LAYOUT                         ;     C7     C6     C5     C4     C3     C2     C1     C0                         ;   +-------------------------------------------#-----                         ; R7|     [F7]     [F5]     [F3]     [F1]     [DN]     [RGT]     [RET]     [DEL]                         ; R6|     [HOME][UP]  =     [RSH]     /     ;     *                              ; R5|     -     @     :     .     #,     L     P     +                         ; R4|     0     O     K     M     N     J     I     9                         ; R3|     8     U     H     B     V     G     Y     7                         ; R2|     6     T     F     C     X     D     R    # 5                         ; R1|     4     E     S     Z     [LSH]     A     W     3                         ; R0|     2     Q     [CBM]     [SP]     [RUN]     [CTL]     [LFT]     1XX9122     = $9122          ; VIA 2 DDRBXX9123     = $9123          #; VIA 2 DDRAXX9124     = $9124          ; VIA 2 T1C_LXX9125     = $9125          ; VIA 2 T1C_HXX9128     = $9128          ; VIA 2 T2C_LXX9129     = $9129          ; VIA 2 T2C_HXX912B     = $912B          ; VIA 2 ACRXX912C     = $912C          ; VIA# 2 PCR; THE STATUS BIT IS A NOT NORMAL FLAG. IT GOES HIGH IF BOTH AN INTERRUPT FLAG IN THE IFR; AND THE CORRESPONDING ENABLE BIT IN THE IER ARE SET. IT CAN BE CLEARED ONLY BY CLEARING; ALL THE ACTIVE FLAGS IN THE IFR OR DISABLING ALL ACTIVE INTERRUPT#S IN THE IERXX912D     = $912D          ; VIA 1 IFR                         ; BIT     FUNCTION          CLEARED BY                         ; ---     --------          ----------                         ;  7     INTERRUPT STATUS     CLEARING ALL ENAB#LED INTERRUPTS                         ;  6     T1 INTERRUPT     READ T1C_L, WRITE T1C_H                         ;  5     T2 INTERRUPT     READ T2C_L, WRITE T2C_H                         ;  4     CB1 TRANSITION     READ OR WRITE PORT B               #          ;  3     CB2 TRANSITION     READ OR WRITE PORT B                         ;  2     8 SHIFTS DONE     READ OR WRITE THE SHIFT REGISTER                         ;  1     CA1 TRANSITION     READ OR WRITE PORT A                         ;  0     CA#2 TRANSITION     READ OR WRITE PORT A; IF ENABLE/DISABLE BIT IS A ZERO DURING A WRITE TO THIS REGISTER, EACH 1 IN BITS 0-6; CLEARS THE CORRESPONDING BIT IN THE IER. IF THIS BIT IS A ONE DURING A WRITE TO THIS; REGISTER, EACH 1 IN BITS 0-6 WILL SET TH#E CORRESPONDING IER BITXX912E     = $912E          ; VIA 1 IER                         ; BIT     FUNCTION                         ; ---     --------                         ;  7     ENABLE/DISABLE                         ;  6     T1 INTERRUPT     #                    ;  5     T2 INTERRUPT                         ;  4     CB1 TRANSITION                         ;  3     CB2 TRANSITION                         ;  2     8 SHIFTS DONE                         ;  1     CA1 TRANSITION                 #        ;  0     CA2 TRANSITIONXX912F     = $912F          ; VIA 2 DRA, KEYBOARD ROW, NO HANDSHAKEXXA000     = $A000          ; AUTOSTART ROM INITIAL ENTRY VECTORXXA002     = $A002          ; AUTOSTART ROM BREAK ENTRYXXA004     = $A004          ; A#UTOSTART ROM IDENTIFIER STRING START;***********************************************************************************;;; BASIC KEYWORD TOKEN VALUES. TOKENS NOT USED IN THE SOURCE ARE INCLUDED FOR; COMPLETENESS BUT COMMENTED OUT; COMMAND TOKENS#;TEND     = $80               ; END TOKENTFOR     = $81               ; FOR TOKEN;TNEXT     = $82               ; NEXT TOKENTDATA     = $83               ; DATA TOKEN;TINFL     = $84               ; INPUT# TOKEN;TINPUT     = $85               ; IN#PUT TOKEN;TDIM     = $86               ; DIM TOKEN;TREAD     = $87               ; READ TOKEN;TLET     = $88               ; LET TOKENTGOTO     = $89               ; GOTO TOKEN;TRUN     = $8A               ; RUN TOKEN;TIF     = $8B               ;# IF TOKEN;TRESTORE     = $8C               ; RESTORE TOKENTGOSUB     = $8D               ; GOSUB TOKEN;TRETURN     = $8E               ; RETURN TOKENTREM     = $8F               ; REM TOKEN;TSTOP     = $90               ; STOP TOKEN;TON     = $91 #              ; ON TOKEN;TWAIT     = $92               ; WAIT TOKEN;TLOAD     = $93               ; LOAD TOKEN;TSAVE     = $94               ; SAVE TOKEN;TVERIFY     = $95               ; VERIFY TOKEN;TDEF     = $96               ; DEF TOKEN;TPOKE #    = $97               ; POKE TOKEN;TPRINFL     = $98               ; PRINT# TOKENTPRINT     = $99               ; PRINT TOKEN;TCONT     = $9A               ; CONT TOKEN;TLIST     = $9B               ; LIST TOKEN;TCLR     = $9C               ; CLR# TOKEN;TCMD     = $9D               ; CMD TOKEN;TSYS     = $9E               ; SYS TOKEN;TOPEN     = $9F               ; OPEN TOKEN;TCLOSE     = $A0               ; CLOSE TOKEN;TGET     = $A1               ; GET TOKEN;TNEW     = $A2               # ; NEW TOKEN; SECONDARY KEYWORD TOKENSTTAB     = $A3               ; TAB( TOKENTTO          = $A4               ; TO TOKENTFN          = $A5               ; FN TOKENTSPC     = $A6               ; SPC( TOKENTTHEN     = $A7               ; THEN TOKE#!NTNOT     = $A8               ; NOT TOKENTSTEP     = $A9               ; STEP TOKEN; OPERATOR TOKENSTPLUS     = $AA               ; + TOKENTMINUS     = $AB               ; - TOKEN;TMUL     = $AC               ; * TOKEN;TDIV     = $AD           #"    ; / TOKEN;TPOWER     = $AE               ; ^ TOKEN;TAND     = $AF               ; AND TOKEN;TOR     = $B0               ; OR TOKENTGT          = $B1               ; > TOKENTEQUAL     = $B2               ; = TOKEN;TLT     = $B3               ; ##< TOKEN; FUNCTION TOKENSTSGN     = $B4               ; SGN TOKEN;TINT     = $B5               ; INT TOKEN;TABS     = $B6               ; ABS TOKEN;TUSR     = $B7               ; USR TOKEN;TFRE     = $B8               ; FRE TOKEN;TPOS     = $B9 #$              ; POS TOKEN;TSQR     = $BA               ; SQR TOKEN;TRND     = $BB               ; RND TOKEN;TLOG     = $BC               ; LOG TOKEN;TEXP     = $BD               ; EXP TOKEN;TCOS     = $BE               ; COS TOKEN;TSIN     = $BF   #%            ; SIN TOKEN;TTAN     = $C0               ; TAN TOKEN;TATN     = $C1               ; ATN TOKEN;TPEEK     = $C2               ; PEEK TOKEN;TLEN     = $C3               ; LEN TOKEN;TSTRS     = $C4               ; STR$ TOKEN;TVAL     = $C5#&               ; VAL TOKEN;TASC     = $C6               ; ASC TOKEN;TCHRS     = $C7               ; CHR$ TOKEN;TLEFTS     = $C8               ; LEFT$ TOKEN;TRIGHTS     = $C9               ; RIGHT$ TOKEN;TMIDS     = $CA               ; MID$ TOKENTG#'O          = $CB               ; GO TOKENTPI          = $FF               ; PI TOKEN;***********************************************************************************;;******************************************************************************" *****;;; ROM START* = $C000 ;     .ORG     $C000XXC000 = *     .WORD     XXE378          ; BASIC COLD START ENTRY POINTXXC002 = *     .WORD     XXE467          ; BASIC WARM START ENTRY POINTXXC004 = *     .BYTE     'CBMBASIC'          ; ROM $ASE/GRAPHICS SET, AND THE LOWERCASE/UPPERCASE; SET.; WHILE THIS CHANGES THE APPEARANCE OF ALL OF THE CHARACTERS ON THE SCREEN AT ONCE IT; HAS NOTHING WHATEVER TO DO WITH THE KEYBOARD SHIFT TABLES AND SHOULD NOT BE CONFUSED; WITH THE PRINTING OF SHIF$TED CHARACTERS, WHICH AFFECTS ONLY ONE CHARACTER AT A TIME.XX028D = $028D  ; KEYBOARD SHIFT/CONTROL FLAG; BIT KEY(S) 1 = DOWN; --- ---------------; 7-3 UNUSED;  2 CTRL;  1 C=;  0 SHIFT; THIS LOCATION, IN COMBINATION WITH THE ONE ABOVE, IS USED $TO DEBOUNCE THE SPECIAL; SHIFT KEYS. THIS WILL KEEP THE SHIFT/C= COMBINATION FROM CHANGING CHARACTER SETS; BACK AND FORTH DURING A SINGLE PRESSING OF BOTH KEYS.XX028E = $028E  ; SHIFT/CTRL/C= KEYPRESS LAST PATTERN; THIS LOCATION POINTS TO THE ADDRE$SS OF THE OPERATING SYSTEM ROUTINE WHICH ACTUALLY; DETERMINES WHICH KEYBOARD MATRIX LOOKUP TABLE WILL BE USED.; THE ROUTINE LOOKS AT THE VALUE OF THE SHIFT FLAG AT $28D, AND BASED ON WHAT VALUE; IT FINDS THERE, STORES THE ADDRESS OF THE CORRECT TABLE$ TO USE AT LOCATION $F5.XX028F = $028F  ; KEYBOARD DECODE LOGIC POINTER LOW BYTEXX0290 = $0290  ; KEYBOARD DECODE LOGIC POINTER HIGH BYTE; THIS FLAG IS USED TO ENABLE OR DISABLE THE FEATURE WHICH LETS YOU SWITCH BETWEEN THE; UPPERCASE/GRAPHICS AND $UPPER/LOWERCASE CHARACTER SETS BY PRESSING THE SHIFT AND; COMMODORE LOGO KEYS SIMULTANEOUSLY.XX0291 = $0291  ; SHIFT MODE SWITCH, $00 = ENABLED, $80 = LOCKED; THIS LOCATION IS USED TO DETERMINE WHETHER MOVING THE CURSOR PAST THE ??XX  COLUMN OF; A $LOGICAL LINE WILL CAUSE ANOTHER PHYSICAL LINE TO BE ADDED TO THE LOGICAL LINE.; A VALUE OF 0 ENABLES THE SCREEN TO SCROLL THE FOLLOWING LINES DOWN IN ORDER TO ADD; THAT LINE; ANY NONZERO VALUE WILL DISABLE THE SCROLL.; THIS FLAG IS SET TO DISABLE TH$E SCROLL TEMPORARILY WHEN THERE ARE CHARACTERS WAITING; IN THE KEYBOARD BUFFER, THESE MAY INCLUDE CURSOR MOVEMENT CHARACTERS THAT WOULD; ELIMINATE THE NEED FOR A SCROLL.XX0292 = $0292  ; SCREEN SCROLLING FLAG, $00 = ENABLEDXX0293 = $0293  ; PSEUDO $	6551 CONTROL REGISTER. THE FIRST CHARACTER OF; THE OPEN RS232 FILENAME WILL BE STORED HERE; BIT FUNCTION; --- --------;  7 2 STOP BITS/1 STOP BIT; 65 WORD LENGTH; --- -----------; 00 8 BITS; 01 7 BITS; 10 6 BITS; 11 5 BITS;  4 UNUSED; 3210 BA$
UD RATE; ---- ---------; 0000 USER RATE *; 0001    50; 0010    75; 0011   110; 0100   134.5; 0101   150; 0110   300; 0111   600; 1000  1200; 1001  1800; 1010  2400; 1011  3600; 1100  4800 *; 1101  7200 *; 1110  9600 *; 1111 19200 * * = N$OT IMPLEMENTEDXX0294 = $0294  ; PSEUDO 6551 COMMAND REGISTER. THE SECOND CHARACTER OF; THE OPEN RS232 FILENAME WILL BE STORED HERE; BIT FUNCTION; --- --------; 765 PARITY; --- ------; XX0 DISABLED; 001 ODD; 011 EVEN; 101 MARK; 111 SPACE;  4 D$UPLEX HALF/FULL;  3 UNUSED;  2 UNUSED;  1 UNUSED;  0 HANDSHAKE - X LINE/3 LINE;XX0295 = $0295  ; NONSTANDARD BIT TIMING LOW BYTE. THE THIRD CHARACTER; OF THE OPEN RS232 FILENAME WILL BE STORED HERE;XX0296 = $0296  ; NONSTANDARD BIT TIMING HIGH BYT$E. THE FOURTH CHARACTER; OF THE OPEN RS232 FILENAME WILL BE STORED HEREXX0297 = $0297  ; RS-232 STATUS REGISTER; BIT FUNCTION; --- --------;  7 BREAK;  6 NO DSR DETECTED;  5 UNUSED;  4 NO CTS DETECTED;  3 UNUSED;  2 RX BUFFER OVERRUN;  1 FRAMI$NG ERROR;  0 PARITY ERRORXX0298 = $0298  ; NUMBER OF BITS TO BE SENT/RECEIVEDXX0299 = $0299  ; TIME OF ONE BIT CELL LOW BYTEXX029A = $029A  ; TIME OF ONE BIT CELL HIGH BYTEXX029B = $029B  ; INDEX TO RX BUFFER ENDXX029C = $029C  ; INDEX TO RX BUFFER$ STARTXX029D = $029D  ; INDEX TO TX BUFFER STARTXX029E = $029E  ; INDEX TO TX BUFFER ENDXX029F = $029F  ; SAVED IRQ LOW BYTEXX02A0 = $02A0  ; SAVED IRQ HIGH BYTE; $02A1 TO $02FF - UNUSEDXX0300 = $0300  ; VECTOR TO THE PRINT BASIC ERROR MESSAGE RO$UTINEXX0302 = $0302  ; VECTOR TO THE MAIN BASIC PROGRAM LOOPXX0304 = $0304  ; VECTOR TO THE THE ASCII TEXT TO KEYWORDS ROUTINEXX0306 = $0306  ; VECTOR TO THE LIST BASIC PROGRAM AS ASCII ROUTINEXX0308 = $0308  ; VECTOR TO THE EXECUTE NEXT BASIC COMMAN$D ROUTINEXX030A = $030A  ; VECTOR TO THE GET VALUE FROM BASIC LINE ROUTINE; BEFORE EVERY SYS COMMAND EACH OF THE REGISTERS IS LOADED WITH THE VALUE FOUND IN THE; CORRESPONDING STORAGE ADDRESS. UPON RETURNING TO BASIC WITH AN RTS INSTRUCTION, THE NEW$; VALUE OF EACH REGISTER IS STORED IN THE APPROPRIATE STORAGE ADDRESS.; THIS FEATURE ALLOWS YOU TO PLACE THE NECESSARY VALUES INTO THE REGISTERS FROM BASIC; BEFORE YOU SYS TO A KERNAL OR BASIC ML ROUTINE. IT ALSO ENABLES YOU TO EXAMINE THE; RESULTING$ EFFECT OF THE ROUTINE ON THE REGISTERS, AND TO PRESERVE THE CONDITION OF THE; REGISTERS ON EXIT FOR SUBSEQUENT SYS CALLS.XX030C = $030C  ; A FOR SYS COMMANDXX030D = $030D  ; X FOR SYS COMMANDXX030E = $030E  ; Y FOR SYS COMMANDXX030F = $030F  ; P F$OR SYS COMMANDXX0314 = $0314  ; IRQ VECTOR LOW BYTEXX0315 = $0315  ; IRQ VECTOR HIGH BYTEXX0316 = $0316  ; BRK VECTORXX0318 = $0318  ; NMI VECTORXX031A = $031A  ; KERNAL VECTOR - OPEN A LOGICAL FILEXX031C = $031C  ; KERNAL VECTOR - CLOSE A SPECIF$IED LOGICAL FILEXX031E = $031E  ; KERNAL VECTOR - OPEN CHANNEL FOR INPUTXX0320 = $0320  ; KERNAL VECTOR - OPEN CHANNEL FOR OUTPUTXX0322 = $0322  ; KERNAL VECTOR - CLOSE INPUT AND OUTPUT CHANNELSXX0324 = $0324  ; KERNAL VECTOR - INPUT CHARACTER FROM C$HANNELXX0326 = $0326  ; KERNAL VECTOR - OUTPUT CHARACTER TO CHANNELXX0328 = $0328  ; KERNAL VECTOR - SCAN STOP KEYXX032A = $032A  ; KERNAL VECTOR - GET CHARACTER FROM KEYBOARD QUEUEXX032C = $032C  ; KERNAL VECTOR - CLOSE ALL CHANNELS AND FILESXX033$0 = $0330  ; KERNAL VECTOR - LOADXX0332 = $0332  ; KERNAL VECTOR - SAVEXX033C = $033C  ; TO $03FB - CASSETTE BUFFER;***********************************************************************************;;**********************************************$*************************************;;; HARDWARE EQUATESXX9000     = $9000          ; VIC CHIP BASE ADDRESSXX9002     = $9002          ; VIDEO ADDRESS AND COLUMS                         ; BIT     FUNCTION                         ; ---     -------$-                         ;  7     VIDEO ADDRESS VA9                         ; 6-0     NUMBER OF COLUMNSXX9005     = $9005          ; VIDEO MEMORY ADDRESSES ($1E00)                         ; BIT     FUNCTION                         ; ---     -------$-                         ;  7     MUST BE 1                         ; 6-4     VIDEO MEMORY ADDRESS VA12-VA10                         ; 3-0     CHARACTER MEMORY START ADDRESS                         ; 0000 ROM     $8000     SET 1                   $      ; 0001  '     $8400                         ; 0010  '     $8800 SET 2                         ; 0011  '     $8C00                         ; 1100 RAM     $1000                         ; 1101  '     $1400                         ; 1110  '     $1$800                         ; 1111  '     $1C00XX9110     = $9110          ; VIA 1 DRB                         ; BIT     FUNCTION                         ; ---     --------                         ;  7     DSR IN                         ;  6     C$TS IN                         ;  5                              ;  4     DCD IN                         ;  3     RI IN                         ;  2     DTR OUT                         ;  1     RTS OUT                         ;  0     DATA INXX9111$     = $9111          ; VIA 1 DRA                         ; BIT     FUNCTION                         ; ---     --------                         ;  7     SERIAL ATN OUT                         ;  6     CASSETTE SWITCH                         ;  5    $ LIGHT PEN                         ;  4     JOY 2                         ;  3     JOY 1                         ;  2     JOY 0                         ;  1     SERIAL DATA IN                         ;  0     SERIAL CLK INXX9112     = $9112        $   ; VIA 1 DDRBXX9113     = $9113          ; VIA 1 DDRAXX9114     = $9114          ; VIA 1 T1C_LXX9115     = $9115          ; VIA 1 T1C_HXX9118     = $9118          ; VIA 1 T2C_LXX9119     = $9119          ; VIA 1 T2C_HXX911B     = $911B          ; $!VIA 1 ACR                         ; BIT     FUNCTION                         ; ---     --------                         ;  7     T1 PB7 ENABLED/DISABLED                         ;  6     T1 FREE RUN/ONE SHOT                         ;  5     T2 CLOCK $"PB6/2                         ; 432     FUNCTION                         ; ---     --------                         ; 000     SHIFT REGISTER DISABLED                         ; 001     SHIFT IN, RATE CONTROLLED BY T2                         ; 010   $#  SHIFT IN, RATE CONTROLLED BY 2                         ; 011     SHIFT IN, RATE CONTROLLED BY EXTERNAK CLOCK                         ; 100     SHIFT OUT, RATE CONTROLLED BY T2, FREE RUN MODE                         ; 101     SHIFT OUT, RATE CONTROL$$LED BY T2                         ; 110     SHIFT OUT, RATE CONTROLLED BY 2                         ; 111     SHIFT OUT, RATE CONTROLLED BY EXTERNAK CLOCK                         ;  1     PB LATCH ENABLED/DISABLED                         ;  0     PA$% LATCH ENABLED/DISABLEDXX911C     = $911C          ; VIA 1 PCR                         ; BIT     FUNCTION                         ; ---     --------                         ; 765     CB2 CONTROL                         ; ---     -----------        $&                 ; 000     INTERRUPT INPUT MODE                         ; 001     INDEPENDENT INTERRUPT INPUT MODE                         ; 010     INPUT MODE                         ; 011     INDEPENDENT INPUT MODE                         ; 100    $' HANDSHAKE OUTPUT MODE                         ; 101     PULSE OUTPUT MODE                         ; 110     MANUAL OUTPUT MODE, CB2 LOW                         ; 111     MANUAL OUTPUT MODE, CB2 HIGH                         ;  4     CB1 EDGE POSITIVE# /NEGATIVE                         ; 321     CA2 CONTROL                         ; ---     -----------                         ; 000     INTERRUPT INPUT MODE                         ; 001     INDEPENDENT INTERRUPT INPUT MODE                         ;% ANYWHERE FROM 1-23. DEPENDING ON THE LENGTH OF THE LOGICAL LINE, THE; CURSOR COLUMN MAY BE FROM 1-22, 1-44, 1-66 OR 1-88.; FOR A MORE ON LOGICAL LINES, SEE THE DESCRIPTION OF THE SCREEN LINE LINK TABLE, $D9.XXC9 = $C9   ; INPUT CURSOR ROWXXCA = $C%A   ; INPUT CURSOR COLUMN; THE KEYSCAN INTERRUPT ROUTINE USES THIS LOCATION TO INDICATE WHICH KEY IS CURRENTLY; BEING PRESSED. THE VALUE HERE IS THEN USED AS AN INDEX INTO THE APPROPRIATE KEYBOARD; TABLE TO DETERMINE WHICH CHARACTER TO PRINT WHEN A K%EY IS STRUCK.; THE CORRESPONDENCE BETWEEN THE KEY PRESSED AND THE NUMBER STORED HERE IS AS FOLLOWS:; $00 1  $10 NOT USED $20 [SPACE] $30 Q  $40 [NO KEY]; $01 3  $11 A  $21 Z  $31 E  $XX INVALID; $02 5  $12 D  $22 C  $32 T; $03 7  $13 G  $23 B  $33% U; $04 9  $14 J  $24 M  $34 O; $05 +  $15 L  $25 .  $35 @; $06 [POUND] $16 ;  $26 NOT USED $36 [U ARROW]; $07 [DEL]  $17 [RIGHT] $27 [F1]  $37 [F5] ; $08 [L ARROW] $18 [STOP] $28 NOT USED $38 2; $09 W  $19 NOT USED $29 S  $39 4; $0A R  $1A X  $2A% F  $3A 6; $0B Y  $1B V  $2B H  $3B 8; $0C I  $1C N  $2C K  $3C 0; $0D P  $1D ,  $2D :  $3D -; $0E *  $1E /  $2E =  $3E [HOME]; $0F [RETURN] $1F [DOWN] $2F [F3]  $3F [F7]XXCB = $CB   ; WHICH KEY; WHEN THIS FLAG IS SET TO A NONZERO VALUE, IT INDI%CATES TO THE ROUTINE THAT NORMALLY; FLASHES THE CURSOR NOT TO DO SO. THE CURSOR BLINK IS TURNED OFF WHEN THERE ARE; CHARACTERS IN THE KEYBOARD BUFFER, OR WHEN THE PROGRAM IS RUNNING.XXCC = $CC   ; CURSOR ENABLE, $00 = FLASH CURSOR; THE ROUTINE THAT% BLINKS THE CURSOR USES THIS LOCATION TO TELL WHEN IT'S TIME FOR A; BLINK. THE NUMBER 20 IS PUT HERE AND DECREMENTED EVERY JIFFY UNTIL IT REACHES ZERO.; THEN THE CURSOR STATE IS CHANGED, THE NUMBER 20 IS PUT BACK HERE, AND THE CYCLE STARTS; ALL OVER A%GAIN.XXCD = $CD   ; CURSOR TIMING COUNTDOWN; THE CURSOR IS FORMED BY PRINTING THE INVERSE OF THE CHARACTER THAT OCCUPIES THE CURSOR; POSITION. IF THAT CHARACTERS IS THE LETTER A, FOR EXAMPLE, THE FLASHING CURSOR MERELY; ALTERNATES BETWEEN PRINTING %	AN A AND A REVERSE-A. THIS LOCATION KEEPS TRACK OF THE; NORMAL SCREEN CODE OF THE CHARACTER THAT IS LOCATED AT THE CURSOR POSITION, SO THAT IT; MAY BE RESTORED WHEN THE CURSOR MOVES ON.XXCE = $CE   ; CHARACTER UNDER CURSOR; THIS LOCATION KEEPS TRAC%
K OF WHETHER, DURING THE CURRENT CURSOR BLINK, THE CHARACTER; UNDER THE CURSOR WAS REVERSED, OR WAS RESTORED TO NORMAL. THIS LOCATION WILL CONTAIN; $00 IF THE CHARACTER IS REVERSED, AND $01 IF THE CHARACTER IS NOT REVERSED.XXCF = $CF   ; CURSOR BLINK% PHASEXXD0 = $D0   ; INPUT FROM KEYBOARD OR SCREEN, $XX = INPUT IS AVAILABLE; FROM THE SCREEN, $00 = INPUT SHOULD BE OBTAINED FROM THE; KEYBOARD; THESE LOCATIONS POINT TO THE ADDRESS IN SCREEN RAM OF THE FIRST COLUMN OF THE LOGICAL; LINE UPON WHIC%H THE CURSOR IS CURRENTLY POSITIONED.XXD1 = $D1   ; CURRENT SCREEN LINE POINTER LOW BYTEXXD2 = $D2   ; CURRENT SCREEN LINE POINTER HIGH BYTE; THIS HOLDS THE CURSOR COLUMN POSITION WITHIN THE LOGICAL LINE POINTED TO BY XXD1.; SINCE A LOGICAL LINE CA%N COMPRISE UP TO FOUR PHYSICAL LINES, THIS VALUE MAY BE FROM; $00 TO $57.XXD3 = $D3   ; CURSOR COLUMN; A NONZERO VALUE IN THIS LOCATION INDICATES THAT THE EDITOR IS IN QUOTE MODE. QUOTE; MODE IS TOGGLED EVERY TIME THAT YOU TYPE IN A QUOTATION MARK %ON A GIVEN LINE, THE; FIRST QUOTE MARK TURNS IT ON, THE SECOND TURNS IT OFF, THE THIRD TURNS IT ON, ETC.; IF THE EDITOR IS IN THIS MODE WHEN A CURSOR CONTROL CHARACTER OR OTHER NONPRINTING; CHARACTER IS ENTERED, A PRINTED EQUIVALENT WILL APPEAR ON TH%E SCREEN INSTEAD OF THE; CURSOR MOVEMENT OR OTHER CONTROL OPERATION TAKING PLACE. INSTEAD, THAT ACTION IS; DEFERRED UNTIL THE STRING IS SENT TO THE STRING BY A PRINT STATEMENT, AT WHICH TIME; THE CURSOR MOVEMENT OR OTHER CONTROL OPERATION WILL TAKE PL%ACE.; THE EXCEPTION TO THIS RULE IS THE DELETE KEY, WHICH WILL FUNCTION NORMALLY WITHIN; QUOTE MODE. THE ONLY WAY TO PRINT A CHARACTER WHICH IS EQUIVALENT TO THE DELETE KEY; IS BY ENTERING INSERT MODE. QUOTE MODE MAY BE EXITED BY PRINTING A CLOSING Q%UOTE OR; BY HITTING THE RETURN OR SHIFT-RETURN KEYS.XXD4 = $D4   ; CURSOR QUOTE FLAG; THE LINE EDITOR USES THIS LOCATION WHEN THE END OF A LINE HAS BEEN REACHED TO DETERMINE; WHETHER ANOTHER PHYSICAL LINE CAN BE ADDED TO THE CURRENT LOGICAL LINE OR% IF A NEW; LOGICAL LINE MUST BE STARTED.XXD5 = $D5   ; CURRENT SCREEN LINE LENGTH; THIS LOCATION CONTAINS THE CURRENT PHYSICAL SCREEN LINE POSITION OF THE CURSOR, 0 TO 22.XXD6 = $D6   ; CURSOR ROW; THE ASCII VALUE OF THE LAST CHARACTER PRINTED T%O THE SCREEN IS HELD HERE TEMPORARILY.XXD7 = $D7   ; CHECKSUM BYTE/TEMPORARY LAST CHARACTER; WHEN THE INST KEY IS PRESSED, THE SCREEN EDITOR SHIFTS THE LINE TO THE RIGHT, ALLOCATES; ANOTHER PHYSICAL LINE TO THE LOGICAL LINE IF NECESSARY (AND POSSIBL%E), UPDATES THE; SCREEN LINE LENGTH IN $D5, AND ADJUSTS THE SCREEN LINE LINK TABLE AT $D9. THIS LOCATION; IS USED TO KEEP TRACK OF THE NUMBER OF SPACES THAT HAS BEEN OPENED UP IN THIS WAY.; UNTIL THE SPACES THAT HAVE BEEN OPENED UP ARE FILLED, THE ED%ITOR ACTS AS IF IN QUOTE; MODE. SEE LOCATION $D4, THE QUOTE MODE FLAG. THIS MEANS THAT CURSOR CONTROL CHARACTERS; THAT ARE NORMALLY NONPRINTING WILL LEAVE A PRINTED EQUIVALENT ON THE SCREEN WHEN; ENTERED, INSTEAD OF HAVING THEIR NORMAL EFFECT ON CURSO%R MOVEMENT, ETC. THE ONLY; DIFFERENCE BETWEEN INSERT AND QUOTE MODE IS THAT THE DELETE KEY WILL LEAVE A PRINTED; EQUIVALENT IN INSERT MODE, WHILE THE INSERT KEY WILL INSERT SPACES AS NORMAL.XXD8 = $D8   ; INSERT COUNT; THIS TABLE CONTAINS 23 ENTRIE%S, ONE FOR EACH ROW OF THE SCREEN DISPLAY. EACH ENTRY HAS; TWO FUNCTIONS. BITS 0-3 INDICATE ON WHICH OF THE FOUR PAGES OF SCREEN MEMORY THE FIRST; BYTE OF MEMORY FOR THAT ROW IS LOCATED. THIS IS USED IN CALCULATING THE POINTER TO THE; STARTING ADDRESS% OF A SCREEN LINE AT $D1.;; THE HIGH BYTE IS CALCULATED BY ADDING THE VALUE OF THE STARTING PAGE OF SCREEN MEMORY; HELD IN $288 TO THE DISPLACEMENT PAGE HELD HERE.;; THE OTHER FUNCTION OF THIS TABLE IS TO ESTABLISH THE MAKEUP OF LOGICAL LINES ON THE%; SCREEN. WHILE EACH SCREEN LINE IS ONLY 22 CHARACTERS LONG, BASIC ALLOWS THE ENTRY OF; PROGRAM LINES THAT CONTAIN UP TO 88 CHARACTERS. THEREFORE, SOME METHOD MUST BE USED; TO DETERMINE WHICH PHYSICAL LINES ARE LINKED INTO A LONGER LOGICAL LINE, SO TH%AT THIS; LONGER LOGICAL LINE MAY BE EDITED AS A UNIT.;; THE HIGH BIT OF EACH BYTE HERE IS USED AS A FLAG BY THE SCREEN EDITOR. THAT BIT IS SET; WHEN A LINE IS THE FIRST OR ONLY PHYSICAL LINE IN A LOGICAL LINE. THE HIGH BIT IS RESET; TO 0 ONLY WHEN A% LINE IS AN EXTENSION TO THIS LOGICAL LINE.XXD9 = $D9   ; TO XXD9 + $18 INCLUSIVE, SCREEN LINE LINK TABLE; THIS POINTER IS SYNCHRONIZED WITH THE POINTER TO THE ADDRESS OF THE FIRST BYTE OF; SCREEN RAM FOR THE CURRENT LINE KEPT IN LOCATION $D1. IT HO%LDS THE ADDRESS OF THE; FIRST BYTE OF COLOUR RAM FOR THE CORRESPONDING SCREEN LINE.XXF2 = $F2   ; SCREEN ROW MARKERXXF3 = $F3   ; COLOUR RAM POINTER LOW BYTEXXF4 = $F4   ; COLOUR RAM POINTER HIGH BYTE; THIS POINTER POINTS TO THE ADDRESS OF THE KEY%BOARD MATRIX LOOKUP TABLE CURRENTLY BEING; USED. ALTHOUGH THERE ARE ONLY 64 KEYS ON THE KEYBOARD MATRIX, EACH KEY CAN BE USED TO; PRINT UP TO FOUR DIFFERENT CHARACTERS, DEPENDING ON WHETHER IT IS STRUCK BY ITSELF OR; IN COMBINATION WITH THE SHIFT, CTR%L, OR C= KEYS.; THESE TABLES HOLD THE ASCII VALUE OF EACH OF THE 64 KEYS FOR ONE OF THESE POSSIBLE; COMBINATIONS OF KEYPRESSES. WHEN IT COMES TIME TO PRINT THE CHARACTER, THE TABLE THAT; IS USED DETERMINES WHICH CHARACTER IS PRINTED.; THE ADDRESSES% OF THE TABLES ARE:; XXEC5E   ; UNSHIFTED; XXEC9F   ; SHIFTED; XXECE0   ; COMMODORE; XXEDA3   ; CONTROLXXF5 = $F5   ; KEYBOARD POINTER LOW BYTEXXF6 = $F6   ; KEYBOARD POINTER HIGH BYTE; WHEN DEVICE THE RS232 CHANNEL IS OPENED TWO BUFFERS OF 256%  BYTES EACH ARE CREATED AT; THE TOP OF MEMORY. THESE LOCATIONS POINT TO THE ADDRESS OF THE ONE WHICH IS USED TO; STORE CHARACTERS AS THEY ARE RECEIVED.XXF7 = $F7   ; RS232 RX POINTER LOW BYTEXXF8 = $F8   ; RS232 RX POINTER HIGH BYTE; THESE LOCATIO%!NS POINT TO THE ADDRESS OF THE 256 BYTE OUTPUT BUFFER THAT IS USED FOR; TRANSMITTING DATA TO RS232 DEVICES.XXF9 = $F9   ; RS232 TX POINTER LOW BYTEXXFA = $FA   ; RS232 TX POINTER HIGH BYTEXX00FF = $FF   ; FAC1 TO STRING OUTPUT BASEXX0100 = $0100 %" ; BOTTOM OF THE STACK PAGEXX01FC = $01FC  ; CHAIN LINK POINTER HIGH BYTEXX01FD = $01FD  ; CHAIN LINK POINTER LOW BYTEXX01FE = $01FE  ; LINE NUMBER LOW BYTE BEFORE CRUNCHED LINEXX01FF = $01FF  ; LINE NUMBER HIGH BYTE BEFORE CRUNCHED LINEXX0200 = %#$0200  ; INPUT BUFFER. FOR SOME ROUTINES THE BYTE BEFORE THE INPUT; BUFFER NEEDS TO BE SET TO A SPECIFIC VALUE FOR THE ROUTINE; TO WORK CORRECTLYXX0201 = $0201  ; INPUT BUFFER + 1XX0259 = $0259  ; .. TO XX0262 LOGICAL FILE TABLEXX0263 = $0263  ; ..%$ TO XX026C DEVICE NUMBER TABLEXX026D = $026D  ; .. TO XX0276 SECONDARY ADDRESS TABLEXX0277 = $0277  ; .. TO XX0280 KEYBOARD BUFFERXX0281 = $0281  ; OS START OF MEMORY LOW BYTEXX0282 = $0282  ; OS START OF MEMORY HIGH BYTEXX0283 = $0283  ; OS TOP OF %%MEMORY LOW BYTEXX0284 = $0284  ; OS TOP OF MEMORY HIGH BYTEXX0285 = $0285  ; SERIAL BUS TIMEOUT FLAGXX0286 = $0286  ; CURRENT COLOUR CODEXX0287 = $0287  ; COLOUR UNDER CURSORXX0288 = $0288  ; SCREEN MEMORY PAGEXX0289 = $0289  ; MAXIMUM KEYBOARD BUF%&FER SIZEXX028A = $028A  ; KEY REPEAT. $80 = REPEAT ALL, $40 = REPEAT NONE,                ; $00 = REPEAT CURSOR MOVEMENT KEYS, INSERT/DELETE                ; KEY AND THE SPACE BARXX028B = $028B  ; REPEAT SPEED COUNTERXX028C = $028C  ; REPEAT DELAY C%'OUNTER; THIS FLAG SIGNALS WHICH OF THE SHIFT, CTRL, OR C= KEYS ARE CURRENTLY BEING PRESSED.; A VALUE OF $01 SIGNIFIES THAT ONE OF THE SHIFT KEYS IS BEING PRESSED, A $02 SHOWS THAT; THE C= KEY IS DOWN, AND $04 MEANS THAT THE CTRL KEY IS BEING PRESSED$ . IF MORE THAN ONE; KEY IS HELD DOWN, THESE VALUES WILL BE ADDED E.G $03 INDICATES THAT SHIFT AND C= ARE; BOTH HELD DOWN.; PRESSING THE SHIFT AND C= KEYS AT THE SAME TIME WILL TOGGLE THE CHARACTER SET THAT IS; PRESENTLY BEING USED BETWEEN THE UPPERC& READ POINTER LOW BYTEXX44 = $44   ; READ POINTER HIGH BYTEXX45 = $45   ; CURRENT VARIABLE NAME FIRST BYTEXX46 = $46   ; CURRENT VARIABLE NAME SECOND BYTE; THESE LOCATIONS POINT TO THE VALUE OF THE CURRENT BASIC VARIABLE SPECIFICALLY THEY; POINT T&O THE BYTE JUST AFTER THE TWO-CHARACTER VARIABLE NAME.XX47 = $47   ; CURRENT VARIABLE ADDRESS LOW BYTEXX48 = $48   ; CURRENT VARIABLE ADDRESS HIGH BYTE; THE ADDRESS OF THE BASIC VARIABLE WHICH IS THE SUBJECT OF A FOR/NEXT LOOP IS FIRST; STORED HERE& BEFORE BEING PUSHED ONTO THE STACK.XX49 = $49   ; FOR/NEXT VARIABLE POINTER LOW BYTEXX4A = $4A   ; FOR/NEXT VARIABLE POINTER HIGH BYTE; THE EXPRESSION EVALUATION ROUTINE CREATES THIS TO LET IT KNOW WHETHER THE CURRENT; COMPARISON OPERATION IS A < &$01, = $02 OR > $04 COMPARISON OR COMBINATION.XX4B = $4B   ; BASIC EXECUTE POINTER TEMPORARY LOW BYTE/PRECEDENCE FLAGXX4C = $4C   ; BASIC EXECUTE POINTER TEMPORARY HIGH BYTEXX4D = $4D   ; COMPARRISON EVALUATION FLAG; THESE LOCATIONS ARE USED AS A P&OINTER TO THE FUNCTION THAT IS CREATED DURING FUNCTION; DEFINITION . DURING FUNCTION EXECUTION IT POINTS TO WHERE THE EVALUATION RESULTS SHOULD; BE SAVED.XX4E = $4E   ; FAC TEMP STORE/FUNCTION/VARIABLE/GARBAGE POINTER LOW BYTEXX4F = $4F   ; FAC TEMP& STORE/FUNCTION/VARIABLE/GARBAGE POINTER HIGH BYTE; TEMPORARY POINTER TO THE CURRENT STRING DESCRIPTOR.XX50 = $50   ; FAC TEMP STORE/DESCRIPTOR POINTER LOW BYTEXX51 = $51   ; FAC TEMP STORE/DESCRIPTOR POINTER HIGH BYTEXX53 = $53   ; GARBAGE COLLEC&TION STEP SIZE; THE FIRST BYTE IS THE 6502 JMP INSTRUCTION $4C, FOLLOWED BY THE ADDRESS OF THE REQUIRED; FUNCTION TAKEN FROM THE TABLE AT $C052.XX54 = $54   ; JMP OPCODE FOR FUNCTIONSXX55 = $55   ; FUNCTIONS JUMP VECTOR LOW BYTEXX56 = $56   ; FUNC&TIONS JUMP VECTOR HIGH BYTEXX57 = $57   ; FAC TEMP STOREXX58 = $58   ; FAC TEMP STOREXX59 = $59   ; FAC TEMP STOREXX5A = $5A   ; FAC TEMP STOREXX5B = $5B   ; BLOCK END HIGH BYTEXX5C = $5C   ; FAC TEMP STOREXX5D = $5D   ; FAC TEMP STOREXX5E = $5E&	   ; FAC TEMP STOREXX5F = $5F   ; FAC TEMP STOREXX60 = $60   ; BLOCK START HIGH BYTEXX61 = $61   ; FAC1 EXPONENTXX62 = $62   ; FAC1 MANTISSA 1XX63 = $63   ; FAC1 MANTISSA 2XX64 = $64   ; FAC1 MANTISSA 3XX65 = $65   ; FAC1 MANTISSA 4XX66 = $66   ;&
 FAC1 SIGNXX67 = $67   ; CONSTANT COUNT/-VE FLAGXX68 = $68   ; FAC1 OVERFLOWXX69 = $69   ; FAC2 EXPONENTXX6A = $6A   ; FAC2 MANTISSA 1XX6B = $6B   ; FAC2 MANTISSA 2XX6C = $6C   ; FAC2 MANTISSA 3XX6D = $6D   ; FAC2 MANTISSA 4XX6E = $6E   ; FAC2 SI&GNXX6F = $6F   ; FAC SIGN COMPARRISONXX70 = $70   ; FAC1 ROUNDINGXX71 = $71   ; TEMP BASIC EXECUTE/ARRAY POINTER LOW BYTE/INDEXXX72 = $72   ; TEMP BASIC EXECUTE/ARRAY POINTER HIGH BYTEXX0073 = $73   ; INCREMENT AND SCAN MEMORY, BASIC BYTE GETXX007&9 = $79   ; SCAN MEMORY, BASIC BYTE GETXX7A = $7A   ; BASIC EXECUTE POINTER LOW BYTEXX7B = $7B   ; BASIC EXECUTE POINTER HIGH BYTEXX80 = $80   ; NUMERIC TEST ENTRYXX008B = $8B   ; RND() SEED, FIVE BYTESXX90 = $90   ; SERIAL STATUS BYTE     ; FUNC&TION     ; BIT CASETTE  SERIAL BUS     ; --- --------  ----------     ;  7 END OF TAPE  DEVICE NOT PRESENT     ;  6 END OF FILE  EOI     ;  5 CHECKSUM ERROR     ;  4 READ ERROR     ;  3 LONG BLOCK     ;  2 SHORT BLOCK     ;  1    TIME OUT READ &    ;  0    TIME OUT WRITEXX91 = $91   ; KEYBOARD ROW, BX = 0 = KEY DOWN     ; BIT KEY     ; --- ------     ;  7 [DOWN]     ;  6 /     ;  5 ,     ;  4 N     ;  3 V     ;  2 X     ;  1 [L SHIFT]     ;  0 [STOP]XX92 = $92   ; TIMING CONSTANT FO&R TAPE READXX93 = $93   ; LOAD/VERIFY FLAG, LOAD = $00, VERIFY = $01XX94 = $94   ; SERIAL OUTPUT: DEFERRED CHARACTER FLAG     ; $00 = NO CHARACTER WAITING, $XX = CHARACTER WAITINGXX95 = $95   ; SERIAL OUTPUT: DEFERRED CHARACTER     ; $FF = NO CHARAC&TER WAITING, $XX = WAITING CHARACTERXX96 = $96   ; CASSETTE BLOCK SYNCHRONIZATION NUMBERXX97 = $97   ; REGISTER SAVE; THE NUMBER OF CURRENTLY OPEN I/O FILES IS STORED HERE. THE MAXIMUM NUMBER THAT CAN BE; OPEN AT ONE TIME IS TEN. THE NUMBER STORED H&ERE IS USED AS THE INDEX TO THE END OF THE; TABLES THAT HOLD THE FILE NUMBERS, DEVICE NUMBERS, AND SECONDARY ADDRESSES.XX98 = $98   ; OPEN FILE COUNT; THE DEFAULT VALUE OF THIS LOCATION IS 0.XX99 = $99   ; INPUT DEVICE NUMBER; THE DEFAULT VALUE &OF THIS LOCATION IS 3.XX9A = $9A   ; OUTPUT DEVICE NUMBER;; NUMBER DEVICE; ------ ------;  0  KEYBOARD;  1  CASSETTE;  2  RS-232C;  3  SCREEN;  4-31 SERIAL BUSXX9B = $9B   ; TAPE CHARACTER PARITYXX9C = $9C   ; BYTE RECEIVED FLAGXX9D = $9D  & ; MESSAGE MODE FLAG,; $C0 = BOTH CONTROL AND KERNAL MESSAGES,; $80 = CONTROL MESSAGES ONLY,; $40 = KERNAL MESSAGES ONLY,; $00 = NEITHER CONTROL OR KERNAL MESSAGESXX9E = $9E   ; TAPE PASS 1 ERROR LOG/CHARACTER BUFFERXX9F = $9F   ; TAPE PASS 2 ERROR& LOG CORRECTED; THESE THREE LOCATIONS FORM A COUNTER WHICH IS UPDATED 60 TIMES A SECOND, AND SERVES AS; A SOFTWARE CLOCK WHICH COUNTS THE NUMBER OF JIFFIES THAT HAVE ELAPSED SINCE THE COMPUTER; WAS TURNED ON. AFTER 24 HOURS AND ONE JIFFY THESE LOCATI&ONS ARE SET BACK TO $000000.XXA0 = $A0   ; JIFFY CLOCK HIGH BYTEXXA1 = $A1   ; JIFFY CLOCK MID BYTEXXA2 = $A2   ; JIFFY CLOCK LOW BYTEXXA3 = $A3   ; EOI FLAG BYTE/TAPE BIT COUNT; B0 OF THIS LOCATION REFLECTS THE CURRENT PHASE OF THE TAPE OUTPUT C&YCLE.XXA4 = $A4   ; TAPE BIT CYCLE PHASEXXA5 = $A5   ; CASSETTE SYNCHRONIZATION BYTE COUNT/SERIAL BUS BIT COUNTXXA6 = $A6   ; TAPE BUFFER INDEXXXA7 = $A7   ; RECEIVER INPUT BIT TEMP STORAGEXXA8 = $A8   ; RECEIVER BIT COUNT INXXA9 = $A9   ; RECEIVE&R START BIT CHECK FLAG, $90 = NO START BIT; RECEIVED, $00 = START BIT RECEIVEDXXAA = $AA   ; RECEIVER BYTE BUFFER/ASSEMBLY LOCATIONXXAB = $AB   ; RECEIVER PARITY BIT STORAGEXXAC = $AC   ; TAPE BUFFER START POINTER LOW BYTE; SCROLL SCREEN ?? BYTEXXA&D = $AD   ; TAPE BUFFER START POINTER HIGH BYTE; SCROLL SCREEN ?? BYTEXXAE = $AE   ; TAPE BUFFER END POINTER LOW BYTE; SCROLL SCREEN ?? BYTEXXAF = $AF   ; TAPE BUFFER END POINTER HIGH BYTE; SCROLL SCREEN ?? BYTEXXB0 = $B0   ; TAPE TIMING CONSTANT M&IN BYTEXXB1 = $B1   ; TAPE TIMING CONSTANT MAX BYTE; THESS TWO LOCATIONS POINT TO THE ADDRESS OF THE CASSETTE BUFFER. THIS POINTER MUST; BE GREATER THAN OR EQUAL TO $0200 OR AN ILLEGAL DEVICE NUMBER ERROR WILL BE SENT; WHEN TAPE I/O IS TRIED. THIS P&OINTER MUST ALSO BE LESS THAT $8000 OR THE ROUTINE; WILL TERMINATE EARLY.XXB2 = $B2   ; TAPE BUFFER START POINTER LOW BYTEXXB3 = $B3   ; TAPE BUFFER START POINTER HIGH BYTE; RS232 ROUTINES USE THIS TO COUNT THE NUMBER OF BITS TRANSMITTED AND FOR PA&RITY AND; STOP BIT MANIPULATION. TAPE LOAD ROUTINES USE THIS LOCATION TO FLAG WHEN THEY ARE; READY TO RECEIVE DATA BYTES.XXB4 = $B4   ; TRANSMITTER BIT COUNT OUT; THIS LOCATION IS USED BY THE RS232 ROUTINES TO HOLD THE NEXT BIT TO BE SENT AND BY TH&E; TAPE ROUTINES TO INDICATE WHAT PART OF A BLOCK THE READ ROUTINE IS CURRENTLY READING.XXB5 = $B5   ; TRANSMITTER NEXT BIT TO BE SENT; RS232 ROUTINES USE THIS AREA TO DISASSEMBLE EACH BYTE TO BE SENT FROM THE TRANSMISSION; BUFFER POINTED TO BY $F9&.XXB6 = $B6   ; TRANSMITTER BYTE BUFFER/DISASSEMBLY LOCATION; DISK FILENAMES MAY BE UP TO 16 CHARACTERS IN LENGTH WHILE TAPE FILENAMES BE UP TO 187; CHARACTERS IN LENGTH.; IF A TAPE NAME IS LONGER THAN 16 CHARACTERS THE EXCESS WILL BE TRUNCATED BY& THE; SEARCHING AND FOUND MESSAGES, BUT WILL STILL BE PRESENT ON THE TAPE.; A DISK FILE IS ALWAYS REFERRED TO BY A NAME. THIS LOCATION WILL ALWAYS BE GREATER THAN; ZERO IF THE CURRENT FILE IS A DISK FILE.; AN RS232 OPEN COMMAND MAY SPECIFY A FILENA&ME OF UP TO FOUR CHARACTERS. THESE CHARACTERS; ARE COPIED TO LOCATIONS $293 TO $296 AND DETERMINE BAUD RATE, WORD LENGTH, AND PARITY,; OR THEY WOULD DO IF THE FEATURE WAS FULLY IMPLEMENTED.XXB7 = $B7   ; FILE NAME LENGTHXXB8 = $B8   ; LOGICAL FILE& XXB9 = $B9   ; SECONDARY ADDRESSXXBA = $BA   ; CURRENT DEVICE NUMBER; NUMBER DEVICE; ------ ------;  0  KEYBOARD;  1  CASSETTE;  2  RS-232C;  3  SCREEN;  4-31 SERIAL BUSXXBB = $BB   ; FILE NAME POINTER LOW BYTEXXBC = $BC   ; FILE NAME POINTER H&!IGH BYTEXXBD = $BD   ; TAPE WRITE BYTE/RS232 PARITY BYTE; USED BY THE TAPE ROUTINES TO COUNT THE NUMBER OF COPIES OF A DATA BLOCK REMAINING TO; BE READ OR WRITTEN.XXBE = $BE   ; TAPE COPIES COUNTXXBF = $BF   ; PARITY COUNT ??XXC0 = $C0   ; TAPE M&"OTOR INTERLOCKXXC1 = $C1   ; I/O START ADDRESSES LOW BYTEXXC2 = $C2   ; I/O START ADDRESSES HIGH BYTEXXC3 = $C3   ; KERNAL SETUP POINTER LOW BYTEXXC4 = $C4   ; KERNAL SETUP POINTER HIGH BYTEXXC5 = $C5   ; CURRENT KEY PRESSED;;  # KEY  # KEY  # KEY&#  # KEY; -- --- -- --- -- --- -- ---; 00 1 10 NONE 20 [SPACE] 30 Q; 01 3 11 A  21 Z  31 E; 02 5 12 D  22 C  32 T; 03 7 13 G  23 B  33 U; 04 9 14 J  24 M  34 O; 05 + 15 L  25 .  35 @; 06 [UKP] 16 ;  26 NONE 36 ^; 07 [DEL] 17 [CSR R] 27 [F1] 37 [F&$5]; 08 [<-] 18 [STOP] 28 NONE 38 2; 09 W 19 NONE 29 S  39 4; 0A R 1A X  2A F  3A 6; 0B Y 1B V  2B H  3B 8; 0C I 1C N  2C K  3C 0; 0D P 1D ,  2D :  3D -; 0E * 1E /  2E =  3E [HOME]; 0F [RET] 1F [CSR D] 2F [F3] 3F [F7]XXC6 = $C6   ; KEYBOARD BUFF&%ER LENGTH/INDEX; WHEN THE [CTRL][RVS-ON] CHARACTERS ARE PRINTED THIS FLAG IS SET TO $12, AND THE PRINT; ROUTINES WILL ADD $80 TO THE SCREEN CODE OF EACH CHARACTER WHICH IS PRINTED, SO THAT; THE CARACTER WILL APPEAR ON THE SCREEN WITH ITS COLOURS REVE&&RSED.; NOTE THAT THE CONTENTS OF THIS LOCATION ARE CLEARED NOT ONLY UPON ENTRY OF A; [CTRL][RVS-OFF] CHARACTER BUT ALSO AT EVERY CARRIAGE RETURN.XXC7 = $C7   ; REVERSE FLAG $12 = REVERSE, $00 = NORMAL; THIS POINTER INDICATES THE COLUMN NUMBER OF T&'HE LAST NONBLANK CHARACTER ON THE LOGICAL; LINE THAT IS TO BE INPUT. SINCE A LOGICAL LINE CAN BE UP TO 88 CHARACTERS LONG THIS; NUMBER CAN RANGE FROM 0-87.XXC8 = $C8   ; INPUT [EOL] POINTER; THESE LOCATIONS KEEP TRACK OF THE LOGICAL LINE THAT THE C% URSOR IS ON AND ITS COLUMN; POSITION ON THAT LOGICAL LINE.; EACH LOGICAL LINE MAY CONTAIN UP TO FOUR 22 COLUMN PHYSICAL LINES. SO THERE MAY BE AS; MANY AS 23 LOGICAL LINES, OR AS FEW AS 6 AT ANY ONE TIME. THEREFORE, THE LOGICAL LINE; NUMBER MIGHT BE';***********************************************************************************;;***********************************************************************************;;; THE ALMOST COMPLETELY COMMENTED VIC 20 ROM DISASSEMBLY. V1.01 LEE DAVISON 2005'-2012.; THIS IS A BIT CORRECT ASSEMBLY LISTING FOR THE VIC 20 BASIC AND KERNAL ROMS AS ONE 16K; ROM. YOU SHOULD BE ABLE TO ASSEMBLE THE VIC ROMS FROM THIS WITH MOST 6502 ASSEMBLERS,; AS NO MACROS OR 'SPECIAL' FEATURES WERE USED. THIS HAS BEEN TESTED 'USING MICHAL; KOWALSKI'S 6502 SIMULATOR ASSEMBLE FUNCTION. SEE HTTP://EXIFPRO.COM/UTILS.HTML FOR; THIS PROGRAM.; MANY REFERENCES WERE USED TO COMPLETE THIS DISASSEMBLY INCLUDING, BUT NOT LIMITED TO,; 'MAPPING THE VIC 20', 'MAPPING THE C64', 'VIC 20 'PROGRAMMERS REFERENCE', 'VIC 20 USER; GUIDE', 'THE COMPLETE COMMODORE INNER SPACE ANTHOLOGY', 'VIC REVEALED' AND VARIOUS; TEXT FILES, PICTURES AND OTHER DOCUMENTS.;***********************************************************************************;';***********************************************************************************;;; FIRST A WHOLE LOAD OF EQUATES; THESE LOCATIONS CONTAIN THE JMP INSTRUCTION TARGET ADDRESS OF THE USR COMMAND. THEY; ARE INITIALISED SO THAT IF YOU TRY TO EXECUTE' A USR CALL WITHOUT CHANGING THEM YOU; WIL RECEIVE AN ILLEGAL QUANTITY ERROR MESSAGE.XX00 = $00   ; USR() JMP INSTRUCTIONXX01 = $01   ; USR() VECTOR LOW BYTEXX02 = $02   ; USR() VECTOR HIGH BYTE; THIS VECTOR POINTS TO THE ADDRESS OF THE BASIC ROUT'INE WHICH CONVERTS A FLOATING POINT; NUMBER TO AN INTEGER, HOWEVER BASIC DOES NOT USE THIS VECTOR. IT MAY BE OF ASSISTANCE; TO THE PROGRAMMER WHO WISHES TO USE DATA THAT IS STORED IN FLOATING POINT FORMAT. THE; PARAMETER PASSED BY THE USR COMMAND IS A'VAILABLE ONLY IN THAT FORMAT FOR EXAMPLE.XX03 = $03   ; FLOAT TO FIXED VECTOR LOW BYTEXX04 = $04   ; FLOAT TO FIXED VECTOR HIGH BYTE; THIS VECTOR POINTS TO THE ADDRESS OF THE BASIC ROUTINE WHICH CONVERTS AN INTEGER TO A; FLOATING POINT NUMBER, HOWE'	VER BASIC DOES NOT USE THIS VECTOR. IT MAY BE USED BY THE; PROGRAMMER WHO NEEDS TO MAKE SUCH A CONVERSION FOR A MACHINE LANGUAGE PROGRAM THAT; INTERACTS WITH BASIC.  TO RETURN AN INTEGER VALUE WITH THE USR COMMAND FOR EXAMPLE.XX05 = $05   ; FIXED TO '
FLOAT VECTOR LOW BYTEXX06 = $06   ; FIXED TO FLOAT VECTOR HIGH BYTE; THE CURSOR COLUMN POSITION PRIOR TO THE TAB OR SPC IS MOVED HERE FROM $D3, AND IS USED; TO CALCULATE WHERE THE CURSOR ENDS UP AFTER ONE OF THESE FUNCTIONS IS INVOKED.; NOTE THAT T'HE VALUE CONTAINED HERE SHOWS THE POSITION OF THE CURSOR ON A LOGICAL LINE.; SINCE ONE LOGICAL LINE CAN BE UP TO FOUR PHYSICAL LINES LONG, THE VALUE STORED HERE; CAN RANGE FROM 0 TO 87.XX07 = $07   ; SEARCH CHARACTERXX08 = $08   ; SCAN QUOTES FLAGX'X09 = $09   ; TAB COLUMN SAVE; THE ROUTINE THAT CONVERTS THE TEXT IN THE INPUT BUFFER INTO LINES OF EXECUTABLE PROGRAM; TOKES, AND THE ROUTINES THAT LINK THESE PROGRAM LINES TOGETHER, USE THIS LOCATION AS AN; INDEX INTO THE INPUT BUFFER AREA. AFTER T'HE JOB OF CONVERTING TEXT TO TOKENS IS DONE,; THE VALUE IN THIS LOCATION IS EQUAL TO THE LENGTH OF THE TOKENIZED LINE.; THE ROUTINES WHICH BUILD AN ARRAY OR LOCATE AN ELEMENT IN AN ARRAY USE THIS LOCATION TO; CALCULATE THE NUMBER OF DIMENSIONS CALLED' FOR AND THE AMOUNT OF STORAGE REQUIRED FOR A; NEWLY CREATED ARRAY, OR THE NUMBER OF SUBSCRIPTS WHEN REFERENCING AN ARRAY ELEMENT.XX0A = $0A   ; LOAD/VERIFY FLAG, 0 = LOAD, 1 = VERIFYXX0B = $0B   ; TEMPORARY BYTE, LINE CRUNCH/ARRAY ACCESS/LOGIC OPERA'TORS; THIS IS USED AS A FLAG BY THE ROUTINES THAT BUILD AN ARRAY OR REFERENCE AN EXISTING; ARRAY. IT IS USED TO DETERMINE WHETHER A VARIABLE IS IN AN ARRAY, WHETHER THE ARRAY; HAS ALREADY BEEN DIMENSIONED, AND WHETHER A NEW ARRAY SHOULD ASSUME THE DE'FAULT SIZE.XX0C = $0C   ; DIM FLAG; THIS FLAG IS USED TO INDICATE WHETHER DATA BEING OPERATED UPON IS STRING OR NUMERIC. A; VALUE OF $FF IN THIS LOCATION INDICATES STRING DATA WHILE A $00 INDICATES NUMERIC DATA.XX0D = $0D   ; DATA TYPE FLAG, $FF =' STRING, $00 = NUMERIC; IF THE ABOVE FLAG INDICATES NUMERIC THEN A $80 IN THIS LOCATION IDENTIFIES THE NUMBER; AS AN INTEGER, AND A $00 INDICATES A FLOATING POINT NUMBER.XX0E = $0E   ; DATA TYPE FLAG, $80 = INTEGER, $00 = FLOATING POINT; THE GARBA'GE COLLECTION ROUTINE USES THIS LOCATION AS A FLAG TO INDICATE THAT GARBAGE; COLLECTION HAS ALREADY BEEN TRIED BEFORE ADDING A NEW STRING. IF THERE IS STILL NOT; ENOUGH MEMORY, AN OUT OF MEMORY ERROR MESSAGE WILL RESULT.; LIST USES THIS BYTE AS A FLA'G TO LET IT KNOW WHEN IT HAS COME TO A CHARACTER STRING IN; QUOTES. IT WILL THEN PRINT THE STRING,RATHER THAN SEARCH IT FOR BASIC KEYWORD TOKENS.; THIS LOCATION IS ALSO USED DURING THE PROCESS OF CONVERTING A LINE OF TEXT IN THE BASIC; INPUT BUFFER I'NTO A LINKED PROGRAM LINE OF BASIC KEYWORD TOKENS TO FLAG A DATA LINE IS; BEING PROCESSED.XX0F = $0F   ; GARBAGE COLLECTED/OPEN QUOTE/DATA FLAG; IF AN OPENING PARENTHESIS IS FOUND, THIS FLAG IS SET TO INDICATE THAT THE VARIABLE IN; QUESTION IS EITH'ER AN ARRAY VARIABLE OR A USER-DEFINED FUNCTION.XX10 = $10   ; SUBSCRIPT/FNX FLAG; THIS LOCATION IS USED TO DETERMINE WHETHER THE SIGN OF THE VALUE RETURNED BY THE; FUNCTIONS SIN, COS, ATN OR TAN IS POSITIVE OR NEGATIVE.; ALSO THE COMPARISON ROUTI'NES USE THIS LOCATION TO INDICATE THE OUTCOME OF THE COMPARE.; FOR A <=> B THE VALUE HERE WILL BE $01 IF A > B, $02 IF A = B, AND $04 IF A < B. IF; MORE THAN ONE COMPARISON OPERATOR WAS USED TO COMPARE THE TWO VARIABLES THEN THE VALUE; HERE WILL BE A 'COMBINATION OF THE ABOVE VALUES.XX11 = $11   ; INPUT MODE FLAG, $00 = INPUT, $40 = GET, $98 = READXX12 = $12   ; ATN SIGN/COMPARISON EVALUATION FLAG; WHEN THE DEFAULT INPUT OR OUTPUT DEVICE IS USED THE VALUE HERE WILL BE A ZERO, AND THE; FORMAT OF 'PROMPTING AND OUTPUT WILL BE THE STANDARD SCREEN OUTPUT FORMAT. THE LOCATION; $B8 IS USED TO DECIDE WHAT DEVICE ACTUALLY TO PUT INPUT FROM OR OUTPUT TO.; THE PRINT CR/LF CODE AT XXCAD7 SUGGESTS THAT B7 OF THIS BYTE IS AN AUTOLF FLAG BIT; BUT IF IT IS' USED AS SUCH IT WOULD BREAK LOTS OF OTHER PARTS OF THE CODEXX13 = $13   ; CURRENT I/O CHANNEL; USED WHENEVER A 16 BIT INTEGER IS USED E.G. THE TARGET LINE NUMBER FOR GOTO, LIST, ON,; AND GOSUB ALSO THE NUMBER OF A BASIC LINE THAT IS TO BE ADDED OR 'REPLACED. ADDITIONALLY; PEEK, POKE, WAIT, AND SYS USE THIS LOCATION AS A POINTER TO THE ADDRESS WHICH IS THE; SUBJECT OF THE COMMAND.XX14 = $14   ; TEMPORARY INTEGER LOW BYTEXX15 = $15   ; TEMPORARY INTEGER HIGH BYTE; THIS LOCATION POINTS TO THE N'EXT AVAILABLE SLOT IN THE TEMPORARY STRING DESCRIPTOR; STACK LOCATED AT $19-$21.XX16 = $16   ; DESCRIPTOR STACK POINTER, NEXT FREE; THIS CONTAINS INFORMATION ABOUT TEMPORARY STRINGS WHICH HVE NOT YET BEEN ASSIGNED TO; A STRING VARIABLE.XX17 = $17'   ; CURRENT DESCRIPTOR STACK ITEM POINTER LOW BYTEXX18 = $18   ; CURRENT DESCRIPTOR STACK ITEM POINTER HIGH BYTEXX19 = $19   ; TO $21, DESCRIPTOR STACK; THESE LOCATIONS ARE USED BY BASIC MULTIPLICATION AND DIVISION ROUTINES. THEY ARE ALSO; USED BY 'THE ROUTINES WHICH COMPUTE THE SIZE OF THE AREA REQUIRED TO STORE AN ARRAY; WHICH IS BEING CREATED.XX22 = $22   ; MISC TEMP BYTEXX23 = $23   ; MISC TEMP BYTEXX24 = $24   ; MISC TEMP BYTEXX25 = $25   ; MISC TEMP BYTEXX26 = $26   ; TEMP MANTISSA 1'XX27 = $27   ; TEMP MANTISSA 2XX28 = $28   ; TEMP MANTISSA 3XX29 = $29   ; TEMP MANTISSA 4; TWO BYTE POINTER TO WHERE THE BASIC PROGRAM TEXT IS STORED.XX2B = $2B   ; START OF MEMORY LOW BYTEXX2C = $2C   ; START OF MEMORY HIGH BYTE; TWO BYTE POIN'TER TO THE START OF THE BASIC VARIABLE STORAGE AREA.XX2D = $2D   ; START OF VARIABLES LOW BYTEXX2E = $2E   ; START OF VARIABLES HIGH BYTE; TWO BYTE POINTER TO THE START OF THE BASIC ARRAY STORAGE AREA.XX2F = $2F   ; END OF VARIABLES LOW BYTEXX30 ' = $30   ; END OF VARIABLES HIGH BYTE; TWO BYTE POINTER TO END OF THE START OF FREE RAM.XX31 = $31   ; END OF ARRAYS LOW BYTEXX32 = $32   ; END OF ARRAYS HIGH BYTE; TWO BYTE POINTER TO THE BOTTOM OF THE STRING TEXT STORAGE AREA.XX33 = $33   ; BOT'!TOM OF STRING SPACE LOW BYTEXX34 = $34   ; BOTTOM OF STRING SPACE HIGH BYTE; USED AS A TEMPORARY POINTER TO THE MOST CURRENT STRING ADDED BY THE ROUTINES WHICH; BUILD STRINGS OR MOVE THEM IN MEMORY.XX35 = $35   ; STRING UTILITY PTR LOW BYTEXX36 = '"$36   ; STRING UTILITY PTR HIGH BYTE; TWO BYTE POINTER TO THE HIGHEST ADDRESS USED BY BASIC +1.XX37 = $37   ; END OF MEMORY LOW BYTEXX38 = $38   ; END OF MEMORY HIGH BYTE; THESE LOCATIONS CONTAIN THE LINE NUMBER OF THE BASIC STATEMENT WHICH IS CUR'#RENTLY BEING; EXECUTED. A VALUE OF $FF IN LOCATION $3A MEANS THAT BASIC IS IN IMMEDIATE MODE.XX39 = $39   ; CURRENT LINE NUMBER LOW BYTEXX3A = $3A   ; CURRENT LINE NUMBER HIGH BYTE; WHEN PROGRAM EXECUTION ENDS OR STOPS THE LAST LINE NUMBER EXECUTED'$ IS STORED HERE.XX3B = $3B   ; BREAK LINE NUMBER LOW BYTEXX3C = $3C   ; BREAK LINE NUMBER HIGH BYTE; THESE LOCATIONS CONTAIN THE ADDRESS OF THE START OF THE TEXT OF THE BASIC STATEMENT; THAT IS BEING EXECUTED.  THE VALUE OF THE POINTER TO THE ADDRE'%SS OF THE BASIC TEXT; CHARACTER CURRENTLY BEING SCANNED IS STORED HERE EACH TIME A NEW BASIC STATEMENT BEGINS; EXECUTION.XX3D = $3D   ; CONTINUE POINTER LOW BYTEXX3E = $3E   ; CONTINUE POINTER HIGH BYTE; THESE LOCATIONS HOLD THE LINE NUMBER OF THE'& CURRENT DATA STATEMENT BEING READ. IF AN; ERROR CONCERNING THE DATA OCCURS THIS NUMBER WILL BE MOVED TO $39/$3A SO THAT THE ERROR; MESSAGE WILL SHOW THE LINE THAT CONTAINS THE DATA STATEMENT RATHER THAN IN THE LINE THAT; CONTAINS THE READ STATEMENT.''XX3F = $3F   ; CURRENT DATA LINE NUMBER LOW BYTEXX40 = $40   ; CURRENT DATA LINE NUMBER HIGH BYTE; THESE LOCATIONS POINT TO THE ADDRESS WHERE THE NEXT DATA WILL BE READ FROM. RESTORE; SETS THIS POINTER BACK TO THE ADDRESS INDICATED BY THE START OF B& ASIC POINTER.XX41 = $41   ; DATA POINTER LOW BYTEXX42 = $42   ; DATA POINTER HIGH BYTE; READ, INPUT AND GET ALL USE THIS AS A POINTER TO THE ADDRESS OF THE SOURCE OF INCOMING; DATA, SUCH AS DATA STATEMENTS, OR THE TEXT INPUT BUFFER.XX43 = $43   ;(D VIC20BASICKERNAL3D                                                                                                                                                                                                                                   (D                                                                                                                                                                                                                                                   $ D                                                                                                                                                                              (((((((((((( ' BK.ASM         	  >'BK.OBJ            CBK         A    CBK         A    *BK.OBJ             .BASICKERNAL         A                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 )              ; DECREMENT LOOP COUNT     BNE     XXE8FE          ; LOOP IF MORE TO TEST     RTS                         ; CURSOR IS AT END OF LINEXXE909 = *     LDX     XXD6          ; GET CURSOR ROW     CPX     #$17               ; COMPARE WITH )END OF SCREEN     BEQ     XXE911          ; EXIT IF END OF SCREEN     INC     XXD6          ; ELSE INCREMENT CURSOR ROWXXE911 = *     RTS;***********************************************************************************;;; SET COLOUR CODE. EN)TER WITH THE COLOUR CHARACTER IN A. IF A DOES NOT CONTAIN A; COLOUR CHARACTER THIS ROUTINE EXITS WITHOUT CHANGING THE COLOURXXE912 = *     LDX     #XXE928-XXE921                         ; SET COLOUR CODE COUNTXXE914 = *     CMP     XXE921,X       )   ; COMPARE THE CHARACTER WITH THE TABLE CODE     BEQ     XXE91D          ; IF A MATCH GO SAVE THE COLOUR AND EXIT     DEX                    ; ELSE DECREMENT THE INDEX     BPL     XXE914          ; LOOP IF MORE TO DO     RTSXXE91D = *     STX )    XX0286          ; SET CURRENT COLOUR CODE     RTS;***********************************************************************************;;; ASCII COLOUR CODE TABLE                         ; CHR$()     COLOURXXE921                    ; ------    ) ------     .BYTE     $90               ;  144     BLACK     .BYTE     $05               ;    5     WHITE     .BYTE     $1C               ;   28     RED     .BYTE     $9F               ;  159     CYAN     .BYTE     $9C               ;  156     MAGEN)TA     .BYTE     $1E               ;   30     GREEN     .BYTE     $1F               ;   31     BLUEXXE928 = *     .BYTE     $9E               ;  158     YELLOW;***********************************************************************************;;); CODE CONVERSION, THESE DON'T SEEM TO BE USED ANYWHERE;XXE929     .BYTE     $EF,$A1,$DF,$A6,$E1,$B1,$E2,$B2,$E3,$B3,$E4,$B4,$E5,$B5,$E6,$B6     .BYTE     $E7,$B7,$E8,$B8,$E9,$B9,$FA,$BA,$FB,$BB,$FC,$BC,$EC,$BD,$FE,$BE     .BYTE     $84,$BF,$F7,$C0,)	$F8,$DB,$F9,$DD,$EA,$DE,$5E,$E0,$5B,$E1,$5D,$E2     .BYTE     $40,$B0,$61,$B1,$78,$DB,$79,$DD,$66,$B6,$77,$C0,$70,$F0,$71,$F1     .BYTE     $72,$F2,$73,$F3,$74,$F4,$75,$F5,$76,$F6,$7D,$FD;*************************************************************)
**********************;;; SCROLL SCREENXXE975 = *     LDA     XXAC          ; COPY TAPE BUFFER START POINTER     PHA                    ; SAVE IT     LDA     XXAD          ; COPY TAPE BUFFER START POINTER     PHA                    ; SAVE IT    ) LDA     XXAE          ; COPY TAPE BUFFER END POINTER     PHA                    ; SAVE IT     LDA     XXAF          ; COPY TAPE BUFFER END POINTER     PHA                    ; SAVE ITXXE981 = *     LDX     #$FF               ; SET TO -1 FOR PRE INC)REMENT LOOP     DEC     XXD6          ; DECREMENT CURSOR ROW     DEC     XXC9          ; DECREMENT INPUT CURSOR ROW     DEC     XXF2          ; DECREMENT SCREEN ROW MARKERXXE989 = *     INX                    ; INCREMENT LINE NUMBER     JSR     XXE)A7E          ; SET START OF LINE X     CPX     #$16               ; COMPARE WITH LAST LINE     BCS     XXE99D          ; BRANCH IF >= $16     LDA     XXEDFD+1,X     ; GET START OF NEXT LINE POINTER LOW BYTE     STA     XXAC          ; SAVE NEXT LINE) POINTER LOW BYTE     LDA     XXD9+1,X          ; GET START OF NEXT LINE POINTER HIGH BYTE     JSR     XXEA56          ; SHIFT SCREEN LINE UP     BMI     XXE989          ; LOOP, BRANCH ALWAYSXXE99D = *     JSR     XXEA8D          ; CLEAR SCREEN LIN)E X                         ; NOW SHIFT UP THE START OF LOGICAL LINE BITS     LDX     #$00               ; CLEAR INDEXXXE9A2 = *     LDA     XXD9,X          ; GET START OF LINE X POINTER HIGH BYTE     AND     #$7F               ; CLEAR LINE X START) OF LOGICAL LINE BIT     LDY     XXD9+1,X          ; GET START OF NEXT LINE POINTER HIGH BYTE     BPL     XXE9AC          ; BRANCH IF NEXT LINE NOT START OF LINE     ORA     #$80               ; SET LINE X START OF LOGICAL LINE BITXXE9AC = *     ST)A     XXD9,X          ; SET START OF LINE X POINTER HIGH BYTE     INX                    ; INCREMENT LINE NUMBER     CPX     #$16               ; COMPARE WITH LAST LINE     BNE     XXE9A2          ; LOOP IF NOT LAST LINE     LDA     XXD9+$16        )  ; GET START OF LAST LINE POINTER HIGH BYTE     ORA     #$80               ; MARK AS START OF LOGICAL LINE     STA     XXD9+$16          ; SET START OF LAST LINE POINTER HIGH BYTE     LDA     XXD9          ; GET START OF FIRST LINE POINTER HIGH BYTE)     BPL     XXE981          ; IF NOT START OF LOGICAL LINE LOOP BACK AND                         ; SCROLL THE SCREEN UP ANOTHER LINE     INC     XXD6          ; INCREMENT CURSOR ROW     INC     XXF2          ; INCREMENT SCREEN ROW MARKER     LDA   )  #$FB               ; SET KEYBOARD COLUMN C2     STA     XX9120          ; SET VIA 2 DRB, KEYBOARD COLUMN     LDA     XX9121          ; GET VIA 2 DRA, KEYBOARD ROW     CMP     #$FE               ; COMPARE WITH ROW R0 ACTIVE, [CTL]     PHP           )         ; SAVE STATUS     LDA     #$F7               ; SET KEYBOARD COLUMN C3     STA     XX9120          ; SET VIA 2 DRB, KEYBOARD COLUMN     PLP                    ; RESTORE STATUS     BNE     XXE9DF          ; SKIP DELAY IF ??                  )       ; FIRST TIME ROUND THE INNER LOOP X WILL BE $16     LDY     #$00               ; CLEAR DELAY OUTER LOOP COUNT, DO THIS 256 TIMESXXE9D6 = *     NOP                    ; WASTE CYCLES     DEX                    ; DECREMENT INNER LOOP COUNT     B)NE     XXE9D6          ; LOOP IF NOT ALL DONE     DEY                    ; DECREMENT OUTER LOOP COUNT     BNE     XXE9D6          ; LOOP IF NOT ALL DONE     STY     XXC6          ; CLEAR KEYBOARD BUFFER INDEXXXE9DF = *     LDX     XXD6          ; )GET CURSOR ROW     PLA                    ; PULL TAPE BUFFER END POINTER     STA     XXAF          ; RESTORE IT     PLA                    ; PULL TAPE BUFFER END POINTER     STA     XXAE          ; RESTORE IT     PLA                    ; PULL TAPE B)UFFER POINTER     STA     XXAD          ; RESTORE IT     PLA                    ; PULL TAPE BUFFER POINTER     STA     XXAC          ; RESTORE IT     RTS;***********************************************************************************;;; OPEN) SPACE ON SCREENXXE9EE = *     LDX     XXD6          ; GET CURSOR ROWXXE9F0 = *     INX                    ; INCREMENT ROW     LDA     XXD9,X          ; GET START OF LINE X POINTER HIGH BYTE     BPL     XXE9F0          ; BRANCH IF NOT START OF LOG)ICAL LINE     STX     XXF2          ; SET SCREEN ROW MARKER     CPX     #$16               ; COMPARE WITH LAST LINE     BEQ     XXEA08          ; BRANCH IF = LAST LINE     BCC     XXEA08          ; BRANCH IF < LAST LINE                         ; )ELSE WAS > LAST LINE     JSR     XXE975          ; ELSE SCROLL SCREEN     LDX     XXF2          ; GET SCREEN ROW MARKER     DEX                    ; DECREMENT SCREEN ROW MARKER     DEC     XXD6          ; DECREMENT CURSOR ROW     JMP     XXE70E     )     ; ADD THIS ROW TO THE CURRENT LOGICAL LINE AND RETURNXXEA08 = *     LDA     XXAC          ; COPY TAPE BUFFER POINTER     PHA                    ; SAVE IT     LDA     XXAD          ; COPY TAPE BUFFER POINTER     PHA                    ; SAVE IT)     LDA     XXAE          ; COPY TAPE BUFFER END POINTER     PHA                    ; SAVE IT     LDA     XXAF          ; COPY TAPE BUFFER END POINTER     PHA                    ; SAVE IT     LDX     #$17               ; SET TO END LINE + 1 FOR PRE)DECREMENT LOOPXXEA16 = *     DEX                    ; DECREMENT LINE NUMBER     JSR     XXEA7E          ; SET START OF LINE X     CPX     XXF2          ; COMPARE WITH SCREEN ROW MARKER     BCC     XXEA2C          ; BRANCH IF < SCREEN ROW MARKER   )   BEQ     XXEA2C          ; BRANCH IF = SCREEN ROW MARKER     LDA     XXEDFD-1,X     ; ELSE GET START OF PREVIOUS LINE LOW BYTE FROM ROM TABLE     STA     XXAC          ; SAVE PREVIOUS LINE POINTER LOW BYTE     LDA     XXD9-1,X          ; GET START O)!F PREVIOUS LINE POINTER HIGH BYTE     JSR     XXEA56          ; SHIFT SCREEN LINE DOWN     BMI     XXEA16          ; LOOP, BRANCH ALWAYSXXEA2C = *     JSR     XXEA8D          ; CLEAR SCREEN LINE X     LDX     #$15               ;.XXEA31 = *     C)"PX     XXF2          ;.COMPARE WITH SCREEN ROW MARKER     BCC     XXEA44          ;.     LDA     XXD9+1,X          ;.     AND     #$7F               ;.     LDY     XXD9,X          ; GET START OF LINE X POINTER HIGH BYTE     BPL     XXEA3F          )#;.     ORA     #$80               ;.XXEA3F = *     STA     XXD9+1,X          ;.     DEX                    ;.     BNE     XXEA31          ;.XXEA44 = *     LDX     XXF2          ;.GET SCREEN ROW MARKER     JSR     XXE70E          ; ADD THIS ROW )$TO THE CURRENT LOGICAL LINE     PLA                    ; PULL TAPE BUFFER END POINTER     STA     XXAF          ; RESTORE IT     PLA                    ; PULL TAPE BUFFER END POINTER     STA     XXAE          ; RESTORE IT     PLA                    )%; PULL TAPE BUFFER POINTER     STA     XXAD          ; RESTORE IT     PLA                    ; PULL TAPE BUFFER POINTER     STA     XXAC          ; RESTORE IT     RTS;********************************************************************************)&***;;; SHIFT SCREEN LINE UP/DOWNXXEA56 = *     AND     #$03               ; MASK 0000 00XX, LINE MEMORY PAGE     ORA     XX0288          ; OR WITH SCREEN MEMORY PAGE     STA     XXAD          ; SAVE NEXT/PREVIOUS LINE POINTER HIGH BYTE     JSR   )'  XXEA6E          ; CALCULATE POINTERS TO SCREEN LINES COLOUR RAMXXEA60 = *     LDY     #$15               ; SET COLUMN COUNTXXEA62 = *     LDA     (XXAC),Y          ; GET CHARACTER FROM NEXT/PREVIOUS SCREEN LINE     STA     (XXD1),Y          ; SAVE*  CHARACTER TO CURRENT SCREEN LINE     LDA     (XXAE),Y          ; GET COLOUR FROM NEXT/PREVIOUS SCREEN LINE COLOUR RAM     STA     (XXF3),Y          ; SAVE COLOUR TO CURRENT SCREEN LINE COLOUR RAM     DEY                    ; DECREMENT COLUMN INDEX/CO*UNT     BPL     XXEA62          ; LOOP IF MORE TO DO     RTS;***********************************************************************************;;; CALCULATE POINTERS TO SCREEN LINES COLOUR RAMXXEA6E = *     JSR     XXEAB2          ; CALCULATE* POINTER TO CURRENT SCREEN LINE COLOUR RAM     LDA     XXAC          ; GET NEXT SCREEN LINE POINTER LOW BYTE     STA     XXAE          ; SAVE NEXT SCREEN LINE COLOUR RAM POINTER LOW BYTE     LDA     XXAD          ; GET NEXT SCREEN LINE POINTER HIGH BY*TE     AND     #$03               ; MASK 0000 00XX, LINE MEMORY PAGE     ORA     #$94               ; SET  1001 01XX, COLOUR MEMORY PAGE     STA     XXAF          ; SAVE NEXT SCREEN LINE COLOUR RAM POINTER HIGH BYTE     RTS;************************************************************************************;;; SET START OF LINE XXXEA7E = *     LDA     XXEDFD,X          ; GET START OF LINE LOW BYTE FROM ROM TABLE     STA     XXD1          ; SET CURRENT SCREEN LINE POINTER LOW BYTE     LDA   *  XXD9,X          ; GET START OF LINE HIGH BYTE FROM RAM TABLE     AND     #$03               ; MASK 0000 00XX, LINE MEMORY PAGE     ORA     XX0288          ; OR WITH SCREEN MEMORY PAGE     STA     XXD2          ; SET CURRENT SCREEN LINE POINTER HIGH *BYTE     RTS;***********************************************************************************;;; CLEAR SCREEN LINE XXXEA8D = *     LDY     #$15               ; SET NUMBER OF COLUMNS TO CLEAR     JSR     XXEA7E          ; SET START OF LINE X*     JSR     XXEAB2          ; CALCULATE POINTER TO COLOUR RAMXXEA95 = *     LDA     #' '               ; SET [SPACE]     STA     (XXD1),Y          ; CLEAR CHARACTER IN CURRENT SCREEN LINE     LDA     #$01               ; SET COLOUR, BLUE ON WHITE  *   STA     (XXF3),Y          ; SET COLOUR RAM IN CURRENT SCREEN LINE     DEY                    ; DECREMENT INDEX     BPL     XXEA95          ; LOOP IF MORE TO DO     RTS;*****************************************************************************	*******;;; PRINT CHARACTER A AND COLOUR X TO SCREENXXEAA1 = *     TAY                    ; COPY CHARACTER     LDA     #$02               ; SET COUNT TO $02, USUALLY $14 ??     STA     XXCD          ; SET CURSOR COUNTDOWN     JSR     XXEAB2       *
   ; CALCULATE POINTER TO COLOUR RAM     TYA                    ; GET CHARACTER BACK; SAVE CHARACTER AND COLOUR TO SCREEN @ CURSORXXEAAA = *     LDY     XXD3          ; GET CURSOR COLUMN     STA     (XXD1),Y          ; SAVE CHARACTER FROM CURRENT *SCREEN LINE     TXA                    ; COPY COLOUR TO A     STA     (XXF3),Y          ; SAVE TO COLOUR RAM     RTS;***********************************************************************************;;; CALCULATE POINTER TO COLOUR RAMXXEAB2 = **     LDA     XXD1          ; GET CURRENT SCREEN LINE POINTER LOW BYTE     STA     XXF3          ; SAVE POINTER TO COLOUR RAM LOW BYTE     LDA     XXD2          ; GET CURRENT SCREEN LINE POINTER HIGH BYTE     AND     #$03               ; MASK 0000 00*XX, LINE MEMORY PAGE     ORA     #$94               ; SET  1001 01XX, COLOUR MEMORY PAGE     STA     XXF4          ; SAVE POINTER TO COLOUR RAM HIGH BYTE     RTS;***********************************************************************************;;*; UPDATE THE CLOCK, FLASH THE CURSOR, CONTROL THE CASSETTE AND SCAN THE KEYBOARD; IRQ HANDLERXXEABF = *     JSR     XXFFEA          ; INCREMENT REAL TIME CLOCK     LDA     XXCC          ; GET CURSOR ENABLE     BNE     XXEAEF          ; BRANCH IF *NOT FLASH CURSOR     DEC     XXCD          ; ELSE DECREMENT CURSOR TIMING COUNTDOWN     BNE     XXEAEF          ; BRANCH IF NOT DONE     LDA     #$14               ; SET COUNT     STA     XXCD          ; SAVE CURSOR TIMING COUNTDOWN     LDY     XX*D3          ; GET CURSOR COLUMN     LSR     XXCF          ; SHIFT B0 CURSOR BLINK PHASE INTO CARRY     LDX     XX0287          ; GET COLOUR UNDER CURSOR     LDA     (XXD1),Y          ; GET CHARACTER FROM CURRENT SCREEN LINE     BCS     XXEAEA        *  ; BRANCH IF CURSOR PHASE B0 WAS 1     INC     XXCF          ; SET CURSOR BLINK PHASE TO 1     STA     XXCE          ; SAVE CHARACTER UNDER CURSOR     JSR     XXEAB2          ; CALCULATE POINTER TO COLOUR RAM     LDA     (XXF3),Y          ; GET COL*OUR RAM BYTE     STA     XX0287          ; SAVE COLOUR UNDER CURSOR     LDX     XX0286          ; GET CURRENT COLOUR CODE     LDA     XXCE          ; GET CHARACTER UNDER CURSORXXEAEA = *     EOR     #$80               ; TOGGLE B7 OF CHARACTER UNDER *CURSOR     JSR     XXEAAA          ; SAVE CHARACTER AND COLOUR TO SCREEN @ CURSORXXEAEF = *     LDA     XX911F          ; GET VIA 1 DRA, NO HANDSHAKE     AND     #$40               ; MASK CASSETTE SWITCH SENSE     BEQ     XXEB01          ; BRANCH IF* CASSETTE SENSE LOW                         ; CASSETTE SENSE WAS HIGH SO TURN OFF MOTOR AND CLEAR                         ; THE INTERLOCK     LDY     #$00               ; CLEAR Y     STY     XXC0          ; CLEAR THE TAPE MOTOR INTERLOCK     LDA   *  XX911C          ; GET VIA 1 PCR     ORA     #$02               ; SET CA2 HIGH, TURN OFF MOTOR     BNE     XXEB0A          ; BRANCH ALWAYS                         ; CASSETTE SENSE WAS LOW SO TURN ON MOTOR, PERHAPSXXEB01 = *     LDA     XXC0       *   ; GET TAPE MOTOR INTERLOCK     BNE     XXEB12          ; IF CASSETTE INTERLOCK <> 0 DON'T TURN ON MOTOR     LDA     XX911C          ; GET VIA 1 PCR     AND     #$FD               ; SET CA2 LOW, TURN ON MOTORXXEB0A = *     BIT     XX911E         * ; TEST VIA 1 IER     BVS     XXEB12          ; IF T1 INTERRUPT ENABLED DON'T CHANGE MOTOR STATE     STA     XX911C          ; SET VIA 1 PCR, SET CA2 HIGH/LOWXXEB12 = *     JSR     XXEB1E          ; SCAN KEYBOARD     BIT     XX9124          ; TEST *VIA 2 T1C_L, CLEAR THE TIMER INTERRUPT FLAG     PLA                    ; PULL Y     TAY                    ; RESTORE Y     PLA                    ; PULL X     TAX                    ; RESTORE X     PLA                    ; RESTORE A     RTI;************************************************************************************;;; SCAN KEYBOARD PERFORMS THE FOLLOWING ..;; 1)     CHECK IF KEY PRESSED, IF NOT THEN EXIT THE ROUTINE;; 2)     INIT I/O PORTS OF VIA 2 FOR KEYBOARD SCAN AND SET POINTE*RS TO DECODE TABLE 1.;     CLEAR THE CHARACTER COUNTER;; 3)     SET ONE LINE OF PORT B LOW AND TEST FOR A CLOSED KEY ON PORT A BY SHIFTING THE;     BYTE READ FROM THE PORT. IF THE CARRY IS CLEAR THEN A KEY IS CLOSED SO SAVE THE;     COUNT WHICH IS I*NCREMENTED ON EACH SHIFT. CHECK FOR SHIFT/STOP/CBM KEYS AND;     FLAG IF CLOSED;; 4)     REPEAT STEP 3 FOR THE WHOLE MATRIX;; 5)     EVALUATE THE SHIFT/CTRL/C= KEYS, THIS MAY CHANGE THE DECODE TABLE SELECTED;; 6)     USE THE KEY COUNT SAVED IN STE*P 3 AS AN INDEX INTO THE TABLE SELECTED IN STEP 5;; 7)     CHECK FOR KEY REPEAT OPERATION;; 8)     SAVE THE DECODED KEY TO THE BUFFER IF FIRST PRESS OR REPEAT; SCAN KEYBOARD; THIS ROUTINE WILL SCAN THE KEYBOARD AND CHECK FOR PRESSED KEYS. IT IS T*HE SAME; ROUTINE CALLED BY THE INTERRUPT HANDLER. IF A KEY IS DOWN, ITS ASCII VALUE IS; PLACED IN THE KEYBOARD QUEUE.XXEB1E = *     LDA     #$00               ; CLEAR A     STA     XX028D          ; CLEAR KEYBOARD SHIFT/CONTROL/C= FLAG     LDY    * #$40               ; SET NO KEY     STY     XXCB          ; SAVE WHICH KEY     STA     XX9120          ; CLEAR VIA 2 DRB, KEYBOARD COLUMN     LDX     XX9121          ; GET VIA 2 DRA, KEYBOARD ROW     CPX     #$FF               ; COMPARE WITH ALL BIT*S SET     BEQ     XXEB8F          ; IF NO KEY PRESSED CLEAR CURRENT KEY AND EXIT (DOES                         ; FURTHER BEQ TO XXEBBA)     LDA     #$FE               ; SET COLUMN 0 LOW     STA     XX9120          ; SET VIA 2 DRB, KEYBOARD COLUMN  *    LDY     #$00               ; CLEAR KEY COUNT     LDA     #<XXEC5E          ; GET DECODE TABLE LOW BYTE     STA     XXF5          ; SET KEYBOARD POINTER LOW BYTE     LDA     #>XXEC5E          ; GET DECODE TABLE HIGH BYTE     STA     XXF6          ;*! SET KEYBOARD POINTER HIGH BYTEXXEB40 = *     LDX     #$08               ; SET ROW COUNT     LDA     XX9121          ; GET VIA 2 DRA, KEYBOARD ROW     CMP     XX9121          ; COMPARE WITH ITSELF     BNE     XXEB40          ; LOOP IF CHANGINGXXEB*"4A = *     LSR A                  ; SHIFT ROW TO CB     BCS     XXEB63          ; IF NO KEY CLOSED ON THIS ROW GO DO NEXT ROW     PHA                    ; SAVE ROW     LDA     (XXF5),Y          ; GET CHARACTER FROM DECODE TABLE     CMP     #$05    *#           ; COMPARE WITH $05, THERE IS NO $05 KEY BUT THE CONTROL                         ; KEYS ARE ALL LESS THAN $05     BCS     XXEB60          ; IF NOT SHIFT/CONTROL/C=/STOP GO SAVE KEY COUNT                         ; ELSE WAS SHIFT/CONTROL/C=/S*$TOP KEY     CMP     #$03               ; COMPARE WITH $03, STOP     BEQ     XXEB60          ; IF STOP GO SAVE KEY COUNT AND CONTINUE                         ; CHARACTER IS $01 - SHIFT, $02 - C= OR $04 - CONTROL     ORA     XX028D          ; OR KEYBO*%ARD SHIFT/CONTROL/C= FLAG     STA     XX028D          ; SAVE KEYBOARD SHIFT/CONTROL/C= FLAG     BPL     XXEB62          ; SKIP SAVE KEY, BRANCH ALWAYSXXEB60 = *     STY     XXCB          ; SAVE KEY COUNTXXEB62 = *     PLA                    ; REST*&ORE ROWXXEB63 = *     INY                    ; INCREMENT KEY COUNT     CPY     #$41               ; COMPARE WITH MAX+1     BCS     XXEB71          ; EXIT LOOP IF >= MAX+1                         ; ELSE STILL IN MATRIX     DEX                    ; *'DECREMENT ROW COUNT     BNE     XXEB4A          ; LOOP IF MORE ROWS TO DO     SEC                    ; SET CARRY FOR KEYBOARD COLUMN SHIFT     ROL     XX9120          ; SHIFT VIA 2 DRB, KEYBOARD COLUMN     BNE     XXEB40          ; LOOP FOR NEXT COL+ UMN, BRANCH ALWAYSXXEB71 = *     JMP     (XX028F)          ; EVALUATE THE SHIFT/CTRL/C= KEYS, XXEBDC; KEY DECODING CONTINUES HERE AFTER THE SHIFT/CTRL/C= KEYS ARE EVALUATEDXXEB74 = *     LDY     XXCB          ; GET SAVED KEY COUNT     LDA     (X+XF5),Y          ; GET CHARACTER FROM DECODE TABLE     TAX                    ; COPY CHARACTER TO X     CPY     XXC5          ; COMPARE KEY COUNT WITH LAST KEY COUNT     BEQ     XXEB84          ; IF THIS KEY = CURRENT KEY, KEY HELD, GO TEST REPEAT   +  LDY     #$10               ; SET REPEAT DELAY COUNT     STY     XX028C          ; SAVE REPEAT DELAY COUNT     BNE     XXEBBA          ; GO SAVE KEY TO BUFFER AND EXIT, BRANCH ALWAYSXXEB84 = *     AND     #$7F               ; CLEAR B7     BIT     +XX028A          ; TEST KEY REPEAT     BMI     XXEBA1          ; BRANCH IF REPEAT ALL     BVS     XXEBD6          ; BRANCH IF REPEAT NONE     CMP     #$7F               ; COMPARE WITH END MARKERXXEB8F = *     BEQ     XXEBBA          ; IF $00/END MA+RKER GO SAVE KEY TO BUFFER AND EXIT     CMP     #$14               ; COMPARE WITH [INSERT]/[DELETE]     BEQ     XXEBA1          ; IF [INSERT]/[DELETE] GO TEST FOR REPEAT     CMP     #' '               ; COMPARE WITH [SPACE]     BEQ     XXEBA1      +    ; IF [SPACE] GO TEST FOR REPEAT     CMP     #$1D               ; COMPARE WITH [CURSOR RIGHT]     BEQ     XXEBA1          ; IF [CURSOR RIGHT] GO TEST FOR REPEAT     CMP     #$11               ; COMPARE WITH [CURSOR DOWN]     BNE     XXEBD6      +    ; IF NOT [CURSOR DOWN] JUST EXIT                         ; WAS ONE OF THE CURSOR MOVEMENT KEYS, INSERT/DELETE                         ; KEY OR THE SPACE BAR SO ALWAYS DO REPEAT TESTSXXEBA1 = *     LDY     XX028C          ; GET REPEAT DELAY COUNT+ER     BEQ     XXEBAB          ; BRANCH IF DELAY EXPIRED     DEC     XX028C          ; ELSE DECREMENT REPEAT DELAY COUNTER     BNE     XXEBD6          ; BRANCH IF DELAY NOT EXPIRED                         ; REPEAT DELAY COUNTER HAS EXPIREDXXEBAB =+ *     DEC     XX028B          ; DECREMENT REPEAT SPEED COUNTER     BNE     XXEBD6          ; BRANCH IF REPEAT SPEED COUNT NOT EXPIRED     LDY     #$04               ; SET FOR 4/60THS OF A SECOND     STY     XX028B          ; SET REPEAT SPEED COUNTE+	R     LDY     XXC6          ; GET KEYBOARD BUFFER INDEX     DEY                    ; DECREMENT IT     BPL     XXEBD6          ; IF THE BUFFER ISN'T EMPTY JUST EXIT                         ; ELSE REPEAT THE KEY IMMEDIATELY; POSSIBLY SAVE THE KEY TO+
 THE KEYBOARD BUFFER. IF THERE WAS NO KEY PRESSED OR THE KEY; WAS NOT FOUND DURING THE SCAN (POSSIBLY DUE TO KEY BOUNCE) THEN X WILL BE $FF HEREXXEBBA = *     LDY     XXCB          ; GET THE KEY COUNT     STY     XXC5          ; SAVE AS THE CURRENT +KEY COUNT     LDY     XX028D          ; GET KEYBOARD SHIFT/CONTROL/C= FLAG     STY     XX028E          ; SAVE AS LAST KEYBOARD SHIFT PATTERN     CPX     #$FF               ; COMPARE CHARACTER WITH TABLE END MARKER OR NO KEY     BEQ     XXEBD6        +  ; IF TABLE END MARKER OR NO KEY JUST EXIT     TXA                    ; COPY CHARACTER TO A     LDX     XXC6          ; GET KEYBOARD BUFFER INDEX     CPX     XX0289          ; COMPARE WITH KEYBOARD BUFFER SIZE     BCS     XXEBD6          ; IF BUFFE+R FULL JUST EXIT     STA     XX0277,X          ; SAVE CHARACTER TO KEYBOARD BUFFER     INX                    ; INCREMENT INDEX     STX     XXC6          ; SAVE KEYBOARD BUFFER INDEXXXEBD6 = *     LDA     #$F7               ; ENABLE COLUMN 3 FOR ST+OP KEY     STA     XX9120          ; SET VIA 2 DRB, KEYBOARD COLUMN     RTS; EVALUATE SHIFT/CTRL/C= KEYS;; 0     $00     EC5E; 1     $02     EC9F; 2     $04     ECE0; 3     ..     ....; 4     $06     EDA3; 5     $06     EDA3; 6     $06     ED+A3; 7     $06     EDA3XXEBDC = *     LDA     XX028D          ; GET KEYBOARD SHIFT/CONTROL/C= FLAG     CMP     #$03               ; COMPARE WITH [SHIFT][C=]     BNE     XXEC0F          ; BRANCH IF NOT [SHIFT][C=]     CMP     XX028E          ; COMP+ARE WITH LAST     BEQ     XXEBD6          ; EXIT IF STILL THE SAME     LDA     XX0291          ; GET SHIFT MODE SWITCH $00 = ENABLED, $80 = LOCKED     BMI     XXEC43          ; IF LOCKED CONTINUE KEYBOARD DECODE     NOP                    ; JUST A +FEW WASTED CYCLES     NOP                    ;     NOP                    ;     NOP                    ;     NOP                    ;     NOP                    ;     NOP                    ;     NOP                    ;     NOP                  +  ;     NOP                    ;     NOP                    ;     NOP                    ;     NOP                    ;     NOP                    ;     NOP                    ;     NOP                    ;     NOP                    ;     NOP  +                  ;     NOP                    ;                         ; TOGGLE TEXT MODE     LDA     XX9005          ; GET START OF CHARACTER MEMORY, ROM     EOR     #$02               ; TOGGLE $8000,$8800     STA     XX9005          ; SET START+ OF CHARACTER MEMORY, ROM     NOP                    ;     NOP                    ;     NOP                    ;     NOP                    ;     JMP     XXEC43          ; CONTINUE KEYBOARD DECODE                         ; WAS NOT [SHIFT][C=] BUT +COULD BE ANY OTHER COMBINATIONXXEC0F = *     ASL A                  ; << 1     CMP     #$08               ; COMPARE WITH [CTRL]     BCC     XXEC18          ; BRANCH IF NOT [CTRL] PRESSED     LDA     #$06               ; ELSE [CTRL] WAS PRESSED SO M+AKE INDEX = $06     NOP                    ;     NOP                    ;XXEC18 = *     NOP                    ; JUST A FEW WASTED CYCLES     NOP                    ;     NOP                    ;     NOP                    ;     NOP              +      ;     NOP                    ;     NOP                    ;     NOP                    ;     NOP                    ;     NOP                    ;     NOP                    ;     NOP                    ;     NOP                    ;     N+OP                    ;     NOP                    ;     NOP                    ;     NOP                    ;     NOP                    ;     NOP                    ;     NOP                    ;     NOP                    ;     NOP            +        ;     NOP                    ;     NOP                    ;     NOP                    ;     NOP                    ;     NOP                    ;     NOP                    ;     NOP                    ;     NOP                    ;    + NOP                    ;     NOP                    ;     TAX                    ; COPY INDEX TO X     LDA     XXEC46,X          ; GET DECODE TABLE POINTER LOW BYTE     STA     XXF5          ; SAVE DECODE TABLE POINTER LOW BYTE     LDA     XXEC46+1+,X     ; GET DECODE TABLE POINTER HIGH BYTE     STA     XXF6          ; SAVE DECODE TABLE POINTER HIGH BYTEXXEC43 = *     JMP     XXEB74          ; CONTINUE KEYBOARD DECODE;***************************************************************************+********;;; KEYBOARD DECODE TABLE POINTERSXXEC46 = *     .WORD     XXEC5E          ; UNSHIFTED     .WORD     XXEC9F          ; SHIFTED     .WORD     XXECE0          ; COMMODORE     .WORD     XXEDA3          ; CONTROL     .WORD     XXEC5E        +  ; UNSHIFTED     .WORD     XXEC9F          ; SHIFTED     .WORD     XXED69          ; SHFITED     .WORD     XXEDA3          ; CONTROL     .WORD     XXED21          ; GRAPHICS/TEXT CONTROL     .WORD     XXED69          ; SHIFTED     .WORD     XXED69+          ; SHIFTED     .WORD     XXEDA3          ; CONTROL; KEYBOARD DECODE TABLE - UNSHIFTEDXXEC5E = *     .BYTE     $31,$33,$35,$37,$39,$2B,$5C,$14     .BYTE     $5F,$57,$52,$59,$49,$50,$2A,$0D     .BYTE     $04,$41,$44,$47,$4A,$4C,$3B,$1D   +  .BYTE     $03,$01,$58,$56,$4E,$2C,$2F,$11     .BYTE     $20,$5A,$43,$42,$4D,$2E,$01,$85     .BYTE     $02,$53,$46,$48,$4B,$3A,$3D,$86     .BYTE     $51,$45,$54,$55,$4F,$40,$5E,$87     .BYTE     $32,$34,$36,$38,$30,$2D,$13,$88     .BYTE     $FF; + KEYBOARD DECODE TABLE - SHIFTEDXXEC9F = *     .BYTE     $21,$23,$25,$27,$29,$DB,$A9,$94     .BYTE     $5F,$D7,$D2,$D9,$C9,$D0,$C0,$8D     .BYTE     $04,$C1,$C4,$C7,$CA,$CC,$5D,$9D     .BYTE     $83,$01,$D8,$D6,$CE,$3C,$3F,$91     .BYTE     $A0,$DA+!,$C3,$C2,$CD,$3E,$01,$89     .BYTE     $02,$D3,$C6,$C8,$CB,$5B,$3D,$8A     .BYTE     $D1,$C5,$D4,$D5,$CF,$BA,$DE,$8B     .BYTE     $22,$24,$26,$28,$30,$DD,$93,$8C     .BYTE     $FF; KEYBOARD DECODE TABLE - COMMODOREXXECE0 = *     .BYTE     $21,$+"23,$25,$27,$29,$A6,$A8,$94     .BYTE     $5F,$B3,$B2,$B7,$A2,$AF,$DF,$8D     .BYTE     $04,$B0,$AC,$A5,$B5,$B6,$5D,$9D     .BYTE     $83,$01,$BD,$BE,$AA,$3C,$3F,$91     .BYTE     $A0,$AD,$BC,$BF,$A7,$3E,$01,$89     .BYTE     $02,$AE,$BB,$B4,$A1,$5B,+#$3D,$8A     .BYTE     $AB,$B1,$A3,$B8,$B9,$A4,$DE,$8B     .BYTE     $22,$24,$26,$28,$30,$DC,$93,$8C     .BYTE     $FF;***********************************************************************************;;;## GRAPHICS/TEXT CONTROLXXED21 = *     +$CMP     #$0E               ; COMPARE WITH [SWITCH TO LOWER CASE]     BNE     XXED30          ; BRANCH IF NOT [SWITCH TO LOWER CASE]     LDA     #$02               ; SET FOR $8800, LOWER CASE CHARACTERS     ORA     XX9005          ; OR WITH START OF C+%HARACTER MEMORY, ROM     STA     XX9005          ; SAVE START OF CHARACTER MEMORY, ROM     JMP     XXE6DC          ; RESTORE REGISTERS, SET QUOTE FLAG AND EXITXXED30 = *     CMP     #$8E               ; COMPARE WITH [SWITCH TO UPPER CASE]     BNE  +&   XXED3F          ; BRANCH IF NOT [SWITCH TO UPPER CASE]     LDA     #$FD               ; SET FOR $8000, UPPER CASE CHARACTERS     AND     XX9005          ; AND WITH START OF CHARACTER MEMORY, ROM     STA     XX9005          ; SAVE START OF CHARACTE+'R MEMORY, ROMXXED3C = *     JMP     XXE6DC          ; RESTORE REGISTERS, SET QUOTE FLAG AND EXITXXED3F = *     CMP     #$08               ; COMPARE WITH DISABLE [SHIFT][C=]     BNE     XXED4D          ; BRANCH IF NOT DISABLE [SHIFT][C=]     LDA ,     #$80               ; SET TO LOCK SHIFT MODE SWITCH     ORA     XX0291          ; OR WITH SHIFT MODE SWITCH, $00 = ENABLED, $80 = LOCKED     STA     XX0291          ; SAVE SHIFT MODE SWITCH     BMI     XXED3C          ; BRANCH ALWAYSXXED4D = *  ,   CMP     #$09               ; COMPARE WITH ENABLE [SHIFT][C=]     BNE     XXED3C          ; EXIT IF NOT ENABLE [SHIFT][C=]     LDA     #$7F               ; SET TO UNLOCK SHIFT MODE SWITCH     AND     XX0291          ; AND WITH SHIFT MODE SWITCH, $0,0 = ENABLED, $80 = LOCKED     STA     XX0291          ; SAVE SHIFT MODE SWITCH     BPL     XXED3C          ; BRANCH ALWAYS; MAKE NEXT SCREEN LINE START OF LOGICAL LINE, INCREMENT LINE LENGTH AND SET POINTERSXXED5B = *     INX                    ; ,INCREMENT SCREEN ROW     LDA     XXD9,X          ; GET START OF LINE X POINTER HIGH BYTE     ORA     #$80               ; MARK AS START OF LOGICAL LINE     STA     XXD9,X          ; SET START OF LINE X POINTER HIGH BYTE     DEX                    ; R,ESTORE SCREEN ROW     LDA     XXD5          ; GET CURRENT SCREEN LINE LENGTH     CLC                    ; CLEAR CARRY FOR ADD     JMP     XXE715          ; ADD ONE LINE LENGTH, SET POINTERS FOR START OF LINE AND                         ; RETURN;**,*********************************************************************************;;; KEYBOARD DECODE TABLE - SHIFTEDXXED69 = *     .BYTE     $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF     .BYTE     $FF,$04,$FF,$FF,$FF,$FF,$FF,$E2     .BYTE     $9D,$83,$01,$F,F,$FF,$FF,$FF,$FF     .BYTE     $91,$A0,$FF,$FF,$FF,$FF,$EE,$01     .BYTE     $89,$02,$FF,$FF,$FF,$FF,$E1,$FD     .BYTE     $8A,$FF,$FF,$FF,$FF,$FF,$B0,$E0     .BYTE     $8B,$F2,$F4,$F6,$FF,$F0,$ED,$93     .BYTE     $8C,$FF; KEYBOARD DECODE TABLE ,- CONTROLXXEDA3 = *     .BYTE     $90,$1C,$9C,$1F,$12,$FF,$FF,$FF     .BYTE     $06,$FF,$12,$FF,$FF,$FF,$FF,$FF     .BYTE     $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF     .BYTE     $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF     .BYTE     $FF,$FF,$FF,$FF,$FF,$FF,$FF,$,FF     .BYTE     $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF     .BYTE     $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF     .BYTE     $05,$9F,$1E,$9E,$92,$FF,$FF,$FF     .BYTE     $FF;***********************************************************************************;;;,	 INITIAL VALUES FOR VIC REGISTERSXXEDE4 = *     .BYTE     $0C               ; INTERLACE AND HORIZONTAL CENTER [PAL];     .BYTE     $05               ; INTERLACE AND HORIZONTAL CENTER [NTSC]                         ; BIT     FUNCTION                ,
         ; ---     --------                         ;  7     INTERLACE / NON INTERLACE                         ; 6-0     HORIZONTAL ORIGIN     .BYTE     $26               ; VERTICAL ORIGIN [PAL];     .BYTE     $19               ; VERTICAL ORIGIN [NTS,C]     .BYTE     $16               ; VIDEO ADDRESS AND COLUMS, $9400 FOR COLOUR RAM                         ; BIT     FUNCTION                         ; ---     --------                         ;  7     VIDEO ADDRESS VA9                         ; 6-,0     NUMBER OF COLUMNS     .BYTE     $2E               ; ROWS AND CHARACTER SIZE                         ; BIT     FUNCTION                         ; ---     --------                         ;  7     B9 RASTER LINE                         ; 6-1    , NUMBER OF ROWS                         ;  0     8X16 / 8X8 CHARACTERS     .BYTE     $00               ; RASTER LINE     .BYTE     $C0               ; VIDEO MEMORY ADDRESSES, RAM $1000, ROM $8000                         ; BIT     FUNCTION           ,              ; ---     --------                         ;  7     MUST BE 1                         ; 6-4     VIDEO MEMORY ADDRESS VA12-VA10                         ; 3-0     CHARACTER MEMORY START ADDRESS                         ; 0000 ROM     $800,0     SET 1 - WE USE THIS                         ; 0001  '     $8400                         ; 0010  '     $8800 SET 2                         ; 0011  '     $8C00                         ; 1100 RAM     $1000                         ; 1101  '     $1,400                         ; 1110  '     $1800                         ; 1111  '     $1C00     .BYTE     $00               ; LIGHT PEN HORIZONTAL POSITION     .BYTE     $00               ; LIGHT PEN VERTICAL POSITION     .BYTE     $00            ,   ; PADDLE X     .BYTE     $00               ; PADDLE Y     .BYTE     $00               ; OSCILLATOR 1 FREQUENCY     .BYTE     $00               ; OSCILLATOR 2 FREQUENCY     .BYTE     $00               ; OSCILLATOR 3 FREQUENCY     .BYTE     $00    ,           ; NOISE SOURCE FREQUENCY     .BYTE     $00               ; AUX COLOUR AND VOLUME                         ; BIT     FUNCTION                         ; ---     --------                         ; 7-4     AUXILIARY COLOUR INFORMATION         ,                ; 3-0     VOLUME     .BYTE     $1B               ; SCREEN AND BORDER COLOUR                         ; BIT     FUNCTION                         ; ---     --------                         ; 7-4     BACKGROUND COLOUR                    ,     ;  3     INVERTED OR NORMAL MODE                         ; 2-0     BORDER COLOUR;***********************************************************************************;;; KEYBOARD BUFFER FOR AUTO LOAD/RUNXXEDF4 = *     .BYTE     'LOAD',$0D,'RU,N',$0D;***********************************************************************************;;; LOW BYTE SCREEN LINE ADDRESSESXXEDFD = *     .BYTE     $00,$16,$2C,$42     .BYTE     $58,$6E,$84,$9A     .BYTE     $B0,$C6,$DC,$F2     .BYTE     $08,,$1E,$34,$4A     .BYTE     $60,$76,$8C,$A2     .BYTE     $B8,$CE,$E4;***********************************************************************************;;; COMMAND A SERIAL BUS DEVICE TO TALK; TO USE THIS ROUTINE THE ACCUMULATOR MUST FIRST BE LOA,DED WITH A DEVICE NUMBER; BETWEEN 4 AND 30. WHEN CALLED THIS ROUTINE CONVERTS THIS DEVICE NUMBER TO A TALK; ADDRESS. THEN THIS DATA IS TRANSMITTED AS A COMMAND ON THE SERIAL BUS.XXEE14 = *     ORA     #$40               ; OR WITH THE TALK COMMAND  ,   .BYTE     $2C               ; MAKES NEXT LINE BIT XX2009;***********************************************************************************;;; COMMAND DEVICES ON THE SERIAL BUS TO LISTEN; THIS ROUTINE WILL COMMAND A DEVICE ON THE SERIAL BUS TO, RECEIVE DATA. THE; ACCUMULATOR MUST BE LOADED WITH A DEVICE NUMBER BETWEEN 4 AND 31 BEFORE CALLING; THIS ROUTINE. LISTEN CONVERT THIS TO A LISTEN ADDRESS THEN TRANSMIT THIS DATA AS; A COMMAND ON THE SERIAL BUS. THE SPECIFIED DEVICE WILL THEN GO INTO ,LISTEN MODE; AND BE READY TO ACCEPT INFORMATION.XXEE17 = *     ORA     #$20               ; OR WITH THE LISTEN COMMAND     JSR     XXF160          ; CHECK RS232 BUS IDLE;****************************************************************************,*******;;; SEND CONTROL CHARACTERXXEE1C = *     PHA                    ; SAVE DEVICE ADDRESS     BIT     XX94          ; TEST DEFERRED CHARACTER FLAG     BPL     XXEE2B          ; BRANCH IF NO DEFERED CHARACTER     SEC                    ; FLAG ,EOI     ROR     XXA3          ; ROTATE INTO EOI FLAG BYTE     JSR     XXEE49          ; TX BYTE ON SERIAL BUS     LSR     XX94          ; CLEAR DEFERRED CHARACTER FLAG     LSR     XXA3          ; CLEAR EOI FLAGXXEE2B = *     PLA                    ,; RESTORE DEVICE ADDRESS     STA     XX95          ; SAVE AS SERIAL DEFERED CHARACTER     JSR     XXE4A0          ; SET SERIAL DATA OUT HIGH     CMP     #$3F               ; COMPARE READ BYTE WITH $3F     BNE     XXEE38          ; BRANCH IF NOT $3F, ,THIS BRANCH WILL ALWAYS BE TAKEN AS                         ; AFTER VIA 2'S PCR IS READ IT IS ANDED WITH $DF, SO THE                         ; RESULT CAN NEVER BE $3F     JSR     XXEF84          ; SET SERIAL CLOCK HIGHXXEE38 = *     LDA     XX911F ,         ; GET VIA 1 DRA, NO HANDSHAKE     ORA     #$80               ; SET SERIAL ATN LOW     STA     XX911F          ; SET VIA 1 DRA, NO HANDSHAKE;***********************************************************************************;;; IF THE CODE,  DROPS THROUGH TO HERE THE SERIAL CLOCK IS LOW AND THE SERIAL DATA HAS BEEN; RELEASED SO THE FOLLOWING CODE WILL HAVE NO EFFECT APART FROM DELAYING THE FIRST BYTE; BY 1MS;## SET CLK/DATA, WAIT AND TX BYTE ON SERIAL BUSXXEE40 = *     JSR     XXEF8D,!          ; SET SERIAL CLOCK LOW     JSR     XXE4A0          ; SET SERIAL DATA OUT HIGH     JSR     XXEF96          ; 1MS DELAY;***********************************************************************************;;; TX BYTE ON SERIAL BUSXXEE49 = ,"*     SEI                    ; DISABLE INTERRUPTS     JSR     XXE4A0          ; SET SERIAL DATA OUT HIGH     JSR     XXE4B2          ; GET SERIAL CLOCK STATUS     LSR A                  ; SHIFT SERIAL DATA TO CB     BCS     XXEEB4          ; IF DATA,# HIGH DO DEVICE NOT PRESENT     JSR     XXEF84          ; SET SERIAL CLOCK HIGH     BIT     XXA3          ; TEST EOI FLAG     BPL     XXEE66          ; BRANCH IF NOT EOI; I THINK THIS IS THE EOI SEQUENCE SO THE SERIAL CLOCK HAS BEEN RELEASED AND TH,$E SERIAL; DATA IS BEING HELD LOW BY THE PERIPHERALS. FIRST UP WAIT FOR THE SERIAL DATA TO RISEXXEE5A = *     JSR     XXE4B2          ; GET SERIAL CLOCK STATUS     LSR A                  ; SHIFT SERIAL DATA TO CB     BCC     XXEE5A          ; LOOP I,%F DATA LOW; NOW THE DATA IS HIGH, EOI IS SIGNALLED BY WAITING FOR AT LEAST 200US WITHOUT PULLING; THE SERIAL CLOCK LINE LOW AGAIN. THE LISTENER SHOULD RESPOND BY PULLING THE SERIAL; DATA LINE LOWXXEE60 = *     JSR     XXE4B2          ; GET SERIAL ,&CLOCK STATUS     LSR A                  ; SHIFT SERIAL DATA TO CB     BCS     XXEE60          ; LOOP IF DATA HIGH; THE SERIAL DATA HAS GONE LOW ENDING THE EOI SEQUENCE, NOW JUST WAIT FOR THE SERIAL; DATA LINE TO GO HIGH AGAIN OR, IF THIS ISN'T AN EO,'I SEQUENCE, JUST WAIT FOR THE SERIAL; DATA TO GO HIGH THE FIRST TIMEXXEE66 = *     JSR     XXE4B2          ; GET SERIAL CLOCK STATUS     LSR A                  ; SHIFT SERIAL DATA TO CB     BCC     XXEE66          ; LOOP IF DATA LOW; SERIAL DATA - IS HIGH NOW PULL THE CLOCK LOW, PREFERABLY WITHIN 60US     JSR     XXEF8D          ; SET SERIAL CLOCK LOW; NOW THE VIC HAS TO SEND THE EIGHT BITS, LSB FIRST. FIRST IT SETS THE SERIAL DATA LINE; TO REFLECT THE BIT IN THE BYTE, THEN IT SETS THE SERIAL- CLOCK TO HIGH. THE SERIAL; CLOCK IS LEFT HIGH FOR 26 CYCLES, 23US ON A PAL VIC, BEFORE IT IS AGAIN PULLED LOW; AND THE SERIAL DATA IS ALLOWED HIGH AGAIN     LDA     #$08               ; EIGHT BITS TO DO     STA     XXA5          ; SET SERIAL BUS BI-T COUNTXXEE73 = *     LDA     XX911F          ; GET VIA 1 DRA, NO HANDSHAKE     CMP     XX911F          ; COMPARE WITH SELF     BNE     XXEE73          ; LOOP IF CHANGING     LSR A                  ; SERIAL CLOCK TO CARRY     LSR A                -  ; SERIAL DATA TO CARRY     BCC     XXEEB7          ; IF DATA LOW DO TIMEOUT ON SERIAL BUS     ROR     XX95          ; ROTATE TRANSMIT BYTE     BCS     XXEE88          ; BRANCH IF BIT = 1     JSR     XXE4A9          ; ELSE SET SERIAL DATA OUT LOW-     BNE     XXEE8B          ; BRANCH ALWAYSXXEE88 = *     JSR     XXE4A0          ; SET SERIAL DATA OUT HIGHXXEE8B = *     JSR     XXEF84          ; SET SERIAL CLOCK HIGH     NOP                    ; WASTE ..     NOP                    ; .. A ..-     NOP                    ; .. CYCLE ..     NOP                    ; .. OR TWO     LDA     XX912C          ; GET VIA 2 PCR     AND     #$DF               ; SET CB2 LOW, SERIAL DATA OUT HIGH     ORA     #$02               ; SET CA2 HIGH, SERIAL CLOC-K OUT LOW     STA     XX912C          ; SAVE VIA 2 PCR     DEC     XXA5          ; DECREMENT SERIAL BUS BIT COUNT     BNE     XXEE73          ; LOOP IF NOT ALL DONE; NOW ALL EIGHT BITS HAVE BEEN SENT IT'S UP TO THE PERIPHERAL TO SIGNAL THE BYTE WAS-; RECEIVED BY PULLING THE SERIAL DATA LOW. THIS SHOULD BE DONE WITHIN ONE MILISECOND     LDA     #$04               ; WAIT FOR UP TO ABOUT 1MS     STA     XX9129          ; SET VIA 2 T2C_HXXEEA5 = *     LDA     XX912D          ; GET VIA 2 IFR     A-ND     #$20               ; MASK T2 INTERRUPT     BNE     XXEEB7          ; IF T2 INTERRUPT DO TIMEOUT ON SERIAL BUS     JSR     XXE4B2          ; GET SERIAL CLOCK STATUS     LSR A                  ; SHIFT SERIAL DATA TO CB     BCS     XXEEA5       -	   ; IF DATA HIGH GO WAIT SOME MORE     CLI                    ; ENABLE INTERRUPTS     RTS;***********************************************************************************;;; DEVICE NOT PRESENTXXEEB4 = *     LDA     #$80               ; ERR-
OR $80, DEVICE NOT PRESENT     .BYTE     $2C               ; MAKES NEXT LINE BIT XX03A9;***********************************************************************************;;; TIMEOUT ON SERIAL BUSXXEEB7 = *     LDA     #$03               ; ERROR- $03, WRITE TIMEOUTXXEEB9 = *     JSR     XXFE6A          ; OR INTO SERIAL STATUS BYTE     CLI                    ; ENABLE INTERRUPTS     CLC                    ; CLEAR FOR BRANCH     BCC     XXEF09          ; ATN HIGH, DELAY, CLOCK HIGH THEN DATA H-IGH, BRANCH ALWAYS;***********************************************************************************;;; SEND SECONDARY ADDRESS AFTER LISTEN; THIS ROUTINE IS USED TO SEND A SECONDARY ADDRESS TO AN I/O DEVICE AFTER A CALL TO; THE LISTEN ROUTINE I-S MADE AND THE DEVICE COMMANDED TO LISTEN. THE ROUTINE CANNOT; BE USED TO SEND A SECONDARY ADDRESS AFTER A CALL TO THE TALK ROUTINE.; A SECONDARY ADDRESS IS USUALLY USED TO GIVE SET-UP INFORMATION TO A DEVICE BEFORE; I/O OPERATIONS BEGIN.; WHEN A S-ECONDARY ADDRESS IS TO BE SENT TO A DEVICE ON THE SERIAL BUS THE ADDRESS; MUST FIRST BE ORED WITH $60.XXEEC0 = *     STA     XX95          ; SAVE DEFERED BYTE     JSR     XXEE40          ; SET CLK/DATA, WAIT AND TX BYTE ON SERIAL BUS; SET SERIAL A-TN HIGHXXEEC5 = *     LDA     XX911F          ; GET VIA 1 DRA, NO HANDSHAKE     AND     #$7F               ; SET SERIAL ATN HIGH     STA     XX911F          ; SET VIA 1 DRA, NO HANDSHAKE     RTS;**************************************************-*********************************;;; SEND SECONDARY ADDRESS AFTER TALK; THIS ROUTINE TRANSMITS A SECONDARY ADDRESS ON THE SERIAL BUS FOR A TALK DEVICE.; THIS ROUTINE MUST BE CALLED WITH A NUMBER BETWEEN 4 AND 31 IN THE ACCUMULATOR.; THE ROUTINE WIL-L SEND THIS NUMBER AS A SECONDARY ADDRESS COMMAND OVER THE SERIAL; BUS. THIS ROUTINE CAN ONLY BE CALLED AFTER A CALL TO THE TALK ROUTINE. IT WILL; NOT WORK AFTER A LISTEN.XXEECE = *     STA     XX95          ; SAVE THE SECONDARY ADDRESS BYTE TO TRAN-SMIT     JSR     XXEE40          ; SET CLK/DATA, WAIT AND TX BYTE ON SERIAL BUS;***********************************************************************************;;; WAIT FOR BUS END AFTER SENDXXEED3 = *     SEI                    ; DISABLE INT-ERRUPTS     JSR     XXE4A9          ; SET SERIAL DATA OUT LOW     JSR     XXEEC5          ; SET SERIAL ATN HIGH     JSR     XXEF84          ; SET SERIAL CLOCK HIGHXXEEDD = *     JSR     XXE4B2          ; GET SERIAL CLOCK STATUS     BCS     XXEEDD  -        ; BRANCH IF CLOCK HIGH     CLI                    ; ENABLE INTERRUPTS     RTS;***********************************************************************************;;; OUTPUT A BYTE TO THE SERIAL BUS; THIS ROUTINE IS USED TO SEND INFORMATI-ON TO DEVICES ON THE SERIAL BUS. A CALL TO; THIS ROUTINE WILL PUT A DATA BYTE ONTO THE SERIAL BUS USING FULL HANDSHAKING.; BEFORE THIS ROUTINE IS CALLED THE LISTEN ROUTINE, XXFFB1, MUST BE USED TO; COMMAND A DEVICE ON THE SERIAL BUS TO GET READY TO RE-CEIVE DATA.; THE ACCUMULATOR IS LOADED WITH A BYTE TO OUTPUT AS DATA ON THE SERIAL BUS. A; DEVICE MUST BE LISTENING OR THE STATUS WORD WILL RETURN A TIMEOUT. THIS ROUTINE; ALWAYS BUFFERS ONE CHARACTER. SO WHEN A CALL TO THE UNLISTEN ROUTINE, XXFFAE,-; IS MADE TO END THE DATA TRANSMISSION, THE BUFFERED CHARACTER IS SENT WITH EOI; SET. THEN THE UNLISTEN COMMAND IS SENT TO THE DEVICE.XXEEE4 = *     BIT     XX94          ; TEST DEFERRED CHARACTER FLAG     BMI     XXEEED          ; BRANCH IF DEFERED- CHARACTER     SEC                    ; SET CARRY     ROR     XX94          ; SHIFT INTO DEFERRED CHARACTER FLAG     BNE     XXEEF2          ; SAVE BYTE AND EXIT, BRANCH ALWAYSXXEEED = *     PHA                    ; SAVE BYTE     JSR     XXEE49  -        ; TX BYTE ON SERIAL BUS     PLA                    ; RESTORE BYTEXXEEF2 = *     STA     XX95          ; SAVE DEFERED BYTE     CLC                    ; FLAG OK     RTS;***********************************************************************-************;;; COMMAND THE SERIAL BUS TO UNTALK; THIS ROUTINE WILL TRANSMIT AN UNTALK COMMAND ON THE SERIAL BUS. ALL DEVICES; PREVIOUSLY SET TO TALK WILL STOP SENDING DATA WHEN THIS COMMAND IS RECEIVED.XXEEF6 = *     JSR     XXEF8D          ; SE-T SERIAL CLOCK LOW     LDA     XX911F          ; GET VIA 1 DRA, NO HANDSHAKE     ORA     #$80               ; SET SERIAL ATN LOW     STA     XX911F          ; SET VIA 1 DRA, NO HANDSHAKE     LDA     #$5F               ; SET THE UNTALK COMMAND     .-BYTE     $2C               ; MAKES NEXT LINE BIT XX3FA9;***********************************************************************************;;; COMMAND THE SERIAL BUS TO UNLISTEN; THIS ROUTINE COMMANDS ALL DEVICES ON THE SERIAL BUS TO STOP RECEIVIN-G DATA FROM; THE COMPUTER. CALLING THIS ROUTINE RESULTS IN AN UNLISTEN COMMAND BEING TRANSMITTED; ON THE SERIAL BUS. ONLY DEVICES PREVIOUSLY COMMANDED TO LISTEN WILL BE AFFECTED.; THIS ROUTINE IS NORMALLY USED AFTER THE COMPUTER IS FINISHED SENDING D-ATA TO; EXTERNAL DEVICES. SENDING THE UNLISTEN WILL COMMAND THE LISTENING DEVICES TO GET; OFF THE SERIAL BUS SO IT CAN BE USED FOR OTHER PURPOSES.XXEF04 = *     LDA     #$3F               ; SET THE UNLISTEN COMMAND     JSR     XXEE1C          ; SEN-D CONTROL CHARACTER; ATN HIGH, DELAY, CLOCK HIGH THEN DATA HIGHXXEF09 = *     JSR     XXEEC5          ; SET SERIAL ATN HIGH; 1MS DELAY, CLOCK HIGH THEN DATA HIGHXXEF0C = *     TXA                    ; SAVE DEVICE NUMBER     LDX     #$0B       -         ; SHORT DELAYXXEF0F = *     DEX                    ; DECREMENT COUNT     BNE     XXEF0F          ; LOOP IF NOT ALL DONE     TAX                    ; RESTORE DEVICE NUMBER     JSR     XXEF84          ; SET SERIAL CLOCK HIGH     JMP     XXE4-!A0          ; SET SERIAL DATA OUT HIGH AND RETURN;***********************************************************************************;;; INPUT A BYTE FROM THE SERIAL BUS; THIS ROUTINE READS A BYTE OF DATA FROM THE SERIAL BUS USING FULL HANDSHAKING-". THE; DATA IS RETURNED IN THE ACCUMULATOR. BEFORE USING THIS ROUTINE THE TALK ROUTINE,; XXFFB4, MUST HAVE BEEN CALLED FIRST TO COMMAND THE DEVICE ON THE SERIAL BUS TO; SEND DATA ON THE BUS. IF THE INPUT DEVICE NEEDS A SECONDARY COMMAND IT MUST BE SEN-#T; BY USING THE TKSA ROUTINE, XXFF96, BEFORE CALLING THIS ROUTINE.; ERRORS ARE RETURNED IN THE STATUS WORD WHICH CAN BE READ BY CALLING THE READST; ROUTINE, XXFFB7.XXEF19 = *     SEI                    ; DISABLE INTERRUPTS     LDA     #$00       -$        ; CLEAR A     STA     XXA5          ; CLEAR SERIAL BUS BIT COUNT     JSR     XXEF84          ; SET SERIAL CLOCK HIGHXXEF21 = *     JSR     XXE4B2          ; GET SERIAL CLOCK STATUS     BCC     XXEF21          ; LOOP WHILE CLOCK LOW     JSR-%     XXE4A0          ; SET SERIAL DATA OUT HIGHXXEF29 = *     LDA     #$01               ; SET TIMEOUT COUNT HIGH BYTE     STA     XX9129          ; SET VIA 2 T2C_HXXEF2E = *     LDA     XX912D          ; GET VIA 2 IFR     AND     #$20             -&  ; MASK T2 INTERRUPT     BNE     XXEF3C          ; BRANCH IF T2 INTERRUPT     JSR     XXE4B2          ; GET SERIAL CLOCK STATUS     BCS     XXEF2E          ; LOOP IF CLOCK HIGH     BCC     XXEF54          ; ELSE GO SE 8 BITS TO DO, BRANCH ALWAYS-'                         ; T2 TIMED OUTXXEF3C = *     LDA     XXA5          ; GET SERIAL BUS BIT COUNT     BEQ     XXEF45          ; IF NOT ALREADY EOI THEN GO FLAG EOI     LDA     #$02               ; ERROR $02, READ TIMEOUR     JMP     XXEEB9    .       ; SET SERIAL STATUS AND EXITXXEF45 = *     JSR     XXE4A9          ; SET SERIAL DATA OUT LOW     JSR     XXEF0C          ; 1MS DELAY, CLOCK HIGH THEN DATA HIGH     LDA     #$40               ; SET EOI     JSR     XXFE6A          ; OR INTO SER.IAL STATUS BYTE     INC     XXA5          ; INCREMENT SERIAL BUS BIT COUNT, DO ERROR ON NEXT TIMEOUT     BNE     XXEF29          ; GO TRY AGAINXXEF54 = *     LDA     #$08               ; 8 BITS TO DO     STA     XXA5          ; SET SERIAL BUS BIT C.OUNTXXEF58 = *     LDA     XX911F          ; GET VIA 1 DRA, NO HANDSHAKE     CMP     XX911F          ; COMPARE WITH SELF     BNE     XXEF58          ; LOOP IF CHANGING     LSR A                  ; SERIAL CLOCK INTO CARRY     BCC     XXEF58        .  ; LOOP WHILE SERIAL CLOCK LOW     LSR A                  ; SERIAL DATA INTO CARRY     ROR     XXA4          ; SHIFT DATA BIT INTO RECEIVE BYTEXXEF66 = *     LDA     XX911F          ; GET VIA 1 DRA, NO HANDSHAKE     CMP     XX911F          ; COMPA.RE WITH SELF     BNE     XXEF66          ; LOOP IF CHANGING     LSR A                  ; SERIAL CLOCK INTO CARRY     BCS     XXEF66          ; LOOP WHILE SERIAL CLOCK HIGH     DEC     XXA5          ; DECREMENT SERIAL BUS BIT COUNT     BNE     XXEF.58          ; LOOP IF NOT ALL DONE     JSR     XXE4A9          ; SET SERIAL DATA OUT LOW     LDA     XX90          ; GET SERIAL STATUS BYTE     BEQ     XXEF7F          ; BRANCH IF NO ERROR     JSR     XXEF0C          ; 1MS DELAY, CLOCK HIGH THEN DA.TA HIGHXXEF7F = *     LDA     XXA4          ; GET RECEIVE BYTE     CLI                    ; ENABLE INTERRUPTS     CLC     RTS;***********************************************************************************;;; SET SERIAL CLOCK HIGHXXEF84 =. *     LDA     XX912C          ; GET VIA 2 PCR     AND     #$FD               ; SET CA2 LOW, SERIAL CLOCK OUT HIGH     STA     XX912C          ; SET VIA 2 PCR     RTS;********************************************************************************.***;;; SET SERIAL CLOCK LOWXXEF8D = *     LDA     XX912C          ; GET VIA 2 PCR     ORA     #$02               ; SET CA2 HIGH, SERIAL CLOCK OUT LOW     STA     XX912C          ; SET VIA 2 PCR     RTS;*****************************************.	******************************************;;; 1MS DELAYXXEF96 = *     LDA     #$04               ; SET FOR 1024 CYCLES     STA     XX9129          ; SET VIA 2 T2C_HXXEF9B = *     LDA     XX912D          ; GET VIA 2 IFR     AND     #$20          .
     ; MASK T2 INTERRUPT     BEQ     XXEF9B          ; LOOP UNTIL T2 INTERRUPT     RTS;***********************************************************************************;;; RS232 TX NMI ROUTINEXXEFA3 = *     LDA     XXB4          ; GET RS232 .BIT COUNT     BEQ     XXEFEE          ; IF ZERO GO SETUP NEXT RS232 TX BYTE AND RETURN     BMI     XXEFE8          ; IF -VE GO DO STOP BIT(S)                         ; ELSE BIT COUNT IS NON ZERO AND +VE     LSR     XXB6          ; SHIFT RS232 OUTPU.T BYTE BUFFER     LDX     #$00               ; SET $00 FOR BIT = 0     BCC     XXEFB0          ; BRANCH IF BIT WAS 0     DEX                    ; SET $FF FOR BIT = 1XXEFB0 = *     TXA                    ; COPY BIT TO A     EOR     XXBD          ; .EOR WITH RS232 PARITY BYTE     STA     XXBD          ; SAVE RS232 PARITY BYTE     DEC     XXB4          ; DECREMENT RS232 BIT COUNT     BEQ     XXEFBF          ; IF RS232 BIT COUNT NOW ZERO GO DO PARITY BIT; SAVE BIT AND EXITXXEFB9 = *     TXA   .                 ; COPY BIT TO A     AND     #$20               ; MASK FOR CB2 CONTROL BIT     STA     XXB5          ; SAVE RS232 NEXT BIT TO SEND     RTS; DO RS232 PARITY BIT, ENTERS WITH RS232 BIT COUNT = 0XXEFBF = *     LDA     #$20           .    ; MASK 00X0 0000, PARITY ENABLE BIT     BIT     XX0294          ; TEST PSEUDO 6551 COMMAND REGISTER     BEQ     XXEFDA          ; BRANCH IF PARITY DISABLED     BMI     XXEFE4          ; BRANCH IF FIXED MARK OR SPACE PARITY     BVS     XXEFDE   .       ; BRANCH IF EVEN PARITY                         ; ELSE ODD PARITY     LDA     XXBD          ; GET RS232 PARITY BYTE     BNE     XXEFCF          ; IF PARITY NOT ZERO LEAVE PARITY BIT = 0XXEFCE = *     DEX                    ; MAKE PARITY BIT. = 1XXEFCF = *     DEC     XXB4          ; DECREMENT RS232 BIT COUNT, 1 STOP BIT     LDA     XX0293          ; GET PSEUDO 6551 CONTROL REGISTER     BPL     XXEFB9          ; IF 1 STOP BIT SAVE PARITY BIT AND EXIT                         ; ELSE TWO .STOP BITS ..     DEC     XXB4          ; DECREMENT RS232 BIT COUNT, 2 STOP BITS     BNE     XXEFB9          ; SAVE BIT AND EXIT, BRANCH ALWAYS                         ; PARITY IS DISABLED SO THE PARITY BIT BECOMES THE FIRST,                         .; AND POSSIBLY ONLY, STOP BIT. TO DO THIS INCREMENT THE BIT                         ; COUNT WHICH EFFECTIVELY DECREMENTS THE STOP BIT COUNT.XXEFDA = *     INC     XXB4          ; INCREMENT RS232 BIT COUNT, = -1 STOP BIT     BNE     XXEFCE          ; .SET STOP BIT = 1 AND EXIT                         ; DO EVEN PARITYXXEFDE = *     LDA     XXBD          ; GET RS232 PARITY BYTE     BEQ     XXEFCF          ; IF PARITY ZERO LEAVE PARITY BIT = 0     BNE     XXEFCE          ; ELSE MAKE PARITY BIT = 1., BRANCH ALWAYS                         ; FIXED MARK OR SPACE PARITYXXEFE4 = *     BVS     XXEFCF          ; IF FIXED SPACE PARITY LEAVE PARITY BIT = 0     BVC     XXEFCE          ; ELSE FIXED MARK PARITY MAKE PARITY BIT = 1, BRANCH ALWAYS; DECRE.MENT STOP BIT COUNT, SET STOP BIT = 1 AND EXIT. $FF IS ONE STOP BIT, $FE IS TWO; STOP BITSXXEFE8 = *     INC     XXB4          ; DECREMENT RS232 BIT COUNT     LDX     #$FF               ; SET STOP BIT = 1     BNE     XXEFB9          ; SAVE STOP BIT. AND EXIT, BRANCH ALWAYS; SETUP NEXT RS232 TX BYTEXXEFEE = *     LDA     XX0294          ; GET 6551 PSEUDO COMMAND REGISTER     LSR A                  ; HANDSHAKE BIT INOT CB     BCC     XXEFFB          ; BRANCH IF 3 LINE INTERFACE     BIT     X.X9120          ; TEST VIA 2 DRB, THIS IS WRONG, THE ADRESS SHOULD BE                         ; XX9110 WHICH IS VIA 1 WHICH IS WHERE THE DSR AND                         ; CTS INPUTS REALLY ARE ##     BPL     XXF016          ; IF DSR = 0 SET DSR SIGNAL. NOT PRESENT AND EXIT     BVC     XXF019          ; IF CTS = 0 SET CTS SIGNAL NOT PRESENT AND EXIT                         ; WAS 3 LINE INTERFACEXXEFFB = *     LDA     #$00               ; CLEAR A     STA     XXBD          ; CLEAR RS232 PARITY BYT.E     STA     XXB5          ; CLEAR RS232 NEXT BIT TO SEND     LDX     XX0298          ; GET NUMBER OF BITS TO BE SENT/RECEIVED     STX     XXB4          ; SET RS232 BIT COUNT     LDY     XX029D          ; GET INDEX TO TX BUFFER START     CPY     XX.029E          ; COMPARE WITH INDEX TO TX BUFFER END     BEQ     XXF021          ; IF ALL DONE GO DISABLE T1 INTERRUPT AND RETURN     LDA     (XXF9),Y          ; ELSE GET BYTE FROM BUFFER     STA     XXB6          ; SAVE TO RS232 OUTPUT BYTE BUFFER  .   INC     XX029D          ; INCREMENT INDEX TO TX BUFFER START     RTS;***********************************************************************************;;;## EXIT OR QUIT; SET DSR SIGNAL NOT PRESENTXXF016 = *     LDA     #$40               ;. SET DSR SIGNAL NOT PRESENT     .BYTE     $2C               ; MAKES NEXT LINE BIT XX10A9; SET CTS SIGNAL NOT PRESENTXXF019 = *     LDA     #$10               ; SET CTS SIGNAL NOT PRESENT     ORA     XX0297          ; OR WITH RS232 STATUS REGISTER.     STA     XX0297          ; SAVE RS232 STATUS REGISTER; DISABLE T1 INTERRUPTXXF021 = *     LDA     #$40               ; DISABLE T1 INTERRUPT     STA     XX911E          ; SET VIA 1 IER     RTS;************************************************.***********************************;;; COMPUTE BIT COUNTXXF027 = *     LDX     #$09               ; SET BIT COUNT TO 9, 8 DATA + 1 STOP BIT     LDA     #$20               ; MASK FOR 8/7 DATA BITS     BIT     XX0293          ; TEST PSEUDO 6551 CONT. ROL REGISTER     BEQ     XXF031          ; BRANCH IF 8 BITS     DEX                    ; ELSE DECREMENT COUNT FOR 7 DATA BITSXXF031 = *     BVC     XXF035          ; BRANCH IF 7 BITS     DEX                    ; ELSE DECREMENT COUNT ..     DEX   .!                 ; .. FOR 5 DATA BITSXXF035 = *     RTS;***********************************************************************************;;; RS232 RX NMIXXF036 = *     LDX     XXA9          ; GET START BIT CHECK FLAG     BNE     XXF068      ."    ; BRANCH IF NO START BIT RECEIVED     DEC     XXA8          ; DECREMENT RECEIVER BIT COUNT IN     BEQ     XXF06F          ;.     BMI     XXF04D          ;.     LDA     XXA7          ; GET RECEIVER INPUT BIT TEMPORARY STORAGE     EOR     XXAB .#         ;.     STA     XXAB          ;.     LSR     XXA7          ; SHIFT RECEIVER INPUT BIT TEMPORARY STORAGE     ROR     XXAA          ;.XXF04A = *     RTSXXF04B = *     DEC     XXA8          ; DECREMENT RECEIVER BIT COUNT INXXF04D = *     L.$DA     XXA7          ; GET RECEIVER INPUT BIT TEMPORARY STORAGE     BEQ     XXF0B3          ;.     LDA     XX0293          ; GET PSEUDO 6551 CONTROL REGISTER     ASL A                  ;.     LDA     #$01               ;.     ADC     XXA8          .%; ADD RECEIVER BIT COUNT IN     BNE     XXF04A          ;.;***********************************************************************************;;;## SETUP TO RXXXF05B = *     LDA     #$90               ; ENABLE CB1 INTERRUPT     STA     XX911E  .&        ; SET VIA 1 IER     STA     XXA9          ; SET START BIT CHECK FLAG, SET NO START BIT RECEIVED     LDA     #$20               ; DISABLE T2 INTERRUPT     STA     XX911E          ; SET VIA 1 IER     RTS;*************************************.'**********************************************;;; NO RS232 START BIT RECEIVEDXXF068 = *     LDA     XXA7          ; GET RECEIVER INPUT BIT TEMPORARY STORAGE     BNE     XXF05B          ;.     STA     XXA9          ; SET START BIT CHECK FLAG, SET / START BIT RECEIVED     RTS;***********************************************************************************;;; ??XXF06F = *     LDY     XX029B          ; GET INDEX TO RX BUFFER END     INY                    ; INCREMENT INDEX     CPY     XX/029C          ; COMPARE WITH INDEX TO RX BUFFER START     BEQ     XXF0A2          ; IF BUFFER FULL GO DO RX OVERRUN ERROR     STY     XX029B          ; SAVE INDEX TO RX BUFFER END     DEY                    ; DECREMENT INDEX     LDA     XXAA        /  ; GET ASSEMBLED BYTE     LDX     XX0298          ; GET BIT COUNTXXF081 = *     CPX     #$09               ; COMPARE WITH BYTE + STOP     BEQ     XXF089          ; BRANCH IF ALL NINE BITS RECEIVED     LSR A                  ; ELSE SHIFT BYTE     /INX                    ; INCREMENT BIT COUNT     BNE     XXF081          ; LOOP, BRANCH ALWAYSXXF089 = *     STA     (XXF7),Y          ; SAVE RECEIVED BYTE TO RX BUFFER     LDA     #$20               ; MASK 00X0 0000, PARITY ENABLE BIT     BIT     /XX0294          ; TEST PSEUDO 6551 COMMAND REGISTER     BEQ     XXF04B          ; BRANCH IF PARITY DISABLED     BMI     XXF04A          ; BRANCH IF MARK OR SPACE PARITY     LDA     XXA7          ; GET RECEIVER INPUT BIT TEMPORARY STORAGE     EOR   /  XXAB          ;.     BEQ     XXF09D          ;.     BVS     XXF04A          ;.     .BYTE     $2C               ; MAKES NEXT LINE BIT XXAB50XXF09D = *     BVC     XXF04A          ;.     LDA     #$01               ; SET RX PARITY ERROR     .BYT/E     $2C               ; MAKES NEXT LINE BIT XX04A9XXF0A2 = *     LDA     #$04               ; SET RX OVERRUN ERROR     .BYTE     $2C               ; MAKES NEXT LINE BIT XX80A9XXF0A5 = *     LDA     #$80               ; RX BREAK ERROR     .BYTE /    $2C               ; MAKES NEXT LINE BIT XX02A9XXF0A8 = *     LDA     #$02               ; RX FRAME ERROR     ORA     XX0297          ; OR WITH RS232 STATUS BYTE     STA     XX0297          ; SAVE RS232 STATUS BYTE     JMP     XXF05B          ;./XXF0B3 = *     LDA     XXAA          ;.     BNE     XXF0A8          ; IF ?? DO FRAME ERROR     BEQ     XXF0A5          ; ELSE DO BREAK ERROR, BRANCH ALWAYS;***********************************************************************************;;; /	DO ILLEGAL DEVICE NUMBERXXF0B9 = *     JMP     XXF796          ; DO ILLEGAL DEVICE NUMBER AND RETURN;***********************************************************************************;;; OPEN RS232 CHANNEL FOR OUTPUTXXF0BC = *     STA     XX9/
A          ; SAVE OUTPUT DEVICE NUMBER     LDA     XX0294          ; GET PSEUDO 6551 COMMAND REGISTER     LSR A                  ; SHIFT HANDSHAKE BIT TO CARRY     BCC     XXF0EB          ; BRANCH IF 3 LINE INTERFACE     LDA     #$02               ;/ MASK FOR RTS OUT     BIT     XX9110          ; TEST VIA 1 DRB     BPL     XXF0E8          ; IF DSR = 0 SET DSR NOT PRESENT AND EXIT     BNE     XXF0EB          ; IF RTS = 1 JUST EXITXXF0CD = *     LDA     XX911E          ; GET VIA 1 IER     AND /    #$30               ; MASK 00XX 0000, T2 AND CB1 INTERRUPTS     BNE     XXF0CD          ; LOOP WHILE EITHER ENABLEDXXF0D4 = *     BIT     XX9110          ; TEST VIA 1 DRB     BVS     XXF0D4          ; LOOP WHILE CTS HIGH     LDA     XX9110     /     ; GET VIA 1 DRB     ORA     #$02               ; SET RTS HIGH     STA     XX9110          ; SAVE VIA 1 DRBXXF0E1 = *     BIT     XX9110          ; TEST VIA 1 DRB     BVS     XXF0EB          ; EXIT IF CTS HIGH     BMI     XXF0E1          ; LOO/P WHILE DSR HIGHXXF0E8 = *     JSR     XXF016          ; SET DSR SIGNAL NOT PRESENTXXF0EB = *     CLC                    ; FLAG OK     RTS;***********************************************************************************;;; SEND BYTE TO RS23/2 BUFFERXXF0ED = *     LDY     XX029E          ; GET INDEX TO TX BUFFER END     INY                    ; + 1     CPY     XX029D          ; COMPARE WITH INDEX TO TX BUFFER START     BEQ     XXF0ED          ; LOOP WHILE BUFFER FULL     STY     XX02/9E          ; SET INDEX TO TX BUFFER END     DEY                    ; INDEX TO AVAILABLE BUFFER BYTE     STA     (XXF9),Y          ; SAVE BYTE TO BUFFER     BIT     XX911E          ; TEST VIA 1 IER     BVC     XXF102          ; BRANCH IF T1 NOT ENABL/ED     RTSXXF102 = *     LDA     XX0299          ; GET BAUD RATE BIT TIME LOW BYTE     STA     XX9114          ; SET VIA 1 T1C_L     LDA     XX029A          ; GET BAUD RATE BIT TIME HIGH BYTE     STA     XX9115          ; SET VIA 1 T1C_H     LDA/     #$C0               ; ENABLE T1 INTERRUPT     STA     XX911E          ; SET VIA 1 IER     JMP     XXEFEE          ; SETUP NEXT RS232 TX BYTE AND RETURN;***********************************************************************************;;; INPU/T FROM RS232 BUFFERXXF116 = *     STA     XX99          ; SAVE INPUT DEVICE NUMBER     LDA     XX0294          ; GET PSEUDO 6551 COMMAND REGISTER     LSR A                  ;.     BCC     XXF146          ; BRANCH IF 3 LINE INTERFACE     AND     #/$08               ; MASK DUPLEX BIT, PSEUDO 6551 COMMAND IS >> 1     BEQ     XXF146          ; BRANCH IF FULL DUPLEX     LDA     #$02               ;.     BIT     XX9110          ; TEST VIA 1 DRB     BPL     XXF0E8          ;.     BEQ     XXF144  /        ;.XXF12B = *     BIT     XX911E          ; TEST VIA 1 IER     BVS     XXF12B          ; LOOP WHILE T1 INTERRUPT ENABLED     LDA     XX9110          ; GET VIA 1 DRB     AND     #$FD               ; MASK XXXX XX0X, CLEAR RTS OUT     STA    / XX9110          ; SAVE VIA 1 DRBXXF138 = *     LDA     XX9110          ; GET VIA 1 DRB     AND     #$04               ; MASK XXXX X1XX, DTR     BEQ     XXF138          ; LOOP WHILE DTR LOWXXF13F = *     LDA     #$90               ; ENABLE CB1 INT/ERRUPT     STA     XX911E          ; SET VIA 1 IERXXF144 = *     CLC                    ;.     RTSXXF146 = *     LDA     XX911E          ; GET VIA 1 IER     AND     #$30               ; MASK 0XX0 0000, T1 AND T2 INTERRUPTS     BEQ     XXF13F    /      ; IF BOTH INTERRUPTS DISABLED GO ENABLE CB1                         ; INTERRUPT AND EXIT     CLC                    ;.     RTS;***********************************************************************************;;; GET BYTE FROM RS232 BUFFE/RXXF14F = *     LDY     XX029C          ; GET INDEX TO RX BUFFER START     CPY     XX029B          ; COMPARE WITH INDEX TO RX BUFFER END     BEQ     XXF15D          ; RETURN NULL IF BUFFER EMPTY     LDA     (XXF7),Y          ; GET BYTE FROM RX BUF/FER     INC     XX029C          ; INCREMENT INDEX TO RX BUFFER START     RTSXXF15D = *     LDA     #$00               ; RETURN NULL     RTS;***********************************************************************************;;; CHECK RS232 BUS /IDLEXXF160 = *     PHA                    ; SAVE A     LDA     XX911E          ; GET VIA 1 IER     BEQ     XXF172          ; BRANCH IF NO INTERRUPTS ENABLED. THIS BRANCH WILL                         ; NEVER BE TAKEN AS B7 OF IER ALWAYS READS AS 1 /                        ; ACCORDING TO THE 6522 DATA SHEETXXF166 = *     LDA     XX911E          ; GET VIA 1 IER     AND     #$60               ; MASK 0XX0 0000, T1 AND T2 INTERRUPTS     BNE     XXF166          ; LOOP IF T1 OR T2 ACTIVE     LDA    / #$10               ; DISABLE CB1 INTERRUPT     STA     XX911E          ; SET VIA 1 IERXXF172 = *     PLA                    ; RESTORE A     RTS;***********************************************************************************;;; KERNEL I/O ME/SSAGESXXF174 = *     .BYTE     $0D,'I/O ERROR ',$A3             ;'#'+$80XXF180 = *     .BYTE     $0D,'SEARCHING',$A0              ;' '+$80XXF18B = *     .BYTE     'FOR',$A0                        ;' '+$80XXF18F = *     .BYTE     $0D,'PRESS PLAY /ON TAP',$C5      ;'E'+$80XXF1A2 = *     .BYTE     'PRESS RECORD & PLAY ON TAP',$C5 ;'E'+$80XXF1BD = *     .BYTE     $0D,'LOADIN',$C7                 ;'G'+$80XXF1C5 = *     .BYTE     $0D,'SAVING',$A0                 ;' '+$80XXF1CD = *     .BYTE   /   $0D,'VERIFYIN',$C7               ;'G'+$80XXF1D7 = *     .BYTE     $0D,'FOUND',$A0                  ;' '+$80XXF1DE = *     .BYTE     $0D,'OK',$0D+$80;***********************************************************************************;;; DISPLAY/! CONTROL I/O MESSAGE IF IN DIRECT MODEXXF1E2 = *     BIT     XX9D          ; TEST MESSAGE MODE FLAG     BPL     XXF1F3          ; EXIT IF CONTROL MESSAGES OFF; DISPLAY KERNEL I/O MESSAGEXXF1E6 = *     LDA     XXF174,Y          ; GET BYTE FROM ME/"SSAGE TABLE     PHP                    ; SAVE STATUS     AND     #$7F               ; CLEAR B7     JSR     XXFFD2          ; OUTPUT CHARACTER TO CHANNEL     INY                    ; INCREMENT INDEX     PLP                    ; RESTORE STATUS     BP/#L     XXF1E6          ; LOOP IF NOT END OF MESSAGEXXF1F3 = *     CLC                    ;.     RTS;***********************************************************************************;;; GET A CHARACTER FROM THE INPUT DEVICE; IN PRACTICE THIS R/$OUTINE OPERATES IDENTICALLY TO THE CHRIN ROUTINE, XXFFCF,; FOR ALL DEVICES EXCEPT FOR THE KEYBOARD. IF THE KEYBOARD IS THE CURRENT INPUT; DEVICE THIS ROUTINE WILL GET ONE CHARACTER FROM THE KEYBOARD BUFFER. IT DEPENDS; ON THE IRQ ROUTINE TO READ THE K/%EYBOARD AND PUT CHARACTERS INTO THE BUFFER.; IF THE KEYBOARD BUFFER IS EMPTY THE VALUE RETURNED IN THE ACCUMULATOR WILL BE ZEROXXF1F5 = *     LDA     XX99          ; GET INPUT DEVICE NUMBER     BNE     XXF201          ; BRANCH IF NOT KEYBOARD    /&                     ; INPUT DEVICE WAS KEYBOARD     LDA     XXC6          ; GET KEYBOARD BUFFER LENGTH     BEQ     XXF26A          ; IF BUFFER EMPTY GO FLAG NO BYTE AND RETURN     SEI                    ; DISABLE INTERRUPTS     JMP     XXE5CF      /'    ; INPUT FROM KEYBOARD BUFFER AND RETURN                         ; INPUT DEVICE WAS NOT KEYBOARDXXF201 = *     CMP     #$02               ; COMPARE DEVICE WITH RS232 DEVICE     BNE     XXF21D          ; BRANCH IF NOT RS232 DEVICE               0           ; INPUT DEVICE IS RS232 DEVICEXXF205 = *     STY     XX97          ; SAVE Y     JSR     XXF14F          ; GET BYTE FROM RS232 BUFFER     LDY     XX97          ; RESTORE Y     CLC                    ; FLAG NO ERROR     RTS;*************0**********************************************************************;;; INPUT CHARACTER FROM CHANNEL; THIS ROUTINE WILL GET A BYTE OF DATA FROM THE CHANNEL ALREADY SET UP AS THE INPUT; CHANNEL BY THE CHKIN ROUTINE, XXFFC6.; IF CHKIN, XXFFC6, HAS0 NOT BEEN USED TO DEFINE ANOTHER INPUT CHANNEL THE DATA IS; EXPECTED TO BE FROM THE KEYBOARD. THE DATA BYTE IS RETURNED IN THE ACCUMULATOR. THE; CHANNEL REMAINS OPEN AFTER THE CALL.; INPUT FROM THE KEYBOARD IS HANDLED IN A SPECIAL WAY. FIRST, THE CUR0SOR IS TURNED ON; AND IT WILL BLINK UNTIL A CARRIAGE RETURN IS TYPED ON THE KEYBOARD. ALL CHARACTERS; ON THE LOGICAL LINE, UP TO 88 CHARACTERS, WILL BE STORED IN THE BASIC INPUT BUFFER.; THEN THE CHARACTERS CAN BE RETURNED ONE AT A TIME BY CALLING THI0S ROUTINE ONCE FOR; EACH CHARACTER. WHEN THE CARRIAGE RETURN IS RETURNED THE ENTIRE LINE HAS BEEN; PROCESSED. THE NEXT TIME THIS ROUTINE IS CALLED THE WHOLE PROCESS BEGINS AGAIN.XXF20E = *     LDA     XX99          ; GET INPUT DEVICE NUMBER     BNE0     XXF21D          ; IF IT'S NOT THE KEYBOARD CONTINUE                         ; THE INPUT DEVICE IS THE KEYBOARD     LDA     XXD3          ; GET CURSOR COLUMN     STA     XXCA          ; SET INPUT CURSOR COLUMN     LDA     XXD6          ; GET CUR0SOR ROW     STA     XXC9          ; SET INPUT CURSOR ROW     JMP     XXE64F          ; GO GET INPUT FROM THE KEYBOARD; THE INPUT DEVICE WAS NOT THE KEYBOARDXXF21D = *     CMP     #$03               ; COMPARE DEVICE NUMBER WITH SCREEN     BNE     0XXF22A          ; IF IT'S NOT THE SCREEN CONTINUE                         ; THE INPUT DEVICE IS THE SCREEN     STA     XXD0          ; INPUT FROM KEYBOARD OR SCREEN, $XX = SCREEN,                         ; $00 = KEYBOARD     LDA     XXD5          ; 0GET CURRENT SCREEN LINE LENGTH     STA     XXC8          ; SAVE INPUT [EOL] POINTER     JMP     XXE64F          ; GO GET INPUT FROM THE SCREEN; THE INPUT DEVICE WAS NOT THE SCREENXXF22A = *     BCS     XXF264          ; IF INPUT DEVICE IS THE SERI0	AL BUS GO HANDLE IT; THE INPUT DEVICE IS < THE SCREEN DO MUST BE THE RS232 OR TAPE DEVICE     CMP     #$02               ; COMPARE DEVICE WITH RS232 DEVICE     BEQ     XXF26F          ; IF IT'S THE RS232 DEVICE GO HANDLE IT; ELSE THERE'S ONLY THE 0
TAPE DEVICE LEFT ..     STX     XX97          ; SAVE X     JSR     XXF250          ; GET BYTE FROM TAPE     BCS     XXF24D          ; EXIT IF ERROR     PHA                    ; SAVE BYTE     JSR     XXF250          ; GET NEXT BYTE FROM TAPE     B0CS     XXF24A          ; EXIT IF ERROR     BNE     XXF244          ; BRANCH IF END REACHED     LDA     #$40               ; SET [EOF] BIT     JSR     XXFE6A          ; OR INTO SERIAL STATUS BYTEXXF244 = *     DEC     XXA6          ; DECREMENT TAPE0 BUFFER INDEX     LDX     XX97          ; RESTORE X     PLA                    ; RESTORE SAVED BYTE     RTS; ERROR EXIT FROM INPUT CHARACTERXXF24A = *     TAX                    ; COPY ERROR BYTE ??     PLA                    ; DUMP SAVED BYTE 0    TXA                    ; RESTORE ERROR BYTE ??XXF24D = *     LDX     XX97          ; RESTORE X     RTS;***********************************************************************************;;; GET BYTE FROM TAPEXXF250 = *     JSR     XXF88A  0        ; BUMP TAPE POINTER     BNE     XXF260          ; IF NOT END GET NEXT BYTE AND EXIT     JSR     XXF8C0          ; INITIATE TAPE READ     BCS     XXF26B          ; EXIT IF ERROR FLAGGED     LDA     #$00               ; CLEAR A     STA     X0XA6          ; CLEAR TAPE BUFFER INDEX     BEQ     XXF250          ; LOOP, BRANCH ALWAYSXXF260 = *     LDA     (XXB2),Y          ; GET NEXT BYTE FROM BUFFER     CLC                    ; FLAG NO ERROR     RTS;*************************************0**********************************************;;; THE INPUT DEVICE WAS THE SERIAL BUSXXF264 = *     LDA     XX90          ; GET SERIAL STATUS BYTE     BEQ     XXF26C          ; IF NO ERRORS FLAGGED GO INPUT BYTE AND RETURN     LDA     #$0D       0        ; ELSE RETURN [EOL]XXF26A = *     CLC                    ; FLAG NO ERRORXXF26B = *     RTSXXF26C = *     JMP     XXEF19          ; INPUT A BYTE FROM THE SERIAL BUS AND RETURN                         ; INPUT DEVICE WAS RS232 DEVICEXXF26F0 = *     JSR     XXF205          ; GET BYTE FROM RS232 DEVICE     BCS     XXF279          ; BRANCH IF ERROR, THIS DOESN'T GET TAKEN AS THE LAST                         ; INSTRUCTION IN THE GET BYTE FROM RS232 DEVICE ROUTINE                         ; 0IS CLC     CMP     #$00               ; COMPARE WITH NULL     BEQ     XXF26F          ; LOOP IF NULL     CLC                    ; FLAG NO ERRORXXF279 = *     RTS;***********************************************************************************0;;; OUTPUT A CHARACTER TO CHANNEL; THIS ROUTINE WILL OUTPUT A CHARACTER TO AN ALREADY OPENED CHANNEL. USE THE OPEN; ROUTINE, XXFFC0, AND THE CHKOUT ROUTINE, XXFFC9, TO SET UP THE OUTPUT CHANNEL; BEFORE CALLING THIS ROUTINE. IF THESE CALLS ARE OMITT0ED, DATA WILL BE SENT TO THE; DEFAULT OUTPUT DEVICE, DEVICE 3, THE SCREEN. THE DATA BYTE TO BE OUTPUT IS LOADED; INTO THE ACCUMULATOR, AND THIS ROUTINE IS CALLED. THE DATA IS THEN SENT TO THE; SPECIFIED OUTPUT DEVICE. THE CHANNEL IS LEFT OPEN AFTER TH0E CALL.; NOTE: CARE MUST BE TAKEN WHEN USING ROUTINE TO SEND DATA TO A SERIAL DEVICE SINCE; DATA WILL BE SENT TO ALL OPEN OUTPUT CHANNELS ON THE BUS. UNLESS THIS IS DESIRED,; ALL OPEN OUTPUT CHANNELS ON THE SERIAL BUS OTHER THAN THE ACTUALLY INTENDED0; DESTINATION CHANNEL MUST BE CLOSED BY A CALL TO THE KERNAL CLOSE CHANNEL ROUTINE.XXF27A = *     PHA                    ; SAVE THE CHARACTER TO SEND     LDA     XX9A          ; GET OUTPUT DEVICE NUMBER     CMP     #$03               ; COMPARE DEVI0CE NUMBER WITH SCREEN     BNE     XXF285          ; IF OUTPUT DEVICE NOT SCREEN CONTINUE; THE OUTPUT DEVICE IS THE SCREEN     PLA                    ; RESTORE CHARACTER TO SEND     JMP     XXE742          ; OUTPUT CHARACTER AND RETURN; THE OUTPUT0 DEVICE WAS NOT THE SCREENXXF285 = *     BCC     XXF28B          ; IF OUTPUT DEVICE < SCREEN CONTINUE; THE OUTPUT DEVICE WAS > SCREEN SO IT IS A SERIAL BUS DEVICE     PLA                    ; RESTORE CHARACTER TO SEND     JMP     XXEEE4          0; OUTPUT A BYTE TO THE SERIAL BUS AND RETURN; THE OUTPUT DEVICE IS < SCREENXXF28B = *     CMP     #$02               ; COMPARE THE DEVICE WITH RS232 DEVICE     BEQ     XXF2B9          ; IF OUTPUT DEVICE IS RS232 DEVICE GO HANDLE IT; ELSE THE OUTP0UT DEVICE IS THE CASSETTE     PLA                    ; RESTORE THE CHARACTER TO SEND;***********************************************************************************;;; OUTPUT A CHARACTER TO THE CASSETTEXXF290 = *     STA     XX9E          ;0 SAVE CHARACTER TO CHARACTER BUFFER     PHA                    ; SAVE A     TXA                    ; COPY X     PHA                    ; SAVE X     TYA                    ; COPY Y     PHA                    ; SAVE Y     JSR     XXF88A          ; BU0MP TAPE POINTER     BNE     XXF2AA          ; IF NOT END SAVE NEXT BYTE AND EXIT     JSR     XXF8E3          ; INITIATE TAPE WRITE     BCS     XXF2AF          ; EXIT IF ERROR     LDA     #$02               ; SET DATA BLOCK TYPE ??     LDY     #$000               ; CLEAR INDEX     STA     (XXB2),Y          ; SAVE TYPE TO BUFFER ??     INY                    ; INCREMENT INDEX     STY     XXA6          ; SAVE TAPE BUFFER INDEXXXF2AA = *     LDA     XX9E          ; RESTORE CHARACTER FROM CHARACTE0R BUFFER     STA     (XXB2),Y          ; SAVE TO BUFFER     CLC                    ; FLAG NO ERRORXXF2AF = *     PLA                    ; PULL Y     TAY                    ; RESTORE Y     PLA                    ; PULL X     TAX                    0 ; RESTORE X     PLA                    ; RESTORE A     BCC     XXF2B8          ; EXIT IF NO ERROR     LDA     #$00               ; ELSE CLEAR AXXF2B8 = *     RTS;***********************************************************************************0!;;; THE OUTPUT DEVICE IS RS232 DEVICEXXF2B9 = *     PLA                    ; RESTORE CHARACTER TO SEND     STX     XX97          ; SAVE X     STY     XX9E          ; SAVE Y     JSR     XXF0ED          ; SEND BYTE TO RS232 BUFFER     LDX     XX970"          ; RESTORE Y     LDY     XX9E          ; RESTORE X     CLC                    ; FLAG OK     RTS;***********************************************************************************;;; OPEN A CHANNEL FOR INPUT; ANY LOGICAL FILE THAT HAS 0#ALREADY BEEN OPENED BY THE OPEN ROUTINE, XXFFC0, CAN BE; DEFINED AS AN INPUT CHANNEL BY THIS ROUTINE. THE DEVICE ON THE CHANNEL MUST BE AN; INPUT DEVICE OR AN ERROR WILL OCCUR AND THE ROUTINE WILL ABORT.; IF YOU ARE GETTING DATA FROM ANYWHERE OTHER T0$HAN THE KEYBOARD, THIS ROUTINE MUST BE; CALLED BEFORE USING EITHER THE CHRIN ROUTINE, XXFFCF, OR THE GETIN ROUTINE,; XXFFE4. IF YOU ARE GETTING DATA FROM THE KEYBOARD AND NO OTHER INPUT CHANNELS ARE; OPEN THEN THE CALLS TO THIS ROUTINE AND TO THE OPEN0% ROUTINE, XXFFC0, ARE NOT NEEDED.; WHEN USED WITH A DEVICE ON THE SERIAL BUS THIS ROUTINE WILL AUTOMATICALLY SEND THE; LISTEN ADDRESS SPECIFIED BY THE OPEN ROUTINE, XXFFC0, AND ANY SECONDARY ADDRESS.; POSSIBLE ERRORS ARE:;;     3 : FILE NOT OPEN;0&     5 : DEVICE NOT PRESENT;     6 : FILE IS NOT AN INPUT FILEXXF2C7 = *     JSR     XXF3CF          ; FIND FILE     BEQ     XXF2CF          ; BRANCH IF FILE OPENED     JMP     XXF784          ; DO FILE NOT OPEN ERROR AND RETURNXXF2CF = *     J0'SR     XXF3DF          ; SET FILE DETAILS FROM TABLE,X     LDA     XXBA          ; GET DEVICE NUMBER     BEQ     XXF2EC          ; IF DEVICE WAS KEYBOARD SAVE DEVICE #, FLAG OK AND EXIT     CMP     #$03               ; COMPARE DEVICE NUMBER WITH SCRE1 EN     BEQ     XXF2EC          ; IF DEVICE WAS SCREEN SAVE DEVICE #, FLAG OK AND EXIT     BCS     XXF2F0          ; BRANCH IF SERIAL BUS DEVICE     CMP     #$02               ; COMPARE DEVICE WITH RS232 DEVICE     BNE     XXF2E3          ; BRANCH I1F NOT RS 232 DEVICE     JMP     XXF116          ; ELSE GET INPUT FROM RS232 BUFFER AND RETURNXXF2E3 = *     LDX     XXB9          ; GET SECONDARY ADDRESS     CPX     #$60               ;.     BEQ     XXF2EC          ;.     JMP     XXF78D        1  ; DO NOT INPUT FILE ERROR AND RETURNXXF2EC = *     STA     XX99          ; SAVE INPUT DEVICE NUMBER     CLC                    ; FLAG OK     RTS                         ; DEVICE WAS SERIAL BUS DEVICEXXF2F0 = *     TAX                    ; COPY1 DEVICE NUMBER TO X     JSR     XXEE14          ; COMMAND A SERIAL BUS DEVICE TO TALK     LDA     XXB9          ; GET SECONDARY ADDRESS     BPL     XXF2FE          ;.     JSR     XXEED3          ; WAIT FOR BUS END AFTER SEND     JMP     XXF301     1     ;.XXF2FE = *     JSR     XXEECE          ; SEND SECONDARY ADDRESS AFTER TALKXXF301 = *     TXA                    ; COPY DEVICE BACK TO A     BIT     XX90          ; TEST SERIAL STATUS BYTE     BPL     XXF2EC          ; IF DEVICE PRESENT SAVE1 DEVICE NUMBER AND EXIT     JMP     XXF78A          ; DO DEVICE NOT PRESENT ERROR AND RETURN;***********************************************************************************;;; OPEN A CHANNEL FOR OUTPUT; ANY LOGICAL FILE THAT HAS ALREADY BEEN1 OPENED BY THE OPEN ROUTINE, XXFFC0, CAN BE; DEFINED AS AN OUTPUT CHANNEL BY THIS ROUTINE THE DEVICE ON THE CHANNEL MUST BE AN; OUTPUT DEVICE OR AN ERROR WILL OCCUR AND THE ROUTINE WILL ABORT.; IF YOU ARE SENDING DATA TO ANYWHERE OTHER THAN THE SCREE1N THIS ROUTINE MUST BE; CALLED BEFORE USING THE CHROUT ROUTINE, XXFFD2. IF YOU ARE SENDING DATA TO THE; SCREEN AND NO OTHER OUTPUT CHANNELS ARE OPEN THEN THE CALLS TO THIS ROUTINE AND TO; THE OPEN ROUTINE, XXFFC0, ARE NOT NEEDED.; WHEN USED WITH A D1EVICE ON THE SERIAL BUS THIS ROUTINE WILL AUTOMATICALLY SEND THE; LISTEN ADDRESS SPECIFIED BY THE OPEN ROUTINE, XXFFC0, AND ANY SECONDARY ADDRESS.; POSSIBLE ERRORS ARE:;;     3 : FILE NOT OPEN;     5 : DEVICE NOT PRESENT;     7 : FILE IS NOT AN OU1	TPUT FILEXXF309 = *     JSR     XXF3CF          ; FIND FILE     BEQ     XXF311          ; BRANCH IF FILE FOUND     JMP     XXF784          ; DO FILE NOT OPEN ERROR AND RETURNXXF311 = *     JSR     XXF3DF          ; SET FILE DETAILS FROM TABLE,X1
     LDA     XXBA          ; GET DEVICE NUMBER     BNE     XXF31B          ; BRANCH IF DEVICE IS NOT KEYBOARDXXF318 = *     JMP     XXF790          ; DO NOT OUTPUT FILE ERROR AND RETURNXXF31B = *     CMP     #$03               ; COMPARE DEVICE NUM1BER WITH SCREEN     BEQ     XXF32E          ; IF SCREEN SAVE OUTPUT DEVICE NUMBER AND EXIT     BCS     XXF332          ; BRANCH IF > SCREEN, SERIAL BUS DEVICE     CMP     #$02               ; COMPARE DEVICE WITH RS232 DEVICE     BNE     XXF328     1     ; BRANCH IF NOT RS232 DEVICE, MUST BE TAPE     JMP     XXF0BC          ; OPEN RS232 CHANNEL FOR OUTPUT                         ; OPEN TAPE CHANNEL FOR OUTPUTXXF328 = *     LDX     XXB9          ; GET SECONDARY ADDRESS     CPX     #$60        1       ;.     BEQ     XXF318          ; IF ?? DO NOT OUTPUT FILE ERROR AND RETURNXXF32E = *     STA     XX9A          ; SAVE OUTPUT DEVICE NUMBER     CLC                    ; FLAG OK     RTSXXF332 = *     TAX                    ; COPY DEVICE NUM1BER     JSR     XXEE17          ; COMMAND DEVICES ON THE SERIAL BUS TO LISTEN     LDA     XXB9          ; GET SECONDARY ADDRESS     BPL     XXF33F          ; BRANCH IF ADDRESS TO SEND     JSR     XXEEC5          ; ELSE SET SERIAL ATN HIGH     BNE  1   XXF342          ; BRANCH ALWAYSXXF33F = *     JSR     XXEEC0          ; SEND SECONDARY ADDRESS AFTER LISTENXXF342 = *     TXA                    ; COPY DEVICE NUMBER BACK TO A     BIT     XX90          ; TEST SERIAL STATUS BYTE     BPL     XXF312E          ; IF DEVICE PRESENT SAVE OUTPUT DEVICE NUMBER AND EXIT     JMP     XXF78A          ; ELSE DO DEVICE NOT PRESENT ERROR AND RETURN;***********************************************************************************;;; CLOSE A SPECIFIED L1OGICAL FILE; THIS ROUTINE IS USED TO CLOSE A LOGICAL FILE AFTER ALL I/O OPERATIONS HAVE BEEN; COMPLETED ON THAT FILE. THIS ROUTINE IS CALLED AFTER THE ACCUMULATOR IS LOADED; WITH THE LOGICAL FILE NUMBER TO BE CLOSED, THE SAME NUMBER USED WHEN THE FIL1E WAS; OPENED USING THE OPEN ROUTINE.XXF34A = *     JSR     XXF3D4          ; FIND FILE A     BEQ     XXF351          ; IF THE FILE IS FOUND GO CLOSE IT     CLC                    ; ELSE THR FILE WAS CLOSED SO JUST FLAG OK     RTS; FOUND THE FI1LE SO CLOSE ITXXF351 = *     JSR     XXF3DF          ; SET FILE DETAILS FROM TABLE,X     TXA                    ; COPY FILE INDEX TO A     PHA                    ; SAVE FILE INDEX     LDA     XXBA          ; GET DEVICE NUMBER     BEQ     XXF3B1   1       ; IF $00, KEYBOARD, RESTORE INDEX AND CLOSE FILE     CMP     #$03               ; COMPARE DEVICE NUMBER WITH SCREEN     BEQ     XXF3B1          ; IF SCREEN RESTORE INDEX AND CLOSE FILE     BCS     XXF3AE          ; IF > SCREEN GO DO SERIAL BU1S DEVICE CLOSE     CMP     #$02               ; COMPARE DEVICE WITH RS232 DEVICE     BNE     XXF38D          ; BRANCH IF NOT RS232 DEVICE                         ; ELSE CLOSE RS232 DEVICE     PLA                    ; RESTORE FILE INDEX     JSR    1 XXF3B2          ; CLOSE FILE INDEX X     LDA     #$7D               ; DISABLE T1, T2, CB1, CB2, SR AND CA2     STA     XX911E          ; SET VIA 1 IER     LDA     #$06               ; SET DTR AND RTS HIGH     STA     XX9110          ; SET VIA 1 DRB1     LDA     #$EE               ; CB2 HIGH, CB1 -VE EDGE, CA2 HIGH, CA1 -VE EDGE     STA     XX911C          ; SET VIA 1 PCR     JSR     XXFE75          ; READ THE TOP OF MEMORY     LDA     XXF8          ; GET RS232 INPUT BUFFER POINTER HIGH BYTE    1 BEQ     XXF37F          ; BRANCH IF NO RS232 INPUT BUFFER     INY                    ; ELSE RECLAIM RS232 INPUT BUFFER MEMORYXXF37F = *     LDA     XXFA          ; GET RS232 OUTPUT BUFFER POINTER HIGH BYTE     BEQ     XXF384          ; BRANCH IF NO1 RS232 OUTPUT BUFFER     INY                    ; ELSE RECLAIM RS232 OUTPUT BUFFER MEMORYXXF384 = *     LDA     #$00               ; CLEAR A     STA     XXF8          ; CLEAR RS232 INPUT BUFFER POINTER HIGH BYTE     STA     XXFA          ; CLEAR RS1232 OUTPUT BUFFER POINTER HIGH BYTE     JMP     XXF53C          ; GO SET TOP OF MEMORY AND EXITXXF38D = *     LDA     XXB9          ; GET SECONDARY ADDRESS     AND     #$0F               ;.     BEQ     XXF3B1          ; IF ?? RESTORE INDEX AND CLOS1E FILE     JSR     XXF84D          ; GET TAPE BUFFER START POINTER IN XY     LDA     #$00               ; CHARACTER $00     JSR     XXF290          ; OUTPUT CHARACTER TO CASSETTE     JMP     XXE4CF          ; GO DO CLOSE TAILXXF39E = *     BCS   1  XXF3CE          ; JUST EXIT IF ERROR     LDA     XXB9          ; GET SECONDARY ADDRESS     CMP     #$62               ;.     BNE     XXF3B1          ; IF NOT ?? RESTORE INDEX AND CLOSE FILE     LDA     #$05               ; SET LOGICAL END OF THE 1TAPE     JSR     XXF7E7          ; WRITE TAPE HEADER     JMP     XXF3B1          ; RESTORE INDEX AND CLOSE FILE;***********************************************************************************;;; DO SERIAL BUS DEVICE FILE CLOSEXXF3AE = *    1 JSR     XXF6DA          ; CLOSE SERIAL BUS DEVICEXXF3B1 = *     PLA                    ; RESTORE FILE INDEX;***********************************************************************************;;; CLOSE FILE INDEX XXXF3B2 = *     TAX            1        ; COPY INDEX TO FILE TO CLOSE     DEC     XX98          ; DECREMENT OPEN FILE COUNT     CPX     XX98          ; COMPARE INDEX WITH OPEN FILE COUNT     BEQ     XXF3CD          ; EXIT IF EQUAL, LAST ENTRY WAS CLOSING FILE                      1    ; ELSE ENTRY WAS NOT LAST IN LIST SO COPY LAST TABLE ENTRY                         ; FILE DETAILS OVER THE DETAILS OF THE CLOSING ONE     LDY     XX98          ; GET OPEN FILE COUNT AS INDEX     LDA     XX0259,Y          ; GET LAST+1 LOGICAL FILE N1!UMBER FROM LOGICAL FILE TABLE     STA     XX0259,X          ; SAVE LOGICAL FILE NUMBER OVER CLOSED FILE     LDA     XX0263,Y          ; GET LAST+1 DEVICE NUMBER FROM DEVICE NUMBER TABLE     STA     XX0263,X          ; SAVE DEVICE NUMBER OVER CLOSED FI1"LE     LDA     XX026D,Y          ; GET LAST+1 SECONDARY ADDRESS FROM SECONDARY ADDRESS TABLE     STA     XX026D,X          ; SAVE SECONDARY ADDRESS OVER CLOSED FILEXXF3CD = *     CLC                    ;.XXF3CE = *     RTS;**********************1#*************************************************************;;; FIND FILEXXF3CF = *     LDA     #$00               ; CLEAR A     STA     XX90          ; CLEAR SERIAL STATUS BYTE     TXA                    ; COPY LOGICAL FILE NUMBER TO A; FIND F1$ILE AXXF3D4 = *     LDX     XX98          ; GET OPEN FILE COUNTXXF3D6 = *     DEX                    ; DECREMEMNT COUNT TO GIVE INDEX     BMI     XXF3EE          ; EXIT IF NO FILES     CMP     XX0259,X          ; COMPARE LOGICAL FILE NUMBER WITH 1%TABLE LOGICAL FILE NUMBER     BNE     XXF3D6          ; LOOP IF NO MATCH     RTS;***********************************************************************************;;; SET FILE DETAILS FROM TABLE,XXXF3DF = *     LDA     XX0259,X          ; GET1& LOGICAL FILE FROM LOGICAL FILE TABLE     STA     XXB8          ; SET LOGICAL FILE     LDA     XX0263,X          ; GET DEVICE NUMBER FROM DEVICE NUMBER TABLE     STA     XXBA          ; SET DEVICE NUMBER     LDA     XX026D,X          ; GET SECONDARY 1'ADDRESS FROM SECONDARY ADDRESS TABLE     STA     XXB9          ; SET SECONDARY ADDRESSXXF3EE = *     RTS;***********************************************************************************;;; CLOSE ALL CHANNELS AND FILES; THIS ROUTINE CLOSES AL2 L OPEN FILES. WHEN THIS ROUTINE IS CALLED, THE POINTERS INTO; THE OPEN FILE TABLE ARE RESET, CLOSING ALL FILES. ALSO THE ROUTINE AUTOMATICALLY; RESETS THE I/O CHANNELS.XXF3EF = *     LDA     #$00               ; CLEAR A     STA     XX98          ; 2CLEAR OPEN FILE COUNT;***********************************************************************************;;; CLOSE INPUT AND OUTPUT CHANNELS; THIS ROUTINE IS CALLED TO CLEAR ALL OPEN CHANNELS AND RESTORE THE I/O CHANNELS TO; THEIR ORIGINAL DEFAUL2T VALUES. IT IS USUALLY CALLED AFTER OPENING OTHER I/O; CHANNELS AND USING THEM FOR INPUT/OUTPUT OPERATIONS. THE DEFAULT INPUT DEVICE IS; 0, THE KEYBOARD. THE DEFAULT OUTPUT DEVICE IS 3, THE SCREEN.; IF ONE OF THE CHANNELS TO BE CLOSED IS TO THE SERI2AL PORT, AN UNTALK SIGNAL IS SENT; FIRST TO CLEAR THE INPUT CHANNEL OR AN UNLISTEN IS SENT TO CLEAR THE OUTPUT CHANNEL.; BY NOT CALLING THIS ROUTINE AND LEAVING LISTENER(S) ACTIVE ON THE SERIAL BUS,; SEVERAL DEVICES CAN RECEIVE THE SAME DATA FROM THE 2VIC AT THE SAME TIME. ONE WAY TO; TAKE ADVANTAGE OF THIS WOULD BE TO COMMAND THE PRINTER TO TALK AND THE DISK TO; LISTEN. THIS WOULD ALLOW DIRECT PRINTING OF A DISK FILE.XXF3F3 = *     LDX     #$03               ; SET X TO SCREEN     CPX     XX9A  2        ; COMPARE OUTPUT DEVICE NUMBER WITH SCREEN     BCS     XXF3FC          ; BRANCH IF >= SCREEN                         ; ELSE WAS SERIAL BUS     JSR     XXEF04          ; COMMAND THE SERIAL BUS TO UNLISTENXXF3FC = *     CPX     XX99          2; COMPARE INPUT DEVICE NUMBER WITH SCREEN     BCS     XXF403          ; BRANCH IF >= SCREEN                         ; ELSE WAS SERIAL BUS     JSR     XXEEF6          ; COMMAND THE SERIAL BUS TO UNTALKXXF403 = *     STX     XX9A          ; SET OUTPU2T DEVICE NUMBER TO SCREEN     LDA     #$00               ; SET FOR KEYBOARD     STA     XX99          ; SET INPUT DEVICE NUMBER TO KEYBOARD     RTS;***********************************************************************************;;; OPEN A LOGI2CAL FILE; THIS ROUTINE IS USED TO OPEN A LOGICAL FILE. ONCE THE LOGICAL FILE IS SET UP IT; CAN BE USED FOR INPUT/OUTPUT OPERATIONS. MOST OF THE I/O KERNAL ROUTINES CALL ON; THIS ROUTINE TO CREATE THE LOGICAL FILES TO OPERATE ON. NO ARGUMENTS NEED TO 2	BE; SET UP TO USE THIS ROUTINE, BUT BOTH THE SETLFS, XXFFBA, AND SETNAM, XXFFBD,; KERNAL ROUTINES MUST BE CALLED BEFORE USING THIS ROUTINE.XXF40A = *     LDX     XXB8          ; GET LOGICAL FILE NUMBER     BNE     XXF411          ; BRANCH IF THERE 2
IS A FILE     JMP     XXF78D          ; ELSE DO NOT INPUT FILE ERROR AND RETURNXXF411 = *     JSR     XXF3CF          ; FIND FILE     BNE     XXF419          ; BRANCH IF FILE NOT FOUND     JMP     XXF781          ; ELSE DO FILE ALREADY OPEN ERROR2 AND RETURNXXF419 = *     LDX     XX98          ; GET OPEN FILE COUNT     CPX     #$0A               ; COMPARE WITH MAX     BCC     XXF422          ; BRANCH IF LESS     JMP     XXF77E          ; ELSE DO TOO MANY FILES ERROR AND RETURNXXF422 = *2     INC     XX98          ; INCREMENT OPEN FILE COUNT     LDA     XXB8          ; GET LOGICAL FILE NUMBER     STA     XX0259,X          ; SAVE TO LOGICAL FILE TABLE     LDA     XXB9          ; GET SECONDARY ADDRESS     ORA     #$60               ; O2R WITH THE OPEN CHANNEL COMMAND     STA     XXB9          ; SET SECONDARY ADDRESS     STA     XX026D,X          ; SAVE TO SECONDARY ADDRESS TABLE     LDA     XXBA          ; GET DEVICE NUMBER     STA     XX0263,X          ; SAVE TO DEVICE NUMBER TABL2E     BEQ     XXF493          ; DO OK EXIT IF KEYBOARD     CMP     #$03               ; COMPARE DEVICE NUMBER WITH SCREEN     BEQ     XXF493          ; DO OK EXIT IF SCREEN     BCC     XXF444          ; BRANCH IF < SCREEN, TAPE OR RS232          2               ; ELSE IS SERIAL BUS DEVICE     JSR     XXF495          ; SEND SECONDARY ADDRESS AND FILENAME     BCC     XXF493          ; DO OK EXITXXF444 = *     CMP     #$02               ; COMPARE DEVICE WITH RS232 DEVICE     BNE     XXF44B    2      ; BRANCH IF NOT RS232 DEVICE, MUST BE TAPE     JMP     XXF4C7          ; GO OPEN RS232 DEVICE AND RETURNXXF44B = *     JSR     XXF84D          ; GET TAPE BUFFER START POINTER IN XY     BCS     XXF453          ; BRANCH IF >= $0200     JMP   2  XXF796          ; DO ILLEGAL DEVICE NUMBER AND RETURNXXF453 = *     LDA     XXB9          ; GET SECONDARY ADDRESS     AND     #$0F               ;.     BNE     XXF478          ;.     JSR     XXF894          ; WAIT FOR PLAY     BCS     XXF494   2       ; EXIT IF STOP WAS PRESSED     JSR     XXF647          ; PRINT 'SEARCHING...'     LDA     XXB7          ; GET FILE NAME LENGTH     BEQ     XXF46F          ; IF NULL FILE NAME JUST GO FIND HEADER     JSR     XXF867          ; FIND SPECIFIC TA2PE HEADER     BCC     XXF482          ; BRANCH IF NO ERROR     BEQ     XXF494          ; EXIT IF ??XXF46C = *     JMP     XXF787          ; DO FILE NOT FOUND ERROR AND RETURNXXF46F = *     JSR     XXF7AF          ; FIND TAPE HEADER, EXIT WITH HE2ADER IN BUFFER     BEQ     XXF494          ; EXIT IF END OF TAPE FOUND     BCC     XXF482          ;.     BCS     XXF46C          ;.XXF478 = *     JSR     XXF8B7          ; WAIT FOR PLAY/RECORD     BCS     XXF494          ; EXIT IF STOP WAS PRES2SED     LDA     #$04               ; SET DATA FILE HEADER     JSR     XXF7E7          ; WRITE TAPE HEADERXXF482 = *     LDA     #$BF               ;.     LDY     XXB9          ; GET SECONDARY ADDRESS     CPY     #$60               ;.     BEQ     2XXF491          ;.     LDY     #$00               ; CLEAR INDEX     LDA     #$02               ;.     STA     (XXB2),Y          ;.SAVE TO TAPE BUFFER     TYA                    ;.CLEAR AXXF491 = *     STA     XXA6          ;.SAVE TAPE BUFFER INDEX2XXF493 = *     CLC                    ; FLAG OKXXF494 = *     RTS;***********************************************************************************;;; SEND SECONDARY ADDRESS AND FILENAMEXXF495 = *     LDA     XXB9          ; GET SECONDARY A2DDRESS     BMI     XXF4C5          ; OK EXIT IF -VE     LDY     XXB7          ; GET FILE NAME LENGTH     BEQ     XXF4C5          ; OK EXIT IF NULL     LDA     XXBA          ; GET DEVICE NUMBER     JSR     XXEE17          ; COMMAND DEVICES ON THE S2ERIAL BUS TO LISTEN     LDA     XXB9          ; GET THE SECONDARY ADDRESS     ORA     #$F0               ; OR WITH THE OPEN COMMAND     JSR     XXEEC0          ; SEND SECONDARY ADDRESS AFTER LISTEN     LDA     XX90          ; GET SERIAL STATUS BYTE 2    BPL     XXF4B2          ; BRANCH IF DEVICE PRESENT     PLA                    ; ELSE DUMP CALLING ADDRESS LOW BYTE     PLA                    ; DUMP CALLING ADDRESS HIGH BYTE     JMP     XXF78A          ; DO DEVICE NOT PRESENT ERROR AND RETURNX2XF4B2 = *     LDA     XXB7          ; GET FILE NAME LENGTH     BEQ     XXF4C2          ; BRANCH IF NULL NAME     LDY     #$00               ; CLEAR INDEXXXF4B8 = *     LDA     (XXBB),Y          ; GET FILE NAME BYTE     JSR     XXEEE4          ; OU2TPUT A BYTE TO THE SERIAL BUS     INY                    ; INCREMENT INDEX     CPY     XXB7          ; COMPARE WITH FILE NAME LENGTH     BNE     XXF4B8          ; LOOP IF NOT ALL DONEXXF4C2 = *     JSR     XXEF04          ; COMMAND THE SERIAL BUS T2O UNLISTENXXF4C5 = *     CLC                    ; FLAG OK     RTS;***********************************************************************************;;; OPEN RS232XXF4C7 = *     LDA     #$06               ; IIII IOOI, DTR AND RTS ONLY AS OUTPU2TS     STA     XX9112          ; SET VIA 1 DDRB     STA     XX9110          ; SET VIA 1 DRB, DTR AND RTS HIGH     LDA     #$EE               ; CB2 HIGH, CB1 -VE EDGE, CA2 HIGH, CA1 -VE EDGE     STA     XX911C          ; SET VIA 1 PCR     LDY     #$020               ; CLEAR INDEX     STY     XX0297          ; CLEAR RS232 STATUS BYTEXXF4D9 = *     CPY     XXB7          ; COMPARE WITH FILE NAME LENGTH     BEQ     XXF4E7          ; EXIT LOOP IF DONE     LDA     (XXBB),Y          ; GET FILE NAME BY2 TE     STA     XX0293,Y          ; COPY TO 6551 REGISTER SET     INY                    ; INCREMENT INDEX     CPY     #$04               ; COMPARE WITH $04     BNE     XXF4D9          ; LOOP IF NOT TO 4 YETXXF4E7 = *     JSR     XXF027          ; 2!COMPUTE BIT COUNT     STX     XX0298          ; SAVE BIT COUNT     LDA     XX0293          ; GET PSEUDO 6551 CONTROL REGISTER     AND     #$0F               ; MASK 0000 XXXX, BAUD RATE     BNE     XXF4F4          ; BRANCH NOWHERE. PERHAPS THERE WAS G2"OING TO BE SOME                         ; ERROR TRAPPING FOR UNIMPLEMENTED BAUD RATES BUT                         ; THIS WAS EVER DONEXXF4F4 = *     ASL A                  ; * 2     TAX                    ; COPY TO INDEX     LDA     XXFF5C-2,X     2#; GET TIMER CONSTANT LOW BYTE     ASL A                  ; * 2     TAY                    ; COPY TO Y     LDA     XXFF5C-1,X     ; GET TIMER CONSTANT HIGH BYTE     ROL A                  ; * 2     PHA                    ; SAVE IT     TYA           2$         ; GET TIMER CONSTANT LOW BYTE BACK     ADC     #$C8               ; + $C8, CARRY CLEARED BY PREVIOUS ROL     STA     XX0299          ; SAVE BIT CELL TIME LOW BYTE     PLA                    ; RESTORE HIGH  BYTE     ADC     #$00              2% ; ADD CARRY     STA     XX029A          ; SAVE BIT CELL TIME HIGH BYTE     LDA     XX0294          ; GET PSEUDO 6551 COMMAND REGISTER     LSR A                  ; SHIFT B0 INTO CB     BCC     XXF51B          ; BRANCH IF 3 LINE INTERFACE     LDA   2&  XX9120          ; GET VIA 2 DRB, THIS IS WRONG, THE ADRESS SHOULD BE                         ; XX9110 WHICH IS VIA 1 WHICH IS WHERE THE DSR INPUT                         ; REALLY IS     ASL A                  ; SHIFT DSR INTO CB     BCS     XXF51B 2'         ; BRANCH IF DSR = 1     JMP     XXF016          ; SET DSR SIGNAL NOT PRESENT AND RETURNXXF51B = *     LDA     XX029B          ; GET INDEX TO RX BUFFER END     STA     XX029C          ; SET INDEX TO RX BUFFER START, CLEAR RX BUFFER     LDA3      XX029E          ; GET INDEX TO TX BUFFER END     STA     XX029D          ; SET INDEX TO TX BUFFER START, CLEAR TX BUFFER     JSR     XXFE75          ; READ THE TOP OF MEMORY     LDA     XXF8          ; GET RX BUFFER POINTER HIGH BYTE     BNE    3 XXF533          ; BRANCH IF BUFFER ALREADY SET     DEY                    ; DECREMENT TOP OF MEMORY HIGH BYTE, 256 BYTE BUFFER     STY     XXF8          ; SET RX BUFFER POINTER HIGH BYTE     STX     XXF7          ; SET RX BUFFER POINTER LOW BYTEXXF3533 = *     LDA     XXFA          ; GET TX BUFFER POINTER HIGH BYTE     BNE     XXF53C          ; BRANCH IF BUFFER ALREADY SET     DEY                    ; DECREMENT RX BUFFER POINTER HIGH BYTE, 256 BYTE BUFFER     STY     XXFA          ; SET TX BUF3FER POINTER HIGH BYTE     STX     XXF9          ; SET TX BUFFER POINTER LOW BYTEXXF53C = *     SEC                    ;.     LDA     #$F0               ;.     JMP     XXFE7B          ; SET THE TOP OF MEMORY AND RETURN;****************************3*******************************************************;;; LOAD RAM FROM A DEVICE; THIS ROUTINE WILL LOAD DATA BYTES FROM ANY INPUT DEVICE DIRECTLY INTO THE MEMORY; OF THE COMPUTER. IT CAN ALSO BE USED FOR A VERIFY OPERATION COMPARING DATA FROM A; 3DEVICE WITH THE DATA ALREADY IN MEMORY, LEAVING THE DATA STORED IN RAM UNCHANGED.; THE ACCUMULATOR MUST BE SET TO 0 FOR A LOAD OPERATION OR 1 FOR A VERIFY. IF THE; INPUT DEVICE WAS OPENED WITH A SECONDARY ADDRESS OF 0 THE HEADER INFORMATION FROM; DEV3ICE WILL BE IGNORED. IN THIS CASE XY MUST CONTAIN THE STARTING ADDRESS FOR THE; LOAD. IF THE DEVICE WAS ADDRESSED WITH A SECONDARY ADDRESS OF 1 OR 2 THE DATA WILL; LOAD INTO MEMORY STARTING AT THE LOCATION SPECIFIED BY THE HEADER. THIS ROUTINE; RETURN3S THE ADDRESS OF THE HIGHEST RAM LOCATION WHICH WAS LOADED.; BEFORE THIS ROUTINE CAN BE CALLED, THE SETLFS, XXFFBA, AND SETNAM, XXFFBD,; ROUTINES MUST BE CALLED.XXF542 = *     STX     XXC3          ; SET KERNAL SETUP POINTER LOW BYTE     STY     X3XC4          ; SET KERNAL SETUP POINTER HIGH BYTE     JMP     (XX0330)          ; DO LOAD VECTOR, USUALLY POINTS TO XXF549;***********************************************************************************;;; LOADXXF549 = *     STA     XX93    3	      ; SAVE LOAD/VERIFY FLAG     LDA     #$00               ; CLEAR A     STA     XX90          ; CLEAR SERIAL STATUS BYTE     LDA     XXBA          ; GET DEVICE NUMBER     BNE     XXF556          ; BRANCH IF NOT KEYBOARD                         ;3
 CAN'T LOAD FORM KEYBOARD SO ..XXF553 = *     JMP     XXF796          ; DO ILLEGAL DEVICE NUMBER AND RETURNXXF556 = *     CMP     #$03               ; COMPARE DEVICE NUMBER WITH SCREEN     BEQ     XXF553          ; IF SCREEN GO DO ILLEGAL DEVICE NU3MBER AND RETURN     BCC     XXF5CA          ; BRANCH IF LESS THAN SCREEN                         ; ELSE IS SERIAL BUS DEVICE     LDY     XXB7          ; GET FILE NAME LENGTH     BNE     XXF563          ; BRANCH IF NOT NULL NAME     JMP     XXF7933          ; ELSE DO MISSING FILE NAME ERROR AND RETURNXXF563 = *     JSR     XXE4BC          ; GET SECONDAY ADDRESS AND PRINT 'SEARCHING...'     LDA     #$60               ;.     STA     XXB9          ; SAVE THE SECONDARY ADDRESS     JSR     XXF4953          ; SEND SECONDARY ADDRESS AND FILENAME     LDA     XXBA          ; GET DEVICE NUMBER     JSR     XXEE14          ; COMMAND A SERIAL BUS DEVICE TO TALK     LDA     XXB9          ; GET SECONDARY ADDRESS     JSR     XXEECE          ; SEND SECON3DARY ADDRESS AFTER TALK     JSR     XXEF19          ; INPUT A BYTE FROM THE SERIAL BUS     STA     XXAE          ; SAVE PROGRAM START ADDRESS LOW BYTE     LDA     XX90          ; GET SERIAL STATUS BYTE     LSR A                  ; SHIFT TIME OUT READ3 ..     LSR A                  ; .. INTO CARRY BIT     BCS     XXF5C7          ; IF TIMED OUT GO DO FILE NOT FOUND ERROR AND RETURN     JSR     XXEF19          ; INPUT A BYTE FROM THE SERIAL BUS     STA     XXAF          ; SAVE PROGRAM START ADDRESS3 HIGH BYTE     JSR     XXE4C1          ; SET LOAD ADDRESS IF SECONDARY ADDRESS = 0XXF58A = *     LDA     #$FD               ; MASK XXXX XX0X, CLEAR TIME OUT READ BIT     AND     XX90          ; MASK SERIAL STATUS BYTE     STA     XX90          ; SET3 SERIAL STATUS BYTE     JSR     XXFFE1          ; SCAN STOP KEY, RETURN ZB = 1 = [STOP]     BNE     XXF598          ; BRANCH IF NOT [STOP]     JMP     XXF6CB          ; ELSE CLOSE THE SERIAL BUS DEVICE AND FLAG STOPXXF598 = *     JSR     XXEF19   3       ; INPUT A BYTE FROM THE SERIAL BUS     TAX                    ; COPY BYTE     LDA     XX90          ; GET SERIAL STATUS BYTE     LSR A                  ; SHIFT TIME OUT READ ..     LSR A                  ; .. INTO CARRY BIT     BCS     XXF58A3          ; IF TIMED OUT GO ??     TXA                    ; COPY RECEIVED BYTE BACK     LDY     XX93          ; GET LOAD/VERIFY FLAG     BEQ     XXF5B3          ; BRANCH IF LOAD                         ; ELSE IS VERIFY     LDY     #$00            3   ; CLEAR INDEX     CMP     (XXAE),Y          ; COMPARE BYTE WITH PREVIOUSLY LOADED BYTE     BEQ     XXF5B5          ; BRANCH IF MATCH     LDA     #$10               ; FLAG READ ERROR     JSR     XXFE6A          ; OR INTO SERIAL STATUS BYTE     .B3YTE     $2C               ; MAKES NEXT LINE BIT XXAE91XXF5B3 = *     STA     (XXAE),Y          ; SAVE BYTE TO MEMORYXXF5B5 = *     INC     XXAE          ; INCREMENT SAVE POINTER LOW BYTE     BNE     XXF5BB          ; IF NO ROLLOVER SKIP THE HIGH BYT3E INCREMENT     INC     XXAF          ; ELSE INCREMENT SAVE POINTER HIGH BYTEXXF5BB = *     BIT     XX90          ; TEST SERIAL STATUS BYTE     BVC     XXF58A          ; LOOP IF NOT END OF FILE     JSR     XXEEF6          ; COMMAND THE SERIAL BUS 3TO UNTALK     JSR     XXF6DA          ; CLOSE SERIAL BUS DEVICE     BCC     XXF641          ; IF ?? GO FLAG OK AND EXITXXF5C7 = *     JMP     XXF787          ; DO FILE NOT FOUND ERROR AND RETURNXXF5CA = *     CMP     #$02               ; COMPARE 3DEVICE WITH RS232 DEVICE     BNE     XXF5D1          ; IF NOT RS232 DEVICE CONTINUE     JMP     XXF0B9          ; ELSE DO ILLEGAL DEVICE NUMBER AND RETURNXXF5D1 = *     JSR     XXF84D          ; GET TAPE BUFFER START POINTER IN XY     BCS     XXF53D9          ; BRANCH IF >= $0200     JMP     XXF796          ; DO ILLEGAL DEVICE NUMBER AND RETURNXXF5D9 = *     JSR     XXF894          ; WAIT FOR PLAY     BCS     XXF646          ; EXIT IF STOP WAS PRESSED     JSR     XXF647          ; PRINT 'S3EARCHING...'XXF5E1 = *     LDA     XXB7          ; GET FILE NAME LENGTH     BEQ     XXF5EE     JSR     XXF867          ; FIND SPECIFIC TAPE HEADER     BCC     XXF5F5          ; IF NO ERROR CONTINUE     BEQ     XXF646          ; EXIT IF ??     BC3S     XXF5C7          ;., BRANCH ALWAYSXXF5EE = *     JSR     XXF7AF          ; FIND TAPE HEADER, EXIT WITH HEADER IN BUFFER     BEQ     XXF646          ; EXIT IF ??     BCS     XXF5C7          ;.XXF5F5 = *     LDA     XX90          ; GET SERIAL3 STATUS BYTE     AND     #$10               ; MASK 000X 0000, READ ERROR     SEC                    ; FLAG FAIL     BNE     XXF646          ; IF READ ERROR JUST EXIT     CPX     #$01               ;.     BEQ     XXF611          ;.     CPX     #$033               ;.     BNE     XXF5E1          ;.XXF604 = *     LDY     #$01               ;.     LDA     (XXB2),Y          ;.     STA     XXC3          ;.     INY                    ;.     LDA     (XXB2),Y          ;.     STA     XXC4          3;.     BCS     XXF615          ;.XXF611 = *     LDA     XXB9          ; GET SECONDARY ADDRESS     BNE     XXF604          ;.XXF615 = *     LDY     #$03               ;.     LDA     (XXB2),Y          ;.     LDY     #$01               ;.     SBC3     (XXB2),Y          ;.     TAX                    ;.     LDY     #$04               ;.     LDA     (XXB2),Y          ;.     LDY     #$02               ;.     SBC     (XXB2),Y          ;.     TAY                    ;.     CLC                    3 ;.     TXA                    ;.     ADC     XXC3          ;.     STA     XXAE          ;.     TYA                    ;.     ADC     XXC4          ;.     STA     XXAF          ;.     LDA     XXC3          ;.     STA     XXC1          ; SET I/O ST3!ART ADDRESSES LOW BYTE     LDA     XXC4          ;.     STA     XXC2          ; SET I/O START ADDRESSES HIGH BYTE     JSR     XXF66A          ; DISPLAY 'LOADING' OR 'VERIFYING'     JSR     XXF8C9          ; DO THE TAPE READ     .BYTE     $24        3"       ; MAKES NEXT LINE BIT XX18, KEEP THE ERROR FLAG IN CBXXF641 = *     CLC                    ; FLAG OK     LDX     XXAE          ; GET THE LOAD END POINTER LOW BYTE     LDY     XXAF          ; GET THE LOAD END POINTER HIGH BYTEXXF646 = *     R3#TS;***********************************************************************************;;; PRINT 'SEARCHING'XXF647 = *     LDA     XX9D          ; GET MESSAGE MODE FLAG     BPL     XXF669          ; EXIT IF CONTROL MESSAGES OFF     LDY     #XXF3$180-XXF174                         ; INDEX TO 'SEARCHING '     JSR     XXF1E6          ; DISPLAY KERNEL I/O MESSAGE     LDA     XXB7          ; GET FILE NAME LENGTH     BEQ     XXF669          ; EXIT IF NULL NAME     LDY     #XXF18B-XXF174        3%                 ; ELSE INDEX TO 'FOR '     JSR     XXF1E6          ; DISPLAY KERNEL I/O MESSAGE; PRINT FILE NAMEXXF659 = *     LDY     XXB7          ; GET FILE NAME LENGTH     BEQ     XXF669          ; EXIT IF NULL FILE NAME     LDY     #$00   3&            ; CLEAR INDEXXXF65F = *     LDA     (XXBB),Y          ; GET FILE NAME BYTE     JSR     XXFFD2          ; OUTPUT CHARACTER TO CHANNEL     INY                    ; INCREMENT INDEX     CPY     XXB7          ; COMPARE WITH FILE NAME LENGTH 3'    BNE     XXF65F          ; LOOP IF MORE TO DOXXF669 = *     RTS; DISPLAY 'LOADING' OR 'VERIFYING'XXF66A = *     LDY     #XXF1BD-XXF174                         ; POINT TO 'LOADING'     LDA     XX93          ; GET LOAD/VERIFY FLAG     BEQ    4  XXF672          ; BRANCH IF LOAD     LDY     #XXF1CD-XXF174                         ; POINT TO 'VERIFYING'XXF672 = *     JMP     XXF1E2          ; DISPLAY KERNEL I/O MESSAGE IF IN DIRECT MODE AND RETURN;******************************************4*****************************************;;; SAVE RAM TO DEVICE, A = INDEX TO START ADDRESS, XY = END ADDRESS LOW/HIGH; THIS ROUTINE SAVES A SECTION OF MEMORY. MEMORY IS SAVED FROM AN INDIRECT ADDRESS; ON PAGE 0 SPECIFIED BY A, TO THE ADDRESS STORED4 IN XY, TO A LOGICAL FILE. THE; SETLFS, XXFFBA, AND SETNAM, XXFFBD, ROUTINES MUST BE USED BEFORE CALLING THIS; ROUTINE. HOWEVER, A FILE NAME IS NOT REQUIRED TO SAVE TO DEVICE 1, THE CASSETTE.; ANY ATTEMPT TO SAVE TO OTHER DEVICES WITHOUT USING A FILE 4NAME RESULTS IN AN ERROR.; NOTE: DEVICE 0, THE KEYBOARD, AND DEVICE 3, THE SCREEN, CANNOT BE SAVED TO. IF; THE ATTEMPT IS MADE, AN ERROR WILL OCCUR, AND THE SAVE STOPPED.XXF675 = *     STX     XXAE          ; SAVE END ADDRESS LOW BYTE     STY     4XXAF          ; SAVE END ADDRESS HIGH BYTE     TAX                    ; COPY INDEX TO START POINTER     LDA     XX00,X          ; GET START ADDRESS LOW BYTE     STA     XXC1          ; SET I/O START ADDRESSES LOW BYTE     LDA     XX01,X          ; GE4T START ADDRESS HIGH BYTE     STA     XXC2          ; SET I/O START ADDRESSES HIGH BYTE     JMP     (XX0332)          ; GO SAVE, USUALLY POINTS TO XXF685;***********************************************************************************;;; SAVE4XXF685 = *     LDA     XXBA          ; GET DEVICE NUMBER     BNE     XXF68C          ; BRANCH IF NOT KEYBOARD                         ; ELSE ..XXF689 = *     JMP     XXF796          ; DO ILLEGAL DEVICE NUMBER AND RETURNXXF68C = *     CMP     #$043               ; COMPARE DEVICE NUMBER WITH SCREEN     BEQ     XXF689          ; IF SCREEN DO ILLEGAL DEVICE NUMBER AND RETURN     BCC     XXF6F1          ; BRANCH IF < SCREEN                         ; IS GREATER THAN SCREEN SO IS SERIAL BUS     L4DA     #$61               ; SET SECONDARY ADDRESS TO $01                         ; WHEN A SECONDARY ADDRESS IS TO BE SENT TO A DEVICE ON                         ; THE SERIAL BUS THE ADDRESS MUST FIRST BE ORED WITH $60     STA     XXB9          ; SAVE 4	SECONDARY ADDRESS     LDY     XXB7          ; GET FILE NAME LENGTH     BNE     XXF69D          ; BRANCH IF FILENAME NOT NULL     JMP     XXF793          ; ELSE DO MISSING FILE NAME ERROR AND RETURNXXF69D = *     JSR     XXF495          ; SEND SECO4
NDARY ADDRESS AND FILENAME     JSR     XXF728          ; PRINT SAVING [FILE NAME]     LDA     XXBA          ; GET DEVICE NUMBER     JSR     XXEE17          ; COMMAND DEVICES ON THE SERIAL BUS TO LISTEN     LDA     XXB9          ; GET SECONDARY ADDRES4S     JSR     XXEEC0          ; SEND SECONDARY ADDRESS AFTER LISTEN     LDY     #$00               ; CLEAR INDEX     JSR     XXFBD2          ; COPY I/O START ADDRESS TO BUFFER ADDRESS     LDA     XXAC          ; GET BUFFER ADDRESS LOW BYTE     JSR  4   XXEEE4          ; OUTPUT A BYTE TO THE SERIAL BUS     LDA     XXAD          ; GET BUFFER ADDRESS HIGH BYTE     JSR     XXEEE4          ; OUTPUT A BYTE TO THE SERIAL BUSXXF6BC = *     JSR     XXFD11          ; CHECK READ/WRITE POINTER, RETURN CB = 41 IF POINTER >= END     BCS     XXF6D7          ; GO DO UNLISTEN IF AT END     LDA     (XXAC),Y          ; GET BYTE FROM BUFFER     JSR     XXEEE4          ; OUTPUT A BYTE TO THE SERIAL BUS     JSR     XXFFE1          ; SCAN STOP KEY     BNE     XX4F6D2          ; IF STOP NOT PRESSED GO INCREMENT POINTER AND LOOP FOR NEXT                         ; ELSE ..; CLOSE THE SERIAL BUS DEVICE AND FLAG STOPXXF6CB = *     JSR     XXF6DA          ; CLOSE SERIAL BUS DEVICE     LDA     #$00              4 ;.     SEC                    ; FLAG STOP     RTSXXF6D2 = *     JSR     XXFD1B          ; INCREMENT READ/WRITE POINTER     BNE     XXF6BC          ; LOOP, BRANCH ALWAYS;***************************************************************************4********;;; ??XXF6D7 = *     JSR     XXEF04          ; COMMAND THE SERIAL BUS TO UNLISTEN; CLOSE THE SERIAL BUS DEVICEXXF6DA = *     BIT     XXB9          ; TEST THE SECONDARY ADDRESS     BMI     XXF6EF          ; IF ALREADY CLOSED JUST EXIT4     LDA     XXBA          ; GET THE DEVICE NUMBER     JSR     XXEE17          ; COMMAND DEVICES ON THE SERIAL BUS TO LISTEN     LDA     XXB9          ; GET SECONDARY ADDRESS     AND     #$EF               ; MASK THE CHANNEL NUMBER     ORA     #$E0  4             ; OR WITH THE CLOSE COMMAND     JSR     XXEEC0          ; SEND SECONDARY ADDRESS AFTER LISTEN     JSR     XXEF04          ; COMMAND THE SERIAL BUS TO UNLISTENXXF6EF = *     CLC                    ; FLAG OK     RTSXXF6F1 = *     CMP  4   #$02               ; COMPARE DEVICE WITH RS232 DEVICE     BNE     XXF6F8          ; BRANCH IF NOT RS232 DEVICE     JMP     XXF0B9          ; ELSE DO ILLEGAL DEVICE NUMBER AND RETURNXXF6F8 = *     JSR     XXF84D          ; GET TAPE BUFFER START P4OINTER IN XY     BCC     XXF689          ; IF < $0200 DO ILLEGAL DEVICE NUMBER AND RETURN     JSR     XXF8B7          ; WAIT FOR PLAY/RECORD     BCS     XXF727          ; EXIT IF STOP WAS PRESSED     JSR     XXF728          ; PRINT SAVING [FILE NAM4E]     LDX     #$03               ; SET HEADER FOR A NON RELOCATABLE PROGRAM FILE     LDA     XXB9          ; GET SECONDARY ADDRESS     AND     #$01               ; MASK NON RELOCATABLE BIT     BNE     XXF70F          ; BRANCH IF NON RELOCATABLE PROG4RAM     LDX     #$01               ; ELSE SET HEADER FOR A RELOCATABLE PROGRAM FILEXXF70F = *     TXA                    ; COPY HEADER TYPE TO A     JSR     XXF7E7          ; WRITE TAPE HEADER     BCS     XXF727          ; EXIT IF ERROR     JSR  4   XXF8E6          ; DO TAPE WRITE, 20 CYCLE COUNT     BCS     XXF727          ; EXIT IF ERROR     LDA     XXB9          ; GET SECONDARY ADDRESS     AND     #$02               ; MASK END OF TAPE FLAG     BEQ     XXF726          ; BRANCH IF NOT END O4F TAPE     LDA     #$05               ; ELSE SET LOGICAL END OF THE TAPE     JSR     XXF7E7          ; WRITE TAPE HEADER     .BYTE     $24               ; MAKES NEXT LINE BIT XX18 SO CB IS NOT CHANGEDXXF726 = *     CLC                    ; FLAG OK4XXF727 = *     RTS;***********************************************************************************;;; PRINT SAVING [FILE NAME]XXF728 = *     LDA     XX9D          ; GET MESSAGE MODE FLAG     BPL     XXF727          ; EXIT IF CONTROL MESSAGE4S OFF     LDY     #XXF1C5-XXF174                         ; INDEX TO 'SAVING '     JSR     XXF1E6          ; DISPLAY KERNEL I/O MESSAGE     JMP     XXF659          ; PRINT FILE NAME AND RETURN;******************************************************4*****************************;;; INCREMENT REAL TIME CLOCK; THIS ROUTINE UPDATES THE SYSTEM CLOCK. NORMALLY THIS ROUTINE IS CALLED BY THE; NORMAL KERNAL INTERRUPT ROUTINE EVERY 1/60TH OF A SECOND. IF THE USER PROGRAM; PROCESSES ITS OWN INTERRUPTS T4HIS ROUTINE MUST BE CALLED TO UPDATE THE TIME. ALSO,; THE STOP KEY ROUTINE MUST BE CALLED IF THE STOP KEY IS TO REMAIN FUNCTIONAL.XXF734 = *     LDX     #$00               ; CLEAR X     INC     XXA2          ; INCREMENT JIFFY LOW BYTE     BNE     X4XF740          ; IF NO ROLLOVER SKIP THE MID BYTE INCREMENT     INC     XXA1          ; INCREMENT JIFFY MID BYTE     BNE     XXF740          ; IF NO ROLLOVER SKIP THE HIGH BYTE INCREMENT     INC     XXA0          ; INCREMENT JIFFY HIGH BYTE       4                  ; NOW SUBTRACT A DAYS WORTH OF JIFFIES FROM CURRENT COUNT                         ; AND REMEMBER ONLY THE CB RESULTXXF740 = *     SEC                    ; SET CARRY FOR SUBTRACT     LDA     XXA2          ; GET JIFFY CLOCK LOW BYTE 4    SBC     #$01               ; SUBTRACT $4F1A01 LOW BYTE     LDA     XXA1          ; GET JIFFY CLOCK MID BYTE     SBC     #$1A               ; SUBTRACT $4F1A01 MID BYTE     LDA     XXA0          ; GET JIFFY CLOCK HIGH BYTE     SBC     #$4F         4       ; SUBTRACT $4F1A01 HIGH BYTE     BCC     XXF755          ; BRANCH IF LESS THAN $4F1A01 JIFFIES                         ; ELSE ..     STX     XXA0          ; CLEAR JIFFIES HIGH BYTE     STX     XXA1          ; CLEAR JIFFIES MID BYTE     STX   4!  XXA2          ; CLEAR JIFFIES LOW BYTE                         ; THIS IS WRONG, THERE ARE $4F1A00 JIFFIES IN A DAY SO                         ; THE RESET TO ZERO SHOULD OCCUR WHEN THE VALUE REACHES                         ; $4F1A00 AND NOT $4F1A01. 4"THIS WOULD GIVE AN EXTRA JIFFY                         ; EVERY DAY AND A POSSIBLE TI VALUE OF 24:00:00XXF755 = *     LDA     XX912F          ; GET VIA 2 DRA, KEYBOARD ROW, NO HANDSHAKE     CMP     XX912F          ; COMPARE WITH SELF     BNE     XXF74#55          ; LOOP IF CHANGING     STA     XX91          ; SAVE VIA 2 DRA, KEYBOARD ROW     RTS;***********************************************************************************;;; READ THE REAL TIME CLOCK; THIS ROUTINE RETURNS THE TIME, IN J4$IFFIES, IN AXY. THE ACCUMULATOR CONTAINS THE; MOST SIGNIFICANT BYTE.XXF760 = *     SEI                    ; DISABLE INTERRUPTS     LDA     XXA2          ; GET JIFFY CLOCK LOW BYTE     LDX     XXA1          ; GET JIFFY CLOCK MID BYTE     LDY     XX4%A0          ; GET JIFFY CLOCK HIGH BYTE;***********************************************************************************;;; SET THE REAL TIME CLOCK; THE SYSTEM CLOCK IS MAINTAINED BY AN INTERRUPT ROUTINE THAT UPDATES THE CLOCK; EVERY 1/60TH OF4& A SECOND. THE CLOCK IS THREE BYTES LONG WHICH GIVES THE CAPABILITY; TO COUNT FROM ZERO UP TO 5,184,000 JIFFIES - 24 HOURS PLUS ONE JIFFY. AT THAT POINT; THE CLOCK RESETS TO ZERO. BEFORE CALLING THIS ROUTINE TO SET THE CLOCK THE NEW TIME,; IN JIFFIES,4' SHOULD BE IN YXA, THE ACCUMULATOR CONTAINING THE MOST SIGNIFICANT BYTE.XXF767 = *     SEI                    ; DISABLE INTERRUPTS     STA     XXA2          ; SAVE JIFFY CLOCK LOW BYTE     STX     XXA1          ; SAVE JIFFY CLOCK MID BYTE     STY  5    XXA0          ; SAVE JIFFY CLOCK HIGH BYTE     CLI                    ; ENABLE INTERRUPTS     RTS;***********************************************************************************;;; SCAN STOP KEY, RETURN ZB = 1 = [STOP]; IF THE STOP KEY ON5 THE KEYBOARD IS PRESSED WHEN THIS ROUTINE IS CALLED THE Z FLAG; WILL BE SET. ALL OTHER FLAGS REMAIN UNCHANGED. IF THE STOP KEY IS NOT PRESSED THEN; THE ACCUMULATOR WILL CONTAIN A BYTE REPRESENTING THE LAST ROW OF THE KEYBOARD SCAN.; THE USER CAN ALS5O CHECK FOR CERTAIN OTHER KEYS THIS WAY.XXF770 = *     LDA     XX91          ; GET KEYBOARD ROW     CMP     #$FE               ; COMPARE WITH R0 DOWN     BNE     XXF77D          ; BRANCH IF NOT JUST R0     PHP                    ; SAVE STATUS    5 JSR     XXFFCC          ; CLOSE INPUT AND OUTPUT CHANNELS     STA     XXC6          ; SAVE KEYBOARD BUFFER LENGTH     PLP                    ; RESTORE STATUSXXF77D = *     RTS;**********************************************************************5*************;;; FILE ERROR MESSAGESXXF77E = *     LDA     #$01               ; TOO MANY FILES     .BYTE     $2C               ; MAKES NEXT LINE BIT XX02A9XXF781 = *     LDA     #$02               ; FILE ALREADY OPEN     .BYTE     $2C           5    ; MAKES NEXT LINE BIT XX03A9XXF784 = *     LDA     #$03               ; FILE NOT OPEN     .BYTE     $2C               ; MAKES NEXT LINE BIT XX04A9XXF787 = *     LDA     #$04               ; FILE NOT FOUND     .BYTE     $2C               ; MAKES5 NEXT LINE BIT XX05A9XXF78A = *     LDA     #$05               ; DEVICE NOT PRESENT     .BYTE     $2C               ; MAKES NEXT LINE BIT XX06A9XXF78D = *     LDA     #$06               ; NOT INPUT FILE     .BYTE     $2C               ; MAKES NEXT 5LINE BIT XX07A9XXF790 = *     LDA     #$07               ; NOT OUTPUT FILE     .BYTE     $2C               ; MAKES NEXT LINE BIT XX08A9XXF793 = *     LDA     #$08               ; MISSING FILE NAME     .BYTE     $2C               ; MAKES NEXT LINE B5IT XX09A9XXF796 = *     LDA     #$09               ; ILLEGAL DEVICE NUMBER     PHA                    ; SAVE ERROR #     JSR     XXFFCC          ; CLOSE INPUT AND OUTPUT CHANNELS     LDY     #XXF174-XXF174                         ; INDEX TO 'I/O E5	RROR #'     BIT     XX9D          ; TEST MESSAGE MODE FLAG     BVC     XXF7AC          ; EXIT IF KERNAL MESSAGES OFF     JSR     XXF1E6          ; DISPLAY KERNEL I/O MESSAGE     PLA                    ; RESTORE ERROR #     PHA                    ; 5
COPY ERROR #     ORA     #'0'               ; CONVERT TO ASCII     JSR     XXFFD2          ; OUTPUT CHARACTER TO CHANNELXXF7AC = *     PLA                    ; PULL ERROR NUMBER     SEC                    ; FLAG ERROR     RTS;*******************5****************************************************************;;; FIND TAPE HEADER, EXIT WITH HEADER IN BUFFERXXF7AF = *     LDA     XX93          ; GET LOAD/VERIFY FLAG     PHA                    ; SAVE LOAD/VERIFY FLAG     JSR     XXF8C0      5    ; INITIATE TAPE READ     PLA                    ; RESTORE LOAD/VERIFY FLAG     STA     XX93          ; SAVE LOAD/VERIFY FLAG     BCS     XXF7E6          ; EXIT IF ERROR     LDY     #$00               ; CLEAR INDEX     LDA     (XXB2),Y          5; READ FIRST BYTE FROM TAPE BUFFER     CMP     #$05               ; COMPARE WITH LOGICAL END OF THE TAPE     BEQ     XXF7E6          ; EXIT IF END OF THE TAPE     CMP     #$01               ; COMPARE WITH HEADER FOR A RELOCATABLE PROGRAM FILE     BE5Q     XXF7CE          ; BRANCH IF PROGRAM FILE HEADER     CMP     #$03               ; COMPARE WITH HEADER FOR A NON RELOCATABLE PROGRAM FILE     BEQ     XXF7CE          ; BRANCH IF PROGRAM FILE HEADER     CMP     #$04               ; COMPARE WITH D5ATA FILE HEADER     BNE     XXF7AF          ; IF DATA FILE LOOP TO FIND TAPE HEADER                         ; WAS PROGRAM FILE HEADERXXF7CE = *     TAX                    ; COPY HEADER TYPE     BIT     XX9D          ; GET MESSAGE MODE FLAG     BPL5     XXF7E4          ; EXIT IF CONTROL MESSAGES OFF     LDY     #XXF1D7-XXF174                         ; INDEX TO 'FOUND '     JSR     XXF1E6          ; DISPLAY KERNEL I/O MESSAGE     LDY     #$05               ; INDEX TO TAPE FILENAMEXXF7DA = *  5   LDA     (XXB2),Y          ; GET BYTE FROM TAPE BUFFER     JSR     XXFFD2          ; OUTPUT CHARACTER TO CHANNEL     INY                    ; INCREMENT INDEX     CPY     #$15               ; COMPARE WITH END+1     BNE     XXF7DA          ; LOOP IF 5MORE TO DOXXF7E4 = *     CLC                    ; FLAG NO ERROR     DEY                    ; DECREMENT INDEXXXF7E6 = *     RTS;***********************************************************************************;;; WRITE TAPE HEADERXXF7E7 = *5     STA     XX9E          ; SAVE HEADER TYPE     JSR     XXF84D          ; GET TAPE BUFFER START POINTER IN XY     BCC     XXF84C          ; EXIT IF < $0200     LDA     XXC2          ; GET I/O START ADDRESS HIGH BYTE     PHA                    ; S5AVE IT     LDA     XXC1          ; GET I/O START ADDRESS LOW BYTE     PHA                    ; SAVE IT     LDA     XXAF          ; GET TAPE END ADDRESS HIGH BYTE     PHA                    ; SAVE IT     LDA     XXAE          ; GET TAPE END ADDRESS L5OW BYTE     PHA                    ; SAVE IT     LDY     #$BF               ; INDEX TO HEADER END     LDA     #' '               ; CLEAR BYTE, [SPACE]XXF7FE = *     STA     (XXB2),Y          ; CLEAR HEADER BYTE     DEY                    ; DECREME5NT INDEX     BNE     XXF7FE          ; LOOP IF MORE TO DO     LDA     XX9E          ; GET HEADER TYPE BACK     STA     (XXB2),Y          ; WRITE TO HEADER     INY                    ; INCREMENT INDEX     LDA     XXC1          ; GET I/O START ADDRES5S LOW BYTE     STA     (XXB2),Y          ; WRITE TO HEADER     INY                    ; INCREMENT INDEX     LDA     XXC2          ; GET I/O START ADDRESS HIGH BYTE     STA     (XXB2),Y          ; WRITE TO HEADER     INY                    ; INCREMEN5T INDEX     LDA     XXAE          ; GET TAPE END ADDRESS LOW BYTE     STA     (XXB2),Y          ; WRITE TO HEADER     INY                    ; INCREMENT INDEX     LDA     XXAF          ; GET TAPE END ADDRESS HIGH BYTE     STA     (XXB2),Y          ;5 WRITE TO HEADER     INY                    ; INCREMENT INDEX     STY     XX9F          ; SAVE INDEX     LDY     #$00               ; CLEAR Y     STY     XX9E          ; CLEAR NAME INDEXXXF822 = *     LDY     XX9E          ; GET NAME INDEX     CPY5     XXB7          ; COMPARE WITH FILE NAME LENGTH     BEQ     XXF834          ; EXIT LOOP IF ALL DONE     LDA     (XXBB),Y          ; GET FILE NAME BYTE     LDY     XX9F          ; GET BUFFER INDEX     STA     (XXB2),Y          ; SAVE FILE NAME BYT5E TO BUFFER     INC     XX9E          ; INCREMENT FILE NAME INDEX     INC     XX9F          ; INCREMENT TAPE BUFFER INDEX     BNE     XXF822          ; LOOP, BRANCH ALWAYSXXF834 = *     JSR     XXF854          ; SET TAPE BUFFER START AND END POINTE5RS     LDA     #$69               ; SET WRITE LEAD CYCLE COUNT     STA     XXAB          ; SAVE WRITE LEAD CYCLE COUNT     JSR     XXF8EA          ; DO TAPE WRITE, NO CYCLE COUNT SET     TAY                    ;.     PLA                    ; PULL TA5PE END ADDRESS LOW BYTE     STA     XXAE          ; RESTORE IT     PLA                    ; PULL TAPE END ADDRESS HIGH BYTE     STA     XXAF          ; RESTORE IT     PLA                    ; PULL I/O START ADDRESSES LOW BYTE     STA     XXC1       5   ; RESTORE IT     PLA                    ; PULL I/O START ADDRESSES HIGH BYTE     STA     XXC2          ; RESTORE IT     TYA                    ;.XXF84C = *     RTS;*******************************************************************************5****;;; GET TAPE BUFFER START POINTERXXF84D = *     LDX     XXB2          ; GET TAPE BUFFER START POINTER LOW BYTE     LDY     XXB3          ; GET TAPE BUFFER START POINTER HIGH BYTE     CPY     #$02               ; COMPARE HIGH BYTE WITH $02XX  5    RTS;***********************************************************************************;;; SET TAPE BUFFER START AND END POINTERSXXF854 = *     JSR     XXF84D          ; GET TAPE BUFFER START POINTER IN XY     TXA                    ; COPY TA5!PE BUFFER START POINTER LOW BYTE     STA     XXC1          ; SAVE AS I/O ADDRESS POINTER LOW BYTE     CLC                    ; CLEAR CARRY FOR ADD     ADC     #$C0               ; ADD BUFFER LENGTH LOW BYTE     STA     XXAE          ; SAVE TAPE BUFFE5"R END POINTER LOW BYTE     TYA                    ; COPY TAPE BUFFER START POINTER HIGH BYTE     STA     XXC2          ; SAVE AS I/O ADDRESS POINTER HIGH BYTE     ADC     #$00               ; ADD BUFFER LENGTH HIGH BYTE     STA     XXAF          ; SA5#VE TAPE BUFFER END POINTER HIGH BYTE     RTS;***********************************************************************************;;; FIND SPECIFIC TAPE HEADERXXF867 = *     JSR     XXF7AF          ; FIND TAPE HEADER, EXIT WITH HEADER IN BUFFER  5$   BCS     XXF889          ; JUST EXIT IF ERROR     LDY     #$05               ; INDEX TO NAME     STY     XX9F          ; SAVE AS TAPE BUFFER INDEX     LDY     #$00               ; CLEAR Y     STY     XX9E          ; SAVE AS NAME BUFFER INDEXXXF875%4 = *     CPY     XXB7          ; COMPARE WITH FILE NAME LENGTH     BEQ     XXF888          ; OK EXIT IF MATCH     LDA     (XXBB),Y          ; GET FILE NAME BYTE     LDY     XX9F          ; GET INDEX TO TAPE BUFFER     CMP     (XXB2),Y          ; C5&OMPARE WITH TAPE HEADER NAME BYTE     BNE     XXF867          ; IF NO MATCH GO GET NEXT HEADER     INC     XX9E          ; ELSE INCREMENT NAME BUFFER INDEX     INC     XX9F          ; INCREMENT TAPE BUFFER INDEX     LDY     XX9E          ; GET NAME 5'BUFFER INDEX     BNE     XXF874          ; LOOP, BRANCH ALWAYSXXF888 = *     CLC                    ; FLAG OKXXF889 = *     RTS;***********************************************************************************;;; BUMP TAPE POINTERXXF88A = 6 *     JSR     XXF84D          ; GET TAPE BUFFER START POINTER IN XY     INC     XXA6          ; INCREMENT TAPE BUFFER INDEX     LDY     XXA6          ; GET TAPE BUFFER INDEX     CPY     #$C0               ; COMPARE WITH BUFFER LENGTH     RTS;****6*******************************************************************************;;; WAIT FOR PLAYXXF894 = *     JSR     XXF8AB          ; RETURN CASSETTE SENSE IN ZB     BEQ     XXF8B5          ; EXIT IF SWITCH CLOSED                         ; CAS6SETTE SWITCH WAS OPEN     LDY     #XXF18F-XXF174                         ; INDEX TO 'PRESS PLAY ON TAPE'XXF89B = *     JSR     XXF1E6          ; DISPLAY KERNEL I/O MESSAGEXXF89E = *     JSR     XXF94B          ; SCAN STOP KEY AND FLAG ABORT IF PRES6SED                         ; NOTE IF STOP WAS PRESSED THE RETURN IS TO THE                         ; ROUTINE THAT CALLED THIS ONE AND NOT HERE     JSR     XXF8AB          ; RETURN CASSETTE SENSE IN ZB     BNE     XXF89E          ; LOOP IF CASSETTE S6WITCH OPEN     LDY     #XXF1DE-XXF174                         ; INDEX TO 'OK'     JMP     XXF1E6          ; DISPLAY KERNEL I/O MESSAGE AND RETURN;***********************************************************************************;;; RETURN CASSE6TTE SENSE IN ZBXXF8AB = *     LDA     #$40               ; MASK FOR CASSETTE SWITCH     BIT     XX911F          ; TEST VIA 1 DRA, NO HANDSHAKE     BNE     XXF8B5          ; BRANCH IF CASSETTE SENSE HIGH     BIT     XX911F          ; TEST VIA 1 DRA6 AGAINXXF8B5 = *     CLC     RTS;***********************************************************************************;;; WAIT FOR PLAY/RECORDXXF8B7 = *     JSR     XXF8AB          ; RETURN CASSETTE SENSE IN ZB     BEQ     XXF8B5          ; EXI6T IF SWITCH CLOSED                         ; CASSETTE SWITCH WAS OPEN     LDY     #XXF1A2-XXF174                         ; INDEX TO 'PRESS RECORD & PLAY ON TAPE'     BNE     XXF89B          ; DISPLAY MESSAGE AND WAIT FOR SWITCH, BRANCH ALWAYS;***6********************************************************************************;;; INITIATE TAPE READXXF8C0 = *     LDA     #$00               ; CLEAR A     STA     XX90          ; CLEAR SERIAL STATUS BYTE     STA     XX93          ; CLEAR THE LO6	AD/VERIFY FLAG     JSR     XXF854          ; SET TAPE BUFFER START AND END POINTERSXXF8C9 = *     JSR     XXF894          ; WAIT FOR PLAY     BCS     XXF8ED          ; EXIT IF STOP WAS PRESSED, USES FURTHER BCS AT TARGET                         ; AD6
DRESS TO REACH FINAL TARGET AT XXF957     SEI                    ; DISABLE INTERRUPTS     LDA     #$00               ; CLEAR A     STA     XXAA          ;.     STA     XXB4          ;.     STA     XXB0          ; CLEAR TAPE TIMING CONSTANT MIN BYTE6     STA     XX9E          ; CLEAR TAPE PASS 1 ERROR LOG/CHAR BUFFER     STA     XX9F          ; CLEAR TAPE PASS 2 ERROR LOG CORRECTED     STA     XX9C          ; CLEAR BYTE RECEIVED FLAG     LDA     #$82               ; ENABLE CA1 INTERRUPT     LDX6     #$0E               ; SET INDEX FOR TAPE READ VECTOR     BNE     XXF8F4          ; GO DO TAPE READ/WRITE, BRANCH ALWAYS;***********************************************************************************;;; INITIATE TAPE WRITEXXF8E3 = *     6JSR     XXF854          ; SET TAPE BUFFER START AND END POINTERS; DO TAPE WRITE, 20 CYCLE COUNTXXF8E6 = *     LDA     #$14               ; SET WRITE LEAD CYCLE COUNT     STA     XXAB          ; SAVE WRITE LEAD CYCLE COUNT; DO TAPE WRITE, NO CYCLE6 COUNT SETXXF8EA = *     JSR     XXF8B7          ; WAIT FOR PLAY/RECORDXXF8ED = *     BCS     XXF957          ; IF STOPPED CLEAR SAVE IRQ ADDRESS AND EXIT     SEI                    ; DISABLE INTERRUPTS     LDA     #$A0               ; ENABLE VIA6 2 T2 INTERRUPT     LDX     #$08               ; SET INDEX FOR TAPE WRITE TAPE LEADER VECTOR;***********************************************************************************;;; TAPE READ/WRITEXXF8F4 = *     LDY     #$7F               ; DISABL6E ALL INTERRUPTS     STY     XX912E          ; SET VIA 2 IER, DISABLE INTERRUPTS     STA     XX912E          ; SET VIA 2 IER, ENABLE INTERRUPTS ACCORDING TO A     JSR     XXF160          ; CHECK RS232 BUS IDLE     LDA     XX0314          ; GET IRQ VE6CTOR LOW BYTE     STA     XX029F          ; SAVE IRQ VECTOR LOW BYTE     LDA     XX0315          ; GET IRQ VECTOR HIGH BYTE     STA     XX02A0          ; SAVE IRQ VECTOR HIGH BYTE     JSR     XXFCFB          ; SET TAPE VECTOR     LDA     #$02       6        ; SET COPIES COUNT. THE FIRST COPY IS THE LOAD COPY, THE                         ; SECOND COPY IS THE VERIFY COPY     STA     XXBE          ; SAVE COPIES COUNT     JSR     XXFBDB          ; NEW TAPE BYTE SETUP     LDA     XX911C          ; GE6T VIA 1 PCR     AND     #$FD               ; CA2 LOW, TURN ON TAPE MOTOR     ORA     #$0C               ; MANUAL OUTPUT MODE     STA     XX911C          ; SET VIA 1 PCR     STA     XXC0          ; SET TAPE MOTOR INTERLOCK                         ; 6326656 CYCLE DELAY, ALLOW TAPE MOTOR SPEED TO STABILISE     LDX     #$FF               ; OUTER LOOP COUNTXXF923 = *     LDY     #$FF               ; INNER LOOP COUNTXXF925 = *     DEY                    ; DECREMENT INNER LOOP COUNT     BNE     XXF9625          ; LOOP IF MORE TO DO     DEX                    ; DECREMENT OUTER LOOP COUNT     BNE     XXF923          ; LOOP IF MORE TO DO     STA     XX9129          ; SET VIA 2 T2C_H     CLI                    ; ENABLE TAPE INTERRUPTSXXF92F = * 6    LDA     XX02A0          ; GET SAVED IRQ HIGH BYTE     CMP     XX0315          ; COMPARE WITH THE CURRENT IRQ HIGH BYTE     CLC                    ; FLAG OK     BEQ     XXF957          ; IF TAPE WRITE DONE GO CLEAR SAVED IRQ ADDRESS AND EXIT     6JSR     XXF94B          ; SCAN STOP KEY AND FLAG ABORT IF PRESSED                         ; NOTE IF STOP WAS PRESSED THE RETURN IS TO THE                         ; ROUTINE THAT CALLED THIS ONE AND NOT HERE     LDA     XX912D          ; GET VIA 2 IFR 6    AND     #$40               ; MASK T1 INTERRUPT     BEQ     XXF92F          ; LOOP IF NOT T1 INTERRUPT                         ; ELSE INCREMENT JIFFY CLOCK     LDA     XX9114          ; GET VIA 1 T1C_L, CLEAR T1 FLAG     JSR     XXF734          ;6 INCREMENT THE REAL TIME CLOCK     JMP     XXF92F          ; LOOP;***********************************************************************************;;; SCAN STOP KEY AND FLAG ABORT IF PRESSEDXXF94B = *     JSR     XXFFE1          ; SCAN STOP KE6Y     CLC                    ; FLAG NO STOP     BNE     XXF95C          ; EXIT IF NO STOP     JSR     XXFCCF          ; RESTORE EVERYTHING FOR STOP     SEC                    ; FLAG STOPPED     PLA                    ; DUMP RETURN ADDRESS LOW BYTE6     PLA                    ; DUMP RETURN ADDRESS HIGH BYTE;***********************************************************************************;;; CLEAR SAVED IRQ ADDRESSXXF957 = *     LDA     #$00               ; CLEAR A     STA     XX02A0     6     ; CLEAR SAVED IRQ ADDRESS HIGH BYTEXXF95C = *     RTS;***********************************************************************************;;;## SET TIMINGXXF95D = *     STX     XXB1          ; SAVE TAPE TIMING CONSTANT MAX BYTE     LDA    6 XXB0          ; GET TAPE TIMING CONSTANT MIN BYTE     ASL A                  ; *2     ASL A                  ; *4     CLC                    ; CLEAR CARRY FOR ADD     ADC     XXB0          ; ADD TAPE TIMING CONSTANT MIN BYTE *5     CLC             6       ; CLEAR CARRY FOR ADD     ADC     XXB1          ; ADD TAPE TIMING CONSTANT MAX BYTE     STA     XXB1          ; SAVE TAPE TIMING CONSTANT MAX BYTE     LDA     #$00               ;.     BIT     XXB0          ; TEST TAPE TIMING CONSTANT MIN BYTE6     BMI     XXF972          ; BRANCH IF B7 SET     ROL A                  ; ELSE SHIFT CARRY INTO ??XXF972 = *     ASL     XXB1          ; SHIFT TAPE TIMING CONSTANT MAX BYTE     ROL A                  ;.     ASL     XXB1          ; SHIFT TAPE TI6 MING CONSTANT MAX BYTE     ROL A                  ;.     TAX                    ;.XXF979 = *     LDA     XX9128          ; GET VIA 2 T2C_L     CMP     #$15               ;.COMPARE WITH ??     BCC     XXF979          ; LOOP IF LESS     ADC     XXB6!1          ; ADD TAPE TIMING CONSTANT MAX BYTE     STA     XX9124          ; SET VIA 2 T1C_L     TXA                    ;.     ADC     XX9129          ; ADD VIA 2 T2C_H     STA     XX9125          ; SET VIA 2 T1C_H     CLI                    ; ENABL6"E INTERRUPTS     RTS;***********************************************************************************;;;;     ON COMMODORE COMPUTERS, THE STREAMS CONSIST OF FOUR KINDS OF SYMBOLS;;     THAT DENOTE DIFFERENT KINDS OF LOW-TO-HIGH-TO-LOW TRANSITIO6#NS ON THE;;     READ OR WRITE SIGNALS OF THE COMMODORE CASSETTE INTERFACE.;;;;     A     A BREAK IN THE COMMUNICATIONS, OR A PULSE WITH VERY LONG CYCLE;;          TIME.;;;;     B     A SHORT PULSE, WHOSE CYCLE TIME TYPICALLY RANGES FROM 296 TO 4246$;;          MICROSECONDS, DEPENDING ON THE COMPUTER MODEL.;;;;     C     A MEDIUM-LENGTH PULSE, WHOSE CYCLE TIME TYPICALLY RANGES FROM;;          440 TO 576 MICROSECONDS, DEPENDING ON THE COMPUTER MODEL.;;;;     D     A LONG PULSE, WHOSE CYCLE TIME 6%TYPICALLY RANGES FROM 600 TO 744;;          MICROSECONDS, DEPENDING ON THE COMPUTER MODEL.;;;;   THE ACTUAL INTERPRETATION OF THE SERIAL DATA TAKES A LITTLE MORE WORK TO;; EXPLAIN. THE TYPICAL ROM TAPE LOADER (AND THE TURBO LOADERS) WILL;; INITIALIZ6&E A TIMER WITH A SPECIFIED VALUE AND START IT COUNTING DOWN. IF;; EITHER THE TAPE DATA CHANGES OR THE TIMER RUNS OUT, AN IRQ WILL OCCUR. THE;; LOADER WILL DETERMINE WHICH CONDITION CAUSED THE IRQ. IF THE TAPE DATA;; CHANGED BEFORE THE TIMER RAN OUT, W6'E HAVE A SHORT PULSE, OR A '0' BIT. IF;; THE TIMER RAN OUT FIRST, WE HAVE A LONG PULSE, OR A '1' BIT. DOING THIS;; CONTINUOUSLY AND WE DECODE THE ENTIRE FILE.; READ TAPE BITS, IRQ ROUTINE; READ T2C WHICH HAS BEEN COUNTING DOWN FROM $FFFF. SUBTRACT 7 THIS FROM $FFFFXXF98E = *     LDX     XX9129          ; GET VIA 2 T2C_H     LDY     #$FF               ;.SET $FF     TYA                    ;.A = $FF     SBC     XX9128          ; SUBTRACT VIA 2 T2C_L     CPX     XX9129          ; COMPARE VIA 2 T27C_H WITH PREVIOUS     BNE     XXF98E          ; LOOP IF TIMER LOW BYTE ROLLED OVER     STX     XXB1          ; SAVE TAPE TIMING CONSTANT MAX BYTE     TAX                    ;.COPY $FF - T2C_L     STY     XX9128          ; SET VIA 2 T2C_L TO $FF    7 STY     XX9129          ; SET VIA 2 T2C_H TO $FF     TYA                    ;.$FF     SBC     XXB1          ; SUBTRACT TAPE TIMING CONSTANT MAX BYTE                         ; A = $FF - T2C_H     STX     XXB1          ; SAVE TAPE TIMING CONSTANT MAX 7BYTE                         ; XXB1 = $FF - T2C_L     LSR A                  ;.A = $FF - T2C_H >> 1     ROR     XXB1          ; SHIFT TAPE TIMING CONSTANT MAX BYTE                         ; XXB1 = $FF - T2C_L >> 1     LSR A                  ;.A = $F7F - T2C_H >> 1     ROR     XXB1          ; SHIFT TAPE TIMING CONSTANT MAX BYTE                         ; XXB1 = $FF - T2C_L >> 1     LDA     XXB0          ; GET TAPE TIMING CONSTANT MIN BYTE     CLC                    ; CLEAR CARRY FOR ADD     ADC  7   #$3C               ;.     BIT     XX9121          ; TEST VIA 2 DRA, KEYBOARD ROW     CMP     XXB1          ; COMPARE WITH TAPE TIMING CONSTANT MAX BYTE                         ; COMPARE WITH ($FFFF - T2C) >> 2     BCS     XXFA06          ;.BRANCH 7IF MIN + $3C >= ($FFFF - T2C) >> 2                         ;.MIN + $3C < ($FFFF - T2C) >> 2     LDX     XX9C          ;.GET BYTE RECEIVED FLAG     BEQ     XXF9C3          ;.BRANCH IF NOT BYTE RECEIVED     JMP     XXFAAD          ;.STORE TAPE CHARAC7TERXXF9C3 = *     LDX     XXA3          ;.GET EOI FLAG BYTE     BMI     XXF9E2          ;.     LDX     #$00               ;.     ADC     #$30               ;.     ADC     XXB0          ; ADD TAPE TIMING CONSTANT MIN BYTE     CMP     XXB1        7  ; COMPARE WITH TAPE TIMING CONSTANT MAX BYTE     BCS     XXF9ED          ;.     INX                    ;.     ADC     #$26               ;.     ADC     XXB0          ; ADD TAPE TIMING CONSTANT MIN BYTE     CMP     XXB1          ; COMPARE WITH TAP7	E TIMING CONSTANT MAX BYTE     BCS     XXF9F1          ;.     ADC     #$2C               ;.     ADC     XXB0          ; ADD TAPE TIMING CONSTANT MIN BYTE     CMP     XXB1          ; COMPARE WITH TAPE TIMING CONSTANT MAX BYTE     BCC     XXF9E5     7
     ;.XXF9E2 = *     JMP     XXFA60          ;.XXF9E5 = *     LDA     XXB4          ; GET BIT COUNT     BEQ     XXFA06          ; BRANCH IF ZERO     STA     XXA8          ; SAVE RECEIVER BIT COUNT IN     BNE     XXFA06          ; BRANCH ALWAYS7XXF9ED = *     INC     XXA9          ; INCREMENT ?? START BIT CHECK FLAG     BCS     XXF9F3          ;.XXF9F1 = *     DEC     XXA9          ; DECREMENT ?? START BIT CHECK FLAGXXF9F3 = *     SEC                    ;.     SBC     #$13            7   ;.     SBC     XXB1          ; SUBTRACT TAPE TIMING CONSTANT MAX BYTE     ADC     XX92          ; ADD TIMING CONSTANT FOR TAPE     STA     XX92          ; SAVE TIMING CONSTANT FOR TAPE     LDA     XXA4          ;.GET TAPE BIT CYCLE PHASE     EOR 7    #$01               ;.     STA     XXA4          ;.SAVE TAPE BIT CYCLE PHASE     BEQ     XXFA25          ;.     STX     XXD7          ;.XXFA06 = *     LDA     XXB4          ; GET BIT COUNT     BEQ     XXFA22          ; EXIT IF ZERO     BIT   7  XX912D          ; TEST GET 2 IFR     BVC     XXFA22          ; EXIT IF NO T1 INTERRUPT     LDA     #$00               ;.     STA     XXA4          ; CLEAR TAPE BIT CYCLE PHASE     LDA     XXA3          ;.GET EOI FLAG BYTE     BPL     XXFA47      7    ;.     BMI     XXF9E2          ;.XXFA19 = *     LDX     #$A6               ; SET TIMIMG MAX BYTE     JSR     XXF95D          ; SET TIMING     LDA     XX9B          ;.     BNE     XXF9E5          ;.XXFA22 = *     JMP     XXFF56          ; RE7STORE REGISTERS AND EXIT INTERRUPTXXFA25 = *     LDA     XX92          ; GET TIMING CONSTANT FOR TAPE     BEQ     XXFA30          ;.     BMI     XXFA2E          ;.     DEC     XXB0          ; DECREMENT TAPE TIMING CONSTANT MIN BYTE     .BYTE    7 $2C               ; MAKES NEXT LINE BIT XXB0E6XXFA2E = *     INC     XXB0          ; INCREMENT TAPE TIMING CONSTANT MIN BYTEXXFA30 = *     LDA     #$00               ;.     STA     XX92          ; CLEAR TIMING CONSTANT FOR TAPE     CPX     XXD7   7       ;.     BNE     XXFA47          ;.     TXA                    ;.     BNE     XXF9E5          ;.     LDA     XXA9          ; GET START BIT CHECK FLAG     BMI     XXFA06          ;.     CMP     #$10               ;.     BCC     XXFA06      7    ;.     STA     XX96          ;.SAVE CASSETTE BLOCK SYNCHRONIZATION NUMBER     BCS     XXFA06          ;.XXFA47 = *     TXA     EOR     XX9B          ;.     STA     XX9B          ;.     LDA     XXB4          ;.     BEQ     XXFA22          ;.7     DEC     XXA3          ;.DECREMENT EOI FLAG BYTE     BMI     XXFA19          ;.     LSR     XXD7          ;.     ROR     XXBF          ;.PARITY COUNT     LDX     #$DA               ; SET TIMIMG MAX BYTE     JSR     XXF95D          ; SET TIMIN7G     JMP     XXFF56          ; RESTORE REGISTERS AND EXIT INTERRUPTXXFA60 = *     LDA     XX96          ;.GET CASSETTE BLOCK SYNCHRONIZATION NUMBER     BEQ     XXFA68          ;.     LDA     XXB4          ;.     BEQ     XXFA6C          ;.XXFA678 = *     LDA     XXA3          ;.GET EOI FLAG BYTE     BPL     XXF9F1          ;.XXFA6C = *     LSR     XXB1          ; SHIFT TAPE TIMING CONSTANT MAX BYTE     LDA     #$93               ;.     SEC                    ;.     SBC     XXB1         7 ; SUBTRACT TAPE TIMING CONSTANT MAX BYTE     ADC     XXB0          ; ADD TAPE TIMING CONSTANT MIN BYTE     ASL A                  ;.     TAX                    ; COPY TIMIMG HIGH BYTE     JSR     XXF95D          ; SET TIMING     INC     XX9C       7   ;.     LDA     XXB4          ;.     BNE     XXFA91          ;.     LDA     XX96          ;.GET CASSETTE BLOCK SYNCHRONIZATION NUMBER     BEQ     XXFAAA          ;.     STA     XXA8          ; SAVE RECEIVER BIT COUNT IN     LDA     #$00        7       ;.     STA     XX96          ;.CLEAR CASSETTE BLOCK SYNCHRONIZATION NUMBER     LDA     #$C0               ; ENABLE T1 INTERRUPT     STA     XX912E          ; SET VIA 2 IER     STA     XXB4          ;.XXFA91 = *     LDA     XX96          ;.GE7T CASSETTE BLOCK SYNCHRONIZATION NUMBER     STA     XXB5          ;.     BEQ     XXFAA0          ;.     LDA     #$00               ;.     STA     XXB4          ;.     LDA     #$40               ; DISABLE T1 INTERRUPT     STA     XX912E          ; 7SET VIA 2 IERXXFAA0 = *     LDA     XXBF          ;.PARITY COUNT     STA     XXBD          ;.SAVE RS232 PARITY BYTE     LDA     XXA8          ; GET RECEIVER BIT COUNT IN     ORA     XXA9          ; OR WITH START BIT CHECK FLAG     STA     XXB6     7     ;.XXFAAA = *     JMP     XXFF56          ; RESTORE REGISTERS AND EXIT INTERRUPT;***********************************************************************************;;;## STORE CHARACTERXXFAAD = *     JSR     XXFBDB          ; NEW TAPE BYTE 7SETUP     STA     XX9C          ; CLEAR BYTE RECEIVED FLAG     LDX     #$DA               ; SET TIMIMG MAX BYTE     JSR     XXF95D          ; SET TIMING     LDA     XXBE          ;.GET COPIES COUNT     BEQ     XXFABD          ;.     STA     XXA7  7        ; SAVE RECEIVER INPUT BIT TEMPORARY STORAGEXXFABD = *     LDA     #$0F               ;.     BIT     XXAA          ;.     BPL     XXFADA          ;.     LDA     XXB5          ;.     BNE     XXFAD3          ;.     LDX     XXBE          ;.G7ET COPIES COUNT     DEX                    ;.     BNE     XXFAD7          ; IF ?? RESTORE REGISTERS AND EXIT INTERRUPT     LDA     #$08               ; SET SHORT BLOCK     JSR     XXFE6A          ; OR INTO SERIAL STATUS BYTE     BNE     XXFAD7     7      ; RESTORE REGISTERS AND EXIT INTERRUPT, BRANCH ALWAYSXXFAD3 = *     LDA     #$00               ;.     STA     XXAA          ;.XXFAD7 = *     JMP     XXFF56          ; RESTORE REGISTERS AND EXIT INTERRUPTXXFADA = *     BVS     XXFB0D        7!  ;.     BNE     XXFAF6          ;.     LDA     XXB5          ;.     BNE     XXFAD7          ;.     LDA     XXB6          ;.     BNE     XXFAD7          ;.     LDA     XXA7          ; GET RECEIVER INPUT BIT TEMPORARY STORAGE     LSR A         7"         ;.     LDA     XXBD          ;.GET RS232 PARITY BYTE     BMI     XXFAF0          ;.     BCC     XXFB07          ;.     CLC                    ;.XXFAF0 = *     BCS     XXFB07          ;.     AND     #$0F               ;.     STA     XX7#AA          ;.XXFAF6 = *     DEC     XXAA          ;.     BNE     XXFAD7          ;.     LDA     #$40               ;.     STA     XXAA          ;.     JSR     XXFBD2          ; COPY I/O START ADDRESS TO BUFFER ADDRESS     LDA     #$00           7$    ;.     STA     XXAB          ;.     BEQ     XXFAD7          ;., BRANCH ALWAYS;***********************************************************************************;;;## RESET POINTERXXFB07 = *     LDA     #$80               ;.     STA     XX7%AA          ;.     BNE     XXFAD7          ; RESTORE REGISTERS AND EXIT INTERRUPT, BRANCH ALWAYSXXFB0D = *     LDA     XXB5          ;.     BEQ     XXFB1B          ;.     LDA     #$04               ;.     JSR     XXFE6A          ; OR INTO SERIAL 7&STATUS BYTE     LDA     #$00               ;.     JMP     XXFB97          ;.XXFB1B = *     JSR     XXFD11          ; CHECK READ/WRITE POINTER, RETURN CB = 1 IF POINTER >= END     BCC     XXFB23          ;.     JMP     XXFB95          ;.XXFB23 =7' *     LDX     XXA7          ; GET RECEIVER INPUT BIT TEMPORARY STORAGE     DEX                    ;.     BEQ     XXFB55          ;.     LDA     XX93          ; GET LOAD/VERIFY FLAG     BEQ     XXFB38          ; BRANCH IF LOAD     LDY     #$00   8             ; CLEAR INDEX     LDA     XXBD          ;.GET RS232 PARITY BYTE     CMP     (XXAC),Y          ;.     BEQ     XXFB38          ;.     LDA     #$01               ;.     STA     XXB6          ;.XXFB38 = *     LDA     XXB6          ;.    8 BEQ     XXFB87          ;.     LDX     #$3D               ;.     CPX     XX9E          ;.     BCC     XXFB80          ;.     LDX     XX9E          ;.     LDA     XXAD          ;.     STA     XX0100+1,X     ;.     LDA     XXAC          ;.     S8TA     XX0100,X          ;.     INX                    ;.     INX                    ;.     STX     XX9E          ;.     JMP     XXFB87          ;.XXFB55 = *     LDX     XX9F          ;.     CPX     XX9E          ;.     BEQ     XXFB90          ;8.     LDA     XXAC          ;.     CMP     XX0100,X          ;.     BNE     XXFB90          ;.     LDA     XXAD          ;.     CMP     XX0100+1,X     ;.     BNE     XXFB90          ;.     INC     XX9F          ;.     INC     XX9F          ;.8     LDA     XX93          ; GET LOAD/VERIFY FLAG     BEQ     XXFB7C          ; BRANCH IF LOAD     LDA     XXBD          ;.GET RS232 PARITY BYTE     LDY     #$00               ;.     CMP     (XXAC),Y          ;.     BEQ     XXFB90          ;.    8 INY                    ;.     STY     XXB6          ;.XXFB7C = *     LDA     XXB6          ;.     BEQ     XXFB87          ;.XXFB80 = *     LDA     #$10               ;.     JSR     XXFE6A          ; OR INTO SERIAL STATUS BYTE     BNE     XXFB908          ;.XXFB87 = *     LDA     XX93          ; GET LOAD/VERIFY FLAG     BNE     XXFB90          ; BRANCH IF VERIFY     TAY                    ;.     LDA     XXBD          ;.GET RS232 PARITY BYTE     STA     (XXAC),Y          ;.XXFB90 = *   8  JSR     XXFD1B          ; INCREMENT READ/WRITE POINTER     BNE     XXFBCF          ; RESTORE REGISTERS AND EXIT INTERRUPT, BRANCH ALWAYSXXFB95 = *     LDA     #$80               ;.XXFB97 = *     STA     XXAA          ;.     LDX     XXBE         8 ;.GET COPIES COUNT     DEX                    ;.     BMI     XXFBA0          ;.     STX     XXBE          ;.SAVE COPIES COUNTXXFBA0 = *     DEC     XXA7          ; DECREMENT RECEIVER INPUT BIT TEMPORARY STORAGE     BEQ     XXFBAC          ;.   8	  LDA     XX9E          ;.     BNE     XXFBCF          ; IF ?? RESTORE REGISTERS AND EXIT INTERRUPT     STA     XXBE          ;.SAVE COPIES COUNT     BEQ     XXFBCF          ; RESTORE REGISTERS AND EXIT INTERRUPT, BRANCH ALWAYSXXFBAC = *     JSR  8
   XXFCCF          ; RESTORE EVERYTHING FOR STOP     JSR     XXFBD2          ; COPY I/O START ADDRESS TO BUFFER ADDRESS     LDY     #$00               ; CLEAR INDEX     STY     XXAB          ; CLEAR CHECKSUMXXFBB6 = *     LDA     (XXAC),Y          ;8 GET BYTE FROM BUFFER     EOR     XXAB          ; XOR WITH CHECKSUM     STA     XXAB          ; SAVE NEW CHECKSUM     JSR     XXFD1B          ; INCREMENT READ/WRITE POINTER     JSR     XXFD11          ; CHECK READ/WRITE POINTER, RETURN CB = 1 IF POIN8TER >= END     BCC     XXFBB6          ; LOOP IF NOT AT END     LDA     XXAB          ; GET COMPUTED CHECKSUM     EOR     XXBD          ; COMPARE WITH STORED CHECKSUM ??     BEQ     XXFBCF          ; IF CHECKSUM OK RESTORE REGISTERS AND EXIT INTERRU8PT     LDA     #$20               ; ELSE SET CHECKSUM ERROR     JSR     XXFE6A          ; OR INTO SERIAL STATUS BYTEXXFBCF = *     JMP     XXFF56          ; RESTORE REGISTERS AND EXIT INTERRUPT;****************************************************8*******************************;;; COPY I/O START ADDRESS TO BUFFER ADDRESSXXFBD2 = *     LDA     XXC2          ; GET I/O START ADDRESS HIGH BYTE     STA     XXAD          ; SET BUFFER ADDRESS HIGH BYTE     LDA     XXC1          ; GET I/O START AD8DRESS LOW BYTE     STA     XXAC          ; SET BUFFER ADDRESS LOW BYTE     RTS;***********************************************************************************;;; NEW TAPE BYTE SETUPXXFBDB = *     LDA     #$08               ; EIGHT BITS TO D8O     STA     XXA3          ; SET BIT COUNT     LDA     #$00               ; CLEAR A     STA     XXA4          ; CLEAR TAPE BIT CYCLE PHASE     STA     XXA8          ; CLEAR START BIT FIRST CYCLE DONE FLAG     STA     XX9B          ; CLEAR BYTE PARI8TY     STA     XXA9          ; CLEAR START BIT CHECK FLAG, SET NO START BIT YET     RTS;***********************************************************************************;;; SEND LSB FROM TAPE WRITE BYTE TO TAPE; THIS ROUTINE TESTS THE LEAST SI8GNIFICANT BIT IN THE TAPE WRITE BYTE AND SETS VIA 2 T2; DEPENDING ON THE STATE OF THE BIT. IF THE BIT IS A 1 A TIME OF $00B0 CYCLES IS SET, IF; THE BOT IS A 0 A TIME OF $0060 CYCLES IS SET. NOTE THAT THIS ROUTINE DOES NOT SHIFT THE; BITS OF THE TAPE W8RITE BYTE BUT USES A COPY OF THAT BYTE, THE BYTE ITSELF IS SHIFTED; ELSEWHEREXXFBEA = *     LDA     XXBD          ; GET TAPE WRITE BYTE     LSR A                  ; SHIFT LSB INTO CB     LDA     #$60               ; SET TIME CONSTANT LOW BYTE FOR B8IT = 0     BCC     XXFBF3          ; BRANCH IF BIT WAS 0; SET TIME CONSTANT FOR BIT = 1 AND TOGGLE TAPEXXFBF1 = *     LDA     #$B0               ; SET TIME CONSTANT LOW BYTE FOR BIT = 1; WRITE TIME CONSTANT AND TOGGLE TAPEXXFBF3 = *     LDX   8  #$00               ; SET TIME CONSTANT HIGH BYTE; WRITE TIME CONSTANT AND TOGGLE TAPEXXFBF5 = *     STA     XX9128          ; SET VIA 2 T2C_L     STX     XX9129          ; SET VIA 2 T2C_H     LDA     XX9120          ; GET VIA 2 DRB, KEYBOARD COL8UMN     EOR     #$08               ; TOGGLE TAPE OUT BIT     STA     XX9120          ; SET VIA 2 DRB     AND     #$08               ; MASK TAPE OUT BIT     RTS;***********************************************************************************;;8; FLAG BLOCK DONE AND EXIT INTERRUPTXXFC06 = *     SEC                    ; SET CARRY FLAG     ROR     XXAD          ; SET BUFFER ADDRESS HIGH BYTE NEGATIVE, FLAG ALL SYNC,                         ; DATA AND CHECKSUM BYTES WRITTEN     BMI     XXFC487          ; RESTORE REGISTERS AND EXIT INTERRUPT, BRANCH ALWAYS;***********************************************************************************;;; TAPE WRITE, IRQ ROUTINE.; THIS IS THE ROUTINE THAT WRITES THE BITS TO THE TAPE. IT IS CALLED EA8CH TIME VIA 2 T2; TIMES OUT AND CHECKS IF THE START BIT IS DONE, IF SO CHECKS IF THE DATA BITS ARE DONE,; IF SO IT CHECKS IF THE BYTE IS DONE, IF SO IT CHECKS IF THE SYNCHRONISATION BYTES ARE; DONE, IF SO IT CHECKS IF THE DATA BYTES ARE DONE, IF SO IT8 CHECKS IF THE CHECKSUM BYTE; IS DONE, IF SO IT CHECKS IF BOTH THE LOAD AND VERIFY COPIES HAVE BEEN DONE, IF SO IT; STOPS THE TAPEXXFC0B = *     LDA     XXA8          ; GET START BIT FIRST CYCLE DONE FLAG     BNE     XXFC21          ; IF FIRST CYCL8E DONE GO DO REST OF BYTE; EACH BYTE SENT STARTS WITH TWO HALF CYCLES OF $0110 STSTEM CLOCKS AND THE WHOLE BLOCK; ENDS WITH TWO MORE SUCH HALF CYCLES     LDA     #$10               ; SET FIRST START CYCLE TIME CONSTANT LOW BYTE     LDX     #$01    8           ; SET FIRST START CYCLE TIME CONSTANT HIGH BYTE     JSR     XXFBF5          ; WRITE TIME CONSTANT AND TOGGLE TAPE     BNE     XXFC47          ; IF FIRST HALF CYCLE GO RESTORE REGISTERS AND EXIT                         ; INTERRUPT     INC 8    XXA8          ; SET START BIT FIRST START CYCLE DONE FLAG     LDA     XXAD          ; GET BUFFER ADDRESS HIGH BYTE     BPL     XXFC47          ; IF BLOCK NOT COMPLETE GO RESTORE REGISTERS AND EXIT                         ; INTERRUPT. THE END OF A 8BLOCK IS INDICATED BY THE TAPE                         ; BUFFER HIGH BYTE B7 BEING SET TO 1     JMP     XXFC95          ; ELSE DO TAPE ROUTINE, BLOCK COMPLETE EXIT; CONTINUE TAPE BYTE WRITE. THE FIRST START CYCLE, BOTH HALF CYCLES OF IT, IS COMPLETE8; SO THE ROUTINE DROPS STRAIGHT THROUGH TO HEREXXFC21 = *     LDA     XXA9          ; GET START BIT CHECK FLAG     BNE     XXFC2E          ; IF THE START BIT IS COMPLETE GO SEND THE BYTE BITS; AFTER THE TWO HALF CYCLES OF $0110 STSTEM CLOCKS THE S8 TART BIT IS COMPLETED WITH TWO; HALF CYCLES OF $00B0 SYSTEM CLOCKS. THIS IS THE SAME AS THE FIRST PART OF A 1 BIT     JSR     XXFBF1          ; SET TIME CONSTANT FOR BIT = 1 AND TOGGLE TAPE     BNE     XXFC47          ; IF FIRST HALF CYCLE GO RESTORE8! REGISTERS AND EXIT                         ; INTERRUPT     INC     XXA9          ; SET START BIT CHECK FLAG     BNE     XXFC47          ; RESTORE REGISTERS AND EXIT INTERRUPT, BRANCH ALWAYS; CONTINUE TAPE BYTE WRITE. THE START BIT, BOTH CYCLES OF 8"IT, IS COMPLETE SO THE ROUTINE; DROPS STRAIGHT THROUGH TO HERE. NOW THE CYCLE PAIRS FOR EACH BIT, AND THE PARITY BIT,; ARE SENTXXFC2E = *     JSR     XXFBEA          ; SEND LSB FROM TAPE WRITE BYTE TO TAPE     BNE     XXFC47          ; IF FIRST HAL8#F CYCLE GO RESTORE REGISTERS AND EXIT                         ; INTERRUPT                         ; ELSE TWO HALF CYCLES HAVE BEEN DONE     LDA     XXA4          ; GET TAPE BIT CYCLE PHASE     EOR     #$01               ; TOGGLE B0     STA     XXA48$          ; SAVE TAPE BIT CYCLE PHASE     BEQ     XXFC4A          ; IF BIT CYCLE PHASE COMPLETE GO SETUP FOR NEXT BIT; EACH BIT IS WRITTEN AS TWO FULL CYCLES. A 1 IS SENT AS A FULL CYCLE OF $0160 SYSTEM; CLOCKS THEN A FULL CYCLE OF $00C0 SYSTEM CLOCK8%S. A 0 IS SENT AS A FULL CYCLE OF $00C0; SYSTEM CLOCKS THEN A FULL CYCLE OF $0160 SYSTEM CLOCKS. TO DO THIS EACH BIT FROM THE; WRITE BYTE IS INVERTED DURING THE SECOND BIT CYCLE PHASE. AS THE BIT IS INVERTED IT; IS ALSO ADDED TO THE, ONE BIT, PARITY C8&OUNT FOR THIS BYTE     LDA     XXBD          ; GET TAPE WRITE BYTE     EOR     #$01               ; INVERT BIT BEING SENT     STA     XXBD          ; SAVE TAPE WRITE BYTE     AND     #$01               ; MASK B0     EOR     XX9B          ; EOR WITH8' TAPE WRITE BYTE PARITY BIT     STA     XX9B          ; SAVE TAPE WRITE BYTE PARITY BITXXFC47 = *     JMP     XXFF56          ; RESTORE REGISTERS AND EXIT INTERRUPT; THE BIT CYCLE PHASE IS COMPLETE SO SHIFT OUT THE JUST WRITTEN BIT AND TEST FOR BYTE9 ; ENDXXFC4A = *     LSR     XXBD          ; SHIFT BIT OUT OF TAPE WRITE BYTE     DEC     XXA3          ; DECREMENT TAPE WRITE BIT COUNT     LDA     XXA3          ; GET TAPE WRITE BIT COUNT     BEQ     XXFC8C          ; IF ALL THE DATA BITS HAVE BE9EN WRITTEN GO SETUP FOR                         ; SENDING THE PARITY BIT NEXT AND EXIT THE INTERRUPT     BPL     XXFC47          ; IF ALL THE DATA BITS ARE NOT YET SENT JUST RESTORE THE                         ; REGISTERS AND EXIT THE INTERRUPT; DO9 NEXT TAPE BYTE; THE BYTE IS COMPLETE. THE START BIT, DATA BITS AND PARITY BIT HAVE BEEN WRITTEN TO; THE TAPE SO SETUP FOR THE NEXT BYTEXXFC54 = *     JSR     XXFBDB          ; NEW TAPE BYTE SETUP     CLI                    ; ENABLE INTERRUPTS   9  LDA     XXA5          ; GET CASSETTE SYNCHRONIZATION CHARACTER COUNT     BEQ     XXFC6E          ; IF SYNCHRONISATION CHARACTERS DONE GO DO BLOCK DATA; AT THE START OF EACH BLOCK SENT TO TAPE THERE ARE A NUMBER OF SYNCHRONISATION BYTES; THAT COUNT 9DOWN TO THE ACTUAL DATA. THE COMMODORE TAPE SYSTEM SAVES TWO COPIES OF ALL; THE TAPE DATA, THE FIRST IS LOADED AND IS INDICATED BY THE SYNCHRONISATION BYTES; HAVING B7 SET, AND THE SECOND COPY IS INDICATED BY THE SYNCHRONISATION BYTES HAVING B7; CLEAR9. THE SEQUENCE GOES $09, $08, ..... $02, $01, DATA BYTES     LDX     #$00               ; CLEAR X     STX     XXD7          ; CLEAR CHECKSUM BYTE     DEC     XXA5          ; DECREMENT CASSETTE SYNCHRONIZATION BYTE COUNT     LDX     XXBE          ; G9ET CASSETTE COPIES COUNT     CPX     #$02               ; COMPARE WITH LOAD BLOCK INDICATOR     BNE     XXFC6A          ; BRANCH IF NOT THE LOAD BLOCK     ORA     #$80               ; THIS IS THE LOAD BLOCK SO MAKE THE SYNCHRONISATION COUNT         9                ; GO $89, $88, ..... $82, $81XXFC6A = *     STA     XXBD          ; SAVE THE SYNCHRONISATION BYTE AS THE TAPE WRITE BYTE     BNE     XXFC47          ; RESTORE REGISTERS AND EXIT INTERRUPT, BRANCH ALWAYS; THE SYNCHRONIZATION BYTES HAV9E BEEN DONE SO NOW CHECK AND DO THE ACTUAL BLOCK DATAXXFC6E = *     JSR     XXFD11          ; CHECK READ/WRITE POINTER, RETURN CB = 1 IF POINTER >= END     BCC     XXFC7D          ; IF NOT ALL DONE YET GO GET THE BYTE TO SEND     BNE     XXFC06    9	      ; IF POINTER > END GO FLAG BLOCK DONE AND EXIT INTERRUPT                         ; ELSE THE BLOCK IS COMPLETE, IT ONLY REMAINS TO WRITE THE                         ; CHECKSUM BYTE TO THE TAPE SO SETUP FOR THAT     INC     XXAD          ; INCREM9
ENT BUFFER POINTER HIGH BYTE, THIS MEANS THE BLOCK                         ; DONE BRANCH WILL ALWAYS BE TAKEN NEXT TIME WITHOUT HAVING                         ; TO WORRY ABOUT THE LOW BYTE WRAPPING TO ZERO     LDA     XXD7          ; GET CHECKSUM BYTE9     STA     XXBD          ; SAVE CHECKSUM AS TAPE WRITE BYTE     BCS     XXFC47          ; RESTORE REGISTERS AND EXIT INTERRUPT, BRANCH ALWAYS; THE BLOCK ISN'T FINISHED SO GET THE NEXT BYTE TO WRITE TO TAPEXXFC7D = *     LDY     #$00             9  ; CLEAR INDEX     LDA     (XXAC),Y          ; GET BYTE FROM BUFFER     STA     XXBD          ; SAVE AS TAPE WRITE BYTE     EOR     XXD7          ; XOR WITH CHECKSUM BYTE     STA     XXD7          ; SAVE NEW CHECKSUM BYTE     JSR     XXFD1B        9  ; INCREMENT READ/WRITE POINTER     BNE     XXFC47          ; RESTORE REGISTERS AND EXIT INTERRUPT, BRANCH ALWAYS; SET PARITY AS NEXT BIT AND EXIT INTERRUPTXXFC8C = *     LDA     XX9B          ; GET PARITY BIT     EOR     #$01               ; TOG9GLE IT     STA     XXBD          ; SAVE AS TAPE WRITE BYTEXXFC92 = *     JMP     XXFF56          ; RESTORE REGISTERS AND EXIT INTERRUPT; TAPE ROUTINE, BLOCK COMPLETE EXITXXFC95 = *     DEC     XXBE          ; DECREMENT COPIES REMAINING TO READ/WR9ITE     BNE     XXFC9C          ; BRANCH IF MORE TO DO     JSR     XXFD08          ; ELSE STOP CASSETTE MOTORXXFC9C = *     LDA     #$50               ; SET TAPE WRITE LEADER COUNT     STA     XXA7          ; SAVE TAPE WRITE LEADER COUNT     LDX  9   #$08               ; SET INDEX FOR WRITE TAPE LEADER VECTOR     SEI                    ; DISABLE INTERRUPTS     JSR     XXFCFB          ; SET TAPE VECTOR     BNE     XXFC92          ; RESTORE REGISTERS AND EXIT INTERRUPT, BRANCH ALWAYS;*********9**************************************************************************;;; WRITE TAPE LEADER IRQ ROUTINEXXFCA8 = *     LDA     #$78               ; SET TIME CONSTANT LOW BYTE FOR BIT = LEADER     JSR     XXFBF3          ; WRITE TIME CONSTANT AND9 TOGGLE TAPE     BNE     XXFC92          ; IF TAPE BIT HIGH RESTORE REGISTERS AND EXIT INTERRUPT     DEC     XXA7          ; DECREMENT CYCLE COUNT     BNE     XXFC92          ; IF NOT ALL DONE RESTORE REGISTERS AND EXIT INTERRUPT     JSR     XXFBDB9          ; NEW TAPE BYTE SETUP     DEC     XXAB          ; DECREMENT CASSETTE LEADER COUNT     BPL     XXFC92          ; IF NOT ALL DONE RESTORE REGISTERS AND EXIT INTERRUPT     LDX     #$0A               ; SET INDEX FOR TAPE WRITE VECTOR     JSR  9   XXFCFB          ; SET TAPE VECTOR     CLI                    ; ENABLE INTERRUPTS     INC     XXAB          ; CLEAR CASSETTE LEADER COUNTER, WAS $FF     LDA     XXBE          ; GET CASSETTE BLOCK COUNT     BEQ     XXFCF6          ; IF ALL DONE REST9ORE EVERYTHING FOR STOP AND EXIT INTERRUPT     JSR     XXFBD2          ; COPY I/O START ADDRESS TO BUFFER ADDRESS     LDX     #$09               ; SET NINE SYNCHRONISATION BYTES     STX     XXA5          ; SAVE CASSETTE SYNCHRONIZATION BYTE COUNT   9  BNE     XXFC54          ; GO DO NEXT TAPE BYTE, BRANCH ALWAYS;***********************************************************************************;;; RESTORE EVERYTHING FOR STOPXXFCCF = *     PHP                    ; SAVE STATUS     SEI        9            ; DISABLE INTERRUPTS     JSR     XXFD08          ; STOP CASSETTE MOTOR     LDA     #$7F               ; DISABLE ALL INTERRUPTS     STA     XX912E          ; SET VIA 2 IER     LDA     #$F7               ; SET KEYBOARD COLUMN 3 ACTIVE     9STA     XX9120          ; SET VIA 2 DRB, KEYBOARD COLUMN     LDA     #$40               ; SET T1 FREE RUN, T2 CLOCK 2,                         ; SR DISABLED, LATCHES DISABLED     STA     XX912B          ; SET VIA 2 ACR     JSR     XXFE39          ; 9SET 60HZ AND ENABLE TIMER     LDA     XX02A0          ; GET SAVED IRQ VECTOR HIGH BYTE     BEQ     XXFCF4          ; BRANCH IF NULL     STA     XX0315          ; RESTORE IRQ VECTOR HIGH BYTE     LDA     XX029F          ; GET SAVED IRQ VECTOR LOW BYT9E     STA     XX0314          ; RESTORE IRQ VECTOR LOW BYTEXXFCF4 = *     PLP                    ; RESTORE STATUS     RTS;***********************************************************************************;;; RESET VECTORXXFCF6 = *     JSR   9  XXFCCF          ; RESTORE EVERYTHING FOR STOP     BEQ     XXFC92          ; RESTORE REGISTERS AND EXIT INTERRUPT, BRANCH ALWAYS;***********************************************************************************;;; SET TAPE VECTORXXFCFB = *   9  LDA     XXFDF1-8,X     ; GET TAPE IRQ VECTOR LOW BYTE     STA     XX0314          ; SET IRQ VECTOR LOW BYTE     LDA     XXFDF1-7,X     ; GET TAPE IRQ VECTOR HIGH BYTE     STA     XX0315          ; SET IRQ VECTOR HIGH BYTE     RTS;***************9********************************************************************;;; STOP CASSETTE MOTORXXFD08 = *     LDA     XX911C          ; GET VIA 1 PCR     ORA     #$0E               ; SET CA2 HIGH, CASSETTE MOTOR OFF     STA     XX911C          ; SET V9IA 1 PCR     RTS;***********************************************************************************;;; CHECK READ/WRITE POINTER; RETURN CB = 1 IF POINTER >= ENDXXFD11 = *     SEC                    ; SET CARRY FOR SUBTRACT     LDA     XXAC   9       ; GET BUFFER ADDRESS LOW BYTE     SBC     XXAE          ; SUBTRACT BUFFER END LOW BYTE     LDA     XXAD          ; GET BUFFER ADDRESS HIGH BYTE     SBC     XXAF          ; SUBTRACT BUFFER END HIGH BYTE     RTS;******************************9 *****************************************************;;; INCREMENT READ/WRITE POINTERXXFD1B = *     INC     XXAC          ; INCREMENT BUFFER ADDRESS LOW BYTE     BNE     XXFD21          ; IF NO OVERFLOW SKIP THE HIGH BYTE INCREMENT     INC     XX9!AD          ; INCREMENT BUFFER ADDRESS HIGH BYTEXXFD21 = *     RTS;***********************************************************************************;;; RESET, HARDWARE RESET STARTS HEREXXFD22 = *     LDX     #$FF               ; SET X FOR STA9"CK     SEI                    ; DISABLE INTERRUPTS     TXS                    ; CLEAR STACK     CLD                    ; CLEAR DECIMAL MODE     JSR     XXFD3F          ; SCAN FOR AUTOSTART ROM AT $A000     BNE     XXFD2F          ; IF NOT THERE CONT9#INUE VIC STARTUP     JMP     (XXA000)          ; CALL ROM START CODEXXFD2F = *     JSR     XXFD8D          ; INITIALISE AND TEST RAM     JSR     XXFD52          ; RESTORE DEFAULT I/O VECTORS     JSR     XXFDF9          ; INITIALIZE I/O REGISTERS 9$    JSR     XXE518          ; INITIALISE HARDWARE     CLI                    ; ENABLE INTERRUPTS     JMP     (XXC000)          ; EXECUTE BASIC;***********************************************************************************;;; SCAN FOR AUTOSTAR9%T ROM AT $A000, RETURNS ZB=1 IF ROM FOUNDXXFD3F = *     LDX     #$05               ; FIVE CHARACTERS TO TESTXXFD41 = *     LDA     XXFD4D-1,X     ; GET TEST CHARACTER     CMP     XXA004-1,X     ; COMPARE WIITH BYTE IN ROM SPACE     BNE     XXFD4C 9&         ; EXIT IF NO MATCH     DEX                    ; DECREMENT INDEX     BNE     XXFD41          ; LOOP IF NOT ALL DONEXXFD4C = *     RTS;***********************************************************************************;;; AUTOSTART ROM 9'SIGNATUREXXFD4D = *     .BYTE     'A0',$C3,$C2,$CD     ; A0CBM;***********************************************************************************;;; RESTORE DEFAULT I/O VECTORS; THIS ROUTINE RESTORES THE DEFAULT VALUES OF ALL SYSTEM VECTORS US: ED IN KERNAL AND; BASIC ROUTINES AND INTERRUPTS. THE KERNAL VECTOR ROUTINE IS USED TO READ AND ALTER; INDIVIDUAL SYSTEM VECTORS.XXFD52 = *     LDX     #<XXFD6D          ; POINTER TO VECTOR TABLE LOW BYTE     LDY     #>XXFD6D          ; POINTER TO V:ECTOR TABLE HIGH BYTE     CLC                    ; FLAG SET VECTORS;***********************************************************************************;;; SET/READ VECTORED I/O FROM (XY), CB = 1 TO READ, CB = 0 TO SET; THIS ROUTINE MANAGES ALL SY:STEM VECTOR JUMP ADDRESSES STORED IN RAM. CALLING THIS; ROUTINE WITH THE ACCUMULATOR CARRY BIT SET WILL STORE THE CURRENT CONTENTS OF THE; RAM VECTORS IN A LIST POINTED TO BY THE X AND Y REGISTERS.; WHEN THIS ROUTINE IS CALLED WITH THE CARRY BIT CLEA:R, THE USER LIST POINTED TO BY; THE X AND Y REGISTERS IS TRANSFERRED TO THE SYSTEM RAM VECTORS.; NOTE: THIS ROUTINE REQUIRES CAUTION IN ITS USE. THE BEST WAY TO USE IT IS TO FIRST; READ THE ENTIRE VECTOR CONTENTS INTO THE USER AREA, ALTER THE DESIRED: VECTORS, AND; THEN COPY THE CONTENTS BACK TO THE SYSTEM VECTORS.XXFD57 = *     STX     XXC3          ; SAVE POINTER LOW BYTE     STY     XXC4          ; SAVE POINTER HIGH BYTE     LDY     #$1F               ; SET BYTE COUNTXXFD5D = *     LDA    : XX0314,Y          ; READ VECTOR BYTE FROM VECTORS     BCS     XXFD64          ; IF READ VECTORS SKIP THE READ FROM XY     LDA     (XXC3),Y          ; READ VECTOR BYTE FROM (XY)XXFD64 = *     STA     (XXC3),Y          ; SAVE BYTE TO (XY)     STA   :  XX0314,Y          ; SAVE BYTE TO VECTOR     DEY                    ; DECREMENT INDEX     BPL     XXFD5D          ; LOOP IF MORE TO DO     RTS;; THE ABOVE CODE WORKS BUT IT TRIES TO WRITE TO THE ROM. WHILE THIS IS USUALLY HARMLESS;; SYSTEMS THAT :USE FLASH ROM MAY SUFFER. HERE IS A VERSION THAT MAKES THE EXTRA WRITE;; TO RAM INSTEAD BUT IS OTHERWISE IDENTICAL IN FUNCTION. ##;;; SET/READ VECTORED I/O FROM (XY), CB = 1 TO READ, CB = 0 TO SET;;XXFD57;     STX     XXC3          ; SAVE POINTER L:OW BYTE;     STY     XXC4          ; SAVE POINTER HIGH BYTE;     LDY     #$1F               ; SET BYTE COUNT;XXFD5D;     LDA     (XXC3),Y          ; READ VECTOR BYTE FROM (XY);     BCC     XXFD66          ; IF SET VECTORS SKIP THE READ FROM XY;;  :	   LDA     XX0314,Y          ; ELSE READ VECTOR BYTE FROM VECTORS;     STA     (XXC3),Y          ; SAVE BYTE TO (XY);XXFD66;     STA     XX0314,Y          ; SAVE BYTE TO VECTOR;     DEY                    ; DECREMENT INDEX;     BPL     XXFD5D       :
   ; LOOP IF MORE TO DO;;     RTS;***********************************************************************************;;; KERNAL VECTORSXXFD6D = *     .WORD     XXEABF          ; XX0314     IRQ VECTOR     .WORD     XXFED2          ; XX0316     :BRK VECTOR     .WORD     XXFEAD          ; XX0318     NMI VECTOR     .WORD     XXF40A          ; XX031A     OPEN A LOGICAL FILE     .WORD     XXF34A          ; XX031C     CLOSE A SPECIFIED LOGICAL FILE     .WORD     XXF2C7          ; XX031E     OPEN :CHANNEL FOR INPUT     .WORD     XXF309          ; XX0320     OPEN CHANNEL FOR OUTPUT     .WORD     XXF3F3          ; XX0322     CLOSE INPUT AND OUTPUT CHANNELS     .WORD     XXF20E          ; XX0324     INPUT CHARACTER FROM CHANNEL     .WORD     XXF2:7A          ; XX0326     OUTPUT CHARACTER TO CHANNEL     .WORD     XXF770          ; XX0328     SCAN STOP KEY     .WORD     XXF1F5          ; XX032A     GET CHARACTER FROM KEYBOARD QUEUE     .WORD     XXF3EF          ; XX032C     CLOSE ALL CHANNELS AN:D FILES     .WORD     XXFED2          ; XX032E     USER FUNCTION; VECTOR TO USER DEFINED COMMAND, CURRENTLY POINTS TO BRK.; THIS APPEARS TO BE A HOLDOVER FROM PET DAYS, WHEN THE BUILT-IN MACHINE LANGUAGE MONITOR; WOULD JUMP THROUGH THE XX032E VECTO:R WHEN IT ENCOUNTERED A COMMAND THAT IT DID NOT; UNDERSTAND, ALLOWING THE USER TO ADD NEW COMMANDS TO THE MONITOR.; ALTHOUGH THIS VECTOR IS INITIALIZED TO POINT TO THE ROUTINE CALLED BY STOP/RESTORE AND; THE BRK INTERRUPT, AND IS UPDATED BY THE KERNA:L VECTOR ROUTINE AT $FD57, IT NO LONGER; HAS ANY FUNCTION.     .WORD     XXF549          ; XX0330     LOAD     .WORD     XXF685          ; XX0332     SAVE;***********************************************************************************;;; INI:TIALISE AND TEST RAM, THE RAM FROM $000 TO $03FF IS NEVER TESTED AND IS JUST ASSUMED; TO WORK. FIRST A SEARCH IS DONE FROM $0401 FOR THE START OF MEMORY AND THIS IS SAVED, IF; THIS START IS AT OR BEYOND $1100 THEN THE ROUTINE DEAD ENDS. ONCE THE START :OF MEMORY IS; FOUND THE ROUTINE LOOKS FOR THE END OF MEMORY, IF THIS END IS BEFORE $2000 THE ROUTINE; AGAIN DEAD ENDS. LASTLY, IF THE END OF MEMORY IS AT $2000 THEN THE SCREEN IS SET TO; $1E00, BUT IF THE MEMORY EXTENDS TO OR BEYOND $2100 THEN THE SCR:EEN IS MOVED TO $1000XXFD8D = *     LDA     #$00               ; CLEAR A     TAX                    ; CLEAR INDEXXXFD90 = *     STA     XX00,X          ; CLEAR PAGE 0     STA     XX0200,X          ; CLEAR PAGE 2     STA     XX0300,X          ; CL:EAR PAGE 3     INX                    ; INCREMENT INDEX     BNE     XXFD90          ; LOOP IF MORE TO DO     LDX     #<XX033C          ; SET CASSETTE BUFFER POINTER LOW BYTE     LDY     #>XX033C          ; SET CASSETTE BUFFER POINTER HIGH BYTE     :STX     XXB2          ; SAVE TAPE BUFFER START POINTER LOW BYTE     STY     XXB3          ; SAVE TAPE BUFFER START POINTER HIGH BYTE     STA     XXC1          ; CLEAR RAM TEST POINTER LOW BYTE     STA     XX97          ; CLEAR LOOKING FOR END FLAG  :   STA     XX0281          ; CLEAR OS START OF MEMORY LOW BYTE     TAY                    ; CLEAR Y     LDA     #$04               ; SET RAM TEST POINTER HIGH BYTE     STA     XXC2          ; SAVE RAM TEST POINTER HIGH BYTEXXFDAF = *     INC     XX:C1          ; INCREMENT RAM TEST POINTER LOW BYTE     BNE     XXFDB5          ; IF NO ROLLOVER SKIP THE HIGH BYTE INCREMENT     INC     XXC2          ; INCREMENT RAM TEST POINTER HIGH BYTEXXFDB5 = *     JSR     XXFE91          ; TEST RAM BYTE, RETUR:N CB=0 IF FAILED     LDA     XX97          ; TEST LOOKING FOR END FLAG     BEQ     XXFDDE          ; BRANCH IF NOT LOOKING FOR END                         ; ELSE NOW LOOKING FOR THE END OF MEMORY     BCS     XXFDAF          ; LOOP IF BYTE TEST PASSE:D     LDY     XXC2          ; GET TEST ADDRESS HIGH BYTE     LDX     XXC1          ; GET TEST ADDRESS LOW BYTE     CPY     #$20               ; COMPARE WITH $2000, RAM SHOULD ALWAYS END AT OR AFTER                         ; $2000 EVEN WITH NO EXPANS:ION MEMORY AS THE BUILT IN RAM                         ; ENDS AT $1FFF. THEREFORE THE FOLLOWING TEST SHOULD                         ; NEVER BRANCH     BCC     XXFDEB          ; IF END ADDRESS < $2000 GO DO DEAD END LOOP     CPY     #$21             :  ; COMPARE WITH $2100     BCS     XXFDD2          ; BRANCH IF >= $2100                         ; ELSE MEMORY ENDED BEFORE $2100     LDY     #$1E               ; SET SCREEN MEMORY PAGE TO $1E00     STY     XX0288          ; SAVE SCREEN MEMORY PAGEX:XFDCF = *     JMP     XXFE7B          ; SET THE TOP OF MEMORY AND RETURN                         ; MEMORY ENDS BEYOND $2100XXFDD2 = *     LDA     #$12               ; SET OS START OF MEMORY HIGH BYTE     STA     XX0282          ; SAVE OS START OF M:EMORY HIGH BYTE     LDA     #$10               ; SET SCREEN MEMORY PAGE TO $1000     STA     XX0288          ; SAVE SCREEN MEMORY PAGE     BNE     XXFDCF          ; SET THE TOP OF MEMORY AND RETURN, BRANCH ALWAYSXXFDDE = *     BCC     XXFDAF       :   ; LOOP IF BYTE TEST FAILED, NOT FOUND START YET                         ; ELSE FOUND START OF RAM     LDA     XXC2          ; GET TEST ADDRESS HIGH BYTE     STA     XX0282          ; SAVE OS START OF MEMORY HIGH BYTE     STA     XX97          ; S:ET LOOKING FOR END FLAG     CMP     #$11               ; COMPARE START WITH $1100, RAM SHOULD ALWAYS START BEFORE                         ; $1100 EVEN WITH NO EXPANSION MEMORY AS THE BUILT IN RAM                         ; STARTS AT $1000. THEREFORE TH: E FOLLOWING TEST SHOULD                         ; ALWAYS BRANCH     BCC     XXFDAF          ; GO FIND END OF RAM, BRANCH ALWAYS                         ; IF THE CODE DROPS THROUGH HERE THEN THE RAM HAS FAILED                         ; AND THERE IS N:!OT MUCH ELSE TO BE DONEXXFDEB = *     JSR     XXE5C3          ; INITIALISE VIC CHIP     JMP     XXFDEB          ; LOOP FOREVER;***********************************************************************************;;; TAPE IRQ VECTORSXXFDF1 = *   :"  .WORD     XXFCA8          ; $08     WRITE TAPE LEADER IRQ ROUTINE     .WORD     XXFC0B          ; $0A     TAPE WRITE IRQ ROUTINE     .WORD     XXEABF          ; $0C     NORMAL IRQ VECTOR     .WORD     XXF98E          ; $0E     READ TAPE BITS IRQ ROU:#TINE;***********************************************************************************;;; INITIALIZE I/O REGISTERSXXFDF9 = *     LDA     #$7F               ; DISABLE ALL INTERRUPTS     STA     XX911E          ; ON VIA 1 IER ..     STA     XX9:$12E          ; .. AND VIA 2 IER     LDA     #$40               ; SET T1 FREE RUN, T2 CLOCK 2,                         ; SR DISABLED, LATCHES DISABLED     STA     XX912B          ; SET VIA 2 ACR     LDA     #$40               ; SET T1 FREE RUN, T2 :%CLOCK 2,                         ; SR DISABLED, LATCHES DISABLED     STA     XX911B          ; SET VIA 1 ACR     LDA     #$FE               ; CB2 HIGH, RS232 TX                         ; CB1 +VE EDGE,                         ; CA2 HIGH, TAPE MOTOR:& OFF                         ; CA1 -VE EDGE     STA     XX911C          ; SET VIA 1 PCR     LDA     #$DE               ; CB2 LOW, SERIAL DATA OUT HIGH                         ; CB1 +VE EDGE,                         ; CA2 HIGH, SERIAL CLOCK OUT LOW:'                         ; CA1 -VE EDGE     STA     XX912C          ; SET VIA 2 PCR     LDX     #$00               ; ALL INPUTS, RS232 INTERFACE OR PARALLEL USER PORT     STX     XX9112          ; SET VIA 1 DDRB     LDX     #$FF               ; ALL;  OUTPUTS, KEYBOARD COLUMN     STX     XX9122          ; SET VIA 2 DDRB     LDX     #$00               ; ALL INPUTS, KEYBOARD ROW     STX     XX9123          ; SET VIA 2 DDRA     LDX     #$80               ; OIII IIII, ATN OUT, LIGHT PEN, JOYSTICK, ;SERIAL DATA                         ; IN, SERIAL CLK IN     STX     XX9113          ; SET VIA 1 DDRA     LDX     #$00               ; ATN OUT LOW, SET ATN HIGH     STX     XX911F          ; SET VIA 1 DRA, NO HANDSHAKE     JSR     XXEF84          ;; SET SERIAL CLOCK HIGH     LDA     #$82               ; ENABLE CA1 INTERRUPT, [RESTORE] KEY     STA     XX911E          ; SET VIA 1 IER     JSR     XXEF8D          ; SET SERIAL CLOCK LOW;*************************************************************;**********************;;; SET 60HZ AND ENABLE TIMERXXFE39 = *     LDA     #$C0               ; ENABLE T1 INTERRUPT     STA     XX912E          ; SET VIA 2 IER     LDA     #$26               ; SET TIMER CONSTANT LOW BYTE [PAL];     LDA     #$89   ;            ; SET TIMER CONSTANT LOW BYTE [NTSC]     STA     XX9124          ; SET VIA 2 T1C_L     LDA     #$48               ; SET TIMER CONSTANT HIGH BYTE [PAL];     LDA     #$42               ; SET TIMER CONSTANT HIGH BYTE [NTSC]     STA     XX912;5          ; SET VIA 2 T1C_H     RTS;***********************************************************************************;;; SET FILENAME; THIS ROUTINE IS USED TO SET UP THE FILE NAME FOR THE OPEN, SAVE, OR LOAD ROUTINES.; THE ACCUMULATOR MUST BE; LOADED WITH THE LENGTH OF THE FILE AND XY WITH THE POINTER; TO FILE NAME, X BEING THE LOW BYTE. THE ADDRESS CAN BE ANY VALID MEMORY ADDRESS IN; THE SYSTEM WHERE A STRING OF CHARACTERS FOR THE FILE NAME IS STORED. IF NO FILE; NAME DESIRED THE ACCUMULA;TOR MUST BE SET TO 0, REPRESENTING A ZERO FILE LENGTH,; IN THAT CASE  XY MAY BE SET TO ANY MEMORY ADDRESS.XXFE49 = *     STA     XXB7          ; SET FILE NAME LENGTH     STX     XXBB          ; SET FILE NAME POINTER LOW BYTE     STY     XXBC       ;   ; SET FILE NAME POINTER HIGH BYTE     RTS;***********************************************************************************;;; SET LOGICAL FILE, FIRST AND SECOND ADDRESSES; THIS ROUTINE WILL SET THE LOGICAL FILE NUMBER, DEVICE ADDRESS, AND S;	ECONDARY; ADDRESS, COMMAND NUMBER, FOR OTHER KERNAL ROUTINES.; THE LOGICAL FILE NUMBER IS USED BY THE SYSTEM AS A KEY TO THE FILE TABLE CREATED; BY THE OPEN FILE ROUTINE. DEVICE ADDRESSES CAN RANGE FROM 0 TO 30. THE FOLLOWING; CODES ARE USED BY THE ;
COMPUTER TO STAND FOR THE FOLLOWING CBM DEVICES:; ADDRESS     DEVICE; =======     ======;  0          KEYBOARD;  1          CASSETTE #1;  2          RS-232C DEVICE;  3          CRT DISPLAY;  4          SERIAL BUS PRINTER;  8          CBM SERIAL ;BUS DISK DRIVE; DEVICE NUMBERS OF FOUR OR GREATER AUTOMATICALLY REFER TO DEVICES ON THE SERIAL; BUS.; A COMMAND TO THE DEVICE IS SENT AS A SECONDARY ADDRESS ON THE SERIAL BUS AFTER; THE DEVICE NUMBER IS SENT DURING THE SERIAL ATTENTION HANDSHAKING ;SEQUENCE. IF; NO SECONDARY ADDRESS IS TO BE SENT Y SHOULD BE SET TO $FF.XXFE50 = *     STA     XXB8          ; SET LOGICAL FILE     STX     XXBA          ; SET DEVICE NUMBER     STY     XXB9          ; SET SECONDARY ADDRESS OR COMMAND     RTS;*;**********************************************************************************;;; READ I/O STATUS WORD; THIS ROUTINE RETURNS THE CURRENT STATUS OF THE I/O DEVICE IN THE ACCUMULATOR. THE; ROUTINE IS USUALLY CALLED AFTER NEW COMMUNICATION TO AN I/;O DEVICE. THE ROUTINE; WILL GIVE INFORMATION ABOUT DEVICE STATUS, OR ERRORS THAT HAVE OCCURRED DURING THE; I/O OPERATION.XXFE57 = *     LDA     XXBA          ; GET DEVICE NUMBER     CMP     #$02               ; COMPARE DEVICE WITH RS232 DEVICE    ; BNE     XXFE68          ; BRANCH IF NOT RS232 DEVICE                         ; GET RS232 DEVICE STATUS     LDA     XX0297          ; READ RS232 STATUS WORD     LDA     #$00               ; CLEAR A     STA     XX0297          ; CLEAR RS232 STATUS;; THE ABOVE CODE IS WRONG. THE RS232 STATUS IS IN A BUT A IS CLEARED AND THAT IS USED; TO CLEAR THE RS232 STATUS BYTE. SO WHATEVER THE STATUS THE RESULT IS ALWAYS $00 AND; THE STATUS BYTE IS ALWAYS CLEARED. A SOLUTION IS TO USE X TO CLEAR THE STATUS AF;TER; IT IS READ INSTEAD OF THE ABOVE LIKE THIS ..;;     LDX     #$00               ; CLEAR X;     STX     XX0297          ; CLEAR RS232 STATUS ##     RTS;***********************************************************************************;;; CON;TROL KERNAL MESSAGES; THIS ROUTINE CONTROLS THE PRINTING OF ERROR AND CONTROL MESSAGES BY THE KERNAL.; EITHER PRINT ERROR MESSAGES OR PRINT CONTROL MESSAGES CAN BE SELECTED BY SETTING; THE ACCUMULATOR WHEN THE ROUTINE IS CALLED.; FILE NOT FOUND IS ;AN EXAMPLE OF AN ERROR MESSAGE. PRESS PLAY ON CASSETTE IS AN; EXAMPLE OF A CONTROL MESSAGE.; BITS 6 AND 7 OF THIS VALUE DETERMINE WHERE THE MESSAGE WILL COME FROM. IF BIT 7; IS SET ONE OF THE ERROR MESSAGES FROM THE KERNAL WILL BE PRINTED. IF BIT 6 I;S SET; A CONTROL MESSAGE WILL BE PRINTED.XXFE66 = *     STA     XX9D          ; SET MESSAGE MODE FLAGXXFE68 = *     LDA     XX90          ; READ SERIAL STATUS BYTE; OR INTO SERIAL STATUS BYTEXXFE6A = *     ORA     XX90          ; OR WITH SERIA;L STATUS BYTE     STA     XX90          ; SAVE SERIAL STATUS BYTE     RTS;***********************************************************************************;;; SET TIMEOUT ON SERIAL BUS; THIS ROUTINE SETS THE TIMEOUT FLAG FOR THE SERIAL BUS. WH;EN THE TIMEOUT FLAG IS; SET, THE COMPUTER WILL WAIT FOR A DEVICE ON THE SERIAL PORT FOR 64 MILLISECONDS.; IF THE DEVICE DOES NOT RESPOND TO THE COMPUTER'S DAV SIGNAL WITHIN THAT TIME THE; COMPUTER WILL RECOGNIZE AN ERROR CONDITION AND LEAVE THE HANDSH;AKE SEQUENCE. WHEN; THIS ROUTINE IS CALLED AND THE ACCUMULATOR CONTAINS A 0 IN BIT 7, TIMEOUTS ARE; ENABLED. A 1 IN BIT 7 WILL DISABLE THE TIMEOUTS.; NOTE: THE THE TIMEOUT FEATURE IS USED TO COMMUNICATE THAT A DISK FILE IS NOT FOUND; ON AN ATTEMPT T;O OPEN A FILE.XXFE6F = *     STA     XX0285          ; SAVE SERIAL BUS TIMEOUT FLAG     RTS;***********************************************************************************;;; READ/SET THE TOP OF MEMORY, CB = 1 TO READ, CB = 0 TO SET; THIS ;ROUTINE IS USED TO READ AND SET THE TOP OF RAM. WHEN THIS ROUTINE IS CALLED; WITH THE CARRY BIT SET THE POINTER TO THE TOP OF RAM WILL BE LOADED INTO XY. WHEN; THIS ROUTINE IS CALLED WITH THE CARRY BIT CLEAR XY WILL BE SAVED AS THE TOP OF; MEMORY POIN;TER CHANGING THE TOP OF MEMORY.XXFE73 = *     BCC     XXFE7B          ; IF CB CLEAR GO SET THE TOP OF MEMORY; READ THE TOP OF MEMORYXXFE75 = *     LDX     XX0283          ; GET MEMORY TOP LOW BYTE     LDY     XX0284          ; GET MEMORY TOP HIG;H BYTE; SET THE TOP OF MEMORYXXFE7B = *     STX     XX0283          ; SET MEMORY TOP LOW BYTE     STY     XX0284          ; SET MEMORY TOP HIGH BYTE     RTS;***********************************************************************************;;;; READ/SET THE BOTTOM OF MEMORY, CB = 1 TO READ, CB = 0 TO SET; THIS ROUTINE IS USED TO READ AND SET THE BOTTOM OF RAM. WHEN THIS ROUTINE IS; CALLED WITH THE CARRY BIT SET THE POINTER TO THE BOTTOM OF RAM WILL BE LOADED; INTO XY. WHEN THIS ROUTINE IS; CALLED WITH THE CARRY BIT CLEAR XY WILL BE SAVED AS; THE BOTTOM OF MEMORY POINTER CHANGING THE BOTTOM OF MEMORY.XXFE82 = *     BCC     XXFE8A          ; IF CB CLEAR GO SET THE BOTTOM OF MEMORY; READ THE BOTTOM OF MEMORY     LDX     XX0281       ;   ; READ OS START OF MEMORY LOW BYTE     LDY     XX0282          ; READ OS START OF MEMORY HIGH BYTE; SET THE BOTTOM OF MEMORYXXFE8A = *     STX     XX0281          ; SET OS START OF MEMORY LOW BYTE     STY     XX0282          ; SET OS START OF M;EMORY HIGH BYTE     RTS;***********************************************************************************;;; NON-DESTRUCTIVE TEST RAM BYTE, RETURN CB=0 IF FAILEDXXFE91 = *     LDA     (XXC1),Y          ; GET EXISTING RAM BYTE     TAX         ;            ; COPY TO X     LDA     #$55               ; SET FIRST TEST BYTE     STA     (XXC1),Y          ; SAVE TO RAM     CMP     (XXC1),Y          ; COMPARE WITH SAVED     BNE     XXFEA4          ; BRANCH IF FAIL     ROR A                  ; MAK;!E BYTE $AA, CARRY IS SET HERE     STA     (XXC1),Y          ; SAVE TO RAM     CMP     (XXC1),Y          ; COMPARE WITH SAVED     BNE     XXFEA4          ; BRANCH IF FAIL     .BYTE     $A9               ; MAKES NEXT LINE LDA #$18XXFEA4 = *     CLC ;"                   ; FLAG TEST FAILED     TXA                    ; GET ORIGINAL BYTE BACK     STA     (XXC1),Y          ; RESTORE ORIGINAL BYTE     RTS;***********************************************************************************;;; NMI VEC;#TORXXFEA9 = *     SEI                    ; DISABLE INTERRUPTS     JMP     (XX0318)          ; DO NMI VECTOR;***********************************************************************************;;; NMI HANDLERXXFEAD = *     PHA                  ;$  ; SAVE A     TXA                    ; COPY X     PHA                    ; SAVE X     TYA                    ; COPY Y     PHA                    ; SAVE Y     LDA     XX911D          ; GET VIA 1 IFR     BPL     XXFEFF          ; IF NO INTERRUPT RES;%TORE REGISTERS AND EXIT     AND     XX911E          ; AND WITH VIA 1 IER     TAX                    ; COPY TO X     AND     #$02               ; MASK [RESTORE] KEY     BEQ     XXFEDE          ; BRANCH IF NOT [RESTORE] KEY                         ;;& ELSE WAS [RESTORE] KEY ..     JSR     XXFD3F          ; SCAN FOR AUTOSTART ROM AT $A000     BNE     XXFEC7          ; BRANCH IF NO AUTOSTART ROM     JMP     (XXA002)          ; ELSE DO AUTOSTART ROM BREAK ENTRYXXFEC7 = *     BIT     XX9111       ;'   ; TEST VIA 1 DRA     JSR     XXF734          ; INCREMENT THE REAL TIME CLOCK     JSR     XXFFE1          ; SCAN STOP KEY     BNE     XXFEFF          ; IF NOT [STOP] RESTORE REGISTERS AND EXIT INTERRUPT;*******************************************< ****************************************;;; BRK HANDLERXXFED2 = *     JSR     XXFD52          ; RESTORE DEFAULT I/O VECTORS     JSR     XXFDF9          ; INITIALIZE I/O REGISTERS     JSR     XXE518          ; INITIALISE HARDWARE     JMP     (XXC0<02)          ; DO BASIC BREAK ENTRY;***********************************************************************************;;; RS232 NMI ROUTINEXXFEDE = *     LDA     XX911E          ; GET VIA 1 IER     ORA     #$80               ; SET ENABLE BIT, T<HIS BIT SHOULD BE SET ACCORDING TO THE                         ; ROCKWELL 6522 DATASHEET BUT CLEAR ACORDING TO THE MOS                         ; DATASHEET. BEST TO ASSUME IT'S NOT IN THE STATE REQUIRED                         ; AND SET IT SO     PHA <                   ; SAVE TO RE-ENABLE INTERRUPTS     LDA     #$7F               ; DISABLE ALL INTERRUPTS     STA     XX911E          ; SET VIA 1 IER     TXA                    ; GET ACTIVE INTERRUPTS BACK     AND     #$40               ; MASK T1 INT<ERRUPT     BEQ     XXFF02          ; BRANCH IF NOT T1 INTERRUPT                         ; WAS VIA 1 T1 INTERRUPT     LDA     #$CE               ; CB2 LOW, CB1 -VE EDGE, CA2 HIGH, CA1 -VE EDGE     ORA     XXB5          ; OR RS232 NEXT BIT TO SEND, SE<TS CB2 HIGH IF SET     STA     XX911C          ; SET VIA 1 PCR     LDA     XX9114          ; GET VIA 1 T1C_L     PLA                    ; RESTORE INTERRUPT ENABLE BYTE TO RSTORE PREVIOUSLY                         ; ENABLED INTERRUPTS     STA     XX9<11E          ; SET VIA 1 IER     JSR     XXEFA3          ; RS232 TX NMI ROUTINEXXFEFF = *     JMP     XXFF56          ; RESTORE REGISTERS AND EXIT INTERRUPT                         ; WAS NOT VIA 1 T1 INTERRUPTXXFF02 = *     TXA                    <; GET ACTIVE INTERRUPTS BACK     AND     #$20               ; MASK T2 INTERRUPT     BEQ     XXFF2C          ; BRANCH IF NOT T2 INTERRUPT                         ; WAS VIA 1 T2 INTERRUPT     LDA     XX9110          ; GET VIA 1 DRB     AND     #$01  <             ; MASK RS232 DATA IN     STA     XXA7          ; SAVE RECEIVER INPUT BIT TEMP STORAGE     LDA     XX9118          ; GET VIA 1 T2C_L     SBC     #$16               ;.     ADC     XX0299          ; ADD BAUD RATE BIT TIME LOW BYTE     STA <	    XX9118          ; SET VIA 1 T2C_L     LDA     XX9119          ; GET VIA 1 T2C_H     ADC     XX029A          ; ADD BAUD RATE BIT TIME HIGH BYTE     STA     XX9119          ; SET VIA 1 T2C_H     PLA                    ; RESTORE INTERRUPT ENABLE BYT<
E TO RESTORE PREVIOUSLY                         ; ENABLED INTERRUPTS     STA     XX911E          ; SET VIA 1 IER, RESTORE INTERRUPTS     JSR     XXF036          ; RS232 RX     JMP     XXFF56          ; RESTORE REGISTERS AND EXIT INTERRUPT          <               ; WAS NOT VIA 1 T2 INTERRUPTXXFF2C = *     TXA                    ; GET ACTIVE INTERRUPTS BACK     AND     #$10               ; MASK CB1 INTERRUPT, RX DATA BIT TRANSITION     BEQ     XXFF56          ; IF NO BIT RESTORE REGISTERS AND EX<IT INTERRUPT     LDA     XX0293          ; GET PSEUDO 6551 CONTROL REGISTER     AND     #$0F               ; CLEAR NON BAUD BITS     BNE     XXFF38          ; SHORT DELAY. WAS THIS TO BE A BRANCH TO CODE TO IMPLEMENT                         ; THE US<ER BAUD RATE ??XXFF38 = *     ASL A                  ; *2, 2 BYTES PER BAUD COUNT     TAX                    ; COPY TO INDEX     LDA     XXFF5C-2,X     ; GET BAUD COUNT LOW BYTE     STA     XX9118          ; SET VIA 1 T2C_L     LDA     XXFF5C-1,X  <   ; GET BAUD COUNT HIGH BYTE     STA     XX9119          ; SET VIA 1 T2C_H     LDA     XX9110          ; READ VIA 1 DRB, CLEAR INTERRUPT FLAG     PLA                    ; RESTORE INTERRUPT ENABLE BYTE TO RSTORE PREVIOUSLY                         ; E<NABLED INTERRUPTS     ORA     #$20               ; ENABLE T2 INTERRUPT     AND     #$EF               ; DISABLE CB1 INTERRUPT     STA     XX911E          ; SET VIA 1 IER     LDX     XX0298          ; GET NUMBER OF BITS TO BE SENT/RECEIVED     STX   <  XXA8          ; SAVE RECEIVER BIT COUNT IN;***********************************************************************************;;; RESTORE THE REGISTERS AND EXIT THE INTERRUPT;; IF YOU WRITE YOUR OWN INTERRUPT CODE YOU SHOULD EITHER RETURN FROM T<HE INTERRUPT; USING CODE THAT ENDS UP HERE OT CODE THAT REPLICATES THIS CODE.XXFF56 = *     PLA                    ; PULL Y     TAY                    ; RESTORE Y     PLA                    ; PULL X     TAX                    ; RESTORE X     PLA <                   ; RESTORE A     RTI;***********************************************************************************;;; BAUD RATE WORD IS CALCULATED FROM ..;; (SYSTEM CLOCK / BAUD RATE) / 2 - 100;;          SYSTEM CLOCK;          -------<-----; PAL          1108404 HZ; NTSC     1022727 HZ; BAUD RATE TABLES FOR PAL VIC 20XXFF5C = *     .WORD     $2AE6               ;   50   BAUD     .WORD     $1C78               ;   75   BAUD     .WORD     $1349               ;  110   BAUD     .<WORD     $0FB1               ;  134.5 BAUD     .WORD     $0E0A               ;  150   BAUD     .WORD     $06D3               ;  300   BAUD     .WORD     $0338               ;  600   BAUD     .WORD     $016A               ; 1200   BAUD     .WORD     <$00D0               ; 1800   BAUD     .WORD     $0083               ; 2400   BAUD     .WORD     $0036               ; 3600   BAUD; BAUD RATE TABLES FOR NTSC VIC 20;     .WORD     $2792               ;   50   BAUD;     .WORD     $1A40              < ;   75   BAUD;     .WORD     $11C6               ;  110   BAUD;     .WORD     $0E74               ;  134.5 BAUD;     .WORD     $0CEE               ;  150   BAUD;     .WORD     $0645               ;  300   BAUD;     .WORD     $02F1               ;  <600   BAUD;     .WORD     $0146               ; 1200   BAUD;     .WORD     $00B8               ; 1800   BAUD;     .WORD     $0071               ; 2400   BAUD;     .WORD     $002A               ; 3600   BAUD;****************************************<*******************************************;;; IRQ VECTORXXFF72 = *     PHA                    ; SAVE A     TXA                    ; COPY X     PHA                    ; SAVE X     TYA                    ; COPY Y     PHA                    ; SAVE< Y     TSX                    ; COPY STACK POINTER     LDA     XX0100+4,X     ; GET THE STACKED STATUS REGISTER     AND     #$10               ; MASK THE BRK FLAG BIT     BEQ     XXFF82          ; IF NOT BRK GO DO THE HARDWARE IRQ VECTOR     JMP   <  (XX0316)          ; ELSE DO THE BRK VECTOR (IBRK)XXFF82 = *     JMP     (XX0314)          ; DO IRQ VECTOR (IIRQ);***********************************************************************************;;; SPARE BYTES, NOT REFERENCED;XXFF85     .B<YTE     $FF,$FF,$FF,$FF,$FF;***********************************************************************************;;; RESTORE DEFAULT I/O VECTORS; THIS ROUTINE RESTORES THE DEFAULT VALUES OF ALL SYSTEM VECTORS USED IN KERNAL AND; BASIC ROUTINES AND <INTERRUPTS. THE KERNAL VECTOR ROUTINE IS USED TO READ AND ALTER; INDIVIDUAL SYSTEM VECTORS.;XXFF8A     JMP     XXFD52          ; RESTORE DEFAULT I/O VECTORS;***********************************************************************************;;; <READ/SET VECTORED I/O; THIS ROUTINE MANAGES ALL SYSTEM VECTOR JUMP ADDRESSES STORED IN RAM. CALLING THIS; ROUTINE WITH THE ACCUMULATOR CARRY BIT SET WILL STORE THE CURRENT CONTENTS OF THE; RAM VECTORS IN A LIST POINTED TO BY THE X AND Y REGISTERS.;< WHEN THIS ROUTINE IS CALLED WITH THE CARRY BIT CLEAR, THE USER LIST POINTED TO BY; THE X AND Y REGISTERS IS TRANSFERRED TO THE SYSTEM RAM VECTORS.; NOTE: THIS ROUTINE REQUIRES CAUTION IN ITS USE. THE BEST WAY TO USE IT IS TO FIRST; READ THE ENTIRE V<ECTOR CONTENTS INTO THE USER AREA, ALTER THE DESIRED VECTORS, AND; THEN COPY THE CONTENTS BACK TO THE SYSTEM VECTORS.;XXFF8D     JMP     XXFD57          ; SET/READ VECTORED I/O FROM (XY);************************************************************< ***********************;;; CONTROL KERNAL MESSAGES; THIS ROUTINE CONTROLS THE PRINTING OF ERROR AND CONTROL MESSAGES BY THE KERNAL.; EITHER PRINT ERROR MESSAGES OR PRINT CONTROL MESSAGES CAN BE SELECTED BY SETTING; THE ACCUMULATOR WHEN THE ROUTINE <!IS CALLED.; FILE NOT FOUND IS AN EXAMPLE OF AN ERROR MESSAGE. PRESS PLAY ON CASSETTE IS AN; EXAMPLE OF A CONTROL MESSAGE.; BITS 6 AND 7 OF THIS VALUE DETERMINE WHERE THE MESSAGE WILL COME FROM. IF BIT 7; IS SET ONE OF THE ERROR MESSAGES FROM THE KE<"RNAL WILL BE PRINTED. IF BIT 6 IS SET; A CONTROL MESSAGE WILL BE PRINTED.XXFF90 = *     JMP     XXFE66          ; CONTROL KERNAL MESSAGES;***********************************************************************************;;; SEND SECONDARY ADDRE<#SS AFTER LISTEN; THIS ROUTINE IS USED TO SEND A SECONDARY ADDRESS TO AN I/O DEVICE AFTER A CALL TO; THE LISTEN ROUTINE IS MADE AND THE DEVICE COMMANDED TO LISTEN. THE ROUTINE CANNOT; BE USED TO SEND A SECONDARY ADDRESS AFTER A CALL TO THE TALK ROUTIN<$E.; A SECONDARY ADDRESS IS USUALLY USED TO GIVE SET-UP INFORMATION TO A DEVICE BEFORE; I/O OPERATIONS BEGIN.; WHEN A SECONDARY ADDRESS IS TO BE SENT TO A DEVICE ON THE SERIAL BUS THE ADDRESS; MUST FIRST BE ORED WITH $60.;XXFF93     JMP     XXEEC<%0          ; SEND SECONDARY ADDRESS AFTER LISTEN;***********************************************************************************;;; SEND SECONDARY ADDRESS AFTER TALK; THIS ROUTINE TRANSMITS A SECONDARY ADDRESS ON THE SERIAL BUS FOR A TALK DEVI<&CE.; THIS ROUTINE MUST BE CALLED WITH A NUMBER BETWEEN 4 AND 31 IN THE ACCUMULATOR.; THE ROUTINE WILL SEND THIS NUMBER AS A SECONDARY ADDRESS COMMAND OVER THE SERIAL; BUS. THIS ROUTINE CAN ONLY BE CALLED AFTER A CALL TO THE TALK ROUTINE. IT WILL; NOT<' WORK AFTER A LISTEN.;XXFF96     JMP     XXEECE          ; SEND SECONDARY ADDRESS AFTER TALK;***********************************************************************************;;; READ/SET THE TOP OF MEMORY; THIS ROUTINE IS USED TO READ AND SET=  THE TOP OF RAM. WHEN THIS ROUTINE IS CALLED; WITH THE CARRY BIT SET THE POINTER TO THE TOP OF RAM WILL BE LOADED INTO XY. WHEN; THIS ROUTINE IS CALLED WITH THE CARRY BIT CLEAR XY WILL BE SAVED AS THE TOP OF; MEMORY POINTER CHANGING THE TOP OF MEMORY.=XXFF99 = *     JMP     XXFE73          ; READ/SET THE TOP OF MEMORY;***********************************************************************************;;; READ/SET THE BOTTOM OF MEMORY; THIS ROUTINE IS USED TO READ AND SET THE BOTTOM OF RAM. WH=EN THIS ROUTINE IS; CALLED WITH THE CARRY BIT SET THE POINTER TO THE BOTTOM OF RAM WILL BE LOADED; INTO XY. WHEN THIS ROUTINE IS CALLED WITH THE CARRY BIT CLEAR XY WILL BE SAVED AS; THE BOTTOM OF MEMORY POINTER CHANGING THE BOTTOM OF MEMORY.XXFF9C == *     JMP     XXFE82          ; READ/SET THE BOTTOM OF MEMORY;***********************************************************************************;;; SCAN THE KEYBOARD; THIS ROUTINE WILL SCAN THE KEYBOARD AND CHECK FOR PRESSED KEYS. IT IS THE SAM=E; ROUTINE CALLED BY THE INTERRUPT HANDLER. IF A KEY IS DOWN, ITS ASCII VALUE IS; PLACED IN THE KEYBOARD QUEUE.;XXFF9F     JMP     XXEB1E          ; SCAN KEYBOARD;***********************************************************************************=;;; SET TIMEOUT ON SERIAL BUS; THIS ROUTINE SETS THE TIMEOUT FLAG FOR THE SERIAL BUS. WHEN THE TIMEOUT FLAG IS; SET, THE COMPUTER WILL WAIT FOR A DEVICE ON THE SERIAL PORT FOR 64 MILLISECONDS.; IF THE DEVICE DOES NOT RESPOND TO THE COMPUTER'S DAV S=IGNAL WITHIN THAT TIME THE; COMPUTER WILL RECOGNIZE AN ERROR CONDITION AND LEAVE THE HANDSHAKE SEQUENCE. WHEN; THIS ROUTINE IS CALLED AND THE ACCUMULATOR CONTAINS A 0 IN BIT 7, TIMEOUTS ARE; ENABLED. A 1 IN BIT 7 WILL DISABLE THE TIMEOUTS.; NOTE: TH=E THE TIMEOUT FEATURE IS USED TO COMMUNICATE THAT A DISK FILE IS NOT FOUND; ON AN ATTEMPT TO OPEN A FILE.;XXFFA2     JMP     XXFE6F          ; SET TIMEOUT ON SERIAL BUS;******************************************************************************=******;; INPUT A BYTE FROM THE SERIAL BUS; THIS ROUTINE READS A BYTE OF DATA FROM THE SERIAL BUS USING FULL HANDSHAKING. THE; DATA IS RETURNED IN THE ACCUMULATOR. BEFORE USING THIS ROUTINE THE TALK ROUTINE,; XXFFB4, MUST HAVE BEEN CALLED FIRST TO C=	OMMAND THE DEVICE ON THE SERIAL BUS TO; SEND DATA ON THE BUS. IF THE INPUT DEVICE NEEDS A SECONDARY COMMAND IT MUST BE SENT; BY USING THE TKSA ROUTINE, XXFF96, BEFORE CALLING THIS ROUTINE.; ERRORS ARE RETURNED IN THE STATUS WORD WHICH CAN BE READ BY =
CALLING THE READST; ROUTINE, XXFFB7.;XXFFA5     JMP     XXEF19          ; INPUT BYTE FROM SERIAL BUS;************************************************************************************;; OUTPUT A BYTE TO THE SERIAL BUS; THIS ROUTINE IS USED T=O SEND INFORMATION TO DEVICES ON THE SERIAL BUS. A CALL TO; THIS ROUTINE WILL PUT A DATA BYTE ONTO THE SERIAL BUS USING FULL HANDSHAKING.; BEFORE THIS ROUTINE IS CALLED THE LISTEN ROUTINE, XXFFB1, MUST BE USED TO; COMMAND A DEVICE ON THE SERIAL BUS TO= GET READY TO RECEIVE DATA.; THE ACCUMULATOR IS LOADED WITH A BYTE TO OUTPUT AS DATA ON THE SERIAL BUS. A; DEVICE MUST BE LISTENING OR THE STATUS WORD WILL RETURN A TIMEOUT. THIS ROUTINE; ALWAYS BUFFERS ONE CHARACTER. SO WHEN A CALL TO THE UNLISTEN R=OUTINE, XXFFAE,; IS MADE TO END THE DATA TRANSMISSION, THE BUFFERED CHARACTER IS SENT WITH EOI; SET. THEN THE UNLISTEN COMMAND IS SENT TO THE DEVICE.;XXFFA8     JMP     XXEEE4          ; OUTPUT A BYTE TO THE SERIAL BUS;***************************=********************************************************;;; COMMAND THE SERIAL BUS TO UNTALK; THIS ROUTINE WILL TRANSMIT AN UNTALK COMMAND ON THE SERIAL BUS. ALL DEVICES; PREVIOUSLY SET TO TALK WILL STOP SENDING DATA WHEN THIS COMMAND IS RECEIVED.=;XXFFAB     JMP     XXEEF6          ; COMMAND THE SERIAL BUS TO UNTALK;***********************************************************************************;;; COMMAND THE SERIAL BUS TO UNLISTEN; THIS ROUTINE COMMANDS ALL DEVICES ON THE SERIAL BUS =TO STOP RECEIVING DATA FROM; THE COMPUTER. CALLING THIS ROUTINE RESULTS IN AN UNLISTEN COMMAND BEING TRANSMITTED; ON THE SERIAL BUS. ONLY DEVICES PREVIOUSLY COMMANDED TO LISTEN WILL BE AFFECTED.; THIS ROUTINE IS NORMALLY USED AFTER THE COMPUTER IS FI=NISHED SENDING DATA TO; EXTERNAL DEVICES. SENDING THE UNLISTEN WILL COMMAND THE LISTENING DEVICES TO GET; OFF THE SERIAL BUS SO IT CAN BE USED FOR OTHER PURPOSES.;XXFFAE     JMP     XXEF04          ; COMMAND THE SERIAL BUS TO UNLISTEN;***********=************************************************************************;;; COMMAND DEVICES ON THE SERIAL BUS TO LISTEN; THIS ROUTINE WILL COMMAND A DEVICE ON THE SERIAL BUS TO RECEIVE DATA. THE; ACCUMULATOR MUST BE LOADED WITH A DEVICE NUMBER BETWE=EN 4 AND 31 BEFORE CALLING; THIS ROUTINE. LISTEN CONVERT THIS TO A LISTEN ADDRESS THEN TRANSMIT THIS DATA AS; A COMMAND ON THE SERIAL BUS. THE SPECIFIED DEVICE WILL THEN GO INTO LISTEN MODE; AND BE READY TO ACCEPT INFORMATION.;XXFFB1     JMP     XX=EE17          ; COMMAND DEVICES ON THE SERIAL BUS TO LISTEN;***********************************************************************************;;; COMMAND A SERIAL BUS DEVICE TO TALK; TO USE THIS ROUTINE THE ACCUMULATOR MUST FIRST BE LOADED WITH A= DEVICE NUMBER; BETWEEN 4 AND 30. WHEN CALLED THIS ROUTINE CONVERTS THIS DEVICE NUMBER TO A TALK; ADDRESS. THEN THIS DATA IS TRANSMITTED AS A COMMAND ON THE SERIAL BUS.;XXFFB4     JMP     XXEE14          ; COMMAND SERIAL BUS DEVICE TO TALK;******=*****************************************************************************;;; READ I/O STATUS WORD; THIS ROUTINE RETURNS THE CURRENT STATUS OF THE I/O DEVICE IN THE ACCUMULATOR. THE; ROUTINE IS USUALLY CALLED AFTER NEW COMMUNICATION TO AN I/O DEV=ICE. THE ROUTINE; WILL GIVE INFORMATION ABOUT DEVICE STATUS, OR ERRORS THAT HAVE OCCURRED DURING THE; I/O OPERATION.XXFFB7 = *     JMP     XXFE57          ; READ I/O STATUS WORD;********************************************************************=***************;;; SET LOGICAL, FIRST AND SECOND ADDRESSES; THIS ROUTINE WILL SET THE LOGICAL FILE NUMBER, DEVICE ADDRESS, AND SECONDARY; ADDRESS, COMMAND NUMBER, FOR OTHER KERNAL ROUTINES.; THE LOGICAL FILE NUMBER IS USED BY THE SYSTEM AS A KEY T=O THE FILE TABLE CREATED; BY THE OPEN FILE ROUTINE. DEVICE ADDRESSES CAN RANGE FROM 0 TO 30. THE FOLLOWING; CODES ARE USED BY THE COMPUTER TO STAND FOR THE FOLLOWING CBM DEVICES:; ADDRESS     DEVICE; =======     ======;  0          KEYBOARD;  1   =       CASSETTE #1;  2          RS-232C DEVICE;  3          CRT DISPLAY;  4          SERIAL BUS PRINTER;  8          CBM SERIAL BUS DISK DRIVE; DEVICE NUMBERS OF FOUR OR GREATER AUTOMATICALLY REFER TO DEVICES ON THE SERIAL; BUS.; A COMMAND TO TH=E DEVICE IS SENT AS A SECONDARY ADDRESS ON THE SERIAL BUS AFTER; THE DEVICE NUMBER IS SENT DURING THE SERIAL ATTENTION HANDSHAKING SEQUENCE. IF; NO SECONDARY ADDRESS IS TO BE SENT Y SHOULD BE SET TO $FF.XXFFBA = *     JMP     XXFE50          ; SET L=OGICAL, FIRST AND SECOND ADDRESSES;***********************************************************************************;;; SET THE FILENAME; THIS ROUTINE IS USED TO SET UP THE FILE NAME FOR THE OPEN, SAVE, OR LOAD ROUTINES.; THE ACCUMULATOR MUST B=E LOADED WITH THE LENGTH OF THE FILE AND XY WITH THE POINTER; TO FILE NAME, X BEING TH LOW BYTE. THE ADDRESS CAN BE ANY VALID MEMORY ADDRESS IN; THE SYSTEM WHERE A STRING OF CHARACTERS FOR THE FILE NAME IS STORED. IF NO FILE; NAME DESIRED THE ACCUMULA=TOR MUST BE SET TO 0, REPRESENTING A ZERO FILE LENGTH,; IN THAT CASE  XY MAY BE SET TO ANY MEMORY ADDRESS.XXFFBD = *     JMP     XXFE49          ; SET FILENAME;***********************************************************************************;;=; OPEN A LOGICAL FILE; THIS ROUTINE IS USED TO OPEN A LOGICAL FILE. ONCE THE LOGICAL FILE IS SET UP IT; CAN BE USED FOR INPUT/OUTPUT OPERATIONS. MOST OF THE I/O KERNAL ROUTINES CALL ON; THIS ROUTINE TO CREATE THE LOGICAL FILES TO OPERATE ON. NO ARGUM= ENTS NEED TO BE; SET UP TO USE THIS ROUTINE, BUT BOTH THE SETLFS, XXFFBA, AND SETNAM, XXFFBD,; KERNAL ROUTINES MUST BE CALLED BEFORE USING THIS ROUTINE.XXFFC0 = *     JMP     (XX031A)          ; DO OPEN FILE VECTOR;*******************************=!****************************************************;;; CLOSE A SPECIFIED LOGICAL FILE; THIS ROUTINE IS USED TO CLOSE A LOGICAL FILE AFTER ALL I/O OPERATIONS HAVE BEEN; COMPLETED ON THAT FILE. THIS ROUTINE IS CALLED AFTER THE ACCUMULATOR IS LOADED;=" WITH THE LOGICAL FILE NUMBER TO BE CLOSED, THE SAME NUMBER USED WHEN THE FILE WAS; OPENED USING THE OPEN ROUTINE.XXFFC3 = *     JMP     (XX031C)          ; DO CLOSE FILE VECTOR;*********************************************************************=#***************;; OPEN A CHANNEL FOR INPUT; ANY LOGICAL FILE THAT HAS ALREADY BEEN OPENED BY THE OPEN ROUTINE, XXFFC0, CAN BE; DEFINED AS AN INPUT CHANNEL BY THIS ROUTINE. THE DEVICE ON THE CHANNEL MUST BE AN; INPUT DEVICE OR AN ERROR WILL OCCUR AN=$D THE ROUTINE WILL ABORT.; IF YOU ARE GETTING DATA FROM ANYWHERE OTHER THAN THE KEYBOARD, THIS ROUTINE MUST BE; CALLED BEFORE USING EITHER THE CHRIN ROUTINE, XXFFCF, OR THE GETIN ROUTINE,; XXFFE4. IF YOU ARE GETTING DATA FROM THE KEYBOARD AND NO OTHE=%R INPUT CHANNELS ARE; OPEN THEN THE CALLS TO THIS ROUTINE AND TO THE OPEN ROUTINE, XXFFC0, ARE NOT NEEDED.; WHEN USED WITH A DEVICE ON THE SERIAL BUS THIS ROUTINE WILL AUTOMATICALLY SEND THE; LISTEN ADDRESS SPECIFIED BY THE OPEN ROUTINE, XXFFC0, AND =&ANY SECONDARY ADDRESS.; POSSIBLE ERRORS ARE:;;     3 : FILE NOT OPEN;     5 : DEVICE NOT PRESENT;     6 : FILE IS NOT AN INPUT FILEXXFFC6 = *     JMP     (XX031E)          ; DO OPEN FOR INPUT VECTOR;*******************************************='*****************************************;; OPEN A CHANNEL FOR OUTPUT; ANY LOGICAL FILE THAT HAS ALREADY BEEN OPENED BY THE OPEN ROUTINE, XXFFC0, CAN BE; DEFINED AS AN OUTPUT CHANNEL BY THIS ROUTINE THE DEVICE ON THE CHANNEL MUST BE AN; OUTPUT DEVI> CE OR AN ERROR WILL OCCUR AND THE ROUTINE WILL ABORT.; IF YOU ARE SENDING DATA TO ANYWHERE OTHER THAN THE SCREEN THIS ROUTINE MUST BE; CALLED BEFORE USING THE CHROUT ROUTINE, XXFFD2. IF YOU ARE SENDING DATA TO THE; SCREEN AND NO OTHER OUTPUT CHANNELS> ARE OPEN THEN THE CALLS TO THIS ROUTINE AND TO; THE OPEN ROUTINE, XXFFC0, ARE NOT NEEDED.; WHEN USED WITH A DEVICE ON THE SERIAL BUS THIS ROUTINE WILL AUTOMATICALLY SEND THE; LISTEN ADDRESS SPECIFIED BY THE OPEN ROUTINE, XXFFC0, AND ANY SECONDARY AD>DRESS.; POSSIBLE ERRORS ARE:;;     3 : FILE NOT OPEN;     5 : DEVICE NOT PRESENT;     7 : FILE IS NOT AN OUTPUT FILEXXFFC9 = *     JMP     (XX0320)          ; DO OPEN FOR OUTPUT VECTOR;*********************************************************>***************************;; CLOSE INPUT AND OUTPUT CHANNELS; THIS ROUTINE IS CALLED TO CLEAR ALL OPEN CHANNELS AND RESTORE THE I/O CHANNELS TO; THEIR ORIGINAL DEFAULT VALUES. IT IS USUALLY CALLED AFTER OPENING OTHER I/O; CHANNELS AND USING THEM F>OR INPUT/OUTPUT OPERATIONS. THE DEFAULT INPUT DEVICE IS; 0, THE KEYBOARD. THE DEFAULT OUTPUT DEVICE IS 3, THE SCREEN.; IF ONE OF THE CHANNELS TO BE CLOSED IS TO THE SERIAL PORT, AN UNTALK SIGNAL IS SENT; FIRST TO CLEAR THE INPUT CHANNEL OR AN UNLISTE>N IS SENT TO CLEAR THE OUTPUT CHANNEL.; BY NOT CALLING THIS ROUTINE AND LEAVING LISTENER(S) ACTIVE ON THE SERIAL BUS,; SEVERAL DEVICES CAN RECEIVE THE SAME DATA FROM THE VIC AT THE SAME TIME. ONE WAY TO; TAKE ADVANTAGE OF THIS WOULD BE TO COMMAND THE >PRINTER TO TALK AND THE DISK TO; LISTEN. THIS WOULD ALLOW DIRECT PRINTING OF A DISK FILE.XXFFCC = *     JMP     (XX0322)          ; DO CLOSE VECTOR;************************************************************************************;; INPUT CHAR>ACTER FROM CHANNEL; THIS ROUTINE WILL GET A BYTE OF DATA FROM THE CHANNEL ALREADY SET UP AS THE INPUT; CHANNEL BY THE CHKIN ROUTINE, XXFFC6.; IF CHKIN, XXFFC6, HAS NOT BEEN USED TO DEFINE ANOTHER INPUT CHANNEL THE DATA IS; EXPECTED TO BE FROM THE K>EYBOARD. THE DATA BYTE IS RETURNED IN THE ACCUMULATOR. THE; CHANNEL REMAINS OPEN AFTER THE CALL.; INPUT FROM THE KEYBOARD IS HANDLED IN A SPECIAL WAY. FIRST, THE CURSOR IS TURNED ON; AND IT WILL BLINK UNTIL A CARRIAGE RETURN IS TYPED ON THE KEYBOARD.>	 ALL CHARACTERS; ON THE LOGICAL LINE, UP TO 88 CHARACTERS, WILL BE STORED IN THE BASIC INPUT BUFFER.; THEN THE CHARACTERS CAN BE RETURNED ONE AT A TIME BY CALLING THIS ROUTINE ONCE FOR; EACH CHARACTER. WHEN THE CARRIAGE RETURN IS RETURNED THE ENTIRE L>
INE HAS BEEN; PROCESSED. THE NEXT TIME THIS ROUTINE IS CALLED THE WHOLE PROCESS BEGINS AGAIN.XXFFCF = *     JMP     (XX0324)          ; DO INPUT VECTOR;************************************************************************************;; OUTPUT> A CHARACTER TO CHANNEL; THIS ROUTINE WILL OUTPUT A CHARACTER TO AN ALREADY OPENED CHANNEL. USE THE OPEN; ROUTINE, XXFFC0, AND THE CHKOUT ROUTINE, XXFFC9, TO SET UP THE OUTPUT CHANNEL; BEFORE CALLING THIS ROUTINE. IF THESE CALLS ARE OMITTED, DATA WIL>L BE SENT TO THE; DEFAULT OUTPUT DEVICE, DEVICE 3, THE SCREEN. THE DATA BYTE TO BE OUTPUT IS LOADED; INTO THE ACCUMULATOR, AND THIS ROUTINE IS CALLED. THE DATA IS THEN SENT TO THE; SPECIFIED OUTPUT DEVICE. THE CHANNEL IS LEFT OPEN AFTER THE CALL.; N>OTE: CARE MUST BE TAKEN WHEN USING ROUTINE TO SEND DATA TO A SERIAL DEVICE SINCE; DATA WILL BE SENT TO ALL OPEN OUTPUT CHANNELS ON THE BUS. UNLESS THIS IS DESIRED,; ALL OPEN OUTPUT CHANNELS ON THE SERIAL BUS OTHER THAN THE ACTUALLY INTENDED; DESTINATI>ON CHANNEL MUST BE CLOSED BY A CALL TO THE KERNAL CLOSE CHANNEL ROUTINE.XXFFD2 = *     JMP     (XX0326)          ; DO OUTPUT VECTOR;***********************************************************************************;;; LOAD RAM FROM A DEVICE; T>HIS ROUTINE WILL LOAD DATA BYTES FROM ANY INPUT DEVICE DIRECTLY INTO THE MEMORY; OF THE COMPUTER. IT CAN ALSO BE USED FOR A VERIFY OPERATION COMPARING DATA FROM A; DEVICE WITH THE DATA ALREADY IN MEMORY, LEAVING THE DATA STORED IN RAM UNCHANGED.; THE> ACCUMULATOR MUST BE SET TO 0 FOR A LOAD OPERATION OR 1 FOR A VERIFY. IF THE; INPUT DEVICE WAS OPENED WITH A SECONDARY ADDRESS OF 0 THE HEADER INFORMATION FROM; DEVICE WILL BE IGNORED. IN THIS CASE XY MUST CONTAIN THE STARTING ADDRESS FOR THE; LOAD. I>F THE DEVICE WAS ADDRESSED WITH A SECONDARY ADDRESS OF 1 OR 2 THE DATA WILL; LOAD INTO MEMORY STARTING AT THE LOCATION SPECIFIED BY THE HEADER. THIS ROUTINE; RETURNS THE ADDRESS OF THE HIGHEST RAM LOCATION WHICH WAS LOADED.; BEFORE THIS ROUTINE CAN B>E CALLED, THE SETLFS, XXFFBA, AND SETNAM, XXFFBD,; ROUTINES MUST BE CALLED.XXFFD5 = *     JMP     XXF542          ; LOAD RAM FROM A DEVICE;***********************************************************************************;;; SAVE RAM TO A DEVIC>E; THIS ROUTINE SAVES A SECTION OF MEMORY. MEMORY IS SAVED FROM AN INDIRECT ADDRESS; ON PAGE 0 SPECIFIED BY A, TO THE ADDRESS STORED IN XY, TO A LOGICAL FILE. THE; SETLFS, XXFFBA, AND SETNAM, XXFFBD, ROUTINES MUST BE USED BEFORE CALLING THIS; ROUTIN>E. HOWEVER, A FILE NAME IS NOT REQUIRED TO SAVE TO DEVICE 1, THE CASSETTE.; ANY ATTEMPT TO SAVE TO OTHER DEVICES WITHOUT USING A FILE NAME RESULTS IN AN ERROR.; NOTE: DEVICE 0, THE KEYBOARD, AND DEVICE 3, THE SCREEN, CANNOT BE SAVED TO. IF; THE ATTEM>PT IS MADE, AN ERROR WILL OCCUR, AND THE SAVE STOPPED.XXFFD8 = *     JMP     XXF675          ; SAVE RAM TO DEVICE;***********************************************************************************;;; SET THE REAL TIME CLOCK; THE SYSTEM CLOCK I>S MAINTAINED BY AN INTERRUPT ROUTINE THAT UPDATES THE CLOCK; EVERY 1/60TH OF A SECOND. THE CLOCK IS THREE BYTES LONG WHICH GIVES THE CAPABILITY; TO COUNT FROM ZERO UP TO 5,184,000 JIFFIES - 24 HOURS PLUS ONE JIFFY. AT THAT POINT; THE CLOCK RESETS TO Z>ERO. BEFORE CALLING THIS ROUTINE TO SET THE CLOCK THE NEW TIME,; IN JIFFIES, SHOULD BE IN YXA, THE ACCUMULATOR CONTAINING THE MOST SIGNIFICANT BYTE.XXFFDB = *     JMP     XXF767          ; SET REAL TIME CLOCK;**************************************>*********************************************;;; READ THE REAL TIME CLOCK; THIS ROUTINE RETURNS THE TIME, IN JIFFIES, IN AXY. THE ACCUMULATOR CONTAINS THE; MOST SIGNIFICANT BYTE.XXFFDE = *     JMP     XXF760          ; READ REAL TIME CLOCK;***>********************************************************************************;;; SCAN THE STOP KEY; IF THE STOP KEY ON THE KEYBOARD IS PRESSED WHEN THIS ROUTINE IS CALLED THE Z FLAG; WILL BE SET. ALL OTHER FLAGS REMAIN UNCHANGED. IF THE STOP KEY >IS NOT PRESSED THEN; THE ACCUMULATOR WILL CONTAIN A BYTE REPRESENTING THE LAST ROW OF THE KEYBOARD SCAN.; THE USER CAN ALSO CHECK FOR CERTAIN OTHER KEYS THIS WAY.XXFFE1 = *     JMP     (XX0328)          ; DO STOP KEY VECTOR;*********************>**************************************************************;;; GET A CHARACTER FROM AN INPUT DEVICE; IN PRACTICE THIS ROUTINE OPERATES IDENTICALLY TO THE CHRIN ROUTINE, XXFFCF,; FOR ALL DEVICES EXCEPT FOR THE KEYBOARD. IF THE KEYBOARD IS THE CURR>ENT INPUT; DEVICE THIS ROUTINE WILL GET ONE CHARACTER FROM THE KEYBOARD BUFFER. IT DEPENDS; ON THE IRQ ROUTINE TO READ THE KEYBOARD AND PUT CHARACTERS INTO THE BUFFER.; IF THE KEYBOARD BUFFER IS EMPTY THE VALUE RETURNED IN THE ACCUMULATOR WILL BE ZER>OXXFFE4 = *     JMP     (XX032A)          ; DO GET VECTOR;***********************************************************************************;;; CLOSE ALL CHANNELS AND FILES; THIS ROUTINE CLOSES ALL OPEN FILES. WHEN THIS ROUTINE IS CALLED, THE >POINTERS INTO; THE OPEN FILE TABLE ARE RESET, CLOSING ALL FILES. ALSO THE ROUTINE AUTOMATICALLY; RESETS THE I/O CHANNELS.XXFFE7 = *     JMP     (XX032C)          ; DO CLOSE ALL VECTOR;**************************************************************>*********************;;; INCREMENT THE REAL TIME CLOCK; THIS ROUTINE UPDATES THE SYSTEM CLOCK. NORMALLY THIS ROUTINE IS CALLED BY THE; NORMAL KERNAL INTERRUPT ROUTINE EVERY 1/60TH OF A SECOND. IF THE USER PROGRAM; PROCESSES ITS OWN INTERRUPTS THIS > ROUTINE MUST BE CALLED TO UPDATE THE TIME. ALSO,; THE STOP KEY ROUTINE MUST BE CALLED IF THE STOP KEY IS TO REMAIN FUNCTIONAL.XXFFEA = *     JMP     XXF734          ; INCREMENT REAL TIME CLOCK;******************************************************>!*****************************;;; RETURN X,Y ORGANIZATION OF SCREEN; THIS ROUTINE RETURNS THE X,Y ORGANISATION OF THE SCREEN IN X,Y;XXFFED     JMP     XXE505          ; RETURN X,Y ORGANIZATION OF SCREEN;******************************************>"*****************************************;;; READ/SET X,Y CURSOR POSITION; THIS ROUTINE, WHEN CALLED WITH THE CARRY FLAG SET, LOADS THE CURRENT POSITION OF; THE CURSOR ON THE SCREEN INTO THE X AND Y REGISTERS. X IS THE COLUMN NUMBER OF; THE CURSOR >#LOCATION AND Y IS THE ROW NUMBER OF THE CURSOR. A CALL WITH THE CARRY; BIT CLEAR MOVES THE CURSOR TO THE POSITION DETERMINED BY THE X AND Y REGISTERS.XXFFF0 = *     JMP     XXE50A          ; READ/SET X,Y CURSOR POSITION;***************************>$********************************************************;;; RETURN THE BASE ADDRESS OF THE I/O DEVICES; THIS ROUTINE WILL SET XY TO THE ADDRESS OF THE MEMORY SECTION WHERE THE MEMORY; MAPPED I/O DEVICES ARE LOCATED. THIS ADDRESS CAN THEN BE USED WIT>%H AN OFFSET TO; ACCESS THE MEMORY MAPPED I/O DEVICES IN THE COMPUTER.XXFFF3 = *     JMP     XXE500          ; RETURN BASE ADDRESS OF I/O DEVICES;***********************************************************************************;;; SPARE BYTES, >&NOT REFERENCED     .BYTE     $FF,$FF,$FF,$FF;***********************************************************************************;;; HARDWARE VECTORS     .WORD     XXFEA9          ; NMI VECTOR     .WORD     XXFD22          ; RESET VECTOR     .W ORD     XXFF72          ; IRQ VECTOR     .END;***********************************************************************************;;***********************************************************************************;;852244C454654245249474854244D0? ;18C00078E367E443424D424153494330C841C71DCDF7C8A4CBBECB0D53;18C01880D005CCA4C99FC870C827C91CC882C8D1C83AC92EC84AC90EE0;18C0302CD864E152E161E1B2D323D87FCA9FCA56C89BC65DC685CA0FE9;18C04826E1BAE1C3E17ACB41C639DCCCDC58DC00007DD39ED371DF0FB4;18C06094E0EAD?9EDDF61E268E2B1E20BE30DD87CD765D4ADD78BD711A0;18C078ECD600D72CD737D77969D87952D87B2ADA7B11DB7F7ADF500E65;18C090E8CF46E5CF7DB3DF5AD3CE6415D0454EC4464FD24E4558D40EE9;18C0A8444154C1494E505554A3494E5055D44449CD524541C44C450AE4;18C0C0D4474F54CF5255CE49C65?24553544F52C5474F5355C252450BE4;18C0D8545552CE5245CD53544FD04FCE574149D44C4F41C45341560BFF;18C0F0C55645524946D94445C6504F4BC55052494E54A35052494E0B49;18C108D4434F4ED44C4953D4434CD2434DC45359D34F5045CE434C0B9A;18C1204F53C54745D44E45D7544142A854CF46CE5?35043A85448450B4F;18C138CE4E4FD4535445D0ABADAAAFDE414EC44FD2BEBDBC5347CE0EAE;18C150494ED44142D35553D24652C5504FD35351D2524EC44C4FC70C6F;18C1684558D0434FD35349CE5441CE4154CE504545CB4C45CE53540BEE;18C18052A45641CC4153C3434852A44C454654A45249474854A44D0?AC8;18C1984944A447CF00544F4F204D414E592046494C45D346494C450932;18C1B0204F5045CE46494C45204E4F54204F5045CE46494C45204E08EC;18C1C84F5420464F554EC4444556494345204E4F5420505245534508C0;18C1E04ED44E4F5420494E5055542046494CC54E4F54204F5554500995;18C1F8555?42046494CC54D495353494E472046494C45204E414DC50955;18C210494C4C4547414C20444556494345204E554D4245D24E45580808;18C2285420574954484F555420464FD253594E5441D85245545552092A;18C2404E20574954484F555420474F5355C24F5554204F46204441082E;18C25854C1494C4C4547414?C205155414E544954D94F564552464C092E;18C2704FD74F5554204F46204D454D4F52D9554E4445462744205308E6;18C288544154454D454ED4424144205355425343524950D45245440945;18C2A0494D27442041525241D94449564953494F4E204259205A450879;18C2B852CF494C4C4547414C204449524543D?454595045204D49530953;18C2D04D415443C8535452494E4720544F4F204C4F4EC746494C450970;18C2E820444154C1464F524D554C4120544F4F20434F4D504C45D8095C;18C30043414E275420434F4E54494E55C5554E444546274420465507C5;18C3184E4354494FCE5645524946D94C4F41C49EC1ACC1B5C1C?2C10CF8;18C330D0C1E2C1F0C1FFC110C225C235C23BC24FC25AC26AC272C20FEA;18C3487FC290C29DC2AAC2BAC2C8C2D5C2E4C2EDC200C30EC31EC310E8;18C36024C383C30D4F4B0D000D204552524F520020494E20000D0A06C1;18C37852454144592E0D0A000D0A425245414B00A0BAE8E8E8E8BD0A40;18C39?	00101C981D021A54AD00ABD02018549BD0301854ADD0301D00A40;18C3A807A549DD0201F0078A186912AAD0D8602008C485318432380AAE;18C3C0A55AE55F8522A8A55BE560AAE898F023A55A38E522855AB00E7C;18C3D803C65B38A558E5228558B008C6599004B15A915888D0F9B10D51;18C3F05A9158C65BC65?
9CAD0F2600A693EB0358522BAE422902E600D55;18C408C4349028D004C533902248A2099848B557CA10FA2026D5A20B82;18C420F7689561E830FA68A868C4349006D005C533B00160A2106C0C65;18C43800038A0AAABD26C38522BD27C3852320CCFFA900851320D70B14;18C450CA2045CBA000B12248297F2047C?BC86810F4207AC6A969A00C01;18C468C3201ECBA43AC8F00320C2DDA976A0C3201ECBA9802090FF0DCB;18C4806C02032060C5867A847B207300AAF0F0A2FF863A900620790BBE;18C498C54CE1C7206BC92079C5840B2013C69044A001B15F8523A50C39;18C4B02D8522A5608525A55F88F15F18652D852D8524A52?E69FF850BB0;18C4C82EE560AA38A55FE52DA8B003E8C6251865229003C62318B10C21;18C4E0229124C8D0F9E623E625CAD0F22059C62033C5AD0002F0880E42;18C4F818A52D855A650B8558A42E845B9001C8845920B8C3A514A40BC9;18C510158DFE018CFF01A531A432852D842EA40B88B9FC01915F880B8F;1?8C52810F82059C62033C54C80C4A52BA42C8522842318A001B1220A6E;18C540F01DA004C8B122D0FBC8986522AAA0009122A5236900C8910CA2;18C558228622852390DD60A200200FE1C90DF00D9D0002E8E059900B49;18C570F1A2174C37C44CCACA6C0403A67AA004840FBD00021007C90A87;18C588FFF03EE8D?0F4C920F0378508C922F056240F702DC93FD0040DB8;18C5A0A999D025C9309004C93C901D8471A000840B88867ACAC8E80D19;18C5B8BD000238F99EC0F0F5C980D030050BA471E8C899FB01B9FB0F2F;18C5D001F03638E93AF004C949D002850F38E955D09F8508BD00020BCC;18C5E8F0DFC508F0DBC899FB01E8D?0F0A67AE60BC8B99DC010FAB911E3;18C6009EC0D0B4BD000210BE99FD01C67BA9FF857A60A52BA62CA00D6E;18C61801855F8660B15FF01FC8C8A515D15F9018F00388D009A5140C0F;18C63088D15F900CF00A88B15FAA88B15FB0D71860D0FDA900A8910DE4;18C6482BC8912BA52B186902852DA52C6900852E208?EC6A900D02D09E1;18C66020E7FFA537A43885338434A52DA42E852F843085318432200B04;18C6781DC8A219861668A868A2FA9A489848A900853E85106018A50B86;18C6902B69FF857AA52C69FF857B609006F004C9ABD0E9206BC9200DC4;18C6A813C6207900F00CC9ABD08E207300206BC9D0866868A514050B9?1;18C6C015D006A9FF85148515A001840FB15FF043202CC820D7CAC80C78;18C6D8B15FAAC8B15FC515D004E414F002B02C844920CDDDA920A40DC0;18C6F049297F2047CBC922D006A50F49FF850FC8F011B15FD010A80CA3;18C708B15FAAC8B15F865F8560D0B54C74C46C060310D7C9FFF0D30E33;18C720240F3?0CF38E97FAA8449A0FFCAF008C8B99EC010FA30F5C80E7F;18C738B99EC030B22047CBD0F5A980851020A5C9208AC3D0058A690D88;18C7500FAA9A6868A90920FBC32006C91898657A48A57B690048A50B1E;18C7683A48A53948A9A420FFCE208DCD208ACDA566097F256285620C1B;18C780A98BA0C7852284234C4?3CEA9BCA0D920A2DB207900C9A9D00DFB;18C79806207300208ACD202BDC2038CEA54A48A54948A98148202C09FF;18C7B0C8A57AA47BC002EAF004853D843EA000B17AD043A002B17A0D64;18C7C818D0034C4BC8C8B17A8539C8B17A853A98657A857A9002E60D42;18C7E07B6C080320730020EDC74CAEC7F03CE98?09011C923B0170A0BCC;18C7F8A8B90DC048B90CC0484C73004CA5C9C93AF0D64C08CFC94B0D93;18C810D0F9207300A9A420FFCE4CA0C838A52BE901A42CB00188850CBA;18C8284184426020E1FFB00118D03CA57AA47BA63AE8F00C853D840C8C;18C8403EA539A43A853B843C6868A981A0C390034C69C44C74C4D?00C57;18C85817A21AA43ED0034C37C4A53D857A847BA53BA43C8539843A0B23;18C8706008A9002090FF28D0034C59C62060C64C97C8A90320FBC30BF1;18C888A57B48A57A48A53A48A53948A98D4820790020A0C84CAEC70BE4;18C8A0206BC92009C938A539E514A53AE515B00B9838657AA67B900BC9;18C8B80?7E8B004A52BA62C2017C6901EA55FE901857AA560E900850BE8;18C8D07B60D0FDA9FF854A208AC39AC98DF00BA20C2CA2114C37C40DFB;18C8E84C08CF6868853968853A68857A68857B2006C99818657A850B72;18C9007A9002E67B60A23A2CA2008607A0008408A508A607850786097D;18C91808B17AF0E8C508F?0E4C8C922D0F3F0E9209ECD207900C9890F6A;18C930F005A9A720FFCEA561D0052009C9F0BB207900B0034CA0C80CBB;18C9484CEDC7209ED748C98DF004C989D091C665D004684CEFC7200E8C;18C9607300206BC9C92CF0EE6860A20086148615B0F7E92F8507A50C6A;18C978158522C919B0D4A5140A26220A262?265148514A52265158508B0;18C9901506142615A514650785149002E6152073004C71C9208BD008BA;18C9A88549844AA9B220FFCEA50E48A50D48209ECD682A2090CDD00CCC;18C9C018681012201BDC20BFD1A000A5649149C8A5659149604CD00BB5;18C9D8DB68A44AC0DFD04C20A6D6C906D03DA000846184668?471200DA1;18C9F01DCA20E2DAE671A471201DCA200CDCAAF005E88A20EDDAA40EAB;18CA0871C8C006D0DF20E2DA209BDCA664A463A5654CDBFFB122200E3F;18CA20800090034C48D2E92F4C7EDDA002B164C5349017D00788B10BA1;18CA3864C533900EA465C42E9008D00DA564C52DB007A564A4654C0B94;18C?A5068CAA000B1642075D4A550A451856F8470207AD6A961A0000C6E;18CA688550845120DBD6A000B1509149C8B1509149C8B1509149600CE6;18CA802086CA4CB5CB209ED7F005A92C20FFCE0886132015E1284C0C15;18CA98A0CA2021CB207900F035F043C9A3F050C9A618F04BC92CF00E34;18CAB037C93BF05E2?09ECD240D30DE20DDDD2087D42021CB203BCB0C6C;18CAC8D0D3A9009D0002A2FFA001A513D010A90D2047CB241310050AA3;18CAE0A90A2047CB49FF603820F0FF9838E90BB0FC49FF6901D0160D9E;18CAF8083820F0FF8409209BD7C929D0592890068AE5099005AAE80CC0;18CB10CAD0062073004CA2CA203BCBD?0F22087D420A6D6AAA000E80D0F;18CB28CAF0BCB1222047CBC8C90DD0F320E5CA4C28CBA513F003A90E49;18CB40202CA91D2CA93F2009E129FF60A511F0113004A0FFD004A50ADE;18CB583FA4408539843A4C08CFA513F005A2184C37C4A90CA0CD200AED;18CB701ECBA53DA43E857A847B6020A6D3C923D010207?300209ED70BEB;18CB88A92C20FFCE8613201BE1A201A002A9008D0102A940200FCC0A44;18CBA0A613D01360209ED7A92C20FFCE8613201BE120CECBA513200C1C;18CBB8CCFFA200861360C922D00B20BDCEA93B20FFCE2021CB20A60D15;18CBD0D3A92C8DFF0120F9CBA513F00D20B7FF2902F00620B5CB4C0D64?;18CBE8F8C8AD0002D01EA513D0E32006C94CFBC8A513D0062045CB0D4F;18CC00203BCB4C60C5A641A442A9982CA900851186438444208BD00B00;18CC188549844AA57AA47B854B844CA643A444867A847B207900D00BAF;18CC30202411500C2021E18D0002A2FFA001D00C3075A513D0032008E4;18CC4845CB20F?9CB867A847B207300240D103124115009E8867AA90A43;18CC60008507F00C8507C922F007A93A8507A92C188508A57AA47B0A61;18CC7869009001C8208DD420E2D720DAC94C91CC20F3DCA50E20C20D68;18CC90C9207900F007C92CF0034C4DCBA57AA47B85438444A54BA40C7B;18CCA84C857A847B207900F02D2? 0FDCE4C15CC2006C9C8AAD012A20C89;18CCC00DC8B17AF06CC8B17A853FC8B17AC8854020FBC8207900AA0E5D;18CCD8E083D0DC4C51CCA543A444A61110034C27C8A000B143F00B0C98;18CCF0A513D007A9FCA0CC4C1ECB603F45585452412049474E4F520B6B;18CD0845440D003F5245444F2046524F4D2053544?!152540D00D00406CF;18CD20A000F003208BD08549844A208AC3F005A20A4C37C49A8A180B40;18CD386904486906852468A00120A2DBBABD09018566A549A44A2009F8;18CD5067D820D0DBA001205DDCBA38FD0901F017BD0F018539BD100B91;18CD6801853ABD1201857ABD1101857B4CAEC78A6911AA9A2079000?"A4D;18CD80C92CD0F12073002024CD209ECD182438240D3003B00360B009E5;18CD98FDA2164C37C4A67AD002C67BC67AA20024488A48A90120FB0C91;18CDB0C32083CEA900854D20790038E9B19017C903B013C9012A490B22;18CDC801454DC54D9061854D2073004CBBCDA64DD02CB07B6907900B96;18CDE0776?#50DD0034C3DD669FF85220A6522A868D980C0B067208D0C6D;18CDF8CD482020CE68A44B1017AAF056D05F460D8A2AA67AD002C60C5C;18CE107BC67AA01B854DD0D7D980C0B04890D9B982C048B981C0480EE4;18CE282033CEA54D4CA9CD4C08CFA566BE80C0A8688522E62268850CBB;18CE40239848201BDCA5654?$8A56448A56348A56248A561486C22000A5E;18CE58A0FF68F023C964F003208DCD844B684A851268856968856A0CB7;18CE7068856B68856C68856D68856E4566856FA561606C0A03A9000AE3;18CE88850D207300B0034CF3DC2013D190034C28CFC9FFD00FA9A80C33;18CEA0A0CE20A2DB4C730082490FDAA1C92EF?%0DEC9ABF058C9AAF00F89;18CEB8D1C922D00FA57AA47B69009001C82087D44CE2D7C9A8D0130E0D;18CED0A018D03B20BFD1A56549FFA8A56449FF4C91D3C9A5D0034C0EB1;18CEE8F4D3C9B490034CA7CF20FACE209ECDA9292CA9282CA92CA00E4A;18CF0000D17AD0034C7300A20B4C37C4A01568684CFACD38A56?&4E90B7A;18CF1800A565E9C09008A987E564A9E3E56560208BD085648465A60DEC;18CF3045A446A50DF026A90085702014CF901CE054D018C0C9D0140BE4;18CF482084CF845E888471A006845DA0242068DE4C6FD460240E100AE3;18CF600DA000B164AAC8B164A88A4C91D32014CF902DE054D01BC00D11;18CF7?'849D0252084CF98A2A04C4FDC20DEFF866484638565A000840D3D;18CF906260E053D00AC054D00620B7FF4C3CDCA564A4654CA2DB0A0D4F;18CFA848AA207300E08F902020FACE209ECD20FDCE208FCD68AAA50DC4;18CFC06548A564488A48209ED768A88A484CD6CF20F1CE68A8B9EA0E71;18CFD8BF8555B9EBBF8@ 5562054004C8DCDA0FF2CA000840B20BFD10D5A;18CFF0A564450B8507A565450B850820FCDB20BFD1A565450B25080AD1;18D008450BA8A564450B2507450B4C91D32090CDB013A56E097F25096D;18D0206A856AA969A000205BDCAA4C61D0A900850DC64D20A6D6850C00;18D0386186628463A56CA46D20AAD6866@C846DAA38E561F008A9010CBF;18D0509004A661A9FF8566A0FFE8C8CAD007A666300F18900CB16C0D72;18D068D162F0EFA2FFB002A201E88A2A2512F002A9FF4C3CDC20FD0E46;18D080CEAA2090D0207900D0F460A200207900860C8545207900200A6D;18D09813D1B0034C08CFA200860D860E20730090052013D@1900BAA0974;18D0B020730090FB2013D1B0F6C924D006A9FF850DD010C925D0130D0E;18D0C8A510D0D0A980850E054585458A0980AA20730086463805100A3E;18D0E0E928D0034CD1D1A0008410A52DA62E8660855FE430D004C50CEB;18D0F82FF022A545D15FD008A546C8D15FF07D8818A55F690790E10DE8;1@8D110E8D0DCC9419005E95B38E9A5606848C92AD005A913A0DF600DA9;18D128A545A446C954D00BC0C9F0EFC049D0034C08CFC953D004C00DF4;18D14054F0F5A52FA430855F8460A531A432855A845B18690790010B55;18D158C88558845920B8C3A558A459C8852F8430A000A545915FC80CCA;18D170A546915FA@900C8915FC8915FC8915FC8915FC8915FA55F180D91;18D1886902A4609001C88547844860A50B0A6905655FA4609001C80A7A;18D1A08558845960908000000020BFD1A564A46560207300209ECD0AF3;18D1B8208DCDA566300DA561C9909009A9A5A0D1205BDCD07A4C9B0DA2;18D1D0DCA50C050E48A50D48A0009@848A54648A5454820B2D168850B10;18D1E84568854668A8BABD020148BD010148A5649D0201A5659D010A73;18D20001C8207900C92CF0D2840B20F7CE68850D68850E297F850C0AA5;18D218A62FA530865F8560C532D004E431F039A000B15FC8C545D00CD1;18D23006A546D15FF016C8B15F18655FAAC8B15F656@090D7A2122C0C83;18D248A20E4C37C4A213A50CD0F72094D1A50BA004D15FD0E74CEA0D4C;18D260D22094D12008C4A0008472A205A545915F1001CAC8A546910BC3;18D2785F1002CACA8671A50BC8C8C8915FA20BA900240C500868180AB4;18D2906901AA686900C8915FC88A915F204CD386718572A422C60B0C1@D;18D2A8D0DC6559B05D8559A88A65589003C8F0522008C4853184320CCB;18D2C0A900E672A471F005889158D0FBC659C672D0F5E65938A5310F5A;18D2D8E55FA002915FA532C8E560915FA50CD062C8B15F850BA9000D60;18D2F085718572C868AA8564688565D15F900ED006C88AD15F90070D99;18D3084C45D@24C35C4C8A572057118F00A204CD38A6564AA98A4220B9C;18D32065658671C60BD0CA8572A205A5451001CAA5461002CACA860BB1;18D33828A9002055D38A655885479865598548A8A547608422B15F0B1C;18D350852888B15F8529A910855DA200A0008A0AAA982AA8B0A4060B0D;18D368712672900B188A6528A@	A986529A8B093C65DD0E360A50DF00CB9;18D3800320A6D62026D538A533E531A8A534E532A200860D8562840B83;18D39863A2904C44DC3820F0FFA900F0EBA63AE8D0A0A2152CA21B0E27;18D3B04C37C420E1D320A6D320FACEA9808510208BD0208DCD20F70E01;18D3C8CEA9B220FFCE48A54848A54748A57B48A@
57A4820F8C84C4F0DC4;18D3E0D4A9A520FFCE098085102092D0854E844F4C8DCD20E1D3A50E3F;18D3F84F48A54E4820F1CE208DCD68854E68854FA002B14E8547AA0C9C;18D410C8B14EF0998548C8B147488810FAA44820D4DBA57B48A57A0DF5;18D42848B14E857AC8B14E857BA54848A54748208ACD68854E688@50C29;18D4404F207900F0034C08CF68857A68857BA00068914E68C8914E0AEF;18D45868C8914E68C8914E68C8914E60208DCDA00020DFDD6868A90D40;18D470FFA000F012A664A4658650845120F4D486628463856160A20D5A;18D4882286078608856F847085628463A0FFC8B16FF00CC507F0040CAA;18D4A0C@508D0F3C922F00118846198656F8571A6709001E88672A50D83;18D4B870F004C902D00B982075D4A66FA4702088D6A616E022D0050CE9;18D4D0A2194C37C4A5619500A5629501A5639502A00086648465840B8C;18D4E87088840D8617E8E8E8861660460F4849FF386533A434B0010BEC;18D50088C4329011D004C@531900B8533843485358436AA6860A2100A79;18D518A50F30B62026D5A980850F68D0D0A637A53886338534A0000B4B;18D530844F844EA531A632855F8660A919A20085228623C516F0050ABE;18D54820C7D5F0F7A9078553A52DA62E85228623E430D004C52FF00D22;18D5600520BDD5F0F385588659A9038553A@558A659E432D007C5310D06;18D578D0034C06D685228623A000B122AAC8B12208C8B1226558850B4D;18D59058C8B122655985592810D38A30D0C8B122A0000A690565220ADB;18D5A885229002E623A623E459D004C558F0BA20C7D5F0F3B122300E1A;18D5C035C8B1221030C8B122F02BC8B122AAC8B122C534900@6D01E0CD0;18D5D8E433B01AC5609016D004E45F9010865F8560A522A623854E0C55;18D5F0864FA5538555A55318652285229002E623A623A00060A54F0B1A;18D608054EF0F5A55529044AA88555B14E655F855AA5606900855B0B11;18D620A533A6348558865920BFC3A455C8A558914EAAE659A559C80D6A;18D@638914E4C2AD5A56548A564482083CE208FCD68856F688570A00C39;18D65000B16F1871649005A2174C37C42075D4207AD6A550A451200AC3;18D668AAD6208CD6A56FA47020AAD620CAD44CB8CDA000B16F48C80E7F;18D680B16FAAC8B16FA86886228423A8F00A4888B122913598D0F80DEA;18D69868186535853@59002E63660208FCDA564A4658522842320DB0B3F;18D6B0D608A000B12248C8B122AAC8B122A86828D013C434D00FE40CED;18D6C833D00B4818653385339002E634688622842360C418D00CC50AB4;18D6E017D0088516E9038517A0006020A1D78A48A901207DD468A00B6D;18D6F800916268684CCAD42061D7D15@0989004B150AA98488A48200CB5;18D7107DD4A550A45120AAD668A86818652285229002E62398208C0B77;18D728D64CCAD42061D718F15049FF4C06D7A9FF8565207900C9290D16;18D740F00620FDCE209ED72061D7F04BCA8A4818A200F150B0B6490D7E;18D758FFC56590B1A565B0AD20F7CE68A868855568686@8AA6885500E6E;18D770688551A555489848A0008A602082D74CA2D320A3D6A200860C44;18D7880DA8602082D7F008A000B122A84CA2D34C48D2207300208A0B7C;18D7A0CD20B8D1A664D0F0A6654C79002082D7D0034CF7D8A67AA40ECA;18D7B87B86718472A622867A1865228524A623867B9001E88625A00BAD@;18D7D000B1244898912420790020F3DC68A0009124A671A472867A0B9B;18D7E8847B60208ACD20F7D720FDCE4C9ED7A566309DA561C991B00F2F;18D80097209BDCA564A4658414851560A51548A5144820F7D7A0000B53;18D818B114A86885146885154CA2D320EBD78AA00091146020EBD70C2C;18D8308649A20@0207900F00320F1D7864AA000B114454A2549F0F80B1F;18D84860A911A0DF4C67D8208CDAA56649FF8566456E856FA5614C0D19;18D8606AD82099D9903C208CDAD0034CFCDBA6708656A269A569A80E1F;18D878F0CE38E561F02490128461A46E846649FF6900A0008456A20D08;18D89061D004A0008470C9F930C@7A8A570560120B0D9246F1057A00C59;18D8A861E069F002A0693849FF65568570B90400F5048565B903000BC9;18D8C0F5038564B90200F5028563B90100F5018562B0032047D9A00B55;18D8D8009818A662D04AA6638662A6648663A6658664A6708665840CF8;18D8F0706908C920D0E4A90085618566606556857@0A565656D85650CAE;18D908A564656C8564A563656B8563A562656A85624C36D96901060B04;18D92070266526642663266210F238E561B0C749FF69018561900E0AD4;18D938E661F0426662666366646665667060A56649FF8566A562490C8C;18D950FF8562A56349FF8563A56449FF8564A56549FF8565A570490@E33;18D968FF8570E670D00EE665D00AE664D006E663D002E66260A20F0E3A;18D9804C37C4A225B4048470B4039404B4029403B4019402A468940AB2;18D99801690830E8F0E6E908A8A570B01416019002F601760176010AE9;18D9B07602760376046AC8D0EC18608100000000037F5E56CB798009ED;18D9C8139@B0B6480763893168238AA3B20803504F334813504F3340A2D;18D9E0808000000080317217F8202BDCF00210034C48D2A561E97F0B03;18D9F848A9808561A9D6A0D92067D8A9DBA0D9200FDBA9BCA0D9200F9C;18DA1050D8A9C1A0D92040E0A9E0A0D92067D868207EDDA9E5A0D90F98;18DA28208CDAD0034C8BDA2@0B7DAA9008526852785288529A570200B65;18DA4059DAA5652059DAA5642059DAA5632059DAA562205EDA4C8F0CB3;18DA58DBD0034C83D94A0980A8901918A529656D8529A528656C850B4D;18DA7028A527656B8527A526656A8526662666276628662966709809BB;18DA884AD0D66085228423A004B122856D88B@122856C88B122856B0C18;18DAA088B122856E4566856FA56E0980856A88B1228569A56160A50C5E;18DAB869F01F1865619004301D182C101469808561D0034CFBD8A50AAF;18DAD06F856660A56649FF300568684CF7D84C7ED9200CDCAAF0100D44;18DAE8186902B0F2A200866F2077D8E661F0E76084200000002@00C0B53;18DB00DCA9F9A0DAA200866F20A2DB4C12DB208CDAF076201BDCA90E04;18DB180038E561856120B7DAE661F0BAA2FCA901A46AC462D010A40E11;18DB306BC463D00AA46CC464D004A46DC465082A9009E89529F0320C68;18DB481034A90128B00E066D266C266B266AB0E630CE10E2A8A56D0A75;18DB6@0E565856DA56CE564856CA56BE563856BA56AE562856A984C0E4B;18DB784FDBA940D0CE0A0A0A0A0A0A8570284C8FDBA2144C37C4A50ACD;18DB90268562A5278563A5288564A52985654CD7D885228423A0040B9F;18DBA8B122856588B122856488B122856388B122856609808562880C1D;18DBC0B122856184706@0A25C2CA257A000F004A649A44A201BDC860BF1;18DBD8228423A004A565912288A564912288A563912288A566097F0B97;18DBF02562912288A5619122847060A56E8566A205B5689560CAD00D03;18DC08F9867060201BDCA206B5609568CAD0F9867060A561F0FB060DFC;18DC207090F7206FD9D0F24C38D9A561F@009A5662AA9FFB002A9010DCA;18DC3860202BDC8562A9008563A288A56249FF2AA90085658564860BD0;18DC5061857085664CD2D846666085248425A000B124C8AAF0C4B10D25;18DC6824456630C2E461D021B1240980C562D019C8B124C563D0120C68;18DC80C8B124C564D00BC8A97FC570B124E565F028A5669@ 00249FF0E56;18DC984C31DCA561F04A38E9A024661009AAA9FF8568204DD98AA20D3A;18DCB061C9F910062099D9846860A8A566298046620562856220B00BDD;18DCC8D9846860A561C9A0B020209BDC8470A566846649802AA9A00DDC;18DCE08561A56585074CD2D88562856385648565A860A000A20A940CD0;1@!8DCF85DCA10FB900FC92DD0048667F004C92BD005207300905BC90C78;18DD102EF02EC945D0302073009017C9ABF00EC92DF00AC9AAF0080C66;18DD28C92BF004D0076660207300905C2460100EA90038E55E4C49097C;18DD40DD665F245F50C3A55E38E55D855EF012100920FEDAE65ED00CF4;18DD58F9F00720E@"2DAC65ED0F9A5673001604CB4DF48245F1002E60D45;18DD705D20E2DA6838E930207EDD4C0ADD48200CDC68203CDCA56E0C08;18DD884566856FA6614C6AD8A55EC90A9009A964246030114C7ED90B95;18DDA00A0A18655E0A18A000717A38E930855E4C30DD9B3EBC1FFD0A6F;18DDB89E6E6B27FD9E6E6B2800A97@#1A0C320DADDA53AA6398562860D66;18DDD063A290382049DC20DFDD4C1ECBA001A92024661002A92D990B5D;18DDE8FF0085668471C8A930A661D0034C04DFA900E080F002B0090D1A;18DE00A9BDA0DD2028DAA9F7855DA9B8A0DD205BDCF01E1012A9B30E3E;18DE18A0DD205BDCF002100E20E2DAC65DD0EE20FED@$AE65DD0DC200EB6;18DE3049D8209BDCA201A55D18690A3009C90BB00669FFAAA902380AC6;18DE48E902855E865D8AF0021013A471A92EC899FF008AF006A9300C33;18DE60C899FF008471A000A280A565187919DF8565A5647918DF850CE8;18DE7864A5637917DF8563A5627916DF8562E8B00410DE300230DA0C5@%3;18DE908A900449FF690A692FC8C8C8C88447A471C8AA297F99FF000DA9;18DEA8C65DD006A92EC899FF008471A4478A49FF2980AAC024F0040DAB;18DEC0C03CD0A6A471B9FF0088C930F0F8C92EF001C8A92BA65EF00FD6;18DED82E1008A90038E55EAAA92D990101A9459900018AA22F38E80A56;18DEF0E90AB@&0FB693A9903018A990201A900990401F00899FF00A90B6A;18DF0800990001A900A001608000000000FA0A1F0000989680FFF00883;18DF20BDC0000186A0FFFFD8F0000003E8FFFFFF9C0000000AFFFF0E0D;18DF38FFFFFFDF0A8000034BC0FFFF736000000E10FFFFFDA800000D35;18DF50003CBFAAAAAAAAAAAAA@'AAAAAAAAAAAAAAAAAAAAAAAAAAAAA1034;18DF68AAAAAAAAAAAAAAAAAA200CDCA911A0DF20A2DBF070A569D00F75;18DF80034CF9D8A24EA00020D4DBA56E100F20CCDCA94EA000205B0C02;18DF98DCD00398A40720FEDB984820EAD9A94EA0002028DA20EDDF0DE2;18DFB0684A900AA561F006A56649FF856660813A 8AA3B29077134580B58;18DFC83E5674167EB31B772FEEE3857A1D841C2A7C6359580A7E750B13;18DFE0FDE7C680317218108100000000A9BFA0DF2028DAA57069500C24;18DFF890032023DC8556200FDCA561C988900320D4DA20CCDCA5070CB3;18E010186981F0F338E90148A205B569B46195619469CA10F5A55A60CEE;18E02885702053D820B4DFA9C4A0DF2056E0A900856F6820B9DA600D6D;18E0408571847220CADBA9572028DA205AE0A957A0004C28DA85710C49;18E058847220C7DBB1718567A471C898D002E6728571A4722028DA0DE3;18E070A571A4721869059001C8857184722067D8A95CA000C667D00C60;18E088EA4609835447A006828B14600202BDC3037D02020F3FF86220B0E;18E0A08423A004B1228562C8B1228564A008B1228563C8B12285650C09;18E0B84CE0E0A98BA00020A2DBA98AA0E02028DAA98FA0E02067D80F19;18E0D0A665A56285658662A663A56485638664A9008566A56185700D1F;18E0E8A980856120D7D8AA28BA0004CD4DBC9F0D007843886374C630E3E;18E100C6AAD002A21E4C37C420D2FFB0E86020CFFFB0E26020C9FF0EF3;18E118B0DC6020C6FFB0D66020E4FFB0D060208ACD20F7D7A9E1480FE2;18E130A94348AD0F0348AD0C03AE0D03AC0E03286C1400088D0C0306E7;18E1488E0D038C0E03688D0F036020D1E1AA62DA42EA92B20D8FFB00AD5;18E1609560A9012CA900850A20D1E1A50AA62BA42C20D5FFB057A50C1E;18E1780AF01AA21C20B7FF2910F0034C37C4A57AC902F007A964A00C1A;18E190C34C1ECB6020B7FF29BFF005A21D4C37C4A57BC902D00E860CE9;18E1A82D842EA976A0C3201ECB4C2AC5208EC64C76E42016EA220C00C58;18E1C0FFB00B602016E2A54920C3FF90C64CF6E0A90020BDFFA2010E5B;18E1D8A00020BAFF2003E22054E22003E220FDE1A000864920BAFF0CF0;18E1F02003E220FDE18AA8A6494CBAFF200BE24C9ED7207900D0020D4B;18E20868686020FDCE207900D0F74C08CFA90020BDFF200EE2209E0BF3;18EA220D786498AA201A00020BAFF2003E220FDE1864AA000A549E00CA7;18E2380390018820BAFF2003E220FDE18AA8A64AA54920BAFF20030C36;18E250E2200BE2209ECD20A3D6A622A4234CBDFFA9DDA0E22067D80E5B;18E268200CDCA9E2A0E2A66E2007DB200CDC20CCDCA900856F20530C6D;18E280D8A9E7A0E22A050D8A56648100D2049D8A5663009A51249FF0CA0;18E298851220B4DFA9E7A0E22067D868100320B4DFA9ECA0E24C400E1E;18E2B0E020CADBA90085122068E2A24EA00020F3E0A957A00020A20CDE;18E2C8DBA9008566A51220D9E2A94EA0004C0FDB484C9AE281490F0C79;18E2E0DAA283490FDAA27F000000000A584E61A2D1B862807FBF8870B2C;18E2F899688901872335DFE186A55DE72883490FDAA2A5664810030C70;18E31020B4DFA56148C9819007A9BCA0D9200FDBA93BA0E32040E00D7C;18E32868C9819007A9DDA0E22050D86810034CB4DF600B76B383BD0CEA;18E340D3791EF4A6F57B83FCB0107C0C1F67CA7CDE53CA	BC17D14640DF4;18E358704C7DB7EA517A7D6330887E7E9244993A7E4CCC91C77FAA0D4C;18E370AAAA138100000000205BE420A4E32004E4A2FB9A4C74C4E60C02;18E3887AD002E67BAD60EAC93AB00AC920F0EF38E93038E9D060800ECE;18E3A04FC75258A94C85548500A948A0D285018402A991A0D385050C54A
;18E3B88406A9AAA0D185038404A21CBD87E39573CA10F8A90385530D54;18E3D0A900856885138518A2018EFD018EFC01A219861638209CFF0B9A;18E3E8862B842C382099FF8637843886338434A00098912BE62BD00BF3;18E40002E62C60A52BA42C2008C4A936A0E4201ECBA53738E52BAA0B36;18E418A538E52AC20CDDDA929A0E4201ECB4C44C6204259544553200B48;18E430465245450D00932A2A2A2A2043424D20424153494320563206B2;18E448202A2A2A2A0D003AC483C47CC51AC7E4C786CEA20BBD4FE40C1C;18E4609D0003CA10F76020CCFFA9008513207AC6584C74C4E820330BD0;18E478C54C77C6FFFFFFFFFFFFFAFFFFFFFFFFFFFFFFFFFFFFFFFFF17AE;18E490FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFAD2C9129DF8D2C911538;18E4A860AD2C9109208D2C9160AD1F91CD1F91D0F84A60A6B94C470C7F;18E4C0F68AD008A5C385AEA5C485AF4C6AF620E3F8900368A9004C0EE3;18E4D89EF3FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFAFFFFFFFFFFFFF194F;18E4F0FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFA210A09160A216A01577;18E5081760B00786D684D32087E5A6D6A4D36020BBE5AD880229FD0DE2;18E5200A0A09808D0590AD88022902F008A9800D02908D0290A90008C6;18E5388D910285CFA9DC8D8F02A9EB8D9002A90A8D89028D8C02A90AC8E;18E550068D8602A9048D8B02A90C85CD85CCAD88020980A8A900AA0B42;18E56894D91869169001C8E8E018D0F3A9FF95D9A216208DEACA100EA4;18E580FAA00084D384D6A6D6A5D3B4D9300818691685D3CA10F4B50EF3;18E598D929030D880285D2BDFDED85D1A915E8B4D93006186916E80D6D;18E5B010FA685D56020BBE54C81E5A903859AA9008599A210BDE3ED0EB0;18E5C89DFF8FCAD0F760AC7702A200BD78029D7702E8E4C6D0F5C61012;18E5E0C6985818602042E7A5C685CC8D9202F0F778A5CFF00CA5CE0F73;18E5F8AE8702A00084CF20A1EA20CFE5C983D010A2097886C6BDF30EE9;18E610ED9D7602CAD0F7F0CAFC90DD0C8A4D584D0B1D1C920D003881061;18E628D0F7C884C8A0008C920284D384D4A5C9301DA6D62019E7E40EAB;18E640C9D014D012A5CA85D3C5C8900AB04298488A48A5D0F091A40EF9;18E658D3B1D1EAEAEAEAEAEAEAEAEAEAEAEAEAEAEAEAEAEAEAEAEA16DD;18E670EAEA85D7293F06D724D710020980900A4A6D4D004700209400B16;18E688E6D320B8E6C4C8D017A90085D0A90DA699E003F006A69AE00F5C;18E6A003F0032042E7A90D85D768AA68A8A5D7C9DED002A9FF18600E26;18E6B8C922D008A5D4490185D4A922600940A6C7F0020980A6D8F00D5F;18E6D002C6D8AE860220A1EA20EAE668A8A5D8F00246D468AA6A8180E6A;18E6E8586020FAE8E6D3A5D5C5D3B037C957F02AAD9202F0034CF00FFC;18E700E9A6D6E01790072075E9C6D6A6D616D956D94C5BED6916850E3E;18E718D5B5D93003CAD0F94C7EEAC6D620C3E8A90085D360A6D6D01008;18E7300686D36868D0A5CA86D62087E5A4D584D3604885D78A48980EC3;18E74A848A90085D0A4D3A5D710034C00E8C90DD0034CD8E8C920900CF5;18E76010C960900429DFD002293F20B8E64CC7E6A6D8F0034CCBE60D93;18E778C914D02E98D006202DE74C9FE720E8E88884D320B2EAC8B10ECA;18E790D18891D1C8B1F38891F3C8C4D5D0EFA92091D1AD860291F311C6;18E7A8104DA6D4F0034ACCBE6C912D00285C7C913D0032081E5C91D0D82;18E7C0D017C820FAE884D388C4D59009C6D620C3E8A00084D34CDC1007;18E7D8E6C911D01D18986916A8E6D6C5D590ECF0EAC6D6E91690041036;18E7F085D3D0F820C3E84CDCE62012E94C21EDEAEAEAEAEAEAEAEA12AD;18E808EAEAEAEAEAEAEAEAEAEAEAEAEA2A97FC97FD002A95EEAEAEA1371;18E820EAEAEAC92090034CC5E6C90DD0034CD8E8A6D4D03FC914D00F3C;18E83837A4D5B1D1C920D004C4D3D007C057F02420EEE9A4D520B20F02;18E850EA88B1D1C891D188B1F3C891F388C4D3D0EFA92091D1AD861222;18E8680291F3E6D84CDCE6A6D8F00509404CCBE6C911D01A6A6D6F00F9F;18E88037C6D6A5D338E916900485D3102A2087E5D025C912D004A90D01;18E8980085C7C91DD01298F00920E8E88884D34CDCE6202DE74CDC0E76;18E8B0E6C913D006205FE54CDCE609802012E94C30ED46C9A6D6E80E3A;18E8C8E017D0032075E9B5D910F486D64C87E5A20086D886C786D40F5D;1A8E8E086D320C3E84CDCE6A204A900C5D3F007186916CAD0F660C60F3D;18E8F8D660A204A915C5D3F007186916CAD0F660A6D6E017F002E60EF3;18E910D660A207DD21E9F004CA10F8608E86026090051C9F9C1E1F0B9C;18E9289EEFA1DFA6E1B1E2B2E3B3E4B4E5B5E6B6E7B7E8B8E9B9FA1440;18E940BAFBBBFCBACECBDFEBE84BFF7C0F8DBF9DDEADE5EE05BE15D1410;18E958E240B061B178DB79DD66B677C070F071F172F273F374F47510A2;18E970F576F67DFDA5AC48A5AD48A5AE48A5AF48A2FFC6D6C6C9C61148;18E988F2E8207EEAE016B00CBDFEED85ACB5DA2056EA30EC208DEA1018;18E9A0A200B5D9297FB4DA1002098A095D9E8E016D0EFA5EF0980850E4F;18E9B8EFA5D910C4E6D6E6F2A9FB8D2091AD2191C9FE08A9F78D2010EB;18E9D09128D00BA000EACAD0FC88D0F984C6A6D66885AF6885AE68103B;18E9E885AD6885AC60A6D6E8B5D910FB86F2E016F00D900B2075E90F95;18EA00A6F2CAC6D64C0EE7A5AC48A5AD48A5AE48A5AAF48A217CA200E4E;18EA187EEAE4F2900EF00CBDFCED85ACB5D82056EA30EA208DEAA21009;18EA3015E4F2900FB5DA297FB4D91002098095DACAD0EDA6F2200E0DD7;18EA48E76885AF6885AE6885AD6885AC6029030D880285AD206EEA0C68;18EA60A015B1AC91D1B1AE91F38810F56020B2EAA5AC85AEA5AD290F6A1;18EA7803099485AF60BDFDED85D1B5D929030D880285D260A015200C88;18EA907EEA20B2EAA92091D1A90191F38810F560A8A90285CD20B20E73;18EAA8EA98A4D391D18A91F360A5D185F3A5D22903099485F460200F9A;18EAC0EAFFA5CCD029C6CDD025A91485CDA4D346CFAE8702B1D1B010A1;18EAD811E6CAF85CE20B2EAB1F38D8702AE8602A5CE498020AAEAAD0F3C;18EAF01F912940F00BA00084C0AD1C910902D009A5C0D00DAD1C910BC4;18EB0829FD2C1E9170038D1C91201EEB2C249168A868AA6840A9000A36;18EB208D8D02A04084CB8D2091AE2191E0FFF05EA9FE8D2091A0000DBE;18EB38A95E85F5A9EC85F6A20A8AD2191CD2191D0F64AB01648B1F50F18;18EB50C905B00CC903F0080D8D028D8D02100284CB68C8C041B0090AA4;18EB68CAD0DF382E2091D0CF6C8F02A4CBB1F5AAC4C5F007A0108C0F12;18EB808C02D036297F2C8A0230167049C97FF029C914F00CC920F00B89;18EB9808C91DF004C911D035AC8C02F005CE8C0A2D02BCE8B02D0260C33;18EBB0A0048C8B02A4C688101CA4CB84C5AC8D028C8E02E0FFF00E0D7A;18EBC88AA6C6EC8902B0069D7702E886C6A9F78D209160AD8D02C90E7B;18EBE003D02CCD8E02F0EEAD91023056EAEAEAEAEAEAEAEAEAEAEA11F1;18EBF8EAEAEAEAEAEAEAEAAD059049028D0590EAEAEAEA4C43EC0AA1127;18EC10C9089004A906EAEAEAEAEAEAEAEAEAEAEAEAEAEAEAEAEAEA139C;18EC28EAEAEAEAEAEAEAEAEAEAEAEAEAEAEAEAAABD46EC85F5BD4714E3;18EC40EC85F64C74EB5EEC9FECE0ECA3ED5EEC9FEC69EDA3ED21ED1250;18EC5869ED69EDA3ED31333537392B5C145F57525949502A0D044109B2;18EC704A 4474A4C3B1D030158564E2C2F11205A43424D2E0185025306AE;18EC8846484B3A3D86514554554F405E8732343638302D1388FF210901;18ECA023252729DBA9945FD7D2D9C9D0C08D04C1C4C7CACC5D9D830F7E;18ECB801D8D6CE3C3F91A0DAC3C2CD3E018902D3C6C8CB5B3D8AD10EFA;18ECD0C5D4D5CFBADE8B2A!224262830DD938CFF2123252729A6A8940D8E;18ECE85FB3B2B7A2AFDF8D04B0ACA5B5B65D9D8301BDBEAA3C3F910F43;18ED00A0ADBCBFA73E018902AEBBB4A15B3D8AABB1A3B8B9A4DE8B0E9B;18ED182224262830DC938CFFC90ED00BA9020D05908D05904CDCE60B0A;18ED30C98ED00BA9FD2D05908D05904CDCEA"6C908D00AA9800D91020C73;18ED488D910230EFC909D0EBA97F2D91028D910210E1E8B5D909800D11;18ED6095D9CAA5D5184C15E7FFFFFFFFFFFFFFFFFF04FFFFFFFFFF146D;18ED78E29D8301FFFFFFFFFF91A0FFFFFFFFEE018902FFFFFFFFE113FF;18ED90FD8AFFFFFFFFFFB0E08BF2F4F6FFF0ED938CFF901C9A#C1F121381;18EDA8FFFFFF06FF12FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF17AF;18EDC0FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF19AD;18EDD8FFFFFF059F1E9E92FFFFFFFF0C26162E00C00000000000000BFE;18EDF00000001B4C4F41440D52554E0D00162C42586E849AB0C6DC08F9;18EA$E08F2081E344A60768CA2B8CEE409402C09202060F1482494100A31;18EE200A3866A32049EE469446A368859520A0E4C93FD0032084EF0C1F;18EE38AD1F9109808D1F91208DEF20A0E42096EF7820A0E420B2E40D18;18EE504AB0612084EF24A3100C20B2E44A90FA20B2E44AB0FA20B20D2D;18EE68E44A90FA208A%DEFA90885A5AD1F91CD1F91D0F84A4A9038660E01;18EE8095B00520A9E4D00320A0E42084EFEAEAEAEAAD2C9129DF090EAA;18EE98028D2C91C6A5D0D3A9048D2991AD2D912920D00B20B2E44A0C7B;18EEB0B0F35860A9802CA903206AFE5818904985952040EEAD1F910CA8;18EEC8297F8D1F916085952040EE782A&0A9E420C5EE2084EF20B2E40DBC;18EEE0B0FB586024943005386694D005482049EE6885951860208D0B83;18EEF8EFAD1F9109808D1F91A95F2CA93F201CEE20C5EE8AA20BCA0D2A;18EF10D0FDAA2084EF4CA0E478A90085A52084EF20B2E490FB20A00ED0;18EF28E4A9018D2991AD2D912920D00720B2E4B0F4901A'8A5A5F0050CD0;18EF40A9024CB9EE20A9E4200CEFA940206AFEE6A5D0D5A90885A50E29;18EF58AD1F91CD1F91D0F84A90F54A66A4AD1F91CD1F91D0F84AB00EC0;18EF70F5C6A5D0E320A9E4A590F003200CEFA5A4581860AD2C91290E26;18EF88FD8D2C9160AD2C9109028D2C9160A9048D2991AD2D9129200AFDB ;18EFA0F0F960A5B4F047303F46B6A2009001CA8A45BD85BDC6B4F00F20;18EFB8068A292085B560A9202C9402F014301C7014A5BDD001CAC60B54;18EFD0B4AD930210E3C6B4D0DFE6B4D0F0A5BDF0EDD0EA70E950E612CB;18EFE8E6B4A2FFD0CBAD94024A90072C2091101D501EA90085BD850CD1;18F000B5AE980B286B4AC9D02CC9E02F013B1F985B6EE9D0260A9400DB4;18F0182CA9100D97028D9702A9408D1E9160A209A9202C9302F001097C;18F030CA5002CACA60A6A9D02EC6A8F031300DA5A745AB85AB46A70DBA;18F04866AA60C6A8A5A7F062AD93020AA90165A8D0EFA9908D1E910E03;18F06085A9A9208D1E9160A5A7DB0EF85A960AC9B02C8CC9C02F02A0E29;18F0788C9B0288A5AAAE9802E009F0044AE8D0F891F7A9202C94020DB2;18F090F0B930B6A5A745ABF00370AE2C50ABA9012CA9042CA9802C0C9F;18F0A8A9020D97028D97024C5BF0A5AAD0F1F0EC4C96F7859AAD940EE3;18F0C0024A9027A9022C1091101DD01EAD1E91293B0D0F92C1091700A19;18F0D8FBAD109109028D10912C1091700530F92016F01860AC9E020AB7;18F0F0C8CC9D02F0F78C9E028891F92C1E91500160AD99028D14910D56;18F108AD9A028D1591A9C08D1E914CEEEF8599AD94024A902829080BEF;18F120F024A9022C109110BFF0192C1E9170FBAD109129FD8D10910BB75;18F138AD10912904F0F9A9908D1E911860AD1E912930F0F21860AC0C4D;18F1509C02CC9B02F006B1F7EE9C0260A9006048AD1E91F00CAD1E0C5E;18F168912960D0F9A9108D1E9168600D492F4F204552524F5220A30A52;18F1800D534541524348494E47A0464F52A00D505245535320504C08A7;18F198415B9204F4E20544150C55052455353205245434F524420260874;18F1B020504C4159204F4E20544150C50D4C4F4144494EC70D534108C2;18F1C856494E47A00D564552494659494EC70D464F554E44A00D4F096A;18F1E04B8D249D100DB974F108297F20D2FFC82810F31860A599D00CD7;18F1F808A5C6F06D784CCFEB5C902D0188497204FF1A4971860A5990E68;18F210D00BA5D385CAA5D685C94C4FE6C903D00985D0A5D585C84C0F13;18F2284FE6B038C902F03F86972050F2B016482050F2B00DD005A90C73;18F24040206AFEC6A6A6976860AA688AA69760208AF8D00B20C0F80E11;18F258B011A90085A6F0F0B1B21860A590F00B4A90D18604C19EF200C7D;18F27005F2B005C900F0F7186048A59AC903D004684C42E79004680C4E;18F2884CE4EEC902F02A68859E488A489848208AF8D00E20E3F8B00E45;18F2A00EA902A00091B2C884A6A59E91B21868A868AA689002A9000C9B;18F2B860688697849E20EDF0A697A49E186020CFF3F0034C84FB7200E79;18F2D0DFF3A5BAF016C903F012B014C902D0034C16F1A6B9E060F00F23;18F2E8034C8DF785991860AA2014EEA5B9100620D3EE4C01F320CE0CAA;18F300EE8A249010E64C8AF720CFF3F0034C84F720DFF3A5BAD0030EBA;18F3184C90F7C903F00FB011C902D0034CBCF0A6B9E060F0EA859A0EB0;18F33B	01860AA2017EEA5B9100520C5EED00320C0EE8A249010E74C0BEA;18F3488AF720D4F3F002186020DFF38A48A5BAF057C903F053B04E0E9C;18F360C902D0296820B2F3A97D8D1E91A9068D1091A9EE8D1C91200C8C;18F37875FEA5F8F001C8A5FAF001C8A90085F885FA4C3CF5A5B929104D;18F3900FF01E204DF8AB
9002090F24CCFE4B02EA5B9C962D00BA9050D57;18F3A820E7F74CB1F320DAF668AAC698E498F014A498B959029D590FC7;18F3C002B963029D6302B96D029D6D021860A90085908AA698CA300B19;18F3D815DD5902D0F860BD590285B8BD630285BABD6D0285B960A90D81;18F3F0008598A203E49AB0032004EFE49B9B00320F6EE869AA900850D83;18F4089960A6B8D0034C8DF720CFF3D0034C81F7A698E00A90034C0D8E;18F4207EF7E698A5B89D5902A5B9096085B99D6D02A5BA9D6302F00DD6;18F4385AC903F05690052095F4904FC902D0034CC7F4204DF8B0030C8A;18F4504C96F7A5B9290FD01F2094F8B0362047F6A5B7F00BA2067F80D7E;18F4689018F0284C87F720AFF7F020900CB0F420B7F8B017A904200D77;18F480E7F7A9BFA4B9C060F007A000A90291B29885A61860A5B9300E9D;18F4982CA4B7F028A5BA2017EEA5B909F020C0EEA590100568684C0D52;18F4B08AF7A5B7F00CA000B1BB20E4EEC8C4B7D0F62004EF1860A90FD0;1B8F4C8068D12918D1091A9EE8D1C91A0008C9702C4B7F00AB1BB990D48;18F4E09302C8C004D0F22027F08E9802AD9302290FD0000AAABD5A0C43;18F4F8FF0AA8BD5BFF2A489869C88D99026869008D9A02AD94024A0CB6;18F5109009AD20910AB0034C16F0AD9B028D9C02AD9E028D9D02200A31;18F52875FEA5F8DB0058884F886F7A5FAD0058884FA86F938A9F04C10B1;18F5407BFE86C384C46C30038593A9008590A5BAD0034C96F7C9030DA3;18F558F0F9906EA4B7D0034C93F720BCE4A96085B92095F4A5BA200F7F;18F57014EEA5B920CEEE2019EF85AEA5904A4AB0452019EF85AF200D4E;18F588C1E4A9FD2590859020E1FFDB0034CCBF62019EFAAA5904A4A0F25;18F5A0B0E88AA493F00CA000D1AEF008A910206AFE2C91AEE6AED00F29;18F5B802E6AF249050CB20F6EE20DAF6907A4C87F7C902D0034CB90E96;18F5D0F0204DF8B0034C96F72094F8B0682047F6A5B7F0092067F80EB3;18F5E8900BF05AB0D920AFF7F053B0D2A590291038DB04AE001F0110E90;18F600E003D0DDA001B1B285C3C8B1B285C4B004A5B9D0EFA003B10F83;18F618B2A001F1B2AAA004B1B2A002F1B2A8188A65C385AE9865C40E78;18F63085AFA5C385C1A5C485C2206AF620C9F82418A6AEA4AF60A50F19;18F6489D101EA00C20E6F1A5B7F015A01720E6F1A4B7F00CA000B10D7BB;18F660BB20D2FFC8C4B7D0F660A049A593F002A0594CE2F186AE841066;18F678AFAAB50085C1B50185C26C3203A5BAD0034C96F7C903F0F90E38;18F690905FA96185B9A4B7D0034C93F72095F42028F7A5BA2017EE0E45;18F6A8A5B920C0EEA00020D2FBA5AC20E4EEA5AD20E4EE2011FDB00FD4;18F6C016B1ABC20E4EE20E1FFD00720DAF6A9003860201BFDD0E5200E48;18F6D804EF24B93011A5BA2017EEA5B929EF09E020C0EE2004EF180CD3;18F6F060C902D0034CB9F0204DF8908C20B7F8B0252028F7A203A50D9F;18F708B92901D002A2018A20E7F7B01220E6F8B00DA5B92902F0060BF3;18F720A90520E7F7241860A59BD10FBA05120E6F14C59F6A200E6A20D71;18F738D006E6A1D002E6A038A5A2E901A5A1E91AA5A0E94F9006860E47;18F750A086A186A2AD2F91CD2F91D0F885916078A5A2A6A1A4A0780F48;18F76885A286A184A05860A591C9FED0070820CCFF85C62860A9010DE5;18F7802CA9022CA9032CA9042CA9052CA9062CAB9072CA9082CA9090863;18F7984820CCFFA000249D500A20E6F16848093020D2FF683860A50C0B;18F7B0934820C0F8688593B02CA000B1B2C905F024C901F008C9030D41;18F7C8F004C904D0E1AA249D1011A06320E6F1A005B1B220D2FFC80E90;18F7E0C015D0F6188860859E204DF8905EA5C248A5C148A5AF48AB50E9E;18F7F8AE48A0BFA92091B288D0FBA59E91B2C8A5C191B2C8A5C2911172;18F810B2C8A5AE91B2C8A5AF91B2C8849FA000849EA49EC4B7F00C0FF5;18F828B1BBA49F91B2E69EE69FD0EE2054F8A96985AB20EAF8A86810B1;18F84085AE6885AF6885C16885C29860A6B2A4B3C00260204DF88A0E34;18F8588B5C11869C085AE9885C2690085AF6020AFF7B01DA005849F0D59;18F870A000849EC4B7F010B1BBA49FD1B2D0E7E69EE69FA49ED0EC11AD;18F8881860204DF8E6A6A4A6C0C06020ABF8F01CA01B20E6F1204B0E17;18F8A0F920ABF8D0F8A06A4CE6F1A9402C1F91D0032C1F911860200D6D;18F8B8ABF8F0F9A02ED0DBBA900859085932054F82094F8B01F78A90FAB;18F8D00085AA85B485B0859E859F859CA982A20ED0112054F8A9140DCA;18F8E885AB20B7F8B06878A9A0A208A07F8C2E918D2E912060F1AD0E4E;18F90014038D9F02AD15038DA00220FBFCA90285BE20DBFBAD1C910B9F;18F91829FD090C8D1C9185C0A2FFA0FF88DB0FDCAD0F88D299158AD0F56;18F930A002CD150318F01F204BF9AD2D912940F0EDAD14912034F70BA1;18F9484C2FF920E1FF18D00B20CFFC386868A9008DA0026086B1A50CC7;18F960B00A0A1865B01865B185B1A90024B030012A06B12A06B12A0960;18F978AAAD2891C91590F965B18D24918A6D29918D2591586B0AE290CDB;18F99091A0FF98ED2891EC2991D0F286B1AA8C28918C299198E5B11011;18F9A886B14A66B14A66B1A5B018693C2C2191C5B1B04AA69CF0030D47;18F9C04CADFAA6A3301BA200693065B0C5B1B01CE8692665B0C5B10DEC;18F9D8B017692C65B0C5B190034C60FAA5B4F01D85A8D019E6A9B00EC4;18FB9F002C6A938E913E5B165928592A5A4490185A4F02186D7A5B40ECD;18FA08F0182C2D915013A90085A4A5A3103030C9A2A6205DF9A59B0BC0;18FA20D0C34C56FFA592F0073003C6B02CE6B0A9008592E4D7D00F0E59;18FA388AD0AAA5A930C7C91090C38596B0BF8A459B859BA5B4F0D20FEE;18FA50C6A330C546DB766BFA2DA205DF94C56FFA596F004A5B4F0040F11;18FA68A5A3108546B1A99338E5B165B00AAA205DF9E69CA5B4D0110E53;18FA80A596F02685A8A9008596A9C08D2E9185B4A59685B5F009A90ED9;18FA980085B4A9408D2E91A5BF85BDA5A805A985B64C56FF20DBFB0E8B;18FAB0859CA2DA205DF9A5BEF00285AB7A90F24AA1017A5B5D00CA60DDF;18FAC8BECAD00BA908206AFED004A90085AA4C56FF7031D018A5B50DA6;18FAE0D0F5A5B6D0F1A5A74AA5BD3003901818B015290F85AAC6AA0E5A;18FAF8D0DDA94085AA20D2FBA90085ABF0D0A98085AAD0CAA5B5F01191;18FB100AA904206AFEA9004C97FB2011FD90034C95FBAB6A7CAF02D0CBA;18FB28A593F00CA000A5BDD1ACF004A90185B6A5B6F04BA23DE49E0EBE;18FB40903EA69EA5AD9D0101A5AC9D0001E8E8869E4C87FBA69FE40E30;18FB589EF035A5ACDD0001D02EA5ADDD0101D027E69FE69FA593F00EB5;18FB700BA5BDA000D1ACF017C884B6A5B6F007A910206AFED009A50E27B;18FB8893D005A8A5BD91AC201BFDD03AA98085AAA6BECA300286BE0E88;18FBA0C6A7F008A59ED02785BEF02320CFFC20D2FBA00084ABB1AC0FAC;18FBB845AB85AB201BFD2011FD90F2A5AB45BDF005A920206AFE4C0DB7;18FBD056FFA5C285ADA5C185AC60A90885A3A90085A485A8859B850F45;18FBE8A960A5BBD4AA9609002A9B0A2008D28918E2991AD209149080C83;18FC008D20912908603866AD303CA5A8D012A910A20120F5FBD02F0B34;18FC18E6A8A5AD10294C95FCA5A9D00920F1FBD01DE6A9D01920EA0EC4;18FC30FBD014A5A4490185A4F00FA5BD490185BD2901459B859B4C0C42;18FC4856FF46BDC6A3A5A3F03A1B 0F320DBFB58A5A5F012A20086D70F2B;18FC60C6A5A6BEE002D002098085BDD0D92011FD900AD091E6ADA50ECC;18FC78D785BDB0CAA000B1AC85BD45D785D7201BFDD0BBA59B49010F23;18FC9085BD4C56FFC6BED0032008FDA95085A7A2087820FBFCD0EA0F1B;18FCA8A97820F3FBD0E3C6A7D0DF20DBFBC6AB10DB!8A20A20FBFC581124;18FCC0E6ABA5BEF03020D2FBA20986A5D08508782008FDA97F8D2E0E88;18FCD891A9F78D2091A9408D2B912039FEADA002F0098D1503AD9F0D1D;18FCF0028D1403286020CFFCF097BDE9FD8D1403BDEAFD8D1503600D94;18FD08AD1C91090E8D1C916038A5ACE5AEA5ADE5AF60E6ACD002E60B"DD4;18FD20AD60A2FF789AD8203FFDD0036C00A0208DFD2052FD20F9FD0E37;18FD382018E5586C00C0A205BD4CFDDD03A0D003CAD0F5604130C30D11;18FD50C2CDA26DA0FD1886C384C4A01FB91403B002B1C391C399140DFF;18FD68038810F160BFEAD2FEADFE0AF44AF3C7F209F3F3F30EF27A10DD;18FD80F27B#0F7F5F1EFF3D2FE49F585F6A900AA95009D00029D00030F66;18FD98E8D0F5A23CA00386B284B385C185978D8102A8A90485C2E60F3E;18FDB0C1D002E6C22091FEA597F022B0F1A4C2A6C1C0209025C0210FE1;18FDC8B008A01E8C88024C7BFEA9128D8202A9108D8802D0F190CF0CEA;18FDE0A5C28D82028597C91B$190C420C3E54CEBFDA8FC0BFCBFEA8E1095;18FDF8F9A97F8D1E918D2E91A9408D2B91A9408D1B91A9FE8D1C910DEB;18FE10A9DE8D2C91A2008E1291A2FF8E2291A2008E2391A2808E130C53;18FE2891A2008E1F912084EFA9828D1E91208DEFA9C08D2E91A9260CC9;18FE408D2491A9488D25916085B786BB84BC6B%085B886BA84B960A50E08;18FE58BAC902D00BAD9702A9008D970260859DA59005908590608D0C31;18FE708502609006AE8302AC84028E83028C8402609006AE8102AC0A60;18FE8882028E81028C820260B1C1AAA95591C1D1C1D0086A91C1D10E06;18FEA0C1D001A9188A91C160786C1803488A489848AD1D91104B&82D0B1E;18FEB81E91AA2902F01F203FFDD0036C02A02C11912034F720E1FF0BB7;18FED0D02D2052FD20F9FD2018E56C02C0AD1E91098048A97F8D1E0CB3;18FEE8918A2940F014A9CE05B58D1C91AD1491688D1E9120A3EF4C0CE5;18FF0056FF8A2920F025AD1091290185A7AD1891E9166D99028D180AFA;18FF1B'891AD19916D9A028D1991688D1E912036F04C56FF8A2910F00B95;18FF3025AD9302290FD0000AAABD5AFF8D1891BD5BFF8D1991AD100BC1;18FF489168092029EF8D1E91AE980286A868A868AA6840E62A781C0BB9;18FF604913B10F0A0ED30638036A01D00083003600488A489848BA0867;18FF78BD04012910F00C 36C16036C1403FFFFFFFFFF4C52FD4C57FD0CBB;18FF904C66FE4CC0EE4CCEEE4C73FE4C82FE4C1EEB4C6FFE4C19EF0F44;18FFA84CE4EE4CF6EE4C04EF4C17EE4C14EE4C57FE4C50FE4C49FE0EB9;18FFC06C1A036C1C036C1E036C20036C22036C24036C26034C42F50743;18FFD84C75F64C67F74C60F76C28036C2 SA036C2C034C34F74C05E50B6B;10FFF04C0AE54C00E5FFFFFFFFA9FE22FD72FF0C9E;0002AB00ADD5AFF8D1891BD5BFF8D1991AD100BC1;18FF489168092029EF8D1E91AE980286A868A868AA6840E62A781C0BB9;18FF604913B10F0A0ED30638036A01D00083003600488A489848BA0867;18FF78BD04012910F00C xgCBMBASIC0AȤ˾ˀ̤ɟp'Ȃ:.J,dRa#ʟVț]ƅ&zA9X  }Ӟqߔah|eԭ׋ ,7yiyR{*{zPF}ZdENFONEXDATINPUTINPUDIREALEGOTRUIRESTORGOSURETURRESTOOWAILOASAVVERIFDEPOCKPRINTPRINCONLISCLCMSYOPECLOSGENETABTFSPCTHENOSTEЫANOҾSGINABUSFRPOSQRNLOEXCOSITAATPEELESTRVAASCHRLEFTRIGHTMIDG TOO MANY FILEFILE OPEFILE NOT OPEFILE NOT FOUNDEVICE NOT PRESENNOT INPUT FILNOT OUTPUTC FILMISSING FILE NAMILLEGAL DEVICE NUMBENEXT WITHOUT FOSYNTARETURN WITHOUT GOSUOUT OF DATILLEGAL QUANTITOVERFLOOUT OF MEMORUNDEF'D STATEMENBAD SUBSCRIPREDIM'D ARRADIVISION BY ZERILLEGAL DIRECTYPE MISMATCSTRING TOO LONFILE DATFORMULA TOOC COMPLECAN'T CONTINUUNDEF'D FUNCTIOVERIFLOAĞ%5;OZjrªº $ÃOK  ERROR  IN  
READY.
 
BREAK Ɂ!J
IJIi` ą128Z_"[`#Z8"Z[8X"XYZXZX[CY`
i>5"".`4(3"H	HW &բha0hh43`l 
&Å"'Å#    Eˠ "H) Gh zƩi ˤ: ݩv ˩ l `ņz{ s : yL k yń ƐD_#-"`%__e--$.i.`8_-%e"#"$#% Y 3ŭC -ZeX.[ȄY å12-._ Y 3Lĥ+,"#"ȱ"Șe" "#i ȑ""#`   YL7Llz > 7"V$p-?%0<q z 8ɀ0qș68:I8UП șCzȹд {z`+,_`_ȥ_	_
__` +ȑ++i-,i . Ʃ - 7834-./012 ȢhhHH >`+iz,i{`ɫ k  y ɫЎ s  kІhh_C , ȱ_ȱ_,I ݩ C	I) G"I__ȱ__`еLtl$08Iȹ0ȹ0 G  ihh	  ezH{i H:H9H   ͥf	%bbǅ"#LCΩ  y ɩ s   + 8ΥJHIHH ,ȥz{=> zCzLKȱz9ȱz:ezz{l s  LC
<逐#
HHLs L:LK s  L8+,AB` <z{:=>9:;<hhÐLiLt>L7ĥ=z{;<9:`  (LY `Lȩ å{HzH:H9HH y  L k 	89:8ez{+, Ɛ_z` {`J Úɍ,L7LhCh9h:hzh{ ɘezz{`:,  z"  y ɉ Υa 	 y LL HɍɉБehL s  k,h` /"ԥ
&"
&"e"e&e s Lq ЅIJ ΥHH h* h  Ѡ dIȥeI`LhJL = Cafq  qq  ܪ ڤq  ܦdceL"  LH/L~ݠd4d3e.d-deLhʠ d uԥPQop z֩a PQ ֠ PIȱPIȱPI` L ,  (L ! y 5CɣPɦK,7;^ $0   ! ;ө   G$
 GI`C8 8Ii8 	 )Y(	 s L ;  ֪ " G L(˥ ,,? 	)`0?@9:LϥL7ĩ ˥=>z{` # s  ש, Ά  @ ̦` ש, Ά  ˥  `" Ω;  ! ө, ˥ ) CLȭ  Lȥ E ;L`ŦAB, CD ЅIJz{KLCDz{ y  $P ! 0u E ˆz{ s $1$P	z ":,z{i    L ܥ  y ,LM˥z{CDKLz{ y - L Ȫȱzlȱz?ȱzȅ@  y LQ̥CDCL'Ƞ CL`?EXTRA IGNORED ?REDO FROM START   ЅIJ 
L7ĚiHi$h ۺ	fIJ g ۠ ]ܺ8	9:z{LǊi y , s  $ $8$0`L7Ħz{z $HH  Ω M y 8鱐*IEMMaM s LͦM,{iweCL=i"
e"hـg H  hKV_F*z{zMـHٹHH 3ΥMLLϥfh""h#H ܥeHdHcHbHaHl" h#d ̈́KhJhihjhkhlhmhnEfoa`l
  s L ѐL( Ls Iڡ.ɫXɪ"z{i  Lɨ; ѥeIdICLɥLɴL  ͩ),(,, zLs L7ĠhhL8d ede` ЅdeEF& p ϐT τ^q]$ hLo`$ dȱdL ϐ-TI% ϘLO dce b`S
T L<ܥdeL
H s      heHdHH hHL h꿅UCV T L͠,  ѥdEeE  ѥeE%EdE%EL Ͱn	%jji  [ܪLaЩ M օabclm ֆlm8aaff0lb*%L< Ϊ  y `  y E y  ѰLϢ  s  ѐ s  Ѱ$%ЩEE	 s CF8(LѠ -.`_0/"E_F_}_iA[8`hH*`EFTILST/0_`12Z[iȅXY åXYȅ/0 E_ȥF_ ȑ_ȑ_ȑ_ȑ_ȑ__i`ȅGH`
ie_`ȅXY`    ѥde` s   ͥf0aɐ	 [zLܥHHC HFHEH hEhFhHHde y ,҄ hh)/0_`219 _EF_ȱ_e_ȱ_e`ע,L7Ģ ѥ_L  Ġ rE_ȥF_ʆqȑ_ $Phihi ȑ_Ȋ_ Lӆqr"eY]YeXR ą12 rqXYrY81C__2`_bȱ_ qrhdhe_Ȋ_LEL5ȥrq
 Lӊed"eeqʅrEʥFʆ(  UӊeXGeYHG`"_(_)]  
*q&re(e)]`  &83142 bcLD8  :Р,L7   Ω   Ω HHHGHC{HzH LOԩ 	 ЅNOL ӥOHNH  hNhONGȱNHȱGHH ۥ{HzHNzȱN{HHGH hNhO y Lhzh{ hNhȑNhȑNhȑNhȑN` ͠  hh dePQ Ԇbca`"opbcȱo"aeoqprp uԦop ֦"L7Cĥa bc dep`FHI8e34213456h`0 &թhЦ7834 ON12_` "# S-."#0/ XYSXY21Lօ"# "ȱ"ȱ"eXXȱ"eYY(ӊ0ȱ" 
ie""##YX "05ȱ"0ȱ"+ȱ"ȱ"C43`__`"#NOSUSe""## `ONU)JUNe_Z`i [34XY äUȥXNYYȑNL*եeHdH  hohp oqdL7 u z֥PQ  ֥op  L͠ oHȱoȱoh"#
H"5he556` ͥde"#  "Hȱ"ȱ"h(43He3C34h"#` ` ׊H }h bhhL aPPHH }ԥPQ hhe""# L aPILשe y )   aKʊH PIee hhUhhhhPhQUHH ` L ֢ `  "LLH s   ѦdeLy  Lئz{qr"ze"$#{C% $H$ y  h $qrz{`   Lץf0aɑ ܥde`HH נ hhL ׊ ` ׆I  y  ׆J EJ%I`Lg ڥfIfEnoaLj ِ< LۦpVii8a$anfIi  Va p0ǨpV $oWaii8IeVp e d cC b G٠ bJcbdcedpepi  af`eVpeemedeldcekcbejbL6ip&e&d&c&b8aIiaaBfbfcfdfefp`fIfbIbcIcdIdeIepIppe
dcb`L7Ģ%phi0pvvvvvj`    ^VyCdv88; 5454   1r +LHҥaHa֠ gة۠ ۩ Pة @ gh ~ݩ L ک &'()p Yڥe Yڥd Yڥc Yڥb ^LLJ	)em)(el('ek'&ej&f&f'f(f)fpJ`"#"m"l"k"nEfon	j"ia`iea0,iCaLإof`fI0hhLL~ ܪi o wa`     ܩڢ o L v ܩ 8aa ajbkc
ldme*	)24(m&l&k&j0⨥memldlkckjbjLO۩@





p(LۢL7ĥ&b'c(d)eL؅"#"e"d"c"f	b"apC`\,W IJ ܆"#e"d"c"f	%b"a"p`nfh`p` ܢ`hp`ap oL8٥a	f*` +܅b cbI* edapfLFf`$% $Ȫı$Ef0a!$	bȱ$cȱ$dȩp$e(fIL1ܥaJ8$f	h Mيa لh`f)FbbCb لh`aɠ  ܄pffI*aeL؅bcde` 
]-g+ s [..E0 s ɫ-
ɪ+f` s \$` 8^LIf_$_På^8]^	 ^ ^g0`LH$_] h80 ~L
H h <ܥnEfoaLjإ^
	d$`0L~

e^
 qz80^L0ݛ>nk'nk( C q ݥ:9bc8 I Lˠ $f- fqȩ0aLߩ 	 (ک] [ [ ] ] I ܢ]i
0	i8^]q.ș 0ș q ey߅edy߅dcy߅cby߅b00ڊIi
i/ȄGqȪ) ].ș qGI)$C!<Цq 0.ȩ+^. 8^-E /8
i:     `    
        

 Ks`     < ܩ piLآN  ۥn ܩN  [ ۘH ٩N  ( hJ
afIfC"`8;)q4X>Vt~w/z*|cYX
~uƀ1r     (ڥpiP #܅V ܥaɈ  ܥi8HiaaiVp S ߩĠ V oh `qr ۩W ( ZW L(څqr ۱qgqȘrqr (ڥqriȅqr gة\ g`5Dz h(F  +07  "#"bȱ"d"cȱ"eLC#  ۩ (ک gئebebcdcd fapa آ L87LcƪL7 ` ` ` ` `  שHCHH(l h` -.+ `, 
 
+, W
 )L7ĥzdL` )L7ĥ{-.v L* LvC$  ` I L      T   I   ከIL L y hh`  y Lϩ    ׆I    J I   ከJI     ֦"#Lݠ g ܩn   ܩ o Sة PإfH Iإf0	I ߩ gh ߩL@ ۩ C% hN  W  ۩ f N LHLIڢIڢ    -(h#5ᆥ](IڢfH ߥaHɁ ۩; @hɁݠ PhL`vy{|g|S}dpL}Qz}c0~~D:~L̑     [  Ltz{`:
 808`ORXLT H҅C&хsS h8 +,8 7834 ++,`+, ĩ6 ˥78+8, ݩ) LD BYTES FREE **** CBM BASIC V2 **** :ă|ǆ΢O `   zXLt 3Lw,)ߍ,`,	 ,`C'J`LGÅąLj h L``ք ֤` 孈)

	) ϩ܍덐
̭ͅ	 i٢  ӄ֦֥Ӵ0i)ҽѩ0iD ` L `w xwƘX` Bƅ̍xή   Ƀ	xƽvȤՄб ȄȠ ӄԥ0 ʅȐ
BHHӱ)?$	p	@  Щ BhhD`"Iԩ"`	@	خ  hFhhX` ӥӰ7W*L u֦VL[iյ0L~  `hhХʆ Մ`H׊HH ФӥL L `))? LL. -L 舄 ȱшȱ ѭMDL  ӈՐ	  LiՐ L L!)^ LL?7ձ W$  ꈱȑшȑ ѭL	@L7֥8* % 	 舄L D-L _L	 L0Fɦ uL ؆ǆԆ L i``i``!``ߦ^[]@axyfwpqrstuv}HHHH ~텬 V0  )D		 ! ( Ʀhhhh` uL祬HHHH ~텬 V0 )	 hhhh`) nѱ` ꥬ)	`ѵ)` ~  ѩ` D꘤ӑъ`х)	` )%ͤFϮѰυ I )@ 		),p ,$hhh@ @ˍ !^  ^!!JHhA	8. l˱6),0pI) 5DΌ+΋&ƈ˄ŬwƩ `,͎0VILC
ꪽFGLt^^i!ii13579+\_WRYIP*ADGJL;XVN,/ ZCBM.SFHK:=QETUO@^24680-!#%')D۩_]<?>[=Ϻދ"$&(0ݓ!#%')_ߍ]<?>[=ދ"$&(0ܓLɎ-L
0	-	ʥL❃퓌D&.          LOADRUN ,BXn4J`v	@,	  `H$
8f IFFh ? 	   x  Ja $ J J J JJ8f   ,)	,ƥD	)-)  JX`, jXI @)` @x    X`$08fH Ih` 	_,?   Lx    )-)  L  @ jթJJfJƥ 䥐 磻X`,),`,	,`)-D
) `G0?F ʊEƴ) ` ,0pƴƴpP洢˭J, P ̞`@,@`	 ,P`.ƨ10EFf`ƨb
e祖 ``̜*	J ,0EpD,P,,,L[LJ',)0,p	,p0 `̝,P`LJ()$,,p))`)0`̛` `H)`h`I/O ERROR SEARCHINGFORPRESS PLAYD ON TAPPRESS RECORD & PLAY ON TAPLOADINSAVINGVERIFYINFOUNDOK$t) (`mxL O`ӅʥօLO	ХՅLO8? PH P@ jƦh`h`   ``L  `HhLBhL*hHHH D  Ȅhhh `h 𦗤` L L`L`  L $L L LL`ꅚ`   $L ` HWSN)h } uȥȩ L<) MD  L.b L hƘYYccmm` 0Y`Ycm` 䚰 䙰  `L L
L~春Y	`mcZV OL ML) 6 G
 g(L    ` D`0,( 	 hhL  ķ ` ķ
 ') 
Z
[*Hiȍhi J	 
L u8L{Äl0 LnL `    JJE  % DL 瘟JJ芤 Ѯ j,$P  zLL ML h G	 gZ Sҥ)8Jݠȱİ񲪠eÅeąÅą j $`    ķ`IYL񆮄 l2LD_aL  (           8`  $0 )	  `L M % ()  ) $`Q LY 8O//`xxX` (`,,,,,D,,,	H  $P
 hH	0 h8`H h, $$c  ` M^HHHH ȥȥȥȥȄ ķ Ti hhhh`` Mii `  ķѲ柤` MD榤`   K jL@,,` .۩  T x  T hx.. `  )	)X K-)@ 4L/  8hh `

ee $0***(e$m)D%X`)()򆱪()屆JfJfi<,!űJL0 i0eűi&eűi,eűL`橰Ʃ8eI!ץ,-P 00ɢ ]LV0ư,氩 Ъ0ÅEƣ0Ff ]LVF8e
 ]朥& D.	 @.LV  ]$ j LVp1J0)ƪݩ@  Щʥ
 j L L- ѬK=䞐> 膞L5 .'查 ѬȄ jD	 :0Ƨ'#   E  E  jLV` `J` () I )`8f0< /樥)L	  II)ELVFƣ: X ƥ	 
Б步ׅʠ EDׅ лILVƾ Px x Ƨ ƫآ
 X櫥0 	Ѕx . @+ 9	(` `	`8宥``x ?l   R  Xl L`A0͢mÄĠÑÙ`
J	zpDI    < "¦ %!L{ϥ L.@+@ލ, " #  既 .&$H%``` ```D``Uj`xlHHHH-) ?l, 4 - R  l	H)@h LV) %)mmh 6LV)%) 
Z[h	 )hhh@*xI
8j  6 HHH) llLRLWLfLLLsLLLoLLLLLLLWLPLIllll l"l$l&LBLuLgL`l(l*l,L4LL
L "r+@ލ, " #  既 .&$H%``` ```D``Uj`xlHHHH-) ?l, 4 - R  l	H)@h LV) %)mmh 6LV)%) 
Z[h	 )hhh@*xI
8j  6 HHH) llLRLWLfLLLsLLLoLLLLLLLWLPLIllll l"l$l&LBLuLgL`l(l*l,L4LL
L "r+@ލ, " #  既 .&$H%``` ```                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                